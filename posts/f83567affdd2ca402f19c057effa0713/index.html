<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux】——网络基础：http协议 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Linux】——网络基础：http协议" />
<meta property="og:description" content="目录
前言
应用层
认识协议
协议的概念
传输结构化数据
序列化和反序列化
网络版本计算器
服务器端Server
客户端Client
协议定制
其它
运行效果
HTTP协议
HTTP的简介
认识URL
urlencode和urldecode
HTTP协议格式
HTTP请求
HTTP响应
HTTP的方法 GET和POST方法
POSTMAN演示
HTTP的状态码
HTTP常见header
Cookie和session
前言 本文主要探究理解应用层的作用, 介绍HTTP协议的工作原理，同时介绍一些常用的分析网络问题的工具和方法。在详细了解HTTP协议之后，我们不难发现在网络通信的过程中使用HTTP协议存在安全隐患。因此还会详细介绍基于HTTP协议的HTTPS协议是如何在网络通信的过程中还能够保证数据的安全性。
应用层 应用层是计算机网络体系结构中的一个层级，位于网络协议栈的最顶部。它提供一些应用程序与网络之间的接口，使得应用程序能够通过网络进行通信和数据交换。
在应用层，各种应用程序可以利用不同的协议来实现数据传输和通信。一些常见的应用层协议包括HTTP、FTP、SMTP、DNS等。这些协议定义了数据传输的格式、交互方式和错误处理等规范。
应用层的功能包括数据编码与格式化、数据压缩、安全认证、数据加密、资源共享等。它为用户提供了各种各样的应用，例如网页浏览器、电子邮件客户端、文件传输工具等。
总结来说，应用层是网络协议栈中负责为应用程序提供通信接口的层级，它使得不同的应用程序能够通过网络进行数据交换和通信。
网络应用程序体系结构
从应用程序研发者的角度看，网络体系结构是固定的，并为应用程序提供了特定的服务集合。在另一方面，应用程序体系结构（ application architecture)由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。在选择应用程序体系结构时，应用程序研发者很可能利用现代网络应用程序中所使用的主流体系结构之一:客户-服务器体系结构。
客户——服务器体系结构
在客户-服务器体系结构（client- server architecture）中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。值得注意的是利用客户-服务器体系结构,客户相互之间不直接通信。客户-服务器体系结构的另一个特征是该服务器具有固定的、周知的地址，该地址称为IP地址。因为该服务器具有固定的、周知的地址，并且因为该服务器总是打开的，客户总是能够通过向该服务器的IP地址发送分组来与其联系。具有客户-服务器体系结构的非常著名的应用程序包括Web,FTP以及电子邮件。
在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况。为此，配备大量主机的数据中心(data center)常被用于创建强大的虚拟服务器。一个数据中心能够有数十万台服务器，它们必须要供电和维护。此外，服务提供商必须支付不断出现的互联和带宽费用，以发送和接收到达/来自数据中心的数据。
应用层协议
应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。
其中我们主要介绍HTTP协议：
http：Web的应用层协议是超文本传输协议（即http，它是web的核心）。HTTP由两个程序实现:一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。
认识协议 协议是一种 &#34;约定&#34;。使用过socket网络套接字通信的人应该都知道socket api的接口, 在读写数据时, 都是按 &#34;字符串&#34; 的方式来发送接收的。如果我们要传输一些&#34;结构化的数据&#34; 怎么办呢?比如下面的情况：
我们想要实现一个网络版本的计算器，计算器想要完成一个计算，最好是直接传给它一个包含着两个操作数和一个操作符的结构体对象。但是使用socket通信的时候，UDP/TCP发送的是数据报或者字节流的数据。所以此时我们如果想要发送一些“结构化的数据”就需要制订协议了。
//网络计算器需要的数据是结构体 typedef struct request{ int x; //左操作数 int y; //右操作数 char op; //操作符 }; //网络通信发送的数据是string string request = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f83567affdd2ca402f19c057effa0713/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-09T16:08:16+08:00" />
<meta property="article:modified_time" content="2023-09-09T16:08:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux】——网络基础：http协议</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E5%BA%94%E7%94%A8%E5%B1%82-toc" style="margin-left:0px;"><a href="#%E5%BA%94%E7%94%A8%E5%B1%82" rel="nofollow">应用层</a></p> 
<p id="%E8%AE%A4%E8%AF%86%E5%8D%8F%E8%AE%AE-toc" style="margin-left:0px;"><a href="#%E8%AE%A4%E8%AF%86%E5%8D%8F%E8%AE%AE" rel="nofollow">认识协议</a></p> 
<p id="%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">协议的概念</a></p> 
<p id="%E4%BC%A0%E8%BE%93%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%E4%BC%A0%E8%BE%93%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE" rel="nofollow">传输结构化数据</a></p> 
<p id="%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-toc" style="margin-left:40px;"><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96" rel="nofollow">序列化和反序列化</a></p> 
<p id="%E7%BD%91%E7%BB%9C%E7%89%88%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E7%BD%91%E7%BB%9C%E7%89%88%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8" rel="nofollow">网络版本计算器</a></p> 
<p id="%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AFServer-toc" style="margin-left:80px;"><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AFServer" rel="nofollow">服务器端Server</a></p> 
<p id="%C2%A0%E5%AE%A2%E6%88%B7%E7%AB%AFClient-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%AE%A2%E6%88%B7%E7%AB%AFClient" rel="nofollow"> 客户端Client</a></p> 
<p id="%E5%8D%8F%E8%AE%AE%E5%AE%9A%E5%88%B6-toc" style="margin-left:80px;"><a href="#%E5%8D%8F%E8%AE%AE%E5%AE%9A%E5%88%B6" rel="nofollow">协议定制</a></p> 
<p id="%E5%85%B6%E5%AE%83-toc" style="margin-left:80px;"><a href="#%E5%85%B6%E5%AE%83" rel="nofollow">其它</a></p> 
<p id="%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C-toc" style="margin-left:80px;"><a href="#%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C" rel="nofollow">运行效果</a></p> 
<p id="HTTP%E5%8D%8F%E8%AE%AE-toc" style="margin-left:0px;"><a href="#HTTP%E5%8D%8F%E8%AE%AE" rel="nofollow">HTTP协议</a></p> 
<p id="HTTP%E7%9A%84%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#HTTP%E7%9A%84%E7%AE%80%E4%BB%8B" rel="nofollow">HTTP的简介</a></p> 
<p id="%E8%AE%A4%E8%AF%86URL-toc" style="margin-left:40px;"><a href="#%E8%AE%A4%E8%AF%86URL" rel="nofollow">认识URL</a></p> 
<p id="urlencode%E5%92%8Curldecode-toc" style="margin-left:40px;"><a href="#urlencode%E5%92%8Curldecode" rel="nofollow">urlencode和urldecode</a></p> 
<p id="HTTP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F-toc" style="margin-left:40px;"><a href="#HTTP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F" rel="nofollow">HTTP协议格式</a></p> 
<p id="HTTP%E8%AF%B7%E6%B1%82-toc" style="margin-left:120px;"><a href="#HTTP%E8%AF%B7%E6%B1%82" rel="nofollow">HTTP请求</a></p> 
<p id="HTTP%E5%93%8D%E5%BA%94-toc" style="margin-left:120px;"><a href="#HTTP%E5%93%8D%E5%BA%94" rel="nofollow">HTTP响应</a></p> 
<p id="HTTP%E7%9A%84%E6%96%B9%E6%B3%95%C2%A0-toc" style="margin-left:40px;"><a href="#HTTP%E7%9A%84%E6%96%B9%E6%B3%95%C2%A0" rel="nofollow">HTTP的方法 </a></p> 
<p id="GET%E5%92%8CPOST%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#GET%E5%92%8CPOST%E6%96%B9%E6%B3%95" rel="nofollow">GET和POST方法</a></p> 
<p id="POSTMAN%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px;"><a href="#POSTMAN%E6%BC%94%E7%A4%BA" rel="nofollow">POSTMAN演示</a></p> 
<p id="HTTP%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81-toc" style="margin-left:40px;"><a href="#HTTP%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81" rel="nofollow">HTTP的状态码</a></p> 
<p id="HTTP%E5%B8%B8%E8%A7%81header-toc" style="margin-left:40px;"><a href="#HTTP%E5%B8%B8%E8%A7%81header" rel="nofollow">HTTP常见header</a></p> 
<p id="Cookie%E5%92%8Csession-toc" style="margin-left:40px;"><a href="#Cookie%E5%92%8Csession" rel="nofollow">Cookie和session</a></p> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>        本文主要探究理解应用层的作用, 介绍HTTP协议的工作原理，同时介绍一些常用的分析网络问题的工具和方法。在详细了解HTTP协议之后，我们不难发现在网络通信的过程中使用HTTP协议存在安全隐患。因此还会详细介绍基于HTTP协议的HTTPS协议是如何在网络通信的过程中还能够保证数据的安全性。</p> 
<h2 id="%E5%BA%94%E7%94%A8%E5%B1%82">应用层</h2> 
<p>应用层是计算机网络体系结构中的一个层级，位于网络协议栈的最顶部。它提供一些应用程序与网络之间的接口，使得应用程序能够通过网络进行通信和数据交换。</p> 
<p>在应用层，各种应用程序可以利用不同的协议来实现数据传输和通信。一些常见的应用层协议包括HTTP、FTP、SMTP、DNS等。这些协议定义了数据传输的格式、交互方式和错误处理等规范。</p> 
<p>应用层的功能包括数据编码与格式化、数据压缩、安全认证、数据加密、资源共享等。它为用户提供了各种各样的应用，例如网页浏览器、电子邮件客户端、文件传输工具等。</p> 
<p>总结来说，应用层是网络协议栈中负责为应用程序提供通信接口的层级，它使得不同的应用程序能够通过网络进行数据交换和通信。</p> 
<blockquote> 
 <p id="1.%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A"><strong>网络应用程序体系结构</strong></p> 
</blockquote> 
<p>从应用程序研发者的角度看，网络体系结构是固定的，并为应用程序提供了特定的服务集合。在另一方面，应用程序体系结构（ application architecture)由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。在选择应用程序体系结构时，应用程序研发者很可能利用现代网络应用程序中所使用的主流体系结构之一:<strong><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">客户-服务器体系结构</span></span></strong>。</p> 
<blockquote> 
 <p><strong>客户——服务器体系结构</strong></p> 
</blockquote> 
<p>在客户-服务器体系结构（client- server architecture）中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。值得注意的是利用客户-服务器体系结构,客户相互之间不直接通信。客户-服务器体系结构的另一个特征是该服务器具有固定的、周知的地址，该地址称为IP地址。因为该服务器具有固定的、周知的地址，并且因为该服务器总是打开的，客户总是能够通过向该服务器的IP地址发送分组来与其联系。具有客户-服务器体系结构的非常著名的应用程序包括Web,FTP以及电子邮件。</p> 
<p>在一个客户-服务器应用中，常常会出现一台单独的服务器主机跟不上它所有客户请求的情况。为此，配备大量主机的数据中心(data center)常被用于创建强大的虚拟服务器。一个数据中心能够有数十万台服务器，它们必须要供电和维护。此外，服务提供商必须支付不断出现的互联和带宽费用，以发送和接收到达/来自数据中心的数据。</p> 
<blockquote> 
 <p>应用层协议</p> 
</blockquote> 
<p><strong>应用层协议</strong>定义了运行在不同端系统上的应用程序进程如何相互传递报文。</p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/df/0b/EQxke6yG_o.png" width="1200"></p> 
<p>其中我们主要介绍HTTP协议：</p> 
<p><strong>http：Web的应用层协议是超文本传输协议（即http，它是web的核心）。</strong>HTTP由两个程序实现:一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。</p> 
<hr> 
<h2 id="%E8%AE%A4%E8%AF%86%E5%8D%8F%E8%AE%AE">认识协议</h2> 
<p>协议是一种 "约定"。使用过socket网络套接字通信的人应该都知道socket api的接口, 在读写数据时, 都是按 "字符串" 的方式来发送接收的。如果我们要传输一些"结构化的数据" 怎么办呢?比如下面的情况：</p> 
<p>        我们想要实现一个网络版本的计算器，计算器想要完成一个计算，最好是直接传给它一个包含着两个操作数和一个操作符的结构体对象。但是使用socket通信的时候，UDP/TCP发送的是数据报或者字节流的数据。<span style="color:#fe2c24;"><strong>所以此时我们如果想要发送一些“结构化的数据”就需要制订协议了。</strong></span></p> 
<pre><code class="language-cpp">//网络计算器需要的数据是结构体
typedef struct request{
	int x; //左操作数
	int y; //右操作数
	char op; //操作符
};

//网络通信发送的数据是string
string request = "10+20";</code></pre> 
<h3 id="%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A6%82%E5%BF%B5">协议的概念</h3> 
<blockquote> 
 <p>协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定，比如怎么建立连接、怎么互相识别等。</p> 
</blockquote> 
<p>为了使数据在网络上能够从源到达目的，网络通信的参与方必须遵循相同的规则，我们将这套规则称为协议（protocol），而协议最终都需要通过计算机语言的方式表示出来。只有通信计算机双方都遵守相同的协议，计算机之间才能互相通信交流。</p> 
<h3 id="%E4%BC%A0%E8%BE%93%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE" style="background-color:transparent;">传输结构化数据</h3> 
<p>通信双方在进行网络通信时：</p> 
<ul><li>如果需要传输的数据是一个字符串，那么直接将这一个字符串发送到网络当中，此时对端也能从网络当中获取到这个字符串。</li><li>但如果需要传输的是一些结构化的数据，此时就不能将这些数据一个个发送到网络当中。</li></ul> 
<p>比如上面提到的网络版本计算器，如果客户端将这些结构化的数据单独一个个的发送到网络当中，那么服务端从网络当中获取这些数据时也只能一个个获取，此时服务端还需要纠结如何将接收到的数据进行组合。因此客户端最好把这些结构化的数据打包后统一发送到网络当中，此时服务端每次从网络当中获取到的就是一个完整的请求数据，客户端常见的“打包”方式如下。</p> 
<ul><li>定制结构体来表示需要交互的信息。</li><li>发送数据时将这个结构体按照一个规则转换成网络标准数据格式，接收数据时再按照相同的规则把接收到的数据转化为结构体。</li><li>这个过程叫做“序列化”和“反序列化”。</li></ul> 
<p>客户端可以定制一个结构体，将需要交互的信息定义到这个结构体当中。客户端发送数据时先对数据进行序列化，服务端接收到数据后再对其进行反序列化，此时服务端就能得到客户端发送过来的结构体，进而从该结构体当中提取出对应的信息。</p> 
<h3 id="%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">序列化和反序列化</h3> 
<p><strong><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">序列化：struct--&gt;string        反序列化： string--&gt;struct</span></span></strong></p> 
<ul><li>序列化是将对象的状态信息转换为可以存储或传输的形式（字节序列）的过程。</li><li>反序列化是把字节序列恢复为对象的过程。</li></ul> 
<blockquote> 
 <p>序列化和反序列化的目的</p> 
</blockquote> 
<ul><li>在网络传输时，序列化目的是为了方便网络数据的发送和接收，无论是何种类型的数据，经过序列化后都变成了二进制序列，此时底层在进行网络数据传输时看到的统一都是二进制序列。</li><li>序列化后的二进制序列只有在网络传输时能够被底层识别，上层应用是无法识别序列化后的二进制序列的，因此需要将从网络中获取到的数据进行反序列化，将二进制序列的数据转换成应用层能够识别的数据格式。</li></ul> 
<p>我们可以认为网络通信和业务处理处于不同的层级，在进行网络通信时底层看到的都是二进制序列的数据，而在进行业务处理时看得到则是可被上层识别的数据。如果数据需要在业务处理和网络通信之间进行转换，则需要对数据进行对应的序列化或反序列化操作。</p> 
<p><img alt="" height="597" src="https://images2.imgbox.com/21/93/Wns6Xzys_o.png" width="1200"></p> 
<h3 id="%E7%BD%91%E7%BB%9C%E7%89%88%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8">网络版本计算器</h3> 
<p>下面实现一个网络版的计算器，主要目的是感受一下什么是协议，以及体会序列化和反序列化的过程。</p> 
<h4 id="%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AFServer">服务器端Server</h4> 
<p>在写服务端之前，我们先对库函数中的socket封装一下，方便我们使用。</p> 
<p>我们自己定义一个sock对象，该sock对象支持bind，listen，accept，connect功能。因此之后在写服务端时只需要调用bind，listen，accept函数。客户端就只用调用connect函数，省去每端初始化套接字的过程。</p> 
<pre><code class="language-cpp">#include &lt;sys/types.h&gt; /* See NOTES */
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#include "Log.hpp"
#include "Err.hpp"

static const int gbacklog = 32;
static const int defaultfd = -1;

class Sock
{
public:
    Sock() : _sock(defaultfd)
    {
    }
    void Socket()
    {
        _sock = socket(AF_INET, SOCK_STREAM, 0);
        if (_sock &lt; 0)
        {
            logMessage(Fatal, "socket error, code: %d, errstring: %s", errno, strerror(errno));
            exit(SOCKET_ERR);
        }
    }
    void Bind(const uint16_t &amp;port)
    {
        struct sockaddr_in local;
        memset(&amp;local, 0, sizeof(local));

        local.sin_family = AF_INET;
        local.sin_port = htons(port);
        local.sin_addr.s_addr = INADDR_ANY;

        if (bind(_sock, (struct sockaddr *)&amp;local, sizeof(local)) &lt; 0)
        {
            logMessage(Fatal, "bind error, code: %d, errstring: %s", errno, strerror(errno));
            exit(BIND_ERR);
        }
    }

    void Listen()
    {
        if(listen(_sock,gbacklog) &lt;0)
        {
            logMessage(Fatal, "listen error, code: %d, errstring: %s", errno, strerror(errno));
            exit(LISTEN_ERR);
        }
    }

    int Accept(std::string *clientip, uint16_t *clientport)
    {
        struct sockaddr_in temp;
        socklen_t len = sizeof(temp);

        int sock = accept(_sock,(struct sockaddr *)&amp;temp, &amp;len);
        if (sock &lt; 0)
        {
            logMessage(Warning, "accept error, code: %d, errstring: %s", errno, strerror(errno));
        }
        else
        {
            *clientip = inet_ntoa(temp.sin_addr);
            *clientport = ntohs(temp.sin_port);
        }
        return sock;
    }

    int Connect(const std::string &amp;serverip, const uint16_t &amp;serverport)
    {
        struct sockaddr_in server;
        memset(&amp;server, 0, sizeof(server));
        server.sin_family = AF_INET;
        server.sin_port = htons(serverport);
        server.sin_addr.s_addr = inet_addr(serverip.c_str());

        return connect(_sock, (struct sockaddr *)&amp;server, sizeof(server));
    }

    int Fd()
    {
        return _sock;
    }
    void Close()
    {
        if (_sock != defaultfd)
            close(_sock);
    }
    ~Sock()
    {
        
    }



private:
    int _sock;
};</code></pre> 
<p>服务器端我们需要首先对服务器进行初始化工作，建立套接字，bind端口号，并将服务器设置为listen状态。初始化工作完成后，我们就可以启动服务器，在这里我们使用多线程，可以让服务器同时接收来自多个客户端的消息。</p> 
<pre><code class="language-cpp">#pragma once

#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;functional&gt;
#include "Sock.hpp"
#include "Protocol.hpp"
#include &lt;memory.h&gt;

namespace tcpserver_ns
{
    class TcpServer;

    class ThreadData
    {
    public:
        ThreadData(int sock, std::string ip, uint16_t port, TcpServer *p)
            : _sock(sock), _ip(ip), _port(port), _tsvrp(p)
        {
        }
        ~ThreadData() {}

    public:
        int _sock;
        std::string _ip;
        uint16_t _port;
        TcpServer *_tsvrp;
    };

    using namespace protocol_ns;

    using func_t = std::function&lt;Response(const Request &amp;)&gt;;

    class TcpServer
    {
    public:
        TcpServer(func_t fuc, uint16_t port) : _func(fuc), _port(port)
        {
        }
        void InitServer()
        {
            // 1.初始化服务器
            _listensock.Socket();
            _listensock.Bind(_port);
            _listensock.Listen();
            // 初始化成功，打印日志
            logMessage(Info, "init server done, listensock: %d", _listensock.Fd());
        }

        void StartServer()
        {
            // 启动服务器（多线程方式）
            for (;;)
            {
                std::string clientip;
                uint16_t clientport;
                int sock = _listensock.Accept(&amp;clientip, &amp;clientport);
                if (sock &lt; 0)
                    continue;
                logMessage(Debug, "get a new client, client info : [%s:%d]", clientip.c_str(), clientport);

                pthread_t tid;
                ThreadData *td = new ThreadData(sock, clientip, clientport, this);
                pthread_create(&amp;tid, nullptr, ThreadRoutine, td);
            }
        }

        static void *ThreadRoutine(void *args)
        {
            pthread_detach(pthread_self());
            ThreadData *td = static_cast&lt;ThreadData *&gt;(args);
            td-&gt;_tsvrp-&gt;ServiceIO(td-&gt;_sock, td-&gt;_ip, td-&gt;_port);
            logMessage(Debug, "thread quit, client quit ...");
        }

        void ServiceIO(int sock, const std::string &amp;ip, const uint16_t &amp;port)
        {
            std::string inbuffer;
            while (true)
            {
                // 0. 你怎么保证你读到了一个完整的字符串报文？"7"\r\n""10 + 20"\r\n
                std::string package;
                int n = ReadPackage(sock, inbuffer, &amp;package);
                if (n == -1)
                    break;
                else if (n == 0)
                    continue;

                else
                {
                    // 一定得到了一个"7"\r\n""10 + 20"\r\n
                    // 1. 你需要的只是有效载荷"10 + 20",要提取有效载荷
                    package = RemoveHeader(package, n);
                    // 2. 已经读到了一个完整的string
                    Request req;
                    req.Deserialize(package);// 对读到的request字符串要进行反序列化

                    // 3. 直接提取用户的请求数据啦
                    Response resp = _func(req);
                    
                    // 4. 给用户返回响应 - 序列化
                    std::string send_string;
                    resp.Serialize(&amp;send_string);
                    
                    // 5. 添加报头
                    send_string = AddHeader(send_string);
                    // 6. 发送
                    send(sock, send_string.c_str(), send_string.size(), 0);
                }
            }
        }

        ~TcpServer()
        {
        }

    private:
        uint16_t _port;
        Sock _listensock;
        func_t _func;
    };

}
</code></pre> 
<pre><code class="language-cpp">#include "TcpServer.hpp"
#include &lt;memory&gt;
using namespace tcpserver_ns;
Response calculate(const Request &amp;req)
{
    // 走到这里，一定保证req是有具体数据的！
    // _result(result), _code(code)
    Response resp(0, 0);
    switch (req._op)
    {
    case '+':
        resp._result = req._x + req._y;
        break;
    case '-':
        resp._result = req._x - req._y;
        break;
    case '*':
        resp._result = req._x * req._y;
        break;
    case '/':
        if (req._y == 0)
            resp._code = 1;
        else
            resp._result = req._x / req._y;
        break;
    case '%':
        if (req._y == 0)
            resp._code = 2;
        else
            resp._result = req._x % req._y;
        break;
    default:
        resp._code = 3;
        break;
    }

    return resp;
}

int main()
{
    uint16_t port = 8888;
    std::unique_ptr&lt;TcpServer&gt; tsvr(new TcpServer(calculate,port));
    tsvr-&gt;InitServer();
    tsvr-&gt;StartServer();

    return 0;
}</code></pre> 
<p></p> 
<h4 id="%C2%A0%E5%AE%A2%E6%88%B7%E7%AB%AFClient"> 客户端Client</h4> 
<p>客户端首先也需要进行初始化：调用socket函数，创建套接字。客户端初始化完毕后需要调用connect函数连接服务端，当连接服务端成功后，客户端就可以向服务端发起计算请求了。这里可以让用户输入两个操作数和一个操作符构建一个计算请求，然后将该请求发送给服务端。而当服务端处理完该计算请求后，会对客户端进行响应，因此客户端发送完请求后还需要读取服务端发来的响应数据。客户端在向服务端发送或接收数据时，可以使用write或read函数进行发送或接收，也可以使用send或recv函数对应进行发送或接收。</p> 
<pre><code class="language-cpp">#include "TcpClient.hpp"
#include "Sock.hpp"
#include "Protocol.hpp"

#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace protocol_ns;

static void usage(std::string proc)
{
    std::cout &lt;&lt; "Usage:\n\t" &lt;&lt; proc &lt;&lt; " serverip serverport\n"
              &lt;&lt; std::endl;
}

enum
{
    LEFT,
    OPER,
    RIGHT
};
// 将输入的一行数据转化为请求的函数
Request ParseLine(const std::string &amp;line)
{
    std::string left, right;
    char op;
    int status = LEFT;

    int i = 0;
    while (i &lt; line.size())
    {
        // if(isdigit(e)) left.push_back;

        switch (status)
        {
        case LEFT:
            if (isdigit(line[i]))
                left.push_back(line[i++]);
            else
                status = OPER;
            break;
        case OPER:
            op = line[i++];
            status = RIGHT;
            break;
        case RIGHT:
            if (isdigit(line[i]))
                right.push_back(line[i++]);
            break;
        }
    }

    Request req;
    std::cout &lt;&lt; "left: " &lt;&lt; left &lt;&lt; std::endl;
    std::cout &lt;&lt; "right: " &lt;&lt; right &lt;&lt; std::endl;
    std::cout &lt;&lt; "op: " &lt;&lt; op &lt;&lt; std::endl;

    req._x = std::stoi(left);
    req._y = std::stoi(right);
    req._op = op;

    return req;
}

int main(int argc, char *argv[])
{
    if (argc != 3)
    {
        usage(argv[0]);
        exit(USAGE_ERR);
    }

    std::string serverip = argv[1];
    uint16_t serverport = atoi(argv[2]);

    Sock sock;
    sock.Socket();

    int n = sock.Connect(serverip, serverport);
    if (n != 0)
    {
        logMessage(Error, "client connect fail...");
    }

    std::string buffer;
    while (true)
    {
        std::cout &lt;&lt; "Enter# ";
        std::string line;
        getline(std::cin, line);
        Request req = ParseLine(line);

        std::cout &lt;&lt; "test: " &lt;&lt; req._x &lt;&lt; req._op &lt;&lt; req._y &lt;&lt; std::endl;

        // 1. 序列化
        std::string sendString;
        req.Serialize(&amp;sendString);

        // 2. 添加报头
        sendString = AddHeader(sendString);
        // 3. send
        send(sock.Fd(), sendString.c_str(), sendString.size(), 0);

        // 4. 获取响应
        std::string package;
        int n = 0;
    START:
        n = ReadPackage(sock.Fd(), buffer, &amp;package);
        if (n == 0)
            goto START;
        else if (n &lt; 0)
            break;
        else
        {

            // 5. 去掉报头
            package = RemoveHeader(package, n);

            // 6. 反序列化
            Response resp;
            resp.Deserialize(package);

            std::cout &lt;&lt; "result: " &lt;&lt; resp._result &lt;&lt; "[code: " &lt;&lt; resp._code &lt;&lt; "]" &lt;&lt; std::endl;
            // sleep(100);
        }
    }


    return 0;
}</code></pre> 
<h4 id="%E5%8D%8F%E8%AE%AE%E5%AE%9A%E5%88%B6">协议定制</h4> 
<p>要实现一个网络版的计算器，就必须保证通信双方能够遵守某种协议约定，因此我们需要设计一套简单的约定。数据可以分为请求数据和响应数据，因此我们分别需要对请求数据和响应数据进行约定。</p> 
<p>在实现时可以采用C++当中的类来实现，也可以直接采用结构体来实现，这里就使用结构体来实现，此时就需要一个请求结构体和一个响应结构体。</p> 
<ul><li>请求结构体中需要包括两个操作数，以及对应需要进行的操作。</li><li>响应结构体中需要包括一个计算结果，除此之外，响应结构体中还需要包括一个状态字段，表示本次计算的状态，因为客户端发来的计算请求可能是无意义的。</li></ul> 
<p>规定状态字段对应的含义：</p> 
<ul><li>状态字段为0，表示计算成功。</li><li>状态字段为1，表示出现除0错误。</li><li>状态字段为2，表示出现模0错误。</li><li>状态字段为3，表示非法计算。</li></ul> 
<p>此时我们就完成了协议的设计，但需要注意，只有当响应结构体当中的状态字段为0时，计算结果才是有意义的，否则计算结果无意义。</p> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">同时在协议中，我们不仅需要定义好应用层需要的结构化数据，更要提供序列化和反序列化的方法，否则只有结构化数据，没用序列化方法也就没有办法发送数据；没有反序列化方法也就无法对收到的数据进行业务处理。</span></strong></p> 
</blockquote> 
<pre><code class="language-cpp">#pragma once

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
// #include &lt;jsoncpp/json/json.h&gt;
#include "Util.hpp"

// 给网络版本计算器制订协议
namespace protocol_ns
{
#define SEP " "
#define SEP_LEN strlen(SEP) // 绝对不能写成sizeof
#define HEADER_SEP "\r\n"
#define HEADER_SEP_LEN strlen("\r\n")


    std::string AddHeader(const std::string &amp;str)
    {
        std::string s = std::to_string(str.size());
        s += HEADER_SEP;
        s += str;
        s += HEADER_SEP;
        return s;
    }

    std::string RemoveHeader(const std::string &amp;str, int len)
    {
        std::string res = str.substr(str.size() - HEADER_SEP_LEN - len, len);
        return res;
    }

    int ReadPackage(int sock, std::string &amp;inbuffer, std::string *package)
    {
        // 边读取
        char buffer[1024];
        ssize_t s = recv(sock, buffer, sizeof(buffer - 1), 0);
        if (s &lt;= 0)
            return -1;
        buffer[s] = 0;
        inbuffer += buffer;

        
        // 边分析， "7"\r\n""10 + 20"\r\n
        auto pos = inbuffer.find(HEADER_SEP);

        //分析读取到的数据流，未找到分隔符，说明没读到完整报文
        if (pos == std::string::npos)
            return 0;                                                    // inbuffer什么都没有动
        
        //找到分隔符
        std::string lenStr = inbuffer.substr(0, pos);                    // 获取了头部字符串
        int len = Util::toInt(lenStr);                                   // "123" -&gt; 123 inbuffer什么都没有动
        int targetPackageLen = lenStr.size() + len + 2 * HEADER_SEP_LEN; // inbuffer什么都没有动
        if (inbuffer.size() &lt; targetPackageLen)
            return 0;                                    // inbuffer什么都没有动
        *package = inbuffer.substr(0, targetPackageLen); // 提取到了一个完整报文，inbuffer还是什么都没有动
        
        
        inbuffer.erase(0, targetPackageLen);             // 读取到完整的报文后，将其从inbuffer中直接移除

        return len;
    }

    class Request
    {
    public:
        Request() {}
        Request(int x, int y, char op)
            : _x(x), _y(y), _op(op)
        {
        }

        //序列化: struct-&gt;string
        bool Serialize(std::string *outStr)
        {
            *outStr = "";

            //手动序列化
            std::string x = std::to_string(_x);
            std::string y = std::to_string(_y);

            *outStr = x + SEP + y + _op + SEP + y;

            return true;
        }

        //反序列化: string-&gt;struct
        bool Deserialize(const std::string &amp;inStr)
        {
            //inStr: 10 + 20  ----&gt; [0]='10' [1]='+' [2]='20'
            //string-&gt;vector
            std::vector&lt;std::string&gt; result;
            Util::StringSplit(inStr,SEP,&amp;result);
            if (result.size() != 3)
                return false;
            if (result[1].size() != 1)
                return false;
            _x = Util::toInt(result[0]);
            _y = Util::toInt(result[2]);
            _op = result[1][0];

            return true;
        }
        ~Request() {}
    public:
        int _x;
        int _y;
        char _op;
    };

    class Response
    {
    public:
        Response() {}
        Response(int result, int code) : _result(result), _code(code)
        {
        }
        
        // struct-&gt;string
        bool Serialize(std::string *outStr)
        {
            *outStr = "";
            //_result _code
            std::string res_string = std::to_string(_result);
            std::string code_string = std::to_string(_code);

            *outStr = res_string + SEP + code_string;

            std::cout &lt;&lt; "Response Serialize:\n"
                      &lt;&lt; *outStr &lt;&lt; std::endl;
            return true;
        }
        
        // string-&gt;struct
        bool Deserialize(const std::string &amp;inStr)
        {
            // 10 0, 10 1
            std::vector&lt;std::string&gt; result;
            Util::StringSplit(inStr, SEP, &amp;result);
            if (result.size() != 2)
                return false;

            _result = Util::toInt(result[0]);
            _code = Util::toInt(result[1]);

            return true;
        }

        ~Response() {}
    public:
        int _result;
        int _code; // 0 success, 1,2,3,4代表不同的错误码
    };



}</code></pre> 
<h4 id="%E5%85%B6%E5%AE%83">其它</h4> 
<p>为了代码的规范易读以及调试工作，我在这里还加入了一个日志系统，并将序列化反序列化过程中会用到的一些字符串转化函数统一定义到了一个Util头文件中。</p> 
<blockquote> 
 <p>Util.hpp</p> 
</blockquote> 
<pre><code class="language-cpp">#pragma once

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;

using namespace std;

class Util
{
public:
    // 输入: const &amp;
    // 输出: *
    // 输入输出: &amp;
    static bool StringSplit(const string &amp;str, const string &amp;sep, vector&lt;std::string&gt; *result)
    {
        size_t start = 0;
        // + 20
        // "abcd efg" -&gt; for(int i = 0; i &lt; 10; i++) !=  for(int i = 0; i &lt;= 9; i++)
        while (start &lt; str.size())
        {
            auto pos = str.find(sep, start);
            if (pos == string::npos) break;
            result-&gt;push_back(str.substr(start, pos-start));
            // 位置的重新reload
            start = pos + sep.size();
        }
        if(start &lt; str.size())  result-&gt;push_back(str.substr(start));
        return true;
    }

    static int toInt(const std::string &amp;s)
    {
        // std::stoi();
        return atoi(s.c_str());
    }
};</code></pre> 
<blockquote> 
 <p>Log.hpp</p> 
</blockquote> 
<pre><code class="language-cpp">#pragma once

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
#include &lt;cstdarg&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

// 日志是有日志等级的

const std::string filename = "log/tcpserver.log";

enum
{
    Debug = 0,
    Info,
    Warning,
    Error,
    Fatal,
    Uknown
};

static std::string toLevelString(int level)
{
    switch (level)
    {
    case Debug:
        return "Debug";
    case Info:
        return "Info";
    case Warning:
        return "Warning";
    case Error:
        return "Error";
    case Fatal:
        return "Fatal";
    default:
        return "Uknown";
    }
}

static std::string getTime()
{
    time_t curr = time(nullptr);
    struct tm *tmp = localtime(&amp;curr);
    char buffer[128];
    snprintf(buffer, sizeof(buffer), "%d-%d-%d %d:%d:%d", tmp-&gt;tm_year + 1900, tmp-&gt;tm_mon+1, tmp-&gt;tm_mday,
             tmp-&gt;tm_hour, tmp-&gt;tm_min, tmp-&gt;tm_sec);
    return buffer;
}

// 日志格式: 日志等级 时间 pid 消息体
// logMessage(DEBUG, "hello: %d, %s", 12, s.c_str()); // DEBUG hello:12, world
void logMessage(int level, const char *format, ...)
{
    char logLeft[1024];
    std::string level_string = toLevelString(level);
    std::string curr_time = getTime();
    snprintf(logLeft, sizeof(logLeft), "[%s] [%s] [%d] ", level_string.c_str(), curr_time.c_str(), getpid());

    char logRight[1024];
    va_list p;
    va_start(p, format);
    vsnprintf(logRight, sizeof(logRight), format, p);
    va_end(p);

    // 打印
    printf("%s%s\n", logLeft, logRight);

    // 保存到文件中
    // FILE *fp = fopen(filename.c_str(), "a");
    // if(fp == nullptr)return;
    // fprintf(fp,"%s%s\n", logLeft, logRight);
    // fflush(fp); //可写也可以不写
    // fclose(fp);


    // 预备
    //  va_list p; // char *
    //  int a = va_arg(p, int);  // 根据类型提取参数
    //  va_start(p, format); //p指向可变参数部分的起始地址
    //  va_end(p); // p = NULL;
}</code></pre> 
<h4 id="%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C">运行效果</h4> 
<p><img alt="" height="807" src="https://images2.imgbox.com/f6/2a/GnvCihdw_o.png" width="1200"></p> 
<hr> 
<h2 id="HTTP%E5%8D%8F%E8%AE%AE">HTTP协议</h2> 
<h3 id="HTTP%E7%9A%84%E7%AE%80%E4%BB%8B">HTTP的简介</h3> 
<p>上文中我们自己制订了一个协议，不难发现即使想要完成一个简单的计算器功能都需要不小的工作量，因此实际在网络通信中不需要我们自己制订协议了，而是存在许多已经优秀的工程师制订好的协议，我们只需要学习如何使用即可。</p> 
<blockquote> 
 <p>HTTP（Hyper Text Transfer Protocol）协议又叫做超文本传输协议，是一个简单的请求-响应协议，TCP是字节流传输，HTTP通常运行在TCP之上。</p> 
</blockquote> 
<h3 id="%E8%AE%A4%E8%AF%86URL">认识URL</h3> 
<blockquote> 
 <p>URL（Uniform Resource Lacator）叫做统一资源定位符，也就是我们通常所说的网址，是因特网的万维网服务程序上用于指定信息位置的表示方法。</p> 
</blockquote> 
<p>一个URL大致由如下几部分构成： </p> 
<p><img alt="" height="227" src="https://images2.imgbox.com/e0/75/XfPrbmM3_o.png" width="1110"></p> 
<blockquote> 
 <p>协议方案名</p> 
</blockquote> 
<p><strong><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">http://</span></span></strong>表示的是协议名称，表示请求时需要使用的协议，通常使用的是HTTP协议或安全协议HTTPS。HTTPS是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。</p> 
<p>常见的应用层协议：</p> 
<ul><li>DNS（Domain Name System）协议：域名系统。</li><li>FTP（File Transfer Protocol）协议：文件传输协议。</li><li>TELNET（Telnet）协议：远程终端协议。</li><li>HTTP（Hyper Text Transfer Protocol）协议：超文本传输协议。</li><li>HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）协议：安全数据传输协议。</li><li>SMTP（Simple Mail Transfer Protocol）协议：电子邮件传输协议。</li><li>POP3（Post Office Protocol - Version 3）协议：邮件读取协议。</li><li>SNMP（Simple Network Management Protocol）协议：简单网络管理协议。</li><li>TFTP（Trivial File Transfer Protocol）协议：简单文件传输协议。</li></ul> 
<blockquote> 
 <p>登录信息 </p> 
</blockquote> 
<p><strong><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">user:pass</span></span></strong>表示的是登录认证信息，包括登录用户的用户名和密码。虽然登录认证信息可以在URL中体现出来，但绝大多数URL的这个字段都是被省略的，因为登录信息可以通过其他方案交付给服务器，并且直接将密码显示到url中也是不私密的。</p> 
<blockquote> 
 <p>服务器地址</p> 
</blockquote> 
<p><strong><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">www.example.ip</span></span></strong>表示的是服务器地址，也叫做域名，比如www.baidu.com、mp.csdn.net、www.bilibili.com等等。</p> 
<p>需要注意的是，我们用IP地址标识公网内的一台主机，但IP地址本身并不适合给用户看。比如说我们可以通过<span style="color:#fe2c24;"><strong><code><span style="background-color:#fbd4d0;">ping</span></code></strong></span>命令，分别获得<strong><span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">www.baidu.com</span></code></span></strong>和<strong><span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">www.qq.com</span></code></span></strong>这两个域名解析后的IP地址。</p> 
<p><img alt="" height="603" src="https://images2.imgbox.com/7f/c0/MKtzrtrQ_o.png" width="1035"></p> 
<blockquote> 
 <p>服务器端口号</p> 
</blockquote> 
<p><strong><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">80</span></span></strong>表示的是服务器端口号。HTTP协议和套接字编程一样都是位于应用层的，在进行套接字编程时我们需要给服务器绑定对应的IP和端口，而这里的应用层协议也同样需要有明确的端口号。</p> 
<p>当我们使用某种协议时，该协议实际就是在为我们提供服务，现在这些常用的服务与端口号之间的对应关系都是明确的，所以我们在使用某种协议时实际是不需要指明该协议对应的端口号的，因此在URL当中，服务器的端口号一般也是被省略的。</p> 
<blockquote> 
 <p>带层次的文件路径 </p> 
</blockquote> 
<p>表示的是要访问的资源所在的路径。访问服务器的目的是获取服务器上的某种资源，通过前面的域名和端口已经能够找到对应的服务器进程了，此时要做的就是指明该资源所在的路径。</p> 
<p>当我们发起网页请求时，本质是获得了这样的一张网页信息，然后浏览器对这张网页信息进行解释，最后就呈现出了对应的网页。</p> 
<p><img alt="" height="936" src="https://images2.imgbox.com/1a/f2/QEWyznxs_o.png" width="1200"></p> 
<p>我们可以将这种资源称为网页资源，此外我们还会向服务器请求视频、音频、网页、图片等资源。HTTP之所以叫做超文本传输协议，而不叫做文本传输协议，就是因为有很多资源实际并不是普通的文本资源。</p> 
<p>因此在URL当中就有这样一个字段，用于表示要访问的资源所在的路径。此外我们可以看到，这里的路径分隔符是/，而不是\，这也就证明了实际很多服务都是部署在Linux上的。<br>  </p> 
<blockquote> 
 <p>查询字符串</p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">uid=1&amp;2</span></strong></span>表示的是请求时提供的额外的参数，这些参数是以键值对的形式，中间用&amp;分割</p> 
<p>比如我们在百度中搜索helloworld：</p> 
<p><img alt="" height="602" src="https://images2.imgbox.com/3b/f1/fAlVPdR8_o.png" width="1200"></p> 
<h3 id="urlencode%E5%92%8Curldecode">urlencode和urldecode</h3> 
<p>如果在搜索关键字当中出现了像<span style="color:#fe2c24;"><strong><code><span style="background-color:#fbd4d0;">/?:</span></code></strong></span>这样的字符，由于这些字符已经被URL当作特殊意义理解了，因此URL在呈现时会对这些特殊字符进行转义。</p> 
<p>转义的规则如下：</p> 
<ul><li>将需要转码的字符转为十六进制，然后从右到左，取4位（不足4位直接处理），每两位做一位，前面加上%，编码成%XY格式。</li></ul> 
<p><img alt="" height="521" src="https://images2.imgbox.com/c3/7e/Z1wnvTGT_o.png" width="923"></p> 
<blockquote> 
 <p>"+" 被转义成了 "%2B" urldecode就是urlencode的逆过程</p> 
</blockquote> 
<h3 id="HTTP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F">HTTP协议格式</h3> 
<h5 id="HTTP%E8%AF%B7%E6%B1%82" style="background-color:transparent;">HTTP请求</h5> 
<p>一个真实的HTTP请求：</p> 
<p><img alt="" height="865" src="https://images2.imgbox.com/74/5f/Dy9saujY_o.png" width="1200"></p> 
<p>HTTP请求协议格式如下：</p> 
<p><img alt="" height="491" src="https://images2.imgbox.com/7e/e1/GzDoSaLN_o.png" width="1146"></p> 
<p>HTTP请求由以下四部分组成：</p> 
<ul><li>请求行：<span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">[请求方法]</span></strong></span>+<span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">[url]</span></strong></span>+<strong><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">[http版本]</span></span></strong></li><li>请求报头：请求的属性，这些属性都是以<span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">key: value</span></strong></span>的形式按行陈列的。</li><li>空行：遇到空行表示请求报头结束。</li><li>请求正文：请求正文允许为空字符串，如果请求正文存在，则在请求报头中会有一个Content-Length属性来标识请求正文的长度。</li></ul> 
<p>其中，前面三部分是一般是HTTP协议自带的，是由HTTP协议自行设置的，而请求正文一般是用户的相关信息或数据，如果用户在请求时没有信息要上传给服务器，此时请求正文就为空字符串。</p> 
<blockquote> 
 <p>获取HTTP请求</p> 
</blockquote> 
<p>因此下面我们编写一个简单的TCP服务器，这个服务器要做的就是把浏览器发来的HTTP请求进行打印即可。（这里我们也使用了上文网络计算器中封装好的Socket头文件）</p> 
<pre><code class="language-cpp">#include &lt;memory&gt;
#include "Sock.hpp"

static int defaultport = 8888;

class HttpServer;
class ThreadData
{
public:
    ThreadData(int sock, const std::string &amp;ip, const uint16_t &amp;port, HttpServer *tsvrp)
        : _sock(sock), _ip(ip), _port(port), _tsvrp(tsvrp)
    {
    }
    ~ThreadData() {}

public:
    int _sock;
    std::string _ip;
    uint16_t _port;
    HttpServer *_tsvrp;
};

class HttpServer
{
public:
    HttpServer(int port=defaultport)
        :port_(port)
    {
    }
    ~HttpServer()
    {
    }
    void InitServer()
    {
        sock_.Socket();
        sock_.Bind(port_);
        sock_.Listen();
    }
    void Start()
    {
        for (;;)
        {
            std::string clientip;
            uint16_t clientport;
            int sock = sock_.Accept(&amp;clientip, &amp;clientport);
            if (sock &lt; 0)
                continue;
            else
            {
                pthread_t tid;
                ThreadData *td = new ThreadData(sock, clientip, clientport, this); 
                pthread_create(&amp;tid, nullptr, threadRoutine, td);

            }
            
        }
    }
    static void *threadRoutine(void *args)
    {
        pthread_detach(pthread_self());
        ThreadData *td = static_cast&lt;ThreadData*&gt;(args);

        char buffer[4096];
        std::cout&lt;&lt;td-&gt;_sock&lt;&lt;std::endl;
        int n = recv(td-&gt;_sock,buffer,sizeof(buffer)-1,0);
        if(n&gt;0)
        {
            std::cout&lt;&lt;buffer&lt;&lt;std::endl;
        }
        else
        {
            std::cout&lt;&lt;"recv fail\n";
        }

        close(td-&gt;_sock);
        return nullptr;
    }

    void HandlerHttpRequest(int sock)
    {
        char buffer[4096];
        ssize_t n = recv(sock, buffer, sizeof(buffer) - 1, 0);
        std::string request;
        if(n&gt;0)
        {
            request = buffer;
            std::cout&lt;&lt;request&lt;&lt;std::endl;
        }
        else
        {
            std::cout&lt;&lt;"recv fail..."&lt;&lt;std::endl;
        }
    }

private:
    Sock sock_;
    int port_;
};

int main()
{
    std::unique_ptr&lt;HttpServer&gt; tsvr(new HttpServer(8888));
    tsvr-&gt;InitServer();
    tsvr-&gt;Start();

    return 0;
}</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="601" src="https://images2.imgbox.com/5c/ad/C0qZfp0k_o.png" width="1200"></p> 
<h5 id="HTTP%E5%93%8D%E5%BA%94">HTTP响应</h5> 
<p>HTTP响应协议格式如下：</p> 
<p><img alt="" height="548" src="https://images2.imgbox.com/84/2e/qPJXFWwm_o.png" width="972"></p> 
<p>HTTP响应由以下四部分组成： </p> 
<ul><li>请求行：<span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">[响应方法]</span></strong></span>+<span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">[状态码]</span></strong></span>+<strong><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">[状态描述]</span></span></strong></li><li>响应报头：响应的属性，这些属性都是以<strong><span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">key: value</span></code></span></strong>的形式按行陈列的。</li><li>空行：遇到空行表示响应报头结束。</li><li>响应正文：响应正文允许为空字符串，如果响应正文存在，则响应报头中会有一个Content-Length属性来标识响应正文的长度。比如服务器返回了一个html页面，那么这个html页面的内容就是在响应正文当中的。</li></ul> 
<blockquote> 
 <p>如何将HTTP响应的报头与有效载荷进行分离？</p> 
</blockquote> 
<p>对于HTTP响应来讲，这里的状态行和响应报头就是HTTP的报头信息，而这里的响应正文实际就是HTTP的有效载荷。与HTTP请求相同，当应用层收到一个HTTP响应时，也是根据HTTP响应当中的空行来分离报头和有效载荷的。当客户端收到一个HTTP响应后，就可以按行进行读取，如果读取到空行则说明报头已经读取完毕。</p> 
<blockquote> 
 <p>发送HTTP响应给浏览器</p> 
</blockquote> 
<p>服务器读取到客户端发来的HTTP请求后，需要对这个HTTP请求进行各种数据分析，然后构建成对应的HTTP响应发回给客户端。而我们刚才写的服务器连接到客户端后，实际就只读取了客户端发来的HTTP请求就将连接断开了。</p> 
<p><img alt="" height="650" src="https://images2.imgbox.com/ed/d5/ukePxWQ4_o.png" width="1065"></p> 
<p>接下来我们可以构建一个HTTP请求给浏览器，鉴于现在还没有办法分析浏览器发来的HTTP请求，这里我们可以给浏览器返回一个固定的HTTP响应。我们就将当前服务程序所在的路径作为我们的web根目录，我们可以在该目录下创建一个html文件，然后编写一个简单的html作为当前服务器的首页。</p> 
<pre><code class="language-cpp">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h1&gt;hello world&lt;/h1&gt;
    &lt;h1&gt;这是从hrimkn的linux服务器发送来的数据&lt;/h1&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
<p>服务器代码：</p> 
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

#include "Sock.hpp"

static int defaultport = 8888;

class HttpServer;
class ThreadData
{
public:
    ThreadData(int sock, const std::string &amp;ip, const uint16_t &amp;port, HttpServer *tsvrp)
        : _sock(sock), _ip(ip), _port(port), _tsvrp(tsvrp)
    {
    }
    ~ThreadData() {}

public:
    int _sock;
    std::string _ip;
    uint16_t _port;
    HttpServer *_tsvrp;
};

class HttpServer
{
public:
    HttpServer(int port = defaultport)
        : port_(port)
    {
    }
    ~HttpServer()
    {
    }
    void InitServer()
    {
        sock_.Socket();
        sock_.Bind(port_);
        sock_.Listen();
    }
    void Start()
    {
        for (;;)
        {
            std::string clientip;
            uint16_t clientport;
            int sock = sock_.Accept(&amp;clientip, &amp;clientport);
            if (sock &lt; 0)
                continue;
            else
            {
                pthread_t tid;
                ThreadData *td = new ThreadData(sock, clientip, clientport, this);
                pthread_create(&amp;tid, nullptr, threadRoutine, td);
            }
        }
    }
    static void *threadRoutine(void *args)
    {
        pthread_detach(pthread_self());
        ThreadData *td = static_cast&lt;ThreadData *&gt;(args);

        // 接收请求
        char buffer[4096];

        std::cout &lt;&lt; td-&gt;_sock &lt;&lt; std::endl;
        int n = recv(td-&gt;_sock, buffer, sizeof(buffer) - 1, 0);
        if (n &gt; 0)
        {
            std::cout &lt;&lt; buffer &lt;&lt; std::endl;
        }
        else
        {
            std::cout &lt;&lt; "recv fail\n";
        }

        // 分析请求，发送响应
        // 打开写好的html网页文件
        int fd = open("./wwwroot/index.html", O_RDONLY);
        char file[4096];
        ssize_t len = read(fd, file, sizeof(file));
        file[len] = '\0';

        // 构建HTTP响应
        std::string status_line = "http/1.1 200 OK\n";                                 // 状态行
        std::string response_header = "Content-Length: " + std::to_string(len) + "\n"; // 响应报头
        std::string blank = "\n";                                                      // 空行
        std::string response_text = file;                                              // 响应正文
        std::string response = status_line + response_header + blank + response_text;  // 响应报文

        // 发送请求
        send(td-&gt;_sock, response.c_str(), response.size(), 0);

        close(td-&gt;_sock);
        return nullptr;
    }

private:
    Sock sock_;
    int port_;
};

int main()
{
    std::unique_ptr&lt;HttpServer&gt; tsvr(new HttpServer(8888));
    tsvr-&gt;InitServer();
    tsvr-&gt;Start();

    return 0;
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/a6/44/92z9c3V6_o.png" width="966"></p> 
<p><strong>说明一下：</strong></p> 
<ul><li>实际我们在进行网络请求的时候，如果不指明请求资源的路径，此时默认你想访问的就是目标网站的首页，也就是web根目录下的index.html文件。</li><li>由于只是作为示例，我们在构建HTTP响应时，在响应报头当中只添加了一个属性信息Content-Length，表示响应正文的长度，实际HTTP响应报头当中的属性信息还有很多。</li></ul> 
<h3 id="HTTP%E7%9A%84%E6%96%B9%E6%B3%95%C2%A0">HTTP的方法 </h3> 
<p>HTTP的方法如下：</p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/39/f6/G6y87gL8_o.png" width="1200"></p> 
<p>其中最常用的是GET和POST方法。</p> 
<h4 id="GET%E5%92%8CPOST%E6%96%B9%E6%B3%95">GET和POST方法</h4> 
<p>GET方法一般用于获取某种资源信息，而POST方法一般用于将数据上传给服务器。但实际我们上传数据时也有可能使用GET方法，比如百度提交数据时实际使用的就是GET方法。</p> 
<p>GET方法和POST方法都可以带参：</p> 
<ul><li>GET方法是通过url传参的。</li><li>POST方法是通过正文传参的。</li></ul> 
<p>从GET方法和POST方法的传参形式可以看出，POST方法能传递更多的参数，因为url的长度是有限制的，POST方法通过正文传参就可以携带更多的数据。</p> 
<p>此外，使用POST方法传参更加私密，因为POST方法不会将你的参数回显到url当中，此时也就不会被别人轻易看到。不能说POST方法比GET方法更安全，<span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">因为POST方法和GET方法实际都不安全，要做到安全只能通过加密来完成。</span></strong></span></p> 
<h4 id="POSTMAN%E6%BC%94%E7%A4%BA">POSTMAN演示</h4> 
<p>Postman是一种网页调试与发送网页http请求的chrome插件。我们可以用来很方便的模拟get或者post或者其他方式的请求来调试接口。在Postman中，请求可以保存，也就类似于文件。而Collection类似文件夹，可以把同一个项目的请求放在一个Collection里方便管理和分享，Collection里面也可以再建文件夹。Postman具有每个API开发人员的功能：请求构建，测试和预请求脚本，变量，环境和请求描述，旨在无缝地一起工作。在这里我们可以借助POSTMAN来看一看http请求方法中GET和POST的区别。</p> 
<p>如果访问我们的服务器时使用的是GET方法，此时应该通过url进行传参，可以在Params下进行参数设置，因为Postman当中的Params就相当于url当中的参数，你在设置参数时可以看到对应的url也在随之变化。</p> 
<p><img alt="" height="601" src="https://images2.imgbox.com/1e/10/yDN1X3N0_o.png" width="1194"></p> 
<p>而如果我们使用的是POST方法，此时就应该通过正文进行传参，可以在Body下进行参数设置，在设置时可以选中Postman当中的raw方式传参，表示原始传参，也就是你输入的参数是什么样的实际传递的参数就是什么样的。</p> 
<p><img alt="" height="512" src="https://images2.imgbox.com/69/00/pHxwYwHI_o.png" width="1119"></p> 
<p> <img alt="" height="296" src="https://images2.imgbox.com/5b/86/qbaW4BxZ_o.png" width="807"></p> 
<h3 id="HTTP%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81">HTTP的状态码</h3> 
<p><img alt="" height="428" src="https://images2.imgbox.com/49/77/czXkX5Lp_o.png" width="1200">最常见的状态码，比如：</p> 
<ul><li>200（OK）</li><li>404（Not Found）</li><li>403（Forbidden请求权限不够）</li><li>302（Redirect）</li><li>504（Bad Gateway）</li></ul> 
<blockquote> 
 <p>Redirection（重定向状态码） </p> 
</blockquote> 
<p>重定向就是通过各种方法将各种网络请求重新定个方向转到其它位置，此时这个服务器相当于提供了一个引路的服务。</p> 
<p>重定向又可分为<strong><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">临时重定向</span></span></strong>和<strong><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">永久重定向</span></span></strong>，其中状态码301表示的就是永久重定向，而状态码302和307表示的是临时重定向。</p> 
<p>临时重定向和永久重定向本质是影响客户端的标签，决定客户端是否需要更新目标地址。如果某个网站是永久重定向，那么第一次访问该网站时由浏览器帮你进行重定向，但后续再访问该网站时就不需要浏览器再进行重定向了，此时你访问的直接就是重定向后的网站。而如果某个网站是临时重定向，那么每次访问该网站时如果需要进行重定向，都需要浏览器来帮我们完成重定向跳转到目标网站。</p> 
<blockquote> 
 <p>临时重定向演示</p> 
</blockquote> 
<p>进行临时重定向时需要用到Location字段，Location字段是HTTP报头当中的一个属性信息，该字段表明了你所要重定向到的目标网站。</p> 
<p>将http响应加入重定向</p> 
<pre><code class="language-cpp">//4. 重定向测试
std::string response;
response = "HTTP/1.0 301 Moved Permanently" + SEP;
response += "Location: https://www.bilibili.com/" + SEP;
response += SEP;

// 发送请求
send(td-&gt;_sock, response.c_str(), response.size(), 0);</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="792" src="https://images2.imgbox.com/26/aa/0DL3JwI8_o.gif" width="1200"></p> 
<h3 id="HTTP%E5%B8%B8%E8%A7%81header">HTTP常见header</h3> 
<ul><li>Content-Type: 数据类型(text/html等)</li><li>Content-Length: Body的长度</li><li>Host: 客户端告知服务器, 所请求的资源是在哪个主机的哪个端口上;</li><li>User-Agent: 声明用户的操作系统和浏览器版本信息;</li><li>referer: 当前页面是从哪个页面跳转过来的;</li><li>location: 搭配3xx状态码使用, 告诉客户端接下来要去哪里访问;</li><li>Cookie: 用于在客户端存储少量信息. 通常用于实现会话(session)的功能<br>  </li></ul> 
<h3 id="Cookie%E5%92%8Csession">Cookie和session</h3> 
<p>HTTP实际上是一种无状态协议，HTTP的每次请求/响应之间是没有任何关系的，但你在使用浏览器的时候发现并不是这样的。</p> 
<p>比如当你登录一次bilibil后，就算你把网站关了甚至是重启电脑，当你再次打开该网站时，bilibili并没有要求你再次输入账号和密码，这实际上是通过cookie技术实现的，点击浏览器当中锁的标志就可以看到对应网站的各种cookie数据。</p> 
<p><img alt="" height="792" src="https://images2.imgbox.com/45/47/uEIvluWn_o.png" width="1200"></p> 
<p>这些cookie数据实际都是对应的服务器方写的，如果你将对应的某些cookie删除，那么此时可能就需要你重新进行登录认证了，因为你删除的可能正好就是你登录时所设置的cookie信息。</p> 
<blockquote> 
 <p>cookie </p> 
</blockquote> 
<p>因为HTTP是一种无状态协议，如果没有cookie的存在，那么每当我们要进行页面请求时都需要重新输入账号和密码进行认证，这样太麻烦了。</p> 
<p>比如你是某个视频网站的VIP，这个网站里面的VIP视频有成百上千个，你每次点击一个视频都要重新进行VIP身份认证。而HTTP不支持记录用户状态，那么我们就需要有一种独立技术来帮我们支持，这种技术目前现在已经内置到HTTP协议当中了，叫做cookie。</p> 
<p>当我们第一次登录某个网站时，需要输入我们的账号和密码进行身份认证，此时如果服务器经过数据比对后判定你是一个合法的用户，那么为了让你后续在进行某些网页请求时不用重新输入账号和密码，此时服务器就会进行Set-Cookie的设置。（Set-Cookie也是HTTP报头当中的一种属性信息）</p> 
<p>当认证通过并在服务端进行Set-Cookie设置后，服务器在对浏览器进行HTTP响应时就会将这个Set-Cookie响应给浏览器。而浏览器收到响应后会自动提取出Set-Cookie的值。当认证通过并在服务端进行Set-Cookie设置后，服务器在对浏览器进行HTTP响应时就会将这个Set-Cookie响应给浏览器。而浏览器收到响应后会自动提取出Set-Cookie的值。</p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/35/4b/Iwbmnioa_o.png" width="1188"></p> 
<blockquote> 
 <p>内存级别&amp;文件级别</p> 
</blockquote> 
<p>cookie就是在浏览器当中的一个小文件，文件里记录的就是用户的私有信息。cookie文件可以分为两种，一种是内存级别的cookie文件，另一种是文件级别的cookie文件。</p> 
<ul><li>将浏览器关掉后再打开，访问之前登录过的网站，如果需要你重新输入账号和密码，说明你之前登录时浏览器当中保存的cookie信息是内存级别的。</li><li>将浏览器关掉甚至将电脑重启再打开，访问之前登录过的网站，如果不需要你重新输入账户和密码，说明你之前登录时浏览器当中保存的cookie信息是文件级别的。</li></ul> 
<blockquote> 
 <p>SessionID</p> 
</blockquote> 
<p>单纯的使用cookie是非常不安全的，因为此时cookie文件当中就保存的是你的私密信息，一旦cookie文件泄漏你的隐私信息也就泄漏。</p> 
<p>如果你浏览器当中保存的cookie信息被非法用户盗取了，那么此时这个非法用户就可以用你的cookie信息，以你的身份去访问你曾经访问过的网站，我们将这种现象称为cookie被盗取了。比如你不小心点了某个链接，这个链接可能就是一个下载程序，当你点击之后它就会通过某种方式把程序下载到你本地，并且自动执行该程序，该程序会扫描你的浏览器当中的cookie目录，把所有的cookie信息通过网络的方式传送给恶意方，当恶意方拿到你的cookie信息后就可以拷贝到它的浏览器对应的cookie目录当中，然后以你的身份访问你曾经访问过的网站。</p> 
<p>所以当前主流的服务器还引入了SessionID这样的概念，当我们第一次登录某个网站输入账号和密码后，服务器认证成功后还会服务端生成一个对应的SessionID，这个SessionID与用户信息是不相关的。系统会将所有登录用户的SessionID值统一维护起来。</p> 
<p>此时当认证通过后服务端在对浏览器进行HTTP响应时，就会将这个生成的SessionID值响应给浏览器。浏览器收到响应后会自动提取出SessionID的值，将其保存在浏览器的cookie文件当中。后续访问该服务器时，对应的HTTP请求当中就会自动携带上这个SessionID。</p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/52/f0/iSncvwQR_o.png" width="1180"></p> 
<blockquote> 
 <p>引入SessionID后的好处</p> 
</blockquote> 
<ul><li>在引入SessionID之前，用户登录的账号信息都是保存在浏览器内部的，此时的账号信息是由客户端去维护的。</li><li>而引入SessionID后，用户登录的账号信息是有服务器去维护的，在浏览器内部保存的只是SessionID。</li></ul> 
<p>此时虽然SessionID可能被非法用户盗取，但服务器也可以使用各种各样的策略来保证用户账号的安全。</p> 
<blockquote> 
 <p>具体演示</p> 
</blockquote> 
<pre><code class="language-cpp">//cookie &amp;&amp; session实验
std::string response;
response = "HTTP/1.0 200 OK" + SEP;
response += "Set-Cookie: sessionid=1234abcd" + SEP;
response += SEP;

// 发送请求
send(td-&gt;_sock, response.c_str(), response.size(), 0);</code></pre> 
<p>运行结果： </p> 
<p><img alt="" height="720" src="https://images2.imgbox.com/bc/ee/amoe7BkL_o.png" width="1200"></p> 
<hr> 
<h2></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1cef8bf406b37198c7021564bbd957bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">10-65 查询课程成绩最高二人</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/402b1bedc3736caea561a9257cc1dfb8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于征程5芯片的BEV感知方案与部署实践</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>