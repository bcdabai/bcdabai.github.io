<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ifstream 的使用方法介绍 一(转载) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ifstream 的使用方法介绍 一(转载)" />
<meta property="og:description" content="此文为转载 原文在https://blog.csdn.net/jllongbell/article/details/79087281 因为排版问题自己整理了一下
——————————————————————————————————————————————————————
ofstream是从内存到硬盘，ifstream是从硬盘到内存，其实所谓的流缓冲就是内存空间;这里我们说的输入输出主语都是程序在C&#43;&#43;中，有一个stream这个类，所有的I/O都以这个“流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符： 1、插入器(&lt;&lt;)　向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;&#34;Write Stdout&#34;&lt;&lt;&#39;/n&#39;;就表示把字符串&#34;Write Stdout&#34;和换行字符(&#39;/n&#39;)输出到标准输出流。2、析取器(&gt;&gt;)　从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。在C&#43;&#43;中，对文件的操作是通过stream的子类fstream(file stream)来实现的要用这种方式操作文件，就必须加入头文件fstream.h。一、打开文件　在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是： void open(const char* filename,int mode,int access); 参数： filename：　要打开的文件名mode：　要打开文件的方式 打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下： ios::app：以追加的方式打开文件 打开文件在文件尾进行写入，即使使用了seekp改变了写入位置，仍将在文件尾写入ios::ate：文件打开后定位到文件尾ios:app就包含有此属性 打开文件在文件尾进行写入，但seekp有效。ios::binary：　以二进制方式打开文件， 默认是ios::text，但最好指定这种读写方式，即使要读写的是文本。 因为在ios::text模式下，在写入时&#39;/ n&#39;字符将转换成两个字符：回车&#43;换行（HEX: 0D 0A) 写入，读入时作逆转换，这容易引起不必要的麻烦。ios::in：文件以输入方式打开（文件数据输入到内存）ios::out：　文件以输出方式打开（内存数据输出到文件）如果文件不存在，则新建一个；存在则清空其内容。ios::nocreate： 不建立文件，所以文件不存在时打开失败ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败ios::trunc：　如果文件存在，把文件长度设为0　可以用“或”把以上属性连接起来，如ios::out|ios::binaryaccess：　打开文件的属性 打开文件的属性取值是： 0：普通文件，打开访问1：只读文件2：隐含文件4：系统文件　可以用“或”或者“&#43;”把以上属性连接起来，如3或1|2就是以只读和隐含属性打开文件。例如： 1.以二进制输入方式打开文件c:/config.sys fstream file1;file1.open(&#34;c://config.sys&#34;,ios::binary|ios::in,0);2.如果open函数只有文件名一个参数，则是以读/写普通文件打开 file1.open(&#34;c://config.sys&#34;);&lt;=&gt;file1.open(&#34;c://config.sys&#34;,ios::in|ios::out,0);&lt;=&gt;fstream file1(&#34;c://config.sys&#34;); 构造函数在定义的时候就能打开文件fstream有两个子类： ifstream(input file stream) ifstream默认以输入方式打开文件ifstream file2(&#34;c://pdos.def&#34;);ofstream(outpu file stream) ofstream默认以输出方式打开文件ofstream file3(&#34;c://x.123&#34;);实际应用中 如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义。二、关闭文件 打开的文件使用完成后一定要关闭。fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。三、读写文件 读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式1、文本文件的读写　文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。示例如下： 假设file1是以输入方式打开，file2以输出打开。向文件写入字符串&#34;I Love You&#34;　file2&lt;&lt;&#34;I Love You&#34;;//从文件输入一个整数值。 int i;file1&gt;&gt;i;这种方式还有一种简单的格式化能力 具体操作符 操纵符 功能 输入/输出dec 格式化为十进制数值数据 输入和输出endl 输出一个换行符并刷新此流 输出ends 输出一个空字符 输出hex 格式化为十六进制数值数据 输入和输出oct 格式化为八进制数值数据 输入和输出setpxecision(int p) 设置浮点数的精度位数 输出比如 要把123当作十六进制输出：file1&lt;&lt;hex&lt;&lt;123;要把3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/90d0881650b2fe59d3c3f6fafae502a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-15T15:06:06+08:00" />
<meta property="article:modified_time" content="2020-05-15T15:06:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ifstream 的使用方法介绍 一(转载)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>此文为转载 原文在<a href="https://blog.csdn.net/jllongbell/article/details/79087281">https://blog.csdn.net/jllongbell/article/details/79087281</a> 因为排版问题自己整理了一下</p> 
<p>——————————————————————————————————————————————————————</p> 
<ul><li>ofstream是从内存到硬盘，ifstream是从硬盘到内存，其实所谓的流缓冲就是内存空间;</li><li>这里我们说的输入输出主语都是程序</li><li>在C++中，有一个stream这个类，所有的I/O都以这个“流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符： 
  <ul><li>1、插入器(&lt;&lt;)　　 
    <ul><li>向流输出数据。</li><li>比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;"Write Stdout"&lt;&lt;'/n';就表示把字符串"Write Stdout"和换行字符('/n')输出到标准输出流。</li></ul></li><li>2、析取器(&gt;&gt;)　　 
    <ul><li>从流中输入数据。</li><li>比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。</li></ul></li></ul></li><li>在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的</li><li>要用这种方式操作文件，就必须加入头文件fstream.h。</li><li>一、打开文件　　 
  <ul><li>在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是： 
    <ul><li>void open(const char* filename,int mode,int access); 
      <ul><li>参数： 
        <ul><li>filename：　　要打开的文件名</li><li>mode：　　　　要打开文件的方式 
          <ul><li>打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下： 
            <ul><li>ios::app：以追加的方式打开文件 
              <ul><li>打开文件在文件尾进行写入，即使使用了seekp改变了写入位置，仍将在文件尾写入</li></ul></li><li>ios::ate：文件打开后定位到文件尾ios:app就包含有此属性 
              <ul><li>打开文件在文件尾进行写入，但seekp有效。</li></ul></li><li>ios::binary：　以二进制方式打开文件， 
              <ul><li>默认是ios::text，但最好指定这种读写方式，即使要读写的是文本。 
                <ul><li>因为在ios::text模式下，在写入时'/ n'字符将转换成两个字符：回车+换行（HEX: 0D 0A) 写入，读入时作逆转换，这容易引起不必要的麻烦。</li></ul></li></ul></li><li>ios::in：文件以输入方式打开（文件数据输入到内存）</li><li>ios::out：　　　文件以输出方式打开（内存数据输出到文件）如果文件不存在，则新建一个；存在则清空其内容。</li><li>ios::nocreate： 不建立文件，所以文件不存在时打开失败</li><li>ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败</li><li>ios::trunc：　　如果文件存在，把文件长度设为0　　</li></ul></li><li>可以用“或”把以上属性连接起来，如ios::out|ios::binary</li></ul></li><li>access：　　　打开文件的属性 
          <ul><li>打开文件的属性取值是： 
            <ul><li>0：普通文件，打开访问</li><li>1：只读文件</li><li>2：隐含文件</li><li>4：系统文件　　</li></ul></li><li>可以用“或”或者“+”把以上属性连接起来，如3或1|2就是以只读和隐含属性打开文件。</li></ul></li></ul></li></ul></li></ul></li><li>例如： 
    <ul><li>1.以二进制输入方式打开文件c:/config.sys 
      <ul><li>fstream file1;</li><li>file1.open("c://config.sys",ios::binary|ios::in,0);</li></ul></li><li>2.如果open函数只有文件名一个参数，则是以读/写普通文件打开 
      <ul><li>file1.open("c://config.sys");</li><li>&lt;=&gt;</li><li>file1.open("c://config.sys",ios::in|ios::out,0);</li><li>&lt;=&gt;</li><li>fstream file1("c://config.sys"); 
        <ul><li>构造函数在定义的时候就能打开文件</li></ul></li></ul></li></ul></li><li>fstream有两个子类： 
    <ul><li>ifstream(input file stream) 
      <ul><li>ifstream默认以输入方式打开文件</li><li>ifstream file2("c://pdos.def");</li></ul></li><li>ofstream(outpu file stream) 
      <ul><li>ofstream默认以输出方式打开文件</li><li>ofstream file3("c://x.123");</li></ul></li></ul></li><li>实际应用中 
    <ul><li>如果想以输入方式打开，就用ifstream来定义；</li><li>如果想以输出方式打开，就用ofstream来定义；</li><li>如果想以输入/输出方式来打开，就用fstream来定义。</li></ul></li></ul></li><li>二、关闭文件 
  <ul><li>打开的文件使用完成后一定要关闭。</li><li>fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。</li></ul></li><li>三、读写文件 
  <ul><li>读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式</li><li>1、文本文件的读写　　 
    <ul><li>文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。</li><li>示例如下： 
      <ul><li>假设file1是以输入方式打开，file2以输出打开。</li><li>向文件写入字符串"I Love You"　　 
        <ul><li>file2&lt;&lt;"I Love You";</li></ul></li><li>//从文件输入一个整数值。 
        <ul><li>int i;</li><li>file1&gt;&gt;i;</li></ul></li></ul></li><li>这种方式还有一种简单的格式化能力 
      <ul><li>具体操作符 
        <ul><li>操纵符 功能 输入/输出</li><li>dec 格式化为十进制数值数据 输入和输出</li><li>endl 输出一个换行符并刷新此流 输出</li><li>ends 输出一个空字符 输出</li><li>hex 格式化为十六进制数值数据 输入和输出</li><li>oct 格式化为八进制数值数据 输入和输出</li><li>setpxecision(int p) 设置浮点数的精度位数 输出</li></ul></li><li>比如 
        <ul><li>要把123当作十六进制输出：file1&lt;&lt;hex&lt;&lt;123;</li><li>要把3.1415926以5位精度输出：file1&lt;&lt;setpxecision(5)&lt;&lt;3.1415926。</li></ul></li></ul></li></ul></li><li>2、二进制文件的读写 
    <ul><li>①put()　　 
      <ul><li>put()函数向流写入一个字符</li><li>原型：ofstream &amp;put(char ch)</li><li>使用：如file1.put('c');就是向流写一个字符'c'。</li></ul></li><li>②get() 
      <ul><li>get()函数比较灵活，有3种常用的重载形式： 
        <ul><li>原型：ifstream &amp;get(char &amp;ch);、 
          <ul><li>功能：从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。</li><li>例如：file2.get(x);表示从文件中读取一个字符，并把读取的字符保存在x中。</li></ul></li><li>原型是：int get(); 
          <ul><li>功能：从流中返回一个字符，如果到达文件尾，返回EOF</li><li>例如：如x=file2.get();</li></ul></li><li>原型是：ifstream &amp;get(char *buf,int num,char delim='/n')； 
          <ul><li>功能：把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符'/n'。</li><li>例如：file2.get(str1,127,'A');  //从文件中读取字符到字符串str1，当遇到字符'A'或读取了127个字符时终止。</li></ul></li></ul></li></ul></li><li>③读写数据块 
      <ul><li>要读写二进制数据块，使用成员函数read()和write()成员函数 
        <ul><li>read(unsigned char *buf,int num);　　　　 
          <ul><li>read()从文件中读取 num 个字符到 buf 指向的缓存中 
            <ul><li>如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；</li></ul></li></ul></li><li>write(const unsigned char *buf,int num); 
          <ul><li>write() 从buf 指向的缓存写 num 个字符到文件中</li><li>值得注意的是缓存的类型是 unsigned char *，有时可能需要类型转换。</li></ul></li></ul></li><li>例：<br> unsigned char str1[]="I Love You";int n[5];　　　　ifstream in("xxx.xxx");　　　　ofstream out("yyy.yyy");　　　　out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中　　　　​in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换　　　　​in.close();​out.close();</li></ul></li></ul></li></ul></li><li>四、检测EOF 
  <ul><li>成员函数eof()用来检测是否到达文件尾 
    <ul><li>原型：int eof();</li><li>返回值 
      <ul><li>如果到达文件尾返回非0值，</li><li>否则返回0。</li></ul></li></ul></li><li>用例<br> if(in.eof())  ​ShowMessage("已经到达文件尾！");</li></ul></li><li>五、文件定位 
  <ul><li>C++ I/O系统管理两个与一个文件相联系的指针。 
    <ul><li>一个是读指针，它说明输入操作在文件中的位置；</li><li>另一个是写指针，它下次写操作的位置。</li><li>每次执行输入或输出时， 相应的指针自动变化。</li></ul></li><li>C++的文件定位分为 
    <ul><li>读位置的定位 
      <ul><li>istream &amp;seekg(streamoff offset,seek_dir origin);　 
        <ul><li>seekg()是设置读位置</li></ul></li></ul></li><li>写位置的定位 
      <ul><li>ostream &amp;seekp(streamoff offset,seek_dir origin); 
        <ul><li>seekp是设置写位置</li></ul></li></ul></li><li>参数 
      <ul><li>streamoff 
        <ul><li>定义于 iostream.h中</li><li>定义有偏移量 offset 所能取得的最大值，</li></ul></li><li>seek_dir 表示移动的基准位置，是一个有以下值的枚举： 
        <ul><li>ios::beg：　　文件开头</li><li>ios::cur：　　文件当前位置</li><li>ios::end：　　文件结尾</li></ul></li></ul></li><li>这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。例： 
      <ul><li>file1.seekg(1234,ios::cur);  //把文件的读指针从当前位置向后移1234个字节　　　</li><li>file2.seekp(1234,ios::beg);  //把文件的写指针从文件开头向后移1234个字节</li></ul></li></ul></li></ul></li><li>fstream的用法 
  <ul><li>开一个文件 
    <ul><li>fstream f;</li><li>f.open("1.txt", ios::in | ios::binary);</li></ul></li><li>if (!<a href="http://f.is" rel="nofollow">f.is</a>_open()) // 检查文件是否成功打开  
    <ul><li>cout &lt;&lt; "cannot open file." &lt;&lt; endl;</li></ul></li><li>读写位置的改变 
    <ul><li>f.seekg(0, ios::beg); // 改变读入位置 g mean Get</li><li>f.seekp(0, ios::end); // 改变写入位置 p mean Put 
      <ul><li>第一个参数是偏移量offset(long)</li><li>第二个参数是offset相对的位置 
        <ul><li>ios::beg -- 文件头 </li><li>ios::end -- 文件尾 </li><li>ios::cur -- 当前位置</li></ul></li></ul></li></ul></li><li>文件读写 
    <ul><li>char s[50];</li><li>f.read(s, 49);</li><li>s[50] = '/0'; // 注意要自己加上字符串结束符</li><li>char *s = "hello";</li><li>f.write(s, strlen(s));</li></ul></li><li>补充 ：记得读写完成后用f.close()关闭文件。</li><li>例子 ：下面的程序用于删除带有行号的源程序中的行号。 
    <ul><li>#include&lt;iostream&gt;</li><li>#include&lt;fstream&gt;</li><li>using namespace std;</li><li>//定义要删除的行号格式，下面定义的是型如: #0001 的行号const int 
      <ul><li>LINE_NUM_LENGTH = 5;</li><li>const char LINE_NUM_START = '#';</li></ul></li><li>int main(int argc, char *argv[]){ 
      <ul><li>fstream f;</li><li>char *s = NULL;</li><li>int n;</li><li>for (int i = 1; i &lt; argc; i++) { 
        <ul><li>cout &lt;&lt; "Processing file " &lt;&lt; argv[i] &lt;&lt; "......";   </li><li>f.open(argv[i], ios::in | ios::binary);   </li><li>if (!<a href="http://f.is" rel="nofollow">f.is</a>_open()){        
          <ul><li>cout &lt;&lt; "CANNOT OPEN"&lt;&lt; endl;       </li><li>continue;    }   </li></ul></li><li>f.seekg(0, ios::end); </li><li>n = f.tellg(); // 文件大小 
          <ul><li>文件大小好像需要把读指针放在最后噢</li></ul></li><li>s = new char[n+1]; </li><li>f.seekg(0, ios::beg);   </li><li>f.read(s, n);   </li><li>s[n] = '/0';   </li><li>f.close();</li></ul></li><li>// 采用一种简单的判断，遇到LINE_NUM_START后接一个数字，   </li><li>// 则认为它是一个行号.   </li><li>for (int j = 0; j &lt; n; j++) {        
        <ul><li>if (s[j] == LINE_NUM_START &amp;&amp; (s[j+1] &gt;= '0' &amp;&amp; s[j+1] &lt;= '9')) { 
          <ul><li>for (int k = j; k &lt; j + LINE_NUM_LENGTH; k++)</li><li>s[k] = ' ';       </li><li>}    }</li></ul></li></ul></li><li>f.open(argv[i], ios::out | ios::binary); </li><li>if (!<a href="http://f.is" rel="nofollow">f.is</a>_open()) 
        <ul><li>{cout &lt;&lt; "CANNOT OPEN" &lt;&lt; endl;</li><li>delete[] s;</li><li>continue; }   </li></ul></li><li>f.write(s, n);   </li><li>f.close();   </li><li>cout &lt;&lt; "OK" &lt;&lt; endl;   </li><li>delete[] s;}</li><li>return 0;}</li></ul></li></ul></li></ul></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f268fedf2f95c3d5aca242460a9d5b3f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flutter permission_handler仅一行代码解决授权</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/65ad7bab4ac6d4ccc810b537fce68558/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Objective-C 基础入门（三） 读写文件与回调</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>