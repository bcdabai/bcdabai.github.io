<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>volatile、restrict、gcc优化、内嵌汇编的memory修饰符 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="volatile、restrict、gcc优化、内嵌汇编的memory修饰符" />
<meta property="og:description" content="GCC在C语言中内嵌汇编-转载 http://hi.baidu.com/liu_bin0101/blog/item/433103007852b216738b658d.html 在内嵌汇编中，可以将C语言表达式指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入哪个寄存器，以及如何将计算结果写回C 变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。
1、简单的内嵌汇编
例：
__asm__ __volatile__(&#34;hlt&#34;); &#34;__asm__&#34;表示后面的代码为内嵌汇编，&#34;asm&#34;是&#34;__asm__&#34;的别名。&#34;__volatile__&#34;表示编译器不要优化代码，后面的指令 保留原样，&#34;volatile&#34;是它的别名。括号里面是汇编指令。
2、内嵌汇编举例
使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如在下面的汇编语句：
__asm__ __violate__ (&#34;movl %1,%0&#34; : &#34;=r&#34; (result) : &#34;m&#34; (input));
&#34;movl %1,%0&#34;是指令模板；&#34;%0&#34;和&#34;%1&#34;代表指令的操作数，称为占位符，内嵌汇编靠它们将C 语言表达式与指令操作数相对应。指令模板后面用小括号括起来的是C语言表达式，本例中只有两个：&#34;result&#34;和&#34;input&#34;，他们按照出现的顺序分 别与指令操作数&#34;%0&#34;，&#34;%1&#34;对应；注意对应顺序：第一个C 表达式对应&#34;%0&#34;；第二个表达式对应&#34;%1&#34;，依次类推，操作数至多有10 个，分别用&#34;%0&#34;,&#34;%1&#34;....&#34;%9&#34;表示。在每个操作数前面有一个用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求。 &#34;result&#34;前面的限制字符串是&#34;=r&#34;，其中&#34;=&#34;表示&#34;result&#34;是输出操作数，&#34;r&#34; 表示需要将&#34;result&#34;与某个通用寄存器相关联，先将操作数的值读入寄存器，然后在指令中使用相应寄存器，而不是&#34;result&#34;本身，当然指令执行 完后需要将寄存器中的值存入变量&#34;result&#34;，从表面上看好像是指令直接对&#34;result&#34;进行操作，实际上GCC做了隐式处理，这样我们可以少写一 些指令。&#34;input&#34;前面的&#34;r&#34;表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。
C表达式或者变量与寄存器的关系由GCC自动处理，我们只需使用限制字符串指导GCC如何处理即可。限制字符必须与指令对操作数的要求相匹配，否则产生的 汇编代码将会有错，读者可以将上例中的两个&#34;r&#34;，都改为&#34;m&#34;(m表示操作数放在内存，而不是寄存器中)，编译后得到的结果是：
movl input, result
很明显这是一条非法指令，因此限制字符串必须与指令对操作数的要求匹配。例如指令movl允许寄存器到寄存器，立即数到寄存器等，但是不允许内存到内存的操作，因此两个操作数不能同时使用&#34;m&#34;作为限定字符。
内嵌汇编语法如下：
__asm__(汇编语句模板: 输出部分: 输入部分: 破坏描述部分)
共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用&#34;:&#34;格开，汇编语句模板必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用&#34;:&#34;格开，相应部分内容为空。例如：
__asm__ __volatile__(&#34;cli&#34;: : :&#34;memory&#34;)
1、汇编语句模板
汇编语句模板由汇编语句序列组成，语句之间使用&#34;;&#34;、&#34;\n&#34;或&#34;\n\t&#34;分开。指令中的操作数可以使用占位符引用C语言变量，操作数占位符最多10个，名称如下：%0，%1，...，%9。指令中使用占位符表示的操作数，总被视为long型（4个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，&#34;b&#34;代表低字节，&#34;h&#34;代表高字节，例如：%h1。
2、输出部分
输出部分描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由限定字符串和C 语言变量组成。每个输出操作数的限定字符串必须包含&#34;=&#34;表示他是一个输出操作数。
例：
__asm__ __volatile__(&#34;pushfl ; popl %0 ; cli&#34;:&#34;=g&#34; (x) )
描述符字符串表示对该变量的限制条件，这样GCC 就可以根据这些条件决定如何分配寄存器，如何产生必要的代码处理指令操作数与C表达式或C变量之间的联系。
3、输入部分
输入部分描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符由限定字符串和C语言表达式或者C语言变量组成。
例1 ：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b845ec71e6ae8a791b393f142e724a82/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-09-22T18:19:49+08:00" />
<meta property="article:modified_time" content="2011-09-22T18:19:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">volatile、restrict、gcc优化、内嵌汇编的memory修饰符</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>GCC在C语言中内嵌汇编-转载</h3> 
<p><a href="http://hi.baidu.com/liu_bin0101/blog/item/433103007852b216738b658d.html" rel="nofollow">http://hi.baidu.com/liu_bin0101/blog/item/433103007852b216738b658d.html</a> </p> 
<div class="tit"> 
 <br> 
</div> 
<p>在内嵌汇编中，可以将C语言表达式指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入哪个寄存器，以及如何将计算结果写回C 变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。<br><br> 1、简单的内嵌汇编<br> 例：</p> 
<p>       __asm__ __volatile__("hlt"); "__asm__"表示后面的代码为内嵌汇编，"asm"是"__asm__"的别名。"__volatile__"表示编译器不要优化代码，后面的指令 保留原样，"volatile"是它的别名。括号里面是汇编指令。<br><br> 2、内嵌汇编举例<br>    使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如在下面的汇编语句：<br>     <br><br> __asm__ __violate__ ("movl %1,%0" : "=r" (result) : "m" (input));<br><br><br> "movl %1,%0"是指令模板；"%0"和"%1"代表指令的操作数，称为占位符，内嵌汇编靠它们将C 语言表达式与指令操作数相对应。指令模板后面用小括号括起来的是C语言表达式，本例中只有两个："result"和"input"，他们按照出现的顺序分 别与指令操作数"%0"，"%1"对应；注意对应顺序：第一个C 表达式对应"%0"；第二个表达式对应"%1"，依次类推，操作数至多有10 个，分别用"%0","%1"...."%9"表示。在每个操作数前面有一个用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求。 "result"前面的限制字符串是"=r"，其中"="表示"result"是输出操作数，"r" 表示需要将"result"与某个通用寄存器相关联，先将操作数的值读入寄存器，然后在指令中使用相应寄存器，而不是"result"本身，当然指令执行 完后需要将寄存器中的值存入变量"result"，从表面上看好像是指令直接对"result"进行操作，实际上GCC做了隐式处理，这样我们可以少写一 些指令。"input"前面的"r"表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。<br>    C表达式或者变量与寄存器的关系由GCC自动处理，我们只需使用限制字符串指导GCC如何处理即可。限制字符必须与指令对操作数的要求相匹配，否则产生的 汇编代码将会有错，读者可以将上例中的两个"r"，都改为"m"(m表示操作数放在内存，而不是寄存器中)，编译后得到的结果是：<br>              movl input, result<br> 很明显这是一条非法指令，因此限制字符串必须与指令对操作数的要求匹配。例如指令movl允许寄存器到寄存器，立即数到寄存器等，但是不允许内存到内存的操作，因此两个操作数不能同时使用"m"作为限定字符。<br><br> 内嵌汇编语法如下：<br>        __asm__(汇编语句模板: 输出部分: 输入部分: 破坏描述部分)<br> 共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用":"格开，汇编语句模板必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用":"格开，相应部分内容为空。例如：<br>              __asm__ __volatile__("cli": : :"memory")<br><br> 1、汇编语句模板<br>     汇编语句模板由汇编语句序列组成，语句之间使用";"、"\n"或"\n\t"分开。指令中的操作数可以使用占位符引用C语言变量，操作数占位符最多10个，名称如下：%0，%1，...，%9。指令中使用占位符表示的操作数，总被视为long型（4个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，"b"代表低字节，"h"代表高字节，例如：%h1。<br><br> 2、输出部分<br>     输出部分描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由限定字符串和C 语言变量组成。每个输出操作数的限定字符串必须包含"="表示他是一个输出操作数。<br> 例：<br>            __asm__ __volatile__("pushfl ; popl %0 ; cli":"=g" (x) )<br> 描述符字符串表示对该变量的限制条件，这样GCC 就可以根据这些条件决定如何分配寄存器，如何产生必要的代码处理指令操作数与C表达式或C变量之间的联系。<br><br> 3、输入部分<br> 输入部分描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符由限定字符串和C语言表达式或者C语言变量组成。<br> 例1 ：<br>              __asm__ __volatile__ ("lidt %0" : : "m" (real_mode_idt));<br> 例二（bitops.h）：<br><br><br> Static __inline__ void __set_bit(int nr, volatile void * addr)<br> {<!-- --><br>          __asm__(<br>                          "btsl %1,%0"<br>                          :"=m" (ADDR)<br>                          :"Ir" (nr));<br> }<br><br> 后 例功能是将(*addr)的第nr位设为1。第一个占位符%0与C 语言变量ADDR对应，第二个占位符%1与C语言变量nr对应。因此上面的汇编语句代码与下面的伪代码等价：btsl nr, ADDR，该指令的两个操作数不能全是内存变量，因此将nr的限定字符串指定为"Ir"，将nr 与立即数或者寄存器相关联，这样两个操作数中只有ADDR为内存变量。<br><br> 4、限制字符<br>    4.1、限制字符列表<br>    限制字符有很多种，有些是与特定体系结构相关，此处仅列出常用的限定字符和i386中可能用到的一些常用的限定符。它们的作用是指示编译器如何处理其后的C语言变量与指令操作数之间的关系。<br><br>    分类            限定符                    描述<br>   通用寄存器       "a"               将输入变量放入eax<br>                                               这里有一个问题：假设eax已经被使用，那怎么办？<br>                                  其实很简单：因为GCC 知道eax 已经被使用，它在这段汇编代码<br>                                  的起始处插入一条语句pushl %eax，将eax 内容保存到堆栈，然<br>                                  后在这段代码结束处再增加一条语句popl %eax，恢复eax的内容<br>                    "b"               将输入变量放入ebx<br>                              "c"               将输入变量放入ecx<br>                              "d"                将输入变量放入edx<br>                              "s"               将输入变量放入esi<br>                              "d"               将输入变量放入edi<br>                              "q"              将输入变量放入eax，ebx，ecx，edx中的一个<br>                    "r"               将输入变量放入通用寄存器，也就是eax，ebx，ecx，<br>                                          edx，esi，edi中的一个<br>                      "A"              把eax和edx合成一个64 位的寄存器(use long longs)<br><br>        内存             "m"             内存变量<br>                      "o"             操作数为内存变量，但是其寻址方式是偏移量类型，<br>                                        也即是基址寻址，或者是基址加变址寻址<br>                      "V"             操作数为内存变量，但寻址方式不是偏移量类型<br>                      " "             操作数为内存变量，但寻址方式为自动增量<br>                      "p"             操作数是一个合法的内存地址（指针）<br><br>      寄存器或内存     "g"             将输入变量放入eax，ebx，ecx，edx中的一个<br>                                        或者作为内存变量<br>                        "X"            操作数可以是任何类型<br><br>      立即数<br>                      "I"             0-31之间的立即数（用于32位移位指令）<br>                        "J"             0-63之间的立即数（用于64位移位指令）<br>                      "N"             0-255之间的立即数（用于out指令）<br>                      "i"             立即数  <br>                      "n"            立即数，有些系统不支持除字以外的立即数，<br>                                        这些系统应该使用"n"而不是"i"<br><br>      匹配             " 0 "，         表示用它限制的操作数与某个指定的操作数匹配，<br>                      "1" ...               也即该操作数就是指定的那个操作数，例如"0"<br>                        "9"            去描述"％1"操作数，那么"%1"引用的其实就<br>                                        是"%0"操作数，注意作为限定符字母的0－9 与<br>                                        指令中的"％0"－"％9"的区别，前者描述操作数，<br>                                        后者代表操作数。<br>                        &amp;                     该输出操作数不能使用过和输入操作数相同的寄存器<br><br>     操作数类型         "="          操作数在指令中是只写的（输出操作数）  <br>                        "+"          操作数在指令中是读写类型的（输入输出操作数）<br><br>      浮点数             "f"          浮点寄存器<br>                        "t"           第一个浮点寄存器<br>                        "u"          第二个浮点寄存器<br>                        "G"          标准的80387浮点常数<br>                        %                   该操作数可以和下一个操作数交换位置<br>                                        例如addl的两个操作数可以交换顺序<br>                                       （当然两个操作数都不能是立即数）<br>                        #                   部分注释，从该字符到其后的逗号之间所有字母被忽略<br>                        *                     表示如果选用寄存器，则其后的字母被忽略<br><br> 5、破坏描述部分<br>    破坏描述符用于通知编译器我们使用了哪些寄存器或内存，由逗号格开的字符串组成，每个字符串描述一种情况，一般是寄存器名；除寄存器外还有"memory"。例如："%eax"，"%ebx"，"memory"等。<br><br> "memory"比较特殊，可能是内嵌汇编中最难懂部分。为解释清楚它，先介绍一下编译器的优化知识，再看C关键字volatile。最后去看该描述符。<br><br> 1、编译器优化介绍<br>    内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入硬件高速缓存Cache，加速对内存的访问。另外在现代CPU中指令的执行并不一定 严格按照顺序执行，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。以上是硬件级别的优化。再看软件一级的优化：一种是在编 写代码时由程序员优化，另一种是由编译器进行优化。编译器优化常用的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用CPU指令流水线，常见的是重 新排序读写指令。对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬件重新排序引起的问题的解决办法是在从硬件（或者其他处 理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memory barrier），linux 提供了一个宏解决编译器的执行顺序问题。<br>                              void Barrier(void)<br> 这个函数通知编译器插入一个内存屏障，但对硬件无效，编译后的代码会把当前CPU寄存器中的所有修改过的数值存入内存，需要这些数据的时候再重新从内存中读出。<br><br> 2、C语言关键字volatile<br>      C 语言关键字volatile（注意它是用来修饰变量而不是上面介绍的__volatile__）表明某个变量的值可能在外部被改变，因此对这些变量的存取 不能缓存到寄存器，每次使用时需要重新存取。该关键字在多线程环境下经常使用，因为在编写多线程的程序时，同一个变量可能被多个线程修改，而程序通过该变 量同步各个线程，例如：<br>      DWORD __stdcall threadFunc(LPVOID signal)<br>      {<!-- --><br>        int* intSignal=reinterpret_cast&lt;int*&gt;(signal);<br>        *intSignal=2;<br>        while(*intSignal!=1)<br>                  sleep(1000);<br>        return 0;<br>      }<br> 该线程启动时将intSignal 置为2，然后循环等待直到intSignal 为1 时退出。显然intSignal的值必须在外部被改变，否则该线程不会退出。但是实际运行的时候该线程却不会退出，即使在外部将它的值改为1，看一下对应的伪汇编代码就明白了：<br>    mov ax,signal<br>      label:<br>      if(ax!=1)<br>                goto label<br><br>    对于C编译器来说，它并不知道这个值会被其他线程修改。自然就把它cache在寄存器里面。记住，C 编译器是没有线程概念的！这时候就需要用到volatile。volatile 的本意是指：这个值可能会在当前线程外部被改变。也就是说，我们要在threadFunc中的intSignal前面加上volatile关键字，这时 候，编译器知道该变量的值会在外部改变，因此每次访问该变量时会重新读取，所作的循环变为如下面伪码所示：<br>    label:<br>      mov ax,signal<br>      if(ax!=1)<br>              goto label<br><br> 3、Memory<br>      有了上面的知识就不难理解Memory修改描述符了，Memory描述符告知GCC：<br>      1）不要将该段内嵌汇编指令与前面的指令重新排序；也就是在执行内嵌汇编代码之前，它前面的指令都执行完毕<br>      2）不要将变量缓存到寄存器，因为这段代码可能会用到内存变量，而这些内存变量会以不可预知的方式发生改变，因此GCC插入必要的代码先将缓存到寄存器的变量值写回内存，如果后面又访问这些变量，需要重新访问内存。<br><br>    如果汇编指令修改了内存，但是GCC 本身却察觉不到，因为在输出部分没有描述，此时就需要在修改描述部分增加"memory"，告诉GCC 内存已经被修改，GCC 得知这个信息后，就会在这段指令之前，插入必要的指令将前面因为优化Cache 到寄存器中的变量值先写回内存，如果以后又要使用这些变量再重新读取。<br><br>    使用"volatile"也可以达到这个目的，但是我们在每个变量前增加该关键字，不如使用"memory"方便</p> 
<p> </p> 
<h3> 关于编译器优化的两个类型限定词：volatile和restrict </h3> 
<p><a href="http://www.diybl.com/course/3_program/c++/cppjs/2008331/107755.html" rel="nofollow">http://www.diybl.com/course/3_program/c++/cppjs/2008331/107755.html</a> </p> 
<p> </p> 
<p>最近开始学习C语言，想把学习过程中的一些心得记录下来，权当自己学习经历中的笔记吧。如果你无意中看到这些文章，能帮我指出其中一些理解不正确的地方，在这里小弟将万分感谢。呵呵。<br>        volatile和restrict这两个类型限定词的运用与编译器的优化存在着一定的关系。volatile这个关键字用在变量类型定义上，指明这个变 量的值存在不确定因素。也就是说这个变量不光会被我们编写的程序改变值，也可能会被某个外部代理改变（比如：某个硬件中断、外部程序等）。这样就不能保证 如果程序没有改变这个变量值，而又存在多次调用后进入寄存器中的值就一定正确。<br>        从编译器的优化角度，举个例子：<br>        int x=5;<br>        int a, b;<br>        a = x;<br>        b = x;<br>        由于程序没有更改X的值，但又存在多次调用，编译器为了优化运行速度，会给a赋值后，把X的值5从内存放入到寄存器中。当给b赋值时，不是再次读取X内存 地址中的值，而是直接把寄存器中的5赋给b。这一优化对于普通变量没有问题。但如果定义成 volatile int x;则表明x可以被程序代码外的其他代理改变值。如果编译器也采用这样的优化，很可能在给b赋值时，x的值已经被程序外部的某个硬件中断改变了。这样从寄 存器获取到的值肯定是不正确的。<br>        因此当给变量加上volatile关键字，除了表示这一变量可以被其他代理改变值，也明确说明编译 器不能为此变量进行上面那种方式的优化：每次调用这一变量，都从变量的地址中获取值，而不是寄存器（此变量使用的硬件内存地址是与其他并行运行的程序共享 数据的，因此不管是程序自身改变变量值，还是其他代理改变变量值，都是改变内存地址中的数据）。<br>       看个有趣的例子：<br>       int square(volatile int *a)<br>       {<!-- --><br>            return (*a * *a);<br>       }<br>       函数的目的本来是计算平方根，但由于a指针用了volatile关键字，两次获取a指针地址中的值不能完全保证一样，所以计算出来的结果也未必就是我们需要的。考虑修改成这样：<br>       int square(volatile int *a)<br>       {<!-- --><br>            int temp = *a;<br>            return (temp * temp);<br>       }</p> 
<p>      restrict关键字只能用来修饰指针，表示被定义的指针是访问指针中数据的唯一途径。这一目的是告诉编译器可以进行一些优化。看个例子：<br>       int x = 2;<br>       int *a = (int *) malloc(sizeof(int));<br>       *a = 2;<br>       int *b = &amp;x;<br>       *a += 2;<br>       *b += 2;<br>       x *= 3;<br>       *a += 3;<br>       *b += 3; <br>      编译器进行优化时可以用一条语句代替：*a += 5;这对于a来说是正确的，但如果用*b += 5来优化b是不正确的。因为其他变量影响了结果。因此，当编译器不确定某些因素时，会放弃寻找某个途径进行优化。如果在变量前加上restrict关键 字。则告诉编译器可以“放心大胆”的进行优化。但编译器并不会验证你定义为restrict的指针，是否真正是某个数据的唯一访问途径；就像数组的下标越 界一样，如果你不遵守规则，编译器并不会指出错误，但后果由你自己负责：）<br>      同样看个有趣的类子：<br>     void change_array(restrict int *array, const restrict int *value,const int size)<br>     {<!-- --><br>            for(int i=0;i&lt;size;i++)<br>            {<!-- --><br>                   array[i] += *value;<br>            }<br>     }</p> 
<p>    int main(void)<br>     {<!-- --><br>            int *array[SIZE]  = {1,2,3};<br><br>           change_array(array,&amp;array[0],SIZE);<br><br>           for(int i=0;i&lt;SIZE;i++)<br>           {<!-- --><br>                 printf("%d \n",array[i]);<br>          }<br>      }<br>      如果编译器支持优化，运行后的结果是：2   3   4   而不是实际正确的结果：2   4   5 。这是在定义函数时，指明两个指针为restrict，因此编译器进行优化了：在程序调用函数时，将value指针的变量值在寄存器中生成了一个副本。后 面的执行都是获取寄存器上的value值。同时可以看出，当你没有遵守restrict定义的指针指向的变量只能通过该指针修改的规则时（函数中 value指针指向的数据，在main调用时，array指针也进行了修改），编译器不会检查。<br>     对于优化来说，volatile是强制性，而restrict是建议性。也就是加了volatile则强制不进行优化，而加入restrict编译器也不 一定肯定优化。大部分情况下restrict和什么都不加编译结果相同，restrict只是告诉编译器可以自由地做一些相关优化的假定。同时也告诉调用 者仅使用满足restrict定义条件的参数，如果你不遵守，嘿嘿。。。<br><br>      restrict这个关键字是C99标准加入，在C++中不支持，因此我在VC++中加入restrict关键字编译不了：（<br>      关于restrict的加入，在网上还找到一段小故事：<br>      为了提高 Cray机器上的效率, ANSI C委员会提出过一种称为noalias的机制来解决这个问题，用它来说明某个C指针可以认为是没有别名, 只是这种机制不成熟，这件事激怒了Dennis Ritchie，拿他对C的标准化过程做了唯一的一次干预。他写了一封公开信说“noalias必须靠边站，这一点是不能协商的。”  <br><br>       后来Cray的Mike Holly又抓起了这个难题，向数值C语言扩充工作组和C++委员会提出了一种改进的反别名建议。所建议的想法是允许程序员说明一个指针可以认为是没有别 名的，采用的方式是将它说明为restrict。  这个建议C99采纳了，但标准C++拒绝了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/183b11e5c9d5b3dff2414e876f786d5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaScript 获得 汉字 的 完整 拼音</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8581a33c7ae856859fee2dd4e728e6b2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Invalid location of tag (form) 的提示 原因</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>