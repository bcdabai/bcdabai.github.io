<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【HBZ分享】ES中的DLS命令使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【HBZ分享】ES中的DLS命令使用" />
<meta property="og:description" content="ES中常见的DLS关键字及命令的使用案例 match：匹配关键字，包含分词的模糊匹配，以及精准匹配 title: 字段的名称， elasticsearch要查的内容，即查询title中带有elasticsearch的文档 GET /索引库名/_search { &#34;query&#34;: { &#34;match&#34;: { &#34;title&#34;: &#34;elasticsearch&#34; } } } term：用于精确匹配一个指定字段的关键词，不进行分词处理。 category: 字段的名称， books要查的内容， 即查询category = books的文档 GET /索引库名/_search { &#34;query&#34;: { &#34;term&#34;: { &#34;category&#34;: &#34;books&#34; } } } match_all: 全量查询，一般很少用，所有数据全都查出来 match_all后面的大括号就这么写就行，啥也不需要加 GET /shop_v1/_search { &#34;query&#34;: { &#34;match_all&#34;: {} } } es中的分页 以及 范围查询 gte:大于等于
gt:大于
lte:小于等于
lt:小于
范围擦汗寻， 查询price在5-10之间的数据 GET /shop_v1/_search { &#34;query&#34;: { &#34;range&#34;: { &#34;price&#34;: { &#34;gte&#34;: 5, &#34;lte&#34;: 100 } } } } 分页查询， size = 每次查询的条数， from = 从第几条开始查 GET /shop_v1/_search { &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0cc4d3448f71857f3d06894d5d3284c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-05T16:49:57+08:00" />
<meta property="article:modified_time" content="2023-11-05T16:49:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【HBZ分享】ES中的DLS命令使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="ESDLS_0"></a>ES中常见的DLS关键字及命令的使用案例</h2> 
<ol><li>match：匹配关键字，包含分词的模糊匹配，以及精准匹配</li></ol> 
<pre><code>title: 字段的名称， elasticsearch要查的内容，即查询title中带有elasticsearch的文档
GET /索引库名/_search 
{
  "query": {
    "match": {
      "title": "elasticsearch"
    }
  }
}
</code></pre> 
<ol start="2"><li>term：用于精确匹配一个指定字段的关键词，不进行分词处理。</li></ol> 
<pre><code>category: 字段的名称， books要查的内容， 即查询category = books的文档
GET /索引库名/_search 
{
  "query": {
    "term": {
      "category": "books"
    }
  }
}
</code></pre> 
<ol start="3"><li>match_all: 全量查询，一般很少用，所有数据全都查出来</li></ol> 
<pre><code>match_all后面的大括号就这么写就行，啥也不需要加
GET /shop_v1/_search
{
  "query": {
    "match_all": {}
  }
}
</code></pre> 
<h2><a id="es___40"></a>es中的分页 以及 范围查询</h2> 
<ol><li> <p>gte:大于等于</p> </li><li> <p>gt:大于</p> </li><li> <p>lte:小于等于</p> </li><li> <p>lt:小于</p> </li></ol> 
<pre><code>范围擦汗寻， 查询price在5-10之间的数据
GET /shop_v1/_search
{
  "query": {
    "range": {
      "price": {
        "gte": 5,
        "lte": 100
      }
    }
  }
}
</code></pre> 
<pre><code>分页查询， size = 每次查询的条数， from = 从第几条开始查
GET /shop_v1/_search
{
  "size": 10,
  "from": 0,
  "query": {
    "match_all": {}
  }
}
</code></pre> 
<h2><a id="ES_77"></a>ES中的排序</h2> 
<ol><li>通过sort字段，desc 与 esc分别是降序 与 升序</li></ol> 
<pre><code>使用key = sort， 根据price进行esc升序排序
GET /shop_v1/_search
{
  "size": 10,
  "from": 0,
  "sort": [
    {
      "price": "asc"
    }
  ],
  "query": {
    "match_all": {}
  }
}
</code></pre> 
<h2><a id="ES_97"></a>ES的布尔查询</h2> 
<ol><li> <p>"must"关键字用于指定必须匹配的条件，即所有条件都必须满足</p> </li><li> <p>"must_not"关键字指定必须不匹配的条件，即所有条件都不能满足</p> </li><li> <p>"should"关键字指定可选的匹配条件，即至少满足一个条件</p> </li></ol> 
<pre><code>格式：
{
  "query": {
    "bool": {
      "must": [
        // 必须匹配的条件
      ],
      "must_not": [
        // 必须不匹配的条件
      ],
      "should": [
        // 可选匹配的条件
      ],
      "filter": [
        // 过滤条件
      ]
    }
  }
}
</code></pre> 
<pre><code>案例： 查询，summary字段中，必须包含Cloud的内容(因为是match分词匹配)， 【并且】price的范围必须 &gt;= 5
GET /shop_v1/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "summary": "Cloud" }},
        { "range": { "price": { "gte": 5 }}}
      ]
    }
  }
}
</code></pre> 
<h2><a id="ESfilter_142"></a>ES中的filter过滤</h2> 
<ol><li>filter可以缓存查询数据，达到搞笑</li><li>可以对 【数字范围】，【日期范围】，【布尔逻辑】，【存在性检测】进行操作</li></ol> 
<pre><code>term查询过滤器, 过滤出category = books的数据，完全匹配，因为term是精准匹配的key
GET /product/_search
{
  "query": {
    "bool": {
      "filter": {
        "term": {
          "category": "books"
        }
      }
    }
  }
}
</code></pre> 
<pre><code>range查询过滤器，过滤出price在30-50之间的数据
GET /product/_search
{
  "query": {
    "bool": {
      "filter": {
        "range": {
          "price": {
            "gte": 30,
            "lte": 50
          }
        }
      }
    }
  }
}
</code></pre> 
<p>== 总节： 其实使用filter 和 直接使用range差范围是一致的，只不过filter下面可以同时使用range 与 term等==</p> 
<h2><a id="ESmatch___183"></a>ES中的match多字段匹配 和 短语搜索</h2> 
<ol><li>多字段搜索使用：multi_match</li><li>短语搜索使用：match_phrase</li><li>短语搜索会考虑到短语间多个词语的顺序，比如搜 iPhone 32G, 那么就会把文档中带有【iPhone 32G】的搜索出来，只有iPhone 或 只有32G的数据都是不能搜出来的，又有iPhone 32G在一起的才会被搜索</li></ol> 
<pre><code>多字段搜索使用：multi_match
query = 要搜索的关键词， fields = 该关键词出现的字段都要搜出来
含义：搜索出product_name, description这俩字段中，包含iPhone的文档， 两个字段为OR关系，只要iPhone这个词存在于其中一个字段那么就会被搜索
GET /product_v2/_search
{
 "query": {
   "multi_match": {
     "query": "iPhone",
     "fields": ["product_name", "description"]
   }
 }
}
query：需要匹配的查询文本。
fields：一个包含需要进行匹配的字段列表的数组。
</code></pre> 
<pre><code>短语搜索使用：match_phrase， 搜索description字段中，带有classic noval的文档， 必须classic noval这个顺序，这个词组才行，缺一个词，或顺序不对都不能搜出来
GET /product_v2/_search
{
  "query": {
    "match_phrase": {
      "description": "classic novel"
    }
  }
}
</code></pre> 
<pre><code>match例子
match搜索，会进行分词， 即把classic novel分词，只要description带有classic 或者 novel的都能搜出，这个是match
GET /product_v2/_search
{
  "query": {
    "match": {
      "description": "classic novel"
    }
  }
}
</code></pre> 
<h2><a id="ESfuzzy_234"></a>ES的fuzzy日常拼错矫正查询</h2> 
<ol><li>fuzzy可以自动矫正简单的拼错，比如日常中一个单词，某两个字母写反了，或者漏写了等简单的失误，fuzzy都可以矫正</li><li>但精准度可能比较低，并且比较耗费CPU</li><li>fuzzy模糊查询是根据编辑距离来模糊匹配的</li><li>编辑距离指的是：<br> (1). 更改字符（box→fox)<br> (2). 删除字符（black→lack）<br> (3). 插入字符（sic→sick）<br> (4). 转置两个相邻字符（dgo→dog）</li><li>fuzzy不会进行分词</li><li>模糊度fuzziness: 0,1,2,auto, 其中auto是单词超过5个字符，默认设置为2。小于2个字符，默认设置为0</li></ol> 
<pre><code># 指定模糊度2，更松散匹配, 比如要查询包含cloud的文档，但少写了两个字母，写成了clo， 设置模糊度为2，则可以自动匹配上
-查询summary字段中，包含cloud的文档，输入的查询值为clo， 模糊度设置2
GET /shop_v1/_search
{
  "query": {
    "fuzzy": {
      "summary": {
        "value": "clo",
        "fuzziness": "2"
      }
    }
  }
}

# 指定模糊度1，更严格匹配， 同样搜cloud，但写成了clo, 由于少了两个字母，模糊度为2，但实际设置是1，所以距离不够，无法检索到内容
- 查询summary字段中，包含cloud的文档，输入的查询值为clo， 模糊度设置1
GET /shop_v1/_search
{
  "query": {
    "fuzzy": {
      "summary": {
        "value": "clo",
        "fuzziness": "1"
      }
    }
  }
}

# 使用自动检查，1个单词拼写错误, auto自动设置模糊度，当大于5个字符会默认自动设置模糊度为2， 当小于2个字符，会自动设置模糊度为0
查询summary字段中，包含spring的文档，输入的查询成了Springa， 模糊度设置auto, 由于spring大于5，所以模糊度为2
GET /shop_v1/_search
{
  "query": {
    "fuzzy": {
      "summary": {
        "value": "Sprina",
        "fuzziness": "auto"
      }
    }
  }
}
</code></pre> 
<h2><a id="ES_291"></a>ES的高亮显示</h2> 
<ol><li>基本用法: 在 key = highlight 里面填写要高亮显示的字段，可以填写多个字段，并且高亮的部分就是关键字，在搜出来的文档中，查询输入的内容会是高亮的。</li><li>高亮显示是通过标签包裹匹配的文本来实现的，通常是 <em> 或其他 HTML 标签，当然可以修改这个标签，下面有例子</em></li><li>pre_tags, post_tags是前后置标签，就是改变高亮的样式，默认是<em>, 可以通过这两个去替换em标签，比如用font来替换</em></li></ol> 
<pre><code>查询出 title字段包含【java】 或者 content字段包含【老王】的文档， 并且高亮显示出title, content中的搜索关键字， 关键字高亮的样式设置为&lt;font color='yellow'&gt; java &lt;/font&gt; 这种的，不使用默认的&lt;em&gt;
GET /high_light_test/_search
{
  "query": {
    "bool": {
      "should": [
        {
          "match": {
            "title": "java"
          }
        },
        {
          "match": {
            "content": "老王"
          }
        }
      ]
    }
  },
  "highlight": {
    "pre_tags": "&lt;font color='yellow'&gt;",
    "post_tags": "&lt;/font&gt;",
    "fields": [
    	{
    		"title":{}
    	},
  		{
  			"content":{}
  		}
 	]
  } 
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b3f30d9665e9356ff6c5f89071b1477f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">html将复选框变为圆形样例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d97f7895ecfe555376ef1d8d2f7668c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Keil MDK5解决error: L6002U: Could not open file</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>