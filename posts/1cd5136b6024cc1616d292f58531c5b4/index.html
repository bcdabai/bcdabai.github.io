<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端学习（应对面试） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端学习（应对面试）" />
<meta property="og:description" content="html：常见的块级（div走天下），行内块，行内标签随便能说出几个有代表的，input img a标签单独记忆
css：marigin-padding，font系列，border系列，定位，盒子模型（box-sizing），盒子阴影，flex布局，background系列等
js：数据类型（简单：字符串，数字型等，复杂：数组等）；数组常用方法重点记忆，对象字符串常用方法（分es6前后记忆，es6之前的方法，es6后的方法（filter，map，扩展运算符等）），解构赋值；应付面试还需要记一些，原型链，原型对象，对象原型，箭头函数，作用域，let，const，var区别和理解，promise等
ajax：简单理解记忆即可
vue：webpack可以稍微了解下，vue脚手架熟练使用，vue常用指令（v-model，v-for，v-if，v-else，v-on（@），v-bind（：），v-show）；vue生命周期；vue的computed，watch，data，methods，props，混入等；vue-router，路由基础和使用（保证手写出简单的路由文件）；vuex和路由要求相同，手写出简单的，这些你可以新建一个vue项目，从下载依赖包到写出这两个功能为止；axios的基本使用，$refs等。时间可以看下diff算法
js （1）cookie、localStorage、sessionStorage的区别和使用？
cookie：是存储在本地的数据，有时候也用cookies，通常经过加密，应用最经典的就是判断注册用户是否已经登录过该网站。 localStorage：仅在客户端保存（即浏览器），不参与和服务器的通信；没有时间限制，即使浏览器关闭，数据依然存在；
共同点：都是保存在浏览器端，且同源（同域名同端口下聚合显示）的。
区别：
cookie数据大小不能超过4K，同时因为每次http请求都会携带cookie，所以cookie只能保存很小的数据。
sessionStorage和localStorage不会自动把数据发给服务器，只在本地保存，虽然也有大小限制，但是要比cookie大得多，可以达到5M或者更大。
数据有效期不同，sessionStorage仅在当前浏览器窗口关闭前有效，不能持久保存；localStorage：始终有效，浏览器窗口关闭也一直保存；cookie：只在cookie设置的过期时间之前保存，即使浏览器窗口关闭。
作用域不同，sessionStorage在不同浏览器窗口的数据不能共享，即使是同一个页面；localStorage在所有的同源窗口中都是共享的；cookie也是在同源窗口中共享的，
（2） JS常用数据类型
简单数据类型：数字型Number，字符串类型String，布尔型Boolean，undefined，null
复杂数据类型（引用类型）：对象Object，数组Array。（在存储时仅仅在栈中以地址的形式指向堆）
（3）堆和栈
简单数据类型存储在栈中，复杂数据类型的地址存储在栈中
复杂数据类型存放在堆里面，首先在栈里面存放地址（十六进制表示），地址在指向堆里面的实例，真正的对象实例存放在堆空间中
（4）简单数据类型的相互转换
（1）转换为字符串
①var num = 10;
var str = num.toString();
②String（转换对象）；
③利用加号拼接字符串的方法。
num &#43; ” “;
（2）转换为数组
①parseInt和parseFloat，整数型和浮点型的转换。
语法格式：parseInt（转换的对象）
parseInt(&#34;&#34;) //NaN
转换小数时得到的结果是整数，console.log(parseInt(&#34;3.14&#34;)); //3取整 console.log(parseInt(&#34;120px&#34;)); //120会去除px这个单位。从第一个字符开始，找第一个数
字，否则结果时NaN
和parseFloat（转换的对象）
转换可得到小数（浮点数），转换整数时依旧时整数，用法与上面基本相似。
②利用Number（转换的对象）
var str = “123”；console.log(Number(str));
③利用算数运算（隐式转换）- / *(不用加号)
（3）转换为布尔型
①Boolean()函数 ==&gt; Boolean(&#34;&#34;) //false
②!!
（5）前置运算符和后置运算符的区别
前置运算符返回已经计算出结果的值，即&#43;&#43;3在使用的时候代表4
后置运算符返回未经计算的值，即3&#43;&#43;在使用的时候表示3" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1cd5136b6024cc1616d292f58531c5b4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-24T15:40:16+08:00" />
<meta property="article:modified_time" content="2023-11-24T15:40:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端学习（应对面试）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>html：常见的块级（div走天下），行内块，行内标签随便能说出几个有代表的，<span style="color:#fe2c24;">input img a</span>标签单独记忆</p> 
<p>css：marigin-padding，font系列，border系列，定位，盒子模型（box-sizing），盒子阴影，<span style="color:#fe2c24;">flex布局</span>，background系列等</p> 
<p>js：数据类型（简单：字符串，数字型等，复杂：数组等）；<span style="color:#fe2c24;">数组常用方法重点记忆</span>，对象字符串常用方法（分es6前后记忆，es6之前的方法，<span style="color:#fe2c24;">es6后的方法</span>（filter，map，扩展运算符等）），<span style="color:#fe2c24;">解构赋值</span>；应付面试还需要记一些，原型链，原型对象，对象原型，箭头函数，作用域，let，const，var区别和理解，promise等</p> 
<p>ajax：简单理解记忆即可</p> 
<p>vue：webpack可以稍微了解下，vue脚手架熟练使用，<span style="color:#fe2c24;">vue常用指令</span>（v-model，v-for，v-if，v-else，v-on（@），v-bind（：），v-show）；<span style="color:#fe2c24;">vue生命周期</span>；vue的<span style="color:#fe2c24;">computed，watch</span>，data，methods，props，混入等；<span style="color:#fe2c24;">vue-router</span>，路由基础和使用（保证手写出简单的路由文件）；vuex和路由要求相同，手写出简单的，这些你可以新建一个vue项目，从下载依赖包到写出这两个功能为止；axios的基本使用，$refs等。时间可以看下diff算法</p> 
<p></p> 
<h2>js</h2> 
<p>（1）cookie、localStorage、sessionStorage的区别和使用？</p> 
<blockquote> 
 <p>cookie：是存储在本地的数据，有时候也用cookies，通常经过加密，应用最经典的就是判断注册用户是否已经登录过该网站。   localStorage：仅在客户端保存（即浏览器），不参与和服务器的通信；没有时间限制，即使浏览器关闭，数据依然存在；<br>   <br>     共同点：都是保存在浏览器端，且同源（同域名同端口下聚合显示）的。<br>     区别：<br>         cookie数据大小不能超过4K，同时因为每次http请求都会携带cookie，所以cookie只能保存很小的数据。<br>         sessionStorage和localStorage不会自动把数据发给服务器，只在本地保存，虽然也有大小限制，但是要比cookie大得多，可以达到5M或者更大。<br>         数据有效期不同，sessionStorage仅在当前浏览器窗口关闭前有效，不能持久保存；localStorage：始终有效，浏览器窗口关闭也一直保存；cookie：只在cookie设置的过期时间之前保存，即使浏览器窗口关闭。<br>         作用域不同，sessionStorage在不同浏览器窗口的数据不能共享，即使是同一个页面；localStorage在所有的同源窗口中都是共享的；cookie也是在同源窗口中共享的，</p> 
</blockquote> 
<p>（2） JS常用数据类型</p> 
<p>简单数据类型：数字型Number，字符串类型String，布尔型Boolean，undefined，null</p> 
<p>复杂数据类型（引用类型）：对象Object，数组Array。（<span style="color:#a2e043;">在存储时仅仅在栈中以地址的形式指向堆</span>）</p> 
<p>（3）堆和栈</p> 
<p>简单数据类型存储在栈中，复杂数据类型的地址存储在栈中</p> 
<p>复杂数据类型存放在堆里面，首先在栈里面存放地址（十六进制表示），地址在指向堆里面的实例，真正的对象实例存放在堆空间中</p> 
<p>（4）简单数据类型的相互转换</p> 
<p>        （1）转换为字符串</p> 
<p>        ①var num = 10;</p> 
<p>        var str = num.toString();</p> 
<p>        ②String（转换对象）；</p> 
<p>        ③利用加号拼接字符串的方法。</p> 
<p>        num + ” “;</p> 
<p>        （2）转换为数组</p> 
<p>        ①parseInt和parseFloat，整数型和浮点型的转换。</p> 
<p>        语法格式：parseInt（转换的对象）</p> 
<p>        parseInt("") //NaN</p> 
<p>        转换小数时得到的结果是整数，console.log(parseInt("3.14")); //3取整         console.log(parseInt("120px")); //120会去除px这个单位。从第一个字符开始，找第一个数</p> 
<p>        字，否则结果时NaN</p> 
<p>        和parseFloat（转换的对象）</p> 
<p>        转换可得到小数（浮点数），转换整数时依旧时整数，用法与上面基本相似。</p> 
<p>        ②利用Number（转换的对象）</p> 
<p>        var str = “123”；console.log(Number(str));</p> 
<p>        ③利用算数运算（隐式转换）<strong>- / *(不用加号)</strong></p> 
<p><strong>        </strong>（3）转换为布尔型</p> 
<p>        ①Boolean()函数 ==&gt; Boolean("") //false</p> 
<p>        ②!!</p> 
<p>（5）前置运算符和后置运算符的区别</p> 
<p>前置运算符返回已经计算出结果的值，即++3在使用的时候代表4</p> 
<p>后置运算符返回未经计算的值，即3++在使用的时候表示3</p> 
<p><span style="color:#a2e043;">无论前置运算符还是后置运算符，都会使操作的变量产生相应的递增或递减，但对于++a这个式子而言，含义有所不同</span></p> 
<p>（6）逻辑中断</p> 
<p>对于&amp;&amp;或者||</p> 
<p>&amp;&amp;：前一个条件为假的话，即可判断出逻辑语句的结果，所以此情况下系统会只判断前一个语句，后面的语句属于多余条件，不进行判断所有会造成逻辑中断</p> 
<p>||： 前一个条件为真的话，即可判断出逻辑语句的结果，所以此情况下系统会只判断前一个语句，后面的语句属于多余条件，不进行判断所有会造成逻辑中断</p> 
<p>（7）continue和break、reaturn关键字的区别</p> 
<p>continue立即跳出本次循环，继续下一次循环。在循环中return和continue的用法一值。</p> 
<p>break关键字立即退出整个循环。</p> 
<p>return在函数中代表函数的结束并返回return后的值为函数的返回值，且不会执行return之后的语句。</p> 
<p>（8）原型链</p> 
<p>前置知识：</p> 
<p>        构造函数（类）：每一个实例化的类表示对象，而类即是构造函数，例如，一个水果表示一个类，通过水果这个类实例化出一个对象——一个苹果，即苹果就是对象。构造函数是概括了一类事物的集合，通过将集合的各个属性实例化，就可以创造出对象。</p> 
<p>class Father {<!-- --></p> 
<p>     constructor(uname) {<!-- --></p> 
<p>        this.uname= uname</p> 
<p>     }</p> 
<p>}</p> 
<p>let obj = new Father("zs") // { uname: "zs" }</p> 
<p>原型链: </p> 
<p>       <span style="color:#a2e043;"> 每一个构造函数都存在一个属性prototype，他也是一个对象，其中存储一些公共方法和属性</span>，即表示存储这个类的一些特征，而实例对象（我们使用中定义的对象）通过构造函数实例化，为了表示他是由哪个类所创建，于是<span style="color:#a2e043;">在生成实例对象的时候，会把prototype完全复制到实例对象中，形成__proto__这个属性，两者一模一样</span>，且栈中的地址相同，修改其中一个的属性，另一个会相应变化。而prototype中又有一个属性constructor，他表示类的本身，也就是构造函数本身，所以这三者会形成一种链式结构————————原型链。</p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/97/34/JHFEUV1v_o.png" width="588"></p> 
<p>由于每一个原型对象， prototype它也是一个对象，他也存在构造函数，所以通过他的__proto__会一直指向最终的构造函数 Object</p> 
<p><img alt="" height="361" src="https://images2.imgbox.com/26/8f/zHqu40j3_o.png" width="813"></p> 
<p></p> 
<p>（9）call，apply，bind三者的区别和联系</p> 
<p>        (1) call方法 fn.call(被指向的对象,函数参数) 改变函数this的指向</p> 
<p>        主要作用可以实现继承</p> 
<p>        (2) apply调用函数,也可以改变函数内部this的指向</p> 
<ul><li>但是他的参数必须是数组形式(伪数组)apply(被指向的对象,['1','2'])</li><li>apply的主要应用:</li><li>利用apply借助数学内置对象求最大值等:Math.max.apply(Math, 数组) <em>//指向没有改变,所以只是相当于调用Math.max方法,数组(apply传参方式)为此方法本来需要传递的参数.</em></li></ul> 
<p>        (3) bind方法 绑定的意思</p> 
<p>        fn.bind(被指向的对象)</p> 
<ul><li>不会调用原来的函数</li><li>可以改变原来函数内部的this指向</li><li>返回的是原函数改变this之后产生的新函数,不会改变原函数</li></ul> 
<p>        如果有的函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind</p> 
<p>（10）闭包</p> 
<p>闭包指可以被另外一个函数访问其变量的函数</p> 
<p>函数嵌套函数的时候，内部函数可以访问外部函数的变量</p> 
<p><u>闭包的主要作用,延伸了变量的作用范围</u></p> 
<p><em>上层作用域的变量，会通过[[Scopes]]属性存在闭包函数中，而这个属性中的 Closure对象就是我们需要的闭包数据，上层作用域里的变量数据,所以,造成内存被占用,一直不释放,也就是内存泄漏.可以实现外部访问闭包函数.一个作用域的变量互通</em></p> 
<h2>ajax等知识点</h2> 
<p>（1）ajax简述</p> 
<p><strong>ajax（A</strong>synchronous <strong>J</strong>avascript <strong>A</strong>nd <strong>X</strong>ML<strong>）</strong>异步JavaScript和XML</p> 
<p>使用 JavaScript 向服务器提出请求并处理响应而不阻塞用户核心对XMLHttpRequest。通过这个对象，您的 JavaScript 可在不重载页面的情况与 Web 服务器交换数据，即在不需要刷新页面的情况下，就可以产生局部刷新的效果。</p> 
<p><span style="color:#a2e043;">ajax可以视作对js内置XMLHttpRequest对象的优化和封装</span></p> 
<p>（2）XMLHttpRequest对象详解</p> 
<p>        使用XHR发起GET请求</p> 
<pre><code>var xhr = new XMLHttpRequest()
xhr.open('GET','http://www.liulongbin.top:3006/api/getbooks') // 参数通过?xx=ss&amp;ss=ss方式拼接在url后面
xhr.sent()
xhr.onreadystatechange = funciton() {
    if(xhr.readyState === 4(请求完成) &amp;&amp; xhr.status === 200(请求成功)) { //判断的属性的status是创建对象xhr里的属性,代表服务器响应的状态,不可以更改
    console.log(xhr.responseText) //响应回数据中的status,是服务器端返回数据的状态,通过后端可以更改
    }

}</code></pre> 
<p>        使用XHR发起POST请求</p> 
<pre><code>var xhr = new XMLHttpRequest()
xhr.open('POST','http://www.liulongbin.top:3006/api/addbook')
xhr.setRequestHeader('Conetnt-Type','application/x-www-form-urlencoded')
xhr.sent('')(提交数据使用字符串格式,多个数据使用&amp;连接,不可以在open中拼接字符串,需要在sent中写入)
xhr.onreadystatechange = funciton() {
    if(xhr.readyState === 4 &amp;&amp; xhr.status === 200) { 
        console.log(xhr.responseText) //得到的是一个JSON字符串
    }

}</code></pre> 
<p>        xhr对象的readyState属性<img alt="" height="223" src="https://images2.imgbox.com/d7/1a/hwlMc9wU_o.png" width="683"></p> 
<p>（3）常用http状态码</p> 
<p>百度</p> 
<p>（4）什么是跨域</p> 
<p>由浏览器同源策略限制的一类请求场景，当两个不同地址，不同端口，不同协议之间请求就会产生跨域。</p> 
<p>（5）防抖和节流</p> 
<p>防抖：是当事件被触发后,延迟n秒后再执行回调,如果在n秒内事件又被触发,则重新计时</p> 
<pre><code>// html
&lt;button id="button"&gt;防抖&lt;/button&gt;
// js
let button = document.getElementById("button")
let timer
button.addEventListener('click', function() {
  if (timer) { clearTimeout(timer) }
  timer = setTimeout(() =&gt; {
    console.log(11111);
  }, 1000)
})</code></pre> 
<p>节流：节流策略，顾名思义，可以减少一段时间内事件的触发的频率。</p> 
<p>当鼠标连续不断地触发某时间，只在单位时间内触发一次。期间的点击无效</p> 
<pre><code>// html
&lt;button id="button"&gt;节流&lt;/button&gt;

// js
let button = document.getElementById("button")
let flag = false
button.addEventListener('click', function() {
  if (!flag) {
    flag = true
    setTimeout(() =&gt; {
      flag = false
    }, 1000)
    console.log(11111);
  }
})</code></pre> 
<p>（6）git常用命令行</p> 
<p>        git status // 查看暂存区文件和修改后文件状态</p> 
<p>        git add . // 将更改文件存入暂存区</p> 
<p>        git commit -m "xxx" // 将暂存区文件提交在本地git仓库</p> 
<p>        git checkout xxx // 切换指定分支</p> 
<p>        git branch // 查看所有分支（当前分支高亮显示）</p> 
<p>        git clone xxx // 克隆远程分支代码（xxx为远程分支代码）</p> 
<p>        git checkout -b xxx // 创建并切换为此分支</p> 
<p>        git pull origin 远程分支:本地分支 // 将远程分支拉取到本地分支，（当本地分支未创建时，自动创建，并合并远程分支到当前分支）</p> 
<p>        git merge xxx // 将指定分支合并到当前分支</p> 
<p>        git push origin 本地分支:远程分支 // 将本地分支推到远程分支，（当远程分支未创建时，会自动创建）</p> 
<p>（7）webpack相关知识了解一下，有助于理解vue</p> 
<p>（8）正则表达式，稍微看一下</p> 
<h2>vue部分</h2> 
<p>（1）vue常用指令</p> 
<p>v-bind：</p> 
<p>        目标: 给标签属性设置vue变量的值</p> 
<p>        v-bind语法和简写</p> 
<p>        语法:v-bind:属性名="vue变量"</p> 
<p>        简写:  :属性名="vue变量"</p> 
<p>v-on:        </p> 
<p>        目标: 给标签绑定事件</p> 
<p>        语法</p> 
<p>        v-on: 事件名="要执行的少量代码"</p> 
<p>        v-on: 事件名=“methods中的函数名"</p> 
<p>        v-on: 事件名=“methods中的函数名(实参)"</p> 
<p>        @事件名=...简写形式</p> 
<p>        方法在methods选项定义</p> 
<p>v-model:</p> 
<p>        value属性和vue数据变量,双向绑定到一起</p> 
<p>        语法: v-model="Vue数据变量"</p> 
<p>        双向数据绑定(双向指定的value属性-vue变量,暂时只能用在表单标签,后期可以用在组件中)</p> 
<p>        变量变化 -&gt; 视图自动同步</p> 
<p>        视图变化 -&gt; 变量自动同步</p> 
<p>        vue变量的初始值会影响表单的默认数据</p> 
<p>       <span style="color:#a2e043;"> v-model的本质：v-bind（变量改变标签使用的变量跟随变化（属性名）） + v-on（标签事件改变时定义变量跟随改变（事件名））</span></p> 
<p>v-text和v-html</p> 
<ul><li>v-text="Vue数据变量",用的较多</li><li>v-html="Vue数据变量",用的较少,因为有安全风险</li></ul> 
<p>v-show和v-if</p> 
<p>        控制标签的隐藏和出现(true时显示，false隐藏)</p> 
<p>        show的本质是css display: block; display: none;的封装</p> 
<p>        if的本质是从节点树中删除和插入</p> 
<p>        v-if 可以搭配 v-else v-else-if使用和if语句相同</p> 
<p>v-for  </p> 
<p>        列表渲染, 所在标签结构, 按照数据数量, 循环生成</p> 
<p>        语法:</p> 
<ul><li>v-for="(值变量, 索引变量) in 目标结构"</li><li>v-for="值变量 in 目标结构"</li></ul> 
<p>        注意: </p> 
<ul><li>想要谁循环就放在谁身上(根据遍历到的数据动态生成标签)</li><li>目标结构可以是数组/对象/字符串(可遍历结构)</li><li>循环都是独立执行的</li><li>v-for的临时变量名只能用在v-for范围内</li></ul> 
<p>（2）动态class动态style</p> 
<p>        语法 :class="{类名: 布尔值}"；语法 :style="{css属性名: 值}"  </p> 
<p>（3）过滤器</p> 
<p>        转换格式，过滤器就是一个函数，传入值返回处理后的值</p> 
<p>        过滤器只能用在，插值表达式和v-bind动态属性里</p> 
<p>        语法：</p> 
<ul><li>Vue.filter("过滤器名", (值) =&gt; {return "返回处理后的值"})   // 全局过滤器,可以生效在所有的vue文件中</li><li>filters: {过滤器名字: (值) =&gt; {return "返回处理后的值"}}   // 局部过滤器,只在当前vue文件中生效</li></ul> 
<p>        使用: 变量名 | 过滤器名</p> 
<p>（4）计算属性 computed</p> 
<p>一个变量的值,依赖另外一些数据计算而来的结果</p> 
<p>语法: computed: {<!-- --></p> 
<p>        计算属性名 () {<!-- --></p> 
<p>                return "值"</p> 
<p>        }</p> 
<p>}</p> 
<p>注意: <span style="color:#a2e043;">计算属性也是vue数据变量, 所以不要和data里重名, 用法和data相同,不需要调用,使用的时候和变量一致</span></p> 
<p></p> 
<p>使用this.计算属性名也可以使用该变量</p> 
<p><span style="color:#a2e043;"><strong>计算属性将基于它们的响应依赖关系缓存</strong>。计算属性只会在相关响应式依赖发生改变时重新求值。这就意味着只要计算属性依赖值<strong>（非响应式数据获得的计算属性值将永远不发生改变）</strong>还没有发生改变，多次访问时计算属性会立即返回之前的计算结果，而不必再次执行函数。（当有需求实时的获取值得时候可以采用函数调用的形式得到值）</span></p> 
<p>计算属性的完整写法：</p> 
<p>// 给计算属性赋值触发set方法</p> 
<p>// 使用计算属性的值,触发get方法</p> 
<p>computed: {<!-- --></p> 
<p>        "属性名": {<!-- --></p> 
<p>                set(值) {<!-- --></p> 
<p>                },</p> 
<p>                get() {<!-- --></p> 
<p>                        return "值"</p> 
<p>                }</p> 
<p>        }</p> 
<p>}</p> 
<p>（5）侦听器watch</p> 
<p>可以侦听data/computed属性值的改变</p> 
<p>语法1: </p> 
<p>watch: {<!-- --></p> 
<p>        "被侦听的属性名" (newVal, oldVal) {<!-- --></p> 
<p>        }</p> 
<p>}</p> 
<p>高级语法:</p> 
<p>watch: {<!-- --></p> 
<p>        "要侦听的属性名": {<!-- --></p> 
<p>                immediate: true, // 立即执行        </p> 
<p>                deep: true, // 深度侦听复杂数据类型内变化</p> 
<p>                handler (newVal, oldVal) {}</p> 
<p>        }</p> 
<p>}</p> 
<p>（6）组件的概念和理解</p> 
<p><span style="color:#a2e043;">每一个.vue文件都是一个组件</span></p> 
<p></p> 
<ul><li>组件是可复用的 Vue 实例, 封装标签, 样式和JS代码</li><li>组件化 ：封装的思想，把页面上 `可重用的部分` 封装为 `组件`，从而方便项目的开发 和 维护</li><li>一个页面， 可以拆分成一个个组件，一个组件就是一个整体, 每个组件可以有自己独立的结构 样式 和 行为(html, css和js)</li><li>各自独立，互不影响</li></ul> 
<p>每个组件都是一个独立的个体, 代码里体现为一个独立的.vue文件</p> 
<ul><li>创建组件, 封装要复用的标签, 样式, JS代码</li><li>注册组件(使用前需要引入) 
  <ul><li>全局注册 – main.js中 – 语法如图</li><li><img alt="" height="41" src="https://images2.imgbox.com/5c/f1/IKWP4hlW_o.png" width="411"></li><li>局部注册 – 某.vue文件内 – 语法如图</li><li><img alt="" height="173" src="https://images2.imgbox.com/5a/bc/oGU38bVa_o.png" width="402"></li></ul></li><li>使用组件(组件名当template标签使用,组件对象代表引入时命名的对象)</li></ul> 
<p>（7）组件通信：父子</p> 
<p>父向子传值：在父组件中的template里使用时，通过属性名="值"的形式传给子组件</p> 
<p><img alt="" height="444" src="https://images2.imgbox.com/c3/8a/pIA490u1_o.png" width="774"></p> 
<p>子组件内通过props接受</p> 
<p><img alt="" height="439" src="https://images2.imgbox.com/da/60/E5eV94DH_o.png" width="516"></p> 
<p>props: []  // 简单写法</p> 
<p>props: { 属性名: { type: 类型, default: 默认值 } } // 复杂数据类型的返回值使用函数的形式返回 () =&gt; { return {} }</p> 
<p>子向父传值：</p> 
<p>子组件触发父自定义事件方法</p> 
<p>前置补充, 父-&gt;索引-&gt;子组件(用于区分是哪个子组件)</p> 
<ul><li>父组件内,绑定自定义事件和事件处理函数 
  <ul><li>语法: @自定义事件名="父methods里函数名"</li></ul></li><li>子组件内,恰当的时机,触发父给我绑的自定义事件,导致父methods里事件处理函数执行</li><li>this.$emit(自定义事件名, 参数/传递的值)</li></ul> 
<p>（8）mixins混入</p> 
<p>通过组件内script标签内通过mixins对象混入。混入对象为一个js文件，通过export default 暴露内容，语法格式与vue组件相同</p> 
<p>格式为： mixins: [obj, obj2]</p> 
<p>使用场景：在多个页面中使用同一个变量或方法时，可以定义混入组件，在main.js中引入</p> 
<p>Vue.mixin({<!-- --></p> 
<p>        methods: {<!-- --></p> 
<p>                ...具体方法</p> 
<p>        }</p> 
<p>})</p> 
<p>（9）依赖注入</p> 
<p>通过provide和inject实例对象可以实现父组件给所有子组件传值</p> 
<p>在父组件中声明provide对象，以函数的形式返回一个对象中需要传递的数据，在子组件中使用inject接收（使用方式和props类似）</p> 
<p><img alt="" height="252" src="https://images2.imgbox.com/76/51/mvcCh9Na_o.png" width="289"></p> 
<p>（10）vue生命周期</p> 
<p>百度（vue3.0有变化）</p> 
<p>（11）$refs和$nextTick使用</p> 
<p>通过ref属性获取组件对象</p> 
<p>this.$nextTick(函数体)(一般情况下写的箭头函数,因为箭头函数没有this指向,使其this指向vue实例对象)</p> 
<p>（12）vue动态组件（<span style="color:#a2e043;">vue-router前身</span>）</p> 
<p>多个组件使用同一个挂载点，并动态切换</p> 
<p>方法： 设置挂载点&lt;component&gt;,使用is属性来设置要显示哪个组件</p> 
<p>&lt;component :is="要显示的动态组件名"&gt;&lt;/component&gt;</p> 
<p>（13）组件插槽（需要着重理解）</p> 
<p>（14）vue-router模块</p> 
<p>（15）vuex</p> 
<p>vue用来存储数据的插件</p> 
<p>是一个js文件</p> 
<pre><code>import Vue from 'vue'

import Vuex from 'vuex'

import user from '@/store/modules/user.js'

Vue.use(Vuex)



export default new Vuex.Store({

  namespaced: true,

  state: {

    userData: {},

  },

  actions: {

        // 异步处理state数据

  },

  mutations: {

    setData(state, data) {

      state.userData = data

    },

   getters: {

        // vuex state变量快速访问，类似computed

        },

        modules: {

                // 与vuex语法类似，小的vuex

        }

  }

})</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5551538a5c18269f17a44a95bb7fb1cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Swagger @ApiModelProperty 绑定枚举类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/494389324309bbd1ac2bf37c8018d3a4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PC端Tab栏与页面滚动联动（VUE2.0版本）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>