<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LCD 基本知识 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LCD 基本知识" />
<meta property="og:description" content="1　LCD控制器 LCD控制器的功能是产生显示驱动信号，驱动LCD显示器，不同的控制器可以支持无源阵列显示屏（STN）和有源阵列显示屏（TFT）的显示，包括单色和彩色，单向刷新模式和双向刷新模式等不同显示的需求。用户只需要读写一系列的寄存器，完成配置和显示控制。
1.1　概述
由处理器产生的显示数据先被存放在外部存储器的帧缓冲中，这些数据由LCD DMA控制器按顺序加载到一个先入先出（FIFO）的缓冲队列中。当采用单向刷新模式时，只有一个DMA通道在工作，同时对应一个FIFO缓冲队列。当采用双向刷新模式，两个DMA通道都会工作，同时对应两个FIFO缓冲队列。
帧缓冲中的数据称为帧缓冲数据，它们对应屏幕上一个个像素点的色彩值。帧缓冲数据可以是压缩编码后的色彩值，也可以是原始的色彩值，这要取决与LCD控制器选定的显示模式。在彩色模式中，原始的色彩值是16位的RGB色彩值，其中Red 5位、Green 6位、Blue 5位（因为人眼对绿色比较敏感，所以Green多占用了1位），一个16位的数据描述了屏幕上一个像素点的色彩。压缩编码的色彩值可以用比较少的位描述一定的色彩值，减少了每像素点的色彩数据量可以相应地提高显示的刷新速率，减少数据的传输量。但是压缩编码的色彩值需要由色彩描述板（Palette）解释后才能描述像素点真正的色彩值。
1．色彩描述板
当使用原始色彩值，即16位描述一个像素点时不使用色彩描述板。单色色彩描述板是一个256入口的8位宽的数据结构，相当于UInt8 palette[256]，可以表示256级灰度。彩色色彩描述板是一个256入口的16位宽的数据结构，相当于UInt16 palette[256]，可以表示256色的伪彩。压缩编码后的每像素色彩描述位数决定了可描述色彩的数量：每像素1位可以访问色彩描述板中2种色彩，每像素2位可以访问色彩描述板中4种色彩，每像素4位可以访问色彩描述板中16种色彩，每像素8位可以访问色彩描述板中256种色彩。
2．刷新模式
STN显示屏采用的是被动（Passive）刷新模式，有时为了提高LCD色彩的表现，可以通过使每屏图像的像素刷新多次，使用时间混合色度的方法。这个方法叫做暂时调节能量分配算法（TMED），也被称为瞬时抖动。
TFT显示屏采用的是主动（Active）刷新模式，不采用瞬时抖动的方法。
不同的显示模式最终使用的LCD数据输出引脚数也是不同的，而且双向刷新模式所使用的数据引脚数一定是对应单向刷新模式的一倍，这是因为双向刷新模式是同时刷新屏幕的上半部分和下半部分。
3．控制时钟
（1）像素时钟（Pixel Clock）
对应片上引脚L_PCLK，LCD显示器用来控制显示数据进入行显示位移寄存器（Line Shift Register）的控制时钟信号。一个时钟周期刷新屏幕上几个像素点，频率越高，行分辨率越高。在被动刷新模式中只有当有效的显示数据到来了时钟才开始翻转。在主动刷新模式中时钟是连续翻转的，数据的有效信是靠AC Bias信号来判断的。
（2）行时钟（Line Clock）
对应片上引脚L_LCLK，LCD显示器用来表示屏幕上一行像素刷新完毕的时钟信号。当行时钟信号生时就表示显示器要开始刷新下一行的像素，控制器会把存放在行显示位移寄存器中下一行的显示数据转移到显示屏，并且将行位置计数器加1。在主动刷新模式中，行时钟信号也称为水平同步信号。
（3）帧时钟（Frame Clock）
对应片上引脚L_FCLK，LCD显示器用来表示整个屏幕刷新完毕，又有新的帧等待显示时产生的时钟信号。当信号到来时显示器将行位置计数器重置到屏幕的第一行（最靠近屏幕顶端）。在主动刷新模式中，帧时钟信号也称为垂直同步信号。
4．特性
LCD控制器拥有以下几点特性。
n　显示模式：
Ø　支持单向刷新或双向刷新；
Ø　在被动单色模式中最多可以显示256级灰度（8位压缩编码）；
Ø　在主动彩色模式中最多可以显示65536种色彩（16位瞬时抖动）；
Ø　在主动彩色模式中最多可以显示65536种色彩（16位不采用瞬时抖动）；
Ø　支持被动256色伪彩单向刷新模式；
Ø　支持被动256色伪彩双向刷新模式。
n　最大分辨率可达1024×1024像素，建议最大分辨率640×480像素；
n　支持外部RAM彩色色彩描述板，256入口16位宽数据（能够在每帧开始时自动加载）；
n　压缩编码像素支持1位、2位、4位和8位；
n　可编程的像素时钟，频率范围195kHz～83MHz（100MHz/512至166MHz/2）；
n　具有双DMA通道（一个通道用来传输色彩描述板和单向刷新的数据，另一个通道用来在双向刷新模式中传输下半屏幕刷新的数据）。
1.2　LCD控制器寄存器
LCD控制器有4个控制寄存器，10个DMA寄存器，1个状态寄存器，还有1个RAM色彩描述板。所有的寄存器都必须由32位的地址来访问，并且不应该尝试对未定义的寄存器地址空间进行读写的操作，这会产生不可预料的错误。
1．控制寄存器
设置这些寄存器的对应位可以有以下功能：
n　启动和停止LCD控制器；
n　设置LCD屏幕的高度和宽度；
n　指定使用单向还是双向的屏幕刷新方式；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3db8185214c6dcb41be944effa7d0011/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-08-02T15:07:58+08:00" />
<meta property="article:modified_time" content="2011-08-02T15:07:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LCD 基本知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                      
<div id="blog_text" class="cnt">
  1　LCD控制器 
 <p>　　LCD控制器的功能是产生显示驱动信号，驱动LCD显示器，不同的控制器可以支持无源阵列显示屏（STN）和有源阵列显示屏（TFT）的显示，包括单色和彩色，单向刷新模式和双向刷新模式等不同显示的需求。用户只需要读写一系列的寄存器，完成配置和显示控制。</p> 
 <p>1.1　概述</p> 
 <p>　　由处理器产生的显示数据先被存放在外部存储器的帧缓冲中，这些数据由LCD DMA控制器按顺序加载到一个先入先出（FIFO）的缓冲队列中。当采用单向刷新模式时，只有一个DMA通道在工作，同时对应一个FIFO缓冲队列。当采用双向刷新模式，两个DMA通道都会工作，同时对应两个FIFO缓冲队列。</p> 
 <p>　　帧缓冲中的数据称为帧缓冲数据，它们对应屏幕上一个个像素点的色彩值。帧缓冲数据可以是压缩编码后的色彩值，也可以是原始的色彩值，这要取决与LCD控制器选定的显示模式。在彩色模式中，原始的色彩值是16位的RGB色彩值，其中Red 5位、Green 6位、Blue 5位（因为人眼对绿色比较敏感，所以Green多占用了1位），一个16位的数据描述了屏幕上一个像素点的色彩。压缩编码的色彩值可以用比较少的位描述一定的色彩值，减少了每像素点的色彩数据量可以相应地提高显示的刷新速率，减少数据的传输量。但是压缩编码的色彩值需要由色彩描述板（Palette）解释后才能描述像素点真正的色彩值。</p> 
 <p>　　1．色彩描述板</p> 
 <p>　　当使用原始色彩值，即16位描述一个像素点时不使用色彩描述板。单色色彩描述板是一个256入口的8位宽的数据结构，相当于UInt8 palette[256]，可以表示256级灰度。彩色色彩描述板是一个256入口的16位宽的数据结构，相当于UInt16 palette[256]，可以表示256色的伪彩。压缩编码后的每像素色彩描述位数决定了可描述色彩的数量：每像素1位可以访问色彩描述板中2种色彩，每像素2位可以访问色彩描述板中4种色彩，每像素4位可以访问色彩描述板中16种色彩，每像素8位可以访问色彩描述板中256种色彩。</p> 
 <p>　　2．刷新模式</p> 
 <p>　　STN显示屏采用的是被动（Passive）刷新模式，有时为了提高LCD色彩的表现，可以通过使每屏图像的像素刷新多次，使用时间混合色度的方法。这个方法叫做暂时调节能量分配算法（TMED），也被称为瞬时抖动。</p> 
 <p>　　TFT显示屏采用的是主动（Active）刷新模式，不采用瞬时抖动的方法。</p> 
 <p>　　不同的显示模式最终使用的LCD数据输出引脚数也是不同的，而且双向刷新模式所使用的数据引脚数一定是对应单向刷新模式的一倍，这是因为双向刷新模式是同时刷新屏幕的上半部分和下半部分。</p> 
 <p>　　3．控制时钟</p> 
 <p>　　（1）像素时钟（Pixel Clock）</p> 
 <p>　　对应片上引脚L_PCLK，LCD显示器用来控制显示数据进入行显示位移寄存器（Line Shift Register）的控制时钟信号。一个时钟周期刷新屏幕上几个像素点，频率越高，行分辨率越高。在被动刷新模式中只有当有效的显示数据到来了时钟才开始翻转。在主动刷新模式中时钟是连续翻转的，数据的有效信是靠AC Bias信号来判断的。</p> 
 <p>　　（2）行时钟（Line Clock）</p> 
 <p>　　对应片上引脚L_LCLK，LCD显示器用来表示屏幕上一行像素刷新完毕的时钟信号。当行时钟信号生时就表示显示器要开始刷新下一行的像素，控制器会把存放在行显示位移寄存器中下一行的显示数据转移到显示屏，并且将行位置计数器加1。在主动刷新模式中，行时钟信号也称为水平同步信号。</p> 
 <p>　　（3）帧时钟（Frame Clock）</p> 
 <p>　　对应片上引脚L_FCLK，LCD显示器用来表示整个屏幕刷新完毕，又有新的帧等待显示时产生的时钟信号。当信号到来时显示器将行位置计数器重置到屏幕的第一行（最靠近屏幕顶端）。在主动刷新模式中，帧时钟信号也称为垂直同步信号。</p> 
 <p>　　4．特性</p> 
 <p>　　LCD控制器拥有以下几点特性。</p> 
 <p>　　n　　　　 显示模式：</p> 
 <p>　　Ø　　　 支持单向刷新或双向刷新；</p> 
 <p>　　Ø　　　 在被动单色模式中最多可以显示256级灰度（8位压缩编码）；</p> 
 <p>　　Ø　　　 在主动彩色模式中最多可以显示65536种色彩（16位瞬时抖动）；</p> 
 <p>　　Ø　　　 在主动彩色模式中最多可以显示65536种色彩（16位不采用瞬时抖动）；</p> 
 <p>　　Ø　　　 支持被动256色伪彩单向刷新模式；</p> 
 <p>　　Ø　　　 支持被动256色伪彩双向刷新模式。</p> 
 <p>　　n　　　　 最大分辨率可达1024×1024像素，建议最大分辨率640×480像素；</p> 
 <p>　　n　　　　 支持外部RAM彩色色彩描述板，256入口16位宽数据（能够在每帧开始时自动加载）；</p> 
 <p>　　n　　　　 压缩编码像素支持1位、2位、4位和8位；</p> 
 <p>　　n　　　　 可编程的像素时钟，频率范围195kHz～83MHz（100MHz/512至166MHz/2）；</p> 
 <p>　　n　　　　 具有双DMA通道（一个通道用来传输色彩描述板和单向刷新的数据，另一个通道用来在双向刷新模式中传输下半屏幕刷新的数据）。</p> 
 <p>　　1.2　LCD控制器寄存器</p> 
 <p>　　LCD控制器有4个控制寄存器，10个DMA寄存器，1个状态寄存器，还有1个RAM色彩描述板。所有的寄存器都必须由32位的地址来访问，并且不应该尝试对未定义的寄存器地址空间进行读写的操作，这会产生不可预料的错误。</p> 
 <p>　　1．控制寄存器</p> 
 <p>　　设置这些寄存器的对应位可以有以下功能：</p> 
 <p>　　n　　　　 启动和停止LCD控制器；</p> 
 <p>　　n　　　　 设置LCD屏幕的高度和宽度；</p> 
 <p>　　n　　　　 指定使用单向还是双向的屏幕刷新方式；</p> 
 <p>　　n　　　　 指定使用彩色还是灰度或纯黑白显示方式；</p> 
 <p>　　n　　　　 设置控制引脚的电平有效值；</p> 
 <p>　　n　　　　 设置帧时钟、行时钟、像素时钟和AC Bias引脚信号的频率；</p> 
 <p>　　n　　　　 设置在屏幕显示数据（行数据、帧数据）前后插入的空数据量（协调屏幕尺寸最小数据传输量）；</p> 
 <p>　　n　　　　 可以启用多种中断屏蔽。</p> 
 <p>　　（1）零号控制寄存器（LCCR0）</p> 
 <p>　　LCCR0的使能位（ENB）被置1时，LCD控制器启动。在控制器启动后其他的控制位就不能做任何的更改了，这点在编程时要特别注意，并且LCD控制器的停止也是依靠控制寄存器来控制的。</p> 
 <p>　　n　　　　 LCD输出队列下溢中断屏蔽控制位（OUM）</p> 
 <p>　　OUM=0时，下溢中断被启用，这时当LCSR中的OU状态位被置1时，一个下溢中断请求产生，中断控制器响应，完成相应的出错处理。OUM=1时，下溢中断被屏蔽。</p> 
 <p>　　n　　　　 快速关闭中断屏蔽控制位（QDM）</p> 
 <p>　　QDM=0时快速停止中断被启用，这时当LCSR中的QD状态位被置1时，一个LCD快速关闭中断请求产生，中断控制器响应请求。QDM=1时被屏蔽。快速关闭一般用于休眠模式。</p> 
 <p>　　n　　　　 LCD关闭控制位（DIS）</p> 
 <p>　　DIS=1时，LCD控制器在读取完当前帧的数据后会停止从缓存中读取新的帧数据，在当前帧显示完成后，关闭LCD控制器。</p> 
 <p>　　n　　　　 主动/被动显示模式选择位（PAS）</p> 
 <p>　　这一位是用来控制显示模式，主动还是被动显示模式。PAS=0时，被动模式被选中。PAS=1时，主动模式被选中。</p> 
 <p>　　n　　　　 单向/双向刷新模式选择位（SDS）</p> 
 <p>　　SDS=0时表示单向刷新，SDS=1时表示双向刷新。在主动模式下SDS一定为0。</p> 
 <p>　　Table7-2考虑加入</p> 
 <p>　　n　　　　 彩色/单色模式选择位（CMS）</p> 
 <p>　　CMS=0时，选中了彩色模式，相应的色彩描述板的的色彩数据是16位宽。CMS=1时，选中了单色模式，相应的色彩描述板的色彩数据是8位宽（最多256级灰度）。</p> 
 <p>　　n　　　　 LCD启动控制位（ENB）</p> 
 <p>　　ENB=0时，所有的LCD引脚都被作为通用IO口使用；ENB=1时，LCD控制器启用。</p> 
 <p>　　（2）一号控制寄存器（LCCR1）</p> 
 <p>　　这个寄存器中的4个域的值是用来控制LCD行显示相关时钟信号的时序，它们分别是对应计数器的默认计数值。</p> 
 <p>　　n　　　　 行前置空像素时钟节拍数（BLW）</p> 
 <p>　　表示在开始显示一行像素前所需要等待的空像素时钟节拍数。BLW可以产生的1～256个像素时钟的等待周期，对应BLW值0～255。</p> 
 <p>　　n　　　　 行后置空像素时钟节拍数（ELW）</p> 
 <p>　　和BLW类似，是在一行像素显示结束后需要等待的空像素时钟节拍数。</p> 
 <p>　　n　　　　 水平同步信号脉冲宽度（HSW）</p> 
 <p>　　HSW的值指定了在主动或被动模式下行时钟信号的脉冲宽度。每次行时钟信号有效时，HSW的值被赋给一个6位的计数器，每一个像素时钟到来时计数器减1，当计数器为0时行时钟信号失效。HSW值的范围是0～63，可以表示1～64之间的脉冲宽度。</p> 
 <p>　　n　　　　 行像素数（PPL）</p> 
 <p>　　PPL可以描述0～1023范围的值，它指定了屏幕中一行上像素点的数量（1～1024个像素）。建议最大不要超过640个像素。在不同的像素描述模式下PPL的值也有不同的要求：每像素1位描述时PPL+1必须是32的倍数，每像素2位描述时PPL+1必须是16的倍数，每像素4位描述时PPL+1必须是8的倍数，每像素8位描述时PPL+1必须是4的倍数，每像素16位描述时PPL+1必须是2的倍数。当PPL与实际屏幕的行像素值不能对应时，空像素就会被引入，BLW或ELW就会被使用。</p> 
 <p>　　（3）二号控制寄存器（LCCR2）</p> 
 <p>　　和LCCR1类似，这个寄存器中的4个域的值是用来控制LCD上帧显示相关时钟信号的时序的。</p> 
 <p>　　（4）帧前置空行时钟节拍数（BFW）</p> 
 <p>　　只在主动显示模式下使用，表示在开始显示新的一帧前所需要等待的空行时钟节拍数。BLW可以产生的0～255个行时钟的等待周期，BLW=0时不等待。</p> 
 <p>　　（5）帧后置空行时钟节拍数（EFW）</p> 
 <p>　　只在主动显示模式下使用，和BFW类似，是在一帧像素显示结束后需要等待的空行时钟节拍数。</p> 
 <p>　　（6）垂直同步信号脉冲宽度（VSW）</p> 
 <p>　　VSW的值指定了在主动或被动模式下帧时钟信号的脉冲宽度。主动模式下，每次帧时钟信号有效时，VSW的值被赋给一个6位的计数器，每一个行时钟到来时计数器减1，当计数器为0时，行时帧信号失效。被动模式下，VSW则用来提供额外的空行时钟，当前一帧显示结束，VSW的值被赋给一个6位的计数器，用来计数空时钟信号，当计数器为0时，下一帧才开始（BFW、EFW还是存在）。VSW值的范围是0～63，可以表示1～64之间的脉冲宽度或额外空时钟数。</p> 
 <p>　　（7）屏幕行数（LPP）</p> 
 <p>　　LPP可以描述0～1023范围的值，它指定了屏幕中行的数量（1～1024行）。</p> 
 <p>　　（8）每像素位描述数（BPP）</p> 
 <p>　　描述了一个像素色彩值在内存中所占的位数。在每像素1、2、4、8位的压缩编码模式在，这些像素在被显示前，它们的色彩描述板必须被加载，以得到真正的色彩值。BPP=0b000时，每像素1位描述。BPP=0b001时，每像素2位描述。BPP=0b010时，每像素4位描述。BPP=0b011时，每像素8位描述。BPP=0b100时，每像素16位描述。其他保留用于将来扩展。</p> 
 <p>　　（9）像素时钟边沿有效性选择（PCP）</p> 
 <p>　　PCP=0时，在L_PCLK上升沿有效，采样LCD数据引脚的数据。PCP=1时，在L_PCLK下降沿有效，采样LCDLCD数据引脚的数据。</p> 
 <p>　　（10）水平同步信号电平有效性选择（HSP）</p> 
 <p>　　HSP=0时，L_LCLK高电平有效，HSP=1时，L_LCLK低电平有效。在被动模式下水平同步信号就是行时钟信号。</p> 
 <p>　　（11）垂直同步信号电平有效性选择（VSP）</p> 
 <p>　　VSP=0时，L_FCLK高电平有效，VSP=1时，L_FCLK低电平有效。</p> 
 <p>　　（12）像素时钟分频选择（PCD）</p> 
 <p>　　PCD的值在0～255之间，代表1～256的分频参数（分频时要乘以2）。最后得到的像素时钟的频率在LCLK/2到LCLK/512之间。LCLK频率等于LCD内存控制器的时钟频率，一般在100MHz～166MHz之间。</p> 
 <p>　　2．状态寄存器（LCSR）</p> 
 <p>　　状态寄存器的状态位可以标示：</p> 
 <p>　　n　　　　 FIFO缓冲队列的上溢与下溢错误；</p> 
 <p>　　n　　　　 DMA总线错误；</p> 
 <p>　　n　　　　 DMA控制器何时开始和结束一个帧数据的传输；</p> 
 <p>　　n　　　　 LCD关闭前最后一个帧显示在何时结束。</p> 
 <p>　　（1）帧结束状态位（EOF）</p> 
 <p>　　当DMA控制器从存储器中取得一帧的显示数据，并且数据中的帧描述符中包含表示帧结束的标示位，那么EOF=1，如果LCCR0中的EFM屏蔽位没有被设置，那么将产生一个EOF中断请求。</p> 
 <p>　　（2）LCD快速关闭状态位（QD）</p> 
 <p>　　当QD=1，QDM=0时，会产生一个快速关闭的中断，这个中断会强制停止LCD控制器，并且马上停止LCD的引脚的驱动。快速关闭可用于LCD休眠模式。</p> 
 <p>　　（3）输出FIFO下溢状态位（OU）</p> 
 <p>　　如果输出FIFO为空，LCD的数据引脚还继续尝试从FIFO中获取显示数据时，OU=1。若OUM=0时，这将产生一个输出FIFO下溢中断。</p> 
 <p>　　（4）上屏幕输入FIFO下溢状态位（IUU）</p> 
 <p>　　如果上屏幕的输入FIFO为空，LCD控制器的像素解码器还继续尝试从FIFO中获取压缩编码的数据时，IUU=1。若IUM=0时，这将产生一个输入FIFO下溢中断。</p> 
 <p>　　（5）下屏幕输入FIFO下溢状态位（IUL）</p> 
 <p>　　当选中了双向刷新模式时才使用（SDS=1），如果下屏幕的输入FIFO为空，LCD控制器的像素解码器还继续尝试从FIFO中获取压缩编码的数据时，IUL=1。若IUM=0时，这将产生一个输入FIFO下溢中断。</p> 
 <p>　　（6）总线错误状态位（BER）</p> 
 <p>　　当DMA传输控制器发生了一个系统总线的错误时，BER=1。例如，当DMA控制器试图访问保留的或不存在的存储空间。错误发生后，DMA控制器会停止工作，直到有效的地址空间被加载到FDADRx寄存器。</p> 
 <p>　　（7）帧开始状态位（SOF）</p> 
 <p>　　当DMA控制器获取到新的帧描述符，并且它包含表示帧开始的标示位，那么SOF=1，如果LCCR0中的SFM屏蔽位没有被设置，那么将产生一个SOF中断请求。</p> 
 <p>　　（8）LCD关闭完成状态位（LDD）</p> 
 <p>　　当DIS=1，LCD控制器读取完当前帧的所有数据时，在当前帧的最后一个像素数据被发送到LCD数据引脚后，LCD控制器被关闭，LDD被置1。若LDM=0，还将产生一个关闭完成中断请求。这个状态位是由硬件设置的，但它的清除工作是由软件来完成的。</p> 
 <p>　　（9）其他寄存器</p> 
 <p>　　除了以上介绍几个主要寄存器外还有一些将会用到的寄存器。例如，LCD DMA命令寄存器（LDCMDx），LCD控制器中断ID寄存器（LIIDR），瞬时抖动RGB色彩偏移寄存器（TRGBR），瞬时抖动控制寄存器（TCR）等。</p> 
 <p>　　1.3　LCD控制器的操作</p> 
 <p>　　1．帧缓存与总线带宽</p> 
 <p>　　存放一个显示帧数据所须的缓存大小可以用以下公式来计算：</p> 
 <p>　　FrameBufferSize=（BitPerPixel´Lines´（Pixels + n））/8　（单位是byte）</p> 
 <p>　　其中BitPerPixel表示描述一个像素所需要多少个bit位，例如256级灰度的BitPerPixel=8，64K彩色的BitPerPixel=16。Lines等于显示屏幕的行数。Pixels是显示屏幕中一行上的像素点的个数，n是插入的空像素点的个数（为了显示的控制）。</p> 
 <p>　　在双向刷新模式中，两个DMA管道的帧缓冲大小是一样的，所以在计算这个模式下一个管道中的帧缓冲时，Lines是屏幕大小的一半。</p> 
 <p>　　为了满足显示数据的传输，LCD控制器的数据传输总线带宽可以用以下公式计算得到：</p> 
 <p>　　n　　　　 单向</p> 
 <p>　　BusBandwidth=（FrameBufferSize+PaletteSize）´RefreshRate</p> 
 <p>　　n　　　　 双向</p> 
 <p>　　BusBandwidth=（FrameBufferSize*2+PaletteSize）´RefreshRate</p> 
 <p>　　其中PaletteSize是色彩描述板的大小，单色色彩描述板的大小是256´8bit=256byte，彩色色彩描述板是256´16=512byte。RefreshRate是屏幕的刷新率。</p> 
 <p>　　在双向模式中，负责上半屏幕的DMA管道负责传输Palette和上半屏幕的显示数据，而负责下半屏幕的DMA管道只下半屏幕的显示数据，所以双向模式的公式中PaleteSize没有乘以2。</p> 
 <p>　　2．被动模式的时序</p> 
 <p>　　初动模式的时序如图4-1至图4-3所示。</p> 
 <p></p> 
 <p> </p> 
 <table class="FCK__ShowTableBorders"><tbody><tr><td width="211"> <p></p> <p>　　ENB – LCD使能信号</p> <p></p> </td><td width="238"> <p></p> <p>　　HSP – 水平同步极性设置</p> <p></p> </td></tr><tr><td width="211"> <p></p> <p>　　0 – LCD禁止</p> <p></p> </td><td width="238"> <p></p> <p>　　0 – 行时钟高有效，低无效</p> <p></p> </td></tr><tr><td width="211"> <p></p> <p>　　1 – LCD使能</p> <p></p> </td><td width="238"> <p></p> <p>　　1 – 行时钟低有效，高无效</p> <p></p> </td></tr><tr><td width="211"> <p></p> <p>　　VSP – 垂直同步极性设置</p> <p></p> </td><td width="238"> <p></p> <p>　　PCP – 像素时钟极性设置</p> <p></p> </td></tr><tr><td width="211"> <p></p> <p>　　0 – 帧时钟高有效，低无效</p> <p></p> </td><td width="238"> <p></p> <p>　　0 – 在时钟的上升沿采样像素数据</p> <p></p> </td></tr><tr><td width="211"> <p></p> <p>　　1 – 帧时钟低有效，高无效</p> <p></p> </td><td width="238"> <p></p> <p>　　1 – 在时钟的下降沿采样像素数据</p> <p></p> </td></tr><tr><td width="449" colspan="2"> <p></p> <p>　　当PCP=0时，L_PCLK的波形是反向的，但时序是相同的。</p> <p></p> </td></tr><tr><td width="449" colspan="2"> <p></p> <p>　　VSW = 垂直同步信号脉冲宽度 – 1</p> <p></p> </td></tr><tr><td width="449" colspan="2"> <p></p> <p>　　HSW = 水平同步信号（行时钟）脉冲宽度 – 1</p> <p></p> </td></tr><tr><td width="449" colspan="2"> <p></p> <p>　　BLW = 开始行像素时钟等待个数 – 1</p> <p></p> </td></tr><tr><td width="449" colspan="2"> <p></p> <p>　　ELW = 结束行像素时钟等待个数 – 1</p> <p></p> </td></tr></tbody></table> 
 <p></p> 
 <p>　　图4-1　被动模式帧启动时序</p> 
 <p></p> 
 <p> </p> 
 <table class="FCK__ShowTableBorders"><tbody><tr><td width="235"> <p></p> <p>　　ENB – LCD使能信号</p> <p></p> </td><td width="238"> <p></p> <p>　　HSP – 水平同步极性设置</p> <p></p> </td></tr><tr><td width="235"> <p></p> <p>　　0 – LCD禁止</p> <p></p> </td><td width="238"> <p></p> <p>　　0 – 行时钟高有效，低无效</p> <p></p> </td></tr><tr><td width="235"> <p></p> <p>　　1 – LCD使能</p> <p></p> </td><td width="238"> <p></p> <p>　　1 – 行时钟低有效，高无效</p> <p></p> </td></tr><tr><td width="235"> <p></p> <p></p> </td><td width="238"> <p></p> <p></p> </td></tr><tr><td width="235"> <p></p> <p>　　VSP – 垂直同步极性设置</p> <p></p> </td><td width="238"> <p></p> <p>　　PCP – 像素时钟极性设置</p> <p></p> </td></tr><tr><td width="235"> <p></p> <p>　　0 – 帧时钟高有效，低无效</p> <p></p> </td><td width="238"> <p></p> <p>　　0 – 在时钟的上升沿采样像素数据</p> <p></p> </td></tr><tr><td width="235"> <p></p> <p>　　1 – 帧时钟低有效，高无效</p> <p></p> </td><td width="238"> <p></p> <p>　　1 – 在时钟的下降沿采样像素数据</p> <p></p> </td></tr><tr><td width="235"> <p></p> <p></p> </td><td width="238"> <p></p> <p></p> </td></tr><tr><td width="473" colspan="2"> <p></p> <p>　　当PCP=0时，L_PCLK的波形是反向的，但时序是相同的。</p> <p></p> </td></tr><tr><td width="235"> <p></p> <p></p> </td><td width="238"> <p></p> <p></p> </td></tr><tr><td width="473" colspan="2"> <p></p> <p>　　VSW = 垂直同步信号脉冲宽度 – 1</p> <p></p> </td></tr><tr><td width="473" colspan="2"> <p></p> <p>　　HSW = 水平同步信号（行时钟）脉冲宽度 – 1</p> <p></p> </td></tr><tr><td width="473" colspan="2"> <p></p> <p>　　BLW = 开始行像素时钟等待个数 – 1</p> <p></p> </td></tr><tr><td width="473" colspan="2"> <p></p> <p>　　ELW = 结束行像素时钟等待个数 – 1</p> <p></p> </td></tr><tr><td width="473" colspan="2"> <p></p> <p>　　PPL = 每行像素 – 1</p> <p></p> </td></tr><tr><td width="473" colspan="2"> <p></p> <p>　　LPP = 每屏幕行数 – 1</p> <p></p> </td></tr></tbody></table> 
 <p></p> 
 <p>　　图4-2 　被动模式帧结束时序</p> 
 <p></p> 
 <p> </p> 
 <table class="FCK__ShowTableBorders"><tbody><tr><td width="509"> <p></p> <p>　　PCP – 像素时钟极性设置</p> <p></p> </td></tr><tr><td width="509"> <p></p> <p>　　0 – 在时钟的上升沿采样像素数据</p> <p></p> </td></tr><tr><td width="509"> <p></p> <p>　　1 – 在时钟的下降沿采样像素数据</p> <p></p> </td></tr><tr><td width="509"> <p></p> <p>　　当PCP=0时，L_PCLK的波形是反向的，但时序是相同的。</p> <p></p> </td></tr></tbody></table> 
 <p></p> 
 <p>　　图4-3　被动模式像素时钟和数据引脚时序</p> 
 <p>　　3．主动模式的时序</p> 
 <p>　　主动模式的时序如图4-4与图4-5所示。</p> 
 <p>　　4．LCD启动</p> 
 <p>　　将对应的通用I/O引脚配置给LCD控制器，设置了正确的色彩描述板、帧描述符的内存地址和LCCR0以外的一些必要寄存器的设置后，置位LCCR0的ENB控制位后LCD控制器就会启动了。</p> 
 <p></p> 
 <p> </p> 
 <table class="FCK__ShowTableBorders"><tbody><tr><td width="195"> <p></p> <p>　　ENB – LCD使能信号</p> <p></p> </td><td width="238"> <p></p> <p>　　HSP – 水平同步极性设置</p> <p></p> </td></tr><tr><td width="195"> <p></p> <p>　　0 – LCD禁止</p> <p></p> </td><td width="238"> <p></p> <p>　　0 – 行时钟高有效，低无效</p> <p></p> </td></tr><tr><td width="195"> <p></p> <p>　　1 – LCD使能</p> <p></p> </td><td width="238"> <p></p> <p>　　1 – 行时钟低有效，高无效</p> <p></p> </td></tr><tr><td width="195"> <p></p> <p></p> </td><td width="238"> <p></p> <p></p> </td></tr><tr><td width="195"> <p></p> <p>　　VSP – 垂直同步极性设置</p> <p></p> </td><td width="238"> <p></p> <p>　　PCP – 像素时钟极性设置</p> <p></p> </td></tr><tr><td width="195"> <p></p> <p>　　0 – 帧时钟高有效，低无效</p> <p></p> </td><td width="238"> <p></p> <p>　　0 – 在时钟的上升沿采样像素数据</p> <p></p> </td></tr><tr><td width="195"> <p></p> <p>　　1 – 帧时钟低有效，高无效</p> <p></p> </td><td width="238"> <p></p> <p>　　1 – 在时钟的下降沿采样像素数据</p> <p></p> </td></tr><tr><td width="195"> <p></p> <p></p> </td><td width="238"> <p></p> <p></p> </td></tr><tr><td width="434" colspan="2"> <p></p> <p>　　当PCP=0时，L_PCLK的波形是反向的，但时序是相同的。</p> <p></p> </td></tr><tr><td width="195"> <p></p> <p></p> </td><td width="238"> <p></p> <p></p> </td></tr><tr><td width="434" colspan="2"> <p></p> <p>　　VSW = 垂直同步信号脉冲宽度 – 1</p> <p></p> </td></tr><tr><td width="434" colspan="2"> <p></p> <p>　　HSW = 水平同步信号（行时钟）脉冲宽度 – 1</p> <p></p> </td></tr><tr><td width="434" colspan="2"> <p></p> <p>　　BFW = 开始帧水平同步时钟等待个数</p> <p></p> </td></tr><tr><td width="434" colspan="2"> <p></p> <p>　　BLW = 开始行像素时钟等待个数 – 1</p> <p></p> </td></tr><tr><td width="434" colspan="2"> <p></p> <p>　　ELW = 结束行像素时钟等待个数 – 1</p> <p></p> </td></tr><tr><td width="434" colspan="2"> <p></p> <p>　　PPL = 每行像素 – 1</p> <p></p> </td></tr></tbody></table> 
 <p></p> 
 <p>　　图4-4　主动模式的时序</p> 
 <p></p> 
 <p> </p> 
 <table class="FCK__ShowTableBorders"><tbody><tr><td width="439"> <p></p> <p>　　PCP – 像素时钟极性设置</p> <p></p> </td></tr><tr><td width="439"> <p></p> <p>　　0 – 在时钟的上升沿采样像素数据</p> <p></p> </td></tr><tr><td width="439"> <p></p> <p>　　1 – 在时钟的下降沿采样像素数据</p> <p></p> </td></tr><tr><td width="439"> <p></p> <p>　　当PCP=0时，L_PCLK的波形是反向的，但时序是相同的。</p> <p></p> </td></tr></tbody></table> 
 <p></p> 
 <p>　　图4-5　主动模式像数时钟和数据引脚时序</p> 
 <p>　　伪代码如下：</p> 
 <p>　　#define LCCR0_ADDRESS 0x44000000　　 // LCCR0的地址</p> 
 <p>　　#define LCCR0 （ * （ （volatile unsigned int * ） LCCR0_ADDRESS ） ）</p> 
 <p>　　#define LCD_ENB 0x00000001　　　　 // ENB在LCCR0中的位置</p> 
 <p>　　LCCR0 = LCCR0 | LCD_ENB;　　　　　　　　　　 // 置位ENB</p> 
 <p>　　5．LCD停止</p> 
 <p>　　（1）正常停止</p> 
 <p>　　一般建议使用这个方式停止LCD控制器。这个操作是由设置LCCR0的DIS控制位来完成的。并且在LCD控制器加载了最后要显示的帧数据后，LCSR的LDD状态位会被硬件自动置位，同时LCCR0中的ENB位也会被硬件清零。</p> 
 <p>　　伪代码如下：</p> 
 <p>　　#define LCCR0_ADDRESS 0x44000000　　 // LCCR0的地址</p> 
 <p>　　#define LCCR0 （ * （ （volatile unsigned int * ） LCCR0_ADDRESS ） ）</p> 
 <p>　　#define LCSR_ADDRESS 0x44000038 　　　 //LCSR的地址</p> 
 <p>　　#define LCSR （ * （ （volatile unsigned int * ） LCSR_ADDRESS ） ）</p> 
 <p>　　#define LCD_DIS 0x00000400　　　　　　　　 //DIS在LCCR0中的位置</p> 
 <p>　　#define LCD_LDD 0x00000001　　　　　　　　 //LDD在LCSR中的位置</p> 
 <p>　　LCCR0 = LCCR0 | LCD_DIS;　　　　　　　　　 　　　 //LCCR0中的LCD_DIS位置位</p> 
 <p>　　while（!（LCSR &amp; LCD_LDD））;　　　　　　 　　　 //等待硬件置位LDD</p> 
 <p>　　LCSR = LCSR &amp; （~LCD_LDD）;　　　　　　　 //软件清除LCD_LDD位，以便下次使用</p> 
 <p>　　（2）快速停止</p> 
 <p>　　直接清除LCCR0的ENB控制位可以实现快速停止的操作。清除了ENB位后LCSR的QD状态位会被置位，产生一个中断，中断响应后LCD控制器会马上停止加载了一切的帧数据，停止LCD控制器对LCD引脚的驱动。在电池电量不足时，CPU为了保存重要的数据，快速停止模式被采用。</p> 
 <p>　　伪代码如下：</p> 
 <p>　　#define LCCR0_ADDRESS 0x44000000 　　 // LCCR0的地址</p> 
 <p>　　#define LCCR0 （ * （ （volatile unsigned int * ） LCCR0_ADDRESS ） ）</p> 
 <p>　　#define LCD_ENB 0x00000001　　　　 // ENB在LCCR0中的位置</p> 
 <p>　　LCCR0 = LCCR0 &amp; （~LCD_ENB）;　　　　　　 //清除ENB位</p> 
</div> 
<br> 原文链接： 
<a href="http://hi.baidu.com/lucky900apple/blog/item/da21ee0dee01a52a6b60fbd7.html" rel="nofollow">http://hi.baidu.com/lucky900apple/blog/item/da21ee0dee01a52a6b60fbd7.html</a>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c8ea72d33b1a4188a98a44d97c61201a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java GC and PhantomReference</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a998c5da7a538a19c1ec18c01ea290b2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">菩提本无树，明镜亦非台</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>