<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RPC和HTTP的理解以及不同之处 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RPC和HTTP的理解以及不同之处" />
<meta property="og:description" content="RPC协议：远程过程调用协议（Remote Procedure Call Protocol)，是一种计算机通讯协议。
如何理解远程过程调用？ 假设有两台服务器A和B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在一个内存空间，所以不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。
简要的步骤 解决通讯问题。主要是客户端和服务器建立TCP连接，远程调用所有交换的数据都在这个连接里面进行交换，连接可以是按需连接，数据交换完毕之后就关闭连接；也可以是长连接，多个远程调用都共享同一个连接。解决寻址问题。服务器A想要调用服务器B的应用，那么A应该告知RPC框架B服务器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。比如基于Web服务协议栈的RPC，就需要提供一个endpoint URI，或者是从UDDI服务上进行查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用。 通常，经过以上五个步骤之后，一次完整的RPC调用算是完成了，另外可能因为网络抖动等原因需要重试等。
为什么会使用RPC？ 主要就是因为在几个进程内（应用分布在不同的机器上），无法共用内存空间，或者在一台机器内通过本地调用无法完成相关的需求，比如不同的系统之间的通讯，甚至不同组织之间的通讯。此外由于机器的横向扩展，需要在多台机器组成的集群上部署应用等等。
RPC支持的协议？ 最早的CORBA、Java RMI， WebService方式的RPC风格， Hessian, Thrift甚至Rest API。
RPC实现的基础？ 1、需要有非常高效的网络通信，比如一般选择Netty作为网络通信框架。
2、需要有比较高效的序列化框架，比如谷歌的Protobuf序列化框架。
3、可靠的寻址方式（主要是提供服务的发现），比如可以使用Zookeeper来注册服务等等。
4、如果是带会话（状态）的RPC调用，还需要有会话和状态保持的功能。
HTTP协议：HTTP(Hyper Text Transfer Protocol)，超文本传输协议的缩写。是用于从WWW服务器传输超文本到本地浏览器的传输协议。HTTP是一个应用层协议,由请求和响应构成，是一个标准的个客户端和服务器模型。
如何理解HTTP协议？ 虽然HTTP是超文本传输协议，但它跟传输没有半毛钱关系，它就是一种协议，和租房合约一样，是一种双方约定的规则。有一定的格式，比如合同，要是甲乙双方、有要具体内容、时间等等。
HTTP组成？ HTTP由起始行（start line）、请求头（header）、消息正文组成（entity）。
1、起始行：描述请求方式和相应的基本信息。由请求方式、请求资源、使用HTTP的版本号。
例如：GET index.html HTTP/1.1
2、请求头：以key-value的形式说明报文内容。
3、消息正文：具体需要传输的数据，可以是文本、图片视频等二级制数据。
HTTP的基本结构如下图：
其中HTTP完整的头部格式如下：
在浏览器输入网址会发生什么呢？ 下面以访问www.baidu.com为例
1、浏览器对www.baidu.com进行DNS域名解析，解析得到ip地址。
2、通过ip地址找到对应的服务器，发起TCP三次握手。
3、基于TCP连接，发送http请求。
4、服务器响应http请求，返回html代码。
5、浏览器解析html的代码，并且请求静态资源（如：js、css、img等）。
6、浏览器将渲染的页面呈现给用户。
RPC和HTTP的不同？ 传输协议：
RPC：可以基于TCP也可以基于HTTP。
HTTP：基于HTTP。
传输效率：
RPC：使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率。
HTTP：如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理。
性能消耗，主要在于序列化和反序列化的耗时：
RPC：可以基于thrift实现高效的二进制传输。
HTTP：大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能。
负载均衡：
RPC：基本都自带了负载均衡策略。
HTTP：需要配置Nginx，HAProxy来实现。
服务治理（下游服务新增，重启，下线时如何不影响上游调用者）：
RPC：能做到自动通知，不影响上游。
HTTP：需要事先通知，修改Nginx/HAProxy配置。
总结：
RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。
参考文章：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/74e1aa8b537c3699c36935460e988467/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-01-02T17:50:37+08:00" />
<meta property="article:modified_time" content="2020-01-02T17:50:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RPC和HTTP的理解以及不同之处</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><font size="2">RPC协议：远程过程调用协议（Remote Procedure Call Protocol)，是一种计算机通讯协议。</font></p> 
<h6><a id="_1"></a>如何理解远程过程调用？</h6> 
<p><font size="2">假设有两台服务器A和B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在一个内存空间，所以不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</font></p> 
<h6><a id="_4"></a>简要的步骤</h6> 
<ol><li><font size="2">解决通讯问题。主要是客户端和服务器建立TCP连接，远程调用所有交换的数据都在这个连接里面进行交换，连接可以是按需连接，数据交换完毕之后就关闭连接；也可以是长连接，多个远程调用都共享同一个连接。</font></li><li><font size="2">解决寻址问题。服务器A想要调用服务器B的应用，那么A应该告知RPC框架B服务器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。比如基于Web服务协议栈的RPC，就需要提供一个endpoint URI，或者是从UDDI服务上进行查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。</font></li><li><font size="2">当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。</font></li><li><font size="2">B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。</font></li><li><font size="2">返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用。</font></li></ol> 
<blockquote> 
 <p>通常，经过以上五个步骤之后，一次完整的RPC调用算是完成了，另外可能因为网络抖动等原因需要重试等。</p> 
</blockquote> 
<h6><a id="RPC_14"></a>为什么会使用RPC？</h6> 
<p><font size="2">主要就是因为在几个进程内（应用分布在不同的机器上），无法共用内存空间，或者在一台机器内通过本地调用无法完成相关的需求，比如不同的系统之间的通讯，甚至不同组织之间的通讯。此外由于机器的横向扩展，需要在多台机器组成的集群上部署应用等等。</font></p> 
<h6><a id="RPC_17"></a>RPC支持的协议？</h6> 
<p><font size="2">最早的CORBA、Java RMI， WebService方式的RPC风格， Hessian, Thrift甚至Rest API。</font></p> 
<h6><a id="RPC_20"></a>RPC实现的基础？</h6> 
<p><font size="2">1、需要有非常高效的网络通信，比如一般选择Netty作为网络通信框架。<br> 2、需要有比较高效的序列化框架，比如谷歌的Protobuf序列化框架。<br> 3、可靠的寻址方式（主要是提供服务的发现），比如可以使用Zookeeper来注册服务等等。<br> 4、如果是带会话（状态）的RPC调用，还需要有会话和状态保持的功能。</font></p> 
<hr> 
<p><font size="2">HTTP协议：HTTP(Hyper Text Transfer Protocol)，超文本传输协议的缩写。是用于从WWW服务器传输超文本到本地浏览器的传输协议。HTTP是一个应用层协议,由请求和响应构成，是一个标准的个客户端和服务器模型。</font></p> 
<h6><a id="HTTP_28"></a>如何理解HTTP协议？</h6> 
<p><font size="2">虽然HTTP是超文本传输协议，但它跟传输没有半毛钱关系，它就是一种协议，和租房合约一样，是一种双方约定的规则。有一定的格式，比如合同，要是甲乙双方、有要具体内容、时间等等。</font></p> 
<h6><a id="HTTP_31"></a>HTTP组成？</h6> 
<p><font size="2">HTTP由起始行（start line）、请求头（header）、消息正文组成（entity）。<br> 1、起始行：描述请求方式和相应的基本信息。由请求方式、请求资源、使用HTTP的版本号。</font></p> 
<blockquote> 
 <p>例如：GET index.html HTTP/1.1</p> 
</blockquote> 
<p><font size="2">2、请求头：以key-value的形式说明报文内容。<br> 3、消息正文：具体需要传输的数据，可以是文本、图片视频等二级制数据。</font></p> 
<p><font size="2">HTTP的基本结构如下图：<br> <img src="https://images2.imgbox.com/db/59/iji2Tr5v_o.png" alt=""><br> <font size="2">其中HTTP完整的头部格式如下：<br> <img src="https://images2.imgbox.com/b1/57/kjvpA2dP_o.png" alt="完整的请求头"><br> <img src="https://images2.imgbox.com/d7/ac/HR59ffKZ_o.png" alt="完整的响应头"></font></font></p> 
<h6><a id="_46"></a>在浏览器输入网址会发生什么呢？</h6> 
<p><font size="2">下面以访问www.baidu.com为例<br> 1、浏览器对www.baidu.com进行DNS域名解析，解析得到ip地址。<br> 2、通过ip地址找到对应的服务器，发起TCP三次握手。<br> 3、基于TCP连接，发送http请求。<br> 4、服务器响应http请求，返回html代码。<br> 5、浏览器解析html的代码，并且请求静态资源（如：js、css、img等）。<br> 6、浏览器将渲染的页面呈现给用户。</font></p> 
<hr> 
<h6><a id="RPCHTTP_55"></a>RPC和HTTP的不同？</h6> 
<ol><li> <p><font size="2">传输协议：<br> RPC：可以基于TCP也可以基于HTTP。<br> HTTP：基于HTTP。</font></p> </li><li> <p><font size="2">传输效率：<br> RPC：使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率。<br> HTTP：如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理。</font></p> </li><li> <p><font size="2">性能消耗，主要在于序列化和反序列化的耗时：<br> RPC：可以基于thrift实现高效的二进制传输。<br> HTTP：大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能。</font></p> </li><li> <p><font size="2">负载均衡：<br> RPC：基本都自带了负载均衡策略。<br> HTTP：需要配置Nginx，HAProxy来实现。</font></p> </li><li> <p><font size="2">服务治理（下游服务新增，重启，下线时如何不影响上游调用者）：<br> RPC：能做到自动通知，不影响上游。<br> HTTP：需要事先通知，修改Nginx/HAProxy配置。</font></p> </li></ol> 
<p><font size="2">总结：<br>   RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</font></p> 
<p><font size="2"><strong>参考文章：</strong><br> <a href="https://www.jianshu.com/p/b61695e6b473" rel="nofollow">https://www.jianshu.com/p/b61695e6b473</a> HTTP和RPC的优缺点<br> <a href="https://www.jianshu.com/p/78f72ccf0377" rel="nofollow">https://www.jianshu.com/p/78f72ccf0377</a> RPC框架实现原理</font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d724197b504a11ae671ff805f119475/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nuget连接失败的问题,发生错误，积极拒绝</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8bd2264891c925673f17b0c8b7a95370/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">802.11标准deauth报文的reason code中文版</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>