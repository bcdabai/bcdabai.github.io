<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32Cubemx：利用定时器实现定时功能 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32Cubemx：利用定时器实现定时功能" />
<meta property="og:description" content="文章目录 细节处理——STM32 hal库编程开启定时器中断会立即进入中断的问题一.实现功能说明二.STM32Cubemx配置过程2.1配置时钟树2.2参数设计（自动重装载值、分频系数、计数方式等）2.2.1分频系数和计数周期2.2.2计数模式2.2.3是否启用预自动重装载 三.中断服务函数编写（重写回调函数）3.1HAL库的中断服务程序调用逻辑3.2如何定位到回调函数？ 四.开启定时器中断 细节处理——STM32 hal库编程开启定时器中断会立即进入中断的问题 通过HAL库实现定时器定时中断需要在开启中断前清除中断标志位，否则一开启定时器中断就会进入一次中断。要解决这个问题很简单，就是调用函数__HAL_TIM_CLEAR_IT(&amp;htim6, TIM_IT_UPDATE);完成中断标志位的清除。这个细节大家根据需要看是否要处理掉。
一.实现功能说明 为了实现LED每隔0.5s进行一次翻转，且不阻塞主程序。
二.STM32Cubemx配置过程 2.1配置时钟树 STM32所有非内核外设都有时钟驱动，所以在配置外设的时候都需要先配置时钟树。
我使用的是STM32F407ZGT6，时钟树配置如下图所示：
2.2参数设计（自动重装载值、分频系数、计数方式等） 配置好时钟树后我们就需要根据时钟总线频率(APB1=84Nhz)设计参数。
这里有个问题就是定时器TIM6挂载在哪个时钟总线上？对于具体外设挂载在哪个时钟总线上我们可以打开对应芯片的数据手册。例如我用的是STM32F407ZGT6打开数据手册我们可以看到一个具体的系统框图(截取一部分)。
通过这张图，我们可以看到TIM6和TIM7都是挂载到APB1上，再结合上面我们配置时钟树是APB1=84Mhz，所以我们可以知道定时器TIM6时钟输入频率为84Mhz。
在知道定时器输入频率后，我们就正式进入参数设计阶段。到这里我们先看一下Cube中有哪些参数需要我们设计：
可以看到一共有四个参数需要我们去配置：
Prescaler：预分频，参数范围0-65535
Counter Mode：计数模式，TIM6只有向上计数模式（UP）
Counter Period：计数周期，参数范围0-65535
auto-reload preload：是否启用预先自动重装载，建议选择Enable
2.2.1分频系数和计数周期 本次实利用定时器实现每隔一段时间去完成某一件事，这段时间为：
T o u t = ( ( a r r &#43; 1 ) ∗ ( p s c &#43; 1 ) ) / T c l k Tout=((arr&#43;1)*(psc&#43;1))/Tclk Tout=((arr&#43;1)∗(psc&#43;1))/Tclk
arr为计数周期（999）
psc为分频系数（41999）
Tclk为接入定时器的时钟总线（Tclk=APB1=84Mhz=84000000）
Tout表示每个多长时间触发一次定时中断（0.5s）
把上图中我设计的参数带入计算可以得到：
T o u t = ( 999 &#43; 1 ) ∗ ( 41999 &#43; 1 ) / 84000000 = 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/162bd45dc222942e0b161ff1104176ab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-03T17:24:50+08:00" />
<meta property="article:modified_time" content="2023-12-03T17:24:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32Cubemx：利用定时器实现定时功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#STM32_hal_1" rel="nofollow">细节处理——STM32 hal库编程开启定时器中断会立即进入中断的问题</a></li><li><a href="#_3" rel="nofollow">一.实现功能说明</a></li><li><a href="#STM32Cubemx_6" rel="nofollow">二.STM32Cubemx配置过程</a></li><li><ul><li><a href="#21_7" rel="nofollow">2.1配置时钟树</a></li><li><a href="#22_13" rel="nofollow">2.2参数设计（自动重装载值、分频系数、计数方式等）</a></li><li><ul><li><ul><li><a href="#221_28" rel="nofollow">2.2.1分频系数和计数周期</a></li><li><a href="#222_44" rel="nofollow">2.2.2计数模式</a></li><li><a href="#223_50" rel="nofollow">2.2.3是否启用预自动重装载</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_52" rel="nofollow">三.中断服务函数编写（重写回调函数）</a></li><li><ul><li><a href="#31HAL_53" rel="nofollow">3.1HAL库的中断服务程序调用逻辑</a></li><li><a href="#32_57" rel="nofollow">3.2如何定位到回调函数？</a></li></ul> 
  </li><li><a href="#_63" rel="nofollow">四.开启定时器中断</a></li></ul> 
</div> 
<p></p> 
<h2><a id="STM32_hal_1"></a>细节处理——STM32 hal库编程开启定时器中断会立即进入中断的问题</h2> 
<blockquote> 
 <p>通过HAL库实现定时器定时中断需要在<code>开启中断前清除中断标志位</code>，否则一开启定时器中断就会进入一次中断。要解决这个问题很简单，就是调用函数<code>__HAL_TIM_CLEAR_IT(&amp;htim6, TIM_IT_UPDATE);</code>完成中断标志位的清除。这个细节大家根据需要看是否要处理掉。</p> 
</blockquote> 
<h2><a id="_3"></a>一.实现功能说明</h2> 
<blockquote> 
 <p>为了实现LED每隔0.5s进行一次翻转，且不阻塞主程序。</p> 
</blockquote> 
<h2><a id="STM32Cubemx_6"></a>二.STM32Cubemx配置过程</h2> 
<h3><a id="21_7"></a>2.1配置时钟树</h3> 
<blockquote> 
 <p>STM32所有<code>非内核外设</code>都有时钟驱动，所以在配置外设的时候都需要先配置时钟树。</p> 
</blockquote> 
<p>我使用的是<strong>STM32F407ZGT6</strong>，时钟树配置如下图所示：<br> <img src="https://images2.imgbox.com/6b/84/ekzK79JJ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22_13"></a>2.2参数设计（自动重装载值、分频系数、计数方式等）</h3> 
<p>配置好时钟树后我们就需要根据<strong>时钟总线频率</strong><code>(APB1=84Nhz)</code>设计参数。</p> 
<blockquote> 
 <p>这里有个问题就是定时器TIM6挂载在哪个时钟总线上？对于具体外设挂载在哪个时钟总线上我们可以打开对应芯片的<code>数据手册</code>。例如我用的是STM32F407ZGT6打开数据手册我们可以看到一个具体的系统框图(截取一部分)。<br> <img src="https://images2.imgbox.com/e0/9e/tKTrNETZ_o.png" alt="在这里插入图片描述"><br> 通过这张图，我们可以看到TIM6和TIM7都是挂载到APB1上，再结合上面我们配置时钟树是APB1=84Mhz，所以我们可以知道定时器TIM6时钟输入频率为84Mhz。</p> 
</blockquote> 
<p>在知道定时器输入频率后，我们就正式进入参数设计阶段。到这里我们先看一下Cube中有哪些参数需要我们设计：<br> <img src="https://images2.imgbox.com/57/2e/u5pKD2PM_o.png" alt="在这里插入图片描述"><br> 可以看到一共有四个参数需要我们去配置：</p> 
<blockquote> 
 <p>Prescaler：预分频，参数范围0-65535<br> Counter Mode：计数模式，TIM6只有向上计数模式（UP）<br> Counter Period：计数周期，参数范围0-65535<br> auto-reload preload：是否启用<code>预先</code>自动重装载，建议选择Enable</p> 
</blockquote> 
<h5><a id="221_28"></a>2.2.1分频系数和计数周期</h5> 
<p>本次实利用定时器实现每隔一段时间去完成某一件事，这段时间为：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          o 
         
        
          u 
         
        
          t 
         
        
          = 
         
        
          ( 
         
        
          ( 
         
        
          a 
         
        
          r 
         
        
          r 
         
        
          + 
         
        
          1 
         
        
          ) 
         
        
          ∗ 
         
        
          ( 
         
        
          p 
         
        
          s 
         
        
          c 
         
        
          + 
         
        
          1 
         
        
          ) 
         
        
          ) 
         
        
          / 
         
        
          T 
         
        
          c 
         
        
          l 
         
        
          k 
         
        
       
         Tout=((arr+1)*(psc+1))/Tclk 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">((</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0278em;">rr</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">sc</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">))</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span></span></p> 
<blockquote> 
 <p>arr为计数周期（999）<br> psc为分频系数（41999）<br> Tclk为接入定时器的时钟总线（Tclk=APB1=84Mhz=84000000）<br> Tout表示每个多长时间触发一次定时中断（0.5s）</p> 
</blockquote> 
<p>把上图中我设计的参数带入计算可以得到：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          o 
         
        
          u 
         
        
          t 
         
        
          = 
         
        
          ( 
         
        
          999 
         
        
          + 
         
        
          1 
         
        
          ) 
         
        
          ∗ 
         
        
          ( 
         
        
          41999 
         
        
          + 
         
        
          1 
         
        
          ) 
         
        
          / 
         
        
          84000000 
         
        
          = 
         
        
          0.5 
         
        
          s 
         
        
       
         Tout=(999+1)*(41999+1)/84000000=0.5s 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">999</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">41999</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/84000000</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0.5</span><span class="mord mathnormal">s</span></span></span></span></span></span></p> 
<h5><a id="222_44"></a>2.2.2计数模式</h5> 
<blockquote> 
 <p>对于不同的计数模式，我看了中文参考手册，发现TIM6只有向上计数模式(UP)，下面就是各个定时器计数模式截图：<br> <img src="https://images2.imgbox.com/45/df/mWpmgI98_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/01/40/9QTokCuD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2c/0e/HjiL9bek_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4f/f0/L7jmoFq0_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h5><a id="223_50"></a>2.2.3是否启用预自动重装载</h5> 
<p>推荐启用Enable，这个问题我单独写一篇博客解释为什么<a href="https://editor.csdn.net/md?not_checkout=1&amp;spm=1001.2101.3001.5352&amp;articleId=134308484" rel="nofollow">推荐开启自动重载预装载功能</a></p> 
<h2><a id="_52"></a>三.中断服务函数编写（重写回调函数）</h2> 
<h3><a id="31HAL_53"></a>3.1HAL库的中断服务程序调用逻辑</h3> 
<blockquote> 
 <p>HAL库对中断进行了再封装，我们不再从中断向量指向的函数执行具体动作，而是通过<code>回调函数</code>来完成我们想完成的动作。HAL的封装帮我们简化了开发流程，只需要写业务逻辑，不需要我们去完成清除中断标志，HAL已经帮我们封装好了。</p> 
</blockquote> 
<p>想要具体了解怎么个原理可以参考<a href="https://blog.csdn.net/m0_46577050/article/details/129036709?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169942971116800188511606%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169942971116800188511606&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129036709-null-null.142%5Ev96%5Epc_search_result_base6&amp;utm_term=STM32cubemx%20f407%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD&amp;spm=1018.2226.3001.4187">这篇博客</a>。</p> 
<h3><a id="32_57"></a>3.2如何定位到回调函数？</h3> 
<blockquote> 
 <p>Cube生成的代码会将回调函数写到main.c文件中。例如本次实验的定时器中断回调函数Cube在main.c中生成的代码：<img src="https://images2.imgbox.com/0f/c4/w2SE7LVG_o.png" alt="在这里插入图片描述"><br> 在这里我就完成了两件事：<br> 一是确定中断来源，也就是那两句if语句。<br> 二是编写业务代码，也就是LED0翻转。</p> 
</blockquote> 
<h2><a id="_63"></a>四.开启定时器中断</h2> 
<blockquote> 
 <p>Cubemx生成的代码并不会自动帮我们打开定时器中断，需要我们手动打开。<br> 需要调用函数<code>HAL_TIM_Base_Start_IT(&amp;htim6);</code>来帮助我们开启定时器中断。</p> 
</blockquote> 
<blockquote> 
 <p>在开启定时器中断前有一个细节，在文章最开头我已经说明了，在启动定时器中断前如果不<code>手动清除中断</code>，那么一旦启动定时器中断，系统就会<code>马上执行一次中断</code>。也就是一旦开启LED灯状态就会进行一次翻转。</p> 
</blockquote> 
<p><strong>下面这些仅作了解</strong></p> 
<blockquote> 
 <p>HAL_TIM_Base_Start_IT(&amp;htim6);`<br> 1.用于启动定时器基本定时中断<br> 2.当定时器的计数器溢出时，会触发中断<br> 3.适用于需要周期性触发中断的应用，如定时器中断用于操作系统的任务调度</p> 
</blockquote> 
<blockquote> 
 <p>还有一个类似的函数是:<br> HAL_TIM_IC_Start_IT(&amp;htim6);`<br> 用于启动输入捕获(Input Capture)模式下的定时器中断<br> 当输入信号发生边沿变化时，会触发中断<br> 适用于需要测量输入信号频率或脉冲宽度的应用，例如测量超声波HC05高电平时长来测距</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/56376d371ca9d1d1a8ff69d073a597a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">半导体封装之倒装封装 （Flip Chip）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e6cbf5aaf5ccb006cba8bf6c18708ac/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何二次封装一个Vue3组件库？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>