<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java equals与hasCode详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java equals与hasCode详解" />
<meta property="og:description" content="以下是关于HashCode的官方文档定义：
[plain] view plain copy hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。 hashCode 的常规协定是： 在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。 以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） 当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。 以上这段官方文档的定义，我们可以抽出成以下几个关键点： 1、hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；
2、如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；
3、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；
4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。
再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。以下这段话是从别人帖子回复拷贝过来的：
[plain] view plain copy 1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有 例如内存中有这样的位置 0 1 2 3 4 5 6 7 而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。 但如果用hashcode那就会使效率提高很多。 我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。 2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。 也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。 那么。重写了equals()，为什么还要重写hashCode()呢？ 想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊 最后，我们来看一个具体的示例吧，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/66abc702dd544f5727c1d27dbfe8d1a7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-10-12T22:50:35+08:00" />
<meta property="article:modified_time" content="2014-10-12T22:50:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java equals与hasCode详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>以下是关于HashCode的官方文档定义：</p> 
<div class="dp-highlighter bg_plain"> 
 <div class="bar"> 
  <div class="tools"> 
   <strong>[plain]</strong> 
   <a target="_blank" href="http://blog.csdn.net/fenglibing/article/details/8905007#" class="ViewSource" title="view plain" rel="noopener noreferrer"> view plain</a> 
   <a target="_blank" href="http://blog.csdn.net/fenglibing/article/details/8905007#" class="CopyToClipboard" title="copy" rel="noopener noreferrer">copy</a> 
  </div> 
 </div> 
 <ol start="1"><li class="alt">hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。   </li><li>  </li><li class="alt">hashCode 的常规协定是：   </li><li>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。   </li><li class="alt">如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。   </li><li>以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。   </li><li class="alt">实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）   </li><li>  </li><li class="alt">当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。  </li></ol> 
</div> 
<br> 以上这段官方文档的定义，我们可以抽出成以下几个关键点： 
<p>1、hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；</p> 
<p>2、如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；</p> 
<p>3、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；</p> 
<p>4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们<strong>“存放在同一个篮子里”</strong>。</p> 
<p><br> </p> 
<p>再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。以下这段话是从别人帖子回复拷贝过来的：</p> 
<div class="dp-highlighter bg_plain"> 
 <div class="bar"> 
  <div class="tools"> 
   <strong>[plain]</strong> 
   <a target="_blank" href="http://blog.csdn.net/fenglibing/article/details/8905007#" class="ViewSource" title="view plain" rel="noopener noreferrer"> view plain</a> 
   <a target="_blank" href="http://blog.csdn.net/fenglibing/article/details/8905007#" class="CopyToClipboard" title="copy" rel="noopener noreferrer">copy</a> 
  </div> 
 </div> 
 <ol start="1"><li class="alt">1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有  </li><li>例如内存中有这样的位置  </li><li class="alt">0  1  2  3  4  5  6  7    </li><li>而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。  </li><li class="alt">但如果用hashcode那就会使效率提高很多。  </li><li>我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。  </li><li class="alt">  </li><li>2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。  </li><li class="alt">也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。  </li><li>那么。重写了equals()，为什么还要重写hashCode()呢？  </li><li class="alt">想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊  </li></ol> 
</div> 
<br> 
<br> 
<p>最后，我们来看一个具体的示例吧，</p> 
<div class="dp-highlighter bg_java"> 
 <div class="bar"> 
  <div class="tools"> 
   <strong>[java]</strong> 
   <a target="_blank" href="http://blog.csdn.net/fenglibing/article/details/8905007#" class="ViewSource" title="view plain" rel="noopener noreferrer"> view plain</a> 
   <a target="_blank" href="http://blog.csdn.net/fenglibing/article/details/8905007#" class="CopyToClipboard" title="copy" rel="noopener noreferrer">copy</a> 
  </div> 
 </div> 
 <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public</span> <span class="keyword">class</span> HashTest {  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> i;  </li><li class="alt">  </li><li>    <span class="keyword">public</span> <span class="keyword">int</span> getI() {  </li><li class="alt">        <span class="keyword">return</span> i;  </li><li>    }  </li><li class="alt">  </li><li>    <span class="keyword">public</span> <span class="keyword">void</span> setI(<span class="keyword">int</span> i) {  </li><li class="alt">        <span class="keyword">this</span>.i = i;  </li><li>    }  </li><li class="alt">  </li><li>    <span class="keyword">public</span> <span class="keyword">int</span> hashCode() {  </li><li class="alt">        <span class="keyword">return</span> i % <span class="number">10</span>;  </li><li>    }  </li><li class="alt">  </li><li>    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {  </li><li class="alt">        HashTest a = <span class="keyword">new</span> HashTest();  </li><li>        HashTest b = <span class="keyword">new</span> HashTest();  </li><li class="alt">        a.setI(<span class="number">1</span>);  </li><li>        b.setI(<span class="number">1</span>);  </li><li class="alt">        Set&lt;HashTest&gt; set = <span class="keyword">new</span> HashSet&lt;HashTest&gt;();  </li><li>        set.add(a);  </li><li class="alt">        set.add(b);  </li><li>        System.out.println(a.hashCode() == b.hashCode());  </li><li class="alt">        System.out.println(a.equals(b));  </li><li>        System.out.println(set);  </li><li class="alt">    }  </li><li>}  </li></ol> 
</div> 
<br> 这个输出的结果： 
<div class="dp-highlighter bg_plain"> 
 <div class="bar"> 
  <div class="tools"> 
   <strong>[plain]</strong> 
   <a target="_blank" href="http://blog.csdn.net/fenglibing/article/details/8905007#" class="ViewSource" title="view plain" rel="noopener noreferrer"> view plain</a> 
   <a target="_blank" href="http://blog.csdn.net/fenglibing/article/details/8905007#" class="CopyToClipboard" title="copy" rel="noopener noreferrer">copy</a> 
  </div> 
 </div> 
 <ol start="1"><li class="alt">true  </li><li>false  </li><li class="alt">[com.ubs.sae.test.HashTest@1, com.ubs.sae.test.HashTest@1]  </li></ol> 
</div> 
<br> 以上这个示例，我们只是重写了hashCode方法，从上面的结果可以看出，虽然两个对象的hashCode相等，但是实际上两个对象并不是相等；，我们没有重写equals方法，那么就会调用object默认的equals方法，是比较两个对象的引用是不是相同，显示这是两个不同的对象，两个对象的引用肯定是不定的。这里我们将生成的对象放到了HashSet中，而HashSet中只能够存放唯一的对象，也就是相同的（适用于equals方法）的对象只会存放一个，但是这里实际上是两个对象a,b都被放到了HashSet中，这样HashSet就失去了他本身的意义了。 
<p>此时我们把equals方法给加上：</p> 
<div class="dp-highlighter bg_java"> 
 <div class="bar"> 
  <div class="tools"> 
   <strong>[java]</strong> 
   <a target="_blank" href="http://blog.csdn.net/fenglibing/article/details/8905007#" class="ViewSource" title="view plain" rel="noopener noreferrer"> view plain</a> 
   <a target="_blank" href="http://blog.csdn.net/fenglibing/article/details/8905007#" class="CopyToClipboard" title="copy" rel="noopener noreferrer">copy</a> 
  </div> 
 </div> 
 <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public</span> <span class="keyword">class</span> HashTest {  </li><li>    <span class="keyword">private</span> <span class="keyword">int</span> i;  </li><li class="alt">  </li><li>    <span class="keyword">public</span> <span class="keyword">int</span> getI() {  </li><li class="alt">        <span class="keyword">return</span> i;  </li><li>    }  </li><li class="alt">  </li><li>    <span class="keyword">public</span> <span class="keyword">void</span> setI(<span class="keyword">int</span> i) {  </li><li class="alt">        <span class="keyword">this</span>.i = i;  </li><li>    }  </li><li class="alt">  </li><li>    &lt;span style=<span class="string">"color:#3366FF;"</span>&gt;&lt;strong&gt;<span class="keyword">public</span> <span class="keyword">boolean</span> equals(Object object) {  </li><li class="alt">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) {  </li><li>            <span class="keyword">return</span> <span class="keyword">false</span>;  </li><li class="alt">        }  </li><li>        <span class="keyword">if</span> (object == <span class="keyword">this</span>) {  </li><li class="alt">            <span class="keyword">return</span> <span class="keyword">true</span>;  </li><li>        }  </li><li class="alt">        <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> HashTest)) {  </li><li>            <span class="keyword">return</span> <span class="keyword">false</span>;  </li><li class="alt">        }  </li><li>        HashTest other = (HashTest) object;  </li><li class="alt">        <span class="keyword">if</span> (other.getI() == <span class="keyword">this</span>.getI()) {  </li><li>            <span class="keyword">return</span> <span class="keyword">true</span>;  </li><li class="alt">        }  </li><li>        <span class="keyword">return</span> <span class="keyword">false</span>;  </li><li class="alt">    }&lt;/strong&gt;&lt;/span&gt;  </li><li>  </li><li class="alt">    <span class="keyword">public</span> <span class="keyword">int</span> hashCode() {  </li><li>        <span class="keyword">return</span> i % <span class="number">10</span>;  </li><li class="alt">    }  </li><li>  </li><li class="alt">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {  </li><li>        HashTest a = <span class="keyword">new</span> HashTest();  </li><li class="alt">        HashTest b = <span class="keyword">new</span> HashTest();  </li><li>        a.setI(<span class="number">1</span>);  </li><li class="alt">        b.setI(<span class="number">1</span>);  </li><li>        Set&lt;HashTest&gt; set = <span class="keyword">new</span> HashSet&lt;HashTest&gt;();  </li><li class="alt">        set.add(a);  </li><li>        set.add(b);  </li><li class="alt">        System.out.println(a.hashCode() == b.hashCode());  </li><li>        System.out.println(a.equals(b));  </li><li class="alt">        System.out.println(set);  </li><li>    }  </li><li class="alt">}  </li></ol> 
</div> 此时得到的结果就会如下： 
<div class="dp-highlighter bg_plain"> 
 <div class="bar"> 
  <div class="tools"> 
   <strong>[plain]</strong> 
   <a target="_blank" href="http://blog.csdn.net/fenglibing/article/details/8905007#" class="ViewSource" title="view plain" rel="noopener noreferrer"> view plain</a> 
   <a target="_blank" href="http://blog.csdn.net/fenglibing/article/details/8905007#" class="CopyToClipboard" title="copy" rel="noopener noreferrer">copy</a> 
  </div> 
 </div> 
 <ol start="1"><li class="alt">true  </li><li>true  </li><li class="alt">[com.ubs.sae.test.HashTest@1]  </li></ol> 
</div> 
<p>从结果我们可以看出，现在两个对象就完全相等了，HashSet中也只存放了一份对象</p> 
<p><strong>如果要重写equals()，则必须要重写hasCode()，两个对象之间互相的equals，两个对象必须具备相同的hasCode</strong>。<br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b1e6cc369cb23d6deb8e87b02da83ed3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通过rtmpdump推送海康视频流到red5服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ca7281dedcf34b7e195b0619428ae37/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java.util.ConcurrentModificationException详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>