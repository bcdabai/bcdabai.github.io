<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【ASP.NET Core 基础知识】--依赖注入（DI）--在ASP.NET Core中使用依赖注入 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【ASP.NET Core 基础知识】--依赖注入（DI）--在ASP.NET Core中使用依赖注入" />
<meta property="og:description" content="一、在ASP.NET Core中实现依赖注入 1.1 配置依赖注入 在ASP.NET Core中实现依赖注入的第一步是配置依赖注入。ASP.NET Core使用了一个称为依赖注入容器（DI Container）的组件来管理对象之间的依赖关系。DI容器在应用程序启动时被配置，并且可以在应用程序的整个生命周期内使用。以下是配置依赖注入的基本步骤：
注册服务：
使用services.AddTransient&lt;TService&gt;()来注册一个瞬态服务，每次请求都会创建一个新的实例。使用services.AddScoped&lt;TService&gt;()来注册一个作用域服务，每次请求会创建一个实例，但在同一个Http请求的生命周期内共享同一个实例。使用services.AddSingleton&lt;TService&gt;()来注册一个单例服务，只会创建一个实例，并在应用程序的整个生命周期内共享。 这些方法通常在ConfigureServices方法中调用，该方法在Startup类中定义。
使用IServiceProvider：
在需要注入服务的地方（例如控制器、服务、视图等），通过构造函数或属性注入来使用服务。在控制器中，可以使用HttpContext.RequestServices属性获取IServiceProvider实例，并通过它来获取服务。 配置中间件：
在Configure方法中，使用依赖注入来构造中间件实例。中间件通常需要注入服务，因此中间件应该使用构造函数注入。 使用DI容器的其他功能：
ASP.NET Core的DI容器提供了更多的功能，例如支持自动解析服务、使用元数据等。 下面是一个简单的示例，演示如何配置依赖注入：
public class Startup { public void ConfigureServices(IServiceCollection services) { // 注册瞬态服务 services.AddTransient&lt;IMyService, MyService&gt;(); // 注册作用域服务 services.AddScoped&lt;IHttpContextAccessor, HttpContextAccessor&gt;(); // 注册单例服务 services.AddSingleton&lt;ISomeOtherService, SomeOtherService&gt;(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { // 使用注入的服务构造中间件 app.UseMiddleware&lt;MyMiddleware&gt;(); // ... } } Tip：在ASP.NET Core 3.0之前，使用Configure方法来配置依赖注入。在ASP.NET Core 3.0及更高版本中，推荐使用AddServices方法。
在配置完依赖注入后，服务就可以在应用程序的任何地方使用，只要它们被正确的注入到需要的类中。
1.2 定义服务 在ASP.NET Core中实现依赖注入的第二步是定义服务。服务是应用程序中需要注入到其他组件的对象或类。服务可以是瞬态、作用域或单例的，这取决于它们是如何注册的。以下是定义服务的步骤：
创建服务类： 创建一个类，它实现了某个接口或继承自某个基类。这个类就是你的服务类，它包含了实现逻辑。如果服务类没有对应的接口或基类，也可以直接创建一个类，但最好还是提供一个接口或基类以支持依赖注入的灵活性。 定义接口或基类： 如果你创建了一个服务类，那么应该为它定义一个接口或基类，以便其他组件可以依赖注入这个服务。接口或基类定义了服务的公共行为，而具体的实现则由服务类来完成。 注册服务： 在ConfigureServices方法中，使用AddTransient、AddScoped或AddSingleton方法注册服务。注册时应该传入一个工厂方法或使用默认的工厂方法来创建服务实例。 以下是一个简单的示例，演示如何定义服务并注册到DI容器中：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/79d6cd041438e90d5ebca7be1a86beb7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-23T23:03:58+08:00" />
<meta property="article:modified_time" content="2024-01-23T23:03:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【ASP.NET Core 基础知识】--依赖注入（DI）--在ASP.NET Core中使用依赖注入</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="ASPNET_Core_0"></a>一、在ASP.NET Core中实现依赖注入</h4> 
<h6><a id="11__1"></a>1.1 配置依赖注入</h6> 
<p>在ASP.NET Core中实现依赖注入的第一步是配置依赖注入。ASP.NET Core使用了一个称为依赖注入容器（DI Container）的组件来管理对象之间的依赖关系。DI容器在应用程序启动时被配置，并且可以在应用程序的整个生命周期内使用。以下是配置依赖注入的基本步骤：</p> 
<ol><li> <p><strong>注册服务</strong>：</p> 
  <ul><li>使用<code>services.AddTransient&lt;TService&gt;()</code>来注册一个瞬态服务，每次请求都会创建一个新的实例。</li><li>使用<code>services.AddScoped&lt;TService&gt;()</code>来注册一个作用域服务，每次请求会创建一个实例，但在同一个Http请求的生命周期内共享同一个实例。</li><li>使用<code>services.AddSingleton&lt;TService&gt;()</code>来注册一个单例服务，只会创建一个实例，并在应用程序的整个生命周期内共享。</li></ul> <p>这些方法通常在<code>ConfigureServices</code>方法中调用，该方法在<code>Startup</code>类中定义。</p> </li><li> <p><strong>使用IServiceProvider</strong>：</p> 
  <ul><li>在需要注入服务的地方（例如控制器、服务、视图等），通过构造函数或属性注入来使用服务。</li><li>在控制器中，可以使用<code>HttpContext.RequestServices</code>属性获取IServiceProvider实例，并通过它来获取服务。</li></ul> </li><li> <p><strong>配置中间件</strong>：</p> 
  <ul><li>在<code>Configure</code>方法中，使用依赖注入来构造中间件实例。</li><li>中间件通常需要注入服务，因此中间件应该使用构造函数注入。</li></ul> </li><li> <p><strong>使用DI容器的其他功能</strong>：</p> 
  <ul><li>ASP.NET Core的DI容器提供了更多的功能，例如支持自动解析服务、使用元数据等。</li></ul> </li></ol> 
<p>下面是一个简单的示例，演示如何配置依赖注入：</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Startup</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ConfigureServices</span><span class="token punctuation">(</span><span class="token class-name">IServiceCollection</span> services<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 注册瞬态服务</span>
        services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddTransient</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>IMyService<span class="token punctuation">,</span> MyService<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 注册作用域服务</span>
        services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddScoped</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>IHttpContextAccessor<span class="token punctuation">,</span> HttpContextAccessor<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 注册单例服务</span>
        services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>ISomeOtherService<span class="token punctuation">,</span> SomeOtherService<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Configure</span><span class="token punctuation">(</span><span class="token class-name">IApplicationBuilder</span> app<span class="token punctuation">,</span> <span class="token class-name">IWebHostEnvironment</span> env<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 使用注入的服务构造中间件</span>
        app<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">UseMiddleware</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>MyMiddleware<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>Tip：在ASP.NET Core 3.0之前，使用<code>Configure</code>方法来配置依赖注入。在ASP.NET Core 3.0及更高版本中，推荐使用<code>AddServices</code>方法。</p> 
</blockquote> 
<p>在配置完依赖注入后，服务就可以在应用程序的任何地方使用，只要它们被正确的注入到需要的类中。</p> 
<h6><a id="12__47"></a>1.2 定义服务</h6> 
<p>在ASP.NET Core中实现依赖注入的第二步是定义服务。服务是应用程序中需要注入到其他组件的对象或类。服务可以是瞬态、作用域或单例的，这取决于它们是如何注册的。以下是定义服务的步骤：</p> 
<ol><li><strong>创建服务类</strong>： 
  <ul><li>创建一个类，它实现了某个接口或继承自某个基类。这个类就是你的服务类，它包含了实现逻辑。</li><li>如果服务类没有对应的接口或基类，也可以直接创建一个类，但最好还是提供一个接口或基类以支持依赖注入的灵活性。</li></ul> </li><li><strong>定义接口或基类</strong>： 
  <ul><li>如果你创建了一个服务类，那么应该为它定义一个接口或基类，以便其他组件可以依赖注入这个服务。</li><li>接口或基类定义了服务的公共行为，而具体的实现则由服务类来完成。</li></ul> </li><li><strong>注册服务</strong>： 
  <ul><li>在<code>ConfigureServices</code>方法中，使用<code>AddTransient</code>、<code>AddScoped</code>或<code>AddSingleton</code>方法注册服务。</li><li>注册时应该传入一个工厂方法或使用默认的工厂方法来创建服务实例。</li></ul> </li></ol> 
<p>以下是一个简单的示例，演示如何定义服务并注册到DI容器中：</p> 
<pre><code class="prism language-csharp"><span class="token comment">// 定义服务接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IMyService</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义服务实现</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IMyService</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 实现逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在Startup.cs中注册服务</span>
<span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ConfigureServices</span><span class="token punctuation">(</span><span class="token class-name">IServiceCollection</span> services<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 注册瞬态服务</span>
    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddTransient</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>IMyService<span class="token punctuation">,</span> MyService<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 注册作用域服务</span>
    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddScoped</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>IHttpContextAccessor<span class="token punctuation">,</span> HttpContextAccessor<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 注册单例服务</span>
    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>ISomeOtherService<span class="token punctuation">,</span> SomeOtherService<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，<code>MyService</code>类实现了<code>IMyService</code>接口，并在<code>ConfigureServices</code>方法中被注册为瞬态服务。这意味着每次需要注入<code>IMyService</code>时，DI容器都会创建一个新的<code>MyService</code>实例。<br> 定义好服务和注册到DI容器后，服务就可以被注入到其他组件中，如控制器、视图组件、中间件等。</p> 
<h6><a id="13__92"></a>1.3 使用服务</h6> 
<p>在ASP.NET Core中，一旦服务被定义并注册到DI容器中，你就可以在需要的地方使用这些服务。以下是使用服务的一些常见方法：</p> 
<ol><li> <p><strong>构造函数注入</strong>：</p> 
  <ul><li>通过在组件的构造函数中标记需要注入的服务，让DI容器自动注入服务。</li><li>例如，如果你有一个服务类<code>MyService</code>，你可以在控制器或服务中通过构造函数注入该服务：<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Controller</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IMyService</span> _myService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">MyController</span><span class="token punctuation">(</span><span class="token class-name">IMyService</span> myService<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _myService <span class="token operator">=</span> myService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li><li> <p><strong>属性注入</strong>：</p> 
  <ul><li>除了构造函数注入，你还可以使用属性注入。在组件中定义一个带有<code>[FromInject]</code>注解的属性，DI容器会自动将服务注入到该属性中。</li><li>例如：<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IMyService</span> _myService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">MyService</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">FromInject</span></span><span class="token punctuation">]</span> <span class="token class-name">IMyService</span> myService<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _myService <span class="token operator">=</span> myService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li><li> <p><strong>方法注入</strong>：</p> 
  <ul><li>在某些情况下，你可能希望在方法级别注入服务。你可以使用<code>HttpContext.RequestServices</code>来获取IServiceProvider实例，然后通过它来获取服务。</li><li>例如：<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Controller</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token return-type class-name">IActionResult</span> <span class="token function">MyAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name"><span class="token keyword">var</span></span> myService <span class="token operator">=</span> HttpContext<span class="token punctuation">.</span>RequestServices<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetService</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>IMyService<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 使用myService</span>
        <span class="token keyword">return</span> <span class="token function">View</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li><li> <p><strong>视图注入</strong>：</p> 
  <ul><li>在视图中，你可以使用<code>@inject</code>关键字来注入服务。</li><li>例如：<pre><code class="prism language-html">@model MyModel
@inject IMyService MyService
<span class="token comment">&lt;!-- 使用MyService --&gt;</span>
</code></pre> </li></ul> </li><li> <p><strong>中间件注入</strong>：</p> 
  <ul><li>在中间件中，你可以通过构造函数或属性注入来使用服务。</li><li>例如：<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMiddleware</span>
<span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IMyService</span> _myService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">MyMiddleware</span><span class="token punctuation">(</span><span class="token class-name">IMyService</span> myService<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _myService <span class="token operator">=</span> myService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">InvokeAsync</span><span class="token punctuation">(</span><span class="token class-name">HttpContext</span> context<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 使用_myService</span>
        <span class="token keyword">await</span> next<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li></ol> 
<blockquote> 
 <p>Tip：注入服务时应根据具体情况选择最合适的方法。在某些情况下，构造函数注入可能更适合，因为它可以确保依赖项在对象创建时就被提供。在其他情况下，属性注入或方法注入可能更方便。</p> 
</blockquote> 
<h4><a id="ASPNET_Core_168"></a>二、ASP.NET Core中的依赖注入核心对象</h4> 
<h6><a id="21_Startup_169"></a>2.1 解析Startup对象</h6> 
<p>在ASP.NET Core中，依赖注入（DI）的核心对象是<code>IServiceProvider</code>，它提供了对已注册服务的解析。<code>Startup</code>对象是应用程序启动时的重要对象，它的主要职责是配置服务和中间件。解析<code>Startup</code>对象实际上意味着解析由<code>IServiceProvider</code>提供的<code>IServiceProvider</code>实例，以便在应用程序启动过程中使用依赖注入。</p> 
<ol><li><strong>创建HostBuilder</strong>： 
  <ul><li>使用<code>Microsoft.AspNetCore.Hosting</code>命名空间中的<code>HostBuilder</code>类来创建一个<code>IHostBuilder</code>实例。</li><li>使用<code>ConfigureServices</code>方法注册服务和中间件。</li></ul> </li><li><strong>构建Host</strong>： 
  <ul><li>通过调用<code>HostBuilder</code>的<code>Build</code>方法创建一个<code>IHost</code>实例。</li><li>这个<code>IHost</code>实例包含了DI容器和应用程序的服务。</li></ul> </li><li><strong>运行Host</strong>： 
  <ul><li>调用<code>IHost</code>的<code>Run</code>方法来启动应用程序。</li><li>或者，调用<code>IHost</code>的<code>RunAsync</code>方法来启动应用程序并允许异步操作。</li></ul> </li><li><strong>使用DI</strong>： 
  <ul><li>在应用程序的任何地方，都可以使用<code>IServiceProvider</code>来解析服务。</li><li>例如，在控制器或服务中通过构造函数或属性注入来使用服务。</li></ul> </li></ol> 
<p>下面是一个简单的示例，演示如何使用<code>Startup</code>对象来配置服务和中间件，并解析服务：</p> 
<pre><code class="prism language-csharp"><span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Builder</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Hosting</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>Extensions<span class="token punctuation">.</span>DependencyInjection</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>Extensions<span class="token punctuation">.</span>Hosting</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Program</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        Host<span class="token punctuation">.</span><span class="token function">CreateDefaultBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">ConfigureServices</span><span class="token punctuation">(</span>services <span class="token operator">=&gt;</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 注册服务</span>
                services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddTransient</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>IMyService<span class="token punctuation">,</span> MyService<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 注册其他服务...</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 运行应用程序</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Startup</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ConfigureServices</span><span class="token punctuation">(</span><span class="token class-name">IServiceCollection</span> services<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 配置服务</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Configure</span><span class="token punctuation">(</span><span class="token class-name">IApplicationBuilder</span> app<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 配置中间件</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IMyService</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IServiceProvider</span> _serviceProvider<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">MyService</span><span class="token punctuation">(</span><span class="token class-name">IServiceProvider</span> serviceProvider<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _serviceProvider <span class="token operator">=</span> serviceProvider<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 使用解析的服务</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个示例中，<code>Startup</code>类定义了<code>ConfigureServices</code>方法，用于注册服务，以及<code>Configure</code>方法，用于配置请求管道的中间件。在应用程序启动时，<code>IServiceProvider</code>会自动创建，并且可以在需要的地方使用，比如在<code>MyService</code>类的构造函数中。</p> 
<blockquote> 
 <p>Tip：<code>IServiceProvider</code>是解析服务的关键，它提供了对DI容器的访问，允许你在应用程序的任何地方获取已注册的服务。</p> 
</blockquote> 
<h6><a id="22__237"></a>2.2 解析中间件对象</h6> 
<p>在ASP.NET Core中，中间件对象是通过<code>Use</code>方法来解析和添加到请求管道中的。每个中间件都是一个处理请求和生成响应的函数。解析中间件对象通常发生在以下场景：</p> 
<ul><li><strong>在Startup.Configure方法中</strong>：这是添加和配置中间件的标准位置。</li><li><strong>在自定义中间件中</strong>：如果你创建了一个自定义中间件，你可能需要在其他地方解析该中间件对象。</li></ul> 
<p>以下是一个简单的示例，演示如何解析和使用中间件：</p> 
<pre><code class="prism language-csharp"><span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Builder</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Hosting</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>Extensions<span class="token punctuation">.</span>DependencyInjection</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>Extensions<span class="token punctuation">.</span>Hosting</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Program</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        Host<span class="token punctuation">.</span><span class="token function">CreateDefaultBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">ConfigureServices</span><span class="token punctuation">(</span>services <span class="token operator">=&gt;</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 注册中间件</span>
                services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddTransient</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>MyMiddleware<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                services<span class="token punctuation">.</span><span class="token function">AddRouting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 示例：添加路由中间件</span>
                <span class="token comment">// 注册其他服务...</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 运行应用程序</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Startup</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Configure</span><span class="token punctuation">(</span><span class="token class-name">IApplicationBuilder</span> app<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 使用中间件</span>
        app<span class="token punctuation">.</span><span class="token function">UseMyMiddleware</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        app<span class="token punctuation">.</span><span class="token function">UseRouting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用路由中间件</span>
        <span class="token comment">// 使用其他中间件...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyMiddleware</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">RequestDelegate</span> _next<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">MyMiddleware</span><span class="token punctuation">(</span><span class="token class-name">RequestDelegate</span> next<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _next <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">InvokeAsync</span><span class="token punctuation">(</span><span class="token class-name">HttpContext</span> context<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 在这里处理请求</span>

        <span class="token comment">// 调用管道中的下一个中间件</span>
        <span class="token keyword">await</span> <span class="token function">_next</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中：</p> 
<ol><li><code>MyMiddleware</code>是一个自定义中间件类，它实现了<code>InvokeAsync</code>方法来处理请求，并通过<code>RequestDelegate</code>类型的参数来调用管道中的下一个中间件。</li><li>在<code>Startup.Configure</code>方法中，我们使用<code>app.UseMyMiddleware()</code>来添加和配置<code>MyMiddleware</code>中间件。</li><li>中间件的解析是通过DI容器自动完成的，当我们在<code>ConfigureServices</code>方法中添加<code>services.AddTransient&lt;MyMiddleware&gt;()</code>时。</li><li>每个中间件都会在前一个中间件完成处理后调用，从而形成了一个请求处理管道。</li></ol> 
<blockquote> 
 <p>Tip：中间件的解析和添加是由ASP.NET Core框架自动处理的，开发人员通常不需要直接解析中间件对象，而是使用<code>Use</code>方法来添加它们到请求管道中。</p> 
</blockquote> 
<h6><a id="23_ControllerView_302"></a>2.3 解析Controller对象和View对象</h6> 
<p>在ASP.NET Core中，依赖注入允许我们轻松地将服务（例如Controller和View）注入到需要它们的组件中。ASP.NET Core的依赖注入框架基于.NET Core的DI框架，提供了几个核心对象来管理和解析依赖关系。</p> 
<ol><li><strong>解析Controller对象</strong>： 
  <ul><li>Controller对象是MVC框架的一部分，它们处理HTTP请求并准备响应。</li><li>控制器通常作为服务注册到DI容器中，并通过构造函数注入的方式解析。</li></ul> </li></ol> 
<p>解析Controller对象的示例代码如下：</p> 
<pre><code class="prism language-csharp"><span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Mvc</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>Extensions<span class="token punctuation">.</span>DependencyInjection</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ControllerBase</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IMyService</span> _myService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">MyController</span><span class="token punctuation">(</span><span class="token class-name">IMyService</span> myService<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _myService <span class="token operator">=</span> myService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">HttpGet</span></span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>IActionResult<span class="token punctuation">&gt;</span></span> <span class="token function">GetData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 使用注入的服务</span>
        <span class="token class-name"><span class="token keyword">var</span></span> data <span class="token operator">=</span> <span class="token keyword">await</span> _myService<span class="token punctuation">.</span><span class="token function">GetData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">Ok</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在Startup.cs的ConfigureServices方法中注册服务</span>
<span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ConfigureServices</span><span class="token punctuation">(</span><span class="token class-name">IServiceCollection</span> services<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddTransient</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>IMyService<span class="token punctuation">,</span> MyService<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddTransient</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>MyController<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，<code>MyController</code>通过构造函数注入了一个<code>IMyService</code>类型的服务实例。在<code>Startup.cs</code>的<code>ConfigureServices</code>方法中，我们注册了<code>MyService</code>和<code>MyController</code>作为瞬态服务。<br> 2. <strong>解析View对象</strong>：</p> 
<ul><li>View对象是MVC视图引擎的一部分，它们用于生成HTML响应。</li><li>视图通常通过Razor模板创建，并在控制器中返回给客户端。</li></ul> 
<p>解析View对象的示例代码如下：</p> 
<pre><code class="prism language-csharp"><span class="token keyword">using</span> <span class="token namespace">Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Mvc</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HomeController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Controller</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token return-type class-name">IActionResult</span> <span class="token function">Index</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">View</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，<code>HomeController</code>的<code>Index</code>方法返回了一个视图。ASP.NET Core会自动查找与控制器方法名称匹配的Razor视图，并使用它来生成HTML响应。</p> 
<blockquote> 
 <p>Tip：视图本身不是一个DI对象，但控制器可以使用DI容器解析服务，并将这些服务传递给视图使用。例如，可以在控制器中注入服务，并将服务传递给视图中的ViewModel，然后在视图中使用这些服务。</p> 
</blockquote> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HomeController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Controller</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IMyService</span> _myService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">HomeController</span><span class="token punctuation">(</span><span class="token class-name">IMyService</span> myService<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _myService <span class="token operator">=</span> myService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token return-type class-name">IActionResult</span> <span class="token function">Index</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name"><span class="token keyword">var</span></span> viewModel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MyViewModel</span><span class="token punctuation">(</span>_myService<span class="token punctuation">.</span><span class="token function">GetData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">View</span><span class="token punctuation">(</span>viewModel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，我们注入了一个<code>IMyService</code>服务，并在视图的ViewModel中使用了这个服务。</p> 
<h4><a id="_379"></a>三、依赖注入的最佳实践</h4> 
<h6><a id="31__380"></a>3.1 服务定位器模式</h6> 
<p>服务定位器模式（Service Locator Pattern）在依赖注入（DI）中是一个有争议的模式。虽然它可以提供一些灵活性，但过度使用服务定位器模式可能导致以下问题：</p> 
<ol><li><strong>耦合性增加</strong>：使用服务定位器模式可能会增加组件之间的耦合性，因为它们不是直接解析依赖项，而是通过一个中心化的服务来获取依赖项。</li><li><strong>依赖反转原则的违反</strong>：依赖反转原则（DIP）建议高级模块不应该依赖于低级模块，而是应该依赖于抽象。服务定位器模式可能会违反这一原则，因为它可能导致组件直接依赖于具体的服务实现。</li><li><strong>测试困难</strong>：使用服务定位器模式可能会使得单元测试更加困难，因为难以模拟和替换通过服务定位器获取的服务。</li><li><strong>难以进行依赖管理</strong>：服务定位器模式可能导致难以跟踪应用程序中到底有哪些服务被使用，从而使得依赖管理变得复杂。</li></ol> 
<p>尽管有这些潜在问题，服务定位器模式在某些情况下仍然是一个有用的工具。例如，在需要动态地解析服务或者在某些服务只能由服务定位器本身提供的情况下，服务定位器模式可能是合适的。<br> 最佳实践是尽量避免使用服务定位器模式，除非确实有必要。在需要使用服务定位器模式时，应该遵循以下建议：</p> 
<ul><li><strong>限制使用范围</strong>：只在确实需要动态解析服务或者服务只能由服务定位器提供时使用该模式。</li><li><strong>使用抽象</strong>：确保服务定位器返回的是抽象类型，而不是具体实现，以保持松耦合。</li><li><strong>使用依赖注入容器</strong>：如果可能，使用DI容器提供的API来获取服务，而不是直接调用服务定位器的解析方法。</li><li><strong>提供清晰的文档</strong>：如果使用了服务定位器模式，确保文档清晰地说明为什么需要这样做，以及如何使用。</li><li><strong>避免滥用</strong>：避免在整个代码库中滥用服务定位器模式，这可能导致代码难以维护和测试。</li></ul> 
<blockquote> 
 <p>Tip：服务定位器模式应作为最后的手段，而不是首选方法。</p> 
</blockquote> 
<h6><a id="32_IOC_396"></a>3.2 控制反转(IOC)</h6> 
<p>控制反转（Inversion of Control, IoC）是一种设计原则，其主要目的是降低代码之间的耦合度。在依赖注入（DI）中，控制反转通常指的是将对象创建和管理的工作从应用程序代码中移除，转而由外部容器（如ASP.NET Core内置的DI容器）来完成。以下是一些关于控制反转的最佳实践：</p> 
<ol><li><strong>明确依赖</strong>：在编写代码时，要明确声明依赖关系，这有助于提高代码的可读性和可维护性。</li><li><strong>使用构造函数注入</strong>：通过构造函数注入来满足依赖关系，这有助于确保依赖项在对象创建时就被正确地初始化。</li><li><strong>利用依赖注入容器</strong>：使用DI容器来自动管理对象的创建和依赖关系，这可以减少手动创建对象的工作，并且有助于确保依赖项正确地被解析。</li><li><strong>避免静态依赖</strong>：避免在代码中使用静态依赖关系，因为这会违反控制反转的原则，导致代码高度耦合。</li><li><strong>使用抽象</strong>：依赖注入通常与面向接口编程（Interface-Oriented Programming）相结合，这有助于确保低耦合和高度可测试性。</li><li><strong>延迟加载</strong>：在需要时才解析依赖项，这有助于减少不必要的内存使用。</li><li><strong>遵循依赖规则</strong>：确保依赖关系遵循依赖倒置原则（Dependence Inversion Principle, DIP），即高层模块不应该依赖于低层模块，应该依赖于抽象。</li><li><strong>使用服务定位器作为最后手段</strong>：在某些情况下，服务定位器模式可能是必要的，但要谨慎使用，并确保遵循上述最佳实践。</li><li><strong>编写可测试的代码</strong>：使用控制反转和依赖注入可以编写更容易测试的代码，因为代码的依赖关系可以更容易地被模拟和替换。</li><li><strong>保持简洁</strong>：不要为了使用控制反转和依赖注入而引入不必要的复杂性。在简单的情况下，直接的依赖可能更为合适。</li></ol> 
<p>在ASP.NET Core中，可以通过在<code>Startup.cs</code>的<code>ConfigureServices</code>方法中注册服务来实践控制反转，然后在需要这些服务的类中通过构造函数注入来使用它们。这种方法有助于保持代码的可维护性和可扩展性。</p> 
<h6><a id="33__410"></a>3.3 依赖注入的性能考虑</h6> 
<p>在考虑依赖注入（DI）的性能时，有几个方面需要注意：</p> 
<ol><li><strong>框架的选择</strong>：不同的DI框架和库在性能上可能会有所差异。选择性能高效的框架可以减少性能开销。</li><li><strong>容器解析性能</strong>：DI容器在解析依赖关系时可能会产生一些开销。在性能关键型应用中，可以考虑减少对容器的频繁调用，或者使用性能优化过的DI库。</li><li><strong>对象生命周期</strong>：尽量使用瞬态对象（每次请求创建新实例）来减少容器在解析依赖时的负担，特别是对于那些不需要长时间存在的对象。</li><li><strong>懒加载</strong>：对于非必需提前创建的对象，可以使用懒加载策略，这样只有在第一次使用时才会创建对象。</li><li><strong>性能测试</strong>：在实际应用中，对DI框架的性能进行基准测试，以确保选用的方案能够满足性能要求。</li><li><strong>缓存</strong>：对于需要频繁创建的对象，可以考虑使用缓存来减少对象的创建次数，从而提高性能。</li><li><strong>对象池</strong>：在某些场景下，可以使用对象池技术来重复利用已创建的对象，减少对象的创建和销毁开销。</li><li><strong>优化配置</strong>：根据应用的特点调整DI容器的配置，例如，通过限制注册的服务数量来提高性能。</li><li><strong>避免不必要的依赖</strong>：减少不必要的依赖关系可以降低DI容器的负担，提高解析性能。</li><li><strong>使用异步和多线程</strong>：在可能的情况下，使用异步和多线程技术来优化性能，特别是在长时间运行的任务中。</li></ol> 
<h4><a id="_423"></a>四、总结</h4> 
<p>今天我们学习了依赖注入（DI）的基本概念和最佳实践，包括控制反转（IoC）、构造函数注入、避免静态依赖等。同时，我们也了解了依赖注入的性能考虑，如使用瞬态对象、懒加载、对象池等技术来优化性能。在ASP.NET Core中，DI框架可以帮助我们轻松实现依赖注入，提高代码的可维护性和可扩展性。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b8819a473481e0a5fb7a9750dd488f8e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;】list的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e8edf0bc85ffb7bd9a41933cb760424/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C/C&#43;&#43; 试题 汇总</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>