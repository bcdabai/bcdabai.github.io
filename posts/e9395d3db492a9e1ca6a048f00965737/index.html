<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>网络入门基础 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="网络入门基础" />
<meta property="og:description" content="目录
计算机网络背景
网络发展
认识协议
协议的制订
网络协议详解
协议分层
OSI七层模型
TCP/IP模型
网络传输的基本流程
局域网通信
跨网络通信
网络中的地址管理
IP地址
MAC地址
计算机网络背景 网络发展 独立模式：计算机之间相互独立
在早期的时候，计算机之间是相互独立的，此时如果多个计算机要协同完成某种业务，那么就只能等一台计算机处理完后再将数据传递给下一台计算机，然后下一台计算机再进行相应的业务处理，效率非常低下。 网络互联：多台计算机连接在一起，完成数据共享 局域网LAN: 计算机数量更多了, 通过交换机和路由器连接在一起
后来这样的网络雏形逐渐发展，连入这个网络中的机器变得越来越多，于是就出现了局域网的概念。在局域网中有一种设备叫做交换机，交换机主要完成局域网内数据的转发工作，也就是在局域网内将数据从一台主机转发给另一台主机。各个局域网之间通过路由器连接起来，路由器主要完成数据的路由转发工作。 广域网WAN: 将远隔千里的计算机都连在一起
各个局域网之间通过路由器相互连接在一起，便组成了一个更大的网络结构，我们将其称之为广域网。实际局域网和广域网是一种相对的概念，我们也可以将广域网看作一个比较大的局域网。 认识协议 “协议”本质就是一种约定，通信双方只要曾经做过某种约定，之后就可以使用这种约定来完成某种事情。而网络协议是通信计算机双方必须共同遵从的一组约定，因此我们一定要将这种约定用计算机语言表达出来，此时双方计算机才能识别约定的相关内容。
计算机之间的传输媒介是光信号和电信号. 通过 &#34;频率&#34; 和 &#34;强弱&#34; 来表示 0 和 1 这样的信息. 要想传递各种不同的信息, 就需要约定好双方的数据格式。
比如通信计算机双方曾经做过如下约定：
如果code的值为1，则表示需要将data的值存储进数据库。如果code的值为2，则表示需要将data的值写入日志信息。如果code的值为3，则表示需要将data的值进行打印输出。 就是一个位段结构，我们是可以通过位段来表示某种协议规定的，而实际上计算机网络里面的协议报头也就是通过位段来实现的。
我们有了这样的约定后，当甲计算机向乙计算机发送类似于{1, 0x1234}的数据时，乙计算机识别到code的值是1，于是就知道了甲计算机是让自己将data的值存储进数据库，这是一种纯软件的约定方案。
协议的制订 在当前这个互联网时代，计算机生产商有很多，计算机操作系统也有很多，计算机网络硬件设备更是多种多样，那我们是如何让这些不同厂商之间生产的计算机能够相互顺畅的通信的呢？这时候就需要有人站出来，约定一个共同的标准，并且让大家都来遵守这个标准，这就是网络协议。
而那个站出来的人一定是该领域当中的佼佼者，因为网络协议的定制本质就是规则的定制，你要站出来制定规则那么一定要同行业的其他人都认可你。比如5G标准的定义，华为就是那个站出来的人，华为在通信领域已经具备很强的通信能力了，在这个行业里它就是所谓的佼佼者。
正所谓“一流的企业做标准，二流的企业做品牌，三流的企业做产品”。但是标准的定制有一部分是公益性、开源性的，它制定标准的目的是为了让我们的世界变得更好；而标准的定制还有一部分是具有一定盈利性质的，当你需要使用这项技术时就会收取部分专利费，此时就能将曾经做的技术投入进行变现。 网络协议详解 协议分层 协议分层的好处
网络协议栈设计成层状结构，其目的就是为了将层与层之间进行解耦，保证代码的可维护性和可扩展性。
比如在打电话的时候，站在工程师的角度实际这两个人并不是直接进行沟通的，而是甲的电话将甲说的话记录下来，经过一系列编码转码后，通过通信网络将信息从甲的电话传递到了乙的电话，然后信息在乙的电话中再经过对应的编码转码，最后乙才通过话筒听到了甲所说的话。
其中，人与人之间通信使用的是汉语，我们可以将其称为语言层；而电话和电话之间通信使用的是电话系统相关的一些接口，我们可以将其称之为通信设备层。
后来随着科技的发展，我们都用上了智能手机，此时我们下层使用的通信设备变了，或是这部电话卖到了其他国家，此时上层使用的通信语言变了，但我们仍然可以正常沟通。
分层最大的好处在于“封装”，在分层情况下，将某层的协议进行替换后，通信双方之间是不会受到影响的。
理解各层之间直接通信
从上述例子我们还可以看出，虽然在打电话时我们并不是直接进行沟通的，但是我们可以认为我们是在直接进行沟通，并且这两台电话也不是直接在进行沟通的，数据经过电话后，还需要各种基站，各种电信网络来进行数据转发，但是这两台电话依旧可以认为是直接在和对方电话进行通信的。
因此对于网络协议我们需要有一个基本的认识：关于通信，同层协议可以认为自己在和对方层直接进行通信，从而达到简化对于网络协议栈的理解。
也就是说，在网络协议栈中我们可以认为通信双方的应用层之间直接在进行通信，也可以认为通信双方的传输层之间直接在进行通信，对于网络层和数据链路层也同样如此。
OSI七层模型 上面我们说的是TCP/IP四层协议，而实际当初那个站出来的人定的协议叫做OSI七层协议：
OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型，是一个逻辑上的定义和规范把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机OSI 七层模型是一种框架性的设计方法，其最主要的功能使就是帮助不同类型的主机实现数据传输它的最大优点是将服务、接口和协议这三个概念明确地区分开来，概念清楚，理论也比较完整。通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯但是它既复杂又不实用，所以我们按照TCP/IP四层模型来讲解。 OSI七层模型如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e9395d3db492a9e1ca6a048f00965737/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-01T18:56:14+08:00" />
<meta property="article:modified_time" content="2023-09-01T18:56:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网络入门基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%83%8C%E6%99%AF-toc" style="margin-left:0px;"><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%83%8C%E6%99%AF" rel="nofollow">计算机网络背景</a></p> 
<p id="%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95-toc" style="margin-left:40px;"><a href="#%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95" rel="nofollow">网络发展</a></p> 
<p id="%E8%AE%A4%E8%AF%86%E5%8D%8F%E8%AE%AE-toc" style="margin-left:40px;"><a href="#%E8%AE%A4%E8%AF%86%E5%8D%8F%E8%AE%AE" rel="nofollow">认识协议</a></p> 
<p id="%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%B6%E8%AE%A2-toc" style="margin-left:40px;"><a href="#%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%B6%E8%AE%A2" rel="nofollow">协议的制订</a></p> 
<p id="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3" rel="nofollow">网络协议详解</a></p> 
<p id="%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82-toc" style="margin-left:40px;"><a href="#%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82" rel="nofollow">协议分层</a></p> 
<p id="OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B" rel="nofollow">OSI七层模型</a></p> 
<p id="TCP%2FIP%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#TCP%2FIP%E6%A8%A1%E5%9E%8B" rel="nofollow">TCP/IP模型</a></p> 
<p id="%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B" rel="nofollow">网络传输的基本流程</a></p> 
<p id="%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1-toc" style="margin-left:40px;"><a href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1" rel="nofollow">局域网通信</a></p> 
<p id="%E8%B7%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1-toc" style="margin-left:40px;"><a href="#%E8%B7%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1" rel="nofollow">跨网络通信</a></p> 
<p id="%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;"><a href="#%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86" rel="nofollow">网络中的地址管理</a></p> 
<p id="IP%E5%9C%B0%E5%9D%80-toc" style="margin-left:40px;"><a href="#IP%E5%9C%B0%E5%9D%80" rel="nofollow">IP地址</a></p> 
<p id="MAC%E5%9C%B0%E5%9D%80-toc" style="margin-left:40px;"><a href="#MAC%E5%9C%B0%E5%9D%80" rel="nofollow">MAC地址</a></p> 
<hr> 
<h2 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%83%8C%E6%99%AF">计算机网络背景</h2> 
<h3 id="%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95">网络发展</h3> 
<blockquote> 
 <p>独立模式：计算机之间相互独立</p> 
</blockquote> 
<p>在早期的时候，计算机之间是相互独立的，此时如果多个计算机要协同完成某种业务，那么就只能等一台计算机处理完后再将数据传递给下一台计算机，然后下一台计算机再进行相应的业务处理，效率非常低下。 </p> 
<p><img alt="" height="575" src="https://images2.imgbox.com/21/8e/gI2ZTY3e_o.png" width="696"></p> 
<blockquote> 
 <p>网络互联：多台计算机连接在一起，完成数据共享 </p> 
</blockquote> 
<p><img alt="" height="552" src="https://images2.imgbox.com/9f/20/Eg5rhQCk_o.png" width="946"></p> 
<blockquote> 
 <p>局域网LAN: 计算机数量更多了, 通过交换机和路由器连接在一起</p> 
</blockquote> 
<p>后来这样的网络雏形逐渐发展，连入这个网络中的机器变得越来越多，于是就出现了局域网的概念。在局域网中有一种设备叫做<strong>交换机</strong>，<strong>交换机</strong>主要完成局域网内数据的转发工作，也就是在局域网内将数据从一台主机转发给另一台主机。各个局域网之间通过<strong>路由器</strong>连接起来，<strong>路由器</strong>主要完成数据的路由转发工作。 </p> 
<p><img alt="" height="386" src="https://images2.imgbox.com/4c/49/E6wFQVDU_o.png" width="975"></p> 
<blockquote> 
 <p>广域网WAN: 将远隔千里的计算机都连在一起</p> 
</blockquote> 
<p>各个局域网之间通过路由器相互连接在一起，便组成了一个更大的网络结构，我们将其称之为广域网。<span style="color:#fe2c24;"><strong>实际局域网和广域网是一种相对的概念，我们也可以将广域网看作一个比较大的局域网。</strong></span> </p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/e2/da/gszkTmuV_o.png" width="1016"></p> 
<h3 id="%E8%AE%A4%E8%AF%86%E5%8D%8F%E8%AE%AE">认识协议</h3> 
<p>“协议”本质就是一种约定，通信双方只要曾经做过某种约定，之后就可以使用这种约定来完成某种事情。而网络协议是通信计算机双方必须共同遵从的一组约定，因此我们一定要将这种约定用计算机语言表达出来，此时双方计算机才能识别约定的相关内容。</p> 
<p><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">计算机之间的传输媒介是光信号和电信号. 通过 "频率" 和 "强弱" 来表示 0 和 1 这样的信息. 要想传递各种不同的信息, 就需要约定好双方的数据格式。</span></span></p> 
<p>比如通信计算机双方曾经做过如下约定：</p> 
<ul><li>如果code的值为1，则表示需要将data的值存储进数据库。</li><li>如果code的值为2，则表示需要将data的值写入日志信息。</li><li>如果code的值为3，则表示需要将data的值进行打印输出。</li></ul> 
<p><img alt="" height="201" src="https://images2.imgbox.com/c8/82/qJcJhRU8_o.png" width="552"></p> 
<p>就是一个位段结构，我们是可以通过位段来表示某种协议规定的，而实际上计算机网络里面的协议报头也就是通过位段来实现的。</p> 
<p>我们有了这样的约定后，当甲计算机向乙计算机发送类似于{1, 0x1234}的数据时，乙计算机识别到code的值是1，于是就知道了甲计算机是让自己将data的值存储进数据库，这是一种纯软件的约定方案。</p> 
<h3 id="%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%B6%E8%AE%A2">协议的制订</h3> 
<p>在当前这个互联网时代，计算机生产商有很多，计算机操作系统也有很多，计算机网络硬件设备更是多种多样，那我们是如何让这些不同厂商之间生产的计算机能够相互顺畅的通信的呢？这时候就需要有人站出来，约定一个共同的标准，并且让大家都来遵守这个标准，这就是网络协议。</p> 
<p>而那个站出来的人一定是该领域当中的佼佼者，因为网络协议的定制本质就是规则的定制，你要站出来制定规则那么一定要同行业的其他人都认可你。比如5G标准的定义，华为就是那个站出来的人，华为在通信领域已经具备很强的通信能力了，在这个行业里它就是所谓的佼佼者。</p> 
<p>正所谓“一流的企业做标准，二流的企业做品牌，三流的企业做产品”。但是标准的定制有一部分是公益性、开源性的，它制定标准的目的是为了让我们的世界变得更好；而标准的定制还有一部分是具有一定盈利性质的，当你需要使用这项技术时就会收取部分专利费，此时就能将曾经做的技术投入进行变现。 </p> 
<h2 id="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3">网络协议详解</h2> 
<h3 id="%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82">协议分层</h3> 
<blockquote> 
 <p>协议分层的好处</p> 
</blockquote> 
<p>网络协议栈设计成层状结构，其目的就是为了将层与层之间进行解耦，保证代码的可维护性和可扩展性。</p> 
<p>比如在打电话的时候，站在工程师的角度实际这两个人并不是直接进行沟通的，而是甲的电话将甲说的话记录下来，经过一系列编码转码后，通过通信网络将信息从甲的电话传递到了乙的电话，然后信息在乙的电话中再经过对应的编码转码，最后乙才通过话筒听到了甲所说的话。</p> 
<p>其中，人与人之间通信使用的是汉语，我们可以将其称为语言层；而电话和电话之间通信使用的是电话系统相关的一些接口，我们可以将其称之为通信设备层。</p> 
<p>后来随着科技的发展，我们都用上了智能手机，此时我们下层使用的通信设备变了，或是这部电话卖到了其他国家，此时上层使用的通信语言变了，但我们仍然可以正常沟通。</p> 
<p><img alt="" height="882" src="https://images2.imgbox.com/c7/35/hJe7e2LK_o.png" width="938"></p> 
<p><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">分层最大的好处在于“封装”，在分层情况下，将某层的协议进行替换后，通信双方之间是不会受到影响的。</span></span></p> 
<blockquote> 
 <p>理解各层之间直接通信</p> 
</blockquote> 
<p>从上述例子我们还可以看出，虽然在打电话时我们并不是直接进行沟通的，但是我们可以认为我们是在直接进行沟通，并且这两台电话也不是直接在进行沟通的，数据经过电话后，还需要各种基站，各种电信网络来进行数据转发，但是这两台电话依旧可以认为是直接在和对方电话进行通信的。</p> 
<p>因此对于网络协议我们需要有一个基本的认识：关于通信，同层协议可以认为自己在和对方层直接进行通信，从而达到简化对于网络协议栈的理解。</p> 
<p>也就是说，在网络协议栈中我们可以认为通信双方的应用层之间直接在进行通信，也可以认为通信双方的传输层之间直接在进行通信，对于网络层和数据链路层也同样如此。</p> 
<p><img alt="" height="521" src="https://images2.imgbox.com/9d/ad/KA80LGBS_o.png" width="1200"></p> 
<h3 id="OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B">OSI七层模型</h3> 
<p>上面我们说的是TCP/IP四层协议，而实际当初那个站出来的人定的协议叫做OSI七层协议：</p> 
<ul><li>OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型，是一个逻辑上的定义和规范</li><li>把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机</li><li>OSI 七层模型是一种框架性的设计方法，其最主要的功能使就是帮助不同类型的主机实现数据传输</li><li>它的最大优点是将服务、接口和协议这三个概念明确地区分开来，概念清楚，理论也比较完整。通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯</li><li>但是它既复杂又不实用，所以我们按照TCP/IP四层模型来讲解。</li></ul> 
<p>OSI七层模型如下：</p> 
<p><img alt="" height="809" src="https://images2.imgbox.com/53/e8/8u5czbr8_o.png" width="898"></p> 
<p><img alt="" height="564" src="https://images2.imgbox.com/5d/49/GAuPsYNE_o.png" width="900"></p> 
<h3 id="TCP%2FIP%E6%A8%A1%E5%9E%8B">TCP/IP模型</h3> 
<p>TCP/IP是一组协议的代名词，它还包括许多协议，共同组成了TCP/IP协议簇。TCP/IP通讯协议采用了五层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。</p> 
<ul><li>物理层：负责光/电信号的传递方式。比如现在以太网通用的网线(双绞线)、早期以太网采用的的同轴电缆(现在主要用于有线电视)、光纤，现在的wifi无线网使用电磁波等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等。<strong><span style="color:#fe2c24;">集线器(Hub)工作在物理层。</span></strong></li><li>数据链路层：负责设备之间的数据帧的传送和识别。例如网卡设备的驱动、帧同步(就是说从网线上检测到什么信号算作新帧的开始)、冲突检测(如果检测到冲突就自动重发)、数据差错校验等工作。有以太网、令牌环网，无线LAN等标准。<span style="color:#fe2c24;"><strong>交换机(Switch)工作在数据链路层。</strong></span></li><li>网络层：负责地址管理和路由选择。例如在IP协议中，通过IP地址来标识一台主机，并通过路由表的方式规划出两台主机之间的数据传输的线路(路由)。路由器(Router)工作在网路层。</li><li>传输层: 负责两台主机之间的数据传输。如传输控制协议 (TCP)，能够确保数据可靠的从源主机发送到目标主机。</li><li>应用层: 负责应用程序间沟通，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等. 我们的网络编程主要就是针对应用层。</li></ul> 
<p>与OSI七层模型各层的对应关系：</p> 
<p><img alt="" height="587" src="https://images2.imgbox.com/d4/b3/2iLL4tUu_o.png" width="918"></p> 
<p>可以看到，它们的下面几层几乎是没有区别的，操作系统对应的是传输层和网络层，数据链路层和物理层都是对应在驱动层的，而TCP/IP协议当中的应用层就对应到OSI七层协议当中的应用层、表示层和会话层。</p> 
<p>一般而言：</p> 
<ul><li>对于一台主机，它的操作系统内核实现了从传输层到物理层的内容。</li><li>对于一台路由器，它实现了从网络层到物理层的内容。</li><li>对于一台交换机，它实现了从数据链路层到物理层的内容。</li><li>对于集线器，它只实现了物理层的内容。</li></ul> 
<p>但这并不是绝对的，比如很多交换机也实现了网络层的转发，很多路由器也实现了部分传输层的内容（比如端口转发）。</p> 
<h2 id="%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B">网络传输的基本流程</h2> 
<p>我们这里以两台主机进行文件传输为例，此时各层对应的协议如下：</p> 
<p><img alt="" height="412" src="https://images2.imgbox.com/45/48/O7hxd3bF_o.png" width="934"></p> 
<h3 id="%E5%B1%80%E5%9F%9F%E7%BD%91%E9%80%9A%E4%BF%A1">局域网通信</h3> 
<p>首先需要明确的是，同一个局域网内的主机是能够直接进行通信的，因为最初局域网设计的目的，就是为了让局域网内的主机能够进行通信。</p> 
<p><img alt="" height="677" src="https://images2.imgbox.com/26/ed/h8PDXZgU_o.png" width="922"></p> 
<p>当用户要将文件传输给另一台主机前，该文件数据需要先通过网络协议栈进行封装：</p> 
<ul><li>文件数据先交给应用层，应用层添加上对应应用层协议的报头信息后，将数据再交给传输层。</li><li>传输层收到数据后，再添加上对应传输层协议的报头信息，并将数据继续向下进行交付。</li><li>网络层收到数据后，再添加上对应网络层协议的报头信息，接着将数据再交给链路层。</li><li>链路层收到数据后，最后再添加上对应链路层协议的报头信息，至此数据封装完毕。</li></ul> 
<p>数据封装完毕后就可以通过局域网将其发送给对端主机了，而当对端主机收到数据后，对应也需要通过网络协议栈对该数据进行解包与分用：</p> 
<ul><li>链路层收到数据后，先将数据中对应链路层协议的报头信息提取出来，然后将剩下的数据交给网络层。</li><li>网络层收到该数据后，再将数据中对应网络层协议的报头信息提取出来，然后将剩下的数据继续向上进行交付。</li><li>传输层收到该数据后，再将数据中对应传输层协议的报头信息提取出来，然后将剩下的数据再交付给应用层。</li><li>应用层收到数据后，最后将数据中对应应用层协议的报头信息提取出来，至此便完成了数据的解包与分用。</li></ul> 
<p>也就是说，任何一台主机在发送数据之前，该数据都要先自顶向下贯穿协议栈来完成数据的封装，在这个过程中，每一层协议都会添加上对应的报头信息；而任何一台主机收到数据后，都要先自底向上贯穿协议栈来完成数据的解包和分用，在这个过程中，每一层协议都会将对应的报头信息提取出来。</p> 
<blockquote> 
 <p>数据包封装和分用</p> 
</blockquote> 
<ul><li>不同协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。</li><li>应用层数据通过协议栈发到网络上，每层协议都要加上一个数据首部（header），称为封装（Encapsulation）。</li><li>首部信息中包含了一些类似于首部有多长，载荷（payload）有多长，上层协议是什么等信息。</li><li>数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，根据首部中的“上层协议字段”将数据交给对应的上层协议处理。</li></ul> 
<p>下图为数据封装的过程：</p> 
<p><img alt="" height="599" src="https://images2.imgbox.com/34/e4/pAlUz4iL_o.png" width="1062"></p> 
<p>下图为数据分用的过程：</p> 
<p><img alt="" height="620" src="https://images2.imgbox.com/20/3a/MYenx0nL_o.png" width="1004"><br>  </p> 
<blockquote> 
 <p>报头</p> 
</blockquote> 
<p>报头本质也是一种数据，报头一般是通过位段实现的，因此协议栈的每一层都有一个对应的位段来表示当前层的报头。</p> 
<p>数据的封装与解包：</p> 
<ul><li>数据封装，实际就是不断给数据加上各种对应的报头，这些报头里面填充的就是对应的各种协议细节。</li><li>数据解包，实际就是不断从数据中提取对应的报头，并对提取出来的报头进行数据分析。</li></ul> 
<blockquote> 
 <p>有效载荷</p> 
</blockquote> 
<p>当对端主机收到数据后，需要自底向上贯穿协议栈，依次进行数据的解包与分用。在这个解包的过程中，每一层的协议只需要提取出数据中对应的报头，然后对该报头进行分析处理，而剩下的数据则直接交付给上层就行了。</p> 
<p>因为每一层的协议实际上只关心数据中与当前层对应的报头信息，而剩下信息的具体内容根本不必关心，我们将数据中除当前层的报头以外的数据叫做“有效载荷”。</p> 
<p>需要注意的是，上层协议在数据封装时添加的报头信息，在下层协议进行数据解包时看来就是有效载荷。比如数据封装时应用层添加的报头信息，在对端主机进行数据解包时，在对端主机的传输层、网络层以及链路层看来，该应用层曾经添加的报头信息就是有效载荷</p> 
<blockquote> 
 <p>报头和有效载荷的分离</p> 
</blockquote> 
<p>协议栈的每一层都要从数据中提取对应的报头信息，而要将数据中的报头提取出来，首先就需要明确报头与有效载荷之间的界限，这样才能将它们进行分离。而每一层添加报头时都是将报头添加到数据的首部的，因此我们只要知道了报头的大小，就能够讲报头和有效载荷进行分离。</p> 
<p>获取报头大小的方法通常有两种：</p> 
<ol><li>定长报头。顾名思义就是报头的大小是固定的。</li><li>自描述字段。报头当中提供了一个字段，用来表示报头的长度。</li></ol> 
<p>实际上每个协议都要提供一种方法，让我们获取到报头的大小，这样我们才能在解包时将报头与有效载荷进行分离。</p> 
<blockquote> 
 <p>局域网内传输数据时，该局域网内的所有主机都能收到</p> 
</blockquote> 
<p>在一个局域网当中，除了当前正在进行通信的A主机和B主机以外，还有其他的主机，那A主机是如何将数据成功发送给B主机的呢？</p> 
<p>实际当主机A想要发数据给主机B的时候，该局域网内的其他主机也都收到了该数据，只不过除了主机B以外，其他主机识别到该数据并不是发给自己的，此时其他主机就把收到的数据丢弃了。</p> 
<p>也就是说，在局域网（以太网）通信时，该局域网内所有的主机在底层其实都收到了任何数据，只不过经过筛选后只提交上来了发给自己的数据。</p> 
<p><img alt="" height="526" src="https://images2.imgbox.com/14/7d/2niV9NZD_o.png" width="1117"></p> 
<blockquote> 
 <p>通信碰撞 </p> 
</blockquote> 
<p>当主机A在向主机B发送数据时，其他主机彼此之间可能也正在进行通信，甚至主机A在和主机B通信的同时也在和其他主机进行通信。</p> 
<p><img alt="" height="534" src="https://images2.imgbox.com/72/74/WKJAiEte_o.png" width="1141"></p> 
<p>但同一局域网中的所有主机在通信时，使用的都是一个共同的通信信道，因此如果局域网内的多台主机同时进行通信，此时这些数据之间就可能会相互干扰。</p> 
<p>每一个局域网都可以看作是一个碰撞域，如果某个主机发送出去的数据与其他主机发送的数据之间产生了干扰，我们就称这两台主机在该碰撞域中发生了碰撞。</p> 
<p>因为发送到局域网当中的数据是所有主机都能够收到的，因此当一个主机将数据发送出去后，该主机本身也是能够收到这个数据的。当该主机收到该数据后就可以将其与之前发送出去的数据进行对比，如果发现收到的数据与之前发送出去的数据不相同，则说明在发送过程中发生了碰撞。</p> 
<p>也就是说，主机实际是能够通过某种方式，知道曾经发送出去的数据是否发生了碰撞的。</p> 
<blockquote> 
 <p>发生碰撞后是如何处理的？</p> 
</blockquote> 
<p>当一个主机发现自己发送出去的数据产生了碰撞，此时该主机就要执行“碰撞避免”算法。“碰撞避免”算法实际很简单：当一个主机发送出去的数据产生了碰撞，那么该主机可以选择等一段时间后，再重新发送该数据。这就像现实生活中的两个人同时想要说话，此时对方就都会说“你先说吧”，这实际上就是一种碰撞避免。</p> 
<blockquote> 
 <p>每个主机如何判断该数据是否是发送给自己的？</p> 
</blockquote> 
<p>在局域网中发送的数据实际叫做MAC数据帧，在这个MAC数据帧的报头当中会包含两个字段，分别叫做源MAC地址和目的MAC地址。</p> 
<p>每一台计算机都至少配有一张网卡，而每一张网卡在出厂时就已经内置了一个48位的序列号，我们将这个序列号称之为“MAC地址”，这个MAC地址是全球唯一的。</p> 
<p>在局域网中进行通信的时候，每一个主机在收到一个MAC数据帧后，都会提取该MAC数据帧的报头，找到对应的目的MAC地址与自己的MAC地址进行比对。如果该MAC地址与自己的MAC地址不匹配，则直接将该MAC数据帧丢弃，只有MAC地址匹配时，该主机才会将该数据帧的有效载荷继续向上进行交付处理。</p> 
<h3 id="%E8%B7%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1">跨网络通信</h3> 
<p>上面说的都是同一局域网内的主机之间的通信，那跨局域网的两台主机之间是如何进行通信的呢？</p> 
<p>局域网之间都是通过路由器连接起来的，因此一个路由器至少能够横跨两个局域网。而这些被路由器级联局域网都认为，该路由器就是本局域网内的一台主机，因此路由器可以和这些局域网内的任意一台主机进行直接通信。</p> 
<p>比如局域网1当中的主机A想要和局域网2当中的主机H进行通信，那么主机A可以先将数据发送给路由器，然后路由器再将数据转发给局域网2当中的主机H。</p> 
<p><img alt="" height="702" src="https://images2.imgbox.com/0d/37/ah8vEb8q_o.png" width="993"></p> 
<blockquote> 
 <p>采用不同通信标准的两个局域网内的主机通信</p> 
</blockquote> 
<p>如果路由器级联的两个局域网采用的是相同的通信标准，那么通信过程大致就是上述那样。但被路由器级联的局域网可能采用的是不同的通信标准，比如局域网1采用的是以太网，而局域网2采用的却是令牌环网。</p> 
<p>由于以太网和令牌环网是不同的通信标准，它们给数据添加的报头也是不一样的，因此令牌环网当中的主机无法对以太网当中的数据帧进行解包。</p> 
<p>这种情况实际是由路由器来处理的，路由器是工作在网络层的一个设备，我们可以认为路由器当中的协议栈是下面这样的。</p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/9f/f2/mOwRfQxH_o.png" width="717"></p> 
<p>此时当数据要从局域网1发送到局域网2时，路由器收到局域网1的数据后，会先将以太网对应的报头进行解包，然后将剩下的数据向上交付给网络层，在网络层进行一系列数据分析后，再将数据向下交付给链路层，此时在链路层当中就会给该数据添加上令牌环对应的报头信息，然后再将该数据发送到局域网2当中，此时该数据就能够在令牌环网当中传输了。</p> 
<p><img alt="" height="576" src="https://images2.imgbox.com/75/74/a5uLTWHc_o.png" width="1003"></p> 
<blockquote> 
 <p>路由器是怎么路由的？</p> 
</blockquote> 
<p>一个路由器可能会级联多个局域网，当路由器需要将一个局域网的数据转发到另一个局域网时，路由器如何知道该数据应该转发到哪一个局域网的呢？</p> 
<p>路由器其实是通过IP地址来确定数据的转发方向的，因特网上的每台计算机都有一个唯一的IP地址，而在数据向下进行封装时，在网络层封装的报头当中就会包含两个字段，分别是源IP地址和目的IP地址。</p> 
<p>当路由器需要将一个局域网的数据转发到另一个局域网时，在路由器的链路层会先将数据的在当前局域网对应的底层报头去掉，然后将剩下的数据向上交付给网络层，此时在网络层就可以获取到该数据对应的目的IP地址，然后路由器就可以根据该IP地址在路由表当中进行查找，最终就能够确认该数据应该发送到哪一个局域网。</p> 
<h2 id="%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86">网络中的地址管理</h2> 
<h3 id="IP%E5%9C%B0%E5%9D%80">IP地址</h3> 
<ul><li>IP地址是在IP协议中，用来标识网络中不同主机的地址。</li><li>对于IPv4来说，IP地址是一个4字节，32位的整数。</li><li>我们通常也使用“点分十进制”的字符串表示IP地址，例如192.168.0.1，用点分割的每一个数字表示一个字节，范围是0-255。</li></ul> 
<p>需要注意的是，IP协议有两个版本，分别是IPv4和IPv6。IPv4用32个比特位来标识IP地址，而IPv6用128个比特位来标识IP地址。</p> 
<h3 id="MAC%E5%9C%B0%E5%9D%80">MAC地址</h3> 
<p>MAC地址用来识别数据链路层中相连的节点。<br> 长度为48位，及6个字节，一般用16进制数字加上冒号的形式来表示（例如：08:00:27:03:fb:19）。<br> 在网卡出厂时就确定了，不能修改。MAC地址通常是唯一的（虚拟机中的MAC地址不是真实的MAC地址，可能会冲突，也有些网卡支持用户配置MAC地址）。<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/80b5f6f981990bcceef72dd02ca50886/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PVE GPU Pass Through（pve显卡直通）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/406c8319cdb211759a8a6e0e58dd8742/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【运维】【NFS】 频繁卡死 ｜NFSv3 迁移到 NFSv4</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>