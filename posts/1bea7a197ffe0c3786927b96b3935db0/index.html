<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从0到1实现GCN——最详细的代码实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从0到1实现GCN——最详细的代码实现" />
<meta property="og:description" content="最近论文中需要使用图卷积神经网络（GNN），看了一些关于GCN的代码，还有基于PyTorch Geometric Temporal的代码实现，在这里做一下记录。
GCN原始代码 关于GCN的原理在这里不进行过多阐述，其他文章里面解释的已经很详细了，这里就直接进入到代码的部分。GCN的公式如下：
其中为邻接矩阵；为t时刻输入的节点的特征矩阵；是近似的图卷积滤波器，其中=&#43;(是N维的单位矩阵)；是度矩阵；代表需要神经网络训练的权重矩阵；是激活函数Relu。
根据公式逐步实现GCN的代码如下：
def get_gcn_fact(adj): &#39;&#39;&#39; Function to calculate the GCN factor of a certain network snapshot 计算GCN因子(图卷积因子D^-1/2AD^-1/2)的函数 :param adj: the adjacency matrix of a specific network snapshot 特定网络快照的邻接矩阵 :return: the corresponding GCN factor 对应的GCN因子 DAD &#39;&#39;&#39; adj_ = adj &#43; np.eye(node_num, node_num) # A&#43;IN row_sum = np.array(adj_.sum(1)) # 求度矩阵D d_inv_sqrt = np.power(row_sum, -0.5).flatten() # D^-1/2 d_inv_sqrt[np.isinf(d_inv_sqrt)] = 0. # 将一些计算得到的NAN值赋0值 d_mat_inv_sqrt = np.mat(np.diag(d_inv_sqrt)) # 将D^-1/2对角化 gcn_fact = d_mat_inv_sqrt*adj_*d_mat_inv_sqrt # 计算D^-1/2AD^-1/2 return gcn_fact 这里根据输入数据代表的邻接矩阵，如果图的拓扑结构不会发生变化，那么GCN因子的值就是固定的，否则要根据时序变化分别计算其对应的GCN因子。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1bea7a197ffe0c3786927b96b3935db0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-16T11:00:47+08:00" />
<meta property="article:modified_time" content="2023-08-16T11:00:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从0到1实现GCN——最详细的代码实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>最近论文中需要使用图卷积神经网络（GNN），看了一些关于GCN的代码，还有基于PyTorch Geometric Temporal的代码实现，在这里做一下记录。</p> 
<h2>GCN原始代码</h2> 
<p>关于GCN的原理在这里不进行过多阐述，其他文章里面解释的已经很详细了，这里就直接进入到代码的部分。GCN的公式如下：</p> 
<blockquote> 
 <p class="img-center"><img alt="G C N(A, X)=\sigma\left(\widehat{D}^{-\frac{1}{2}} \hat{A} \widehat{D}^{-\frac{1}{2}} X W\right)" class="mathcode" src="https://images2.imgbox.com/97/fd/P3q9uZzm_o.png"></p> 
</blockquote> 
<p>其中<em><img alt="A" class="mathcode" src="https://images2.imgbox.com/a0/88/BU4cQPE9_o.png"></em>为邻接矩阵；<img alt="X" class="mathcode" src="https://images2.imgbox.com/98/e1/mHznJmku_o.png">为t时刻输入的节点的特征矩阵；<img alt="\widehat{D}^{-\frac{1}{2}} \hat{A} \widehat{D}^{-\frac{1}{2}}" class="mathcode" src="https://images2.imgbox.com/0f/40/PjMXCxZk_o.png">是近似的图卷积滤波器，其中<strong><em><img alt="\hat{A}" class="mathcode" src="https://images2.imgbox.com/71/b4/7ibHHztC_o.png"></em></strong><em>=<img alt="A" class="mathcode" src="https://images2.imgbox.com/76/f4/OE7qoZGR_o.png"></em>+<img alt="I_{N}" class="mathcode" src="https://images2.imgbox.com/78/18/h65dqlLq_o.png">(<img alt="I_{N}" class="mathcode" src="https://images2.imgbox.com/20/18/D5Oh4Sue_o.png">是N维的单位矩阵)；<img alt="\hat{D}" class="mathcode" src="https://images2.imgbox.com/b4/dc/avifFXVq_o.png"><span style="color:#0d0016;">是度矩阵</span>；<img alt="W" class="mathcode" src="https://images2.imgbox.com/3d/03/U1oNOYDN_o.png">代表需要神经网络训练的权重矩阵；<img alt="\sigma \left ( \cdot \right )" class="mathcode" src="https://images2.imgbox.com/77/b5/xcE8BkNI_o.png">是激活函数<em>Relu。</em></p> 
<p>根据公式逐步实现GCN的代码如下：</p> 
<pre><code class="language-python">def get_gcn_fact(adj):
    '''
    Function to calculate the GCN factor of a certain network snapshot
    计算GCN因子(图卷积因子D^-1/2AD^-1/2)的函数
    :param adj: the adjacency matrix of a specific network snapshot 特定网络快照的邻接矩阵
    :return: the corresponding GCN factor 对应的GCN因子 DAD
    '''
    adj_ = adj + np.eye(node_num, node_num) # A+IN
    row_sum = np.array(adj_.sum(1)) # 求度矩阵D 
    d_inv_sqrt = np.power(row_sum, -0.5).flatten() # D^-1/2
    d_inv_sqrt[np.isinf(d_inv_sqrt)] = 0. # 将一些计算得到的NAN值赋0值
    d_mat_inv_sqrt = np.mat(np.diag(d_inv_sqrt)) # 将D^-1/2对角化
    gcn_fact = d_mat_inv_sqrt*adj_*d_mat_inv_sqrt # 计算D^-1/2AD^-1/2

    return gcn_fact</code></pre> 
<p>这里根据输入数据<img alt="adj" class="mathcode" src="https://images2.imgbox.com/3c/a3/Hkz7FDq6_o.png">代表的邻接矩阵<em><em><img alt="A" class="mathcode" src="https://images2.imgbox.com/fc/0d/YhKb15Rg_o.png"></em></em>，如果图的拓扑结构不会发生变化，那么GCN因子的值就是固定的，否则要根据时序变化分别计算其对应的GCN因子。</p> 
<h2>基于PyTorch Geometric的GCN实现</h2> 
<p>但由于上述代码中需要对矩阵进行复杂的计算，并且大部分图数据的邻接矩阵比较稀疏，因此这种计算方法会造成内存资源的浪费，计算效率也比较低。但是幸运的是，PyTorch Geometric(PyG)中封装了大量已经编写好的图神经网络，我们只需要调库进行使用就好了（哈哈哈大家最喜欢的部分）。</p> 
<h3>PyG库介绍</h3> 
<p>PyG的下载：<a href="https://pytorch-geometric.readthedocs.io/en/latest/notes/installation.html" rel="nofollow" title="Installation — pytorch_geometric  documentation">Installation — pytorch_geometric documentation</a>里面提供了各种安装方法。</p> 
<p><img alt="" height="553" src="https://images2.imgbox.com/b8/2e/4eFUV78M_o.png" width="798"></p> 
<p> 提供的各种神经网络层：</p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/2c/59/gi56p0mV_o.png" width="371"></p> 
<p> 部分图卷积操作层：</p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/b9/5e/G94aHC0G_o.png" width="811"></p> 
<p> （哈哈哈哈哈哈因为最近一直在看GNN方面的文章，有这些库可以直接调真的是救大命了）。</p> 
<p></p> 
<h3>言归正传，根据PyG实现GCN的代码如下：</h3> 
<pre><code class="language-python">from torch_geometric.nn import GCNConv

class GCN(torch.nn.Module):
    def __init__(self, node_features, input_size, output_size):
        super(GCN, self).__init__()
        self.conv1 = GCNConv(node_features, input_size)
        self.MLP = torch.nn.Sequential(
            torch.nn.Linear(input_size, input_size // 2),
            torch.nn.ReLU(inplace=True),
            torch.nn.Linear(input_size // 2, input_size // 4),
            torch.nn.ReLU(inplace=True),
            torch.nn.Linear(input_size // 4, output_size))
        self.relu = torch.nn.ReLU()


    def forward(self, x, edge_index, edge_weight):
        '''
        GCN
        '''
        x = self.relu(self.conv1(x, edge_index))
        x = F.dropout(x, training=self.training)
        x = self.MLP(x)

        return x</code></pre> 
<p>这里面我们使用GCN对输入数据进行编码，MLP全连接层对提取到的数据进行解码，实现了一个简单的对输入数据进行特征提取的网络。</p> 
<p></p> 
<p>现有模型中，有许多模型在特征提取时对GCN的处理结果进行拼接处理的，比如：<img alt="\left ( X,GCN \right )" class="mathcode" src="https://images2.imgbox.com/3c/6b/3XsRZ0Jo_o.png">，因此对上述模型进行改进：</p> 
<pre><code class="language-python">class GCN(torch.nn.Module):
    def __init__(self, node_features, input_size, output_size):
        super(GCN, self).__init__()
        self.conv1 = GCNConv(node_features, input_size)
        self.linear = torch.nn.Linear(node_features+input_size, input_size)
        self.MLP = torch.nn.Sequential(
            torch.nn.Linear(input_size, input_size // 2),
            torch.nn.ReLU(inplace=True),
            torch.nn.Linear(input_size // 2, input_size // 4),
            torch.nn.ReLU(inplace=True),
            torch.nn.Linear(input_size // 4, output_size))
        self.relu = torch.nn.ReLU()


    def forward(self, x, edge_index, edge_weight):
        '''
        (x, GCN)
        '''
        lst = list()
        lst.append(x)

        x = self.relu(self.conv1(x, edge_index, edge_weight)) #根据数据集确定有没有edge_weight
        x = F.dropout(x, training=self.training)
        lst.append(x)

        x = torch.cat(lst, dim=1)
        # print('cat', x.shape)cat torch.Size([node_num, node_features+input_size])
        x = self.relu(self.linear(x))
        x = F.dropout(x, training=self.training)

        x = self.MLP(x)</code></pre> 
<h3>完整代码</h3> 
<p>模型中简单的随机生成了图数据，只是为了展示GCN模型在具体代码中应该如何使用。</p> 
<p>分类模型：</p> 
<pre><code class="language-python">import torch
import random
import matplotlib.pyplot as plt
from tqdm import tqdm
import numpy as np
import networkx as nx
import torch.nn.functional as F
from torch_geometric.nn import GCNConv


def create_mock_data(number_of_nodes, edge_per_node, in_channels):
    """
    Creating a mock feature matrix and edge index.
    """
    graph = nx.watts_strogatz_graph(number_of_nodes, edge_per_node, 0.5)
    edge_index = torch.LongTensor(np.array([edge for edge in graph.edges()]).T)
    X = torch.FloatTensor(np.random.uniform(-1, 1, (number_of_nodes, in_channels)))
    return X, edge_index


def create_mock_edge_weight(edge_index):
    """
    Creating a mock edge weight tensor.
    """
    return torch.FloatTensor(np.random.uniform(0, 1, (edge_index.shape[1])))

def create_mock_target(number_of_nodes, number_of_classes):
    """
    Creating a mock target vector.
    """
    return torch.LongTensor([random.randint(0, number_of_classes-1) for node in range(number_of_nodes)])


class GCN(torch.nn.Module):
    def __init__(self, node_features, input_size, num_classes):
        super(GCN, self).__init__()
        self.conv1 = GCNConv(node_features, input_size)
        self.MLP = torch.nn.Sequential(
            torch.nn.Linear(input_size, input_size // 2),
            torch.nn.ReLU(inplace=True),
            torch.nn.Linear(input_size // 2, input_size // 4),
            torch.nn.ReLU(inplace=True),
            torch.nn.Linear(input_size // 4, num_classes))
        self.relu = torch.nn.ReLU()


    def forward(self, x, edge_index, edge_weight):
        '''
        GCN
        '''
        x = self.relu(self.conv1(x, edge_index))
        x = F.dropout(x, training=self.training)
        x = self.MLP(x)

        return F.log_softmax(x, dim=1)


node_features = 100
node_count = 1000
input_size = 32
num_classes = 10
edge_per_node = 15
epochs = 200
learning_rate = 0.01
weight_decay = 5e-4

model = GCN(node_features=node_features, input_size=input_size, num_classes=num_classes)

optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate, weight_decay=weight_decay)

model.train()

loss_list = []
for epoch in tqdm(range(epochs)):
    optimizer.zero_grad()
    x, edge_index = create_mock_data(node_count, edge_per_node, node_features)
    edge_weight = create_mock_edge_weight(edge_index)
    scores = model(x, edge_index, edge_weight)
    target = create_mock_target(node_count, num_classes)
    loss = F.nll_loss(scores, target)
    loss_list.append(loss.item())
    loss.backward()
    optimizer.step()

plt.plot(loss_list)
plt.xlabel("Epoch")
plt.ylabel("MSE")
plt.title("loss")
plt.show()</code></pre> 
<p>损失函数：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/07/ab/705HvrXA_o.png"></p> 
<p> 预测模型：</p> 
<p>这里不再赘述预测模型的代码，其实预测问题和分类问题非常相像，预测模型只需要去掉模型最后的softmax函数，改变output_size就好。</p> 
<p>如果想看预测模型，或者其他图神经网络模型的欢迎大家在评论区讨论。有哪里写的不对的地方也欢迎指正！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4cc41c977f23b43fddc17650c6b9e66d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Js读取本地json文件做修改后再保存为json文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/218eeeb4f9b1d8e39dfc7d09ec48eaa7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">超详细解决pytesseract.pytesseract.TesseractNotFoundError: tesseract is not installed or it‘s not in yo...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>