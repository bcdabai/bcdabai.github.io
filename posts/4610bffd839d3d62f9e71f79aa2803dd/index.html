<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java利用RxtxComm接收串口数据 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java利用RxtxComm接收串口数据" />
<meta property="og:description" content="1.下载 地址：RXTX for Java
2.部署到Windows
下载完成后将rxtxSerial.dll文件放到java的对应目录下（如图）
然后把RXTXcomm.jar包引入到项目中或者使用maven引入都可以
本地jar包直接引入
在项目根目录下新建lib文件夹并导入RXTXcomm.jar，然后在pom中引入本地jar包即可
&lt;dependency&gt; &lt;groupId&gt;com.test&lt;/groupId&gt; &lt;artifactId&gt;rxtxcomm&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${basedir}/lib/RXTXcomm.jar&lt;/systemPath&gt; &lt;/dependency&gt; maven引入：在pom中写入如下内容即可
&lt;dependency&gt; &lt;groupId&gt;org.bidib.jbidib.org.qbang.rxtx&lt;/groupId&gt; &lt;artifactId&gt;rxtxcomm&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; 3.编码
import gnu.io.*; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Enumeration; import java.util.TooManyListenersException; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; public class SerialPortDataHandle extends Thread implements SerialPortEventListener { private static final Logger logger = LoggerFactory.getLogger(SerialPortDataHandle.class); // 通讯端口管理，控制对通信端口的访问的中心类 static CommPortIdentifier portManager; // 有效连接上的端口的枚举 static Enumeration&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4610bffd839d3d62f9e71f79aa2803dd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-11T09:27:58+08:00" />
<meta property="article:modified_time" content="2023-05-11T09:27:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java利用RxtxComm接收串口数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.下载 </p> 
<p>地址：<a href="http://fizzed.com/oss/rxtx-for-java" rel="nofollow" title="RXTX for Java">RXTX for Java</a></p> 
<p>2.部署到Windows</p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/cf/4d/Z7PujlZx_o.png" width="635"></p> 
<p>下载完成后将rxtxSerial.dll文件放到java的对应目录下（如图）</p> 
<p><img alt="" height="305" src="https://images2.imgbox.com/7a/aa/5RRTPSsC_o.png" width="782"></p> 
<p>然后把RXTXcomm.jar包引入到项目中或者使用maven引入都可以</p> 
<p>本地jar包直接引入</p> 
<p>在项目根目录下新建lib文件夹并导入RXTXcomm.jar，然后在pom中引入本地jar包即可</p> 
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;com.test&lt;/groupId&gt;
            &lt;artifactId&gt;rxtxcomm&lt;/artifactId&gt;
            &lt;version&gt;2.2&lt;/version&gt;
            &lt;scope&gt;system&lt;/scope&gt;
            &lt;systemPath&gt;${basedir}/lib/RXTXcomm.jar&lt;/systemPath&gt;
        &lt;/dependency&gt;</code></pre> 
<p>maven引入：在pom中写入如下内容即可</p> 
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.bidib.jbidib.org.qbang.rxtx&lt;/groupId&gt;
            &lt;artifactId&gt;rxtxcomm&lt;/artifactId&gt;
            &lt;version&gt;2.2&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<p>3.编码</p> 
<pre><code class="language-java">import gnu.io.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Enumeration;
import java.util.TooManyListenersException;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class SerialPortDataHandle extends Thread implements SerialPortEventListener {

    private static final Logger logger = LoggerFactory.getLogger(SerialPortDataHandle.class);

    // 通讯端口管理，控制对通信端口的访问的中心类
    static CommPortIdentifier portManager;
    // 有效连接上的端口的枚举
    static Enumeration&lt;?&gt; portList;
    // 串口输入流引用
    static InputStream inputStream;
    // 串口输出流引用
    static OutputStream outputStream;
    // 串口对象引用
    static SerialPort serialPort;
    // 堵塞队列：用来存放串口发送到服务端的数据
    private BlockingQueue&lt;String&gt; msgQueue = new LinkedBlockingQueue();
    // 线程控制标识
    private boolean flag = true;

    public void serialEvent(SerialPortEvent event) {
        switch (event.getEventType()) {
            /*
             *  SerialPortEvent.BI:/*Break interrupt,通讯中断
             *  SerialPortEvent.OE:/*Overrun error，溢位错误
             *  SerialPortEvent.FE:/*Framing error，传帧错误
             *  SerialPortEvent.PE:/*Parity error，校验错误
             *  SerialPortEvent.CD:/*Carrier detect，载波检测
             *  SerialPortEvent.CTS:/*Clear to send，清除发送
             *  SerialPortEvent.DSR:/*Data set ready，数据设备就绪
             *  SerialPortEvent.RI:/*Ring indicator，响铃指示
             *  SerialPortEvent.OUTPUT_BUFFER_EMPTY:/*Output buffer is empty，输出缓冲区清空
             */
            case SerialPortEvent.BI:
            case SerialPortEvent.OE:
            case SerialPortEvent.FE:
            case SerialPortEvent.PE:
            case SerialPortEvent.CD:
            case SerialPortEvent.CTS:
            case SerialPortEvent.DSR:
            case SerialPortEvent.RI:
            case SerialPortEvent.OUTPUT_BUFFER_EMPTY: break;
            // 当有可用数据时读取数据
            case SerialPortEvent.DATA_AVAILABLE:
                // 数据接收缓冲容器
                byte[] readBuffer = new byte[200];
                try {
                    // 存储待接收读取字节数大小
                    int numBytes = 0;
                    while (inputStream.available() &gt; 0) {
                        numBytes = inputStream.read(readBuffer);
                        if (numBytes &gt; 0) {
                            msgQueue.add(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
                                    .format(new Date()) + " 收到的串口发送数据为："+ new String(readBuffer));
                            // 数据接收缓冲容器清空初始化
                            readBuffer = new byte[200];
                        }
                    }
                } catch (IOException e) {
                    logger.error("IO异常", e);
                }
                break;
        }
    }

    public int init() {
        // 通过串口通信管理类获得当前连接上的端口列表
        //（获取一个枚举对象，该CommPortIdentifier对象包含系统中每个端口的对象集[串口、并口]）
        portList = CommPortIdentifier.getPortIdentifiers();
        while (portList.hasMoreElements()) {
            // 获取相应串口对象
            portManager = (CommPortIdentifier) portList.nextElement();
            /*
             *  判断端口类型是否为串口
             *  PORT_SERIAL = 1; 【串口】
             *  PORT_PARALLEL = 2; 【并口】
             *  PORT_I2C = 3; 【I2C】
             *  PORT_RS485 = 4; 【RS485】
             *  PORT_RAW = 5; 【RAW】
             */
            if (portManager.getPortType() == CommPortIdentifier.PORT_SERIAL) {
                logger.info("串口设备名称：" + portManager.getName());
                // 判断模拟COM4串口存在，就打开该串口
                if (portManager.getName().equals("COM4")) {
                    logger.info("测试串口设备名称：" + portManager.getName());
                    try {
                        if (serialPort==null) {
                            // 打开串口，设置名字为COM_4(自定义),延迟阻塞时等待3000毫秒（赋值给预设的串口引用）
                            serialPort = (SerialPort)portManager.open("COM4", 3000);
                            logger.info("串口设备COM4已打开");
                        }
                    } catch (PortInUseException e) {
                        logger.error("串口使用异常", e);
                        return 0;
                    }
                    // 在串口引用不为空时进行下述操作
                    if (serialPort!=null) {
                        // 1. 设置串口的输入输出流引用
                        try {
                            inputStream = serialPort.getInputStream();
                            outputStream = serialPort.getOutputStream();
                        } catch (IOException e) {
                            logger.error("串口输入输出IO异常", e);
                            return 0;
                        }
                        // 2. 设置串口监听器
                        try {
                            serialPort.addEventListener(this);
                        } catch (TooManyListenersException e) {
                            logger.error("串口监听器添加异常", e);
                            return 0;
                        }
                        // 设置监听器在有数据时通知生效
                        serialPort.notifyOnDataAvailable(true);

                        // 3. 设置串口相关读写参数
                        try {
                            // 比特率、数据位、停止位、校验位
                            serialPort.setSerialPortParams(9600,
                                    SerialPort.DATABITS_8,
                                    SerialPort.STOPBITS_1,
                                    SerialPort.PARITY_NONE);
                        } catch (UnsupportedCommOperationException e) {
                            logger.error("串口设置操作异常", e);
                            return 0;
                        }
                        return 1;
                    }
                    return 0;
                }
            }
        }
        return 0;
    }

    @Override
    public void run() {
        try {
            logger.info("串口线程已运行");
            while (flag) {
                // 如果堵塞队列中存在数据就将其输出
                if (msgQueue.size() &gt; 0) {
                    // take() 取走BlockingQueue里排在首位的对象
                    // 若BlockingQueue为空，阻断进入等待状态直到Blocking有新的对象被加入为止
                    logger.info(msgQueue.take());
                }
            }
        } catch (InterruptedException e) {
            logger.error("线程执行异常", e);
        }
    }

    public void stopGetDataBySerialPort() {
        this.flag = false;
    }

    public static void main(String[] args) {
        SerialPortDataHandle handle = new SerialPortDataHandle();
        int i = handle.init();
        if (i == 1) {
            // 线程启动
            handle.start();
        }
    }
}
</code></pre> 
<p>4.测试</p> 
<p>需要下载SerialPortUtility、vspd（Configure Virtual Serial Port Driver）</p> 
<p>先在vspd中新增COMM4和COMM5端口如图，这里COMM4和COMM5是连接在一起的，也就是说如果我在COMM5发送数据后COMM4就能收到</p> 
<p><img alt="" height="396" src="https://images2.imgbox.com/c8/62/lgyuMelN_o.png" width="553"></p> 
<p>然后我们打开SerialPortUtility，然后配置串口参数如图（我选择的是COMM5），这样我们在COMM5发送消息后，COMM4应该就能收到了</p> 
<p><img alt="" height="501" src="https://images2.imgbox.com/4b/eb/gvkmDjJx_o.png" width="933"></p> 
<p>5.注意事项</p> 
<p>Java版本！Java版本！Java版本！重要的事情说三遍！</p> 
<p>我刚开始使用的是是jdk1.8.0_261，每次从接口1发送消息到接口2，服务就马上崩溃，然后报这样的错误：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/5c/d3/r7oQnVG8_o.jpg" width="713"></p> 
<p>网上查了各种文章无果，然后我看了下报错貌似和Java的JDK版本有关，所以我尝试着修改成较低版本的JDK：jdk1.8.0_31，果然好使了</p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/d9/75/iMjfis2i_o.png" width="880"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54804dae50a239c3bd86a0507fcf18eb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">记一次wvp&#43;zlm踩坑记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c06fb2f13f7c6d3b3425c8577a626022/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决VS Code的高cpu占用率问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>