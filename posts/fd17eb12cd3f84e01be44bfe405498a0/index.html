<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python - 深夜数据结构与算法之 高级字符串 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python - 深夜数据结构与算法之 高级字符串" />
<meta property="og:description" content="目录
一.引言
二.经典算法实战
1.Longest-Common-Sub-Seq [1143]
2.Edit-Distance [72]
3.Longest-Palindromic-Str [5]
4.Distinct-Sub-Seq [115]
5.Regular-Exp-Match [10]
三.总结
一.引言 上一节介绍了字符串的基本操作，本文介绍字符串更复杂的一些操作，主要设计动态规划与字符串扩展。
二.经典算法实战 1.Longest-Common-Sub-Seq [1143] 最长公共子序列: https://leetcode.cn/problems/longest-common-subsequence/description/
◆ 题目分析
状态转移方程:
根据二维 DP Table 理解转移方程更轻松些。
◆ 动态规划
class Solution(object): def longestCommonSubsequence(self, text1, text2): &#34;&#34;&#34; :type text1: str :type text2: str :rtype: int &#34;&#34;&#34; m, n = len(text1), len(text2) dp = [[0] * (n &#43; 1) for _ in range(m &#43; 1)] for i in range(1, m &#43; 1): c1 = text1[i - 1] for j in range(1, n &#43; 1): c2 = text2[j - 1] if c1 == c2: dp[i][j] = dp[i-1][j-1] &#43; 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[-1][-1] 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fd17eb12cd3f84e01be44bfe405498a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T08:00:00+08:00" />
<meta property="article:modified_time" content="2024-01-22T08:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python - 深夜数据结构与算法之 高级字符串</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="475" src="https://images2.imgbox.com/70/fd/UuAXK9BF_o.png" width="700"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E5%BC%95%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%BC%95%E8%A8%80" rel="nofollow">一.引言</a></p> 
<p id="%E4%BA%8C.%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98" rel="nofollow">二.经典算法实战</a></p> 
<p id="1.Longest-Common-Sub-Seq%20%5B1143%5D-toc" style="margin-left:40px;"><a href="#1.Longest-Common-Sub-Seq%20%5B1143%5D" rel="nofollow">1.Longest-Common-Sub-Seq [1143]</a></p> 
<p id="2.Edit-Distance%20%5B72%5D-toc" style="margin-left:40px;"><a href="#2.Edit-Distance%20%5B72%5D" rel="nofollow">2.Edit-Distance [72]</a></p> 
<p id="3.Longest-Palindromic-Str%20%5B5%5D-toc" style="margin-left:40px;"><a href="#3.Longest-Palindromic-Str%20%5B5%5D" rel="nofollow">3.Longest-Palindromic-Str [5]</a></p> 
<p id="4.Distinct-Sub-Seq%20%5B115%5D-toc" style="margin-left:40px;"><a href="#4.Distinct-Sub-Seq%20%5B115%5D" rel="nofollow">4.Distinct-Sub-Seq [115]</a></p> 
<p id="5.Regular-Exp-Match%20%5B10%5D-toc" style="margin-left:40px;"><a href="#5.Regular-Exp-Match%20%5B10%5D" rel="nofollow">5.Regular-Exp-Match [10]</a></p> 
<p id="%E4%B8%89.%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E6%80%BB%E7%BB%93" rel="nofollow">三.总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E5%BC%95%E8%A8%80">一.引言</h2> 
<p>上一节介绍了字符串的基本操作，本文介绍字符串更复杂的一些操作，主要设计动态规划与字符串扩展。</p> 
<p></p> 
<h2 id="%E4%BA%8C.%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98">二.经典算法实战</h2> 
<h3 id="1.Longest-Common-Sub-Seq%20%5B1143%5D">1.Longest-Common-Sub-Seq [1143]</h3> 
<p>最长公共子序列: <a class="link-info" href="https://leetcode.cn/problems/longest-common-subsequence/description/" rel="nofollow" title="https://leetcode.cn/problems/longest-common-subsequence/description/">https://leetcode.cn/problems/longest-common-subsequence/description/</a></p> 
<p class="img-center"><img alt="" height="412" src="https://images2.imgbox.com/d8/50/osW0Jhup_o.png" width="700"></p> 
<p><strong>◆ 题目分析</strong></p> 
<p class="img-center"><img alt="" height="426" src="https://images2.imgbox.com/9c/ad/9U2X5Ihp_o.png" width="450"></p> 
<p>状态转移方程:</p> 
<p class="img-center"><img alt="" height="73" src="https://images2.imgbox.com/fb/46/ikESy2at_o.png" width="450"></p> 
<p>根据二维 DP Table 理解转移方程更轻松些。</p> 
<p></p> 
<p><strong>◆ 动态规划</strong></p> 
<pre><code class="language-python">class Solution(object):
    def longestCommonSubsequence(self, text1, text2):
        """
        :type text1: str
        :type text2: str
        :rtype: int
        """
    
        m, n = len(text1), len(text2)

        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            c1 = text1[i - 1]
            for j in range(1, n + 1):
                c2 = text2[j - 1]
                if c1 == c2:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        return dp[-1][-1]
</code></pre> 
<p class="img-center"><img alt="" height="210" src="https://images2.imgbox.com/46/00/9vWe7sw1_o.png" width="450"></p> 
<p></p> 
<h3 id="2.Edit-Distance%20%5B72%5D">2.Edit-Distance [72]</h3> 
<p>编辑距离: <a class="link-info" href="https://leetcode.cn/problems/edit-distance/" rel="nofollow" title="https://leetcode.cn/problems/edit-distance/">https://leetcode.cn/problems/edit-distance/</a></p> 
<p class="img-center"><img alt="" height="407" src="https://images2.imgbox.com/8e/7f/wGy5WOpy_o.png" width="700"></p> 
<p><strong>◆ 题目分析</strong></p> 
<p class="img-center"><img alt="" height="219" src="https://images2.imgbox.com/1f/26/XQimPEEv_o.png" width="450"></p> 
<p>和上一题的 DP Table 类似，但是初始的边界条件有所不同，其次需要注意转换时需要计算三个位置的最小值。</p> 
<p></p> 
<p><strong>◆ 动态规划</strong></p> 
<pre><code class="language-python">class Solution(object):
    def minDistance(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """
        # w[i] = w[j] -&gt; w[i][j] = w[i-1]w[j-1]
        # w[i] != w[j] -&gt; w[i][j] = min(w[i-1][j-1] + 1, w[i-1][j] + 1, w[i][j-1] +1)

        M, N = len(word1), len(word2)

        # 状态空间
        dp = [[0] * (N + 1) for _ in range(M + 1)]

        # word1="" word2="xxxx" 则 word1 -&gt; word2 需要变换4次, 同理可得另一种情况
        for i in range(M + 1):
            dp[i][0] = i
        for j in range(N + 1):
            dp[0][j] = j

        for i in range(1, M + 1):
            c1 = word1[i-1]
            for j in range(1, N + 1):
                c2 = word2[j-1]
                # 此时字符相等，该位置无需变换，所以二者相同
                if c1 == c2:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    # 此时字符不同，需要看三种方法那种转换最小
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1

        return dp[-1][-1]</code></pre> 
<p class="img-center"><img alt="" height="210" src="https://images2.imgbox.com/57/ee/LHruaM5y_o.png" width="450"></p> 
<p></p> 
<h3 id="3.Longest-Palindromic-Str%20%5B5%5D">3.Longest-Palindromic-Str [5]</h3> 
<p>最长回文子串: <a class="link-info" href="https://leetcode.cn/problems/longest-palindromic-substring/description/" rel="nofollow" title="https://leetcode.cn/problems/longest-palindromic-substring/description/">https://leetcode.cn/problems/longest-palindromic-substring/description/</a> </p> 
<p class="img-center"><img alt="" height="372" src="https://images2.imgbox.com/db/7b/sbP24rFR_o.png" width="700"></p> 
<p><strong>◆ 题目分析</strong></p> 
<p>首先明确回文串的定义，同时明确如果 i 或者 ii 为回文串时，我们可以向左右两边扩散，如果相同即为回文串。</p> 
<p></p> 
<p><strong>◆ 中心扩散</strong></p> 
<pre><code class="language-python">class Solution(object):

    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """

        # 中心扩散
        def palindrome(s, st, end):
            # 边界合法且左右相等则向两边扩散
            while st &gt;= 0 and end &lt; len(s) and s[st] == s[end]:
                st -= 1
                end += 1
            
            # 我们需要 st-end 最后多加减了一次实际是 st-1 end+1，所以需要回补
            return s[st+1: end]

        res = ""

        for i in range(len(s)):

            sub1 = palindrome(s, i, i)
            sub2 = palindrome(s, i, i + 1)

            if len(sub1) &gt; len(res):
                res = sub1
            if len(sub2) &gt; len(res):
                res = sub2
        
        return res

</code></pre> 
<p class="img-center"><img alt="" height="207" src="https://images2.imgbox.com/e4/2a/TQpAxc7B_o.png" width="450"></p> 
<p></p> 
<h3 id="4.Distinct-Sub-Seq%20%5B115%5D" style="background-color:transparent;">4.Distinct-Sub-Seq [115]</h3> 
<p>不同子序列: <a class="link-info" href="https://leetcode.cn/problems/distinct-subsequences/solutions/661616/dai-ma-sui-xiang-lu-115-bu-tong-de-zi-xu-q6uq/" rel="nofollow" title="https://leetcode.cn/problems/distinct-subsequences">https://leetcode.cn/problems/distinct-subsequences</a></p> 
<p class="img-center"><img alt="" height="298" src="https://images2.imgbox.com/93/0b/rpTzdllF_o.png" width="700"></p> 
<p><strong>◆ 题目分析</strong></p> 
<p>- 确定 DP 定义: </p> 
<p>dp[i][j]：以 i-1 为结尾的 s 子序列中出现以 j-1 为结尾的 t 的个数为 dp[i][j]。</p> 
<p>- 确定递推公式:</p> 
<p>s[i-1] == t[j-1] - 此时 dp[i][j] 可以不考虑这两个位置，所以复用 dp[i-1][j-1]；当然也可以考虑 dp[i-1][j] 的情况，即 s[i-1] 结尾子序列中出现以 j 结尾的 t 的个数，因为我们计算的是 s 中有多少个 t，不是 t 中有多少个 s，</p> 
<p class="img-center"><img alt="" height="348" src="https://images2.imgbox.com/5d/21/05bazLoN_o.png" width="350"></p> 
<p>- 初始状态</p> 
<p>dp[i][0] 表示：以 i-1为结尾的 s 可以随便删除元素，出现空字符串的个数，所以 dp[i][0] = 1</p> 
<p>dp[0][j] 表示：空字符串 s 可以随便删除元素，出现以 j-1 为结尾的字符串 t 的个数，dp[0][j] = 0</p> 
<p>dp[0][0]: dp[0][0] 应该是 1，空字符串 s，可以删除 0 个元素，变成空字符串 t。</p> 
<p></p> 
<p><strong>◆ 动态规划</strong></p> 
<pre><code class="language-python">class Solution:
    def numDistinct(self, s, t):
        m, n = len(s), len(t)

        dp = [[0]*(n+1) for _ in range(m+1)]

        for i in range(m+1):
            dp[i][0] = 1
        for j in range(1, n+1):
            dp[0][j] = 0
        
        for i in range(1, m+1):
            for j in range(1, n+1):
                if s[i-1] == t[j-1]:
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j]
        
        return dp[-1][-1]</code></pre> 
<p class="img-center"><img alt="" height="210" src="https://images2.imgbox.com/28/f6/zyNQ9m81_o.png" width="450"></p> 
<p></p> 
<h3 id="5.Regular-Exp-Match%20%5B10%5D">5.Regular-Exp-Match [10]</h3> 
<p>正则匹配: <a class="link-info" href="https://leetcode.cn/problems/regular-expression-matching/" rel="nofollow" title="https://leetcode.cn/problems/regular-expression-matching/">https://leetcode.cn/problems/regular-expression-matching/</a></p> 
<p class="img-center"><img alt="" height="403" src="https://images2.imgbox.com/9a/ea/EpdaFlVw_o.png" width="700"></p> 
<p><strong>◆ 题目分析</strong></p> 
<p>首先判断第一个字符是否相同:</p> 
<p><strong>- 此时要么 s[0] = p[0] 或者 s[0] 随意 且 p[0] = "."</strong></p> 
<p>如果第一个字符相同，则进行推进，分多种情况:</p> 
<p>- 如果此时 p 长度大于 2 且第二位 为 "*"，则进入 "x*" 的匹配逻辑:</p> 
<p><strong>- 不需要 x* 匹配，默认 x 为 0 位，则直接忽略 2 位 p -&gt; s 不变，p 推进两位 p[:2]</strong></p> 
<p><strong>- x* 匹配了一个，接着匹配 x，则 s 推进1为 s[1:]，p 不动，因为还在匹配 x</strong></p> 
<p><strong>- p 非 "x*" 的状态，则判断第一位是否匹配，匹配后 s、p 同步推进 [1:]</strong></p> 
<p></p> 
<p><strong>◆ 递归实现</strong></p> 
<pre><code class="language-python">class Solution(object):
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """

        # 模式为空时 只能匹配空串
        if len(p) == 0:
            return len(s) == 0

        # s 第一个字符与 p第一个字符相等或者 p 第一个字符为 "."
        firstMatch = len(s) &gt;= 1 and (s[0] == p[0] or p[0] == '.')
 
        if len(p) &gt;= 2 and p[1] == '*':
            # 0 * Char 的忽略情况 与 消除一个前面的字符继续保留该通配符
            return self.isMatch(s, p[2:]) or (firstMatch and self.isMatch(s[1:], p))
        
        # 硬匹配后同步推进
        return firstMatch and self.isMatch(s[1:], p[1:])</code></pre> 
<p>超时了，因为第二步 "x*" 会出现重复多次的情况。</p> 
<p class="img-center"><img alt="" height="140" src="https://images2.imgbox.com/0d/26/QvgFoIf2_o.png" width="450"></p> 
<p></p> 
<p><strong>◆ 递归 + Cache</strong></p> 
<pre><code class="language-python">class Solution(object):

    def __init__(self):
        self.cache = {}

    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """

        def DFS(i, j):

            if (i, j) in self.cache:
                return self.cache[(i, j)]
            # 模式为空时 只能匹配空串
            # if len(p) == 0:
            #   return len(s) == 0
            if j == len(p):
                return i == len(s)

            # # s 第一个字符与 p第一个字符相等或者 p 第一个字符为 "."
            # firstMatch = len(s) &gt;= 1 and (s[0] == p[0] or p[0] == '.')
            firstMatch = i &lt; len(s) and (s[i] == p[j] or p[j] == ".")
 
            # if len(p) &gt;= 2 and p[1] == '*':
            if j + 1 &lt; len(p) and p[j+1] == "*":
                # 0 * Char 的忽略情况 与 消除一个前面的字符继续保留该通配符
                # self.isMatch(s, p[2:]) or (firstMatch and self.isMatch(s[1:], p))
                re = DFS(i, j+2) or (firstMatch and DFS(i+1, j))
                self.cache[(i, j)] = re
                return re

            # 硬匹配后同步推进
            # return firstMatch and self.isMatch(s[1:], p[1:])
            re = firstMatch and DFS(i+1, j+1)
            self.cache[(i, j)] = re
            return re
        
        return DFS(0, 0)</code></pre> 
<p>把上面的代码转换为 DFS 并添加 cache，大家可以对照着之前的代码转换下。</p> 
<p class="img-center"><img alt="" height="212" src="https://images2.imgbox.com/6b/c6/wd8KX43s_o.png" width="450"></p> 
<p></p> 
<h2 id="%E4%B8%89.%E6%80%BB%E7%BB%93">三.总结</h2> 
<p>高级字符串的题目一般需要用到动态规划的方法，我们可以构建 DP Table，dp[i][j] 转移需要左上的三个位置的信息，根据题目的不同，做相应的取舍。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/965bff05b0b0da8140f6aa2164b7a673/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Sqoop与Kafka的集成：实时数据导入</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a78d9ad56e43f3358e0b4888966a9839/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python - 深夜数据结构与算法之 字符串常规操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>