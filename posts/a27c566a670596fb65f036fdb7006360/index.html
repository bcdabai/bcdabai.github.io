<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的构造方法和方法重载 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中的构造方法和方法重载" />
<meta property="og:description" content="一、构造方法 定义：用来创建对象的方法（实例化对象的方法）
作用：创建对象过程中对成员变量进行初始化
分类：无参构造方法 &amp; 有参构造方法
格式：
public class 类名 {
修饰符 类名 (【参数列表】){
方法体
}
}
特点：
（1）方法名和类名相同，采用大驼峰命名法。
（2）无返回值（不用写void）
（3）每创建一个类，系统自动为这个类添加一个无参构造方法（默认存在）。
（4）通过无参构造方法创建对象，没有给对象的属性赋值，那么对象的属性值全部为默认值
（5）当你在类中添加了其它的构造方法后，默认的无参构造方法会被覆盖，如果你还想使用无参构造方法，需要手动添加
二、this关键字 语法知识：
（1）this修饰的变量用于指代成员变量
（2）方法被哪个对象调用，this就指代哪个对象
（3）this关键字调用方法时，this关键字调用方法的语句必须放在第一行
（4）方法的形参如果没有和成员变量重名，不带this关键字修饰的变量指的是成员变量
（5）方法的形参如果和成员变量重名，不带this关键字修饰的变量指的是形参而不是成员变量。
作用：
（1）this关键字可以调用成员方法。
（2）this关键字用于指代当前对象，所以this关键字可以调用属性。
（3）this关键字解决了成员变量和局部变量的名称冲突问题，防止成员变量名被局部变量名隐藏。
（4）this关键字可以调用构造方法：
1.在构造方法中使用this关键字调用其他构造方法时，不能在成员方法中使用。
2.在构造方法中使用this关键字调用其他构造方法，this关键字调用构造方法的语句必须是该方法的第一条执行语句，且只能出现一次。
注意： 不能在一个类的两个构造方法中使用this互调。
范例代码
package test; public class Person { public String name; public String gender; public int age; //无参构造方法 public Person() { System.out.println(&#34;我是无参构造方法&#34;); } //有参构造方法 public Person(String name, String gender, int age) { //调用无参构造方法，必须放在第一行 this(); //调用属性 this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a27c566a670596fb65f036fdb7006360/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-06T14:38:01+08:00" />
<meta property="article:modified_time" content="2022-10-06T14:38:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的构造方法和方法重载</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、构造方法</h3> 
<blockquote> 
 <p><strong>定义：用来创建对象的方法（实例化对象的方法）</strong></p> 
 <p><strong>作用：创建对象过程中对成员变量进行初始化</strong></p> 
 <p><strong>分类：无参构造方法 &amp; 有参构造方法</strong></p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p><strong>格式：</strong></p> 
 <p><strong>public  class  类名 {<!-- --></strong></p> 
 <p></p> 
 <p><strong>             修饰符 类名 (【参数列表】){<!-- --></strong></p> 
 <p></p> 
 <p><strong>                        方法体</strong></p> 
 <p><strong>        }</strong></p> 
 <p></p> 
 <p><strong>}</strong></p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p><strong>特点：</strong></p> 
 <p><strong>（1）方法名和类名相同，采用大驼峰命名法。</strong></p> 
 <p><strong>（2）无返回值（不用写void）</strong></p> 
 <p><strong>（3）每创建一个类，系统自动为这个类添加一个无参构造方法（默认存在）。</strong></p> 
 <p><strong>（4）通过无参构造方法创建对象，没有给对象的属性赋值，那么对象的属性值全部为默认值</strong></p> 
 <p><strong>（5）当你在类中添加了其它的构造方法后，默认的无参构造方法会被覆盖，如果你还想使用无参构造方法，需要手动添加</strong></p> 
</blockquote> 
<p></p> 
<p></p> 
<h3>二、this关键字</h3> 
<blockquote> 
 <p><strong>语法知识：</strong></p> 
 <p><strong>（1）this修饰的变量用于指代成员变量</strong></p> 
 <p><strong>（2）方法被哪个对象调用，this就指代哪个对象</strong></p> 
 <p><strong>（3）this关键字调用方法时，this关键字调用方法的语句必须放在第一行</strong></p> 
 <p><strong>（4）方法的形参如果没有和成员变量重名，不带this关键字修饰的变量指的是成员变量</strong></p> 
 <p><strong>（5）方法的形参如果和成员变量重名，不带this关键字修饰的变量指的是形参而不是成员变量。</strong></p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p><strong>作用：</strong></p> 
 <p><strong>（1）this关键字可以调用成员方法。</strong></p> 
 <p><strong>（2）this关键字用于指代当前对象，所以this关键字可以调用属性。</strong></p> 
 <p><strong>（3）this关键字解决了成员变量和局部变量的名称冲突问题，防止成员变量名被局部变量名隐藏。</strong></p> 
 <p><strong>（4）this关键字可以调用构造方法：</strong></p> 
 <p><strong>        1.在构造方法中使用this关键字调用其他构造方法时，不能在成员方法中使用。</strong></p> 
 <p><strong>        2.在构造方法中使用this关键字调用其他构造方法，this关键字调用构造方法的语句必须是该方法的第一条执行语句，且只能出现一次。</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>注意： 不能在一个类的两个构造方法中使用this互调。</strong></p> 
</blockquote> 
<p></p> 
<p><strong>范例代码</strong></p> 
<pre><code class="language-java">package test;

public class Person {
	public String name;
	public String gender;
	public int age;
	
	//无参构造方法
	public Person() {
		System.out.println("我是无参构造方法");
	}
	
	//有参构造方法
	public Person(String name, String gender, int age) {
		//调用无参构造方法，必须放在第一行
		this();  
		//调用属性
		this.name = name;
		this.gender = gender;
		this.age = age;
		System.out.println("姓名："+name+" "+"性别："+gender+" "+"年龄："+age);
		System.out.println("我是有参构造方法");
	}

}
</code></pre> 
<pre><code class="language-java">//测试类
package test;

public class PersonTest {

	public static void main(String[] args) {
		
		//创建对象
		Person person = new Person("张三", "男", 25);     //实例化对象
		

	}

}</code></pre> 
<p></p> 
<h3><strong>三、方法重载</strong></h3> 
<blockquote> 
 <p><strong>定义：在同一个类中，一组方法名相同，参数列表不同，就构成方法重载</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>特点：<br>         （1）在同一个类中<br>         （2）方法名相同<br>         （3）参数列表不同（参数个数、参数顺序、参数类型）<br>         （4）与访问权限修饰符和返回值类型无关</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>优点：</strong></p> 
 <p><strong>      方法重载其实是对原有方法的一种升级，可以根据参数的不同，采用不同的实现方法，而且不需要编写多个名称，简化了类调用方法的代码</strong></p> 
</blockquote> 
<p></p> 
<p> <strong>范例代码：</strong></p> 
<pre><code class="language-java">package homework;

public class Demo {
	
	//定义两个int类型数据相加的方法
	public int sum(int a,int b){
		return a+b;
		
	}
	
	
	//定义两个double类型数据相加的方法
	public double sum(double a,double b){
		return a+b;
		
	}
	
	//定义两个double类型数据相加的方法
	public int sum(int a,int b,int c){
		return a+b+c;
		
	}
	
	//定义三个double类型数据相加的方法
	public double sum(double a,double b,double c){
		return a+b+c;
		
	}
	/*方法重载特点：
        （1）在同一个类中
        （2）方法名相同
        （3）参数列表不同（参数个数、参数类型）
        （4）与访问权限修饰符和返回值类型无关
	 * 
	 */
	
}
</code></pre> 
<p></p> 
<pre><code class="language-java">//测试类
package homework;

public class DemoTest {

	public static void main(String[] args) {
		Demo demo = new Demo();
		
		//两个int类型的数据相加
		int result1 = demo.sum(10, 20);
		System.out.println("两个int类型的数据相加和为："+result1);
		
		//两个double类型的数据相加
		double result2 = demo.sum(10, 20);
		System.out.println("两个double类型的数据相加和为："+result2);
		
		//三个int类型的数据相加
		int result3 = demo.sum(10, 20,30);
		System.out.println("三个int类型的数据相加和为："+result3);
		
		//三个double类型的数据相加
		double result4 = demo.sum(10, 20,30);
		System.out.println("三个double类型的数据相加和为："+result4);
		
		
	}

}
</code></pre> 
<h3><strong>四、static关键字</strong></h3> 
<h4><strong>1.静态变量</strong></h4> 
<blockquote> 
 <p><strong>静态变量：static关键字修饰的成员变量</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>实例变量（非静态变量）：没有static关键字修饰的变量</strong> </p> 
</blockquote> 
<blockquote> 
 <p><strong>特点：</strong></p> 
 <p><strong>        （1）静态变量被该类所有对象共享</strong></p> 
 <p><strong>        （2）static关键字修饰的属性，属于类，不属于对象</strong></p> 
 <p><strong>        （3）静态变量会随着类的加载而加载，而优先于对象出现</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>注意：static只能修饰成员变量，不能修饰局部变量</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>调用方式：</strong></p> 
 <p><strong>        1.类名调用（推荐）</strong></p> 
 <p><strong>                格式：类名.成员变量名</strong></p> 
 <p><strong>         2.对象名调用</strong></p> 
 <p><strong>                格式：对象名.成员变量名</strong></p> 
</blockquote> 
<p>            </p> 
<p><strong>范例代码：</strong></p> 
<pre><code class="language-java">package test;

public class Student {
	//成员变量
	private String name;
	private String gender;
	private int age;
	public static String schoolName;
	//创建无参构造方法
	public Student() {
		super();
	}
	//创建有参构造方法
	public Student(String name, String gender, int age) {
		super();
		this.name = name;
		this.gender = gender;
		this.age = age;
	}
	//创建get方法和set方法
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getGender() {
		return gender;
	}
	public void setGender(String gender) {
		this.gender = gender;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
	//成员方法
	public void method() {
		System.out.println("姓名："+name+","+"性别："+gender+","+"年龄："+age+","+
"就读于"+schoolName);
	}

}</code></pre> 
<pre><code class="language-java">//测试类
package test;

public class StudentbtTest {

	public static void main(String[] args) {

        //静态变量赋值
        Student.method();          //通过类名调用静态变量并赋值

		//创建第一个对象
		Student st1 = new Student();
		st1.setName("张三");
		st1.setGender("男");
		st1.setAge(21);
		
        //创建第二个对象
		Student st2 = new Student();
		st1.setName("李四");
		st1.setGender("男");
		st1.setAge(20);
		

	}

}

/*
运行结果：

姓名：张三,性别：男,年龄：21,就读于清华大学
姓名：李四,性别：男,年龄：22,就读于清华大学


结果分析：

    通过结果可以看出使用类名调用静态变量scoolName并赋值，对象st1和对象st2都显示出了
清华大学，从中可以得出static关键字能实现共享的特点

*/</code></pre> 
<p></p> 
<h4>2.静态方法</h4> 
<blockquote> 
 <p><strong>静态方法：static关键字修饰的成员方法</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>实例方法（非静态方法）：没有static关键字修饰的方法</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>调用方式：</strong></p> 
 <p><strong>1.类名调用</strong></p> 
 <p><strong>        格式：类名.成员方法名</strong></p> 
 <p><strong>2.对象名调用</strong></p> 
 <p><strong>        格式：对象名.成员方法名</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>特点：</strong></p> 
 <p><strong>（1）静态方法里不能使用this关键字</strong></p> 
 <p><strong>（2）静态方法只能调用静态方法和静态变量，不能调用非静态的方法和变量</strong></p> 
 <p><strong>（3）非静态方法可以调用非静态的成员方法和成员变量，也可以调用静态方法和静态变量</strong></p> 
</blockquote> 
<p></p> 
<pre><code class="language-java">package homework;

public class Person {
	String name;
	String gender;
	int age;
	
	/*非静态成员方法的形参中都隐藏一个this关键字,这个this不能在调用方法时手动赋值，
	 * 它是调用方法的时候，虚拟机给这个this赋值，就是谁调用当前方法，那么this就表示谁的地址值
	 * this表示当前方法调用者的地址值，也表示当前调用对象
	 */
	//成员方法
	public void method(Person this) {     //方法的形参中含有隐藏的关键字
		System.out.println("this:"+this); //打印方法调用者的地址值
		System.out.println("我是非静态方法");
		//谁调用method方法，this就指的时谁
		System.out.println("姓名："+this.name+","+"性别："+this.gender+","+"年龄："+this.age);
        way();//非静态方法可以调用静态
		
	}
	
	//静态方法
	public static void way() {        //静态方法形参中无隐藏的this关键字
		System.out.println("我是静态方法");
		
	}

}
</code></pre> 
<pre><code class="language-java">//测试类
package homework;

public class PersonTest {

	public static void main(String[] args) {
		//创建对象
		Person person1 = new Person();
		//调用非静态方法
		person1.method();//peson1调用method方法,method方法形参中的this指的就是peson1
		System.out.println("person1:"+ person1); //输出对象person1的地址值
		
		System.out.println("-------------------------------------------");
		
		//创建对象
		Person person2 = new Person();
		//调用非静态方法
		person2.method();//peson2调用method方法,method方法形参中的this指的就是peson2
		System.out.println("person2:"+ person2);//输出对象person2的地址值
		
		System.out.println("-------------------------------------------");
		
		Person.way(); //类名调用静态方法
		person1.way();//对象名调用静态方法
		
		
	}

}</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/19273a4842a41f7fdbfd17a827cee81b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu系统USB权限设置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d6ef5ef0cd78bd9441b6c44ee217dfc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">信息学奥赛一本通（C&#43;&#43;版）题解目录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>