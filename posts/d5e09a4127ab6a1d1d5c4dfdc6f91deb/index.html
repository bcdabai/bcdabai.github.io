<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一篇大数据调优 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一篇大数据调优" />
<meta property="og:description" content="一、flink flink官网
1、Flink 是如何支持批流一体的？ Flink 通过一个底层引擎同时支持流处理和批处理.
1.检查点机制和状态机制：用于实现容错、有状态的处理; 2.水印机制：用于实现事件时钟; 3.窗口和触发器：用于限制计算范围，并定义呈现结果的时间
同一个流处理引擎之上，Flink 还存在另一套机制，用于实现高效的批处理。 1.用于调度和恢复的回溯法：由 Microsoft Dryad 引入，现在几乎用于所有批处理器; 2.用于散列和排序的特殊内存数据结构：可以在需要时，将一部分数据从内存溢出到硬盘上; 3.优化器：尽可能地缩短生成结果的时间。
2、Flink 是如何做容错的？ Flink 实现容错主要靠强大的 CheckPoint 机制和 State 机制。
3、Flink 分布式快照的原理是什么？ 1.barrier 机制
4、Flink 是如何保证 Exactly-once 语义的？ 1.barrier 机制
通过 Flink 的 TwoPhaseCommitSinkFunction 两阶段提交协议能支持端到端（KafkaSource， KafkaSink）的 Exactly-Once 语义。
5、Flink 中的 Window 出现了数据倾斜，你有什么解决办法？ 1、进入窗口进行预聚合
2、重新设计窗口聚合的key
6、Flink 中在使用聚合函数 GroupBy、Distinct、KeyBy 等函数时出现数据热点该如何解决？ （1）在业务上规避这类问题
2、热key拆分
3、（3）参数设置 Flink 1.9.0 SQL(Blink Planner) 性能优化中一项重要的改进就是升级了微批模型，即 MiniBatch。原理是缓存一定的数据后再触发处理，以减少对 State 的访问，从而提升吞吐和 减少数据的输出量。
7、Flink 任务延迟高，想解决这个问题，你会如何入手？ 1、后台看哪个task出现了反压
2、手段是资源调优和算子调优。 资源调优即是对作业中的 Operator 的并发数（parallelism）、CPU（core）、堆内存 （heap_memory）等参数进行调优。 作业参数调优包括：并行度的设置，State 的设置，checkpoint 的设置。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d5e09a4127ab6a1d1d5c4dfdc6f91deb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-27T08:59:59+08:00" />
<meta property="article:modified_time" content="2022-07-27T08:59:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一篇大数据调优</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<h2>一、flink</h2> 
<p><a href="https://flink.apache.org/" rel="nofollow" title="flink官网">flink官网</a></p> 
<h3>1、Flink 是如何支持批流一体的？</h3> 
<p>Flink 通过一个底层引擎同时支持流处理和批处理.</p> 
<p>1.检查点机制和状态机制：用于实现容错、有状态的处理; 2.水印机制：用于实现事件时钟; 3.窗口和触发器：用于限制计算范围，并定义呈现结果的时间</p> 
<p>同一个流处理引擎之上，Flink 还存在另一套机制，用于实现高效的批处理。 1.用于调度和恢复的回溯法：由 Microsoft Dryad 引入，现在几乎用于所有批处理器; 2.用于散列和排序的特殊内存数据结构：可以在需要时，将一部分数据从内存溢出到硬盘上; 3.优化器：尽可能地缩短生成结果的时间。</p> 
<h3>2、Flink 是如何做容错的？</h3> 
<p>Flink 实现容错主要靠强大的 CheckPoint 机制和 State 机制。</p> 
<h3>3、Flink 分布式快照的原理是什么？</h3> 
<p>1.barrier 机制</p> 
<h3>4、Flink 是如何保证 Exactly-once 语义的？</h3> 
<p>1.barrier 机制</p> 
<ol><li> <p>通过 Flink 的 TwoPhaseCommitSinkFunction 两阶段提交协议能支持端到端（KafkaSource， KafkaSink）的 Exactly-Once 语义。</p> </li></ol> 
<h3>5、Flink 中的 Window 出现了数据倾斜，你有什么解决办法？</h3> 
<p>1、进入窗口进行预聚合</p> 
<p>2、重新设计窗口聚合的key</p> 
<h3>6、Flink 中在使用聚合函数 GroupBy、Distinct、KeyBy 等函数时出现数据热点该如何解决？</h3> 
<p>（1）在业务上规避这类问题</p> 
<p>2、热key拆分</p> 
<p>3、（3）参数设置 Flink 1.9.0 SQL(Blink Planner) 性能优化中一项重要的改进就是升级了微批模型，即 MiniBatch。原理是缓存一定的数据后再触发处理，以减少对 State 的访问，从而提升吞吐和 减少数据的输出量。</p> 
<h3>7、Flink 任务延迟高，想解决这个问题，你会如何入手？</h3> 
<p>1、后台看哪个task出现了反压</p> 
<p>2、手段是资源调优和算子调优。 资源调优即是对作业中的 Operator 的并发数（parallelism）、CPU（core）、堆内存 （heap_memory）等参数进行调优。 作业参数调优包括：并行度的设置，State 的设置，checkpoint 的设置。</p> 
<p></p> 
<h3>8、Flink 什么情况下才会把 Operator chain 在一起形成算子链？</h3> 
<p>两个 operator chain 在一起的的条件： （1）上下游的并行度一致 （2）下游节点的入度为 1 （也就是说下游节点没有来自其他节点的输入） （3）上下游节点都在同一个 slot group 中（下面会解释 slot group） （4）下游节点的 chain 策略为 ALWAYS（可以与上下游链接，map、flatmap、filter 等默 认是 ALWAYS） （5）上游节点的 chain 策略为 ALWAYS 或 HEAD（只能与下游链接，不能与上游链接， Source 默认是 HEAD） （6）两个节点间数据分区方式是 forward（参考理解数据流的分区） （7）用户没有禁用 chain</p> 
<h3>9、说说 Flink 资源管理中 Task Slot 的概念？</h3> 
<p>最多能同时·执行的task数量，但是只做了内存隔离，没有做cpu隔离。</p> 
<h3>10、说说 Flink1.9 的新特性？</h3> 
<p>参考答案： 1.支持 hive 读写，支持 UDF 2.Flink SQL TopN 和 GroupBy 等优化 3.Checkpoint 与 savepoint 针对实际业务场景做了优化 4.支持 Flink state 查询</p> 
<h3>11、Flink 的反压和 Storm 有哪些不同？</h3> 
<p>参考答案： Storm 是通过监控 Bolt 中的接收队列负载情况，如果超过高水位值就会将反压信息写到 Zookeeper ，Zookeeper 上的 watch 会通知该拓扑的所有 Worker 都进入反压状态，最后 Spout 停止发送 tuple。 Flink 中的反压使用了高效有界的分布式阻塞队列，下游消费变慢会导致发送端阻塞。二者最大的区别是 Flink 是逐级反压，而 Storm 是直接从源头降速</p> 
<h3>12、Flink 中水印是什么概念，起到什么作用？</h3> 
<p>延迟数据</p> 
<h3>13、flink的时间</h3> 
<p>event、摄入、处理</p> 
<h3>14、说说 Flink 中的状态存储？</h3> 
<p>memory、hdfs、rockDB</p> 
<h3>15、重启策略</h3> 
<p>固定延迟、故障率、没有</p> 
<h3>16、Flink 面对数据高峰期时如何处理？</h3> 
<p>kafka小峰后flink处理</p> 
<h3>17、和spark的checkpoint的区别</h3> 
<p>spark 仅对drive的恢复做了数据和元数据快照，而flink是对每个算子和流动中的数据做快照</p> 
<h3>18、海量数据去重</h3> 
<p>etl-》redis去重-》flink\spark处理</p> 
<p>1、bloom过滤器 +redis的bit操作</p> 
<pre>  class MyBloomFilter(lengthBits:Long) extends Serializable{
​
    /**
     * 根据车牌，计算布隆过滤器(二进制向量)中对应的下标
     * 由于从用两个哈希函数(提高去重准确率)
     * @param car
     * @return
     */
    def getOffsets(car:String):Array[Long] = {
      var result  = new Array[Long](2)
      //调用谷歌的函数算法
      var hashcode1 = googleHash(car)
      if(hashcode1&lt;0){
        hashcode1 = ~ hashcode1 //防止哈希值为负数
      }
      var bit1 =  hashcode1 % lengthBits
      result(0) = bit1
​
      //调用JDK的哈希算法
      var hashcode2 = car.hashCode()
      if(hashcode2&lt;0){
        hashcode2 = ~ hashcode2 //防止哈希值为负数
      }
      result(1) = hashcode2 % lengthBits
      result
    }
​
    /**
     * 调用谷歌的哈希算法得到一个哈希值
     * @param car
     * @return
     */
    def googleHash(car:String):Long ={
      Hashing.murmur3_128(1).hashString(car,Charset.forName("UTF-8")).asLong()
    }
​
  }
  
  
  
  for(offset&lt;-offsets){
  //有了下标需要位图计算，采用redis帮助我们做位图计算
  //如果返回true，当前车辆可能是重复的，如果是false当前车辆肯定不重复
  val isContain: lang.Boolean = jedis.getbit(mapKey,offset)
  if(!isContain){
  repeated =false
  loop.break()
  }
  }</pre> 
<p>或者直接离线</p> 
<h3>19、parllelism和slot的关系</h3> 
<p>parllism是任务实际并发，slot 是task manger拥有的并发</p> 
<h3>20、State Backends</h3> 
<h4><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650239366&amp;idx=2&amp;sn=7489bf383e2deb3921daf6480887e090&amp;chksm=8f5a1bdab82d92cc6dcdf71ea51663b7d647f2259fe6e27b5244a66891c0156f6dfe233a7fe8&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="Flink State 最佳实践">Flink State 最佳实践</a></h4> 
<h4>1、根据数据结构分类</h4> 
<pre>valuestate：单值，与key绑定
liststate：状态值为一个list
reducingstate：
foldingstate：
mapstate：状态值为一个map</pre> 
<h4>2、托管类型</h4> 
<p>原生状态：自己管理状态，需要自己写snapshot和restore方法。</p> 
<p>托管：flink来给做快照和恢复。</p> 
<p>1）operator state：支持list、union list、broadcast</p> 
<p>自己管理状态。</p> 
<p>存储在内存。</p> 
<p>获取方式：1、实现CheckpointedFunction接口 2、实现ListCheckPointed</p> 
<p>和算子实例绑定，算子并行度发生变化自动重新分配。</p> 
<p>建议：</p> 
<p>1、慎用，因为内部会用long存储offset，存的多的话，checkpoint 时会使jm的oom。</p> 
<p>2、union state：在失败后恢复，所有算子都会有原先所以operator的全量的state状态</p> 
<p></p> 
<p>2）keystate：支持valuestate、liststate、reducingstate、foldingstate、mapstate，支持过期</p> 
<p>托管</p> 
<p>存储在内存或者rocksdb。</p> 
<p>和operator和key绑定，通过function获取。</p> 
<p>建议：</p> 
<p>1、state.clear() 只会清理当前key的的value，要清空整个state，可以用applyToAllKeys （）方法。</p> 
<p>2、rocksdb对于大value，上限是2^31 bytes，可以考虑用mapstate代替liststate和valuestate，因为RocksDB 的 map state 并不是将整个 map 作为 value 进行存储，而是将 map 中的一个条目作为键值对进行存储。</p> 
<p>3、监控rockdb的wirte buffer、compactions、flush等metric</p> 
<h4>3、存储分类</h4> 
<p>1、memory</p> 
<p>：state 存储在jobmanger的内存，checkpoint的时候也存储在内存。元数据存储在文件里。</p> 
<p>2、file state</p> 
<p>state存储在内存，checkpoint的时候存储在文件。</p> 
<p>适用情况：大状态，长窗口、failover的时候恢复、要注意state在没checkpoint时，数据还是在内存，所以不能大于taskmanger内存。</p> 
<p>缺点：不支持增量checkpoint</p> 
<p>3、rockesdb</p> 
<p>state：存储在本地文件系统</p> 
<p>checkpoint的时候存到远端文件系统</p> 
<p>好处：gc少，支持增量checkpoint、支持超大状态</p> 
<p>坏处：受限于磁盘大小，更新和获取状态需求序列化和序列化，比内存性能烧地，</p> 
<h4><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650239077&amp;idx=2&amp;sn=39bedd4f5a381f06a133acae290edd86&amp;chksm=8f5a1a39b82d932fb1000ad1f45492b1b42c1eec3bb40ec40198bbc71d3e03b2134c2d242f7f&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="4、大状态的一些优化">4、大状态的一些优化</a></h4> 
<p>1、flink-conf.yaml<code>中配置</code>state.backend.rocksdb.localdir 多个磁盘，分担单个磁盘压力，因为flink会随机选择要使用的目录。</p> 
<p>2、<a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650239077&amp;idx=2&amp;sn=39bedd4f5a381f06a133acae290edd86&amp;chksm=8f5a1a39b82d932fb1000ad1f45492b1b42c1eec3bb40ec40198bbc71d3e03b2134c2d242f7f&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="修改源码去自定义磁盘轮询">修改源码去自定义磁盘轮询</a>。Flink 1.8.1 版本，使用random来获取任务使用的磁盘，导致有的磁盘会分配多个任务，把磁盘占满，可以修改为roundrobin。</p> 
<p>roundrobin不能解决jvm有taskmanger，可以利用zookeeper来获取唯一id来分散磁盘压力，然后做成配置项在flink-conf.yaml里配置。目前flink.11版本还是random策略。</p> 
<p></p> 
<h4>5、<a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650239999&amp;idx=1&amp;sn=5183e97f78d35b59cb6cdc318de114a7&amp;chksm=8f5a19a3b82d90b59fe7cf9bf894f37245f722ed342fcc3a7fa046fe28cb8d4d6643c9c1cc84&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="Flink 状态生存时间（State TTL）机制的底层实现">Flink 状态生存时间（State TTL）机制的底层实现</a></h4> 
<p></p> 
<p></p> 
<h4>6、广播流去广播配置文件等</h4> 
<p>零、<a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650239265&amp;idx=2&amp;sn=cbc2bda736883cd9f695893a19e50544&amp;chksm=8f5a1b7db82d926b20f0e2740303227da5b47bac2a661ccd61257c18b7d26b8207eab045abff&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="Flink 使用 broadcast 实现维表或配置的实时更新">Flink 使用 broadcast 实现维表或配置的实时更新</a></p> 
<p>广播会将信息一直存储在内存，要注意大小和定制删除策略，或者使用keyby 来让每个节点只存储key对应的维度信息</p> 
<p></p> 
<p>一、keyBy的广播流使用</p> 
<p>KeyedBroadcastProcessFunction</p> 
<pre>public class TwoStreamJoinWithBroadcastStream {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(3);
 
        FlinkKafkaConsumer010&lt;String&gt; dwdConsumer = new FlinkKafkaConsumer010&lt;&gt;("dwd", new SimpleStringSchema(), KafkaUtils.comsumerProps());
        FlinkKafkaConsumer010&lt;String&gt; dimConsumer = new FlinkKafkaConsumer010&lt;&gt;("dim", new SimpleStringSchema(), KafkaUtils.comsumerProps());
 
        DataStreamSource&lt;String&gt; dwdStream = env.addSource(dwdConsumer);
        DataStreamSource&lt;String&gt; dimStream = env.addSource(dimConsumer);
 
        // 声明一个MapStateDescriptor，维度表作为广播state
        MapStateDescriptor&lt;String, String&gt; dimState = new MapStateDescriptor&lt;&gt;("dimState", BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO);
        BroadcastStream&lt;String&gt; broadcastStream = dimStream.broadcast(dimState);
 
        KeyedStream&lt;String, String&gt; vodKeyStream = dwdStream.keyBy(new KeySelector&lt;String, String&gt;() {
            @Override
            public String getKey(String line) throws Exception {
                JSONObject jn = JSON.parseObject(line);
                return jn.get("vodid").toString();
            }
        });
 
        SingleOutputStreamOperator&lt;String&gt; output = vodKeyStream
                .connect(broadcastStream)
                .process(new KeyedBroadcastProcessFunction&lt;String, String, String, String&gt;() {
                    /*
                    处理数据流数据
                     */
                    @Override
                    public void processElement(String line, ReadOnlyContext context, Collector&lt;String&gt; collector) throws Exception {
                        // 通过MapStateDescriptor获取BroadcastState
                        ReadOnlyBroadcastState&lt;String, String&gt; state = context.getBroadcastState(dimState);
 
                        JSONObject jn = JSON.parseObject(line);
                        String vodid = jn.get("vodid").toString();
                        String userid = jn.get("userid").toString();
                        String time = jn.get("time").toString();
 
                        if (state.contains(vodid)) {
                            String vodInfo = state.get(vodid);
                            String[] infos = vodInfo.split(",");
                            String vodName = infos[1];
                            String vodTag = infos[2];
                            String vodActor = infos[3];
 
                            StringJoiner joiner = new StringJoiner(",");
 
                            joiner.add(time)
                                    .add(userid)
                                    .add(vodid)
                                    .add(vodName)
                                    .add(vodTag)
                                    .add(vodActor);
 
                            collector.collect(joiner.toString());
                        }
                    }
 
                    /*
                    处理广播流数据
                     */
                    @Override
                    public void processBroadcastElement(String s, Context context, Collector&lt;String&gt; collector) throws Exception {
                        // 通过MapStateDescriptor获取BroadcastState
                        BroadcastState&lt;String, String&gt; state = context.getBroadcastState(dimState);
                        String key = s.split(",")[0];
                        if (!state.contains(key)) {
                            System.out.println("新的vod加入" + key);
                            state.put(key, s);
                        }
                    }
                });
 
        output.print();
        env.execute();
    }
}</pre> 
<p></p> 
<p>二、非keyby的广播流使用</p> 
<pre>public class TwoStreamJoinWithBroadcastStream {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(3);
 
        FlinkKafkaConsumer010&lt;String&gt; dwdConsumer = new FlinkKafkaConsumer010&lt;&gt;("dwd", new SimpleStringSchema(), KafkaUtils.comsumerProps());
        FlinkKafkaConsumer010&lt;String&gt; dimConsumer = new FlinkKafkaConsumer010&lt;&gt;("dim", new SimpleStringSchema(), KafkaUtils.comsumerProps());
 
        DataStreamSource&lt;String&gt; dwdStream = env.addSource(dwdConsumer);
        DataStreamSource&lt;String&gt; dimStream = env.addSource(dimConsumer);
 
        // 声明一个MapStateDescriptor，维度表作为广播state
        MapStateDescriptor&lt;String, String&gt; dimState = new MapStateDescriptor&lt;&gt;("dimState", BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO);
        BroadcastStream&lt;String&gt; broadcastStream = dimStream.broadcast(dimState);
 
        SingleOutputStreamOperator&lt;String&gt; output = dwdStream
                .connect(broadcastStream)
                .process(new BroadcastProcessFunction&lt;String, String, String&gt;() {
                     /*
                    处理数据流数据
                     */
                    @Override
                    public void processElement(String line, ReadOnlyContext readOnlyContext, Collector&lt;String&gt; collector) throws Exception {
                        ReadOnlyBroadcastState&lt;String, String&gt; state = readOnlyContext.getBroadcastState(dimState);
 
                        JSONObject jn = JSON.parseObject(line);
                        String vodid = jn.get("vodid").toString();
                        String userid = jn.get("userid").toString();
                        String time = jn.get("time").toString();
 
                        if (state.contains(vodid)) {
                            String vodInfo = state.get(vodid);
                            String[] infos = vodInfo.split(",");
                            String vodName = infos[1];
                            String vodTag = infos[2];
                            String vodActor = infos[3];
 
                            StringJoiner joiner = new StringJoiner(",");
 
                            joiner.add(time)
                                    .add(userid)
                                    .add(vodid)
                                    .add(vodName)
                                    .add(vodTag)
                                    .add(vodActor);
 
                            collector.collect(joiner.toString());
                        }
                    }
 
                    /*
                    处理广播流数据
                     */
                    @Override
                    public void processBroadcastElement(String s, Context context, Collector&lt;String&gt; collector) throws Exception {
                        BroadcastState&lt;String, String&gt; state = context.getBroadcastState(dimState);
                        String key = s.split(",")[0];
                        if (!state.contains(key)) {
                            System.out.println("新的vod加入" + key);
                            state.put(key, s);
                        }
                    }
                });
 
        output.print();
        env.execute();
    }
}</pre> 
<p></p> 
<p></p> 
<h3>21、checkpoint &amp;&amp; savepoint</h3> 
<p>savepoint为主动行为，强烈推荐为每个算子指定uid，因为savepoint回复的时候是根据算子的uid进行回复，代码结构更改会导致flink自动为算子分配的uid更改，从而无法从savepoint回复。</p> 
<p>手动触发：bin/flink savepoint :jobId [:targetDirectory]</p> 
<p>使用yanr触发savepoint：bin/flink savepoint :jobId [:targetDirectory] -yid :yarnAppId</p> 
<p></p> 
<p>checkpoint 恢复会比savepoint快。</p> 
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650239009&amp;idx=2&amp;sn=2c63bcba31f91a15ca2e2cf3cacf5566&amp;chksm=8f5a1a7db82d936bc6114dacfed17ca9ad4a92eab2c941ad35bfd90aefb67d35f741ace80563&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="无论RETAIN_ON_CAN">无论RETAIN_ON_CAN</a>CELLATION、DELETE_ON_CANCELLATION，flink重启或者失败，checkpoint都会永远存在存储上，需要手动清除。手动清理不能通过时间来判断清理，因为rocksdb 增量快照恢复会依赖之前的快照，可以通过解析metadata文件，解析出哪些checkpoint还被依赖，删除那些已经被不被依赖的checkpoint。</p> 
<h3>22、整合apollo</h3> 
<p>1、setcheckpointintervel 去动态更改是不生效的。</p> 
<h3>23、内存管理</h3> 
<p>1、预先分配内存，内存不足则刷写磁盘</p> 
<p>2、二进制形式存储对象，比java原生方式消耗内存低</p> 
<p>3、排序先基于key进行前缀排序，相等时才比较整个对象。</p> 
<p>如何分配内存：</p> 
<p>taskmanager由actor：负责跟mater通信、iomanger：负责一些磁盘和从磁盘读数据、memorymanager：负责memorysegment分配，启动后预先分配，可重用，默认站70%内存。</p> 
<p>对象序列化：BasicTypeInfo：java基础数据类型、string</p> 
<p>BasicArrayTypeInfo：java基础类型构成的数组、string</p> 
<p>WritableTypeInfo：hadoop writable</p> 
<p>TupleTypeInfo</p> 
<p>CaseClassTypeInfo：scala caseclass 或者scala tuples</p> 
<p>PojoTypeInfo：任何pojo对象</p> 
<h3>24、<a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650241012&amp;idx=1&amp;sn=1fc2d3848c957f759036a5d2a55ae09f&amp;chksm=8f5a1da8b82d94be63cbd12d4ceac54442b353f3d1453d02de72898e7b4af7e0f1affca1d568&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="常用参数">常用参数</a></h3> 
<p><strong>Flink 参数配置和常见参数调优</strong></p> 
<ul><li> <p>jobmanger.rpc.address jm的地址。</p> </li><li> <p>jobmanager.rpc.port jm的端口号。</p> </li><li> <p><strong>jobmanager.heap.mb jm的堆内存大小。不建议配的太大，1-2G足够。</strong></p> </li><li> <p><strong>taskmanager.heap.mb tm的堆内存大小。大小视任务量而定。需要存储任务的中间值，网络缓存，用户数据等。</strong></p> </li><li> <p><strong>taskmanager.numberOfTaskSlots slot数量。在yarn模式使用的时候会受到<code>yarn.scheduler.maximum-allocation-vcores</code>值的影响。此处指定的slot数量如果超过yarn的maximum-allocation-vcores，flink启动会报错。在yarn模式，flink启动的task manager个数可以参照如下计算公式：</strong></p> </li></ul> 
<blockquote> 
 <p>num_of_tm = ceil(parallelism / slot) 即并行度除以slot个数，结果向上取整。</p> 
</blockquote> 
<ul><li> <p>parallelsm.default 任务默认并行度，如果任务未指定并行度，将采用此设置。</p> </li><li> <p>web.port Flink web ui的端口号。</p> </li><li> <p>jobmanager.archive.fs.dir 将已完成的任务归档存储的目录。</p> </li><li> <p>history.web.port 基于web的history server的端口号。</p> </li><li> <p>historyserver.archive.fs.dir history server的归档目录。该配置必须包含<code>jobmanager.archive.fs.dir</code>配置的目录，以便history server能够读取到已完成的任务信息。</p> </li><li> <p>historyserver.archive.fs.refresh-interval 刷新存档作业目录时间间隔</p> </li><li> <p><strong>state.backend 存储和检查点的后台存储。可选值为rocksdb filesystem hdfs。</strong></p> </li><li> <p><strong>state.backend.fs.checkpointdir 检查点数据文件和元数据的默认目录。</strong></p> </li><li> <p><strong>state.checkpoints.dir 保存检查点目录。</strong></p> </li><li> <p><strong>state.savepoints.dir save point的目录。</strong></p> </li><li> <p><strong>state.checkpoints.num-retained 保留最近检查点的数量。</strong></p> </li><li> <p><strong>state.backend.incremental 增量存储。</strong></p> </li><li> <p>akka.ask.timeout Job Manager和Task Manager通信连接的超时时间。如果网络拥挤经常出现超时错误，可以增大该配置值。</p> </li><li> <p>akka.watch.heartbeat.interval 心跳发送间隔，用来检测task manager的状态。</p> </li><li> <p>akka.watch.heartbeat.pause 如果超过该时间仍未收到task manager的心跳，该task manager 会被认为已挂掉。</p> </li><li> <p><strong>taskmanager.network.memory.max 网络缓冲区最大内存大小。</strong></p> </li><li> <p><strong>taskmanager.network.memory.min 网络缓冲区最小内存大小。</strong></p> </li><li> <p>taskmanager.network.memory.fraction 网络缓冲区使用的内存占据总JVM内存的比例。如果配置了<code>taskmanager.network.memory.max</code>和<code>taskmanager.network.memory.min</code>，本配置项会被覆盖。</p> </li><li> <p>fs.hdfs.hadoopconf hadoop配置文件路径（<strong>已被废弃，建议使用HADOOP_CONF_DIR环境变量</strong>）</p> </li><li> <p>yarn.application-attempts job失败尝试次数，主要是指job manager的重启尝试次数。该值不应该超过<code>yarn-site.xml</code>中的<code>yarn.resourcemanager.am.max-attemps</code>的值。</p> </li></ul> 
<p><strong>Flink HA(Job Manager)的配置</strong></p> 
<ul><li> <p>high-availability: zookeeper 使用zookeeper负责HA实现</p> </li><li> <p>high-availability.zookeeper.path.root: /flink flink信息在zookeeper存储节点的名称</p> </li><li> <p>high-availability.zookeeper.quorum: zk1,zk2,zk3 zookeeper集群节点的地址和端口</p> </li><li> <p>high-availability.storageDir: hdfs://nameservice/flink/ha/ job manager元数据在文件系统储存的位置，zookeeper仅保存了指向该目录的指针。</p> </li></ul> 
<p><strong>Flink metrics 监控相关配置</strong></p> 
<ul><li> <p>metrics.reporters: prom</p> </li><li> <p>metrics.reporter.prom.class: org.apache.flink.metrics.prometheus.PrometheusReporter</p> </li><li> <p>metrics.reporter.prom.port: 9250-9260</p> </li></ul> 
<p><strong>Kafka相关调优配置</strong></p> 
<ul><li> <p>linger.ms/batch.size 这两个配置项配合使用，可以在吞吐量和延迟中得到最佳的平衡点。batch.size是kafka producer发送数据的批量大小，当数据量达到batch size的时候，会将这批数据发送出去，避免了数据一条一条的发送，频繁建立和断开网络连接。但是如果数据量比较小，导致迟迟不能达到batch.size，为了保证延迟不会过大，kafka不能无限等待数据量达到batch.size的时候才发送。为了解决这个问题，引入了<code>linger.ms</code>配置项。当数据在缓存中的时间超过<code>linger.ms</code>时，无论缓存中数据是否达到批量大小，都会被强制发送出去。</p> </li></ul> 
<p>ack 数据源是否需要kafka得到确认。all表示需要收到所有ISR节点的确认信息，1表示只需要收到kafka leader的确认信息，0表示不需要任何确认信息。该配置项需要对数据精准性和延迟吞吐量做出权衡。</p> 
<p><strong>Kafka topic分区数和Flink并行度的关系</strong></p> 
<ul><li> <p>Flink kafka source的并行度需要和kafka topic的分区数一致。最大化利用kafka多分区topic的并行读取能力。</p> </li></ul> 
<p><strong>Yarn相关调优配置</strong></p> 
<ul><li> <p>yarn.scheduler.maximum-allocation-vcores</p> </li><li> <p>yarn.scheduler.minimum-allocation-vcores</p> </li></ul> 
<p>Flink单个task manager的slot数量必须介于这两个值之间</p> 
<ul><li> <p>yarn.scheduler.maximum-allocation-mb</p> </li><li> <p>yarn.scheduler.minimum-allocation-mb</p> </li></ul> 
<p>Flink的job manager 和task manager内存不得超过container最大分配内存大小。</p> 
<p>yarn.nodemanager.resource.cpu-vcores yarn的虚拟CPU内核数，建议设置为物理CPU核心数的2-3倍，如果设置过少，会导致CPU资源无法被充分利用，跑任务的时候CPU占用率不高。</p> 
<p></p> 
<h3>25、Flink 使用 connect 实现双流匹配</h3> 
<h4>一、案例分析</h4> 
<p>在生产环境中，我们经常会遇到双流匹配的案例，例如：</p> 
<ul><li> <p>一个订单包含了订单主体信息和商品的信息。</p> </li><li> <p>外卖行业，一个订单包含了订单付款信息和派送信息。</p> </li><li> <p>互联网广告行业，一次点击包含了用户的点击行为日志和计费日志。</p> </li><li> <p>等其他相关的案例</p> </li></ul> 
<p>上述这些案例都需要涉及到双流匹配的操作，也就是所谓的双流 join。下面用一个案例来详解如何用 connect 实现双流 join。</p> 
<p>本文案例</p> 
<p>一个订单分成了大订单和小订单，大小订单对应的数据流来自 Kafka 不同的 Topic，需要在两个数据流中按照订单 Id 进行匹配，这里认为相同订单 id 的两个流的延迟最大为 60s。大订单和小订单匹配成功后向下游发送，若 60s 还未匹配成功，意味着当前只有一个流来临，则认为订单异常，需要将数据进行侧流输出。</p> 
<p>思路描述</p> 
<p>提取两个流的时间戳，因为要通过订单 Id 进行匹配，所以这里按照订单 Id 进行 keyBy，然后两个流 connect，大订单和小订单的处理逻辑一样，两个流通过 ValueState 进行关联。假如大订单流对应的数据先来了，需要将大订单的相关信息保存到大订单的 ValueState 状态中，注册一个 60s 之后的定时器。</p> 
<ul><li> <p>如果 60s 内来了小订单流对应的数据来了，则将两个数据拼接发送到下游。</p> </li><li> <p>如果 60s 内小订单流对应的数据还没来，就会触发 onTimer，然后进行侧流输出。</p> </li></ul> 
<p>如果小订单流对应的数据先到，也是同样的处理逻辑，先将小订单的信息保存到小订单的 ValueState 中，注册 60s 之后的定时器。</p> 
<h4>二、实现</h4> 
<p>用代码来讲述如何实现，首先要配置 Checkpoint 等参数，这里就不详细阐述。</p> 
<p>1. 定义订单类</p> 
<p>这里大小订单都使用同一个类演示：</p> 
<pre>@Data
publicclass Order {
    /** 订单发生的时间 */
    long time;
​
    /** 订单 id */
    String orderId;
​
    /** 用户id */
    String userId;
​
    /** 商品id */
    int goodsId;
​
    /** 价格 */
    int price;
​
    /** 城市 */
    int cityId;
}</pre> 
<p>2. 从 Kafka 的 topic 读取大小订单数据</p> 
<p>读取大订单数据，从 json 解析成 Order 类。从 Order 中提取 EventTime、并分配 WaterMark。按照订单 id 进行 keyBy 得到 bigOrderStream。</p> 
<pre>// 读取大订单数据，读取的是 json 类型的字符串
FlinkKafkaConsumerBase&lt;String&gt; consumerBigOrder =
        new FlinkKafkaConsumer011&lt;&gt;("big_order_topic_name",
                new SimpleStringSchema(),
                KafkaConfigUtil.buildConsumerProps(KAFKA_CONSUMER_GROUP_ID))
                .setStartFromGroupOffsets();
​
KeyedStream&lt;Order, String&gt; bigOrderStream = env.addSource(consumerBigOrder)
        // 有状态算子一定要配置 uid
        .uid(KAFKA_TOPIC)
        // 过滤掉 null 数据
        .filter(Objects::nonNull)
        // 将 json 解析为 Order 类
        .map(str -&gt; JSON.parseObject(str, Order.class))
        // 提取 EventTime，分配 WaterMark
        .assignTimestampsAndWatermarks(
                new BoundedOutOfOrdernessTimestampExtractor&lt;Order&gt;
                        (Time.seconds(60)) {
                    @Override
                    public long extractTimestamp(Order order) {
                        return order.getTime();
                    }
                })
        // 按照 订单id 进行 keyBy
        .keyBy(Order::getOrderId);</pre> 
<p>小订单的处理逻辑与上述流程完全类似，只不过读取的 topic 不是同一个。</p> 
<pre>// 小订单处理逻辑与大订单完全一样
FlinkKafkaConsumerBase&lt;String&gt; consumerSmallOrder =
        new FlinkKafkaConsumer011&lt;&gt;("small_order_topic_name",
                new SimpleStringSchema(),
                KafkaConfigUtil.buildConsumerProps(KAFKA_CONSUMER_GROUP_ID))
                .setStartFromGroupOffsets();
​
KeyedStream&lt;Order, String&gt; smallOrderStream = env.addSource(consumerSmallOrder)
        .uid(KAFKA_TOPIC)
        .filter(Objects::nonNull)
        .map(str -&gt; JSON.parseObject(str, Order.class))
        .assignTimestampsAndWatermarks(
                new BoundedOutOfOrdernessTimestampExtractor&lt;Order&gt;
                        (Time.seconds(10)) {
                    @Override
                    public long extractTimestamp(Order order) {
                        return order.getTime();
                    }
                })
        .keyBy(Order::getOrderId);</pre> 
<h4>3. connect 连接大小订单流，使用 process 进行匹配</h4> 
<p>再次描述一下处理流程：</p> 
<p>两个流通过 ValueState 进行关联，假如大订单流对应的数据先来了，需要将大订单的相关信息保存到大订单的 ValueState 状态中，注册一个 60s 之后的定时器。</p> 
<ul><li> <p>如果 60s 内来了小订单流对应的数据来了，则将两个数据拼接发送到下游。</p> </li><li> <p>如果 60s 内小订单流对应的数据还没来，就会触发 onTimer，然后进行侧流输出。</p> </li></ul> 
<p>需要提前定义好侧流输出需要用到的 OutTag：</p> 
<pre>privatestatic OutputTag&lt;Order&gt; bigOrderTag = new OutputTag&lt;&gt;("bigOrder");
privatestatic OutputTag&lt;Order&gt; smallOrderTag = new OutputTag&lt;&gt;("smallOrder")</pre> 
<p>代码实现如下：</p> 
<pre>// 使用 connect 连接大小订单的流，然后使用 CoProcessFunction 进行数据匹配
SingleOutputStreamOperator&lt;Tuple2&lt;Order, Order&gt;&gt; resStream = bigOrderStream
        .connect(smallOrderStream)
        .process(new CoProcessFunction&lt;Order, Order, Tuple2&lt;Order, Order&gt;&gt;() {
            // 大订单数据先来了，将大订单数据保存在 bigState 中。
            ValueState&lt;Order&gt; bigState;
            // 小订单数据先来了，将小订单数据保存在 smallState 中。
            ValueState&lt;Order&gt; smallState;

            // 大订单的处理逻辑
            @Override
            public void processElement1(Order bigOrder, Context ctx,
                                        Collector&lt;Tuple2&lt;Order, Order&gt;&gt; out)
                    throws Exception {
                // 获取当前 小订单的状态值
                Order smallOrder = smallState.value();
                // smallOrder 不为空表示小订单先来了，直接将大小订单拼接发送到下游
                if (smallOrder != null) {
                    out.collect(Tuple2.of(smallOrder, bigOrder));
                    // 清空小订单对应的 State 信息
                    smallState.clear();
                } else {
                    // 小订单还没来，将大订单放到状态中，并注册 1 分钟之后触发的 timerState
                    bigState.update(bigOrder);
                    // 1 分钟后触发定时器，当前的 eventTime + 60s
                    long time = bigOrder.getTime() + 60000;
                    ctx.timerService().registerEventTimeTimer(time);
                }
            }

            @Override
            public void processElement2(Order smallOrder, Context ctx,
                                        Collector&lt;Tuple2&lt;Order, Order&gt;&gt; out)
                    throws Exception {
                // 这里先省略代码，小订单的处理逻辑与大订单的处理逻辑完全类似
            }

            @Override
            public void onTimer(long timestamp, OnTimerContext ctx,
                                Collector&lt;Tuple2&lt;Order, Order&gt;&gt; out)
                    throws Exception {
                // 定时器触发了，即 1 分钟内没有接收到两个流。
                // 大订单不为空，则将大订单信息侧流输出
                if (bigState.value() != null) {
                    ctx.output(bigOrderTag, bigState.value());
                }
                // 小订单不为空，则将小订单信息侧流输出
                if (smallState.value() != null) {
                    ctx.output(smallOrderTag, smallState.value());
                }
                bigState.clear();
                smallState.clear();
            }

            @Override
            public void open(Configuration parameters) throws Exception {
                super.open(parameters);
                // 初始化状态信息
                bigState = getRuntimeContext().getState(
                        new ValueStateDescriptor&lt;&gt;("bigState", Order.class));
                smallState = getRuntimeContext().getState(
                        new ValueStateDescriptor&lt;&gt;("smallState", Order.class));
            }
        });</pre> 
<p>小优化</p> 
<p>假如 60s 以内，两个流的数据都到了，也就是执行了 <code>out.collect(Tuple2.of(smallOrder, bigOrder));</code> 还有必要触发定时器吗？</p> 
<p>定时器的目的是为了保证当 60s 时间到了，仍然有一个流还未到达。那么当两个流都到达时，没有必要再去触发定时器。所以当两个流都到达时，可以删除注册的定时器。（定时器的维护和触发也是需要成本的，所以及时清理这些垃圾是一个比较好的习惯）</p> 
<p>改造后的代码如下，申请了一个 ValueState 类型的 timerState 用于维护注册的定时器时间，如果两个流都到达时，触发 delete 操作，同时要注意调用 timerState.clear() 去清理 timerState 的状态信息。</p> 
<pre>// 大订单的处理逻辑
@Override
public void processElement1(Order bigOrder, Context ctx,
                            Collector&lt;Tuple2&lt;Order, Order&gt;&gt; out)
        throws Exception {
    // 获取当前 小订单的状态值
    Order smallOrder = smallState.value();
    // smallOrder 不为空表示小订单先来了，直接将大小订单拼接发送到下游
    if (smallOrder != null) {
        out.collect(Tuple2.of(smallOrder, bigOrder));
        // 清空小订单对应的 State 信息
        smallState.clear();
        // 这里可以将 Timer 清除。因为两个流都到了，没必要再触发 onTimer 了
        ctx.timerService().deleteEventTimeTimer(timerState.value());
        timerState.clear();
    } else {
        // 小订单还没来，将大订单放到状态中，并注册 1 分钟之后触发的 timerState
        bigState.update(bigOrder);
        // 1 分钟后触发定时器，并将定时器的触发时间保存在 timerState 中
        long time = bigOrder.getTime() + 60000;
        timerState.update(time);
        ctx.timerService().registerEventTimeTimer(time);
    }
}</pre> 
<p>4. 结果输出</p> 
<p>这里直接将正常的输出结果还有策略输出都通过 print 进行输出，生产环境肯定是需要通过 Sink 输出到外部系统的。侧流输出的数据属于异常数据，需要保存到外部系统，进行特殊处理。</p> 
<pre>// 正常匹配到数据的 输出。生产环境肯定是需要通过 Sink 输出到外部系统
resStream.print();

// 只有大订单时，没有匹配到 小订单，属于异常数据，需要保存到外部系统，进行特殊处理
resStream.getSideOutput(bigOrderTag).print();
// 只有小订单时，没有匹配到 大订单，属于异常数据，需要保存到外部系统，进行特殊处理
resStream.getSideOutput(smallOrderTag).print();

env.execute(JOB_NAME);</pre> 
<h4>三、 总结</h4> 
<p>Flink 使用 connect 实现双流 join 在 Flink 的 Streaming Api 中相对经常使用的 map、flatMap 等算子来讲已经属于比较复杂的场景了。文中开始处介绍的那些场景都可以通过本文的案例经过简单改造即可实现。而且 connect 实现双流 join 属于 Flink 面试的高频考点，希望读者通过本文有所收获。</p> 
<p></p> 
<p>###</p> 
<p></p> 
<h3>26、<a href="%20https%3A//zhisheng-blog.yuque.com/docs/share/a4b45fed-7417-4789-8df3-071abb9b3cac?" rel="nofollow">Flink 精进学习知识星球内容整理</a></h3> 
<p><a href="assets%5C%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%B0%83%E4%BC%98.assets%5C%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20Flink%20%E7%BD%91%E7%BB%9C%E6%B5%81%E6%8E%A7%E4%B8%8E%E5%8F%8D%E5%8E%8B%E6%9C%BA%E5%88%B6.pdf" rel="nofollow">一文搞懂 Flink 网络流控与反压机制.pdf</a></p> 
<p><a href="assets%5C%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%B0%83%E4%BC%98.assets%5C%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E4%B8%80%E5%A5%97%20Flink%20%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F.pdf" rel="nofollow">从0到1搭建一套 Flink 监控系统.pdf</a></p> 
<p><a href="assets%5C%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%B0%83%E4%BC%98.assets%5C4.3Flink%20Checkpoint%20%E5%92%8C%20Savepoint%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%85%B6%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%20%281%29.pdf" rel="nofollow">4.3Flink Checkpoint 和 Savepoint 的区别及其配置使用 (1).pdf</a></p> 
<p><a href="assets%5C%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%B0%83%E4%BC%98.assets%5C2%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%20Flink%20%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8_.pdf" rel="nofollow">2如何选择 Flink 状态后端存储_.pdf</a></p> 
<p><a href="assets%5C%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%B0%83%E4%BC%98.assets%5C%E4%BD%BF%E7%94%A8%20Prometheus%20Grafana%20%E7%9B%91%E6%8E%A7%20Flink.pdf" rel="nofollow">使用 Prometheus Grafana 监控 Flink.pdf</a></p> 
<h3>27、分流split/sideout</h3> 
<p>split的流再spilt select不生效。</p> 
<p>想完成连续split流可以用 split+filter或者side output来代替</p> 
<p><a href="http://www.54tianzhisheng.cn/2019/06/12/flink-split/" rel="nofollow" title="Flink 从0到1学习—— Flink 不可以连续 Split(分流)？">Flink 从0到1学习—— Flink 不可以连续 Split(分流)？</a></p> 
<p><a href="http://www.54tianzhisheng.cn/2019/08/18/flink-side-output/" rel="nofollow" title="Flink 从0到1学习 —— 如何使用 Side Output 来分流？">Flink 从0到1学习 —— 如何使用 Side Output 来分流？</a></p> 
<p></p> 
<p></p> 
<p></p> 
<h3><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650238825&amp;idx=1&amp;sn=28da5840a8c22c7c675d7d4987824f33&amp;chksm=8f5a0535b82d8c232681d2bc935bf99fa7c3d05f0406c184f71722e53a5209b2f19816f31ae1&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="28、Flink 全链路端到端延迟的测量方法">28、Flink 全链路端到端延迟的测量方法</a></h3> 
<p>env.getConfig().setLatencyTrackingInterval()</p> 
<p>GET taskmanagers/ABCDE/metrics</p> 
<p><a href="https://zhuanlan.zhihu.com/p/415652541" rel="nofollow" title="一口气搞懂「Flink Metrics」监控指标和性能优化，全靠这33张图和7千字（建议收藏）">一口气搞懂「Flink Metrics」监控指标和性能优化，全靠这33张图和7千字（建议收藏）</a></p> 
<p><a href="https://www.modb.pro/db/113005" rel="nofollow" title="Flink 实时 metrics">Flink 实时 metrics</a></p> 
<p></p> 
<h4>sideout</h4> 
<ul><li> <p>ProcessFunction</p> </li><li> <p>KeyedProcessFunction</p> </li><li> <p>CoProcessFunction</p> </li><li> <p>ProcessWindowFunction</p> </li><li> <p>ProcessAllWindowFunction</p> </li></ul> 
<pre>private static final OutputTag&lt;AlertEvent&gt; middleware = new OutputTag&lt;AlertEvent&gt;("MIDDLEWARE") {};
private static final OutputTag&lt;AlertEvent&gt; machine = new OutputTag&lt;AlertEvent&gt;("MACHINE") {};
private static final OutputTag&lt;AlertEvent&gt; docker = new OutputTag&lt;AlertEvent&gt;("DOCKER") {};


//dataStream 是总的数据流
SingleOutputStreamOperator&lt;AlertEvent, AlertEvent&gt; outputStream = dataStream.process(new ProcessFunction&lt;AlertEvent, AlertEvent&gt;() {
    @Override
    public void processElement(AlertEvent value, Context ctx, Collector&lt;AlertEvent&gt; out) throws Exception {
        if ("MACHINE".equals(value.type)) {
            ctx.output(machine, value);
        } else if ("DOCKER".equals(value.type)) {
            ctx.output(docker, value);
        } else if ("MIDDLEWARE".equals(value.type)) {
            ctx.output(middleware, value);
        } else {
            //其他的业务逻辑
            out.collect(value);
        }
    }
});
    
    
//机器相关的告警&amp;恢复数据
outputStream.getSideOutput(machine).print();

//容器相关的告警&amp;恢复数据
outputStream.getSideOutput(docker).print();

//中间件相关的告警&amp;恢复数据
outputStream.getSideOutput(middleware).print();


这样你就可以获取到 Side Output 数据了。
另外你还可以看下我在 Github 放的一个完整 demo 代码: https://github.com/zhisheng17/flink-learning/blob/master/flink-learning-examples/src/main/java/com/zhisheng/examples/streaming/sideoutput/Main.java</pre> 
<p></p> 
<p></p> 
<h3>29、<a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650239150&amp;idx=2&amp;sn=738a83a0c4981ac851c077d27fc390bb&amp;chksm=8f5a1af2b82d93e42d24119e8563a6ec50968e5c3d9bce7f075777baff37f63583a169055a6d&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="Flink HDFS Sink 如何保证 exactly-once 语义">Flink HDFS Sink 如何保证 exactly-once 语义</a></h3> 
<h3>30、Flink on YARN 常见问题与排查思路</h3> 
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650238685&amp;idx=2&amp;sn=b023313ecbaf30d9a66e75636c6dfa7a&amp;chksm=8f5a0481b82d8d970433c857c11a4e5af971f21d6c9c4e70eb619cfeb2b871a344b3a7764830&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="一张图轻松掌握 Flink on YARN 基础架构与启动流程">一张图轻松掌握 Flink on YARN 基础架构与启动流程</a></p> 
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650238700&amp;idx=2&amp;sn=a391c6cf1f1e4d6e22f6453a4033f575&amp;chksm=8f5a04b0b82d8da68459f17ea2105b9f5f130b5aff498579e6cf4cb426cd6109a3a2462f1f5c&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="Flink on YARN 常见问题与排查思路">Flink on YARN 常见问题与排查思路</a></p> 
<p></p> 
<p><a href="https://blog.csdn.net/iflink/article/details/122389637" title="Maven专题(六) - 插件maven-shade-plugin">Maven专题(六) - 插件maven-shade-plugin</a></p> 
<p></p> 
<h3><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650238695&amp;idx=2&amp;sn=222d820e2a0485ab31811b6ab774b0b2&amp;chksm=8f5a04bbb82d8dad2650a4e751743d950a64082f2b7ba7796f8d35a936c076453b1cf3f0abbb&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="31、Flink 单并行度内使用多线程来提高作业性能">31、Flink 单并行度内使用多线程来提高作业性能</a></h3> 
<p></p> 
<p>利用线程池+CyclicBarrier 来完成异步多线程+at least one语义。</p> 
<pre>public class MultiThreadConsumerSink extends RichSinkFunction&lt;String&gt; implements CheckpointedFunction {
    private Logger LOG = LoggerFactory.getLogger(MultiThreadConsumerSink.class);

    // Client 线程的默认数量
    private final int DEFAULT_CLIENT_THREAD_NUM = 5;
    // 数据缓冲队列的默认容量
    private final int DEFAULT_QUEUE_CAPACITY = 5000;

    private LinkedBlockingQueue&lt;String&gt; bufferQueue;
    private CyclicBarrier clientBarrier;

    @Override
    public void open(Configuration parameters) throws Exception {
        super.open(parameters);
        // new 一个容量为 DEFAULT_CLIENT_THREAD_NUM 的线程池
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(DEFAULT_CLIENT_THREAD_NUM, DEFAULT_CLIENT_THREAD_NUM,
                0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;());
        // new 一个容量为 DEFAULT_QUEUE_CAPACITY 的数据缓冲队列
        this.bufferQueue = Queues.newLinkedBlockingQueue(DEFAULT_QUEUE_CAPACITY);
        // barrier 需要拦截 (DEFAULT_CLIENT_THREAD_NUM + 1) 个线程
        this.clientBarrier = new CyclicBarrier(DEFAULT_CLIENT_THREAD_NUM + 1);
        // 创建并开启消费者线程
        MultiThreadConsumerClient consumerClient = new MultiThreadConsumerClient(bufferQueue, clientBarrier);
        for (int i=0; i &lt; DEFAULT_CLIENT_THREAD_NUM; i++) {
            threadPoolExecutor.execute(consumerClient);
        }
    }

    @Override
    public void invoke(String value, Context context) throws Exception {
        // 往 bufferQueue 的队尾添加数据
        bufferQueue.put(value);
    }

    @Override
    public void snapshotState(FunctionSnapshotContext functionSnapshotContext) throws Exception {
        LOG.info("snapshotState : 所有的 client 准备 flush !!!");
        // barrier 开始等待
        clientBarrier.await();
    }

    @Override
    public void initializeState(FunctionInitializationContext functionInitializationContext) throws Exception {
    }

}</pre> 
<p></p> 
<p></p> 
<p></p> 
<pre>public class MultiThreadConsumerClient implements Runnable {

    private Logger LOG = LoggerFactory.getLogger(MultiThreadConsumerClient.class);
    private LinkedBlockingQueue&lt;String&gt; bufferQueue;
    private CyclicBarrier barrier;

    public MultiThreadConsumerClient(
            LinkedBlockingQueue&lt;String&gt; bufferQueue, CyclicBarrier barrier) {
        this.bufferQueue = bufferQueue;
        this.barrier = barrier;
    }

    @Override
    public void run() {
        String entity;
        while (true){
            try {
                // 从 bufferQueue 的队首消费数据，并设置 timeout
                entity = bufferQueue.poll(50, TimeUnit.MILLISECONDS);
                // entity != null 表示 bufferQueue 有数据
                if(entity != null){
                    // 执行 client 消费数据的逻辑
                    doSomething(entity);
                } else {
                    // entity == null 表示 bufferQueue 中已经没有数据了，
                    // 且 barrier wait 大于 0 表示当前正在执行 Checkpoint，
                    // client 需要执行 flush，保证 Checkpoint 之前的数据都消费完成
                    if ( barrier.getNumberWaiting() &gt; 0 ) {
                        LOG.info("MultiThreadConsumerClient 执行 flush, " +
                                "当前 wait 的线程数：" + barrier.getNumberWaiting());
                        flush();
                        barrier.await();
                    }
                }
            } catch (InterruptedException| BrokenBarrierException e) {
                e.printStackTrace();
            }
        }
    }

    // client 消费数据的逻辑
    private void doSomething(String entity) {

    }

    // client 执行 flush 操作，防止丢数据
    private void flush() {
        // client.flush();
    }
}</pre> 
<h3>32、背压</h3> 
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650238405&amp;idx=1&amp;sn=a262bef27509f0017688e16374ad44c0&amp;chksm=8f5a0799b82d8e8f99a365822bc678b77ced5dc03c3c4817a4f8635d9b77e96e0ac258e88ffa&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="Flink Back Pressure(背压)是怎么实现的？有什么绝妙之处？">Flink Back Pressure(背压)是怎么实现的？有什么绝妙之处？</a>：</p> 
<p>1、每50ms对任务执行100个<code>Thread.getStackTrace()</code>。，来确定任务是否存在背压。</p> 
<h3>33、部署模式</h3> 
<h4>0、local，本地调试</h4> 
<h4>1、standalone 单机模式，独立的flink集群</h4> 
<h4>2、yarn模式</h4> 
<p>1）session ：开启的是一个yarn session，然后使用flin-run提交任务给yarn session，对于大量的小任务可以用这样的方式，减少资源创建时间。</p> 
<p>2）per job 直接提交任务给yarn，相当于一个yarn session只跑一个flink job.</p> 
<p>生产一般用yarn，极少用standalone</p> 
<p></p> 
<h3>34、异步io</h3> 
<h4>使用前提：</h4> 
<p>1、数据库或者存储支持异步请求的client</p> 
<p>2、没有异步客户端，那就丢到线程池中执行</p> 
<h4>2、默认超时会重启 job，可以重写timeout方法</h4> 
<h4>3、提供了 exactly-onece保证，他将未执行回调的任务都保存在检查点中，恢复的时候会再次调用定义的方法查询结果，然后发送给下游</h4> 
<p></p> 
<h4>4、</h4> 
<p>1）AsyncFunction#asyncInvoke 的操作不用调用阻塞操作，他不是被flink多线程调用的</p> 
<p>2）AsyncDataStream.orderedWait(有序)：消息发送顺序和接收到顺序相同</p> 
<p>3）AsyncDataStream.unorderedWait 无序</p> 
<p>注意：processtime做watermark的时候完全无序（开销和延迟低）</p> 
<p>eventtime做watermark的时候，窗口中的无序，但是watermark后的消息不能早于watermark前的消息发送。（开销取决于watermark的频率）</p> 
<pre>	private static class SampleAsyncFunction extends RichAsyncFunction&lt;Integer, String&gt; {
		private static final long serialVersionUID = 2098635244857937717L;

		private transient ExecutorService executorService;

		/**
		 * The result of multiplying sleepFactor with a random float is used to pause
		 * the working thread in the thread pool, simulating a time consuming async operation.
		 */
		private final long sleepFactor;

		/**
		 * The ratio to generate an exception to simulate an async error. For example, the error
		 * may be a TimeoutException while visiting HBase.
		 */
		private final float failRatio;

		private final long shutdownWaitTS;

		SampleAsyncFunction(long sleepFactor, float failRatio, long shutdownWaitTS) {
			this.sleepFactor = sleepFactor;
			this.failRatio = failRatio;
			this.shutdownWaitTS = shutdownWaitTS;
		}

		@Override
		public void open(Configuration parameters) throws Exception {
			super.open(parameters);

			executorService = Executors.newFixedThreadPool(30);
		}

		@Override
		public void close() throws Exception {
			super.close();
			ExecutorUtils.gracefulShutdown(shutdownWaitTS, TimeUnit.MILLISECONDS, executorService);
		}

		@Override
		public void asyncInvoke(final Integer input, final ResultFuture&lt;String&gt; resultFuture) {
			executorService.submit(() -&gt; {
				// wait for while to simulate async operation here
				long sleep = (long) (ThreadLocalRandom.current().nextFloat() * sleepFactor);
				try {
					Thread.sleep(sleep);

					if (ThreadLocalRandom.current().nextFloat() &lt; failRatio) {
						resultFuture.completeExceptionally(new Exception("wahahahaha..."));
					} else {
						resultFuture.complete(
							Collections.singletonList("key-" + (input % 10)));
					}
				} catch (InterruptedException e) {
					resultFuture.complete(new ArrayList&lt;&gt;(0));
				}
			});
		}
	}</pre> 
<p></p> 
<h3>35、窗口触发器</h3> 
<p>窗口类型：滚动：默认对齐整分、整点、整秒、</p> 
<p>滑动：默认对齐整分、整点、整秒、</p> 
<p>session：定于静态gap或者动态gap，为每个event创建一个新窗口，窗口之间距离比定义的gap小则将其合并成一个。</p> 
<p></p> 
<p>窗口允许延迟触发，即窗口触发后又有属于该窗口的数据到达，也可能会导致session的合并。</p> 
<p></p> 
<h3>36、常用算子</h3> 
<p></p> 
<p>coGroup ：将两个流的相同key合到一起。</p> 
<p>###</p> 
<h3>37、窗口是串行执行的吗</h3> 
<p>单个task窗口是串行，如果一个窗口阻塞住了，会导致下一个时间窗口的数据留到下下个窗口中。</p> 
<h4>38、看完flink 大会</h4> 
<p></p> 
<p></p> 
<h3>错误</h3> 
<p><strong>Cannot instantiate user function.</strong></p> 
<pre>修改：默认设置指示首先从用户代码jar加载类，这意味着用户代码jar可以包含和加载不同于Flink使用的依赖项(传递性地)。

在onf/flink-conf.yaml 添加如下内容并重启 flink.

classloader.resolve-order: parent-first</pre> 
<p></p> 
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMTE0ODU5NQ==&amp;mid=2650239115&amp;idx=2&amp;sn=f6ff30687c0ecaf2e10b23434674257e&amp;chksm=8f5a1ad7b82d93c1f2f492f70ea5257671eba44f48c00c1be8008310af15ad857c66fbbbc2cf&amp;token=1858295303&amp;lang=zh_CN#rd" rel="nofollow" title="Flink流计算编程--Flink扩容、程序升级前后的思考">Flink流计算编程--Flink扩容、程序升级前后的思考</a></p> 
<blockquote> 
 <p>删除一个有状态的operator：状态丢了，这时会报出找不到operator的错误，你要通过-n(--allowNonRestoredState)来指定跳过这个operator的状态恢复</p> 
</blockquote> 
<h2>二、hive</h2> 
<h3>1、Hive 在 select 查询数据后，执行 insert 操作插入 ORC 表和 parquet 表操作的过程中，遇到over gc limit、java.lang.OutMemoryError:Java heap space 等字样的错误，大概从哪些地方查找原因解决问题？</h3> 
<p>1）可能数据分布不均匀造成的，可以在 select 阶段加 cluster by rand()让数据均匀分布。 （2）map 和 reduce 阶段的内存不够，通过 hive 参数增加内存 set mapreduce.reduce.memory.mb=16384;（实际调试的时候，8G 内存不够，增加到 16G 解决 问题） set mapreduce.map.memory.mb=4096; （3）另外在数据格式不统一的情况下，不同格式的 insert 操作效率奇低。</p> 
<h3>2、手写连续登入 7 日的用户 SQL？</h3> 
<p>select * from (select user_id,dt,date_sub(dt, (row_number over(partition by user_id order by dt asc )) as c from a where status=1) a group by user_id,c having count(1)&gt;=7</p> 
<p>求连续登录的天数、开始、结束时间和间隔时间</p> 
<pre>select 
	user_id, 
    duration, 
    min(le) as start_time, 
    max(le) as end_time, 
    max(le) - min(le) as interval1
from (select user_id,
             dt,
             date_sub(dt, (row_number over (partition by user_id order by dt asc )) as duration,
                      lead(dt, 1) over (partiton by user_id order by dt asc ) as le
                      from a where status = 1
                 ) a
      group by user_id, duration</pre> 
<p></p> 
<h3>3、hive 性能调优的常见方法？</h3> 
<p>参考答案： （1）HQL 层面优化 1）利用分区表优化 2）利用桶表优化 3）join 优化 4 ） Group By 数 据 倾 斜 优 化 解 决 这 个 问 题 的 方 法 是 配 置 一 个 参 数 ： set hive.groupby.skewindata=true。 5）Order By 优化 6）一次读取多次插入 7）Join 字段显示类型转换 （2）Hive 架构层面优化 1）不执行 MapReduc 2）本地模式执行 MapReduce 3）JVM 重用 4）并行化 （2）底层 MapReduce 优化 1）合理设置 map 数 2）合理设置reduce</p> 
<p>skew join</p> 
<h2>三、spark</h2> 
<h3>1、分配足够的资源 executor、core、memory</h3> 
<h3>2、用缓存，先MEMORY_ONLY、MEMORY_ONLY_SER、MEMORY_AND_DISK_SER、MEMORY_AND_DISK</h3> 
<h3>3、用checkpoint，对依赖长，计算时间长的rdd 做checkpoint，防止失败后再次计算。</h3> 
<h3>4、避免shuffle类算子。使用broadcast+map替代</h3> 
<h3>5、用reduceByKey、 aggregateByKey、 combineByKey代替group bykey，因为groupbykey不会在map端预聚合。</h3> 
<p>aggregateByKey：指定初始值，分区内、分区间聚合函数</p> 
<h3>6、尽量使用高性能的算子</h3> 
<p>使用reduceByKey替代groupByKey</p> 
<p>使用mapPartition替代map</p> 
<p>使用foreachPartition替代foreach</p> 
<p>filter后使用coalesce减少分区数</p> 
<p>使用repartition和coalesce算子操作分区。</p> 
<h3>7、善用broadcast</h3> 
<h3>8、使用Kryo （科瑞啊）序列化，性能比java原生高10倍。</h3> 
<h3>9、拉取数据、executor 失联等超时时间，spark.network.timeout=120s</h3> 
<h3>10、解决数据倾斜</h3> 
<p>3.2版本出现aqe <a href="https://spark.apache.org/docs/3.3.0/sql-performance-tuning.html#join-strategy-hints-for-sql-queries" rel="nofollow" title="官网调优">官网调优</a></p> 
<h3>11、shuffle类型</h3> 
<p><a href="https://spark.apache.org/docs/3.3.0/sql-performance-tuning.html#join-strategy-hints-for-sql-queries" rel="nofollow" title="官网调优">官网调优</a></p> 
<h3>12、数据本地性</h3> 
<p><a href="https://spark.apache.org/docs/latest/configuration.html#scheduling" rel="nofollow" title="官网调优">官网调优</a></p> 
<h3>13、小文件输出合并</h3> 
<p><a href="https://spark.apache.org/docs/3.3.0/sql-performance-tuning.html" rel="nofollow" title="SQL 查询的合并提示">SQL 查询的合并提示</a></p> 
<p><a href="https://spark.apache.org/docs/3.3.0/sql-ref-syntax-qry-select-hints.html#join-hints" rel="nofollow" title="hints">hints</a></p> 
<h3>14、善用bucket</h3> 
<p></p> 
<h3><a href="https://www.sohu.com/a/448260375_315839" rel="nofollow" title="15、Spark Skew Join 的原理及在 eBay 的优化">15、Spark Skew Join 的原理及在 eBay 的优化</a></h3> 
<p><strong>支持单边是bucket表的skew join</strong></p> 
<h2>四、hbase</h2> 
<p>数据模型：</p> 
<p><strong>master</strong>：存储元数据，负责创建、分配、平衡region</p> 
<p><strong>zookeeper</strong>：存储元数据在哪个region server里，客户端会缓存这个信息。</p> 
<p><strong>region server</strong>：region-&gt;多个store(1个store 存储1个Column family)-&gt;多个memstore+多个hfile</p> 
<p></p> 
<h3>1、创建表的时候预分区，指定region的startkey、end key</h3> 
<p>增加读写效率、负载均衡，防止数据倾斜</p> 
<h3>2、flush \compact\拆分机制</h3> 
<p><strong>memstore</strong></p> 
<p>达到大小或者时间限制，flush到磁盘</p> 
<p><strong>compact</strong></p> 
<p>多个hfile大小和数量达到阈值会合并多个hfile为一个</p> 
<p>也可以手动命名将region合并为一个</p> 
<p><strong>split</strong></p> 
<p>region达到大小或者key前缀相同等规定，会把大region拆分成小的region</p> 
<h3>3、协处理器</h3> 
<p>关系型数据库中的存储过程，也可以在get、scan的时候用来聚合数据，例如用来求最大值</p> 
<h3>4、rowkey设计</h3> 
<p>最大长度64k，建议16byte以下，越短越好，定长，高位作为散列</p> 
<p><strong>常见优化</strong>：</p> 
<p>1）预分区 2)加盐 3）哈希 4）反转：让经常变量的作为前缀，但牺牲了rowkey有序性</p> 
<h3>5、二级索引</h3> 
<p>借助例如Phoenix或者solr或者ES等，来完成对非rowkey字段查询</p> 
<h3>6、hbase的布隆过滤器</h3> 
<p></p> 
<h2>五、ES</h2> 
<p></p> 
<h2>六、clickhouse</h2> 
<h3>1、jion支持不好，尽量用宽表</h3> 
<h3>2、merge tree\</h3> 
<p>replaceingmerge tree\summingmergetree</p> 
<p>dictionary</p> 
<h3>3、分区</h3> 
<p>1、分区大小控制在百万或1000万的数据条数</p> 
<p>2、类型：整形、日期、string和float用128hash值作为分区id</p> 
<p>3、order by：查询频率大的在前，基数非常大的不适合在前</p> 
<p>4、抽样：对于基数大的表进行抽样</p> 
<p>5、尽量不存储null，而用无意义的默认值，因为null不能索引，也需要占额外的存储空间</p> 
<h3>4、设置ttl</h3> 
<h3>5、sql 优化</h3> 
<p>1、count()或count(*)且没有where条件则直接使用system.tables记录的行数</p> 
<p>2、explain syntax select ，可以查看优化后的sql，拿过来替换自己的sql</p> 
<pre>EXPLAIN indexes=1,json = 1 select * from mt_table;</pre> 
<p>3、消除重复字段的查询</p> 
<p>4、prewhere 替换where</p> 
<p>5、uniqCombined 替换count distinct</p> 
<p>6、local join</p> 
<p>7、global in</p> 
<p>8、in代替join</p> 
<p>9、join小表在右</p> 
<p>10、设置查询熔断</p> 
<p>11、关闭虚拟内存</p> 
<p>12、关注cpu，最好保证在50%,而到了70%一般会查询超时</p> 
<p>13、批量写入控制批次和提前排序，无序或者设计分区太多会导致ck对数据进行合并，影响查询</p> 
<h2>七、Doris</h2> 
<h3>1、分区分桶</h3> 
<p>1、分区建议日期、分桶建议区分度大的列</p> 
<p>2、表的tablet数量=partition×bucket数量，tablet数量应该略多余磁盘数量，单个大小在1G-10G，分区可单独指定数量，show data可以看表的数据量</p> 
<h3>2、模型</h3> 
<p>合理选择aggergation、unique、duplicate模型</p> 
<h3>3、副本数</h3> 
<p>副本数取决与集群的独立ip，所以尽量选择多个小机器而不是少量大机器</p> 
<h3>4、rollup\物化视图</h3> 
<p>劣势：rollup不能基于明细数据做预聚合</p> 
<h3>5、join</h3> 
<p>1、localjoin：分桶键一致、在一个group、sql语句不能用括号</p> 
<p>2、broadcast join：适合小表，可显示指定</p> 
<p>3、shuffle join：可显示指定</p> 
<p>4、bucket join：shuffle部分数据到本地节点计算</p> 
<p>性能：Colocate Join -&gt; Bucket Shuffle Join -&gt;Broadcast Join -&gt; Shuffle Join，doris也自动按照这个顺序选择join。显示指定则按照指定的进行.</p> 
<p>5、explain查看join类型</p> 
<p>6、小表写在右边</p> 
<p>7、runtimefilter：适合左表数据量大，右表过滤后数据量少的场景</p> 
<p>8、使用bitmap索引，适合枚举值少的列</p> 
<p>9、使用bloomfilter，适合枚举值多的列</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/655e897a2db4622eeeac49b9259dcab7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【区块链实战】如何搭建以太网智能合约私网</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4df45a6d3bdbd55699ef12b80e4d16cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">FTP服务搭建（linux）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>