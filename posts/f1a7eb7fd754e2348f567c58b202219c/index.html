<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>带你搞懂JavaScript中的原型和原型链 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="带你搞懂JavaScript中的原型和原型链" />
<meta property="og:description" content="简介 原型和原型链是JavaScript中与对象有关的重要概念，但是部分前端开发者却不太理解，也不清楚原型链有什么用处。其实，学过其他面对对象语言的同学应该了解，对象是由类生成的实例，类与类之间有继承的关系。在ES6之前，JavaScript中并没有class，实现类和继承的方法就是使用原型。在我个人看来，JS中类和原型链的设计和语法由于一些历史或包袱问题而不易用，也不易于理解。因此在ES6中推出了class相关的语法，和其他语言更接近，也更易用。
ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。(ECMAScript6入门教程 阮一峰)
虽然有了class，但是原型链相关的内容我们依然要掌握。不仅是因为作为前端开发者，我们要深入理解语法。而且在查看源码，以及实现一些复杂的面对对象写法时，依然是有用的。因此在这篇文章中，我们一起搞懂JavaScript中的原型和原型链。(这篇文章并不会涉及class相关语法)
构造函数与原型 构造函数 在JS中创建实例的方法是通过构造函数。在构造函数中通过this实现对实例的操控，比如赋值各种属性和方法。我们看个例子：
// Person构造函数 function PersonFun(name) { this.name = name; this.getName = function() { return this.name; } } // 创建实例 const p1 = new PersonFun(&#39;jz&#39;); console.log(p1.name, p1.getName()); // 输出结果: // jz jz 我们创建了PersonFun构造函数，使用new关键字创建了实例p1。可以看到，在构造函数中对this增加了属性和方法，最后成为了实例的属性。注意构造方法必须使用new调用。但是这样所有的属性都是实例属性，包括那个getName方法：
const p1 = new PersonFun(&#39;jz&#39;); const p2 = new PersonFun(&#39;jz&#39;); console.log(p1.getName === p2.getName); // 输出结果: // false 原型对象 只用上面的构造函数，依然没有“类”的存在。这时候我们增加原型这一概念，可以理解为是实例对象的类。原型对象可以通过构造函数的prototype属性访问。
// Person构造函数 function PersonFun(name) { this.name = name; } // Person原型对象 PersonFun." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f1a7eb7fd754e2348f567c58b202219c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-10T19:40:06+08:00" />
<meta property="article:modified_time" content="2023-12-10T19:40:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">带你搞懂JavaScript中的原型和原型链</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>简介</h2> 
<p>原型和原型链是JavaScript中与对象有关的重要概念，但是部分前端开发者却不太理解，也不清楚原型链有什么用处。其实，学过其他面对对象语言的同学应该了解，对象是由类生成的实例，类与类之间有继承的关系。在ES6之前，JavaScript中并没有class，实现类和继承的方法就是使用原型。在我个人看来，JS中类和原型链的设计和语法由于一些历史或包袱问题而不易用，也不易于理解。因此在ES6中推出了class相关的语法，和其他语言更接近，也更易用。</p> 
<blockquote> 
 <p>ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。(ECMAScript6入门教程 阮一峰)</p> 
</blockquote> 
<p>虽然有了class，但是原型链相关的内容我们依然要掌握。不仅是因为作为前端开发者，我们要深入理解语法。而且在查看源码，以及实现一些复杂的面对对象写法时，依然是有用的。因此在这篇文章中，我们一起搞懂JavaScript中的原型和原型链。(这篇文章并不会涉及class相关语法)</p> 
<h2><a id="_7"></a>构造函数与原型</h2> 
<h3><a id="_9"></a>构造函数</h3> 
<p>在JS中创建实例的方法是通过构造函数。在构造函数中通过this实现对实例的操控，比如赋值各种属性和方法。我们看个例子：</p> 
<pre><code class="prism language-js"><span class="token comment">// Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">PersonFun</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 创建实例</span>
<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonFun</span><span class="token punctuation">(</span><span class="token string">'jz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">,</span> p1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// jz jz</span>
</code></pre> 
<p>我们创建了PersonFun构造函数，使用new关键字创建了实例p1。可以看到，在构造函数中对this增加了属性和方法，最后成为了实例的属性。注意构造方法必须使用new调用。但是这样所有的属性都是实例属性，包括那个getName方法：</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonFun</span><span class="token punctuation">(</span><span class="token string">'jz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonFun</span><span class="token punctuation">(</span><span class="token string">'jz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>getName <span class="token operator">===</span> p2<span class="token punctuation">.</span>getName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// false</span>
</code></pre> 
<h3><a id="_36"></a>原型对象</h3> 
<p>只用上面的构造函数，依然没有“类”的存在。这时候我们增加原型这一概念，可以理解为是实例对象的类。原型对象可以通过构造函数的prototype属性访问。</p> 
<pre><code class="prism language-js"><span class="token comment">// Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">PersonFun</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Person原型对象</span>
<span class="token class-name">PersonFun</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 创建实例</span>
<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonFun</span><span class="token punctuation">(</span><span class="token string">'jz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonFun</span><span class="token punctuation">(</span><span class="token string">'jz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">,</span> p1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>getName <span class="token operator">===</span> p2<span class="token punctuation">.</span>getName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// jz jz</span>
<span class="token comment">// true</span>
</code></pre> 
<p>可以看到，我们没有在构造函数中添加实例对象的属性方法getName，仅仅在原型对象上添加。但实例对象上依然能使用属性方法getName，而且对于不同的实例来说，这个方法是共享的，是同一个。通过原型，我们不仅能共享方法名也能共享属性值：</p> 
<pre><code class="prism language-js"><span class="token comment">// Person原型对象</span>
<span class="token class-name">PersonFun</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonFun</span><span class="token punctuation">(</span><span class="token string">'jz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonFun</span><span class="token punctuation">(</span><span class="token string">'jz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>title<span class="token punctuation">,</span> p1<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'你好'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>title<span class="token punctuation">,</span> p2<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// hello hello</span>
<span class="token comment">// 你好 你好</span>
</code></pre> 
<p>可以看到，在实例中修改原型上提供的属性，实际上是增加实例中的属性值，因此这个修改是不在实例中共享的。但如果原型提供的属性是个对象，我们修改对象内部的值，这个值是实例间共享的。</p> 
<pre><code class="prism language-js"><span class="token class-name">PersonFun</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// 1</span>
</code></pre> 
<h3><a id="_82"></a>构造函数/原型的获取</h3> 
<p>通过上面的描述，我们了解了实例，构造函数和原型对象以及他们之间的关系。那么在代码中，如何获取构造函数和原型对象呢？我们列出了一些方法：</p> 
<pre><code class="prism language-js"><span class="token comment">// 构造函数 PersonFun</span>
<span class="token comment">// 获取原型对象</span>
Person <span class="token operator">=</span> <span class="token class-name">PersonFun</span><span class="token punctuation">.</span>prototype
<span class="token comment">// 创建实例对象</span>
p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 原型对象 Person</span>
<span class="token comment">// 获取构造函数</span>
PersonFun <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>constructor

<span class="token comment">// 实例对象 p1</span>
<span class="token comment">// 获取原型对象</span>
Person <span class="token operator">=</span> p1<span class="token punctuation">.</span>__proto__
Person <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span>
<span class="token comment">// 获取构造函数</span>
PersonFun <span class="token operator">=</span> p1<span class="token punctuation">.</span>constructor
</code></pre> 
<p>其中的<code>__proto__</code>最好使用<code>Object.getPrototypeOf</code>代替：</p> 
<blockquote> 
 <p><code>__proto__</code>并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的JS引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。(ECMAScript6入门教程 阮一峰)</p> 
</blockquote> 
<h2><a id="_107"></a>字面量的原型</h2> 
<h3><a id="_109"></a>字面量对象的原型</h3> 
<p>如果我们创建对象的时候，没有使用构造函数，而是直接是用大括号，以字面量的形式创建的对象，那么它的原型是什么？它有没有构造函数呢？是有的。我们一起来看一下：</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// {constructor: ƒ, __defineGetter__: ƒ, …}</span>
<span class="token comment">// ƒ Object() { [native code] }</span>
</code></pre> 
<p>输出了一些奇怪的东西，我们还是不知道字面量对象的原型是什么。我们换个角度想一想，以字面量形式创建的对象，是不是就相当于直接使用<code>new Object()</code>形式创建的对象？这里的Object也是一个构造函数。我们来试验下：</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> obj2<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> obj1<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// true</span>
<span class="token comment">// true</span>
<span class="token comment">// true</span>
</code></pre> 
<p>可以看到，使用字面量形式和<code>new Object()</code>形式，创建出来对象的原型是一样的。既然Object是个构造函数，那么<code>Object.prototype</code>即是Object实例的原型对象。</p> 
<p>至于<code>obj.constructor</code>实际上就是构造函数<code>Object()</code>。它是JS内部生成的，因此这里展示<code>[native code]</code>。</p> 
<h3><a id="new_Function_136"></a>new Function()</h3> 
<p>在JS中函数实际上也是个对象。既然它是个对象，那么它应该也有构造函数和原型吧。我们来试验下：</p> 
<pre><code class="prism language-js"><span class="token comment">// Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">PersonFun</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>PersonFun<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">PersonFun</span><span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// ƒ () { [native code] }</span>
<span class="token comment">// ƒ Function() { [native code] }</span>
</code></pre> 
<p>又输出了一些奇怪的东西，其中还有个<code>Function()</code>。我们继续联想下：对象可以用<code>new Object()</code>形式创建，那么函数是不是也可以？可以的！使用<code>new Function()</code>可以创建函数。我们来看下：</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> fun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'return a + b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// 3</span>
</code></pre> 
<p><code>new Function()</code>可以使用字符串作为代码执行的函数体，感觉有点像eval。但是eval是局部作用域，<code>new Function()</code>一直都是全局作用域。我们来看下例子：</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">envir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'console.log(a)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> fun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">'console.log(a)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">envir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// 2</span>
<span class="token comment">// 1</span>
</code></pre> 
<p>可以看到，eval输出的是局部作用域中的a值2，而<code>new Function()</code>虽然在局部作用域的位置中，但是内部获取到的依然是全局的变量。不过这些区别和我们要讨论的原型链无关，因此不再继续讨论。</p> 
<h3><a id="_176"></a>字面量函数的原型</h3> 
<p>了解了<code>new Function()</code>，我们再回来看看字面量函数的原型。</p> 
<pre><code class="prism language-js"><span class="token comment">// Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">PersonFun</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> fun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'return a + b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>PersonFun<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> fun<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>PersonFun<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">PersonFun</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function<span class="token punctuation">)</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// true</span>
<span class="token comment">// true</span>
<span class="token comment">// true</span>
</code></pre> 
<p>与对象类似，<code>Function.prototype</code>是函数的原型，我们函数字面量的原型都是它。函数的构造函数即是<code>Function()</code>。（构造函数与普通函数并无区别，都是函数）。在上面的输出中，函数的原型对象<code>Function.prototype</code>也是一个函数：<code>ƒ () { [native code] }</code>。关于这点我们会在后面讨论。</p> 
<h2><a id="JS_196"></a>JS中的原型关系</h2> 
<p>了解了字面量相关的原型，现在我们再来刨根问底，看看JS中对象的原型关系。</p> 
<h3><a id="_199"></a>对象的原型关系</h3> 
<p>首先看下Object原型的关系。</p> 
<h4><a id="_202"></a>对象的尽头</h4> 
<p>首先看看对象的尽头。上面讲过字面量对象的原型即是<code>Object.prototype</code>。它也是个对象，那么它有没有原型呢？我们试一下：</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// {constructor: ƒ, __defineGetter__: ƒ, …}</span>
<span class="token comment">// null</span>
</code></pre> 
<p>答案是没有的，<code>Object.prototype</code>是没有原型的。</p> 
<h4><a id="_214"></a>自定义构造函数与原生对象的关系</h4> 
<p>我们的自定义构造函数与对应的实例原型和<code>Object.prototype</code>有关系么？我们试验下：</p> 
<pre><code class="prism language-js"><span class="token comment">// Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">PersonFun</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Person原型对象</span>
<span class="token class-name">PersonFun</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">PersonFun</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">PersonFun</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">PersonFun</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// {constructor: ƒ, __defineGetter__: ƒ, …}</span>
<span class="token comment">// true</span>
<span class="token comment">// false</span>
</code></pre> 
<p>可以看到，Person构造函数对应实例的原型对象，它的原型即是<code>Object.prototype</code>。但是它与字面量对象不同的是，它的constructor属性表示的是它对应实例的构造函数，而不是字面量对象的<code>Object()</code>。</p> 
<h3><a id="_236"></a>原生类型的原型关系</h3> 
<p>在前面我们聊过了函数的原型，即是<code>Function.prototype</code>。但当时我们输出它，发现它是一个函数，那么它究竟是什么？它还有没有原型？</p> 
<pre><code class="prism language-js"><span class="token comment">// Person构造函数</span>
<span class="token keyword">function</span> <span class="token function">PersonFun</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>PersonFun<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>PersonFun<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>PersonFun<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>PersonFun<span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// ƒ () { [native code] }</span>
<span class="token comment">// {constructor: ƒ, __defineGetter__: ƒ, …}</span>
<span class="token comment">// true</span>
<span class="token comment">// undefined</span>
</code></pre> 
<p>可以看到，直接打印函数的原型也是一个函数，里面是<code>[native code]</code>，即它也是由JS内部生成的。它的再深一层原型，居然又是<code>Object.prototype</code>。函数的原型虽然也是个函数，但是它并没有更深一层的prototype。</p> 
<p>这时候我们返回去看看对象原型的构造函数，即<code>Object()</code>。作为一个函数，它的原型是什么？</p> 
<pre><code class="prism language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// ƒ Object() { [native code] }</span>
<span class="token comment">// ƒ () { [native code] }</span>
<span class="token comment">// true</span>
</code></pre> 
<p>看来这些原生类型的构造函数的原型，都同一个来源。我们再试一下其他的原生类型：</p> 
<pre><code class="prism language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Function<span class="token punctuation">.</span>prototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果:</span>
<span class="token comment">// ƒ Number() { [native code] }</span>
<span class="token comment">// ƒ () { [native code] }</span>
<span class="token comment">// true</span>
<span class="token comment">// ƒ Array() { [native code] }</span>
<span class="token comment">// ƒ () { [native code] }</span>
<span class="token comment">// true</span>
<span class="token comment">// ƒ String() { [native code] }</span>
<span class="token comment">// ƒ () { [native code] }</span>
<span class="token comment">// true</span>
<span class="token comment">// Uncaught TypeError: Function.prototype is not a constructor</span>
</code></pre> 
<p>果然如此，原生类型的构造函数的原型都是同一个。而如上面实验得出的结论，这个原型是一个函数，它没有构造函数，它的原型是<code>Object.prototype</code>。我还尝试直接用这个构造函数原型创建实例，结果提示这不是一个构造函数。</p> 
<h2><a id="_293"></a>原型链</h2> 
<p>有了上面这些关系，我们发现不同类型对象的原型似乎都是有关系的，好像有一条线可以把他们穿起来。这条线就是我们所说的原型链。在文章一开始的简介中说过，原型和原型链是JavaScirpt中实现类和继承的一种方式。原型就相当于实例的类，继承就像是原型链。因此，原型的特点也很像父类，即实例可以访问原型的属性，也可以覆盖原型属性。在浏览器的控制台中，我们打印一个对象，展示的<code>[[Prototype]]</code>即是它的原型。</p> 
<h3><a id="_296"></a>原型链示意图</h3> 
<p>不仅我们自定义的类型有原型链的关系，JS内部的原生类型也存在原型链，且可以和我们自定义的类型串起来。这里我们用一个图片描述原型链之间的关系（图片来源MollyPages.org）：</p> 
<p><img src="https://images2.imgbox.com/fd/86/oMkYZjwY_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="_301"></a>原型链文字版</h3> 
<p>假设我们有这样一些对象，我们来搞清楚它们的原型关系。</p> 
<ul><li>构造函数 PersonFun</li><li>实例对象 p1</li><li>原型对象(类) Person</li></ul> 
<pre><code class="prism language-js"><span class="token comment">// 构造函数 生成 实例对象</span>
p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 构造函数 -&gt; 原型对象</span>
Person <span class="token operator">=</span> <span class="token class-name">PersonFun</span><span class="token punctuation">.</span>prototype

<span class="token comment">// 实例对象 -&gt; 构造函数</span>
PersonFun <span class="token operator">=</span> p1<span class="token punctuation">.</span>constructor
<span class="token comment">// 实例对象 -&gt; 原型对象</span>
Person <span class="token operator">=</span> p1<span class="token punctuation">.</span>__proto__
Person <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> <span class="token comment">// 推荐</span>

<span class="token comment">// 原型对象 -&gt; 构造函数</span>
PersonFun <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>constructor
</code></pre> 
<p>再看一下字面量的原型关系，以及更深层次的关系：</p> 
<ul><li>字面量对象 obj1</li><li>字面量函数 fun1</li></ul> 
<pre><code class="prism language-js"><span class="token comment">// 字面量对象 -&gt; Object构造函数</span>
Object <span class="token operator">=</span> obj1<span class="token punctuation">.</span>constructor
<span class="token comment">// 字面量对象 -&gt; Object原型</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj1<span class="token punctuation">.</span>__proto__
<span class="token comment">// Object原型的原型 为 null</span>
<span class="token keyword">null</span> <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__

<span class="token comment">// 字面量函数 -&gt; Function构造函数</span>
Function <span class="token operator">=</span> fun1<span class="token punctuation">.</span>constructor
<span class="token comment">// 字面量函数 -&gt; Function原型</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> fun1<span class="token punctuation">.</span>__proto__
<span class="token comment">// Function原型作为一个构造函数时的实例原型 -&gt; undefined</span>
<span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>prototype
<span class="token comment">// Function原型的原型 为 Object原型</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__
</code></pre> 
<p>然后我们就可以完整的得到原型链：</p> 
<pre><code class="prism language-js"><span class="token comment">// 构造函数链</span>
<span class="token comment">// 实例对象 -&gt; 构造函数 -&gt; Function构造函数</span>
PersonFun <span class="token operator">=</span> p1<span class="token punctuation">.</span>constructor
Function  <span class="token operator">=</span> p1<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>constructor
Function  <span class="token operator">=</span> p1<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>constructor

<span class="token comment">// 原型对象链</span>
<span class="token comment">// 实例对象 -&gt; 原型对象 -&gt; Object原型 -&gt; null</span>
Person            <span class="token operator">=</span> p1<span class="token punctuation">.</span>__proto__
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype  <span class="token operator">=</span> p1<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__
<span class="token keyword">null</span>              <span class="token operator">=</span> p1<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__

<span class="token comment">// 字面量对象的原型对象链</span>
<span class="token comment">// 字面量函数 -&gt;  Object原型 -&gt; null</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype  <span class="token operator">=</span> obj1<span class="token punctuation">.</span>__proto__
<span class="token keyword">null</span>              <span class="token operator">=</span> obj1<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__

<span class="token comment">// 字面量函数的原型对象链</span>
<span class="token comment">// 字面量函数 -&gt; Function原型 -&gt; Object原型 -&gt; null</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype  <span class="token operator">=</span> fun1<span class="token punctuation">.</span>__proto__
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype    <span class="token operator">=</span> fun1<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__
<span class="token keyword">null</span>                <span class="token operator">=</span> fun1<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__

<span class="token comment">// Number对象的原型链</span>
<span class="token keyword">const</span> n1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Number对象 -&gt; Number原型 -&gt; Object原型 -&gt; null</span>
<span class="token class-name">Number</span><span class="token punctuation">.</span>prototype  <span class="token operator">=</span> n1<span class="token punctuation">.</span>__proto__
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype  <span class="token operator">=</span> n1<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__
<span class="token keyword">null</span>              <span class="token operator">=</span> n1<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__
</code></pre> 
<h2><a id="_378"></a>总结</h2> 
<p>通过原型链，我们可以了解JS中一些原生对象的原理和机制，比如为什么Function的实例也是对象，Number的实例也是对象，因为这些对象的原型都继承了Object原型，因此可以使用对象类型的方法。</p> 
<p>使用原型链，也可以实现很多类的继承模式，后面有机会我们可以讨论一下。总体看来，虽然使用原型链确实可以实现类和继承的等面对对象特性，但是相比于其他语言更晦涩且不容易理解。</p> 
<h2><a id="_384"></a>参考</h2> 
<ul><li>Class的基本语法 ECMAScript6入门教程 阮一峰<br> https://es6.ruanyifeng.com/#docs/class</li><li>Class 的继承 ECMAScript6入门教程 阮一峰<br> https://es6.ruanyifeng.com/#docs/class-extends</li><li>一文搞懂JS原型与原型链（超详细，建议收藏）<br> https://juejin.cn/post/6984678359275929637</li><li>你可能不太理解的JavaScript - 原型与原型链<br> https://juejin.cn/post/7254443448563040311</li><li>js从原型链到继承——图解来龙去脉<br> https://juejin.cn/post/7075354546096046087</li><li>Javascript Object Layout<br> http://www.mollypages.org/tutorials/js.mp</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f887a851d549fc68395c24ee5c0597c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">20231210 随机矩阵和M矩阵</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ff5a8930f704fc61a965b6fbf07d5cc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">密码学中的SM2</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>