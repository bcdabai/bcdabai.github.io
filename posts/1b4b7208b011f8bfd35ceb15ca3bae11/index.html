<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringMvc中拦截器的配置及应用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringMvc中拦截器的配置及应用" />
<meta property="og:description" content="拦截器原理 在 Spring MVC 中，拦截器（Interceptor）是一种机制，用于拦截请求并在处理程序（Controller）执行之前或之后执行一些操作。拦截器允许您在请求的不同阶段（如处理程序执行前、处理程序执行后、视图渲染前、视图渲染后等）添加自定义逻辑。
其中问号就是拦截器处理的范围。
实现自定义拦截器 @Component public class SampleInterceptor implements HandlerInterceptor { // 在controller执行前的逻辑 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 在controller执行之前执行的逻辑 System.out.println(&#34;Pre-handle logic&#34;); return true; // 返回 true，将允许请求继续传递到处理程序； //返回 false，将阻止请求传递给处理程序 } // 在controller执行后、并在视图渲染前执行的逻辑 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&#34;Post-handle logic&#34;); } //在服务器响应结束后执行的逻辑 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1b4b7208b011f8bfd35ceb15ca3bae11/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-21T15:33:41+08:00" />
<meta property="article:modified_time" content="2024-01-21T15:33:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringMvc中拦截器的配置及应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="HA7Ek">拦截器原理</h4> 
<blockquote> 
 <p id="uc08c0625">在 Spring MVC 中，拦截器（Interceptor）是一种机制，用于拦截请求并在处理程序（Controller）执行之前或之后执行一些操作。拦截器允许您在请求的不同阶段（如处理程序执行前、处理程序执行后、视图渲染前、视图渲染后等）添加自定义逻辑。</p> 
</blockquote> 
<p id="ub95062ee"></p> 
<p class="img-center"><img alt="" height="691" id="uaf0f8eb2" src="https://images2.imgbox.com/84/cc/NicI3U8B_o.png" width="1200"></p> 
<p id="u74ecdba7">其中问号就是拦截器处理的范围。</p> 
<h4 id="H3ezx">实现自定义拦截器</h4> 
<pre id="jNNSN"><code>@Component
public class SampleInterceptor implements HandlerInterceptor {
    // 在controller执行前的逻辑
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        // 在controller执行之前执行的逻辑
        System.out.println("Pre-handle logic");
        return true; // 返回 true，将允许请求继续传递到处理程序；
        //返回 false，将阻止请求传递给处理程序
    }
    // 在controller执行后、并在视图渲染前执行的逻辑
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
            ModelAndView modelAndView) throws Exception {
       
        System.out.println("Post-handle logic");
    }
    //在服务器响应结束后执行的逻辑
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
            throws Exception {
   
        System.out.println("After-completion logic");
    }
}</code></pre> 
<h4 id="fQmsR">将自定义拦截器添加到SpringMvc中</h4> 
<pre id="ylj8w"><code>@Configuration
public class InterceptorRoll implements WebMvcConfigurer {
    @Autowired
    LoginTicketInterceptor loginTicketInterceptor;
  
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //registry.addInterceptor() 方法可以向注册表中添加拦截器。
        InterceptorRegistration interceptorRegistration = registry.addInterceptor(loginTicketInterceptor);
        //添加拦截器生效路径，以及拦截器忽略的路径
        ...
        
        }
}</code></pre> 
<h4 id="sr9Qv">使用拦截器实现权限验证逻辑</h4> 
<p id="ud22240d3">关键鉴权逻辑图解：</p> 
<p id="u3a181a99"></p> 
<p class="img-center"><img alt="" height="522" id="u87263d95" src="https://images2.imgbox.com/2b/78/T5CuaJTv_o.png" width="830"></p> 
<p id="uf084511e">1.在请求controller之前先经过拦截器，从cookie中获取用户标识，根据用户标识，从redis中取出登录凭证</p> 
<p id="u5025934e">2.如果登录凭证有效，则设置一个线程与用户信息进行绑定，并将用户信息存入到视图模型中</p> 
<p id="u99a74d07">3.如果凭证无效则跳转到登录页面</p> 
<p id="ufb37a463">4.在用户请求完之后，销毁线程与用户名的绑定</p> 
<p id="u26dbc366">实现:</p> 
<p id="u07f2fa3b">1.创建工具类ThreadHolder</p> 
<pre id="pQxMA"><code>package com.duhong.util;

import com.duhong.entity.User;
import org.springframework.data.redis.core.StringRedisTemplate;

public class ThreadHolder {
    static ThreadLocal&lt;User&gt; users=new ThreadLocal&lt;&gt;();

    /**
     * 设置线程信息
     * @param user
     */
    public static void setHolder(User user){
        users.set(user);
    }

    /**
     * 获取当前线程的信息
     * @return
     */
    public static User getHolder(){
        return users.get();
    }

    /**
     * 解除线程与当前用户的绑定
     */
    public static void remove(){
        users.remove();
    }
}</code></pre> 
<p id="u370beff5">2.创建自定义拦截器</p> 
<pre id="Xwc2L"><code>@Component
public class LoginTicketInterceptor implements HandlerInterceptor {
    @Autowired
    StringRedisTemplate redisTemplate;//redis客户端
    @Autowired
    UserMapper userMapper;//根据用户id查询用户所有信息

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //获取用户的cookie
        Cookie[] cookies = request.getCookies();
        String loginOwner=null;
        System.out.println("开始鉴权");
        for(Cookie cookie:cookies){
            if(cookie.getName().equals("loginOwner")){
                loginOwner=cookie.getValue();
                break;
            };
        }
        LoginTicket ticket=new LoginTicket();
        //如果loginOwner不等于null,从redis中获取登录签证
        if(loginOwner!=null) {
            String s = redisTemplate.opsForValue().get(RedisUtil.getTicket(loginOwner));
            ticket = RedisUtil.getObject(s);

            //用户已被授权
            if (ticket != null &amp;&amp; ticket.getStatus() == 1) {
                User user = userMapper.selectById(ticket.getUserId());
                //将用户信息与当前线程绑定
                ThreadHolder.setHolder(user);
                return true;
            }
        }
        //如果签证不等于null,而且签证的状态无效则跳转到登录页面
        response.sendRedirect("/site/login");
        return false;
    }

    /**
     * 在视图层渲染之前将用户信息存入模型
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
     public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {
         if(ThreadHolder.getHolder()!=null&amp;&amp;modelAndView!=null){
         //从当前线程中获取用用户信息
             modelAndView.addObject("loginUser",ThreadHolder.getHolder());
         }

     }

    /**
     * 在服务器响应完本次信息之后,解除当前线程与用户信息的绑定
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
     public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {
         ThreadHolder.remove();
     }
}</code></pre> 
<p id="u54e77875">3.将拦截器加入到SpringMvc中并设置拦截规则</p> 
<pre id="DQSZ9"><code>package com.duhong.config;

import com.duhong.filter.LoginTicketInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.Arrays;
import java.util.List;

@Configuration
public class InterceptorRoll implements WebMvcConfigurer {
    @Autowired
    LoginTicketInterceptor loginTicketInterceptor;
    //配置文件中配置配置需要过滤的路径形式为:路径，路径，...
    @Value("${allow.pages}")
    String allowPages;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        InterceptorRegistration interceptorRegistration = registry.addInterceptor(loginTicketInterceptor);
        interceptorRegistration.addPathPatterns("/**");
        String[] split = allowPages.split(",");
        for (String allowpage : split) {
            System.out.println(allowpage);
            //忽略指定页面
            interceptorRegistration.excludePathPatterns(allowpage);
        }
        //忽略静态资源
        interceptorRegistration.excludePathPatterns("/css/**","/img/**","/js/**");
    }
}</code></pre> 
<p id="u577ef1e4">如有收获，就点个赞吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/adf873367b199857e0433793c6e66b72/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">leetcode-环形链表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/057c6e918c2d8e6e947eeb2cf372ac5f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java中的代理模式（二）JDK动态代理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>