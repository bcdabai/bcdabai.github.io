<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库系统概论 ---知识点大全（期末复习版） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库系统概论 ---知识点大全（期末复习版）" />
<meta property="og:description" content="（一）绪论 数据(Data)：是数据库中存储的基本对象
数据的定义：描述事物的符号记录
数据的种类：文字、图形、图象、声音等
数据的特点：数据与其语义是不可分的
数据库(Database,简称DB)：是长期储存在计算机内、有组织的、可共享的大量数据集合
数据库管理系统（Database Management System，简称DBMS）：是位于用户与操作系统之间的一层数据管理软件。
DBMS的用途：科学地组织和存储数据、高效地获取和维护数据。
DBMS的主要功能：
数据库的运行管理 保证数据的安全性、完整性 多用户对数据的并发使用
发生故障后的系统恢复 数据库的建立和维护功能(实用程序) 数据库数据批量装载
数据库转储 介质故障恢 数据库的重组织 性能监视等
数据库系统（Database System，简称DBS）是指在计算机系统中引入数据库后的系统构成。
数据库系统的构成：由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员（和用户）构成。（三树一人）
数据管理：对数据进行分类、组织、编码、存储、检索和维护，是数据处理的中心问题
数据模型这个工具来抽象、表示和处理现实世界中的数据和信息。
数据模型分成两个不同的层次
(1) 概念模型 也称信息模型，它是按用户的观点来对数据和信息建模。 (2) 数据模型 主要包括网状模型、层次模型、关系模型等，它是按计算机系统的观点对数据建模。 客观对象的抽象过程---两步抽象：① 现实世界中的客观对象抽象为概念模型；② 把概念模型转换为某一DBMS支持的数据模型。
数据结构：对象类型的集合 即数据结构是对系统静态特性的描述
两类对象：①与数据类型、内容、性质有关的对象 ②与数据之间联系有关的对象
数据操作：对数据库中各种对象（型）的实例（值）允许执行的操作及有关的操作规则
数据操作的类型：检索 更新（包括插入、删除、修改）
数据模型对操作的定义：
①操作的确切含义 ；②操作符号；③操作规则（如优先级）；④ 实现操作的语言数据模型对操作的定义
数据操作是对系统动态特性的描述。
数据模型对约束条件的定义：反映和规定本数据模型必须遵守的基本的通用的完整性约束条件。提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。
信息世界中的基本概念
(1) 实体（Entity） 客观存在并可相互区别的事物称为实体。
(2) 属性（Attribute） 实体所具有的某一特性称为属性。
一个实体可以由若干个属性来刻画。 (3) 码（Key） 唯一标识实体的属性集称为码。 (4) 域（Domain） 属性的取值范围称为该属性的域。 (5) 实体型（Entity Type） 用实体名及其属性名集合来抽象和刻画
同类实体称为实体型
(6) 实体集（Entity Set） 同型实体的集合称为实体集" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e7314958d2d9539b93e96698dab4167b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-11T09:03:58+08:00" />
<meta property="article:modified_time" content="2023-06-11T09:03:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库系统概论 ---知识点大全（期末复习版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 style="margin-left:.0001pt;"> （一）绪论</h4> 
<p style="margin-left:.0001pt;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>数据</strong><strong>(Data)</strong>：是数据库中存储的基本对象</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>数据的定义：</strong>描述事物的符号记录</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>数据的种类：</strong>文字、图形、图象、声音等</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>数据的特点：</strong>数据与其语义是不可分的</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>数据库</strong><strong>(Database,</strong><strong>简称</strong><strong>DB)</strong>：是<u><u>长期</u></u>储存在计算机内、有<u><u>组织</u></u>的、可<u><u>共享</u></u>的<u><u>大量</u></u>数据集合</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong><img alt="" height="683" src="https://images2.imgbox.com/53/73/npOwLtOL_o.png" width="1104"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>数据库管理系统（</strong><strong>Database  Management System</strong><strong>，简称</strong><strong>DBMS</strong><strong>）：</strong>是位于用户与操作系统之间的一层数据管理软件。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>DBMS</strong><strong>的用途</strong>：科学地组织和存储数据、高效地获取和维护数据。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>DBMS</strong></strong><strong><strong>的主要功能</strong></strong>：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">数据库的运行管理      <strong><strong>保证数据的安全性、完整性 </strong>       <strong> </strong><strong>多用户对数据的并发使用</strong></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong> </strong><strong> </strong><strong><strong>发生故障后的系统恢复</strong></strong>     数据库的建立和维护功能(<strong><strong>实用程序</strong></strong><strong><strong>)</strong>    <strong>数据库数据批量装载</strong></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>  </strong><strong> </strong><strong><strong>数据库转储   </strong></strong><strong><strong>介质故障恢  </strong> <strong> </strong><strong>数据库的重组织        </strong></strong><strong><strong>性能监视等</strong></strong></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>数据库系统（</strong></strong><strong><strong>Database System</strong></strong><strong><strong>，简称</strong></strong><strong><strong>DBS</strong></strong><strong><strong>）是指在计算机系统中</strong></strong><strong><span style="background-color:#00ff00;"><strong>引入数据库</strong></span></strong><strong><strong>后的系统构成。</strong></strong></p> 
<p style="text-align:justify;">    数据库系统的构成：<strong><strong>由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员（和用户）构成。<span style="color:#fe2c24;">（三树一人）</span></strong></strong></p> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;">          数据管理：<strong><strong>对数据进行分类、组织、编码、存储、检索和维护，是数据处理的中心问题</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">数据模型这个工具来<strong><u><strong><u>抽象、表示和处理</u></strong></u></strong>现实世界中的数据和信息。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="text-align:justify;"><img alt="" height="470" src="https://images2.imgbox.com/e7/0a/F3lQAbSb_o.png" width="1104"></p> 
<p></p> 
<p style="text-align:justify;">数据模型分成两个不同的层次</p> 
<p style="text-align:justify;"><img alt="" height="739" src="https://images2.imgbox.com/43/84/UfTNFkjc_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>(1) </strong></strong><strong><strong>概念模型</strong></strong><strong>   </strong><strong><strong>也称信息模型，它是按用户的观点来对数据和信息建模。</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>(2) </strong></strong><strong><strong>数据模型</strong></strong><strong>   </strong><strong><strong>主要包括</strong></strong><strong><span style="color:#0000ff;"><strong>网状模型、层次模型、关系模型</strong></span></strong><strong><strong>等，它是按计算机系统的观点对数据建模</strong></strong>。 </p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="text-align:justify;">      客观对象的抽象过程---两步抽象：① <strong><strong>现实世界中的客观对象抽象为概念模型；</strong></strong>② <strong><strong>把概念模型转换为某一DBMS</strong></strong><strong><strong>支持的数据模型。</strong></strong></p> 
<p style="text-align:justify;">数据结构：对象类型的集合     即<span style="color:#be191c;"><strong>数据结构是对系统静态特性的描述</strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">两类对象：①与数据类型、内容、性质有关的对象   ②与数据之间联系有关的对象</p> 
<p style="margin-left:.0001pt;text-align:justify;">数据操作：对数据库中各种对象（型）的实例（值）允许执行的操作及有关的操作规则</p> 
<p style="margin-left:.0001pt;text-align:justify;">数据操作的类型：检索       更新（包括插入、删除、修改）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">数据模型对操作的定义：</p> 
<p style="text-align:justify;">①操作的确切含义 ；②操作符号；③操作规则（如优先级）；④ 实现操作的语言数据模型对操作的定义</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">数据操作是对系统动态特性的描述。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">数据模型对约束条件的定义：<strong>反<strong><strong>映</strong>和规定本数据模型必须遵守的基本的通用的完整性约束条件。提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件</strong></strong>。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>信息世界中的基本概念</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">(1) 实体（Entity） </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>客观存在并可相互区别的事物称为实体。</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"> (2) 属性（Attribute） </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>实体所具有的某一特性称为属性。</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>一个实体可以由若干个属性来刻画。</strong></strong>  </p> 
<p style="margin-left:.0001pt;text-align:justify;">(3) 码（Key） </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>唯一标识实体的属性集称为码。</strong></strong> </p> 
<p style="margin-left:.0001pt;text-align:justify;">(4) 域（Domain） </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>属性的取值范围称为该属性的域</strong></strong>。 </p> 
<p style="margin-left:.0001pt;text-align:justify;">(5) 实体型（Entity Type） </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>用实体名及其属性名集合来抽象和刻画</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>同类实体称为实体型</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">(6) 实体集（Entity Set） </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>同型实体的集合称为实体集</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">联系（Relationship）  </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>现实世界中事物内部以及事物之间的联系在信息世界</strong></strong><strong><strong>中反映为实体内部的联系和实体之间的联系。</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;"><strong>实体内部</strong></span>的联系通常是指组成实体的各属性之间的联系 。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;"><strong>实体之间</strong></span>的联系通常是指<strong><span style="background-color:#ff9900;">不同实体集之间的联系。</span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>两个实体型间的联系</strong></strong><strong> </strong></p> 
<ol><li style="text-align:justify;">一对一联系    
  <ol><li style="text-align:justify;"><strong><strong>如果对于实体集</strong></strong><strong><strong>A</strong></strong><strong><strong>中的每一个实体，实体集</strong></strong><strong><strong>B</strong></strong><strong><strong>中至多有一个实体与之联系，反之亦然，则称实体集</strong></strong><strong><strong>A</strong></strong><strong><strong>与实体集</strong></strong><strong><strong>B</strong></strong><strong><strong>具有一对一联系。记为</strong></strong><strong><strong>1:1</strong></strong><strong><strong>。</strong></strong> </li></ol></li><li style="text-align:justify;">一对多联系 
  <ol><li style="text-align:justify;"><strong><strong>如果对于实体集</strong></strong><strong><strong>A</strong></strong><strong><strong>中的每一个实体，实体集</strong></strong><strong><strong>B</strong></strong><strong><strong>中有</strong></strong><strong><strong>n</strong></strong><strong><strong>个实体（</strong></strong><strong><strong>n</strong></strong><strong><strong>≥</strong></strong><strong><strong>0</strong></strong><strong><strong>）与之联系，反之，对于实体集</strong></strong><strong><strong>B</strong></strong><strong><strong>中的每一个实体，实体集</strong></strong><strong><strong>A</strong></strong><strong><strong>中至多只有一个实体与之联系，则称实体集</strong></strong><strong><strong>A</strong></strong><strong><strong>与实体集</strong></strong><strong><strong>B</strong></strong><strong><strong>有一对多联系</strong></strong><strong><strong>记为</strong></strong><strong><strong>1:n</strong></strong></li></ol></li><li style="text-align:justify;">多对多联系（m:n） 
  <ol><li style="text-align:justify;"><strong><strong>如果对于实体集</strong></strong><strong><strong>A</strong></strong><strong><strong>中的每一个实体，实体集</strong></strong><strong><strong>B</strong></strong><strong><strong>中有</strong></strong><strong><strong>n</strong></strong><strong><strong>个实体（</strong></strong><strong><strong>n</strong></strong><strong><strong>≥</strong></strong><strong><strong>0</strong></strong><strong><strong>）与之联系，反之，对于实体集</strong></strong><strong><strong>B</strong></strong><strong><strong>中的每一个实体，实体集</strong></strong><strong><strong>A</strong></strong><strong><strong>中也有</strong></strong><strong><strong>m</strong></strong><strong><strong>个实体（</strong></strong><strong><strong>m</strong></strong><strong><strong>≥</strong></strong><strong><strong>0</strong></strong><strong><strong>）与之联系，则称实体集</strong></strong><strong><strong>A</strong></strong><strong><strong>与实体</strong></strong><strong><strong>B</strong></strong><strong><strong>具有多对多联系。记为</strong></strong><strong><strong>m:n</strong></strong></li></ol></li></ol> 
<p style="text-align:justify;"><img alt="" height="665" src="https://images2.imgbox.com/ef/04/ZwJIFlP6_o.png" width="1150"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>概念模型的表示方法</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">实体－联系方法(E-R方法)：</p> 
<p style="margin-left:.0001pt;text-align:justify;">①用E-R图来描述现实世界的概念模型；</p> 
<p style="margin-left:.0001pt;text-align:justify;">②E-R方法也称为E-R模型；</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>常用数据模型</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">非关系模型：<strong><strong>层次模型（</strong></strong><strong><strong>Hierarchical Model</strong></strong><strong><strong>）</strong></strong>；<strong><strong>网状模型</strong></strong><strong><strong>(Network Model )</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p>      2.数据结构：以基本层次联系为基本单位</p> 
<p style="margin-left:.0001pt;text-align:justify;">  <strong><strong>基本层次联系：两个记录以及它们之间的一对多（包括一对一</strong></strong><strong><strong>)</strong></strong><strong><strong>的联系</strong></strong></p> 
<ol><li style="text-align:justify;">面向对象模型(Object Oriented Model）数据结构：对象</li><li style="text-align:justify;">关系模型(Relational Model)    数据结构：表</li><li style="text-align:justify;">层次模型<strong><strong>满足下面两个条件的基本层次联系的集合为层次模型。①</strong></strong><strong><strong>有且只有一个结点没有双亲结点，这个结点称为根结点   ②根以外的其它结点有且只有一个双亲结点</strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">表示方法</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>实体型：用记录类型描述。</strong></strong><strong><strong>每个结点表示一个记录类型。</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>属性：用字段描述。每个记录类型可包含若干个字段。</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>联系：用结点之间的连线表示记录（类）型之间的</strong><strong>一对多的联系。</strong></strong></p> 
<p><img alt="" height="720" src="https://images2.imgbox.com/d1/f6/h7PlFFKN_o.png" width="1018"></p> 
<p>层次模型的特点： </p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="599" src="https://images2.imgbox.com/41/42/5Ng8k3gS_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> 层次模型的优缺点：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="557" src="https://images2.imgbox.com/21/03/6nZbNCaZ_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>网状数据模型的数据结构</strong></strong></p> 
<p style="text-align:justify;">网状模型：<strong><strong>满足下面两个条件的基本层次联系的集合为网状模型。①允许一个以上的结点无双亲；②一个结点可以有多于一个的双亲</strong></strong>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">表示方法（与层次数据模型相同）</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>实体型：用记录类型描述。</strong>     <strong>每个结点表示一个记录类型。</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>属性：用字段描述。</strong> <strong>每个记录类型可包含若干个字段。</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>联系：用结点之间的连线表示记录（类）型之</strong></strong><strong><strong>间的一对多的父子联系。</strong></strong></p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/df/45/dNpweGZy_o.png" width="1030"></p> 
<p></p> 
<p>       网状模型与层次模型的区别 ： 网状模型<span style="color:#fe2c24;"><strong>允许多个结点没有双亲结点</strong></span> ；网状模型允许<strong>结点有多个双亲结点</strong>； 网状模型允许<strong>两个结点之间有多种联系（复合联系）</strong> ；网状模型可以更直接地去描述现实世界 ；层次模型实际上是<span style="color:#fe2c24;"><strong>网状模型的一个特例</strong></span></p> 
<p></p> 
<p>网状模型的优缺点： </p> 
<p><img alt="" height="555" src="https://images2.imgbox.com/98/9a/ckejQfY1_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>关系模型的基本概念</strong></strong></p> 
<p>关系（Relation）一个关系对应通常说的一张表。</p> 
<p style="margin-left:.0001pt;text-align:justify;">元组（Tuple）表中的一行即为一个元组。</p> 
<p> 属性（Attribute）表中的一列即为一个属性，给每一个属性起一个名称即属性名。关系必须是规范化的，满足一定的规范条件</p> 
<p style="text-align:justify;">表示方法</p> 
<p style="text-align:justify;">实体型：用关系表表示</p> 
<p style="text-align:justify;">属性：用属性名表示</p> 
<p style="text-align:justify;">联系：  一对一：隐含在实体对应关系中 </p> 
<p style="text-align:justify;">           一对多：隐含在实体对应关系中 </p> 
<p style="text-align:justify;">             多对多：用新的关系表表示</p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">关系必须是规范化的，满足一定的规范条件,如 <span style="color:#1c7892;"><strong>不允许表中还有表</strong></span>。<strong><strong>最基本的规范条件：关系的每一个分量必须是一个不可分的数据项。</strong></strong>  </p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p>关系数据模型的优缺点 </p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="611" src="https://images2.imgbox.com/b9/99/0YprFsPl_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;">关系数据模型的操纵与完整性约束</p> 
<ol><li style="text-align:justify;">查询、插入、删除、更新</li><li style="text-align:justify;">数据操作是集合操作，<u><u>操作对象和操作结果都是关系，</u></u>即若干元组的集合</li><li style="text-align:justify;">存取路径对用户隐蔽，用户只要指出“干什么”，<u><u>不必详细说明</u></u><u><u>“</u></u><u><u>怎么干</u></u><u><u>”</u></u></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>关系模型的完整性约束</strong></strong></p> 
<ol><li style="text-align:justify;">实体完整性</li><li style="text-align:justify;">参照完整性</li><li style="text-align:justify;">用户定义的完整性</li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>关系数据模型的存储结构</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">① 表以文件形式存储</p> 
<p style="margin-left:.0001pt;text-align:justify;">② 有的DBMS一个表对应一个操作系统文件</p> 
<p style="margin-left:.0001pt;text-align:justify;">③ 有的DBMS自己设计文件结构</p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>关系模型的优缺点</strong></strong></p> 
<ol><li style="text-align:justify;">优点 
  <ol><li style="text-align:justify;"><strong><strong>建立在严格的数学概念的基础上</strong></strong></li><li style="text-align:justify;"><strong><strong>概念单一。数据结构简单、清晰，用户易懂易用</strong></strong> 
    <ol><li style="text-align:justify;"><strong><strong>实体和各类联系都用关系来表示。</strong></strong></li><li style="text-align:justify;"><strong><strong>对数据的检索结果也是关系。</strong></strong></li></ol></li><li style="text-align:justify;">关系模型的存取路径对用户透明 
    <ol><li style="text-align:justify;"><strong><strong>具有更高的数据独立性，更好的安全保密性</strong></strong></li><li style="text-align:justify;"><strong><strong>简化了程序员的工作和数据库开发建立的工作</strong></strong></li></ol></li></ol></li><li style="text-align:justify;">缺点</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>①  存取路径对用户透明导致查询效率往往不如非关系数据模型</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>②  为提高性能，必须对用户的</strong><u><strong><u>查询请求进行优化</u></strong></u></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>③  增加了开发数据库管理系统的难度</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h4 style="margin-left:.0001pt;text-align:justify;">数据库系统结构</h4> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="696" src="https://images2.imgbox.com/aa/1d/X8Fx6zdl_o.png" width="1200"></p> 
<p></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong> </strong>数据库系统的三级模式结构</h4> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/d2/6f/tAwjtxJC_o.png" width="1200"></p> 
<p> <img alt="" height="968" src="https://images2.imgbox.com/5b/97/tOwMVREs_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p><strong>数据库的二级映像功能与数据独立性</strong></p> 
<p><img alt="" height="677" src="https://images2.imgbox.com/45/21/yRdpV0AL_o.png" width="1200"></p> 
<p><img alt="" height="750" src="https://images2.imgbox.com/25/8d/chizt27Q_o.png" width="1200"></p> 
<p><strong> 外模式/模式映像</strong></p> 
<p><img alt="" height="700" src="https://images2.imgbox.com/43/75/KAxKwtcl_o.png" width="1200"></p> 
<p>       映象定义通常包含在各自外模式的描述中<span style="color:#fe2c24;"><strong>保证数据的逻辑独立性</strong></span> ；当模式改变时，数据库管理员修改有关的外模式／模式映象，可以使外模式保持不变； 应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。 修改 外模式/模式 的映射（create view）  外模式／模式映象可以保证获得一定程度的数据的逻辑独立性（非 完全独立）。</p> 
<p></p> 
<p><strong>模式／内模式映象</strong></p> 
<p>      模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系 。例如，说明逻辑记录和字段在内部是如何表示的。</p> 
<p>      数据库中模式／内模式映象是唯一的。 该映象定义通常包含在模式描述中。保证数据的物理独立性。</p> 
<p>         当数据库的存储结构改变了，数据库管理员修改模式／ 内模式映象，使模式保持不变。例如，存储结构：由堆存储—hash存储， 从而应用程序不受影响。</p> 
<p>      保证了数据与程序的物理独立性，简称数据的物理独立性 。</p> 
<p><span style="color:#fe2c24;"><strong> 模式／内模式映象保证获得完全的数据物理独立性</strong></span></p> 
<h4>总结：</h4> 
<p> <img alt="" height="724" src="https://images2.imgbox.com/f6/43/BV2CRPM3_o.png" width="1200"><img alt="" height="737" src="https://images2.imgbox.com/1a/f7/vp3L4v8d_o.png" width="1200"></p> 
<p></p> 
<p> <img alt="" height="799" src="https://images2.imgbox.com/5e/0b/8KaDhhJg_o.png" width="1200"></p> 
<p style="text-align:justify;"><img alt="" height="640" src="https://images2.imgbox.com/b4/29/GV6e9mt5_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>分布式结构的数据库系统</strong></strong></p> 
<ol><li style="text-align:justify;">数据库中的数据在<u><u>逻辑上是一个整体</u></u>，但<u><u>物理地分布</u></u>在计算机网络的不同结点上。 
  <ol><li style="text-align:justify;"><strong><strong>网络中的每个结点都可以独立处理本地数据库中的数据，执行局部应用</strong></strong></li><li style="text-align:justify;"><strong><strong>同时也可以同时存取和处理多个异地数据库中的数据，执行全局应用</strong></strong></li></ol></li><li style="text-align:justify;">优点 
  <ol><li style="text-align:justify;"><strong><strong>适应了地理上分散的公司、团体和组织对于数据库应用的需求。</strong></strong></li></ol></li><li style="text-align:justify;">缺点 
  <ol><li style="text-align:justify;"><strong><strong>数据的分布存放给数据的处理、管理与维护带来困难。</strong></strong></li><li style="text-align:justify;"><strong><strong>当用户需要经常访问远程数据时，系统效率会明显地受到网络传输的制约</strong></strong></li></ol></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>数据库管理员</strong></strong><strong><strong>(DBA)</strong></strong></p> 
<ol><li style="text-align:justify;">决定数据库中的信息内容和结构</li><li style="text-align:justify;">决定数据库的存储结构和存取策略</li><li style="text-align:justify;">定义数据的安全性要求和完整性约束条件</li></ol> 
<p></p> 
<p></p> 
<h2>（二）<strong><strong>关系数据库</strong></strong></h2> 
<ol><li style="text-align:justify;">关系模型的组成 
  <ol><li style="text-align:justify;">关系数据结构</li><li style="text-align:justify;">关系操作集合</li><li style="text-align:justify;">关系完整性约束</li></ol></li><li style="text-align:justify;">1) 常用的关系操作 
  <ol><li style="text-align:justify;">查询：选择、投影、连接、除、并、交、差</li><li style="text-align:justify;">数据更新：插入、删除、修改</li><li style="text-align:justify;">查询的表达能力是其中最主要的部分                                                                                          </li></ol></li><li style="text-align:justify;">2) 关系操作的特点 
  <ol><li style="text-align:justify;">集合操作方式，即操作的对象和结果都是集合。 
    <ol><li style="text-align:justify;">非关系数据模型的数据操作方式：一次一记录</li><li style="text-align:justify;">文件系统的数据操作方式</li></ol></li></ol></li><li style="text-align:justify;">3) 关系数据语言的种类 
  <ol><li style="text-align:justify;">关系代数语言   
    <ol><li style="text-align:justify;">用对关系的运算来表达查询要求</li></ol></li></ol></li><li style="text-align:justify;">4) 关系数据语言的特点 
  <ol><li style="text-align:justify;">关系语言是一种高度非过程化的语言： 
    <ol><li style="text-align:justify;">存取路径的选择由DBMS的优化机制来完成</li><li style="text-align:justify;">用户不必用循环结构就可以完成数据操作</li></ol></li><li style="text-align:justify;">能够嵌入高级语言中使用</li><li style="text-align:justify;">关系代数、元组关系演算和域关系演算三种语言在表达能力上完全等价</li></ol></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>关系</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>域（Domain）  </strong></p> 
<blockquote> 
 <p style="text-align:justify;"> 域是一组具有相同数据类型的值的集合。例：</p> 
 <p style="text-align:justify;">1. 整数</p> 
 <p style="text-align:justify;">2.介于某个取值范围的日期</p> 
 <p style="text-align:justify;">3.{‘男’，‘女’}</p> 
 <p style="text-align:justify;">4.长度指定长度的字符串集合</p> 
 <p style="text-align:justify;">5.介于某个取值范围的整数</p> 
 <p style="text-align:justify;">6.实数</p> 
</blockquote> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> 笛卡尔积（Cartesian Product）</strong>给定一组域<em><em>D</em></em>1，<em><em>D</em></em>2，…，<em><em>Dn</em></em>，这些域中可以有相同的。<em><em>D</em></em>1，<em><em>D</em></em>2，<em><em>…</em></em>，<em><em>Dn</em></em>的笛卡尔积为：</p> 
<p> <em><em>D</em></em>1×<em><em>D</em></em>2×…×<em><em>Dn</em></em>＝｛（<em><em>d</em></em>1，<em><em>d</em></em>2，…，<em><em>dn</em></em>）｜<em><em>di</em></em>Î<em><em>Di</em></em>，<em><em>i</em></em>＝1，2，…，<em><em>n</em></em>｝</p> 
<p style="margin-left:.0001pt;text-align:justify;">所有域的所有取值的一个组合   不能重复</p> 
<p></p> 
<p>        元组（Tuple）笛卡尔积中每一个元素（<em><em>d</em></em>1，<em><em>d</em></em>2，…，<em><em>dn</em></em>）叫作一个<em><em>n</em></em>元组（n-tuple）或简称元组。</p> 
<p style="margin-left:.0001pt;text-align:justify;">   </p> 
<ol><li style="text-align:justify;">3) 分量（Component） 
  <ol><li style="text-align:justify;">笛卡尔积元素（<em><em>d</em></em>1，<em><em>d</em></em>2，…，<em><em>dn</em></em>）中的每一个值<em><em>di</em></em>叫作一个分量。</li></ol></li><li style="text-align:justify;">4) 基数（Cardinal number） 
  <ol><li style="text-align:justify;">若<em><em>Di</em></em>（<em><em>i</em></em>＝1，2，…，<em><em>n</em></em>）为有限集，其基数为<em><em>mi</em></em>（<em><em>i</em></em>＝1，2，…，<em><em>n</em></em>），则<em><em>D</em></em>1×<em><em>D</em></em>2×…×<em><em>Dn</em></em>的基数<em><em>M</em></em>为：</li></ol></li><li style="text-align:justify;">5)笛卡尔积的表示方法 
  <ol><li style="text-align:justify;">笛卡尔积可表示为一个二维表。表中的每行对应一个元组，表中的每列对应一个域。</li></ol></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>关系（Relation）</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">1) 关系</p> 
<p style="margin-left:.0001pt;text-align:justify;"><em><em>D</em></em>1×<em><em>D</em></em>2×…×<em><em>Dn</em></em>的子集叫作在域<em><em>D</em></em>1，<em><em>D</em></em>2，…，<em><em>Dn</em></em>上的关系，表示为 <em><em>R</em></em>（<em><em>D</em></em>1，<em><em>D</em></em>2，…，<em><em>Dn</em></em>）</p> 
<p style="margin-left:.0001pt;text-align:justify;">         <em><em>R</em></em><em><em>：</em></em>关系名</p> 
<p style="margin-left:.0001pt;text-align:justify;"><em><em>         n</em></em><em><em>：</em></em>关系的目或度（Degree）</p> 
<p style="margin-left:.0001pt;text-align:justify;">2) 元组</p> 
<p style="margin-left:.0001pt;text-align:justify;">关系中的每个元素是关系中的元组，通常用<em><em>t</em></em>表示。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">3) 单元关系与二元关系</p> 
<p style="margin-left:.0001pt;text-align:justify;">当<em><em>n</em></em>=1时，称该关系为单元关系（Unary relation）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">当<em><em>n</em></em>=2时，称该关系为二元关系（Binary relation）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">4) 关系的表示</p> 
<p style="margin-left:.0001pt;text-align:justify;">关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">5) 属性</p> 
<p style="margin-left:.0001pt;text-align:justify;">关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性（Attribute）。<strong>   <em><em>n</em></em>目关系必有<em><em>n</em></em>个属性。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">6) 码</p> 
<p style="margin-left:.0001pt;text-align:justify;"><u><u>候选码（</u></u><u><u>Candidate key</u></u><u><u>）</u></u></p> 
<p style="margin-left:.0001pt;text-align:justify;">①若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码</p> 
<p style="margin-left:.0001pt;text-align:justify;">②在最简单的情况下，候选码只包含一个属性。<u><u>称为全码（</u></u><u><u>All-key</u></u><u><u>）</u></u></p> 
<p style="margin-left:.0001pt;text-align:justify;">在最极端的情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><u><u>主码</u></u></p> 
<p style="margin-left:.0001pt;text-align:justify;">若一个关系有多个候选码，则选定其中一个为主码（Primary key）主码的诸属性称为<u><u>主属性</u></u>（Prime attribute）。不包含在任何<strong>侯选码</strong>中的属性称为<u><u>非码属性</u></u>（Non-key attribute） </p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">7) 三类关系</p> 
<p style="margin-left:.0001pt;text-align:justify;"><u><u>基本关系</u></u>（基本表或基表）实际存在的表，是实际存储数据的逻辑表示。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><u><u>查询表</u></u>    结果对应的表。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><u><u>视图表</u></u>      由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。</p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>基本关系的性质</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">① 列是同质的（Homogeneous）</p> 
<p style="margin-left:.0001pt;text-align:justify;">每一列中的分量是同一类型的数据，来自同一个域</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">② 不同的列可出自同一个域</p> 
<p style="margin-left:.0001pt;text-align:justify;">其中的每一列称为一个属性       不同的属性要给予不同的属性名</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">③ 列的顺序无所谓</p> 
<p style="margin-left:.0001pt;text-align:justify;">列的次序可以任意交换  ，遵循这一性质的数据库产品(如ORACLE)，增加新属性时，永远是插至最后一列，但也有许多关系数据库产品没有遵循这一性质，例如FoxPro仍然区分了属性顺序。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">④ 任意两个元组不能完全相同</p> 
<p style="margin-left:.0001pt;text-align:justify;">由笛卡尔积的性质决定但许多关系数据库产品没有遵循这一性质。例如:Oracle，FoxPro等都允许关系表中存在两个完全相同的元组，除非用户特别定义了相应的约束条件。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">⑤ 行的顺序无所谓</p> 
<p style="margin-left:.0001pt;text-align:justify;">行的次序可以任意交换，遵循这一性质的数据库产品(如ORACLE)，插入一个元组时永远插至最后一行，但也有许多关系数据库产品没有遵循这一性质，例如FoxPro仍然区分了元组的顺序。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">⑥ 分量必须取原子值</p> 
<p style="margin-left:.0001pt;text-align:justify;">每一个分量都必须是不可分的数据项。这是规范条件中最基本的一条</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">关系模式（Relation Schema）是型。关系是值关系模式是对关系的描述，它包括以下要素：</p> 
<ol><li> <p>元组集合的结构：关系模式定义了元组的集合，每个元组代表关系中的一个实例。</p> </li><li> <p>属性构成：关系模式指定了关系中的属性，每个属性代表关系中的一个特征或字段。</p> </li><li> <p>属性来自的域：每个属性来自于一个特定的域，域定义了属性的取值范围。</p> </li><li> <p>属性与域之间的映象关系：关系模式指定了属性与域之间的映射关系，确保属性的取值符合域的要求。</p> </li><li> <p>元组语义以及完整性约束条件：关系模式可以包含有关元组语义和完整性约束条件的描述，用于限制关系中的数据。</p> </li><li> <p>属性间的数据依赖关系集合：关系模式可以包含属性间的数据依赖关系集合，用于描述属性之间的相互关系，例如主键、外键、函数依赖等。</p> </li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>定义关系模式</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">关系模式可以形式化地表示为：</p> 
<p style="margin-left:.0001pt;text-align:justify;">     <em><em>R</em></em>（<em><em>U</em></em>，<em><em>D</em></em>，dom，<em><em>F</em></em>）</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><em><em> R  </em></em></td><td>关系名</td></tr><tr><td><em><em>U</em></em></td><td>       组成该关系的属性名集合</td></tr><tr><td><em><em>D</em></em>  </td><td>   属性组<em><em>U</em></em>中属性所来自的域</td></tr><tr><td>dom</td><td>  属性向域的映象集合</td></tr><tr><td><em><em>F</em></em>   </td><td>  属性间的数据依赖关系集合</td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;"><em><em>    </em></em></p> 
<p style="margin-left:.0001pt;text-align:justify;"> 关系模式通常可以简记为  <em><em>R </em></em>(<em><em>U</em></em>)    或    <em><em>R </em></em>(<em><em>A</em></em>1，<em><em>A</em></em>2，…，<em><em>An ）  </em></em> </p> 
<p style="margin-left:.0001pt;text-align:justify;"><em><em>                                         R   </em></em>关系名  </p> 
<p style="margin-left:.0001pt;text-align:justify;"><em><em>                                       A</em></em>1，<em><em>A</em></em>2，…，<em><em>An      </em></em>属性名</p> 
<p style="margin-left:.0001pt;text-align:justify;">注：<em><em>A</em></em>1，<em><em>A</em></em>2，…，<em><em>An为属性名；</em></em>域名及属性向域的映象常常直接说明为属性的类型、长度。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><u><u>关系模式</u></u>：对关系的描述静态的、稳定的</p> 
<p style="margin-left:.0001pt;text-align:justify;"><u><u>关系</u></u>：关系模式在某一时刻的状态或内容动态的、随时间不断变化的，关系模式和关系往往统称为关系。两者通过上下文加以区别。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1. </strong></strong><strong><strong>关系数据库</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">在一个给定的应用领域中，所有实体及实体之间联系的关系的集合构成一个关系数据库。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2. </strong></strong><strong><strong>关系数据库的型与值</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">关系数据库也有型和值之分，<u><u>关系数据库的型</u></u>称为关系数据库模式，是对关系数据库的描述</p> 
<p style="margin-left:.0001pt;text-align:justify;">若干域的定义，在这些域上定义的若干关系模式，<u><u>关系数据库的值</u></u>是这些关系模式在某一时刻对应的关系的集合，通常简称为关系数据库</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3  </strong></strong><strong><strong>关系的完整性</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">    关系模型的完整性规则是对关系的某种约束条件。</p> 
<p style="margin-left:.0001pt;text-align:justify;">关系模型中三类完整性约束：</p> 
<p style="margin-left:.0001pt;text-align:justify;">实体完整性</p> 
<p style="margin-left:.0001pt;text-align:justify;">参照完整性</p> 
<p style="margin-left:.0001pt;text-align:justify;">用户定义的完整性</p> 
<p style="margin-left:.0001pt;text-align:justify;">     <span style="color:#fe2c24;"><strong> 实体完整性和参照完整性</strong></span>是关系模型必须满足的完整性约束条件，被称作是关系的两个<strong><u><strong><u>不变性</u></strong></u></strong>，应该由关系系统自动支持。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>实体完整性</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">实体完整性规则（Entity Integrity）</p> 
<p style="margin-left:.0001pt;text-align:justify;">若属性<em><em>A</em></em>是基本关系<em><em>R</em></em>的主属性，则属性<em><em>A</em></em>不能取空值。</p> 
<p style="margin-left:.0001pt;text-align:justify;">关系模型必须遵守实体完整性规则的原因：</p> 
<p style="margin-left:.0001pt;text-align:justify;">(1) 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集或多对多联系。</p> 
<p style="margin-left:.0001pt;text-align:justify;">(2) 现实世界中的实体和实体间的联系都是可区分的，即它们具有某种唯一性标识。</p> 
<p style="margin-left:.0001pt;text-align:justify;">(3) 相应地，关系模型中以主码作为唯一性标识。</p> 
<p style="margin-left:.0001pt;text-align:justify;">(4) 主码中的属性即主属性不能取空值。  空值就是“不知道”或“无意义”的值。</p> 
<p style="margin-left:.0001pt;text-align:justify;">     主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第（2）点相矛盾，因此这个规则称为实体完整性。</p> 
<p style="margin-left:.0001pt;text-align:justify;">注意   ：<strong>实体完整性规则规定基本关系的所有，主属性都不能取空值。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>参照完整性</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">1. 关系间的引用</p> 
<p style="margin-left:.0001pt;text-align:justify;">2. 外码</p> 
<p style="margin-left:.0001pt;text-align:justify;">3. 参照完整性规则</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>关系间的引用</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">在关系模型中实体及实体间的联系都是用关系来描述的，因此可能存在着关系与关系间的引用。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2</strong></strong><strong><strong>．外码（</strong></strong><strong><strong>Foreign Key</strong></strong><strong><strong>）</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">设<em><em>F</em></em>是基本关系<em><em>R</em></em>的一个或一组属性，但不是关系<em><em>R</em></em>的码。如果F与基本关系<em><em>S</em></em>的主码Ks相对应，则称F是基本关系<em><em>R</em></em>的外码。基本关系<em><em>R</em></em><em><em>称</em></em>为参照关系（Referencing  Relation）基本关系<em><em>S</em></em><em><em>称</em></em>为被参照关系（ReferencedRelation）或目标关系（Target Relation）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">说明</p> 
<ol><li style="text-align:justify;">关系<em><em>R</em></em>和<em><em>S</em></em>不一定是不同的关系</li><li style="text-align:justify;">目标关系<em><em>S</em></em>的主码Ks 和参照关系的外码F必须定义在同一个（或一组）域上</li><li style="text-align:justify;">外码并不一定要与相应的主码同名</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">   当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3. </strong></strong><strong><strong>参照完整性规则</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">若属性（或属性组）<em><em>F</em></em>是基本关系<em><em>R</em></em>的外码，它与基本关系<em><em>S</em></em>的主码Ks相对应（基本关系<em><em>R</em></em>和<em><em>S</em></em>不一定是不同的关系），则对于<em><em>R</em></em>中每个元组在<em><em>F</em></em>上的值必须为：</p> 
<p style="margin-left:.0001pt;text-align:justify;">· 或者取空值（<em><em>F</em></em>的每个属性值均为空值）</p> 
<p style="margin-left:.0001pt;text-align:justify;">· 或者等于<em><em>S</em></em>中某个元组的主码值。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong> </strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong> </strong></strong><strong><strong>用户定义的完整性</strong></strong></p> 
<ol><li style="text-align:justify;">用户定义的完整性是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。</li><li style="text-align:justify;">关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不要由应用程序承担这一功能。</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">Operation  运算，操作</p> 
<p style="margin-left:.0001pt;text-align:justify;">Operator    算子</p> 
<p style="margin-left:.0001pt;text-align:justify;">Operand     操作数</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">1.关系代数</p> 
<p style="margin-left:.0001pt;text-align:justify;">一种抽象的查询语言，用对关系的运算来表达查询</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">2．关系代数运算的三个要素</p> 
<p style="margin-left:.0001pt;text-align:justify;">运算对象：关系</p> 
<p style="margin-left:.0001pt;text-align:justify;">运算结果：关系</p> 
<p style="margin-left:.0001pt;text-align:justify;">运算符：2类（集合运算和关系运行）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>关系代数运算符</strong></strong> </p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td colspan="2" rowspan="1" style="text-align:center;">运算符</td><td>含义</td></tr><tr><td colspan="1" rowspan="4">集合运算符</td><td>∪</td><td>并</td></tr><tr><td>－</td><td>差</td></tr><tr><td>∩</td><td>交</td></tr><tr><td>×</td><td>笛卡尔积</td></tr><tr><td colspan="1" rowspan="4">专门的关系运算符</td><td>σ</td><td>选择</td></tr><tr><td>∏</td><td>投影</td></tr><tr><td><img alt="" height="80" src="https://images2.imgbox.com/8d/34/BGj3xjyE_o.png" width="91"></td><td>连接</td></tr><tr><td>÷</td><td>除</td></tr></tbody></table> 
<p></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">4．关系代数运算的分类</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 传统的集合运算</p> 
<p style="margin-left:.0001pt;text-align:justify;">            并、差、交、广义笛卡尔积</p> 
<p style="margin-left:.0001pt;text-align:justify;">专门的关系运算</p> 
<p style="margin-left:.0001pt;text-align:justify;">            选择、投影、连接、除</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">5．<strong>常用的表示记号 </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">（1）<strong> R，t∈R，t[Ai]</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"> 设关系模式为<em><em>R</em></em>(<em><em>A</em></em>1，<em><em>A</em></em>2，…，<em><em>An</em></em>)，它的一个关系设为<em><em>R</em></em>。<em><em>t</em></em>∈<em><em>R</em></em>表示<em><em>t</em></em>是<em><em>R</em></em>的一个元组，<em><em>t</em></em>[<em><em>Ai</em></em>]则表示元组<em><em>t</em></em>中相应于属性<em><em>Ai</em></em>的一个分量 。</p> 
<p style="margin-left:.0001pt;text-align:justify;">（2）</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong><img alt="" height="583" src="https://images2.imgbox.com/5b/18/pmaalDor_o.png" width="1200"></p> 
<p></p> 
<p>（3） </p> 
<p><em> </em><img alt="" height="723" src="https://images2.imgbox.com/54/af/w4Xzzg3i_o.png" width="1200"></p> 
<p></p> 
<p>（4） <img alt="" height="1200" src="https://images2.imgbox.com/af/ee/ZS2SeWXq_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h4 style="margin-left:.0001pt;text-align:justify;">传统的集合运算（<span style="color:#fe2c24;">关系代数运算</span>是以<span style="background-color:#ffd900;">集合运算为基础</span>的运算）</h4> 
<p style="margin-left:.0001pt;text-align:justify;"><em><em>①</em></em><strong><strong>并（</strong></strong><strong><strong>Union）关系R与关系S的并记作   </strong></strong><em><em>R</em></em>∪<em><em>S</em></em> = { <em><em>t</em></em>|<em><em>t∈R</em></em>∨<em><em>t </em></em>∈<em><em>S </em></em>} 仍为<em><em>n</em></em>目关系，由属于<em><em>R</em></em>或属于<em><em>S</em></em>的元组组成</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">②<strong> 差（execpt）<strong>关系R与关系S的差记作  </strong></strong><em><em>R </em></em>-<em><em>S</em></em> = { <em><em>t</em></em>|<em><em>t</em></em>∈<em><em>R</em></em>∧<em><em>t</em></em>∉<em><em>S</em></em> }  仍为<em><em>n</em></em>目关系，由<span style="color:#fe2c24;">属于<em><em>R</em></em>而不属于<em><em>S</em></em></span>的所有元组组成</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">③交  <strong><strong>关系R与关系S的交记作  </strong></strong><em><em>  R</em></em>∩<em><em>S</em></em> = { <em><em>t</em></em>|<em><em>t</em></em>∈ <em><em>R</em></em>∧<em><em>t </em></em>∈<em><em>S </em></em>}或者<em><em>  R</em></em>∩<em><em>S</em></em> = <em><em>R</em></em> –(<em><em>R</em></em>-<em><em>S</em></em>）仍为<em><em>n</em></em>目关系，由既属于<em><em>R</em></em>又属于<em><em>S</em></em>的元组组成</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>④ 笛卡尔积</strong> <strong><strong> </strong></strong><strong><strong>广义笛卡尔积（</strong></strong><strong><strong>Extended Cartesian Product</strong></strong><strong><strong>）</strong></strong></p> 
<p style="text-align:justify;"><img alt="" height="700" src="https://images2.imgbox.com/a9/a0/IgB6hfgG_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>专门的关系运算</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1. </strong></strong><strong><strong>选择（</strong></strong><strong><strong>Selection</strong></strong><strong><strong>）</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/0d/16/je73MQNk_o.png" width="1200"></p> 
<p></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2. </strong></strong><strong><strong>投影（</strong></strong><strong><strong>Projection</strong></strong><strong><strong>）</strong></strong><strong> </strong></p> 
<p style="text-align:justify;"><img alt="" height="819" src="https://images2.imgbox.com/8d/fa/Dy3LpdVe_o.png" width="1200"></p> 
<p></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3. </strong></strong><strong><strong>连接（</strong></strong><strong><strong>Join</strong></strong><strong><strong>）</strong></strong><strong> </strong></p> 
<p style="text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/d4/54/IsDq544x_o.png" width="1200"></p> 
<p><strong> 关于连接的一些概念：</strong></p> 
<p><strong>悬浮元祖（ dangling tuple ）</strong> ：两个关系R和S在做自然连接时，关系R中某些元 组有可能在S中不存在公共属性上值相等的元组 ，从而造成R中这些元组在操作时被舍弃了，这 些被舍弃的元组称为悬浮元组。</p> 
<p><strong>外连接 （OUTER JOIN）</strong></p> 
<p>如果把舍弃的元组也保存在结果关系中，而在其他 属性上填空值(Null)，这种连接就叫做外连接。 </p> 
<p></p> 
<p><strong>左外连接(LEFT OUTER JOIN或LEFT JOIN)（<span style="color:#fe2c24;">留哪边就叫 啥外连接</span>）</strong></p> 
<p> 如果只把左边关系R中要舍弃的元组保留就叫做左外连接</p> 
<p><strong>右外连接</strong></p> 
<p>如果只把右边关系S中要舍弃的元组保留就叫做右外连接(RIGHT OUTER JOIN或RIGHT JOIN)。</p> 
<p></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4. </strong></strong><strong><strong>除（</strong></strong><strong><strong>Division</strong></strong><strong><strong>）</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong><img alt="" height="1200" src="https://images2.imgbox.com/a9/4d/kJaS45B1_o.png" width="1200"></p> 
<p></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"></h3> 
<h2 style="margin-left:.0001pt;text-align:justify;"><strong><strong>（三）关系数据库标准语言SQL</strong></strong></h2> 
<h3 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.1 SQL</strong></strong><strong><strong>概述</strong></strong></h3> 
<p><img alt="" height="1070" src="https://images2.imgbox.com/1d/42/X4MH7FI6_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p style="text-align:justify;"><img alt="" height="765" src="https://images2.imgbox.com/f1/de/mN5HCyAj_o.png" width="975"></p> 
<p> <img alt="" height="755" src="https://images2.imgbox.com/63/d4/XV5Q9B5B_o.png" width="1200"></p> 
<p> <img alt="" height="640" src="https://images2.imgbox.com/90/22/FnkTiv6g_o.png" width="1200"></p> 
<p> <img alt="" height="601" src="https://images2.imgbox.com/63/c3/0cwRsGfz_o.png" width="1200"></p> 
<p><img alt="" height="700" src="https://images2.imgbox.com/88/10/Avqrz0T6_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong></p> 
<p><img alt="" height="690" src="https://images2.imgbox.com/9a/68/VJSnzC5S_o.png" width="1200"></p> 
<p></p> 
<blockquote> 
 <p>概念补充：</p> 
 <p>SQL可以分为<strong>数据定义、数据查询、数据更新、数据控制</strong>四大部分。</p> 
 <p>基本表 ：</p> 
 <p>本身独立存在的表，关系表，是实表；</p> 
 <p>SQL中一个关系就对应一个基本表；</p> 
 <p>一个(或多个)基本表对应一个存储文件；</p> 
 <p>一个表可以带若干索引；</p> 
 <p>存储文件 ：</p> 
 <p>逻辑结构组成了关系数据库的内模式；</p> 
 <p>物理结构是任意的，对用户透明；</p> 
 <p>视图：</p> 
 <p>从一个或几个基本表导出的表；</p> 
 <p>数据库中只存放视图的定义而不存放视图对应的数据；</p> 
 <p>视图是一个虚表；</p> 
 <p>用户可以在视图上再定义视图 （例如，查询语句执行之后的结果）；</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.2  </strong></strong><strong><strong>数</strong></strong><strong> </strong><strong><strong>据</strong></strong><strong> </strong><strong><strong>定</strong></strong><strong> </strong><strong><strong>义</strong></strong><strong> </strong></h3> 
<p><img alt="" height="761" src="https://images2.imgbox.com/32/28/VVUt8xxu_o.png" width="1200"><strong> </strong><img alt="" height="723" src="https://images2.imgbox.com/31/14/YZZof78O_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.2.1模式的定义与删除</strong></strong></h4> 
<p> 定义模式 </p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="807" src="https://images2.imgbox.com/c0/8a/mlo7uNRa_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;">删除模式</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="676" src="https://images2.imgbox.com/8a/1f/zDLVcRpg_o.png" width="1200"></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"></h4> 
<h4 style="margin-left:.0001pt;text-align:justify;">3.2.2基本表</h4> 
<h4 style="margin-left:.0001pt;text-align:justify;">定义基本表</h4> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="742" src="https://images2.imgbox.com/00/d5/3yId4fr0_o.png" width="1200"></p> 
<p></p> 
<p> 常用完整性约束</p> 
<ol><li style="text-align:justify;">主码约束：    PRIMARY  KEY</li><li style="text-align:justify;">唯一性约束：UNIQUE</li><li style="text-align:justify;">非空值约束：NOT NULL</li><li style="text-align:justify;">参照完整性约束</li></ol> 
<p style="text-align:justify;"></p> 
<h4 style="text-align:justify;">PRIMARY KEY与 UNIQUE的区别</h4> 
<blockquote> 
 <p><strong>    PRIMARY KEY</strong>  可空，可以在一个表里的一个或多个字段定义；<strong>PRIMARY KEY</strong> 不可空不可重复，在一个表里可以定义联合主键；</p> 
 <p> 简单的说，<strong>PRIMARY KEY</strong> <strong> =UNIQUE  + NOT NULL</strong></p> 
</blockquote> 
<h4 style="margin-left:.0001pt;text-align:justify;"></h4> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>  删除基本表</strong></strong><strong> </strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;"> <img alt="" height="1175" src="https://images2.imgbox.com/9e/ca/04xk3jIi_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">⑵ 删除属性列</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 直接/间接删除</p> 
<ol><li>把表中要保留的列及其内容复制到一个新表中</li><li>删除原表</li><li>再将新表重命名为原表名</li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">直接删除属性列:(新)</p> 
<p style="margin-left:.0001pt;text-align:justify;">例：ALTER TABLE Student  Drop Scome；</p> 
<p style="margin-left:.0001pt;text-align:justify;">ALTER TABLE Student MODIFY Sage SMALLINT；</p> 
<p style="margin-left:.0001pt;text-align:justify;">注：修改原有的列定义有可能会破坏已有数据</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>修改基本表</strong></strong></h4> 
<h3 style="margin-left:.0001pt;text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/39/5e/Mj5qFIjf_o.png" width="1200"></h3> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h4>表与模式</h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f4/77/boejDcwB_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.3  建立与删除索引</strong></strong><strong> </strong></h3> 
<ol><li style="text-align:justify;">建立索引是<span style="color:#fe2c24;"><strong>加快查询速度</strong></span>的有效手段</li><li style="text-align:justify;">建立索引 
  <ol><li style="text-align:justify;">DBA或表的属主（即建立表的人）根据需要建立；</li><li style="text-align:justify;">有些DBMS自动建立以下列上的索引：                                                                 ①PRIMARY  KEY       ②UNIQUE</li></ol></li><li style="text-align:justify;">维护索引：DBMS自动完成 </li><li style="text-align:justify;">使用索引： DBMS自动选择是否使用索引以及使用哪些索引</li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong> 建立索引</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="617" src="https://images2.imgbox.com/ae/60/IRWOjwC5_o.png" width="1200"></p> 
<p></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">唯一值索引</p> 
<p><img alt="" height="558" src="https://images2.imgbox.com/43/a4/e9RZG0Q2_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p></p> 
<p> 聚簇索引&amp;非聚簇索引 </p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/4d/b1/x4RxpPnO_o.png" width="1200"></p> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;"><strong>更新索引</strong></p> 
<p style="text-align:justify;"><img alt="" height="304" src="https://images2.imgbox.com/3a/cf/Ng67EEof_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong> </strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>删除索引</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="184" src="https://images2.imgbox.com/a8/57/29NNIJSo_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.5 </strong></strong><strong><strong>查</strong></strong><strong>    </strong><strong><strong>询</strong></strong><strong> </strong></h3> 
<p>查询语句：</p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/d3/44/7UXwwyE9_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>①SELECT子句：指定要显示的属性列</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>②FROM子句：指定查询对象(基本表或视图)</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>③ WHERE子句：指定查询条件</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>④ GROUP BY子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用集函数。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⑤HAVING短语：筛选出只有满足指定条件的组</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⑥ORDER BY子句：对查询结果表按指定列值的升序或降序排序</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>  </strong></strong><strong><strong>单表查询</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">查询仅涉及一个表，是一种最简单的查询操作</p> 
<p style="margin-left:.0001pt;text-align:justify;">⑴ 选择表中的若干列</p> 
<p style="margin-left:.0001pt;text-align:justify;">⑵ 选择表中的若干元组</p> 
<p style="margin-left:.0001pt;text-align:justify;">⑶ 对查询结果排序</p> 
<p style="margin-left:.0001pt;text-align:justify;"> ⑷ 使用集函数</p> 
<p style="margin-left:.0001pt;text-align:justify;">⑸ 对查询结果分组 </p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>查询经过计算的值</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">SELECT子句的&lt;目标列表达式&gt;为表达式</p> 
<p style="margin-left:.0001pt;text-align:justify;">①算术表达式     ②字符串常量     ③函数      ④列别名</p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>二、选择表中的若干元组</strong></strong><strong> </strong></p> 
<ol><li style="text-align:justify;">消除取值重复的行：在SELECT子句中使用DISTINCT短语</li><li style="text-align:justify;">查询满足条件的元组 ：</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>WHERE</strong></strong><strong><strong>子句常用的查询条件</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="687" src="https://images2.imgbox.com/a2/e7/4ZXCMXwN_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>(1) </strong></strong><strong><strong>比较大小</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">在WHERE子句的&lt;比较条件&gt;中使用比较运算符</p> 
<ol><li>=，&gt;，&lt;，&gt;=，&lt;=，!= 或 &lt;&gt;，!&gt;，!&lt;， </li><li>逻辑运算符NOT  +  比较运算符</li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>(2) </strong></strong><strong><strong>确定范围</strong></strong></p> 
<p style="text-align:justify;">使用谓词   BETWEEN …  AND  …</p> 
<p style="margin-left:.0001pt;text-align:justify;">                 NOT BETWEEN  …  AND  …</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>(3) </strong></strong><strong><strong>确定集合</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">使用谓词     IN &lt;值表&gt;,  NOT IN &lt;值表&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">          &lt;值表&gt;：用逗号分隔的一组取值</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>(4) </strong></strong><strong><strong>字符串匹配</strong></strong></p> 
<ol><li style="text-align:justify;">[NOT] LIKE  ‘&lt;匹配串&gt;’  [ESCAPE ‘ &lt;换码字符&gt;’]</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">&lt;匹配串&gt;：指定匹配模板</p> 
<p style="margin-left:.0001pt;text-align:justify;">      匹配模板：固定字符串或含通配符的字符串</p> 
<p style="margin-left:.0001pt;text-align:justify;">      当匹配模板为固定字符串时，</p> 
<p style="margin-left:.0001pt;text-align:justify;">      可以用 = 运算符取代 LIKE 谓词</p> 
<p style="margin-left:.0001pt;text-align:justify;">      用 != 或 &lt; &gt;运算符取代 NOT LIKE 谓词</p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>通配符</strong></strong></p> 
<ul><li> <p>% (百分号)  代表任意长度（长度可以为0）的字符串    例：a%b表示以a开头，以b结尾的任意长度的字符串。如acb，addgb，ab 等都满足该匹配串 </p> </li><li> <p>  _ (下横线)  代表任意单个字符      例：a_b表示以a开头，以b结尾的长度为3的任意字符串。如acb，afb等都满足该匹配串</p> </li></ul> 
<p style="margin-left:.0001pt;text-align:justify;">查询DB_Design课程的课程号和学分。</p> 
<p style="margin-left:.0001pt;text-align:justify;">      SELECT Cno，Ccredit</p> 
<p style="margin-left:.0001pt;text-align:justify;">      FROM Course</p> 
<p style="margin-left:.0001pt;text-align:justify;">      WHERE Cname LIKE 'DB\_Design'      </p> 
<p style="margin-left:.0001pt;text-align:justify;">                       ESCAPE '\'</p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>(5) </strong></strong><strong><strong>涉及空值的查询</strong></strong></p> 
<ol><li>使用谓词 IS NULL 或 IS NOT NULL</li><li>“IS NULL” 不能用 “= NULL” 代替</li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>(6) </strong></strong><strong><strong>多重条件查询</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">用逻辑运算符AND和 OR来联结多个查询条件</p> 
<ol><li>AND的优先级高于OR</li><li>可以用括号改变优先级</li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">可用来实现多种其他谓词</p> 
<ol><li> [NOT] IN</li><li> [NOT] BETWEEN …   AND  …</li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>三、对查询结果排序</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">使用ORDER BY子句</p> 
<p>          可以按一个或多个属性列排序： 升序：ASC；降序：DESC；缺省值为升序</p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">当排序列含空值时</p> 
<ol><li>ASC：排序列为空值的元组最后显示</li><li>DESC：排序列为空值的元组最先显示 </li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>四、使用集函数</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"> 主要集函数</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="1025" src="https://images2.imgbox.com/2a/d6/LJeTbGSE_o.png" width="1200"></p> 
<p><span style="color:#0d0016;"><strong>注：处COUNT（*） 外，都跳过空值只处理非空值。</strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>五、对查询结果分组</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>使用GROUP BY子句 分组 </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">细化集函数的作用对象</p> 
<ol><li> 未对查询结果分组，集函数将作用于整个查询结果；对查询结果分组后，集函数将分别作用于每个组 </li><li style="text-align:justify;">GROUP BY子句的作用对象是查询的中间结果表</li><li style="text-align:justify;">分组方法：按指定的一列或多列值分组，值相等的为一组</li><li style="text-align:justify;">使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性和集函数</li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>使用</strong></strong><strong><strong>HAVING</strong></strong><strong><strong>短语筛选最终输出结果</strong></strong></p> 
<ol><li style="text-align:justify;">只有满足HAVING短语指定条件的组才输出</li><li style="text-align:justify;">HAVING短语与WHERE子句的区别：作用对象不同  WHERE子句作用于基表或视图，从中选择满足条件的元组   ②HAVING短语作用于组，从中选择满足条件的组。 </li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>连接查询</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">同时涉及多个表的查询称为<span style="color:#fe2c24;"><strong>连接查询</strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;">用来连接两个表的条件称为<strong>连接条件或连接谓词</strong> </p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="769" src="https://images2.imgbox.com/3c/6c/Qfeffkkf_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>连接操作的执行过程</strong></strong></p> 
<ol><li style="text-align:justify;">嵌套循环法(NESTED-LOOP) 
  <ol><li style="text-align:justify;">首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。</li><li style="text-align:justify;">表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组。</li><li style="text-align:justify;">重复上述操作，直到表1中的全部元组都处理完毕 </li></ol></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>排序合并法</strong></strong><strong><strong>(SORT-MERGE)</strong></strong></p> 
<p style="text-align:justify;"><img alt="" height="585" src="https://images2.imgbox.com/a5/be/WLIt3PyG_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>索引连接</strong></strong><strong><strong>(INDEX-JOIN)</strong></strong></p> 
<p>对表2按连接字段建立索引；</p> 
<p>对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组 </p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">SQL中连接查询的主要类型</p> 
<p style="margin-left:.0001pt;text-align:justify;">广义笛卡尔积；等值连接(含自然连接)；  非等值连接查询；自身连接查询；外连接查询；复合条件连接查询</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>一、广义笛卡尔积</strong></strong><strong> </strong></p> 
<ol><li style="text-align:justify;">不带连接谓词的连接</li><li style="text-align:justify;"> 很少使用</li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>二、等值与非等值连接查询</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>等值连接</strong></strong></p> 
<ol><li style="text-align:justify;">连接运算符为 = 的连接操作 
  <ol><li style="text-align:justify;"> [&lt;表名1&gt;.]&lt;列名1&gt;  =  [&lt;表名2&gt;.]&lt;列名2&gt;</li><li style="text-align:justify;">任何子句中引用表1和表2中同名属性时，都必须加表名前缀。引用唯一属性名时可以加也可以省略表名前缀。 </li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>自然连接</strong></strong></p> 
<ol><li style="text-align:justify;">等值连接的一种特殊情况，把目标列中重复的属性列去掉。</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>非等值连接查询</strong></strong> </p> 
<p style="margin-left:.0001pt;text-align:justify;">连接运算符 不是 = 的连接操作</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>三、自身连接</strong></strong><strong> </strong></p> 
<ol><li style="text-align:justify;">一个表与其自己进行连接，称为表的自身连接。</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="text-align:justify;">     2.需要给表起别名以示区别。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="text-align:justify;">      3.由于所有属性名都是同名属性，因此必须使用别名前缀。</p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>四、外连接（</strong></strong><strong><strong>Outer Join</strong></strong><strong><strong>）</strong></strong><strong> </strong></p> 
<p>外连接与普通连接的区别</p> 
<p> ① 普通连接操作只输出满足连接条件的元组</p> 
<p>② 外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</p> 
<p>③在表名后面加外连接操作符(*)或(+)指定非主体表</p> 
<p>④非主体表有一“万能”的虚行，该行全部由空值组成</p> 
<p>⑤虚行可以和主体表中所有不满足连接条件的元组进行连接</p> 
<p>⑥由于虚行各列全部是空值，因此与虚行连接的结果中，来自非主体表的属性值全部是空值 </p> 
<p>  注意：</p> 
<p><strong> 左外连接：外连接符出现在连接条件的左边   </strong>  <span style="color:#fe2c24;"><strong> 右外连接：外连接符出现在连接条件的右边 </strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>五、复合条件连接</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">WHERE子句中含多个连接条件时，称为复合条件连接</p> 
<ol><li style="text-align:justify;">嵌套查询概述 
  <ol><li style="text-align:justify;">一个SELECT-FROM-WHERE语句称为一个查询块</li><li style="text-align:justify;">将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</li><li style="text-align:justify;">子查询的限制：不能使用ORDER BY子句</li><li style="text-align:justify;">层层嵌套方式反映了 SQL语言的结构化</li><li style="text-align:justify;">有些嵌套查询可以用连接运算替代</li></ol></li></ol> 
<p></p> 
<p>  2. 不相关子查询</p> 
<p style="margin-left:.0001pt;text-align:justify;">      子查询的查询条件不依赖于父查询，是由里向外逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p>3.相关子查询</p> 
<p style="margin-left:.0001pt;text-align:justify;">子查询的查询条件依赖于父查询</p> 
<p style="margin-left:.0001pt;text-align:justify;">①首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表；②然后再取外层表的下一个元组；③重复这一过程，直至外层表全部检查完为止。</p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>引出子查询的谓词</strong></strong></p> 
<ol><li style="text-align:justify;">带有IN谓词的子查询</li><li style="text-align:justify;">带有比较运算符的子查询</li><li style="text-align:justify;">带有ANY或ALL谓词的子查询</li><li style="text-align:justify;">带有EXISTS谓词的子查询</li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>⒈带有IN</strong></strong><strong><strong>谓词的子查询</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>⒉带有比较运算符的子查询</strong></strong></p> 
<ul><li style="text-align:justify;">当能确切知道内层查询返回单值时，可用比较运算符（&gt;，&lt;，=，&gt;=，&lt;=，!=或&lt; &gt;）。</li><li style="text-align:justify;">与ANY或ALL谓词配合使用</li></ul> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>⒊带有ANY</strong></strong><strong><strong>或</strong></strong><strong><strong>ALL</strong></strong><strong><strong>谓词的子查询</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">谓词语义</p> 
<p>ANY：任意一个值          ALL：所有值</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>需要配合使用比较运算符</strong></strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong><strong>&gt; ANY</strong></strong></td><td><strong><strong>大于子查询结果中的某个值</strong></strong><strong>       </strong></td></tr><tr><td><strong><strong> &gt; ALL</strong></strong></td><td><strong><strong>大于子查询结果中的所有值</strong></strong></td></tr><tr><td><strong><strong>&lt; ANY</strong></strong></td><td><strong><strong>小于子查询结果中的某个值</strong></strong><strong> </strong></td></tr><tr><td><strong><strong>&lt; ALL</strong></strong></td><td><strong><strong>小于子查询结果中的所有值</strong></strong></td></tr><tr><td><strong><strong>&gt;= ANY</strong></strong><strong> </strong></td><td><strong><strong>大于等于子查询结果中的某个值</strong></strong></td></tr><tr><td><strong><strong>&gt;= ALL</strong></strong><strong> </strong></td><td><strong><strong>大于等于子查询结果中的所有值</strong></strong></td></tr><tr><td><strong><strong>&lt;= ANY</strong></strong></td><td><strong><strong>小于等于子查询结果中的某个值</strong></strong><strong>    </strong></td></tr><tr><td><strong><strong>&lt;= ALL</strong></strong></td><td><strong><strong>小于等于子查询结果中的所有值</strong></strong></td></tr><tr><td><strong><strong>= ANY</strong></strong></td><td><strong><strong>等于子查询结果中的某个值</strong></strong></td></tr><tr><td><strong><strong>=ALL</strong></strong></td><td><strong><strong>等于子查询结果中的所有值（通常没有实际意义）</strong></strong></td></tr><tr><td><strong><strong>!=</strong></strong><strong><strong>（或</strong></strong><strong><strong>&lt;&gt;</strong></strong><strong><strong>）</strong></strong><strong><strong>ANY</strong></strong></td><td><strong><strong>不等于子查询结果中的某个值</strong></strong></td></tr><tr><td><strong><strong>!=</strong></strong><strong><strong>（或</strong></strong><strong><strong>&lt;&gt;</strong></strong><strong><strong>）</strong></strong><strong><strong>ALL</strong></strong></td><td><strong><strong>不等于子查询结果中的任何一个值</strong></strong></td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>        </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>⒋带有EXISTS</strong></strong><strong><strong>谓词的子查询</strong></strong></p> 
<p></p> 
<ul><li style="text-align:justify;"><strong>1. EXISTS谓词</strong> 
  <ul><li style="text-align:justify;"><strong>存在量词 </strong></li><li style="text-align:justify;"><strong>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值</strong><strong>“</strong><strong>true</strong><strong>”</strong><strong>或逻辑假值</strong><strong>“</strong><strong>false</strong><strong>”</strong><strong>。</strong> 
    <ul><li style="text-align:justify;"><strong>若内层查询结果非空，则外层的WHERE子句返回真值</strong></li><li style="text-align:justify;"><strong>若内层查询结果为空，则外层的WHERE子句返回假值</strong></li></ul></li><li style="text-align:justify;"><strong>由EXISTS引出的子查询，其目标列表达式通常都用* ，因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义</strong></li></ul></li></ul> 
<p style="text-align:justify;"><strong>   </strong></p> 
<ul><li style="text-align:justify;"><strong>2. NOT EXISTS谓词</strong> 
  <ul><li style="text-align:justify;"><strong>若内层查询结果非空，则外层的WHERE子句返回假值</strong></li><li style="text-align:justify;"><strong>若内层查询结果为空，则外层的WHERE子句返回真值</strong></li></ul></li></ul> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3. 不同形式的查询间的替换</strong></p> 
<p>       <strong>一些带EXISTS或NOT EXISTS谓词的子查询不能被其他形式的子查询等价替换</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>      所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="844" src="https://images2.imgbox.com/46/9c/TEKeGm8Z_o.png" width="1200"></p> 
<p> <img alt="" height="986" src="https://images2.imgbox.com/fa/d6/Dj87ZLD9_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>5.用EXISTS/NOT EXISTS实现全称量词(难点)</strong></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><strong>SQL语言中没有全称量词</strong><strong>"</strong><strong> （For all）</strong></li><li style="text-align:justify;"><strong>可以把带有全称量词的谓词转换为等价的带有存在量词的谓词：</strong> </li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>        (</strong><strong>"</strong><strong>x)P ≡ </strong><strong>Ø</strong><strong> (</strong><strong>$</strong><strong> x(</strong><strong>Ø</strong><strong> P)) </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>6. </strong><strong>用</strong><strong>EXISTS/NOT EXISTS</strong><strong>实现逻辑蕴函</strong><strong>(</strong><strong>难点</strong><strong>)</strong></p> 
<ol><li><strong>SQL</strong><strong>语言中没有蕴函</strong><strong>(Implication)</strong><strong>逻辑运算</strong></li><li><strong>可以利用谓词演算将逻辑蕴函谓词等价转换为：</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>                   p </strong><strong>®</strong><strong> q </strong><strong>≡</strong><strong> </strong><strong>Ø</strong><strong> p</strong><strong>∨</strong><strong>q </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.3.5  集合查询</strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>标准SQL直接支持的集合操作种类:并操作(UNION)</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>一般商用数据库支持的集合操作种类</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>并操作(UNION)</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>交操作(INTERSECT)</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>差操作(MINUS)</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1</strong></strong><strong><strong>．</strong></strong><strong> </strong><strong><strong>并操作</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>形式 </strong>  <strong>&lt;</strong><strong>查询块</strong><strong>&gt; UNION</strong> <strong> &lt;</strong><strong>查询块</strong><strong>&gt;</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="767" src="https://images2.imgbox.com/3e/6f/aWLCo82I_o.png" width="1200"></p> 
<p></p> 
<p>注意：<strong>参加</strong><strong>UNION</strong><strong>操作的各结果表的列数必须相同；对应项的数据类型也必须相同</strong></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2</strong></strong><strong><strong>．</strong></strong><strong> </strong><strong><strong>交操作</strong></strong> </p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>标准</strong><strong>SQL</strong><strong>中没有提供集合交操作，但可用其他方法间接实现。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3</strong></strong><strong><strong>．</strong></strong><strong> </strong><strong><strong>差操作</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4. </strong></strong><strong><strong>对集合操作结果的排序</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>ORDER BY</strong><strong>子句只能用于对最终查询结果排序，不能对中间结果排序</strong></li><li style="text-align:justify;"><strong>任何情况下，</strong><strong>ORDER BY</strong><strong>子句只能出现在最后</strong></li><li style="text-align:justify;"><strong>对集合操作结果排序时，</strong><strong>ORDER BY</strong><strong>子句中用数字指定排序属性</strong></li></ol> 
<p style="text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.4 </strong></strong><strong><strong>数据更新</strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.4.1  </strong></strong><strong><strong>插入数据</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"> <img alt="" height="1081" src="https://images2.imgbox.com/31/77/7WVpAX9V_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2. </strong></strong><strong><strong>插入子查询结果</strong></strong></p> 
<p style="text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/91/7e/sLHjPVJ9_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.4.2  </strong></strong><strong><strong>修改数据</strong></strong></h4> 
<p style="text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/70/32/6VkxFbqL_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p><strong>三种修改方式</strong></p> 
<p></p> 
<ol><li style="text-align:justify;"><strong>修改某一个元组的值</strong></li><li style="text-align:justify;"><strong>修改多个元组的值</strong></li><li style="text-align:justify;"><strong>带子查询的修改语句</strong></li></ol> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>UPDATE SC</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>        SET  Grade=0</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>        WHERE  'CS'=</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>              (SELETE Sdept</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>               FROM  Student</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>               WHERE  Student.Sno = SC.Sno)</strong><strong>；</strong></p> 
</blockquote> 
<p><img alt="" height="580" src="https://images2.imgbox.com/54/02/6Bdau7Bt_o.png" width="1200"></p> 
<p></p> 
<p><strong>SET子句      </strong>指定修改方式    </p> 
<p style="margin-left:.0001pt;text-align:justify;">  要修改的列</p> 
<p style="margin-left:.0001pt;text-align:justify;">  修改后取值</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p><strong>WHERE子句        指定要修改的元组</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>缺省表示要修改表中的所有元组</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>DBMS</strong><strong>在执行修改语句时会检查修改操作</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>是否破坏表上已定义的完整性规则</strong></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><strong>实体完整性</strong></li><li style="text-align:justify;"><strong>主码不允许修改</strong></li><li style="text-align:justify;"><strong>用户定义的完整性</strong> 
    <ol><li style="text-align:justify;"><strong> NOT NULL</strong><strong>约束</strong></li><li style="text-align:justify;"><strong> UNIQUE</strong><strong>约束</strong></li><li style="text-align:justify;"><strong> </strong><strong>值域约束</strong></li></ol></li></ol></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>DELETE</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>       FROM     &lt;</strong><strong>表名</strong><strong>&gt;</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>       [WHERE &lt;</strong><strong>条件</strong><strong>&gt;]</strong><strong>；</strong></p> 
<ul><li style="text-align:justify;"><strong>功能</strong> 
  <ol><li style="text-align:justify;"><strong>删除指定表中满足</strong><strong>WHERE</strong><strong>子句条件的元组</strong></li></ol></li><li style="text-align:justify;"><strong>WHERE</strong><strong>子句</strong> 
  <ol><li style="text-align:justify;"><strong>指定要删除的元组</strong></li><li style="text-align:justify;"><strong>缺省表示要修改表中的所有元组</strong></li></ol></li><li style="text-align:justify;"><strong>三种删除方式</strong> 
  <ol><li style="text-align:justify;"><strong>删除某一个元组的值</strong></li><li style="text-align:justify;"><strong>删除多个元组的值</strong></li><li style="text-align:justify;"><strong>带子查询的删除语句</strong></li></ol></li></ul> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>DBMS</strong><strong>在执行插入语句时会检查所插元组</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>是否破坏表上已定义的完整性规则</strong></p> 
<ul><li style="text-align:justify;"><strong>参照完整性</strong> 
  <ul><li style="text-align:justify;"><strong>不允许删除</strong></li><li style="text-align:justify;"><strong>级联删除</strong></li></ul></li></ul> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>更新数据与数据一致性</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>DBMS</strong><strong>在执行插入、删除、更新语句时必须保证数据库一致性</strong></p> 
<ol><li style="text-align:justify;"><strong>必须有事务的概念和原子性</strong></li><li style="text-align:justify;"><strong>完整性检查和保证</strong></li></ol> 
<p style="text-align:justify;"></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.5  </strong></strong><strong><strong>视</strong></strong><strong>    </strong><strong><strong>图</strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>视图的特点</strong></p> 
<ol><li style="text-align:justify;"><strong>虚表，是从一个或几个基本表（或视图）导出的表</strong></li><li style="text-align:justify;"><strong>只存放视图的定义，不会出现数据冗余</strong></li><li style="text-align:justify;"><strong>基表中的数据发生变化，从视图中查询出的数据也随之改变</strong></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>基于视图的操作</strong></p> 
<ol><li style="text-align:justify;"><strong> </strong><strong>查询</strong></li><li style="text-align:justify;"><strong> </strong><strong>删除</strong></li><li style="text-align:justify;"><strong> </strong><strong>受限更新</strong></li><li style="text-align:justify;"><strong>定义基于该视图的新视图</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1. </strong></strong><strong><strong>建立视图</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/2d/4e/h3IjMGeh_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>DBMS</strong><strong>执行</strong><strong>CREATE VIEW</strong><strong>语句时只是把视图的定义存入<span style="color:#fe2c24;">数据字典</span>，并不执行其中的SELECT</strong><strong>语句。在对视图查询时，按视图的定义从基本表中将数据查出。</strong><strong><strong>组成视图的属性列名</strong>全部省略或全部指定。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p>​​​​​​​<strong>省略</strong><strong>: </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>    </strong><strong>由子查询中</strong><strong>SELECT</strong><strong>目标列中的诸字段组成</strong>​​​​​​​<strong>明确指定视图的所有列名</strong><strong>:</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>(1) </strong><strong>某个目标列是集函数或列表达式</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>(2) </strong><strong>目标列为</strong><strong>  *</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>(3) </strong><strong>多表连接时选出了几个同名列作为视图的字段</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>(4) </strong><strong>需要在视图中为某个列启用新的更合适的名字</strong></p> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;"><strong>WITH CHECK OPTION</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>    透过视图进行增删改操作时，不得破坏视图定义中的谓词条件（即子查询中的条件表达式）</strong><strong><strong>带表达式的视图。</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>定义一个反映学生出生年份的视图。</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>        CREATE  VIEW BT_S(Sno</strong><strong>，</strong><strong>Sname</strong><strong>，</strong><strong>Sbirth)</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>               AS </strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>           SELECT Sno</strong><strong>，</strong><strong>Sname</strong><strong>，</strong><strong>2000-Sage</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>           FROM  Student</strong></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>设置一些派生属性列</strong><strong>, </strong><strong>也称为虚拟列</strong><strong>--Sbirth </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>带表达式的视图必须明确定义组成视图的各个属性列名</strong></p> 
<p style="text-align:justify;"><strong>     一类不易扩充的视图</strong>：<strong>以</strong><strong> SELECT * </strong><strong>方式创建的视图可扩充性差，应尽可能避免</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2. </strong></strong><strong><strong>删除视图</strong></strong></p> 
<p style="text-align:justify;">​​​​​​​<img alt="" height="583" src="https://images2.imgbox.com/8c/b3/sPNWgFBz_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.5.2  </strong></strong><strong><strong>查询视图</strong></strong></h4> 
<ol><li style="text-align:justify;"><strong>从用户角度：查询视图与查询基本表相同</strong></li><li style="text-align:justify;"><strong>DBMS</strong><strong>实现视图查询的方法</strong> 
  <ol><li style="text-align:justify;"><strong>实体化视图（</strong><strong>View Materialization</strong><strong>）</strong> 
    <ol><li style="text-align:justify;"><strong>有效性检查：检查所查询的视图是否存在</strong></li><li style="text-align:justify;"><strong>执行视图定义，将视图临时实体化，生成临时表</strong></li><li style="text-align:justify;"><strong>查询视图转换为查询临时表</strong></li><li style="text-align:justify;"><strong>查询完毕删除被实体化的视图</strong><strong>(</strong><strong>临时表</strong><strong>)</strong></li></ol></li><li style="text-align:justify;"><strong>视图消解法（</strong><strong>View Resolution</strong><strong>）</strong> 
    <ol><li style="text-align:justify;"><strong>进行有效性检查，检查查询的表、视图等是否存在。如果存在，则从数据字典中取出视图的定义</strong></li><li style="text-align:justify;"><strong>把视图定义中的子查询与用户的查询结合起来，转换成等价的对基本表的查询</strong></li><li style="text-align:justify;"><strong>执行修正后的查询</strong></li></ol></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.5.3  </strong></strong><strong><strong>更新视图</strong></strong></h4> 
<ol><li style="text-align:justify;"><strong>用户角度：更新视图与更新基本表相同</strong></li><li style="text-align:justify;"><strong>DBMS</strong><strong>实现视图更新的方法</strong> 
  <ol><li style="text-align:justify;"><strong>视图实体化法（</strong><strong>View Materialization</strong><strong>）</strong></li><li style="text-align:justify;"><strong>视图消解法（</strong><strong>View Resolution</strong><strong>）</strong></li></ol></li><li style="text-align:justify;"><strong>指定</strong><strong>WITH CHECK OPTION</strong><strong>子句后</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>    DBMS</strong><strong>在更新视图时会进行检查，防止用户通过视图对不属于视图范围内的基本表数据进行更新</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>更新视图的限制</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新</strong><strong>(</strong><strong>对两类方法均如此</strong><strong>)</strong></li><li style="text-align:justify;"><strong>允许对行列子集视图进行更新</strong></li><li style="text-align:justify;"><strong>对其他类型视图的更新不同系统有不同限制</strong> </li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="735" src="https://images2.imgbox.com/1d/b0/fcwDJCt8_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong><strong><strong>3.5.4  视图的作用 </strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="887" src="https://images2.imgbox.com/3d/d0/9dutEMG0_o.png" width="1200"></p> 
<p></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"><strong><strong>（四）</strong></strong><strong><strong>数据库安全性</strong></strong></h3> 
<p style="text-align:justify;"><strong>4.1授权</strong></p> 
<p style="text-align:justify;"><strong>4.2 </strong><strong>收回权限</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>数据控制亦称为数据保护，包括数据的：</strong></p> 
<ol><li style="text-align:justify;"><strong>安全性控制</strong></li><li style="text-align:justify;"><strong>完整性控制</strong></li><li style="text-align:justify;"><strong>并发控制</strong></li><li style="text-align:justify;"><strong>恢复</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>SQL</strong></strong><strong><strong>语言的数据控制功能</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>SQL语言提供了数据控制功能，能够在一定程度上保证数据库中数据的完全性、完整性，并提供了一定的并发控制及恢复能力。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1. </strong></strong><strong><strong>完整性</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>数据库的完整性是指数据库中数据的正确性与相容性。</strong></li><li style="text-align:justify;"><strong>SQL</strong><strong>语言定义完整性约束条件</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>CREATE TABLE</strong><strong>语句</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>ALTER TABLE</strong><strong>语句</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<ol><li><strong>码</strong></li><li><strong>其他约束条件</strong></li><li><strong>参照完整性</strong></li><li><strong>取值唯一的列</strong></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2. </strong></strong><strong><strong>并发控制</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>并发控制</strong><strong>: </strong><strong>当多个用户并发地对数据库进行操作时，对他们加以控制、协调，以保证并发操作正确执行，保持数据库的一致性。</strong></li><li style="text-align:justify;"><strong>SQL语言并发控制能力：   </strong><strong>提供事务、事务开始、事务结束、提交等概念</strong></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3. </strong></strong><strong><strong>恢复</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>恢复</strong><strong>: </strong><strong>当发生各种类型的故障导致数据库处于不一致状态时，将数据库恢复到一致状态的功能。</strong></li><li style="text-align:justify;"><strong>SQL</strong><strong>语言恢复功能：</strong><strong>提供事务回滚、重做等概念 （</strong><strong>UNDO</strong><strong>、</strong><strong>REDO</strong><strong>）</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4. </strong></strong><strong><strong>安全性</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>安全性：保护数据库，防止不合法的使用所造成的数据泄露和破坏。</strong></li><li style="text-align:justify;"><strong>保证数据安全性的主要措施</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>存取控制：控制用户只能存取他有权存取的数据</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>规定不同用户对于不同数据对象所允许执行的操作</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>DBMS</strong></strong><strong><strong>实现数据安全性保护的过程</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>用户或</strong><strong>DBA</strong><strong>把授权决定告知系统</strong></li><li style="text-align:justify;"><strong>SQL</strong><strong>的</strong><strong>GRANT</strong><strong>和</strong><strong>REVOKE</strong></li><li style="text-align:justify;"><strong>DBMS</strong><strong>把授权的结果存入数据字典</strong></li><li style="text-align:justify;"><strong>当用户提出操作请求时，</strong><strong>DBMS</strong><strong>根据授权定义进行检查，以决定是否执行操作请求</strong></li></ol> 
<p></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>41 </strong></strong><strong><strong>授</strong></strong><strong> </strong><strong><strong>权</strong></strong></h4> 
<ol><li style="text-align:justify;"><strong>GRANT语句的一般格式：</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>       GRANT &lt;权限&gt;[,&lt;权限&gt;]... </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>          [ON &lt;对象类型&gt; &lt;对象名&gt;]</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>           TO &lt;用户&gt;[,&lt;用户&gt;]...</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>          [WITH GRANT OPTION];</strong></p> 
<ol><li style="text-align:justify;"><strong>谁定义？DBA和表的建立者（即表的属主）</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<ol><li style="text-align:justify;"><strong>REVOKE</strong><strong>功能：将对指定操作对象的指定操作权限授予指定的用户。</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>(1) </strong></strong><strong><strong>操作权限</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>对象</td><td>TABLE</td><td>操作权限</td></tr><tr><td>属性列</td><td>TABLE</td><td> <p>SELECT ，INSERT，UPDATE </p> <p>DELECT，ALL  PIVIEGES </p> </td></tr><tr><td>视图</td><td>TABLE</td><td> <p>SELECT ，INSERT，UPDATE </p> <p>DELECT，ALL  PIVIEGES </p> </td></tr><tr><td>基本表</td><td>TABLE</td><td> <p>SELECT ，INSERT，UPDATE </p> <p>DELECT ，ALTER ,INDEX,ALL  PIVIEGES </p> </td></tr><tr><td>数据库</td><td>DATABASE</td><td>CREATETAB</td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>(2) </strong></strong><strong><strong>用户的权限</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>建表（CREATETAB）的权限:属于DBA</strong></li><li style="text-align:justify;"><strong>DBA授予--&gt;普通用户</strong></li><li style="text-align:justify;"><strong>基本表或视图的属主拥有对该表或视图的一切操作权限</strong></li><li style="text-align:justify;"><strong>接受权限的用户</strong><strong>:</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>   一个或多个具体用户</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>   PUBLIC（全体用户）</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>(3) WITH GRANT OPTION子句</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>指定了WITH GRANT OPTION子句:</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>  获得某种权限的用户还可以把这种权限再授予别的用户。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">      2.<strong>没有指定WITH GRANT OPTION子句:</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>  获得某种权限的用户只能使用该权限，不能传播该权限</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>查询Student表权限授给用户U1</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>      GRANT   SELECT </strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>      ON   TABLE   Student </strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>      TO   U1;</strong></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>把对Student表和Course表的全部权限授予用户U2和U3</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>      GRANT ALL PRIVILIGES </strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>      ON TABLE Student, Course </strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>      TO U2, U3;</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
</blockquote> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong>4.2  </strong><strong>收回权限</strong></h4> 
<ol><li style="text-align:justify;"><strong>REVOKE语句的一般格式为：</strong></li></ol> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>      REVOKE &lt;权限&gt;[,&lt;权限&gt;]... </strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>      [ON &lt;对象类型&gt; &lt;对象名&gt;]</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>      FROM &lt;用户&gt;[,&lt;用户&gt;]...;</strong></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>功能：从指定用户那里收回对指定对象的指定权限</strong></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>第4章  数据库安全性</strong></strong></p> 
<p>数据库系统的安全保护措施是否有效是数据库系统主要的性能指标之一</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4.1  </strong></strong><strong><strong>计算机安全性概论</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>什么是计算机系统安全性</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">      为计算机系统建立和采取的各种安全保护措施，以保护计算机系统中的硬件、软件及数据，防止其因偶然或恶意的原因使系统遭到破坏，数据遭到更改或泄露等。</p> 
<p style="margin-left:.0001pt;text-align:justify;">技术安全</p> 
<p style="margin-left:.0001pt;text-align:justify;">       指计算机系统中采用具有一定安全性的硬件、软件来实现对计算机系统及其所存数据的安全保护，当计算机系统受到无意或恶意的攻击时仍能保证系统正常运行，保证系统内的数据不增加、不丢失、不泄露。</p> 
<p style="margin-left:.0001pt;text-align:justify;">管理安全</p> 
<p style="margin-left:.0001pt;text-align:justify;">        软硬件意外故障、场地的意外事故、管理不善导致的计算机设备和数据介质的物理破坏、丢失等安全问题</p> 
<p style="margin-left:.0001pt;text-align:justify;">政策法律类</p> 
<p style="margin-left:.0001pt;text-align:justify;">     政府部门建立的有关计算机犯罪、数据安全保密的法律道德准则和政策法规、法令。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>安全标准简介</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">发展历史：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="698" src="https://images2.imgbox.com/a7/9b/2YYgNkx5_o.png" width="1200"></p> 
<p>安全标准简介 </p> 
<p style="text-align:justify;"><img alt="" height="610" src="https://images2.imgbox.com/c9/6a/EnqySj2z_o.png" width="1200"></p> 
<p><strong>TCSEC/TDI安全级别划分 </strong></p> 
<p><img alt="" height="696" src="https://images2.imgbox.com/bc/6e/ltJIN0Gr_o.png" width="1200"></p> 
<p></p> 
<ol><li style="text-align:justify;">R1 安全策略（Security Policy）</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">  R1.1 自主存取控制 （Discretionary Access  Control，简记为DAC）</p> 
<p style="margin-left:.0001pt;text-align:justify;">  R1.2 客体重用（Object Reuse）</p> 
<p style="margin-left:.0001pt;text-align:justify;">  R1.3 标记（Labels）</p> 
<p style="margin-left:.0001pt;text-align:justify;">  R1.4 强制存取控制（Mandatory Access Control，简记为MAC）</p> 
<p></p> 
<p> 2.R2 责任（Accountability）</p> 
<p style="margin-left:.0001pt;text-align:justify;">  R2.1 标识与鉴别（Identification &amp;  Authentication）</p> 
<p style="margin-left:.0001pt;text-align:justify;">  R2.2 审计（Audit）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">3.R3 保证（Assurance）</p> 
<p style="margin-left:.0001pt;text-align:justify;">  R3.1 操作保证（Operational Assurance）</p> 
<p style="margin-left:.0001pt;text-align:justify;">  R3.2 生命周期保证（Life Cycle Assurance）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">R4 文档（Documentation）</p> 
<p style="margin-left:.0001pt;text-align:justify;">  R4.1 安全特性用户指南（Security Features User's Guide）</p> 
<p style="margin-left:.0001pt;text-align:justify;">  R4.2 可信设施手册（Trusted Facility  Manual）</p> 
<p style="margin-left:.0001pt;text-align:justify;">  R4.3 测试文档（Test Documentation）</p> 
<p style="margin-left:.0001pt;text-align:justify;">  R4.4 设计文档（Design Documentation）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="text-align:justify;">CC评估保证级划分</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="786" src="https://images2.imgbox.com/0b/9e/k4H38S5D_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>  </strong></strong><strong><strong>数据库安全性控制</strong></strong></p> 
<ol><li style="text-align:justify;">数据库安全性控制的常用方法 
  <ol><li style="text-align:justify;">用户标识和鉴定</li><li style="text-align:justify;">存取控制</li><li style="text-align:justify;">视图</li><li style="text-align:justify;">审计</li><li style="text-align:justify;">密码存储</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>  </strong></strong><strong><strong>用户标识与鉴别</strong></strong></p> 
<ol><li style="text-align:justify;">用户标识与鉴别（Identification &amp;    Authentication）</li></ol> 
<p>系统提供的最外层安全保护措施</p> 
<p style="margin-left:.0001pt;text-align:justify;">基本方法</p> 
<ol><li style="text-align:justify;">系统提供一定的方式让用户标识自己的名字或身份；</li><li style="text-align:justify;">系统内部记录着所有合法用户的标识；</li><li style="text-align:justify;">每次用户要求进入系统时，由系统核对用户提供的身份标识；</li><li style="text-align:justify;">通过鉴定后才提供机器使用权。</li><li style="text-align:justify;">用户标识和鉴定可以重复多次</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>  </strong></strong><strong><strong>存取控制</strong></strong></p> 
<ol><li style="text-align:justify;">存取控制机制的功能 
  <ol><li style="text-align:justify;">存取控制机制的组成 
    <ol><li style="text-align:justify;"> 定义存取权限</li><li style="text-align:justify;"> 检查存取权限</li></ol></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;"><strong>用户权限定义和合法权检查机制一起组成了DBMS的安全子系统</strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">常用存取控制方法</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="748" src="https://images2.imgbox.com/b1/b4/LjzZiz0E_o.png" width="1200"></p> 
<p> 自主存取控制的特点</p> 
<ol><li style="text-align:justify;">同一用户对于不同的数据对象有不同的存取权限</li><li style="text-align:justify;">不同的用户对同一对象也有不同的权限</li><li style="text-align:justify;">用户还可将其拥有的存取权限转授给其他用户</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"> 强制存取控制的特点</p> 
<ol><li style="text-align:justify;">每一个数据对象被标以一定的密级</li><li style="text-align:justify;">每一个用户也被授予某一个级别的许可证</li><li style="text-align:justify;">对于任意一个对象，只有具有合法许可证的用户才可以存取</li></ol> 
<p style="text-align:justify;"><img alt="" height="971" src="https://images2.imgbox.com/87/55/gzgShjyS_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>  </strong></strong><strong><strong>自主存取控制方法</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/ac/3b/PJqg7LLT_o.png" width="1200"></p> 
<p> 授权与回收<img alt="" height="1200" src="https://images2.imgbox.com/e3/00/KHu4RnK5_o.png" width="1200"></p> 
<p> 回收：</p> 
<p><img alt="" height="534" src="https://images2.imgbox.com/9b/ca/xsctHUPF_o.png" width="1200"></p> 
<p> SQL灵活的授权机制</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/50/d2/4sei5lXF_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">关系数据库中授权的数据对象粒度</p> 
<ol><li> 行</li><li> 属性列 </li><li> 表</li><li> 数据库</li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>   </strong></strong><strong><strong>强制存取控制方法</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">什么是强制存取控制</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/63/b6/oSUZHt3J_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<ol><li style="text-align:justify;"> 
  <ol><li style="text-align:justify;">强制存取控制(MAC)是指系统为保证更高程度的安全性，按照TDI/TCSEC标准中安全策略的要求，所采取的强制存取检查手段。</li><li style="text-align:justify;">MAC不是用户能直接感知或进行控制的。</li></ol></li><li style="text-align:justify;">主体与客体 
  <ol><li style="text-align:justify;">在MAC中，DBMS所管理的全部实体被分为主体和客体两大类</li><li style="text-align:justify;">主体是系统中的活动实体 
    <ol><li style="text-align:justify;"> DBMS所管理的实际用户</li><li style="text-align:justify;"> 代表用户的各进程</li></ol></li><li style="text-align:justify;">客体是系统中的被动实体，是受主体操纵的 
    <ol><li style="text-align:justify;"> 文件</li><li style="text-align:justify;"> 基表</li><li style="text-align:justify;"> 索引</li><li style="text-align:justify;"> 视图</li></ol></li></ol></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>   </strong></strong><strong><strong>视图机制</strong></strong></p> 
<ol><li style="text-align:justify;">视图机制与授权机制配合使用:</li><li style="text-align:justify;">首先用视图机制屏蔽掉一部分保密数据</li><li style="text-align:justify;">视图上面再进一步定义存取权限</li><li style="text-align:justify;">间接实现了支持存取谓词的用户权限定义</li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong> 审计</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>审计的定义</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="580" src="https://images2.imgbox.com/d4/34/vQz5xZms_o.png" width="1200"></p> 
<p><img alt="" height="722" src="https://images2.imgbox.com/0e/22/BjEbx7BF_o.png" width="1200"></p> 
<p></p> 
<p style="text-align:justify;"> 审计功能的可选性：①审计很费时间和空间   ②DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能。</p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4.2.8  </strong></strong><strong><strong>数据加密</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="672" src="https://images2.imgbox.com/d0/3f/3QcijoGD_o.png" width="1200"></p> 
<p></p> 
<ol><li style="text-align:justify;">加密方法 
  <ol><li style="text-align:justify;"> 替换方法 
    <ol><li style="text-align:justify;">使用密钥（Encryption Key）将明文中的每一个字符转换为密文中的一个字符</li></ol></li><li style="text-align:justify;">置换方法 
    <ol><li style="text-align:justify;">将明文的字符按不同的顺序重新排列</li></ol></li><li style="text-align:justify;">混合方法</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">     美国1977年制定的官方加密标准：数据加密标准（Data Encryption Standard，简称DES）</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4.3  </strong></strong><strong><strong>统计数据库安全性</strong></strong></p> 
<ol><li style="text-align:justify;">统计数据库的特点 
  <ol><li style="text-align:justify;">允许用户查询聚集类型的信息（例如合计、平均值等）</li><li style="text-align:justify;">不允许查询单个记录信息</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">规则1：任何查询至少要涉及N(N足够大)个以上的记录</p> 
<p style="margin-left:.0001pt;text-align:justify;">规则2：任意两个查询的相交数据项不能超过M个</p> 
<p style="margin-left:.0001pt;text-align:justify;">规则3：任一用户的查询次数不能超过1+(N-2)/M                </p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="671" src="https://images2.imgbox.com/6d/99/HWC9B2Ps_o.png" width="1096"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>第五章  数据库完整性</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">什么是数据库的完整性</p> 
<ol><li> 
  <ol><li style="text-align:justify;">数据的正确性和相容性</li><li style="text-align:justify;">防止不合语义的数据进入数据库。</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>完整性约束条件定义</strong></strong></p> 
<ol><li style="text-align:justify;">完整性约束条件：数据模型的组成部分约束数据库中数据的语义</li><li style="text-align:justify;">DBMS应提供定义数据库完整性约束条件，并把它们作为模式的一部分存入数据库中</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">完整性约束条件作用的对象</p> 
<ol><li style="text-align:justify;">列：对属性的取值类型、范围、精度等的约束条件</li><li style="text-align:justify;">元组：对元组中各个属性列间的联系的约束</li><li style="text-align:justify;">关系：对若干元组间、关系集合上以及关系之间的联系的约束</li><li style="text-align:justify;">静态 
  <ol><li style="text-align:justify;">对静态对象的约束是反映数据库状态合理性的约束</li></ol></li><li style="text-align:justify;">动态 
  <ol><li style="text-align:justify;">对动态对象的约束是反映数据库状态变迁的约束</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">1. 静态列级约束</p> 
<ol><li style="text-align:justify;">静态列级约束：对的取值域的说明</li><li style="text-align:justify;">最常见、最简单、最容易实现的一类完整性约束</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">五类静态列级约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">1) 数据类型约束：数据的类型、长度、单位、精度等</p> 
<p style="margin-left:.0001pt;text-align:justify;">2) 对数据格式的约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">3) 取值范围或取值集合的约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">4) 对空值的约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">5) 其他约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">2. 静态元组约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">   规定元组的各个列之间的约束关系</p> 
<p style="margin-left:.0001pt;text-align:justify;">   静态元组约束只局限在元组上 </p> 
<p style="margin-left:.0001pt;text-align:justify;">3. 静态关系约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">    关系的各个元组之间或若干关系之间存在的各种联系或约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">    常见静态关系约束：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1) 实体完整性约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">2) 参照完整性约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">3) 函数依赖约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">4) 统计约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">4. 动态列级约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">   动态列级约束是修改列定义或列值时应满足的约束条件</p> 
<p style="margin-left:.0001pt;text-align:justify;">1) 修改列定义时的约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">   2) 修改列值时的约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">5. 动态元组约束</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 修改元组值: 各个字段之间要满足的约束条件</p> 
<p style="margin-left:.0001pt;text-align:justify;">6. 动态关系约束</p> 
<p style="margin-left:.0001pt;text-align:justify;">    关系变化前后状态：限制条件</p> 
<table border="1" cellspacing="0" style="margin-left:3.9pt;width:350.25pt;"><tbody><tr><td style="vertical-align:top;width:87.2pt;"> <p style="margin-left:.0001pt;text-align:justify;">粒  度       状态 </p> </td><td style="vertical-align:top;width:62.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">列  级 </p> </td><td style="vertical-align:top;width:100.5pt;"> <p style="margin-left:.0001pt;text-align:justify;">元 组 级 </p> </td><td style="vertical-align:top;width:100.5pt;"> <p style="margin-left:.0001pt;text-align:justify;">关 系 级 </p> </td></tr><tr><td style="vertical-align:top;width:87.2pt;"> <p style="margin-left:.0001pt;text-align:justify;">    静  态 </p> </td><td style="vertical-align:top;width:62.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">列定义</p> <p style="margin-left:.0001pt;text-align:justify;">·类型</p> <p style="margin-left:.0001pt;text-align:justify;">·格式</p> <p style="margin-left:.0001pt;text-align:justify;">·值域</p> <p style="margin-left:.0001pt;text-align:justify;">     ·空值 </p> </td><td style="vertical-align:top;width:100.5pt;"> <p style="margin-left:.0001pt;text-align:justify;">元组值应满足的条件</p> <p style="margin-left:.0001pt;text-align:justify;"></p> </td><td style="vertical-align:top;width:100.5pt;"> <p style="margin-left:.0001pt;text-align:justify;">   实体完整性约束</p> <p style="margin-left:.0001pt;text-align:justify;">   参照完整性约束</p> <p style="margin-left:.0001pt;text-align:justify;">   函数依赖约束</p> <p style="margin-left:.0001pt;text-align:justify;">   统计约束 </p> </td></tr><tr><td style="vertical-align:top;width:87.2pt;"> <p style="margin-left:.0001pt;text-align:justify;">     动  态 </p> </td><td style="vertical-align:top;width:62.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">改变列定义或列值 </p> </td><td style="vertical-align:top;width:100.5pt;"> <p style="margin-left:.0001pt;text-align:justify;">元组新旧值之间应满足的约束条件 </p> </td><td style="vertical-align:top;width:100.5pt;"> <p style="margin-left:.0001pt;text-align:justify;">关系新旧状态间应满足的约束条件 </p> </td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>10.2  </strong></strong><strong><strong>完整性控制</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>一、</strong></strong><strong><strong>DBMS</strong></strong><strong><strong>的完整性控制机制</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">1. 定义功能</p> 
<p style="margin-left:.0001pt;text-align:justify;">一个完善的完整性控制机制应该允许用户定义各类完整性约束条件。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2. 检查功能</p> 
<ol><li style="text-align:justify;">立即执行的约束(Immediate constraints)</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">    语句执行完后立即检查是否违背完整性约束</p> 
<ol><li style="text-align:justify;"> 延迟执行的约束(Deferred constrainsts)</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">    完整性检查延迟到整个事务执行结束后进行</p> 
<p style="margin-left:.0001pt;text-align:justify;">3. 违约反应</p> 
<p style="margin-left:.0001pt;text-align:justify;">拒绝该操作； 其他处理方法</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">完整性规则五元组表示:</p> 
<p style="margin-left:.0001pt;text-align:justify;">(D，O，A，C，P)</p> 
<ol><li style="text-align:justify;">D（Data） 约束作用的数据对象；</li><li style="text-align:justify;">O（Operation） 触发完整性检查的数据库操作</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">   当用户发出什么操作请求时需要检查该完整性规则</p> 
<p style="margin-left:.0001pt;text-align:justify;">   是立即检查还是延迟检查；</p> 
<p style="text-align:justify;">  3.A（Assertion） 数据对象必须满足的断言或语义约束这是规则的主体；</p> 
<p style="text-align:justify;">  4. C（Condition） 选择A作用的数据对象值的谓词；</p> 
<p style="text-align:justify;">  5. P（Procedure） 违反完整性规则时触发的过程。</p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1. </strong></strong><strong><strong>外码是否可以接受空值的问题</strong></strong></p> 
<ol><li style="text-align:justify;">外码是否能够取空值：依赖于应用环境的语义</li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2.</strong></strong><strong><strong>在被参照关系中删除元组时的问题</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">出现违约操作的情形：</p> 
<p style="margin-left:.0001pt;text-align:justify;">    删除被参照关系的某个元组（student）</p> 
<p style="margin-left:.0001pt;text-align:justify;">   而参照关系有若干元组(SC)的外码值与被删除的被参照关系的主码值相同</p> 
<ol><li style="text-align:justify;">违约反应：可有三种策略 
  <ol><li style="text-align:justify;">级联删除（CASCADES）</li><li style="text-align:justify;">受限删除（RESTRICTED）</li><li style="text-align:justify;">置空值删除（NULLIFIES）</li></ol></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.</strong></strong><strong><strong>在参照关系中插入元组时的问题</strong></strong></p> 
<ol><li style="text-align:justify;">受限插入 
  <ol><li style="text-align:justify;">仅当被参照关系中存在相应的元组，其主码值与参照关系插入元组的外码值相同时，系统才执行插入操作，否则拒绝此操作。</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<ol><li style="text-align:justify;">   递归插入 
  <ol><li style="text-align:justify;">首先向被参照关系中插入相应的元组，其主码值等于参照关系插入元组的外码值，然后向参照关系插入元组。</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4. </strong></strong><strong><strong>修改被参照关系中主码的问题</strong></strong></p> 
<ol><li style="text-align:justify;">两种策略</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">(1)不允许修改主码</p> 
<p style="margin-left:.0001pt;text-align:justify;">(2)允许修改主码   </p> 
<p></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"></h3> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>第六章 关系数据理论</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>二、关系模式的形式化定义</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>关系模式由五部分组成，即它是一个五元组：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>                    R(U, D, DOM, F)</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>R</strong><strong>：</strong><strong>         </strong><strong>关系名</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>U</strong><strong>：</strong><strong>       </strong><strong>组成该关系的属性名集合</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>D</strong><strong>：</strong><strong>       </strong><strong>属性组</strong><strong>U</strong><strong>中属性所来自的域</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>DOM</strong><strong>：属性向域的映象集合</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>F</strong><strong>：</strong><strong>        </strong><strong>属性间数据的依赖关系集合</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/be/5d/JxGTTado_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>三、什么是数据依赖</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1. </strong><strong>完整性约束的表现形式</strong></p> 
<ol><li style="text-align:justify;"><strong>限定属性取值范围： </strong></li><li style="text-align:justify;"><strong>定义属性值间的相互关连（主要体现于值的相等与否），这就是数据依赖，它是数据库模式设计的关键</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2. </strong><strong>数据依赖</strong></p> 
<ol><li style="text-align:justify;"><strong>是通过一个关系中属性间值的相等与否体现出来的数据间的相互关系</strong></li><li style="text-align:justify;"><strong>是现实世界属性间相互联系的抽象</strong></li><li style="text-align:justify;"><strong>是数据内在的性质</strong></li><li style="text-align:justify;"><strong>是语义的体现</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3. </strong><strong>数据依赖的类型</strong></p> 
<ol><li style="text-align:justify;"><strong>函数依赖（</strong><strong>Functional Dependency</strong><strong>，简记为</strong><strong>FD</strong><strong>）</strong></li><li style="text-align:justify;"><strong>多值依赖（</strong><strong>Multivalued Dependency</strong><strong>，简记为</strong><strong>MVD</strong><strong>）</strong></li><li style="text-align:justify;"><strong>其他</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>四、关系模式的简化表示</strong></strong></p> 
<ul><li style="text-align:justify;"><strong>关系模式</strong><strong>R</strong><strong>（</strong><strong>U, D, DOM, F</strong><strong>）</strong></li></ul> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>    </strong><strong>简化为一个三元组：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>                    R</strong><strong>（</strong><strong>U, F</strong><strong>）</strong></p> 
<ul><li style="text-align:justify;"><strong>当且仅当</strong><strong>U</strong><strong>上的一个关系</strong><strong>r </strong><strong>满足</strong><strong>F</strong><strong>时，</strong><strong>r</strong><strong>称为关系模式</strong><strong> R</strong><strong>（</strong><strong>U, F</strong><strong>）的一个关系</strong></li></ul> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>五、数据依赖对关系模式的影响</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒈</strong><strong> </strong><strong>数据冗余太大</strong></p> 
<p>​​​​​​​  <strong>浪费大量的存储空间</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>    </strong><strong>例：每一个系主任的姓名重复出现</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒉</strong><strong> </strong><strong>更新异常（</strong><strong>Update Anomalies</strong><strong>）</strong></p> 
<p>​​​​​​​<strong>数据冗余</strong><strong> </strong><strong>，更新数据时，维护数据完整性代价大。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>例：某系更换系主任后，系统必须修改与该系学生有关的每一个元组</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒊</strong><strong> </strong><strong>插入异常（</strong><strong>Insertion Anomalies</strong><strong>）</strong></p> 
<p><span style="color:#fe2c24;"><strong>该插的数据插不进去</strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>    </strong><strong>例，如果一个系刚成立，尚无学生，我们就无法把这个系及其系主任的信息存入数据库。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒋</strong><strong> </strong><strong>删除异常（</strong><strong>Deletion Anomalies</strong><strong>）</strong></p> 
<p><span style="color:#fe2c24;">​​​​​​​<strong>不该删除的数据不得不删</strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>原因：由存在于模式中的某些数据依赖引起的</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>解决方法：通过分解关系模式来消除其中不合适的数据依赖。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>6.2  </strong></strong><strong><strong>规范化</strong></strong></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>6.2.1 </strong></strong><strong><strong>函数依赖</strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>一、函数依赖</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/14/5c/sL9Lr1lT_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong> R的所有关系实例</strong></span>均要满足：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1. </strong><strong>函数依赖不是指关系模式</strong><strong>R</strong><strong>的某个或某些关系实例满足的约束条件，而是指</strong><strong>R</strong><strong>的所有关系实例均要满足的约束条件。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2. </strong><strong>函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>       </strong><strong>例如</strong><strong>“</strong><strong>姓名→年龄</strong><strong>”</strong><strong>这个函数依赖只有在不允许有同名人的条件下成立，若有同名，则年龄不依赖于姓名。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3. </strong><strong>数据库设计者可以对现实世界作强制的规定。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>二、平凡函数依赖与非平凡函数依赖</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="727" src="https://images2.imgbox.com/5f/d2/8OYHhC4O_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>在关系</strong><strong>SC(Sno, Cno, Grade)</strong><strong>中，</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>      </strong><strong>非平凡函数依赖：</strong><strong> (Sno, Cno) </strong><strong>→</strong><strong> Grade</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>      </strong><strong>平凡函数依赖：</strong><strong>     (Sno, Cno) </strong><strong>→</strong><strong> Sno </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>                                       (Sno, Cno) </strong><strong>→</strong><strong> Cno</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>三、完全函数依赖与部分函数依赖</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="809" src="https://images2.imgbox.com/f5/03/8mbUcw7I_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>四、传递函数依赖</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong><img alt="" height="794" src="https://images2.imgbox.com/7e/6e/ehDL64Di_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>码</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="771" src="https://images2.imgbox.com/e9/a8/GucIlFsl_o.png" width="1200"></p> 
<p> <img alt="" height="770" src="https://images2.imgbox.com/0e/dd/G3GKj9MQ_o.png" width="1200"></p> 
<p> 外码：<img alt="" height="444" src="https://images2.imgbox.com/c1/b6/hTk6pbwL_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>6.2.3 </strong></strong><strong><strong>范式</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">      范式是符合某一种级别的关系模式的集合 ；关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式；<strong>某一关系模式R</strong><strong>为第</strong><strong>n</strong><strong>范式，可简记为</strong><strong>R</strong><strong>∈</strong><strong>nNF</strong><strong>。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong><img alt="" height="725" src="https://images2.imgbox.com/56/ca/d4JoewLP_o.png" width="1200"></p> 
<p></p> 
<p style="text-align:justify;"><strong>1NF</strong><strong>的定义</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;"><strong>   如果一个关系模式</strong><strong>R</strong><strong>的所有属性都是不可分的基本数据项，则</strong><strong>R</strong><strong>∈</strong><strong>1NF</strong><strong>。</strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="text-align:justify;"><strong>注意：第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>(1) </strong><strong>插入异常</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>(2) </strong><strong>删除异常</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>(3) </strong><strong>数据冗余度大</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>(4) </strong><strong>修改复杂</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="text-align:justify;"><strong>2NF</strong><strong>的定义</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>定义</strong><strong>5.6  </strong><strong>若关系模式</strong><strong>R</strong><strong>∈</strong><strong>1NF</strong><strong>，并且每一个非主属性都完全函数依赖于</strong><strong>R</strong><strong>的码，则</strong><strong>R</strong><strong>∈</strong><strong>2NF</strong><strong>。</strong></p> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;">​​​​​​​<strong>3NF</strong><strong>的定义</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="611" src="https://images2.imgbox.com/b1/44/T37r2kJ0_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="643" src="https://images2.imgbox.com/b4/98/sVlS8jrz_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>5.2.6  BC</strong></strong><strong><strong>范式（</strong></strong><strong><strong>BCNF</strong></strong><strong><strong>）</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>定义</strong><strong>5.9   </strong><strong>设关系模式</strong><strong>R&lt;U</strong><strong>，</strong><strong>F&gt;</strong><strong>∈</strong><strong>1NF</strong><strong>，如果对于</strong><strong>R</strong><strong>的每个函数依赖</strong><strong>X</strong><strong>→</strong><strong>Y</strong><strong>，若</strong><strong>Y</strong><strong>不属于</strong><strong>X</strong><strong>，则</strong><strong>X</strong><strong>必含有候选码，那么</strong><strong>R</strong><strong>∈</strong><strong>BCNF</strong><strong>。</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>若</strong><strong>R</strong><strong>∈</strong><strong>BCNF </strong></p> 
<ol><li style="text-align:justify;"><strong>每一个决定属性集（因素）都包含（候选）码</strong></li><li style="text-align:justify;"><strong>R</strong><strong>中的所有属性（主，非主属性）都完全函数依赖于码</strong></li><li style="text-align:justify;"><strong>R</strong><strong>∈</strong><strong>3NF</strong><strong>（证明）</strong></li><li style="text-align:justify;"><strong>若</strong><strong>R</strong><strong>∈</strong><strong>3NF    </strong><strong>则</strong><strong>  R</strong><strong>不一定∈</strong><strong>BCNF</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/ae/00/3gT8HcTM_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>5.2.5 </strong></strong><strong><strong>多值依赖与第四范式（</strong></strong><strong><strong>4NF</strong></strong><strong><strong>）</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong></p> 
<p style="text-align:justify;"><strong>定义6</strong><strong>.10   第四范式</strong></p> 
<p style="text-align:justify;"><img alt="" height="601" src="https://images2.imgbox.com/ef/77/LcP8XMlM_o.png" width="1200"></p> 
<p> <img alt="" height="821" src="https://images2.imgbox.com/cb/78/8h345mBV_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong> </strong></strong><img alt="" height="627" src="https://images2.imgbox.com/1b/f0/8ngenMvN_o.png" width="1200"><strong><strong>多值依赖</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="1028" src="https://images2.imgbox.com/0e/f1/B9pvUdN3_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>多值依赖的性质</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="702" src="https://images2.imgbox.com/62/f7/dqzlrfTX_o.png" width="1173"></p> 
<p> 多值依赖与函数依赖区别</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong><img alt="" height="885" src="https://images2.imgbox.com/39/da/768A7oM3_o.png" width="1200"></p> 
<p></p> 
<h4 style="margin-left:.0001pt;text-align:justify;">规范化小结</h4> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/98/c5/VbD8n8g3_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 style="margin-left:.0001pt;text-align:justify;"><strong><strong>第七章  数据库设计</strong></strong></h2> 
<ol><li style="text-align:justify;"><strong>数据库设计</strong> 
  <ol><li style="text-align:justify;"><strong>数据库设计是指对于一个给定的应用环境，构造最优的数据库模式，建立数据库及其应用系统，使之能够有效地存储数据，满足各种用户的应用需求（信息要求和处理要求）</strong></li><li style="text-align:justify;"><strong>在数据库领域内，常常把使用数据库的各类系统统称为数据库应用系统。</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>7.1.1  </strong></strong><strong><strong>数据库和信息系统</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>数据库是信息系统的核心和基础</strong> 
  <ol><li style="text-align:justify;"><strong>把信息系统中大量的数据按一定的模型组织起来</strong></li><li style="text-align:justify;"><strong>提供存储、维护、检索数据的功能</strong></li><li style="text-align:justify;"><strong>使信息系统可以方便、及时、准确地从数据库中获得所需的信息</strong></li></ol></li><li style="text-align:justify;"><strong>数据库是信息系统的各个部分能否紧密地结合在一起以及如何结合的关键所在</strong></li><li style="text-align:justify;"><strong>数据库设计是信息系统开发和建设的重要组成部分</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>7.1.2  </strong></strong><strong><strong>数据库设计的特点</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>数据库建设是硬件、软件和干件的结合</strong> 
  <ol><li style="text-align:justify;"><strong>三分技术，七分管理，十二分基础数据</strong></li><li style="text-align:justify;"><strong>技术与管理的界面称之为</strong><strong>“</strong><strong>干件</strong><strong>”</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">  2.<strong>数据库设计应该与应用系统设计相结合</strong></p> 
<ol><li style="text-align:justify;"><strong>结构（数据）设计：设计数据库框架或数据库结构</strong></li><li style="text-align:justify;"><strong>行为（处理）设计：设计应用程序、事务处理等</strong>.</li></ol> 
<p></p> 
<p>   3. <strong>结构</strong><strong>和行为分离的设计</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<ol><li style="text-align:justify;"><strong>传统的软件工程忽视对应用中数据语义的分析和抽象，只要有可能就尽量推迟数据结构设计的决策</strong></li><li style="text-align:justify;"><strong>早期的数据库设计致力于数据模型和建模方法研究，忽视了对行为的设计</strong></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>数据库设计的基本步骤</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒈需求分析阶段</strong></p> 
<ol><li><strong>准确了解与分析用户需求（包括数据与处理）</strong></li><li><strong>是整个设计过程的基础，是最困难、最耗费时间的一步</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒉概念结构设计阶段</strong></p> 
<ol><li><strong>是整个数据库设计的关键</strong></li><li><strong>通过对用户需求进行综合、归纳与抽象，形成一个独立于具体</strong><strong>DBMS</strong><strong>的概念模型</strong></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒊逻辑结构设计阶段</strong></p> 
<ol><li><strong>将概念结构转换为某个</strong><strong>DBMS</strong><strong>所支持的数据模型</strong></li><li><strong>对其进行优化</strong></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒋数据库物理设计阶段</strong></p> 
<p>​​​​​​​<strong>为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）</strong></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒌数据库实施阶段</strong></p> 
<ol><li><strong>运用</strong><strong>DBMS</strong><strong>提供的数据语言、工具及宿主语言，根据逻辑设计和物理设计的结果</strong> 
  <ol><li style="text-align:justify;"><strong>并进行试运行</strong></li><li style="text-align:justify;"><strong>组织数据入库</strong></li><li style="text-align:justify;"><strong>编制与调试应用程序</strong></li><li style="text-align:justify;"><strong>建立数据库</strong></li></ol></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒍数据库运行和维护阶段</strong></p> 
<ol><li><strong>数据库应用系统经过试运行后即可投入正式运行。</strong></li><li><strong>在数据库系统运行过程中必须不断地对其进行评价、调整与修改。</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong>数据库各级模式的形成过程</strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">1. 需求分析阶段</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="424" src="https://images2.imgbox.com/88/23/73HWFJYX_o.png" width="1071"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2.概念设计阶段</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3.</strong><strong>逻辑设计阶段</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">4.<strong>物理设计阶段</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>5.数据库实施阶段</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>6.运行和维护阶段</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/10/5d/kjpOBNp6_o.png" width="1200"></p> 
<p><img alt="" height="1094" src="https://images2.imgbox.com/35/bc/vijT8tNq_o.png" width="993"></p> 
<p> 数据库设计不同阶段形成的数据库各级模式<img alt="" height="805" src="https://images2.imgbox.com/0d/88/TSSkVy0e_o.png" width="1200"></p> 
<p></p> 
<p> 特点：</p> 
<p><strong>       然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图</strong><strong>(View)，形成数据的外模式。首先将</strong><strong>E-R图转换成具体的数据库产品支持的数据模型，如关系模型，形成数据库逻辑模式。根据</strong><strong>DBMS特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式需。求分析的重点是调查、收集与分析用户在数据管理中的信息要求、处理要求、安全性与完整性要求。</strong></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>一、数据字典的用途</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">      数据字典是关于数据库中数据的描述，即元数据， 不是数据本身，是数据的数据 ； 数据字典在需求分析阶段建立，在数据库设计过程 中不断修改、充实、完善；数据字典是进行详细的数据收集和数据分析所获得 的主要结果。</p> 
<ol><li style="text-align:justify;"><strong>数据字典是各类数据描述的集合</strong></li><li style="text-align:justify;"><strong>数据字典是进行详细的数据收集和数据分析所获得的主要结果</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>二、数据字典的内容</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>数据字典的内容</strong> 
  <ol><li style="text-align:justify;"><strong>数据项</strong></li><li style="text-align:justify;"><strong>数据结构</strong></li><li style="text-align:justify;"><strong>数据流</strong></li><li style="text-align:justify;"><strong>数据存储</strong></li><li style="text-align:justify;"><strong>处理过程</strong></li></ol></li><li style="text-align:justify;"><strong> </strong><strong>数据项是数据的最小组成单位</strong></li><li style="text-align:justify;"><strong> </strong><strong>若干个数据项可以组成一个数据结构</strong></li><li style="text-align:justify;"><strong> </strong><strong>数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。</strong></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>⒈</strong></strong><strong> </strong><strong><strong>数据项</strong></strong></p> 
<p style="text-align:justify;">    数据项是不可再分的数据单位</p> 
<blockquote> 
 <p style="text-align:justify;">      对数据项的描述 数据项描述＝｛ 数据项名，数据项含义说明，别名，数据类型，长度， 取值范围，取值含义，与其他数据项的逻辑关系，数据项之间的联系 ｝</p> 
</blockquote> 
<p style="text-align:justify;">     用<span style="color:#fe2c24;"><strong>关系规范化理论</strong></span>为指导，用<span style="color:#fe2c24;"><strong>数据依赖</strong></span>的概念分析和表示 数据项之间的联系 —函数依赖</p> 
<p style="text-align:justify;">          “取值范围” 、 “与其他数据项的逻辑关系”。</p> 
<p style="text-align:justify;">     <span style="color:#fe2c24;"><strong>定义了数据的完整性约束条件</strong></span>，是设计数据检验功能的依据，包括模式设计、完整性检查条件、触发器，存储过程。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>⒉</strong></strong><strong> </strong><strong><strong>数据结构</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>数据结构反映了数据之间的组合关系。</strong></li><li style="text-align:justify;"><strong> </strong><strong>一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。</strong></li><li style="text-align:justify;"><strong> </strong><strong>对数据结构的描述</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>数据结构描述＝｛数据结构名，含义说明，组成</strong><strong>:</strong><strong>｛数据项或数据结构｝｝</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>⒊</strong></strong><strong> </strong><strong><strong>数据流</strong></strong></p> 
<p style="text-align:justify;"><img alt="" height="670" src="https://images2.imgbox.com/90/2c/oxP14TrZ_o.png" width="1152"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>⒋</strong></strong><strong> </strong><strong><strong>数据存储</strong></strong></p> 
<p style="text-align:justify;"><img alt="" height="698" src="https://images2.imgbox.com/b2/85/z8NGjFsZ_o.png" width="1200"></p> 
<p></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>⒌</strong></strong><strong> </strong><strong><strong>处理过程</strong></strong></p> 
<p style="text-align:justify;"><img alt="" height="730" src="https://images2.imgbox.com/f9/f4/Sjb10ReG_o.png" width="1200"></p> 
<p></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>6.3  </strong></strong><strong><strong>概念结构设计</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>概念结构设计</strong> 
  <ol><li style="text-align:justify;"><strong>需求分析阶段描述的用户应用需求是现实世界的具体需求</strong></li><li style="text-align:justify;"><strong>将需求分析得到的用户需求抽象为信息结构即概念模型的过程就是概念结构设计</strong></li><li style="text-align:justify;"><strong>概念结构是各种数据模型的共同基础，它比数据模型更独立于机器、更抽象，从而更加稳定。</strong></li><li style="text-align:justify;"><strong>概念结构设计是整个数据库设计的关键</strong></li></ol></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>7.3.2  </strong></strong><strong><strong>概念结构设计的方法与步骤</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>设计概念结构的四类方法</strong> 
  <ol><li style="text-align:justify;"><strong>自顶向下</strong></li><li style="text-align:justify;"><strong>自底向上</strong></li><li style="text-align:justify;">​​​​​​​<strong>逐步扩张</strong></li><li style="text-align:justify;"><strong>混合策略</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>7.3.3  </strong></strong><strong><strong>数据抽象与局部视图设计</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>一、数据抽象</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>概念结构是对现实世界的一种抽象</strong> 
  <ol><li style="text-align:justify;"><strong>从实际的人、物、事和概念中抽取所关心的共同特性，忽略非本质的细节</strong></li><li style="text-align:justify;"><strong>把这些特性用各种概念精确地加以描述</strong></li><li style="text-align:justify;"><strong>这些概念组成了某种模型</strong></li></ol></li></ol> 
<p></p> 
<p>2. <strong>三种常用抽象</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1. </strong><strong>分类（</strong><strong>Classification</strong><strong>）</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>定义某一类概念作为现实世界中一组对象的类型；</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>这些对象具有某些共同的特性和行为；</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>它抽象了对象值和型之间的</strong><strong>“is member of”</strong><strong>的语义；</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>在</strong><strong>E-R</strong><strong>模型中，实体型就是这种抽象；</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"> </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2. </strong><strong>聚集（</strong><strong>Aggregation</strong><strong>）</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>定义某一类型的组成成分；</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>它抽象了对象内部类型和成分之间</strong><strong>“is part of”</strong><strong>的语义；</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>在</strong><strong>E-R</strong><strong>模型中若干属性的聚集组成了实体型，就是这种抽象</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3. </strong><strong>概括（</strong><strong>Generalization</strong><strong>）</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>定义类型之间的一种子集联系；</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>它抽象了类型之间的</strong><strong>“is subset of”</strong><strong>的语义；</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>概括有一个很重要的性质：继承性。子类继承超类上定义的所有抽象。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>设计分</strong><strong>E-R</strong><strong>图的步骤</strong><strong>:</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒈选择局部应用</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒉逐一设计分</strong><strong>E-R</strong><strong>图</strong></p> 
<ol><li><strong>一般原则</strong> 
  <ol><li style="text-align:justify;"><strong>属性不能与其他实体具有联系。联系只发生在实体之间。</strong></li><li style="text-align:justify;"><strong>属性不能再具有需要描述的性质。即属性必须是不可分的数据项，不能再由另一些属性组成。</strong></li><li style="text-align:justify;"><strong>符合上述两条特性的事物一般作为属性对待。</strong></li><li style="text-align:justify;"><strong>为了简化</strong><strong>E-R</strong><strong>图的处置，现实世界中的事物凡能够作为属性对待的，应尽量作为属性。</strong></li></ol></li><li style="text-align:justify;"><strong>集成局部</strong><strong>E-R</strong><strong>图的步骤</strong></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>（1）</strong><strong>合并</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">① 属性冲突</p> 
<ol><li style="text-align:justify;">两类属性冲突 
  <ol><li style="text-align:justify;">属性域冲突：属性值的类型、取值范围或取值集合不同。</li><li style="text-align:justify;">​​​​​​​属性取值单位冲突。</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">②  命名冲突</p> 
<p style="margin-left:.0001pt;text-align:justify;">同名异义：不同意义的对象在不同的局部应用中具有相同的名字</p> 
<p style="margin-left:.0001pt;text-align:justify;">异名同义（一义多名）：同一意义的对象在不同的局部应用中具有不同的名字</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">③ 结构冲突</p> 
<p style="margin-left:.0001pt;text-align:justify;">同一对象在不同应用中具有不同的抽象</p> 
<p style="margin-left:.0001pt;text-align:justify;">同一实体在不同局部视图中所包含的属性不完全相同，或者属性的排列次序不完全相同。</p> 
<p style="margin-left:.0001pt;text-align:justify;">实体之间的联系在不同局部视图中呈现不同的类型</p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>（2）</strong><strong>修改与重构</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>①概念结构设计的步骤：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>抽象数据并设计局部视图；集成局部视图，得到全局概念结构；验证整体概念结构</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>②设计局部视图：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>选择局部应用；</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>逐一设计分</strong><strong>E-R图：</strong>标定局部应用中的实体、属性、码，实体间的联系；用E-R图描述出来</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>③集成局部视图：合并分E-R图，生成初步E-R图（消除冲突）：</strong>属性冲突、命名冲突、结构冲突；</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>修改与重构（消除不必要的冗余，设计生成基本E-R图）：</strong>分析方法、规范化理论</p> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;"><strong><strong>6.4  </strong></strong><strong><strong>逻辑结构设计</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>逻辑结构设计的任务</strong> 
  <ol><li style="text-align:justify;"><strong>概念结构是各种数据模型的共同基础</strong></li><li style="text-align:justify;"><strong>为了能够用某一</strong><strong>DBMS</strong><strong>实现用户需求，还必须将概念结构进一步转化为相应的数据模型，这正是数据库逻辑结构设计所要完成的任务。</strong></li></ol></li><li style="text-align:justify;"><strong>逻辑结构设计的步骤</strong> 
  <ol><li style="text-align:justify;"><strong>将概念结构转化为一般的关系、网状、层次模型</strong></li><li style="text-align:justify;"><strong>将转化来的关系、网状、层次模型向特定</strong><strong>DBMS</strong><strong>支持下的数据模型转换</strong></li><li style="text-align:justify;"><strong>对数据模型进行优化</strong></li></ol></li><li style="text-align:justify;"><strong>转换原则</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> ① 一个实体型转换为一个关系模式。</strong></p> 
<ol><li><strong><em><em>关系的属性</em></em></strong><strong>：实体型的属性</strong></li><li><strong><em><em>关系的码</em></em></strong><strong>：实体型的码</strong></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>② </strong><strong>一个</strong><strong>m:n</strong><strong>联系转换为一个关系模式。</strong></p> 
<ol><li><strong><em><em>关系的属性</em></em></strong><strong>：与该联系相连的各实体的码以及联系本身的属性</strong></li><li><strong><em><em>关系的码</em></em></strong><strong>：各实体码的组合</strong></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>③ </strong><strong>一个</strong><strong>1:n</strong><strong>联系可以转换为一个独立的关系模式，也可以与</strong><strong>n</strong><strong>端对应的关系模式合并。</strong></p> 
<p> <strong>转换为一个独立的关系模式：</strong></p> 
<ol><li><strong><em><em>关系的码</em></em></strong><strong>：</strong><strong>n</strong><strong>端实体的码</strong></li><li>​​​​​​​<strong><em><em>关系的属性</em></em></strong><strong>：与该联系相连的各实体的码以及联系本身的属性</strong></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong><strong>与</strong><strong>n</strong><strong>端对应的关系模式合并</strong></p> 
<ol><li><strong><em><em>合并后关系的码</em></em></strong><strong>：不变</strong></li><li><strong><em><em>合并后关系的属性</em></em></strong><strong>：在</strong><strong>n</strong><strong>端关系中加入</strong><strong>1</strong><strong>端关系的码和联系本身的属性</strong></li><li><strong>可以减少系统中的关系个数，一般情况下更倾向于采用这种方法</strong></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>④  一个</strong><strong>1:1</strong><strong>联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>转换为一个独立的关系模式</strong></p> 
<ol><li><strong><em><em>关系的候选码</em></em></strong><strong>：每个实体的码均是该关系的候选码</strong></li><li><strong><em><em>关系的属性</em></em></strong><strong>：与该联系相连的各实体的码以及联系本身的属性</strong></li></ol> 
<p><strong>与某一端对应的关系模式合并</strong></p> 
<ol><li style="text-align:justify;"><strong><em><em>合并后关系的属性</em></em></strong><strong>：加入对应关系的码和联系本身的属性</strong></li><li style="text-align:justify;"><strong><em><em>合并后关系的码</em></em></strong><strong>：不变</strong><strong><span style="color:#4d4d4d;"> </span></strong></li></ol> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⑤ </strong><strong>三个或三个以上实体间的一个多元联系转换为一个关系模式。</strong></p> 
<ol><li><strong><em><em>关系的属性</em></em></strong><strong>：与该多元联系相连的各实体的码以及联系本身的属性</strong></li><li><strong><em><em>关系的码</em></em></strong><strong>：各实体码的组合</strong></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⑥ </strong><strong>同一实体集的实体间的联系，即自联系，也可按上述</strong><strong>1:1</strong><strong>、</strong><strong>1:n</strong><strong>和</strong><strong>m:n</strong><strong>三种情况分别处理。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⑦  </strong><strong>具有相同码的关系模式可合并。</strong></p> 
<ol><li><strong>目的：减少系统中的关系个数。</strong></li><li><strong>合并方法：将其中一个关系模式的全部属性加入到另一个关系模式中，然后去掉其中的同义属性（可能同名也可能不同名），并适当调整属性的次序。</strong></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>7.4.2  </strong></strong><strong><strong>向特定</strong></strong><strong><strong>DBMS</strong></strong><strong><strong>规定的模型进行转换</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>一般的数据模型还需要向特定</strong><strong>DBMS</strong><strong>规定的模型进行转换。</strong></li><li style="text-align:justify;"><strong>转换的主要依据是所选用的</strong><strong>DBMS</strong><strong>的功能及限制。没有通用规则。</strong></li><li style="text-align:justify;"><strong>对于关系模型来说，这种转换通常都比较简单。</strong></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>7.4.3  </strong></strong><strong><strong>数据模型的优化</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>数据库逻辑设计的结果不是唯一的。</strong></li><li style="text-align:justify;"><strong>得到初步数据模型后，还应该适当地修改、调整数据模型的结构，以进一步提高数据库应用系统的性能，这就是数据模型的优化。</strong></li><li style="text-align:justify;"><strong>关系数据模型的优化通常以规范化理论为指导。</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>数据模型的优化</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒈</strong><strong> </strong><strong>确定数据依赖</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒉</strong><strong>  </strong><strong>对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒊</strong><strong>  </strong><strong>按照数据依赖的理论对关系模式逐一进行分析，考查是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒋</strong><strong>   </strong><strong>按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>⒌</strong><strong>  </strong><strong>按照需求分析阶段得到的各种应用对数据处理的要求，对关系模式进行必要的分解或合并，以提高数据操作的效率和存储空间的利用率</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>水平分解</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="706" src="https://images2.imgbox.com/42/78/LBQQ0873_o.png" width="1200"></p> 
<p></p> 
<p> <strong>垂直分解</strong></p> 
<p><img alt="" height="690" src="https://images2.imgbox.com/cd/31/GTrC65sO_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>逻辑结构设计小结</strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>E-R</strong><strong>图向关系模型的转换原则</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>⒈</strong><strong> </strong><strong>一个实体型转换为一个关系模式。</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>⒉</strong><strong> </strong><strong>一个</strong><strong>m:n</strong><strong>联系转换为一个关系模式。</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>⒊</strong><strong> </strong><strong>一个</strong><strong>1:n</strong><strong>联系可以转换为一个独立的关系模式，也可以与</strong><strong>n</strong><strong>端对应的关系模式合并。</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>⒋</strong><strong> </strong><strong>一个</strong><strong>1:1</strong><strong>联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>⒌</strong><strong> </strong><strong>三个或三个以上实体间的一个多元联系转换为一个关系模式。</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>⒍</strong><strong> </strong><strong>同一实体集的实体间的联系，即自联系，也可按上述</strong><strong>1:1</strong><strong>、</strong><strong>1:n</strong><strong>和</strong><strong>m:n</strong><strong>三种情况分别处理。</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>⒎</strong><strong> </strong><strong>具有相同码的关系模式可合并。</strong></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>优化数据模型的方法</strong></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>⒈</strong><strong> </strong><strong>确定数据依赖</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>⒉</strong><strong>  </strong><strong>对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>⒊</strong><strong>  </strong><strong>确定各关系模式分别属于第几范式。</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>⒋</strong><strong>   </strong><strong>分析对于应用环境这些模式是否合适，确定是否要对它们进行合并或分解。</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>⒌</strong><strong>  </strong><strong>对关系模式进行必要的分解或合并</strong></p> 
</blockquote> 
<p></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>7.5  </strong></strong><strong><strong>数据库的物理设计</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>定义: </strong></strong>数据库在物理设备上的<span style="color:#1a439c;"><strong>存储结构与存取方法</strong></span>称为数据库的物理结构，它依赖于选定的数据库管理系统,为一个给定的逻辑数据模型选取一个最适合应用环境的物理结构的过程，就是数据库的物理设计。</p> 
<p style="text-align:justify;"></p> 
<p><img alt="" height="818" src="https://images2.imgbox.com/0c/27/cGs5LVFF_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>关系模式存取方法选择</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>DBMS</strong><strong>常用存取方法</strong> 
  <ol><li style="text-align:justify;"><strong>索引方法，目前主要是</strong><strong>B+</strong><strong>树索引方法</strong></li><li style="text-align:justify;"><strong>聚簇（</strong><strong>Cluster</strong><strong>）方法</strong></li><li style="text-align:justify;"><strong>HASH</strong><strong>方法</strong></li></ol></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>一、索引存取方法的选择</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>选择索引存取方法的主要内容</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>根据应用要求确定</strong></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><strong> </strong><strong>对哪些属性列建立索引</strong></li><li style="text-align:justify;"><strong> </strong><strong>对哪些属性列建立组合索引</strong></li><li style="text-align:justify;"><strong> </strong><strong>对哪些索引要设计为唯一索引</strong></li></ol></li><li style="text-align:justify;"><strong>聚簇索引</strong> 
  <ol><li style="text-align:justify;"><strong>建立聚簇索引后，基表中数据也需要按指定的聚簇属性值的升序或降序存放。也即聚簇索引的索引项顺序与表中元组的物理顺序一致。</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>7.6  </strong></strong><strong><strong>数据库的实施</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>一、定义数据库结构</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>确定了数据库的逻辑结构与物理结构后，就可以用所选用的</strong><strong>DBMS</strong><strong>提供的数据定义语言（</strong><strong>DDL</strong><strong>）来严格描述数据库结构。</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>二、数据装载</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>数据库结构建立好后，就可以向数据库中装载数据了。组织数据入库是数据库实施阶段最主要的工作。</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<ol><li style="text-align:justify;"><strong>数据装载方法</strong> 
  <ol><li style="text-align:justify;"><strong>人工方法</strong></li><li style="text-align:justify;"><strong>计算机辅助数据入库</strong></li></ol></li></ol> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;"><img alt="" height="522" src="https://images2.imgbox.com/33/83/bCSwTFg7_o.png" width="1200"></p> 
<h4><img alt="" height="550" src="https://images2.imgbox.com/f1/55/8sGlrrFp_o.png" width="1200"> 数据库各级模式的形成</h4> 
<p style="text-align:justify;"><img alt="" height="608" src="https://images2.imgbox.com/74/cc/cbs0Uj1S_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"></h3> 
<h2 style="margin-left:.0001pt;text-align:justify;">第八章  数据库编程</h2> 
<p> <strong><strong> </strong></strong><strong><strong>嵌</strong></strong><strong> </strong><strong><strong>入</strong></strong><strong> </strong><strong><strong>式 SQL：</strong></strong>高级程序语言中嵌入SQL</p> 
<p><img alt="" height="809" src="https://images2.imgbox.com/01/9c/H061aIOK_o.png" width="1200"></p> 
<p> <img alt="" height="654" src="https://images2.imgbox.com/a1/3c/p4ukmhRV_o.png" width="1200"></p> 
<p></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.7.1</strong></strong><strong><strong>嵌入式</strong></strong><strong><strong>SQL</strong></strong><strong><strong>的一般形式</strong></strong></h4> 
<ol><li style="text-align:justify;"><strong>为了区分</strong><strong>SQL</strong><strong>语句与主语言语句，需要</strong><strong>: </strong> 
  <ol><li><strong>前缀：</strong><strong>EXEC SQL</strong></li><li><strong> </strong><strong>结束标志：随主语言的不同而不同</strong></li></ol></li><li style="text-align:justify;"><strong>以</strong><strong>C</strong><strong>为主语言的嵌入式</strong><strong>SQL</strong><strong>语句的一般形式</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>          EXEC SQL &lt;SQL</strong><strong>语句</strong><strong>&gt;;</strong></p> 
<p><img alt="" height="697" src="https://images2.imgbox.com/a8/4f/081nU3hZ_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>DBMS</strong></strong><strong><strong>处理宿主型数据库语言</strong></strong><strong><strong>SQL </strong></strong><strong><strong>的方法</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>预编译</strong></li><li style="text-align:justify;"><strong>修改和扩充主语言使之能处理</strong><strong>SQL</strong><strong>语句</strong></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>预编译</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>  1</strong><strong>．由</strong><strong>DBMS</strong><strong>的预处理程序对源程序进行扫描，识别出</strong><strong>SQL</strong><strong>语句</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>  2</strong><strong>．把它们转换成主语言调用语句，以使主语言编译程序能识别它</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>  3</strong><strong>．最后由主语言的编译程序将整个源程序编译成目标码。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>嵌入</strong></strong><strong><strong>SQL</strong></strong><strong><strong>语句</strong></strong><strong>     </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>说明性语句</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>嵌入</strong><strong>SQL</strong><strong>语句</strong><strong> </strong><strong> </strong><strong> </strong><strong>  </strong><strong>    </strong><strong> </strong><strong>数据定义</strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>可执行语句</strong><strong>  </strong><strong>  </strong><strong> </strong><strong>数据控制</strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>   </strong><strong>    数据操纵</strong><strong>  </strong> </p> 
<ol><li style="text-align:justify;"><strong>允许出现可执行的高级语言语句的地方，都可以写可执行</strong><strong>SQL</strong><strong>语句</strong></li><li style="text-align:justify;"><strong>允许出现说明语句的地方，都可以写说明性</strong><strong>SQL</strong><strong>语句</strong></li></ol> 
<p style="text-align:justify;"></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.7.2 </strong></strong><strong><strong>嵌入式</strong></strong><strong><strong>SQL</strong></strong><strong><strong>语句与主语言之间的通信</strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>     将</strong><strong>SQL</strong><strong>嵌入到高级语言中混合编程，程序中会含有两种不同计算模型的语句</strong></p> 
<ol><li><strong>SQL</strong><strong>语句</strong> 
  <ol><li style="text-align:justify;"><strong> </strong><strong>负责操纵数据库</strong></li><li style="text-align:justify;"><strong> </strong><strong>描述性的面向集合的语句</strong></li></ol></li><li style="text-align:justify;"><strong>高级语言语句：</strong><strong> </strong><strong>过程性的面向记录的语句</strong> <strong> </strong><strong>负责控制程序流程</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>工作单元之间的通信方式</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1. SQL</strong><strong>通信区</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>向主语言传递</strong><strong>SQL</strong><strong>语句的执行状态信息</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>主语言能够据此控制程序流程</strong></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2. </strong><strong>主变量</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> 1</strong><strong>）主语言向</strong><strong>SQL</strong><strong>语句提供参数</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> 2</strong><strong>）将</strong><strong>SQL</strong><strong>语句查询数据库的结果交主语言进一步处理</strong></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3. </strong><strong>游标</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>解决集合性操作语言与过程性操作语言的不匹配</strong></p> 
<ol><li style="text-align:justify;"><strong>为什么要使用游标</strong> 
  <ol><li style="text-align:justify;"><strong> SQL</strong><strong>语言与主语言具有不同数据处理方式</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<ol><li style="text-align:justify;"><strong>SQL</strong><strong>语言是面向集合的，一条</strong><strong>SQL</strong><strong>语句原则上可以产生或处理多条记录</strong></li><li style="text-align:justify;"><strong>主语言是面向记录的，一组主变量一次只能存放一条记录</strong> 
  <ol><li style="text-align:justify;"><strong>仅使用主变量并不能完全满足</strong><strong>SQL</strong><strong>语句向应用程序输出数据的要求</strong></li><li style="text-align:justify;"><strong>嵌入式</strong><strong>SQL</strong><strong>引入了游标的概念，用来协调这两种不同的处理方式</strong></li></ol></li><li style="text-align:justify;"><strong>什么是游标</strong> 
  <ol><li style="text-align:justify;"><strong>游标是系统为用户开设的一个数据缓冲区，存放</strong><strong>SQL</strong><strong>语句的执行结果</strong></li><li style="text-align:justify;"><strong>每个游标区都有一个名字</strong></li><li style="text-align:justify;"><strong>用户可以用</strong><strong>SQL</strong><strong>语句逐一从游标中获取记录，并赋给主变量，交由主语言进一步处理</strong></li></ol></li><li style="text-align:justify;"><strong>使用游标的步骤</strong> 
  <ol><li style="text-align:justify;"><strong>1. </strong><strong>说明游标</strong></li><li style="text-align:justify;"><strong>2. </strong><strong>打开游标</strong></li><li style="text-align:justify;"><strong>3. </strong><strong>移动游标指针，然后取当前记录</strong></li><li style="text-align:justify;"><strong>4. </strong><strong>关闭游标</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1. </strong></strong><strong><strong>说明游标</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>使用</strong><strong>DECLARE</strong><strong>语句</strong></li><li style="text-align:justify;"><strong>语句格式</strong></li></ol> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>EXEC SQL DECLARE &lt;</strong><strong>游标名</strong><strong>&gt; CURSOR</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>                         FOR &lt;SELECT</strong><strong>语句</strong><strong>&gt;;</strong></p> 
</blockquote> 
<p style="text-align:justify;"><strong>功能</strong>：<strong>是一条说明性语句，这时</strong><strong>DBMS</strong><strong>并不执行</strong><strong>SELECT</strong><strong>指定的查询操作。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2. </strong></strong><strong><strong>打开游标</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>使用</strong><strong>OPEN</strong><strong>语句</strong></li><li style="text-align:justify;"><strong>语句格式</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>          EXEC SQL OPEN &lt;</strong><strong>游标名</strong><strong>&gt;;</strong></p> 
<ol><li style="text-align:justify;"><strong>功能</strong> 
  <ol><li style="text-align:justify;"><strong>打开游标实际上是执行相应的</strong><strong>SELECT</strong><strong>语句，把所有满足查询条件的记录从指定表取到缓冲区中</strong></li><li style="text-align:justify;"><strong>这时游标处于活动状态，指针指向查询结果集中第一条记录之前</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3. </strong></strong><strong><strong>移动游标指针，然后取当前记录</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>使用</strong><strong>FETCH</strong><strong>语句</strong></li><li style="text-align:justify;"><strong>语句格式</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>   EXEC SQL FETCH [[NEXT|PRIOR|</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>                       FIRST|LAST] FROM] &lt;</strong><strong>游标名</strong><strong>&gt; </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>               INTO &lt;</strong><strong>主变量</strong><strong>&gt;[&lt;</strong><strong>指示变量</strong><strong>&gt;]</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>                                [,&lt;</strong><strong>主变量</strong><strong>&gt;[&lt;</strong><strong>指示变量</strong><strong>&gt;]]...;</strong></p> 
<ol><li style="text-align:justify;"><strong>功能</strong> 
  <ol><li style="text-align:justify;"><strong>指定方向推动游标指针，然后将缓冲区中的当前记录取出来送至主变量供主语言进一步处理。</strong></li><li style="text-align:justify;"><strong>NEXT|PRIOR|FIRST|LAST</strong><strong>：指定推动游标指针的方式。</strong> 
    <ol><li style="text-align:justify;"><strong> NEXT</strong><strong>：向前推进一条记录</strong></li><li style="text-align:justify;"><strong> PRIOR</strong><strong>：向回退一条记录</strong></li><li style="text-align:justify;"><strong> FIRST</strong><strong>：推向第一条记录</strong></li><li style="text-align:justify;"><strong> LAST</strong><strong>：推向最后一条记录</strong></li><li style="text-align:justify;"><strong> </strong><strong>缺省值为</strong><strong>NEXT</strong></li></ol></li></ol></li><li style="text-align:justify;"><strong>说明</strong> 
  <ol><li style="text-align:justify;"><strong>(1) </strong><strong>主变量必须与</strong><strong>SELECT</strong><strong>语句中的目标列表达式具有一一对应关系</strong></li><li style="text-align:justify;"><strong>(2) FETCH</strong><strong>语句通常用在一个循环结构中，通过循环执行</strong><strong>FETCH</strong><strong>语句逐条取出结果集中的行进行处理</strong></li><li style="text-align:justify;"><strong>(3) </strong><strong>为进一步方便用户处理数据，现在一些关系数据库管理系统对</strong><strong>FETCH</strong><strong>语句做了扩充，允许用户向任意方向以任意步长移动游标指针</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4. </strong></strong><strong><strong>关闭游标</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>使用</strong><strong>CLOSE</strong><strong>语句</strong></li><li style="text-align:justify;"><strong>语句格式</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>      EXEC SQL CLOSE &lt;</strong><strong>游标名</strong><strong>&gt;;</strong></p> 
<ol><li style="text-align:justify;"><strong>功能</strong> 
  <ol><li style="text-align:justify;"><strong>关闭游标，释放结果集占用的缓冲区及其他资源</strong></li></ol></li><li style="text-align:justify;"><strong>说明</strong> 
  <ol><li style="text-align:justify;"><strong>游标被关闭后，就不再和原来的查询结果集相联系</strong></li><li style="text-align:justify;"><strong>被关闭的游标可以再次被打开，与新的查询结果相联系</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p></p> 
<p></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>第八章  数据库恢复技术</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>数据库系统中的数据是由</strong><strong>DBMS</strong><strong>统一管理和控制的，为了适应数据共享的环境，</strong><strong>DBMS</strong><strong>必须提供数据保护能力，以保证数据库中数据的安全可靠和正确有效。</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>7.1  </strong></strong><strong><strong>事务的基本概念</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>事务</strong><strong>(Transaction)</strong><strong>是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<ol><li style="text-align:justify;"><strong>事务和程序是两个概念</strong> 
  <ol><li style="text-align:justify;"><strong>在关系数据库中，一个事务可以是一条</strong><strong>SQL</strong><strong>语句，一组</strong><strong>SQL</strong><strong>语句或整个程序</strong></li><li style="text-align:justify;"><strong>一个应用程序通常包含多个事务</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<ol><li style="text-align:justify;"><strong>事务是恢复和并发控制的基本单位</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>一、什么是事务</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>事务</strong><strong>(Transaction)</strong><strong>是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<ol><li style="text-align:justify;"><strong>事务和程序是两个概念</strong> 
  <ol><li style="text-align:justify;"><strong>在关系数据库中，一个事务可以是一条</strong><strong>SQL</strong><strong>语句，一组</strong><strong>SQL</strong><strong>语句或整个程序</strong></li><li style="text-align:justify;"><strong>一个应用程序通常包含多个事务</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<ol><li style="text-align:justify;"><strong>事务是恢复和并发控制的基本单位</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>二、如何定义事务</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>显式定义方式</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>   BEGIN TRANSACTION                   BEGIN TRANSACTION</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>          SQL </strong><strong>语句</strong><strong>1                                             SQL </strong><strong>语句</strong><strong>1</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>          SQL </strong><strong>语句</strong><strong>2                                             SQL </strong><strong>语句</strong><strong>2</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>          </strong><strong>。。。。。</strong><strong>                                            </strong><strong>。。。。。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>      COMMIT                                             ROLLBACK</strong></p> 
<ol><li style="text-align:justify;"><strong>隐式方式</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>当用户没有显式地定义事务时，</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>DBMS</strong><strong>按缺省规定自动划分事务</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>事务结束</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>COMMIT</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>事务正常结束</strong><strong>   </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>提交事务的所有操作（读</strong><strong>+</strong><strong>更新）</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>事务中所有对数据库的更新永久生效</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>ROLLBACK</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>事务异常终止</strong></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><strong>事务运行的过程中发生了故障，不能继续执行</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>回滚事务的所有更新操作</strong></p> 
<ol><li> 
  <ol><li style="text-align:justify;"><strong>事务滚回到开始时的状态</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>三、事务的特性</strong></strong><strong><strong>(ACID</strong></strong><strong><strong>特性</strong></strong><strong><strong>)</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>事务的</strong><strong>ACID</strong><strong>特性：</strong></p> 
<ol><li style="text-align:justify;"><strong>原子性（</strong><strong>Atomicity</strong><strong>）</strong></li><li style="text-align:justify;"><strong>一致性（</strong><strong>Consistency</strong><strong>）</strong></li><li style="text-align:justify;"><strong>隔离性（</strong><strong>Isolation</strong><strong>）</strong></li><li style="text-align:justify;"><strong>持续性（</strong><strong>Durability </strong><strong>）</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1. </strong></strong><strong><strong>原子性</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>事务是数据库的逻辑工作单位</strong> 
  <ol><li style="text-align:justify;"><strong>事务中包括的诸操作要么都做，要么都不做</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2. </strong></strong><strong><strong>一致性</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>事务执行的结果必须是使数据库从一个</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>   </strong><strong>一致性状态变到另一个一致性状态</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>一致性状态：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>数据库中只包含成功事务提交的结果</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>不一致状态：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>数据库中包含失败事务的结果</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3. </strong></strong><strong><strong>隔离性</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>对并发执行而言</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>一个事务的执行不能被其他事务干扰</strong></p> 
<ol><li style="text-align:justify;"><strong>一个事务内部的操作及使用的数据对其他并发事务是隔离的</strong></li><li style="text-align:justify;"><strong>并发执行的各个事务之间不能互相干扰</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4. </strong></strong><strong><strong>持续性</strong></strong></p> 
<ol><li style="text-align:justify;">持续性也称永久性（Permanence） 
  <ol><li style="text-align:justify;">一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</li><li style="text-align:justify;">接下来的其他操作或故障不应该对其执行结果有任何影响。</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>事务的特性</strong></strong><strong> </strong></p> 
<ol><li style="text-align:justify;">保证事务ACID特性是事务处理的任务</li><li style="text-align:justify;">破坏事务ACID特性的因素 
  <ol><li style="text-align:justify;">多个事务并行运行时，不同事务的操作交叉执行</li><li style="text-align:justify;">事务在运行过程中被强行停止</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>系统故障的恢复</strong></strong></p> 
<ol><li style="text-align:justify;">清除尚未完成的事务对数据库的所有修改 
  <ol><li style="text-align:justify;">系统重新启动时，恢复程序要强行撤消（UNDO）所有未完成事务</li></ol></li><li style="text-align:justify;">将缓冲区中已完成事务提交的结果写入数据库 
  <ol><li style="text-align:justify;">系统重新启动时，恢复程序需要重做（REDO）所有已提交的事务</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">恢复机制涉及的关键问题</p> 
<p style="margin-left:.0001pt;text-align:justify;">1. 如何建立冗余数据</p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;">数据转储（backup）</li><li style="text-align:justify;">登录日志文件（logging）</li></ol></li></ol></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">2. 如何利用这些冗余数据实施数据库恢复</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1</strong></strong><strong><strong>．静态转储</strong></strong></p> 
<ol><li style="text-align:justify;">在系统中无运行事务时进行转储</li><li style="text-align:justify;">转储开始时数据库处于一致性状态</li><li style="text-align:justify;">转储期间不允许对数据库的任何存取、修改活动</li><li style="text-align:justify;">优点：实现简单</li><li style="text-align:justify;">缺点：降低了数据库的可用性 
  <ol><li style="text-align:justify;">转储必须等用户事务结束</li><li style="text-align:justify;">新的事务必须等转储结束</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>动态转储</strong></strong></p> 
<ol><li style="text-align:justify;">转储操作与用户事务并发进行</li><li style="text-align:justify;">转储期间允许对数据库进行存取或修改</li><li style="text-align:justify;">优点 
  <ol><li style="text-align:justify;">不用等待正在运行的用户事务结束</li><li style="text-align:justify;">不会影响新事务的运行</li></ol></li><li style="text-align:justify;">动态转储的缺点 
  <ol><li style="text-align:justify;">不能保证副本中的数据正确有效</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>7.4.2  </strong></strong><strong><strong>登记日志文件</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>一、日志文件的内容</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">1. 什么是日志文件</p> 
<p style="margin-left:.0001pt;text-align:justify;">日志文件(log)是用来记录事务对数据库的</p> 
<p style="margin-left:.0001pt;text-align:justify;">更新操作的文件</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">2. 日志文件的格式</p> 
<p style="margin-left:.0001pt;text-align:justify;">以记录为单位的日志文件</p> 
<p style="margin-left:.0001pt;text-align:justify;">以数据块为单位的日志文件</p> 
<p style="margin-left:.0001pt;text-align:justify;">3. 日志文件内容</p> 
<ol><li> 
  <ol><li style="text-align:justify;">各个事务的开始标记(BEGIN TRANSACTION)</li><li style="text-align:justify;">各个事务的结束标记(COMMIT或ROLLBACK)</li><li style="text-align:justify;">各个事务的所有更新操作</li><li style="text-align:justify;">与事务有关的内部更新操作</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">日志文件中的一个日志记录 (log  record)</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4. </strong></strong><strong><strong>基于记录的日志文件</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">每条日志记录的内容</p> 
<ol><li> 
  <ol><li style="text-align:justify;">事务标识</li><li style="text-align:justify;">操作类型（插入、删除或修改）</li><li style="text-align:justify;">操作对象（记录ID、Block NO.）</li><li style="text-align:justify;">更新前数据的旧值（对插入操作而言，此项为空值）</li><li style="text-align:justify;">更新后数据的新值（对删除操作而言, 此项为空值）</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>5. </strong></strong><strong><strong>基于数据块的日志文件</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">每条日志记录的内容</p> 
<ol><li> 
  <ol><li style="text-align:justify;">事务标识（标明是那个事务）</li><li style="text-align:justify;">操作对象（记录ID、Block NO.）</li><li style="text-align:justify;">更新前数据所在的整个数据块的值（对插入操作而言，此项为空值）</li><li style="text-align:justify;">更新后整个数据块的值（对删除操作而言, 此项为空值）</li></ol></li><li style="text-align:justify;"><strong><strong>常用恢复技术</strong></strong> 
  <ol><li style="text-align:justify;"><strong><strong>事务故障的恢复</strong></strong> 
    <ol><li style="text-align:justify;"><strong><strong>UNDO</strong></strong></li></ol></li><li style="text-align:justify;"><strong><strong>系统故障的恢复</strong></strong> 
    <ol><li style="text-align:justify;"><strong><strong>UNDO + REDO</strong></strong></li></ol></li><li style="text-align:justify;"><strong><strong>介质故障的恢复</strong></strong> 
    <ol><li style="text-align:justify;"><strong><strong>重装备份并恢复到一致性状态</strong></strong><strong><strong> + REDO</strong></strong></li></ol></li></ol></li></ol> 
<h2 style="margin-left:.0001pt;text-align:justify;"><strong> (九)关系数据理论</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"><strong>6.1 </strong><strong>关系系统</strong></h3> 
<ol><li style="text-align:justify;"><strong>能够在一定程度上支持关系模型的数据库管理系统是关系系统。</strong></li><li style="text-align:justify;"><strong>由于关系模型中并非每一部分都是同等重要的</strong></li><li style="text-align:justify;"><strong>并不苛求一个实际的关系系统必须完全支持关系模型。</strong><strong> </strong></li><li style="text-align:justify;"><strong>关系数据结构</strong> 
  <ol><li style="text-align:justify;"><strong>域及域上定义的关系</strong></li></ol></li><li style="text-align:justify;"><strong>关系操作</strong> 
  <ol><li style="text-align:justify;"><strong>并、交、差、广义笛卡尔积、选择、投影、连接、除等</strong><strong> </strong></li></ol></li><li style="text-align:justify;"><strong>关系完整性</strong> 
  <ol><li style="text-align:justify;"><strong>实体完整性、参照完整性、用户自己定义的完整性</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>一个数据库管理系统可定义为关系系统，当且仅当它至少支持：</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1. </strong><strong>关系数据库（即关系数据结构）</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>   </strong><strong>系统中只有表这种结构</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2. </strong><strong>支持选择、投影和（自然）连接运算</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>   </strong><strong>对这些运算不要求用户定义任何物理存取路径</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>对关系系统的最低要求</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"><strong>6.2 </strong><strong>关系系统的查询优化</strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>6.2.1 </strong></strong><strong><strong>查询优化概述</strong></strong></p> 
<ol><li style="text-align:justify;"><strong>查询优化的必要性</strong> 
  <ol><li style="text-align:justify;"><strong>查询优化极大地影响</strong><strong>RDBMS</strong><strong>的性能。</strong></li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong></p> 
<ol><li style="text-align:justify;"><strong>查询优化的可能性</strong> 
  <ol><li style="text-align:justify;"><strong>关系数据语言的级别很高，使</strong><strong>DBMS</strong><strong>可以从关系表达式中分析查询语义。</strong><strong> </strong></li></ol></li><li style="text-align:justify;"><strong>用户不必考虑如何最好地表达查询以获得较好的效率</strong></li><li style="text-align:justify;"><strong>系统可以比用户程序的优化做得更好</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>(1)  </strong><strong>优化器可以从数据字典中获取许多统计信息，而用户程序则难以获得这些信息</strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>(2)</strong><strong>如果数据库的物理统计信息改变了，系统可以自动对查询重新优化以选择相适应的执行计划。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>  </strong><strong>在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>(3)</strong><strong>优化器可以考虑数百种不同的执行计划，而程序员一般只能考虑有限的几种可能性。</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>(4)</strong><strong>优化器中包括了很多复杂的优化技术</strong></p> 
<ol><li style="text-align:justify;"><strong>查询优化的总目标</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>    </strong><strong>选择有效策略，求得给定关系表达式的值</strong></p> 
<ol><li style="text-align:justify;"><strong>实际系统的查询优化步骤</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1. </strong><strong>将查询转换成某种内部表示，通常是语法树</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2. </strong><strong>根据一定的等价变换规则把语法树转换成标准</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong><strong>（优化）形式</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3. </strong><strong>选择低层的操作算法</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>对于语法树中的每一个操作</strong></p> 
<ol><li style="text-align:justify;"><strong>计算各种执行算法的执行代价</strong></li><li style="text-align:justify;"><strong>选择代价小的执行算法</strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>4. </strong><strong>生成查询计划</strong><strong>(</strong><strong>查询执行方案</strong><strong>)</strong></p> 
<p>​​​​​​​      <strong>查询计划是由一系列内部操作组成的。</strong></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>6.2.4 </strong></strong><strong><strong>关系代数等价变换规则</strong></strong><strong> </strong></p> 
<ol><li style="text-align:justify;"><strong>关系代数表达式等价</strong> 
  <ol><li style="text-align:justify;"><strong>指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的</strong></li><li style="text-align:justify;"><strong>上面的优化策略大部分都涉及到代数表达式的变换</strong></li></ol></li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>6.2.6 </strong></strong><strong><strong>优化的一般步骤</strong></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>1</strong><strong>．把查询转换成某种内部表示</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>2</strong><strong>．代数优化：把语法树转换成标准（优化）形式</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>3</strong><strong>．物理优化：选择低层的存取路径</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>4</strong><strong>．生成查询计划，选择代价最小的</strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>第十章  并发控制</strong></strong></p> 
<ol><li style="text-align:justify;">DBMS必须提供并发控制机制</li><li style="text-align:justify;">并发控制机制是衡量一个DBMS性能的重要标志之一</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"> <img alt="" height="536" src="https://images2.imgbox.com/69/d6/HXiPYjBI_o.png" width="969"></p> 
<p></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>并发操作带来的数据不一致性</strong></strong></p> 
<ol><li style="text-align:justify;">丢失修改（lost update）</li><li style="text-align:justify;">不可重复读（non-repeatable read）</li><li style="text-align:justify;">读“脏”数据（dirty read）</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1. </strong></strong><strong><strong>丢失修改</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">丢失修改是指事务1与事务2从数据库中读入同一数据并修改,事务2的提交结果破坏了事务1提交的结果，导致事务1的修改被丢失。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2. </strong></strong><strong><strong>不可重复读</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">不可重复读是指事务1读取数据后，事务2</p> 
<p style="margin-left:.0001pt;text-align:justify;">执行更新操作，使事务1无法再现前一次读</p> 
<p style="margin-left:.0001pt;text-align:justify;">取结果。</p> 
<p style="margin-left:.0001pt;text-align:justify;">事务1读取某一数据后：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1.事务2对其做了修改，当事务1再次读该数据时，得到与前一次不同的值。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2. 事务2删除了其中部分记录，当事务1再次读取数据时，发现某些记录神密地消失了。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3. 事务2插入了一些记录，当事务1再次按相同条件读取数据时，发现多了一些记录。</p> 
<p style="margin-left:.0001pt;text-align:justify;">后两种不可重复读有时也称为幻影现象（phantom row）</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3. </strong></strong><strong><strong>读</strong></strong><strong><strong>“</strong></strong><strong><strong>脏</strong></strong><strong><strong>”</strong></strong><strong><strong>数据</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">事务1修改某一数据，并将其写回磁盘,事务2读取同一数据后,事务1由于某种原因被撤消，这时事务1已修改过的数据恢复原值,事务2读到的数据就与数据库中的数据不一致，是不正确的数据，又称为“脏”数据。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>8.2  </strong></strong><strong><strong>封锁</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>一、什么是封锁</strong></strong></p> 
<ol><li style="text-align:justify;">封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁</li><li style="text-align:justify;">加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。</li><li style="text-align:justify;">封锁是实现并发控制的一个非常重要的技术</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>二、基本封锁类型</strong></strong></p> 
<ol><li style="text-align:justify;">基本封锁类型 <p> 排它锁（eXclusive lock，简记为X锁）</p> <img alt="" height="793" src="https://images2.imgbox.com/54/80/R3DJUhL0_o.png" width="1200"></li></ol> 
<p></p> 
<p>共享锁（Share lock，简记为S锁）</p> 
<p style="text-align:justify;"><img alt="" height="692" src="https://images2.imgbox.com/93/ca/5HxNzckA_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>8.3  </strong></strong><strong><strong>封锁协议</strong></strong></p> 
<ol><li style="text-align:justify;">在运用X锁和S锁对数据对象加锁时，需要约定一些规则：封锁协议（Locking Protocol）  
  <ol><li style="text-align:justify;">何时申请X锁或S锁</li><li style="text-align:justify;">持锁时间</li><li style="text-align:justify;">何时释放</li></ol></li></ol> 
<p style="text-align:justify;"></p> 
<ol><li style="text-align:justify;"> 不同的封锁协议，在不同的程度上为并发操作的正确调度提供一定的保证</li><li style="text-align:justify;">常用的封锁协议：三级封锁协议</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1</strong></strong><strong><strong>级封锁协议</strong></strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/5a/5f/G8KtT7oV_o.png" width="1200"></p> 
<p> 一级封锁协议 vs 不可重读<img alt="" height="1188" src="https://images2.imgbox.com/41/af/aBTHV89o_o.png" width="1200"></p> 
<p></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2</strong></strong><strong><strong>级封锁协议</strong></strong></p> 
<p><img alt="" height="841" src="https://images2.imgbox.com/56/42/O0jE6jS0_o.png" width="1200"></p> 
<p>二级封锁协议 vs 不可重读 </p> 
<p style="text-align:justify;"><img alt="" height="933" src="https://images2.imgbox.com/66/b0/TyUka4Vz_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3</strong></strong><strong><strong>级封锁协议</strong></strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/5d/7e/71rJlX2Y_o.png" width="1200"></p> 
<p><strong> 总结</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="806" src="https://images2.imgbox.com/49/7e/l792ffpz_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>8.4  </strong></strong><strong><strong>活锁和死锁</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>活锁</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">定义：事务𝑻𝟏封锁了数据R   事务𝑻𝟐又请求封锁R，于是𝑻𝟐等待。 也请求封锁R，当𝑻𝟏释放了R上的封锁之后系统首先批准 了𝑻𝟑的请求， 𝑻𝟐仍然等待。  又请求封锁R，当𝑻𝟑释放了R上的封锁之后系统又批准了 𝑻𝟒的请求……  有可能永远等待，这就是活锁的情形</p> 
<p style="margin-left:.0001pt;text-align:justify;">避免活锁：采用先来先服务的策略，   当多个事务请求封锁同一数据对象时 ，按请求封锁的先后次序对这些事务排队， 该数据对象上的锁一旦释放，首先批准申请队列中第一 个事务获得锁。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>死锁</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>定义</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">事务𝑻𝟏封锁了数据𝑹𝟏，封锁了数据𝑹𝟐，又请求封锁𝑹𝟐 ，因𝑻𝟐已封锁了𝑹𝟐 ，于是𝑻𝟏等待𝑻𝟐释放 𝑹𝟐上的锁 ， 接着𝑻𝟐又申请封锁𝑹𝟏 ，因𝑻𝟏已封锁了𝑹𝟏 ， 𝑻𝟐也只能等待 𝑻𝟏释放𝑹𝟏上的锁 ， 这样𝑻𝟏在等待𝑻𝟐 ，而𝑻𝟐又在等待𝑻𝟏 ， 𝑻𝟏和𝑻𝟐两个事务永 远不能结束，形成死锁</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>死锁的预防</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;"><strong><strong>（</strong></strong><strong><strong>1</strong></strong><strong><strong>）一次封锁法</strong></strong></span></p> 
<ol><li style="text-align:justify;">要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行</li><li style="text-align:justify;">一次封锁法存在的问题：降低并发度 
  <ol><li style="text-align:justify;"> 扩大封锁范围</li><li style="text-align:justify;">将以后要用到的全部数据加锁，势必扩大了封锁的范围，从而降低了系统的并发度</li></ol></li><li style="text-align:justify;">难于事先精确确定封锁对象 
  <ol><li style="text-align:justify;">数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能会变成封锁对象，所以很难事先精确地确定每个事务所要封锁的数据对象</li><li style="text-align:justify;">解决方法：将事务在执行过程中可能要封锁的数据对象全部加锁，这就进一步降低了并发度。</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;"><strong><strong>（</strong></strong><strong><strong>2</strong></strong><strong><strong>）顺序封锁法</strong></strong></span></p> 
<ol><li style="text-align:justify;">顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</li><li style="text-align:justify;">顺序封锁法存在的问题 
  <ol><li style="text-align:justify;"> 维护成本高</li><li style="text-align:justify;">数据库系统中可封锁的数据对象极其众多，并且随数据的插入、删除等操作而不断地变化，要维护这样极多而且变化的资源的封锁顺序非常困难，成本很高</li><li style="text-align:justify;">难于实现</li></ol></li><li style="text-align:justify;">事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁。</li></ol> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2. </strong></strong><strong><strong>死锁的诊断与解除</strong></strong></p> 
<ol><li style="text-align:justify;">允许死锁发生</li><li style="text-align:justify;">解除死锁 
  <ol><li style="text-align:justify;">由DBMS的并发控制子系统定期检测系统中是否存在死锁</li><li style="text-align:justify;">一旦检测到死锁，就要设法解除</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>检测死锁：超时法</strong></p> 
<ol><li style="text-align:justify;">如果一个事务的等待时间超过了规定的时限，就认为发生了死锁</li><li style="text-align:justify;">优点：实现简单</li><li style="text-align:justify;">缺点 
  <ol><li style="text-align:justify;">有可能误判死锁</li><li style="text-align:justify;">时限若设置得太长，死锁发生后不能及时发现</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>等待图法</strong></strong></p> 
<p style="text-align:justify;"><img alt="" height="1200" src="https://images2.imgbox.com/dc/ce/NCZgt5f5_o.png" width="1200"></p> 
<p></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>8.5  </strong></strong><strong><strong>并发调度的可串行性</strong></strong></p> 
<ol><li style="text-align:justify;">几个事务的并行执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同。这种并行调度策略称为可串行化（Serializable）的调度。</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">可串行性是并行事务正确性的唯一准则</p> 
<ol><li style="text-align:justify;">保证并发操作调度正确性的方法 
  <ol><li style="text-align:justify;">封锁方法：两段锁（Two-Phase Locking，简称2PL）协议</li><li style="text-align:justify;">时标方法</li><li style="text-align:justify;">乐观方法</li></ol></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>8.6  </strong></strong><strong><strong>两段锁协议</strong></strong></p> 
<p></p> 
<ol><li style="text-align:justify;">两段锁协议的内容</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">Ⅰ 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</p> 
<p style="margin-left:.0001pt;text-align:justify;">Ⅱ  在释放一个封锁之后，事务不再获得任何其他封锁。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="745" src="https://images2.imgbox.com/ce/43/Tqpy812A_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"> <img alt="" height="1096" src="https://images2.imgbox.com/f5/8c/rWZxFl2N_o.png" width="1200"></p> 
<p></p> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><strong> 并行执行的所有事务均遵守两段锁协议，则对这些事务的所有并行调度策略都是可串行化的。</strong></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;"><strong>所有遵守两段锁协议的事务，其并行执行的结果一定是正确的。</strong></span></p> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><strong> </strong></span></p> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;">两段锁协议与三级封锁协议</p> 
<ol><li style="text-align:justify;">两类不同目的的协议 
  <ol><li style="text-align:justify;">两段锁协议 
    <ol><li style="text-align:justify;">保证并发调度的正确性</li></ol></li><li style="text-align:justify;">三级封锁协议 
    <ol><li style="text-align:justify;">在不同程度上保证数据一致性</li></ol></li></ol></li></ol> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><strong>遵守第三级封锁协议必然遵守两段协议</strong></span></p> 
<p style="text-align:justify;"></p> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>8.7  </strong></strong><strong><strong>封锁的粒度</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>一、什么是封锁粒度</strong></strong></p> 
<ol><li style="text-align:justify;">X锁和S锁都是加在某一个数据对象上的</li><li style="text-align:justify;">封锁的对象:逻辑单元，物理单元  
  <ol><li style="text-align:justify;">逻辑单元: 属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库等</li><li style="text-align:justify;">物理单元：页（数据页或索引页）、物理记录等</li></ol></li></ol> 
<p style="text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>二、选择封锁粒度的原则</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">     封锁粒度与<span style="color:#fe2c24;"><strong>系统的并发度和并发控制</strong></span>的开销密切相关；封锁的粒度越大，数据库所能够封锁的数据单元就越 少，并发度就越小，系统开销也越小；但并发度低 ， 封锁的粒度越小，并发度较高，但系统开销也就越大。</p> 
<ol><li style="text-align:justify;">封锁的粒度越                  大，小，</li><li style="text-align:justify;">系统被封锁的对象            少，多，</li><li style="text-align:justify;">并发度                            小，高，</li><li style="text-align:justify;">系统开销                         小，大，</li><li style="text-align:justify;">选择封锁粒度：考虑<span style="color:#fe2c24;"><strong>封锁机构和并发度</strong></span>两个因素</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">对系统开销与并发度进行权衡</p> 
<ol><li style="text-align:justify;">需要处理多个关系的大量元组的用户事务：以数据库为封锁单位；</li><li style="text-align:justify;">需要处理大量元组的用户事务：以关系为封锁单元；</li><li style="text-align:justify;">只处理少量元组的用户事务：以元组为封锁单位</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>8.7.2 多粒度封锁</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="659" src="https://images2.imgbox.com/57/84/CvQ7wwM0_o.png" width="1200"></p> 
<p></p> 
<p style="text-align:justify;"><img alt="" height="787" src="https://images2.imgbox.com/cd/fb/t0xPNHoX_o.png" width="1200"></p> 
<p></p> 
<p><img alt="" height="806" src="https://images2.imgbox.com/74/9f/w67sdxtM_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>显式封锁和隐式封锁</strong></strong></p> 
<ol><li style="text-align:justify;">显式封锁:<strong> 直接加到数据对象上的封锁</strong></li><li style="text-align:justify;">隐式封锁: 由于其<strong><span style="color:#fe2c24;">上级结点加锁</span></strong>而使<strong>该数据对象加上了锁</strong></li><li style="text-align:justify;">显式封锁和隐式封锁的效果是一样的</li></ol> 
<p style="text-align:justify;"><img alt="" height="456" src="https://images2.imgbox.com/ce/70/yxiYUfKo_o.png" width="1200"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>8.7.3 </strong></strong><strong><strong>意向锁</strong></strong></p> 
<ol><li style="text-align:justify;">引进意向锁（intention lock）目的 
  <ol><li style="text-align:justify;">提高对某个数据对象加锁时系统的检查效率</li></ol></li><li style="text-align:justify;">对任一结点加基本锁，必须先对它的上层结点加意向锁</li><li style="text-align:justify;">如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁</li></ol> 
<p>Is意向锁 </p> 
<p> <img alt="" height="801" src="https://images2.imgbox.com/ec/46/h2yvehjB_o.png" width="1200"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong></p> 
<p>意向排它锁 </p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="768" src="https://images2.imgbox.com/76/e1/0RWM8ruo_o.png" width="1200"></p> 
<p>共享意向排它锁： </p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="811" src="https://images2.imgbox.com/c3/57/stzVLm3n_o.png" width="1200"></p> 
<p> 补充：<img alt="" height="641" src="https://images2.imgbox.com/6a/14/ofJM5s0n_o.png" width="1200"></p> 
<p></p> 
<p><img alt="" height="775" src="https://images2.imgbox.com/95/8b/lyMuQoEW_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"><strong><strong>  </strong></strong></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d122b8aae43444f17fc8d98d9801635/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Java的反射和字节码操作实现动态代码生成</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27af270aaece6397f08ace84f00dc979/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决websocket.GetHttpSessionConfig.modifyHandshake中获取httpsession时为null报NullPointerException</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>