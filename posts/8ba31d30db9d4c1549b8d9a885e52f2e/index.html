<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>erlang （Lists 操作模块）学习笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="erlang （Lists 操作模块）学习笔记" />
<meta property="og:description" content="all 1&gt; lists:all(fun(X)-&gt;X&lt;4 end,[1,2,3]). true 2&gt; lists:all(fun(X)-&gt;X&lt;4 end,[1,2,3,4]). false all（Pred， List）-&gt; boolean()
如果 Pred（Elem） 对 List 中的所有元素 Elem 返回 true，则返回 true，否则返回 false。Pred 函数必须返回布尔值。
any 3&gt;lists:any(fun(X)-&gt;X&lt;4 end,[1,2,3,4]). true 4&gt;lists:any(fun(X)-&gt;X&lt;4 end,[4,5]). false all（Pred， List）-&gt; boolean()
如果 Pred（Elem） 对列表中的至少一个元素 Elem 返回 true，则返回 true。Pred 函数必须返回一个 布尔。
append 5&gt; lists:append([[1, 2, 3], [a, b], [4, 5, 6]]). [1,2,3,a,b,4,5,6] 6&gt; lists:append(&#34;abc&#34;, &#34;def&#34;). &#34;abcdef&#34; append（ListOfLists） -&gt; List1
返回一个列表，其中追加了 ListOfLists 的所有子列表。
append（List1， List2） -&gt; List3
返回一个新列表 List3，该列表由 List1 的元素后跟 List2 的元素。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8ba31d30db9d4c1549b8d9a885e52f2e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T22:40:58+08:00" />
<meta property="article:modified_time" content="2024-01-22T22:40:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">erlang （Lists 操作模块）学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>all</h4> 
<pre><code class="language-Erlang">1&gt; lists:all(fun(X)-&gt;X&lt;4 end,[1,2,3]).
true
2&gt; lists:all(fun(X)-&gt;X&lt;4 end,[1,2,3,4]).
false</code></pre> 
<p id="all-2">   all（Pred， List）-&gt; boolean()</p> 
<p> 如果 Pred（Elem） 对 List 中的所有元素 Elem 返回 true，则返回 true，否则返回 false。Pred 函数必须返回布尔值。</p> 
<h4>any</h4> 
<div> 
 <pre><code class="language-Erlang">3&gt;lists:any(fun(X)-&gt;X&lt;4 end,[1,2,3,4]).
true
4&gt;lists:any(fun(X)-&gt;X&lt;4 end,[4,5]).    
false</code></pre> 
</div> 
<p> all（Pred， List）-&gt; boolean()</p> 
<p>如果 Pred（Elem） 对列表中的至少一个元素 Elem 返回 true，则返回 true。Pred 函数必须返回一个 布尔。</p> 
<h4>append</h4> 
<div> 
 <pre><code class="language-Erlang">5&gt; lists:append([[1, 2, 3], [a, b], [4, 5, 6]]).
[1,2,3,a,b,4,5,6]
6&gt; lists:append("abc", "def").
"abcdef"</code></pre> 
</div> 
<p id="append-1">append（ListOfLists） -&gt; List1</p> 
<p>返回一个列表，其中追加了 ListOfLists 的所有子列表。</p> 
<p>append（List1， List2） -&gt; List3</p> 
<p>返回一个新列表 List3，该列表由 List1 的元素后跟 List2 的元素。</p> 
<h4>concat</h4> 
<div> 
 <pre><code class="language-Erlang">7&gt; lists:concat([doc, '/', file, '.', 3]).
"doc/file.3"</code></pre> 
</div> 
<p id="concat-1">concat（事物）-&gt; string()</p> 
<p>连接事物元素的文本表示形式。Things 的元素可以是原子、整数、浮点数或字符串。</p> 
<h4>delete</h4> 
<pre><code class="language-Erlang">40&gt; lists:delete(1,[1,2,3,4]).                          
[2,3,4]
41&gt; lists:delete(1,[2,3,4]).  
[2,3,4]
</code></pre> 
<p id="delete-2">delete（Elem， List1） -&gt; List2</p> 
<p>返回 List1 的副本，其中第一个元素 匹配的 Elem 将被删除，如果有这样的 元素。</p> 
<h4>droplast</h4> 
<div> 
 <pre><code class="language-Erlang">8&gt; lists:droplast([1,2,3,4]).               
[1,2,3]
9&gt; lists:droplast([]).       
** exception error: no function clause matching lists:droplast([]) (lists.erl, line 218)</code></pre> 
</div> 
<p id="droplast-1">droplast（列表） -&gt; 初始化列表</p> 
<p>删除 List 的最后一个元素。该列表是 为非空，否则函数崩溃并出现function_clause。</p> 
<h4>dropwhile</h4> 
<div> 
 <pre><code class="language-Erlang">10&gt; lists:dropwhile(fun(X)-&gt;X&lt;4 end,[1,2,3,4,5,6,7]).
[4,5,6,7]</code></pre> 
</div> 
<p> dropwhile（Pred， List1） -&gt; List2</p> 
<p>从 List1 中删除元素 Elem，而 Pred（Elem） 返回 true 和 返回剩余列表。Pred 函数必须返回一个 布尔。</p> 
<h4>duplicate</h4> 
<div> 
 <pre><code class="language-Erlang">11&gt; lists:duplicate(5,hello).                        
[hello,hello,hello,hello,hello]</code></pre> 
</div> 
<p> duplicate（N， Elem） -&gt;列表</p> 
<p>返回包含术语 Elem 的 N 个副本的列表。</p> 
<p>filter</p> 
<div> 
 <pre><code class="language-Erlang">13&gt; lists:filter(fun(X)-&gt;X&lt;4 end,[1,2,3,4,5,6,7,8]).
[1,2,3]</code></pre> 
</div> 
<p id="filter-2">filter（Pred， List1） -&gt; List2</p> 
<p>List2 是 List1 中 Elem 的所有元素的列表，Pred（Elem） 为其返回 true。 Pred 函数必须返回布尔值.</p> 
<h4>filtermap</h4> 
<div> 
 <pre><code class="language-Erlang">14&gt; lists:filtermap(fun(X)-&gt;X&lt;4 end,[1,2,3,4,5,6,7,8]).
[1,2,3]
15&gt; lists:filtermap(fun(X) -&gt; case X rem 2 of 0 -&gt; {true, X div 2}; _ -&gt; false end end, [1,2,3,4,5]).
[1,2]</code></pre> 
</div> 
<p id="filtermap-2">filtermap（Fun， List1） -&gt; List2</p> 
<p> 连续调用 Fun（Elem） 元素 Elem of List1.Fun/1 必须返回布尔值或元组 {true， Value}。该函数返回 元素，其中 Fun 返回一个新值，其中 值 true 与 {true， Elem} 同义。</p> 
<h4>flatlength</h4> 
<div> 
 <pre><code class="language-Erlang">16&gt; lists:flatlength([1,[1,2,[3,4,8]],3,4,5,6]).                                
10     </code></pre> 
</div> 
<p> flatlength（DeepList）-&gt; Integer() &gt;= 0</p> 
<p>等效于 length（flatten（DeepList）），但 效率更高。</p> 
<h4>flatmap</h4> 
<div> 
 <pre><code class="language-Erlang">17&gt;  lists:flatmap(fun(X)-&gt;[X,X] end, [a,b,c]).
[a,a,b,b,c,c]</code></pre> 
</div> 
<p> flatmap（Fun， List1） -&gt; List2</p> 
<p>将函数从 A s 转换为 B的列表，以及 A的列表 （List1），并通过将函数应用于 List1 中的每个元素并附加结果列表来生成 B列表。</p> 
<p>flatten</p> 
<div> 
 <pre><code class="language-Erlang">18&gt; lists:flatten([1,[1,2,[3,4,8]],3,4,5,6]). 
[1,1,2,3,4,8,3,4,5,6]
19&gt; lists:flatten([1,[1,2,[3,4,8]],3,4,5,6],[8,34,11]).
[1,1,2,3,4,8,3,4,5,6,8,34,11]</code></pre> 
</div> 
<p> flatten（DeepList） -&gt;列表</p> 
<p>返回 DeepList 的平展版本。</p> 
<p id="flatten-2">flatten（DeepList， tail） -&gt;列表</p> 
<p>返回 DeepList 的扁平化版本，并追加了 tail Tail。</p> 
<h4>foldl 和 fold</h4> 
<div> 
 <pre><code class="language-Erlang">20&gt; lists:foldl(fun(X, Sum) -&gt; X + Sum end, 0, [1,2,3,4,5]).
15
21&gt; lists:foldl(fun(X, Prod) -&gt; X * Prod end, 1, [1,2,3,4,5]).
120
22&gt; P = fun(A, AccIn) -&gt; io:format("~p ", [A]), AccIn end.
#Fun&lt;erl_eval.43.65746770&gt;
23&gt; lists:foldl(P, void, [1,2,3]).
1 2 3 void
24&gt; lists:foldr(P, void, [1,2,3]).
3 2 1 void</code></pre> 
</div> 
<p> foldl（Fun， Acc0， List） -&gt; Acc1</p> 
<p>在列表的连续元素 A 上调用 Fun（Elem， AccIn），开始 使用 AccIn == Acc0。Fun/2 必须返回一个新的累加器，它是 传递到下一个调用。该函数返回 蓄能器。如果列表为 空。</p> 
<p id="foldr-3">foldr（Fun， Acc0， List） -&gt; Acc1</p> 
<p>像foldl/3一样，但 列表从右到左遍历。</p> 
<p>foldl/3 是尾递归的，通常优于 foldr/3。</p> 
<h4>join</h4> 
<div> 
 <pre><code class="language-Erlang">25&gt; lists:join(x, [a,b,c]).
[a,x,b,x,c]
26&gt; lists:join(x, [a]).    
[a]
27&gt; lists:join(x, []). 
[]</code></pre> 
 <p id="join-2">join（Sep， List1） -&gt; List2</p> 
 <p>在 List1 中的每个元素之间插入 Sep。没有 对空列表和单一实例列表的影响。</p> 
</div> 
<h4>keydelete</h4> 
<div> 
 <pre><code class="language-Erlang">28&gt; lists:keydelete(1,1,[{1,hello},{2,key},{3,value}]).
[{2,key},{3,value}]
29&gt; lists:keydelete(1,1,[{2,key},{3,value}]).          
[{2,key},{3,value}]</code></pre> 
</div> 
<p id="keydelete-3">keydelete（Key， N， TupleList1） -&gt; TupleList2</p> 
<p>返回 TupleList1 的副本，其中第一个 出现第 N个元素比较的元组 等于 Key，如果存在这样的元组，则删除。</p> 
<p></p> 
<h4>keyfind</h4> 
<div> 
 <pre><code class="language-Erlang">30&gt; lists:keyfind(1,1,[{1,hello},{2,key},{3,value}]).  
{1,hello}
31&gt; lists:keyfind(1,1,[{2,key},{3,value}]).          
false</code></pre> 
 <p>keyfind（Key， N， TupleList） -&gt;元组 |假</p> 
 <p>在元组 TupleList 列表中搜索 第 N个元素比较等于 Key 的元组。 如果找到这样的元组，则返回元组， 否则为 false。</p> 
</div> 
<h4>keymap</h4> 
<div> 
 <pre><code class="language-Erlang">32&gt; Fun = fun(Atom) -&gt; atom_to_list(Atom) end.
#Fun&lt;erl_eval.44.65746770&gt;
33&gt; lists:keymap(Fun, 2, [{name,jane,22},{name,lizzie,20},{name,lydia,15}]).
[{name,"jane",22},{name,"lizzie",20},{name,"lydia",15}]</code></pre> 
</div> 
<p> keymap（Fun， N， TupleList1） -&gt; TupleList2</p> 
<p>返回一个元组列表，其中，对于 TupleList1 中的每个元组，元组的第 N个元素 Term1 已替换为调用 Fun（Term1） 的结果。</p> 
<h4>keymember</h4> 
<div> 
 <pre><code class="language-Erlang">34&gt; lists:keymember(1,1,[{1,hello},{2,key},{3,value}]).                     
true
35&gt; lists:keymember(1,1,[{2,key},{3,value}]).          
false</code></pre> 
</div> 
<p></p> 
<p id="keymember-3">keymember（Key， N， TupleList） -&gt;boolean()</p> 
<p>如果 TupleList 中有一个元组，其第 N个元素，则返回 true compares 等于 Key，否则为 false。</p> 
<p> </p> 
<h4>keymerge</h4> 
<div> 
 <pre><code class="language-Erlang">36&gt; lists:keymerge(1,[{2,key},{3,value}],[{1,hello},{2,tuple},{3,none}]).
[{1,hello},{2,key},{2,tuple},{3,value},{3,none}]</code></pre> 
</div> 
<p>keymerge（N， TupleList1， TupleList2） -&gt; TupleList3</p> 
<p>返回通过合并 TupleList1 和 TupleList2 形成的排序列表。 合并是在每个元素的第 N个元素上执行的 元。在计算之前，必须对 TupleList1 和 TupleList2 进行键排序 此功能。当两个元组比较相等时，在 TupleList1 中的元组之前选取 TupleList2 中的元组。</p> 
<h4>keyreplace</h4> 
<div> 
 <pre><code class="language-Erlang">38&gt; lists:keyreplace(2,1,[{2,key},{3,value}],{1,hello}). 
[{1,hello},{3,value}]
39&gt; lists:keyreplace(1,1,[{2,key},{3,value}],{1,hello}).
[{2,key},{3,value}]
</code></pre> 
</div> 
<p id="keyreplace-4">keyreplace（Key， N， TupleList1， NewTuple） -&gt; TupleList2</p> 
<p> 返回 TupleList1 的副本，其中第一个 出现一个 T 元组，其第 N个元素 如果存在这样的元组 T，则将等于 Key 替换为 NewTuple。</p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/20cd8b2ecc82e0e43dab37d2bd6fd0a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FPGA之分布式RAM（2）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/77cfaecec28dc909a1098a76cb7d4ad9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WPF多值转换器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>