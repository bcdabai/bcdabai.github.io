<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker入门学习 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker入门学习" />
<meta property="og:description" content="Docker入门学习 Docker安装
Docker Hello World docker run ubuntu:15.10 /bin/echo &#34;Hello world&#34; 解释：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。
docker: Docker 的二进制执行文件。run: 与前面的 docker 组合来运行一个容器。ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。/bin/echo “Hello world”: 在启动的容器里执行的命令 运行交互式的容器 docker run -i -t ubuntu:15.10 /bin/bash -t: 在新容器内指定一个伪终端或终端。-i: 允许你对容器内的标准输入 (STDIN) 进行交互。 运行 exit 命令或者使用 CTRL&#43;D 来退出容器。
后台启动容器 docker run -d ubuntu:15.10 /bin/sh -c &#34;while true; do echo hello world; sleep 1; done&#34; 返回的长串代表的是容器ID“adfe9755…”
docker ps用来查看容器" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/daffc17adab2194f0dd0f198291d530b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-29T19:05:45+08:00" />
<meta property="article:modified_time" content="2022-09-29T19:05:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker入门学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Docker_0"></a>Docker入门学习</h2> 
<p><a href="https://blog.csdn.net/qq_40893942/article/details/127006519">Docker安装</a></p> 
<h4><a id="Docker_Hello_World_4"></a>Docker Hello World</h4> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run ubuntu:15.10 /bin/echo <span class="token string">"Hello world"</span>
</code></pre> 
<p>解释：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。</p> 
<ul><li><strong>docker:</strong> Docker 的二进制执行文件。</li><li><strong>run:</strong> 与前面的 docker 组合来运行一个容器。</li><li><strong>ubuntu:15.10</strong> 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li><li><strong>/bin/echo “Hello world”:</strong> 在启动的容器里执行的命令</li></ul> 
<h5><a id="_17"></a>运行交互式的容器</h5> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -i -t ubuntu:15.10 /bin/bash
</code></pre> 
<ul><li><strong>-t:</strong> 在新容器内指定一个伪终端或终端。</li><li><strong>-i:</strong> 允许你对容器内的标准输入 (STDIN) 进行交互。</li></ul> 
<p><img src="https://images2.imgbox.com/2d/3f/9PZ1A8q8_o.png" alt="在这里插入图片描述"></p> 
<p>运行 exit 命令或者使用 CTRL+D 来退出容器。</p> 
<h5><a id="_31"></a>后台启动容器</h5> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -d ubuntu:15.10 /bin/sh -c <span class="token string">"while true; do echo hello world; sleep 1; done"</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/5f/7b/Pu6dNeY6_o.png" alt="在这里插入图片描述"></p> 
<p>返回的长串代表的是容器ID“adfe9755…”</p> 
<p><code>docker ps</code>用来查看容器</p> 
<p><img src="https://images2.imgbox.com/ca/b2/RC0kRUJD_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p><strong>CONTAINER ID:</strong> 容器 ID。</p> </li><li> <p><strong>IMAGE:</strong> 使用的镜像。</p> </li><li> <p><strong>COMMAND:</strong> 启动容器时运行的命令。</p> </li><li> <p><strong>CREATED:</strong> 容器的创建时间。</p> </li><li> <p><strong>STATUS:</strong> 容器状态。</p> <p>状态有7种：</p> 
  <ul><li>created（已创建）</li><li>restarting（重启中）</li><li>running 或 Up（运行中）</li><li>removing（迁移中）</li><li>paused（暂停）</li><li>exited（停止）</li><li>dead（死亡）</li></ul> </li><li> <p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p> </li><li> <p><strong>NAMES:</strong> 自动分配的容器名称。</p> </li></ul> 
<p>宿主主机内使用 <strong>docker logs</strong> 命令，查看容器内的标准输出：</p> 
<p><img src="https://images2.imgbox.com/89/b7/atrm3nCE_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_75"></a>停止容器</h5> 
<p><code>docker stop "容器id"</code></p> 
<p><img src="https://images2.imgbox.com/82/05/XWP56Qv1_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Docker__82"></a>Docker 容器使用</h4> 
<h5><a id="_84"></a>获取镜像</h5> 
<p>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> pull ubuntu
</code></pre> 
<h5><a id="_92"></a>启动已停止运行的容器</h5> 
<p>查看所有的容器命令如下：</p> 
<pre><code> docker ps -a
</code></pre> 
<p>使用 docker start 启动一个已停止的容器：</p> 
<pre><code> docker start 
</code></pre> 
<p><img src="https://images2.imgbox.com/6f/35/1OTfHqOL_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_109"></a>进入容器</h5> 
<p>在使用 <strong>-d</strong> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p> 
<ul><li><strong>docker attach</strong></li><li><strong>docker exec</strong>：推荐大家使用 docker exec 命令，因为此命令会退出容器终端，但不会导致容器的停止。</li></ul> 
<h5><a id="_116"></a>导出和导入容器</h5> 
<h6><a id="_118"></a><strong>导出容器</strong></h6> 
<p>如果要导出本地某个容器，可以使用 <strong>docker export</strong> 命令。</p> 
<p><code>docker export a9dd521 &gt; ubuntu.tar</code></p> 
<h6><a id="_124"></a><strong>导入容器快照</strong></h6> 
<p>可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:</p> 
<p><code>cat ubuntu.tar | docker import - test/ubuntu:v1</code></p> 
<p><img src="https://images2.imgbox.com/fc/e1/XhwyM5Gr_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_133"></a>删除容器</h5> 
<p><code>docker container prune</code> 命令可以清理掉所有处于终止状态的容器。</p> 
<p><img src="https://images2.imgbox.com/f2/6a/B523vDXo_o.png" alt="在这里插入图片描述"></p> 
<p><code>docker rm</code></p> 
<p><img src="https://images2.imgbox.com/40/da/8X0DOfB8_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="a_nameweb_web_a_145"></a>运行 web 应用</h5> 
<p>尝试使用 docker 构建一个 web 应用程序。</p> 
<p>在docker容器中运行一个 Python Flask 应用来运行一个web应用。</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> pull training/webapp  <span class="token comment"># 载入镜像</span>
<span class="token function">docker</span> run -d -P training/webapp python app.py
</code></pre> 
<ul><li>**-d:**让容器在后台运行。</li><li>**-P:**将容器内部使用的网络端口随机映射到我们使用的主机上。</li></ul> 
<blockquote> 
 <p>在运行<code>docker pull training/webapp</code>出现错误“Error response from daemon: Get “https://registry-1.docker.io/v2/”: net/http: TLS handshake timeout”</p> 
 <p>解决办法参考：https://blog.csdn.net/qq_40893942/article/details/127011382</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/32/2a/nCeFKPLW_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到多了端口信息</p> 
<p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 49153 上。</p> 
<p>这时我们可以通过浏览器访问WEB应用</p> 
<p><img src="https://images2.imgbox.com/c0/73/YQbwE9gm_o.png" alt="在这里插入图片描述"></p> 
<p>通过 -p 参数来设置不一样的端口：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -d -p <span class="token number">5000</span>:5000 training/webapp python app.py
</code></pre> 
<p>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。</p> 
<h5><a id="_183"></a>网络端口的快捷方式</h5> 
<p>通过 <strong>docker ps</strong> 命令可以查看到容器的端口映射，<strong>docker</strong> 还提供了另一个快捷方式 <strong>docker port</strong>，使用 <strong>docker port</strong> 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</p> 
<p>上面我们创建的 web 应用容器 ID 为 <strong>85dbbbfdf937</strong> 名字为 <strong>distracted_bell</strong>。</p> 
<p>我可以使用 <strong>docker port 85dbbbfdf937</strong> 或 <strong>docker port distracted_bell</strong> 来查看容器端口的映射情况。</p> 
<h5><a id="_WEB__191"></a>查看 WEB 应用程序日志</h5> 
<p>docker logs [ID或者名字] 可以查看容器内部的标准输出。</p> 
<h5><a id="WEB_195"></a>查看WEB应用程序容器的进程</h5> 
<p>我们还可以使用 docker top 来查看容器内部运行的进程</p> 
<h5><a id="_WEB__199"></a>检查 WEB 应用程序</h5> 
<p>使用 <strong>docker inspect</strong> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</p> 
<h5><a id="WEB_203"></a>重启WEB应用容器</h5> 
<p>已经停止的容器，我们可以使用命令 docker start 来启动。</p> 
<p>docker ps -l 查询最后一次创建的容器：</p> 
<pre><code>  docker ps -l 
</code></pre> 
<p>正在运行的容器，我们可以使用 <strong>docker restart</strong> 命令来重启。</p> 
<h5><a id="WEB_215"></a>移除WEB应用容器</h5> 
<p>我们可以使用 docker rm 命令来删除不需要的容器</p> 
<p>删除容器时，容器必须是停止状态，否则会报错</p> 
<h4><a id="Docker__221"></a>Docker 镜像使用</h4> 
<p><code>docker images</code>：列出镜像</p> 
<p><code>docker pull xxx</code>：当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p> 
<p><code>docker search xxx</code>：查找镜像</p> 
<p><code>docker rmi hello-world</code>：删除镜像</p> 
<h5><a id="_231"></a>创建镜像</h5> 
<p>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。</p> 
<ol><li>从已经创建的容器中更新镜像，并且提交这个镜像</li><li>使用 Dockerfile 指令来创建一个新的镜像</li></ol> 
<h6><a id="_238"></a>更新镜像</h6> 
<p>更新镜像之前，我们需要使用镜像来创建一个容器。</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@VM-4-4-centos ~<span class="token punctuation">]</span><span class="token comment"># docker run -i -t ubuntu:15.10 /bin/bash</span>
root@b6c6dd942ccb:/<span class="token comment"># apt-get update</span>
</code></pre> 
<p>在运行的容器内使用 <strong>apt-get update</strong> 命令进行更新。</p> 
<p>在完成操作之后，输入 exit 命令来退出这个容器。</p> 
<p>此时 ID 为 b6c6dd942ccb的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@VM-4-4-centos ~<span class="token punctuation">]</span><span class="token comment"># docker commit -m="has update,but failed." -a="qingchen" b6c6dd942ccb qingchen/ubuntu:v2</span>
sha256:f19c33de62bdd0d04e9cb1f261a4b5748ee818e9eddc310f4996554abc8081ac
</code></pre> 
<p>参数说明：</p> 
<ul><li><strong>-m:</strong> 提交的描述信息</li><li><strong>-a:</strong> 指定镜像作者</li><li>**b6c6dd942ccb：**容器 ID</li><li><strong>qingchen/ubuntu:v2:</strong> 指定要创建的目标镜像名</li></ul> 
<p><strong>docker images</strong> 命令查看<strong>qingchen/ubuntu:v2</strong></p> 
<h6><a id="_267"></a>构建镜像</h6> 
<p>命令 <strong>docker build</strong> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 <code>Dockerfile</code> 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@VM-4-4-centos ~<span class="token punctuation">]</span><span class="token comment"># vim Dockerfile </span>

FROM centos:6.7
MAINTAINER Fisher <span class="token string">"fisher@sudops.com"</span>

RUN /bin/echo <span class="token string">'root:123456'</span> <span class="token operator">|</span>chpasswd
RUN <span class="token function">useradd</span> qingchen
RUN /bin/echo <span class="token string">'qingchen:123456'</span> <span class="token operator">|</span>chpasswd
EXPOSE <span class="token number">22</span>
EXPOSE <span class="token number">80</span>
CMD /usr/sbin/sshd -D
</code></pre> 
<p>使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@VM-4-4-centos ~<span class="token punctuation">]</span><span class="token comment"># docker build -t qingchen/centos:6.7 .</span>
Sending build context to Docker daemon  <span class="token number">26</span>.11kB
Step <span class="token number">1</span>/8 <span class="token builtin class-name">:</span> FROM centos:6.7
 ---<span class="token operator">&gt;</span> 9f1de3c6ad53
Step <span class="token number">2</span>/8 <span class="token builtin class-name">:</span> MAINTAINER Fisher <span class="token string">"fisher@sudops.com"</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
Successfully built bdd2ecffec26
Successfully tagged qingchen/centos:6.7
</code></pre> 
<p>参数说明：</p> 
<ul><li><strong>-t</strong> ：指定要创建的目标镜像名</li><li><strong>.</strong> ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li></ul> 
<h5><a id="_303"></a>设置镜像标签</h5> 
<p><code>docker tag bdd2ecffec26 qingchen/centos:dev</code></p> 
<p>docker tag 镜像ID，这里是 bdd2ecffec26 ,用户名称、镜像源名(repository name)和新的标签名(tag)。</p> 
<p>使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签。</p> 
<h4><a id="Docker_311"></a>Docker容器连接</h4> 
<h5><a id="_313"></a>网络端口映射</h5> 
<p>在<a href="#web" rel="nofollow">前面的 web 应用</a>时使用了运行python应用命令</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -d -P training/webapp python app.py
</code></pre> 
<p>我们使用 <strong>-P、-p</strong> 绑定端口号</p> 
<p>两种方式的区别是:</p> 
<ul><li><strong>-P :<strong>是容器内部端口</strong>随机</strong>映射到主机的端口。</li><li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</li></ul> 
<p>另外，还可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -d -p <span class="token number">127.0</span>.0.1:5001:5000 training/webapp python app.py
</code></pre> 
<p>默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 <strong>/udp</strong>。</p> 
<p><strong>docker port</strong> 命令可以让我们快捷地查看端口的绑定情况。</p> 
<h5><a id="Docker__338"></a>Docker 容器互联</h5> 
<p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</p> 
<p>docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</p> 
<h6><a id="_344"></a>容器命名</h6> 
<p>当我们创建一个容器的时候，docker 会自动对它进行命名。另外，也可以使用 <strong>–name</strong> 标识来命名容器，例如：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -d -P --name 周杰伦 training/webapp python app.py
</code></pre> 
<blockquote> 
 <p>PS：命名规则不能是中文 ，only [a-zA-Z0-9][a-zA-Z0-9_.-]</p> 
</blockquote> 
<h6><a id="_354"></a>新建网络</h6> 
<p>下面先创建一个新的 Docker 网络。</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> network create -d bridge test-net
</code></pre> 
<p><img src="https://images2.imgbox.com/74/b6/IDpLMsR1_o.png" alt="在这里插入图片描述"></p> 
<p><strong>-d</strong>：参数指定 Docker 网络类型，有 bridge、overlay。</p> 
<p>其中 overlay 网络类型用于 Swarm mode。</p> 
<h6><a id="_369"></a>连接容器</h6> 
<p>运行一个容器并连接到新建的 test-net 网络:</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -itd --name test1 --network test-net ubuntu /bin/bash
</code></pre> 
<p>打开新的终端，再运行一个容器并加入到 test-net 网络:</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -itd --name test2 --network test-net ubuntu /bin/bash
</code></pre> 
<p>通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。</p> 
<p>test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器）。</p> 
<pre><code class="prism language-shell"><span class="token function">apt-get</span> update
<span class="token function">apt</span> <span class="token function">install</span> iputils-ping
</code></pre> 
<p>如果多个容器之间需要互相连接，推荐使用 Docker Compose。</p> 
<h5><a id="_DNS_394"></a>配置 DNS</h5> 
<p>在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</p> 
<pre><code class="prism language-shell"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"dns"</span> <span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
    <span class="token string">"114.114.114.114"</span>,
    <span class="token string">"8.8.8.8"</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。</p> 
<p>配置完，需要重启 docker 才能生效。</p> 
<blockquote> 
 <p>重启docker服务：<br> systemctl restart docker / service docker restart</p> 
</blockquote> 
<p>查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：</p> 
<pre><code class="prism language-shell">$ <span class="token function">docker</span> run -it --rm  ubuntu  <span class="token function">cat</span> etc/resolv.conf
</code></pre> 
<h6><a id="_420"></a><strong>手动指定容器的配置</strong></h6> 
<p>如果只想在指定的容器设置 DNS，则可以使用以下命令：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -it --rm -h host_ubuntu  --dns<span class="token operator">=</span><span class="token number">114.114</span>.114.114 --dns-search<span class="token operator">=</span>test.com ubuntu
</code></pre> 
<p>参数说明：</p> 
<p><strong>–rm</strong>：容器退出时自动清理容器内部的文件系统。</p> 
<p><strong>-h HOSTNAME 或者 --hostname=HOSTNAME</strong>： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</p> 
<p><strong>–dns=IP_ADDRESS</strong>： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</p> 
<p><strong>–dns-search=DOMAIN</strong>： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。</p> 
<p>如果在容器启动时没有指定 <strong>–dns</strong> 和 <strong>–dns-search</strong>，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。</p> 
<h4><a id="Dockerfile_440"></a>Dockerfile</h4> 
<p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p> 
<h5><a id="_Dockerfile__444"></a>使用 Dockerfile 定制镜像</h5> 
<p>在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加以下内容：</p> 
<pre><code class="prism language-shell">FROM nginx
RUN <span class="token builtin class-name">echo</span> <span class="token string">'从本地构建的nginx镜像'</span> <span class="token operator">&gt;</span> /usr/share/nginx/html/index.html
</code></pre> 
<p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p> 
<p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下俩种格式：</p> 
<p>shell 格式：</p> 
<pre><code>RUN &lt;命令行命令&gt;
# &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。
</code></pre> 
<p>exec 格式：</p> 
<pre><code>RUN ["可执行文件", "参数1", "参数2"]
# 例如：
# RUN ["./test.php", "dev", "offline"] 等价于 RUN ./test.php dev offline
</code></pre> 
<p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p> 
<pre><code class="prism language-shell">FROM centos
RUN **yum** -y **install** **wget**
RUN **wget** -O redis.tar.gz <span class="token string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span>
RUN **tar** -xvf redis.tar.gz
</code></pre> 
<p>以上执行会创建 3 层镜像。可简化为以下格式：</p> 
<pre><code class="prism language-shell">FROM centos
RUN **yum** -y **install** **wget** <span class="token punctuation">\</span>
  **<span class="token operator">&amp;&amp;</span>** **wget** -O redis.tar.gz <span class="token string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> <span class="token punctuation">\</span>
  **<span class="token operator">&amp;&amp;</span>** **tar** -xvf redis.tar.gz
</code></pre> 
<p>如上，以 <strong>&amp;&amp;</strong> 符号连接命令，这样执行后，只会创建 1 层镜像。</p> 
<h5><a id="_492"></a>构建镜像</h5> 
<p>在 Dockerfile 文件的存放目录下，执行构建动作。</p> 
<p><code>docker build -t nginx:v1 .</code></p> 
<p>最后的 <code>.</code> 代表本次执行的上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p> 
<p><strong>解析</strong>：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p> 
<p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</p> 
<p><strong>注意</strong>：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p> 
<h5><a id="Dockerfilehttpsblogcsdnnetqq_40893942articledetails127109533_506"></a><a href="https://blog.csdn.net/qq_40893942/article/details/127109533">Dockerfile指令</a></h5> 
<ul><li> <p>FROM：构建镜像基于哪个镜像</p> </li><li> <p>MAINTAINER：镜像维护者姓名或邮箱地址</p> </li><li> <p>RUN：构建镜像执行的命令，每一次RUN都会构建一层</p> </li><li> <p>CMD：容器启动的命令，如果有多个则以最后一个为准，也可以为ENTRYPOINT提供参数</p> </li><li> <p>VOLUME：指定容器挂载点到宿主机自动生成的目录或其他容器</p> </li><li> <p>USER：为RUN、CMD、和 ENTRYPOINT 执行命令指定运行用户</p> </li><li> <p>WORKDIR：为 RUN、CMD、ENTRYPOINT、COPY 和 ADD 设置工作目录，就是切换目录</p> </li><li> <p>HEALTHCHECH：健康检查</p> </li><li> <p>ARG：构建时指定的一些参数</p> </li><li> <p>EXPOSE：声明容器的服务端口（仅仅是声明）</p> </li><li> <p>ENV：设置容器环境变量</p> </li><li> <p>ADD：拷贝文件或目录到容器中，如果是URL或压缩包便会自动下载或自动解压</p> </li><li> <p>COPY：拷贝文件或目录到容器中，跟ADD类似，但不具备自动下载或解压的功能</p> </li><li> <p>ENTRYPOINT：运行容器时执行的shell命令</p> </li></ul> 
<h4><a id="Docker_Compose_536"></a>Docker Compose</h4> 
<h5><a id="Compose__538"></a>Compose 简介</h5> 
<p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p> 
<p>Compose 使用的三个步骤：</p> 
<ul><li>使用 Dockerfile 定义应用程序的环境。</li><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li><li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li></ul> 
<h5><a id="Compose__548"></a>Compose 安装</h5> 
<ul><li>下载二进制包</li></ul> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -s<span class="token variable">`</span></span>-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -m<span class="token variable">`</span></span> <span class="token operator">&gt;</span> /usr/local/bin/docker-compose
</code></pre> 
<ul><li>可执行权限应用于二进制文件</li></ul> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">chmod</span> +x /usr/local/bin/docker-compose
</code></pre> 
<ul><li>创建软链</li></ul> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">ln</span> -s /usr/local/bin/docker-compose /usr/bin/docker-compose
</code></pre> 
<p>测试是否安装成功：</p> 
<p><code>[root@VM-4-4-centos ~]# docker-compose version</code><br> <code>Docker Compose version v2.4.1</code></p> 
<h5><a id="Compose__573"></a>Compose 使用</h5> 
<h6><a id="_575"></a>准备</h6> 
<p>创建测试目录</p> 
<pre><code class="prism language-shell">$ <span class="token function">mkdir</span> composetest
$ <span class="token builtin class-name">cd</span> composetest
</code></pre> 
<p>创建一个名为 app.py 的文件</p> 
<pre><code>import time

import redis
from flask import Flask

app = Flask(__name__)
cache = redis.Redis(host='redis', port=6379)


def get_hit_count():
    retries = 5
    while True:
        try:
            return cache.incr('hits')
        except redis.exceptions.ConnectionError as exc:
            if retries == 0:
                raise exc
            retries -= 1
            time.sleep(0.5)


@app.route('/')
def hello():
    count = get_hit_count()
    return 'Hello World! I have been seen {} times.\n'.format(count)
</code></pre> 
<p>创建另一个名为 <strong>requirements.txt</strong> 的文件，内容如下：</p> 
<pre><code>flask
redis
</code></pre> 
<h6><a id="2_Dockerfile__621"></a>2、创建 Dockerfile 文件</h6> 
<p>创建一个名为 <strong>Dockerfile</strong> 的文件，内容如下：</p> 
<pre><code>FROM python:3.7-alpine
WORKDIR /code
ENV FLASK_APP app.py
ENV FLASK_RUN_HOST 0.0.0.0
RUN apk add --no-cache gcc musl-dev linux-headers
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
CMD ["flask", "run"]
</code></pre> 
<ul><li> <p><strong>FROM python:3.7-alpine</strong>: 从 Python 3.7 映像开始构建镜像。</p> </li><li> <p><strong>WORKDIR /code</strong>: 将工作目录设置为 /code。</p> </li><li> <pre><code>ENV FLASK_APP app.py
ENV FLASK_RUN_HOST 0.0.0.0
</code></pre> <p>设置 flask 命令使用的环境变量。</p> </li><li> <p><strong>RUN apk add --no-cache gcc musl-dev linux-headers</strong>: 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。</p> </li><li> <pre><code>COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
</code></pre> <p>复制 requirements.txt 并安装 Python 依赖项。</p> </li><li> <p><strong>COPY . .</strong>: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。</p> </li><li> <p><strong>CMD [“flask”, “run”]</strong>: 容器提供默认的执行命令为：flask run。</p> </li></ul> 
<h6><a id="3_dockercomposeyml_661"></a>3.创建 docker-compose.yml</h6> 
<p>创建一个名为 docker-compose.yml 的文件，然后粘贴以下内容：</p> 
<pre><code class="prism language-yaml"><span class="token comment"># yaml 配置</span>
<span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> .
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
     <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:alpine"</span>
</code></pre> 
<p>该 Compose 文件定义了两个服务：web 和 redis。</p> 
<ul><li><strong>web</strong>：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000</li><li><strong>redis</strong>：该 redis 服务使用 Docker Hub 的公共 Redis 映像。</li></ul> 
<h6><a id="4_Compose__683"></a>4、使用 Compose 命令构建和运行</h6> 
<pre><code class="prism language-shell"><span class="token function">docker-compose</span> up -d
</code></pre> 
<h6><a id="yml_httpsblogcsdnnetqq_40893942articledetails127110610_689"></a><a href="https://blog.csdn.net/qq_40893942/article/details/127110610">yml 配置指令参考</a></h6> 
<h4><a id="Swarm__691"></a>Swarm 集群管理</h4> 
<p>Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机。</p> 
<h5><a id="_695"></a>原理</h5> 
<p>swarm 集群由管理节点（manager）和工作节点（work node）构成。</p> 
<ul><li><strong>swarm mananger</strong>：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。</li><li><strong>work node</strong>：即图中的 available node，主要负责运行相应的服务来执行任务（task）。</li></ul> 
<p><img src="https://images2.imgbox.com/4d/bf/jp7aamia_o.png" alt="img"></p> 
<p><a href="https://www.runoob.com/docker/docker-tutorial.html" rel="nofollow">参考链接</a>：https://www.runoob.com/docker/docker-tutorial.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/64e562f381233662511ce34e87414e18/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL中 count(*)、count(主键id)、count(字段)和count(1)的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0bfdb1a4fb41ecc9dc8402f7d0ade87a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java synchronized类锁，对象锁详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>