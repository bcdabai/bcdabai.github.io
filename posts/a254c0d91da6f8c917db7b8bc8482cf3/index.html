<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数字图像处理(19): 边缘检测算子(Roberts算子、Prewitt算子、Sobel算子 和 Laplacian算子) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数字图像处理(19): 边缘检测算子(Roberts算子、Prewitt算子、Sobel算子 和 Laplacian算子)" />
<meta property="og:description" content="目录
1 边缘检测的基本原理
2 边缘检测算子分类
3 梯度
3.1 图像梯度
3.2 梯度算子
4 Roberts 算子
4.1 基本原理
4.2 代码示例
5 Prewitt 算子
5.1 基本原理
5.2 代码示例
6 Sobel 算子
6.1 基本原理
6.2 代码示例
7 Laplacian 算子
7.1 基本原理
7.2 代码示例
8 小结
8.1 各类算子实验比较
8.2 各类算子的优缺点
参考资料
1 边缘检测的基本原理 图像边缘是图像最基本的特征，所谓边缘(Edge) 是指图像局部特性的不连续性。灰度或结构等信息的突变处称之为边缘。例如，灰度级的突变、颜色的突变,、纹理结构的突变等。边缘是一个区域的结束，也是另一个区域的开始，利用该特征可以分割图像。
如图1所示，当我们看到一个有边缘的物体时，首先感受到的就是边缘。
图1 灰度级跃变的边缘模型 图1(a)是一个理想的边缘所具备的特性。每个灰度级跃变到一个垂直的台阶上。而实际上，在图像采集系统的性能、采样率和获取图像的照明条件等因素的影响，得到的边缘往往是模糊的，边缘被模拟成具有“斜坡面”的剖面，如图1(b)所示，在这个模型中，模糊的边缘变得“宽”了，而清晰的边缘变得“窄”了。
图像的边缘有方向和幅度两种属性。边缘通常可以通过一阶导数或二阶导数检测得到。一阶导数是以最大值作为对应的边缘的位置，而二阶导数则以过零点作为对应边缘的位置。
2 边缘检测算子分类 （1）一阶导数的边缘算子
通过模板作为核与图像的每个像素点做卷积和运算，然后选取合适的阈值来提取图像的边缘。常见的有Roberts算子、Sobel算子和Prewitt算子。
（2）二阶导数的边缘算子
依据于二阶导数过零点，常见的有Laplacian 算子，此类算子对噪声敏感。
（3）其他边缘算子
前面两类均是通过微分算子来检测图像边缘，还有一种就是Canny算子，其是在满足一定约束条件下推导出来的边缘检测最优化算子。
3 梯度 3.1 图像梯度 为了达到寻找边缘的目的，检测灰度变化可用一阶导数或二阶导数来完成。下面将讨论一阶导数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a254c0d91da6f8c917db7b8bc8482cf3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-05T16:15:33+08:00" />
<meta property="article:modified_time" content="2019-05-05T16:15:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数字图像处理(19): 边缘检测算子(Roberts算子、Prewitt算子、Sobel算子 和 Laplacian算子)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" class="has" height="549" src="https://images2.imgbox.com/1f/c4/zNNOTIBE_o.png" width="986"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%20%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#1%20%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" rel="nofollow">1 边缘检测的基本原理</a></p> 
<p id="2%20%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E5%AD%90%E5%88%86%E7%B1%BB-toc" style="margin-left:0px;"><a href="#2%20%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E5%AD%90%E5%88%86%E7%B1%BB" rel="nofollow">2 边缘检测算子分类</a></p> 
<p id="3%20%E6%A2%AF%E5%BA%A6-toc" style="margin-left:0px;"><a href="#3%20%E6%A2%AF%E5%BA%A6" rel="nofollow">3 梯度</a></p> 
<p id="3.1%20%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6-toc" style="margin-left:40px;"><a href="#3.1%20%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6" rel="nofollow">3.1 图像梯度</a></p> 
<p id="3.2%20%E6%A2%AF%E5%BA%A6%E7%AE%97%E5%AD%90-toc" style="margin-left:40px;"><a href="#3.2%20%E6%A2%AF%E5%BA%A6%E7%AE%97%E5%AD%90" rel="nofollow">3.2 梯度算子</a></p> 
<p id="4%20Roberts%20%E7%AE%97%E5%AD%90-toc" style="margin-left:0px;"><a href="#4%20Roberts%20%E7%AE%97%E5%AD%90" rel="nofollow">4 Roberts 算子</a></p> 
<p id="4.1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#4.1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" rel="nofollow">4.1 基本原理</a></p> 
<p id="4.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#4.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow">4.2 代码示例</a></p> 
<p id="5%20Prewitt%20%E7%AE%97%E5%AD%90-toc" style="margin-left:0px;"><a href="#5%20Prewitt%20%E7%AE%97%E5%AD%90" rel="nofollow">5 Prewitt 算子</a></p> 
<p id="5.1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#5.1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" rel="nofollow">5.1 基本原理</a></p> 
<p id="5.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#5.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow">5.2 代码示例</a></p> 
<p id="6%20Sobel%20%E7%AE%97%E5%AD%90-toc" style="margin-left:0px;"><a href="#6%20Sobel%20%E7%AE%97%E5%AD%90" rel="nofollow">6 Sobel 算子</a></p> 
<p id="6.1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#6.1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" rel="nofollow">6.1 基本原理</a></p> 
<p id="6.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#6.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow">6.2 代码示例</a></p> 
<p id="7%20Laplacian%20%E7%AE%97%E5%AD%90-toc" style="margin-left:0px;"><a href="#7%20Laplacian%20%E7%AE%97%E5%AD%90" rel="nofollow">7 Laplacian 算子</a></p> 
<p id="7.1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#7.1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" rel="nofollow">7.1 基本原理</a></p> 
<p id="7.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#7.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow">7.2 代码示例</a></p> 
<p id="8%20%E5%B0%8F%E7%BB%93-toc" style="margin-left:0px;"><a href="#8%20%E5%B0%8F%E7%BB%93" rel="nofollow">8 小结</a></p> 
<p id="8.1%20%E5%90%84%E7%B1%BB%E7%AE%97%E5%AD%90%E5%AE%9E%E9%AA%8C%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#8.1%20%E5%90%84%E7%B1%BB%E7%AE%97%E5%AD%90%E5%AE%9E%E9%AA%8C%E6%AF%94%E8%BE%83" rel="nofollow">8.1 各类算子实验比较</a></p> 
<p id="8.2%20%E5%90%84%E7%B1%BB%E7%AE%97%E5%AD%90%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;"><a href="#8.2%20%E5%90%84%E7%B1%BB%E7%AE%97%E5%AD%90%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">8.2 各类算子的优缺点</a></p> 
<p id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-toc" style="margin-left:0px;"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" rel="nofollow">参考资料</a></p> 
<hr id="hr-toc"> 
<p> </p> 
<h2 id="1%20%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" style="margin-left:0cm;">1 边缘检测的基本原理</h2> 
<p style="text-indent:50px;">图像边缘是图像最基本的特征，所谓<strong>边缘</strong>(Edge) 是指图像局部特性的不连续性。灰度或结构等信息的突变处称之为<strong>边缘</strong>。例如，灰度级的突变、颜色的突变,、纹理结构的突变等。边缘是一个区域的结束，也是另一个区域的开始，利用该特征可以分割图像。</p> 
<p style="text-indent:50px;">如图1所示，当我们看到一个有边缘的物体时，首先感受到的就是<span style="color:#f33b45;"><strong>边缘</strong></span>。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="136" src="https://images2.imgbox.com/25/30/zeXDg1Lb_o.png" width="322"> 
  <figcaption>
    图1 灰度级跃变的边缘模型 
  </figcaption> 
 </figure> 
</div> 
<p style="text-indent:50px;">图1(a)是一个理想的边缘所具备的特性。每个灰度级跃变到一个垂直的台阶上。而实际上，在图像采集系统的性能、采样率和获取图像的照明条件等因素的影响，得到的边缘往往是模糊的，边缘被模拟成具有“斜坡面”的剖面，如图1(b)所示，在这个模型中，模糊的边缘变得“宽”了，而清晰的边缘变得“窄”了。</p> 
<p style="text-indent:50px;">图像的边缘有方向和幅度两种属性。边缘通常可以通过<strong>一阶导数</strong>或<strong>二阶导数</strong>检测得到。<strong>一阶导数</strong>是以<strong><span style="color:#f33b45;">最大值</span></strong>作为对应的边缘的位置，而<strong>二阶导数</strong>则以<span style="color:#f33b45;"><strong>过零点</strong></span>作为对应边缘的位置。</p> 
<hr> 
<p style="margin-left:0cm;"> </p> 
<h2 id="2%20%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E5%AD%90%E5%88%86%E7%B1%BB" style="margin-left:0cm;">2 边缘检测算子分类</h2> 
<p style="text-indent:0;">（1）一阶导数的边缘算子</p> 
<p style="text-indent:50px;">通过模板作为核与图像的每个像素点做卷积和运算，然后选取合适的阈值来提取图像的边缘。常见的有Roberts算子、Sobel算子和Prewitt算子。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">（2）二阶导数的边缘算子</p> 
<p style="text-indent:50px;">依据于二阶导数过零点，常见的有Laplacian 算子，此类算子对噪声敏感。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">（3）其他边缘算子</p> 
<p style="text-indent:50px;">前面两类均是通过微分算子来检测图像边缘，还有一种就是Canny算子，其是在满足一定约束条件下推导出来的边缘检测最优化算子。</p> 
<hr> 
<p style="margin-left:0cm;"> </p> 
<h2 id="3%20%E6%A2%AF%E5%BA%A6" style="margin-left:0cm;">3 梯度</h2> 
<h3 id="3.1%20%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6">3.1 图像梯度</h3> 
<p style="text-indent:50px;">为了达到寻找<strong>边缘</strong>的目的，检测灰度变化可用<strong>一阶导数</strong>或<strong>二阶导数</strong>来完成。下面将讨论<strong>一阶导数</strong>。</p> 
<p style="text-indent:50px;">为了在一幅图像<img alt="f" class="mathcode" src="https://images2.imgbox.com/ff/1c/3UQJNqv0_o.gif"> 的<img alt="(x,y)" class="mathcode" src="https://images2.imgbox.com/4f/ab/HBAW5sD6_o.gif">位置处寻找<strong>边缘</strong>的强度和方向，所以选择的工具就是<span style="color:#f33b45;"><strong>梯度</strong></span>，梯度用<img alt="\nabla f" class="mathcode" src="https://images2.imgbox.com/ef/8f/2DErFm1v_o.gif">来表示，并用向量来定义，定义如下所示：</p> 
<p>                                                                             <img alt="\nabla f\equiv \text{grad}(f)\equiv \left[ \begin{matrix} {​{g}_{x}} \\ {​{g}_{y}} \\ \end{matrix} \right]\equiv \left[ \begin{matrix} \frac{\partial f}{\partial x} \\ {} \\ \frac{\partial f}{\partial y} \\ \end{matrix} \right]" class="mathcode" src="https://images2.imgbox.com/92/77/XTyhUT38_o.gif"></p> 
<p> </p> 
<p>其中，梯度<img alt="\nabla f" class="mathcode" src="https://images2.imgbox.com/7c/a8/kmzIuILp_o.gif"> 为一个向量，它表示<img alt="f" class="mathcode" src="https://images2.imgbox.com/a3/0e/wSLXTxU5_o.gif"> 在位置<img alt="(x,y)" class="mathcode" src="https://images2.imgbox.com/96/62/Ay8wS38G_o.gif"> 处的最大变化率的方向。</p> 
<p style="text-indent:50px;">梯度<img alt="\nabla f" class="mathcode" src="https://images2.imgbox.com/cc/3b/w803rkwa_o.gif"> 的大小用<img alt="M(x,y)" class="mathcode" src="https://images2.imgbox.com/60/3d/h4FlyTmT_o.gif"> 表示，则：</p> 
<p>                                                                          <img alt="M(x,y)=mag(\nabla f)=\sqrt{g_{x}^{2}+g_{y}^{2}}" class="mathcode" src="https://images2.imgbox.com/00/01/MkrVQG1I_o.gif"></p> 
<p style="text-indent:0;">其中，<img alt="M(x,y)" class="mathcode" src="https://images2.imgbox.com/d5/2f/zdzoAeyu_o.gif"> 表示梯度向量方向变化率的值。</p> 
<p> </p> 
<p style="text-indent:50px;"><strong>数学梯度的简单推导</strong></p> 
<p style="text-indent:50px;">对于以为函数<img alt="f(x)" class="mathcode" src="https://images2.imgbox.com/51/0c/YBEgRE3i_o.gif"> 在点 <img alt="x" class="mathcode" src="https://images2.imgbox.com/3c/44/wxwEh7Un_o.gif"> 处的导数的近似：将函数<img alt="f(x+\Delta x)" class="mathcode" src="https://images2.imgbox.com/91/71/3fxuPb3Q_o.gif"> 展开为 <img alt="x" class="mathcode" src="https://images2.imgbox.com/7b/cf/Mo9LIyor_o.gif"> 的泰勒级数，令<img alt="\Delta x=1" class="mathcode" src="https://images2.imgbox.com/1a/ca/XCC8HorS_o.gif">，且只保该级数的线性项，则函数<img alt="f(x)" class="mathcode" src="https://images2.imgbox.com/cb/2f/Ah9W6ycN_o.gif"> 的梯度<img alt="\nabla f" class="mathcode" src="https://images2.imgbox.com/c5/10/qPFuq3Y1_o.gif"> 计算为：</p> 
<p style="margin-left:0cm;">                                                                      <img alt="\nabla f=\frac{\partial f}{\partial x}={​{f}^{'}}(x)=f(x+1)-f(x)" class="mathcode" src="https://images2.imgbox.com/03/a7/RSixAzVZ_o.gif"></p> 
<p style="margin-left:0cm;"> </p> 
<h3 id="3.2%20%E6%A2%AF%E5%BA%A6%E7%AE%97%E5%AD%90" style="margin-left:0cm;">3.2 梯度算子</h3> 
<p style="text-indent:50px;">由上面的数学推导可知，要得到一幅图像的<span style="color:#f33b45;"><strong>梯度</strong></span>，则要求在图像的每个像素点位置处计算偏导数。我们处理的是数字量，因此要求关于一点的邻域上的偏导数的数字近似，因此一幅图像<img alt="f" class="mathcode" src="https://images2.imgbox.com/8f/84/h26D3NyN_o.gif"> ，在 <img alt="(x,y)" class="mathcode" src="https://images2.imgbox.com/6b/62/ffN8rj8l_o.gif"> 位置处的 <img alt="x" class="mathcode" src="https://images2.imgbox.com/90/77/Qum8uWT4_o.gif"> 和 <img alt="y" class="mathcode" src="https://images2.imgbox.com/d9/94/2yFOzz5r_o.gif"> 方向上的梯度大小 <img alt="{g}_{x}}" class="mathcode" src="https://images2.imgbox.com/4c/6e/5dMvwixX_o.png"> 和 <img alt="{g}_{y}}" class="mathcode" src="https://images2.imgbox.com/7d/50/e16WUqp8_o.png"> 分别计算为：</p> 
<p style="margin-left:0cm;">                                                                       <img alt="{​{g}_{x}}=\frac{\partial f(x,y)}{\partial x}=f(x+1,y)-f(x,y)" class="mathcode" src="https://images2.imgbox.com/1c/c2/UgnvxJHD_o.gif"></p> 
<p style="margin-left:0cm;">                                                                       <img alt="{​{g}_{y}}=\frac{\partial f(x,y)}{\partial y}=f(x,y+1)-f(x,y)" class="mathcode" src="https://images2.imgbox.com/ce/2f/XmK4w5RS_o.gif"></p> 
<p style="text-indent:0;">上述两个公式对所有 <img alt="x" class="mathcode" src="https://images2.imgbox.com/56/84/XehXJmey_o.gif"> 和 <img alt="y" class="mathcode" src="https://images2.imgbox.com/f5/74/evHOOnio_o.gif"> 的有关值可用下图的<strong>一维模板</strong>对 <img alt="f(x,y)" class="mathcode" src="https://images2.imgbox.com/31/04/9lMbiXaI_o.gif"> 的滤波得到。</p> 
<p style="text-align:center;"><img alt="" height="89" src="https://images2.imgbox.com/92/88/VZZ2sGvq_o.png" width="177"></p> 
<p style="text-indent:50px;">用于计算梯度偏导数的<strong>滤波器模板</strong>，通常称之为<strong>梯度算子</strong>、<strong>边缘算子</strong>和<strong>边缘检测子</strong>等。</p> 
<p style="text-indent:50px;">对于不同的滤波器模板得到的梯度是不同的，这也就衍生出很多算子，如Roberts、Prewitt、Sobel和Laplacian算子等。下面将详细介绍不同的算子。</p> 
<hr> 
<p style="text-indent:0;"> </p> 
<h2 id="4%20Roberts%20%E7%AE%97%E5%AD%90" style="margin-left:0cm;">4 Roberts 算子</h2> 
<h3 id="4.1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">4.1 基本原理</h3> 
<p style="text-indent:50px;"><strong>Roberts算子</strong>又称为交叉微分算法，它是基于交叉差分的梯度算法，通过局部差分计算检测边缘线条。常用来处理具有陡峭的低噪声图像，当图像边缘接近于正45度或负45度时，该算法处理效果更理想。其缺点是对边缘的定位不太准确，提取的边缘线条较粗。</p> 
<p style="text-indent:50px;">Roberts算子的<strong>模板</strong>分为水平方向和垂直方向，如下式所示，从其模板可以看出，Roberts算子能较好的增强正负45度的图像边缘。</p> 
<p>                                                                          <img alt="{​{d}_{x}}=\left[ \begin{matrix} -1 &amp; 0 \\ 0 &amp; 1 \\ \end{matrix} \right]\begin{matrix} {} &amp; {} \\ {} &amp; {} \\ \end{matrix}{​{d}_{y}}=\left[ \begin{matrix} 0 &amp; -1 \\ 1 &amp; 0 \\ \end{matrix} \right]" class="mathcode" src="https://images2.imgbox.com/03/c8/5DuoVI0D_o.gif"></p> 
<p style="text-indent:50px;">例如，下面给出<strong>Roberts算子</strong>的<strong>模板</strong>，在<span style="color:#f33b45;"><strong>像素点P5处 </strong></span><img alt="x" class="mathcode" src="https://images2.imgbox.com/25/1d/NRr5Kmne_o.gif"> 和 <img alt="y" class="mathcode" src="https://images2.imgbox.com/b5/89/cgAxsX36_o.gif"> 方向上的梯度大小 <img alt="{g}_{x}}" class="mathcode" src="https://images2.imgbox.com/64/ac/OfEh07nh_o.png"> 和 <img alt="{g}_{y}}" class="mathcode" src="https://images2.imgbox.com/b2/cd/tXC5AzjN_o.png"> 分别计算为：</p> 
<p style="text-align:center;"><img alt="" class="has" height="190" src="https://images2.imgbox.com/68/77/2Y5ioOGR_o.png" width="483"></p> 
<p>                                                                                   <img alt="{​{g}_{x}}=\frac{\partial f}{\partial x}=\text{P9-P5}" class="mathcode" src="https://images2.imgbox.com/0c/42/y4w0aTqL_o.gif"></p> 
<p>                                                                                   <img alt="{​{g}_{y}}=\frac{\partial f}{\partial y}=\text{P8-P6}" class="mathcode" src="https://images2.imgbox.com/09/d0/4la8Bn3Y_o.gif"></p> 
<p> </p> 
<p> </p> 
<h3 id="4.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">4.2 代码示例</h3> 
<p style="text-indent:50px;">在Python中，Roberts算子主要通过numpy定义模板，再调用OpenCV的 <span style="color:#3399ea;"><strong>filter2D()</strong></span> 函数实现边缘提取。该函数主要是利用内核实现对图像的卷积运算。<span style="color:#3399ea;"><strong>filter2D()</strong></span> 函数用法如下所示：</p> 
<blockquote> 
 <p style="text-indent:50px;"><span style="color:#3399ea;"><strong>dst = filter2D(src, ddepth, kernel[, dst[, anchor[, delta[, borderType]]]])</strong></span></p> 
 <p style="text-indent:0;">其中，参数：</p> 
 <p style="text-indent:50px;">src 表示输入图像；</p> 
 <p style="text-indent:50px;">dst 表示输出的边缘图，其大小和通道数与输入图像相同；</p> 
 <p style="text-indent:50px;">ddepth 表示目标图像所需的深度；</p> 
 <p style="text-indent:50px;">kernel 表示卷积核，一个单通道浮点型矩阵；</p> 
 <p style="text-indent:50px;">anchor 表示内核的基准点，其默认值为 (-1，-1)，位于中心位置；</p> 
 <p style="text-indent:50px;">delta 表示在储存目标图像前可选的添加到像素的值，默认值为0；</p> 
 <p style="text-indent:50px;">borderType 表示边框模式。</p> 
</blockquote> 
<p style="text-indent:50px;">代码如下所示：</p> 
<pre class="has"><code class="language-python"># -*- coding: utf-8 -*-
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 读取图像
img = cv2.imread('zxp.jpg')
img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) #转成RGB 方便后面显示

# 灰度化处理图像
grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Roberts算子
kernelx = np.array([[-1, 0], [0, 1]], dtype=int)
kernely = np.array([[0, -1], [1, 0]], dtype=int)
x = cv2.filter2D(grayImage, cv2.CV_16S, kernelx)
y = cv2.filter2D(grayImage, cv2.CV_16S, kernely)
# 转uint8
absX = cv2.convertScaleAbs(x)
absY = cv2.convertScaleAbs(y)
Roberts = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)

# 用来正常显示中文标签
plt.rcParams['font.sans-serif'] = ['SimHei']

# 显示图形
# titles = [u'原始图像', u'Roberts算子']
# images = [img_RGB, Roberts]
# for i in range(2):
#     plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')
#     plt.title(titles[i])
#     plt.xticks([]), plt.yticks([])

# plt.show()

# 显示图形
plt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭
plt.subplot(122),plt.imshow(Roberts, cmap=plt.cm.gray ),plt.title('Roberts算子'), plt.axis('off')
plt.show()</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p style="text-indent:50px;">运行结果如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="has" height="337" src="https://images2.imgbox.com/ac/9c/1LWG1Qdg_o.png" width="585"></p> 
<p> </p> 
<hr> 
<p style="margin-left:0cm;"> </p> 
<h2 id="5%20Prewitt%20%E7%AE%97%E5%AD%90" style="margin-left:0cm;">5 Prewitt 算子</h2> 
<h3 id="5.1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">5.1 基本原理</h3> 
<p style="text-indent:50px;"><strong>Prewitt算子</strong>是一种图像边缘检测的微分算子，其原理是利用特定区域内像素灰度值产生的差分实现边缘检测。由于Prewitt算子采用 3<img alt="\times" class="mathcode" src="https://images2.imgbox.com/9d/2b/45qqvvBm_o.gif">3 模板对区域内的像素值进行计算，而Robert算子的模板为 2<img alt="\times" class="mathcode" src="https://images2.imgbox.com/11/93/MI1sT3p5_o.gif">2，故Prewitt算子的边缘检测结果在水平方向和垂直方向均比Robert算子更加明显。Prewitt算子适合用来识别噪声较多、灰度渐变的图像，其计算公式如下所示：</p> 
<p>                                                                  <img alt="{​{d}_{y}}=\left[ \begin{matrix} -1 &amp; 0 &amp; 1 \\ -1 &amp; 0 &amp; 1 \\ -1 &amp; 0 &amp; 1 \\ \end{matrix} \right]\begin{matrix} {} &amp; {} &amp; {} \\ {} &amp; {} &amp; {} \\ {} &amp; {} &amp; {} \\ \end{matrix}{​{d}_{x}}=\left[ \begin{matrix} -1 &amp; -1 &amp; -1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1 \\ \end{matrix} \right]" class="mathcode" src="https://images2.imgbox.com/48/2c/c8E5S4Zj_o.gif"></p> 
<p style="text-indent:50px;">例如，下面给出<strong>Prewitt算子</strong>的<strong>模板</strong>，在<span style="color:#f33b45;"><strong>像素点P5处</strong></span> <img alt="x" class="mathcode" src="https://images2.imgbox.com/98/c6/JBjnmij8_o.gif"> 和 <img alt="y" class="mathcode" src="https://images2.imgbox.com/a1/55/lxYgJ58F_o.gif"> 方向上的梯度大小 <img alt="{g}_{x}}" class="mathcode" src="https://images2.imgbox.com/1c/8f/oNU3KUcJ_o.png"> 和 <img alt="{g}_{y}}" class="mathcode" src="https://images2.imgbox.com/6a/74/dzrz61up_o.png"> 分别计算为：</p> 
<p style="text-align:center;"><img alt="" class="has" height="238" src="https://images2.imgbox.com/cb/9a/fFSGprcW_o.png" width="627"></p> 
<p>                                                                <img alt="{​{g}_{x}}=\frac{\partial f}{\partial x}=(\text{P7+P8+P9)-}(\text{P1+P2+P3)}" class="mathcode" src="https://images2.imgbox.com/f7/40/z9WBHLgK_o.gif"></p> 
<p>                                                                <img alt="{​{g}_{y}}=\frac{\partial f}{\partial y}=(\text{P3+P6+P9)-}(\text{P1+P4+P7)}" class="mathcode" src="https://images2.imgbox.com/97/24/rRmnFoJO_o.gif"></p> 
<p> </p> 
<h3 id="5.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">5.2 代码示例</h3> 
<p style="text-indent:50px;">在Python中，Prewitt算子的实现过程与Roberts算子比较相似。通过Numpy定义模板，再调用OpenCV的<span style="color:#3399ea;"><strong>filter2D() </strong></span>函数实现对图像的卷积运算，最终通过<span style="color:#3399ea;"><strong> convertScaleAbs()</strong></span> 和<span style="color:#3399ea;"> <strong>addWeighted()</strong></span> 函数实现边缘提取。<span style="color:#3399ea;"><strong>filter2D() </strong></span>函数用法如下所示：</p> 
<blockquote> 
 <p style="text-indent:50px;"><span style="color:#3399ea;"><strong>dst = filter2D(src, ddepth, kernel[, dst[, anchor[, delta[, borderType]]]])</strong></span></p> 
 <p style="text-indent:0;">其中，参数：</p> 
 <p style="text-indent:50px;">src 表示输入图像；</p> 
 <p style="text-indent:50px;">dst 表示输出的边缘图，其大小和通道数与输入图像相同；</p> 
 <p style="text-indent:50px;">ddepth 表示目标图像所需的深度；</p> 
 <p style="text-indent:50px;">kernel 表示卷积核，一个单通道浮点型矩阵；</p> 
 <p style="text-indent:50px;">anchor 表示内核的基准点，其默认值为(-1，-1)，位于中心位置；</p> 
 <p style="text-indent:50px;">delta 表示在储存目标图像前可选的添加到像素的值，默认值为0；</p> 
 <p style="text-indent:50px;">borderType 表示边框模式。</p> 
</blockquote> 
<p style="margin-left:0cm;"> </p> 
<p style="text-indent:50px;">代码如下所示：</p> 
<pre class="has"><code class="language-python"># -*- coding: utf-8 -*-
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 读取图像
img = cv2.imread('zxp.jpg')
img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# 灰度化处理图像
grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Prewitt算子
kernelx = np.array([[1, 1, 1], [0, 0, 0], [-1, -1, -1]], dtype=int)
kernely = np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]], dtype=int)
x = cv2.filter2D(grayImage, cv2.CV_16S, kernelx)
y = cv2.filter2D(grayImage, cv2.CV_16S, kernely)
# 转uint8
absX = cv2.convertScaleAbs(x)
absY = cv2.convertScaleAbs(y)
Prewitt = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)

# 用来正常显示中文标签
plt.rcParams['font.sans-serif'] = ['SimHei']

# 显示图形
# titles = [u'原始图像', u'Prewitt算子']
# images = [img_RGB, Prewitt]
# for i in range(2):
#     plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')
#     plt.title(titles[i])
#     plt.xticks([]), plt.yticks([])
# plt.show()


# 显示图形
plt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭
plt.subplot(122),plt.imshow(Prewitt, cmap=plt.cm.gray ),plt.title('Prewitt算子'), plt.axis('off')
plt.show()</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p style="text-indent:50px;">运行结果如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="has" height="347" src="https://images2.imgbox.com/d7/5d/3ESCCiQW_o.png" width="595"></p> 
<p style="text-indent:50px;">由上图可以看出Prewitt算子的边缘检测结果在水平方向和垂直方向均比Robert算子更加明显。</p> 
<p> </p> 
<hr> 
<p> </p> 
<h2 id="6%20Sobel%20%E7%AE%97%E5%AD%90" style="margin-left:0cm;">6 Sobel 算子</h2> 
<h3 id="6.1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">6.1 基本原理</h3> 
<p style="text-indent:50px;"><strong>Sobel算子</strong>是一种用于边缘检测的离散微分算子，它结合了高斯平滑和微分求导。该算子用于计算图像明暗程度近似值，根据图像边缘旁边明暗程度把该区域内超过某个数的特定点记为边缘。Sobel算子在Prewitt算子的基础上增加了权重的概念，认为相邻点的距离远近对当前像素点的影响是不同的，距离越近的像素点对应当前像素的影响越大，从而实现图像锐化并突出边缘轮廓。</p> 
<p style="text-indent:50px;">Sobel算子根据像素点上下、左右邻点灰度加权差，在边缘处达到极值这一现象检测边缘。对噪声具有平滑作用，提供较为精确的边缘方向信息。因为Sobel算子结合了高斯平滑和微分求导（分化），因此结果会具有更多的抗噪性，当对精度要求不是很高时，Sobel算子是一种较为常用的边缘检测方法。</p> 
<p style="text-indent:50px;">Sobel算子的边缘定位更准确，常用于噪声较多、灰度渐变的图像。其算法模板如下面的公式所示，其中 <img alt="{​{d}_{x}}" class="mathcode" src="https://images2.imgbox.com/af/49/ur3FcsYh_o.gif"> 表示水平方向，<img alt="{​{d}_{y}}" class="mathcode" src="https://images2.imgbox.com/58/1e/n7n2Y7qG_o.gif"> 表示垂直方向。</p> 
<p>                                                                 <img alt="{​{d}_{x}}=\left[ \begin{matrix} -1 &amp; 0 &amp; 1 \\ -2 &amp; 0 &amp; 2 \\ -1 &amp; 0 &amp; 1 \\ \end{matrix} \right]\begin{matrix} {} &amp; {} &amp; {} \\ {} &amp; {} &amp; {} \\ {} &amp; {} &amp; {} \\ \end{matrix}{​{d}_{y}}=\left[ \begin{matrix} -1 &amp; -2 &amp; -1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 2 &amp; 1 \\ \end{matrix} \right]" class="mathcode" src="https://images2.imgbox.com/16/e4/qd9G5BCo_o.gif"></p> 
<p style="text-indent:50px;">例如，下面给出<strong>Sobel算子</strong>的<strong>模板</strong>，在<span style="color:#f33b45;"><strong>像素点P5处</strong></span> <img alt="x" class="mathcode" src="https://images2.imgbox.com/32/53/mO0Kj2Kl_o.gif"> 和 <img alt="y" class="mathcode" src="https://images2.imgbox.com/11/74/6aosvwrI_o.gif"> 方向上的梯度大小 <img alt="{g}_{x}}" class="mathcode" src="https://images2.imgbox.com/91/8f/ilFkPR6c_o.png"> 和 <img alt="{g}_{y}}" class="mathcode" src="https://images2.imgbox.com/18/66/Qb1xbml5_o.png"> 分别计算为：</p> 
<p style="text-align:center;"><img alt="" class="has" height="243" src="https://images2.imgbox.com/84/69/9G3ZAkQc_o.png" width="619"></p> 
<p>                                                              <img alt="{​{g}_{x}}=\frac{\partial f}{\partial x}=(\text{P7+2P8+P9)-}(\text{P1+2P2+P3)}" class="mathcode" src="https://images2.imgbox.com/0f/2f/zPxE4WWS_o.gif"></p> 
<p>                                                              <img alt="{​{g}_{y}}=\frac{\partial f}{\partial y}=(\text{P3+2P6+P9)-}(\text{P1+2P4+P7)}" class="mathcode" src="https://images2.imgbox.com/9f/63/3yx00eNO_o.gif"></p> 
<p> </p> 
<h3 id="6.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">6.2 代码示例</h3> 
<p style="text-indent:50px;"><span style="color:#3399ea;"><strong>Sobel() </strong></span>函数用法如下所示：</p> 
<blockquote> 
 <p style="text-indent:50px;"><span style="color:#3399ea;"><strong>dst = Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]])</strong></span></p> 
 <p style="text-indent:0;">其中，参数：</p> 
 <p style="text-indent:50px;">src 表示输入图像；</p> 
 <p style="text-indent:50px;">dst 表示输出的边缘图，其大小和通道数与输入图像相同；</p> 
 <p style="text-indent:50px;">ddepth 表示目标图像所需的深度，针对不同的输入图像，输出目标图像有不同的深度；</p> 
 <p style="text-indent:50px;">dx 表示 <img alt="x" class="mathcode" src="https://images2.imgbox.com/65/2d/4h8eWWFZ_o.gif"> 方向上的差分阶数，取值1或 0；</p> 
 <p style="text-indent:50px;">dy 表示 <img alt="y" class="mathcode" src="https://images2.imgbox.com/ee/72/8WewJUu8_o.gif"> 方向上的差分阶数，取值1或0；</p> 
 <p style="text-indent:50px;">ksize 表示Sobel算子的大小，其值必须是<strong>正数</strong>和<strong>奇数</strong>；</p> 
 <p style="text-indent:50px;">scale 表示缩放导数的比例常数，默认情况下没有伸缩系数；</p> 
 <p style="text-indent:50px;">delta 表示将结果存入目标图像之前，添加到结果中的可选增量值；</p> 
 <p style="text-indent:50px;">borderType 表示边框模式，更多详细信息查阅BorderTypes。</p> 
</blockquote> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"><strong><span style="color:#ff0000;">注</span></strong>：在进行Sobel算子处理之后，还需要调用 <span style="color:#3399ea;"><strong>convertScaleAbs() </strong></span>函数计算绝对值，并将<span style="color:#f33b45;"><strong>图像转换为8位图</strong></span>进行显示。其函数用法如下所示：</p> 
<blockquote> 
 <p style="text-indent:50px;"><span style="color:#3399ea;"><strong>dst = convertScaleAbs(src[, dst[, alpha[, beta]]])</strong></span></p> 
 <p style="text-indent:0;">其中，参数：</p> 
 <p style="text-indent:50px;">src 表示原数组；</p> 
 <p style="text-indent:50px;">dst 表示输出数组，深度为8位；</p> 
 <p style="text-indent:50px;">alpha 表示比例因子；</p> 
 <p style="text-indent:50px;">beta 表示原数组元素按比例缩放后添加的值。</p> 
</blockquote> 
<p> </p> 
<p style="text-indent:50px;">代码如下所示：</p> 
<pre class="has"><code class="language-python"># -*- coding: utf-8 -*-
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 读取图像
img = cv2.imread('zxp.jpg')
img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# 灰度化处理图像
grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Sobel算子
x = cv2.Sobel(grayImage, cv2.CV_16S, 1, 0)  # 对x求一阶导
y = cv2.Sobel(grayImage, cv2.CV_16S, 0, 1)  # 对y求一阶导
absX = cv2.convertScaleAbs(x)
absY = cv2.convertScaleAbs(y)
Sobel = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)

# 用来正常显示中文标签
plt.rcParams['font.sans-serif'] = ['SimHei']

# # 显示图形
# titles = [u'原始图像', u'Sobel算子']
# images = [lenna_img, Sobel]
# for i in xrange(2):
#     plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')
#     plt.title(titles[i])
#     plt.xticks([]), plt.yticks([])
# plt.show()

# 显示图形
plt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭
plt.subplot(122),plt.imshow(Sobel, cmap=plt.cm.gray ),plt.title('Sobel算子'), plt.axis('off')
plt.show()</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p style="text-indent:50px;">运行结果如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="has" height="334" src="https://images2.imgbox.com/6e/25/L0WNHJGE_o.png" width="576"></p> 
<p> </p> 
<hr> 
<p> </p> 
<h2 id="7%20Laplacian%20%E7%AE%97%E5%AD%90" style="margin-left:0cm;">7 Laplacian 算子</h2> 
<h3 id="7.1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">7.1 基本原理</h3> 
<p style="text-indent:50px;"><strong>拉普拉斯(Laplacian) 算子</strong>是 <img alt="n" class="mathcode" src="https://images2.imgbox.com/3c/a6/mQRWeDWm_o.gif"> 维欧几里德空间中的一个<span style="color:#f33b45;"><strong>二阶微分算子</strong></span>，常用于图像增强领域和边缘提取。它通过灰度差分计算邻域内的像素。</p> 
<p style="text-indent:50px;"><strong>算法基本流程</strong></p> 
<p style="text-indent:50px;">1）判断图像中心像素灰度值与它周围其他像素的灰度值，如果中心像素的灰度更高，则提升中心像素的灰度；反之降低中心像素的灰度，从而实现图像锐化操作；</p> 
<p style="text-indent:50px;">2）在算法实现过程中，Laplacian算子通过对邻域中心像素的四方向或八方向求梯度，再将梯度相加起来判断中心像素灰度与邻域内其他像素灰度的关系；</p> 
<p style="text-indent:50px;">3）最后通过梯度运算的结果对像素灰度进行调整。</p> 
<p style="text-indent:50px;">Laplacian算子分为四邻域和八邻域，四邻域是对邻域中心像素的四个方向求梯度，八邻域是对八个方向求梯度。</p> 
<p style="text-indent:50px;">其中，Laplacian算子<strong>四邻域</strong>模板如下所示：</p> 
<p>                                                                              <img alt="\text{H}=\left[ \begin{matrix} 0 &amp; -1 &amp; 0 \\ -1 &amp; 4 &amp; -1 \\ 0 &amp; -1 &amp; 0 \\ \end{matrix} \right]" class="mathcode" src="https://images2.imgbox.com/7e/83/7zqdaKTr_o.gif"></p> 
<p style="text-indent:50px;">Laplacian算子的<strong>八邻域</strong>模板如下所示：</p> 
<p style="text-indent:0;">                                                                              <img alt="\text{H}=\left[ \begin{matrix} -1 &amp; -1 &amp; -1 \\ -1 &amp; 8 &amp; -1 \\ -1 &amp; -1 &amp; -1 \\ \end{matrix} \right]" class="mathcode" src="https://images2.imgbox.com/17/99/BGvNDDe4_o.gif"></p> 
<p style="text-indent:50px;">通过Laplacian算子的模板可以发现：</p> 
<p style="text-indent:50px;">1）当邻域内像素灰度相同时，模板的卷积运算结果为0；</p> 
<p style="text-indent:50px;">2）当中心像素灰度高于邻域内其他像素的平均灰度时，模板的卷积运算结果为正数；</p> 
<p style="text-indent:50px;">3）当中心像素的灰度低于邻域内其他像素的平均灰度时，模板的卷积为负数。对卷积运算的结果用适当的衰弱因子处理并加在原中心像素上，就可以实现图像的锐化处理。</p> 
<p>                                                                              </p> 
<p> </p> 
<h3 id="7.2%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">7.2 代码示例</h3> 
<p style="text-indent:50px;">Python和OpenCV将Laplacian算子封装在 <span style="color:#3399ea;"><strong>Laplacian() </strong></span>函数中，其函数用法如下所示：</p> 
<blockquote> 
 <p style="text-indent:50px;"><span style="color:#3399ea;"><strong>dst = Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]])</strong></span></p> 
 <p style="text-indent:0;">其中，参数：</p> 
 <p style="text-indent:50px;">src 表示输入图像；</p> 
 <p style="text-indent:50px;">dst 表示输出的边缘图，其大小和通道数与输入图像相同；</p> 
 <p style="text-indent:50px;">ddepth 表示目标图像所需的深度；</p> 
 <p style="text-indent:50px;">ksize 表示用于计算二阶导数的滤波器的孔径大小，其值必须是正数和奇数，且默认值为1，更多详细信息查阅getDerivKernels ；</p> 
 <p style="text-indent:50px;">scale 表示计算拉普拉斯算子值的可选比例因子。默认值为1，更多详细信息查阅getDerivKernels；</p> 
 <p style="text-indent:50px;">delta 表示将结果存入目标图像之前，添加到结果中的可选增量值，默认值为0；</p> 
 <p style="text-indent:50px;">borderType 表示边框模式，更多详细信息查阅BorderTypes。</p> 
</blockquote> 
<p style="text-indent:50px;"><span style="color:#f33b45;"><strong>注</strong></span>：Laplacian算子其实主要是利用Sobel算子的运算，通过加上Sobel算子运算出的图像 <img alt="x" class="mathcode" src="https://images2.imgbox.com/b4/24/qizTbdWl_o.gif"> 方向和 <img alt="y" class="mathcode" src="https://images2.imgbox.com/17/c5/AegNcnsr_o.gif"> 方向上的导数，得到输入图像的图像锐化结果。同时，在进行Laplacian算子处理之后，还需要调用<span style="color:#3399ea;"><strong> convertScaleAbs()</strong></span> 函数计算绝对值，并将<span style="color:#f33b45;"><strong>图像转换为8位图</strong></span>进行显示。其函数用法如下：</p> 
<blockquote> 
 <p style="text-indent:50px;"><span style="color:#3399ea;"><strong>dst = convertScaleAbs(src[, dst[, alpha[, beta]]])</strong></span></p> 
 <p style="text-indent:0;">其中，参数：</p> 
 <p style="text-indent:50px;">src 表示原数组；</p> 
 <p style="text-indent:50px;">dst 表示输出数组，深度为8位；</p> 
 <p style="text-indent:50px;">alpha 表示比例因子；</p> 
 <p style="text-indent:50px;">beta 表示原数组元素按比例缩放后添加的值。</p> 
</blockquote> 
<p style="text-indent:50px;">当ksize=1时，<span style="color:#3399ea;"><strong>Laplacian() </strong></span>函数采用 3<img alt="\times" class="mathcode" src="https://images2.imgbox.com/80/ec/ttLvGwvF_o.gif">3 的孔径 (四邻域模板) 进行变换处理。下面的代码是采用 ksize=3 的Laplacian算子进行图像锐化处理。</p> 
<p> </p> 
<p style="text-indent:50px;">代码如下所示：</p> 
<pre class="has"><code class="language-python"># -*- coding: utf-8 -*-
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 读取图像
img = cv2.imread('zxp.jpg')
img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# 灰度化处理图像
grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 拉普拉斯算法
dst = cv2.Laplacian(grayImage, cv2.CV_16S, ksize=3)
Laplacian = cv2.convertScaleAbs(dst)

# 用来正常显示中文标签
plt.rcParams['font.sans-serif'] = ['SimHei']

# # 显示图形
# titles = [u'原始图像', u'Laplacian算子']
# images = [lenna_img, Laplacian]
# for i in xrange(2):
#     plt.subplot(1, 2, i + 1), plt.imshow(images[i], 'gray')
#     plt.title(titles[i])
#     plt.xticks([]), plt.yticks([])
# plt.show()


# 显示图形
plt.subplot(121),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭
plt.subplot(122),plt.imshow(Laplacian, cmap=plt.cm.gray ),plt.title('Laplacian算子'), plt.axis('off')
plt.show()</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p style="text-indent:50px;">运行结果如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="has" height="331" src="https://images2.imgbox.com/7b/66/PbjZSbA6_o.png" width="577"></p> 
<p> </p> 
<hr> 
<p> </p> 
<h2 id="8%20%E5%B0%8F%E7%BB%93" style="margin-left:0cm;">8 小结</h2> 
<h3 id="8.1%20%E5%90%84%E7%B1%BB%E7%AE%97%E5%AD%90%E5%AE%9E%E9%AA%8C%E6%AF%94%E8%BE%83">8.1 各类算子实验比较</h3> 
<p style="text-indent:50px;">边缘检测算法主要是基于图像强度的<strong>一阶导数</strong>和<strong>二阶导数</strong>，但导数通常对噪声很敏感，因此需要采用滤波器来过滤噪声，并调用图像增强或阈值化算法进行处理，最后再进行边缘检测。下面是采用高斯滤波去噪和阈值化处理之后，再进行边缘检测的过程，并对比了四种常见的边缘提取算法。</p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;">代码如下所示：</p> 
<pre class="has"><code class="language-python"># -*- coding: utf-8 -*-
import cv2
import numpy as np
import matplotlib.pyplot as plt

#读取图像
img = cv2.imread('zxp.jpg')
img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) #转成RGB 方便后面显示

#灰度化处理图像
grayImage = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

#高斯滤波
gaussianBlur = cv2.GaussianBlur(grayImage, (3,3), 0)

#阈值处理
ret, binary = cv2.threshold(gaussianBlur, 127, 255, cv2.THRESH_BINARY)

#Roberts算子
kernelx = np.array([[-1,0],[0,1]], dtype=int)
kernely = np.array([[0,-1],[1,0]], dtype=int)
x = cv2.filter2D(binary, cv2.CV_16S, kernelx)
y = cv2.filter2D(binary, cv2.CV_16S, kernely)
absX = cv2.convertScaleAbs(x)
absY = cv2.convertScaleAbs(y)
Roberts = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)

#Prewitt算子
kernelx = np.array([[1,1,1],[0,0,0],[-1,-1,-1]], dtype=int)
kernely = np.array([[-1,0,1],[-1,0,1],[-1,0,1]], dtype=int)
x = cv2.filter2D(binary, cv2.CV_16S, kernelx)
y = cv2.filter2D(binary, cv2.CV_16S, kernely)
absX = cv2.convertScaleAbs(x)
absY = cv2.convertScaleAbs(y)
Prewitt = cv2.addWeighted(absX,0.5,absY,0.5,0)

#Sobel算子
x = cv2.Sobel(binary, cv2.CV_16S, 1, 0)
y = cv2.Sobel(binary, cv2.CV_16S, 0, 1)
absX = cv2.convertScaleAbs(x)
absY = cv2.convertScaleAbs(y)
Sobel = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)

#Laplacian算子
dst = cv2.Laplacian(binary, cv2.CV_16S, ksize = 3)
Laplacian = cv2.convertScaleAbs(dst)

# #效果图
# titles = ['Source Image', 'Binary Image', 'Roberts Image',
#           'Prewitt Image','Sobel Image', 'Laplacian Image']
# images = [lenna_img, binary, Roberts, Prewitt, Sobel, Laplacian]
# for i in np.arange(6):
#    plt.subplot(2,3,i+1),plt.imshow(images[i],'gray')
#    plt.title(titles[i])
#    plt.xticks([]),plt.yticks([])
# plt.show()

# 用来正常显示中文标签
plt.rcParams['font.sans-serif'] = ['SimHei']

# # 显示图形
plt.subplot(231),plt.imshow(img_RGB),plt.title('原始图像'), plt.axis('off') #坐标轴关闭
plt.subplot(232),plt.imshow(binary, cmap=plt.cm.gray ),plt.title('二值图'), plt.axis('off')
plt.subplot(233),plt.imshow(Roberts, cmap=plt.cm.gray ),plt.title('Roberts算子'), plt.axis('off')
plt.subplot(234),plt.imshow(Prewitt, cmap=plt.cm.gray ),plt.title('Prewitt算子'), plt.axis('off')
plt.subplot(235),plt.imshow(Sobel, cmap=plt.cm.gray ),plt.title('Sobel算子'), plt.axis('off')
plt.subplot(236),plt.imshow(Laplacian, cmap=plt.cm.gray ),plt.title('Laplacian算子'), plt.axis('off')

plt.show()</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p style="text-indent:50px;">运行结果如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="has" height="511" src="https://images2.imgbox.com/8b/f7/gzkHRvlR_o.png" width="631"></p> 
<p style="text-indent:0;"> </p> 
<p style="text-indent:50px;">为了比较不同算子，多测试了几张图像，如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="has" height="503" src="https://images2.imgbox.com/8d/42/VX6xuuNt_o.png" width="629"></p> 
<p style="text-indent:0;"> </p> 
<p style="text-align:center;"><img alt="" class="has" height="470" src="https://images2.imgbox.com/8f/c5/wN2KtsTJ_o.png" width="628"></p> 
<p style="text-indent:0;"> </p> 
<p style="text-align:center;"><img alt="" class="has" height="503" src="https://images2.imgbox.com/d8/9e/YJsNtlkL_o.png" width="635"></p> 
<p style="text-indent:0;"> </p> 
<p style="text-indent:50px;">由上面的结果所示，不同的算子进行了比较。可知：</p> 
<p style="text-indent:50px;">1）<strong>Robert算子</strong>对陡峭的低噪声图像效果较好，尤其是边缘正负45度较多的图像，但定位准确率较差；</p> 
<p style="text-indent:50px;">2）<strong>Prewitt算子</strong>对灰度渐变的图像边缘提取效果较好，而没有考虑相邻点的距离远近对当前像素点的影响；</p> 
<p style="text-indent:50px;">3）<strong>Sobel算子</strong>考虑了综合因素，对噪声较多的图像处理效果更好。</p> 
<p style="text-indent:50px;">4）<strong>Laplacian算子</strong>对噪声比较敏感，由于其算法可能会出现双像素边界，常用来判断边缘像素位于图像的明区或暗区，很少用于边缘检测；</p> 
<p> </p> 
<h3 id="8.2%20%E5%90%84%E7%B1%BB%E7%AE%97%E5%AD%90%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">8.2 各类算子的优缺点</h3> 
<p style="text-indent:0;"><strong>（1）Roberts 算子 </strong></p> 
<p style="text-indent:50px;"><strong>Roberts算子</strong>利用局部差分算子寻找边缘，边缘定位精度较高，但容易丢失一部分边缘，不具备抑制噪声的能力。该算子对具有陡峭边缘且含噪声少的图像效果较好，尤其是边缘正负45度较多的图像，但定位准确率较差；</p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:0;"><strong>（2）Sobel 算子</strong></p> 
<p style="text-indent:50px;"><strong>Sobel算子</strong>考虑了综合因素，对噪声较多的图像处理效果更好，Sobel 算子边缘定位效果不错，但检测出的边缘容易出现多像素宽度。</p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:0;"><strong>（3） Prewitt 算子</strong></p> 
<p style="text-indent:50px;"><strong>Prewitt算子</strong>对灰度渐变的图像边缘提取效果较好，而没有考虑相邻点的距离远近对当前像素点的影响，与Sobel 算子类似，不同的是在平滑部分的权重大小有些差异；</p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:0;"><strong>（4）Laplacian 算子</strong></p> 
<p style="text-indent:50px;">Laplacian 算子不依赖于边缘方向的二阶微分算子，对图像中的阶跃型边缘点定位准确，该算子对噪声非常敏感，它使噪声成分得到加强，这两个特性使得该算子容易丢失一部分边缘的方向信息，造成一些不连续的检测边缘，同时抗噪声能力比较差，由于其算法可能会出现双像素边界，常用来判断边缘像素位于图像的明区或暗区，很少用于边缘检测；</p> 
<p> </p> 
<p> </p> 
<h2 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" style="margin-left:0cm;">参考资料</h2> 
<p style="margin-left:0cm;">[1] <span style="color:#0563c1;"><u><a href="https://blog.csdn.net/Eastmount/article/details/89001702">https://blog.csdn.net/Eastmount/article/details/89001702</a></u></span></p> 
<p style="margin-left:0cm;">[2] 杨帆. 数字图像处理与分析（第三版）. 北京航空航天大学出版社</p> 
<p style="margin-left:0cm;">[3] <a href="https://download.csdn.net/download/zaishuiyifangxym/10044192">冈萨雷斯. 数字图像处理(第三版)</a> </p> 
<p style="margin-left:0cm;"> </p> 
<hr> 
<p><strong>如果觉得内容还不错的话，欢迎点赞、转发、收藏，还可以关注微信公众号、CSDN博客、知乎。</strong><br>  </p> 
<p>1. 微信公众号:</p> 
<p style="text-align:center;"><img alt="" height="258" src="https://images2.imgbox.com/68/e0/0wefUfVV_o.jpg" width="258"></p> 
<p>2. CSDN博客：<a href="https://xiongyiming.blog.csdn.net/" rel="nofollow">https://xiongyiming.blog.csdn.net/</a></p> 
<p>3. 知乎：<a href="https://www.zhihu.com/people/xiongyiming" rel="nofollow">https://www.zhihu.com/people/xiongyiming</a></p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/62b2013d844fa67dabffd9217f5870d1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Studio中如何清理gradle缓存</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3164c9e4b82773488a74aa8fc731078d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java调用接口，就可以调用到接口实现类里面的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>