<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ARMv6 ARMv7 架构 整体介绍 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ARMv6 ARMv7 架构 整体介绍" />
<meta property="og:description" content="文章目录 市场应用领域市占率常见产品 架构编程模型运行状态指令集寄存器非特权级别(usr模式)下不建议访问的指令与寄存器ABI 异常模型特权级异常种类 内存模型VMSA&amp;MMU内存一致性cache debug模型External DebugSelf-hosted DebugTrace boot模型虚拟化模型安全模型 开发工具gcc toolchain &amp; gdbqemu常见开发环境(除qemu外) 软件开发裸机(baremetal)RTOSLinuxarm32-linux镜像arm32-linux boot 符号debugbootboot时的内存管理架构相关代码通用知识:如何新增一个架构 微架构 市场 应用领域 嵌入式 市占率 常见产品 架构 架构整体综述 编程模型 运行状态 armv6/v7 有两种执行状态，arm和thumb。 //cpsr 的 T // 0:arm // 1:thumb // 应该reset 是 arm 状态 // 异常时,cpsr 中的 T 被置位 0 , 也就是 进入arm state 指令集 ARM&amp;THUMB&amp;VFP&amp;SIMD指令集ARMv7/ARMv8/RV32/RV64指令集及寄存器对比 寄存器 R0-R7 R8-R12 R13-R15 及其BANK寄存器CPSRSPSR 及其BANK寄存器CP15寄存器 非特权级别(usr模式)下不建议访问的指令与寄存器 // 指令集 mcr/mrc cdp/ldc/stc mcrr/mrrc // 寄存器 协处理器寄存器 ABI arm abi : ATPCSARM 汇编 调用约定ABI与汇编语法 异常模型 特权级 7种处理器模式(SVC/ABT/UND/IRQ/FIQ &amp; USR/SYSTEM)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b0ac48fd08047ce2cd3636f3df013001/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-09T14:14:19+08:00" />
<meta property="article:modified_time" content="2022-08-09T14:14:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ARMv6 ARMv7 架构 整体介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_2" rel="nofollow">市场</a></li><li><ul><li><ul><li><a href="#_3" rel="nofollow">应用领域</a></li><li><a href="#_7" rel="nofollow">市占率</a></li><li><a href="#_8" rel="nofollow">常见产品</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_10" rel="nofollow">架构</a></li><li><ul><li><ul><li><a href="#_14" rel="nofollow">编程模型</a></li><li><ul><li><ul><li><a href="#_15" rel="nofollow">运行状态</a></li><li><a href="#_26" rel="nofollow">指令集</a></li><li><a href="#_30" rel="nofollow">寄存器</a></li><li><a href="#usr_37" rel="nofollow">非特权级别(usr模式)下不建议访问的指令与寄存器</a></li><li><a href="#ABI_46" rel="nofollow">ABI</a></li></ul> 
     </li></ul> 
     </li><li><a href="#_52" rel="nofollow">异常模型</a></li><li><ul><li><ul><li><a href="#_54" rel="nofollow">特权级</a></li><li><a href="#_60" rel="nofollow">异常种类</a></li></ul> 
     </li></ul> 
     </li><li><a href="#_68" rel="nofollow">内存模型</a></li><li><ul><li><ul><li><a href="#VMSAMMU_73" rel="nofollow">VMSA&amp;MMU</a></li><li><a href="#_92" rel="nofollow">内存一致性</a></li><li><a href="#cache_111" rel="nofollow">cache</a></li></ul> 
     </li></ul> 
     </li><li><a href="#debug_119" rel="nofollow">debug模型</a></li><li><ul><li><ul><li><a href="#External_Debug_125" rel="nofollow">External Debug</a></li><li><a href="#Selfhosted_Debug_132" rel="nofollow">Self-hosted Debug</a></li><li><a href="#Trace_136" rel="nofollow">Trace</a></li></ul> 
     </li></ul> 
     </li><li><a href="#boot_140" rel="nofollow">boot模型</a></li><li><a href="#_147" rel="nofollow">虚拟化模型</a></li><li><a href="#_152" rel="nofollow">安全模型</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_157" rel="nofollow">开发工具</a></li><li><ul><li><ul><li><a href="#gcc_toolchain__gdb_159" rel="nofollow">gcc toolchain &amp; gdb</a></li><li><a href="#qemu_164" rel="nofollow">qemu</a></li><li><a href="#qemu_171" rel="nofollow">常见开发环境(除qemu外)</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_178" rel="nofollow">软件开发</a></li><li><ul><li><ul><li><a href="#baremetal_180" rel="nofollow">裸机(baremetal)</a></li><li><a href="#RTOS_187" rel="nofollow">RTOS</a></li><li><a href="#Linux_188" rel="nofollow">Linux</a></li><li><ul><li><ul><li><a href="#arm32linux_189" rel="nofollow">arm32-linux镜像</a></li><li><a href="#arm32linux_boot__194" rel="nofollow">arm32-linux boot 符号</a></li><li><a href="#debug_201" rel="nofollow">debug</a></li><li><a href="#boot_203" rel="nofollow">boot</a></li><li><a href="#boot_209" rel="nofollow">boot时的内存管理</a></li><li><a href="#_211" rel="nofollow">架构相关代码</a></li><li><a href="#_218" rel="nofollow">通用知识:如何新增一个架构</a></li></ul> 
     </li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#_223" rel="nofollow">微架构</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>市场</h3> 
<h5><a id="_3"></a>应用领域</h5> 
<ul><li>嵌入式</li></ul> 
<h5><a id="_7"></a>市占率</h5> 
<h5><a id="_8"></a>常见产品</h5> 
<h3><a id="_10"></a>架构</h3> 
<ul><li><a href="https://blog.csdn.net/u011011827/category_9460000.html">架构整体综述</a></li></ul> 
<h5><a id="_14"></a>编程模型</h5> 
<h6><a id="_15"></a>运行状态</h6> 
<pre><code class="prism language-c">armv6<span class="token operator">/</span>v7 有两种执行状态，arm和thumb。
	<span class="token comment">//cpsr 的 T</span>
	<span class="token comment">// 0:arm</span>
	<span class="token comment">// 1:thumb</span>
	<span class="token comment">// 应该reset 是 arm 状态</span>
	<span class="token comment">// 异常时,cpsr 中的 T 被置位 0 , 也就是 进入arm state</span>
</code></pre> 
<h6><a id="_26"></a>指令集</h6> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/103027416">ARM&amp;THUMB&amp;VFP&amp;SIMD指令集</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/124380323">ARMv7/ARMv8/RV32/RV64指令集及寄存器对比</a></li></ul> 
<h6><a id="_30"></a>寄存器</h6> 
<ul><li>R0-R7 R8-R12 R13-R15 及其BANK寄存器</li><li>CPSR</li><li>SPSR 及其BANK寄存器</li><li><a href="https://blog.csdn.net/u011011827/article/details/106733786">CP15寄存器</a></li></ul> 
<h6><a id="usr_37"></a>非特权级别(usr模式)下不建议访问的指令与寄存器</h6> 
<pre><code class="prism language-c"><span class="token comment">// 指令集</span>
mcr<span class="token operator">/</span>mrc
cdp<span class="token operator">/</span>ldc<span class="token operator">/</span>stc
mcrr<span class="token operator">/</span>mrrc
<span class="token comment">// 寄存器</span>
协处理器寄存器
</code></pre> 
<h6><a id="ABI_46"></a>ABI</h6> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/103828670">arm abi : ATPCS</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/119531799">ARM 汇编 调用约定ABI与汇编语法</a></li></ul> 
<h5><a id="_52"></a>异常模型</h5> 
<h6><a id="_54"></a>特权级</h6> 
<ul><li> <p>7种处理器模式(SVC/ABT/UND/IRQ/FIQ &amp; USR/SYSTEM)</p> </li><li> <p>两种特权模式(usr模式非特权,其他6种模式特权)</p> </li></ul> 
<h6><a id="_60"></a>异常种类</h6> 
<ul><li> <p><a href="https://blog.csdn.net/u011011827/article/details/103110736">7种异常(reset/swi/data abort/prefetch abort/und/irq/fiq)</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/103110736">7种异常对应的5种处理器模式SVC/ABT/UND/IRQ/FIQ</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/107206106">(二) 5.1 硬件 内存访问异常</a></p> </li></ul> 
<h5><a id="_68"></a>内存模型</h5> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/106732702">内存模型总览</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/103213717">总览2</a></li></ul> 
<h6><a id="VMSAMMU_73"></a>VMSA&amp;MMU</h6> 
<ul><li> <p><a href="https://blog.csdn.net/u011011827/article/details/105778371">(一) 内存管理发展历史及进程地址空间抽象</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/106490625">(二) 2.1硬件 MMU及其运行过程 总览</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/106521823">(二) 2.2 硬件 MMU及其运行过程 关键过程一 TLB</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/106521835">(二) 2.3 硬件 MMU及其运行过程 关键过程二 translation table walk</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/106521840">(二) 2.4 硬件 MMU及其运行过程 关键过程三 cache</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/106521845">(二) 2.5 硬件 MMU及其运行过程 关键过程四 DDR</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/122636894">arm-linux 内存管理之一级页表及二级页表</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/107206106">MMU运行过程中可能产生的异常</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/106530439">(二) 2.6 硬件 MMU的操作手册</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/106732492">(二) 3.1 硬件 CP15系统控制协处理器的操作手册</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/106733786">(二) 3.2 硬件 CP15系统控制协处理器的寄存器描述</a></p> </li></ul> 
<h6><a id="_92"></a>内存一致性</h6> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/121874380">内存一致性:A.缓存一致性 B.原子性 C.memory order(一致性模型)</a></li></ul> 
<hr> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/125400152">缓存一致性</a></li></ul> 
<hr> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/117818411">原子性</a></li></ul> 
<hr> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/124563277">memory order : 乱序和屏障1 : 总览 及 编译器内存屏障</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/124590543">memory order : 乱序和屏障2 : UP单核需要处理的CPU乱序问题</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/106734055">memory order : (二) 4.2 硬件 SMP-Consistency之内存顺序模型1</a></li></ul> 
<h6><a id="cache_111"></a>cache</h6> 
<ul><li> <p><a href="https://zhuanlan.zhihu.com/p/136300660" rel="nofollow">高速缓存与一致性专栏索引</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/107206206">(二) 6.1 硬件 CACHE/WRITE BUFFER/TCM</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/124634035">cache 概念详解 &amp; PoC &amp; PoU &amp; inner/outer cache</a></p> </li></ul> 
<h5><a id="debug_119"></a>debug模型</h5> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/103679763">debug总述</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/118610638">arm debug实现:coregisht</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/121273734">coresight 组件</a></li></ul> 
<h6><a id="External_Debug_125"></a>External Debug</h6> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/99617995">通用知识 : JTAG的状态机&amp;JTAG的TAP</a></li><li>通用知识 : JTAG状态机 的封装 : IR SCAN &amp; DR SCAN</li><li><a href="https://blog.csdn.net/u011011827/article/details/121192528">基于JTAG的 芯片DEBUG 文章整理</a></li></ul> 
<h6><a id="Selfhosted_Debug_132"></a>Self-hosted Debug</h6> 
<ul><li>BKPT指令及其异常处理</li></ul> 
<h6><a id="Trace_136"></a>Trace</h6> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/121273734">ARM coresight 中的 trace数据输出源(DWT/ITM/ETM) &amp; trace 数据interface TPIU(SWO/CLK_DATA)</a></li></ul> 
<h5><a id="boot_140"></a>boot模型</h5> 
<ul><li> <p><a href="https://blog.csdn.net/u011011827/article/details/123843826">ARMv7 boot</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/77773095">嵌入式启动顺序 - uboot之前</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/61927749">嵌入式启动顺序 - uboot</a></p> </li></ul> 
<h5><a id="_147"></a>虚拟化模型</h5> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/123801488">ARMv7 Virtualization硬件实现</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/120431923">armv7 虚拟化软件:KVM</a></li></ul> 
<h5><a id="_152"></a>安全模型</h5> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/119562961">通用知识: 安全硬件实现及软件实现</a></li></ul> 
<h3><a id="_157"></a>开发工具</h3> 
<h5><a id="gcc_toolchain__gdb_159"></a>gcc toolchain &amp; gdb</h5> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/53932622">交叉编译工具链的获取</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/124410351">我们能从一个ARM32编译器获取什么信息</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/121031973">GDB 常用命令</a></li></ul> 
<h5><a id="qemu_164"></a>qemu</h5> 
<ul><li> <p><a href="https://qemu.readthedocs.io/en/latest/system/target-arm.html" rel="nofollow">qemu中的 Arm System emulator</a></p> </li><li> <p><a href="https://qemu.readthedocs.io/en/latest/system/arm/virt.html" rel="nofollow">qemu-system-arm中的virt开发板</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/125056082">编译qemu</a></p> </li></ul> 
<h5><a id="qemu_171"></a>常见开发环境(除qemu外)</h5> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/53925833">开发环境</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/53927414">内核和文件系统的烧写和启动配置</a></li></ul> 
<h3><a id="_178"></a>软件开发</h3> 
<h5><a id="baremetal_180"></a>裸机(baremetal)</h5> 
<ul><li><a href="https://github.com/umanovskis/baremetal-arm">qemu armv7 裸机开发</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/124268922">ARMv7/ARMv8/RV32/RV64裸机编程中的区别</a></li><li><a href="https://gitee.com/suweishuai/baremetal" rel="nofollow">兼容ARMv7/ARMv8/RV32/RV64的一个裸机qemu工程</a></li></ul> 
<h5><a id="RTOS_187"></a>RTOS</h5> 
<h5><a id="Linux_188"></a>Linux</h5> 
<h6><a id="arm32linux_189"></a>arm32-linux镜像</h6> 
<ul><li>各个镜像<a href="https://blog.csdn.net/u011011827/article/details/71057018">解读1</a>&amp;<a href="https://blog.csdn.net/u011011827/article/details/115395426">解读2</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/115766762">各个镜像执行结果</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/82995261">uImage镜像或zImage被加载</a></li><li>一般不会直接加载 Image,如果想要直接加载Image,参考<a href="https://blog.csdn.net/u011011827/article/details/125012120">这里</a></li></ul> 
<h6><a id="arm32linux_boot__194"></a>arm32-linux boot 符号</h6> 
<ul><li> <p><a href="https://blog.csdn.net/u011011827/article/details/71056889">uImage的入口符号</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/107863316">zImage的符号</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/107863316">Image中的符号</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/125071317">arm32-linux boot 符号总览</a></p> </li></ul> 
<h6><a id="debug_201"></a>debug</h6> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/125012120">gdb调试qemu virt板 arm32 linux 各个过程</a></li></ul> 
<h6><a id="boot_203"></a>boot</h6> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/82995261">uboot引导内核 Load Address Entry Point</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/71056889">uImage 的 入口符号地址</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/710570180">内核镜像解析</a></li><li><a href="https://blog.csdn.net/u011011827/article/details/83030119">内核启动流程</a></li></ul> 
<h6><a id="boot_209"></a>boot时的内存管理</h6> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/125323805">RISC 架构 linux boot 临时页表 对比 ARM32 ARM64 RV32 RV64</a></li></ul> 
<h6><a id="_211"></a>架构相关代码</h6> 
<ul><li> <p><a href="https://blog.csdn.net/u011011827/article/details/122654174">arch/arm中的目录</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/122557613">linux arch 提供的函数与宏</a></p> </li><li> <p><a href="https://blog.csdn.net/u011011827/article/details/122579366">arch/arm中的页表 相关函数</a></p> </li></ul> 
<h6><a id="_218"></a>通用知识:如何新增一个架构</h6> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/123312955">linux移植需要考虑什么</a></li><li><a href="https://gitee.com/tinylab/riscv-linux/blob/master/articles/20220315-porting-linux-to-a-new-processor-architecture-part-1-the-basics.md" rel="nofollow">将 Linux 移植到新的处理器架构，第 1 部分：基础前言</a></li><li><a href="https://gitee.com/tinylab/riscv-linux/blob/master/articles/20220315-porting-linux-to-a-new-processor-architecture-part-2-the-early-code.md" rel="nofollow">将 Linux 移植到新的处理器架构，第 2 部分：早期代码</a></li><li><a href="https://gitee.com/tinylab/riscv-linux/blob/master/articles/20220406-porting-linux-to-a-new-processor-architecture-part-3-to-the-finish-line.md" rel="nofollow">将 Linux 移植到新的处理器架构，第 3 部分：收尾</a></li></ul> 
<h3><a id="_223"></a>微架构</h3> 
<ul><li><a href="https://blog.csdn.net/u011011827/article/details/121937153">通用知识:cpu微架构解读</a></li><li>arm32 下的 cortex-a7/cortex-a8/cortex-a9/cortex-a15/cortex-a17</li><li><a href="https://blog.csdn.net/u011011827/article/details/118156597">ARMv6架构下 各微架构的不同</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/391c052ea1e99aba9a87afee20f07af2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【vue】报错：Error: [ElTable] prop row-key is required</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/893983cbd0e6e8a2a79ce2fa3f8d451f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ubuntu18.04&#43;RTX3090安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>