<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【ocr 文字检测】DocSegTr: An Instance-Level End-to-End Document Image Segmentation Transformer - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【ocr 文字检测】DocSegTr: An Instance-Level End-to-End Document Image Segmentation Transformer" />
<meta property="og:description" content="论文链接：https://arxiv.org/pdf/2201.11438.pdf
代码：https://github.com/biswassanket/DocSegTr
出处：西班牙巴塞罗那自治大学
目的：理解复杂布局的文档首先就需要进行信息提取。本文目的就是通过实例级别分割获得不同的文章目标（different document objects），如：标题，章节，图片，表格等；（效果图1），文中提出一个 Document Image Segmentation Transformer（DocSegTr），第一次用于复杂布局文本的实例级分割；
关键词：文档布局分析，实例级别分割，transformer，信息抽取
贡献有三点：
提出了文档图像分割Transformer（Document image Segmentation Transformer，DocSegTr），该方法是一个端对端的实例级别的分割方法，可以有效的分析和分割布局复杂的文档。且该方法是第一个bottom-up实例级别文档分割方法，有效的结合了CNN和transformer方法，且没有使用box做目标检测；DocSegTr中将self-attention用twin attention替代，与Maskrcnn相比提升了计算效率，节省了内存空间；DocSegTr在文档数据集PubLayNet 数据上获得了89.4%AP； 2.Related Work 对于文档的信息提取需要对本页中不同布局组件之间进行空间理解和关系推理，例如：表格，文本块（段落），图，标题等等。从基于规则启发性的文档布局分割到最近的基于深度学习的文档目标检测（DOD， Document Object Detection）大量的工作是为了解决页内的目标定位。本章节，作者回顾了很多不同的方法；
2.1 基于规则启发式的文档布局分析 基于规则启发式的文档布局分割主要有三种模式：top-down，bottom-up 和hybird方法，bottom-up方法【2，31，34】使用像素作为基本组件，通过类似分组和合并的方式形成大的同种类的区域；top-down方法【20，23，29】是将整个文档划分为不同的区域，直到最终定义出标准的列或模块。bottom-up方法更加灵巧，适用于不同布局的文档，但是计算复杂；top-down 计算效率高，但是却只能处理特定版面的文档，例如基于曼哈顿布局的文档；因此，hybird方法【38，40】混合以上二者的优点，产生更好的结果；在深度学习时代以前，基于规则的分割技巧【7，10，37】对于表格检测也是影响深远；
2.2 文档目标检测 基于深度学习的发展，CNN成为了文档布局分割的主要方法。主要是通过Faster-RCNN【32】，Mask-RCNN【14】和Retinanet【26】这类自然场景检测方法对文档布局进行分割。DeepDeSRT【36】是第一个最为流行的用于处理文档中（如：扫描图和数据图片）表格检测和结构识别的目标检测方法；该方法是在将文档输入Faster-RCNN模型之前，对文档应用了一种新的图像变换策略；之后，FCNNs【13】用于在页面上检测大量的目标内容（表格和图）。Oliviera等人【30】使用了一个基于FCNN的相似框架在历史文献上进行逐个像素级别的分割。Saha等人【35】基于transfer learning的Faster-RCNN主干在数据集ICDAR POD（page object Detection）2017【11】上检测表格，图和数学公式获得了很好的结果。最近一个新的跨区域的文档目标检测（DOD）基准在【24】中建立，该基准使用了区域自适应策略，用于DOD中解决区域变换问题；
2.3 Transformers用于文档分析系统 自然语言模型获得更好的结果是因为self-attention和positional embedding机制，在Vaswani等人【41】提出了最原始的transformers。之后，BERT【9】语言模型用于多模态最新的视觉文档理解任务（VDU），比如扫描菜单和发票中的实体识别（entity recognition）和键值对（key-value pair）信息提取。LayoutLM【46】就联合学习文档图片的文档，布局和视觉特征，BERT模型作为基线（BERT-like model baseline），在VDU任务中获得了最佳效果；最近在VDU中的研究【1，22，25】使用了transformers，使用了在文档，布局和图像区域的预训练用于解决VDU任务，如表格理解【19】，菜谱理解【18】，和文档视觉QA（question， answering）【28】。
受transformers在文档理解和文档分析突破的影响，作者首先提出了端对端的文档图像分割transformer，在实例级别分割上获得了很好的效果【47】。作者也将本文的结果和之前的研究结果【4】进行了比较；
3 方法 为了完成实例级别的文档布局分割，一个混合CNN基于transformer（DocSegTr）被提出来，用于识别出不同布局的元素（段落，表，图，标题等）和它们之间的长期依赖。DocSegTr是一个端对端的分割算法，它将特征图分割成patches，然后在patches上预测文章内容，DocSegTr有三部分组成：1）一个有特征金字塔（FPN）的CNN主干用于提取输入文档图片的突出的，特定的低维和近邻元素；2）一个transformer用于广泛和语义推理，transformer兼并了functional heads用于预测语义的类别，和卷积kernel中的kernel head（这个操作是为了展开多尺度特征增加位置信息（positional embedding））；3）一个Layerwise Feature Aggregation module（分层特征聚合模块）通过在特征图和相关的卷积核之间通过动态卷积活动创作最后的一层操作（the last division cover）；产生的结构如图1
3.1 文档分割Transformer（DocSegTr） DocSegTr包含三个模块：self-attention机制：处理长期依赖；transformer层和一个Functional head用于实例级分割中的mask预测；
Attention机制：self-attention模块在Transformer中是很重要的一个部分，用于学习全局特征（catches full-document setting）和学习文档不同特征信息之间的关系。但是在【41】中提出的最原始的self-attention计算和存储都相当复杂，耗费时间。为了解决这个问题，作者使用【12】中的孪生注意力（twin-attention）分解了原始的注意力矩阵，twin-attention就是传统注意力的稀疏表示。twin-attention首先单独计算每一列的结果。这样有助于减少水平尺度的语境推理。然后通过计算每一行的相似注意力在竖着的尺度进行相似的操作；最终结果就是行和列注意力（分别为垂直尺度和水平尺度）有序连接形成全局注意力模块，沿着两个不同的维度（全局和局部）覆盖了所有重要的特征信息；
在实例级别分割任务中，假设FPN的每一层的特征图谱为，DocSegTr首先将特征图谱划分为个块（patches）,然后通过垂直方向和水平防线将这些patches堆叠为固定的组件（components）。然后将位置信息（position embedding）嵌入到components中保留位置信息，这些行列的位置信息（position embeding）用于自注意力机制当中；为了确保这两个模块（行和列的注意力矩阵）和多头注意力一起工作，作者使用了跨多层连接（防止梯度消失），在twin-attention中所有的子层中会产生相同的的输出。这个方法可以减少内存消耗，减少计算复杂度；原始的self-attention的内存和计算复杂度从降到;
Transformer Layer:本章节中，作者展示了三个特定的transformer层回顾基础结构（如图1）中的encoder。1）第一个transformer和【41】中的一样，包含两个组件：层归一化后【3】一个多头注意力单元和层归一化后的多层感知机（MLP）。此外，使用残差连接【15】两个模块。最终transformer层K个序列关联的结果就是多维特征序列，确保了下面functional heads能够做出预测；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f3793cd881d8a49e35e57e046a633275/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-25T11:50:54+08:00" />
<meta property="article:modified_time" content="2022-02-25T11:50:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【ocr 文字检测】DocSegTr: An Instance-Level End-to-End Document Image Segmentation Transformer</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>论文链接</strong>：https://arxiv.org/pdf/2201.11438.pdf</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>代码</strong>：https://github.com/biswassanket/DocSegTr</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>出处</strong>：西班牙巴塞罗那自治大学</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>目的</strong>：理解复杂布局的文档首先就需要进行信息提取。本文目的就是通过实例级别分割获得不同的文章目标（different document objects），如：标题，章节，图片，表格等；（效果图1），文中提出一个 Document Image Segmentation Transformer（DocSegTr），第一次用于复杂布局文本的实例级分割；</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/af/ef/gDIpFrBw_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;">关键词：文档布局分析，实例级别分割，transformer，信息抽取</p> 
<p style="margin-left:.0001pt;text-align:justify;">贡献有三点：</p> 
<ol><li style="text-align:justify;">提出了文档图像分割Transformer（Document image Segmentation Transformer，DocSegTr），该方法是一个端对端的实例级别的分割方法，可以有效的分析和分割布局复杂的文档。且该方法是第一个bottom-up实例级别文档分割方法，有效的结合了CNN和transformer方法，且没有使用box做目标检测；</li><li style="text-align:justify;">DocSegTr中将self-attention用twin attention替代，与Maskrcnn相比提升了计算效率，节省了内存空间；</li><li style="text-align:justify;">DocSegTr在文档数据集PubLayNet 数据上获得了89.4%AP；</li></ol> 
<p></p> 
<h2>2.Related Work</h2> 
<p>对于文档的信息提取需要对本页中不同布局组件之间进行空间理解和关系推理，例如：表格，文本块（段落），图，标题等等。从基于规则启发性的文档布局分割到最近的基于深度学习的文档目标检测（DOD， Document Object Detection）大量的工作是为了解决页内的目标定位。本章节，作者回顾了很多不同的方法；</p> 
<h3>2.1 基于规则启发式的文档布局分析</h3> 
<p>基于规则启发式的文档布局分割主要有三种模式：top-down，bottom-up 和hybird方法，bottom-up方法【2，31，34】使用像素作为基本组件，通过类似分组和合并的方式形成大的同种类的区域；top-down方法【20，23，29】是将整个文档划分为不同的区域，直到最终定义出标准的列或模块。bottom-up方法更加灵巧，适用于不同布局的文档，但是计算复杂；top-down 计算效率高，但是却只能处理特定版面的文档，例如基于曼哈顿布局的文档；因此，hybird方法【38，40】混合以上二者的优点，产生更好的结果；在深度学习时代以前，基于规则的分割技巧【7，10，37】对于表格检测也是影响深远；</p> 
<p></p> 
<h3>2.2 文档目标检测</h3> 
<p>基于深度学习的发展，CNN成为了文档布局分割的主要方法。主要是通过Faster-RCNN【32】，Mask-RCNN【14】和Retinanet【26】这类自然场景检测方法对文档布局进行分割。DeepDeSRT【36】是第一个最为流行的用于处理文档中（如：扫描图和数据图片）表格检测和结构识别的目标检测方法；该方法是在将文档输入Faster-RCNN模型之前，对文档应用了一种新的图像变换策略；之后，FCNNs【13】用于在页面上检测大量的目标内容（表格和图）。Oliviera等人【30】使用了一个基于FCNN的相似框架在历史文献上进行逐个像素级别的分割。Saha等人【35】基于transfer learning的Faster-RCNN主干在数据集ICDAR POD（page object Detection）2017【11】上检测表格，图和数学公式获得了很好的结果。最近一个新的跨区域的文档目标检测（DOD）基准在【24】中建立，该基准使用了区域自适应策略，用于DOD中解决区域变换问题；</p> 
<p></p> 
<h3>2.3 Transformers用于文档分析系统</h3> 
<p>自然语言模型获得更好的结果是因为self-attention和positional embedding机制，在Vaswani等人【41】提出了最原始的transformers。之后，BERT【9】语言模型用于多模态最新的视觉文档理解任务（VDU），比如扫描菜单和发票中的实体识别（entity recognition）和键值对（key-value pair）信息提取。LayoutLM【46】就联合学习文档图片的文档，布局和视觉特征，BERT模型作为基线（BERT-like model baseline），在VDU任务中获得了最佳效果；最近在VDU中的研究【1，22，25】使用了transformers，使用了在文档，布局和图像区域的预训练用于解决VDU任务，如表格理解【19】，菜谱理解【18】，和文档视觉QA（question， answering）【28】。</p> 
<p>受transformers在文档理解和文档分析突破的影响，作者首先提出了端对端的文档图像分割transformer，在实例级别分割上获得了很好的效果【47】。作者也将本文的结果和之前的研究结果【4】进行了比较；</p> 
<p></p> 
<h2>3 方法</h2> 
<p>为了完成实例级别的文档布局分割，一个混合CNN基于transformer（DocSegTr）被提出来，用于识别出不同布局的元素（段落，表，图，标题等）和它们之间的长期依赖。DocSegTr是一个端对端的分割算法，它将特征图分割成patches，然后在patches上预测文章内容，DocSegTr有三部分组成：1）一个有特征金字塔（FPN）的CNN主干用于提取输入文档图片的突出的，特定的低维和近邻元素；2）一个transformer用于广泛和语义推理，transformer兼并了functional heads用于预测语义的类别，和卷积kernel中的kernel head（这个操作是为了展开多尺度特征增加位置信息（positional embedding））；3）一个Layerwise Feature Aggregation module（分层特征聚合模块）通过在特征图和相关的卷积核之间通过动态卷积活动创作最后的一层操作（the last division cover）；产生的结构如图1</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/92/da/KMY3TtuS_o.png"></p> 
<h3> 3.1 文档分割Transformer（DocSegTr）</h3> 
<p>DocSegTr包含三个模块：self-attention机制：处理长期依赖；transformer层和一个Functional head用于实例级分割中的mask预测；</p> 
<p><strong>Attention机制</strong>：self-attention模块在Transformer中是很重要的一个部分，用于学习全局特征（catches full-document setting）和学习文档不同特征信息之间的关系。但是在【41】中提出的最原始的self-attention计算和存储都相当复杂，耗费时间。为了解决这个问题，作者使用【12】中的孪生注意力（twin-attention）分解了原始的注意力矩阵，twin-attention就是传统注意力的稀疏表示。twin-attention首先单独计算每一列的结果。这样有助于减少水平尺度的语境推理。然后通过计算每一行的相似注意力在竖着的尺度进行相似的操作；最终结果就是行和列注意力（分别为垂直尺度和水平尺度）有序连接形成全局注意力模块，沿着两个不同的维度（全局和局部）覆盖了所有重要的特征信息；</p> 
<p>在实例级别分割任务中，假设FPN的每一层<img alt="i" class="mathcode" src="https://images2.imgbox.com/8b/3a/IvLIPJUH_o.png">的特征图谱为<img alt="f_{i}=R^{h\times w\times c}" class="mathcode" src="https://images2.imgbox.com/d2/0b/nyk1V1ez_o.png">，DocSegTr首先将特征图谱划分为<img alt="n\times n" class="mathcode" src="https://images2.imgbox.com/14/ab/0pb4gwwK_o.png">个块（patches）<img alt="p_{i}\in R^{n\times n\times c}" class="mathcode" src="https://images2.imgbox.com/2d/83/HCcFcIvm_o.png">,然后通过垂直方向和水平防线将这些patches堆叠为固定的组件（components）。然后将位置信息（position embedding）嵌入到components中保留位置信息，这些行列的位置信息（position embeding）用于自注意力机制当中；为了确保这两个模块（行和列的注意力矩阵）和多头注意力一起工作，作者使用了跨多层连接（防止梯度消失），在twin-attention中所有的子层中会产生相同的<img alt="n\times n\times c" class="mathcode" src="https://images2.imgbox.com/a2/11/dTSGkr60_o.png">的输出。这个方法可以减少内存消耗，减少计算复杂度；原始的self-attention的内存和计算复杂度从<img alt="O(h \times w)^{2}" class="mathcode" src="https://images2.imgbox.com/57/d1/3ev8IWh8_o.png">降到<img alt="O(h\times w^{2}+w\times h^{2})" class="mathcode" src="https://images2.imgbox.com/1d/fd/nS1QmODj_o.png">;</p> 
<p><strong>Transformer Layer</strong>:本章节中，作者展示了三个特定的transformer层回顾基础结构（如图1）中的encoder。1）第一个transformer和【41】中的一样，包含两个组件：层归一化后【3】一个多头注意力单元和层归一化后的多层感知机（MLP）。此外，使用残差连接【15】两个模块。最终transformer层K个序列关联的结果就是多维特征序列，确保了下面functional heads能够做出预测；</p> 
<p>在DocSegTr中，原始的transformer层【41】得到使用，同时多头注意力被替换为twin attention，twin attention不仅仅帮助建模了全局特征依赖（在两个不同的尺度），同时twin attention稀疏性也减少了计算量；</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9c/d5/hljQKCJ9_o.png"></p> 
<p>注：图片来自于【12】《SOTR: Segmenting Objects with Transformers》 </p> 
<p><strong>Functional Heads</strong>：从transformer中获得的结果序列送入到两个functional head。category head包括多层感知机（MLP）分类层去产生<img alt="n\times n\times q_{c}" class="mathcode" src="https://images2.imgbox.com/c2/cc/Ys4XAKsv_o.png">个结果；<img alt="q_{c}" class="mathcode" src="https://images2.imgbox.com/bc/95/g9OfMh6f_o.png">是类别数量。它就是产生的文档实例分类结果（如：标题，图，段落）。</p> 
<p>kernel head也是由一个线性层组成，产生<img alt="n\times n\times b" class="mathcode" src="https://images2.imgbox.com/dd/de/mmmBpSSv_o.png">个张量，<img alt="n\times n" class="mathcode" src="https://images2.imgbox.com/4b/2b/9aps9hv0_o.png">代表卷积核，b代表的是参数量。这里的结果最终用于预测mask，使用focal loss【26】作为文本实例预测loss；</p> 
<p style="margin-left:.0001pt;text-align:justify;">注：focal loss这个损失函数是在标准交叉熵损失基础上修改得到的，它可以通过减少易分类样本的权重，使得模型在训练时更专注于难分类的样本。</p> 
<h3>3.2 使用掩膜特征产生实例级别的分割</h3> 
<p>本章节中介绍DocSegTr中使用的分割策略。首先体现了全局特征和局部特征在实例分割中优势。然后分析了输入文档布局是怎样产生的掩膜预测结果。</p> 
<p><strong>Mask Feature Generation</strong>：为了产生文档实例级别的掩膜特征，最直接的方法就是在特征图上进行不同尺寸的预测【8，21】。然而，时间成本和存储成本都比较复杂。为了克服这个问题，作者提出了分层特征聚合模块（a Layerwise Feature Aggregator Module,LFAM）结合每一个FPN的多尺度特征和transformer特征输出结合后的mask 特征；拥有位置信息的低精度特征和transformer特征在P5进行融合，然后依次产生P4-P2的特征，最终将分层特征多尺度的全局特征和局部特征进行编码，将P2-P5结果最终concat连接，并使用Pointwise conv（增加通道数）和upsample操作生成最终的mask预测结果为h*w;</p> 
<p><strong>Instance Mask Prediction</strong>:对于文档最终的mask预测，DocSegTr中通过对特征图进行动态卷积操作后每一个patch会产生mask，受【43】启发做动态预测策略。预测卷积核的kernel head中的大小<img alt="k\in R^{n\times n\times b}" class="mathcode" src="https://images2.imgbox.com/11/6a/PIvefY26_o.png">，每一个kernel负责相关patch产生mask。细节操作如下式：</p> 
<p style="text-align:center;"><img alt="M^{_{f}^{h\times w\times n\times n}}=f^{h\times w\times c}\ast k^{n\times n\times b}" class="mathcode" src="https://images2.imgbox.com/0d/aa/Z0AkBJaU_o.png"></p> 
<p>*代表卷积操作，<img alt="M_{f}" class="mathcode" src="https://images2.imgbox.com/8a/58/N0gwOML4_o.png">代表最终产生的Mask，大小为<img alt="h\times w\times n\times n" class="mathcode" src="https://images2.imgbox.com/34/a1/TRp6scBr_o.png">,b值的大小有kernel大小决定，最终的mask结果由Matrix NMS【16】产生，使用Dice Loss【42】；</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f2/5a/dFzfAsNX_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;">注：图片来自【16】</p> 
<p style="margin-left:.0001pt;text-align:justify;">《<a href="http://arxiv.org/abs/2003.12729" rel="nofollow" title="NMS by Representative Region: Towards Crowded Pedestrian Detection by Proposal Pairing">NMS by Representative Region: Towards Crowded Pedestrian Detection by Proposal Pairing</a>》</p> 
<p style="margin-left:.0001pt;text-align:justify;">图1. R2NMS的示意图。左图显示了在NMS之前检测到的两个结果。红色的BBox是全身预测，绿色的BBox是可见部分的预测。右侧的两个小图像显示了最终结果，该结果由原始NMS和R2NMS处理。红色实心BBox表示保留的BBox，而红色虚线BBox表示已减少的真实正BBox。箭头表示IoU计算。他们的全身预测的IoU为0.63，而可见部分身体的IoU只有0.18。因此，原始NMS将减少红色虚线的BBox，但R2NMS可以保留它。</p> 
<p> </p> 
<p><strong>作者方法总结</strong>：</p> 
<p>1）不再依赖box，参考文献solov2，产生动态实例掩码(dynamic instance mask);</p> 
<p>2）利用强大的transformer，transformer的self-attention通过聚合位置和特征信息能够处理长期语义依赖；</p> 
<p>3）解决重叠问题，使用R^2NMS；</p> 
<p>4）CNN相较于其他方法可以很好的提取局部特征和地为特征，所以网络结构中加入CNN backbone；</p> 
<p>5）考虑到self-attention的计算复杂度和存储开销问题，twin-attention；</p> 
<p></p> 
<p>[1]DocFormer: End-to-End Transformer for Document Understanding<br> [2]Simplifying the reading of historical manuscripts<br> [4]Beyond document object detection: instance-level segmentation of complex layouts  ---没有找到<br> [6]End-to-End Object Detection with Transformers</p> 
<p>[9]BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding<br> https://blog.csdn.net/czp_374/article/details/86712962</p> 
<p>[12] SOTR: Segmenting Objects with Transformers<br> https://blog.csdn.net/m0_61899108/article/details/121598645</p> 
<p>[16]NMS by Representative Region: Towards Crowded Pedestrian Detection by Proposal Pairing<br> https://blog.csdn.net/JYdhqx_8012162596/article/details/114652082</p> 
<p>[20]Text/Graphic labelling of Ancient Printed Documents</p> 
<p>[24]Cross-Domain Document Object Detection: Benchmark Suite and Method<br> https://zhuanlan.zhihu.com/p/255244168</p> 
<p>[26]Focal loss for dense object detection<br> https://zhuanlan.zhihu.com/p/49981234</p> 
<p>[38]Hybrid page layout analysis via tab-stop detection</p> 
<p>[41]Attention is all you need<br> https://zhuanlan.zhihu.com/p/48508221<br> http://jalammar.github.io/illustrated-transformer/<br> https://blog.csdn.net/yujianmin1990/article/details/85221271<br> transform的详细说明：http://jalammar.github.io/illustrated-transformer/</p> 
<p>[42]An Improved Dice Loss for Pneumothorax Segmentation by Mining the Information of Negative Areas <br> https://zhuanlan.zhihu.com/p/269592183</p> 
<p>[43]SOLOv2: Dynamic, Faster and Stronger<br> https://www.zhihu.com/search?type=content&amp;q=solov2%EF%BC%9Adynamic%20and%20fast%20instance%20Segmentation</p> 
<p>[46]Pre-training of Text and Layout for Document Image Understanding<br> https://zhuanlan.zhihu.com/p/384608929<br> [47] PubLayNet: Largest Dataset Ever for Document Layout Analysis</p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/814787c5d0b648dc2933d3dcea62631f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java基础-双指针算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7381d3c843ed77bfd8242e559fa1d9da/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C/C&#43;&#43;学习记录：智能指针 std::unique_ptr 源码分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>