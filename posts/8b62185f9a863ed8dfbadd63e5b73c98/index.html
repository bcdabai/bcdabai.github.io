<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HTTP响应状态码大全：从100到511，全面解析HTTP请求的各种情况 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HTTP响应状态码大全：从100到511，全面解析HTTP请求的各种情况" />
<meta property="og:description" content="文章目录 前言发现宝藏一、认识响应状态码1. 什么是HTTP响应状态码2. Http响应状态码的作用3. 优化和调试HTTP请求的建议 二、1xx 信息响应1. 认识http信息响应2. 常见的信息响应状态码 三、2xx 成功响应1. 认识HTTP成功响应2. 常见的成功响应状态码 四、3xx 重定向1. 认识http重定向2. 常见的重定向状态码 五、4xx 客户端响应1. 认识http客户端响应2. 常见的客户端响应状态码 六、5xx 服务端响应1. 认识HTTP服务端响应2. 常见的服务端响应状态码 总结 前言 为了巩固所学的知识，作者尝试着开始发布一些学习笔记类的博客，方便日后回顾。当然，如果能帮到一些萌新进行新技术的学习那也是极好的。作者菜菜一枚，文章中如果有记录错误，欢迎读者朋友们批评指正。
（博客的参考源码可以在我主页的资源里找到，如果在学习的过程中有什么疑问欢迎大家在评论区向我提出）
发现宝藏 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【宝藏入口】。
一、认识响应状态码 1. 什么是HTTP响应状态码 HTTP状态码是由服务器在响应客户端请求时返回的三位数字代码。它们用于表示HTTP请求的处理状态和结果。每个状态码都具有特定的含义，用于向客户端传达有关请求处理情况的信息。 2. Http响应状态码的作用 提供请求处理结果信息：HTTP状态码告知客户端请求的处理情况，包括成功、重定向、客户端错误和服务器错误等。通过状态码，客户端可以了解请求是否成功处理，以及如何进一步处理响应数据。
识别请求错误原因：状态码可以帮助客户端定位请求出错的原因。例如，当客户端发送了无效的请求或请求的资源不存在时，服务器会返回相应的错误状态码，使客户端能够了解到具体的错误原因，从而采取适当的措施。
支持协议扩展和升级：HTTP状态码的范围留有一定的空间，以支持未来的协议扩展和升级。通过定义新的状态码，可以为新的协议功能或处理情况提供准确的表示。
用于调试和故障排除：状态码在调试和故障排除过程中起到重要的作用。通过查看状态码，开发人员可以追踪请求处理的过程并确定出现问题的具体环节，以便进行修复和改进。
帮助构建良好的用户体验：正确使用状态码有助于提供良好的用户体验。例如，合理使用重定向状态码可以引导用户到正确的页面，而准确的错误状态码可以向用户提供友好的错误提示，提高用户满意度。
3. 优化和调试HTTP请求的建议 使用适当的HTTP方法：选择正确的HTTP方法来匹配请求的目的。常见的方法包括GET、POST、PUT、DELETE等。确保使用最适合的方法来执行特定的操作，以提高效率和安全性。
减少请求次数：减少不必要的请求次数可以显著提高性能。考虑使用请求合并、缓存、批量操作等技术来减少请求的数量，尽量减少服务器和网络的负载。
最小化请求大小：减少请求的大小可以降低网络传输成本和请求处理时间。优化请求的体积，例如通过压缩、减少冗余数据、合并请求等方式来减小请求的大小。
使用HTTP缓存：利用HTTP缓存可以减少对服务器的请求。合理设置缓存头，包括Cache-Control、Expires等，以及验证缓存是否仍然有效的机制，如ETag和Last-Modified。
压缩响应数据：使用压缩算法（如Gzip）对响应数据进行压缩，以减小响应的大小。客户端可以通过设置Accept-Encoding头来指示对压缩响应的支持，服务器则可以通过设置Content-Encoding头来指示响应数据的压缩方式。
使用合适的数据格式：选择适合数据交换的格式，如JSON、XML等。根据需求和场景选择合适的数据格式，以提高数据传输的效率和易用性。
监控和日志记录：使用适当的工具和技术来监控和记录HTTP请求和响应的信息。通过记录日志和分析监控数据，可以帮助发现潜在的性能问题和错误，以及进行调试和优化。
使用合适的工具和库：使用优秀的HTTP请求库或框架，如cURL、HttpClient等，可以简化开发过程并提供更高效的请求处理和调试功能。
进行性能测试：对HTTP请求进行性能测试，可以评估系统的性能并找出瓶颈。使用工具如Apache JMeter、LoadRunner等进行负载测试和压力测试，以确定性能瓶颈并进行优化。
仔细分析错误信息：对于出现的错误，仔细分析错误信息和状态码，以了解问题的根本原因。结合日志和其他调试工具，追踪请求的处理过程，找出错误所在并采取相应的修复措施。
二、1xx 信息响应 1. 认识http信息响应 HTTP信息响应是指当客户端向服务器发送HTTP请求后，服务器返回给客户端的响应消息
2. 常见的信息响应状态码 100 Continue 这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它 101 Switching Protocol 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议 102 Processing（WebDAV） 此代码表示服务器已收到并正在处理该请求，但没有响应可用 103 Early Hints 此状态代码主要用于与 Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源 三、2xx 成功响应 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8b62185f9a863ed8dfbadd63e5b73c98/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-08T10:17:29+08:00" />
<meta property="article:modified_time" content="2023-12-08T10:17:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HTTP响应状态码大全：从100到511，全面解析HTTP请求的各种情况</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">前言</a></li><li><a href="#_9" rel="nofollow">发现宝藏</a></li><li><a href="#_13" rel="nofollow">一、认识响应状态码</a></li><li><ul><li><a href="#1_HTTP_15" rel="nofollow">1. 什么是HTTP响应状态码</a></li><li><a href="#2_Http_21" rel="nofollow">2. Http响应状态码的作用</a></li><li><a href="#3_HTTP_33" rel="nofollow">3. 优化和调试HTTP请求的建议</a></li></ul> 
  </li><li><a href="#1xx__57" rel="nofollow">二、1xx 信息响应</a></li><li><ul><li><a href="#1_http_59" rel="nofollow">1. 认识http信息响应</a></li><li><a href="#2__62" rel="nofollow">2. 常见的信息响应状态码</a></li></ul> 
  </li><li><a href="#2xx__72" rel="nofollow">三、2xx 成功响应</a></li><li><ul><li><a href="#1_HTTP_76" rel="nofollow">1. 认识HTTP成功响应</a></li><li><a href="#2__83" rel="nofollow">2. 常见的成功响应状态码</a></li></ul> 
  </li><li><a href="#3xx__99" rel="nofollow">四、3xx 重定向</a></li><li><ul><li><a href="#1_http_101" rel="nofollow">1. 认识http重定向</a></li><li><a href="#2__107" rel="nofollow">2. 常见的重定向状态码</a></li></ul> 
  </li><li><a href="#4xx__122" rel="nofollow">五、4xx 客户端响应</a></li><li><ul><li><a href="#1_http_124" rel="nofollow">1. 认识http客户端响应</a></li><li><a href="#2__127" rel="nofollow">2. 常见的客户端响应状态码</a></li></ul> 
  </li><li><a href="#5xx__161" rel="nofollow">六、5xx 服务端响应</a></li><li><ul><li><a href="#1_HTTP_163" rel="nofollow">1. 认识HTTP服务端响应</a></li><li><a href="#2__166" rel="nofollow">2. 常见的服务端响应状态码</a></li></ul> 
  </li><li><a href="#_185" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_4"></a>前言</h2> 
<p>为了巩固所学的知识，作者尝试着开始发布一些学习笔记类的博客，方便日后回顾。当然，如果能帮到一些萌新进行新技术的学习那也是极好的。作者菜菜一枚，文章中如果有记录错误，欢迎读者朋友们批评指正。<br> （博客的参考源码可以在我主页的资源里找到，如果在学习的过程中有什么疑问欢迎大家在评论区向我提出）</p> 
<h2><a id="_9"></a>发现宝藏</h2> 
<p>前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【<a href="https://www.captainbed.cn/dl" rel="nofollow">宝藏入口</a>】。</p> 
<h2><a id="_13"></a>一、认识响应状态码</h2> 
<h3><a id="1_HTTP_15"></a>1. 什么是HTTP响应状态码</h3> 
<blockquote> 
 <p><font size="3"></font></p> 
 <div> 
  <strong>HTTP状态码是由服务器在响应客户端请求时返回的三位数字代码。它们用于表示HTTP请求的处理状态和结果。每个状态码都具有特定的含义，用于向客户端传达有关请求处理情况的信息。</strong> 
 </div> 
 <p></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/b7/d9/MiNGejwl_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_Http_21"></a>2. Http响应状态码的作用</h3> 
<ul><li> <p><strong>提供请求处理结果信息</strong>：HTTP状态码告知客户端请求的处理情况，包括成功、重定向、客户端错误和服务器错误等。通过状态码，客户端可以了解请求是否成功处理，以及如何进一步处理响应数据。</p> </li><li> <p><strong>识别请求错误原因</strong>：状态码可以帮助客户端定位请求出错的原因。例如，当客户端发送了无效的请求或请求的资源不存在时，服务器会返回相应的错误状态码，使客户端能够了解到具体的错误原因，从而采取适当的措施。</p> </li><li> <p><strong>支持协议扩展和升级</strong>：HTTP状态码的范围留有一定的空间，以支持未来的协议扩展和升级。通过定义新的状态码，可以为新的协议功能或处理情况提供准确的表示。</p> </li><li> <p><strong>用于调试和故障排除</strong>：状态码在调试和故障排除过程中起到重要的作用。通过查看状态码，开发人员可以追踪请求处理的过程并确定出现问题的具体环节，以便进行修复和改进。</p> </li><li> <p><strong>帮助构建良好的用户体验</strong>：正确使用状态码有助于提供良好的用户体验。例如，合理使用重定向状态码可以引导用户到正确的页面，而准确的错误状态码可以向用户提供友好的错误提示，提高用户满意度。</p> </li></ul> 
<h3><a id="3_HTTP_33"></a>3. 优化和调试HTTP请求的建议</h3> 
<ul><li> <p><strong>使用适当的HTTP方法</strong>：选择正确的HTTP方法来匹配请求的目的。常见的方法包括GET、POST、PUT、DELETE等。确保使用最适合的方法来执行特定的操作，以提高效率和安全性。</p> </li><li> <p><strong>减少请求次数</strong>：减少不必要的请求次数可以显著提高性能。考虑使用请求合并、缓存、批量操作等技术来减少请求的数量，尽量减少服务器和网络的负载。</p> </li><li> <p><strong>最小化请求大小</strong>：减少请求的大小可以降低网络传输成本和请求处理时间。优化请求的体积，例如通过压缩、减少冗余数据、合并请求等方式来减小请求的大小。</p> </li><li> <p><strong>使用HTTP缓存</strong>：利用HTTP缓存可以减少对服务器的请求。合理设置缓存头，包括Cache-Control、Expires等，以及验证缓存是否仍然有效的机制，如ETag和Last-Modified。</p> </li><li> <p><strong>压缩响应数据</strong>：使用压缩算法（如Gzip）对响应数据进行压缩，以减小响应的大小。客户端可以通过设置Accept-Encoding头来指示对压缩响应的支持，服务器则可以通过设置Content-Encoding头来指示响应数据的压缩方式。</p> </li><li> <p><strong>使用合适的数据格式</strong>：选择适合数据交换的格式，如JSON、XML等。根据需求和场景选择合适的数据格式，以提高数据传输的效率和易用性。</p> </li><li> <p><strong>监控和日志记录</strong>：使用适当的工具和技术来监控和记录HTTP请求和响应的信息。通过记录日志和分析监控数据，可以帮助发现潜在的性能问题和错误，以及进行调试和优化。</p> </li><li> <p><strong>使用合适的工具和库</strong>：使用优秀的HTTP请求库或框架，如cURL、HttpClient等，可以简化开发过程并提供更高效的请求处理和调试功能。</p> </li><li> <p><strong>进行性能测试</strong>：对HTTP请求进行性能测试，可以评估系统的性能并找出瓶颈。使用工具如Apache JMeter、LoadRunner等进行负载测试和压力测试，以确定性能瓶颈并进行优化。</p> </li><li> <p><strong>仔细分析错误信息</strong>：对于出现的错误，仔细分析错误信息和状态码，以了解问题的根本原因。结合日志和其他调试工具，追踪请求的处理过程，找出错误所在并采取相应的修复措施。</p> </li></ul> 
<h2><a id="1xx__57"></a>二、1xx 信息响应</h2> 
<h3><a id="1_http_59"></a>1. 认识http信息响应</h3> 
<blockquote> 
 <p>HTTP信息响应是指当客户端向服务器发送HTTP请求后，服务器返回给客户端的响应消息</p> 
</blockquote> 
<h3><a id="2__62"></a>2. 常见的信息响应状态码</h3> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>100 Continue</strong></td><td> 
    <div align="left"> 
     <font size="3">这个临时响应表明，迄今为止的所有内容都是可行的，<strong>客户端应该继续请求，如果已经完成，则忽略它</strong></font> 
    </div></td></tr><tr><td><strong>101 Switching Protocol</strong></td><td> 
    <div align="left"> 
     <font size="3">该代码是响应客户端的 Upgrade 标头发送的，并且<strong>指示服务器也正在切换的协议</strong></font> 
    </div></td></tr><tr><td><strong>102 Processing（WebDAV）</strong></td><td> 
    <div align="left"> 
     <font size="3">此代码表示服务器已收到并<strong>正在处理该请求，但没有响应可用</strong></font> 
    </div></td></tr><tr><td><strong>103 Early Hints</strong></td><td> 
    <div align="left"> 
     <font size="3">此状态代码<strong>主要用于与 Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源</strong></font> 
    </div></td></tr></tbody></table> 
<h2><a id="2xx__72"></a>三、2xx 成功响应</h2> 
<h3><a id="1_HTTP_76"></a>1. 认识HTTP成功响应</h3> 
<blockquote> 
 <p>HTTP状态码成功响应是指服务器成功处理了客户端的请求，并返回了符合预期的响应</p> 
</blockquote> 
<h3><a id="2__83"></a>2. 常见的成功响应状态码</h3> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>200 OK</strong></td><td> 
    <div align="left"> 
     <font size="4"><strong>请求成功,成功的含义取决于 HTTP 方法：</strong></font> 
     <ul><li> 
      <div align="left"> 
       <font size="3"> GET：资源已被提取并在消息正文中传输</font> 
      </div></li><li> 
      <div align="left"> 
       <font size="3"> HEAD：实体表头位于消息正文中</font> 
      </div></li><li> 
      <div align="left"> 
       <font size="3"> POST：描述动作结果的资源在消息体中传输</font> 
      </div></li><li> 
      <div align="left"> 
       <font size="3"> TRACE：消息正文包含服务器收到的请求消息</font> 
      </div></li></ul></div></td></tr><tr><td><strong>201 Created</strong></td><td> 
    <div align="left"> 
     <font size="3">该请求已成功，<strong>并因此创建了一个新的资源</strong>。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应</font> 
    </div></td></tr><tr><td><strong>202 Accepted</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>请求已经接收到，但还未响应，没有结果</strong>。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理</font> 
    </div></td></tr><tr><td><strong>203 Non-Authoritative Information</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> 服务器<strong>已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝</strong>.当前的信息可能是原始版本的子集或者超集。</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回 200 OK 的情况下才是合适的</font> 
     </div></li></ul></td></tr><tr><td><strong>204 No Content</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> <strong>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息</strong>。响应可能通过实体头部的形式，返回新的或更新后的元信息</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档 </font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 由于 204 响应被禁止包含任何消息体，因此他始终以消息头后的第一个空行结尾</font> 
     </div></li></ul></td></tr><tr><td><strong>205 Reset Content</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> <strong>服务器成功处理了请求，且没有返回任何内容。但是与 204 响应不同，返回此状态码的响应要求请求者重置文档视图</strong>。该请求主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松的开始另一次输入</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 与 204 响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一空行结束</font> 
     </div></li></ul></td></tr><tr><td><strong>206 Partial Content</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> <strong>服务器已经成功处理了部分 GET 请求</strong>。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解成多个下载段同时下载</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> <strong>该请求必须包含 Range 头信息来指示客户端希望得到的内容范围</strong>，并且可能包含 If-Range 来作为请求条件</font> 
     </div></li></ul></td></tr><tr><td><strong>207 Multi-Status （WebDAV）</strong></td><td> 
    <div align="left"> 
     <font size="3">由 WebDAV（RFC 2518）扩展的状态码，<strong>代表之后的消息体将是一个 XML 消息</strong>，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码</font> 
    </div></td></tr><tr><td><strong>208 Already Reported（WebDAV）</strong></td><td> 
    <div align="left"> 
     <font size="3">在 DAV 里面使用：<strong>propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合</strong></font> 
    </div></td></tr><tr><td><strong>226 IM Used（HTTP Delta encoding）</strong></td><td> 
    <div align="left"> 
     <font size="3">服务器已经完成了对资源的 GET 请求，<strong>并且响应是对当前实例应用的一个或多个实例操作结果的表示</strong></font> 
    </div></td></tr></tbody></table> 
<h2><a id="3xx__99"></a>四、3xx 重定向</h2> 
<h3><a id="1_http_101"></a>1. 认识http重定向</h3> 
<blockquote> 
 <p>HTTP状态码重定向是在服务器接收到客户端的请求后，返回一个特定的状态码，指示客户端需要采取进一步的操作以完成请求</p> 
</blockquote> 
<h3><a id="2__107"></a>2. 常见的重定向状态码</h3> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>300 Multiple Choice</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>被请求的资源有一系列可供选择的回馈信息</strong>，每个都有自己特定的地址和浏览器驱动的商议信息。<strong>用户或浏览器能够自行选择一个首选的地址进行重定向</strong></font> 
    </div></td></tr><tr><td><strong>301 Moved Permanently</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> <strong>被请求的资源已永久移动到新位置</strong>，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URL 之一。如果可能，<strong>拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址</strong></font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 除非额外指定，否则这个响应也可缓存的</font> 
     </div></li></ul></td></tr><tr><td><strong>302 Found</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>请求的资源现在临时从不同的 URL 响应请求</strong>。由于这样的重定向是临时的，<strong>客户端应当继续向原有地址发送以后的请求</strong>。只有在 Cache-Control 或 Expires 中进行了指定的情况，这个响应才是可缓存的</font> 
    </div></td></tr><tr><td><strong>303 See Othe</strong>r</td><td> 
    <div align="left"> 
     <font size="3"><strong>对应当前的响应可以在另一个 URL 上被找到，而且客户端应当采用 GET 的方式访问那个资源</strong>。这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源</font> 
    </div></td></tr><tr><td><strong>304 Not Modified</strong></td><td> 
    <div align="left"> 
     <font size="3">如果<strong>客户端发送一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码</strong>。304 响应禁止包含消息体，因此始终以消息头的第一个空行结尾</font> 
    </div></td></tr><tr><td><strong>305 Use Proxy</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>被请求的资源必须通过指定的代理才能访问</strong>。Location 域中将给出指定的代理所在的 URL 信息，接受这需要重复发送一个单独的请求，通过这个代理才能访问相应资源。<strong>只有原始服务器才能建立 305 响应</strong></font> 
    </div></td></tr><tr><td><strong>306 unused</strong></td><td> 
    <div align="left"> 
     <font size="3">在最新版的规范中，<strong>306 状态码已经不再被使用</strong></font> 
    </div></td></tr><tr><td><strong>307 Temporary Redirect</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>请求的资源现在临时从不同的 URL 响应请求</strong>。由于这样的重定向是临时的，<strong>客户端应当继续向原有地址发送以后的请求</strong>。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的</font> 
    </div></td></tr><tr><td><strong>308 Permanent Redirect</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> <strong>这意味着资源现在永久位于 Location</strong>：HTTP Response 标头指定的另一个 URL</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 这与301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：<strong>如果第一个请求中使用 POST，则必须在第二个请求中使用 POST</strong></font> 
     </div></li></ul></td></tr></tbody></table> 
<h2><a id="4xx__122"></a>五、4xx 客户端响应</h2> 
<h3><a id="1_http_124"></a>1. 认识http客户端响应</h3> 
<blockquote> 
 <ol><li>HTTP客户端是指发起HTTP请求的客户端应用程序或设备。当HTTP客户端发送请求到服务器端时，服务器会返回HTTP响应。HTTP客户端会负责接收和处理这个HTTP响应</li><li>HTTP客户端响应是指服务器返回给客户端的HTTP响应报文</li></ol> 
</blockquote> 
<h3><a id="2__127"></a>2. 常见的客户端响应状态码</h3> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>400 Bad Request</strong></td><td>**<ul><li> 
     <div align="left"> 
      <font size="3"> <strong>语义有误，当前请求无法被服务器理解</strong>。除非进行修改，否则客户端不应该重复提交这个请求</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 请求参数有误</font> 
     </div></li></ul></td></tr><tr><td><strong>401 Unauthorized</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> <strong>当前请求需要用户验证</strong>。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> <strong>客户端可以重复提交一个包含恰当的 Authenticate 头信息的请求</strong>。如果当前请求已经包含了 Authenticate 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书。如果 401 响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息</font> 
     </div></li></ul></td></tr><tr><td><strong>402 Payment Required</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>此响应码保留以便将来使用</strong>，创造此响应码的最初目的是用于数字支付系统</font> 
    </div></td></tr><tr><td><strong>403 Forbidden</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> <strong>服务器已经理解请求，但是拒绝执行它</strong>。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 当然服务器也可以返回一个 404 响应，假如他不希望客户端获得任何信息</font> 
     </div></li></ul></td></tr><tr><td><strong>404 Not Found</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> <strong>请求失败，请求所希望得到的资源未被在服务器上发现</strong>。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 410 状态码来告知旧资源因为某些内部配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 404 这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下</font> 
     </div></li></ul></td></tr><tr><td><strong>405 Method Not Allowed</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> <strong>请求行中指定的请求方法不能被用于请求相应的资源</strong>。该响应必须返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回 405 错误</font> 
     </div></li></ul></td></tr><tr><td><strong>406 Not Acceptable</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体</strong></font> 
    </div></td></tr><tr><td><strong>407 Proxy Authentication Required</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>与 401响应相似，只不过客户端必须在代理服务器上进行身份验证</strong>。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证</font> 
    </div></td></tr><tr><td><strong>408 Request Timeout</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>请求超时</strong>。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这个请求而无需进行任何更改</font> 
    </div></td></tr><tr><td><strong>409 Conflict</strong></td><td> 
    <div align="left"> 
     <font size="3"> <strong>由于和被请求的资源的当前状态之间存在冲突，请求无法完成</strong>。这个代码只允许用在这样的情况才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头</font> 
    </div></td></tr><tr><td><strong>410 Gone</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> <strong>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址</strong>。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否为永久的，那么就应该使用 404 状态码</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 除非额外说明，否则这个响应是可缓存的</font> 
     </div></li></ul></td></tr><tr><td><strong>411 Length Required</strong></td><td> 
    <div align="left"> 
     <font size="3"> <strong>服务器拒绝在没有定义 Content-Length 头的情况下接受请求</strong>。在添加了标明请求消息体长度的有效 Content-Length 头后，客户端可以再次提交该请求</font> 
    </div></td></tr><tr><td><strong>412 Precondition Failed</strong></td><td> 
    <div align="left">
      &lt;font size=“3” 
     <strong>&gt;服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或者多个</strong>。这个状态码允许客户端在获取资源的请求的元信息（请求头字段数据）中设置先决条件，以此来避免该请求方法被应用到其希望的内容以外的资源上 
    </div></td></tr><tr><td><strong>413 Payload Too Large</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> <strong>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围</strong>。此种情况下，服务器可以关闭连接以免客户端继续发送此请求</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 如果这种状况是临时的，服务器应当返回一个 Refty-After 的响应头，以告知客户端可以在多少时间以后重新尝试</font> 
     </div></li></ul></td></tr><tr><td><strong>414 URL Too Long</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>请求的 URL 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务</strong>。这比较少见，通常情况包括：本应使用 POST 方法的表单提交变成了 GET 方法，导致查询字符串（Query String）过长</font> 
    </div></td></tr><tr><td><strong>415 Unsupported Media Type</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器所支持的格式，因此请求被拒绝</strong></font> 
    </div></td></tr><tr><td><strong>416 Range Not Satisfiable</strong></td><td> 
    <div align="left"> 
     <font size="3">如果<strong>请求中包含了 Range 请求头</strong>，并且 <strong>Range 中指定的任何数据范围都与当前资源的可用范围不重合</strong>，同时<strong>请求中又没有定义 If-Range 请求头</strong>，那么服务器就应当返回 416 状态码</font> 
    </div></td></tr><tr><td><strong>417 Expectation Failed</strong></td><td> 
    <div align="left"> 
     <font size="3">此响应代码意味着<strong>服务器无法满足 Expect 请求标头字段指示的期望值</strong></font> 
    </div></td></tr><tr><td><strong>418 I’m a teapot</strong></td><td> 
    <div align="left"> 
     <font size="3"> 服务器拒绝尝试用“茶壶冲泡咖啡”(愚人节玩笑)</font> 
    </div></td></tr><tr><td><strong>421 Misdirected Request</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>该请求针对的是无法产生响应的服务器</strong>。这可以由服务器发送，该服务器为配置为针对包含在请求 URL 中的方案和权限的组合产生响应</font> 
    </div></td></tr><tr><td><strong>422 Unprocessable Entity（WebDAV）</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>请求格式良好，但由于语义错误而无法遵循</strong></font> 
    </div></td></tr><tr><td><strong>423 Locked（WebDAV）</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>正在访问的资源被锁定</strong></font> 
    </div></td></tr><tr><td><strong>424 Failed Dependency（WebDAV）</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>由于先前的请求失败</strong>，所以这次请求失败</font> 
    </div></td></tr><tr><td><strong>425 Too Early</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>服务器不愿意冒着风险去处理可能重播的请求</strong></font> 
    </div></td></tr><tr><td><strong>426 Upgrade Required</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做</strong>。服务器在 426 响应中发送 Upgrade 头一直是所需的协议</font> 
    </div></td></tr><tr><td><strong>428 Precondition Required</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>原始服务器要求该请求是有条件的</strong>。旨在防止“丢失更新”问题，即客户端获取资源状态，修改改状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突</font> 
    </div></td></tr><tr><td><strong>429 Too Many Requests</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>用户在给定时间内发送了太多请求（“限制请求速率”）</strong></font> 
    </div></td></tr><tr><td><strong>431 Request Header Fields Too Large</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>服务器不愿意处理请求，因为他的请求头字段太大</strong>。请求可以在减少请求头字段的大小后重新提交</font> 
    </div></td></tr><tr><td><strong>451 Unavailable For Legal Reasons</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>用户请求非法资源</strong>，例如：由政府审查的网页</font> 
    </div></td></tr></tbody></table> 
<h2><a id="5xx__161"></a>六、5xx 服务端响应</h2> 
<h3><a id="1_HTTP_163"></a>1. 认识HTTP服务端响应</h3> 
<blockquote> 
 <p>HTTP服务端响应是指服务器对客户端的HTTP请求做出的响应。服务器接收到客户端的请求后，会根据请求的内容和服务器端的处理逻辑生成一个HTTP响应，然后将该响应发送回客户端</p> 
</blockquote> 
<h3><a id="2__166"></a>2. 常见的服务端响应状态码</h3> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>500 Internal Server Error</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>服务器遇到了不知道如何处理的情况</strong></font> 
    </div></td></tr><tr><td><strong>501 Not Implemented</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>此请求方法不被服务器支持且无法被处理</strong>。只有 GET 和 HEAD 时要求服务器支持的，他们必定不会返回次错误代码</font> 
    </div></td></tr><tr><td><strong>502 Bad Gateway</strong></td><td> 
    <div align="left"> 
     <font size="3"> <strong>此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应</strong></font> 
    </div></td></tr><tr><td><strong>503 Service Unavailable</strong></td><td><ul><li> 
     <div align="left"> 
      <font size="3"> <strong>服务器没有准备好处理请求</strong>。常见原因是服务器因维护或重载而停机。请注意，与此响应一起，应发送解释问题的用户友好页面。这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP 头应该包含恢复服务之前的估计时间</font> 
     </div></li><li> 
     <div align="left"> 
      <font size="3"> 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存</font> 
     </div></li></ul></td></tr><tr><td><strong>504 Gateway Timeout</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>当服务器作为网关，不能及时得到响应时返回此错误代码</strong></font> 
    </div></td></tr><tr><td><strong>505 HTTP Version Not Supported</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>服务器不支持请求中所使用的 HTTP 协议版本</strong></font> 
    </div></td></tr><tr><td><strong>506 Variant Also Negotiates</strong></td><td> 
    <div align="left"> 
     <font size="3">服务器有一个内部配置错误：<strong>对请求的透明内容协议导致循环引用</strong></font> 
    </div></td></tr><tr><td><strong>507 Insufficient Storage</strong></td><td> 
    <div align="left"> 
     <font size="3">服务器有内部配置错误：<strong>所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点</strong></font> 
    </div></td></tr><tr><td><strong>508 Loop Detected（WebDAV）</strong></td><td> 
    <div align="left"> 
     <font size="3">服务器在处理请求时<strong>检测到无限循环</strong></font> 
    </div></td></tr><tr><td><strong>510 Not Extended</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>客户端需要对请求进一步扩展，服务器才能实现它</strong>。服务器会回复客户端发出扩展请求所需的所有信息</font> 
    </div></td></tr><tr><td><strong>511 Network Authentication Required</strong></td><td> 
    <div align="left"> 
     <font size="3"><strong>511 状态码指示客户端需要进行身份验证才能获得网络访问权限</strong></font> 
    </div></td></tr></tbody></table> 
<h2><a id="_185"></a>总结</h2> 
<p>欢迎各位留言交流以及批评指正，如果文章对您有帮助或者觉得作者写的还不错可以点一下关注，点赞，收藏支持一下。<br> （博客的参考源码可以在我主页的资源里找到，如果在学习的过程中有什么疑问欢迎大家在评论区向我提出）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5db61c703862eb9caec6fca7674f2666/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Vue】修改组件样式并动态添加样式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c6d0f3b3821891081a969e849b136d57/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python-Django的“日志功能-日志模块(logging模块)-日志输出”的功能详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>