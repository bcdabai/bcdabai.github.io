<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; ： auto关键字 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; ： auto关键字" />
<meta property="og:description" content="前提引入:
1.类型名，在绝大多数编程时，我们都会引入类型来定义一个我们需要的数据。
类型众多，偶尔我们会遇见一串类型名，使用起来无比复杂。存在拼写错误，含义不明确导致出错的问题。
列如:
std::map&lt;std::string, std::string&gt; m{ { &#34;apple&#34;, &#34;苹果&#34; }, { &#34;orange&#34;, &#34;橙子&#34; }, {&#34;pear&#34;,&#34;梨&#34;} }; std::map&lt;std::string, std::string&gt;::iterator it = m.begin(); 在这串代码中，std::map&lt;std::string, std::string&gt;::iterator 是一个类型，但是该类型太长了，特别容易写错。如何简化呢。
在C中，typedef 作为一个可以取别名的一个关键字。确实可以省事许多，却任然存在缺陷。
typedef std::map&lt;std::string, std::string&gt; Map; 若 typedef 为指针取了别名。存在小问题。
typedef char* pstring; int main() { const pstring p1; // 编译成功还是失败？ const pstring* p2; // 编译成功还是失败？ return 0; } C&#43;&#43;是怎么做的呢，设计师为了不想写复杂的类型，引入了auto关键字。
auto ：
1.在早期C/C&#43;&#43;中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量
2.C&#43;&#43;11中，标准委员会赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得
注：既然auto作为推导而得，在使用auto时，必须初始化。
auto 的使用场景
1. auto 在推导指针是，不必再加*号；
2.auto在使用引用时，必须遵循规则加上&amp;号；
3.不能作为函数的参数使用
4.不能直接用来声明数组。
5.一行多个数据推导必须同类型。
int main() { //1 int x = 10; auto a = &amp;x; auto* b = &amp;x; auto&amp; c = x; cout &lt;&lt; typeid(a)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9f8a5954be3bd2238c3b87bb558277b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-10T19:54:27+08:00" />
<meta property="article:modified_time" content="2023-04-10T19:54:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; ： auto关键字</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>        前提引入:</p> 
 <p>                1.类型名，在绝大多数编程时，我们都会引入类型来定义一个我们需要的数据。</p> 
 <p>                类型众多，偶尔我们会遇见一串类型名，使用起来无比复杂。存在拼写错误，含义不明确导致出错的问题。</p> 
</blockquote> 
<blockquote> 
 <p>                列如:</p> 
 <pre><code class="language-cpp">std::map&lt;std::string, std::string&gt; m{ { "apple", "苹果" }, { "orange", "橙子" },
{"pear","梨"} };

std::map&lt;std::string, std::string&gt;::iterator it = m.begin();</code></pre> 
 <p>           在这串代码中，std::map&lt;std::string, std::string&gt;::iterator 是一个类型，但是该类型太长了，特别容易写错。如何简化呢。</p> 
 <p>        在C中，typedef 作为一个可以取别名的一个关键字。确实可以省事许多，却任然存在缺陷。</p> 
 <pre><code class="language-cpp">typedef std::map&lt;std::string, std::string&gt; Map;</code></pre> 
 <p>        若 typedef 为指针取了别名。存在小问题。</p> 
 <pre><code class="language-cpp">typedef char* pstring;
int main()
{
    const pstring p1; // 编译成功还是失败？
    const pstring* p2; // 编译成功还是失败？
    return 0;
}
</code></pre> 
 <p>        C++是怎么做的呢，设计师为了不想写复杂的类型，引入了auto关键字。</p> 
</blockquote> 
<blockquote> 
 <p>        auto ：</p> 
 <p>       1.在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量<br>        2.C++11中，标准委员会赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得<br>         注：既然auto作为推导而得，<strong><span style="color:#fe2c24;">在使用auto时，必须初始化。</span></strong></p> 
 <p> </p> 
</blockquote> 
<blockquote> 
 <p> auto 的使用场景</p> 
 <p>        1. auto 在推导指针是，不必再加*号；</p> 
 <p>        2.auto在使用引用时，<strong>必须</strong>遵循规则加上&amp;号；</p> 
 <p></p> 
 <p>        3.<strong>不能</strong>作为函数的参数使用</p> 
 <p>        4.<strong>不能</strong>直接用来声明数组。</p> 
 <p>        5.一行多个数据推导<strong>必须同类型</strong>。</p> 
</blockquote> 
<p>        </p> 
<blockquote> 
 <p>        </p> 
 <pre><code class="language-cpp">int main()
{


    //1
    int x = 10;
    auto a = &amp;x;
    auto* b = &amp;x;
    auto&amp; c = x;
    cout &lt;&lt; typeid(a).name() &lt;&lt; endl;
    cout &lt;&lt; typeid(b).name() &lt;&lt; endl;
    cout &lt;&lt; typeid(c).name() &lt;&lt; endl;
    *a = 20;
    *b = 30;
    c = 40;

    
    
    //5
    void TestAuto()
    {
        auto a = 1, b = 2;
        auto c = 3, d = 4.0;  //错
    }


return 0;
}</code></pre> 
 <p></p> 
</blockquote> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0cfb6d9811b139830078f8c599ff64d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于k8s&#43;prometheus实现双vip可监控Web高可用集群</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e997bc7a836b4c5ac651f4a86473880e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">内网穿透加nginx 实现一条隧道部署前后端项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>