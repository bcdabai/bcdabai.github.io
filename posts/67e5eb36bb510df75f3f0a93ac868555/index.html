<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>嵌入式linux开发实用工具小程序 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="嵌入式linux开发实用工具小程序" />
<meta property="og:description" content="Table of Contents
（一）十六进制字符转整型数字
（二）字符串转整型
（三）创建文件并填充固定数据
（四）批量处理图片
（五）海思HI3520 IO控制小程序
（六）路由追踪
（七）文件固定位置插入数据
（七）H264 I帧与P帧偏移
（八）获取本地IP地址
在学习和工作开发的时候，经常需要使用到各种各样不太常用的操作，这种情况一般是自己手动写一些小程序来处理。因为它们不太常用，所以经常用了又没保存，等到下一次在使用的时候又需要重写，这样的非常浪费时间和精力。所以想在这里统一记录一下，以备下次重新使用。代码以实用为主，如果缺陷，欢迎指出。
（一）十六进制字符转整型数字 功能：将16进制的字符串转换为10进制的数字。我是没有找到相应的库函数，所以参考网上的代码自己手动写了个函数来实现。常用的函数有atoi,atol,他们都是将10进制的数字字符串转换为int或是long类型，所以在有些情况下不适用。
/*============================================================================= # FileName: hex2dec.cpp # Desc: Convert a hex string to a int number # Author: Caibiao Lee # Version: # LastChange: 2018-11-26 # History: =============================================================================*/ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;ctype.h&gt; int c2i(char ch) { // 如果是数字，则用数字的ASCII码减去48, 如果ch = &#39;2&#39; ,则 &#39;2&#39; - 48 = 2 if(isdigit(ch)) return ch - 48; // 如果是字母，但不是A~F,a~f则返回 if( ch &lt; &#39;A&#39; || (ch &gt; &#39;F&#39; &amp;&amp; ch &lt; &#39;a&#39;) || ch &gt; &#39;z&#39; ) return -1; // 如果是大写字母，则用数字的ASCII码减去55, 如果ch = &#39;A&#39; ,则 &#39;A&#39; - 55 = 10 // 如果是小写字母，则用数字的ASCII码减去87, 如果ch = &#39;a&#39; ,则 &#39;a&#39; - 87 = 10 if(isalpha(ch)) return isupper(ch) ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/67e5eb36bb510df75f3f0a93ac868555/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-30T18:57:56+08:00" />
<meta property="article:modified_time" content="2022-08-30T18:57:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式linux开发实用工具小程序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>Table of Contents</strong></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%95%B4%E5%9E%8B%E6%95%B0%E5%AD%97-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%95%B4%E5%9E%8B%E6%95%B0%E5%AD%97" rel="nofollow">（一）十六进制字符转整型数字</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E5%9E%8B" rel="nofollow">（二）字符串转整型</a></p> 
<p id="%C2%A0%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%B9%B6%E5%A1%AB%E5%85%85%E5%9B%BA%E5%AE%9A%E6%95%B0%E6%8D%AE-toc" style="margin-left:0px;"><a href="#%C2%A0%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%B9%B6%E5%A1%AB%E5%85%85%E5%9B%BA%E5%AE%9A%E6%95%B0%E6%8D%AE" rel="nofollow">（三）创建文件并填充固定数据</a></p> 
<p id="%EF%BC%88%E5%9B%9B%EF%BC%89%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87" rel="nofollow">（四）批量处理图片</a></p> 
<p id="%EF%BC%88%E4%BA%94%EF%BC%89%E6%B5%B7%E6%80%9DHI3520%20IO%E6%8E%A7%E5%88%B6%E5%B0%8F%E7%A8%8B%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%BA%94%EF%BC%89%E6%B5%B7%E6%80%9DHI3520%20IO%E6%8E%A7%E5%88%B6%E5%B0%8F%E7%A8%8B%E5%BA%8F" rel="nofollow">（五）海思HI3520 IO控制小程序</a></p> 
<p id="%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%AF%E7%94%B1%E8%BF%BD%E8%B8%AA-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%AF%E7%94%B1%E8%BF%BD%E8%B8%AA" rel="nofollow">（六）路由追踪</a></p> 
<p id="%EF%BC%88%E4%B8%83%EF%BC%89%E6%96%87%E4%BB%B6%E5%9B%BA%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%83%EF%BC%89%E6%96%87%E4%BB%B6%E5%9B%BA%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow">（七）文件固定位置插入数据</a></p> 
<p id="%EF%BC%88%E4%B8%83%EF%BC%89H264%20I%E5%B8%A7%E4%B8%8EP%E5%B8%A7%E5%81%8F%E7%A7%BB-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%83%EF%BC%89H264%20I%E5%B8%A7%E4%B8%8EP%E5%B8%A7%E5%81%8F%E7%A7%BB" rel="nofollow">（七）H264 I帧与P帧偏移</a></p> 
<p id="%EF%BC%88%E5%85%AB%EF%BC%89%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0IP%E5%9C%B0%E5%9D%80-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E5%85%AB%EF%BC%89%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0IP%E5%9C%B0%E5%9D%80" rel="nofollow">（八）获取本地IP地址</a></p> 
<hr id="hr-toc"> 
<p>    在学习和工作开发的时候，经常需要使用到各种各样不太常用的操作，这种情况一般是自己手动写一些小程序来处理。因为它们不太常用，所以经常用了又没保存，等到下一次在使用的时候又需要重写，这样的非常浪费时间和精力。所以想在这里统一记录一下，以备下次重新使用。代码以实用为主，如果缺陷，欢迎指出。</p> 
<hr> 
<h2 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%95%B4%E5%9E%8B%E6%95%B0%E5%AD%97">（一）十六进制字符转整型数字</h2> 
<p>    功能：将16进制的字符串转换为10进制的数字。我是没有找到相应的库函数，所以参考网上的代码自己手动写了个函数来实现。常用的函数有atoi,atol,他们都是将10进制的数字字符串转换为int或是long类型，所以在有些情况下不适用。</p> 
<pre class="has"><code class="language-cpp">/*=============================================================================
#     FileName: hex2dec.cpp
#         Desc: Convert a hex string to a int number
#       Author: Caibiao Lee
#      Version: 
#   LastChange: 2018-11-26 
#      History:
=============================================================================*/

#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string.h&gt;  
#include &lt;ctype.h&gt;

int c2i(char ch)  
{  
    // 如果是数字，则用数字的ASCII码减去48, 如果ch = '2' ,则 '2' - 48 = 2  
    if(isdigit(ch))  
            return ch - 48;  

    // 如果是字母，但不是A~F,a~f则返回  
    if( ch &lt; 'A' || (ch &gt; 'F' &amp;&amp; ch &lt; 'a') || ch &gt; 'z' )  
            return -1;  

    // 如果是大写字母，则用数字的ASCII码减去55, 如果ch = 'A' ,则 'A' - 55 = 10  
    // 如果是小写字母，则用数字的ASCII码减去87, 如果ch = 'a' ,则 'a' - 87 = 10  
    if(isalpha(ch))  
            return isupper(ch) ? ch - 55 : ch - 87;  

    return -1;  
} 

int hex2dec(char *hex)  
{  
    int len;  
    int num = 0;  
    int temp;  
    int bits;  
    int i;  
    char str[64] = {0};

	if(NULL==hex)
	{
		printf("input para error \n");
		return 0;
	}


	if(('0'==hex[0])&amp;&amp;(('X'==hex[1])||('x'==hex[1])))
	{
		strcpy(str,&amp;hex[2]);
	}else
	{
		strcpy(str,hex);
	}
	
	printf("input num = %s \n",str);
	
    // 此例中 str = "1de" 长度为3, hex是main函数传递的  
    len = strlen(str);  

    for (i=0, temp=0; i&lt;len; i++, temp=0)  
    {  
            // 第一次：i=0, *(str + i) = *(str + 0) = '1', 即temp = 1  
            // 第二次：i=1, *(str + i) = *(str + 1) = 'd', 即temp = 13  
            // 第三次：i=2, *(str + i) = *(str + 2) = 'd', 即temp = 14  
            temp = c2i( *(str + i) );  
            // 总共3位，一个16进制位用 4 bit保存  
            // 第一次：'1'为最高位，所以temp左移 (len - i -1) * 4 = 2 * 4 = 8 位  
            // 第二次：'d'为次高位，所以temp左移 (len - i -1) * 4 = 1 * 4 = 4 位  
            // 第三次：'e'为最低位，所以temp左移 (len - i -1) * 4 = 0 * 4 = 0 位  
            bits = (len - i - 1) * 4;  
            temp = temp &lt;&lt; bits;  

            // 此处也可以用 num += temp;进行累加  
            num = num | temp;  
    }  

    // 返回结果  
    return num;  
}  

int main(int argc, char **argv)
{
	int l_s32Ret = 0;
	
	if(2!=argc)
	{
		printf("=====ERROR!======\n");
		printf("usage: %s Num \n", argv[0]);
		printf("eg 1: %s 0x400\n", argv[0]);
		return 0;
	}

	l_s32Ret = hex2dec(argv[1]);
	printf("value hex = 0x%x \n",l_s32Ret);
	printf("value dec = %d \n",l_s32Ret);
	return 0;
}
</code></pre> 
<p>运行结果： </p> 
<pre class="has"><code class="language-cpp">biao@ubuntu:~/test/flash$ ./a.out 0x400
input num = 400 
value hex = 0x400 
value dec = 1024 
biao@ubuntu:~/test/flash$ </code></pre> 
<h2 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E5%9E%8B">（二）字符串转整型</h2> 
<p>     功能：将正常输入的16进制或是10进制的字符串转换为int数据类型</p> 
<pre class="has"><code class="language-cpp">/*=============================================================================
#     FileName: hex2dec.cpp
#         Desc: Convert a hex/dec string to a int number
#       Author: Caibiao Lee
#      Version: 
#   LastChange: 2018-12-03 
#      History:
=============================================================================*/
#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string.h&gt;  
#include &lt;ctype.h&gt;

int String2int(char *strChar)
{
	int len=0;
	const char *pstrCmp1="0123456789ABCDEF";
	const char *pstrCmp2="0123456789abcdef";
	
	char *pstr=NULL;
	int uiValue=0;
	int j=0;	
	unsigned int t=0;
	int i=0;
	if(NULL==strChar)
		return -1;
	if(0&gt;=(len=strlen((const char *)strChar)))
		return -1;
	if(NULL!=(pstr=strstr(strChar,"0x"))||NULL!=(pstr=strstr(strChar,"0X")))
	{
		pstr=(char *)strChar+2;
		
		if(0&gt;=(len=strlen((const char *)pstr)))
			return -1;
		for(i=(len-1);i&gt;=0;i--)
		{
			if(pstr[i]&gt;'F')
			{
				for(t=0;t&lt;strlen((const char *)pstrCmp2);t++)
				{	
					if(pstrCmp2[t]==pstr[i])
						uiValue|=(t&lt;&lt;(j++*4));
				}
			}
			else
			{
				for(t=0;t&lt;strlen((const char *)pstrCmp1);t++)
				{	
					if(pstrCmp1[t]==pstr[i])
						uiValue|=(t&lt;&lt;(j++*4));
				}
			}
		}
	}
	else
	{
		uiValue=atoi((const char*)strChar);
	}
	return uiValue;
}

int main(int argc, char **argv)
{
	int l_s32Ret = 0;
		
	if(2!=argc)
	{
		printf("=====ERROR!======\n");
		printf("usage: %s Num \n", argv[0]);
		printf("eg 1: %s 0x400\n", argv[0]);
		return 0;
	}
	l_s32Ret = String2int(argv[1]);
	printf("value hex = 0x%x \n",l_s32Ret);
	printf("value dec = %d \n",l_s32Ret);
	return 0;
}
</code></pre> 
<h2 id="%C2%A0%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%B9%B6%E5%A1%AB%E5%85%85%E5%9B%BA%E5%AE%9A%E6%95%B0%E6%8D%AE">（三）创建文件并填充固定数据</h2> 
<p>    功能：创建固定大小的一个文件，并且把这个文件填充为固定的数据。</p> 
<pre class="has"><code class="language-cpp">/*=============================================================================
#     FileName: CreateFile.cpp
#         Desc: 创建固定大小的文件，然后填充固定的数据
#       Author: Caibiao Lee
#      Version: 
#   LastChange: 2018-11-26 
#      History:
=============================================================================*/
#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string.h&gt;  
#include &lt;ctype.h&gt;

//#define	FILL_DATA_VALUE		0xff
#define	FILL_DATA_VALUE		0x30 //char 0

int c2i(char ch)  
{  
    if(isdigit(ch))  
            return ch - 48;  

    if( ch &lt; 'A' || (ch &gt; 'F' &amp;&amp; ch &lt; 'a') || ch &gt; 'z' )  
            return -1;  

    if(isalpha(ch))  
            return isupper(ch) ? ch - 55 : ch - 87;  

    return -1;  
} 

int hex2dec(char *hex)  
{  
    int len;  
    int num = 0;  
    int temp;  
    int bits;  
    int i;  
    char str[64] = {0};

	if(NULL==hex)
	{
		printf("input para error \n");
		return 0;
	}

	if(('0'==hex[0])&amp;&amp;(('X'==hex[1])||('x'==hex[1])))
	{
		strcpy(str,&amp;hex[2]);
	}else
	{
		strcpy(str,hex);
	}
	
	printf("input num = %s \n",str);
	
    len = strlen(str);  

    for (i=0, temp=0; i&lt;len; i++, temp=0)  
    {  
            temp = c2i( *(str + i) );  

            bits = (len - i - 1) * 4;  
            temp = temp &lt;&lt; bits;  

            num = num | temp;  
    }  
    return num;  
}  

int main(int argc, char **argv)
{
	FILE *l_pFile = NULL;
	int 	l_s32Rest = 0;
	unsigned int l_WriteLen = 0;
	unsigned int l_FileLen = 0;
	unsigned char TempData[1024] = {FILL_DATA_VALUE};

	if(3!=argc)
	{
		printf("usage: %s FileName  FileLen \n ", argv[0]);
		printf("eg: %s ./Outfile.bin 0x400 \n ", argv[0]);
		return 0;
	};

	const char *l_pFileName = argv[1];
	if(NULL==l_pFileName)
	{
		printf("input file name is NULL \n");
		return -1;
	}
	
	if(('0'==argv[2][0])&amp;&amp;(('X'==argv[2][1])||('x'==argv[2][1])))
	{
		l_FileLen = hex2dec(argv[2]);
		
	}else
	{
		l_FileLen = atoi(argv[2]);
	}
	
	printf("Need To Write Data Len %d \n",l_FileLen);
	printf("Fill Data Vale = 0x%x \n",FILL_DATA_VALUE);
	
	for(int i=0;i&lt;1024;i++)
	{
		TempData[i] = FILL_DATA_VALUE;
	}
	

	l_pFile = fopen(l_pFileName,"w+");
	if(l_pFile==NULL)
	{
		printf("open file %s error \n",l_pFileName);
		return -1;
	}

	
	while(l_WriteLen&lt;l_FileLen)
	{
		if(l_FileLen&lt;1024)
		{
			l_s32Rest = fwrite(TempData,1,l_FileLen,l_pFile);
			
		}
		else
		{
			l_s32Rest = fwrite(TempData,1,1024,l_pFile);
		}

		if(l_s32Rest &lt;= 0)
		{
			break;
		};

		l_WriteLen +=l_s32Rest; 
	}
	
	if(NULL!=l_pFile)
	{
		fclose(l_pFile);
		l_pFile = NULL;
	}

	return 0;

}

</code></pre> 
<p>运行结果：</p> 
<pre class="has"><code class="language-cpp">biao@ubuntu:~/test/flash$ gcc CreateFile.cpp 
biao@ubuntu:~/test/flash$ ls
a.out  CreateFile.cpp  hex2dec.cpp  main.cpp  out.bin
biao@ubuntu:~/test/flash$ ./a.out ./out.bin 0x10
input num = 10 
Need To Write Data Len 16 
Fill Data Vale = 0x30 
biao@ubuntu:~/test/flash$ ls
a.out  CreateFile.cpp  hex2dec.cpp  main.cpp  out.bin
biao@ubuntu:~/test/flash$ vim out.bin 
  1 0000000000000000                                     </code></pre> 
<h2 id="%EF%BC%88%E5%9B%9B%EF%BC%89%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87">（四）批量处理图片</h2> 
<p>功能：批处理将图片前面固定的字节数删除。</p> 
<pre class="has"><code class="language-cpp">/*=============================================================================
#     FileName: CutFile.cpp
#         Desc: 批量处理，将图片的前面固定字节删除
#       Author: Caibiao Lee
#      Version: 
#   LastChange: 2018-11-26 
#      History:
=============================================================================*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;


#define START_READ_POSITION		128
#define PHOTO_START_TIME		83641
//l_s32PhotoTime = 92809;

int Cut_file(char * InputFile)
{
	FILE *l_pFileInput = NULL;
	FILE *l_pFileOutput = NULL;
	char l_ars8OutputName[128] = {0};
	unsigned char l_arru8TempData[1024] = {0};
	int l_s32Ret = 0;
	static unsigned int ls_u32Num = 0;

	
	if(NULL== InputFile) 
	{
		goto ERROR;
	}
	
	//sprintf(l_ars8OutputName,"./outfile/_%s",&amp;InputFile[8]);
	sprintf(l_ars8OutputName,"./outfile/00%d.jpg",ls_u32Num++);

	//printf("out file name %s \n",l_ars8OutputName);
	
	l_pFileInput = fopen(InputFile,"rb+");
	if(NULL==l_pFileInput)
	{
		printf("input file open error\n");
		goto ERROR;
	}

	l_pFileOutput = fopen(l_ars8OutputName,"w+");
	if(NULL==l_pFileOutput)
	{
		printf("out file open error\n");
		goto ERROR;
	}

	fseek(l_pFileInput,START_READ_POSITION,SEEK_SET);

	while(!feof(l_pFileInput))
	{
		l_s32Ret = fread(l_arru8TempData,1,1024,l_pFileInput);
		if(l_s32Ret&lt;0)
		{
			break;
		}

		l_s32Ret = fwrite(l_arru8TempData,1,l_s32Ret,l_pFileOutput);
		if(l_s32Ret&lt;0)
		{
			break;
		}
	}

ERROR:
	if(NULL!=l_pFileOutput)
	{
		fclose(l_pFileOutput);
		l_pFileOutput =NULL;
	};

	if(NULL !=l_pFileInput);
	{
		fclose(l_pFileInput);
		l_pFileInput =NULL;
	}
}

int main(void)
{
	char l_arrs8InputName[128] = {0};
	char l_s8PhotoChannel = 0;
	int  l_s32PhotoTime = 0;

	l_s8PhotoChannel = 3;
	l_s32PhotoTime = PHOTO_START_TIME;

	/**从第一通道开始**/
	for(int j=1;j&lt;l_s8PhotoChannel;j++)
	{
	
		for(int i=l_s32PhotoTime;i&lt;235959;i++)
		{
			memset(l_arrs8InputName,0,sizeof(l_arrs8InputName));
			sprintf(l_arrs8InputName,"./image/%dY%06d.jpg",j,i);
	
			if(0==access(l_arrs8InputName,F_OK))
			{
				printf("%s\n",l_arrs8InputName);
				Cut_file(l_arrs8InputName);				
			}
		}
	}
}
</code></pre> 
<p>运行结果：</p> 
<pre class="has"><code class="language-cpp">biao@ubuntu:~/test/photo$ gcc CutFile.cpp 
biao@ubuntu:~/test/photo$ ls
a.out  CutFile.cpp  image  outfile
biao@ubuntu:~/test/photo$ ./a.out 
./image/1Y083642.jpg
./image/1Y083714.jpg
./image/1Y083747.jpg
./image/1Y083820.jpg
./image/1Y083853.jpg
./image/1Y083925.jpg
./image/1Y084157.jpg
./image/1Y084228.jpg
./image/1Y084301.jpg
./image/1Y084334.jpg
./image/1Y084406.jpg
./image/1Y084439.jpg
./image/1Y084711.jpg
./image/1Y084742.jpg
./image/1Y173524.jpg
./image/1Y173556.jpg
./image/1Y173629.jpg
./image/1Y173702.jpg
./image/1Y173933.jpg
./image/1Y174004.jpg
./image/1Y174244.jpg
./image/1Y174315.jpg
./image/1Y174348.jpg
./image/1Y174420.jpg
./image/1Y174454.jpg
./image/1Y174733.jpg
biao@ubuntu:~/test/photo$ tree
.
├── a.out
├── CutFile.cpp
├── image
│   ├── 1Y083642.jpg
│   ├── 1Y083714.jpg
│   ├── 1Y083747.jpg
│   ├── 1Y083820.jpg
│   ├── 1Y083853.jpg
│   ├── 1Y083925.jpg
│   ├── 1Y084157.jpg
│   ├── 1Y084228.jpg
│   ├── 1Y084301.jpg
│   ├── 1Y084334.jpg
│   ├── 1Y084406.jpg
│   ├── 1Y084439.jpg
│   ├── 1Y084711.jpg
│   ├── 1Y084742.jpg
│   ├── 1Y173524.jpg
│   ├── 1Y173556.jpg
│   ├── 1Y173629.jpg
│   ├── 1Y173702.jpg
│   ├── 1Y173933.jpg
│   ├── 1Y174004.jpg
│   ├── 1Y174244.jpg
│   ├── 1Y174315.jpg
│   ├── 1Y174348.jpg
│   ├── 1Y174420.jpg
│   ├── 1Y174454.jpg
│   └── 1Y174733.jpg
└── outfile
    ├── 000.jpg
    ├── 0010.jpg
    ├── 0011.jpg
    ├── 0012.jpg
    ├── 0013.jpg
    ├── 0014.jpg
    ├── 0015.jpg
    ├── 0016.jpg
    ├── 0017.jpg
    ├── 0018.jpg
    ├── 0019.jpg
    ├── 001.jpg
    ├── 0020.jpg
    ├── 0021.jpg
    ├── 0022.jpg
    ├── 0023.jpg
    ├── 0024.jpg
    ├── 0025.jpg
    ├── 002.jpg
    ├── 003.jpg
    ├── 004.jpg
    ├── 005.jpg
    ├── 006.jpg
    ├── 007.jpg
    ├── 008.jpg
    └── 009.jpg

2 directories, 54 files
biao@ubuntu:~/test/photo$ </code></pre> 
<p>    运行前需要创建两个目录，image用来存放需要处理的图片，outfile用来存放处理过后的文件。这种处理文件批处理方式很暴力，偶尔用用还是可以的。</p> 
<hr> 
<h2 id="%EF%BC%88%E4%BA%94%EF%BC%89%E6%B5%B7%E6%80%9DHI3520%20IO%E6%8E%A7%E5%88%B6%E5%B0%8F%E7%A8%8B%E5%BA%8F">（五）海思HI3520 IO控制小程序</h2> 
<p>嵌入式设备系统一般为了节省空间，一般都会对系统进行裁剪，所以很多有用的命令都会被删除。在嵌入式设备中要调试代码也是比较麻烦的，一般只能看串口打印。现在写了个小程序，专门用来查看和控制海思Hi3520DV300芯片的IO电平状态。</p> 
<pre class="has"><code class="language-cpp">/*=============================================================================
#     FileName: Hi3520_IO_CTRL.cpp
#         Desc: Hi3520DV300 IO Write and  Read
#       Author: Caibiao Lee
#      Version: 
#   LastChange: 2018-11-30
#      History:
=============================================================================*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "hstGpioAL.h"

int PrintfInputTips(char *ps8Name)
{
	printf("=========== error!!! ========\n\n");
	printf("usage Write: %s GPIO bit value \n", ps8Name);
	printf("usage Read : %s GPIO bit \n", ps8Name);
	printf("eg Write 1 to GPIO1_bit02  :     %s 1 2 1\n", ps8Name);
	printf("eg Read  GPIO1_bit02 Value :     %s 1 2 \n\n", ps8Name);
	
	printf("=============BT20==================\n")
	printf("USB HUB    GPIO_0_2  1_UP; 0_Down \n");
	printf("RESET_HD   GPIO_13_0 0_EN; 1_disEN\n");
	printf("Power_HD   GPIO_13_3 1_UP; 0_Down \n");
	return 0;
}

int main(int argc, char **argv)
{
	if((3!=argc)&amp;&amp;(4!=argc))
	{
		PrintfInputTips(argv[0]);
		return -1;
	}
	
	unsigned char l_u8GPIONum = 0;
	unsigned char l_u8GPIOBit = 0;
	unsigned char l_u8SetValue = 0;

	GPIO_GROUP_E  l_eGpioGroup;
	GPIO_BIT_E	  l_eBit;
	GPIO_DATA_E   l_eData;

	l_u8GPIONum   = atoi(argv[1]);
	l_u8GPIOBit   = atoi(argv[2]);

	if(l_u8GPIONum&lt;14)
	{
		l_eGpioGroup = (GPIO_GROUP_E)l_u8GPIONum;
	}else
	{
		printf("l_u8GPIONum error l_u8GPIONum = %d\n",l_u8GPIONum);
		return -1;
	};

	if(l_u8GPIOBit&lt;8)
	{
		l_eBit = (GPIO_BIT_E)l_u8GPIOBit;
	}else
	{
		printf("l_u8GPIOBit error l_u8GPIOBit = %d\n",l_u8GPIOBit);
		return -1;
	}

	if(NULL!=argv[3])
	{
		l_u8SetValue = atoi(argv[3]);
		if(0==l_u8SetValue)
		{
			l_eData = (GPIO_DATA_E)l_u8SetValue;
		}else if(1==l_u8SetValue)
		{
			l_eData = (GPIO_DATA_E)l_u8SetValue;
		}else
		{
			printf("l_u8SetValue error l_u8SetValue = %d\n",l_u8SetValue);
		}
	}
	
	if(3==argc)                                                       
	{/**read**/                                                                                                                                                      
	    printf("read GPIO%d Bit%d \n",l_u8GPIONum,l_u8GPIOBit);           
        /**set input**/                                               
        HstGpio_Set_Direction(l_eGpioGroup, l_eBit, GPIO_INPUT);                        
                                                                                          
	    /**read **/                                                                               
	    char l_s8bit_val = 0;                                                                     
	    HstGpio_Get_Value(l_eGpioGroup, l_eBit, &amp;l_s8bit_val);                                    
	                                                                                              
	    printf("read Data = %d \n",l_s8bit_val);                                                  
	                                                                                                
	  }else if(4==argc)                                                                             
	  {/**write**/                                                                                                                                                                            
	      printf("Write GPIO %d; Bit %d; Value %d\n",l_u8GPIONum,l_u8GPIOBit,l_u8SetValue);         
	                                                                                                
	      /***set IO output*/                                                                       
	      HstGpio_Set_Direction(l_eGpioGroup, l_eBit, GPIO_OUPUT);                                  
	                                                                                                
	      /**Write To IO**/ 
		  HstGpio_Set_Value(l_eGpioGroup,l_eBit,l_eData);
	  }else                                            
	  {                                                                                             
	                                                                                                
	  }

	return 0;

}

</code></pre> 
<p>    完整工程代码下载地址：<a href="https://download.csdn.net/download/li_wen01/10820670" title="Hi3520DV300 IO读写应用小程序">Hi3520DV300 IO读写应用小程序</a></p> 
<hr> 
<h2 id="%EF%BC%88%E5%85%AD%EF%BC%89%E8%B7%AF%E7%94%B1%E8%BF%BD%E8%B8%AA">（六）路由追踪</h2> 
<p>路由追踪用来查看网络路由状态，在linux设备中，可以使用traceroute 和tracepath 命令来跟踪路由。在我UbuntuPC端我使用tracepath跟踪我主机到百度的路由如下：</p> 
<pre class="has"><code class="language-cpp">biao@ubuntu:~$ 
biao@ubuntu:~$ 
biao@ubuntu:~$ tracepath www.baidu.com
 1?: [LOCALHOST]                                         pmtu 1500
 1:  192.168.20.254                                        1.425ms 
 1:  192.168.20.254                                        1.733ms 
 2:  10.10.10.254                                          1.997ms 
 3:  10.10.10.254                                          1.522ms pmtu 1492
 3:  100.64.0.1                                           10.884ms 
 4:  113.106.44.49                                         4.968ms asymm  5 
 5:  202.105.158.77                                        4.629ms 
 6:  113.96.4.42                                          11.837ms 
 7:  no reply
 8:  14.29.121.190                                         9.454ms 
 9:  no reply
10:  no reply
11:  no reply
12:  no reply
13:  no reply
14:  no reply
15:  no reply
^C
biao@ubuntu:~$ </code></pre> 
<p>在我一台使用移动物联网卡的设备上运行traceroute,它是4G卡拨号上网的，他的路由情况如下：</p> 
<pre class="has"><code class="language-cpp">~ # 
~ # 
~ # traceroute www.baidu.com
traceroute to www.baidu.com (111.13.100.92), 30 hops max, 38 byte packets
 1  *  192.168.16.17 (192.168.16.17)  177.186 ms  79.267 ms
 2  *  *  *
 3  117.132.190.74 (117.132.190.74)  68.455 ms  51.361 ms  59.812 ms
 4  *  *  *
 5  221.183.38.90 (221.183.38.90)  83.953 ms  87.263 ms  74.621 ms
 6  111.13.98.101 (111.13.98.101)  81.521 ms  111.13.98.93 (111.13.98.93)  77.664 ms  111.13.98.101 (111.13.98.101)  79.678 ms
 7  *  *  111.13.112.57 (111.13.112.57)  418.551 ms
 8  *  *  *
 9  *  *  *
10  *</code></pre> 
<h2 id="%EF%BC%88%E4%B8%83%EF%BC%89%E6%96%87%E4%BB%B6%E5%9B%BA%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">（七）文件固定位置插入数据</h2> 
<p>       在文件的固定位置插入固定的数据</p> 
<pre class="has"><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define BASIC_FILE_NAME		"./nandflash.bin"
#define UBOOT_FILE_NAME		"./u-boot.bin"
#define KERNEL_FILE_NAME	"./kernel.bin"
#define ROOTFS_FILE_NAME	"./rootfs.bin"
#define APP_FILE_NAME		"./app.bin"


#define UBOOT_POSITION		0x00
#define KERNEL_POSITION		0x100000
#define ROOTFS_POSITION		0x500000
#define APP_POSITION		0x2700000



int InsertData(FILE *pfBasic,FILE *psInsert,int s32Position)
{
	int l_S32Ret = 0;
	unsigned char l_arru8Temp[1024] = {0xff};
	
	fseek(pfBasic,s32Position,SEEK_SET);
	fseek(psInsert,0,SEEK_SET);
	while(1)
	{
		l_S32Ret = fread(l_arru8Temp,1,1024,psInsert);
		if(l_S32Ret &gt; 0)
		{
			l_S32Ret = fwrite(l_arru8Temp,1,l_S32Ret,pfBasic);
			if(l_S32Ret&lt;=0)
			{
				printf("line %d error l_S32Ret = %d \n",__LINE__,l_S32Ret);
				return -1;
			}
		}else
		{
			break;
		}
	}
	
	return 0;
}



int main(void)
{
	int l_s32Ret = 0;
	FILE *l_pfBasec = NULL;
	FILE *l_pfUboot = NULL;
	FILE *l_pfKernel = NULL;
	FILE *l_pfRootfs = NULL;
	FILE *l_pfApp = NULL;


	l_pfBasec = fopen(BASIC_FILE_NAME,"r+");
	if(NULL==l_pfBasec)
	{
		printf("line %d error \n",__LINE__);
		goto ERROR;
	}

	l_pfUboot = fopen(UBOOT_FILE_NAME,"r");
	if(NULL==l_pfUboot)
	{
		printf("line %d error \n",__LINE__);
		goto ERROR;
	}

	l_pfKernel = fopen(KERNEL_FILE_NAME,"r");
	if(NULL==l_pfKernel)
	{
		printf("line %d error \n",__LINE__);
		goto ERROR;
	}

	l_pfRootfs = fopen(ROOTFS_FILE_NAME,"r");
	if(NULL==l_pfRootfs)
	{
		printf("line %d error \n",__LINE__);
		goto ERROR;
	}

	l_pfApp = fopen(APP_FILE_NAME,"r");
	if(NULL==l_pfApp)
	{
		printf("line %d error \n",__LINE__);
		goto ERROR;
	}

	if(0&gt; InsertData(l_pfBasec,l_pfUboot,UBOOT_POSITION))
	{
		printf("line %d error \n",__LINE__);
		goto ERROR;
	}

	if(0&gt; InsertData(l_pfBasec,l_pfKernel,KERNEL_POSITION))
	{
		printf("line %d error \n",__LINE__);
		goto ERROR;
	}

	if(0&gt; InsertData(l_pfBasec,l_pfRootfs,ROOTFS_POSITION))
	{
		printf("line %d error \n",__LINE__);
		goto ERROR;
	}

	if(0&gt; InsertData(l_pfBasec,l_pfApp,APP_POSITION))
	{
		printf("line %d error \n",__LINE__);
		goto ERROR;
	}


ERROR:
	if(NULL!=l_pfBasec)
	{
		fclose(l_pfBasec);
		l_pfBasec = NULL;
	}

	if(NULL!=l_pfUboot)
	{
		fclose(l_pfUboot);
		l_pfUboot = NULL;
	}
	
	if(NULL!=l_pfKernel)
	{
		fclose(l_pfKernel);
		l_pfKernel = NULL;
	}
	
	
	if(NULL!=l_pfRootfs)
	{
		fclose(l_pfRootfs);
		l_pfRootfs = NULL;
	}
	
	if(NULL!=l_pfApp)
	{
		fclose(l_pfApp);
		l_pfApp = NULL;
	}
	
	return 0;

}
</code></pre> 
<h2 id="%EF%BC%88%E4%B8%83%EF%BC%89H264%20I%E5%B8%A7%E4%B8%8EP%E5%B8%A7%E5%81%8F%E7%A7%BB">（七）H264 I帧与P帧偏移</h2> 
<p>    在H264存储的时候，P帧比I帧存储得快了14帧，需要将所有的P帧往后移动14帧。</p> 
<pre class="has"><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;errno.h&gt; 

/************************************************* 
Function:    FindStartCode3  
Description: 判断是否为0x00000001,如果是返回1     
Return: 
Others:
Author: licaibiao
Date:   2017-12-06
*************************************************/
static int FindStartCode3 (unsigned char *Buf)  
{  
	if(Buf[0]!=0 || Buf[1]!=0 || Buf[2] !=0 || Buf[3] !=1) 
	{
		return 0;
	}
	else
	{
		return 1;  
	}	
} 

int read_data(FILE *p_fd,unsigned char* pBuf,int* ps32Len)
{
	int l_s32Pos = 0;
	int l_s32Rewind = -4;
	int l_s32NaluLen = 0;
	unsigned char l_u8FindFlag = 0;
	unsigned char *l_pBuf = NULL;
	l_pBuf = (unsigned char*)malloc (1024*1024*10);
	
	/**从码流中读取4个字节**/
	if (4 != fread (l_pBuf, 1, 4, p_fd))
	{  
		free(l_pBuf);  
		return -1;  
	} 
	
	/**判断是否是00 00 00 01**/
	if(FindStartCode3(l_pBuf))
	{
		l_u8FindFlag = 1;
		l_s32Pos = 4;
	}
	else
	{
		l_u8FindFlag = 0;
		printf("【[%s:%d] start code error  \n", __func__, __LINE__);
		return -1;
	}
	
	/**查找下一个开始字符标志位**/
	l_u8FindFlag = 0;
	while(!l_u8FindFlag)
	{
		/**判断是否到了文件尾**/
		if(feof(p_fd))
		{
			l_s32NaluLen = l_s32Pos - 1;
			memcpy (pBuf, l_pBuf, l_s32NaluLen);
			free(pBuf);
			pBuf = NULL;
			*ps32Len = l_s32NaluLen;
			return -2;
		}
		/**读取一个字节到pBuf 中**/
		l_pBuf[l_s32Pos++] = fgetc(p_fd);
		if(FindStartCode3(&amp;l_pBuf[l_s32Pos-4]))
		{
			l_u8FindFlag = 1;
		}
	}
	
		/**把文件指针指向前一个NALU的末尾 **/
	if (0 != fseek (p_fd, l_s32Rewind, SEEK_CUR))
	{  
		free(l_pBuf);  
		printf("【[%s:%d] GetAnnexbNALU: Cannot fseek in the bit stream file  \n", __func__, __LINE__);
	} 

	l_s32NaluLen = l_s32Pos + l_s32Rewind;
	memcpy(pBuf,l_pBuf,l_s32NaluLen);
	*ps32Len = l_s32NaluLen;
	
	return 0;
}

int main()
{
	unsigned char *l_pBuf = NULL;
	unsigned char *l_pTemp = NULL;
	unsigned char *l_pIFrame = NULL;
	unsigned char *l_pPFrame = NULL;
	unsigned char* l_IPack[30];
	unsigned char* l_PPack[30];
	unsigned int l_ILen[33] = {0};
	unsigned int l_PLen[33] = {0};
	unsigned int i =0;
	unsigned int j =0;
	unsigned int p =0;
	unsigned int l_s32ILen = 0;
	unsigned int l_s32PLen = 0;
	unsigned int l_d = 0;
	int l_s32Ret = 0;
	int l_s32Len = 0;
	
	FILE *l_fpInput = NULL;
	FILE *l_fpOutput = NULL;

    printf("biao debug %d \n",__LINE__);
	l_fpInput = fopen("./001.264","rb");
	if(NULL==l_fpInput)
	{
		printf("open error \n");
		return -1;
	}
	
	l_fpOutput = fopen("./002.h264","w+");
	if(NULL==l_fpOutput)
	{
		printf("open error \n");
		return -1;
	}
	printf("biao debug %d \n",__LINE__);
	l_pBuf = (unsigned char*)malloc (1024*1024*1);
	l_pTemp = (unsigned char*)malloc (1024*1024*1);
	l_pIFrame = (unsigned char*)malloc (1024*1024*1);
	l_pPFrame = (unsigned char*)malloc (1024*1024*1);
	
	for(i=0;i&lt;33;i++)
	{
		l_IPack[i] = (unsigned char*)malloc (500*1024);
		l_PPack[i] = (unsigned char*)malloc (500*1024);	
	}
	i = 0;

	p = 14;
	while(1)
	{
		l_s32Ret = read_data(l_fpInput,l_pBuf,&amp;l_s32Len);
		if(0==l_s32Ret)
		{			
			if(0x61!=l_pBuf[4]) /**I**/
			{
				memcpy(&amp;l_pIFrame[l_s32ILen],l_pBuf,l_s32Len);
				l_s32ILen +=l_s32Len;
				if(0x65==l_pBuf[4])
				{
					printf("write I %d\n",i);
					memcpy(l_IPack[i],l_pIFrame,l_s32ILen);
					l_ILen[i] = l_s32ILen;
					i++;
					l_s32ILen = 0;
				}
			}

			if(0x61==l_pBuf[4]) /**P**/
			{
				memcpy(&amp;l_pPFrame[l_s32PLen],l_pBuf,l_s32Len);
				l_s32PLen +=l_s32Len;
				p++;
				if(0==(p%44))
				{
					printf("write P %d frame=%d l_s32PLen = %d\n",j,p,l_s32PLen);
					memcpy(l_PPack[j],l_pPFrame,l_s32PLen);
					l_PLen[j] = l_s32PLen;
					j++;
					l_s32PLen = 0;
				}
			}
			
		}else
		{
			break;
		}
	}
	
	for(i=0;i&lt;j;i++)
	{
		fwrite(l_IPack[i+3],1,l_ILen[i+3],l_fpOutput);
		fwrite(l_PPack[i],1,l_PLen[i],l_fpOutput);	
	}
	fclose(l_fpInput);
	fclose(l_fpOutput);

	free(l_pBuf);
	free(l_pTemp);
	free(l_pIFrame);
	free(l_pPFrame);
	for(i=0;i&lt;33;i++)
	{
		free(l_IPack[i]);
		free(l_PPack[i]);
	}
	return 0;
}

</code></pre> 
<h2 id="%EF%BC%88%E5%85%AB%EF%BC%89%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0IP%E5%9C%B0%E5%9D%80">（八）获取本地IP地址</h2> 
<p>    在linux设备中获取本地IP地址可以使用下面的程序，支持最大主机有三个网口的设备，当然这个网卡数可以修改。</p> 
<pre class="has"><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;ifaddrs.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;string.h&gt;
#include &lt;arpa/inet.h&gt;

int get_local_ip(char *ps8IpList)
{
    struct ifaddrs *ifAddrStruct;
    char l_s8IpAddr[INET_ADDRSTRLEN];
    void *tmpAddrPtr;
    int l_s32IPCount = 0;
    
    getifaddrs(&amp;ifAddrStruct);
    while (ifAddrStruct != NULL) 
    {
        if (ifAddrStruct-&gt;ifa_addr-&gt;sa_family==AF_INET)
        {
            tmpAddrPtr=&amp;((struct sockaddr_in *)ifAddrStruct-&gt;ifa_addr)-&gt;sin_addr;
            inet_ntop(AF_INET, tmpAddrPtr, l_s8IpAddr, INET_ADDRSTRLEN);
            if (strcmp(l_s8IpAddr, "127.0.0.1") != 0) 
            {
                if(l_s32IPCount == 0)
                {
                        memcpy(ps8IpList, l_s8IpAddr, INET_ADDRSTRLEN);
                } else 
                {
                        memcpy(ps8IpList+INET_ADDRSTRLEN, l_s8IpAddr, INET_ADDRSTRLEN);
                }
                l_s32IPCount++;
            }
        }
        ifAddrStruct=ifAddrStruct-&gt;ifa_next;
    }

    freeifaddrs(ifAddrStruct);
    return l_s32IPCount;
}

int main()
{
    char l_arrs8IpAddrList[3][INET_ADDRSTRLEN];
    int l_s32AddrCount;
    
    memset(l_arrs8IpAddrList, 0, sizeof(l_arrs8IpAddrList));

    l_s32AddrCount = get_local_ip(*l_arrs8IpAddrList);

    for(l_s32AddrCount;l_s32AddrCount&gt;0;l_s32AddrCount--)
    {
        printf("Server Local IP%d: %s\n",l_s32AddrCount,l_arrs8IpAddrList[l_s32AddrCount-1]);
    }
	
	return 0;
}</code></pre> 
<p></p> 
<p style="text-align:center;">------------------------------------------2022.08.28日更新------------------------------------------</p> 
<p style="text-align:center;">该博客将停止更新 </p> 
<p style="text-align:center;">新的文章内容和附件工程文件更新到了</p> 
<p style="text-align:center;">Gong众号 :<strong> liwen01</strong></p> 
<p style="text-align:center;">-----------------------------------------------2022.08.28-----------------------------------------------</p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72615ef893eea8c334955a4e814ccd66/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">泛型知识点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4d5c3988d83af9e7e171dae6347d2655/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c&#43;&#43; 单源最短路径-狄杰斯特拉算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>