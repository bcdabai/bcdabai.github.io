<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>S25FL256S介绍及FPGA实现思路 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="S25FL256S介绍及FPGA实现思路" />
<meta property="og:description" content="本文介绍 S25FL256S 这款 FLASH 芯片，并进行 FPGA 读写控制的实现（编程思路及注意事项）。
文章目录 S25FL-S 介绍管脚功能说明SPI 时钟模式SDRDDR 工作模式FLASH存储阵列（地址空间映射）常用寄存器及相关指令Status Register 1 (SR1)Status Register 2 (SR2)Configuration Register 1 (CR1)Autoboot Register (ABR)Bank Address Register (BAR) 关于部分常用命令的解释写使能命令（WREN 06h）写寄存器命令（WRR 01h）Autoboot读 flash 命令写 flash 命令flash 擦除命令 FPGA 实现（思路） S25FL-S 介绍 管脚功能说明 RESET#，input，硬件复位信号；CS#，input，片选信号；SCK，input，串行时钟；SI/IO0，inout，在 single mode 下的串行输入，在 Dual/Quad mode 下的 IO0；SO/IO1，inout，在 single mode 下的串行输出，在 Dual/Quad mode 下的 IO1；WP#/IO2，inout，在 single/Dual mode 下的写入保护，Quad mode 下的 IO2。在该管脚作为写入保护管脚时，当 WP# 为LOW时，在 WRR 命令期间，如果状态寄存器的状态寄存器写禁用（SRWD）位被设置为 1 时，将无法写入状态和配置寄存器，这可以防止状态寄存器的块保护（BP2、BP1、BP0）和 TBPROT 位的任何更改。同时，如果在 WRR 命令期间 WP# 为低电平，内存区域中受块保护和 TBPROT 位保护的所有数据字节也将被硬件保护，防止数据修改。WP# 芯片内部存在上拉电阻。HOLD#/IO3，inout，在 single/Dual mode 下的保持/暂停传输控制信号，Quad mode 下的 IO3。HOLD# 信号可用于暂停与设备的任何串行通信，而无需取消片选（CS#）或停止串行时钟（SCK），在 HOLD# 拉低后，若 SCK 处于 LOW，则立即进入保持状态，否则会在 SCK 的下降沿到达时进入保持状态，如下图。需注意，HOLD 不会终止已经在执行的操作。HOLD# 芯片内部存在上拉电阻。 在 SDR 情况下，FLASH 会在 SCK 上升沿寄存数据，并在 SCK 下降沿转换输出数据；在 DDR 模式下将在 SCK 的每个边沿进行数据转换。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/55f70436924aa95edfb9aea5e48de726/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-16T15:39:57+08:00" />
<meta property="article:modified_time" content="2023-11-16T15:39:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">S25FL256S介绍及FPGA实现思路</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>  本文介绍 S25FL256S 这款 FLASH 芯片，并进行 FPGA 读写控制的实现（编程思路及注意事项）。</p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#S25FLS__3" rel="nofollow">S25FL-S 介绍</a></li><li><ul><li><a href="#_8" rel="nofollow">管脚功能说明</a></li><li><a href="#SPI__25" rel="nofollow">SPI 时钟模式</a></li><li><ul><li><a href="#SDR_32" rel="nofollow">SDR</a></li><li><a href="#DDR_39" rel="nofollow">DDR</a></li></ul> 
   </li><li><a href="#_46" rel="nofollow">工作模式</a></li><li><a href="#FLASH_82" rel="nofollow">FLASH存储阵列（地址空间映射）</a></li><li><a href="#_93" rel="nofollow">常用寄存器及相关指令</a></li><li><ul><li><a href="#Status_Register_1_SR1_100" rel="nofollow">Status Register 1 (SR1)</a></li><li><a href="#Status_Register_2_SR2_114" rel="nofollow">Status Register 2 (SR2)</a></li><li><a href="#Configuration_Register_1_CR1_124" rel="nofollow">Configuration Register 1 (CR1)</a></li><li><a href="#Autoboot_Register_ABR_144" rel="nofollow">Autoboot Register (ABR)</a></li><li><a href="#Bank_Address_Register_BAR_156" rel="nofollow">Bank Address Register (BAR)</a></li></ul> 
   </li><li><a href="#_169" rel="nofollow">关于部分常用命令的解释</a></li><li><ul><li><a href="#WREN_06h_171" rel="nofollow">写使能命令（WREN 06h）</a></li><li><a href="#WRR_01h_178" rel="nofollow">写寄存器命令（WRR 01h）</a></li><li><a href="#Autoboot_185" rel="nofollow">Autoboot</a></li><li><a href="#_flash__198" rel="nofollow">读 flash 命令</a></li><li><a href="#_flash__236" rel="nofollow">写 flash 命令</a></li><li><a href="#flash__262" rel="nofollow">flash 擦除命令</a></li></ul> 
  </li></ul> 
  </li><li><a href="#FPGA__278" rel="nofollow">FPGA 实现（思路）</a></li></ul> 
</div> 
<p></p> 
<h2><a id="S25FLS__3"></a>S25FL-S 介绍</h2> 
<p><img src="https://images2.imgbox.com/02/99/SGJMGu1A_o.jpg" alt="在这里插入图片描述" width="400" height="250"></p> 
<h3><a id="_8"></a>管脚功能说明</h3> 
<ul><li>RESET#，input，硬件复位信号；</li><li>CS#，input，片选信号；</li><li>SCK，input，串行时钟；</li><li>SI/IO0，inout，在 single mode 下的串行输入，在 Dual/Quad mode 下的 IO0；</li><li>SO/IO1，inout，在 single mode 下的串行输出，在 Dual/Quad mode 下的 IO1；</li><li>WP#/IO2，inout，在 single/Dual mode 下的写入保护，Quad mode 下的 IO2。在该管脚作为写入保护管脚时，当 WP# 为LOW时，在 WRR 命令期间，如果状态寄存器的状态寄存器写禁用（SRWD）位被设置为 1 时，将无法写入状态和配置寄存器，这可以防止状态寄存器的块保护（BP2、BP1、BP0）和 TBPROT 位的任何更改。同时，如果在 WRR 命令期间 WP# 为低电平，内存区域中受块保护和 TBPROT 位保护的所有数据字节也将被硬件保护，防止数据修改。WP# 芯片内部<strong>存在上拉电阻</strong>。</li><li>HOLD#/IO3，inout，在 single/Dual mode 下的保持/暂停传输控制信号，Quad mode 下的 IO3。HOLD# 信号可用于暂停与设备的任何串行通信，而无需取消片选（CS#）或停止串行时钟（SCK），在 HOLD# 拉低后，若 SCK 处于 LOW，则立即进入保持状态，否则会在 SCK 的下降沿到达时进入保持状态，如下图。需注意，HOLD 不会终止已经在执行的操作。HOLD# 芯片内部<strong>存在上拉电阻</strong>。</li></ul> 
<p><img src="https://images2.imgbox.com/0b/5d/UOCkyZ6V_o.jpg" alt="在这里插入图片描述" width="800" height="200"></p> 
<p>  在 SDR 情况下，FLASH 会在 SCK <strong>上升沿寄存数据</strong>，并在 SCK <strong>下降沿转换输出数据</strong>；在 DDR 模式下将在 SCK 的每个边沿进行数据转换。</p> 
<p>  在 <strong>single mode</strong>（也即传统的 SPI 协议）下，通过 SI 进行数据写入，通过 SO 进行数据读取；在 <strong>Dual/Quad Output mode</strong> 下，通过 SI 进行指令和地址的写入，而分别通过 IO0/IO1、IO0/IO/IO2/IO3 进行数据读回；而在 <strong>Dual/Quad Input/Output mode</strong> 下，通过 SI 传输指令，分别通过 IO0/IO1、IO0/IO1/IO2/IO3 进行地址写入（及可能存在的模式写入）和数据读回。</p> 
<h3><a id="SPI__25"></a>SPI 时钟模式</h3> 
<p>  S25FL256S 支持两种模式的 SPI 时钟：</p> 
<ul><li>mode 0，时钟极性 CPOL=0，时钟相位 CPHA=0；</li><li>mode 3，时钟极性 CPOL=1，时钟相位 CPHA=1；</li></ul> 
<h4><a id="SDR_32"></a>SDR</h4> 
<p>  在 SDR 模式，两种时钟模式下，芯片都是在 SCK 上升沿锁存数据，在 SCK 下降沿转换数据。两种模式的不同之处在于空闲状态下 SCK 的状态，如下图所示</p> 
<p><img src="https://images2.imgbox.com/84/84/Wx7nllpv_o.jpg" alt="在这里插入图片描述" width="600" height="150"></p> 
<h4><a id="DDR_39"></a>DDR</h4> 
<p>  DDR 模式也支持以上两种时钟模式。指令位总是锁定在时钟的上升边缘，与 SDR 模式中相同。而地址和输入输出数据都被锁定在 SCK 的上升和下降边缘上。如下图</p> 
<p><img src="https://images2.imgbox.com/f3/fc/MqqLJiEp_o.jpg" alt="在这里插入图片描述" width="800" height="230"></p> 
<h3><a id="_46"></a>工作模式</h3> 
<p>  在 single mode 模式以及 Dual/Quad Output Commands 模式下，命令和地址在 SI 线上单比特传输，而数据分别从 SO、IO0/IO1、IO0/IO1/IO2/IO3 传输；在 Dual/Quad I/O Commands 模式下，命令在 SI 上传输，而地址和数据都以数据对的形式在 IO0/IO1、IO0/IO1/IO2/IO3 上传输。时序分别如下图</p> 
<ul><li><strong>Single Bit Wide Commands</strong></li></ul> 
<p><img src="https://images2.imgbox.com/79/b5/pB4OZg42_o.jpg" alt="在这里插入图片描述" width="700" height="550"></p> 
<ul><li><strong>Single Bit Wide I/O Commands</strong></li></ul> 
<p><img src="https://images2.imgbox.com/96/52/YAK7ksSE_o.jpg" alt="在这里插入图片描述" width="700" height="350"></p> 
<ul><li><strong>Dual/Quad Output Commands</strong></li></ul> 
<p><img src="https://images2.imgbox.com/a8/80/KPcOPW7G_o.jpg" alt="在这里插入图片描述" width="700" height="400"></p> 
<ul><li><strong>Dual/Quad I/O Commands</strong></li></ul> 
<p><img src="https://images2.imgbox.com/44/60/GWBSHuR2_o.jpg" alt="在这里插入图片描述" width="700" height="400"></p> 
<ul><li><strong>DDR Single Commands</strong></li></ul> 
<p><img src="https://images2.imgbox.com/a4/70/y4TMlj3o_o.jpg" alt="在这里插入图片描述" width="700" height="170"></p> 
<ul><li><strong>DDR Dual/Quad I/O Commands</strong></li></ul> 
<p><img src="https://images2.imgbox.com/1a/b9/VwOulJ3V_o.jpg" alt="在这里插入图片描述" width="700" height="400"></p> 
<p>  在图中读数据时序中的 Dummy 阶段，S25FL256S 不会对 I/O 进行响应，期间 FLASH 正在准备数据，Dummy 延迟的长度由配置寄存器的 CR[7:6] 决定。Dummy 期间，应当保持 CS#=L、RESET#=H、HOLD#/IO3=H，WP#/IO2 被忽略。由于 HOLD、WP 内部都具有上拉电阻，因此<strong>建议在 Dummy 期间主控端释放 IO0~IO3</strong>，以避免可能出现的驱动器冲突。</p> 
<h3><a id="FLASH_82"></a>FLASH存储阵列（地址空间映射）</h3> 
<p>  S25FL 系列的 FALSH 存储阵列被划分为被称为**扇区（Sector）**的擦除单元。这些 Sector 要么是 4kB 和 64kB 扇区的组合，要么是统一的 256kB 扇区，与 FLASH 型号有关。对于笔者使用的 S25FL256SAGNFI00，关于其 Sector Type 的描述为 ‘A hybrid of 32 x 4-KB sectors with all remaining sectors being 64 KB, with a 256B programming buffer’，因此是如下的结构</p> 
<p><img src="https://images2.imgbox.com/a3/15/v7ysyr5N_o.jpg" alt="在这里插入图片描述" width="700" height="400"></p> 
<p>对于 FL-S 系列具有 64KB Sector 的 128Mb/256Mb 芯片，针对 4KB Sector 区域，可以使用支持一次清除 4KB 的擦除命令，<strong>也可以使用 64KB 的擦除命令来一次性擦除 16 个 4KB 扇区</strong>。</p> 
<p>  FL-S 128Mb 和 256Mb 具有混合扇区架构的 FLASH，其 4KB 扇区在初次交付时位于阵列地址的底部。然而，<strong>配置寄存器的 TBPARM 位 （Configuration Register 1 - bit2，CR1[2] ）可以被编程以反转扇区映射</strong>，以将 4-KB 扇区放置在阵列地址映射的顶部。<strong>因此用户必须检查 TBPARM 位，以确定扇区是否被倒置</strong>。</p> 
<h3><a id="_93"></a>常用寄存器及相关指令</h3> 
<p><img src="https://images2.imgbox.com/37/6d/jDLgL8AY_o.jpg" alt="在这里插入图片描述" width="700" height="350"></p> 
<p>  寄存器状态有易失性（Volatile）、非易失性（Non-Volatile）、一次性可编程（OTP，One Time Programmable）等，其中非易失性和 OTP 类型的寄存器初始值与出厂时的配置有关，非易失性寄存器的持久性与 FLASH 存储阵列的相同。</p> 
<h4><a id="Status_Register_1_SR1_100"></a>Status Register 1 (SR1)</h4> 
<p>  SR1 寄存器相关指令：读 SR1 指令（RDSR1 05h）、写寄存器指令（WRR 01h）、写使能 （WREN 06h）、写失能（WRDI 04h）、清空状态寄存器（CLSR 30h）。</p> 
<p><img src="https://images2.imgbox.com/d7/a9/VpiamN3A_o.jpg" alt="在这里插入图片描述" width="700" height="400"></p> 
<ul><li>SR1[7]，SR1 寄存器写失能，非易失性，为 1 时启用 WP# 的写保护功能。当 SRWD=1 且 WP#=H ，或 SRWD=0 时，SRWD 和 BP 位可以被 WRR 命令改变；</li><li>SR1[6]，指示编程是否发生错误，易失性，只读，可使用 CLSR 重新置零；</li><li>SR1[5]，指示擦除是否发生错误，易失性，只读，可使用 CLSR 重新置零；</li><li>SR1[4:2]，块保护。当 CR1[3] 为 0 时，BP[2:0] 为非易失性，出厂时默认值被设为 0；当 CR1[3] 为 1 时，为易失性，且默认值为 1；</li><li>SR1[1]，SR1 写使能，易失性，为 1 时可以进行写寄存器操作（WRR）、flash 编程和擦除操作。该位只会由 WREN、WRDI 命令影响，不会被 WRR 写入。<strong>由于默认值为 0，因此如果要写寄存器（WRR）、编程/擦除 flash，需要先执行 WREN 命令，随后才能执行对应命令</strong>；</li><li>SR[0]，指示设备是否忙碌，只读，1 表示设备忙，0 表示空闲。</li></ul> 
<h4><a id="Status_Register_2_SR2_114"></a>Status Register 2 (SR2)</h4> 
<p>  SR2 相关指令：读 SR2 指令（RDSR2 07h）。</p> 
<p><img src="https://images2.imgbox.com/f2/b0/hJDz7aVl_o.jpg" alt="在这里插入图片描述" width="700" height="250"></p> 
<ul><li>SR2[1]，擦除挂起，只读；</li><li>SR2[0]，编程挂起，只读。</li></ul> 
<h4><a id="Configuration_Register_1_CR1_124"></a>Configuration Register 1 (CR1)</h4> 
<p>  CR1 相关指令：读 CR1 指令（RDCR 35h）、写寄存器指令（WRR 01h）。在 16 数据周期的 WRR 命令中，可以对 CR1 进行写入操作。<strong>注意到 WRR 命令对应了多个寄存器的写入，如何控制 WRR 写入不同寄存器见本文下一小节。</strong></p> 
<p><img src="https://images2.imgbox.com/5a/ee/lGtXHDPQ_o.jpg" alt="在这里插入图片描述" width="700" height="370"></p> 
<ul><li> <p>CR1[7:6]，控制延迟周期的 mode 和 Dummy 的长度，在不同时钟模式（SDR/DDR）和芯片型号（高性能 HPLC、增强高性能 EHPLC）下不尽相同，详见官方手册；</p> </li><li> <p>CR1[5]，块保护配置起始。SR1 的 BP[2:0] 位允许用户可选择地保护阵列的一部分，范围从1/64、1/4、1/2等，一直到整个阵列，当TBPROT 被设置为 0 时，块保护被定义为从数组的顶部（最大地址）开始。<strong>出厂时 TBPORT 被配置为 0，如果被配置为 1 后，再尝试将它修改回 0 将会失败，并置位 R_ERR（SR1[6]），下面几个 OTP 的也是</strong>；</p> </li><li> <p>CR1[3]，配置 SR1[4:2]（BP[2:0]）是否为易失性；</p> </li><li> <p>CR1[2]，配置 Sector 地址是否倒置。<strong>由于 CR1[5:2] 都是 OTP 的，因此用户务必要检查这几个位</strong>；</p> </li><li> <p>CR1[1]，非易失性，1 配置设备到 Quad 模式，0 则为 Dual 或 Single 模式。在配置到 1 时，WP# 与 HOLD# 功能不被监控，并在内部置为 HIGH，这两个引脚被用作 IO2、IO3。<strong>要使用 Quad Output Read、Quad I/O Read、Quad Page Programming 等四元功能时必须置位 Quad bit</strong>，而 Dual、Single 的操作不受影响，只是不需要驱动 WP# 和 HOLD# 了；</p> </li><li> <p>CR1[0]，是否启用块保护以及 OTP 锁定。Freeze 位默认为 0，当 Freeze 位置为 1 时，将锁定状态寄存器中的 BP[2:0] 位、配置寄存器中的 TBPROT 和 TBPARM 位以及 OTP 地址空间（S25FL-S 具有独立的 1024 Byte 的 OTP 空间，被分为 32 个 32Byte 的Sector）。<strong>一旦 Freeze 位被置为 1，就只能通过断电重启或硬件复位重新置 0，而通过 WRR 或软复位重新置为 0 的尝试都会失败</strong>。</p> </li></ul> 
<p>  关于 BP 位、TBPROT 位设置下的保护范围见下表</p> 
<p><img src="https://images2.imgbox.com/bd/e5/xabWc2sX_o.jpg" alt="在这里插入图片描述" width="700" height="500"></p> 
<h4><a id="Autoboot_Register_ABR_144"></a>Autoboot Register (ABR)</h4> 
<p>  ABRD 相关指令：AutoBoot Read（ABRD 14h） 、 AutoBoot Write（ABWR 15h）。Autoboot 寄存器提供了一种自动读取启动代码的方法，作为开机重置、硬件重置或软件重置过程的一部分。</p> 
<p><img src="https://images2.imgbox.com/47/37/1Zufdx3i_o.jpg" alt="在这里插入图片描述" width="700" height="180"></p> 
<ul><li> <p>ABR[31:9]，为启动引导代码的起始地址。<strong>ABSA 为 512 字节对齐地址</strong>，23bit 地址支持最大 32Gbit 地址空间的寻址，对于 256Mb 设备而言，只会用到 0<sub>65535dec（0h</sub>00FFFFh）；</p> </li><li> <p>ABR[8:1]，启动代码延迟；</p> </li><li> <p>ABR[0]，Autoboot 使能。</p> </li></ul> 
<h4><a id="Bank_Address_Register_BAR_156"></a>Bank Address Register (BAR)</h4> 
<p>  BRAC 相关指令：访问块地址寄存器（BRAC B9h）、块地址寄存器读（BRRD 16h）、块地址寄存器写 （BRWR 17h）。</p> 
<p>  该寄存器用于扩展高位地址，以实现对 3Byte 命令的兼容。对于 128Mb 以下的设备，只需要 24 位地址就可以访问（字节地址），而对于 256Mb 以上容量的设备，就需要第四字节来提供对更高地址的访问。对于遗留的 3 字节命令，需要该寄存器提供额外的高位地址。</p> 
<p><img src="https://images2.imgbox.com/69/51/6HoWZJhl_o.jpg" alt="在这里插入图片描述" width="700" height="140"></p> 
<ul><li> <p>BAR[7]，EXTADD，易失性，默认值 0。<strong>当为 1 时，所有 3Byte 遗留指令也同新版指令一样采用 32bit 寻址</strong>，本寄存器的 BRAC[6:0] 不被使用；当为 0 时，遗留指令采用传统的 24bit 寻址，而由 BRA[6:0] 提供对高位地址的补充（由于当前只有最大 256Mb 的设备，所以只用到了 BRA[0]）。<strong>所以还是建议 256Mb 以上的设备直接采用新版的采用 32bit 寻址的命令，方便好多</strong>；</p> </li><li> <p>BAR[0]，高位地址补充。</p> </li></ul> 
<h3><a id="_169"></a>关于部分常用命令的解释</h3> 
<h4><a id="WREN_06h_171"></a>写使能命令（WREN 06h）</h4> 
<p>  任何编程非易失性存储空间的指令执行前都要先执行 WREN 命令，该命令会置位 WEL（SR1[1]）位。在上电、硬复位、相关编程命令执行完成后，WEL 都会重新复位为 0：</p> 
<p><img src="https://images2.imgbox.com/f5/2f/Fl8FrckZ_o.jpg" alt="在这里插入图片描述" width="250" height="180"></p> 
<h4><a id="WRR_01h_178"></a>写寄存器命令（WRR 01h）</h4> 
<p>  WRR 命令可以写 SR1 和 CR1 寄存器，有 8 数据周期、16 数据周期两种，如果 CS# 在第 8 个数据周期后拉高，则只会写 SR1，而如果在 16 数据周期后再拉高 CS#，则会在 CS# 拉高后同时写入 SR1 和 CR1。</p> 
<p><img src="https://images2.imgbox.com/a3/b2/u0I6zzz7_o.jpg" alt="在这里插入图片描述" width="700" height="500"></p> 
<h4><a id="Autoboot_185"></a>Autoboot</h4> 
<p>  自动引导功能允许主机内存控制器在复位结束后立即从 S25FL-S 设备获取引导代码，而无需发送读取命令，这节省了 32 个或更多的周期，并简化了启动引导代码读取所需的逻辑。ABE bit（ABR[0]）控制 Autoboot 功能是否启用。</p> 
<p>  在上电、硬复位、命令复位（RESET F0h）后，Autoboot 功能将从预定地址（ABSA, ABR[31:9]）自动读取引导程序，主控制器只需要将 CS# 拉低并给入 SCK，则 S25FL-S 设备将在延迟指定周期（ABSD, ABR[8:1]）后输出代码流，在 CS# 拉高前将持续移出高位数据。需要注意，如果 ABSD=0，则 SCK 最大支持 50MHz。</p> 
<p>  在 Autoboot 输出至少一个字节数据后任意时刻拉高 CS#，设备将回到标准 SPI 模式，可以接收并响应各种指令。</p> 
<p>  根据 QUAD bit（CR1[1]）的配置情况，将分别在 SI 或 IO0~IO3 上传回数据。</p> 
<p><img src="https://images2.imgbox.com/20/bb/Z81QZgqN_o.jpg" alt="在这里插入图片描述" width="700" height="550"></p> 
<h4><a id="_flash__198"></a>读 flash 命令</h4> 
<p>  关于 main flash memory 的一系列读取命令，可以从任意字节地址开始读取，<strong>只要 CS# 没有拉高，flash 会将地址自动加一，顺序输出下一字节数据</strong>。如果在顺序读取过程中地址达到了最大，那么下一个数据地址将为 0。</p> 
<p>  READ 命令和 FAST_READ 命令的时序都是一样的，只是支持的最大时钟不同，前者最大支持 50M，后者可支持最大 133MHz，时序如下</p> 
<p><img src="https://images2.imgbox.com/97/88/8RR9GmGK_o.jpg" alt="在这里插入图片描述" width="700" height="230"></p> 
<p>  对于 Quad Output Read，时序如下，地址也是在 SI 上顺序给出，而数据在 IO0~IO3 上返回；Dual Output 类似，只不过数据只从 IO0~IO1 上返回，这两种指令都不存在 mode 位</p> 
<p><img src="https://images2.imgbox.com/e9/fc/R3QTZfbz_o.jpg" alt="在这里插入图片描述" width="700" height="200"></p> 
<p>  对于 Dual I/O Read，地址和数据都在 IO0~IO1 上传输，根据芯片型号（HPLC or EHPLC）而决定有无 mode 字段</p> 
<p><img src="https://images2.imgbox.com/d9/63/DnPN9LqB_o.jpg" alt="在这里插入图片描述" width="700" height="350"></p> 
<p>在存在模式位时，如果模式位为 Axh，则设备将保持在 Dual I/O 模式，在下一次 CS# 拉高再拉低后，可以直接从地址开始，而忽略命令字段，如下图</p> 
<p><img src="https://images2.imgbox.com/6a/e0/WekViSTG_o.jpg" alt="在这里插入图片描述" width="700" height="180"></p> 
<p>而如果模式位为 Axh 以外的任何值，设备都将在 CS# 拉高后回到传统的 SPI 模式下。</p> 
<p>  对于 Quad I/O Read 模式，地址和数据都在 IO0~IO3 上传输，具有 mode 字段</p> 
<p><img src="https://images2.imgbox.com/ff/29/joM1bbrZ_o.jpg" alt="在这里插入图片描述" width="700" height="250"></p> 
<p>若 mode 字段为 Axh，则会在 CS# 拉高后保持在 Quad I/O 模式，可在下一个 CS# 下降沿后直接从地址字段开始</p> 
<p><img src="https://images2.imgbox.com/9d/e1/Xq0rhM3Q_o.jpg" alt="在这里插入图片描述" width="700" height="250"></p> 
<p>如果模式位为 Axh 以外的任何值，设备将在 CS# 拉高后回到传统的 SPI 模式下。</p> 
<h4><a id="_flash__236"></a>写 flash 命令</h4> 
<p>  在执行写命令前必须<strong>先执行写使能命令 WREN</strong>，随后可以通过写 flash 命令写入 1~256/512 Byte 数据（具体最大数目以具体型号的 Page Size 确定），有 Page Programming（PP）、Singl Byte Programming 两类写指令。flash 存储空间的默认值为 1，通过写 flash 可以修改到 0 或保持为 1；<strong>如果 flash 中的数据已经被写入了 0，那么要修改回 1 必须通过擦除命令实现</strong>。</p> 
<p>  对于 Page Programming，Page 在 Page 大小边界对齐，建议每次编程 16 Byte 的倍数个数据，且与 Page Size 对齐。Single Byte Programming 允许在任意字节地址写入单个字节数据（没有单独的 Single Byte Programming 命令，PP 命令可以在任意字节地址开始编程，因此兼容了 Single Byte Programming）。为了获取最优性能，建议 PP 在 Page 末尾处结束。</p> 
<p>  注意到写 flash 命令和 Erase 命令都依赖于 WEL bit（SR1[1]），因此<strong>一个完整的 flash 写过程如下：WREN --&gt; Erase --&gt; WREN --&gt; Write Flash</strong>。</p> 
<p>  Page Programming <strong>只能在单个 Page 里进行数据写入</strong>。如果 Addr 低 9/10 位（视 Page Size 决定）不为 0，则超出当前 Page 的数据会无法写入；而对于 Addr 低位为 0 的情况，由于 Programming Buffer 大小的限制，自然不会越界。</p> 
<p>  当 PP 一次写入少于一个 Page 的数据时，将从指定地址开始依次写入数据，而不对当前 Page 内的其他数据造成影响。为了优化写入时间，建议每次写入一个完整的 Page。</p> 
<p>  S25FL-S 有两类 PP 指令，Single Wide mode 和 Quad mode，而不支持 Dual mode。对于 Single mode，时序如下，最高可支持 133 MHz</p> 
<p><img src="https://images2.imgbox.com/cc/a7/F6AnpG3F_o.jpg" alt="在这里插入图片描述" width="700" height="380"></p> 
<p>对于 Quad mode，时序如下，最大支持 80MHz</p> 
<p><img src="https://images2.imgbox.com/42/cb/W4tNSmvG_o.jpg" alt="在这里插入图片描述" width="700" height="420"></p> 
<p>需注意，这里不像 Quad I/O Read，不支持地址通过 IO0~IO3 传输，只能通过 SI 单线传输。</p> 
<p>  Programming 过程可以被编程挂起命令（Program Suspend, PGSP 85h）中断，然后可以从其他非擦除 Sector 或非编程挂起的 Page 中读取数据，可以通过编程恢复命令（Program Resume, PGRS 8Ah）恢复写入。</p> 
<h4><a id="flash__262"></a>flash 擦除命令</h4> 
<p>  有两类擦除命令：扇区擦除命令（Sector Erase, SE）、批量擦除命令（Bulk Erase, BE）。SE 命令仅擦除一个扇区，而 BE 命令会擦除整个 flash。在擦除命令的 CS# 拉高后，擦除循环就会启动；由于擦除过程较慢，因此用户可以检查 WIP bit（SR1[0]）查看是否完成擦除，擦除过程中 WIP=1，擦除完成后 WIP 将为 0。<strong>CS# 必须在最后一个地址位被移入后拉高，才可以启动擦除循环；如果没有被拉高，将不会进行擦除</strong>。</p> 
<p>  可以通过 4P4E（21h）擦除 4KB 扇区，通过 4SE（DCh）擦除一个标准扇区（64KB 或 256KB），擦除操作会将扇区所有单元的值置为 1。4P4E 只能用于擦除 4KB 扇区，对于其他扇区将不会执行，且不会置位 E_ERR bit（SR1[5]），而应用于被保护的 4KB 扇区时，则会擦除失败，并置位 E_ERR bit。SE 命令用于受保护扇区时，也会擦除失败并置位 E_ERR bit。时序如下</p> 
<p><img src="https://images2.imgbox.com/d4/4e/OOZc4u55_o.jpg" alt="在这里插入图片描述" width="700" height="220"></p> 
<p>  批量擦除命令（Bulk Erase, BE 60h or C7h），会将整个闪存中所有 bit 置 1。必须在第 8 个SCK 后拉高 CS# 以启动擦除循环，否则擦除循环不会启动。只有当 BP[2:0] 都为 0 时才能启动 BE，否则将不会执行 BE，也不会置位 E_ERR bit。</p> 
<p><img src="https://images2.imgbox.com/29/67/R2TRPtLR_o.jpg" alt="在这里插入图片描述" width="400" height="200"></p> 
<p>  可以通过擦除挂起命令（Erase Suspend, ERSP 75h）和擦除恢复命令（Erase Resume, ERRS 7Ah）挂起/恢复擦除操作。执行擦除挂起命令后，需要等待 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          t 
         
         
         
           E 
          
         
           S 
          
         
           L 
          
         
        
       
      
        t_{ESL} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7651em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3283em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0576em;">ES</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 后设备才会挂起并置位 ES bit（SR2[1]），之后可以执行其他操作。<strong>擦除挂起命令只在 SE 操作期间有效</strong>，而 BE 操作期间将被忽略。在擦除挂起后，WIP bit 会被置 0，此时可以检查 ES bit 查看当前是擦除挂起（ES=1）还是擦除完成（ES=0）。</p> 
<h2><a id="FPGA__278"></a>FPGA 实现（思路）</h2> 
<p>  （行文至此，内容较多，就不再附代码了，先进行思路的介绍，之后另开一篇专门放代码）</p> 
<p>  笔者的芯片具体型号为 S25FL256SAGNFI00，存储容量 256Mb，增强高性能 EHPLC，4KB 与 64KB 混合 Sector 的存储阵列，256 Byte 的 Page Programming Buffer 大小，最高支持 133MHz，无硬复位 RESET# 引脚。</p> 
<p>  为简单起见，采用 SDR 时钟模式；为了兼顾读写速度，采用 Quad mode；同时考虑到 Quad Page Programming 地址只能通过 SI 单线传输，因此读、写 FLASH 分别采用 Quad Output Read、Quad Page Programming，以实现时序格式的统一，简化编程。</p> 
<p>  由于 S25FL-S 在 SCK 上升沿锁存数据，在 SCK 下降沿转换数据，<strong>因此主控端应在 SCK 下降沿转换数据，在 SCK 上升沿锁存数据</strong>。</p> 
<p>  由于写 FLASH 需要先进行写使能以及擦除操作，而擦除操作需要检查 WIP bit（SR1[0]）；要使用 Quad 读写模式，需要置位 Quad bit（CR1[1]）；要判断地址映射类型和四元读模式下的 Dummy 长度，需要实现读写寄存器。因此需要实现以下功能：写使能 WREN、写失能 WRDI、写寄存器 WRR、清除状态寄存器 CLSR、读状态寄存器 RDSR1/RDSR2、读配置寄存器 RDCR、擦除操作（扇区擦除 4SE、批量擦除 BE）、四元编程操作 4QPP、Quad Output Read 操作 4QOR 等。</p> 
<p>  为每一种功能单独写一个模块当然也是可行的思路，但过于繁杂；观察到在时序层面上述指令可以归类为简单的五种：<strong>单 8bit 指令</strong>（如 WREN、WRDI、CLSR、BE 等）、<strong>写寄存器</strong>（8bit 指令后跟随 1~4Byte 数据，SI 单线传输，如 WRR、ABWR、BRWR 等，甚至 8bit 指令 + 4Byte 地址的 4SE 也可归于此类）、<strong>读寄存器</strong>（8bit 指令（SI）后跟随 1~4Byte 输出（SO），如 RDSR1、RDSR2、RDCR1、ABRD、BRRD 等）、<strong>四元写 FLASH</strong> （8bit 指令（SI）+ 32bit 地址（SI）+ 1~256Byte 数据（IO0~IO3写），如 4QPP）、<strong>四元读 FLASH</strong> （8bit 指令（SI）+ 32bit 地址（SI）+ xbit Dummy + xByte 数据（IO0~IO3读回），如 4QOR）。</p> 
<p>  因此可以首先实现以上几个基础模块，然后根据需要在上层模块中用状态机控制几个基础模块的运行。</p> 
<p>（完）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cbedf73623d53221a24590c5bbd8b4e5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python图像处理基础代码（分辨率、格式、删除指定文件）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d6ac91c500f4efec1f0abc4b0c078c33/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ApplicationContext和ServletContext</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>