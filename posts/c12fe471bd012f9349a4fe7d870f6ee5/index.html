<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>遵照std::allocator实现自定制的内存分配器 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="遵照std::allocator实现自定制的内存分配器" />
<meta property="og:description" content="下面是标准库STL中allocator的实现
template&lt;class _Ty&gt;
class allocator
: public _Allocator_base&lt;_Ty&gt;
{ // generic allocator for objects of class _Ty
public:
typedef allocator&lt;_Ty&gt; other;
typedef _Allocator_base&lt;_Ty&gt; _Mybase;
typedef typename _Mybase::value_type value_type;
typedef value_type *pointer;
typedef const value_type *const_pointer;
typedef void *void_pointer;
typedef const void *const_void_pointer;
typedef value_type&amp; reference;
typedef const value_type&amp; const_reference;
typedef size_t size_type;
typedef ptrdiff_t difference_type;
#if _HAS_CPP0X
typedef false_type propagate_on_container_copy_assignment;
typedef false_type propagate_on_container_move_assignment;
typedef false_type propagate_on_container_swap;
allocator&lt;_Ty&gt; select_on_container_copy_construction() const" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c12fe471bd012f9349a4fe7d870f6ee5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-05-13T22:50:15+08:00" />
<meta property="article:modified_time" content="2014-05-13T22:50:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">遵照std::allocator实现自定制的内存分配器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>下面是标准库STL中allocator的实现</p> 
<p>template&lt;class _Ty&gt;<br> <span style="white-space:pre"></span>class allocator<br> <span style="white-space:pre"></span>: public _Allocator_base&lt;_Ty&gt;<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// generic allocator for objects of class _Ty<br> public:<br> <span style="white-space:pre"></span>typedef allocator&lt;_Ty&gt; other;<br> <br> <br> <span style="white-space:pre"></span>typedef _Allocator_base&lt;_Ty&gt; _Mybase;<br> <span style="white-space:pre"></span>typedef typename _Mybase::value_type value_type;<br> <br> <br> <span style="white-space:pre"></span>typedef value_type *pointer;<br> <span style="white-space:pre"></span>typedef const value_type *const_pointer;<br> <span style="white-space:pre"></span>typedef void *void_pointer;<br> <span style="white-space:pre"></span>typedef const void *const_void_pointer;<br> <br> <br> <span style="white-space:pre"></span>typedef value_type&amp; reference;<br> <span style="white-space:pre"></span>typedef const value_type&amp; const_reference;<br> <br> <br> <span style="white-space:pre"></span>typedef size_t size_type;<br> <span style="white-space:pre"></span>typedef ptrdiff_t difference_type;<br> <br> <br>  #if _HAS_CPP0X<br> <span style="white-space:pre"></span>typedef false_type propagate_on_container_copy_assignment;<br> <span style="white-space:pre"></span>typedef false_type propagate_on_container_move_assignment;<br> <span style="white-space:pre"></span>typedef false_type propagate_on_container_swap;<br> <br> <br> <span style="white-space:pre"></span>allocator&lt;_Ty&gt; select_on_container_copy_construction() const<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// return this allocator<br> <span style="white-space:pre"></span>return (*this);<br> <span style="white-space:pre"></span>}<br>  #endif /* _HAS_CPP0X */<br> <br> <br> <span style="white-space:pre"></span>template&lt;class _Other&gt;<br> <span style="white-space:pre"></span>struct rebind<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// convert this type to allocator&lt;_Other&gt;<br> <span style="white-space:pre"></span>typedef allocator&lt;_Other&gt; other;<br> <span style="white-space:pre"></span>};<br> <br> <br> <span style="white-space:pre"></span>pointer address(reference _Val) const _NOEXCEPT<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// return address of mutable _Val<br> <span style="white-space:pre"></span>return (_STD addressof(_Val));<br> <span style="white-space:pre"></span>}<br> <br> <br> <span style="white-space:pre"></span>const_pointer address(const_reference _Val) const _NOEXCEPT<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// return address of nonmutable _Val<br> <span style="white-space:pre"></span>return (_STD addressof(_Val));<br> <span style="white-space:pre"></span>}<br> <br> <br> <span style="white-space:pre"></span>allocator() _THROW0()<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// construct default allocator (do nothing)<br> <span style="white-space:pre"></span>}<br> <br> <br> <span style="white-space:pre"></span>allocator(const allocator&lt;_Ty&gt;&amp;) _THROW0()<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// construct by copying (do nothing)<br> <span style="white-space:pre"></span>}<br> <br> <br> <span style="white-space:pre"></span>template&lt;class _Other&gt;<br> <span style="white-space:pre"></span>allocator(const allocator&lt;_Other&gt;&amp;) _THROW0()<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// construct from a related allocator (do nothing)<br> <span style="white-space:pre"></span>}<br> <br> <br> <span style="white-space:pre"></span>template&lt;class _Other&gt;<br> <span style="white-space:pre"></span>allocator&lt;_Ty&gt;&amp; operator=(const allocator&lt;_Other&gt;&amp;)<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// assign from a related allocator (do nothing)<br> <span style="white-space:pre"></span>return (*this);<br> <span style="white-space:pre"></span>}<br> <br> <br> <span style="white-space:pre"></span>void deallocate(pointer _Ptr, size_type)<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// deallocate object at _Ptr, ignore size<br> <span style="white-space:pre"></span>::operator delete(_Ptr);<br> <span style="white-space:pre"></span>}<br> <br> <br> <span style="white-space:pre"></span>pointer allocate(size_type _Count)<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// allocate array of _Count elements<br> <span style="white-space:pre"></span>return (_Allocate(_Count, (pointer)0));<br> <span style="white-space:pre"></span>}<br> <br> <br> <span style="white-space:pre"></span>pointer allocate(size_type _Count, const void *)<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// allocate array of _Count elements, ignore hint<br> <span style="white-space:pre"></span>return (allocate(_Count));<br> <span style="white-space:pre"></span>}<br> <br> <br> <span style="white-space:pre"></span>void construct(_Ty *_Ptr)<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// default construct object at _Ptr<br> <span style="white-space:pre"></span>::new ((void *)_Ptr) _Ty();<br> <span style="white-space:pre"></span>}<br> <br> <br> <span style="white-space:pre"></span>void construct(_Ty *_Ptr, const _Ty&amp; _Val)<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// construct object at _Ptr with value _Val<br> <span style="white-space:pre"></span>::new ((void *)_Ptr) _Ty(_Val);<br> <span style="white-space:pre"></span>}<br> <br> <br> #define _ALLOC_MEMBER_CONSTRUCT( \<br> <span style="white-space:pre"></span>TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \<br> <span style="white-space:pre"></span>template&lt;class _Objty COMMA LIST(_CLASS_TYPE)&gt; \<br> <span style="white-space:pre"></span>void construct(_Objty *_Ptr COMMA LIST(_TYPE_REFREF_ARG)) \<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>/* construct _Objty(_Types...) at _Ptr */ \<br> <span style="white-space:pre"></span>::new ((void *)_Ptr) _Objty(LIST(_FORWARD_ARG)); \<br> <span style="white-space:pre"></span>}<br> <br> <br> _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )<br> #undef _ALLOC_MEMBER_CONSTRUCT<br> <br> <br> <span style="white-space:pre"></span>template&lt;class _Uty&gt;<br> <span style="white-space:pre"></span>void destroy(_Uty *_Ptr)<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// destroy object at _Ptr<br> <span style="white-space:pre"></span>_Ptr-&gt;~_Uty();<br> <span style="white-space:pre"></span>}<br> <br> <br> <span style="white-space:pre"></span>size_t max_size() const _THROW0()<br> <span style="white-space:pre"></span>{<!-- --><span style="white-space:pre"> </span>// estimate maximum array size<br> <span style="white-space:pre"></span>return ((size_t)(-1) / sizeof (_Ty));<br> <span style="white-space:pre"></span>}<br> <span style="white-space:pre"></span>};<br> </p> 
<p><br> </p> 
<p>基于上述STL对于内存分配器的实现，如下是基于malloc，free和new，delete对该功能的实现</p> 
<p>来自boost中pool的实现版本</p> 
<p><br> <br> #ifndef BOOST_SYS_ALLOCATOR_H<br> #define BOOST_SYS_ALLOCATOR_H<br> <br> <br> #ifdef _MSC_VER<br> #pragma warning(push)<br> #pragma warning(disable:4100)<br> #endif<br> <br> <br> // Symbols: malloc_allocator, new_delete_allocator<br> <br> <br> #include &lt;cstddef&gt;<br> #include &lt;cstdlib&gt;<br> #include &lt;boost/limits.hpp&gt;<br> #include &lt;new&gt;<br> <br> <br> template &lt;typename T&gt;<br> struct malloc_allocator<br> {<!-- --><br>   typedef T * pointer;<br>   typedef const T * const_pointer;<br>   typedef T &amp; reference;<br>   typedef const T &amp; const_reference;<br>   typedef T value_type;<br> <br> <br>   typedef std::size_t size_type;<br>   typedef std::ptrdiff_t difference_type;<br> <br> <br>   template &lt;typename U&gt;<br>   struct rebind<br>   {<!-- --><br>     typedef malloc_allocator&lt;U&gt; other;<br>   };<br> <br> <br>   static pointer address(reference r) { return &amp;r; }<br>   static const_pointer address(const_reference r) { return &amp;r; }<br>   static pointer allocate(const size_type n, const void* = 0)<br>   {<!-- --><br>     const pointer ret = (pointer) std::malloc(n * sizeof(T));<br>     if (ret == 0)<br>       throw std::bad_alloc();<br>     return ret;<br>   }<br>   static void deallocate(const pointer p, const size_type)<br>   { std::free(p); }<br>   static size_type max_size() { return (std::numeric_limits&lt;size_type&gt;::max)(); }<br> <br> <br>   bool operator==(const malloc_allocator &amp;) const { return true; }<br>   bool operator!=(const malloc_allocator &amp;) const { return false; }<br> <br> <br>   malloc_allocator() { }<br>   template &lt;typename U&gt;<br>   malloc_allocator(const malloc_allocator&lt;U&gt; &amp;) { }<br> <br> <br>   static void construct(const pointer p, const_reference t)<br>   { new ((void *) p) T(t); }<br>   static void destroy(const pointer p)<br>   { p-&gt;~T(); }<br> };<br> <br> <br> template &lt;typename T&gt;<br> struct new_delete_allocator<br> {<!-- --><br>   typedef T * pointer;<br>   typedef const T * const_pointer;<br>   typedef T &amp; reference;<br>   typedef const T &amp; const_reference;<br>   typedef T value_type;<br> <br> <br>   typedef std::size_t size_type;<br>   typedef std::ptrdiff_t difference_type;<br> <br> <br>   template &lt;typename U&gt;<br>   struct rebind<br>   {<!-- --><br>     typedef new_delete_allocator&lt;U&gt; other;<br>   };<br> <br> <br>   static pointer address(reference r) { return &amp;r; }<br>   static const_pointer address(const_reference r) { return &amp;r; }<br>   static pointer allocate(const size_type n, const void* = 0)<br>   { return (pointer) new char[n * sizeof(T)]; }<br>   static void deallocate(const pointer p, const size_type)<br>   { delete [] p; }<br>   static size_type max_size() { return (std::numeric_limits&lt;size_type&gt;::max)(); }<br> <br> <br>   bool operator==(const new_delete_allocator &amp;) const { return true; }<br>   bool operator!=(const new_delete_allocator &amp;) const { return false; }<br> <br> <br>   new_delete_allocator() { }<br>   template &lt;typename U&gt;<br>   new_delete_allocator(const new_delete_allocator&lt;U&gt; &amp;) { }<br> <br> <br>   static void construct(const pointer p, const_reference t)<br>   { new ((void *) p) T(t); }<br>   static void destroy(const pointer p)<br>   { p-&gt;~T(); }<br> };<br> <br> <br> #ifdef _MSC_VER<br> #pragma warning(pop)<br> #endif<br> <br> <br> #endif<br> </p> 
<p><br> </p> 
<p>通过boost中pool的demo测试代码可以看出这三种的性能在vector中相差无几，、</p> 
<p>但是使用boost::fast_pool_allocator在对set和list这样的数据结构中，性能提升了几倍</p> 
<p>甚至几十倍。</p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f7f78eb3769c78c063fc2a6ac9cc6a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">create temp table as from occur ora-600 处理一例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7fb92c3b8b083018d1565b23bf7ee913/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows 8 和 OpenWRT 下查看 WiFi 属性</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>