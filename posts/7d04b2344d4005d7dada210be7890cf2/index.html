<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>es6---Promise - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="es6---Promise" />
<meta property="og:description" content="一、Promise 1.1 promise是什么？ Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理且更强大。它最早由社区提出并实现，ES6将其写进了语言标准，统一了用法，并原生提供了Promise对象。 1、主要用于异步计算
2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果
3、可以在对象之间传递和操作promise，帮助我们处理队列 1.2 为什么会有promise？ 1.2.1 为了避免界面冻结（任务） 同步：假设你去了一家饭店，找个位置，叫来服务员，这个时候服务员对你说，对不起我是“同步”服务员，我要服务完这张桌子才能招呼你。那桌客人明明已经吃上了，你只是想要个菜单，这么小的动作，服务员却要你等到别人的一个大动作完成之后，才能再来招呼你，这个便是同步的问题：也就是“顺序交付的工作1234，必须按照1234的顺序完成”。
异步：则是将耗时很长的A交付的工作交给系统之后，就去继续做B交付的工作，。等到系统完成了前面的工作之后，再通过回调或者事件，继续做A剩下的工作。
AB工作的完成顺序，和交付他们的时间顺序无关，所以叫“异步”。
1.2.2 异步操作的常见语法 1.事件监听
document.getElementById(&#39;#start&#39;).addEventListener(&#39;click&#39;, start, false); function start() { // 响应事件，进行相应的操作 } // jquery on 监听 $(&#39;#start&#39;).on(&#39;click&#39;, start) 2.回调
// 比较常见的有ajax $.ajax(&#39;https://www.baidu.com/&#39;, { success (res) { // 这里可以监听res返回的数据做回调逻辑的处理 } }) // 或者在页面加载完毕后回调 $(function() { // 页面结构加载完成，做回调逻辑处理 }) 有了nodeJS之后...对异步的依赖进一步加剧了 大家都知道在nodeJS出来之前PHP、Java、python等后台语言已经很成熟了，nodejs要想能够有自己的一片天，那就得拿出点自己的绝活：
无阻塞高并发，是nodeJS的招牌，要达到无阻塞高并发异步是其基本保障
举例：查询数据从数据库，PHP第一个任务查询数据，后面有了新任务，那么后面任务会被挂起排队；而nodeJS是第一个任务挂起交给数据库去跑，然后去接待第二个任务交给对应的系统组件去处理挂起，接着去接待第三个任务...那这样子的处理必然要依赖于异步操作
异步回调的问题： 之前处理异步是通过纯粹的回调函数的形式进行处理很容易进入到回调地狱中，剥夺了函数 return 的能力问题可以解决，但是难以读懂，维护困难稍有不慎就会踏入回调地狱 - 嵌套层次深，不好维护 1.2.3 回调地狱 在正式了解“回调地狱”之前，我们先了解两个概念：
1.回调函数
当一个函数作为参数传入另一个函数中，并且它不会立即执行，只有当满足一定条件后该函数才可以执行，这种函数就称为回调函数。我们熟悉的定时器和Ajax中就存在有回调函数：
setTimeout(function(){ //function(){console.log(&#39;执行了回调函数&#39;)}就是回调函数，它只有在3秒后才会执行 console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7d04b2344d4005d7dada210be7890cf2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-14T00:14:13+08:00" />
<meta property="article:modified_time" content="2024-01-14T00:14:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">es6---Promise</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、Promise</h2> 
<h3>1.1 promise是什么？</h3> 
<blockquote> 
 <p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理且更强大。它最早由社区提出并实现，ES6将其写进了语言标准，统一了用法，并原生提供了Promise对象。 </p> 
</blockquote> 
<p>1、主要用于异步计算<br> 2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果<br> 3、可以在对象之间传递和操作promise，帮助我们处理队列 </p> 
<h3>1.2 为什么会有promise？</h3> 
<h4><strong>1.2.1 为了避免界面冻结（任务）</strong></h4> 
<ul><li> <p>同步：假设你去了一家饭店，找个位置，叫来服务员，这个时候服务员对你说，对不起我是“同步”服务员，我要服务完这张桌子才能招呼你。那桌客人明明已经吃上了，你只是想要个菜单，这么小的动作，服务员却要你等到别人的一个大动作完成之后，才能再来招呼你，这个便是同步的问题：也就是“顺序交付的工作1234，必须按照1234的顺序完成”。</p> </li><li> <p>异步：则是将耗时很长的A交付的工作交给系统之后，就去继续做B交付的工作，。等到系统完成了前面的工作之后，再通过回调或者事件，继续做A剩下的工作。<br> AB工作的完成顺序，和交付他们的时间顺序无关，所以叫“异步”。</p> </li></ul> 
<h4>1.2.2 异步操作的常见语法</h4> 
<p>1.事件监听</p> 
<pre><code class="language-javascript">document.getElementById('#start').addEventListener('click', start, false);
function start() {
  // 响应事件，进行相应的操作
}
// jquery on 监听
$('#start').on('click', start)
</code></pre> 
<p>2.回调</p> 
<pre><code class="language-javascript">// 比较常见的有ajax
$.ajax('https://www.baidu.com/', {
 success (res) {
   // 这里可以监听res返回的数据做回调逻辑的处理
 }
})

// 或者在页面加载完毕后回调
$(function() {
 // 页面结构加载完成，做回调逻辑处理
})
</code></pre> 
<h4>有了nodeJS之后...对异步的依赖进一步加剧了</h4> 
<p>大家都知道在nodeJS出来之前PHP、Java、python等后台语言已经很成熟了，nodejs要想能够有自己的一片天，那就得拿出点自己的绝活：<br><strong>无阻塞高并发，是nodeJS的招牌，要达到无阻塞高并发异步是其基本保障</strong><br> 举例：查询数据从数据库，PHP第一个任务查询数据，后面有了新任务，那么后面任务会被挂起排队；而nodeJS是第一个任务挂起交给数据库去跑，然后去接待第二个任务交给对应的系统组件去处理挂起，接着去接待第三个任务...<strong>那这样子的处理必然要依赖于异步操作</strong></p> 
<h4>异步回调的问题：</h4> 
<ul><li>之前处理异步是通过纯粹的回调函数的形式进行处理</li><li>很容易进入到回调地狱中，剥夺了函数 return 的能力</li><li>问题可以解决，但是难以读懂，维护困难</li><li>稍有不慎就会踏入回调地狱 - 嵌套层次深，不好维护</li></ul> 
<h4>1.2.3 回调地狱</h4> 
<p>在正式了解“回调地狱”之前，我们先了解两个概念：</p> 
<p>        1.回调函数<br>         <span style="color:#fe2c24;">当一个函数作为参数传入另一个函数中，并且它不会立即执行，只有当满足一定条件后该函数才可以执行，这种函数就称为回调函数</span>。我们熟悉的定时器和Ajax中就存在有回调函数：</p> 
<pre><code class="language-javascript">setTimeout(function(){   //function(){console.log('执行了回调函数')}就是回调函数，它只有在3秒后才会执行
	console.log('执行了回调函数');
},3000)  //3000毫秒
</code></pre> 
<p>这里的<span style="color:#fe2c24;">回调函数</span>是<code>function(){console.log('执行了回调函数')}</code>，在满足时间3秒后执行。</p> 
<div> 
 <pre><code class="language-javascript">      //1.创建异步对象
			var xhr=new XMLHttpRequest();
      //2.绑定监听事件(接收请求)
			xhr.onreadystatechange=function(){
				//此方法会被调用4次
				//最后一次，readyState==4
				//并且响应状态码为200时，才是我们要的响应结果 xhr.status==200
				if(xhr.readyState==4 &amp;&amp; xhr.status==200){
					//把响应数据存储到变量result中
					var result=xhr.responseText;
					console.log(result);
				}
			}
      //3.打开链接（创建请求）
			xhr.open("get","/demo/ajaxDemo",true);
      //4.发送请求
			xhr.send();
</code></pre> 
</div> 
<p>这里的回调函数是<span style="color:#fe2c24;"><code>xhr.onreadystatechange</code></span>绑定的函数，在<span style="color:#fe2c24;"><code>xhr.send()</code></span>发送请求并拿到响应后执行。</p> 
<p>        2.<a class="link-info" href="https://blog.csdn.net/muzidigbig/article/details/88594980" title="异步任务">异步任务</a><br>         与之相对应的概念是“同步任务”，同步任务在主线程上排队执行，只有前一个任务执行完毕，才能执行下一个任务。异步任务不进入主线程，而是进入异步队列/消息队列，前一个任务是否执行完毕不影响下一个任务的执行。同样，还拿定时器作为异步任务举例：</p> 
<div> 
 <pre><code class="language-javascript">        setTimeout(function(){
            console.log('执行了回调函数');
        },3000)
        console.log('111');
</code></pre> 
</div> 
<p>如果按照代码编写的顺序，应该先输出“执行了回调函数”，再输出“111”。但实际输出为：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/c4/2c/kcCrKl5g_o.png">​</p> 
<p>这种不阻塞后面任务执行的任务就叫做异步任务。<br> 接下来让我们看看什么是回调地狱。 </p> 
<h5>1.2.3.1 回调地狱是什么？</h5> 
<p> 根据前面我们可以得出一个结论：存在异步任务的代码，不能保证能按照顺序执行，那如果我们非要代码顺序执行呢？</p> 
<p>比如我要说一句话，语序必须是下面这样的：武林要以和为贵，要讲武德，不要搞窝里斗。<br> 我必须要这样操作，才能保证顺序正确：</p> 
<div> 
 <pre><code class="language-javascript">        setTimeout(function () {  //第一层
            console.log('武林要以和为贵');
            setTimeout(function () {  //第二程
                console.log('要讲武德');
                setTimeout(function () {   //第三层
                    console.log('不要搞窝里斗');
                }, 1000)
            }, 2000)
        }, 3000)
</code></pre> 
</div> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/0c/9b/EcQVxwc9_o.png">​</p> 
<p>可以看到，代码中的<span style="color:#fe2c24;">回调函数套回调函数</span>，居然套了3层，这种回调函数中嵌套回调函数的情况就<span style="color:#fe2c24;">叫做回调地狱</span>。</p> 
<p><span style="color:#fe2c24;">当异步操作想要有顺序时，只能在一个异步成功以后的回调函数里面嵌套另一个异步的操作，如果嵌套的层数过多就形成了回调地狱</span></p> 
<p>回调地狱的弊端：后期代码维护比较困难</p> 
<p>总结一下，回调地狱就是为是<span style="color:#fe2c24;">实现代码顺序执行</span>而出现的一种操作，它会造成我们的代码可读性非常差，后期不好维护。</p> 
<p>那该如何解决回调地狱呢？</p> 
<h3>1.3 如何创建promise对象</h3> 
<p>创建Promise对象有两种方式：</p> 
<h4><strong>方式一  通过Promise构造函数</strong></h4> 
<ul><li>promise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）</li><li>并未剥夺函数 return 的能力，因此无需层层传递callback，进行回调获取数据</li><li>代码风格，容易理解，便于维护</li><li>多个异步等待合并便于解决</li></ul> 
<div> 
 <pre><code class="language-javascript">new Promise(
  function (resolve, reject) {
    // 一段耗时的异步操作
    resolve('成功') // 数据处理完成
    // reject('失败') // 数据处理出错
  }
).then(
  (res) =&gt; {console.log(res)},  // 成功
  (err) =&gt; {console.log(err)} // 失败
)
</code></pre> 
</div> 
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<span style="color:#f33b45;"><code>resolve</code>和<code>reject</code></span>。它们是两个函数，由<span style="color:#f33b45;">JavaScript引擎</span>提供，不用自己部署。 </p> 
<ul><li>resolve作用是，将Promise对象的状态从“未完成”变为“<span style="color:#f33b45;">成功</span>”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<br> reject作用是，将Promise对象的状态从“未完成”变为“<span style="color:#f33b45;">失败</span>”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li><li>promise对象的状态不受外界影响 （<span style="color:#fe2c24;">3种状态</span>）：<br> 1、pending[待定]初始状态<br> 2、fulfilled[实现]操作成功<br> 3、rejected[被否决]操作失败<br> 当promise状态发生改变，就会触发then()里的响应函数处理后续步骤；promise状态一经改变，不会再变。</li><li>一旦状态改变就不会再变 （两种状态改变：成功或失败）：<br> 从pending变为fulfilled（成功）<br> 从pending变为rejected（失败）<br> 这两种情况只要发生，状态就凝固了，不会再变了。</li></ul> 
<p>对于第一种方式，需要手动判断成功还是失败，比如你获取用户信息：</p> 
<div> 
 <pre><code class="language-javascript">// 定义一个函数，用于获取用户信息
function getUserInfo(userId) {
  // 使用Promise手动管理异步操作
  return new Promise(function(resolve, reject) {
    // 假设获取用户信息是一个异步操作，需要一定时间
    setTimeout(function() {
      // 假设获取到了用户信息
      let user = { id: userId, name: '张三', age: 18 };
      // 判断用户是否存在
      if (user) {
        // 如果存在，使用resolve方法将Promise状态变为成功态
        resolve(user);
      } else {
        // 如果不存在，使用reject方法将Promise状态变为失败态
        reject('用户不存在');
      }
    }, 1000);
  });
}
 
// 调用getUserInfo函数获取用户信息
getUserInfo('001')
  .then(function(user) {
    // 如果获取用户信息成功，将打印用户信息
    console.log(user);
  })
  .catch(function(error) {
    // 如果获取用户信息失败，将打印错误信息
    console.log(error);
  });</code></pre> 
</div> 
<p>在该例子中，使用Promise手动管理异步操作。在getUserInfo函数中创建了一个Promise对象，将异步操作封装在其中，当异步操作执行成功时，使用resolve方法将Promise状态变为成功态，并传递用户信息，当异步操作执行失败时，使用reject方法将Promise状态变为失败态，并传递错误信息。使用then方法和catch方法分别处理Promise的状态变化，如果Promise状态变为成功态，将打印用户信息，如果Promise状态变为失败态，将打印错误信息。</p> 
<h4><strong>方式二  通过静态方法创建一个Promise对象</strong></h4> 
<p>也称为Promise的自动化管理方式。比如，Promise.resolve()可以创建一个状态为成功的Promise对象，Promise.reject()可以创建一个状态为失败的Promise对象。</p> 
<div> 
 <pre><code class="language-javascript">// 第二种方式，自动管理
let promise = Promise.resolve('successful');
let promise = Promise.reject('failed');</code></pre> 
</div> 
<p> 关于第二种方式，也给一个例子：</p> 
<div> 
 <pre><code class="language-javascript">// 模拟一个异步操作函数
function asyncFunction() {
  return new Promise((resolve, reject) =&gt; {
    // 模拟一个异步操作，2秒钟后将结果返回
    setTimeout(() =&gt; {
      resolve('success');
    }, 2000);
  });
}
 
// 返回一个已解决的Promise对象，并使用函数返回值作为解决结果
Promise.resolve(asyncFunction())
  .then((value) =&gt; {
    console.log('异步操作执行成功', value);
    // 在这里处理异步操作执行成功的情况
  })
  .catch((error) =&gt; {
    console.error('异步操作执行失败', error);
    // 在这里处理异步操作执行失败的情况
  });</code></pre> 
</div> 
<p>在这个例子中，我们定义了一个asyncFunction()函数，该函数返回一个Promise对象，在Promise对象的构造函数中使用setTimeout模拟了一个异步操作。然后我们使用Promise.resolve()方法将异步操作函数的返回值转换成一个自动管理状态的Promise对象。最后，我们在使用Promise.resolve()方法返回的Promise对象上使用.then()方法和.catch()方法处理异步操作成功或失败的情况。</p> 
<p><span style="color:#fe2c24;">使用Promise.resolve()方法的好处在于，如果被传入的参数本来就是一个promise对象，那么直接返回这个promise对象，如果不是promise对象，会自动转换成promise对象，方便在异步操作逻辑中使用。</span></p> 
<p>无论是哪种方式，创建的Promise对象都将具有pending（等待态）状态，调用resolve或reject方法可以改变其状态，并传递相应的值或错误。</p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/a6/56/KgL1sHDU_o.png" width="668">​</p> 
<p>最简单示例：</p> 
<div> 
 <pre><code class="language-javascript">new Promise(resolve =&gt; {
  setTimeout(() =&gt; {
    resolve('hello')
  }, 2000)
}).then(res =&gt; {
  console.log(res)
})
</code></pre> 
</div> 
<p>分两次，顺序执行</p> 
<div> 
 <pre><code class="language-javascript">    new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve('hello')//  1参数val = 'hello'
        }, 1000)
    }).then(val =&gt; {
        console.log(val);
        return new Promise((resolve, reject) =&gt; {
            setTimeout(() =&gt; {
                resolve('world')
            }, 1000)
        })
    }).then(val =&gt; {
        console.log(val);//  2参数val = 'world'
    })</code></pre> 
</div> 
<p>promise完成后then()</p> 
<div> 
 <pre><code class="language-javascript">    let pro = new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve('hello world')//  1参数val = 'hello'
        }, 1000)
    })
    setTimeout(() =&gt; {
        pro.then(val =&gt; {
            console.log(val); //  参数val = 'hello world'
        }, 1000)
    })
    console.log(pro.then(val =&gt; {}) instanceof Promise); // true</code></pre> 
</div> 
<p>结论：promise作为队列最为重要的特性，我们在任何一个地方生成了一个promise队列之后，我们可以把他作为一个变量传递到其他地方。</p> 
<h4>.then()</h4> 
<p>1、接收<span style="color:#fe2c24;">两个函数</span>作为参数，<span style="color:#fe2c24;">分别代表fulfilled（成功）和rejected（失败）</span><br> 2、<span style="color:#fe2c24;">.then()返回一个<strong>新的Promise实例</strong>，所以它可以链式调用</span><br> 3、当前面的Promise状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行<br> 4、状态响应函数可以返回新的promise，或其他值，不返回值也可以我们可以认为它返回了一个null；<br> 5、如果返回新的promise，那么下一级.then()会在新的promise状态改变之后执行<br> 6、如果返回其他任何值，则会立即执行下一级.then()</p> 
<p>.then()里面有.then()的情况</p> 
<p>1、因为.then()返回的还是Promise实例<br> 2、会等里面的then()执行完，再执行外面的</p> 
<p><img alt="" height="482" src="https://images2.imgbox.com/31/68/OS0YRUrq_o.png" width="576">​</p> 
<p> 对于我们来说，此时最好将其展开，也是一样的结果，而且会更好读：</p> 
<p><img alt="" height="498" src="https://images2.imgbox.com/c7/c5/o4Mb93S5_o.png" width="590">​</p> 
<p><strong>执行顺序</strong></p> 
<p>  接下来我们探究一下它的执行顺序，看以下代码：</p> 
<div> 
 <pre><code class="language-javascript">let promise = new Promise(function(resolve, reject){
    console.log("AAA");
    resolve()
});
promise.then(() =&gt; console.log("BBB"));
console.log("CCC")

// AAA
// CCC
// BBB
</code></pre> 
</div> 
<p>  执行后，我们发现输出顺序总是 <code>AAA -&gt; CCC -&gt; BBB</code>。表明，在<span style="color:#f33b45;">Promise新建后会立即执行</span>，所以<code>首先输出 AAA</code>。然后，then方法指定的回调函数将在当前脚本所有同步任务执行完后才会执行，所以<code>BBB 最后输出</code>。</p> 
<p><strong>与定时器混用</strong></p> 
<p>  首先看一个实例：</p> 
<div> 
 <pre><code class="language-javascript">let promise = new Promise(function(resolve, reject){
    console.log("1");
    resolve();
});
setTimeout(()=&gt;console.log("2"), 0);
promise.then(() =&gt; console.log("3"));
console.log("4");

// 1
// 4
// 3
// 2
</code></pre> 
</div> 
<p>可以看到，结果输出顺序总是：<code>1 -&gt; 4 -&gt; 3 -&gt; 2</code>。1与4的顺序不必再说，而2与3先输出Promise的then，而后输出定时器任务。原因则是<span style="color:#f33b45;">Promise属于微任务</span>，而<span style="color:#f33b45;">setTimeout则是宏任务</span>，而<span style="color:#fe2c24;">微</span><span style="color:#f33b45;">任务优先级高于宏任务</span>，所以有此结果。</p> 
<p>错误处理</p> 
<p><span style="color:#fe2c24;">Promise会自动捕获内部异常</span>，并交给rejected响应函数处理。</p> 
<ol><li> <p>第一种错误处理 （throw new Error() 抛出错误）</p> </li></ol> 
<p><img alt="" height="299" src="https://images2.imgbox.com/a1/bd/sEY0hWRO_o.png" width="360">​</p> 
<p>2.第二种错误处理（reject() 抛出错误）</p> 
<p><img alt="" height="285" src="https://images2.imgbox.com/37/8d/4D9iiNJ2_o.png" width="397">​</p> 
<p><span style="color:#fe2c24;"><strong>错误处理两种做法：</strong></span><br>     第一种：reject('错误信息').then(() =&gt; {}, () =&gt; {错误处理逻辑})<br>     第二种：throw new Error('错误信息').catch( () =&gt; {错误处理逻辑})<br>     推荐使用第二种方式，更加清晰好读，并且可以捕获前面所有的错误（可以捕获N个then回调错误）</p> 
<h4>catch() + then()</h4> 
<p>第一种情况： then(() =&gt; { throw new Error("错误")})</p> 
<p><img alt="" height="579" src="https://images2.imgbox.com/84/5e/P3erbneV_o.png" width="424">​</p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/93/96/fq7YupC4_o.png" width="328">​</p> 
<p>结论：<span style="color:#fe2c24;">catch里<strong>不</strong>抛出异常，catch会返回一个promise 实例，并且是 resolved 状态</span></p> 
<p>第二种情况： catch(() =&gt; { throw new Error("错误")})</p> 
<p><img alt="" height="419" src="https://images2.imgbox.com/60/65/fHAtkccB_o.png" width="676">​</p> 
<p><img alt="" height="187" src="https://images2.imgbox.com/5c/6e/o5mYoPVu_o.png" width="347">​</p> 
<p>结论：<span style="color:#fe2c24;">catch里抛出异常，catch会返回一个promise 实例，并且是 rejected 状态，所以绕过两个then直接跑到最下面的catch</span></p> 
<p><strong>finally</strong><br> finally()方法是Promise对象的原型方法，用于指定不论Promise对象状态如何都要被执行的回调函数，<span style="color:#fe2c24;">通常用来执行释放资源、清理操作等最终操作</span>。</p> 
<p>finally()方法只有一个参数，就是要执行的回调函数。这个回调函数在Promise对象状态变为已解决(resolved)或已拒绝(rejected)时都会被执行，无论如何都会执行。以下是一个使用finally()方法的例子：</p> 
<div> 
 <pre><code class="language-javascript">function asyncFunction() {
  return new Promise((resolve, reject) =&gt; {
    // 模拟一个异步操作，2秒钟后将结果返回
    setTimeout(() =&gt; {
      resolve('success');
    }, 2000);
  });
}
 
// 在异步操作结束后执行清理操作
asyncFunction()
  .then((value) =&gt; {
    console.log('异步操作成功', value);
    // 在这里对异步操作的结果进行处理
  })
  .catch((error) =&gt; {
    console.error('异步操作失败', error);
    // 处理异步操作的错误情况
  })
  .finally(() =&gt; {
    console.log('清理操作已执行');
    // 在这里执行清理操作，无论异步操作成功还是失败都会执行
  });</code></pre> 
</div> 
<p></p> 
<h3>1.4 promise 常用静态方法</h3> 
<h4><strong>Promise.all() 批量执行</strong></h4> 
<p>Promise.all([p1, p2, p3])用于将<span style="color:#fe2c24;">多个promise实例，包装成一个新的promise实例</span>，<span style="color:#fe2c24;">返回的实例就是普通的promise，</span><span style="color:#fe2c24;">它接收一个<strong>数组</strong>作为参数</span><br> 数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变<br> 当<span style="color:#f33b45;">所有的子Promise都完成</span>，该Promise完成，<span style="color:#fe2c24;">返回值是</span><span style="color:#f33b45;">全部值的数组</span><br><span style="color:#f33b45;">有任何一个失败，该Promise失败，返回值是第一个失败的子Promise结果</span></p> 
<div> 
 <pre><code class="language-javascript">    //切菜
    function cutUp() {
        console.log('开始切菜。');
        var p = new Promise(function (resolve, reject) {        //做一些异步操作
            setTimeout(function () {
                console.log('切菜完毕！');
                resolve('切好的菜');
            }, 1000);
        });
        return p;
    }

    //烧水
    function boil() {
        console.log('开始烧水。');
        var p = new Promise(function (resolve, reject) {        //做一些异步操作
            setTimeout(function () {
                console.log('烧水完毕！');
                resolve('烧好的水');
            }, 1000);
        });
        return p;
    }

    Promise.all([cutUp(), boil()])
        .then((result) =&gt; {
            console.log('准备工作完毕');
            console.log(result); // ["切好的菜", "烧好的水"]
        })

//结果：
//reject
//Promise {&lt;fulfilled&gt;: undefined}</code></pre> 
</div> 
<p>Promise.all()方法通常用于处理需要同时获取多个数据的情况，并将这些数据合并为一个结果返回。例如，在一个Web应用程序中，用户在提交订单时需要同时更新订单和用户信息，这时候就可以使用Promise.all()方法一次性向服务器发送两个请求，等待两个Promise都进入fulfilled状态后再进行下一步操作。</p> 
<p>另外，Promise.all()方法也可以用于并行处理多个HTTP请求或I/O操作，以提高程序的执行效率。例如，我们从网站中获取多条数据，这些数据都需要通过HTTP请求来获取，在所有Promise进入fulfilled状态后，我们可以将这些数据进行合并，并对它们进行排序、过滤等操作。这样一来，我们就可以在不阻塞主线程的情况下，在较短的时间内获取到多个数据，提高了应用程序的响应速度和用户体验。</p> 
<p>除了上述使用场景之外，Promise.all()方法还可以用于多个耗时操作的并行执行和等待，例如读取多个文件、并发执行多个函数等。总之，Promise.all()方法在项目中具有很多实际使用场景，可以帮助我们优化和改进代码的执行效率和用户体验。</p> 
<h4><strong><code>Promise.allSettled()</code></strong></h4> 
<p>用来确定<span style="color:#fe2c24;"><strong>一组异步操作是否都结束了（不管成功或失败）</strong></span>。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。 </p> 
<p>当您有多个彼此<strong>不依赖</strong>的异步任务成功完成时，或者您总是想知道每个promise的结果时，通常使用它。</p> 
<p><strong>相比之下，Promise.all() 更适合彼此相互依赖或者在其中任何一个reject时立即结束。</strong></p> 
<p>用法示例：</p> 
<pre><code class="language-javascript">var p1 = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 4000, 'one');
});
var p2 = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 3000, 'two');
});
var p3 = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 2000, 'three');
});
var p4 = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 1000, 'four');
});
var p5 = new Promise((resolve, reject) =&gt; {
  reject('reject');
});

Promise.allSettled([p1, p2, p3, p4, p5]).then(values =&gt; {
  console.log(values);
}, reason =&gt; {
  console.log(reason)
});
//结果：
//Promise {&lt;pending&gt;}
//(5) [{…}, {…}, {…}, {…}, {…}]
//0: {status: "fulfilled", value: "one"}
//1: {status: "fulfilled", value: "two"}
//2: {status: "fulfilled", value: "three"}
//3: {status: "fulfilled", value: "four"}
//4: {status: "rejected", reason: "reject"}
//length: 5
//[[Prototype]]: Array(0)
</code></pre> 
<p> 一旦所指定的 promises 集合中每一个 promise 已经完成，无论是成功的达成或被拒绝，未决议的 Promise将被异步完成。那时，所返回的 promise 的处理器将传入一个数组作为输入，该数组包含原始 promises 集中每个 promise 的结果。</p> 
<p><strong>对于每个结果对象，都有一个 status 字符串。如果它的值为 fulfilled，则结果对象上存在一个 value 。如果值为 rejected，则存在一个 reason 。value（或 reason ）反映了每个 promise 决议（或拒绝）的值。</strong></p> 
<p>可以发现和all相比，<strong>allSettled在其中一个promise返回错误时还可以继续等待结果</strong>。并且不管内部的计时器定时多少毫秒，它都会等所有结果返回后按照传参传入的顺序返回promise结果。</p> 
<p><strong>应用场景：</strong><br> 比如我们用户在页面上面同时填了3干个独立的表单，这三个表单分三个接口提交到后端，<strong>三个接口独立，没有顺序依赖</strong>，这个时候我们需要等到请求全部完成后给与用户提示表单提交的情况。</p> 
<p><strong>面试题：</strong><br> 共有四个接口，第一个接口是崩溃的，但是需要返回所有接口的结果。</p> 
<p>这一题如果使用 all，那么会直接抛出错误，所以必须使用allSettled方法请求数据</p> 
<pre><code class="language-javascript"> let a = axios.get("http://xxxa")
 let b = axios.get("http://xxxb")
 let c = axios.get("http://xxxc")
 let d = axios.get("http://xxxd")

 Promise.allSettled([a, b, c,d]).then(resx =&gt; {
   console.log('resx:',resx);
 },err =&gt; console.log(err))
/*结果：
第一个接口请求结果是错误的
(4) [{…}, {…}, {…}, {…}]
0: {status: "rejected", reason: Error:log…}
1: {status: "fulfilled", value: {…}}
2: {status: "fulfilled", value: {…}}
3: {status: "fulfilled", value: {…}}

*/</code></pre> 
<h4><strong>Promise.race()</strong></h4> 
<p>Promise.race()方法同样是将多个Promise实例包装成一个新的Promise实例，但是<span style="color:#fe2c24;">只要有一个Promise 实例状态发生变化，就将新的Promise实例的状态改变，且终值由第一个完成的 Promise提供。</span></p> 
<div> 
 <pre><code class="language-javascript">const promise1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve('promise1 resolved'), 2000);
});
const promise2 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve('promise2 resolved'), 1000);
});
const promise3 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve('promise3 resolved'), 3000);
});
 
Promise.race([promise1, promise2, promise3]).then((value) =&gt; {
  console.log(value); // 'promise2 resolved'
});
 </code></pre> 
</div> 
<p>Promise.race()方法也有许多实际使用场景。它可以用于处理需要快速获取结果的情况，例如，当我们向多个不同的服务器请求同一个资源时，我们可以使用Promise.race()方法来获取最快返回结果的服务器的响应，并忽略其他服务器的响应结果。或者，在一个Web应用程序中，我们需要在指定的时间内获取用户的同步输入和异步请求结果，我们可以使用Promise.race()方法同时监听用户输入事件和请求结果事件，一旦其中有一个事件触发，就可以立即返回响应结果，提高应用程序的响应速度和用户体验。</p> 
<p>另外，Promise.race()方法还可以用于处理超时情况，例如，在一个HTTP请求的响应时间超过一定时间后，我们可以使用Promise.race()方法将该请求和一个延迟一定时间的Promise实例包装起来，一旦有一个Promise进入fulfilled状态，就可以立即返回响应结果。如果请求在规定的时间内仍未返回，则将其取消并返回一个错误信息给用户，以提高应用程序的可用性和稳定性。</p> 
<h4><strong>Promise.any()</strong></h4> 
<p>Promise.any()方法会对多个Promise进行竞争，<span style="color:#fe2c24;">直到有一个Promise进入<strong>Fulfilled</strong>状态，Promise实例返回该Promise的结果。</span>如果所有Promise都进入Rejected状态，则返回失败状态，其中维护Promise及其状态的任何提示返回数组都是必需的。</p> 
<p><span style="color:#fe2c24;"><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 <strong>Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。</strong></span></p> 
<div> 
 <pre><code class="language-javascript">const promises = [
  Promise.reject(1),
  Promise.reject(2),
  Promise.resolve(3),
];
 
Promise.any(promises)
  .then((value) =&gt; console.log(value))
  .catch((error) =&gt; console.log(error)); // 3</code></pre> 
</div> 
<p>如果所有的promise都是reject的，就抛出异常：</p> 
<div> 
 <pre><code class="language-javascript">const promises = [
  Promise.reject('error 1'),
  Promise.reject('error 2')
];
Promise.any(promises)
  .then((value) =&gt; console.log(value))
  .catch((err) =&gt; console.log(err));</code></pre> 
</div> 
<p>打印 AggregateError: All promises were rejected</p> 
<p>Promise.any()方法可以用于处理多种资源竞争的情况，例如，在一个抢单系统中，多个用户需要争夺同一个订单，系统将同时向多个用户发送请求，并使用Promise.any()方法监听所有请求的状态，一旦有一个用户成功抢到订单，系统就立即返回订单信息并发送通知给该用户，从而提高了用户的参与度和系统的可用性。</p> 
<p>除此之外，Promise.any()方法还可以用于指定默认值或备选方案，例如，在一个多语言网站中，我们需要从多个API获取多语言翻译结果，但有些API可能由于网络原因或其他问题无法正常工作，这时候我们就可以使用Promise.any()方法来一次性向多个API发送请求，并设置一个默认值或备选方案，一旦有一个API正常返回翻译结果，就立即返回结果给用户，如果所有API都无法正常工作，则返回默认值或备选方案。</p> 
<h2>二、Promise是没有中断方法的，当需要在链式中中断请求的时候要怎么处理？</h2> 
<p>讲道理，我们回忆下就知道 Promise 的特性就是：不能中断。</p> 
<p>一旦执行，我们无法知道它具体执行到哪里了，只知道在 pending，最后 resolve 或者 reject 才知道执行完毕。</p> 
<p>promise可以通过在流程中使用 <span style="color:#fe2c24;">throw 来中断流程触发catch操作</span>，也可以在某一个节点进行 <span style="color:#fe2c24;">reject来中断操作它的链式调用的.then函数</span>并不代表每一次的对象都是原始的promise对象。所以在链式调用的过程中是完全可以实现中断操作的。</p> 
<h3>方式一：同步的中断 promise </h3> 
<div> 
 <pre><code class="language-javascript">function someAsyncFunction() {
  return new Promise(function(resolve, reject) {
    // 在这里执行异步操作
    if (/* 某个条件成立 */) {
      // 如果条件成立，中断 promise 
      // throw new Error("The promise was interrupted")
      reject(new Error("The promise was interrupted"));
    }
  });
}

someAsyncFunction().catch(function(error) {
  // 处理 promise 中断的回调函数
  console.error(error.message);
});
</code></pre> 
</div> 
<h3>方式二：用 Promise 封装异步请求，当超过 N 秒后还未执行完，中断 Promise ，执行后续操作；</h3> 
<div> 
 <pre><code class="language-javascript">function timeoutWrapper(p, timeout = 2000) {
  const wait = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      reject('请求超时')
    }, timeout)
  })
  return Promise.race([p, wait])
}</code></pre> 
</div> 
<h2>三、拓展 async/await     <span style="color:#fe2c24;">同步代码异步操作，两者必须搭配使用</span></h2> 
<h3>3.1 async</h3> 
<p>首先我们看<code>async</code>关键字，他作为一个关键字放到声明函数前面，表示该函数为一个异步任务，不会阻塞后面函数的执行。</p> 
<p>  顾名思义，异步。async函数对 Generator 函数的改进，<strong><span style="color:#f33b45;">async 函数必定返回 Promise</span></strong>，我们把所有返回 Promise 的函数都可以认为是异步函数。特点体现在以下四点：</p> 
<ul><li>内置执行器</li><li>更好的语义</li><li>更广的适用性</li><li>返回值是 Promise</li></ul> 
<p><strong>1）表明程序里可能有异步过程</strong></p> 
<p>async表明程序里可能有异步过程（有await关键字）；全部是同步代码也没关系，但async就显得多余了；</p> 
<p><strong>2）非阻塞</strong></p> 
<p>async函数里如果有异步过程会等待，但<strong>async函数本身会马上返回</strong>，不会阻塞当前线程。可以简单认为async函数工作在主线程，同步执行，不会阻塞界面渲染；async函数内部由await修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回；</p> 
<p><strong>3）async函数返回类型为Promise对象</strong></p> 
<p><span style="color:#fe2c24;">async函数会返回一个promise，并且Promise对象的状态值是resolved（成功的）</span></p> 
<p>如果没有在async函数中写return，那么Promise对象resolve的值就是是undefined</p> 
<p>如果写了return，那么return的值就会作为成功的时候传入的值</p> 
<p>这是和普通函数本质上不同的地方，也是使用时重点注意的地方：</p> 
<p>（1）return new Promise();这个符合async函数本意；</p> 
<p>（2）<span style="color:#fe2c24;">return data;这是同步函数的写法，特别注意这其实就相当于Promise.resolve(data);还是一个Promise对象；但在调用async函数的地方通过简单的=是拿不到这个data的，因为<strong>返回值是一个Promise对象</strong>，所以需要用<strong>.then(data =&gt; { })才可以拿到data</strong>；</span></p> 
<p>（3）如果没有返回值，相当于返回了Promise.resolve(undefined);</p> 
<div> 
 <pre><code class="language-javascript">asyn function(){
    return await 1
} 
返回值：resove(1)

</code></pre> 
</div> 
<p> <strong>4）无等待</strong></p> 
<p><span style="color:#fe2c24;">在没有await的情况下执行async函数，它会立即执行，返回一个Promise对象，并且不会阻塞后面的语句，这和普通返回Promise对象的函数并无二致；</span></p> 
<p><strong>5）内部的await不处理异步error</strong></p> 
<p>await是不管异步过程的reject(error)消息的，async函数返回的这个Promise对象的catch函数负责统一抓取内部所有异步过程的错误；async函数内部只要有一个异步过程发生错误，整个执行过程就中断，这个返回的Promise对象的catch就能抓取到这个错误；</p> 
<h3>3.2 await</h3> 
<p>  顾名思义，等待。正常情况下，<span style="color:#fe2c24;">await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值</span>。另一种情况是，await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象。<span style="color:#fe2c24;">await后的Promise如果是reject状态， 那么整个async函数都会中断，后面的代码不执行。</span></p> 
<p>混合使用</p> 
<p>  先看示例：</p> 
<div> 
 <pre><code class="language-javascript">function sleep(ms) {
    return new Promise(function(resolve, reject) {
        console.log("CCC");
        resolve("promise1")
        setTimeout(function() {
            console.log("DDD");
            
        },ms);
    })
}
async function handle(){
    console.log("AAA")
    await sleep(2000).then((res) =&gt; {
        console.log(res)
    });
    console.log("BBB")
}

handle()

// AAA
// CCC
// promise1
// BBB 
// DDD</code></pre> 
</div> 
<p>我们定义函数sleep，返回一个Promise。然后在handle函数前加上async关键词，这样就定义了一个async函数。在该函数中，利用await来等待一个Promise。</p> 
<p>为什么叫<code>await</code>等待呢，因为当代码执行到<code>async</code>函数中的<code>await</code>时，代码就在此处等待不继续往下执行，知道<code>await</code>拿到Promise对象中resolve的数据，才继续往下执行，这样就保证了代码的执行顺序，而且使异步代码看起来更像同步代码。<span style="color:#fe2c24;">如果是reject状态， 那么整个async函数都会中断，后面的代码不执行。</span></p> 
<h4>Promise优缺点</h4> 
<p><img alt="" height="144" src="https://images2.imgbox.com/d7/ec/Y6KGJmNf_o.png" width="627">​</p> 
<p><img alt="" height="196" src="https://images2.imgbox.com/1c/1a/OHu4SKV4_o.png" width="862">​</p> 
<h4>为什么async/await更好？</h4> 
<ul><li>使用async函数可以让代码简洁很多</li><li> 不需要像Promise一样需要then</li><li>不需要写匿名函数处理Promise的resolve的值 </li><li>也不需要定义多余的data变量，还避免了嵌套代码 </li></ul> 
<p><strong>总结</strong><br> 总结一下，当我们写代码遇到异步回调时，我们想让异步代码按照我们想要的顺序执行，如果按照传统的嵌套方式，就会出现回调地狱，这样的代码不利于维护，我们可以通过Promise对象进行链式编程来解决，这样尽管可以解决问题，但是ES7给我们提供了更加舒适的async/await语法糖，可以使得异步代码看起来更像是同步代码。<br>  </p> 
<p></p> 
<blockquote> 
 <p>实战示例，回调地狱和promise对比：</p> 
</blockquote> 
<div> 
 <pre><code class="language-javascript">/***
   第一步：找到北京的id
   第二步：根据北京的id -&gt; 找到北京公司的id
   第三步：根据北京公司的id -&gt; 找到北京公司的详情
   目的：模拟链式调用、回调地狱
 ***/
 
 // 回调地狱
 // 请求第一个API: 地址在北京的公司的id
 $.ajax({
   url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/city',
   success (resCity) {
     let findCityId = resCity.filter(item =&gt; {
       if (item.id == 'c1') {
         return item
       }
     })[0].id
     
     $.ajax({
       //  请求第二个API: 根据上一个返回的在北京公司的id “findCityId”，找到北京公司的第一家公司的id
       url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/position-list',
       success (resPosition) {
         let findPostionId = resPosition.filter(item =&gt; {
           if(item.cityId == findCityId) {
             return item
           }
         })[0].id
         // 请求第三个API: 根据上一个API的id(findPostionId)找到具体公司，然后返回公司详情
         $.ajax({
           url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/company',
           success (resCom) {
             let comInfo = resCom.filter(item =&gt; {
               if (findPostionId == item.id) {
                 return item
               }
             })[0]
             console.log(comInfo)
           }
         })
       }
     })
   }
 })
</code></pre> 
</div> 
<div> 
 <pre><code class="language-javascript">// Promise 写法
  // 第一步：获取城市列表
  const cityList = new Promise((resolve, reject) =&gt; {
    $.ajax({
      url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/city',
      success (res) {
        resolve(res)
      }
    })
  })

  // 第二步：找到城市是北京的id
    cityList.then(res =&gt; {
      let findCityId = res.filter(item =&gt; {
        if (item.id == 'c1') {
          return item
        }
      })[0].id
      
      findCompanyId().then(res =&gt; {
        // 第三步（2）：根据北京的id -&gt; 找到北京公司的id
        let findPostionId = res.filter(item =&gt; {
            if(item.cityId == findCityId) {
              return item
            }
        })[0].id

        // 第四步（2）：传入公司的id
        companyInfo(findPostionId)

      })

    })

  // 第三步（1）：根据北京的id -&gt; 找到北京公司的id
  function findCompanyId () {
    let aaa = new Promise((resolve, reject) =&gt; {
      $.ajax({
        url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/position-list',
        success (res) {
          resolve(res)
        }
      })
    })
    return aaa
  }

// 第四步：根据上一个API的id(findPostionId)找到具体公司，然后返回公司详情
function companyInfo (id) {
  let companyList = new Promise((resolve, reject) =&gt; {
    $.ajax({
      url: 'https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/company',
      success (res) {
        let comInfo = res.filter(item =&gt; {
            if (id == item.id) {
               return item
            }
        })[0]
        console.log(comInfo)
      }
    })
  })
}
</code></pre> 
</div> 
<h4></h4> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58f46a053a434ee05d74216fcdd24912/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Postman测试WebService接口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/40059acf67076be52b21bcb045d39776/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【AI】大模型训练的常用图像数据集</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>