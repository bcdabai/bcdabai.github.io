<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（三）k8s资源清单 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（三）k8s资源清单" />
<meta property="og:description" content="一、k8s中的资源 K8s中所有的内容都抽象为资源,资源实例化之后,叫做对象,那么这些资源不能在同一空间下重名
名称空间级别（namespace）
工作负载型资源( workload):Pod、 ReplicaSet、 Deployment、 StatefulSet、 DaemonSet、Job、CronJob( ReplicationController在v1.11版本被废弃)服务发现及负载均衡型资源( ServiceDiscovery LoadBalance): Service、 Ingress配置与存储型资源: Volume(存储卷)、CSI(容器存储接口,可以扩展各种各样的第三方存储卷)特殊类型的存储卷: ConfigMap(当配置中心来使用的资源类型)、 Secret(保存敏感数据) DownwardAPI(把外部环境中的信息输出给容器) 集群级资源:
Namespace、node、 Role ClusterRole、 RoleBinding、 ClusterRoleBinding元数据型资源: HPA、 PodTemplate、 LimitRange 二、资源清单 在k8s中，一般使用yam格式的文件来创建符合我们预期期望的pod，这样的yaml文件我们一般
称为资源清单。
2.1、资源清单yaml 语法 三、字段解释 3.1、必须存在的属性 参数名字段说明类型versionString这里是指的是K8SAPl的版本,目前基本上是v1,可以用 kubectl api versions命令查询kindString这里指的是yam文件定义的资源类型和角色,比如:odmetadataObject元数据对象,下面是它的属性metadata. nameString元数据对象的名字,这里由我们编写,比如命名pod的名字metadata. namespaceString元数据对象的命名空间,由我们自身定义SpecObject详细定义对象,下面是它的属性spec.containers[]list这里是Spec对象的容器列表定义,是个列表spec. containers.nameString这里定义容器的名字spec.containers.imageString这里定义要用到的镜像名称 3.2、主要属性 参数名字段说明类型spec. containers.nameString这里定义容器的名字spec.containers.imageString这里定义要用到的镜像名称spec.containers[]. imagePullPolicyString定义镜像拉取策略,有 Always、 Never 、IfNotPresent三个值可选(1) Always:意思是每次都尝试重新拉取镜像；(2) Never:表示仅使用本地镜像 ；(3)、IfNotPresent:如果本地有镜像就使用本地镜像,没有就拉取在线镜像。上面三个值都没设置的话,默认是 Alwaysspec.containers[].command[]List指定容器启动命令,因为是数组可以指定多个,不指定则使用镜像打包时使用的启动命spec.containers[].args[]List指定容器启动命令参数,因为是数组可以指定多个。spec.containers[].workingDirString指容器的工作目录spec.containers[]. volumeMounts[]List指定容器内部的存储卷配置spec.containers[].volumeMounts[].nameString指定可以被容器挂载的存储卷的名称spec.containers[].volumeMounts[].mountPathString指可以被容器挂载的存储卷的路径spec.containers[].volumeMounts[]. readOnlyString设置存储卷路径的读写模式,ture或者 false,spec.containers[].ports[]List指定容器需要用到的端口列表spec.containers[].ports[].nameString指定端口名称spec.containers[].ports[].containerPortString指定容器需要监听的端口号spec. containers[.ports[].hostPortString指定容器所在主机需要监听的端口号,默认跟上面 icontainerPort相同,注意设置了 hostPort，同一台主机无法启动该容器的相同副本(因为主机的端口号不能相同,这样会冲突)spec. containers[]-ports[.protocolString指定端口协议,支持TCP和UDP,默认值为 TCPspec. containers[]. env[]List指定容器运行前需设置的环境变量列表spec. containers[].env[].nameString指环境变量名称spec.containers[].env].valueString指定环境变量值spec.containers[].resourcesObject指定资源限制和资源请求的值(这里开始就是设置容器的资源上限)spec.containers[].resources.limitsObject指设置容器运行时资源的运行上限spec.containers[].resources.limits.cpuString指定CPU的限制,单位为core数,将用于docker run-cpu-shares参数(这里前面文章 Pod资源限制有讲过 HAP 那个啥的，哈哈 主要我也忘记具体名字了)spec.containers[].resources. limits.memoryString指定MEM内存的限制,单位为MB、GiB spec." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f8bee8f7bb04e3ad9cec34b40a196bee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-12T17:15:28+08:00" />
<meta property="article:modified_time" content="2022-05-12T17:15:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（三）k8s资源清单</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="k8s_0"></a>一、k8s中的资源</h2> 
<p>K8s中所有的内容都抽象为资源,资源实例化之后,叫做对象,那么这些资源不能在同一空间下重名</p> 
<ul><li> <p>名称空间级别（namespace）</p> 
  <ul><li>工作负载型资源( workload):Pod、 ReplicaSet、 Deployment、 StatefulSet、 DaemonSet、Job、CronJob( ReplicationController在v1.11版本被废弃)</li><li>服务发现及负载均衡型资源( ServiceDiscovery LoadBalance): Service、 Ingress</li><li>配置与存储型资源: Volume(存储卷)、CSI(容器存储接口,可以扩展各种各样的第三方存储卷)</li><li>特殊类型的存储卷: ConfigMap(当配置中心来使用的资源类型)、 Secret(保存敏感数据) DownwardAPI(把外部环境中的信息输出给容器)</li></ul> </li><li> <p>集群级资源:</p> 
  <ul><li>Namespace、node、 Role ClusterRole、 RoleBinding、 ClusterRoleBinding</li><li>元数据型资源: HPA、 PodTemplate、 LimitRange</li></ul> </li></ul> 
<h2><a id="_15"></a>二、资源清单</h2> 
<p>在k8s中，一般使用yam格式的文件来创建符合我们预期期望的pod，这样的yaml文件我们一般<br> 称为资源清单。</p> 
<h3><a id="21yaml__19"></a>2.1、资源清单yaml 语法</h3> 
<p><img src="https://images2.imgbox.com/17/73/2Tm5y9QG_o.png" alt="01"><br> <img src="https://images2.imgbox.com/75/9e/j8ZCibSc_o.png" alt="03"><br> <img src="https://images2.imgbox.com/29/98/QMFsA9RX_o.png" alt="04"><br> <img src="https://images2.imgbox.com/52/aa/FX7YMNok_o.png" alt="05"><br> <img src="https://images2.imgbox.com/9f/1a/ncfgTZJj_o.png" alt="06"><br> <img src="https://images2.imgbox.com/aa/30/kXYN9wcM_o.png" alt="07"><br> <img src="https://images2.imgbox.com/e2/7f/lbXtWmsJ_o.png" alt="08"><br> <img src="https://images2.imgbox.com/98/46/PkyE1YJx_o.png" alt="09"></p> 
<h2><a id="_28"></a>三、字段解释</h2> 
<h3><a id="31_29"></a>3.1、必须存在的属性</h3> 
<table><thead><tr><th>参数名</th><th>字段说明</th><th>类型</th></tr></thead><tbody><tr><td>version</td><td>String</td><td>这里是指的是K8SAPl的版本,目前基本上是v1,可以用 kubectl api versions命令查询</td></tr><tr><td>kind</td><td>String</td><td>这里指的是yam文件定义的资源类型和角色,比如:od</td></tr><tr><td>metadata</td><td>Object</td><td>元数据对象,下面是它的属性</td></tr><tr><td>metadata. name</td><td>String</td><td>元数据对象的名字,这里由我们编写,比如命名pod的名字</td></tr><tr><td>metadata. namespace</td><td>String</td><td>元数据对象的命名空间,由我们自身定义</td></tr><tr><td>Spec</td><td>Object</td><td>详细定义对象,下面是它的属性</td></tr><tr><td>spec.containers[]</td><td>list</td><td>这里是Spec对象的容器列表定义,是个列表</td></tr><tr><td>spec. containers.name</td><td>String</td><td>这里定义容器的名字</td></tr><tr><td>spec.containers.image</td><td>String</td><td>这里定义要用到的镜像名称</td></tr></tbody></table> 
<h3><a id="32_43"></a>3.2、主要属性</h3> 
<table><thead><tr><th>参数名</th><th>字段说明</th><th>类型</th></tr></thead><tbody><tr><td>spec. containers.name</td><td>String</td><td>这里定义容器的名字</td></tr><tr><td>spec.containers.image</td><td>String</td><td>这里定义要用到的镜像名称</td></tr><tr><td>spec.containers[]. imagePullPolicy</td><td>String</td><td>定义镜像拉取策略,有 Always、 Never 、IfNotPresent三个值可选(1) Always:意思是每次都尝试重新拉取镜像；(2) Never:表示仅使用本地镜像 ；(3)、IfNotPresent:如果本地有镜像就使用本地镜像,没有就拉取在线镜像。上面三个值都没设置的话,默认是 Always</td></tr><tr><td>spec.containers[].command[]</td><td>List</td><td>指定容器启动命令,因为是数组可以指定多个,不指定则使用镜像打包时使用的启动命</td></tr><tr><td>spec.containers[].args[]</td><td>List</td><td>指定容器启动命令参数,因为是数组可以指定多个。</td></tr><tr><td>spec.containers[].workingDir</td><td>String</td><td>指容器的工作目录</td></tr><tr><td>spec.containers[]. volumeMounts[]</td><td>List</td><td>指定容器内部的存储卷配置</td></tr><tr><td>spec.containers[].volumeMounts[].name</td><td>String</td><td>指定可以被容器挂载的存储卷的名称</td></tr><tr><td>spec.containers[].volumeMounts[].mountPath</td><td>String</td><td>指可以被容器挂载的存储卷的路径</td></tr><tr><td>spec.containers[].volumeMounts[]. readOnly</td><td>String</td><td>设置存储卷路径的读写模式,ture或者 false,</td></tr><tr><td>spec.containers[].ports[]</td><td>List</td><td>指定容器需要用到的端口列表</td></tr><tr><td>spec.containers[].ports[].name</td><td>String</td><td>指定端口名称</td></tr><tr><td>spec.containers[].ports[].containerPort</td><td>String</td><td>指定容器需要监听的端口号</td></tr><tr><td>spec. containers[.ports[].hostPort</td><td>String</td><td>指定容器所在主机需要监听的端口号,默认跟上面 icontainerPort相同,注意设置了 hostPort，同一台主机无法启动该容器的相同副本(因为主机的端口号不能相同,这样会冲突)</td></tr><tr><td>spec. containers[]-ports[.protocol</td><td>String</td><td>指定端口协议,支持TCP和UDP,默认值为 TCP</td></tr><tr><td>spec. containers[]. env[]</td><td>List</td><td>指定容器运行前需设置的环境变量列表</td></tr><tr><td>spec. containers[].env[].name</td><td>String</td><td>指环境变量名称</td></tr><tr><td>spec.containers[].env].value</td><td>String</td><td>指定环境变量值</td></tr><tr><td>spec.containers[].resources</td><td>Object</td><td>指定资源限制和资源请求的值(这里开始就是设置容器的资源上限)</td></tr><tr><td>spec.containers[].resources.limits</td><td>Object</td><td>指设置容器运行时资源的运行上限</td></tr><tr><td>spec.containers[].resources.limits.cpu</td><td>String</td><td>指定CPU的限制,单位为core数,将用于docker run-cpu-shares参数(这里前面文章 Pod资源限制有讲过 HAP 那个啥的，哈哈 主要我也忘记具体名字了)</td></tr><tr><td>spec.containers[].resources. limits.memory</td><td>String</td><td>指定MEM内存的限制,单位为MB、GiB spec.containers[].resources.requests</td></tr><tr><td>spec.containers[].resources.requests.cpu</td><td>string</td><td>cpu请求,单位为core数,容器启动时初始化可用数量</td></tr><tr><td>spec.containers.resources.requests.memory</td><td>String</td><td>内存请求,单位为MB、GB,容器启动的初始化可用数量</td></tr></tbody></table> 
<h3><a id="32_72"></a>3.2、额外属性</h3> 
<table><thead><tr><th>参数名</th><th>字段说明</th><th>类型</th></tr></thead><tbody><tr><td>spec.restartPolicy</td><td>String</td><td>定义Pod的重启策略,可选值为 Always、 OnFailure,默认值为Always；1、Always:pod一旦终止运行,则无论容器是如何终止的, kubelet服务都将重启它。如果容器正常结束(退出码为0),则 kubelet将不会重启它； 2、OnFailure:只有pod以非零退出码终止时, kubelet会重启该容；3、Never:pod终止后, kubeletMast将退出码报告给,会重启该Pod.</td></tr><tr><td>spec.nodeSelector</td><td>Object</td><td>定义node的 Label过滤标签,以 key value格式指定</td></tr><tr><td>spec.imagePullSecrets</td><td>Object</td><td>定义pull镜像时 secret使用名称,以 name secretkey格式指定</td></tr><tr><td>spec.hostNetwork</td><td>Boolean</td><td>定义是否使用主机网络模式,默认值为 false，设置true表示使用宿主机网络,不使用 docker网桥,同时设置了true将无法在同一台宿主机上启动第二个副本。</td></tr></tbody></table> 
<h3><a id="33_yaml__80"></a>3.3、模板 yaml 文件</h3> 
<ul><li>资源清单格式</li></ul> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> group/apiVersion <span class="token comment">#如果没有给定group名称,那么默认为core,可以使用kubectl api-versions  获取当前k8s版本上所有的 apiVersion版本信息(每个版本可能不同)</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span>  <span class="token comment">#资源类别  Pod,Deploment,rs 等等  #goupcorekubect1ap-:group/apiversion</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token comment">#资源元数据</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> 
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 
  <span class="token key atrule">lables</span><span class="token punctuation">:</span> 
  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>   <span class="token comment">#主要目的是方便用户阅读查找</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment">#期望的状态(disired state)</span>
<span class="token key atrule">status</span><span class="token punctuation">:</span> <span class="token comment">#当前状态,本字段有 Kubernetes自身维护,用户不能去定义,查看的时候可以看下当前的状态</span>
</code></pre> 
<ul><li>获取资源的 apiVersion 版本信息</li></ul> 
<pre><code class="prism language-shell">kubectl explain pod
kubectl explain Ingress
</code></pre> 
<p><img src="https://images2.imgbox.com/19/83/e9okkHUq_o.png" alt="331"></p> 
<ul><li>获取字段帮助文档</li></ul> 
<pre><code class="prism language-shell">kubectl explain pod
</code></pre> 
<p><img src="https://images2.imgbox.com/23/93/ghX301mO_o.png" alt="在这里插入图片描述"></p> 
<ul><li>字段配置格式</li></ul> 
<pre><code class="prism language-conf">apiVersion &lt;string&gt;          #表示字符串类型
metadata &lt;Object&gt;            #表示需要嵌套多层字段
labels &lt;map[string]string&gt;   #表示由k:v组成的映射
finalizers &lt;[]string&gt;        #表示字串列表
ownerReferences &lt;[]Object&gt;   #表示对象列表
hostPID &lt;boolean&gt;            #布尔类型
priority &lt;integer&gt;           #整型
name &lt;string&gt; -required-     #如果类型后面接 -required-，表示为必填字段
</code></pre> 
<ul><li>通过定义清单文件创建 Pod(当然根据你的 <strong>kind</strong> 来创建)</li></ul> 
<pre><code class="prism language-shell"><span class="token comment"># 创建命令</span>
kutectl create -f xxx.yaml
<span class="token comment"># 使用 -o 参数 加 yaml，可以将资源的配置以 yaml的格式输出出来，也可以使用json，输出为json格式</span>
kubectl get pod podName -o yaml  
</code></pre> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> pod<span class="token punctuation">-</span>demo
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> myapp
    <span class="token key atrule">name</span><span class="token punctuation">:</span> gkj<span class="token punctuation">-</span>test
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp<span class="token punctuation">-</span><span class="token number">1</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> hub.atguigu.com/library/myapp<span class="token punctuation">:</span>v1
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> busybox<span class="token punctuation">-</span><span class="token number">1</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox<span class="token punctuation">:</span>latest
    <span class="token key atrule">command</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token string">"/bin/sh"</span>
    <span class="token punctuation">-</span> <span class="token string">"-c"</span>
    <span class="token punctuation">-</span> <span class="token string">"sleep 3600"</span>
</code></pre> 
<h2><a id="_152"></a>四、容器生命周期</h2> 
<h3><a id="41Pod__153"></a>4.1、Pod 生命周期</h3> 
<p>这只是一个main C （即一个镜像）的周期，如果一个Pod中有多个main C (即多个镜像)，则也会有多个下列视图对象，<strong>可以为每一个 Main C 设置 init C、START、readiness、STOP 、Liveness</strong><br> <img src="https://images2.imgbox.com/64/36/V6dgUhf8_o.png" alt="41"><br> Pod能够具有多个容器,应用运行在容器里面但是它也可能有一个或多个先于应用容器启动的Init<br> 容器，并且Init 容器与普通的容器非常像,除了如下两点:</p> 
<blockquote> 
 <ul><li>Init容器总是运行到成功完成为止</li><li>每个Init容器都必须在下一个Init容器启动之前成功完成</li></ul> 
</blockquote> 
<p>如果Pod的Init容器失败，Kubernetes会不断地重启该Pod,直到Init容器成功为止。然而，如果Pod对应的 restartPolicy为 Never，它不会重新启动。</p> 
<p>因为Init容器具有与应用程序容器分离的单独镜像,所以它们的启动相关代码具有如下优势:</p> 
<blockquote> 
 <ul><li>它们可以包含并运行实用工具（因为执行完成Init C 之后就会把Init C 销毁）,但是出于安全考虑,是不建议在应用程序容器镜像中包含这<br> 些实用工具的</li><li>它们可以包含使用工具和定制化代码来安装,但是不能出现在应用程序镜像中。例如,创建<br> 镜像没必要FROM另一个镜像,只需要在安装过程中使用类似sed、awk、 python或dig<br> 这样的工具。</li><li>应用程序镜像可以分离出创建和部署的角色,而没有必要联合它们构建一个单独的镜像。</li><li>Init容器使用 Linux Namespace,所以相对应用程序容器来说具有不同的文件系统视图。因<br> 此,它们能够具有访问 Secret的权限,而应用程序容器则不能。</li><li><strong>它们必须在应用程序容器启动之前运行完成,而应用程序容器是并行运行的,所以Init容<br> 器能够提供了一种简单的阻塞或延迟应用容器的启动的方法,直到满足了一组先决条件。</strong></li></ul> 
</blockquote> 
<h3><a id="42init_C__175"></a>4.2、init C 示例</h3> 
<p>这个yaml 文件，创建了一个pod，并且这个pod里面只有一个 main C，这个main C 有两个 init C，<br> 当创建的时候，会先按照顺序创建 init C（即第一个Init C 先创建，如果失败，则不会创建第二个），最后只有两个Init C 都是成功的，才会创建 main C。</p> 
<blockquote> 
 <p>busybox 镜像只是封装了一些工具的镜像</p> 
</blockquote> 
<pre><code class="prism language-shell"><span class="token comment"># 内容就是如下</span>
<span class="token function">vim</span> ini-pod.yaml  
<span class="token comment"># 根据文件创建 </span>
kubectl create -f ini-pod.yaml
</code></pre> 
<p>如果有名称相同的可以把之前的删除，可以使用 --all 或者指定具体的名称删除，都是可以的</p> 
<pre><code class="prism language-shell"><span class="token comment"># 如果有资源是deployment的 不要删pod和Rs,因为这样是删不干净的，可以直接删除 deployment ，这样 rs和pod都会被删除</span>
kubectl delete deployment --all  <span class="token comment"># 这里没有指定namespace 默认是名称空间是default</span>
kubectl delete pod --all
kubectl delete svc --all 
</code></pre> 
<p><img src="https://images2.imgbox.com/55/2c/deTEOnGf_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp<span class="token punctuation">-</span>pod
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> myapp
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp<span class="token punctuation">-</span>container  <span class="token comment"># 定义一个容器，</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'sh'</span><span class="token punctuation">,</span> <span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'echo The app is running! &amp;&amp; sleep 3600'</span><span class="token punctuation">]</span> <span class="token comment"># 启动时执行 ，即输出一句话  The app is running 然后 休眠 6分钟，不退出镜像</span>
  <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>   <span class="token comment">#这里就是配置 init C 了，下面为这个main C配置了两个init C</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> init<span class="token punctuation">-</span>myservice
    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'sh'</span><span class="token punctuation">,</span> <span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'until nslookup myservice; do echo waiting for myservice; sleep 2; done;'</span><span class="token punctuation">]</span> <span class="token comment"># 这个的作用是检测 myservice(会在后面定义) 容器是否启动起来了</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> init<span class="token punctuation">-</span>mydb
    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'sh'</span><span class="token punctuation">,</span> <span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'until nslookup mydb; do echo waiting for mydb; sleep 2; done;'</span><span class="token punctuation">]</span> <span class="token comment"># 这个的作用是检测 mydb （会在后面定义）容器是否启动起来了</span>
</code></pre> 
<p>创建完成后，查看pod状态，如下，可以看到init 是有2个的，因为我们定义了2个init C，而main C 只有一个 0/1。<br> <img src="https://images2.imgbox.com/ab/75/vlphAYLo_o.png" alt="在这里插入图片描述"><br> 后面你一直 <code>kubectl get pod </code>会发现init c一直无法成功，这时我们可以看下当前这个pod 的详情,你会发现执行了第一个init c <strong>init-myservice</strong>,然后没有执行第二个init C，只是分配了myapp-pod的节点，然后没有下文了，说明第一个 init C <strong>init-myservice</strong>有问题。</p> 
<pre><code class="prism language-shell">kubectl describe pod myapp-pod
</code></pre> 
<p><img src="https://images2.imgbox.com/5c/3a/iQzVI7yD_o.png" alt="在这里插入图片描述"><br> 所以我们需要看下第一个init C <strong>init-myservice</strong>的日志</p> 
<pre><code class="prism language-shell"><span class="token comment"># -c 的作用是指定这个pod 的哪一个具体的容器，因为一个pod里面有多个容器的</span>
kubtctl log myapp-pod -c init-myservice 
</code></pre> 
<p><img src="https://images2.imgbox.com/2d/17/DfbKl6ED_o.png" alt="在这里插入图片描述"><br> 最后看到日志就会明白了，因为没有myservice这个服务，所以init C 过不去，对于另一种检测mydb的就不再演示了，两个必须都通过才行，才会到创建pod哪里，创建main C。<br> <img src="https://images2.imgbox.com/1d/c8/mNwOtUA1_o.png" alt="在这里插入图片描述"></p> 
<p>当你创建完第一个 service时，第一个init C 就已经通过了,也可以在svc中看到我们的myservice了，至于为什么我们的pod可以ping <strong>myservice</strong>，而不是使用ip，<strong>是因为一旦我们service创建成功，会被coredns-xxxx 记录，这样k8s内部的机器都是可以通过域名访问的</strong>。<br> <img src="https://images2.imgbox.com/b4/8e/h2VpUXPT_o.png" alt="在这里插入图片描述"><br> 分别创建 myservice 和 mydb 的 svc 即可</p> 
<pre><code class="prism language-shell">kubectl create -f myservice.yaml
kubectl create -f mydb.yaml
</code></pre> 
<ul><li>myservice.yaml</li></ul> 
<pre><code class="prism language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> myservice
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">9376</span>
</code></pre> 
<ul><li>mydb.yaml</li></ul> 
<pre><code class="prism language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> mydb
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">9377</span>
</code></pre> 
<p>最后结果<br> <img src="https://images2.imgbox.com/df/d2/72wJUUd5_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="43init_C__269"></a>4.3、init C 特殊说明/总结</h3> 
<ul><li>在 Pod 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动（<strong>网络和数据初始化会在每一个pod的pause中处理完成，这个pause是我们不可控的</strong>）。每个容器必须在下一个<br> 容器启动之前成功退出</li><li>如果由于运行时或失败退出，将导致容器启动失败，它会根据 Pod 的 restartPolicy 指定的策略<br> 进行重试。然而，如果 Pod 的 restartPolicy 设置为 Always，Init 容器失败时会使用<br> RestartPolicy 策略，尝试最大次数后如果还是失败则就是失败。</li><li>在所有的 Init 容器没有成功之前，Pod 将不会变成 Ready 状态（前面的实验图已经说的很清楚了）。Init 容器的端口将不会在<br> Service 中进行聚集，<strong>这样客户端或者浏览器是不能通过svc来访问到它的</strong>。 正在初始化中的 Pod 处于 Pending 状态，但应该会将 Initializing 状态设置为 true</li><li>如果 Pod 重启，所有 Init 容器必须重新执行（<strong>所以init 容器必须要保证幂等性，当然你也可以不设置init 容器</strong>）</li><li>对 Init 容器 spec 的修改被限制在容器 image 字段，修改其他字段都不会生效。<strong>更改 Init<br> 容器的 image 字段，等价于重启该 Pod</strong>。</li><li>Init 容器具有应用容器的所有字段。除了 readinessProbe和liveNess，因为 Init 容器无法定义不同于完成（completion）的就绪（readiness）之外的其他状态（init 容器本身就是检测其它容器准备就绪的前置条件，所以它不会存在准备就绪状态，而已检测完成就会销毁，所以不存在livenesss，<strong>所以通过这一点我们可以知道，在同一个main C的init C中的init C的端口是可以重复的，因为会按照顺序创建，通过就会删除，不会影响第二个</strong>）。这会在验证过程中强制执行</li><li>在 Pod 中的每个 app 和 Init 容器的名称必须唯一；与任何其它容器共享同一个名称，会在验证<br> 时抛出错误，这是肯定的，比较init C也是容器啊。</li></ul> 
<h3><a id="44_288"></a>4.4、探针</h3> 
<p>探针是由 kubelet 对容器执行的定期诊断。要执行诊断，kubelet 调用由容器实现的 Handler。有三<br> 种类型的处理程序：</p> 
<ul><li>ExecAction：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</li><li>TCPSocketAction：对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断<br> 被认为是成功的。</li><li>HTTPGetAction：对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的<br> 状态码大于等于200 且小于 400，则诊断被认为是成功的</li></ul> 
<p>每次探测都将获得以下三种结果之一：</p> 
<ul><li>成功：容器通过了诊断。</li><li>失败：容器未通过诊断。</li><li>未知：诊断失败，因此不会采取任何行动</li></ul> 
<p><strong>注意失败之后pod在指定策略下会重启，一些指令就会重新执行了</strong></p> 
<h4><a id="441_308"></a>4.4.1、探测方式</h4> 
<ul><li> <p>livenessProbe：指示容器是否正在运行。<strong>如果存活探测失败，则 kubelet 会杀死容器</strong>，并且容器将受到其<strong>重启策略</strong>的影响。如果容器不提供存活探针，则默认状态为 Success</p> </li><li> <p>readinessProbe：指示容器是否准备好服务请求。如果就绪探测失败，端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址。初始延迟之前的就绪状态默认为 Failure。如果容器不提供就绪探针，则默认状态为 Success</p> </li></ul> 
<h4><a id="442_314"></a>4.4.2、示例说明</h4> 
<h5><a id="4421___316"></a>4.4.2.1、检测探针 - 就绪检测</h5> 
<p>对就绪状态使用 httpget方式(<strong>至于其它的几种方式会在下面的就绪状态文章里面</strong>)检测 readinessProbe-httpget</p> 
<pre><code class="prism language-shell"><span class="token function">vim</span> readinessProbe-httpget.yaml 
</code></pre> 
<p>具体内容如下</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> readiness<span class="token punctuation">-</span>httpget<span class="token punctuation">-</span>pod
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> readiness<span class="token punctuation">-</span>httpget<span class="token punctuation">-</span>container
    <span class="token key atrule">image</span><span class="token punctuation">:</span> wangyanglinux/myapp<span class="token punctuation">:</span>v1
    <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent
    <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>
      <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>
        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
        <span class="token key atrule">path</span><span class="token punctuation">:</span> /index1.html  <span class="token comment"># 这个文件是不存在的</span>
      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment"># 容器创建启动一秒后开始检测</span>
      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token comment"># 每隔3秒检测一次，直到就绪状态结束</span>
</code></pre> 
<p>可以看到 READ 状态一直都是失败的，因为index1.html在80端口是不存的，状态码不会所在200多<br> <img src="https://images2.imgbox.com/61/95/LOa19GHL_o.png" alt="在这里插入图片描述"><br> 再仔细查看pod的日志，可以看到 readiness 探针失败了。</p> 
<pre><code class="prism language-shell">kubectl describe pod  readinessProbe-httpget
</code></pre> 
<p><img src="https://images2.imgbox.com/1a/ad/YJaKGhj9_o.png" alt="在这里插入图片描述"><br> 我们进入这个容器，因为当前这个pod只有一个main C容器，所以我们不需要使用 <code>- c </code>指定具体那个容器，然后增加一个 <code>index1.html</code>即可</p> 
<pre><code class="prism language-shell"><span class="token comment">#kubectl exec readinessProbe-httpget -c xxx pod -it -- /bin/sh</span>
kubectl <span class="token builtin class-name">exec</span> readinessProbe-httpget pod -it -- /bin/sh
</code></pre> 
<p><img src="https://images2.imgbox.com/96/dd/29yrTMDS_o.png" alt="在这里插入图片描述"><br> 再监控这个pod的状态</p> 
<pre><code class="prism language-shell"><span class="token comment"># w的意思是 watch 监听</span>
lubectl get pod -w 
</code></pre> 
<p><img src="https://images2.imgbox.com/c7/34/ryCJit1t_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4422___364"></a>4.4.2.2、检测探针 - 存活检测</h5> 
<h6><a id="44221__exec__365"></a>4.4.2.2.1、存活检测 使用 exec 来检测</h6> 
<p>livenessProbe-exec</p> 
<pre><code class="prism language-shell"><span class="token function">vim</span> livenessProbe-exec.yaml
</code></pre> 
<p>内容如下</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness<span class="token punctuation">-</span>exec<span class="token punctuation">-</span>pod
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness<span class="token punctuation">-</span>exec<span class="token punctuation">-</span>container
    <span class="token key atrule">image</span><span class="token punctuation">:</span> hub.atguigu.com/library/busybox
    <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"touch /tmp/live ; sleep 60; rm -rf /tmp/live; sleep 3600"</span><span class="token punctuation">]</span> <span class="token comment"># 启动完成后创建一个文件/tmp/live 睡眠60秒后再把这个文件删除后睡眠6分钟</span>
    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>
      <span class="token key atrule">exec</span><span class="token punctuation">:</span>
        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token string">"-e"</span><span class="token punctuation">,</span><span class="token string">"/tmp/live"</span><span class="token punctuation">]</span>  <span class="token comment"># 检测这个文件是否存在</span>
      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">1</span>
      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">3</span>
</code></pre> 
<p>可以想到，这个容器前面的一段时间是可以通过存活检测的，因为前60秒这个文件是一直都在的，但是60秒之后就没了，所以会失败，就会重启，如下，虽然ready状态是ok的，但是存活检测是失败的，已经重启2次了。</p> 
<pre><code class="prism language-shell">kubectl get pod -w
</code></pre> 
<p><img src="https://images2.imgbox.com/55/74/p4CTW13w_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="44222__httpget__395"></a>4.4.2.2.2、存活检测 使用 httpget 来检测</h6> 
<p>livenessProbe-httpget</p> 
<pre><code class="prism language-shell"><span class="token function">vim</span> livenessProbe-httpget.yaml
</code></pre> 
<p>内容如下</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness<span class="token punctuation">-</span>httpget<span class="token punctuation">-</span>pod
  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness<span class="token punctuation">-</span>httpget<span class="token punctuation">-</span>container
    <span class="token key atrule">image</span><span class="token punctuation">:</span> hub.atguigu.com/library/myapp<span class="token punctuation">:</span>v1
    <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http   <span class="token comment"># 定义80 端口的名称为http ,后面使用的时候，不用写80,可以用http这个名称代替</span>
      <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>
      <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>
        <span class="token key atrule">port</span><span class="token punctuation">:</span> http  <span class="token comment"># 那这里其实就是80端口啦</span>
        <span class="token key atrule">path</span><span class="token punctuation">:</span> /index.html
      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">1</span>
      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">3</span>
      <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>
</code></pre> 
<h6><a id="44222__tcp__424"></a>4.4.2.2.2、存活检测 使用 tcp 来检测</h6> 
<p>livenessProbe-tcp</p> 
<pre><code class="prism language-shell"><span class="token function">vim</span> livenessProbe-tcp.yaml
</code></pre> 
<p>内容如下</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> probe<span class="token punctuation">-</span>tcp
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">image</span><span class="token punctuation">:</span> hub.atguigu.com/library/myapp<span class="token punctuation">:</span>v1
    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>
      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>
      <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">1</span>
      <span class="token key atrule">tcpSocket</span><span class="token punctuation">:</span>
        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
</code></pre> 
<h5><a id="4423_447"></a>4.4.2.3、组合就绪和存活-探针</h5> 
<p>组合的话，其实也是很简单的，就是把对于的配置copy再一起就行了。<br> liveness-readness-Probe</p> 
<pre><code class="prism language-shell"><span class="token function">vim</span> liveness-readness-Probe.yaml
</code></pre> 
<p>内容如下</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> probe<span class="token punctuation">-</span>tcp
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">image</span><span class="token punctuation">:</span> hub.atguigu.com/library/myapp<span class="token punctuation">:</span>v1
    <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>
      <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>
        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
        <span class="token key atrule">path</span><span class="token punctuation">:</span> /index1.html
      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">1</span>
      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">3</span>
    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>
      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>
      <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">1</span>
      <span class="token key atrule">tcpSocket</span><span class="token punctuation">:</span>
        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
</code></pre> 
<h5><a id="4424start__stop___475"></a>4.4.2.4、start 和 stop - 阶段</h5> 
<p>其实就是和上面差不多，都是一个回调的阶段。</p> 
<pre><code class="prism language-shell"><span class="token function">vim</span> start-stop-probe.yaml
</code></pre> 
<p>这里的关键字就是 <code>lifecycle</code> ,内容如下</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> lifecycle<span class="token punctuation">-</span>demo
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> lifecycle<span class="token punctuation">-</span>demo<span class="token punctuation">-</span>container
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">lifecycle</span><span class="token punctuation">:</span>
      <span class="token key atrule">postStart</span><span class="token punctuation">:</span>
        <span class="token key atrule">exec</span><span class="token punctuation">:</span>
          <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"echo Hello from the postStart handler &gt; /usr/share/message"</span><span class="token punctuation">]</span>
      <span class="token key atrule">preStop</span><span class="token punctuation">:</span>
        <span class="token key atrule">exec</span><span class="token punctuation">:</span>
           <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"echo bybe from the preStop handler &gt; /usr/share/message"</span><span class="token punctuation">]</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c31687dcebe3ef1bdf1cc590ccbbe7e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win10无法登陆到你的账户解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f65ca782cbe5258156d89a26c44b7c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">高性能 Go 语言发行版优化与落地实践 （Go 内存管理及优化、编译器优化）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>