<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ORB-SLAM2系列第三章—— 地图初始化 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ORB-SLAM2系列第三章—— 地图初始化" />
<meta property="og:description" content="文章目录 前言一、为什么需要地图初始化？二、多视图几何基础1.对极约束示意图2.H矩阵求解原理3.哪个奇异向量是最优解？3.求解基础矩阵F4.SVD5.单目投影恢复3D点 三、 卡方检验1.为什么要引用卡方检验?2.卡方分布假设检验步骤？3.ORB-SLAM2中的卡方检测剔除外点策略 四、单目SFM地图初始化1.为什么要归一化？2.具体归一化操作3.检查位姿的有效性 五、 双目地图初始化：稀疏立体匹配1.双目相机2.稀疏立体匹配原理3.亚像素插值 前言 迎浏览我的SLAM专栏，包括slam安装运行、代码注释、原理详解，一起加油淦穿SLAM。
一、为什么需要地图初始化？ 在ORB-SLAM2中初始化和使用的传感器类型有关，其中单目相机模式初始化相对复杂，需要运行一段时间才能成功初始化。而双目相机、
RGB-D相机模式下比较简单，一般从第一帧开始就可以完成初始化。
为什么不同传感器类型初始化差别这么大呢？
我们从最简单的RGB-D相机初始化来说，因为该相机可以直接输出RGB图像和对应的深度图像，所以每个像素点对应的深度值是确定的，也
就是说，我在第一帧提取了特征点后，特征点对应的三维点在空间的绝对坐标是可以计算出来的（需要用到内参）。
对于双目相机来说，也可以通过第一帧左右目图像立体匹配来得到特征点对应的三维点在空间的绝对坐标。因为第一帧的三维点是作为地图
来实现跟踪的，所以这些三维点我们也称为地图点。所以理论来说，双目相机、RGB-D相机在第一帧就可以完成初始化。
而对于单目相机来说，仅仅有第一帧无法得到三维点，想要初始化，需要像双目相机那样去进行立体匹配。
二、多视图几何基础 1.对极约束示意图 2.H矩阵求解原理 等式左边两项分别用A, X表示，则有:
AX = 0
一对点提供两个约束等式，单应矩阵H总共有9个元素，8个自由度（尺度等价性），所以需要4对点提供8个约束方程就可以求解。
3.哪个奇异向量是最优解？ 为什么VT的第9个奇异向量就是最优解？
Ah=0 对应的代价函数
最优解是导数为0
问题就转换为求ATA的最小特征值向量
可见 的特征向量就是 的特征向量。因此求解得到V 之后取出最后一行奇异值向量作为f的最优值，然后整理成3维矩阵形式。（其实其他行的奇异值向量也是一个解，但是不是最优解）
3.求解基础矩阵F 推导F矩阵约束方程
4.SVD SVD分解结果
假设我们使用8对点求解，A 是 8x9 矩阵，分解后
U 是左奇异向量，它是一个8x8的 正交矩阵，
V 是右奇异向量，是一个 9x9 的正交矩阵， 是V的转置
D是一个8 x 9 对角矩阵，除了对角线其他元素均为0，对角线元素称为奇异值，一般来说奇异值是按照从大到小的顺序降序排列。因为每个
奇异值都是一个残差项，因此最后一个奇异值最小，其含义就是最优的残差。因此其对应的奇异值向量就是最优值，即最优解。
VT中的每个列向量对应着D中的每个奇异值，最小二乘最优解就是VT对应的第9个列向量，也就是基础矩阵F的元素。这里我们先记做
Fpre，因为这个还不是最终的F。
F矩阵秩为2
基础矩阵 F 有个很重要的性质，就是秩为2，可以进一步约束求解准确的F
上面的方法使用 对应的第9个列向量构造的Fpre 秩通常不为2，我们可以继续进行SVD分解。
其最小奇异值人为置为0，这样F矩阵秩为2
此时的F就是最终得到的基础矩阵。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/eca14655558ed37f90eb699ce34906ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-29T20:13:08+08:00" />
<meta property="article:modified_time" content="2022-03-29T20:13:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ORB-SLAM2系列第三章—— 地图初始化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_6" rel="nofollow">前言</a></li><li><a href="#_16" rel="nofollow">一、为什么需要地图初始化？</a></li><li><a href="#_27" rel="nofollow">二、多视图几何基础</a></li><li><ul><li><a href="#1_28" rel="nofollow">1.对极约束示意图</a></li><li><a href="#2H_31" rel="nofollow">2.H矩阵求解原理</a></li><li><a href="#3_38" rel="nofollow">3.哪个奇异向量是最优解？</a></li><li><a href="#3F_49" rel="nofollow">3.求解基础矩阵F</a></li><li><a href="#4SVD_56" rel="nofollow">4.SVD</a></li><li><a href="#53D_79" rel="nofollow">5.单目投影恢复3D点</a></li></ul> 
  </li><li><a href="#__89" rel="nofollow">三、 卡方检验</a></li><li><ul><li><a href="#1_90" rel="nofollow">1.为什么要引用卡方检验?</a></li><li><a href="#2_100" rel="nofollow">2.卡方分布假设检验步骤？</a></li><li><a href="#3ORBSLAM2_120" rel="nofollow">3.ORB-SLAM2中的卡方检测剔除外点策略</a></li></ul> 
  </li><li><a href="#SFM_173" rel="nofollow">四、单目SFM地图初始化</a></li><li><ul><li><a href="#1_177" rel="nofollow">1.为什么要归一化？</a></li><li><a href="#2_196" rel="nofollow">2.具体归一化操作</a></li><li><a href="#3_204" rel="nofollow">3.检查位姿的有效性</a></li></ul> 
  </li><li><a href="#__208" rel="nofollow">五、 双目地图初始化：稀疏立体匹配</a></li><li><ul><li><a href="#1_210" rel="nofollow">1.双目相机</a></li><li><a href="#2_212" rel="nofollow">2.稀疏立体匹配原理</a></li><li><a href="#3_225" rel="nofollow">3.亚像素插值</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_6"></a>前言</h2> 
<p>迎浏览我的<a href="https://blog.csdn.net/weixin_45947476/category_11603869.html?spm=1001.2014.3001.5482">SLAM专栏</a>，包括slam安装运行、代码注释、原理详解，一起加油淦穿SLAM。</p> 
<hr> 
<h2><a id="_16"></a>一、为什么需要地图初始化？</h2> 
<p>在ORB-SLAM2中初始化和使用的传感器类型有关，其中单目相机模式初始化相对复杂，需要运行一段时间才能成功初始化。而双目相机、<br> RGB-D相机模式下比较简单，一般从第一帧开始就可以完成初始化。<br> 为什么不同传感器类型初始化差别这么大呢？<br> 我们从最简单的RGB-D相机初始化来说，因为该相机可以直接输出RGB图像和对应的深度图像，所以每个像素点对应的深度值是确定的，也<br> 就是说，我在第一帧提取了特征点后，特征点对应的三维点在空间的绝对坐标是可以计算出来的（需要用到内参）。<br> 对于双目相机来说，也可以通过第一帧左右目图像立体匹配来得到特征点对应的三维点在空间的绝对坐标。因为第一帧的三维点是作为地图<br> 来实现跟踪的，所以这些三维点我们也称为地图点。所以理论来说，双目相机、RGB-D相机在第一帧就可以完成初始化。<br> 而对于单目相机来说，仅仅有第一帧无法得到三维点，想要初始化，需要像双目相机那样去进行立体匹配。</p> 
<h2><a id="_27"></a>二、多视图几何基础</h2> 
<h3><a id="1_28"></a>1.对极约束示意图</h3> 
<p><img src="https://images2.imgbox.com/b7/6f/gUuZD6Fm_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2H_31"></a>2.H矩阵求解原理</h3> 
<p><img src="https://images2.imgbox.com/03/c4/w37qamix_o.png" alt="在这里插入图片描述"><br> 等式左边两项分别用A, X表示，则有:<br> <strong>AX = 0</strong><br> 一对点提供两个约束等式，单应矩阵H总共有9个元素，8个自由度（尺度等价性），所以需要4对点提供8个约束方程就可以求解。</p> 
<h3><a id="3_38"></a>3.哪个奇异向量是最优解？</h3> 
<p>为什么VT的第9个奇异向量就是最优解？<br> Ah=0 对应的代价函数<br> <img src="https://images2.imgbox.com/ed/d7/BwI99qRr_o.png" alt="在这里插入图片描述"><br> 最优解是导数为0<br> <img src="https://images2.imgbox.com/08/79/aEjw4wjh_o.png" alt="在这里插入图片描述"><br> 问题就转换为求ATA的最小特征值向量<br> <img src="https://images2.imgbox.com/4f/8e/BY55HDHM_o.png" alt="在这里插入图片描述"><br> 可见 的特征向量就是 的特征向量。因此求解得到V 之后取出最后一行奇异值向量作为f的最优值，然后整理成3维矩阵形式。（其实其他行的奇异值向量也是一个解，但是不是最优解）</p> 
<h3><a id="3F_49"></a>3.求解基础矩阵F</h3> 
<p><strong>推导F矩阵约束方程</strong><br> <img src="https://images2.imgbox.com/cd/ea/NAsZrKhP_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f9/9d/6kiYrg3P_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4SVD_56"></a>4.SVD</h3> 
<p>SVD分解结果<br> <img src="https://images2.imgbox.com/34/10/ppJwTz1J_o.png" alt="在这里插入图片描述"><br> 假设我们使用8对点求解，A 是 8x9 矩阵，分解后</p> 
<p>U 是左奇异向量，它是一个8x8的 正交矩阵，<br> V 是右奇异向量，是一个 9x9 的正交矩阵， 是V的转置<br> D是一个8 x 9 对角矩阵，除了对角线其他元素均为0，对角线元素称为奇异值，一般来说奇异值是按照从大到小的顺序降序排列。因为每个<br> 奇异值都是一个残差项，因此最后一个奇异值最小，其含义就是最优的残差。因此其对应的奇异值向量就是最优值，即最优解。<br> VT中的每个列向量对应着D中的每个奇异值，最小二乘最优解就是VT对应的第9个列向量，也就是基础矩阵F的元素。这里我们先记做<br> Fpre，因为这个还不是最终的F。</p> 
<p><strong>F矩阵秩为2</strong><br> 基础矩阵 F 有个很重要的性质，就是秩为2，可以进一步约束求解准确的F<br> 上面的方法使用 对应的第9个列向量构造的Fpre 秩通常不为2，我们可以继续进行SVD分解。<br> <img src="https://images2.imgbox.com/1c/bb/eoHL8ltP_o.png" alt="在这里插入图片描述"><br> 其最小奇异值人为置为0，这样F矩阵秩为2<br> <img src="https://images2.imgbox.com/e3/ab/kzHbiHaQ_o.png" alt="在这里插入图片描述"><br> 此时的F就是最终得到的基础矩阵。</p> 
<h3><a id="53D_79"></a>5.单目投影恢复3D点</h3> 
<p><img src="https://images2.imgbox.com/5e/a9/K285aEMy_o.png" alt="在这里插入图片描述"></p> 
<p>等式左边两项分别用A, X表示，则有<br> <img src="https://images2.imgbox.com/7b/36/l4EOhKcF_o.png" alt="在这里插入图片描述"><br> SVD求解，右奇异矩阵的最后一行就是最终的解。</p> 
<hr> 
<h2><a id="__89"></a>三、 卡方检验</h2> 
<h3><a id="1_90"></a>1.为什么要引用卡方检验?</h3> 
<p>以特定概率分布为某种情况建模时，事物长期结果较为稳定，能够清晰进行把握。比如抛硬币实验。<br> 但是期望与事实存在差异怎么办？偏差是正常的小幅度波动？还是建模错误？此时，利用卡方分布分析结果，排除可疑结果。<br> 简单来说：当事实与期望不符合情况下使用卡方分布进行检验，看是否系统出了问题，还是属于正常波动.</p> 
<p>检查实际结果与期望结果之间何时存在显著差异。<br> 1、检验拟合程度：也就是说可以检验一组给定数据与指定分布的吻合程度。如：用它检验抽奖机收益的观察频数与我们所期望的吻合程<br> 度。<br> 2、检验两个变量的独立性：通过这个方法检查变量之间是否存在某种关系。</p> 
<h3><a id="2_100"></a>2.卡方分布假设检验步骤？</h3> 
<p>1、确定要进行检验的假设（H0）及其备择假设H1.<br> 2、求出期望E.<br> 3、确定用于做决策的拒绝域（右尾）.<br> 4、根据自由度和显著性水平查询检验统计量临界值.<br> 5、查看检验统计量是否在拒绝域内.<br> 6、做出决策.<br> <strong>决策原则：</strong><br> 如果位于拒绝域内我们拒绝原假设H0，接受H1。<br> 如果不在拒绝域内我们接受原假设H0，拒绝H1<br> 检验统计量38.272 &gt; 9.49 位于拒绝域内</p> 
<p><strong>检验统计量拒绝域内外判定：</strong><br> 1、求出检验统计量a<br> 2、通过自由度和显著性水平查到拒绝域临界值b<br> 3、a&gt;b则位于拒绝域内，反之，位于拒绝域外。</p> 
<p><strong>这就不写例子了，详见张宇</strong></p> 
<h3><a id="3ORBSLAM2_120"></a>3.ORB-SLAM2中的卡方检测剔除外点策略</h3> 
<p>误差的定义：<br> 就特征点法的视觉SLAM而言，一般会计算重投影误差。具体而言，记U为特征点的2D位置，U-为由地图点投影到图像上的2D位置。重投影误差为<br> <img src="https://images2.imgbox.com/2a/9a/kXC7W5Z9_o.png" alt="在这里插入图片描述"><br> 重投影误差服从高斯分布</p> 
<p><img src="https://images2.imgbox.com/28/7c/YYSa9su4_o.png" alt="在这里插入图片描述"><br> 其中<br> <img src="https://images2.imgbox.com/6b/fc/6zWLJNRB_o.png" alt="在这里插入图片描述"><br> 而<br> <img src="https://images2.imgbox.com/43/14/nJKDkteA_o.png" alt="在这里插入图片描述"><br> 为多维标准正态分布。<br> 也就是说不同金字塔层提取的特征，计算的重投影误差都被归一化了，或者说去量纲化了，那么，我们只用一个阈值就可以了。<br> 可见：<br> 金字塔层数越高，图像分辨率越低，特征提取的精度也就越低，因此协方差越大<br> 单目投影为2自由度，在0.05的显著性水平（也就是95%的准确率）下，卡方统计量阈值为5.99<br> 双目投影为3自由度，在0.05的显著性水平（也就是95%的准确率）下，卡方统计量阈值为7.81<br> 双目匹配到的特征点在右图中的x坐标为 ，重投影后计算得到特征点左图的x坐标 ，根据视差<br> <img src="https://images2.imgbox.com/55/c5/o6zQVIOV_o.png" alt="在这里插入图片描述"><br> 从而得到重投影后右图中特征点x坐标<br> <img src="https://images2.imgbox.com/a3/51/lHu43VqX_o.png" alt="在这里插入图片描述"><br> disparity就是另一个自由度。<br> LocalMapping.cc 里面</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">float</span> <span class="token operator">&amp;</span>sigmaSquare1 <span class="token operator">=</span> mpCurrentKeyFrame<span class="token operator">-&gt;</span>mvLevelSigma2<span class="token punctuation">[</span>kp1<span class="token punctuation">.</span>octave<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">float</span> x1 <span class="token operator">=</span> Rcw1<span class="token punctuation">.</span><span class="token function">row</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dot</span><span class="token punctuation">(</span>x3Dt<span class="token punctuation">)</span><span class="token operator">+</span>tcw1<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">float</span> y1 <span class="token operator">=</span> Rcw1<span class="token punctuation">.</span><span class="token function">row</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dot</span><span class="token punctuation">(</span>x3Dt<span class="token punctuation">)</span><span class="token operator">+</span>tcw1<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">float</span> invz1 <span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">/</span>z1<span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>bStereo1<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">float</span> u1 <span class="token operator">=</span> fx1<span class="token operator">*</span>x1<span class="token operator">*</span>invz1<span class="token operator">+</span>cx1<span class="token punctuation">;</span>
<span class="token keyword">float</span> v1 <span class="token operator">=</span> fy1<span class="token operator">*</span>y1<span class="token operator">*</span>invz1<span class="token operator">+</span>cy1<span class="token punctuation">;</span>
<span class="token keyword">float</span> errX1 <span class="token operator">=</span> u1 <span class="token operator">-</span> kp1<span class="token punctuation">.</span>pt<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
<span class="token keyword">float</span> errY1 <span class="token operator">=</span> v1 <span class="token operator">-</span> kp1<span class="token punctuation">.</span>pt<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
<span class="token comment">// 基于卡方检验计算出的阈值（假设测量有一个像素的偏差）自由度2</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>errX1<span class="token operator">*</span>errX1<span class="token operator">+</span>errY1<span class="token operator">*</span>errY1<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">5.991</span><span class="token operator">*</span>sigmaSquare1<span class="token punctuation">)</span>
<span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">float</span> u1 <span class="token operator">=</span> fx1<span class="token operator">*</span>x1<span class="token operator">*</span>invz1<span class="token operator">+</span>cx1<span class="token punctuation">;</span>
<span class="token keyword">float</span> u1_r <span class="token operator">=</span> u1 <span class="token operator">-</span> mpCurrentKeyFrame<span class="token operator">-&gt;</span>mbf<span class="token operator">*</span>invz1<span class="token punctuation">;</span> <span class="token comment">// 根据视差公式计算假想的右目坐标</span>
<span class="token keyword">float</span> v1 <span class="token operator">=</span> fy1<span class="token operator">*</span>y1<span class="token operator">*</span>invz1<span class="token operator">+</span>cy1<span class="token punctuation">;</span>
<span class="token keyword">float</span> errX1 <span class="token operator">=</span> u1 <span class="token operator">-</span> kp1<span class="token punctuation">.</span>pt<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
<span class="token keyword">float</span> errY1 <span class="token operator">=</span> v1 <span class="token operator">-</span> kp1<span class="token punctuation">.</span>pt<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
<span class="token keyword">float</span> errX1_r <span class="token operator">=</span> u1_r <span class="token operator">-</span> kp1_ur<span class="token punctuation">;</span>
<span class="token comment">// 自由度为3</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>errX1<span class="token operator">*</span>errX1<span class="token operator">+</span>errY1<span class="token operator">*</span>errY1<span class="token operator">+</span>errX1_r<span class="token operator">*</span>errX1_r<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">7.8</span><span class="token operator">*</span>sigmaSquare1<span class="token punctuation">)</span>
<span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2><a id="SFM_173"></a>四、单目SFM地图初始化</h2> 
<p>归一化对应函数Initializer::Normalize</p> 
<h3><a id="1_177"></a>1.为什么要归一化？</h3> 
<p>Ah=0<br> 矩阵A是利用8点法求基础矩阵的关键，所以Hartey就认为，利用8点法求基础矩阵不稳定的一个主要原因就是原始的图像像点坐标组成的系<br> 数矩阵A不好造成的，而造成A不好的原因是像点的齐次坐标各个分量的数量级相差太大。基于这个原因，Hartey提出一种改进的8点法，在<br> 应用8点法求基础矩阵之前，先对像点坐标进行归一化处理，即对原始的图像坐标做同向性变换，这样就可以减少噪声的干扰，大大的提高8<br> 点法的精度。<br> 预先对图像坐标进行归一化有以下好处：</p> 
<ul><li>能够提高运算结果的精度</li><li>利用归一化处理后的图像坐标，对任何尺度缩放和原点的选择是不变的。归一化步骤预先为图像坐标选择了一个标准的坐标系中，消除了坐标变换对结果的影响。<br> 归一化操作分两步进行，首先对每幅图像中的坐标进行平移（每幅图像的平移不同）使图像中匹配的点组成的点集的形心（Centroid）移动<br> 到原点；接着对坐标系进行缩放使得各个分量总体上有一样的平均值，各个坐标轴的缩放相同的</li></ul> 
<p><img src="https://images2.imgbox.com/40/73/vAEY8hKy_o.png" alt="在这里插入图片描述">使用归一化的坐标虽然能够在一定程度上消除噪声、错误匹配带来的影响，但还是不够的。<br> 参考：<br> <a href="https://www.cnblogs.com/wangguchangqing/p/8214032.html" rel="nofollow">https://www.cnblogs.com/wangguchangqing/p/8214032.html</a></p> 
<h3><a id="2_196"></a>2.具体归一化操作</h3> 
<p><img src="https://images2.imgbox.com/d6/36/u5tbkD6n_o.png" alt="在这里插入图片描述"><br> 疑问：变换矩阵T为何这样？</p> 
<p>答案：就是把上述变换用矩阵表示了而已</p> 
<p><img src="https://images2.imgbox.com/82/fb/z0JWSDE0_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_204"></a>3.检查位姿的有效性</h3> 
<p><img src="https://images2.imgbox.com/a2/40/H25eOevt_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="__208"></a>五、 双目地图初始化：稀疏立体匹配</h2> 
<h3><a id="1_210"></a>1.双目相机</h3> 
<p><img src="https://images2.imgbox.com/2c/8a/1sWAJaV7_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_212"></a>2.稀疏立体匹配原理</h3> 
<p>函数ComputeStereoMatches()<br> 两帧图像稀疏立体匹配<br> *输入：两帧立体矫正后的图像对应的orb特征点集<br> *过程：<br> 1.行特征点统计<br> 2.粗匹配<br> 3.精确匹配SAD<br> 4.亚像素精度优化<br> 5.最有视差值/深度选择<br> 6.删除离缺点（outliers）<br> *输出：稀疏特征点视差图/深度图和匹配结果<br> <img src="https://images2.imgbox.com/18/57/MXeUv1uv_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_225"></a>3.亚像素插值</h3> 
<p><img src="https://images2.imgbox.com/01/15/eAS1zJSR_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9295d049a57474cba1bab7bec08184db/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Apollo配置改动动态加载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b1807ea19752705125ab4139242fad8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cookie是什么？有什么用？cookie详解，一篇文章彻底搞懂cookie</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>