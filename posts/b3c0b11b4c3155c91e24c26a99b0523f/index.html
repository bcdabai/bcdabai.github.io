<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>qt-事件循环系统 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="qt-事件循环系统" />
<meta property="og:description" content="Qt中，如果创建的console程序,使用的是QCoreApplication对象；如果创建的是GUI程序，使用的是QApplication对象，而QApplication 继承自 QGUIApplication ，最终继承QCoreApplication，GUI是对console的封装。
QEventDispatcherWin32（win32事件调度器），主要功能是执行程序运行期间所涉及到的过程事件以及创建windows的隐藏窗口。C:\Qt\5.9.8\Src\qtbase\src\corelib\kernel\qeventdispatcher_win.cpp 创建了一个隐藏窗口
static HWND qt_create_internal_window(const QEventDispatcherWin32 *eventDispatcher) { QWindowsMessageWindowClassContext *ctx = qWindowsMessageWindowClassContext(); if (!ctx-&gt;atom) return 0; HWND wnd = CreateWindow(ctx-&gt;className, // classname ctx-&gt;className, // window name 0, // style 0, 0, 0, 0, // geometry HWND_MESSAGE, // parent 0, // menu handle GetModuleHandle(0), // application 0); // windows creation data. if (!wnd) { qErrnoWarning(&#34;CreateWindow() for QEventDispatcherWin32 internal window failed&#34;); return 0; } #ifdef GWLP_USERDATA SetWindowLongPtr(wnd, GWLP_USERDATA, (LONG_PTR)eventDispatcher); #else SetWindowLong(wnd, GWL_USERDATA, (LONG)eventDispatcher); #endif return wnd; } QEventDispatcherWin32Private（win32事件调度器私有），主要存储了qt与windows操作系统之间的事件交互队列（用户输入事件队列、用户套接字事件队列）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b3c0b11b4c3155c91e24c26a99b0523f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-03T11:14:21+08:00" />
<meta property="article:modified_time" content="2022-05-03T11:14:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">qt-事件循环系统</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="586" src="https://images2.imgbox.com/86/a4/gZOvRfqZ_o.png" width="1046"></p> 
<p>        Qt中，如果创建的console程序,使用的是QCoreApplication对象；如果创建的是GUI程序，使用的是QApplication对象，而QApplication 继承自 QGUIApplication ，最终继承QCoreApplication，GUI是对console的封装。</p> 
<p>        QEventDispatcherWin32（win32事件调度器），主要功能是执行程序运行期间所涉及到的过程事件以及创建windows的隐藏窗口。C:\Qt\5.9.8\Src\qtbase\src\corelib\kernel\qeventdispatcher_win.cpp  创建了一个隐藏窗口</p> 
<pre><code>
static HWND qt_create_internal_window(const QEventDispatcherWin32 *eventDispatcher)
{
    QWindowsMessageWindowClassContext *ctx = qWindowsMessageWindowClassContext();
    if (!ctx-&gt;atom)
        return 0;
    HWND wnd = CreateWindow(ctx-&gt;className,    // classname
                            ctx-&gt;className,    // window name
                            0,                 // style
                            0, 0, 0, 0,        // geometry
                            HWND_MESSAGE,            // parent
                            0,                 // menu handle
                            GetModuleHandle(0),     // application
                            0);                // windows creation data.

    if (!wnd) {
        qErrnoWarning("CreateWindow() for QEventDispatcherWin32 internal window failed");
        return 0;
    }

#ifdef GWLP_USERDATA
    SetWindowLongPtr(wnd, GWLP_USERDATA, (LONG_PTR)eventDispatcher);
#else
    SetWindowLong(wnd, GWL_USERDATA, (LONG)eventDispatcher);
#endif

    return wnd;
}
</code></pre> 
<p>        QEventDispatcherWin32Private（win32事件调度器私有），主要存储了qt与windows操作系统之间的事件交互队列（<strong>用户输入事件队列、用户套接字事件队列</strong>）。</p> 
<p>        qt与windows之间使用MSG对象进行交互，MSG是windows的原生对象，qt 以QList&lt;MSG&gt;的方式来存储windows的事件对象，QEventDispatcherWin32Private提供了套接字\定时器相关的操作接口，和用户自定义的外部窗口所涉及到的事件队列：QWinEventNotifier,QSocketNotifier</p> 
<p>    QWinEventNotifier:用户自定义的窗口事件.</p> 
<p>      qt与windows交互时，主要用到了三个回调</p> 
<p>qt_internal_proc  解析windows系统给qt传输的MSG消息对象,qt解析MSG后进行相应的处理</p> 
<p>qt_GetMessageHook:qt 手动调用，向windows操作系统传输MSG消息对象</p> 
<p>qt_fast_timer_proc:主要用于工作线程，qt向操作系统传入定时器相关的数据</p> 
<p></p> 
<h2>数据存储 :QCoreApplication的初始化</h2> 
<p>        系统级EventLoop :qt系统是如何对接windows操作系统，存储和调度MSG</p> 
<p>        用户级EventLoop:qt内部的消息处理</p> 
<h3>qt  console程序</h3> 
<p><img alt="" height="563" src="https://images2.imgbox.com/3e/8e/HchI4RVf_o.png" width="1200"></p> 
<p></p> 
<p>C:\qt5base\qtbase\src\corelib\kernel\qcoreapplication.cpp</p> 
<p>        构造一个 Qt 核心应用程序。 核心应用是没有图形用户界面。 此类应用程序用于控制台或作为服务器进程。argc 和 argv 参数由应用程序处理，并通过 arguments() 以更方便的形式提供功能。</p> 
<pre><code>QCoreApplication::QCoreApplication(int &amp;argc, char **argv
#ifndef Q_QDOC
                                   , int _internal
#endif
                                   )
#ifdef QT_NO_QOBJECT
    : d_ptr(new QCoreApplicationPrivate(argc, argv, _internal))
#else

    //1 构建QCoreApplicationPrivate对象 并且传入命令行参数
    : QObject(*new QCoreApplicationPrivate(argc, argv, _internal))
#endif
{
    d_func()-&gt;q_ptr = this;
    //2 调用QCoreApplicationPrivate init函数  创建事件调度器
    d_func()-&gt;init();
#ifndef QT_NO_QOBJECT
    // 3 启动事件调度器
    QCoreApplicationPrivate::eventDispatcher-&gt;startingUp();
#endif
}</code></pre> 
<h4>调用 void QCoreApplicationPrivate::init() </h4> 
<pre><code>void QCoreApplicationPrivate::init()
{
#if defined(Q_OS_MACOS)
    QMacAutoReleasePool pool;
#endif

    Q_Q(QCoreApplication);

    initLocale();

    Q_ASSERT_X(!QCoreApplication::self, "QCoreApplication", "there should be only one application object");
    QCoreApplication::self = q;


    //1 设置应用名称和版本
    // Store app name/version (so they're still available after QCoreApplication is destroyed)
    if (!coreappdata()-&gt;applicationNameSet)
        coreappdata()-&gt;application = appName();

    if (!coreappdata()-&gt;applicationVersionSet)
        coreappdata()-&gt;applicationVersion = appVersion();

......

#ifndef QT_NO_QOBJECT

    // 2 创建事件调度器
    // use the event dispatcher created by the app programmer (if any)
    if (!eventDispatcher)//第一次threadData-&gt;eventDispatcher.load()返回为空
        eventDispatcher = threadData-&gt;eventDispatcher.load();
    // otherwise we create one
    if (!eventDispatcher)
        createEventDispatcher();//创建事件调度器
    Q_ASSERT(eventDispatcher);

    //3 将事件调度器的槽函数放到新的线程threadData-&gt;thread中
    if (!eventDispatcher-&gt;parent()) {
        eventDispatcher-&gt;moveToThread(threadData-&gt;thread);
        eventDispatcher-&gt;setParent(q);
    }

    //4 重置当前线程的事件调度器
    threadData-&gt;eventDispatcher = eventDispatcher;
    eventDispatcherReady();//事件调度器处于准备状态
#endif

#ifdef QT_EVAL
    extern void qt_core_eval_init(QCoreApplicationPrivate::Type);
    qt_core_eval_init(application_type);
#endif

    processCommandLineArguments();//处理命令行参数

    qt_call_pre_routines();
    qt_startup_hook();//启动hook 函数
#ifndef QT_BOOTSTRAPPED
    if (Q_UNLIKELY(qtHookData[QHooks::Startup]))
        reinterpret_cast&lt;QHooks::StartupCallback&gt;(qtHookData[QHooks::Startup])();
#endif

#ifndef QT_NO_QOBJECT
    is_app_running = true; // No longer starting up.
#endif
}
</code></pre> 
<p></p> 
<p>        事件调度器类型    static QAbstractEventDispatcher *eventDispatcher;，它继承于QObject；</p> 
<p>         QThreadData *threadData; // id of the thread that owns the object  位于QObjectPrivate中（它继承QObject）</p> 
<h4>createEventDispatcher</h4> 
<p>        系统创建事件调度器：void QCoreApplicationPrivate::createEventDispatcher()，在windows屏幕创建的是    eventDispatcher = new QEventDispatcherWin32(q);  QEventDispatcherWin32 :公有继承 QAbstractEventDispatcher</p> 
<pre><code>void QCoreApplicationPrivate::createEventDispatcher()
{
    Q_Q(QCoreApplication);
#if defined(Q_OS_UNIX)
#  if defined(Q_OS_DARWIN)
    bool ok = false;
    int value = qEnvironmentVariableIntValue("QT_EVENT_DISPATCHER_CORE_FOUNDATION", &amp;ok);
    if (ok &amp;&amp; value &gt; 0)
        eventDispatcher = new QEventDispatcherCoreFoundation(q);
    else
        eventDispatcher = new QEventDispatcherUNIX(q);
#  elif !defined(QT_NO_GLIB)
    if (qEnvironmentVariableIsEmpty("QT_NO_GLIB") &amp;&amp; QEventDispatcherGlib::versionSupported())
        eventDispatcher = new QEventDispatcherGlib(q);
    else
        eventDispatcher = new QEventDispatcherUNIX(q);
#  else
        eventDispatcher = new QEventDispatcherUNIX(q);
#  endif
#elif defined(Q_OS_WINRT)
    eventDispatcher = new QEventDispatcherWinRT(q);
#elif defined(Q_OS_WIN)
    eventDispatcher = new QEventDispatcherWin32(q);
#else
#  error "QEventDispatcher not yet ported to this platform"
#endif
}</code></pre> 
<p></p> 
<p>C:\Qt\5.9.8\Src\qtbase\src\corelib\kernel\qeventdispatcher_win.cpp</p> 
<p>在QEventDispatcherWin32构造函数中，并没有什么操作，仅仅创建了QEventDispatcherWin32Private的实例对象</p> 
<pre><code>QEventDispatcherWin32::QEventDispatcherWin32(QEventDispatcherWin32Private &amp;dd, QObject *parent)
    : QAbstractEventDispatcher(dd, parent)
{ }</code></pre> 
<p>QEventDispatcherWin32Private 也没有实质操作 </p> 
<pre><code>QEventDispatcherWin32Private::QEventDispatcherWin32Private()
    : threadId(GetCurrentThreadId()), interrupt(false), closingDown(false), internalHwnd(0),
      getMessageHook(0), serialNumber(0), lastSerialNumber(0), sendPostedEventsWindowsTimerId(0),
      wakeUps(0)
    , activateNotifiersPosted(false)
{
}</code></pre> 
<p></p> 
<p>QEventDispatcherWin32Private 的定义：</p> 
<pre><code>class Q_CORE_EXPORT QEventDispatcherWin32Private : public QAbstractEventDispatcherPrivate
{
    Q_DECLARE_PUBLIC(QEventDispatcherWin32)
public:
    QEventDispatcherWin32Private();
    ~QEventDispatcherWin32Private();

    DWORD threadId;

    bool interrupt;
    bool closingDown;
 
    //用于 socketnotifiers/timers/etc 的内部窗口句柄
    // internal window handle used for socketnotifiers/timers/etc
    HWND internalHwnd;
    HHOOK getMessageHook;

    //用于控制何时发送发布的事件
    // for controlling when to send posted events
    QAtomicInt serialNumber;
    int lastSerialNumber, sendPostedEventsWindowsTimerId;
    QAtomicInt wakeUps;

    // timers  定时器
    WinTimerVec timerVec;
    WinTimerDict timerDict;
    void registerTimer(WinTimerInfo *t);
    void unregisterTimer(WinTimerInfo *t);
    void sendTimerEvent(int timerId);

    // socket notifiers  socket通知
    QSNDict sn_read;
    QSNDict sn_write;
    QSNDict sn_except;
    QSFDict active_fd;
    bool activateNotifiersPosted;
    void postActivateSocketNotifiers();
    void doWsaAsyncSelect(int socket, long event);

    QList&lt;QWinEventNotifier *&gt; winEventNotifierList;//QWinEventNotifier 列表
    void activateEventNotifier(QWinEventNotifier * wen);

    QList&lt;MSG&gt; queuedUserInputEvents;//用户输入事件队列
    QList&lt;MSG&gt; queuedSocketEvents;//socket事件队列
};</code></pre> 
<h2>事件循环启动过程</h2> 
<p>        QCoreApplication 在初始化时，会创建win32事件调度器QEventDispatcherWin32，QEventDispatcherWin32</p> 
<pre><code>
class Q_CORE_EXPORT QEventDispatcherWin32 : public QAbstractEventDispatcher
{
    Q_OBJECT
    Q_DECLARE_PRIVATE(QEventDispatcherWin32)

protected:
    void createInternalHwnd();
    void installMessageHook();
    void uninstallMessageHook();

public:
    explicit QEventDispatcherWin32(QObject *parent = 0);
    ~QEventDispatcherWin32();

    bool QT_ENSURE_STACK_ALIGNED_FOR_SSE processEvents(QEventLoop::ProcessEventsFlags flags);
    bool hasPendingEvents();

    void registerSocketNotifier(QSocketNotifier *notifier);
    void unregisterSocketNotifier(QSocketNotifier *notifier);

    void registerTimer(int timerId, int interval, Qt::TimerType timerType, QObject *object);
    bool unregisterTimer(int timerId);
    bool unregisterTimers(QObject *object);
    QList&lt;TimerInfo&gt; registeredTimers(QObject *object) const;

    bool registerEventNotifier(QWinEventNotifier *notifier);
    void unregisterEventNotifier(QWinEventNotifier *notifier);
    void activateEventNotifiers();

    int remainingTime(int timerId);

    void wakeUp();
    void interrupt();
    void flush();

    void startingUp();
    void closingDown();

    bool event(QEvent *e);

    HWND internalHwnd();

protected:
    QEventDispatcherWin32(QEventDispatcherWin32Private &amp;dd, QObject *parent = 0);
    virtual void sendPostedEvents();
    void doUnregisterSocketNotifier(QSocketNotifier *notifier);

private:
    friend LRESULT QT_WIN_CALLBACK qt_internal_proc(HWND hwnd, UINT message, WPARAM wp, LPARAM lp);
    friend LRESULT QT_WIN_CALLBACK qt_GetMessageHook(int, WPARAM, LPARAM);
};</code></pre> 
<p></p> 
<p></p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/ac/03/zN3OiOZ8_o.png" width="1200"></p> 
<h3> QCoreApplication调用exec接口完成程序的启动：</h3> 
<p><br>     进入主事件循环并等待直到 exit() 被调用。 需要调用此函数来启动事件处理。主事件循环从窗口系统接收事件并将这些分派给应用程序小部件。使您的应用程序执行空闲处理（通过执行<br> 每当没有未决事件时的特殊功能），使用超时时间为 0 的 QTimer。更高级的空闲处理方案可以<br> 使用 processEvents() 来实现。</p> 
<pre><code>int QCoreApplication::exec()
{
    //1 检查自身实例是否已经存在
    if (!QCoreApplicationPrivate::checkInstance("exec"))
        return -1;


    //2 检查QCoreApplication对象是否位于主线程中
    QThreadData *threadData = self-&gt;d_func()-&gt;threadData;
    if (threadData != QThreadData::current()) {
        qWarning("%s::exec: Must be called from the main thread", self-&gt;metaObject()-&gt;className());
        return -1;
    }

    //3 检查主线程中是否已经存在事件调度器
    if (!threadData-&gt;eventLoops.isEmpty()) {
        qWarning("QCoreApplication::exec: The event loop is already running");
        return -1;
    }

    //4 创建事件调度器 并且启动时间调度器
    threadData-&gt;quitNow = false;
    QEventLoop eventLoop;
    self-&gt;d_func()-&gt;in_exec = true;
    self-&gt;d_func()-&gt;aboutToQuitEmitted = false;
    int returnCode = eventLoop.exec();
    threadData-&gt;quitNow = false;


    //5 程序退出，执行清理操作
    if (self)
        self-&gt;d_func()-&gt;execCleanup();

    return returnCode;
}</code></pre> 
<p></p> 
<h3>int QEventLoop::exec(ProcessEventsFlags flags)</h3> 
<h4>QEventLoop 做了什么</h4> 
<p><br> 先看构造函数：</p> 
<pre><code>QEventLoop::QEventLoop(QObject *parent)
    : QObject(*new QEventLoopPrivate, parent)
{
    Q_D(QEventLoop);
    //QApplication是所有线程共享的对象，全局且唯一  
    if (!QCoreApplication::instance()) {
        qWarning("QEventLoop: Cannot be used without QApplication");
    } else if (!d-&gt;threadData-&gt;eventDispatcher.load()) {
    //如果当前线程还没有事件派发器，那就创建一个
        QThreadPrivate::createEventDispatcher(d-&gt;threadData);
    }
}</code></pre> 
<p><br>         一，QApplication是所有线程共享的对象，全局且唯一 ；</p> 
<p>        二，一个线程有且只有一个eventDispatcher，如果不存在，则创建一个。而且，由于QEventLoop不能在QApplication之前创建，所以，如果QEventLoop是在GUI线程中构造，那么eventDispatcher早在QApplication构造时就被创建了，所以免了自己创建eventDispatcher的步骤。如果QEventLoop是在非GUI线程中构造呢？这种情况肯定是存在的，因为非GUI线程可能也需要处理事件，这些事件不是来自可见窗口，而是来自自己或其他线程。例如，使用跨线程的信号和槽（如postEvent 跨线程调用时，发送者将Post事件发到接收者的postevent列表中，然后调用接收者的事件分发器的wakeup，使得接收者的消息循环处理事件，在下面的Postevent的实现中有讲述）。下面看看在非GUI下的QEventLoop：</p> 
<pre><code>class MyThread :public QThread
{
    void run() Q_DECL_OVERRIDE{
        //start a event loop
        this-&gt;exec();
    }
 
};
 
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
 
    MyThread t;
    t.start();
 
    return a.exec();
}</code></pre> 
<p><br>         现在，程序有两个线程，一个是GUI线程，一个是线程t。GUI线程有一个事件循环，在a.exec中创建并启动，线程t也有一个事件循环，在t.exec中创建并启动。</p> 
<p>        就像在GUI线程中的事件循环需要使用一个事件派发器一样，任何一个线程中的事件循环都需要一个派发器。GUI线程中的事件派发器是在构造QApplication时创建的，是一个QWindowsGuiEventDispatcher类的派发器，在这个派发器的构造函数中同时还创建了一个message-only窗口。</p> 
<p>        对于需要事件循环的非GUI线程，message-only窗口是不可或缺的，因为没有他，线程就没有消息队列，何谈消息循环，除非Qt使用另外的机制而非消息循环机制来支持非GUI线程的事件循环，不过这完全没必要。我们来看看这些步骤在非GUI线程中是怎么完成的：</p> 
<p>        第一步，创建一个事件派发器</p> 
<p>事件派发器在t.start中被创建：</p> 
<pre><code>unsigned int __stdcall QT_ENSURE_STACK_ALIGNED_FOR_SSE QThreadPrivate::start(void *arg)
{
    QThread *thr = reinterpret_cast&lt;QThread *&gt;(arg);
    QThreadData *data = QThreadData::get2(thr);
 
    qt_create_tls();
    TlsSetValue(qt_current_thread_data_tls_index, data);
    data-&gt;threadId = reinterpret_cast&lt;Qt::HANDLE&gt;(GetCurrentThreadId());
  ...
    if (data-&gt;eventDispatcher.load()) // custom event dispatcher set?
        data-&gt;eventDispatcher.load()-&gt;startingUp();
    else
        createEventDispatcher(data); //创建事件派发器
  ...
}</code></pre> 
<p><br>         创建的是一个QEventDispatcherWin32类的事件派发器，它并不像QWindowsGuiEventDispatcher一样在构造的同时还创建 message-only 窗口。</p> 
<p>第二步，创建一个 message-only 窗口</p> 
<p>        如果在启动事件循环的过程中发现当前的事件派发器还没有创建 message-only 窗口的话，那就会为其创建一个这样的窗口。</p> 
<pre><code>bool QEventDispatcherWin32::processEvents(QEventLoop::ProcessEventsFlags flags)
{
      Q_D(QEventDispatcherWin32);
 
    if (!d-&gt;internalHwnd) {
        createInternalHwnd();
        wakeUp(); // trigger a call to sendPostedEvents()
    }
 ...
}</code></pre> 
<p><br>         对比GUI线程创建事件派发器和message-only窗口的一步到位，非GUI线程采用延迟的方式来处理。为什么要这样做呢？像GUI线程一步到位不行吗？当然可以，但是没必要，因为创建一个 message-only 窗口是要占用内核资源的，GUI线程一定需要一个消息循环来实现事件循环，所以一步到位的创建没毛病，但是非GUI线程可能根本就不需要一个事件循环，所以，白白浪费资源干嘛呢？</p> 
<p><strong>int QEventLoop::exec(ProcessEventsFlags flags)</strong></p> 
<p>         进入主事件循环并等待直到 exit() 被调用。返回传递给 exit() 的值。需要调用此函数来启动事件处理。 这主事件循环从窗口系统接收事件并将这些分派给应用程序小部件。</p> 
<p>         一般来说，之前不能进行任何用户交互调用 exec()。 作为一个特例，像 QMessageBox 这样的模态小部件可以在调用 exec() 之前使用，因为模态小部件使用他们自己的本地事件循环。</p> 
<pre><code>int QEventLoop::exec(ProcessEventsFlags flags)
{
    Q_D(QEventLoop);
    //we need to protect from race condition with QThread::exit
    QMutexLocker locker(&amp;static_cast&lt;QThreadPrivate *&gt;(QObjectPrivate::get(d-&gt;threadData-&gt;thread))-&gt;mutex);
    if (d-&gt;threadData-&gt;quitNow)
        return -1;

    if (d-&gt;inExec) {
        qWarning("QEventLoop::exec: instance %p has already called exec()", this);
        return -1;
    }

    struct LoopReference {
        QEventLoopPrivate *d;
        QMutexLocker &amp;locker;

        bool exceptionCaught;
        LoopReference(QEventLoopPrivate *d, QMutexLocker &amp;locker) : d(d), locker(locker), exceptionCaught(true)
        {
            d-&gt;inExec = true;
            d-&gt;exit.storeRelease(false);
            ++d-&gt;threadData-&gt;loopLevel;
//将事件循环器添加到该线程的事件循环器容器中：
            d-&gt;threadData-&gt;eventLoops.push(d-&gt;q_func());
            locker.unlock();
        }

        ~LoopReference()
        {
            if (exceptionCaught) {
                qWarning("Qt has caught an exception thrown from an event handler. Throwing\n"
                         "exceptions from an event handler is not supported in Qt.\n"
                         "You must not let any exception whatsoever propagate through Qt code.\n"
                         "If that is not possible, in Qt 5 you must at least reimplement\n"
                         "QCoreApplication::notify() and catch all exceptions there.\n");
            }
            locker.relock();
            QEventLoop *eventLoop = d-&gt;threadData-&gt;eventLoops.pop();
            Q_ASSERT_X(eventLoop == d-&gt;q_func(), "QEventLoop::exec()", "internal error");
            Q_UNUSED(eventLoop); // --release warning
            d-&gt;inExec = false;
            --d-&gt;threadData-&gt;loopLevel;
        }
    };
    LoopReference ref(d, locker);


   // 判断当前线程是不是主线程，如果不是则清除 QEvent::Quit事件
    // remove posted quit events when entering a new event loop
    QCoreApplication *app = QCoreApplication::instance();
    if (app &amp;&amp; app-&gt;thread() == thread())
        QCoreApplication::removePostedEvents(app, QEvent::Quit);

   //循环：如果程序没有退出，则循环执行processEvents：flags此时默认值是AllEvents
   //执行所有事件
    while (!d-&gt;exit.loadAcquire())
        processEvents(flags | WaitForMoreEvents | EventLoopExec);

    ref.exceptionCaught = false;
    return d-&gt;returnCode.load();
}
</code></pre> 
<p></p> 
<h3>bool QEventLoop::processEvents(ProcessEventsFlags flags)</h3> 
<p>        处理匹配 flags标志的未决事件，直到没有更多要处理的事件。 如果处理了未决事件，则返回 true；否则返回 false。</p> 
<p>     这个函数只是一个包装器 ,具体由QAbstractEventDispatcher::processEvents()执行</p> 
<pre><code>bool QEventLoop::processEvents(ProcessEventsFlags flags)
{
    Q_D(QEventLoop);
    //检查QEventLoopPrivate中的事件调度器是否存在
    if (!d-&gt;threadData-&gt;eventDispatcher.load())
        return false;

    //调用事件调度器处理函数
    return d-&gt;threadData-&gt;eventDispatcher.load()-&gt;processEvents(flags);
}</code></pre> 
<p>在windows平台 即bool QEventDispatcherWin32::processEvents(QEventLoop::ProcessEventsFlags flags)</p> 
<p></p> 
<h3>QEventDispatcherWin32::processEvents</h3> 
<p>        QEventDispatcherWin32 由 createEventDispatcher接口在主线程中由void QCoreApplicationPrivate::init()中创建；</p> 
<p>        同时，如果是创建一个线程，那么在QThread调用windows api创建线程传递函数地址QThreadPriavate::start中，也会创建：</p> 
<p><img alt="" height="1150" src="https://images2.imgbox.com/6e/d1/X3jZamhR_o.png" width="1200"></p> 
<p>         createEventDispatcher在windows平台仅仅是创建了一个QEventDispatcherWin32实例对象，并没有其他操作；QEventDispatcherWin32的事件处理过程是通过 （主）线程调用exec函数最终调用bool QEventDispatcherWin32::processEvents(QEventLoop::ProcessEventsFlags flags)来完成的。</p> 
<p>C:\Qt\5.9.8\Src\qtbase\src\corelib\kernel\qeventdispatcher_win.cpp</p> 
<p>        QEventDispatcherWin32 的d 指针QEventDispatcherWin32Private对象中存储了</p> 
<pre><code>    QList&lt;MSG&gt; queuedUserInputEvents;//用户输入事件队列
    QList&lt;MSG&gt; queuedSocketEvents;//socket事件队列</code></pre> 
<p>        QEventDispatcherWin32 的主要作用是使得QT系统 和windows系统进行数据的交互，使用的MSG消息对象。</p> 
<pre><code>
bool QEventDispatcherWin32::processEvents(QEventLoop::ProcessEventsFlags flags)
{

    //1 获取QEventDispatcherWin32Private对象
    Q_D(QEventDispatcherWin32);

    //2 检测QEventDispatcherWin32Private对象是否已经创建了隐藏窗口，
       //如果没有则创建隐藏窗口
    if (!d-&gt;internalHwnd) {
        createInternalHwnd();
        wakeUp(); // trigger a call to sendPostedEvents()
    }

    d-&gt;interrupt = false;
    //3 发送隐藏窗口已创建的信号
    emit awake();

    bool canWait;
    bool retVal = false;
    bool seenWM_QT_SENDPOSTEDEVENTS = false;
    bool needWM_QT_SENDPOSTEDEVENTS = false;
    do {
        DWORD waitRet = 0;
        HANDLE pHandles[MAXIMUM_WAIT_OBJECTS - 1];
        QVarLengthArray&lt;MSG&gt; processedTimers;
        while (!d-&gt;interrupt) {
            DWORD nCount = d-&gt;winEventNotifierList.count();
            Q_ASSERT(nCount &lt; MAXIMUM_WAIT_OBJECTS - 1);

            MSG msg;
            bool haveMessage;


            //4 对两个队列中的数据分别进行处理
                 //检查用户输入事件队列是否为空
            if (!(flags &amp; QEventLoop::ExcludeUserInputEvents) &amp;&amp; !d-&gt;queuedUserInputEvents.isEmpty()) {
                // process queued user input events
                //处理输入事件，获取队列中最先来的事件
                haveMessage = true;
                msg = d-&gt;queuedUserInputEvents.takeFirst();
               //检查socket消息事件队列
            } else if(!(flags &amp; QEventLoop::ExcludeSocketNotifiers) &amp;&amp; !d-&gt;queuedSocketEvents.isEmpty()) {
                // process queued socket events
                haveMessage = true;
                msg = d-&gt;queuedSocketEvents.takeFirst();
            } else {
                //检查消息队列中事件的可用性：PM_REMOVE PeekMessage处理后，消息从队列里除掉。
                haveMessage = PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE);
                //如果有消息，判断消息类型
                if (haveMessage) {
                    //将可用的事件进行转化，重新添加到 用户输入事件或者socket事件中
                    if ((flags &amp; QEventLoop::ExcludeUserInputEvents)
                        &amp;&amp; ((msg.message &gt;= WM_KEYFIRST
                             &amp;&amp; msg.message &lt;= WM_KEYLAST)
                            || (msg.message &gt;= WM_MOUSEFIRST
                                &amp;&amp; msg.message &lt;= WM_MOUSELAST)
                            || msg.message == WM_MOUSEWHEEL
                            || msg.message == WM_MOUSEHWHEEL
                            || msg.message == WM_TOUCH
#ifndef QT_NO_GESTURES
                            || msg.message == WM_GESTURE
                            || msg.message == WM_GESTURENOTIFY
#endif
                            || msg.message == WM_CLOSE)) {
                        // queue user input events for later processing
                        d-&gt;queuedUserInputEvents.append(msg);
                        continue;//跳过此次循环
                    }
                    if ((flags &amp; QEventLoop::ExcludeSocketNotifiers)
                        &amp;&amp; (msg.message == WM_QT_SOCKETNOTIFIER &amp;&amp; msg.hwnd == d-&gt;internalHwnd)) {
                        // queue socket events for later processing
                        d-&gt;queuedSocketEvents.append(msg);
                        continue;
                    }
                }
            }

            // 5 如果消息无效，进行下列操作
            if (!haveMessage) {
                // no message - check for signalled objects
                for (int i=0; i&lt;(int)nCount; i++)
                    pHandles[i] = d-&gt;winEventNotifierList.at(i)-&gt;handle();
                waitRet = MsgWaitForMultipleObjectsEx(nCount, pHandles, 0, QS_ALLINPUT, MWMO_ALERTABLE);
                if ((haveMessage = (waitRet == WAIT_OBJECT_0 + nCount))) {
                    // a new message has arrived, process it
                    continue;
                }
            }

            // 6 如果消息有效
            if (haveMessage) {
                // WinCE doesn't support hooks at all, so we have to call this by hand :(
                if (!d-&gt;getMessageHook)
                    (void) qt_GetMessageHook(0, PM_REMOVE, (LPARAM) &amp;msg);

                if (d-&gt;internalHwnd == msg.hwnd &amp;&amp; msg.message == WM_QT_SENDPOSTEDEVENTS) {
                    if (seenWM_QT_SENDPOSTEDEVENTS) {
                        // when calling processEvents() "manually", we only want to send posted
                        // events once
                        needWM_QT_SENDPOSTEDEVENTS = true;
                        continue;
                    }
                    seenWM_QT_SENDPOSTEDEVENTS = true;

                //如果消息是定时器或退出操作，则执行相应的操作
                } else if (msg.message == WM_TIMER) {
                    // avoid live-lock by keeping track of the timers we've already sent
                    bool found = false;
                    for (int i = 0; !found &amp;&amp; i &lt; processedTimers.count(); ++i) {
                        const MSG processed = processedTimers.constData()[i];
                        found = (processed.wParam == msg.wParam &amp;&amp; processed.hwnd == msg.hwnd &amp;&amp; processed.lParam == msg.lParam);
                    }
                    if (found)
                        continue;
                    processedTimers.append(msg);
                } else if (msg.message == WM_QUIT) {
                    if (QCoreApplication::instance())
                        QCoreApplication::instance()-&gt;quit();
                    return false;
                }

                //过滤消息
                if (!filterNativeEvent(QByteArrayLiteral("windows_generic_MSG"), &amp;msg, 0)) {
                    TranslateMessage(&amp;msg);
                    DispatchMessage(&amp;msg);
                }
		    //检查数量，如果数量不对，激活本地事件过滤器
            } else if (waitRet - WAIT_OBJECT_0 &lt; nCount) {
                d-&gt;activateEventNotifier(d-&gt;winEventNotifierList.at(waitRet - WAIT_OBJECT_0));
            } else {
                // nothing todo so break
                break;
            }
            retVal = true;
        }

        // still nothing - wait for message or signalled objects
        canWait = (!retVal
                   &amp;&amp; !d-&gt;interrupt
                   &amp;&amp; (flags &amp; QEventLoop::WaitForMoreEvents));
        if (canWait) {
            DWORD nCount = d-&gt;winEventNotifierList.count();
            Q_ASSERT(nCount &lt; MAXIMUM_WAIT_OBJECTS - 1);
            for (int i=0; i&lt;(int)nCount; i++)
                pHandles[i] = d-&gt;winEventNotifierList.at(i)-&gt;handle();

            emit aboutToBlock();
            waitRet = MsgWaitForMultipleObjectsEx(nCount, pHandles, INFINITE, QS_ALLINPUT, MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);
            emit awake();
            if (waitRet - WAIT_OBJECT_0 &lt; nCount) {
                d-&gt;activateEventNotifier(d-&gt;winEventNotifierList.at(waitRet - WAIT_OBJECT_0));
                retVal = true;
            }
        }
    } while (canWait);

    if (!seenWM_QT_SENDPOSTEDEVENTS &amp;&amp; (flags &amp; QEventLoop::EventLoopExec) == 0) {
        // when called "manually", always send posted events
        sendPostedEvents();//发送当前线程中,postevent事件队列中所有剩余的post事件到操作系统中
    }

    if (needWM_QT_SENDPOSTEDEVENTS)
        PostMessage(d-&gt;internalHwnd, WM_QT_SENDPOSTEDEVENTS, 0, 0);

    return retVal;
}
</code></pre> 
<p></p> 
<h4>创建隐藏窗口的过程 QEventDispatcherWin32::createInternalHwnd()</h4> 
<p>        qt获取windows系统的消息主要是通过windows原生接口来获取消息数据，从而对消息进行解包，分类，从而将数据发送到qt系统处理</p> 
<p>        qt向windows传递事件消息，主要是通过向windows系统中安装挂钩，从而进一步通过事先创建的隐藏窗口将qt本身的 事件打包，进一步通过隐藏窗口进行事件的转发,传输到windows操作系统</p> 
<pre><code>void QEventDispatcherWin32::createInternalHwnd()
{
    Q_D(QEventDispatcherWin32);

    if (d-&gt;internalHwnd)
        return;
   
    //1 创建 windows原生窗口
    d-&gt;internalHwnd = qt_create_internal_window(this);

    //2 安装消息钩子
    installMessageHook();

    // start all normal timers
    for (int i = 0; i &lt; d-&gt;timerVec.count(); ++i)
        d-&gt;registerTimer(d-&gt;timerVec.at(i));
}

</code></pre> 
<p></p> 
<p><strong>创建windows原生窗口，</strong>一些自定义消息都是在这个窗口的过程回调中处理</p> 
<pre><code>
static HWND qt_create_internal_window(const QEventDispatcherWin32 *eventDispatcher)
{
    // 1 创建一个windows 消息上下文对象
    QWindowsMessageWindowClassContext *ctx = qWindowsMessageWindowClassContext();
    if (!ctx-&gt;atom)
        return 0;

    //2 创建一个大小为0x0 的窗口
    HWND wnd = CreateWindow(ctx-&gt;className,    // classname
                            ctx-&gt;className,    // window name
                            0,                 // style
                            0, 0, 0, 0,        // geometry
                            HWND_MESSAGE,            // parent
                            0,                 // menu handle
                            GetModuleHandle(0),     // application
                            0);                // windows creation data.

    if (!wnd) {
        qErrnoWarning("CreateWindow() for QEventDispatcherWin32 internal window failed");
        return 0;
    }

#ifdef GWLP_USERDATA
    SetWindowLongPtr(wnd, GWLP_USERDATA, (LONG_PTR)eventDispatcher);
#else
    SetWindowLong(wnd, GWL_USERDATA, (LONG)eventDispatcher);
#endif

    return wnd;
}
</code></pre> 
<p></p> 
<p><strong>QWindowsMessageWindowClassContext  在windows消息的上下文对象中，首先完成类名的注册，其中窗口过程函数是qt_internal_proc</strong></p> 
<pre><code>QWindowsMessageWindowClassContext::QWindowsMessageWindowClassContext()
    : atom(0), className(0)
{
    // make sure that multiple Qt's can coexist in the same process
    const QString qClassName = QStringLiteral("QEventDispatcherWin32_Internal_Widget")
        + QString::number(quintptr(qt_internal_proc));
    className = new wchar_t[qClassName.size() + 1];
    qClassName.toWCharArray(className);
    className[qClassName.size()] = 0;

    WNDCLASS wc;
    wc.style = 0;
    wc.lpfnWndProc = qt_internal_proc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = GetModuleHandle(0);
    wc.hIcon = 0;
    wc.hCursor = 0;
    wc.hbrBackground = 0;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = className;
    atom = RegisterClass(&amp;wc);
    if (!atom) {
        qErrnoWarning("%s RegisterClass() failed", qPrintable(qClassName));
        delete [] className;
        className = 0;
    }
}</code></pre> 
<p><strong>窗口过程函数：获取windows系统传递到qt系统的 MSG消息对象，进行解析，并且传递到qt系统进行相应的处理。</strong></p> 
<p>socket消息，也是Qt内部自定义的消息WM_QT_SOCKETNOTIFIER<br> postEvent到一些对象的消息，也是自定义消息WM_QT_SENDPOSTEDEVENTS<br> 通过QObject注册的定时器消息WM_TIMER</p> 
<pre><code>
LRESULT QT_WIN_CALLBACK qt_internal_proc(HWND hwnd, UINT message, WPARAM wp, LPARAM lp)
{
    if (message == WM_NCCREATE)
        return true;

    MSG msg;
    msg.hwnd = hwnd;
    msg.message = message;
    msg.wParam = wp;
    msg.lParam = lp;
    QAbstractEventDispatcher* dispatcher = QAbstractEventDispatcher::instance();
    long result;
    if (!dispatcher) {
        if (message == WM_TIMER)
            KillTimer(hwnd, wp);
        return 0;
    } else if (dispatcher-&gt;filterNativeEvent(QByteArrayLiteral("windows_dispatcher_MSG"), &amp;msg, &amp;result)) {
        return result;
    }

#ifdef GWLP_USERDATA
    QEventDispatcherWin32 *q = (QEventDispatcherWin32 *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
    QEventDispatcherWin32 *q = (QEventDispatcherWin32 *) GetWindowLong(hwnd, GWL_USERDATA);
#endif
    QEventDispatcherWin32Private *d = 0;
    if (q != 0)
        d = q-&gt;d_func();

    if (message == WM_QT_SOCKETNOTIFIER) {
        // socket notifier message
        int type = -1;
        switch (WSAGETSELECTEVENT(lp)) {
        case FD_READ:
        case FD_ACCEPT:
            type = 0;
            break;
        case FD_WRITE:
        case FD_CONNECT:
            type = 1;
            break;
        case FD_OOB:
            type = 2;
            break;
        case FD_CLOSE:
            type = 3;
            break;
        }
        if (type &gt;= 0) {
            Q_ASSERT(d != 0);
            QSNDict *sn_vec[4] = { &amp;d-&gt;sn_read, &amp;d-&gt;sn_write, &amp;d-&gt;sn_except, &amp;d-&gt;sn_read };
            QSNDict *dict = sn_vec[type];

            QSockNot *sn = dict ? dict-&gt;value(wp) : 0;
            if (sn == nullptr) {
                d-&gt;postActivateSocketNotifiers();
            } else {
                Q_ASSERT(d-&gt;active_fd.contains(sn-&gt;fd));
                QSockFd &amp;sd = d-&gt;active_fd[sn-&gt;fd];
                if (sd.selected) {
                    Q_ASSERT(sd.mask == 0);
                    d-&gt;doWsaAsyncSelect(sn-&gt;fd, 0);
                    sd.selected = false;
                }
                d-&gt;postActivateSocketNotifiers();

                // Ignore the message if a notification with the same type was
                // received previously. Suppressed message is definitely spurious.
                const long eventCode = WSAGETSELECTEVENT(lp);
                if ((sd.mask &amp; eventCode) != eventCode) {
                    sd.mask |= eventCode;
                    QEvent event(type &lt; 3 ? QEvent::SockAct : QEvent::SockClose);
                    QCoreApplication::sendEvent(sn-&gt;obj, &amp;event);
                }
            }
        }
        return 0;
    } else if (message == WM_QT_ACTIVATENOTIFIERS) {
        Q_ASSERT(d != 0);

        // Postpone activation if we have unhandled socket notifier messages
        // in the queue. WM_QT_ACTIVATENOTIFIERS will be posted again as a result of
        // event processing.
        MSG msg;
        if (!PeekMessage(&amp;msg, d-&gt;internalHwnd,
                         WM_QT_SOCKETNOTIFIER, WM_QT_SOCKETNOTIFIER, PM_NOREMOVE)
            &amp;&amp; d-&gt;queuedSocketEvents.isEmpty()) {
            // register all socket notifiers
            for (QSFDict::iterator it = d-&gt;active_fd.begin(), end = d-&gt;active_fd.end();
                 it != end; ++it) {
                QSockFd &amp;sd = it.value();
                if (!sd.selected) {
                    d-&gt;doWsaAsyncSelect(it.key(), sd.event);
                    // allow any event to be accepted
                    sd.mask = 0;
                    sd.selected = true;
                }
            }
        }
        d-&gt;activateNotifiersPosted = false;
        return 0;
    } else if (message == WM_QT_SENDPOSTEDEVENTS
               // we also use a Windows timer to send posted events when the message queue is full
               || (message == WM_TIMER
                   &amp;&amp; d-&gt;sendPostedEventsWindowsTimerId != 0
                   &amp;&amp; wp == (uint)d-&gt;sendPostedEventsWindowsTimerId)) {
        const int localSerialNumber = d-&gt;serialNumber.load();
        if (localSerialNumber != d-&gt;lastSerialNumber) {
            d-&gt;lastSerialNumber = localSerialNumber;
            q-&gt;sendPostedEvents();
        }
        return 0;
    } else if (message == WM_TIMER) {
        Q_ASSERT(d != 0);
        d-&gt;sendTimerEvent(wp);
        return 0;
    }

    return DefWindowProc(hwnd, message, wp, lp);
}</code></pre> 
<p></p> 
<p><strong>安装消息钩子，将qt的钩子函数qt_GetMessageHook添加到系统hooks中， 监听当前程序中该线程中的所有事件</strong></p> 
<p><strong>       SetWindowsHookEx </strong>钩子(Hook)，是Windows消息处理机制的一个平台，应用程序可以在上面设置子程以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它。钩子机制允许应用程序截获处理window消息或特定事件。</p> 
<pre><code>void QEventDispatcherWin32::installMessageHook()
{
    Q_D(QEventDispatcherWin32);

    if (d-&gt;getMessageHook)
        return;

    // setup GetMessage hook needed to drive our posted events
    d-&gt;getMessageHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC) qt_GetMessageHook, NULL, GetCurrentThreadId());
    if (Q_UNLIKELY(!d-&gt;getMessageHook)) {
        int errorCode = GetLastError();
        qFatal("Qt: INTERNAL ERROR: failed to install GetMessage hook: %d, %s",
               errorCode, qPrintable(qt_error_string(errorCode)));
    }
}</code></pre> 
<pre><code>
LRESULT QT_WIN_CALLBACK qt_GetMessageHook(int code, WPARAM wp, LPARAM lp)
{

    //1 获取事件调度器
    QEventDispatcherWin32 *q = qobject_cast&lt;QEventDispatcherWin32 *&gt;(QAbstractEventDispatcher::instance());
    Q_ASSERT(q != 0);

    if (wp == PM_REMOVE) {
        if (q) {
            MSG *msg = (MSG *) lp;
            QEventDispatcherWin32Private *d = q-&gt;d_func();
            const int localSerialNumber = d-&gt;serialNumber.load();
            static const UINT mask = inputTimerMask();
            if (HIWORD(GetQueueStatus(mask)) == 0) {
                // no more input or timer events in the message queue, we can allow posted events to be sent normally now
                if (d-&gt;sendPostedEventsWindowsTimerId != 0) {
                    // stop the timer to send posted events, since we now allow the WM_QT_SENDPOSTEDEVENTS message
                    KillTimer(d-&gt;internalHwnd, d-&gt;sendPostedEventsWindowsTimerId);
                    d-&gt;sendPostedEventsWindowsTimerId = 0;
                }
                (void) d-&gt;wakeUps.fetchAndStoreRelease(0);
                if (localSerialNumber != d-&gt;lastSerialNumber
                    // if this message IS the one that triggers sendPostedEvents(), no need to post it again
                    &amp;&amp; (msg-&gt;hwnd != d-&gt;internalHwnd
                        || msg-&gt;message != WM_QT_SENDPOSTEDEVENTS)) {

                   //使用windows api PostMessage将消息发送到隐藏窗口，从而发送给windows操作系统
                    PostMessage(d-&gt;internalHwnd, WM_QT_SENDPOSTEDEVENTS, 0, 0);
                }
            } else if (d-&gt;sendPostedEventsWindowsTimerId == 0
                       &amp;&amp; localSerialNumber != d-&gt;lastSerialNumber) {
                // start a special timer to continue delivering posted events while
                // there are still input and timer messages in the message queue
                d-&gt;sendPostedEventsWindowsTimerId = SetTimer(d-&gt;internalHwnd,
                                                             SendPostedEventsWindowsTimerId,
                                                             0, // we specify zero, but Windows uses USER_TIMER_MINIMUM
                                                             NULL);
                // we don't check the return value of SetTimer()... if creating the timer failed, there's little
                // we can do. we just have to accept that posted events will be starved
            }
        }
    }
    return q-&gt;d_func()-&gt;getMessageHook ? CallNextHookEx(0, code, wp, lp) : 0;
}</code></pre> 
<h2></h2> 
<h2>自定义一个类如qttest 继承QWidget时，它是如何收到鼠标离开事件的呢？</h2> 
<p><img alt="" height="233" src="https://images2.imgbox.com/85/f1/bZI6dcra_o.png" width="1200"></p> 
<p></p> 
<p>bool QEventDispatcherWin32::processEvents中循环的 peekMessage 并                     TranslateMessage(&amp;msg);</p> 
<p>DispatchMessage(&amp;msg);将鼠标离开事件分发到相应窗口句柄的窗口过程中</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b9/de/e4KRfLfC_o.png" width="1200"></p> 
<p>当执行DispatchMessage windowsapi时，如上图，当前消息窗口句柄是0x000c1b1a;该消息会被分发到该窗口句柄的过程函数中 </p> 
<p>实际窗口的窗口函数：C:\Qt\5.9.8\Src\qtbase\src\plugins\platforms\windows\qwindowscontext.cpp</p> 
<pre><code>
extern "C" LRESULT QT_WIN_CALLBACK qWindowsWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT result;
    // 1 计算消息类型 
    const QtWindows::WindowsEventType et = windowsEventType(message, wParam, lParam);
    QWindowsWindow *platformWindow = nullptr;
    const RECT ncCalcSizeFrame = rectFromNcCalcSize(message, wParam, lParam, 0);

    // 2 处理消息
    const bool handled = QWindowsContext::instance()-&gt;windowsProc(hwnd, message, et, wParam, lParam, &amp;result, &amp;platformWindow);
    if (QWindowsContext::verbose &gt; 1 &amp;&amp; lcQpaEvents().isDebugEnabled()) {
        if (const char *eventName = QWindowsGuiEventDispatcher::windowsMessageName(message)) {
            qCDebug(lcQpaEvents) &lt;&lt; "EVENT: hwd=" &lt;&lt; hwnd &lt;&lt; eventName &lt;&lt; hex &lt;&lt; "msg=0x"  &lt;&lt; message
                &lt;&lt; "et=0x" &lt;&lt; et &lt;&lt; dec &lt;&lt; "wp=" &lt;&lt; int(wParam) &lt;&lt; "at"
                &lt;&lt; GET_X_LPARAM(lParam) &lt;&lt; GET_Y_LPARAM(lParam) &lt;&lt; "handled=" &lt;&lt; handled;
        }
    }
    if (!handled)
        result = DefWindowProc(hwnd, message, wParam, lParam);

    // Capture WM_NCCALCSIZE on top level windows and obtain the window margins by
    // subtracting the rectangles before and after processing. This will correctly
    // capture client code overriding the message and allow for per-monitor margins
    // for High DPI (QTBUG-53255, QTBUG-40578).
    if (message == WM_NCCALCSIZE &amp;&amp; !isEmptyRect(ncCalcSizeFrame) &amp;&amp; isTopLevel(hwnd) &amp;&amp; !isMinimized(hwnd)) {
        const QMargins margins =
            marginsFromRects(ncCalcSizeFrame, rectFromNcCalcSize(message, wParam, lParam, 0));
        if (margins.left() &gt;= 0) {
            if (platformWindow) {
                platformWindow-&gt;setFrameMargins(margins);
            } else {
                const QSharedPointer&lt;QWindowCreationContext&gt; ctx = QWindowsContext::instance()-&gt;windowCreationContext();
                if (!ctx.isNull())
                    ctx-&gt;margins = margins;
            }
        }
    }
    return result;
}</code></pre> 
<p></p> 
<h4>QtWindows::WindowsEventType windowsEventType 将windows消息类型 转化成qt消息类型</h4> 
<p>C:\Qt\5.9.8\Src\qtbase\src\plugins\platforms\windows\qwindowscontext.cpp</p> 
<pre><code>
inline QtWindows::WindowsEventType windowsEventType(UINT message, WPARAM wParamIn, LPARAM lParamIn)
{
    switch (message) {
    case WM_PAINT:
    case WM_ERASEBKGND:
        return QtWindows::ExposeEvent;
    case WM_CLOSE:
        return QtWindows::CloseEvent;
    case WM_DESTROY:
        return QtWindows::DestroyEvent;
    case WM_ACTIVATEAPP:
        return (int)wParamIn ?
        QtWindows::ActivateApplicationEvent : QtWindows::DeactivateApplicationEvent;
    case WM_MOUSEACTIVATE:
        return QtWindows::MouseActivateWindowEvent;
    case WM_ACTIVATE:
        return  LOWORD(wParamIn) == WA_INACTIVE ?
            QtWindows::DeactivateWindowEvent : QtWindows::ActivateWindowEvent;
    case WM_SETCURSOR:
        return QtWindows::CursorEvent;
    case WM_MOUSELEAVE:
        return QtWindows::MouseEvent;
    case WM_HSCROLL:
        return QtWindows::ScrollEvent;
    case WM_MOUSEWHEEL:
    case WM_MOUSEHWHEEL:
        return QtWindows::MouseWheelEvent;
 ......
        return QtWindows::ExitSizeMoveEvent;
    default:
        break;
    }
    if (message &gt;= WM_NCMOUSEMOVE &amp;&amp; message &lt;= WM_NCMBUTTONDBLCLK)
        return QtWindows::NonClientMouseEvent; //
    if ((message &gt;= WM_MOUSEFIRST &amp;&amp; message &lt;= WM_MOUSELAST)
         || (message &gt;= WM_XBUTTONDOWN &amp;&amp; message &lt;= WM_XBUTTONDBLCLK))
        return QtWindows::MouseEvent;
    return QtWindows::UnknownEvent;
}
</code></pre> 
<p> QWindowsContext::windowsProc  对相应消息进行处理</p> 
<pre><code>
/*!
     \brief Main windows procedure registered for windows.

     \sa QWindowsGuiEventDispatcher
*/

bool QWindowsContext::windowsProc(HWND hwnd, UINT message,
                                  QtWindows::WindowsEventType et,
                                  WPARAM wParam, LPARAM lParam,
                                  LRESULT *result,
                                  QWindowsWindow **platformWindowPtr)
{
    *result = 0;

    MSG msg;
    msg.hwnd = hwnd;         // re-create MSG structure
    msg.message = message;   // time and pt fields ignored
    msg.wParam = wParam;
    msg.lParam = lParam;
    msg.pt.x = msg.pt.y = 0;
    if (et != QtWindows::CursorEvent &amp;&amp; (et &amp; (QtWindows::MouseEventFlag | QtWindows::NonClientEventFlag))) {
        msg.pt.x = GET_X_LPARAM(lParam);
        msg.pt.y = GET_Y_LPARAM(lParam);
        // For non-client-area messages, these are screen coordinates (as expected
        // in the MSG structure), otherwise they are client coordinates.
        if (!(et &amp; QtWindows::NonClientEventFlag)) {
            ClientToScreen(msg.hwnd, &amp;msg.pt);
        }
    } else {
        GetCursorPos(&amp;msg.pt);
    }

    QWindowsWindow *platformWindow = findPlatformWindow(hwnd);
    *platformWindowPtr = platformWindow;

    // Run the native event filters.
    long filterResult = 0;
    QAbstractEventDispatcher* dispatcher = QAbstractEventDispatcher::instance();
    if (dispatcher &amp;&amp; dispatcher-&gt;filterNativeEvent(d-&gt;m_eventType, &amp;msg, &amp;filterResult)) {
        *result = LRESULT(filterResult);
        return true;
    }

    if (platformWindow) {
        filterResult = 0;
        if (QWindowSystemInterface::handleNativeEvent(platformWindow-&gt;window(), d-&gt;m_eventType, &amp;msg, &amp;filterResult)) {
            *result = LRESULT(filterResult);
            return true;
        }
    }
    if (et &amp; QtWindows::InputMethodEventFlag) {
        QWindowsInputContext *windowsInputContext = ::windowsInputContext();
        // Disable IME assuming this is a special implementation hooking into keyboard input.
        // "Real" IME implementations should use a native event filter intercepting IME events.
        if (!windowsInputContext) {
            QWindowsInputContext::setWindowsImeEnabled(platformWindow, false);
            return false;
        }
        switch (et) {
        case QtWindows::InputMethodStartCompositionEvent:
            return windowsInputContext-&gt;startComposition(hwnd);
        case QtWindows::InputMethodCompositionEvent:
            return windowsInputContext-&gt;composition(hwnd, lParam);
        case QtWindows::InputMethodEndCompositionEvent:
            return windowsInputContext-&gt;endComposition(hwnd);
        case QtWindows::InputMethodRequest:
            return windowsInputContext-&gt;handleIME_Request(wParam, lParam, result);
        default:
            break;
        }
    } // InputMethodEventFlag

    switch (et) {
    case QtWindows::GestureEvent:
#if QT_CONFIG(sessionmanager)
        return platformSessionManager()-&gt;isInteractionBlocked() ? true : d-&gt;m_mouseHandler.translateGestureEvent(platformWindow-&gt;window(), hwnd, et, msg, result);
#else
        return d-&gt;m_mouseHandler.translateGestureEvent(platformWindow-&gt;window(), hwnd, et, msg, result);
#endif
    case QtWindows::InputMethodOpenCandidateWindowEvent:
    case QtWindows::InputMethodCloseCandidateWindowEvent:
        // TODO: Release/regrab mouse if a popup has mouse grab.
        return false;
    case QtWindows::DestroyEvent:
        if (platformWindow &amp;&amp; !platformWindow-&gt;testFlag(QWindowsWindow::WithinDestroy)) {
            qWarning() &lt;&lt; "External WM_DESTROY received for " &lt;&lt; platformWindow-&gt;window()
                       &lt;&lt; ", parent: " &lt;&lt; platformWindow-&gt;window()-&gt;parent()
                       &lt;&lt; ", transient parent: " &lt;&lt; platformWindow-&gt;window()-&gt;transientParent();
            }
        return false;
 ......
     // 这里以LeaveEvent为例
    case QtWindows::MouseWheelEvent:
    case QtWindows::MouseEvent:
    case QtWindows::LeaveEvent:
        {
            QWindow *window = platformWindow-&gt;window();//找到原生窗口
            //如果该窗口不响应输入事件，则向上找父窗口
            while (window &amp;&amp; (window-&gt;flags() &amp; Qt::WindowTransparentForInput))
                window = window-&gt;parent();
            if (!window)
                return false;
#if QT_CONFIG(sessionmanager)
          //调用m_mouseHandler.translateMouseEvent进行鼠标事件处理
        return platformSessionManager()-&gt;isInteractionBlocked() ? true : d-&gt;m_mouseHandler.translateMouseEvent(window, hwnd, et, msg, result);
#else
        return d-&gt;m_mouseHandler.translateMouseEvent(window, hwnd, et, msg, result);
#endif
        }
    case QtWindows::TouchEvent:
#if QT_CONFIG(sessionmanager)
        return platformSessionManager()-&gt;isInteractionBlocked() ? true : d-&gt;m_mouseHandler.translateTouchEvent(platformWindow-&gt;window(), hwnd, et, msg, result);
#else
        return d-&gt;m_mouseHandler.translateTouchEvent(platformWindow-&gt;window(), hwnd, et, msg, result);
#endif
    case QtWindows::FocusInEvent: // see QWindowsWindow::requestActivateWindow().
 .......
    default:
        break;
    }
    return false;
}</code></pre> 
<p>C:\Qt\5.9.8\Src\qtbase\src\plugins\platforms\windows\qwindowsmousehandler.cpp </p> 
<pre><code>
bool QWindowsMouseHandler::translateMouseEvent(QWindow *window, HWND hwnd,
                                               QtWindows::WindowsEventType et,
                                               MSG msg, LRESULT *result)
{
.......
    QWindowSystemInterface::handleMouseEvent(window, winEventPosition, globalPosition, buttons,
                                             QWindowsKeyMapper::queryKeyboardModifiers(),
                                             source);
    m_previousCaptureWindow = hasCapture ? window : 0;
    // QTBUG-48117, force synchronous handling for the extra buttons so that WM_APPCOMMAND
    // is sent for unhandled WM_XBUTTONDOWN.
    return (msg.message != WM_XBUTTONUP &amp;&amp; msg.message != WM_XBUTTONDOWN &amp;&amp; msg.message != WM_XBUTTONDBLCLK)
        || QWindowSystemInterface::flushWindowSystemEvents();
}</code></pre> 
<p>接下来的过程：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/22/09/JTR59lyU_o.png" width="1200"></p> 
<p></p> 
<pre><code>void QWindowSystemInterface::handleFrameStrutMouseEvent(QWindow *window, const QPointF &amp;local, const QPointF &amp;global, Qt::MouseButtons b,
                                                        Qt::KeyboardModifiers mods, Qt::MouseEventSource source)
{
    const unsigned long time = QWindowSystemInterfacePrivate::eventTime.elapsed();
    handleFrameStrutMouseEvent(window, time, local, global, b, mods, source);
}</code></pre> 
<p>其中： QPointF &amp;local  鼠标在本窗口的位置； const QPointF &amp;global  鼠标全局位置 ，如：</p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/fb/a2/Xyd0YLjH_o.png" width="1200"></p> 
<p>QWindowSystemInterface::handleFrameStrutMouseEvent 将鼠标的数据封装成 MouseEvent  </p> 
<pre><code>void QWindowSystemInterface::handleFrameStrutMouseEvent(QWindow *window, ulong timestamp, const QPointF &amp;local, const QPointF &amp;global, Qt::MouseButtons b,
                                                        Qt::KeyboardModifiers mods, Qt::MouseEventSource source)
{
    QWindowSystemInterfacePrivate::MouseEvent * e =
            new QWindowSystemInterfacePrivate::MouseEvent(window, timestamp,
                                                          QWindowSystemInterfacePrivate::FrameStrutMouse,
                                                          QHighDpi::fromNativeLocalPosition(local, window), QHighDpi::fromNativePixels(global, window), b, mods, source);
    QWindowSystemInterfacePrivate::handleWindowSystemEvent(e);
}</code></pre> 
<p><strong> QWindowSystemInterfacePrivate::handleWindowSystemEvent</strong><br>      处理窗口系统事件。 默认情况下此函数将事件发布到窗口系统事件队列中，并且唤醒 Gui 事件调度器。 Qt Gui 将异步处理事件稍后。 返回值不用于异步模式，将永远是真实的。</p> 
<p>     在同步模式下，Qt Gui 会立即处理事件。 返回值指示 Qt 是否接受该事件。 如果事件是从另一个线程传递的 比 Qt 主线程刷新窗口系统事件队列，这可能会传递其他事件也是如此。</p> 
<p></p> 
<pre><code>
template&lt;&gt;
bool QWindowSystemInterfacePrivate::handleWindowSystemEvent&lt;QWindowSystemInterface::DefaultDelivery&gt;(QWindowSystemInterfacePrivate::WindowSystemEvent *ev)
{
    if (synchronousWindowSystemEvents)//同步处理
        return handleWindowSystemEvent&lt;QWindowSystemInterface::SynchronousDelivery&gt;(ev);
    else//异步处理
        return handleWindowSystemEvent&lt;QWindowSystemInterface::AsynchronousDelivery&gt;(ev);
}</code></pre> 
<p><strong>QWindowSystemInterfacePrivate::handleWindowSystemEvent</strong><br>      通过将事件发布到 Qt Gui 来异步处理窗口系统事件。此函数将事件发布到窗口系统事件队列并唤醒 Gui 事件调度程序。 然后 Qt Gui 将异步处理事件。</p> 
<p>        ev当前是MouseEvent 被加入windowSystemEventQueue，然后唤醒事件调度器wake</p> 
<pre><code>
template&lt;&gt;
bool QWindowSystemInterfacePrivate::handleWindowSystemEvent&lt;QWindowSystemInterface::AsynchronousDelivery&gt;(WindowSystemEvent *ev)
{
    windowSystemEventQueue.append(ev);
    if (QAbstractEventDispatcher *dispatcher = QGuiApplicationPrivate::qt_qpa_core_dispatcher())
        dispatcher-&gt;wakeUp();
    return true;
}</code></pre> 
<p><br><strong>  void QEventDispatcherWin32::wakeUp()    post 一个WM_QT_SENDPOSTEDEVENTS消息到本线程 ，PostMessage是windows原生接口</strong></p> 
<p><img alt="" src="https://images2.imgbox.com/be/52/DhQB5ffu_o.png"></p> 
<p> </p> 
<pre><code>void QEventDispatcherWin32::wakeUp()
{
    Q_D(QEventDispatcherWin32);
    d-&gt;serialNumber.ref();
    if (d-&gt;internalHwnd &amp;&amp; d-&gt;wakeUps.testAndSetAcquire(0, 1)) {
        // post a WM_QT_SENDPOSTEDEVENTS to this thread if there isn't one already pending
        //将消息发送到隐藏窗口internalHwnd 中
       //发送WM_QT_SENDPOSTEDEVENTS(1025)给QApplication的
       //message-only窗口
        PostMessage(d-&gt;internalHwnd, WM_QT_SENDPOSTEDEVENTS, 0, 0);
    }
}</code></pre> 
<p>之后：最开始创建<strong>的隐藏窗口的窗口过程回调收到该消息进行</strong>处理</p> 
<pre><code>LRESULT QT_WIN_CALLBACK qt_internal_proc(HWND hwnd, UINT message, WPARAM wp, LPARAM lp)
{
    if (message == WM_NCCREATE)
        return true;
.......
     //收到消息
    } else if (message == WM_QT_SENDPOSTEDEVENTS
               // we also use a Windows timer to send posted events when the message queue is full
               || (message == WM_TIMER
                   &amp;&amp; d-&gt;sendPostedEventsWindowsTimerId != 0
                   &amp;&amp; wp == (uint)d-&gt;sendPostedEventsWindowsTimerId)) {
        const int localSerialNumber = d-&gt;serialNumber.load();
        if (localSerialNumber != d-&gt;lastSerialNumber) {
            d-&gt;lastSerialNumber = localSerialNumber;
            q-&gt;sendPostedEvents();//执行
        }
        return 0;
    } else if (message == WM_TIMER) {
        Q_ASSERT(d != 0);
        d-&gt;sendTimerEvent(wp);
        return 0;
    }

    return DefWindowProc(hwnd, message, wp, lp);
}</code></pre> 
<p>        注意，GUI线程使用的派发器是<strong>QWindowsGuiEventDispatcher</strong>，所以除了处理postEventList队列之外，还会处理windowSystemEventsQueued。但是非GUI线程使用的派发器是<strong>QEventDispatcherWin32</strong>，所以非GUI线程就只负责处理他的postEventList队列。</p> 
<p>      </p> 
<pre><code>void QWindowsGuiEventDispatcher::sendPostedEvents()
{
    QEventDispatcherWin32::sendPostedEvents();
    QWindowSystemInterface::sendWindowSystemEvents(m_flags);
}

</code></pre> 
<p>bool QWindowSystemInterface::sendWindowSystemEvent 将循环遍历系统事件队列，并发送</p> 
<pre><code>
bool QWindowSystemInterface::sendWindowSystemEvents(QEventLoop::ProcessEventsFlags flags)
{
    int nevents = 0;

    while (QWindowSystemInterfacePrivate::windowSystemEventsQueued()) {
        QWindowSystemInterfacePrivate::WindowSystemEvent *event =
            (flags &amp; QEventLoop::ExcludeUserInputEvents) ?
                QWindowSystemInterfacePrivate::getNonUserInputWindowSystemEvent() :
// 1 从系统事件中获取之前存入的事件：队列 先进先出
                QWindowSystemInterfacePrivate::getWindowSystemEvent();
        if (!event)
            break;

        if (QWindowSystemInterfacePrivate::eventHandler) {
            if (QWindowSystemInterfacePrivate::eventHandler-&gt;sendEvent(event))
                nevents++;
        } else {
            nevents++;
            //2 gui 处理事件
            QGuiApplicationPrivate::processWindowSystemEvent(event);
        }

        // Record the accepted state for the processed event
        // (excluding flush events). This state can then be
        // returned by flushWindowSystemEvents().
        if (event-&gt;type != QWindowSystemInterfacePrivate::FlushEvents)
            QWindowSystemInterfacePrivate::eventAccepted.store(event-&gt;eventAccepted);

        delete event;
    }

    return (nevents &gt; 0);
}

//返回一个之前进入的事件 如MouseEvent
QWindowSystemInterfacePrivate::WindowSystemEvent * QWindowSystemInterfacePrivate::getWindowSystemEvent()
{
    return windowSystemEventQueue.takeFirstOrReturnNull();
}





void QGuiApplicationPrivate::processWindowSystemEvent(QWindowSystemInterfacePrivate::WindowSystemEvent *e)
{
    switch(e-&gt;type) {
    case QWindowSystemInterfacePrivate::FrameStrutMouse:
    case QWindowSystemInterfacePrivate::Mouse:
       //处理鼠标事件
    QGuiApplicationPrivate::processMouseEvent(static_cast&lt;QWindowSystemInterfacePrivate::MouseEvent *&gt;(e));
        break;
......
}</code></pre> 
<p></p> 
<p>之后的传递过程不再展开，可以看堆栈：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b8/e2/I1yvy9nu_o.png" width="1200"></p> 
<p> 最终我们自定义的qttest 重写的leaveEvent收到鼠标离开事件</p> 
<h4>总结：</h4> 
<h4> windows消息处理机制：</h4> 
<p><strong>1  注册窗口类（指定窗口函数），可以注册多个窗口类</strong></p> 
<p><strong>2  进入消息循环形式如下：</strong></p> 
<p><img alt="" src="https://images2.imgbox.com/c8/25/4LRcnztp_o.jpg"><br> 首先取消息PeekMessage(&amp;msg,0,0,0,PM_REMOVE); 从应用程序队列，也就是从主线程的消息队列中。 </p> 
<p>接着转换消息并派发：<br> TranslateMessage(&amp;msg);</p> 
<p>DispatchMessage(&amp;msg);</p> 
<p><strong>3  窗口函数就负责处理相应的消息。</strong></p> 
<p><br><strong>二 qt中的消息处理机制：</strong></p> 
<p>      1 首先我们要关注的CApplication类，该类在初始化的时候会通过QWindowsClipboard::registerViewer()注册一个名字为“Qt5ClipboardView”窗口类，其中窗口函数为：qClipboardViewerWndProc，同时该类初始的调度器为QWindowsGuiEventDispatcher，该调度器也注册了一个窗口类，类名为"QEventDispatcherWin32_Internal_Widget1806862873"，该类的窗口函数为：qt_internal_proc（这个是qt自定义事件的主要处理函数）</p> 
<p>      2 如果我们开发的是wiget风格应用，还会初始化一个原生窗口类，该类也会注册一个窗口函数，类名为"Qt5QWindowIcon"，窗口函数为qWindowsWndProc（这个函数处理的是用户操作引起的系统事件，比如鼠标事件，键盘事件，点击事件。。。，这些事件可能又会触发Qt定义的事件，此时这类事件会被qt_internal_proc函数处理）</p> 
<p>      3 前面两步是注册了窗口函数，接着我们要看qt是如何进行消息派发的，在1中已经说到调度器为QWindowsGuiEventDispatcher，该类会调用：processEvents成员函数，调用父类的QEventDispatcherWin32::processEvents函数，在该函数中做了如下事情：</p> 
<p><strong>a 取消息</strong></p> 
<p>        来源有三个：</p> 
<ol><li>1）msg = d-&gt;queuedUserInputEvents.takeFirst();</li><li>2）msg = d-&gt;queuedSocketEvents.takeFirst();</li><li>3）haveMessage = PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE);</li></ol> 
<p>这三类消息代表不同的来源，其中第三个是系统推送来的消息（包括系统消息和用户自定义消息）<br><strong>b 如果没有消息的话，判断关注的句柄是否有触发的消息，句柄通过QEventDispatcherWin32::registerEventNotifier注册</strong><br> waitRet = MsgWaitForMultipleObjectsEx(nCount, pHandles, 0, QS_ALLINPUT, MWMO_ALERTABLE);<br><strong>c 通过ab两种监测消息的机制，若有消息就直接：</strong><br> if (!filterNativeEvent(QByteArrayLiteral("windows_generic_MSG"), &amp;msg, 0)) 这函数是过滤<br> {<!-- --><br>       TranslateMessage(&amp;msg);<br>       DispatchMessage(&amp;msg);<br> }<br> 至此qt的消息循环机制就已经完成。<br>    4 回调函数，之前已经说过，由于注册了三个窗口类所以对应的应该有三个窗口函数，在此我分析其中两个关键的：<br>  1）LRESULT QT_WIN_CALLBACK qt_internal_proc(HWND hwnd, UINT message, WPARAM wp, LPARAM lp)：该函数是只处理自定义消息的， 套接字读写消息WM_QT_SOCKETNOTIFIER，WM_QT_ACTIVATENOTIFIERS（对应套接字激活和失活状态）WM_QT_SENDPOSTEDEVENTS（异步消息），这三类消息都是qt自定义的，</p> 
<p>        对于第一个消息，主要处理的是套接字读写事件，将套接字事件转化为QEvent事件然后通过QCoreApplication::sendEvent(sn-&gt;obj, &amp;event)立即处理;</p> 
<p>        第二类消息是指套接字注册成功或关闭时响应的消息，主要功能就是向函数WSAAsyncSelect(socket, internalHwnd, event ? int(WM_QT_SOCKETNOTIFIER) : 0, event)重新注册关注的事件；</p> 
<p>        第三个消息是最应用最广的消息，比如当我们调用异步函数发送消息时会触发该类消息QCoreApplication::postEvent(),该消息被触发后会从当前线程的自定义队列中取消息执行；</p> 
<p>2）extern "C" LRESULT QT_WIN_CALLBACK qWindowsWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)：该函数处理用户操作产生的消息，比如鼠标等，它做了以下事情：<br> 1）const QtWindows::WindowsEventType et = windowsEventType(message, wParam, lParam);将windows消息转为qt事件<br> 2）const bool handled = QWindowsContext::instance()-&gt;windowsProc(hwnd, message, et, wParam, lParam, &amp;result);在qt事件分类中处理该类消息。有的消息就直接处理，有的消息会postWindowSystemEvent(ev)到消息队列中windowSystemEventQueue;同时发出WM_QT_SENDPOSTEDEVENTS消息以经过window消息循环回调第1）个函数处理，达到异步效果。</p> 
<p>  至此qt消息循环应该已经算基本清楚了</p> 
<h2>同步事件原理：sendEvent 只能在本线程中使用</h2> 
<p></p> 
<p><img alt="" height="1181" src="https://images2.imgbox.com/2e/9f/0hG0zOlI_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<pre><code>inline bool QCoreApplication::sendEvent(QObject *receiver, QEvent *event)
{  if (event) 
        event-&gt;spont = false; //设定事件为非系统自发事件
   return notifyInternal2(receiver, event); 
}</code></pre> 
<p></p> 
<pre><code>
bool QCoreApplication::notifyInternal2(QObject *receiver, QEvent *event)
{
    //1 检测是否可以获取当前线程内的线程数据
    bool selfRequired = QCoreApplicationPrivate::threadRequiresCoreApplication();
    if (!self &amp;&amp; selfRequired)
        return false;

    // Make it possible for Qt Script to hook into events even
    // though QApplication is subclassed...
    bool result = false;

    //2 将接受者对象和事件对象放入指针数组  激活事件的回调函数
    void *cbdata[] = { receiver, event, &amp;result };
    if (QInternal::activateCallbacks(QInternal::EventNotifyCallback, cbdata)) {
        return result;
    }

    // Qt enforces the rule that events can only be sent to objects in
    // the current thread, so receiver-&gt;d_func()-&gt;threadData is
    // equivalent to QThreadData::current(), just without the function
    // call overhead.
    QObjectPrivate *d = receiver-&gt;d_func();
    QThreadData *threadData = d-&gt;threadData;
    QScopedScopeLevelCounter scopeLevelCounter(threadData);
    if (!selfRequired)
        return doNotify(receiver, event);

    //3 调用notify
    return self-&gt;notify(receiver, event);
}</code></pre> 
<p></p> 
<pre><code>/*! \reimp
 */
bool QApplication::notify(QObject *receiver, QEvent *e)
{
    Q_D(QApplication);
    // no events are delivered after ~QCoreApplication() has started
    // 1 检查是否关闭应用
    if (QApplicationPrivate::is_app_closing)
        return true;

    if (Q_UNLIKELY(!receiver)) {                        // serious error
        qWarning("QApplication::notify: Unexpected null receiver");
        return true;
    }

#ifndef QT_NO_DEBUG
    //2 检查是否处于同一个线程中
    d-&gt;checkReceiverThread(receiver);
#endif

   // 3 检查接受者是否是window 类型
    if (receiver-&gt;isWindowType())
        QGuiApplicationPrivate::sendQWindowEventToQPlatformWindow(static_cast&lt;QWindow *&gt;(receiver), e);

    //4 根据消息类型，进入相应的处理函数 s如鼠标事件
......
case QEvent::MouseMove:
        {
            QWidget* w = static_cast&lt;QWidget *&gt;(receiver);

            QMouseEvent* mouse = static_cast&lt;QMouseEvent*&gt;(e);
            QPoint relpos = mouse-&gt;pos();

            if (e-&gt;spontaneous()) {
                if (e-&gt;type() != QEvent::MouseMove)
                    QApplicationPrivate::giveFocusAccordingToFocusPolicy(w, e, relpos);

                // ### Qt 5 These dynamic tool tips should be an OPT-IN feature. Some platforms
                // like OS X (probably others too), can optimize their views by not
                // dispatching mouse move events. We have attributes to control hover,
                // and mouse tracking, but as long as we are deciding to implement this
                // feature without choice of opting-in or out, you ALWAYS have to have
                // tracking enabled. Therefore, the other properties give a false sense of
                // performance enhancement.
                if (e-&gt;type() == QEvent::MouseMove &amp;&amp; mouse-&gt;buttons() == 0
                    &amp;&amp; w-&gt;rect().contains(relpos)) { // Outside due to mouse grab?
                    d-&gt;toolTipWidget = w;
                    d-&gt;toolTipPos = relpos;
                    d-&gt;toolTipGlobalPos = mouse-&gt;globalPos();
                    QStyle *s = d-&gt;toolTipWidget-&gt;style();
                    int wakeDelay = s-&gt;styleHint(QStyle::SH_ToolTip_WakeUpDelay, 0, d-&gt;toolTipWidget, 0);
                    d-&gt;toolTipWakeUp.start(d-&gt;toolTipFallAsleep.isActive() ? 20 : wakeDelay, this);
                }
            }

            bool eventAccepted = mouse-&gt;isAccepted();

            QPointer&lt;QWidget&gt; pw = w;
            while (w) {
                QMouseEvent me(mouse-&gt;type(), relpos, mouse-&gt;windowPos(), mouse-&gt;globalPos(),
                               mouse-&gt;button(), mouse-&gt;buttons(), mouse-&gt;modifiers(), mouse-&gt;source());
                me.spont = mouse-&gt;spontaneous();
                me.setTimestamp(mouse-&gt;timestamp());
                QGuiApplicationPrivate::setMouseEventFlags(&amp;me, mouse-&gt;flags());
                // throw away any mouse-tracking-only mouse events
                if (!w-&gt;hasMouseTracking()
                    &amp;&amp; mouse-&gt;type() == QEvent::MouseMove &amp;&amp; mouse-&gt;buttons() == 0) {
                    // but still send them through all application event filters (normally done by notify_helper)
                    d-&gt;sendThroughApplicationEventFilters(w, w == receiver ? mouse : &amp;me);
                    res = true;
                } else {
                    w-&gt;setAttribute(Qt::WA_NoMouseReplay, false);
                    // 5 调用通知接口

 /*
               * 将事件传递下去，进行处理，如果返回值res为真且事件被接收，或者到了顶层窗口，
               * 或者w窗口设置了Qt::WA_NoMousePropagation，则停止事件的传递，退出循环。
               * 完成对该事件的处理。否则，将事件转发给w的父窗口处理：
               * w = w-&gt;parentWidget();
*/
                    res = d-&gt;notify_helper(w, w == receiver ? mouse : &amp;me);
                    e-&gt;spont = false;
                }
                eventAccepted = (w == receiver ? mouse : &amp;me)-&gt;isAccepted();
                if (res &amp;&amp; eventAccepted)
                    break;
                if (w-&gt;isWindow() || w-&gt;testAttribute(Qt::WA_NoMousePropagation))
                    break;
                relpos += w-&gt;pos();
                w = w-&gt;parentWidget();
            }

            mouse-&gt;setAccepted(eventAccepted);

            if (e-&gt;type() == QEvent::MouseMove) {
                if (!pw)
                    break;

                w = static_cast&lt;QWidget *&gt;(receiver);
                relpos = mouse-&gt;pos();
                QPoint diff = relpos - w-&gt;mapFromGlobal(d-&gt;hoverGlobalPos);
                while (w) {
                    if (w-&gt;testAttribute(Qt::WA_Hover) &amp;&amp;
                        (!QApplication::activePopupWidget() || QApplication::activePopupWidget() == w-&gt;window())) {
                        QHoverEvent he(QEvent::HoverMove, relpos, relpos - diff, mouse-&gt;modifiers());
                        d-&gt;notify_helper(w, &amp;he);
                    }
                    if (w-&gt;isWindow() || w-&gt;testAttribute(Qt::WA_NoMousePropagation))
                        break;
                    relpos += w-&gt;pos();
                    w = w-&gt;parentWidget();
                }
            }

            d-&gt;hoverGlobalPos = mouse-&gt;globalPos();
        }
        break;
......</code></pre> 
<p></p> 
<pre><code>bool QApplicationPrivate::notify_helper(QObject *receiver, QEvent * e)
{ 
    /*
    * 首先将事件交由安装到QApplication上的事件过滤器进行处理。如果事件被过滤器处理并返回
    * true，则从这里直接返回true
    */
    // send to all application event filters
    if (sendThroughApplicationEventFilters(receiver, e))
        return true;
 
    if (receiver-&gt;isWidgetType()) {
        QWidget *widget = static_cast&lt;QWidget *&gt;(receiver);
      ...
 
     /*
     * 在事件交由receiver的event处理之前，先将它交给安装到receiver上的过滤器处理。如果事件
     * 被过滤器处理并返回true，则从这里直接返回true
     */   
    // send to all receiver event filters
    if (sendThroughObjectEventFilters(receiver, e))
        return true;
 
    /*
    * 最后，交给receiver的event进行处理，返回event的返回值
    */  
    // deliver the event
    bool consumed = receiver-&gt;event(e);
    QCoreApplicationPrivate::setEventSpontaneous(e, false);
    return consumed;
}</code></pre> 
<p>来到QWidget的event 函数，调用mousePressEvent函数。</p> 
<pre><code>
bool QWidget::event(QEvent *event)
{
    Q_D(QWidget);

 ......
    case QEvent::MouseButtonPress:
        mousePressEvent((QMouseEvent*)event);
        break;
......
</code></pre> 
<p>子类qttest重写了该函数，最后调用到：</p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/4a/56/ydFBhbDZ_o.png" width="1200"></p> 
<p></p> 
<h4>总结：</h4> 
<ol><li> sendEvent是根据事件类型发送事件进行处理，且不借助QEventLoop发送事件</li><li>事件发送者对象和事件接收者对象必须处于同一个线程</li><li>遵循父子对象的事件处理机制</li><li>是堵塞的事件发送类型，需要重写接收对象event的处理函数</li><li>事件发生后会立即进入QObject::event函数进行处理</li><li>sendEvent中事件对象的生命周期由qt平台管理，支持局部对象和new分配，new事件处理后内部自动销毁</li><li>sendEvent会立即同步要发送的event，当sendEvent返回的时候，表示对方已经完成了对事件的处理</li></ol> 
<p></p> 
<h2>异步事件原理 postEvent：支持不同的线程间使用</h2> 
<p>        </p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/93/ff/YDHkisiq_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<pre><code>
void QCoreApplication::postEvent(QObject *receiver, QEvent *event, int priority)
{

    //1 如果接收者为0 则删除事件
    if (receiver == 0) {
        qWarning("QCoreApplication::postEvent: Unexpected null receiver");
        delete event;
        return;
    }

    //2 检查接收者的线程数据是否为空
    QThreadData * volatile * pdata = &amp;receiver-&gt;d_func()-&gt;threadData;
    QThreadData *data = *pdata;
    if (!data) {
        // posting during destruction? just delete the event to prevent a leak
        delete event;
        return;
    }



    //3 对postEvent存储容器进行加锁操作
    // lock the post event mutex
    data-&gt;postEventList.mutex.lock();


    //4 对接收者数据进行校验，防止接收者通过movetoThread 转移到其他线程
    // if object has moved to another thread, follow it
    while (data != *pdata) {
        data-&gt;postEventList.mutex.unlock();

        data = *pdata;
        if (!data) {
            // posting during destruction? just delete the event to prevent a leak
            delete event;
            return;
        }

        data-&gt;postEventList.mutex.lock();
    }

    QMutexUnlocker locker(&amp;data-&gt;postEventList.mutex);

    //5 事件压缩操作：目的是保证接收者对象posteEvents队列中只有一个DeferredDelete事件和quit事件
    // if this is one of the compressible events, do compression
    if (receiver-&gt;d_func()-&gt;postedEvents
        &amp;&amp; self &amp;&amp; self-&gt;compressEvent(event, receiver, &amp;data-&gt;postEventList)) {
        return;
    }

    if (event-&gt;type() == QEvent::DeferredDelete)
        receiver-&gt;d_ptr-&gt;deleteLaterCalled = true;

    if (event-&gt;type() == QEvent::DeferredDelete &amp;&amp; data == QThreadData::current()) {
        // remember the current running eventloop for DeferredDelete
        // events posted in the receiver's thread.

        // Events sent by non-Qt event handlers (such as glib) may not
        // have the scopeLevel set correctly. The scope level makes sure that
        // code like this:
        //     foo-&gt;deleteLater();
        //     qApp-&gt;processEvents(); // without passing QEvent::DeferredDelete
        // will not cause "foo" to be deleted before returning to the event loop.

        // If the scope level is 0 while loopLevel != 0, we are called from a
        // non-conformant code path, and our best guess is that the scope level
        // should be 1. (Loop level 0 is special: it means that no event loops
        // are running.)
        int loopLevel = data-&gt;loopLevel;
        int scopeLevel = data-&gt;scopeLevel;
        if (scopeLevel == 0 &amp;&amp; loopLevel != 0)
            scopeLevel = 1;
        static_cast&lt;QDeferredDeleteEvent *&gt;(event)-&gt;level = loopLevel + scopeLevel;
    }


    //6 使用智能指针对象包裹事件对象 将事件添加到接收者对象的postEventList中
//原因：postEvent并不会立即执行，需要等到事件调度器下一次循环，执行事件后，清理
    // delete the event on exceptions to protect against memory leaks till the event is
    // properly owned in the postEventList
    QScopedPointer&lt;QEvent&gt; eventDeleter(event);
    data-&gt;postEventList.addEvent(QPostEvent(receiver, event, priority));
    eventDeleter.take();
    event-&gt;posted = true;//设置事件对象为post事件
    ++receiver-&gt;d_func()-&gt;postedEvents;
    data-&gt;canWait = false;
    locker.unlock();


    //7 获取当前接收者对象的事件调度器 并进行唤醒
    QAbstractEventDispatcher* dispatcher = data-&gt;eventDispatcher.loadAcquire();
    if (dispatcher)
        dispatcher-&gt;wakeUp();
}
</code></pre> 
<p> class QThreadData中定义了      QPostEventList postEventList;存放post事件，类型是class QPostEventList : public QVector&lt;QPostEvent&gt;</p> 
<pre><code>class QPostEvent
{
public:
    QObject *receiver;//接收者
    QEvent *event;//事件
    int priority;//优先级
    inline QPostEvent()
        : receiver(0), event(0), priority(0)
    { }
    inline QPostEvent(QObject *r, QEvent *e, int p)
        : receiver(r), event(e), priority(p)
    { }
};</code></pre> 
<p><img alt="" height="313" src="https://images2.imgbox.com/80/63/pfd5mcrV_o.png" width="843"></p> 
<p><br>         dispatcher-&gt;wakeUp();发送一个自定义消息：</p> 
<p><strong>  void QEventDispatcherWin32::wakeUp()    post 一个WM_QT_SENDPOSTEDEVENTS消息到本线程 ，PostMessage是windows原生接口</strong></p> 
<pre><code>void QEventDispatcherWin32::wakeUp()
{
    Q_D(QEventDispatcherWin32);
    d-&gt;serialNumber.ref();
    if (d-&gt;internalHwnd &amp;&amp; d-&gt;wakeUps.testAndSetAcquire(0, 1)) {
        // post a WM_QT_SENDPOSTEDEVENTS to this thread if there isn't one already pending
        //将消息发送到隐藏窗口internalHwnd 中
        PostMessage(d-&gt;internalHwnd, WM_QT_SENDPOSTEDEVENTS, 0, 0);
    }
}</code></pre> 
<p>之后：最开始创建<strong>的隐藏窗口的窗口过程回调收到该消息进行</strong>处理</p> 
<pre><code>LRESULT QT_WIN_CALLBACK qt_internal_proc(HWND hwnd, UINT message, WPARAM wp, LPARAM lp)
{
    if (message == WM_NCCREATE)
        return true;
.......
     //收到消息
    } else if (message == WM_QT_SENDPOSTEDEVENTS
               // we also use a Windows timer to send posted events when the message queue is full
               || (message == WM_TIMER
                   &amp;&amp; d-&gt;sendPostedEventsWindowsTimerId != 0
                   &amp;&amp; wp == (uint)d-&gt;sendPostedEventsWindowsTimerId)) {
        const int localSerialNumber = d-&gt;serialNumber.load();
        if (localSerialNumber != d-&gt;lastSerialNumber) {
            d-&gt;lastSerialNumber = localSerialNumber;
            q-&gt;sendPostedEvents();//执行
        }
        return 0;
    } else if (message == WM_TIMER) {
        Q_ASSERT(d != 0);
        d-&gt;sendTimerEvent(wp);
        return 0;
    }

    return DefWindowProc(hwnd, message, wp, lp);
}</code></pre> 
<h4>sendPostedEvents</h4> 
<p>       sendPostedEvents是阻塞型事件，事件发送后，等到receive执行后才返回，并删除事件对象。</p> 
<pre><code>void QWindowsGuiEventDispatcher::sendPostedEvents()
{

    // 1 发送post事件
    QEventDispatcherWin32::sendPostedEvents();
    // 2 发送系统事件 上面讲鼠标事件是通过这个接口调用的
    QWindowSystemInterface::sendWindowSystemEvents(m_flags);
}

</code></pre> 
<p>        QEventDispatcherWin32::sendPostedEvents将Post到当前线程QThreadData::postEventList中的QPostEvent包装着的QEvent发送给QPostEvent**指定的对象**。</p> 
<pre><code>void QEventDispatcherWin32::sendPostedEvents()
{
    Q_D(QEventDispatcherWin32);
    QCoreApplicationPrivate::sendPostedEvents(0, 0, d-&gt;threadData);
}</code></pre> 
<p></p> 
<pre><code>
void QCoreApplicationPrivate::sendPostedEvents(QObject *receiver, int event_type,
                                               QThreadData *data)
{
    if (event_type == -1) {
        // we were called by an obsolete event dispatcher.
        event_type = 0;
    }

    if (receiver &amp;&amp; receiver-&gt;d_func()-&gt;threadData != data) {
        qWarning("QCoreApplication::sendPostedEvents: Cannot send "
                 "posted events for objects in another thread");
        return;
    }

    ++data-&gt;postEventList.recursion;

    QMutexLocker locker(&amp;data-&gt;postEventList.mutex);

    // by default, we assume that the event dispatcher can go to sleep after
    // processing all events. if any new events are posted while we send
    // events, canWait will be set to false.
    //默认情况下，事件循环器在处理完事件后canWait = true 进入休眠状态，当发布postevent时，
 //需要将其设置为false，唤醒事件循环器
    data-&gt;canWait = (data-&gt;postEventList.size() == 0);

    if (data-&gt;postEventList.size() == 0 || (receiver &amp;&amp; !receiver-&gt;d_func()-&gt;postedEvents)) {
        --data-&gt;postEventList.recursion;
        return;
    }

    data-&gt;canWait = true;

    // okay. here is the tricky loop. be careful about optimizing
    // this, it looks the way it does for good reasons.
    int startOffset = data-&gt;postEventList.startOffset;
    int &amp;i = (!event_type &amp;&amp; !receiver) ? data-&gt;postEventList.startOffset : startOffset;
    data-&gt;postEventList.insertionOffset = data-&gt;postEventList.size();

    // Exception-safe cleaning up without the need for a try/catch block
    struct CleanUp {
        QObject *receiver;
        int event_type;
        QThreadData *data;
        bool exceptionCaught;

        inline CleanUp(QObject *receiver, int event_type, QThreadData *data) :
            receiver(receiver), event_type(event_type), data(data), exceptionCaught(true)
        {}
        inline ~CleanUp()
        {
            if (exceptionCaught) {
                // since we were interrupted, we need another pass to make sure we clean everything up
                data-&gt;canWait = false;
            }

            --data-&gt;postEventList.recursion;
            if (!data-&gt;postEventList.recursion &amp;&amp; !data-&gt;canWait &amp;&amp; data-&gt;hasEventDispatcher())
                data-&gt;eventDispatcher.load()-&gt;wakeUp();

            // clear the global list, i.e. remove everything that was
            // delivered.
            if (!event_type &amp;&amp; !receiver &amp;&amp; data-&gt;postEventList.startOffset &gt;= 0) {
                const QPostEventList::iterator it = data-&gt;postEventList.begin();
                data-&gt;postEventList.erase(it, it + data-&gt;postEventList.startOffset);
                data-&gt;postEventList.insertionOffset -= data-&gt;postEventList.startOffset;
                Q_ASSERT(data-&gt;postEventList.insertionOffset &gt;= 0);
                data-&gt;postEventList.startOffset = 0;
            }
        }
    };
    CleanUp cleanup(receiver, event_type, data);

   //循环遍历PostEventList
    while (i &lt; data-&gt;postEventList.size()) {
        // avoid live-lock
        if (i &gt;= data-&gt;postEventList.insertionOffset)
            break;

        const QPostEvent &amp;pe = data-&gt;postEventList.at(i);
        ++i;

        if (!pe.event)
            continue;
        if ((receiver &amp;&amp; receiver != pe.receiver) || (event_type &amp;&amp; event_type != pe.event-&gt;type())) {
            data-&gt;canWait = false;
            continue;
        }

        if (pe.event-&gt;type() == QEvent::DeferredDelete) {
            // DeferredDelete events are sent either
            // 1) when the event loop that posted the event has returned; or
            // 2) if explicitly requested (with QEvent::DeferredDelete) for
            //    events posted by the current event loop; or
            // 3) if the event was posted before the outermost event loop.

            int eventLevel = static_cast&lt;QDeferredDeleteEvent *&gt;(pe.event)-&gt;loopLevel();
            int loopLevel = data-&gt;loopLevel + data-&gt;scopeLevel;
            const bool allowDeferredDelete =
                (eventLevel &gt; loopLevel
                 || (!eventLevel &amp;&amp; loopLevel &gt; 0)
                 || (event_type == QEvent::DeferredDelete
                     &amp;&amp; eventLevel == loopLevel));
            if (!allowDeferredDelete) {
                // cannot send deferred delete
                if (!event_type &amp;&amp; !receiver) {
                    // we must copy it first; we want to re-post the event
                    // with the event pointer intact, but we can't delay
                    // nulling the event ptr until after re-posting, as
                    // addEvent may invalidate pe.
                    QPostEvent pe_copy = pe;

                    // null out the event so if sendPostedEvents recurses, it
                    // will ignore this one, as it's been re-posted.
                    const_cast&lt;QPostEvent &amp;&gt;(pe).event = 0;

                    // re-post the copied event so it isn't lost
                    data-&gt;postEventList.addEvent(pe_copy);
                }
                continue;
            }
        }

        // first, we diddle the event so that we can deliver
        // it, and that no one will try to touch it later.
        pe.event-&gt;posted = false;
        QEvent *e = pe.event;
        QObject * r = pe.receiver;

        --r-&gt;d_func()-&gt;postedEvents;
        Q_ASSERT(r-&gt;d_func()-&gt;postedEvents &gt;= 0);

        // next, update the data structure so that we're ready
        // for the next event.
        const_cast&lt;QPostEvent &amp;&gt;(pe).event = 0;

        struct MutexUnlocker
        {
            QMutexLocker &amp;m;
            MutexUnlocker(QMutexLocker &amp;m) : m(m) { m.unlock(); }
            ~MutexUnlocker() { m.relock(); }
        };
        MutexUnlocker unlocker(locker);

        QScopedPointer&lt;QEvent&gt; event_deleter(e); // will delete the event (with the mutex unlocked)

        // after all that work, it's time to deliver the event.
        //sendEvent发送e   到receive
        QCoreApplication::sendEvent(r, e);

        // careful when adding anything below this point - the
        // sendEvent() call might invalidate any invariants this
        // function depends on.
    }

    cleanup.exceptionCaught = false;
}
</code></pre> 
<p>sendPostedEvents 在接收者线程中 遍历postEventList,将事件通过sendEvent(r,e);发送到具体的接收者对象，下面的过程和上面鼠标点击的调用过程相同，最后qttest收到mousePressEvent事件</p> 
<p><img alt="" height="828" src="https://images2.imgbox.com/26/10/FnB4Og2K_o.png" width="1200"></p> 
<h4> 总结：</h4> 
<p>postEvent和sendEvent区别</p> 
<p>（1）</p> 
<p>        qt事件循环需要维护一个事件队列，在Qt的main函数中最后一般调用QApplication::exec()成员函数来保持程序对事件队列的处理，exec()的实质是不停调用processEvent()函数从队列中获取事件，并处理，然后删除，postEvent的作用就是发送一个事件到此队列中，由于删除队列中事件调用delete运算符，所以，postEvent()传递的事件一定要是<strong>动态分配</strong>的。</p> 
<p>        sendEvent()函数直接跳过事件循环队列，直接调用notify()函数发送事件到目标对象，并等待事件处理结果，所以其传递的事件<strong>直接在栈上分配即可，也可以通过堆空间</strong>，(postEvent()函数只负责添加事件到队列，不等待事件处理结果)。</p> 
<p>（2） sendEvent是同步<strong>阻塞型事件发送，</strong>postEvent是异步非阻塞型事件发送</p> 
<p></p> 
<h2>思考：在QWidget（顶层窗口）中放个QPushButton，QPushButton是如果收到鼠标点击事件的？</h2> 
<p>        首先，顶层窗口一定是一个QWindow ，它拥有一个windows native原生窗口来接收系统事件，因此事件首先被QWidget接收到，</p> 
<h3><strong>Native widget or Alien widget</strong></h3> 
<p><br>         Native widget是指拥有windows窗口句柄的widget，占用了内核资源，Alien widget是指依附在某个Native widget上的子窗口，没有windows窗口句柄，不占用内核资源。在qt4.4之前，所有的widget都是Native widget，而且伴随着被人诟病的闪烁现象。qt4.4之后，使用了Alien widget，子窗口默认是一个Alien widget，除非必要，qt不会创建一个Native widget。qt想尽可能地把对窗口的处理从内核转移到qt上，从而拥有更大的自主权。widget的Alien widget和Native widget属性是可以配置的，如果你确实需要一个Native widget，你可以对属性进行显示的配置</p> 
<p>setAttribute(Qt::WA_NativeWindow);</p> 
<h3><br> 创建Native widget</h3> 
<p><br>         如果一个窗口是Alien widget，没有窗口句柄，那他怎么得到windows的消息呢？不能，可以肯定的是一个没有窗口句柄的Alien widget是无法被操作系统感知的。所以，在windows之上，qt建立了自己的窗口系统。然而，qt程序逃避不了的一个事实是：它需要获取windows的消息。要获取操作系统消息的前提是拥有窗口句柄，所以，qt的窗口程序一般是这样的：</p> 
<p>        一个Native widget作为顶层窗口，一些Alien widget窗口作为顶层窗口的后代，依附其上。<br> 这样形式的qt程序，对于操作系统来说，它只看到了Native widget，所以它就认为消息是传递给这个Native widget的；对于qt的窗口系统来说，它看到的是依附于Native widget上绘制出来的数目众多的Alien widget，qt内部再确定该事件正真的目的地是哪个窗口。</p> 
<p>对，没毛病，windows的观点没错，qt的观点就更对了。</p> 
<p>创建一个Native widget就意味着需要注册一个窗口类或者使用同名的已经注册过的窗口类，然后创建一个内核窗口对象，并返回窗口句柄。</p> 
<p>QWidget注册窗口类时使用的窗口过程为qWindowsWndProc：<br>  </p> 
<pre><code>extern "C" LRESULT QT_WIN_CALLBACK qWindowsWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT result;
    const QtWindows::WindowsEventType et = windowsEventType(message, wParam, lParam);
 
    const bool handled = 
      QWindowsContext::instance()-&gt;windowsProc(hwnd, message, et, 
                                               wParam, lParam, &amp;result); 
...
    //qt不感兴趣的消息，直接交由DefWindowProc处理
    if (!handled)
        result = DefWindowProc(hwnd, message, wParam, lParam);
    return result;
}</code></pre> 
<p>        例如，当你点击窗口时，windows感知到了用户对native widget的点击操作，并将消息发送给native widget所在的线程的消息队列，在qt的消息循环中能够GetMessage获取消息，qt使用GetMessage的非阻塞版PeekMessage获取线程队列中的消息，然后通过DispatchMessage将消息转给Native widget的这个窗口过程qWindowsWndProc。</p> 
<p>        窗口过程将消息映射到系统事件类型WindowsEventType，case各种类型，最后将封装好的WindowSystemEvent格式的系统事件放入QWindowSystemInterfacePrivate的全局系统事件队列中。</p> 
<p>        对，一般都是将事件放入windowSystemEventQueue队列中排队。然后就一步步的返回了，最后从DispatchMessage回到事件循环。</p> 
<p>        如果遇到qt不干兴趣的消息，他不会将其放入windowSystemEventQueue队列，而是从windowsProc返回false，交给DefWindowProc进行默认处理。<br>  </p> 
<p>        整体过程了上面举例的QWidget接受到鼠标事件相同，仅仅是多了一步：因为QPushButton是Alien widget，它的鼠标事件首先被native  widget窗口收到，native  widget窗口调用pickMouseReceiver来判断鼠标事件是在哪个子窗口中</p> 
<p><img alt="" height="908" src="https://images2.imgbox.com/ec/56/1IXFJyiG_o.png" width="1200"></p> 
<p>C:\Qt\5.9.8\Src\qtbase\src\widgets\kernel\qapplication.cpp </p> 
<pre><code>void QWidgetWindow::handleMouseEvent(QMouseEvent *event)
{
......
    //QWidget收到信号后，调用childAt判断鼠标位置在哪个子对象中
    // which child should have it?
    QWidget *widget = m_widget-&gt;childAt(event-&gt;pos());
    QPoint mapped = event-&gt;pos();

    if (!widget)
        widget = m_widget;

    if (event-&gt;type() == QEvent::MouseButtonPress)
        qt_button_down = widget;

    //判断真正的 receiver 该接口通过判断，确定鼠标信号应该给哪个控件
    QWidget *receiver = QApplicationPrivate::pickMouseReceiver(m_widget, event-&gt;windowPos().toPoint(), &amp;mapped, event-&gt;type(), event-&gt;buttons(),
                                                               qt_button_down, widget);

......
}</code></pre> 
<p></p> 
<p>void QWidgetWindow::handleMouseEvent(QMouseEvent *event)处理鼠标事件的最终receiver后</p> 
<p>调用 QApplicationPrivate::sendMouseEvent 发送     </p> 
<p>        QApplication::sendSpontaneousEvent(receiver, event);</p> 
<p>                 notifyInternal2(receiver, event);</p> 
<p>                        self-&gt;notify(receiver, event);</p> 
<p>该通过与sendEvent类型</p> 
<p>最终,走到  QPushButton event事件接口，收到鼠标事件</p> 
<p><img alt="" height="676" src="https://images2.imgbox.com/f8/1d/DOPhtLAP_o.png" width="1200"></p> 
<p></p> 
<p> 测试代码：</p> 
<pre><code>
class CustomBtn :public QPushButton {

public:
	CustomBtn(QWidget* parent) :QPushButton(parent) {}

	void mousePressEvent(QMouseEvent *)override {
	
	}

};


qttest::qttest(QWidget *parent)
	: QWidget(parent)
{
	ui.setupUi(this);

	connect(this,&amp;qttest::signal_test1,this,&amp;qttest::slot_test1);
	connect(this, SIGNAL(signal_test1()) , this, SLOT(slot_test1()));
	connect(this, &amp;qttest::signal_test1, [this]() {slot_test1(); });
	signal_test1();
	signal_test2(2);

	QPushButton  * btn = new CustomBtn(this);

	QMouseEvent *ev;
	ev = new QMouseEvent(QEvent::MouseButtonPress, QPoint(10,10), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier);
	//QApplication::postEvent(btn, ev);

}
void qttest::slot_test1() {

}
void qttest::slot_test2(int index) {


}

void qttest::mousePressEvent(QMouseEvent *) {

}

void qttest::leaveEvent(QEvent *event) {

}</code></pre> 
<p>断点：</p> 
<p><img alt="" height="608" src="https://images2.imgbox.com/50/1e/Lg6BTzBN_o.png" width="1200"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d67eeada89b284f1328253e81c8bd803/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Twaver-HTML5基础学习(33)自动布局</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/544b30b633458008b52d09a262b49f90/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">常见通用的join查询</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>