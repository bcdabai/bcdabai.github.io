<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中常用的容器String、vector、list、map（学习笔记） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中常用的容器String、vector、list、map（学习笔记）" />
<meta property="og:description" content="目录 一、String容器
初始化
string对象上的操作 二、vector容器
初始化
区分是列表初始化还是值初始化：
其他操作
三、list容器
四、map容器
这里主要讲C&#43;&#43;中经常用到的一些保存数据的容器，其中也会介绍string。
在C&#43;&#43;11中提到了很多容器，这里主要介绍：vector、list、map。还有一些其他的容器就不做介绍了。
一、String容器 这是我们用得最多的用来表示字符串的类型了 ，下面介绍一下String的一些知识：
初始化 string s1; //这里默认初始化，s1是一个空字符串
string s2 = s1; //s2是s1的副本，此时s2和s1是里面保存的是一样的内容
string s3 = &#34;hiya&#34;; //s3是该字符串字面值的副本
string s3(&#34;hiya&#34;); //等价于上面的s3
string s4(10, &#39;c&#39;); //s4的内容是cccccccccc。（10个c）
string对象上的操作 os&lt;&lt;s; 将s写到输出流os当中，返回os
is&gt;&gt;s; 从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, s) 从is中读取一行赋给s，返回is
s.empty(); s为空返回true，否则返回false
s.size(); 返回s中字符的个数
s[n]; 返回s中第n个字符的引用，位置从0计起
s1 &#43; s2; 返回s1和s2连接后的结果
s1 = s2; 用s2的副本代替s1中原来的字符；
s1 == s2； 如果s1和s2中所含字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感
s1 != s2; &lt;,&lt;=,&gt;,&gt;= 利用字符在字典中的顺序进行比较，且对字母的大小写敏感
这里对于string类型的数据，我们可以像访问数组元素一样访问string中的对应字符。
注：还可以使用迭代器来对字符串类型做一些操作，如" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8d233513d30435d3eb9cf3d2d3eb42a3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-05T19:15:26+08:00" />
<meta property="article:modified_time" content="2023-05-05T19:15:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中常用的容器String、vector、list、map（学习笔记）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="main-toc"><strong>目录</strong></h2> 
<p id="%E4%B8%80%E3%80%81String%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81String%E5%AE%B9%E5%99%A8" rel="nofollow">一、String容器</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">        初始化</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0string%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0string%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0" rel="nofollow">        string对象上的操作       </a></p> 
<p id="%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8" rel="nofollow">二、vector容器</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">        初始化</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%E5%8C%BA%E5%88%86%E6%98%AF%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%98%E6%98%AF%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%E5%8C%BA%E5%88%86%E6%98%AF%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%98%E6%98%AF%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A" rel="nofollow">         区分是列表初始化还是值初始化：</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C" rel="nofollow">        其他操作</a></p> 
<p id="%E4%B8%89%E3%80%81list%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81list%E5%AE%B9%E5%99%A8" rel="nofollow">三、list容器</a></p> 
<p id="%E5%9B%9B%E3%80%81map%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81map%E5%AE%B9%E5%99%A8" rel="nofollow">四、map容器</a></p> 
<hr id="hr-toc"> 
<p>        这里主要讲C++中经常用到的一些保存数据的容器，其中也会介绍string。</p> 
<p>        在C++11中提到了很多容器，这里主要介绍：vector、list、map。还有一些其他的容器就不做介绍了。</p> 
<h3 id="%E4%B8%80%E3%80%81String%E5%AE%B9%E5%99%A8">一、String容器</h3> 
<p>        这是我们用得最多的用来表示字符串的类型了 ，下面介绍一下String的一些知识：</p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96">        初始化</h4> 
<blockquote> 
 <p>                string s1;                                 //这里默认初始化，s1是一个空字符串</p> 
 <p>                string s2 = s1;                        //s2是s1的副本，此时s2和s1是里面保存的是一样的内容</p> 
 <p>                string s3 = "hiya";                //s3是该字符串字面值的副本</p> 
 <p>                string s3("hiya");                  //等价于上面的s3</p> 
 <p>                string s4(10, 'c');                    //s4的内容是cccccccccc。（10个c）</p> 
</blockquote> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0string%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0"><strong>       </strong> string对象上的操作       </h4> 
<blockquote> 
 <p>                os&lt;&lt;s;                   将s写到输出流os当中，返回os</p> 
 <p>                is&gt;&gt;s;                    从is中读取字符串赋给s，字符串以空白分隔，返回is</p> 
 <p>                getline(is, s)       从is中读取一行赋给s，返回is</p> 
 <p>                s.empty();           s为空返回true，否则返回false</p> 
 <p>                s.size();                返回s中字符的个数</p> 
 <p>                s[n];                      返回s中第n个字符的引用，位置从0计起</p> 
 <p>                s1 + s2;                返回s1和s2连接后的结果</p> 
 <p>                s1 = s2;                用s2的副本代替s1中原来的字符；</p> 
 <p>                s1 == s2；          如果s1和s2中所含字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感</p> 
 <p>                s1 != s2;              </p> 
 <p>                &lt;,&lt;=,&gt;,&gt;=           利用字符在字典中的顺序进行比较，且对字母的大小写敏感</p> 
</blockquote> 
<p>        这里对于string类型的数据，我们可以像访问数组元素一样访问string中的对应字符。</p> 
<p><strong>        注：还可以使用迭代器来对字符串类型做一些操作，如</strong></p> 
<pre><code class="language-cpp">   string s("some things");
   if (s.begin() != s.end())
   {
       uto it = s.begin;     //it表示s的第一个字符
       *it = touper(*it);    //将当前字符改为大写形式
   }</code></pre> 
<h3 id="%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8">二、vector容器</h3> 
<p>        vector类型得到标准定义为：vector&lt;T&gt; v1;</p> 
<p>        其中T为类型，这里可以是内置类型，如int等，也可以是结构体或者类类型。</p> 
<h4>        初始化</h4> 
<blockquote> 
 <p>                vector&lt;T&gt; v1;                              //v1是一个空的vector，它潜在的元素是T类型，执行默认初始化</p> 
 <p>                vector&lt;T&gt; v2(v1);                      //v2中包含有v1的所有元素的副本</p> 
 <p>                vector&lt;T&gt; v2 = v1;                     //等价于v2（v1),v2中包含有v1所有元素的副本</p> 
 <p>                vector&lt;T&gt; v3(n, val);                //v3包含了n个重复的元素，每个元素的值都是val</p> 
 <p>                vector&lt;T&gt; v4(n);                        //v4中包含了n个重复执行了值初始化的对象</p> 
 <p>                <span style="color:#fe2c24;">vector&lt;T&gt; v5{a,b,c,......};        //v5包含了初始值个数的元素，每个元素被赋予了相应的初始值</span></p> 
 <p><span style="color:#fe2c24;">                vector&lt;T&gt; v5 = {a,b,c,.......};   //等价于上面的v5</span></p> 
</blockquote> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%20%E5%8C%BA%E5%88%86%E6%98%AF%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%98%E6%98%AF%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"> <strong>        区分是列表初始化还是值初始化：</strong></h4> 
<blockquote> 
 <p>                vector&lt;int&gt; v1(10);          //v1有10个元素，每个元素的值都是0</p> 
 <p>                vector&lt;int&gt; v2{10};         //v2有1个元素，该元素的值为10</p> 
 <p>                vector&lt;int&gt; v3(10,1);      //v3有10个元素，每个元素的值都是1</p> 
 <p>                vector&lt;int&gt; v4{10,1};     //v4有2个元素，值分别为10和1</p> 
</blockquote> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C">        其他操作</h4> 
<blockquote> 
 <p>                v.empty()                 如果v不返回任何元素，返回真，否则返回假</p> 
 <p>                v.size()                     返回v中元素的个数</p> 
 <p>                v.push_back(t)         向v的尾端添加一个值为t的元素</p> 
 <p>                v[n]                          返回v中第n个位置上的元素的引用，从0开始计起</p> 
 <p>                v1 = v2;                    用v2中的元素的拷贝替换v1中的元素</p> 
 <p>                v1 = {a,b,c,......}       用列表中的元素来拷贝替换v1中的元素</p> 
 <p>                v1 == v2                   v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同</p> 
 <p>                v1 != v2                    </p> 
 <p>                &lt;,&lt;=,&gt;,&gt;=                以字典的书序进行比较<br>  </p> 
</blockquote> 
<p>         上述介绍的string和vector我们都可以使用基于范围的for语句来进行范文，如：</p> 
<pre><code class="language-cpp">  string str("hello");
  for(auto c : str)
  cout &lt;&lt; c &lt;&lt; endl;</code></pre> 
<p>        这里将依次输出str中的每一个字符，且每一个字符占一行 </p> 
<pre><code class="language-cpp">vector&lt;string&gt; vec{"hello"， “world"};
for(auto c : vec)
    cout &lt;&lt; c &lt;&lt; endl;</code></pre> 
<p>        这里会输出hello和world，且每个单词占一行</p> 
<p>        对于vector我们还可以通过基于范围的for语句来改变当中的每一个元素的值</p> 
<pre><code class="language-cpp">vector&lt;int&gt; v{1,2,3,4,5,6,7,8,9};
for(auto &amp;i : v) //对于v中的每一个元素（注意：i是一个引用）
    i *= i;        //求每个元素的平方值
for(auto i : v)
    cout &lt;&lt; i &lt;&lt; " ";
cout &lt;&lt; endl;</code></pre> 
<p>        输出结果为：1 4 9 16 25 36 49 64 81</p> 
<p><strong>        注：不能使用下标的形式往vector对象中添加元素</strong></p> 
<h3 id="%E4%B8%89%E3%80%81list%E5%AE%B9%E5%99%A8">三、list容器</h3> 
<p>        这里list和vector基本操作相同，这里就说说它们之间的区别，便于我们选择用哪一种容器更好，区别如下：</p> 
<p>        （1）  vector是顺序表，表示的是一块连续的内存，元素被顺序存储；list是双向连接表，在内存中不一定连续。</p> 
<p>        （2）当数值内存不够时，vector会重新申请一块足够大的连续内存，把原来的数据拷贝到新的内存里面；list因为不用考虑内存的连续，因此新增开销比vector小。</p> 
<p>        （3）list只能通过指针访问元素，随机访问元素的效率特别低，在需要频繁随机存取元素时，使用vector更加合适。</p> 
<p>        （4）当向vector插入或者删除一个元素时，需要复制移动待插入元素右边的所有元素；因此在有频繁插入删除操作时，使用list更加合适。</p> 
<p>        下面介绍一个list和vector中的插入。</p> 
<p>        vector中可以使用push_back()向容易的尾端插入指定的数据，但是不能使用push_front，该函数是向容器的首端插入指定的元素，这里我们就可以使用insert（）函数来实现插入操作，insert包括两个参数，一个参数是迭代器，用于指出插入元素的位置，这里即使是尾端迭代器也可以，所以insert完成的是向该迭代器所指位置的前一个位置插入指定的元素，如：</p> 
<p> <strong>注：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器，如：</strong></p> 
<p>   lst.insert(lst.begin(), lst.begin(), lst.end());// 这里要插入的迭代器容器是lst，但是要拷贝的范围也是lst，所以运行时会出现错误。</p> 
<blockquote> 
 <p>                vector&lt;string&gt; vec;</p> 
 <p>                list&lt;string&gt; lst;</p> 
 <p>                lst.insert(lst.begin(), "Hello");           //向list类型容器的lst的首端插入”Hello“</p> 
 <p>                vec.insert(vec.begin(), "Hello");       //同上</p> 
 <hr> 
 <p>                insert除了上述接收两个参数的形式外，还可以接收三个参数，如：</p> 
 <hr> 
 <p>                vec.insert(vec.begin(), 10, "Hello");                 //添加10个Hello字符串到vec的首端</p> 
 <p>                vector&lt;string&gt; v = {"quasi", "simba", "frollo", "scar"};</p> 
 <p>                vec.insert(vec.begin(), v.end()-2, v.end());      //将v的最后两个插入vec的首端</p> 
 <p>                lst.insert(lst.end(), {"shese", "words", "will", "go”, "at", "the", "end"});      //将后面的列表中的字符串插入lst的尾部</p> 
</blockquote> 
<h3 id="%E5%9B%9B%E3%80%81map%E5%AE%B9%E5%99%A8">四、map容器</h3> 
<p><strong>        map是属于关联容器这一类的，包括两个参数，第一个参数是关键字，第二个参数的该关键字对应的值。</strong></p> 
<p><strong>        对map的一个经典例子是单词计数器程序：</strong></p> 
<pre><code class="language-cpp">map&lt;string, size_t&gt; word_count; //string 到size_t的空map
string word;
while(cin &gt;&gt; word)
    ++word_count[word];   //提取word的计数器并将其加1
for(const auto &amp;w : word_count)   //使用基于范围的for语句依次访问map中的数据
    cout &lt;&lt; w.first &lt;&lt; "occurs" &lt;&lt; w.second &lt;&lt; ((w.second &gt; 1) ? "times" : "time") &lt;&lt; endl;</code></pre> 
<p>        一般很多时候，我们会将map和set连起来一起用，如下面的例子是改进的上面的单词计数器的例子，本例子中只统计不在exclude中的单词.</p> 
<pre><code class="language-cpp">map&lt;string, size_t&gt; word_count;
set&lt;string&gt; exclude = {"the", "But", "And", "At", "A", "An"};
string word;
while(cin &gt;&gt; word)
    if (exclude.find(word) == exclude.end())
       ++word_count[word];</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/75c698a4de10be2aa6a210615d2c7686/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">二叉树基础详解和Python代码定义，各种二叉树遍历方式详解和Python实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b2ebaa251112749be6e610a2ff4f679/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CentOS7下离线安装MySQL8</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>