<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>堆、堆排序、堆应用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="堆、堆排序、堆应用" />
<meta property="og:description" content="一、概述 “堆”（Heap），原地排序、时间复杂度O(nlogn)的排序算法。
堆是一个完全二叉树；堆中每一个节点的值都必须大于等于（或者小于等于）其子树中每个节点的值； 二、如何实现一个堆 使用数组来存储
数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2&#43;1 的节点，父节点就是下标为 2i​ 的节点。
往堆中插入一个数据（堆化）
从下往上堆化
从上往下堆化
删除堆顶元素
可以选择删除堆顶元素后，将堆中的最后一个元素放到堆顶，然后进行从上往下堆化。包含n个节点的完全二叉树，树的高度不会查过log2​n，所以堆化的时间复杂度和树的高度成正比，也就是O(logn)。
三、如何基于堆实现排序 1、建堆
起始堆中只有一个元素，下标为1的数据，然后根据前面的插入操作，将2到下标n的数据依次插入到堆中；从后往前处理数据，叶子节点往下堆化只能自己跟自己比较，所以从最后一个非叶子节点开始，依次堆化；
private static void buildHeap(int[] a, int n) { for (int i = n/2; i &gt;= 1; --i) { heapify(a, n, i); } } private static void heapify(int[] a, int n, int i) { while (true) { int maxPos = i; if (i*2 &lt;= n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2; if (i*2&#43;1 &lt;= n &amp;&amp; a[maxPos] &lt; a[i*2&#43;1]) maxPos = i*2&#43;1; if (maxPos == i) break; swap(a, i, maxPos); i = maxPos; } } 那么建堆时间复杂度是多少？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/febc86db3448331649349addb6ac24c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-27T23:50:11+08:00" />
<meta property="article:modified_time" content="2022-11-27T23:50:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">堆、堆排序、堆应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一、概述</h3> 
<p>“堆”（Heap），原地排序、时间复杂度O(nlogn)的排序算法。</p> 
<ul><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或者小于等于）其子树中每个节点的值；</li></ul> 
<h3><a id="_6"></a>二、如何实现一个堆</h3> 
<p><strong>使用数组来存储</strong><br> 数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为 2i​ 的节点。<br> <img src="https://images2.imgbox.com/9a/04/cBttkxOg_o.png" alt="在这里插入图片描述"><br> <strong>往堆中插入一个数据（堆化）</strong></p> 
<ul><li> <p>从下往上堆化<br> <img src="https://images2.imgbox.com/66/24/vksxOXJO_o.png" alt="在这里插入图片描述"></p> </li><li> <p>从上往下堆化</p> </li></ul> 
<p><strong>删除堆顶元素</strong><br> 可以选择删除堆顶元素后，将堆中的最后一个元素放到堆顶，然后进行<strong>从上往下堆化</strong>。包含n个节点的完全二叉树，树的高度不会查过log2​n，所以堆化的时间复杂度和树的高度成正比，也就是O(logn)。<br> <img src="https://images2.imgbox.com/00/62/jQe0c9bM_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_21"></a>三、如何基于堆实现排序</h3> 
<p><strong>1、建堆</strong></p> 
<ol><li>起始堆中只有一个元素，下标为1的数据，然后根据前面的插入操作，将2到下标n的数据依次插入到堆中；</li><li>从后往前处理数据，叶子节点往下堆化只能自己跟自己比较，所以从最后一个非叶子节点开始，依次堆化；<br> <img src="https://images2.imgbox.com/e0/aa/DpU4cDIy_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/67/d7/4BTdliwe_o.png" alt="在这里插入图片描述"></li></ol> 
<pre><code class="prism language-cpp">
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">buildHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">heapify</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> maxPos <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> maxPos <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>maxPos<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> maxPos <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>maxPos <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> maxPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    i <span class="token operator">=</span> maxPos<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>那么建堆时间复杂度是多少？</strong><br> O(n)。</p> 
<p><strong>2、排序</strong><br> 堆化为大顶堆后，数据已经按照顺序存放了，所以将堆顶数据取出，然后将最后一个元素放入堆顶进行堆化，依次进行。<br> <img src="https://images2.imgbox.com/27/45/VwTcGCDr_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token comment">// n表示数据的个数，数组a中的数据从下标1到n的位置。</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">buildHeap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> k <span class="token operator">=</span> n<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">--</span>k<span class="token punctuation">;</span>
    <span class="token function">heapify</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>时间复杂度</strong>：建堆O(n)，排序O(nlogn)，因此整体时间复杂度是O(nlogn)。</p> 
<h3><a id="_69"></a>四、堆排序和快速排序对比</h3> 
<ul><li>快速排序，数据是顺序访问。而对于堆排序，数据跳着访问，这样对于CPU缓存不友好。</li><li>同样的数据，排序中，堆排序的数据交换次数多于快速排序。</li></ul> 
<h3><a id="_74"></a>五、堆排序的应用</h3> 
<p><strong>1、优先级队列</strong></p> 
<ul><li><strong>合并有序小文件</strong>：100个小文件，每个文件大小100MB，每个文件里都是有序的字符串，希望将这100个文件合并成一个有序的大文件。操作类似于归并排序，从100个文件中，各取一个字符串，放入数组中，然后比较大小，再把最小的字符串放入合并后的大文件，并从数组中删除。另外可以组建<strong>小顶堆</strong>，每次取堆顶元素放入合并的大文件，在从小文件中取下一个字符串放入堆中，依次玄幻操作。</li><li><strong>高性能服务器</strong>：定时器中维护很多定时任务，每个任务都有一个出发执行的时间点，定时器需要固定时间（1S），扫描一遍任务列表，查看是否有任务到达执行时间。如果把任务列表按照还需要等待时间的长短设计为一个小顶堆，那么定时器只需要到点0去看看堆顶的任务有没有到达执行时间就可，然后计算新的堆顶任务剩余的时间T，然后等待T秒再来取任务。</li></ul> 
<p><strong>2、利用堆求Top K</strong><br> 针对静态数据集合，组件一个大小为K的大顶堆，依次从数组中取元素和堆顶元素进行比较，遍历完数组后，堆中的元素就是Top k数据了。遍历数组时间复杂度时O(n)，每次堆化需要O(logK)的时间复杂度，所以整体最坏情况下，n个元素都入堆依次，总的时间复杂度就是O(nlogK)。</p> 
<p><strong>3、利用堆求中位数</strong><br> 对于<strong>静态数据</strong>，中位数是固定的，可以先排序，第n/2个数据就是中位数。每次询问中位数时可以直接返回，当时如果是动态数据集合时，中位数不停的变动，每次询问都需要排序。<br> 可以借助堆，维护一个<strong>大顶堆存前n/2或n/2+1个数据，再维护一个小顶堆，存后n/2个数据</strong>。新加入一个数据时，如果数据小于大顶堆中的元素，将数据插入大顶堆；否则，将数据插入到小顶堆。如果插入后两个堆中的数据不满足前面的约定，从一个堆中取出元素移动到另一个堆中。<br> <img src="https://images2.imgbox.com/f9/ae/RTSx8FV0_o.png" alt="在这里插入图片描述"><br> <strong>如何求接口的99%相应时间？</strong><br> 将上面的大小堆个数比按照99:1设计。</p> 
<p><strong>4、如何获取Top 10最热门的搜索关键词</strong><br> 假设现在有一个包含 10 亿个搜索关键词的日志文件，如何能快速获取到热门榜 Top 10 的搜索关键词呢？<br> 单机环境，内存1GB。<br> 首先统计每个关键词出现的频率，使用散列表、平衡二叉树或者其他支持快速查找、插入的数据结构记录关键词及其出现的次数。<br> 顺序扫描10亿个关键词，扫描到后在散列表中查找，有的话次数+1，没有的话插入，以此类推。然后构建Top K的小顶堆，遍历散列表，依次与堆顶元素进行对比。遍历完散列表后，堆中的元素就是Top K频率的关键词。<br> 如果10亿中的关键词很多，假如说有1亿条，每个关键词平均长度50字节，那么存储就需要5GB的内存空间，那么散列表为了避免频繁冲突。所以需要的内存空间大。1GB可能不够用。因此所以需要创建10个空文件00、01、02…，09，遍历10亿个关键字，按照哈希算法将结果取10的模，得到结果就是此关键词被分到的文件编号。然后利用散列表和堆，分别求出每个文件的Top 10，然后将每个文件的Top 10放在一块100个关键词求其Top 10就可。</p> 
<p><strong>5、求每间隔1小时新闻网站点击Top 10的新闻</strong><br> 有一个访问量非常大的新闻网站，希望将点击量排名 Top 10 的新闻摘要，滚动显示在网站首页 banner 上，并且每隔 1 小时更新一次。如何来实现呢？<br> 根据新闻个数构建散列表，每点击一次更新其点击量；<br> 每隔一个小时遍历散列表维护一个大小为10的小顶堆；</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d4bda0662843bcf5f0f200dc1be84cf5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CVE-2022-28060(Victor CMS v1.0 )</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9771d00790a461a4812c9232acb2d439/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【学习笔记46】JavaScript购物车的实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>