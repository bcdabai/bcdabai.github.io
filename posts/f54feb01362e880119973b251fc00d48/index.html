<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s ------存储卷（PV、PVC） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s ------存储卷（PV、PVC）" />
<meta property="og:description" content="目录
一：为什么需要存储卷？
二：emptyDir存储卷 ​三：hostPath存储卷 四：nfs共享存储卷 五：PVC 和 PV
1、PVC 和 PV介绍
2、PV和PVC之间的相互作用遵循的生命周期
3、PV 的4 种状态
4、一个PV从创建到销毁的具体流程
六：静态创建pv和pvc资源由pod运用过程
​1、配置nfs存储
​2、定义PV
​3、定义PVC
4、测试访问
七、StorageClass &#43; nfs-client-provisioner搭建动态创建pv
1、创建共享目录
2、创建 Service Account
3、使用 Deployment 来创建 NFS Provisioner
4、创建 StorageClass
5、创建 PVC 和 Pod 测试
一：为什么需要存储卷？ 容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题。首先，当容器崩溃时，kubelet 会重启它，但是容器中的文件将丢失——容器以干净的状态（镜像最初的状态）重新启动。其次，在Pod中同时运行多个容器时，这些容器之间通常需要共享文件。Kubernetes 中的Volume抽象就很好的解决了这些问题。Pod中的容器通过Pause容器共享Volume。
二：emptyDir存储卷 当Pod被分配给节点时，首先创建emptyDir卷，并且只要该Pod在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod 中的容器可以读取和写入emptyDir卷中的相同文件，尽管该卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除 Pod 时，emptyDir中的数据将被永久删除。
emptyDir可实现Pod中的容器之间共享目录数据，但是emptyDir卷不能持久化数据，会随着Pod生命周期结束而一起删除。
mkdir /opt/volumes cd /opt/volumes vim pod-emptydir.yaml apiVersion: v1 kind: Pod metadata: name: pod-emptydir namespace: default labels: app: myapp tier: frontend spec: containers: - name: myapp image: ikubernetes/myapp:v1 imagePullPolicy: IfNotPresent ports: - name: http containerPort: 80 #定义容器挂载内容 volumeMounts: #使用的存储卷名称，如果跟下面volume字段name值相同，则表示使用volume的这个存储卷 - name: html #挂载至容器中哪个目录 mountPath: /usr/share/nginx/html/ - name: busybox image: busybox:latest imagePullPolicy: IfNotPresent volumeMounts: - name: html #在容器内定义挂载存储名称和挂载路径 mountPath: /data/ command: [&#39;/bin/sh&#39;,&#39;-c&#39;,&#39;while true;do echo $(date) &gt;&gt; /data/index." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f54feb01362e880119973b251fc00d48/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-14T18:11:41+08:00" />
<meta property="article:modified_time" content="2023-08-14T18:11:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s ------存储卷（PV、PVC）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AD%98%E5%82%A8%E5%8D%B7%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AD%98%E5%82%A8%E5%8D%B7%EF%BC%9F" rel="nofollow">一：为什么需要存储卷？</a></p> 
<p id="%E4%BA%8C%EF%BC%9AemptyDir%E5%AD%98%E5%82%A8%E5%8D%B7%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%EF%BC%9AemptyDir%E5%AD%98%E5%82%A8%E5%8D%B7%C2%A0" rel="nofollow">二：emptyDir存储卷 </a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%E4%B8%89%EF%BC%9AhostPath%E5%AD%98%E5%82%A8%E5%8D%B7%C2%A0-toc" style="margin-left:0px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%E4%B8%89%EF%BC%9AhostPath%E5%AD%98%E5%82%A8%E5%8D%B7%C2%A0" rel="nofollow">​三：hostPath存储卷 </a></p> 
<p id="%E5%9B%9B%EF%BC%9Anfs%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E5%8D%B7%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%EF%BC%9Anfs%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E5%8D%B7%C2%A0" rel="nofollow">四：nfs共享存储卷 </a></p> 
<p id="%C2%A0%E4%BA%94%EF%BC%9APVC%20%E5%92%8C%20PV-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%EF%BC%9APVC%20%E5%92%8C%20PV" rel="nofollow"> 五：PVC 和 PV</a></p> 
<p id="1%E3%80%81PVC%20%E5%92%8C%20PV%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#1%E3%80%81PVC%20%E5%92%8C%20PV%E4%BB%8B%E7%BB%8D" rel="nofollow">1、PVC 和 PV介绍</a></p> 
<p id="2%E3%80%81PV%E5%92%8CPVC%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8%E9%81%B5%E5%BE%AA%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:40px;"><a href="#2%E3%80%81PV%E5%92%8CPVC%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8%E9%81%B5%E5%BE%AA%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" rel="nofollow">2、PV和PVC之间的相互作用遵循的生命周期</a></p> 
<p id="3%E3%80%81PV%20%E7%9A%844%20%E7%A7%8D%E7%8A%B6%E6%80%81-toc" style="margin-left:40px;"><a href="#3%E3%80%81PV%20%E7%9A%844%20%E7%A7%8D%E7%8A%B6%E6%80%81" rel="nofollow">3、PV 的4 种状态</a></p> 
<p id="4%E3%80%81%E4%B8%80%E4%B8%AAPV%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E9%94%80%E6%AF%81%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E4%B8%80%E4%B8%AAPV%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E9%94%80%E6%AF%81%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B" rel="nofollow">4、一个PV从创建到销毁的具体流程</a></p> 
<p id="%E5%85%AD%EF%BC%9A%E9%9D%99%E6%80%81%E5%88%9B%E5%BB%BApv%E5%92%8Cpvc%E8%B5%84%E6%BA%90%E7%94%B1pod%E8%BF%90%E7%94%A8%E8%BF%87%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E5%85%AD%EF%BC%9A%E9%9D%99%E6%80%81%E5%88%9B%E5%BB%BApv%E5%92%8Cpvc%E8%B5%84%E6%BA%90%E7%94%B1pod%E8%BF%90%E7%94%A8%E8%BF%87%E7%A8%8B" rel="nofollow">六：静态创建pv和pvc资源由pod运用过程</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%911%E3%80%81%E9%85%8D%E7%BD%AEnfs%E5%AD%98%E5%82%A8-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%911%E3%80%81%E9%85%8D%E7%BD%AEnfs%E5%AD%98%E5%82%A8" rel="nofollow">​1、配置nfs存储</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%912%E3%80%81%E5%AE%9A%E4%B9%89PV-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%912%E3%80%81%E5%AE%9A%E4%B9%89PV" rel="nofollow">​2、定义PV</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%913%E3%80%81%E5%AE%9A%E4%B9%89PVC-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%913%E3%80%81%E5%AE%9A%E4%B9%89PVC" rel="nofollow">​3、定义PVC</a></p> 
<p id="4%E3%80%81%E6%B5%8B%E8%AF%95%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%B5%8B%E8%AF%95%E8%AE%BF%E9%97%AE" rel="nofollow">4、测试访问</a></p> 
<p id="%E4%B8%83%E3%80%81StorageClass%20%2B%20nfs-client-provisioner%E6%90%AD%E5%BB%BA%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BApv-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81StorageClass%20%2B%20nfs-client-provisioner%E6%90%AD%E5%BB%BA%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BApv" rel="nofollow">七、StorageClass + nfs-client-provisioner搭建动态创建pv</a></p> 
<p id="1%E3%80%81%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95" rel="nofollow">1、创建共享目录</a></p> 
<p id="2%E3%80%81%E5%88%9B%E5%BB%BA%20Service%20Account-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%88%9B%E5%BB%BA%20Service%20Account" rel="nofollow">2、创建 Service Account</a></p> 
<p id="%C2%A03%E3%80%81%E4%BD%BF%E7%94%A8%20Deployment%20%E6%9D%A5%E5%88%9B%E5%BB%BA%20NFS%20Provisioner-toc" style="margin-left:40px;"><a href="#%C2%A03%E3%80%81%E4%BD%BF%E7%94%A8%20Deployment%20%E6%9D%A5%E5%88%9B%E5%BB%BA%20NFS%20Provisioner" rel="nofollow"> 3、使用 Deployment 来创建 NFS Provisioner</a></p> 
<p id="%C2%A04%E3%80%81%E5%88%9B%E5%BB%BA%20StorageClass-toc" style="margin-left:40px;"><a href="#%C2%A04%E3%80%81%E5%88%9B%E5%BB%BA%20StorageClass" rel="nofollow"> 4、创建 StorageClass</a></p> 
<p id="%C2%A05%E3%80%81%E5%88%9B%E5%BB%BA%20PVC%20%E5%92%8C%20Pod%20%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#%C2%A05%E3%80%81%E5%88%9B%E5%BB%BA%20PVC%20%E5%92%8C%20Pod%20%E6%B5%8B%E8%AF%95" rel="nofollow"> 5、创建 PVC 和 Pod 测试</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AD%98%E5%82%A8%E5%8D%B7%EF%BC%9F">一：为什么需要存储卷？</h2> 
<p>容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题。首先，当容器崩溃时，kubelet 会重启它，但是容器中的文件将丢失——容器以干净的状态（镜像最初的状态）重新启动。其次，在Pod中同时运行多个容器时，这些容器之间通常需要共享文件。Kubernetes 中的Volume抽象就很好的解决了这些问题。Pod中的容器通过Pause容器共享Volume。</p> 
<h2 id="%E4%BA%8C%EF%BC%9AemptyDir%E5%AD%98%E5%82%A8%E5%8D%B7%C2%A0">二：emptyDir存储卷 </h2> 
<p>当Pod被分配给节点时，首先创建emptyDir卷，并且只要该Pod在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod 中的容器可以读取和写入emptyDir卷中的相同文件，尽管该卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除 Pod 时，emptyDir中的数据将被永久删除。</p> 
<p><strong>emptyDir可实现Pod中的容器之间共享目录数据，但是emptyDir卷不能持久化数据，会随着Pod生命周期结束而一起删除。</strong></p> 
<pre><code>mkdir /opt/volumes
cd /opt/volumes

vim pod-emptydir.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: pod-emptydir
  namespace: default
  labels:
    app: myapp
    tier: frontend
spec:
  containers:
  - name: myapp
    image: ikubernetes/myapp:v1
    imagePullPolicy: IfNotPresent
    ports:
    - name: http
      containerPort: 80
    #定义容器挂载内容
    volumeMounts:
    #使用的存储卷名称，如果跟下面volume字段name值相同，则表示使用volume的这个存储卷
    - name: html
      #挂载至容器中哪个目录
      mountPath: /usr/share/nginx/html/
  - name: busybox
    image: busybox:latest
    imagePullPolicy: IfNotPresent
    volumeMounts:
    - name: html
      #在容器内定义挂载存储名称和挂载路径
      mountPath: /data/
    command: ['/bin/sh','-c','while true;do echo $(date) &gt;&gt; /data/index.html;sleep 2;done']
  #定义存储卷
  volumes:
  #定义存储卷名称  
  - name: html
    #定义存储卷类型
    emptyDir: {}
    
    
kubectl apply -f pod-emptydir.yaml

kubectl get pods -o wide
NAME           READY   STATUS    RESTARTS   AGE   IP            NODE     NOMINATED NODE   READINESS GATES
pod-emptydir   2/2     Running   0          36s   10.244.2.19   node02   &lt;none&gt;           &lt;none&gt;

//在上面定义了2个容器，其中一个容器是输入日期到index.html中，然后验证访问nginx的html是否可以获取日期。以验证两个容器之间挂载的emptyDir实现共享。
curl 10.244.2.19
Thu May 27 18:17:11 UTC 2021
Thu May 27 18:17:13 UTC 2021
Thu May 27 18:17:15 UTC 2021
Thu May 27 18:17:17 UTC 2021
Thu May 27 18:17:19 UTC 2021
Thu May 27 18:17:21 UTC 2021
Thu May 27 18:17:23 UTC 2021</code></pre> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91%E4%B8%89%EF%BC%9AhostPath%E5%AD%98%E5%82%A8%E5%8D%B7%C2%A0"><img alt="" height="813" src="https://images2.imgbox.com/28/42/DPZpTowk_o.png" width="1147"><br> 三：hostPath存储卷 </h2> 
<p>hostPath卷将 node 节点的文件系统中的文件或目录挂载到集群中。<br> hostPath可以实现持久存储，但是在node节点故障时，也会导致数据的丢失。</p> 
<p><strong>把Node节点上的目录/文件挂载到容器中，可实现持久化数据存储。但是存储空间会受到Node节点的单机限制，Node节点故障数据就会丢失，且Pod不能实现跨节点共享数据</strong></p> 
<pre><code>//在 node01 节点上创建挂载目录
mkdir -p /data/pod/volume1
echo 'node01.kgc.com' &gt; /data/pod/volume1/index.html

//在 node02 节点上创建挂载目录
mkdir -p /data/pod/volume1
echo 'node02.kgc.com' &gt; /data/pod/volume1/index.html

//创建 Pod 资源
vim pod-hostpath.yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-hostpath
  namespace: default
spec:
  containers:
  - name: myapp
    image: ikubernetes/myapp:v1
    #定义容器挂载内容
    volumeMounts:
    #使用的存储卷名称，如果跟下面volume字段name值相同，则表示使用volume的这个存储卷
    - name: html
      #挂载至容器中哪个目录
      mountPath: /usr/share/nginx/html
      #读写挂载方式，默认为读写模式false
      readOnly: false
  #volumes字段定义了paues容器关联的宿主机或分布式文件系统存储卷
  volumes:
    #存储卷名称
    - name: html
      #路径，为宿主机存储路径
      hostPath:
        #在宿主机上目录的路径
        path: /data/pod/volume1
        #定义类型，这表示如果宿主机没有此目录则会自动创建
        type: DirectoryOrCreate


kubectl apply -f pod-hostpath.yaml

//访问测试
kubectl get pods -o wide
NAME           READY   STATUS    RESTARTS   AGE   IP            NODE     NOMINATED NODE   READINESS GATES
pod-hostpath   2/2     Running   0          37s   10.244.2.35   node02   &lt;none&gt;           &lt;none&gt;

curl 10.244.2.35
node02.kgc.com

//删除pod，再重建，验证是否依旧可以访问原来的内容
kubectl delete -f pod-hostpath.yaml  
kubectl apply -f pod-hostpath.yaml 

kubectl get pods -o wide
NAME           READY   STATUS    RESTARTS   AGE   IP            NODE     NOMINATED NODE   READINESS GATES
pod-hostpath   2/2     Running   0          36s   10.244.2.37   node02   &lt;none&gt;           &lt;none&gt;

curl  10.244.2.37 
node02.kgc.com</code></pre> 
<p><img alt="" height="402" src="https://images2.imgbox.com/52/41/gl0JDGt7_o.png" width="1164"></p> 
<p><img alt="" height="704" src="https://images2.imgbox.com/d6/f0/eadHKPxu_o.png" width="857"></p> 
<p> </p> 
<h2 id="%E5%9B%9B%EF%BC%9Anfs%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E5%8D%B7%C2%A0">四：nfs共享存储卷 </h2> 
<pre><code>
//在stor01节点上安装nfs，并配置nfs服务
mkdir /data/volumes -p
chmod 777 /data/volumes

vim /etc/exports
/data/volumes 192.168.80.0/24(rw,no_root_squash)

systemctl start rpcbind
systemctl start nfs

showmount -e
Export list for stor01:
/data/volumes 192.168.80.0/24


//master节点操作
vim pod-nfs-vol.yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-vol-nfs
  namespace: default
spec:
  containers:
  - name: myapp
    image: ikubernetes/myapp:v1
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
  volumes:
    - name: html
      nfs:
        path: /data/volumes
        server: stor01


kubectl apply -f pod-nfs-vol.yaml

kubectl get pods -o wide
NAME                     READY     STATUS    RESTARTS   AGE       IP            NODE
pod-vol-nfs              1/1       Running   0          21s       10.244.2.38   node02


//在nfs服务器上创建index.html
cd /data/volumes
vim index.html
&lt;h1&gt; nfs stor01&lt;/h1&gt;

//master节点操作
curl 10.244.2.38
&lt;h1&gt; nfs stor01&lt;/h1&gt;

kubectl delete -f pod-nfs-vol.yaml   #删除nfs相关pod，再重新创建，可以得到数据的持久化存储

kubectl apply -f pod-nfs-vol.yaml</code></pre> 
<p><img alt="" height="641" src="https://images2.imgbox.com/b6/c5/2YqNN10u_o.png" width="899"></p> 
<p><img alt="" height="698" src="https://images2.imgbox.com/8b/e7/ubZudKYd_o.png" width="691"></p> 
<p> <img alt="" height="601" src="https://images2.imgbox.com/ad/40/X2YtLXrd_o.png" width="1149"></p> 
<h2 id="%C2%A0%E4%BA%94%EF%BC%9APVC%20%E5%92%8C%20PV"> 五：PVC 和 PV</h2> 
<h3 id="1%E3%80%81PVC%20%E5%92%8C%20PV%E4%BB%8B%E7%BB%8D">1、PVC 和 PV介绍</h3> 
<p>PV 全称叫做 Persistent Volume，<strong><span style="color:#fe2c24;">持久化存储卷</span></strong>。它是用来描述或者说用来定义一个存储卷的，这个通常都是由运维工程师来定义。</p> 
<p>PVC 的全称是 Persistent Volume Claim，是<strong><span style="color:#fe2c24;">持久化存储的请求</span></strong>。它是用来描述希望使用什么样的或者说是满足什么条件的 PV 存储。</p> 
<p>PVC 的使用逻辑：在 Pod 中定义一个存储卷（该存储卷类型为 PVC），定义的时候直接指定大小，PVC 必须与对应的 PV 建立关系，PVC 会根据配置的定义去 PV 申请，而 PV 是由存储空间创建出来的。PV 和 PVC 是 Kubernetes 抽象出来的一种存储资源。</p> 
<p>一个PV可以个一个或多个POD使用，PV是k8s集群里专用的存储资源，是逻辑划分存储设备空间的资源对象。存储资源要提供存储空间给存储资源使用，不能凭空出现。真正提供存储空间的是存储设备，如硬盘挂载的目录，nfs共享的目录，ceph分布式存储等。<br> 我们作为K8S集群管理员，可以在K8S集群中创建PV，再从存储设备划分存储空间给PV<br> 然后我的POD想引用哪个PV，得先定义一个PVC，用来描述希望使用什么样的或者说是满足什么条件的 PV 存储，比如多大存储空间，是专用，是一对一，还是一对多，POD会根据PVC去找符合条件的PV进行绑定，最后给POD挂载使用。<br> 上面介绍的PV和PVC模式是需要运维人员先创建好PV，然后开发人员定义好PVC进行一对一的Bond，但是如果PVC请求成千上万，那么就需要创建成千上万的PV，对于运维人员来说维护成本很高，Kubernetes提供一种自动创建PV的机制，叫StorageClass，它的作用就是创建PV的模板。</p> 
<p>创建 StorageClass 需要定义 PV 的属性，比如存储类型、大小等；另外创建这种 PV 需要用到的存储插件，比如 Ceph 等。 有了这两部分信息，Kubernetes 就能够根据用户提交的 PVC，找到对应的 StorageClass，然后 Kubernetes 就会调用 StorageClass 声明的存储插件，自动创建需要的 PV 并进行绑定。</p> 
<p>PV是集群中的资源。 PVC是对这些资源的请求，也是对资源的索引检查。 </p> 
<h3 id="2%E3%80%81PV%E5%92%8CPVC%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8%E9%81%B5%E5%BE%AA%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">2、PV和PVC之间的相互作用遵循的生命周期</h3> 
<p>PV和PVC之间的相互作用遵循这个生命周期：<br><strong><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">Provisioning（配置）---&gt; Binding（绑定）---&gt; Using（使用）---&gt; Releasing（释放） ---&gt; Recycling（回收）</span></span></strong></p> 
<p><strong><span style="color:#fe2c24;">●Provisioning</span></strong>，即 PV 的创建，可以直接创建 PV（静态方式），也可以使用 StorageClass 动态创建<br><strong><span style="color:#fe2c24;">●Binding</span></strong>，将 PV 分配给 PVC<br><strong><span style="color:#fe2c24;">●Using</span></strong>，Pod 通过 PVC 使用该 Volume，并可以通过准入控制StorageProtection（1.9及以前版本为PVCProtection） 阻止删除正在使用的 PVC<br><strong><span style="color:#fe2c24;">●Releasing</span></strong>，Pod 释放 Volume 并删除 PVC<br><strong><span style="color:#fe2c24;">●Reclaiming</span></strong>，回收 PV，可以保留 PV 以便下次使用，也可以直接从云存储中删除</p> 
<h3 id="3%E3%80%81PV%20%E7%9A%844%20%E7%A7%8D%E7%8A%B6%E6%80%81">3、PV 的4 种状态</h3> 
<p><strong><span style="color:#fe2c24;">●Available（可用）</span></strong>：表示可用状态，还未被任何 PVC 绑定<br><strong><span style="color:#fe2c24;">●Bound（已绑定）</span></strong>：表示 PV 已经绑定到 PVC<br><strong><span style="color:#fe2c24;">●Released（已释放）</span></strong>：表示 PVC 被删掉，但是资源尚未被集群回收<br><strong><span style="color:#fe2c24;">●Failed（失败）</span></strong>：表示该 PV 的自动回收失败</p> 
<h3 id="4%E3%80%81%E4%B8%80%E4%B8%AAPV%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E9%94%80%E6%AF%81%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B">4、一个PV从创建到销毁的具体流程</h3> 
<p>1、一个PV创建完后状态会变成Available，等待被PVC绑定。<br> 2、一旦被PVC邦定，PV的状态会变成Bound，就可以被定义了相应PVC的Pod使用。<br> 3、Pod使用完后会释放PV，PV的状态变成Released。<br> 4、变成Released的PV会根据定义的回收策略做相应的回收工作。有三种回收策略，Retain、Delete和Recycle。Retain就是保留现场，K8S集群什么也不做，等待用户手动去处理PV里的数据，处理完后，再手动删除PV。Delete策略，K8S会自动删除该PV及里面的数据。Recycle方式，K8S会将PV里的数据删除，然后把PV的状态变成Available，又可以被新的PVC绑定使用。</p> 
<pre><code class="hljs">kubectl explain pv    #查看pv的定义方式
FIELDS:
    apiVersion: v1
    kind: PersistentVolume
    metadata:    #由于 PV 是集群级别的资源，即 PV 可以跨 namespace 使用，所以 PV 的 metadata 中不用配置 namespace
      name: 
    spec
    
kubectl explain pv.spec    #查看pv定义的规格
spec:
  nfs:（定义存储类型）
    path:（定义挂载卷路径）
    server:（定义服务器名称）
  accessModes:（定义访问模型，有以下三种访问模型，以列表的方式存在，也就是说可以定义多个访问模式）
    - ReadWriteOnce          #（RWO）卷可以被一个节点以读写方式挂载。 ReadWriteOnce 访问模式也允许运行在同一节点上的多个 Pod 访问卷。
    - ReadOnlyMany           #（ROX）卷可以被多个节点以只读方式挂载。
    - ReadWriteMany          #（RWX）卷可以被多个节点以读写方式挂载。
#nfs 支持全部三种；iSCSI 不支持 ReadWriteMany（iSCSI 就是在 IP 网络上运行 SCSI 协议的一种网络存储技术）；HostPath 不支持 ReadOnlyMany 和 ReadWriteMany。
  capacity:（定义存储能力，一般用于设置存储空间）
    storage: 2Gi （指定大小）
  storageClassName: （自定义存储类名称，此配置用于绑定具有相同类别的PVC和PV）
  persistentVolumeReclaimPolicy: Retain    #回收策略（Retain/Delete/Recycle）
#Retain（保留）：当用户删除与之绑定的PVC时候，这个PV被标记为released（PVC与PV解绑但还没有执行回收策略）且之前的数据依然保存在该PV上，但是该PV不可用，需要手动来处理这些数据并删除该PV。
#Delete（删除）：删除与PV相连的后端存储资源。对于动态配置的PV来说，默认回收策略为Delete。表示当用户删除对应的PVC时，动态配置的volume将被自动删除。（只有 AWS EBS, GCE PD, Azure Disk 和 Cinder 支持）
#Recycle（回收）：如果用户删除PVC，则删除卷上的数据，卷不会删除。（只有 NFS 和 HostPath 支持）

kubectl explain pvc   #查看PVC的定义方式
KIND:     PersistentVolumeClaim
VERSION:  v1
FIELDS:
   apiVersion    &lt;string&gt;
   kind    &lt;string&gt;  
   metadata    &lt;Object&gt;
   spec    &lt;Object&gt;

#PV和PVC中的spec关键字段要匹配，比如存储（storage）大小、访问模式（accessModes）、存储类名称（storageClassName）
kubectl explain pvc.spec
spec:
  accessModes: （定义访问模式，必须是PV的访问模式的子集）
  resources:
    requests:
      storage: （定义申请资源的大小）
  storageClassName: （定义存储类名称，此配置用于绑定具有相同类别的PVC和PV）</code></pre> 
<h2 id="%E5%85%AD%EF%BC%9A%E9%9D%99%E6%80%81%E5%88%9B%E5%BB%BApv%E5%92%8Cpvc%E8%B5%84%E6%BA%90%E7%94%B1pod%E8%BF%90%E7%94%A8%E8%BF%87%E7%A8%8B">六：静态创建pv和pvc资源由pod运用过程</h2> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%911%E3%80%81%E9%85%8D%E7%BD%AEnfs%E5%AD%98%E5%82%A8"><img alt="" height="656" src="https://images2.imgbox.com/09/6d/1RorMzgp_o.png" width="1200"><br> 1、配置nfs存储</h3> 
<pre><code class="hljs">mkdir v{1,2,3,4,5}

vim /etc/exports
/data/volumes/v1 192.168.231.0/24(rw,no_root_squash)
/data/volumes/v2 192.168.231.0/24(rw,no_root_squash)
/data/volumes/v3 192.168.231.0/24(rw,no_root_squash)
/data/volumes/v4 192.168.231.0/24(rw,no_root_squash)
/data/volumes/v5 192.168.231.0/24(rw,no_root_squash)

exportfs -arv

showmount -e</code></pre> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%912%E3%80%81%E5%AE%9A%E4%B9%89PV"><img alt="" height="265" src="https://images2.imgbox.com/9e/7c/5mvfnwHv_o.png" width="1200"><br> 2、定义PV</h3> 
<pre><code class="hljs">//这里定义5个PV，并且定义挂载的路径以及访问模式，还有PV划分的大小。
vim pv-demo.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv001
  labels:
    name: pv001
spec:
  nfs:
    path: /data/volumes/v1
    server: stor01
  accessModes: ["ReadWriteMany","ReadWriteOnce"]
  capacity:
    storage: 1Gi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv002
  labels:
    name: pv002
spec:
  nfs:
    path: /data/volumes/v2
    server: stor01
  accessModes: ["ReadWriteOnce"]
  capacity:
    storage: 2Gi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv003
  labels:
    name: pv003
spec:
  nfs:
    path: /data/volumes/v3
    server: stor01
  accessModes: ["ReadWriteMany","ReadWriteOnce"]
  capacity:
    storage: 2Gi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv004
  labels:
    name: pv004
spec:
  nfs:
    path: /data/volumes/v4
    server: stor01
  accessModes: ["ReadWriteMany","ReadWriteOnce"]
  capacity:
    storage: 4Gi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv005
  labels:
    name: pv005
spec:
  nfs:
    path: /data/volumes/v5
    server: stor01
  accessModes: ["ReadWriteMany","ReadWriteOnce"]
  capacity:
    storage: 5Gi

 


kubectl apply -f pv-demo.yaml

kubectl get pv
NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE
pv001     1Gi        RWO,RWX        Retain           Available                                      7s
pv002     2Gi        RWO            Retain           Available                                      7s
pv003     2Gi        RWO,RWX        Retain           Available                                      7s
pv004     4Gi        RWO,RWX        Retain           Available                                      7s
pv005     5Gi        RWO,RWX        Retain           Available                                       7s</code></pre> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%913%E3%80%81%E5%AE%9A%E4%B9%89PVC"><img alt="" height="295" src="https://images2.imgbox.com/00/6b/oDQRb6ZL_o.png" width="1200"><br> 3、定义PVC</h3> 
<pre><code class="hljs">//这里定义了pvc的访问模式为多路读写，该访问模式必须在前面pv定义的访问模式之中。定义PVC申请的大小为2Gi，此时PVC会自动去匹配多路读写且大小为2Gi的PV，匹配成功获取PVC的状态即为Bound
vim pod-vol-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mypvc
  namespace: default
spec:
  accessModes: ["ReadWriteMany"]
  resources:
    requests:
      storage: 2Gi
---
apiVersion: v1
kind: Pod
metadata:
  name: pod-vol-pvc
  namespace: default
spec:
  containers:
  - name: myapp
    image: ikubernetes/myapp:v1
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
  volumes:
    - name: html
      persistentVolumeClaim:
        claimName: mypvc

 


kubectl apply -f pod-vol-pvc.yaml

kubectl get pv
NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM           STORAGECLASS   REASON    AGE
pv001     1Gi        RWO,RWX        Retain           Available                                            19m
pv002     2Gi        RWO            Retain           Available                                            19m
pv003     2Gi        RWO,RWX        Retain           Bound       default/mypvc                            19m
pv004     4Gi        RWO,RWX        Retain           Available                                            19m
pv005     5Gi        RWO,RWX        Retain           Available                                            19m

kubectl get pvc
NAME      STATUS    VOLUME    CAPACITY   ACCESS MODES   STORAGECLASS   AGE
mypvc     Bound     pv003     2Gi        RWO,RWX                       22s</code></pre> 
<h3 id="4%E3%80%81%E6%B5%8B%E8%AF%95%E8%AE%BF%E9%97%AE">4、测试访问</h3> 
<pre><code class="hljs">//在存储服务器上创建index.html，并写入数据，通过访问Pod进行查看，可以获取到相应的页面。
cd /data/volumes/v3/
echo "welcome to use pv3" &gt; index.html

kubectl get pods -o wide
pod-vol-pvc             1/1       Running   0          3m        10.244.2.39   k8s-node02

curl  10.244.2.39
welcome to use pv3</code></pre> 
<h2 id="%E4%B8%83%E3%80%81StorageClass%20%2B%20nfs-client-provisioner%E6%90%AD%E5%BB%BA%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BApv">七、StorageClass + nfs-client-provisioner搭建动态创建pv</h2> 
<p><strong>StorageClass + nfs-client-provisioner的理解</strong></p> 
<p>Kubernetes 本身支持的动态 PV 创建不包括 NFS，所以需要使用外部存储卷插件分配PV。详见：https://kubernetes.io/zh/docs/concepts/storage/storage-classes/</p> 
<p>卷插件称为 Provisioner（存储分配器），NFS 使用的是 nfs-client，这个外部卷插件会使用已经配置好的 NFS 服务器自动创建 PV。<br> Provisioner：用于指定 Volume 插件的类型，包括内置插件（如 kubernetes.io/aws-ebs）和外部插件（如 external-storage 提供的 ceph.com/cephfs）。1、在stor01节点上安装nfs，并配置nfs服务</p> 
<h3 id="1%E3%80%81%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95">1、创建共享目录</h3> 
<pre><code class="hljs">mkdir /opt/k8s
chmod 777 /opt/k8s/

vim /etc/exports
/opt/k8s 192.168.231.0/24(rw,no_root_squash,sync)

systemctl restart nfs</code></pre> 
<p><img alt="" height="271" src="https://images2.imgbox.com/b8/1c/0nONRKQn_o.png" width="966"></p> 
<h3 id="2%E3%80%81%E5%88%9B%E5%BB%BA%20Service%20Account">2、创建 Service Account</h3> 
<p>用来管理 NFS Provisioner 在 k8s 集群中运行的权限，设置 nfs-client 对 PV，PVC，StorageClass 等的规则</p> 
<pre><code class="hljs">vim nfs-client-rbac.yaml
#创建 Service Account 账户，用来管理 NFS Provisioner 在 k8s 集群中运行的权限
apiVersion: v1
kind: ServiceAccount
metadata:
  name: nfs-client-provisioner
---
#创建集群角色
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: nfs-client-provisioner-clusterrole
rules:
  - apiGroups: [""]
    resources: ["persistentvolumes"]
    verbs: ["get", "list", "watch", "create", "delete"]
  - apiGroups: [""]
    resources: ["persistentvolumeclaims"]
    verbs: ["get", "list", "watch", "update"]
  - apiGroups: ["storage.k8s.io"]
    resources: ["storageclasses"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["list", "watch", "create", "update", "patch"]
  - apiGroups: [""]
    resources: ["endpoints"]
    verbs: ["create", "delete", "get", "list", "watch", "patch", "update"]
---
#集群角色绑定
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: nfs-client-provisioner-clusterrolebinding
subjects:
- kind: ServiceAccount
  name: nfs-client-provisioner
  namespace: default
roleRef:
  kind: ClusterRole
  name: nfs-client-provisioner-clusterrole
  apiGroup: rbac.authorization.k8s.io

 


kubectl apply -f nfs-client-rbac.yaml</code></pre> 
<p><img alt="" height="413" src="https://images2.imgbox.com/af/cb/wVSQkK0l_o.png" width="1200"></p> 
<p><img alt="" height="323" src="https://images2.imgbox.com/19/12/STUkOiYF_o.png" width="1200"></p> 
<p> <img alt="" height="1196" src="https://images2.imgbox.com/4d/a0/s0d3n56E_o.png" width="1200"></p> 
<p><img alt="" height="583" src="https://images2.imgbox.com/62/d4/hZnefvgj_o.png" width="1200"> </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d1/b2/FKOthqde_o.png" width="1200"> </p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/9e/77/9SFbKjxm_o.png" width="1200"></p> 
<p> </p> 
<h3 id="%C2%A03%E3%80%81%E4%BD%BF%E7%94%A8%20Deployment%20%E6%9D%A5%E5%88%9B%E5%BB%BA%20NFS%20Provisioner"> 3、使用 Deployment 来创建 NFS Provisioner</h3> 
<p>NFS Provisioner(即 nfs-client)，有两个功能：一个是在 NFS 共享目录下创建挂载点(volume)，另一个则是将 PV 与 NFS 的挂载点建立关联。</p> 
<pre><code class="hljs"> 

#由于 1.20 版本启用了 selfLink，所以 k8s 1.20+ 版本通过 nfs provisioner 动态生成pv会报错，解决方法如下：
vim /etc/kubernetes/manifests/kube-apiserver.yaml
spec:
  containers:
  - command:
    - kube-apiserver
    - --feature-gates=RemoveSelfLink=false       #添加这一行
    - --advertise-address=192.168.80.20
......

kubectl apply -f /etc/kubernetes/manifests/kube-apiserver.yaml
kubectl delete pods kube-apiserver -n kube-system 
kubectl get pods -n kube-system | grep apiserver

#创建 NFS Provisioner
vim nfs-client-provisioner.yaml
kind: Deployment
apiVersion: apps/v1
metadata:
  name: nfs-client-provisioner
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nfs-client-provisioner
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: nfs-client-provisioner
    spec:
      serviceAccountName: nfs-client-provisioner         #指定Service Account账户
      containers:
        - name: nfs-client-provisioner
          image: quay.io/external_storage/nfs-client-provisioner:latest
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - name: nfs-client-root
              mountPath: /persistentvolumes
          env:
            - name: PROVISIONER_NAME
              value: nfs-storage       #配置provisioner的Name，确保该名称与StorageClass资源中的provisioner名称保持一致
            - name: NFS_SERVER
              value: stor01           #配置绑定的nfs服务器
            - name: NFS_PATH
              value: /opt/k8s          #配置绑定的nfs服务器目录
      volumes:              #申明nfs数据卷
        - name: nfs-client-root
          nfs:
            server: stor01
            path: /opt/k8s
    
    
kubectl apply -f nfs-client-provisioner.yaml 

 

kubectl get pod
NAME                                   READY   STATUS    RESTARTS   AGE
nfs-client-provisioner-cd6ff67-sp8qd   1/1     Running   0          14s</code></pre> 
<p><img alt="" height="506" src="https://images2.imgbox.com/01/ad/MtJHyvPv_o.png" width="1200"></p> 
<p><img alt="" height="925" src="https://images2.imgbox.com/5c/0c/ywBiiIKO_o.png" width="1200"></p> 
<p> <img alt="" height="406" src="https://images2.imgbox.com/09/20/VVXKGll6_o.png" width="1016"></p> 
<h3 id="%C2%A04%E3%80%81%E5%88%9B%E5%BB%BA%20StorageClass"> 4、创建 StorageClass</h3> 
<p>负责建立 PVC 并调用 NFS provisioner 进行预定的工作，并让 PV 与 PVC 建立关联</p> 
<pre><code class="hljs">vim nfs-client-storageclass.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: nfs-client-storageclass
provisioner: nfs-storage     #这里的名称要和provisioner配置文件中的环境变量PROVISIONER_NAME保持一致
parameters:
  archiveOnDelete: "false"   #false表示在删除PVC时不会对数据目录进行打包存档，即删除数据；为ture时就会自动对数据目录进行打包存档，存档文件以archived开头
  
  
kubectl apply -f nfs-client-storageclass.yaml

kubectl get storageclass
NAME                      PROVISIONER   RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
nfs-client-storageclass   nfs-storage   Delete          Immediate           false                  43s</code></pre> 
<p><img alt="" height="184" src="https://images2.imgbox.com/9f/fa/Kr2sYtjO_o.png" width="1200"></p> 
<p><img alt="" height="269" src="https://images2.imgbox.com/46/99/vSVGXXAp_o.png" width="992"></p> 
<h3 id="%C2%A05%E3%80%81%E5%88%9B%E5%BB%BA%20PVC%20%E5%92%8C%20Pod%20%E6%B5%8B%E8%AF%95"> 5、创建 PVC 和 Pod 测试</h3> 
<pre><code class="hljs">vim test-pvc-pod.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test-nfs-pvc
  #annotations: volume.beta.kubernetes.io/storage-class: "nfs-client-storageclass"     #另一种SC配置方式
spec:
  accessModes:
    - ReadWriteMany
  storageClassName: nfs-client-storageclass    #关联StorageClass对象
  resources:
    requests:
      storage: 1Gi
---
apiVersion: v1
kind: Pod
metadata:
  name: test-storageclass-pod
spec:
  containers:
  - name: busybox
    image: busybox:latest
    imagePullPolicy: IfNotPresent
    command:
    - "/bin/sh"
    - "-c"
    args:
    - "sleep 3600"
    volumeMounts:
    - name: nfs-pvc
      mountPath: /mnt
  restartPolicy: Never
  volumes:
  - name: nfs-pvc
    persistentVolumeClaim:
      claimName: test-nfs-pvc      #与PVC名称保持一致
      
      
kubectl apply -f test-pvc-pod.yaml

//PVC 通过 StorageClass 自动申请到空间
kubectl get pvc
NAME            STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS              AGE
test-nfs-pvc   Bound    pvc-11670f39-782d-41b8-a842-eabe1859a456   1Gi        RWX            nfs-client-storageclass   2s

//查看 NFS 服务器上是否生成对应的目录，自动创建的 PV 会以 ${namespace}-${pvcName}-${pvName} 的目录格式放到 NFS 服务器上
ls /opt/k8s/
default-test-nfs-pvc-pvc-11670f39-782d-41b8-a842-eabe1859a456

//进入 Pod 在挂载目录 /mnt 下写一个文件，然后查看 NFS 服务器上是否存在该文件
kubectl exec -it test-storageclass-pod sh
/ # cd /mnt/
/mnt # echo 'this is test file' &gt; test.txt

//发现 NFS 服务器上存在，说明验证成功
cat /opt/k8s/test.txt</code></pre> 
<p><img alt="" height="737" src="https://images2.imgbox.com/fc/59/HtxcoVlw_o.png" width="937"></p> 
<p><img alt="" height="1081" src="https://images2.imgbox.com/d1/56/qauopqU8_o.png" width="1200"></p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/76/6a/xtXsNMvB_o.png" width="1200"></p> 
<pre><code class="hljs">cp pvc.yaml pvc1.yaml
vim pvc1.yaml

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mypvc02-nfs
spec:
  accessModes:
    - ReadOnlyMany
  resources:
    requests:
      storage: 2Gi
  storageClassName: nfs-client-storageclass
</code></pre> 
<p><img alt="" height="466" src="https://images2.imgbox.com/14/ba/lEI6173w_o.png" width="1200"></p> 
<p><img alt="" height="732" src="https://images2.imgbox.com/b3/7b/Mx0qPDpM_o.png" width="1200"> <img alt="" height="394" src="https://images2.imgbox.com/f7/a0/4cYBJIS2_o.png" width="1200"></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b45df661a4155dc80b881584a7cd0bfc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux 查询文件创建时间</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/25b5025f863fddb8d9bb9a9199800d24/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">write javaBean error, fastjson version 1.2.76</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>