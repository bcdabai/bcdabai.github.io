<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker run 命令详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker run 命令详解" />
<meta property="og:description" content="一、前言 Docker容器是一个开源的应用容器引擎，让开发者可以以统一的方式打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何安装了Docker引擎的服务器上（包括流行的Linux机器、Windows机器），也可以实现虚拟化。以下是Docker容器的特点：
沙箱机制：容器是完全使用沙箱机制，相互之间不会有任何接口（类似iPhone的app）。性能开销小：几乎没有性能开销，可以很容易地在机器和数据中心中运行。语言、框架、系统无关：最重要的是，容器不依赖于任何语言、框架包括系统。所以，需要通过设计和部署把这些服务拆分成为它们自己的容器。扩展性：如果一个应用程序能够被拆分成为越多的分布式组件，那么应用程序扩展的选择则越多。配置管理：企业用户可以把这些配置部署在容器中或使用环境变量。为了积极主动地关注基于容器的应用程序的运行状况，可考虑实施必要的监控和管理机制，确保打开日志记录功能。命令行工具和API：Docker提供了一个命令行工具Docker以及一整套RESTful API。架构：Docker采用C/S架构，Docker daemon作为服务端接受来自客户的请求，并处理这些请求（创建、运行、分发容器）。客户端和服务端既可以运行在一个机器上，也可通过socket或者RESTful API来进行通信 二、nginx docker run 命令详解 docker run -d \ --name nginx \ --net=host \ -v /home/docker/apps/nginx/www:/usr/share/nginx/html \ -v /home/docker/apps/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \ -v /home/docker/apps/nginx/logs:/var/log/nginx \ -v /home/docker/apps/nginx/conf.d:/etc/nginx/conf.d \ -v /home/docker/apps/nginx/cert:/etc/nginx/cert \ nginx -d: 在后台以守护进程模式运行容器。
--name nginx: 为容器指定一个名称，可以进行自定义名称。
-v /home/docker/apps/nginx/www:/usr/share/nginx/html \: 将主机上的 NGINX 配置文件目录挂载到容器中的usr/share/nginx/html目录，以便使用自定义的 NGINX 配置。
所以在nginx location中只需要指向容器的路径，实际访问的就是主机的路径，他们是个映射关系，或者说是个代理关系
如：配合的是 /usr/share/nginx/html/member-plat 实际主机上 /home/docker/apps/nginx/wwwmember-plat #静态资源 location /icon/ { root /usr/share/nginx/html/member-plat; try_files $uri $uri/ /index.html; } docker run --name eureka_docker -d -p 8861:8861 eureka_host" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/431f5e31e02f213d264db913fb15da9b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T11:31:23+08:00" />
<meta property="article:modified_time" content="2024-01-08T11:31:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker run 命令详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、前言</h4> 
<p><img alt="" height="393" src="https://images2.imgbox.com/34/29/cTp9r1sc_o.png" width="962"></p> 
<p>Docker容器是一个开源的应用容器引擎，让开发者可以以统一的方式打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何安装了Docker引擎的服务器上（包括流行的Linux机器、Windows机器），也可以实现虚拟化。以下是Docker容器的特点：</p> 
<ol><li>沙箱机制：容器是完全使用沙箱机制，相互之间不会有任何接口（类似iPhone的app）。</li><li>性能开销小：几乎没有性能开销，可以很容易地在机器和数据中心中运行。</li><li>语言、框架、系统无关：最重要的是，容器不依赖于任何语言、框架包括系统。所以，需要通过设计和部署把这些服务拆分成为它们自己的容器。</li><li>扩展性：如果一个应用程序能够被拆分成为越多的分布式组件，那么应用程序扩展的选择则越多。</li><li>配置管理：企业用户可以把这些配置部署在容器中或使用环境变量。为了积极主动地关注基于容器的应用程序的运行状况，可考虑实施必要的监控和管理机制，确保打开日志记录功能。</li><li>命令行工具和API：Docker提供了一个命令行工具Docker以及一整套RESTful API。</li><li>架构：Docker采用C/S架构，Docker daemon作为服务端接受来自客户的请求，并处理这些请求（创建、运行、分发容器）。客户端和服务端既可以运行在一个机器上，也可通过socket或者RESTful API来进行通信</li></ol> 
<h4>二、nginx docker run 命令详解</h4> 
<pre><code class="language-bash">docker run -d \
  --name nginx \
  --net=host \
  -v /home/docker/apps/nginx/www:/usr/share/nginx/html \
  -v /home/docker/apps/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \
  -v /home/docker/apps/nginx/logs:/var/log/nginx \
  -v /home/docker/apps/nginx/conf.d:/etc/nginx/conf.d \
  -v /home/docker/apps/nginx/cert:/etc/nginx/cert \
  nginx</code></pre> 
<p></p> 
<p>-d: 在后台以守护进程模式运行容器。<br> --name nginx: 为容器指定一个名称，可以进行自定义名称。<br>  <br>  -v /home/docker/apps/nginx/www:/usr/share/nginx/html \: 将主机上的 NGINX 配置文件目录挂载到容器中的usr/share/nginx/html目录，以便使用自定义的 NGINX 配置。</p> 
<p>所以在nginx  location中只需要指向容器的路径，实际访问的就是主机的路径，他们是个映射关系，或者说是个代理关系</p> 
<p>如：配合的是  /usr/share/nginx/html/member-plat  实际主机上 /home/docker/apps/nginx/wwwmember-plat </p> 
<pre><code class="language-bash">   #静态资源
   location /icon/ {
                root /usr/share/nginx/html/member-plat;
                try_files $uri $uri/ /index.html;
        }</code></pre> 
<p><br>  docker run --name eureka_docker  -d -p 8861:8861 eureka_host</p> 
<pre><code class="language-bash">
 docker run --name eureka_docker  -d -p 8861:8861 eureka_host</code></pre> 
<p>所以这一段的意思是 运行主机上的 eureka_host  在容器中叫 eureka_docker  主机的  8861 映射 容器的 8861 ，通过主机的8861 实际访问的就是容器的 8861</p> 
<p></p> 
<h4>三、DockerFile的使用</h4> 
<p>Dockerfile是一个用来构建镜像的文本文件，其中包含了一系列的指令和说明，这些指令和说明告诉Docker如何构建镜像。</p> 
<p>Docker通过阅读Dockerfile中的指令代码来构建镜像文件。在Dockerfile中，可以使用多种指令来定义如何构建镜像，例如：</p> 
<ol><li>FROM：指定基础镜像；</li><li>RUN：在容器中执行命令；</li><li>COPY：将文件从主机复制到容器中；</li><li>ENV：设置环境变量；</li><li>EXPOSE：声明容器将监听的端口；</li><li>CMD：定义容器启动时执行的命令。</li></ol> 
<p>要创建一个Dockerfile，需要在项目目录中创建一个名为Dockerfile的文件，并在其中编写指令。编写Dockerfile的指令将按照文件中的顺序逐一执行。使用docker build命令可以构建镜像。</p> 
<pre><code class="language-bash">FROM java:8
VOLUME /tmp
ADD eureka.jar eureka.jar
EXPOSE 8861</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/89b586c72ebdad2aa141dd915491b6f0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Shell脚本入门实战：探索自动化任务与实用场景</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7817a2ac494d1fa6bb6ab92aa8be97b8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">3dmax灯光缓存参数怎么设置？解析来了！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>