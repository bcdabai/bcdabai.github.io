<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>span源码解析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="span源码解析" />
<meta property="og:description" content="CLI命令 vpp 端口镜像注册了两个命令：
设置端口镜像set interface span VLIB_CLI_COMMAND (set_interface_span_command, static) = { .path = &#34;set interface span&#34;, .short_help = &#34;set interface span &lt;if-name&gt; [l2] {disable | destination &lt;if-name&gt; [both|rx|tx]}&#34;, .function = set_interface_span_command_fn, }; 显示端口镜像的设置信息show interface span VLIB_CLI_COMMAND (show_interfaces_span_command, static) = { .path = &#34;show interface span&#34;, .short_help = &#34;Shows SPAN mirror table&#34;, .function = show_interfaces_span_command_fn, }; 源码 设置端口镜像 static clib_error_t * set_interface_span_command_fn (vlib_main_t * vm, unformat_input_t * input, vlib_cli_command_t * cmd) { span_main_t *sm = &amp;span_main; u32 src_sw_if_index = ~0; u32 dst_sw_if_index = ~0; span_feat_t sf = SPAN_FEAT_DEVICE; span_state_t state = SPAN_BOTH; int state_set = 0; //参数解析 while (unformat_check_input (input) !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d572be0953a40e362439913f5ccb21a6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-04T17:03:41+08:00" />
<meta property="article:modified_time" content="2020-06-04T17:03:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">span源码解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="CLI_0"></a>CLI命令</h3> 
<p>vpp 端口镜像注册了两个命令：</p> 
<ol><li>设置端口镜像set interface span</li></ol> 
<pre><code>VLIB_CLI_COMMAND (set_interface_span_command, static) = {
  .path = "set interface span",
  .short_help = "set interface span &lt;if-name&gt; [l2] {disable | destination &lt;if-name&gt; [both|rx|tx]}",
  .function = set_interface_span_command_fn,
};
</code></pre> 
<ol start="2"><li>显示端口镜像的设置信息show interface span</li></ol> 
<pre><code>VLIB_CLI_COMMAND (show_interfaces_span_command, static) = {
  .path = "show interface span",
  .short_help = "Shows SPAN mirror table",
  .function = show_interfaces_span_command_fn,
};
</code></pre> 
<h3><a id="_18"></a>源码</h3> 
<ol><li>设置端口镜像</li></ol> 
<pre><code>static clib_error_t *
set_interface_span_command_fn (vlib_main_t * vm,
			       unformat_input_t * input,
			       vlib_cli_command_t * cmd)
{
  span_main_t *sm = &amp;span_main;
  u32 src_sw_if_index = ~0;
  u32 dst_sw_if_index = ~0;
  span_feat_t sf = SPAN_FEAT_DEVICE;
  span_state_t state = SPAN_BOTH;
  int state_set = 0;
//参数解析
  while (unformat_check_input (input) != UNFORMAT_END_OF_INPUT)
    {
      if (unformat (input, "%U", unformat_vnet_sw_interface,
		    sm-&gt;vnet_main, &amp;src_sw_if_index)) //源接口，直接转换为接口的索引
	;
      else if (unformat (input, "destination %U", unformat_vnet_sw_interface,
			 sm-&gt;vnet_main, &amp;dst_sw_if_index))	//目标接口，直接转换为接口的索引
	;
      else if (unformat (input, "%U", unformat_span_state, &amp;state)) //解析禁用，rx，tx或both，默认为both
	{
	  if (state_set)
	    return clib_error_return (0, "Multiple mirror states in input");
	  state_set = 1;
	}
      else if (unformat (input, "l2"))
	sf = SPAN_FEAT_L2;
      else
	return clib_error_return (0, "Invalid input");
    }

//调用添加或删除镜像函数
  int rv =
    span_add_delete_entry (vm, src_sw_if_index, dst_sw_if_index, state, sf);
  if (rv == VNET_API_ERROR_INVALID_INTERFACE)
    return clib_error_return (0, "Invalid interface");
  return 0;
}
//添加或删除镜像函数
int
span_add_delete_entry (vlib_main_t * vm,
		       u32 src_sw_if_index, u32 dst_sw_if_index, u8 state,
		       span_feat_t sf)
{
  span_main_t *sm = &amp;span_main;
//state校验
  if (state &gt; SPAN_BOTH)
    return VNET_API_ERROR_UNIMPLEMENTED;
    //接口索引校验
  if ((src_sw_if_index == ~0) || (dst_sw_if_index == ~0 &amp;&amp; state &gt; 0)
      || (src_sw_if_index == dst_sw_if_index))
    return VNET_API_ERROR_INVALID_INTERFACE;

  vec_validate_aligned (sm-&gt;interfaces, src_sw_if_index,
			CLIB_CACHE_LINE_BYTES);
//获取被镜像接口
  span_interface_t *si = vec_elt_at_index (sm-&gt;interfaces, src_sw_if_index);
//计算接口使能状态
  int rx = ! !(state &amp; SPAN_RX);
  int tx = ! !(state &amp; SPAN_TX);
//获取镜像接口
  span_mirror_t *rxm = &amp;si-&gt;mirror_rxtx[sf][VLIB_RX];
  span_mirror_t *txm = &amp;si-&gt;mirror_rxtx[sf][VLIB_TX];
//设置镜像接口
  u32 last_rx_ports_count = span_dst_set (rxm, dst_sw_if_index, rx);
  u32 last_tx_ports_count = span_dst_set (txm, dst_sw_if_index, tx);

  int enable_rx = last_rx_ports_count == 0 &amp;&amp; rxm-&gt;num_mirror_ports == 1;
  int disable_rx = last_rx_ports_count &gt; 0 &amp;&amp; rxm-&gt;num_mirror_ports == 0;
  int enable_tx = last_tx_ports_count == 0 &amp;&amp; txm-&gt;num_mirror_ports == 1;
  int disable_tx = last_tx_ports_count &gt; 0 &amp;&amp; txm-&gt;num_mirror_ports == 0;

  switch (sf)
    {
    case SPAN_FEAT_DEVICE:
    //根据设置使能或者禁用span-input或span-output节点
      if (enable_rx || disable_rx)
	vnet_feature_enable_disable ("device-input", "span-input",
				     src_sw_if_index, rx, 0, 0);
      if (enable_tx || disable_tx)
	vnet_feature_enable_disable ("interface-output", "span-output",
				     src_sw_if_index, tx, 0, 0);
      break;
    case SPAN_FEAT_L2:
    //根据设置在给定接口的位图中启用（或禁用）L2INPUT_FEAT_SPAN（或L2OUTPUT_FEAT_SPAN）
      if (enable_rx || disable_rx)
	l2input_intf_bitmap_enable (src_sw_if_index, L2INPUT_FEAT_SPAN, rx);
      if (enable_tx || disable_tx)
	l2output_intf_bitmap_enable (src_sw_if_index, L2OUTPUT_FEAT_SPAN, tx);
      break;
    default:
      return VNET_API_ERROR_UNIMPLEMENTED;
    }

  if (dst_sw_if_index != ~0 &amp;&amp; dst_sw_if_index &gt; sm-&gt;max_sw_if_index)
    sm-&gt;max_sw_if_index = dst_sw_if_index;

  return 0;
}
</code></pre> 
<p>设置镜像端口将镜像信息保存在span_main.interfaces中，并且使能了镜像节点，开始镜像。<br> 镜像节点处理过程源码：</p> 
<pre><code>static_always_inline uword
span_node_inline_fn (vlib_main_t * vm, vlib_node_runtime_t * node,
		     vlib_frame_t * frame, vlib_rx_or_tx_t rxtx,
		     span_feat_t sf)
{
  span_main_t *sm = &amp;span_main;
  vnet_main_t *vnm = vnet_get_main ();
  u32 n_left_from, *from, *to_next;
  u32 next_index;
  u32 sw_if_index;
  static __thread vlib_frame_t **mirror_frames = 0;

//frame起始位置
  from = vlib_frame_vector_args (frame);
  //frame中数据包个数
  n_left_from = frame-&gt;n_vectors;
  //节点之后的处理节点
  next_index = node-&gt;cached_next_index;

  vec_validate_aligned (mirror_frames, sm-&gt;max_sw_if_index,
			CLIB_CACHE_LINE_BYTES);

  while (n_left_from &gt; 0)
    {
      u32 n_left_to_next;

/* vlib_get_next_frame，vlib_put_next_frame几乎每个node中必定出现的一对好基友。 vlib_get_next_frame获取传递给下一个node的数据包将驻留的内存结构。vlib_put_next_frame把传递给下一个node的数据包写入特定位置。
	  这样下一个node将正式可以被调度框架调度，并处理传给他的数据包
	  */
      vlib_get_next_frame (vm, node, next_index, to_next, n_left_to_next);

		/*
        * n_left_from表示vector拿到多少个数据包
        * n_left_to_next表示上次缓存的下一级node剩下的vector位置
        * 所以循环表示的是当前node还能拿到多少个包，
        * 下一级能接收多少包，以少的为准。
        */
      while (n_left_from &gt;= 4 &amp;&amp; n_left_to_next &gt;= 2)
	{
	  u32 bi0;
	  u32 bi1;
	  vlib_buffer_t *b0;
	  vlib_buffer_t *b1;
	  u32 sw_if_index0;
	  u32 next0 = 0;
	  u32 sw_if_index1;
	  u32 next1 = 0;

	  /* speculatively enqueue b0, b1 to the current next frame */
	  to_next[0] = bi0 = from[0];
	  to_next[1] = bi1 = from[1];
	  to_next += 2;
	  n_left_to_next -= 2;
	  from += 2;
	  n_left_from -= 2;
    //获取两个数据包
	  b0 = vlib_get_buffer (vm, bi0);
	  b1 = vlib_get_buffer (vm, bi1);
	  //获取数据包的源端口
	  sw_if_index0 = vnet_buffer (b0)-&gt;sw_if_index[rxtx];
	  sw_if_index1 = vnet_buffer (b1)-&gt;sw_if_index[rxtx];
	
     //镜像当前端口到指定端口
	  span_mirror (vm, node, sw_if_index0, b0, mirror_frames, rxtx, sf);
	  span_mirror (vm, node, sw_if_index1, b1, mirror_frames, rxtx, sf);

	  switch (sf)
	    {
	    case SPAN_FEAT_L2:
	      if (rxtx == VLIB_RX)
		{
		  next0 = vnet_l2_feature_next (b0, sm-&gt;l2_input_next,
						L2INPUT_FEAT_SPAN);
		  next1 = vnet_l2_feature_next (b1, sm-&gt;l2_input_next,
						L2INPUT_FEAT_SPAN);
		}
	      else
		{
		  next0 = vnet_l2_feature_next (b0, sm-&gt;l2_output_next,
						L2OUTPUT_FEAT_SPAN);
		  next1 = vnet_l2_feature_next (b1, sm-&gt;l2_output_next,
						L2OUTPUT_FEAT_SPAN);
		}
	      break;
	    case SPAN_FEAT_DEVICE:
	    default:
	      vnet_feature_next (&amp;next0, b0);
	      vnet_feature_next (&amp;next1, b1);
	      break;
	    }

		/* 验证处理结果，当next0 == next_index时，说明该包被正确处理，该宏将do nothing
	     否则，说明本来该包应去next_index但是发生错误，使得next0 != next_index。该宏会将该错误包索引bi0发往到next0实际的下一个结点(next_index) */
	  /* verify speculative enqueue, maybe switch current next frame */
	  vlib_validate_buffer_enqueue_x2 (vm, node, next_index,
					   to_next, n_left_to_next,
					   bi0, bi1, next0, next1);
	}
	//单个包处理
      while (n_left_from &gt; 0 &amp;&amp; n_left_to_next &gt; 0)
	{
	  u32 bi0;
	  vlib_buffer_t *b0;
	  u32 sw_if_index0;
	  u32 next0 = 0;

	  /* speculatively enqueue b0 to the current next frame */
	  to_next[0] = bi0 = from[0];
	  to_next += 1;
	  n_left_to_next -= 1;
	  from += 1;
	  n_left_from -= 1;

	  b0 = vlib_get_buffer (vm, bi0);
	  sw_if_index0 = vnet_buffer (b0)-&gt;sw_if_index[rxtx];

	  span_mirror (vm, node, sw_if_index0, b0, mirror_frames, rxtx, sf);

	  switch (sf)
	    {
	    case SPAN_FEAT_L2:
	      if (rxtx == VLIB_RX)
		next0 = vnet_l2_feature_next (b0, sm-&gt;l2_input_next,
					      L2INPUT_FEAT_SPAN);
	      else
		next0 = vnet_l2_feature_next (b0, sm-&gt;l2_output_next,
					      L2OUTPUT_FEAT_SPAN);
	      break;
	    case SPAN_FEAT_DEVICE:
	    default:
	      vnet_feature_next (&amp;next0, b0);
	      break;
	    }

	  /* verify speculative enqueue, maybe switch current next frame */
	  vlib_validate_buffer_enqueue_x1 (vm, node, next_index, to_next,
					   n_left_to_next, bi0, next0);
	}
     /* 所有流程都正确处理完毕后，下一结点的frame上已经有本结点处理过后的数据索引
         执行该函数，将相关信息登记到vlib_pending_frame_t中，准备开始调度处理 
	  */
      vlib_put_next_frame (vm, node, next_index, n_left_to_next);
    }


  for (sw_if_index = 0; sw_if_index &lt; vec_len (mirror_frames); sw_if_index++)
    {
      vlib_frame_t *f = mirror_frames[sw_if_index];
      if (f == 0)
	continue;

      if (sf == SPAN_FEAT_L2)
	vlib_put_frame_to_node (vm, l2output_node.index, f);
      else
	vnet_put_frame_to_sw_interface (vnm, sw_if_index, f);
      mirror_frames[sw_if_index] = 0;
    }
/* 返回frame中数据包个数 */
  return frame-&gt;n_vectors;
}
//端口镜像
static_always_inline void
span_mirror (vlib_main_t * vm, vlib_node_runtime_t * node, u32 sw_if_index0,
	     vlib_buffer_t * b0, vlib_frame_t ** mirror_frames,
	     vlib_rx_or_tx_t rxtx, span_feat_t sf)
{
  vlib_buffer_t *c0;
  span_main_t *sm = &amp;span_main;
  vnet_main_t *vnm = vnet_get_main ();
  u32 *to_mirror_next = 0;
  u32 i;
  span_interface_t *si0;
  span_mirror_t *sm0;

  if (sw_if_index0 &gt;= vec_len (sm-&gt;interfaces))
    return;
  //从源接口队列中取出当前端口
  si0 = vec_elt_at_index (sm-&gt;interfaces, sw_if_index0);
  //获取源接口的镜像信息
  sm0 = &amp;si0-&gt;mirror_rxtx[sf][rxtx];
  //判断目的镜像队列是否为空
  if (sm0-&gt;num_mirror_ports == 0)
    return;

  /* Don't do it again */
  if (PREDICT_FALSE (b0-&gt;flags &amp; VNET_BUFFER_F_SPAN_CLONE))
    return;
//遍历目的接口，镜像数据包
  /* *INDENT-OFF* */
  clib_bitmap_foreach (i, sm0-&gt;mirror_ports, (
    {
    //获取目的接口的frame
      if (mirror_frames[i] == 0)
        {
          if (sf == SPAN_FEAT_L2)
            mirror_frames[i] = vlib_get_frame_to_node (vm, l2output_node.index);
          else
            mirror_frames[i] = vnet_get_frame_to_sw_interface (vnm, i);
	   }
	   //指针指向frame队列
      to_mirror_next = vlib_frame_vector_args (mirror_frames[i]);
      //指针指向frame队列结尾
      to_mirror_next += mirror_frames[i]-&gt;n_vectors;
      /* This can fail */
      c0 = vlib_buffer_copy (vm, b0);
      if (PREDICT_TRUE(c0 != 0))
        {
          vnet_buffer (c0)-&gt;sw_if_index[VLIB_TX] = i;
          c0-&gt;flags |= VNET_BUFFER_F_SPAN_CLONE;
          if (sf == SPAN_FEAT_L2)
	    vnet_buffer (c0)-&gt;l2.feature_bitmap = L2OUTPUT_FEAT_OUTPUT;
	    //将被拷贝frame的index赋值给目的接口的frame队列的结尾
          to_mirror_next[0] = vlib_get_buffer_index (vm, c0);
          //增加队列长度计数
          mirror_frames[i]-&gt;n_vectors++;
          if (PREDICT_FALSE (b0-&gt;flags &amp; VLIB_BUFFER_IS_TRACED))
            {
              span_trace_t *t = vlib_add_trace (vm, node, b0, sizeof (*t));
              t-&gt;src_sw_if_index = sw_if_index0;
              t-&gt;mirror_sw_if_index = i;
#if 0
	      /* Enable this path to allow packet trace of SPAN packets.
	         Note that all SPAN packets will show up on the trace output
	         with the first SPAN packet (since they are in the same frame)
	         thus making trace output of the original packet confusing */
	      mirror_frames[i]-&gt;flags |= VLIB_FRAME_TRACE;
	      c0-&gt;flags |= VLIB_BUFFER_IS_TRACED;
#endif
	        }
	    }
    }));
  /* *INDENT-ON* */
}
</code></pre> 
<ol start="2"><li>显示端口镜像的设置信息show interface span<br> show interface span比较简单，遍历一下span_main.interfaces，打印相关信息</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/14d5e4a2b2fbbc0f91214fcb6f60acb6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue-cli中自定义播放器样式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/62f19ca5eeb2e31819e64be2af67eaf3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决Mac安装MySQL后Navicat连接出现2003和2000异常</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>