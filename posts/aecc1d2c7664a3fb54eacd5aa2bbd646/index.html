<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>九大排序算法原理图解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="九大排序算法原理图解" />
<meta property="og:description" content="九大排序算法图解 0、稳定性和复杂度1、直接插入排序（插入类）2、折半插入排序（插入类）3、冒泡排序（交换类）4、简单选择排序（选择类）5、希尔排序(插入类)6、快速排序（交换类）7、堆排序（选择类）8、2路归并排序9、基数排序 0、稳定性和复杂度 开始之前，先简单介绍一下排序算法的几个重要指标,这里，我尽量用自己理解的傻瓜式方法解读：
（1）稳定性：当序列中存在两个或两个以上的关键字相等的时候，如果排序前序列中r1领先于r2,那么排序后r1如果仍旧领先r2的话，则是稳定的。（相等的元素排序后相对位置不变）
（2）不稳定性：当序列中存在两个或两个以上的关键字相等的时候，如果排序前序列中r1领先于r2,那么排序后r1如果落后r2的话，则是不稳定的。（相等的元素排序后相对位置发生改变）
（3）时间复杂度：算法的时间开销是衡量其好坏的最重要的标志。高效率的算法应该具有更少的比较次数和记录移动次数。
（4）空间复杂度：即执行算法所需要的辅助存储的空间。
排序算法小结表
1、直接插入排序（插入类） 流程描述：遍历序列中的关键字，每次取一个待排序的关键字，从待排序关键字的前一个关键字逐次向前扫描，如果扫描到的关键字大于待排序关键字，则把扫描到的关键字往后移一个位置。最后找到插入位置，将待排序关键字插入。
void InsertSort(int R[],int n)
{
int i,j
int temp;
for(i=1;i&lt;n;&#43;&#43;i)
{
temp=R[i]; //将待排关键字暂时存放在temp中
j=i-1; //待排关键字的前一个关键字序号
while(j&gt;=0&amp;&amp;temp&lt;R[j])
//从待排关键字的前一个关键字开始扫描，如果大于待排关键字，则往后移一个位置
{
R[j&#43;1]=R[j];
–j;
}
R[j&#43;1]=temp; //找到插入位置，将temp中暂存的待排关键字插入
}
}
最坏情况：整个序列是逆序的时候，则内层循环的条件temp&lt;R[j]始终成立，此时对于每一次外层循环，内层循环次数每次达到最大值（即内层循环位i次），外层循环i取值为1~i-1,所以总的执行次数为n(n-1)/2 。
最好情况：整个序列为正序的时候。内层循环条件始终不成立，所以内层循环始终不执行，始终执行语句R[j&#43;1]=temp。所以时间复杂度为O(n)。
空间复杂度：算法所需的辅助存储空间不随待排序列的规模变化而变化，是个常量，所以为O(1)。
2、折半插入排序（插入类） 过程描述：过程同直接插入排序，只是不同于直接插入排序时用顺序查找，这里用的是折半查找。所以折半插入排序在查找过程上比直接插入排序节约不少时间。但是关键字移动次数和直接插入排序一样。
3、冒泡排序（交换类） 过程描述：通过一系列的交换动作实现排序。首先第一个关键字和第二个关键字比较，如果第一个关键字大，二者交换；然后第二个关键字和第三个关键字比较，如果第二个关键字大，二者交换，否则不交换。一直进行下去，知道最终最大的哪个关键字被交换到了最后，一趟冒泡排序完成。
void BubbleSort(int R[],int n)
{
int i,j,flag;
int temp;
for(i=n-1;i&gt;=1;–i)
{
flag=0; //flag用来标记本趟排序是否发生了交换
for(j=1;j&lt;=i;&#43;&#43;j)
{
if(R[j-1]&gt;R[j])
{
temp=R[j];
R[j-1]=R[j];
R[j]=temp;
flag=1; //flag=1表示本次排序发生了交换
}
if(flag==0)//如果没有发生交换，说明序列有序，排序结束
return;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/aecc1d2c7664a3fb54eacd5aa2bbd646/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T10:07:56+08:00" />
<meta property="article:modified_time" content="2024-01-09T10:07:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">九大排序算法原理图解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>九大排序算法图解</h4> 
 <ul><li><a href="#0_1" rel="nofollow">0、稳定性和复杂度</a></li><li><a href="#1_15" rel="nofollow">1、直接插入排序（插入类）</a></li><li><a href="#2_44" rel="nofollow">2、折半插入排序（插入类）</a></li><li><a href="#3_48" rel="nofollow">3、冒泡排序（交换类）</a></li><li><a href="#4_79" rel="nofollow">4、简单选择排序（选择类）</a></li><li><a href="#5_101" rel="nofollow">5、希尔排序(插入类)</a></li><li><a href="#6_128" rel="nofollow">6、快速排序（交换类）</a></li><li><a href="#7_168" rel="nofollow">7、堆排序（选择类）</a></li><li><a href="#82_184" rel="nofollow">8、2路归并排序</a></li><li><a href="#9_197" rel="nofollow">9、基数排序</a></li></ul> 
</div> 
<p></p> 
<h2><a id="0_1"></a>0、稳定性和复杂度</h2> 
<p>开始之前，先简单介绍一下排序算法的几个重要指标,这里，我尽量用自己理解的傻瓜式方法解读：</p> 
<p>（1）稳定性：当序列中存在两个或两个以上的关键字相等的时候，如果排序前序列中r1领先于r2,那么排序后r1如果仍旧领先r2的话，则是稳定的。（相等的元素排序后相对位置不变）</p> 
<p>（2）不稳定性：当序列中存在两个或两个以上的关键字相等的时候，如果排序前序列中r1领先于r2,那么排序后r1如果落后r2的话，则是不稳定的。（相等的元素排序后相对位置发生改变）</p> 
<p>（3）时间复杂度：算法的时间开销是衡量其好坏的最重要的标志。高效率的算法应该具有更少的比较次数和记录移动次数。</p> 
<p>（4）空间复杂度：即执行算法所需要的辅助存储的空间。</p> 
<p>排序算法小结表<br> <img src="https://images2.imgbox.com/ea/84/0AKafTzY_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="1_15"></a>1、直接插入排序（插入类）</h2> 
<p>流程描述：遍历序列中的关键字，每次取一个待排序的关键字，从待排序关键字的前一个关键字逐次向前扫描，如果扫描到的关键字大于待排序关键字，则把扫描到的关键字往后移一个位置。最后找到插入位置，将待排序关键字插入。</p> 
<p>void InsertSort(int R[],int n)<br> {<!-- --><br> int i,j<br> int temp;<br> for(i=1;i&lt;n;++i)<br> {<!-- --><br> temp=R[i]; //将待排关键字暂时存放在temp中<br> j=i-1; //待排关键字的前一个关键字序号<br> while(j&gt;=0&amp;&amp;temp&lt;R[j])<br> //从待排关键字的前一个关键字开始扫描，如果大于待排关键字，则往后移一个位置<br> {<!-- --><br> R[j+1]=R[j];<br> –j;<br> }<br> R[j+1]=temp; //找到插入位置，将temp中暂存的待排关键字插入<br> }<br> }</p> 
<p>最坏情况：整个序列是逆序的时候，则内层循环的条件temp&lt;R[j]始终成立，此时对于每一次外层循环，内层循环次数每次达到最大值（即内层循环位i次），外层循环i取值为1~i-1,所以总的执行次数为n(n-1)/2 。</p> 
<p>最好情况：整个序列为正序的时候。内层循环条件始终不成立，所以内层循环始终不执行，始终执行语句R[j+1]=temp。所以时间复杂度为O(n)。</p> 
<p>空间复杂度：算法所需的辅助存储空间不随待排序列的规模变化而变化，是个常量，所以为O(1)。<br> <img src="https://images2.imgbox.com/72/2b/onXPEvSB_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2_44"></a>2、折半插入排序（插入类）</h2> 
<p>过程描述：过程同直接插入排序，只是不同于直接插入排序时用顺序查找，这里用的是折半查找。所以折半插入排序在查找过程上比直接插入排序节约不少时间。但是关键字移动次数和直接插入排序一样。</p> 
<h2><a id="3_48"></a>3、冒泡排序（交换类）</h2> 
<p>过程描述：通过一系列的交换动作实现排序。首先第一个关键字和第二个关键字比较，如果第一个关键字大，二者交换；然后第二个关键字和第三个关键字比较，如果第二个关键字大，二者交换，否则不交换。一直进行下去，知道最终最大的哪个关键字被交换到了最后，一趟冒泡排序完成。</p> 
<p>void BubbleSort(int R[],int n)<br> {<!-- --><br> int i,j,flag;<br> int temp;<br> for(i=n-1;i&gt;=1;–i)<br> {<!-- --><br> flag=0; //flag用来标记本趟排序是否发生了交换<br> for(j=1;j&lt;=i;++j)<br> {<!-- --><br> if(R[j-1]&gt;R[j])<br> {<!-- --><br> temp=R[j];<br> R[j-1]=R[j];<br> R[j]=temp;<br> flag=1; //flag=1表示本次排序发生了交换<br> }<br> if(flag==0)//如果没有发生交换，说明序列有序，排序结束<br> return;<br> }<br> }</p> 
<p>最坏情况：序列逆序，此时内层循环if语句的条件始终成立，基本操作执行的次数为n-i。i取值为1~n-1,所以总的执行次数为(n-1+1)(n-1)/2=n(n-1)/2,所以时间复杂度为O(n^2)。</p> 
<p>最好情况：序列正序。此时内层循环的条件比较语句始终不成立，不发生交换，内层循环执行n-1次，所以时间复杂度为O（n）。</p> 
<p>平均情况：时间复杂度O(n^2)。<br> <img src="https://images2.imgbox.com/8f/7b/oK8lf06C_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4_79"></a>4、简单选择排序（选择类）</h2> 
<p>选择排序就是不断地从未排序的元素中选择最大（或者最小）的元素放入已经排好序的元素集合中，直到未排序中仅剩一个元素为止<br> void SelectSort(int R[],int n)<br> {<!-- --><br> int i,j,k;<br> int temp;<br> for(i=0;i&lt;n;++i)<br> {<!-- --><br> k=i;<br> for(j=i+1;j&lt;n;++j) //从i后面的序列中挑选一个最小的关键字<br> {<!-- --><br> if(R[k]&gt;R[j])<br> k=j; //<br> temp=R[i];<br> R[i]=R[k];<br> R[k]=temp;<br> }<br> }<br> }</p> 
<h2><a id="5_101"></a>5、希尔排序(插入类)</h2> 
<p>首先它把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高<br> <img src="https://images2.imgbox.com/0d/92/8CGFXSdm_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/72/93/T92l9upb_o.png" alt="在这里插入图片描述"><br> 可以看出，他是按下标相隔距离为4分的组，也就是说把下标相差4的分到一组，比如这个例子中a[0]与a[4]是一组、a[1]与a[5]是一组…，这里的差值（距离）被称为增量<br> <img src="https://images2.imgbox.com/dd/a8/u1YewFWo_o.png" alt="在这里插入图片描述"><br> 每个分组进行插入排序后，各个分组就变成了有序的了（整体不一定有序）<br> <img src="https://images2.imgbox.com/55/15/yQigGUSz_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101811251333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIxMzE3Ng==,size_16,color_FFFFFF,t_70"></p> 
<p>此时，整个数组变的部分有序了（有序程度可能不是很高）<br> <img src="https://images2.imgbox.com/a4/f9/h33SQgT9_o.png" alt="在这里插入图片描述"></p> 
<p>然后缩小增量为上个增量的一半:2，继续划分分组，此时，每个分组元素个数多了，但是，数组变的部分有序了，插入排序效率同样比高<br> <img src="https://images2.imgbox.com/b6/90/VVx3187I_o.png" alt="在这里插入图片描述"></p> 
<p>同理对每个分组进行排序（插入排序），使其每个分组各自有序</p> 
<p><img src="https://images2.imgbox.com/69/4b/VDamHHyw_o.png" alt="图解算法---希尔排序"></p> 
<p>最后设置增量为上一个增量的一半：1，则整个数组被分为一组，此时，整个数组已经接近有序了，插入排序效率高</p> 
<p><img src="https://images2.imgbox.com/22/d1/x0ocLpmu_o.png" alt="图解算法---希尔排序"></p> 
<p>同理，对这仅有的一组数据进行排序，排序完成</p> 
<h2><a id="6_128"></a>6、快速排序（交换类）</h2> 
<p>过程描述：每一趟选择当前子序列中的一个关键字作为枢轴（一般选择第一个关键字作为枢轴），将子序列中比枢轴小的移到枢轴前面，比枢轴大的移到枢轴后面，本趟交换完成后得到新的更短的子序列，成为下一趟交换的初始序列。一趟排序之后可以确定枢轴的最终位置。比枢轴小的全部在枢轴左边，比枢轴大的全部在枢轴右边。</p> 
<p>void QuickSort(int R[],int high,int low)<br> {<!-- --><br> int temp;<br> int i=low,j=high;<br> if(low&lt;high)<br> {<!-- --><br> temp=R[low];<br> while(i!=j)<br> {<!-- --><br> while(j&gt;i&amp;&amp;R[j]&gt;=temp) --j; //从右往左扫描，找到一个小于枢轴temp的关键字<br> if(i&lt;j)<br> {<!-- --><br> R[i]=R[j]; //将右边小于枢轴temp的关键字放在temp的左边<br> ++i; //左边序列号向右移一位<br> }<br> while(i&lt;j&amp;&amp;R[i]&lt;temp) ++i;//从左向右扫描，找到一个大于枢轴关键字temp的关键字<br> if(i&lt;j)<br> {<!-- --><br> R[j]=R[i];//将左边大于枢轴temp的关键字放在temp的右边<br> –j; //右边序号向左移动一位<br> }<br> }<br> R[i]=temp;<br> QuickSort(R,low,i-1);<br> QuickSort(R,i+1,high);<br> }<br> }</p> 
<p>最好情况：时间复杂度为[公式] ,待排序列越接近无序，本算法效率越高。</p> 
<p>最坏情况：时间复杂度为 [公式] ,待排序列越接近有序，本算法效率越低。</p> 
<p>平均情况：时间复杂度 [公式] 。</p> 
<p>空间复杂度：从头到尾只用了temp这一个辅助存储，所以为O(1)。<br> <img src="https://images2.imgbox.com/30/d0/uSUHnkXs_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="7_168"></a>7、堆排序（选择类）</h2> 
<p>把堆看成完全二叉树，大根堆—父亲大孩子小；小根堆—父亲小孩子大。</p> 
<p>过程描述：整个排序的过程就是不断地将序列调整为堆。</p> 
<p>以原始序列：49 38 65 97 76 13 27 49为例，调整为大根堆。</p> 
<p>（1）调整97，97&gt;49，不需要调整</p> 
<p>（2）调整65,65&gt;13,65&gt;27，不需要调整<br> <img src="https://images2.imgbox.com/03/d0/bXZmwMEV_o.png" alt="在这里插入图片描述"><br> (3)调整38，38&lt;97,38&lt;76。需要调整，38和97交换，交换后38成为49的根节点，，继续将38和49交换。<br> <img src="https://images2.imgbox.com/8d/0b/2ccblHFe_o.png" alt="在这里插入图片描述"><br> （4）调整49，49&lt;97,49&lt;65,所以49和较大者97交换，交换后，49&lt;76，仍然不满足大根堆，将49与76交换。<br> <img src="https://images2.imgbox.com/ea/d9/PYg6IAxc_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="82_184"></a>8、2路归并排序</h2> 
<p>void mergeSort(int A[],int low,int high)<br> {<!-- --><br> if(low&lt;high)<br> {<!-- --><br> int mid=(low+high)/2;<br> mergeSort(A,low,mid); //归并排序前半段<br> mergeSort(A,mid+1,high);//归并排序后半段<br> merge(A,low,mid,high); //把数组中的low到mid 和 mid+1到high的两段有序序列归并成一段有序序列<br> }<br> }<br> <img src="https://images2.imgbox.com/fa/b8/CxRFG9v8_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="9_197"></a>9、基数排序</h2> 
<p>“多关键字排序”，（1）最高位优先（2）最低位优先。例如最高位优先：先按最高位排成若干子序列，再对每个子序列按次高位进行排序。</p> 
<p>如下图，低位优先的排序过程：每个桶相当于一个队列，先进先出规则。<br> <img src="https://images2.imgbox.com/8b/fc/mEfzz4Zg_o.png" alt="在这里插入图片描述"><br> 最后得到的结果：最高为有序，最高位相同的关键字次高位有序，次高位相同的关键字最低位有序，所以整个序列有序。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cff59e848feef62643fb731a54fe7c12/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTB | Codify vm2@3.9.16 中的沙箱逃逸</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6594cf29a7adf7ac43bb6333c3509e30/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">test fuzz-04-模糊测试 jazzer Coverage-guided, in-process fuzzing for the JVM</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>