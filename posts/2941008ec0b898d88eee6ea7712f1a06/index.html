<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Tomcat与网络1】史前时代—没有Spring该如何写Web服务 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Tomcat与网络1】史前时代—没有Spring该如何写Web服务" />
<meta property="og:description" content="在前面我们介绍了网络与Java相关的问题， 最近在调研的时候发现这块内容其实非常复杂，涉及的内容多而且零碎，想短时间梳理出整个体系是不太可能的，所以我们还是继续看Tomcat的问题，后面有网络的内容继续补充吧。
目录
1 搭建一个本地web服务
2 Java web是如何工作的
Servlet是Java Web的核心机制，而实现Servlet最好的服务器无疑就是Tomcat。在前面我们介绍了如何用Java实现网络通信，这个与自己实现一个Servlet服务器，比如Tomcat 还差多少呢？差十万八千里，有一个挺好玩的图：
目前各类Spring的材料实在太多了，我们用的也多。那么Spring到底是什么？又有什么用呢？我们可以找到一堆的标准答案，但是貌似对Spring的理解总是感觉没有学透，那么Spring的作用到底体现在哪里呢？要理解这个问题，我们需要先看一下没有Spring的世界是什么样的，然后再看看有了Spring之后是什么样子的，这样自然理解更加透彻。
史前时代
假如没有Spring框架，要开发一个java web程序该怎么做呢？很多人马上想到了Java web里的Servlet、JSP以及Tomcat这些技术，是的，这是用Java做web应用基础技术。接触Java 有些年头了，相信很多人已经忘记了怎么创建一个不使用构建工具和任何Java Web框架的原始JavaWeb。本节我们看一下如何搭建一个没有高级框架的web应用。这个工作使用idea还挺麻烦，我们记录一下：
1 搭建一个本地web服务 1.打开idea，选择file-&gt;New-&gt;Project
2.点击Java,点击下一步.
3.修改项目名
这里根据你的计划，设置到一个相对稳定的目录即可。为了防止异常问题，建立路径里不要有空格或者中文字符。
4.右键项目，选择add framework support
5.完成之后，项目结构变成了这样,然后我们在WEB-INF下创建classes和lib文件夹，如下所示：
6.接下来，编辑项目结构, 将output path的路径改成classes文件夹的路径，如下所示：
7.点击dependencies，选择加号，选择jars or directories, 点击后，他会弹出一个文件选择框，这里选择lib文件所在位置，如图所示：
然后此时单击西方的“&#43;”号，会出现中间位置的弹窗，单击之后会在中间位置出现一个小窗口：
这里将web-INF下的lib目录添加进来。此时还会出现一个弹窗，就是询问这个lib是干什么的，这就是我们后面会手动添加的lib：
之后选中退出即可，效果如下：
接下来要配置tomcat，我们使用的是8.5。这个需要先下载到本地，然后执行一下看看是否正常。之后再在idea中配置。
单击idea的“Run”，然后选择“edit setting”，进入下面的界面：
此时我们要首先选择左上方的“&#43;”，在列表中找到“tomcat server”（注意不要和TomEE server混了）。
然后配置右侧的相关内容。这里图中标记处默认的端口号是8080，但是8080经常会和其他服务冲突，因此这里改成了9091。
这里还要注意deployment下的这个配置：
保持与全面访问路径一致。
最后我们打开index.jsp页面，增加如下内容：
&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello world&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello world &lt;/body&gt; &lt;/html&gt; 之后启动tomcat，在浏览器输入：http://localhost:9091/webtest/就可以看到一个“Hello world&#34;的信息。
2 Java web是如何工作的 有了上面的环境之后，那如何实现展示的内容与后台Java交互呢？我们知道有两种常用的技术，一种是JSP，一个是直接写Servlet。JSP其实就是在静态页面里嵌入Java代码，而Servlet则是在Java代码里嵌入静态代码，例如常见的JSP页面一般是这样的：
&lt;%@ page import=&#34;com.lqc.pojo.Person&#34; %&gt; &lt;%@ page import=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2941008ec0b898d88eee6ea7712f1a06/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-27T09:54:16+08:00" />
<meta property="article:modified_time" content="2024-01-27T09:54:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Tomcat与网络1】史前时代—没有Spring该如何写Web服务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在前面我们介绍了网络与Java相关的问题， 最近在调研的时候发现这块内容其实非常复杂，涉及的内容多而且零碎，想短时间梳理出整个体系是不太可能的，所以我们还是继续看Tomcat的问题，后面有网络的内容继续补充吧。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%20%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0web%E6%9C%8D%E5%8A%A1-toc" style="margin-left:0px;"><a href="#1%20%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0web%E6%9C%8D%E5%8A%A1" rel="nofollow">1 搭建一个本地web服务</a></p> 
<p id="2%20Java%20web%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-toc" style="margin-left:0px;"><a href="#2%20Java%20web%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84" rel="nofollow">2 Java web是如何工作的</a></p> 
<hr id="hr-toc"> 
<p>Servlet是Java Web的核心机制，而实现Servlet最好的服务器无疑就是Tomcat。在前面我们介绍了如何用Java实现网络通信，这个与自己实现一个Servlet服务器，比如Tomcat 还差多少呢？差十万八千里，有一个挺好玩的图：</p> 
<p class="img-center"><img alt="" height="447" src="https://images2.imgbox.com/41/80/v2MJv6Gd_o.png" width="365"></p> 
<p>目前各类Spring的材料实在太多了，我们用的也多。那么Spring到底是什么？又有什么用呢？我们可以找到一堆的标准答案，但是貌似对Spring的理解总是感觉没有学透，那么Spring的作用到底体现在哪里呢？要理解这个问题，我们需要先看一下没有Spring的世界是什么样的，然后再看看有了Spring之后是什么样子的，这样自然理解更加透彻。</p> 
<p>史前时代</p> 
<p>假如没有Spring框架，要开发一个java web程序该怎么做呢？很多人马上想到了Java web里的Servlet、JSP以及Tomcat这些技术，是的，这是用Java做web应用基础技术。接触Java 有些年头了，相信很多人已经忘记了怎么创建一个不使用构建工具和任何Java Web框架的原始JavaWeb。本节我们看一下如何搭建一个没有高级框架的web应用。这个工作使用idea还挺麻烦，我们记录一下：</p> 
<h2 id="1%20%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0web%E6%9C%8D%E5%8A%A1">1 搭建一个本地web服务</h2> 
<p>1.打开idea，选择file-&gt;New-&gt;Project</p> 
<p class="img-center"><img alt="" height="168" src="https://images2.imgbox.com/72/8f/EPg3DGGE_o.png" width="582"></p> 
<p>2.点击Java,点击下一步.</p> 
<p class="img-center"><img alt="" height="187" src="https://images2.imgbox.com/60/e5/ah3QCTQv_o.png" width="570"></p> 
<p>3.修改项目名</p> 
<p>这里根据你的计划，设置到一个相对稳定的目录即可。为了防止异常问题，建立路径里不要有空格或者中文字符。</p> 
<p>4.右键项目，选择add framework support</p> 
<p class="img-center"><img alt="" height="231" src="https://images2.imgbox.com/db/40/8bamjb5Z_o.png" width="600"></p> 
<p>5.完成之后，项目结构变成了这样,然后我们在WEB-INF下创建classes和lib文件夹，如下所示：</p> 
<p class="img-center"><img alt="" height="234" src="https://images2.imgbox.com/c8/51/k5OPrHFU_o.png" width="369"></p> 
<p>6.接下来，编辑项目结构, 将output path的路径改成classes文件夹的路径，如下所示：</p> 
<p class="img-center"><img alt="" height="233" src="https://images2.imgbox.com/b8/62/WvJ4SZpT_o.png" width="630"></p> 
<p>7.点击dependencies，选择加号，选择jars or directories, 点击后，他会弹出一个文件选择框，这里选择lib文件所在位置，如图所示：</p> 
<p class="img-center"><img alt="" height="191" src="https://images2.imgbox.com/ce/ba/X5P8dtPt_o.png" width="647"></p> 
<p>然后此时单击西方的“+”号，会出现中间位置的弹窗，单击之后会在中间位置出现一个小窗口：</p> 
<p class="img-center"><img alt="" height="441" src="https://images2.imgbox.com/11/39/7bLLR84Q_o.png" width="536"></p> 
<p>这里将web-INF下的lib目录添加进来。此时还会出现一个弹窗，就是询问这个lib是干什么的，这就是我们后面会手动添加的lib：</p> 
<p class="img-center"><img alt="" height="566" src="https://images2.imgbox.com/e6/cc/Hig3jfdv_o.png" width="524"></p> 
<p>之后选中退出即可，效果如下：</p> 
<p class="img-center"><img alt="" height="307" src="https://images2.imgbox.com/b0/a7/in4MzWVd_o.png" width="580"></p> 
<p class="img-center"><img alt="" height="82" src="https://images2.imgbox.com/cb/b6/5clSoNkP_o.png" width="629"></p> 
<p class="img-center"><img alt="" height="105" src="https://images2.imgbox.com/7b/09/CTVOZs91_o.png" width="590"></p> 
<p>接下来要配置tomcat，我们使用的是8.5。这个需要先下载到本地，然后执行一下看看是否正常。之后再在idea中配置。</p> 
<p>单击idea的“Run”，然后选择“edit setting”，进入下面的界面：</p> 
<p class="img-center"><img alt="" height="399" src="https://images2.imgbox.com/fe/80/8t2FLXx3_o.png" width="623"></p> 
<p>此时我们要首先选择左上方的“+”，在列表中找到“tomcat server”（注意不要和TomEE server混了）。</p> 
<p>然后配置右侧的相关内容。这里图中标记处默认的端口号是8080，但是8080经常会和其他服务冲突，因此这里改成了9091。</p> 
<p>这里还要注意deployment下的这个配置：</p> 
<p><img alt="" height="368" src="https://images2.imgbox.com/17/69/PigE37Aa_o.png" width="639"></p> 
<p>保持与全面访问路径一致。</p> 
<p>最后我们打开index.jsp页面，增加如下内容：</p> 
<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello world&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
Hello world
  &lt;/body&gt;
&lt;/html&gt;

</code></pre> 
<p>之后启动tomcat，在浏览器输入：<a href="http://localhost:9091/webtest/" rel="nofollow" title="http://localhost:9091/webtest/">http://localhost:9091/webtest/</a>就可以看到一个“Hello world"的信息。</p> 
<h2 id="2%20Java%20web%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">2 Java web是如何工作的</h2> 
<p>有了上面的环境之后，那如何实现展示的内容与后台Java交互呢？我们知道有两种常用的技术，一种是JSP，一个是直接写Servlet。JSP其实就是在静态页面里嵌入Java代码，而Servlet则是在Java代码里嵌入静态代码，例如常见的JSP页面一般是这样的：</p> 
<pre><code>&lt;%@ page import="com.lqc.pojo.Person" %&gt;
&lt;%@ page import="java.util.List" %&gt;
&lt;%@ page import="java.util.ArrayList" %&gt;
&lt;%@ page import="java.util.Map" %&gt;
&lt;%@ page import="java.util.HashMap" %&gt;

&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;body&gt;
    &lt;%
        Person person = new Person();
        person.setName("哥好帅！");
        person.setPhones(new String[]{"11111111111","13333333333","13666666666"});

        List&lt;String&gt; cities = new ArrayList&lt;String&gt;();
        cities.add("北京");
        cities.add("上海");
        person.setCities(cities);

        Map&lt;String,Object&gt;map = new HashMap&lt;&gt;();
        map.put("key1","value1");
        map.put("key2","value2");
        person.setMap(map);

        pageContext.setAttribute("p", person);
    %&gt;

    输出Person：${ p }&lt;br/&gt;
    输出Person的name属性：${p.name} &lt;br&gt;
    输出Person的pnones数组属性值：${p.phones[2]} &lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>而典型的Servlet代码是这样的：</p> 
<pre><code>public class HelloServlet extends HttpServlet {

   public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
            throws ServletException, IOException {
        // 设置响应内容类型
        response.setContentType("text/html");

        // 实际的逻辑是在这里
        PrintWriter out = response.getWriter();
        out.println("&lt;h1&gt; servlet Hello World  &lt;/h1&gt;");
    }

    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }

    public void destroy() {
        // ....
    }
}</code></pre> 
<p>此时还要在web.xml中增加相关的配置信息：</p> 
<pre><code> &lt;servlet&gt;
        &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.lqc.webtest.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/helloServlet&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;</code></pre> 
<p>这时候，然后重启tomat，输入地址<a href="http://localhost:9091/webtest/helloServlet" rel="nofollow" title="http://localhost:9091/webtest/helloServlet">http://localhost:9091/webtest/helloServlet</a>，就可以看到页面展示了“servlet Hello World”。</p> 
<p>上面的代码不管是在JSP中嵌套Java代码，还是在Servlet中嵌套静态代码，如果到工程里这么干，肯定都是灾难，虽然可以使用EL等优化，但是对于变成来说仍然非常不友好。典型的情况有：</p> 
<p>1.前端必须会后台的技术，后台也必须会前端的技术，不利用不同技术栈的人相互合作。</p> 
<p>2.即使懂相关技术非常容易错，即使错了也无法很好的定位。</p> 
<p>3.很难扩展和维护。</p> 
<p>为了解决这个问题 ，必须要实现前后端代码的分离，该如何分离呢？其实思路非常简单，我们上面输入的请求地址即使不用浏览器也能请求的，例如可以使用curl命令：</p> 
<p><img alt="" height="70" src="https://images2.imgbox.com/94/f2/wHK1oXYS_o.png" width="773"></p> 
<p>这里同样返回了结果“&lt;h1&gt; servlet Hello World &lt;/h1&gt;”。既然这样，那我前端工程只要能发送和接收http请求就可以了？入参和出参可以双方协定， 只要规则一致就可以正确相互解析了？其实前后端分离，或者动静分离，都是这个原理。之后前端和后端就分道扬镳了，前端有VUE等框架，而后台则更多。</p> 
<p>动静分离之后就没问题了吗？当然不是，后台要干的事情其实非常多，要处理用户请求，要执行很多业务处理、要负责数据库管理等等，还是太多了，那怎么办呢？这时候MVC模式就开始大量应用了，Java中最为典型的就是Struts2和SpringMVC，这个曾经被使用了很多年，估计现在很多公司的老项目还有其身影，使用MVC框架的的好处有：</p> 
<ol><li>允许更改视图层代码而不用重新编译模型和控制器代码；</li><li>允许使用各种不同样式的视图来访问同一个服务器端的代码；</li><li>使降低开发和维护用户接口的技术含量成为可能；</li><li>使开发时间得到相当大的缩减等。</li></ol> 
<p>与此同时，为了处理数据库管理的麻烦，就诞生了专门的框架，这就是持久化框架（ORM），最为典型的就是Hibernate、Mybatis和SpringJDBC Tempalte。由于Hibernate封装过度，导致框架过重，很多优化等不方便，所以逐步被Mybatis等取代。</p> 
<p>有了MVC框架和ORM框架，就够了吗？还不是，问题还有很多，其中最典型的问题是其配置问题，例如你要在Struts.xml中配置每个对象和实现类的映射关系，例如：</p> 
<pre><code>&lt;!--配置package,必须继承Struts-default--&gt;
&lt;struts&gt;
  &lt;package name="struts2" extends="struts-default"&gt;
  &lt;!--配置按action，名字hello是访问URL使用的：hello.action--&gt;

    &lt;action name="hello" class="org.yangjq.HelloAction"&gt;
    &lt;result name="success"&gt;/success.jsp&lt;/result&gt;
    &lt;result name="error"&gt;/error.jsp&lt;/result&gt;
    &lt;/action&gt;
  &lt;/package&gt;
&lt;/struts&gt;</code></pre> 
<p>Spring是如何管理用户的类的，这是一个很常见的面试题。其实管理的就是类似上面的Struts.xml里的配置，随着Spring的不断完善，衍生出来的功能越来越多，功能越来越强，甚至很多人“只知Spring，不知Java Web”。</p> 
<p>不过呢，Spring管理我们的类也需要一大堆的配置文件，这个过程仍然是非常痛苦，所以后面就逐步有了SpringBoot，SpringBoot使用自动装载等机制帮助我们省去了大量而繁琐的配置问题，很多时候我们只要加一个注解或者包扫描就可以使用了，这个我们后面再说。</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/569a5872dbf9e2c9a2b0668d29a79949/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言通过IXMLHttpRequest以get或post方式发送http请求获取服务器文本或xml数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17b491867f7259d9fe3f2117b7e435e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《动手学深度学习(PyTorch版)》笔记4.7</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>