<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅析MyBatis的动态代理原理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅析MyBatis的动态代理原理" />
<meta property="og:description" content="原文博客地址: pjmike的博客
前言 一直以来都在使用MyBatis做持久化框架，也知道当我们定义XXXMapper接口类并利用它来做CRUD操作时，Mybatis是利用了动态代理的技术帮我们生成代理类。那么动态代理内部的实现细节到底是怎么的呀？XXXMapper.java类和XXXMapper.xml到底是如何关联起来的呀？本篇文章就来详细剖析下MyBatis的动态代理的具体实现机制。
MyBatis的核心组件及应用 在详细探究MyBatis中动态代理机制之前，先来补充一下基础知识，认识一下MyBatis的核心组件。
SqlSessionFactoryBuilder(构造器)： 它可以从XML、注解或者手动配置Java代码来创建SqlSessionFactory。SqlSessionFactory: 用于创建SqlSession (会话) 的工厂SqlSession: SqlSession是Mybatis最核心的类，可以用于执行语句、提交或回滚事务以及获取映射器Mapper的接口SQL Mapper： 它是由一个Java接口和XML文件（或注解）构成的，需要给出对应的SQL和映射规则，它负责发送SQL去执行，并返回结果 注意： 现在我们使用Mybatis，一般都是和Spring框架整合在一起使用，这种情况下，SqlSession将被Spring框架所创建，所以往往不需要我们使用SqlSessionFactoryBuilder或者SqlSessionFactory去创建SqlSession
下面展示一下如何使用MyBatis的这些组件，或者如何快速使用MyBatis：
数据库表 CREATE TABLE user( id int, name VARCHAR(255) not NULL , age int , PRIMARY KEY (id) )ENGINE =INNODB DEFAULT CHARSET=utf8; 复制代码 声明一个User类 @Data public class User { private int id; private int age; private String name; @Override public String toString() { return &#34;User{&#34; &#43; &#34;id=&#34; &#43; id &#43; &#34;, age=&#34; &#43; age &#43; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bb59a535fe91200d9ac7e686a1820368/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-09T14:16:34+08:00" />
<meta property="article:modified_time" content="2019-05-09T14:16:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅析MyBatis的动态代理原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <blockquote> 
  <p>原文博客地址: <a href="https://link.juejin.im?target=https%3A%2F%2Fpjmike.github.io%2F2019%2F05%2F09%2F%25E6%25B5%2585%25E6%259E%2590MyBatis%25E7%259A%2584%25E5%258A%25A8%25E6%2580%2581%25E4%25BB%25A3%25E7%2590%2586%25E5%258E%259F%25E7%2590%2586%2F%23more" rel="nofollow">pjmike的博客</a></p> 
 </blockquote> 
 <h3 class="heading">前言</h3> 
 <p>一直以来都在使用MyBatis做持久化框架，也知道当我们定义XXXMapper接口类并利用它来做CRUD操作时，Mybatis是利用了动态代理的技术帮我们生成代理类。那么动态代理内部的实现细节到底是怎么的呀？XXXMapper.java类和XXXMapper.xml到底是如何关联起来的呀？本篇文章就来详细剖析下MyBatis的动态代理的具体实现机制。</p> 
 <h3 class="heading">MyBatis的核心组件及应用</h3> 
 <p>在详细探究MyBatis中动态代理机制之前，先来补充一下基础知识，认识一下MyBatis的核心组件。</p> 
 <ul><li><strong>SqlSessionFactoryBuilder(构造器)</strong>： 它可以从XML、注解或者手动配置Java代码来创建SqlSessionFactory。</li><li><strong>SqlSessionFactory</strong>: 用于创建SqlSession (会话) 的工厂</li><li><strong>SqlSession</strong>: SqlSession是Mybatis最核心的类，可以用于执行语句、提交或回滚事务以及获取映射器Mapper的接口</li><li><strong>SQL Mapper</strong>： 它是由一个Java接口和XML文件（或注解）构成的，需要给出对应的SQL和映射规则，它负责发送SQL去执行，并返回结果</li></ul> 
 <blockquote> 
  <p>注意： 现在我们使用Mybatis，一般都是和Spring框架整合在一起使用，这种情况下，SqlSession将被Spring框架所创建，所以往往不需要我们使用SqlSessionFactoryBuilder或者SqlSessionFactory去创建SqlSession</p> 
 </blockquote> 
 <p>下面展示一下如何使用MyBatis的这些组件，或者如何快速使用MyBatis：</p> 
 <ol><li>数据库表</li></ol> 
 <pre><code class="hljs mysql copyable">CREATE TABLE  user(
  id int,
  name VARCHAR(255) not NULL ,
  age int ,
  PRIMARY KEY (id)
)ENGINE =INNODB DEFAULT CHARSET=utf8;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ol start="2"><li>声明一个User类</li></ol> 
 <pre><code class="hljs java copyable"><span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"User{"</span> +
                <span class="hljs-string">"id="</span> + id +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">'}'</span>;
    }
}

<span class="copy-code-btn">复制代码</span></code></pre> 
 <ol start="3"><li>定义一个全局配置文件mybatis-config.xml (关于配置文件中具体属性标签解释参阅官方文档)</li></ol> 
 <pre><code class="hljs xml copyable" lang="xml"><span class="php"><span class="hljs-meta">&lt;?</span>xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span> <span class="hljs-meta">?&gt;</span></span>
<span class="hljs-meta">&lt;!DOCTYPE configuration  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span>
<span class="hljs-comment">&lt;!--全局配置文件的根元素--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
    <span class="hljs-comment">&lt;!--enviroments表示环境配置，可以配置成开发环境(development)、测试环境(test)、生产环境(production)等--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>
            <span class="hljs-comment">&lt;!--transactionManager： 事务管理器，属性type只有两个取值：JDBC和MANAGED--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"MANAGED"</span> /&gt;</span>
            <span class="hljs-comment">&lt;!--dataSource: 数据源配置--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/test"</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span> /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>
    <span class="hljs-comment">&lt;!--mappers文件路径配置--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"mapper/UserMapper.xml"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ol start="4"><li>UserMapper接口</li></ol> 
 <pre><code class="hljs java copyable"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>{
    <span class="hljs-function">User <span class="hljs-title">selectById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ol start="5"><li>UserMapper文件</li></ol> 
 <pre><code class="hljs xml copyable" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span>
<span class="hljs-comment">&lt;!--namespace属性表示命令空间，不同xml映射文件namespace必须不同--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.pjmike.mybatis.UserMapper"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectById"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span>
            <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.pjmike.mybatis.User"</span>&gt;</span>
             SELECT id,name,age FROM user where id= #{id}
       <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ol start="6"><li>测试类</li></ol> 
 <pre><code class="hljs java copyable"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisTest</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;
    <span class="hljs-keyword">static</span> {
        <span class="hljs-keyword">try</span> {
            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()
                    .build(Resources.getResourceAsStream(<span class="hljs-string">"mybatis-config.xml"</span>));
        } <span class="hljs-keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession()) {
            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
            User user = userMapper.selectById(<span class="hljs-number">1</span>);
            System.out.println(<span class="hljs-string">"User : "</span> + user);
        }
    }
}
<span class="hljs-comment">// 结果：</span>
User : User{id=<span class="hljs-number">1</span>, age=<span class="hljs-number">21</span>, name=<span class="hljs-string">'pjmike'</span>}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>上面的例子简单的展示了如何使用MyBatis，与此同时，我也将用这个例子来进一步探究MyBatis动态原理的实现。</p> 
 <h3 class="heading">MyBatis动态代理的实现</h3> 
 <pre><code class="hljs java copyable"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession()) {
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<span class="hljs-comment">// &lt;1&gt;</span>
        User user = userMapper.selectById(<span class="hljs-number">1</span>);
        System.out.println(<span class="hljs-string">"User : "</span> + user);
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在前面的例子中，我们使用sqlSession.getMapper()方法获取UserMapper对象，实际上这里我们是获取了UserMapper接口的代理类，然后再由代理类执行方法。那么这个代理类是如何生成的呢？在探究动态代理类如何生成之前，我们先来看下SqlSessionFactory工厂的创建过程做了哪些准备工作，比如说mybatis-config配置文件是如何读取的，映射器文件是如何读取的？</p> 
 <h4 class="heading">mybatis全局配置文件解析</h4> 
 <pre><code class="hljs java copyable"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;
<span class="hljs-keyword">static</span> {
    <span class="hljs-keyword">try</span> {
        sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()
                .build(Resources.getResourceAsStream(<span class="hljs-string">"mybatis-config.xml"</span>));
    } <span class="hljs-keyword">catch</span> (IOException e) {
        e.printStackTrace();
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>我们使用new SqlSessionFactoryBuilder().build()的方式创建SqlSessionFactory工厂，走进build方法</p> 
 <pre><code class="hljs java copyable"> <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">build</span><span class="hljs-params">(InputStream inputStream, Properties properties)</span> </span>{
    <span class="hljs-keyword">return</span> build(inputStream, <span class="hljs-keyword">null</span>, properties);
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">build</span><span class="hljs-params">(InputStream inputStream, String environment, Properties properties)</span> </span>{
    <span class="hljs-keyword">try</span> {
      XMLConfigBuilder parser = <span class="hljs-keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);
      <span class="hljs-keyword">return</span> build(parser.parse());
    } <span class="hljs-keyword">catch</span> (Exception e) {
      <span class="hljs-keyword">throw</span> ExceptionFactory.wrapException(<span class="hljs-string">"Error building SqlSession."</span>, e);
    } <span class="hljs-keyword">finally</span> {
      ErrorContext.instance().reset();
      <span class="hljs-keyword">try</span> {
        inputStream.close();
      } <span class="hljs-keyword">catch</span> (IOException e) {
        <span class="hljs-comment">// Intentionally ignore. Prefer previous error.</span>
      }
    }
  }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p><strong>对于mybatis的全局配置文件的解析，相关解析代码位于XMLConfigBuilder的parse()方法</strong>中：</p> 
 <pre><code class="hljs java copyable"> <span class="hljs-function"><span class="hljs-keyword">public</span> Configuration <span class="hljs-title">parse</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (parsed) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">"Each XMLConfigBuilder can only be used once."</span>);
    }
    parsed = <span class="hljs-keyword">true</span>;
    <span class="hljs-comment">//解析全局配置文件</span>
    parseConfiguration(parser.evalNode(<span class="hljs-string">"/configuration"</span>));
    <span class="hljs-keyword">return</span> configuration;
  }

  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseConfiguration</span><span class="hljs-params">(XNode root)</span> </span>{
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">//issue #117 read properties first</span>
      propertiesElement(root.evalNode(<span class="hljs-string">"properties"</span>));
      Properties settings = settingsAsProperties(root.evalNode(<span class="hljs-string">"settings"</span>));
      loadCustomVfs(settings);
      loadCustomLogImpl(settings);
      typeAliasesElement(root.evalNode(<span class="hljs-string">"typeAliases"</span>));
      pluginElement(root.evalNode(<span class="hljs-string">"plugins"</span>));
      objectFactoryElement(root.evalNode(<span class="hljs-string">"objectFactory"</span>));
      objectWrapperFactoryElement(root.evalNode(<span class="hljs-string">"objectWrapperFactory"</span>));
      reflectorFactoryElement(root.evalNode(<span class="hljs-string">"reflectorFactory"</span>));
      settingsElement(settings);
      <span class="hljs-comment">// read it after objectFactory and objectWrapperFactory issue #631</span>
      environmentsElement(root.evalNode(<span class="hljs-string">"environments"</span>));
      databaseIdProviderElement(root.evalNode(<span class="hljs-string">"databaseIdProvider"</span>));
      typeHandlerElement(root.evalNode(<span class="hljs-string">"typeHandlers"</span>));
      <span class="hljs-comment">//解析mapper映射器文件</span>
      mapperElement(root.evalNode(<span class="hljs-string">"mappers"</span>));
    } <span class="hljs-keyword">catch</span> (Exception e) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BuilderException(<span class="hljs-string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);
    }
  }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>从parseConfiguration方法的源代码中很容易就可以看出它对mybatis全局配置文件中各个元素属性的解析。当然最终解析后返回一个Configuration对象，Configuration是一个很重要的类，它包含了Mybatis的所有配置信息，它是通过XMLConfigBuilder取钱构建的，Mybatis通过XMLConfigBuilder读取mybatis-config.xml中配置的信息，然后将这些信息保存到Configuration中</p> 
 <h4 class="heading">映射器Mapper文件的解析</h4> 
 <pre><code class="hljs java copyable">  <span class="hljs-comment">//解析mapper映射器文件</span>
  mapperElement(root.evalNode(<span class="hljs-string">"mappers"</span>));
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>该方法是对全局配置文件中mappers属性的解析，走进去：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p><code>mapperParser.parse()</code>方法就是XMLMapperBuilder对Mapper映射器文件进行解析，可与XMLConfigBuilder进行类比</p> 
 <pre><code class="hljs java copyable">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (!configuration.isResourceLoaded(resource)) {
      configurationElement(parser.evalNode(<span class="hljs-string">"/mapper"</span>)); <span class="hljs-comment">//解析映射文件的根节点mapper元素</span>
      configuration.addLoadedResource(resource);  
      bindMapperForNamespace(); <span class="hljs-comment">//重点方法，这个方法内部会根据namespace属性值，生成动态代理类</span>
    }
    parsePendingResultMaps();
    parsePendingCacheRefs();
    parsePendingStatements();
  }

<span class="copy-code-btn">复制代码</span></code></pre> 
 <ul><li><strong>configurationElement(XNode context)方法</strong></li></ul> 
 <p>该方法主要用于将mapper文件中的元素信息，比如<code>insert</code>、<code>select</code>这等信息解析到MappedStatement对象，并保存到Configuration类中的mappedStatements属性中，以便于后续动态代理类执行CRUD操作时能够获取真正的Sql语句信息</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>buildStatementFromContext方法就用于解析<code>insert、select</code>这类元素信息，并将其封装成MappedStatement对象，具体的实现细节这里就不细说了。</p> 
 <ul><li><strong>bindMapperForNamespace()方法</strong></li></ul> 
 <p>该方法是核心方法，它会根据mapper文件中的namespace属性值，为接口生成动态代理类，这就来到了我们的主题内容——动态代理类是如何生成的。</p> 
 <h4 class="heading">动态代理类的生成</h4> 
 <p>bindMapperForNamespace方法源码如下所示：</p> 
 <pre><code class="hljs java copyable"> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindMapperForNamespace</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">//获取mapper元素的namespace属性值</span>
    String namespace = builderAssistant.getCurrentNamespace();
    <span class="hljs-keyword">if</span> (namespace != <span class="hljs-keyword">null</span>) {
      Class&lt;?&gt; boundType = <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 获取namespace属性值对应的Class对象</span>
        boundType = Resources.classForName(namespace);
      } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
        <span class="hljs-comment">//如果没有这个类，则直接忽略，这是因为namespace属性值只需要唯一即可，并不一定对应一个XXXMapper接口</span>
        <span class="hljs-comment">//没有XXXMapper接口的时候，我们可以直接使用SqlSession来进行增删改查</span>
      }
      <span class="hljs-keyword">if</span> (boundType != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (!configuration.hasMapper(boundType)) {
          <span class="hljs-comment">// Spring may not know the real resource name so we set a flag</span>
          <span class="hljs-comment">// to prevent loading again this resource from the mapper interface</span>
          <span class="hljs-comment">// look at MapperAnnotationBuilder#loadXmlResource</span>
          configuration.addLoadedResource(<span class="hljs-string">"namespace:"</span> + namespace);
          <span class="hljs-comment">//如果namespace属性值有对应的Java类，调用Configuration的addMapper方法，将其添加到MapperRegistry中</span>
          configuration.addMapper(boundType);
        }
      }
    }
  }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>这里提到了Configuration的addMapper方法，实际上Configuration类里面通过MapperRegistry对象维护了所有要生成动态代理类的XxxMapper接口信息，可见Configuration类确实是相当重要一类</p> 
 <pre><code class="hljs java copyable"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Configuration</span> </span>{
    ...
    <span class="hljs-keyword">protected</span> MapperRegistry mapperRegistry = <span class="hljs-keyword">new</span> MapperRegistry(<span class="hljs-keyword">this</span>);
    ...
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>{
      mapperRegistry.addMapper(type);
    }
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>{
      <span class="hljs-keyword">return</span> mapperRegistry.getMapper(type, sqlSession);
    }
    ...
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>其中两个重要的方法：getMapper()和addMapper()</p> 
 <ul><li>getMapper(): 用于创建接口的动态类</li><li>addMapper(): mybatis在解析配置文件时，会将需要生成动态代理类的接口注册到其中</li></ul> 
 <h5 class="heading">1. Configuration#addMappper()</h5> 
 <p>Configuration将addMapper方法委托给MapperRegistry的addMapper进行的，源码如下：</p> 
 <pre><code class="hljs java copyable">  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>{
    <span class="hljs-comment">// 这个class必须是一个接口，因为是使用JDK动态代理，所以需要是接口，否则不会针对其生成动态代理</span>
    <span class="hljs-keyword">if</span> (type.isInterface()) {
      <span class="hljs-keyword">if</span> (hasMapper(type)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">"Type "</span> + type + <span class="hljs-string">" is already known to the MapperRegistry."</span>);
      }
      <span class="hljs-keyword">boolean</span> loadCompleted = <span class="hljs-keyword">false</span>;
      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 生成一个MapperProxyFactory，用于之后生成动态代理类</span>
        knownMappers.put(type, <span class="hljs-keyword">new</span> MapperProxyFactory&lt;&gt;(type));
        <span class="hljs-comment">//以下代码片段用于解析我们定义的XxxMapper接口里面使用的注解，这主要是处理不使用xml映射文件的情况</span>
        MapperAnnotationBuilder parser = <span class="hljs-keyword">new</span> MapperAnnotationBuilder(config, type);
        parser.parse();
        loadCompleted = <span class="hljs-keyword">true</span>;
      } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (!loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
  }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>MapperRegistry内部维护一个映射关系，每个接口对应一个MapperProxyFactory（生成动态代理工厂类）</p> 
 <pre><code class="hljs java copyable">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>这样便于在后面调用MapperRegistry的getMapper()时，直接从Map中获取某个接口对应的动态代理工厂类，然后再利用工厂类针对其接口生成真正的动态代理类。</p> 
 <h5 class="heading">2. Configuration#getMapper()</h5> 
 <p>Configuration的getMapper()方法内部就是调用MapperRegistry的getMapper()方法，源代码如下：</p> 
 <pre><code class="hljs java copyable">  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>{
    <span class="hljs-comment">//根据Class对象获取创建动态代理的工厂对象MapperProxyFactory</span>
    <span class="hljs-keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
    <span class="hljs-keyword">if</span> (mapperProxyFactory == <span class="hljs-keyword">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">"Type "</span> + type + <span class="hljs-string">" is not known to the MapperRegistry."</span>);
    }
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">//这里可以看到每次调用都会创建一个新的代理对象返回</span>
      <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);
    } <span class="hljs-keyword">catch</span> (Exception e) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">"Error getting mapper instance. Cause: "</span> + e, e);
    }
  }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>从上面可以看出，创建动态代理类的核心代码就是在MapperProxyFactory.newInstance方法中，源码如下：</p> 
 <pre><code class="hljs java copyable">  <span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>{
    <span class="hljs-comment">//这里使用JDK动态代理，通过Proxy.newProxyInstance生成动态代理类</span>
    <span class="hljs-comment">// newProxyInstance的参数：类加载器、接口类、InvocationHandler接口实现类</span>
    <span class="hljs-comment">// 动态代理可以将所有接口的调用重定向到调用处理器InvocationHandler，调用它的invoke方法</span>
    <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> Class[] { mapperInterface }, mapperProxy);
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> </span>{
    <span class="hljs-keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);
    <span class="hljs-keyword">return</span> newInstance(mapperProxy);
  }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <blockquote> 
  <p>PS: 关于JDK动态代理的详细介绍这里就不再细说了，有兴趣的可以参阅我之前写的文章：<a href="https://link.juejin.im?target=https%3A%2F%2Fpjmike.github.io%2F2018%2F08%2F07%2F%25E5%258A%25A8%25E6%2580%2581%25E4%25BB%25A3%25E7%2590%2586%25E7%259A%2584%25E5%258E%259F%25E7%2590%2586%25E5%258F%258A%25E5%2585%25B6%25E5%25BA%2594%25E7%2594%25A8%2F" rel="nofollow">动态代理的原理及其应用</a></p> 
 </blockquote> 
 <p>这里的InvocationHandler接口的实现类是MapperProxy，其源码如下：</p> 
 <pre><code class="hljs java copyable"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperProxy</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span>, <span class="hljs-title">Serializable</span> </span>{

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">6424540398559729838L</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SqlSession sqlSession;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; mapperInterface;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MapperProxy</span><span class="hljs-params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>{
    <span class="hljs-keyword">this</span>.sqlSession = sqlSession;
    <span class="hljs-keyword">this</span>.mapperInterface = mapperInterface;
    <span class="hljs-keyword">this</span>.methodCache = methodCache;
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">//如果调用的是Object类中定义的方法，直接通过反射调用即可</span>
      <span class="hljs-keyword">if</span> (Object.class.equals(method.getDeclaringClass())) {
        <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-keyword">this</span>, args);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isDefaultMethod(method)) {
        <span class="hljs-keyword">return</span> invokeDefaultMethod(proxy, method, args);
      }
    } <span class="hljs-keyword">catch</span> (Throwable t) {
      <span class="hljs-keyword">throw</span> ExceptionUtil.unwrapThrowable(t);
    }
    <span class="hljs-comment">//调用XxxMapper接口自定义的方法，进行代理</span>
    <span class="hljs-comment">//首先将当前被调用的方法Method构造成一个MapperMethod对象，然后掉用其execute方法真正的开始执行。</span>
    <span class="hljs-keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);
    <span class="hljs-keyword">return</span> mapperMethod.execute(sqlSession, args);
  }
  <span class="hljs-function"><span class="hljs-keyword">private</span> MapperMethod <span class="hljs-title">cachedMapperMethod</span><span class="hljs-params">(Method method)</span> </span>{
    <span class="hljs-keyword">return</span> methodCache.computeIfAbsent(method, k -&gt; <span class="hljs-keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));
  }
  ...
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>最终的执行逻辑在于MapperMethod类的execute方法，源码如下：</p> 
 <pre><code class="hljs java copyable"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperMethod</span> </span>{

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SqlCommand command;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodSignature method;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MapperMethod</span><span class="hljs-params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>{
    <span class="hljs-keyword">this</span>.command = <span class="hljs-keyword">new</span> SqlCommand(config, mapperInterface, method);
    <span class="hljs-keyword">this</span>.method = <span class="hljs-keyword">new</span> MethodSignature(config, mapperInterface, method);
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">execute</span><span class="hljs-params">(SqlSession sqlSession, Object[] args)</span> </span>{
    Object result;
    <span class="hljs-keyword">switch</span> (command.getType()) {
      <span class="hljs-comment">//insert语句的处理逻辑</span>
      <span class="hljs-keyword">case</span> INSERT: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.insert(command.getName(), param));
        <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-comment">//update语句的处理逻辑</span>
      <span class="hljs-keyword">case</span> UPDATE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.update(command.getName(), param));
        <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-comment">//delete语句的处理逻辑</span>
      <span class="hljs-keyword">case</span> DELETE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = rowCountResult(sqlSession.delete(command.getName(), param));
        <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-comment">//select语句的处理逻辑</span>
      <span class="hljs-keyword">case</span> SELECT:
        <span class="hljs-keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
          executeWithResultHandler(sqlSession, args);
          result = <span class="hljs-keyword">null</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsMany()) {
          result = executeForMany(sqlSession, args);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsMap()) {
          result = executeForMap(sqlSession, args);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.returnsCursor()) {
          result = executeForCursor(sqlSession, args);
        } <span class="hljs-keyword">else</span> {
          Object param = method.convertArgsToSqlCommandParam(args);
          <span class="hljs-comment">//调用sqlSession的selectOne方法</span>
          result = sqlSession.selectOne(command.getName(), param);
          <span class="hljs-keyword">if</span> (method.returnsOptional()
              &amp;&amp; (result == <span class="hljs-keyword">null</span> || !method.getReturnType().equals(result.getClass()))) {
            result = Optional.ofNullable(result);
          }
        }
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> FLUSH:
        result = sqlSession.flushStatements();
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">"Unknown execution method for: "</span> + command.getName());
    }
    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">"Mapper method '"</span> + command.getName()
          + <span class="hljs-string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="hljs-string">")."</span>);
    }
    <span class="hljs-keyword">return</span> result;
  }
  ...
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在MapperMethod中还有两个内部类，SqlCommand和MethodSignature类，在execute方法中首先用switch case语句根据SqlCommand的getType()方法，判断要执行的sql类型，比如INSET、UPDATE、DELETE、SELECT和FLUSH，然后分别调用SqlSession的增删改查等方法。</p> 
 <p>慢着，说了这么多，那么这个getMapper()方法什么时候被调用呀？实际是一开始我们调用SqlSession的getMapper()方法：</p> 
 <pre><code class="hljs java copyable">UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultSqlSession</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SqlSession</span> </span>{

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Configuration configuration;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor executor;
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>{
    <span class="hljs-keyword">return</span> configuration.getMapper(type, <span class="hljs-keyword">this</span>);
  }
  ...
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>所以getMapper方法的大致调用逻辑链是： SqlSession#getMapper() ——&gt; Configuration#getMapper() ——&gt; MapperRegistry#getMapper() ——&gt; MapperProxyFactory#newInstance() ——&gt; Proxy#newProxyInstance()</p> 
 <p>还有一点我们需要注意：<strong>我们通过SqlSession的getMapper方法获得接口代理来进行CRUD操作，其底层还是依靠的是SqlSession的使用方法</strong>。</p> 
 <h3 class="heading">小结</h3> 
 <p>根据上面的探究过程，简单画了一个逻辑图（不一定准确）：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>本篇文章主要介绍了MyBatis的动态原理，回过头来，我们需要知道我们使用UserMapper的动态代理类进行CRUD操作，本质上还是通过SqlSession这个关键类执行增删改查操作，但是对于SqlSession如何具体执行CRUD的操作并没有仔细阐述，有兴趣的同学可以查阅相关资料。</p> 
 <h3 class="heading">参考资料 &amp; 鸣谢</h3> 
 <ul><li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.tianshouzhi.com%2Fapi%2Ftutorials%2Fmybatis%2F360" rel="nofollow">www.tianshouzhi.com/api/tutoria…</a></li><li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.mybatis.org%2Fmybatis-3%2F" rel="nofollow">www.mybatis.org/mybatis-3/</a></li></ul> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7aa3ef793879cb226a711aadae6149d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android实用技巧之adb命令：am 命令的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/091b13e1a03d51979d4c7849f1356d34/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql Caused by: java.sql.SQLSyntaxErrorException: Unknown database &#39;task&#39;</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>