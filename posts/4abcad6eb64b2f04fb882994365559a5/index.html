<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP 协议相关知识点 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TCP 协议相关知识点" />
<meta property="og:description" content="**
TCP 的特性 **
TCP 提供一种面向连接的、可靠的字节流服务
TCP 使用校验和，确认和重传机制来保证可靠传输
TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制
注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。
**
TCP 帧格式 **
TCP的源端口、目的端口、以及IP层的源IP地址、目的IP地址四元组唯一的标识了一个TCP连接
TCP各字段释义：
TCP源端口(Source Port)：16位的源端口其中包含发送方应用程序对应的端口。源端口和源IP地址标示报文发送端的地址。
TCP目的端口(Destination port)：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。
TCP序列号（SequenceNumber）：该数据报第一个数据字节的序列号，用作标识该报文段序列号
TCP应答号(Acknowledgment Number简称ACK Number)：存放的是发送方期望收到的数据段序号，算作是对收到报文的一个确认。ACK标志为 0 时，应答号部分无效(例如首个连接的[SYN]数据包)，ACK标志为1时应答号才有效
TCP首部长度：标明TCP协议报头长度，单位是32bit即4个字节，其最小值为5（5 x 4 = 20 byte，这个长度是除去可选项的长度），从上图中看出，其规定头部长为 4 bit，所以最大值为 15， 15 x 4 = 60 byte可以算出可选项长度大为40个字节(60 byte - 20 byte = 40 byte)
保留位：保留字段长度为3位，必须全置为0
标记：
标志位简写 全写 含义
NSNonce有效排除潜在的ECN滥用CWRCongestion Window Reduced拥塞窗口减少标志ECEECN-EchoECN标志URGUrgent紧急指针有效性标志ACKAcknowledgment确认序号有效性标志，一旦一个连接建立起来，该标志总被置为1PSHPushush标志（接收方应尽快将报文段提交至应用层）RSTReset重置连接标志SYNSynchronization同步序号标志(建立连接时候使用)FINFin传输数据结束标志(断开连接时使用) 窗口大小(Window Size)：16位，该值指示了从Ack Number开始还愿意接收多少byte的数据量，也即用来表示当前接收端的接收窗还有多少剩余空间，用于TCP的流量控制。
校验位(Checksum)：16位TCP头。发送端基于数据内容计算一个数值，接收端要与发送端数值结果完全一样，才能证明数据的有效性。接收端checksum校验失败的时候会直接丢掉这个数据包。CheckSum是根据伪头&#43;TCP头&#43;TCP数据三部分进行计算的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4abcad6eb64b2f04fb882994365559a5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-01T11:31:23+08:00" />
<meta property="article:modified_time" content="2020-12-01T11:31:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP 协议相关知识点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>**</p> 
<h3><a id="TCP__2"></a>TCP 的特性</h3> 
<p>**<br> TCP 提供一种面向连接的、可靠的字节流服务<br> TCP 使用校验和，确认和重传机制来保证可靠传输<br> TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复<br> TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制<br> 注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p> 
<p>**</p> 
<h3><a id="TCP__13"></a>TCP 帧格式</h3> 
<p>**<br> <img src="https://images2.imgbox.com/8e/0b/X0lIWq6e_o.png" alt="在这里插入图片描述"><br> TCP的源端口、目的端口、以及IP层的源IP地址、目的IP地址四元组唯一的标识了一个TCP连接</p> 
<p>TCP各字段释义：<br> <strong>TCP源端口(Source Port)</strong>：16位的源端口其中包含发送方应用程序对应的端口。源端口和源IP地址标示报文发送端的地址。<br> <strong>TCP目的端口(Destination port)</strong>：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。<br> <strong>TCP序列号（SequenceNumber）</strong>：该数据报第一个数据字节的序列号，用作标识该报文段序列号<br> <strong>TCP应答号(Acknowledgment Number简称ACK Number)</strong>：存放的是发送方期望收到的数据段序号，算作是对收到报文的一个确认。ACK标志为 0 时，应答号部分无效(例如首个连接的[SYN]数据包)，ACK标志为1时应答号才有效<br> <strong>TCP首部长度</strong>：标明TCP协议报头长度，单位是32bit即4个字节，其最小值为5（5 x 4 = 20 byte，这个长度是除去可选项的长度），从上图中看出，其规定头部长为 4 bit，所以最大值为 15， 15 x 4 = 60 byte可以算出可选项长度大为40个字节(60 byte - 20 byte = 40 byte)</p> 
<p><strong>保留位</strong>：保留字段长度为3位，必须全置为0<br> <strong>标记：</strong><br> 标志位简写 全写 含义</p> 
<table><thead><tr><th>NS</th><th>Nonce</th><th>有效排除潜在的ECN滥用</th></tr></thead><tbody><tr><td>CWR</td><td>Congestion Window Reduced</td><td>拥塞窗口减少标志</td></tr><tr><td>ECE</td><td>ECN-Echo</td><td>ECN标志</td></tr><tr><td>URG</td><td>Urgent</td><td>紧急指针有效性标志</td></tr><tr><td>ACK</td><td>Acknowledgment</td><td>确认序号有效性标志，一旦一个连接建立起来，该标志总被置为1</td></tr><tr><td>PSH</td><td>Push</td><td>ush标志（接收方应尽快将报文段提交至应用层）</td></tr><tr><td>RST</td><td>Reset</td><td>重置连接标志</td></tr><tr><td>SYN</td><td>Synchronization</td><td>同步序号标志(建立连接时候使用)</td></tr><tr><td>FIN</td><td>Fin</td><td>传输数据结束标志(断开连接时使用)</td></tr></tbody></table> 
<p><strong>窗口大小(Window Size)</strong>：16位，该值指示了从Ack Number开始还愿意接收多少byte的数据量，也即用来表示当前接收端的接收窗还有多少剩余空间，用于TCP的流量控制。</p> 
<p><strong>校验位(Checksum)</strong>：16位TCP头。发送端基于数据内容计算一个数值，接收端要与发送端数值结果完全一样，才能证明数据的有效性。接收端checksum校验失败的时候会直接丢掉这个数据包。CheckSum是根据伪头+TCP头+TCP数据三部分进行计算的。</p> 
<p><strong>优先指针（紧急,Urgent Pointer）</strong>：16位，指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。</p> 
<p><strong>选项(Option)</strong>：选项可以有 0 到多个，可选项字段以第一个字节表明其类型，第二个字节表示该可选项的总长度，后面紧跟可选项的值(长度为可选项的总长度-2)。可选项字段可以从任何字节边界开始，但若最后选项长度不足的话，要填充以补足定义的数据段长度。</p> 
<p>**</p> 
<h3><a id="TCP__50"></a>TCP 三次握手</h3> 
<p>**<br> 所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p> 
<p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p> 
<p><strong>第一次握手(SYN=1, seq=x):</strong></p> 
<p>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。<br> 发送完毕后，客户端进入 SYN_SEND 状态。</p> 
<p><strong>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):</strong></p> 
<p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。</p> 
<p><strong>第三次握手(ACK=1，ACKnum=y+1)</strong></p> 
<p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1<br> 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</p> 
<p>三次握手的过程的示意图如下：<br> <img src="https://images2.imgbox.com/39/3d/koUhqWWB_o.png" alt="在这里插入图片描述"><br> 简述：<br> 客户端发送一个SYN段，并指明客户端的初始序列号，即ISN©.<br> 服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN©+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。<br> 为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</p> 
<p>**</p> 
<h3><a id="TCP__80"></a>TCP 四次挥手</h3> 
<p>**<br> TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p> 
<p><strong>第一次挥手(FIN=1，seq=x)</strong></p> 
<p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。<br> 发送完毕后，客户端进入 FIN_WAIT_1 状态。</p> 
<p><strong>第二次挥手(ACK=1，ACKnum=x+1)</strong></p> 
<p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p> 
<p>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</p> 
<p><strong>第三次挥手(FIN=1，seq=y)</strong></p> 
<p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p> 
<p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p> 
<p><strong>第四次挥手(ACK=1，ACKnum=y+1)</strong></p> 
<p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。</p> 
<p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p> 
<p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</p> 
<p>四次挥手的示意图如下：<br> <img src="https://images2.imgbox.com/00/df/srJHB1iy_o.png" alt="在这里插入图片描述"><br> **</p> 
<h3><a id="TCP_114"></a>TCP连接状态</h3> 
<p>**<br> <img src="https://images2.imgbox.com/15/67/ehRKvozH_o.png" alt="在这里插入图片描述"><br> <strong>LISTENING：侦听来自远方的TCP端口的连接请求.</strong><br> 首先服务端需要打开一个socket进行监听，状态为LISTEN。<br> 有提供某种服务才会处于LISTENING状态，TCP状态变化就是某个端口的状态变化，提供一个服务就打开一个端口，例如：提供www服务默认开的是80端口，提供ftp服务默认的端口为21，当提供的服务没有被连接时就处于LISTENING状态。FTP服务启动后首先处于侦听（LISTENING）状态。处于侦听LISTENING状态时，该端口是开放的，等待连接，但还没有被连接。就像你房子的门已经敞开的，但还没有人进来。<br> 看LISTENING状态最主要的是看本机开了哪些端口，这些端口都是哪个程序开的，关闭不必要的端口是保证安全的一个非常重要的方面，服务端口都对应一个服务（应用程序），停止该服务就关闭了该端口，例如要关闭21端口只要停止IIS服务中的FTP服务即可。关于这方面的知识请参阅其它文章。<br> 如果你不幸中了服务端口的木马，木马也开个端口处于LISTENING状态。</p> 
<p><strong>SYN-SENT：客户端SYN_SENT状态</strong><br> 再发送连接请求后等待匹配的连接请求:客户端通过应用程序调用connect进行active open.于是客户端tcp发送一个SYN以请求建立一个连接.之后状态置为SYN_SENT. /*The socket is actively attempting to establish a connection. 在发送连接请求后等待匹配的连接请求 */<br> 当请求连接时客户端首先要发送同步信号给要访问的机器，此时状态为SYN_SENT，如果连接成功了就变为ESTABLISHED，正常情况下SYN_SENT状态非常短暂。例如要访问网站http://www.baidu.com,如果是正常连接的话，用TCPView观察IEXPLORE.EXE（IE）建立的连接会发现很快从SYN_SENT变为ESTABLISHED，表示连接成功。SYN_SENT状态快的也许看不到。<br> 如果发现有很多SYN_SENT出现，那一般有这么几种情况，一是你要访问的网站不存在或线路不好，二是用扫描软件扫描一个网段的机器，也会出出现很多SYN_SENT，另外就是可能中了病毒了，例如中了"冲击波"，病毒发作时会扫描其它机器，这样会有很多SYN_SENT出现。</p> 
<p><strong>SYN-RECEIVED：服务器端握手状态SYN_RCVD</strong><br> 再收到和发送一个连接请求后等待对方对连接请求的确认<br> 当服务器收到客户端发送的同步信号时，将标志位ACK和SYN置1发送给客户端，此时服务器端处于SYN_RCVD状态，如果连接成功了就变为ESTABLISHED，正常情况下SYN_RCVD状态非常短暂。<br> 如果发现有很多SYN_RCVD状态，那你的机器有可能被SYN Flood的DoS(拒绝服务攻击)攻击了。</p> 
<p><strong>ESTABLISHED：代表一个打开的连接。</strong><br> ESTABLISHED状态是表示两台机器正在传输数据，观察这个状态最主要的就是看哪个程序正在处于ESTABLISHED状态。<br> 服务器出现很多ESTABLISHED状态： netstat -nat |grep 9502或者使用lsof -i:9502可以检测到。<br> 当客户端未主动close的时候就断开连接：即客户端发送的FIN丢失或未发送:<br> 这时候若客户端断开的时候发送了FIN包，则服务端将会处于CLOSE_WAIT状态；<br> 这时候若客户端断开的时候未发送FIN包，则服务端处还是显示ESTABLISHED状态；<br> 结果客户端重新连接服务器。<br> 而新连接上来的客户端（也就是刚才断掉的重新连上来了）在服务端肯定是ESTABLISHED; 如果客户端重复的上演这种情况，那么服务端将会出现大量的假的ESTABLISHED连接和CLOSE_WAIT连接。<br> 最终结果就是新的其他客户端无法连接上来，但是利用netstat还是能看到一条连接已经建立，并显示ESTABLISHED，但始终无法进入程序代码。</p> 
<p><strong>FIN-WAIT-1：</strong><br> 等待远程TCP连接中断请求，或先前的连接中断请求的确认<br> 主动关闭(active close)端应用程序调用close，于是其TCP发出FIN请求主动关闭连接，之后进入FIN_WAIT1状态./* The socket is closed, and the connection is shutting down. 等待远程TCP的连接中断请求，或先前的连接中断请求的确认 */<br> 如果服务器出现shutdown再重启，使用netstat -nat查看，就会看到很多FIN-WAIT-1的状态。就是因为服务器当前有很多客户端连接，直接关闭服务器后，无法接收到客户端的ACK。</p> 
<p><strong>FIN-WAIT-2：从远程TCP等待连接中断请求</strong><br> 主动关闭端接到ACK后，就进入了FIN-WAIT-2 ./* Connection is closed, and the socket is waiting for a shutdown from the remote end. 从远程TCP等待连接中断请求 */<br> 这就是著名的半关闭的状态了，这是在关闭连接时，客户端和服务器两次握手之后的状态。在这个状态下，应用程序还有接受数据的能力，但是已经无法发送数据，但是也有一种可能是，客户端一直处于FIN_WAIT_2状态，而服务器则一直处于WAIT_CLOSE状态，而直到应用层来决定关闭这个状态。</p> 
<p><strong>CLOSE-WAIT：等待从本地用户发来的连接中断请求</strong><br> 被动关闭(passive close)端TCP接到FIN后，就发出ACK以回应FIN请求(它的接收也作为文件结束符传递给上层应用程序),并进入CLOSE_WAIT. /* The remote end has shut down, waiting for the socket to close. 等待从本地用户发来的连接中断请求 */</p> 
<p><strong>CLOSING：等待远程TCP对连接中断的确认</strong><br> 比较少见./* Both sockets are shut down but we still don’t have all our data sent. 等待远程TCP对连接中断的确认 */<br> 实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？<br> 有两种情况可能导致这种状态：<br> 其一，如果双方几乎在同时关闭连接，那么就可能出现双方同时发送FIN包的情况；<br> 其二，如果ACK包丢失而对方的FIN包很快发出，也会出现FIN先于ACK到达。</p> 
<p><strong>LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认</strong></p> 
<p>被动关闭端一段时间后，接收到文件结束符的应用程序将调用CLOSE关闭连接。这导致它的TCP也发送一个 FIN,等待对方的ACK.就进入了LAST-ACK . /* The remote end has shut down, and the socket is closed. Waiting for acknowledgement. 等待原来发向远程TCP的连接中断请求的确认 */<br> 使用并发压力测试的时候，突然断开压力测试客户端，服务器会看到很多LAST-ACK。</p> 
<p><strong>TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认</strong><br> 在主动关闭端接收到FIN后，TCP就发送ACK包，并进入TIME-WAIT状态。/* The socket is waiting after close to handle packets still in the network.等待足够的时间以确保远程TCP接收到连接中断请求的确认 */<br> TIME_WAIT等待状态，这个状态又叫做2MSL状态，说的是在TIME_WAIT2发送了最后一个ACK数据报以后，要进入TIME_WAIT状态，这个状态是防止最后一次握手的数据报没有传送到对方那里而准备的（注意这不是四次握手，这是第四次握手的保险状态）。这个状态在很大程度上保证了双方都可以正常结束。</p> 
<p><strong>CLOSED：没有任何连接状态</strong></p> 
<p>被动关闭端在接受到ACK包后，就进入了closed的状态。连接结束./* The socket is not being used. 没有任何连接状态 */</p> 
<p><strong>TCP状态图纵览</strong><br> TCP连接本质是点对点的，理论上无所谓服务器，客户端。不过总得有一个进程等待在那里，对外提供连接的服务，就称之为服务器。</p> 
<p>下图是来源于Wikipedia的状态图，蓝线表示服务器的运行线路，棕色描述客户端。<br> <img src="https://images2.imgbox.com/27/08/g0dAkQg8_o.png" alt="在这里插入图片描述"><br> <strong>Server端典型状态图</strong><br> <img src="https://images2.imgbox.com/df/93/kXWBH5eU_o.png" alt="在这里插入图片描述"><br> <strong>Client端典型状态图</strong><br> <img src="https://images2.imgbox.com/b5/ae/FhZHlmHR_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/88a9f0a492ac5f3ded556435f0436924/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">error:could not open jvm.cfg</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cb4583254a2457830bbb7c4cbc6ad963/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">阿里运维笔试题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>