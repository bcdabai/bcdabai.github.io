<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何保证 RabbitMQ 消息不丢失？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何保证 RabbitMQ 消息不丢失？" />
<meta property="og:description" content="一.RabbitMQ消息丢失的三种情况 第一种：生产者弄丢了数据。生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。
第二种：RabbitMQ 弄丢了数据。MQ还没有持久化自己挂了。
第三种：消费端弄丢了数据。刚消费到，还没处理，结果进程挂了，比如重启了。
二.RabbitMQ消息丢失解决方案 1.针对生产者 方案1 ：开启RabbitMQ事务 可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。
// 开启事务 channel.txSelect(); try { // 这里发送消息 } catch (Exception e) { channel.txRollback(); // 这里再次重发这条消息 } // 提交事务 channel.txCommit(); 缺点：
RabbitMQ 事务机制是同步的，你提交一个事务之后会阻塞在那儿，采用这种方式基本上吞吐量会下来，因为太耗性能。
方案2：使用confirm机制 事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm 机制是异步的
在生产者开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq之中，rabbitmq会给你回传一个ack消息，告诉你这个消息发送OK了；如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。
//开启confirm channel.confirm(); //发送成功回调 public void ack(String messageId){ } // 发送失败回调 public void nack(String messageId){ //重发该消息 } 2.针对RabbitMQ 主要需要应对三点：
要保证rabbitMQ不丢失消息，那么就需要开启rabbitMQ的持久化机制，即把消息持久化到硬盘上，这样即使rabbitMQ挂掉在重启后仍然可以从硬盘读取消息；
如果rabbitMQ单点故障怎么办，这种情况倒不会造成消息丢失，这里就要提到rabbitMQ的3种安装模式，单机模式、普通集群模式、镜像集群模式，这里要保证rabbitMQ的高可用就要配合HAPROXY做镜像集群模式；
如果硬盘坏掉怎么保证消息不丢失。
（1）消息持久化 RabbitMQ 的消息默认存放在内存上面，如果不特别声明设置，消息不会持久化保存到硬盘上面的，如果节点重启或者意外crash掉，消息就会丢失。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b7526ad6946341efee44c6444ec4effb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-21T10:06:56+08:00" />
<meta property="article:modified_time" content="2023-03-21T10:06:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何保证 RabbitMQ 消息不丢失？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一.RabbitMQ消息丢失的三种情况</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6a/a6/Ab7MlmdX_o.png"></p> 
<p>  </p> 
<p>第一种：生产者弄丢了数据。生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。</p> 
<p>第二种：RabbitMQ 弄丢了数据。MQ还没有持久化自己挂了。</p> 
<p>第三种：消费端弄丢了数据。刚消费到，还没处理，结果进程挂了，比如重启了。</p> 
<h3>二.RabbitMQ消息丢失解决方案</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/be/75/CdgvYmNZ_o.png"></p> 
<p>  </p> 
<h3>1.针对生产者</h3> 
<h4>方案1 ：开启RabbitMQ事务</h4> 
<p>可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。</p> 
<pre><code>// 开启事务  
channel.txSelect();  
try {  
   // 这里发送消息  
} catch (Exception e) {  
   channel.txRollback(); 
// 这里再次重发这条消息
}
// 提交事务  
channel.txCommit();  
</code></pre> 
<p>缺点：</p> 
<p>RabbitMQ 事务机制是同步的，你提交一个事务之后会阻塞在那儿，采用这种方式基本上吞吐量会下来，因为太耗性能。</p> 
<h4>方案2：使用confirm机制</h4> 
<p>事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm 机制是异步的</p> 
<p>在生产者开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq之中，rabbitmq会给你回传一个ack消息，告诉你这个消息发送OK了；如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。</p> 
<pre><code>//开启confirm  
channel.confirm();  
//发送成功回调  
public void ack(String messageId){
}
// 发送失败回调  
public void nack(String messageId){  
    //重发该消息  
}
</code></pre> 
<h3>2.针对RabbitMQ</h3> 
<p>主要需要应对三点：</p> 
<ul><li> <p>要保证rabbitMQ不丢失消息，那么就需要开启rabbitMQ的持久化机制，即把消息持久化到硬盘上，这样即使rabbitMQ挂掉在重启后仍然可以从硬盘读取消息；</p> </li><li> <p>如果rabbitMQ单点故障怎么办，这种情况倒不会造成消息丢失，这里就要提到rabbitMQ的3种安装模式，单机模式、普通集群模式、镜像集群模式，这里要保证rabbitMQ的高可用就要配合HAPROXY做镜像集群模式；</p> </li><li> <p>如果硬盘坏掉怎么保证消息不丢失。</p> </li></ul> 
<h4>（1）消息持久化</h4> 
<p>RabbitMQ 的消息默认存放在内存上面，如果不特别声明设置，消息不会持久化保存到硬盘上面的，如果节点重启或者意外crash掉，消息就会丢失。</p> 
<p>所以就要对消息进行持久化处理。如何持久化，下面具体说明下。要想做到消息持久化，必须满足以下三个条件，缺一不可。</p> 
<ul><li> <p>Exchange 设置持久化</p> </li><li> <p>Queue 设置持久化</p> </li><li> <p>Message持久化发送：发送消息设置发送模式deliveryMode=2，代表持久化消息</p> </li></ul> 
<h4>（2）设置集群镜像模式</h4> 
<p>先来介绍下RabbitMQ三种部署模式：</p> 
<ul><li> <p>单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。 </p> </li><li> <p>普通模式：消息只会存在与当前节点中，并不会同步到其他节点，当前节点宕机，有影响的业务会瘫痪，只能等待节点恢复重启可用（必须持久化消息情况下）。 </p> </li><li> <p>镜像模式：消息会同步到其他节点上，可以设置同步的节点个数，但吞吐量会下降。属于RabbitMQ的HA方案</p> </li></ul> 
<p>为什么设置镜像模式集群，因为队列的内容仅仅存在某一个节点上面，不会存在所有节点上面，所有节点仅仅存放消息结构和元数据。下面画了一张图介绍普通集群丢失消息情况：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ab/6d/EKE8Npvj_o.png"></p> 
<p>  </p> 
<p>如果想解决上面途中问题，保证消息不丢失，需要采用HA 镜像模式队列。</p> 
<p>下面介绍下三种HA策略模式：</p> 
<ul><li> <p>同步至所有的</p> </li><li> <p>同步最多N个机器</p> </li><li> <p>只同步至符合指定名称的nodes</p> </li></ul> 
<p>命令处理HA策略模版：</p> 
<pre><code>rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]
</code></pre> 
<p>1）为每个以<code>rock.wechat</code>开头的队列设置所有节点的镜像，并且设置为自动同步模式</p> 
<pre><code>rabbitmqctl set_policy ha-all "^rock.wechat" '{"ha-mode":"all","ha-sync-mode":"automatic"}'  
rabbitmqctl set_policy -p rock ha-all "^rock.wechat" '{"ha-mode":"all","ha-sync-mode":"automatic"}'
</code></pre> 
<p>2）为每个以<code>rock.wechat.</code>开头的队列设置两个节点的镜像，并且设置为自动同步模式</p> 
<pre><code>rabbitmqctl set_policy -p rock ha-exacly "^rock.wechat" \
'{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'
</code></pre> 
<p>3）为每个以<code>node.</code>开头的队列分配指定的节点做镜像</p> 
<pre><code>rabbitmqctl set_policy ha-nodes "^nodes\." \
'{"ha-mode":"nodes","ha-params":["rabbit@nodeA", "rabbit@nodeB"]}'
</code></pre> 
<p>但是：HA 镜像队列有一个很大的缺点就是系统的吞吐量会有所下降。</p> 
<h4>（3）消息补偿机制</h4> 
<p>为什么还要消息补偿机制呢？难道消息还会丢失，没错，系统是在一个复杂的环境，不要想的太简单了，虽然以上的三种方案，基本可以保证消息的高可用不丢失的问题。</p> 
<p>但是作为有追求的程序员来讲，要绝对保证我的系统的稳定性，有一种危机意识。</p> 
<p>比如：持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？</p> 
<p>1）生产端首先将业务数据以及消息数据入库，需要在同一个事务中，消息数据入库失败，则整体回滚。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a9/f0/986qXmH9_o.png"></p> 
<p>  </p> 
<p>2）根据消息表中消息状态，失败则进行消息补偿措施，重新发送消息处理。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ec/33/0rtZCVVU_o.png"></p> 
<p>  </p> 
<h3>3.针对消费者</h3> 
<h4>方案一：ACK确认机制</h4> 
<p>多个消费者同时收取消息，比如消息接收到一半的时候，一个消费者死掉了(逻辑复杂时间太长，超时了或者消费被停机或者网络断开链接)，如何保证消息不丢？</p> 
<p>使用rabbitmq提供的ack机制，服务端首先关闭rabbitmq的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。才把消息从内存删除。</p> 
<p>这样就解决了，即使一个消费者出了问题，但不会同步消息给服务端，会有其他的消费端去消费，保证了消息不丢的case。</p> 
<h3>总结</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7f/d5/ugneYHXe_o.png"></p> 
<p>  </p> 
<p>如果需要保证消息在整条链路中不丢失，那就需要生产端、mq自身与消费端共同去保障。</p> 
<ul><li> <p>生产端：对生产的消息进行状态标记，开启confirm机制，依据mq的响应来更新消息状态，使用定时任务重新投递超时的消息，多次投递失败进行报警。</p> </li><li> <p>mq自身：开启持久化，并在落盘后再进行ack。如果是镜像部署模式，需要在同步到多个副本之后再进行ack。</p> </li><li> <p>消费端：开启手动ack模式，在业务处理完成后再进行ack，并且需要保证幂等。</p> </li></ul> 
<p>通过以上的处理，理论上不存在消息丢失的情况，但是系统的吞吐量以及性能有所下降。在实际开发中，需要考虑消息丢失的影响程度，来做出对可靠性以及性能之间的权衡。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c688066ce64ace9e09d81dc2682df874/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nginx实战:反向代理及负载均衡实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6158f5f8cea76bce494971f0e146c0c3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">了解衡量网络性能的四大指标：带宽、时延、抖动、丢包</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>