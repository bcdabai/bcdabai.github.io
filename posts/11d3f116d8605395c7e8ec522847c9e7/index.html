<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于Qt的飞机小游戏实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于Qt的飞机小游戏实现" />
<meta property="og:description" content="目录
前言
一、准备工作
二、基本功能实现
1.主菜单
2.核心玩法
3.其他
资源文件
前言 这是学习Qt时期做的一个小项目，现在看感觉有很多可优化的地方，放在这里给新人朋友们提供一个参考。
一、准备工作 无论什么项目，在正式写代码前应该梳理一下项目有哪些需要实现的基本功能，后期可扩展的功能，界面的基本布局，代码细分为哪些模块等等。总而言之，我们写程序必须具备迭代思维，为后期更新维护留空间。
我做的这个小游戏就类似于Flappy Bird，主要就是通过点击实现躲避障碍物。单一实现这一功能并不难，但游戏都讲究一个包装，所以我想还需要在界面上下点功夫。如下图所示，我把界面划分成了主菜单、游戏说明、游玩页面、结算页面四个部分：
二、基本功能实现 1.主菜单 ①鼠标停留图标放大：
当鼠标悬浮在图标上方，图标变大，鼠标离开则图标复原。这一功能有更简单的实现方式（用QSS样式表设置伪状态），但当时我是重写鼠标事件判断鼠标坐标与图标是否重合来实现的（现在看来太过冗余=.=）。 void Widget::mouseMoveEvent(QMouseEvent *event) { int x=this-&gt;mapFromGlobal(QCursor().pos()).x();//获取鼠标全局坐标点 int y=this-&gt;mapFromGlobal(QCursor().pos()).y(); //qDebug() &lt;&lt; &#34;x:&#34; &lt;&lt; event-&gt;x() &lt;&lt; &#34;y:&#34; &lt;&lt; event-&gt;y(); scale1 = 0; scale2 = 0; scale3 = 0; //判断鼠标位置是否在图标内 if(x &gt; play_x &amp;&amp; x &lt;(play_x&#43;pb_width) &amp;&amp; y &gt; play_y &amp;&amp; y &lt; (play_y&#43;pb_height)) { if(in_box)//标志位，true表示在图标内，默认状态为false { du-&gt;play();//播放音效 in_box = false; } //qDebug() &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/11d3f116d8605395c7e8ec522847c9e7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-21T12:33:31+08:00" />
<meta property="article:modified_time" content="2023-07-21T12:33:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于Qt的飞机小游戏实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" rel="nofollow">一、准备工作</a></p> 
<p style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0" rel="nofollow">二、基本功能实现</a></p> 
<p style="margin-left:40px;"><a href="#1.%E4%B8%BB%E8%8F%9C%E5%8D%95" rel="nofollow">1.主菜单</a></p> 
<p style="margin-left:40px;"> </p> 
<p style="margin-left:40px;"><a href="#2.%E6%A0%B8%E5%BF%83%E7%8E%A9%E6%B3%95" rel="nofollow">2.核心玩法</a></p> 
<p style="margin-left:40px;"><a href="#3.%E5%85%B6%E4%BB%96" rel="nofollow">3.其他</a></p> 
<p style="margin-left:0px;"><a href="#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6" rel="nofollow">资源文件</a></p> 
<hr> 
<h2>前言</h2> 
<p>这是学习Qt时期做的一个小项目，现在看感觉有很多可优化的地方，放在这里给新人朋友们提供一个参考。</p> 
<hr> 
<p> </p> 
<h2>一、准备工作</h2> 
<p>        无论什么项目，在正式写代码前应该梳理一下项目有哪些需要实现的基本功能，后期可扩展的功能，界面的基本布局，代码细分为哪些模块等等。总而言之，我们写程序必须具备迭代思维，为后期更新维护留空间。</p> 
<p>        我做的这个小游戏就类似于Flappy Bird，主要就是通过点击实现躲避障碍物。单一实现这一功能并不难，但游戏都讲究一个包装，所以我想还需要在界面上下点功夫。如下图所示，我把界面划分成了主菜单、游戏说明、游玩页面、结算页面四个部分：</p> 
<p>                         <img src="https://images2.imgbox.com/92/c5/bhteWI5L_o.png" alt="3b8d2954596d4978880b03603903d8d0.png"><img src="https://images2.imgbox.com/a8/65/Ug0XkMZK_o.png" alt="181dfae1b32a4be4b66164a9f0df9c84.png"></p> 
<p>                         <img src="https://images2.imgbox.com/55/54/G14VhLz4_o.png" alt="bb0c855f77d94c9388d3d578c8dff6ab.png"><img src="https://images2.imgbox.com/82/09/lFqELACC_o.png" alt="d321af9f5d47495dae1d26be05da2cb2.png"></p> 
<p> </p> 
<h2>二、基本功能实现</h2> 
<h3>1.主菜单</h3> 
<p>①鼠标停留图标放大：</p> 
<p>        当鼠标悬浮在图标上方，图标变大，鼠标离开则图标复原。这一功能有更简单的实现方式（用QSS样式表设置伪状态），但当时我是重写鼠标事件判断鼠标坐标与图标是否重合来实现的（现在看来太过冗余=.=）。<code class="language-c"> </code></p> 
<pre><code class="language-cpp">void Widget::mouseMoveEvent(QMouseEvent *event)
{

    int x=this-&gt;mapFromGlobal(QCursor().pos()).x();//获取鼠标全局坐标点
    int y=this-&gt;mapFromGlobal(QCursor().pos()).y();
    //qDebug() &lt;&lt; "x:" &lt;&lt; event-&gt;x() &lt;&lt; "y:" &lt;&lt; event-&gt;y();
    scale1 = 0;
    scale2 = 0;
    scale3 = 0;
    //判断鼠标位置是否在图标内
    if(x &gt; play_x &amp;&amp; x &lt;(play_x+pb_width) &amp;&amp; y &gt; play_y &amp;&amp; y &lt; (play_y+pb_height))
    {
        if(in_box)//标志位，true表示在图标内，默认状态为false
        {
            du-&gt;play();//播放音效
            in_box = false;
        }
        //qDebug() &lt;&lt; "box1:" &lt;&lt; in_box;
        scale1 = 1;
        pb_scale();//调用缩放函数
    }
    else if(x &gt; des_x &amp;&amp; x &lt;(des_x+pb_width) &amp;&amp; y &gt; des_y &amp;&amp; y &lt; (des_y+pb_height))
    {
        if(in_box)
        {
            du-&gt;play();
            in_box = false;
        }
        scale2 = 1;
        pb_scale();
    }
    else if(x &gt; end_x &amp;&amp; x &lt;(end_x+pb_width) &amp;&amp; y &gt; end_y &amp;&amp; y &lt; (end_y+pb_height))
    {
        if(in_box)
        {
            du-&gt;play();
            in_box = false;
        }
        scale3 = 1;
        pb_scale();
    }
    else
    {
        if(!in_box)
        {
            in_box = true;
        }
        //qDebug() &lt;&lt; "box2:" &lt;&lt; in_box;
        pb_scale();
    }
}

void Widget::pb_scale()//缩放函数
{
    ui-&gt;pb_play-&gt;setGeometry(play_x,play_y,pb_width,pb_height);
    ui-&gt;pushButton_2-&gt;setGeometry(des_x,des_y,pb_width,pb_height);
    ui-&gt;pb_close-&gt;setGeometry(end_x,end_y,pb_width,pb_height);
    if(scale1)
    {
        //绘制图标放大后的位置及大小
        ui-&gt;pb_play-&gt;setGeometry(play_x-5,play_y-5,pb_width+13,pb_height+8);
    }
    if(scale2)
    {
        ui-&gt;pushButton_2-&gt;setGeometry(des_x-5,des_y-5,pb_width+13,pb_height+8);
    }
    if(scale3)
    {
        ui-&gt;pb_close-&gt;setGeometry(end_x-5,end_y-5,pb_width+13,pb_height+8);
    }
}</code></pre> 
<h3> </h3> 
<p>②音效开关：</p> 
<p>        添加背景音乐及互动时的音效。注意在pro文件中添加代码：</p> 
<blockquote> 
 <p>QT += multimedia</p> 
</blockquote> 
<p>        定义背景音乐bgm和音效du：</p> 
<blockquote> 
 <p>QMediaPlayer *bgm;<br> QSound *du;</p> 
</blockquote> 
<pre><code class="language-cpp">du = new QSound(":/voice/du.wav",this);
bgm = new QMediaPlayer;
bgm-&gt;setMedia(QUrl("qrc:/voice/A Quest Unfolds.mp3"));//添加音频文件
bgm-&gt;setVolume(50);//设置音量
bgm-&gt;play();//开始播放
ui-&gt;voice_off-&gt;hide();//默认隐藏音效关闭按钮

void Widget::on_voice_on_clicked()//音效开-&gt;关
{
    ui-&gt;voice_off-&gt;show();//show出音效关闭的按钮
    bgm-&gt;setVolume(0);//设置音量为0
}

void Widget::on_voice_off_clicked()//音效关-&gt;开
{
    ui-&gt;voice_off-&gt;hide();//隐藏音效关闭的按钮
    bgm-&gt;setVolume(50);
}
</code></pre> 
<h3>2.核心玩法</h3> 
<p>①飞机：</p> 
<p>        飞机类，包含运动和撞机两个状态，初始化它的位置和速度（上升速度+重力），启用定时器，用绘图事件不断刷新飞机位置。</p> 
<pre><code class="language-cpp">Plane::Plane(QObject *parent) : QObject(parent)
{
    plane.load(":/image/plane3.png");
    style = 0;
    init();
    connect(&amp;timer_gravity,&amp;QTimer::timeout,this,&amp;Plane::Action);
}

void Plane::init()//初始化状态
{
    gamestart = 1;//游戏开始标志位
    pos = QPoint(50,150);//初始位置
    UpSpeed = 0;//上升速度为0
    gravity = 2;//重力为2
    timer_gravity.start(30);//开启定时器
}

void Plane::draw(QPainter &amp;painter)//绘制飞机位置
{
    if(gamestart)
    {
        painter.translate(pos.x(), pos.y());
        painter.translate(-pos.x(), -pos.y());
        painter.drawPixmap(pos.x(), pos.y(), PLANE_WIDTH, PLANE_HEIGHT, plane);
    }
}

void Plane::Up()//飞机上升
{
    UpSpeed = -10;//给上升速度为10（QT坐标下，向上向左为负，向右向下为正）
}

void Plane::Crash()//撞机
{
    gamestart = 0;//游戏结束
    timer_gravity.stop();//定时器停止
}

void Plane::Action()//飞机运动
{
    if(gamestart){
        //qDebug() &lt;&lt; "y:" &lt;&lt; pos.y() &lt;&lt; "x:" &lt;&lt; pos.x();
        if(UpSpeed&lt;0)//判断飞机是否上升
        {
            pos.setY(pos.y()+(UpSpeed));//设置飞机y轴坐标
            UpSpeed++;//上升速度逐渐减少，直到为0
        }
        else//飞机下坠
        {
            Speed = 0;
            Speed += gravity;//重力加速度
            pos.setY(pos.y()+(Speed));
        }
    }
}</code></pre> 
<p>②管道：</p> 
<p>        管道类，分为上下管道，提前刷新出新的管道并向左移动，营造飞机向前飞行的错觉，包含运动和撞飞机两个状态，同样，启用定时器，用绘图事件不断绘制管道位置。</p> 
<pre><code class="language-cpp">Pipe::Pipe(QObject *parent) : QObject(parent)
{
    texture_up[0].load(":/image/pipe_up.png");
    texture_up[1].load(":/image/pipe_up.png");
    texture_down[0].load(":/image/pipe_down.png");
    texture_down[1].load(":/image/pipe_down.png");
    //style = 0;
    init();
    //关联定时器，提前刷新出新的管道
    connect(&amp;timer_action, &amp;QTimer::timeout, [=]()
    {
        for(int i = 0;i&lt;3;i++)
        {
            pos[i].setX(pos[i].x()-1);
            if(pos[i].x()+PIPE_WIDTH&lt;0)
            {
                pos[i].setX(last-&gt;x()+PIPE_WIDTH+PIPES_WIDTH_SPACE);
                pos[i].setY(getRandom(100-PIPE_HEIGHT, WINDOW_HEIGHT-100-PIPES_HEIGHT_SPACE-PIPE_HEIGHT-CLOUD_HEIGHT));
                last = &amp;pos[i];
            }
        }
    });
}

void Pipe::run()
{
    timer_action.start(10);//开启运动状态
}

void Pipe::stop()
{
    timer_action.stop();//停止状态
}

void Pipe::draw(QPainter &amp;painter)//绘制管道位置，不断向左移动
{
    for(int i = 0;i&lt;3;i++)
    {
        painter.drawPixmap(pos[i].x(), pos[i].y(), PIPE_WIDTH, PIPE_HEIGHT, texture_down[style]);
        painter.drawPixmap(pos[i].x(), pos[i].y()+PIPE_HEIGHT+PIPES_HEIGHT_SPACE, PIPE_WIDTH, PIPE_HEIGHT, texture_up[style]);
    }
}

void Pipe::init()//初始化管道位置
{
    stop();
    for(int i = 0;i&lt;3;i++)
    {
        pos[i].setX(WINDOW_WIDTH+i*(PIPE_WIDTH+PIPES_WIDTH_SPACE));
        pos[i].setY(getRandom(100-PIPE_HEIGHT, WINDOW_HEIGHT-100-PIPES_HEIGHT_SPACE-PIPE_HEIGHT-CLOUD_HEIGHT));
    }
    last = &amp;pos[2];
}

int Pipe::getRandom(int min, int max)//随机函数
{
    static QTime t = QTime::currentTime();
    static int n = 0;
    QTime T = QTime::currentTime();
    int i = T.msecsTo(t);
    qsrand(i+(n+=20));
    if(n&gt;100) n = 0;
    int num = -(qrand()%(-min));
    if(num &gt; max) return getRandom(min, max);
    else return num;
}

bool Pipe::Test(Plane &amp;plane)//监测飞机与管道位置是否重合
{
    int plane_x = plane.getPos().x();
    int plane_y = plane.getPos().y();

    for(int i = 0;i&lt;3;i++)
    {
        int pipe_x = pos[i].x();
        int pipe_y = pos[i].y();
        if(plane_x+PLANE_WIDTH&gt;pipe_x &amp;&amp; plane_x&lt;pipe_x+PIPE_WIDTH &amp;&amp;
          (plane_y&lt;pipe_y+PIPE_HEIGHT || plane_y+PLANE_HEIGHT&gt;pipe_y+PIPE_HEIGHT+PIPES_HEIGHT_SPACE))
        {
            return false;
        }
    }
    return true;
}
</code></pre> 
<p>③游玩状态：</p> 
<p>        在游玩界面中创建飞机对象、管道对象，游戏开始后，使飞机、管道处于运动状态，并且通过定时器不断调用飞机和管道中的绘图事件，刷新位置。</p> 
<h3>3.其他</h3> 
<p>        点击按钮实现界面跳转：在跳转时new出新界面并show出来，当前界面close掉；计分系统：可以判断飞机飞过管道没有撞机则积一分，我图省事直接通过时间来积分了；可扩展的附加功能：添加设置按钮更改飞行速度、排行榜功能记录历史积分；</p> 
<p>        注意：最后可以将项目打包为一个exe可执行文件，方便传输</p> 
<hr> 
<h2>资源文件</h2> 
<p>https://pan.baidu.com/s/1yTYOQ39V11wd8J5C62zIOg?pwd=7b72 <br> 提取码:7b72</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/64ff69c1599aa33f3eb154da8d646f7f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">面向BEV感知的4D标注方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e5897018be9ca179bed6d433ad44e69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java基础篇 Java 反射机制详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>