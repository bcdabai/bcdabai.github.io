<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>-栈的应用- - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="-栈的应用-" />
<meta property="og:description" content="计算机是如何执行递归函数的呢? 答案是使用递归工作栈(recursion stack)。 当一个函数被调用时，一个返回地址( 即被调函数一旦执行完，接下去要执行的程序指令的地址)和被调函数的局部变量和形参的值都要存储在递归工作栈中。当执行一次返回时，被调函数的局部变量和形参的值被恢复为调用之前的值(这些值存储在递归工作栈的顶部)，而且程序从返回地址处继续执行，这个返回地址也存储在递归工作栈的顶部。 如果把数组线性表的右端定义为栈顶，那么入栈和出栈操作对应的就是线性表在最好情况下的插入和删除操作。结果两个操作的时间都为O(1)。 用链表的左端作为栈顶，需要调用的链表方法是get(0)、insert(0,theElement) 和erase(0)，其中每一个链表方法需要用时0(1)。分析表明，我们应该选择链表的左端作为栈顶。 括号匹配 通过观察可以发现，如果从左至右地扫描一个字符串，那么每一个右括号都与最近扫描的那个未匹配的左括号相匹配。这种观察结果促使我们在从左至右的扫描过程中，将扫描到的左括号保存到栈中。每当扫描都一个右括号，就将它与栈顶的左括号(如果存在)相匹配，并将匹配的左括号从栈顶删除。 void printMatchedPairs(string expr) { //括号匹配 arrayStack&lt;int&gt; s; int length = (int) expr.size() ; //扫描表达式expr寻找左括号和右括号 for (int i = 0; i &lt; length; i&#43;&#43;) { if (expr.at(i) == &#39;(&#39;) s.push(i); else if (expr.at(i) == &#39;)&#39;) { try {//从栈中删除匹配的左括号 cout &lt;&lt; s.top() &lt;&lt; &#39; &#39; &lt;&lt; i &lt;&lt; endl; s.pop() ; } //没有栈匹配 catch (stackEmpty) {//栈为空。没有匹配的左括号 cout &lt;&lt; &#34;No match for right parenthesis&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/33f9df363ff8999073bfb764b650fb88/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-25T15:24:55+08:00" />
<meta property="article:modified_time" content="2022-05-25T15:24:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">-栈的应用-</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_recursion_stack_0"></a>计算机是如何执行递归函数的呢? 答案是使用递归工作栈(recursion stack)。</h2> 
<ul><li>当一个函数被调用时，一个<strong>返回地址</strong>( 即被调函数一旦执行完，接下去要执行的程序指令的地址)和被调函数的<strong>局部变量和形参的</strong>值都要存储在递归工作栈中。<strong>当执行一次返回时，被调函数的局部变量和形参的值被恢复为调用之前的值</strong>(这些值存储在递归工作栈的顶部)，而且程序从返回地址处继续执行，这个返回地址也存储在递归工作栈的顶部。</li></ul> 
<h6><a id="O1_2"></a>如果把数组线性表的右端定义为栈顶，那么入栈和出栈操作对应的就是线性表在最好情况下的插入和删除操作。结果两个操作的时间都为O(1)。</h6> 
<h6><a id="get0insert0theElement_erase001_3"></a>用链表的左端作为栈顶，需要调用的链表方法是get(0)、insert(0,theElement) 和erase(0)，其中每一个链表方法需要用时0(1)。分析表明，我们应该选择链表的左端作为栈顶。</h6> 
<h2><a id="_4"></a>括号匹配</h2> 
<ul><li>通过观察可以发现，如果从左至右地扫描一个字符串，那么每一个右括号都与最近扫描的那个未匹配的左括号相匹配。</li><li>这种观察结果促使我们在从左至右的扫描过程中，将扫描到的左括号保存到栈中。每当扫描都一个右括号，就将它与栈顶的左括号(如果存在)相匹配，并将匹配的左括号从栈顶删除。</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">printMatchedPairs</span><span class="token punctuation">(</span>string expr<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//括号匹配</span>
	arrayStack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> s<span class="token punctuation">;</span>
	<span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> expr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
	<span class="token comment">//扫描表达式expr寻找左括号和右括号</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>expr<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span>
			s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>expr<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">try</span>
			<span class="token punctuation">{<!-- --></span><span class="token comment">//从栈中删除匹配的左括号</span>
				cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
				<span class="token comment">//没有栈匹配</span>
			<span class="token keyword">catch</span> <span class="token punctuation">(</span>stackEmpty<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span><span class="token comment">//栈为空。没有匹配的左括号</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"No match for right parenthesis"</span><span class="token operator">&lt;&lt;</span> <span class="token string">"at"</span><span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token comment">//栈不为空。剩余在栈中的左括号是不匹配的</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> "No match <span class="token keyword">for</span> left parenthesis at”<span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_42"></a>使用栈求解汉诺塔问题</h2> 
<pre><code class="prism language-cpp"><span class="token comment">//全局变量，tower[1:3] 表示三个塔</span>
arrayStack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> tower<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">moveAndShow</span><span class="token punctuation">(</span><span class="token keyword">int</span>，<span class="token keyword">int</span>， <span class="token keyword">int</span>， <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">towersOfHanoi</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token comment">//函数moveAndShow的预处理程序</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token operator">=</span>n<span class="token punctuation">;</span>d<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>d<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token comment">//初始化</span>
		tower<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把碟子d加到塔1</span>
	<span class="token comment">//把n个碟子从塔1移到塔3，用塔2作为中转站</span>
	<span class="token function">moveAndShow</span><span class="token punctuation">(</span>n，<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span>，<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">moveAndShow</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> X，<span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token comment">//把塔x顶部的n个碟子移到塔y，显示移动后的布局</span>
	<span class="token comment">//用塔z作为中转站</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">moveAndshow</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> X，Z，y<span class="token punctuation">)</span> <span class="token punctuation">;</span>
		<span class="token keyword">int</span> d <span class="token operator">=</span> tower<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">//把一个碟子:</span>
		tower<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">//从塔x的顶部移到</span>
		tower<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">//塔y的顶部</span>
		<span class="token function">showState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
		<span class="token comment">//显示塔3的布局</span>
		<span class="token function">moveAndShow</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> Z<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_70"></a>列车车厢重排</h2> 
<p><img src="https://images2.imgbox.com/b9/8a/tIi2O2Mh_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4b/38/uvikLnYh_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_73"></a>开关盒布线</h2> 
<ul><li>每对要连接的管脚称为一个<strong>网组</strong>。对于给定的一些网组，我们需要确定，它们能否连接而又不发生交叉。</li><li>图8-8a是一个布线的示例，其中有8个管脚和4个网组。四个网组分别是(1，4)，(2，3), (5, 6)和(7, 8)。图8-8b的布线在网组( 1, 4)和(2, 3)之间有交叉，而图8-8c的布线没有交叉。因为这4个网组的布线可以没有交叉，所以这个开关盒称为可布线开关盒( routable switch box)。<br> <img src="https://images2.imgbox.com/17/a3/3QA9NmXI_o.png" alt="在这里插入图片描述"></li><li>如果从管脚1开始沿顺时针方向遍历图8-8a的管脚，那么遍历的管脚顺序是1, 2，.，8。管脚1和4是一个网组，于是管脚1至4之间出现的所有管脚构成第一个分区，管脚4至1之间出现的所有管脚构成另一个分区。</li><li>把管脚1插入栈，然后继续处理，直到管脚4。这个过程使我们仅在处理完一个分区之后才能进入下一个分区。 下一个是管脚2，它与管脚3是一个网组，它们把当前分区分成两个分区。与前面的做法一样，把管脚2插入栈，然后继续处理，直到管脚3。由于管脚3和管脚2是一个网组，而管脚2正处在栈顶， 可将管脚2从栈顶删除。接下来将遇到管脚4，可从栈顶删除管脚1。</li><li>按照这种方法继续下去，我们可以完成对所有分区的处理，而且当8个管脚都检查之后，栈为空。</li><li>所以程序的输入数组为：[1,2,2,1,3,3,4,4] -&gt; 对于索引为：[1,2,3,4,5,6,7,8]</li></ul> 
<h2><a id="_81"></a>迷宫老鼠</h2> 
<ul><li> <p>首先把迷宫的入口作为当前位置。如果当前位置是迷宫出口，那么已经找到了一条路径，寻找工作结束。</p> </li><li> <p>如果当前位置不是迷宫出口，则在<strong>当前位置上放置障碍物</strong>，以阻止寻找过程又绕回到这个位置。然后检查相邻位置是否有空闲(即没有障碍物), 如果有，就移动到一个空闲的相邻位置上，然后从这个位置开始寻找通往出口的路径。如果不成功，就选择另一个空闲的相邻位置, 并从它开始寻找通往出口的路径。</p> </li><li> <p>为了方便移动，在进入新的相邻位置之前，<strong>把当前位置保存在一个栈中</strong>。如果所有空闲的相邻位置都已经被探索过，但还未能找到路径，则表明迷宫不存在从入口到出口的路径。<br> <img src="https://images2.imgbox.com/83/f0/RIM3xVVS_o.png" alt="在这里插入图片描述"></p> </li><li> <p>我们需要把迷宫(一个0和1的矩阵)、迷宫的每个位置以及栈都表示出来。</p> </li><li> <p>迷宫一般被描述成一个int类型的二维数组maze。(由于每个数组的位置仅有0或1两种取值，因此可以用bool型二维数组，true 代表1, false代表0。 这样,表示迷宫的数组空间就被减少了。)迷宫矩阵的位置(i, j)对应于数组maze的位置[i] [j]。</p> </li><li> <p>现在，迷宫的所有位置都处在一圈障碍物所围成的边界之内，从迷宫的每个位置开始，都有4种可能的移动方向(可能每个方向都有障碍物)。因为给迷宫围上了一圈障碍物，所以程序不再需要处理边界条件。</p> </li><li> <p>可以定义一个带有数据成员row和col的类position,使用它的对象来跟踪记录迷宫位置。用数组表示栈，栈用来保存从入口到当前位置的路径。一个没有障碍物的m*m迷宫，最长的路径可包含m^2个位置。<br> <img src="https://images2.imgbox.com/42/9d/nct3j7fs_o.png" alt="在这里插入图片描述"></p> </li><li> <p>计算这些坐标。把向右、向下、向左和向上移动分别表示为0、1、2和3。在图8-18的表中, offset[i].row 和 offset[j].col 分别是从当前位置沿方向i移动到下一个相邻位置时，row 和col坐标的增量。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42a7a5d4776dcfe9c1208c1a60f38be5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构——跳表和散列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a37cd5ffdbd8d38874b34f8d2f35e3e1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数组和矩阵</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>