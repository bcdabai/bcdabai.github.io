<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>微信小程序 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="微信小程序" />
<meta property="og:description" content="微信小程序 框架（MINA） 小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生APP体验的服务。
框架提供了自己的视图层描述语言WXML和WXSS，以及基于JavaScript的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。
主体文件
在每个小程序框架中最关键也是必不可少的文件就是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。
app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。
//app.js App({ onLaunch: function () { //调用API从本地缓存中获取数据 var logs = wx.getStorageSync(&#39;logs&#39;) || [] logs.unshift(Date.now()) wx.setStorageSync(&#39;logs&#39;, logs) }, getUserInfo:function(cb){ var that = this; if(this.globalData.userInfo){ typeof cb == &#34;function&#34; &amp;&amp; cb(this.globalData.userInfo) }else{ //调用登录接口 wx.login({ success: function () { wx.getUserInfo({ success: function (res) { that.globalData.userInfo = res.userInfo; typeof cb == &#34;function&#34; &amp;&amp; cb(that.globalData.userInfo) } }) } }); } }, globalData:{ userInfo:null } }) app." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/439845b85c0a405cebc2e738b0786f15/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-01-14T15:41:03+08:00" />
<meta property="article:modified_time" content="2020-01-14T15:41:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">微信小程序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <h4>微信小程序 框架（MINA）</h4> 
</blockquote> 
<p>小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生APP体验的服务。</p> 
<p>框架提供了自己的视图层描述语言WXML和WXSS，以及基于JavaScript的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。</p> 
<p><strong>主体文件</strong></p> 
<p>在每个小程序框架中最关键也是必不可少的文件就是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。</p> 
<p>app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。</p> 
<pre class="has"><code class="language-javascript">//app.js
App({
  onLaunch: function () {
    //调用API从本地缓存中获取数据
    var logs = wx.getStorageSync('logs') || []
    logs.unshift(Date.now())
    wx.setStorageSync('logs', logs)
  },
  getUserInfo:function(cb){
    var that = this;
    if(this.globalData.userInfo){
      typeof cb == "function" &amp;&amp; cb(this.globalData.userInfo)
    }else{
      //调用登录接口
      wx.login({
        success: function () {
          wx.getUserInfo({
            success: function (res) {
              that.globalData.userInfo = res.userInfo;
              typeof cb == "function" &amp;&amp; cb(that.globalData.userInfo)
            }
          })
        }
      });
    }
  },
  globalData:{
    userInfo:null
  }
})</code></pre> 
<p>app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。</p> 
<p>app.json 配置项列表</p> 
<p> </p> 
<table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>描述</th></tr></thead><tbody><tr><td>pages</td><td>String Array</td><td>是</td><td>设置页面路径</td></tr><tr><td>window</td><td>Object</td><td>否</td><td>设置默认页面的窗口表现</td></tr><tr><td>tabBar</td><td>Object</td><td>否</td><td>设置底部 tab 的表现</td></tr><tr><td>networkTimeout</td><td>Object</td><td>否</td><td>设置网络超时时间</td></tr><tr><td>debug</td><td>Boolean</td><td>否</td><td>设置是否开启 debug 模式</td></tr></tbody></table> 
<p>以下是一个包含了所有配置选项的简单配置app.json ：</p> 
<pre class="has"><code class="language-javascript">{
  "pages": [
    "pages/index/index",
    "pages/logs/index"
  ],  
"window": {
    "navigationBarTitleText": "Demo"
  },
  "tabBar": {
    "list": [{
      "pagePath": "pages/index/index",
      "text": "首页"
    }, {
      "pagePath": "pages/logs/logs",
      "text": "日志"
    }]
  },
  "networkTimeout": {
    "request": 10000,
    "downloadFile": 10000
  },
  "debug": true
}</code></pre> 
<p>app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。</p> 
<pre class="has"><code class="language-css">/**app.wxss**/
.container {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 200rpx 0;
  box-sizing: border-box;
}</code></pre> 
<p><strong>响应式的数据绑定</strong></p> 
<p>框架的核心是一个响应的数据绑定系统。</p> 
<p>整个系统分为两块视图层(View)和逻辑层(App Service)。</p> 
<p>框架可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。</p> 
<p> </p> 
<blockquote> 
 <h4>MINA 文件结构</h4> 
</blockquote> 
<p>MINA程序包含一个描述整体程序的app和多个描述各自页面的page。一个MINA程序主体部分由三个文件组成，必须放在项目的根目录，如下：</p> 
<table><thead><tr><th>文件</th><th>必需</th><th>作用</th></tr></thead><tbody><tr><td>app.js</td><td>是</td><td>小程序逻辑</td></tr><tr><td>app.json</td><td>是</td><td>小程序公共设置</td></tr><tr><td>app.wxss</td><td>否</td><td>小程序公共样式表</td></tr></tbody></table> 
<p>一个MINA页面由四个文件组成，分别是：</p> 
<table><thead><tr><th>文件类型</th><th>必须</th><th>作用</th></tr></thead><tbody><tr><td>wxml</td><td>是</td><td>页面结构</td></tr><tr><td>wxss</td><td>否</td><td>页面样式表</td></tr><tr><td>json</td><td>否</td><td>页面配置</td></tr><tr><td>js</td><td>是</td><td>页面逻辑</td></tr></tbody></table> 
<p> </p> 
<blockquote> 
 <h4>逻辑层(App Service)</h4> 
</blockquote> 
<p>小程序开发框架的逻辑层是由JavaScript编写。逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</p> 
<hr> 
<p><strong>注册程序 App()函数</strong></p> 
<p>App()函数用来注册一个小程序。接受一个object参数，其指定小程序的生命周期函数等。</p> 
<p>object参数说明：</p> 
<table><thead><tr><th>属性</th><th>类型</th><th>描述</th><th>触发时机</th></tr></thead><tbody><tr><td>onLaunch</td><td>Function</td><td>生命周期函数--监听小程序初始化</td><td>当小程序初始化完成时，会触发 onLaunch（全局只触发一次）</td></tr><tr><td>onShow</td><td>Function</td><td>生命周期函数--监听小程序显示</td><td>当小程序启动，或从后台运行进入前台显示，会触发 onShow</td></tr><tr><td>onHide</td><td>Function</td><td>生命周期函数--监听小程序隐藏</td><td>当小程序从前台进入后台，会触发 onHide</td></tr><tr><td>onError</td><td>Function</td><td>错误监听函数</td><td>当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息</td></tr><tr><td>onPageNotFound</td><td>Function</td><td>页面不存在监听函数</td><td>当小程序出现要打开的页面不存在的情况，会带上页面信息回调该函数，详见下文</td></tr><tr><td>其他</td><td>Any</td><td> </td><td>开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问</td></tr></tbody></table> 
<p><strong>示例代码：</strong></p> 
<pre class="has"><code class="language-javascript">App({
  onLaunch: function(options) { 
    // Do something initial when launch.
  },
  onShow: function(options) {
      // Do something when show.
  },
  onHide: function() {
      // Do something when hide.
  },
  onError: function(msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})</code></pre> 
<p id="getApp()"><strong>getApp()</strong></p> 
<p>我们提供了全局的<code>getApp()</code>函数，可以获取到小程序实例。</p> 
<pre class="has"><code>// other.js
var appInstance = getApp()
console.log(appInstance.globalData) // I am global data</code></pre> 
<p><strong>注意：</strong></p> 
<p>App() 必须在app.js中注册，且不能注册多个。</p> 
<p>不要在定义于App() 内的函数中调用getApp() ，使用this就可以拿到app实例。</p> 
<p>不要在onLaunch的时候调用getCurrentPage()，此时page还没有生成。</p> 
<p>getApp()通过获取实例之后，不要私自调用生命周期函数。</p> 
<hr> 
<p><strong>注册页面 Page()函数</strong></p> 
<p>Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。</p> 
<p><strong>示例代码：</strong></p> 
<pre class="has"><code class="language-javascript">//index.js
Page({
  data: { // 页面的初始数据
    text: 'init data',
    array: [{msg: '1'}, {msg: '2'}]
  },
  // 生命周期函数
  onLoad: function(options) { // 生命周期函数--监听页面加载
    // 一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。
  },
  onReady: function() { // 生命周期函数--监听页面初次渲染完成
    // 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。
  },
  onShow: function() { // 生命周期函数--监听页面显示
    // 每次打开页面都会调用一次。
  },
  onHide: function() { // 生命周期函数--监听页面隐藏
    // 当navigateTo或底部tab切换时调用。
  },
  onUnload: function() { // 生命周期函数--监听页面卸载
    // 当redirectTo或navigateBack的时候调用。
  },
  // 页面相关事件处理函数
  onPullDownRefresh: function() { // 监听用户下拉动作
    // 监听用户下拉刷新事件。
    // 需要在config的window选项中开启enablePullDownRefresh。
    // 当处理完数据刷新后，wx.stopPullDownRefresh可以停止当前页面的下拉刷新。
  },
  onReachBottom: function() { // 页面上拉触底事件的处理函数
    // 监听用户下拉触底事件。
  },
  onPageScroll: function() { // 页面滚动触发事件的处理函数
    // 监听用户滑动页面事件。
  },
  onShareAppMessage: function () { // 用户点击右上角转发
   // 只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮。
   // 用户点击转发按钮的时候会调用。
   // 此事件需要 return 一个 Object，用于自定义转发内容。
   return {
      title: '自定义转发标题',
      path: '/page/user?id=123'
    } 
  },
  // 事件处理函数。
  // 在渲染层可以在组件中加入事件绑定，当达到触发事件时，就会执行 Page 中定义的事件处理函数。
  viewTap: function() {
    this.setData({
      text: 'Set some data for updating view.'
    })
  }
})</code></pre> 
<p id="pageprototyperoute"><strong>Page.prototype.route</strong></p> 
<p>route 字段可以获取到当前页面的路径。</p> 
<p id="pageprototypesetdata"><strong>Page.prototype.setData()</strong></p> 
<p>setData 函数用于将数据从逻辑层发送到视图层，同时改变对应的 this.data 的值。</p> 
<p> </p> 
<blockquote> 
 <h4>微信小程序 模块化</h4> 
</blockquote> 
<p id="文件作用域"><strong>文件作用域</strong></p> 
<p>在JavaScript文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。<br> 通过全局函数getApp()可以获取全局的应用实例，如果需要全局的数据可以在App()中设置，如：</p> 
<pre class="has"><code class="language-javascript">// app.js
App({
  globalData: 1
})</code></pre> 
<pre class="has"><code class="language-javascript">// b.jsa.js.
var localValue = 'b'
console.log(getApp().globalData)</code></pre> 
<p id="模块化"><strong>模块化</strong></p> 
<p>exports是module.exports的一个引用，因此在模块里边随意更改exports的指向会造成未知的错误。所以我们更推荐开发者采用module.exports来暴露模块接口，除非你已经清晰知道这两者的关系。</p> 
<pre class="has"><code class="language-javascript">// common.js
function sayHello(name) {
  console.log('Hello ${name} !')
}
function sayGoodbye(name) {
  console.log('Goodbye ${name} !')
}
module.exports.sayHello = sayHello
exports.sayGoodbye = sayGoodbye</code></pre> 
<p>在需要使用这些模块的文件中，使用require(path)将公共代码引入（require暂时不支持绝对路径）。</p> 
<pre class="has"><code class="language-javascript">var common = require('common.js')
Page({
  helloMINA: function() {
    common.sayHello('MINA')
  }
  goodbyeMINA: function() {
    common.sayGoodbye('MINA')
  }
})</code></pre> 
<p> </p> 
<blockquote> 
 <h4>视图层(View) - WXML</h4> 
</blockquote> 
<p>MINA的视图层由WXML与WXSS编写。</p> 
<p>将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。</p> 
<p>WXML(WeiXin Markup language)用于描述页面的结构。</p> 
<p>WXSS(WeiXin Style Sheet)用于描述页面的样式。</p> 
<p>组件(Component)是视图的基本组成单元。</p> 
<p id="wxml"><strong>WXML</strong></p> 
<p>WXML(WeiXin Markup Language)是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。</p> 
<h4> </h4> 
<h4><strong>数据绑定</strong></h4> 
<p>WXML中的动态数据均来自对应Page的data。</p> 
<p id="内容"><strong>内容</strong></p> 
<pre class="has"><code class="language-html">&lt;view&gt; {<!-- -->{ message }} &lt;/view&gt;</code></pre> 
<pre class="has"><code class="language-javascript">Page({
  data: {
    message: 'Hello MINA!'
  }
})</code></pre> 
<p id="组件属性需要在双引号之内"><strong>组件属性(需要在双引号之内)</strong></p> 
<pre class="has"><code class="language-html">&lt;view id="item-{<!-- -->{id}}"&gt; &lt;/view&gt;</code></pre> 
<pre class="has"><code class="language-javascript">Page({
  data: {
    id: 0
  }
})</code></pre> 
<p id="控制属性需要在双引号之内"><strong>控制属性(需要在双引号之内)</strong></p> 
<pre class="has"><code class="language-html">&lt;view wx:if="{<!-- -->{condition}}"&gt; &lt;/view&gt;</code></pre> 
<pre class="has"><code class="language-javascript">Page({
  data: {
    condition: true
  }
})</code></pre> 
<p><strong>关键字(需要在双引号之内)</strong></p> 
<pre class="has"><code class="language-html">&lt;checkbox checked="{<!-- -->{false}}"&gt; &lt;/checkbox&gt;</code></pre> 
<p>特别注意：不要直接写 checked="false"，其计算结果是一个字符串，转成 boolean 类型后代表真值。</p> 
<p id="运算"><strong>运算</strong></p> 
<p>可以在 {<!-- -->{}} 内进行简单的运算，支持的有如下几种方式：</p> 
<p id="三元运算">三元运算：</p> 
<pre class="has"><code class="language-html">&lt;view hidden="{<!-- -->{flag ? true : false}}"&gt; Hidden &lt;/view&gt;</code></pre> 
<p id="算数运算">算数运算：</p> 
<pre class="has"><code class="language-html">&lt;view&gt; {<!-- -->{a + b}} + {<!-- -->{c}} + d &lt;/view&gt;</code></pre> 
<p>数据路径运算：</p> 
<pre class="has"><code class="language-html">&lt;view&gt;{<!-- -->{object.key}} {<!-- -->{array[0]}}&lt;/view&gt;</code></pre> 
<h4> </h4> 
<h4><strong>列表渲染 wx:for</strong></h4> 
<p>在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。<br> 默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item。<br> 使用 wx:for-item 可以指定数组当前元素的变量名。<br> 使用 wx:for-index 可以指定数组当前下标的变量名。</p> 
<pre class="has"><code class="language-html">&lt;view wx:for="{<!-- -->{array}}" wx:for-index="idx" wx:for-item="itemName" wx:key="unique"&gt;
  {<!-- -->{idx}}: {<!-- -->{itemName.message}}
&lt;/view&gt;</code></pre> 
<p id="wxkey"><strong>wx:key</strong></p> 
<p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 &lt;input/&gt; 中的输入内容，&lt;switch/&gt; 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p> 
<p><strong>注意：</strong></p> 
<p>当 wx:for 的值为字符串时，会将字符串解析成字符串数组</p> 
<pre class="has"><code class="language-html">&lt;view wx:for="array"&gt;
  {<!-- -->{item}}
&lt;/view&gt;</code></pre> 
<p>等同于</p> 
<pre class="has"><code class="language-html">&lt;view wx:for="{<!-- -->{['a','r','r','a','y']}}"&gt;
  {<!-- -->{item}}
&lt;/view&gt;</code></pre> 
<p> </p> 
<h4>条件渲染 wx:if</h4> 
<p>在框架中，我们用wx:if="{<!-- -->{condition}}"来判断是否需要渲染该代码块，也可以用wx:elif和wx:else来添加一个else块：</p> 
<pre class="has"><code class="language-html">&lt;view wx:if="{<!-- -->{length &gt; 5}}"&gt; 1 &lt;/view&gt;
&lt;view wx:elif="{<!-- -->{length &gt; 2}}"&gt; 2 &lt;/view&gt;
&lt;view wx:else&gt; 3 &lt;/view&gt;</code></pre> 
<p> </p> 
<h4>模板(template)</h4> 
<p>WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。</p> 
<p id="定义模板"><strong>定义模板</strong></p> 
<p>使用name属性，作为模板的名字。然后在<code>&lt;template/&gt;</code>内定义代码片段，如：</p> 
<pre class="has"><code class="language-html">&lt;template name="msgItem"&gt;
  &lt;view&gt;
    &lt;text&gt; {<!-- -->{index}}: {<!-- -->{msg}} &lt;/text&gt;
    &lt;text&gt; Time: {<!-- -->{time}} &lt;/text&gt;
  &lt;/view&gt;
&lt;/template&gt;</code></pre> 
<p id="使用模板"><strong>使用模板</strong></p> 
<p>使用is属性，声明需要的使用的模板，然后将模板所需要的data传入，如：</p> 
<pre class="has"><code class="language-html">&lt;template is="msgItem" data="{<!-- -->{...item}}"/&gt;</code></pre> 
<p>is 属性可以使用 Mustache 语法，来动态决定具体需要渲染哪个模板：</p> 
<pre class="has"><code class="language-html">&lt;template name="odd"&gt;
  &lt;view&gt; odd &lt;/view&gt;
&lt;/template&gt;
&lt;template name="even"&gt;
  &lt;view&gt; even &lt;/view&gt;
&lt;/template&gt;

&lt;block wx:for="{<!-- -->{[1, 2, 3, 4, 5]}}"&gt;
    &lt;template is="{<!-- -->{item % 2 == 0 ? 'even' : 'odd'}}"/&gt;
&lt;/block&gt;</code></pre> 
<p id="模板的作用域"><strong>模板的作用域</strong></p> 
<p>模板拥有自己的作用域，只能使用data传入的数据。</p> 
<p> </p> 
<h4>事件</h4> 
<p>事件是视图层到逻辑层的通讯方式。</p> 
<p>事件可以将用户的行为反馈到逻辑层进行处理。</p> 
<p>事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。</p> 
<p>事件对象可以携带额外信息，如id, dataset, touches。</p> 
<p id="事件的使用方式"><strong>事件的使用方式</strong></p> 
<ul><li>在组件中绑定一个事件处理函数。</li></ul> 
<p>如 bindtap，当用户点击该组件的时候会在该页面对应的Page中找到相应的事件处理函数。</p> 
<pre class="has"><code class="language-html">&lt;view id="tapTest" data-hi="WeChat" bindtap="tapName"&gt; Click me! &lt;/view&gt;</code></pre> 
<ul><li>在相应的Page定义中写上相应的事件处理函数，参数是event。</li></ul> 
<pre class="has"><code class="language-javascript">Page({
  tapName: function(event) {
    console.log(event)
  }
})</code></pre> 
<p id="事件分类"><strong>事件分类</strong></p> 
<p>事件分为冒泡事件和非冒泡事件</p> 
<ol><li>冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。</li><li>非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。</li></ol> 
<p>WXML的冒泡事件列表：</p> 
<table><thead><tr><th>类型</th><th>触发条件</th></tr></thead><tbody><tr><td>touchstart</td><td>手指触摸动作开始</td></tr><tr><td>touchmove</td><td>手指触摸后移动</td></tr><tr><td>touchcancel</td><td>手指触摸动作被打断，如来电提醒，弹窗</td></tr><tr><td>touchend</td><td>手指触摸动作结束</td></tr><tr><td>tap</td><td>手指触摸后马上离开</td></tr><tr><td>longtap</td><td>手指触摸后，超过350ms再离开</td></tr></tbody></table> 
<p id="事件绑定"><strong>事件绑定</strong></p> 
<p>事件绑定的写法同组件的属性，以key、value的形式。</p> 
<p>key以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstart。</p> 
<p>value是一个字符串，需要在对应的Page中定义同名的函数。不然当触发事件的时候会报错。</p> 
<p>bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。</p> 
<pre class="has"><code class="language-html">&lt;view id="outter" bindtap="handleTap1"&gt;
  outer view
  &lt;view id="middle" catchtap="handleTap2"&gt;
    middle view
    &lt;view id="inner" bindtap="handleTap3"&gt;
      inner view
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;</code></pre> 
<p id="事件对象"><strong>事件对象</strong></p> 
<p>如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。</p> 
<pre class="has"><code class="language-javascript">function(e){
   console.log(e.target);
   console.log(e.detail);
}</code></pre> 
<p><strong>BaseEvent基础事件对象属性列表：</strong></p> 
<table><thead><tr><th style="width:174.5px;">属性</th><th style="width:118px;">类型</th><th style="width:557px;">说明</th></tr></thead><tbody><tr><td style="width:174.5px;">type</td><td style="width:118px;">String</td><td style="width:557px;">事件类型</td></tr><tr><td style="width:174.5px;">timeStamp</td><td style="width:118px;">Integer</td><td style="width:557px;">该页面打开到触发事件所经过的毫秒数。</td></tr><tr><td style="width:174.5px;">target</td><td style="width:118px;">Object</td><td style="width:557px;">触发事件的根源组件的一些属性值集合，包括触发事件组件的id，类型，以及dataset自定义属性的集合</td></tr><tr><td style="width:174.5px;">currentTarget</td><td style="width:118px;">Object</td><td style="width:557px;">触发事件的当前组件，触发当前事件组件的id，类型，以及dataset自定义属性的集合</td></tr></tbody></table> 
<p><strong>CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：</strong></p> 
<table><thead><tr><th style="width:96px;">属性</th><th style="width:101px;">类型</th><th>说明</th></tr></thead><tbody><tr><td style="width:96px;">detail</td><td style="width:101px;">Object</td><td>自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息</td></tr></tbody></table> 
<p><strong>target</strong></p> 
<p>触发事件的源组件。</p> 
<table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>String</td><td>事件源组件的id</td></tr><tr><td>tagName</td><td>String</td><td>当前组件的类型</td></tr><tr><td>dataset</td><td>Object</td><td>事件源组件上由data-开头的自定义属性组成的集合</td></tr></tbody></table> 
<p id="currenttarget"><strong>currentTarget</strong></p> 
<p>事件绑定的当前组件。</p> 
<table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>String</td><td>当前组件的id</td></tr><tr><td>tagName</td><td>String</td><td>当前组件的类型</td></tr><tr><td>dataset</td><td>Object</td><td>当前组件上由data-开头的自定义属性组成的集合</td></tr></tbody></table> 
<p><strong>dataset</strong></p> 
<p>在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。书写方式：以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如 data-element-type，最终在 event.target.dataset 中会将连字符转成驼峰 elementType。</p> 
<p id="detail"> </p> 
<h4>引用</h4> 
<p>WXML提供两种文件引用方式import和include。</p> 
<p id="import"><strong>import</strong></p> 
<p>import可以在该文件中使用目标文件定义的template，如在item.wxml中定义了一个叫item的template：</p> 
<pre class="has"><code class="language-html">&lt;!-- item.wxml --&gt;
&lt;template name="item"&gt;
  &lt;text&gt;{<!-- -->{text}}&lt;/text&gt;
&lt;/template&gt;</code></pre> 
<p>在index.wxml中引用了item.wxml，就可以使用item模板：</p> 
<pre class="has"><code class="language-html">&lt;import src="item.wxml"/&gt;
&lt;template is="item" data="{<!-- -->{text: 'forbar'}}"/&gt;</code></pre> 
<p><strong>import的作用域</strong></p> 
<p>import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。</p> 
<p id="include"><strong>include</strong></p> 
<p>include可以将目标文件除了&lt;template/&gt;的整个代码引入，相当于是拷贝到include位置，如：</p> 
<pre class="has"><code class="language-html">&lt;!-- index.wxml --&gt;
&lt;include src="header.wxml"/&gt;
&lt;view&gt; body &lt;/view&gt;
&lt;include src="footer.wxml"/&gt;</code></pre> 
<p> </p> 
<blockquote> 
 <h4>视图层(View) - WXS</h4> 
</blockquote> 
<p>在微信小程序开发中，是不能直接在wxml中写js代码的，因此就有了wxs。</p> 
<p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。</p> 
<p>WXS 代码可以编写在 wxml 文件中的<strong> </strong>&lt;wxs&gt; 标签内，或以 .wxs 为后缀名的文件内。</p> 
<p><strong>注意：</strong></p> 
<ul><li>&lt;template&gt; 标签中，只能使用定义该 &lt;template&gt; 的 WXML 文件中定义的 &lt;wxs&gt; 模块</li><li>切记wxs里面的变量不要使用let,因为wxs是微信的脚本语言，和js还是有区别的</li></ul> 
<p><strong>模块</strong></p> 
<p>每一个 <strong>.</strong>wxs 文件和 &lt;wxs&gt; 标签都是一个单独的模块。</p> 
<p>每个模块都有自己独立的作用域。即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见。</p> 
<p>每个 wxs 模块均有一个内置的 module 对象，通过该属性，可以对外共享本模块的私有变量与函数，这样就可以被别的wxs文件或&lt;wxs&gt;标签引入。</p> 
<p><strong>内嵌wxs脚本：</strong></p> 
<p>wxs代码可编写在wxml文件中，&lt;wxs&gt;&lt;/wxs&gt;标签内，就像JavaScript代码可以编写在html文件中的&lt;script&gt;&lt;/script&gt;标签内一样。</p> 
<p>wxml文件中的每个&lt;wxs&gt;&lt;/wxs&gt;标签，必须提供一个module属性，用来指定当前&lt;wxs&gt;&lt;/wxs&gt;标签的模块名。在单个wxml文件内，建议其值唯一。</p> 
<pre class="has"><code class="language-javascript">&lt;!-- wxml --&gt; 
&lt;wxs module="localFilter"&gt;
  var some_msg = "hello world";
  function fnFirstText(text) {
    if (null != text &amp;&amp; text.length &gt; 1) {
      return text.substring(0, 1);
    } else {
      return text;
    }
  }

  module.exports = {
    msg : some_msg,
    fnFirstText: fnFirstText
  }
&lt;/wxs&gt;</code></pre> 
<p><strong>在wxml中引入内联的wxs脚本： </strong></p> 
<pre class="has"><code class="language-html">&lt;text&gt;{<!-- -->{localFilter.fnFirstText(businessName)}}&lt;/text&gt;
&lt;text&gt;{<!-- -->{localFilter.msg}}&lt;/text&gt;</code></pre> 
<p><strong>外联wxs脚本：</strong></p> 
<p>wxs代码可以编写在以.wxs为后缀的文件内，就像js一样可以编写在.js文件中一样。</p> 
<pre class="has"><code class="language-javascript">// /pages/tools.wxs
var foo = "'hello world' from tools.wxs";
var bar = function (d) {
  return d;
}
module.exports = {
  FOO: foo,
  bar: bar,
};
module.exports.msg = "some msg";</code></pre> 
<p><strong>在wxml中引入外联的wxs脚本： </strong></p> 
<pre class="has"><code class="language-html">&lt;!--wxml--&gt; 
&lt;wxs src="../../filter/filter.wxs" module="tools" /&gt;
&lt;view&gt; {<!-- -->{tools.msg}} &lt;/view&gt;
&lt;view&gt; {<!-- -->{tools.FOO}} &lt;/view&gt; 
&lt;view&gt; {<!-- -->{tools.bar(tools.FOO)}} &lt;/view&gt; </code></pre> 
<p> <strong>require 函数</strong></p> 
<p>在.wxs模块中引用其他 wxs 文件模块，可以使用 require 函数。</p> 
<p>引用的时候，要注意如下几点：</p> 
<ul><li>只能引用 .wxs 文件模块，且必须使用相对路径。</li><li>wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。</li><li>如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。</li></ul> 
<p>示例代码：</p> 
<pre class="has"><code class="language-javascript">// /pages/tools.wxs
var foo = "'hello world' from tools.wxs";
var bar = function (d) {
  return d;
}
module.exports = {
  FOO: foo,
  bar: bar,
};
module.exports.msg = "some msg";</code></pre> 
<pre class="has"><code class="language-javascript">// /pages/logic.wxs
var tools = require("./tools.wxs");

console.log(tools.FOO);
console.log(tools.bar("logic.wxs"));
console.log(tools.msg);</code></pre> 
<p> </p> 
<blockquote> 
 <h4 id="wxss">WXSS</h4> 
</blockquote> 
<p>WXSS(WeiXin Style Sheets)是一套样式语言，用于描述WXML的组件样式。</p> 
<p>WXSS用来决定WXML的组件应该怎么显示。</p> 
<p><strong>样式导入</strong></p> 
<p>使用@import语句可以导入外联样式表，@import跟需要导入的外联样式表的相对路径，用;表示语句结束。</p> 
<p>示例代码：</p> 
<pre class="has"><code class="language-css">/** common.wxss **/
.small-p{
  padding:5px;
}</code></pre> 
<pre class="has"><code class="language-css">/** app.wxss **/
@import "common.wxss";
.middle-p {
  padding:15px;
}</code></pre> 
<p id="内联样式"><strong>内联样式</strong></p> 
<p>框架组件上支持使用style、class属性来控制组件的样式。</p> 
<ul><li>style：静态的样式统一写到class中。style接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进style中，以免影响渲染速度。</li></ul> 
<pre class="has"><code class="language-html">&lt;view style="color:{<!-- -->{color}};" /&gt;</code></pre> 
<ul><li>class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上<code>.</code>，样式类名之间用空格分隔。</li></ul> 
<pre class="has"><code class="language-html">&lt;view class="normal_view" /&gt;</code></pre> 
<p id="全局样式与局部样式"><strong>全局样式与局部样式</strong></p> 
<p>定义在app.wxss中的样式为全局样式，作用于每一个页面。在page的wxss文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖app.wxss中相同的选择器。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f7befc67e4b1ddf3a03d496537760671/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">hybrid</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8fe44435e05547be1e21af26cb5becf0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">polkitd进程解释</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>