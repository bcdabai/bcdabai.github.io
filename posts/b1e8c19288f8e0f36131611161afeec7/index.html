<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Autosar-OS软件概述和配置 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Autosar-OS软件概述和配置" />
<meta property="og:description" content="Autosar OS目录 一、为什么需要OSOS的功能实时操作系统OSEK OS 二、Autosar OSAutosar OS可裁剪类型 三、OS配置OS ApplicationCountersAlarmsTask ManagementResource ManagementISRsScheduleTablesHook 函数和错误处理 一、为什么需要OS 为什么汽车电子ECU需要使用OS(Operation System)呢，它的必要性在哪里？
随着车载系统需求越来越复杂化，需要用到模块化设计方法以及多任务编程思想，为此减少后期软件升级维护成本。采用传统的计数器与状态机来实现简单多个任务的调度，无法满足多个任务之间的状态切换，优先级，现场保护，执行时间控制等各个方面。
此时迫切需要一种机制来替我们完成各个任务之间的调度功能，使得开发人员能够更关注于应用软件的开发，提高软件开发效率，为此OS便应运而生！
OS的功能 ①改变各任务的执行频率；
②改变各任务的执行时间；
③设定各任务的优先级，保证高优先级任务能够及时执行；
④任务调度、切换时的现场保护与恢复；
⑤共享资源的安全访问机制等；
在一个单核系统中，多任务只能并发执行，通过时间片轮转法来切换任务，通过时钟中断或者软中断的方式来触发一次任务的切换，从而打断当前执行任务，调度器抢夺CPU控制器，来进行任务调度并切换至新任务开始执行。
实时操作系统 实时操作系统（RTOS-Real Time Operating System）中实时（Real Time）指的是任务（Task）或者说实现一个功能的线程（Thread）必须在给定的时间(Deadline)内完成。
系统可以大致分为四个部分：硬件（Hardware），操作系统（operating system），应用程序（application programs），使用者（user）。
目前比较流行的实时操作系统包括Linux，黑莓QNX，RTOS（例如uCOS FreeRTOS,以及一些商用的认证SafeRTOS等），AUTOSAR OS(基于OSEK/VDX OS)，RT-Thread，华为的鸿蒙等
提示：FreeRTOS的官网地址：https://www.freertos.org/
OSEK OS OSEK是德文“Offene Systeme und deren Schnittstellen für die Elektronik im Kraftfahrzeug”的缩写，译为汽车电子开放系统及接口。OSEK OS是一个为满足汽车电子可靠性、实时性、成本敏感性等需求而打造的实时单核操作系统(RTAOS)。
类别OSEK OS基本特性①操作系统中任务、资源、服务静态配置；②支持在只读存储器上运行；③应用中的任务具备较好的可移植性；④操作系统所定义的动作可预见且可记录基本服务①任务管理：包括任务激活与终止以及任务的切换；②同步服务：主要通过资源调度和事件控制来实现；③中断服务程序：包括Catogory I与Category II两类中断；④Alarm机制：主要包括相对Alarm与绝对Alarm；⑤ 进程通信：主要用于进程间数据交互；⑥错误处理：支持各类错误的处理 osek已经被iso标准化，ISO17356，有兴趣的可以私聊小编获取。
二、Autosar OS AUTOSAR OS是基于OSEK OS继承发展而来，所以上述的OSEK OS的基本特点在AUTOSAR OS都能够得到满足，所以AUTOSAR OS是向后兼容的，也就意味着在OSEK OS上能够运行的应用程序同样也可以在AUTOSAR OS上运行。
AUTOSAR OS继承OSEK OS，在OSEK OS的基础上又特别明确了一些AUTOSAR OS需要提供的系统服务：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b1e8c19288f8e0f36131611161afeec7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-18T19:26:45+08:00" />
<meta property="article:modified_time" content="2023-09-18T19:26:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Autosar-OS软件概述和配置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Autosar OS目录</h4> 
 <ul><li><a href="#OS_5" rel="nofollow">一、为什么需要OS</a></li><li><ul><li><a href="#OS_12" rel="nofollow">OS的功能</a></li><li><a href="#_21" rel="nofollow">实时操作系统</a></li><li><a href="#OSEK_OS_29" rel="nofollow">OSEK OS</a></li></ul> 
  </li><li><a href="#Autosar_OS_40" rel="nofollow">二、Autosar OS</a></li><li><ul><li><a href="#Autosar_OS_55" rel="nofollow">Autosar OS可裁剪类型</a></li></ul> 
  </li><li><a href="#OS_66" rel="nofollow">三、OS配置</a></li><li><ul><li><a href="#OS_Application_78" rel="nofollow">OS Application</a></li><li><ul><li><a href="#Counters_89" rel="nofollow">Counters</a></li><li><a href="#Alarms_95" rel="nofollow">Alarms</a></li><li><a href="#Task_Management_116" rel="nofollow">Task Management</a></li><li><a href="#Resource_Management_198" rel="nofollow">Resource Management</a></li><li><a href="#ISRs_203" rel="nofollow">ISRs</a></li><li><a href="#ScheduleTables_212" rel="nofollow">ScheduleTables</a></li><li><a href="#Hook__219" rel="nofollow">Hook 函数和错误处理</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="OS_5"></a>一、为什么需要OS</h2> 
<p>为什么汽车电子ECU需要使用OS(Operation System)呢，它的必要性在哪里？</p> 
<p>随着车载系统需求越来越复杂化，需要用到模块化设计方法以及多任务编程思想，为此减少后期软件升级维护成本。采用传统的计数器与状态机来实现简单多个任务的调度，无法满足多个任务之间的状态切换，优先级，现场保护，执行时间控制等各个方面。</p> 
<p>此时迫切需要一种机制来替我们完成各个任务之间的调度功能，使得开发人员能够更关注于应用软件的开发，提高软件开发效率，为此OS便应运而生！</p> 
<h3><a id="OS_12"></a>OS的功能</h3> 
<p>①改变各任务的执行频率；<br> ②改变各任务的执行时间；<br> ③设定各任务的优先级，保证高优先级任务能够及时执行；<br> ④<strong>任务调度</strong>、切换时的现场保护与恢复；<br> ⑤共享资源的安全访问机制等；<br> <img src="https://images2.imgbox.com/bf/7d/10gFpT8H_o.png" alt="调度器"></p> 
<p>在一个单核系统中，多任务只能并发执行，通过时间片轮转法来切换任务，通过时钟中断或者软中断的方式来触发一次任务的切换，从而打断当前执行任务，调度器抢夺CPU控制器，来进行任务调度并切换至新任务开始执行。</p> 
<h3><a id="_21"></a>实时操作系统</h3> 
<p>实时操作系统（RTOS-Real Time Operating System）中实时（Real Time）指的是任务（Task）或者说实现一个功能的线程（Thread）必须在给定的时间(Deadline)内完成。</p> 
<p>系统可以大致分为四个部分：硬件（Hardware），操作系统（operating system），应用程序（application programs），使用者（user）。<br> <img src="https://images2.imgbox.com/e6/e4/Ab0orPmG_o.png" alt="实时操作系统"><br> 目前比较流行的实时操作系统包括Linux，黑莓QNX，RTOS（例如uCOS FreeRTOS,以及一些商用的认证SafeRTOS等），AUTOSAR OS(基于OSEK/VDX OS)，RT-Thread，华为的鸿蒙等<br> <code>提示：FreeRTOS的官网地址：https://www.freertos.org/</code></p> 
<h3><a id="OSEK_OS_29"></a>OSEK OS</h3> 
<p>OSEK是德文“Offene Systeme und deren Schnittstellen für die Elektronik im Kraftfahrzeug”的缩写，译为汽车电子开放系统及接口。OSEK OS是一个为满足汽车电子可靠性、实时性、成本敏感性等需求而打造的实时单核操作系统(RTAOS)。</p> 
<table><thead><tr><th>类别</th><th>OSEK OS</th></tr></thead><tbody><tr><td>基本特性</td><td>①操作系统中任务、资源、服务静态配置；②支持在只读存储器上运行；③应用中的任务具备较好的可移植性；④操作系统所定义的动作可预见且可记录</td></tr><tr><td>基本服务</td><td>①任务管理：包括任务激活与终止以及任务的切换；②同步服务：主要通过资源调度和事件控制来实现；③中断服务程序：包括Catogory I与Category II两类中断；④Alarm机制：主要包括相对Alarm与绝对Alarm；⑤ 进程通信：主要用于进程间数据交互；⑥错误处理：支持各类错误的处理</td></tr></tbody></table> 
<p>osek已经被iso标准化，ISO17356，有兴趣的可以私聊小编获取。</p> 
<hr> 
<h2><a id="Autosar_OS_40"></a>二、Autosar OS</h2> 
<p>AUTOSAR OS是基于OSEK OS继承发展而来，所以上述的OSEK OS的基本特点在AUTOSAR OS都能够得到满足，所以AUTOSAR OS是向后兼容的，也就意味着在OSEK OS上能够运行的应用程序同样也可以在AUTOSAR OS上运行。<br> AUTOSAR OS继承OSEK OS，在OSEK OS的基础上又特别明确了一些AUTOSAR OS需要提供的系统服务：</p> 
<blockquote> 
 <p>基于优先级的调度<br> 中断优先级必定高于task；<br> 通过StartOS（） 与StartOSHook（）来创建启动接口；<br> 通过ShutdownOS() 与ShutdownOSHook来创建关闭接口；</p> 
</blockquote> 
<p>Autosar OS是用于车载MCU的<strong>实时操作系统</strong>，在整个Autosar架构中属于BSW层的System Services中的一个组件。其上至RTE、下至驱动，中间与BSW基础模块进行交互，是整个autosar框架下最重要的组成部分。<br> <img src="https://images2.imgbox.com/49/3a/P9tqLmNT_o.png" alt="OS"><br> 标准地址: <a href="https://www.autosar.org/standards/" rel="nofollow">https://www.autosar.org/standards/</a></p> 
<p>虽然说OS 是整个框架的灵魂，但是也有极少数的BSW 模块不与OS 直接交互。换句话说，其他BSW 模块在改动的时候，是需要考虑一下OS 对其的影响，和它对OS 的影响。<br> <img src="https://images2.imgbox.com/22/69/BCIx99np_o.png" alt="BSW-OS"></p> 
<h3><a id="Autosar_OS_55"></a>Autosar OS可裁剪类型</h3> 
<p>AUTOSAR组织根据是否支持时间保护和内存保护为不同的用户提供四类不同功能安全的OS可裁剪类型，分别为SC1-SC4。</p> 
<ol><li>SC1: OSEK OS + Schedule Table；</li><li>SC2: OSEK OS + Schedule Table + Timing Protection;</li><li>SC3: OSEK OS + Schedule Table + Memory Protection;</li><li>SC4: OSEK OS + Schedule Table + Timing Protection + Memory Protection；<br> <img src="https://images2.imgbox.com/d4/6d/Wi0c5C6w_o.png" alt="SC1-SC44"></li></ol> 
<p>Timing Protection：用于监控任务或者中断是否超时（超过规定的时间deadline）</p> 
<p>Memory Protection：用于防止不同的OS application异常访问其他不允许的程序段或数据段</p> 
<h2><a id="OS_66"></a>三、OS配置</h2> 
<p>Os主要包括以下内容<br> ①单Core/多核<br> ②Os应用（任务，中断等object的集合）<br> ③任务管理<br> ④中断管理<br> ⑤定时器<br> ⑥调度表<br> ⑦资源<br> ⑧Memory/Timing Protection<br> ⑨Stack<br> <img src="https://images2.imgbox.com/1f/61/D2i3auZb_o.png" alt="OS"></p> 
<h3><a id="OS_Application_78"></a>OS Application</h3> 
<p>OS Application是程序应用的单元，每个OS Application包含如下内容：<br> <code>①Task Management（任务管理）</code><br> <code>②ISR Management（中断管理）</code><br> <code>③Scheduler（调度表）</code><br> <code>④Resource Management（资源管理）</code><br> <code>⑤Counter and Alarms（时基和警报器）</code><br> <code>⑥Hook Rountines（Hook程序）</code></p> 
<p><img src="https://images2.imgbox.com/05/51/8rxINcw1_o.png" alt="APP"></p> 
<h4><a id="Counters_89"></a>Counters</h4> 
<p>Counters是OSEK OS中一个组件，在软件中可以理解为<strong>Ticks</strong><br> <img src="https://images2.imgbox.com/28/72/IarQe1Yh_o.png" alt="counter"></p> 
<blockquote> 
 <p>Counter Type: 采用硬件时钟并关联到硬件Timer<br> Counter Tick Per Base: 每100个硬件Timer Counter触发OS Counter 累加<br> Seconds Per Tick: 1us, 为了增加OS调度速度，精度不宜过小</p> 
</blockquote> 
<h4><a id="Alarms_95"></a>Alarms</h4> 
<p>Alarm（警报器）是由Counter驱动的，多个Alarm可以连接到同一个counter<br> Counter每次累加都会触发相关联Alarm的检查，如果满足触发条件，Alarm会被触发<br> <img src="https://images2.imgbox.com/3e/d5/5mfcAfcc_o.png" alt="Alarm"><br> Alarm报警，主要实现的是定时功能，在预定时间到达时候触发相关操作，例如：触发一次事件（Set Event），激活任务（BCC task），进行回调等操作<br> <code>回调函数是在IncrementCountrer()的上下文中执行的，而IncrementCounter一般是在与硬件计数器关联的计数器的中断函数中执行，所以中断执行函数不会知道回调的堆栈使用情况。在实际项目中我们要避免在回调中做大量的计算和函数调用，而只是设置全局变量等一些简单的事情</code></p> 
<p>Alarm的类型：</p> 
<blockquote> 
 <p>Relative（相对时间Alarm）：对比当前时基又过了Tick数量后触发<br> Absolute（绝对时间Alarm）：当counter到达固定数值后触发，或者周期固定间隔触发</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/92/64/jNNCPEHN_o.png" alt="setrelative"></p> 
<pre><code class="prism language-c"><span class="token function">FUNC</span><span class="token punctuation">(</span>Std_ReturnType<span class="token punctuation">,</span> RTE_CODE<span class="token punctuation">)</span> <span class="token function">Rte_Start</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">/* activate the alarms used for TimingEvents */</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">SetRelAlarm</span><span class="token punctuation">(</span>Rte_Al_TE_Test_SWC_Test_ECCTaskRunnable<span class="token punctuation">,</span> <span class="token function">RTE_SEC_OsCounter_Core0</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>TickType<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">RTE_SEC_OsCounter_Core0</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> RTE_E_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="Task_Management_116"></a>Task Management</h4> 
<p>OS的task分为两种：基础任务(BCC task)和扩展任务（Extended Task）。主要区别在于有无waiting状态：<br> <img src="https://images2.imgbox.com/4b/fc/w9x9lJs7_o.png" alt="task"><br> <strong>运行状态(Running)</strong>：处于运行状态的任务可能被高优先级任务或者中断抢占从而进入就绪状态，且同一Core中任何时刻只会存在一个任务处于运行状态，任务运行结束后则将自己挂起进入阻塞状态；<br> <strong>就绪状态(Ready)</strong>: 处于就绪状态的任务由调度器决定是否启动进入运行状态，且该状态时任务切换至运行状态的前提；<br> <strong>阻塞状态(Suspend)</strong>: 处于阻塞状态的任务是被动的，可以由API函数或Alarm激活进入就绪状态；<br> <strong>等待状态(Waiting)</strong>：当任务的运行需要等待某一或某些事件被置位时，任务进入就绪状态。</p> 
<p><strong>基础任务</strong>每次启动都会从程序开始执行到程序结束，没有等待状态，会在如下情况下停止运行<br> • 任务结束<br> • 被高优先级任务抢占<br> • 被中断抢占 （中断优先级高于任务）<br> <img src="https://images2.imgbox.com/5a/41/gj8F1zmR_o.png" alt="bcc"></p> 
<blockquote> 
 <p>Task Activation:同时只允许一次任务激活<br> Priority：任务优先级（值越大优先级越高），高优先级任务可以抢占低优先级任务（如果低优先级任务配置成支持抢占类型）<br> Schedule：NON-不支持抢占；FULL-可以被任何高优先级类型抢占<br> Stack Size：1K（根据当前任务所需要stack进行设置，如果Stack产生overflow，os会在任务切换时报错挂死，进入error hook或者是protection hook）<br> Type：Basic Task</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token function">TASK</span><span class="token punctuation">(</span>Core0_App_100ms<span class="token punctuation">)</span> <span class="token comment">/* PRQA S 3408, 1503 */</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">/* call runnable */</span>
    <span class="token function">Test_SWC_Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*任务挂在Alarm上, Alarm激活后Task会执行到任务结束，中间不会进入Wait 状态*/</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">TerminateTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* PRQA S 3417 */</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>• Event用于扩展类型任务的触发执行（从Waiting状态到Run状态）<br> • 每个扩展类型任务可以关联多个事件<br> • 任何任务或者中断程序都可以激活事件<br> • 只有关联事件的任务可以等待和清除相关联事件<br> <img src="https://images2.imgbox.com/07/df/a2iFkoJf_o.png" alt="Event"><br> 会在如下情况下停止运行<br> • 任务结束<br> • 被高优先级任务抢占<br> • 被中断抢占 （中断优先级高于任务）<br> • 自主挂起进入Waiting状态<br> <img src="https://images2.imgbox.com/ee/b6/Tu1wMIHt_o.png" alt="extended"></p> 
<blockquote> 
 <p>Task Activation: 同时只允许一次任务激活<br> Priority: 任务优先级, 高优先级任务可以抢占低优先级任务（如果低优先级任务配置成支持抢占类型）<br> Schedule: NON-不支持抢占；FULL-可以被任何高优先级类型抢占<br> Stack Size: 1K （根据当前任务所需要Stack进行设置，如果Stack产生Overflow, OS会再任务切换时报错挂死）<br> Type: Extended</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token function">TASK</span><span class="token punctuation">(</span>Core1_Bsw_5ms<span class="token punctuation">)</span> <span class="token comment">/* PRQA S 3408, 1503 */</span>
<span class="token punctuation">{<!-- --></span>
    EventMaskType ev<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token comment">/* 无结束任务调用 */</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">WaitEvent</span><span class="token punctuation">(</span>Rte_Ev_Run_Test_core1_SWC_Test_Core1_SWC_Runnable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 任务进入Waiting状态并等待事件 */</span>
        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">GetEvent</span><span class="token punctuation">(</span>Core1_Bsw_5ms<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 事件触发，任务恢复执行 （事件由Alarm触发） */</span>
        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">ClearEvent</span><span class="token punctuation">(</span>ev <span class="token operator">&amp;</span> Rte_Ev_Run_Test_core1_SWC_Test_Core1_SWC_Runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ev <span class="token operator">&amp;</span> Rte_Ev_Run_Test_core1_SWC_Test_Core1_SWC_Runnable<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token punctuation">(</span>EventMaskType<span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">/* 事件为runnable执行所等待事件*/</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">Test_Core1_SWC_Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 执行runnable */</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>AUTOSAR OS是基于优先级进行task 调度，所以每个任务必定有一个优先级，而每个任务都是根据其自身特点来定义一个优先级且需要配置其可抢占属性。可抢占属性可分为不可抢占与全抢占，调度策略可分为以下两种：<br> 非抢占式：OS中所有任务均是不可抢占的；<br> 完全抢占式：OS所有任务均是可抢占类型；</p> 
<p>假定TaskA为扩展任务，TaskB与TaskC为基本任务，优先级TaskA &gt; TaskB &gt; TaskC。<br> ①若采用非抢占式调度策略，那么当前运行状态的任务在任何时刻都不会其他高优先级任务所抢占，任务的切换只会发生在任务完时。 非抢占式调度策略的问题在于任务执行时间不确定，系统调度实时性较差。如下图所示为非抢占式调度策略，可见即使高优先级任务 TaskB被激活切换至就绪状态，也必须等到TaskC执行结束之后才能够被调度。<br> <img src="https://images2.imgbox.com/c5/47/lQs3MWSh_o.png" alt="非抢占式调度"><br> ②对于完全抢占式任务调度策略而言，当前运行的任务可在任何时刻被高优先级任务打断而被迫释放处理器控制权，具备最高优先级的任务从就绪状态转入运行状态，而当前任务被抢占从而进入就绪状态，同时保留现场环境，带下次运行时恢复。<br> <img src="https://images2.imgbox.com/a6/25/TDywXB0a_o.png" alt="完全抢占式调度"><br> Case1：当前TaskC处于运行状态，当激活TaskB进入到就绪状态时，由于TaskB优先级高于TaskC，所以TaskC被迫释放处理器控制权，调度器 开始调度TaskB从就绪状态变为运行状态，直到TaskB运行完成之后，在调度TaskC继续运行。</p> 
<p>Case2：当前TaskC处于运行状态，激活TaskA与TaskB分别进入就绪状态，由于TaskA优先级高于TaskB，所以TaskA抢占内核运行， 但是由于Resource1仍被TaskC暂用，而TaskA无法访问到共享资源Resource1，则被迫进入到等待状态，TaskB开始运行。</p> 
<p>TaskB运行结束后挂起之后则重新运行TaskC，TaskC运行结束后释放Resource1，进入TaskA得以由等待状态转入运行状态。此时你会发现高优先级的任务TaskA由于共享资源被占用的原因导致不能先于TaskB运行的现象，该现象也被称为优先级反转现象。<br> 为了解决该问题，在此需要提到AUTOSAR OS的优先级天花板模式：即将访问共享资源的任务优先级在占用资源的过程中提升至共享资源任务的最高优先级之上，从而避免优先级反转现象的发生。<br> <img src="https://images2.imgbox.com/37/d5/lwzjW8gX_o.png" alt="关系图"><br> 即若TaskC运行过程中占用共享资源Resource1，此时即使存在需占用共享资源的高优先级任务TaskA被激活，也必须保证TaskC运行结束之后才能执行TaskA，也就意味着在重要代码执行之前，应采用资源保护机制，以免被高优先级的任务打断。</p> 
<blockquote> 
 <p>多个任务共享的资源（数据和外设等），需要防止task1再读取共享数据的时候被task2改写。<br> 临界区保护（Exclusive Area Handling）：<br> ①开关中断<br> ②Get/Release Resource<br> ③Get/Release SpinLock</p> 
</blockquote> 
<h4><a id="Resource_Management_198"></a>Resource Management</h4> 
<p>Resouce作为OS调度过程中一个十分重要的对象，资源管理就是为了协调具有不同优先级的多个任务或者中断对共享内存（如内存或者硬件等）的并发访问。<br> AUTOSAR OS采用上述的优先级天花板模式来避免任务优先级反转以及死锁问题的发生，即资源的上限优先级必须高于所有该资源的任务以及中断的优先级，但是应低于不访问该资源的任务的最低优先级。<br> 其中为了保护共享资源而提出的锁机制-自旋锁(Spin Lock)。该自旋锁一般用于多核操作系统解决资源互斥的问题。当内核控制必须访问共享数据结构或进入临界区时，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了该锁，从而达到某共享资源的互斥作用。</p> 
<h4><a id="ISRs_203"></a>ISRs</h4> 
<p><img src="https://images2.imgbox.com/98/49/0Twlq2CJ_o.png" alt="ISRs"><br> 在AUTOSAR中定义了两类中断服务程序(Interrupt Service Routine)。分别为一类中断(Category I)与二类中断(Category),两者之间的区别定义如下：<br> Categoty I：此类中断服务程序不能够使用OS提供的系统服务，当中断执行完成之后则会重新跳转至产生中断的地方继续执行，不会影响到任务的执行，因此占用系统资源较少。</p> 
<p>Category II：该类中断则可以调用OS系统服务，如激活任务或者设置事件等，受OS控制。<br> 如下述代码所示，中断向量表不直接指定中断服务程序，而是指向Os_Hal_IsrRun 程序由OS接管中断服务程序。<br> <img src="https://images2.imgbox.com/1e/0f/HBP9aTNc_o.png" alt="二类中断"><br> 在AUTOSAR OS中，<strong>中断的优先级始终高于任务的优先级</strong>，即最低优先级的中断都可以打断最高优先级的任务，即使该任务配置不可抢占也会被中断抢占。因此，中断服务子程序的执行时间不宜过长，否则会影响到整个系统的实时性。</p> 
<h4><a id="ScheduleTables_212"></a>ScheduleTables</h4> 
<p>调度表（ScheduleTables) 通过提供一组静态定义的到期点（expiry points）的封装来解决同步问题。每个到期点定义：<br> 处理时必须发生的一个或多个动作，其中动作是任务（Task）的激活或事件（event）的设置。<br> 从调度表（ScheduleTable）开始点一个以滴答（Tick）为单位的偏移量(Offset)。<br> <img src="https://images2.imgbox.com/88/57/rxAjJbUD_o.png" alt="ep"><br> 每个调度表都有一个持续时间(Duration)，即调度表的一次运行时间，度量单位为计数器的计数单位 Tick。<br> <img src="https://images2.imgbox.com/d6/0a/VhrW4dP7_o.png" alt="Duration"></p> 
<h4><a id="Hook__219"></a>Hook 函数和错误处理</h4> 
<table><thead><tr><th>Hook函数</th><th>功能描述</th></tr></thead><tbody><tr><td>StartupHook</td><td>在StartOS之后，第一个任务启动之前触发</td></tr><tr><td>ShutdownHook</td><td>ShutdownOS函数被调用后触发</td></tr><tr><td>PretaskHook</td><td>任务启动前触发</td></tr><tr><td>PosttaskHook</td><td>任务结束时触发</td></tr><tr><td>ErrorHook</td><td>系统故障时触发，可以在MICROSAR OS查看Error Code</td></tr><tr><td>Protection Hook</td><td>Stack, Memory, timing 保护错误发生时触发</td></tr><tr><td>Panic Hook</td><td>NULL指针，unexpected process</td></tr></tbody></table> 
<p>使能Hook配置后，可以在Os_Callout_Stubs.c对应的function中加入manual code。</p> 
<p>AUTOSAR BSW模块通常将其错误报告给Det(开发错误)或Dem(生产错误)。操作系统处理错误的方式不同，不会将错误报告给Dem/Det。如果需要向Dem/Det报告错误，用户可以在ErrorHook()中执行这些操作。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e1f3d9cfc8857407dbff2799c4320c16/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot ＋MyBatis批量插入数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/017eedf4baee6bd0d5a24108d5f97dd5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vscode插件开发 悬浮，ctrl点击 自动补全提示</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>