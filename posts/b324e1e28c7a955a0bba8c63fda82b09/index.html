<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>函数式编程 - 组合compose的使用方法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="函数式编程 - 组合compose的使用方法" />
<meta property="og:description" content="函数式编程中有一个比较重要的概念就是函数组合（compose）,组合多个函数，同时返回一个新的函数。调用时，组合函数按顺序从右向左执行。右边函数调用后，返回的结果，作为左边函数的参数传入，严格保证了执行顺序，这也是compose 主要特色。| 函数式编程--函数组合(Function composition) - 知乎
入门简介 组合两个函数 compose 非常简单，通过下面的示例代码，就非常清楚。
function compose (f, g) { return function(x) { return f(g(x)); } } var arr = [1, 2, 3], reverse = function(x){ return x.reverse()}, getFirst = function(x) {return x[0]}, compseFunc = compose(getFirst, reverse); compseFunc(arr); // 3 参数在函数间就好像经过‘管道’传输同样，最右边的函数接收外界参数，返回结果传给左边的函数，最后输出结果。
组合任意个函数 上面组合了两个函数的compose，也让咱们了解了组合的特点，接着咱们看看如何组合更多的函数，由于在实际应用中，不会像入门介绍的代码那么简单。
主要注意几个关键点：
1、利用arguments的长度得到所有组合函数的个数
2、reduce 遍历执行全部函数。
var compose = function() { var args = Array.prototype.slice.call(arguments); return function(x) { if (args.length &gt;= 2) { return args." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b324e1e28c7a955a0bba8c63fda82b09/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T10:01:43+08:00" />
<meta property="article:modified_time" content="2024-01-12T10:01:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">函数式编程 - 组合compose的使用方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/11/27/OM4gnEH6_o.jpg"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9a/78/QysrHQ6V_o.gif"></p> 
<p>函数式编程中有一个比较重要的概念就是函数组合（compose）,组合多个函数，同时返回一个新的函数。调用时，<strong>组合函数按顺序从右向左执行</strong>。右边函数调用后，返回的结果，作为左边函数的参数传入，严格保证了执行顺序，这也是compose 主要特色。| <a href="https://zhuanlan.zhihu.com/p/356984124" rel="nofollow" title="函数式编程--函数组合(Function composition) - 知乎">函数式编程--函数组合(Function composition) - 知乎</a></p> 
<h3>入门简介</h3> 
<hr> 
<h4>组合两个函数</h4> 
<p>compose 非常简单，通过下面的示例代码，就非常清楚。</p> 
<pre><code class="language-javascript">function compose (f, g) {
    return function(x) {
        return f(g(x));
    }
}

var arr = [1, 2, 3],
reverse = function(x){ return x.reverse()},
getFirst = function(x) {return x[0]},
compseFunc = compose(getFirst, reverse);
    
compseFunc(arr);   // 3</code></pre> 
<p><strong>参数在函数间就好像经过‘管道’传输同样，最右边的函数接收外界参数，返回结果传给左边的函数，最后输出结果。</strong></p> 
<h4>组合任意个函数</h4> 
<p>上面组合了两个函数的compose，也让咱们了解了组合的特点，接着咱们看看如何组合更多的函数，由于在实际应用中，不会像入门介绍的代码那么简单。</p> 
<p>主要注意几个关键点：</p> 
<p>1、利用arguments的长度得到所有组合函数的个数</p> 
<p>2、reduce 遍历执行全部函数。</p> 
<pre><code class="language-javascript">var compose = function() {
      var args = Array.prototype.slice.call(arguments);
      
      return function(x) {
       if (args.length &gt;= 2) {
       
          return args.reverse().reduce((p, c) =&gt; {
            return p = c(p)
         }, x)
         
       } else {
           return args[1] &amp;&amp; args[1](x);
       }
      }
    }
   
// 利用上面示例 测试一下。
var arr = [1, 2, 3],
reverse = function(x){ return x.reverse()},
getFirst = function(x) {return x[0]},
trace = function(x) {  console.log('执行结果：', x); return x}
    
compseFunc = compose(trace, getFirst, trace, reverse);
    
compseFunc(arr);   
 // 执行结果： (3) [3, 2, 1]
 // 执行结果： 3
 // 3</code></pre> 
<p>如此实现，基本没什么问题，变量<code>arr</code> 在管道中传入后，经过各种操作，最后返回了结果。</p> 
<h3>深入理解</h3> 
<hr> 
<h4>认识pipe</h4> 
<p>函数式编程（FP）里面跟compose类似的方法，就是<strong>pipe</strong>。</p> 
<p><strong>pipe，</strong>主要作用也是组合多个函数，称之为<strong><span style="color:#0d0016;">“</span><span style="color:#fe2c24;">流</span><span style="color:#0d0016;">”</span></strong>， 肯定得按照正常方法，从左往右调用函数，与compose 调用方法相反。</p> 
<h4>ES6 实现Compose function</h4> 
<p>先看下compose 最基础的两参数版本</p> 
<pre><code class="language-javascript">const compose = (f1, f2) =&gt; value =&gt; f1(f2(value));</code></pre> 
<p>利用箭头函数，非常直接的表明两个函数嵌套执行的关系，接着看多层嵌套。</p> 
<pre><code class="language-javascript">(f1, f2, f3...) =&gt; value =&gt; f1(f2(f3));</code></pre> 
<p>抽象出来表示：</p> 
<pre><code class="language-javascript">() =&gt; () =&gt; result;</code></pre> 
<p>先提出这些基础的组合方式，对我们后面理解高级ES6方法实现compose有很大帮助。</p> 
<h5>实现pipe</h5> 
<p>前面提到 pipe 是反向的compose，pipe正向调用也致使它实现起来更容易。</p> 
<pre><code class="language-javascript">pipe = (...fns) =&gt; x =&gt; fns.reduce((v, f) =&gt; f(v), x)</code></pre> 
<p>一行代码就实现了pipe，套用上面抽象出来的表达式，<strong><span style="color:#fe2c24;"><code>reduce</code></span></strong>恰好正向遍历全部函数， 参数<strong><span style="color:#fe2c24;"><code>x</code></span></strong>做为传递给函数的初始值， 后面每次<strong><span style="color:#fe2c24;"><code>f(v)</code></span></strong>执行的结果，作为下一次<strong><span style="color:#fe2c24;"><code>f(v)</code></span></strong>调用的参数<strong><span style="color:#fe2c24;"><code>v</code></span></strong>，完成了函数组合调用。</p> 
<p>或者，能够把函数组合中，第一个函数获取参数后，获得的结果，作为<strong><span style="color:#fe2c24;"><code>reduce</code></span></strong>遍历的初始值。</p> 
<pre><code class="language-javascript">pipe = (fn,...fns) =&gt; (x) =&gt; fns.reduce( (v, f) =&gt; f(v), fn(x));</code></pre> 
<p>利用ES6提供的<span style="color:#fe2c24;"><strong>rest </strong></span>参数 ，用于获取函数的多余参数，提取出第一个函数fn，多余函数参数放到fns中，fns看成是数组，也不用像arguments那种事先经过<span style="color:#fe2c24;"><strong><code>Array.prototype.slice.call</code></strong></span>转为数组，<a href="http://www.noobyard.com/link?url=https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments" title="arguments对性能损耗">arguments对性能损耗</a>也可以避免。<strong><span style="color:#fe2c24;"> <code>fn(x)</code></span></strong> 第一个函数执行结果做为<code>reduce</code> 初始值。</p> 
<p><span style="color:#fe2c24;"><strong>注：</strong></span>关于剩余参数<strong>rest</strong>，可参考我之前文章：<a href="https://blog.csdn.net/sunyctf/article/details/125961050" title="【JS高级】ES6参数增强之剩余参数的应用">【JS高级】ES6参数增强之剩余参数的应用</a></p> 
<h5>实现compose</h5> 
<p>1、pipe 部分，利用reduce实现，反过来看，<strong><span style="color:#fe2c24;"><code>compose</code></span></strong>就能够利用reduceRight</p> 
<pre><code class="language-javascript">compose = (...fns) =&gt; x =&gt; fns.reduceRight((v, f) =&gt; f(v), x);</code></pre> 
<p>2、利用递归</p> 
<pre><code class="language-javascript">compose = (fn, ...fns) =&gt; fns.length === 0 ? fn: (...args) =&gt; fn(compose(...fns)(...args))</code></pre> 
<p>递归代码，首先看出口条件， <strong><span style="color:#fe2c24;"><code>fns.length === 0</code></span></strong>，最后一定执行最左边的函数，然后把剩下的函数再经过<strong><span style="color:#fe2c24;"><code>compose</code></span></strong>调用，</p> 
<p>3、利用reduce实现。</p> 
<p>一行实现，并且仍是用正向的 <strong><span style="color:#fe2c24;"><code>reduce</code></span></strong>。</p> 
<pre><code class="language-javascript">const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; f(g(...args)))</code></pre> 
<p>作者其实用例子作了解释，可以看下<span style="color:#fe2c24;"><strong><code>reduce</code></strong></span> 迭代的方向是从左往右的，而<strong><span style="color:#fe2c24;"><code>compose</code></span></strong> 要求执行的方向是从右往左。对数组中每一项执行函数，正常状况下都应该放回执行结果，比如<code><strong><span style="color:#fe2c24;">(v, f) =&gt;</span></strong> <span style="color:#fe2c24;"><strong>f(v)</strong></span></code>，返回<strong><span style="color:#fe2c24;"><code>f(v)</code></span></strong>执行结果，这里是<span style="color:#fe2c24;"><strong><code>(f, g) =&gt; (...args) =&gt; f(g(...args))</code></strong></span>返回一个函数<strong><span style="color:#fe2c24;"><code>(...args) =&gt; f(g(...args))</code></span></strong>，这样就能够保证后面的函数<strong><span style="color:#fe2c24;"><code>g</code></span></strong>在被作为参数传入时比前面的函数<strong><span style="color:#fe2c24;"><code>f</code></span></strong>先执行。</p> 
<p>简单利用前面的组合两个函数的例子分析一下。</p> 
<pre><code class="language-javascript">...
composeFunc = compose(getFirst, trace, reverse);
composeFunc(arr);</code></pre> 
<p><strong>主要看reduce 函数里面的执行过程：</strong></p> 
<p>◆ 入口<strong><span style="color:#fe2c24;"> composeFunc(arr),</span></strong> 第一次迭代，<span style="color:#fe2c24;"><strong>reduce</strong></span>函数执行<strong><span style="color:#fe2c24;"> (getFirst, trace) =&gt; (...args)=&gt;getFirst(trace(...args))</span></strong>，函数<strong><span style="color:#fe2c24;"><code>(...args)=&gt;getFirst(trace(...args))</code></span></strong>作为下一次迭代中累计器<code>f</code>的值。</p> 
<p>◆ 第二次迭代，reduce函数中</p> 
<pre><code class="language-javascript">f == (...args)=&gt;getFirst(trace(...args))
g == reverse。
// 替换一下 (f, g) =&gt; (...args) =&gt; f(g(...args))
((...args)=&gt;getFirst(trace(...args)), reverse) =&gt; (...args) =&gt; ((...args)=&gt;getFirst(trace(...args)))(reverse(...args))</code></pre> 
<p>◆ 迭代结束，最后得到的comoseFunc就是</p> 
<pre><code class="language-javascript">// 对照第二次的执行结果， (...args) =&gt; f(g(...args))

(...args) =&gt; ((...args)=&gt;getFirst(trace(...args)))(reverse(...args))</code></pre> 
<p>◆ 调用函数composeFunc(arr)。</p> 
<pre><code class="language-javascript">(arr) =&gt; ((...args)=&gt;getFirst(trace(...args)))(reverse(arr))

===》reverse(arr) 执行结果[3, 2, 1] 做为参数

 ((...args)=&gt;getFirst(trace(...args)))([3,2,1])

==》入参调用函数

   getFirst(trace[3,2,1])

===》 

   getFirst([3, 2, 1])

===》

   结果为 3</code></pre> 
<p>非常巧妙的把后一个函数的执行结果作为包裹着前面函数的空函数的参数，传入执行。其中大量用到下面的结构。</p> 
<pre><code class="language-javascript">((arg)=&gt; f(arg))(arg) 
// 转换一下。
  (function(x) {
     return f(x)
  })(x)</code></pre> 
<h3>最后</h3> 
<p>不管是compose， 仍是后面提到的pipe，概念很是简单，均可以使用很是巧妙的方式实现（大部分使用reduce），并且在编程中很大程度上简化代码。最后列出优秀框架中使用compose的示例：</p> 
<ul><li><a href="https://github.com/reduxjs/redux/blob/master/src/compose.ts" title="redux/compose">redux/compose</a></li><li><a href="http://www.noobyard.com/link?url=https://github.com/koajs/compose/blob/master/index.js" title="koa-Compose">koa-Compose</a></li><li><a href="http://www.noobyard.com/link?url=https://underscorejs.org/#compose" rel="nofollow" title="underscorejs/compose">underscorejs/compose</a></li></ul> 
<p><strong>参考连接</strong>：</p> 
<ul><li><a href="http://www.noobyard.com/link?url=https://medium.com/@dtipson/creating-an-es6ish-compose-in-javascript-ac580b95104a" rel="nofollow" title="Creating an ES6ish Compose in Javascript">Creating an ES6ish Compose in Javascript</a></li><li><a href="http://www.noobyard.com/link?url=https://gist.github.com/WaldoJeffers/905e14d03f4283599bac753f73b7716b" rel="nofollow" title="compose.js">compose.js</a></li><li><a href="http://www.noobyard.com/link?url=https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments" title="Optimization-killers">Optimization-killers</a></li></ul> 
<p><strong>参考资料：</strong></p> 
<p><a href="https://blog.csdn.net/MRlaochen/article/details/120437542" title="JS高级编程中compose函数的介绍和基本实现">JS高级编程中compose函数的介绍和基本实现</a> |  <a href="https://blog.csdn.net/shi_Avicii/article/details/104282158" title="复合函数compose函数的概念">复合函数compose函数的概念</a></p> 
<p><a href="https://www.cnblogs.com/shapeY/p/10693552.html" rel="nofollow" title="compose函数">compose函数</a> | <a href="https://zhuanlan.zhihu.com/p/356984124" rel="nofollow" title="函数式编程--函数组合(Function composition)">函数式编程--函数组合(Function composition)</a> | <a href="https://cloud.tencent.com/developer/article/2129819" rel="nofollow" title="函数式编程之compose">函数式编程之compose</a></p> 
<p style="text-align:center;"><img alt="" height="150" src="https://images2.imgbox.com/8a/f7/b85UegE5_o.gif" width="960"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e5b78a418328eae9a08ac04522e5d1a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何查看一篇论文是期刊还是会议？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f377b346fc556fc78bd344d85468b0b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RSIC-V“一芯”学习笔记（一）——概述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>