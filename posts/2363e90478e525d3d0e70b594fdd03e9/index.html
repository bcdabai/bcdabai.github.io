<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>initramfs 最全解释与制作 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="initramfs 最全解释与制作" />
<meta property="og:description" content="先提几个问题：
0、什么是 initrd 和 initramfs？
概述
现代Linux系统都使用到了一种功能比较特殊的微型系统，作为Linux内核初始化完成但未进入最终系统时的过渡系统，主要的目的是为了将最终系统载入到根文件系统上，辅助内核启动最终系统，可以称之为“辅助系统”。
辅助系统的作用
通常，主流的Linux发行版都会把内核中一些非必要且可以编译成模块的核心功能，如SATA、SCSI等设备的驱动程序，以内核模块的方式来提供。考虑这样一个场景，如果Linux系统是安装在如SATA磁盘上，那么就需要加载SATA磁盘的驱动程序来挂载磁盘上的根文件系统，但SATA的驱动程序又是放在磁盘的文件系统上，因此通过把SATA的驱动程序放到辅助系统中，就可以灵活解决这个问题。
辅助系统实现
辅助系统存放方式目前有两种：
Initrd
Initial RAM Disk，使用传统的内存磁盘方式存放辅助系统，现在基本已经不使用这种方式了，但很多Linux发行版在/boot目录也还在继续使用Initrd这个名字；
Initramfs
Initial RAM Filesystem，使用比较现代的内存文件系统方式存放辅助系统，也是当下主流的使用方式。
Initrd
Initrd采用RAM Disk来存储辅助系统，RAM Disk模拟块设备操作，Linux内核启动过程将辅助系统的镜像文件还原到RAM Disk设备上，在RAM Disk设备上使用辅助系统必须采用文件系统，必须将镜像文件格式化Linux内核支持的文件系统，在该文件系统中存放辅助系统。
将镜像文件还原到RAM Disk设备上时需要注意RAM Disk设备的大小，镜像文件还原后的文件系统占用空间必须小于等于RAM Disk设备的空间，否则会出现还原错误。
启动器将该镜像文件从磁盘上读取并存放到内存某个特定位置上，再由Linux内核在启动过程中从内存特定位置中将镜像文件还原到RAM Disk上，默认还原的RAM Disk设备文件名为/dev/ram0，然后按照Initrd的方式启动辅助系统。
Linux内核将Initrd中的辅助系统视为过渡系统，在辅助系统执行完成后，Linux内核重新获得控制权，继续执行根文件系统中的“最终系统”。
Initramfs
Initramfs采用内存文件系统存储“辅助系统”。与Initrd方式不同，Initramfs中的系统在Linux内核中被视为“最终系统”，定义为“辅助系统”是从制作该系统目的而言的，Linux内核将辅助系统文件还原到根文件系统，内核执行该系统后就不再接管执行控制权了，执行的控制都由该系统完成。
启动流程：
采用“Initrd”时Linux内核的启动过程
辅助系统文件采用“Initrd”时，内核将root参数指定设备对应的编号保存在内核的内部变量“real-root-dev”中，如果内核未能探测到root指定的设备，“real-root-dev”中将保存为“0”。
内核将“Initrd”文件还原到/dev/ram0设备上，运行其中根目录下的linuxrc文件，等待该文件的执行结束，linuxrc文件执行结束后推出并返回到内核继续执行。内核再次获得执行权后将检查“real-root-dev”中的取值，根据取值作不同处理:
real-root-dev为“0”，将提示无法挂载“0:0”设备而出错，无法继续启动；
real-root-dev的值与“/dev/ram0”的设备号相同时，内核认为“最终系统”已经准备就绪不再处理，直接运行当前根文件系统中/sbin/init命令；
real-root-dev的值不是“/dev/ram0”的设备号时，内核会认为需要挂载设备到根文件系统，按照“real-root-dev”对应的设备号挂载设备到根文件系统，并运行根文件系统中/sbin/init命令，如果内核无法挂载该设备将提示错误并启动失败。
采用“Initramfs”时Linux内核的启动过程
内核探测“Initramfs”后将会把文件解压还原到根文件系统中，形成一个微型系统，并认为该系统就是“最终系统”而直接运行其中的/sbin/init命令，内核完成启动过程。
1、initrd 和 initramfs 有什么区别？
linux 初始化会执行 init 进程，而 init 进程 会初始化 根文件系统(rootfs)，但由于 init 进程也在 rootfs 中，这里出现一个先有鸡还是现有蛋的问题； **kernel 2.6 以前：**所以我们需要创造一个临时的文件系统环境（initrd.img），init 进程在 initrd.img 创造的文件系统里面运行起来，然后 init 进程去挂载真正的 根文件系统" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2363e90478e525d3d0e70b594fdd03e9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-25T14:39:16+08:00" />
<meta property="article:modified_time" content="2023-10-25T14:39:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">initramfs 最全解释与制作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>先提几个问题：</p> 
<p>0、什么是 initrd 和 initramfs？</p> 
<p>概述<br> 现代Linux系统都使用到了一种功能比较特殊的微型系统，作为Linux内核初始化完成但未进入最终系统时的过渡系统，主要的目的是为了将最终系统载入到根文件系统上，辅助内核启动最终系统，可以称之为“辅助系统”。</p> 
<p>辅助系统的作用<br> 通常，主流的Linux发行版都会把内核中一些非必要且可以编译成模块的核心功能，如SATA、SCSI等设备的驱动程序，以内核模块的方式来提供。考虑这样一个场景，如果Linux系统是安装在如SATA磁盘上，那么就需要加载SATA磁盘的驱动程序来挂载磁盘上的根文件系统，但SATA的驱动程序又是放在磁盘的文件系统上，因此通过把SATA的驱动程序放到辅助系统中，就可以灵活解决这个问题。</p> 
<p>辅助系统实现<br> 辅助系统存放方式目前有两种：<br> <strong>Initrd</strong><br> Initial RAM Disk，使用传统的内存磁盘方式存放辅助系统，现在基本已经不使用这种方式了，但很多Linux发行版在/boot目录也还在继续使用Initrd这个名字；<br> <strong>Initramfs</strong><br> Initial RAM Filesystem，使用比较现代的内存文件系统方式存放辅助系统，也是当下<strong>主流的使用方式</strong>。</p> 
<p><strong>Initrd</strong><br> Initrd采用RAM Disk来存储辅助系统，RAM Disk模拟块设备操作，Linux内核启动过程将辅助系统的镜像文件还原到RAM Disk设备上，在RAM Disk设备上使用辅助系统必须采用文件系统，必须将镜像文件格式化Linux内核支持的文件系统，在该文件系统中存放辅助系统。<br> 将镜像文件还原到RAM Disk设备上时需要注意RAM Disk设备的大小，镜像文件还原后的文件系统占用空间必须小于等于RAM Disk设备的空间，否则会出现还原错误。<br> 启动器将该镜像文件从磁盘上读取并存放到内存某个特定位置上，再由Linux内核在启动过程中从内存特定位置中将镜像文件还原到RAM Disk上，默认还原的RAM Disk设备文件名为/dev/ram0，然后按照Initrd的方式启动辅助系统。<br> Linux内核将Initrd中的辅助系统视为过渡系统，在辅助系统执行完成后，Linux内核重新获得控制权，继续执行根文件系统中的“最终系统”。</p> 
<p><strong>Initramfs</strong><br> Initramfs采用内存文件系统存储“辅助系统”。与Initrd方式不同，Initramfs中的系统在Linux内核中被视为“最终系统”，定义为“辅助系统”是从制作该系统目的而言的，Linux内核将辅助系统文件还原到根文件系统，内核执行该系统后就不再接管执行控制权了，执行的控制都由该系统完成。</p> 
<p>启动流程：<br> <img src="https://images2.imgbox.com/38/8c/dW2mE5aR_o.png" alt="在这里插入图片描述"><br> 采用“Initrd”时Linux内核的启动过程<br> 辅助系统文件采用“Initrd”时，内核将root参数指定设备对应的编号保存在内核的内部变量“real-root-dev”中，如果内核未能探测到root指定的设备，“real-root-dev”中将保存为“0”。<br> 内核将“Initrd”文件还原到/dev/ram0设备上，运行其中根目录下的linuxrc文件，等待该文件的执行结束，linuxrc文件执行结束后推出并返回到内核继续执行。内核再次获得执行权后将检查“real-root-dev”中的取值，根据取值作不同处理:</p> 
<p>real-root-dev为“0”，将提示无法挂载“0:0”设备而出错，无法继续启动；<br> real-root-dev的值与“/dev/ram0”的设备号相同时，内核认为“最终系统”已经准备就绪不再处理，直接运行当前根文件系统中/sbin/init命令；<br> real-root-dev的值不是“/dev/ram0”的设备号时，内核会认为需要挂载设备到根文件系统，按照“real-root-dev”对应的设备号挂载设备到根文件系统，并运行根文件系统中/sbin/init命令，如果内核无法挂载该设备将提示错误并启动失败。<br> 采用“Initramfs”时Linux内核的启动过程<br> 内核探测“Initramfs”后将会把文件解压还原到根文件系统中，形成一个微型系统，并认为该系统就是“最终系统”而直接运行其中的/sbin/init命令，内核完成启动过程。</p> 
<p>1、initrd 和 initramfs 有什么区别？<br> linux 初始化会执行 init 进程，而 init 进程 会初始化 根文件系统(rootfs)，但由于 init 进程也在 rootfs 中，这里出现一个先有鸡还是现有蛋的问题； **kernel 2.6 以前：**所以我们需要创造一个临时的文件系统环境（initrd.img），init 进程在 initrd.img 创造的文件系统里面运行起来，然后 init 进程去挂载真正的 根文件系统<br> **kernel 2.6 以后：**实现方式发生改变，完成功能一致。采用 initramfs: init ram filesystem，它是一个 cpio 的内存文件格式，制作方式有两种，mkinitrd、cpio 手动压缩制作，制作出来后，grub 里写上 initramfs 的路径，填入在 initrd 后面，一般指定都是 iso 目录下面的路径（/images/pxeboot/initrd.img）</p> 
<p>2、放在 initramfs 的 ko 会先加载，还是 /lib/modules/ 下面的 ko 会先加载？<br> 我们都知道 initramfs 是系统启动时加载，其中的 lib/modules 中包含必要的设备驱动（磁盘、网卡、文件系统等）及运行环境C库/动态库链接器等， 先启动一个临时系统，然后会再 switchroot 时加载，用的是initramfs 相关驱动，在 switchroot 后，用的是硬盘上的非必须驱动，有些 ko 虽然放到 initramfs 中，但是 switchroot 前不加载的话，用的还是硬盘上的，关键看 ko 加载时机</p> 
<p>我们很容易在 /boot 下找到 initramfs.img，但是如何解压呢？<br> /usr/lib/dracut/skipcpio …/$initramfs | zcat | cpio -id</p> 
<p>参考：<br> boot 启动流程：<br> http://www.ruanyifeng.com/blog/2013/02/booting.html</p> 
<p>initrd 制作和详解：<br> http://xstarcd.github.io/wiki/Linux/ShengRuLiJie_linux_2.6_initramfs.html<br> http://xstarcd.github.io/wiki/Linux/initramfs.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4a8fb48a458754ceb7699e621736a872/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springboot 动态添加不同类型数据源(demo)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/24183f717a4b00adf9c923cc163a7507/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">信息学奥赛一本通：1057：简单计算器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>