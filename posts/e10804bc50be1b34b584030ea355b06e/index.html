<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>分治法的基本思想_归并排序-分治思想的典型应用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="分治法的基本思想_归并排序-分治思想的典型应用" />
<meta property="og:description" content="前面的文章讲了二分查找算法，这种算法使用了一种非常常见的思想–&#34;分治思想&#34;。所谓分治，就是&#34;分而治之&#34;，当解决一个大问题时，如果问题太大而无法直接解决，就可以试着把问题分解成很多个相互独立的子问题，将每个子问题各个击破，最后每个子问题得到的结果一合并就得出了原问题的结果，分治法一般都通过递归实现。本文讲解的归并排序就是分治思想的经典应用。
一.基本思想 1. 分解：给出包含若干个数的一段序列。按照分治思想要把序列分成两部分，然后对每个部分，再以相同的方式分成两个更小的序列。就这样一直分下去，到最后每段序列都只有一个数了。无法再分解了，那该怎样排序呢？答案是不用排序了，每个序列都只有一个数还怎么排序呢，换句话说，只有一个数，这本身就是有序的。这就是分治算法的妙处，把一个无序的序列分成了若干个有序的序列。
2. 合并：合并是整个排序算法的难点和重点。阐述起来很简单，就是把分开的子序列两两按序合并。
· 说起来很简单，要想真正的理解并不容易，以图解的形式描述归并的过程更直观一些。
二.图解 分解的步骤很简单。
把整个序列分成多个仅有一个数的序列后，开始合并。
第一趟合并
第二趟合并
第三趟合并
在不断合并的过程中，序列中的元素就自动排好了序。
三.具体实现 上述就是归并排序的思路，那具体是如何实现的呢？
我们要先定义一个临时数组b[]，我们将被排序的数组命名为数组a[]。在两个序列合并的过程中，要先将两个序列中的元素进行比较，再按顺序存放到临时数组b[]中，这样b[]中的元素就是有序的，再将b[]中的数组复制到a[]中。以最后一次合并为例(由于合并的两序列也都经过了多次比较和合并之后才形成，所以也是有序的)
注：下文的比较过程中用的首个元素并不是序列本身的首个元素，序列本身的首个元素是固定不变的，这里的首个元素是序列中未进行比较的元素中的首个元素。
(1)第一次比较，4&lt;7，4放入临时数组，12变成了第一个序列的首个元素。
(2)第二次比较，7&lt;12，7放入临时数组，16变成了第二个序列的首个元素。
(3)第三次比较，12&lt;16，12放入临时数组，13变成了第一个序列首个元素。
(4)第四次比较，13&lt;16，13放入临时数组，50变成了第一个序列的首个元素。
(5)第五次比较，16&lt;50，16放入临时数组，25变成了第二个序列的首个元素。
(6)第六次比较，25&lt;50，25放进临时数组，33变成了第二个序列的首个元素。
(7)第七次比较，33&lt;50，33放进临时数组，第二个序列的元素全部被安排了。
(8)第八次比较，发现第二个序列都比完了，这时候就把第一个序列中的剩余元素(其实也就一个了)按序放进数组。
这段过程的实现代码为
private static void Merge(int a[],int low,int mid,int high){ int[] b=new int[high-low&#43;1];//开临时数组 int i=low,j=mid&#43;1,t=0,t1=0;//i,j分别作为两部分的指针 while(i&lt;=mid&amp;&amp;j&lt;=high){//两部分比较，小的进临时数组 if(a[i]&gt;a[j]){ b[t&#43;&#43;]=a[j&#43;&#43;]; }else { b[t&#43;&#43;]=a[i&#43;&#43;]; } } while(i&lt;=mid) b[t&#43;&#43;]=a[i&#43;&#43;];//如果有一方元素比较完了，另一方的元素直接塞进去 while(j&lt;=high) b[t&#43;&#43;]=a[j&#43;&#43;]; for(i=0;i 四.代码 import java.util.Scanner;public class Sort { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=sc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e10804bc50be1b34b584030ea355b06e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-06T01:29:25+08:00" />
<meta property="article:modified_time" content="2020-12-06T01:29:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分治法的基本思想_归并排序-分治思想的典型应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p class="pgc-end-literature">前面的文章讲了二分查找算法，这种算法使用了一种非常常见的思想–"分治思想"。所谓分治，就是"分而治之"，当解决一个大问题时，如果问题太大而无法直接解决，就可以试着把问题分解成很多个相互独立的子问题，将每个子问题各个击破，最后每个子问题得到的结果一合并就得出了原问题的结果，分治法一般都通过递归实现。本文讲解的归并排序就是分治思想的经典应用。</p> 
 <h2 class="pgc-h-arrow-right">一.基本思想</h2> 
 <p>1. 分解：给出包含若干个数的一段序列。按照分治思想要把序列分成两部分，然后对每个部分，再以相同的方式分成两个更小的序列。就这样一直分下去，到最后每段序列都只有一个数了。无法再分解了，那该怎样排序呢？答案是不用排序了，每个序列都只有一个数还怎么排序呢，换句话说，只有一个数，这本身就是有序的。这就是分治算法的妙处，把一个无序的序列分成了若干个有序的序列。</p> 
 <p>2. 合并：合并是整个排序算法的难点和重点。阐述起来很简单，就是把分开的子序列两两按序合并。</p> 
 <p>· 说起来很简单，要想真正的理解并不容易，以图解的形式描述归并的过程更直观一些。</p> 
 <h2 class="pgc-h-arrow-right">二.图解</h2> 
 <p>分解的步骤很简单。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/76/1a/0pGNYnpX_o.png" alt="5bd7cc3f1856a98e8ed6b76a5d398a53.png"> 
 </div> 
 <p>把整个序列分成多个仅有一个数的序列后，开始合并。</p> 
 <p>第一趟合并</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/a7/5d/5g4cqnzi_o.png" alt="0d33ee2b993fb0f060c2833595b0edfa.png"> 
 </div> 
 <p>第二趟合并</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/32/32/GzcwwtLS_o.png" alt="c10278e5254becb7c4eb36afecc3c947.png"> 
 </div> 
 <p>第三趟合并</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/2f/74/6wrs6EGy_o.png" alt="b186dbeeabe1275623acff5dee4f36b9.png"> 
 </div> 
 <p>在不断合并的过程中，序列中的元素就自动排好了序。</p> 
 <h2 class="pgc-h-arrow-right">三.具体实现</h2> 
 <p>上述就是归并排序的思路，那具体是如何实现的呢？</p> 
 <p>我们要先定义一个临时数组b[]，我们将被排序的数组命名为数组a[]。在两个序列合并的过程中，要先将两个序列中的元素进行比较，再按顺序存放到临时数组b[]中，这样b[]中的元素就是有序的，再将b[]中的数组复制到a[]中。以最后一次合并为例(由于合并的两序列也都经过了多次比较和合并之后才形成，所以也是有序的)</p> 
 <p>注：下文的比较过程中用的首个元素并不是序列本身的首个元素，序列本身的首个元素是固定不变的，这里的首个元素是序列中未进行比较的元素中的首个元素。</p> 
 <p>(1)第一次比较，4&lt;7，4放入临时数组，12变成了第一个序列的首个元素。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/ab/c5/DtaFrPuA_o.png" alt="f0a69ee0f7d9f2d5bc83eae927064cf3.png"> 
 </div> 
 <p>(2)第二次比较，7&lt;12，7放入临时数组，16变成了第二个序列的首个元素。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/00/8c/128BQkqf_o.png" alt="8caeae8a73d3dd5167934ac370904147.png"> 
 </div> 
 <p>(3)第三次比较，12&lt;16，12放入临时数组，13变成了第一个序列首个元素。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/7e/99/tM3d0OYB_o.png" alt="2174f801dcbee7ce99e320451570a708.png"> 
 </div> 
 <p>(4)第四次比较，13&lt;16，13放入临时数组，50变成了第一个序列的首个元素。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/d6/1c/dfTNS2fJ_o.png" alt="e1d4cd4cbc0bacb71a1897022a4244e8.png"> 
 </div> 
 <p>(5)第五次比较，16&lt;50，16放入临时数组，25变成了第二个序列的首个元素。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/fe/78/sKOiDNSY_o.png" alt="fad42c3f30411200102b0af4e6a72156.png"> 
 </div> 
 <p>(6)第六次比较，25&lt;50，25放进临时数组，33变成了第二个序列的首个元素。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/6a/dc/4eKovmyU_o.png" alt="51e4a90d09968e6cdfe1b9b3a7aaa071.png"> 
 </div> 
 <p>(7)第七次比较，33&lt;50，33放进临时数组，第二个序列的元素全部被安排了。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/fa/65/CQCyIfcH_o.png" alt="f9c415af3210dcab07ed9fed4c3843ff.png"> 
 </div> 
 <p>(8)第八次比较，发现第二个序列都比完了，这时候就把第一个序列中的剩余元素(其实也就一个了)按序放进数组。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/06/32/6oV1cFRg_o.png" alt="94298ec0ca201d7b110f31481763a632.png"> 
 </div> 
 <p>这段过程的实现代码为</p> 
 <pre class="has"><code>private static void Merge(int a[],int low,int mid,int high){        int[] b=new int[high-low+1];//开临时数组        int i=low,j=mid+1,t=0,t1=0;//i,j分别作为两部分的指针        while(i&lt;=mid&amp;&amp;j&lt;=high){//两部分比较，小的进临时数组            if(a[i]&gt;a[j]){                b[t++]=a[j++];            }else {                b[t++]=a[i++];            }        }        while(i&lt;=mid) b[t++]=a[i++];//如果有一方元素比较完了，另一方的元素直接塞进去        while(j&lt;=high) b[t++]=a[j++];        for(i=0;i</code></pre> 
 <h2 class="pgc-h-arrow-right">四.代码</h2> 
 <pre class="has"><code>import java.util.Scanner;public class Sort {    public static void main(String[] args) {        Scanner sc=new Scanner(System.in);        int n=sc.nextInt();        int[] a=new int[n];        for(int i=0;ia[j]){                b[t++]=a[j++];            }else {                b[t++]=a[i++];            }        }        while(i&lt;=mid) b[t++]=a[i++];        while(j&lt;=high) b[t++]=a[j++];        for(i=0;i</code></pre> 
 <p>如果您觉得这篇文章对您有所帮助，欢迎关注我的微信公众号–【堆栈树图】，阅读更多的类似文章。如果您发现该文章有错误或不足之处，也欢迎批评指正。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7345ca48491dc4d8ab00e82db58976e4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Binary Insertion Sort-折半插入排序，介绍，伪代码，复杂度计算，在java上的案例应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f94d4b551f472f15e9477eb3d77acf09/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【git】解决ssh: connect to host ssh.github.com port 22: Connection timed out的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>