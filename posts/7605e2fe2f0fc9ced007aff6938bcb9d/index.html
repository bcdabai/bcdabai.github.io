<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FPGA逻辑面试笔试准备材料 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FPGA逻辑面试笔试准备材料" />
<meta property="og:description" content="目录 背景专业问题问题1 状态机的编码面试2 串口线最长有多少米问题3 负数补码的计算问题4 化简逻辑表达式问题5 什么是组合逻辑？什么是时序逻辑？问题6 谈一谈竞争冒险的产生、解决方案。问题7 谈一谈锁存器和触发器的区别问题8 谈一谈阻塞逻辑和非阻塞逻辑的区别。问题9 用异或门怎么构建非门？问题10 使用二选1选择器和一个非门实现异或问题11 使用二选一选择器mux构建或门问题12 用状态机进行序列检测问题13 什么是同步逻辑和异步逻辑问题14 如何理解触发器要满足建立/保持时间？问题15 什么是亚稳态？为什么两级触发可以防止亚稳态？问题16 时序约束的计算题问题17 解释FPAG和ASIC的概念及区别问题18 解释相关名词问题 19 数制转换问题 20 跨时钟域的几种方法问题 21 用与非门等设计一个全加法器问题 22 理解MOS门电路，根据门电路，写出表达式问题 23 关于FIFO的深度计算，你是如何理解？场景1、fa&gt;fb with no idle cycles in both write and read场景2 fa&gt;fb with two clock cycle delay between two successive read and write场景3 fa&gt;fb with idle cycles in both write and read场景4 fa 背景 由于平时也没太注重基础，这次针对我本人，自己准备了一些面试官可能问到的，以及网上别人被面试到的问题，问题的难度都不大，但你不复习也许就不行。
我的文章禁止转载！！！你可以收藏！
QQ：1183699227
资料推荐：
https://blog.csdn.net/ciscomonkey/article/details/102941101
专业问题 问题1 状态机的编码 在使用Verilog描述状态机时，通常用参数定义语句 parameter指定状态编码。常用的状态编码有三种分别是：递增二进制编码，格雷码和one-hot编码。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7605e2fe2f0fc9ced007aff6938bcb9d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-07T16:07:39+08:00" />
<meta property="article:modified_time" content="2019-10-07T16:07:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FPGA逻辑面试笔试准备材料</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">背景</a></li><li><a href="#_8" rel="nofollow">专业问题</a></li><li><ul><li><a href="#1__9" rel="nofollow">问题1 状态机的编码</a></li><li><a href="#2__16" rel="nofollow">面试2 串口线最长有多少米</a></li><li><a href="#3__34" rel="nofollow">问题3 负数补码的计算</a></li><li><a href="#4__52" rel="nofollow">问题4 化简逻辑表达式</a></li><li><a href="#5__91" rel="nofollow">问题5 什么是组合逻辑？什么是时序逻辑？</a></li><li><a href="#6__97" rel="nofollow">问题6 谈一谈竞争冒险的产生、解决方案。</a></li><li><a href="#7__114" rel="nofollow">问题7 谈一谈锁存器和触发器的区别</a></li><li><a href="#8__124" rel="nofollow">问题8 谈一谈阻塞逻辑和非阻塞逻辑的区别。</a></li><li><a href="#9__128" rel="nofollow">问题9 用异或门怎么构建非门？</a></li><li><a href="#10_1_132" rel="nofollow">问题10 使用二选1选择器和一个非门实现异或</a></li><li><a href="#11_mux_141" rel="nofollow">问题11 使用二选一选择器mux构建或门</a></li><li><a href="#12__159" rel="nofollow">问题12 用状态机进行序列检测</a></li><li><a href="#13__252" rel="nofollow">问题13 什么是同步逻辑和异步逻辑</a></li><li><a href="#14__256" rel="nofollow">问题14 如何理解触发器要满足建立/保持时间？</a></li><li><a href="#15__264" rel="nofollow">问题15 什么是亚稳态？为什么两级触发可以防止亚稳态？</a></li><li><a href="#16__267" rel="nofollow">问题16 时序约束的计算题</a></li><li><a href="#17_FPAGASIC_281" rel="nofollow">问题17 解释FPAG和ASIC的概念及区别</a></li><li><a href="#18__283" rel="nofollow">问题18 解释相关名词</a></li><li><a href="#_19__290" rel="nofollow">问题 19 数制转换</a></li><li><a href="#_20__296" rel="nofollow">问题 20 跨时钟域的几种方法</a></li><li><a href="#_21__297" rel="nofollow">问题 21 用与非门等设计一个全加法器</a></li><li><a href="#_22_MOS_298" rel="nofollow">问题 22 理解MOS门电路，根据门电路，写出表达式</a></li><li><a href="#_23_FIFO_323" rel="nofollow">问题 23 关于FIFO的深度计算，你是如何理解？</a></li><li><ul><li><a href="#1fafb_with_no_idle_cycles_in_both_write_and_read_336" rel="nofollow">场景1、fa&gt;fb with no idle cycles in both write and read</a></li><li><a href="#2_fafb_with_two_clock_cycle_delay_between_two_successive_read_and_write_355" rel="nofollow">场景2 fa&gt;fb with two clock cycle delay between two successive read and write</a></li><li><a href="#3_fafb_with_idle_cycles_in_both_write_and_read_360" rel="nofollow">场景3 fa&gt;fb with idle cycles in both write and read</a></li><li><a href="#4_fafb_with_no_idle_cycles_in_both_write_and_read_379" rel="nofollow">场景4 fa</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>背景</h2> 
<p>由于平时也没太注重基础，这次针对我本人，自己准备了一些面试官可能问到的，以及网上别人被面试到的问题，问题的难度都不大，但你不复习也许就不行。<br> <strong>我的文章禁止转载！！！你可以收藏！</strong><br> QQ：1183699227<br> 资料推荐：<br> https://blog.csdn.net/ciscomonkey/article/details/102941101</p> 
<h2><a id="_8"></a>专业问题</h2> 
<h3><a id="1__9"></a>问题1 状态机的编码</h3> 
<p>在使用Verilog描述状态机时，通常用参数定义语句 parameter指定状态编码。常用的状态编码有三种分别是：递增二进制编码，格雷码和one-hot编码。<br> <img src="https://images2.imgbox.com/16/23/YvpJ8MVd_o.png" alt="在这里插入图片描述"><br> 递增的二进制码在转台跳转条件比较复杂的时候会导致很大的组合逻辑。<br> 格雷码，这种编码方式能够避免进入错误的状态，常用于高可靠性设计。<br> 独热码，这种编码所占用的D触发器资源比递增二进制编码多一些，速度非常快。<br> 个人理解：格雷码非常可靠，建议格雷码</p> 
<h3><a id="2__16"></a>面试2 串口线最长有多少米</h3> 
<p>异步串行是指UART，通用异步接收/发送。<br> UART包含了TTL电平的串口和RS232电平的串口。<br> <strong>RS232</strong><br> RS232采用不平衡传输方式，即所谓的单端通讯，由于发送电平与接收电平的差仅仅为2V到3V左右，所以其共模抑制能力差，再加上双绞线上的分布电容，其传送距离最大为约15米，在115200波特率的情况下，最高速率为<code>11.5KByte/s</code><br> <strong>RS422</strong></p> 
<p>RS422定义了四线接口，实际上还有一根地线。RS422支持最多10个节点，即一个主设备，其余从设备，从设备之间不能通信，所以RS422支持点对多的双向通信。RS422的最大传输距离为1219米，最大传输速率为<code>10Mb/s</code>。其平衡双绞线的长度与传输速率成反比，在 100kb/s速率以下，才可能达到最大传输距离。只有在很短的距离下才能获得最高速率传输。一般100米长的双绞线上所能获得的最大传输速率仅为 1Mb/s。<br> <strong>RS-485</strong><br> RS 485与RS232类似，只是有二线和四线，所以可以最大带有32个从属设备。</p> 
<p><strong>USB设备 2.0</strong></p> 
<p>最新的USB2.0可以达到<code>480Mbps</code>，最长5米。</p> 
<p><strong>USB 3.0</strong><br> <code>5.0Gbps</code> (500MB/s)，从5米突破到100米。</p> 
<h3><a id="3__34"></a>问题3 负数补码的计算</h3> 
<p>其实这个问题以前我就写过，这里仅仅拿出例子来，回顾一下。<br> https://blog.csdn.net/ciscomonkey/article/details/87104636<br> <strong>正数的反码就是原码，负数的反码等于原码除符号位以外所有的位取反</strong><br> <strong>补码：符号位保持不变，其余位取反加1</strong></p> 
<pre><code>原码：-8，-8的源码是1【1000】，取反码：1【0111】，补码：1【1000】（十进制转二进制）
原码：-4，-4的原码是1100，取反码：1011， 补码：1100（十进制转二进制）

补码：1000，-8
补码：1100，说明此数是负数，减1，得1011，取反：1100，十进制4：因此为-4. 
</code></pre> 
<p>在不超限溢出的前提下，如果计算结果为正数，那么补码与原码相同，得到的就是正确结果； 如果计算结果为负数，还需要将补码再转换成原码。<br> -4+2=1100+0010=1110 =1101（减1）=1010（取反）= -2<br> -6+7=1010+0111=10001 == = 》舍去溢出得0001</p> 
<p>通过以上练习，足以了。只需要牢记正数的反码就是源码，负数的补码等于源码除了符号位以外所有的位取反再加1.【除符取反加1】<br> 通过计算后的补码要转换成源码。</p> 
<h3><a id="4__52"></a>问题4 化简逻辑表达式</h3> 
<p><img src="https://images2.imgbox.com/58/3e/wXW9zP0k_o.png" alt="在这里插入图片描述"><br> 基本运算无非就是上述7种，上述有几处公式有误，但是图片做的好看。以国际图片为准。<br> 下面我对其总结：<br> <strong>与、或、非<br> 与非：AB条件都具备、Y不发生<br> 或非：任意条件具备、Y不发生<br> 异或：条件AB不同，则Y发生<br> 同或：条件AB相同，则Y发生</strong></p> 
<p>那么在verilog种要实现与非、或非、异或、同或运算是不是也只需要一个符号呢？答案是不行的，我们需要用与或非三种运算符号组合起来。<br> 为什么要化简？<br> 当表达式复杂时，其对应的数字电路所使用的元器件就会比较复杂，减少元器件可以提高电路的可靠性。<br> 这里就介绍卡诺图化简法吧，公式我记不住。<br> 首先找出最小项，最小项就是乘积项在输入随机的情况下，结果为1的可能性最小。n个变量可以构成2^n个最小项。<br> <img src="https://images2.imgbox.com/c6/95/kZtTSc8E_o.png" alt="在这里插入图片描述"><br> 如何写出卡诺图？<br> <img src="https://images2.imgbox.com/81/d5/DjIQ2XlK_o.png" alt="在这里插入图片描述"><br> 我们可以观察到最小项都是用格雷码编码的，然后序列号就是格雷码的十进制<br> <img src="https://images2.imgbox.com/50/a9/nuBZw6PZ_o.png" alt="在这里插入图片描述"><br> 注意，遵循A为最高位的原则<br> 卡诺图的化简：谁变了，干掉谁的原则，其实，我们只用观察谁不变，保留谁即可<br> <img src="https://images2.imgbox.com/2d/ff/pYzBxWQf_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6d/c4/4oAAJvas_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/34/22/QWpLhCMC_o.png" alt="在这里插入图片描述"><br> 掌握了上述如何化简卡诺图后，接下来，我来说明一下根据表达式，如何画出卡诺图吧<br> <img src="https://images2.imgbox.com/dc/c3/gFZYGpR7_o.png" alt="在这里插入图片描述"><br> 其实就是将只要有表达式出现的那一项，都写上1。<br> <img src="https://images2.imgbox.com/f2/cc/vQIJKjII_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/14/c5/U5Vf5agV_o.png" alt="在这里插入图片描述"><br> 对于一般的表达式，需要将其转换为最小项的形式。</p> 
<p>补充：公式法如何转换为最小项。<br> <img src="https://images2.imgbox.com/4a/35/1vogaMmF_o.png" alt="在这里插入图片描述"><br> 其中反演律最为重要，利用反演律可以化简为最小项。然后利用卡诺图化简。<br> <img src="https://images2.imgbox.com/ab/89/eHcwOCVG_o.png" alt="在这里插入图片描述"><br> 上面给了个练习题，具体卡诺图化简步骤，这里不再赘述了，我做过，和上述结果一样。</p> 
<h3><a id="5__91"></a>问题5 什么是组合逻辑？什么是时序逻辑？</h3> 
<p>在数字电路中，根据逻辑功能的不同，我们可以将数字电路分为2大类，一类叫做组合咯及电路，另一类叫时序逻辑电路。<br> <img src="https://images2.imgbox.com/c8/32/aRAWT2bG_o.png" alt="在这里插入图片描述"><br> 输出只与当前的输入有关系，而与输入信号的上一个状态没有关系。<br> 而时序电路是有记忆功能的，它在任何时刻的输出，不仅与该时刻的输入信号有关，而且还与该时刻以前的输入信号有关。</p> 
<h3><a id="6__97"></a>问题6 谈一谈竞争冒险的产生、解决方案。</h3> 
<p><img src="https://images2.imgbox.com/5b/fb/ygGVZyfV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a3/42/0Ot3VK02_o.png" alt="在这里插入图片描述"><br> 若输入变量在卡诺图的圈内发生改变时候，则输出不会有冒险现象，若输入变量是在相邻卡诺圈的相邻处发生变化，并且从一个卡诺圈进入到另一个卡诺圈，则可能产生逻辑冒险。<br> <img src="https://images2.imgbox.com/0d/b6/VgX1oscz_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a3/5a/xkrvwWLQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e2/98/efoti7Yo_o.png" alt="在这里插入图片描述"><br> 通过增加冗余项来消除逻辑冒险。<br> <img src="https://images2.imgbox.com/08/ef/M3KhTKnH_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e3/2a/2mL1kS1L_o.png" alt="在这里插入图片描述"><br> 有两个以上同时变化比如0001变到0111，可能走0101这条路，或者走0011这条路。所以两者是有差别的，如果走0011这条路就会发生功能冒险，解决方法只有增加选通信号或者输出电容。（个人建议是寄存2拍）<br> 信号由于经由不同路径传输达到某一汇合点的时间有先有后的现象，就称之为竞争，由于竞争现象所引起的电路输出发生瞬间错误的现象，就称之为冒险。FPGA设计中最简单的避免方法就是尽量使用时序逻辑同步输入输出。</p> 
<p>加滤波电容，消除毛刺的影响；<br> 加选通信号，避开毛刺<br> 增加冗余项，消除逻辑冒险</p> 
<h3><a id="7__114"></a>问题7 谈一谈锁存器和触发器的区别</h3> 
<p>常用的存储电路有两类，一类是锁存器，另一类是触发器，它们两者所采用的电路结构形式不同，信号的触发方式也不同，其中，采用电平触发方式的叫做锁存器，而采用脉冲边沿触发方式的叫做触发器。</p> 
<p>锁存器（latch）是数字电路中的一种具有记忆功能的逻辑元件。锁存器对脉冲电平敏感的存储单元电路，它只在输入脉冲的高（低）电平期间对输入信号敏感并改变状态。<br> 这里介绍一种D锁存器，多说两句，当控制门等于1时，此时锁存器的状态是由激励输入端D来确定的，并且D等于什么，锁存器的状态就是什么。</p> 
<p>触发器（Flip-Flop）是对脉冲边沿敏感的存储单元电路，它只在触发脉冲的上升沿（或者下降沿）瞬间改变其状态。</p> 
<p><img src="https://images2.imgbox.com/66/10/qWzoPvvU_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="8__124"></a>问题8 谈一谈阻塞逻辑和非阻塞逻辑的区别。</h3> 
<p>非阻塞逻辑用&lt;=<br> 使用阻塞逻辑可以在几个ns内完成</p> 
<h3><a id="9__128"></a>问题9 用异或门怎么构建非门？</h3> 
<p>这个问题，我们首先要知道异或门，就是相异为1，相同为0.<br> 用异或门实现非门：只需将输入与高电平进行异或就行了。</p> 
<h3><a id="10_1_132"></a>问题10 使用二选1选择器和一个非门实现异或</h3> 
<p><img src="https://images2.imgbox.com/2d/7f/DKXo7SST_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="11_mux_141"></a>问题11 使用二选一选择器mux构建或门</h3> 
<pre><code>
module FPGA_mianshi 
(
input a,
input b,
output q

);
assign q=a?1:b;
endmodule


</code></pre> 
<p><img src="https://images2.imgbox.com/26/ec/bZU26dfE_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="12__159"></a>问题12 用状态机进行序列检测</h3> 
<p>用序列检测机，检测一串数字序列：<br> 1101</p> 
<pre><code>
//检测序列1101

module FPGA_mianshi (
    input clk,  
    input rst,  
    input  data,		//输入串行数据流
    output reg valid	//代表检测到输入数据
    );  
    

localparam s1=3'b001;
localparam s2=3'b011;
localparam s3=3'b010;
localparam s4=3'b110;

reg [2:0] now_state=s1;
reg [2:0] next_state=s1;

always @ (posedge clk or negedge rst)
begin
	if(!rst)
		now_state&lt;=s1;
	else
		now_state&lt;=next_state;
end

always @ (*)	//实现条件转换
begin
	case(now_state)
		s1:
			if(data==1)
				begin
					next_state=s2;
				end
			else
				begin
					next_state=s1;
				end
			
		s2:
			if(data==1)
				begin
					next_state=s3;
				end
			else
					next_state=s1;
		s3:
			if(data==0)
				begin
					next_state=s4;
				end
			else 
				begin
					next_state=s3;
				end

		s4:
			if(data==1)
				begin
					next_state=s1;
					
				end
			else
					next_state=s1;
		default:next_state=s1;
		endcase
end
always @ (posedge clk or negedge rst)
begin
	if(!rst)
		valid&lt;=0;
	else
		begin
			if((now_state==s4)&amp;(data==1))
				valid&lt;=1;
			else
				valid&lt;=0;
		end
end
endmodule

</code></pre> 
<p><img src="https://images2.imgbox.com/46/4e/e17JzpWJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f3/d3/qbK2KaqL_o.png" alt="在这里插入图片描述"><br> 这种题目一定要先考虑出状态图，比如，我这个1101，每种状态无非要么0，要么1.<br> 比如已经出了 11了，那么接下来检测第三个数据是1还是0，如果是0，那么继续，如果是1，我们就要回到初始状态吗？答案是否定的，因为111，能够证明已经检测到了11两个连续了，所以，此时我们要停留在此状态，如果还是1，那么就成了1111，也满足了检测到两个1，直到我们检测到0，才迈向下一个状态。<br> 所以序列检测，千万不要认为简单，这些细节，稍不注意，你可能出现漏检的情况。</p> 
<h3><a id="13__252"></a>问题13 什么是同步逻辑和异步逻辑</h3> 
<p>同步逻辑是时钟之间有固定的因果关系，异步逻辑是各时钟时间没有固定的因果关系。<br> 同步逻辑必须要收到时钟脉冲的控制；异步逻辑，只要输入变化，输出就立即变化。</p> 
<h3><a id="14__256"></a>问题14 如何理解触发器要满足建立/保持时间？</h3> 
<p>电路设计的难点在于时序设计，时序设计的实质就是满足每一个触发器的建立/保持时间而要求的</p> 
<p>建立时间：触发器在时钟上升沿到来之前，其数据输入端的数据必须保持不变的时间。<br> 保持时间：触发器在时钟上升沿到来之后，其数据输入端的数据必须保持不变的时间。</p> 
<p>因为触发器内部数据的形成是需要一定的时间的，如果不满足建立和保持时间，触发器将进入亚稳态，进入亚稳态后触发器的输出将不稳定，在0和1之间变化，这时候需要经过一个恢复时间，其输出才能稳定，但稳定后的值并不一定是你的输入值。这就是为什么要用两级触发器来同步异步输入信号（这一点在检测外部输入触发，尤为有经验，这也是我之间检测外部触发信号上升沿，为什么都要用2级检测，否则不稳定，但是在系统内部，我只需要一级检测即可）。这样做可以防止由于异步输入细心好对于本级时钟可能不满足建立保持时间而使本级触发器产生的亚稳态传播到后面逻辑中，导致亚稳态的传播。</p> 
<h3><a id="15__264"></a>问题15 什么是亚稳态？为什么两级触发可以防止亚稳态？</h3> 
<p>亚稳态是指触发器无法再某个规定的时间段内到达一个可以确认的状态。使用两级触发器来使异步电路同步化的电路其实叫做“一步同位器”，他只能用来对他只能用来对一位异步信号进行同步。两级触发器可以防止亚稳态传播的原理：假设第一级触发器的输入不满足建立保持时间，它在第一个脉冲沿到来后输出的数据就为亚稳态，那么在下一个脉冲沿到来之前，其输出的亚稳态数据在一段恢复时间后必须稳定下来，而稳定的数据必须满足第二级触发器的建立时间，如果都满足了，在下一个脉冲沿到来时，第二级触发器将不会出现亚稳态，因为其输入端的数据满足其建立保持时间。</p> 
<h3><a id="16__267"></a>问题16 时序约束的计算题</h3> 
<p>这个问题，以前我专门花了不少力气写过，并从官方文档入手，这里再次拿出来回顾<br> https://blog.csdn.net/ciscomonkey/article/details/88877296</p> 
<p><img src="https://images2.imgbox.com/fb/49/CRYpNXD2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4c/86/FADlUs6m_o.png" alt="在这里插入图片描述"><br> 上述公式可以说，充分总结了如何计算建立时间余量（slack）的方法。注意这是同步系统时钟信号。<br> 只要好好领悟，非常简单。</p> 
<p>下面，我建议自己手推hold slack的公式。<br> <img src="https://images2.imgbox.com/74/69/r95m3A24_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/41/f0/RX5GmoNZ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="17_FPAGASIC_281"></a>问题17 解释FPAG和ASIC的概念及区别</h3> 
<h3><a id="18__283"></a>问题18 解释相关名词</h3> 
<p>SRAM：Static Random-Access Memory,静态随机存取存储器，主要是供电数据就会保持，但断电就会消失。也称之为Volatile memory.<br> SDRAM:Synchronous Dynamic Random Access Memory,同步动态随机存储器，同步写入和读出数据的DRAM。<br> EEOROM：Electrically Erasable Programmable Read Only Memory,电可擦除可编程只读存储器。<br> DDR：Double Data Synchronous Dynamic Random Accsee Memory,双倍速率同步动态随机存储器，双倍速率传输的SDRAM，在时钟的上升沿和下降沿都可以进行数据传输。我们的电脑内存条都是DDR芯片。<br> FLASH：flash memory,闪存，非易失性固态存储，如制成内存条或U盘。</p> 
<h3><a id="_19__290"></a>问题 19 数制转换</h3> 
<p>十进制数转换成R进制：整数部分，除R取余法，除到商为0为止，小数部分，乘R取整法，乘到积为0为止。<br> <img src="https://images2.imgbox.com/c8/0a/oSTTPpdg_o.png" alt="在这里插入图片描述"><br> 十进制小数转二进制<br> <img src="https://images2.imgbox.com/d5/1f/4AtwIhAW_o.png" alt="在这里插入图片描述"><br> 取整数部分即可。</p> 
<h3><a id="_20__296"></a>问题 20 跨时钟域的几种方法</h3> 
<h3><a id="_21__297"></a>问题 21 用与非门等设计一个全加法器</h3> 
<h3><a id="_22_MOS_298"></a>问题 22 理解MOS门电路，根据门电路，写出表达式</h3> 
<p>这个问题，问的组里的师兄，还是当面讲解效率高不少，然后下来简单看了一下视频就理解了。<br> <img src="https://images2.imgbox.com/2f/a0/wRUucH50_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/00/0d/5o3c3N1w_o.png" alt="在这里插入图片描述"><br> 箭头朝里，属于NMOS，所以左边属于NMOS，当G端大于S时，D、S之间相当于开关闭合，那么D与S之间可能电流D流向S，也可能S流向D。<br> 箭头朝外，属于PMOS，S大于G时，D与S之间相当于开关闭合<br> 通常来讲，S一般是接的电源，D端接的是输出。</p> 
<p>记忆：<br> 箭头往里NMOS、箭头朝外PMOS，箭头朝谁，谁更大。与G端靠近的是源极。</p> 
<p>例子：</p> 
<p><img src="https://images2.imgbox.com/83/aa/mob9KwQd_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/57/2e/x4f9NwfR_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5a/de/6f9eO4Y0_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/5f/9c/ACr0JiRI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e3/fb/lq6GCP6q_o.png" alt="在这里插入图片描述"><br> 参考视频：https://www.dianyuan.com/class/video_2123.html<br> <img src="https://images2.imgbox.com/26/de/oVf48XAM_o.png" alt="在这里插入图片描述"><br> 注意上述表示符号，PMOS就是有一个圆圈。NMOS是没有圆圈的。</p> 
<h3><a id="_23_FIFO_323"></a>问题 23 关于FIFO的深度计算，你是如何理解？</h3> 
<p>这一点，我查阅了诸多CSDN的blog，发现抄袭居多，很多人1是没讲清楚，2是也许作者自己也没有真正理解到位。下面，作为处女座，无法看下去了。根据自己的理解，以及我的抄袭阅读。来谈谈这个FIFO的深度计算处理跨时钟域数据问题。</p> 
<p>在数字IC设计中，我们经常遇到这种工作场景，工作在不同时钟域下的两个模块，它们之间需要进行数据传递，为了避免数据丢失，我们会使用到FIFO。当读数据的速率小于写数据的速率时候，我们就不得不将还没有被读走的数据缓存下来，那么我们需要开多大的控件缓存这些数据呢？缓存开大了，会浪费资源，开小了，会丢失数据，如何计算最小FIFO深度。</p> 
<p><strong>如何理解数据突发长度？为什么FIFO能解决？</strong><br> 首先，我得说一下数据突发长度（burst length）这个概念，如果模块A不间断的往FIFO中写数据，模块B同样不间断的从FIFO中读数据，不同的是模块A写数据的时钟频率大于B读数据的频率，那么如果系统一直在工作的话，有一部分数据还没来得及读走，新的数据又来了，也就是说那些没有被读走的数据会越累积越多，那么FIFO的深度需要无穷大，<code>因此只有在突发数据传输过程中讨论FIFO深度才是有意义的。</code>什么叫突发数据长度，那就好明白了，就是发送一段数据后，然后停下来等待。这一段数据就是突发数据长度（burst length）。<br> 这一点，很好理解，你想一下，如果饮水机的桶装水，小口朝下，大口接一个超大的水管。如果大口不断在注入水，小口同时在放水。这样，即使同时进行。但这桶水肯定会在一段时间后溢出来。那么，想一下，如果注入水和放水同时进行，但是一旦注入水刚要满的时候，我就停止继续注入水。这样就能保持水不会溢出来，水桶达到缓存水的目的。<br> 回到正题，也就是说我们一次传递一包数据完成后再去传递下一包数据，我们把一段时间内传递的数据个数称为burst length。<br> 在维基百科中，burst transmission是这样解释的：In telecommunication, a burst transmission or data burst is the broadcast of a relatively high-bandwidth transmission over a short period。在通信中，被解释为在较短的时间周期内，传输高带宽的数据。<br> 下面，为了更好的理解FIFO size的计算过程，这里在不套用计算公式的前提下来逐步计算不同场景FIFO深度，当然在本文的最后会给出FIFO深度的计算公式。<br> 在讨论之间A模块向FIFO写数据的时钟频率为fa，模块B从FIFO读数据的时钟频率为fb。</p> 
<h4><a id="1fafb_with_no_idle_cycles_in_both_write_and_read_336"></a>场景1、fa&gt;fb with no idle cycles in both write and read</h4> 
<p>写速率大于读速率，并且没有空闲周期，一直读与写。<br> 假设：</p> 
<ul><li>写数据时钟频率fa=80MHz</li><li>读数据时钟频率fb=50MHz</li><li>突发长度=number of data to be transferred =120</li><li>在突发传输过程中，数据都是连续读写的</li></ul> 
<p>计算：<br> 写120个数据需要的时间是：<br> 1/80（us）*120=1500 ns<br> 读一个数据需要20ns（50MHz）<br> 在1500ns内，读取了75个数据<br> 还剩余数据120-75个=45个数据<br> 也就是说在1500ns内还没有被读走的数据个数=45个<br> 因此FIFO的最小深度为45</p> 
<h4><a id="2_fafb_with_two_clock_cycle_delay_between_two_successive_read_and_write_355"></a>场景2 fa&gt;fb with two clock cycle delay between two successive read and write</h4> 
<p>场景2在场景1的基础上增加了一个假设，即读比写慢两拍。这种假设是真正存在的，在异步FIFO设计中，我们需要去判断FIFO的空满来保证逻辑的正确性，判断空满标志需要去比较读写指针，而读指针与写指针处在不同的时钟域中，我们需要采用格雷码和两级同步寄存器去降低亚稳态的概率，而两级同步必然会导致空满标志位的判断至少延迟2个cycle。对于空标志位来说，将写指针同步到读时钟域至少需要花费2个时钟，而在同步这段时间内有可能还会写入新的数据，因此同步后的写指针一定小于或等于（当且仅有同步时间内没有新数据写入的情况下才会等于）当前的写指针，所以此时判断不一定是真空；同理，对于满标志位来说，将读指针同步到读时钟域至少需要花费2个时钟，而在同步这段时间内有可能还会读出新的数据，因此同步后的读指针一定小于或等于当前读指针，所以此时判断并不一定是真满。</p> 
<p>通过上述讨论可以知道场景2的FIFO最小深度应该比场景1的FIFO最小深度45略大。</p> 
<h4><a id="3_fafb_with_idle_cycles_in_both_write_and_read_360"></a>场景3 fa&gt;fb with idle cycles in both write and read</h4> 
<p>fa&gt;fb 并且都有空闲周期</p> 
<ul><li>写时钟频率fa=80MHz</li><li>度数据时钟频率fb=50MHz</li><li>突发长度=number of data to be transferred =120</li><li>每隔1个cycle写一次</li><li>每隔3个cycle读一次<br> 计算：<br> 每隔一个一个cycle写一次，意味着2个cycle才写一个数据<br> 每隔3个cycle读一次，意味着4个cycle才读一个数据<br> 那么写120个数据需要时间：120<em>1/80</em>2=3000ns<br> 读一个数据需要时间：4*1/50=80ns<br> 在3000ns的时间内，读取数据 3000/80=37.5个<br> 那么还剩余数据：120-37.5=82.5个–》83个<br> 也就说，至少需要FIFO的深度为83个</li></ul> 
<h4><a id="4_fafb_with_no_idle_cycles_in_both_write_and_read_379"></a>场景4 fa&lt;fb with no idle cycles in both write and read</h4> 
<ul><li>写数据时钟频率fa=40MHz</li><li>读数据时钟频率fb=50MHz</li><li>突发长度=number of data to be transferred =120</li><li>在突发传输过程中，数据都是连续读写的</li></ul> 
<p>那么：<br> 由于读数据比写数据要快，因此FIFO只起到了过时钟域的作用，FIFO的最小深度为1即可。</p> 
<h4><a id="5_fafb_with_idle_cycles_in_both_write_and_read_388"></a>场景5 fa&lt;fb with idle cycles in both write and read</h4> 
<p>读的速率大于写的速率,但是读和写都有空闲期</p> 
<ul><li>写数据时钟频率fa=40MHz</li><li>读数据时钟频率fb=50MHz</li><li>突发长度=number of data to be transferred=120</li><li>每隔1个cycle写一次</li><li>每隔3个cycle读一次<br> 计算：<br> 每隔1个cycle写一次，意味着2个cycle才写一个数据<br> 每隔3个cycle读一次，意味着4个cycle才读一个数据<br> 写一个数据所需要的时间 2<em>1/40（us）=50ns<br> 120个数据传输完毕，需要120</em>50=6000ns<br> 读一个数据需要时间：4*1/50=80ns<br> 在6000ns的时间内，能够读取6000/80=75 个数据<br> 剩余数据：120-75=45个数据<br> 也就是说FIFO的最小深度为45个数据</li></ul> 
<h4><a id="6_fafb_with_no_idle_cycles_in_both_write_and_read_404"></a>场景6 fa=fb with no idle cycles in both write and read</h4> 
<ul><li>写数据时钟频率fa=50MHz</li><li>读数据时钟频率fb=50MHz</li><li>突发长度=number of data to be transferres =120<br> 那么<br> 如果读写时钟同源并且无相位1，可以不需要FIFO，否则FIFO的最小深度设置为1即可</li></ul> 
<h4><a id="7_fafb_with_idle_cycles_in_both_write_and_read_413"></a>场景7 fa=fb with idle cycles in both write and read</h4> 
<ul><li>写数据时钟频率fa=50MHz</li><li>读数据时钟频率fb=50MHz</li><li>突发长度=number of data to be transferred =120</li><li>每隔1个cycle写一次</li><li>每隔3个cycle读一次</li></ul> 
<p>计算：<br> 每隔1个cycle写一次，意味着2个cycle才写一个数据<br> 每隔3个cycle读一次，意味着4个cycle才读一个数据<br> 写一个数据需要的时间：2<em>1/50=40ns<br> 突发传输中，写完所有数据所需要的时间=120</em>40=4800ns<br> 读一个数据所需要的时间是4*1/50MHz=80ns<br> 在4800ns内能够读走的数据个数是4800/80=60<br> 还剩余数据120-60=60个数据<br> 因此FIFO的最小深度为60</p> 
<h4><a id="8_data_rates_are_givenread_and_write_randomimportant_431"></a>场景8 data rates are given,read and write random(important!!!)</h4> 
<p>在上面给出的场景中，我们给出的条件都是每隔几个时钟读写一次，这种周期性读写在实际中很常见。但是在工程设计中还存在着这样一种情况，只给出数据在一段时间内的读写速率，怎么读写完全随机，这种情况我们需要考虑最坏的一种情况避免数据丢失。在最坏的情形的情况中，读写的速率应该相差最大，也就是说<code>需要找出最大的写速率和最小的读速率。</code><br> 假设：<br> 写数据时钟频率fa=80MHz<br> 读数据时钟频率fb=50MHz<br> 在写时钟周期内，每100个周期就有40个数据写入FIFO<br> 在读时钟周期内，每10个周期可以有8个数据读出FIFO</p> 
<p>这里没有给出数据的突发长度，从假设中可以得出每100个周期就有40个数据写入FIFO，这里可能就有人会说突发长度就是40个数据，其实不是这样的，因为数据是随机写入FIFO的，需要考虑最坏的情形，即写速率最大的情形，只有如下所示的情形才是写速率最高的情形，burst length为80<br> <img src="https://images2.imgbox.com/1c/84/LYGYyjQs_o.png" alt="在这里插入图片描述"><br> 其实这一点也很好理解，也就是写入数据，连续写入的持续时间最长。<br> 那么读数据应该是怎么样的呢？读数据当然是越慢，情况越糟糕<br> 计算：<br> 连续写入80个数据需要的时间1/80（us）<em>80=1000ns<br> 由于每10个周期可以有8个数据读出FIFO；<br> 80个数据，需要B时钟的100个周期，也就是说需要100</em>1 /50=2000ns<br> 也就是说读这80个数据，需要2000ns，那么就是说在1000ns的时间能够读取1000 /（20ns*10/8）=40 个数据<br> 那么还剩下40个数据，所以需要FIFO 40个</p> 
<h4><a id="_450"></a>总结</h4> 
<p>1、从上面分析来看，求FIFO的最小深度主要有以下几个要点：<br> 不管在什么场景下，要确定FIFO的深度，关键在于计算出在突发读2、写这段时间内有多少个数据没有被读走；<br> 由于FIFO空满标志位的判断延迟，在实际应用中需要预留一些余量<br> 3、求FIFO深度需要考虑最坏的情形，读写的速率应该相差最大，也就是说需要找出最大的写速率和最小的读速率。<br> 4、下面给出网上的公式，就很好理解了，这些公式不用记忆，理解了就自然会做了。<br> <img src="https://images2.imgbox.com/08/2b/UbYyIBbI_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_24___457"></a>问题 24 如何解决高速数据接口？如何理解串并/并串 转换器</h3> 
<p>并行转换是载入并行的数据，在同步信号为有效电平时，寄存器内的数据被逐位移出。</p> 
<h3><a id="_460"></a>串转并思想</h3> 
<p>串并转换是在时钟驱动下，将单比特的位数据流输入寄存器，并依次诸逐位移动，直到寄存器满了为止，然后直接读取并行输出。<br> <img src="https://images2.imgbox.com/80/88/6L1NLIX6_o.png" alt="在这里插入图片描述"><br> 串行数据转并行数据的verilog:</p> 
<pre><code>reg [7:0]sda_reg;
//wire en;
 
always@(posedge clk or negedge rst_n)
	begin
		if(!rst_n)
			begin
				sda_reg&lt;=0;
			end
		else
			begin
				if(en)
					begin
						sda_reg&lt;={sda_reg[6:0],sda};  //将并转串模块输出的串行数据sda转入sda_reg的每一位（从低位到高位）
					end
				else
					begin
						sda_reg&lt;=0;
					end
			end
	end
	

</code></pre> 
<p>串并转换器，我们看到，其实就是流水线操作，如果输入为1Gbps<br> 那么可以转换为100M*位宽10位<br> 其实这样来理解上图，串行时钟是1ns更新一个数据，那么10ns（100M）就更新10个数，此时10个寄存器的数据都已经更新完毕，由于此时FPGA内部时钟的速度是100M。所以10个寄存器的数据都被更新，所以，实现100M采样10个bit。从而实现了串转并的思想。接口可以跑到1G以上，但是FPGA内部时钟只能够跑到400M就差不多了。通常一些高速的AD采样都是达到了1G，所以采用串转并的思想，可以实现对高速数据的处理。</p> 
<h3><a id="_494"></a>并转串的思想</h3> 
<p>并行数据转串行数据的verilog：</p> 
<h3><a id="25_FPGA_497"></a>问题25 谈谈FPGA的设计思想-流水线设计</h3> 
<p>流水线操作是处理高速设计中的一个常用设计手段。如果某个设计的处理流程分为若干步骤，而且整个数据处理是单流向的，即没有反馈或者迭代运算，前一个步骤的输出是下一个步骤的输入，则可以考虑采用流水线设计来提高系统的工作频率。<br> <img src="https://images2.imgbox.com/49/8b/frSr3a92_o.png" alt="在这里插入图片描述"><br> 在 WCDMA 设计中经常使用到流水线处理的方法，如 RAKE 接收机、搜索器、前导捕获等。流水线处理方式之所以频率较高，是因为复制了处理模块，它是面积换取速度思想的又一种具体体现。</p> 
<h3><a id="26_FIFO_502"></a>问题26 异步FIFO的设计</h3> 
<p>前面关于FIFO的深度计算，我已经介绍得很详细了。相信已经能够熟练掌握了，那么下面来看一下异步FIFO；<br> FIFO是一种先进先出的数据缓冲器，特点是没有外部的读写笛子。由于没有外部的地址信号，所以只能顺序的读写，而不能跳读。FIFO的读写是根据满和空信号设计。当FIFO满的时候不可以往里面写、当FIFO空的时候不能读数据。读FIFO的时候，内部的读指针自动加1当写FIFO的时候写指针自动加1.<br> 什么是异步FIFO，什么又是同步FIFO呢？<br> 异步FIFO简单的来说就是读写时钟不相同，同步FIFO就是读写的时钟相同。<br> 使用异步FIFO可以在两个不同的时钟域之间快速而方便的传输数据，起到跨时钟域处理的作用。经常用于处理跨时钟域问题。<br> 此外对于不同宽度的数据接口也可以采用FIFO进行缓冲，如8位输入，16位输出。<br> 如何使用异步FIFO，请参照我的另一篇blog：<br> https://blog.csdn.net/ciscomonkey/article/details/99702628</p> 
<h3><a id="27__511"></a>问题27 格雷码与二进制码的相互转换</h3> 
<p><img src="https://images2.imgbox.com/6c/3a/Kwt4gNX3_o.png" alt="在这里插入图片描述"><br> 格雷码的概念不用多说，就是相邻两个二进制，只有1位发生了变化。</p> 
<ul><li>二进制转换为格雷码<br> <img src="https://images2.imgbox.com/a1/29/893F8dQ1_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/74/cf/zpejnWUY_o.png" alt="在这里插入图片描述"><br> 简而言之，就是二进制新增一位最高位被默认为0，然后依次如上图所指做异或运算即可<br> 比如0101，转化为格雷码为0111</li><li>格雷码转二进制码（解码）<br> 同理，也是在格雷码的最高位新增一位0，然后从左边起，将每一位异或后得到的值与下一位再异或，直到最低位。就能得到格雷码转换后二进制码的值。</li></ul> 
<p>举例：<br> 如果采集器器采到了格雷码：1010<br> 就要将它变为自然二进制：<br> 0 与第四位 1 进行异或结果为 1<br> 上面结果1与第三位0异或结果为 1<br> 上面结果1与第二位1异或结果为 0<br> 上面结果0与第一位0异或结果为 0<br> 因此最终结果为：1100 这就是二进制码即十进制 12</p> 
<p>再举例：</p> 
<p><img src="https://images2.imgbox.com/99/a3/pZCTYhpG_o.png" alt="在这里插入图片描述"><br> 注意格雷码转二进制一定要从左边起！！！</p> 
<h3><a id="27_LSFR__536"></a>27 LSFR （线性反馈移位寄存器）的工作原理</h3> 
<p>线性反馈移位寄存器（LFSR）是内测试电路中的最基本标准模块，作为伪随机测试码产生器<br> 一个n阶的LFSR由n个触发器和若干个异或门组成。特点是产生伪随机序列的最大长度为2^n-1；</p> 
<p><img src="https://images2.imgbox.com/42/6b/Vbbq13ko_o.png" alt="在这里插入图片描述"></p> 
<pre><code>module test(
  CLR,
  CLK,
  EN,
  DIN,         //需要置进的数
  DOUT);
input CLR;
input CLK;
input EN;
input [7:0] DIN;
output DOUT;
wire DOUT;
reg din;
reg [7:0] state;

always @(posedge CLK)
  begin 
    if(CLR)
      begin
        state &lt;= 8'b00000000;
      end
    else
      begin
        if(EN)
          begin
            state&lt;=DIN; 
          end 
        else
          begin
            state[7:1] &lt;= state[6:0];
            state[0] &lt;= din;
          end
      end
  end
  
assign DOUT = state[7];
  
always @(state[7] or state[5]or state[4] or state[0])
  begin
    din = state[7] ^ state[5]^ state[4]^ state[0]; 
  end
    
endmodule

</code></pre> 
<h3><a id="24__589"></a>24 位运算</h3> 
<p><img src="https://images2.imgbox.com/6a/0e/YiotPeJ7_o.png" alt="在这里插入图片描述"><br> 特别要注意位运算Y与逻辑运算<br> <img src="https://images2.imgbox.com/38/17/HDe4lIBE_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="HR_594"></a>与HR的心理博弈</h2> 
<h3><a id="1_595"></a>面试心理战1</h3> 
<p>这里提一点，如果有人问你有offer了吗，就实话实说，有的话就说有了，因为这是你个人能力的体现，不然别人会以为你一个offer都没有，实力不行，可以不跟他们透露具体公司和待遇，这属于你自己的隐私，他不会强问的，所以，要自信，不要隐瞒自己的offer。</p> 
<h3><a id="2_599"></a>面试心理战2</h3> 
<p>（技术宅们一定要注意，你可能技术好，但是不给你展示的机会，一定要自己主动）这里强调一点。很重要：面试不要等着面试官问什么你说什么，你要掌握好节奏，你来带着面试官按照你的思路走，多说一些自己的好处，当然我不是让你不给面试官插嘴的机会，自己把握好度，说的好，就算技术不好可能一年比别人多好几万的工资，所以面试会说很重要，非常重要，特别重要。</p> 
<h3><a id="_603"></a>最后的总结</h3> 
<p>经过2个多星期在成都一个人奔波，一忽儿，电子科大，一忽儿，川大，备受各种打击，毕竟本科也不是211/985，研究生虽然我有自信敢说高于一般学校的平台，和川大，我也敢去竞争，但跟电子科大比，我自己还是心虚的。两星期奔波，收获了2个IC公司的offer，其他乱七八糟的小公司我就不提了，但是被某家小公司拒绝的时候，彻底清醒了我的大脑，别去小公司，他们养不起我们这种，也不会耐心等待我们的成长。年轻人，最好去个大公司，薪资低一点没关系，先把自己的平台一定要往上面提一档次，这样你才能去够得着下一个档次。<br> 以后，我可能不会太去关注FPGA这一块了，决定从新开始我的CSDN博客，从事IC相关，当然数字处理这一块，matlab仿真这一块，我不会放弃。因为这一次面试我被感觉到了，要设计一款IC，数字信号处理需要十分精通才行，这样才会有全局观念，这些参数对于IC设计时非常重要。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e162f6071ea43f87f2e45cfb175d1b71/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Qt--多线程间的互斥</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4bcbbd7835445a52f436104cde40076e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">proxmox的U盘制作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>