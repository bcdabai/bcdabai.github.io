<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>讨论：一个进程(Process)最多可以生成多少个线程(Thread) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="讨论：一个进程(Process)最多可以生成多少个线程(Thread)" />
<meta property="og:description" content="1.进程中创建线程的限制
默认情况下，一个线程的栈要预留1M的内存空间,而一个进程中可用的内存空间只有2G，所以理论上一个进程中最多可以开2048个线程,但是内存当然不可能完全拿来作线程的栈，所以实际数目要比这个值要小。
#include &#34;stdafx.h&#34;#include &lt;windows.h&gt;#include &lt;process.h&gt;#include &lt;assert.h&gt;volatile bool gbExitThread = false;HANDLE ghDataEvent = CreateEvent(NULL, FALSE, FALSE, NULL);UINT WINAPI SubThread(void* ptr){int nThreadID = *((int*)ptr);nThreadID&#43;&#43;;SetEvent(ghDataEvent);printf(&#34;%d线程启动/n&#34;, nThreadID);int i = 0;while(!gbExitThread){Sleep(10000);}return 0;}int _tmain(int argc, _TCHAR* argv[]){int nThreadCount = 10000;HANDLE* phaThread = new HANDLE[nThreadCount];int nErr = 0;for(int i = 0; i &lt; nThreadCount; i&#43;&#43;){phaThread[i] = (HANDLE)_beginthreadex(NULL, 0, SubThread, &amp;i, 0, NULL);if(phaThread[i] == 0){nErr = GetLastError();if(nErr == 8){printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/29a21d49b894ff81004b6d4fad3ac1db/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-10-09T18:15:00+08:00" />
<meta property="article:modified_time" content="2010-10-09T18:15:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">讨论：一个进程(Process)最多可以生成多少个线程(Thread)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="font-weight: bold;"><span style="font-size: medium;">1.进程中创建线程的限制</span></p> 
<p><span style="font-size: medium;">默认情况下，一个线程的栈要预留<span style="font-weight: bold; text-decoration: underline;">1M</span>的内存空间,而一个进程中可用的内存空间只有2G，所以理论上一个进程中最多可以开2048个线程,但是内存当然不可能完全拿来作线程的栈，所以实际数目要比这个值要小。</span></p> 
<p> </p> 
<p><textarea name="code" class="cpp">#include "stdafx.h"
#include &lt;windows.h&gt;
#include &lt;process.h&gt;
#include &lt;assert.h&gt;

volatile bool gbExitThread = false;
HANDLE ghDataEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

UINT WINAPI SubThread(void* ptr)
{
	int nThreadID = *((int*)ptr);
	nThreadID++;
	SetEvent(ghDataEvent);
	printf("%d线程启动/n", nThreadID);
	int i = 0;
	while(!gbExitThread)
	{
		Sleep(10000);
	}

	return 0;
}

int _tmain(int argc, _TCHAR* argv[])
{
	int nThreadCount = 10000;
	HANDLE* phaThread = new HANDLE[nThreadCount];
	int nErr = 0;
	for(int i = 0; i &lt; nThreadCount; i++)
	{
		phaThread[i] = (HANDLE)_beginthreadex(NULL, 0, SubThread, &amp;i, 0, NULL);

		if(phaThread[i] == 0)
		{
			nErr = GetLastError();
			if(nErr == 8)
			{
				printf("开启线程失败，存储空间不足!/n");
			}
			else
			{
				printf("开启线程失败，错误号%d/n", nErr);
			}

			break;
		}

		WaitForSingleObject(ghDataEvent, INFINITE);
	}

	return 0;
}</textarea> </p> 
<p> </p> 
<p><span style="font-size: medium;"><img src="https://images2.imgbox.com/13/2e/QBvKFWe3_o.gif" alt=""></span></p> 
<p> </p> 
<p><span style="font-size: medium;"><strong>2.如何突破2000个限制？<br></strong>    你也可以通过连接时修改默认栈大小，将其改的比较小，这样就可以多开一些线程。 如将默认栈的大小改成512K，这样理论上最多就可以开4096个线程。<br>    即使物理内存再大，一个进程中可以起的线程总要受到2GB这个内存空间的限制。比方说你的机器装了64GB物理内存，但每个进程的内存空间还是4GB，其中用户态可用的还是2GB。 </span></p> 
<p><span style="font-size: medium;">    如果是同一台机器内的话，能起多少线程也是受内存限制的。每个线程对象都要站用非页面内存，而非页面内存也是有限的，当非页面内存被耗尽时，也就无法创建线程了。 <br></span></p> 
<p><span style="font-size: medium;">    如果物理内存非常大，同一台机器内可以跑的线程数目的限制值会越来越大。  </span> </p> 
<p> </p> 
<p><span style="font-size: medium;"><strong>MSDN原文：</strong></span></p> 
<p><span style="font-size: medium;">“The number of threads a process can create is limited by the available virtual memory. By default, every thread has one megabyte of stack space. Therefore, you can create at most 2,048 threads. <span style="text-decoration: underline;">If you reduce the default stack size, you can create more threads.</span> However, your application will have better performance if you create one thread per processor and build queues of requests for which the application maintains the context information. A thread would process all requests in a queue before processing requests in the next queue.”</span></p> 
<p> </p> 
<p><span style="font-size: medium;"><strong></strong>可以通过修改CreateThread参数来缩小线程栈StackSize，例如</span></p> 
<p><textarea name="code" class="cpp">#include "stdafx.h"
#include &lt;windows.h&gt;
#include &lt;process.h&gt;
#include &lt;assert.h&gt;

volatile bool gbExitThread = false;
HANDLE ghDataEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

UINT WINAPI SubThread(void* ptr)
{
	int nThreadID = *((int*)ptr);
	nThreadID++;
	SetEvent(ghDataEvent);
	printf("%d线程启动/n", nThreadID);
	int i = 0;
	while(!gbExitThread)
	{
		printf("%d: %d/n", nThreadID, i++);
		Sleep(10000);
	}

	printf("%d线程退出/n", nThreadID);

	return 0;
}

int _tmain(int argc, _TCHAR* argv[])
{
	int nThreadCount = 10000;
	HANDLE* phaThread = new HANDLE[nThreadCount];
	int nErr = 0;
	for(int i = 0; i &lt; nThreadCount; i++)
	{
		phaThread[i] = (HANDLE)_beginthreadex(NULL, 512*1024, SubThread, &amp;i, STACK_SIZE_PARAM_IS_A_RESERVATION, NULL);
		if(phaThread[i] == 0)
		{
			nErr = GetLastError();
			if(nErr == 8)
			{
				printf("开启线程失败，存储空间不足!/n");
			}
			else
			{
				printf("开启线程失败，错误号%d/n", nErr);
			}

			break;
		}

		WaitForSingleObject(ghDataEvent, INFINITE);
	}

	return 0;
}</textarea> </p> 
<p> </p> 
<p><img src="https://images2.imgbox.com/f6/d2/t6XbF0zX_o.gif" alt=""></p> 
<p> </p> 
<p><span style="font-size: medium;"><strong>服务器端程序设计</strong></span></p> 
<p><span style="font-size: medium;">如果你的服务器端程序设计成：来一个client连接请求则创建一个线程，那么就会存在2000个限制（在硬件内存和CPU个数一定的情况下）。建议如下：</span></p> 
<p><span style="font-size: medium;">The "one thread per client" model is well-known not to scale beyond a dozen clients or so. If you're going to be handling more than that many clients simultaneously, you should move to a model where instead of dedicating a thread to a client, you instead allocate an object. (Someday I'll muse on the duality between threads and objects.) Windows provides I/O completion ports and a <strong>thread pool</strong> to help you convert from a thread-based model to a work-item-based model.</span></p> 
<h6><span style="font-size: medium;"><a name="nb"><span style="color: #000000;">1. Serve many clients with each thread, and use nonblocking I/O and <strong>level-triggered</strong> readiness notification</span></a></span></h6> 
<h6><span style="font-size: medium;"><a name="nb.edge"><span style="color: #000000;">2. Serve many clients with each thread, and use nonblocking I/O and readiness <strong>change</strong> notification</span></a></span></h6> 
<h6><span style="font-size: medium;"><a name="aio"><span style="color: #000000;">3. Serve many clients with each server thread, and use asynchronous I/O</span></a></span></h6> 
<h6><span style="font-size: medium;">上面几句哈的核心的思想是：使用异步I/O,和一个线程处理多个客户请求！！</span></h6>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf708f8cdf0d4d47d990b3602e0247f7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MFC中实现简单的位图显示、处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de10e7ddd83fee0ad327869fe36d55d1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaSE笔试题一套带答案(4)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>