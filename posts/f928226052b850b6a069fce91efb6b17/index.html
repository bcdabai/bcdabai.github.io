<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LM(列文伯格-马夸尔特)方法的个人理解，以及实现问题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LM(列文伯格-马夸尔特)方法的个人理解，以及实现问题" />
<meta property="og:description" content="前言 LM方法是适用于求解方程最小值的一种方法，在非线性优化的框架中，优化方法分为Line Search 和 Trust Region，也就是线搜索和信任域方法，它们是两种不同性质的方法。
不同之处:
LIne Search:不管当前迭代点X(k)到最优解X*之间的路径，每次迭代X(k)得到X(k&#43;1),都是使用该点的反向梯度方向进行值得寻找，这就导致了这样一种可能得问题：‘在靠近X*的时候，X(k)反复震荡，不容易收敛。这种情况特别是会发生在固定迭代步长的时候，Eg:对于求解f(x)=x^2的最优解X*,当X(k)=0.01,而迭代步长为1的时候，这个时候下一个X(k&#43;1)=-0.01，如此这就发生了震荡，无法收敛。这确实是特例，但是只要有这种情况存在，也就是我们能够找出一个情况算法有问题，我们就无法保证所需要优化的函数f(x)不存在这种性质。
代表:梯度下降法，牛顿法，高斯牛顿法。
Trust Region:对于当前迭代点X(k)，我们会找出一个合适的迭代区域||D(X(k&#43;1)-X(k))||&lt;=hk,hk&gt;0，下一个X(k&#43;1)产生于该区域内，然后寻找这个区域的内最佳的迭代向量dX(k)。同时uk会根据每次的X(k)来计算调整，这就i是信任域的普遍思想。
代表:LM法。
LM法的个人理解 具体的实现方法我不做说明，网络上已经有很多人进行了详细的介绍。
这里转载一个我认为没有问题的他人的博客。https://www.codelast.com/%e5%8e%9f%e5%88%9blm%e7%ae%97%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0/
这里需要说明的是，很多博主在描述到LM具体算法实现的伪代码描述时，大多会混淆拉格朗日乘子和信任域hk这两个参量。导致在说到具体实现的时候逻辑不清，在应该让h(k&#43;1)=2*h(k)的时候，说成h(k&#43;1)=h(k)/2。
下面来说明一下算法和LM思想原理之间的对应关系:
高斯牛顿法优化目标是，利用求导数为0，我们得到,但是这个要求必须是可逆矩阵，要求较为严格。
而LM算法优化目标是,因为约束条件的h(k)是迭代变化的，为了保证公式一致性，把约束条件改写成是加了约束条件的优化目标.利用拉格朗日乘子法进行转换成无约束目标，令。
采用拉格朗日乘数法确实需要解出不同情况下对应的*，但是在LM法中进行了这样的操作，把看成常数，相等于把问题转化成了数学建模中的规划问题，约束条件的权重为,而高斯牛顿法优化目标为,当时，两者同比重，也就是总优化目标同时考虑到了两者。这样我们就可以减少求解乘子的步骤，得到最终的迭代向量，特别的当D为单位矩阵时，表示信任域是一个球。
接下来讲述关键问题，也就是如何迭代u(k).
LM定义了这样一个比值参量,表征了实际下降量与一阶微分量（也就是近似下降量)的比值。
在算法伪代码中有这么一个判断:
如果,那么h(k&#43;1)=h(k)/2,也就是减小信任域，此时在具体的算法中u(k&#43;1)=2*u(k)；
如果,那么h(k&#43;1)=2*h(k),也就是增大信任域，此时在具体的算法中u(k&#43;1)=u(k)/2；
这其中的逻辑关系从LM迭代公式可以知道，因为如果实际下降比一阶近似小很多，那么表示二阶以上分量占了比较大的比重，这个时候非线性比较严重，那么就应该缩小信任域，u(k)增大，而的模长变小，也就是变化较小了。同理可说明另外的情况。
最后说明一下如果u(k)的迭代搞混了，也就是之前提到的，该增大的时候变小了，而该变小的时候增大了，这个时候会出现的问题。
最容易遇到的问题就是迭代过小，通过查看的模长||||2^(-k)，就是同一个数量级，而且收敛于非最优解，过早收敛了。产生这种情况的逻辑在于:当某一次迭代过程得到,本该u(k&#43;1)=u(k)/2,但是搞混的情况下u(k&#43;1)=2*u(k),下次的迭代将会变得更小，因为u(k&#43;1)=2*u(k)等价于信任域变小了。另外，这样一次比一次的迭代小了，而且还是指数变小，那么就会使得目标在非最优解上收敛。通过修改程序上的正常逻辑，我们可以验证这样的情况。
最后附上LM算法的matlab程序 链接：https://pan.baidu.com/s/1_3AF-ZRkU9DPlcgxoMY-DA 提取码：z7y8 复制这段内容后打开百度网盘手机App，操作更方便哦" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f928226052b850b6a069fce91efb6b17/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-04T21:56:51+08:00" />
<meta property="article:modified_time" content="2020-08-04T21:56:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LM(列文伯格-马夸尔特)方法的个人理解，以及实现问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p style="text-indent:33px;">LM方法是适用于求解方程最小值的一种方法，在非线性优化的框架中，优化方法分为Line Search 和 Trust Region，也就是线搜索和信任域方法，它们是两种不同性质的方法。</p> 
<p><strong>不同之处:</strong></p> 
<p style="text-indent:33px;">LIne Search:不管当前迭代点X(k)到最优解X*之间的路径，每次迭代X(k)得到X(k+1),都是使用该点的反向梯度方向进行值得寻找，这就导致了这样一种可能得问题：‘在靠近X*的时候，X(k)反复震荡，不容易收敛。这种情况特别是会发生在固定迭代步长的时候，Eg:对于求解f(x)=x^2的最优解X*,当X(k)=0.01,而迭代步长为1的时候，这个时候下一个X(k+1)=-0.01，如此这就发生了震荡，无法收敛。这确实是特例，但是只要有这种情况存在，也就是我们能够找出一个情况算法有问题，我们就无法保证所需要优化的函数f(x)不存在这种性质。</p> 
<p>代表:梯度下降法，牛顿法，高斯牛顿法。</p> 
<p style="text-indent:33px;">Trust Region:对于当前迭代点X(k)，我们会找出一个合适的迭代区域||D(X(k+1)-X(k))||&lt;=hk,hk&gt;0，下一个X(k+1)产生于该区域内，然后寻找这个区域的内最佳的迭代向量dX(k)。同时uk会根据每次的X(k)来计算调整，这就i是信任域的普遍思想。</p> 
<p>代表:LM法。</p> 
<h2>LM法的个人理解</h2> 
<p>具体的实现方法我不做说明，网络上已经有很多人进行了详细的介绍。</p> 
<p>这里转载一个我认为没有问题的他人的博客。<a href="https://www.codelast.com/%E5%8E%9F%E5%88%9Blm%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/" rel="nofollow">https://www.codelast.com/%e5%8e%9f%e5%88%9blm%e7%ae%97%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0/</a></p> 
<p>这里需要说明的是，很多博主在描述到LM具体算法实现的伪代码描述时，大多会混淆拉格朗日乘子<img alt="\lambda" class="mathcode" src="https://images2.imgbox.com/59/da/oqeIOTI1_o.gif">和信任域hk这两个参量。导致在说到具体实现的时候逻辑不清，在应该让h(k+1)=2*h(k)的时候，说成h(k+1)=h(k)/2。</p> 
<p><strong>下面来说明一下算法和LM思想原理之间的对应关系:</strong></p> 
<p style="text-indent:33px;">高斯牛顿法优化目标是<img alt="\bigtriangleup x*=arg min \frac{1}{2}||f(x)+J(x)\bigtriangleup x||" class="mathcode" src="https://images2.imgbox.com/43/12/v7DEzMUm_o.gif">，利用求导数为0，我们得到<img alt="\bigtriangleup x*=-(J(x)^{T}J(x))^{-1}J(x)f(x)" class="mathcode" src="https://images2.imgbox.com/b2/54/4f9ZSeyz_o.gif">,但是这个要求<img alt="J(x)^{T}J(x)" class="mathcode" src="https://images2.imgbox.com/ff/b3/DLIsSc8j_o.gif">必须是可逆矩阵，要求较为严格。</p> 
<p style="text-indent:33px;">而LM算法优化目标是<img alt="\bigtriangleup x*=arg min \frac{1}{2}||f(x)+J(x)\bigtriangleup x||,st.||D\Delta x||\leqslant h(k)" class="mathcode" src="https://images2.imgbox.com/a6/3a/huFhSq5l_o.gif">,因为约束条件的h(k)是迭代变化的，为了保证公式一致性，把约束条件改写成<img alt="g(\Delta x)=\frac{||D\Delta x||}{h(k)}-1\leq 0" class="mathcode" src="https://images2.imgbox.com/ce/87/3oMWUpVk_o.gif">是加了约束条件的优化目标.利用拉格朗日乘子法进行转换成无约束目标<img alt="\bigtriangleup x*=arg min \frac{1}{2}||f(x)+J(x)\bigtriangleup x||+\frac{\lambda}{2 }(\frac{||D\Delta x||}{h(k)}-1)" class="mathcode" src="https://images2.imgbox.com/b1/36/4qve771R_o.gif">，令<u><strong><img alt="u(k)=\frac{\lambda }{h(k)}" class="mathcode" src="https://images2.imgbox.com/04/7e/X50boTQu_o.gif"></strong></u>。</p> 
<p style="text-indent:33px;">采用拉格朗日乘数法确实需要解出不同情况下对应的<img alt="\lambda" class="mathcode" src="https://images2.imgbox.com/a0/39/0TW19ccM_o.gif">*，但是在LM法中进行了这样的操作，把<img alt="\lambda" class="mathcode" src="https://images2.imgbox.com/ee/c1/06swyFly_o.gif">看成常数，相等于把问题转化成了数学建模中的规划问题，约束条件的权重为<img alt="\frac{\lambda }{\lambda +1}" class="mathcode" src="https://images2.imgbox.com/4a/99/paZTK0le_o.gif">,而高斯牛顿法优化目标为<img alt="\frac{1}{\lambda +1}" class="mathcode" src="https://images2.imgbox.com/34/45/vIJMa4at_o.gif">,当<img alt="\lambda =1" class="mathcode" src="https://images2.imgbox.com/90/9a/xfYgKi41_o.gif">时，两者同比重，也就是总优化目标同时考虑到了两者。这样我们就可以减少求解乘子的步骤，得到最终的迭代向量<img alt="\bigtriangleup x*=-(J(x)^{T}J(x)+u(k)D^{T}D)^{-1}J(x)f(x)" class="mathcode" src="https://images2.imgbox.com/e7/3b/WM4eTOOf_o.gif">，特别的当D为单位矩阵<img alt="I" class="mathcode" src="https://images2.imgbox.com/d0/78/i5Af7VFQ_o.gif">时，表示信任域是一个球。</p> 
<p><strong>接下来讲述关键问题，也就是如何迭代u(k).</strong></p> 
<p>LM定义了这样一个比值参量<img alt="\rho(x,\Delta x) =\frac{f(x+\Delta x)-f(x)}{J(x)\Delta x}" class="mathcode" src="https://images2.imgbox.com/21/8c/8c1nZ2F2_o.gif">,表征了实际下降量与一阶微分量（也就是近似下降量)的比值。</p> 
<p>在算法伪代码中有这么一个判断:</p> 
<p>如果<img alt="\rho(x(k),\Delta x)\leq 0.25" class="mathcode" src="https://images2.imgbox.com/c8/08/jJov961E_o.gif">,那么h(k+1)=h(k)/2,也就是减小信任域，此时在具体的算法中u(k+1)=2*u(k)；</p> 
<p>如果<img alt="\rho(x(k),\Delta x)\geq 0.75" class="mathcode" src="https://images2.imgbox.com/ac/13/ZGksjTTo_o.gif">,那么h(k+1)=2*h(k),也就是增大信任域，此时在具体的算法中u(k+1)=u(k)/2；</p> 
<p>这其中的逻辑关系从LM迭代公式<img alt="\bigtriangleup x*=-(J(x)^{T}J(x)+u(k)D^{T}D)^{-1}J(x)f(x)" class="mathcode" src="https://images2.imgbox.com/b7/83/TWrxEi6z_o.gif">可以知道，因为如果实际下降比一阶近似小很多，那么表示二阶以上分量占了比较大的比重，这个时候非线性比较严重，那么就应该缩小信任域，u(k)增大，而<img alt="\bigtriangleup x*" class="mathcode" src="https://images2.imgbox.com/92/84/KcjPYEoU_o.gif">的模长变小，也就是变化较小了。同理可说明另外的情况。</p> 
<p><strong>最后说明一下如果u(k)的迭代搞混了</strong>，也就是之前提到的，该增大的时候变小了，而该变小的时候增大了，这个时候会出现的问题。</p> 
<p>最容易遇到的问题就是<img alt="\Delta x" class="mathcode" src="https://images2.imgbox.com/80/72/2XZl4PT6_o.gif">迭代过小，通过查看<img alt="\Delta x" class="mathcode" src="https://images2.imgbox.com/4e/38/05tyB8dG_o.gif">的模长||<img alt="\Delta x" class="mathcode" src="https://images2.imgbox.com/3d/c0/gAHsksHL_o.gif">||<img alt="\approx" class="mathcode" src="https://images2.imgbox.com/a8/d3/umTHbv4s_o.gif">2^(-k)，就是同一个数量级，而且收敛于非最优解，过早收敛了。产生这种情况的逻辑在于:当某一次迭代过程得到<img alt="\rho(x(k),\Delta x)\geq 0.75" class="mathcode" src="https://images2.imgbox.com/72/04/SlHP9dvw_o.gif">,本该u(k+1)=u(k)/2,但是搞混的情况下u(k+1)=2*u(k),下次的<img alt="\Delta x" class="mathcode" src="https://images2.imgbox.com/f4/34/wI9Rs4xP_o.gif">迭代将会变得更小，因为u(k+1)=2*u(k)等价于信任域变小了。另外<img alt="\lim_{||\Delta x||}\rho(x,\Delta x) =\frac{f(x+\Delta x)-f(x)}{J(x)\Delta x}=1" class="mathcode" src="https://images2.imgbox.com/c7/ae/oVEYL5oE_o.gif">，这样一次比一次的迭代小了，而且还是指数变小，那么就会使得目标在非最优解上收敛。通过修改程序上的正常逻辑，我们可以验证这样的情况。</p> 
<h2>最后附上LM算法的matlab程序</h2> 
<p>链接：https://pan.baidu.com/s/1_3AF-ZRkU9DPlcgxoMY-DA <br> 提取码：z7y8 <br> 复制这段内容后打开百度网盘手机App，操作更方便哦</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0276b1fb5f62e10683e37e776b95dd4e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PostgreSQL 目录结构及修改数据目录及配置文件分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0d7545f26f8f26246e283e9eda7ec4be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Assimp 编译（Visual Studio 2019）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>