<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>String的面试知识点 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="String的面试知识点" />
<meta property="og:description" content="String的变化历程 在java6之前，String对象主要有四个成员变量：char[]数组，offset偏移量，count字符数量，hash哈希值；通过offset和count两个属性可以定位char[]数组，共享数组对象，但是有可能会导致内存泄露。占用空间不被释放，比如源字符串很大，subString()一个字符，然后i只调用分割后的，那麽就会会共享原String对象，不会被GC，造成内存泄露。
泄露：调用String对象的substring方法后指向的对象地址并没有发生改变，只是改变的是偏移量，这样的话在GC阶段就有可能造成内存泄露了。
解决：这个里面是通过内存复制的方式重新指向了一个新的地址。
java7/8修复了内存泄漏问题。
java9中维护了一个新的属性coder，标识字符串的字节编码；char[]改成byte[]，可以减少每一个字符的占用空间，由16字节减少为8字节。
不可变性的好处（final） 1.String被设计为不可变是因为String对象是缓存在字符串池中的，
因此这些缓存的字符串是可以被多个客户端访问的，如果一个客户端的访问影响了别的客户端的行为，这样就存在风险。例如一个客户端把&#34;test&#34;改为&#34;TEST&#34;，其他所有的客户端都会跟着受影响。之所以把String进行了缓存处理，是出于性能的考虑。也就是说开发人员认为读比写次数多，索性就直接放方法区公用。因此这个风险只能通过把String设置为不可变来避免。同时，String类被声明为final的。是防止其他人通过继承String类，覆盖父类的方法，会破坏String的不可变性、缓存性以及hascode的计算方式
2.为了实现String可以创建HashCode不可变性
因为字符串是不可变的，所以在它创建的时候HashCode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。否则hashcode不同，同一个字符串会导致不同entry。
3**.为了线程安全**
因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。
4.String的不可变性为Java的类加载机制的安全性提供了根本的保障。 如果String是可变的，一个加载&#34;java.io.Writer&#34; 类的请求，可以被改变为&#34;mil.vogoon.DiskErasingWriter&#34;，这样安全就没有保障了。
双亲委派机制保证了string类不被重写，因为肯定是想看root加载类有没有，再往下看。
字符串的创建问题 String str = &#34;abc&#34;的方式会检查对象是否在字符串常量池中，如果在，就直接返回该对象的引用；否则新的字符串将在常量池中被创建。
2.str = new String(“abc”)每次都会在堆中新建一个对象。 字符串的性能优化 1.两个或者两个以上的字符串常量相加，在预编译的时候“&#43;”会被优化，相当于把两个或者两个以上字符串常量自动合成一个字符串常量.
字符串常量相加，不会用到StringBuilder对象，有一点要注意的是：字符串常量和字符串是不同的概念，字符串常量储存于方法区(总之就常量池)，而字符串储存于堆(heap)。2.而非纯常量的字符串相加
像是字符串相加表达式中带变量的那种的话，就是JVM会自动创建一个StringBuilder然后再调用append()方法最后再调用toString()方法返回的方式了，所以在堆中会有个String对象，引用指向的是堆中的对象的地址。
所以相加出来的结果，是不会被加到常量池中的。String s1 = new String(&#34;he&#34;)&#43;new String(&#34;llo&#34;); 1,这个代码中，首先，new String(“he”)，先在常量池中看，发现没有这个&#34;he&#34;常量，于是建一个，然后再在堆中创建一个String的对象（但没引用，很快被gc的）。
2,加法**，暗中new了StringBuilder，调用append方法。**
3.new String(“llo”)一样的道理，堆中一个String对象，常量池中&#34;llo&#34;常量对象。
4.StringBuilder的append方法搞定后，调用toString()方法，具体是new一个String对象，也就是现在是一个堆中的String对象，内容是&#34;hello&#34;，但注意这个hello没有在常量池中创建！！其实可以理解因为没有出现过一次&#34;hello&#34;，拼接是通过StringBuilder的append方法完成的。
总之：对于所有包含new方式新建对象（包括null）和变量形式 的“&#43;”连接表达式，它所产生的新对象都不会被加入字符串池中。 String str = &#34;new String(&#34;he&#34;); for(int i=0; i&lt;10; i&#43;&#43;) { str = str &#43; i; } 自动优化成
String str = &#34;haha&#34;; for(int i=0; i&lt;10; i&#43;&#43;) { str = (new StringBuilder(String." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/00836930b46ae46298467c7e75113e3f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-18T21:55:23+08:00" />
<meta property="article:modified_time" content="2020-06-18T21:55:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">String的面试知识点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="String_0"></a>String的变化历程</h2> 
<p>在java6之前，String对象主要有四个成员变量：char[]数组，offset偏移量，count字符数量，hash哈希值；通过offset和count两个属性可以定位char[]数组，共享数组对象，但是有可能会导致内存泄露。占用空间不被释放，比如源字符串很大，subString()一个字符，然后i只调用分割后的，那麽就会会共享原String对象，不会被GC，造成内存泄露。<br> <strong>泄露：<strong>调用String对象的substring方法后指向的对象地址并没有发生改变，只是改变的是</strong>偏移量</strong>，这样的话在GC阶段就有可能造成内存泄露了。<br> <strong>解决：<strong>这个里面是通过内存复制的方式重新指向了一个新的地址。<br> <strong>java7/8</strong>修复了内存泄漏问题。<br> <strong>java9</strong>中维护了一个新的属性coder，标识字符串的</strong>字节编码</strong>；char[]改成byte[]，可以减少每一个字符的占用空间，<strong>由16字节减少为8字节</strong>。</p> 
<h3><a id="final_7"></a>不可变性的好处（final）</h3> 
<ul><li> <p>1.<strong>String被设计为不可变是因为String对象是缓存在</strong>字符串池<strong>中的，</strong><br> 因此这些缓存的字符串是可以被多个客户端访问的，如果一个客户端的访问影响了别的客户端的行为，这样就存在风险。例如一个客户端把"test"改为"TEST"，其他所有的客户端都会跟着受影响。之所以把String进行了缓存处理，是出于性能的考虑。<strong>也就是说开发人员认为读比写次数多，索性就直接放方法区公用</strong>。因此这个风险只能通过把String设置为不可变来避免。同时，String类被声明为final的。<strong>是防止其他人通过继承String类，覆盖父类的方法</strong>，会破坏String的<strong>不可变性</strong>、<strong>缓存性</strong>以及<strong>hascode的计算方式</strong></p> </li><li> <p><strong>2.为了实现String可以创建HashCode不可变性</strong><br> 因为字符串是不可变的，所以在它创建的时候<strong>HashCode就被缓存了</strong>，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。否则hashcode不同，同一个字符串会导致不同entry。</p> </li><li> <p>3**.为了线程安全**<br> 因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p> </li><li> <p>4.<strong>String的不可变性为Java的类加载机制的安全性提供了根本的保障。</strong> <br> 如果String是可变的，一个加载"java.io.Writer" 类的请求，可以被改变为"mil.vogoon.DiskErasingWriter"，这样安全就没有保障了。<br> <strong>双亲委派机制保证了string类不被重写，因为肯定是想看root加载类有没有，再往下看。</strong></p> </li></ul> 
<h4><a id="_18"></a>字符串的创建问题</h4> 
<blockquote> 
 <ol><li>String str = "abc"的方式会检查对象是否在字符串常量池中，如果在，就直接返回该对象的引用；否则新的字符串将在常量池中被创建。<br> 2.str = new String(“abc”)每次都会在堆中新建一个对象。</li></ol> 
</blockquote> 
<h4><a id="_23"></a>字符串的性能优化</h4> 
<ul><li>1.两个或者两个以上的<strong>字符串常量</strong>相加，在预编译的时候“+”会被优化，相当于把<strong>两个或者两个以上字符串常量自动合成一个字符串常量.</strong><br> 　　字符串常量相加，不会用到StringBuilder对象，有一点要注意的是：字符串常量和字符串是不同的概念，字符串常量储存于方法区(总之就常量池)，而字符串储存于堆(heap)。</li><li>2.而<strong>非纯常量的字符串相加</strong><br> 像是字符串相加表达式中带变量的那种的话，就是<strong>JVM会自动创建一个StringBuilder</strong>然后再调用append()方法最后再调用toString()方法返回的方式了，所以在<strong>堆中会有个String对象</strong>，引用指向的是堆中的对象的地址。<br> 所以相加出来的结果，是不会被加到常量池中的。<pre><code class="prism language-javascript">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"he"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"llo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre> 1,这个代码中，首先，new String(“he”)，先在常量池中看，发现没有这个"he"常量，于是建一个，然后再在堆中创建一个String的对象（<strong>但没引用，很快被gc的</strong>）。<br> 2,加法**，暗中new了StringBuilder，调用append方法。**<br> 3.new String(“llo”)一样的道理，堆中一个String对象，常量池中"llo"常量对象。<br> 4.StringBuilder的append方法搞定后，调用toString()方法，具体是new一个String对象，也就是现在是一个堆中的String对象，内容是"hello"，<strong>但注意这个hello没有在常量池中创建</strong>！！其实可以理解因为没有出现过一次"hello"，拼接是通过StringBuilder的append方法完成的。<br> <strong>总之：对于所有包含new方式新建对象（包括null）和变量形式 的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</strong></li></ul> 
<pre><code class="prism language-javascript">String str <span class="token operator">=</span> <span class="token string">"new String("</span>he"<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>int i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      str <span class="token operator">=</span> str <span class="token operator">+</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> 
<p>自动优化成</p> 
<pre><code class="prism language-javascript">String str <span class="token operator">=</span> <span class="token string">"haha"</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span>int i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
              str <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> 
<p>这样在循环体内一直生成新的StringBuilder对象，性能是比较低的，这种情况下，<strong>最好在循环外层定义一个StringBuilder对象</strong>，然后使用该对象进行字符串的拼接。</p> 
<h4><a id="intern_56"></a>intern()</h4> 
<p>JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，<strong>复制一个副本放到常量池</strong>，<strong>1.7后则是将在堆上的地址引用复制到常量池</strong>。量池被从<strong>方法区中移出来到了堆中</strong>。</p> 
<h4><a id="StringStringBufferStringBuilder_59"></a>String、StringBuffer、StringBuilder区别</h4> 
<ul><li> <p>String，定义字符串常量，每次对字符串的修改，都会返回一个新的字符串对象。如果涉及到字符串变量的拼接，不建议使用String。</p> </li><li> <p>StringBuilder，主要用于字符串变量的拼接，<strong>性能比String的拼接要高</strong>。<strong>线程不安全</strong>。适用于单线程或没有线程安全问题的字符串变量拼接。</p> </li><li> <p>StringBuffer，与StringBuilder类似，不过<strong>StringBuffer是线程安全的</strong>，<strong>也就是说任何对字符串的操作，都是加锁的</strong>，所以性能比StringBuilder低。适用于多线程下字符串变量的修改。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/358eba82dc1f9a0cfb21aebd72ad9bb5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LCD基础概念（三）：LCD RGB之PCLK、VS、HS、DE</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1de1f38b04afd4ce885fb355256ec806/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue跳转同一路由，导致页面函数没有执行，页面不刷新。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>