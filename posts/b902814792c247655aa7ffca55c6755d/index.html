<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TypeScript接口、type关键字详解（可读、只读属性、继承接口|类、规范类、函数|可索引|类|混合类型接口、ReadonlyArray、接口&amp;type、映射类型） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TypeScript接口、type关键字详解（可读、只读属性、继承接口|类、规范类、函数|可索引|类|混合类型接口、ReadonlyArray、接口&amp;type、映射类型）" />
<meta property="og:description" content="目录
TypeScript接口
可选属性
:?
只读属性
ReadonlyArray
接口继承接口（extends）
接口继承类（extends）
接口规范类（implements）
函数类型接口
可索引类型接口
只读设置
类类型接口
规定构造函数 混合类型接口
type关键字
type扩展（&amp;）
interface继承type
映射类型
type高级使用
TypeScript接口 用于规范定义变量的类型，规定变量应该具有什么属性或函数入参什么值返回什么值等。
interface IUser { name: string age: number } let user: IUser = { name : &#39;yf&#39;, age: 32 } 可选属性 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。定义的属性可以不用实现。
interface IUser { name: string age?: number } let user: IUser = { name : &#39;yf&#39; } :? 注意区分冒号后也可以接问号。
const gender: ?number = undefined; // 等同于下面这种写法 const gender: number | null | void = undefined 只读属性 只读属性只能在对象刚刚创建的时候修改其值。 在属性名前用readonly来指定只读属性 。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b902814792c247655aa7ffca55c6755d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-17T17:49:50+08:00" />
<meta property="article:modified_time" content="2022-12-17T17:49:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TypeScript接口、type关键字详解（可读、只读属性、继承接口|类、规范类、函数|可索引|类|混合类型接口、ReadonlyArray、接口&amp;type、映射类型）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="TypeScript%E6%8E%A5%E5%8F%A3-toc" style="margin-left:0px;"><a href="#TypeScript%E6%8E%A5%E5%8F%A3" rel="nofollow">TypeScript接口</a></p> 
<p id="%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7" rel="nofollow">可选属性</a></p> 
<p id="%C2%A0%3A%3F-toc" style="margin-left:80px;"><a href="#%C2%A0%3A%3F" rel="nofollow"> :?</a></p> 
<p id="%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7" rel="nofollow">只读属性</a></p> 
<p id="ReadonlyArray%3CT%3E-toc" style="margin-left:80px;"><a href="#ReadonlyArray%3CT%3E" rel="nofollow">ReadonlyArray</a></p> 
<p id="%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%EF%BC%88extends%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%EF%BC%88extends%EF%BC%89" rel="nofollow">接口继承接口（extends）</a></p> 
<p id="%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB%EF%BC%88extends%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB%EF%BC%88extends%EF%BC%89" rel="nofollow">接口继承类（extends）</a></p> 
<p id="%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83%E7%B1%BB%EF%BC%88implements%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83%E7%B1%BB%EF%BC%88implements%EF%BC%89" rel="nofollow">接口规范类（implements）</a></p> 
<p id="%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3" rel="nofollow">函数类型接口</a></p> 
<p id="%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B" rel="nofollow">可索引类型接口</a></p> 
<p id="%E5%8F%AA%E8%AF%BB%E8%AE%BE%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%E5%8F%AA%E8%AF%BB%E8%AE%BE%E7%BD%AE" rel="nofollow">只读设置</a></p> 
<p id="%E7%B1%BB%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B" rel="nofollow">类类型接口</a></p> 
<p id="%E8%A7%84%E5%AE%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:80px;"><a href="#%E8%A7%84%E5%AE%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">规定构造函数 </a></p> 
<p id="%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B" rel="nofollow">混合类型接口</a></p> 
<p id="type%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px;"><a href="#type%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">type关键字</a></p> 
<p id="type%E6%89%A9%E5%B1%95%EF%BC%88%26%EF%BC%89-toc" style="margin-left:40px;"><a href="#type%E6%89%A9%E5%B1%95%EF%BC%88%26%EF%BC%89" rel="nofollow">type扩展（&amp;）</a></p> 
<p id="interface%E7%BB%A7%E6%89%BFtype-toc" style="margin-left:40px;"><a href="#interface%E7%BB%A7%E6%89%BFtype" rel="nofollow">interface继承type</a></p> 
<p id="%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B" rel="nofollow">映射类型</a></p> 
<p id="type%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#type%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8" rel="nofollow">type高级使用</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="TypeScript%E6%8E%A5%E5%8F%A3">TypeScript接口</h2> 
<p>用于规范定义变量的类型，规定变量应该具有什么属性或函数入参什么值返回什么值等。</p> 
<pre><code class="language-TypeScript">interface IUser {
    name: string
    age: number
}
let user: IUser = { name : 'yf', age: 32 }</code></pre> 
<p></p> 
<h3 id="%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7">可选属性</h3> 
<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。定义的属性可以不用实现。</p> 
<pre><code class="language-TypeScript">interface IUser {
    name: string
    age?: number
}
let user: IUser = { name : 'yf' }</code></pre> 
<h4 id="%C2%A0%3A%3F"> :?</h4> 
<p>注意区分冒号后也可以接问号。</p> 
<pre><code class="language-TypeScript">const gender: ?number = undefined;
// 等同于下面这种写法
const gender: number | null | void = undefined</code></pre> 
<h3 id="%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7">只读属性</h3> 
<p>只读属性只能在对象刚刚创建的时候修改其值。 在属性名前用<strong><code>readonly</code></strong>来指定只读属性 。</p> 
<pre><code class="language-TypeScript">interface Point {
    readonly x: number;
    readonly y: number;
}
let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!</code></pre> 
<h4 id="ReadonlyArray%3CT%3E">ReadonlyArray&lt;T&gt;</h4> 
<p>表示数组创建后再也不能被修改</p> 
<pre><code class="language-TypeScript">let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray&lt;number&gt; = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!</code></pre> 
<p><code>注意最后a=ro，将ReadonlyArray</code>赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写</p> 
<pre><code class="language-TypeScript">a = ro as number[];</code></pre> 
<p></p> 
<h3 id="%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%EF%BC%88extends%EF%BC%89">接口继承接口（extends）</h3> 
<p>一个接口<strong>可以继承多个接口</strong>，创建出多个接口的合成接口，<strong>继承的每个接口里的内容都需要满足</strong>。</p> 
<pre><code class="language-TypeScript">interface Shape {
    color: string;
}
interface PenStroke {
    penWidth: number;
}
interface Square extends Shape, PenStroke {
    sideLength: number;
}
let square:Square = {
    color: 'bule',
    sideLength: 0,
    penWidth: 0
};</code></pre> 
<h3 id="%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB%EF%BC%88extends%EF%BC%89">接口继承类（extends）</h3> 
<p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。</p> 
<p>例如下面接口继承了Control类，故接口约束的abc类中需要定义pubulic的state属性</p> 
<pre><code class="language-TypeScript">class Control {
    state: any;
}
interface SelectableControl extends Control {
    select(): void;
}
class abc implements SelectableControl {
    state: any
    select() { }
}
</code></pre> 
<p>注意<strong>接口也能继承到类的private和protected成员。但继承后这个接口类型只能被这个类或其子类所实现</strong>。</p> 
<p> 例如下面abc实现SelectableControl接口就必须是Control类的子类，因为state属性是私有属性。</p> 
<pre><code class="language-TypeScript">class Control {
    private state: any;
}
interface SelectableControl extends Control {
    select(): void;
}

class abc extends Control implements SelectableControl {
    select() { }
}
</code></pre> 
<p></p> 
<h3 id="%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83%E7%B1%BB%EF%BC%88implements%EF%BC%89">接口规范类（implements）</h3> 
<p>相当于用接口规范便量时的冒号：,同样也可以通过逗号用多个接口约束一个类。</p> 
<p>注意接口中定义的属性，必须在初始时定义，如果仅在constructor中定义也会报错，例如下面h不能仅在constructor中定义</p> 
<pre><code class="language-TypeScript">interface ClockInterface {
    tick();
}
interface Clock {
    h: number
}
class DigitalClock implements ClockInterface,Clock { 
    //h: string    //放开此行注释为正确的 
    constructor(h: number, m: number) { } //error缺少h属性
    tick() {
        console.log("beep beep");
    }
}</code></pre> 
<h3 id="%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3">函数类型接口</h3> 
<p>括号里为参数，冒号右边为函数的返回值。</p> 
<p>函数的参数会逐个进行检查，只要求<strong>对应位置上的参数类型是兼容</strong>的。所以函数的<strong>参数名不需要与接口里定义的名字相同</strong>。</p> 
<pre><code class="language-TypeScript">interface SearchFunc {
  (source: string, subString: string): boolean;
}
let mySearch: SearchFunc = function(so: string, su: string) {
  let result = so.search(su);
  return result &gt; -1;
}</code></pre> 
<p></p> 
<h3 id="%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B">可索引类型接口</h3> 
<p>可索引类型具有一个<em>索引签名</em>，它描述了对象索引的类型，还有相应的索引返回值类型。 </p> 
<p>它共有支持两种索引签名：字符串和数字。</p> 
<p>注意同时使用两种类型的索引时，<strong>数字索引的返回值必须是字符串索引返回值类型的子类型</strong>。 这是因为当使用<code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。 也就是说用<code>100</code>（一个<code>number</code>）去索引等同于使用<code>"100"</code>（一个<code>string</code>）去索引，因此两者需要保持一致。 </p> 
<pre><code class="language-TypeScript">class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}// 错误：使用'string'索引，有时会得到Animal，数字索引应该是字符串索引的子集

interface NotOkay {
    [x: number]: Dog;
    [x: string]: Animal;
}//OK</code></pre> 
<p> 注意<strong>使用了可索引类型后，另外定义的属性需要符合可索引</strong>。例如下面额外定义了字符串name属性，而使用的可索引也是字符串，所以指向的值应该相同。</p> 
<pre><code class="language-TypeScript">interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}</code></pre> 
<h4 id="%E5%8F%AA%E8%AF%BB%E8%AE%BE%E7%BD%AE">只读设置</h4> 
<p>可以将索引签名设置为只读，这样就防止了给索引赋值 </p> 
<pre><code class="language-TypeScript">interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // error!</code></pre> 
<p></p> 
<h3 id="%E7%B1%BB%E7%B1%BB%E5%9E%8B">类类型接口</h3> 
<p><strong>接口描述了类的公共部分</strong>，而不是公共和私有两部分。 它<strong>不会检查类是否具有某些私有成员</strong>。 </p> 
<pre><code class="language-TypeScript">interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    private currentTime: Date;//error ,只能为public
    constructor(h: number, m: number) { }
}</code></pre> 
<h4 id="%E8%A7%84%E5%AE%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0">规定构造函数 </h4> 
<p>注意类是具有两个类型的：静态部分的类型和实例的类型 ， constructor存在于类的静态部分，所以不在检查的范围内。</p> 
<p>故下面通过在接口里new定义构造函数会报错</p> 
<pre><code class="language-TypeScript">interface ClockConstructor {
    new (hour: number, minute: number);
}

class Clock implements ClockConstructor {  //error,接口中的new无法直接在类里面实现
    currentTime: Date;
    constructor(h: number, m: number) { }
}</code></pre> 
<p> 但是我们可以借助函数的的形式去实现，例如下面</p> 
<pre><code class="language-TypeScript">interface ClockInterface {
    tick();
}
class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("beep beep");
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("tick tock");
    }
}
interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface;
}
function createClock(ctor: ClockConstructor, hour: number, minute: number){
    return new ctor(hour, minute);
}
let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);</code></pre> 
<p></p> 
<h3 id="%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B">混合类型接口</h3> 
<p>一个对象可以同时做为函数和对象使用，并带有额外的属性。</p> 
<p>需要借助类型断言，例如下面：</p> 
<pre><code class="language-TypeScript">interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}
function getCounter(): Counter {
    let counter = &lt;Counter&gt;function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;</code></pre> 
<p></p> 
<h2 id="type%E5%85%B3%E9%94%AE%E5%AD%97">type关键字</h2> 
<p>用于给类型起一个新名字，支持基本类型、联合类型、元祖及其它任何你需要的手写类型,常用于联合类型。</p> 
<pre><code class="language-TypeScript">type test = number; //基本类型
let num: test = 10;
type userOjb = {name:string} // 对象
type getName = ()=&gt;string  // 函数
type data = [number,string] // 元组
type numOrFun = Second | getName  // 联合类型</code></pre> 
<h3 id="type%E6%89%A9%E5%B1%95%EF%BC%88%26%EF%BC%89">type扩展（&amp;）</h3> 
<p>interface的扩展可以通过type交叉(&amp;)类型实现。</p> 
<pre><code class="language-TypeScript">type Name = {
   name: string;
}
type User = Name &amp; {age: number}
let stu:User={name: 'wang', age: 18}</code></pre> 
<p> interface交叉（&amp;）可以实现type类型。</p> 
<pre><code class="language-TypeScript">interface Name {
  name: string;
}
type User = Name &amp; {
  age: number;
}
let stu:User={name:'wang', age: 18}</code></pre> 
<h3 id="interface%E7%BB%A7%E6%89%BFtype">interface继承type</h3> 
<p>接口可以继承type类型。</p> 
<pre><code class="language-TypeScript">type Name = {
  name: string;
}
interface User extends Name {
  age: number;
}
let stu:User={name: 'wang', age: 89}</code></pre> 
<h3 id="%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span style="color:#fe2c24;">映射类型</span></h3> 
<p><span style="color:#fe2c24;"><strong>type可以使用关键字生成映射类型。</strong></span></p> 
<pre><code class="language-TypeScript">type Keys = "name" | "sex"
type DuKey = {
  [Key in Keys]: string //类似 for ... in
}
let stu: Dukey = {
  name: 'wang'，
  sex: 'man'
}</code></pre> 
<h3 id="type%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8">type高级使用</h3> 
<p><a href="https://blog.csdn.net/sinat_34560749/article/details/104082864" title="编写TypeScript工具类型，你需要知道的知识_胖子依然6的博客-CSDN博客_typescript 工具类型">编写TypeScript工具类型，你需要知道的知识_胖子依然6的博客-CSDN博客_typescript 工具类型</a></p> 
<p>补充：</p> 
<pre><code class="language-javascript">// 将所有属性变成可选的
type Optional&lt;T&gt; = {
  [key in keyof T]?: T[key];
}
 
// 将某些属性变成必选的
type MyRequired&lt;T, K extends keyof T&gt; = T &amp;
  {
    [key in K]-?: T[key];
  };
  
// 例如我们有个实体
type App = {
  _id?: string;
  appId: string;
  name: string;
  description: string;
  ownerList: string[];
  createdAt?: number;
  updatedAt?: number;
};
 
// 我们在更新这个对象/类型的时候，有些 key 是必填的，有些 key 是选填的，这个时候就可以这样子生成我们需要的类型
type AppUpdatePayload = MyRequired&lt;Optional&lt;App&gt;, '_id'&gt;
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b37b359099471e6c70756f97166ead28/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Window11新机激活步骤（零基础）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4b88a4910556d2ca869517a500434bb3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pycharm代码自动补全中的c，m,F, f，v，P, p分别是代表什么意思？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>