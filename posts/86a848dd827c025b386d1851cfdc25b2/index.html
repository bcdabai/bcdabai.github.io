<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;力扣题目530--二叉搜索树的最小绝对值 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;力扣题目530--二叉搜索树的最小绝对值" />
<meta property="og:description" content="给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。
差值是一个正数，其数值等于两值之差的绝对值。
示例 1：
输入：root = [4,2,6,1,3] 输出：1 示例 2：
输入：root = [1,0,48,null,null,12,49] 输出：1 提示： 树中节点的数目范围是 [2, 104]0 &lt;= Node.val &lt;= 105 思路 题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。
注意是二叉搜索树，二叉搜索树可是有序的。
遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。
#递归 那么二叉搜索树采用中序遍历，其实就是一个有序数组。
在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。
最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。
代码如下：
class Solution { private: vector&lt;int&gt; vec; void traversal(TreeNode* root) { if (root == NULL) return; traversal(root-&gt;left); vec.push_back(root-&gt;val); // 将二叉搜索树转换为有序数组 traversal(root-&gt;right); } public: int getMinimumDifference(TreeNode* root) { vec.clear(); traversal(root); if (vec.size() &lt; 2) return 0; int result = INT_MAX; for (int i = 1; i &lt; vec." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/86a848dd827c025b386d1851cfdc25b2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-13T13:09:55+08:00" />
<meta property="article:modified_time" content="2024-01-13T13:09:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;力扣题目530--二叉搜索树的最小绝对值</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><a id="_0"></a></h3> 
<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p> 
<p>差值是一个正数，其数值等于两值之差的绝对值。</p> 
<p><strong>示例 1：</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="301" src="https://images2.imgbox.com/d9/e6/wynG8qhY_o.jpg" width="292"></p> 
<pre><strong>输入：</strong>root = [4,2,6,1,3]
<strong>输出：</strong>1
</pre> 
<p><strong>示例 2：</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="301" src="https://images2.imgbox.com/47/c6/peVA51fW_o.jpg" width="282"></p> 
<pre><strong>输入：</strong>root = [1,0,48,null,null,12,49]
<strong>输出：</strong>1
<strong>提示：</strong></pre> 
<ul><li>树中节点的数目范围是 <code>[2, 104]</code></li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul> 
<h3 id="思路">思路</h3> 
<p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p> 
<p><strong>注意是二叉搜索树</strong>，二叉搜索树可是有序的。</p> 
<p>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。</p> 
<h4 id="递归"><a href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html#%E9%80%92%E5%BD%92" rel="nofollow" title="#">#</a>递归</h4> 
<p>那么二叉搜索树采用中序遍历，其实就是一个有序数组。</p> 
<p><strong>在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。</strong></p> 
<p>最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">class Solution {
private:
vector&lt;int&gt; vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root-&gt;left);
    vec.push_back(root-&gt;val); // 将二叉搜索树转换为有序数组
    traversal(root-&gt;right);
}
public:
    int getMinimumDifference(TreeNode* root) {
        vec.clear();
        traversal(root);
        if (vec.size() &lt; 2) return 0;
        int result = INT_MAX;
        for (int i = 1; i &lt; vec.size(); i++) { // 统计有序数组的最小差值
            result = min(result, vec[i] - vec[i-1]);
        }
        return result;
    }
};
</code></pre> 
<p><br>  </p> 
<p>以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。</p> 
<p>需要用一个pre节点记录一下cur节点的前一个节点。</p> 
<p>如图：</p> 
<p></p> 
<p class="img-center"><img alt="530.二叉搜索树的最小绝对差" height="730" src="https://images2.imgbox.com/d0/15/rZ02Mt11_o.png" width="1120"></p> 
<p>一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">class Solution {
private:
int result = INT_MAX;
TreeNode* pre = NULL;
void traversal(TreeNode* cur) {
    if (cur == NULL) return;
    traversal(cur-&gt;left);   // 左
    if (pre != NULL){       // 中
        result = min(result, cur-&gt;val - pre-&gt;val);
    }
    pre = cur; // 记录前一个
    traversal(cur-&gt;right);  // 右
}
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
</code></pre> 
<p>是不是看上去也并不复杂！</p> 
<h4 id="迭代"><a href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html#%E8%BF%AD%E4%BB%A3" rel="nofollow" title="#">#</a>迭代</h4> 
<p>看过这两篇<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html" rel="nofollow" title="二叉树：听说递归能做的，栈也能做！ (opens new window)">二叉树：听说递归能做的，栈也能做！ (opens new window)</a>，<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html" rel="nofollow" title="二叉树：前中后序迭代方式的写法就不能统一一下么？ (opens new window)">二叉树：前中后序迭代方式的写法就不能统一一下么？ (opens new window)</a>文章之后，不难写出两种中序遍历的迭代法。</p> 
<p>下面我给出其中的一种中序遍历的迭代法，代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        int result = INT_MAX;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur-&gt;left;                // 左
            } else {
                cur = st.top();
                st.pop();
                if (pre != NULL) {              // 中
                    result = min(result, cur-&gt;val - pre-&gt;val);
                }
                pre = cur;
                cur = cur-&gt;right;               // 右
            }
        }
        return result;
    }
};
</code></pre> 
<p></p> 
<h3 id="总结"><a href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html#%E6%80%BB%E7%BB%93" rel="nofollow" title="#">#</a>总结</h3> 
<p><strong>遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。</strong></p> 
<p>同时要学会在递归遍历的过程中如何记录前后两个指针，这也是一个小技巧，学会了还是很受用的。</p> 
<p>后面我将继续介绍一系列利用二叉搜索树特性的题目。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df1efe8442e9de87c95e626db2fcfc18/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[iris_0_ego_planner_node-3] process has died [pid 7044, exit code -11, cmd报错</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/68cc624c877e7a8a2bbd4a1106a5a6c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">XTdrone运行ego需打开多个终端 麻烦 一键启动脚本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>