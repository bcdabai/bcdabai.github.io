<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>利用C语言绘制操作系统图像界面 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="利用C语言绘制操作系统图像界面" />
<meta property="og:description" content="阅读博客的朋友可以参看视频： Linux kernel Hacker, 从零构建自己的内核
有了C语言这一利器后，不多多拿来用，那就太对不起前面的一系列努力了。那么怎么表现C语言的强大功能呢，如果还只是一味的在界面上输出几行字符，那太没意思，考虑到，我们的目标是做出像windows那样具备舒心的图像用户界面那样的系统，所以在这一节，我们由字符模式切换入画面模式，初步体验下，那些绚丽多彩的图像界面是如何发展而成的。
要想由字符模式转入图形模式，我们需要操作硬件，特别是向显卡发送命令，让其进入图形显示模式，就如同前面我们所做的，要操作硬件，一般需要使用BIOS调用，以下几行就是打开VGA显卡色彩功能的代码：
mov al, 0x13h mov ah, 0x00 int 0x10 其中al 的值决定了要设置显卡的色彩模式，下面是一些常用的模式设置： 1. 0x03, 16色字符模式 2. 0x12, VGA图形模式, 640 * 480 * 4位彩色模式，独特的4面存储模式 3. 0x13, VGA图形模式, 320 * 200 * 8位彩色模式，调色板模式 4. 0x6a, 扩展VGA图形模式， 800 * 600 * 4彩色模式
我们采用的是0x13模式，其中320*200*8 中，最后的数值8表示的是色彩值得位数，也就是我们可以用8位数值表示色彩，总共可以显示256种色彩。
系统显存的地址是0x000a0000，当我们执行上面几句代码后，望显存地址写入数据，那么屏幕就会出现相应的变化了。
我们先看看内核的汇编代码部分(kernel.asm)：
%include &#34;pm.inc&#34; org 0x9000 jmp LABEL_BEGIN [SECTION .gdt] ; 段基址 段界限 属性 LABEL_GDT: Descriptor 0, 0, 0 LABEL_DESC_CODE32: Descriptor 0, SegCode32Len - 1, DA_C &#43; DA_32 LABEL_DESC_VIDEO: Descriptor 0B8000h, 0ffffh, DA_DRW LABEL_DESC_VRAM: Descriptor 0, 0ffffffffh, DA_DRW LABEL_DESC_STACK: Descriptor 0, TopOfStack, DA_DRWA&#43;DA_32 GdtLen equ $ - LABEL_GDT GdtPtr dw GdtLen - 1 dd 0 SelectorCode32 equ LABEL_DESC_CODE32 - LABEL_GDT SelectorVideo equ LABEL_DESC_VIDEO - LABEL_GDT SelectorStack equ LABEL_DESC_STACK - LABEL_GDT SelectorVram equ LABEL_DESC_VRAM - LABEL_GDT [SECTION ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/74be113fcf728699c133ca30f626a1c6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-09-13T11:39:04+08:00" />
<meta property="article:modified_time" content="2016-09-13T11:39:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">利用C语言绘制操作系统图像界面</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>阅读博客的朋友可以参看视频： <br> <a href="http://study.163.com/course/courseMain.htm?courseId=1003169025" rel="nofollow">Linux kernel Hacker, 从零构建自己的内核</a></p> 
<p>有了C语言这一利器后，不多多拿来用，那就太对不起前面的一系列努力了。那么怎么表现C语言的强大功能呢，如果还只是一味的在界面上输出几行字符，那太没意思，考虑到，我们的目标是做出像windows那样具备舒心的图像用户界面那样的系统，所以在这一节，我们由字符模式切换入画面模式，初步体验下，那些绚丽多彩的图像界面是如何发展而成的。</p> 
<p>要想由字符模式转入图形模式，我们需要操作硬件，特别是向显卡发送命令，让其进入图形显示模式，就如同前面我们所做的，要操作硬件，一般需要使用BIOS调用，以下几行就是打开VGA显卡色彩功能的代码：</p> 
<pre class="prettyprint"><code class="language-nasm hljs avrasm"><span class="hljs-keyword">mov</span>  al, <span class="hljs-number">0x13</span>h
<span class="hljs-keyword">mov</span>  ah, <span class="hljs-number">0x00</span>
int  <span class="hljs-number">0x10</span></code></pre> 
<p>其中al 的值决定了要设置显卡的色彩模式，下面是一些常用的模式设置： <br> 1. 0x03, 16色字符模式 <br> 2. 0x12, VGA图形模式, 640 * 480 * 4位彩色模式，独特的4面存储模式 <br> 3. 0x13, VGA图形模式, 320 * 200 * 8位彩色模式，调色板模式 <br> 4. 0x6a, 扩展VGA图形模式， 800 * 600 * 4彩色模式</p> 
<p>我们采用的是0x13模式，其中320*200*8 中，最后的数值8表示的是色彩值得位数，也就是我们可以用8位数值表示色彩，总共可以显示256种色彩。</p> 
<p>系统显存的地址是0x000a0000，当我们执行上面几句代码后，望显存地址写入数据，那么屏幕就会出现相应的变化了。</p> 
<p>我们先看看内核的汇编代码部分(kernel.asm)：</p> 
<pre class="prettyprint"><code class="language-nasm hljs avrasm">%include <span class="hljs-string">"pm.inc"</span>

org   <span class="hljs-number">0x9000</span>

<span class="hljs-keyword">jmp</span>   LABEL_BEGIN

[SECTION <span class="hljs-preprocessor">.gdt</span>]
 <span class="hljs-comment">;                                  段基址          段界限                属性</span>
<span class="hljs-label">LABEL_GDT:</span>          Descriptor        <span class="hljs-number">0</span>,            <span class="hljs-number">0</span>,                   <span class="hljs-number">0</span>  
<span class="hljs-label">LABEL_DESC_CODE32:</span>  Descriptor        <span class="hljs-number">0</span>,      SegCode32Len - <span class="hljs-number">1</span>,       DA_C + DA_32
<span class="hljs-label">LABEL_DESC_VIDEO:</span>   Descriptor        <span class="hljs-number">0</span>B8000h,         <span class="hljs-number">0</span>ffffh,            DA_DRW
<span class="hljs-label">LABEL_DESC_VRAM:</span>    Descriptor        <span class="hljs-number">0</span>,         <span class="hljs-number">0</span>ffffffffh,            DA_DRW
<span class="hljs-label">LABEL_DESC_STACK:</span>   Descriptor        <span class="hljs-number">0</span>,             TopOfStack,        DA_DRWA+DA_32

GdtLen     equ    $ - LABEL_GDT
GdtPtr     dw     GdtLen - <span class="hljs-number">1</span>
           dd     <span class="hljs-number">0</span>

SelectorCode32    equ   LABEL_DESC_CODE32 -  LABEL_GDT
SelectorVideo     equ   LABEL_DESC_VIDEO  -  LABEL_GDT
SelectorStack     equ   LABEL_DESC_STACK  -  LABEL_GDT
SelectorVram      equ   LABEL_DESC_VRAM   -  LABEL_GDT


[SECTION  <span class="hljs-preprocessor">.s</span>16]
[BITS  <span class="hljs-number">16</span>]
<span class="hljs-label">LABEL_BEGIN:</span>
     <span class="hljs-keyword">mov</span>   ax, cs
     <span class="hljs-keyword">mov</span>   ds, ax
     <span class="hljs-keyword">mov</span>   es, ax
     <span class="hljs-keyword">mov</span>   ss, ax
     <span class="hljs-keyword">mov</span>   sp, <span class="hljs-number">0100</span>h

     <span class="hljs-keyword">mov</span>   al, <span class="hljs-number">0x13</span>
     <span class="hljs-keyword">mov</span>   ah, <span class="hljs-number">0</span>
     int   <span class="hljs-number">0x10</span>

     xor   eax, eax
     <span class="hljs-keyword">mov</span>   ax,  cs
     shl   eax, <span class="hljs-number">4</span>
     <span class="hljs-keyword">add</span>   eax, LABEL_SEG_CODE32
     <span class="hljs-keyword">mov</span>   word [LABEL_DESC_CODE32 + <span class="hljs-number">2</span>], ax
     shr   eax, <span class="hljs-number">16</span>
     <span class="hljs-keyword">mov</span>   byte [LABEL_DESC_CODE32 + <span class="hljs-number">4</span>], al
     <span class="hljs-keyword">mov</span>   byte [LABEL_DESC_CODE32 + <span class="hljs-number">7</span>], ah

     <span class="hljs-comment">;set stack for C language</span>
     xor   eax, eax
     <span class="hljs-keyword">mov</span>   ax,  cs
     shl   eax, <span class="hljs-number">4</span>
     <span class="hljs-keyword">add</span>   eax, LABEL_STACK
     <span class="hljs-keyword">mov</span>   word [LABEL_DESC_STACK + <span class="hljs-number">2</span>], ax
     shr   eax, <span class="hljs-number">16</span>
     <span class="hljs-keyword">mov</span>   byte [LABEL_DESC_STACK + <span class="hljs-number">4</span>], al
     <span class="hljs-keyword">mov</span>   byte [LABEL_DESC_STACK + <span class="hljs-number">7</span>], ah

     xor   eax, eax
     <span class="hljs-keyword">mov</span>   ax, ds
     shl   eax, <span class="hljs-number">4</span>
     <span class="hljs-keyword">add</span>   eax,  LABEL_GDT
     <span class="hljs-keyword">mov</span>   dword  [GdtPtr + <span class="hljs-number">2</span>], eax

     lgdt  [GdtPtr]

     <span class="hljs-keyword">cli</span>   <span class="hljs-comment">;关中断</span>

     <span class="hljs-keyword">in</span>    al,  <span class="hljs-number">92</span>h
     <span class="hljs-keyword">or</span>    al,  <span class="hljs-number">00000010</span>b
     <span class="hljs-keyword">out</span>   <span class="hljs-number">92</span>h, al

     <span class="hljs-keyword">mov</span>   eax, cr0
     <span class="hljs-keyword">or</span>    eax , <span class="hljs-number">1</span>
     <span class="hljs-keyword">mov</span>   cr0, eax

     <span class="hljs-keyword">jmp</span>   dword  SelectorCode32: <span class="hljs-number">0</span>

     [SECTION <span class="hljs-preprocessor">.s</span>32]
     [BITS  <span class="hljs-number">32</span>]
     LABEL_SEG_CODE32:
     <span class="hljs-comment">;initialize stack for c code</span>
     <span class="hljs-keyword">mov</span>  ax, SelectorStack
     <span class="hljs-keyword">mov</span>  ss, ax
     <span class="hljs-keyword">mov</span>  esp, TopOfStack

     <span class="hljs-keyword">mov</span>  ax, SelectorVram
     <span class="hljs-keyword">mov</span>  ds,  ax

<span class="hljs-label">C_CODE_ENTRY:</span>
     %include <span class="hljs-string">"write_vga.asm"</span>


     io_hlt:  <span class="hljs-comment">;void io_hlt(void);</span>
      HLT
      <span class="hljs-keyword">RET</span>

SegCode32Len   equ  $ - LABEL_SEG_CODE32

[SECTION <span class="hljs-preprocessor">.gs</span>]
ALIGN <span class="hljs-number">32</span>
[BITS <span class="hljs-number">32</span>]
<span class="hljs-label">LABEL_STACK:</span>
times <span class="hljs-number">512</span>  db <span class="hljs-number">0</span>
TopOfStack  equ  $ - LABEL_STACK</code></pre> 
<p>解释下上面代码，我们设置了一个描述符,LABEL_DESC_VRAM, 这个描述符对应的内存起始地址是0，长度是0xffffffff，也就是我们把整个4G内存当做一段可读可写的内存，有了这个设置后，我们在C语言里就可以随意读写内存的任何地方。</p> 
<p>LABEL_DESC_STACK 这个描述符用来设置一段可读可写的内存，它的起始地址是LABEL_STACK， 可以看到，程序通过语句：times 512 db 0 <br> 初始化了512字节的内存。C语言的运行，特别是函数调用时，是需要一个堆栈来传递参数的，所以，要运行C语言，我们首先需要为其配置一个堆栈，该描述符所对应的这512自己内存就是给C语言使用的，由于堆栈只有512字节，在后面我们使用C语言写的代码中，函数的局部变量大小不能超过512字节，例如下面的代码可能就要出错了：</p> 
<pre class="prettyprint"><code class="language-C hljs scss">void <span class="hljs-function">fun()</span> {
  <span class="hljs-value">char</span> buf<span class="hljs-attr_selector">[513]</span>;
}</code></pre> 
<p>语句%include write_vga.asm”， 表明，我们要开发的C代码文件叫write_vga.c, 我们写完C代码后，会使用上一节的步骤将它编译成汇编，然后include到我们当前的汇编文件里，统一编译成可执行内核。</p> 
<p>最后一小块代码： <br> io_hlt: ;void io_hlt(void); <br> HLT <br> RET <br> 作用是进入死循环，HLT指令会让系统进入休眠状态。</p> 
<h5 id="导入c语言">导入C语言</h5> 
<p>硬件，堆栈等基层设施通过汇编准备就绪后，我们可以使用C语言开发图形功能了。显示器的每一个像素对应一个点，一个点可以显示256种不同的颜色，因此，只要我们给每个点设置成相应的颜色，那么最终就可以绘制出特定的图像。</p> 
<p>我们看看如何用C语言写入显存从而操作屏幕图像，write_ram.c:</p> 
<pre class="prettyprint"><code class="language-C hljs cs"><span class="hljs-keyword">void</span> CMain(<span class="hljs-keyword">void</span>) {
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">char</span>*p = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0xa0000</span>; i &lt;= <span class="hljs-number">0xaffff</span>; i++) {
        p = i;
        *p = i &amp; <span class="hljs-number">0x0f</span>;  
    }

    <span class="hljs-keyword">for</span>(;;) {
       io_hlt();
    }

}
</code></pre> 
<p>代码中，我们将指针P指向地址0xa0000, 这个地址正好就是vga显存地址，vga显存地址从0xa0000开始，直到0xaffff结束，总共64k.接着语句: <br> *p = i &amp; 0x0f 将一个数值写入显存，这个值可以是0-256中任意一个数值，我们代码里是将i的最后4位作为像素颜色写入显存，这个值是任意的，大家可以随意设置。</p> 
<p>在Ubuntu中写出上面代码后，通过命令编译成二进制文件： <br> gcc -m32 -fno-asynchronous-unwind-tables -s -c -o write_vga.asm write_vga.c</p> 
<p>于是在目录下会生成write_vga.o二进制文件，接着使用objconv进行反汇编： <br> ./objconv -fnasm write_vga.asm write_vga.o <br> 反汇编后代码如下:</p> 
<pre class="prettyprint"><code class="language-nasm hljs avrasm"><span class="hljs-comment">; Disassembly of file: write_vga.o</span>
<span class="hljs-comment">; Tue Sep 13 10:30:14 2016</span>
<span class="hljs-comment">; Mode: 32 bits</span>
<span class="hljs-comment">; Syntax: YASM/NASM</span>
<span class="hljs-comment">; Instruction set: 80386</span>


global CMain: function

extern io_hlt                                           <span class="hljs-comment">; near</span>


SECTION <span class="hljs-preprocessor">.text</span>   align=<span class="hljs-number">1</span> execute                         <span class="hljs-comment">; section number 1, code</span>

<span class="hljs-label">CMain:</span>  <span class="hljs-comment">; Function begin</span>
        <span class="hljs-keyword">push</span>    ebp                                     <span class="hljs-comment">; 0000 _ 55</span>
        <span class="hljs-keyword">mov</span>     ebp, esp                                <span class="hljs-comment">; 0001 _ 89. E5</span>
        <span class="hljs-keyword">sub</span>     esp, <span class="hljs-number">24</span>                                 <span class="hljs-comment">; 0003 _ 83. EC, 18</span>
        <span class="hljs-keyword">mov</span>     dword [ebp-<span class="hljs-number">0</span>CH], <span class="hljs-number">0</span>                      <span class="hljs-comment">; 0006 _ C7. 45, F4, 00000000</span>
        <span class="hljs-keyword">mov</span>     dword [ebp-<span class="hljs-number">10</span>H], <span class="hljs-number">655360</span>                 <span class="hljs-comment">; 000D _ C7. 45, F0, 000A0000</span>
        <span class="hljs-keyword">jmp</span>     ?_002                                   <span class="hljs-comment">; 0014 _ EB, 17</span>

?_001:  <span class="hljs-keyword">mov</span>     eax, dword [ebp-<span class="hljs-number">10</span>H]                    <span class="hljs-comment">; 0016 _ 8B. 45, F0</span>
        <span class="hljs-keyword">mov</span>     dword [ebp-<span class="hljs-number">0</span>CH], eax                    <span class="hljs-comment">; 0019 _ 89. 45, F4</span>
        <span class="hljs-keyword">mov</span>     eax, dword [ebp-<span class="hljs-number">10</span>H]                    <span class="hljs-comment">; 001C _ 8B. 45, F0</span>
        <span class="hljs-keyword">and</span>     eax, <span class="hljs-number">0</span>FH                                <span class="hljs-comment">; 001F _ 83. E0, 0F</span>
        <span class="hljs-keyword">mov</span>     edx, eax                                <span class="hljs-comment">; 0022 _ 89. C2</span>
        <span class="hljs-keyword">mov</span>     eax, dword [ebp-<span class="hljs-number">0</span>CH]                    <span class="hljs-comment">; 0024 _ 8B. 45, F4</span>
        <span class="hljs-keyword">mov</span>     byte [eax], dl                          <span class="hljs-comment">; 0027 _ 88. 10</span>
        <span class="hljs-keyword">add</span>     dword [ebp-<span class="hljs-number">10</span>H], <span class="hljs-number">1</span>                      <span class="hljs-comment">; 0029 _ 83. 45, F0, 01</span>
?_002:  cmp     dword [ebp-<span class="hljs-number">10</span>H], <span class="hljs-number">720895</span>                 <span class="hljs-comment">; 002D _ 81. 7D, F0, 000AFFFF</span>
        jle     ?_001                                   <span class="hljs-comment">; 0034 _ 7E, E0</span>
?_003:  <span class="hljs-keyword">call</span>    io_hlt                                  <span class="hljs-comment">; 0036 _ E8, FFFFFFFC(rel)</span>
        <span class="hljs-keyword">jmp</span>     ?_003                                   <span class="hljs-comment">; 003B _ EB, F9</span>
<span class="hljs-comment">; CMain End of function</span>


SECTION <span class="hljs-preprocessor">.data</span>   align=<span class="hljs-number">1</span> noexecute                       <span class="hljs-comment">; section number 2, data</span>


SECTION <span class="hljs-preprocessor">.bss</span>    align=<span class="hljs-number">1</span> noexecute                       <span class="hljs-comment">; section number 3, bss</span>
</code></pre> 
<p>在上面代码中去掉以section 开始的指令，这些指令会影响我们把当前汇编结合入内核kerne.asm. <br> 同时去掉开头的两句：</p> 
<p>global CMain: function <br> extern io_hlt </p> 
<p>因为我们要把两个汇编文件结合成一个，所以这两句声明是多余的。做完这些后，再用nasm编译kernel.asm: <br> nasm -o kernel.bat kernel.asm <br> 于是本地目录下，内核文件就编译好了。</p> 
<p>接着运行java工程，生成虚拟软盘，运行结果如下： <br> <img src="https://images2.imgbox.com/ed/1f/BfZSGwuV_o.png" alt="这里写图片描述" title=""></p> 
<p>大家注意看，kernel.bat写入了两个扇区，也就是说，我们内核的大小已经超过了512字节。此时我们需要修改一下内核加载器，让内核加载器一次读入两个扇区才能把内核完全加载入内存，打开boot.asm，将readFloppy中的： <br> mov ah, 0x02 <br> mov al, 1 <br> 改成： <br> mov al, 2 <br> 也就是一次读取两个扇区的内容，修改后再次编译boot.asm: <br> nasm -o boot.bat boot.asm</p> 
<p>最后再次运行java程序，此时生成的虚拟软盘中，才会包含完整的内核文件。启动虚拟机，加载虚拟软盘后，运行情况如下： <br> <img src="https://images2.imgbox.com/32/7f/ZSxxm6Bo_o.png" alt="这里写图片描述" title=""></p> 
<p>大家可以看到，屏幕显示出了条纹状图像。</p> 
<p>本节所以代码均可在网易云课堂上下载： <br> <a href="http://study.163.com/course/courseMain.htm?courseId=1003169025" rel="nofollow">Linux kernel Hacker, 从零构建自己的内核</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5846f4d9c0fbe6a8015f9399503f5b7d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java反射初步学习（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a184de4683d79c8711a10f99bb1a6515/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在浏览器地址栏输入一个URL后回车，执行的全部过程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>