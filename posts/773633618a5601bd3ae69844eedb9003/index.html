<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>php 扑克牌洗牌算法,随机洗牌算法 | 学步园 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="php 扑克牌洗牌算法,随机洗牌算法 | 学步园" />
<meta property="og:description" content="随机洗牌
其实我最初想到的也是那3个方法：1判断生成的随机数有没有重复，2.生成一张布尔表，3.双随机数。
下面给出我的算法：
#include #include #include using namespace std;
void RandCard(vector, int); //函数声明
int main(int argc, char *argv[])
{
vector nRetCard;
int nCards=54;
RandCard(nRetCard, nCards);
return 0;
}
void RandCard(vector nRetCard, int nCards)
{
int i, j, temp;
for(i=0; i
{
nRetCard.push_back(i&#43;1); //顺序生成初始值
}
srand(time(NULL));
for(i=0, j=nCards; i
{
temp=rand()%j; //从向量中随机取一个
cout&lt;
if( !((i&#43;1)%17) ) cout&lt;
nRetCard.erase(nRetCard.begin()&#43;temp); //删除用过的元素
}
}
其思路很简单，每次从向量中随机取一个数出来，利用vevtor向量的自动调整长度，每次删除一个元素，再用新的向量长度j生成随机数：temp=rand()%j; 显然算法的时间复杂度为O(n)(不考虑vevtor向量API的情况下)，即一趟for循环，不存在最坏情况。
但是注意，该方法的写法虽然简单，但是调用了vevtor向量的API，所以其实效率并不是特别高，但一般情况下够用了。
如果是PHP语言，那么它自带了一个随机洗牌的函数，即shuffle()，它的作用是随机地对数组元素重新排序。其形式为：
void shuffle(array input_array)
考虑一个数组，其中包含扑克牌的值：
$cards = array(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/773633618a5601bd3ae69844eedb9003/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-16T15:38:40+08:00" />
<meta property="article:modified_time" content="2021-03-16T15:38:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">php 扑克牌洗牌算法,随机洗牌算法 | 学步园</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>随机洗牌</p> 
 <p>其实我最初想到的也是那3个方法：1判断生成的随机数有没有重复，2.生成一张布尔表，3.双随机数。</p> 
 <p>下面给出我的算法：</p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>using namespace std;</p> 
 <p>void RandCard(vector, int); //函数声明</p> 
 <p>int main(int argc, char *argv[])</p> 
 <p>{<!-- --></p> 
 <p>vector nRetCard;</p> 
 <p>int nCards=54;</p> 
 <p>RandCard(nRetCard, nCards);</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>void RandCard(vector nRetCard, int nCards)</p> 
 <p>{<!-- --></p> 
 <p>int i, j, temp;</p> 
 <p>for(i=0; i</p> 
 <p>{<!-- --></p> 
 <p>nRetCard.push_back(i+1); //顺序生成初始值</p> 
 <p>}</p> 
 <p>srand(time(NULL));</p> 
 <p>for(i=0, j=nCards; i</p> 
 <p>{<!-- --></p> 
 <p>temp=rand()%j; //从向量中随机取一个</p> 
 <p>cout&lt;</p> 
 <p>if( !((i+1)%17) ) cout&lt;</p> 
 <p>nRetCard.erase(nRetCard.begin()+temp); //删除用过的元素</p> 
 <p>}</p> 
 <p>}</p> 
 <p>其思路很简单，每次从向量中随机取一个数出来，利用vevtor向量的自动调整长度，每次删除一个元素，再用新的向量长度j生成随机数：temp=rand()%j; 显然算法的时间复杂度为O(n)(不考虑vevtor向量API的情况下)，即一趟for循环，不存在最坏情况。</p> 
 <p>但是注意，该方法的写法虽然简单，但是调用了vevtor向量的API，所以其实效率并不是特别高，但一般情况下够用了。</p> 
 <p>如果是PHP语言，那么它自带了一个随机洗牌的函数，即shuffle()，它的作用是随机地对数组元素重新排序。其形式为：</p> 
 <p>void shuffle(array input_array)</p> 
 <p>考虑一个数组，其中包含扑克牌的值：</p> 
 <p>$cards = array("jh","js","jd","jc","qh","qs","qd","qc","kh","ks","kd","kc","ah","as","ad","ac");</p> 
 <p>$positions=shuffle($cards);</p> 
 <p>print_r($positions); //输出随机排序后的结果</p> 
 <p>另外PHP中的array_rand()函数可从数组中随机出一个或多个键，其形式为：</p> 
 <p>mixed array_rand(array array [, int num_entries] )</p> 
 <p>如果忽略可选的num_entries参数，则只返回一个随机值。可以通过设置num_entries来调整返回随机值的个数。</p> 
 <p>如果是Java语言，可以用我下面这个算法，效率是以上探讨过的方法中最高的，当然这个算法也可以用其他语言来实现，大概思路如下：</p> 
 <p>从0~size-1中产生一个随机数j，然后将a.[j]放到最末尾去(与最后一个未使用的数交换)，</p> 
 <p>然后再从0~size-2中产生一个随机数k，然后将a.[k]放到倒数第二个位置(与最后一个未使用的数交换)，</p> 
 <p>以此类推……最后，整个序列都被打乱了，而且数字成排列组合状态，不会有数字重复出现。</p> 
 <p>public static void main(String[] args) {<!-- --></p> 
 <p>ArrayList pokerCards = new ArrayList(5);</p> 
 <p>pokerCards.add("A");</p> 
 <p>pokerCards.add("B");</p> 
 <p>pokerCards.add("C");</p> 
 <p>pokerCards.add("D");</p> 
 <p>pokerCards.add("E");</p> 
 <p>zolltyRandom(pokerCards);</p> 
 <p>printList(pokerCards);</p> 
 <p>ArrayList excList = new ArrayList(5);</p> 
 <p>excList.add(new Exception("A"));</p> 
 <p>excList.add(new Exception("B"));</p> 
 <p>excList.add(new Exception("C"));</p> 
 <p>excList.add(new Exception("D"));</p> 
 <p>excList.add(new Exception("E"));</p> 
 <p>zolltyRandom(excList);</p> 
 <p>printList(excList);</p> 
 <p>int orgIntArray[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,</p> 
 <p>15, 16, 17, 18, 19, 20, 21 };</p> 
 <p>int resultArray[] = zolltyRandom(orgIntArray);</p> 
 <p>printArray(resultArray);</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>* 将原始数组重新随机排序(=洗牌)</p> 
 <p>*</p> 
 <p>* @param orgIntArray</p> 
 <p>* 例如{ 0, 1, 2, 3, 4, 5, 6, 7 }</p> 
 <p>* @return 排列后的数组</p> 
 <p>* @author zollty</p> 
 <p>*/</p> 
 <p>public static int[] zolltyRandom(int[] orgIntArray) {<!-- --></p> 
 <p>Random rand = new Random();</p> 
 <p>int pos, temp2;</p> 
 <p>int returnValue[] = new int[orgIntArray.length];</p> 
 <p>for (int i = 0, r = orgIntArray.length; i &lt; orgIntArray.length - 1; i++, r--) {<!-- --></p> 
 <p>pos = Math.abs(rand.nextInt()) % r;</p> 
 <p>returnValue[i] = orgIntArray[pos];</p> 
 <p>// [pos]已使用，与最后那个未使用的交换</p> 
 <p>temp2 = orgIntArray[pos];</p> 
 <p>orgIntArray[pos] = orgIntArray[r - 1];</p> 
 <p>orgIntArray[r - 1] = temp2;</p> 
 <p>}</p> 
 <p>returnValue[orgIntArray.length - 1] = orgIntArray[0];</p> 
 <p>return returnValue;</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>* 将ArrayList里面的元素随机排序(=洗牌)</p> 
 <p>*</p> 
 <p>* @param targetList</p> 
 <p>* 需要排序的"ArrayList"</p> 
 <p>* @author zollty</p> 
 <p>*/</p> 
 <p>@SuppressWarnings("unchecked")</p> 
 <p>public static void zolltyRandom(ArrayList targetList) {<!-- --></p> 
 <p>Random rand = new Random();</p> 
 <p>int pos;</p> 
 <p>int size = targetList.size();</p> 
 <p>targetList.add(targetList.get(0)); // 即targetList.get(size) 作为temp元素</p> 
 <p>for (int i = 0, r = size; i &lt; size - 1; i++, r--) {<!-- --></p> 
 <p>pos = Math.abs(rand.nextInt()) % r;</p> 
 <p>// [pos]已使用，与最后那个未使用的交换</p> 
 <p>targetList.set(size, targetList.get(pos)); // 将[pos]的值暂时转移到[size]上</p> 
 <p>targetList.set(pos, targetList.get(r - 1));</p> 
 <p>targetList.set(r - 1, targetList.get(size));</p> 
 <p>}</p> 
 <p>targetList.remove(size); // 移除temp元素</p> 
 <p>}</p> 
 <p>public static void printArray(int[] arry) {<!-- --></p> 
 <p>for (int j = 0; j &lt; arry.length; j++) {<!-- --></p> 
 <p>System.out.print(arry[j]);</p> 
 <p>if (j != arry.length - 1) {<!-- --></p> 
 <p>System.out.print(",");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>public static void printArray(String[] arry) {<!-- --></p> 
 <p>for (int j = 0; j &lt; arry.length; j++) {<!-- --></p> 
 <p>System.out.println(j + " =&gt; " + arry[j]);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>public static void printList(final List list) {<!-- --></p> 
 <p>int size = list.size();</p> 
 <p>for (int j = 0; j &lt; size; j++) {<!-- --></p> 
 <p>System.out.println(j + " =&gt; " + list.get(j));</p> 
 <p>}</p> 
 <p>}</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a61fdf7fe25f25e11298ace67a491387/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">php 扑克牌洗牌算法,算法思维系列/洗牌算法.md · 刘欢/fucking-algorithm - Gitee.com</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b314f05cd56c101abef67019e2d86df/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">matlab高斯滤波跟中值滤波区别,matlab图像滤波处理代码讲解 均值滤波 中值滤波 高斯滤波...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>