<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java IO 流Stream 序列化Serializable 文件File - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java IO 流Stream 序列化Serializable 文件File" />
<meta property="og:description" content="一、什么是流 流是个抽象的概念，是对输入输出设备的抽象，Java程序中，对于数据的输入/输出操作都是以“流”的方式进行。设备可以是文件，网络，内存等。 流具有方向性，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。
可以将流想象成一个“水流管道”，水流就在这管道中形成了，自然就出现了方向的概念。 当程序需要从某个数据源读入数据的时候，就会开启一个输入流，数据源可以是文件、内存或网络等等。相反地，需要写出数据到某个数据源目的地的时候，也会开启一个输出流，这个数据源目的地也可以是文件、内存或网络等等。
二、流的分类 可以从不同的角度对流进行分类：
处理的数据单位不同，可分为：字符流，字节流
数据流方向不同，可分为：输入流，输出流
功能不同，可分为：节点流，处理流
1 和 2 都比较好理解，对于根据功能分类的，可以这么理解： 节点流：节点流从一个特定的数据源读写数据。即节点流是直接操作文件，网络等的流，例如FileInputStream和FileOutputStream，他们直接从文件中读取或往文件中写入字节流。 处理流：“连接”在已存在的流（节点流或处理流）之上通过对数据的处理为程序提供更为强大的读写功能。过滤流是使用一个已经存在的输入流或输出流连接创建的，过滤流就是对节点流进行一系列的包装。例如BufferedInputStream和BufferedOutputStream，使用已经存在的节点流来构造，提供带缓冲的读写，提高了读写的效率，以及DataInputStream和DataOutputStream，使用已经存在的节点流来构造，提供了读写Java中的基本数据类型的功能。他们都属于过滤流。 举例：
import java.io.BufferedOutputStream; import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.BufferedInputStream; public class StreamTest { public static void main(String[] args) throws IOException { // 节点流FileOutputStream直接以A.txt作为数据源操作 FileOutputStream fileOutputStream = new FileOutputStream(&#34;A.txt&#34;); // 过滤流BufferedOutputStream进一步装饰节点流，提供缓冲写 BufferedOutputStream bufferedOutputStream = new BufferedOutputStream( fileOutputStream); // 过滤流DataOutputStream进一步装饰过滤流，使其提供基本数据类型的写 DataOutputStream out = new DataOutputStream(bufferedOutputStream); out.writeInt(3); out.writeBoolean(true); out.flush(); out.close(); // 此处输入节点流，过滤流正好跟上边输出对应，读者可举一反三 DataInputStream in = new DataInputStream(new BufferedInputStream( new FileInputStream(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1dd2fca3402ac98eebced2e18eac516d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-02-27T11:12:04+08:00" />
<meta property="article:modified_time" content="2016-02-27T11:12:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java IO 流Stream 序列化Serializable 文件File</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>一、什么是流</strong> <br> 流是个抽象的概念，是对输入输出设备的抽象，Java程序中，对于数据的输入/输出操作都是以“流”的方式进行。设备可以是文件，网络，内存等。 <br> <img src="https://images2.imgbox.com/a2/22/9XvINoJj_o.png" alt="这里写图片描述" title=""></p> 
<p>流具有方向性，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。</p> 
<p>可以将流想象成一个“水流管道”，水流就在这管道中形成了，自然就出现了方向的概念。 <br> <img src="https://images2.imgbox.com/06/06/6uWmjcQi_o.jpg" alt="这里写图片描述" title=""></p> 
<p>当程序需要从某个数据源读入数据的时候，就会开启一个输入流，数据源可以是文件、内存或网络等等。相反地，需要写出数据到某个数据源目的地的时候，也会开启一个输出流，这个数据源目的地也可以是文件、内存或网络等等。</p> 
<p><strong>二、流的分类</strong> <br> 可以从不同的角度对流进行分类：</p> 
<ol><li><p>处理的数据单位不同，可分为：字符流，字节流</p></li><li><p>数据流方向不同，可分为：输入流，输出流</p></li><li><p>功能不同，可分为：节点流，处理流</p></li></ol> 
<p>1 和 2 都比较好理解，对于根据功能分类的，可以这么理解： <br> 节点流：节点流从一个特定的数据源读写数据。即节点流是直接操作文件，网络等的流，例如FileInputStream和FileOutputStream，他们直接从文件中读取或往文件中写入字节流。 <br> <img src="https://images2.imgbox.com/c5/23/wzbyao8X_o.png" alt="这里写图片描述" title=""></p> 
<p>处理流：“连接”在已存在的流（节点流或处理流）之上通过对数据的处理为程序提供更为强大的读写功能。过滤流是使用一个已经存在的输入流或输出流连接创建的，过滤流就是对节点流进行一系列的包装。例如BufferedInputStream和BufferedOutputStream，使用已经存在的节点流来构造，提供带缓冲的读写，提高了读写的效率，以及DataInputStream和DataOutputStream，使用已经存在的节点流来构造，提供了读写Java中的基本数据类型的功能。他们都属于过滤流。 <br> <img src="https://images2.imgbox.com/52/b8/o0eLTmhX_o.png" alt="这里写图片描述" title=""></p> 
<p>举例：</p> 
<pre class="prettyprint"><code class=" hljs actionscript"><span class="hljs-preprocessor"><span class="hljs-keyword">import</span> java.io.BufferedOutputStream;</span>
<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> java.io.DataInputStream;</span>
<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> java.io.DataOutputStream;</span>
<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> java.io.FileInputStream;</span>
<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> java.io.FileOutputStream;</span>
<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> java.io.IOException;</span>
<span class="hljs-preprocessor"><span class="hljs-keyword">import</span> java.io.BufferedInputStream;</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamTest</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) throws IOException {
        <span class="hljs-comment">// 节点流FileOutputStream直接以A.txt作为数据源操作</span>
        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"A.txt"</span>);
        <span class="hljs-comment">// 过滤流BufferedOutputStream进一步装饰节点流，提供缓冲写</span>
        BufferedOutputStream bufferedOutputStream = <span class="hljs-keyword">new</span> BufferedOutputStream(
                fileOutputStream);
        <span class="hljs-comment">// 过滤流DataOutputStream进一步装饰过滤流，使其提供基本数据类型的写</span>
        DataOutputStream out = <span class="hljs-keyword">new</span> DataOutputStream(bufferedOutputStream);
        out.writeInt(<span class="hljs-number">3</span>);
        out.writeBoolean(<span class="hljs-literal">true</span>);
        out.flush();
        out.close();
        <span class="hljs-comment">// 此处输入节点流，过滤流正好跟上边输出对应，读者可举一反三</span>
        DataInputStream <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> BufferedInputStream(
                <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"A.txt"</span>)));
        System.out.println(<span class="hljs-keyword">in</span>.readInt());
        System.out.println(<span class="hljs-keyword">in</span>.readBoolean());
        <span class="hljs-keyword">in</span>.close();
    }
}</code></pre> 
<p>三、流结构介绍 <br> Java所有的流类位于java.io包中，都分别继承字以下四种抽象流类型。</p> 
<table><tbody><tr><td> </td><td>字节流</td><td>字符流</td></tr><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table> 
<p>1.继承自InputStream/OutputStream的流都是用于向程序中输入/输出数据，且数据的单位都是字节(byte=8bit)，如图，深色的为节点流，浅色的为处理流。 <br> <img src="https://images2.imgbox.com/5f/20/9RMuV7tc_o.png" alt="这里写图片描述" title=""></p> 
<p>2.继承自Reader/Writer的流都是用于向程序中输入/输出数据，且数据的单位都是字符(2byte=16bit)，如图，深色的为节点流，浅色的为处理流。 <br> <img src="https://images2.imgbox.com/b2/1f/oTiIjgKR_o.png" alt="这里写图片描述" title=""></p> 
<p>四、常用流类介绍 <br> 节点流类型常见的有：</p> 
<p>对文件操作的字符流有FileReader/FileWriter，字节流有FileInputStream/FileOutputStream。</p> 
<p>处理流类型常见的有：</p> 
<p>1.缓冲流：缓冲流要“套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写效率，同事增加了一些新的方法。</p> 
<p>　　字节缓冲流有BufferedInputStream/BufferedOutputStream，字符缓冲流有BufferedReader/BufferedWriter，字符缓冲流分别提供了读取和写入一行的方法ReadLine和NewLine方法。</p> 
<p>　　对于输出地缓冲流，写出的数据，会先写入到内存中，再使用flush方法将内存中的数据刷到硬盘。所以，在使用字符缓冲流的时候，一定要先flush，然后再close，避免数据丢失。</p> 
<p>2.转换流：用于字节数据到字符数据之间的转换。 <br> 　　仅有字符流InputStreamReader/OutputStreamWriter。其中，InputStreamReader需要与InputStream“套接”，OutputStreamWriter需要与OutputStream“套接”。</p> 
<p>3.数据流：提供了读写Java中的基本数据类型的功能。 <br> 　　DataInputStream和DataOutputStream分别继承自InputStream和OutputStream，需要“套接”在InputStream和OutputStream类型的节点流之上。</p> 
<p>4.对象流：用于直接将对象写入写出。 <br> 　　流类有ObjectInputStream和ObjectOutputStream，本身这两个方法没什么，但是其要写出的对象有要求，该对象必须实现Serializable接口，来声明其是可以序列化的。否则，不能用对象流读写。</p> 
<p>　　还有一个关键字比较重要，transient，由于修饰实现了Serializable接口的类内的属性，被该修饰符修饰的属性，在以对象流的方式输出的时候，该字段会被忽略。</p> 
<p>五、Serializable</p> 
<p>六、面试题 <br> 1.Java中如何实现序列化，有什么意义？ <br> 答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 <br> 要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考《<a href="http://blog.csdn.net/u010575093/article/details/50733588">java 对象克隆</a>》）。</p> 
<p>2.Java中有几种类型的流？ <br> 答：字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。</p> 
<p>3.编程实现文件拷贝。（这个题目在笔试的时候经常出现，下面的代码给出了两种实现方案）</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.FileOutputStream;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.InputStream;
<span class="hljs-keyword">import</span> java.io.OutputStream;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;

<span class="hljs-comment">//文件拷贝工具类</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileCopyUtil</span> {<!-- --></span>
    <span class="hljs-comment">// 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title">FileCopyUtil</span>() {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();
    }

    <span class="hljs-comment">//文件拷贝</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fileCopy</span>(String source, String target) <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-keyword">try</span> (InputStream in = <span class="hljs-keyword">new</span> FileInputStream(source)) {
            <span class="hljs-keyword">try</span> (OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(target)) {
                <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4096</span>];
                <span class="hljs-keyword">int</span> bytesToRead;
                <span class="hljs-keyword">while</span>((bytesToRead = in.read(buffer)) != -<span class="hljs-number">1</span>) {
                    out.write(buffer, <span class="hljs-number">0</span>, bytesToRead);
                }
            }
        }
    }

    <span class="hljs-comment">//使用NIO实现的文件拷贝</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fileCopyNIO</span>(String source, String target) <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-keyword">try</span> (FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(source)) {
            <span class="hljs-keyword">try</span> (FileOutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(target)) {
                FileChannel inChannel = in.getChannel();
                FileChannel outChannel = out.getChannel();
                ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">4096</span>);
                <span class="hljs-keyword">while</span>(inChannel.read(buffer) != -<span class="hljs-number">1</span>) {
                    buffer.flip();
                    outChannel.write(buffer);
                    buffer.clear();
                }
            }
        }
    }
}</code></pre> 
<p>关于第二篇文章，参考我文章类表中有关java NIO或Buffer.flips()的有关内容。</p> 
<blockquote> 
 <p>注意：上面用到Java 7的TWR(try-with-resources AutoCloseable)，使用TWR后可以不用在finally中释放外部资源 ，从而让代码更加优雅。</p> 
</blockquote> 
<p>4.写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。 <br> 答：代码如下：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;
<span class="hljs-keyword">import</span> java.io.FileReader;

<span class="hljs-comment">//文件中单词计数工具类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountWordInFileUtil</span> {<!-- --></span>

    <span class="hljs-comment">// 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯)</span>
     <span class="hljs-keyword">private</span> <span class="hljs-title">CountWordInFileUtil</span>() {
         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();
     }

     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countWordInFile</span>(String filename, String word) {
         <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;
         <span class="hljs-keyword">try</span> (FileReader fr = <span class="hljs-keyword">new</span> FileReader(filename)) {
             <span class="hljs-keyword">try</span> (BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(fr)) {
                 String line = <span class="hljs-keyword">null</span>;
                 <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-keyword">null</span>) {
                     <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>;
                     <span class="hljs-keyword">while</span> (line.length() &gt;= word.length() &amp;&amp; (index = line.indexOf(word)) &gt;= <span class="hljs-number">0</span>) {
                         counter++;
                         line = line.substring(index + word.length());
                     }
                 }
             }
         } <span class="hljs-keyword">catch</span> (Exception ex) {
            ex.printStackTrace();
        }
         <span class="hljs-keyword">return</span> counter;
     }
}</code></pre> 
<p>5.如何用Java代码列出一个目录下所有的文件？ <br> 答： <br> 如果只要求列出当前文件夹下的文件，代码如下所示：</p> 
<pre class="prettyprint"><code class=" hljs cs">import java.io.File;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> FilesInDirectoryTest {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> (String[] args) {
        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"/Users"</span>);
        <span class="hljs-keyword">for</span> (File temp : file.listFiles()) {
            <span class="hljs-keyword">if</span> (temp.isFile()) {
                System.<span class="hljs-keyword">out</span>.println(temp.getName());
            }
        }
    }
}</code></pre> 
<p>如果需要对文件夹继续展开，代码如下所示：</p> 
<pre class="prettyprint"><code class=" hljs cs">import java.io.File;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> FilesInDirectoryTest1 {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        showDirectory(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"/Users"</span>));
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showDirectory</span>(File f) {
        _walkDirectory(f, <span class="hljs-number">0</span>);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _<span class="hljs-title">walkDirectory</span>(File f, <span class="hljs-keyword">int</span> level) {
        <span class="hljs-keyword">if</span>(f.isDirectory()) {
            <span class="hljs-keyword">for</span>(File temp : f.listFiles()) {
                _walkDirectory(temp, level + <span class="hljs-number">1</span>);
            }
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level - <span class="hljs-number">1</span>; i++) {
                System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">"\t"</span>);
            }
            System.<span class="hljs-keyword">out</span>.println(f.getName());
        }
    }
}</code></pre> 
<p>在Java 7中可以使用NIO.2的API来做同样的事情，代码如下所示：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">import java<span class="hljs-preprocessor">.io</span><span class="hljs-preprocessor">.IOException</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.nio</span><span class="hljs-preprocessor">.file</span><span class="hljs-preprocessor">.attribute</span><span class="hljs-preprocessor">.BasicFileAttributes</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.nio</span><span class="hljs-preprocessor">.file</span><span class="hljs-preprocessor">.FileVisitResult</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.nio</span><span class="hljs-preprocessor">.file</span><span class="hljs-preprocessor">.Files</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.nio</span><span class="hljs-preprocessor">.file</span><span class="hljs-preprocessor">.Path</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.nio</span><span class="hljs-preprocessor">.file</span><span class="hljs-preprocessor">.Paths</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.nio</span><span class="hljs-preprocessor">.file</span><span class="hljs-preprocessor">.SimpleFileVisitor</span><span class="hljs-comment">;</span>

public class FilesInDirectoryTest3 {

    public static void main(String[] args) throws IOException {
        Path initPath = Paths<span class="hljs-preprocessor">.get</span>(<span class="hljs-string">"/Users/xudong/Documents/books"</span>)<span class="hljs-comment">;</span>
        Files<span class="hljs-preprocessor">.walkFileTree</span>(initPath, new SimpleFileVisitor&lt;Path&gt;() {

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) 
                    throws IOException {
                System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(file<span class="hljs-preprocessor">.getFileName</span>()<span class="hljs-preprocessor">.toString</span>())<span class="hljs-comment">;</span>
                return FileVisitResult<span class="hljs-preprocessor">.CONTINUE</span><span class="hljs-comment">;</span>
            }
        })<span class="hljs-comment">;</span>
    }
}</code></pre> 
<p>6.用Java的套接字编程实现一个多线程的回显（echo）服务器。 <br> 答：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.InputStreamReader;
<span class="hljs-keyword">import</span> java.io.PrintWriter;
<span class="hljs-keyword">import</span> java.net.ServerSocket;
<span class="hljs-keyword">import</span> java.net.Socket;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> {<!-- --></span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ECHO_SERVER_PORT = <span class="hljs-number">6789</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {        
        <span class="hljs-keyword">try</span>(ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(ECHO_SERVER_PORT)) {
            System.out.println(<span class="hljs-string">"服务器已经启动..."</span>);
            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) {
                Socket client = server.accept();
                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ClientHandler(client)).start();
            }
        } <span class="hljs-keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> {<!-- --></span>
        <span class="hljs-keyword">private</span> Socket client;

        <span class="hljs-keyword">public</span> <span class="hljs-title">ClientHandler</span>(Socket client) {
            <span class="hljs-keyword">this</span>.client = client;
        }

        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
            <span class="hljs-keyword">try</span>(BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(client.getInputStream()));
                    PrintWriter pw = <span class="hljs-keyword">new</span> PrintWriter(client.getOutputStream())) {
                String msg = br.readLine();
                System.out.println(<span class="hljs-string">"收到"</span> + client.getInetAddress() + <span class="hljs-string">"发送的: "</span> + msg);
                pw.println(msg);
                pw.flush();
            } <span class="hljs-keyword">catch</span>(Exception ex) {
                ex.printStackTrace();
            } <span class="hljs-keyword">finally</span> {
                <span class="hljs-keyword">try</span> {
                    client.close();
                } <span class="hljs-keyword">catch</span> (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}</code></pre> 
<blockquote> 
 <p>注意：上面的代码使用了Java 7的TWR语法，由于很多外部资源类都间接的实现了AutoCloseable接口（单方法回调接口），因此可以利用TWR语法在try结束的时候通过回调的方式自动调用外部资源类的close()方法，避免书写冗长的finally代码块。此外，上面的代码用一个静态内部类实现线程的功能，使用多线程可以避免一个用户I/O操作所产生的中断影响其他用户对服务器的访问，简单的说就是一个用户的输入操作不会造成其他用户的阻塞。当然，上面的代码使用线程池可以获得更好的性能，因为频繁的创建和销毁线程所造成的开销也是不可忽视的。</p> 
</blockquote> 
<p>下面是一段回显客户端测试代码：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">import java<span class="hljs-preprocessor">.io</span><span class="hljs-preprocessor">.BufferedReader</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.io</span><span class="hljs-preprocessor">.InputStreamReader</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.io</span><span class="hljs-preprocessor">.PrintWriter</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.net</span><span class="hljs-preprocessor">.Socket</span><span class="hljs-comment">;</span>
import java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.Scanner</span><span class="hljs-comment">;</span>

public class EchoClient {

    public static void main(String[] args) throws Exception {
        Socket client = new Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">6789</span>)<span class="hljs-comment">;</span>
        Scanner sc = new Scanner(System<span class="hljs-preprocessor">.in</span>)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.print</span>(<span class="hljs-string">"请输入内容: "</span>)<span class="hljs-comment">;</span>
        String msg = sc<span class="hljs-preprocessor">.nextLine</span>()<span class="hljs-comment">;</span>
        sc<span class="hljs-preprocessor">.close</span>()<span class="hljs-comment">;</span>
        PrintWriter pw = new PrintWriter(client<span class="hljs-preprocessor">.getOutputStream</span>())<span class="hljs-comment">;</span>
        pw<span class="hljs-preprocessor">.println</span>(msg)<span class="hljs-comment">;</span>
        pw<span class="hljs-preprocessor">.flush</span>()<span class="hljs-comment">;</span>
        BufferedReader br = new BufferedReader(new InputStreamReader(client<span class="hljs-preprocessor">.getInputStream</span>()))<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(br<span class="hljs-preprocessor">.readLine</span>())<span class="hljs-comment">;</span>
        client<span class="hljs-preprocessor">.close</span>()<span class="hljs-comment">;</span>
    }
}</code></pre> 
<p>如果希望用NIO的多路复用套接字实现服务器，代码如下所示。NIO的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.CharBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;
<span class="hljs-keyword">import</span> java.nio.channels.Selector;
<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;
<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerNIO</span> {<!-- --></span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ECHO_SERVER_PORT = <span class="hljs-number">6789</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ECHO_SERVER_TIMEOUT = <span class="hljs-number">5000</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BUFFER_SIZE = <span class="hljs-number">1024</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerSocketChannel serverChannel = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Selector selector = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 多路复用选择器</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ByteBuffer buffer = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 缓冲区</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        init();
        listen();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>() {
        <span class="hljs-keyword">try</span> {
            serverChannel = ServerSocketChannel.open();
            buffer = ByteBuffer.allocate(BUFFER_SIZE);
            serverChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(ECHO_SERVER_PORT));
            serverChannel.configureBlocking(<span class="hljs-keyword">false</span>);
            selector = Selector.open();
            serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span>() {
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">if</span> (selector.select(ECHO_SERVER_TIMEOUT) != <span class="hljs-number">0</span>) {
                    Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();
                    <span class="hljs-keyword">while</span> (it.hasNext()) {
                        SelectionKey key = it.next();
                        it.remove();
                        handleKey(key);
                    }
                }
            } <span class="hljs-keyword">catch</span> (Exception e) {
                e.printStackTrace();
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleKey</span>(SelectionKey key) <span class="hljs-keyword">throws</span> IOException {
        SocketChannel channel = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (key.isAcceptable()) {
                ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
                channel = serverChannel.accept();
                channel.configureBlocking(<span class="hljs-keyword">false</span>);
                channel.register(selector, SelectionKey.OP_READ);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) {
                channel = (SocketChannel) key.channel();
                buffer.clear();
                <span class="hljs-keyword">if</span> (channel.read(buffer) &gt; <span class="hljs-number">0</span>) {
                    buffer.flip();
                    CharBuffer charBuffer = CharsetHelper.decode(buffer);
                    String msg = charBuffer.toString();
                    System.out.println(<span class="hljs-string">"收到"</span> + channel.getRemoteAddress() + <span class="hljs-string">"的消息："</span> + msg);
                    channel.write(CharsetHelper.encode(CharBuffer.wrap(msg)));
                } <span class="hljs-keyword">else</span> {
                    channel.close();
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) {
                channel.close();
            }
        }
    }
}</code></pre> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.CharBuffer;
<span class="hljs-keyword">import</span> java.nio.charset.CharacterCodingException;
<span class="hljs-keyword">import</span> java.nio.charset.Charset;
<span class="hljs-keyword">import</span> java.nio.charset.CharsetDecoder;
<span class="hljs-keyword">import</span> java.nio.charset.CharsetEncoder;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharsetHelper</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String UTF_8 = <span class="hljs-string">"UTF-8"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CharsetEncoder encoder = Charset.forName(UTF_8).newEncoder();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CharsetDecoder decoder = Charset.forName(UTF_8).newDecoder();

    <span class="hljs-keyword">private</span> <span class="hljs-title">CharsetHelper</span>() {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">encode</span>(CharBuffer in) <span class="hljs-keyword">throws</span> CharacterCodingException{
        <span class="hljs-keyword">return</span> encoder.encode(in);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CharBuffer <span class="hljs-title">decode</span>(ByteBuffer in) <span class="hljs-keyword">throws</span> CharacterCodingException{
        <span class="hljs-keyword">return</span> decoder.decode(in);
    }
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4b39bab7cc10706f7e4981d39bd80cd1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">线上Nginx跳转存在的接口返回异常问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5974577e0313b27f68e0528481829888/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决vi编辑器不能使用方向键和退格键问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>