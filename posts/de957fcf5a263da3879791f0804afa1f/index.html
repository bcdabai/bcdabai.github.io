<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>node深入学习(1) eventloop - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="node深入学习(1) eventloop" />
<meta property="og:description" content="多线程 优点：同时处理多个请求，适合cpu密集型运算
缺点：如果多个线程操作同一个资源得上锁。多线程并不是一起去干一些事情，而是靠切换上下文（浪费一些性能）
单线程 node的主线程是单线程，不需要开启多个线程，节省资源，不适合做大量的cpu操作。但是node提供了开启子进程，可以将比较大的操作放入子进程去运行。
同步异步和阻塞非阻塞 阻塞非阻塞是相对于操作方的，操作放调用了同步方法，这时候就会阻塞。同步异步是相对于调用的方法。比如调用readFile就是异步的。
异步非阻塞：调用异步的方法，操作方不会被阻塞。
event loop 因为node的主线程是单线程，所以node也实现了自己的event loop。
1 代码会交给v8引擎进行处理2 代码中可能会调用nodeApi，node会交给libuv库处理3 libuv通过阻塞i/o和多线程实现了异步io。4 通过事件驱动的方式，将结果放入事件队列中，最终交给我们的应用。 node使用 默认执行一个文件的时候，在命令行运行node index.js文件的时候，他会把整个文件当成一个模块，默认把this修改了。
在全局下指向的就是global。
node新增的全局属性 buffer node中的二进制对象（最早的时候浏览器不能直接读写文件）process 进程
process中的一些属性： platform 当前执行环境的平台（如window(win32)，mac(darwin))chidir,以更改当前工作的目录env 执行代码的时候可以传入一些环境变量argv 执行代码的时候可以传入的参数
可以通过传入参数获取。第一二个值是固定的，
[执行node所在的exe文件，当前的执行文件，…其他参数],用户脚手架启动项目的时候传入一些参数，然后在配置文件中获取这些值。
解析可以用到commander库（命令行管家）
nextTick
下面祥讲cwd (current working directory)当前工作的目录，比如webpack会自动擦护照运行webpack的目录下查找webpack.config.js文件。 __dirname(当前执行时的目录，绝对路劲) __filename（当前执行时的文件的绝对路劲）
setImmediate nextTick与node的eventloop node中自己实现的，不属于node的eventloop。优先级比Promise更高。nextTick算是微任务，他是当前栈中同步代码执行完毕后立即执行的。因为Node里也有一些异步操作，所以node实现了自己的eventLoop。
而node中的异步队列不比浏览器，node有很多类型的宏任务队列。
这是官网的案例。
一共有六种。 第一种是setTImeout等到时间就放入这个队列。
第二种就是一些回调函数，还有第四种io任务非常多，导致只能下一个循环执行，就会放入这里。
第三种是内部使用的
第四种是与io相关的回调 (poll, 比如readFIle)。
第五种是setImmediate的回调函数
第六种是一些关闭的回调函数。
我们重点需要关注第一种，第四种，第五种。
poll主要是放Io的回调，必须对文件的读写这些readFile等。
第五种check放一些setImmediate的回调。代码是从上往下执行的，从第一种走到第六种，走完之后继续走，是个死循环。但是有个问题，比如setTimeout按道理是在setImmediate前执行，但是有时候会setImmediate先执行。是因为当前默认执行主栈代码，主栈代码执行完毕后要执行定时器，但是定时器可能还没到时间，所以就先往下走，所以setImmediate可能会先执行。
有个特殊情况。就是
当执行io操作的时候，如上，主栈执行完代码之后，会走eventloop，此时同步代码没有setTimeout等，会直接走到第四种，poll，poll中有readFile这个io操作已经完成好的的回调，放在了poll，然后执行回调函数，检查到了setTImeout和setImmediate，分别放入timer队列，和check队列。接着执行完毕后会检查check队列，因为刚才已经放入一个了，所以会立马执行。然后等待setTimeout执行完之后再回到第一种往下执行，所以poll队列的特点是执行完当前队列会先检查有没有check队列的要执行，有的话会先执行第五个队列check的东西。
所以会出现这种情况。等待完毕后会往回去执行第一个timer队列里面的东西。
浏览器的特点是，先执行栈中代码，清空后为执行微任务，然后渲染页面，再从宏任务队列中取出一个来执行。node是先执行栈代码，执行完毕后，清空当前的微任务队列，会进入事件环中（evetloop），拿出一个来执行，执行完毕后再次清空当前微任务队列。（以前是一个队列！ 清空完，再清空微任务，现在是一个执行完，就清空微任务，为的就是跟浏览器表现一致） global的其他重要属性 global上可以直接访问的属性叫全局属性，而requrei,exports,moudel也可以直接访问，但是不在global。因为每个文件都是一个模块，就好比自执行函数。如
(function(rqeuire, exports, module){})(require,exports,module) 他是作为入参传入，然后在这个模块就可以使用这些。而global上没有。
模块化 为什么要有模块化？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/de957fcf5a263da3879791f0804afa1f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-01T08:45:21+08:00" />
<meta property="article:modified_time" content="2021-12-01T08:45:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">node深入学习(1) eventloop</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>多线程</h3> 
<p>优点：同时处理多个请求，适合cpu密集型运算<br> 缺点：如果多个线程操作同一个资源得上锁。多线程并不是一起去干一些事情，而是靠切换上下文（浪费一些性能）</p> 
<h3><a id="_3"></a>单线程</h3> 
<p>node的主线程是单线程，不需要开启多个线程，节省资源，不适合做大量的cpu操作。但是node提供了开启子进程，可以将比较大的操作放入子进程去运行。</p> 
<h3><a id="_5"></a>同步异步和阻塞非阻塞</h3> 
<p>阻塞非阻塞是相对于操作方的，操作放调用了同步方法，这时候就会阻塞。同步异步是相对于调用的方法。比如调用readFile就是异步的。<br> 异步非阻塞：调用异步的方法，操作方不会被阻塞。</p> 
<h3><a id="event_loop_8"></a>event loop</h3> 
<p>因为node的主线程是单线程，所以node也实现了自己的event loop。<br> <img src="https://images2.imgbox.com/0d/21/RWwMAdS5_o.png" alt="在这里插入图片描述"></p> 
<ul><li>1 代码会交给v8引擎进行处理</li><li>2 代码中可能会调用nodeApi，node会交给libuv库处理</li><li>3 libuv通过阻塞i/o和多线程实现了异步io。</li><li>4 通过事件驱动的方式，将结果放入事件队列中，最终交给我们的应用。</li></ul> 
<h3><a id="node_18"></a>node使用</h3> 
<p>默认执行一个文件的时候，在命令行运行node index.js文件的时候，他会把整个文件当成一个模块，默认把this修改了。<br> <img src="https://images2.imgbox.com/92/ba/Xe2FyVPv_o.png" alt="在这里插入图片描述"><br> 在全局下指向的就是global。</p> 
<h4><a id="node_22"></a>node新增的全局属性</h4> 
<ul><li>buffer node中的二进制对象（最早的时候浏览器不能直接读写文件）</li><li>process 进程<br> process中的一些属性：</li></ul> 
<ol><li>platform 当前执行环境的平台（如window(win32)，mac(darwin))</li><li>chidir,以更改当前工作的目录</li><li>env 执行代码的时候可以传入一些环境变量</li><li>argv 执行代码的时候可以传入的参数<br> <img src="https://images2.imgbox.com/5f/0b/rMy3Sz0d_o.png" alt="在这里插入图片描述"><br> 可以通过传入参数获取。第一二个值是固定的，<br> [执行node所在的exe文件，当前的执行文件，…其他参数],用户脚手架启动项目的时候传入一些参数，然后在配置文件中获取这些值。<br> 解析可以用到commander库（命令行管家）<br> <img src="https://images2.imgbox.com/57/e6/oltST32k_o.png" alt="在这里插入图片描述"></li><li>nextTick<br> 下面祥讲</li><li>cwd (current working directory)当前工作的目录，比如webpack会自动擦护照运行webpack的目录下查找webpack.config.js文件。</li></ol> 
<ul><li>__dirname(当前执行时的目录，绝对路劲) __filename（当前执行时的文件的绝对路劲）<br> <img src="https://images2.imgbox.com/d8/b3/99WrWBzr_o.png" alt="在这里插入图片描述"></li><li>setImmediate</li></ul> 
<h3><a id="nextTicknodeeventloop_41"></a>nextTick与node的eventloop</h3> 
<p>node中自己实现的，不属于node的eventloop。优先级比Promise更高。nextTick算是微任务，他是当前栈中同步代码执行完毕后立即执行的。因为Node里也有一些异步操作，所以node实现了自己的eventLoop。<br> 而node中的异步队列不比浏览器，node有很多类型的宏任务队列。<br> <img src="https://images2.imgbox.com/52/94/lFR37vgd_o.png" alt="在这里插入图片描述"><br> 这是官网的案例。<br> <img src="https://images2.imgbox.com/5b/45/jRBqUQT6_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="_47"></a>一共有六种。</h6> 
<ul><li>第一种是setTImeout等到时间就放入这个队列。<br> 第二种就是一些回调函数，还有第四种io任务非常多，导致只能下一个循环执行，就会放入这里。<br> 第三种是内部使用的<br> 第四种是与io相关的回调 (poll, 比如readFIle)。<br> 第五种是setImmediate的回调函数<br> 第六种是一些关闭的回调函数。<br> 我们重点需要关注第一种，第四种，第五种。<br> poll主要是放Io的回调，必须对文件的读写这些readFile等。<br> 第五种check放一些setImmediate的回调。</li><li>代码是从上往下执行的，从第一种走到第六种，走完之后继续走，是个死循环。</li><li>但是有个问题，比如setTimeout按道理是在setImmediate前执行，但是有时候会setImmediate先执行。是因为当前默认执行主栈代码，主栈代码执行完毕后要执行定时器，但是定时器可能还没到时间，所以就先往下走，所以setImmediate可能会先执行。<br> <img src="https://images2.imgbox.com/5f/0f/roOBRTWb_o.png" alt="在这里插入图片描述"></li></ul> 
<p><img src="https://images2.imgbox.com/0c/57/wduzfdQW_o.png" alt="在这里插入图片描述"><br> 有个特殊情况。就是<img src="https://images2.imgbox.com/a9/55/nTNF1Itg_o.png" alt="在这里插入图片描述"></p> 
<p>当执行io操作的时候，如上，主栈执行完代码之后，会走eventloop，此时同步代码没有setTimeout等，会直接走到第四种，poll，poll中有readFile这个io操作已经完成好的的回调，放在了poll，然后执行回调函数，检查到了setTImeout和setImmediate，分别放入timer队列，和check队列。接着执行完毕后会检查check队列，因为刚才已经放入一个了，所以会立马执行。然后等待setTimeout执行完之后再回到第一种往下执行，所以poll队列的特点是执行完当前队列会先检查有没有check队列的要执行，有的话会先执行第五个队列check的东西。<br> <img src="https://images2.imgbox.com/cc/ec/CJGTtAn9_o.png" alt="在这里插入图片描述"><br> 所以会出现这种情况。等待完毕后会往回去执行第一个timer队列里面的东西。</p> 
<ul><li>浏览器的特点是，先执行栈中代码，清空后为执行微任务，然后渲染页面，再从宏任务队列中取出一个来执行。</li><li>node是先执行栈代码，执行完毕后，清空当前的微任务队列，会进入事件环中（evetloop），拿出一个来执行，执行完毕后再次清空当前微任务队列。（以前是一个队列！ 清空完，再清空微任务，现在是一个执行完，就清空微任务，为的就是跟浏览器表现一致）</li></ul> 
<h3><a id="global_69"></a>global的其他重要属性</h3> 
<p>global上可以直接访问的属性叫全局属性，而requrei,exports,moudel也可以直接访问，但是不在global。因为每个文件都是一个模块，就好比自执行函数。如</p> 
<pre><code>(function(rqeuire, exports, module){})(require,exports,module)
</code></pre> 
<p>他是作为入参传入，然后在这个模块就可以使用这些。而global上没有。</p> 
<h3><a id="_75"></a>模块化</h3> 
<p>为什么要有模块化？</p> 
<ul><li>一开始是为了解决命名冲突问题 
  <ol><li>最开始是用对象，单例模式，但是不能完全解决这些问题</li><li>然后就是自执行函数，配合文件拆问的方式。但是会有请求问题，依赖问题，（amd cmd）。所以才有define([‘jqury’,‘vue’],()=&gt;{})这种前置依赖，后来也逐渐被淘汰。</li><li>umd,兼容amd+cmd+commonjs，但是不支持esmodule</li><li>commonjs规范(一个文件就是一个模块，使用就用require，导出就module.exports，他只是一个规范） esmoudle(es的规范，使用就是import from ,到处就是export)</li><li>commonjs是基于文件的读写的，是同步的，而且不能在编译时确定，只有在运行的时候才会报错。）</li><li>esmodule支持静态编译，（正常每次import一个模块，会发请求，是异步操作，但现在都是靠webpack编译，不会发请求，而是编译成require这些。）</li><li>这也是为什么import不能在if里面编写。import是静态导入，因为总不能在if（true）import 'xx’就去请求，卡在这里,只能放在顶部，这样webpack就会去编译，而放入条件判断中，因为条件判断必须要动态执行才知道结果，所以不可以这样。但是commonjs可以。因为require是同步的，后面es7又出了一个import()就可以在if里面编写。</li></ol> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/952664bdf55fd5e0137fcd97e87cdd92/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构：弗洛伊德算法（最短路径）图文详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/278b55d70652591125444ffd08bcc1c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Cloud Gateway系列【1】API网关概述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>