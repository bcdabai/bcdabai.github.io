<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux UNIX域socket，进程间通信 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux UNIX域socket，进程间通信" />
<meta property="og:description" content="一、UNIX域套接字 UNIX域套接字作用在同一台计算机上运行的两个进程间的通信。UNIX域套接字比因特尔网络套接字效率要高。它仅复制数据，不执行协议处理，不需要添加或删除网络报文头，无需计算校验和，不要产生顺序号，无需发送确认报文等等。UNIX域套接字有两种类型的套接字：字节流套接字和数据报套接字，字节流套接字类似于TCP，数据报套接字类似于UDPUNIX域套接字连接的一对套接字可以起到全双工管道的作用，是全双工的通信方式。 二、数据结构 2.1 unix域套接字的地址结构 struct sockaddr_un { sa_family_t sun_family; /* AF_UNIX 或 AF_LOCAL */ char sun_path[108]; /* pathname */ } sun_path是一个路径名，此路径名的属性为0777，可以进行读写等操作这个路径名应该是一个绝对路径名，而不是一个相对路径名。因为解析相对路径名依赖调用者当前工作目录，如果使用使用相对路径名就必须要确保服务器与客户端程序运行在相同目录下，否则将会出现异常除了普通路径名外，还可以使用抽象路径名。好处是不用担心出现文件已存在情况，同时程序结束，也会自动删除这个抽象名。但是，在计算抽象路径名长度的时候要注意。 2.2 创建套接字 /* 功能：socket的创建 参数： domain：AF_UNIX 或 AF_LOCAL type：套接字类型：字节流套接字（SOCK_STREAM）与数据报套接字（SOCK_DGRAM） protocol：如果第二参数不是SOCK_RAM原始套接字类型，一般设为0 返回值：成功返回文件描述符，失败返回 -1 */ #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int socket(int domain,int type,int protocol); 2.3 地址绑定 /* 功能：在UNIX域socket中bind函数不是用来绑定IP和端口，而是绑定一个有效路径名 参数： sockfd：socket函数返回的文件描述符 addr：套接字的地址结构，sockaddr_un类型 addrlen：地址长度 返回值：成功放回 0，失败返回 -1 */ #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; int bind(int sockfd,const struct sockaddr *addr,socklen_t addrlen); 2.4 其它API函数 #include &lt;sys/types." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/47033c9762e2a439e37a4ec6d476bba6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-16T18:51:04+08:00" />
<meta property="article:modified_time" content="2023-03-16T18:51:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux UNIX域socket，进程间通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、UNIX域套接字</h3> 
<ul><li>UNIX域套接字作用在同一台计算机上运行的两个进程间的通信。</li><li>UNIX域套接字比因特尔网络套接字效率要高。它仅复制数据，不执行协议处理，不需要添加或删除网络报文头，无需计算校验和，不要产生顺序号，无需发送确认报文等等。</li><li>UNIX域套接字有两种类型的套接字：字节流套接字和数据报套接字，字节流套接字类似于TCP，数据报套接字类似于UDP</li><li>UNIX域套接字连接的一对套接字可以起到全双工管道的作用，是全双工的通信方式。</li></ul> 
<p><img alt="" height="238" src="https://images2.imgbox.com/c8/58/QJGkHFJu_o.png" width="271"></p> 
<h3> 二、数据结构</h3> 
<h4>2.1 unix域套接字的地址结构</h4> 
<pre><code class="language-cs">struct sockaddr_un {
     sa_family_t  sun_family;       /* AF_UNIX 或 AF_LOCAL */
     char         sun_path[108];    /* pathname */
}</code></pre> 
<ul><li>sun_path是一个路径名，此路径名的属性为0777，可以进行读写等操作</li><li>这个路径名应该是一个绝对路径名，而不是一个相对路径名。因为解析相对路径名依赖调用者当前工作目录，如果使用使用相对路径名就必须要确保服务器与客户端程序运行在相同目录下，否则将会出现异常</li><li>除了普通路径名外，还可以使用抽象路径名。好处是不用担心出现文件已存在情况，同时程序结束，也会自动删除这个抽象名。但是，在计算抽象路径名长度的时候要注意。</li></ul> 
<h4>2.2 创建套接字</h4> 
<pre><code class="language-cs">/*
功能：socket的创建
参数：
     domain：AF_UNIX 或 AF_LOCAL
     type：套接字类型：字节流套接字（SOCK_STREAM）与数据报套接字（SOCK_DGRAM）
     protocol：如果第二参数不是SOCK_RAM原始套接字类型，一般设为0
返回值：成功返回文件描述符，失败返回 -1
*/
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain,int type,int protocol);</code></pre> 
<h4>2.3 地址绑定</h4> 
<pre><code class="language-cs">/*
功能：在UNIX域socket中bind函数不是用来绑定IP和端口，而是绑定一个有效路径名
参数：
     sockfd：socket函数返回的文件描述符
     addr：套接字的地址结构，sockaddr_un类型
     addrlen：地址长度
返回值：成功放回 0，失败返回 -1
*/
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int bind(int sockfd,const struct sockaddr *addr,socklen_t addrlen);</code></pre> 
<h4>2.4 其它API函数</h4> 
<pre><code class="language-cs">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;

int listen(int sockfd,int backlog)
/*  监听套接字 */

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
/* 接收客户端建立连接请求 */

int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
/* 客户端向服务器端发送连接请求 */

ssize_t read(int fd, void *buf, size_t count);
/* 进行读操作 */

ssize_t write(int fd, const void *buf, size_t count);
/* 进行写操作 */
</code></pre> 
<ul><li>这些函数的使用与因特尔网络socket基本类似，注意套接字地址结构体不要弄错就行</li></ul> 
<h3>三、编程示例</h3> 
<h4>3.1 客户端、服务器流程</h4> 
<p><img alt="" height="381" src="https://images2.imgbox.com/8c/3b/ujLNujA8_o.png" width="538"></p> 
<h4>3.2 unix_socket_server  </h4> 
<pre><code class="language-cs">  1 #include &lt;stdio.h&gt;
  2 #include &lt;string.h&gt;
  3 #include &lt;unistd.h&gt;
  4 #include &lt;errno.h&gt;
  5 #include &lt;sys/un.h&gt;
  6 #include &lt;sys/types.h&gt;
  7 #include &lt;sys/socket.h&gt;
  8 
  9 #define STR "I'm server"
 10 
 11 int main(int argc,char **argv)
 12 {
 13         int     rv=-1;
 14         int     socket_fd=-1;
 15         int     client_fd=-1;
 16 
 17         char    buf[1024];
 18         char    SOCK_PATH[108];
 19 
 20         socklen_t addrlen=sizeof(struct sockaddr_un);
 21         struct sockaddr_un serverAddr;
 22         struct sockaddr_un clientAddr;
 23 
 24 
 25         if(argc != 2)
 26         {
 27                 printf("please input file name!\n");
 28                 return -1;
 29         }
 30         
            //使用snprintf函数将输入的pathname保存在SOCK_PATH中，这里要注意第二个参数字节的长度需要计入/0
 31         snprintf(SOCK_PATH,strlen(argv[1])+1,"%s",argv[1]);
 32 

            //创建UNIX域字节流套接字
 33         socket_fd=socket(AF_UNIX,SOCK_STREAM,0);
 34         if(socket_fd &lt; 0)
 35         {
 36                 printf("socket failure:%s\n",strerror(errno));
 37                 return -2;
 38         }
 39 
            //初始化地址结构体 serverAddr 
 40         memset(&amp;serverAddr,0,sizeof(struct sockaddr_un));
 41         serverAddr.sun_family=AF_UNIX;
 42         serverAddr.sun_path[0]=0;
 43         snprintf(serverAddr.sun_path+1,strlen(SOCK_PATH)+1,"%s",SOCK_PATH);
 44         printf("sun_path:%s\n",serverAddr.sun_path+1);
 45 
            //绑定地址
 46         rv=bind(socket_fd,(struct sockaddr *)&amp;serverAddr,addrlen);
 47         if(rv &lt; 0)
 48         {
 49                 printf("bind failure:%s\n",strerror(errno));
 50                 return -3;
 51         }
            //监听
 52         listen(socket_fd,13);
 53 
            //接收客户端的连接请求
 54         client_fd=accept(socket_fd,(struct sockaddr *)&amp;clientAddr,&amp;addrlen);
 55         if(client_fd &lt; 0)
 56         {
 57                 printf("accept failure:%s\n",strerror(errno));
 58                 return -4;
 59         }
 60         printf("accept client_fd[%d]\n",client_fd);
 61 
 62         while(1)
 63         {
 64                 memset(buf,0,sizeof(buf));
 65                 rv=read(client_fd,buf,sizeof(buf));  //调用read函数读取客户端写入缓存区中的内容
 66                 if(rv &lt;= 0)
 67                 {
 68                         printf("read failure:%s\n",strerror(errno));
 69                         close(client_fd);  //连接断开记得关闭文件描述符
 70                         break;
 71                 }
 72 
 73                 printf("read %d word:%s\n",rv,buf);
 74         }
 75         close(socket_fd);  //在程序退出前将打开的文件描述符都关闭
 76         return 0;
 77 }</code></pre> 
<h4>3.3 unix_socket_client</h4> 
<pre><code class="language-cs">  1 #include &lt;stdio.h&gt;
  2 #include &lt;string.h&gt;
  3 #include &lt;unistd.h&gt;
  4 #include &lt;sys/types.h&gt;
  5 #include &lt;sys/socket.h&gt;
  6 #include &lt;errno.h&gt;
  7 #include &lt;sys/un.h&gt;
  8 
  9 #define STDIN 0
 10 
 11 int main(int argc,char **argv)
 12 {
 13         int    rv = -1;
 14         int    client_fd = -1;
 15         char   SOCK_PATH[108];
 16         char   buf[1024];
 17         
 18         struct sockaddr_un clientAddr;
 19         
 20         if(argc != 2)
 21         {
 22                 printf("please input pathname!\n");
 23                 return -1;
 24         }       
 25         
 26         snprintf(SOCK_PATH,strlen(argv[1])+1,"%s",argv[1]);
 27         
            //创建UNIX域字节流套接字
 28         client_fd=socket(AF_UNIX,SOCK_STREAM,0);
 29         if(client_fd &lt; 0)
 30         {
 31                 printf("socket failure:%s\n",strerror(errno));
 32         }       
 33         
            //初始化地址结构体 clientAddr
 34         memset(&amp;clientAddr,0,sizeof(struct sockaddr_un));
 35         clientAddr.sun_family = AF_UNIX;
 36         clientAddr.sun_path[0]=0;
 37         snprintf(clientAddr.sun_path+1,strlen(SOCK_PATH)+1,"%s",SOCK_PATH);
 38 
            //向客户端发送连接请求
 39         if(connect(client_fd,(struct sockaddr *)&amp;clientAddr,sizeof(struct sockaddr_un)) &lt; 0)
 40         {
 41                 printf("connect failure:%s\n",strerror(errno));
 42                 return -2;
 43         }
 44 
 45         while(1)
 46         {
 47                 memset(buf,0,sizeof(buf));
 48                 rv=read(STDIN,buf,sizeof(buf));  //从标准输入中读取内容存储到buf中
 49                 if(rv &lt;= 0)
 50                 {
 51                         printf("STDIN read failure:%s\n",strerror(errno));
 52                         close(client_fd);
 53                         return -3;
 54                 }
 55 
 56                 rv=write(client_fd,buf,strlen(buf));  //将buf内存储的内容写入缓存区供服务器端读取，注：第三个参数应为buf实际数据大小
 57                 if(rv &lt;= 0)
 58                 {
 59                         printf("write failure:%s\n",strerror(errno));
 60                         close(client_fd);
 61                         return -3;
 62                 }
 63 
 64         }
 65         return 0;
 66 }</code></pre> 
<h4>四、小结</h4> 
<ul><li>UNIX域套接字的地址结构体为 sockaddr_un；</li><li>创建套接字的协议是AF_UNIX或AF_LOCAL；</li><li>字节流套接字（SOCK_STREAM）和数据报套接字（SOCK_DAEAM）</li><li>可通过多进程、多线程、多路复用实现多客户端的并发访问</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f13eb1e8f297fbdf915c5526373427a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Boot jolokia 配置不当导致RCE漏洞</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30e40cb458348700f1717469a08a80e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android APP隐私合规检测工具Camille使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>