<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>项目问题~ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="项目问题~" />
<meta property="og:description" content="一、 国际化（i18n）北京外国语大学27种语言 vue-i18n &#43; i18n Ally &#43; xlsx &#43; vue-json-excel
1. 开始开发用zh-cn.json的文件写完页面逻辑
2. 通过公司免费的api接口将每个字段翻译成27种语言（生成一个大对象）
3. 使用vue-json-excel读取json数据，导出一个excel文件
4. 让内容组同事修正翻译，通过腾讯文档同步内容，改完导成本地
5. 通过 xlsx 插件xlsx文件内容读出来，FileSaver 生成js文件
但是有个问题，后续添加的翻译，不能使用i18n Ally翻译了，它是全量翻译，会覆盖同事手动翻译的内容，只能使用公司翻译的接口，把新增的字段翻译（拿到zh-cn文件字段，对比en.json文件没有的就是新增的，翻译完第一个将所有新增的字段放在一个数组里边）将翻译内容写入json文件。后端的返回信息也需要翻译，在自己封装的接口请求方法加个变量，每个接口都需要传语言字段
国际化翻译 Vue-i18n 的架构组织和 $t 的原理，当遇到插值对象的时候，需要进行 parse 和 compileVue-i18n 通过转义字符避免 XSS通过观察者模式对数据进行监听和更新，做到无刷新更新页面全局自定义指令和全局组件的实现 二、大文件分片上传，断点续传
1.通过el-upload组件拿到binary类型文件
2.校验文件不能超高20G，通过请求接口盘点磁盘大小，是否够存储文件
3. 直接将文件抛给webworker，file.slice()进行分片5M每片，用spark-md5给每一片加密（md5是一种信息摘要算法，它是一段数据,即128bit的由“0”和“1”组成的一段二进制数据。无论原始数据长短是多少,其MD5值都只是128bit）
4. 传送index、hash、file、size、total
5. 断点续传，刷新或者退出前端会停止上传，再次上传拿到MD5，后台先查有没有这个，有的话返回上次的index，前端从index继续上传。
6. 每一片5M传输最合理（nginx默认的上传文件大小是有限制的，一般为2MB，修改client_max_body_size 30M），oss存储有自动清理垃圾文件机制。调用的oss的api
7. nginx默认限制请求1M，修改client_max_body_size 20M;
大文件下载 阶段1：后台返回文件地址，创建隐藏的iframe下载，批量下载是创建多个iframe或者后端生成zip下载。（单线程下载速度慢） 阶段2： 多线程大文件下载，http1.1的range字段（分片下载blod文件，请求返回206，部分下载，下载完成合并blod文件，单个域名并发限制一次最多只能发送6个请求） 或者用jszip压缩文件 const zip = new JSZip(); zip.file(file.name, file); const blob = await zip.generateAsync({type:&#34;blob&#34;}) saveAs(blob, &#34;example.zip&#34;); 升级http2，没有并发限制，并不是并发越多越好。最后经过大量测试24个请求是最快的，请求完24个在请求24分片,请求完成合并文件" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f46b313f8262d5e4421f402fa24c05be/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-10T11:09:08+08:00" />
<meta property="article:modified_time" content="2023-05-10T11:09:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">项目问题~</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><br> 一、 国际化（i18n）北京外国语大学27种语言    vue-i18n + i18n Ally  + xlsx + vue-json-excel</p> 
<p>        1. 开始开发用zh-cn.json的文件写完页面逻辑<br>         2. 通过公司免费的api接口将每个字段翻译成27种语言（生成一个大对象）<br>         3. 使用vue-json-excel读取json数据，导出一个excel文件<br>         4. 让内容组同事修正翻译，通过腾讯文档同步内容，改完导成本地<br>         5. 通过 xlsx 插件xlsx文件内容读出来，FileSaver 生成js文件</p> 
<p>         但是有个问题，后续添加的翻译，不能使用i18n Ally翻译了，它是全量翻译，会覆盖同事手动翻译的内容，只能使用公司翻译的接口，把新增的字段翻译（拿到zh-cn文件字段，对比en.json文件没有的就是新增的，翻译完第一个将所有新增的字段放在一个数组里边）将翻译内容写入json文件。后端的返回信息也需要翻译，在自己封装的接口请求方法加个变量，每个接口都需要传语言字段</p> 
<ul><li>国际化翻译 Vue-i18n 的架构组织和 $t 的原理，当遇到插值对象的时候，需要进行 parse 和 compile</li><li>Vue-i18n 通过转义字符避免 XSS</li><li>通过观察者模式对数据进行监听和更新，做到无刷新更新页面</li><li>全局自定义指令和全局组件的实现</li></ul> 
<p>二、大文件分片上传，断点续传<br>         1.通过el-upload组件拿到binary类型文件<br>         2.校验文件不能超高20G，通过请求接口盘点磁盘大小，是否够存储文件<br>         3. 直接将文件抛给webworker，file.slice()进行分片5M每片，用spark-md5给每一片加密（md5是一种信息摘要算法，它是一段数据,即128bit的由“0”和“1”组成的一段二进制数据。无论原始数据长短是多少,其MD5值都只是128bit）<br>         4. 传送index、hash、file、size、total<br>         5. 断点续传，刷新或者退出前端会停止上传，再次上传拿到MD5，后台先查有没有这个，有的话返回上次的index，前端从index继续上传。<br>         6. 每一片5M传输最合理（<a href="https://so.csdn.net/so/search?q=nginx&amp;spm=1001.2101.3001.7020" title="nginx">nginx</a>默认的上传文件大小是有限制的，一般为2MB，修改client_max_body_size 30M），oss存储有自动清理垃圾文件机制。调用的oss的api<br>         7. nginx默认限制请求1M，修改client_max_body_size 20M;</p> 
<h4 id="%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%C2%A0%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E9%98%B6%E6%AE%B51%EF%BC%9A%E5%90%8E%E5%8F%B0%E8%BF%94%E5%9B%9E%E6%96%87%E4%BB%B6%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%88%9B%E5%BB%BA%E9%9A%90%E8%97%8F%E7%9A%84iframe%E4%B8%8B%E8%BD%BD%EF%BC%8C%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E6%98%AF%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAiframe%E6%88%96%E8%80%85%E5%90%8E%E7%AB%AF%E7%94%9F%E6%88%90zip%E4%B8%8B%E8%BD%BD%E3%80%82%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%EF%BC%89">大文件下载 <br>         阶段1：后台返回文件地址，创建隐藏的iframe下载，批量下载是创建多个iframe或者后端生成zip下载。（单线程下载速度慢）</h4> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%98%B6%E6%AE%B52%EF%BC%9A%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%EF%BC%8Chttp1.1%E7%9A%84range%E5%AD%97%E6%AE%B5%EF%BC%88%E5%88%86%E7%89%87%E4%B8%8B%E8%BD%BDblod%E6%96%87%E4%BB%B6%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E206%EF%BC%8C%E9%83%A8%E5%88%86%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%88%E5%B9%B6blod%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8D%95%E4%B8%AA%E5%9F%9F%E5%90%8D%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6%E4%B8%80%E6%AC%A1%E6%9C%80%E5%A4%9A%E5%8F%AA%E8%83%BD%E5%8F%91%E9%80%816%E4%B8%AA%E8%AF%B7%E6%B1%82%EF%BC%89%C2%A0%20%E6%88%96%E8%80%85%E7%94%A8jszip%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6">        阶段2： 多线程大文件下载，http1.1的range字段（分片下载blod文件，请求返回206，部分下载，下载完成合并blod文件，单个域名并发限制一次最多只能发送6个请求）  或者用jszip压缩文件</h4> 
<pre><code class="language-javascript">const zip = new JSZip();
zip.file(file.name, file);
const blob = await zip.generateAsync({type:"blob"})
saveAs(blob, "example.zip");</code></pre> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E5%8D%87%E7%BA%A7http2%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6%EF%BC%8C%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%B9%B6%E5%8F%91%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%E3%80%82%E6%9C%80%E5%90%8E%E7%BB%8F%E8%BF%87%E5%A4%A7%E9%87%8F%E6%B5%8B%E8%AF%9524%E4%B8%AA%E8%AF%B7%E6%B1%82%E6%98%AF%E6%9C%80%E5%BF%AB%E7%9A%84%EF%BC%8C%E8%AF%B7%E6%B1%82%E5%AE%8C24%E4%B8%AA%E5%9C%A8%E8%AF%B7%E6%B1%8224%E5%88%86%E7%89%87%2C%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%88%90%E5%90%88%E5%B9%B6%E6%96%87%E4%BB%B6%E5%BC%8A%E7%AB%AFgoogle%E6%9C%80%E5%A4%A7%E6%98%BE%E7%A4%BA2G%EF%BC%8COpera500M%EF%BC%8C%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%B6%85%E8%BF%87%E7%BC%93%E5%AD%98%E5%A4%A7%E5%B0%8F%E4%BC%9A%E5%B4%A9%E6%BA%83">         升级http2，没有并发限制，并不是并发越多越好。最后经过大量测试24个请求是最快的，请求完24个在请求24分片,请求完成合并文件<br> 弊端google最大显示2G，Opera500M，不同浏览器大小限制不同，超过缓存大小会崩溃</h4> 
<pre><code class="language-javascript"> Promise.all(arr).then((res) =&gt; {
    const arrBufferList = res
      .sort((item) =&gt; item.i - item.i)
      .map((item) =&gt; new Uint8Array(item.buffer));
    count = 0;
    const allBuffer = concatenate(Uint8Array, arrBufferList);
    const blob = new Blob([allBuffer], { type: "image/jpeg" });
    const blobUrl = URL.createObjectURL(blob);
//a标签下载
    const aTag = document.createElement("a");
    aTag.download = donwloadName;
    aTag.href = blobUrl;
    aTag.click();
    URL.revokeObjectURL(blob);
    console.timeEnd("并发下载1");
// fileServer.js保存
 FileSaver.saveAs(blob , '文件名')
  });</code></pre> 
<h4 id="%E5%89%8D%E7%AB%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%AE%9E%E8%B7%B5%EF%BC%8C%E6%8F%90%E9%80%9F10%E5%80%8D(%E6%8B%BF%E6%8D%8F%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98)-%E9%98%BF%E9%87%8C%E4%BA%91%E5%BC%80%E5%8F%91%E8%80%85%E7%A4%BE%E5%8C%BA"><br><a href="https://developer.aliyun.com/article/918120" rel="nofollow" title="前端多线程大文件下载实践，提速10倍(拿捏百度云盘)-阿里云开发者社区">前端多线程大文件下载实践，提速10倍(拿捏百度云盘)-阿里云开发者社区</a></h4> 
<h4 id="%C2%A0%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9AStreams%20API%C2%A0%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%90%E4%BE%9B%E7%BB%99%C2%A0JS%C2%A0%E7%9A%84%E6%B5%81%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%82%20%E5%B0%86%E6%96%87%E4%BB%B6%E6%B5%81%E7%9B%B4%E6%8E%A5%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%E5%AE%83%E5%80%9F%E5%8A%A9%E4%BA%86%20Streams%20API%20%E5%92%8C%20Service%20Worker%20%E8%A7%A3%E5%86%B3%E4%BA%86%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98"> 阶段三：<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/Streams_API" rel="nofollow" title="Streams API">Streams API</a> 是浏览器提供给 <code>JS</code> 的流式操作数据的接口。 将文件流直接写入磁盘<br> 它借助了 Streams API 和 Service Worker 解决了内存占用过大的问题</h4> 
<p><a href="https://segmentfault.com/a/1190000021367378" rel="nofollow" title="https://segmentfault.com/a/1190000021367378">https://segmentfault.com/a/1190000021367378</a><br><a href="https://zhuanlan.zhihu.com/p/446145066" rel="nofollow" title="JS 实现流式打包下载 - 知乎">JS 实现流式打包下载 - 知乎</a><a href="https://blog.csdn.net/qq_16165281/article/details/123104549" title="JS前端批量下载大文件并打包zip（StreamSaver.js）_斗战圣佛91的博客-CSDN博客_js批量下载文件生成zip">JS前端批量下载大文件并打包zip（StreamSaver.js）_斗战圣佛91的博客-CSDN博客_js批量下载文件生成zip</a></p> 
<p>responseType: 'arraybuffer'（请求arraybuffer文件流）</p> 
<h4 id="Service%20worker%20%E5%AE%83%E5%8F%AF%E4%BB%A5%E6%8B%A6%E6%88%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E5%B9%B6%E6%8F%90%E4%BE%9B%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%E3%80%82">Service worker 它可以<strong>拦截</strong>浏览器的请求并<strong>提供</strong>离线缓存。</h4> 
<p>Service worker 本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用来采取适当的动作、更新来自服务器的的资源。</p> 
<p>StreamSaver.js 包含两部分代码，一部分是客户端代码，一部分是 Service Worker 的代码（对于不支持 Service Worker 的情况，作者在 GitHub Pages 上提供了一个运行 Service Worker 的页面供跨域使用）。</p> 
<p>在初始化时客户端代码会创建一个 <code>TransformStream</code> 并将可写入的一端封装为 <code>writer</code> 暴露给外部使用，在脚本调用 <code>writer.write(chunk)</code> 写入文件片段时，客户端会和 Service Worker 之间建立一个 <code>MessageChannel</code>，并将之前的 <code>TransformStream</code> 中可读取的一端通过 <code>port1.postMessage()</code> 传递给 Service Worker。Service Worker 里监听到通道的 <code>onmessage</code> 事件时会生成一个随机的 URL，并将 URL 和可读取的流存入一个 Map 中，然后将这个 URL 通过 <code>port2.postMessage()</code> 传递给客户端代码。</p> 
<p>客户端接收到 URL 后会控制浏览器跳转到这个链接，此时 Service Worker 的 <code>onfetch</code> 事件接收到这个请求，将 URL 和之前的 Map 存储的 URL 比对，将对应的流取出来，再加上一些让浏览器认为可以下载的响应头（例如 <code>Content-Disposition</code>）封装成 <code>Response</code> 对象，最后通过 <code>event.respondWith()</code> 返回。这样在当客户端将数据写入 <code>writer</code> 时，经过 Service Worker 的流转，数据可以立刻下载到用户的设备上。这样就不需要分配巨大的内存来存放 Blob，数据块经过流的流转后直接被回收了，降低了内存的占用。</p> 
<p>所以借助 StreamSaver.js，之前下载图片的流程可以优化如下：JSZip 提供了一个 <code>StreamHelper</code> 的接口来模拟流的实现，所以我们可以调用 <code>generateInternalStream()</code> 方法以小文件块的形式接收数据，每次接收到数据时数据会写入 StreamSaver.js 的 writer，经过 Service Worker 后数据直接被下载。这样就不会再像之前那样在生成 zip 时占用大量的内存空间了，因为 zip 数据在实时生成时被划分成了小块并迅速被处理掉了。<br>  </p> 
<p>下载完成流----&gt;postmessage发送给serviceWorker------&gt;onmessage事件内部随机生成一个URL，存在map中 ------&gt; 通过postMessage发送给客户端 ----&gt; 客户端通过跳转这个url-------&gt;serviceWorker拦截请求------&gt;将对应流拉取出来，加上响应头，下载线程拿到响应，开启流式下载</p> 
<p>readableStream .pipeTo(fileStream) .then(() =&gt; console.log("done writing"))</p> 
<h4 id="AXIOS%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82%C2%A0%20%C2%A0"><br><br> AXIOS取消请求   </h4> 
<pre><code class="language-javascript">let CancelToken; //取消请求的token令牌
let cancel:any; //取消请求的方法
// 发送请求
function sendAxios() { 
   CancelToken = axios.CancelToken
   axios.get('https://edu.newsight.cn/wxList.php', {
      cancelToken: new CancelToken(function excutor(c) {
         cancel = c;
      })
   }).then((res) =&gt; { 
      console.log('axios1发回来的数据',res)
   }).catch((thrown) =&gt; { 
      if (axios.isCancel(thrown)) {
         console.log('请求已经取消了==&gt;', thrown.message);
      } else {
         // 处理错误
      }
   });
}
// 取消请求
function cancelHandert() {
   cancel&amp;&amp;cancel(); 
}</code></pre> 
<p>三、主题切换<br>         1. 给ued组开发了一个定义主题颜色的系统，table表格展示每一个主题色的属性，通过FileSaver保存生成scss文件，供前端使用 ，新增主题，修改主题只需要UI去修改颜色，生成新的scss文件供前端使用。<br>         2. table是一个数组，一列就是一个主题，每个主题有多个属性，最后点确认，生成一个js文件存放这次生成的数组，供下次使用。还要将数组对象拼接成字符串，输出成scss文件。</p> 
<p>a = { '--theme-color': "#eee", '--theme-background': "#333" } -&gt;</p> 
<p>a = '.a {--theme-color: "#eee";--theme-background: "#333"}'</p> 
<p>        3. 基础常用的样式的样式 通过@mixin，@extend减少重复</p> 
<p>        4. 通过动态设置html的class实现切换主题</p> 
<p>        5. 还有一个项目用户需要自定义主题颜色，自己选择每一个模块的颜色（可以颜色面板选择）</p> 
<pre><code class="language-css">/* 定义根作用域下的变量 */
:root {
  --theme-color: #333;
  --theme-background: #eee;
}
/* 更改dark类名下变量的取值 */
.dark{
  --theme-color: #eee;
  --theme-background: #333;
}
/* 更改pink类名下变量的取值 */
.pink{
  --theme-color: #fff;
  --theme-background: pink;
}

.box {
  transition: all .2s;
  width: 100px;
  height: 100px;
  border: 1px solid #000;
  /* 使用变量 */
  color: var(--theme-color);
  background: var(--theme-background);
}</code></pre> 
<p>四、网盘存储、资源管理<br>         1. 资源分片上传<br>         2. 大文件下载，批量下载（生成一个zip）<br>         3. 资源、文件夹的分享、复制、移动、收藏、下载、公开、编辑、删除<br>         4. 视频资源支持打点、剪切、视频融合、字幕、分享、字幕转写、添加笔记、无效片段处理，COR识别、编辑字幕、字幕翻译、词云、图文模式、多路视频随意切换、局部全屏（所有全屏）<br>         5. 文件预览。文档，图片，视频 ，音频<br>         6. 直播，字幕（实时语音翻译，websocket拿到数据展示），实时语音聊天(类似腾讯课堂，但是支持多路和多路全屏，显示实时语音翻译，)</p> 
<p>五、大屏数据展示，移动端<br>         大屏适配</p> 
<pre><code class="language-Kotlin"> const baseWidth = 1920;
    const baseHeight = 1080;
    let timer = null;
    let calcScale = function () {
      let windowInnerWidth = window.innerWidth;
      let windowInnerHeight = window.innerHeight;
      // let ratioW = baseWidth / windowInnerWidth;
      let ratioW = windowInnerWidth / baseWidth;
      // let ratioH = baseHeight / windowInnerHeight;
      let ratioH = windowInnerHeight / baseHeight;
      document.body.style.width = baseWidth + 'px';
      document.body.style.height = baseHeight + 'px';
      document.body.style.transformOrigin = 'left top';
      document.body.style.transform = `scale(${ratioW})`;
    }
    calcScale();
    window.onresize = function () {
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(calcScale, 300)
    }</code></pre> 
<p><br>         移动端适配：rem是<strong>相对长度单位。相对于根元素(即html元素)<a href="http://www.css88.com/book/css/properties/font/font-size.htm" rel="nofollow" title="font-size">font-size</a>计算值的倍数</strong>的一个css单位,默认1rem = 16px，不好计算，重新设置比率   html{font-size: 100px;} 1rem = 100px<br> 等比缩放<br> vw，wh是 1/100宽高，兼容性不太好<br> em：相对于父元素的大小，一个改变后边子元素也得变</p> 
<pre><code class="language-javascript">(function(win, doc) {
    function changeSize() {
        doc.documentElement.style.fontSize = 100 * 
            doc.documentElement.clientWidth / 375 + 'px';
    }
    changeSize();
    win.addEventListener('resize', changeSize, false);
})(window, document);
</code></pre> 
<p>postcss-plugin  pxtovw  实现px转化为vw</p> 
<pre><code class="language-javascript">import pxtovw from 'postcss-px-to-viewport'

const getPlagin = (isVant) =&gt; {
    let opt: any = {
        //这里是设计稿宽度 自己修改
        viewportWidth: isVant ? 375 : 750,
        viewportUnit: 'vw',
    }
    if (isVant) {
        opt.include = [/node_modules\/vant/]
        opt.exclude = [/controller/]
    } else {
        opt.exclude = [/node_modules\/vant/, /controller/]
    }
    return pxtovw(opt)

}
const config = {
    base: '/iplat/fifMobile/fif_zjzx/',
    css: {
        postcss: {
            plugins: [getPlagin(false), getPlagin(true)]
        }
    },
  
    plugins: [
        vue(),
        vueSetupExtend(),
        Components({
            resolvers: [VantResolver()],
        }),
        // viteCompression({ deleteOriginFile: true }) // gzip 压缩
    ],
  
}</code></pre> 
<p>六、弹幕问题<br>         通过css3 <br>         transition: -webkit-transform 0s linear 0s;（过度效果时间，匀速，延迟）<br>         transform: matrix(1, 0, 0, 1, -406.081, 0);（矩阵变换，线性代数，运动就是在线性空间的一种变换，transform: matrix(a,b,c,d,e,f);，x'=ax+cy+e y'=bx+dy+f）<br>         animation: 0s ease 0s 1 normal none running none;（动画: 动画-名 动画-持续时间 动画-时间控制函数 动画-延时 动画-重复次数 动画-方向 动画-填充方法 动画-播放状态;）<br>         will-change: transform, opacity;（<code>transform</code>和<code>animation有时会出现闪烁，</code>将动画交给GPU，硬件加速，属性允许你提前告知浏览器你可能会对一个元素进行什么样的改变，这样它就可以提前设置适当的优化，该元素会被移动到属于它自己的“图层”，在那里它可以独立于页面的其他部分进行渲染。避免其他元素的重排和重绘）<br>         stroke-width:1px;stroke: rgba(0,0,0,.5); 文字描边</p> 
<p><img alt="" height="304" src="https://images2.imgbox.com/e4/83/AEVTrNf7_o.png" width="573"></p> 
<p>直播半屏，显示右侧聊天室，网页全屏显示弹幕功能<br> 录播功能2分钟根据当前时间请求一次最新的弹幕，轮循，websocket常<br> 直播使用websocket（弹幕+实时字幕），录播30s根据播放时间获取一次弹幕</p> 
<p>流程：添加新弹幕到等待队列、寻找合适的轨道、从等待队列中抽取弹幕并放入轨道、整体渲染、清空。<br><br> 分为三部分：舞台、轨道、弹幕池<br> 舞台是整个弹幕的主控制，它维护着多个轨道、一个等待队列、一个弹幕池<br> 弹幕池：[[1,2,3],[4,5,6]]（new WeakMap() ）   等待队列：[7,8,9,10] <br> 获取每一行的宽度，找到最小的给他添加新的弹幕，（先填充满上边的一行）</p> 
<p> transition:1s linear 0s, 速度是transition的时间控制的<br> 追及问题，设置最大速度为两倍，计算两个之前的距离<br> 丢弃排队时间过长的弹幕大神</p> 
<p>-webkit-mask-image：url（） //防止弹幕遮挡人物<br><br> 自定义指令：水印（手机端人名字水印和视频水印，mutationObserver检测dom变化，执行生成水印方法，防止人为删除dom），懒加载，按钮节流，输入防抖，拖拽</p> 
<pre><code class="language-javascript">
// 选择需要观察变动的节点（获取到DOM）
const targetNode = document.getElementById('app');
 
// 观察器的配置（需要观察什么变动）
const config = { attributes: true, childList: true, subtree: true };
 
// 当观察到变动时执行的回调函数
const callback = function() {
   console.log('触发回调')
};
 
// 创建一个观察器实例并传入回调函数
const observer = new MutationObserver(callback);
 
// 以上述配置开始观察目标节点
observer.observe(targetNode, config);
 
// 之后，可停止观察

childList: true,  // 观察目标子节点的变化，是否有添加或者删除
attributes: true, // 观察属性变动
subtree: true     // 观察后代节点，默认为 false</code></pre> 
<p><br><br> 前端优化 </p> 
<p>1、减少请求量<br>         雪碧图，iconfont、spritesmith（生成png和scss）、nginx开启http2(server {listen 10.10.10.10:443 backlog=20480 http2 ssl;ssl_async on;)、图片懒加载、虚拟列表、</p> 
<pre><code class="language-javascript">// 定义懒加载图片或者文件等，自定义指令
Vue.directive('lazy', (el, binding) =&gt; {
  let oldSrc = el.src //保存旧的src，方便后期渲染时候赋值src真实路径
  el.src = "" //将渲染的src赋为空，则不会渲染图片出来
  let observer = new IntersectionObserver(([{ isIntersecting }]) =&gt; { // 调用方法得到该elDOM元素是否处于可视区域
    if (isIntersecting) { //回调是否处于可视区域，true or false
      el.src = oldSrc //如果处于可视区域额，将最开始保存的真实路径赋予DOM元素渲染
      observer.unobserve(el) // 只需要监听一次即可，第二次滑动到可视区域时候不在监听
    }
  })
  observer.observe(el) // 调用方法
})
</code></pre> 
<p>2、减小文件大小<br> ​    路由懒加载，组件按需加载、开启zip（CompressionPlugin）、压缩css（css-minimizer-webpack-plugin）、压缩图片（image-webpack-loader / webp ）、提取公共库（SplitChunksPlugin）、<strong><code>Tree Shaking</code> 移除无用代码、</strong>减少不必要的 cookie</p> 
<p>3、加快请求速度<br> ​    预解析DNS（&lt;link rel="dns-prefetch" href="xxx.com"&gt; ，官网配置子应用）、CDN 分发、nginx负载均衡、使用 <code>preconnect</code> 提前建立连接、webpackPrefetch（预加载资源文件）、CDN 托管静态资源 + HTTP 缓存（强缓存，协商缓存）</p> 
<p>4. 交互层面：减少回流/重绘（使用 <code>will-change</code> 开启 <code>GPU</code> 加速、减少对 <code>DOM</code> 进行频繁操作、使经常变动的元素脱离文档流）、防抖/节流</p> 
<p>5. Web Worker</p> 
<p><code>JavaScript</code> 是单线程的，如果存在需要大量计算的场景（如视频解码），<code>UI</code> 线程就会被阻塞，甚至浏览器直接卡死。<br><code>Web Worker</code> 可以使脚本运行在新的线程中，它们独立于主线程，可以进行大量的计算活动，而不会影响主线程的 <code>UI</code> 渲染，但不能滥用 <code>Web Worker</code> 。<br> 6、虚拟列表</p> 
<p>最常用的还是 <strong>分页加载</strong> 的方式：</p> 
<ul><li> <p>基于 <code>上拉加载</code> 列表的渲染，随着加载数据的增多，对应的 <code>DOM</code> 节点也会增多，达到某个限制页面一定会发生卡顿</p> </li></ul> 
<p><strong>虚拟列表</strong> 核心就是固定渲染的 <strong><code>DOM</code></strong> 数，通过动态切换数据内容实现视图的更新，并保证文档中真实 <strong><code>DOM</code></strong> 的数量不随着数据量增大而增大（其实和 <code>table</code> 分页很像，但它支持滚动）。</p> 
<p>7. 大文件分片上传、下载</p> 
<p>8. 前端文件导入/导出</p> 
<p></p> 
<p>​ Minify把 CSS 和 JS 压缩和削减(Minify：去掉空格回车符等)，以及把多个CSS，JS文件整合到一个文件里。</p> 
<p>4、缓存<br> ​ ① HTTP协议缓存请求（ng开启强缓存，协商缓存）</p> 
<p>​ ② 离线缓存 manifest（webpack-manifest）</p> 
<p>​ ③ 本地缓存 localStorage</p> 
<p>补充知识：<br> ​ GET请求可以缓存，POST请求不能缓存。GET请求后退/刷新无害，POST后退/刷新则会致使重新提交数据</p> 
<p>4、渲染<br> ​ ① JS优化，如防抖、节流、事件委托、减少重排重绘等。</p> 
<p>​ ② CSS优化，如提取公共样式减少代码量、减少选择器嵌套层数、精灵图等。</p> 
<p>​ ③ 服务器端渲染</p> 
<p>​ ④ 使用Web Workers</p> 
<p>​ ⑤ CSS写在文件头部，JS写在文件底部。</p> 
<p>img/css这些文件都可以用强缓存。通过更改文件名的方式来获取最新的数据，index.html就要用协商</p> 
<p><strong>FP</strong> : 首次绘制（白屏时间）<br><strong>FCP</strong>：首次内容绘制（绘制第一个元素）<br><strong>LCP</strong>：首屏时间（最大内容绘制，应在2.5s完成）mutationObserve*dom树的层级计算一个权重，页面元素一直在变化，取一个相对的比较大的变化作为首屏渲染截止时间<br><strong>FID：</strong>第一次输入事件延迟<br><strong>CLS：</strong>累积布局偏移<br> 浏览器perfermace观察各项指标，但是不直观<br> 可以用lightHouse观察（各项指标性能）</p> 
<p>会在项目部署的初期，通过设置变量控制各个性能指标的开启，监听load事件，load完成以后将各项指标上传，前端人员进行分析，运行平稳以后，可以把一些dns，tcp的检测给去掉。</p> 
<pre><code class="language-javascript">import {getCLS, getFID, getLCP} from 'web-vitals';  1.5k很小

function sendToAnalytics(metric) {
  const body = JSON.stringify(metric);
  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
  (navigator.sendBeacon &amp;&amp; navigator.sendBeacon('/analytics', body)) ||
      fetch('/analytics', {body, method: 'POST', keepalive: true});
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getLCP(sendToAnalytics);
</code></pre> 
<pre><code class="language-javascript">perfermence.timing

DNS查询耗时 ：domainLookupEnd - domainLookupStart

TCP链接耗时 ：connectEnd - connectStart

request请求耗时 ：responseEnd - responseStart

解析dom树耗时 ： domComplete- domInteractive

白屏时间 ：responseStart - navigationStart

domready时间 ：domContentLoadedEventEnd - navigationStart

onload时间 ：loadEventEnd - navigationStart

DOMContentLoaded：文档被加载完，图片还未加载，样式表还未渲染
   （1）解析html结构

   （2）加载外部脚本和样式表文件

   （3）解析并执行脚本代码

   （4）构造HTML DOM模型   //DOMContentLoaded执行点

   （5）加载图片等外部文件

   （6）页面加载完毕  //load
   window.addEventListener("load", function () {   //添加load事件
       console.log("load执行");
   }, false);

   window.addEventListener("DOMContentLoaded", function () {  //添加DOMContentLoaded事件
       console.log("domContentLoad执行");
   }, false)

</code></pre> 
<pre><code class="language-javascript">统计接口响应时间
const start = response.config.headers['request-startTime']
const currentTime = new Date().getTime()
const requestDuration = ((currentTime - start)/1000).toFixed(2)
</code></pre> 
<p>axios取消请求CancelToken = axios.CancelToken<br>  </p> 
<pre><code class="language-javascript">let CancelToken; //取消请求的token令牌
let cancel:any; //取消请求的方法
// 发送请求
function sendAxios() { 
   CancelToken = axios.CancelToken
   axios.get('https://edu.newsight.cn/wxList.php', {
      cancelToken: new CancelToken(function excutor(c) {
         cancel = c;
      })
   }).then((res) =&gt; { 
      console.log('axios1发回来的数据',res)
   }).catch((thrown) =&gt; { 
      if (axios.isCancel(thrown)) {
         console.log('请求已经取消了==&gt;', thrown.message);
      } else {
         // 处理错误
      }
   });
}
// 取消请求
function cancelHandert() {
   cancel&amp;&amp;cancel(); 
}

function sendAxios2() {
   axios.get('https://edu.newsight.cn/wxList.php').then(function (response) {
      console.log('返回来的数据sendAxios2', response)
   })
}</code></pre> 
<p></p> 
<h4 id="DocumentFragment%3A%E5%AE%83%E4%B8%8D%E6%98%AF%E7%9C%9F%E5%AE%9E%20DOM%20%E6%A0%91%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E5%AE%83%E7%9A%84%E5%8F%98%E5%8C%96%E4%B8%8D%E4%BC%9A%E8%A7%A6%E5%8F%91%20DOM%20%E6%A0%91%E7%9A%84%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%EF%BC%8C%E4%B8%94%E4%B8%8D%E4%BC%9A%E5%AF%B9%E6%80%A7%E8%83%BD%E4%BA%A7%E7%94%9F%E5%BD%B1%E5%93%8D%E3%80%82">DocumentFragment:它不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Reflow" rel="nofollow" title="重新渲染">重新渲染</a>，且不会对性能产生影响。</h4> 
<h4 id="IntersectionObserver%3A%C2%A0%E7%9B%91%E5%90%AC%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E8%BF%9B%E5%85%A5%E4%BA%86%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F">IntersectionObserver: 监听元素是否进入了可视区域</h4> 
<pre><code class="language-javascript">图片懒加载
const imgList = [...document.querySelectorAll('img')]

var io = new IntersectionObserver((entries) =&gt;{
  entries.forEach(item =&gt; {
    // isIntersecting是一个Boolean值，判断目标元素当前是否可见
    if (item.isIntersecting) {
      item.target.src = item.target.dataset.src
      // 图片加载后即停止监听该元素
      io.unobserve(item.target)
    }
  })
}, {
  root: document.querySelector('.root')
})

// observe遍历监听所有img节点
imgList.forEach(img =&gt; io.observe(img))
</code></pre> 
<p>HTTP <strong><code>101 Switching Protocols</code></strong>响应代码指示服务器正在根据发送包括<code>Upgrade</code>请求头的消息的客户端的请求切换到的协议。</p> 
<p>服务器在此响应中包含一个<code>Upgrade</code>响应标题，指示它切换到的协议。该过程在文章“协议升级机制”中有详细描述</p> 
<p></p> 
<p></p> 
<h3 id="%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7">前端错误监控</h3> 
<p>1. <code>window.onerror</code>可以捕捉语法错误，也可以捕捉运行时错误，可以拿到出错的信息，堆栈，出错的文件、行号、列号<br> 2. 当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 <code>Event</code> 接口的 <code>error</code> 事件，并执行该元素上的<code>onerror()</code> 处理函数<br> window.addEventListener('error', function(event) {<!-- --><br>          // onerror_statements<br> })<br> 3. 在vue中使用errorHandler 或者生命周期钩子 errorCaptured<br>         app.config.errorHandler = (err, vm, info) =&gt; {<!-- --><br>                   // 处理错误<br>                   // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子<br>         }<br> 4. 请求异常在响应拦截器中处理  在axios中拦截<br> 5. promise异常使用Promise Catch，在全局增加一个对 <code>unhandledrejection</code> 的监听，用来全局监听<code>Uncaught Promise Error</code>。使用方式：</p> 
<pre><code class="language-javascript">window.addEventListener("unhandledrejection", function(e){
  console.log(e);
});</code></pre> 
<p>6. 崩溃和卡顿<br>         1.利用 <code>window</code> 对象的 <code>load</code> 和 <code>beforeunload</code> 事件实现了网页崩溃的监控(在页面加载时（<strong>load</strong> 事件）在 <strong>sessionStorage </strong>记录 <strong>good_exit</strong> 状态为 <strong>pending</strong>，如果用户正常退出（<strong>beforeunload</strong> 事件）状态改为 <strong>true</strong>，如果 <strong>crash</strong> 了，状态依然为 <strong>pending</strong>，在用户第2次访问网页的时候（第2个<strong>load</strong>事件），查看 <strong>good_exit</strong> 的状态，如果仍然是 <strong>pending</strong> 就是可以断定上次访问网页崩溃了！存在的问题：采用 <strong>sessionStorage</strong> 存储状态，但通常网页崩溃/卡死后，用户会强制关闭网页或者索性重新打开浏览器，sessionStorage 存储但状态将不复存在；如果将状态存储在 <strong>localStorage</strong> 甚至 Cookie 中，如果用户先后打开多个网页，但不关闭，good_exit 存储的一直都是 pending，完了，每有一次网页打开，就会有一个 crash 上报。)。<br>        2. 可以使用 <code>Service Worker</code> 来实现<a href="https://juejin.im/entry/5be158116fb9a049c6434f4a?utm_source=gold_browser_extension" rel="nofollow" title="网页崩溃的监控">网页崩溃的监控</a><br> (1).Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；<br> (2).Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；<br> (3).网页可以通过 <strong>navigator.serviceWorker.controller.postMessage</strong> API 向掌管自己的 SW 发送消息。<br> 基于<strong>心跳检测</strong>的监控方案：</p> 
<ul><li>p1：网页加载后，通过 <strong>postMessage</strong> API 每 <strong>5s</strong> 给 sw 发送一个心跳，表示自己的在线，sw 将在线的网页登记下来，更新登记时间；</li><li>p2：网页在 <strong>beforeunload</strong> 时，通过 <strong>postMessage</strong> API 告知自己已经正常关闭，sw 将登记的网页清除；</li><li>p3：如果网页在运行的过程中 crash 了，sw 中的 <strong>running</strong> 状态将不会被清除，更新时间停留在奔溃前的最后一次心跳；</li><li>sw：Service Worker 每 <strong>10s</strong> 查看一遍登记中的网页，发现登记时间已经超出了一定时间（比如 15s）即可判定该网页 crash 了</li></ul> 
<h4 id="%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%C2%A0sentry%20%E4%B8%8A%E6%8A%A5%E6%B5%81%E7%A8%8B%20%EF%BC%88doker%E6%90%AD%E5%BB%BA%E4%B8%80%E5%A5%97%EF%BC%8C%E9%80%9A%E8%BF%87%E9%92%89%E9%92%89%E7%94%9F%E6%88%90webhook%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%B0%86%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E5%8F%91%E9%80%81%E5%88%B0%E9%92%89%E9%92%89%E5%BC%80%E5%8F%91%E8%80%85%E7%BE%A4%EF%BC%8C%E5%AE%9E%E6%97%B6%E5%85%B3%E6%B3%A8%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%EF%BC%89">终极解决方案 <strong>sentry 上报流程 （doker搭建一套，通过钉钉生成webhook地址，将错误信息发送到钉钉开发者群，实时关注错误提示）</strong></h4> 
<ol><li>Sentry Init 初始化，读取配置的 Release 和 DSN 信息，然后将 Sentry 对象挂在到全局</li><li>当代码在运行过程中发生错误时，往上抛出一个 Error 对象，会执行 TraceKit 重写的 window.onerror 方法</li><li>如果是一个未捕获的 Promise 错误是，将执行重写的 window.onunhandledrejection</li><li>然后使用网络请求上报到 Sentry 服务器，这里会用到配置时使用的 DNS</li></ol> 
<h2 id="%E5%BE%AE%E5%89%8D%E7%AB%AF%C2%A0%20qiankun">微前端  qiankun</h2> 
<p>主应用需要安装乾坤，子应用有三个周期函数，bootstrap，mount，unmount<br>  </p> 
<pre><code class="language-javascript">子应用

let instance = null;
function render(props = {}) {
  const { container } = props;
  if (props) {
    // 注入 actions 实例
    actions.setActions(props);
  }
  instance = new Vue({
    router,
    store,
    render: (h) =&gt; h(App),
  }).$mount(container ? container.querySelector('#learningApp') : '#learningApp');
}

// 独立运行时
if (!window.__POWERED_BY_QIANKUN__) {
  render();
}

export async function bootstrap() { //初始化之前
  console.log('[vue] vue app bootstraped');
}
export async function mount(props) {//挂载
  console.log('[vue] props from main framework', props);
  render(props);
}
export async function unmount() { //卸载
  instance.$destroy();
  instance.$el.innerHTML = '';
  instance = null;
}
//子应用打包生成的umd格式的js，在window上挂载这三个生命周期，主应用可以直接调用



主应用
import { registerMicroApps, start } from 'qiankun';

registerMicroApps([
  {
    name: 'react app', // app name registered
    entry: '//localhost:7100',
    container: '#yourContainer',
    activeRule: '/yourActiveRule',
  },
  {
    name: 'vue app',
    entry: { scripts: ['//localhost:7100/main.js'] },
    container: '#yourContainer2',
    activeRule: '/yourActiveRule2',
  },
]);

start({
  sandbox: {
    strictStyleIsolation: true, // 使用shadow dom解决样式冲突
    experimentalStyleIsolation: true // 通过添加选择器范围来解决样式冲突 [date-react-app]
  }
}); // 开启应用


 // 配置全局环境变量
  window.__POWERED_BY_QIANKUN__ = true;
  window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ = app.entry;


如果图片出不来，src目录下面加一个文件public-path.js,然后引入,将文件域名指向子应用
if(window.__POWERED_BY_QIANKUN__) {
    __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}
</code></pre> 
<p>原理 <a href="https://blog.csdn.net/weixin_45389051/article/details/123403887" title="手写微前端qiankun框架,vue+react双重配置_进阶的巨人001的博客-CSDN博客">手写微前端qiankun框架,vue+react双重配置_进阶的巨人001的博客-CSDN博客</a></p> 
<blockquote> 
 <p>1.监视路由变化</p> 
 <p>2.匹配子应用</p> 
 <p>3.加载子应用 （unmount(prevApp); 之前的应用需要先卸载）</p> 
 <p>4.渲染子应用</p> 
</blockquote> 
<blockquote> 
 <p>1.客户端渲染需要通过执行 js 来生成内容<br> 2.浏览器出于安全考虑， innerHtml中的 script 不会加载执行<br> 3.所以需要手动加载子应用的script，执行script中的代码，我们可以用eval或者new Function</p> 
</blockquote> 
<p> 监听路由变化，hash的话是 onhashchange， history 监听 popstate、pushState、replaceState<br><a href="https://github.com/lsh555/qiankun" title="GitHub - lsh555/qiankun: 手写微前端qiankun框架，vue+react双重配置">GitHub - lsh555/qiankun: 手写微前端qiankun框架，vue+react双重配置</a></p> 
<h3 id="js%E6%B2%99%E7%AE%B1%E5%8E%9F%E7%90%86%C2%A0%20%C2%A0%E4%B9%BE%E5%9D%A4%E4%BC%9A%E6%A0%B9%E6%8D%AE%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81proxy%E6%9D%A5%E5%86%B3%E5%AE%9A%E7%94%A8%E9%82%A3%E7%A7%8D%E6%96%B9%E5%BC%8F%E3%80%82">js沙箱原理   乾坤会根据当前环境是否支持proxy来决定用那种方式。</h3> 
<h4 id="1.%C2%A0%E6%BF%80%E6%B4%BB%E5%BE%AE%E5%BA%94%E7%94%A8%E6%97%B6%E5%B0%86%E5%BD%93%E5%89%8D%E7%9A%84window%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E5%AD%98%E8%B5%B7%E6%9D%A5%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BB%8EmodifyPropsMap%E4%B8%AD%E6%81%A2%E5%A4%8D%E8%BF%99%E4%B8%AA%E5%BE%AE%E5%BA%94%E7%94%A8%E4%B8%8A%E6%AC%A1%E4%BF%AE%E6%94%B9%E7%9A%84%E5%B1%9E%E6%80%A7%E5%88%B0window%E4%B8%AD%E3%80%82%E5%9C%A8%E7%A6%BB%E5%BC%80%E5%BE%AE%E5%BA%94%E7%94%A8%E6%97%B6%E4%BC%9A%E4%B8%8E%E5%8E%9F%E6%9C%89%E7%9A%84window%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%AF%B9%E6%AF%94%EF%BC%8C%E5%B0%86%E6%9C%89%E4%BF%AE%E6%94%B9%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%9D%E5%AD%98%E8%B5%B7%E6%9D%A5%EF%BC%8C%E4%BB%A5%E4%BE%BF%E5%86%8D%E6%AC%A1%E8%BF%9B%E5%85%A5%E8%BF%99%E4%B8%AA%E5%BE%AE%E5%BA%94%E7%94%A8%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8A%8A%E6%9C%89%E4%BF%AE%E6%94%B9%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%E6%81%A2%E5%A4%8D%E5%88%B0%E4%BB%A5%E5%89%8D%E7%9A%84%E7%8A%B6%E6%80%81%E3%80%82">1.快照沙箱： <span style="color:#fe2c24;">激活微应用时将当前的window对象拷贝存起来</span>，然后从modifyPropsMap中恢复这个微应用上次修改的属性到window中。在离开微应用时会与原有的window对象做对比，将有修改的属性保存起来，以便再次进入这个微应用时进行数据恢复，然后把有修改的属性值恢复到以前的状态。<br><span style="color:#fe2c24;">缺点</span>：需要遍历window上的所有属性，性能差，同时间内只能激活一个微应用</h4> 
<h4 id="2.%C2%A0%E4%BB%A3%E7%90%86%E6%B2%99%E7%AE%B1">2. 代理沙箱 proxy  （单例和多例）</h4> 
<p> import-html-entry 里，也就是加载后的 js 就被包裹了一层 </p> 
<p> function 包裹了一层，所以代码放在了单独作用域跑，又用 with 修改了 window，所以 window 也被隔离了。<br>         </p> 
<h3>css样式隔离</h3> 
<h4>1. shadow dom 隔离样式 </h4> 
<pre><code class="language-javascript">if (appElement.attachShadow) {
    shadow = appElement.attachShadow({ mode: 'open' });
} else {
    shadow = (appElement as any).createShadowRoot();
}
shadow.innerHTML = innerHTML;</code></pre> 
<h4>2.  使用<code>scopedCss</code>做到样式隔离</h4> 
<p>先查找要添加的应用是否有相应的属性，没有的话给子应用容器添加一个属性。然后遍历每个style标签，在每个style标签代码前面增加属性选择符，通过属性选择符+样式来确保样式不被重写</p> 
<p>div[data-qiankun="app-vue"]</p> 
<p></p> 
<h3>qiankun通讯方式</h3> 
<p></p> 
<p>1.  props，主应用通过全局的mount生命周期传递props </p> 
<pre><code class="language-javascript">export async function mount(props) {//挂载
  render(props);
}</code></pre> 
<p>2. initGlobalState(state)<br>         （1）onGlobalStateChange：注册 观察者 函数 - 响应 globalState 变化，在 globalState 发生改变时触发该 观察者 函数。<br>         （2）setGlobalState：设置 globalState - 设置新的值时，内部将执行 浅检查，如果检查到 globalState 发生改变则触发通知，通知到所有的 观察者 函数【深度监听的】<br>         （3）offGlobalStateChange：取消 观察者 函数 - 该实例不再响应 globalState 变化</p> 
<p>==第一步：==首先需要在父应用中使用initGlobalState设置全局状态actions并导出供其他组件使用。<br> ==第二步：==然后在main.js中引入actions实例并在注册子应用时通过props传递全局状态actions：<br> ==第三步：==主应用中的组件要修改全局状态actions，就在此组件中引入actions实例<br> ==第四步：==配置子应用的全局状态Actions，子应用中的全局状态必须要跟主应用中的全局状态变量属性名相同，比如主应用中全局状态变量为{project_id: “项目2”}，则子应用中也需要保证在setGloabalState时也需要设定相同的变量名。<br> 然后在mounted的生命周期里注入actions实例：<br><a href="https://blog.csdn.net/wanghe1111_/article/details/123816165" title="微前端qiankun框架的底层实现原理_veggie_a_h的博客-CSDN博客_qiankun原理">微前端qiankun框架的底层实现原理_veggie_a_h的博客-CSDN博客_qiankun原理</a><br><a href="https://www.jianshu.com/p/b6c12380e02b" rel="nofollow" title="微前端解决方案-qiankun实战及部署 - 简书">微前端解决方案-qiankun实战及部署 - 简书</a></p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/be/e7/NL90m8gc_o.png" width="738"></p> 
<p></p> 
<h3>网页SEO</h3> 
<p> 1. <code>&lt;title&gt;</code>、<code> meta description</code> 和<code> meta</code> <code>keywords</code> 三者的权重依次减小，我们要想网页有好的排名，必须合理使用这三个标签。<br> 2. 搜索引擎是识别文字，而不识别图片的。就拿网站的Logo来举例子，用a标签包裹，设置背景图（京东）<br> 3. 使用语义化元素（禁止滥用H1标签）<br> 4. 利用 <code>&lt;img&gt;</code> 中的 alt 属性<br> 5. 设置 <code>rel='nofollow' </code>忽略跟踪，如果某个链接不需要跟踪，可以忽略，爬虫分给每个页面的权重是一定的<br> 6. 提高加载速度（减少重排和重绘）<br> 7. 扁平化网站结构(一个网站的结构层次越少，越有利于“爬虫”的爬取。模仿用户操作)<br> 8. <code>含重要内容的 HTML 代码放在最前面</code>，<code>因为“爬虫”爬取 HTML 的顺序是从上到下</code>，有的搜索引擎对<code>抓取长度有限制</code>，所以要保证重要内容被<code>优先爬取，</code>并且，重要内容不应该由 JavaScript 输出，因为“爬虫”没有办法读取 JavaScript ，同时也要少用 iframe ，因为“爬虫”一般不会去读取它里面的内容。</p> 
<h3>SSR   VUE  NUXT 服务端渲染</h3> 
<ul><li> <p>客户端渲染 CSR</p> </li><li> <p>服务器端渲染 SSR</p> </li><li> <p>静态站点生成 SSG：缺点是内容可能过时，每次更改内容时都需要构建和部署应用程序。</p> </li><li> <p>增量静态再生 ISR：ISR 是 SSG 的下一个改进，它定期构建和重新验证新页面，以便内容永远不会过时。适合电商，新闻类页面</p> </li><li> <p>SSG和ISR都是next提出的</p> </li></ul> 
<blockquote> 
 <p>适合高度动态的 Web 应用程序<br> 客户端渲染 CSR. ： 典型代表：单页面应用，内容都是js动态渲染<br> 服务器端渲染 SSR ： 在服务端获取数据组装页面，返回到浏览器是html，对服务器要求高，主要应用是交互多的页面需要seo的</p> 
</blockquote> 
<blockquote> 
 <p>适合高度静态的web程序  插件 PrerenderSPAPlugin<br> 静态站点生成 SSG： 在build的的时候就已经生成好静态页面，放在服务端的也是静态页面，博客，静态官网都非常合适<br> 增量静态再生 ISR：ISR 是 SSG 的下一个改进，它定期构建和重新验证新页面，以便内容永远不会过时</p> 
</blockquote> 
<blockquote> 
 <p><strong>原理</strong>：<code>Prerender</code> 就是利用 Chrome 官方出品的 <code>Puppeteer</code> 工具，对页面进行爬取。<br> 在 <code>Webpack</code> 构建阶段的最后，在本地启动一个 <code>Puppeteer</code> 的服务，访问配置了预渲染的路由，然后将 <code>Puppeteer</code> 中渲染的页面输出到 HTML 文件中，并建立路由对应的目录。<br> 所以预渲染的缺点除了需要插件支持以外，由于渲染是在打包阶段，如果页面上有实时更新的数据，则在渲染时显示的不是最新的数据。</p> 
 <p>打包的时候就预先渲染页面，所以在请求到 index.html 就已经是渲染过的内容。</p> 
 <p>可以看出，<strong>SSR 和 Prerender 的最大区别</strong>就在于，<code>Prerender 是静态的，SSR 是动态的，SSR 会在服务端实时构建出对应的 DOM</code>。  </p> 
 <p></p> 
</blockquote> 
<p>vue-meta-info插件配置 title和meta<br> 公司官网用的就是 PrerenderSPAPlugin 生成的，每个页面一个目录。没用ssg是因为基于nuxt的ssg</p> 
<p>1. 如果<strong>页面无数据，或者是纯静态页面，建议使用 Prerender</strong>，这是一种通过预览打包的方式构建页面，也不会增加服务器负担，但其他情况并不推荐。如果<strong>页面数据请求多，又对 SEO 和加载速度有需求的，建议使用 SSR</strong>。</p> 
<p>2. 对于高操作需求的项目来说，CSR 可能更加适合，页面显示元素即绑定了操作，而 SSR 和 Prerender 虽然会提前显示页面，但此时页面元素无法操作，仍需要下载完 bundle.js 进行事件绑定才能执行。</p> 
<p>3. 客户端渲染中，用户的浏览器中永远只存在一个 Store，服务器端的 Store 是所有用户都要用的，共享Store是有问题的，需要<strong>为每个用户提供一个独立的 Store</strong>。</p> 
<p>4. vue的生命周期钩子函数中， 只有 <code>beforeCreate</code> 和 <code>created</code> 会在服务器端渲染(SSR)过程中被调用，这就是说在这两个钩子函数中的代码以及除了vue生命周期钩子函数的全局代码，都将会在服务端和客户端两套环境下执行。<br> 在beforeCreate，created生命周期以及全局的执行环境中调用特定的api前需要判断执行环境。</p> 
<p>5. 在客户端到SSR服务器的请求中，客户端是携带有cookie数据的。但是在SSR服务器请求后端接口的过程中，却是没有相应的cookie数据的。因此在SSR服务器进行接口请求的时候，我们需要手动拿到客户端的cookie传给后端服务器。</p> 
<p>6. vue有两种路由模式，一种是hash模式，就是我们经常用的#/hasha/hashb这种，还有一种是history模式，就是/historya/historyb这种。因为hash模式的路由提交不到服务器上，因此ssr的路由需要采用history的方式</p> 
<p></p> 
<h3>yarn和npm的区别<a href="https://yydatav.blog.csdn.net/article/details/119251135?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1" rel="nofollow" title="https://yydatav.blog.csdn.net/article/details/119251135?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1">https://yydatav.blog.csdn.net/article/details/119251135?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1</a></h3> 
<p><a class="has-card" href="https://yydatav.blog.csdn.net/article/details/119251135?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1" rel="nofollow" title="https://yydatav.blog.csdn.net/article/details/119251135?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1"><span class="link-card-box"><span class="link-title">https://yydatav.blog.csdn.net/article/details/119251135?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/b5/6e/xhWWAYCf_o.png">https://yydatav.blog.csdn.net/article/details/119251135?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1</span></span></a><a href="https://yydatav.blog.csdn.net/article/details/119251135?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1" rel="nofollow" title="https://yydatav.blog.csdn.net/article/details/119251135?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1">https://yydatav.blog.csdn.net/article/details/119251135?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119251135-blog-124731943.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=1</a></p> 
<h3>webpack详解</h3> 
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2F" rel="nofollow" title="Webpack">Webpack</a> 本质上是一个函数，它接受一个配置信息作为参数，执行后返回一个 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2Finternal-plugins%2F%23compiler" rel="nofollow" title="compiler 对象">compiler 对象</a>，调用 <code>compiler</code> 对象中的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fnode%2F%23run" rel="nofollow" title="run">run</a> 方法就会启动编译。<code>run</code> 方法接受一个回调，可以用来查看编译过程中的错误信息或编译信息</p> 
<p>入口文件（<code>src/index.js</code>）被包裹在最后的立即执行函数中，而它所依赖的模块（<code>src/name.js</code>、<code>src/age.js</code>）则被放进了 <code>modules</code> 对象中（<code>modules</code> 用于存放<strong>入口文件的依赖模块</strong>，<code>key 值为依赖模块路径，value 值为依赖模块源代码</code>）。</p> 
<p> <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftapable" rel="nofollow" title="Tapable">Tapable</a> 了！它是一个类似于 Node.js 中的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fevents" rel="nofollow" title="EventEmitter">EventEmitter</a> 的库，但<strong>更专注于自定义事件的触发和处理</strong>。通过 Tapable 我们可以注册自定义事件，然后在适当的时机去执行自定义事件。</p> 
<p>syncHook.tap("监听器3", (name) =&gt; { console.log("监听器3", name); });<br> 在 Webpack 中，就是通过 <code>tapable</code> 在 <code>comiler</code> 和 <code>compilation</code> 上像这样挂载着一系列<code>生命周期 Hook</code>，它就像是一座桥梁，贯穿着整个构建过程：</p> 
<p><code>Webpack Plugin 其实就是一个普通的函数，在该函数中需要我们定制一个 apply 方法。</code>当 Webpack 内部进行插件挂载时会执行 <code>apply</code> 函数。我们可以在 <code>apply</code> 方法中订阅各种生命周期钩子，当到达对应的时间点时就会执行。</p> 
<p></p> 
<h4><br> 打包过程（*）</h4> 
<p>（1）搭建结构，读取配置参数<br> （2）用配置参数对象初始化 <code>Compiler</code> 对象<br> （3）挂载配置文件中的插件<br> （4）执行 <code>Compiler</code> 对象的 <code>run</code> 方法开始执行编译<br> （5）根据配置文件中的 <code>entry</code> 配置项找到所有的入口<br> （6）从入口文件出发，调用配置的 <code>loader</code> 规则，对各模块进行编译<br> （7）找出此模块所依赖的模块，再对依赖模块进行编译<br> （8）等所有模块都编译完成后，根据模块之间的依赖关系，组装代码块 <code>chunk</code><br> （9）把各个代码块 <code>chunk</code> 转换成一个一个文件加入到输出列表<br> （10）确定好输出内容之后，根据配置的输出路径和文件名，将文件内容写入到文件系统</p> 
<p></p> 
<p><code>Compilation</code> 中的 <code>this.fileDependencies</code>（本次打包涉及到的文件）是用来做什么的？为什么没有地方用到该属性？</p> 
<p>这里其实是为了实现<a href="https://link.juejin.cn?target=https%3A%2F%2Fwebpack.docschina.org%2Fguides%2Fdevelopment%2F%23using-watch-mode" rel="nofollow" title=" Webpack 的 watch 模式"> Webpack 的 watch 模式</a>：当文件发生变更时将重新编译。</p> 
<p>思路：对 <code>this.fileDependencies</code> 里面的文件进行监听，当文件发生变化时，重新执行 <code>compile</code> 函数。</p> 
<p><a href="https://juejin.cn/post/7170852747749621791" rel="nofollow" title="二十张图片彻底讲明白Webpack设计理念，以看懂为目的 - 掘金">二十张图片彻底讲明白Webpack设计理念，以看懂为目的 - 掘金</a></p> 
<h3>Webpack HMR 热更新 ，核心流程：</h3> 
<ol><li>使用 webpack-dev-server (后面简称 WDS)托管静态资源，同时以 Runtime 方式注入 HMR 客户端代码；</li><li>浏览器加载页面后，与 WDS 建立 WebSocket 连接；</li><li>Webpack 监听到文件变化后，增量构建发生变更的模块，并通过 WebSocket 发送 hash 事件；</li><li>浏览器接收到 hash 事件后，请求 manifest 资源文件，确认增量变更范围；</li><li>浏览器加载发生变更的增量模块，jsonp请求拿到最新模块代码；</li><li>Webpack 运行时触发变更模块的 module.hot.accept 回调，执行代码变更逻辑；</li><li>done；</li></ol> 
<h3>热更新原理</h3> 
<p>第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</p> 
<p>第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API 对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。</p> 
<p>第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了 devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。</p> 
<p>第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</p> 
<p>webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。</p> 
<p>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</p> 
<p>而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</p> 
<p></p> 
<h4>当模块的热替换过程中，如果替换模块失败，有什么回退机制吗？</h4> 
<p>模块热更新的错误处理，如果在热更新过程中出现错误，热更新将回退到刷新浏览器</p> 
<p></p> 
<h4>说一下 webpack 的热更新原理？</h4> 
<h4>webpack 通过 watch 可以监测代码的变化；webpack-dev-middleware 可以调用 webpack 暴露的 API 检测代码变化，并且告诉 webpack 将代码保存到内存中；webpack-dev-middleware 通过 sockjs 和 webpack-dev-server/client 建立 webSocket 长连接，将 webpack 打包阶段的各个状态告知浏览器端，最重要的是新模块的 hash 值。webpack-dev-server/client 通过 webpack/hot/dev-server 中的 HMR 去请求新的更新模块，HMR 主要借助 JSONP。先拿到 hash 的 json 文件，然后根据 hash 拼接出更新的文件 js，然后 HotModulePlugin 对比新旧模块和模块依赖完成更新。</h4> 
<h4><br> promise模拟接口请求并发限制</h4> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">需求描述：<br> 浏览器限制每次最多发出10个请求接口，总共有1000个待请求接口，每个接口的响应时间是随机的，要保证在某个接口请求成功之后立即请求下一个接口，保证当前并发度始终为10。</p> 
</blockquote> 
<pre><code class="language-javascript">async function asyncPool(poolLimit, array, iteratorFn) {
  const ret = []; // 用于存放所有的promise实例
  const executing = []; // 用于存放目前正在执行的promise
  for (const item of array) {
    const p = Promise.resolve(iteratorFn(item)); // 防止回调函数返回的不是promise，使用Promise.resolve进行包裹
    ret.push(p);
    if (poolLimit &lt;= array.length) {
      // then回调中，当这个promise状态变为fulfilled后，将其从正在执行的promise列表executing中删除
      const e = p.then(() =&gt; executing.splice(executing.indexOf(e), 1));
      executing.push(e);
      if (executing.length &gt;= poolLimit) {
        // 一旦正在执行的promise列表数量等于限制数，就使用Promise.race等待某一个promise状态发生变更，
        // 状态变更后，就会执行上面then的回调，将该promise从executing中删除，
        // 然后再进入到下一次for循环，生成新的promise进行补充
        await Promise.race(executing);
      }
    }
  }
  return Promise.all(ret);
}

//测试代码
const timeout = (i) =&gt; {
  console.log('开始', i);
  return new Promise((resolve) =&gt; setTimeout(() =&gt; {
    resolve(i);
    console.log('结束', i);
  }, i));
};

(async () =&gt; {
    const res = await asyncPool(2, [1000, 5000, 3000, 2000], timeout);
    console.log(res);
  })();
</code></pre> 
<p>代码的核心思路为：</p> 
<ul><li>先初始化 limit 个 promise 实例，将它们放到 executing 数组中</li><li>使用 Promise.race 等待这 limit 个 promise 实例的执行结果</li><li>一旦某一个 promise 的状态发生变更，就将其从 executing 中删除，然后再执行循环生成新的 promise，放入executing 中</li><li>重复2、3两个步骤，直到所有的 promise 都被执行完</li><li>最后使用 Promise.all 返回所有 promise 实例的执行结果</li></ul> 
<h4>原型<br>       原型是函数的一个属性prototype；</h4> 
<p>      通过该函数实例化出来的对象都可以继承得到原型上的所有属性和方法</p> 
<p>      原型对象默认有一个属性constructor ，值为对应的构造函数；另外，有一个属性__proto__，值为Object.prototype</p> 
<p></p> 
<h4>原型链</h4> 
<p> 在JavaScript中万物都是对象，对象和对象之间并不是独立存在的，对象和对象之间有一定关系。</p> 
<p>        通过对象__proto__属性指向函数的原型对象(函数.prototype)一层一层往上找，直到找到Object的原型对象(Object.prototype)为止，层层继承的链接结构叫做原型链（通过proto属性形成原型的链式结构,专业术语叫做原型链）</p> 
<p></p> 
<h4><br><br> flex布局父项常见属性</h4> 
<p><br> flex-direction: 设置主轴的方向<br> justify-content: 设置主轴上的子元素排列方式<br> flex-wrap: 设置子元素是否换行<br> align-content: 设置侧轴的子元素的排列方式（多行）<br> align-items:设置侧轴上的子元素排列方式（单行）<br> flex-flow:复合属性，相当于同时设置了flex-direction 和 flex-wrap</p> 
<p><span style="color:#38d8f0;">flex：1</span> 是 flex-grow, flex-shrink, flex-basis. 三个属性的简写，默认值为 0 1 auto。该属性有两个快捷值：auto(1 1 auto) 和 none(0 0 auto)。建议优先写 flex 属性，而不是写三个分离的属性，因为浏览器会自动计算其相关值。</p> 
<p><span style="color:#4da8ee;">flex-grow</span> 默认为0， 只能是正整数。即父元素有剩余空间也不放大元素。如果为 1，则把剩余空间的一份加给自己的宽度。<br><span style="color:#4da8ee;">flex-shrink</span> 默认为1，只能是正整数。即父元素空间不足则按比例收缩。如果为 0，则不收缩<br><span style="color:#4da8ee;">flex-basis </span>默认为 auto, 即元素本身的大小。这个属性定义了在分配多余空间之前，元素占据的主轴空间，浏览器根据这个属性计算是否有多余空间。可以设置为和 width 和 height 属性一样的值，比如 220px，则元素占据固定空间。</p> 
<h4>readyState的五种状态详解 </h4> 
<p> 0 － （未初始化）还没有调用send()方法<br>  1 － （载入）已调用send()方法，正在发送请求<br>  2 － （载入完成）send()方法执行完成，已经接收到全部响应内容<br>  3 － （交互）已经接收部分数据。但若在此时调用responseBody和responseText属性获取部分结果将会产生错误，因为状态和响应头部还不完全可用。<br>  4 － （完成）响应内容解析完成，可以在客户端调用了<br> readyState为3的时候把网线拔了，可能只接收到部分信息<br><br>  </p> 
<h4> 私有组件库<a href="http://verdaccio.iflyhed.com:84/" rel="nofollow" title="http://verdaccio.iflyhed.com">http://verdaccio.iflyhed.com</a>    维达斯科<br>  </h4> 
<ol><li> <p>切换本地npm源 (可使用nrm 源管理工具)<br> npm config set registry=http://verdaccio.iflyhed.com/</p> </li><li> <p>本地登录</p> <pre><code>1. Login

npm adduser --registry http://verdaccio.iflyhed.com/
2. Publish

npm publish --registry http://verdaccio.iflyhed.com/</code></pre> </li></ol> 
<h4></h4> 
<p>3.使用安装    npm i fif-base<br> 4. 上传包  </p> 
<pre><code>npm version patch  //自增版本号
npm publish // 推送到服务器</code></pre> 
<p></p> 
<p><strong>angular 的数据绑定采用什么机制？详述原理</strong></p> 
<p>脏检查机制。<br> 双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 <a href="https://so.csdn.net/so/search?q=model&amp;spm=1001.2101.3001.7020" title="model">model</a> ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。</p> 
<p>原理就是，Angular 在 <a href="https://so.csdn.net/so/search?q=scope&amp;spm=1001.2101.3001.7020" title="scope">scope</a> 模型上设置了一个监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch ，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时， $digest 循环就会触发，遍历所有的 $watch ，最后更新 dom。</p> 
<p></p> 
<h4>vue响应式原理</h4> 
<p>在 newVue() 后， Vue 会调用 _init 函数进行初始化，也就是init 过程，在 这个过程Data通过Observer转换成了getter/setter的形式，来对数据追踪变化，当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter函数。</p> 
<p>当render function 执行的时候，因为会读取所需对象的值，所以会触发getter函数从而将Watcher添加到依赖中进行依赖收集。</p> 
<p>在修改对象的值的时候，会触发对应的 setter， setter通知之前依赖收集得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher就会开始调用 update 来更新视图。<br>  </p> 
<p></p> 
<h4>proxy和Object.defineProperty区别</h4> 
<p>1.Proxy性能优于Object.defineProperty。 Proxy代理的是整个对象Object.defineProperty只代理对象上的某个属性,如果是多层嵌套的数据需要循环递归绑定;<br> 2.对象上定义新属性时，Proxy可以监听到，Object.defineProperty监听不到，需要借助$set方法;<br> 3.数组的某些方法(push、unshift和splice)Object.defineProperty监听不到，Proxy可以监听到;<br> 4.Proxy在ie浏览器存在兼容性问题  ，vue做了降级处理使用  Object.defineProperty</p> 
<p>内部使用reflect，proxy存在get陷阱，this可能不会指向调用者。用reflect修正this指向到调用者。<br> 13个api方法。 </p> 
<h4>object.definePropety 的深度监听是一次性就全部监听的，而 proxy 的深度监听是在 get 的时候才去递归的，是一个惰性的，很慢的过程，这就是 proxy 性能的优化。开始内部只是一个普通对象，当调用时才会reactive(result)递归添加响应式，将访问的对象变成proxy对象。</h4> 
<p></p> 
<h4>vue对数组的监听</h4> 
<pre><code class="language-javascript">/**
 * Vue对数组的变化侦测
 * 思想: 通过一个拦截器来覆盖Array.prototype。
 * 拦截器其实就是一个Object, 它的属性与Array.prototype一样。 只是对数组的变异方法进行了处理。
*/
 
function def (obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    })
}
 
// 数组原型对象
const arrayProto = Array.prototype
// 拦截器
const arrayMethods = Object.create(arrayProto)
 
// 变异数组方法：执行后会改变原始数组的方法
const methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
]
 
methodsToPatch.forEach(function (method) {
    // 缓存原始的数组原型上的方法
    const original = arrayProto[method]
    // 对每个数组编译方法进行处理(拦截)
    def(arrayMethods, method, function mutator (...args) {
      // 返回的value还是通过数组原型方法本身执行的结果
      const result = original.apply(this, args)
      // 每个value在被observer()时候都会打上一个__ob__属性
      const ob = this.__ob__
      // 存储调用执行变异数组方法导致数组本身值改变的数组，主要指的是原始数组增加的那部分(需要重新Observer)
      let inserted
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args
          break
        case 'splice':
          inserted = args.slice(2)
          break
      }
      // 重新Observe新增加的数组元素
      if (inserted) ob.observeArray(inserted)
      // 发送变化通知
      ob.dep.notify()
      return result
    })
})
 
</code></pre> 
<p></p> 
<p></p> 
<h4>type 和 interface区别</h4> 
<p>type一般定义基本类型，（可定义所有类型）扩展用&amp;    <strong>基本类型的别名，联合类型，元组类型</strong><br> interface 一般用来定义接口，描述数据类型 ， 扩展用extend，<strong>声明合并</strong></p> 
<p></p> 
<p></p> 
<p><strong>cdn的概念，cdn失败了，如何处理。</strong></p> 
<p><strong>sort内部原理，找到数组第二大元素，边界问题（一个元素，全都是一个元素）  new Set()</strong></p> 
<p><strong>sort length&lt;10 插入排序  O（n2），n&gt;10快速排序（二分法，nlogn）</strong></p> 
<p>双向绑定</p> 
<p>vue层面的优化</p> 
<p>虚拟dom的理解</p> 
<p>性能优化</p> 
<p>学习的途径</p> 
<p>http2相比于http1.1的优势</p> 
<p>微任务和宏任务</p> 
<p>重绘和回流</p> 
<p>index.html  如何清缓存  （nginx配置不缓存index.html）    </p> 
<blockquote> 
 <p>&lt;--如果需要在html页面上设置不缓存，这在标签中加入如下语句--&gt;<br> &lt;meta http-equiv="Pragma" content="no-cache"&gt;<br> &lt;--用于设定禁止浏览器从本地机的缓存中调阅页面内容--&gt;<br> &lt;meta http-equiv="Cache-Control" content="no-cache, must-revalidate"&gt;<br> &lt;-- Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。--&gt;<br> &lt;meta http-equiv="Expires" content="0"&gt;</p> 
</blockquote> 
<p>router，axios封装，</p> 
<p></p> 
<p></p> 
<h4>vuex</h4> 
<ul><li><strong>Vuex 是通过 new 一个 vue 实例，并把 state 作为 vue 的 data 利用 vue 的响应式系统把 state 中的数据变为了 响应式数据。</strong>* **getter 本质上是依赖了 vue 的 computed 实现了缓存机制。**store.js</li><li>定义了 install 方法，该方法在执行 Vue.use(Vuex) 时会自动调用，install 方法中主要是调用 mixin 方法，在 beforeCreate 勾子中为每个组件都混入一个$store 属性，他们都指向同一个 </li></ul> 
<p></p> 
<p><strong>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</strong></p> 
<p><strong>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位）</strong></p> 
<p><br><strong>VUEX应用场景  原理</strong></p> 
<p><strong>D3  api</strong></p> 
<p><strong>适配问题 不同分辨率</strong></p> 
<p><strong>性能优化    </strong></p> 
<p><strong> 什么场景不能用this  </strong></p> 
<p><strong> es6语法 </strong></p> 
<p><strong> 关系图的数据结构     </strong></p> 
<p></p> 
<p></p> 
<p><strong>pinia和vuex的区别</strong></p> 
<p><strong>qiankun沙箱原理（js、css）</strong></p> 
<p><strong>vite 和wabpack的区别</strong></p> 
<p><strong>vite首次启动过慢解决方案</strong></p> 
<p></p> 
<h4>vue更新页面方式</h4> 
<p>$forceUpdate    this.$router.go(0)   使用v-if标记    改变key<br> $forceUpdate    在依赖发生变化的时候会通知​​watcher​​，然后通知​​watcher​​来调用​​update​​方法，重新render</p> 
<pre><code class="language-javascript">Vue.prototype.$forceUpdate = function () {
    const vm: Component = this
    if (vm._watcher) {
        vm._watcher.update()
    }
}</code></pre> 
<p></p> 
<p>requestIdleCallback    会在网页渲染完成后，CPU 空闲时执行<br> requestAnimationFrame     浏览器每次渲染都会执行，不用自己计算时间</p> 
<p>首屏时间  firstScreen - performance.timing.navigationStart<br> 白屏时间  </p> 
<p><img alt="" height="166" src="https://images2.imgbox.com/a3/e7/kAjpju8h_o.png" width="977"></p> 
<p> async脚本会在页面加载完毕后执行。</p> 
<p></p> 
<p></p> 
<h4>axios底层实现原理</h4> 
<pre><code class="language-javascript">class Axios {
    constructor() {
        新增代码
        this.interceptors = {
            request: new InterceptorsManage,
            response: new InterceptorsManage
        }
    }
 
    request(config) {
        return new Promise(resolve =&gt; {
            const {url = '', method = 'get', data = {}} = config;
            // 发送ajax请求
            console.log(config);
            const xhr = new XMLHttpRequest();
            xhr.open(method, url, true);
            xhr.onload = function() {
                console.log(xhr.responseText)
                resolve(xhr.responseText);
            };
            xhr.send(data);
        })
    }
}

class InterceptorsManage {
  constructor() {
    this.handlers = [];
  }
 
  use(fullfield, rejected) {
    this.handlers.push({
      fullfield,
      rejected
    })
  }
}</code></pre> 
<p></p> 
<p></p> 
<h4>ts比js  V8引擎中编译效率更高</h4> 
<p>js -----(parse)  --&gt; ast语法树  -----（类型推断，不同类型存储地址不同，ts有类型定义，省去了推断，更高效）----------&gt;   字节码   -&gt;机器码运行</p> 
<p></p> 
<p></p> 
<h4>vue3性能优化</h4> 
<p>1. 响应式系统升级  object.defineProperty,递归对象每个属性，proxy 在对象外层加一个拦截，惰性响应式，只有获取属性时才会动态设置proxy，  内部使用reflect，避免了proxy的get陷阱</p> 
<p>2. Vue2中会通过<strong>标记根节点</strong>的操作，<strong>优化diff过程</strong>，但是静态节点还需要被diff，这个过程没有被优化<br> 当组件的状态发生变化后，会通知 watcher 触发 update 函数，最终执行虚拟dom的patch操作，遍历所有的虚拟节点，找到差异更新到真实节点上<br> diff的过程中会去比较整个虚拟dom，先对比新旧的div以及他的属性，然后再对比他的子节点<br> Vue2中渲染的最小单位是组件</p> 
<p>Vue3中标记和提升所有的静态节点，diff的时候只需要对比动态节点内容  <code>Fragments</code>片段的特性<br> 几个静态节点的dom全部都被提取到了最外层，这些被提升的静态节点，只有在创建的时候被创建一次，之后我们在调用render的时候，只需要进行复用就好。</p> 
<p>3. catchHandler 缓存函数，再次进行调用的时候，就会通过缓存中获取函数</p> 
<p>4. 对 Tree-shaking 的依赖更好，按需引入做的更好</p> 
<p></p> 
<h4>vite和webpack的区别</h4> 
<p>vite服务器启动速度比webpack快，由于vite启动的时候不需要打包，也就无需分析模块依赖、编译，所以启动速度非常快。当浏览器请求需要的模块时，再对模块进行编译，这种按需动态编译的模式，极大缩短了编译时间，当项目越大，文件越多时，vite的开发时优势越明显。vite热更新比webpack快，vite在HRM方面，当某个模块内容改变时，让浏览器去重新请求该模块即可，而不是像webpack重新将该模块的所有依赖重新编译。</p> 
<p>Vite的使用简单，只需执行初始化命令，就可以得到一个预设好的开发环境，开箱即获得一堆功能，包括：CSS预处理、html预处理、异步加载、分包、压缩、HMR等。使用复杂度介于Parcel和Webpack的中间，只是暴露了极少数的配置项和plugin接口，既不会像Parcel一样配置不灵活，又不会像Webpack一样需要了解庞大的loader、plugin生态，灵活适中、复杂度适中。</p> 
<h4>加速vite首次启动慢的问题</h4> 
<p>1. vite.config.ts，添加配置预打包的文件，比较繁琐<br> 2.<a href="https://www.npmjs.com/package/vite-plugin-optimize-persist" rel="nofollow" title=" vite-plugin-optimize-persist"> vite-plugin-optimize-persist</a> 插件，首次启动会给package.json文件添加预打包的配置， 第一次启动慢，再次进入会使用缓存，加速启动</p> 
<p></p> 
<h4>判断数组的方法<br> 深拷贝和浅拷贝的区别，，，扩展运算符是深拷贝还是浅拷贝...</h4> 
<p>...   当拷贝对象的<strong>属性值</strong>对应的都是<strong>基本类型数据</strong>，可以理解为<strong>深拷贝</strong>。当拷贝对象的<strong>属性</strong>对应的值为数组或对象等<strong>引用类型</strong>时，为<strong>浅拷贝</strong></p> 
<p><strong>跨域的方案，线上如何解决的  <br> 前端优化   <br> promise.all原理<br> 从0开始搭建框架需要考虑什么</strong></p> 
<p><a href="https://so.csdn.net/so/search?q=jsonp&amp;spm=1001.2101.3001.7020" title="jsonp">jsonp</a>是一种跨域通信的手段，它的原理其实很简单：</p> 
<ol><li> <p>首先是利用script标签的src属性来实现跨域。</p> </li><li> <p>通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。</p> </li><li> <p>由于使用script标签的src属性，因此只支持get方法</p> </li></ol> 
<p>Loader直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。<br> loader它只专注于转化文件（transform）这一个领域，完成压缩，打包，语言翻译; 而plugin不仅只局限在打包，资源的加载上，还可以打包优化和压缩，重新定义环境变量等</p> 
<p>watch和computed的区别</p> 
<p></p> 
<h2><a href="https://my.oschina.net/caiya928/blog/784051" rel="nofollow" title="webview 长按事件 js 监听">webview 长按事件 js 监听</a></h2> 
<pre><code class="language-javascript">var timeOutEvent = 0; //定时器 
    //开始按 
    function gtouchstart() {
        timeOutEvent = setTimeout("longPress()", 500); //这里设置定时器，定义长按500毫秒触发长按事件，时间可以自己改，个人感觉500毫秒非常合适 
        return false;
    };
    //手释放，如果在500毫秒内就释放，则取消长按事件，此时可以执行onclick应该执行的事件 
    function gtouchend() {
        clearTimeout(timeOutEvent); //清除定时器 
        if (timeOutEvent != 0) {
            //这里写要执行的内容（尤如onclick事件） 
            //alert("你这是点击，不是长按");
        }
        return false;
    };
    //如果手指有移动，则取消所有事件，此时说明用户只是要移动而不是长按 
    function gtouchmove() {
        clearTimeout(timeOutEvent); //清除定时器 
        timeOutEvent = 0;
    };

    //真正长按后应该执行的内容 
    function longPress() {
        timeOutEvent = 0;
        //执行长按要执行的内容，如弹出菜单 
        //alert("长按事件触发");
        do_Page.fire("showTool",{"index":index,"url":images[index].source});
    }</code></pre> 
<p>CORS全称“跨域资源共享”，它是一种机制通过添加额外的HTTP头部告诉浏览器，允许origin上的web应用访问不同源服务器资源，可以在XMLHttpRequest、Fetch中使用CORS发起跨域请求。</p> 
<p>移动端bug</p> 
<p><a href="https://blog.csdn.net/weixin_40046130/article/details/110231613?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-110231613-blog-128968884.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-110231613-blog-128968884.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=3" title="移动端页面开发bug记录 多年总结 长期更新_泡面而已的博客-CSDN博客_前端开发 移动端输入bug">移动端页面开发bug记录 多年总结 长期更新_泡面而已的博客-CSDN博客_前端开发 移动端输入bug</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/18d3b4c987cf01f49241d52bc4913d96/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手把手教你使用ChatGPT辅助写论文</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/636df36be867f3091f55224dbea808e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java格式化日期SimpleDateFormat在Linux下显示英文问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>