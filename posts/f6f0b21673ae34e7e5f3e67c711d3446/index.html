<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>驱动 | Linux | NVMe - 1. 内核驱动 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="驱动 | Linux | NVMe - 1. 内核驱动" />
<meta property="og:description" content="本文总结 NVMe 的 Linux 驱动是如何实现的。
Update: 2022 / 11 / 2
系列文章 驱动 | Linux | NVMe - 1. 内核驱动 系列文章总览NVMe 命令PCI 总线注册和初始化驱动创建 NVMe 块设备硬件层面软件层面 NVMe 设备的 IO 流程DMA参考链接 总览 NVMe (Non-VolatileMemory express)，是一种建立在 M.2 接口上的类似 AHCI 的一种协议，是专门为闪存类存储设计的协议。
NVMe 具体优势包括：
性能有数倍的提升；可降低延迟超过50%；NVMe PCIe SSD 可提供的 IOPs 十倍于高端企业级 SATA SSD ;自动功耗状态切换和动态能耗管理功能大大降低功耗；支持未来十年技术发展的可扩展能力。 码农该怎么理解？——
问：它是一个存储协议，既然是存储协议是不是需要快速的读写？
答：对。 PCIe 才是最快的协议啊，为啥不用 PCIe 呢？
答：PCIe 很复杂的。 问：那我们给 PCIe 穿个马甲，就可以？
答：NVMe 就是给 PCIe 穿个马甲。 问：NVMe 是怎么做到的？
答：PCIe 是作文题，NVMe 是选词填空，最后的结果却一样。 问：怎么填？填什么？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f6f0b21673ae34e7e5f3e67c711d3446/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-06T01:19:20+08:00" />
<meta property="article:modified_time" content="2022-11-06T01:19:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">驱动 | Linux | NVMe - 1. 内核驱动</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文总结 <code>NVMe</code> 的 <code>Linux</code> 驱动是如何实现的。</p> 
<p>Update: 2022 / 11 / 2</p> 
<hr> 
<h2><a id="_6"></a>系列文章</h2> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>驱动 | Linux | NVMe - 1. 内核驱动</h4> 
 <ul><li><a href="#_6" rel="nofollow">系列文章</a></li><li><a href="#_14" rel="nofollow">总览</a></li><li><a href="#NVMe__58" rel="nofollow">NVMe 命令</a></li><li><a href="#PCI__95" rel="nofollow">PCI 总线</a></li><li><a href="#_120" rel="nofollow">注册和初始化驱动</a></li><li><a href="#_NVMe__379" rel="nofollow">创建 NVMe 块设备</a></li><li><ul><li><a href="#_434" rel="nofollow">硬件层面</a></li><li><a href="#_444" rel="nofollow">软件层面</a></li></ul> 
  </li><li><a href="#NVMe__IO__465" rel="nofollow">NVMe 设备的 IO 流程</a></li><li><a href="#DMA_497" rel="nofollow">DMA</a></li><li><a href="#_513" rel="nofollow">参考链接</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_14"></a>总览</h2> 
<p><code>NVMe (Non-VolatileMemory express)</code>，是一种建立在 <code>M.2</code> 接口上的类似 <code>AHCI</code> 的一种协议，是专门为闪存类存储设计的协议。<br> <code>NVMe</code> 具体优势包括：</p> 
<ul><li>性能有数倍的提升；</li><li>可降低延迟超过50%；</li><li><code>NVMe PCIe SSD</code> 可提供的 <code>IOPs</code> 十倍于高端企业级 <code>SATA SSD</code> ;</li><li>自动功耗状态切换和动态能耗管理功能大大降低功耗；</li><li>支持未来十年技术发展的可扩展能力。</li></ul> 
<p>码农该怎么理解？——</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 问：它是一个存储协议，既然是存储协议是不是需要快速的读写？<br> 答：对。</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> <code>PCIe</code> 才是最快的协议啊，为啥不用 <code>PCIe</code> 呢？<br> 答：<code>PCIe</code> 很复杂的。</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 问：那我们给 <code>PCIe</code> 穿个马甲，就可以？<br> 答：<code>NVMe</code> 就是给 <code>PCIe</code> 穿个马甲。</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 问：<code>NVMe</code> 是怎么做到的？<br> 答：<code>PCIe</code> 是作文题，<code>NVMe</code> 是选词填空，最后的结果却一样。</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked disabled> 问：怎么填？填什么？<br> 答：按照这个表格填写，发什么就填什么，总共 <code>64</code> 字节，不需要的填 <code>0</code> 就行了。</li></ul> 
<table><thead><tr><th align="left"><code>IO Command</code></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">appmask</td><td align="left">apptag</td><td align="left">reftag</td><td align="left">dsmgmt</td><td align="left">slba</td><td align="left">addr</td><td align="left">metadata</td><td align="left">rsvd</td><td align="left">nblocks</td><td align="left">control</td><td align="left">Flags</td><td align="left">Opcode</td></tr><tr><td align="left"><strong><code>Admin Command</code></strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">rsvd11</td><td align="left">numd</td><td align="left">offset</td><td align="left">lid</td><td align="left">prp2</td><td align="left">prp1</td><td align="left">rsvd1</td><td align="left">command_id</td><td align="left">flags</td><td align="left">Opcode</td><td align="left"></td><td align="left"></td></tr></tbody></table> 
<br> 
<p><code>NVMe</code> 是一种 <code>Host</code> 与 <code>SSD</code> 之间通讯的协议，制定了 <code>Host</code> 与 <code>SSD</code> 之间通讯的命令，以及命令如何执行的，它在协议栈中隶属高层，</p> 
<p><img src="https://images2.imgbox.com/fb/31/cJn6d4mO_o.png" alt="在这里插入图片描述" width="300"><br> <br></p> 
<p><code>NVMe</code> 离不开 <code>PCIe</code>，<code>NVMe SSD</code> 是 <code>PCIe</code> 的 <code>endpoint</code>。<code>PCIe</code> 是 <code>x86</code> 平台上一种流行的 <code>bus</code> 总线，由于其 <code>Plug and Play</code> 的特性，目前很多外设都通过 <code>PCI Bus</code> 与 <code>Host</code> 通信，甚至不少 <code>CPU</code> 的集成外设都通过 <code>PCI Bus</code> 连接，如 <code>APIC</code>等。<br> <code>NVMe SSD</code> 在 <code>PCIe</code> 接口上使用新的标准协议 <code>NVMe</code> ，由大厂 <code>Intel</code> 推出并交由 <code>nvmexpress</code> 组织推广，现在被全球大部分存储企业采纳 <sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1">1</a></sup>。<br> 　　<br> <code>NVMe SSD</code> 本身是一个块设备，因此 <code>NVMe</code> 的驱动也是遵循块设备的驱动架构。<br> 本文基于 <code>Linux 4.1.12</code> 版本的内核（ 其它版本的内核代码可能略有不同，但不影响理解）通过两部分介绍 <code>NVMe</code> 的驱动程序 <sup class="footnote-ref"><a href="#fn2" rel="nofollow" id="fnref2">2</a></sup>：</p> 
<ul><li>操作系统如何创建 <code>NVMe</code> 块设备</li><li><code>NVMe</code> 的主要流程，包括读写流程和管理流程等</li></ul> 
<hr> 
<h2><a id="NVMe__58"></a>NVMe 命令</h2> 
<p>参考这里 <sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1:1">1</a></sup>’ <sup class="footnote-ref"><a href="#fn3" rel="nofollow" id="fnref3">3</a></sup></p> 
<p><code>NVMe Host</code> 和 <code>NVMe Controller</code> 通过 <code>NVMe Command</code> 进行信息交互。<br> <code>NVMe Command</code> 是 <code>Host</code> 与 <code>SSD Controller</code> 交流的基本单元，应用的 <code>I/O</code> 请求也要转化成 <code>NVMe Command</code>。</p> 
<p><code>NVMe Spec</code> 中定义了 <code>NVMe Command</code> 的格式，占用 <code>64</code> 字节。<br> <code>NVMe Command</code> 分为 <code>Admin Command</code> 和 <code>IO Command</code> 两大类，前者主要是 <code>Host</code> 用于管理和控制 <code>SSD</code>，后者用于 <code>Host</code> 和 <code>SSD</code> 之间的数据传输。</p> 
<p>发送的太快我来不及执行咋办？——<br> 搞两个缓冲区吧：</p> 
<ul><li>发送缓冲区 <code>SubmissionQueue</code>（ <code>SQ</code> ）</li><li>完成缓冲区 <code>CompletionQueue</code>（ <code>CQ</code> ）</li></ul> 
<p>处理完了，我该怎么告诉你呢？——</p> 
<ul><li>写 <code>Doorbell Register</code>（ <code>DB</code> ）</li></ul> 
<p>这个系统结构可以下图表示，</p> 
<p><img src="https://images2.imgbox.com/39/c8/0zmJ9LrV_o.png" alt="在这里插入图片描述" width="400"><br> 这个 <code>namespace</code> 是什么？——<br> 每个 <code>flash</code> 块就是一个 <code>namaspce</code>，它有个 <code>id</code> ，叫 <code>namaspce ID</code>。</p> 
<p><code>NVMe</code> 到 <code>SDD</code> 是怎么玩的？——<br> 举例 <code>Host</code> 需要从 <code>flash</code> 地址 <code>0x02000000</code> 上读取 <code>nblock = 2</code> 的数据，<code>PRP1</code> 给出内存地址是<code>0x10000000</code>，该怎么操作？<br> 首先我们得组包 <code>nvme_cmd</code>，这个包为读命令，它包含我们读地址（ <code>0x02000000</code> ）、长度（ <code>nblock = 2</code> ）、和读到什么地方（ <code>PRP</code> ），然后把这个包扔给 <code>SQ</code>，写 <code>doorbell</code> 通知控制器来取命令，控制器取出命令来转换为 <code>TLP</code> 包通过 <code>PCIe Memory</code> 方式把 <code>0x02000000</code> 的数据写入到<code>0x10000000</code> 中，然后在 <code>CQ</code> 的尾部写入完成标志，再写 <code>doorbell</code> 告诉控制器我的事干完了。</p> 
<ul><li> 
  <ol><li>这个命令放在 <code>SQ</code> 里；</li></ol> </li><li> 
  <ol start="2"><li><code>Host</code> 通过写 <code>SQ</code> 的 <code>Tail DB</code>，通知 <code>SSD</code> 来取命令；</li></ol> </li><li> 
  <ol start="3"><li><code>SSD</code> 收到通知，去 <code>Host</code> 端的 <code>SQ</code> 中取指。 <code>PCIe</code> 是通过发一个 <code>Memory Read TLP</code> 到 <code>Host</code> 的 <code>SQ</code> 中取命令的；</li></ol> </li><li> 
  <ol start="4"><li><code>SSD</code> 执行读命令，把数据从闪存中读到缓存中，然后把数据传给 <code>Host</code>；</li></ol> </li><li> 
  <ol start="5"><li><code>SSD</code> 往 <code>Host</code> 的 <code>CQ</code> 中返回状态；</li></ol> </li><li> 
  <ol start="6"><li><code>SSD</code> 采用中断的方式告诉 <code>Host</code> 去处理 <code>CQ</code>；</li></ol> </li><li> 
  <ol start="7"><li><code>Host</code> 处理相应的 <code>CQ</code></li></ol> </li></ul> 
<hr> 
<h2><a id="PCI__95"></a>PCI 总线</h2> 
<p>参考这里 <sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1:2">1</a></sup></p> 
<p>在系统启动时，<code>BIOS</code> 会枚举整个 <code>PCI</code> 的总线，之后将扫描到的设备通过 <code>ACPI tables</code> 传给操作系统。当操作系统加载时，<code>PCI Bus</code> 驱动则会根据此信息读取各个 <code>PCI</code> 设备的 <code>Header Config</code> 空间，从 <code>class code</code> 寄存器获得一个特征值。</p> 
<p><code>class code</code> 是 <code>PCI bus</code> 用来选择哪个驱动加载设备的唯一根据。<code>NVMe Spec</code> 定义的 <code>class code</code> 是 <code>010802h</code>。<code>NVMe SSD</code> 内部的 <code>Controller</code> <code>PCIe Header</code> 中 <code>class code</code> 都会设置成 <code>010802h</code>。<br> <img src="https://images2.imgbox.com/e7/82/RuikESEK_o.png" alt="在这里插入图片描述" width="600"><br> 所以，需要在驱动中指定 <code>class code</code> 为 <code>010802h</code>，将 <code>010802h</code> 放入 <code>pci_driver nvme_driver</code> 的 <code>id_table</code>。之后当<code>nvme_driver</code> 注册到 <code>PCI Bus</code> 后，<code>PCI Bus</code> 就知道这个驱动是给 <code>class code=010802h</code> 的设备使用的。<code>nvme_driver</code> 中有一个 <code>probe</code> 函数，<code>nvme_probe()</code>，这个函数才是真正加载设备的处理函数。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PCI_CLASS_STORAGE_EXPRESS</span>       <span class="token expression"><span class="token number">0x010802</span></span></span>

<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pci_device_id</span> nvme_id_table<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>

……

<span class="token punctuation">{<!-- --></span> <span class="token function">PCI_DEVICE_CLASS</span><span class="token punctuation">(</span>PCI_CLASS_STORAGE_EXPRESS<span class="token punctuation">,</span> <span class="token number">0xffffff</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>

……

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h2><a id="_120"></a>注册和初始化驱动</h2> 
<p>参考这里 <sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1:3">1</a></sup></p> 
<p>我们知道首先是驱动需要注册到PCI总线。那么nvme_driver是如何注册的呢？</p> 
<p>当驱动被加载时就会调用 <code>nvme_init</code> ( <code>drivers/nvme/host/pci.c</code> <sup class="footnote-ref"><a href="#fn4" rel="nofollow" id="fnref4">4</a></sup> ) 函数，如下所示，</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">nvme_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">nvme_create_cq</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">nvme_create_sq</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">nvme_delete_queue</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span>IRQ_AFFINITY_MAX_SETS <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span><span class="token function">nvme_pci_npages_prp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> NVME_CTRL_PAGE_SIZE<span class="token punctuation">)</span> <span class="token operator">&gt;</span>
		     S8_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">pci_register_driver</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nvme_driver<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个函数中，调用了 <code>kernel</code> 的函数 <code>pci_register_driver</code>，注册 <code>nvme_driver</code>。这样 <code>PCI bus</code> 上就多了一个 <code>pci_driver nvme_driver</code>。</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">pci_driver</span> nvme_driver <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span>name		<span class="token operator">=</span> <span class="token string">"nvme"</span><span class="token punctuation">,</span>
	<span class="token punctuation">.</span>id_table	<span class="token operator">=</span> nvme_id_table<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>probe		<span class="token operator">=</span> nvme_probe<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>remove		<span class="token operator">=</span> nvme_remove<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>shutdown	<span class="token operator">=</span> nvme_shutdown<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_PM_SLEEP</span></span>
	<span class="token punctuation">.</span>driver		<span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
		<span class="token punctuation">.</span>pm	<span class="token operator">=</span> <span class="token operator">&amp;</span>nvme_dev_pm_ops<span class="token punctuation">,</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token punctuation">.</span>sriov_configure <span class="token operator">=</span> pci_sriov_configure_simple<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>err_handler	<span class="token operator">=</span> <span class="token operator">&amp;</span>nvme_err_handler<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>当读到一个设备的 <code>class code</code> 是 <code>010802h</code> 时，就会调用这个 <code>nvme_driver</code> 结构体的 <code>probe</code> 函数, 也就是说当设备和驱动匹配了之后，驱动的 <code>probe</code> 函数就会被调用，来实现驱动的加载。</p> 
<p><code>Probe</code> 函数主要完成四个工作：</p> 
<ul><li>映射设备的 <code>BAR</code> 空间到内存虚拟地址空间；</li><li>设置 <code>admin queue</code>；</li><li>添加 <code>nvme namespace</code> 设备；</li><li>添加 <code>nvme Controller</code>，提供 <code>ioctl</code> 接口。</li></ul> 
<p><code>PCIe</code> 的 <code>Header</code> 空间和 <code>BAR</code> 空间是 <code>PCIe</code> 的关键特性。<code>Header</code> 空间是 <code>PCIe</code> 设备的通有属性，所有的 <code>PCIe Spec</code> 功能和规范都在这里实现；<code>BAR</code> 空间则是设备差异化的具体体现，<code>BAR</code> 空间的定义决定了这个设备是网卡，<code>SSD</code> 还是虚拟设备。<code>BAR</code> 空间是 <code>Host</code> 和 <code>PCIe</code> 设备进行信息交互的重要介质，<code>BAR</code> 空间的数据实际存储在 <code>PCIe</code> 设备上。<code>Host</code> 这边给 <code>PCIe</code> 设备分配的地址资源，并不占用 <code>Host</code> 的内存资源。当读写 <code>BAR</code> 空间时，都需要通过 <code>PCIe</code> 接口（通过<code>PCI TLP</code> 消息）进行实际的数据传输。</p> 
<p>接着来看下 <code>nvme_driver</code> 结构体中的 <code>.probe</code> 函数 <code>nvme_probe</code>，</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nvme_probe</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pci_dev</span> <span class="token operator">*</span>pdev<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pci_device_id</span> <span class="token operator">*</span>id<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> node<span class="token punctuation">,</span> result <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">nvme_dev</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> quirks <span class="token operator">=</span> id<span class="token operator">-&gt;</span>driver_data<span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> alloc_size<span class="token punctuation">;</span>

	node <span class="token operator">=</span> <span class="token function">dev_to_node</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> NUMA_NO_NODE<span class="token punctuation">)</span>
		<span class="token function">set_dev_node</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> first_memory_node<span class="token punctuation">)</span><span class="token punctuation">;</span>

	dev <span class="token operator">=</span> <span class="token function">kzalloc_node</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dev<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>

	dev<span class="token operator">-&gt;</span>nr_write_queues <span class="token operator">=</span> write_queues<span class="token punctuation">;</span>
	dev<span class="token operator">-&gt;</span>nr_poll_queues <span class="token operator">=</span> poll_queues<span class="token punctuation">;</span>
	dev<span class="token operator">-&gt;</span>nr_allocated_queues <span class="token operator">=</span> <span class="token function">nvme_max_io_queues</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	dev<span class="token operator">-&gt;</span>queues <span class="token operator">=</span> <span class="token function">kcalloc_node</span><span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>nr_allocated_queues<span class="token punctuation">,</span>
			<span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">nvme_queue</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dev<span class="token operator">-&gt;</span>queues<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> free<span class="token punctuation">;</span>

	dev<span class="token operator">-&gt;</span>dev <span class="token operator">=</span> <span class="token function">get_device</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">pci_set_drvdata</span><span class="token punctuation">(</span>pdev<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

	result <span class="token operator">=</span> <span class="token function">nvme_dev_map</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> put_pci<span class="token punctuation">;</span>

	<span class="token function">INIT_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev<span class="token operator">-&gt;</span>ctrl<span class="token punctuation">.</span>reset_work<span class="token punctuation">,</span> nvme_reset_work<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">INIT_WORK</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev<span class="token operator">-&gt;</span>remove_work<span class="token punctuation">,</span> nvme_remove_dead_ctrl_work<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev<span class="token operator">-&gt;</span>shutdown_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>

	result <span class="token operator">=</span> <span class="token function">nvme_setup_prp_pools</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> unmap<span class="token punctuation">;</span>

	quirks <span class="token operator">|=</span> <span class="token function">check_vendor_combination_bug</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>noacpi <span class="token operator">&amp;&amp;</span> <span class="token function">acpi_storage_d3</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">/*
		 * Some systems use a bios work around to ask for D3 on
		 * platforms that support kernel managed suspend.
		 */</span>
		<span class="token function">dev_info</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span>
			 <span class="token string">"platform quirk: setting simple suspend\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		quirks <span class="token operator">|=</span> NVME_QUIRK_SIMPLE_SUSPEND<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/*
	 * Double check that our mempool alloc size will cover the biggest
	 * command we support.
	 */</span>
	alloc_size <span class="token operator">=</span> <span class="token function">nvme_pci_iod_alloc_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">WARN_ON_ONCE</span><span class="token punctuation">(</span>alloc_size <span class="token operator">&gt;</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

	dev<span class="token operator">-&gt;</span>iod_mempool <span class="token operator">=</span> <span class="token function">mempool_create_node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> mempool_kmalloc<span class="token punctuation">,</span>
						mempool_kfree<span class="token punctuation">,</span>
						<span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> alloc_size<span class="token punctuation">,</span>
						GFP_KERNEL<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dev<span class="token operator">-&gt;</span>iod_mempool<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		result <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
		<span class="token keyword">goto</span> release_pools<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	result <span class="token operator">=</span> <span class="token function">nvme_init_ctrl</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev<span class="token operator">-&gt;</span>ctrl<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nvme_pci_ctrl_ops<span class="token punctuation">,</span>
			quirks<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> release_mempool<span class="token punctuation">;</span>

	<span class="token function">dev_info</span><span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>ctrl<span class="token punctuation">.</span>device<span class="token punctuation">,</span> <span class="token string">"pci function %s\n"</span><span class="token punctuation">,</span> <span class="token function">dev_name</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">nvme_reset_ctrl</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev<span class="token operator">-&gt;</span>ctrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">async_schedule</span><span class="token punctuation">(</span>nvme_async_probe<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>nvme_probe</code> 函数会通过 <code>nvme_dev_map</code> 函数 (层层调用之后) 映射设备的 <code>BAR</code> 空间到内核的虚拟地址空间当中, <code>PCI</code> 协议里规定了 <code>PCI</code> 设备的配置空间里有 <code>6</code> 个 <code>32</code> 位的 <code>BAR</code> 寄存器，代表了 <code>PCI</code> 设备上的一段内存空间，可以通过<code>writel</code>，<code>readl</code> 这类函数直接读写寄存器，并分配设备数据结构 <code>nvme_dev</code>，队列 <code>nvme_queue</code> 等。</p> 
<p><code>nvme_dev</code> 结构体如下，</p> 
<pre><code class="prism language-c"><span class="token comment">/*
 * Represents an NVM Express device.  Each nvme_dev is a PCI function.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">nvme_dev</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">nvme_queue</span> <span class="token operator">*</span>queues<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">blk_mq_tag_set</span> tagset<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">blk_mq_tag_set</span> admin_tagset<span class="token punctuation">;</span>
	u32 __iomem <span class="token operator">*</span>dbs<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">dma_pool</span> <span class="token operator">*</span>prp_page_pool<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">dma_pool</span> <span class="token operator">*</span>prp_small_pool<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> online_queues<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> max_qid<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> io_queues<span class="token punctuation">[</span>HCTX_MAX_TYPES<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> num_vecs<span class="token punctuation">;</span>
	u32 q_depth<span class="token punctuation">;</span>
	<span class="token keyword">int</span> io_sqes<span class="token punctuation">;</span>
	u32 db_stride<span class="token punctuation">;</span>
	<span class="token keyword">void</span> __iomem <span class="token operator">*</span>bar<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> bar_mapped_size<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">work_struct</span> remove_work<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">mutex</span> shutdown_lock<span class="token punctuation">;</span>
	bool subsystem<span class="token punctuation">;</span>
	u64 cmb_size<span class="token punctuation">;</span>
	bool cmb_use_sqes<span class="token punctuation">;</span>
	u32 cmbsz<span class="token punctuation">;</span>
	u32 cmbloc<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">nvme_ctrl</span> ctrl<span class="token punctuation">;</span>
	u32 last_ps<span class="token punctuation">;</span>
	bool hmb<span class="token punctuation">;</span>

	<span class="token class-name">mempool_t</span> <span class="token operator">*</span>iod_mempool<span class="token punctuation">;</span>

	<span class="token comment">/* shadow doorbell buffer support: */</span>
	u32 <span class="token operator">*</span>dbbuf_dbs<span class="token punctuation">;</span>
	<span class="token class-name">dma_addr_t</span> dbbuf_dbs_dma_addr<span class="token punctuation">;</span>
	u32 <span class="token operator">*</span>dbbuf_eis<span class="token punctuation">;</span>
	<span class="token class-name">dma_addr_t</span> dbbuf_eis_dma_addr<span class="token punctuation">;</span>

	<span class="token comment">/* host memory buffer support: */</span>
	u64 host_mem_size<span class="token punctuation">;</span>
	u32 nr_host_mem_descs<span class="token punctuation">;</span>
	<span class="token class-name">dma_addr_t</span> host_mem_descs_dma<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">nvme_host_mem_buf_desc</span> <span class="token operator">*</span>host_mem_descs<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>host_mem_desc_bufs<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_allocated_queues<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_write_queues<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_poll_queues<span class="token punctuation">;</span>

	bool attrs_added<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>每个设备至少两个队列，一个是 <code>admin</code> 管理命令，一个是给 <code>I / O</code> 命令,这个队列概念和之前介绍块驱动中的磁盘队列一个道理，只是那个驱动比较基础，所以命令和IO并不区分队列，<code>nvme_queue</code> 具体结构体如下，</p> 
<pre><code class="prism language-c"><span class="token comment">/*
 * An NVM Express queue.  Each device has at least two (one for admin
 * commands and one for I/O commands).
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">nvme_queue</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">nvme_dev</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span>
	<span class="token class-name">spinlock_t</span> sq_lock<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>sq_cmds<span class="token punctuation">;</span>
	 <span class="token comment">/* only used for poll queues: */</span>
	<span class="token class-name">spinlock_t</span> cq_poll_lock ____cacheline_aligned_in_smp<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">nvme_completion</span> <span class="token operator">*</span>cqes<span class="token punctuation">;</span>
	<span class="token class-name">dma_addr_t</span> sq_dma_addr<span class="token punctuation">;</span>
	<span class="token class-name">dma_addr_t</span> cq_dma_addr<span class="token punctuation">;</span>
	u32 __iomem <span class="token operator">*</span>q_db<span class="token punctuation">;</span>
	u32 q_depth<span class="token punctuation">;</span>
	u16 cq_vector<span class="token punctuation">;</span>
	u16 sq_tail<span class="token punctuation">;</span>
	u16 last_sq_tail<span class="token punctuation">;</span>
	u16 cq_head<span class="token punctuation">;</span>
	u16 qid<span class="token punctuation">;</span>
	u8 cq_phase<span class="token punctuation">;</span>
	u8 sqes<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NVMEQ_ENABLED</span>		<span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NVMEQ_SQ_CMB</span>		<span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NVMEQ_DELETE_ERROR</span>	<span class="token expression"><span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NVMEQ_POLLED</span>		<span class="token expression"><span class="token number">3</span></span></span>
	u32 <span class="token operator">*</span>dbbuf_sq_db<span class="token punctuation">;</span>
	u32 <span class="token operator">*</span>dbbuf_cq_db<span class="token punctuation">;</span>
	u32 <span class="token operator">*</span>dbbuf_sq_ei<span class="token punctuation">;</span>
	u32 <span class="token operator">*</span>dbbuf_cq_ei<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">completion</span> delete_done<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>继续说 <code>nvme_probe</code> 函数，<code>nvme_setup_prp_pools</code> 主要是创建 <code>dma pool</code>，后面可以通过 <code>dma</code> 函数从 <code>dma pool</code> 中获得<code>memory</code>。主要是为了给 <code>4k</code> 和 <code>128k</code> 的不同 <code>IO</code> 来做优化。</p> 
<p><code>nvme_init_ctrl</code> 函数会创建 <code>NVMe</code> 控制器结构体，这样在后后续 <code>probe</code> 阶段时候用初始化过的结构，其传入的操作函数集是 <code>nvme_pci_ctrl_ops</code>，如下所示，</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">nvme_ctrl_ops</span> nvme_pci_ctrl_ops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span>name			<span class="token operator">=</span> <span class="token string">"pcie"</span><span class="token punctuation">,</span>
	<span class="token punctuation">.</span>module			<span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>flags			<span class="token operator">=</span> NVME_F_METADATA_SUPPORTED<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>reg_read32		<span class="token operator">=</span> nvme_pci_reg_read32<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>reg_write32		<span class="token operator">=</span> nvme_pci_reg_write32<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>reg_read64		<span class="token operator">=</span> nvme_pci_reg_read64<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>free_ctrl		<span class="token operator">=</span> nvme_pci_free_ctrl<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>submit_async_event	<span class="token operator">=</span> nvme_pci_submit_async_event<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>get_address		<span class="token operator">=</span> nvme_pci_get_address<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>print_device_info	<span class="token operator">=</span> nvme_pci_print_device_info<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>supports_pci_p2pdma	<span class="token operator">=</span> nvme_pci_supports_pci_p2pdma<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>另外 <code>NVMe</code> 磁盘的操作函数集，例如打开，释放等属于 <code>block_device_operations</code> （ <code>drivers/nvme/host/core.c</code> <sup class="footnote-ref"><a href="#fn5" rel="nofollow" id="fnref5">5</a></sup> )，其结构体如下，</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">block_device_operations</span> nvme_bdev_ops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
   <span class="token punctuation">.</span>owner		<span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
   <span class="token punctuation">.</span>ioctl		<span class="token operator">=</span> nvme_ioctl<span class="token punctuation">,</span>
   <span class="token punctuation">.</span>compat_ioctl	<span class="token operator">=</span> blkdev_compat_ptr_ioctl<span class="token punctuation">,</span>
   <span class="token punctuation">.</span>open		<span class="token operator">=</span> nvme_open<span class="token punctuation">,</span>
   <span class="token punctuation">.</span>release	<span class="token operator">=</span> nvme_release<span class="token punctuation">,</span>
   <span class="token punctuation">.</span>getgeo		<span class="token operator">=</span> nvme_getgeo<span class="token punctuation">,</span>
   <span class="token punctuation">.</span>report_zones	<span class="token operator">=</span> nvme_report_zones<span class="token punctuation">,</span>
   <span class="token punctuation">.</span>pr_ops		<span class="token operator">=</span> <span class="token operator">&amp;</span>nvme_pr_ops<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h2><a id="_NVMe__379"></a>创建 NVMe 块设备</h2> 
<p>参考这里 <sup class="footnote-ref"><a href="#fn3" rel="nofollow" id="fnref3:1">3</a></sup></p> 
<p>对于 <code>Linux</code> 的块设备来说，其主要的是通过调用 <code>device_add_disk</code> 或者 <code>add_disk</code> 函数（后者是对前者的简单包装）在 <code>/dev</code> 目录下创建块设备，来实现向操作系统添加一个设备实例。<br> <code>NVMe</code> 本身也是块设备，自然也不会跳出这个大框架。</p> 
<p><code>NVMe</code> 块设备文件操作集合会在 <code>add_disk</code> 时通过 <code>block_device_operations</code> （ <code>drivers/nvme/host/multipath.c</code> <sup class="footnote-ref"><a href="#fn6" rel="nofollow" id="fnref6">6</a></sup> ) 进行声明，代码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">block_device_operations</span> nvme_ns_head_ops <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span>owner		<span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>submit_bio	<span class="token operator">=</span> nvme_ns_head_submit_bio<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>open		<span class="token operator">=</span> nvme_ns_head_open<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>release	<span class="token operator">=</span> nvme_ns_head_release<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>ioctl		<span class="token operator">=</span> nvme_ns_head_ioctl<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>compat_ioctl	<span class="token operator">=</span> blkdev_compat_ptr_ioctl<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>getgeo		<span class="token operator">=</span> nvme_getgeo<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>report_zones	<span class="token operator">=</span> nvme_ns_head_report_zones<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>pr_ops		<span class="token operator">=</span> <span class="token operator">&amp;</span>nvme_pr_ops<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中 <code>ownder</code> 表示该 <code>nvme_ns_head_ops</code> 的所有者是 <code>NVMe</code> 块设备驱动，而 <code>ioctl</code> 和 <code>compat_ioctl</code> 分别是用户调用 <code>ioctl</code> 的两种方式。</p> 
<p>进入 <code>nvme_ns_head_ioctl</code> （如下所示）接口，</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">nvme_ns_head_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>bdev<span class="token punctuation">,</span> <span class="token class-name">fmode_t</span> mode<span class="token punctuation">,</span>
		<span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">nvme_ns_head</span> <span class="token operator">*</span>head <span class="token operator">=</span> bdev<span class="token operator">-&gt;</span>bd_disk<span class="token operator">-&gt;</span>private_data<span class="token punctuation">;</span>
	<span class="token keyword">void</span> __user <span class="token operator">*</span>argp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">nvme_ns</span> <span class="token operator">*</span>ns<span class="token punctuation">;</span>
	<span class="token keyword">int</span> srcu_idx<span class="token punctuation">,</span> ret <span class="token operator">=</span> <span class="token operator">-</span>EWOULDBLOCK<span class="token punctuation">;</span>

	srcu_idx <span class="token operator">=</span> <span class="token function">srcu_read_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token operator">-&gt;</span>srcu<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ns <span class="token operator">=</span> <span class="token function">nvme_find_path</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ns<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> out_unlock<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * Handle ioctls that apply to the controller instead of the namespace
	 * seperately and drop the ns SRCU reference early.  This avoids a
	 * deadlock when deleting namespaces using the passthrough interface.
	 */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_ctrl_ioctl</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">nvme_ns_head_ctrl_ioctl</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> argp<span class="token punctuation">,</span> head<span class="token punctuation">,</span> srcu_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>

	ret <span class="token operator">=</span> <span class="token function">nvme_ns_ioctl</span><span class="token punctuation">(</span>ns<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> argp<span class="token punctuation">)</span><span class="token punctuation">;</span>
out_unlock<span class="token operator">:</span>
	<span class="token function">srcu_read_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token operator">-&gt;</span>srcu<span class="token punctuation">,</span> srcu_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h3><a id="_434"></a>硬件层面</h3> 
<p>首先从硬件层面上，我们知道任何设备必须通过某个总线与 <code>CPU</code> 向连接，<code>NVMe</code> 则正是通过<code>PCIe</code> 总线与 <code>CPU</code> 相连，如下所示：</p> 
<p><img src="https://images2.imgbox.com/85/51/BJp12Fwz_o.png" alt="在这里插入图片描述" width="400"><br> <br></p> 
<p>当然，目前 <code>NVMe</code> 除了可以通过 <code>PCIe</code> 总线与 <code>CPU</code> 相连外，还可以通过其它通道连接，比如<code>FC</code> 或者 <code>IB</code>。后者则是一种将 <code>NVMe</code> 设备从计算节点独立出来的方式，也就是此时 <code>NVMe</code> 就不再是一个卡设备，而是一个独立机箱的设备。无论何种方式相连接，其本质是一样的。</p> 
<br> 
<h3><a id="_444"></a>软件层面</h3> 
<p>硬件的连通性是基础，当硬件已经连通后，就可以在 <code>Linux</code> 内核层面发现设备，并进行初始化了。<br> 软件层面的初始化有两种情况：</p> 
<ul><li>计算机启动的时候，操作系统会扫描总线上的设备，并完成初始化；</li><li>设备在系统启动后连接的，此时需要手动触发扫描的过程。</li></ul> 
<p>无论是系统启动也好，还是手动触发扫描也好，<code>NVMe</code> 发现设备的核心流程是一样的，如下所示：<br> <img src="https://images2.imgbox.com/a4/51/9wLiAJof_o.png" alt="在这里插入图片描述" width="150"><br> 与其它块设备类似，<code>NVMe</code> 设备初始化完成后会在 <code>/dev</code> 目录下出现一个文件。<code>NVMe</code> 设备会出现一个形如 <code>nvmeXnY</code> 的设备文件。<br> 如下图所示，红色方框中的为一个 <code>NVMe</code> 块设备，</p> 
<p><img src="https://images2.imgbox.com/b3/7e/Jh6MM64p_o.png" alt="在这里插入图片描述" width="400"><br> <br></p> 
<p>上面我们简要的介绍了初始化的主流程。<br> 在上面初始化流程中需要重点关注的是 <code>nvme_alloc_ns</code> 函数的流程。该函数完成了块设备创建基本信息填充和块设备注册到内核等工作。</p> 
<p>在整个初始化流程中比较关键的是对请求队列（ <code>request_queue</code> ）中请求处理函数指针（<code>make_request_fn</code>）的初始化及多队列函数集（ <code>mq_ops</code> ）的初始化。因为，这里的函数正是<code>NVMe</code> 区别于 <code>SCSI</code> 等类型设备数据处理流程的地方。</p> 
<hr> 
<h2><a id="NVMe__IO__465"></a>NVMe 设备的 IO 流程</h2> 
<p>参考这里 <sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1:4">1</a></sup>’ <sup class="footnote-ref"><a href="#fn2" rel="nofollow" id="fnref2:1">2</a></sup></p> 
<p>机械硬盘时代，由于其随机访问性能差，内核开发者主要放在缓存 <code>I / O</code>、合并 <code>I / O</code> 等方面，并没有考虑多队列的设计。<br> 而 <code>Flash</code> 的出现，性能出现了戏剧性的反转，因为单个 <code>CPU</code> 每秒发出 <code>IO</code> 请求数量是有限的，所以促进了 <code>IO</code> 多队列开发。</p> 
<p>驱动中的队列创建，通过函数 <code>kcalloc_node</code> ( <code>drivers/nvme/host/pci.c</code> <sup class="footnote-ref"><a href="#fn4" rel="nofollow" id="fnref4:1">4</a></sup> ) 如下，</p> 
<pre><code class="prism language-c">dev<span class="token operator">-&gt;</span>queues <span class="token operator">=</span> <span class="token function">kcalloc_node</span><span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>nr_allocated_queues<span class="token punctuation">,</span>
			<span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">nvme_queue</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dev<span class="token operator">-&gt;</span>queues<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> free<span class="token punctuation">;</span>
</code></pre> 
<p><code>Queue</code> 有的概念，那就是队列深度,表示其能够放多少个成员。在 <code>NVMe</code> 中，这个队列深度是由 <code>NVMe SSD</code> 决定的，存储在 <code>NVMe</code> 设备的 <code>BAR</code> 空间里。</p> 
<p>队列用来存放 <code>NVMe Command</code>，<code>NVMe Command</code> 是主机与 <code>SSD</code> 控制器交流的基本单元，应用的 <code>I/O</code> 请求也要转化成<code>NVMe Command</code>。</p> 
<p>不过需要注意的是，就算有很多 <code>CPU</code> 发送请求，但是 <code>Block</code> 层并不能保证都能处理完，将来可能要绕过 <code>IO</code> 栈的块层，不然瓶颈就是操作系统本身了。</p> 
<p>当前 <code>Linux</code> 内核提供了 <code>blk_queue_make_request</code> 函数，调用这个函数注册自定义的队列处理方法，可以绕过 <code>IO</code> 调度和 <code>io</code> 队列，从而缩短 <code>io</code> 延时。<code>Block</code> 层收到上层发送的 <code>IO</code> 请求，就会选择该方法处理。</p> 
<p>为了便于理解 <code>NVMe</code> 的处理流程，我们给出了传统 <code>SCSI</code> 及 <code>NVMe</code> 数据处理的对比流程，如下图所示，</p> 
<p><img src="https://images2.imgbox.com/d1/c0/Y6wc49Le_o.png" alt="在这里插入图片描述" width="400"><br> 整个流程是从通用块层的接口（ <code>submit_bio</code> ）开始的。<br> 对于 <code>NVMe</code> 设备来说，在初始化的时候初始化函数指针 <code>make_request_fn</code> 为 <code>nvme_queue_rq</code>，该函数就是 <code>NVMe</code> 驱动程序的请求处理接口。该函数最终会将请求写入 <code>NVMe</code> 中的 <code>SQ</code> 队列当中，并通知控制器处理请求。</p> 
<p>相对于 <code>SCSI</code> 设备来说，<code>NVMe</code> 设备的驱动还是非常简单的。</p> 
<hr> 
<h2><a id="DMA_497"></a>DMA</h2> 
<p>参考这里 <sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1:5">1</a></sup></p> 
<p><code>PCIe</code> 有个寄存器位 <code>Bus Master Enable</code>，这个 <code>bit</code> 置 <code>1</code> 后，<code>PCIe</code> 设备就可以向 <code>Host</code> 发送 <code>DMA Read Memory</code> 和 <code>DMA Write Memory</code> 请求。</p> 
<p>当 <code>Host</code> 的 <code>driver</code> 需要跟 <code>PCIe</code> 设备传输数据的时候，只需要告诉 <code>PCIe</code> 设备存放数据的地址就可以。</p> 
<p><code>NVMe Command</code> 占用 <code>64</code> 个字节，另外其 <code>PCIe BAR</code> 空间被映射到虚拟内存空间（其中包括用来通知 <code>NVMe SSD Controller</code> 读取 <code>Command</code> 的 <code>Doorbell</code> 寄存器）。</p> 
<p><code>NVMe</code> 数据传输都是通过 <code>NVMe Command</code>，而 <code>NVMe Command</code> 则存放在 <code>NVMe Queue</code> 中，其配置如下图，</p> 
<p><img src="https://images2.imgbox.com/73/f1/n8J5eUGU_o.png" alt="在这里插入图片描述" width="500"><br> 其中队列中有 <code>Submission Queue</code>，<code>Completion Queue</code> 两个。</p> 
<hr> 
<h2><a id="_513"></a>参考链接</h2> 
<p>#TODO<br> <a href="https://github.com/andyBrake/andyBrake.github.io/blob/master/doc/nvme.md">nvme驱动分析</a></p> 
<hr class="footnotes-sep"> 
<section class="footnotes"> 
 <ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://developer.aliyun.com/article/596648" rel="nofollow">Linux中nvme驱动详解</a> <a href="#fnref1" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref1:1" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref1:2" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref1:3" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref1:4" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref1:5" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn2" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/72234187" rel="nofollow">NVMe的Linux内核驱动分析</a> <a href="#fnref2" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref2:1" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn3" class="footnote-item"><p><a href="https://blog.csdn.net/wangpeng22/article/details/73930872">linux NVMe驱动总结</a> <a href="#fnref3" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref3:1" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn4" class="footnote-item"><p><a href="https://github.com/torvalds/linux/blob/master/drivers/nvme/host/pci.c">linux/drivers/nvme/host/pci.c</a> <a href="#fnref4" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref4:1" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn5" class="footnote-item"><p><a href="https://github.com/torvalds/linux/blob/master/drivers/nvme/host/core.c">linux/drivers/nvme/host/core.c</a> <a href="#fnref5" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn6" class="footnote-item"><p><a href="https://github.com/torvalds/linux/blob/master/drivers/nvme/host/multipath.c">linux/drivers/nvme/host/multipath.c</a> <a href="#fnref6" rel="nofollow" class="footnote-backref">↩︎</a></p> </li></ol> 
</section>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0a7b98c8e4c4f3869c3b882e933fc008/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux入门级教程（一）。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/38b63ef52089facb40fa2d511428bfad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">抽象类和抽象方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>