<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring—IOC与AOP - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring—IOC与AOP" />
<meta property="og:description" content="一.IOC（Inversion of Control，控制反转）介绍 IOC（控制反转）是一种设计思想，其核心原则是将对象的创建、依赖关系的管理从应用程序代码中抽离出来，交给容器来负责。传统的开发方式中，对象的创建和依赖关系需要由开发者显式地在代码中进行处理，而采用IOC的方式，开发者只需通过配置文件或注解等方式描述对象的创建和依赖关系，容器会根据这些描述信息自动完成对象的创建和依赖注入。这样可以降低代码的耦合性，提高可维护性和可扩展性，使得应用程序更加灵活和易于测试。
实现IOC 1.导入IOC相关的jar包 &lt;dependencies&gt; &lt;!-- Spring Core：包含IOC容器的核心功能 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.3.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Context：提供了应用程序上下文（ApplicationContext）的支持，包含了IOC容器的实现 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; spring-core：包含IOC容器的核心功能，提供了基础的依赖注入（DI）机制。spring-context：提供了应用程序上下文（ApplicationContext）的支持，是Spring IOC容器的具体实现。 2.创建 User_DemoMapper接口和对应的User_DemoMapperImpl实现类 public interface User_DemoMapper { public void show(); } public class User_DemoMapperImpl implements User_DemoMapper{ @Override public void show() { System.out.println(&#34;诸葛亮：我从未见过如此厚颜无耻之人&#34;); } } 3.编写Spring容器，applicationContext.xml文件进行配置 依赖注入 &lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xmlns:aop=&#34;http://www.springframework.org/schema/aop&#34; xsi:schemaLocation=&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&#34;&gt; &lt;!-- 这里是配置内容 --&gt; &lt;bean id=&#34;user_demo&#34; class=&#34;com.cskt.poji.User_Demo&#34;&gt; &lt;property name=&#34;name&#34; value=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a66f03e202d9149348fb42d6d42ba511/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-21T23:34:22+08:00" />
<meta property="article:modified_time" content="2023-08-21T23:34:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring—IOC与AOP</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.IOC（Inversion of Control，控制反转）介绍</h2> 
<p>        IOC（控制反转）是一种设计思想，其核心原则是将对象的创建、依赖关系的管理从应用程序代码中抽离出来，交给容器来负责。传统的开发方式中，对象的创建和依赖关系需要由开发者显式地在代码中进行处理，而采用IOC的方式，开发者只需通过配置文件或注解等方式描述对象的创建和依赖关系，容器会根据这些描述信息自动完成对象的创建和依赖注入。<span style="color:#fe2c24;">这样可以降低代码的耦合性，提高可维护性和可扩展性，使得应用程序更加灵活和易于测试。</span></p> 
<p></p> 
<h3>实现IOC</h3> 
<h3>        1.导入IOC相关的jar包</h3> 
<pre><code>&lt;dependencies&gt;
    &lt;!-- Spring Core：包含IOC容器的核心功能 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;5.3.10&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Spring Context：提供了应用程序上下文（ApplicationContext）的支持，包含了IOC容器的实现 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.3.10&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre> 
<blockquote> 
 <ul><li><code>spring-core</code>：包含IOC容器的核心功能，提供了基础的依赖注入（DI）机制。</li><li><code>spring-context</code>：提供了应用程序上下文（ApplicationContext）的支持，是Spring IOC容器的具体实现。 </li></ul> 
</blockquote> 
<h4>        2.创建 User_DemoMapper接口和对应的User_DemoMapperImpl实现类</h4> 
<pre><code>public interface User_DemoMapper {
    public void show();
}



public class User_DemoMapperImpl implements User_DemoMapper{

    @Override
    public void show() {
        System.out.println("诸葛亮：我从未见过如此厚颜无耻之人");
    }
}
</code></pre> 
<h4>        3.编写Spring容器，applicationContext.xml文件进行配置 依赖注入</h4> 
<pre><code>&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop                                 
        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;
    &lt;!-- 这里是配置内容 --&gt;

    &lt;bean id="user_demo" class="com.cskt.poji.User_Demo"&gt;
        &lt;property name="name" value="猪脚亮说："&gt;&lt;/property&gt;
        &lt;property name="word" value="我从未见过如此厚颜无耻之人"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="userMapper" class="com.cskt.mapper.User_DemoMapperImpl"&gt;&lt;/bean&gt;

    &lt;bean id="userService" class="com.cskt.service.User_DemoServiceImpl"&gt;
        &lt;property name="user_demoMapper" ref="userMapper"&gt;&lt;/property&gt;
         &lt;!--property标签表示配置当前bean的属性
        name属性表示配置哪一个具体的属性
        ref属性表示参照哪一个bean
        value属性表示赋值--&gt;

    &lt;/bean&gt;
&lt;/beans&gt;</code></pre> 
<h4>        4.编写一个测试类来使用Spring容器获取Bean并调用方法</h4> 
<pre><code>public class testUser {

    @Test
    public void testUser_Demo(){
        ApplicationContext act=new ClassPathXmlApplicationContext("applicationContext.xml");
        User_Demo user_demo=(User_Demo) act.getBean("user_demo");
        System.out.println(user_demo.getName()+user_demo.getWord());
    }
}</code></pre> 
<h4 style="background-color:transparent;">        5.运行结果 </h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/eb/c2/EKnhIIfU_o.png"></p> 
<p> </p> 
<p></p> 
<h2>二. AOP(Aspect-Oriented Programming，面向切面编程)介绍</h2> 
<p>        AOP（面向切面编程）是一种编程思想，它的目的是将与核心业务逻辑无关的功能（例如日志记录、事务管理、权限控制等）从主要业务逻辑中分离出来，以便实现模块化和复用。在AOP中，通过定义切面（Aspect）和通知（Advice），可以在程序运行过程中自动地插入额外的行为。切面定义了在何处以及何时应用通知，通知则定义了具体的额外行为，可以包括在目标方法执行前、执行后或发生异常时执行的操作。<span style="color:#fe2c24;">AOP的好处是能够降低代码的重复性，提高代码的可维护性和可扩展性，使得关注点分离更加清晰。</span></p> 
<p></p> 
<h3>实现AOP</h3> 
<h4>        1.导入IOC相关的jar包</h4> 
<pre><code>&lt;dependencies&gt;
    &lt;!-- Spring AOP：包含AOP相关的功能和类库 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
        &lt;version&gt;5.3.10&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- AspectJ Weaver：AspectJ的编织器，用于在运行时织入切面 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.9.7&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre> 
<blockquote> 
 <p>                </p> 
 <ul><li><code>spring-aop</code>：包含了Spring框架的AOP相关功能和类库。</li><li><code>aspectjweaver</code>：AspectJ的编织器，用于在运行时织入切面。</li></ul> 
</blockquote> 
<h4>         2.定义一个切面类，用于在目标方法执行前后添加额外的行为</h4> 
<pre><code>package com.cskt.aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;

@Aspect
public class MyAspect {
    //前置增强  方法前面 执行  后置增强  环绕增强  异常增强  最终增强
    //切面 Aspect  Advice  beforeAdvice pointCut
    // 给那个方法增强 。。。。。，
   @Before("execution( * com.cskt.service..*.*(..))")
   public void before(){
       System.out.println("前置通知.... 在方法之前要執行的公共代码放在这里");
   }
    /**
     * 后置通知
     * returnVal,切点方法执行后的返回值
     */
    @AfterReturning(value="execution(* com.cskt.service..*.*(..)))",returning = "returnVal")
    public void AfterReturning(Object returnVal){
        System.out.println("后置通知...."+returnVal
        );
    }

    /**
     * 环绕通知
     * @param joinPoint 可用于执行切点的类
     *                  具体什么业务
     * @return
     * @throws Throwable
     */
    @Around("execution(* com.cskt.service..*.*(..))")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("环绕通知前....");

        Object obj= (Object) joinPoint.proceed();

        System.out.println("环绕通知后....");
        return obj;
    }
    /**
     * 抛出通知
     * @param e
     */
    @AfterThrowing(value="execution(* com.cskt.service..*.*(..))",throwing = "e")
    public void afterThrowable(Throwable e){
        System.out.println("出现异常:msg="+e.getMessage());
    }

    /**
     * 无论什么情况下都会执行的方法
     */
    @After(value="execution(* com.cskt.service..*.*(..))")
    public void after(){
        //方法的对象的关闭
        //方法的回滚
        System.out.println("最终通知....");
    }
}
</code></pre> 
<h4>        3.编写Spring容器，applicationContext.xml文件进行配置</h4> 
<pre><code>&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;
    
       &lt;bean id="myAspect" class="com.cskt.aspect.MyAspect"/&gt;
       &lt;aop:aspectj-autoproxy/&gt;
&lt;/beans&gt;
</code></pre> 
<h4 style="background-color:transparent;">        4.编写一个测试类来验证AOP的效果</h4> 
<pre><code> @Test
    public void tsetUserShow(){
        ApplicationContext apt=new ClassPathXmlApplicationContext("applicationContext.xml");
        User_DemoService userservice=(User_DemoService) apt.getBean("userService");
        userservice.show();
    }</code></pre> 
<p>        5.运行结果</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/28/4c/aKbXuV9v_o.png"></p> 
<p><span style="color:#4da8ee;"><strong>        </strong></span></p> 
<p><span style="color:#4da8ee;"><strong>        综上所述，IOC和AOP是Spring框架中两个重要的概念。IOC通过控制反转实现对象的解耦和依赖注入，AOP通过面向切面编程实现横切关注点的模块化和复用。它们的应用可以提高代码的可维护性、可测试性和可扩展性，使开发变得更加灵活和高效。</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68dfc083f65f4a92f2d9271f559bde19/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Stable Diffusion 原理介绍与源码分析（二、DDPM、DDIM、PLMS算法分析）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d667ee31953a8e4d5b653dec4e6dfeb8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">本科双非CS，计算机985 CS，投的IC，记录一下</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>