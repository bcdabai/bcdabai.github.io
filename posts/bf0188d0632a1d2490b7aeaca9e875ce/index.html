<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用Spring Boot Admin实现运维监控平台 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用Spring Boot Admin实现运维监控平台" />
<meta property="og:description" content="简介： 我们知道，使用Actuator可以收集应用系统的健康状态、内存、线程、堆栈、配置等信息，比较全面地监控了Spring Boot应用的整个生命周期。但是还有一个问题：如何呈现这些采集到的应用监控数据、性能数据呢？在这样的背景下，就诞生了另一个开源软件Spring Boot Admin。下面就来介绍什么是Spring Boot Admin以及如何使用Spring Boot Admin搭建完整的运维监控平台。 我们知道，使用Actuator可以收集应用系统的健康状态、内存、线程、堆栈、配置等信息，比较全面地监控了Spring Boot应用的整个生命周期。但是还有一个问题：如何呈现这些采集到的应用监控数据、性能数据呢？在这样的背景下，就诞生了另一个开源软件Spring Boot Admin。下面就来介绍什么是Spring Boot Admin以及如何使用Spring Boot Admin搭建完整的运维监控平台。
一、什么是Spring Boot Admin Spring Boot Admin是一个管理和监控Spring Boot应用程序的开源项目，在对单一应用服务监控的同时也提供了集群监控方案，支持通过eureka、consul、zookeeper等注册中心的方式实现多服务监控与管理。Spring Boot Admin UI部分使用Vue JS将数据展示在前端。
Spring Boot Admin分为服务端（spring-boot-admin-server）和客户端（spring-boot-admin-client）两个组件：
spring-boot-admin-server通过采集actuator端点数据显示在spring-boot-admin-ui上，已知的端点几乎都有进行采集。spring-boot-admin-client是对Actuator的封装，提供应用系统的性能监控数据。此外，还可以通过spring-boot-admin动态切换日志级别、导出日志、导出heapdump、监控各项性能指标等。 Spring Boot Admin服务器端负责收集各个客户的数据。各台客户端配置服务器地址，启动后注册到服务器。服务器不停地请求客户端的信息（通过Actuator接口）。具体架构如下图所示。
上图为Spring Boot Admin的整体架构，在每个Spring Boot应用程序上增加Spring Boot Admin Client组件。这样每个Spring Boot应用即Admin客户端，Admin服务端通过请求Admin客户端的接口收集所有的Spring Boot应用信息并进行数据呈现，从而实现Spring Boot应用监控。
二、使用Spring Boot Admin搭建运维监控平台 下面就通过示例，演示如何使用Spring Boot Admin 搭建运维监控平台。
1、创建服务器端 Spring Boot Admin服务器端主要负责收集各个客户的数据。建立一个Spring Boot Admin服务器端只需要简单的两步。下面通过示例演示创建Spring Boot Admin服务器端的过程。
1. 配置依赖
创建新的Spring Boot项目，在新建的项目中添加Spring Boot Admin服务器端的依赖JAR包：spring-boot-admin-starter-server。
&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;version&gt;2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bf0188d0632a1d2490b7aeaca9e875ce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-24T11:01:01+08:00" />
<meta property="article:modified_time" content="2022-01-24T11:01:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用Spring Boot Admin实现运维监控平台</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>简介：</strong> 我们知道，使用Actuator可以收集应用系统的健康状态、内存、线程、堆栈、配置等信息，比较全面地监控了Spring Boot应用的整个生命周期。但是还有一个问题：如何呈现这些采集到的应用监控数据、性能数据呢？在这样的背景下，就诞生了另一个开源软件Spring Boot Admin。下面就来介绍什么是Spring Boot Admin以及如何使用Spring Boot Admin搭建完整的运维监控平台。</h2> 
<p>我们知道，使用Actuator可以收集应用系统的健康状态、内存、线程、堆栈、配置等信息，比较全面地监控了Spring Boot应用的整个生命周期。但是还有一个问题：如何呈现这些采集到的应用监控数据、性能数据呢？在这样的背景下，就诞生了另一个开源软件Spring Boot Admin。下面就来介绍什么是Spring Boot Admin以及如何使用Spring Boot Admin搭建完整的运维监控平台。</p> 
<h3 id="slide-0">一、什么是Spring Boot Admin</h3> 
<p>Spring Boot Admin是一个管理和监控Spring Boot应用程序的开源项目，在对单一应用服务监控的同时也提供了集群监控方案，支持通过eureka、consul、zookeeper等注册中心的方式实现多服务监控与管理。Spring Boot Admin UI部分使用Vue JS将数据展示在前端。</p> 
<p>Spring Boot Admin分为服务端（spring-boot-admin-server）和客户端（spring-boot-admin-client）两个组件：</p> 
<ul><li>spring-boot-admin-server通过采集actuator端点数据显示在spring-boot-admin-ui上，已知的端点几乎都有进行采集。</li><li>spring-boot-admin-client是对Actuator的封装，提供应用系统的性能监控数据。此外，还可以通过spring-boot-admin动态切换日志级别、导出日志、导出heapdump、监控各项性能指标等。</li></ul> 
<p>Spring Boot Admin服务器端负责收集各个客户的数据。各台客户端配置服务器地址，启动后注册到服务器。服务器不停地请求客户端的信息（通过Actuator接口）。具体架构如下图所示。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e6/80/a9RRBiiC_o.png"></p> 
<p>上图为Spring Boot Admin的整体架构，在每个Spring Boot应用程序上增加Spring Boot Admin Client组件。这样每个Spring Boot应用即Admin客户端，Admin服务端通过请求Admin客户端的接口收集所有的Spring Boot应用信息并进行数据呈现，从而实现Spring Boot应用监控。</p> 
<p></p> 
<h3 id="slide-1">二、使用Spring Boot Admin搭建运维监控平台</h3> 
<p>下面就通过示例，演示如何使用Spring Boot Admin 搭建运维监控平台。</p> 
<h4 id="slide-2">1、创建服务器端</h4> 
<p>Spring Boot Admin服务器端主要负责收集各个客户的数据。建立一个Spring Boot Admin服务器端只需要简单的两步。下面通过示例演示创建Spring Boot Admin服务器端的过程。</p> 
<p>1. 配置依赖</p> 
<p>创建新的Spring Boot项目，在新建的项目中添加Spring Boot Admin服务器端的依赖JAR包：spring-boot-admin-starter-server。</p> 
<pre>&lt;dependency&gt;
   &lt;groupId&gt;de.codecentric&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;
   &lt;version&gt;2.1.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</pre> 
<p>添加spring-boot-starter-web是为了让应用处于启动状态。</p> 
<p></p> 
<p>2. 配置启动端口</p> 
<p>修改系统配置文件application.properties，配置服务端的启动端口为8000：</p> 
<pre>server.port=8000</pre> 
<p></p> 
<p>3. 启用Admin服务器</p> 
<p>使用@EnableAdminServer注解启动Admin服务器，示例代码如下：</p> 
<pre>@SpringBootApplication
// 启用Admin服务器
@EnableAdminServer
public class AdminServerApplication {
    public static void main(String[] args) {
       SpringApplication.run(AdminServerApplication.class, args);
    }
}</pre> 
<p></p> 
<p>4. 运行测试</p> 
<p>完成以上3步之后，启动服务器端，在浏览器中访问http://localhost:8000，可以看到如下所示的界面。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/75/b3/iChIJktK_o.png"></p> 
<p></p> 
<p>从Admin服务端的启动界面可以看到，Applications页面会展示应用数量、实例数量和状态3个信息。这里由于没有启动客户端，因此显示出“No applications registered.”的信息。</p> 
<p></p> 
<h4 id="slide-3">2、创建客户端</h4> 
<p>接下来我们创建一个客户端并注册到服务器端。</p> 
<p>1. 配置依赖</p> 
<p>创建新的Spring Boot项目，在新建的项目中添加Spring Boot Admin客户端的依赖JAR包：spring-boot-admin-starter-server。</p> 
<pre>&lt;dependency&gt;
    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</pre> 
<p>spring-boot-admin-starter-client会自动添加Actuator相关依赖，所以这里不需要重复添加Actuator的相关依赖。</p> 
<p></p> 
<p>2. 配置客户端</p> 
<p>修改application.properties配置文件，增加如下配置：</p> 
<pre>server.port=8001
spring.application.name=Admin Client
spring.boot.admin.client.url=http://localhost:8000
management.endpoints.web.exposure.include=*</pre> 
<p>相关配置说明如下：</p> 
<ul><li>server.port：当前应用设置端口为8001。</li><li>spring.application.name：设置Application名称，其默认名称都是spring-boot-application。</li><li>spring.boot.admin.client.url：配置Admin服务器的地址。</li><li>management.endpoints.web.exposure.include=*：打开客户端Actuator的监控。</li></ul> 
<p></p> 
<p>3. 运行验证</p> 
<p>配置完成后启动客户端，客户端会自动注册到Admin服务器，Admin服务器检查到客户端的变化并展示其应用信息。重新刷新地址http://localhost:8000后，可以看到如图15-7所示的页面。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f4/ad/A1O2022v_o.png"></p> 
<p>客户端启动之后，Admin服务器界面的Application数量会增加。单击Application下的数值可以查看完整的应用信息。页面会展示被监控的应用列表，单击应用名称会进入此应用的详细监控信息页面。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/41/0b/VV99cyAG_o.png"></p> 
<p></p> 
<p>这个页面会实时显示应用的运行监控信息，包括之前介绍的Actuator所有的端点数据信息。</p> 
<p>Spring Boot Admin以图形化的形式展示了应用的各项信息，这些信息大多来自于Spring Boot Actuator提供的接口。利用图形化的形式很容易看到应用的各项参数变化，甚至有些页面还可以进行一些配置操作，比如改变打印日志的级别等。</p> 
<p></p> 
<h3 id="slide-4">三、告警提醒功能</h3> 
<p>虽然Spring Boot Admin提供了强大的监控功能，但它不能存储历史数据，我们不可能一直盯着系统，为此，Spring Boot Admin提供了强大的提醒功能，能够在发生服务状态变更的时候发出告警。支持的Email等提醒功能，同时也支持自定义告警提醒。</p> 
<p>下面就来介绍Spring Boot Admin的告警提醒功能。</p> 
<h4 id="slide-5">1、邮件提醒</h4> 
<p>设置Spring Boot Admin的邮件提醒，需要用到Spring Boot的邮件组件：spring-boot-starter-mail。这里只展示邮件提醒功能的使用。</p> 
<ol><li>配置依赖</li></ol> 
<p>修改前面的服务器端，在pom.xml 文件中，增加邮件组件，示例代码如下：</p> 
<pre>        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
        &lt;/dependency&gt;</pre> 
<ol><li>修改系统配置</li></ol> 
<p>修改application.properties 系统配置文件，增加邮件发送配置，和告警通知配置，示例代码如下：</p> 
<pre># 邮件服务配置
spring.mail.host=smtp.163.com
spring.mail.username=18618243664@163.com
spring.mail.password=#邮箱授权码 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.ssl.enable=true

#告警接收
spring.boot.admin.notify.mail.enabled=true
spring.boot.admin.notify.mail.to=417114764@qq.com
spring.boot.admin.notify.mail.from=18618243664@163.com</pre> 
<p>上面，我们配置了Spring Boot 发送邮件的相关配置，这个是通用的。然后配置了告警消息的接收地址。</p> 
<p></p> 
<ol><li>验证测试</li></ol> 
<p>我们再次启动服务端和客户端，然后停止客户端，模拟应用宕机的情况。这样Spring Boot Admin 就会发送告警邮件提醒。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/51/7f/3w7u4kKN_o.png"></p> 
<h4 id="slide-6">2、自定义告警提醒</h4> 
<p>除了邮件提醒之外，通常我们还需要其他的提醒方式，比如：短信，日志等。我们可以通过自定义的方式实现自定义的消息告警方式。</p> 
<p>Spring Boot Admin 实现自定义告警提醒也非常简单，只要实现Notifier接口即可。具体实现方式：继承AbstractEventNotifier 或AbstractStatusChangeNotifier这两个类。然后重写doNotify中实现具体的业务逻辑。</p> 
<p>下面通过示例演示自定义告警提醒功能：</p> 
<p>首先，创建AppStatusNotifier类，实现告警提醒功能，示例代码如下：</p> 
<pre>**
 * 自定义的事件通知者
 * @author weiz
 *
 */
@Service
public class AppStatusNotifier extends AbstractEventNotifier {
    private static final Logger LOGGER = LoggerFactory.getLogger(LoggingNotifier.class);

    public AppStatusNotifier(InstanceRepository repository) {
        super(repository);
    }

    @Override
    protected Mono&lt;Void&gt; doNotify(InstanceEvent event, Instance instance) {
        return Mono.fromRunnable(() -&gt; {
            if (event instanceof InstanceStatusChangedEvent) {
                LOGGER.info("Instance {} ({}) is {}", instance.getRegistration().getName(), event.getInstance(),
                        ((InstanceStatusChangedEvent) event).getStatusInfo().getStatus());
            }
            else {
                LOGGER.info("Instance {} ({}) {}", instance.getRegistration().getName(), event.getInstance(),
                        event.getType());
            }
        });
    }
}</pre> 
<p>然后，再次运行服务端和客户端。启动成功之后，再关掉客户端，模拟应用宕机的情况。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/12/48/0lRislfc_o.png"></p> 
<p>我们看到服务端后台日志显示，服务端已经收到了客户端状态改变的告警消息。客户端状态已经变为OFFLINE。</p> 
<p></p> 
<h3 id="slide-7">最后</h3> 
<p>以上，就将Spring Boot Admin搭建运维监控平台介绍完毕，</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/283c0223e36d40f18ba916aeb2d1b326/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">koa2中使用http-proxy-middleware和koa-bodyparser</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09b5ea011a04dc2babd84ccd44f53ae1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Nginx报错404</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>