<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第四章 基本C#特性 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第四章 基本C#特性" />
<meta property="og:description" content="第四章 基本C#特性 本章我将讨论一些在web应用开发中用到, 但会造成迷惑的C#特性. 但这不是介绍C#, 所以我仅仅为每个特性提供一个简单的例子, 以便你能够看懂本书后面的代码, 以及在自己的项目中应用. 下面的表格概括了这一章节. (主要是因为不熟悉C#语言或C#新版本的语法糖, 比如转行的某语言程序员….后面又臭又长又啰嗦的手把手教学懒得翻译了, 直接提关键点)
| - | - | | 问题 | 解决方案 | | 避免访问空引用的属性 | 空条件操作符 | 简化C#属性 | 自动属性 | 简化字符串拼接 | 内插字符串 | 在一步中创建对象并为属性赋值 | 对象或集合初始化器 | 测试一个对象的类型或特征 | 模式匹配 | 向无法更改的类中添加函数 | 扩展属性 | 简化委托和单语句方法 | lambda表达式 | 使用不明确的类型 | var关键字 | 创建对象而不定义类型 | 匿名类 | 简化异步方法 | async和await关键字 | 获取类方法或熟悉的名字而不定义字符串 | nameof表达式
准备示例项目 创建一个名为LanguageFeatures的项目, 使用ASP.NET COre Web Application模板, 创建一个空项目." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/35b5611a8868ced17fadc7241905d9f2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-15T15:53:33+08:00" />
<meta property="article:modified_time" content="2018-07-15T15:53:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第四章 基本C#特性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="第四章-基本c特性">第四章 基本C#特性</h2> 
<p>本章我将讨论一些在web应用开发中用到, 但会造成迷惑的C#特性. 但这不是介绍C#, 所以我仅仅为每个特性提供一个简单的例子, 以便你能够看懂本书后面的代码, 以及在自己的项目中应用. 下面的表格概括了这一章节. <br> (主要是因为不熟悉C#语言或C#新版本的语法糖, 比如转行的某语言程序员….后面又臭又长又啰嗦的手把手教学懒得翻译了, 直接提关键点)</p> 
<p>| - | - | <br> | 问题 | 解决方案 | <br> | 避免访问空引用的属性 | 空条件操作符 <br> | 简化C#属性 | 自动属性 <br> | 简化字符串拼接 | 内插字符串 <br> | 在一步中创建对象并为属性赋值 | 对象或集合初始化器 <br> | 测试一个对象的类型或特征 | 模式匹配 <br> | 向无法更改的类中添加函数 | 扩展属性 <br> | 简化委托和单语句方法 | lambda表达式 <br> | 使用不明确的类型 | var关键字 <br> | 创建对象而不定义类型 | 匿名类 <br> | 简化异步方法 | async和await关键字 <br> | 获取类方法或熟悉的名字而不定义字符串 | nameof表达式</p> 
<h3 id="准备示例项目">准备示例项目</h3> 
<p>创建一个名为<code>LanguageFeatures</code>的项目, 使用<code>ASP.NET COre Web Application</code>模板, 创建一个空项目.</p> 
<h4 id="启用aspnet-core-mvc">启用ASP.NET Core MVC</h4> 
<p>因为创建了一个空项目, 所以需要手动启用MVC支持</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-comment">// StartUp.cs</span>

<span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> System.Linq;
<span class="hljs-keyword">using</span> System.Threading.Tasks;
<span class="hljs-keyword">using</span> Microsoft.AspNetCore.Builder;
<span class="hljs-keyword">using</span> Microsoft.AspNetCore.Hosting;
<span class="hljs-keyword">using</span> Microsoft.AspNetCore.Http;
<span class="hljs-keyword">using</span> Microsoft.Extensions.DependencyInjection;

namespace LanguageFeatures
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Startup
    {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureServices</span>(IServiceCollection services)
        {
            services.AddMvc();
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Configure</span>(IApplicationBuilder app, IHostingEnvironment env)
        {
            <span class="hljs-keyword">if</span> (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            <span class="hljs-comment">//app.Run(async (context) =&gt;</span>
            <span class="hljs-comment">//{<!-- --></span>
            <span class="hljs-comment">//    await context.Response.WriteAsync("Hello World!");</span>
            <span class="hljs-comment">//});</span>
            app.UseMvcWithDefaultRoute();
        }
    }
}</code></pre> 
<p>我将在第十四章中介绍如何配置MVC应用程序, 但添加此处的两个语句就可以完成使用基本配置和约定的MVC框架.</p> 
<h4 id="创建mvc应用组件">创建MVC应用组件</h4> 
<p>MVC创建好后, 我将添加展示重要C#语言特性的MVC应用组件.</p> 
<h5 id="创建模型">创建模型</h5> 
<p>首先要创建一个简单的模型类来存储数据, 于是添加了<code>Models</code>文件夹, 并创建了一个类<code>Product.cs</code>:</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-comment">// Models\Product.cs</span>

namespace LanguageFeatures.Models {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Product {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">decimal</span>? Price { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Product[] <span class="hljs-title">GetProducts</span>() {
            Product kayak = <span class="hljs-keyword">new</span> Product {
                Name = <span class="hljs-string">"Kayak"</span>, Price = <span class="hljs-number">275</span>M
            };
            Product lifejacket = <span class="hljs-keyword">new</span> Product {
                Name = <span class="hljs-string">"Lifejacket"</span>, Price = <span class="hljs-number">48.95</span>M
            };
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product[] { kayak, lifejacket, <span class="hljs-keyword">null</span> };
        }
    }
}</code></pre> 
<p><code>GetProducts</code>数组包含一个<code>null</code>, 我稍后将用来说明一下有用的语言特性.</p> 
<h5 id="创建控制器和视图">创建控制器和视图</h5> 
<p>创建一个文件夹<code>Controllers</code>, 以及控制器类<code>HomeController.cs</code>, 在默认的MVC配置中, <code>Home</code>控制器是MVC默认发送请求的地方.</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-comment">// Controllers\HomeController.cs</span>

<span class="hljs-keyword">using</span> Microsoft.AspNetCore.Mvc;

namespace LanguageFeatures.Controllers {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> HomeController : Controller {
        <span class="hljs-keyword">public</span> ViewResult <span class="hljs-title">Index</span>() {
            <span class="hljs-keyword">return</span> View(<span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span>[] { <span class="hljs-string">"C#"</span>, <span class="hljs-string">"Language"</span>, <span class="hljs-string">"Features"</span> });
        }
    }
}</code></pre> 
<p><code>Index</code>行为渲染默认视图, 并传递一个字符串数组. 添加<code>Views/Home</code>文件夹, 并创建<code>Index.cshtml</code>文件.</p> 
<pre class="prettyprint"><code class="language-html hljs ">@model IEnumerable<span class="hljs-tag">&lt;<span class="hljs-title">string</span>&gt;</span>
@{ Layout = null; }

<span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"viewport"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"width=device-width"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Language Features<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
        @foreach (string s in Model) {
            <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>@s<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
        }
    <span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre> 
<p>运行后将在浏览器中看到如下输出:</p> 
<pre class="prettyprint"><code class="language-txt hljs mathematica"><span class="hljs-keyword">C</span>#
<span class="hljs-keyword">Language</span>
Features</code></pre> 
<h3 id="使用空条件操作符">使用空条件操作符</h3> 
<p>空条件运算符可以更优雅地检测空值. 在MVC开发中, 要确定一个请求是否包含一个特定的头或值, 或者模型是否包含一个特定的数据项时, 可能会有很多检查空值的工作. 通常处理null需要进行显式检查, 当必须检查对象及其属性时, 这会变得冗长且容易出错. 要确保不出错, 就要判断大量的<code>NullReferenceException</code>, 空条件运算符使这个过程更简洁.</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-comment">// Controllers\HomeController.cs</span>

<span class="hljs-keyword">using</span> Microsoft.AspNetCore.Mvc;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> LanguageFeatures.Models;

namespace LanguageFeatures.Controllers {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> HomeController : Controller {
        <span class="hljs-keyword">public</span> ViewResult <span class="hljs-title">Index</span>() {
            List&lt;<span class="hljs-keyword">string</span>&gt; results = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;();
            <span class="hljs-keyword">foreach</span> (Product p <span class="hljs-keyword">in</span> Product.GetProducts()) {
                <span class="hljs-keyword">string</span> name = p?.Name;
                <span class="hljs-keyword">decimal</span>? price = p?.Price;
                results.Add(<span class="hljs-keyword">string</span>.Format(<span class="hljs-string">"Name: {0}, Price: {1}"</span>, name, price));
            }
            <span class="hljs-keyword">return</span> View(results);
        }
    }
}</code></pre> 
<p>想得到<code>Product</code>对象的<code>Name</code>和<code>Value</code>值, 并在视图中显示. 问题是既不知道集合中的对象是否为null, 也不知道对象的属性是否为null, 所以使用了空条件操作符, 像这样:</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs">    <span class="hljs-keyword">string</span> name = p?.Name;
    <span class="hljs-keyword">decimal</span>? price = p?.Price;</code></pre> 
<p>空条件操作符是一个问号(<code>?</code>), 如果<code>p is null</code>, <code>name</code>也会被设置为<code>null</code>, 否则<code>name</code>会被设置为<code>Person.Name</code>. 另外空条件操作符必须跟在可空类型后使用, 所以使用<code>decimal?</code>类型.</p> 
<h4 id="空条件操作符链">空条件操作符链</h4> 
<p>空条件操作符可以在在对象层次中迭代, 这是让它真正成为简化代码并安全导航的有效工具的因素. 向<code>Product</code>类中添加一个属性, 创造一个更复杂的对象层次结构</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-comment">// Models\Product.cs</span>

namespace LanguageFeatures.Models
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Product
    {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">decimal</span>? Price { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
        <span class="hljs-keyword">public</span> Product Related { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Product[] <span class="hljs-title">GetProducts</span>()
        {
            Product kayak = <span class="hljs-keyword">new</span> Product
            {
                Name = <span class="hljs-string">"Kayak"</span>,
                Price = <span class="hljs-number">275</span>M
            };
            Product lifejacket = <span class="hljs-keyword">new</span> Product
            {
                Name = <span class="hljs-string">"Lifejacket"</span>,
                Price = <span class="hljs-number">48.95</span>M
            };

            kayak.Related = lifejacket;

            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product[] { kayak, lifejacket, <span class="hljs-keyword">null</span> };
        }
    }
}</code></pre> 
<p>向<code>Product</code>中添加了一个<code>Related</code>属性, 指向一个<code>Product</code>对象.</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-comment">// Controllers\HomeController.cs</span>

<span class="hljs-keyword">using</span> Microsoft.AspNetCore.Mvc;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> LanguageFeatures.Models;

namespace LanguageFeatures.Controllers
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> HomeController : Controller
    {
        <span class="hljs-keyword">public</span> ViewResult <span class="hljs-title">Index</span>()
        {
            List&lt;<span class="hljs-keyword">string</span>&gt; results = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;();
            <span class="hljs-keyword">foreach</span> (Product p <span class="hljs-keyword">in</span> Product.GetProducts())
            {
                <span class="hljs-keyword">string</span> name = p?.Name;
                <span class="hljs-keyword">decimal</span>? price = p?.Price;
                <span class="hljs-keyword">string</span> relatedName = p?.Related?.Name;
                results.Add(<span class="hljs-keyword">string</span>.Format(<span class="hljs-string">"Name: {0}, Price: {1}, Related: {2}"</span>, name, price, relatedName));
            }
            <span class="hljs-keyword">return</span> View(results);
        }
    }
}</code></pre> 
<p>建立了这样的空条件操作符链:</p> 
<pre class="prettyprint"><code class="language-csharp hljs avrasm">string relatedName = p?<span class="hljs-preprocessor">.Related</span>?<span class="hljs-preprocessor">.Name</span><span class="hljs-comment">;</span></code></pre> 
<p>输出结果为</p> 
<pre class="prettyprint"><code class="language-txt hljs http"><span class="hljs-attribute">Name</span>: <span class="hljs-string">Kayak, Price: 275, Related: Lifejacket</span>
<span class="hljs-attribute">Name</span>: <span class="hljs-string">Lifejacket, Price: 48.95, Related:</span>
<span class="hljs-attribute">Name</span>: <span class="hljs-string">, Price: , Related:</span></code></pre> 
<h4 id="组合空条件操作符和空合操作符">组合空条件操作符和空合操作符</h4> 
<p>空合操作符是两个问号(<code>??</code>)</p> 
<pre class="prettyprint"><code class="language-csharp hljs fix"><span class="hljs-attribute">var output </span>=<span class="hljs-string"> input ?? defalutValue;</span></code></pre> 
<p>如上, 若<code>input is null</code>, 则<code>output == input</code>, 否则<code>output == defaultValue</code>, 即为不可空的值’output`指定一个替换null的默认值. <br> 组合起来</p> 
<pre class="prettyprint"><code class="language-csharp hljs avrasm">// Controllers\HomeController<span class="hljs-preprocessor">.cs</span>

string name = p?<span class="hljs-preprocessor">.Name</span> ?? <span class="hljs-string">"&lt;No Name&gt;"</span><span class="hljs-comment">;</span>
decimal? price = p?<span class="hljs-preprocessor">.Price</span> ?? <span class="hljs-number">0</span><span class="hljs-comment">;</span>
string relatedName = p?<span class="hljs-preprocessor">.Related</span>?<span class="hljs-preprocessor">.Name</span> ?? <span class="hljs-string">"&lt;None&gt;"</span><span class="hljs-comment">;</span></code></pre> 
<p>输出结果</p> 
<pre class="prettyprint"><code class="language-txt hljs http"><span class="hljs-attribute">Name</span>: <span class="hljs-string">Kayak, Price: 275, Related: Lifejacket</span>
<span class="hljs-attribute">Name</span>: <span class="hljs-string">Lifejacket, Price: 48.95, Related: &lt;None&gt;</span>
<span class="hljs-attribute">Name</span>: <span class="hljs-string">&lt;No Name&gt;, Price: 0, Related: &lt;None&gt;</span></code></pre> 
<h3 id="使用自动实现属性">使用自动实现属性</h3> 
<p>C#支持自动实现属性(属性, property, 通过get\set对数据进行访问控制, java中的setter\getter) <br> 可读可写的属性如下</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }</code></pre> 
<p>这实际是一个语法糖, 编译时编译器会转换为</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name {
    <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> _name; }
    <span class="hljs-keyword">set</span> { _name = <span class="hljs-keyword">value</span>; }
}</code></pre> 
<p>这里<code>_name</code>只是一个代称, 不确定字段名到底是什么.</p> 
<h4 id="自动属性初始化器">自动属性初始化器</h4> 
<p>从C# 3.0起就支持自动属性, 而C#的最新版本(7.0??)支持自动属性的初始化器, 可以在不使用构造函数的情况下设置初始值, 之前只可以为字段设置.</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Category { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-string">"Watersports"</span>;</code></pre> 
<p>初始化器不会妨碍setter的更改. 编译器只是会整理初始化器, 并得到一个包含各属性默认值的构造函数</p> 
<h4 id="只读自动属性">只读自动属性</h4> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> InStock { <span class="hljs-keyword">get</span>; } = <span class="hljs-keyword">true</span>;</code></pre> 
<p>相当于</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span>(<span class="hljs-keyword">bool</span> stock = <span class="hljs-keyword">true</span>) {
    InStock = stock;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> InStock { <span class="hljs-keyword">get</span>; }</code></pre> 
<p>由于没有set权限, 只能在构造对象时赋值</p> 
<h3 id="内插字符串">内插字符串</h3> 
<p><code>string.Format()</code>是C#拼接字符串的传统方式, 现在可以使用新方法</p> 
<pre class="prettyprint"><code class="language-csharp hljs css"><span class="hljs-tag">results</span><span class="hljs-class">.Add</span>(<span class="hljs-tag">string</span><span class="hljs-class">.Format</span>("<span class="hljs-tag">Name</span>: <span class="hljs-rules">{<!-- --><span class="hljs-rule">0}</span></span>, <span class="hljs-tag">Price</span>: <span class="hljs-rules">{<!-- --><span class="hljs-rule">1}</span></span>, <span class="hljs-tag">Related</span>: <span class="hljs-rules">{<!-- --><span class="hljs-rule">2}</span></span>", <span class="hljs-tag">name</span>, <span class="hljs-tag">price</span>, <span class="hljs-tag">relatedName</span>));</code></pre> 
<p>可替换为</p> 
<pre class="prettyprint"><code class="language-csharp hljs http"><span class="hljs-attribute">results.Add($"Name</span>: <span class="hljs-string">{name}, Price: {price}, Related: {relatedName}");</span></code></pre> 
<p>内插字符串以<code>$</code>为前缀, 包含孔(以<code>{}</code>包含), 孔内可以填写简单的表达式. 计算字符串时, 会使用指定的表达式的值填充这些孔. <br> 内插字符串支持<code>string.Format()</code>的所有格式说明符, 只要用在孔中, 如<code>$"Price: {Price:C2}"</code>将会把价格值格式化为具有两个十进制数字的货币值.</p> 
<h3 id="对象和集合初始化器">对象和集合初始化器</h3> 
<p>对象初始化器可以将创建对象和赋值简化为一步(个人觉得是因为已经简化了构造函数, 所以有必要这样做). 例子:</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs">Product kayak = <span class="hljs-keyword">new</span> Product {
    Name = <span class="hljs-string">"Kayak"</span>,
    Category = <span class="hljs-string">"Water Craft"</span>,
    Price = <span class="hljs-number">275</span>M
};</code></pre> 
<p>如果没有这个特性, 就不得不这样写</p> 
<pre class="prettyprint"><code class="language-csharp hljs avrasm">Product kayak = new Product()<span class="hljs-comment">;</span>
kayak<span class="hljs-preprocessor">.Name</span> = <span class="hljs-string">"Kayak"</span><span class="hljs-comment">;</span>
kayak<span class="hljs-preprocessor">.Category</span> = <span class="hljs-string">"Water Craft"</span><span class="hljs-comment">;</span>
kayak<span class="hljs-preprocessor">.Price</span> = <span class="hljs-number">275</span>M<span class="hljs-comment">;</span></code></pre> 
<p>相似的特性是集合初始化器, 旧的语法:</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> ViewResult <span class="hljs-title">Index</span>() {
    <span class="hljs-keyword">string</span>[] names = <span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span>[<span class="hljs-number">3</span>];
    names[<span class="hljs-number">0</span>] = <span class="hljs-string">"Bob"</span>;
    names[<span class="hljs-number">1</span>] = <span class="hljs-string">"Joe"</span>;
    names[<span class="hljs-number">2</span>] = <span class="hljs-string">"Alice"</span>;
    <span class="hljs-keyword">return</span> View(<span class="hljs-string">"Index"</span>, names);
}</code></pre> 
<p>可以简化为</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> ViewResult <span class="hljs-title">Index</span>() {
    <span class="hljs-keyword">return</span> View(<span class="hljs-string">"Index"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span>[] { <span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Joe"</span>, <span class="hljs-string">"Alice"</span> });
}</code></pre> 
<h4 id="索引初始化器">索引初始化器</h4> 
<p>最新的C#版本整理了使用索引的集合(如Dictionary)的方法, 并提供了初始化器语法. 旧的语法:</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> ViewResult <span class="hljs-title">Index</span>() {
    Dictionary&lt;<span class="hljs-keyword">string</span>, Product&gt; products = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">string</span>, Product&gt; {
        { <span class="hljs-string">"Kayak"</span>, <span class="hljs-keyword">new</span> Product { Name = <span class="hljs-string">"Kayak"</span>, Price = <span class="hljs-number">275</span>M } },
        { <span class="hljs-string">"Lifejacket"</span>,  <span class="hljs-keyword">new</span> Product{ Name = <span class="hljs-string">"Lifejacket"</span>, Price = <span class="hljs-number">48.95</span>M } }
    };
    <span class="hljs-keyword">return</span> View(<span class="hljs-string">"Index"</span>, products.Keys);
}</code></pre> 
<p>可以简化为:</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> ViewResult <span class="hljs-title">Index</span>() {
    Dictionary&lt;<span class="hljs-keyword">string</span>, Product&gt; products = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">string</span>, Product&gt; {
        [<span class="hljs-string">"Kayak"</span>] = <span class="hljs-keyword">new</span> Product { Name = <span class="hljs-string">"Kayak"</span>, Price = <span class="hljs-number">275</span>M },
        [<span class="hljs-string">"Lifejacket"</span>] = <span class="hljs-keyword">new</span> Product { Name = <span class="hljs-string">"Lifejacket"</span>, Price = <span class="hljs-number">48.95</span>M }
    };
    <span class="hljs-keyword">return</span> View(<span class="hljs-string">"Index"</span>, products.Keys);
}</code></pre> 
<h3 id="模式匹配判断对象类型">模式匹配(判断对象类型)</h3> 
<p>C#最重要的新特性之一是支持模式匹配, 用于测试对象是否某种特定类型, 或有特定的特征, 这也是一种语法糖, 使用<code>is</code>关键字</p> 
<pre class="prettyprint"><code class="language-csharp hljs r"><span class="hljs-keyword">if</span> (data[i] is decimal d) {
    // <span class="hljs-keyword">...</span>
}</code></pre> 
<p>如果<code>data[i]</code>是<code>decimal</code>类型, 则表达式<code>data[i] is decimal d</code>值为true, 并将<code>data[i]</code>赋值给<code>d</code>.</p> 
<h4 id="结合switch语句的模式匹配">结合switch语句的模式匹配</h4> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">object</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">object</span>[] { <span class="hljs-number">275</span>M, <span class="hljs-number">29.95</span>M,
    <span class="hljs-string">"apple"</span>, <span class="hljs-string">"orange"</span>, <span class="hljs-number">100</span>, <span class="hljs-number">10</span> };
<span class="hljs-keyword">decimal</span> total = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++) {
    <span class="hljs-keyword">switch</span> (data[i]) {
        <span class="hljs-keyword">case</span> <span class="hljs-keyword">decimal</span> decimalValue:
            total += decimalValue;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span> intValue when intValue &gt; <span class="hljs-number">50</span>:
            total += intValue;
            <span class="hljs-keyword">break</span>;
    }
}</code></pre> 
<p>语法如下</p> 
<pre class="prettyprint"><code class="language-csharp hljs r">case &lt;Type&gt; outputVariableName [when condition]:
    // <span class="hljs-keyword">...</span></code></pre> 
<h3 id="扩展方法">扩展方法</h3> 
<p>扩展方法是一种给不属于自己的或不方便修改的类增加方法的方便途径. 通过在函数定义中使用<code>this</code>关键字, 可以定义扩展方法</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">decimal</span> <span class="hljs-title">TotalPrices</span>(<span class="hljs-keyword">this</span> ShoppingCart cartParam) {
    <span class="hljs-keyword">decimal</span> total = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">foreach</span> (Product prod <span class="hljs-keyword">in</span> cartParam.Products) {
        total += prod?.Price ?? <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> total;
}</code></pre> 
<p>扩展方法必须定义在自己的static类中, 并定义为public static. 第一个this参数指定了可以调用此方法的对象, 并可以在方法体中使用. 如上, 则可以调用<code>cartParam.TotalPrices()</code>, 第一个参数在调用时被忽略(类似python中类方法的定义)</p> 
<p><strong>注意</strong>: 扩展方法只能访问可以访问的类成员.</p> 
<h4 id="在接口中使用扩展方法">在接口中使用扩展方法</h4> 
<pre class="prettyprint"><code class="language-csharp hljs cs">
namespace LanguageFeatures.Models {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ShoppingCart : IEnumerable&lt;Product&gt; {
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> MyExtensionMethods {
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> HomeController : Controller {
        <span class="hljs-keyword">public</span> ViewResult <span class="hljs-title">Index</span>() {
            ShoppingCart cart
                = <span class="hljs-keyword">new</span> ShoppingCart { Products = Product.GetProducts() };
            Product[] productArray = {
                <span class="hljs-keyword">new</span> Product {Name = <span class="hljs-string">"Kayak"</span>, Price = <span class="hljs-number">275</span>M},
                <span class="hljs-keyword">new</span> Product {Name = <span class="hljs-string">"Lifejacket"</span>, Price = <span class="hljs-number">48.95</span>M}
            };
            <span class="hljs-keyword">decimal</span> cartTotal = cart.TotalPrices();
            <span class="hljs-keyword">decimal</span> arrayTotal = productArray.TotalPrices();
            <span class="hljs-keyword">return</span> View(<span class="hljs-string">"Index"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span>[] {
                $<span class="hljs-string">"Cart Total: {cartTotal:C2}"</span>,
                $<span class="hljs-string">"Array Total: {arrayTotal:C2}"</span> });
        }
    }
}
</code></pre> 
<p>因为定义了<code>IEnumerable&lt;Product&gt;</code>的扩展方法, 所以直接继承接口的<code>ShoppingCart</code>可以使用扩展方法, 泛型类<code>Array&lt;Product&gt;</code>也可以使用</p> 
<h4 id="过滤器扩展方法">过滤器扩展方法</h4> 
<p>过滤器扩展方法可以用于筛选对象集合, 使用<code>yield</code>关键字(生成器), 效果类似于LINQ</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">using</span> System.Collections.Generic;
namespace LanguageFeatures.Models {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> MyExtensionMethods {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">decimal</span> <span class="hljs-title">TotalPrices</span>(<span class="hljs-keyword">this</span> IEnumerable&lt;Product&gt; products) {
            <span class="hljs-keyword">decimal</span> total = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">foreach</span> (Product prod <span class="hljs-keyword">in</span> products) {
                total += prod?.Price ?? <span class="hljs-number">0</span>;
            }
            <span class="hljs-keyword">return</span> total;
        }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IEnumerable&lt;Product&gt; <span class="hljs-title">FilterByPrice</span>(
                <span class="hljs-keyword">this</span> IEnumerable&lt;Product&gt; productEnum, <span class="hljs-keyword">decimal</span> minimumPrice) {
            <span class="hljs-keyword">foreach</span> (Product prod <span class="hljs-keyword">in</span> productEnum) {
                <span class="hljs-keyword">if</span> ((prod?.Price ?? <span class="hljs-number">0</span>) &gt;= minimumPrice) {
                    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> prod;
                }
            }
        }
    }
}</code></pre> 
<p>扩展方法<code>FilterByPrice</code>, 采用了一个额外的参数来筛选产品, 返回一个<code>IEnumerable&lt;Product&gt;</code>对象, 包含价格大于参数的对象</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Mvc;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> LanguageFeatures.Models;

namespace LanguageFeatures.Controllers {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> HomeController : Controller {
        <span class="hljs-keyword">public</span> ViewResult <span class="hljs-title">Index</span>() {
            Product[] productArray = {
                <span class="hljs-keyword">new</span> Product {Name = <span class="hljs-string">"Kayak"</span>, Price = <span class="hljs-number">275</span>M},
                <span class="hljs-keyword">new</span> Product {Name = <span class="hljs-string">"Lifejacket"</span>, Price = <span class="hljs-number">48.95</span>M},
                <span class="hljs-keyword">new</span> Product {Name = <span class="hljs-string">"Soccer ball"</span>, Price = <span class="hljs-number">19.50</span>M},
                <span class="hljs-keyword">new</span> Product {Name = <span class="hljs-string">"Corner flag"</span>, Price = <span class="hljs-number">34.95</span>M}
            };
            <span class="hljs-keyword">decimal</span> arrayTotal = productArray.FilterByPrice(<span class="hljs-number">20</span>).TotalPrices();
            <span class="hljs-keyword">return</span> View(<span class="hljs-string">"Index"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span>[] { $<span class="hljs-string">"Array Total: {arrayTotal:C2}"</span> });
        }
    }
}</code></pre> 
<p>输出(Kayak + Lifejacket + Corner flag)</p> 
<pre class="prettyprint"><code class="language-txt hljs http"><span class="hljs-attribute">Total</span>: <span class="hljs-string">$358.90</span></code></pre> 
<h3 id="lambda表达式">Lambda表达式</h3> 
<p>Lambda表达式令人迷惑, 特别是用它来简化的特性也令人迷惑. 要理解下面的问题, 请参照上文中定义的<code>FilterByPrice</code>方法, 现在又想根据Name过滤数据</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IEnumerable&lt;Product&gt; <span class="hljs-title">FilterByName</span>(
        <span class="hljs-keyword">this</span> IEnumerable&lt;Product&gt; productEnum, <span class="hljs-keyword">char</span> firstLetter) {
    <span class="hljs-keyword">foreach</span> (Product prod <span class="hljs-keyword">in</span> productEnum) {
        <span class="hljs-keyword">if</span> (prod?.Name?[<span class="hljs-number">0</span>] == firstLetter) {
            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> prod;
        }
    }
}</code></pre> 
<p>要是想使用多个过滤器呢? 这里采用了定义泛型委托的方式</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IEnumerable&lt;Product&gt; <span class="hljs-title">Filter</span>(
        <span class="hljs-keyword">this</span> IEnumerable&lt;Product&gt; productEnum,
        Func&lt;Product, <span class="hljs-keyword">bool</span>&gt; selector) {
    <span class="hljs-keyword">foreach</span> (Product prod <span class="hljs-keyword">in</span> productEnum) {
        <span class="hljs-keyword">if</span> (selector(prod)) {
            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> prod;
        }
    }
}</code></pre> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> HomeController : Controller {
    <span class="hljs-keyword">bool</span> FilterByPrice(Product p) {
        <span class="hljs-keyword">return</span> (p?.Price ?? <span class="hljs-number">0</span>) &gt;= <span class="hljs-number">20</span>;
    }
    <span class="hljs-keyword">public</span> ViewResult <span class="hljs-title">Index</span>() {
        Product[] productArray = {
            <span class="hljs-keyword">new</span> Product {Name = <span class="hljs-string">"Kayak"</span>, Price = <span class="hljs-number">275</span>M},
            <span class="hljs-keyword">new</span> Product {Name = <span class="hljs-string">"Lifejacket"</span>, Price = <span class="hljs-number">48.95</span>M},
            <span class="hljs-keyword">new</span> Product {Name = <span class="hljs-string">"Soccer ball"</span>, Price = <span class="hljs-number">19.50</span>M},
            <span class="hljs-keyword">new</span> Product {Name = <span class="hljs-string">"Corner flag"</span>, Price = <span class="hljs-number">34.95</span>M}
        };
        Func&lt;Product, <span class="hljs-keyword">bool</span>&gt; nameFilter = <span class="hljs-keyword">delegate</span> (Product prod) {
            <span class="hljs-keyword">return</span> prod?.Name?[<span class="hljs-number">0</span>] == <span class="hljs-string">'S'</span>;
        };
        <span class="hljs-keyword">decimal</span> priceFilterTotal = productArray
            .Filter(FilterByPrice)
            .TotalPrices();
        <span class="hljs-keyword">decimal</span> nameFilterTotal = productArray
            .Filter(nameFilter)
            .TotalPrices();
        <span class="hljs-keyword">return</span> View(<span class="hljs-string">"Index"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span>[] {
            $<span class="hljs-string">"Price Total: {priceFilterTotal:C2}"</span>,
            $<span class="hljs-string">"Name Total: {nameFilterTotal:C2}"</span> });
    }
}</code></pre> 
<p>可简化为</p> 
<pre class="prettyprint"><code class="language-csharp hljs avrasm">decimal priceFilterTotal = productArray
    <span class="hljs-preprocessor">.Filter</span>(p =&gt; (p?<span class="hljs-preprocessor">.Price</span> ?? <span class="hljs-number">0</span>) &gt;= <span class="hljs-number">20</span>)
    <span class="hljs-preprocessor">.TotalPrices</span>()<span class="hljs-comment">;</span>
decimal nameFilterTotal = productArray
    <span class="hljs-preprocessor">.Filter</span>(p =&gt; p?<span class="hljs-preprocessor">.Name</span>?[<span class="hljs-number">0</span>] == <span class="hljs-string">'S'</span>)
    <span class="hljs-preprocessor">.TotalPrices</span>()<span class="hljs-comment">;</span></code></pre> 
<p>…也不知道摘的这些大家能不能看懂…反正会用的是肯定能看懂的, 就是把一行语句能写完的函数简化一下, 一个语法糖</p> 
<pre class="prettyprint"><code class="language-csharp hljs r">(param1, param2, <span class="hljs-keyword">...</span>) =&gt; expression</code></pre> 
<p>或</p> 
<pre class="prettyprint"><code class="language-csharp hljs r">(param1, param2, <span class="hljs-keyword">...</span>) =&gt; {
    // <span class="hljs-keyword">...</span>
    <span class="hljs-keyword">return</span> result;
}</code></pre> 
<h4 id="用在方法和属性中">用在方法和属性中</h4> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> ViewResult <span class="hljs-title">Index</span>() {
    <span class="hljs-keyword">return</span> View(Product.GetProducts().Select(p =&gt; p?.Name));
}</code></pre> 
<p>可以简化成这样</p> 
<pre class="prettyprint"><code class="language-csharp hljs coffeescript">public ViewResult Index<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
View(Product.GetProducts().Select(p<span class="hljs-function"> =&gt;</span> p?.Name));</code></pre> 
<p>另一个例子</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> NameBeginsWithS =&gt; Name?[<span class="hljs-number">0</span>] == <span class="hljs-string">'S'</span>;</code></pre> 
<h3 id="类型推断和匿名类型">类型推断和匿名类型</h3> 
<h4 id="类型推断">类型推断</h4> 
<p>写C#的话, <code>var</code>应该没人没用过吧…?</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">var</span> name = <span class="hljs-keyword">new</span> SimpleClassWithLongLongLongLongName();</code></pre> 
<p>一个优点是不用再打一遍类型名, 另一个优点不容易出类型错误.</p> 
<h4 id="匿名类型">匿名类型</h4> 
<p>想创建一个对象, 又不想定义一个类(可能就临时用一下), 用<code>var</code>关键字</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">var</span> productA = <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">"Kayak"</span>, Price = <span class="hljs-number">275</span>M };</code></pre> 
<p>之后就可以用<code>productA.Name</code>和<code>productA.Price</code>属性. 但这个类没办法访问啊(被编译器分配一个不容易出错的类名)…所以要创建集合的话也必须用<code>var</code>.</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">var</span> products = <span class="hljs-keyword">new</span> [] {
    <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">"Kayak"</span>, Price = <span class="hljs-number">275</span>M },
    <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">"Lifejacket"</span>, Price = <span class="hljs-number">48.95</span>M },
    <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">"Soccer ball"</span>, Price = <span class="hljs-number">19.50</span>M },
    <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">"Corner flag"</span>, Price = <span class="hljs-number">34.95</span>M }
};</code></pre> 
<h3 id="异步方法">异步方法</h3> 
<p>异步方法启动后将在后台完成工作, 并在完成后发出通知, 允许代码在执行后台工作时处理其他业务(多线程). 异步方法是消除代码瓶颈的重要工具, 允许应用程序使用多个处理器和处理器内核进行并行工作. <br> 在MVC中, 可以使用异步方法来提高应用程序的整体性能(应对IO阻塞), 使用关键字<code>async</code>和<code>await</code> <br> 首先修改项目设置, 添加.NET组件以启用异步HTTP请求. 右击解决方案资源管理器中的项目, 编辑<code>&lt;ProjectName&gt;.csproj</code>, 添加包引用</p> 
<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-tag">&lt;<span class="hljs-title">Project</span> <span class="hljs-attribute">Sdk</span>=<span class="hljs-value">"Microsoft.NET.Sdk.Web"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">TargetFramework</span>&gt;</span>netcoreapp2.0<span class="hljs-tag">&lt;/<span class="hljs-title">TargetFramework</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">PropertyGroup</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">Folder</span> <span class="hljs-attribute">Include</span>=<span class="hljs-value">"wwwroot\"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">ItemGroup</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">PackageReference</span> <span class="hljs-attribute">Include</span>=<span class="hljs-value">"Microsoft.AspNetCore.All"</span> <span class="hljs-attribute">Version</span>=<span class="hljs-value">"2.0.0"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">PackageReference</span> <span class="hljs-attribute">Include</span>=<span class="hljs-value">"System.Net.Http"</span> <span class="hljs-attribute">Version</span>=<span class="hljs-value">"4.3.2"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">Project</span>&gt;</span></code></pre> 
<p>保存文件后, VS会自动下载软件包. 直接使用NuGet安装也行. 详见第六章</p> 
<h4 id="直接处理任务">直接处理任务</h4> 
<p>C#和.NET对异步方法支持很好, 但<code>await</code>和<code>async</code>是比较新的特性, 之前的实现很繁琐. 如下代码</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">using</span> System.Net.Http;
<span class="hljs-keyword">using</span> System.Threading.Tasks;

namespace LanguageFeatures.Models {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MyAsyncMethods {

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Task&lt;<span class="hljs-keyword">long</span>?&gt; <span class="hljs-title">GetPageLength</span>() {
            HttpClient client = <span class="hljs-keyword">new</span> HttpClient();
            <span class="hljs-keyword">var</span> httpTask = client.GetAsync(<span class="hljs-string">"http://apress.com"</span>);
            <span class="hljs-keyword">return</span> httpTask.ContinueWith((Task&lt;HttpResponseMessage&gt; antecedent) =&gt; {
                <span class="hljs-keyword">return</span> antecedent.Result.Content.Headers.ContentLength;
            });
        }
    }
}</code></pre> 
<p>这个方法使用<code>System.Net.Http.HttpClient</code>对象来请求Apress主页的内容, 并返回页面长度. .NET将异步工作表示为<code>Task</code>. <code>Task</code>对象是强类型化的, 所以在调用<code>HttpClient.GetAsync</code>方法时, 会获得<code>Task&lt;HttpResponseMessage&gt;</code>. 请求将在后台执行, 结果将是<code>HttpResponseMessage</code>对象。 <br> 大多数程序员困惑的地方是<code>continuation</code>, 这种机制可以指定后台任务完成后希望做什么. 此例中, 使用<code>ContinueWith</code>方法来处理从<code>HttpClient.GetAsync</code>获取的<code>HttpResponseMessage</code>对象. 用lambda表达式返回内容长度值. <br> 令人困惑的是使用两次<code>return</code>. 第一个<code>return</code>返回<code>Task&lt;HttpResponseMessage&gt;</code>对象, 在任务结束后将返回<code>ContentLength</code>的标头, 然后返回一个<code>long?</code>结果, 所以返回值类型是<code>Task&lt;long?&gt;</code>. <br> 很多人被这种语法搞懵了, 所以微软简化了C#的异步方法语法.</p> 
<h4 id="使用async和await">使用async和await</h4> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">using</span> System.Net.Http;
<span class="hljs-keyword">using</span> System.Threading.Tasks;
namespace LanguageFeatures.Models {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MyAsyncMethods {

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">static</span> Task&lt;<span class="hljs-keyword">long</span>?&gt; <span class="hljs-title">GetPageLength</span>() {
            HttpClient client = <span class="hljs-keyword">new</span> HttpClient();
            <span class="hljs-keyword">var</span> httpMessage = <span class="hljs-keyword">await</span> client.GetAsync(<span class="hljs-string">"http://apress.com"</span>);
            <span class="hljs-keyword">return</span> httpMessage.Content.Headers.ContentLength;
        }
    }
}</code></pre> 
<p>在调用异步方法时使用<code>await</code>关键字, 告诉C#编译器我要等待<code>GetAsync</code>的返回结果, 然后再执行该方法中的其他语句. 使用<code>await</code>关键字意味着可以将<code>GetAsync</code>方法的视为一个常规方法, 并将其返回值赋值给一个变量. <br> 在使用<code>await</code>时, 必须给方法加上<code>async</code>关键字. 且返回值应为<code>Task&lt;&gt;</code>类型. 控制器也使用相同的方法处理</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs">namespace LanguageFeatures.Controllers {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> HomeController : Controller {

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;ViewResult&gt; <span class="hljs-title">Index</span>() {
            <span class="hljs-keyword">long</span>? length = <span class="hljs-keyword">await</span> MyAsyncMethods.GetPageLength();
            <span class="hljs-keyword">return</span> View(<span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span>[] { $<span class="hljs-string">"Length: {length}"</span> });
        }
    }
}</code></pre> 
<h3 id="获取名字">获取名字</h3> 
<p>Web应用开发中有许多时候需要获取参数\变量\方法\类名字. 常见的例子包括处理来自用户的输入时抛出的异常或验证错误. 传统的方法是使用字符串来硬编码名字, 如</p> 
<pre class="prettyprint"><code class="language-csharp hljs cs"><span class="hljs-keyword">public</span> ViewResult <span class="hljs-title">Index</span>() {
    <span class="hljs-keyword">var</span> products = <span class="hljs-keyword">new</span> [] {
        <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">"Kayak"</span>, Price = <span class="hljs-number">275</span>M },
        <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">"Lifejacket"</span>, Price = <span class="hljs-number">48.95</span>M },
        <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">"Soccer ball"</span>, Price = <span class="hljs-number">19.50</span>M },
        <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">"Corner flag"</span>, Price = <span class="hljs-number">34.95</span>M }
    };
    <span class="hljs-keyword">return</span> View(products.Select(p =&gt; $<span class="hljs-string">"Name: {p.Name}, Price: {p.Price}"</span>));
}</code></pre> 
<p>LINQ<code>Select</code>方法生成一个字符串序列, 描述了Name和Price属性, 输出为</p> 
<pre class="prettyprint"><code class="language-txt hljs http"><span class="hljs-attribute">Name</span>: <span class="hljs-string">Kayak, Price: 275</span>
<span class="hljs-attribute">Name</span>: <span class="hljs-string">Lifejacket, Price: 48.95</span>
<span class="hljs-attribute">Name</span>: <span class="hljs-string">Soccer ball, Price: 19.50</span>
<span class="hljs-attribute">Name</span>: <span class="hljs-string">Corner flag, Price: 34.95</span></code></pre> 
<p>这里主要讨论的是这个部分<code>Name: ...... Price:</code>. 这种方法容易出错, 主要是引入错误的输入或者代码重构忘了更新字符串. 这对显示给用户的信息来说很成问题, 应该使用<code>nameof()</code>方法, 如下</p> 
<pre class="prettyprint"><code class="language-csharp hljs php"><span class="hljs-keyword">return</span> View(products.Select(p =&gt;
$<span class="hljs-string">"{nameof(p.Name)}: {p.Name}, {nameof(p.Price)}: {p.Price}"</span>));</code></pre> 
<p>输出和上面相同</p> 
<h3 id="总结">总结</h3> 
<p>本章中, 我们浏览了一个高效MVC程序员需要知道的关键C#语言特性. C#是一种灵活的语言, 通常有不同的方法来处理问题, 但这些特性是在开发web应用中经常遇到的. <br> 在下一章中, 我将介绍Razor引擎, 并解释如何在MVC web应用中生成动态内容.</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/120e6e678a09416af64f7afda8c6f5c4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">常见的HTTP状态码(HTTP Status Code)说明</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/74067a771f961567fa1df95ad29d4a28/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python爬虫初学：requests库安装（”pip“不是内部或外部命令时，也不是可运行的程序或批处理文件“）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>