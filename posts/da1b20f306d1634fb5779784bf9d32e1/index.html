<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>去除OCR中的虚线 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="去除OCR中的虚线" />
<meta property="og:description" content="原图如下 处理代码
#include&lt;iostream&gt; #include&lt;opencv.hpp&gt; using namespace cv; using namespace std; /* 函数功能：在输入图像中找一条直线 输入输出：输入的图像是灰度图raw，返回值为dst，返回值是一条白色的线 lines = cvHoughLines2(canny, stor, CV_HOUGH_PROBABILISTIC, 1, CV_PI / 180, 80, 200, 30); 参数中的200是指要找的直线长度要在200个像素以上； 参数中的30指的是两条在同一直线上的线段，如果相隔不到30，则把它们连起来 */ void findLines(IplImage* raw, IplImage* dst) { IplImage* src = cvCloneImage(raw); // clone the input image IplImage* canny = cvCreateImage(cvGetSize(src), IPL_DEPTH_8U, 1); // create a tmp image head to save gradient image cvCanny(src, canny, 20, 200, 3); // Generate its gradient image CvMemStorage* stor = cvCreateMemStorage(0); CvSeq* lines = NULL; // find a line whose length bigger than 200 pixels lines = cvHoughLines2(canny, stor, CV_HOUGH_PROBABILISTIC, 1, CV_PI / 180, 80, 200, 30); cvZero(dst); CvPoint maxStart, maxEnd; // save the coordinate of the head and rear of the line we want int maxDistance = 0; // The maximum distance of all lines found by [cvHoughLines2] for (int i = 0; i &lt; lines-&gt;total; i&#43;&#43;) // lines-&gt;total: the number of lines { // variable &#39;lines&#39; is a sequence, [cvGetSeqElem] gets the (i)th line, and it returns its head and rear." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/da1b20f306d1634fb5779784bf9d32e1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-26T14:36:08+08:00" />
<meta property="article:modified_time" content="2018-07-26T14:36:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">去除OCR中的虚线</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>原图如下 <br> <img src="https://images2.imgbox.com/d1/51/77Fbd6ou_o.png" alt="这里写图片描述" title=""> <br> 处理代码</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include&lt;opencv.hpp&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-comment">/*
函数功能：在输入图像中找一条直线
输入输出：输入的图像是灰度图raw，返回值为dst，返回值是一条白色的线
lines = cvHoughLines2(canny, stor, CV_HOUGH_PROBABILISTIC, 1, CV_PI / 180, 80, 200, 30);
参数中的200是指要找的直线长度要在200个像素以上；
参数中的30指的是两条在同一直线上的线段，如果相隔不到30，则把它们连起来
*/</span>

<span class="hljs-keyword">void</span> findLines(IplImage* raw, IplImage* dst)
{
    IplImage* src = cvCloneImage(raw); <span class="hljs-comment">// clone the input image</span>
    IplImage* canny = cvCreateImage(cvGetSize(src), IPL_DEPTH_8U, <span class="hljs-number">1</span>);   <span class="hljs-comment">// create a tmp image head to save gradient image</span>
    cvCanny(src, canny, <span class="hljs-number">20</span>, <span class="hljs-number">200</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">// Generate its gradient image</span>
    CvMemStorage* stor = cvCreateMemStorage(<span class="hljs-number">0</span>);
    CvSeq* lines = NULL;
    <span class="hljs-comment">// find a line whose length bigger than 200 pixels</span>
    lines = cvHoughLines2(canny, stor, CV_HOUGH_PROBABILISTIC, <span class="hljs-number">1</span>, CV_PI / <span class="hljs-number">180</span>, <span class="hljs-number">80</span>, <span class="hljs-number">200</span>, <span class="hljs-number">30</span>);
    cvZero(dst);
    CvPoint maxStart, maxEnd;   <span class="hljs-comment">// save the coordinate of the head and rear of the line we want</span>
    <span class="hljs-keyword">int</span> maxDistance = <span class="hljs-number">0</span>;        <span class="hljs-comment">// The maximum distance of all lines found by [cvHoughLines2]</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lines-&gt;total; i++)  <span class="hljs-comment">// lines-&gt;total: the number of lines </span>
    {
        <span class="hljs-comment">// variable 'lines' is a sequence, [cvGetSeqElem] gets the (i)th line, and it returns its head and rear.</span>
        CvPoint* line = (CvPoint*)cvGetSeqElem(lines, i);
        <span class="hljs-comment">// line[0] and line[1] is respectively the line's coordinate of its head and rear</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(line[<span class="hljs-number">0</span>].x - line[<span class="hljs-number">1</span>].x) &gt; maxDistance)
        {<!-- --><span class="hljs-comment">/*  It's a trick because the line is almost horizontal.
         strictly, it should be
         sqrt((line[0].x - line[1].x)*(line[0].x - line[1].x)+(line[0].y - line[1].y)*(line[0].x - line[1].x))
         */</span>
            maxDistance = <span class="hljs-built_in">abs</span>(line[<span class="hljs-number">0</span>].x - line[<span class="hljs-number">1</span>].x);
            maxStart = line[<span class="hljs-number">0</span>];
            maxEnd = line[<span class="hljs-number">1</span>];
        }
    }
    cvLine(dst, maxStart, maxEnd, cvScalar(<span class="hljs-number">255</span>), <span class="hljs-number">1</span>);    <span class="hljs-comment">// draw the white line[cvScalar(255)] in a black background</span>
    cvReleaseImage(&amp;src);                               <span class="hljs-comment">// free the memory</span>
    cvReleaseMemStorage(&amp;stor);
}
<span class="hljs-comment">/*
函数功能：擦除面积小于【15个像素】的小块儿
输入输出：无返回值，直接对输入的图像进行操作
*/</span>
<span class="hljs-keyword">void</span> erase(IplImage* raw)
{
    IplImage* src = cvCloneImage(raw);
    <span class="hljs-comment">/*Binarization and inverse the black and white because the function next only find white area while
    the word in image is black.*/</span>
    cvThreshold(src, src, <span class="hljs-number">120</span>, <span class="hljs-number">255</span>, CV_THRESH_BINARY_INV);
    <span class="hljs-comment">// create some space to save the white areas but we access it via variable 'cont'</span>
    CvMemStorage* stor = cvCreateMemStorage(<span class="hljs-number">0</span>);
    CvSeq* cont;
    cvFindContours(src, stor, &amp;cont, <span class="hljs-keyword">sizeof</span>(CvContour), CV_RETR_EXTERNAL); <span class="hljs-comment">// find the white regions</span>
    <span class="hljs-keyword">for</span> (; cont; cont = cont-&gt;h_next) <span class="hljs-comment">// Traversal</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(cvContourArea(cont)) &lt; <span class="hljs-number">15</span>) <span class="hljs-comment">// if its Area smaller than 15, we fill it with white[cvScalar(255)]</span>
            cvDrawContours(raw, cont, cvScalar(<span class="hljs-number">255</span>), cvScalar(<span class="hljs-number">255</span>), <span class="hljs-number">0</span>, CV_FILLED, <span class="hljs-number">8</span>);
    }
    cvReleaseImage(&amp;src);
}

<span class="hljs-keyword">int</span> main()
{
    IplImage* src = cvLoadImage(<span class="hljs-string">"E:\\fengce\\0726\\1.png"</span>);
    cvNamedWindow(<span class="hljs-string">"原图"</span>, <span class="hljs-number">1</span>);
    cvShowImage(<span class="hljs-string">"原图"</span>, src);
    IplImage* gray = cvCreateImage(cvGetSize(src), IPL_DEPTH_8U, <span class="hljs-number">1</span>);
    IplImage* canny = cvCreateImage(cvGetSize(src), IPL_DEPTH_8U, <span class="hljs-number">1</span>);
    IplImage* dst = cvCreateImage(cvGetSize(src), IPL_DEPTH_8U, <span class="hljs-number">1</span>);
    IplImage* binary = cvCreateImage(cvGetSize(src), IPL_DEPTH_8U, <span class="hljs-number">1</span>);

    cvCvtColor(src, gray, CV_RGB2GRAY);
    cvThreshold(gray, binary, <span class="hljs-number">120</span>, <span class="hljs-number">255</span>, CV_THRESH_OTSU);

    findLines(gray, dst);
    cvNamedWindow(<span class="hljs-string">"dst"</span>, <span class="hljs-number">1</span>);
    cvShowImage(<span class="hljs-string">"dst"</span>, dst);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; binary-&gt;height; row++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; binary-&gt;width; col++)
        {
            <span class="hljs-keyword">if</span> (cvGet2D(dst, row, col).val[<span class="hljs-number">0</span>] == <span class="hljs-number">255</span>)
            {
                <span class="hljs-keyword">int</span> up = <span class="hljs-number">0</span>, down = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">int</span> white = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row; i &gt;= <span class="hljs-number">0</span>; i--)
                {
                    <span class="hljs-keyword">if</span> (cvGet2D(binary, i, col).val[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)
                    {
                        up++;
                        white = <span class="hljs-number">0</span>;
                    }
                    <span class="hljs-keyword">else</span> white++;
                    <span class="hljs-keyword">if</span> (white &gt; <span class="hljs-number">2</span>)  <span class="hljs-keyword">break</span>;
                }
                white = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row; i &lt; binary-&gt;height; i++)
                {
                    <span class="hljs-keyword">if</span> (cvGet2D(binary, i, col).val[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)
                    {
                        down++;
                        white = <span class="hljs-number">0</span>;
                    }
                    <span class="hljs-keyword">else</span> white++;
                    <span class="hljs-keyword">if</span> (white &gt; <span class="hljs-number">2</span>)  <span class="hljs-keyword">break</span>;
                }
                <span class="hljs-keyword">if</span> (up + down &lt; <span class="hljs-number">8</span>)
                {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = -up; i &lt;= down; i++) cvSet2D(binary, row + i, col, cvScalar(<span class="hljs-number">255</span>));
                }
            }
        }

    cvNamedWindow(<span class="hljs-string">"结果"</span>, <span class="hljs-number">1</span>);
    cvShowImage(<span class="hljs-string">"结果"</span>, binary);
    erase(binary);
    cvDilate(binary, binary, NULL, <span class="hljs-number">1</span>);
    cvErode(binary, binary, NULL, <span class="hljs-number">1</span>);
    cvNamedWindow(<span class="hljs-string">"膨胀腐蚀"</span>, <span class="hljs-number">1</span>);
    cvShowImage(<span class="hljs-string">"膨胀腐蚀"</span>, binary);
    cvSaveImage(<span class="hljs-string">"D:/result.png"</span>, binary);
    cvReleaseImage(&amp;src);
    cvReleaseImage(&amp;canny);
    cvReleaseImage(&amp;gray);
    cvReleaseImage(&amp;dst);
    cvReleaseImage(&amp;binary);
    cvWaitKey(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre> 
<p>处理效果 <br> <img src="https://images2.imgbox.com/29/fd/oKf1sbkm_o.png" alt="这里写图片描述" title=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38cfe9278a41d1421e1be3be39271667/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Promise配合axios</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e616cd10ea5e7b4cbe94c3ea5cb16d3b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">keras报错：load_weights() got an unexpected keyword arguement &#39;skip_mmismatch&#39;</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>