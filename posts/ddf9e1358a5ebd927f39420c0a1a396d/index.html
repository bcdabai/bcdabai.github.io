<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FFmpeg与SDL双剑合璧之ubuntu - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FFmpeg与SDL双剑合璧之ubuntu" />
<meta property="og:description" content="以前所做的工作，大多是把FFmpeg用在windows平台，采用D3D或者OpenGL的方式进行渲染呈现；
前面两篇文章中，已经做好了ubuntu平台下的ffmpeg编译与简单调试（ubuntu编译ffmpeg并且demo测试），以及windows平台下的ffmpeg解码SDL显示（FFmpeg与SDL双剑合璧之Windows ）；
梳理一下手上已经具备的材料：
①ffmpeg解码，SDL播放的Demo（windows平台）；
②ubuntu平台下编译好的ffmpeg库；
③ubuntu平台下编译好的SDL库；
第③份材料，没有写出来，因为太简单了，大致操作步骤是：
1.下载SDL源码（SDL），解压；
2.打开终端，切换到SDL源码解压后的目录，执行./configure
3.make
4.sudo make install
OVER;
接下来，就是把windows平台下的代码直接搬过来，没有多少需要修改的地方，主要是库的引用上下了点功夫
一个需要注意的，对于ffmpeg库的调用，需要在包含头文件之前，定义一下
#define __STDC_CONSTANT_MACROS 下面上干货： //FFDecoder.h #pragma once #define __STDC_CONSTANT_MACROS extern &#34;C&#34; { #include &#34;libavcodec/avcodec.h&#34; #include &#34;libavformat/avformat.h&#34; #include &#34;libavutil/avutil.h&#34; #include &#34;libavutil/opt.h&#34; #include &#34;libswscale/swscale.h&#34; } class CFFDecoder { public: CFFDecoder(); virtual ~CFFDecoder(); int	OpenFile(const char *pFilePath); int	GetMediaInfo(int &amp;nFrameW,int &amp;nFrameH); int	GetOneFrame(AVFrame *pFrame); private: AVFormatContext	*m_pFormatCxt; AVCodecContext	*m_pCodecCtx; AVCodec	*m_pCodec; AVPacket	m_Packet; int	m_nVideoIndex; int	m_nAudioIndex; }; //FFDecoder." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ddf9e1358a5ebd927f39420c0a1a396d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-09-17T16:50:52+08:00" />
<meta property="article:modified_time" content="2015-09-17T16:50:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FFmpeg与SDL双剑合璧之ubuntu</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>以前所做的工作，大多是把FFmpeg用在windows平台，采用D3D或者OpenGL的方式进行渲染呈现；</p> 
<p>前面两篇文章中，已经做好了ubuntu平台下的ffmpeg编译与简单调试（<a target="_blank" href="http://blog.csdn.net/zhuxian2009/article/details/48497947" rel="noopener noreferrer">ubuntu编译ffmpeg并且demo测试</a>），以及windows平台下的ffmpeg解码SDL显示（<a target="_blank" href="http://blog.csdn.net/zhuxian2009/article/details/48471077" rel="noopener noreferrer">FFmpeg与SDL双剑合璧之Windows </a>）；</p> 
<p>梳理一下手上已经具备的材料：</p> 
<p>①ffmpeg解码，SDL播放的Demo（windows平台）；</p> 
<p>②ubuntu平台下编译好的ffmpeg库；</p> 
<p>③ubuntu平台下编译好的SDL库；</p> 
<p>第③份材料，没有写出来，因为太简单了，大致操作步骤是：</p> 
<p>1.下载SDL源码（<a target="_blank" href="http://www.libsdl.org/download-2.0.php" rel="nofollow noopener noreferrer">SDL</a>），解压；</p> 
<p>2.打开终端，切换到SDL源码解压后的目录，执行./configure</p> 
<p>3.make</p> 
<p>4.sudo make install</p> 
<p>OVER;</p> 
<p><br> </p> 
<p>接下来，就是把windows平台下的代码直接搬过来，没有多少需要修改的地方，主要是库的引用上下了点功夫</p> 
<p>一个需要注意的，对于ffmpeg库的调用，需要在包含头文件之前，定义一下</p> 
<p></p> 
<pre><code class="language-cpp">#define __STDC_CONSTANT_MACROS </code></pre> 
<br> 下面上干货： 
<p></p> 
<p></p> 
<pre><code class="language-cpp">//FFDecoder.h

#pragma once



#define __STDC_CONSTANT_MACROS  


extern "C" {

	#include "libavcodec/avcodec.h"

	#include "libavformat/avformat.h"

	#include "libavutil/avutil.h" 

	#include "libavutil/opt.h"

	#include "libswscale/swscale.h"

}



class CFFDecoder

{

public:

	CFFDecoder();

	virtual ~CFFDecoder();



	int					OpenFile(const char *pFilePath);

	int					GetMediaInfo(int &amp;nFrameW,int &amp;nFrameH);

	int					GetOneFrame(AVFrame *pFrame);



private:

	AVFormatContext		*m_pFormatCxt;

	AVCodecContext		*m_pCodecCtx;

	AVCodec			*m_pCodec;

	AVPacket		m_Packet;

	int			m_nVideoIndex;

	int			m_nAudioIndex;

};</code></pre> 
<br> 
<pre><code class="language-cpp">//FFDecoder.cpp
#include "FFDecoder.h"



CFFDecoder::CFFDecoder()

{

	m_pFormatCxt = avformat_alloc_context();

	m_pCodecCtx = NULL;

	m_pCodec = NULL;

	m_nVideoIndex = -1;

	m_nAudioIndex = -1;

}



CFFDecoder::~CFFDecoder()

{



}



int CFFDecoder::OpenFile(const char *pFilePath)

{

	av_register_all();

	

	if(avformat_open_input(&amp;m_pFormatCxt,pFilePath,NULL,NULL)&lt;0)

	{

		return -1;

	}



	if (avformat_find_stream_info(m_pFormatCxt,NULL)&lt;0)

	{

		return -2;

	}



	//ÕÒµœÒôÊÓÆµ¶ÔÓŠµÄÁ÷ÍšµÀ



	for (int i=0;i&lt;m_pFormatCxt-&gt;nb_streams;i++)

	{

		if (m_pFormatCxt-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)

		{

			m_nVideoIndex = i;

		}

		else if (m_pFormatCxt-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO)

		{

			m_nAudioIndex = i;

		}

	}



	if (m_nVideoIndex == -1)

	{

		return -3;

	}



	//Žò¿ªÏàÓŠµÄœâÂëÆ÷

	m_pCodecCtx = m_pFormatCxt-&gt;streams[m_nVideoIndex]-&gt;codec;

	m_pCodec = avcodec_find_decoder(m_pCodecCtx-&gt;codec_id);;

	if(m_pCodec==NULL){  

		return -4;  

	}



	if(avcodec_open2(m_pCodecCtx, m_pCodec,NULL)&lt;0){

		return -5;

	}



	return 0;

}



int CFFDecoder::GetMediaInfo(int &amp;nFrameW,int &amp;nFrameH)

{

	if(m_pCodecCtx==NULL)

		return -1;



	nFrameW = m_pCodecCtx-&gt;width;

	nFrameH = m_pCodecCtx-&gt;height;

	return 0;

}



int CFFDecoder::GetOneFrame(AVFrame *pFrame)

{

	if(m_pFormatCxt==NULL)

		return 0;



	int nGotPicture=-1;



	if(av_read_frame(m_pFormatCxt,&amp;m_Packet)&gt;=0)

	{

		//ÅÐ¶ÏÊÇ·ñÎªµ±Ç°ÊÓÆµÁ÷ÖÐµÄ°ü

		if (m_Packet.stream_index == m_nVideoIndex)

		{

			int nLen = avcodec_decode_video2(m_pCodecCtx,pFrame,&amp;nGotPicture,&amp;m_Packet);

			if (nLen&lt;0)

			{

				return 0;

			}



			if (nGotPicture)

			{

				//³É¹ŠµÃµœÒ»Ö¡ÊýŸÝ

				return nLen;

			}

		}

	}

	return 0;

}</code></pre> 
<br> 
<pre><code class="language-cpp">//SDLPlayer.h
#pragma once

extern "C" {

	#include "SDL.h"

}





#define		MSG_REFRESH_VIDEO		(SDL_USEREVENT+10)



class CSDLPlayer

{

public:

	CSDLPlayer();

	virtual ~CSDLPlayer();

	//³õÊŒ»¯²¥·ÅÆ÷£¬ÉèÖÃ²¥·ÅÆ÷¿ížß

	int				InitPlayer(int nWinW, int nWinH);



	//³õÊŒ»¯ÎÆÀí£¬ÉèÖÃÎÆÀí¿ížß

	int				InitTexture(int nFrameW, int nFrameH);



	int				InputFrame(unsigned char *pY, unsigned long Ylinesize,

								unsigned char *pU, unsigned long Ulinesize,

								unsigned char *pV, unsigned long Vlinesize);



private:

	static int			Thread2Refresh(void *opaque);

private:

	SDL_Window		*m_pPlayer;

	SDL_Rect		m_rect;  

	SDL_Renderer		*m_pReader;

	SDL_Texture		*m_pTexture;

};</code></pre> 
<br> 
<pre><code class="language-cpp">//SDLPlayer.cpp

#include "SDLPlayer.h"



CSDLPlayer::CSDLPlayer()

{

	m_pPlayer = NULL;

	m_pReader = NULL;

	m_pTexture = NULL;

}



CSDLPlayer::~CSDLPlayer()

{



}



int CSDLPlayer::Thread2Refresh(void *opaque)

{  

	while(1)

	{

		SDL_Event evt;

		evt.type = MSG_REFRESH_VIDEO;

		SDL_PushEvent(&amp;evt);
		SDL_Delay(40);

	}

	return 0;  

}  



int CSDLPlayer::InitPlayer(int nWinW, int nWinH)

{

	if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {  

		return -1;  

	}   



	m_pPlayer=SDL_CreateWindow("Hello SDL",

		SDL_WINDOWPOS_UNDEFINED,

		SDL_WINDOWPOS_UNDEFINED,

		nWinW,nWinH,

		SDL_WINDOW_RESIZABLE|SDL_WINDOW_OPENGL);

	

	SDL_Thread *refresh_thread = SDL_CreateThread(Thread2Refresh,NULL,NULL);



	return 0;

}



int CSDLPlayer::InitTexture(int nFrameW, int nFrameH)

{

	if(m_pPlayer==NULL)

		return 0;



	m_pReader = SDL_CreateRenderer(m_pPlayer,-1,0);

	m_pTexture = SDL_CreateTexture(m_pReader,SDL_PIXELFORMAT_IYUV,SDL_TEXTUREACCESS_STREAMING,nFrameW,nFrameH);



	m_rect.x = 0;

	m_rect.y = 0;

	m_rect.w = nFrameW;

	m_rect.h = nFrameH;



	return 0;

}



int	CSDLPlayer::InputFrame(unsigned char *pY, unsigned long Ylinesize,

						   unsigned char *pU, unsigned long Ulinesize,

						   unsigned char *pV, unsigned long Vlinesize)

{

	if(m_pPlayer==NULL || m_pReader==NULL || m_pTexture==NULL)

		return -1;



	//ÊµÏÖÏûÏ¢£¬ÊÇÎªÁË¿ØÖÆ²¥·ÅËÙ¶ÈÒÑŸ­±ÜÃâŽ°¿Ú³öÏÖÎŽÏìÓŠ×ŽÌ¬

	SDL_Event evt;

	SDL_WaitEvent(&amp;evt);
	//SDL_Log("#####EVENT evt.type=0x%d\n",evt.type);
	if(evt.type == SDL_WINDOWEVENT)
	{
		SDL_Log("WINDOWEVENT evt.type=0x%x,evt.window.event=0x%d\n",evt.type,evt.window.event);
		if(evt.window.event==SDL_WINDOWEVENT_CLOSE)
		{
			SDL_Window *pWindow=SDL_GetWindowFromID(evt.window.windowID);
			if(pWindow == m_pPlayer)
			{
				SDL_DestroyWindow(pWindow);
				m_pPlayer = NULL;
			}
		}
	}

	

	if(evt.type!=MSG_REFRESH_VIDEO)

		return -1;

	

	SDL_Rect sdlRect; 

						 

	sdlRect.x = 0;    

	sdlRect.y = 0;    

	SDL_GetWindowSize(m_pPlayer,&amp;sdlRect.w,&amp;sdlRect.h);



	//SDL_UpdateTexture(m_pTexture,&amp;m_rect,pYUVData,linesize);



	//¿ÉÒÔŽŠÀíÄÇÐ©yuvÄÚŽæÊýŸÝ²»Á¬ÐøµÄÇé¿ö

	SDL_UpdateYUVTexture(m_pTexture,&amp;m_rect,

		pY,Ylinesize,

		pU,Ulinesize,

		pV,Vlinesize);

	SDL_RenderClear( m_pReader );     

	SDL_RenderCopy( m_pReader, m_pTexture, &amp;m_rect, &amp;sdlRect);    

	SDL_RenderPresent( m_pReader ); 
	SDL_Delay(10);	

	return 0;

}</code></pre> 
<br> 下面是调用的主函数 
<p></p> 
<p></p> 
<pre><code class="language-cpp">//FFmpegSDL.cpp
#include "FFDecoder.h"

#include "SDLPlayer.h"



int main(int argc, char* argv[])

{

	CFFDecoder dec;

	CSDLPlayer player[2];



	dec.OpenFile("/home/xy/Videos/Wild.mp4");



	int nFrameW=0,nFrameH=0;

	dec.GetMediaInfo(nFrameW,nFrameH);



	player[0].InitPlayer(800,600);

	player[0].InitTexture(nFrameW,nFrameH);



	player[1].InitPlayer(800,600);

	player[1].InitTexture(nFrameW,nFrameH);



	AVFrame *pFrame=av_frame_alloc(); 



	while(1)

	{

		if(dec.GetOneFrame(pFrame)&gt;0)

		{

			player[0].InputFrame(pFrame-&gt;data[0],pFrame-&gt;linesize[0],

								pFrame-&gt;data[1],pFrame-&gt;linesize[1],

								pFrame-&gt;data[2],pFrame-&gt;linesize[2]);



			player[1].InputFrame(pFrame-&gt;data[0],pFrame-&gt;linesize[0],

				pFrame-&gt;data[1],pFrame-&gt;linesize[1],

				pFrame-&gt;data[2],pFrame-&gt;linesize[2]);

		}

	}


	return 0;

}</code></pre> 
<br> 接下来是主菜，makefile 
<p></p> 
<p></p> 
<pre><code class="language-cpp">srcdir  = .

CC      = g++
EXE	= 
CFLAGS  = -I/home/xy/soft/ffout/include -D_REENTRANT -I/usr/local/include/SDL2   -DHAVE_OPENGL
LIBS	=  -L/home/xy/soft/ffout/lib -lpthread  -lavutil -lavformat -lavcodec -lswscale -lm -lz \
-lSDL2_test -Wl,-rpath,/usr/local/lib -L/usr/local/lib -lSDL2

TARGETS = FFmpegSDL

all: $(TARGETS)

FFmpegSDL$(EXE): $(srcdir)/FFDecoder.cpp $(srcdir)/FFDecoder.h $(srcdir)/SDLPlayer.cpp $(srcdir)/SDLPlayer.h $(srcdir)/FFmpegSDL.cpp
	$(CC)  $^ -o $(TARGETS) $(CFLAGS) $(LIBS)

clean:
	rm -f $(TARGETS)</code></pre> 
<br> 工作到此为止，收获的时间到了，cd到这些源代码所在的目录，make一下， 
<p></p> 
<p><img src="https://images2.imgbox.com/39/a2/tEFib1Vc_o.png" alt=""><br> </p> 
<p><br> </p> 
<p>执行，看效果如何：</p> 
<p><img src="https://images2.imgbox.com/20/03/GjcCiKmU_o.png" alt=""><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51f0668d88a60f0f2c9c7e01a86baec1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">局域网访问速度慢、文件传输慢的解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/35bc869dd76470a6dc860858a4d051ae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务端控件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>