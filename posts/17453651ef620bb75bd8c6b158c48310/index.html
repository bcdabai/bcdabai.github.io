<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言面试题整理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言面试题整理" />
<meta property="og:description" content="1.什么是预编译？
预编译又称预处理，是整个编译最先做的工作，及程序执行前的一些预处理工作
主要处理开头的指令，如拷贝 #include包含的文件代码、替换#define定义的宏、条件编译等
何时需要预编译？ 总是使用并不经常改动的大型代码体
2. # 和 ##的作用？
#是宏参数 字符串替换运算符，## 是把两个 宏参数 连接起来的运算符
#define STR(arg) #arg //STR(hello) ---&gt; hello #define NAME(x,y) x##y //NAME(1,2) ----&gt;12
3.static 的用法
修饰局部变量，该变量（栈区）变成静态存储类型，该变量存在于内存的静态区，作用域不变。
修饰全局变量，该变量的作用域，只能在该文件中使用。不能在其他文件中通过extern引用
修饰函数， 静态函数只能在申明它的源文件中使用
4. extern 关键字的作用
用来修饰变量或函数，表明该变量或函数都是在别的文件中定义的，提醒编译器在其他文件中寻找定义
5. sizeof 的用法
计算对象或类型所占的内存字节数
sizeof 求得的结构体(及其对象)的大小，不等于各个数据成员大小之和
sizeof运算符 和函数strlen的区别与用法
sizeof（）计算分配空间的字节数
strlen（）计算空间中的字符个数(不包括&#39;\0&#39;)
char str[20] = {&#34;hello world&#34;};
int a[10];
sizeof(str); //20 sizeof(a); //4*10 strlen(str); //11
6.结构体的赋值
C语言中对结构体变量的赋值##在初始化##或者在定义后按字段赋值
1. struct dog{ char a; int b; }x={ &#39;a&#39; ,2 };" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/17453651ef620bb75bd8c6b158c48310/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-23T17:51:27+08:00" />
<meta property="article:modified_time" content="2023-02-23T17:51:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言面试题整理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.什么是预编译？</p> 
<p>        预编译又称预处理，是整个编译最先做的工作，及程序执行前的一些预处理工作</p> 
<p>        主要处理开头的指令，如拷贝  #include包含的文件代码、替换#define定义的宏、条件编译等</p> 
<p>        何时需要预编译？ 总是使用并不经常改动的大型代码体</p> 
<p>2. # 和 ##的作用？</p> 
<p>        #是宏参数 字符串替换运算符，## 是把两个 宏参数 连接起来的运算符</p> 
<p>        #define   STR(arg)        #arg      //STR(hello)     ---&gt; hello </p> 
<p>        #define  NAME(x,y)       x##y        //NAME(1,2)  ----&gt;12</p> 
<p>3.static 的用法</p> 
<p>        修饰局部变量，该变量（栈区）变成静态存储类型，该变量存在于内存的静态区，作用域不变。</p> 
<p>        修饰全局变量，该变量的作用域，只能在该文件中使用。不能在其他文件中通过extern引用</p> 
<p>        修饰函数，        静态函数只能在申明它的源文件中使用</p> 
<p>4. extern 关键字的作用</p> 
<p>        用来修饰变量或函数，表明该变量或函数都是在别的文件中定义的，提醒编译器在其他文件中寻找定义</p> 
<p>5. sizeof 的用法</p> 
<p>        计算对象或类型所占的内存字节数</p> 
<p>        sizeof 求得的结构体(及其对象)的大小，不等于各个数据成员大小之和</p> 
<p>sizeof运算符 和函数strlen的区别与用法</p> 
<p>        sizeof（）计算分配空间的字节数</p> 
<p>        strlen（）计算空间中的字符个数(不包括'\0')</p> 
<p>        char str[20] = {"hello world"};</p> 
<p>        int   a[10];</p> 
<p>        sizeof(str);      //20              sizeof(a);     //4*10        strlen(str);        //11</p> 
<p>6.结构体的赋值</p> 
<p>        C语言中对结构体变量的赋值##在初始化##或者在定义后按字段赋值</p> 
<p>       1. struct   dog{    char   a;  int   b;  }x={ 'a' ,2 };</p> 
<p>        2.定义结构体变量         struct dog  x  ={ 'a' ,2 };</p> 
<p>        按字段赋值</p> 
<p>        struct  dog  x;    x.a='a';     x.b =2;</p> 
<p>7.结构体变量如何比较？</p> 
<p>        int  memcmp( const void *s1, const void *s2, size_t  n)        //n 为比较长度</p> 
<p>        按字节来比较，如果超过数组长度，比较不会停止'\0' 之后继续比较下去，可能会出错</p> 
<p>        strcmp()        按字符比较，直到出现结果</p> 
<p>结构体成员数组大小为0，好处是可以在结构体中分配不定长的大小</p> 
<p>typedef  struct  st{<!-- --></p> 
<p>        int   a;</p> 
<p>        int   b;</p> 
<p>        char c[0];        //空数组</p> 
<p>} st_t;</p> 
<p>        sizeof(st_t)  == 8; //即 c[0] ==0</p> 
<p>8. malloc/free 与new/delete 的区别</p> 
<p>        1.malloc/free 是C/C++语言的标准库函数，new/delete 是C++的运算符，都是动态分配和释放内存。2.主要区别就是 new/delete 对象在创建和释放的时候会执行构造函数和析构函数</p> 
<p>9.C++里的类 和C里面的 struct 区别</p> 
<p>        C++     中的类具有成员保护功能，并且具有继承和多态的特点</p> 
<p>        C里面没有成员函数，可以有函数指针，不能继承和派生，但可以结构体嵌套</p> 
<p>10.主函数的写法</p> 
<p>        int main(void)  {} </p> 
<p>        int  main( int argc, char  *args[] ){}</p> 
<p>        argc  运行程序执行的参数个数 ， 第一个是程序本身   xx.out</p> 
<p>        args   指向字符串数组的指针   xx.out  ...</p> 
<p>11.printf（）；</p> 
<p>        int   a=10, b=20, c=30; </p> 
<p>        printf("%d  %d   %d\n",a+b+c, (b=b*2), (c=c*2) );  //  110  40  60   输出从右往左</p> 
<p>        float   double 的输出   %.2f  --- 输出两位小数，会自动进行四舍五入</p> 
<p>                     %8.2f --- 8是输出宽度，就是数据输出后在终端上占据8个 英文字母，不足的补空格</p> 
<p>                float  a= 13.141592f;</p> 
<p>                printf("%d\n", a );    //输出随机数，从内存里随机取来输出，不进行类型转换</p> 
<p>12. float  x 与 "零值 "的比较</p> 
<p>        const   float  ESP  = 0.000001f;  //参考量</p> 
<p>        float  x  = 0.0f;</p> 
<p>       if( x &gt;= -ESP &amp;&amp;  x &lt;= ESP ){  yes  } else { no  }</p> 
<p>        指针  int   *p =NULL;</p> 
<p>               if(p == NULL ){}</p> 
<p>13.操作符优先级问题</p> 
<p>        char  *ptr  = "Linux";        //在内存中占了 6个字节 '\0'</p> 
<p>        printf( "%c\n", *ptr++ );   // L 同一级，自右向左      ++*ptr ==M 编译报错，L常量不允许修改</p> 
<p>        printf("%c\n", *ptr);         // i</p> 
<p>        书写时多加(),</p> 
<p>        伪运算符 优先级最高()</p> 
<p>        单目大于双目  三目</p> 
<p>        算符运算符 &gt;  比较运算符 &gt; 位运算符  &gt; 逻辑运算符</p> 
<p>自右向左：只有单目(++ --)  三目  赋值运算符</p> 
<p>        三目运算： a?b:c?d:e  就是  a?b : (c?d:e )     //运算从左向右，结合从右向左</p> 
<p>14.逻辑短路问题 : 有逻辑运算参与    </p> 
<p>     int a=5,b=6,c=7,d=8,m=2,n=2;<br>     (m=a&lt;b)||(n=c&gt;d);    //m=1  ||或 为真所以右边的不会执行  n的值不变<br>     printf("%d\t%d\n",m,n);   //1  2<br>     <br>     (m=a&lt;b)&amp;&amp;(n=c&gt;d);   //true &amp;&amp; fause  m=1 n=0<br>     <br>     (n=c&gt;d)||(m=a&lt;b);   //n=0 m=1  ，||只要有一个为真最后的结果就为真</p> 
<p>    (n=c&gt;d)&amp;&amp;(m=a&lt;b); //逻辑短路  右边不会被运行</p> 
<p>     应用：<br>     if(strlen(name)!=0 &amp;&amp; strcmp(name,"admin") ==0 ){}  保证了程序的健壮性<br>     //name ==NULL 后面就不会执行<br>     <br>     递归终结条件<br>     int test(int n,int *sum)<br>     {<!-- --><br>         n &amp;&amp; test(n-1,sum);<br>         return *sum += n;<br>     }<br>     <br>     int ret =0;<br>     test(100,&amp;ret);   //1+2+3.....+100<br>     <br> 如果说不能使用循环，那么第一个应该想到 递归 重视逻辑短路问题</p> 
<p>15.分支<br>     int a=4;<br>     switch( a&gt;5 ){ case 0: ...}   //a&gt;5 判断表达式  假0  case 0会被执行<br>         switch( 3.14 )   //报错  不能放 float double<br>         //只能放整型(数)   ---char bool short long 枚举<br>         对于switch 控制表达式应该是整数类型，case也一样<br>         并且 case表达式转换后的值，不应该是相同的值 'a' ==97<br>         <br>     switch(a-4){  //2  普通表达式<br>         case 0:   ; break;<br>         case 1:   ;  break;<br>         <br>         case 2:   ;  break;  <br>         <br>         default:  //other <br>             printf("");<br>     }<br>    16.二维数组和一维数组的相互转化</p> 
<p>        将一维数组中的元素分别存入二维数组中</p> 
<p>    int a[9] ={1,2,3,4,5,6,7,8,9};   <br>         int b[3][3];<br>     (1).代码实现：<br>         int i, j, k=0;<br>         for(i=0; i&lt;3; i++){  //控制行<br>             for(j=0; j&lt;3; j++){  //控制列<br>                 b[i][j]=a[k]; k++;<br>             }<br>         }<br>     (2).借助边界<br>         for(i=0; i&lt;9; i++){   //控制数组a  <br>             b[0][i] = a[i];   //赋值 <br>         }<br>     (3).运算：<br>         for(i=0; i&lt;9; i++){<!-- --><br>             b[i/3][i%3] =a[i];<br>         }<br>         </p> 
<p>        二维数组转化为一维数组:<br>         int array1[A][B] ={1,2,3,4};   int array2[A*B];<br>         for(i=0; i&lt;A; i++){<!-- --><br>             for(j=0; j&lt;B; j++){<!-- --><br>                 array2[k] = array1[i][j];  //将二维数组的值一个个存入一维数组中<br>                 k++;<br>             }<br>         }<br> 17.字符串</p> 
<p>strcpy() 和memcpy()的区别？？</p> 
<p>        strcpy()  字符串拷贝，自动拷贝一个'\0'</p> 
<p>        memcpy(char *dst, const char *src,  size_t  len );  内存拷贝</p> 
<p>        区别：</p> 
<p>                strcpy()只能使用在字符串上，会自动拷贝'\0'</p> 
<p>                memcpy() 适用于各种类型，必须要指定长度</p> 
<p>char  name[10];</p> 
<p>gets(name);                 //当 name length ，超过10，内存越界，可能出错</p> 
<p>18.指针</p> 
<p>        char a;        //开辟一个字节的空间</p> 
<p>        char  *str =&amp;a;</p> 
<p>        strcpy(str, "hello");           //6 个字节的空间，越界 可能导致程序崩溃</p> 
<p>内存分区：<br>         栈区：函数参数 局部变量 系统管理(释放 回收)<br>         <br>         堆区：程序员管理(malloc/free)作用域 生命周期<br>         <br>         *静态存储区：全局变量 静态数据(static) 常量<br>             bss段：未初始化的全局变量、静态变量<br>             data段：初始化全局变量  静态变量  常量 <br>         <br>         代码区：程序代码</p> 
<p>int  main()</p> 
<p>{<!-- --></p> 
<p>char  *str = "abcd";   //str--栈区   "zbcd"--静态数据区-常量  不允许更改</p> 
<p>str[2] = 'f';        //程序崩溃  段错误--试图去修改不属于你的内存空间</p> 
<p>}</p> 
<p>int  *p;----&gt;malloc(p); -----&gt;free() -----&gt;p= NULL;</p> 
<p>自己开辟的空间free之后一定要记得置空---清理</p> 
<p>数组和指针相结合？/</p> 
<p>        int  a[5] = {1,2,3,4,5};</p> 
<p>        int   *ptr =(int *)(&amp;a+1);   //&amp;a[0] --取的是整个数组，指向数组尾部</p> 
<p>        printf("%d  %d\n", *(a+1), *(ptr-1) );        //2, 5</p> 
<p>        a[0] 第一个元素的首地址，  第一个字节 ，用首地址来表示整个数组</p> 
<p>19.不定长函数参数</p> 
<p>        （传参1，传参2，...）</p> 
<p>        printf(const char *format, ...);    //也是一个不同的函数，可以传不同的参数，打印出来</p> 
<p>                //  ...  可以传任意长度的参数---变长参数</p> 
<p>        va_start(va_list arg_ptr ,prev_param);<br>          //以固定参数的地址作为起点，确定变长参数的内存起始地址，获取第一个变长参数的首地址<br>     <br>             va_arg(va_list arg_ptr,type);  //获取每个变长参数  返回的参数类型<br>             va_end(va_list arg_ptr);  //将va_list 类型的arg_ptr置0<br>     </p> 
<p>20.const    不可改变的变量</p> 
<p>        char   const  *p1;</p> 
<p>        const  char   *p2;    //p1 and  p2可以指向不同的空间，指向的变量的内容不能改变</p> 
<p>        char  *const  p3;    //不可以指向其它空间，可以修改里面的内容</p> 
<p>21.结构体</p> 
<p>        //#pragma    pack(n)   //宏定义 指定对齐模数n  必须是2的整数倍</p> 
<p>        字节对齐</p> 
<p>        第一原则：</p> 
<p>        对齐模数     32位机器---4字节     64位机器---8字节</p> 
<p>        第二原则：</p> 
<p>              按照对齐模数和  结构体中最大的数据类型大小比较 ，以比较小的那个数据大小进行对齐</p> 
<p>        第三原则：</p> 
<p>                结构体中第一个数据放在 offset 为0的位置，每个数据，存储的起始位置，必须是自身大小的整数倍</p> 
<pre><code>	struct {
		short a;
		short b;
		short c;
	}C;     sizeof(C) ==6;
	
	struct {
		char a;
		short b;   //2
		int c;  //1*11 1111          
	}d;    sizeof(d)==8;   四字节对齐 cpu取数据 一次取四个字节(char short) 
	
	struct {
		char a;
		int c;  //1*** 1111 11** 
		short b;   //2         
	}f;   //12    四字节对齐 cpu取数据 int要取两次 ,被拆开不符合规则  

	struct {
		char a;
		short b;
		char c;
		int d;  //4
	}e;    //sizeof(e) ==12
	
</code></pre> 
<p>22.联合体和大小端问题   </p> 
<pre><code class="language-cpp">union xx{        //联合体整个空间是 最大成员在空间中的大小
    short a;
    char b[sizeof(a) ];   //short 在不同的编译器中所占的字节不同
} kk;

if(sizeof(a) ==2){
    kk.a =0x1234;   //看这个数据字这片空间 里是怎样存储的就知道大小端
    if(kk.b[0] ==0x12 ){
        printf("big");  //高字节存储在低地址
    }else {
        printf("small");
    }
}
</code></pre> 
<p>23.C语言文件操作</p> 
<p>        文件拷贝，实现一个函数</p> 
<pre><code class="language-cpp">int  copy_file(const char *srcFilename, const char desFilename)
{
    //打开文件 r r+  rw  w+
    FILE *fp =fopen(srcFilename , "r");
    if(fp&lt;0){
        printf("%s没有打开成功\n",srcFilename);
        return -1;
    }
   FILE *fp1 =fopen(desFilename , "w");
    if(fp&lt;0){
        printf("%s没有打开成功\n",desFilename);
        return -1;
    }
    /*
        fgetc()        fputc()
        fgets()        fputs()
        fscanf()       fprintf()  格式化写
        fread()        fwrite()   二进制写
    */ 
    char ch = '\0';
    while(EOF != (ch =fgetc(fp) )){  //文件结束 =EOF
        fputc(ch, fp1);
    }  
        
    fclose(fp);  fclose(fp1);
    fp =NULL;  fp1=NULL;

  
    return 0;
}</code></pre> 
<p>24.代码改错题</p> 
<pre><code>int main(int argc, char *argv[] )
{
	char *ptr = (char *)malloc(10);
	if(NULL ==ptr ){
		printf("\nmalloc failed\n");
		exit(1);			//return -1;
	}else if(argc ==1 ){
		printf("\n Usage \n");
	}else{
		memset(ptr, '\n', 10);
		strnpy(ptr, argv[1],9);
		while( *ptr != 'z'){
			if(*ptr ==' ')  break;
			else ptr++;   //指针的指向改变了
		}
		if(*ptr =='z'){
			printf("stream contained 'z'\n");
		}
		free(ptr);  //zhhgg--没问题 freez释放不属于自己的空间 ,段错误 
	}
}</code></pre> 
<p>25.exit() 的用法</p> 
<p>exit(num);   &lt;stdlib.h&gt;<br>     <br>     根据 num的值，知道程序退出的原因<br>     num =0 正常退出<br>     !0     不正常退出 <br>     <br>     int main(int argc, char *argv[])<br>     {<!-- --><br>         if(argc ==1){<!-- --><br>             exit(1);<br>         }else{<!-- --><br>             exit(0);<br>         }<br>         return 0;<br>     }<br>     脚本：exit.sh <br>     gcc exit.c -o exit <br>     ./exit<br>     echo $?<br>     ./exit asd<br>     echo $?    ## $？程序退出的返回码<br>     <br>     system("touch aa");  //终端创建一个文件 aa <br>     <br>     system("rm -rvf aa");  //删除 aa <br>     <br>     atexit(func);   //func 函数名/函数指针 --当退出的时候<br>     每次调用 exit();的时候，都会去调用这个传入的函数func<br>         一般用来作为程序结束前的清理工作<br>     注：<br>         传入的函数，必须是无参数的<br>         可以传入32个，调用的顺序和传入的顺序相反<br>         <br>         _exit(1)  &lt;unistd.h&gt;   运行到该函数，直接退出程序 ，并不会执行绑定的函数</p> 
<p>26.函数返回值</p> 
<p>int fun(int val)<br> {<!-- --><br>     int a =val;<br>     a++;<br>     return &amp;a;   //局部变量的地址，函数结束，这片内存就销毁了<br> }</p> 
<p>int main()<br> {<!-- --><br>     int a = 10;<br>     int *val = fun(a);   //可能会出现段错误 <br> }<br>    // 多文件编程 全局变量(同名变量)不可以定义在多个.c 文件中<br>     //static 修饰 变成静态变量，模块化只能在本文件中使用<br>     <br>     作用域大的值和作用域小的值同名，则会使用作用域小的值<br> 27.    代码改错题</p> 
<pre><code>void  strcopy(void)
{
    char *src = "hello world";
	char *dest =NULL;
	int len =strlen(src);  //不包含'\0',计算的是有效字符的长度
	dest = (char *)malloc(len+1);  //多开辟一个字节大小的空间  malloc(len)
	char *d = dest;
	char *s = &amp;src[len-1];  //指向'\0' 前的一个字符(有效字符) src[len]
	// '\0'字符串的结束标志
	while(len-- != 0)
	{
		*d++ = *s--;  //直接指针赋值不允许  d++ = s--;
	}
	*d = '\0';
	free(dest);
	dest =NULL;

}</code></pre> 
<p>    28.将小写字母转换成大写字母</p> 
<pre><code>void upperCase(char str[] )
{
	int i=0;     //sizeof(str)==8 ---指针大小的长度
	//越界  
	for(i=0; i&lt;sizeof(str)/sizeof(str[0]); ++i){
		if('a' &lt;= str[i] &amp;&amp; str[i] &lt;= 'z'){
			str[i] -= ('a' -'A');  // -32
		}
	}
}

int main()
{
	char str[] ="aGsHbvsggdgg"; 
	//sizeof(str) 获取的是数据在内存中占据的空间大小  --字符串个数+1
	/*用法：
		1.只能获取静态数组的大小
		2.malloc 不能，动态的
		3.函数传入的数组大小 ，也不能获取  */
	return 0;
}</code></pre> 
<p>29.内存分配和二级指针</p> 
<p>堆 heap  ---(空闲表)--有空间就可以申请，使用完free就放回这个--空闲表 <br> 栈 stack</p> 
<p>char *p1;<br> int main()<br> {<!-- --><br>     char s[] = "abc";  //栈区--数组 <br>     char *p = "123456";   //p 栈区  "123456" 常量数据区<br>     <br>     p1 = (char*)malloc(10);  //堆区 <br>     strcpy(p1, "123456");   //常量数据区<br> }</p> 
<p>二级指针：指向指针的指针<br>     如何在函数中更改一级指针呢？<br>         传二级指针<br>     void change(int **a, int **b)<br>     {<!-- --><br>         *a= *b;   //更改一级指针<br>     }<br>         <br>     int main()<br>     {<!-- --><br>         int a=5,b=6;<br>         int *c= &amp;a,*d = &amp;b;<br>         change(&amp;c, &amp;d);<br>         printf("%d\n", *c);  //6<br>         <br>     }</p> 
<p>30.联合(共用)体</p> 
<p>联合体的大小--取决于它所有的成员中占用空间最大的一个成员的大小<br>     <br> union u1{<!-- --><br>     double a;<br>     int b;<br> };    //8</p> 
<p>union u2{<!-- --><br>     char a[13];<br>     int b;   <br> };    //16   ---int 四字节对齐</p> 
<p>union u3{<!-- --><br>     char a[13];<br>     char b;<br> };    //13  一字节对齐</p> 
<p>不仅仅union，对于别的复合数据类型，如union,struct ,class 的对齐方式为成员中最大的成员--对齐方式</p> 
<p>可以使用 #pragma pack(x),可以改变编译器的对齐方式</p> 
<p>31.int (*a[10])(int) 的含义</p> 
<p>        从右向左，由远及近，括号优先</p> 
<p>        a是一个数组，里面存放的是指针，所存的指针是指向有一个int形参的函数，函数的返回值是int型。</p> 
<p>32.如何让程序跳转到 0地址执行？</p> 
<p>        C语言程序跳转需要调用函数 /函数指针</p> 
<p>        typedef  void (*Fun_t)(void)</p> 
<p>        Fun_t  fun =(Fun_t)0;     //初始化函数指针</p> 
<p>        fun();</p> 
<p>33.带参宏和带参函数的区别</p> 
<p>        主要是看它们处理的时间，参数类型，程序长度，运行时间。</p> 
<p>        带参宏，编译时展开，没有参数类型，程序变长，不占运行时间</p> 
<p>        带参函数，运行时处理，参数类型需定义，函数调用和返回时耗费时间</p> 
<p>34.volitile 的用法--易变的</p> 
<p>        修饰变量，告诉编译器不要缓存到寄存器，每次直接读取该地址</p> 
<p>        用途:1.并行设备的硬件寄存器 (如：状态寄存器)<br>                 2.一个中断服务子程序中会访问到非自动变量<br>                 3.多进程中会被几个任务 共享的变量<br>   </p> 
<hr> 
<p>         这是我自动总结的，难免会有出错的 </p> 
<p>如果有什么不对的，欢迎在评论区留言</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2df9df5422f294af4d7668d7881fff0a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySql主从复制原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e7ead39f3bc624ef3c6d582ba75a121/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DX机器人 评论区</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>