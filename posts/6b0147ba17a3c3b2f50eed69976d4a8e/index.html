<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>堆排序必知重要点 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="堆排序必知重要点" />
<meta property="og:description" content="目录
1、完整堆排序代码
2、为什么要从 length/2-1处开始构建
3、堆调整过程中为什么还需要循环
本文就不讲述堆排序的概念了，只讲2个重点，理清楚了这两个重点，才算真正理解了堆排序。
1、完整堆排序代码 public static void main(String[] args) { int[] nums = {7,8,2,9,3,1,90,88,33}; heapSort(nums); for (int i = 0; i &lt; nums.length; i&#43;&#43;) { System.out.println(nums[i]); } } public static void heapSort(int[] nums){ int length = nums.length; //从这里开始构造大顶堆 int start = length/2-1; //构造大顶堆 for (int i = start;i&gt;=0;i--) { heapAdjust(nums,i,length); } //重新构造大顶堆 for (int i = length; i &gt;=3; i--) { swap(nums,0,i-1); heapAdjust(nums,0,i-1); } //最后剩第0个和第1个元素 if (nums[0] &gt; nums[1]){ swap(nums,0,1); } } public static void heapAdjust(int[] nums,int start,int length){ if (length == 2){ return; } int k = 2 * start &#43; 1; if (nums[k &#43; 1] &gt; nums[k]){ k&#43;&#43;; } if (nums[k] &gt; nums[start]){ //交换 swap(nums,start,k); //交换之后需要重新构建 for (int i = 2 * start &#43; 1; i &lt; length/2-1; i&#43;&#43;) { heapAdjust(nums,i,length); } } } public static void swap(int[] nums,int i,int j){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } 2、为什么要从 length/2-1处开始构建 因为对于一个完全二叉树来说，length/2-1 所对应的节点是 倒数第二层，从右往左 第一个非叶子节点。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6b0147ba17a3c3b2f50eed69976d4a8e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-22T15:06:23+08:00" />
<meta property="article:modified_time" content="2023-07-22T15:06:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">堆排序必知重要点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="1%E3%80%81%E5%AE%8C%E6%95%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%AE%8C%E6%95%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81" rel="nofollow">1、完整堆排序代码</a></p> 
<p id="2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BB%8E%20length%2F2-1%E5%A4%84%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BB%8E%20length%2F2-1%E5%A4%84%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA" rel="nofollow">2、为什么要从 length/2-1处开始构建</a></p> 
<p id="3%E3%80%81%E5%A0%86%E8%B0%83%E6%95%B4%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E5%BE%AA%E7%8E%AF-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%A0%86%E8%B0%83%E6%95%B4%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E5%BE%AA%E7%8E%AF" rel="nofollow">3、堆调整过程中为什么还需要循环</a></p> 
<hr id="hr-toc"> 
<p>本文就不讲述堆排序的概念了，只讲2个重点，理清楚了这两个重点，才算真正理解了堆排序。</p> 
<h3 id="1%E3%80%81%E5%AE%8C%E6%95%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81">1、完整堆排序代码</h3> 
<pre><code class="language-java">public static void main(String[] args) {
        int[] nums = {7,8,2,9,3,1,90,88,33};
        heapSort(nums);
        for (int i = 0; i &lt; nums.length; i++) {
            System.out.println(nums[i]);
        }
    }



    public static void heapSort(int[] nums){
        int length = nums.length;
        //从这里开始构造大顶堆
        int start = length/2-1;

        //构造大顶堆
        for (int i = start;i&gt;=0;i--) {
            heapAdjust(nums,i,length);
        }
        //重新构造大顶堆
        for (int i = length; i &gt;=3; i--) {
            swap(nums,0,i-1);
            heapAdjust(nums,0,i-1);
        }
        //最后剩第0个和第1个元素
        if (nums[0] &gt; nums[1]){
            swap(nums,0,1);
        }
    }
    
    public static void heapAdjust(int[] nums,int start,int length){
        if (length == 2){
            return;
        }
        int k = 2 * start + 1;
        if (nums[k + 1] &gt; nums[k]){
            k++;
        }
        if (nums[k] &gt; nums[start]){
            //交换
            swap(nums,start,k);

            //交换之后需要重新构建
            for (int i = 2 * start + 1; i &lt; length/2-1; i++) {
                heapAdjust(nums,i,length);
            }
        }
    }
    
    public static void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
</code></pre> 
<h3 id="2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BB%8E%20length%2F2-1%E5%A4%84%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA">2、为什么要从 length/2-1处开始构建</h3> 
<p><img alt="" height="470" src="https://images2.imgbox.com/17/d4/cRpAXuK8_o.png" width="1025"></p> 
<p><span style="color:#fe2c24;"><strong>因为对于一个完全二叉树来说，length/2-1 所对应的节点是 倒数第二层，从右往左 第一个非叶子节点。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>看图1</strong></span></p> 
<p><img alt="" height="475" src="https://images2.imgbox.com/61/77/iQw3tvzf_o.png" width="1163"></p> 
<p><strong> 看图2</strong></p> 
<p> ​​​​​<img alt="" height="452" src="https://images2.imgbox.com/b0/09/lopufN0c_o.png" width="1053"> 大家自己可以试下更多的场景，一定是满足 <span style="color:#fe2c24;"><strong>倒数第二层，从右往左 第一个非叶子节点</strong></span> 这个规则的。这个对于大家理解堆排序是至关重要的。</p> 
<p><img alt="" height="469" src="https://images2.imgbox.com/13/20/5pLs0Afo_o.png" width="844"></p> 
<p> 构造堆的循环就是从  倒数第二层，从右往左，从第一个非叶子节点开始，从右往左再往上一层循环 构建的这么一个步骤。</p> 
<p><img alt="" height="557" src="https://images2.imgbox.com/67/9c/q73lpe7D_o.png" width="1036"></p> 
<p> </p> 
<h3 id="3%E3%80%81%E5%A0%86%E8%B0%83%E6%95%B4%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E5%BE%AA%E7%8E%AF">3、堆调整过程中为什么还需要循环</h3> 
<p>先来看待排序的数组</p> 
<pre><code class="language-java">int[] nums = {7,8,2,9,3,1,90,88,33};</code></pre> 
<p>转化成完全二叉树如下图所示</p> 
<p><img alt="" height="504" src="https://images2.imgbox.com/ac/de/PvylX9EZ_o.png" width="989"> 该数组中</p> 
<p><img alt="" height="641" src="https://images2.imgbox.com/61/aa/EEmzpbaj_o.png" width="1200"> </p> 
<p> <img alt="" height="614" src="https://images2.imgbox.com/4c/bd/SbnuruEA_o.png" width="1200"></p> 
<p>经过第一次构建之后,  <strong><span style="background-color:#fe2c24;">88 </span></strong>和 <strong><span style="background-color:#fe2c24;">9 </span></strong>交换位置 变成</p> 
<p><img alt="" height="543" src="https://images2.imgbox.com/e4/6d/310iOaHW_o.png" width="1017"> </p> 
<p> 继续排序<strong><span style="background-color:#fe2c24;"> 8、88、3</span></strong>这三个节点，88和8需要交换</p> 
<p> <img alt="" height="486" src="https://images2.imgbox.com/ea/f9/puo6s4hM_o.png" width="909"></p> 
<p> </p> 
<p> 8和88交换之后，<strong><span style="background-color:#fe2c24;">8、33、33 </span></strong>不满足规则   nums[i] &gt; nums[2*i+1]，所以需要继续交换。这也是</p> 
<p>需要这个循环的原因</p> 
<p><img alt="" height="501" src="https://images2.imgbox.com/58/3a/MU5VMn5p_o.png" width="1125"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/545122bcff294fe601c4699e6f60ae3b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C# IO FileStream流（一）使用整理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5dcf4d2c1f751cdb74510a18b2e49073/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MarkdownQuote：简化 Markdown 中的代码引用！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>