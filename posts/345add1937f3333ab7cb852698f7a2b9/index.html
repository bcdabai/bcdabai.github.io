<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ELK——一套实用、易用的监控架构 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ELK——一套实用、易用的监控架构" />
<meta property="og:description" content="目录
ELK是什么
ELK的主要优点
为什么要使用elk
ELK 的好处：
elk组件的作用
elasticsearch核心概念（属于elk的老大）
分片的两个最主要原因:
logstash的基本概念
Kibana 主要功能
ELK工作原理
使用场景
搭建elk
​ 使用插件管理 登录 Apache主机 做对接配置
安装kibana
对接Apache主机的Apache 日志文件（访问的、错误的）
启动日志
总结
本次所用到的软件包
ELK是什么 通俗来讲，ELK是由Elasticsearch（日志存储和搜索）、Logstash（日志收集）、Kibana（查看日志）三个开源软件的组成的一个组合体，ELK是elastic公司研发的一套完整的日志收集、分析和展示的企业级解决方案，在这三个软件当中，每个软件用于完成不同的功能，ELK又称为ELKstack。 官方域名为elastic.co。
ELK的主要优点 处理方式灵活：elasticsearch是实时全文索引，具有强大的搜索功能 （支持任意key全文搜索）
配置相对简单：elasticsearch的API全部使用JSON接口，logstash使用模块配置，kibana的配置文件部分更简单。
检索性能高效：基于优秀的设计，虽然每次查询都是实时，但是也可以达到百亿级数据的查询秒级响应。
集群线性扩展：elasticsearch和logstash都可以灵活线性扩展，节点读写出现瓶颈可以扩容（3 5 7 11个服务器）
前端操作绚丽：kibana的前端设计比较绚丽，而且操作简单（早期比较简单）
为什么要使用elk ELK 组件在海量日志系统的运维中，可用于解决以下主要问题：- 分布式日志数据统一收集，实现集中式查询和管理
故障排查
安全信息和事件管理
报表功能
ELK 的好处： ELK 组件在大数据运维系统中，主要可解决的问题如下：
日志查询，问题排查，故障恢复，故障自愈
应用日志分析，错误报警
性能分析，用户行为分析
elk组件的作用 elasticsearch核心概念（属于elk的老大） 1、接近实时(NRT)
elasticsearch是一个接近实时的搜索平台，这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒)
2、集群(cluster)
一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。其中一个节点为主节点，这个主节点是可以通过选举产生的，并提供跨节点的联合索引和搜索的功能。集群有一个唯一性标示的名字，默认是elasticsearch,集群名字很重要，每个节点是基于集群名字加入到其集群中的。因此，确保在不同环境中使用不同的集群名字。 一个集群可以只有一个节点。强烈建议在配置elasticsearch时，配置成集群模式。
3、节点（node)
节点就是一台单一的服务器，是集群的一部分，存储数据并参与集群的索引和搜索功能。像集群一样，节点也是通过名字来标识默认是在节点启动时随机分配的字符名。当然，你可以自己定义。该名字也很重要，在集群中用于识别服务器对应的节点。
节点可以通过指定集群名字来加入到集群中。默认情况，每个节点被设置成加入到elasticsearch集群。如果启动了多个节点，假设能自动发现对方，他们将会自动组建一个名为elasticsearch的集群。
4、索引(index)
一个索引就是一个拥有几分相似特征的文档的集合。
比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，如果你想，可以定义任意多的索引。
●索引相对于关系型数据库的库。
5、类型（type）
在一个索引中，你可以定义一种或多种类型。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/345add1937f3333ab7cb852698f7a2b9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-30T22:46:09+08:00" />
<meta property="article:modified_time" content="2021-12-30T22:46:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ELK——一套实用、易用的监控架构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="ELK%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:0px;"><a href="#ELK%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">ELK是什么</a></p> 
<p id="ELK%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9-toc" style="margin-left:80px;"><a href="#ELK%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9" rel="nofollow">ELK的主要优点</a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8elk-toc" style="margin-left:0px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8elk" rel="nofollow">为什么要使用elk</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0ELK%20%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0ELK%20%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A" rel="nofollow">                ELK 的好处：</a></p> 
<p id="elk%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:0px;"><a href="#elk%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">elk组件的作用</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20elasticsearch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%88%E5%B1%9E%E4%BA%8Eelk%E7%9A%84%E8%80%81%E5%A4%A7%EF%BC%89-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20elasticsearch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%88%E5%B1%9E%E4%BA%8Eelk%E7%9A%84%E8%80%81%E5%A4%A7%EF%BC%89" rel="nofollow">        elasticsearch核心概念（属于elk的老大）</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%88%86%E7%89%87%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%9C%80%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%3A-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%88%86%E7%89%87%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%9C%80%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%3A" rel="nofollow">                分片的两个最主要原因:</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20logstash%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20logstash%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">        logstash的基本概念</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0Kibana%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0Kibana%C2%A0" rel="nofollow">        Kibana </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD" rel="nofollow">                主要功能</a></p> 
<p id="ELK%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#ELK%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">ELK工作原理</a></p> 
<p id="%C2%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow"> 使用场景</a></p> 
<p id="%E6%90%AD%E5%BB%BAelk-toc" style="margin-left:0px;"><a href="#%E6%90%AD%E5%BB%BAelk" rel="nofollow">搭建elk</a></p> 
<p id="%E2%80%8B%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%C2%A0-toc" style="margin-left:80px;"><a href="#%E2%80%8B%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%C2%A0" rel="nofollow">​                使用插件管理 </a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%99%BB%E5%BD%95%20Apache%E4%B8%BB%E6%9C%BA%20%E5%81%9A%E5%AF%B9%E6%8E%A5%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%99%BB%E5%BD%95%20Apache%E4%B8%BB%E6%9C%BA%20%E5%81%9A%E5%AF%B9%E6%8E%A5%E9%85%8D%E7%BD%AE" rel="nofollow">                登录 Apache主机 做对接配置</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%AE%89%E8%A3%85kibana-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%AE%89%E8%A3%85kibana" rel="nofollow">                安装kibana</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%AF%B9%E6%8E%A5Apache%E4%B8%BB%E6%9C%BA%E7%9A%84Apache%20%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%EF%BC%88%E8%AE%BF%E9%97%AE%E7%9A%84%E3%80%81%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%89-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%AF%B9%E6%8E%A5Apache%E4%B8%BB%E6%9C%BA%E7%9A%84Apache%20%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%EF%BC%88%E8%AE%BF%E9%97%AE%E7%9A%84%E3%80%81%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%89" rel="nofollow">                对接Apache主机的Apache 日志文件（访问的、错误的）</a></p> 
<p id="%C2%A0%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97" rel="nofollow"> 启动日志</a></p> 
<p id="%C2%A0%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%C2%A0%E6%80%BB%E7%BB%93" rel="nofollow"> 总结</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%9C%AC%E6%AC%A1%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%9C%AC%E6%AC%A1%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85" rel="nofollow">                本次所用到的软件包</a></p> 
<hr id="hr-toc"> 
<h2 id="ELK%E6%98%AF%E4%BB%80%E4%B9%88">ELK是什么</h2> 
<p>        通俗来讲，ELK是由<span style="background-color:#ffd900;">Elasticsearch（日志存储和搜索</span>）、<span style="background-color:#ffd900;">Logstash（日志收集）</span>、<span style="background-color:#ffd900;">Kibana（查看日志）</span>三个开源软件的组成的一个组合体，ELK是elastic公司研发的一套完整的日志收集、分析和展示的企业级解决方案，在这三个软件当中，每个软件用于完成不同的功能，ELK又称为ELKstack。 官方域名为elastic.co。</p> 
<h4 id="ELK%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9">ELK的主要优点</h4> 
<ol><li> <p>处理方式灵活：elasticsearch是实时全文索引，具有强大的搜索功能 （支持任意key全文搜索）</p> </li><li> <p>配置相对简单：elasticsearch的API全部使用JSON接口，logstash使用模块配置，kibana的配置文件部分更简单。</p> </li><li> <p>检索性能高效：基于优秀的设计，虽然每次查询都是实时，但是也可以达到百亿级数据的查询秒级响应。</p> </li><li> <p>集群线性扩展：elasticsearch和logstash都可以灵活线性扩展，节点读写出现瓶颈可以扩容（3 5 7 11个服务器）</p> </li><li> <p>前端操作绚丽：kibana的前端设计比较绚丽，而且操作简单（早期比较简单）</p> </li></ol> 
<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8elk">为什么要使用elk</h2> 
<p>        ELK 组件在海量日志系统的运维中，可用于解决以下主要问题：- 分布式日志数据统一收集，实现集中式查询和管理</p> 
<ol><li> <p>故障排查</p> </li><li> <p>安全信息和事件管理</p> </li><li> <p>报表功能</p> </li></ol> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0ELK%20%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A"><strong>                ELK</strong> <strong>的好处：</strong></h4> 
<p>ELK 组件在大数据运维系统中，主要可解决的问题如下：</p> 
<ol><li> <p>日志查询，问题排查，故障恢复，故障自愈</p> </li><li> <p>应用日志分析，错误报警</p> </li><li> <p>性能分析，用户行为分析</p> </li></ol> 
<h2 id="elk%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8">elk组件的作用</h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20elasticsearch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%88%E5%B1%9E%E4%BA%8Eelk%E7%9A%84%E8%80%81%E5%A4%A7%EF%BC%89">        elasticsearch核心概念（属于elk的老大）</h3> 
<p>1、<strong>接近实时(NRT)</strong></p> 
<p>        elasticsearch是一个接近实时的搜索平台，这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒)</p> 
<p>2、<strong>集群(cluster)</strong></p> 
<p>        一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。其中一个节点为主节点，这个主节点是可以通过选举产生的，并提供跨节点的联合索引和搜索的功能。集群有一个唯一性标示的名字，默认是elasticsearch,集群名字很重要，每个节点是基于集群名字加入到其集群中的。因此，确保在不同环境中使用不同的集群名字。 一个集群可以只有一个节点。<span style="color:#fe2c24;">强烈建议在配置elasticsearch时，配置成集群模式。</span></p> 
<p>3、<strong>节点（node)</strong></p> 
<p>        节点就是一台单一的服务器，是集群的一部分，存储数据并参与集群的索引和搜索功能。像集群一样，节点也是通过名字来标识默认是在节点启动时随机分配的字符名。当然，你可以自己定义。该名字也很重要，在集群中用于识别服务器对应的节点。</p> 
<p>         节点可以通过指定集群名字来加入到集群中。默认情况，每个节点被设置成加入到elasticsearch集群。如果启动了多个节点，假设能自动发现对方，他们将会自动组建一个名为elasticsearch的集群。</p> 
<p>4、<strong>索引(index)</strong></p> 
<p>        一个索引就是一个拥有几分相似特征的文档的集合。</p> 
<blockquote> 
 <p>比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，如果你想，可以定义任意多的索引。</p> 
</blockquote> 
<p>        ●索引相对于关系型数据库的库。</p> 
<p>5、<strong>类型（type）</strong></p> 
<p>         在一个索引中，你可以定义一种或多种类型。</p> 
<blockquote> 
 <p>一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。 ●类型相对于关系型数据库的表</p> 
</blockquote> 
<p>6、<strong>文档（document）</strong></p> 
<p>        一个文档是一个可被索引的基础信息单元。</p> 
<blockquote> 
 <p>        比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以<span style="color:#fe2c24;">SON(Javascript Object NMotation）</span>格式来表示，而JSON是一个到处存在的互联网数据交互格式。 在一个index/type里面，只要你想，你可以存储任意多的文档。注意，虽然一个文档在物理上位于一个索引中，实际上一个文档必须在一个索引内被索引和分配一个类型。 ●文档相对于关系型数据库的列。</p> 
</blockquote> 
<p>7、<strong>分片和副本(shards &amp; replicas )</strong></p> 
<p>        在实际情况下，索引存储的数据可能超过单个节点的硬件限制。</p> 
<blockquote> 
 <p>        如一个10亿文档需1TB空间可能不适合存储在单个节点的磁盘上， 或者从单个节点搜索请求太慢了。为了解决这个问题，elasticsearch提供将索引分成多个分片的功能。当在创建索引时，可以定义想要分片的数量。每一个分片就是一个全功能的独立的索引，可以位于集群中任何节点上。</p> 
</blockquote> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%88%86%E7%89%87%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%9C%80%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%3A"><strong>                分片的两个最主要原因:</strong></h4> 
<p>        1、水平分割扩展，增大存储量</p> 
<p>        2、分布式并行跨分片操作,提高性能和吞吐量</p> 
<p>        分布式分片的机制和搜索请求的文档如何汇总完全是有elasticsearch控制的，这些对用户而言是透明的。 <strong>网络问题等等其它问题可以在任何时候不期而至，为了健壮性，强烈建议要有一个故障切换机制，无论何种故障以防止分片或者节点不可用。</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e1/83/fMdIz3Zz_o.png"></p> 
<p>        为此，elasticsearch让我们将索引分片复制一份或多份，称之为分片副本或副本。 ​ <strong>副本也有两个最主要原因:</strong></p> 
<p>a．高可用性，以应对分片或者节点故障。出于这个原因，分片副本要在不同的节点上。 b. 读写性能，增大吞吐量，搜索可以并行在所有副本上执行。</p> 
<p><span style="background-color:#ffd900;">        总之，每个索引可以被分成多个分片。一个索引也可以被复制0次(意思是没有复制)或多次。一旦复制了，每个索引就有了主分片(作为复制源的原来的分片）和复制分片(主分片的拷贝)之别。分片和副本的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变副本的数量，但是你事后不能改变分片的数量</span></p> 
<p></p> 
<blockquote> 
 <p>        默认情况下，Elasticsearch中的每个索引被分片<strong>5个主分片和1个副本</strong>，这意味着, 如果你的集群中至少有两个节点，你的索引将会有5个主分片 和另外5个副本分片(1个完全拷贝），这样的话每个索引总共就有10个分片。</p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20logstash%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">        logstash的基本概念</h3> 
<p>         Logstash由JRuby语言编写，基于消息(message-based）的简单架构，并运行在Java虚拟机(JVM)上。不同于分离的代理端〈agent)或主机端（server),LogStash可配置单一的代理端（agent）与其它开源软件结合，以实现不同的功能。 </p> 
<p>        Logstash 是一个具有实时传输能力的数据收集引擎，其可以通过插件实现日志收集和转发，支持日志过滤，支持普通 log、自定义 json 格式的日志解析，最终把经过处理的日志发送给 elasticsearch。    </p> 
<p><strong>它由三部分组成</strong></p> 
<ul><li> <p>Shipper－发送日志数据</p> </li><li> <p>Broker－收集数据，缺省内置 Redis</p> </li><li> <p>Indexer－数据写入</p> </li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/31/28/eZZ3yc3n_o.png"></p> 
<p></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0Kibana%C2%A0">        Kibana </h3> 
<p>        是一款基于apache开源协议，使用JavaScript编写，为Elasticsearch提供分析和可视化的Web平台。它可以Elasticsearch的索引中查找，交互数据，并生成各种维度的表图就相当与一个前端数据的展示</p> 
<p>        Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。 ​ 使用Kibana，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板(dashboard）)实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编写代码，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">                主要功能</h4> 
<blockquote> 
 <p>1、Elasticsearch无缝之集成。Kibana架构为Elasticsearch定制，可以将任何结构化和非结构化数据加入Elasticsearch索引。Kibana还充分利用了Elasticsearch强大的搜索和分析功能。</p> 
 <p>2、整合你的数据。Kibana能够更好地处理海量数据，并据此创建柱形图、折线图、散点图、直方图、饼图和地图。</p> 
 <p>3、复杂数据分析。Kibana提升了Elasticsearch分析能力，能够更加智能地分析数据，执行数学转换并且根据要求对数据切割分块。</p> 
 <p>4、让更多团队成员受益。强大的数据库可视化接口让各业务岗位都能够从数据集合受益</p> 
 <p>5、接口灵活，分享更容易。使用Kibana可以更加方便地创建、保存、分享数据，并将可视化数据快速交流。</p> 
 <p>6、配置简单。Kibana的配置和启用非常简单，用户体验非常友好。Kibana自带web服务器，可以快速启动运行。</p> 
 <p>7、可视化多数据源。Kibana可以非常方便地把来自Logstash、BS-Hadoop、Beats或第三方技术的数据整合到Elasticsearch，支持的第三方技术包括Apache Flume、Fluentd等。</p> 
 <p>8、简单数据导出。Kibana可以方便地导出感兴趣的数据，与其它数据集合并融合后快速建模分析，发现新结果。</p> 
</blockquote> 
<h2 id="ELK%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">ELK工作原理</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/75/b0/aKX48g8k_o.png"></p> 
<p></p> 
<p>        logstash收集APPServer产生的log，并存放到Elasticsearch集群中，而kibana则从ES集群中查询数据生成图表，再返回给Browser</p> 
<p>经过的步骤</p> 
<p>1、将日志进行集中化管理（beats）</p> 
<ul><li><code>Packetbeat</code>（搜集网络流量数据）；</li><li><code>Topbeat</code>（搜集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）；</li><li><code>Filebeat</code>（搜集文件数据）；</li><li><code>Winlogbeat</code>（搜集 Windows 事件日志数据）</li></ul> 
<p>2、将日志格式化（logstash）</p> 
<p>3、对格式化后的数据进行索引和存储（elasticsearch）</p> 
<p>4、前端数据展示（kibana）</p> 
<h2 id="%C2%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"> 使用场景</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d9/47/6jj35LM3_o.png"></p> 
<p></p> 
<h2 id="%E6%90%AD%E5%BB%BAelk">搭建elk</h2> 
<blockquote> 
 <p>环境：</p> 
 <p>node1节点：192.168.37.101</p> 
 <p>node2节点：192.168.37.102</p> 
 <p>apache（web服务访问）：192.168.37.105</p> 
</blockquote> 
<p>我们需要在每台机器修改它的名字，好区分</p> 
<pre><code>hostnamectl set-hostname node1            #37.101
hostnamectl set-hostname node2            #37.102
hostnamectl set-hostname apache           #37.105</code></pre> 
<p>配置他们的映射文件（所有服务器）</p> 
<pre><code>[root@node1 ~]#vim /etc/hosts


....
192.168.37.101 node1
192.168.37.102 node2
192.168.37.105 apache
</code></pre> 
<p>可以ping通 </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a6/c6/TDVNnSAc_o.png"></p> 
<p> </p> 
<p> 查看jdk环境（环境自带的环境即可，因为不是在实际生产中）</p> 
<pre><code>[root@node1 config]#java -version
openjdk version "1.8.0_131"
OpenJDK Runtime Environment (build 1.8.0_131-b12)
OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)</code></pre> 
<p><strong>传入安装包elasticsearch-5.5.0.rpmgz并解压</strong></p> 
<pre><code>[root@node1 /opt]# ls
elasticsearch-5.5.0.rpm 
[root@node1 /opt]# rpm -ivh elasticsearch-5.5.0.rpm
</code></pre> 
<p>修改配置文件</p> 
<pre><code>
[root@node1 /etc/elasticsearch]# vim elasticsearch.yml</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/58/c9/WnCIG4Y4_o.png"></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/bb/d8/RtVYFKCP_o.png"></p> 
<p><strong> 查看一下我们所配置的文件</strong></p> 
<pre><code>[root@node1 /etc/elasticsearch]# grep -v "^#" elasticsearch.yml
cluster.name: my-application
node.name: node-1
path.data: /data/elk_data
path.logs: /var/log/elasticsearch/
bootstrap.memory_lock: false
network.host: 0.0.0.0
http.port: 9200
discovery.zen.ping.unicast.hosts: ["node1", "node2"]
</code></pre> 
<p>创建数据目录</p> 
<pre><code>[root@node1 /etc/elasticsearch]# mkdir -p /data/elk_data

</code></pre> 
<p>给属主属组权限</p> 
<pre><code>[root@node1 /etc/elasticsearch]# chown elasticsearch:elasticsearch /data/elk_data/</code></pre> 
<p>开启服务，查看9200端口是否开启</p> 
<pre><code>[root@node1 /etc/elasticsearch]# systemctl enable --now elasticsearch.service
Created symlink from /etc/systemd/system/multi-user.target.wants/elasticsearch.service to /usr/lib/systemd/system/elasticsearch.service.
[root@node1 /etc/elasticsearch]# ss -natp |grep 9200
LISTEN     0      128         :::9200                    :::*                   users:(("java",pid=71579,fd=243))
</code></pre> 
<p>去真机验证node1、node2</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5b/34/HgjSrQVn_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/03/02/RVl0pmuI_o.png"> </p> 
<p>查看集群的生命值</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2d/7e/4UjWeWAK_o.png"></p> 
<p>查看状态</p> 
<h4 id="%E2%80%8B%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%C2%A0"><img alt="" src="https://images2.imgbox.com/a4/50/NLw8A0oR_o.png">                使用插件管理 </h4> 
<p><strong>使用以上方式查看状态并不友好，可以通过 elasticsearch-head插件来直接管理 </strong></p> 
<p><strong>安装Elasticsearch-head插件</strong></p> 
<blockquote> 
 <p>Elasticsearch在5.0 版本后，Elasticsearch-head插件需要作为独立服务进行安装，需要使用npm.工具(Wodeas的包管理T具）安装。安装 Elasticsearch-head 需要提前安装好依赖软件node 和 phantomjs。<br> node:是一个基于 Chrome v8引擎的 JavaScript运行环境。</p> 
 <p>phantomjs:是一个基于websit 的JavaScriptAPI，可以理解为一个隐形的浏览器，任何基于webkit浏览器做的事情，它都可以做到。</p> 
</blockquote> 
<pre><code>root@node1 /etc/elasticsearch]# yum install gcc gcc-c++ make -y

###安装依赖环境
</code></pre> 
<p><strong> 上传node-v8.2.1.tar.gz到/opt</strong></p> 
<p><strong>解压</strong></p> 
<pre><code>
[root@node1 /opt]# tar zxf node-v8.2.1.tar.gz</code></pre> 
<p><strong>执行安装</strong></p> 
<pre><code>[root@node1 /opt/node-v8.2.1]# ./configure
</code></pre> 
<p><strong>编译安装等待时间较长</strong></p> 
<pre><code>[root@node2 /opt/node-v8.2.1]# make &amp;&amp; make install -j2
</code></pre> 
<p><strong><span style="background-color:#ffd900;">--------------------------------------------安装phantomjs------------------------------------------------</span></strong></p> 
<p>解压 </p> 
<pre><code>root@node1 /opt]# tar -jxf phantomjs-2.1.1-linux-x86_64.tar.bz2 -C /usr/local/src/</code></pre> 
<p>做一个软链接，让系统识别</p> 
<pre><code>[root@node2 /usr/local/src]# ln -s /usr/local/src/phantomjs-2.1.1-linux-x86_64/bin/* /usr/local/bin/
</code></pre> 
<p><strong><span style="background-color:#ffd900;">-------------------------------------------安装elasticsearch-head（两个节点上）-----------------------------</span></strong></p> 
<p> </p> 
<pre><code>[root@node1 /opt]# tar zxvf elasticsearch-head.tar.gz  -C /usr/local/src/</code></pre> 
<p>安装npm</p> 
<pre><code>
[root@node1 /usr/local/src/elasticsearch-head]# npm install</code></pre> 
<p>修改主配置文件</p> 
<pre><code>[root@node2 ~]# vim /etc/elasticsearch/elasticsearch.yml
</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/25/a8/WSn0KLzY_o.png"></p> 
<p><strong> 启动elasticsearch-head  启动服务器</strong></p> 
<p><strong>必须在安装目录下启动服务，进程会读取该目录下的 gruntfile.js文件，否则可能会启动失败</strong></p> 
<pre><code>
[root@node1 /usr/local/src/elasticsearch-head]# npm run start &amp;
[1] 118591
[root@node1 /usr/local/src/elasticsearch-head]#
&gt; elasticsearch-head@0.0.0 start /usr/local/src/elasticsearch-head
&gt; grunt server

Running "connect:server" (connect) task
Waiting forever...
Started connect web server on http://localhost:9100
</code></pre> 
<p>浏览器访问</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f5/c3/2uU6POwu_o.png"></p> 
<p> 创建一个索引</p> 
<pre><code>[root@node1 ~]#  curl -X PUT '192.168.37.101:9200/index-demo/test/1?pretty&amp;pretty' -H 'content-Type: application/json' -d '{"user":"zhangsan","mesg":"hello world"}
&gt; '
{
  "_index" : "index-demo",
  "_type" : "test",
  "_id" : "1",
  "_version" : 1,
  "result" : "created",
  "_shards" : {
    "total" : 2,
    "successful" : 2,
    "failed" : 0
  },
  "created" : true
}
</code></pre> 
<p>刷新页面</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4e/fd/UC11Pjrd_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e9/a6/yCnkFcm3_o.png"> </p> 
<p> </p> 
<p><strong> 上面图可以看见索引默认被分片5个，并且有一个副本</strong></p> 
<p></p> 
<p><strong><span style="background-color:#ffd900;">------------------------------------ ELK Logstash 部署（在Apache 节点上操作）-----------------</span></strong></p> 
<blockquote> 
 <p><strong>Logstash一般部署在需要监控其日志的服务器。在本案例中，Logstash 部署在Apache服务器上，用于收集Apache服务器的日志信息并发送到Elasticsearch。</strong></p> 
</blockquote> 
<p>解压logstash</p> 
<pre><code>[root@apache /opt]# rpm -ivh logstash-5.5.1.rpm
</code></pre> 
<p>做软链接</p> 
<pre><code>[root@apache /usr/share/logstash]# ln -s /usr/share/logstash/bin/logstash /usr/local/bin/
</code></pre> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%99%BB%E5%BD%95%20Apache%E4%B8%BB%E6%9C%BA%20%E5%81%9A%E5%AF%B9%E6%8E%A5%E9%85%8D%E7%BD%AE">                登录 Apache主机 做对接配置</h4> 
<p>对其他用户执行只读模式</p> 
<pre><code>[root@apache /usr/share/logstash]# chmod o+r /var/log/messages

[root@apache /usr/share/logstash]# ll /var/log/messages
-rw----r--. 1 root root 291885 Dec 30 08:10 /var/log/messages
</code></pre> 
<p><br> 添加配置文件</p> 
<pre><code>
[root@apache /usr/share/logstash]# vim /etc/logstash/conf.d/system.conf

input {
       file{
        path =&gt; "/var/log/messages"
        type =&gt; "system"
        start_position =&gt; "beginning"
        }
      }
output {
        elasticsearch {
          hosts =&gt; ["192.168.37.101:9200"]
          index =&gt; "system-%{+YYYY.MM.dd}"
          }
        }
</code></pre> 
<p>重启logstatsh</p> 
<pre><code>[root@apache /usr/share/logstash]# systemctl restart logstash.service
</code></pre> 
<p>去真机测试</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/56/31/gwFponoY_o.png"></p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%AE%89%E8%A3%85kibana">                安装kibana</h4> 
<p>在node1节点安装</p> 
<p>上传kibana-5.5.1-x86_64.rpm 到/usr/local/src目录</p> 
<pre><code>
[root@node1 /usr/local/src]# rpm -ivh kibana-5.5.1-x86_64.rpm
</code></pre> 
<p>修改配置文件最后备份一份</p> 
<pre><code>root@node1 /etc/kibana]# cp kibana.yml kibana.yml.bak
[root@node1 /etc/kibana]# vim kibana.yml</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/81/97/69uccfAh_o.png"></p> 
<p> 开启kibana</p> 
<pre><code>[root@node1 /etc/kibana]# systemctl start kibana.service
[root@node1 /etc/kibana]# systemctl enable kibana.service
Created symlink from /etc/systemd/system/multi-user.target.wants/kibana.service to /etc/systemd/system/kibana.service.
</code></pre> 
<p>浏览器输入192.168.37.101:5601</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3e/43/CCVPW5FR_o.png"></p> 
<p>加载后的页面</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/06/3a/TzrofG16_o.png"> </p> 
<p> 首次登录创建一个索引 名字：system-*  ##这是对接系统日志文件<br> Index name or pattern   ###下面输入system-*</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/db/d4/QSBAkK6z_o.png"></p> 
<p>然后点下面的host旁边的add  会发现右面的图只有 Time  和host 选项了 这个比较友好</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a7/04/2pUKOWyq_o.png"> </p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%AF%B9%E6%8E%A5Apache%E4%B8%BB%E6%9C%BA%E7%9A%84Apache%20%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%EF%BC%88%E8%AE%BF%E9%97%AE%E7%9A%84%E3%80%81%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%89">                对接Apache主机的Apache 日志文件（访问的、错误的）</h4> 
<pre><code>[root@apache /etc/logstash/conf.d]# touch apache_log.conf
[root@apache /etc/logstash/conf.d]# vim apache_log.conf


input {
       file{
        path =&gt; "/usr/local/httpd/logs/access_log"
        type =&gt; "access"
        start_position =&gt; "beginning"
        }
       file{
        path =&gt; "/usr/local/httpd/logs/error_log"
        type =&gt; "error"
        start_position =&gt; "beginning"
        }

      }
output {
        if [type] == "access" {
        elasticsearch {
          hosts =&gt; ["192.168.37.101:9200"]
          index =&gt; "apache_access-%{+YYYY.MM.dd}"
          }
        }
        if [type] == "error" {
        elasticsearch {
          hosts =&gt; ["192.168.37.101:9200"]
          index =&gt; "apache_error-%{+YYYY.MM.dd}"
          }
        }
        }
</code></pre> 
<h4 id="%C2%A0%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97"> 启动日志</h4> 
<pre><code>[root@apache /etc/logstash/conf.d]# /usr/share/logstash/bin/logstash -f apache_log.conf
</code></pre> 
<p>访问192.168.37.101:9100会多能发现<br> apache_error-****    和 apache_access-****</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/91/2c/LAlYlJHv_o.png"></p> 
<p> 在<a href="http://192.168.37.101:5601/" rel="nofollow" title="http://192.168.37.101:5601/">http://192.168.37.101:5601/</a>创建两个日志access和error日志</p> 
<p>ps：创建之前要先访问一些apache哦，不然会没有记录的</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/99/a8/fQH5EFJB_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b4/9a/K1U3tNAq_o.png"> </p> 
<p> 最后，因为没做什么页面它也是空的，是不是很方便啊！！！不要面对枯燥的代码，只需点点就好</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/49/d2/bfjQB5us_o.png"></p> 
<h2 id="%C2%A0%E6%80%BB%E7%BB%93"> 总结</h2> 
<p>        在配置文件的时候，千万要注意地址一定要写对 我apache之前是安装过的，也可以不需要安装yum install httpd 也是一样的，只不过看对路径</p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%9C%AC%E6%AC%A1%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85">                本次所用到的软件包</h4> 
<blockquote> 
 <p><a class="link-info" href="http://xn--https-bl8js66z7n7i//pan.baidu.com/s/1utAlomUz84Md0wr4FmbLKw%20%20%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Axbzs" rel="nofollow" title="链接：https://pan.baidu.com/s/1utAlomUz84Md0wr4FmbLKw 提取码：xbzs">链接：https://pan.baidu.com/s/1utAlomUz84Md0wr4FmbLKw <br> 提取码：xbzs</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/45b65f5bf0e995d31522be062cb6e1a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vivado编译出错 [Synth 8-729] [Synth 8-787]解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f1ee2ed084bdab84f4d61d180af005a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">代码初学者可以看看这样可不可以快速理解链表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>