<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于多线程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于多线程" />
<meta property="og:description" content="多线程
一 并发 与 并行 并行：指两个或多个事件在 同一时刻 发生（同时发生）
并发：值两个或多个时间在 同一个时间段内 发生， 即同一段时间内宏观上有多程序同时运行，微观上是分时的交替运行，多线程是实现并发机制的一种有效手段。
注：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同
理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个
线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为
线程调度。
二 进程 与 线程
1.进程 指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；
进程也是程序的依次执行过程，是系统运行程序的基本单位；
系统运行一个程序即是一个进程从创建、运行到消亡的过程。
2.线程 进程内部的一个独立执行单元，一个进程可以同时并发的运行多个线程
3.进程 与 线程 的区别
1）进程 有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。
2）线程 堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。
注意：
1）因为一个进程中的多个线程是并发运行的，那么从微观角度看也是有先后顺序的，哪个线程执行完全取决于
CPU 的调度，程序员是干涉不了的。而这也就造成的多线程的随机性。
2）Java 程序的进程里面至少包含两个线程，主进程也就是 main()方法线程，用于启动子线程，另外一个是垃圾回收机制线程，负责垃圾回收。每
当使用 java 命令执行一个类时，实际上都会启动一个 JVM，每一个 JVM 实际上就是在操作系统中启动了一个
进程，java 本身具备了垃圾的收集机制，所以在 Java 运行时至少会启动两个线程---main线程 和 gc线程。
3） 由于创建一个线程的开销比创建一个进程的开销小的多，那么我们在开发多任务运行的时候，通常考虑创建
多线程，而不是创建多进程。
4.线程调度
计算机通常只有一个CPU时,在任意时刻只能执行一条计算机指令,每一个线程只有获得CPU的使用权才能执行指
令。所谓多线程并发运行,从宏观上看,其实是各个线程轮流获得CPU的使用权,分别执行各自的任务。那么,在可运行
池中,会有多个线程处于就绪状态等到CPU,JVM就负责了线程的调度。JVM采用的是 抢占式调度 ,没有采用分时调度,
因此可以能造成多线程执行结果的的随机性。
5.线程类
java.lang.Thread类代表线程，所有的线程UI想都必须是Tread类或者其子类的实例
1）创建并启动多线程步骤
（1） 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把
run()方法称为线程执行体。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/03f19d2f0ed6e642129230a615a55114/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-18T22:14:28+08:00" />
<meta property="article:modified_time" content="2018-08-18T22:14:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于多线程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>    多线程<br> 一 并发 与 并行 <br>     并行：指两个或多个事件在 同一时刻 发生（同时发生）</p> 
<p>    并发：值两个或多个时间在 同一个时间段内 发生， 即同一段时间内宏观上有多程序同时运行，微观上是分时的交替运行，多线程是实现并发机制的一种有效手段。<br>     <br>     注：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同<br>     理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个<br>     线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为<br>     线程调度。</p> 
<p>二 进程 与 线程<br>     1.进程 指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；<br>             进程也是程序的依次执行过程，是系统运行程序的基本单位；<br>             系统运行一个程序即是一个进程从创建、运行到消亡的过程。<br>     2.线程 进程内部的一个独立执行单元，一个进程可以同时并发的运行多个线程</p> 
<p>    3.进程 与 线程 的区别<br>         1）进程 有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。<br>         2）线程 堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。<br>     注意：<br>         1）因为一个进程中的多个线程是并发运行的，那么从微观角度看也是有先后顺序的，哪个线程执行完全取决于<br>             CPU 的调度，程序员是干涉不了的。而这也就造成的多线程的随机性。<br>         2）Java 程序的进程里面至少包含两个线程，主进程也就是 main()方法线程，用于启动子线程，另外一个是垃圾回收机制线程，负责垃圾回收。每<br>             当使用 java 命令执行一个类时，实际上都会启动一个 JVM，每一个 JVM 实际上就是在操作系统中启动了一个<br>             进程，java 本身具备了垃圾的收集机制，所以在 Java 运行时至少会启动两个线程---main线程 和 gc线程。<br>         3） 由于创建一个线程的开销比创建一个进程的开销小的多，那么我们在开发多任务运行的时候，通常考虑创建<br>             多线程，而不是创建多进程。<br>     4.线程调度<br>             计算机通常只有一个CPU时,在任意时刻只能执行一条计算机指令,每一个线程只有获得CPU的使用权才能执行指<br>         令。所谓多线程并发运行,从宏观上看,其实是各个线程轮流获得CPU的使用权,分别执行各自的任务。那么,在可运行<br>         池中,会有多个线程处于就绪状态等到CPU,JVM就负责了线程的调度。JVM采用的是 抢占式调度 ,没有采用分时调度,<br>         因此可以能造成多线程执行结果的的随机性。<br>     5.线程类<br>         java.lang.Thread类代表线程，所有的线程UI想都必须是Tread类或者其子类的实例<br>         1）创建并启动多线程步骤<br>             （1） 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把<br>                 run()方法称为线程执行体。<br>             （2） 创建Thread子类的实例，即创建了线程对象<br>             （3） 调用线程对象的start()方法来启动该线程<br>     6.常用方法<br>         1）构造方法<br>             public Thread（）<br>                 分配一个新的线程对象<br>             public Thread（String name）<br>                  分配一个指定名字的新的线程对象<br>             public Thread（Runnable target）<br>                 分配一个带有指定目标新的线程对象<br>             public Thread(Runnable target, String name)<br>                 分配一个带有指定目标新的线程对象并指定名字<br>         2）方法<br>             public final String getName()<br>                 获取当前线程名称<br>             public  final String setName()<br>                 设置线程名字<br>             public void start()    <br>                 执行线程，Java虚拟机调用次线程的 run（）方法<br>             public void run()<br>                 此线程要执行的任务在此处定义代码<br>             public static Thread currentThread()<br>                 返回当前正在执行的线程对象的引用</p> 
<p>    7.创建线程的方式<br>         1）继承Thread类<br>         2）实现Runnable接口<br>             （1）创建步骤<br>                     （a）定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>                     （b）创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>                         的线程对象。<br>                     （c） 调用线程对象的start()方法来启动线程。<br>         3）缺点<br>             不能返回操作结果<br>     8.线程安全<br>         1）概念<br>             如果有多个线程在同时运行，而这些线程可能会同时运行这段代码，程序每次运行结果和单线程运行的结果是一样的，二且其他的变量的值也和语气的是一样的<br>         2）产生原因<br>             线程安全问题都是由 全局变量 及 静态变量 引起的。若每个线程中对全局变量、静态变量只有读操作，而无写<br>             操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，<br>             否则的话就可能影响线程安全。<br>     9.线程同步<br>         1）多线程面对的问题： 多线程同时处理资源比单线程高很多，但是多个线程操作同一资源会出现不同步的问题（资源操作的完整性）</p> 
<p>        2）同步操作就是在一个代码块中，多个线程操作在同一个时间段内只能有一个线程执行，其它线程需要等待此线程完成后才能够执行。</p> 
<p>        3）Java提供了同步机制（synchronized）来解决这个问题，synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p> 
<p>        4）同步操作三种方法<br>             （1）同步代码块<br>                 synchronized(同步锁){<!-- --><br>                     需要同步操作的代码<br>                 }<br>             （2）同步锁 （同步代码块，Java中有4种代码块： 普通代码块、构造块、静态块、同步块）<br>                     （a）锁对象，可以是任意类型<br>                     （b）多个线程对象要使用同一把锁<br>                     注：在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他线程只能在外等候（BLOCKED）<br>             （2）同步方法<br>                     public synchronized void method(){<!-- --><br>                         可能会产生线程安全问题的代码<br>                     }<br>             （3）锁机制 Lock<br>                     public void lock()<br>                         加同步锁<br>                     public void unlock()<br>                         释放同步锁<br>                 注：java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,<br>                 同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。<br>         注：1）同步的代码块性能很低，但是数据的安全性会高，称为线程安全性高<br>             2）过多的同步操作可以能会带来 死锁 问题，进而导致程序进入停滞状态</p> 
<p>    10.线程状态<br>             （1）五种状态<br>                     创建、就绪、运行、堵塞、总之<br>             （2）当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态<br>                     线程状态                      导致状态发生条件</p> 
<p>                NEW(新建)             线程刚被创建，但是并未启动。还没调用start方法。</p> 
<p>                Runnable(可运行)        线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</p> 
<p>                Blocked(锁阻塞)        当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</p> 
<p>                Waiting(无限等待)    一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。Timed</p> 
<p>                Waiting(计时等待)    同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。<br>                                     public static void sleep(long millis) throws InterruptedException</p> 
<p>                Teminated(被终止)    因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</p> 
<p>    11.多线程两种实现方式的区别<br>         <br>         不同<br>         1）    使用  Ruunable接口 可以避免单继承的局限性<br>         2） Ruunable接口    比 Thread类 可以更好的实现数据共享的概念<br>         相同 <br>         1） 多线程两种实现都需要一个线程的朱磊，这个主类实现 Ruunable接口 或者 继承 Thread类，不管使用哪种方式子类都必须覆写 run() 方法 ，此方法为线程的主方法。</p> 
<p>    12.利用 Callable接口 实现多线程<br>         1）从 JDK1.5 开始增加此接口，可以返回一个值。<br>             @FunctionalInterface<br>             public interface Callable&lt;V&gt; ｛<br>                 public V call（） throws Exception；<br>             ｝<br>         2）Thread类 如何接收 call（）的返回值<br>             （1）使用 FutureTask类,它实现了RunnableFuture接口，而 RunnableFuture接口 又实现了 Runnable接口 和 Future 接口。<br>                 这样FutureTask的对象作为Runnable接口的子类可以被Thread类接收；作为Future的子类，可以使用Future接口的 get（）方法来获取返回值。<br>             （2）FutureTask类 常用方法<br>                     public FutureTask(Callable&lt;V&gt; callable)<br>                         本构造方法接收Callable接口实例<br>                     public FutureTask(Runnable runnable, V result)<br>                         本构造方法接收Runnable接口实例，并指定返回结果类型<br>                     public V get() throws Interrupted Exception, ExceutionException<br>                         取得线程操作结果，此方法为Future接口定义<br>         3）Callable接口 与 Runnable接口 优缺点<br>             Callable接口 比 Runnable接口 多了一个获取返回值的功能，但Runnable接口使用最早，最广泛，所以实现多线程时优先考虑Runnable接口<br>     13.线程的优先级<br>         1）线程的优先级越高，越有 可能 先执行<br>                             常量<br>             最高优先级    MAX_PRIORITY        数值为 10<br>             中等优先级    NORM_PRIORITY        数值为 5<br>             最低优先级    MIN_PRIORITY        数值为 1<br>         2）方法<br>             public final void setPriority(int newPriority)<br>                 设置线程优先级<br>             public final int getPriority()<br>                 获得线程优先级<br>         注：main（）方法的优先级为 5<br>     14.多线程中数据交互情况<br>         概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。<br>         1）两点问题<br>             （1）数据错位<br>                 原因：非同步的操作<br>                 解决：要使用同步处理（不同的操作想要同步控制，需要放在一个类里面）<br>             （2）数据重复<br>                 原因：没有使用唤醒机制<br>                 解决: Object类的操作线程的方法<br>                     public final void wait() throws InterruptedException<br>                         线程的等待<br>                     public final void notify()<br>                         唤醒第一个等待线程<br>                     public final void notifyAll()<br>                         唤醒全部等待线程(哪个优先级高，哪个线程就有可能先执行)<br>                     注：在方法中增加一个标志位，来判断是否执行某个操作或者 Waiting<br>     15.注意<br>         1）suspend()方法<br>             resume（）方法<br>             stop（）方法<br>             这上个方法在操作时候容易产生 死锁 的问题，所以不建议使用。<br>         2）在多线程开发中，可以通过设置标志位的方式停滞一个线程的运行（覆写 stop（）方法）</p> 
<p>        3）调用wait和notify方法需要注意的细节<br>             （1） wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对<br>                     象调用的wait方法后的线程。<br>             （2） wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继<br>                     承了Object类的。<br>             （3） wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方<br>                     法。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d98ce5d5a7501b049ca6cbb0b94e5f51/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kaggle Titanic 生存问题 - Java 机器学习实战</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d475fd34cdbc8ce0c4978653d33a33f1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">eclipse无法添加tomcat</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>