<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>无锁队列概述 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="无锁队列概述" />
<meta property="og:description" content="一、无锁队列原理 1、队列操作模型 队列是一种非常重要的数据结构，其特性是先进先出（FIFO），符合流水线业务流程。在进程间通信、网络通信间经常采用队列做缓存，缓解数据处理压力。
根据操作队列的场景分为：单生产者——单消费者、多生产者——单消费者、单生产者——多消费者、多生产者——多消费者四大模型。根据队列中数据分为：队列中的数据是定长的、队列中的数据是变长的。
（1）单生产者——单消费者
（2）多生产者——单消费者
（3）单生产者——多消费者
（4）多生产者——多消费者
（5）数据定长队列
（6）数据变长队列
2、 无锁队列 生产环境中广泛使用生产者和消费者模型，要求生产者在生产的同时，消费者可以进行消费，通常使用互斥锁保证数据同步。但线程互斥锁的开销仍然比较大，因此在要求高性能、低延时场景中，推荐使用无锁队列。
3、CAS操作 CAS即Compare and Swap，是所有CPU指令都支持CAS的原子操作（X86中CMPXCHG汇编指令），用于实现实现各种无锁（lock free）数据结构。
CAS操作的C语言实现如下：
bool compare_and_swap ( int *memory_location, int expected_value, int new_value) { if (*memory_location == expected_value) { *memory_location = new_value; return true; } return false; } CAS用于检查一个内存位置是否包含预期值，如果包含，则把新值复赋值到内存位置。成功返回true，失败返回false。
（1）GCC对CAS支持
GCC4.1&#43;版本中支持CAS原子操作。
bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...); type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...); （2）Windows对CAS支持
Windows中使用Windows API支持CAS。
LONG InterlockedCompareExchange( LONG volatile *Destination, LONG ExChange, LONG Comperand ); （3）C11对CAS支持" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dea37ea29a88cd43d8524d766b1f86ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-19T22:01:02+08:00" />
<meta property="article:modified_time" content="2021-09-19T22:01:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">无锁队列概述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、无锁队列原理</h3> 
<h4>1、队列操作模型</h4> 
<p>        队列是一种非常重要的数据结构，其特性是先进先出（FIFO），符合流水线业务流程。在进程间通信、网络通信间经常采用队列做缓存，缓解数据处理压力。</p> 
<p>        根据操作队列的场景分为：单生产者——单消费者、多生产者——单消费者、单生产者——多消费者、多生产者——多消费者四大模型。根据队列中数据分为：队列中的数据是定长的、队列中的数据是变长的。</p> 
<p>（1）单生产者——单消费者</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/94/c5/v9aOA9P4_o.png"></p> 
<p> （2）多生产者——单消费者</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7d/71/Vvd12Mgp_o.png"></p> 
<p> （3）单生产者——多消费者</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/54/58/aaKK1zXm_o.png"></p> 
<p> （4）多生产者——多消费者</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/97/2c/D4Z8gAtm_o.png"></p> 
<p> （5）数据定长队列</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/92/00/Hmhns5EY_o.png"></p> 
<p> （6）数据变长队列</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/91/6b/uFRnuA4Y_o.png"></p> 
<h4>2、 无锁队列</h4> 
<p>        生产环境中广泛使用生产者和消费者模型，要求生产者在生产的同时，消费者可以进行消费，通常使用互斥锁保证数据同步。但线程互斥锁的开销仍然比较大，因此在要求高性能、低延时场景中，推荐使用无锁队列。</p> 
<h4 id="h3">3、CAS操作</h4> 
<p> CAS即Compare and Swap，是所有CPU指令都支持CAS的原子操作（X86中CMPXCHG汇编指令），用于实现实现各种无锁（lock free）数据结构。<br> CAS操作的C语言实现如下：</p> 
<pre><code class="language-cpp">bool compare_and_swap ( int *memory_location, int expected_value, int new_value)
{
    if (*memory_location == expected_value)
    {
        *memory_location = new_value;
        return true;
    }
    return false;
}</code></pre> 
<p> CAS用于检查一个内存位置是否包含预期值，如果包含，则把新值复赋值到内存位置。成功返回true，失败返回false。<br><strong>（1）GCC对CAS支持</strong><br> GCC4.1+版本中支持CAS原子操作。</p> 
<pre><code class="language-cpp">bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...);
type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...);</code></pre> 
<p><strong>（2）Windows对CAS支持</strong><br> Windows中使用Windows API支持CAS。</p> 
<pre><code class="language-cpp">LONG InterlockedCompareExchange(
  LONG volatile *Destination,
  LONG          ExChange,
  LONG          Comperand
);</code></pre> 
<p><strong>（3）C11对CAS支持</strong><br> C11 STL中atomic函数支持CAS并可以跨平台。</p> 
<pre><code class="language-cpp">template&lt; class T &gt;
bool atomic_compare_exchange_weak( std::atomic* obj,T* expected, T desired );
template&lt; class T &gt;
bool atomic_compare_exchange_weak( volatile std::atomic* obj,T* expected, T desired );</code></pre> 
<p>其它原子操作如下：<br> Fetch-And-Add：一般用来对变量做+1的原子操作；<br> Test-and-set：写值到某个内存位置并传回其旧值；</p> 
<h3>二、无锁队列方案</h3> 
<h4 id="h5">1、boost方案</h4> 
<p>boost提供了三种无锁方案，分别适用不同使用场景。<br> boost::lockfree::queue是支持多个生产者和多个消费者线程的无锁队列。<br> boost::lockfree::stack是支持多个生产者和多个消费者线程的无锁栈。<br> boost::lockfree::spsc_queue是仅支持单个生产者和单个消费者线程的无锁队列，比boost::lockfree::queue性能更好。<br> Boost无锁数据结构的API通过轻量级原子锁实现lock-free，不是真正意义的无锁。<br> Boost提供的queue可以设置初始容量，添加新元素时如果容量不够，则总容量自动增长；但对于无锁数据结构，添加新元素时如果容量不够，总容量不会自动增长。</p> 
<h4 id="h6">2、ConcurrentQueue</h4> 
<p>ConcurrentQueue是基于C实现的工业级无锁队列方案。<br><a class="link-info" href="http://xn--githubhttps-6q25d//github.com/cameron314/concurrentqueue" rel="nofollow">http://GitHub：https://github.com/cameron314/concurrentqueue</a><br> ReaderWriterQueue是基于C实现的单生产者单消费者场景的无锁队列方案。<br><a class="link-info" href="http://xn--githubhttps-6q25d//github.com/cameron314/readerwriterqueue" rel="nofollow">http://GitHub：https://github.com/cameron314/readerwriterqueue</a></p> 
<h3 id="h8">三、无锁队列实现</h3> 
<h4 id="h9"><a id="1_76" title=""></a>1、环形缓冲区</h4> 
<p>RingBuffer是生产者和消费者模型中常用的数据结构，生产者将数据追加到数组尾端，当达到数组的尾部时，生产者绕回到数组的头部；消费者从数组头端取走数据，当到达数组的尾部时，消费者绕回到数组头部。<br> 如果只有一个生产者和一个消费者，环形缓冲区可以无锁访问，环形缓冲区的写入index只允许生产者访问并修改，只要生产者在更新index前将新的值保存到缓冲区中，则消费者将始终看到一致的数据结构；读取index也只允许消费者访问并修改，消费者只要在取走数据后更新读index，则生产者将始终看到一致的数据结构。 </p> 
<p> </p> 
<p style="text-align:center;"><img alt="C++性能优化（十三）——无锁队列_无锁队列_07" src="https://images2.imgbox.com/a2/48/RYj0vdVt_o.png"></p> 
<p> 空队列时，front与rear相等；当有元素进队，则rear后移；有元素出队，则front后移。</p> 
<p style="text-align:center;"><img alt="C++性能优化（十三）——无锁队列_无锁队列_08" src="https://images2.imgbox.com/bc/5d/jMn2uQ5y_o.png"></p> 
<p> 空队列时，rear等于front；满队列时，队列尾部空一个位置，因此判断循环队列满时使用(rear-front+maxn)%maxn。<br> 入队操作：</p> 
<pre><code class="language-cpp">data[rear] = x;
 rear = (rear+1)%maxn;</code></pre> 
<p>出队操作：</p> 
<pre><code>x = data[front];
rear = (front+1)%maxn;</code></pre> 
<h4 id="h10">2、单生产者单消费者</h4> 
<p>对于单生产者和单消费者场景，由于read_index和write_index都只会有一个线程写，因此不需要加锁也不需要原子操作，直接修改即可，但读写数据时需要考虑遇到数组尾部的情况。<br> 线程对write_index和read_index的读写操作如下：<br> （1）写操作。先判断队列时否为满，如果队列未满，则先写数据，写完数据后再修改write_index。<br> （2）读操作。先判断队列是否为空，如果队列不为空，则先读数据，读完再修改read_index。</p> 
<h4 id="h11"><a id="3_98" title=""></a>3、多生产者单消费者</h4> 
<p>多生产者和单消费者场景中，由于多个生产者都会修改write_index，所以在不加锁的情况下必须使用原子操作。</p> 
<h3>四、无锁队列使用</h3> 
<h4>1、ConcurrentQueue无锁队列</h4> 
<p>实现demo如下：</p> 
<p><strong>lock_free_queue_impl.h</strong></p> 
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;memory&gt;
#include&lt;thread&gt;
#include"concurrentqueue.h"

class Response
{
public:
	~Response()
	{
		std::cout &lt;&lt; "~Response()" &lt;&lt; std::endl;
	}

	int status_code;
	int content;
};

class LockFreeImpl
{
public:
	LockFreeImpl() {}
	~LockFreeImpl() {}

	static LockFreeImpl&amp; GetRef();
	void Init();
	void DoJob();
	void OnMessage(std::shared_ptr&lt;Response&gt; response);
	void HandleMsg(std::shared_ptr&lt;Response&gt; response);

	void Release();

private:
	volatile bool inited_ = false;

	std::thread work_thread_;
	moodycamel::ConcurrentQueue&lt;std::shared_ptr&lt;Response&gt;&gt;* worker_queue_;

};</code></pre> 
<p><strong> lock_free_queue_impl.cpp</strong></p> 
<pre><code class="language-cpp">#include"lock_free_queue_impl.h"
#include&lt;Windows.h&gt;

LockFreeImpl&amp; LockFreeImpl::GetRef()
{
	static LockFreeImpl impl;
	return impl;
}

void LockFreeImpl::Init()
{
	inited_ = true;
	worker_queue_ = new moodycamel::ConcurrentQueue&lt;std::shared_ptr&lt;Response&gt;&gt;(81920, 1, 1);

	work_thread_ = std::thread(std::bind(&amp;LockFreeImpl::DoJob, this));

	std::cout &lt;&lt; "LockFreeImpl init successfully!" &lt;&lt; std::endl;
}

void LockFreeImpl::DoJob()
{
	std::cout &lt;&lt; "worker thread, worker thread start!" &lt;&lt; std::endl;
	
	std::shared_ptr&lt;Response&gt; item = nullptr;
	while (inited_)
	{
		if (worker_queue_-&gt;try_dequeue(item) == false)
		{
			Sleep(10);
			continue;
		}
		if (item == nullptr)
			std::cout &lt;&lt; "item == nullptr" &lt;&lt; std::endl;
		else
		{
			HandleMsg(item);
		}
	}

	std::cout &lt;&lt; "worker thread, worker thread exit successfully!" &lt;&lt; std::endl;
}

void LockFreeImpl::OnMessage(std::shared_ptr&lt;Response&gt; response)
{
	try
	{
		worker_queue_-&gt;try_enqueue(response);
	}
	catch (const std::exception&amp; e)
	{
		std::cout &lt;&lt; "the error is: " &lt;&lt; e.what() &lt;&lt; std::endl;
	}
}

void LockFreeImpl::HandleMsg(std::shared_ptr&lt;Response&gt; response)
{
	std::cout &lt;&lt; "\n ----------------------开始解析数据----------------------" &lt;&lt; std::endl;
	std::cout &lt;&lt; "response-&gt;status_code is: " &lt;&lt; response-&gt;status_code &lt;&lt; std::endl;
	std::cout &lt;&lt; "response-&gt;content is: " &lt;&lt; response-&gt;content &lt;&lt; std::endl;
}

void LockFreeImpl::Release()
{
	if (inited_)
		inited_ = false;
	if (work_thread_.joinable())
		work_thread_.join();
	delete worker_queue_;

	std::cout &lt;&lt; "LockFreeImpl release,release exit successfully!" &lt;&lt; std::endl;
}</code></pre> 
<p><strong>main.cpp</strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;Windows.h&gt;
#include"lock_free_queue_impl.h"

using namespace std;

int main()
{
	LockFreeImpl lock_free_impl;
	lock_free_impl.Init();
	std::shared_ptr&lt;Response&gt; response(new Response());
	response-&gt;status_code = 0;
	response-&gt;content = 1;

	for (int i = 0; i &lt; 4; ++i)
	{

		std::cout &lt;&lt; "开始push数据...." &lt;&lt; std::endl;
		Sleep(1000);
		lock_free_impl.OnMessage(response);
	}

	system("pause");
	lock_free_impl.Release();
	return 0;
}</code></pre> 
<p>结果如下：</p> 
<p><img alt="" height="456" src="https://images2.imgbox.com/e8/b2/QyH96Hg2_o.png" width="615"></p> 
<p> concurrentqueue.h 文件下载上文链接</p> 
<p><strong>参考链接：</strong></p> 
<p><a class="link-info" href="https://blog.51cto.com/u_9291927/2588193" rel="nofollow">https://blog.51cto.com/u_9291927/2588193</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b08535309d3ea240c4a78859aaa992d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">苹果官网查询产品的激活日期教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5229e2abdad638f7b1dade37fea90ab5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python数据分析与挖掘——使用Matplotlib绘制直方图</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>