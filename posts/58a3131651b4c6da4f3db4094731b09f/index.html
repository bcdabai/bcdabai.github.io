<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue原理解析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue原理解析" />
<meta property="og:description" content="文章目录 1. VUE的响应式原理1.1 ViewModel1.2 双向绑定的基本原理1.3 什么是响应性1.4 Vue 中的响应性是如何工作的 2. Vue 渲染机制2.1 虚拟 DOM2.2 渲染管线2.3 带编译时信息的虚拟 DOM2.3.1 静态提升2.3.2 修补标记 Flags2.3.3 树结构打平2.3.4 对 SSR 激活的影响 1. VUE的响应式原理 响应式的基本原理：双向数据绑定，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新，在单向绑定的基础上，如果用户更新了View，Model的数据也会自动更新。
双向绑定由三个重要部分构成：
数据层（Model）：应用数据及业务逻辑
视图层（View）：应用的展示效果，各类UI组件
业务逻辑层（ViewModel）：框架封装的核心，负责将数据与视图关联起来
1.1 ViewModel 作用：
数据变化更新视图视图变化更新数据 它还有两个主要部分组成：
监听器（Observer）：对所有数据的属性进行监听解析器（Compiler）：对每个节点的指令进行扫描跟解析，根据指令模板替换数据，以及绑定相应的更新函数 1.2 双向绑定的基本原理 在 JavaScript 中有两种劫持属性访问的方式：Object.defineProperty 和 Proxy 。
Vue 2 使用 Object.defineProperty 完全由于需支持更旧版本浏览器的限制。在 Vue 3 中使用了 Proxy 来创建响应式对象，将 getter/setter 用于 ref。 首先要对数据（data）进行劫持监听。所以需要设置一个监听器Observer，用来监听所有的属性。
每一个组件都有一个Watcher实例。如果属性发生变化，需要通知订阅者Watcher，看是否需要更新。因为订阅者有多个，所以需要一个消息订阅器（发布者）Dep（订阅者集合的管理数组）来专门收集这些订阅者，在Observer和Watcher之间进行统一管理。
还需要一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令初始化为一个订阅者Watcher，并替换模板数据或绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。
1、实现一个监听器Observer，用来劫持并监听所有属性，如果发生变化，就通知订阅者。
2、实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。
3、实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并据此初始化视图和订阅器Watcher。
1.3 什么是响应性 如果我们在 JavaScript 写类似的逻辑：
let A0 = 1 let A1 = 2 let A2 = A0 &#43; A1 console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/58a3131651b4c6da4f3db4094731b09f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-13T17:27:06+08:00" />
<meta property="article:modified_time" content="2023-02-13T17:27:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue原理解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_VUE_1" rel="nofollow">1. VUE的响应式原理</a></li><li><ul><li><a href="#11_ViewModel_10" rel="nofollow">1.1 ViewModel</a></li><li><a href="#12__19" rel="nofollow">1.2 双向绑定的基本原理</a></li><li><a href="#13__34" rel="nofollow">1.3 什么是响应性</a></li><li><a href="#14_Vue__73" rel="nofollow">1.4 Vue 中的响应性是如何工作的</a></li></ul> 
  </li><li><a href="#2_Vue__197" rel="nofollow">2. Vue 渲染机制</a></li><li><ul><li><a href="#21__DOM_198" rel="nofollow">2.1 虚拟 DOM</a></li><li><a href="#22__219" rel="nofollow">2.2 渲染管线</a></li><li><a href="#23__DOM_226" rel="nofollow">2.3 带编译时信息的虚拟 DOM</a></li><li><ul><li><a href="#231__233" rel="nofollow">2.3.1 静态提升</a></li><li><a href="#232__Flags_247" rel="nofollow">2.3.2 修补标记 Flags</a></li><li><a href="#233__285" rel="nofollow">2.3.3 树结构打平</a></li><li><a href="#234__SSR__330" rel="nofollow">2.3.4 对 SSR 激活的影响</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_VUE_1"></a>1. VUE的响应式原理</h2> 
<p>响应式的基本原理：<code>双向数据绑定</code>，就是把<code>Model</code>绑定到<code>View</code>，当我们用<code>JavaScript</code>代码更新<code>Model</code>时，<code>View</code>就会自动更新，在单向绑定的基础上，如果用户更新了<code>View</code>，<code>Model</code>的数据也会自动更新。</p> 
<p>双向绑定由三个重要部分构成：</p> 
<p>数据层（<code>Model</code>）：应用数据及业务逻辑<br> 视图层（<code>View</code>）：应用的展示效果，各类UI组件<br> 业务逻辑层（<code>ViewModel</code>）：框架封装的核心，负责将数据与视图关联起来</p> 
<h3><a id="11_ViewModel_10"></a>1.1 ViewModel</h3> 
<p>作用：</p> 
<ul><li>数据变化更新视图</li><li>视图变化更新数据</li></ul> 
<p>它还有两个主要部分组成：</p> 
<ul><li>监听器（<code>Observer</code>）：对所有数据的属性进行监听</li><li>解析器（<code>Compiler</code>）：对每个节点的指令进行扫描跟解析，根据指令模板替换数据，以及绑定相应的更新函数</li></ul> 
<h3><a id="12__19"></a>1.2 双向绑定的基本原理</h3> 
<p>在 <code>JavaScript</code> 中有两种劫持属性访问的方式：<code>Object.defineProperty</code> 和 <code>Proxy </code>。</p> 
<ul><li><code>Vue 2</code> 使用 <code>Object.defineProperty</code> 完全由于需支持更旧版本浏览器的限制。</li><li>在 <code>Vue 3</code> 中使用了 <code>Proxy</code> 来创建响应式对象，将 <code>getter/setter</code> 用于 <code>ref</code>。</li></ul> 
<p><img src="https://images2.imgbox.com/e8/9b/Fa8GUHFk_o.png" alt="在这里插入图片描述"><br> 首先要对<code>数据（data）</code>进行<code>劫持监听</code>。所以需要设置一个监听器<code>Observer</code>，用来监听所有的属性。<br> 每一个组件都有一个<code>Watcher</code>实例。如果属性发生变化，需要通知订阅者<code>Watcher</code>，看是否需要更新。因为订阅者有多个，所以需要一个消息订阅器（发布者）<code>Dep</code>（订阅者集合的管理数组）来专门收集这些订阅者，在<code>Observer</code>和<code>Watcher</code>之间进行统一管理。<br> 还需要一个指令解析器<code>Compile</code>，对每个节点元素进行扫描和解析，将相关指令初始化为一个订阅者<code>Watcher</code>，并替换模板数据或绑定相应的函数，此时当订阅者<code>Watcher</code>接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</p> 
<blockquote> 
 <p>1、实现一个监听器<code>Observer</code>，用来劫持并监听所有属性，如果发生变化，就通知订阅者。<br> 2、实现一个订阅者<code>Watcher</code>，可以收到属性的变化通知并执行相应的函数，从而更新视图。<br> 3、实现一个解析器<code>Compile</code>，可以扫描和解析每个节点的相关指令，并据此初始化视图和订阅器Watcher。</p> 
</blockquote> 
<h3><a id="13__34"></a>1.3 什么是响应性</h3> 
<p>如果我们在 JavaScript 写类似的逻辑：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> <span class="token constant">A0</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">let</span> <span class="token constant">A1</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">let</span> <span class="token constant">A2</span> <span class="token operator">=</span> <span class="token constant">A0</span> <span class="token operator">+</span> <span class="token constant">A1</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A2</span><span class="token punctuation">)</span> <span class="token comment">// 3</span>

<span class="token constant">A0</span> <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A2</span><span class="token punctuation">)</span> <span class="token comment">// 仍然是 3</span>
</code></pre> 
<p>当我们更改 A0 后，A2 不会自动更新。</p> 
<p>那么我们如何在 JavaScript 中做到这一点呢？首先，为了能重新运行计算的代码来更新 A2，我们需要将其包装为一个函数：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> <span class="token constant">A2</span>

<span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token constant">A2</span> <span class="token operator">=</span> <span class="token constant">A0</span> <span class="token operator">+</span> <span class="token constant">A1</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>然后，我们需要定义几个术语：</p> 
<ul><li>这个 <code>update()</code> 函数会产生一个<code>副作用</code>，或者就简称为<code>作用</code>，因为它会更改程序里的状态。</li><li><code>A0</code> 和 <code>A1</code> 被视为这个作用的<code>依赖</code>，因为它们的值被用来执行这个作用。因此这次作用也可以说是一个它依赖的<code>订阅者</code>。</li></ul> 
<p>我们需要一个魔法函数，能够在 <code>A0</code> 或 <code>A1</code> (这两个依赖) 变化时调用 <code>update()</code> (产生作用)。</p> 
<pre><code class="prism language-javascript"><span class="token function">whenDepsChange</span><span class="token punctuation">(</span>update<span class="token punctuation">)</span>
</code></pre> 
<p>这个 <code>whenDepsChange()</code> 函数有如下的任务：</p> 
<ul><li>当一个变量被读取时进行追踪。例如我们执行了表达式 <code>A0 + A1</code> 的计算，则 <code>A0</code> 和 <code>A1</code> 都被读取到了。</li><li>如果一个变量在当前运行的<code>副作用</code>中被读取了，就将该<code>副作用</code>设为此<code>变量</code>的一个<code>订阅者</code>。例如由于 <code>A0</code> 和 <code>A1</code> 在 <code>update()</code> 执行时被访问到了，则 <code>update()</code> 需要在第一次调用之后成为 <code>A0</code> 和 <code>A1</code> 的订阅者。</li><li>探测一个变量的变化。例如当我们给 <code>A0</code> 赋了一个新的值后，应该通知其所有订阅了的副作用重新执行。</li></ul> 
<h3><a id="14_Vue__73"></a>1.4 Vue 中的响应性是如何工作的</h3> 
<p>我们是可以追踪一个<code>对象的属性</code>进行读和写的。</p> 
<p>在 <code>JavaScript</code> 中有两种劫持属性访问的方式：<code>getter/setters</code> 和 <code>Proxies</code>。Vue 2 使用 <code>getter/setters</code> 完全由于需支持更旧版本浏览器的限制。而在 <code>Vue 3</code> 中使用了 <code>Proxy</code> 来创建响应式对象，将 <code>getter/setter</code> 用于 <code>ref</code>。下面的伪代码将会说明它们是如何工作的：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
      <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
      <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> refObject <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">track</span><span class="token punctuation">(</span>refObject<span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      value <span class="token operator">=</span> newValue
      <span class="token function">trigger</span><span class="token punctuation">(</span>refObject<span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> refObject
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>当你将一个响应性对象的属性解构为一个局部变量时，响应性就会“断开连接”，因为对局部变量的访问不再触发 <code>get / set</code> 代理捕获。</li><li>从 <code>reactive()</code> 返回的代理尽管行为上表现得像原始对象，但我们通过使用 <code>===</code> 运算符还是能够比较出它们的不同。</li></ul> 
<p>在 <code>track()</code> 内部，我们会检查当前是否有正在运行的副作用。如果有，我们会查找到一个所有追踪了该属性的订阅者，它们存储在一个 <code>Set</code> 中，然后将当前这个副作用添加到该 <code>Set</code> 中。</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 这会在一个副作用就要运行之前被设置</span>
<span class="token comment">// 我们会在后面处理它</span>
<span class="token keyword">let</span> activeEffect

<span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> effects <span class="token operator">=</span> <span class="token function">getSubscribersForProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    effects<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>副作用订阅将被存储在一个全局的 <code>WeakMap&lt;target, Map&lt;key, Set&lt;effect&gt;&gt;&gt;</code> 数据结构中。如果在第一次追踪时没有找到对相应属性订阅的副作用集合，它将会在这里新建。这就是 <code>getSubscribersForProperty()</code> 函数所做的事。为了简化描述，我们跳过了它其中的细节。</p> 
<p>在 <code>trigger()</code> 之中，我们会再查找到该属性的所有订阅副作用。但这一次我们是去调用它们：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> effects <span class="token operator">=</span> <span class="token function">getSubscribersForProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">effect</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>现在让我们回到 <code>whenDepsChange()</code> 函数中：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">whenDepsChange</span><span class="token punctuation">(</span><span class="token parameter">update</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> <span class="token function-variable function">effect</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    activeEffect <span class="token operator">=</span> effect
    <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    activeEffect <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>它包装了原先的 <code>update</code> 函数到一个副作用中，并在运行实际的更新之前，将它自己设为当前活跃的副作用。而在更新期间开启的 <code>track()</code> 调用，都将能定位到这个当前活跃的副作用。</p> 
<p>此时，我们已经创建了一个能自动跟踪其依赖关系的副作用，它会在依赖关系更改时重新运行。我们称其为<code>响应式副作用</code>。</p> 
<p>Vue 提供了一个 API 来让你创建响应式副作用 <code>watchEffect()</code>。事实上，你会发现它的使用方式和我们上面示例中说的魔法函数 <code>whenDepsChange()</code> 非常相似。我们可以用真正的 <code>Vue API</code> 改写上面的例子：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> ref<span class="token punctuation">,</span> watchEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> <span class="token constant">A0</span> <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token constant">A1</span> <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token constant">A2</span> <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 追踪 A0 和 A1</span>
  <span class="token constant">A2</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token constant">A0</span><span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token constant">A1</span><span class="token punctuation">.</span>value
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 将触发副作用</span>
<span class="token constant">A0</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">2</span>
</code></pre> 
<p>使用一个响应式副作用来更改一个 ref 并不是最优解，事实上使用计算属性会更直观简洁：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> ref<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> <span class="token constant">A0</span> <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token constant">A1</span> <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token constant">A2</span> <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">A0</span><span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token constant">A1</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>

<span class="token constant">A0</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">2</span>
</code></pre> 
<p>在内部，<code>computed</code> 会使用响应式副作用来管理失效与重新计算的过程。</p> 
<p>那么，常见的响应式副作用的用例是什么呢？自然是更新 DOM！我们可以像下面这样实现一个简单的“响应式渲染”：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> ref<span class="token punctuation">,</span> watchEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">计数：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>count<span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 更新 DOM</span>
count<span class="token punctuation">.</span>value<span class="token operator">++</span>
</code></pre> 
<p>实际上，这与 Vue 组件保持状态和 DOM 同步的方式非常接近。每个组件实例创建一个响应式副作用来渲染和更新 DOM。当然，Vue 组件使用了比 <code>innerHTML</code> 更高效的方式来更新 DOM。这会在<code>渲染机制</code>一章中详细介绍。</p> 
<p><code>ref()</code>、<code>computed()</code> 和 <code>watchEffect()</code> 这些 API 都是<code>组合式 API</code> 的一部分，如果你至今只使用过选项式 API，那么你需要知道的是组合式 API 更贴近 Vue 底层的响应式系统。事实上，Vue 3 中的选项式 API 正是基于组合式 API 建立的。对该组件实例 (<code>this</code>) 所有的属性访问都会触发 <code>getter/setter</code> 的响应式追踪，而像 <code>watch</code> 和 <code>computed</code> 这样的选项也是在内部调用相应等价的组合式 API。</p> 
<h2><a id="2_Vue__197"></a>2. Vue 渲染机制</h2> 
<h3><a id="21__DOM_198"></a>2.1 虚拟 DOM</h3> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'hello'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">/* 更多 vnode */</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里所说的 <code>vnode</code> 即一个纯 JavaScript 的对象 (一个“虚拟节点”)，它代表着一个 <code>&lt;div&gt;</code> 元素。它包含我们创建实际元素所需的所有信息。它还包含更多的子节点，这使它成为虚拟 DOM 树的根节点。</p> 
<p>一个运行时渲染器将会遍历整个虚拟 DOM 树，并据此构建真实的 DOM 树。这个过程被称为<code>挂载 (mount)</code>。</p> 
<p>如果我们有两份虚拟 DOM 树，渲染器将会有比较地遍历它们，找出它们之间的区别，并应用这其中的变化到真实的 DOM 上。这个过程被称为<code>修补 (patch)</code>，又被称为“<code>比较差异 (diffing)</code>”或“<code>协调 (reconciliation)</code>”。</p> 
<p>虚拟 DOM 带来的主要收益是它赋予了开发者编程式地、声明式地创建、审查和组合所需 UI 结构的能力，而把直接与 DOM 相关的操作交给了渲染器。</p> 
<h3><a id="22__219"></a>2.2 渲染管线</h3> 
<ol><li><strong>编译</strong>：Vue 模板被编译为了<strong>渲染函数</strong>：即用来返回虚拟 DOM 树的函数。这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。</li><li><strong>挂载</strong>：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。这一步会作为<code>响应式副作用</code>执行，因此它会追踪其中所用到的所有响应式依赖。</li><li><strong>修补</strong>：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。</li></ol> 
<p><img src="https://images2.imgbox.com/34/92/vOUa26HM_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="23__DOM_226"></a>2.3 带编译时信息的虚拟 DOM</h3> 
<p>虚拟 DOM 在 React 和大多数其他实现中都是纯运行时的：协调算法无法预知新的虚拟 DOM 树会是怎样，因此它总是需要遍历整棵树、比较每个 vnode 上 props 的区别来确保正确性。另外，即使一棵树的某个部分从未改变，还是会在每次重渲染时创建新的 vnode，带来了完全不必要的内存压力。这也是虚拟 DOM 最受诟病的地方之一：这种有点暴力的协调过程通过牺牲效率来换取可声明性和正确性。</p> 
<p>但实际上我们并不需要这样。在 Vue 中，框架同时控制着编译器和运行时。这使得我们可以为紧密耦合的模板渲染器应用许多编译时优化。编译器可以静态分析模板并在生成的代码中留下标记，使得运行时尽可能地走捷径。与此同时，我们仍旧保留了边界情况时用户想要使用底层渲染函数的能力。我们称这种混合解决方案为<code>带编译时信息的虚拟 DOM</code>。</p> 
<p>下面，我们将讨论一些 Vue 编译器用来提高虚拟 DOM 运行时性能的主要优化：</p> 
<h4><a id="231__233"></a>2.3.1 静态提升</h4> 
<p>在模板中常常有部分内容是不带任何动态绑定的：</p> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>foo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 需提升 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>bar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 需提升 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{<!-- -->{ dynamic }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p><code>foo</code> 和 <code>bar</code> 这两个 div 是完全静态的，没有必要在重新渲染时再次创建和比对它们。Vue 编译器自动地会提升这部分 vnode 创建函数到这个模板的渲染函数之外，并在每次渲染时都使用这份相同的 vnode，渲染器知道新旧 vnode 在这部分是完全相同的，所以会完全跳过对它们的差异比对。</p> 
<p>此外，当有足够多连续的静态元素时，它们还会再被压缩为一个“静态 vnode”，其中包含的是这些节点相应的纯 HTML 字符串。这些静态节点会直接通过 <code>innerHTML</code> 来挂载。同时还会在初次挂载后缓存相应的 DOM 节点。如果这部分内容在应用中其他地方被重用，那么将会使用原生的 <code>cloneNode()</code> 方法来克隆新的 DOM 节点，这会非常高效。</p> 
<h4><a id="232__Flags_247"></a>2.3.2 修补标记 Flags</h4> 
<p>对于单个有动态绑定的元素来说，我们可以在编译时推断出大量信息：</p> 
<pre><code class="prism language-html"><span class="token comment">&lt;!-- 仅含 class 绑定 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{ active }<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 仅含 id 和 value 绑定 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 仅含文本子节点 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{<!-- -->{ dynamic }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>在为这些元素生成渲染函数时，Vue 在 vnode 创建调用中直接编码了每个元素所需的更新类型：</p> 
<pre><code class="prism language-javascript"><span class="token function">createElementVNode</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">class</span><span class="token operator">:</span> <span class="token function">_normalizeClass</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">active</span><span class="token operator">:</span> _ctx<span class="token punctuation">.</span>active <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token comment">/* CLASS */</span><span class="token punctuation">)</span>
</code></pre> 
<p>最后这个参数 2 就是一个修补标记 (patch flag)。一个元素可以有多个修补标记，会被合并成一个数字。运行时渲染器也将会使用位运算来检查这些标记，确定相应的更新操作：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>patchFlag <span class="token operator">&amp;</span> PatchFlags<span class="token punctuation">.</span><span class="token constant">CLASS</span> <span class="token comment">/* 2 */</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 更新节点的 CSS class</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>位运算检查是非常快的。通过这样的修补标记，Vue 能够在更新带有动态绑定的元素时做最少的操作。</p> 
<p>Vue 也为 vnode 的子节点标记了类型。举个例子，包含多个根节点的模板被表示为一个片段 (fragment)，大多数情况下，我们可以确定其顺序是永远不变的，所以这部分信息就可以提供给运行时作为一个修补标记。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">_openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_createElementBlock</span><span class="token punctuation">(</span>_Fragment<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
    <span class="token comment">/* children */</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">64</span> <span class="token comment">/* STABLE_FRAGMENT */</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="233__285"></a>2.3.3 树结构打平</h4> 
<p>再来看看上面这个例子中生成的代码，你会发现所返回的虚拟 DOM 树是经一个特殊的 <code>createElementBlock()</code> 调用创建的：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">_openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_createElementBlock</span><span class="token punctuation">(</span>_Fragment<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
    <span class="token comment">/* children */</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">64</span> <span class="token comment">/* STABLE_FRAGMENT */</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里我们引入一个概念“区块”，内部结构是稳定的一个部分可被称之为一个区块。在这个用例中，整个模板只有一个区块，因为这里没有用到任何结构性指令 (比如 <code>v-if</code> 或者 <code>v-for</code>)。</p> 
<p>每一个块都会追踪其所有带修补标记的后代节点 (不只是直接子节点)，举个例子：</p> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- root block --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>         <span class="token comment">&lt;!-- 不会追踪 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>   <span class="token comment">&lt;!-- 要追踪 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>                  <span class="token comment">&lt;!-- 不会追踪 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{<!-- -->{ bar }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 要追踪 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>编译的结果会被打平为一个数组，仅包含所有动态的后代节点：</p> 
<pre><code class="prism language-html">div (block root)
- div 带有 :id 绑定
- div 带有 {<!-- -->{ bar }} 绑定
</code></pre> 
<p>当这个组件需要重渲染时，只需要遍历这个打平的树而非整棵树。这也就是我们所说的树结构打平，这大大减少了我们在虚拟 DOM 协调时需要遍历的节点数量。模板中任何的静态部分都会被高效地略过。</p> 
<p><code>v-if</code> 和 <code>v-for</code> 指令会创建新的区块节点：</p> 
<pre><code class="prism language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 根区块 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- if 区块 --&gt;</span>
      ...
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>一个子区块会在父区块的动态子节点数组中被追踪，这为他们的父区块保留了一个稳定的结构。</p> 
<h4><a id="234__SSR__330"></a>2.3.4 对 SSR 激活的影响</h4> 
<p>修补标记和树结构打平都大大提升了 Vue <code>SSR 激活</code>的性能表现：</p> 
<ul><li>单个元素的激活可以基于相应 vnode 的修补标记走更快的捷径。</li><li>在激活时只有区块节点和其动态子节点需要被遍历，这在模板层面上实现更高效的部分激活。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f5ce0f28cb991d82d7384a854a5fa18/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Cocos number格式转换时分秒格式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb3790668944741be0fd8ceb2f6664b2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Rabbitmq消息的有序性、消息不丢失、不被重复消费</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>