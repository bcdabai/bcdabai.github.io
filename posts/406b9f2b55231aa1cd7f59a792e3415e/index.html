<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java面试题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java面试题" />
<meta property="og:description" content="一.ArrayList、LinkedList 和 Vector 的区别。
1.ArrayList非线程安全的，Vector是线程安全的。
2.ArrayList扩容时按照50%增加，Vector 按照100%增加或则根据指定的扩容增量进行增加。
3.ArrayList的性能要高于Vector
4.LinkedList是链表实现的，因此查询慢，增删快。
5.LinkedList提供了List接口没有提供的方法，方便数据的头尾操作。
二.快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？
1.快速失败：如果用迭代器遍历集合时，如果集合内容发生了改变。这时会抛出一个ConcurrentModificationException.
2.安全失败：迭代器遍历时用的是原集合的拷贝，因此改变原集合不会引起一场，但是这样也就无法感知原集合的变化了。
三.hashmap的数据结构
1.是由数组和链表/红黑树组成的，链表的数据多了就会转为红黑树。转换的阈值是8.
2.通过key的hashcode取模数组长度来确定将数据放到哪里
3.如果存放的位置已经有了数据了就形成链表向后放，node记录了next的节点。
4.默认初始容量是16，加载因子是0.75.意味着容量超过75%就会扩容一倍
5.key的equals用来确定在链表中是否有相同的key
四.List、Map、Set 三个接口，存取元素时，各有什么特点？
1.list可以有重复的元素，可以通过执行索引取元素，也可以在指定的位置存放元素
2.map键值对的方式存取元素，key不可以重复，可以通过key获取指定的键值对
3.set不允许存重复的元素，也就是equals相同的对象，也无法获取指定的元素。只能通过遍历。
五.两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对?
1.分不同的情况，如果对象的equals没有被重写的话，那么equals都是继承的Object的。即为==，也就是说equals相同证明了是同一个对象，hashcode也一定相同。
2.针对上面的这种规范，java倡导如果equals被重写了那么hashcode也要重写。以此来保证equals相同时hashcode也相同
3.而这个问题是对的，因为如果不遵守这个规范，当然equals相同hashcode可以不同了。
六.Java 集合类框架的基本接口有哪些？
add,addAll,clear,contains,containsAll,remove,removeAll
clear,containsKey,containsValue,get,put
七.HashSet 和 TreeSet 有什么区别？
1.HashSet是无序的，可以有一个null，非同步。TreeSet是有序的，不能有null，通过compare方法决定放置的位置。TreeSet有两种排序方法：自然排序、自定义排序
2.HashSet是通过哈希表实现的、TreeSet二叉树实现的
八.HashSet的底层实现是什么？
1.通过hashmap来实现的，用key来存储数据，保证key的唯一性
九.LinkedHashMap 的实现原理?
hashmap&#43;双向链表实现的，是有序的，分为插入顺序和访问顺序。
十.为什么集合Collection类没有实现 Cloneable 和 Serializable 接口？
应该有具体的实现来完由
十一.什么是迭代器？
为了方便容器的遍历，和具体的容器进行解耦。提供了公共的实现方法。
十二.Iterator 和 ListIterator 的区别是什么？
Iterator是一个接口，ListIterator 是对它的具体实现,并增加了上一个元素的查询和set,add方法
十三.数组 (Array) 和列表 (ArrayList) 有什么区别？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/406b9f2b55231aa1cd7f59a792e3415e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-04T16:48:59+08:00" />
<meta property="article:modified_time" content="2021-07-04T16:48:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java面试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>一.ArrayList、LinkedList 和 Vector 的区别。</p> 
<p>1.ArrayList非线程安全的，Vector是线程安全的。</p> 
<p>2.ArrayList扩容时按照50%增加，Vector 按照100%增加或则根据指定的扩容增量进行增加。</p> 
<p>3.ArrayList的性能要高于Vector</p> 
<p>4.LinkedList是链表实现的，因此查询慢，增删快。</p> 
<p>5.LinkedList提供了List接口没有提供的方法，方便数据的头尾操作。</p> 
<p>二.快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？</p> 
<p>1.快速失败：如果用迭代器遍历集合时，如果集合内容发生了改变。这时会抛出一个ConcurrentModificationException.</p> 
<p>2.安全失败：迭代器遍历时用的是原集合的拷贝，因此改变原集合不会引起一场，但是这样也就无法感知原集合的变化了。</p> 
<p>三.hashmap的数据结构</p> 
<p>1.是由数组和链表/红黑树组成的，链表的数据多了就会转为红黑树。转换的阈值是8.</p> 
<p>2.通过key的hashcode取模数组长度来确定将数据放到哪里</p> 
<p>3.如果存放的位置已经有了数据了就形成链表向后放，node记录了next的节点。</p> 
<p>4.默认初始容量是16，加载因子是0.75.意味着容量超过75%就会扩容一倍</p> 
<p>5.key的equals用来确定在链表中是否有相同的key</p> 
<p>四.List、Map、Set 三个接口，存取元素时，各有什么特点？</p> 
<p>1.list可以有重复的元素，可以通过执行索引取元素，也可以在指定的位置存放元素</p> 
<p>2.map键值对的方式存取元素，key不可以重复，可以通过key获取指定的键值对</p> 
<p>3.set不允许存重复的元素，也就是equals相同的对象，也无法获取指定的元素。只能通过遍历。</p> 
<p>五.两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对?</p> 
<p>1.分不同的情况，如果对象的equals没有被重写的话，那么equals都是继承的Object的。即为==，也就是说equals相同证明了是同一个对象，hashcode也一定相同。</p> 
<p>2.针对上面的这种规范，java倡导如果equals被重写了那么hashcode也要重写。以此来保证equals相同时hashcode也相同</p> 
<p>3.而这个问题是对的，因为如果不遵守这个规范，当然equals相同hashcode可以不同了。</p> 
<p>六.Java 集合类框架的基本接口有哪些？</p> 
<p></p> 
<p>add,addAll,clear,contains,containsAll,remove,removeAll</p> 
<p>clear,containsKey,containsValue,get,put</p> 
<p>七.HashSet 和 TreeSet 有什么区别？</p> 
<p>1.HashSet是无序的，可以有一个null，非同步。TreeSet是有序的，不能有null，通过compare方法决定放置的位置。TreeSet有两种排序方法：自然排序、自定义排序</p> 
<p>2.HashSet是通过哈希表实现的、TreeSet二叉树实现的</p> 
<p>八.HashSet的底层实现是什么？</p> 
<p>1.通过hashmap来实现的，用key来存储数据，保证key的唯一性</p> 
<p>九.LinkedHashMap 的实现原理?</p> 
<p>hashmap+双向链表实现的，是有序的，分为插入顺序和访问顺序。</p> 
<p>十.为什么集合Collection类没有实现 Cloneable 和 Serializable 接口？</p> 
<p>应该有具体的实现来完由</p> 
<p>十一.什么是迭代器？</p> 
<p>为了方便容器的遍历，和具体的容器进行解耦。提供了公共的实现方法。</p> 
<p>十二.Iterator 和 ListIterator 的区别是什么？</p> 
<p>Iterator是一个接口，ListIterator 是对它的具体实现,并增加了上一个元素的查询和set,add方法</p> 
<p>十三.数组 (Array) 和列表 (ArrayList) 有什么区别？</p> 
<p>1.Array(这里的Array并不是指jdk中的Array类，只是为了说明数组) 是定长的，ArrayList是变长的。</p> 
<p>2.Array适合处理不变的数据，ArrayList提供的方法更丰富。</p> 
<p>十四.集合使用</p> 
<p>十五.Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？它们有何区别？</p> 
<p>== 和 equals</p> 
<p>十六.Comparable(内排序) 和 Comparator（外排序） 接口是干什么的？列出它们的区别?</p> 
<p>如果想对一个对象进行排序，可以有两种方式。一个是这个对象实现 comparable 接口、另一个是单独写一个类，这个类实现 Comprator 接口。相当于一个在需要排序的内部实现，一个可以在外部实现。</p> 
<p>十七.Collection 和 Collections 的区别。</p> 
<p>Collection是集合的接口、Collections是操作集合的一个工具类</p> 
<p>十八.java类加载过程？</p> 
<p>1.加载-&gt;链接(验证、准备、解析)-&gt;初始化</p> 
<p>2.加载：加载二进制流、静态结构转化为方法区和数据结构、生成类对象</p> 
<p>十九.jvm加载class的原理和机制？</p> 
<p>1.java通过双亲委派机制加载类，这样的好处是安全。</p> 
<p>2.有三个类加载器：系统类加载器（加载java的系统类）扩展类加载器（继承和实现的类）程序类加载器（程序员自定义的类）</p> 
<p>二十.java内存分配？</p> 
<p>堆：存储java的实例对象</p> 
<p>栈：线程私有，存储局部变量表，动态链接</p> 
<p>方法区：线程共享的，存储class二级制文件。包含类信息、常量池、静态变量</p> 
<p>程序计数器：线程私有的，记录着程序运行的位置</p> 
<p>本地方法栈：存储java本地方法信息</p> 
<p>二十一.GC是什么？</p> 
<p>是java的内存回收机制，通过算法判断对象是否为垃圾对象来进行回收。如果判断对象是垃圾对象呢，有两种算法：一种是引用计数法，当对象被引用一次时计数加一。当引用计数的次数为零的时候就表示对象无用了。但是这种算法有一个问题，就是当对象循环引用时无法做出正确的判断。还有一种算法是可达性分析：把对象看作一棵树，看对象是否可达。</p> 
<p>回收过程：1.分为下面四个区：eden、s1、s2、old</p> 
<p>2.对象先放入eden中，满了就放入s1-》s1满了放入s2，eden和s1清空-》s2满了将对象放入old中，然后s1和s2互换-》old满了进行老年代的回收</p> 
<p>二十二.Java 中会存在内存泄漏吗</p> 
<p>数据库连接、网络连接</p> 
<p>二十三.深拷贝和浅拷贝</p> 
<p>深拷贝是拷贝对象的属性，如果原对象有引用的属性则修改引用属性不会引起拷贝对象的变化。</p> 
<p>二十四.System.gc和Runtime.gc</p> 
<p>功能一样，不建议使用。</p> 
<p>二十五.finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？</p> 
<p>对象回收前会调用finalize方法、析构函数与构造函数相反，就是释放资源。</p> 
<p>二十六.什么是分布式垃圾回收（DGC）？它是如何工作的？</p> 
<p>跨虚拟机的远程对象引用，引用有租期。定时发送租约。</p> 
<p>二十七.串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？</p> 
<p>串行针对小应用、吞吐量针对大数据量</p> 
<p>二十八.Minor GC 和 Major GC</p> 
<p>minorGC是新生代的gc、Major是老年代的gc</p> 
<p>二十九.JVM 的永久代中会发生垃圾回收么？</p> 
<p>会回收：请看jvm虚拟机第3.2.5 回收方法区</p> 
<p>三十.双亲委派机制？</p> 
<p>会递归它的父类加载器进行加载，好处：放置重复加载、安全。</p> 
<p>三十一.Synchronized 用过吗，其原理是什么？</p> 
<p>重量解锁，可以修饰方法，也可以修饰代码块。是通过监视器实现的。一个监视器的锁只能被一个线程持有，这样保证了同一时刻只有一个线程执行这段代码。<br> 进入监视器时enter、退出时exit、并且监视器有一个计数器。这个线程获得了这个锁计数器就加一，同一个线程再次获得这个锁时就再加一。<br> 最后这个计数器为零时表明其他线程可以访问这段代码了。</p> 
<p>三十二.什么是可重入性？</p> 
<p>如果当前线程持有了这个锁，那么再有这个锁的同步方法或代码块时这个线程可以再次进入。</p> 
<p>三十三.jvm 锁做了哪些优化？</p> 
<p>分为偏向锁（单线程访问的场景，加锁解锁速度快）、轻量级锁（多线程执行时的执行速度很快的场景，会进行自旋，效率更高）、重量级锁</p> 
<p>三十四.锁消除和锁粗化？</p> 
<p>锁消除：jvm在编译器会对代码进行是否可逃逸分析，发现同步的代码不可以让其他线程访问到就会进行锁消除。</p> 
<p>锁粗化：就是看同步块之间没有同步的代码执行的速度是否快，如果未同步的代码执行速度很快。那么可以将两个同步代码合为一个，这样同一个线程减少了申请锁的次数，提升了效率。</p> 
<p>三十五.乐观锁、cas？</p> 
<p>乐观锁：乐观地认为并发的问题实属罕见，通过version来控制并发修改的问题。每次修改version都会加一，如果当前请求是获取version与最后提交时的version不同表明发生了并发问题，会更新失败。</p> 
<p>cas：compare and swap 比较值和预期值作对比，如果相同就进行更新。但是会出现ABA问题。</p> 
<p>三十六.ReentrantLock原理？</p> 
<p>是通过cas和队列实现的，先通过cas获取锁的状态-》state为零且队列为空时当前线程得到锁、state不为零时将当前线程放入队列中进行排队-》持有锁线程释放锁，判断是否为公平锁。如果是公平锁，那么队列头的线程获得锁。如果是非公平锁，那么队列中的线程都有可能获得锁。</p> 
<p>三十七.AQS?</p> 
<p>队列同步器</p> 
<p>三十八.请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。</p> 
<p>1.ReentrantLock有公平锁和非公平锁</p> 
<p>2.ReentrantLock可以终止等待</p> 
<p>3.ReentrantLock可以分组唤醒</p> 
<p>4.Synchronized使用起来更便捷，ReentrantLock功能更多，带需要手动释放锁。</p> 
<p>三十九.ReentrantLock 是如何实现可重入性的？</p> 
<p>获得锁的线程再次进入同步块的时候state会加一，释放锁的时候回减一。</p> 
<p>四十.ReadWriteLock 和 StampedLock</p> 
<p>ReadWriteLock:读写锁，允许多线程并发读操作。StampedLock：相对于ReadWriteLock的一个优化，ReadWriteLock并发读线程回阻塞写线程。而StampedLock则不会。</p> 
<p>四十一.如何让 Java 的线程彼此同步？</p> 
<p>wait、notify、park、unpark</p> 
<p>四十二.CyclicBarrier 和 CountDownLatch区别？</p> 
<p>CyclicBarrier：控制并发进入的现成的数量 CountDownLatch：减数器，主线程可以阻塞等待，知道减数器为零。</p> 
<p><strong>更多面试题请访问</strong><a href="https://www.javaoffers.com" rel="nofollow">www.javaoffers.com</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3a43bfc9fa867523e702f74c129ea14b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PHP的内存限制Allowed memory size of之memory_limit</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7619dfdd9afc32e3b91538c3a850d65e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">屏幕适配方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>