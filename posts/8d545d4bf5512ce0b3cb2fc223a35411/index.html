<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构 第3讲 顺序表 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构 第3讲 顺序表" />
<meta property="og:description" content="数据结构 第3讲 顺序表
顺序表是最简单的一种线性结构，逻辑上相邻的数据在计算机内的存储位置也是相邻的，可以快速定位第几个元素，中间不允许有空，所以插入、删除时需要移动大量元素。
顺序表可以分配一段连续的存储空间Maxsize，用elem记录基地址，用length记录实际的元素个数，即顺序表的长度，
结构体的定义：
结构体定义后，如果要定义个顺序表L，就可以写：
SqList L;
1. 顺序表初始化
初始化是指给顺序表分配一个预定义大小的空间，用基地址elem记录这段空间的首地址，里面什么都没用，元素个数为0。前面我们已经预定义好了一个最大空间数Maxsize，那么就用new分配这么大的空间，分配成功会返回空间的首地址。假设顺序表里面需要存储整型数，那么就可以这样初始化：
boolInitList(SqList &amp;L) //构造一个空的顺序表L
{ //L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效
//不加&amp;内部改变，跳出函数后无效
L.elem=new int[Maxsize]; //为顺序表分配Maxsize个空间
if(!L.elem) return false; //存储分配失败
L.length=0; //空表长度为0
return true;
}
2. 顺序表创建
顺序表创建是向顺序表中输入数据，输入数据的类型要与类型定义中的类型一致。假设顺序表里面需要存储整型数，那么就可以这样创建：
boolCreateList(SqList &amp;L) //创建一个顺序表L
{ //L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效
//不加&amp;内部改变，跳出函数后无效
int a,i=0；
while(a!=-1)
{
cin&gt;&gt;a;
if(L.length==Maxsize)
{
cout&lt;&lt;”顺序表已满！”
return false;
}
L.elem[i&#43;&#43;]=a;
L.length&#43;&#43;;
}
return true;
}
3. 顺序表取值
顺序表中的任何一个元素都可以立即找到，称为随机存取方式，例如我们我取第i个元素，只要i值是合理的（1≤i≤L.length），那么立即就可以找到该元素L.elem[i-1]：
bool GetElem(SqList L,int i,int &amp;e)
{
if (i&lt;1||i&gt;L.length) return false; //判断i值是否合理，若不合理，返回false" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8d545d4bf5512ce0b3cb2fc223a35411/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-09-12T16:35:55+08:00" />
<meta property="article:modified_time" content="2017-09-12T16:35:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构 第3讲 顺序表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center"><span style="font-size:12pt"><strong>数据结构 第3讲 顺序表</strong></span></p> 
<p>顺序表是最简单的一种线性结构，逻辑上相邻的数据在计算机内的存储位置也是相邻的，可以快速定位第几个元素，中间不允许有空，所以插入、删除时需要移动大量元素。</p> 
<p>顺序表可以分配一段连续的存储空间Maxsize，用elem记录基地址，用length记录实际的元素个数，即顺序表的长度，</p> 
<p style="text-align:center; margin-left:63pt"><img src="https://images2.imgbox.com/98/c5/8XuAqAZ6_o.png" alt=""><br> <span style="font-family:Times New Roman; font-size:10pt"></span></p> 
<p><strong>结构体的定义：</strong></p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/a7/03/gZGgCfet_o.png" alt=""><br> </p> 
<p>结构体定义后，如果要定义个顺序表L，就可以写：</p> 
<p><span style="background-color:#d9d9d9">SqList L;</span></p> 
<p></p> 
<p>1. 顺序表初始化</p> 
<p>初始化是指给顺序表分配一个预定义大小的空间，用基地址elem记录这段空间的首地址，里面什么都没用，元素个数为0。前面我们已经预定义好了一个最大空间数Maxsize，那么就用new分配这么大的空间，分配成功会返回空间的首地址。假设顺序表里面需要存储整型数，那么就可以这样初始化：</p> 
<p align="left">boolInitList(SqList &amp;L) //构造一个空的顺序表L</p> 
<p align="left">{   //L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效</p> 
<p align="left">    //不加&amp;内部改变，跳出函数后无效</p> 
<p align="left">    L.elem=new int[Maxsize];    //为顺序表分配Maxsize个空间</p> 
<p align="left">    if(!L.elem) return false;      //存储分配失败</p> 
<p align="left">    L.length=0;                          //空表长度为0</p> 
<p align="left">    return true;</p> 
<p align="left">}</p> 
<p>2. 顺序表创建</p> 
<p></p> 
<p></p> 
<p>顺序表创建是向顺序表中输入数据，输入数据的类型要与类型定义中的类型一致。假设顺序表里面需要存储整型数，那么就可以这样创建：</p> 
<p align="left">boolCreateList(SqList &amp;L) //创建一个顺序表L</p> 
<p align="left">{   //L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效</p> 
<p align="left">    //不加&amp;内部改变，跳出函数后无效</p> 
<p align="left">    int a,i=0；</p> 
<p align="left">   while(a!=-1)</p> 
<p align="left">   {<!-- --></p> 
<p align="left">       cin&gt;&gt;a;</p> 
<p align="left">      if(L.length==Maxsize)</p> 
<p align="left">     {<!-- --></p> 
<p align="left">          cout&lt;&lt;”顺序表已满！”</p> 
<p align="left">          return false;</p> 
<p align="left">     }</p> 
<p align="left">    L.elem[i++]=a;</p> 
<p align="left">      L.length++;</p> 
<p align="left">   }</p> 
<p align="left">    return true;</p> 
<p align="left">}</p> 
<p>3. 顺序表取值</p> 
<p>顺序表中的任何一个元素都可以立即找到，称为随机存取方式，例如我们我取第i个元素，只要i值是合理的（1<span style="font-family:宋体">≤</span>i<span style="font-family:宋体">≤</span>L.length），那么立即就可以找到该元素L.elem[i-1]：</p> 
<p>bool GetElem(SqList L,int i,int &amp;e)</p> 
<p>{<!-- --></p> 
<p>    if (i&lt;1||i&gt;L.length) return false; </p> 
<p>      //判断i值是否合理，若不合理，返回false</p> 
<p>    e=L.elem[i-1]; //第i-1的单元存储着第i个数据</p> 
<p>   return true;</p> 
<p>}</p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/5e/4c/0HT5qiYa_o.png" alt=""><br> </p> 
<p>4. 顺序表查找</p> 
<p>在顺序表中查找一个元素e，需要从第一个元素开始顺序查找，依次比较每一个元素值，如果相等，则返回元素位置(第几个元素)，如果查找整个顺序表都没找到，则返回-1：</p> 
<p>int LocateELem(SqList L,int e)</p> 
<p>{<!-- --></p> 
<p>   for (i=0;i&lt; L.length;i++)</p> 
<p>       if (L.elem[i]==e) return i+1; //第几个元素，例如第5个元素，下标其实为4</p> 
<p>  return -1;</p> 
<p>}</p> 
<p>时间复杂性分析：</p> 
<p><strong>最好情况：</strong>如果元素正好在第一个位置，一次比较成功；时间复杂度为<em>O</em>(1);</p> 
<p><strong>最坏情况：</strong>如果元素正好在最后一个位置，需要比较<em>n</em>次成功，时间复杂度为<em>O</em>(<em>n</em>);</p> 
<p><strong>平均情况：</strong>假设每个元素查找概率均等，在第一个位置需要比较1次，第二个位置需要比较2次，<span style="font-family:宋体">…，最后一个位置，需要比较</span><em>n</em>次，把<em>n</em>种情况加起来平均，平均时间复杂度也为<em>O</em>(<em>n</em>)：<span style="background-color:#d9d9d9"></span></p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/aa/20/NqwDxhDi_o.png" alt=""><br> </p> 
<p>5. 顺序表插入</p> 
<p>在顺序表中第<em>i</em>个位置之前插入一个元素<em>e</em>，需要从最后一个元素开始后移，<span style="font-family:宋体">…，直到把第</span><em>i</em>个元素也后移一位，然后把<em>e</em>放入第<em>i</em>个位置。</p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/ca/d1/30uXMWVo_o.png" alt=""><br> </p> 
<p>（1）判断插入位置<em>i</em>是否合法（1<span style="font-family:宋体">≤</span><em>i</em><span style="font-family:宋体">≤</span>L.length+1），可以在第<em>n</em>+1个元素之前插入。</p> 
<p>（2）判断顺序表的存储空间是否已满。 </p> 
<p>（3）将第<em>n</em>至第<em>i </em>位的元素依次向后移动一个位置，空出第<em>i</em>个位置。</p> 
<p>（4）将要插入的新元素<em>e</em>放入第<em>i</em>个位置。</p> 
<p>（5）表长加1，插入成功返回true。</p> 
<p>bool ListInsert_Sq(SqList &amp;L,int i ,int e)</p> 
<p>{<!-- --></p> 
<p>   if(i&lt;1 || i&gt;L.length+1) return false;     //i值不合法</p> 
<p>   if(L.length==Maxsize) return false; //存储空间已满 </p> 
<p>   for(j=L.length-1;j&gt;=i-1;j--) </p> 
<p>      L.elem[j+1]=L.elem[j]; //从最后一个元素开始后移，直到第i个元素后移</p> 
<p>   L.elem[i-1]=e; //将新元素e放入第i个位置</p> 
<p>   L.length++;             //表长增1</p> 
<p>  return true;</p> 
<p>}</p> 
<p>时间复杂性分析：</p> 
<p>假设每个位置插入的概率均等，可以在第一个位置之前插入，第二个位置之前插入，<span style="font-family:宋体">…，最后一个位置之前，第</span><em>n</em>+1个位置之前，一共有<em>n</em>+1种情况，每种情况移动元素的个数是<em>n</em>-<em>i</em>+1，把所有情况加起来平均，平均时间复杂度为<em>O</em>(<em>n</em>)：<span style="background-color:#d9d9d9"></span></p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/ad/1a/Xw9A6K45_o.png" alt=""><br> </p> 
<p>6. 顺序表删除</p> 
<p>在顺序表中删除第<em>i</em>个元素，需要把该元素暂存到变量<em>e</em>，然后从<em>i</em>+1个元素开始前移，<span style="font-family:宋体">…，直到把第</span><em>n</em>个元素也前移一位，然后把<em>e</em>放入第<em>i</em>个位置。</p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/5c/02/ir3bQtvC_o.png" alt=""><br> </p> 
<p>（1）判断插入位置<em>i</em>是否合法（1≤<em>i</em>≤L.length）。</p> 
<p>（2）将欲删除的元素保留在<em>e</em>中。 </p> 
<p>（3）将第<em>i</em>+1至第<em>n</em> 位的元素依次向前移动一个位置。</p> 
<p>（4）表长减1，删除成功返回true。</p> 
<p>bool ListDelete_Sq(SqList &amp;L,int i, int &amp;e)</p> 
<p>{<!-- --></p> 
<p>   if((i&lt;1)||(i&gt;L.length)) return false;     //i值不合法</p> 
<p>  e=L.elem[i-1]; //将欲删除的元素保留在<em>e</em>中</p> 
<p>  for (j=i;j&lt;=L.length-1;j++) </p> 
<p>　 　L.elem[j-1]=L.elem[j]; //被删除元素之后的元素前移 </p> 
<p>  L.length--;      //表长减1</p> 
<p>  return true;</p> 
<p>}</p> 
<p>时间复杂性分析：</p> 
<p>假设删除每个元素的概率均等，一共有<em>n</em>种情况，每种情况移动元素的个数是<em>n</em>-<em>i</em>，把所有情况加起来平均，平均时间复杂度为<em>O</em>(<em>n</em>)：<span style="background-color:#d9d9d9"></span></p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/9f/e8/BuW6w2DC_o.png" alt=""><br> <span style="color:red"></span></p> 
<p><span style="color:red"></span></p> 
<p>完整代码</p> 
<p>#include &lt;iostream&gt;</p> 
<p>using namespace std;</p> 
<p> </p> 
<p>#define  Maxsize 100  //最大空间</p> 
<p> </p> 
<p>typedef struct{<!-- --></p> 
<p>  int *elem;</p> 
<p>  int length;       // 顺序表的长度</p> 
<p>}SqList;</p> 
<p> </p> 
<p>bool InitList(SqList &amp;L) //构造一个空的顺序表L</p> 
<p>{   //L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效</p> 
<p>//不加&amp;内部改变，跳出函数后无效</p> 
<p>    L.elem=new int[Maxsize];    //为顺序表分配Maxsize个空间</p> 
<p>    if(!L.elem) return false;      //存储分配失败</p> 
<p>    L.length=0;                          //空表长度为0</p> 
<p>    return true;</p> 
<p>}</p> 
<p> </p> 
<p>bool CreateList(SqList &amp;L) //创建一个顺序表L</p> 
<p>{   //L加&amp;表示引用类型参数，函数内部的改变跳出函数仍然有效</p> 
<p>//不加&amp;内部改变，跳出函数后无效</p> 
<p>    int a,i=0;</p> 
<p>    cin&gt;&gt;a;</p> 
<p>    while(a!=-1)</p> 
<p>    {<!-- --></p> 
<p>     if(L.length==Maxsize)</p> 
<p>     {<!-- --></p> 
<p>       cout&lt;&lt;"顺序表已满！";</p> 
<p>       return false;</p> 
<p>     }</p> 
<p>     L.elem[i++]=a;</p> 
<p>     L.length++;</p> 
<p>     cin&gt;&gt;a;</p> 
<p>   }</p> 
<p>   return true;</p> 
<p>}</p> 
<p> </p> 
<p>bool GetElem(SqList L,int i,int &amp;e)</p> 
<p>{<!-- --></p> 
<p>  if (i&lt;1||i&gt;L.length) returnfalse;</p> 
<p>   //判断i值是否合理，若不合理，返回false</p> 
<p>  e=L.elem[i-1];   //第i-1的单元存储着第i个数据</p> 
<p>  return true;</p> 
<p>}</p> 
<p> </p> 
<p>int LocateELem(SqList L,int x)</p> 
<p>{<!-- --></p> 
<p>  for (int i=0;i&lt;L.length;i++)</p> 
<p>      if (L.elem[i]==x) return i+1;//第几个元素，例如第5个元素，下标其实为4</p> 
<p>  return -1;</p> 
<p>}</p> 
<p> </p> 
<p>bool ListInsert_Sq(SqList &amp;L,int i ,int e)</p> 
<p>{<!-- --></p> 
<p>   if(i&lt;1 || i&gt;L.length+1)return false; //i值不合法</p> 
<p>   if(L.length==Maxsize) returnfalse; //存储空间已满</p> 
<p>   for(intj=L.length-1;j&gt;=i-1;j--)</p> 
<p>       L.elem[j+1]=L.elem[j];   //从最后一个元素开始后移，直到第i个元素后移</p> 
<p>   L.elem[i-1]=e;              //将新元素e放入第i个位置</p> 
<p>   L.length++;                      //表长增1</p> 
<p>   return true;</p> 
<p>}</p> 
<p> </p> 
<p>bool ListDelete_Sq(SqList &amp;L,int i,int &amp;e)</p> 
<p>{<!-- --></p> 
<p>   if((i&lt;1)||(i&gt;L.length))return false;  //i值不合法</p> 
<p>   e=L.elem[i-1];   //将欲删除的元素保留在e中</p> 
<p>   for (int j=i; j&lt;=L.length-1; j++)</p> 
<p>              L.elem[j-1] =L.elem[j]; //被删除元素之后的元素前移</p> 
<p>   L.length--; //表长减1</p> 
<p>   return true;</p> 
<p>}</p> 
<p> </p> 
<p>void print(SqList L)</p> 
<p>{<!-- --></p> 
<p>   cout &lt;&lt; "输出顺序表" &lt;&lt;endl;</p> 
<p>   for(int j=0;j&lt;=L.length-1;j++)</p> 
<p>    cout&lt;&lt;L.elem[j]&lt;&lt;"  ";</p> 
<p>   cout&lt;&lt;endl;</p> 
<p>}</p> 
<p> </p> 
<p>void DestroyList(SqList &amp;L)</p> 
<p>{<!-- --></p> 
<p>  if (L.elem) delete []L.elem;    //释放存储空间</p> 
<p>}</p> 
<p> </p> 
<p>int main()</p> 
<p>{<!-- --></p> 
<p>    SqList myL;</p> 
<p>    int i,e,x;</p> 
<p>    cout &lt;&lt; "1. 初始化\n";</p> 
<p>       cout &lt;&lt; "2. 创建\n";</p> 
<p>       cout &lt;&lt; "3. 取值\n";</p> 
<p>       cout &lt;&lt; "4. 查找\n";</p> 
<p>       cout &lt;&lt; "5. 插入\n";</p> 
<p>       cout &lt;&lt; "6. 删除\n";</p> 
<p>       cout &lt;&lt; "7. 输出\n";</p> 
<p>       cout &lt;&lt; "8. 销毁\n";</p> 
<p>       cout &lt;&lt; "0. 退出\n";</p> 
<p> </p> 
<p>       int choose = -1;</p> 
<p>       while (choose != 0)</p> 
<p>       {<!-- --></p> 
<p>        cout &lt;&lt; "请选择:";</p> 
<p>              cin &gt;&gt; choose;</p> 
<p>              switch (choose)</p> 
<p>              {<!-- --></p> 
<p>                  case 1://初始化顺序表</p> 
<p>                      cout &lt;&lt; "顺序表初始化..." &lt;&lt;endl;</p> 
<p>                      if(InitList(myL))</p> 
<p>                    cout &lt;&lt;"顺序表初始化成功！" &lt;&lt; endl;</p> 
<p>                else</p> 
<p>                    cout &lt;&lt;"顺序表初始化失败！" &lt;&lt; endl;</p> 
<p>                      break;</p> 
<p>                   case 2://创建顺序表</p> 
<p>                       cout &lt;&lt; "顺序表创建..." &lt;&lt;endl;</p> 
<p>                       cout &lt;&lt; "输入整型数，输入-1结束" &lt;&lt;endl;</p> 
<p>                       if(CreateList(myL))</p> 
<p>                    cout &lt;&lt;"顺序表创建成功！" &lt;&lt; endl;</p> 
<p>                 else</p> 
<p>                    cout &lt;&lt;"顺序表创建失败！" &lt;&lt; endl;</p> 
<p>                 break;</p> 
<p>            case 3://取值</p> 
<p>                cout &lt;&lt; "输入整型数i，取第i个元素输出" &lt;&lt;endl;</p> 
<p>                cin&gt;&gt;i;</p> 
<p>                if(GetElem(myL,i,e))</p> 
<p>                    cout &lt;&lt;"第i个元素是： " &lt;&lt;e&lt;&lt; endl;</p> 
<p>                 else</p> 
<p>                    cout &lt;&lt;"顺序表取值失败！" &lt;&lt; endl;;</p> 
<p>                cout &lt;&lt; "第i个元素是： "&lt;&lt;e&lt;&lt; endl;</p> 
<p>                break;</p> 
<p>            case 4://查找</p> 
<p>                cout &lt;&lt; "请输入要查找的数x:";</p> 
<p>                cin&gt;&gt;x;</p> 
<p>               if(LocateELem(myL,x)==-1)</p> 
<p>                    cout &lt;&lt;"查找失败！" &lt;&lt; endl;</p> 
<p>                else</p> 
<p>                    cout &lt;&lt;"查找成功！" &lt;&lt; endl;</p> 
<p>                break;</p> 
<p>            case 5://插入</p> 
<p>                cout &lt;&lt; "请输入要插入的位置和要插入的数据元素e:";</p> 
<p>               cin&gt;&gt;i&gt;&gt;e;</p> 
<p>               if(ListInsert_Sq(myL,i,e))</p> 
<p>                    cout &lt;&lt;"插入成功！" &lt;&lt; endl;</p> 
<p>                else</p> 
<p>                    cout &lt;&lt;"插入失败！" &lt;&lt; endl;</p> 
<p>                break;</p> 
<p>             case 6://删除</p> 
<p>                cout &lt;&lt; "请输入要删除的位置i:";</p> 
<p>                cin&gt;&gt;i;</p> 
<p>               if(ListDelete_Sq(myL,i,e))</p> 
<p>                    cout &lt;&lt;" 删除成功！" &lt;&lt; endl;</p> 
<p>                else</p> 
<p>                    cout &lt;&lt;"删除失败！" &lt;&lt; endl;</p> 
<p>                break;</p> 
<p>            case 7://输出</p> 
<p>                print(myL);</p> 
<p>                break;</p> 
<p>            case 8://销毁</p> 
<p>                cout &lt;&lt; "顺序表销毁..."&lt;&lt;endl;</p> 
<p>                DestroyList(myL);</p> 
<p>                break;</p> 
<p>        }</p> 
<p>       }</p> 
<p>    return 0;</p> 
<p>}</p> 
<p style="text-align:justify"><span style="color:red"></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5ce4b53833b5370da3c9eb5e2774eeff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java中cloneable的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2315c03835a393f448e2679fa7afd703/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【异步FIFO的一些小事·1】空满判断与格雷码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>