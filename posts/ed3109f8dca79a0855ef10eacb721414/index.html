<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring-全面详解（基础知识） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring-全面详解（基础知识）" />
<meta property="og:description" content="简介 Spring5框架
内容介绍：
1.Spring概念
2.IOC容器
3.Aop
4.JDBCTEmplate
5.事物管理
6.Spring5新特性
所需的jar包
参考俺滴下面博客
Spring所需jar包_爱你的阿白~的博客-CSDN博客
一.Spring框架概述 1.概述 1.Spring框架是轻量级的JavaEE框架
2.Spring可以解决企业应用开发的复杂性
3.Spring有两个核心部分：IOC和Aop
（1）IOC：控制反转，把创建对象的过程交给Spring进行管理
（2）Aop：面向切面，不修改源代码进行功能增强
4.Spring特点
（1）方便解耦，简化开发
（2）Aop变成支持
（3）方便程序测试
（4）方便和其他框架进行整合
（5）方便进行事物操作
（6）降低API开发难度
5.Spring5
2.入门案例 （1）下载spring 最后是这个网址
https://repo.spring.io/ui/native/release/org/springframework/spring/ 下载解压
（2）创建新的项目 （3）导入jar包 把所需的jar包导入其中
导入流程：
在项目文件夹中建立lab文件夹
把jar包放入文件夹中
（4）创建普通类 在这个类中创建普通方法
（5）创建Spring配置文件 在配置文件中配置创建的对象
1.Spring配置文件使用xml文件格式
（6）测试代码编写 二，IOC容器 1.IOC底层原理 （1）什么是IOC 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 one：控制反转，把对象的创建和对象的调用过程交给Spring进行管理
two：使用IOC的目的：为了耦合度降低
three：做入门案例就是IOC的实现
（2）IOC底层原理 （1）xml解析，工厂模式，反射
（3）画图讲解IOC底层原理 IOC过程
（1）配置xml文件，配置创建的对象
（2）有service类和dao类，创建工厂类
2.IOC接口（BeanFactory） 1.IOC思想基于IOC容器完成，IOC容器底层就是对象工厂
2.Spring提供IOC容器实现的两种方式：（两个接口）
（1）BeanFactory：
IOC容器中最基本实现方式，时Spring内部使用的接口，不提供开发人员进行使用
特点：加载配置文件的时候不会去创建对象，在获取对象（使用）才会去创建对象
（2）ApplicationContext：
BeanFactory接口的子接口，提供更多更强大的功能，一般有开发人员进行使用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ed3109f8dca79a0855ef10eacb721414/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-24T17:12:56+08:00" />
<meta property="article:modified_time" content="2022-03-24T17:12:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring-全面详解（基础知识）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>简介</h2> 
<p>Spring5框架</p> 
<p>内容介绍：</p> 
<p>1.Spring概念</p> 
<p>2.IOC容器</p> 
<p>3.Aop</p> 
<p>4.JDBCTEmplate</p> 
<p>5.事物管理</p> 
<p>6.Spring5新特性</p> 
<hr> 
<hr> 
<p>所需的jar包</p> 
<p>参考俺滴下面博客</p> 
<p><a href="https://blog.csdn.net/m0_63324772/article/details/123690842?spm=1001.2014.3001.5501" title="Spring所需jar包_爱你的阿白~的博客-CSDN博客">Spring所需jar包_爱你的阿白~的博客-CSDN博客</a></p> 
<p></p> 
<h2>一.Spring框架概述</h2> 
<hr> 
<p></p> 
<h3>1.概述</h3> 
<hr> 
<p></p> 
<p><strong>1.Spring框架是轻量级的JavaEE框架</strong></p> 
<p><strong>2.Spring可以解决企业应用开发的复杂性</strong></p> 
<p><strong>3.Spring有两个核心部分：IOC和Aop</strong></p> 
<p>（1）IOC：控制反转，把创建对象的过程交给Spring进行管理</p> 
<p>（2）Aop：面向切面，不修改源代码进行功能增强</p> 
<p><strong>4.Spring特点</strong></p> 
<p>（1）方便解耦，简化开发</p> 
<p>（2）Aop变成支持</p> 
<p>（3）方便程序测试</p> 
<p>（4）方便和其他框架进行整合</p> 
<p>（5）方便进行事物操作</p> 
<p>（6）降低API开发难度</p> 
<p><strong>5.Spring5</strong></p> 
<hr> 
<hr> 
<p></p> 
<h3>2.入门案例</h3> 
<p></p> 
<h4>（1）下载spring</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9c/f6/pTUo4Msq_o.png"></p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/77/d2/8vGS0ntm_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6f/14/u35YniNQ_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/92/6d/o8QMMSH9_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ff/04/vSZ79oL5_o.png"></p> 
<p>最后是这个网址</p> 
<pre>https://repo.spring.io/ui/native/release/org/springframework/spring/</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/08/09/COmThogs_o.png"></p> 
<p>下载解压</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/65/9b/MkWOLHvR_o.png"></p> 
<h4>（2）创建新的项目</h4> 
<p></p> 
<p></p> 
<h4>（3）导入jar包</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/42/19/rhu5mwTd_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/30/OFzXBXtD_o.png"></p> 
<p>把所需的jar包导入其中</p> 
<p>导入流程：</p> 
<p>在项目文件夹中建立lab文件夹</p> 
<p>把jar包放入文件夹中</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b8/b3/nyAagrLj_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/27/e2/xCAgLKjA_o.png"></p> 
<p></p> 
<h4>（4）创建普通类</h4> 
<p>在这个类中创建普通方法</p> 
<p></p> 
<h4>（5）创建Spring配置文件</h4> 
<p>在配置文件中配置创建的对象</p> 
<p>1.Spring配置文件使用xml文件格式</p> 
<p></p> 
<h4>（6）测试代码编写</h4> 
<p></p> 
<p></p> 
<h2>二，IOC容器</h2> 
<p></p> 
<p></p> 
<h3>1.IOC底层原理</h3> 
<h4>（1）什么是IOC</h4> 
<pre>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</pre> 
<p><strong>one：控制反转，把对象的创建和对象的调用过程交给Spring进行管理</strong></p> 
<p><strong>two：使用IOC的目的：为了耦合度降低</strong></p> 
<p><strong>three：做入门案例就是IOC的实现</strong></p> 
<p></p> 
<h4>（2）IOC底层原理</h4> 
<p></p> 
<p>（1）xml解析，工厂模式，反射</p> 
<p></p> 
<h4>（3）画图讲解IOC底层原理</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0a/f2/1QW8palF_o.png"></p> 
<p><strong>IOC过程</strong></p> 
<p>（1）配置xml文件，配置创建的对象</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/54/5a/OT58sVXd_o.png"></p> 
<p>（2）有service类和dao类，创建工厂类</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/24/2c/7iWz9zbE_o.png"></p> 
<p></p> 
<p></p> 
<hr> 
<p></p> 
<p></p> 
<h3>2.IOC接口（BeanFactory）</h3> 
<p><strong>1.IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</strong></p> 
<p></p> 
<p><strong>2.Spring提供IOC容器实现的两种方式：（两个接口</strong>）</p> 
<p><strong>（1）BeanFactory：</strong></p> 
<p>IOC容器中最基本实现方式，时Spring内部使用的接口，不提供开发人员进行使用</p> 
<p><strong>特点：</strong>加载配置文件的时候不会去创建对象，在获取对象（使用）才会去创建对象</p> 
<p><strong>（2）ApplicationContext：</strong></p> 
<p>BeanFactory接口的子接口，提供更多更强大的功能，一般有开发人员进行使用</p> 
<p><strong>特点：</strong>加载配置文件时候就会把在配置文件的对象进行创建</p> 
<p></p> 
<p><strong>3.ApplicationContext接口有实现类</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4d/28/pTRFQWAZ_o.png"></p> 
<p>FlieSystemXmlApplicationContext对应电脑的盘符路径</p> 
<p>ClassPathXmlApplicationContext类路径</p> 
<p></p> 
<hr> 
<p></p> 
<p></p> 
<p></p> 
<h3>3.IOC操作Bean管理（基于xml）</h3> 
<p></p> 
<p></p> 
<h4>（1）Bean管理定义：</h4> 
<p>Bean管理指的是两个操作</p> 
<p></p> 
<p>1.Spring创建对象</p> 
<p>2.Spring注入属性</p> 
<p></p> 
<p></p> 
<p></p> 
<h4>（2）Bean管理操作的两种方式</h4> 
<pre>​
1.基于xml方式创建对象
​
2.基于注解方式的实现</pre> 
<p></p> 
<p></p> 
<p></p> 
<p>1.基于xml配置文件方式的实现</p> 
<pre>&lt;!--配置User对象创建--&gt;
    &lt;bean id = "user" class="com.spring.User"&gt;&lt;/bean&gt;</pre> 
<p>（1）在Spring中使用bean标签，在标签里面添加对应的属性，就可以实现对象的创建</p> 
<p>（2）在bean标签中有许多的属性，介绍常用的属性</p> 
<p>*id属性：唯一标识</p> 
<p>*class属性：类全路径（包类路径）</p> 
<p>*name属性：和id一样，但是在name中可以加入些特殊符号</p> 
<p>（3）创建对象的时候，默认是执行无参数构造方法</p> 
<p></p> 
<p>2.基于xml方式注入属性</p> 
<p></p> 
<p>（1）DI：依赖注入，就是注入属性</p> 
<p>3.第一种注入方式：使用set方法进行注入</p> 
<p>（1）创建类，定义属性和对应的set方法</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/20/d9/rJeT4sll_o.png"></p> 
<p></p> 
<p>（2）在Spring配置文件配置对象的创建，配置属性注入</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bd/08/Mn6xxOyL_o.png"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>最后测试：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/62/83/nk7VPQqu_o.png"></p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ea/53/yyw6PlWh_o.png"></p> 
<p></p> 
<p>4.第二种注入方式：通过有参构造注入</p> 
<p>（1）创建类，定义属性，创建属性对应有参数构造方法</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5b/43/nyvk1w4x_o.png"></p> 
<p></p> 
<p>（2）在Spring文件中进行配置</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/82/bc/0FypO8yS_o.png"></p> 
<p>测试：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c7/b7/VQyKPgff_o.png"></p> 
<p></p> 
<p></p> 
<p>5.p名称空间注入（了解）</p> 
<p>（1）使用P名称空间注入，可以简化基于xml配置方式</p> 
<p></p> 
<p>第一步：添加p名称空间在配置文件中</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b5/94/a8FuBzDH_o.png"></p> 
<p>第二步：进行属性注入，在bean标签里面进行操作</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/29/a4/jAGRoCrl_o.png"></p> 
<p></p> 
<p>测试：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fb/23/0O5niLRL_o.png"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h4>（3）IOC操作Bean管理（xml注入其他类型的操作）</h4> 
<p><strong>字面量</strong></p> 
<p>one：null值</p> 
<p>eg：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e9/09/Bb2hfDwd_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c1/a8/FVbfwbwk_o.png"></p> 
<p></p> 
<p>测试：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8f/3e/0hdwr63Z_o.png"></p> 
<p>two：属性值包含特殊符号</p> 
<pre>1.把&lt;&gt;进行转义&amp;lt;&amp;gt;</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/eb/90/BHeCmtjH_o.png"></p> 
<pre>2.把带特殊符号内容写到CDATA</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/54/5d/o4MnDK4L_o.png"></p> 
<p></p> 
<p>测试：（两个的输出结果都一样）</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e1/59/68RfmqCf_o.png"></p> 
<p></p> 
<p></p> 
<p>three：注入属性-外部bean</p> 
<p></p> 
<p>1.创建两个类service和dao类</p> 
<p>2.在service调用dao里面的方法</p> 
<p>3.在Spring配置文件中进行配置</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b0/ae/Q9SEzXNi_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/04/52/S1fGMMwv_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ac/51/9InIhkjd_o.png"></p> 
<p>测试：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2a/0b/33TwYIXK_o.png"></p> 
<p>four：注入属性-内部bean</p> 
<ol><li> <p>一对多关系：部门和员工</p> <p>一个部门有多个员工，一个员工属于一个部门</p> <p>部门是一，员工是多</p> </li><li> <p>在实体类之间表示一对多的关系，员工表示所属部门，使用对象类型属性进行表示</p> </li><li> <p>在Spring的配置文件中进行配置</p> </li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/82/bb/8XP77F77_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f1/1d/WYnLVvA9_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3c/91/7AlwgKnd_o.png"></p> 
<p></p> 
<p>测试：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5a/8c/piiyhxk6_o.png"></p> 
<p>five：注入属性-级联赋值</p> 
<p><strong>1.第一种写法</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f3/ca/S415NEid_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ae/17/1D5hbZe0_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f4/6e/kC9W3qTf_o.png"></p> 
<p>测试：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b1/63/Psic44pU_o.png"></p> 
<p><strong>2.第二种写法</strong></p> 
<p>Dept.java</p> 
<p>Testbean.java同上</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4d/dc/DXv2ecqv_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/92/44/zoWaOYpx_o.png"></p> 
<p></p> 
<p>测试：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7d/a2/bSCyZcdK_o.png"></p> 
<p></p> 
<hr> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h4>（4）IOC操作Bean管理（xml注入集合属性）</h4> 
<ol><li> <p>注入数组类型属性</p> </li><li> <p>注入List集合类型属性</p> </li><li> <p>注入Map集合类型属性</p> </li></ol> 
<p>1.创建类</p> 
<p><strong>定义数组，List，Map，Set类型的属性，生成对应的set方法</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fe/c9/ghww8bwL_o.png"></p> 
<pre>package com.spring.collectiontype;
​
import java.nio.MappedByteBuffer;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
​
/**
 * @author yanchaochao
 * @date 2022/3/17 20:34
 */
public class Stu {
    //1.数组类型
    private String[] courses;
​
    //2.list集合类型属性
    private List&lt;String&gt; list;
​
    //3.创建Map集合属性
    private Map&lt;String,String&gt; maps;
​
    //4.set集合类型
    private Set&lt;String&gt; sets;
​
​
​
    public void setCourses(String[] courses) {
        this.courses = courses;
    }
​
    public void setList(List&lt;String&gt; list) {
        this.list = list;
    }
​
    public void setMaps(Map&lt;String, String&gt; maps) {
        this.maps = maps;
    }
​
    public void setSets(Set&lt;String&gt; sets) {
        this.sets = sets;
​
    }
​
    //测试
    public void test(){
        System.out.println(Arrays.toString(courses));
        System.out.println(list);
        System.out.println(maps);
        System.out.println(sets);
    }
}</pre> 
<p><strong>2.在spring配置文件进行配置</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ef/f4/2zvxyW0G_o.png"></p> 
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
​
        &lt;!--1.集合类型属性注入--&gt;
        &lt;bean id="stu" class="com.spring.collectiontype.Stu"&gt;
​
                &lt;!--数组类型属性注入--&gt;
                &lt;property name="courses"&gt;
                        &lt;array&gt;
                                &lt;value&gt;java&lt;/value&gt;
                                &lt;value&gt;c&lt;/value&gt;
                                &lt;value&gt;c++&lt;/value&gt;
                                &lt;value&gt;算法&lt;/value&gt;
                                &lt;value&gt;mysql&lt;/value&gt;
                        &lt;/array&gt;
                &lt;/property&gt;
​
                &lt;!--list类型属性注入--&gt;
                &lt;property name="list"&gt;
                        &lt;list&gt;
                                &lt;value&gt;张三&lt;/value&gt;
                                &lt;value&gt;小三&lt;/value&gt;
                        &lt;/list&gt;
                &lt;/property&gt;
​
                &lt;!--map类型属性注入--&gt;
                &lt;property name="maps"&gt;
                        &lt;map&gt;
                                &lt;entry key="JAVA" value="java"&gt;&lt;/entry&gt;
                                &lt;entry key="C" value="c"&gt;&lt;/entry&gt;
                        &lt;/map&gt;
                &lt;/property&gt;
​
                &lt;!--set类型属性注入--&gt;
                &lt;property name="sets"&gt;
                       &lt;set&gt;
                               &lt;value&gt;MySQL&lt;/value&gt;
                               &lt;value&gt;Redis&lt;/value&gt;
                       &lt;/set&gt;
                &lt;/property&gt;
        &lt;/bean&gt;
&lt;/beans&gt;</pre> 
<p>测试：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/22/15/ILeGljcU_o.png"></p> 
<pre>package com.spring.testdemo;
​
import com.spring.collectiontype.Stu;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
​
/**
 * @author yanchaochao
 * @date 2022/3/17 21:19
 */
public class Testcollectiontype {
    @Test
    public void testCollection(){
        ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
        Stu stu = context.getBean("stu", Stu.class);
        stu.test();
​
    }
}
​</pre> 
<p></p> 
<p><strong>3.在集合里设置对象类型值</strong></p> 
<pre>&lt;!--创建多个course对象--&gt;
        &lt;bean id="course1" class="com.spring.collectiontype.Course"&gt;
                &lt;property name="cname" value="Spring5框架"&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean id="course2" class="com.spring.collectiontype.Course"&gt;
                &lt;property name="cname" value="MySQL数据库"&gt;&lt;/property&gt;
        &lt;/bean&gt;
​</pre> 
<p></p> 
<pre> &lt;!--注入list集合类型，值是对象--&gt;
                &lt;property name="courseList"&gt;
                        &lt;list&gt;
                                &lt;ref bean="course1"&gt;&lt;/ref&gt;
                                &lt;ref bean="course2"&gt;&lt;/ref&gt;
                        &lt;/list&gt;
                &lt;/property&gt;</pre> 
<p></p> 
<p></p> 
<pre>Course.java</pre> 
<pre>package com.spring.collectiontype;
​
/**
 * @author yanchaochao
 * @date 2022/3/17 21:40
 */
public class Course {
    private  String cname;//课程名称
​
    public void setCname(String cname) {
        this.cname = cname;
    }
​
    @Override
    public String toString() {
        return "Course{" +
                "cname='" + cname + '\'' +
                '}';
    }
}
​</pre> 
<pre>Stu.java</pre> 
<pre>package com.spring.collectiontype;
​
import java.nio.MappedByteBuffer;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
​
/**
 * @author yanchaochao
 * @date 2022/3/17 20:34
 */
public class Stu {
    //1.数组类型
    private String[] courses;
​
    //2.list集合类型属性
    private List&lt;String&gt; list;
​
    //3.创建Map集合属性
    private Map&lt;String,String&gt; maps;
​
    //4.set集合类型
    private Set&lt;String&gt; sets;
​
    //学生所学多门课程
    private List&lt;Course&gt;courseList;
    public void setCourseList(List&lt;Course&gt; courseList) {
        this.courseList = courseList;
    }
​
    public void setCourses(String[] courses) {
        this.courses = courses;
    }
​
    public void setList(List&lt;String&gt; list) {
        this.list = list;
    }
​
    public void setMaps(Map&lt;String, String&gt; maps) {
        this.maps = maps;
    }
​
    public void setSets(Set&lt;String&gt; sets) {
        this.sets = sets;
​
    }
​
    //测试
    public void test(){
        System.out.println(Arrays.toString(courses));
        System.out.println(list);
        System.out.println(maps);
        System.out.println(sets);
        System.out.println(courseList);
    }
}</pre> 
<pre>bean1.xml</pre> 
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:lang="http://www.springframework.org/schema/lang"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd"&gt;
​
        &lt;!--1.集合类型属性注入--&gt;
        &lt;bean id="stu" class="com.spring.collectiontype.Stu"&gt;
​
                &lt;!--数组类型属性注入--&gt;
                &lt;property name="courses"&gt;
                        &lt;array&gt;
                                &lt;value&gt;java&lt;/value&gt;
                                &lt;value&gt;c&lt;/value&gt;
                                &lt;value&gt;c++&lt;/value&gt;
                                &lt;value&gt;算法&lt;/value&gt;
                                &lt;value&gt;mysql&lt;/value&gt;
                        &lt;/array&gt;
                &lt;/property&gt;
​
                &lt;!--list类型属性注入--&gt;
                &lt;property name="list"&gt;
                        &lt;list&gt;
                                &lt;value&gt;张三&lt;/value&gt;
                                &lt;value&gt;小三&lt;/value&gt;
                        &lt;/list&gt;
                &lt;/property&gt;
​
                &lt;!--map类型属性注入--&gt;
                &lt;property name="maps"&gt;
                        &lt;map&gt;
                                &lt;entry key="JAVA" value="java"&gt;&lt;/entry&gt;
                                &lt;entry key="C" value="c"&gt;&lt;/entry&gt;
                        &lt;/map&gt;
                &lt;/property&gt;
​
                &lt;!--set类型属性注入--&gt;
                &lt;property name="sets"&gt;
                       &lt;set&gt;
                               &lt;value&gt;MySQL&lt;/value&gt;
                               &lt;value&gt;Redis&lt;/value&gt;
                       &lt;/set&gt;
                &lt;/property&gt;
​
                &lt;!--注入list集合类型，值是对象--&gt;
                &lt;property name="courseList"&gt;
                        &lt;list&gt;
                                &lt;ref bean="course1"&gt;&lt;/ref&gt;
                                &lt;ref bean="course2"&gt;&lt;/ref&gt;
                        &lt;/list&gt;
                &lt;/property&gt;
        &lt;/bean&gt;
        &lt;!--创建多个course对象--&gt;
        &lt;bean id="course1" class="com.spring.collectiontype.Course"&gt;
                &lt;property name="cname" value="Spring5框架"&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean id="course2" class="com.spring.collectiontype.Course"&gt;
                &lt;property name="cname" value="MySQL数据库"&gt;&lt;/property&gt;
        &lt;/bean&gt;
&lt;/beans&gt;</pre> 
<p></p> 
<pre>Testcollectiontype.java</pre> 
<pre>package com.spring.testdemo;
​
import com.spring.collectiontype.Stu;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
​
/**
 * @author yanchaochao
 * @date 2022/3/17 21:19
 */
public class Testcollectiontype {
    @Test
    public void testCollection(){
        ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
        Stu stu = context.getBean("stu", Stu.class);
        stu.test();
​
    }
}
​</pre> 
<p>测试：</p> 
<p></p> 
<p></p> 
<p></p> 
<p><strong>4.把集合注入的部分提取出来</strong></p> 
<p>（1）在spring配置文件中引入名称空间util</p> 
<p>（2）使用util标签完成list集合注入提取</p> 
<p></p> 
<pre>Book.java</pre> 
<pre>package com.spring.collectiontype;
import java.util.List;
/**
 * @author yanchaochao
 * @date 2022/3/17 21:55
 */
public class Book {
    private List&lt;String&gt;list;
    public void setList(List&lt;String&gt; list) {
        this.list = list;
    }
    public void test(){
        System.out.println(list);
    }
}</pre> 
<p></p> 
<pre>bean2.xml</pre> 
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
​
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:util="http://www.springframework.org/schema/util"
​
       xsi:schemaLocation="http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/util  http://www.springframework.org/schema/util/spring-util.xsd"&gt;
​
        &lt;!--1.提取list集合类型注入--&gt;
        &lt;util:list id="booklist"&gt;
            &lt;value&gt;JAVA&lt;/value&gt;
            &lt;value&gt;C&lt;/value&gt;
            &lt;value&gt;MySQL&lt;/value&gt;
            &lt;value&gt;C++&lt;/value&gt;
            &lt;value&gt;Git&lt;/value&gt;
        &lt;/util:list&gt;
​
        &lt;!--2.提取list集合类型属性注入使用--&gt;
        &lt;bean id="book" class="com.spring.collectiontype.Book"&gt;
            &lt;property name="list" ref="booklist"&gt;&lt;/property&gt;
        &lt;/bean&gt;
&lt;/beans&gt;</pre> 
<p></p> 
<p>测试：</p> 
<pre>package com.spring.testdemo;
​
import com.spring.collectiontype.Book;
import com.spring.collectiontype.Stu;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
​
/**
 * @author yanchaochao
 * @date 2022/3/17 22:03
 */
public class TestBook {
    @Test
    public void testBook(){
        ApplicationContext context = new ClassPathXmlApplicationContext("bean2.xml");
        Book book = context.getBean("book", Book.class);
        book.test();
​
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/66/c1/5oAoYAkn_o.png"></p> 
<p></p> 
<p></p> 
<hr> 
<p></p> 
<p></p> 
<h4>（5）IOC操作Bean管理（FactoryBean）</h4> 
<p></p> 
<ol><li> <p>Spring有两种类型Bean，一种普通bean，另外一种工厂bean（FactoryBean）</p> <p></p> </li><li> <p>普通Bean：在配置文件中定义Bean类型就是返回类型</p> <p></p> </li><li> <p>工厂Bean：在配置文件定义Bean类型可以和返回类型不一样</p> <p>第一步：创建类，让这个类作为工厂bean，实现接口FactoryBean</p> <p>第二步：实现接口里面的方法，在实现的方法中定义返回的bean类型</p> </li></ol> 
<pre>MyBean.java</pre> 
<pre>package com.spring.factorybean;
​
import com.spring.collectiontype.Course;
import org.springframework.beans.factory.FactoryBean;
​
/**
 * @author yanchaochao
 * @date 2022/3/17 22:21
 */
public class MyBean implements FactoryBean&lt;Course&gt; {
​
    //定义类型和返回类型不一样
    //定义返回bean
    @Override
    public Course getObject() throws Exception {
        Course course = new Course();
        course.setCname("abc");
        return course;
    }
​
    @Override
    public Class&lt;?&gt; getObjectType() {
        return null;
    }
​
    @Override
    public boolean isSingleton() {
        return FactoryBean.super.isSingleton();
    }
}</pre> 
<pre>bean3.xml</pre> 
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/util  http://www.springframework.org/schema/util/spring-util.xsd"&gt;
​
​
    &lt;bean id="myBean" class="com.spring.factorybean.MyBean"&gt;
​
    &lt;/bean&gt;
​
&lt;/beans&gt;</pre> 
<p></p> 
<p></p> 
<p>测试：</p> 
<pre>package com.spring.testdemo;
​
import com.spring.collectiontype.Course;
import com.spring.collectiontype.Stu;
import com.spring.factorybean.MyBean;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
​
/**
 * @author yanchaochao
 * @date 2022/3/17 22:23
 */
public class Testfactorybean {
    @Test
    public void testFactoryBean(){
        ApplicationContext context = new ClassPathXmlApplicationContext("bean3.xml");
        Course course = context.getBean("myBean", Course.class);
        System.out.println(course);
​
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ee/84/vRhwgay2_o.png"></p> 
<p></p> 
<p></p> 
<h4>（6）IOC操作Bean管理（Bean的作用域）</h4> 
<p><strong>1.在Spring里面，设置创建Bean实例时单实例还是多实例</strong></p> 
<p><strong>2.在Spring里面，默认情况下，bean是单实例对象</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/70/01/P8D8ugaV_o.png"></p> 
<p></p> 
<p>由图可得出，输出的两个地址是一样的，所以可以得出在默认情况下bean是单实例对象</p> 
<p><strong>3.如何设置单实例还是多实例</strong></p> 
<p></p> 
<p>（1）在Spring配置文件bean标签里面有属性用于设置单实例还是多实例</p> 
<p>（2）scope属性值</p> 
<p>第一个值 默认值，singleton，表示单实例对象</p> 
<p>第二个值 prototype，表示多实例对象</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ab/1f/WJQSdMyP_o.png"></p> 
<p>测试：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/62/76/WBwSBZpA_o.png"></p> 
<p>两个对象的地址不一样</p> 
<p></p> 
<p>（3）singleton和prototype区别</p> 
<ol><li> <p>singleton表示单实例，prototype表示多实例</p> </li><li> <p>设置scope值是<strong>singleton</strong>时候，加载spring的时候就会创建单实例对象</p> <p>设置scope值是<strong>prototype</strong>时候，不是在加载spring配置文件时候创建对象，在调用getBean方法创建多实例对象</p> </li></ol> 
<p></p> 
<p></p> 
<p></p> 
<h4>（7）IOC操作Bean管理（生命周期）</h4> 
<p></p> 
<p>1.生命周期</p> 
<p>从对象到对象销毁的过程</p> 
<p>2.bean生命周期</p> 
<p>（1）通过构造器创建bean实例（无参数构造）</p> 
<p>（2）为bean的属性设置值和对其他bean的引用（调用set方法）</p> 
<p>（3）调用bean的初始化的方法（需要进行配置）</p> 
<p>（4）bean可以直接使用了（对象获取到了）</p> 
<p>（5）当容器关闭时候，调用bean的销毁的方法（需要进行配置销毁）</p> 
<p>3.演示bean的生命周期</p> 
<p></p> 
<pre>Order.java</pre> 
<pre>package com.spring.bean;
​
/**
 * @author yanchaochao
 * @date 2022/3/18 19:48
 */
public class Order {
    private String oname;
​
​
    //无参数构造
    public Order(){
        System.out.println("第一步，执行无参构造实例");
    }
​
    public void setOname(String oname) {
        this.oname = oname;
        System.out.println("第二步，调用set方法调用初始化值");
    }
​
    //创建执行初始化的方法
    public void initMethod(){
        System.out.println("第三部，执行初始化方法");
    }
​
    //执行销毁的方法
    public void destroyMethod(){
        System.out.println("第五步执行销毁的方法");
    }
}</pre> 
<pre>bean4.xml</pre> 
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/util  http://www.springframework.org/schema/util/spring-util.xsd"&gt;
​
​
    &lt;bean id="orders" class="com.spring.bean.Order" init-method="initMethod" destroy-method="destroyMethod"&gt;
        &lt;property name="oname" value="手机"&gt;&lt;/property&gt;
​
    &lt;/bean&gt;
​
&lt;/beans&gt;</pre> 
<p>测试：</p> 
<pre>Testbean.java</pre> 
<p></p> 
<pre>package com.spring.testdemo;
​
import com.spring.bean.Order;
import com.spring.collectiontype.Book;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
​
/**
 * @author yanchaochao
 * @date 2022/3/18 19:54
 */
public class Testbean {
    @Test
    public void testBook(){
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("bean4.xml");
        Order order = context.getBean("orders", Order.class);
        System.out.println("第四步，得到对象");
        System.out.println(order);
​
​
        //手动销毁
        context.close();
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b4/6f/GONRwitp_o.png"></p> 
<p>4.bean的后置处理</p> 
<p>（1）通过构造器创建bean实例（无参数构造）</p> 
<p>（2）为bean的属性设置值和对其他bean的引用（调用set方法）</p> 
<p>（3）把bean实例传递bean后置处理器的方法</p> 
<pre>postProcessBeforeInitialization</pre> 
<p>（4）调用bean的初始化的方法（需要进行配置）</p> 
<p>（5）把bean实例传递bean后置处理器的方法</p> 
<pre>postProcessAfterInitialization</pre> 
<p>（6）bean可以直接使用了（对象获取到了）</p> 
<p>（7）当容器关闭时候，调用bean的销毁的方法（需要进行配置销毁）</p> 
<p></p> 
<p></p> 
<p>5.演示添加后置处理器效果</p> 
<p>（1）创建类，实现接口BeanPostProcessor，创建后置处理器</p> 
<pre>MyBeanPost.java</pre> 
<pre>package com.spring.bean;
​
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.lang.Nullable;
​
/**
 * @author yanchaochao
 * @date 2022/3/18 20:17
 */
public class MyBeanPost implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("在初始化之前执行的方法");
        return bean;
    }
​
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("在初始化之后执行的方法");
        return bean;
    }
}</pre> 
<pre>Order.java</pre> 
<pre>package com.spring.bean;
​
/**
 * @author yanchaochao
 * @date 2022/3/18 19:48
 */
public class Order {
    private String oname;
​
​
    //无参数构造
    public Order(){
        System.out.println("第一步，执行无参构造实例");
    }
​
    public void setOname(String oname) {
        this.oname = oname;
        System.out.println("第二步，调用set方法调用初始化值");
    }
​
    //创建执行初始化的方法
    public void initMethod(){
        System.out.println("第三部，执行初始化方法");
    }
​
    //执行销毁的方法
    public void destroyMethod(){
        System.out.println("第五步执行销毁的方法");
    }
}</pre> 
<pre>bean4.xml</pre> 
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/util  http://www.springframework.org/schema/util/spring-util.xsd"&gt;
​
​
    &lt;bean id="orders" class="com.spring.bean.Order" init-method="initMethod" destroy-method="destroyMethod"&gt;
        &lt;property name="oname" value="手机"&gt;&lt;/property&gt;
​
    &lt;/bean&gt;
    &lt;!--配置后置处理器--&gt;
    &lt;bean id="myBeanPost" class="com.spring.bean.MyBeanPost"&gt;&lt;/bean&gt;
&lt;/beans&gt;</pre> 
<pre>Testbean.java</pre> 
<pre>package com.spring.testdemo;
​
import com.spring.bean.Order;
import com.spring.collectiontype.Book;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
/**
 * @author yanchaochao
 * @date 2022/3/18 19:54
 */
public class Testbean {
    @Test
    public void testBook(){
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("bean4.xml");
        Order order = context.getBean("orders", Order.class);
        System.out.println("第四步，得到对象");
        System.out.println(order);
​
        //手动销毁
        context.close();
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/08/87/nMfwIHOz_o.png"></p> 
<p></p> 
<p></p> 
<h4>（8）IOC操作Bean管理（xml自动装配）</h4> 
<p></p> 
<p>1.什么是自动装配</p> 
<p>（1）根据指定装配规则（属性名称或者属性类型），spring自动将匹配的属性值进行注入</p> 
<p>2.演示自动装配</p> 
<p>（1）根据属性名称自动注入</p> 
<pre> &lt;!--实现自动装配
        bean标签属性autowire，配置自动装配
        autowire属性常用两个值：
            byName根据属性名称注入，注入值bean的id值和类属性名称一样
            byType根据属性类型注入
​
    --&gt;
    &lt;bean id="emp" class="com.spring.autowire.Emp" autowire="byName"&gt;</pre> 
<p>根据属性名称注入，注入值bean的id值和类属性名称一样</p> 
<p></p> 
<p>（2）根据属性类型自动注入</p> 
<pre>   &lt;!--实现自动装配
        bean标签属性autowire，配置自动装配
        autowire属性常用两个值：
            byName根据属性名称注入，注入值bean的id值和类属性名称一样
            byType根据属性类型注入
​
    --&gt;
    &lt;bean id="emp" class="com.spring.autowire.Emp" autowire="byType"&gt;</pre> 
<p></p> 
<p></p> 
<p></p> 
<hr> 
<p></p> 
<h4>（9）IOC操作Bean管理（外部属性文件）</h4> 
<p></p> 
<p>1.直接配置数据库信息</p> 
<p>（1）配置德鲁伊连接池</p> 
<pre> &lt;!--直接配置连接池--&gt;
    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
          destroy-method="close"&gt;
        &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt;
        &lt;property name="url" value="jdbc:mysql://localhost:3306/userDb" /&gt;
        &lt;property name="username" value="root" /&gt;
        &lt;property name="password" value="root" /&gt;
    &lt;/bean&gt;</pre> 
<p>2.引入外部属性文件配置数据库连接池</p> 
<p></p> 
<p>（1）创建外部属性文件，properties格式文件，写数据库信息</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bb/4f/kTfhqHxJ_o.png"></p> 
<p>（2）把外部properties属性文件引入到配置文件</p> 
<p>*引入context名称空间</p> 
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:util="http://www.springframework.org/schema/util"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/util  http://www.springframework.org/schema/util/spring-util.xsd
                           http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd"&gt;
​</pre> 
<p></p> 
<p>（3）在spring配置文件中使用标签引入外部属性文件</p> 
<pre>&lt;!--引入外部属性文件--&gt;
&lt;context:property-placeholder location="classpath*:jdbc.properties"&gt;&lt;/context:property-placeholder&gt;
​
&lt;!--配置连接池--&gt;
    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
          destroy-method="close"&gt;
        &lt;property name="driverClassName" value="${prop.driverClass}" /&gt;
        &lt;property name="url" value="${prop.url}" /&gt;
        &lt;property name="username" value="${prop.username}" /&gt;
        &lt;property name="password" value="${prop.password}" /&gt;
    &lt;/bean&gt;</pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h3>4.IOC操作Bean管理（基于注解）</h3> 
<p></p> 
<h4>1.什么是注解</h4> 
<p>（1）注解是代码特殊标记，格式：@注解名称<strong>(</strong>属性名称=属性值，属性名称=属性值<strong>)</strong></p> 
<p>（2）使用注解，注解作用在类上面，方法上面，属性上面</p> 
<p>（3）使用注解目的：简化xml配置</p> 
<p></p> 
<h4>2.Spring针对Bean管理中创建对象提供注解</h4> 
<p>（1）@Component</p> 
<p>（2）@Service</p> 
<p>（3）@Controller</p> 
<p>（4）@Repository</p> 
<p>*上面四个注解功能是一样的，都可以用来创建bean实例</p> 
<p></p> 
<h4>3.基于注解方式实现对象创建</h4> 
<p>（1）引入依赖</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c9/04/RpS6jXr2_o.png"></p> 
<p>（2）开启组件扫描</p> 
<p>（3）创建类，在类上面添加创建对象注解</p> 
<pre>package com.atguigu.spring5.testdemo;
import com.atguigu.spring5.service.UserService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
​
/**
 * @author yanchaochao
 * @date 2022/3/22 14:31
 */
public class TestSpring5Demo1 {
​
​
    @Test
    public void testService(){
        ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
        UserService userService = context.getBean("userService", UserService.class);
        System.out.println(userService);
        userService.add();
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c0/55/wc7IcIBm_o.png"></p> 
<p></p> 
<p></p> 
<p>实例一：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/29/2e/aRQ4ryVT_o.png"></p> 
<p>实例二：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3b/7d/rmyC6S6P_o.png"></p> 
<p></p> 
<h4>4.基于注解方式实现属性注入</h4> 
<p><strong>（1）@AutoWired：根据属性类型自动装配</strong></p> 
<p>第一步：把service和dao对象创建，在service和dao类添加创建对象注解</p> 
<p>第二步：在service注入dao对象，在service类添加dao类型属性，在属性上面使用注解</p> 
<pre>@Service
public class UserService {
    //定义dao类型的属性
    //不需要添加set方法
    //添加注入属性注解
    @Autowired
    private UserDao userDao;
    public void add(){
        System.out.println("service add.....");
        userDao.add();
    }
}</pre> 
<p></p> 
<pre>UserDao.java</pre> 
<pre>package com.atguigu.spring5.dao;
public interface UserDao {
    public void add();
}</pre> 
<pre>UserDaoImpl</pre> 
<pre>import org.springframework.stereotype.Repository;
@Repository
public class UserDaoImpl implements UserDao{
    @Override
    public void add(){
        System.out.println("dao add...");
    }
}</pre> 
<pre>UserService.java</pre> 
<pre>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;
@Service
public class UserService {
    //定义dao类型的属性
    //不需要添加set方法
    //添加注入属性注解
    @Autowired
    private UserDao userDao;
​
    public void add(){
        System.out.println("service add.....");
        userDao.add();
    }
}</pre> 
<p>测试：</p> 
<pre>TestSpring5Demo1.java</pre> 
<pre>package com.atguigu.spring5.testdemo;
​
import com.atguigu.spring5.service.UserService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class TestSpring5Demo1 {
    @Test
    public void testService(){
        ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
        UserService userService = context.getBean("userService", UserService.class);
        System.out.println(userService);
        userService.add();
    }
}</pre> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cb/00/xbsb3N3s_o.png"></p> 
<p></p> 
<p></p> 
<p><strong>（2）@Qualifier：根据属性名称进行注入</strong></p> 
<p>这个@Qualifier注解的使用，和上面@Autowired一起使用</p> 
<p><strong>（3）@Resource：可以根据类型注入，可以根据名称注入</strong></p> 
<p><strong>（4）@Value：注入普通类型属性</strong></p> 
<p></p> 
<h4>5.完全注解开发</h4> 
<p>（1）创建配置类，替代xml的配置文件</p> 
<pre>package com.atguigu.spring5.config;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
@Configuration  //作为配置类，替代xml配置文件
@ComponentScan(basePackages = {"com.atguigu"})
public class SpringConfig {
}</pre> 
<p>（2）编写测试类</p> 
<pre> @Test
    public void testService2(){
        //加载配置类
        ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
        UserService userService = context.getBean("userService", UserService.class);
        System.out.println(userService);
        userService.add();
    }</pre> 
<p></p> 
<p></p> 
<p></p> 
<hr> 
<p></p> 
<p></p> 
<hr> 
<p></p> 
<p></p> 
<p></p> 
<h2>三，AOP</h2> 
<h3>1.简介</h3> 
<p><strong>AOP（面向切面编程）</strong></p> 
<p>AOP是<a href="https://baike.baidu.com/item/OOP" rel="nofollow" title="OOP">OOP</a>的延续，是软件开发中的一个热点，也是<a href="https://baike.baidu.com/item/Spring" rel="nofollow" title="Spring">Spring</a>框架中的一个重要内容，是<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/4035031" rel="nofollow" title="函数式编程">函数式编程</a>的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<a href="https://baike.baidu.com/item/%E8%80%A6%E5%90%88%E5%BA%A6/2603938" rel="nofollow" title="耦合度">耦合度</a>降低，提高程序的可重用性，同时提高了开发的效率。</p> 
<p><strong>主要功能</strong></p> 
<p>日志记录，性能统计，安全控制，事务处理，<a href="https://baike.baidu.com/item/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" rel="nofollow" title="异常处理">异常处理</a>等等。</p> 
<p><strong>主要意图</strong></p> 
<p>将日志记录，性能统计，安全控制，事务处理，<a href="https://baike.baidu.com/item/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" rel="nofollow" title="异常处理">异常处理</a>等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。</p> 
<p>eg：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1e/b9/VBY9mJ0u_o.png"></p> 
<p></p> 
<h3>2.底层原理</h3> 
<p></p> 
<p><strong>一，AOP底层使用动态代理</strong></p> 
<p>（1）有两种情况</p> 
<p><strong>第一种</strong>：有接口的情况，使用JDK代理</p> 
<p>创建接口实现代理对象，增强类的方法</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/43/iFkSDyAw_o.png"></p> 
<p><strong>第二种</strong>：没有接口的情况，使用CGLIB代理</p> 
<p>创建子类的代理对象，增强类的方法</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/47/f2/iScBX61o_o.png"></p> 
<p></p> 
<h3>3.AOP（JDK动态代理）</h3> 
<p><strong>一，使用JDK动态代理，使用Proxy类里面的方法创建代理对象</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/90/50/Qf9JYQhb_o.png"></p> 
<p><strong>调用newProxyInstance方法</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7c/ba/QbQfc902_o.png"></p> 
<p></p> 
<p></p> 
<p>方法里有三个参数：</p> 
<p>one：类加载器</p> 
<p>two：增强方法所在的类，这个类实现的接口，支持多个接口</p> 
<p>three：实现这个接口InvocationHandler，创建代理对象，写增强的方法</p> 
<p></p> 
<p><strong>二，JDK动态代理代码</strong></p> 
<p></p> 
<p>（1）创建接口，定义方法</p> 
<pre>package com.study;
​
public interface UserDao {
​
    public int add(int a,int b);
​
    public String update(String id);
​
}</pre> 
<p>（2）创建接口实现类，实现方法</p> 
<pre>package com.study;
​
public class UserDaoImpl implements UserDao{
​
    @Override
    public int add(int a, int b) {
        System.out.println("add方法执行了......");
        return a+b;
    }
​
    @Override
    public String update(String id) {
        System.out.println("update方法执行了......");
        return id;
    }
}
​</pre> 
<p>（3）使用Proxy类创建接口代理对象</p> 
<pre>package com.study;
​
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Arrays;
​
/**
 * @author yanchaochao
 * @date 2022/3/22 20:39
 */
public class JDKProxy {
    public static void main(String[] args) {
        //创建接口实现类代理对象
        Class [] interfaces = {UserDao.class};
​
        UserDaoImpl userDao = new UserDaoImpl();
        UserDao dao =(UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao));
​
        int result = dao.add(1,2);
        System.out.println("result："+result);
    }
}
//创建代理对象代码
class UserDaoProxy implements InvocationHandler{
​
    //1.把创建的是谁的代理对象，把谁传递过来
    //有参数构造传递
    private Object object;
    public UserDaoProxy(Object object){
        this.object = object;
    }
​
​
    //增强的逻辑
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
​
        //方法之前
        System.out.println("方法之前执行......"+method.getName()+"：传递参数..."+ Arrays.toString(args));
​
        //被增强的方法
        Object res = method.invoke(object, args);
​
        //方法之后
        System.out.println("方法执行之后......"+object);
        return res;
    }
}</pre> 
<p>结果：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/71/8e/iSmiWvBq_o.png"></p> 
<p></p> 
<p></p> 
<h3>4.AOP（术语）</h3> 
<p>一，连接点</p> 
<p>二，切入点</p> 
<p>三，通知（增强）</p> 
<p>四，切面</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/09/9c/h81PaU7H_o.png"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h3>5.AOP操作（准备）</h3> 
<p></p> 
<p><strong>1.Spring框架一般基于AspectJ实现AOP操作</strong></p> 
<p>（1）什么是AspectJ</p> 
<p>*AspectJ不是Spring组成部分，独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作</p> 
<p></p> 
<p><strong>2.基于AspectJ实现AOP操作</strong></p> 
<p>（1）基于xml配置文件实现</p> 
<p>（2）jiyu注解方式实现</p> 
<p><strong>3.在项目工程里面引入AOP相关依赖</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ef/11/DClRfVAd_o.png"></p> 
<p><strong>4.切入点表达式</strong></p> 
<p>（1）切入点表达式作用：知道对哪个类型里面的哪个方法进行增强</p> 
<p></p> 
<hr> 
<p></p> 
<p>（2）语法结构：</p> 
<p>execution([权限修饰符] [返回类型] [类全路径] [方法名称] [参数列表])</p> 
<p></p> 
<p>举例1：对com.atguigu.dao.BookDao类里面的add进行增强</p> 
<p>execution(*com.atguigu.dao.BookDao.add(...方法中的参数))</p> 
<p>举例2：对com.atguigu.dao.BookDao类里面的所有方法进行增强</p> 
<p>execution(*com.atguigu.dao.BookDao. * (...方法中的参数))</p> 
<p>举例3：对com.atguigu.dao包里面的所有类，类里面的所有方法进行增强</p> 
<p>execution(*com.atguigu.dao. *. * (...方法中的参数))</p> 
<p></p> 
<p></p> 
<hr> 
<p></p> 
<h3>6.AOP操作（AspectJ注解）</h3> 
<p></p> 
<p></p> 
<p>1.创建类，在类里面定义方法</p> 
<p></p> 
<p>2.创建增强类（编写增强逻辑）</p> 
<p>（1）在增强类里面，创建方法，让不同方法代表不同通知类型</p> 
<pre>package com.study.aopanno;
import org.springframework.stereotype.Component;
//被增强的类
@Component
public class User {
    public void add (){
        System.out.println("add...");
    }
}</pre> 
<pre>package com.study.aopanno;
​
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;
​
//增强的类
@Component
@Aspect  //生成代理对象
public class UserProxy {
​
    //前置通知
    public void before(){
        System.out.println("before......");
    }
}</pre> 
<p></p> 
<p>3.进行通知的配置</p> 
<p>（1）在spring配置文件中，开启注解扫描</p> 
<pre>bean1.xml</pre> 
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
​
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
​
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;
    &lt;!--开启注解扫描--&gt;
    &lt;context:component-scan base-package="com.study.aopanno"&gt;&lt;/context:component-scan&gt;
    
&lt;/beans&gt;</pre> 
<p>（2）使用注解创建User和UserProxy对象</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e4/f5/MuxEIUUe_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bc/65/wcgPZMG1_o.png"></p> 
<p>（3）在增强类上面添加注解@Aspect</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6e/fe/eicbJRTn_o.png"></p> 
<p>（4）在spring配置文件中开启代理生成对象</p> 
<pre>&lt;!--开启Aspect生成的代理对象--&gt;
&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
​</pre> 
<p>4.配置不用类型的通知</p> 
<p>（1）在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p> 
<pre>package com.study.aopanno;
​
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;
​
/**
 * @author yanchaochao
 * @date 2022/3/23 17:34
 */
​
//增强的类
@Component
@Aspect  //生成代理对象
​
public class UserProxy {
​
​
​
    //前置通知
    //Before注解表示为前置通知
    @Before(value = "execution(* com.study.aopanno.User.add(..))")
​
    public void before(){
        System.out.println("before......");
    }
    //最终通知
    @After(value = "execution(* com.study.aopanno.User.add(..))")
    public void after(){
        System.out.println("after......");
    }
​
    //后置通知（返回通知）
    @AfterReturning(value = "execution(* com.study.aopanno.User.add(..))")
    public void afterReturning(){
        System.out.println("afterReturning......");
    }
    //异常通知
    @AfterThrowing(value = "execution(* com.study.aopanno.User.add(..))")
    public void afterThrowing(){
        System.out.println("afterThrowing......");
    }
​
    //环绕通知
    @Around(value = "execution(* com.study.aopanno.User.add(..))")
    public void around(ProceedingJoinPoint proceedingJoinPoint)throws Throwable{
        System.out.println("环绕之前......");
​
​
        //被增强的方法
        proceedingJoinPoint.proceed();
​
        System.out.println("环绕之后......");
    }
}
​</pre> 
<p>TestAop.java</p> 
<pre>package com.study.test;
​
import com.study.aopanno.User;
import jdk.jfr.StackTrace;
import org.springframework.context.ApplicationContext;
import org.junit.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;
​
public class TestAop {
​
​
​
    @Test
    public void testAopAnno(){
        ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
        User user = context.getBean("user", User.class);
        user.add();
​
    }
}
​</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2b/2c/COtaeeMM_o.png"></p> 
<p></p> 
<p></p> 
<p>5.公共切入点抽取</p> 
<p></p> 
<pre>package com.study.aopanno;
​
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;
​
//增强的类
@Component
@Aspect  //生成代理对象
​
public class UserProxy {
​
​
​
​
    //相同切入点抽取
    @Pointcut(value = "execution(* com.study.aopanno.User.add(..))")
    public void piontdemo(){
​
    }
​
​
    //前置通知
    //Before注解表示为前置通知
    @Before(value = "piontdemo()")
​
    public void before(){
        System.out.println("before......");
    }
    //最终通知
    @After(value = "execution(* com.study.aopanno.User.add(..))")
    public void after(){
        System.out.println("after......");
    }
​
    //后置通知（返回通知）
    @AfterReturning(value = "execution(* com.study.aopanno.User.add(..))")
    public void afterReturning(){
        System.out.println("afterReturning......");
    }
    //异常通知
    @AfterThrowing(value = "execution(* com.study.aopanno.User.add(..))")
    public void afterThrowing(){
        System.out.println("afterThrowing......");
    }
​
    //环绕通知
    @Around(value = "execution(* com.study.aopanno.User.add(..))")
    public void around(ProceedingJoinPoint proceedingJoinPoint)throws Throwable{
        System.out.println("环绕之前......");
        //被增强的方法
        proceedingJoinPoint.proceed();
​
        System.out.println("环绕之后......");
    }
}
​</pre> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/03/c5/exe6MFNw_o.png"></p> 
<p></p> 
<p></p> 
<p></p> 
<p>6.有多个增强类多同一个方法进行增强,设置增强类优先级</p> 
<p>（1）在增强类上面添加注解@Order（数字类类值），数字类值越小优先级越高</p> 
<pre>PersonPerxy.java</pre> 
<pre>package com.study.aopanno;
​
​
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
@Component
@Aspect
@Order(1)
public class PersonPerxy {
     //后置通知（返回通知）
        @Before(value = "execution(* com.study.aopanno.User.add(..))")
        public void afterReturning(){
            System.out.println("Person Before......");
        }
}</pre> 
<pre>User.java</pre> 
<pre>package com.study.aopanno;
import org.springframework.stereotype.Component;
​
//被增强的类
@Component
public class User {
    public void add (){
        System.out.println("add...");
    }
}</pre> 
<pre>UserProxy.java</pre> 
<pre>package com.study.aopanno;
​
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
​
​
//增强的类
@Component
@Aspect  //生成代理对象
@Order(3)
public class UserProxy {
​
​
​
​
    //相同切入点抽取
    @Pointcut(value = "execution(* com.study.aopanno.User.add(..))")
    public void piontdemo(){
​
    }
​
​
    //前置通知
    //Before注解表示为前置通知
    @Before(value = "piontdemo()")
​
    public void before(){
        System.out.println("before......");
    }
    //最终通知
    @After(value = "execution(* com.study.aopanno.User.add(..))")
    public void after(){
        System.out.println("after......");
    }
​
    //后置通知（返回通知）
    @AfterReturning(value = "execution(* com.study.aopanno.User.add(..))")
    public void afterReturning(){
        System.out.println("afterReturning......");
    }
    //异常通知
    @AfterThrowing(value = "execution(* com.study.aopanno.User.add(..))")
    public void afterThrowing(){
        System.out.println("afterThrowing......");
    }
​
    //环绕通知
    @Around(value = "execution(* com.study.aopanno.User.add(..))")
    public void around(ProceedingJoinPoint proceedingJoinPoint)throws Throwable{
        System.out.println("环绕之前......");
​
​
        //被增强的方法
        proceedingJoinPoint.proceed();
​
        System.out.println("环绕之后......");
    }
}</pre> 
<p></p> 
<p>测试：</p> 
<pre>package com.study.test;
​
import com.study.aopanno.User;
import jdk.jfr.StackTrace;
import org.springframework.context.ApplicationContext;
import org.junit.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class TestAop {
    @Test
    public void testAopAnno(){
        ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");
        User user = context.getBean("user", User.class);
        user.add();
​
    }
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6e/34/e40aWNHO_o.png"></p> 
<p></p> 
<h3>7.AOP操作（AspectJ配置文件）</h3> 
<p></p> 
<p></p> 
<p>（1）创建两个类，增强类和被增强类，创建方法</p> 
<pre>package com.study.aopxml;
​
​
public class Book {
    public void buy(){
        System.out.println("buy.......");
    }
}</pre> 
<pre>package com.study.aopxml;
​
public class BookProxy {
    public void Before(){
        System.out.println("before.......");
    }
}</pre> 
<p></p> 
<p>（2）在spring配置文件中创建两个类对象</p> 
<p>（3）在spring配置文件中配置切入点</p> 
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
​
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
​
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;
&lt;!-- 创建对象 --&gt;
    &lt;bean id="book" class="com.study.aopxml.Book"&gt;&lt;/bean&gt;
    &lt;bean id="bookProxy" class="com.study.aopxml.BookProxy"&gt;&lt;/bean&gt;
​
​
​
&lt;!--配置AOP增强--&gt;
    &lt;aop:config&gt;
        &lt;!--切入点--&gt;
        &lt;aop:pointcut id="p" expression="execution(* com.study.aopxml.Book.buy(..))"/&gt;
        &lt;!--配置切面--&gt;
        &lt;aop:aspect ref="bookProxy"&gt;
            &lt;!--增强作用在具体的方法上--&gt;
            &lt;aop:before method="Before" pointcut-ref="p"&gt;&lt;/aop:before&gt;
        &lt;/aop:aspect&gt;
​
​
    &lt;/aop:config&gt;
&lt;/beans&gt;</pre> 
<p></p> 
<p></p> 
<p>测试：</p> 
<p></p> 
<pre>@Test
    public void testBook(){
        ApplicationContext context = new ClassPathXmlApplicationContext("bean2.xml");
        Book book = context.getBean("book", Book.class);
        book.buy();
​
    }</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/53/f0/tQJLQlYJ_o.png"></p> 
<hr> 
<p>完全使用注解开发</p> 
<p>不需要创建xml文件</p> 
<pre>package com.study.config;
​
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;
​
​
@Configuration
​
@ComponentScan(basePackages = {"com.study"})
​
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class ConfigAop {
    
}
​</pre> 
<p></p> 
<hr> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a61285064eef18ca8846d019f3d6045e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">软考种类有哪些？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ad9f04d1907deab4dd95236b0703284c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springMVC 有这一篇就够了 （保姆级）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>