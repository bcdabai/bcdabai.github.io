<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>YOLOv5 模型结构及代码详细讲解（一） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="YOLOv5 模型结构及代码详细讲解（一）" />
<meta property="og:description" content="王旭*，沈啸彬 *, 张钊*
(淮北师范大学计算机科学与技术学院，淮北师范大学经济与管理学院，安徽 淮北)
*These authors contributed to the work equllly and should be regarded as co-first authors.
🌞欢迎来到深度学习的世界 🌈博客主页：卿云阁
💌欢迎关注🎉点赞👍收藏⭐️留言📝
🌟本文由卿云阁原创！
🌠本阶段属于练气阶段，希望各位仙友顺利完成突破
📆首发时间：🌹2022年12月6日🌹
✉️希望可以和大家一起完成进阶之路！
🙏作者水平很有限，如果发现错误，请留言轰炸哦！万分感谢！
目录
🍈 配置文件
backbone配置文件
​编辑
🍊构成的元素
Conv ---CBA(convolution, batch normalization, activation)
关于SiLU--sigmoid linear unit
SPP(Spatial Pyramid Pooling)/SPPF(Spatial Pyramid Pooling Fast)结构
C3 -- cross stage partial network with 3 convolutions
🍋项目结构
🍈 配置文件 在yolov5中有好几种得配置文件，这几种配置文件只有下面的两个参数不同，其它部分都相同这两个参数是为了控制模型大小的。下面以yolov5l.yaml为例
depth_multiple: 1.0 # model depth multiple width_multiple: 1.0 # layer channel multiple 第一部分：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/70b1a7e259ed6e4d27167ad93df44b51/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-06T18:45:22+08:00" />
<meta property="article:modified_time" content="2022-12-06T18:45:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">YOLOv5 模型结构及代码详细讲解（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p style="text-align:center;"><strong>王旭*，沈啸彬 *, 张钊*</strong></p> 
 <p style="text-align:center;"><strong>(淮北师范大学计算机科学与技术学院，淮北师范大学经济与管理学院，安徽 淮北)</strong></p> 
 <p style="text-align:center;"><strong>*These authors contributed to the work equllly and should be regarded as co-first authors.</strong><br>  </p> 
</blockquote> 
<blockquote> 
 <p>🌞欢迎来到深度学习的世界 <br> 🌈博客主页：<a class="link-info" href="https://blog.csdn.net/zzqingyun?spm=1011.2415.3001.5343" title="卿云阁">卿云阁</a></p> 
 <p>💌欢迎关注🎉点赞👍收藏⭐️留言📝</p> 
 <p>🌟本文由卿云阁原创！</p> 
 <p>🌠本阶段属于练气阶段，希望各位仙友顺利完成突破</p> 
 <p>📆首发时间：🌹2022年12月6日🌹</p> 
 <p>✉️希望可以和大家一起完成进阶之路！</p> 
 <p>🙏作者水平很有限，如果发现错误，请留言轰炸哦！万分感谢！</p> 
 <hr> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%F0%9F%8D%88%20%E4%B8%80%E3%80%81Jupyter%20Notebook%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%88%20%E4%B8%80%E3%80%81Jupyter%20Notebook%E7%9A%84%E4%BB%8B%E7%BB%8D" rel="nofollow">🍈 配置文件</a></p> 
 <p id="h_563598234_5-toc" style="margin-left:80px;"><a href="#h_563598234_5" rel="nofollow">backbone配置文件</a></p> 
 <p id="h_563598234_6-toc" style="margin-left:80px;"><a href="#h_563598234_6" rel="nofollow">​编辑</a></p> 
 <p id="%F0%9F%8D%8A%E4%B8%89%EF%BC%8Cjupyter%20notebook%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BD%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8A%E4%B8%89%EF%BC%8Cjupyter%20notebook%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BD%8D%E7%BD%AE" rel="nofollow">🍊构成的元素</a></p> 
 <p id="h_563598234_1-toc" style="margin-left:80px;"><a href="#h_563598234_1" rel="nofollow">Conv ---CBA(convolution, batch normalization, activation)</a></p> 
 <p id="h_563598234_2-toc" style="margin-left:80px;"><a href="#h_563598234_2" rel="nofollow">关于SiLU--sigmoid linear unit</a></p> 
 <p id="h_563598234_3-toc" style="margin-left:80px;"><a href="#h_563598234_3" rel="nofollow">SPP(Spatial Pyramid Pooling)/SPPF(Spatial Pyramid Pooling Fast)结构</a></p> 
 <p id="%C2%A0C3%20--%20cross%20stage%20partial%20network%20with%203%20convolutions-toc" style="margin-left:80px;"><a href="#%C2%A0C3%20--%20cross%20stage%20partial%20network%20with%203%20convolutions" rel="nofollow"> C3 -- cross stage partial network with 3 convolutions</a></p> 
 <p id="%F0%9F%8D%8B%E5%9B%9B%E3%80%81Jupyter%20Notebook%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8B%E5%9B%9B%E3%80%81Jupyter%20Notebook%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">🍋项目结构</a></p> 
 <p></p> 
 <p></p> 
</blockquote> 
<p><img alt="" height="535" src="https://images2.imgbox.com/34/05/qNN6ff3C_o.png" width="959"></p> 
<blockquote> 
 <h3 id="%F0%9F%8D%88%20%E4%B8%80%E3%80%81Jupyter%20Notebook%E7%9A%84%E4%BB%8B%E7%BB%8D">🍈 配置文件</h3> 
 <p>     在yolov5中有好几种得配置文件，这几种配置文件只有下面的两个参数不同，其它部分都相同这两个参数是为了控制模型大小的。下面以yolov5l.yaml为例</p> 
 <pre>depth_multiple: 1.0  # model depth multiple
width_multiple: 1.0  # layer channel multiple</pre> 
 <p></p> 
 <p><img alt="" height="312" src="https://images2.imgbox.com/f1/4d/o9bQ5gAg_o.png" width="392"></p> 
 <p><strong>第一部分：</strong></p> 
 <p></p> 
 <pre><code># YOLOv5 🚀 by Ultralytics, GPL-3.0 license

# Parameters
nc: 80  # number of classes
depth_multiple: 1.0  # model depth multiple
width_multiple: 1.0  # layer channel multiple
anchors:
  - [10,13, 16,30, 33,23]  # P3/8
  - [30,61, 62,45, 59,119]  # P4/16
  - [116,90, 156,198, 373,326]  # P5/32
</code></pre> 
 <pre>nc: 80  # number of classes</pre> 
 <p>这一部分代表模型的种类，对于coco数据集来说，有80个类别。</p> 
 <pre>depth_multiple: 1.0  # model depth multiple</pre> 
 <p>是为了控制层的重复的次数。它会和number相乘后取整，代表该层的重复的数量，</p> 
 <p><img alt="" height="467" src="https://images2.imgbox.com/66/3e/HMxePyKj_o.png" width="673"></p> 
 <p></p> 
 <p></p> 
 <pre>width_multiple: 1.0  # layer channel multiple</pre> 
 <p>是为了控制输出特征图的通道数，它会和出特征图的通道数相乘，代表该层的输出通道数。</p> 
 <p><img alt="" height="352" src="https://images2.imgbox.com/5f/3a/GfjK0RvI_o.png" width="341"></p> 
 <p></p> 
 <h4 id="h_563598234_5"><strong>backbone配置文件</strong></h4> 
 <p>backone的配置在文件models/yolov5*.yaml中，下面以yolov5l.yaml为例，</p> 
 <pre><code>backbone:
  # [from, number, module, args]
  [[-1, 1, Conv, [64, 6, 2, 2]],  # 0-P1/2
   [-1, 1, Conv, [128, 3, 2]],  # 1-P2/4
   [-1, 3, C3, [128]],
   [-1, 1, Conv, [256, 3, 2]],  # 3-P3/8
   [-1, 6, C3, [256]],
   [-1, 1, Conv, [512, 3, 2]],  # 5-P4/16
   [-1, 9, C3, [512]],
   [-1, 1, Conv, [1024, 3, 2]],  # 7-P5/32
   [-1, 3, C3, [1024]],
   [-1, 1, SPPF, [1024, 5]],  # 9
  ]</code></pre> 
 <p>输入图片的大小是640*640*3</p> 
 <p><strong>第0层：conv层</strong></p> 
 <ul><li>每一行代表yolo网络的每一层</li><li>第一列表示该层输入特征图的来源，-1表示指的是上一层的输出当成自己的输入。</li><li>第二列，是为了控制该层重复的次数。</li><li>第三列，指的是该层的名字。</li><li>下面的一个列表是该层输入的参数，比如第一行的64代表该层输出特征图的通道数。（最后的输出还要进行相关的处理）。6代表该层用的是一个6*6大小的卷积核。第一个2表示描边2，下一个2指的是步长是2。</li><li>后面的注释我们可以看到，通过该层之后特征图的大小变成<strong>原图</strong>的1/2.</li></ul> 
 <p><strong>第1层：conv层</strong></p> 
 <ul><li>通过该层之后特征图的大小变成<strong>原图</strong>的1/4.</li></ul> 
 <p></p> 
 <p><strong>第2层：C3层</strong></p> 
 <ul><li>通过该层之后特征图的大小不变.</li></ul> 
 <p></p> 
 <p><strong>第3层：conv层</strong></p> 
 <ul><li>通过该层之后特征图的大小变成<strong>原图</strong>的1/8.</li></ul> 
 <p></p> 
 <h4 id="h_563598234_6"><img alt="" height="912" src="https://images2.imgbox.com/f7/b6/dIdBGCrR_o.png" width="1142"></h4> 
 <p><strong>第4层：C3层</strong></p> 
 <ul><li>通过该层之后特征图的大小不变.</li></ul> 
 <p></p> 
 <p><strong>第5层：conv层</strong></p> 
 <ul><li>通过该层之后特征图的大小变成<strong>原图</strong>的1/16.(40*40*512)</li></ul> 
 <p><strong>第6层：C3层(个数是9）</strong></p> 
 <ul><li>通过该层之后特征图的大小不变.</li></ul> 
 <p></p> 
 <p><strong>第7层：conv层</strong></p> 
 <ul><li>通过该层之后特征图的大小变成<strong>原图</strong>的1/16.(20*20*1024)</li></ul> 
 <p><img alt="" height="884" src="https://images2.imgbox.com/8b/13/TNyFPDWG_o.png" width="937"></p> 
 <p></p> 
 <p><strong>第8层：c3层(个数是3）</strong></p> 
 <ul><li>通过该层之后特征图的大小变成<strong>原图</strong>的1/16.(20*20*1024)</li></ul> 
 <p></p> 
 <p><strong>第9层：SPPF层</strong></p> 
 <ul><li>主要是对不同尺度特征图的融合<strong>。</strong></li><li>特征图的大小的大小不变</li></ul> 
 <p><img alt="" height="561" src="https://images2.imgbox.com/d9/51/9iJg94vN_o.png" width="925"></p> 
 <p> 到第九层为止，整个<strong>backbone就结束了，</strong>这个部分会形成三个接口，</p> 
 <p><strong>第4层的输出：</strong></p> 
 <p style="text-align:center;"><strong>80*80*256</strong></p> 
 <p><strong>第6层的输出：</strong></p> 
 <p style="text-align:center;"><strong>40*40*512</strong></p> 
 <p><strong>第9层的输出：</strong></p> 
 <p style="text-align:center;"><strong>20*20*1024</strong></p> 
 <p style="text-align:center;"></p> 
 <p><strong>head网络结构</strong></p> 
 <p>层为止head包括两个部分，一个部分是Neck,一个部分是 Detect部分。</p> 
 <pre><code># YOLOv5 v6.0 head
head:
  [[-1, 1, Conv, [512, 1, 1]],
   [-1, 1, nn.Upsample, [None, 2, 'nearest']],
   [[-1, 6], 1, Concat, [1]],  # cat backbone P4
   [-1, 3, C3, [512, False]],  # 13
​
   [-1, 1, Conv, [256, 1, 1]],
   [-1, 1, nn.Upsample, [None, 2, 'nearest']],
   [[-1, 4], 1, Concat, [1]],  # cat backbone P3
   [-1, 3, C3, [256, False]],  # 17 (P3/8-small)
​
   [-1, 1, Conv, [256, 3, 2]],
   [[-1, 14], 1, Concat, [1]],  # cat head P4
   [-1, 3, C3, [512, False]],  # 20 (P4/16-medium)
​
   [-1, 1, Conv, [512, 3, 2]],
   [[-1, 10], 1, Concat, [1]],  # cat head P5
   [-1, 3, C3, [1024, False]],  # 23 (P5/32-large)
​
   [[17, 20, 23], 1, Detect, [nc, anchors]],  # Detect(P3, P4, P5)
  ]</code></pre> 
 <p><strong>第10层：conv层</strong></p> 
 <p style="text-align:center;"><strong>20*20*512</strong></p> 
 <p><strong>第11层：Upsample层</strong></p> 
 <ul><li>不改变通道数<strong>，特征图的长和宽会增加一倍</strong></li></ul> 
 <p style="text-align:center;"><strong>40*40*512</strong></p> 
 <p></p> 
 <p><strong>第12层： Concat层</strong></p> 
 <ul><li><strong>与第6层的输出</strong>进行特征图的融合<strong>。</strong></li></ul> 
 <p style="text-align:center;"><strong>40*40*1024</strong></p> 
 <p><strong>第13层：c3层</strong></p> 
 <p style="text-align:center;"><strong>40*40*512</strong></p> 
 <p><img alt="" height="602" src="https://images2.imgbox.com/65/9a/Qz84FYKg_o.png" width="640"></p> 
 <p></p> 
 <p><strong>第14层：conv层</strong></p> 
 <p style="text-align:center;"><strong>40*40*256</strong></p> 
 <p><strong>第15层：Upsample层</strong></p> 
 <ul><li>不改变通道数<strong>，特征图的长和宽会增加一倍</strong></li></ul> 
 <p style="text-align:center;"><strong>80*80*256</strong></p> 
 <p></p> 
 <p><strong>第16层： Concat层</strong></p> 
 <ul><li><strong>与第4层的输出</strong>进行特征图的融合<strong>。</strong></li></ul> 
 <p style="text-align:center;"><strong>80*80*512</strong></p> 
 <p><strong>第17层：c3层</strong></p> 
 <p style="text-align:center;"><strong>40*40*256</strong></p> 
 <p style="text-align:center;"><img alt="" height="863" src="https://images2.imgbox.com/38/ae/agCCNNJh_o.png" width="619"></p> 
 <p></p> 
 <p>两个向下融合：</p> 
 <p><strong>第18层：conv层</strong></p> 
 <p style="text-align:center;"><strong>40*40*256</strong></p> 
 <p></p> 
 <p><strong>第19层： Concat层</strong></p> 
 <ul><li><strong>与第14层的输出</strong>进行特征图的融合<strong>。</strong></li></ul> 
 <p style="text-align:center;"><strong>40*40*512</strong></p> 
 <p><strong>第20层：c3层</strong></p> 
 <p style="text-align:center;"><strong>40*40*512</strong></p> 
 <p style="text-align:center;"></p> 
 <p><img alt="" height="713" src="https://images2.imgbox.com/fe/48/1eO4fLab_o.png" width="869"></p> 
 <p></p> 
 <p><strong>第21层：conv层</strong></p> 
 <p style="text-align:center;"><strong>20*20*512</strong></p> 
 <p></p> 
 <p><strong>第22层： Concat层</strong></p> 
 <ul><li><strong>与第10层的输出</strong>进行特征图的融合<strong>。</strong></li></ul> 
 <p style="text-align:center;"><strong>20*20*1024</strong></p> 
 <p><strong>第23层：c3层</strong></p> 
 <p style="text-align:center;"><strong>20*20*1024</strong></p> 
 <p style="text-align:center;"><img alt="" class="left" height="709" src="https://images2.imgbox.com/8c/56/tBr1wsi2_o.png" width="900"></p> 
 <p style="text-align:center;"></p> 
 <p> <strong>Detect</strong></p> 
 <ul><li>是对第17，20，23层的输出进行检测。</li></ul> 
 <p></p> 
 <h3 id="%F0%9F%8D%8A%E4%B8%89%EF%BC%8Cjupyter%20notebook%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BD%8D%E7%BD%AE"><a href="https://blog.csdn.net/zzqingyun/article/details/123289836?spm=1001.2014.3001.5501#%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AEPyCharm%E7%8E%AF%E5%A2%83" title="🍊">🍊</a>构成的元素</h3> 
 <h4 id="h_563598234_1"><strong>Conv ---CBA(convolution, batch normalization, activation)</strong></h4> 
 <pre><code>class Conv(nn.Module):
    # Standard convolution
    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True):  # ch_in, ch_out, kernel, stride, padding, groups
        super().__init__()
        self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p), groups=g, bias=False)
        self.bn = nn.BatchNorm2d(c2)
        self.act = nn.SiLU() if act is True else (act if isinstance(act, nn.Module) else nn.Identity())
​
    def forward(self, x):
        return self.act(self.bn(self.conv(x)))
​
    def forward_fuse(self, x):
        return self.act(self.conv(x))</code></pre> 
 <h4 id="h_563598234_2"><strong>关于SiLU--sigmoid linear unit</strong></h4> 
 <p>* sigmoid(x) = x / (e^-x + 1)</p> 
 <p>在yolov5中作者使用的是<strong>SiLU这个激活函数，</strong>用的这个函数有什么好处呢？</p> 
 <p>这个函数有一个极小值点，在模型训练的时候更有利于模型的收敛。</p> 
 <h4 id="h_563598234_3"></h4> 
 <p></p> 
 <p><img alt="" height="649" src="https://images2.imgbox.com/c2/6d/S17eBQGX_o.png" width="998"></p> 
 <p></p> 
 <h4><strong>SPP(Spatial Pyramid Pooling)/SPPF(Spatial Pyramid Pooling Fast)结构</strong></h4> 
 <p>SPP 是何凯明15年在<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1406.4729" rel="nofollow" title="Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition">Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition</a>中提出来的，在RCNN中第一阶段检测出来的候选框大小不一样，为了让这些候选框可以变成固定大小送进FC层，SPP就可以达到这一目的。<img alt="" height="566" src="https://images2.imgbox.com/0f/a8/3BSJ0xVh_o.png" width="1200"></p> 
 <p>在YOLOV5中SPP的目的是进一步增大feature map的感受野，使得物体在不同的尺度下输入时都能够被很好的检测到。如下左图所示。</p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/ae/a0/2zPfUme0_o.jpg"></p> 
 <p>SPPF是YOLOV5作者突然有一天想出来的，他发现用连续三个5x5大小的kernal做polling可以达到同样的效果，如上右图所示。输入的feature map连续进入3个kernel size为5的卷积，然后cancat在一起，channel经过卷积升维到1024输出。SPPF在YOLO中的实现如下。</p> 
 <pre><code>class SPPF(nn.Module):
    # Spatial Pyramid Pooling - Fast (SPPF) layer for YOLOv5 by Glenn Jocher
    def __init__(self, c1, c2, k=5):  # equivalent to SPP(k=(5, 9, 13))
        super().__init__()
        c_ = c1 // 2  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)
        self.cv2 = Conv(c_ * 4, c2, 1, 1)
        self.m = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)
​
    def forward(self, x):
        x = self.cv1(x)
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')  # suppress torch 1.9.0 max_pool2d() warning
            y1 = self.m(x)
            y2 = self.m(y1)
            return self.cv2(torch.cat((x, y1, y2, self.m(y2)), 1))</code></pre> 
 <h4 id="%C2%A0C3%20--%20cross%20stage%20partial%20network%20with%203%20convolutions"> <strong>C3 -- cross stage partial network with 3 convolutions</strong></h4> 
 <p>C3源自于CSPNet--cross stage patrial networks<a href="https://link.zhihu.com/?target=https%3A//github.com/WongKinYiu/CrossStagePartialNetworks" rel="nofollow" title="WongKinYiu/CrossStagePartialNetworks: Cross Stage Partial Networks (github.com)">WongKinYiu/CrossStagePartialNetworks: Cross Stage Partial Networks (github.com)</a>, CSPNet主要有以下几个贡献：</p> 
 <ul><li><strong>Strengthening learning ability of a CNN</strong> 现有的CNN在轻量化后，其精度大大降低，因此我们希望加强CNN的学习能力，使其在轻量化的同时保持足够的准确性。所提出的CSPNet可以很容易地应用于ResNet、ResNeXt和DenseNet。将CSPNet应用于上述网络后，计算量可从10%减少到20%，但在ImageNet[2]上进行图像分类任务的精度优于ResNet[7]、ResNeXt[39]、DenseNet[11]、HarDNet[1]、Elastic[36]和Res2Net[5]。</li><li><strong>Removing computational bottlenecks</strong> 过高的计算瓶颈会导致更多的计算周期来完成推理过程，或者一些算力单元经常闲置。因此，我们希望能够均匀分配CNN中各层的计算量，这样可以有效提升各计算单元的利用率，从而减少不必要的能耗。据悉，提出的CSPNet使得PeleeNet[37]的计算瓶颈减少了一半。此外，在基于MS COCO[18]数据集的物体检测实验中，我们提出的模型在基于YOLOv3的模型上测试时，可以有效降低80%的计算瓶颈。</li><li><strong>Reducing memory costs</strong> 动态随机存取存储器(DRAM)的晶圆制造成本非常昂贵，而且还占用了大量的空间。如果能有效降低存储器的成本，将大大降低ASIC的成本。此外，小面积的晶圆可以用于各种边缘计算设备。在减少内存使用方面，我们采用cross-channel pooling[6]，在特征金字塔生成过程中对特征图进行压缩。这样，提出的CSPNet与提出的对象检测器在生成特征金字塔时，可以减少PeleeNet上75%的内存使用量。</li></ul> 
 <p>对于CSPNet这里不多赘述，下面我们看下YoloV5中的“简化版CSPNet”，C3结构，</p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/3c/94/IpDwIK1Y_o.jpg"></p> 
 <pre><code>class C3(nn.Module):
    # CSP Bottleneck with 3 convolutions
    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, number, shortcut, groups, expansion
        super().__init__()
        c_ = int(c2 * e)  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)
        self.cv2 = Conv(c1, c_, 1, 1)
        self.cv3 = Conv(2 * c_, c2, 1)  # optional act=FReLU(c2)
        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))
        # self.m = nn.Sequential(*(CrossConv(c_, c_, 3, 1, g, 1.0, shortcut) for _ in range(n)))
​
    def forward(self, x):
        return self.cv3(torch.cat((self.m(self.cv1(x)), self.cv2(x)), 1))
        
class Bottleneck(nn.Module):
    # Standard bottleneck
    def __init__(self, c1, c2, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, shortcut, groups, expansion
        super().__init__()
        c_ = int(c2 * e)  # hidden channels
        self.cv1 = Conv(c1, c_, 1, 1)
        self.cv2 = Conv(c_, c2, 3, 1, g=g)
        self.add = shortcut and c1 == c2
​
    def forward(self, x):
        return x + self.cv2(self.cv1(x)) if self.add else self.cv2(self.cv1(x))</code></pre> 
 <hr> 
 <h3 id="%F0%9F%8D%8B%E5%9B%9B%E3%80%81Jupyter%20Notebook%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><a href="https://blog.csdn.net/zzqingyun/article/details/123289836?spm=1001.2014.3001.5501#%E5%9B%9B%E3%80%81PyCharm%E7%A0%B4%E8%A7%A3" title="🍋">🍋</a>项目结构</h3> 
 <p><strong>    scripts</strong>是获取数据的一些脚本。下面的yaml是关于一些数据的定义，比如coco数据集，coco128指的是从coco数据集中取出128张用于测试。</p> 
 <p></p> 
 <p><img alt="" height="296" src="https://images2.imgbox.com/5c/1e/b3uDZ7hK_o.png" width="475"></p> 
 <p><strong>models</strong>中的yaml指的是4个模型的配置文件</p> 
 <p><strong>yolo.py</strong>指的是把模型翻译成模型的一些接口。</p> 
 <p><strong>common</strong>放的是一些网络结构的定义</p> 
 <p></p> 
 <p><img alt="" height="289" src="https://images2.imgbox.com/b4/ef/8yCJhU9v_o.png" width="556"></p> 
 <p><strong>rus</strong>是我们运行的时候的一些输出文件。</p> 
 <p>每一次运行就会生成一个exp的文件夹。</p> 
 <p><img alt="" height="88" src="https://images2.imgbox.com/c3/1d/SdiV7ne8_o.png" width="631"></p> 
 <p></p> 
 <p> <img alt="" height="444" src="https://images2.imgbox.com/3f/04/a4SPgiBU_o.png" width="445"></p> 
 <p><strong>utils</strong>这个里面主要是放的一些脚本信息，比如数据增强等。</p> 
 <p><img alt="" height="371" src="https://images2.imgbox.com/62/eb/8AlQnneg_o.png" width="527"></p> 
 <p><strong>weight</strong></p> 
 <p>yolov5s.pt指的是预训练模型</p> 
 <p>detect.py是负责推理的文件</p> 
 <p>train.py 是训练的文件</p> 
 <p> <img alt="" height="463" src="https://images2.imgbox.com/86/af/BEbxekU9_o.png" width="547"></p> 
 <p></p> 
 <p><strong>Institutional Review Board Statement: Not applicable.</strong></p> 
 <p><strong>Informed Consent Statement: Not applicable.</strong></p> 
 <p><strong>Data Availability Statement: Not applicable.</strong></p> 
 <p><strong>Author Contributions:All authors participated in the assisting performance study and approved the paper.</strong></p> 
 <p><strong>Conflicts of Interest: The authors declare no conflict of interest</strong><br>  </p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1d1402f5801c97005050ba4a60d593c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MAC 通过IDEA启动tomcat，显示80端口被占用解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f8f56ff4d9ea388e5e51a297bbabc721/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">免费生成Nginx的Https使用的SSL证书</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>