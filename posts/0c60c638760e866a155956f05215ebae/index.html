<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>(四)OpenCV中的特征检测之Harris Corner检测 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="(四)OpenCV中的特征检测之Harris Corner检测" />
<meta property="og:description" content="注释：本文翻译自OpenCV3.0.0 document-&gt;OpenCV-Python Tutorials，包括对原文档种错误代码的纠正
1.目标
我们将了解harris corner detection背后的概念学习函数：cv2.cornerHarris()、cv2.cornerSubPix() 2.理论
在上一章中，我们看到角落是图像中各个方向强度变化很大的区域。早在1988年，Chris Harris &amp; Mike Stephens就在其论文A Combined Corner and Edge Detector中发现了这些角落的一个早期尝试，现在它被称为harris Corner Detector。他把这个简单的思想变成了一种数学形式。它基本找到了所有方向上的(u,v)位移的强度差异。这表示如下：
窗口函数是一个矩形窗口或高斯窗口，它给在其中的像素加权。
我们必须使边角检测的函数 最大化，这意味着，我们必须最大限度地利用第二个参数。将泰勒展开式应用于上述方程并使用一些数学步骤(请参阅你喜欢的任何标准教科书以获得完整推导)，我们的最终方程式为：
其中M为：
这里I_x和I_y分别是在x和y方向上的导数（使用cv2.Sobel()可以得到）。
然后是主要部分。在此之后，他们创建了一个分数，基本上是一个等式，它将决定一个窗口是否可以包含边角。
其中：
和 是M的特征值 所以这些特征值的值决定了一个区域是角落，边缘还是平面。
当 很小,也就是介于 和 之间,该区域是平面.当 ,也就是当 或相反时,该区域是边缘.当 很大,即当 和 都很大并且R介于 之间, 该区域是边角. 可以如下图表示：
所以Harris Corner检测的结果是一个灰度图像与这些数值，合适的阈值会给出图像中的边角。所以我们会用一个简单的图像来做到这点。
3.OpenCV中的harrisCorner检测器
为此，OpenCV中有cv2.cornerHarris(),它的参数是：
Img：输入图像，应该是灰度和float32类型blockSize：这是考虑边角检测的领域大小ksize：使用Sobel衍生物的孔径参数k：harris Corner检测器的自由参数 下面是一个栗子：
# -*- coding: utf-8 -*- &#39;&#39;&#39; harris Corner检测 1.OpenCV中的函数cv2.cornerHarris()和cv2.cornerSubPix() 2.cv2.cornerharris()参数： img：输入图像 blockSize:这是考虑检测的领域大小 ksize:使用Sobel衍生物的孔径参数 k:harris Corner检测器的自由参数 &#39;&#39;&#39; import cv2 import numpy as np filename = &#39;blox." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0c60c638760e866a155956f05215ebae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-04T09:28:15+08:00" />
<meta property="article:modified_time" content="2018-06-04T09:28:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">(四)OpenCV中的特征检测之Harris Corner检测</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="background-color:rgb(255,255,255);">注释：本文翻译自OpenCV3.0.0 document-&gt;OpenCV-Python Tutorials，包括对原文档种错误代码的纠正</span><br></p> 
<p>1.目标</p> 
<p></p> 
<ul><li>我们将了解harris corner detection背后的概念</li><li>学习函数：cv2.cornerHarris()、cv2.cornerSubPix()</li></ul> 
<p>2.理论</p> 
<p></p> 
<p>在上一章中，我们看到角落是图像中各个方向强度变化很大的区域。早在1988年，Chris Harris &amp; Mike Stephens就在其论文A Combined Corner and Edge Detector中发现了这些角落的一个早期尝试，现在它被称为harris Corner Detector。他把这个简单的思想变成了一种数学形式。它基本找到了所有方向上的(u,v)位移的强度差异。这表示如下：</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/ab/7a/fjtWs1Qm_o.png" alt=""></p> 
<p></p> 
<p>窗口函数是一个矩形窗口或高斯窗口，它给在其中的像素加权。</p> 
<p>我们必须使边角检测的函数<img src="https://images2.imgbox.com/24/ad/84bWa6jQ_o.png" alt=""> 最大化，这意味着，我们必须最大限度地利用第二个参数。将泰勒展开式应用于上述方程并使用一些数学步骤(请参阅你喜欢的任何标准教科书以获得完整推导)，我们的最终方程式为：</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/e5/5d/ZKZRQCoZ_o.png" alt=""></p> 
<p></p> 
<p>其中M为：</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/80/81/HsRO9Rbq_o.png" alt=""></p> 
<p></p> 
<p>这里I_x和I_y分别是在x和y方向上的导数（使用cv2.Sobel()可以得到）。</p> 
<p>然后是主要部分。在此之后，他们创建了一个分数，基本上是一个等式，它将决定一个窗口是否可以包含边角。</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/59/b3/UzY0jsER_o.png" alt=""></p> 
<p></p> 
<p>其中：</p> 
<ul type="disc"><li style="color:#000000;background:#FFFFFF;"><img src="https://images2.imgbox.com/ac/66/axPYzNHY_o.png" alt=""></li><li style="color:#000000;background:#FFFFFF;"><img src="https://images2.imgbox.com/f8/7d/KRc3c0Ri_o.png" alt=""></li><li style="color:#000000;background:#FFFFFF;"> <img src="https://images2.imgbox.com/b1/4e/OoInQp29_o.png" alt="">和 <img src="https://images2.imgbox.com/33/cc/YuzN1p46_o.png" alt=""> 是M的特征值</li></ul> 
<p style="background:#FFFFFF;"><span style="color:#000000;">所以这些特征值的值决定了一个区域是角落，边缘还是平面。</span></p> 
<ul type="disc"><li style="color:#000000;background:#FFFFFF;">当 <img src="https://images2.imgbox.com/bd/87/woYW2suT_o.png" alt=""> 很小,也就是介于<img src="https://images2.imgbox.com/e5/75/C2KUBNvM_o.png" alt=""> 和 <img src="https://images2.imgbox.com/90/6e/WwNDOt55_o.png" alt=""> 之间,该区域是平面.</li><li style="color:#000000;background:#FFFFFF;">当<img src="https://images2.imgbox.com/fb/87/vz7Y7maT_o.png" alt=""> ,也就是当<img src="https://images2.imgbox.com/f5/5a/Y4wDZevR_o.png" alt=""> 或相反时,该区域是边缘.</li><li style="color:#000000;background:#FFFFFF;">当<img src="https://images2.imgbox.com/26/50/Vso1RF6E_o.png" alt=""> 很大,即当 <img src="https://images2.imgbox.com/59/bb/lyUWdJPp_o.png" alt=""> 和<img src="https://images2.imgbox.com/ad/f1/2rcyXm7z_o.png" alt=""> 都很大并且R介于 <img src="https://images2.imgbox.com/17/ca/9ECGkKoz_o.png" alt=""> 之间, 该区域是边角.</li></ul> 
<p style="background:#FFFFFF;"><span style="color:#000000;">可以如下图表示：</span></p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/b8/2e/8l4EMnq2_o.jpg" alt=""></p> 
<p></p> 
<p>所以Harris Corner检测的结果是一个灰度图像与这些数值，合适的阈值会给出图像中的边角。所以我们会用一个简单的图像来做到这点。</p> 
<p>3.OpenCV中的harrisCorner检测器</p> 
<p></p> 
<p>为此，OpenCV中有cv2.cornerHarris(),它的参数是：</p> 
<p></p> 
<ul><li>Img：输入图像，应该是灰度和float32类型</li><li>blockSize：这是考虑边角检测的领域大小</li><li>ksize：使用Sobel衍生物的孔径参数</li><li>k：harris Corner检测器的自由参数</li></ul> 
<p>下面是一个栗子：</p> 
<pre><code class="language-python"># -*- coding: utf-8 -*-
'''
harris Corner检测
1.OpenCV中的函数cv2.cornerHarris()和cv2.cornerSubPix()
2.cv2.cornerharris()参数：
    img：输入图像
    blockSize:这是考虑检测的领域大小
    ksize:使用Sobel衍生物的孔径参数
    k:harris Corner检测器的自由参数

'''
import cv2
import numpy as np

filename = 'blox.jpg'
img = cv2.imread(filename)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

gray = np.float32(gray)
dst = cv2.cornerHarris(gray, 2, 3, 0.04)

# 结果是扩大标记的角落，不重要
dst = cv2.dilate(dst, None)

# 最佳值的阈值，它可能因图像而异
img[dst &gt; 0.01 * dst.max()] = [0, 255, 0]

cv2.imshow('dst', img)
if cv2.waitKey(0) &amp; 0xFF == 27:
    cv2.destroyAllWindows()
</code></pre> 
<p>结果：</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/a1/f2/EvbL4MrV_o.png" alt=""><br></p> 
<p>4.具有SubPixel准确度的角落(Corner with SubPixel Accuracy)</p> 
<p></p> 
<p>有时候，你可能需要以最高精度找到角点。OpenCV带有一个函数cv2.cornerSubPix().它进一步细化了以亚像素检测到的角点。下面是一个栗子。像往常一样，我们需要先找到Harris Corner，然后通过这些角的质心(可能有一些像素位于角落，我们取其质心)来优化它们。Harris Corner的角落标记为红色像素，精致的角落标记为绿色像素。对于这个函数，我们必须定义何时停止迭代的标准。我们停止指定的迭代次数或达到一定的准确度，以先发生者为准。我们还需定义要搜索拐角的领域的大小。</p> 
<pre><code class="language-python"># -*- coding: utf-8 -*-
'''
具有subPixel准确度的角落：
有时候需要以高精确度找到角点。使用cv2.cornerSubPix(),它进一步细化了以亚像素检测到的角点。
1.要先寻找harris corner，然后找到这些点的质心。
2.下面栗子中，harris corner的角落标记为红色像素，精致的角落标记为绿色像素。
3.还需要搜索拐角领域的大小
'''

import cv2
import numpy as np

filename = 'blox.jpg'
img = cv2.imread(filename)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 找到harris corner
gray = np.float32(gray)
dst = cv2.cornerHarris(gray, 2, 3, 0.04)
dst = cv2.dilate(dst, None)
ret, dst = cv2.threshold(dst, 0.01 * dst.max(), 255, 0)
dst = np.uint8(dst)

# 找到质心
ret, labels, states, centroids = cv2.connectedComponentsWithStats(dst)
# 定义停止和改进角落的标注
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.001)
corners = cv2.cornerSubPix(gray, np.float32(centroids), (5, 5), (-1, -1), criteria)

# 现在绘制它们
res = np.hstack((centroids, corners))
res = np.int0(res)
img[res[:, 1], res[:, 0]] = [0, 0, 255]  # 红色
img[res[:, 3], res[:, 2]] = [0, 255, 0]  # 绿色

cv2.imwrite('subpixel5.png', img)
cv2.imshow('res', img)
cv2.waitKey(0) &amp; 0xFF
cv2.destroyAllWindows()
</code></pre> 
<p>结果：</p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/e8/6c/gDC7Z9CS_o.png" alt=""><br></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5fcef103e1d45acb7dc6962889746238/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">激光样式——第九届蓝桥杯C语言B组（国赛）第二题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9125585f88b036d9b6e6834fd08aca75/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">(四)OpenCV中的特征检测之SIFT(尺度不变换特征)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>