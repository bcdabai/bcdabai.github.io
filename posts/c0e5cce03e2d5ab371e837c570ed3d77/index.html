<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>audio的输出设备切换分析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="audio的输出设备切换分析" />
<meta property="og:description" content="本文主要介绍android上音频输出设备切换的代码流程 （此文部分内容参考自邓凡达老师的博客。感谢邓老师讲解） 上层程序要切换输出设备时，经过JNI调用，会调用AudioSystem::setForceUse status_t AudioSystem::setForceUse(audio_policy_force_use_t usage, audio_policy_forced_cfg_t config) { const sp&lt;IAudioPolicyService&gt;&amp; aps = AudioSystem::get_audio_policy_service(); if (aps == 0) return PERMISSION_DENIED; return aps-&gt;setForceUse(usage, config); } 接下来就是调用frameworks/av/services/audioflinger/AudioPolicyService.cpp的setForceUse()函数了； status_t AudioPolicyService::setForceUse(audio_policy_force_use_t usage, audio_policy_forced_cfg_t config) { Mutex::Autolock _l(mLock); mpAudioPolicy-&gt;set_force_use(mpAudioPolicy, usage, config); return NO_ERROR; } AP章节中，我们介绍过，mpAudioPolicy实际上是在AudioServicePolicy.cpp的构造函数中被赋值，可以理解成是指向了AP HAL层的handle mpAudioPolicy-&gt;set_force_use实际上调用的是audio_policy_hal.cpp里面的ap_set_force_use。 static void ap_set_force_use(struct audio_policy *pol, audio_policy_force_use_t usage, audio_policy_forced_cfg_t config) { struct legacy_audio_policy *lap = to_lap(pol); lap-&gt;apm-&gt;setForceUse((AudioSystem::force_use)usage, (AudioSystem::forced_config)config); } 继而调用AudioPolicyManagerBase::setForceUse void AudioPolicyManagerBase::setForceUse(AudioSystem::force_use usage, AudioSystem::forced_config config) { .... checkA2dpSuspend(); checkOutputForAllStrategies(); updateDevicesAndOutputs(); //各种内部状态的更新 for (size_t i = 0; i &lt; mOutputs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c0e5cce03e2d5ab371e837c570ed3d77/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-02-20T20:02:49+08:00" />
<meta property="article:modified_time" content="2016-02-20T20:02:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">audio的输出设备切换分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <br> 
<br> 本文主要介绍android上音频输出设备切换的代码流程 
<br> （此文部分内容参考自邓凡达老师的博客。感谢邓老师讲解） 
<br> 
<br> 
<br> 上层程序要切换输出设备时，经过JNI调用，会调用AudioSystem::setForceUse 
<br> 
<pre><code class="language-cpp">status_t AudioSystem::setForceUse(audio_policy_force_use_t usage, audio_policy_forced_cfg_t config)
{
    const sp&lt;IAudioPolicyService&gt;&amp; aps = AudioSystem::get_audio_policy_service();
    if (aps == 0) return PERMISSION_DENIED;
    return aps-&gt;setForceUse(usage, config);
}</code></pre> 
<br> 
<br> 
<br> 接下来就是调用frameworks/av/services/audioflinger/AudioPolicyService.cpp的setForceUse()函数了； 
<br> 
<pre><code class="language-cpp">status_t AudioPolicyService::setForceUse(audio_policy_force_use_t usage,
                                         audio_policy_forced_cfg_t config)
{
    Mutex::Autolock _l(mLock);
    mpAudioPolicy-&gt;set_force_use(mpAudioPolicy, usage, config);
    return NO_ERROR;
}</code></pre> 
<br> 
<br> 
<p><br> </p> AP章节中，我们介绍过，mpAudioPolicy实际上是在AudioServicePolicy.cpp的构造函数中被赋值，可以理解成是指向了AP HAL层的handle 
<br> mpAudioPolicy-&gt;set_force_use实际上调用的是audio_policy_hal.cpp里面的ap_set_force_use。 
<br> 
<pre><code class="language-cpp">static void ap_set_force_use(struct audio_policy *pol,
                          audio_policy_force_use_t usage,
                          audio_policy_forced_cfg_t config)
{
    struct legacy_audio_policy *lap = to_lap(pol);
    lap-&gt;apm-&gt;setForceUse((AudioSystem::force_use)usage,
                          (AudioSystem::forced_config)config);
}</code></pre> 
<br> 
<br> 继而调用AudioPolicyManagerBase::setForceUse 
<br> 
<pre><code class="language-cpp">void AudioPolicyManagerBase::setForceUse(AudioSystem::force_use usage, AudioSystem::forced_config config)
{
....
    checkA2dpSuspend();
    checkOutputForAllStrategies();
    updateDevicesAndOutputs(); //各种内部状态的更新
    for (size_t i = 0; i &lt; mOutputs.size(); i++) {
        audio_io_handle_t output = mOutputs.keyAt(i);
        audio_devices_t newDevice = getNewDevice(output, true /*fromCache*/);
        setOutputDevice(output, newDevice, (newDevice != AUDIO_DEVICE_NONE));  //继续往下调用
        if (forceVolumeReeval &amp;&amp; (newDevice != AUDIO_DEVICE_NONE)) {
            applyStreamVolumes(output, newDevice, 0, true);
        }
    }
....
 
}</code></pre> 
<br> 
<br> 继续看setOutputDevice的代码，如下所示： 
<br> 
<br> [--&gt;AudioPolicyManagerBase.cpp] 
<br> 
<pre><code class="language-cpp">void AudioPolicyManagerBase::setOutputDevice(audio_io_handle_toutput,  uint32_t device,bool force, int delayMs)
{
    ......
   //把这个请求要发送到output对应的AF工作线程中
     AudioParameterparam = AudioParameter();
   //参数是key/vlaue键值对的格式
    param.addInt(String8(AudioParameter::keyRouting),(int)device);
   //mpClientInterface是AP对象，由它处理
    mpClientInterface-&gt;setParameters(mHardwareOutput, param.toString(),delayMs);
   //设置音量，不做讨论，读者可自行分析
   applyStreamVolumes(output, device, delayMs);
 }</code></pre> 
<p><br> </p> 
<p><br> </p> setParameters最终会调用APS的setParameters，代码如下所示： 
<br> [--&gt;AudioPolicyService.cpp] 
<br> 
<pre><code class="language-cpp">voidAudioPolicyService::setParameters(audio_io_handle_t ioHandle,
                              constString8&amp; keyValuePairs, int delayMs)
{
    //把这个请求加入到AudioCommandThread处理
    mAudioCommandThread-&gt;parametersCommand((int)ioHandle,
                                                 keyValuePairs, delayMs);
}
</code></pre> 
<br> 
<br> 
<br> AudioPolicyService创建时会同时创建两个线程，其中一个用于处理各种请求。现在看看它是怎么做的。 
<br> AudioCommandThread有一个请求处理队列，AP负责往该队列中提交请求，而AudioCommandThread在它的线程函数threadLoop中处理这些命令。请直接看命令是如何处理的。 
<br> 说明：这种通过一个队列来协调两个线程的方法，在多线程编程中非常常见，它也属于生产者/消费者模型。 
<br> 
<br> 
<br> AudioCommandThread中的处理 
<br> [--&gt;AudioPolicyService.cpp] 
<br> 
<pre><code class="language-cpp">boolAudioPolicyService::AudioCommandThread::threadLoop()
{
    nsecs_twaitTime = INT64_MAX;
   mLock.lock();
    while(!exitPending())
    {
       while(!mAudioCommands.isEmpty()) {
           nsecs_t curTime = systemTime();
           if (mAudioCommands[0]-&gt;mTime &lt;= curTime) {
               AudioCommand *command = mAudioCommands[0];
               mAudioCommands.removeAt(0);
               mLastCommand = *command;
               switch (command-&gt;mCommand) {
               case START_TONE:
                   ......
               case STOP_TONE:
                   ......  //TONE处理
                    mLock.lock();
                    }break;
               case SET_VOLUME: {
                    //设置音量
                    delete data;
                    }break;
               case SET_PARAMETERS: {
                    //处理路由设置请求
                     ParametersData *data =(ParametersData *)command-&gt;mParam;
                    //转到AudioSystem处理，mIO的值为mHardwareOutput
                     command-&gt;mStatus =AudioSystem::setParameters(
                                          data-&gt;mIO,
                                         data-&gt;mKeyValuePairs);
                     if(command-&gt;mWaitStatus) {
                        command-&gt;mCond.signal();
                        mWaitWorkCV.wait(mLock);
                     }
                     delete data;
                     }break;
               ......
               default:
               }
}</code></pre> 
<br> 先看AudioSystem的setParameters。 
<br> AudioSystem将设置请求转移给AudioFlinger处理，代码如下所示： 
<br> 
<pre><code class="language-cpp">[--&gt;AudioSystem.cpp]
status_t AudioSystem::setParameters(audio_io_handle_t ioHandle,
                                          constString8&amp; keyValuePairs)
{
     const sp&lt;IAudioFlinger&gt;&amp; af = AudioSystem::get_audio_flinger();
    //果然是交给AF处理，ioHandle看来一定就是工作线程索引号了
    return af-&gt;setParameters(ioHandle, keyValuePairs);
}</code></pre> 
<p><br> </p> 
<p><br> </p> 离真相越来越近了，接着看代码，如下所示： 
<br> [--&gt;AudioFlinger.cpp] 
<br> 
<pre><code class="language-cpp">status_t AudioFlinger::setParameters(intioHandle,  constString8&amp; keyValuePairs)
{
   status_t result;
    // ioHandle == 0 表示和混音线程无关，需要直接设置到HAL对象中。
    if(ioHandle == 0) {
       AutoMutex lock(mHardwareLock);
       mHardwareStatus = AUDIO_SET_PARAMETER;
       //调用AudioHardwareInterface的参数设置接口
       result = mAudioHardware-&gt;setParameters(keyValuePairs);
       mHardwareStatus = AUDIO_HW_IDLE;
       return result;
    }
    sp&lt;ThreadBase&gt; thread;
    {
       Mutex::Autolock _l(mLock);
       //根据索引号找到对应混音线程。
       thread = checkPlaybackThread_l(ioHandle);
      }
     result = thread-&gt;setParameters(keyValuePairs);
      return result;
    }
    return BAD_VALUE;
}</code></pre> 
<br> 
<br> 好了，最终的请求处理在MixerThread，或者DirectPlaybackThread的线程函数中，来看： 
<br> 例如MixerThread最终处理代码如下所示： 
<br> [ 
<pre><code class="language-cpp">--&gt;AudioFlinger.cpp]
bool AudioFlinger::MixerThread::threadLoop()
{
    ....
    while(!exitPending())
    {
       processConfigEvents();
       mixerStatus = MIXER_IDLE;
        {// scope for mLock
           Mutex::Autolock _l(mLock);
          // checkForNewParameters_l最有嫌疑
           if (checkForNewParameters_l()) {
                ...
           }
      ......//其他处理
}
</code></pre> 
<br> 
<br> 
<pre><code class="language-cpp">[--&gt;AudioFlinger.cpp]
boolAudioFlinger::MixerThread::checkForNewParameters_l()
{


    boolreconfig = false;
    while(!mNewParameters.isEmpty()) {
       status_t status = NO_ERROR;
       String8 keyValuePair = mNewParameters[0];
       AudioParameter param = AudioParameter(keyValuePair);
       int value;
       ......
      //路由设置需要硬件参与，所以直接交给代表音频输出设备的HAL对象处理
      status = mOutput-&gt;setParameters(keyValuePair);   
      return reconfig;
}</code></pre> 
<br> 
<br> 至此，路由设置最终通过HAL的setParameters来实现。 
<br> 在某款android DTV的具体HAL实现上， 
<br> 智能电视上只有三路音频通道：板载speaker，SPDIF，蓝牙， 
<br> 切换到蓝牙时，走A2DP的path，这里没有深入研究。不做赘述。 
<br> 切换到板载speaker或者SPDIF时，这两者在同一个HAL里。 
<br> HAL层切换的时候，根据不同的setParameters参数，打开不同的/dev/snd/pcm设备写就可以了。
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c7f50941e131e2d92bdebaabc26be9df/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">android audio 音量设置分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c75c945dac913770ecf34b8f4b6b2a2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">给eclipse装一些插件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>