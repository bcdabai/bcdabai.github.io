<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java Map集合的详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java Map集合的详解" />
<meta property="og:description" content="一，Map
先说一下Map吧~
如果程序中存储了几百万个学生，而且经常需要使用学号来搜索某个学生，那么这个需求有效的数据结构就是Map。
Map是一种依照键（key）存储元素的容器，键（key）很像下标，在List中下标是整数。在Map中键（key）可以使任意类型的对象。Map中不能有重复的键（Key），每个键（key）都有一个对应的值（value）。
一个键（key）和它对应的值构成map集合中的一个元素。
Map中的元素是两个对象，一个对象作为键，一个对象作为值。键不可以重复，但是值可以重复。
看顶层共性方法找子类特有对象.
Map与Collection在集合框架中属并列存在
Map存储的是键值对
Map存储元素使用put方法，Collection使用add方法
Map集合没有直接取出元素的方法，而是先转成Set集合，在通过迭代获取元素
Map集合中键要保证唯一性
也就是Collection是单列集合, Map 是双列集合。
总结: Map一次存一对元素, Collection 一次存一个。Map 的键不能重复，保证唯一。
Map 一次存入一对元素,是以键值对的形式存在.键与值存在映射关系.一定要保证键的唯一性.
查看api文档:
interface Map&lt;K,V&gt;
K - 此映射所维护的键的类型
V - 映射值的类型
概念
将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。
特点
Key和Value是1对1的关系，如：门牌号 ：家 老公:老婆
双列集合
Map学习体系： ---| Map 接口 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 ---| HashMap 采用哈希表实现，所以无序 ---| TreeMap 可以对健进行排序 ---|Hashtable: 底层是哈希表数据结构，线程是同步的，不可以存入null键，null值。 效率较低，被HashMap 替代。 ---|HashMap: 底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。 要保证键的唯一性，需要覆盖hashCode方法，和equals方法。 ---| LinkedHashMap： 该子类基于哈希表又融入了链表。可以Map集合进行增删提高效率。 ---|TreeMap: 底层是二叉树数据结构。可以对map集合中的键进行排序。需要使用Comparable或者Comparator 进行比较排序。return 0，来判断键的唯一性。 常见方法
1、添加： 1、V put(K key, V value) （可以相同的key值，但是添加的value值会覆 盖前面的，返回值是前一个，如果没有就返回null） 2、putAll(Map&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5586e52e4f697cfc99c3e570828a7254/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-07-27T21:43:33+08:00" />
<meta property="article:modified_time" content="2016-07-27T21:43:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java Map集合的详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:14px; color:#ff0000">一，Map</span></p> 
<p><span style="font-size:14px">先说一下Map吧~</span></p> 
<p><span style="font-size:14px">如果程序中存储了几百万个学生，而且经常需要使用学号来搜索某个学生，那么这个需求有效的数据结构就是<span style="font-family:Times New Roman">Map</span><span style="font-family:宋体">。</span></span></p> 
<p><span style="font-size:14px">Map<span style="font-family:宋体">是一种依照键（</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">）存储元素的容器，键（</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">）很像下标，在</span><span style="font-family:Times New Roman">List</span><span style="font-family:宋体">中下标是整数。在</span><span style="font-family:Times New Roman">Map</span><span style="font-family:宋体">中键（</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">）可以使任意类型的对象。</span>Map<span style="font-family:宋体">中不能有重复的键（</span><span style="font-family:Times New Roman">Key</span><span style="font-family:宋体">），每个键（</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">）都有一个对应的值（</span><span style="font-family:Times New Roman">value</span><span style="font-family:宋体">）。</span></span></p> 
<p><span style="font-size:14px"><span style="font-family:宋体">一个键（</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">）和它对应的值构成</span><span style="font-family:Times New Roman">map</span><span style="font-family:宋体">集合中的一个元素。</span></span></p> 
<p><span style="font-size:14px">Map<span style="font-family:宋体">中的元素是两个对象，一个对象作为键，一个对象作为值。键不可以重复，但是值可以重复。</span></span></p> 
<p><span style="font-size:14px; color:#ff0000">看顶层共性方法找子类特有对象.</span></p> 
<p><span style="font-size:14px">Map与Collection在集合框架中属并列存在</span></p> 
<p><span style="font-size:14px">Map存储的是键值对</span></p> 
<p><span style="font-size:14px">Map存储元素使用put方法，Collection使用add方法</span></p> 
<p><span style="font-size:14px">Map集合没有直接取出元素的方法，而是先转成Set集合，在通过迭代获取元素</span></p> 
<p><span style="font-size:14px">Map集合中键要保证唯一性</span></p> 
<p><span style="font-size:14px">也就是Collection是单列集合, Map 是双列集合。</span></p> 
<p><span style="font-size:14px; color:#ff0000">总结<span style="font-family:Courier New">:</span> </span></p> 
<p><span style="font-size:14px">Map一次存一对元素, Collection 一次存一个。Map 的键不能重复，保证唯一。</span></p> 
<p><span style="font-size:14px">Map 一次存入一对元素,是以键值对的形式存在.键与值存在映射关系.一定要保证键的唯一性.</span></p> 
<p><span style="font-size:14px">查看<span style="font-family:Courier New">api</span><span style="font-family:宋体">文档</span><span style="font-family:Courier New">:</span></span></p> 
<p><span style="font-size:14px">interface Map&lt;K,V&gt;</span></p> 
<p><span style="font-size:14px">K - 此映射所维护的键的类型</span></p> 
<p><span style="font-size:14px">V - 映射值的类型</span></p> 
<p><span style="font-size:14px; color:#ff0000">概念</span></p> 
<p><span style="font-size:14px">将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。</span></p> 
<p><span style="font-size:14px; color:#ff0000">特点</span></p> 
<p><span style="font-size:14px">Key和Value是1对1的关系，如：门牌号 ：家  老公<span style="font-family:Courier New">:</span><span style="font-family:宋体">老婆</span></span></p> 
<p><span style="font-size:14px">双列集合</span></p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-java">Map学习体系：
 ---| Map  接口    将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。
			---| HashMap  采用哈希表实现，所以无序
            ---| TreeMap   可以对健进行排序

---|Hashtable:
底层是哈希表数据结构，线程是同步的，不可以存入null键，null值。
效率较低，被HashMap 替代。
---|HashMap:
底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。
要保证键的唯一性，需要覆盖hashCode方法，和equals方法。
---| LinkedHashMap：
该子类基于哈希表又融入了链表。可以Map集合进行增删提高效率。
---|TreeMap:
底层是二叉树数据结构。可以对map集合中的键进行排序。需要使用Comparable或者Comparator 进行比较排序。return 0，来判断键的唯一性。</code></pre> 
<p></p> 
<p>常见方法</p> 
<p><span style="font-size:14px"></span></p> 
<pre><code class="language-java">1、添加：
	1、V put(K key, V value)    （可以相同的key值，但是添加的value值会覆
盖前面的，返回值是前一个，如果没有就返回null）                                          
	2、putAll(Map&lt;? extends K,? extends V&gt; m)  从指定映射中将所有映射关
系复制到此映射中（可选操作）。
2、删除
	1、remove()    删除关联对象，指定key对象
	2、clear()     清空集合对象
3、获取
     1：value get(key); 可以用于判断键是否存在的情况。当指定的键不存在的时候，返
回的是null。

3、判断：
	1、boolean isEmpty()   长度为0返回true否则false
    2、boolean containsKey(Object key)  判断集合中是否包含指定的key
3、boolean containsValue(Object value)  判断集合中是否包含指定的value
4、长度：
Int size（）</code></pre> 
<p></p> 
<p><span style="color:#ff0000">添加：</span></p> 
<p>该案例使用了HashMap，建立了学生姓名和年龄之间的映射关系。并试图添加重复的键。</p> 
<pre><code class="language-java">public class Demo1 {
	public static void main(String[] args) {
		// 定义一个Map的容器对象
		Map&lt;String, Integer &gt; map1 = new HashMap&lt;String, Integer &gt;();
		map1.put("jack", 20);
		map1.put("rose", 18);
		map1.put("lucy", 17);
		map1.put("java", 25);
		System.out.println(map1);
		// 添加重复的键值（值不同）,会返回集合中原有（重复键）的值，		 System.out.println(map1.put("jack", 30)); //20
		       
		Map&lt;String, Integer&gt; map2 = new HashMap&lt;String, Integer&gt;();
		map2.put("张三丰", 100);
		map2.put("虚竹", 20);
		System.out.println("map2:" + map2);
// 从指定映射中将所有映射关系复制到此映射中。
		map1.putAll(map2);
		System.out.println("map1:" + map1);
         //
	}
}</code></pre> 
<p><span style="color:#ff0000">删除<span style="font-family:Times New Roman">:</span></span></p> 
<pre><code class="language-java">// 删除：
		// remove() 删除关联对象，指定key对象
		// clear() 清空集合对象

		Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();
		map1.put("jack", 20);
		map1.put("rose", 18);
		map1.put("lucy", 17);
		map1.put("java", 25);
		System.out.println(map1);				
// 指定key，返回删除的键值对映射的值。
		System.out.println("value:" + map1.remove("java"));
		map1.clear();
		System.out.println("map1:" + map1);</code></pre> 
<p><span style="color:#ff0000">获取<span style="font-family:Times New Roman">:</span></span></p> 
<pre><code class="language-java">// 获取：
		// V get(Object key) 通过指定的key对象获取value对象
		// int size() 获取容器的大小
		Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();
		map1.put("jack", 20);
		map1.put("rose", 18);
		map1.put("lucy", 17);
		map1.put("java", 25);
		System.out.println(map1);
		// V get(Object key) 通过指定的key对象获取value对象
		// int size() 获取容器的大小
		System.out.println("value:" + map1.get("jack"));
		System.out.println("map.size:" + map1.size());</code></pre> 
<p><span style="color:#ff0000">判断<span style="font-family:Times New Roman">:</span></span></p> 
<pre><code class="language-java">// 判断：
		// boolean isEmpty() 长度为0返回true否则false
		// boolean containsKey(Object key) 判断集合中是否包含指定的key
		// boolean containsValue(Object value)

		Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();
		map1.put("jack", 20);
		map1.put("rose", 18);
		map1.put("lucy", 17);
		map1.put("java", 25);
		System.out.println(map1);
		System.out.println("isEmpty:" + map1.isEmpty());
		System.out.println("containskey:" + map1.containsKey("jack"));
		System.out.println("containsvalues:" + map1.containsValue(100));</code></pre> 
<p>遍历Map的方式：</p> 
<pre><code class="language-java">1、将map 集合中所有的键取出存入set集合。
		Set&lt;K&gt; keySet()   返回所有的key对象的Set集合
                             再通过get方法获取键对应的值。
2、 values() ，获取所有的值.
		Collection&lt;V&gt; values()不能获取到key对象
3、 Map.Entry对象  推荐使用   重点
		Set&lt;Map.Entry&lt;k,v&gt;&gt; entrySet()
将map 集合中的键值映射关系打包成一个对象
Map.Entry对象通过Map.Entry 对象的getKey，
getValue获取其键和值。</code></pre> 
<p>第一种方式:使用keySet</p> 
<p>将Map转成Set集合（keySet()），通过Set<span style="font-family:宋体">的</span>迭代器取出Set集合中的每一个元素（Iterator）就是Map集合中的所有的键，再通过get方法获取键对应的值。</p> 
<pre><code class="language-java">public class Demo2 {
	public static void main(String[] args) {
		Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();
		map.put(1, "aaaa");
		map.put(2, "bbbb");
		map.put(3, "cccc");
		System.out.println(map);

		//
		// 获取方法：
		// 第一种方式: 使用keySet
		// 需要分别获取key和value，没有面向对象的思想
		// Set&lt;K&gt; keySet() 返回所有的key对象的Set集合

		Set&lt;Integer&gt; ks = map.keySet();
		Iterator&lt;Integer&gt; it = ks.iterator();
		while (it.hasNext()) {
			Integer key = it.next();
			String value = map.get(key);
			System.out.println("key=" + key + " value=" + value);
		}
	}
}</code></pre> 
<br> 
<p>第二种方式<span style="font-family:Times New Roman">:</span><span style="color:rgb(63,127,95)"> </span>通过<span style="font-family:Times New Roman">values </span><span style="font-family:宋体">获取所有值</span><span style="font-family:Times New Roman">,</span><span style="font-family:宋体">不能获取到</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">对象</span></p> 
<pre><code class="language-java">public static void main(String[] args) {
		Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();
		map.put(1, "aaaa");
		map.put(2, "bbbb");
		map.put(3, "cccc");
		System.out.println(map);
// 第二种方式：
		// 通过values 获取所有值,不能获取到key对象
		// Collection&lt;V&gt; values()

		Collection&lt;String&gt; vs = map.values();
		Iterator&lt;String&gt; it = vs.iterator();
		while (it.hasNext()) {
			String value = it.next();
			System.out.println(" value=" + value);
		}
}</code></pre> 
<p>第三种方式: Map.Entry</p> 
<p>public static interface Map.Entry&lt;K,V&gt;</p> 
<p>通过<span style="font-family:Courier New">Map</span><span style="font-family:宋体">中的</span>entrySet()方法获取存放Map.Entry&lt;K,V&gt;对象的<span style="font-family:Courier New">Set</span><span style="font-family:宋体">集合。</span></p> 
<p>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</p> 
<p>面向对象的思想将<span style="font-family:Courier New">map</span><span style="font-family:宋体">集合中的键和值映射关系打包为一个对象，就是</span>Map.Entry</p> 
<p>，将该对象存入<span style="font-family:Courier New">Set</span><span style="font-family:宋体">集合，</span>Map.Entry是一个对象，那么该对象具备的<span style="font-family:Courier New">getKey</span><span style="font-family:宋体">，</span><span style="font-family:Courier New">getValue</span><span style="font-family:宋体">获得键和值。</span></p> 
<pre><code class="language-java">public static void main(String[] args) {
		Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();
		map.put(1, "aaaa");
		map.put(2, "bbbb");
		map.put(3, "cccc");
		System.out.println(map);
		// 第三种方式： Map.Entry对象 推荐使用 重点
		// Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()
		

		// 返回的Map.Entry对象的Set集合 Map.Entry包含了key和value对象
		Set&lt;Map.Entry&lt;Integer, String&gt;&gt; es = map.entrySet();

		Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = es.iterator();

		while (it.hasNext()) {
			
			// 返回的是封装了key和value对象的Map.Entry对象
			Map.Entry&lt;Integer, String&gt; en = it.next();

			// 获取Map.Entry对象中封装的key和value对象
			Integer key = en.getKey();
			String value = en.getValue();

			System.out.println("key=" + key + " value=" + value);
		}
	}</code></pre> 
<br> 
<span style="color:#ff0000">二，HashMap</span> 
<p><span style="font-size:14px"></span></p> 
<p>底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。</p> 
<p>案例：自定义对象作为Map的键。</p> 
<pre><code class="language-java">public class Demo3 {
	public static void main(String[] args) {
		HashMap&lt;Person, String&gt; hm = new HashMap&lt;Person, String&gt;();
		hm.put(new Person("jack", 20), "1001");
		hm.put(new Person("rose", 18), "1002");
		hm.put(new Person("lucy", 19), "1003");
		hm.put(new Person("hmm", 17), "1004");
		hm.put(new Person("ll", 25), "1005");
		System.out.println(hm);
		System.out.println(hm.put(new Person("rose", 18), "1006"));

		Set&lt;Entry&lt;Person, String&gt;&gt; entrySet = hm.entrySet();
		Iterator&lt;Entry&lt;Person, String&gt;&gt; it = entrySet.iterator();
		while (it.hasNext()) {
			Entry&lt;Person, String&gt; next = it.next();
			Person key = next.getKey();
			String value = next.getValue();
			System.out.println(key + " = " + value);
		}
	}
}

class Person {
	private String name;
	private int age;

	Person() {

	}

	public Person(String name, int age) {

		this.name = name;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public int hashCode() {

		return this.name.hashCode() + age * 37;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Person) {
			Person p = (Person) obj;
			return this.name.equals(p.name) &amp;&amp; this.age == p.age;
		} else {
			return false;
		}
	}

	@Override
	public String toString() {

		return "Person@name:" + this.name + " age:" + this.age;
	}

}
}</code></pre> 
<br> 
<span style="color:#ff0000">三，TreeMap</span> 
<p><span style="font-size:14px"></span></p> 
<p>TreeMap的排序，TreeMap可以对集合中的键进行排序。如何实现键的排序？</p> 
<p>方式一：元素自身具备比较性</p> 
<p>和TreeSet一样原理，需要让存储在键位置的对象实现Comparable接口，重写compareTo方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫做默认排序。</p> 
<p>方式二：容器具备比较性</p> 
<p>当元素自身不具备比较性，或者自身具备的比较性不是所需要的。那么此时可以让容器自身具备。需要定义一个类实现接口Comparator，重写compare方法，并将该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。</p> 
<p>注意：当Comparable比较方式和Comparator比较方式同时存在时，以Comparator的比较方式为主；</p> 
<p>注意：在重写compareTo或者compare方法时，必须要明确比较的主要条件相等时要比较次要条件。（假设姓名和年龄一直的人为相同的人，如果想要对人按照年龄的大小来排序，如果年龄相同的人，需要如何处理？不能直接<span style="font-family:Courier New">return 0</span><span style="font-family:宋体">，以为可能姓名不同（年龄相同姓名不同的人是不同的人）。此时就需要进行次要条件判断（需要判断姓名），只有姓名和年龄同时相等的才可以返回</span><span style="font-family:Courier New">0.</span><span style="font-family:宋体">）</span></p> 
<p>通过<span style="font-family:Courier New">return 0</span><span style="font-family:宋体">来判断唯一性。</span></p> 
<pre><code class="language-java">public class Demo4 {
	public static void main(String[] args) {
		TreeMap&lt;String, Integer&gt; tree = new TreeMap&lt;String, Integer&gt;();
		tree.put("张三", 19);
		tree.put("李四", 20);
		tree.put("王五", 21);
		tree.put("赵六", 22);
		tree.put("周七", 23);
		tree.put("张三", 24);
		System.out.println(tree);
		System.out.println("张三".compareTo("李四"));//-2094
	}
}</code></pre> 
<p>自定义元素排序</p> 
<pre><code class="language-java">public class Demo3 {
	public static void main(String[] args) {
		TreeMap&lt;Person, String&gt; hm = new TreeMap&lt;Person, String&gt;(
				new MyComparator());
		hm.put(new Person("jack", 20), "1001");
		hm.put(new Person("rose", 18), "1002");
		hm.put(new Person("lucy", 19), "1003");
		hm.put(new Person("hmm", 17), "1004");
		hm.put(new Person("ll", 25), "1005");
		System.out.println(hm);
		System.out.println(hm.put(new Person("rose", 18), "1006"));

		Set&lt;Entry&lt;Person, String&gt;&gt; entrySet = hm.entrySet();
		Iterator&lt;Entry&lt;Person, String&gt;&gt; it = entrySet.iterator();
		while (it.hasNext()) {
			Entry&lt;Person, String&gt; next = it.next();
			Person key = next.getKey();
			String value = next.getValue();
			System.out.println(key + " = " + value);
		}
	}
}

class MyComparator implements Comparator&lt;Person&gt; {

	@Override
	public int compare(Person p1, Person p2) {
		if (p1.getAge() &gt; p2.getAge()) {
			return -1;
		} else if (p1.getAge() &lt; p2.getAge()) {
			return 1;
		}
		return p1.getName().compareTo(p2.getName());
	}

}

class Person implements Comparable&lt;Person&gt; {
	private String name;
	private int age;

	Person() {

	}

	public Person(String name, int age) {

		this.name = name;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public int hashCode() {

		return this.name.hashCode() + age * 37;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Person) {
			Person p = (Person) obj;
			return this.name.equals(p.name) &amp;&amp; this.age == p.age;
		} else {
			return false;
		}
	}

	@Override
	public String toString() {

		return "Person@name:" + this.name + " age:" + this.age;
	}

	@Override
	public int compareTo(Person p) {

		if (this.age &gt; p.age) {
			return 1;
		} else if (this.age &lt; p.age) {
			return -1;
		}
		return this.name.compareTo(p.name);
	}

}</code></pre> 
<p> </p> 
<p>注意：Set的元素不可重复，Map的键不可重复，如果存入重复元素如何处理</p> 
<p>Set元素重复元素不能存入add<span style="font-family:宋体">方法返回</span><span style="font-family:Courier New">false</span></p> 
<p>Map的重复健将覆盖旧键，将旧值返回。</p> 
<br> 
<p><span style="font-size:14px"><br> </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85c5ada20540e73ed4597cdca210825a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java Set集合的详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e237c87adfa101473d838764bfc8a10b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Shell_Find</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>