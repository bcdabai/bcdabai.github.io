<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringMVC 5.2.9 &#43; MySQL 8.0.25 &#43; jdk 1.8 version 15 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringMVC 5.2.9 &#43; MySQL 8.0.25 &#43; jdk 1.8 version 15" />
<meta property="og:description" content="目录
SpringMVC
1.回顾MVC 架构
2 回顾Servlet
3、初识SpringMVC
4 第一个 SpringMVC 项目
4.1配置版
4.2 注解版
5 SpringMVC 执行原理
6 Controller 配置总结
控制器Controller
实现Controller接口
使用注解@Controller
@RequestMapping
7 Restful 风格
8 结果跳转方式
8.1 ModelAndView
8.2 ServletAPI
8.3 SpringMVC
9 数据处理
9.1 处理提交数据
9.2 数据显示到前端
10 乱码的问题
11 jSON
11.1 什么是Json?
11.2 Controller 返回 JSON 数据
11.2.1 Jackson
11.2.2 fastson
12 整合SSM
12.1 Mybatis层编写
12.2 Spring层
12.3 SpringMVC层
12.4 Controller 和 视图层编写
13 Ajax" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d9a2856602d329c109546ed22f9433f4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-21T14:55:44+08:00" />
<meta property="article:modified_time" content="2021-10-21T14:55:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringMVC 5.2.9 &#43; MySQL 8.0.25 &#43; jdk 1.8 version 15</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="SpringMVC-toc" style="margin-left:0px;"><a href="#SpringMVC" rel="nofollow" title="SpringMVC">SpringMVC</a></p> 
<p id="1.%E5%9B%9E%E9%A1%BEMVC%20%E6%9E%B6%E6%9E%84-toc" style="margin-left:0px;"><a href="#1.%E5%9B%9E%E9%A1%BEMVC%20%E6%9E%B6%E6%9E%84" rel="nofollow" title="1.回顾MVC 架构">1.回顾MVC 架构</a></p> 
<p id="2%20%E5%9B%9E%E9%A1%BEServlet-toc" style="margin-left:0px;"><a href="#2%20%E5%9B%9E%E9%A1%BEServlet" rel="nofollow" title="2 回顾Servlet">2 回顾Servlet</a></p> 
<p id="3%E3%80%81%E5%88%9D%E8%AF%86SpringMVC-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E5%88%9D%E8%AF%86SpringMVC" rel="nofollow" title="3、初识SpringMVC">3、初识SpringMVC</a></p> 
<p id="4%20%E7%AC%AC%E4%B8%80%E4%B8%AA%20SpringMVC%20%E9%A1%B9%E7%9B%AE-toc" style="margin-left:0px;"><a href="#4%20%E7%AC%AC%E4%B8%80%E4%B8%AA%20SpringMVC%20%E9%A1%B9%E7%9B%AE" rel="nofollow" title="4 第一个 SpringMVC 项目">4 第一个 SpringMVC 项目</a></p> 
<p id="4.1%E9%85%8D%E7%BD%AE%E7%89%88-toc" style="margin-left:40px;"><a href="#4.1%E9%85%8D%E7%BD%AE%E7%89%88" rel="nofollow" title="4.1配置版">4.1配置版</a></p> 
<p id="4.2%20%E6%B3%A8%E8%A7%A3%E7%89%88-toc" style="margin-left:40px;"><a href="#4.2%20%E6%B3%A8%E8%A7%A3%E7%89%88" rel="nofollow" title="4.2 注解版">4.2 注解版</a></p> 
<p id="5%20SpringMVC%20%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#5%20SpringMVC%20%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86" rel="nofollow" title="5 SpringMVC 执行原理">5 SpringMVC 执行原理</a></p> 
<p id="6%20Controller%20%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#6%20Controller%20%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93" rel="nofollow" title="6 Controller 配置总结">6 Controller 配置总结</a></p> 
<p id="%E6%8E%A7%E5%88%B6%E5%99%A8Controller-toc" style="margin-left:40px;"><a href="#%E6%8E%A7%E5%88%B6%E5%99%A8Controller" rel="nofollow" title="控制器Controller">控制器Controller</a></p> 
<p id="%E5%AE%9E%E7%8E%B0Controller%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E7%8E%B0Controller%E6%8E%A5%E5%8F%A3" rel="nofollow" title="实现Controller接口">实现Controller接口</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%40Controller-toc" style="margin-left:40px;"><a href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%40Controller" rel="nofollow" title="使用注解@Controller">使用注解@Controller</a></p> 
<p id="%40RequestMapping-toc" style="margin-left:40px;"><a href="#%40RequestMapping" rel="nofollow" title="@RequestMapping">@RequestMapping</a></p> 
<p id="7%20Restful%20%E9%A3%8E%E6%A0%BC-toc" style="margin-left:0px;"><a href="#7%20Restful%20%E9%A3%8E%E6%A0%BC" rel="nofollow" title="7 Restful 风格">7 Restful 风格</a></p> 
<p id="8%20%E7%BB%93%E6%9E%9C%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#8%20%E7%BB%93%E6%9E%9C%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F" rel="nofollow" title="8 结果跳转方式">8 结果跳转方式</a></p> 
<p id="8.1%20ModelAndView-toc" style="margin-left:40px;"><a href="#8.1%20ModelAndView" rel="nofollow" title="8.1 ModelAndView">8.1 ModelAndView</a></p> 
<p id="8.2%20ServletAPI-toc" style="margin-left:40px;"><a href="#8.2%20ServletAPI" rel="nofollow" title="8.2 ServletAPI">8.2 ServletAPI</a></p> 
<p id="8.3%20SpringMVC-toc" style="margin-left:40px;"><a href="#8.3%20SpringMVC" rel="nofollow" title="8.3 SpringMVC">8.3 SpringMVC</a></p> 
<p id="9%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-toc" style="margin-left:0px;"><a href="#9%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86" rel="nofollow" title="9 数据处理">9 数据处理</a></p> 
<p id="9.1%20%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#9.1%20%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE" rel="nofollow" title="9.1 处理提交数据">9.1 处理提交数据</a></p> 
<p id="9.2%20%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%E5%88%B0%E5%89%8D%E7%AB%AF-toc" style="margin-left:40px;"><a href="#9.2%20%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%E5%88%B0%E5%89%8D%E7%AB%AF" rel="nofollow" title="9.2 数据显示到前端">9.2 数据显示到前端</a></p> 
<p id="10%20%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#10%20%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow" title="10 乱码的问题">10 乱码的问题</a></p> 
<p id="11%20jSON-toc" style="margin-left:0px;"><a href="#11%20jSON" rel="nofollow" title="11 jSON">11 jSON</a></p> 
<p id="11.1%20%E4%BB%80%E4%B9%88%E6%98%AFJson%3F-toc" style="margin-left:40px;"><a href="#11.1%20%E4%BB%80%E4%B9%88%E6%98%AFJson%3F" rel="nofollow" title="11.1 什么是Json?">11.1 什么是Json?</a></p> 
<p id="11.2%20Controller%20%E8%BF%94%E5%9B%9E%20JSON%20%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#11.2%20Controller%20%E8%BF%94%E5%9B%9E%20JSON%20%E6%95%B0%E6%8D%AE" rel="nofollow" title="11.2 Controller 返回 JSON 数据">11.2 Controller 返回 JSON 数据</a></p> 
<p id="11.2.1%20Jackson-toc" style="margin-left:80px;"><a href="#11.2.1%20Jackson" rel="nofollow" title="11.2.1 Jackson">11.2.1 Jackson</a></p> 
<p id="11.2.2%20fastson-toc" style="margin-left:80px;"><a href="#11.2.2%20fastson" rel="nofollow" title="11.2.2 fastson">11.2.2 fastson</a></p> 
<p id="12%20%E6%95%B4%E5%90%88SSM-toc" style="margin-left:0px;"><a href="#12%20%E6%95%B4%E5%90%88SSM" rel="nofollow" title="12 整合SSM">12 整合SSM</a></p> 
<p id="12.1%20Mybatis%E5%B1%82%E7%BC%96%E5%86%99-toc" style="margin-left:40px;"><a href="#12.1%20Mybatis%E5%B1%82%E7%BC%96%E5%86%99" rel="nofollow" title="12.1 Mybatis层编写">12.1 Mybatis层编写</a></p> 
<p id="12.2%20Spring%E5%B1%82-toc" style="margin-left:40px;"><a href="#12.2%20Spring%E5%B1%82" rel="nofollow" title="12.2 Spring层">12.2 Spring层</a></p> 
<p id="12.3%20SpringMVC%E5%B1%82-toc" style="margin-left:40px;"><a href="#12.3%20SpringMVC%E5%B1%82" rel="nofollow" title="12.3 SpringMVC层">12.3 SpringMVC层</a></p> 
<p id="12.4%20Controller%20%E5%92%8C%20%E8%A7%86%E5%9B%BE%E5%B1%82%E7%BC%96%E5%86%99-toc" style="margin-left:40px;"><a href="#12.4%20Controller%20%E5%92%8C%20%E8%A7%86%E5%9B%BE%E5%B1%82%E7%BC%96%E5%86%99" rel="nofollow" title="12.4 Controller 和 视图层编写">12.4 Controller 和 视图层编写</a></p> 
<p id="13%20Ajax-toc" style="margin-left:0px;"><a href="#13%20Ajax" rel="nofollow" title="13 Ajax">13 Ajax</a></p> 
<p id="13.1%20%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#13.1%20%E7%AE%80%E4%BB%8B" rel="nofollow" title="13.1 简介">13.1 简介</a></p> 
<p id="13.2%E4%BC%AA%E9%80%A0Ajax-toc" style="margin-left:40px;"><a href="#13.2%E4%BC%AA%E9%80%A0Ajax" rel="nofollow" title="13.2伪造Ajax">13.2伪造Ajax</a></p> 
<p id="13.3%20jQuery.ajax-toc" style="margin-left:40px;"><a href="#13.3%20jQuery.ajax" rel="nofollow" title="13.3 jQuery.ajax">13.3 jQuery.ajax</a></p> 
<p id="14%20%E6%8B%A6%E6%88%AA%E5%99%A8-toc" style="margin-left:0px;"><a href="#14%20%E6%8B%A6%E6%88%AA%E5%99%A8" rel="nofollow" title="14 拦截器">14 拦截器</a></p> 
<p id="14.1%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8-toc" style="margin-left:40px;"><a href="#14.1%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8" rel="nofollow" title="14.1 自定义拦截器">14.1 自定义拦截器</a></p> 
<p id="14.2%20%E6%A1%88%E4%BE%8B-toc" style="margin-left:40px;"><a href="#14.2%20%E6%A1%88%E4%BE%8B" rel="nofollow" title="14.2 案例">14.2 案例</a></p> 
<p id="15%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD-toc" style="margin-left:0px;"><a href="#15%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD" rel="nofollow" title="15 文件上传和下载">15 文件上传和下载</a></p> 
<p id="15.1%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-toc" style="margin-left:40px;"><a href="#15.1%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0" rel="nofollow" title="15.1文件上传">15.1文件上传</a></p> 
<p id="15.2%20%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD-toc" style="margin-left:40px;"><a href="#15.2%20%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD" rel="nofollow" title="15.2 文件下载">15.2 文件下载</a></p> 
<hr id="hr-toc"> 
<h2 id="SpringMVC"><strong>SpringMVC</strong></h2> 
<p>参考文章;<a href="https://www.kuangstudy.com/bbs/1432248418843000834" rel="nofollow" title="Springmvc学习笔记-KuangStudy-文章">Springmvc学习笔记-KuangStudy-文章</a></p> 
<p><a href="https://blog.csdn.net/qq_33369905/article/details/106647313" title="狂神说SpringMVC01：什么是SpringMVC_狂神说-CSDN博客">狂神说SpringMVC01：什么是SpringMVC_狂神说-CSDN博客</a></p> 
<p>视频：<a href="https://www.bilibili.com/video/BV1aE41167Tu?p=30&amp;spm_id_from=pageDriver" rel="nofollow" title="【狂神说Java】SpringMVC最新教程IDEA版通俗易懂_哔哩哔哩_bilibili">【狂神说Java】SpringMVC最新教程IDEA版通俗易懂_哔哩哔哩_bilibili</a></p> 
<p>github 练习： <a href="https://github.com/abbywei123/springmvc-2021" title="https://github.com/abbywei123/springmvc-2021">https://github.com/abbywei123/springmvc-2021</a></p> 
<h2 id="1.%E5%9B%9E%E9%A1%BEMVC%20%E6%9E%B6%E6%9E%84">1.回顾MVC 架构</h2> 
<h2 id="2%20%E5%9B%9E%E9%A1%BEServlet">2 回顾Servlet</h2> 
<p>1.新建一个maven 工程当作父工程 pom 依赖</p> 
<pre><code class="language-XML">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;version&gt;2.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre> 
<pre></pre> 
<p>2、建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！</p> 
<p><img alt="" height="220" src="https://images2.imgbox.com/d1/45/XEYWaPUo_o.png" width="435"></p> 
<p></p> 
<p></p> 
<p>3、导入servlet 和 jsp 的 jar 依赖</p> 
<pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
    &lt;version&gt;2.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>4.创建servlet 层 请求类</p> 
<pre><code class="language-java">package com.yw.servlet;
​
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
​
public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       //获取前端参数
        //取得参数
        String method = req.getParameter("method");
        if (method.equals("add")){
            req.getSession().setAttribute("msg","执行了add方法");
        }
        if (method.equals("delete")){
            req.getSession().setAttribute("msg","执行了delete方法");
        }
​
        //调用业务层
​
        //是否重定向
        req.getRequestDispatcher("/WEB-INF/jsp/hello.jsp").forward(req,resp);
    }
​
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}</code></pre> 
<pre>​</pre> 
<p>5.部署tomcat</p> 
<p>add configurations</p> 
<p></p> 
<p><img alt="" height="503" src="https://images2.imgbox.com/a0/53/tcpmF1XP_o.png" width="802"></p> 
<p><img alt="" height="518" src="https://images2.imgbox.com/62/85/oDA3zEbh_o.png" width="796"></p> 
<p></p> 
<p></p> 
<p>6.启动tocat</p> 
<p>访问项目<a href="http://localhost:8080/hello?method=add" rel="nofollow" title="http://localhost:8080/hello?method=add">http://localhost:8080/hello?method=add</a></p> 
<p><img alt="" height="78" src="https://images2.imgbox.com/db/79/vNbSTCEa_o.png" width="783"></p> 
<p></p> 
<p></p> 
<p><strong>MVC框架要做哪些事情</strong></p> 
<p>将url映射到java类或java类的方法 .</p> 
<p>封装用户提交的数据 .</p> 
<p>处理请求--调用相关的业务处理--封装响应数据 .</p> 
<p>将响应的数据进行渲染 . jsp / html 等表示层数据 .</p> 
<p>说明：</p> 
<p>常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等....</p> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="3%E3%80%81%E5%88%9D%E8%AF%86SpringMVC">3、初识SpringMVC</h2> 
<p>官方文档</p> 
<p><a href="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web" rel="nofollow" title="Web on Servlet Stack">Web on Servlet Stack</a></p> 
<p></p> 
<p><strong>我们为什么要学习SpringMVC呢?</strong></p> 
<p>Spring MVC的特点：</p> 
<ol><li> <p>轻量级，简单易学</p> </li><li> <p>高效 , 基于请求响应的MVC框架</p> </li><li> <p>与Spring兼容性好，无缝结合</p> </li><li> <p>约定优于配置</p> </li><li> <p>功能强大：RESTful、数据验证、格式化、本地化、主题等</p> </li><li> <p>简洁灵活</p> </li></ol> 
<p></p> 
<p></p> 
<p>中心控制器</p> 
<p><strong>Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。</strong> DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；</p> 
<p></p> 
<h2 id="4%20%E7%AC%AC%E4%B8%80%E4%B8%AA%20SpringMVC%20%E9%A1%B9%E7%9B%AE">4 第一个 SpringMVC 项目</h2> 
<h3 id="4.1%E9%85%8D%E7%BD%AE%E7%89%88">4.1配置版</h3> 
<p>1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！</p> 
<p>2、确定导入了SpringMVC 的依赖！</p> 
<p>3、配置web.xml ， 注册DispatcherServlet</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0"&gt;
​
    &lt;!--1.注册DispatcherServlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!--启动级别-1--&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;   &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;
    &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
​
&lt;/web-app&gt;</code></pre> 
<p>4、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml</p> 
<p>说明，这里的名称要求是按照官方来的</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
​
&lt;/beans&gt;</code></pre> 
<p>5、添加 处理映射器</p> 
<pre><code class="language-XML">&lt;!--    添加 处理映射器--&gt;
    &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt;</code></pre> 
<p>6、添加 处理器适配器</p> 
<pre><code class="language-XML">&lt;!--    添加 处理器适配器--&gt;
    &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/&gt;</code></pre> 
<p>7、添加 视图解析器</p> 
<pre><code class="language-XML"> &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;
    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="InternalResourceViewResolver"&gt;
        &lt;!--前缀--&gt;
        &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
        &lt;!--后缀--&gt;
        &lt;property name="suffix" value=".jsp"/&gt;
    &lt;/bean&gt;</code></pre> 
<p>8、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；</p> 
<pre><code class="language-java">package com.yw.controller;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

//注意：这里我们先导入Controller接口
public class HelloController implements Controller {


    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        //ModelAndView 模型和视图
        ModelAndView mv = new ModelAndView();


        //封装对象，放在ModelAndView中。Model
        mv.addObject("msg", "HelloSpringMVC!");
        //封装要跳转的视图，放在ModelAndView中
        mv.setViewName("hello"); //: /WEB-INF/jsp/hello.jsp
        return mv;
    }
}
</code></pre> 
<p>9、将自己的类交给SpringIOC容器，注册bean</p> 
<pre><code class="language-XML"> &lt;!--Handler--&gt;
    &lt;bean id="/hello" class="com.yw.controller.HelloController"/&gt;</code></pre> 
<p>10、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面；</p> 
<pre><code class="language-html">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
${msg}
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>11、配置Tomcat 启动测试！</p> 
<p><img alt="" height="105" src="https://images2.imgbox.com/6c/90/jz5uqCuX_o.png" width="596"></p> 
<p></p> 
<p></p> 
<p><strong>可能遇到的问题：访问出现404，排查步骤：</strong></p> 
<ol><li> <p>查看控制台输出，看一下是不是缺少了什么jar包。</p> </li><li> <p>如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！</p> </li><li> <p>重启Tomcat 即可解决！</p> </li></ol> 
<p>file-project Structure</p> 
<p><img alt="" height="558" src="https://images2.imgbox.com/69/fd/OBqQLquB_o.png" width="877"></p> 
<p></p> 
<p></p> 
<h3 id="4.2%20%E6%B3%A8%E8%A7%A3%E7%89%88">4.2 注解版</h3> 
<p><strong>1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！</strong></p> 
<p>2、由于Maven可能存在资源过滤的问题，我们将配置完善</p> 
<pre><code class="language-XML">&lt;build&gt;
   &lt;resources&gt;
       &lt;resource&gt;
           &lt;directory&gt;src/main/java&lt;/directory&gt;
           &lt;includes&gt;
               &lt;include&gt;**/*.properties&lt;/include&gt;
               &lt;include&gt;**/*.xml&lt;/include&gt;
           &lt;/includes&gt;
           &lt;filtering&gt;false&lt;/filtering&gt;
       &lt;/resource&gt;
       &lt;resource&gt;
           &lt;directory&gt;src/main/resources&lt;/directory&gt;
           &lt;includes&gt;
               &lt;include&gt;**/*.properties&lt;/include&gt;
               &lt;include&gt;**/*.xml&lt;/include&gt;
           &lt;/includes&gt;
           &lt;filtering&gt;false&lt;/filtering&gt;
       &lt;/resource&gt;
   &lt;/resources&gt;
&lt;/build&gt;</code></pre> 
<p>3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC（目前我是的是version 5.2.19）、servlet , JSTL等。我们在父依赖中已经引入了！</p> 
<p><strong>4、配置web.xml</strong></p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
        version="4.0"&gt;
 
 
   &lt;!--1.注册servlet--&gt;
   &lt;servlet&gt;
       &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
       &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
           &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
       &lt;/init-param&gt;
       &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
       &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
   &lt;/servlet&gt;
 
 
   &lt;!--所有请求都会被springmvc拦截 --&gt;
   &lt;servlet-mapping&gt;
       &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
       &lt;url-pattern&gt;/&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
 
 
&lt;/web-app&gt;</code></pre> 
<ul><li> <p>注意web.xml版本问题，要最新版！</p> </li><li> <p>注册DispatcherServlet</p> </li><li> <p>关联SpringMVC的配置文件</p> </li><li> <p>启动级别为1</p> </li><li> <p>映射路径为 / 【不要用/*，会404】</p> </li></ul> 
<p><strong>5、添加Spring MVC配置文件</strong></p> 
<p>在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下：</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:context="http://www.springframework.org/schema/context"
      xmlns:mvc="http://www.springframework.org/schema/mvc"
      xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;
 
 
   &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;
   &lt;context:component-scan base-package="com.kuang.controller"/&gt;
   &lt;!-- 让Spring MVC不处理静态资源 --&gt;
   &lt;mvc:default-servlet-handler /&gt;
   &lt;!--
   支持mvc注解驱动
       在spring中一般采用@RequestMapping注解来完成映射关系
       要想使@RequestMapping注解生效
       必须向上下文中注册DefaultAnnotationHandlerMapping
       和一个AnnotationMethodHandlerAdapter实例
       这两个实例分别在类级别和方法级别处理。
       而annotation-driven配置帮助我们自动完成上述两个实例的注入。
    --&gt;
   &lt;mvc:annotation-driven /&gt;
 
 
   &lt;!-- 视图解析器 --&gt;
   &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
         id="internalResourceViewResolver"&gt;
       &lt;!-- 前缀 --&gt;
       &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;
       &lt;!-- 后缀 --&gt;
       &lt;property name="suffix" value=".jsp" /&gt;
   &lt;/bean&gt;
 
 
&lt;/beans&gt;</code></pre> 
<p>在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。</p> 
<ul><li> <p>让IOC的注解生效</p> </li><li> <p>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 .....</p> </li><li> <p>MVC的注解驱动</p> </li><li> <p>配置视图解析器</p> </li></ul> 
<p><strong>6、创建Controller</strong></p> 
<p>编写一个Java控制类：com.yw.controller.HelloController , 注意编码规范</p> 
<pre><code class="language-java">package com.yw.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {

    @RequestMapping("h1")
    public String hello(Model model){
        //封装数据
        model.addAttribute("msg","hello,SpringMvc!");
        return "hello"; //会被视图解析器处理
    }
}</code></pre> 
<p>@Controller是为了让Spring IOC容器初始化时自动扫描到；</p> 
<p>@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello；</p> 
<p>方法中声明Model类型的参数是为了把Action中的数据带到视图中；</p> 
<p>方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。</p> 
<p>7、<strong>创建视图层</strong></p> 
<p>在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；</p> 
<p>可以通过EL表示取出Model中存放的值，或者对象；</p> 
<pre><code class="language-html">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;SpringMVC&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
${msg}
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p><strong>8、配置Tomcat运行</strong></p> 
<p>访问地址：<a href="http://localhost:8080/h1" rel="nofollow" title="http://localhost:8080/h1">http://localhost:8080/h1</a></p> 
<h2 id="5%20SpringMVC%20%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86">5 SpringMVC 执行原理</h2> 
<p>简要分析执行流程</p> 
<ol><li> <p>DispatcherServlet 表示前置控制器，是整个SpringMVC的控制中心，用户发出请求，DispatcherServlet接收请求并拦截请求</p> 
  <ul><li> <p>我们假设请求的url为：<a href="http://localhost:8080/SpringMVC/hello" rel="nofollow" title="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></p> </li><li> <p>如上url拆分三部分：</p> </li><li> <p><a href="http://localhost:8080" rel="nofollow" title="http://localhost:8080">http://localhost:8080</a>服务器域名</p> </li><li> <p>SpringMVC部署在服务器上的web站点</p> </li><li> <p>hello表示控制器</p> </li><li> <p>通过分析，如上url表示为：请求位于<a href="http://localhost:8080" rel="nofollow" title="http://localhost:8080">http://localhost:8080</a>上pringMVC站点的hello控制器。</p> </li></ul></li><li> <p>HandlerMapping为处理映射，DispatcherServlet 调用HandlerMapping，HandlerMapping根据url查找Handler.</p> </li><li> <p>HandlerExcution 表示具体的Handler，其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</p> </li><li> <p>HandlerExcution 将解析后的信息传递给DispatcherServlet ，如解析控制器映射等。</p> </li><li> <p>HandlerAdapter 表示处理器适配器，其按照特定的规则去执行Handler</p> </li><li> <p>Handler 让具体的Controller去执行</p> </li><li> <p>Controller将具体的执行信息返回给HandlerAdapetr，如ModelAndView</p> </li><li> <p>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet</p> </li><li> <p>DispatcherServlet 调用视图解析器类解析HandlerAdapter传递的逻辑视图名</p> </li><li> <p>视图解析器将解析的逻辑视图名传给DispatcherServlet</p> </li><li> <p>DispatcherServlet 根据视图解析器解析的视图结果，调用具体的视图</p> </li><li> <p>最终将视图呈现给用户</p> </li></ol> 
<p></p> 
<h2 id="6%20Controller%20%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93">6 Controller 配置总结</h2> 
<p>具体详细可参考：<a href="https://blog.csdn.net/qq_33369905/article/details/106647289?spm=1001.2014.3001.5501" title="狂神说SpringMVC03：RestFul和控制器_狂神说-CSDN博客">狂神说SpringMVC03：RestFul和控制器_狂神说-CSDN博客</a></p> 
<h3 id="%E6%8E%A7%E5%88%B6%E5%99%A8Controller">控制器Controller</h3> 
<ul><li> <p>控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</p> </li><li> <p>控制器负责解析用户的请求并将其转换为一个模型。</p> </li><li> <p>在Spring MVC中一个控制器类可以包含多个方法</p> </li><li> <p>在Spring MVC中，对于Controller的配置方式有很多种</p> </li></ul> 
<h3 id="%E5%AE%9E%E7%8E%B0Controller%E6%8E%A5%E5%8F%A3">实现Controller接口</h3> 
<p>Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；</p> 
<pre><code class="language-java">//实现该接口的类获得控制器功能
public interface Controller {
    //处理请求且返回一个模型与视图对象
    ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;
}</code></pre> 
<ul><li> <p>缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦；</p> </li></ul> 
<h3 id="%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%40Controller">使用注解@Controller</h3> 
<p>@Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；</p> 
<p>Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</p> 
<pre>&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
&lt;context:component-scan base-package="com.yw.controller"/&gt;</pre> 
<p><strong>可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。</strong></p> 
<h3 id="%40RequestMapping">@RequestMapping</h3> 
<ul><li> <p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p> </li><li> <p>只注解在方法上面</p> </li></ul> 
<p></p> 
<h2 id="7%20Restful%20%E9%A3%8E%E6%A0%BC">7 Restful 风格</h2> 
<p>概念</p> 
<p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p> 
<p>功能</p> 
<p>资源：互联网所有的事物都可以被抽象为资源</p> 
<p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p> 
<p>分别对应 添加、 删除、修改、查询。</p> 
<p>传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get</p> 
<p><a href="http://127.0.0.1/item/queryItem.action?id=1" rel="nofollow" title="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p> 
<p><a href="http://127.0.0.1/item/saveItem.action" rel="nofollow" title="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p> 
<p><a href="http://127.0.0.1/item/updateItem.action" rel="nofollow" title="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p> 
<p><a href="http://127.0.0.1/item/deleteItem.action?id=1" rel="nofollow" title="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p> 
<p>使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p> 
<p><a href="http://127.0.0.1/item/1" rel="nofollow" title="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</p> 
<p><a href="http://127.0.0.1/item" rel="nofollow" title="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</p> 
<p><a href="http://127.0.0.1/item" rel="nofollow" title="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</p> 
<p><a href="http://127.0.0.1/item/1" rel="nofollow" title="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</p> 
<p></p> 
<p></p> 
<p>学习测试</p> 
<p>在新建一个类 RestFulController</p> 
<pre><code class="language-java">@Controller
public class RestFulController {
}</code></pre> 
<p>在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。</p> 
<pre><code class="language-java">package com.yw.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class RestFulController {

    //http://localhost:8080/add?a=1&amp;b=2
    //restful:http://localhost:8080/add/1/2
    @RequestMapping("/add/{a}/{b}")
    public String test1(@PathVariable int a, @PathVariable int b, Model model){
        int res=a+b;
        model.addAttribute("msg","结果为："+res);
        return "hello";
    }
}</code></pre> 
<ol><li> <p>思考：使用路径变量的好处？</p> </li></ol> 
<ul><li> <p>使路径变得更加简洁；</p> </li><li> <p>获得参数更加方便，框架会自动进行类型转换。</p> </li><li> <p>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。</p> </li></ul> 
<p></p> 
<p><strong>使用method属性指定请求类型</strong></p> 
<p>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等</p> 
<p>我们来测试一下：</p> 
<pre><code class="language-java">  @RequestMapping(value = "/add/{a}/{b}",method = RequestMethod.GET)
    public String test1(@PathVariable int a, @PathVariable int b, Model model){
        int res=a+b;
        model.addAttribute("msg","结果为："+res);
        return "hello";
    }</code></pre> 
<p><strong>method = RequestMethod.GET</strong></p> 
<p>小结：</p> 
<p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p> 
<p>所有的地址栏请求默认都会是 HTTP GET 类型的。</p> 
<p>方法级别的注解变体有如下几个：组合注解</p> 
<pre><code class="language-java">@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping</code></pre> 
<p>@GetMapping 是一个组合注解，平时使用的会比较多！</p> 
<p>它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。</p> 
<h2 id="8%20%E7%BB%93%E6%9E%9C%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F">8 结果跳转方式</h2> 
<p>参考 <a href="https://blog.csdn.net/qq_33369905/article/details/106647289?spm=1001.2014.3001.5501" title="狂神说SpringMVC03：RestFul和控制器_狂神说-CSDN博客">狂神说SpringMVC03：RestFul和控制器_狂神说-CSDN博客</a></p> 
<h3 id="8.1%20ModelAndView">8.1 ModelAndView</h3> 
<p>设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面</p> 
<h3 id="8.2%20ServletAPI">8.2 ServletAPI</h3> 
<p>通过设置ServletAPI , 不需要视图解析器 .</p> 
<p>1、通过HttpServletResponse进行输出</p> 
<p>2、通过HttpServletResponse实现重定向</p> 
<p>3、通过HttpServletResponse实现转发</p> 
<pre><code class="language-java">@Controller
public class ResultGo {
 
    @RequestMapping("/result/t1")
    public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
        rsp.getWriter().println("Hello,Spring BY servlet API");
    }
 
    @RequestMapping("/result/t2")
    public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
        rsp.sendRedirect("/index.jsp");
    }
 
    @RequestMapping("/result/t3")
    public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception {
        //转发
        req.setAttribute("msg","/result/t3");
        req.getRequestDispatcher("/WEB-INF/jsp/test.jsp").forward(req,rsp);
    }
 
}</code></pre> 
<h3 id="8.3%20SpringMVC">8.3 SpringMVC</h3> 
<p><strong>通过SpringMVC来实现转发和重定向 - 无需视图解析器；</strong></p> 
<p>测试前，需要将视图解析器注释掉</p> 
<pre><code class="language-java">@Controller
public class HelloController {

    //转发
    @RequestMapping("h1")
    public String hello(Model model){
        //封装数据
        model.addAttribute("msg","hello,SpringMvc!");
        return "/WEB-INF/jsp/hello.jsp"; //会被视图解析器处理
    }

    //重定向
    @RequestMapping("h2")
    public String hello2(Model model){
        //封装数据
        model.addAttribute("msg","hello,SpringMvc!");
        return "redirect:/index.jsp"; //会被视图解析器处理
    }
}</code></pre> 
<p><strong>通过SpringMVC来实现转发和重定向 - 有视图解析器；</strong></p> 
<p>重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.</p> 
<p>可以重定向到另外一个请求实现 .</p> 
<pre><code class="language-java">@Controller
public class ResultSpringMVC2 {
    @RequestMapping("/rsm2/t1")
    public String test1(){
        //转发
        return "test";
    }
 
    @RequestMapping("/rsm2/t2")
    public String test2(){
        //重定向
        return "redirect:/index.jsp";
        //return "redirect:hello.do"; //hello.do为另一个请求/
    }
 
}</code></pre> 
<h2 id="9%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">9 数据处理</h2> 
<p>参考 ： <a href="https://blog.csdn.net/qq_33369905/article/details/106647331?spm=1001.2014.3001.5501" title="狂神说SpringMVC04：数据处理及跳转_狂神说-CSDN博客">狂神说SpringMVC04：数据处理及跳转_狂神说-CSDN博客</a></p> 
<h3 id="9.1%20%E5%A4%84%E7%90%86%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE">9.1 处理提交数据</h3> 
<p><strong>1、提交的域名称和处理方法的参数名一致</strong></p> 
<p>提交数据 : <a href="http://localhost:8080/hello?name=kuangshen" rel="nofollow" title="http://localhost:8080/hello?name=kuangshen">http://localhost:8080/hello?name=kuangshen</a></p> 
<p>处理方法 :</p> 
<pre><code class="language-java">@Controller
@RequestMapping("/user")
public class UserController {
    //http://localhost:8080/user/t1?name=yw
    @GetMapping("/t1")
    public String test1(@RequestParam("name") String name, Model model){
        model.addAttribute("msg",name);
        return "test";
    }
}</code></pre> 
<p>后台输出 : yw</p> 
<p></p> 
<p>2、提交的域名称和处理方法的参数名不一致</p> 
<p>提交数据 : <a href="http://localhost:8080/hello?username=kuangshen" rel="nofollow" title="http://localhost:8080/hello?username=kuangshen">http://localhost:8080/hello?username=kuangshen</a></p> 
<p>处理方法 :</p> 
<pre><code class="language-java">//@RequestParam("username") : username提交的域的名称 .
@RequestMapping("/hello")
public String hello(@RequestParam("username") String name){
    System.out.println(name);
    return "hello";
}</code></pre> 
<p>后台输出 : kuangshen</p> 
<p>3、提交的是一个对象</p> 
<p>要求提交的表单域和对象的属性名一致 , 参数使用对象即可</p> 
<p>1、实体类</p> 
<pre><code class="language-java">public class User {
    private int id;
    private String name;
    private int age;
    //构造
    //get/set
    //tostring()
}</code></pre> 
<p>2、提交数据 : <a href="http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15" rel="nofollow" title="http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15">http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15</a></p> 
<p>3、处理方法 :</p> 
<pre><code class="language-java">@RequestMapping("/user")
public String user(User user){
    System.out.println(user);
    return "hello";
}</code></pre> 
<p>后台输出 : User { id=1, name='kuangshen', age=15 }</p> 
<p>说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。</p> 
<h3 id="9.2%20%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%E5%88%B0%E5%89%8D%E7%AB%AF">9.2 数据显示到前端</h3> 
<p><strong>第一种 : 通过ModelAndView</strong></p> 
<p>我们前面一直都是如此 . 就不过多解释</p> 
<pre><code class="language-java">public class ControllerTest1 implements Controller {
 
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
        //返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject("msg","ControllerTest1");
        mv.setViewName("test");
        return mv;
    }
}</code></pre> 
<p><strong>第二种 : 通过ModelMap</strong></p> 
<p>ModelMap</p> 
<pre><code class="language-java">@RequestMapping("/hello")
public String hello(@RequestParam("username") String name, ModelMap model){
    //封装要显示到视图中的数据
    //相当于req.setAttribute("name",name);
    model.addAttribute("name",name);
    System.out.println(name);
    return "hello";
}</code></pre> 
<p><strong>第三种 : 通过Model</strong></p> 
<p>Model</p> 
<pre><code class="language-java">@RequestMapping("/ct2/hello")
public String hello(@RequestParam("username") String name, Model model){
    //封装要显示到视图中的数据
    //相当于req.setAttribute("name",name);
    model.addAttribute("msg",name);
    System.out.println(name);
    return "test";
}</code></pre> 
<p><strong>对比</strong></p> 
<p>就对于新手而言简单来说使用区别就是：</p> 
<pre>Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；
 
ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；
 
ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</pre> 
<h2 id="10%20%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98">10 乱码的问题</h2> 
<p>测试步骤：</p> 
<p>1、我们可以在首页编写一个提交的表单</p> 
<pre><code class="language-html">&lt;form action="/e/t" method="post"&gt;
  &lt;input type="text" name="name"&gt;
  &lt;input type="submit"&gt;
&lt;/form&gt;</code></pre> 
<p>2、后台编写对应的处理类</p> 
<pre><code class="language-java">@Controller
public class Encoding {
    @RequestMapping("/e/t")
    public String test(Model model,String name){
        model.addAttribute("msg",name); //获取表单提交的值
        return "test"; //跳转到test页面显示输入的值
    }
}</code></pre> 
<p>3、输入中文测试，发现乱码</p> 
<p>访问 <a href="http://localhost:8080/form.jsp" rel="nofollow" title="http://localhost:8080/form.jsp">http://localhost:8080/form.jsp</a></p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/71/9a/9M1raQDc_o.png" width="644"></p> 
<p></p> 
<p></p> 
<p>以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .</p> 
<p>修改了xml文件需要重启服务器！</p> 
<pre><code class="language-XML">&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre> 
<p>但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 .</p> 
<p>处理方法 :</p> 
<p>1、修改tomcat配置文件 ：设置编码！</p> 
<pre><code class="language-XML">&lt;Connector URIEncoding="utf-8" port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" /&gt;</code></pre> 
<p>2、自定义过滤器</p> 
<pre><code class="language-java">package com.kuang.filter;
 
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Map;
 
/**
 * 解决get和post请求 全部乱码的过滤器
 */
public class GenericEncodingFilter implements Filter {
 
    @Override
    public void destroy() {
    }
 
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        //处理response的字符编码
        HttpServletResponse myResponse=(HttpServletResponse) response;
        myResponse.setContentType("text/html;charset=UTF-8");
 
        // 转型为与协议相关对象
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        // 对request包装增强
        HttpServletRequest myrequest = new MyRequest(httpServletRequest);
        chain.doFilter(myrequest, response);
    }
 
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }
 
}
 
//自定义request对象，HttpServletRequest的包装类
class MyRequest extends HttpServletRequestWrapper {
 
    private HttpServletRequest request;
    //是否编码的标记
    private boolean hasEncode;
    //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰
    public MyRequest(HttpServletRequest request) {
        super(request);// super必须写
        this.request = request;
    }
 
    // 对需要增强方法 进行覆盖
    @Override
    public Map getParameterMap() {
        // 先获得请求方式
        String method = request.getMethod();
        if (method.equalsIgnoreCase("post")) {
            // post请求
            try {
                // 处理post乱码
                request.setCharacterEncoding("utf-8");
                return request.getParameterMap();
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        } else if (method.equalsIgnoreCase("get")) {
            // get请求
            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();
            if (!hasEncode) { // 确保get手动编码逻辑只运行一次
                for (String parameterName : parameterMap.keySet()) {
                    String[] values = parameterMap.get(parameterName);
                    if (values != null) {
                        for (int i = 0; i &lt; values.length; i++) {
                            try {
                                // 处理get乱码
                                values[i] = new String(values[i]
                                        .getBytes("ISO-8859-1"), "utf-8");
                            } catch (UnsupportedEncodingException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }
                hasEncode = true;
            }
            return parameterMap;
        }
        return super.getParameterMap();
    }
 
    //取一个值
    @Override
    public String getParameter(String name) {
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        if (values == null) {
            return null;
        }
        return values[0]; // 取回参数的第一个值
    }
 
    //取所有值
    @Override
    public String[] getParameterValues(String name) {
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        return values;
    }
}</code></pre> 
<p>这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！</p> 
<p><strong>然后在web.xml中配置这个过滤器即可！</strong></p> 
<p>乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！</p> 
<p></p> 
<h2 id="11%20jSON">11 jSON</h2> 
<p>参考： <a href="https://blog.csdn.net/qq_33369905/article/details/106647323?spm=1001.2014.3001.5501" title="狂神说SpringMVC06：Json交互处理_狂神说-CSDN博客_狂神说json">狂神说SpringMVC06：Json交互处理_狂神说-CSDN博客_狂神说json</a></p> 
<h3 id="11.1%20%E4%BB%80%E4%B9%88%E6%98%AFJson%3F">11.1 什么是Json?</h3> 
<ul><li> <p>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。</p> </li></ul> 
<ul><li> <p>采用完全独立于编程语言的文本格式来存储和表示数据。</p> </li></ul> 
<ul><li> <p>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。</p> </li></ul> 
<ul><li> <p>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p> </li></ul> 
<p>在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p> 
<ul><li> <p>对象表示为键值对，数据由逗号分隔</p> </li></ul> 
<ul><li> <p>花括号保存对象</p> </li></ul> 
<ul><li> <p>方括号保存数组</p> </li></ul> 
<p>JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 "" 包裹，使用冒号 : 分隔，然后紧接着值：</p> 
<pre><code class="language-java">{"name": "QinJiang"}
{"age": "3"}
{"sex": "男"}</code></pre> 
<p>很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：</p> 
<p>JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</p> 
<pre><code class="language-java">var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的
var json = '{"a": "Hello", "b": "World"}'; //这是一个 JSON 字符串，本质是一个字符串</code></pre> 
<p><strong>JSON 和 JavaScript 对象互转</strong></p> 
<p>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：</p> 
<pre><code class="language-java">var obj = JSON.parse('{"a": "Hello", "b": "World"}');
//结果是 {a: 'Hello', b: 'World'}</code></pre> 
<p>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：</p> 
<pre><code class="language-java">var json = JSON.stringify({a: 'Hello', b: 'World'});
//结果是 '{"a": "Hello", "b": "World"}'</code></pre> 
<h3 id="11.2%20Controller%20%E8%BF%94%E5%9B%9E%20JSON%20%E6%95%B0%E6%8D%AE">11.2 Controller 返回 JSON 数据</h3> 
<h4 id="11.2.1%20Jackson">11.2.1 Jackson</h4> 
<p>使用它需要导入它的jar包；</p> 
<pre><code class="language-XML">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.13.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>配置SpringMVC需要的配置</p> 
<p>web.xml</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0"&gt;
 
    &lt;!--1.注册servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;!--所有请求都会被springmvc拦截 --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
springmvc-servlet.xml

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;
 
    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package="com.kuang.controller"/&gt;
 
    &lt;!-- 视图解析器 --&gt;
    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
          id="internalResourceViewResolver"&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name="suffix" value=".jsp" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre> 
<p>我们随便编写一个User的实体类，然后我们去编写我们的测试Controller；</p> 
<pre><code class="language-java">package com.kuang.pojo;
 
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
 
//需要导入lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
 
    private String name;
    private int age;
    private String sex;
    
}</code></pre> 
<p>这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法</p> 
<p>编写一个Controller；</p> 
<pre><code class="language-java">@Controller
public class UserController {
 
    @RequestMapping("/json1")
    @ResponseBody
    public String json1() throws JsonProcessingException {
        //创建一个jackson的对象映射器，用来解析数据
        ObjectMapper mapper = new ObjectMapper();
        //创建一个对象
        User user = new User("秦疆1号", 3, "男");
        //将我们的对象解析成为json格式
        String str = mapper.writeValueAsString(user);
        //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便
        return str;
    }
 
}</code></pre> 
<p>配置Tomcat ， 启动测试一下！</p> 
<p><a href="http://localhost:8080/json1" rel="nofollow" title="http://localhost:8080/json1">http://localhost:8080/json1</a></p> 
<p>在没有使用ObjectMapper 时</p> 
<p><img alt="" height="121" src="https://images2.imgbox.com/27/9a/OPZchTU1_o.png" width="525"></p> 
<p></p> 
<p></p> 
<p>使用了ObjectMapper对象，将对象输出为了json格式</p> 
<p><img alt="" height="110" src="https://images2.imgbox.com/90/a2/MwYGlO9v_o.png" width="445"></p> 
<p></p> 
<p></p> 
<p>发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型；</p> 
<p>通过@RequestMaping的produces属性来实现，修改下代码</p> 
<pre><code class="language-java">//produces:指定响应体返回类型和编码
@RequestMapping(value = "/json1",produces = "application/json;charset=utf-8")</code></pre> 
<p></p> 
<p>【注意：使用json记得处理乱码问题】</p> 
<p><strong>代码优化</strong></p> 
<p><strong>乱码统一解决</strong></p> 
<p>上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！</p> 
<p>我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！</p> 
<pre><code class="language-XML">&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults="true"&gt;
        &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt;
            &lt;constructor-arg value="UTF-8"/&gt;
        &lt;/bean&gt;
        &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt;
            &lt;property name="objectMapper"&gt;
                &lt;bean class="org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"&gt;
                    &lt;property name="failOnEmptyBeans" value="false"/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;</code></pre> 
<p></p> 
<p><strong>返回json字符串统一解决</strong></p> 
<p>在类上直接使用 <strong>@RestController</strong> ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！</p> 
<pre><code class="language-java">@RestController
public class UserController {
 
    //produces:指定响应体返回类型和编码
    @RequestMapping(value = "/json1")
    public String json1() throws JsonProcessingException {
        //创建一个jackson的对象映射器，用来解析数据
        ObjectMapper mapper = new ObjectMapper();
        //创建一个对象
        User user = new User("秦疆1号", 3, "男");
        //将我们的对象解析成为json格式
        String str = mapper.writeValueAsString(user);
        //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便
        return str;
    }
 
}</code></pre> 
<p></p> 
<p></p> 
<p>测试集合输出</p> 
<pre><code class="language-java">@RequestMapping("/json2")
public String json2() throws JsonProcessingException {
 
    //创建一个jackson的对象映射器，用来解析数据
    ObjectMapper mapper = new ObjectMapper();
    //创建一个对象
    User user1 = new User("秦疆1号", 3, "男");
    User user2 = new User("秦疆2号", 3, "男");
    User user3 = new User("秦疆3号", 3, "男");
    User user4 = new User("秦疆4号", 3, "男");
    List&lt;User&gt; list = new ArrayList&lt;User&gt;();
    list.add(user1);
    list.add(user2);
    list.add(user3);
    list.add(user4);
 
    //将我们的对象解析成为json格式
    String str = mapper.writeValueAsString(list);
    return str;
}</code></pre> 
<p><img alt="" height="156" src="https://images2.imgbox.com/d3/b5/bGwAsWvA_o.png" width="826"></p> 
<p></p> 
<p></p> 
<p>输出时间对象</p> 
<pre><code class="language-java">@RequestMapping("/json3")
public String json3() throws JsonProcessingException {
 
    ObjectMapper mapper = new ObjectMapper();
 
    //创建时间一个对象，java.util.Date
    Date date = new Date();
    //将我们的对象解析成为json格式
    String str = mapper.writeValueAsString(date);
    return str;
}</code></pre> 
<p><img alt="" height="95" src="https://images2.imgbox.com/f0/6c/zsUA2B1P_o.png" width="409"></p> 
<p></p> 
<p></p> 
<ul><li> <p>默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！</p> </li><li> <p><strong>Jackson 默认是会把时间转成timestamps形式</strong></p> </li></ul> 
<p></p> 
<p><strong>解决方案：取消timestamps形式 ， 自定义时间格式</strong></p> 
<pre><code class="language-java">@RequestMapping("/json4")
public String json4() throws JsonProcessingException {
 
    ObjectMapper mapper = new ObjectMapper();
 
    //不使用时间戳的方式
    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
    //自定义日期格式对象
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    //指定日期格式
    mapper.setDateFormat(sdf);
 
    Date date = new Date();
    String str = mapper.writeValueAsString(date);
 
    return str;
}</code></pre> 
<p><img alt="" height="94" src="https://images2.imgbox.com/3b/39/ns6F9U36_o.png" width="470"></p> 
<p></p> 
<p></p> 
<p>抽取为工具类</p> 
<pre><code class="language-java">package com.kuang.utils;
 
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
 
import java.text.SimpleDateFormat;
 
public class JsonUtils {
    
    public static String getJson(Object object) {
        return getJson(object,"yyyy-MM-dd HH:mm:ss");
    }
 
    public static String getJson(Object object,String dateFormat) {
        ObjectMapper mapper = new ObjectMapper();
        //不使用时间差的方式
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        //自定义日期格式对象
        SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);
        //指定日期格式
        mapper.setDateFormat(sdf);
        try {
            return mapper.writeValueAsString(object);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return null;
    }
}
@RequestMapping("/json5")
public String json5() throws JsonProcessingException {
    Date date = new Date();
    String json = JsonUtils.getJson(date);
    return json;
}</code></pre> 
<p></p> 
<h4 id="11.2.2%20fastson">11.2.2 fastson</h4> 
<p>fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。</p> 
<p>fastjson 的 pom依赖！</p> 
<pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.60&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>fastjson 三个主要的类：</p> 
<p><strong>JSONObject 代表 json 对象</strong></p> 
<p>JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。</p> 
<p>JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取"键：值"对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</p> 
<p><strong>JSONArray 代表 json 对象数组</strong></p> 
<p>内部是有List接口中的方法来完成操作的。</p> 
<p><strong>JSON代表 JSONObject和JSONArray的转化</strong></p> 
<p></p> 
<p>JSON类源码分析与使用</p> 
<p>仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。</p> 
<p>代码测试，我们新建一个FastJsonDemo 类</p> 
<pre><code class="language-java">package com.kuang.controller;
 
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.kuang.pojo.User;
 
import java.util.ArrayList;
import java.util.List;
 
public class FastJsonDemo {
    public static void main(String[] args) {
        //创建一个对象
        User user1 = new User("秦疆1号", 3, "男");
        User user2 = new User("秦疆2号", 3, "男");
        User user3 = new User("秦疆3号", 3, "男");
        User user4 = new User("秦疆4号", 3, "男");
        List&lt;User&gt; list = new ArrayList&lt;User&gt;();
        list.add(user1);
        list.add(user2);
        list.add(user3);
        list.add(user4);
 
        System.out.println("*******Java对象 转 JSON字符串*******");
        String str1 = JSON.toJSONString(list);
        System.out.println("JSON.toJSONString(list)==&gt;"+str1);
        String str2 = JSON.toJSONString(user1);
        System.out.println("JSON.toJSONString(user1)==&gt;"+str2);
 
        System.out.println("\n****** JSON字符串 转 Java对象*******");
        User jp_user1=JSON.parseObject(str2,User.class);
        System.out.println("JSON.parseObject(str2,User.class)==&gt;"+jp_user1);
 
        System.out.println("\n****** Java对象 转 JSON对象 ******");
        JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);
        System.out.println("(JSONObject) JSON.toJSON(user2)==&gt;"+jsonObject1.getString("name"));
 
        System.out.println("\n****** JSON对象 转 Java对象 ******");
        User to_java_user = JSON.toJavaObject(jsonObject1, User.class);
        System.out.println("JSON.toJavaObject(jsonObject1, User.class)==&gt;"+to_java_user);
    }
}</code></pre> 
<p></p> 
<h2 id="12%20%E6%95%B4%E5%90%88SSM">12 整合SSM</h2> 
<p>环境</p> 
<ul><li> <p>IDEA</p> </li><li> <p>MySQL 8.0.25</p> </li><li> <p>Tomcat 9</p> </li><li> <p>Maven 3.6</p> </li></ul> 
<p>要求：</p> 
<ul><li> <p>需要熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis知识，简单的前端知识；</p> </li></ul> 
<p>创建一个存放书籍数据的数据库表</p> 
<pre><code class="language-sql">CREATE DATABASE `ssmbuild`;
 
USE `ssmbuild`;
 
DROP TABLE IF EXISTS `books`;
 
CREATE TABLE `books` (
  `bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id',
  `bookName` VARCHAR(100) NOT NULL COMMENT '书名',
  `bookCounts` INT(11) NOT NULL COMMENT '数量',
  `detail` VARCHAR(200) NOT NULL COMMENT '描述',
  KEY `bookID` (`bookID`)
) ENGINE=INNODB DEFAULT CHARSET=utf8
 
INSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES 
(1,'Java',1,'从入门到放弃'),
(2,'MySQL',10,'从删库到跑路'),
(3,'Linux',5,'从进门到进牢');</code></pre> 
<p>1、新建一Maven项目！ssmbuild ， 添加web的支持</p> 
<p>2、导入相关的pom依赖！</p> 
<pre><code class="language-XML"> &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--数据库驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.25&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 数据库连接池 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mchange&lt;/groupId&gt;
            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
            &lt;version&gt;0.9.5.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
            &lt;version&gt;2.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.13.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.78&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.7&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;2.0.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.22&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre> 
<p>3、Maven资源过滤设置</p> 
<pre><code class="language-XML">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;</code></pre> 
<p>4、建立基本结构和配置框架！</p> 
<ul><li> <p>com.kuang.pojo</p> </li><li> <p>com.kuang.dao</p> </li><li> <p>com.kuang.service</p> </li><li> <p>com.kuang.controller</p> </li><li> <p>mybatis-config.xml</p> </li></ul> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
 
&lt;/configuration&gt;</code></pre> 
<ul><li> <p>applicationContext.xml</p> </li></ul> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
 
&lt;/beans&gt;</code></pre> 
<h3 id="12.1%20Mybatis%E5%B1%82%E7%BC%96%E5%86%99">12.1 Mybatis层编写</h3> 
<p>1、数据库配置文件 <strong>database.properties</strong></p> 
<pre><code class="language-XML">jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8
jdbc.username=root
jdbc.password=root</code></pre> 
<p>2、IDEA关联数据库</p> 
<p>3、编写MyBatis的核心配置文件</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
&lt;!--配置数据源，交给Spring去做--&gt;
    
    &lt;typeAliases&gt;
        &lt;package name="com.yw.pojo"/&gt;
    &lt;/typeAliases&gt;

    &lt;mappers&gt;
        &lt;mapper class="com.yw.dao.BookMapper"/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre> 
<p>4、编写数据库对应的实体类 com.kuang.pojo.Books</p> 
<p>使用lombok插件！</p> 
<pre><code class="language-java">import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Books {
    private int bookID;
    private String bookName;
    private int bookCounts;
    private String detail;
}</code></pre> 
<p>5、编写Dao层的 Mapper接口！</p> 
<pre><code class="language-java">public interface BookMapper {
    int addBook(Books book);

    int deleteBookById(int bookID);

    int updateBook(Books book);

    Books queryBookById(int bookID);

    List&lt;Books&gt; queryAllBook();
}</code></pre> 
<p>6、编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包；</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;mapper namespace="com.yw.dao.BookMapper"&gt;

    &lt;!--增加一个Book--&gt;
    &lt;insert id="addBook" parameterType="Books"&gt;
        insert into ssmbuild.books(bookName,bookCounts,detail)
        values (#{bookName}, #{bookCounts}, #{detail})
    &lt;/insert&gt;

    &lt;!--根据id删除一个Book--&gt;
    &lt;delete id="deleteBookById" parameterType="int"&gt;
        delete from ssmbuild.books where bookID=#{bookID}
    &lt;/delete&gt;

    &lt;!--更新Book--&gt;
    &lt;update id="updateBook" parameterType="Books"&gt;
        update ssmbuild.books
        set bookName = #{bookName},bookCounts = #{bookCounts},detail = #{detail}
        where bookID = #{bookID}
    &lt;/update&gt;

    &lt;!--根据id查询,返回一个Book--&gt;
    &lt;select id="queryBookById" resultType="Books"&gt;
        select * from ssmbuild.books
        where bookID = #{bookID}
    &lt;/select&gt;

    &lt;!--查询全部Book--&gt;
    &lt;select id="queryAllBook" resultType="Books"&gt;
        SELECT * from ssmbuild.books
    &lt;/select&gt;

&lt;/mapper&gt;</code></pre> 
<p>7、编写Service层的接口和实现类</p> 
<p>接口：</p> 
<pre><code class="language-java">public interface BookService {
    int addBook(Books book);

    int deleteBookById(int bookID);

    int updateBook(Books book);

    Books queryBookById(int bookID);

    List&lt;Books&gt; queryAllBook();
}</code></pre> 
<p>实现类：</p> 
<pre><code class="language-java">package com.yw.service;

import com.yw.dao.BookMapper;
import com.yw.pojo.Books;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

public class BookServiceImpl implements BookService{

    private BookMapper bookMapper;

    public void setBookMapper(BookMapper bookMapper) {
        this.bookMapper = bookMapper;
    }

    @Override
    public int addBook(Books book) {
        return bookMapper.addBook(book);
    }

    @Override
    public int deleteBookById(int bookID) {
        return bookMapper.deleteBookById(bookID);
    }

    @Override
    public int updateBook(Books book) {
        return bookMapper.updateBook(book);
    }

    @Override
    public Books queryBookById(int bookID) {
        return bookMapper.queryBookById(bookID);
    }

    @Override
    public List&lt;Books&gt; queryAllBook() {
        return bookMapper.queryAllBook();
    }
}</code></pre> 
<h3 id="12.2%20Spring%E5%B1%82">12.2 Spring层</h3> 
<p>1、配置<strong>Spring整合MyBatis</strong>，我们这里数据源使用c3p0连接池；</p> 
<p>2、我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;!-- 配置整合mybatis --&gt;
    &lt;!-- 1.关联数据库文件 --&gt;
    &lt;context:property-placeholder location="classpath:database.properties"/&gt;

    &lt;!-- 2.数据库连接池 --&gt;
    &lt;!--数据库连接池
        dbcp  半自动化操作  不能自动连接
        c3p0  自动化操作（自动的加载配置文件 并且设置到对象里面）
    --&gt;
    &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;
        &lt;!-- 配置连接池属性 --&gt;
        &lt;property name="driverClass" value="${jdbc.driver}"/&gt;
        &lt;property name="jdbcUrl" value="${jdbc.url}"/&gt;
        &lt;property name="user" value="${jdbc.username}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
        &lt;!-- c3p0连接池的私有属性 --&gt;
        &lt;property name="maxPoolSize" value="30"/&gt;
        &lt;property name="minPoolSize" value="10"/&gt;
        &lt;!-- 关闭连接后不自动commit --&gt;
        &lt;property name="autoCommitOnClose" value="false"/&gt;
        &lt;!-- 获取连接超时时间 --&gt;
        &lt;property name="checkoutTimeout" value="10000"/&gt;
        &lt;!-- 当获取连接失败重试次数 --&gt;
        &lt;property name="acquireRetryAttempts" value="2"/&gt;
    &lt;/bean&gt;
    &lt;!-- 3.配置SqlSessionFactory对象 --&gt;
    &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
        &lt;!-- 注入数据库连接池 --&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
        &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;
        &lt;property name="configLocation" value="classpath:mybatis-config.xml"/&gt;
    &lt;/bean&gt;
    &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;
    &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;
    &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;
        &lt;!-- 注入sqlSessionFactory --&gt;
        &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt;
        &lt;!-- 给出需要扫描Dao接口包 --&gt;
        &lt;property name="basePackage" value="com.yw.dao"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre> 
<p>3、<strong>Spring整合service层</strong></p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;!-- 扫描service相关的bean --&gt;
    &lt;context:component-scan base-package="com.yw.service" /&gt;

    &lt;!--BookServiceImpl注入到IOC容器中--&gt;
    &lt;bean id="BookServiceImpl" class="com.yw.service.BookServiceImpl"&gt;
        &lt;property name="bookMapper" ref="bookMapper"/&gt;
    &lt;/bean&gt;
    &lt;!-- 配置事务管理器 --&gt;
    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;!-- 注入数据库连接池 --&gt;
        &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre> 
<h3 id="12.3%20SpringMVC%E5%B1%82">12.3 SpringMVC层</h3> 
<p>1、<strong>web.xml</strong></p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0"&gt;

    &lt;!--1.注册DispatcherServlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!--启动级别-1--&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;   &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;!--    乱码过滤--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;session-config&gt;
        &lt;session-timeout&gt;15&lt;/session-timeout&gt;
    &lt;/session-config&gt;

&lt;/web-app&gt;</code></pre> 
<p>2、<strong>spring-mvc.xml</strong></p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;


    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;
    &lt;context:component-scan base-package="com.yw.controller"/&gt;
    &lt;!-- 让Spring MVC不处理静态资源 --&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;!--
    支持mvc注解驱动
        在spring中一般采用@RequestMapping注解来完成映射关系
        要想使@RequestMapping注解生效
        必须向上下文中注册DefaultAnnotationHandlerMapping
        和一个AnnotationMethodHandlerAdapter实例
        这两个实例分别在类级别和方法级别处理。
        而annotation-driven配置帮助我们自动完成上述两个实例的注入。
     --&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters register-defaults="true"&gt;
            &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt;
                &lt;constructor-arg value="UTF-8"/&gt;
            &lt;/bean&gt;
            &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt;
                &lt;property name="objectMapper"&gt;
                    &lt;bean class="org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"&gt;
                        &lt;property name="failOnEmptyBeans" value="false"/&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;


    &lt;!-- 视图解析器 --&gt;
    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
          id="internalResourceViewResolver"&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name="suffix" value=".jsp" /&gt;
    &lt;/bean&gt;


&lt;/beans&gt;</code></pre> 
<p>3、<strong>Spring配置整合文件，applicationContext.xml</strong></p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;import resource="spring-dao.xml"/&gt;
    &lt;import resource="spring-service.xml"/&gt;
    &lt;import resource="spring-mvc.xml"/&gt;

&lt;/beans&gt;</code></pre> 
<h3 id="12.4%20Controller%20%E5%92%8C%20%E8%A7%86%E5%9B%BE%E5%B1%82%E7%BC%96%E5%86%99">12.4 <strong>Controller 和 视图层编写</strong></h3> 
<p>1、BookController 类编写 ， 方法一：查询全部书籍</p> 
<pre><code class="language-java">package com.yw.controller;

import com.yw.pojo.Books;
import com.yw.service.BookService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.List;

@Controller
@RequestMapping("/book")
public class BookController {
    //controller 调用 service 层
    @Autowired
    @Qualifier("BookServiceImpl")
    private BookService bookService;

    //查询全部的书籍并返回到一个书籍展示页面
    @RequestMapping("/allBook")
    public String list(Model model){
        List&lt;Books&gt; books=bookService.queryAllBook();

        model.addAttribute("list",books);
        return "allBook";

    }
}</code></pre> 
<p>2、编写首页 <strong>index.jsp</strong></p> 
<pre><code class="language-html">&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;首页&lt;/title&gt;
    &lt;style type="text/css"&gt;
        a {
            text-decoration: none;
            color: black;
            font-size: 18px;
        }
        h3 {
            width: 180px;
            height: 38px;
            margin: 100px auto;
            text-align: center;
            line-height: 38px;
            background: deepskyblue;
            border-radius: 4px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
 
&lt;h3&gt;
    &lt;a href="${pageContext.request.contextPath}/book/allBook"&gt;点击进入列表页&lt;/a&gt;
&lt;/h3&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>3、书籍列表页面 <strong>allbook.jsp</strong></p> 
<pre><code class="language-html">&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;书籍列表&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;!-- 引入 Bootstrap --&gt;
    &lt;link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
 
&lt;div class="container"&gt;
    &lt;div class="row clearfix"&gt;
        &lt;div class="col-md-12 column"&gt;
            &lt;div class="page-header"&gt;
                &lt;h1&gt;
                    &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;
                &lt;/h1&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-md-4 column"&gt;
            &lt;a class="btn btn-primary" href="${pageContext.request.contextPath}/book/toAddBook"&gt;新增&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="row clearfix"&gt;
        &lt;div class="col-md-12 column"&gt;
            &lt;table class="table table-hover table-striped"&gt;
                &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;书籍编号&lt;/th&gt;
                    &lt;th&gt;书籍名字&lt;/th&gt;
                    &lt;th&gt;书籍数量&lt;/th&gt;
                    &lt;th&gt;书籍详情&lt;/th&gt;
                    &lt;th&gt;操作&lt;/th&gt;
                &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                &lt;c:forEach var="book" items="${requestScope.get('list')}"&gt;
                    &lt;tr&gt;
                        &lt;td&gt;${book.getBookID()}&lt;/td&gt;
                        &lt;td&gt;${book.getBookName()}&lt;/td&gt;
                        &lt;td&gt;${book.getBookCounts()}&lt;/td&gt;
                        &lt;td&gt;${book.getDetail()}&lt;/td&gt;
                        &lt;td&gt;
                            &lt;a href="${pageContext.request.contextPath}/book/toUpdateBook?id=${book.getBookID()}"&gt;更改&lt;/a&gt; |
                            &lt;a href="${pageContext.request.contextPath}/book/del/${book.getBookID()}"&gt;删除&lt;/a&gt;
                        &lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/c:forEach&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre> 
<p>4、BookController 类编写 ， 方法二：添加书籍</p> 
<pre><code class="language-java">@RequestMapping("/toAddBook")
public String toAddPaper() {
    return "addBook";
}
 
@RequestMapping("/addBook")
public String addPaper(Books books) {
    System.out.println(books);
    bookService.addBook(books);
    return "redirect:/book/allBook";
}</code></pre> 
<p>5、添加书籍页面：<strong>addBook.jsp</strong></p> 
<pre><code class="language-html">&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
 
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;新增书籍&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;!-- 引入 Bootstrap --&gt;
    &lt;link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="container"&gt;
    &lt;div class="row clearfix"&gt;
        &lt;div class="col-md-12 column"&gt;
            &lt;div class="page-header"&gt;
                &lt;h1&gt;
                    &lt;small&gt;新增书籍&lt;/small&gt;
                &lt;/h1&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;form action="${pageContext.request.contextPath}/book/addBook" method="post"&gt;
        书籍名称：&lt;input type="text" name="bookName"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
        书籍数量：&lt;input type="text" name="bookCounts"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
        书籍详情：&lt;input type="text" name="detail"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
        &lt;input type="submit" value="添加"&gt;
    &lt;/form&gt;
&lt;/div&gt;</code></pre> 
<p>6、BookController 类编写 ， 方法三：修改书籍</p> 
<pre><code class="language-java">@RequestMapping("/toUpdateBook")
public String toUpdateBook(Model model, int id) {
    Books books = bookService.queryBookById(id);
    System.out.println(books);
    model.addAttribute("book",books );
    return "updateBook";
}
 
@RequestMapping("/updateBook")
public String updateBook(Model model, Books book) {
    System.out.println(book);
    bookService.updateBook(book);
    Books books = bookService.queryBookById(book.getBookID());
    model.addAttribute("books", books);
    return "redirect:/book/allBook";
}</code></pre> 
<p>7、修改书籍页面 <strong>updateBook.jsp</strong></p> 
<pre><code class="language-html">&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;修改信息&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;!-- 引入 Bootstrap --&gt;
    &lt;link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="container"&gt;
    &lt;div class="row clearfix"&gt;
        &lt;div class="col-md-12 column"&gt;
            &lt;div class="page-header"&gt;
                &lt;h1&gt;
                    &lt;small&gt;修改信息&lt;/small&gt;
                &lt;/h1&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;form action="${pageContext.request.contextPath}/book/updateBook" method="post"&gt;
        &lt;input type="hidden" name="bookID" value="${book.getBookID()}"/&gt;
        书籍名称：&lt;input type="text" name="bookName" value="${book.getBookName()}"/&gt;
        书籍数量：&lt;input type="text" name="bookCounts" value="${book.getBookCounts()}"/&gt;
        书籍详情：&lt;input type="text" name="detail" value="${book.getDetail() }"/&gt;
        &lt;input type="submit" value="提交"/&gt;
    &lt;/form&gt;
&lt;/div&gt;</code></pre> 
<p>8、BookController 类编写 ， 方法四：删除书籍</p> 
<pre><code class="language-java">@RequestMapping("/del/{bookId}")
public String deleteBook(@PathVariable("bookId") int id) {
    bookService.deleteBookById(id);
    return "redirect:/book/allBook";
}</code></pre> 
<p><strong>项目结构图</strong></p> 
<p></p> 
<p><img alt="" height="463" src="https://images2.imgbox.com/f6/a7/bNu3dMNe_o.png" width="628"></p> 
<p> <img alt="" height="150" src="https://images2.imgbox.com/bc/ef/CWPqXnYp_o.png" width="435"></p> 
<p></p> 
<p></p> 
<ol><li> <p>BookController 类编写 ， 方法四：根据名称查询书籍</p> </li></ol> 
<pre><code class="language-java"> @RequestMapping("/querBook")
    public String querBook(String queryBookName,Model model){
        List&lt;Books&gt; list=new ArrayList&lt;&gt;();
​
        Books books=bookService.querBookByName(queryBookName);
        System.err.println("querBook=&gt;books:"+books);
​
        if (books ==null){
            list=bookService.queryAllBook();
            model.addAttribute("error","未查到结果");
            model.addAttribute("list",list);
            return "allBook";
        }
​
​
        list.add(books);
        System.err.println("querBook=&gt;list:"+list);
        model.addAttribute("list",list);
        return "allBook";
​
    }</code></pre> 
<ol><li> <p>BookMapper ,BookService 编写 省略</p> </li><li> <p>BookMapper.xml</p> </li></ol> 
<pre><code class="language-XML">&lt;!--    querBookByName--&gt;
    &lt;select id="querBookByName" resultType="Books"&gt;
        select * from ssmbuild.books where bookName=#{bookName}
    &lt;/select&gt;</code></pre> 
<pre>​</pre> 
<ol><li> <p>allBook.jsp</p> </li></ol> 
<pre><code class="language-html">&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%--
  Created by IntelliJ IDEA.
  User: yw
  Date: 2021/10/19
  Time: 23:05
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;书籍展示&lt;/title&gt;
    &lt;!-- 引入 Bootstrap --&gt;
    &lt;link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt;
​
&lt;/head&gt;
&lt;body&gt;
&lt;div class="container"&gt;
    &lt;div class="row clearfix"&gt;
        &lt;div class="col-md-12 column"&gt;
            &lt;div class="page-header"&gt;
                &lt;h1&gt;
                    &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;
                &lt;/h1&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-md-4 column"&gt;
            &lt;a class="btn btn-primary" href="${pageContext.request.contextPath}/book/toAddBook"&gt;新增&lt;/a&gt;
            &lt;a class="btn btn-primary" href="${pageContext.request.contextPath}/book/allBook"&gt;显示全部书籍&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class="col-md-4 column"&gt;&lt;/div&gt;
        &lt;div class="col-md-4 column"&gt;
&lt;%--            查询书籍--%&gt;
    &lt;form class="form-inline" action="${pageContext.request.contextPath}/book/querBook" method="post" style="float: right"&gt;
        &lt;span style="color: red;font-weight:bold "&gt;${error}&lt;/span&gt;
        &lt;input type="text" class="form-control" name="queryBookName" placeholder="请输入要查询的书籍名称"&gt;
        &lt;input type="submit" value="查询" class="btn btn-primary"&gt;
    &lt;/form&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="row clearfix"&gt;
        &lt;div class="col-md-12 column"&gt;
            &lt;table class="table table-hover table-striped"&gt;
                &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;书籍编号&lt;/th&gt;
                    &lt;th&gt;书籍名字&lt;/th&gt;
                    &lt;th&gt;书籍数量&lt;/th&gt;
                    &lt;th&gt;书籍详情&lt;/th&gt;
                    &lt;th&gt;操作&lt;/th&gt;
                &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                    &lt;c:forEach var="book" items="${list}"&gt;
                        &lt;tr&gt;
                            &lt;td&gt;${book.bookID}&lt;/td&gt;
                            &lt;td&gt;${book.bookName}&lt;/td&gt;
                            &lt;td&gt;${book.bookCounts}&lt;/td&gt;
                            &lt;td&gt;${book.detail}&lt;/td&gt;
                            &lt;td&gt;
​
                                &lt;a href="${pageContext.request.contextPath}/book/toUpdateBook?id=${book.bookID}"&gt;更改&lt;/a&gt; |
                                &lt;a href="${pageContext.request.contextPath}/book/del/${book.bookID}"&gt;删除&lt;/a&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/c:forEach&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
​</code></pre> 
<p></p> 
<p></p> 
<h2 id="13%20Ajax">13 Ajax</h2> 
<h3 id="13.1%20%E7%AE%80%E4%BB%8B">13.1 简介</h3> 
<ul><li> <p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p> </li></ul> 
<ul><li> <p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p> </li><li> <p>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</p> </li><li> <p>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。</p> </li><li> <p>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</p> </li><li> <p>就和国内百度的搜索框一样!</p> </li><li> <p>传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。</p> </li><li> <p>使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</p> </li><li> <p>使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。</p> </li></ul> 
<h3 id="13.2%E4%BC%AA%E9%80%A0Ajax">13.2伪造Ajax</h3> 
<p>我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签</p> 
<p>1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！</p> 
<p>2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果</p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;kuangshen&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 
&lt;script type="text/javascript"&gt;
    window.onload = function(){
        var myDate = new Date();
        document.getElementById('currentTime').innerText = myDate.getTime();
    };
 
    function LoadPage(){
        var targetUrl =  document.getElementById('url').value;
        console.log(targetUrl);
        document.getElementById("iframePosition").src = targetUrl;
    }
 
&lt;/script&gt;
 
&lt;div&gt;
    &lt;p&gt;请输入要加载的地址：&lt;span id="currentTime"&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;
        &lt;input id="url" type="text" value="https://www.baidu.com/"/&gt;
        &lt;input type="button" value="提交" onclick="LoadPage()"&gt;
    &lt;/p&gt;
&lt;/div&gt;
 
&lt;div&gt;
    &lt;h3&gt;加载页面位置：&lt;/h3&gt;
    &lt;iframe id="iframePosition" style="width: 100%;height: 500px;"&gt;&lt;/iframe&gt;
&lt;/div&gt;
 
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p><strong>利用AJAX可以做：</strong></p> 
<ul><li> <p>注册时，输入用户名自动检测用户是否已经存在。</p> </li><li> <p>登陆时，提示用户名密码错误</p> </li><li> <p>删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。</p> </li><li> <p>....等等</p> </li></ul> 
<h3 id="13.3%20jQuery.ajax">13.3 jQuery.ajax</h3> 
<p>纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！</p> 
<p>Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</p> 
<p>jQuery 提供多个与 AJAX 有关的方法。</p> 
<p>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</p> 
<p>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</p> 
<pre><code class="language-html">jQuery.ajax(...)
       部分参数：
              url：请求地址
             type：请求方式，GET、POST（1.9.0之后用method）
          headers：请求头
             data：要发送的数据
      contentType：即将发送信息至服务器的内容编码类型(默认: "application/x-www-form-urlencoded; charset=UTF-8")
            async：是否异步
          timeout：设置请求超时时间（毫秒）
       beforeSend：发送请求前执行的函数(全局)
         complete：完成之后执行的回调函数(全局)
          success：成功之后执行的回调函数(全局)
            error：失败之后执行的回调函数(全局)
          accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型
         dataType：将服务器端返回的数据转换成指定类型
            "xml": 将服务器端返回的内容转换成xml格式
           "text": 将服务器端返回的内容转换成普通文本格式
           "html": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。
         "script": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式
           "json": 将服务器端返回的内容转换成相应的JavaScript对象
          "jsonp": JSONP 格式使用 JSONP 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数</code></pre> 
<p><strong>我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用</strong></p> 
<p>1、配置web.xml 和 springmvc的配置文件</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;
 
    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package="com.kuang.controller"/&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;mvc:annotation-driven /&gt;
 
    &lt;!-- 视图解析器 --&gt;
    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
          id="internalResourceViewResolver"&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name="suffix" value=".jsp" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre> 
<p>2、编写一个AjaxController</p> 
<pre><code class="language-java">@Controller
public class AjaxController {
 
    @RequestMapping("/a1")
    public void ajax1(String name , HttpServletResponse response) throws IOException {
        if ("admin".equals(name)){
            response.getWriter().print("true");
        }else{
            response.getWriter().print("false");
        }
    }
 
}</code></pre> 
<p>3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入</p> 
<pre><code class="language-html">&lt;script src="https://code.jquery.com/jquery-3.1.1.min.js"&gt;&lt;/script&gt;
&lt;script src="${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js"&gt;&lt;/script&gt;</code></pre> 
<p>4、编写index.jsp测试</p> 
<pre><code class="language-html">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
    &lt;%--&lt;script src="https://code.jquery.com/jquery-3.1.1.min.js"&gt;&lt;/script&gt;--%&gt;
    &lt;script src="${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        function a1(){
            $.post({
                url:"${pageContext.request.contextPath}/a1",
                data:{'name':$("#txtName").val()},
                success:function (data,status) {
                    alert(data);
                    alert(status);
                }
            });
        }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
 
  &lt;%--onblur：失去焦点触发事件--%&gt;
  用户名:&lt;input type="text" id="txtName" onblur="a1()"/&gt;
 
  &lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！</p> 
<p><strong>Springmvc实现</strong></p> 
<p>实体类user</p> 
<pre><code class="language-java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
 
    private String name;
    private int age;
    private String sex;
 
}</code></pre> 
<p>我们来获取一个集合对象，展示到前端页面</p> 
<pre><code class="language-java">@RequestMapping("/a2")
public List&lt;User&gt; ajax2(){
    List&lt;User&gt; list = new ArrayList&lt;User&gt;();
    list.add(new User("秦疆1号",3,"男"));
    list.add(new User("秦疆2号",3,"男"));
    list.add(new User("秦疆3号",3,"男"));
    return list; //由于@RestController注解，将list转成json格式返回
}</code></pre> 
<p>前端页面</p> 
<pre><code class="language-html">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type="button" id="btn" value="获取数据"/&gt;
&lt;table width="80%" align="center"&gt;
    &lt;tr&gt;
        &lt;td&gt;姓名&lt;/td&gt;
        &lt;td&gt;年龄&lt;/td&gt;
        &lt;td&gt;性别&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tbody id="content"&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
 
&lt;script src="${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
 
    $(function () {
        $("#btn").click(function () {
            $.post("${pageContext.request.contextPath}/a2",function (data) {
                console.log(data)
                var html="";
                for (var i = 0; i &lt;data.length ; i++) {
                    html+= "&lt;tr&gt;" +
                        "&lt;td&gt;" + data[i].name + "&lt;/td&gt;" +
                        "&lt;td&gt;" + data[i].age + "&lt;/td&gt;" +
                        "&lt;td&gt;" + data[i].sex + "&lt;/td&gt;" +
                        "&lt;/tr&gt;"
                }
                $("#content").html(html);
            });
        })
    })
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p><strong>成功实现了数据回显！可以体会一下Ajax的好处！</strong></p> 
<p>我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化</p> 
<p>我们写一个Controller</p> 
<pre><code class="language-java">@RequestMapping("/a3")
public String ajax3(String name,String pwd){
    String msg = "";
    //模拟数据库中存在数据
    if (name!=null){
        if ("admin".equals(name)){
            msg = "OK";
        }else {
            msg = "用户名输入错误";
        }
    }
    if (pwd!=null){
        if ("123456".equals(pwd)){
            msg = "OK";
        }else {
            msg = "密码输入有误";
        }
    }
    return msg; //由于@RestController注解，将msg转成json格式返回
}</code></pre> 
<p>前端页面 login.jsp</p> 
<pre><code class="language-html">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;ajax&lt;/title&gt;
    &lt;script src="${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
 
        function a1(){
            $.post({
                url:"${pageContext.request.contextPath}/a3",
                data:{'name':$("#name").val()},
                success:function (data) {
                    if (data.toString()=='OK'){
                        $("#userInfo").css("color","green");
                    }else {
                        $("#userInfo").css("color","red");
                    }
                    $("#userInfo").html(data);
                }
            });
        }
        function a2(){
            $.post({
                url:"${pageContext.request.contextPath}/a3",
                data:{'pwd':$("#pwd").val()},
                success:function (data) {
                    if (data.toString()=='OK'){
                        $("#pwdInfo").css("color","green");
                    }else {
                        $("#pwdInfo").css("color","red");
                    }
                    $("#pwdInfo").html(data);
                }
            });
        }
 
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;
    用户名:&lt;input type="text" id="name" onblur="a1()"/&gt;
    &lt;span id="userInfo"&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    密码:&lt;input type="text" id="pwd" onblur="a2()"/&gt;
    &lt;span id="pwdInfo"&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>【记得处理json乱码问题】</p> 
<p>获取baidu接口Demo</p> 
<pre><code class="language-html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
    &lt;title&gt;JSONP百度搜索&lt;/title&gt;
    &lt;style&gt;
        #q{
            width: 500px;
            height: 30px;
            border:1px solid #ddd;
            line-height: 30px;
            display: block;
            margin: 0 auto;
            padding: 0 10px;
            font-size: 14px;
        }
        #ul{
            width: 520px;
            list-style: none;
            margin: 0 auto;
            padding: 0;
            border:1px solid #ddd;
            margin-top: -1px;
            display: none;
        }
        #ul li{
            line-height: 30px;
            padding: 0 10px;
        }
        #ul li:hover{
            background-color: #f60;
            color: #fff;
        }
    &lt;/style&gt;
    &lt;script&gt;
 
        // 2.步骤二
        // 定义demo函数 (分析接口、数据)
        function demo(data){
            var Ul = document.getElementById('ul');
            var html = '';
            // 如果搜索数据存在 把内容添加进去
            if (data.s.length) {
                // 隐藏掉的ul显示出来
                Ul.style.display = 'block';
                // 搜索到的数据循环追加到li里
                for(var i = 0;i&lt;data.s.length;i++){
                    html += '&lt;li&gt;'+data.s[i]+'&lt;/li&gt;';
                }
                // 循环的li写入ul
                Ul.innerHTML = html;
            }
        }
 
        // 1.步骤一
        window.onload = function(){
            // 获取输入框和ul
            var Q = document.getElementById('q');
            var Ul = document.getElementById('ul');
 
            // 事件鼠标抬起时候
            Q.onkeyup = function(){
                // 如果输入框不等于空
                if (this.value != '') {
                    // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
                    // 创建标签
                    var script = document.createElement('script');
                    //给定要跨域的地址 赋值给src
                    //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址
                    script.src = 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='+this.value+'&amp;cb=demo';
                    // 将组合好的带src的script标签追加到body里
                    document.body.appendChild(script);
                }
            }
        }
    &lt;/script&gt;
&lt;/head&gt;
 
&lt;body&gt;
&lt;input type="text" id="q" /&gt;
&lt;ul id="ul"&gt;
 
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p></p> 
<p></p> 
<h2 id="14%20%E6%8B%A6%E6%88%AA%E5%99%A8">14 拦截器</h2> 
<p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p> 
<p><strong>过滤器与拦截器的区别：</strong>拦截器是AOP思想的具体应用。</p> 
<p><strong>过滤器</strong></p> 
<ul><li> <p>servlet规范中的一部分，任何java web工程都可以使用</p> </li></ul> 
<ul><li> <p>在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截</p> </li></ul> 
<p>拦截器</p> 
<ul><li> <p>拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</p> </li></ul> 
<ul><li> <p>拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的</p> </li></ul> 
<h3 id="14.1%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8">14.1 自定义拦截器</h3> 
<p>那如何实现拦截器呢？</p> 
<p>想要自定义拦截器，必须实现 HandlerInterceptor 接口。</p> 
<p>1、新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持</p> 
<p>2、配置web.xml 和 springmvc-servlet.xml 文件</p> 
<p>3、编写一个拦截器</p> 
<pre><code class="language-java">package com.kuang.interceptor;
 
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
 
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
 
public class MyInterceptor implements HandlerInterceptor {
 
    //在请求处理的方法之前执行
    //如果返回true执行下一个拦截器
    //如果返回false就不执行下一个拦截器
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
        System.out.println("------------处理前------------");
        return true;
    }
 
    //在请求处理方法执行之后执行
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
        System.out.println("------------处理后------------");
    }
 
    //在dispatcherServlet处理后执行,做清理工作.
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {
        System.out.println("------------清理------------");
    }
}</code></pre> 
<p>4、在springmvc的配置文件中配置拦截器</p> 
<pre><code class="language-XML">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/** 包括路径及其子路径--&gt;
        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
        &lt;mvc:mapping path="/**"/&gt;
        &lt;!--bean配置的就是拦截器--&gt;
        &lt;bean class="com.kuang.interceptor.MyInterceptor"/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;</code></pre> 
<p>5、编写一个Controller，接收请求</p> 
<pre><code class="language-java">package com.kuang.controller;
 
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
 
//测试拦截器的控制器
@Controller
public class InterceptorController {
 
    @RequestMapping("/interceptor")
    @ResponseBody
    public String testFunction() {
        System.out.println("控制器中的方法执行了");
        return "hello";
    }
}</code></pre> 
<p>6、前端 index.jsp</p> 
<pre><code class="language-html">&lt;a href="${pageContext.request.contextPath}/interceptor"&gt;拦截器测试&lt;/a&gt;</code></pre> 
<p></p> 
<h3 id="14.2%20%E6%A1%88%E4%BE%8B">14.2 案例</h3> 
<p>验证用户是否登录 (认证用户)</p> 
<p>实现思路</p> 
<p>1、有一个登陆页面，需要写一个controller访问页面。</p> 
<p>2、登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。</p> 
<p>3、拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</p> 
<p>测试：</p> 
<p>1、编写一个登陆页面 login.jsp</p> 
<pre><code class="language-html">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
 
&lt;h1&gt;登录页面&lt;/h1&gt;
&lt;hr&gt;
 
&lt;body&gt;
&lt;form action="${pageContext.request.contextPath}/user/login"&gt;
    用户名：&lt;input type="text" name="username"&gt; &lt;br&gt;
    密码：&lt;input type="password" name="pwd"&gt; &lt;br&gt;
    &lt;input type="submit" value="提交"&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>2、编写一个Controller处理请求</p> 
<pre><code class="language-html">package com.kuang.controller;
 
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
 
import javax.servlet.http.HttpSession;
 
@Controller
@RequestMapping("/user")
public class UserController {
 
    //跳转到登陆页面
    @RequestMapping("/jumplogin")
    public String jumpLogin() throws Exception {
        return "login";
    }
 
    //跳转到成功页面
    @RequestMapping("/jumpSuccess")
    public String jumpSuccess() throws Exception {
        return "success";
    }
 
    //登陆提交
    @RequestMapping("/login")
    public String login(HttpSession session, String username, String pwd) throws Exception {
        // 向session记录用户身份信息
        System.out.println("接收前端==="+username);
        session.setAttribute("user", username);
        return "success";
    }
 
    //退出登陆
    @RequestMapping("logout")
    public String logout(HttpSession session) throws Exception {
        // session 过期
        session.invalidate();
        return "login";
    }
}</code></pre> 
<p>3、编写一个登陆成功的页面 success.jsp</p> 
<pre><code class="language-html">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 
&lt;h1&gt;登录成功页面&lt;/h1&gt;
&lt;hr&gt;
 
${user}
&lt;a href="${pageContext.request.contextPath}/user/logout"&gt;注销&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>4、在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！</p> 
<pre><code class="language-html">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;h1&gt;首页&lt;/h1&gt;
  &lt;hr&gt;
  &lt;%--登录--%&gt;
  &lt;a href="${pageContext.request.contextPath}/user/jumplogin"&gt;登录&lt;/a&gt;
  &lt;a href="${pageContext.request.contextPath}/user/jumpSuccess"&gt;成功页面&lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p>5、编写用户登录拦截器</p> 
<pre><code class="language-java">package com.kuang.interceptor;
 
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
 
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
 
public class LoginInterceptor implements HandlerInterceptor {
 
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException {
        // 如果是登陆页面则放行
        System.out.println("uri: " + request.getRequestURI());
        if (request.getRequestURI().contains("login")) {
            return true;
        }
 
        HttpSession session = request.getSession();
 
        // 如果用户已登陆也放行
        if(session.getAttribute("user") != null) {
            return true;
        }
 
        // 用户没有登陆跳转到登陆页面
        request.getRequestDispatcher("/WEB-INF/jsp/login.jsp").forward(request, response);
        return false;
    }
 
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
 
    }
    
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {
 
    }
}</code></pre> 
<p>6、在Springmvc的配置文件中注册拦截器</p> 
<pre><code class="language-XML">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path="/**"/&gt;
        &lt;bean id="loginInterceptor" class="com.kuang.interceptor.LoginInterceptor"/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;</code></pre> 
<p>7、再次重启Tomcat测试！</p> 
<h2 id="15%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD">15 文件上传和下载</h2> 
<h3 id="15.1%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">15.1文件上传</h3> 
<p>1、导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包；</p> 
<pre><code class="language-XML">&lt;!--文件上传--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--servlet-api导入高版本的--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>2、配置bean：multipartResolver</p> 
<p>【<strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong>】</p> 
<pre><code class="language-XML">&lt;!--文件上传配置--&gt;
&lt;bean id="multipartResolver"  class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;
    &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;
    &lt;property name="defaultEncoding" value="utf-8"/&gt;
    &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;
    &lt;property name="maxUploadSize" value="10485760"/&gt;
    &lt;property name="maxInMemorySize" value="40960"/&gt;
&lt;/bean&gt;</code></pre> 
<p>CommonsMultipartFile 的 常用方法：</p> 
<p>String getOriginalFilename()：获取上传文件的原名</p> 
<p>InputStream getInputStream()：获取文件流</p> 
<p>void transferTo(File dest)：将上传文件保存到一个目录文件中</p> 
<p>我们去实际测试一下</p> 
<p>3、编写前端页面</p> 
<pre><code class="language-html">&lt;form action="/upload" enctype="multipart/form-data" method="post"&gt;
  &lt;input type="file" name="file"/&gt;
  &lt;input type="submit" value="upload"&gt;
&lt;/form&gt;</code></pre> 
<p>4、<strong>Controller</strong></p> 
<pre><code class="language-java">package com.kuang.controller;
 
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.commons.CommonsMultipartFile;
 
import javax.servlet.http.HttpServletRequest;
import java.io.*;
 
@Controller
public class FileController {
    //@RequestParam("file") 将name=file控件得到的文件封装成CommonsMultipartFile 对象
    //批量上传CommonsMultipartFile则为数组即可
    @RequestMapping("/upload")
    public String fileUpload(@RequestParam("file") CommonsMultipartFile file , HttpServletRequest request) throws IOException {
 
        //获取文件名 : file.getOriginalFilename();
        String uploadFileName = file.getOriginalFilename();
 
        //如果文件名为空，直接回到首页！
        if ("".equals(uploadFileName)){
            return "redirect:/index.jsp";
        }
        System.out.println("上传文件名 : "+uploadFileName);
 
        //上传路径保存设置
        String path = request.getServletContext().getRealPath("/upload");
        //如果路径不存在，创建一个
        File realPath = new File(path);
        if (!realPath.exists()){
            realPath.mkdir();
        }
        System.out.println("上传文件保存地址："+realPath);
 
        InputStream is = file.getInputStream(); //文件输入流
        OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流
 
        //读取写出
        int len=0;
        byte[] buffer = new byte[1024];
        while ((len=is.read(buffer))!=-1){
            os.write(buffer,0,len);
            os.flush();
        }
        os.close();
        is.close();
        return "redirect:/index.jsp";
    }
}</code></pre> 
<p>5、测试上传文件，OK！</p> 
<p><strong>采用file.Transto 来保存上传的文件</strong></p> 
<p>1、编写Controller</p> 
<pre><code class="language-java">/*
 * 采用file.Transto 来保存上传的文件
 */
@RequestMapping("/upload2")
public String  fileUpload2(@RequestParam("file") CommonsMultipartFile file, HttpServletRequest request) throws IOException {
 
    //上传路径保存设置
    String path = request.getServletContext().getRealPath("/upload");
    File realPath = new File(path);
    if (!realPath.exists()){
        realPath.mkdir();
    }
    //上传文件地址
    System.out.println("上传文件保存地址："+realPath);
 
    //通过CommonsMultipartFile的方法直接写文件（注意这个时候）
    file.transferTo(new File(realPath +"/"+ file.getOriginalFilename()));
 
    return "redirect:/index.jsp";
}</code></pre> 
<p>2、前端表单提交地址修改</p> 
<p>3、访问提交测试，OK！</p> 
<h3 id="15.2%20%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD">15.2 文件下载</h3> 
<p><strong>文件下载步骤：</strong></p> 
<p>1、设置 response 响应头</p> 
<p>2、读取文件 -- InputStream</p> 
<p>3、写出文件 -- OutputStream</p> 
<p>4、执行操作</p> 
<p>5、关闭流 （先开后关）</p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-java">@RequestMapping(value="/download")
public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{
    //要下载的图片地址
    String  path = request.getServletContext().getRealPath("/upload");
    String  fileName = "基础语法.jpg";
 
    //1、设置response 响应头
    response.reset(); //设置页面不缓存,清空buffer
    response.setCharacterEncoding("UTF-8"); //字符编码
    response.setContentType("multipart/form-data"); //二进制传输数据
    //设置响应头
    response.setHeader("Content-Disposition",
            "attachment;fileName="+URLEncoder.encode(fileName, "UTF-8"));
 
    File file = new File(path,fileName);
    //2、 读取文件--输入流
    InputStream input=new FileInputStream(file);
    //3、 写出文件--输出流
    OutputStream out = response.getOutputStream();
 
    byte[] buff =new byte[1024];
    int index=0;
    //4、执行 写出操作
    while((index= input.read(buff))!= -1){
        out.write(buff, 0, index);
        out.flush();
    }
    out.close();
    input.close();
    return null;
}</code></pre> 
<p>前端</p> 
<pre>测试，文件下载OK，大家可以和我们之前学习的JavaWeb原生的方式对比一下，就可以知道这个便捷多了!</pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0abf4d1bb13ba70cd09ee546284a3ecf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">XGB的python实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/abe372422cb05975d9452376bdd1af8c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Window本地Flink环境搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>