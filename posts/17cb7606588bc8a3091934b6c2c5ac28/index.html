<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>jCanvas插件使用手册 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="jCanvas插件使用手册" />
<meta property="og:description" content="目录
jCanvas
Introduction
Syntax
Canvas Object
Extending jCanvas
Properties
Methods
Canvas
Clear Canvas(canvas清除)
Rotate Canvas(canvas缩放)
Scale Canvas(canvas缩放)
Translate Canvas(canvas反转)
Pixel Manipulation(像素操作)
Get Canvas Images(获取canvas图像)
Draw Manually(手动绘制)
Detect Pixel Ratio(检测像素比率)
Drawings
Layers
Events
Styles
jCanvas是一个jQuery插件，使HTML5画布易于使用。
jCanvas是一个JavaScript库，用jQuery编写并用于jQuery，它包含HTML5 canvas API，添加了新的特性和功能，其中许多是可定义的。功能包括图层、事件、拖放、动画等等。结果是一个灵活的API包含在一个含糖的jQuery-esque语法中，为HTML5画布带来了强大的功能。
特性：
用于绘制x形状的灵活API适用于桌面和移动设备小(经gzip后只有12kb)免费和开源 jCanvas Introduction &lt;canvas&gt;元素是HTML5的一个新元素。它允许你在被称为画布的空白元素上绘制任意形状、路径、图像和其它图形。
创建画布：
&lt;canvas width=&#34;300&#34; height=&#34;150&#34;&gt;&lt;/canvas&gt; 当然，画布可以设置为任意宽度和高度。还可以为画布提供id，以供将来c参考。
note：无法通过css准确设置画布的宽度和高度，只能通过canvas元素的width和heights属性设置。
导入jCanvas：
&lt;script src=&#34;jcanvas.min.js&#34;&gt;&lt;/script&gt; 绘制：
HTML5提供了一个绘制canvas的原生javascript API。a native JavaScript API，但是我们使用jCanvas，使用jCanvas需要了解jQuery的基本知识。
Syntax 所有的jCanvas方法都是jQuery常规方法，调用jCanvas方法将应用于jQuery集合中所有canvas元素。
基础用法：
大多数jCanvas方法接受属性映射，可以按照任何顺序列出。
// 在画布上绘制一个圆 $(&#39;canvas&#39;).drawArc({ fillStyle: &#39;black&#39;, x: 100, y: 100, radius: 50 }); 数字值：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/17cb7606588bc8a3091934b6c2c5ac28/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-06T17:18:06+08:00" />
<meta property="article:modified_time" content="2018-09-06T17:18:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">jCanvas插件使用手册</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="jCanvas-toc" style="margin-left:40px;"><a href="#jCanvas" rel="nofollow">jCanvas</a></p> 
<p id="Introduction-toc" style="margin-left:80px;"><a href="#Introduction" rel="nofollow">Introduction</a></p> 
<p id="Syntax-toc" style="margin-left:80px;"><a href="#Syntax" rel="nofollow">Syntax</a></p> 
<p id="Canvas%20Object-toc" style="margin-left:80px;"><a href="#Canvas%20Object" rel="nofollow">Canvas Object</a></p> 
<p id="Extending%20jCanvas-toc" style="margin-left:80px;"><a href="#Extending%20jCanvas" rel="nofollow">Extending jCanvas</a></p> 
<p id="Properties-toc" style="margin-left:80px;"><a href="#Properties" rel="nofollow">Properties</a></p> 
<p id="Methods-toc" style="margin-left:80px;"><a href="#Methods" rel="nofollow">Methods</a></p> 
<p id="Canvas-toc" style="margin-left:40px;"><a href="#Canvas" rel="nofollow">Canvas</a></p> 
<p id="Clear%20Canvas(canvas%E6%B8%85%E9%99%A4)-toc" style="margin-left:80px;"><a href="#Clear%20Canvas%28canvas%E6%B8%85%E9%99%A4%29" rel="nofollow">Clear Canvas(canvas清除)</a></p> 
<p id="Rotate%20Canvas(canvas%E7%BC%A9%E6%94%BE)-toc" style="margin-left:80px;"><a href="#Rotate%20Canvas%28canvas%E7%BC%A9%E6%94%BE%29" rel="nofollow">Rotate Canvas(canvas缩放)</a></p> 
<p id="Scale%20Canvas(canvas%E7%BC%A9%E6%94%BE)-toc" style="margin-left:80px;"><a href="#Scale%20Canvas%28canvas%E7%BC%A9%E6%94%BE%29" rel="nofollow">Scale Canvas(canvas缩放)</a></p> 
<p id="Translate%20Canvas(canvas%E5%8F%8D%E8%BD%AC)-toc" style="margin-left:80px;"><a href="#Translate%20Canvas%28canvas%E5%8F%8D%E8%BD%AC%29" rel="nofollow">Translate Canvas(canvas反转)</a></p> 
<p id="Pixel%20Manipulation(%E5%83%8F%E7%B4%A0%E6%93%8D%E4%BD%9C)-toc" style="margin-left:80px;"><a href="#Pixel%20Manipulation%28%E5%83%8F%E7%B4%A0%E6%93%8D%E4%BD%9C%29" rel="nofollow">Pixel Manipulation(像素操作)</a></p> 
<p id="Get%20Canvas%20Images(%E8%8E%B7%E5%8F%96canvas%E5%9B%BE%E5%83%8F)-toc" style="margin-left:80px;"><a href="#Get%20Canvas%20Images%28%E8%8E%B7%E5%8F%96canvas%E5%9B%BE%E5%83%8F%29" rel="nofollow">Get Canvas Images(获取canvas图像)</a></p> 
<p id="Draw%20Manually(%E6%89%8B%E5%8A%A8%E7%BB%98%E5%88%B6)-toc" style="margin-left:80px;"><a href="#Draw%20Manually%28%E6%89%8B%E5%8A%A8%E7%BB%98%E5%88%B6%29" rel="nofollow">Draw Manually(手动绘制)</a></p> 
<p id="Detect%20Pixel%20Ratio(%E6%A3%80%E6%B5%8B%E5%83%8F%E7%B4%A0%E6%AF%94%E7%8E%87)-toc" style="margin-left:80px;"><a href="#Detect%20Pixel%20Ratio%28%E6%A3%80%E6%B5%8B%E5%83%8F%E7%B4%A0%E6%AF%94%E7%8E%87%29" rel="nofollow">Detect Pixel Ratio(检测像素比率)</a></p> 
<p id="Drawings-toc" style="margin-left:40px;"><a href="#Drawings" rel="nofollow">Drawings</a></p> 
<p id="Layers-toc" style="margin-left:40px;"><a href="#Layers" rel="nofollow">Layers</a></p> 
<p id="Events-toc" style="margin-left:40px;"><a href="#Events" rel="nofollow">Events</a></p> 
<p id="Styles-toc" style="margin-left:40px;"><a href="#Styles" rel="nofollow">Styles</a></p> 
<hr id="hr-toc"> 
<p><strong>jCanvas是一个jQuery插件，使HTML5画布易于使用。</strong></p> 
<p>jCanvas是一个JavaScript库，用jQuery编写并用于jQuery，它包含HTML5 canvas API，添加了新的特性和功能，其中许多是可定义的。功能包括图层、事件、拖放、动画等等。结果是一个灵活的API包含在一个含糖的jQuery-esque语法中，为HTML5画布带来了强大的功能。</p> 
<p><strong>特性：</strong></p> 
<ul><li>用于绘制x形状的灵活API</li><li>适用于桌面和移动设备</li><li>小(经gzip后只有12kb)</li><li>免费和开源</li></ul> 
<h3 id="jCanvas">jCanvas</h3> 
<ul><li> <h4 id="Introduction">Introduction</h4> </li></ul> 
<p>&lt;canvas&gt;元素是HTML5的一个新元素。它允许你在被称为画布的空白元素上绘制任意形状、路径、图像和其它图形。</p> 
<p>创建画布：</p> 
<pre class="has"><code class="language-javascript">&lt;canvas width="300" height="150"&gt;&lt;/canvas&gt;</code></pre> 
<p>当然，画布可以设置为任意宽度和高度。还可以为画布提供id，以供将来c参考。</p> 
<p>note：无法通过css准确设置画布的宽度和高度，只能通过canvas元素的width和heights属性设置。</p> 
<p>导入jCanvas：</p> 
<pre class="has"><code class="language-javascript">&lt;script src="jcanvas.min.js"&gt;&lt;/script&gt;</code></pre> 
<p>绘制：</p> 
<p> HTML5提供了一个绘制canvas的原生javascript API。<a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes" rel="nofollow">a native JavaScript API</a>，但是我们使用jCanvas，使用jCanvas需要了解jQuery的基本知识。</p> 
<ul><li> <h4 id="Syntax">Syntax</h4> </li></ul> 
<p>所有的jCanvas方法都是jQuery常规方法，调用jCanvas方法将应用于jQuery集合中所有canvas元素。</p> 
<p>基础用法：</p> 
<p>大多数jCanvas方法接受属性映射，可以按照任何顺序列出。</p> 
<pre class="has"><code class="language-javascript">// 在画布上绘制一个圆
$('canvas').drawArc({
  fillStyle: 'black',
  x: 100, y: 100,
  radius: 50
});</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/46/ca/CGA3RNTW_o.png"></p> 
<p> </p> 
<p>数字值：</p> 
<p>大多数数字属性值都以像素为单位，但有些是相对于其它属性的值。任何属性的描述通常都会在必要时提及这些特殊的情况。</p> 
<p>属性链/方法链：</p> 
<p>大多数jCanvas方法支持链接以获得更清晰和更快的代码。</p> 
<pre class="has"><code class="language-javascript">$('canvas').drawArc({
  fillStyle: 'black',
  x: 100, y: 100,
  radius: 50
})
.drawArc({
  fillStyle: '#36b',
  x: 300, y: 150,
  radius: 50
});</code></pre> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/7d/cb/VkM2lDHa_o.png"></p> 
<p> </p> 
<p>当然也可以在多个画布上绘制相同的图形。</p> 
<ul><li> <h4 id="Canvas%20Object">Canvas Object</h4> </li></ul> 
<p>jCanvas包含一个jcanvas对象作为jQuery对象的一部分。</p> 
<pre class="has"><code>$.jCanvas</code></pre> 
<p>这个<span style="color:#3399ea;">jCanvas对象</span>包含如下属性和方法：</p> 
<ol><li> 默认：包含jCanvas默认属性的对象</li><li>扩展：一种使用自定义方法扩展jCanvas对象</li></ol> 
<p>覆盖jCanvas默认值：</p> 
<p>如果希望覆盖任何jCanvas默认属性值，可以显式设置该属性或使用jQuery的<span style="color:#3399ea;">$.extend</span>:</p> 
<pre class="has"><code class="language-javascript">$.jCanvas.defaults.fromCenter = false;</code></pre> 
<pre class="has"><code class="language-javascript">$.extend($.jCanvas.defaults, {
  fromCenter: false,
  inDegrees: false
});</code></pre> 
<p> </p> 
<ul><li> <h4 id="Extending%20jCanvas">Extending jCanvas</h4> </li></ul> 
<p>jCanvas提供了一个插件API，因此可以创建与jCanvas集成的方法。为此，可以使用<span style="color:#3399ea;">jCanvas.extend()</span>方法。</p> 
<p><span style="color:#3399ea;">extend()</span>方法接受一个包含三个属性的对象：</p> 
<ol><li><span style="color:#3399ea;">name</span>:你正在创建的方法的名称；</li><li><span style="color:#3399ea;">type</span>:可选，绘制d的类型，jCanvas将其识别为type属性的有效值；</li><li><span style="color:#3399ea;">props</span>：可选，你的方法使用的自定义属性(及其默认值)。这些属性将合并到arguments对象中(如下所述)，以便在方法的代码中使用。</li><li><span style="color:#3399ea;">fn</span>:提供插件功能的函数，它接受两个参数：画布的上下文<span style="color:#3399ea;">context</span>，<span style="color:#3399ea;">调用方法时接受的参数对象</span></li></ol> 
<pre class="has"><code class="language-javascript">$.jCanvas.extend({
  name: 'pluginName',
  props: {
    prop: true
  },
  fn: function(ctx, params) {
    // Your code here
  }
});</code></pre> 
<p> 示例：drawHeart()</p> 
<p>为了演示这是如何工作的，我们将创建一个在画布上绘制心脏的方法。</p> 
<pre class="has"><code class="language-javascript">// Create a drawHeart() method
$.jCanvas.extend({
  name: 'drawHeart',
  type: 'heart',
  props: {},
  fn: function(ctx, params) {
    // Just to keep our lines short
    var p = params;
    // Enable layer transformations like scale and rotate
    $.jCanvas.transformShape(this, ctx, p);
    // Draw heart
    ctx.beginPath();
    ctx.moveTo(p.x, p.y + p.radius);
    // Left side of heart
    ctx.quadraticCurveTo(
      p.x - (p.radius * 2),
      p.y - (p.radius * 2),
      p.x,
      p.y - (p.radius / 1.5)
    );
    // Right side of heart
    ctx.quadraticCurveTo(
      p.x + (p.radius * 2),
      p.y - (p.radius * 2),
      p.x,
      p.y + p.radius
    );
    // Call the detectEvents() function to enable jCanvas events
    // Be sure to pass it these arguments, too!
    $.jCanvas.detectEvents(this, ctx, p);
    // Call the closePath() functions to fill, stroke, and close the path
    // This function also enables masking support and events
    // It accepts the same arguments as detectEvents()
    $.jCanvas.closePath(this, ctx, p);
  }
});

// Use the drawHeart() method
$('canvas').drawHeart({
  layer: true,
  draggable: true,
  fillStyle: '#c33',
  radius: 50,
  x: 150, y: 130,
  rotate: 30
});</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/0a/4d/4Tcc81K1_o.png"></p> 
<p> API方法：</p> 
<p>jCanvas对象($.jCanvas)提供了一些将方法与jCanvas集成的有用方法。所有这些方法都接受三个参数：canvas DOM元素(this),canvas上下文(ctx)和参数object(params)。</p> 
<p style="text-indent:50px;">setGlobalProps():设置全局画布属性，如fillStyle,shadowColor等。</p> 
<p style="text-indent:50px;">transformShape():使用标准转换属性(旋转，缩放，平移)启用形状z转换。请注意，必须稍后d调用closePath（）方法才能恢复图层转换。</p> 
<p style="text-indent:50px;">detectEvents():启用并检测自定义路径的jCanvas事件。请注意，应在路径末尾调用此方法。</p> 
<p style="text-indent:50px;">closePath():关闭当前路径，如果已设置相应的属性。则填充/描边。该方法还允许通过使用mask属性l来屏蔽路径。</p> 
<p style="text-indent:50px;">setCanvasFont():根据fontStyle,fontStyle和fontFamily属性设置画布上下文的字体。</p> 
<p style="text-indent:50px;">measureText():使用计算的文本宽度和高度扩充给定的参数对象。接受一个字符串数组(表示文本行)作为第四个参数。</p> 
<p style="text-indent:0;"> </p> 
<pre class="has"><code class="language-javascript">$.jCanvas.detectEvents(this, ctx, params);</code></pre> 
<pre class="has"><code class="language-javascript">$.jCanvas.closePath(this, ctx, params);</code></pre> 
<p> note：调用方法时，jCanvas将自动循环的画布元素，因此您不需要。</p> 
<p> 这些是每个jCanvas属性，它们支持的方法及其可能值的描述。 首先列出默认属性值。</p> 
<ul><li> <h4 id="Properties">Properties</h4> </li></ul> 
<p>详情见：<a href="https://projects.calebevans.me/jcanvas/docs/properties/" rel="nofollow">jCanvas属性以及支持的方法</a></p> 
<ul><li> <h4 id="Methods">Methods</h4> </li></ul> 
<p>这是每个jCanvas方法的参考列表，详情见：<a href="https://projects.calebevans.me/jcanvas/docs/methods/" rel="nofollow">jCanvas方法</a></p> 
<h3 id="Canvas">Canvas</h3> 
<ul><li> <h4 id="Clear%20Canvas(canvas%E6%B8%85%E9%99%A4)">Clear Canvas(canvas清除)</h4> </li></ul> 
<p><span style="color:#3399ea;">clearCanvas()</span>方法清除所有或部分canvas。</p> 
<p>如果你使用jCanvas Layer API，则不应使用此方法，因为在许多情况下，如果你尝试清除画布 ，API会为你重新绘制。当你认为必要的时候，你的图层最终会被jCanvas重新绘制。</p> 
<p>如果暂时隐藏图层，请使用<span style="color:#3399ea;">setLayer()</span>设置图层的visible属性，然后调用<span style="color:#3399ea;">drawLayers()</span>:</p> 
<pre class="has"><code class="language-javascript">$('canvas').setLayer('myLayerName', {
  visible: false // set to true instead to show the layer again
}).drawLayers();</code></pre> 
<p>如果想要永远地移除一个图层，调用<span style="color:#3399ea;">removeLayer()</span>后面跟着<span style="color:#3399ea;">drawLayer()</span>:</p> 
<pre class="has"><code class="language-javascript">$('canvas').removeLayer('myLayerName').drawLayers();</code></pre> 
<p>清除所有图层：如果没有传递参数，那么清除所有图层</p> 
<pre class="has"><code class="language-javascript">$('canvas').clearCanvas()</code></pre> 
<p> </p> 
<p>清除一个部分(clear a section):</p> 
<p>清除部分的工作与矩阵绘制的方式相同，矩阵从中心绘制(默认情况下)。</p> 
<pre class="has"><code class="language-javascript">$('canvas')
.drawEllipse({
  fillStyle: '#000',
  x: 200, y: 100,
  width: 200, height: 100,
})
.clearCanvas({
  x: 200, y: 100,
  width: 50,
  height: 50
});</code></pre> 
<p> <img alt="" class="has" src="https://images2.imgbox.com/d6/5d/crs3Mvjx_o.png"></p> 
<h4> </h4> 
<ul><li> <h4 id="Rotate%20Canvas(canvas%E7%BC%A9%E6%94%BE)">Rotate Canvas(canvas缩放)</h4> </li></ul> 
<ol><li>1旋转画布上下文(context)</li></ol> 
<p style="text-indent:50px;">rotateCanvas()方法从包含的点旋转画布，x和y属性定义旋转中心。</p> 
<pre class="has"><code class="language-javascript">$('canvas').rotateCanvas({
  rotate: 45,
  x: 100, y: 100
})
.drawRect({
  fillStyle: '#000',
  x: 100, y: 100,
  width: 100, height: 50
})
.restoreCanvas();</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/21/82/wLuB2mZP_o.png"></p> 
<p> </p> 
<ol><li>2旋转一个单独的形状(an individual shape)</li></ol> 
<p style="text-indent:50px;">可以旋转单个形状，而不是整个画布</p> 
<pre class="has"><code class="language-javascript">// Rotate this rectangle by 30 degrees
$('canvas').drawRect({
  fillStyle: '#c33',
  x: 200, y: 100,
  width: 150, height: 80,
  rotate: 30
});</code></pre> 
<p> <img alt="" class="has" src="https://images2.imgbox.com/ef/47/iSbInV7u_o.png"></p> 
<p> </p> 
<p>请注意，你可以指定<span style="color:#3399ea;">translateX</span>和<span style="color:#3399ea;">translateY</span>属性来偏移旋转中心 </p> 
<pre class="has"><code class="language-javascript">// Rectangle rotates from its center
$('canvas').drawRect({
  fillStyle: '#c33',
  x: 150, y: 100,
  width: 150, height: 80,
  rotate: 30
});
// Rectangle rotates from its top-left corner
$('canvas').drawRect({
  fillStyle: '#6c3',
  x: 150, y: 100,
  width: 150, height: 80,
  translateX: 75, // width / 2
  translateY: 40, // height / 2
  rotate: 30
});</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/0b/34/xX2jWXpN_o.png"></p> 
<p> </p> 
<ol><li>3图层(Layer)</li></ol> 
<p style="text-indent:50px;">尽管看起来有点违反直觉，但<span style="color:#3399ea;">rotateCanvas()</span>方法实际上可以绘制图层。这允许在绘制图层时应用画布变换。</p> 
<p style="text-indent:50px;">要执行此操作，请将<span style="color:#3399ea;">layer</span>属性设置为<span style="color:#3399ea;">true</span>，就像任何其他形状设置图层一样。此外，就像使用任何其它类型的图层一样，你可以使用<span style="color:#3399ea;">name</span>属性为此图层指定名称。</p> 
<pre class="has"><code class="language-javascript">$('canvas').rotateCanvas({
  layer: true,
  name: 'rotate1'
});</code></pre> 
<p>但是，无论何时旋转画布，都必须使用<span style="color:#3399ea;">restoreCanavs()</span>方法恢复转换。 </p> 
<pre class="has"><code class="language-javascript">$('canvas').restoreCanvas({
  layer: true
});</code></pre> 
<p>note：要恢复到画布之前的状态，调用<span style="color:#3399ea;">restoreCanvas()</span>方法。但是，旋转单个形状s时无需如此。 </p> 
<ul><li> <h4 id="Scale%20Canvas(canvas%E7%BC%A9%E6%94%BE)">Scale Canvas(canvas缩放)</h4> </li></ul> 
<ol><li>缩放图层</li></ol> 
<p><span style="color:#3399ea;">scaleCanvas()</span>方法从包含的点缩放画布。</p> 
<pre class="has"><code class="language-javascript">$('canvas').scaleCanvas({
  x: 100, y: 100,
  scaleX: 1.5, scaleY: 3
})
.drawArc({
  fillStyle: '#000',
  x: 100, y: 100,
  radius: 20
})
.restoreCanvas();</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/5f/ba/lVG07t44_o.png"></p> 
<p> </p> 
<ol><li>scale property</li></ol> 
<p>你还可以用<span style="color:#3399ea;">scale</span>属性设置<span style="color:#3399ea;">scaleX</span>和<span style="color:#3399ea;">scaleY</span>.</p> 
<pre class="has"><code class="language-javascript">$('canvas').scaleCanvas({
  scale: 2
})
.drawRect({
  fillStyle: '#000',
  x: 100, y: 100,
  width: 100, height: 50
})
.restoreCanvas();</code></pre> 
<p> <img alt="" class="has" src="https://images2.imgbox.com/09/82/mLfuY4OL_o.png"></p> 
<p> </p> 
<ol><li>缩放单个形状</li></ol> 
<p>你可以使用以下三个属性中的任何一个缩放单个形状，而不是缩放整个画布：<span style="color:#3399ea;">scale</span>，<span style="color:#3399ea;">scaleX</span>或<span style="color:#3399ea;">scaleY</span></p> 
<pre class="has"><code>// This square is scaled to be a rectangle
$('canvas').drawRect({
  fillStyle: '#36c',
  x: 200, y: 100,
  width: 100, height: 100,
  scaleX: 3
});</code></pre> 
<p> <img alt="" class="has" src="https://images2.imgbox.com/dc/c2/9jhkNsty_o.png"></p> 
<p> </p> 
<ol><li>图层</li></ol> 
<p>尽管看起来有点违反直觉，但scaleCanvas()方法实际上可以绘制为图层。这允许在绘制图层时应用画布变换。</p> 
<p>要执行此操作，请将layer属性设置为true,就像将任何其它形状设置为图层一样。此外，就像使用任何t其它类型的图层一样，你可以使用<span style="color:#3399ea;">name</span>属性为此图层指定名称。</p> 
<pre class="has"><code class="language-javascript">$('canvas').scaleCanvas({
  layer: true,
  name: 'scale1'
});</code></pre> 
<p>当然也需要使用<span style="color:#3399ea;">restoreCanvas()</span>方法恢复转换。 </p> 
<pre class="has"><code class="language-javascript">$('canvas').restoreCanvas({
  layer: true
});</code></pre> 
<p>note:</p> 
<p>scaleX和scaleY值是画布当前宽度/高度的倍数（即1是基线）。</p> 
<p>要恢复到画布的先前状态，请调用restoreCanvas（）方法。 但是，在缩放单个形状时，无需调用此方法。</p> 
<p> </p> 
<ul><li> <h4 id="Translate%20Canvas(canvas%E5%8F%8D%E8%BD%AC)">Translate Canvas(canvas反转)</h4> </li></ul> 
<p>反转的几种方式：</p> 
<pre class="has"><code class="language-javascript">$('canvas').translateCanvas({
  translateX: 200, translateY: 100
})
.drawRect({
  fillStyle: '#000',
  x: 50, y: 50,
  width: 100, height: 50
})
.restoreCanvas();</code></pre> 
<pre class="has"><code class="language-javascript">$('canvas').translateCanvas({
  translate: 100
})
.drawRect({
  fillStyle: '#000',
  x: 100, y: 100,
  width: 100, height: 50
})
.restoreCanvas();</code></pre> 
<pre class="has"><code class="language-javascript">$('canvas')
.drawRect({
  fillStyle: '#474',
  x: 50, y: 50,
  width: 100, height: 50,
  translateX: 200, translateY: 100
});</code></pre> 
<p>note：平移形状会改变其转换中心。</p> 
<p>以图层的方式转换：</p> 
<pre class="has"><code class="language-javascript">$('canvas').translateCanvas({
  layer: true,
  name: 'translate1'
});</code></pre> 
<pre class="has"><code class="language-javascript">$('canvas').restoreCanvas({
  layer: true
});</code></pre> 
<ul><li> <h4 id="Pixel%20Manipulation(%E5%83%8F%E7%B4%A0%E6%93%8D%E4%BD%9C)">Pixel Manipulation(像素操作)</h4> </li></ul> 
<p><span style="color:#3399ea;">setPixes()</span>方法允许从画布修改特定像素部分。要修改像素，可以使用每个回调方法遍历每个像素。每个回调函数都接受两个参数：包括红色，绿色、蓝色和alpha颜色值<span style="color:#3399ea;">(r,g,b,a)</span>属性的对象；传递给<span style="color:#3399ea;">setPixels()</span>方法的参数。</p> 
<pre class="has"><code class="language-javascript">function invert() {
  $(this).setPixels({
    x: 150, y: 100,
    width: 220, height: 138,
    // loop through each pixel
    each: function(px) {
      px.r = 255 - px.r;
      px.g = 255 - px.g;
      px.b = 255 - px.b;
    }
  });
}

$('canvas').drawImage({
  source: 'images/fish.jpg',
  x: 150, y: 100,
  // Invert image color when image loads
  load: invert
});</code></pre> 
<p>在此示例中，将鼠标悬停在图像上，将会操纵最靠近你悬停部分的像素。</p> 
<pre class="has"><code class="language-javascript">function invert(params) {
  $(this).setPixels({
    x: params.eventX, y: params.eventY,
    width: 50, height: 50,
    // loop through each pixel
    each: function(px) {
      px.r = 255 - px.r;
      px.g = 255 - px.g;
      px.b = 255 - px.b;
    }
  });
}

$('canvas').drawImage({
  layer: true,
  source: 'images/fish.jpg',
  x: 150, y: 100,
  mousemove: invert
});</code></pre> 
<p> note：如果没有指定<span style="color:#3399ea;">width</span>和<span style="color:#3399ea;">height</span>属性，该方法会遍历画布上的每个像素。r,g,b和alpha的属性范围都是0-255。与所有jCanvas方法一样，setPixels()方法尊重<span style="color:#3399ea;">fromCenter</span>属性值，默认为false。</p> 
<p> </p> 
<ul><li> <h4 id="Get%20Canvas%20Images(%E8%8E%B7%E5%8F%96canvas%E5%9B%BE%E5%83%8F)">Get Canvas Images(获取canvas图像)</h4> </li></ul> 
<p><span style="color:#3399ea;">getCanvasImage()</span>方法将画布的图像数据检索为字符串。该字符串时<span style="color:#3399ea;">base64</span>编码的图像URL，可以作为任何有效图像的URL。</p> 
<pre class="has"><code class="language-javascript">$('canvas').getCanvasImage();</code></pre> 
<p>默认是.png格式，也可以设置为其它格式。</p> 
<pre class="has"><code class="language-javascript">$('canvas').getCanvasImage('png');
$('canvas').getCanvasImage('jpeg');</code></pre> 
<p>设置属性：</p> 
<pre class="has"><code class="language-javascript">$('canvas').getCanvasImage('jpeg', 0.5);</code></pre> 
<p> note:如果页面是从文件URL（file：//）提供的，则此方法在Google Chrome上无效。 这是Google Chrome沙盒架构的限制，因此无法修复。 但是，当从服务器（在线或通过localhost：//在本地运行）提供页面时，此方法仍然有效。</p> 
<ul><li> <h4 id="Draw%20Manually(%E6%89%8B%E5%8A%A8%E7%BB%98%E5%88%B6)">Draw Manually(手动绘制)</h4> </li></ul> 
<p>使用draw()方法，可以用原生canvas方法任意绘制。</p> 
<pre class="has"><code class="language-javascript">$('canvas').draw({
  fn: function(ctx) {
    ctx.fillStyle = '#333';
    ctx.fillRect(50, 50, 100, 100);
  }
});</code></pre> 
<pre class="has"><code class="language-javascript">$('canvas').draw({
  type: 'rectangle',
  fillStyle: '#c33',
  x: 100, y: 100,
  width: 100, height: 80
});</code></pre> 
<p> 与下面的方法等同：</p> 
<pre class="has"><code class="language-javascript">$('canvas').drawRect({
  fillStyle: '#c33',
  x: 100, y: 100,
  width: 100, height: 80
});</code></pre> 
<ul><li> <h4 id="Detect%20Pixel%20Ratio(%E6%A3%80%E6%B5%8B%E5%83%8F%E7%B4%A0%E6%AF%94%E7%8E%87)">Detect Pixel Ratio(检测像素比率)</h4> </li></ul> 
<p>jCanvas提供了detectPixelRatio（）方法，用于检测高分辨率显示器（包括带有视网膜显示器的设备）。</p> 
<p>对于这些设备，该方法将增加画布的尺寸宽度和高度，缩放其上下文以匹配，然后使用CSS缩小它。 这将导致设备以更高的像素密度渲染画布。</p> 
<p>该方法还接受回调函数作为其唯一参数，而该参数又接受设备的像素比率作为其唯一参数。</p> 
<pre class="has"><code class="language-javascript">$('canvas').detectPixelRatio(function(ratio) {
  // Run some code depending on the device pixel ratio
});</code></pre> 
<p>比如说：Apple设备上的Retina显示器的像素比率为2。</p> 
<h3 id="Drawings">Drawings</h3> 
<p>参考：<a href="https://projects.calebevans.me/jcanvas/docs/arcs/" rel="nofollow">jCanvas绘制</a></p> 
<h3 id="Layers">Layers</h3> 
<p>参考：<a href="https://projects.calebevans.me/jcanvas/docs/layerAPI/" rel="nofollow">Layers API</a></p> 
<h3 id="Events">Events</h3> 
<p>参考：<a href="https://projects.calebevans.me/jcanvas/docs/eventAPI/" rel="nofollow">Events API</a></p> 
<h3 id="Styles">Styles</h3> 
<p>参考：<a href="https://projects.calebevans.me/jcanvas/docs/colors/" rel="nofollow">Styles</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f3c7cc001239ca1689477a892b63d9aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">洛谷1982-小朋友的数字-noip2013</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7543d24d0a0d5f68e250eef90d20e1a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">hive启动小问题解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>