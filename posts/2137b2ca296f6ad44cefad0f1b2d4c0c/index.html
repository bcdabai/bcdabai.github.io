<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32F4 ADC - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32F4 ADC" />
<meta property="og:description" content="文章目录 【 1. 简介 】【 2. 通道 】【 3. 单次转换模式 】【 4. 连续转换模式 】【 5. 模拟看门狗 】【 6. 扫描模式 】【 7. 注入通道管理 】触发注入自动注入 【 8. 不连续采样模式 】规则组注入组 【 9. 数据对齐 】【 10. 可独立设置各通道采样时间 】【 11. 外部触发转换和触发极性 】【 12. 快速转换模式 】【 13. 数据管理 】使用 DMA在不使用DMA的情况下管理转换序列在不使用DMA和溢出检测的情况下进行转换 【 14. 多重ADC模式 】多重 ADC 下的 DMA 模式注入同时模式规则同时模式交替模式双重 ADC 模式三重 ADC 模式 交替触发模式混合型规则/注入同时模式规则同时&#43;交替触发组合模式 【 15. 温度传感器 】【 16. 电池充电监测 】【 17. ADC 中断 】【 18. 寄存器 】状态寄存器 ADC_SR控制寄存器 ADC_CR1、ADC_CR2采样时间寄存器 ADC_SMPR1、ADC_SMPR2注入通道偏移寄存器 ADC_JOFRx (x=1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2137b2ca296f6ad44cefad0f1b2d4c0c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-09T20:52:48+08:00" />
<meta property="article:modified_time" content="2022-02-09T20:52:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32F4 ADC</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1___1" rel="nofollow">【 1. 简介 】</a></li><li><a href="#_2___12" rel="nofollow">【 2. 通道 】</a></li><li><a href="#_3___26" rel="nofollow">【 3. 单次转换模式 】</a></li><li><a href="#_4___43" rel="nofollow">【 4. 连续转换模式 】</a></li><li><a href="#_5___52" rel="nofollow">【 5. 模拟看门狗 】</a></li><li><a href="#_6___60" rel="nofollow">【 6. 扫描模式 】</a></li><li><a href="#_7___69" rel="nofollow">【 7. 注入通道管理 】</a></li><li><ul><li><a href="#_70" rel="nofollow">触发注入</a></li><li><a href="#_78" rel="nofollow">自动注入</a></li></ul> 
  </li><li><a href="#_8___85" rel="nofollow">【 8. 不连续采样模式 】</a></li><li><ul><li><a href="#_86" rel="nofollow">规则组</a></li><li><a href="#_99" rel="nofollow">注入组</a></li></ul> 
  </li><li><a href="#_9___111" rel="nofollow">【 9. 数据对齐 】</a></li><li><a href="#_10___121" rel="nofollow">【 10. 可独立设置各通道采样时间 】</a></li><li><a href="#_11___129" rel="nofollow">【 11. 外部触发转换和触发极性 】</a></li><li><a href="#_12___138" rel="nofollow">【 12. 快速转换模式 】</a></li><li><a href="#_13___145" rel="nofollow">【 13. 数据管理 】</a></li><li><ul><li><a href="#_DMA_146" rel="nofollow">使用 DMA</a></li><li><a href="#DMA_158" rel="nofollow">在不使用DMA的情况下管理转换序列</a></li><li><a href="#DMA_164" rel="nofollow">在不使用DMA和溢出检测的情况下进行转换</a></li></ul> 
  </li><li><a href="#_14_ADC__166" rel="nofollow">【 14. 多重ADC模式 】</a></li><li><ul><li><a href="#_ADC__DMA__183" rel="nofollow">多重 ADC 下的 DMA 模式</a></li><li><a href="#_224" rel="nofollow">注入同时模式</a></li><li><a href="#_226" rel="nofollow">规则同时模式</a></li><li><a href="#_228" rel="nofollow">交替模式</a></li><li><ul><li><a href="#_ADC__230" rel="nofollow">双重 ADC 模式</a></li><li><a href="#_ADC__243" rel="nofollow">三重 ADC 模式</a></li></ul> 
   </li><li><a href="#_260" rel="nofollow">交替触发模式</a></li><li><a href="#_262" rel="nofollow">混合型规则/注入同时模式</a></li><li><a href="#_264" rel="nofollow">规则同时+交替触发组合模式</a></li></ul> 
  </li><li><a href="#_15___266" rel="nofollow">【 15. 温度传感器 】</a></li><li><a href="#_16___268" rel="nofollow">【 16. 电池充电监测 】</a></li><li><a href="#_17_ADC___270" rel="nofollow">【 17. ADC 中断 】</a></li><li><a href="#_18___276" rel="nofollow">【 18. 寄存器 】</a></li><li><ul><li><a href="#_ADC_SR_277" rel="nofollow">状态寄存器 ADC_SR</a></li><li><a href="#_ADC_CR1ADC_CR2_304" rel="nofollow">控制寄存器 ADC_CR1、ADC_CR2</a></li><li><a href="#_ADC_SMPR1ADC_SMPR2_466" rel="nofollow">采样时间寄存器 ADC_SMPR1、ADC_SMPR2</a></li><li><a href="#_ADC_JOFRx_x14_494" rel="nofollow">注入通道偏移寄存器 ADC_JOFRx (x=1...4)</a></li><li><a href="#_ADC_HTRADC_LTR_500" rel="nofollow">看门狗阈值寄存器 ADC_HTR、ADC_LTR</a></li><li><a href="#_ADC_SQR1ADC_SQR2ADC_SQR3_512" rel="nofollow">规则序列寄存器 ADC_SQR1、ADC_SQR2、ADC_SQR3</a></li><li><a href="#_ADC_JDRx_548" rel="nofollow">注入序列寄存器 ADC_JDRx</a></li><li><a href="#_ADC_DR_572" rel="nofollow">规则数据寄存器 ADC_DR</a></li><li><a href="#_ADC_JSQR_577" rel="nofollow">注入数据寄存器 ADC_JSQR</a></li><li><a href="#_ADC_CSR_583" rel="nofollow">通用状态寄存器 ADC_CSR</a></li><li><a href="#_ADC_CCR_624" rel="nofollow">通用控制寄存器 ADC_CCR</a></li><li><a href="#ADC_ADC_CDR_683" rel="nofollow">适用于双重和三重模式的ADC通用规则数据寄存器 ADC_CDR</a></li></ul> 
  </li><li><a href="#_19___694" rel="nofollow">【 19. 例程 】</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1___1"></a>【 1. 简介 】</h2> 
<ul><li>STM32F4xx 系列一般都有 3 个 ADC，这些 ADC 可以独立使用，也可以使用双重/三重模式（提高采样率）。</li><li><font color="#FF0000">STM32F4 的 ADC 最大的转换速率为 2.4Mhz</font> ，也就是转换时间为 0.41us（在 ADCCLK=36M,采样周期为 3 个 ADC 时钟下得到），<font color="#FF0000">不要让 ADC 的时钟超过 36M，否则将导致结果准确度下降</font> 。</li><li><font color="#FF0000">12位</font> 逐次逼近型，可配置 12位、10位、8位、6位分辨率</li><li>输入范围：<font color="#FF0000">V<sub>REF-</sub> ≤ V<sub>IN</sub> ≤ V<sub>REF+</sub></font></li><li>A/D 转换可以单次、连续、扫描或间断模式执行。</li><li><font color="#FF0000">规则通道</font> 转换器件可产生<font color="#FF0000"> <strong>DMA请求</strong> </font></li><li>模拟看门狗特性可以 <font color="#FF0000">检测输入电压是否超过了用户自定义的阈值上下限</font></li><li>19 个通道，可测量 16 个外部源（复用通道）、 2 个内部源和 Vbat 通道的信号</li><li>ADC结果储存在一个 左对齐/右对齐 的16位数据寄存器中</li><li>STM32F407ZGT6 包含有 3 个 ADC。</li></ul> 
<h2><a id="_2___12"></a>【 2. 通道 】</h2> 
<ul><li>有 <font color="#FF0000"> 19 个通道，可测量 16 个外部源、 2 个内部源和 Vbat 通道的信号</font> 。</li><li>可以将转换分为两组：<strong>规则转换</strong> 和 <strong>注入转换</strong>，<font color="#FF0000"> 规则通道相当于你正常运行的程序，而注入通道呢，就相当于中断</font> 。在你程序正常执行的时候，中断是可以打断你的执行的。同这个类似，注入通道的转换可以打断规则通道的转换， 在注入通道被转换完成之后，规则通道才得以继续转换。</li></ul> 
<blockquote> 
 <p>通过一个形象的例子可以说明： 假如你在家里的院子内放了 5 个温度探头，室内放了 3 个温度探头； 你需要时刻监视室外温度即可，但偶尔你想看看室内的温度；因此你可以使用规则通道组循环扫描室外的 5 个探头并显示 AD 转换结果，当你想看室内温度时，通过一个按钮启动注入转换组(3 个室内探头)并暂时显示室内温度，当你放开这个按钮后，系统又会回到规则通道组继续检测室外温度。从系统设计上，测量并显示室内温度的过程中断了测量并显示室外温度的过程，但程序设计上可以在初始化阶段分别设置好不同的转换组，系统运行中不必再变更循环转换的配置，从而达到两个任务互不干扰和快速切换的结果。可以设想一下，如果没有规则组和注入组的划分，当你按下按钮后，需要从新配置 AD 循环扫描的通道，然后在释放按钮后需再次配置 AD 循环扫描的通道。</p> 
</blockquote> 
<ul><li><font color="#FF0000"><em>每个组包含一个转换序列，该序列可按任意顺序在任意通道上完成</em></font> ，例如，可按以下顺序对序列进行转换： ADC_IN3、ADC_IN8、 ADC_IN2、 ADC_IN2、 ADC_IN0、 ADC_IN2、 ADC_IN2、 ADC_IN15。 
  <ul><li><font color="#FF0000">一个规则转换组最多由 16 个转换构成</font> 。必须在 ADC_SQRx 寄存器中选择转换序列的规则通道及其顺序，规则转换组中的转换总数必须写入 ADC_SQR1 寄存器中的 L[3:0] 位。</li><li><font color="#FF0000">一个注入转换组最多由 4 个转换构成</font> 。必须在 ADC_JSQR 寄存器中选择转换序列的注入通道及其顺序，注入转换组中的转换总数必须写入 ADC_JSQR 寄存器中的 L[1:0] 位。</li></ul> </li><li>STM32F4 其 ADC 的规则通道组最多包含 16 个转换，而注入通道组最多包含 4 个通道。</li><li>如果在转换期间修改 ADC_SQRx 或 ADC_JSQR 寄存器，将复位当前转换并向 ADC 发送一个新的启动脉冲，以转换新选择的组。</li><li>温度传感器、 V<sub>REFINT</sub> 和 V<sub>BAT</sub> 内部通道 
  <ul><li>对于 STM32F40x 和 STM32F41x 器件，温度传感器内部连接到通道 ADC1_IN16。内部参考电压 V<sub>REFINT</sub> 连接到 ADC1_IN17。</li><li>对于 STM23F42x 和 STM32F43x 器件，温度传感器内部连接到与 V<sub>BAT</sub> 共用的通道ADC1_IN18，一次只能选择一个转换（温度传感器或 VBAT）。同时设置了温度传感器和 V<sub>BAT</sub> 转换时，将只进行 V<sub>BAT</sub> 转换。内部参考电压 V<sub>REFINT</sub> 连接到 ADC1_IN17。</li><li>V<sub>BAT</sub> 通道连接到通道 ADC1_IN18，该通道也可转换为注入通道或规则通道。</li><li>注意： 温度传感器、V<sub>REFINT</sub> 和 V<sub>BAT</sub> 通道只在主 ADC1 外设上可用。</li></ul> </li></ul> 
<h2><a id="_3___26"></a>【 3. 单次转换模式 】</h2> 
<p><font color="#FF0000">在单次转换模式下， ADC 执行一次转换</font></p> 
<ul><li> <p>CONT 位为 0 时，可通过以下方式启动此模式</p> 
  <ul><li>将 ADC_CR2 寄存器中的 SWSTART 位置 1（仅适用于规则通道）</li><li>将 JSWSTART 位置 1（适用于注入通道）</li><li>外部触发（适用于规则通道或注入通道）</li></ul> </li><li> <p>完成所选通道的转换之后</p> 
  <ul><li>如果转换了规则通道</li></ul> 
  <ol><li>转换数据存储在 16 位 ADC_DR 寄存器中</li><li>EOC（转换结束）标志置 1</li><li>EOCIE 位置 1 时将产生中断</li></ol> 
  <ul><li>如果转换了注入通道</li></ul> 
  <ol><li>转换数据存储在 16 位 ADC_JDR1 寄存器中</li><li>JEOC（注入转换结束）标志置 1</li><li>JEOCIE 位置 1 时将产生中断</li></ol> </li><li> <p>然后， ADC 停止。</p> </li></ul> 
<h2><a id="_4___43"></a>【 4. 连续转换模式 】</h2> 
<p><font color="#FF0000">在连续转换模式下， ADC 结束一个转换后立即启动一个新的转换</font></p> 
<ul><li>CONT 位为 1 时，可通过外部触发或将 ADC_CR2 寄存器中的 SWSTRT 位置 1 来启动此模式（仅适用于规则通道）。</li><li>每次转换之后： 
  <ul><li>如果转换了规则通道组</li></ul> 
  <ol><li>上次转换的数据存储在 16 位 ADC_DR 寄存器中</li><li>EOC（转换结束）标志置 1</li><li>EOCIE 位置 1 时将产生中断</li></ol> </li><li>注意： 无法连续转换注入通道。连续模式下唯一的例外情况是，注入通道配置为在规则通道之后自动转换（使用 JAUTO 位）。</li></ul> 
<h2><a id="_5___52"></a>【 5. 模拟看门狗 】</h2> 
<ul><li>如果 ADC 转换的模拟电压低于阈值下限或高于阈值上限，则 AWD 模拟看门狗 <font color="#FF0000">状态位会置1</font> 。</li><li>这些阈值在 ADC_HTR 和 ADC_LTR 16 位寄存器的 12 个最低有效位中进行<font color="#FF0000"> 阈值设定</font> 。<br> <img src="https://images2.imgbox.com/63/ff/VxqOjotn_o.png" alt="在这里插入图片描述"></li><li>可以使用 ADC_CR1 寄存器中的 AWDIE 位 <font color="#FF0000"> 使能中断</font>。</li><li>阈值与 ADC_CR2 寄存器中的 ALIGN 位的所选对齐方式无关，在对齐之前，会将模拟电压与阈值上限和下限进行比较。</li><li>表 49 介绍了应如何配置 ADC_CR1 寄存器才能在一个或多个通道上使能模拟看门狗。<br> <img src="https://images2.imgbox.com/79/5f/qigiheT4_o.png" alt="在这里插入图片描述"></li></ul> 
<h2><a id="_6___60"></a>【 6. 扫描模式 】</h2> 
<p>此模式用于 <font color="#FF0000">扫描一组模拟通道</font></p> 
<ul><li>通过将 ADC_CR1 寄存器中的 SCAN 位置 1 来选择扫描模式。将此位置 1 后， ADC 会扫描在 ADC_SQRx 寄存器（对于规则通道）或 ADC_JSQR 寄存器（对于注入通道）中选择的所有通道。为组中的每个通道都执行一次转换，每次转换结束后，会自动转换该组中的下一个通道。</li><li><font color="#FF0000">如果将 CONT 位置 1，规则通道转换不会在组中最后一个所选通道处停止，而是再次从第一个所选通道继续转换</font> 。</li><li>如果将 <font color="#FF0000"> DMA 位置 1</font> ，则在每次规则通道转换之后，均使用直接存储器访问 (DMA) 控制器将转换自规则通道组的数据（存储在 ADC_DR 寄存器中）传输到 SRAM。</li><li>在以下情况下， ADC_SR 寄存器中的 EOC 位置 1： 
  <ul><li>如果 EOCS 位清零，在每个规则组序列转换结束时</li><li>如果 EOCS 位置 1，在每个规则通道转换结束时<br> 从注入通道转换的数据始终存储在 ADC_JDRx 寄存器中。</li></ul> </li></ul> 
<h2><a id="_7___69"></a>【 7. 注入通道管理 】</h2> 
<h3><a id="_70"></a>触发注入</h3> 
<p>要使用触发注入，必须将 ADC_CR1 寄存器中的 JAUTO 位清零。</p> 
<ul><li>通过外部触发或将 ADC_CR2 寄存器中的 SWSTART 位置 1 来启动规则通道组转换。</li><li>如果在规则通道组转换期间出现外部注入触发或者 JSWSTART 位置 1，则当前的转换会复位，并且注入通道序列会切换为单次扫描模式。</li><li>然后，规则通道组的规则转换会从上次中断的规则转换处恢复。</li><li>如果在注入转换期间出现规则事件，注入转换不会中断，但在注入序列结束时会执行规则序列。</li></ul> 
<p>注意： 使用触发注入时，必须确保触发事件之间的间隔长于注入序列。例如，如果序列长度为 30 个ADC 时钟周期（即，采样时间为 3 个时钟周期的两次转换），则触发事件的最小间隔不能小于 31 个 ADC 时钟周期。</p> 
<h3><a id="_78"></a>自动注入</h3> 
<p>如果将 JAUTO 位置 1，则注入组中的通道会在规则组通道之后自动转换。</p> 
<ul><li>这可用于转换最多由 20 个转换构成的序列，这些转换在 ADC_SQRx 和 ADC_JSQR 寄存器中编程。</li><li>在此模式下，必须禁止注入通道上的外部触发。</li><li>如果 CONT 位和 JAUTO 位均已置 1，则在转换规则通道之后会继续转换注入通道。</li></ul> 
<p>注意： <font color="#FF0000">不能同时使用自动注入和不连续采样模式</font></p> 
<h2><a id="_8___85"></a>【 8. 不连续采样模式 】</h2> 
<h3><a id="_86"></a>规则组</h3> 
<ul><li> <p>可将 ADC_CR1 寄存器中的 DISCEN 位置 1 来使能此模式。</p> </li><li> <p>该模式可用于转换含有 n (n≤8)个转换的短序列，该短序列是在 ADC_SQRx 寄存器中选择的转换序列的一部分，可通过写入 ADC_CR1 寄存器中的 DISCNUM[2:0] 位来指定 n 的值。</p> </li><li> <p>出现外部触发时，将启动在 ADC_SQRx 寄存器中选择的接下来 n 个转换，直到序列中的所有转换均完成为止。通过 ADC_SQR1 寄存器中的 L[3:0] 位定义总序列长度。</p> </li></ul> 
<blockquote> 
 <p>示例：<br> n = 3，要转换的通道 = 0、 1、 2、 3、 6、 7、 9、 10<br> 第 1 次触发：转换序列 0、 1、 2<br> 第 2 次触发：转换序列 3、 6、 7<br> 第 3 次触发：转换序列 9、 10 并生成 EOC 事件<br> 第 4 次触发：转换序列 0、 1、 2</p> 
</blockquote> 
<p>注意： 在不连续采样模式下转换规则组时，不会出现翻转。 <font color="#FF0000">转换完所有子组后，下一个触发信号将启动第一个子组的转换</font> 。在上述示例中，第 4 次触发重新转换了第 1 个子组中的通道 0、 1 和 2。</p> 
<h3><a id="_99"></a>注入组</h3> 
<ul><li>可将 ADC_CR1 寄存器中的 JDISCEN 位置 1 来使能此模式。</li><li>在出现外部触发事件之后，可使用该模式逐通道转换在 ADC_JSQR 寄存器中选择的序列。</li><li>出现外部触发时，将启动在 ADC_JSQR 寄存器中选择的下一个通道转换，直到序列中的所有转换均完成为止。通过 ADC_JSQR 寄存器中的 JL[1:0] 位定义总序列长度。</li></ul> 
<blockquote> 
 <p>示例：<br> n = 1，要转换的通道 = 1、 2、 3<br> 第 1 次触发：转换通道 1<br> 第 2 次触发：转换通道 2<br> 第 3 次触发：转换通道 3 并生成 EOC 和 JEOC 事件<br> 第 4 次触发：通道 1</p> 
</blockquote> 
<p>注意： <font color="#FF0000">转换完所有注入通道后，下一个触发信号将启动第一个注入通道的转换</font> 。在上述示例中，第 4 次触发重新转换了第 1 个注入通道。 <font color="#FF0000">不能同时使用自动注入和不连续采样模式。不得同时为规则组和注入组设置不连续采样模式，只能针对一个组使能不连续采样模式</font> 。</p> 
<h2><a id="_9___111"></a>【 9. 数据对齐 】</h2> 
<ul><li>ADC_CR2 寄存器中的 ALIGN 位用于选择转换后存储的数据的对齐方式，可选择左对齐和<br> 右对齐两种方式。</li><li>注入通道组的转换数据将减去 ADC_JOFRx 寄存器中写入的用户自定义偏移量，因此结果可<br> 以是一个负值。 SEXT 位表示扩展的符号值。</li><li>对于规则组中的通道，不会减去任何偏移量，因此只有十二个位有效。<br> <img src="https://images2.imgbox.com/36/f5/y3WTl2Pb_o.png" alt="在这里插入图片描述"></li><li>特例：采用左对齐时，数据基于半字进行对齐，除了分辨率设置为 6 位时。分辨率设置为 6 位<br> 时，数据基于字节进行对齐。<br> <img src="https://images2.imgbox.com/5c/24/MdWQ12Yc_o.png" alt="在这里插入图片描述"></li></ul> 
<h2><a id="_10___121"></a>【 10. 可独立设置各通道采样时间 】</h2> 
<ul><li><font color="#FF0000">ADC 会在数个 ADCCLK时钟周期（可设定）内对输入电压进行采样</font> ，可使用 ADC_SMPR1 和 ADC_SMPR2 寄存器中的 SMP[2:0] 位修改周期数。</li><li>每个通道均可以使用不同的采样时间进行采样。<br> 总转换时间的计算公式如下：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           总 
          
         
           转 
          
         
           换 
          
         
           时 
          
         
           间 
          
          
          
            T 
           
           
           
             c 
            
           
             o 
            
           
             n 
            
           
             v 
            
           
          
         
           = 
          
         
           采 
          
         
           样 
          
         
           时 
          
         
           间 
          
         
           + 
          
         
           12 
          
         
           个 
          
         
           A 
          
         
           D 
          
         
           C 
          
         
           C 
          
         
           L 
          
         
           K 
          
         
           周 
          
         
           期 
          
         
        
          总转换时间 T_{conv} = 采样时间 + 12 个ADCCLK周期 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">换</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord cjk_fallback">采</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.07153em;">K</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">期</span></span></span></span></span></span></li></ul> 
<blockquote> 
 <p>示例：<br> ADCCLK = 30 MHz 且采样时间 = 3 个周期时：<br> T<sub>conv</sub> = 3 + 12 = 15 个周期 = 15* (1/30M) = 0.5 μs（ APB2 为 60 MHz 时）</p> 
</blockquote> 
<h2><a id="_11___129"></a>【 11. 外部触发转换和触发极性 】</h2> 
<ul><li><font color="#FF0000">可以通过外部事件（例如，定时器捕获、 EXTI 中断线）触发转换</font> 。</li><li><font color="#FF0000">可以实时更改外部触发的极性</font> 。如果 EXTEN[1:0] 控制位（对于行规转换）或 JEXTEN[1:0] 位（对于注入转换）不等于 “0b00” ，则外部事件能够以所选极性触发转换。 表 50 提供了 EXTEN[1:0] 和 JEXTEN[1:0] 值与触发极性之间的对应关系。<br> <img src="https://images2.imgbox.com/27/6b/WI7iGohK_o.png" alt="在这里插入图片描述"></li><li><font color="#FF0000">外部触发事件选择</font>：EXTSEL[3:0] 和 JEXTSEL[3:0] 控制位用于从 16 个可能事件中选择可触发规则组转换和注入组转换的事件。<br> <img src="https://images2.imgbox.com/4f/58/Bwux1vNZ_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/04/09/r8o9Cv8M_o.png" alt="在这里插入图片描述"></li><li><font color="#FF0000">可通过将 ADC_CR2 寄存器中的 SWSTART（对于规则转换）或 JSWSTART（对于注入转换）位置 1 来产生 <strong>软件源触发事件</strong></font>。</li><li><font color="#FF0000">可通过注入触发中断规则组转换</font>。</li><li><font color="#FF0000">可以实时更改触发选择</font>。不过，当更改触发选择时，会在 1 个 APB 时钟周期的时间范围内禁止触发检测，这是为了避免在转换期间出现意外检测。</li></ul> 
<h2><a id="_12___138"></a>【 12. 快速转换模式 】</h2> 
<ul><li><font color="#FF0000">可通过降低 ADC 分辨率来执行快速转换</font> 。</li><li>RES 位用于选择数据寄存器中可用的位数，<font color="#FF0000"><strong>每种分辨率的最小转换时间</strong></font> 如下：<br> 12 位： 3 + 12 = 15 ADCCLK 周期<br> 10 位： 3 + 10 = 13 ADCCLK 周期<br> 8 位： 3 + 8 = 11 ADCCLK 周期<br> 6 位： 3 + 6 = 9 ADCCLK 周期</li></ul> 
<h2><a id="_13___145"></a>【 13. 数据管理 】</h2> 
<h3><a id="_DMA_146"></a>使用 DMA</h3> 
<ul><li>多通道转换时DMA起到的作用：由于规则通道组只有一个数据寄存器，因此，对于多个规则通道的转换，使用 DMA 非常有帮助，因为这样可以避免丢失在下一次写入之前还未被读出的 ADC_DR 寄存器中的数据。</li><li>在使能 DMA 模式的情况下（ ADC_CR2 寄存器中的 DMA 位置 1） ，<font color="#FF0000">每完成规则通道组中的一个通道转换后，都会生成一个 DMA 请求</font> 。这样便可将转换的数据从 ADC_DR 寄存器传输到用软件选择的目标位置。</li><li><font color="#FF0000"><strong>溢出错误的影响和解决方法</strong></font>：如果数据丢失（溢出），则会将 ADC_SR 寄存器中的 OVR 位置 1 并生成一个中断（如果 OVRIE 使能位已置 1）。随后会禁止 DMA 传输并且不再接受 DMA 请求。在这种情况下，如果生成 DMA 请求，则会中止正在进行的规则转换并忽略之后的规则触发。随后需要 <font color="#FF0000">将所使用的 DMA 流中的 OVR 标志和 DMAEN 位清零，并重新初始化 DMA 和 ADC</font>，以将需要的转换通道数据传输到正确的存储器单元。只有这样，才能恢复转换并再次使能数据传输。<font color="#FF0000">注入通道转换不会受到溢出错误的影响</font>。</li><li>在 DMA 模式下，<font color="#FF0000">当 OVR = 1 时，传送完最后一个有效数据后会阻止 DMA 请求</font>，这意味着传输到 RAM 的所有数据均被视为有效。</li><li>在<font color="#FF0000">最后一次 DMA 传输（ DMA 控制器的 DMA_SxRTR 寄存器中配置的传输次数）结束时： </font> 
  <ul><li>如果将 ADC_CR2 寄存器中的 DDS 位清零，则不会向 DMA 控制器发出新的 DMA 请求（这可避免产生溢出错误）。不过，硬件不会将 DMA 位清零，必须将该位写入 0 然后写入 1 才能启动新的传输。</li><li>如果将 DDS 位置 1，则可继续生成请求。从而允许在双缓冲区循环模式下配置 DMA。</li></ul> </li><li>在<font color="#FF0000"> 使用 DMA 时将 ADC 从 OVR 状态中恢复</font>，请按以下步骤操作 
  <ul><li>重新初始化 DMA（调整目标地址和 NDTR 计数器）</li><li>将 ADC_SR 寄存器中的 ADC OVR 位清零</li><li>触发 ADC 以开始转换。</li></ul> </li></ul> 
<h3><a id="DMA_158"></a>在不使用DMA的情况下管理转换序列</h3> 
<ul><li>如果转换过程足够慢，则可使用软件来处理转换序列。在这种情况下，必须将 <font color="#FF0000">ADC_CR2 寄存器中的 EOCS 位置 1，才能使 EOC 状态位在每次转换结束时置 1</font>，而不仅是在序列结束时置 1。当 EOCS = 1 时，会自动使能溢出检测。因此，每当转换结束时， EOC 都会置 1，并且可以读取 ADC_DR 寄存器。</li><li>溢出管理与使用 DMA 时的管理相同。</li><li>要在 EOCS 位置 1 时将 ADC 从 OVR 状态中恢复，请按以下步骤操作： 
  <ul><li>将 ADC_SR 寄存器中的 ADC OVR 位清零</li><li>触发 ADC 以开始转换。</li></ul> </li></ul> 
<h3><a id="DMA_164"></a>在不使用DMA和溢出检测的情况下进行转换</h3> 
<p>ADC 在转换一个或多个通道时不是每次都读取数据的情况下，这可能会很有用（例如，存在模拟看门狗时）。为此，必须禁止 DMA (DMA = 0) 并且仅在序列结束 (EOCS = 0) 时才将EOC 位置 1。在此配置中，溢出检测已禁止。</p> 
<h2><a id="_14_ADC__166"></a>【 14. 多重ADC模式 】</h2> 
<ul><li>在具有两个或更多 ADC 的器件中，可使用双重（具有两个 ADC）和三重（具有三个 ADC）ADC 模式</li></ul> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/6c/86/Ajodq6Zg_o.png" alt="在这里插入图片描述"></p> 
 <ul><li>尽管 ADC2 和 ADC3 上存在外部触发，但它们并未显示在此图中。</li><li>在双重 ADC 模式下，不存在 ADC3 从器件部分。ADC 通用数据寄存器 (ADC_CDR) 包含 ADC1 和 ADC2 的规则转换数据。使用全部32 个寄存器位。</li><li>在三重 ADC 模式下， ADC 通用数据寄存器 (ADC_CDR) 包含 ADC1、 ADC2 和 ADC3 的规则转换数据。按照所选的存储顺序使用全部 32 个寄存器位。</li></ul> 
</blockquote> 
<ul><li>在多重 ADC 模式下，通过 ADC1 主器件到 ADC2 和 ADC3 从器件的交替触发或同时触发来启动转换，具体取决于 ADC_CCR 寄存器中的 MULTI[4:0] 位所选的模式。</li><li>在多重 ADC 模式下，<font color="#FF0000">配置外部事件触发转换时，应用必须设置为仅主器件触发而禁止从器件触发</font> ，以防止出现意外触发而启动不需要的从转换。</li><li>可实现以下的多重ADC模式： 
  <ul><li>注入同时模式</li><li>规则同时模式</li><li>交替模式</li><li>交替触发模式</li><li>注入同时模式 + 规则同时模式</li><li>规则同时模式 + 交替触发模式</li></ul> </li><li>在多重 ADC 模式下，可在多模式数据寄存器 (ADC_CDR) 中读取转换的数据。可在多模式状态寄存器 (ADC_CSR) 中读取状态位</li></ul> 
<h3><a id="_ADC__DMA__183"></a>多重 ADC 下的 DMA 模式</h3> 
<p>在多重 ADC 模式下，可将 DMA 配置为使用三种不同的模式来传输转换的数据。在所有情况下，要使用的 DMA 流均连接到 ADC：</p> 
<ul><li> <p>DMA 模式 1： <font color="#FF0000">每发出一个 DMA 请求（一个数据项可用），就会传输一个表示 ADC 转换的数据项的半字</font> 。</p> 
  <ul><li>DMA 模式 1 用于 <font color="#FF0000"><strong>三重规则同时模式</strong></font> 。</li><li>在双重 ADC 模式下，发出第一个请求时传输 ADC1 的数据，发出第二个请求时传输 ADC2 的数据，依次类推。</li><li>在三重 ADC 模式下，发出第一个请求时传输 ADC1 的数据，发出第二个请求时传输ADC2 的数据，发出第三个请求时传输 ADC3 的数据；重复此序列。因此 DMA 首先传输 ADC1 的数据，随后传输 ADC2 的数据，再传输 ADC3 的数据，依次类推。</li><li> 
    <blockquote> 
     <p>示例：<br> 三重规则同时模式：生成 3 个连续的 DMA 请求（每个请求对应一个转换数据项）<br> 第 1 个请求： ADC_CDR[31:0] = ADC1_DR[15:0]<br> 第 2 个请求： ADC_CDR[31:0] = ADC2_DR[15:0]<br> 第 3 个请求： ADC_CDR[31:0] = ADC3_DR[15:0]<br> 第 4 个请求： ADC_CDR[31:0] = ADC1_DR[15:0]</p> 
    </blockquote> </li></ul> </li><li> <p>DMA 模式 2： <font color="#FF0000">每发送一个 DMA 请求（两个数据项可用），就会以字的形式传输表示两个 ADC 转换数据项的两个半字（半字就是16位）</font> 。</p> 
  <ul><li>DMA 模式 2 用于 <font color="#FF0000"> <strong>交替模式和规则同时模式（仅适用于双重 ADC 模式）</strong></font> 。</li><li>在双重 ADC 模式下，发出第一个请求时会传输 ADC2 和 ADC1 的数据（ ADC2 数据占用高位半字， ADC1 数据占用低位半字），依此类推。</li><li>在三重 ADC 模式下，将生成三个 DMA 请求：发出第一个请求时，会传输 ADC2和 ADC1 的数据（ ADC2 数据占用高位半字， ADC1 数据占用低位半字）。发出第二个请求时，会传输 ADC1 和 ADC3 的数据（ ADC1 数据占用高位半字， ADC3数据占用低位半字）。发出第三个请求时，会传输 ADC3 和 ADC2 的数据（ ADC3 数据占用高位半字， ADC2 数据占用低位半字），依此类推。</li></ul> 
  <blockquote> 
   <p>示例：<br> a) 双重交替模式：每当有 2 个数据项可用时，就会生成一个 DMA 请求：<br> 第 1 个请求： ADC_CDR[31:0] = ADC2_DR[15:0] | ADC1_DR[15:0]<br> 第 2 个请求： ADC_CDR[31:0] = ADC2_DR[15:0] | ADC1_DR[15:0]<br> b) 三重交替模式：每当有 2 个数据项可用时，就会生成一个 DMA 请求<br> 第 1 个请求： ADC_CDR[31:0] = ADC2_DR[15:0] | ADC1_DR[15:0]<br> 第 2 个请求： ADC_CDR[31:0] = ADC1_DR[15:0] | ADC3_DR[15:0]<br> 第 3 个请求： ADC_CDR[31:0] = ADC3_DR[15:0] | ADC2_DR[15:0]<br> 第 4 个请求： ADC_CDR[31:0] = ADC2_DR[15:0] | ADC1_DR[15:0]</p> 
  </blockquote> </li><li> <p>DMA 模式 3： 此模式与 DMA 模式 2 相似，唯一的区别是：在这种模式下，<font color="#FF0000"> 每发送一个 DMA 请求（两个数据项可用），就会以半字的形式传输表示两个 ADC 转换数据项的两个字节</font> ，此模式下的数据传输顺序与 DMA 模式 2 相似。</p> 
  <ul><li>DMA 模式 3 用于 <font color="#FF0000"><strong>分辨率为 6 位和 8 位时的交替模式</strong></font> 。</li><li> 
    <blockquote> 
     <p>示例：<br> a) 双重交替模式：每当有 2 个数据项可用时，就会生成一个 DMA 请求<br> 第 1 个请求： ADC_CDR[15:0] = ADC2_DR[7:0] | ADC1_DR[7:0]<br> 第 2 个请求： ADC_CDR[15:0] = ADC2_DR[7:0] | ADC1_DR[7:0]<br> b) 三重交替模式：每当有 2 个数据项可用时，就会生成一个 DMA 请求<br> 第 1 个请求： ADC_CDR[15:0] = ADC2_DR[7:0] | ADC1_DR7:0]<br> 第 2 个请求： ADC_CDR[15:0] = ADC1_DR[7:0] | ADC3_DR[15:0]<br> 第 3 个请求： ADC_CDR[15:0] = ADC3_DR[7:0] | ADC2_DR[7:0]<br> 第 4 个请求： ADC_CDR[15:0] = ADC2_DR[7:0] | ADC1_DR7:0]</p> 
    </blockquote> </li></ul> </li><li> <p>溢出检测：</p> 
  <ul><li><font color="#FF0000">如果在其中一个相关的 ADC（双重和三重模式下的 ADC1 和 ADC2，仅有三重模式时的 ADC3）上检测到溢出，则不再发出 DMA 请求，以确保传输到 RAM 的所有数据都有效</font>。</li><li><font color="#FF0000">对于与某个 ADC 对应的 EOC 位，有时可能会因为此 ADC 的数据寄存器包含有效数据而保持置 1</font> 。</li></ul> </li></ul> 
<h3><a id="_224"></a>注入同时模式</h3> 
<h3><a id="_226"></a>规则同时模式</h3> 
<h3><a id="_228"></a>交替模式</h3> 
<p>此模式只能用于规则组（通常为一个通道）。外部触发源来自 ADC1 的规则通道多路复用器。</p> 
<h4><a id="_ADC__230"></a>双重 ADC 模式</h4> 
<ul><li> <p>出现外部触发之后：</p> 
  <ul><li>ADC1 立即启动</li><li>经过几个 ADC 时钟周期延迟后 ADC2 启动</li></ul> </li><li> <p>交替模式下 2 个转换之间的最小延迟通过 ADC_CCR 寄存器中的 DELAY 位进行配置。但是，如果某个 ADC 的互补 ADC 仍在对其输入进行采样，则该 ADC 无法启动转换（在给定时间内，只有一个 ADC 能够对输入信号采样）。在这种情况下：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            延 
           
          
            迟 
           
          
            时 
           
          
            间 
           
          
            = 
           
          
            采 
           
          
            样 
           
          
            时 
           
          
            间 
           
          
            + 
           
          
            2 
           
          
            个 
           
          
            A 
           
          
            D 
           
          
            C 
           
          
            时 
           
          
            钟 
           
          
            周 
           
          
            期 
           
          
         
           延迟时间=采样时间 + 2 个ADC 时钟周期 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mord cjk_fallback">延</span><span class="mord cjk_fallback">迟</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord cjk_fallback">采</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">钟</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">期</span></span></span></span></span></span></p> 
  <blockquote> 
   <p>例如：如果两个 ADC 的 DELAY = 5 个时钟周期，且采样时间为 15 个时钟周期，则 ADC1 和 ADC2 之间的转换延迟为 17 个时钟周期。</p> 
  </blockquote> </li><li> <p>如果 ADC1 和 ADC2 上的 CONT 位均置 1，则这两个 ADC 所选规则通道会连续进行转换。</p> </li><li> <p>如果转换序列中断（例如 DMA 传输结束时），则必须首先通过在独立模式下进行配置来将多重 ADC 定序器复位（位 DUAL[4:0] = 00000），然后才可以对交替模式进行编程。</p> </li><li> <p>ADC2 生成一个 EOC 中断之后（如果已通过 EOCIE 位使能），会生成一个 32 位 DMA 传输请求（如果 ADC_CCR 寄存器中的 DMA[1:0] 位等于 0b10）。此请求首先会将存储在ADC_CDR 32 位寄存器高位半字中的 ADC2 转换数据传输到 SRAM，然后将存储在寄存器低位半字中的 ADC1 转换数据传输到 SRAM。<br> <img src="https://images2.imgbox.com/40/28/W3VTfAn5_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h4><a id="_ADC__243"></a>三重 ADC 模式</h4> 
<ul><li> <p>出现外部触发之后：</p> 
  <ul><li>ADC1 立即启动</li><li>经过几个 ADC 时钟周期延迟后 ADC2 启动</li><li>在 ADC2 转换经过几个 ADC 时钟周期的延迟后 ADC3 启动</li></ul> </li><li> <p>交替模式下 2 个转换之间的最小延迟通过 ADC_CCR 寄存器中的 DELAY 位进行配置。但是，如果某个 ADC 的互补 ADC 仍在对其输入进行采样，则该 ADC 无法启动转换（ <font color="#FF0000"> 在给定时间内，只有一个 ADC 能够对输入信号采样 </font> ）。在这种情况下：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            延 
           
          
            迟 
           
          
            时 
           
          
            间 
           
          
            = 
           
          
            采 
           
          
            样 
           
          
            时 
           
          
            间 
           
          
            + 
           
          
            2 
           
          
            个 
           
          
            A 
           
          
            D 
           
          
            C 
           
          
            时 
           
          
            钟 
           
          
            周 
           
          
            期 
           
          
         
           延迟时间=采样时间 + 2 个ADC 时钟周期 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mord cjk_fallback">延</span><span class="mord cjk_fallback">迟</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord cjk_fallback">采</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">钟</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">期</span></span></span></span></span></span></p> 
  <blockquote> 
   <p>例如：如果这三个 ADC 的 DELAY = 5 个时钟周期，且采样时间为 15 个时钟周期，则 ADC1、 ADC2 和 ADC3 之间的转换延迟为 17 个时钟周期。</p> 
  </blockquote> </li><li> <p>如果 ADC1、 ADC2 和 ADC3 上的 CONT 位均置 1，则这些 ADC 所选规则通道会连续进行转换。</p> </li><li> <p>如果转换序列中断（例如 DMA 传输结束时），则必须首先通过在独立模式下进行配置来将多重 ADC 定序器复位（位 DUAL[4:0] = 00000），然后才可以对交替模式进行编程。</p> </li><li> <p>在此模式下，每当出现 2 个可用数据项时，就会生成一个 DMA 传输请求（如果 ADC_CCR 寄存器中的 DMA[1:0] 位等于 0b10）。此请求首先会将存储在 ADC_CDR 32 位寄存器低位半字中的第一批转换数据传输到 SRAM，然后将存储在 ADC_CDR 高位半字中的第二批转换数据传输到 SRAM。具体顺序如下：</p> 
  <ul><li>第 1 个请求： ADC_CDR[31:0] = ADC2_DR[15:0] | ADC1_DR[15:0]</li><li>第 2 个请求： ADC_CDR[31:0] = ADC1_DR[15:0] | ADC3_DR[15:0]</li><li>第 3 个请求： ADC_CDR[31:0] = ADC3_DR[15:0] | ADC2_DR[15:0]</li><li>第 4 个请求： ADC_CDR[31:0] = ADC2_DR[15:0] | ADC1_DR[15:0], …<br> <img src="https://images2.imgbox.com/d9/f4/n2KN7t58_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h3><a id="_260"></a>交替触发模式</h3> 
<h3><a id="_262"></a>混合型规则/注入同时模式</h3> 
<h3><a id="_264"></a>规则同时+交替触发组合模式</h3> 
<h2><a id="_15___266"></a>【 15. 温度传感器 】</h2> 
<p>-----不常用，待定更新-----</p> 
<h2><a id="_16___268"></a>【 16. 电池充电监测 】</h2> 
<p>-----不常用，待定更新-----</p> 
<h2><a id="_17_ADC___270"></a>【 17. ADC 中断 】</h2> 
<ul><li>当模拟看门狗状态位和溢出状态位分别置 1 时，规则组和注入组在转换结束时可能会产生中断。可以使用单独的中断使能位以实现灵活性。</li><li>ADC_SR 寄存器中存在另外两个标志，但这两个标志不存在中断相关性： 
  <ul><li>JSTRT（开始转换注入组的通道）</li><li>STRT（开始转换规则组的通道）<br> <img src="https://images2.imgbox.com/ef/94/ED07pajY_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h2><a id="_18___276"></a>【 18. 寄存器 】</h2> 
<h3><a id="_ADC_SR_277"></a>状态寄存器 ADC_SR</h3> 
<p><img src="https://images2.imgbox.com/3a/d8/C7eNupMT_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:6 保留，必须保持复位值</li><li><strong>位 5 OVR： 溢出 (Overrun)</strong><br> 数据丢失时，硬件将该位置 1（在单一模式或双重/三重模式下）。但需要通过软件清零。溢出检测仅在 DMA = 1 或 EOCS = 1 时使能。<br> 0：未发生溢出<br> 1：发生溢出</li><li><strong>位 4 STRT： 规则通道开始标志 (Regular channel start flag)</strong><br> 规则通道转换开始时，硬件将该位置 1。但需要通过软件清零。<br> 0：未开始规则通道转换<br> 1：已开始规则通道转换</li><li><strong>位 3 JSTRT： 注入通道开始标志 (Injected channel start flag)</strong><br> 注入组转换开始时，硬件将该位置 1。但需要通过软件清零。<br> 0：未开始注入组转换<br> 1：已开始注入组转换</li><li><strong>位 2 JEOC： 注入通道转换结束 (Injected channel end of conversion)</strong><br> 组内所有注入通道转换结束时，硬件将该位置 1。但需要通过软件清零。<br> 0：转换未完成<br> 1：转换已完成</li><li><strong>位 1 EOC： 规则通道转换结束 (Regular channel end of conversion)</strong><br> 规则组通道转换结束后，硬件将该位置 1。通过软件或通过读取 ADC_DR 寄存器将该位清零。<br> 0：转换未完成 (EOCS=0) 或转换序列未完成 (EOCS=1)<br> 1：转换已完成 (EOCS=0) 或转换序列已完成 (EOCS=1)</li><li><strong>位 0 AWD： 模拟看门狗标志 (Analog watchdog flag)</strong><br> 当转换电压超过在 ADC_LTR 和 ADC_HTR 寄存器中编程的值时，硬件将该位置 1。但需要通过软件清零。<br> 0：未发生模拟看门狗事件<br> 1：发生模拟看门狗事件</li></ul> 
</blockquote> 
<h3><a id="_ADC_CR1ADC_CR2_304"></a>控制寄存器 ADC_CR1、ADC_CR2</h3> 
<p><img src="https://images2.imgbox.com/77/ba/Zaqjxup3_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位31:27保留，必须保持复位值</li><li><strong>位26 OVRIE:溢出中断使能(Overrun interrupt enable)</strong><br> 通过软件将该位置1和清零可使能/禁止溢出中断。<br> 0:禁止溢出中断<br> 1:使能溢出中断。OVR位置1时产生中断。</li><li><strong>位25:24 RES[1:0]:分辨率(Resolution)</strong><br> 通过软件写入这些位可选择转换的分辨率。<br> 00:12位( 15 ADCCLK周期&gt;<br> 01: 10位( 13 ADCCLK周期&gt;<br> 10:8位( 11 ADCCLK周期&gt;<br> 11:6位(9 ADCCLK周期)</li><li><strong>位23 AWDEN:规则通道上的模拟看门狗使能(Analog watchdog enable on regular channels)</strong><br> 此位由软件置1和清零。<br> 0:在规则通道上禁止模拟看门狗<br> 1:在规则通道上使能模拟看门狗</li><li><strong>位22JAWDEN:注入通道上的模拟看门狗使能(Analog watchdog enable on injected channels)</strong><br> 此位由软件置1和清零。<br> 0:在注入通道上禁止模拟看门狗<br> 1:在注入通道上使能模拟看门狗</li><li>位.21:16 保留，必须保持复位值</li><li><strong>位15:13 DISCNUM[2:0]:不连续采样模式通道计数(Discontinuous mode channel count)</strong><br> 软件将写入这些位，用于定义在接收到外部触发后于不连续采样模式下转换的规则通道数。<br> 000:1个通道<br> 001:2个通道<br> …<br> 111:8个通道</li><li><strong>位12 JDISCEN:注入通道的不连续采样模式(Discontinuous mode on injected channels)</strong><br> 通过软件将该位置1和清零可使能/禁止注入通道的不连续采样模式。<br> 0:禁止注入通道的不连续采样模式<br> 1:使能注入通道的不连续采样模式</li><li><strong>位11 DISCEN:规则通道的不连续采样模式(Discontinuous mode on regular channels)</strong><br> 通过软件将该位置1和清零可使能/禁止规则通道的不连续采样模式。<br> 0:禁止规则通道的不连续采样模式<br> 1:使能规则通道的不连续采样模式</li><li><strong>位10 JAUTO:注入组自动转换(Automatic injected group conversion)</strong><br> 通过软件将该位置1和清零可在规则组转换后分别使能/禁止注入组自动转换。<br> 0:禁止注入组自动转换<br> 1:使能注入组自动转换</li><li><strong>位9 AWDSGL:在扫描模式下使能单一通道上的看门狗(Enable the watchdog on a single channel in scan mode)</strong><br> 通过软件将该位置1和清零可分别使能/禁止通过AWDCH[4:0]位确定的通道上的模拟看门狗。<br> 0:在所有通道上使能模拟看门狗<br> 1:在单一通道上使能模拟看门狗</li><li><strong>位8 SCAN:扫描模式(Scan mode)</strong><br> 通过软件将该位置1和清零可使能/禁止扫描模式。在扫描模式下，转换通过ADC_SQRx或ADC_JSQRx寄存器选择的输入。<br> 0:禁止扫描模式<br> 1:使能扫描模式<br> 注意: EOCIE位置1时将生成EOC中断：如果EOCS位清零，在每个规则组序列转换结束时；如果EOCS位置1，在每个规则通道转换结束时。<br> 注意:JEOCIE位置1时，JEOC中断仅在最后一个通道转换结束时生成。</li><li><strong>位7 JEOCIE:注入通道的中断使能(Interrupt enable for injected channels)</strong><br> 通过软件将该位置1和清零可使能/禁止注入通道的转换结束中断。<br> 0:禁止JEOC中断<br> 1:使能JEoC中断。<br> JEOC位置1时产生中断。</li><li><strong>位6 AWDIE:模拟看门狗中断使能(Analog watchdog interrupt enable)</strong><br> 通过软件将该位置1和清零可使能/禁止模拟看门狗中断。<br> 0:禁止模拟看门狗中断<br> 1:使能模拟看门狗中断</li><li><strong>位5 EOCIE:EOC中断使能(Interrupt enable for EOC)</strong><br> 通过软件将该位置1和清零可使能/禁止转换结束中断。<br> 0:禁止EOC中断<br> 1:使能EOC中断<br> EOC位置1时产生中断。</li><li><strong>位4:0 AWDCH[4:0]:模拟看门狗通道选择位(Analog watchdog channel select bits)</strong><br> 这些位将由软件置1和清零。它们用于选择由模拟看门狗监控的输入通道。<br> 00000:ADC模拟输入通道0<br> 00001:ADC模拟输入通道1<br> …<br> 01111:ADC模拟输入通道15<br> 10000:ADC模拟输入通道16<br> 10001:ADC模拟输入通道17<br> 10010:ADC模拟输入通道18<br> 保留其它值</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/28/c5/gx0rZ5tt_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位31保留，必须保持复位值</li><li><strong>位30 SWSTART:开始转换规则通道(Start conversion of regular channels)</strong><br> 通过软件将该位置1可开始转换，而硬件会在转换开始后将该位清零。我们每次转换（单次转换模式下）都需要向该位写1。<br> 0:复位状态<br> 1:开始转换规则通道<br> 注意:该位只能在ADON= 1时置1，否则不会启动转换。</li><li>位29:28 <strong>EXTEN:规则通道的外部触发使能(External trigger enable for regular channels)</strong><br> 通过软件将这些位置1和清零可选择外部触发极性和使能规则组的触发。<br> 00:禁止触发检测<br> 01:上升沿上的触发检测<br> 10:下降沿上的触发检测<br> 11:上升沿和下降沿上的触发检测</li><li><strong>位.27:24 EXTSEL[3:0]:为规则组选择外部事件(External event select for regular group)</strong><br> 这些位可选择用于触发规则组转换的外部事件。<br> 0000:定时器1 CC1事件<br> 0001:定时器1 CC2事件<br> 0010:定时器1 CC3事件<br> 0011:定时器2 CC2事件<br> 0100:定时器2 CC3事件<br> 0101:定时器2 CC4事件<br> 0110:定时器2 TRGO事件<br> 0111:定时器3 CC1事件<br> 1000:定时器3 TRGO事件<br> 1001:定时器4 CC4事件<br> 1010:定时器5 CC1事件<br> 1011:定时器5 cC2事件<br> 1111:EXTI线11</li><li>位23 保留，必须保持复位值</li><li><strong>位22JswSTART:开始转换注入通道(Start conversion of injected channels)</strong><br> 转换开始后，软件将该位置1，而硬件将该位清零。<br> 0:复位状态<br> 1:开始转换注入通道<br> 注意:该位只能在ADON= 1时置1，否则不会启动转换。</li><li><strong>位21:20 JEXTEN:注入通道的外部触发使能(External trigger enable for injected channels)</strong><br> 通过软件将这些位置1和清零可选择外部触发极性和使能注入组的触发。<br> 00:禁止触发检测<br> 01:上升沿上的触发检测<br> 10:下降沿上的触发检测<br> 11:上升沿和下降沿上的触发检测</li><li><strong>位19:16 JEXTSEL[3:0]:为注入组选择外部事件(External event select for injected group)</strong><br> 这些位可选择用于触发注入组转换的外部事件。<br> 0000:定时器1 CC4事件<br> 0001:定时器1 TRGO事件<br> 0010:定时器2 CC1事件<br> 0011:定时器2 TRGO事件<br> 0100:定时器3 CC2事件<br> 0101:定时器3 CC4事件<br> 0110:定时器4 CC1事件<br> 0111:定时器4 CC2事件<br> 1000:定时器4 CC3事件<br> 1001:定时器4 TRGO事件<br> 1010:定时器5 CC4事件<br> 1011:定时器5 TRGO事件<br> 1100:定时器8 CC2事件<br> 1101:定时器8 CC3事件<br> 1110:定时器8 CC4事件<br> 1111:EXTI线15</li><li>位15:12保留，必须保持复位值。</li><li><strong>位11 ALIGN:数据对齐(Data alignment)</strong><br> 此位由软件置1和清零。请参见图38和图 39。<br> 0:右对齐<br> 1:左对齐</li><li><strong>位10 EOCS:结束转换选择(End of conversion selection)</strong><br> 此位由软件置1和清零。<br> 0:在每个规则转换序列结束时将EOC位置1。溢出检测仅在DMA=1时使能。<br> 1:在每个规则转换结束时将EOC位置1。使能溢出检测。</li><li><strong>位9 DDS:DMA 禁止选择（对于单一ADC模式）(DMA disable selection (for single ADC mode))</strong><br> 此位由软件置1和清零。<br> 0:最后一次传输后不发出新的 DMA请求（在DMA 控制器中进行配置)<br> 1:只要发生数据转换且DMA = 1，便会发出DAM请求</li><li><strong>位8 DMA:直接存储器访问模式(对于单一ADC模式)(Direct memory access mode (for single ADC mode))</strong><br> 此位由软件置1和清零。有关详细信息，请参见DMA控制器一章。<br> 0:禁止DMA模式<br> 1:使能DMA模式</li><li>位7:2保留，必须保持复位值。</li><li><strong>位1CONT:连续转换(Continuous conversion)</strong><br> 此位由软件置1和清零。该位置1时，转换将持续进行，直到该位清零。<br> 0:单次转换模式<br> 1:连续转换模式</li><li><strong>位0 ADON:A/D转换器开启/关闭(A/D Converter ON /OFF)</strong><br> 此位由软件置1和清零。<br> 可通过将 ADON 位置 1 来为 ADC 供电，首次将 ADON 位置 1 时，会将 ADC 从掉电模式中唤醒。<br> 将 ADON 位清零来停止转换并使 ADC 进入掉电模式，在此模式下， ADC 几乎不耗电（只有几 μA）。<br> 0:禁止ADC转换并转至掉电模式<br> 1:使能ADC</li></ul> 
</blockquote> 
<h3><a id="_ADC_SMPR1ADC_SMPR2_466"></a>采样时间寄存器 ADC_SMPR1、ADC_SMPR2</h3> 
<p><img src="https://images2.imgbox.com/81/a8/NhCR69gF_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:27 保留，必须保持复位值。</li><li><strong>位 26:0 SMPx[2:0]： 通道 X 采样时间选择 (Channel x sampling time selection)</strong><br> 通过软件写入这些位可分别为各个通道选择采样时间。在采样周期期间，通道选择位必须保持不变。<br> 000： 3 个周期<br> 001： 15 个周期<br> 010： 28 个周期<br> 011： 56 个周期<br> 100： 84 个周期<br> 101： 112 个周期<br> 110： 144 个周期<br> 111： 480 个周期</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/0e/f1/ua6Rsy4Y_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:30 保留，必须保持复位值。</li><li><strong>位 29:0 SMPx[2:0]： 通道 X 采样时间选择 (Channel x sampling time selection)</strong><br> 通过软件写入这些位可分别为各个通道选择采样时间。在采样周期期间，通道选择位必须保<br> 持不变。<br> 000： 3 个周期<br> 001： 15 个周期<br> 010： 28 个周期<br> 011： 56 个周期<br> 100： 84 个周期<br> 101： 112 个周期<br> 110： 144 个周期<br> 111： 480 个周期</li></ul> 
</blockquote> 
<h3><a id="_ADC_JOFRx_x14_494"></a>注入通道偏移寄存器 ADC_JOFRx (x=1…4)</h3> 
<p><img src="https://images2.imgbox.com/d8/cb/MAOWtS4L_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:12 保留，必须保持复位值</li><li><strong>位 11:0 JOFFSETx[11:0]： 注入通道 X 的数据偏移 (Data offset for injected channel x)</strong><br> 通过软件写入这些位可定义在转换注入通道时从原始转换数据中减去的偏移量。可从ADC_JDRx 寄存器中读取转换结果。</li></ul> 
</blockquote> 
<h3><a id="_ADC_HTRADC_LTR_500"></a>看门狗阈值寄存器 ADC_HTR、ADC_LTR</h3> 
<p><img src="https://images2.imgbox.com/c9/cb/2rsIyP7c_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:12 保留，必须保持复位值</li><li><strong>位 11:0 HT[11:0]： 模拟看门狗高阈值 (Analog watchdog higher threshold)</strong><br> 通过软件写入这些位可为模拟看门狗定义高阈值。</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/52/42/fsRUwrXf_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:12 保留，必须保持复位值</li><li><strong>位 11:0 LT[11:0]： 模拟看门狗低阈值 (Analog watchdog lower threshold)</strong><br> 通过软件写入这些位可为模拟看门狗定义低阈值。</li></ul> 
</blockquote> 
<h3><a id="_ADC_SQR1ADC_SQR2ADC_SQR3_512"></a>规则序列寄存器 ADC_SQR1、ADC_SQR2、ADC_SQR3</h3> 
<p><img src="https://images2.imgbox.com/2d/a1/pZa2x4bv_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:24 保留，必须保持复位值</li><li><strong>位 23:20 L[3:0]： 规则通道序列长度 (Regular channel sequence length)</strong><br> 通过软件写入这些位可定义规则通道转换序列中的转换总数。<br> 0000： 1 次转换<br> 0001： 2 次转换<br> …<br> 1111： 16 次转换</li><li><strong>位 19:15 SQ16[4:0]： 规则序列中的第十六次转换 (16th conversion in regular sequence)</strong><br> 通过软件写入这些位，并将通道编号 (0…18) 分配为转换序列中的第十六次转换。</li><li><strong>位 14:10 SQ15[4:0]： 规则序列中的第十五次转换 (15th conversion in regular sequence)</strong></li><li><strong>位 9:5 SQ14[4:0]： 规则序列中的第十四次转换 (14th conversion in regular sequence)</strong></li><li><strong>位 4:0 SQ13[4:0]： 规则序列中的第十三次转换 (13th conversion in regular sequence)</strong></li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/40/99/XSEVzXtW_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:30 保留，必须保持复位值</li><li><strong>位 29:26 SQ12[4:0]： 规则序列中的第十二次转换 (12th conversion in regular sequence)</strong><br> 通过软件写入这些位，并将通道编号 (0…18) 分配为序列中的第十二次转换。</li><li><strong>位 24:20 SQ11[4:0]： 规则序列中的第十一次转换 (11th conversion in regular sequence)</strong></li><li><strong>位 19:15 SQ10[4:0]： 规则序列中的第十次转换 (10th conversion in regular sequence)</strong></li><li><strong>位 14:10 SQ9[4:0]： 规则序列中的第九次转换 (9th conversion in regular sequence)</strong></li><li><strong>位 9:5 SQ8[4:0]： 规则序列中的第八次转换 (8th conversion in regular sequence)</strong></li><li><strong>位 4:0 SQ7[4:0]： 规则序列中的第七次转换 (7th conversion in regular sequence)</strong></li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/78/64/gXnqDc85_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:30 保留，必须保持复位值</li><li><strong>位 29:25 SQ6[4:0]： 规则序列中的第六次转换 (6th conversion in regular sequence)</strong><br> 通过软件写入这些位，并将通道编号 (0…18) 分配为序列中的第六次转换。</li><li><strong>位 24:20 SQ5[4:0]： 规则序列中的第五次转换 (5th conversion in regular sequence)</strong></li><li><strong>位 19:15 SQ4[4:0]： 规则序列中的第四次转换 (4th conversion in regular sequence)</strong></li><li><strong>位 14:10 SQ3[4:0]： 规则序列中的第三次转换 (3rd conversion in regular sequence)</strong></li><li><strong>位 9:5 SQ2[4:0]： 规则序列中的第二次转换 (2nd conversion in regular sequence)</strong></li><li><strong>位 4:0 SQ1[4:0]： 规则序列中的第一次转换 (1st conversion in regular sequence)</strong></li></ul> 
</blockquote> 
<h3><a id="_ADC_JDRx_548"></a>注入序列寄存器 ADC_JDRx</h3> 
<p><img src="https://images2.imgbox.com/0e/ae/9VDWaAXu_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:22 保留，必须保持复位值</li><li><strong>位 21:20 JL[1:0]： 注入序列长度 (Injected sequence length)</strong><br> 通过软件写入这些位可定义注入通道转换序列中的转换总数。<br> 00： 1 次转换<br> 01： 2 次转换<br> 10： 3 次转换<br> 11： 4 次转换</li><li><strong>位 19:15 JSQ4[4:0]： 注入序列中的第四次转换 (4th conversion in injected sequence)</strong><br> （当 JL[1:0] = 3 时，请参见下方的注释）<br> 通过软件写入这些位，并将通道编号 (0…18) 分配为序列中的第四次转换。</li><li><strong>位 14:10 JSQ3[4:0]： 注入序列中的第三次转换 (3rd conversion in injected sequence)</strong><br> （当 JL[1:0] = 3 时，请参见下方的注释）</li><li><strong>位 9:5 JSQ2[4:0]： 注入序列中的第二次转换 (2nd conversion in injected sequence)</strong><br> （当 JL[1:0] = 3 时，请参见下方的注释）</li><li><strong>位 4:0 JSQ1[4:0]： 注入序列中的第一次转换 (1st conversion in injected sequence)</strong><br> （当 JL[1:0] = 3 时，请参见下方的注释）</li><li><strong>注意</strong><br> 当 JL[1:0] = 3（定序器中有 4 次注入转换）时， ADC 将按以下顺序转换通道： JSQ1[4:0]、JSQ2[4:0]、 JSQ3[4:0] 和 JSQ4[4:0]。<br> 当 JL = 2（定序器中有 3 次注入转换）时， ADC 将按以下顺序转换通道： JSQ2[4:0]、JSQ3[4:0] 和 JSQ4[4:0]。<br> 当 JL = 1（定序器中有 2 次注入转换）时， ADC 转换通道的顺序为：先是 JSQ3[4:0]，而后是JSQ4[4:0]。<br> 当 JL = 0（定序器中有 1 次注入转换）时， ADC 将仅转换 JSQ4[4:0] 通道。</li></ul> 
</blockquote> 
<h3><a id="_ADC_DR_572"></a>规则数据寄存器 ADC_DR</h3> 
<p><img src="https://images2.imgbox.com/ad/9c/qjxXcBUL_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:16 保留，必须保持复位值</li><li><strong>位 15:0 DATA[15:0]： 规则数据 (Regular data)</strong><br> 这些位为只读。它们包括来自规则通道的转换结果。数据有左对齐和右对齐两种方式。</li></ul> 
</blockquote> 
<h3><a id="_ADC_JSQR_577"></a>注入数据寄存器 ADC_JSQR</h3> 
<p><img src="https://images2.imgbox.com/b9/1b/zE0xrwX8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6b/a2/8P9HLySl_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:16 保留，必须保持复位值。</li><li><strong>位 15:0 JDATA[15:0]： 注入数据 (Injected data)</strong><br> 这些位为只读。它们包括来自注入通道 X 的转换结果。 数据有左对齐和右对齐两种方式。</li></ul> 
</blockquote> 
<h3><a id="_ADC_CSR_583"></a>通用状态寄存器 ADC_CSR</h3> 
<p><img src="https://images2.imgbox.com/e7/30/QKuUxWwF_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位 31:22 保留，必须保持复位值</li><li><strong>位 21 OVR3： ADC3 的溢出标志 (Overrun flag of ADC3)</strong><br> 该位是 ADC3_SR 寄存器中 OVR 位的副本。</li><li><strong>位 20 STRT3： ADC3 的规则通道开始标志 (Regular channel Start flag of ADC3)</strong><br> 该位是 ADC3_SR 寄存器中 STRT 位的副本。</li><li><strong>位 19 JSTRT3： ADC3 的注入通道开始标志 (Injected channel Start flag of ADC3)</strong><br> 该位是 ADC3_SR 寄存器中 JSTRT 位的副本。</li><li><strong>位 18 JEOC3： ADC3 的注入通道转换结束 (Injected channel end of conversion of ADC3)</strong><br> 该位是 ADC3_SR 寄存器中 JEOC 位的副本。</li><li><strong>位 17 EOC3： ADC3 的转换结束 (End of conversion of ADC3)</strong><br> 该位是 ADC3_SR 寄存器中 EOC 位的副本。</li><li><strong>位 16 AWD3： ADC3 的模拟看门狗标志 (Analog watchdog flag of ADC3)</strong><br> 该位是 ADC3_SR 寄存器中 AWD 位的副本。</li><li>位 15:14 保留，必须保持复位值</li><li><strong>位 13 OVR2： ADC2 的溢出标志 (Overrun flag of ADC2)</strong><br> 该位是 ADC2_SR 寄存器中 OVR 位的副本。</li><li><strong>位 12 STRT2： ADC2 的规则通道开始标志 (Regular channel Start flag of ADC2)</strong><br> 该位是 ADC2_SR 寄存器中 STRT 位的副本。</li><li><strong>位 11 JSTRT2： ADC2 的注入通道开始标志 (Injected channel Start flag of ADC2)</strong><br> 该位是 ADC2_SR 寄存器中 JSTRT 位的副本。</li><li><strong>位 10 JEOC2： ADC2 的注入通道转换结束 (Injected channel end of conversion of ADC2)</strong><br> 该位是 ADC2_SR 寄存器中 JEOC 位的副本。</li><li><strong>位 9 EOC2： ADC2 转换结束 (End of conversion of ADC2)</strong><br> 该位是 ADC2_SR 寄存器中 EOC 位的副本。</li><li><strong>位 8 AWD2： ADC2 的模拟看门狗标志 (Analog watchdog flag of ADC2)</strong><br> 该位是 ADC2_SR 寄存器中 AWD 位的副本。</li><li>位 7:6 保留，必须保持复位值</li><li><strong>位 5 OVR1： ADC1 的溢出标志 (Overrun flag of ADC1)</strong><br> 该位是 ADC1_SR 寄存器中 OVR 位的副本。</li><li><strong>位 4 STRT1： ADC1 的规则通道开始标志 (Regular channel Start flag of ADC1)</strong><br> 该位是 ADC1_SR 寄存器中 STRT 位的副本。</li><li><strong>位 3 JSTRT1： ADC1 的注入通道开始标志 (Injected channel Start flag of ADC1)</strong><br> 该位是 ADC1_SR 寄存器中 JSTRT 位的副本。</li><li><strong>位 2 JEOC1： ADC1 的注入通道转换结束 (Injected channel end of conversion of ADC1)</strong><br> 该位是 ADC1_SR 寄存器中 JEOC 位的副本。</li><li><strong>位 1 EOC1： ADC1 的转换结束 (End of conversion of ADC1)</strong><br> 该位是 ADC1_SR 寄存器中 EOC 位的副本。</li><li><strong>位 0 AWD1： ADC1 的模拟看门狗标志 (Analog watchdog flag of ADC1)</strong><br> 该位是 ADC1_SR 寄存器中 AWD 位的副本。</li></ul> 
</blockquote> 
<h3><a id="_ADC_CCR_624"></a>通用控制寄存器 ADC_CCR</h3> 
<p><img src="https://images2.imgbox.com/05/22/G3HVWkg8_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>位31:24保留，必须保持复位值</li><li><strong>位23 TSVREFE:温度传感器和VREFINT使能(Temperature sensor and VREFINT enable)</strong><br> 通过软件将该位置1和清零可使能/禁止温度传感器和VREFINT通道。<br> 0:禁止温度传感器和VREFINT通道<br> 1:使能温度传感器和VREFINT通道<br> 对于STM32F42x 和STM32F43x 器件，当TSVREFE位置1时必须禁止VBATE。两个位同时置1时，仅进行VBAT转换。</li><li><strong>位22 VBATE:VBAT使能(VBAT enable)</strong><br> 通过软件将该位置1和清零可使能/禁止 VBAT通道。<br> 0:禁止VBAT通道<br> 1:使能VBT通道</li><li>位21:18 保留，必须保持复位值</li><li><strong>位17:16ADCPRE:ADC预分频器(ADCprescaler)</strong><br> 由软件置1和清零，以选择ADC的时钟频率。该时钟为所有ADC所共用。<br> 00:PCLK2：2分频<br> 01:PCLK2：4分频<br> 10: PCLK2：6分频<br> 11: PCLK2：8分频</li><li><strong>位15:14 DMA:直接存储器访问模式(对于多个ADC模式)(Direct memory access mode for multi ADC mode)</strong><br> 此位由软件置1和清零。有关详细信息，请参见DMA控制器一节。<br> 00:禁止 DMA模式<br> 01:使能DMA模式1(依次2/3半字-1、2、3依次进行)<br> 10:使能DMA模式2（成对2/3半字-2和1、1和3、3和2依次进行)<br> 11:使能DMA模式3（成对2/3字节-2和1、1和3、3和2依次进行)</li><li><strong>位13 DDS:DMA禁止选择（对于多个ADC模式)(DMA disable selection (for multi-ADC mode))</strong><br> 此位由软件置1和清零。<br> 0:最后一次传输后不发出新的DMA请求(在DMA 控制器中进行配置)DMA位不通过硬件清零，但必须在生成新的DMA请求前，通过软件清零并设置为需要的模式。<br> 1:只要数据发生转换且DMA = 01、10或11，便会发出 DMA请求。</li><li>位12保留，必须保持复位值。</li><li><strong>位11:8 DELAY:2个采样阶段之间的延迟(Delay between 2 sampling phases)</strong><br> 由软件置1和清零。这些位在双重或三重交错模式下使用。<br> 0000: 5 * T<sub>ADCCLK</sub><br> 0001: 6 * T<sub>ADCCLK</sub><br> 0010: 7 * T<sub>ADCCLK</sub><br> …<br> 1111:20 * T<sub>ADCCLK</sub></li><li>位7:5 保留，必须保持复位值</li><li><strong>位4:0 MULTI[4:0]:多重ADC模式选择(Multi ADC mode selection)</strong><br> 通过软件写入这些位可选择操作模式，所有ADC均独立。<br> 00000:独立模式<br> 00001到01001:双重模式，ADC1和ADC2一起工作，ADC3独立<br> 00001:规则同时＋注入同时组合模式<br> 00010:规则同时＋交替触发组合模式<br> 00011:Reserved<br> 00101:仅注入同时模式<br> 00110:仅规则同时模式仅交错模式<br> 01001:仅交替触发模式<br> 10001到11001:三重模式:ADC1、ADC2和 ADC3一起工作<br> 10001:规则同时＋注入同时组合模式<br> 10010:规则同时＋交替触发组合模式<br> 10011: Reserved<br> 10101:仅注入同时模式<br> 10110:仅规则同时模式仅交错模式<br> 仅交错模式<br> 11001:仅交替触发模式<br> 其它所有组合均需保留且不允许编程<br> 在多重模式下，更改通道配置会生成中止，进而导致同步丢失。建议在更改配置前禁用多重ADC模式。</li></ul> 
</blockquote> 
<h3><a id="ADC_ADC_CDR_683"></a>适用于双重和三重模式的ADC通用规则数据寄存器 ADC_CDR</h3> 
<p><img src="https://images2.imgbox.com/d5/b5/Ylsr1Vuk_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li><strong>位 31:16 DATA2[15:0]： 规则转换对中的第二个数据项 (2nd data item of a pair of regular conversions)</strong><br> 在双重模式下，这些位包含 ADC2 的规则数据。请参见双重 ADC 模式。<br> 在三重模式下，这些位还可以包含 ADC2、 ADC1 和 ADC3 的规则数据。请参见三重 ADC<br> 模式。</li><li><strong>位 15:0 DATA1[15:0]：规则转换对中的第一个数据项 (1st data item of a pair of regular conversions)</strong><br> 在双重模式下，这些位包含 ADC1 的规则数据。请参见双重 ADC 模式。<br> 在三重模式下，这些位还可以包含 ADC1、 ADC3 和 ADC2 的规则数据。请参见三重 ADC<br> 模式。</li></ul> 
</blockquote> 
<h2><a id="_19___694"></a>【 19. 例程 】</h2> 
<pre><code class="prism language-cpp"><span class="token comment">//adc.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"adc.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"delay.h"</span>		 </span>

<span class="token comment">//初始化ADC															   </span>
<span class="token keyword">void</span>  <span class="token function">Adc_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>    
    GPIO_InitTypeDef  GPIO_InitStructure<span class="token punctuation">;</span>
	ADC_CommonInitTypeDef ADC_CommonInitStructure<span class="token punctuation">;</span>
	ADC_InitTypeDef       ADC_InitStructure<span class="token punctuation">;</span>
	
  <span class="token function">RCC_AHB1PeriphClockCmd</span><span class="token punctuation">(</span>RCC_AHB1Periph_GPIOA<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使能GPIOA时钟</span>
  <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_ADC1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//使能ADC1时钟</span>

  <span class="token comment">//先初始化ADC1通道5 IO口</span>
  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_5<span class="token punctuation">;</span><span class="token comment">//PA5 通道5</span>
  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AN<span class="token punctuation">;</span><span class="token comment">//模拟输入</span>
  GPIO_InitStructure<span class="token punctuation">.</span>GPIO_PuPd <span class="token operator">=</span> GPIO_PuPd_NOPULL <span class="token punctuation">;</span><span class="token comment">//不带上下拉</span>
  <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化  </span>
 
  <span class="token function">RCC_APB2PeriphResetCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_ADC1<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>	  <span class="token comment">//ADC1复位</span>
  <span class="token function">RCC_APB2PeriphResetCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_ADC1<span class="token punctuation">,</span>DISABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//复位结束	 </span>
 
	
  ADC_CommonInitStructure<span class="token punctuation">.</span>ADC_Mode <span class="token operator">=</span> ADC_Mode_Independent<span class="token punctuation">;</span><span class="token comment">//独立模式</span>
  ADC_CommonInitStructure<span class="token punctuation">.</span>ADC_TwoSamplingDelay <span class="token operator">=</span> ADC_TwoSamplingDelay_5Cycles<span class="token punctuation">;</span><span class="token comment">//两个采样阶段之间的延迟5个时钟</span>
  ADC_CommonInitStructure<span class="token punctuation">.</span>ADC_DMAAccessMode <span class="token operator">=</span> ADC_DMAAccessMode_Disabled<span class="token punctuation">;</span> <span class="token comment">//DMA失能</span>
  ADC_CommonInitStructure<span class="token punctuation">.</span>ADC_Prescaler <span class="token operator">=</span> ADC_Prescaler_Div4<span class="token punctuation">;</span><span class="token comment">//预分频4分频。ADCCLK=PCLK2/4=84(APB2)/4=21Mhz,ADC时钟最好不要超过36Mhz </span>
  <span class="token function">ADC_CommonInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ADC_CommonInitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化</span>
	
  ADC_InitStructure<span class="token punctuation">.</span>ADC_Resolution <span class="token operator">=</span> ADC_Resolution_12b<span class="token punctuation">;</span><span class="token comment">//12位模式</span>
  ADC_InitStructure<span class="token punctuation">.</span>ADC_ScanConvMode <span class="token operator">=</span> DISABLE<span class="token punctuation">;</span><span class="token comment">//非扫描模式	</span>
  ADC_InitStructure<span class="token punctuation">.</span>ADC_ContinuousConvMode <span class="token operator">=</span> DISABLE<span class="token punctuation">;</span><span class="token comment">//关闭连续转换</span>
  ADC_InitStructure<span class="token punctuation">.</span>ADC_ExternalTrigConvEdge <span class="token operator">=</span> ADC_ExternalTrigConvEdge_None<span class="token punctuation">;</span><span class="token comment">//禁止触发检测，使用软件触发</span>
  ADC_InitStructure<span class="token punctuation">.</span>ADC_DataAlign <span class="token operator">=</span> ADC_DataAlign_Right<span class="token punctuation">;</span><span class="token comment">//右对齐	</span>
  ADC_InitStructure<span class="token punctuation">.</span>ADC_NbrOfConversion <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//1个转换在规则序列中 也就是只转换规则序列1 </span>
  <span class="token function">ADC_Init</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ADC_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ADC初始化</span>
	
  <span class="token function">ADC_Cmd</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启AD转换器	</span>

<span class="token punctuation">}</span>				  
<span class="token comment">//获得ADC值</span>
<span class="token comment">//ch: @ref ADC_channels </span>
<span class="token comment">//通道值 0~16取值范围为：ADC_Channel_0~ADC_Channel_16</span>
<span class="token comment">//返回值:转换结果</span>
u16 <span class="token function">Get_Adc</span><span class="token punctuation">(</span>u8 ch<span class="token punctuation">)</span>   
<span class="token punctuation">{<!-- --></span>
	  	<span class="token comment">//设置指定ADC的规则组通道，一个序列，采样时间</span>
	<span class="token function">ADC_RegularChannelConfig</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> ADC_SampleTime_480Cycles <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//ADC1,ADC通道,480个周期,提高采样时间可以提高精确度			    </span>
  
	<span class="token function">ADC_SoftwareStartConv</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//使能指定的ADC1的软件转换启动功能	</span>
	 
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ADC_GetFlagStatus</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">,</span> ADC_FLAG_EOC <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待转换结束</span>

	<span class="token keyword">return</span> <span class="token function">ADC_GetConversionValue</span><span class="token punctuation">(</span>ADC1<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//返回最近一次ADC1规则组的转换结果</span>
<span class="token punctuation">}</span>
<span class="token comment">//获取通道ch的转换值，取times次,然后平均 </span>
<span class="token comment">//ch:通道编号</span>
<span class="token comment">//times:获取次数</span>
<span class="token comment">//返回值:通道ch的times次转换结果平均值</span>
u16 <span class="token function">Get_Adc_Average</span><span class="token punctuation">(</span>u8 ch<span class="token punctuation">,</span>u8 times<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	u32 temp_val<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	u8 t<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>t<span class="token operator">&lt;</span>times<span class="token punctuation">;</span>t<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		temp_val<span class="token operator">+=</span><span class="token function">Get_Adc</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> temp_val<span class="token operator">/</span>times<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

</code></pre> 
<pre><code class="prism language-cpp"><span class="token comment">//main.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sys.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"delay.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"usart.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lcd.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"adc.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span> 
 	u16 adcx<span class="token punctuation">;</span>
	<span class="token keyword">float</span> temp<span class="token punctuation">;</span>
	<span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置系统中断优先级分组2</span>
	<span class="token function">delay_init</span><span class="token punctuation">(</span><span class="token number">168</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//初始化延时函数</span>
	<span class="token function">uart_init</span><span class="token punctuation">(</span><span class="token number">115200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//初始化串口波特率为115200</span>
 	<span class="token function">LCD_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//初始化LCD接口</span>
	<span class="token function">Adc_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//初始化ADC</span>
	POINT_COLOR<span class="token operator">=</span>RED<span class="token punctuation">;</span> 
	<span class="token function">LCD_ShowString</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">70</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token string">"ADC TEST"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	POINT_COLOR<span class="token operator">=</span>BLUE<span class="token punctuation">;</span><span class="token comment">//设置字体为蓝色</span>
	<span class="token function">LCD_ShowString</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">130</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token string">"ADC1_CH5_VAL:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	      
	<span class="token function">LCD_ShowString</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">150</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token string">"ADC1_CH5_VOL:0.000V"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//先在固定位置显示小数点      </span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span> 
		adcx<span class="token operator">=</span><span class="token function">Get_Adc_Average</span><span class="token punctuation">(</span>ADC_Channel_5<span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取通道5的转换值，20次取平均</span>
		<span class="token function">LCD_ShowxNum</span><span class="token punctuation">(</span><span class="token number">134</span><span class="token punctuation">,</span><span class="token number">130</span><span class="token punctuation">,</span>adcx<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//显示ADCC采样后的原始值</span>
		temp<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>adcx<span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">3.3</span><span class="token operator">/</span><span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//获取计算后的带小数的实际电压值，比如3.1111</span>
		adcx<span class="token operator">=</span>temp<span class="token punctuation">;</span>                            <span class="token comment">//赋值整数部分给adcx变量，因为adcx为u16整形</span>
		<span class="token function">LCD_ShowxNum</span><span class="token punctuation">(</span><span class="token number">134</span><span class="token punctuation">,</span><span class="token number">150</span><span class="token punctuation">,</span>adcx<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//显示电压值的整数部分，3.1111的话，这里就是显示3</span>
		temp<span class="token operator">-=</span>adcx<span class="token punctuation">;</span>                           <span class="token comment">//把已经显示的整数部分去掉，留下小数部分，比如3.1111-3=0.1111</span>
		temp<span class="token operator">*=</span><span class="token number">1000</span><span class="token punctuation">;</span>                           <span class="token comment">//小数部分乘以1000，例如：0.1111就转换为111.1，相当于保留三位小数。</span>
		<span class="token function">LCD_ShowxNum</span><span class="token punctuation">(</span><span class="token number">150</span><span class="token punctuation">,</span><span class="token number">150</span><span class="token punctuation">,</span>temp<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">0X80</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//显示小数部分（前面转换为了整形显示），这里显示的就是111.</span>
		<span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d07daae9837556a730f793e6e94f83c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">unix网络编程：大端小端、常用的函数细节、inetd介绍、select函数到epoll函数的变化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ed25ac7adb477e9f9bf91c77632a5293/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【微信小程序/事件】事件响应的各种场景</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>