<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL之临时表 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL之临时表" />
<meta property="og:description" content="写在前面 本文一起看下MySQL的临时表。
1：什么是临时表 通过create temporary table t语句创建的表，就是临时表，临时表的临时体现在其生命周期是和会话一样的，当会话结束，即连接关闭时MySQL会自动将创建的临时表执行删除操作，如下：
mysql&gt; create temporary table t_tmp(age int)engine=innodb; Query OK, 0 rows affected (0.07 sec) mysql&gt; show create table t_tmp; &#43;-------&#43;----------------------------------------------------------------------------------------------------&#43; | Table | Create Table | &#43;-------&#43;----------------------------------------------------------------------------------------------------&#43; | t_tmp | CREATE TEMPORARY TABLE `t_tmp` ( `age` int(11) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8 | &#43;-------&#43;----------------------------------------------------------------------------------------------------&#43; 1 row in set (0.03 sec) 虽然临时表的生命周期是会话级别的，但是在程序中显式的删除临时表永远是一个我们必须要做的动作(删除也是使用drop table语句如：drop table t_tmp;)，因为你不能保证任何场景下你所创建的临时表都会被合理的删除，比如使用线程池时，此时就不仅仅是临时表没有被删除而占用资源的问题了，还会因为后续的程序读取到前面程序在临时表中的数据，而造成bug，而且这种bug是很难发现的。所以，养成好习惯是很重要的。
2：临时表和内存表 内存表
内存表指的是存储引擎为memory的表，建表语句是create table t()engine=memory,数据是保存在内存中的，因此如果是重启的话，数据不会保留，但表结构是保留的，可以看到，内存表就是正常的表，只不过是存储引擎为memory，且重启后数据不会保留，如下测试： mysql&gt; create table t_memory(id int primary key auto_increment)engine=memory; Query OK, 0 rows affected (0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2bfee10314e24aa8d051c9838a3e9cf1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-07T11:43:28+08:00" />
<meta property="article:modified_time" content="2023-03-07T11:43:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL之临时表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>写在前面</h3> 
<p>本文一起看下MySQL的临时表。</p> 
<h3><a id="1_2"></a>1：什么是临时表</h3> 
<p>通过create temporary table t语句创建的表，就是临时表，临时表的<code>临时</code>体现在其生命周期是和会话一样的，当会话结束，即连接关闭时MySQL会自动将创建的临时表执行删除操作，如下：</p> 
<pre><code>mysql&gt; create temporary table t_tmp(age int)engine=innodb;
Query OK, 0 rows affected (0.07 sec)

mysql&gt; show create table t_tmp;
+-------+----------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                       |
+-------+----------------------------------------------------------------------------------------------------+
| t_tmp | CREATE TEMPORARY TABLE `t_tmp` (
  `age` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+-------+----------------------------------------------------------------------------------------------------+
1 row in set (0.03 sec)
</code></pre> 
<blockquote> 
 <p>虽然临时表的生命周期是会话级别的，但是在程序中显式的删除临时表永远是一个我们必须要做的动作<code>(删除也是使用drop table语句如：drop table t_tmp;)</code>，因为你不能保证任何场景下你所创建的临时表都会被合理的删除，比如使用线程池时，此时就不仅仅是临时表没有被删除而占用资源的问题了，还会因为后续的程序读取到前面程序在临时表中的数据，而造成bug，而且这种bug是很难发现的。所以，养成好习惯是很重要的。</p> 
</blockquote> 
<h3><a id="2_21"></a>2：临时表和内存表</h3> 
<ul><li>内存表<br> 内存表指的是存储引擎为memory的表，建表语句是create table t()engine=memory,数据是保存在内存中的，因此如果是重启的话，数据不会保留，但表结构是保留的，可以看到，内存表就是正常的表，只不过是存储引擎为memory，且重启后数据不会保留，如下测试：</li></ul> 
<pre><code>mysql&gt; create table t_memory(id int primary key auto_increment)engine=memory;
Query OK, 0 rows affected (0.08 sec)

mysql&gt; insert into t_memory value();
Query OK, 1 row affected (0.04 sec)

mysql&gt; select * from t_memory;
+----+
| id |
+----+
|  1 |
+----+
1 row in set (0.01 sec)

// 重启
[root@localhost tmp]# service mysql restart
Shutting down MySQL............. SUCCESS! 
Starting MySQL................................................................. SUCCESS! 

// 重启后查看
mysql&gt; show create table t_memory;
+----------+-----------------------------------------------------------------------------------------------------------------------------+
| Table    | Create Table                                                                                                                |
+----------+-----------------------------------------------------------------------------------------------------------------------------+
| t_memory | CREATE TABLE `t_memory` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)
) ENGINE=MEMORY DEFAULT CHARSET=utf8 |
+----------+-----------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; select * from t_memory;
Empty set (0.00 sec)
</code></pre> 
<ul><li>临时表<br> 可以是任何存储引擎，但是生命周期和会话绑定，并且不同会话可以创建相同名称的临时表，具体我们在后面继续来分析。</li></ul> 
<h3><a id="3_61"></a>3：临时表的特点</h3> 
<p>为了便于理解，我们来看下下面这个操作序列：<br> <img src="https://images2.imgbox.com/29/d9/L8UU2v1Y_o.png" alt="在这里插入图片描述"></p> 
<p>总结其特点如下：</p> 
<pre><code>1：语法是create temporary table ...
2：临时表在会话之间是隔离的，即本会话只能看到本会话内创建的临时表
3：临时表可以和普通表同名
4：操作时，存在同名的临时表和普通表时，临时表的优先级高于普通表
5：show tables不会显示临时表，只显示普通表
6：不同会话可以创建同名的临时表
</code></pre> 
<p>其中的特点<code>6：不同会话可以创建同名的临时表</code>当我们在实际业务代码中需要使用中间表的业务中就非常有用了，比如在分库分表场景中聚合不同库和表的数据，此时如果是使用普通表，那么不同的会话并行操作时肯定会出现表名称重复的问题，而使用临时表则会很好的解决这个问题。</p> 
<h3><a id="4_75"></a>4：为什么临时表是可以重名的</h3> 
<p>从前面的分析中我们知道了，不同的会话临时表名称是可以重复的，这是为什么呢？要解释这个问题，必须先来了解下，MySQL是如何判断<code>表是否存在？</code>，每个表都有一个对应的table_def_key，对于普通表table_def_key的定义是<code>库名+表名</code>，因此普通表的表名称不可以重复，而临时表table_def_key的规则是<code>库名+表名+server_id+thread_id</code>，而其中thread_id，每个会话连接都是不一样的，所以，临时表是可以重名的，那么当我们执行语句<code>create temporary table tttt(age int(32))engine=innodb;</code>之后临时表tttt的结构和数据都是如何存储的呢？对于结构是在<code>select @@tmpdir</code>目录下创建名称为<code>#sql{进程 id}_{线程 id}_序列号.frm</code>的文件，如下：</p> 
<pre><code>[root@localhost tmp]# mysql -uroot -p -e"select @@tmpdir"
Enter password: 
+----------+
| @@tmpdir |
+----------+
| /tmp     |
+----------+
[root@localhost tmp]# pwd
/tmp
[root@localhost tmp]# ll | egrep '#sql'
-rw-r----- 1 mysql mysql    8558 Sep  2 16:50 #sql105b4_3_0.frm
</code></pre> 
<p>数据的存放，在5.7之前是在<code>select @@tmpdir</code>目录下创建一个相同前缀的.ibd文件，5.7之后引入了临时文件表空间，数据就存放在这里，就不需要生成ibd文件了。</p> 
<h3><a id="_91"></a>写在后面</h3> 
<p>参考文章列表：</p> 
<p><a href="https://www.runoob.com/mysql/mysql-temporary-tables.html" rel="nofollow">MySQL 临时表</a> 。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/422f1b57e4daa8a1fc50797707ecdf70/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">本地通信实例(AF_UNIX)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/486d4d96fb5726881ce766d67189fe9d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】BloomFilter——布隆过滤器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>