<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>死锁避免策略-银行家算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="死锁避免策略-银行家算法" />
<meta property="og:description" content="文章目录 目录
前言
一、数据结构
二、算法设计
1.流程图
2.C&#43;&#43;实现
前言 银行家算法是由迪杰斯特拉提出在避免死锁的算法，该算法原为银行系统而设计，防止发放现金贷款时不能满足客户需要，在OS中可用于避免进程死锁。
一、数据结构 1.当前可利用资源向量 available
2.最大需求矩阵 max
3.已分配矩阵 allocation
4.剩余需求矩阵 need
5.进程发出的请求向量 request
注：
Need[i,j] = Max[i,j] - allocation[i, j]
二、算法设计 1.流程图 2.C&#43;&#43;实现 //银行家算法 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; /* 当前可利用资源向量 available 最大需求矩阵 max 已分配矩阵 allocation 剩余需求矩阵 need 进程发出的请求向量 request */ void renewavailable(int *available,vector&lt;int&gt; allocation);//更新可利用资源量 bool safe(vector&lt;vector&lt;int&gt;&gt; &amp;max,vector&lt;vector&lt;int&gt;&gt; &amp;allocation,int *available,vector&lt;vector&lt;int&gt;&gt; &amp;need);//安全性算法 int banker_algorithm(vector&lt;vector&lt;int&gt;&gt; max,vector&lt;vector&lt;int&gt;&gt; &amp;allocation,int *available,int *request,int i);//银行家算法 void renewavailable(int *available,vector&lt;int&gt; allocation) { for(int i=0;i&lt;3;i&#43;&#43;) { available[i]&#43;=allocation[i]; } } bool safe(vector&lt;vector&lt;int&gt;&gt; &amp;max,vector&lt;vector&lt;int&gt;&gt; &amp;allocation,int *available,vector&lt;vector&lt;int&gt;&gt; &amp;need) { //设置进程访问标记为，false为未访问 bool tag[5]={false,false,false,false,false}; int count=5; while(count--) { for(int i=0;i&lt;need." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/df41775b5064e318b9bdc45122c323e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-23T15:28:13+08:00" />
<meta property="article:modified_time" content="2023-10-23T15:28:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">死锁避免策略-银行家算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p></p> 
</blockquote> 
<p></p> 
<div> 
 <h4 id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">文章目录</h4> 
 <ul><li> <p id="main-toc"><strong>目录</strong></p> <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> <p id="%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">一、数据结构</a></p> <p id="%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1" rel="nofollow">二、算法设计</a></p> <p id="1.%E6%B5%81%E7%A8%8B%E5%9B%BE-toc" style="margin-left:40px;"><a href="#1.%E6%B5%81%E7%A8%8B%E5%9B%BE" rel="nofollow">1.流程图</a></p> <p id="2.C%2B%2B%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#2.C%2B%2B%E5%AE%9E%E7%8E%B0" rel="nofollow">2.C++实现</a></p> </li><li> <p style="margin-left:40px;"></p> </li></ul> 
</div> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_7"></a>前言</h2> 
<p>银行家算法是由迪杰斯特拉提出在避免死锁的算法，该算法原为银行系统而设计，防止发放现金贷款时不能满足客户需要，在OS中可用于避免进程死锁。</p> 
<hr> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><a id="pandas_16"></a>一、数据结构</h2> 
<p>1.当前可利用资源向量 available</p> 
<p>2.最大需求矩阵    max</p> 
<p>3.已分配矩阵      allocation</p> 
<p>4.剩余需求矩阵    need</p> 
<p>5.进程发出的请求向量 request</p> 
<p>注：</p> 
<p>Need[i,j] = Max[i,j] - allocation[i, j]</p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><a id="_19"></a>二、算法设计</h2> 
<h3 id="1.%E6%B5%81%E7%A8%8B%E5%9B%BE"><a id="1_20"></a>1.流程图</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4a/60/E6jFvJiM_o.png"></p> 
<p></p> 
<h3 id="2.C%2B%2B%E5%AE%9E%E7%8E%B0"><a id="2_34"></a>2.C++实现</h3> 
<pre><code class="language-cpp">//银行家算法
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

/*
当前可利用资源向量 available
最大需求矩阵    max
已分配矩阵      allocation
剩余需求矩阵    need
进程发出的请求向量 request
*/
void renewavailable(int *available,vector&lt;int&gt; allocation);//更新可利用资源量
bool safe(vector&lt;vector&lt;int&gt;&gt; &amp;max,vector&lt;vector&lt;int&gt;&gt; &amp;allocation,int *available,vector&lt;vector&lt;int&gt;&gt; &amp;need);//安全性算法
int banker_algorithm(vector&lt;vector&lt;int&gt;&gt; max,vector&lt;vector&lt;int&gt;&gt; &amp;allocation,int *available,int *request,int i);//银行家算法

void renewavailable(int *available,vector&lt;int&gt; allocation)
{
    for(int i=0;i&lt;3;i++)
    {
        available[i]+=allocation[i];
    }
}


bool safe(vector&lt;vector&lt;int&gt;&gt; &amp;max,vector&lt;vector&lt;int&gt;&gt; &amp;allocation,int *available,vector&lt;vector&lt;int&gt;&gt; &amp;need)
{
    //设置进程访问标记为，false为未访问
    bool tag[5]={false,false,false,false,false};
    int count=5;
    while(count--)
    {
        for(int i=0;i&lt;need.size();i++)
        {
            if(tag[i]==false)
            {
                if(need[i][0]&lt;=available[0] &amp;&amp; need[i][1]&lt;=available[1] &amp;&amp; need[i][2]&lt;=available[2])
                {
                    renewavailable(available,allocation[i]);
                    cout&lt;&lt;"可行性序列P"&lt;&lt;i&lt;&lt;" "&lt;&lt;max[i][0]&lt;&lt;" "&lt;&lt;max[i][1]&lt;&lt;" "&lt;&lt;max[i][2]&lt;&lt;endl;
                    cout&lt;&lt;"当前可利用资源向量"&lt;&lt;available[0]&lt;&lt;" "&lt;&lt;available[1]&lt;&lt;" "&lt;&lt;available[2]&lt;&lt;" "&lt;&lt;endl;
                    tag[i]=true;
                    break;
                }
            }
        }
    }

    for(int i=0;i&lt;5;i++)
    {
        if(tag[i]==false)
        {
            cout&lt;&lt;"无可行性方案"&lt;&lt;endl;
            return false;
        }
    }
    return true;
}


int banker_algorithm(vector&lt;vector&lt;int&gt;&gt; max,vector&lt;vector&lt;int&gt;&gt; &amp;allocation,int *available,int *request,int i)
{
    vector&lt;vector&lt;int&gt;&gt; need;

    //计算剩余需求矩阵need和当前可利用资源向量 available
    for(int i=0;i&lt;allocation.size();i++)
    {
        vector&lt;int&gt; needtemp;
        needtemp.clear();
        for(int j=0;j&lt;allocation[i].size();j++)
        {
            available[j]-=allocation[i][j];
            needtemp.push_back(max[i][j]-allocation[i][j]);
        }
        need.push_back(needtemp);
    }
        
    cout&lt;&lt;endl;

    for(int i=0;i&lt;3;i++)
        cout&lt;&lt;"available "&lt;&lt;available[i]&lt;&lt;" ";
    cout&lt;&lt;endl;
    for(int i=0;i&lt;5;i++)
    {
        for(int j=0;j&lt;3;j++)
        {
            cout&lt;&lt;"max "&lt;&lt;i&lt;&lt;j&lt;&lt;" "&lt;&lt;max[i][j]&lt;&lt;" ";
            cout&lt;&lt;"allocation "&lt;&lt;i&lt;&lt;j&lt;&lt;" "&lt;&lt;allocation[i][j]&lt;&lt;" ";
            cout&lt;&lt;"need "&lt;&lt;i&lt;&lt;j&lt;&lt;" "&lt;&lt;need[i][j]&lt;&lt;" ";
            cout&lt;&lt;endl;
        }
        cout&lt;&lt;endl;
    }

    //max={<!-- -->{7,5,3},{3,2,2},{9,0,2},{2,2,2},{4,3,3}};
    if(request[0]&lt;=need[i][0]&amp;&amp;request[1]&lt;=need[i][1]&amp;&amp;request[2]&lt;=need[i][2])
    {
        if(request[0]&lt;=available[0]&amp;&amp;request[1]&lt;=available[1]&amp;&amp;request[2]&lt;=available[2])
        {
            for(int j=0;j&lt;3;j++)
            {
                available[j]-= request[j];
                allocation[i][j]+=request[j];
                need[i][j]-=request[j];
            }
            cout&lt;&lt;endl;
            if(true==safe(max,allocation,available,need))
            {
                cout&lt;&lt;endl;
                cout&lt;&lt;"系统安全，可将资源进行分配"&lt;&lt;endl;
            }
            else
            {
                cout&lt;&lt;endl;
                cout&lt;&lt;"系统进入不安全状态，不分配资源"&lt;&lt;endl;
            }
        }
        else
        {
            cout&lt;&lt;"资源不够，需要等待"&lt;&lt;endl;
            return 0;
        }
    }
    else
    {
        cout&lt;&lt;"所需资源数超过宣布的最大值"&lt;&lt;endl;
        return 0;
    }
}

int main()
{
    int available[3]={10,5,7};
    int request[3]={1,0,2};

    vector&lt;vector&lt;int&gt;&gt; max;
    max.push_back({7,5,3});
    max.push_back({3,2,2});
    max.push_back({9,0,2});
    max.push_back({2,2,2});
    max.push_back({4,3,3});

    vector&lt;vector&lt;int&gt;&gt; allocation;
    allocation.push_back({0,1,0});
    allocation.push_back({2,0,0});
    allocation.push_back({3,0,2});
    allocation.push_back({2,1,1});
    allocation.push_back({0,0,2});
    
    banker_algorithm(max,allocation,available,request,1);

    return 0;
}</code></pre> 
<p> 调试结果：</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/df/80/JGfyeiZa_o.png"></p> 
<hr> 
<h2><a id="_45"></a></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/39167b2e1403cc402b0ed36ea8c458cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">无偏估计协方差和运行协方差</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59c11b1d0e818e5201fe7a97af43b55b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构之二叉树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>