<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HTTP协与Apache服务的搭建 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HTTP协与Apache服务的搭建" />
<meta property="og:description" content="首先看一张图，在IOS七层模型与TCP/IP四层模型中，HTTP协议所处的位置一目了然，我们来从头开始了解HTTP协议的工作原理。
一个网站有以下几个指标来衡量：
IP(独立IP):即Internet Protocol,指独立IP数。一天内来自 相同客户机IP地址只计算一次，记录远程客户机IP地址的计 算机访问网站的次数，是衡量网站流量的重要指标PV(访问量): 即Page View, 页面浏览量或点击量，用户每 次刷新即被计算一次，PV反映的是浏览某网站的页面数，PV 与来访者的数量成正比，PV并不是页面的来访者数量，而是 网站被访问的页面数量UV(独立访客):即Unique Visitor,访问网站的一台电脑为一 个访客。一天内相同的客户端只被计算一次。可以理解成访问 某网站的电脑的数量。网站判断来访电脑的身份是通过来访电 脑的cookies实现的。如果更换了IP后但不清除cookies，再访 问相同网站，该网站的统计中UV数是不变的
网站统计:http://www.alexa.cn/rank. 一次完整的http请求处理过程 一次完整的http请求处理过程有一下几步：
1、建立连接:接收或拒绝连接请求
2、接收请求:接收客户端请求报文中对某资源的一次请求的过程
Web访问响应模型(Web I/O)
单进程I/O模型:启动一个进程处理用户请求，而且一次只处理一个 ，多个请求被串行响应多进程I/O模型:并行启动多个进程,每个进程响应一个连接请求 复用I/O结构:启动一个进程，同时响应N个连接请求
实现方法:多线程模型和事件驱动 多线程模型:一个进程生成N个线程，每线程响应一个连接请求事件驱动:一个进程处理N个请求 复用的多进程I/O模型:启动M个进程，每个进程响应N个连接请求 ，同时接收M*N个请求 3、处理请求:服务器对请求报文进行解析，并获取请求的资 源及请求方法等相关信息，根据方法，资源，首部和可选的主体部分对请求进行处理
元数据:请求报文首部
&lt;method&gt; &lt;URL&gt; &lt;VERSION&gt; HEADERS
格式 name:value 示例:
Host: www.yangyang.host 请求的主机名称
Server: Apache/2.4.7
HTTP常用请求方式（Method）:
GET、POST、HEAD、PUT、DELETE、TRACE、OPTIONS
**4、访问资源:
服务器获取请求报文中请求的资源web服务器，即存放了web资源的服务器，负责向请求者提供对方请求的静态资源，或动态运行后生成的资源
资源放置于本地文件系统特定的路径:DocRoot
DocRoot
/var/www/html /var/www/html/images/logo.jpg
http://www.magedu.com/images/logo.jpg
web服务器资源路径映射方式:
(a) docroot(b) alias(c) 虚拟主机docroot(d) 用户家目录docroot 5、构建响应报文:
一旦Web服务器识别除了资源，就执行请求方法中描述的 动作，并返回响应报文。响应报文中 包含有响应状态码、响应 首部，如果生成了响应主体的话，还包括响应主体
1)响应实体:如果事务处理产生了响应主体，就将内容放在 响应报文中回送过去。
响应报文中通常包括: 描述了响应主体MIME类型的Content-Type首部描述了响应主体长度的Content-Length实际报文的主体内容 2)URL重定向:web服务构建的响应并非客户端请求的资源 ，而是资源另外一个访问路径 永久重定向:http://www." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dc4ff754e0106b6201de1c7cda93f20e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-21T14:13:32+08:00" />
<meta property="article:modified_time" content="2020-07-21T14:13:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HTTP协与Apache服务的搭建</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>首先看一张图，在IOS七层模型与TCP/IP四层模型中，HTTP协议所处的位置一目了然，我们来从头开始了解HTTP协议的工作原理。</strong><br> <img src="https://images2.imgbox.com/dc/8b/2KnolcKo_o.png" alt="在这里插入图片描述"><br> <strong>一个网站有以下几个指标来衡量：</strong></p> 
<ul><li><strong>IP(独立IP):即Internet Protocol,指独立IP数。一天内来自 相同客户机IP地址只计算一次，记录远程客户机IP地址的计 算机访问网站的次数，是衡量网站流量的重要指标</strong></li><li><strong>PV(访问量): 即Page View, 页面浏览量或点击量，用户每 次刷新即被计算一次，PV反映的是浏览某网站的页面数，PV 与来访者的数量成正比，PV并不是页面的来访者数量，而是 网站被访问的页面数量</strong></li><li><strong>UV(独立访客):即Unique Visitor,访问网站的一台电脑为一 个访客。一天内相同的客户端只被计算一次。可以理解成访问 某网站的电脑的数量。网站判断来访电脑的身份是通过来访电 脑的cookies实现的。如果更换了IP后但不清除cookies，再访 问相同网站，该网站的统计中UV数是不变的<br> 网站统计:<a href="http://www.alexa.cn/rank/" rel="nofollow">http://www.alexa.cn/rank</a>.</strong></li></ul> 
<h3><a id="http_9"></a>一次完整的http请求处理过程</h3> 
<p><strong>一次完整的http请求处理过程有一下几步：</strong></p> 
<ul><li> <p><strong>1、建立连接:接收或拒绝连接请求</strong></p> </li><li> <p><strong>2、接收请求:接收客户端请求报文中对某资源的一次请求的过程</strong><br> <strong>Web访问响应模型(Web I/O)</strong></p> 
  <ul><li><strong>单进程I/O模型:启动一个进程处理用户请求，而且一次只处理一个 ，多个请求被串行响应</strong></li><li><strong>多进程I/O模型:并行启动多个进程,每个进程响应一个连接请求 复用I/O结构:启动一个进程，同时响应N个连接请求</strong><br> <strong>实现方法:多线程模型和事件驱动</strong> 
    <ul><li><strong>多线程模型:一个进程生成N个线程，每线程响应一个连接请求</strong></li><li><strong>事件驱动:一个进程处理N个请求</strong></li></ul> </li><li><strong>复用的多进程I/O模型:启动M个进程，每个进程响应N个连接请求 ，同时接收M*N个请求</strong></li></ul> </li><li> <p><strong>3、处理请求:服务器对请求报文进行解析，并获取请求的资 源及请求方法等相关信息，根据方法，资源，首部和可选的主体部分对请求进行处理</strong><br> <strong>元数据:请求报文首部</strong><br> <strong>&lt;method&gt; &lt;URL&gt; &lt;VERSION&gt; HEADERS</strong><br> <strong>格式 name:value </strong><br> <strong>示例:</strong><br> <strong>Host: www.yangyang.host 请求的主机名称</strong><br> <strong>Server: Apache/2.4.7</strong><br> <strong>HTTP常用请求方式（Method）:<br> GET、POST、HEAD、PUT、DELETE、TRACE、OPTIONS</strong></p> </li><li> <p>**4、访问资源:<br> <strong>服务器获取请求报文中请求的资源web服务器，即存放了web资源的服务器，负责向请求者提供对方请求的静态资源，或动态运行后生成的资源<br> 资源放置于本地文件系统特定的路径:DocRoot<br> DocRoot<br> /var/www/html /var/www/html/images/logo.jpg<br> http://www.magedu.com/images/logo.jpg<br> web服务器资源路径映射方式:</strong></p> 
  <ul><li><strong>(a) docroot</strong></li><li><strong>(b) alias</strong></li><li><strong>(c) 虚拟主机docroot</strong></li><li><strong>(d) 用户家目录docroot</strong></li></ul> </li><li> <p><strong>5、构建响应报文:<br> 一旦Web服务器识别除了资源，就执行请求方法中描述的 动作，并返回响应报文。响应报文中 包含有响应状态码、响应 首部，如果生成了响应主体的话，还包括响应主体</strong></p> 
  <ul><li><strong>1)响应实体:如果事务处理产生了响应主体，就将内容放在 响应报文中回送过去。</strong><br> <strong>响应报文中通常包括:</strong> 
    <ul><li><strong>描述了响应主体MIME类型的Content-Type首部</strong></li><li><strong>描述了响应主体长度的Content-Length</strong></li><li><strong>实际报文的主体内容</strong></li></ul> </li><li><strong>2)URL重定向:web服务构建的响应并非客户端请求的资源 ，而是资源另外一个访问路径</strong> 
    <ul><li><strong>永久重定向:http://www.360buy.com</strong></li><li><strong>临时重定向:http://www.taobao.com</strong></li></ul> </li><li><strong>3)MIME类型:<br> Web服务器要负责确定响应主体的MIME类型。多种配置服务器的方法可将MIME类型与资源管理起来</strong></li><li><strong>魔法分类:Apache web服务器可以扫描每个资源的内容，并 将其与一个已知模式表(被称为魔法文件)进行匹配，以决定每个 文件的MIME类型。这样做可能比较慢，但很方便，尤其是文件 没有标准扩展名时</strong></li><li><strong>显式分类:可以对Web服务器进行配置，使其不考虑文件的 扩展名或内容，强制特定文件或目录内容拥有某个MIME类型</strong></li><li><strong>类型协商: 有些Web服务器经过配置，可以以多种文档格 式来存储资源。在这种情况下，可以配置Web服务器，使其可以 通过与用户的协商来决定使用哪种格式(及相关的MIME类型)"最好"</strong></li></ul> </li><li> <p><strong>6、发送响应报文<br> Web服务器通过连接发送数据时也会面临与接收数据一样 的问题。服务器可能有很多条到各个客户端的连接，有些是空闲 的，有些在向服务器发送数据，还有一些在向客户端回送响应数 据。服务器要记录连接的状态，还要特别注意对持久连接的处理 。对非持久连接而言，服务器应该在发送了整条报文之后，关闭 自己这一端的连接。对持久连接来说，连接可能仍保持打开状态 ，在这种情况下，服务器要正确地计算Content-Length首部， 不然客户端就无法知道响应什么时候结束了</strong></p> </li><li> <p><strong>7、记录日志<br> 最后，当事务结束时，Web服务器会在日志文件中添加一 个条目，来描述已执行的事务</strong></p> </li></ul> 
<h3><a id="Apache__63"></a>Apache 介绍</h3> 
<p><strong>Apache原型是在20世纪90年代初，国家超级计算机应用中心NCSA开发<br> 1995年开源社区发布apache(a patchy server)</strong></p> 
<ul><li> <p><strong>ASF: apache software foundation</strong></p> </li><li> <p><strong>FSF:Free Software Foundation</strong></p> </li><li> <p><strong>特性:</strong></p> 
  <ul><li><strong>高度模块化:core + modules</strong></li><li><strong>DSO: Dynamic Shared Object 动态加/卸载</strong></li><li><strong>MPM:multi-processing module多路处理模块</strong></li></ul> </li></ul> 
<p><strong>MPM工作模式</strong></p> 
<ul><li> <p><strong>prefork:多进程I/O模型，每个进程响应一个请求，默认模型</strong></p> 
  <ul><li><strong>一个主进程:生成和回收n个子进程，创建套接字，不响应请求</strong></li><li><strong>多个子进程:工作work进程，每个子进程处理一个请求;系统初始时 ，预先生成多个空闲进程，等待请求，最大不超过1024个</strong></li></ul> </li><li> <p><strong>worker:复用的多进程I/O模型,多进程多线程，IIS使用此模型</strong></p> 
  <ul><li><strong>一个主进程:生成m个子进程，每个子进程负责生个n个线程，每个线程响应一个请求，并发响应请求:m*n</strong></li></ul> </li><li> <p><strong>event:事件驱动模型(worker模型的变种)</strong></p> 
  <ul><li><strong>一个主进程:生成m个子进程，每个进程直接响应n个请求，并发响应 请求:m*n，有专门的线程来管理这些keep-alive类型的线程，当有真 实请求时，将请求传递给服务线程，执行完毕后，又允许释放。这样增强了高并发场景下的请求处理能力</strong></li></ul> </li><li> <p><strong>httpd-2.2: event 测试版，centos6默认</strong></p> </li><li> <p><strong>httpd-2.4:event 稳定版，centos7默认</strong><br> <img src="https://images2.imgbox.com/cc/50/4p9iqpMG_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<p><strong>实验HTTP短链接<br> telnet 服务器IP 端口<br> GET /index.html HTTP/1.1<br> HOST:3.3.3.3 (随便写)</strong></p> 
<p><strong>服务的配置文件<br> /etc/httpd/conf/httpd.conf<br> 支持长连接 配置文件<br> KeepAlive ON</strong></p> 
<p><strong>启动脚本的配置文件<br> /etc/sysconfig/httpd<br> 去掉下行的注释<br> HTTPD=/usr/sbin/httpd.worker<br> 开启worker模式</strong><br> <strong>具体MPM工作模块设置在主配置文件里</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>IfModule worker.c<span class="token operator">&gt;</span>
StartServers         4
MaxClients         300
MinSpareThreads     25
MaxSpareThreads     75
ThreadsPerChild     25
MaxRequestsPerChild  0
<span class="token operator">&lt;</span>/IfModule<span class="token operator">&gt;</span>
</code></pre> 
<p><strong>访问网页apache，主配置文件里定义的这样格式的文件<br> DirectoryIndex index.html index.html.var<br> 主站点页面文件<br> 当找不到上述格式的文件的时候<br> 默认错误页面显示在这里显示<br> /etc/httpd/conf.d/welcome.conf<br> 把这个文件改名就可以不再显示Apache宣传界面<br> 而 index.html文件在<br> /var/www/error 目录下</strong></p> 
<h3><a id="_128"></a>站点访问控制常见机制</h3> 
<p><strong>可基于两种机制指明对哪些资源进行何种访问控制<br> 访问控制机制有两种:客户端来源地址，用户账号</strong></p> 
<ul><li><strong>文件系统路径:</strong></li></ul> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>Directory “/path<span class="token string">"&gt; 
	...
&lt;/Directory&gt;

&lt;File “/path/file”&gt; 
	... 
&lt;/File&gt;

&lt;FileMatch "</span>PATTERN"<span class="token operator">&gt;</span>
	 <span class="token punctuation">..</span>.
<span class="token operator">&lt;</span>/FileMatch<span class="token operator">&gt;</span> 
</code></pre> 
<p><strong>URL路径:</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>Location <span class="token string">""</span><span class="token operator">&gt;</span> 
<span class="token punctuation">..</span>.
<span class="token operator">&lt;</span>/Location<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span>LocationMatch <span class="token string">""</span><span class="token operator">&gt;</span> 
<span class="token punctuation">..</span>. 
<span class="token operator">&lt;</span>/LocationMatch<span class="token operator">&gt;</span> 
</code></pre> 
<p><strong>示例:</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>FilesMatch <span class="token string">"\.(gif|jpe?g|png)$"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>Files “?at.*”<span class="token operator">&gt;</span> 通配符
<span class="token operator">&lt;</span>Location /status<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>LocationMatch <span class="token string">"/(extra|special)/data"</span><span class="token operator">&gt;</span> 
</code></pre> 
<p><strong>中“基于源地址”实现访问控制</strong><br> <strong>在主配置文件里添加</strong></p> 
<ul><li>（<strong>1) Options:后跟1个或多个以空白字符分隔的选项列表<br> 在选项前的+，- 表示增加或删除指定选项<br> 常见选项:</strong><br> * <strong>Indexes:指明的URL路径下不存在与定义的主页面资源相符的资源文件时，返回索引列表给用户</strong><br> * <strong>FollowSymLinks:允许访问符号链接文件所指向的源文件</strong><br> * <strong>None:全部禁用</strong><br> * <strong>All: 全部允许</strong><br> <strong>示例:</strong></li></ul> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>Directory /web/docs<span class="token operator">&gt;</span>
	Options Indexes FollowSymLinks 
<span class="token operator">&lt;</span>/Directory<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>Directory /web/docs/spec<span class="token operator">&gt;</span> 
	Options FollowSymLinks 
<span class="token operator">&lt;</span>/Directory<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span>Directory /web/docs<span class="token operator">&gt;</span>
	Options Indexes FollowSymLinks 
<span class="token operator">&lt;</span>/Directory<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>Directory /web/docs/spec<span class="token operator">&gt;</span> 
	Options +Includes -Indexes
<span class="token operator">&lt;</span>/Directory<span class="token operator">&gt;</span> 
</code></pre> 
<ul><li><strong>(2) AllowOverride</strong><br> <strong>与访问控制相关的哪些指令可以放在指定目录下的 .htaccess(由AccessFileName指定)文件中，覆盖之前的配置指令</strong><br> <strong>只对&lt;directory&gt;语句有效</strong><br> <strong>AllowOverride All: 所有指令都有效<br> AllowOverride None:.htaccess 文件无效<br> AllowOverride AuthConfig Indexes 除了AuthConfig 和Indexes的其它指令都无法覆盖</strong><br> <strong><mark>写完.htaccess文件之后还需要再配置文件中加入AllowOverride All</mark><br> 例子:</strong></li></ul> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>Directory /web/docs/spec<span class="token operator">&gt;</span> 
	AllowOverride All
<span class="token operator">&lt;</span>/Directory<span class="token operator">&gt;</span> 
</code></pre> 
<ul><li><strong>(3) order和allow、deny</strong><br> <strong>放在directory, .htaccess中</strong><br> <strong>order:定义生效次序;写在后面的表示默认法则</strong></li><li>Order allow,deny</li><li>Order deny,allow<br> <strong>Allow from和Deny from:定义客户端地址</strong><br> <strong>客户端地址: IP<br> 网络: 172.16<br> 172.16.0.0<br> 172.16.0.0/16<br> 172.16.0.0/255.255.0.0</strong><br> <strong>例子</strong></li></ul> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>Directory /web/docs/spec<span class="token operator">&gt;</span> 
	order deny,allow
	deny from 172.16.0.0/16
<span class="token operator">&lt;</span>/Directory<span class="token operator">&gt;</span> 
</code></pre> 
<p><strong><mark>这里的deny,allow的顺序非常重要</mark></strong></p> 
<ul><li> <p><strong><mark>deny,allow的意思是没有被明确拒绝的都允许</mark></strong><br> <strong>order deny,allow<br> deny from 172.16.0.0/16</strong><br> <strong>除了172.16.0.0/16都允许</strong></p> </li><li> <p><strong>allow,deny的意思是没有被明确允许的都拒绝</strong><br> <strong>order allow,deny<br> deny from 172.16.0.0/16<br> 所有都拒绝</strong></p> </li><li> <p><strong>order allow,deny<br> deny from 172.16.0.0/16<br> allow from 172.16.0.0/16</strong><br> <strong>172.16.0.0/16被允许，如果有冲突，以排在后面的基准，优先级高</strong><br> <strong>如下表：</strong></p> 
  <table><thead><tr><th>空</th><th>allow deny</th><th>deny allow</th></tr></thead><tbody><tr><td>allow only</td><td>允许</td><td>允许</td></tr><tr><td>deny only</td><td>拒绝</td><td>拒绝</td></tr><tr><td>allow deny</td><td>拒绝</td><td>允许</td></tr><tr><td>none</td><td>拒绝</td><td>允许</td></tr></tbody></table></li></ul> 
<h3><a id="_259"></a>日志设定</h3> 
<p><strong>日志类型:</strong></p> 
<ul><li><strong>访问日志</strong></li><li><strong>错误日志</strong><br> <strong>错误日志:<br> ErrorLog logs/error_log LogLevel warn</strong><br> <strong>LogLevel 可选值:</strong><br> <strong>debug, info, notice, warn,error crit, alert, emerg</strong><br> <strong>访问日志:</strong><br> <strong>定义日志格式:LogFormat format strings</strong><br> <strong>LogFormat “%h %l %u %t \”%r\" %&gt;s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined</strong><br> <strong>使用日志格式:<br> CustomLog logs/access_log combined</strong><br> <strong>参考帮助:<br> http://httpd.apache.org/docs/2.2/mod/mod_log_config .html#formats<br> %h 客户端IP地址<br> %l 远程用户,启用mod_ident才有效，通常为减号“-”<br> %u 验证(basic，digest)远程用户,非登录访问时，为 一个减号“-”<br> %t 服务器收到请求时的时间<br> %r First line of request，即表示请求报文的首行;记录了此次请求的“方法”，“URL”以及协议版本<br> %&gt;s 响应状态码<br> %b 响应报文的大小，单位是字节;不包括响应报文http首部<br> %{Referer}i 请求报文中首部“referer”的值;即从哪个页 面中的超链接跳转至当前页面的<br> %{User-Agent}i 请求报文中首部“User-Agent”的值;即发 出请求的应用程序</strong></li></ul> 
<h3><a id="_285"></a>设定默认字符集</h3> 
<p><strong>AddDefaultCharset UTF-8<br> 中文字符集:GBK, GB2312, GB18030</strong></p> 
<h3><a id="_289"></a>定义路径别名</h3> 
<p><strong>格式: Alias /URL/ "/PATH/"</strong></p> 
<pre><code class="prism language-bash">DocumentRoot <span class="token string">"/www/htdocs"</span> 
	http://www.yangyang.host/download/bash.rpm 
	<span class="token operator">==</span><span class="token operator">&gt;</span>/www/htdocs/download/bash.rpm 
Alias /download/ <span class="token string">"/rpms/pub/"</span> 
	http://www.yangyang.host/download/bash.rpm 
	<span class="token operator">==</span><span class="token operator">&gt;</span>/rpms/pub/bash.rpm 
	http://www.yangyang.host/images/logo.png 
	<span class="token operator">==</span><span class="token operator">&gt;</span>/www/htdocs/images/logo.png 
</code></pre> 
<h3><a id="_304"></a>基于用户的访问控制</h3> 
<p><strong>认证质询:WWW-Authenticate:响应码为401，拒绝客户端请求，并说明要求客户端提供账号和密码</strong></p> 
<p><strong>认证:Authorization:客户端用户填入账号和密码后再次发送 请求报文;认证通过时，则服务器发送响应的资源</strong></p> 
<p><strong>认证方式两种:</strong><br> * <strong>basic:明文</strong><br> * <strong>digest:消息摘要认证,兼容性差</strong></p> 
<p><strong>安全域:需要用户认证后方能访问的路径;应该通过名称对其进行标识，以便于告知用户认证的原因</strong></p> 
<p><strong>用户的账号和密码<br> 虚拟账号:仅用于访问某服务时用到的认证标识<br> 存储:文本文件，SQL数据库，ldap目录存储，nis等</strong></p> 
<p><strong>例子:</strong></p> 
<p><strong>下载密码命令包<br> yum install httpd-tools</strong></p> 
<p><strong>生成密码</strong><br> <strong>htpasswd -cs /etc/httpd/conf.d/.httpusers yang</strong></p> 
<p><strong>创建密码配置文件<br> vim /etc/httpd/conf.d/auth.conf</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>Directory /var/www/html/secret<span class="token operator">&gt;</span>
        authtype basic
        authname <span class="token string">"老哥，起来工作了！"</span>
        authuserfile <span class="token string">"/etc/httpd/conf.d/.httpuers"</span>
        require user yang
<span class="token operator">&lt;</span>/Directory<span class="token operator">&gt;</span>
</code></pre> 
<p><strong>重新启动httpd服务器</strong></p> 
<p><strong>或者在 /var/www/html/secre下创建.htaccess文件<br> 把/etc/httpd/conf.d/auth.conf文件复制到 /var/www/html/secre下<br> 修改为</strong></p> 
<pre><code class="prism language-bash"> authtype basic
        authname <span class="token string">"老哥，起来工作了！"</span>
        authuserfile <span class="token string">"/etc/httpd/conf.d/.httpuers"</span>
</code></pre> 
<p><strong>修改/etc/httpd/conf.d/auth.conf文件</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>Directory /var/www/html/secret<span class="token operator">&gt;</span>
        allowoverride authconfig
<span class="token operator">&lt;</span>/Directory<span class="token operator">&gt;</span>
</code></pre> 
<h3><a id="_359"></a><strong>密码组</strong></h3> 
<p><strong>vim /etc/httpd/conf.d/.httpgroups<br> admin: user1 user2</strong></p> 
<p><strong>修改配置文件</strong><br> <strong>vim /var/www/html/secre/.htaccess</strong></p> 
<pre><code class="prism language-bash">  	authtype basic
    authname <span class="token string">"老哥，起来工作了！"</span>
    authuserfile <span class="token string">"/etc/httpd/conf.d/.httpuers"</span>
  	authgroupfile “/etc/httpd/conf.d/.httpgroups”
	require group admin
</code></pre> 
<p><strong>修改/etc/httpd/conf.d/auth.conf文件</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>Directory /var/www/html/secret<span class="token operator">&gt;</span>
        allowoverride authconfig
<span class="token operator">&lt;</span>/Directory<span class="token operator">&gt;</span>
</code></pre> 
<p><strong>重新启动服务器</strong></p> 
<p><strong>远程客户端和用户验证的控制<br> Satisfy ALL|Any<br> ALL 客户机IP和用户验证都需要通过才可以<br> Any客户机IP和用户验证,有一个满足即可</strong><br> <strong>示例:</strong><br> <strong>Require valid-user<br> Order allow,deny<br> Allow from 192.168.1<br> Satisfy Any</strong></p> 
<p><strong>实现用户家目录的http共享</strong></p> 
<p><strong>基于模块mod_userdir.so实现</strong><br> <strong>SELinux: http_enable_homedirs</strong><br> <strong>相关设置:</strong><br> <strong>vim /etc/httpd/conf/httpd.conf</strong></p> 
<p><strong>&lt;IfModule mod_userdir.c&gt;<br> #UserDir disabled<br> UserDir public_html #指定共享目录的名称 &lt;/IfModule&gt;</strong><br> <strong>准备目录</strong><br> <strong>su – yang;mkdir ~/public_html</strong><br> <strong>setfacl –m u:apache:x ~student</strong><br> <strong>访问 http://localhost/~yang/index.html</strong></p> 
<h3><a id="ServerSignature_On__Off__EMail_413"></a>ServerSignature On | Off | EMail</h3> 
<p><strong>当客户请求的网页并不存在时，服务器将产生错误文档，缺省 情况下由于打开了 ServerSignature选项，错误文档的最后一行将包含服务器的名字、Apache的版本等信息,如果不对外显示这些信息，就可以将这个参数设置为Off<br> 设置为Email，将显示ServerAdmin 的Email提示</strong></p> 
<h3><a id="ServerType_inetd__standalone_417"></a>ServerType inetd | standalone.</h3> 
<p><strong>standalone 独立服务模式<br> inetd 非独立服务模式<br> 只适用于Unix平台</strong></p> 
<h3><a id="status_424"></a>status页面</h3> 
<p><strong>LoadModule status_module modules/mod_status.so<br> &lt;Location /server-status&gt;<br> SetHandler server-status<br> Order allow,deny<br> Allow from 172.16<br> &lt;/Location&gt;<br> ExtendedStatus On 显示扩展信息</strong></p> 
<h3><a id="_434"></a>虚拟主机</h3> 
<p><strong>站点标识: socket</strong><br> <strong>虚拟主机有三种构建方法：</strong></p> 
<ul><li><strong>IP相同，但端口不同</strong></li><li><strong>IP不同，但端口均为默认端口</strong></li><li><strong>FQDN不同:</strong><br> <strong>请求报文中首部</strong><br> <strong>Host: www.yangyang.host</strong></li></ul> 
<p><strong>有三种实现方案:</strong></p> 
<ul><li> <p><strong>基于ip:为每个虚拟主机准备至少一个ip地址</strong></p> </li><li> <p><strong>基于port:为每个虚拟主机使用至少一个独立的port</strong></p> </li><li> <p><strong>基于FQDN:为每个虚拟主机使用至少一个FQDN</strong><br> <mark><strong>注意:一般虚拟机不要与main主机混用;因此，要使用虚拟主机，一般先禁用main主机</strong></mark><br> <mark><strong>禁用方法:注释中心主机的DocumentRoot指令即可</strong></mark></p> <p><strong>虚拟主机的配置方法:</strong></p> </li></ul> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>VirtualHost IP:PORT<span class="token operator">&gt;</span> 
			ServerName FQDN 
			DocumentRoot “/path"
<span class="token operator">&lt;</span>/VirtualHost<span class="token operator">&gt;</span> 
</code></pre> 
<p><strong>建议:上述配置存放在独立的配置文件中</strong><br> <strong>其它可用指令:</strong><br> <strong>ServerAlias:虚拟主机的别名;可多次使用<br> ErrorLog: 错误日志<br> CustomLog:访问日志<br> &lt;Directory “/path"&gt; &lt;/Directory&gt;<br> Alias</strong></p> 
<p><strong>基于IP的虚拟主机示例:</strong><br> <strong>创建/etc/httpd/conf.d/vhost.conf文件</strong><br> <strong>vim /etc/httpd/conf.d/vhost.conf</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>virtualhost 192.168.1.39:80<span class="token operator">&gt;</span>
       	documentroot /var/www/html
      	ErrorLog logs/html1-error_log
      	CustomLog logs/html1-error_log common
<span class="token operator">&lt;</span>/virtualhost<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>VirtualHost 192.168.1.50:80<span class="token operator">&gt;</span>
		    DocumentRoot /var/www/html2
 		   ErrorLog logs/html2-error_log
 		   CustomLog logs/html2-error_log common
<span class="token operator">&lt;</span>/VirtualHost<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>VirtualHost 192.168.1.100:80<span class="token operator">&gt;</span>
		    DocumentRoot /var/www/html3
 		   ErrorLog logs/html3-error_log
 		   CustomLog logs/html3-error_log common
<span class="token operator">&lt;</span>/VirtualHost<span class="token operator">&gt;</span>
</code></pre> 
<p><strong>基于端口的虚拟主机:可和基于IP的虚拟主机混和使用</strong></p> 
<pre><code class="prism language-bash">		Listen 8001
		Listen 8002
		Listen 8003

		<span class="token operator">&lt;</span>virtualhost *:8001<span class="token operator">&gt;</span>
 		       documentroot /var/www/html
   		     ErrorLog logs/html1-error_log
   		     CustomLog logs/html1-error_log common
		<span class="token operator">&lt;</span>/virtualhost<span class="token operator">&gt;</span>

		<span class="token operator">&lt;</span>VirtualHost *:8002<span class="token operator">&gt;</span>
  			  DocumentRoot /var/www/html2
  			  ErrorLog logs/html2-error_log
 			   CustomLog logs/html2-error_log common
		<span class="token operator">&lt;</span>/VirtualHost<span class="token operator">&gt;</span>

		<span class="token operator">&lt;</span>VirtualHost *:8003<span class="token operator">&gt;</span>
			    DocumentRoot /var/www/html3
			    ErrorLog logs/html3-error_log
			    CustomLog logs/html3-error_log common
		<span class="token operator">&lt;</span>/VirtualHost<span class="token operator">&gt;</span>
</code></pre> 
<p><strong>基于FQDN的虚拟主机:</strong></p> 
<pre><code class="prism language-bash">NameVirtualHost *:80
<span class="token operator">&lt;</span>virtualhost *:80<span class="token operator">&gt;</span>
        servername www.a.com
        documentroot /var/www/html
        ErrorLog logs/html1-error_log
	serveralias www.cc.com
	serveralias www.ccc.com
        CustomLog logs/html1-error_log common
<span class="token operator">&lt;</span>/virtualhost<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>VirtualHost *:80<span class="token operator">&gt;</span>
        servername www.b.com
        DocumentRoot /var/www/html2
        ErrorLog logs/html2-error_log
        CustomLog logs/html2-error_log common
<span class="token operator">&lt;</span>/VirtualHost<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>VirtualHost *:80<span class="token operator">&gt;</span>
        servername www.c.com
        DocumentRoot /var/www/html3
        ErrorLog logs/html3-error_log
        CustomLog logs/html3-error_log common
<span class="token operator">&lt;</span>/VirtualHost<span class="token operator">&gt;</span>
</code></pre> 
<p><strong>serveralias www.cc.com 为常用别名跳转</strong></p> 
<h3><a id="HTTP_552"></a>HTTP的报文结构</h3> 
<p><img src="https://images2.imgbox.com/bf/9c/K7yi1Aed_o.png" alt="在这里插入图片描述"><br> <strong>telnet www.baidu.com<br> telnet 服务器IP 端口<br> GET /index.html HTTP/1.1<br> HOST:3.3.3.3 (随便写)<br> 回车</strong></p> 
<p><strong>这便是模拟HTTP的请求报文</strong><br> <img src="https://images2.imgbox.com/52/08/DsD71wTT_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="http_564"></a><strong>http协议状态码分类</strong></h3> 
<p><strong>status(状态码):</strong></p> 
<ul><li><strong>1xx:100-101 信息提示</strong></li><li><strong>2xx:200-206 成功</strong></li><li><strong>3xx:300-305 重定向</strong></li><li><strong>4xx:400-415 错误类信息，客户端错误</strong></li><li><strong>5xx:500-505 错误类信息，服务器端错误</strong></li></ul> 
<p><strong>200: 成功，请求数据通过响应报文的entity-body部分发送;OK</strong></p> 
<p><strong>301: 请求的URL指向的资源已经被删除;但在响应报文中通过首部 Location指明了资源现在所处的新位置;Moved Permanently</strong></p> 
<p><strong>302: 响应报文Location指明资源临时新位置 Moved</strong> <strong>Temporarily</strong></p> 
<p><strong>304: 客户端发出了条件式请求，但服务器上的资源未曾发生改变， 则通过响应此响应状态码通知客户端;Not Modified</strong></p> 
<p><strong>401: 需要输入账号和密码认证方能访问资源;Unauthorized</strong></p> 
<p><strong>403: 请求被禁止;Forbidden</strong></p> 
<p><strong>404: 服务器无法找到客户端请求的资源;Not Found</strong></p> 
<p><strong>500: 服务器内部错误;Internal Server Error</strong></p> 
<p><strong>502: 代理服务器从后端服务器收到了一条伪响应，如无法连接到网 关;Bad Gateway</strong></p> 
<p><strong>503 – 服务不可用，临时服务器维护或过载，服务器无法处理请求</strong></p> 
<p><strong>504 – 网关超时</strong></p> 
<h3><a id="curl_595"></a>curl工具</h3> 
<p><strong>curl是基于URL语法在命令行方式下工作的文件传输工具，它支持FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE及LDAP等协议。curl支持HTTPS认证，并且支持 HTTP的POST、PUT等方法， FTP上传， kerberos认证， HTTP上传，代理服务器，cookies，用户名/密码认证， 下载文 件断点续传，上载文件断点续传, http代理服务器管道( proxy tunneling)，还支持IPv6，socks5代理服务器，通过http代理 服务器上传文件到FTP服务器等，功能十分强大</strong><br> <strong>curl [options] [URL…]</strong><br> <strong>-A/–user-agent 设置用户代理发送给服务器<br> -e/–referer 来源网址<br> –cacert CA证书 (SSL)<br> -k/–insecure 允许忽略证书进行 SSL 连接<br> –compressed 要求返回是压缩的格式<br> -H/–header 
  <line>
    自定义首部信息传递给服务器 
   <br> -i 显示页面内容，包括报文首部信息 
   <br> -I/–head 只显示响应报文首部信息 
   <br> -D/–dump-header 将url的header信息存放在指定文件中 
   <br> –basic 使用HTTP基本认证 
   <br> -u/–user &lt;user[:password]&gt;设置服务器的用户和密码 
   <br> -L 如果有3xx响应码，重新发请求到新位置 
   <br> -O 使用URL中默认的文件名保存文件到本地 
   <br> -o 将网络文件保存为指定的文件中 
   <br> –limit-rate 设置传输速度 
   <br> -0/–http1.0 数字0，使用HTTP 1.0 
   <br> -v/–verbose 更详细 
   <br> -C - 选项可对文件使用断点续传功能 
   <br> -c/–cookie-jar 将url中cookie存放在指定文件中 
   <br> -x/–proxy &lt;proxyhost[:port]&gt; 指定代理服务器地址 -X/–request 向服务器发送指定请求方法 
   <br> -U/–proxy-user 
   user:password 代理服务器用户和密码 
   <br> -T 选项可将指定的本地文件上传到FTP服务器上 
   <br> –data/-d 方式指定使用POST方式传递数据 
   <br> -b name=data 从服务器响应set-cookie得到值，返回给服务器 
  </line></strong></p> 
<p><strong>openssl s_client -connect www.yangyang.host:443 代替telnet连接</strong></p> 
<p><strong>elinks工具:<br> elinks [OPTION]… [URL]…<br> -dump: 非交互式模式，将URL的内容输出至标准输出<br> -source:打印源码</strong></p> 
<h3><a id="mod_deflate_633"></a>mod_deflate模块</h3> 
<p><strong>使用mod_deflate模块压缩页面优化传输速度<br> 适用场景:</strong></p> 
<ul><li><strong>(1) 节约带宽，额外消耗CPU;同时，可能有些较老浏览器不支持</strong></li><li><strong>(2) 压缩适于压缩的资源，例如文本文件</strong></li></ul> 
<pre><code class="prism language-bash">LoadModule deflate_module modules/mod_deflate.so 
		SetOutputFilter DEFLATE 
		<span class="token comment"># Restrict compression to these MIME types </span>
		AddOutputFilterByType DEFLATE text/plain 
		AddOutputFilterByType DEFLATE text/html 
		AddOutputFilterByType DEFLATE application/xhtml+xml 
		AddOutputFilterByType DEFLATE text/xml 
		AddOutputFilterByType DEFLATE application/xml 
		AddOutputFilterByType DEFLATE application/x-javascript 
		AddOutputFilterByType DEFLATE text/javascript
		AddOutputFilterByType DEFLATE text/css 
</code></pre> 
<p><strong>添加压缩比</strong><br> <strong>Level of compression (Highest 9 - Lowest 1)<br> DeflateCompressionLevel 9</strong><br> <strong>排除特定旧版本的浏览器，不支持压缩<br> Netscape 4.x 只压缩text/html<br> BrowserMatch ^Mozilla/4 gzip-only-text/html Netscape 4.06-08三个版本 不压缩 BrowserMatch ^Mozilla/4\.0[678] no-gzip</strong><br> <strong>Internet Explorer标识本身为“Mozilla / 4”，但实际上是 能够处理请求的压缩。如果用户代理首部匹配字符串 “MSIE”(“B”为单词边 界”)，就关闭之前定义的限制<br> BrowserMatch \bMSI[E] !no-gzip !gzip-only- text/html</strong></p> 
<h3><a id="httpshttp_over_ssl_663"></a>https:http over ssl</h3> 
<p><strong>SSL会话的简化过程</strong></p> 
<ul><li><strong>(1) 客户端发送可供选择的加密方式，并向服务器请求证书</strong></li><li><strong>(2) 服务器端发送证书以及选定的加密方式给客户端</strong></li><li><strong>(3) 客户端取得证书并进行证书验证</strong><br> <strong>如果信任给其发证书的CA</strong> 
  <ul><li><strong>(a) 验证证书来源的合法性;用CA的公钥解密证书上数字签名</strong></li><li><strong>(b) 验证证书的内容的合法性:完整性验证</strong></li><li><strong>(c) 检查证书的有效期限</strong></li><li><strong>(d) 检查证书是否被吊销</strong></li><li><strong>(e) 证书中拥有者的名字，与访问的目标主机要一致</strong></li></ul> </li><li><strong>(4) 客户端生成临时会话密钥(对称密钥)，并使用服务器端的公钥加密 此数据发送给服务器，完成密钥交换</strong></li><li><strong>(5) 服务用此密钥加密用户请求的资源，响应给客户端<br> 注意:SSL是基于IP地址实现,单IP的主机仅可以使用一个https虚拟主机</strong></li></ul> 
<p><strong>搭建步骤：</strong><br> <strong>(1) 为服务器申请数字证书</strong><br> <strong>测试:通过私建CA发证书</strong></p> 
<ul><li><strong>(a) 创建私有CA</strong></li><li><strong>(b) 在服务器创建证书签署请求</strong></li><li><strong>(c) CA签证</strong></li></ul> 
<p><strong>(2) 配置httpd支持使用ssl，及使用的证书<br> yum -y install mod_ssl<br> 配置文件:/etc/httpd/conf.d/ssl.conf<br> DocumentRoot<br> ServerName<br> SSLCertificateFile<br> SSLCertificateKeyFile</strong><br> <strong>(3) 测试基于https访问相应的主机</strong><br> <strong>openssl s_client [-connect host:port] [-cert filename] [- CApath directory] [-CAfile filename]</strong></p> 
<h3><a id="HTTPS__698"></a>HTTPS 实现</h3> 
<p><strong>下载ssl模块<br> yum install mod_ssl</strong></p> 
<p><strong>创建放证书的路径：<br> mkdir /etc/httpd/conf.d/ssl</strong></p> 
<p><strong>进行证书申请，自己搭建根CA<br> 配置文件vim /etc/pki/tls/openssl.cnf</strong><br> <strong>1。建立Root CA<br> 生成私钥<br> (umask 066;openssl genrsa -out private/cakey.pem 4096 )<br> 自签名证书<br> openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650<br> 查看自签名认证证书<br> openssl x509 -in cacert.pem -noout -text</strong><br> <strong>2。用户或服务器<br> cd /etc/httpd/conf.d/ssl<br> 生成私钥<br> (umask 066;openssl genrsa -out app.key 1024)<br> 生成证书申请文件<br> openssl req -new -key app.key -out app.csr<br> 将申请文件发给CA<br> scp app.csr root@192.168.1.19:/etc/pki/CA</strong><br> <strong>3。CA颁发证书<br> touch index.txt<br> echo 0F &gt; serial<br> openssl ca -in app.csr -out certs/app.crt -days 100<br> 发给申请方<br> scp certs/app.crt 192.168.1.39:/etc/httpd/conf.d/ssl/</strong></p> 
<p><strong>修改配置文件<br> vim /etc/httpd/conf.d/ssl.conf</strong><br> <strong>修改下面三项</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>VirtualHost _default_:443<span class="token operator">&gt;</span>
SSLCertificateFile /etc/httpd/conf.d/ssl/app.crt
SSLCertificateKeyFile /etc/httpd/conf.d/ssl/app.key
</code></pre> 
<p><strong>这里的路径是放的证书位置</strong></p> 
<p><strong>接着把CA证书也得复制过来<br> scp cacert.pem 192.168.1.39:/etc/httpd/conf.d/ssl</strong></p> 
<p><strong>修改配置文件<br> vim /etc/httpd/conf.d/ssl.conf<br> SSLCACertificateFile /etc/httpd/conf.d/ssl/cacert.pem<br> 把这一行修改成CA证书存放的位置(127行)</strong></p> 
<p><strong>重启服务</strong></p> 
<p><strong>接着把证书导出来添加到系统里面，使系统接受信任，<br> Mac和WIndows各有不同，自行百度<br> 记得把hosts文件修改DNS指向<br> 192.168.1.39 www.yangyang.host</strong></p> 
<p><strong>接着使用https://www.yangyang.host就可以访问到了<br> 在颁发CA到时候最重要的就是观察系统时间<br> 如果时间不标准 CA证书会无效过期，还是不能使用</strong></p> 
<p><strong>openssl s_client -connect www.yangyang.host:443 代替telnet连接<br> 证书连接https</strong></p> 
<h3><a id="httphttpsURL_764"></a>将http请求转发至https的URL</h3> 
<p><strong>重定向<br> Redirect [status] 原本路径 跳转路径</strong><br> <strong>status状态:</strong></p> 
<ul><li><strong>永久跳转<br> Permanent:Returns a permanent redirect status (301) indicating that the resource has moved permanently</strong></li><li><strong>临时跳转<br> Temp:Returns a temporary redirect status (302). This is the default</strong></li></ul> 
<p><strong>示例:<br> Redirect temp / https://www.yangyang.host/</strong></p> 
<p><strong>生效需要在/etc/httpd/conf/httpd.conf<br> 或者/etc/httpd/conf.d/下创建.conf文件<br> 并且加入跳转语句<br> redirect temp / www.baidu.com</strong></p> 
<p><strong>跳转到https<br> 需要使用模块rewrite_module<br> 使用httpd -M | grep rewrite命令来查询<br> 修改配置文件<br> vim /etc/httpd/conf/httpd.conf</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>Directory /<span class="token operator">&gt;</span>
	RewriteEngine on
	RewriteRule ^<span class="token punctuation">(</span>/.*<span class="token punctuation">)</span>$ https://%<span class="token punctuation">{<!-- --></span>HTTP_HOST<span class="token punctuation">}</span><span class="token variable">$1</span> <span class="token punctuation">[</span>redirect<span class="token operator">=</span>302<span class="token punctuation">]</span> 
<span class="token operator">&lt;</span>Directory<span class="token operator">&gt;</span>
</code></pre> 
<p><strong>需要记住，这里必须是在网站的配置文件的标签内，否则不生效</strong></p> 
<h3><a id="HSTSHTTP_Strict_Transport_Security_799"></a>HSTS:HTTP Strict Transport Security</h3> 
<p><strong>服务器端配置支持HSTS后，会在给浏览器返回的HTTP首部中携带 HSTS字段。浏览器获取到该信息后，会将所有HTTP访问请求在内部 做307跳转到HTTPS。而无需任何网络过程</strong><br> <strong>HSTS preload list</strong></p> 
<p><strong>是Chrome浏览器中的HSTS预载入列表，在该列表中的网站，使用 Chrome浏览器访问时，会自动转换成HTTPS。Firefox、Safari、 Edge浏览器也会采用这个列表</strong></p> 
<p><strong>实现HSTS示例:</strong></p> 
<p><strong>vim /etc/httpd/conf/httpd.conf</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>Directory /<span class="token operator">&gt;</span>
	Header always <span class="token keyword">set</span> Strict-Transport-Security <span class="token string">"max- age=31536000"</span> 
	RewriteEngine on
	RewriteRule ^<span class="token punctuation">(</span>/.*<span class="token punctuation">)</span>$ https://%<span class="token punctuation">{<!-- --></span>HTTP_HOST<span class="token punctuation">}</span><span class="token variable">$1</span> <span class="token punctuation">[</span>redirect<span class="token operator">=</span>302<span class="token punctuation">]</span> 
<span class="token operator">&lt;</span>Directory<span class="token operator">&gt;</span>
</code></pre> 
<p><strong>max- age=31536000的默认时间是秒</strong></p> 
<p><strong>压力测试<br> ab [OPTIONS] URL<br> 来自httpd-tools包<br> -n:总请求数<br> -c:模拟的并行数<br> -k:以持久连接模式测试<br> 如果并行输太大太多的请求，可以使用以下命令来调高系统局限性<br> ulimit –n # 调整能打开的文件数</strong></p> 
<h3><a id="httpd24_828"></a>httpd-2.4</h3> 
<p><strong>新特性<br> MPM支持运行为DSO机制;以模块形式按需加载<br> event MPM生产环境可用<br> 异步读写机制<br> 支持每模块及每目录的单独日志级别定义<br> 每请求相关的专用配置<br> 增强版的表达式分析式<br> 毫秒级持久连接时长定义<br> 基于FQDN的虚拟主机不需要NameVirutalHost指令  新指令，AllowOverrideList<br> 支持用户自定义变量<br> 更低的内存消耗</strong></p> 
<p><strong>httpd-2.4<br> 重新设置主站目录，不仅需要修改<br> DocumentRoot 选项，还得单独加权限，如下例：</strong></p> 
<pre><code class="prism language-bash">DocumentRoot <span class="token string">"/app/website"</span>
<span class="token operator">&lt;</span>Directory /app/website<span class="token operator">&gt;</span>
        Require all granted
<span class="token operator">&lt;</span>/Directory<span class="token operator">&gt;</span>
</code></pre> 
<p><strong>配置应用:</strong></p> 
<ul><li><strong>(1) 切换使用的MPM<br> Centos 7:/etc/httpd/conf.modules.d/00-mpm.conf<br> 启用要启用的MPM相关的LoadModule指令即可<br> centos6编译安装:<br> vim /etc/httpd24/httpd.conf<br> Include /etc/httpd24/extra/httpd-mpm.conf<br> LoadModule mpm_event_module</strong> <strong>modules/mod_mpm_event.so</strong></li><li><strong>(2)主目录: DocumentRoot /path</strong></li><li><strong>(3) 基于IP的访问控制:</strong><br> <strong>无明确授权的目录，默认拒绝<br> 允许所有主机访问:Require all granted<br> 拒绝所有主机访问:Require all denied<br> 控制特定的IP访问:<br> Require ip IPADDR:授权指定来源的IP访问<br> Require not ip IPADDR:拒绝特定的IP访问</strong><br> <strong>控制特定的主机访问:</strong> 
  <ul><li><strong>Require host HOSTNAME:授权特定主机访问</strong></li><li><strong>Require not host HOSTNAME:拒绝</strong></li><li><strong>HOSTNAME:</strong> 
    <ul><li><strong>FQDN:特定主机</strong></li><li><strong>domin.tld:指定域名下的所有主机</strong></li></ul> </li></ul> </li></ul> 
<p><strong>例子：</strong><br> <strong>不能有失败，至少有一个成功匹配才成功，即失败优先</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>RequireAll<span class="token operator">&gt;</span> 
		Require all granted 
		Require not ip 172.16.1.1 拒绝特定IP 
	<span class="token operator">&lt;</span>/RequireAll<span class="token operator">&gt;</span> 
</code></pre> 
<p><strong>多个语句有一个成功，则成功，即成功优先</strong></p> 
<pre><code class="prism language-bash"> <span class="token operator">&lt;</span>RequireAny<span class="token operator">&gt;</span> 
		Require all denied 
		require ip 172.16.1.1 允许特定IP 
	<span class="token operator">&lt;</span>/RequireAny<span class="token operator">&gt;</span> 
</code></pre> 
<ul><li><strong>(4) 虚拟主机</strong><br> <mark>基于FQDN的虚拟主机不再需要NameVirutalHost指令</mark></li></ul> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>VirtualHost *:80<span class="token operator">&gt;</span> 
		ServerName www.b.net 
		DocumentRoot <span class="token string">"/apps/b.net/htdocs"</span> 
		<span class="token operator">&lt;</span>Directory <span class="token string">"/apps/b.net/htdocs"</span><span class="token operator">&gt;</span> 
			Options None 
			AllowOverride None 
			Require all granted 
		<span class="token operator">&lt;</span>/Directory<span class="token operator">&gt;</span> 
	<span class="token operator">&lt;</span>/VirtualHost<span class="token operator">&gt;</span> 
</code></pre> 
<p><strong><mark>注意:任意目录下的页面只有显式授权才能被访问</mark></strong></p> 
<ul><li><strong>(5) ssl:安装mod_ssl，和httpd-2.2相同配置</strong></li><li><strong>(6) KeepAlive on 持久连接</strong><br> <strong>KeepAliveTimeout #ms 默认以毫秒为单位<br> MaxKeepAliveRequests 100 毫秒级持久连接时长定义<br> 在配置文件<br> vim /usr/share/doc/httpd-2.4.6/httpd-default.conf</strong></li></ul> 
<h3><a id="Sendfile_922"></a>Sendfile机制</h3> 
<p><strong>不用 sendfile 的传统网络传输过程:<br> read(file, tmp_buf, len)<br> write(socket, tmp_buf, len)</strong></p> 
<p><strong>硬盘 &gt;&gt; kernel buffer &gt;&gt; user buffer &gt;&gt; kernel socket buffer &gt;&gt; 协议栈</strong></p> 
<p><strong>一般网络应用通过读硬盘数据，写数据到 socket 来完成网络传输,底层执行过程:</strong></p> 
<ul><li> <p><strong>1 系统调用 read() 产生一个上下文切换:从 user mode 切换到 kernel mode， 然后 DMA 执行拷贝，把文件数据从硬盘读到一个 kernel buffer 里。</strong></p> </li><li> <p><strong>2 数据从 kernel buffer 拷贝到 user buffer，然后系统调用 read() 返回，这时 又产生一个上下文切换:从kernel mode 切换到 user mode</strong></p> </li><li> <p><strong>3 系统调用 write() 产生一个上下文切换:从 user mode 切换到 kernel mode， 然后把步骤2读到 user buffer 的数据拷贝到 kernel buffer(数据第2次拷贝到 kernel buffer)，不过这次是个不同的 kernel buffer，这个 buffer和 socket 相关联。</strong></p> </li><li> <p><strong>4 系统调用 write() 返回，产生一个上下文切换:从 kernel mode 切换到 user mode(第4次切换),然后DMA从 kernel buffer 拷贝数据到协议栈(第4次拷贝)</strong></p> <p><strong>上面4个步骤有4次上下文切换，有4次拷贝，如果能减少切换次数和拷贝次数将会 有效提升性能</strong></p> </li></ul> 
<p><strong>在kernel 2.0+ 版本中，系统调用 sendfile() 就是用来简化上面步骤提升性能的。sendfile() 不但能减少切换次数而且还能减少拷贝次数</strong><br> <strong>用 sendfile() 来进行网络传输的过程:</strong></p> 
<ul><li><strong>sendfile(socket, file, len);</strong></li><li><strong>硬盘 &gt;&gt; kernel buffer (快速拷贝到kernel socket buffer) &gt;&gt; 协议栈</strong> 
  <ul><li><strong>1 系统调用 sendfile() 通过 DMA 把硬盘数据拷贝到 kernel buffer，然后数据被 kernel 直接拷贝到另外一个与 socket 相关 的 kernel buffer。这里没有 user mode 和 kernel mode 之间的 切换，在 kernel 中直接完成了从一个 buffer 到另一个 buffer 的拷贝。</strong></li><li><strong>2 DMA 把数据从 kernel buffer 直接拷贝给协议栈，没有切换， 也不需要数据从 user mode 拷贝到 kernel mode，因为数据就在 kernel 里</strong></li></ul> </li></ul> 
<h3><a id="_946"></a>反向代理功能</h3> 
<p><strong>启用反向代理<br> ProxyPass “/” “http://www.example.com/”<br> ProxyPassReverse “/” "http://www.example.com/"</strong><br> <strong>特定URL反向代理<br> ProxyPass “/images” “http://www.example.com/”<br> ProxyPassReverse “/images” http://www.example.com/</strong><br> <strong>示例:</strong></p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>VirtualHost *<span class="token operator">&gt;</span> 
	ServerName www.yangyang.host
	ProxyPass / http://localhost:8080/ 
	ProxyPassReverse / http://localhost:8080/ 
<span class="token operator">&lt;</span>/VirtualHost<span class="token operator">&gt;</span> 
</code></pre> 
<h3><a id="centos6httpd24__964"></a>在centos6编译安装httpd-2.4 方法一</h3> 
<p><strong>安装httpd-2.4<br> 依赖于apr-1.4+, apr-util-1.4+, [apr-iconv]<br> apr: apache portable runtime，解决跨平台实现(虚拟接口)</strong><br> <strong>CentOS 6:默认:apr-1.3.9, apr-util-1.3.9</strong></p> 
<p><strong>安装前准备开发包:</strong><br> <strong>开发环境包组:<br> 安装Development Tools<br> yum groupinstall “development tools” -y<br> yum install -y libxml2-devel</strong></p> 
<p><strong>Server 相关包:<br> pcre-devel，<br> openssl-devel<br> expat-devel<br> libxml2-devel</strong></p> 
<p><strong>下载源代码并解压缩:<br> httpd-2.4.27.tar.bz2<br> apr-1.6.2.tar.bz2<br> apr-util-1.6.0.tar.bz2</strong></p> 
<p><strong>安装apr-1.7+<br> wget wget https://downloads.apache.org//apr/apr-1.7.0.tar.bz2</strong><br> <strong>tar -xvf apr-1.7.0.tar.bz2<br> cd apr-1.7.2<br> ./configure --prefix=/app/apr<br> make &amp;&amp; make install</strong></p> 
<p><strong>安装apr-util-1.6+</strong><br> <strong>yum install openssl-devel pcre-devel expat-devel -y<br> wget https://downloads.apache.org//apr/apr-util-1.6.1.tar.bz2<br> tar -xvf apr-util-1.6.1.tar.bz2<br> cd …/apr-util-1.6.0<br> ./configure --prefix=/app/apr-utils --with-apr=/app/apr/<br> make &amp;&amp; make install</strong></p> 
<p><strong>编译安装httpd-2.4</strong><br> <strong>cd …/httpd-2.4.27<br> ./configure --prefix=/app/httpd24 <br> –enable-so <br> –enable-ssl <br> –enable-cgi <br> –enable-rewrite <br> –with-zlib <br> –with-pcre <br> –with-apr=/app/apr/ <br> –with-apr-util=/app/apr-utils <br> –enable-modules=most <br> –enable-mpms-shared=all<br> –with-mpm=prefork<br> make &amp;&amp; make install</strong></p> 
<p><strong>安装好后进入目录<br> cd /app/httpd24/</strong></p> 
<p><strong>添加到PATH变量<br> echo ‘PATH=/app/httpd24/bin/:$PATH’ &gt; /etc/profile.d/httpd24.sh<br> . /etc/profile.d/httpd24.sh</strong></p> 
<p><strong>添加系统用户<br> useradd -r -s /sbin/nologin apache</strong></p> 
<p><strong>修改配置文件<br> vim /app/httpd24/conf/httpd.conf</strong></p> 
<p><strong>修改这两项<br> User apache<br> Group apache</strong></p> 
<p><strong>保存启动<br> apachectl start</strong></p> 
<p><strong>准备脚本需要文件夹<br> mkdir /var/lock/subsys/</strong></p> 
<p><strong>写启动脚本</strong></p> 
<pre><code class="prism language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment">#</span>
<span class="token comment"># httpd        Startup script for the Apache HTTP Server</span>
<span class="token comment">#</span>
<span class="token comment"># chkconfig: - 85 15</span>
<span class="token comment"># description: The Apache HTTP Server is an efficient and extensible  \</span>
<span class="token comment">#	       server implementing the current HTTP standards.</span>
<span class="token comment"># processname: httpd</span>
<span class="token comment"># config: /etc/httpd/conf/httpd.conf</span>
<span class="token comment"># config: /etc/sysconfig/httpd</span>
<span class="token comment"># pidfile: /var/run/httpd/httpd.pid</span>
<span class="token comment">#</span>
<span class="token comment">### BEGIN INIT INFO</span>
<span class="token comment"># Provides: httpd</span>
<span class="token comment"># Required-Start: $local_fs $remote_fs $network $named</span>
<span class="token comment"># Required-Stop: $local_fs $remote_fs $network</span>
<span class="token comment"># Should-Start: distcache</span>
<span class="token comment"># Short-Description: start and stop Apache HTTP Server</span>
<span class="token comment"># Description: The Apache HTTP Server is an extensible server</span>
<span class="token comment">#  implementing the current HTTP standards.</span>
<span class="token comment">### END INIT INFO</span>

<span class="token keyword">.</span> /etc/rc.d/init.d/functions

<span class="token keyword">if</span> <span class="token punctuation">[</span> -f /etc/sysconfig/httpd <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token keyword">.</span> /etc/sysconfig/httpd
<span class="token keyword">fi</span>

HTTPD_LANG<span class="token operator">=</span>$<span class="token punctuation">{<!-- --></span>HTTPD_LANG-<span class="token string">"C"</span><span class="token punctuation">}</span>

INITLOG_ARGS<span class="token operator">=</span><span class="token string">""</span>

apachectl<span class="token operator">=</span>/app/httpd24/bin/apachectl
httpd<span class="token operator">=</span><span class="token variable">${HTTPD-/app/httpd24/bin/httpd}</span>
prog<span class="token operator">=</span>httpd
pidfile<span class="token operator">=</span><span class="token variable">${PIDFILE-/app/httpd24/logs/httpd.pid}</span>
lockfile<span class="token operator">=</span><span class="token variable">${LOCKFILE-/var/lock/subsys/httpd24}</span>
RETVAL<span class="token operator">=</span>0
STOP_TIMEOUT<span class="token operator">=</span><span class="token variable">${STOP_TIMEOUT-10}</span>



start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">echo</span> -n $<span class="token string">"Starting <span class="token variable">$prog</span>: "</span>
        LANG<span class="token operator">=</span><span class="token variable">$HTTPD_LANG</span> daemon --pidfile<span class="token operator">=</span><span class="token variable">${pidfile}</span> <span class="token variable">$httpd</span> <span class="token variable">$OPTIONS</span>
        RETVAL<span class="token operator">=</span><span class="token variable">$?</span>
        <span class="token keyword">echo</span>
        <span class="token punctuation">[</span> <span class="token variable">$RETVAL</span> <span class="token operator">=</span> 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">touch</span> <span class="token variable">${lockfile}</span>
        <span class="token keyword">return</span> <span class="token variable">$RETVAL</span>
<span class="token punctuation">}</span>

stop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	status -p <span class="token variable">${pidfile}</span> <span class="token variable">$httpd</span> <span class="token operator">&gt;</span> /dev/null
	<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token operator">=</span> 0 <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
		<span class="token keyword">echo</span> -n $<span class="token string">"Stopping <span class="token variable">$prog</span>: "</span>
		killproc -p <span class="token variable">${pidfile}</span> -d <span class="token variable">${STOP_TIMEOUT}</span> <span class="token variable">$httpd</span>
	<span class="token keyword">else</span>
		<span class="token keyword">echo</span> -n $<span class="token string">"Stopping <span class="token variable">$prog</span>: "</span>
		success
	<span class="token keyword">fi</span>
	RETVAL<span class="token operator">=</span><span class="token variable">$?</span>
	<span class="token keyword">echo</span>
	<span class="token punctuation">[</span> <span class="token variable">$RETVAL</span> <span class="token operator">=</span> 0 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -f <span class="token variable">${lockfile}</span> <span class="token variable">${pidfile}</span>
<span class="token punctuation">}</span>

reload<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">echo</span> -n $<span class="token string">"Reloading <span class="token variable">$prog</span>: "</span>
    <span class="token keyword">if</span> <span class="token operator">!</span> LANG<span class="token operator">=</span><span class="token variable">$HTTPD_LANG</span> <span class="token variable">$httpd</span> <span class="token variable">$OPTIONS</span> -t <span class="token operator">&gt;</span><span class="token operator">&amp;</span>/dev/null<span class="token punctuation">;</span> <span class="token keyword">then</span>
        RETVAL<span class="token operator">=</span>6
        <span class="token keyword">echo</span> $<span class="token string">"not reloading due to configuration syntax error"</span>
        failure $<span class="token string">"not reloading <span class="token variable">$httpd</span> due to configuration syntax error"</span>
    <span class="token keyword">else</span>
        LSB<span class="token operator">=</span>1 killproc -p <span class="token variable">${pidfile}</span> <span class="token variable">$httpd</span> -HUP
        RETVAL<span class="token operator">=</span><span class="token variable">$?</span>
        <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$RETVAL</span> -eq 7 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
            failure $<span class="token string">"httpd shutdown"</span>
        <span class="token keyword">fi</span>
    <span class="token keyword">fi</span>
    <span class="token keyword">echo</span>
<span class="token punctuation">}</span>

<span class="token keyword">case</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token keyword">in</span>
  start<span class="token punctuation">)</span>
	start
	<span class="token punctuation">;</span><span class="token punctuation">;</span>
  stop<span class="token punctuation">)</span>
	stop
	<span class="token punctuation">;</span><span class="token punctuation">;</span>
  status<span class="token punctuation">)</span>
        status -p <span class="token variable">${pidfile}</span> <span class="token variable">$httpd</span>
	RETVAL<span class="token operator">=</span><span class="token variable">$?</span>
	<span class="token punctuation">;</span><span class="token punctuation">;</span>
  restart<span class="token punctuation">)</span>
	stop
	start
	<span class="token punctuation">;</span><span class="token punctuation">;</span>
  condrestart<span class="token operator">|</span>try-restart<span class="token punctuation">)</span>
	<span class="token keyword">if</span> status -p <span class="token variable">${pidfile}</span> <span class="token variable">$httpd</span> <span class="token operator">&gt;</span><span class="token operator">&amp;</span>/dev/null<span class="token punctuation">;</span> <span class="token keyword">then</span>
		stop
		start
	<span class="token keyword">fi</span>
	<span class="token punctuation">;</span><span class="token punctuation">;</span>
  force-reload<span class="token operator">|</span>reload<span class="token punctuation">)</span>
        reload
	<span class="token punctuation">;</span><span class="token punctuation">;</span>
  graceful<span class="token operator">|</span><span class="token function">help</span><span class="token operator">|</span>configtest<span class="token operator">|</span>fullstatus<span class="token punctuation">)</span>
	<span class="token variable">$apachectl</span> <span class="token variable">$@</span>
	RETVAL<span class="token operator">=</span><span class="token variable">$?</span>
	<span class="token punctuation">;</span><span class="token punctuation">;</span>
  *<span class="token punctuation">)</span>
	<span class="token keyword">echo</span> $<span class="token string">"Usage: <span class="token variable">$prog</span> {start|stop|restart|condrestart|try-restart|force-reload|reload|status|fullstatus|graceful|help|configtest}"</span>
	RETVAL<span class="token operator">=</span>2
esac

<span class="token keyword">exit</span> <span class="token variable">$RETVAL</span>
</code></pre> 
<p><strong>把这个脚本移动到/etc/init.d/目录下</strong><br> <strong>mv 脚本路径 /etc/init.d/httpd24</strong></p> 
<p><strong>加入chkconfig</strong><br> <strong>chkconfig --add httpd24</strong></p> 
<p><strong>设为开机启动<br> chkconfig httpd24 on</strong></p> 
<p><strong>到此安装完成</strong></p> 
<h3><a id="centos6httpd24__1173"></a>在centos6编译安装httpd-2.4 方法二</h3> 
<p><strong>安装需要的工具包<br> yum groupinstall “development tools” -y<br> yum install -y libxml2-devel<br> yum install openssl-devel pcre-devel expat-devel -y</strong></p> 
<p><strong>下载apr，apr-util，httpd源码，并且解压缩</strong><br> <strong>wget wget https://downloads.apache.org//apr/apr-1.7.0.tar.bz2<br> tar -xvf apr-1.7.0.tar.bz2<br> wget https://downloads.apache.org//apr/apr-util-1.6.1.tar.bz2<br> tar -xvf apr-util-1.6.1.tar.bz2<br> wget https://downloads.apache.org//httpd/httpd-2.4.43.tar.bz2<br> tar -xvf httpd-2.4.43.tar.bz2</strong></p> 
<p><strong>开始编译<br> cp -r /root/apr-1.7.0/ /root/httpd-2.4.43/srclib/apr<br> cp -r /root/apr-util-1.6.1/ /root/httpd-2.4.43/srclib/apr-util<br> cd httpd-2.4.43/<br> ./configure --prefix=/app/httpd24 <br> –enable-so <br> –enable-ssl <br> –enable-cgi <br> –enable-rewrite <br> –with-zlib <br> –with-pcre <br> –with-included-apr <br> –enable-modules=most <br> –enable-mpms-shared=all<br> –with-mpm=prefork<br> make &amp;&amp; make install<br> Httpd编译过程:/app/httpd24/build/config.nice<br> 自带的服务控制脚本:/app/httpd24/bin/apachectl</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/862dc0dcefcdcf6bdb4405db2a6356fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">只要30行代码！7步教会你Python爬取网页抖音热门视频</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bfc615b341a14c88b6397b78bcf69681/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何优雅的利用C#做协议解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>