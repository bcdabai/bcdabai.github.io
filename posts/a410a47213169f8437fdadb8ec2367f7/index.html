<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DLL释放引起的死锁问题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="DLL释放引起的死锁问题" />
<meta property="og:description" content="DLL释放引起的死锁问题 一，问题介绍二，问题分析三，问题总结 一，问题介绍 最近在做代码重构，今早对前两天重构的某个组件进行自测时，突然发现停止程序运行时，出现了卡死，进程退不出，查看日志发现是FreeLibrary没有走完。打开任务管理器-》性能-》资源监视器，找到进程，右键分析分析等待链，结果如下：
出现了死锁，16800线程是主线程（调用FreeLibrary），12128是DLL中的工作线程，两个线程互相等待，导致死锁，进程退不出。
二，问题分析 打开Windbg，配好pdb文件和源码路径，attach到该进程上，输入!locks命令，查看当前进程锁的情况：
可以发现锁771f20c0处于死锁状态，它此时被30f8线程占有。再输入~*kb查看所有线程，看看哪个线程正在等待锁771f20c0：
线程42d4在等待锁771f20c0，而锁771f20c0被线程30f8占有，我们再看看30f8线程：
它也在等待，不过从代码中看得出来它在等待线程42d4的退出，而42d4线程又在等待771f20c0锁的释放，可是锁771f20c0被30f8线程占有，由此产生的死锁，导致进程退不出来：
可是我们在线程30f8中并没有看到771f20c0锁的相关信息，这个锁是在42d2线程调用LdrShutdownThread时进行等待的，我们可以在win2K中找到它的实现：
VOID LdrShutdownThread ( VOID ) /*&#43;&#43; Routine Description: This function is called by a thread that is terminating cleanly. It&#39;s purpose is to call all of the processes DLLs to notify them that the thread is detaching. Arguments: None Return Value: None. --*/ { PPEB Peb; PLDR_DATA_TABLE_ENTRY LdrDataTableEntry; PDLL_INIT_ROUTINE InitRoutine; PLIST_ENTRY Next; Peb = NtCurrentPeb(); RtlEnterCriticalSection(&amp;LoaderLock); try { // // Go in reverse order initialization order and build // the unload list // Next = Peb-&gt;Ldr-&gt;InInitializationOrderModuleList." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a410a47213169f8437fdadb8ec2367f7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-03T20:04:17+08:00" />
<meta property="article:modified_time" content="2019-09-03T20:04:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DLL释放引起的死锁问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>DLL释放引起的死锁问题</h4> 
 <ul><li><a href="#_1" rel="nofollow">一，问题介绍</a></li><li><a href="#_7" rel="nofollow">二，问题分析</a></li><li><a href="#_110" rel="nofollow">三，问题总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一，问题介绍</h2> 
<p>     最近在做代码重构，今早对前两天重构的某个组件进行自测时，突然发现停止程序运行时，出现了卡死，进程退不出，查看日志发现是FreeLibrary没有走完。打开任务管理器-》性能-》资源监视器，找到进程，右键分析分析等待链，结果如下：<br> <img src="https://images2.imgbox.com/e4/f0/aajERkRH_o.png" alt="在这里插入图片描述"><br>      出现了死锁，16800线程是主线程（调用FreeLibrary），12128是DLL中的工作线程，两个线程互相等待，导致死锁，进程退不出。</p> 
<h2><a id="_7"></a>二，问题分析</h2> 
<p>     打开Windbg，配好pdb文件和源码路径，attach到该进程上，输入<code>!locks</code>命令，查看当前进程锁的情况：<br> <img src="https://images2.imgbox.com/78/f6/M7mwlUrY_o.png" alt="在这里插入图片描述">     可以发现锁771f20c0处于死锁状态，它此时被30f8线程占有。再输入<code>~*kb</code>查看所有线程，看看哪个线程正在等待锁771f20c0：<br> <img src="https://images2.imgbox.com/3a/39/x14TgdP4_o.png" alt="在这里插入图片描述">     线程42d4在等待锁771f20c0，而锁771f20c0被线程30f8占有，我们再看看30f8线程：<br> <img src="https://images2.imgbox.com/56/64/JxFg97Z2_o.png" alt="在这里插入图片描述"><br>      它也在等待，不过从代码中看得出来它在等待线程42d4的退出，而42d4线程又在等待771f20c0锁的释放，可是锁771f20c0被30f8线程占有，由此产生的死锁，导致进程退不出来：<br> <img src="https://images2.imgbox.com/4d/c0/VS3qUNDi_o.png" alt="在这里插入图片描述"><br>      可是我们在线程30f8中并没有看到771f20c0锁的相关信息，这个锁是在42d2线程调用LdrShutdownThread时进行等待的，我们可以在win2K中找到它的实现：</p> 
<pre><code>VOID
LdrShutdownThread (
    VOID
    )
/*++
Routine Description:
    This function is called by a thread that is terminating cleanly.
    It's purpose is to call all of the processes DLLs to notify them
    that the thread is detaching.
Arguments:
    None
Return Value:
    None.
--*/
{
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PDLL_INIT_ROUTINE InitRoutine;
    PLIST_ENTRY Next;
 
    Peb = NtCurrentPeb();
 
    RtlEnterCriticalSection(&amp;LoaderLock);
 
    try {
        //
        // Go in reverse order initialization order and build
        // the unload list
        //
 
        Next = Peb-&gt;Ldr-&gt;InInitializationOrderModuleList.Blink;
        while ( Next != &amp;Peb-&gt;Ldr-&gt;InInitializationOrderModuleList) {
            LdrDataTableEntry
                = (PLDR_DATA_TABLE_ENTRY)
                  (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InInitializationOrderLinks));
 
            Next = Next-&gt;Blink;
 
            //
            // Walk through the entire list looking for
            // entries. For each entry, that has an init
            // routine, call it.
            //
 
            if (Peb-&gt;ImageBaseAddress != LdrDataTableEntry-&gt;DllBase) {
                if ( !(LdrDataTableEntry-&gt;Flags &amp; LDRP_DONT_CALL_FOR_THREADS)) {
                    InitRoutine = (PDLL_INIT_ROUTINE)LdrDataTableEntry-&gt;EntryPoint;
                    if (InitRoutine &amp;&amp; (LdrDataTableEntry-&gt;Flags &amp; LDRP_PROCESS_ATTACH_CALLED) ) {
                        if (LdrDataTableEntry-&gt;Flags &amp; LDRP_IMAGE_DLL) {
                            if ( LdrDataTableEntry-&gt;TlsIndex ) {
                                LdrpCallTlsInitializers(LdrDataTableEntry-&gt;DllBase,DLL_THREAD_DETACH);
                                }
 
#if defined (WX86)
                            if (!Wx86ProcessInit ||
                                LdrpRunWx86DllEntryPoint(InitRoutine,
                                                        NULL,
                                                        LdrDataTableEntry-&gt;DllBase,
                                                        DLL_THREAD_DETACH,
                                                        NULL
                                                        ) ==  STATUS_IMAGE_MACHINE_TYPE_MISMATCH)
#endif
                               {
                                LdrpCallInitRoutine(InitRoutine,
                                                    LdrDataTableEntry-&gt;DllBase,
                                                    DLL_THREAD_DETACH,
                                                    NULL);
                                }
                            }
                        }
                    }
                }
            }
 
        //
        // If the image has tls than call its initializers
        //
 
        if ( LdrpImageHasTls ) {
            LdrpCallTlsInitializers(NtCurrentPeb()-&gt;ImageBaseAddress,DLL_THREAD_DETACH);
            }
        LdrpFreeTls();
 
    } finally {
 
        RtlLeaveCriticalSection(&amp;LoaderLock);
    }
}
</code></pre> 
<p>     锁771f20c0也就是LoaderLock，LoaderLock是dll加载和释放时微软内部给的一把锁（就是一个临界区），它在LoadLibrary和FreeLibrary时都会用到，我们以FreeLibrary来看：<br> <img src="https://images2.imgbox.com/f6/89/Cp8xv9fd_o.png" alt="在这里插入图片描述"><br>      在红色函数内部就会去获取LoaderLock这把锁，继续走会到DLL的各个析构函数里面。而在我们的析构函数里会通知线程退出，并用WaitForSingleObject等待各个创建的线程退出，最终也会调用_LdrShutdownThread，而这个函数内部也在等待LoaderLock这把锁，由此导致了死锁。</p> 
<h2><a id="_110"></a>三，问题总结</h2> 
<p>     对于DLL中的线程释放，最好提供一个导出函数，函数内部专门处理各个线程的释放，由外部调用方主动调用该函数，切记不可使用全局类或者静态类的析构函数来进行线程的释放退出。</p> 
<p>参考文献：<br> 1，https://blog.csdn.net/breaksoftware/article/details/8163663<br> 2，《windows核心编程》第二十章</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8216157ee6037682a2c36d701738705/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot开发日记(五)——如何在@Query中动态的判断参数是否为空</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/10d31caf7af80abf4a8157cee8f8eccc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue.js点击判断是否已经登录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>