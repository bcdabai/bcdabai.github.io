<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PHP超时处理全面总结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PHP超时处理全面总结" />
<meta property="og:description" content="【 概述 】
在PHP开发中工作里非常多使用到超时处理到超时的场合，我说几个场景：
1. 异步获取数据如果某个后端数据源获取不成功则跳过，不影响整个页面展现
2. 为了保证Web服务器不会因为当个页面处理性能差而导致无法访问其他页面，则会对某些页面操作设置
3. 对于某些上传或者不确定处理时间的场合，则需要对整个流程中所有超时设置为无限，否则任何一个环节设置不当，都会导致莫名执行中断
4. 多个后端模块(MySQL、Memcached、HTTP接口)，为了防止单个接口性能太差，导致整个前面获取数据太缓慢，影响页面打开速度，引起雪崩
5. 。。。很多需要超时的场合
这些地方都需要考虑超时的设定，但是PHP中的超时都是分门别类，各个处理方式和策略都不同，为了系统的描述，我总结了PHP中常用的超时处理的总结。
【Web服务器超时处理】
[ Apache ]
一般在性能很高的情况下，缺省所有超时配置都是30秒，但是在上传文件，或者网络速度很慢的情况下，那么可能触发超时操作。
目前 apache fastcgi php-fpm 模式 下有三个超时设置：
fastcgi 超时设置：
修改 httpd.conf 的fastcgi连接配置，类似如下：
FastCgiExternalServer /home/forum/apache/apache_php/cgi-bin/php-cgi -socket /home/forum/php5/etc/php-fpm.sock
ScriptAlias /fcgi-bin/ &#34;/home/forum/apache/apache_php/cgi-bin/&#34;
AddHandler php-fastcgi .php
Action php-fastcgi /fcgi-bin/php-cgi
AddType application/x-httpd-php .php
&lt;/ifmodule mod_fastcgi.c&gt; 缺省配置是 30s，如果需要定制自己的配置，需要修改配置，比如修改为100秒：(修改后重启 apache)：
&lt;/ifmodule mod_fastcgi.c&gt;
FastCgiExternalServer /home/forum/apache/apache_php/cgi-bin/php-cgi -socket /home/forum/php5/etc/php-fpm.sock -idle-timeout 100
ScriptAlias /fcgi-bin/ &#34;/home/forum/apache/apache_php/cgi-bin/&#34;
AddHandler php-fastcgi .php
Action php-fastcgi /fcgi-bin/php-cgi" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/37ed2ca78647d86f25dd0a39c1a3a150/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-08-14T11:01:15+08:00" />
<meta property="article:modified_time" content="2012-08-14T11:01:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PHP超时处理全面总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left"><strong>【 概述 】</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    在PHP开发中工作里非常多使用到超时处理到超时的场合，我说几个场景：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    1. 异步获取数据如果某个后端数据源获取不成功则跳过，不影响整个页面展现</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    2. 为了保证Web服务器不会因为当个页面处理性能差而导致无法访问其他页面，则会对某些页面操作设置</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    3. 对于某些上传或者不确定处理时间的场合，则需要对整个流程中所有超时设置为无限，否则任何一个环节设置不当，都会导致莫名执行中断</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    4. 多个后端模块(MySQL、Memcached、HTTP接口)，为了防止单个接口性能太差，导致整个前面获取数据太缓慢，影响页面打开速度，引起雪崩</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    5. 。。。很多需要超时的场合</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    这些地方都需要考虑超时的设定，但是PHP中的超时都是分门别类，各个处理方式和策略都不同，为了系统的描述，我总结了PHP中常用的超时处理的总结。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>【Web服务器超时处理】</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>[ Apache ]</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    一般在性能很高的情况下，缺省所有超时配置都是30秒，但是在上传文件，或者网络速度很慢的情况下，那么可能触发超时操作。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    目前 apache fastcgi php-fpm 模式 下有三个超时设置：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    fastcgi 超时设置：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    修改 httpd.conf 的fastcgi连接配置，类似如下：</p> 
<table border="1" width="80%" bgcolor="#ffffff" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px"> <p>     FastCgiExternalServer /home/forum/apache/apache_php/cgi-bin/php-cgi -socket /home/forum/php5/etc/php-fpm.sock</p> <p>     ScriptAlias /fcgi-bin/ "/home/forum/apache/apache_php/cgi-bin/"</p> <p>     AddHandler php-fastcgi .php</p> <p>     Action php-fastcgi /fcgi-bin/php-cgi</p> <p>     AddType application/x-httpd-php .php</p> <p>    </p> &lt;/ifmodule mod_fastcgi.c&gt;</td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    缺省配置是 30s，如果需要定制自己的配置，需要修改配置，比如修改为100秒：(修改后重启 apache)：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    </p> 
<table border="1" width="80%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px"> <p>    &lt;/ifmodule mod_fastcgi.c&gt;</p> <p>     FastCgiExternalServer /home/forum/apache/apache_php/cgi-bin/php-cgi -socket /home/forum/php5/etc/php-fpm.sock  -idle-timeout <strong>100</strong></p> <p>     ScriptAlias /fcgi-bin/ "/home/forum/apache/apache_php/cgi-bin/"</p> <p>     AddHandler php-fastcgi .php</p> <p>     Action php-fastcgi /fcgi-bin/php-cgi</p> <p>     AddType application/x-httpd-php .php</p> <p>    </p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    如果超时会返回500错误，断开跟后端php服务的连接，同时记录一条apache错误日志：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    [Thu Jan 27 18:30:15 2011] [error] [client 10.81.41.110] FastCGI: comm with server "/home/forum/apache/apache_php/cgi-bin/php-cgi" aborted: idle timeout (30 sec)</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    [Thu Jan 27 18:30:15 2011] [error] [client 10.81.41.110] FastCGI: incomplete headers (0 bytes) received from server "/home/forum/apache/apache_php/cgi-bin/php-cgi"</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    其他 fastcgi 配置参数说明：</p> 
<table border="1" width="80%" bgcolor="#ffffff" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px">IdleTimeout 发呆时限 <p>    ProcessLifeTime 一个进程的最长生命周期，过期之后无条件kill</p> <p>    MaxProcessCount 最大进程个数</p> <p>    DefaultMinClassProcessCount 每个程序启动的最小进程个数</p> <p>    DefaultMaxClassProcessCount 每个程序启动的最大进程个数</p> <p>    IPCConnectTimeout 程序响应超时时间</p> <p>    IPCCommTimeout 与程序通讯的最长时间，上面的错误有可能就是这个值设置过小造成的</p> <p>    MaxRequestsPerProcess 每个进程最多完成处理个数，达成后自杀</p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>[ Lighttpd ]</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    配置：lighttpd.conf</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    Lighttpd配置中，关于超时的参数有如下几个(篇幅考虑，只写读超时，写超时参数同理)：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    主要涉及选项：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    server.max-keep-alive-idle = 5</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    server.max-read-idle = 60</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    server.read-timeout = 0</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    server.max-connection-idle = 360</p> 
<table border="1" width="80%" bgcolor="#d8d8d8" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px"> <p>    --------------------------------------------------</p> <p>    # 每次keep-alive 的最大请求数, 默认值是16</p> <p>    server.max-keep-alive-requests = 100</p> <p>    # keep-alive的最长等待时间, 单位是秒，默认值是5</p> <p>    server.max-keep-alive-idle = 1200</p> <p>    # lighttpd的work子进程数，默认值是0，单进程运行</p> <p>    server.max-worker = 2</p> <p>    # 限制用户在发送请求的过程中，最大的中间停顿时间(单位是秒)，</p> <p>    # 如果用户在发送请求的过程中(没发完请求)，中间停顿的时间太长，lighttpd会主动断开连接</p> <p>    # 默认值是60(秒)</p> <p>    server.max-read-idle = 1200</p> <p>    # 限制用户在接收应答的过程中，最大的中间停顿时间(单位是秒)，</p> <p>    # 如果用户在接收应答的过程中(没接完)，中间停顿的时间太长，lighttpd会主动断开连接</p> <p>    # 默认值是360(秒)</p> <p>    server.max-write-idle = 12000</p> <p>    # 读客户端请求的超时限制，单位是秒, 配为0表示不作限制</p> <p>    # 设置小于max-read-idle时，read-timeout生效</p> <p>    server.read-timeout = 0</p> <p>    # 写应答页面给客户端的超时限制，单位是秒，配为0表示不作限制</p> <p>    # 设置小于max-write-idle时，write-timeout生效</p> <p>    server.write-timeout = 0</p> <p>    # 请求的处理时间上限，如果用了mod_proxy_core，那就是和后端的交互时间限制, 单位是秒</p> <p>    server.max-connection-idle = 1200</p> <p>    --------------------------------------------------</p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>说明：</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    对于一个keep-alive连接上的连续请求，发送第一个请求内容的最大间隔由参数max-read-idle决定，从第二个请求起，发送请求内容的最大间隔由参数max-keep-alive-idle决定。请求间的间隔超时也由max-keep-alive-idle决定。发送请求内容的总时间超时由参数read-timeout决定。Lighttpd与后端交互数据的超时由max-connection-idle决定。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    延伸阅读：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://www.snooda.com/read/244</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>[ Nginx ]</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    配置：nginx.conf</p> 
<table border="1" width="80%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px"> <p>    http { </p> <p>     #Fastcgi: (针对后端的fastcgi 生效, fastcgi 不属于proxy模式)</p> <p>     fastcgi_connect_timeout 5;    #连接超时</p> <p>     fastcgi_send_timeout 10;       #写超时</p> <p>     fastcgi_read_timeout 10;        #读取超时</p> <p>     #Proxy: (针对proxy/upstreams的生效)</p> <p>     proxy_connect_timeout 15s;    #连接超时</p> <p>     proxy_read_timeout 24s;          #读超时</p> <p>     proxy_send_timeout 10s;         #写超时</p> <p>    }</p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>说明：</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    Nginx 的超时设置倒是非常清晰容易理解，上面超时针对不同工作模式，但是因为超时带来的问题是非常多的。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    延伸阅读：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://hi.baidu.com/pibuchou/blog/item/a1e330dd71fb8a5995ee3753.html</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://hi.baidu.com/pibuchou/blog/item/7cbccff0a3b77dc60b46e024.html</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://hi.baidu.com/pibuchou/blog/item/10a549818f7e4c9df703a626.html</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://www.apoyl.com/?p=466</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>【PHP本身超时处理】</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>[ PHP-fpm ] </strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    配置：php-fpm.conf</p> 
<table border="1" width="80%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:826px"> <p>    </p> <p>    </p> <p>    //...</p> <p>    Sets the limit on the number of simultaneous requests that will be served.</p> <p>    Equivalent to Apache MaxClients directive.</p> <p>    Equivalent to PHP_FCGI_CHILDREN environment in original php.fcgi</p> <p>    Used with any pm_style.</p> <p>    #php-cgi的进程数量</p> <p>    128&lt;/value name="max_children"&gt;</p> <p>    The timeout (in seconds) for serving a single request after which the worker process will be terminated</p> <p>    Should be used when \'max_execution_time\' ini option does not stop script execution for some reason</p> <p>    \'0s\' means \'off\'</p> <p>    #php-fpm 请求执行超时时间，0s为永不超时，否则设置一个 Ns 为超时的秒数</p> <p>    0s&lt;/value name="request_terminate_timeout"&gt;</p> <p>    The timeout (in seconds) for serving of single request after which a php backtrace will be dumped to slow.log file</p> <p>    \'0s\' means \'off\'</p> <p>    0s&lt;/value name="request_slowlog_timeout"&gt;</p> <p>    </p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>说明：</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    在 php.ini 中，有一个参数 max_execution_time 可以设置 PHP 脚本的最大执行时间，但是，在 php-cgi(php-fpm) 中，该参数不会起效。真正能够控制 PHP 脚本最大执行时：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    0s  &lt;/value name="request_terminate_timeout"&gt;</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    就是说如果是使用 mod_php5.so 的模式运行 max_execution_time 是会生效的，但是如果是php-fpm模式中运行时不生效的。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    延伸阅读：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://blog.s135.com/file_get_contents/</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>[ PHP ]</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    配置：php.ini</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    选项：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    max_execution_time = 30</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    或者在代码里设置：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    ini_set("max_execution_time", 30);</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    set_time_limit(30);</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>说明：</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    对当前会话生效，比如设置0一直不超时，但是如果php的 safe_mode 打开了，这些设置都会不生效。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    效果一样，但是具体内容需要参考php-fpm部分内容，如果php-fpm中设置了 request_terminate_timeout 的话，那么 max_execution_time 就不生效。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>【后端&amp;接口访问超时】</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>【HTTP访问】</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    一般我们访问HTTP方式很多，主要是：curl, socket, file_get_contents() 等方法。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    如果碰到对方服务器一直没有响应的时候，我们就悲剧了，很容易把整个服务器搞死，所以在访问http的时候也需要考虑超时的问题。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    [ CURL 访问HTTP]</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    CURL 是我们常用的一种比较靠谱的访问HTTP协议接口的lib库，性能高，还有一些并发支持的功能等。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    CURL:</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl_setopt($ch, opt) 可以设置一些超时的设置，主要包括：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    *(重要) CURLOPT_TIMEOUT 设置cURL允许执行的最长秒数。   </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    *(重要) CURLOPT_TIMEOUT_MS 设置cURL允许执行的最长毫秒数。 (在cURL 7.16.2中被加入。从PHP 5.2.3起可使用。 )</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    CURLOPT_CONNECTTIMEOUT 在发起连接前等待的时间，如果设置为0，则无限等待。  </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    CURLOPT_CONNECTTIMEOUT_MS 尝试连接等待的时间，以毫秒为单位。如果设置为0，则无限等待。  在cURL 7.16.2中被加入。从PHP 5.2.3开始可用。  </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    CURLOPT_DNS_CACHE_TIMEOUT 设置在内存中保存DNS信息的时间，默认为120秒。  </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl普通秒级超时：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    $ch = curl_init(); </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl_setopt($ch, CURLOPT_URL,$url); </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl_setopt($ch, CURLOPT_TIMEOUT, 60);   //只需要设置一个秒的数量就可以</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers); </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl_setopt($ch, CURLOPT_USERAGENT, $defined_vars[\'HTTP_USER_AGENT\']); </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl普通秒级超时使用：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl_setopt($ch, CURLOPT_TIMEOUT, 60);</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl如果需要进行毫秒超时，需要增加：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L); </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    或者是：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl_setopt ( $ch,  CURLOPT_NOSIGNAL, true); 是可以支持毫秒级别超时设置的</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    curl一个毫秒级超时的例子：</p> 
<table border="1" width="80%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px"> <p>    </p> <p>    if (!isset($_GET[\'foo\'])) {<!-- --></p> <p>    // Client</p> <p>    $ch = curl_init(\'http://example.com/\');</p> <p>    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);</p> <p>    curl_setopt($ch, CURLOPT_NOSIGNAL, 1);    //注意，毫秒超时一定要设置这个</p> <p>    curl_setopt($ch, CURLOPT_TIMEOUT_MS, 200);  //超时毫秒，cURL 7.16.2中被加入。从PHP 5.2.3起可使用</p> <p>    $data = curl_exec($ch);</p> <p>    $curl_errno = curl_errno($ch);</p> <p>    $curl_error = curl_error($ch);</p> <p>    curl_close($ch);</p> <p>    if ($curl_errno &gt; 0) {<!-- --></p> <p>      echo "cURL Error ($curl_errno): $curl_error\\n";</p> <p>    } else {<!-- --></p> <p>      echo "Data received: $data\\n";</p> <p>    }</p> <p>    } else {<!-- --></p> <p>    // Server</p> <p>    sleep(10);</p> <p>    echo "Done.";</p> <p>    }</p> <p>    ?&gt; </p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>其他一些技巧：</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    1. 按照经验总结是：cURL 版本 &gt;= libcurl/7.21.0 版本，毫秒级超时是一定生效的，切记。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    2. curl_multi的毫秒级超时也有问题。。单次访问是支持ms级超时的，curl_multi并行调多个会不准</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    [流处理方式访问HTTP] </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    除了curl，我们还经常自己使用fsockopen、或者是file操作函数来进行HTTP协议的处理，所以，我们对这块的超时处理也是必须的。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    一般连接超时可以直接设置，但是流读取超时需要单独处理。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    自己写代码处理:</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    $tmCurrent = gettimeofday();</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    $intUSGone = ($tmCurrent[\'sec\'] - $tmStart[\'sec\']) * 1000000</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">          + ($tmCurrent[\'usec\'] - $tmStart[\'usec\']);</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    if ($intUSGone &gt; $this-&gt;_intReadTimeoutUS) {<!-- --></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">      return false;</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    }</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    或者使用内置流处理函数 stream_set_timeout() 和 stream_get_meta_data() 处理：</p> 
<table border="1" width="80%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px">    // Timeout in seconds  <p></p> <p>    $timeout = 5; </p> <p>    $fp = fsockopen("example.com", 80, $errno, $errstr, $timeout); </p> <p>    if ($fp) { </p> <p>    fwrite($fp, "GET / HTTP/1.0\\r\\n"); </p> <p>    fwrite($fp, "Host: example.com\\r\\n"); </p> <p>    fwrite($fp, "Connection: Close\\r\\n\\r\\n"); </p> <p>    stream_set_blocking($fp, true);   //重要，设置为非阻塞模式</p> <p>    stream_set_timeout($fp,$timeout);   //设置超时</p> <p>    $info = stream_get_meta_data($fp); </p> <p>    while ((!feof($fp)) &amp;&amp; (!$info[\'timed_out\'])) { </p> <p>      $data .= fgets($fp, 4096); </p> <p>      $info = stream_get_meta_data($fp); </p> <p>      ob_flush; </p> <p>      flush(); </p> <p>    } </p> <p>    if ($info[\'timed_out\']) { </p> <p>      echo "Connection Timed Out!"; </p> <p>    } else { </p> <p>      echo $data; </p> <p>    } </p> <p>    } </p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>file_get_contents</strong> 超时：</p> 
<table border="1" width="80%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px">    $timeout = array( <p></p> <p>     \'http\' =&gt; array(</p> <p>    \'timeout\' =&gt; 5 //设置一个超时时间，单位为秒</p> <p>     )</p> <p>    );</p> <p>    $ctx = stream_context_create($timeout);</p> <p>    $text = file_get_contents("http://example.com/", 0, $ctx);</p> <p>    ?&gt;</p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>fopen </strong>超时：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    </p> 
<table border="1" width="80%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px">    $timeout = array( <p></p> <p>     \'http\' =&gt; array(</p> <p>    \'timeout\' =&gt; 5 //设置一个超时时间，单位为秒</p> <p>     )</p> <p>    );</p> <p>    $ctx = stream_context_create($timeout);</p> <p>    if ($fp = fopen("http://example.com/", "r", false, $ctx)) {<!-- --></p> <p>    while( $c = fread($fp, 8192)) {<!-- --></p> <p>     echo $c;</p> <p>    }</p> <p>    fclose($fp);</p> <p>    }</p> <p>    ?&gt;</p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>【MySQL】</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">     php中的mysql客户端都没有设置超时的选项，mysqli和mysql都没有，但是libmysql是提供超时选项的，只是我们在php中隐藏了而已。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    那么如何在PHP中使用这个操作捏，就需要我们自己定义一些MySQL操作常量，主要涉及的常量有：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    MYSQL_OPT_READ_TIMEOUT=11;</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    MYSQL_OPT_WRITE_TIMEOUT=12;</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    这两个，定义以后，可以使用 options 设置相应的值。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    不过有个注意点，mysql内部实现：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    1. 超时设置单位为秒，最少配置1秒</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    2. 但mysql底层的read会重试两次，所以实际会是 3 秒</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    重试两次 +　自身一次 = 3倍超时时间，那么就是说最少超时时间是3秒，不会低于这个值，对于大部分应用来说可以接受，但是对于小部分应用需要优化。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    查看一个设置访问mysql超时的php实例：</p> 
<table border="1" width="80%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px">    //自己定义读写超时常量 <p></p> <p>    if (!defined(\'MYSQL_OPT_READ_TIMEOUT\')) {<!-- --></p> <p>    define(\'MYSQL_OPT_READ_TIMEOUT\',  11);</p> <p>    }</p> <p>    if (!defined(\'MYSQL_OPT_WRITE_TIMEOUT\')) {<!-- --></p> <p>    define(\'MYSQL_OPT_WRITE_TIMEOUT\', 12);</p> <p>    }</p> <p>    //设置超时</p> <p>    $mysqli = mysqli_init();</p> <p>    $mysqli-&gt;options(MYSQL_OPT_READ_TIMEOUT, 3);</p> <p>    $mysqli-&gt;options(MYSQL_OPT_WRITE_TIMEOUT, 1);</p> <p>    //连接数据库</p> <p>    $mysqli-&gt;real_connect("localhost", "root", "root", "test");</p> <p>    if (mysqli_connect_errno()) {<!-- --></p> <p>    printf("Connect failed: %s/n", mysqli_connect_error());</p> <p>    exit();</p> <p>    }</p> <p>    //执行查询 sleep 1秒不超时</p> <p>    printf("Host information: %s/n", $mysqli-&gt;host_info);</p> <p>    if (!($res=$mysqli-&gt;query(\'select sleep(1)\'))) {<!-- --></p> <p>     echo "query1 error: ". $mysqli-&gt;error ."/n";</p> <p>    } else {<!-- --></p> <p>     echo "Query1: query success/n";</p> <p>    }</p> <p>    //执行查询 sleep 9秒会超时</p> <p>    if (!($res=$mysqli-&gt;query(\'select sleep(9)\'))) {<!-- --></p> <p>     echo "query2 error: ". $mysqli-&gt;error ."/n";</p> <p>    } else {<!-- --></p> <p>     echo "Query2: query success/n";</p> <p>    }</p> <p>    $mysqli-&gt;close();</p> <p>    echo "close mysql connection/n";</p> <p>    ?&gt;</p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    延伸阅读：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://blog.csdn.net/heiyeshuwu/article/details/5869813</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>【Memcached】</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>[PHP扩展]</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    php_memcache 客户端：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    连接超时：bool Memcache::connect ( string $host [, int $port [, int $timeout ]] )</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    在get和set的时候，都没有明确的超时设置参数。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    libmemcached 客户端：在php接口没有明显的超时参数。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    说明：所以说，在PHP中访问Memcached是存在很多问题的，需要自己hack部分操作，或者是参考网上补丁。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>[C&amp;C++访问Memcached]</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    客户端：libmemcached 客户端</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    说明：memcache超时配置可以配置小点，比如5，10个毫秒已经够用了，超过这个时间还不如从数据库查询。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    下面是一个连接和读取set数据的超时的C++示例：</p> 
<table border="1" width="100%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:833px"> <p>    //创建连接超时(连接到Memcached)</p> <p>    memcached_st* MemCacheProxy::_create_handle()</p> <p>    {<!-- --></p> <p>     memcached_st * mmc = NULL;</p> <p>     memcached_return_t prc;</p> <p>    if (_mpool != NULL) {  // get from pool</p> <p>     mmc = memcached_pool_pop(_mpool, false, &amp;prc);</p> <p>     if (mmc == NULL) {<!-- --></p> <p>     __LOG_WARNING__("MemCacheProxy", "get handle from pool error [%d]", (int)prc);</p> <p>     }</p> <p>     return mmc;</p> <p>     }</p> <p>     memcached_st* handle = memcached_create(NULL);</p> <p>     if (handle == NULL){<!-- --></p> <p>     __LOG_WARNING__("MemCacheProxy", "create_handle error");</p> <p>     return NULL;</p> <p>     }</p> <p>    // 设置连接/读取超时</p> <p>    memcached_behavior_set(handle, MEMCACHED_BEHAVIOR_HASH, MEMCACHED_HASH_DEFAULT);</p> <p>    memcached_behavior_set(handle, MEMCACHED_BEHAVIOR_NO_BLOCK, _noblock);  //参数MEMCACHED_BEHAVIOR_NO_BLOCK为1使超时配置生效，不设置超时会不生效，关键时候会悲剧的，容易引起雪崩</p> <p>    memcached_behavior_set(handle, MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT, _connect_timeout);  //连接超时</p> <p>    memcached_behavior_set(handle, MEMCACHED_BEHAVIOR_RCV_TIMEOUT, _read_timeout);    //读超时</p> <p>    memcached_behavior_set(handle, MEMCACHED_BEHAVIOR_SND_TIMEOUT, _send_timeout);    //写超时</p> <p>    memcached_behavior_set(handle, MEMCACHED_BEHAVIOR_POLL_TIMEOUT, _poll_timeout);</p> <p>    // 设置一致hash</p> <p>    //      memcached_behavior_set_distribution(handle, MEMCACHED_DISTRIBUTION_CONSISTENT);</p> <p>     memcached_behavior_set(handle, MEMCACHED_BEHAVIOR_DISTRIBUTION, MEMCACHED_DISTRIBUTION_CONSISTENT);</p> <p>    memcached_return rc;</p> <p>    for (uint i = 0; i &lt; _server_count; i++){<!-- --></p> <p>     rc = memcached_server_add(handle, _ips[i], _ports[i]);</p> <p>     if (MEMCACHED_SUCCESS != rc) {<!-- --></p> <p>     __LOG_WARNING__("MemCacheProxy", "add server [%s:%d] failed.", _ips[i], _ports[i]);</p> <p>     }</p> <p>    }</p> <p>    _mpool = memcached_pool_create(handle, _min_connect, _max_connect);</p> <p>    if (_mpool == NULL){<!-- --></p> <p>     __LOG_WARNING__("MemCacheProxy", "create_pool error");</p> <p>     return NULL;</p> <p>    }</p> <p>    mmc = memcached_pool_pop(_mpool, false, &amp;prc);</p> <p>    if (mmc == NULL) {<!-- --></p> <p>     __LOG_WARNING__("MyMemCacheProxy", "get handle from pool error [%d]", (int)prc);</p> <p>    }</p> <p>    //__LOG_DEBUG__("MemCacheProxy", "get handle [%p]", handle);</p> <p>    return mmc;</p> <p>    }</p> <p>    //设置一个key超时(set一个数据到memcached)</p> <p>    bool MemCacheProxy::_add(memcached_st* handle, unsigned int* key, const char* value, int len, unsigned int timeout)</p> <p>    {<!-- --></p> <p>    memcached_return rc;</p> <p>    char tmp[1024];</p> <p>    snprintf(tmp, sizeof (tmp), "%u#%u", key[0], key[1]);</p> <p>    //有个timeout值</p> <p>    rc = memcached_set(handle, tmp, strlen(tmp), (char*)value, len, <strong>timeout</strong>, 0);</p> <p>    if (MEMCACHED_SUCCESS != rc){<!-- --></p> <p>     return false;</p> <p>    } </p> <p>    return true;</p> <p>    }</p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    //Memcache读取数据超时 (没有设置)</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    libmemcahed 源码中接口定义：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    LIBMEMCACHED_API char *memcached_get(memcached_st *ptr,const char *key, size_t key_length,size_t *value_length,uint32_t *flags,memcached_return_t *error);</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    LIBMEMCACHED_API memcached_return_t memcached_mget(memcached_st *ptr,const char * const *keys,const size_t *key_length,size_t number_of_keys);</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    从接口中可以看出在读取数据的时候，是没有超时设置的。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    延伸阅读：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://hi.baidu.com/chinauser/item/b30af90b23335dde73e67608</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://libmemcached.org/libMemcached.html</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>【如何实现超时】</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    程序中需要有超时这种功能，比如你单独访问一个后端Socket模块，Socket模块不属于我们上面描述的任何一种的时候，它的协议也是私有的，那么这个时候可能需要自己去实现一些超时处理策略，这个时候就需要一些处理代码了。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>[PHP中超时实现] </strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>一、初级：最简单的超时实现 (秒级超时)</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    思路很简单：链接一个后端，然后设置为非阻塞模式，如果没有连接上就一直循环，判断当前时间和超时时间之间的差异。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    php socket 中实现原始的超时：(每次循环都当前时间去减，性能会很差，cpu占用会较高)</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    </p> 
<table border="1" width="80%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px">     $host = "127.0.0.1"; <p></p> <p>     $port = "80";</p> <p>     $timeout = 15;  //timeout in seconds</p> <p>     $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP)</p> <p>    or die("Unable to create socket\\n");</p> <p>     socket_set_nonblock($socket)     //务必设置为阻塞模式</p> <p>    or die("Unable to set nonblock on socket\\n");</p> <p>     $time = time();</p> <p>     //循环的时候每次都减去相应值</p> <p>     while (!@socket_connect($socket, $host, $port))    //如果没有连接上就一直死循环</p> <p>     {<!-- --></p> <p>    $err = socket_last_error($socket);</p> <p>    if ($err == 115 || $err == 114)</p> <p>    {<!-- --></p> <p>    if ((time() - $time) &gt;= $timeout)    //每次都需要去判断一下是否超时了</p> <p>    {<!-- --></p> <p>     socket_close($socket);</p> <p>     die("Connection timed out.\\n");</p> <p>    }</p> <p>    sleep(1);</p> <p>    continue;</p> <p>    }</p> <p>    die(socket_strerror($err) . "\\n");</p> <p>     }</p> <p>     socket_set_block($this-&gt;socket)    //还原阻塞模式</p> <p>    or die("Unable to set block on socket\\n");</p> <p>    ?&gt; </p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>二、升级：使用PHP自带异步IO去实现(毫秒级超时)</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>说明：</strong></p> 
<span style="font-family:宋体; font-size:13px; line-height:18px; text-align:left"></span> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left"><strong>     </strong>异步IO：异步IO的概念和同步IO相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。异步IO将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方从不知道它们会在什么时候到达。</p> 
<span style="font-family:宋体; font-size:13px; line-height:18px; text-align:left"></span> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">     多路复用：复用模型是对多个IO操作进行检测，返回可操作集合，这样就可以对其进行操作了。这样就避免了阻塞IO不能随时处理各个IO和非阻塞占用系统资源的确定。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    ​</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    使用 socket_select() 实现超时</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    socket_select(..., floor($timeout), ceil($timeout*1000000));</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">     select的特点：能够设置到微秒级别的超时！</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    使用socket_select() 的超时代码(需要了解一些异步IO编程的知识去理解)</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    </p> 
<table border="1" width="80%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px"> <p>    ### 调用类 ####</p> <p>    </p> <p>    $server = new Server; </p> <p>    $client = new Client; </p> <p>    for (;;) { </p> <p>    foreach ($select-&gt;can_read(0) as $socket) { </p> <p>     if ($socket == $client-&gt;socket) { </p> <p>    // New Client Socket </p> <p>    $select-&gt;add(socket_accept($client-&gt;socket)); </p> <p>     } </p> <p>     else { </p> <p>    //there\'s something to read on $socket </p> <p>     } </p> <p>    } </p> <p>    } </p> <p>    ?&gt; </p> <p>    ### 异步多路复用IO &amp; 超时连接处理类 ###</p> <p>    </p> <p>    class select { </p> <p>    var $sockets; </p> <p>    function select($sockets) { </p> <p>     $this-&gt;sockets = array(); </p> <p>     foreach ($sockets as $socket) { </p> <p>    $this-&gt;add($socket); </p> <p>     } </p> <p>    } </p> <p>    function add($add_socket) { </p> <p>     array_push($this-&gt;sockets,$add_socket); </p> <p>    } </p> <p>    function remove($remove_socket) { </p> <p>     $sockets = array(); </p> <p>     foreach ($this-&gt;sockets as $socket) { </p> <p>    if($remove_socket != $socket) </p> <p>    $sockets[] = $socket; </p> <p>     } </p> <p>     $this-&gt;sockets = $sockets; </p> <p>    } </p> <p>    function can_read($timeout) { </p> <p>     $read = $this-&gt;sockets; </p> <p>     socket_select($read,$write = NULL,$except = NULL,$timeout); </p> <p>     return $read; </p> <p>    } </p> <p>    function can_write($timeout) { </p> <p>     $write = $this-&gt;sockets; </p> <p>     socket_select($read = NULL,$write,$except = NULL,$timeout); </p> <p>     return $write; </p> <p>    } </p> <p>    } </p> <p>    ?&gt; </p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>[C&amp;C++中超时实现] </strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    一般在Linux C/C++中，可以使用：alarm() 设置定时器的方式实现秒级超时，或者：select()、poll()、epoll() 之类的异步复用IO实现毫秒级超时。也可以使用二次封装的异步io库(libevent, libev)也能实现。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>一、使用alarm中用信号实现超时 (秒级超时)</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    说明：Linux内核connect超时通常为75秒，我们可以设置更小的时间如10秒来提前从connect中返回。这里用使用信号处理机制，调用alarm，超时后产生SIGALRM信号 (也可使用select实现) </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    用 alarym 秒级实现　connect 设置超时代码示例：</p> 
<table border="1" width="80%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:532px">//信号处理函数 <p>    static void connect_alarm(int signo)</p> <p>    {<!-- --></p> <p>    debug_printf("SignalHandler");</p> <p>    return;</p> <p>    }</p> <p>    //alarm超时连接实现</p> <p>    static void conn_alarm()</p> <p>    { </p> <p>    　　Sigfunc * sigfunc ; //现有信号处理函数</p> <p>    　　sigfunc=signal(SIGALRM, connect_alarm); //建立信号处理函数connect_alarm,(如果有)保存现有的信号处理函数 </p> <p>     int timeout = 5;</p> <p>     //设置闹钟</p> <p>    　　if( alarm(timeout)!=0 ){ </p> <p>    　　  //... 闹钟已经设置处理</p> <p>    　　} </p> <p>     //进行连接操作</p> <p>     if (connect(m_Socket, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0 ) {<!-- --></p> <p>    if ( errno == EINTR ) { //如果错误号设置为EINTR，说明超时中断了</p> <p>    debug_printf("Timeout");</p> <p>    m_connectionStatus = STATUS_CLOSED;</p> <p>    errno = ETIMEDOUT; //防止三次握手继续进行 </p> <p>    return ERR_TIMEOUT;</p> <p>    }</p> <p>    else {<!-- --></p> <p>    debug_printf("Other Err");</p> <p>    m_connectionStatus = STATUS_CLOSED;</p> <p>    return ERR_NET_SOCKET;</p> <p>    }</p> <p>     }</p> <p>    　　alarm(0);//关闭时钟 </p> <p>    　　signal(SIGALRM, sigfunc); //(如果有)恢复原来的信号处理函数 </p> <p>    　　return; </p> <p>    }</p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    //读取数据的超时设置</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    同样可以为 recv 设置超时，5秒内收不到任何应答就中断 </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    signal( ... ); </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    alarm(5); </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    recv( ... ); </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    alarm(0); </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    static void sig_alarm(int signo){return;} </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    当客户端阻塞于读(readline,...)时，如果此时服务器崩了，客户TCP试图从服务器接收一个ACK，持续重传 数据分节，大约要等9分钟才放弃重传，并返回一个错误。因此，在客户读阻塞时，调用超时。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    ​</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    二、使用异步复用IO使用 (毫秒级超时)</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    异步IO执行流程：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    1.首先将标志位设为Non-blocking模式，准备在非阻塞模式下调用connect函数</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    2.调用connect，正常情况下，因为TCP三次握手需要一些时间；而非阻塞调用只要不能立即完成就会返回错误，所以这里会返回EINPROGRESS，表示在建立连接但还没有完成。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    3.在读套接口描述符集(fd_set rset)和写套接口描述符集(fd_set wset)中将当前套接口置位(用FD_ZERO()、FD_SET()宏)，并设置好超时时间(struct timeval *timeout)</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    4.调用select( socket, &amp;rset, &amp;wset, NULL, timeout )</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    返回0表示connect超时，如果你设置的超时时间大于75秒就没有必要这样做了，因为内核中对connect有超时限制就是75秒。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    //select 实现毫秒级超时示例：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">      </p> 
<table border="1" width="80%" bgcolor="#f2f2f2" style="color:rgb(0,0,0); font-family:宋体; font-size:13px; line-height:18px; text-align:left"><tbody><tr><td style="width:602px"> <p>    static void conn_select() {<!-- --></p> <p>     // Open TCP Socket</p> <p>     m_Socket = socket(PF_INET,SOCK_STREAM,0);</p> <p>     if( m_Socket &lt; 0 )</p> <p>     {<!-- --></p> <p>    m_connectionStatus = STATUS_CLOSED;</p> <p>    return ERR_NET_SOCKET;</p> <p>     }</p> <p>     struct sockaddr_in addr;</p> <p>     inet_aton(m_Host.c_str(), &amp;addr.sin_addr);</p> <p>     addr.sin_port = htons(m_Port);</p> <p>     addr.sin_family = PF_INET;</p> <p>     // Set timeout values for socket</p> <p>     struct timeval timeouts;</p> <p>     timeouts.tv_sec = SOCKET_TIMEOUT_SEC ;   // const -&gt; 5</p> <p>     timeouts.tv_usec = SOCKET_TIMEOUT_USEC ; // const -&gt; 0</p> <p>     uint8_t optlen = sizeof(timeouts);</p> <p>     if( setsockopt( m_Socket, SOL_SOCKET, SO_RCVTIMEO,&amp;timeouts,(socklen_t)optlen) &lt; 0 )</p> <p>     {<!-- --></p> <p>    m_connectionStatus = STATUS_CLOSED;</p> <p>    return ERR_NET_SOCKET;</p> <p>     }</p> <p>     // Set the Socket to TCP Nodelay ( Send immediatly after a send / write command )</p> <p>     int flag_TCP_nodelay = 1;</p> <p>     if ( (setsockopt( m_Socket, IPPROTO_TCP, TCP_NODELAY,</p> <p>    (char *)&amp;flag_TCP_nodelay, sizeof(flag_TCP_nodelay))) &lt; 0)</p> <p>     {<!-- --></p> <p>    m_connectionStatus = STATUS_CLOSED;</p> <p>    return ERR_NET_SOCKET;</p> <p>     }</p> <p>     // Save Socket Flags</p> <p>     int opts_blocking = fcntl(m_Socket, F_GETFL);</p> <p>     if ( opts_blocking &lt; 0 )</p> <p>     {<!-- --></p> <p>    return ERR_NET_SOCKET;</p> <p>     }</p> <p>     //设置为非阻塞模式</p> <p>     int opts_noblocking = (opts_blocking | O_NONBLOCK);</p> <p>     // Set Socket to Non-Blocking</p> <p>     if (fcntl(m_Socket, F_SETFL, opts_noblocking)&lt;0)</p> <p>     {<!-- --></p> <p>    return ERR_NET_SOCKET;</p> <p>     }</p> <p>     // Connect</p> <p>     if ( connect(m_Socket, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0)</p> <p>     {<!-- --></p> <p>    // EINPROGRESS always appears on Non Blocking connect</p> <p>    if ( errno != EINPROGRESS )</p> <p>    {<!-- --></p> <p>    m_connectionStatus = STATUS_CLOSED;</p> <p>    return ERR_NET_SOCKET;</p> <p>    }</p> <p>    // Create a set of sockets for select</p> <p>    fd_set socks;</p> <p>    FD_ZERO(&amp;socks);</p> <p>    FD_SET(m_Socket,&amp;socks);</p> <p>    // Wait for connection or timeout</p> <p>    int fdcnt = select(m_Socket+1,NULL,&amp;socks,NULL,&amp;timeouts);</p> <p>    if ( fdcnt &lt; 0 )</p> <p>    {<!-- --></p> <p>    return ERR_NET_SOCKET;</p> <p>    }</p> <p>    else if ( fdcnt == 0 )</p> <p>    {<!-- --></p> <p>    return ERR_TIMEOUT;</p> <p>    }</p> <p>     }</p> <p>     //Set Socket to Blocking again</p> <p>     if(fcntl(m_Socket,F_SETFL,opts_blocking)&lt;0)</p> <p>     {<!-- --></p> <p>    return ERR_NET_SOCKET;</p> <p>     }</p> <p>     m_connectionStatus = STATUS_OPEN;</p> <p>     return 0;</p> <p>    }</p> </td></tr></tbody></table> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    说明：在超时实现方面，不论是什么脚本语言：PHP、Python、Perl 基本底层都是C&amp;C++的这些实现方式，需要理解这些超时处理，需要一些Linux 编程和网络编程的知识。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    延伸阅读：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://blog.sina.com.cn/s/blog_4462f8560100tvgo.html</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://blog.csdn.net/thimin/article/details/1530839</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://hi.baidu.com/xjtdy888/item/93d9daefcc1d31d1ea34c992</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://blog.csdn.net/byxdaz/article/details/5461142</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://blog.163.com/xychenbaihu@yeah/blog/static/13222965520112163171778/</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://hi.baidu.com/suyupin/item/df10004decb620e91f19bcf5</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://stackoverflow.com/questions/7092633/connect-timeout-with-alarm</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://stackoverflow.com/questions/7089128/linux-tcp-connect-with-select-fails-at-testserver?lq=1</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    http://cppentry.com/bencandy.php?fid=54&amp;id=1129</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>【 总结 】</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>1. PHP应用层如何设置超时?</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    PHP在处理超时层次有很多，不同层次，需要前端包容后端超时：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    浏览器(客户端) -&gt; 接入层 -&gt; Web服务器  -&gt; PHP  -&gt; 后端 (MySQL、Memcached)</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    就是说，接入层(Web服务器层)的超时时间必须大于PHP(PHP-FPM)中设置的超时时间，不然后面没处理完，你前面就超时关闭了，这个会很杯具。还有就是PHP的超时时间要大于PHP本身访问后端(MySQL、HTTP、Memcached)的超时时间，不然结局同前面。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>2. 超时设置原则是什么？</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    如果是希望永久不超时的代码(比如上传，或者定期跑的程序)，我仍然建议设置一个超时时间，比如12个小时这样的，主要是为了保证不会永久夯住一个php进程或者后端，导致无法给其他页面提供服务，最终引起所有机器雪崩。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    如果是要要求快速响应的程序，建议后端超时设置短一些，比如连接500ms，读1s，写1s，这样的速度，这样能够大幅度减少应用雪崩的问题，不会让服务器负载太高。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>3. 自己开发超时访问合适吗？</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    一般如果不是万不得已，建议用现有很多网络编程框架也好、基础库也好，里面一般都带有超时的实现，比如一些网络IO的lib库，尽量使用它们内置的，自己重复造轮子容易有bug，也不方便维护(不过如是是基于学习的目的就当别论了)。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    <strong>4. 其他建议</strong></p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    超时在所有应用里都是大问题，在开发应用的时候都要考虑到。我见过一些应用超时设置上百秒的，这种性能就委实差了，我举个例子：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    比如你php-fpm开了128个php-cgi进程，然后你的超时设置的是32s，那么我们如果后端服务比较差，极端情况下，那么最多每秒能响应的请求是：</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    128 / 32 = 4个 </p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    你没看错，1秒只能处理4个请求，那服务也太差了！虽然我们可以把php-cgi进程开大，但是内存占用，还有进程之间切换成本也会增加，cpu呀，内存呀都会增加，服务也会不稳定。所以，尽量设置一个合理的超时值，或者督促后端提高性能。</p> 
<p style="font-family:宋体; font-size:13px; line-height:18px; text-align:left">    本文有部分经验值，还有部分参考的内容，如果不足之处，还请指正。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c4f1e794f17902b800da6128caafd1a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">POJ 试题分类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d83e03b0ea5a64b86f177d30dc7c3d91/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java（JDBC连接数据库）[完整版封装]</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>