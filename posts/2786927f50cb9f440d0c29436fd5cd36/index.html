<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【mysql代码解读】仅通过sql查询树结构的所有子节点 手把手带你解读复杂sql - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【mysql代码解读】仅通过sql查询树结构的所有子节点 手把手带你解读复杂sql" />
<meta property="og:description" content="目录 事件起因代码解读：接下来我们来拆解解读这个“我认为比较复杂的sql”： 得到的结果字符串再转换为字符串集合列表：总结 事件起因 在看一个老项目的时候，看到的一个比较神奇的操作，我们平时查询有层级关系的内容时，比如一个部门表或者类别表的时候，常常会使用到树结构，就是在mysql的表中有一列是pid，也就是父亲id，从而形成树结构，这种情况，我们一般在服务端（后端）采用递归遍历的方式来循环访问数据库，从而得到一个树结构的列表，要想访问某个节点下的所有子节点，大致也是这种方式，从要开始找的节点开始向下找，然后递归遍历子节点继续向下找子节点
我遇到了一个什么呢？就是在找一个结点下所有子结点的时候，我看到一个野路子，它的源代码是这样的：(该代码是在mapper层的，通过注解@select的方式写的sql)
首先：要明确我们的目标，我们的目标是：找到树结构中某个id下所有的子节点
@Select(&#34;SELECT max(t3.childId)\n&#34; &#43; &#34; FROM (\n&#34; &#43; &#34; SELECT *,\n&#34; &#43; &#34; IF\n&#34; &#43; &#34; (\n&#34; &#43; &#34; find_in_set( t1.pid, @p ) &gt; 0,\n&#34; &#43; &#34; @p := concat( @p, &#39;,&#39;, id ),\n&#34; &#43; &#34; 0\n&#34; &#43; &#34; ) AS childId\n&#34; &#43; &#34; FROM\n&#34; &#43; &#34; ( SELECT id, pid FROM sys_category t ORDER BY id ) t1,\n&#34; &#43; &#34; ( SELECT @p := #{parentId}) t2\n&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2786927f50cb9f440d0c29436fd5cd36/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-24T21:12:11+08:00" />
<meta property="article:modified_time" content="2022-04-24T21:12:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【mysql代码解读】仅通过sql查询树结构的所有子节点 手把手带你解读复杂sql</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#_2" rel="nofollow">事件起因</a></li><li><a href="#_28" rel="nofollow">代码解读：</a></li><li><ul><li><a href="#sql_49" rel="nofollow">接下来我们来拆解解读这个“我认为比较复杂的sql”：</a></li></ul> 
   </li><li><a href="#_71" rel="nofollow">得到的结果字符串再转换为字符串集合列表：</a></li><li><a href="#_83" rel="nofollow">总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>事件起因</h3> 
<p>在看一个老项目的时候，看到的一个比较神奇的操作，我们平时查询有层级关系的内容时，比如一个部门表或者类别表的时候，常常会使用到树结构，就是在mysql的表中有一列是pid，也就是父亲id，从而形成树结构，这种情况，<font color="blue">我们一般在服务端（后端）采用递归遍历的方式来循环访问数据库，从而得到一个树结构的列表</font>，要想访问某个节点下的所有子节点，大致也是这种方式，从要开始找的节点开始向下找，然后递归遍历子节点继续向下找子节点</p> 
<p>我遇到了一个什么呢？就是在找一个结点下所有子结点的时候，我看到一个野路子，它的源代码是这样的：(该代码是在mapper层的，通过注解@select的方式写的sql)</p> 
<p>首先：要明确我们的目标，我们的目标是：<font color="red">找到树结构中某个id下所有的子节点</font></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"SELECT max(t3.childId)\n"</span> <span class="token operator">+</span>
            <span class="token string">"        FROM (\n"</span> <span class="token operator">+</span>
            <span class="token string">"            SELECT *,\n"</span> <span class="token operator">+</span>
            <span class="token string">"                IF\n"</span> <span class="token operator">+</span>
            <span class="token string">"                (\n"</span> <span class="token operator">+</span>
            <span class="token string">"                find_in_set( t1.pid, @p ) &gt; 0,\n"</span> <span class="token operator">+</span>
            <span class="token string">"                @p := concat( @p, ',', id ),\n"</span> <span class="token operator">+</span>
            <span class="token string">"                0\n"</span> <span class="token operator">+</span>
            <span class="token string">"                ) AS childId\n"</span> <span class="token operator">+</span>
            <span class="token string">"            FROM\n"</span> <span class="token operator">+</span>
            <span class="token string">"                ( SELECT id, pid FROM sys_category t ORDER BY id ) t1,\n"</span> <span class="token operator">+</span>
            <span class="token string">"                ( SELECT @p := #{parentId}) t2\n"</span> <span class="token operator">+</span>
            <span class="token string">"                ) t3\n"</span> <span class="token operator">+</span>
            <span class="token string">"        WHERE\n"</span> <span class="token operator">+</span>
            <span class="token string">"            childId != 0"</span><span class="token punctuation">)</span>
    <span class="token class-name">String</span> <span class="token function">selectChildByPid</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"parentId"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> parentId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>原图：<br> <img src="https://images2.imgbox.com/a1/57/sN2oirTH_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_28"></a>代码解读：</h3> 
<p>因为看这代码挺有意思，就把它拉出来分析了一下</p> 
<p>我将它单独拉到了navicat里进行分段执行了一下<br> 在代码里面是一个变量的值，我就单独给了一个指定值<br> <img src="https://images2.imgbox.com/ef/b1/gpa60Ch2_o.png" alt="在这里插入图片描述"></p> 
<p>对应的可复制sql：</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> 
	 <span class="token function">max</span><span class="token punctuation">(</span>t3<span class="token punctuation">.</span>childId<span class="token punctuation">)</span>
 <span class="token keyword">from</span> 
 <span class="token punctuation">(</span>
 <span class="token keyword">select</span> <span class="token operator">*</span><span class="token punctuation">,</span>
 <span class="token keyword">if</span><span class="token punctuation">(</span> find_in_set<span class="token punctuation">(</span>t1<span class="token punctuation">.</span>pid<span class="token punctuation">,</span> <span class="token variable">@p</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token variable">@p</span> :<span class="token operator">=</span> concat<span class="token punctuation">(</span><span class="token variable">@p</span><span class="token punctuation">,</span><span class="token string">','</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span> <span class="token punctuation">)</span> <span class="token keyword">as</span> childId
 <span class="token keyword">from</span>
	<span class="token punctuation">(</span><span class="token keyword">select</span> id<span class="token punctuation">,</span> pid <span class="token keyword">from</span> sys_category t <span class="token keyword">order</span> <span class="token keyword">by</span> id<span class="token punctuation">)</span> t1<span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token variable">@p</span> :<span class="token operator">=</span> <span class="token string">"1492039984654921729"</span><span class="token punctuation">)</span> t2
 <span class="token punctuation">)</span> t3
 <span class="token keyword">where</span> childId <span class="token operator">!=</span> <span class="token number">0</span>
</code></pre> 
<h4><a id="sql_49"></a>接下来我们来拆解解读这个“我认为比较复杂的sql”：</h4> 
<p>首先sql 要从最内部逐层像外执行，所以我们先解读最内部的sql，那就是t1集合与t2集合的产生：<br> <img src="https://images2.imgbox.com/68/61/GrXevyI1_o.png" alt="在这里插入图片描述"><br> 这个也较为简单，分别执行的话，就是下面的结果（注意这儿引进了一个变量 @p ，且t1的集合是根据id的大小从小到大排序的）：<br> <img src="https://images2.imgbox.com/99/42/e2Yt2Klk_o.png" alt="在这里插入图片描述"></p> 
<ul><li>然后再向外面扩展一层：（<font color="red">我觉得这段sql语句理解起来的重难点就主要是在这儿</font>）<br> 整个执行和解释过程我写在了图中，按照1,2,3,4,5的顺序阅读的话，那么也能对这个sql了解得更多一点吧<br> <img src="https://images2.imgbox.com/00/a8/iR4Ay6b2_o.png" alt="在这里插入图片描述"></li><li>再向外扩展一层：</li></ul> 
<p>那就是最外面的一层了，这一层没有执行其他的东西，主要是一个max函数和对数据进行了筛选，只要有子节点的的最大值(其实就是变量p子结点最多的那个值)<br> <img src="https://images2.imgbox.com/1b/44/Ph6K6t3B_o.png" alt="在这里插入图片描述"></p> 
<p>关于max函数：</p> 
<pre><code>知识点:
mysql字符串大小比较：使用MAX()查询一个字符串类型的字段时，
字符串类型大小比较是先比较首字符的ASCII码的大小，然后依次往后进行比较的。
</code></pre> 
<p>只求最后得出的这个变量p的最长的一个值 也就是目标结点id下的所有的子节点</p> 
<h3><a id="_71"></a>得到的结果字符串再转换为字符串集合列表：</h3> 
<p>另：这种的sql查询结果是一个采用"，"号隔开的要查询目标结点其下所有子id的字符串（也包含自身的id）<br> 就像这样：<br> <img src="https://images2.imgbox.com/db/7a/IcSYn5S2_o.png" alt="在这里插入图片描述"><br> 要想在后端将它转换会列表集合，那么只需要：<br> 执行这样的操作：</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> childIdList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>childId<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span>
</code></pre> 
<p>就能得到一个某个id（节点）下的所有节点id的字符串集合</p> 
<h3><a id="_83"></a>总结</h3> 
<p>这个sql主要利用了变量p在执行过程中反复给它赋值(增加新的子结点的id)，在变化的过程中就得出了所有的子节点的id 还有就是变量的使用、find_in_set和max函数的使用 难点主要在变量的执行过程中的变化和函数 当然 理解完之后（大佬回到新手村）发现其实这也不难</p> 
<p>当然这个项目中在做的过程中也发现：它所记录的id居然是使用的字符串格式进行存储（而非常规的bigint）：<br> <img src="https://images2.imgbox.com/ce/0f/3vvAS1i2_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2de299ba28f7aa68a07a1cfc23efe29f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用C语言找出0~100的所有整数当中一共出现多少个数字9</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/50180db38344362a472e234185696f7d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">＜论文阅读＞ M2BEV Multi-Camera Joint 3D Detection and Segmentation with Unified Bird’s-Eye View Represen</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>