<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AcWing 239. 奇偶游戏（边带权/扩展域并查集 离散化 xor） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AcWing 239. 奇偶游戏（边带权/扩展域并查集 离散化 xor）" />
<meta property="og:description" content="题意： 有一个长度为n的序列，给出m条限制，给出区间[l，r]和parity（中文意思是奇偶性）。
①parity == &#34;odd&#34; 表示[l,r]区间内&#39;1&#39;的个数是奇数。
②parity == &#34;even&#34; 表示[l,r]区间内&#39;1&#39;的个数是偶数。
请你输出最小的不满足条件的编号减一，如果全部满足，输出限制条件总数m。
思路： 对于本题我们可以有两种做法，第一种是“边带权”并查集，第二种是“扩展域”并查集。两种做法的运行效率差不多，不过第二种会更好写，且更容易理解，现在我们先讲边带权并查集。
一、
由题意，我们很容易了解到，这个题描述的是区间关系，而并查集只能作用于两个点的关系，因此我们要进行关系转换。
如果我们用sum数组表示序列s的前缀和，那么，在输入问题每一个小A的回答中：
(1)s[l~r]中有偶数个1，等价于sum[r]-sum[l-1]的值为偶数，即(s[r]-s[l-1])%2==0，也即sum[l-1]和sum[r]奇偶性是相同的（因为两个奇数或两个偶数相减的结果无论如何都是偶数）
(2)s[l~r]中有奇数个1，等价于sum[r]-sum[l-1]的值为奇数，即(s[r]-s[l-1])%2==1，也即sum[l-1]和sum[r]奇偶性是不同的（因为一个奇数和一个偶数相减无论如何都是奇数）
（注意，我们并没有真正求出sum数组，我们只是把sum视作变量，这时，这道题与之前的AcWing 237. 程序自动分析（第二类离散化 并查集） 一题就非常相像了，共同点：都是给定若干变量和关系，判定这些关系是否满足的问题。不同点：传递关系不一样）
二、
另外，题目中还提到，输入序列的长度n非常的大，达到了1e9，但是输入的问题数m却很少，只有1e5，而每个问题中包含2个区间的端点值，因此我们首先要用离散化将每个问题的两个整数：l-1和r缩小到等价的1~2m，即1~2e5以内的范围。
我们是用的是第二类离散化，不要求保序：
int idx; unordered_map&lt;int, int&gt; umi; int get(int x) { if(!umi.count(x)) return umi[x] = &#43;&#43;idx; return umi[x]; } 三、
为了处理多种传递关系，我们是用“边带权”的并查集解决。
定义边权数组d[]，d[x]=0表示x与父节点p[x]的奇偶性相同，d[x]=1表示x与父节点p[x]奇偶性相反。（注意是父节点，父节点也可以是根节点的）
我们在find函数中进行路径压缩的时候，联系dfs的思想，我们发现，在递归到尽头后回溯的时候对x到其所属的根节点路径上所有边权进行异或运算（xor），就可以轻松得到x和根节点的奇偶性关系。
（由于按位加法运算在模2的意义下等价于按位异或运算，因此也可以用相加模2来代替。注意，一定要加上“按位”俩字，按位即按二进制位，只有0、1参与操作，如果 任给两个整数相加模2 的结果当然可能不会等于 两个整数异或的结果。可详见此处。）
find函数：
int find(int x) { if(p[x]!=x) { //先用一个变量root记录根节点find(p[x])，那么p[x]指向的还会是它的父亲而不是根节点，这时已经递归到了最底层， //所以一步步冒泡 d[x]&#43;=d[p[x]] 就是将x一直到根节点一段段加起来，最后用完p[x]之后再将p[x]指向根节点。 int root = find(p[x]); d[x]^=d[p[x]];//联系dfs的思想，我们在回溯的时候对x到其所属的根节点路径上所有边权进行异或运算，也可写为：d[x] = (d[x] &#43; d[p[x]]) % 2; p[x] = root;//路径压缩 } return p[x]; } 四、" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1b2a5132d4b5c14fd887a129198b5da7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-17T23:25:19+08:00" />
<meta property="article:modified_time" content="2022-02-17T23:25:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AcWing 239. 奇偶游戏（边带权/扩展域并查集 离散化 xor）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/14/c1/n19hBgJj_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2d/41/TfpXm7EJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/47/55/WzxvsSbO_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_8"></a><strong>题意</strong>：</h2> 
<p>有一个长度为<code>n</code>的序列，给出<code>m</code>条限制，给出区间<code>[l，r]</code>和<code>parity</code>（中文意思是奇偶性）。</p> 
<p>①<code>parity == "odd"</code> 表示<code>[l,r]</code>区间内<code>'1'</code>的个数是奇数。<br> ②<code>parity == "even"</code> 表示<code>[l,r]</code>区间内<code>'1'</code>的个数是偶数。</p> 
<p>请你输出<strong>最小的不满足条件的编号减一</strong>，如果<strong>全部满足，输出限制条件总数<code>m</code></strong>。</p> 
<h2><a id="_20"></a><strong>思路</strong>：</h2> 
<p>对于本题我们可以有两种做法，第一种是“<strong>边带权</strong>”并查集，第二种是“<strong>扩展域</strong>”并查集。两种做法的运行效率差不多，不过第二种会更好写，且更容易理解，现在我们先讲<strong>边带权并查集</strong>。</p> 
<p><strong>一、</strong></p> 
<p>由题意，我们很容易了解到，这个题描述的是<strong>区间关系</strong>，而并查集只能作用于<strong>两个点的关系</strong>，因此我们要进行<strong>关系转换</strong>。</p> 
<p>如果我们用<code>sum</code>数组表示序列<code>s</code>的<strong>前缀和</strong>，那么，在<strong>输入问题每一个小A的回答</strong>中：</p> 
<ul><li> <p>(1)<code>s[l~r]</code>中有偶数个<code>1</code>，等价于<code>sum[r]-sum[l-1]</code>的值为偶数，即<code>(s[r]-s[l-1])%2==0</code>，也即<code>sum[l-1]</code>和<code>sum[r]</code>奇偶性是相同的（因为两个奇数或两个偶数相减的结果无论如何都是偶数）</p> </li><li> <p>(2)<code>s[l~r]</code>中有奇数个<code>1</code>，等价于<code>sum[r]-sum[l-1]</code>的值为奇数，即<code>(s[r]-s[l-1])%2==1</code>，也即<code>sum[l-1]</code>和<code>sum[r]</code>奇偶性是不同的（因为一个奇数和一个偶数相减无论如何都是奇数）</p> </li></ul> 
<p>（注意，我们<strong>并没有真正求出<code>sum</code>数组</strong>，我们只是把<code>sum</code>视作变量，这时，这道题与之前的<a href="https://blog.csdn.net/Jacob0824/article/details/122875915?spm=1001.2014.3001.5502">AcWing 237. 程序自动分析（第二类离散化 并查集）</a> 一题就非常相像了，共同点：都是给定若干变量和关系，判定这些关系是否满足的问题。不同点：传递关系不一样）</p> 
<p><img src="https://images2.imgbox.com/80/30/FMdnuzja_o.png" alt="微信图片_20220212114109.png"></p> 
<p><strong>二、</strong></p> 
<p>另外，题目中还提到，输入序列的<strong>长度</strong><code>n</code><strong>非常的大</strong>，达到了<code>1e9</code>，但是<strong>输入的问题数</strong><code>m</code>却<strong>很少</strong>，只有<code>1e5</code>，而每个问题中包含<code>2</code>个区间的端点值，因此我们首先要用<strong>离散化</strong>将每个问题的两个整数：<code>l-1</code>和<code>r</code>缩小到等价的<code>1~2m</code>，即<code>1~2e5</code>以内的范围。</p> 
<p>我们是用的是<strong>第二类离散化，不要求保序</strong>：</p> 
<pre><code>int idx;
unordered_map&lt;int, int&gt; umi;

int get(int x)
{
        if(!umi.count(x)) return umi[x] = ++idx;
        return umi[x];
}
</code></pre> 
<p><strong>三、</strong></p> 
<p>为了处理<strong>多种传递关系</strong>，我们是用“<strong>边带权</strong>”的并查集解决。</p> 
<p>定义<strong>边权数组<code>d[]</code></strong>，<code>d[x]=0</code>表示<code>x</code>与<strong>父节点</strong><code>p[x]</code>的奇偶性相同，<code>d[x]=1</code>表示<code>x</code>与<strong>父节点</strong><code>p[x]</code>奇偶性相反。（注意是父节点，父节点也可以是根节点的）</p> 
<p>我们在<code>find</code>函数中进行路径压缩的时候，联系<code>dfs</code>的思想，我们发现，<strong>在递归到尽头后回溯的时候对<code>x</code>到其所属的根节点路径上所有边权进行异或运算（<code>xor</code>），就可以轻松得到<code>x</code>和根节点的奇偶性关系。</strong></p> 
<p>（由于<strong>按位加法运算在模2的意义下等价于按位异或运算</strong>，因此也可以用相加模2来代替。<strong>注意</strong>，一定要加上“按位”俩字，按位即<strong>按二进制位</strong>，只有<strong>0、1</strong>参与操作，如果 任给两个整数<strong>相加模2</strong> 的结果当然可能不会等于 两个整数<strong>异或</strong>的结果。可详见<a href="https://www.zhihu.com/question/445097227" rel="nofollow">此处</a>。）</p> 
<p><code>find</code>函数：</p> 
<pre><code>int find(int x)
{
        if(p[x]!=x)
        {
//先用一个变量root记录根节点find(p[x])，那么p[x]指向的还会是它的父亲而不是根节点，这时已经递归到了最底层，
//所以一步步冒泡 d[x]+=d[p[x]] 就是将x一直到根节点一段段加起来，最后用完p[x]之后再将p[x]指向根节点。

                int root = find(p[x]);
                d[x]^=d[p[x]];//联系dfs的思想，我们在回溯的时候对x到其所属的根节点路径上所有边权进行异或运算，也可写为：d[x] = (d[x] + d[p[x]]) % 2;
                p[x] = root;//路径压缩
        }
        return p[x];
}
</code></pre> 
<p><strong>四、</strong></p> 
<p>对于每一个问题，设在离散化之后<code>l-1</code>、<code>r</code>的值分别是<code>a</code>、<code>b</code>，设<code>ans</code>表示对于当前问题小A给出的的答案。</p> 
<p>（当<code>ans</code>等于<code>0</code>，代表当前区间<code>[l, r]</code>内有偶数个<code>'1'</code>，且<code>a</code>、<code>b</code>奇偶性相同。如等于<code>1</code>，代表当前区间内有奇数个<code>'1'</code>，且<code>a</code>、<code>b</code>奇偶性不同）。</p> 
<p><strong>先判断<code>a</code>和<code>b</code>是否属于同一集合</strong>（是否已知奇偶关系），当查询函数<code>find(a)</code>、<code>find(b)</code>都执行完成后，<code>d[a]^d[b]</code>即为<code>a</code>和<code>b</code>的奇偶关系。</p> 
<ul><li> <p>①如果属于同一集合，如果我们发现<code>d[a]^d[b]!=ans</code>，我们求得的<code>a</code>、<code>b</code>之间的关系和之前输入的小A所判断<code>a</code>、<code>b</code>间的关系<code>ans</code>相矛盾，则可以确定小A在撒谎。（具体见主代码）</p> </li><li> <p>②如果不属于同一集合，则合并两个集合，应该进行的操作：</p> </li><li> 
  <ul><li>通过<code>find</code>得到两个集合<code>a</code>、<code>b</code>的根节点，设为<code>pa</code>、<code>pb</code>。</li></ul> </li><li> 
  <ul><li>若要合并，则先使<code>pa</code>为<code>pb</code>的儿子。</li></ul> </li><li> 
  <ul><li>接下来，我们知道<code>d[a]</code>与<code>d[b]</code>分别表示路径<code>a~pa</code>和<code>b~pb</code>之间所有边权的“<code>xor</code>和”，<code>pa~pb</code>之间的边权<code>d[pa]</code>是我们亟待求解的值。</li></ul> </li><li> 
  <ul><li>显然路径<code>a~b</code>由<code>a~pa</code>、<code>pa~pb</code>、<code>pb~b</code>三部分组成（在纸上画图就很明了了），因此<code>a</code>和<code>b</code>的奇偶性<code>ans</code>（这里的<code>ans</code>是小A判断的值）=<code>d[a]^d[pa]^d[b]</code>，进行一下数学推导，这一步用到了异或运算的性质：<code>d[pa]=d[a]^d[b]^ans</code>（新连接的边权）。</li></ul> </li></ul> 
<p><strong>异或运算的性质</strong>：<br> <img src="https://images2.imgbox.com/bd/21/zT6b6NsT_o.png" alt="在这里插入图片描述"></p> 
<p>合并两集合要进行的操作：</p> 
<pre><code>if(pa!=pb) _union(pa, pb), d[pa] = d[a]^d[b]^ans;
</code></pre> 
<h2><a id="_115"></a><strong>时间复杂度</strong>：</h2> 
<p>应该是<code>mlogm</code></p> 
<h2><a id="_122"></a><strong>代码</strong>：</h2> 
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 2*5000+10;
int p[N], d[N];
int n, m;

struct Query
{
        int l, r;
        int parity;
}query[N];

int idx;
unordered_map&lt;int, int&gt; umi;
int get(int x)
{
        if(!umi.count(x)) return umi[x] = ++idx;
        return umi[x];
}

void init(int n) { for(int i=1;i&lt;=n;++i) p[i] = i; }

int find(int x)
{
        if(p[x]!=x)
        {
//先用一个变量root记录根节点find(p[x])，那么p[x]指向的还会是它的父亲而不是根节点，这时已经递归到了最底层，
//所以一步步冒泡 d[x]+=d[p[x]] 就是将x一直到根节点一段段加起来，最后用完p[x]之后再将p[x]指向根节点。

                int root = find(p[x]);
                d[x]^=d[p[x]];//联系dfs的思想，我们在回溯的时候对x到其所属的根节点路径上所有边权进行异或运算，也可写为：d[x] = (d[x] + d[p[x]]) % 2;
                p[x] = root;//路径压缩
        }
        return p[x];
}

void _union(int pa, int pb) { p[pa] = pb; }

int main()
{
        cin&gt;&gt;n&gt;&gt;m;
        idx = 0;
        for(int i=1;i&lt;=m;++i)
        {
                int l, r; string par;
                cin&gt;&gt;l&gt;&gt;r&gt;&gt;par;
                query[i] = {get(l-1), get(r), par=="odd" ? 1 : 0};//注意啊，我们想要离散化的第一个值是l-1而不是l，联系前缀和的思想就行
        }
        init(idx);
        int res = m;
        for(int i=1;i&lt;=m;++i)
        {
                int a = query[i].l, b = query[i].r, ans = query[i].parity;
                int pa = find(a), pb = find(b);
                if(pa!=pb) _union(pa, pb), d[pa] = d[a]^d[b]^ans;
                else
                {
                        if(d[a]^d[b]!=ans)
                        {
                                res = i-1;
                                break;
                        }
                }
        }
        cout&lt;&lt;res&lt;&lt;endl;

        return 0;
}
</code></pre> 
<h2><a id="_197"></a>扩展域并查集做法</h2> 
<p>上面讲的“边带权”并查集主要思想是<strong>存储相对关系</strong>，即<strong>当前节点和根</strong>的关系，由于<strong>关系具有传递性</strong>，我们使用 当前节点和根的关系 就可以知道 集合内<strong>任意两个元素</strong>的关系。</p> 
<p>接下来，<strong>扩展域并查集</strong>做法则换了一种全新的思考方式。</p> 
<p><img src="https://images2.imgbox.com/57/ee/Kx3xApH6_o.png" alt="微信图片_20220212170057.png"></p> 
<p>可以看出，扩展域并查集解决此题相对于前两种更加好理解，无需维护d[]数组，也更好写一点，扩展域并查集<strong>对于条件来划分集合</strong>，引申出x和x+idx点，此处<strong>x点表示为x是奇数，x+idx表示x为偶数</strong>。</p> 
<p>扩展域并查集适合<strong>种类不是很多</strong>的情况，如果太多显然会导致空间爆炸。典型的以空间换时间思想。</p> 
<h2><a id="_212"></a>代码：</h2> 
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 2*2*5000+10;
int p[N];
int n, m;

struct Query
{
        int l, r;
        int parity;
}query[N];

int idx;
unordered_map&lt;int, int&gt; umi;
int get(int x)
{
        if(!umi.count(x)) return umi[x] = ++idx;
        return umi[x];
}

void init(int n) { for(int i=1;i&lt;=n;++i) p[i] = i; }

int find(int x)
{
        if(p[x]!=x) p[x] = find(p[x]);
        return p[x];
}

void _union(int pa, int pb) { p[pa] = pb; }

int main()
{
        cin&gt;&gt;n&gt;&gt;m;
        idx = 0;
        for(int i=1;i&lt;=m;++i)
        {
                int l, r; string par;
                cin&gt;&gt;l&gt;&gt;r&gt;&gt;par;
                query[i] = {get(l-1), get(r), par=="odd" ? 1 : 0};//注意啊，我们想要离散化的第一个值是l-1而不是l，联系前缀和的思想就行
        }
        init(2*idx);
        int res = m;
        for(int i=1;i&lt;=m;++i)
        {
                int a = query[i].l, b = query[i].r, ans = query[i].parity;
                int a_odd = a, a_even = a + idx, b_odd = b, b_even = b + idx;

                if(ans == 0)//回答奇偶性相同
                {
                    if(find(a_odd) == find(b_even))//与已知情况矛盾
                    {
                        res = i - 1;
                        break;
                    }
                    _union(find(a_odd), find(b_odd)), _union(find(a_even), find(b_even));//合并
                }

                else
                {
                    if(find(a_odd) == find(b_odd))//与已知情况矛盾
                    {
                        res = i - 1;
                        break;
                    }
                    _union(find(a_odd), find(b_even)), _union(find(a_even), find(b_odd));//合并
                }
        }
        cout&lt;&lt;res&lt;&lt;endl;

        return 0;
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e367e4467a8f43a7a55cb4ba523e300f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LabVIEW崩溃后如何排查故障</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2327fc4a54c7bb52c107393c3d58a1fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python code自留地（1）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>