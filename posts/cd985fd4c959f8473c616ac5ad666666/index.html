<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>7、Linux驱动开发：设备-自动创建设备节点 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="7、Linux驱动开发：设备-自动创建设备节点" />
<meta property="og:description" content="目录 🍅点击这里查看所有博文
随着自己工作的进行，接触到的技术栈也越来越多。给我一个很直观的感受就是，某一项技术/经验在刚开始接触的时候都记得很清楚。往往过了几个月都会忘记的差不多了，只有经常会用到的东西才有可能真正记下来。存在很多在特殊情况下有一点用处的技巧，用的不多的技巧可能一个星期就忘了。
想了很久想通过一些手段把这些事情记录下来。也尝试过在书上记笔记，这也只是一时的，书不在手边的时候那些笔记就和没记一样，不是很方便。
很多时候我们遇到了问题，一般情况下都是选择在搜索引擎检索相关内容，这样来的也更快一点，除非真的找不到才会去选择翻书。后来就想到了写博客，博客作为自己的一个笔记平台倒是挺合适的。随时可以查阅，不用随身携带。
同时由于写博客是对外的，既然是对外的就不能随便写，任何人都可以看到。经验对于我来说那就只是经验而已，公布出来说不一定我的一些经验可以帮助到其他的人。遇到和我相同问题时可以少走一些弯路。
既然决定了要写博客，那就只能认真去写。不管写的好不好，尽力就行。千里之行始于足下，一步一个脚印，慢慢来 ，写的多了慢慢也会变好的。权当是记录自己的成长的一个过程，等到以后再往回看时，就会发现自己以前原来这么菜😂。
本系列博客所述资料均来自互联网资料，并不是本人原创（只有博客是自己写的）。出于热心，本人将自己的所学笔记整理并推出相对应的使用教程，方面其他人学习。为国内的物联网事业发展尽自己的一份绵薄之力，没有为自己谋取私利的想法。若出现侵权现象，请告知本人，本人会立即停止更新，并删除相应的文章和代码。
前言 在前面两小节中，我们学习到了设备注册。可以将一个设备驱动注册到内核中。设备注册完成后，还需要通过mknod指令在用户空间中手动创建该驱动对应的设备节点。
root@ubuntu:# mknod /dev/hello_test0 c 237 0 该命令在执行是不会检查参数的合法性。也不会检查设备驱动是否存在。如果系统中所有的驱动都通过该方法创建设备节点，就会出现一个问题。当设备未接入时，就可能会出现很多的设备节点。
实际上Linux内核为我们提供了一组函数，可以在模块加载的时候自动在/dev目录下创建相应设备节点，并在卸载模块时删除该节点，当然前提条件是用户空间移植了udev。
udev udev是一个工作在用户空间的工具，它能根据系统中硬件设备的状态动态的更新设备文件，包括设备文件的创建，删除，权限等。这些文件通常都定义在/dev 目录下，但也可以在配置文件中指定。
当插入新设备—&gt;加入驱动模块—&gt;在sysfs上注册新的数据后，udev会自动创建新的设备节点。udev运行在用户模式中，而并非内核中。
接口 内核中定义了struct class结构体，顾名思义，一个struct class结构体类型变量对应一个类。代码中出现的class指的是 设备类（device classes），是对于设备的高级抽象。但 实际上class也是一个结构体，只不过class结构体在声明时是按照类的思想来组织其成员的。
/** * struct class - device classes * @name:	Name of the class. * @owner:	The module owner. * @class_attrs: Default attributes of this class. * @dev_groups:	Default attributes of the devices that belong to the class. * @dev_kobj:	The kobject that represents this class and links it into the hierarchy." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cd985fd4c959f8473c616ac5ad666666/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-18T15:48:34+08:00" />
<meta property="article:modified_time" content="2023-10-18T15:48:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">7、Linux驱动开发：设备-自动创建设备节点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_1"></a>目录</h2> 
<p><a href="https://blog.csdn.net/weixin_44570083/article/details/104285283">🍅点击这里查看所有博文</a></p> 
<p>  随着自己工作的进行，接触到的技术栈也越来越多。给我一个很直观的感受就是，某一项技术/经验在刚开始接触的时候都记得很清楚。往往过了几个月都会忘记的差不多了，只有经常会用到的东西才有可能真正记下来。存在很多在特殊情况下有一点用处的技巧，用的不多的技巧可能一个星期就忘了。</p> 
<p>  想了很久想通过一些手段把这些事情记录下来。也尝试过在书上记笔记，这也只是一时的，书不在手边的时候那些笔记就和没记一样，不是很方便。</p> 
<p>  很多时候我们遇到了问题，一般情况下都是选择在搜索引擎检索相关内容，这样来的也更快一点，除非真的找不到才会去选择翻书。后来就想到了写博客，博客作为自己的一个笔记平台倒是挺合适的。随时可以查阅，不用随身携带。</p> 
<p>  同时由于写博客是对外的，既然是对外的就不能随便写，任何人都可以看到。经验对于我来说那就只是经验而已，公布出来说不一定我的一些经验可以帮助到其他的人。遇到和我相同问题时可以少走一些弯路。</p> 
<p>  既然决定了要写博客，那就只能认真去写。不管写的好不好，尽力就行。<code>千里之行始于足下，一步一个脚印，慢慢来</code> ，写的多了慢慢也会变好的。权当是记录自己的成长的一个过程，等到以后再往回看时，就会发现自己以前原来这么菜😂。</p> 
<p>  本系列博客所述资料<code>均来自互联网资料</code>，并不是本人原创（只有博客是自己写的）。出于热心，本人将自己的所学笔记整理并推出相对应的使用教程，方面其他人学习。为国内的物联网事业发展尽自己的一份绵薄之力，<code>没有为自己谋取私利的想法</code>。若出现侵权现象，请告知本人，本人会立即停止更新，并删除相应的文章和代码。</p> 
<h2><a id="_17"></a>前言</h2> 
<p>  在前面两小节中，我们学习到了设备注册。可以将一个设备驱动注册到内核中。设备注册完成后，还需要通过mknod指令在用户空间中手动创建该驱动对应的设备节点。</p> 
<pre><code class="prism language-shell">root@ubuntu:<span class="token comment"># mknod /dev/hello_test0 c 237 0</span>
</code></pre> 
<p>  该命令在执行是不会检查参数的合法性。也不会检查设备驱动是否存在。如果系统中所有的驱动都通过该方法创建设备节点，就会出现一个问题。当设备未接入时，就可能会出现很多的设备节点。</p> 
<p>  实际上Linux内核为我们提供了一组函数，可以在模块加载的时候自动在<code>/dev</code>目录下创建相应设备节点，并在卸载模块时删除该节点，当然前提条件是用户空间移植了<strong>udev</strong>。</p> 
<h2><a id="udev_29"></a>udev</h2> 
<p>  <strong>udev</strong>是一个工作在用户空间的工具，它能根据系统中硬件设备的状态动态的更新设备文件，包括设备文件的创建，删除，权限等。这些文件通常都定义在<code>/dev</code> 目录下，但也可以在配置文件中指定。</p> 
<p>  当插入新设备—&gt;加入驱动模块—&gt;在sysfs上注册新的数据后，udev会自动创建新的设备节点。udev运行在用户模式中，而并非内核中。</p> 
<p><img src="https://images2.imgbox.com/f4/4d/01mdkyww_o.png" alt="输入图片说明"></p> 
<h2><a id="_38"></a>接口</h2> 
<p>  内核中定义了<strong>struct class</strong>结构体，顾名思义，一个<strong>struct class</strong>结构体类型变量对应一个类。代码中出现的<strong>class</strong>指的是 设备类（<strong>device classes</strong>），是对于设备的高级抽象。但 实际上<strong>class</strong>也是一个结构体，只不过<strong>class</strong>结构体在声明时是按照类的思想来组织其成员的。</p> 
<pre><code class="prism language-c"><span class="token comment">/**
 * struct class - device classes
 * @name:	Name of the class.
 * @owner:	The module owner.
 * @class_attrs: Default attributes of this class.
 * @dev_groups:	Default attributes of the devices that belong to the class.
 * @dev_kobj:	The kobject that represents this class and links it into the hierarchy.
 * @dev_uevent:	Called when a device is added, removed from this class, or a
 *		few other things that generate uevents to add the environment
 *		variables.
 * @devnode:	Callback to provide the devtmpfs.
 * @class_release: Called to release this class.
 * @dev_release: Called to release the device.
 * @suspend:	Used to put the device to sleep mode, usually to a low power
 *		state.
 * @resume:	Used to bring the device from the sleep mode.
 * @ns_type:	Callbacks so sysfs can detemine namespaces.
 * @namespace:	Namespace of the device belongs to this class.
 * @pm:		The default device power management operations of this class.
 * @p:		The private data of the driver core, no one other than the
 *		driver core can touch this.
 *
 * A class is a higher-level view of a device that abstracts out low-level
 * implementation details. Drivers may see a SCSI disk or an ATA disk, but,
 * at the class level, they are all simply disks. Classes allow user space
 * to work with devices based on what they do, rather than how they are
 * connected or how they work.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">char</span>		<span class="token operator">*</span>name<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">module</span>		<span class="token operator">*</span>owner<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">class_attribute</span>		<span class="token operator">*</span>class_attrs<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span>	<span class="token operator">*</span><span class="token operator">*</span>dev_groups<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">kobject</span>			<span class="token operator">*</span>dev_kobj<span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>dev_uevent<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kobj_uevent_env</span> <span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>devnode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token class-name">umode_t</span> <span class="token operator">*</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>class_release<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dev_release<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>suspend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token class-name">pm_message_t</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>resume<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">kobj_ns_type_operations</span> <span class="token operator">*</span>ns_type<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>namespace<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dev_pm_ops</span> <span class="token operator">*</span>pm<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">subsys_private</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>  内核同时提供了<strong>class_create</strong>宏。用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进Linux内核系统中。此函数的执行效果就是在**/sys/class/**目录下创建一个新的文件夹，此文件夹的名字为此函数的第二个输入参数。</p> 
<p>  <strong>class_create</strong> 一共有两个参数，参数 <strong>owner</strong> 一般为 <strong>THIS_MODULE</strong>，参数 <strong>name</strong> 是类名字。返回值是个指向结构体 <strong>class</strong> 的指针，也就是创建的类。</p> 
<pre><code class="prism language-c"><span class="token comment">/* This is a #define to keep the compiler from merging different
 * instances of the __key variable */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">class_create</span><span class="token expression"><span class="token punctuation">(</span>owner<span class="token punctuation">,</span> name<span class="token punctuation">)</span>		</span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>						</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">lock_class_key</span> __key<span class="token punctuation">;</span>	</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token function">__class_create</span><span class="token punctuation">(</span>owner<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>__key<span class="token punctuation">)</span><span class="token punctuation">;</span>	</span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/**
 * class_create - create a struct class structure
 * @owner: pointer to the module that is to "own" this struct class
 * @name: pointer to a string for the name of this class.
 * @key: the lock_class_key for this class; used by mutex lock debugging
 *
 * This is used to create a struct class pointer that can then be used
 * in calls to device_create().
 *
 * Returns &amp;struct class pointer on success, or ERR_PTR() on error.
 *
 * Note, the pointer created here is to be destroyed when finished by
 * making a call to class_destroy().
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span><span class="token function">__class_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
			     <span class="token keyword">struct</span> <span class="token class-name">lock_class_key</span> <span class="token operator">*</span>key<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>cls<span class="token punctuation">;</span>
	<span class="token keyword">int</span> retval<span class="token punctuation">;</span>
	cls <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>cls<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cls<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		retval <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
		<span class="token keyword">goto</span> error<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cls<span class="token operator">-&gt;</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
	cls<span class="token operator">-&gt;</span>owner <span class="token operator">=</span> owner<span class="token punctuation">;</span>
	cls<span class="token operator">-&gt;</span>class_release <span class="token operator">=</span> class_create_release<span class="token punctuation">;</span>
	retval <span class="token operator">=</span> <span class="token function">__class_register</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> error<span class="token punctuation">;</span>
	<span class="token keyword">return</span> cls<span class="token punctuation">;</span>
error<span class="token operator">:</span>
	<span class="token function">kfree</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  函数<strong>device_create</strong>用于动态创建逻辑设备，对新的逻辑设备进行相应初始化，然后将此逻辑设备加入到Linux内核系统的设备驱动程序模型中。</p> 
<p>  <strong>device_create</strong>是个可变参数函数，参数 <strong>class</strong> 就是设备要创建在哪个类下面。参数 <strong>parent</strong> 是父设备，一般为 NULL，也就是没有父设备。参数 <strong>devt</strong> 是设备号。参数 <strong>drvdata</strong> 是设备可能会使用的一些数据，一般为 NULL。参数 <strong>fmt</strong> 是设备名字，如果设置 fmt=xxx 的话，就会生成/dev/xxx这个设备文件。返回值就是创建好的设备。</p> 
<pre><code class="prism language-c"><span class="token comment">/**
 * device_create - creates a device and registers it with sysfs
 * @class: pointer to the struct class that this device should be registered to
 * @parent: pointer to the parent struct device of this new device, if any
 * @devt: the dev_t for the char device to be added
 * @drvdata: the data to be added to the device for callbacks
 * @fmt: string for the device's name
 *
 * This function can be used by char device classes.  A struct device
 * will be created in sysfs, registered to the specified class.
 *
 * A "dev" file will be created, showing the dev_t for the device, if
 * the dev_t is not 0,0.
 * If a pointer to a parent struct device is passed in, the newly created
 * struct device will be a child of that device in sysfs.
 * The pointer to the struct device will be returned from the call.
 * Any further sysfs files that might be required can be created using this
 * pointer.
 *
 * Returns &amp;struct device pointer on success, or ERR_PTR() on error.
 *
 * Note: the struct class passed to this function must have previously
 * been created with a call to class_create().
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span><span class="token function">device_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>parent<span class="token punctuation">,</span>
			     <span class="token class-name">dev_t</span> devt<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>drvdata<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	va_list vargs<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">;</span>
	<span class="token function">va_start</span><span class="token punctuation">(</span>vargs<span class="token punctuation">,</span> fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
	dev <span class="token operator">=</span> <span class="token function">device_create_vargs</span><span class="token punctuation">(</span>class<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> devt<span class="token punctuation">,</span> drvdata<span class="token punctuation">,</span> fmt<span class="token punctuation">,</span> vargs<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">va_end</span><span class="token punctuation">(</span>vargs<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> dev<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  该函数会自动地在<code>/sys/devices/virtual</code>目录下创建新的逻辑设备目录。并将其软连接到<code>/sys/class/</code>目录中对应的类下。同时还会在<code>/dev</code>目录下创建与逻辑类对应地设备文件。</p> 
<pre><code class="prism language-shell">root@ubuntu:<span class="token comment"># ll /sys/class/hellocls/</span>
total <span class="token number">0</span>
lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">0</span> Sep <span class="token number">17</span> 06:11 hellodev -<span class="token operator">&gt;</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/devices/virtual/hellocls/hellodev

root@ubuntu:<span class="token comment"># ll /dev/hellodev </span>
crw------- <span class="token number">1</span> root root <span class="token number">237</span>, <span class="token number">0</span> Sep <span class="token number">17</span> 06:11 /dev/hellodev
</code></pre> 
<h2><a id="_193"></a>代码实现</h2> 
<p>  示例代码实现也比较简单，完成设备的注册后。<strong>class_create</strong>创建一个<code>hellocls</code>的类，该函数最终会在<code>/sys/class</code>目录中创建一个名为<code>hellocls</code>的文件夹。<strong>device_create</strong>函数将设备驱动存放到<code>hellocls</code>类中，并创建对应的设备文件。</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> result<span class="token punctuation">;</span>	
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"hello_init \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	result <span class="token operator">=</span> <span class="token function">register_chrdev</span><span class="token punctuation">(</span> major<span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hello_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"register_chrdev fail \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cls <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"hellocls"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"class_create() failed for cls\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		result <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">goto</span> out_err_1<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	devno <span class="token operator">=</span> <span class="token function">MKDEV</span><span class="token punctuation">(</span>major<span class="token punctuation">,</span> minor<span class="token punctuation">)</span><span class="token punctuation">;</span>	
	class_dev <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> devno<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"hellodev"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>class_dev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		result <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>class_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">goto</span> out_err_2<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
out_err_2<span class="token operator">:</span>
	<span class="token function">class_destroy</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>
out_err_1<span class="token operator">:</span>
	<span class="token function">unregister_chrdev</span><span class="token punctuation">(</span>major<span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> 	result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"hello_exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">device_destroy</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> devno<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">class_destroy</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">unregister_chrdev</span><span class="token punctuation">(</span>major<span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_239"></a>实验结果</h2> 
<p>  测试程序如下，打开<code>/dev/hellodev</code>字符设备。紧接着关闭掉。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span>
	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/hellodev"</span><span class="token punctuation">,</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open fail \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"close ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  加载模块，用户空间编译测试程序。运行测试程序对驱动进行打开和关闭的操作。日志可以看到驱动中的<strong>hello_open</strong>，<strong>hello_release</strong>都被正常调用。</p> 
<pre><code class="prism language-shell">root@ubuntu:<span class="token comment"># insmod ./hello.ko</span>
root@ubuntu:<span class="token comment"># gcc ./test.c </span>
root@ubuntu:<span class="token comment"># ./a.out </span>
<span class="token function">open</span> ok 
close ok 
root@ubuntu:<span class="token comment"># dmesg</span>
<span class="token punctuation">[</span><span class="token number">170236.680298</span><span class="token punctuation">]</span> hello_exit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">170280.990839</span><span class="token punctuation">]</span> hello_init 
<span class="token punctuation">[</span><span class="token number">222202.880295</span><span class="token punctuation">]</span> hello_open<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">222202.880418</span><span class="token punctuation">]</span> hello_release<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>  进入到系统的类目录，查看dev文件和uevent文件。其中记录的就是驱动模块中注册的设备号。</p> 
<pre><code class="prism language-shell">root@ubuntu:<span class="token comment"># cd /sys/class//hellocls/hellodev</span>
root@ubuntu:<span class="token comment"># $ cat dev</span>
<span class="token number">237</span>:0
root@ubuntu:<span class="token comment"># cat uevent </span>
<span class="token assign-left variable">MAJOR</span><span class="token operator">=</span><span class="token number">237</span>
<span class="token assign-left variable">MINOR</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">DEVNAME</span><span class="token operator">=</span>hellodev
root@ubuntu:<span class="token comment"># ll /dev/hellodev </span>
crw------- <span class="token number">1</span> root root <span class="token number">237</span>, <span class="token number">0</span> Sep <span class="token number">17</span> 06:11 /dev/hellodev
</code></pre> 
<p>  那么本篇博客就到此结束了，这里只是记录了一些我个人的学习笔记，其中存在大量我自己的理解。文中所述不一定是完全正确的，可能有的地方我自己也理解错了。如果有些错的地方，欢迎大家批评指正。如有问题直接在对应的博客评论区指出即可，不需要私聊我。我们交流的内容留下来也有助于其他人查看，说不一定也有其他人遇到了同样的问题呢😂。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ff1f8b19e1e1b0fd47f25fb029f9dfb0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32cubeMx系列小白学习教程（三）——外部中断</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/94289864a923497a463a8840cd7c71d6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">web 端 vite 配置 px 转 rem</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>