<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mysql系列 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mysql系列" />
<meta property="og:description" content="1 MySQL设计表的三大范式是什么？ MySQL设计表时遵循的三大范式是关系型数据库设计理论中的基本规范，它们确保了数据在数据库中的存储结构合理、无冗余且一致。以下是三大范式的详细介绍：
第一范式（1NF：First Normal Form） 要求：
每个属性（列）都必须是不可再分的原子值。表中所有字段的值都是基本的、不可分解的数据项。 这意味着在一个关系型表格中，每一列的单元格都应该只包含一个值，而不能是多个值的集合或复合值。例如，地址不应该作为一个字段来存储，因为它可以被分解为街道、城市、省份等独立的部分。
第二范式（2NF：Second Normal Form） 要求：
数据表必须满足第一范式。表中的非主键字段完全依赖于整个候选键（通常是主键），而不是部分依赖。 换句话说，在第二范式中，不允许存在非主键列对部分主键的依赖。如果存在这种情况，需要将这部分非主键列单独拆分为一个新的表，并通过外键与原表关联。这样可以消除数据冗余并确保每个表都有明确的主题。
第三范式（3NF：Third Normal Form） 要求：
数据表必须满足第二范式。所有非主键字段之间不存在传递依赖关系，即没有任何一个非主键字段依赖于另一个非主键字段。 第三范式进一步消除了冗余数据，它规定任何非主键字段的信息都只能直接依赖于主键，不能通过其他非主键字段间接依赖于主键。如果存在这种传递依赖，则需要继续拆分表以达到3NF的要求。
总结来说，三大范式旨在减少数据冗余、提高数据一致性以及简化数据修改操作的复杂性。在实际数据库设计中，根据业务需求和性能考量，有时会适度地违反某些范式，如引入适当的冗余以提升查询效率，这需要设计者权衡规范化与性能之间的平衡。
2 MySQL的selete * 和seltet 全字段的区别？ MySQL中SELECT *和SELECT 全部字段名在查询结果上没有区别，它们都会返回表中的所有列数据。但二者在性能、可读性以及数据库设计原则上有以下几点差异：
性能影响：
SELECT *：MySQL服务器需要解析查询语句时确定*代表的所有字段，这可能会比直接指定字段名稍微多花一点时间。此外，如果表中有大量字段，而应用程序只需要其中一部分，那么使用SELECT *会增加网络传输的开销，因为返回了不必要的字段信息。SELECT 全部字段名：当明确列出所有字段名时，MySQL可以直接处理这些字段而无需额外解析步骤。尤其在大表中，只选择必要的字段可以减少I/O操作和网络传输量。 索引优化：
使用覆盖索引（Covering Index）的情况下，如果仅查询索引包含的字段，MySQL有可能直接从索引中获取所需数据，而不必访问实际的数据页，从而提高查询效率。但如果执行SELECT *，即使部分字段可以通过索引查找，其他非索引字段仍需回表查询，导致无法充分利用索引优化。 可读性和维护性：
SELECT *降低了代码的可读性，因为阅读者不能一眼看出具体查询哪些字段，增加了未来维护成本。明确写出每个字段名则提高了SQL语句的可读性，并且有助于保持代码整洁和明确。 表结构变更的影响：
当表结构发生变化（如添加或删除字段）时，使用SELECT *的代码可能不会反映出这种变化，导致预期外的行为。而在代码中明确列出字段，则可以避免因表结构变动带来的问题。 综上所述，在编写SQL查询时，除非确实需要表的所有字段，一般推荐明确列出所要查询的字段名称以提升性能和维护性。
3 MySQL的seletet *除了是全字段扫描外为什么慢？ MySQL的SELECT *语句之所以在某些情况下执行较慢，主要是因为以下几个原因：
数据传输量大：
当查询表中的所有字段时，数据库需要将所有列的数据从磁盘读取到内存，并通过网络发送给客户端。如果表结构中有大量字段或者字段值占用空间较大（如文本、二进制数据等），这会显著增加网络传输和内存使用，特别是在带宽有限或内存资源紧张的情况下。 索引利用率低：
如果查询中没有明确指定索引字段，即使表中有适合当前查询的索引，也无法利用索引来加速查询。由于索引通常只包含部分字段（尤其是主键和唯一索引），因此全字段扫描不会直接利用索引提高查询速度。 I/O操作成本高：
在大数据量的表中，全字段扫描意味着对表进行全表扫描，可能导致大量的磁盘I/O操作，尤其当数据无法全部加载到内存时，频繁的磁盘访问会使查询响应时间大大增加。 无谓的计算开销：
对于存储过程、触发器或者其他后续处理来说，可能只需要其中一部分字段，但SELECT *却返回了所有字段，导致不必要的计算和处理。 未优化的查询计划：
数据库优化器可能无法提供一个最优的查询计划，因为它不能针对未知的具体列做出最佳选择。 缓存效率较低：
查询结果缓存通常基于SQL语句和所涉及的具体列来实现。SELECT *与具体列出列名的查询相比，在缓存匹配上的效率可能会降低，因为相同的表查询不同列集可能会产生不同的缓存项。 为了提高查询性能，应尽量避免在生产环境中使用SELECT *，除非确实需要获取所有字段信息。推荐的做法是根据实际需求指定要查询的列，同时结合适当的索引策略以减少不必要的I/O和CPU开销
4 MySQL如何做优化？ MySQL数据库优化涉及多个层面，包括但不限于以下几点：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7b9e27b53ab38f79a105c0c643bc504c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-25T21:32:54+08:00" />
<meta property="article:modified_time" content="2024-01-25T21:32:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mysql系列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1 MySQL设计表的三大范式是什么？</h4> 
<p>MySQL设计表时遵循的三大范式是关系型数据库设计理论中的基本规范，它们确保了数据在数据库中的存储结构合理、无冗余且一致。以下是三大范式的详细介绍：</p> 
<h4>第一范式（1NF：First Normal Form）</h4> 
<p><strong>要求</strong>：</p> 
<ul><li>每个属性（列）都必须是不可再分的原子值。</li><li>表中所有字段的值都是基本的、不可分解的数据项。</li></ul> 
<p>这意味着在一个关系型表格中，每一列的单元格都应该只包含一个值，而不能是多个值的集合或复合值。例如，地址不应该作为一个字段来存储，因为它可以被分解为街道、城市、省份等独立的部分。</p> 
<h4>第二范式（2NF：Second Normal Form）</h4> 
<p><strong>要求</strong>：</p> 
<ul><li>数据表必须满足第一范式。</li><li>表中的非主键字段完全依赖于整个候选键（通常是主键），而不是部分依赖。</li></ul> 
<p>换句话说，在第二范式中，不允许存在非主键列对部分主键的依赖。如果存在这种情况，需要将这部分非主键列单独拆分为一个新的表，并通过外键与原表关联。这样可以消除数据冗余并确保每个表都有明确的主题。</p> 
<h4>第三范式（3NF：Third Normal Form）</h4> 
<p><strong>要求</strong>：</p> 
<ul><li>数据表必须满足第二范式。</li><li>所有非主键字段之间不存在传递依赖关系，即没有任何一个非主键字段依赖于另一个非主键字段。</li></ul> 
<p>第三范式进一步消除了冗余数据，它规定任何非主键字段的信息都只能直接依赖于主键，不能通过其他非主键字段间接依赖于主键。如果存在这种传递依赖，则需要继续拆分表以达到3NF的要求。</p> 
<p>总结来说，三大范式旨在减少数据冗余、提高数据一致性以及简化数据修改操作的复杂性。在实际数据库设计中，根据业务需求和性能考量，有时会适度地违反某些范式，如引入适当的冗余以提升查询效率，这需要设计者权衡规范化与性能之间的平衡。</p> 
<h4>2 MySQL的selete * 和seltet 全字段的区别？</h4> 
<p>MySQL中<code>SELECT *</code>和<code>SELECT 全部字段名</code>在查询结果上没有区别，它们都会返回表中的所有列数据。但二者在性能、可读性以及数据库设计原则上有以下几点差异：</p> 
<ol><li> <p><strong>性能影响</strong>：</p> 
  <ul><li><code>SELECT *</code>：MySQL服务器需要解析查询语句时确定<code>*</code>代表的所有字段，这可能会比直接指定字段名稍微多花一点时间。此外，如果表中有大量字段，而应用程序只需要其中一部分，那么使用<code>SELECT *</code>会增加网络传输的开销，因为返回了不必要的字段信息。</li><li><code>SELECT 全部字段名</code>：当明确列出所有字段名时，MySQL可以直接处理这些字段而无需额外解析步骤。尤其在大表中，只选择必要的字段可以减少I/O操作和网络传输量。</li></ul></li><li> <p><strong>索引优化</strong>：</p> 
  <ul><li>使用覆盖索引（Covering Index）的情况下，如果仅查询索引包含的字段，MySQL有可能直接从索引中获取所需数据，而不必访问实际的数据页，从而提高查询效率。但如果执行<code>SELECT *</code>，即使部分字段可以通过索引查找，其他非索引字段仍需回表查询，导致无法充分利用索引优化。</li></ul></li><li> <p><strong>可读性和维护性</strong>：</p> 
  <ul><li><code>SELECT *</code>降低了代码的可读性，因为阅读者不能一眼看出具体查询哪些字段，增加了未来维护成本。</li><li>明确写出每个字段名则提高了SQL语句的可读性，并且有助于保持代码整洁和明确。</li></ul></li><li> <p><strong>表结构变更的影响</strong>：</p> 
  <ul><li>当表结构发生变化（如添加或删除字段）时，使用<code>SELECT *</code>的代码可能不会反映出这种变化，导致预期外的行为。而在代码中明确列出字段，则可以避免因表结构变动带来的问题。</li></ul></li></ol> 
<p>综上所述，在编写SQL查询时，除非确实需要表的所有字段，一般推荐明确列出所要查询的字段名称以提升性能和维护性。</p> 
<p></p> 
<h4>3 MySQL的seletet *除了是全字段扫描外为什么慢？</h4> 
<p>MySQL的<code>SELECT *</code>语句之所以在某些情况下执行较慢，主要是因为以下几个原因：</p> 
<ol><li> <p><strong>数据传输量大</strong>：</p> 
  <ul><li>当查询表中的所有字段时，数据库需要将所有列的数据从磁盘读取到内存，并通过网络发送给客户端。如果表结构中有大量字段或者字段值占用空间较大（如文本、二进制数据等），这会显著增加网络传输和内存使用，特别是在带宽有限或内存资源紧张的情况下。</li></ul></li><li> <p><strong>索引利用率低</strong>：</p> 
  <ul><li>如果查询中没有明确指定索引字段，即使表中有适合当前查询的索引，也无法利用索引来加速查询。由于索引通常只包含部分字段（尤其是主键和唯一索引），因此全字段扫描不会直接利用索引提高查询速度。</li></ul></li><li> <p><strong>I/O操作成本高</strong>：</p> 
  <ul><li>在大数据量的表中，全字段扫描意味着对表进行全表扫描，可能导致大量的磁盘I/O操作，尤其当数据无法全部加载到内存时，频繁的磁盘访问会使查询响应时间大大增加。</li></ul></li><li> <p><strong>无谓的计算开销</strong>：</p> 
  <ul><li>对于存储过程、触发器或者其他后续处理来说，可能只需要其中一部分字段，但<code>SELECT *</code>却返回了所有字段，导致不必要的计算和处理。</li></ul></li><li> <p><strong>未优化的查询计划</strong>：</p> 
  <ul><li>数据库优化器可能无法提供一个最优的查询计划，因为它不能针对未知的具体列做出最佳选择。</li></ul></li><li> <p><strong>缓存效率较低</strong>：</p> 
  <ul><li>查询结果缓存通常基于SQL语句和所涉及的具体列来实现。<code>SELECT *</code>与具体列出列名的查询相比，在缓存匹配上的效率可能会降低，因为相同的表查询不同列集可能会产生不同的缓存项。</li></ul></li></ol> 
<p>为了提高查询性能，应尽量避免在生产环境中使用<code>SELECT *</code>，除非确实需要获取所有字段信息。推荐的做法是根据实际需求指定要查询的列，同时结合适当的索引策略以减少不必要的I/O和CPU开销</p> 
<h4>4 MySQL如何做优化？</h4> 
<p>MySQL数据库优化涉及多个层面，包括但不限于以下几点：</p> 
<h4><strong>配置优化</strong></h4> 
<ol><li> <p><strong>调整参数</strong>：</p> 
  <ul><li>根据服务器硬件资源和应用特点调整<code>innodb_buffer_pool_size</code>（InnoDB缓冲池大小），通常应设置为可用物理内存的50%-70%。</li><li>调整<code>max_connections</code>以适应并发连接需求，但要防止过多空闲连接导致内存浪费。</li><li>配置<code>query_cache_size</code>（查询缓存）或启用查询缓存插件（MySQL 8.0中已移除查询缓存）。</li><li>设置合适的<code>tmp_table_size</code>和<code>max_heap_table_size</code>以处理内部临时表。</li></ul></li><li> <p><strong>线程池优化</strong>：</p> 
  <ul><li>对于高并发场景，考虑启用线程池功能（如<code>thread_handling=pool-of-threads</code>）来减少线程创建销毁开销。</li></ul></li><li> <p><strong>日志系统</strong>：</p> 
  <ul><li>合理配置事务日志、错误日志以及慢查询日志，比如适当增大日志文件大小、合理设置sync_binlog参数等。</li></ul></li></ol> 
<h4><strong>表结构及索引优化</strong></h4> 
<ol><li> <p><strong>字段类型选择</strong>：</p> 
  <ul><li>确保使用最合适的字段类型，避免过度消耗存储空间，例如使用更小的整数类型、适合数据范围的浮点数类型等。</li></ul></li><li> <p><strong>表设计</strong>：</p> 
  <ul><li>分区表：对于大表可以考虑水平分区或者垂直拆分。</li><li>压缩表：在存储空间紧张时可考虑启用表压缩。</li></ul></li><li> <p><strong>索引策略</strong>：</p> 
  <ul><li>创建适当的唯一索引和覆盖索引提高查询效率。</li><li>使用复合索引，并遵循最左前缀原则。</li><li>避免在经常更新的列上创建索引，因为插入、删除和更新操作会触发索引重建，影响性能。</li></ul></li><li> <p><strong>NULL值处理</strong>：</p> 
  <ul><li>尽可能避免索引列允许NULL值，因为在某些情况下，含有NULL值的索引可能会降低查询效率。</li></ul></li></ol> 
<h4><strong>查询优化</strong></h4> 
<ol><li> <p><strong>SQL语句审查</strong>：</p> 
  <ul><li>避免全表扫描，尽可能利用索引执行查询。</li><li>减少不必要的JOIN操作，尤其避免CROSS JOIN。</li><li>避免在WHERE子句中对索引列进行函数运算或类型转换。</li><li>使用EXPLAIN分析查询计划，找出低效查询并针对性优化。</li></ul></li><li> <p><strong>批量处理与延迟写入</strong>：</p> 
  <ul><li>对于大量插入、更新操作，采用批量INSERT或LOAD DATA INFILE代替单条插入。</li><li>对于实时性要求不高的数据，可以采用异步方式写入，减轻主库压力。</li></ul></li></ol> 
<h4><strong>服务器硬件与架构优化</strong></h4> 
<ol><li> <p><strong>硬件升级</strong>：</p> 
  <ul><li>提升CPU速度和核心数量、增加内存容量、使用高速SSD硬盘替换传统HDD。</li></ul></li><li> <p><strong>架构改进</strong>：</p> 
  <ul><li>数据库读写分离，通过主从复制实现读取负载均衡。</li><li>在合适的情况下采用分布式数据库中间件或分片技术进行水平扩展。</li><li>对于复杂查询，考虑引入缓存服务如Redis。</li></ul></li></ol> 
<h4><strong>其他优化措施</strong></h4> 
<ol><li> <p><strong>定期维护与监控</strong>：</p> 
  <ul><li>定期分析和清理无用的数据，运行ANALYZE TABLE更新统计信息以便优化器做出更好的决策。</li><li>使用监控工具持续关注MySQL服务器状态，如磁盘I/O、内存使用情况、锁竞争状况等。</li></ul></li><li> <p><strong>定时任务与计划</strong>：</p> 
  <ul><li>合理安排大型任务在业务低峰期执行，避免影响正常业务时段的性能。</li></ul></li></ol> 
<p>总之，MySQL数据库优化是一个全方位的过程，需要结合实际应用场景和业务需求不断调整和改进。同时，随着MySQL版本迭代，新特性可能带来新的优化手段，因此保持对最新技术的关注也很重要。</p> 
<p></p> 
<h4>5 MySQL的常用SQL语句优化有哪些？</h4> 
<p>MySQL数据库中SQL语句的优化涉及多个方面，以下是一些常用的SQL语句优化策略：</p> 
<ol><li> <p><strong>使用索引</strong>：</p> 
  <ul><li>确保在查询条件中频繁使用的列上创建索引，尤其是where子句中的列和连接操作的列。</li><li>对于排序、分组等操作的字段也应考虑建立索引。</li><li>使用覆盖索引（Covering Index），即索引包含所有需要查询的字段，可以减少回表操作。</li></ul></li><li> <p><strong>避免全表扫描</strong>：</p> 
  <ul><li>尽可能避免<code>SELECT *</code>，明确指定需要的列，减少数据传输量和CPU处理开销。</li><li>当查询结果集很小而表很大时，优先考虑使用索引来替代全表扫描。</li></ul></li><li> <p><strong>合理使用JOIN</strong>：</p> 
  <ul><li>减少不必要的JOIN操作，尽量简化JOIN层次和数量。</li><li>优化JOIN顺序，根据表的数据量和索引情况选择合适的JOIN策略。</li><li>使用INNER JOIN代替LEFT JOIN或RIGHT JOIN，因为后者可能导致更多行被读取。</li></ul></li><li> <p><strong>条件过滤</strong>：</p> 
  <ul><li>在WHERE子句中先处理最能过滤数据的条件，以便尽早减少工作集大小。</li><li>避免在索引列上使用函数或者进行类型转换，这可能会导致无法利用索引。</li></ul></li><li> <p><strong>避免在JOIN和WHERE子句中使用不等条件</strong>：</p> 
  <ul><li>不等条件通常会阻止MySQL使用某些索引优化策略。</li></ul></li><li> <p><strong>避免IN和NOT IN</strong>：</p> 
  <ul><li>如果列表中有大量值，改用JOIN或者EXISTS子查询可能更高效。</li></ul></li><li> <p><strong>LIMIT与OFFSET优化</strong>：</p> 
  <ul><li>当需要进行分页查询时，随着OFFSET值增加，效率会下降。考虑使用索引跳跃查询或临时表存储中间结果以提高性能。</li></ul></li><li> <p><strong>避免冗余计算</strong>：</p> 
  <ul><li>如果一个表达式在SQL语句中多次出现，考虑将其结果保存到变量中重用。</li></ul></li><li> <p><strong>子查询优化</strong>：</p> 
  <ul><li>将适用的子查询转化为JOIN操作，有时可提高性能。</li></ul></li><li> <p><strong>批量插入和更新</strong>：</p> 
  <ul><li>使用INSERT INTO ... VALUES ..., (...) ON DUPLICATE KEY UPDATE结构进行批量插入或更新操作，而非单条执行。</li></ul></li><li> <p><strong>适当设置SQL缓存</strong>：</p> 
  <ul><li>根据业务场景，对于静态或变化较少的结果集，可以考虑启用查询缓存（MySQL 8.0后移除查询缓存）或自建缓存机制。</li></ul></li><li> <p><strong>事务管理</strong>：</p> 
  <ul><li>合理控制事务范围，避免长事务阻塞资源；在可能的情况下，使用乐观锁或悲观锁来减少死锁的发生。</li></ul></li></ol> 
<p>通过上述策略以及对特定查询执行计划的理解和调整，可以显著提升MySQL数据库中SQL语句的执行效率。同时，持续监控和分析数据库性能指标也是优化过程的重要组成部分。</p> 
<h4>6 Mysql 悲观锁</h4> 
<p>在MySQL中，悲观锁是一种并发控制机制，它假设多个事务并发访问数据时会发生冲突，并且为了防止这种情况，在读取或修改数据前先获取并持有排他锁（Exclusive Lock），直到事务结束才释放。这样可以确保在当前事务处理期间，其他事务不能对锁定的数据进行修改。</p> 
<p><strong>如何实现MySQL的悲观锁：</strong></p> 
<ol><li> <p><strong>行级悲观锁：</strong> 使用<code>SELECT ... FOR UPDATE</code>语句来获取某一行记录的悲观锁。例如：</p> <pre></pre> Sql <pre><code>1START TRANSACTION;
2SELECT * FROM table_name WHERE id = ? FOR UPDATE;
3-- 进行业务操作...
4COMMIT;</code></pre> <p>上述SQL执行后，如果找到匹配id的记录，则该记录会被加上一个排他锁，直到事务提交或回滚。在此期间，其他试图对同一记录执行<code>FOR UPDATE</code>的事务将会被阻塞，直到该锁被释放。</p> </li><li> <p><strong>表级悲观锁：</strong> MySQL也支持使用<code>LOCK TABLES</code>命令对整个表加锁，但这种方式粒度较粗，一般不推荐在高并发场景下使用，因为容易导致性能瓶颈。</p> <pre></pre> Sql <pre><code>1LOCK TABLES table_name WRITE;
2-- 进行业务操作...
3UNLOCK TABLES;</code></pre> <p>当执行<code>LOCK TABLES</code>后，其他任何事务都不能对该表进行写入操作，直到当前事务调用<code>UNLOCK TABLES</code>释放锁。</p> </li></ol> 
<p>需要注意的是，悲观锁在提高并发安全性的同时，可能会降低系统的并发性能，因为它会增加</p> 
<p></p> 
<h4>7 MySQL索引的作用？和它的优点缺点是什么？</h4> 
<p>MySQL索引的作用：</p> 
<ol><li> <p><strong>加速查询</strong>：</p> 
  <ul><li>索引是数据库表中数据结构的一种，它可以快速定位到特定的数据行。通过索引，数据库系统不需要进行全表扫描，而是直接根据索引查找对应的记录，从而显著提高数据检索速度。</li></ul></li><li> <p><strong>唯一性保证</strong>：</p> 
  <ul><li>对于唯一索引（UNIQUE INDEX），可以确保指定列的值在表中是唯一的，从而防止插入重复数据，为业务逻辑提供保障。</li></ul></li><li> <p><strong>排序和分组优化</strong>：</p> 
  <ul><li>当对索引列进行ORDER BY或GROUP BY操作时，数据库可以直接利用索引来完成排序和分组，减少不必要的计算开销。</li></ul></li><li> <p><strong>连接性能提升</strong>：</p> 
  <ul><li>在执行JOIN操作时，如果被连接的字段上有合适的索引，可以极大地提高连接操作的效率。</li></ul></li></ol> 
<p>MySQL索引的优点：</p> 
<ul><li>提高查询性能，特别是对于大型表来说，索引可以大大减少查询时间。</li><li>通过唯一索引实现数据完整性约束，避免数据重复。</li></ul> 
<p>MySQL索引的缺点：</p> 
<ol><li> <p><strong>占用存储空间</strong>：</p> 
  <ul><li>创建索引需要额外的物理存储空间，尤其是在包含大量数据的大表上建立索引，可能会占用较大的存储资源。</li></ul></li><li> <p><strong>写入性能下降</strong>：</p> 
  <ul><li>插入、更新和删除操作需要同时维护索引，这会增加写操作的成本。每次修改数据时，不仅要修改数据本身，还要对涉及的索引进行相应调整，这可能导致写入性能降低。</li></ul></li><li> <p><strong>维护成本</strong>：</p> 
  <ul><li>随着数据量的增长，索引可能需要定期重建以保持性能，而重建过程通常需要消耗较多的系统资源。</li></ul></li><li> <p><strong>过度索引</strong>：</p> 
  <ul><li>如果创建了过多不必要的索引，不仅浪费存储空间，还可能导致优化器在选择执行计划时产生困扰，反而降低查询效率。</li></ul></li><li> <p><strong>查询优化器的选择</strong>：</p> 
  <ul><li>即使存在索引，MySQL查询优化器并不一定总会选择使用索引执行查询，具体是否能发挥索引优势取决于具体的查询条件和SQL语句结构。</li></ul></li></ol> 
<p>8  MySQL有哪些索引（或者说索引类型有哪些）？</p> 
<p>MySQL数据库支持多种索引类型，以下是一些主要的索引类型：</p> 
<ol><li> <p><strong>B-Tree Index（B树索引）</strong></p> 
  <ul><li>这是最常见的索引类型，几乎所有的InnoDB和MyISAM表都默认使用这种类型的索引。B-Tree索引适用于全值匹配、范围查询以及排序操作，它能提供快速的点查、范围查找和排序功能。</li></ul></li><li> <p><strong>晚7yHash Index（哈希索引）</strong></p> 
  <ul><li>Memory引擎表支持哈希索引，适用于等值查询且效率极高，但不支持范围查询和排序操作。哈希索引通过哈希函数将键直接映射到存储位置，因此对于精确匹配特别快。</li></ul></li><li> <p><strong>R-Tree Index（R树索引）</strong></p> 
  <ul><li>用于空间数据类型的索引，例如<code>SPATIAL</code>索引，常用于地理空间数据的检索，如经纬度坐标。</li></ul></li><li> <p><strong>Full-text Index（全文索引）</strong></p> 
  <ul><li>适用于对文本字段进行全文搜索，可以实现对文本内容的关键字搜索，而非仅仅基于字符串的开头或完全匹配。在MyISAM、InnoDB中均可创建全文索引，不过它们使用的全文索引引擎不同。</li></ul></li><li> <p><strong>Primary Key Index（主键索引）</strong></p> 
  <ul><li>主键自动具有唯一性，并且在InnoDB中会隐式地创建一个聚簇索引（Clustered Index），主键索引的顺序决定了行记录在磁盘上的物理存储顺序。</li></ul></li><li> <p><strong>Secondary Index（辅助索引/二级索引）</strong></p> 
  <ul><li>在非主键列上创建的索引被称为辅助索引或二级索引。InnoDB中，辅助索引包含了主键值，从而允许从辅助索引直接定位到具体的行记录。</li></ul></li><li> <p><strong>Unique Index（唯一索引）</strong></p> 
  <ul><li>可以是任何类型的索引（如B-Tree索引），但是要求所有索引键值必须唯一。这对于保证数据一致性很有用，同时也有助于查询优化。</li></ul></li><li> <p><strong>Composite Index（组合索引/复合索引）</strong></p> 
  <ul><li>复合索引是在多个列上定义的一个索引，它可以是一个B-Tree索引，其内部按照索引列的顺序构建层次结构。最左前缀原则在这种索引上尤为关键，即查询时需要从索引最左边开始连续使用索引列。</li></ul></li></ol> 
<p>根据实际业务需求和数据库表设计，可以选择适合的索引类型来提高查询性能和数据一致性</p> 
<p></p> 
<h4>8 MySQL的主键和索引有什么区别？</h4> 
<p>MySQL的主键（Primary Key）和索引（Index）在概念和功能上有着明显的区别，同时也存在一定的联系。以下是对它们区别的详细说明：</p> 
<p><strong>主键：</strong></p> 
<ol><li> <p><strong>唯一性</strong>： 主键的主要特性是其值必须在表中是唯一的，每个表只能有一个主键，并且每个主键列的每一行都不能有重复的值。</p> </li><li> <p><strong>完整性约束</strong>： 主键用于确保数据完整性，数据库管理系统会自动强制执行主键的唯一性约束，即不允许插入两行具有相同主键值的数据。</p> </li><li> <p><strong>标识记录</strong>： 主键通常用来唯一地标识表中的每一行记录，作为记录的“身份证”，使得用户可以通过主键快速定位到特定的一行数据。</p> </li><li> <p><strong>聚簇索引（InnoDB存储引擎）</strong>： 在InnoDB存储引擎中，主键索引同时也是聚簇索引，这意味着表的数据行实际按照主键顺序进行物理存储，且主键索引包含了所有列的数据，可以直接通过主键索引获取整行数据。</p> </li></ol> 
<p><strong>索引：</strong></p> 
<ol><li> <p><strong>非唯一性</strong>： 索引并不一定要求唯一，除了唯一索引外，还可以创建普通索引，允许存在多个相同的索引值。</p> </li><li> <p><strong>辅助查找</strong>： 索引主要用于提高查询性能，数据库系统使用索引来加速对表中数据的检索速度，减少磁盘I/O操作。</p> </li><li> <p><strong>独立于数据存储</strong>： 除InnoDB的聚簇索引外，大多数索引与数据行的物理存储位置无关，它们是一种指向数据行的指针列表。</p> </li><li> <p><strong>多种类型</strong>： 索引可以是B-Tree、哈希、全文等不同类型的索引，每种索引适用于不同的查询场景。</p> </li><li> <p><strong>非必要性</strong>： 并不是每个表都需要有索引，也不是每个字段都需要建立索引。索引的选择取决于查询模式以及业务需求。</p> </li></ol> 
<p><strong>联系：</strong></p> 
<ul><li>主键字段默认会自动创建一个唯一索引，也就是说，主键其实也是一种特殊的索引。</li><li>如果主键是一个复合主键（由多个列组成），那么这个主键就是一个组合索引（Composite Index）。</li></ul> 
<p>总结来说，主键是用来唯一标识一行记录并保持数据完整性的关键字段，而索引则主要是为了提升查询效率的一种数据库结构。虽然主键隐含着一种特殊的索引，但并非所有的索引都是主键</p> 
<p></p> 
<h4>9 MySQL创建索引的原则是什么？</h4> 
<p>MySQL创建索引的原则主要包括以下几点：</p> 
<ol><li> <p><strong>高选择性原则</strong>：</p> 
  <ul><li>对于具有高选择性的列（即列中唯一或非重复值的比例高的列）优先考虑创建索引。例如，身份证号、用户ID等列通常具有良好的选择性，创建索引后查询性能提升明显。</li></ul></li><li> <p><strong>频繁查询和过滤条件原则</strong>：</p> 
  <ul><li>经常出现在WHERE子句中的列，尤其是作为查询条件的列，应建立索引。这些索引可以加速数据检索过程，提高查询效率。</li></ul></li><li> <p><strong>排序和分组原则</strong>：</p> 
  <ul><li>如果在ORDER BY、GROUP BY或者DISTINCT操作中涉及的列，特别是当它们不在查询结果集中时，为这些列创建索引有助于优化排序和分组操作。</li></ul></li><li> <p><strong>联合索引与覆盖索引</strong>：</p> 
  <ul><li>对于多列查询，可以考虑创建联合索引。按照查询需求从左至右顺序排列索引字段，遵循最左前缀匹配原则。</li><li>覆盖索引是指一个索引包含了查询需要的所有列，使得查询可以直接通过索引返回结果，而无需回表访问数据行，大大提升了查询性能。</li></ul></li><li> <p><strong>避免过度索引</strong>：</p> 
  <ul><li>不是所有列都需要创建索引，特别是对于那些更新频繁的列，每次插入、修改或删除都会导致索引的维护成本增加，从而可能影响写操作性能。</li><li>同时，过多的索引也会占用更多的存储空间，并可能导致优化器在选择执行计划时产生困惑。</li></ul></li><li> <p><strong>考虑索引维护成本</strong>：</p> 
  <ul><li>索引虽然能提升查询速度，但在插入、更新和删除数据时会额外增加维护索引的成本。因此，在对频繁更新的表设计索引时要权衡读写操作的需求。</li></ul></li><li> <p><strong>业务场景分析</strong>：</p> 
  <ul><li>根据具体的业务场景和数据库工作负载进行索引设计，如热点数据分布、查询模式（点查、范围查询、全表扫描）、数据量大小等因素。</li></ul></li></ol> 
<p>总之，在MySQL中创建索引应该基于实际的业务需求和查询模式来综合判断和决策，以实现查询性能的最大化和资源消耗的合理平衡。</p> 
<p></p> 
<h4>10 MySQL的索引在哪些情况下会失效？</h4> 
<p>MySQL的索引在以下情况下可能失效或无法有效利用：</p> 
<p>全表扫描（Full Table Scan）：</p> 
<p>当执行SELECT *查询所有字段，尤其是当数据量不大或者需要返回的数据量超过一定比例时，MySQL可能会选择进行全表扫描而非使用索引。<br> 如果查询条件包含不等号（!=、&lt;&gt;、NOT IN、BETWEEN且范围不是从左到右连续）、LIKE以通配符开头（如LIKE '%abc%'），或者使用函数和表达式对索引列进行操作，可能导致索引失效。<br> 排序与分组（ORDER BY 和 GROUP BY）：</p> 
<p>对非索引列进行排序或分组，即使查询条件中有索引，也可能导致无法利用索引排序。但如果排序或分组的列恰好是覆盖索引的一部分，则可以避免额外的排序开销。<br> 联合索引最左前缀原则：</p> 
<p>在一个复合索引中，如果查询条件没有按照索引建立的顺序指定，那么从第一个未被指定的列开始，后续的索引将不会被使用。例如，对于索引idx(a, b, c)，WHERE b = ? AND c = ?将不能使用该索引。<br> 类型转换与隐式转换：</p> 
<p>查询条件中的数据类型与索引列数据类型不匹配，数据库系统在比较之前需要进行隐式类型转换，这会导致无法使用索引。<br> 索引列上的运算：</p> 
<p>如果查询语句中对索引列进行了加减乘除、字符串拼接等计算操作，索引通常无法发挥作用。<br> 索引未被维护或失效：</p> 
<p>表数据更新后，如果没有正确维护索引，例如删除了索引列的唯一值后未重建索引，可能会导致索引失效。<br> 覆盖索引未被满足：</p> 
<p>当查询所需的所有列都在一个索引中能找到，而实际查询结果包含了不在索引中的列时，虽然部分索引会被使用，但依然可能导致不必要的回表操作。<br> 索引统计信息过时：</p> 
<p>数据库优化器依赖于索引和表的统计信息来决定是否使用索引。如果统计信息过时，可能会错误地选择不使用索引。<br> 索引列使用OR连接条件：</p> 
<p>OR条件连接的两个条件分别涉及到索引的不同部分时，MySQL可能无法同时使用索引。<br> 查询优化器选择：</p> 
<p>即使存在合适的索引，查询优化器根据成本估算模型也可能选择不使用索引，尤其是在数据分布非常不均匀的情况下。<br> 为了确保索引能够有效地提高查询性能，应密切关注查询语句编写方式，并结合EXPLAIN分析工具了解查询计划，以便针对性地优化SQL语句和索引策略。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d74b0d372ffc66b8a947decf5ab398d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">WPS JS宏的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1cbc3720d7ecec47b8babd228a15a7b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">翻硬币-贪心</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>