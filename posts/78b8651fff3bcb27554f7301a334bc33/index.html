<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[UOJ]#61. 【UR #5】怎样更有力气 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[UOJ]#61. 【UR #5】怎样更有力气" />
<meta property="og:description" content="题面传送门
做法：做法比较暴力。先按权值把每一天排序，从小到大做生成树，每一天我们先判这条链是否已经在同一个连通块（后面说怎么判），如果是就跳过，否则我们选出链的一个端点，然后找链上不与它在同一连通块的点，为了跳过同一连通块的点，我们用并查集维护每个点一直向祖先走，只走在同一连通块的点最远走到哪，合并连通块的时候我们启发式合并，顺便维护这个信息即可（利用这个信息，整条链是否属于同一个连通块也能判了），如果找到被限制条件限住的点，我们跳过，否则我们合并这两个连通块，链上与它不在同一连通块的点都走过之后，就把这个点从链上删掉从头做，我们每次考虑一个点对的时候要么是限制条件，要么是最后求出的生成树中的边，所以是O(n&#43;p)的，加上启发式合并等复杂度，总时间复杂度大概是O(nlogn)级别的，常数较大。（另外貌似成为了UOJ上该题的代码最短）
代码：
#include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;map&gt; using namespace std; inline int read() { int x;char c; while((c=getchar())&lt;&#39;0&#39;||c&gt;&#39;9&#39;); for(x=c-&#39;0&#39;;(c=getchar())&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;;)x=x*10&#43;c-&#39;0&#39;; return x; } #define MN 300000 #define K 19 #define v(x,y) make_pair(min(x,y),max(x,y)) struct work{int x,y,w,id;}w[MN&#43;5]; bool cmp(const work&amp;a,const work&amp;b){return a.w&lt;b.w;} int fa[K][MN&#43;5],f[MN&#43;5],d[MN&#43;5],c[MN&#43;5]; map&lt;pair&lt;int,int&gt;,bool&gt; mp[MN&#43;5]; vector&lt;int&gt; v[MN&#43;5],vv[MN&#43;5]; int gf(int k){return f[k]?f[k]=gf(f[k]):k;} int lca(int x,int y) { if(d[x]&lt;d[y])swap(x,y); int i=0,p=d[x]-d[y]; for(;p;p&gt;&gt;=1,&#43;&#43;i)if(p&amp;1)x=fa[i][x]; if(x==y)return x; for(i=K;i--;)if(fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y]; return fa[0][x]; } void merge(int a,int b) { if(vv[a]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/78b8651fff3bcb27554f7301a334bc33/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-09-13T17:40:00+08:00" />
<meta property="article:modified_time" content="2017-09-13T17:40:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[UOJ]#61. 【UR #5】怎样更有力气</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><a href="http://uoj.ac/problem/61" rel="nofollow">题面传送门</a></p> 
 <p>做法：做法比较暴力。先按权值把每一天排序，从小到大做生成树，每一天我们先判这条链是否已经在同一个连通块（后面说怎么判），如果是就跳过，否则我们选出链的一个端点，然后找链上不与它在同一连通块的点，为了跳过同一连通块的点，我们用并查集维护每个点一直向祖先走，只走在同一连通块的点最远走到哪，合并连通块的时候我们启发式合并，顺便维护这个信息即可（利用这个信息，整条链是否属于同一个连通块也能判了），如果找到被限制条件限住的点，我们跳过，否则我们合并这两个连通块，链上与它不在同一连通块的点都走过之后，就把这个点从链上删掉从头做，我们每次考虑一个点对的时候要么是限制条件，要么是最后求出的生成树中的边，所以是O(n+p)的，加上启发式合并等复杂度，总时间复杂度大概是O(nlogn)级别的，常数较大。（另外貌似成为了UOJ上该题的代码最短）</p> 
 <p>代码：</p> 
 <div class="cnblogs_code"> 
  <pre>#include&lt;cstdio&gt;<span style="color:#000000;">
#include</span>&lt;algorithm&gt;<span style="color:#000000;">
#include</span>&lt;vector&gt;<span style="color:#000000;">
#include</span>&lt;map&gt;
<span style="color:#0000ff;">using</span> <span style="color:#0000ff;">namespace</span><span style="color:#000000;"> std;
inline </span><span style="color:#0000ff;">int</span><span style="color:#000000;"> read()
{
    </span><span style="color:#0000ff;">int</span> x;<span style="color:#0000ff;">char</span><span style="color:#000000;"> c;
    </span><span style="color:#0000ff;">while</span>((c=getchar())&lt;<span style="color:#800000;">'</span><span style="color:#800000;">0</span><span style="color:#800000;">'</span>||c&gt;<span style="color:#800000;">'</span><span style="color:#800000;">9</span><span style="color:#800000;">'</span><span style="color:#000000;">);
    </span><span style="color:#0000ff;">for</span>(x=c-<span style="color:#800000;">'</span><span style="color:#800000;">0</span><span style="color:#800000;">'</span>;(c=getchar())&gt;=<span style="color:#800000;">'</span><span style="color:#800000;">0</span><span style="color:#800000;">'</span>&amp;&amp;c&lt;=<span style="color:#800000;">'</span><span style="color:#800000;">9</span><span style="color:#800000;">'</span>;)x=x*<span style="color:#800080;">10</span>+c-<span style="color:#800000;">'</span><span style="color:#800000;">0</span><span style="color:#800000;">'</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> x;
}
</span><span style="color:#0000ff;">#define</span> MN 300000
<span style="color:#0000ff;">#define</span> K 19
<span style="color:#0000ff;">#define</span> v(x,y) make_pair(min(x,y),max(x,y))
<span style="color:#0000ff;">struct</span> work{<!-- --><span style="color:#0000ff;">int</span> x,y,w,id;}w[MN+<span style="color:#800080;">5</span><span style="color:#000000;">];
</span><span style="color:#0000ff;">bool</span> cmp(<span style="color:#0000ff;">const</span> work&amp;a,<span style="color:#0000ff;">const</span> work&amp;b){<!-- --><span style="color:#0000ff;">return</span> a.w&lt;<span style="color:#000000;">b.w;}
</span><span style="color:#0000ff;">int</span> fa[K][MN+<span style="color:#800080;">5</span>],f[MN+<span style="color:#800080;">5</span>],d[MN+<span style="color:#800080;">5</span>],c[MN+<span style="color:#800080;">5</span><span style="color:#000000;">];
map</span>&lt;pair&lt;<span style="color:#0000ff;">int</span>,<span style="color:#0000ff;">int</span>&gt;,<span style="color:#0000ff;">bool</span>&gt; mp[MN+<span style="color:#800080;">5</span><span style="color:#000000;">];
vector</span>&lt;<span style="color:#0000ff;">int</span>&gt; v[MN+<span style="color:#800080;">5</span>],vv[MN+<span style="color:#800080;">5</span><span style="color:#000000;">];
</span><span style="color:#0000ff;">int</span> gf(<span style="color:#0000ff;">int</span> k){<!-- --><span style="color:#0000ff;">return</span> f[k]?f[k]=<span style="color:#000000;">gf(f[k]):k;}
</span><span style="color:#0000ff;">int</span> lca(<span style="color:#0000ff;">int</span> x,<span style="color:#0000ff;">int</span><span style="color:#000000;"> y)
{
    </span><span style="color:#0000ff;">if</span>(d[x]&lt;<span style="color:#000000;">d[y])swap(x,y);
    </span><span style="color:#0000ff;">int</span> i=<span style="color:#800080;">0</span>,p=d[x]-<span style="color:#000000;">d[y];
    </span><span style="color:#0000ff;">for</span>(;p;p&gt;&gt;=<span style="color:#800080;">1</span>,++i)<span style="color:#0000ff;">if</span>(p&amp;<span style="color:#800080;">1</span>)x=<span style="color:#000000;">fa[i][x];
    </span><span style="color:#0000ff;">if</span>(x==y)<span style="color:#0000ff;">return</span><span style="color:#000000;"> x;
    </span><span style="color:#0000ff;">for</span>(i=K;i--;)<span style="color:#0000ff;">if</span>(fa[i][x]!=fa[i][y])x=fa[i][x],y=<span style="color:#000000;">fa[i][y];
    </span><span style="color:#0000ff;">return</span> fa[<span style="color:#800080;">0</span><span style="color:#000000;">][x];
}
</span><span style="color:#0000ff;">void</span> merge(<span style="color:#0000ff;">int</span> a,<span style="color:#0000ff;">int</span><span style="color:#000000;"> b)
{
    </span><span style="color:#0000ff;">if</span>(vv[a].size()&gt;<span style="color:#000000;">vv[b].size())swap(a,b);
    </span><span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">int</span> i=<span style="color:#800080;">0</span>,x;i&lt;vv[a].size();++<span style="color:#000000;">i)
    {
        vv[c[x</span>=vv[a][i]]=<span style="color:#000000;">b].push_back(x);
        </span><span style="color:#0000ff;">if</span>(c[fa[<span style="color:#800080;">0</span>][x]]==b)f[x]=fa[<span style="color:#800080;">0</span><span style="color:#000000;">][x];
        </span><span style="color:#0000ff;">for</span>(<span style="color:#0000ff;">int</span> j=<span style="color:#800080;">0</span>;j&lt;v[x].size();++j)<span style="color:#0000ff;">if</span>(c[v[x][j]]==b)f[v[x][j]]=<span style="color:#000000;">x;
    }
}
</span><span style="color:#0000ff;">int</span><span style="color:#000000;"> main()
{
    </span><span style="color:#0000ff;">int</span> n,m,p,i,j,t,a,b;<span style="color:#0000ff;">long</span> <span style="color:#0000ff;">long</span> ans=<span style="color:#800080;">0</span><span style="color:#000000;">;
    n</span>=read();m=read();p=<span style="color:#000000;">read();
    </span><span style="color:#0000ff;">for</span>(d[<span style="color:#800080;">1</span>]=<span style="color:#800080;">1</span>,i=<span style="color:#800080;">2</span>;i&lt;=n;++i)v[fa[<span style="color:#800080;">0</span>][i]=read()].push_back(i),d[i]=d[fa[<span style="color:#800080;">0</span>][i]]+<span style="color:#800080;">1</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">for</span>(j=<span style="color:#800080;">1</span>;j&lt;K;++j)<span style="color:#0000ff;">for</span>(i=<span style="color:#800080;">1</span>;i&lt;=n;++i)fa[j][i]=fa[j-<span style="color:#800080;">1</span>][fa[j-<span style="color:#800080;">1</span><span style="color:#000000;">][i]];
    </span><span style="color:#0000ff;">for</span>(i=<span style="color:#800080;">1</span>;i&lt;=m;++i)w[i].x=read(),w[i].y=read(),w[i].w=read(),w[i].id=<span style="color:#000000;">i;
    sort(w</span>+<span style="color:#800080;">1</span>,w+m+<span style="color:#800080;">1</span><span style="color:#000000;">,cmp);
    </span><span style="color:#0000ff;">while</span>(p--)t=read(),a=read(),b=read(),mp[t][v(a,b)]=<span style="color:#800080;">1</span><span style="color:#000000;">;
    </span><span style="color:#0000ff;">for</span>(i=<span style="color:#800080;">1</span>;i&lt;=n;++i)vv[i].push_back(c[i]=<span style="color:#000000;">i);
    </span><span style="color:#0000ff;">for</span>(i=<span style="color:#800080;">1</span>;i&lt;=m;++<span style="color:#000000;">i)
    {
        j</span>=<span style="color:#000000;">lca(w[i].x,w[i].y);
        </span><span style="color:#0000ff;">while</span>(max(d[gf(w[i].x)],d[gf(w[i].y)])&gt;<span style="color:#000000;">d[j])
        {
            </span><span style="color:#0000ff;">if</span>(d[w[i].y]&gt;<span style="color:#000000;">d[w[i].x])swap(w[i].x,w[i].y);
            </span><span style="color:#0000ff;">for</span>(a=w[i].x;d[a]&gt;=d[j];a=fa[<span style="color:#800080;">0</span><span style="color:#000000;">][a])
            {
                </span><span style="color:#0000ff;">if</span>(c[a]==c[w[i].x]){a=gf(a);<span style="color:#0000ff;">continue</span><span style="color:#000000;">;}
                </span><span style="color:#0000ff;">if</span>(mp[w[i].id][v(a,w[i].x)])<span style="color:#0000ff;">continue</span><span style="color:#000000;">;
                ans</span>+=<span style="color:#000000;">w[i].w;merge(c[a],c[w[i].x]);
            }
            </span><span style="color:#0000ff;">for</span>(a=w[i].y;d[a]&gt;=d[j];a=fa[<span style="color:#800080;">0</span><span style="color:#000000;">][a])
            {
                </span><span style="color:#0000ff;">if</span>(c[a]==c[w[i].x]){a=gf(a);<span style="color:#0000ff;">continue</span><span style="color:#000000;">;}
                </span><span style="color:#0000ff;">if</span>(mp[w[i].id][v(a,w[i].x)])<span style="color:#0000ff;">continue</span><span style="color:#000000;">;
                ans</span>+=<span style="color:#000000;">w[i].w;merge(c[a],c[w[i].x]);
            }
            w[i].x</span>=fa[<span style="color:#800080;">0</span><span style="color:#000000;">][w[i].x];
        }
    }
    printf(</span><span style="color:#800000;">"</span><span style="color:#800000;">%lld</span><span style="color:#800000;">"</span><span style="color:#000000;">,ans);
}</span></pre> 
 </div> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/ditoly/p/UOJ61.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd9fcda1b3bf7b4ce368cf3ddb7e55c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java集合之LinkList解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f631c41ea0f58550f6c743aee503516/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">phpcms得到专题的名称</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>