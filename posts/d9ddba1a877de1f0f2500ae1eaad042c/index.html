<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM黑马版：笔记、应用、速查 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM黑马版：笔记、应用、速查" />
<meta property="og:description" content="前言 由于工作中时常和JVM打交道，但是对JVM的体系缺乏系统深入了解。日前跟随b站上黑马程序猿的课程成体系地学习了JVM，结合工作中的实践写就了此笔记。
黑马原视频地址：https://www.bilibili.com/video/BV1yE411Z7AP
1、概述：什么是JVM 2、内存结构 学习概述图：会根据下图依次介绍之：
2.1 程序计数器 程序计数器线程私有的理解：
2.2 虚拟机栈 栈帧的概念：一次方法调用 每个方法需要的内存存放于栈帧，方法的局部变量也存放于栈帧
问题辨析 1，垃圾回收是否涉及栈内存？
​ 不会，栈内存就是一次次的方法调用所产生的栈帧内存，栈帧内存在每一次的方法调用结束后后被弹出栈，自动的被回收掉，不需要垃圾回收。
2，栈内存分配越大越好么？
​ 栈内存划分的越大会使得线程数变少，因为我们物理内存的大小是一定的
如果是static修饰，会被多个线程使用，需要考虑线程安全问题：
局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全
栈内存溢出（Stack Overflow） 栈帧过多导致内存溢出（案例：疯狂的递归调用）
栈帧过大导致内存溢出（不易出现，因为局部变量只占一点空间）
可以使用虚拟机参数：Xss 来设置栈区内存大小。
线程运行诊断 2.3 本地方法栈 native关键字 native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C&#43;&#43;）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。
JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。
本地方法栈 其实就是给本地方法运行提供一个内存空间。
本地方法栈用于支持 native 方法的执行，存储了每个 native 方法调用的状态。本地方法栈和虚拟机方法栈运行机制一致，它们唯一的区别就是，虚拟机栈是执行 Java 方法的，而本地方法栈是用来执行 native 方法的，在很多虚拟机中（如 Sun 的 JDK 默认的 HotSpot 虚拟机），会将本地方法栈与虚拟机栈放在一起使用。
2.4 堆 堆概念 堆内存溢出（OutOfMemoryError） 代码示例：
上图例子是对象体积越来越大，最终撑爆了堆内存。
虚拟机参数：-Xmx 用来控制堆内存大小。例：-Xmx8m，指定堆内存为8MB。
堆内存诊断 jmap查看堆内存占用情况：
2.5 方法区 方法区定义： 方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量（const）、静态变量（static）、即时编译器编译后的代码等数据，方法编译出的字节码就是保存在这个区域虚拟机启动时，方法区被创建。方法区内存不足也会抛出OutOfMemoryError在Java1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d9ddba1a877de1f0f2500ae1eaad042c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-23T08:01:36+08:00" />
<meta property="article:modified_time" content="2023-05-23T08:01:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM黑马版：笔记、应用、速查</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<p>由于工作中时常和JVM打交道，但是对JVM的体系缺乏系统深入了解。日前跟随b站上黑马程序猿的课程成体系地学习了JVM，结合工作中的实践写就了此笔记。</p> 
<p>黑马原视频地址：https://www.bilibili.com/video/BV1yE411Z7AP</p> 
<h2><a id="1JVM_11"></a>1、概述：什么是JVM</h2> 
<h2><a id="2_13"></a>2、内存结构</h2> 
<p>学习概述图：会根据下图依次介绍之：<br> <img src="https://images2.imgbox.com/74/0e/fQTh9FuC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="21__18"></a>2.1 程序计数器</h3> 
<p><img src="https://images2.imgbox.com/22/8f/hXFrJBQe_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/96/89/y1QPp9Ha_o.png" alt="在这里插入图片描述"><br> <strong>程序计数器线程私有的理解：</strong><br> <img src="https://images2.imgbox.com/46/3c/xLcF7HSx_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22__28"></a>2.2 虚拟机栈</h3> 
<p><img src="https://images2.imgbox.com/e5/67/DAqrNph6_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_31"></a>栈帧的概念：一次方法调用</h4> 
<p><strong>每个方法需要的内存存放于栈帧，方法的局部变量也存放于栈帧</strong><br> <img src="https://images2.imgbox.com/be/c5/jTGIhIo2_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_35"></a>问题辨析</h4> 
<p><img src="https://images2.imgbox.com/f2/37/U1BrwQjI_o.png" alt="在这里插入图片描述"><br> <strong>1，垃圾回收是否涉及栈内存？</strong></p> 
<p>​ 不会，栈内存就是一次次的方法调用所产生的栈帧内存，栈帧内存在每一次的方法调用结束后后被弹出栈，自动的被回收掉，不需要垃圾回收。</p> 
<p><strong>2，栈内存分配越大越好么？</strong></p> 
<p>​ 栈内存划分的越大会使得线程数变少，因为我们物理内存的大小是一定的</p> 
<p><strong>如果是static修饰，会被多个线程使用，需要考虑线程安全问题：</strong><br> <img src="https://images2.imgbox.com/d8/82/u50Vtg2z_o.png" alt="在这里插入图片描述"><br> <strong>局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</strong><br> <img src="https://images2.imgbox.com/1c/ec/vGssTMnH_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Stack_Overflow_51"></a>栈内存溢出（Stack Overflow）</h4> 
<p>栈帧过多导致内存溢出（案例：疯狂的递归调用）</p> 
<p>栈帧过大导致内存溢出（不易出现，因为局部变量只占一点空间）</p> 
<p><strong>可以使用虚拟机参数：Xss 来设置栈区内存大小。</strong></p> 
<h4><a id="_58"></a>线程运行诊断</h4> 
<p><img src="https://images2.imgbox.com/0e/34/ydNULHKW_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="23__65"></a>2.3 本地方法栈</h3> 
<h4><a id="native_66"></a>native关键字</h4> 
<p>native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。</p> 
<p>JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。</p> 
<h4><a id="_72"></a>本地方法栈</h4> 
<p>其实就是给本地方法运行提供一个内存空间。</p> 
<p>本地方法栈用于支持 native 方法的执行，存储了每个 native 方法调用的状态。本地方法栈和虚拟机方法栈运行机制一致，它们唯一的区别就是，虚拟机栈是执行 Java 方法的，而本地方法栈是用来执行 native 方法的，在很多虚拟机中（如 Sun 的 JDK 默认的 HotSpot 虚拟机），会将本地方法栈与虚拟机栈放在一起使用。</p> 
<h3><a id="24__78"></a>2.4 堆</h3> 
<h4><a id="_79"></a>堆概念</h4> 
<p><img src="https://images2.imgbox.com/f1/ef/y9SJgD6q_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="OutOfMemoryError_82"></a>堆内存溢出（OutOfMemoryError）</h4> 
<p><strong>代码示例：</strong><br> <img src="https://images2.imgbox.com/6e/1a/Ei5vQkeR_o.png" alt="在这里插入图片描述"><br> 上图例子是对象体积越来越大，最终撑爆了堆内存。<br> <strong>虚拟机参数：-Xmx 用来控制堆内存大小。例：-Xmx8m，指定堆内存为8MB。</strong></p> 
<h4><a id="_88"></a>堆内存诊断</h4> 
<p><img src="https://images2.imgbox.com/7a/c9/viHvQYyx_o.png" alt="在这里插入图片描述"></p> 
<p><strong>jmap查看堆内存占用情况：</strong><br> <img src="https://images2.imgbox.com/0b/07/7wkrFDz7_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="25__95"></a>2.5 方法区</h3> 
<h4><a id="_96"></a>方法区定义：</h4> 
<ul><li>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量（const）、静态变量（static）、即时编译器编译后的代码等数据，方法编译出的字节码就是保存在这个区域</li><li>虚拟机启动时，方法区被创建。</li><li>方法区内存不足也会抛出OutOfMemoryError</li><li>在Java1.6里面 ，方法区在堆上，占用堆内存，称为<strong>永久代</strong>，然而Java1.8以后叫<strong>元空间</strong>，<strong>占用本地内存（操作系统内存）</strong></li></ul> 
<h4><a id="_102"></a>反射与方法区</h4> 
<p><img src="https://images2.imgbox.com/b8/5d/WViuTsyp_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_107"></a>方法区内存溢出</h4> 
<p><img src="https://images2.imgbox.com/ad/9d/ZhcQzi9u_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_109"></a>常量池和运行时常量池</h4> 
<p><strong>1、 .class文件中静态的常量池 无非就是一张表，虚拟机指令通过这张常量表找到要执行的类名，方法名等信息（不进JVM运行时候就有了，就是.class文件的一张表而已）</strong></p> 
<p><strong>2、 运行时常量池在1.8以后，是方法区的一部分。</strong><br> <img src="https://images2.imgbox.com/3e/54/5HkPFGQe_o.png" alt="在这里插入图片描述"><br> <strong>其实黑马这里说的不明白，我自己查阅了知乎，对常量池有了更深的理解。常量池分两种：一是.class文件中静态的常量池，二是.class文件中的静态常量池被加载到JVM中而形成的运行时常量池。如下图所示：</strong></p> 
<p>https://zhuanlan.zhihu.com/p/141072562</p> 
<p><img src="https://images2.imgbox.com/c5/0d/aHijHSCa_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8c/47/d2E7sUgw_o.png" alt="在这里插入图片描述"></p> 
<p><strong>如何查看静态常量池案例：</strong><br> 从编译目录（out目录），找到HelloWorld.java的class文件：HalloWorld.class，然后执行命令<code>javap -v HelloWorld.class</code>，即可看到反编译后的详细信息。</p> 
<p><img src="https://images2.imgbox.com/98/77/OlTYK2PZ_o.png" alt="在这里插入图片描述"><br> 可以看到.class详细信息如下所示：</p> 
<pre><code class="prism language-bash">Classfile /home/daji/data/datas/studyFiles/资料-解密JVM/jvm/out/production/jvm/cn/itcast/jvm/t5/HelloWorld.class
  Last modified <span class="token number">2021</span>年10月29日<span class="token punctuation">;</span> size <span class="token number">567</span> bytes
  SHA-256 checksum 37204bf6e654f64ae56660a1e8becfaa98b3ae7592b81b4b6e331de92a460b96
  Compiled from <span class="token string">"HelloWorld.java"</span>
public class cn.itcast.jvm.t5.HelloWorld
  minor version: <span class="token number">0</span>
  major version: <span class="token number">52</span>
  flags: <span class="token punctuation">(</span>0x0021<span class="token punctuation">)</span> ACC_PUBLIC, ACC_SUPER
  this_class: <span class="token comment">#5                          // cn/itcast/jvm/t5/HelloWorld</span>
  super_class: <span class="token comment">#6                         // java/lang/Object</span>
  interfaces: <span class="token number">0</span>, fields: <span class="token number">0</span>, methods: <span class="token number">2</span>, attributes: <span class="token number">1</span>
Constant pool:
   <span class="token comment">#1 = Methodref          #6.#20         // java/lang/Object."&lt;init&gt;":()V</span>
   <span class="token comment">#2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;</span>
   <span class="token comment">#3 = String             #23            // hello world</span>
   <span class="token comment">#4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span>
   <span class="token comment">#5 = Class              #26            // cn/itcast/jvm/t5/HelloWorld</span>
   <span class="token comment">#6 = Class              #27            // java/lang/Object</span>
   <span class="token comment">#7 = Utf8               &lt;init&gt;</span>
   <span class="token comment">#8 = Utf8               ()V</span>
   <span class="token comment">#9 = Utf8               Code</span>
  <span class="token comment">#10 = Utf8               LineNumberTable</span>
  <span class="token comment">#11 = Utf8               LocalVariableTable</span>
  <span class="token comment">#12 = Utf8               this</span>
  <span class="token comment">#13 = Utf8               Lcn/itcast/jvm/t5/HelloWorld;</span>
  <span class="token comment">#14 = Utf8               main</span>
  <span class="token comment">#15 = Utf8               ([Ljava/lang/String;)V</span>
  <span class="token comment">#16 = Utf8               args</span>
  <span class="token comment">#17 = Utf8               [Ljava/lang/String;</span>
  <span class="token comment">#18 = Utf8               SourceFile</span>
  <span class="token comment">#19 = Utf8               HelloWorld.java</span>
  <span class="token comment">#20 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span>
  <span class="token comment">#21 = Class              #28            // java/lang/System</span>
  <span class="token comment">#22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span>
  <span class="token comment">#23 = Utf8               hello world</span>
  <span class="token comment">#24 = Class              #31            // java/io/PrintStream</span>
  <span class="token comment">#25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span>
  <span class="token comment">#26 = Utf8               cn/itcast/jvm/t5/HelloWorld</span>
  <span class="token comment">#27 = Utf8               java/lang/Object</span>
  <span class="token comment">#28 = Utf8               java/lang/System</span>
  <span class="token comment">#29 = Utf8               out</span>
  <span class="token comment">#30 = Utf8               Ljava/io/PrintStream;</span>
  <span class="token comment">#31 = Utf8               java/io/PrintStream</span>
  <span class="token comment">#32 = Utf8               println</span>
  <span class="token comment">#33 = Utf8               (Ljava/lang/String;)V</span>
<span class="token punctuation">{<!-- --></span>
  public cn.itcast.jvm.t5.HelloWorld<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    descriptor: <span class="token punctuation">(</span><span class="token punctuation">)</span>V
    flags: <span class="token punctuation">(</span>0x0001<span class="token punctuation">)</span> ACC_PUBLIC
    Code:
      <span class="token assign-left variable">stack</span><span class="token operator">=</span><span class="token number">1</span>, <span class="token assign-left variable">locals</span><span class="token operator">=</span><span class="token number">1</span>, <span class="token assign-left variable">args_size</span><span class="token operator">=</span><span class="token number">1</span>
         <span class="token number">0</span>: aload_0
         <span class="token number">1</span>: invokespecial <span class="token comment">#1                  // Method java/lang/Object."&lt;init&gt;":()V</span>
         <span class="token number">4</span>: <span class="token builtin class-name">return</span>
      LineNumberTable:
        line <span class="token number">4</span>: <span class="token number">0</span>
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            <span class="token number">0</span>       <span class="token number">5</span>     <span class="token number">0</span>  this   Lcn/itcast/jvm/t5/HelloWorld<span class="token punctuation">;</span>

  public static void main<span class="token punctuation">(</span>java.lang.String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    descriptor: <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava/lang/String<span class="token punctuation">;</span><span class="token punctuation">)</span>V
    flags: <span class="token punctuation">(</span>0x0009<span class="token punctuation">)</span> ACC_PUBLIC, ACC_STATIC
    Code:
      <span class="token assign-left variable">stack</span><span class="token operator">=</span><span class="token number">2</span>, <span class="token assign-left variable">locals</span><span class="token operator">=</span><span class="token number">1</span>, <span class="token assign-left variable">args_size</span><span class="token operator">=</span><span class="token number">1</span>
         <span class="token number">0</span>: getstatic     <span class="token comment">#2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span>
         <span class="token number">3</span>: ldc           <span class="token comment">#3                  // String hello world</span>
         <span class="token number">5</span>: invokevirtual <span class="token comment">#4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>
         <span class="token number">8</span>: <span class="token builtin class-name">return</span>
      LineNumberTable:
        line <span class="token number">6</span>: <span class="token number">0</span>
        line <span class="token number">7</span>: <span class="token number">8</span>
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            <span class="token number">0</span>       <span class="token number">9</span>     <span class="token number">0</span>  args   <span class="token punctuation">[</span>Ljava/lang/String<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
SourceFile: <span class="token string">"HelloWorld.java"</span>
</code></pre> 
<p><font color="red"><strong>还有一个非常重要的字符串常量池，趁热打铁直接移步到 2.5.5 b 去看！</strong></font></p> 
<h3><a id="font_colororage2022823_font_214"></a><font color="orage">各种池总结（2022年8月23日 ）</font></h3> 
<p>方法区和常量池对比</p> 
<p>方法区：方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量（const）、静态变量（static）、即时编译器编译后的代码等数据，方法编译出的字节码就是保存在这个区域。</p> 
<p>常量池：是方法区的一部分，虚拟机指令通过这张常量表找到要执行的类名，方法名</p> 
<p>常量池分2种：静态常量池，运行时常量池，常量池在方法区中。</p> 
<p>还有一种池叫字符串池，以及各种包装类型（Integer）的缓冲池。<br> 字符串池1.8在堆中，1.8之前在方法区里。</p> 
<p><strong>最终总结：字符串池在堆中，常量池在方法区中。方法区占用操作系统内存，不占用堆内存。（1.8）</strong></p> 
<p>在Java1.6里面 ，方法区在堆上，占用堆内存，称为<strong>永久代</strong>，1.8中 方法区占用操作系统内存，不占用堆内存。</p> 
<h3><a id="255StringTable__231"></a>2.5.5（非常重要：StringTable 意为字符串常量池）</h3> 
<h4><a id="a_StringTable_233"></a>a. 引入：一个StringTable的面试题</h4> 
<p><img src="https://images2.imgbox.com/0a/7c/6SD5232E_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="b__236"></a>b. 常量池和串池（字符串常量池）的关系</h4> 
<p><img src="https://images2.imgbox.com/f0/7a/BfA0jx9n_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/1f/79/VuKhWE4C_o.png" alt="在这里插入图片描述"></p> 
<p><strong>HashSet 和 HashTable的概念！！！</strong></p> 
<h4><a id="cStringBuildernew_246"></a>c.字符串变量拼接的实质（StringBuilder+new）</h4> 
<p><strong>字符串变量拼接的实质如下图所示：</strong><br> <img src="https://images2.imgbox.com/c8/1d/igtTLzh5_o.png" alt="在这里插入图片描述"><br> 通过上面可知，s1 s2 s3不是new出来的，而s4是new出来的。那么这两种创建字符串的方式有什么区别吗？</p> 
<p>建议必须通读这个博客，便于理解：<br> <strong>https://blog.csdn.net/weixin_41098980/article/details/80060200</strong><br> <img src="https://images2.imgbox.com/89/b7/sigAIsil_o.png" alt="在这里插入图片描述"><br> 简单说来，String str = “abc” 这种方式，只会在字符串常量池里面添加一个"abc"的串；如果下次再声明String str1 = “abc”，那么str和str1的内存地址是一样的（因为字符串常量池已经有abc了，不会重复申请。这就是字符串常量池的作用节省空间）</p> 
<p><strong>但是使用new String 创建字符串就不同了：</strong><br> String str = new String(“abc”);至少会创建一个对象，也有可能创建两个。因为用到new关键字，肯定会在堆中创建一个String对象，如果字符池中已经存在”abc”,则不会在字符串池中添加一个"abc"的串，如果不存在，则会在字符串常量池中也添加一个"abc"的串。</p> 
<p><strong>因此，尽量少用new创建字符串，节省堆内存</strong></p> 
<h4><a id="d__264"></a>d. 字符串常量拼接的实质（编译期优化）</h4> 
<p><strong>这个例子和c例对比学习。</strong></p> 
<p>常量用+号拼接会怎样呢（c例是变量拼接）？</p> 
<p>如下图所示：</p> 
<p><img src="https://images2.imgbox.com/a1/79/Exhd5w3t_o.png" alt="在这里插入图片描述"></p> 
<p><strong>那最后还有一个问题，常量和变量用+拼接在一起呢？答案是当成变量处理（StringBuilder+new出来）！</strong></p> 
<h4><a id="f_StringTable_intern_18__16_278"></a>f. StringTable_intern_1.8 和 1.6</h4> 
<p><img src="https://images2.imgbox.com/27/2a/7ijsq9AU_o.png" alt="在这里插入图片描述"><br> <strong>先看1.8：</strong></p> 
<p>1.8情况1：</p> 
<p><img src="https://images2.imgbox.com/69/47/HUQYavIU_o.png" alt="8"></p> 
<p>1.8情况2：</p> 
<p><img src="https://images2.imgbox.com/86/2b/0yVqChvd_o.png" alt="在这里插入图片描述"></p> 
<p><strong>再看1.6：</strong></p> 
<p>1.6和 1.8的区别就是下面一点：</p> 
<p><img src="https://images2.imgbox.com/1a/f1/f7zWjeN5_o.png" alt="在这里插入图片描述"><br> 例子直接看g的面试题。</p> 
<h4><a id="g_StringTable_303"></a>g. StringTable面试题</h4> 
<p>再回到最开头的面试题（预测四个sout语句输出的是true还是false）：</p> 
<p><img src="https://images2.imgbox.com/65/ad/uN0cEXav_o.png" alt="在这里插入图片描述"><br> 答案是false true true false</p> 
<p>最后一问的调换位置版本：</p> 
<p><img src="https://images2.imgbox.com/a3/05/HpjEiE1u_o.png" alt="在这里插入图片描述"><br> <strong>最后一问调换位置的代码如上图所示，如果是1.8执行，就是true，如果是1.6执行，就是false。因为1.6是创建了个副本。</strong></p> 
<p><strong>看到这，应该非常轻松的做对了，如果你做不对，或者有疑惑，真该好好反思下了，因为都是学过的。</strong></p> 
<h4><a id="h_StringTable_317"></a>h. StringTable位置</h4> 
<p><strong>StringTable （字符串常量池）的位置：</strong><br> 1.8在堆里(常量池仍然在方法区(元空间)中)；<br> 1.6在方法区(永久代)中的常量池中。</p> 
<p>案例如下图所示：</p> 
<p><img src="https://images2.imgbox.com/92/35/zLFw3U4A_o.png" alt="在这里插入图片描述"></p> 
<p><strong>1.8将StringTable从方法区(也就是永久代)转移到了堆里，原因是：永久代垃圾回收效率特别低；而堆里垃圾回收效率会高。</strong></p> 
<p><font color="red"><strong>到现在为止了，堆，方法区，常量池，StringTable四者之间的关系已经可以总结出为一张图：</strong></font></p> 
<p><img src="https://images2.imgbox.com/87/aa/S7cRUQ0v_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="i_StringTable_333"></a>i. StringTable垃圾回收</h4> 
<p>见案例Demo1_7.java 如果堆内存满了就会触发回收机制，回收掉StringTable没用的字符串。</p> 
<h4><a id="j_StringTable_335"></a>j. StringTable调优</h4> 
<p><strong>调优案例1（调整虚拟机参数）：</strong></p> 
<p><strong>StringTable是类似于HashSet的数据结构（也有一说是其本质上就是一个<code>HashSet&lt;String&gt;</code>）</strong></p> 
<p>因此对其进行调优，可以通过调整虚拟机参数-XX:StringTableSize=桶个数。<br> 举例：如果你的程序有10w个字符串要入池，你将你的虚拟机参数调整成：-XX:StringTableSize=1009；那么平均每个桶里面就要进100个串，这样容易引发哈希碰撞，入桶时间会很长。</p> 
<p>然而你将你虚拟机调整成：-XX:StringTableSize=10000,那么每个桶只会进10个串，不容易引起哈希冲突；加载速度就会变快很多。</p> 
<p><strong>调优案例2（尽量使用intern）：</strong></p> 
<p>美团要处理一大堆用户的address信息(30w条)，很多用户的address是重复的。之前每次都要创建对象或是在已有对象中追加，但是这样非常耗费堆内存。</p> 
<p>于是美团就一直调用<code>.intern</code>方法，如果遇到重复，就不会入串池，从而大大节省了内存空间。</p> 
<p><strong>如下两个图所示：</strong></p> 
<p><img src="https://images2.imgbox.com/6b/32/z0uW1Slr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a0/7b/cXhmirzX_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="26__360"></a>2.6 直接内存</h3> 
<h4><a id="_361"></a>直接内存的概念和定义</h4> 
<p>概念：直接内存属于操作系统的内存。它常用在NIO中。</p> 
<ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul> 
<p><font color="green"><strong>NIO的ByteBuffer开辟的内存空间就是来源于直接内存。学习这个的前置条件是了解NIO。如下图所示：</strong></font></p> 
<p><img src="https://images2.imgbox.com/fd/d3/aks2nEWU_o.png" alt="在这里插入图片描述"></p> 
<p><strong>补充：</strong> NIO的ByteBuffer有两个方法，<strong>其中allocateDirect分配的字节缓冲区用中文叫做直接缓冲区（DirectByteBuffer）</strong>，用allocate分配的ByteBuffer叫做堆字节缓冲区(HeapByteBuffer)。</p> 
<p><strong>读取文件时，传统IO的Buffer（byte[] buffer = new byte[1024]）性能是不如NIO的ByteBuffer的。下图是传统的Buffer（该buffer建立在堆中）：</strong></p> 
<p>通过下图可以看到，程序要想读取磁盘文件，先要经过系统缓冲区，<strong>然后经过Java堆内存上的缓冲区，才能读到数据。</strong> 有中间商赚差价，读取速度就慢了。</p> 
<p><img src="https://images2.imgbox.com/2a/f6/0PhNDYJS_o.png" alt="在这里插入图片描述"><br> 再看下面一张图，这是使用直接内存之后。Java程序可以直接操作直接内存，<strong>磁盘文件只需要放入直接内存的缓冲区中即可被Java程序读取到，所以这个直接内存可以大大加快IO效率。</strong>（本质上是加快了读buffer的效率）</p> 
<p><img src="https://images2.imgbox.com/de/fa/lTs7gS8h_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_384"></a>直接内存溢出、分配、释放</h4> 
<p>直接内存也会溢出。下面介绍<font color="red"><strong>操作系统（不是JVM，直接内存不受JVM管理）</strong></font>如何分配和释放直接内存。</p> 
<p><strong>分配和回收的原理：</strong></p> 
<ul><li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法。</li><li>ByteBuﬀer 的实现类内部，使用了 Cleaner （虚引用）来监测ByteBuﬀer 对象，<strong>一旦ByteBuﬀer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存。</strong></li></ul> 
<p><strong>只需要记住分配和回收的原理即可，并不需要程序猿真正调用。</strong></p> 
<p>这个Unsafe非常底层，如果想更深的了解，详见下图Demo：<br> <img src="https://images2.imgbox.com/8a/bb/mNnLfBPq_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="JVM_397"></a>JVM如何禁用显式垃圾回收，及其对直接内存的影响</h4> 
<p>在使用虚拟机参数时，有时候会加上下面的参数来禁用显式垃圾回收：</p> 
<p><code>-XX:+DisableExplicitGC </code></p> 
<p>Explicit adj.显式的，明晰的</p> 
<p><strong>如果这样设置的话，会导致我们自己写的代码（手动gc）：<code>System.gc();</code>无效</strong></p> 
<p><font color="green"><strong>看到这大家可能有一个疑问：直接内存是不受JVM管理的，你禁止垃圾回收与否与我直接内存有什么关系？！</strong></font></p> 
<p><font color="green">大家别忘了上文说的： <strong>NIO 的ByteBuffer 可以创建直接内存！<br><br> 一旦ByteBuﬀer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存。</strong> 所以GC可以释放掉直接内存。</font></p> 
<p>假如我们的虚拟机参数真的设置了<code>-XX:+DisableExplicitGC </code>，我们不能调用<code>System.gc();</code>回收掉NIO的 ByteBuffer了，但是仍然想释放掉直接内存，怎么办？？</p> 
<p><strong>答案是使用上文所说的Unsafe来手动回收直接内存，绕开JVM虚拟机的垃圾回收！</strong></p> 
<p><strong>其实，这个直接内存的内存地址，实际上是通过一个虚引用关联到Java虚拟机的。具体请看下文（页内跳转） <a href="#jump1" rel="nofollow">3.4 虚引用应用</a></strong></p> 
<p>关于直接内存，介绍到这就比较完善了！结合NIO，Buffer会更好的理解！</p> 
<h3><a id="_422"></a>内存泄露和内存溢出</h3> 
<p>前面说的都是内存溢出（OOM, 内存不够了）</p> 
<p><strong>而内存泄露的概念是：</strong></p> 
<ol><li></ol> 
<p>内存泄漏(memory leak) 是指程序在申请内存后,无法释放已申请的内存空间,一次内存泄漏似乎不会有大的影响,但内存泄漏堆积后的后果就是内存溢出。<br> 2.<br> 内存溢出(out of memory) 指程序申请内存时,没有足够的内存供申请者使用。</p> 
<p>内存泄漏是指对象实例在新建和使用完毕后，仍然被引用，没能被垃圾回收释放，一直积累，直到没有剩余内存可用。如果内存泄露，我们要找出泄露的对象是怎么被 GC ROOT 引用起<br> 来，然后通过引用链来具体分析泄露的原因。分析内存泄漏的工具有：Jprofiler，visualvm等。</p> 
<h2><a id="3_435"></a>3、垃圾回收</h2> 
<h3><a id="31__437"></a>3.1 垃圾回收概述</h3> 
<p>学这一章节，必须了解什么是引用，什么是对象。非常重要！</p> 
<h4><a id="font_colorredfont_440"></a><font color="red"><strong>引用和对象的区别</strong></font></h4> 
<p>看这一段代码：<code>User user = new User()</code></p> 
<p><strong>左边的user只是个引用变量(可以类比于C语言的指针变量)而已，它首先是一个变量，它在函数中被创建，所以存放在虚拟机的栈帧里。</strong></p> 
<p><strong>而右边的new User()是一个对象，是一块地址空间，它存放在堆中！</strong></p> 
<h3><a id="32__447"></a>3.2 判断垃圾</h3> 
<h4><a id="_449"></a>引用计数法：</h4> 
<p>引用计数法（Reference Counting）比较简单，对每一个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。<br> 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象的引用计数器的值为0，即表示对象A不能在被使用，可进行回收。</p> 
<p>缺点：循环引用问题，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/ef/48/fHL9Nn1W_o.png" alt="在这里插入图片描述"><br> 但是在这种情况下，即使已经没有对象引用A和B了，仍然不能将其回收。<strong>这就是循环引用的问题，这是一条致命缺陷，导致现在已经不用引用计数法了。</strong></p> 
<h4><a id="_459"></a>可达性分析算法：</h4> 
<p>概念：<br> <img src="https://images2.imgbox.com/53/a3/WuZaGg0q_o.png" alt="在这里插入图片描述"><br> 使用Eclipse提供的一个工具，可以看到<strong>到底哪些对象可以作为GC Root对象（工具是什么不重要，怎么使用也不重要，以下内容才是重点）：</strong></p> 
<ul><li> <p>第一类<br> 最核心的类，比如Object，String，HashMap这种，不会被回收。<br> <img src="https://images2.imgbox.com/ef/58/4y4JR8RT_o.png" alt="在这里插入图片描述"></p> </li><li> <p>第二类<br> <img src="https://images2.imgbox.com/b7/0f/JtfcuSFa_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>第三类（特别重要！）</strong><br> <font color="green"><strong>活动线程中，局部变量(引用)所引用的对象，是可以作为Root对象的。</strong></font><br> <font color="green"><strong>活动线程中，局部变量(引用)所引用的对象，是可以作为Root对象的。</strong></font><br> <font color="green"><strong>活动线程中，局部变量(引用)所引用的对象，是可以作为Root对象的。</strong></font><br> <font color="green"><strong>这句话一定要理解，太重要了。如果理解不了这句话，看下文的[引用和对象的区别]，然后回来理解这句话。</strong></font><br> <strong>这句话的潜台词其实就是，如果没有局部变量引用这块存放在堆中的地址空间(也就是对象)了，那它就不是根对象了</strong><br> 看下图：<br> <img src="https://images2.imgbox.com/5d/5b/rT7RCRLA_o.png" alt="在这里插入图片描述"><br> <strong>上图提到了每个线程都有自己独立的栈，这个概念可以看我之前写的文章：</strong></p> </li></ul> 
<p><img src="https://images2.imgbox.com/f4/6a/BU5QUQbq_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/74/a6/GvaPuGXl_o.png" alt="在这里插入图片描述"></p> 
<ul><li>第四类：<br> <img src="https://images2.imgbox.com/21/74/fXxYYL8t_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="font_colorredfont_492"></a><font color="red"><strong>引用和对象的区别</strong></font></h4> 
<p>看这一段代码：<code>User user = new User()</code></p> 
<p><strong>左边的user只是个引用变量(可以类比于C语言的指针变量)而已，它首先是一个变量，它在函数中被创建，所以存放在虚拟机的栈帧里。</strong></p> 
<p><strong>而右边的new User()是一个对象，是一块地址空间，它存放在堆中！</strong></p> 
<h3><a id="33__500"></a>3.3 五种引用：强软弱虚终</h3> 
<p><strong>概念如图所示：</strong><br> <img src="https://images2.imgbox.com/28/3d/HBn8vVMP_o.png" alt="在这里插入图片描述"></p> 
<p><strong><font color="green">对上图概念的补充说明：</font></strong></p> 
<ul><li>举例：<code>User user = new User()</code>。这就是一个强引用，强引用只要在GC Root引用链上就不会被回收。</li><li>软引用和弱引用的区别：<strong>被弱引用引用的对象</strong>只要垃圾回收了就会被回收，<strong>被软引用引用的对象</strong>只有在垃圾回收后，内存仍然不足，才会被干掉。</li><li>引用队列的概念：弱引用和软引用自身也是需要占用内存空间的，如果被弱引用/软引用引用的对象已被回收，那么软引用和弱引用自身，会进入引用队列。</li><li>虚引用和终结器引用必须配合引用队列使用：当虚引用和终结器引用创建时，它们会关联一个引用队列。</li></ul> 
<h3><a id="34__512"></a>3.4 虚引用介绍</h3> 
<p><span id="jump1"></span><br> <strong>虚引用应用于前面讲的直接内存，如下图所示：</strong></p> 
<p><img src="https://images2.imgbox.com/df/00/6G389Tun_o.png" alt="在这里插入图片描述"></p> 
<p>创建ByteBuffer并使用allocateDirect开辟直接内存时，除了创建ByteBuffer对象会建立一个强引用之外，<strong>还会将直接内存地址传递给虚引用对象。</strong></p> 
<p>如果日后ByteBuffer这个强引用对象被垃圾回收了，但是那个直接内存空间并不能被Java的垃圾回收回收掉。虚拟机是如何回收直接内存地址的呢？</p> 
<p>答案是在ByteBuffer被回收的时候，让虚引用对象进入引用队列。而虚引用所在的引用队列，<strong>会由一个叫<code>ReferenceHandler</code>的线程来定期回收该对象，</strong> 该线程回收的时候，其实就是调用前面说过的<code>Unsafe.freeMemory()</code>来回收掉这个直接内存。</p> 
<p><strong>总之，虚引用和终结器引用必须配合引用队列使用：当虚引用和终结器引用创建时，它们会关联一个引用队列。</strong></p> 
<h3><a id="35__528"></a>3.5 终结器引用介绍</h3> 
<p>所有的Java对象都会继承Object类。而Object父类里面会有一个finallize()的方法（终结方法）。</p> 
<p><strong>它的作用类似于C++的析构函数。</strong></p> 
<p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再 <strong>由一个叫<code>FinallizeHandler</code>的线程，</strong> 通过终结器引用找到被引用对象并调用它的 ﬁnalize方法，第二次 GC 时才能回收被引用对象</p> 
<p>终结器引用回收效率很低，使用finallize方法，终结器引用释放资源效率很低，不推荐！</p> 
<h3><a id="35__541"></a>3.5 软引用介绍</h3> 
<p>和上面的虚引用应用场景一样，也是内存空间的开辟。</p> 
<p><strong>看下面的例子，下图为使用强引用开辟内存空间，会报错。</strong></p> 
<p><img src="https://images2.imgbox.com/d6/26/WpsuhQdj_o.png" alt="在这里插入图片描述"><br> 上图的场景比较常见，比如读取网络上的图片，然后将这些图片资源暂存到业务层进行进一步的处理。当读取图片很多的时候，就会导致堆内存溢出。即使这些图片资源并不在核心业务逻辑里。</p> 
<p>像这种非核心业务，我们能不能想个办法在内存紧张时直接释放掉，日后如果想用，再重新读取就好了（类似于狗熊掰棒子，掰一个掉一个）</p> 
<p><strong>这种场景可以用软引用和弱引用实现。下图为软引用案例（用一个软引用对象<code>new SoftReference&lt;byte[]&gt;</code><br> ）</strong></p> 
<p><img src="https://images2.imgbox.com/92/3b/DJwv8Omd_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/74/45/zp3Qt3uy_o.png" alt="在这里插入图片描述"><br> <strong>为什么只有最后一个留下来呢？因为申请到最后一个的时候，内存满了，于是触发了一次垃圾回收。导致前面几个都被回收掉了（潜台词是：如果内存没满，那么前几个就不会被回收）</strong></p> 
<p><font color="orange"> <strong>将软引用本身从引用队列中清除</strong> </font><br> 软引用自身也是一个引用。当软引用自身关联的那块内存空间被GC掉之后，那么软引用自身也应该被回收。（这有点像指向指针的指针）</p> 
<p><strong>如何清除软引用本身呢？答案是配合引用队列。见下图（可以对比上面刚写的没回收软引用本身的例子学习）：</strong></p> 
<p><img src="https://images2.imgbox.com/09/55/PfnhdMVB_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/6e/98/rYm1GqLe_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="36__572"></a>3.6 弱引用介绍</h3> 
<p><strong>弱引用是更弱的软引用。</strong> 和软引用场景类似，只不过换成了<code>new WeakReference</code>这个对象。</p> 
<blockquote> 
 <p>但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。<br> 弱引用需要用<br> java.lang.ref.WeakReference类来实现，它比软引用的生存期更短。<br> 对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，都会回收该对象占用的内存。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/5f/f7/olrZDDSN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_584"></a>软引用和弱引用的实际应用场景：</h3> 
<p>https://blog.csdn.net/arui319/article/details/8489451</p> 
<h3><a id="37__587"></a>3.7 回收算法（这实际上就是操作系统的知识点）</h3> 
<h4><a id="a_588"></a>a.标记清除</h4> 
<p>优点：速度较快</p> 
<p>缺点：会产生内存碎片</p> 
<p>如下图所示：<br> <img src="https://images2.imgbox.com/5e/7e/W76As9SP_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="b_599"></a>b.标记整理</h4> 
<p>为了解决碎片问题，实际上就是整理了一下（也是操作系统的概念），几个小块内存合成了一个大块内存。</p> 
<p>缺点就是速度慢了。</p> 
<p><img src="https://images2.imgbox.com/5c/cc/bWnEtKJt_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="c_608"></a>c.复制</h4> 
<p>第一步：将From能被内存找到的对象复制到另一块内存空间中：<br> <img src="https://images2.imgbox.com/8e/f2/VKJghPzG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/16/f8/0MGlrfCg_o.png" alt="在这里插入图片描述"><br> 复制好之后，就可以将原来的内存空间（From区）整个删光！</p> 
<p>最后交换From区和To区的位置 <strong>（交换指针的方式。下文会讲到）</strong> ：</p> 
<p><img src="https://images2.imgbox.com/57/c0/KFYW28dJ_o.png" alt="在这里插入图片描述"></p> 
<p><strong>这样就解决了内存碎片。它的缺点显而易见：需要占用双倍的内存空间（T<br> o空间）。</strong></p> 
<h3><a id="38__624"></a>3.8 分代回收</h3> 
<p><strong>上面的垃圾回收算法，JVM都有采用。分代回收机制就是综合采用上面算法的一种回收体系。JVM会针对不同的区域（新生代，老年代）采用不同的垃圾回收算法。</strong></p> 
<p>新生代存放的是相对来讲不重要的对象（有的甚至用过即失），老年代存放的是相对重要（不易回收）的内存空间。</p> 
<h4><a id="aMinor_GC_630"></a>a.Minor GC，以及晋升到老年代</h4> 
<p><img src="https://images2.imgbox.com/0b/08/xuG8EcJ1_o.png" alt="在这里插入图片描述"><br> 下一步：</p> 
<p><img src="https://images2.imgbox.com/ef/2f/YEVndJ6y_o.png" alt="在这里插入图片描述"><br> 经过这通操作，伊甸园空了。就可以继续入对象，直到第二次将伊甸园占满。触发第二次GC。<strong>第二次GC的不同之处会在检查伊甸园区的同时，检查 幸存区From。（此时幸存区From里面的所有对象寿命至少是1了），然后尝试标记幸存区From、伊甸园没被root引用到的对象。</strong></p> 
<p>然后就是重复之前的步骤，将未被标记的移动到To区域 -&gt; 删光伊甸园 -&gt; To和From互换位置 -&gt; From区对象寿命+1</p> 
<p>由于是第二次GC，有些From区对象寿命就有可能是2。<strong>以此类推经过几次迭代，From区的老不死对象寿命就会越来越长。</strong></p> 
<p>幸存区From的寿命达到一定大小时（比如15），<strong>这个老不死的对象就别在新生代的From区呆着了，直接晋升到老年代！</strong></p> 
<p><strong>老不死的对象被证明了它的价值比较高，于是它晋升到了老年代，老年代的垃圾回收频率比较低，不会频繁回收。</strong></p> 
<h4><a id="bFull_GC_646"></a>b.Full GC</h4> 
<p><strong>但是随着我们一次次的调用，老年代的对象终将被占满。此时会先尝试Minor GC，如果之后空间仍然不足，就会触发 Full GC。</strong></p> 
<p>Full GC 会对整个新生代，老年代的所有对象进行一次清理。</p> 
<p><strong>老年代用的就不是复制算法了，是标记清除+标记整理。</strong></p> 
<p><font color="red"><strong>如果老年代回收了空间仍然不足，就会OOM —— OutOfMemoryError</strong> </font></p> 
<h4><a id="_656"></a>总结</h4> 
<p>对下图概念的解释：</p> 
<ul><li>stop the world ： 字面意义，时间静止。当minor gc发生时，只有minor gc会运行，它工作的过程时，其他所有用户的所有线程都必须暂停。等待minor gc工作完，它们才能恢复运行。</li><li>STW 就是stop the world<br> <img src="https://images2.imgbox.com/8f/b3/plLajehO_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="39_GCGC_663"></a>3.9 GC相关参数，看懂GC日志</h3> 
<p><img src="https://images2.imgbox.com/10/2a/tpd6d14c_o.png" alt="在这里插入图片描述"><br> <strong>看懂GC日志（使用命令<code>-XX:+PrintGCDetails</code>打印GC详情）（下图相当重要！！！）：</strong></p> 
<p><img src="https://images2.imgbox.com/e9/76/6CM2uAVd_o.png" alt="在这里插入图片描述"><br> 关于上图的补充说明：幸存区from为啥占用了50% 因为触发普通Minor GC之后，From区域和to区域交换（新生代Minor GC用的就是复制算法）。本来这50%应该放在to区的。</p> 
<p><strong>tenured： 老年代。当伊甸园和From区，to区域实在是放不下了，就算执行了MinorGC，也放不下这块大对象，那么就不会管这个寿命的限制了，大对象直接晋升到老年代。</strong></p> 
<h4><a id="_672"></a>大对象直接晋升老年代策略</h4> 
<p><strong>大对象直接晋升看下例：</strong><br> <img src="https://images2.imgbox.com/6a/45/Yow4Q0Nl_o.png" alt="在这里插入图片描述"></p> 
<p><strong>如果老年代和新生代都塞不下了，那么就会直接触发OOM！（见下图）：</strong></p> 
<p><img src="https://images2.imgbox.com/0f/1b/U6Urc85Z_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="OOM_682"></a>关于OOM的问题</h3> 
<p><strong>问题：一个进程有3个线程，如果一个线程抛出oom，其他两个线程还能运行么?</strong></p> 
<p>这个题非常容易出错。按照常理，堆空间是线程共享的，一个线程OOM了，其它所有线程应该都抛出OOM才对。但是事实上其它线程会活的好好的。</p> 
<p><strong>原因：当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行</strong></p> 
<p><strong>问题2：主线程抛出异常挂掉了，子线程会活着吗？</strong></p> 
<p>答案：仍然会活着！主线程正常执行完毕，或者主线程挂了，<strong>只要子线程不是<code>守护线程</code>，都会活的好好的。</strong></p> 
<h3><a id="310__696"></a>3.10 垃圾回收器</h3> 
<p><strong>概述：三类垃圾回收器：</strong></p> 
<p><img src="https://images2.imgbox.com/78/56/HeM5SVA5_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="font_colorredSerial_Parallel_Concurrencyfont_702"></a><font color="red"><strong>补充：串行（Serial） 并行（Parallel） 并发（Concurrency）的概念：</strong></font></h3> 
<ul><li> <p>串行（Serial），就是串行化嘛，很好理解。单核情况下大家以葫芦娃救爷爷的方式一个一个上。</p> </li><li> <p>并发（Concurrency），是串行化的升级，在单核情况下，有一堆线程可以争抢时间片。<strong>虽然同一时刻上仍旧是只有一个线程在执行，但是由于CPU处理速度特别快，我们看起来好像是一个核心同时处理了多个任务似的。</strong> 当然你多核的情况下也可以这么做，让每个核都并发。</p> </li><li> <p>并行（Parallel），侧重描述的是多核的概念。由于有了多核，线程运行在每个单独的核既可以独占式，也可以抢占式（并发争抢时间片）。不管是独占式还是抢占式，由于是多核的缘故，任务在我们看来是并行执行的。</p> </li><li> <p><font color="green"><strong>所以我们说：并发在单核状态下不一定满足并行的概念。在微观上看来，并发仍然是串行的。只不过CPU执行的速度简直太快了，在宏观上看，并发就如同并行一般！</strong></font></p> </li></ul> 
<p><strong>所以我认为：并发和并行更多的是表述侧重点的不同，并发和并行其实都可以用来指代：<code>在同一时刻，可以执行多个任务。</code>但是如果硬要单独把并发和并行拎出来说，就要从CPU核心数来入手了。并行（多核）的概念更大一些。并发（单核）只能让自己在宏观上让自己看起来像并行而已。</strong></p> 
<h4><a id="a__713"></a>a. <strong>【串行】串行垃圾回收器：</strong></h4> 
<p>根据上面串行的描述，它适用于单核机器（配置较低的机器首选）。</p> 
<p>下图虽然有多个核，但是垃圾回收的时候，其他核上面的线程也阻塞了。这本质上就是个串行的，核再多也没用！！</p> 
<p><strong>当垃圾回收线程运行时，会触发STW.</strong></p> 
<p><img src="https://images2.imgbox.com/90/4e/QmSNhzcs_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="b_ParallelGC18JDK_723"></a>b. 【并行】<strong>（ParallelGC）吞吐量优先：1.8下JDK默认方式！</strong></h4> 
<p>Parallel 并行的；Concurrency 并发的。看名字 UseParallelGC，它是一个并行的垃圾回收器。<strong>它的确是并行的。而下面介绍的响应时间优先的垃圾回收器就是并发的。</strong></p> 
<p><strong>参数设置：</strong></p> 
<ul><li> <p><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC</code><br><br> 这两个开关代表使用吞吐量优先的垃圾回收机制。JDK1.8默认打开这两个选项。这两个开关左边是开启新生代右边是开启老年代，开启一个另一个也开启</p> </li><li> <p><code>-XX:+UseAdaptiveSizePolicy</code><br> 自适应调整新生代区域大小和各部分(伊甸园、晋升阈值等)比例。</p> </li><li> <p><code>-XX:GCTimeRatio=ratio</code><br> 调整垃圾回收时间和总时间的占比。公式：1/(1+ratio)<br> 如果你的ratio设为99，那么根据公式可知：程序运行了100min，垃圾回收的时间是1min。ratio默认就是99，程序猿一般可以将其设为19。</p> </li><li> <p><code>-XX:MaxGCPauseMillis=ms</code><br> 执行垃圾回收线程时，最大暂停毫秒数。默认是200ms</p> </li></ul> 
<p><strong>第三行和第四行的指标是矛盾的。一个是比率，一个是写死的，是个对立指标。必须根据实际应用选取之。</strong></p> 
<ul><li><code>-XX:ParallelGCThreads=n</code><br> 修改垃圾回收并行线程数。垃圾回收器会开启多个垃圾回收线程一拥而上。垃圾回收线程的个数默认情况下与你的CPU核数相关。如果你想控制数目，请修改n。</li></ul> 
<p>过程如下图所示：比起前面说的串行垃圾回收器，其最大区别是当线程运行到安全点时，会STW，<strong>只不过这个STW会执行一大堆垃圾回收线程。在执行垃圾回收的过程中，CPU会急剧飙升到100% 。这就是它的特点。</strong><br> <img src="https://images2.imgbox.com/bc/77/I21Hun5c_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="c_CMS_750"></a>c. 【并发】响应时间优先（CMS）</h4> 
<p>Parallel 并行的；Concurrency 并发的。区别于上面的吞吐量优先（并行垃圾回收），它是并发的。</p> 
<p><strong>参数说明：</strong></p> 
<ul><li> <p><code>-XX:+UseConcMarkSweepGC</code><br> Conc是Concurrent缩写，Mark 标记，Sweep清除。看名字，它是一款<strong>基于标记清除算法且并发</strong>的垃圾回收器，<strong>且它工作在老年代。</strong><br> 由于是标记清除算法，会产生比较多的内存碎片。这样会导致并发失败。<strong>这时候就会使ConcMarkSweepGC退化成上文介绍过的串行垃圾回收器（<code>SerialOld</code>），这个SerialOld是基于标记整理算法的。串行化的同时帮你整理一下内存碎片。</strong><br><br> <strong>垃圾产生太快，并行标记和复制速度跟不上线程产生垃圾的速度就会退化，并触发<code>Full GC</code>。<br> 关于这一点，下文在FullGC时还会讲到。退化成串行化垃圾回收器实质上就会触发<code>Full GC</code>。</strong></p> </li><li> <p>与上面的ConcMarkSweepGC配合的一个垃圾回收器是：<code>XX:+UseParNewGC</code>,它工作在<strong>新生代</strong>，基于复制算法。它们是成对出现的</p> </li><li> <p><code>-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads</code><br>并发时的线程数，受到这两个参数的影响。第一个参数<code>-XX:ParallelGCThreads=n</code>和之前介绍过的 吞吐量优先的参数完全一样。去上面重新看一遍定义即可。<br>而同一个CPU中并发的GC线程数设置就不一样了，<code>-XX:ConcGCThreads=threads</code>建议设置的线程数是<code>-XX:ParallelGCThreads=n</code>（也就是核数）的四分之一。<br><br> <strong>这一对概念比较难懂。实际只需要记住：第一个参数设置时，设置你的核数。第二个参数设置时，设置为第一个参数的四分之一。</strong><br> <strong>该算法工作流程如下图所示，其比较复杂。</strong><br> 并发的解释：如下图所示：在某些时机，不用STW。但是有些时机必须STW<br> <img src="https://images2.imgbox.com/96/88/B0NMHcJF_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<p><strong>根据上图补充说明几个参数：</strong></p> 
<p>而且它由于清理时是不发生STW的，所以在并发清理阶段，它可能会产生浮动垃圾（在垃圾回收时会产生新的垃圾），浮动垃圾只有在下一次GC时才可以清除。也就是它清不干净。</p> 
<p>这样会带来一个问题：它不能像之前的垃圾回收算法等到内存不足了再触发GC，它必须预留一个空间来保留浮动垃圾（浮动垃圾是上次的垃圾，会影响这次的GC标记）。</p> 
<p>为了解决这个问题，可以使用下面的参数：</p> 
<ul><li><code>-XX:CMSInitiatingOccupancyFraction=percent</code><br>percent的意思是内存占比，假如你的percent设为80，<strong>那么你的老年代空间不用等到全部占满了才触发GC，老年代空间占到了80%你就可以触发GC了</strong>（因为有一些浮动垃圾，留这20%空间是给浮动垃圾的。）</li></ul> 
<p>在早期的JVM，percent设置的值是65%左右。</p> 
<ul><li> <p>还有一个参数：<code> -XX:+CMSScavengeBeforeRemark</code><br><br> 它应用的场景是：在上图的重新标记阶段（第三次标记），有可能新生代对象会引用老年代的对象。<br> 作用是：这个选项如果打开，就会在重新标记之前，对新生代对象进行一次MinorGC，这样就不用重新标记新生代对象了，只用标记老年代对象。减轻了重新标记阶段的压力。</p> <p><font color="orange"><strong>该参数会在 GC 调优案例中重点说明，这个概念比较重要！！ (<a href="#jump3" rel="nofollow">点击页内跳转到 GC 调优案例</a>)</strong> </font></p> </li></ul> 
<p><strong>与吞吐量优先的比较，以及优缺点：</strong></p> 
<p>该算法工作时，垃圾回收时CPU占用率不高，但是由于垃圾回收线程和用户线程大多数时间是共存的（是因为不STW）。所以用户线程在大多数情况下是受影响的。<strong>相比吞吐量优先的垃圾回收器，它牺牲了程序在绝大多数情况下的吞吐量，但是换取的是响应更加及时。</strong></p> 
<p>前面还说过,响应时间优先的垃圾回收器对老年代进行清除时，会由于磁盘碎片的产生退化成串行垃圾回收器。一旦发生了退化，对CPU的消耗是比较大的。这也是ConcMarkSweepGC的一个缺点</p> 
<h3><a id="311_G1Garbage_First_797"></a>3.11 G1(Garbage First)工作流程</h3> 
<h4><a id="_798"></a><strong>概述：</strong></h4> 
<p><img src="https://images2.imgbox.com/f9/b5/xMIIluMV_o.png" alt="在这里插入图片描述"><br> 它借鉴了吞吐量优先，和CMS（响应时间优先）这两种垃圾回收器，同时注重吞吐量和低延迟。</p> 
<p>它对超大堆内存的支持比CMS做的要好。</p> 
<p>它是并发的垃圾回收器。</p> 
<p><strong>工作流程：</strong></p> 
<p><img src="https://images2.imgbox.com/ed/7a/YTMmVJLA_o.png" alt="在这里插入图片描述"><br> 如上图所示三部曲：</p> 
<ul><li>第一步（上图中的绿色三角）：先进行一次新生代的垃圾回收。</li><li>第2步（上图中的蓝色三角）：进行一次新生代垃圾回收+并发标记。</li><li>第3步（上图的橘色三角）：进行一次混合回收阶段</li></ul> 
<h4><a id="a_STW_818"></a>a. 新生代的垃圾回收（会STW）</h4> 
<p><strong>新生代垃圾回收第一步：</strong> 如下图所示，三个E为Eden space（伊甸园区）已满</p> 
<p><img src="https://images2.imgbox.com/81/bc/LlUhZ161_o.png" alt="在这里插入图片描述"><br> <strong>新生代垃圾回收第二步：</strong> 新生代垃圾回收之后，将幸存对象用复制算法，复制到下图中的幸存区S（Survival）区，如下图所示：<br> <img src="https://images2.imgbox.com/c6/cc/6IVmSPp4_o.png" alt="在这里插入图片描述"></p> 
<p><strong>新生代垃圾回收第三步：</strong> 幸存区S过大后，又会触发一次新生代垃圾回收。在这次垃圾回收中，S区够了年龄（寿命）的，就会晋升到老年代O（Old）区，不够年龄的会复制到其它的S区域。<br> <img src="https://images2.imgbox.com/c3/f4/SjgvYue3_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="b_Young_Collection__ConcurrenMark_832"></a>b. <strong>新生代的垃圾回收和并发标记阶段（Young Collection + ConcurrenMark）：</strong></h4> 
<p><font color="red"><strong>该算法对新生代GC时，会STW，但是CM阶段（ConcurrentMark并发标记）阶段并不会STW。</strong> </font></p> 
<p>E：Eddn space;<br> S：Survival space；<br> O：Old space</p> 
<p><img src="https://images2.imgbox.com/73/22/xDMGKEvT_o.png" alt="在这里插入图片描述"></p> 
<p><strong>这里的老年代无用对象只是被并发标记了一次，并没有回收。而新生代会在这个阶段进行一次GC。</strong></p> 
<h4><a id="c_Mixed_CollectionSTW_844"></a>c. <strong>混合收集阶段（Mixed Collection），会STW</strong></h4> 
<p>它会对E、S、O区进行一次全面的垃圾回收：</p> 
<p><img src="https://images2.imgbox.com/c5/a4/7pAvo4aY_o.png" alt="在这里插入图片描述"></p> 
<p><strong>混合收集阶段首先会先执行一次新生代的垃圾回收（前面讲过）：</strong> 将E区回收，幸存对象到S区，如果S区域满了，够寿命的晋升到O区，不够寿命的复制到其它S区域。</p> 
<p><strong>然后执行一次Young Collection + ConcurrenMark阶段（就是上文的b）阶段：</strong> 在进行新生代垃圾回收的同时，标记老年代无用对象。</p> 
<p>最后对被标记的老年代无用对象<strong>进行一次最终标记和GC。</strong> 但是G1会根据你设置的参数：<code>-XX:MaxGCPauseMillis=ms （设置最大暂停时长）</code>来进行一次<strong>有选择的老年代垃圾回收</strong>。为什么呢？<strong>因为老年代垃圾回收太大，STW可能时间较长，这样就超过了刚刚设置的最大暂停时长了。</strong></p> 
<p><strong>为了要达到这个<code>-XX:MaxGCPauseMillis=ms （设置最大暂停时长）</code>的目标，G1会挑出回收价值较高的O区进行有选择的垃圾回收。</strong></p> 
<p><strong>进行完GC后，会执行拷贝存活（Evacuation）阶段，</strong> 将老年代幸存对象会被复制到新的老年代区域：O --&gt; O。如下图所示：<br> <img src="https://images2.imgbox.com/50/a0/8HQx2Ova_o.png" alt="在这里插入图片描述"></p> 
<p><strong>总之，最终标记阶段，和拷贝存活阶段，都会STW。</strong></p> 
<p><font color="orange"><strong>思考：最终标记阶段为什么要STW呢？</strong></font></p> 
<p><strong>G1在这方面的特点和CMS垃圾回收器一样：和前文讲的一样：因为会有并发标记阶段，并发标记不产生STW，用户的线程和标记线程会并发运行，所以会产生浮动垃圾，（在垃圾标记回收时会产生新的垃圾），浮动垃圾只有在下一次GC时才可以清除。</strong></p> 
<p>CMS对此的解决方案是设置参数：</p> 
<p><img src="https://images2.imgbox.com/77/20/3up7zawt_o.png" alt="在这里插入图片描述"></p> 
<p><font color="orange"><strong>而G1的解决方案，就是在最终标记阶段进行一次STW，标记掉那些浮动垃圾, 然后再进行回收，已确保清除干净</strong></font></p> 
<h3><a id="Full_GC_878"></a>总结：Full GC</h3> 
<p>前面学了四种垃圾回收算法，它们对老年代内存不足的处理是不一样的，Full GC的触发也是不同的。</p> 
<p><img src="https://images2.imgbox.com/4d/8f/4qlaQQMA_o.png" alt="在这里插入图片描述"><br> <strong>总之，只要是基于并行标记和复制和回收的垃圾回收算法，老年代空间不足，都不会马上触发Full GC，而是只有在垃圾回收太快跟不上并行处理速度时，才会触发Full GC</strong></p> 
<p>那如何降低 Full GC 概率呢？ <a href="#jump2" rel="nofollow">请页内跳转 3.17</a></p> 
<ul><li>补充：关于 Major GC：<br> <img src="https://images2.imgbox.com/0b/a6/wJdE7OPd_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="312_G1_891"></a>3.12 G1新生代跨代引用问题（卡表机制）</h3> 
<p>先复习一下新生代垃圾回收的过程：先找到root对象，然后进行可达性分析，将存活对象复制到幸存区。</p> 
<p>有一些根对象是来自老年代的 <strong>（老年代引用新生代，跨代引用）</strong> 。老年代的对象太多了，所以在查找root对象时，遍历整个老年代对象查找效率非常低。因此，采用了卡表机制。</p> 
<ul><li><strong>CardTable（卡表）机制</strong></li></ul> 
<p>其实就是对老年代分区再次进行细分，分成一个一个的CardTable：</p> 
<p><img src="https://images2.imgbox.com/bf/db/3Zti2Fsi_o.png" alt="在这里插入图片描述"><br> 如果有一个card引用了新对象，就将其标注为脏card。如果下次进行root对象扫描的时候，不用扫描整个老年代分区，只需要扫描脏卡即可。</p> 
<p>新生代会由一个 <code>Remembered Set</code>区域，记录外部对我的引用。也就是说记录老年代引用我的区域（脏卡）。<strong>将来进行新生代垃圾回收时，先根据<code>Remembered Set</code>找到对应的脏卡，到脏卡中遍历找到 GC Root，再从root进行可达性分析，从而找到新生代的垃圾进行回收。</strong></p> 
<p><img src="https://images2.imgbox.com/33/4d/ET31COnc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="313_Remark_907"></a>3.13 Remark（标记）阶段，写屏障技术</h3> 
<p>这一章和 3.12的卡表机制联系紧密，视频里讲的不甚完善，可以自行百度。</p> 
<p>推荐一篇CSDN文章，讲得很好：</p> 
<p>https://blog.csdn.net/Yao_ziwei/article/details/117518283</p> 
<h3><a id="314_G1__915"></a>3.14 G1 字符串去重优化</h3> 
<p>这里和之前讲的 <code>intern()</code>方法（使用串池实现）不同：</p> 
<p><img src="https://images2.imgbox.com/5e/78/TlNxWdbE_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="315_G1__920"></a>3.15 G1 类卸载</h3> 
<p>有些类是由类加载器加载的（常用于框架），所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类和它们的实例都不再使用，则卸载它所加载的所有类。</p> 
<p>-XX:+ClassUnloadingWithConcurrentMark 默认启用</p> 
<p>而jdk自己的类加载器不会被卸载。只有自定义的类卸载器会被卸载。</p> 
<p>于 JDK 8u40 版本开始支持。</p> 
<h3><a id="316_JDK_8u60__930"></a>3.16 JDK 8u60 回收巨型对象</h3> 
<p>JDK 8u60 版本对回收巨型对象进行了优化。</p> 
<p>之前在介绍G1 分区的时候，除了 E、S、O 三个区域，还有巨型对象区域：</p> 
<p><img src="https://images2.imgbox.com/a9/a5/OwjgIK9A_o.png" alt="在这里插入图片描述"><br> 总之，其回收被优先考虑。它是在新生代垃圾回收时被处理掉的。</p> 
<h3><a id="317_JDK_9__939"></a>3.17 JDK 9 并发标记起始时间的调整</h3> 
<p><span id="jump2"></span></p> 
<p>先复习一下前面讲的Full GC：</p> 
<p><strong>当你垃圾回收速度跟不上你垃圾产生的速度，G1和CMS就会退化为Full GC。</strong></p> 
<p>所以可以提前让并发标记、复制和回收这个过程提前。这个过程提前开始了，则会降低Full GC的概率，至少是延缓Full GC的到来。</p> 
<p><strong>可以通过调整参数的方式实现：</strong></p> 
<p><img src="https://images2.imgbox.com/a8/9a/0a6eYbFP_o.png" alt="在这里插入图片描述"><br> JDK9进行了优化，设置初始值之后不用管，可以动态调整。</p> 
<p>JDK9对垃圾回收器进行了大规模增强，修复了无数bug。这里不展开讲了。</p> 
<h2><a id="4_955"></a>4、垃圾回收调优</h2> 
<h3><a id="41__957"></a>4.1 概述</h3> 
<ul><li>掌握 GC 相关的 VM 参数，会基本的空间调整</li><li>掌握相关工具</li><li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</li></ul> 
<p>根据你的优化目标（要低延迟还是要高吞吐量）来选择合适的垃圾回收器。</p> 
<h3><a id="42_GCJVM_966"></a>4.2 GC调优的思路（先找代码，后找JVM）</h3> 
<p><strong>经常Full GC，很有可能是你代码写的有问题，先别甩锅给JVM。先检查一下你的代码，看看以下四个场景，是否命中了？</strong></p> 
<p><strong>场景一：从SQL入手</strong><br> 假如你写这么一条：<code>select * from BigTable</code>这条语句。这条语句在MyBatis的结果集映射（ResultSet）中会将所有这个表的数据拿出来放到java内存中，这样内存必爆。</p> 
<p>解决方法就是不要 select * 。或者使用limit 关键字，减少查询数据量。</p> 
<p><strong>场景二：对象过大</strong><br> 一个实体类里面有很多字段，但是并不是所有字段都是我们需要的，我们可能只需要部分属性。我们可以只查部分属性，或者单独建立一个小的VO类，该VO类只包括部分字段用于展示。</p> 
<p><strong>场景三：包装类</strong><br> 能不使用包装类型就不使用，因为最小的包装类型 Integer 也要16个字节，而一个普通的int 只要4字节</p> 
<p><strong>场景四：使用软弱引用</strong><br> 比如buffer这种缓冲区，可以用软引用、弱引用等等。或者像这种缓冲区交给中间件来实现，比如Redis等等。</p> 
<p><strong>下面几个章节会介绍一下JVM层面的调优：</strong></p> 
<h3><a id="43_GC___986"></a>4.3 GC 调优 新生代</h3> 
<p>先来看新生代的几个特点：</p> 
<p><img src="https://images2.imgbox.com/da/a2/1Fpguzba_o.png" alt="在这里插入图片描述"><br> 由此可知，新生代的GC代价远远低于老年代，我们应该先从新生代入手。</p> 
<p><strong>新生代内存设置多大合适？（下面翻译自官网）</strong></p> 
<p><code>-Xmn</code></p> 
<p>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is<br> performed in this region more often than in other regions. If the size for the young generation is<br> too small, then a lot of minor garbage collections are performed. If the size is too large, then only<br> full garbage collections are performed, which can take a long time to complete. Oracle<br> recommends that you keep the size for the young generation greater than 25% and less than<br> 50% of the overall heap size.</p> 
<p><code>-Xmn</code>这个参数的意思是：设置新生代初始和最大大小。GC在这一个区域发生的更加频繁（相对于老年代）。</p> 
<p>如果新生代区域过小，则会执行很多次Minor GC，如果新生代内存过大，则只有Full GC才会发挥作用。<strong>因此Oracle建议您将新生代大小保持在总堆大小的25%以上，50%以下。</strong></p> 
<p><strong>因此合理的新生代配置如下图（幸存区也属于新生代）：</strong><br> <img src="https://images2.imgbox.com/74/35/vNciCZh4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="44_GC___1013"></a>4.4 GC 调优 老年代</h3> 
<p>先检查自己的代码问题，再尝试调优新生代，实在不行了再考虑调优老年代。理由在上文讲过。</p> 
<p>老年代调优方法在3.17讲过（如下图所示）：</p> 
<p><img src="https://images2.imgbox.com/2f/2f/BGiy23zH_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="45_GC___1021"></a>4.5 GC 调优 案例</h3> 
<ul><li> <p>案例1 Full GC 和 Minor GC频繁</p> <p>原因：新生代过小导致MinorGC频繁，新生代内存不足会使得一些对象未经晋升机制就直接跑到老年代（原因见前文：<code>大对象直接晋升老年代策略</code>），导致老年代内存不足引发Full GC</p> <p>解决方案：增大新生代内存。降低MinorGC概率，并且增大幸存区晋升阈值。避免过早晋升到老年代</p> </li></ul> 
<p><span id="jump3"></span></p> 
<ul><li> <p>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）</p> <p>原因分析：先根据GC日志定位到底是CMS哪个暂停时间特别长。如果定位到<strong>第三次暂停时间（重新标记时间）</strong> 特别长，<strong>那么解决方案其实之前讲CMS时就讲过了，增加参数即可</strong>：<br> <img src="https://images2.imgbox.com/95/29/wsZXCpe5_o.png" alt="在这里插入图片描述"></p> </li><li> <p>案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</p> <p>1.7的方法区叫永久代（占用堆内存，受垃圾回收管理），1.8以后的方法区叫元空间（占用操作系统内存空间，不受垃圾回收机制管理）</p> <p>虽然老年代充裕，但是也有可能是永久代内存不足导致的，解决方案就是增大永久代。</p> </li></ul> 
<h2><a id="5_1046"></a>5、类加载与字节码技术</h2> 
<h3><a id="51_javap_java_1047"></a>5.1 javap 工具反汇编，查看java汇编指令</h3> 
<p><strong>这里就不跟着黑马看了，直接去Oracle官方文档看：</strong></p> 
<p>https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javap.html</p> 
<p>下面给翻译一下：</p> 
<blockquote> 
 <p>The javap command disassembles one or more class files. The output depends on the options used. When no options are used, then the javap command prints the package, protected and public fields, and methods of the classes passed to it. The javap command prints its output to stdout.</p> 
</blockquote> 
<p>javap命令可以反汇编一个或多个class文件，输出取决于参数的选择。如果你不选择任何参数（比如<code>javap HelloWorld.class</code>），就会在控制台打印出包，protected方法和public方法，普通方法。</p> 
<p><strong>使用：</strong><br> javap [options] classfile…</p> 
<p><strong>它作用在一个.class 文件上。如果你用的是idea，你得去out文件夹下找到.class文件，并在这个目录下使用 javap命令</strong></p> 
<p>一般使用 <code>javap -v HelloWorld.class</code>这个命令，-v显示更多信息</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d1fe2c4db4faead123cb16d13868d4cb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">websocket的基础使用，心跳机制，断线重连</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0546da3ee44522abde54b3f2e9dff468/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mysql 数据备份（详细教程）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>