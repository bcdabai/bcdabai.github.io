<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python基础知识六 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python基础知识六" />
<meta property="og:description" content="博客园的博文对每篇博文的长度似乎做了限制
面向对象编程，
在程序何种，根据操作数据的函数或语句块来设计程序。这被成为面向过程的编程。还有一种把数据和功能结合起来，用称为对象的东西包裹起来组织组织程序的额方法。这种方法称为面向对象的编程理念。
类和对象是面向对象编程的两个主要方面。类创建一个新类型，而对象是这个类的实例。这类似于你有一个int的变量，这纯属整数的变量是int类的实例(对象)
对象可以使用普通的属于对象的变量存储数据。属于一个对象或累i的变量称为域。对象可以使用属于类的函数来具有功能。这样的函数被称为类的方法。这些属于帮助我们把它们与鼓励的函数和变量区分开来。域和方法可以合成为类的属性。
域有两种类型---属于每个实例/类的对象或属于类本身。它们分别被成为实例变量和类变量。
类使用class关键字创建。类的域和方法被列在一个缩进块中。
self
类的方法于普通的函数只有一个特别的区别---他们必须有一个额外的第一个参数名称，但是在调用这个方法的时候你不为这个参数赋值，python会提供这个值。这个特别的便利指对象本身，按照惯例它的名称是self.
虽然你可以给这个参数任何名称，但是强烈建议你使用self这个名称---其它名称都是不赞成使用的。使用一个标准的名称有很多优点-IDE和读者会容易识别
你一定很奇怪 python如何给self赋值以及为何你不需要给他赋值。举一个例子会使此变得清晰。假如你有一个类称为MyClass和这个类的一个实例MyObject。当你调用这个对象的方法MyObject.method（arg1,arg2）的时候，这会由python自动转化为MyClass.method(MyObject,arg1,arg2)--这就是self的原理了。
这也意味着如果你有一个不需要参数的方法，你还是得给这个方法定义一个self参数。
class Person:
pass
p=Person()
print p
输出：
$ python simplestclass.py
&lt;__main__.Person instance at 0xf6fcb18c&gt;
我们使用class语句后跟类名，创建了一个新的类。这后面跟着一个缩进的语句块形成类体。在这个例子中，我们使用了一个空白块，它由pass语句表示。
接下来，我们使用类名后跟一对圆括号来创建一个对象/实例。
为了验证，我们简单地打印了这个变量的类型，它告诉我们在__main__模块中有了一个Person类的实例。
可以注意到存储对象的计算机内存地址也打印了出来。这个地址在你的计算机上会是另外一个只，因为python可以在任何空位存储对象。
对象的方法
我们已经讨论了类/对象可以拥有像函数一样的方法，这些方法与函数的区别只是一个额外的sel变量。
class Person:
def sayHi(self):
print &#39;hello &#39;
p=Person()
p.sayHi()
输出：
$ python method.py
Hello, how are you?
这里我们看到了self的用法，注意sayHi方法没有任何参数，但仍然在函数定义时有self
__init__方法
在python的类中有很多方法的名字有特殊的重要意义。
__init__方法在类的一个对象被建立时，马上运行。这个方法可以用来对你的对象做一些你希望的初始化。注意，这个名称的开始和结尾都是双下划线。
class Person:
def sayHi(self):
print &#39;hello,my name is &#39;,self.name
def __init__(self,name):
self.name=name
p=Person(&#39;swaroop&#39;)
p.sayHi()
输出：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7e5da99cc45c03f025d4fef6a1aa44c2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-11-15T19:54:00+08:00" />
<meta property="article:modified_time" content="2015-11-15T19:54:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python基础知识六</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>博客园的博文对每篇博文的长度似乎做了限制</p> 
 <p>面向对象编程，</p> 
 <p>在程序何种，根据操作数据的函数或语句块来设计程序。这被成为面向过程的编程。还有一种把数据和功能结合起来，用称为对象的东西包裹起来组织组织程序的额方法。这种方法称为面向对象的编程理念。</p> 
 <p> </p> 
 <p><span lang="zh-cn">类和对象是面向对象编程的两个主要方面。类创建一个新类型，而对象是这个类的实例。这类似于你有一个<span lang="en-us">int<span lang="zh-cn">的变量，这纯属整数的变量是<span lang="en-us">int<span lang="zh-cn">类的实例<span lang="en-us">(<span lang="zh-cn">对象<span lang="en-us">)</span></span></span></span></span></span></span></span></p> 
 <p lang="en-us"> </p> 
 <p><span lang="zh-cn">对象可以使用普通的属于对象的变量存储数据。属于一个对象或累<span lang="en-us">i<span lang="zh-cn">的变量称为域。对象可以使用属于类的函数来具有功能。这样的函数被称为类的方法。这些属于帮助我们把它们与鼓励的函数和变量区分开来。域和方法可以合成为类的属性。</span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">域有两种类型<span lang="en-us">---<span lang="zh-cn">属于每个实例<span lang="en-us">/<span lang="zh-cn">类的对象或属于类本身。它们分别被成为实例变量和类变量。</span></span></span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">类使用<span lang="en-us">class<span lang="zh-cn">关键字创建。类的域和方法被列在一个缩进块中。</span></span></span></p> 
 <p> </p> 
 <p lang="en-us">self</p> 
 <p><span lang="zh-cn">类的方法于普通的函数只有一个特别的区别<span lang="en-us">---<span lang="zh-cn">他们必须有一个额外的第一个参数名称，但是在调用这个方法的时候你不为这个参数赋值，<span lang="en-us">python<span lang="zh-cn">会提供这个值。这个特别的便利指对象本身，按照惯例它的名称是<span lang="en-us">self.</span></span></span></span></span></span></p> 
 <p lang="en-us"> </p> 
 <p><span lang="zh-cn">虽然你可以给这个参数任何名称，但是强烈建议你使用<span lang="en-us">self<span lang="zh-cn">这个名称<span lang="en-us">---<span lang="zh-cn">其它名称都是不赞成使用的。使用一个标准的名称有很多优点<span lang="en-us">-IDE<span lang="zh-cn">和读者会容易识别</span></span></span></span></span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">你一定很奇怪<span lang="en-us"> python<span lang="zh-cn">如何给<span lang="en-us">sel<span lang="en-us">f<span lang="zh-cn">赋值以及为何你不需要给他赋值。举一个例子会使此变得清晰。假如你有一个类称为<span lang="en-us">MyClass<span lang="zh-cn">和这个类的一个实例<span lang="en-us">MyObject<span lang="zh-cn">。当你调用这个对象的方法<span lang="en-us">MyObject.method<span lang="zh-cn">（<span lang="en-us">arg1,arg2<span lang="zh-cn">）的时候，这会由<span lang="en-us">python<span lang="zh-cn">自动转化为<span lang="en-us">MyClass.method(MyObject,arg1,arg2)--<span lang="zh-cn">这就是<span lang="en-us">self<span lang="zh-cn">的原理了。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">这也意味着如果你有一个不需要参数的方法，你还是得给这个方法定义一个<span lang="en-us">self<span lang="zh-cn">参数。</span></span></span></p> 
 <p> </p> 
 <p>class Person:</p> 
 <p>pass</p> 
 <p>p=Person()</p> 
 <p>print p</p> 
 <p>输出：</p> 
 <p>$ python simplestclass.py</p> 
 <p>&lt;__main__.Person instance at 0xf6fcb18c&gt;</p> 
 <p> </p> 
 <p><span lang="zh-cn">我们使用<span lang="en-us">class<span lang="zh-cn">语句后跟类名，创建了一个新的类。这后面跟着一个缩进的语句块形成类体。在这个例子中，我们使用了一个空白块，它由<span lang="en-us">pass<span lang="zh-cn">语句表示。</span></span></span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">接下来，我们使用类名后跟一对圆括号来创建一个对象<span lang="en-us">/<span lang="zh-cn">实例。</span></span></span></p> 
 <p><span lang="zh-cn">为了验证，我们简单地打印了这个变量的类型，它告诉我们在<span lang="en-us">__main__<span lang="zh-cn">模块中有了一个<span lang="en-us">Per<span lang="en-us">son<span lang="zh-cn">类的实例。</span></span></span></span></span></span></p> 
 <p><span lang="zh-cn">可以注意到存储对象的计算机内存地址也打印了出来。这个地址在你的计算机上会是另外一个只，因为<span lang="en-us">python<span lang="zh-cn">可以在任何空位存储对象。</span></span></span></p> 
 <p> </p> 
 <p>对象的方法</p> 
 <p><span lang="zh-cn">我们已经讨论了类<span lang="en-us">/<span lang="zh-cn">对象可以拥有像函数一样的方法，这些方法与函数的区别只是一个额外的<span lang="en-us">sel<span lang="zh-cn">变量。</span></span></span></span></span></p> 
 <p>class Person:</p> 
 <p>def sayHi(self):</p> 
 <p>print 'hello '</p> 
 <p>p=Person()</p> 
 <p>p.sayHi()</p> 
 <p> </p> 
 <p>输出：</p> 
 <p>$ python method.py</p> 
 <p>Hello, how are you?</p> 
 <p><span lang="zh-cn">这里我们看到了<span lang="en-us">self<span lang="zh-cn">的用法，注意<span lang="en-us">say<span lang="en-us">Hi<span lang="zh-cn">方法没有任何参数，但仍然在函数定义时有<span lang="en-us">self</span></span></span></span></span></span></span></p> 
 <p> </p> 
 <p><span lang="en-us">__init__<span lang="zh-cn">方法</span></span></p> 
 <p><span lang="zh-cn">在<span lang="en-us">python<span lang="zh-cn">的类中有很多方法的名字有特殊的重要意义。</span></span></span></p> 
 <p><span lang="en-us">__init__<span lang="zh-cn">方法在类的一个对象被建立时，马上运行。这个方法可以用来对你的对象做一些你希望的初始化。注意，这个名称的开始和结尾都是双下划线。</span></span></p> 
 <p> </p> 
 <p>class Person:</p> 
 <p>def sayHi(self):</p> 
 <p>print 'hello,my name is ',self.name</p> 
 <p>def __init__(self,name):</p> 
 <p>self.name=name</p> 
 <p> </p> 
 <p>p=Person('swaroop')</p> 
 <p>p.sayHi()</p> 
 <p>输出：</p> 
 <p>$ python class_init.py</p> 
 <p>Hello, my name is Swaroop</p> 
 <p> </p> 
 <p><span lang="zh-cn">这里，我们把<span lang="en-us">__init__<span lang="zh-cn">方法定义为取一个参数<span lang="en-us">name<span lang="zh-cn">（以及普通的参数<span lang="en-us">self<span lang="zh-cn">）。在这个<span lang="en-us">__init__<span lang="zh-cn">里，我们只是创建一个新的域，也称为<span lang="en-us">name<span lang="en-us">.<span lang="zh-cn">注意它们是两个不同的变量，尽管它们有相同的名字。点号能够使我们区分它们。</span></span></span></span></span></span></span></span></span></span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">最重要的是，我们没有专门调用<span lang="en-us">__inti__<span lang="zh-cn">方法，只是在创建一个类的新实例的时候，把参数包括在圆括号内跟在类名后面，从而传递给<span lang="en-us">__init__<span lang="zh-cn">方法。</span></span></span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">其实<span lang="en-us">__init__<span lang="zh-cn">就是构造函数</span></span></span></p> 
 <p> </p> 
 <p>类与对象的方法</p> 
 <p>事实上，数据部分只是类和对象的名称空间绑定的普通变量，即这些名称只在这些类与对象的前提下有效。</p> 
 <p><span lang="zh-cn">有两种类型的域<span lang="en-us">--<span lang="zh-cn">类的变量和对象的变量，它们是根据是类还是对象拥有这个变量而区分。</span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">类的变量由一个类的所有对象<span lang="en-us">(<span lang="zh-cn">实例）共享使用。只有一个类变量的拷贝，所以当某个对象对类的变量做了改动的时候，这个改动会反映到所有其他的实例上。</span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">对象的变量由类的每个对象<span lang="en-us">/<span lang="zh-cn">实例拥有。因此每个对象有自己对这个域的一份拷贝，即它们不是共享的，在同一个类的不同实例中，虽然对象的变量有相同的名称，但是是互不相关的。</span></span></span></p> 
 <p> </p> 
 <p>class Person:</p> 
 <p>'''Represents a person.'''</p> 
 <p>population = 0</p> 
 <p> </p> 
 <p>def __init__(self, name):</p> 
 <p>'''Initializes the person's data.'''</p> 
 <p>self.name = name</p> 
 <p>print '(Initializing %s)' % self.name</p> 
 <p> </p> 
 <p># When this person is created, he/she</p> 
 <p># adds to the population</p> 
 <p>Person.population += 1</p> 
 <p> </p> 
 <p>def __del__(self):</p> 
 <p>'''I am dying.'''</p> 
 <p>print '%s says bye.' % self.name</p> 
 <p> </p> 
 <p>Person.population -= 1</p> 
 <p> </p> 
 <p>if Person.population == 0:</p> 
 <p>print 'I am the last one.'</p> 
 <p>else:</p> 
 <p>print 'There are still %d people left.' % Person.population</p> 
 <p> </p> 
 <p>def sayHi(self):</p> 
 <p>'''Greeting by the person.</p> 
 <p> </p> 
 <p>Really, that's all it does.'''</p> 
 <p>print 'Hi, my name is %s.' % self.name</p> 
 <p> </p> 
 <p>def howMany(self):</p> 
 <p>'''Prints the current population.'''</p> 
 <p>if Person.population == 1:</p> 
 <p>print 'I am the only person here.'</p> 
 <p>else:</p> 
 <p>print 'We have %d persons here.' % Person.population</p> 
 <p> </p> 
 <p>swaroop = Person('Swaroop')</p> 
 <p>swaroop.sayHi()</p> 
 <p>swaroop.howMany()</p> 
 <p> </p> 
 <p>kalam = Person('Abdul Kalam')</p> 
 <p>kalam.sayHi()</p> 
 <p>kalam.howMany()</p> 
 <p> </p> 
 <p>swaroop.sayHi()</p> 
 <p>swaroop.howMany()</p> 
 <p> </p> 
 <p>输出：</p> 
 <p>$ python objvar.py</p> 
 <p>(Initializing Swaroop)</p> 
 <p>Hi, my name is Swaroop.</p> 
 <p>I am the only person here.</p> 
 <p>(Initializing Abdul Kalam)</p> 
 <p>Hi, my name is Abdul Kalam.</p> 
 <p>We have 2 persons here.</p> 
 <p>Hi, my name is Swaroop.</p> 
 <p>We have 2 persons here.</p> 
 <p>Abdul Kalam says bye.</p> 
 <p>There are still 1 people left.</p> 
 <p>Swaroop says bye.</p> 
 <p>I am the last one.</p> 
 <p> </p> 
 <p><span lang="en-us">population<span lang="zh-cn">属于<span lang="en-us">Person<span lang="zh-cn">类，因此是一个类的变量。<span lang="en-us">name<span lang="zh-cn">变量属于对象<span lang="en-us">(<span lang="zh-cn">它使用<span lang="en-us">self<span lang="zh-cn">赋值<span lang="en-us">)<span lang="zh-cn">，因此是对象的变量</span></span></span></span></span></span></span></span></span></span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">观察可以发现<span lang="en-us">__init__<span lang="zh-cn">方法用一个名字来初始化<span lang="en-us">Per<span lang="en-us">son<span lang="zh-cn">实例。在这个方法中，我们让<span lang="en-us">population<span lang="zh-cn">增加<span lang="en-us">1<span lang="zh-cn">，这是因为我们增加了一个人。同样可以发现，<span lang="en-us">self.name<span lang="zh-cn">的值根据每个对象指定，这表明了它作为对象的变量的本质。</span></span></span></span></span></span></span></span></span></span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">记住，只能使用<span lang="en-us">self<span lang="zh-cn">变量来参考同一个对象的变量和方法，这被称为属性参考。</span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">在这个程序中，还用了<span lang="en-us">doc<span lang="en-us">string <span lang="zh-cn">对于类和方法同样有用。我们在运行时使用<span lang="en-us">Person.__doc__<span lang="zh-cn">和<span lang="en-us">Person.sayHi.</span></span></span></span></span></span></span></p> 
 <p><span lang="en-us">__doc__<span lang="zh-cn">来分别访问类与方法的文档字符串。</span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">就如同<span lang="en-us">__init__<span lang="zh-cn">方法一样，还有一个特殊的方法<span lang="en-us">__del__<span lang="zh-cn">，它在对象消逝的时候被调用。对象消逝即对象不再被使用，它所占用的内存将返回给系统作它用。在这个方法里面，我们只是简单地把<span lang="en-us">Per<span lang="en-us">son.population<span lang="zh-cn">减<span lang="en-us">1.</span></span></span></span></span></span></span></span></span></p> 
 <p lang="en-us"> </p> 
 <p><span lang="zh-cn">当对象不再被使用时，<span lang="en-us">__del__<span lang="zh-cn">方法运行，但是很难保证这个方法究竟在什么时候运行。如果你想要指明它的运行，你就得使用<span lang="en-us">del<span lang="zh-cn">语句，</span></span></span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">当在<span lang="en-us">python<span lang="zh-cn">中，你使用的数据成员名称以双下划线前缀如<span lang="en-us">__privatevar,python<span lang="zh-cn">的名称管理体系才会有效地把它作为私有变量。</span></span></span></span></span></p> 
 <p><span lang="zh-cn">这样就有一个管理，如果某个变量只想在类或对象中使用，就应该以单下划线前缀。而其他的名称都是公共的，可以被其他类<span lang="en-us">/<span lang="zh-cn">对象使用。</span></span></span></p> 
 <p> </p> 
 <p>继承</p> 
 <p>面向对象编程带来的好处之一就是代码的重用，实现这种重用的方法之一就是通过继承机制。继承可以理解成类之间的类型和子类型关心。</p> 
 <p>假设你想要写一个程序来记录学校之中的教师和学生情况。他们有一些共同属性，比如姓名、年龄和地址。他们也有专有的属性，比如教师的薪水、课程和假期，学生的成绩和学费。</p> 
 <p>你可以为教师和学生建立两个独立的类来处理它们，但是这样做的话，如果要增加一个新的共有属性，就意味着要在这两个独立的类中都增加这个属性。这很快就会显得不实用。</p> 
 <p>一个比较好的方法是创建一个共同的类称为SchoolMember然后让教师和学生的类 继承 这个共同的类。即它们都是这个类型（类）的子类型，然后我们再为这些子类型添加专有的属性。</p> 
 <p>使用这种方法有很多优点。如果我们增加/改变了SchoolMember中的任何功能，它会自动地反映到子类型之中。例如，你要为教师和学生都增加一个新的身份证域，那么你只需简单地把它加到SchoolMember类中。然而，在一个子类型之中做的改动不会影响到别的子类型。另外一个优点是你可以把教师和学生对象都作为SchoolMember对象来使用，这在某些场合特别有用，比如统计学校成员的人数。一个子类型在任何需要父类型的场合可以被替换成父类型，即对象可以被视作是父类的实例，这种现象被称为多态现象。</p> 
 <p>另外，我们会发现在 重用 父类的代码的时候，我们无需在不同的类中重复它。而如果我们使用独立的类的话，我们就不得不这么做了。</p> 
 <p> </p> 
 <p>在上述的场合中，SchoolMember类被称为 基本类 或 超类 。而Teacher和Student类被称为 导出类 或 子类 。</p> 
 <p>现在，我们将学习一个例子程序。</p> 
 <p> </p> 
 <p>class SchoolMember:</p> 
 <p>'''represents any school member.'''</p> 
 <p>def __init__(self,name,age):</p> 
 <p>self.name=name</p> 
 <p>self.age=age</p> 
 <p>print '(Initalized SchoolMember:%s)' %self.name</p> 
 <p>def tell(self):</p> 
 <p>'''Tell my details.'''</p> 
 <p>print 'Name:"%s" Age:"%s"' %(self.name,self.age),</p> 
 <p>class Teacher(SchoolMember):</p> 
 <p>'''Represents a teacher.'''</p> 
 <p>def __init__(self,name,age,salary):</p> 
 <p>SchoolMember.__init__(self,name,age)</p> 
 <p>self.salary=salary</p> 
 <p>print '(Initialized Teacher:%s)' %self.name</p> 
 <p>def tell(self):</p> 
 <p>SchoolMember.tell(self)</p> 
 <p>print 'salary:"%d"' %self.salary</p> 
 <p>class Student(SchoolMember):</p> 
 <p>'''Represents a student.'''</p> 
 <p>def __init__(self,name,age,marks):</p> 
 <p>SchoolMember.__init__(self,name,age)</p> 
 <p>self.marks=marks</p> 
 <p>print '(Initalized Student:%s)' %self.name</p> 
 <p>def tell(self):</p> 
 <p>SchoolMember.tell(self)</p> 
 <p>print 'Marks:"%d:' %self.marks</p> 
 <p>t=Teacher('Mrs.Shrividya',40,30000)</p> 
 <p>s=Student('Swarrop',22,75)</p> 
 <p> </p> 
 <p>print</p> 
 <p> </p> 
 <p>members=[t,s]</p> 
 <p>for member in members:</p> 
 <p>member.tell()</p> 
 <p> </p> 
 <p>输出：</p> 
 <p>$ python inherit.py</p> 
 <p>(Initialized SchoolMember: Mrs. Shrividya)</p> 
 <p>(Initialized Teacher: Mrs. Shrividya)</p> 
 <p>(Initialized SchoolMember: Swaroop)</p> 
 <p>(Initialized Student: Swaroop)</p> 
 <p> </p> 
 <p>Name:"Mrs. Shrividya" Age:"40" Salary: "30000"</p> 
 <p>Name:"Swaroop" Age:"22" Marks: "75"</p> 
 <p> </p> 
 <p><span lang="zh-cn">为了使用继承，我们把基本类的名称作为一个元组跟在定义类时的类名称之后。然后我们注意到基本类的<span lang="en-us">__init__<span lang="zh-cn">方法专门使用<span lang="en-us">self<span lang="zh-cn">变量调用，这样我们就可以初始化对象的基本类部分。这一点十分重要，<span lang="en-us">py<span lang="en-us">thon<span lang="zh-cn">不会自动调用基本类的<span lang="en-us">constructor<span lang="zh-cn">，得<span lang="zh-cn">亲自调用<span lang="zh-cn">。</span></span></span></span></span></span></span></span></span></span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">在方法调用之前加上类名称前缀，然后把<span lang="en-us">self<span lang="zh-cn">变量及其他参数传递给它。</span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">注意，在我们使用<span lang="en-us">Sch<span lang="en-us">oolMember<span lang="zh-cn">类的<span lang="en-us">tell<span lang="zh-cn">方法的时候，我们把<span lang="en-us">Teacher<span lang="zh-cn">和<span lang="en-us">Student<span lang="zh-cn">的实例仅仅作为<span lang="en-us">SchoolMember<span lang="zh-cn">的实例。</span></span></span></span></span></span></span></span></span></span></span></span></p> 
 <p> </p> 
 <p><span lang="zh-cn">另外，我们调用了子类型的<span lang="en-us">tell<span lang="zh-cn">方法，而不是<span lang="en-us">Sch<span lang="en-us">oolMember<span lang="zh-cn">类的<span lang="en-us">tell<span lang="zh-cn">方法。<span lang="en-us">python<span lang="zh-cn">总是首先查找对应类型的方法，在这个例子中就是如此。如果它不能在到导出类中找到对应的方法，它才开始到基本类中逐个查找。基本类是在类定义的时候，在元组之中指明的。</span></span></span></span></span></span></span></span></span></span></p> 
 <p> </p> 
 <p>一个属于的解释，如果在继承元组中列了一个以上的类，那么它就叫做多重继承。</p> 
 <div>
     
 </div> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/likeshu/p/4967179.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01a40d69c507161f8b49c2abaf0b330d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VS2013等版本中怎么写函数注释可以鼠标悬停自动显示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/70de4f4a0217e9486ad78bd79832cab5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ACM-ICPC北京赛区2015网络同步赛E:Stamps</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>