<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TypeScript学习笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TypeScript学习笔记" />
<meta property="og:description" content="目录
前言：
1 TS基础知识
1.1 TS中新增六个类型
1.2 类型断言：
2 接口interface
2.1 定义接口
2.2 属性规则
2.3 高级用法
3 函数
3.1 函数类型
3.2 参数
3.3 函数重载
4 泛型函数
4.1 基本语法
4.2 利用定义泛型类的函数和函数类的泛型
4.3 泛型约束
4.4 在泛型约束中使用类型参数
5 TS中的类
5.1 基本语法
5.2 修饰符
5.3 类里的属性
6 类型
6.1 类型推论
6.1.1 基础使用
6.2 类型兼容性
6.2.1 函数兼容性
6.3 枚举兼容性
6.4 类的兼容
6.5 泛型兼容性
7 类型保护
8 显示复制断言
8.1 null和undefined的补充
8.2 显示赋值断言
9 类型别名和字面量类型
10 可辨识联合类型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5a3f17751e0d327b1192b71f6fffcf4d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-23T16:20:48+08:00" />
<meta property="article:modified_time" content="2023-02-23T16:20:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TypeScript学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="1%20TS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-toc" style="margin-left:0px;"><a href="#1%20TS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" rel="nofollow">1 TS基础知识</a></p> 
<p id="1.1%20TS%E4%B8%AD%E6%96%B0%E5%A2%9E%E5%85%AD%E4%B8%AA%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#1.1%20TS%E4%B8%AD%E6%96%B0%E5%A2%9E%E5%85%AD%E4%B8%AA%E7%B1%BB%E5%9E%8B" rel="nofollow">1.1 TS中新增六个类型</a></p> 
<p id="1.2%20%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.2%20%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%9A" rel="nofollow">1.2 类型断言：</a></p> 
<p id="2%20%E6%8E%A5%E5%8F%A3interface-toc" style="margin-left:0px;"><a href="#2%20%E6%8E%A5%E5%8F%A3interface" rel="nofollow">2 接口interface</a></p> 
<p id="2.1%20%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#2.1%20%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3" rel="nofollow">2.1 定义接口</a></p> 
<p id="2.2%20%E5%B1%9E%E6%80%A7%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#2.2%20%E5%B1%9E%E6%80%A7%E8%A7%84%E5%88%99" rel="nofollow">2.2 属性规则</a></p> 
<p id="2.3%20%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.3%20%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" rel="nofollow">2.3 高级用法</a></p> 
<p id="3%20%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#3%20%E5%87%BD%E6%95%B0" rel="nofollow">3 函数</a></p> 
<p id="3.1%20%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#3.1%20%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B" rel="nofollow">3.1 函数类型</a></p> 
<p id="3.2%20%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.2%20%E5%8F%82%E6%95%B0" rel="nofollow">3.2 参数</a></p> 
<p id="3.3%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#3.3%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD" rel="nofollow">3.3 函数重载</a></p> 
<p id="4%20%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#4%20%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0" rel="nofollow">4 泛型函数</a></p> 
<p id="4.1%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#4.1%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" rel="nofollow">4.1 基本语法</a></p> 
<p id="4.2%20%E5%88%A9%E7%94%A8%3Ctype%3E%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B-toc" style="margin-left:40px;"><a href="#4.2%20%E5%88%A9%E7%94%A8%3Ctype%3E%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B" rel="nofollow">4.2 利用定义泛型类的函数和函数类的泛型</a></p> 
<p id="4.3%C2%A0%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F-toc" style="margin-left:40px;"><a href="#4.3%C2%A0%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F" rel="nofollow">4.3 泛型约束</a></p> 
<p id="4.4%C2%A0%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.4%C2%A0%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0" rel="nofollow">4.4 在泛型约束中使用类型参数</a></p> 
<p id="5%20TS%E4%B8%AD%E7%9A%84%E7%B1%BB-toc" style="margin-left:0px;"><a href="#5%20TS%E4%B8%AD%E7%9A%84%E7%B1%BB" rel="nofollow">5 TS中的类</a></p> 
<p id="5.1%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#5.1%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" rel="nofollow">5.1 基本语法</a></p> 
<p id="5.2%20%E4%BF%AE%E9%A5%B0%E7%AC%A6-toc" style="margin-left:40px;"><a href="#5.2%20%E4%BF%AE%E9%A5%B0%E7%AC%A6" rel="nofollow">5.2 修饰符</a></p> 
<p id="5.3%20%E7%B1%BB%E9%87%8C%E7%9A%84%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#5.3%20%E7%B1%BB%E9%87%8C%E7%9A%84%E5%B1%9E%E6%80%A7" rel="nofollow">5.3 类里的属性</a></p> 
<p id="%C2%A06%20%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%C2%A06%20%E7%B1%BB%E5%9E%8B" rel="nofollow"> 6 类型</a></p> 
<p id="6.1%20%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA-toc" style="margin-left:40px;"><a href="#6.1%20%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA" rel="nofollow">6.1 类型推论</a></p> 
<p id="6.1.1%C2%A0%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#6.1.1%C2%A0%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8" rel="nofollow">6.1.1 基础使用</a></p> 
<p id="6.2%20%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#6.2%20%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7" rel="nofollow">6.2 类型兼容性</a></p> 
<p id="6.2.1%20%E5%87%BD%E6%95%B0%E5%85%BC%E5%AE%B9%E6%80%A7-toc" style="margin-left:80px;"><a href="#6.2.1%20%E5%87%BD%E6%95%B0%E5%85%BC%E5%AE%B9%E6%80%A7" rel="nofollow">6.2.1 函数兼容性</a></p> 
<p id="6.3%20%E6%9E%9A%E4%B8%BE%E5%85%BC%E5%AE%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#6.3%20%E6%9E%9A%E4%B8%BE%E5%85%BC%E5%AE%B9%E6%80%A7" rel="nofollow">6.3 枚举兼容性</a></p> 
<p id="6.4%20%E7%B1%BB%E7%9A%84%E5%85%BC%E5%AE%B9-toc" style="margin-left:40px;"><a href="#6.4%20%E7%B1%BB%E7%9A%84%E5%85%BC%E5%AE%B9" rel="nofollow">6.4 类的兼容</a></p> 
<p id="6.5%C2%A0%E6%B3%9B%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#6.5%C2%A0%E6%B3%9B%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7" rel="nofollow">6.5 泛型兼容性</a></p> 
<p id="7%20%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4-toc" style="margin-left:0px;"><a href="#7%20%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4" rel="nofollow">7 类型保护</a></p> 
<p id="8%20%E6%98%BE%E7%A4%BA%E5%A4%8D%E5%88%B6%E6%96%AD%E8%A8%80-toc" style="margin-left:0px;"><a href="#8%20%E6%98%BE%E7%A4%BA%E5%A4%8D%E5%88%B6%E6%96%AD%E8%A8%80" rel="nofollow">8 显示复制断言</a></p> 
<p id="8.1%20null%E5%92%8Cundefined%E7%9A%84%E8%A1%A5%E5%85%85-toc" style="margin-left:40px;"><a href="#8.1%20null%E5%92%8Cundefined%E7%9A%84%E8%A1%A5%E5%85%85" rel="nofollow">8.1 null和undefined的补充</a></p> 
<p id="8.2%20%E6%98%BE%E7%A4%BA%E8%B5%8B%E5%80%BC%E6%96%AD%E8%A8%80-toc" style="margin-left:40px;"><a href="#8.2%20%E6%98%BE%E7%A4%BA%E8%B5%8B%E5%80%BC%E6%96%AD%E8%A8%80" rel="nofollow">8.2 显示赋值断言</a></p> 
<p id="9%C2%A0%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#9%C2%A0%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B" rel="nofollow">9 类型别名和字面量类型</a></p> 
<p id="10%20%E5%8F%AF%E8%BE%A8%E8%AF%86%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#10%20%E5%8F%AF%E8%BE%A8%E8%AF%86%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B" rel="nofollow">10 可辨识联合类型</a></p> 
<p id="11%20TS%E4%B8%AD%E7%9A%84this-toc" style="margin-left:0px;"><a href="#11%20TS%E4%B8%AD%E7%9A%84this" rel="nofollow">11 TS中的this</a></p> 
<p id="12%20%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#12%20%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B" rel="nofollow">12 索引类型</a></p> 
<p id="12.1%20%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#12.1%20%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">12.1 索引类型查询字符串</a></p> 
<p id="12.2%20%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px;"><a href="#12.2%20%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">12.2 索引访问操作符</a></p> 
<p id="13%20%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#13%20%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B" rel="nofollow">13 映射类型</a></p> 
<p id="13.1%20%E5%9F%BA%E7%A1%80-toc" style="margin-left:40px;"><a href="#13.1%20%E5%9F%BA%E7%A1%80" rel="nofollow">13.1 基础</a></p> 
<p id="13.2%20%E7%94%B1%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%8E%A8%E6%96%AD-toc" style="margin-left:40px;"><a href="#13.2%20%E7%94%B1%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%8E%A8%E6%96%AD" rel="nofollow">13.2 由映射类型进行推断</a></p> 
<p id="14%20%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6-toc" style="margin-left:0px;"><a href="#14%20%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6" rel="nofollow">14 声明合并</a></p> 
<p id="14.1%20%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#14.1%20%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8" rel="nofollow">14.1 基础使用</a></p> 
<p id="14.2%20%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86-toc" style="margin-left:40px;"><a href="#14.2%20%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86" rel="nofollow">14.2 补充知识</a></p> 
<p id="%C2%A014.3%20%E5%90%88%E5%B9%B6%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%C2%A014.3%20%E5%90%88%E5%B9%B6%E6%8E%A5%E5%8F%A3" rel="nofollow"> 14.3 合并接口</a></p> 
<p id="14.4%20%E5%90%88%E5%B9%B6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-toc" style="margin-left:40px;"><a href="#14.4%20%E5%90%88%E5%B9%B6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" rel="nofollow">14.4 合并命名空间</a></p> 
<p id="14.5%20%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%90%88%E5%B9%B6-toc" style="margin-left:40px;"><a href="#14.5%20%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%90%88%E5%B9%B6" rel="nofollow">14.5 不同类型合并</a></p> 
<p id="15%20%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#15%20%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B" rel="nofollow">15 条件类型</a></p> 
<p id="15.1%20%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#15.1%20%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8" rel="nofollow">15.1 基础使用</a></p> 
<p id="15.2%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#15.2%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B" rel="nofollow">15.2 分布式条件类型</a></p> 
<p id="15.3%C2%A0%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD-infer-toc" style="margin-left:40px;"><a href="#15.3%C2%A0%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD-infer" rel="nofollow">15.3 条件类型的类型推断-infer</a></p> 
<p id="15.4%20TS%E9%A2%84%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#15.4%20TS%E9%A2%84%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B" rel="nofollow">15.4 TS预定义条件类型</a></p> 
<p id="16%20%E5%85%A5%E6%89%8B%E8%A3%85%E9%A5%B0%E5%99%A8-toc" style="margin-left:0px;"><a href="#16%20%E5%85%A5%E6%89%8B%E8%A3%85%E9%A5%B0%E5%99%A8" rel="nofollow">16 入手装饰器</a></p> 
<p id="16.1%20%E5%9F%BA%E7%A1%80-toc" style="margin-left:40px;"><a href="#16.1%20%E5%9F%BA%E7%A1%80" rel="nofollow">16.1 基础</a></p> 
<p id="16.2%20%E8%A3%85%E9%A5%B0%E5%99%A8%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#16.2%20%E8%A3%85%E9%A5%B0%E5%99%A8%E7%B1%BB%E5%9E%8B" rel="nofollow">16.2 装饰器类型</a></p> 
<p id="17%20typescript%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85-toc" style="margin-left:0px;"><a href="#17%20typescript%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85" rel="nofollow">17 typescript知识点补充</a></p> 
<hr id="hr-toc"> 
<h2>前言：</h2> 
<p>不同于JS的弱类型语言，TS在JS基础上增加了几个新类型，并约束了变量的类型，不同的类型间一般无法相互赋值，以  <span style="color:#ff9900;">变量:类型</span>  的形式为一个变量指定类型，</p> 
<h2 id="1%20TS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">1 TS基础知识</h2> 
<h3 id="1.1%20TS%E4%B8%AD%E6%96%B0%E5%A2%9E%E5%85%AD%E4%B8%AA%E7%B1%BB%E5%9E%8B">1.1 TS中新增六个类型</h3> 
<p>（1）元组</p> 
<p>元组其实是知道长度和每个元素类型的数组，需要个数和类型与变量后规定的类型一一对应</p> 
<pre><code class="language-TypeScript">let Tuple: [String, Number] // Tuple只是变量名可以改变
Tuple = ['z', 1]
Tuple = ['z', '1'] // error 不能将类型“string”分配给类型“Number”</code></pre> 
<p> （2）枚举</p> 
<p>使用enum 关键字声明</p> 
<pre><code class="language-TypeScript">enum demo {
    one,
    two,
}
// 相当于：
let obj = {
    0: 'one',
    1: "two",
    one: 1,
    two: 2
}</code></pre> 
<p><span style="color:#ff9900;">注：</span></p> 
<ul><li>访问属性的方式和对象类似</li><li>可以通过索引访问，也可以通过属性名访问</li><li>通过属性名 = number的形式指定枚举的索引，并且后续的枚举不指定值得情况下，从指定值之上开始累加</li><li>枚举赋值也可以赋值字符串</li><li>const关键字定义的enum枚举对象，不会在js中进行编译，使用的时候只会将其中的值取出来使用</li><li>反向映射只支持数字枚举，字符串枚举是不支持的</li></ul> 
<p>（3）any</p> 
<p>表示任意类型，给一个变量指定any后，就可给他赋值不同的类型变量</p> 
<p>（4）void</p> 
<p>表示没有类型，和any相反，当一个函数不设定返回值时，可以指定它的返回值类型为void</p> 
<p>void 类型的变量只能赋值为 <code>undefined</code> 和 <code>null</code>，其他类型不能赋值给 void 类型的变量</p> 
<p>（5）never</p> 
<p>值永不存在值得类型。它是那些总会抛出异常或根本不会有返回值的函数（不同于不设定返回值默认为undefined，当一个函数死循环或者异常时可以指定never）表达式的返回值类型，当变量被永不为真的类型保护（后面章节会详细介绍）所约束时，该变量也是 never 类型</p> 
<p>（6）unknown</p> 
<p>表示未知类型，多使用unknown替代any，unknown更安全</p> 
<h3 id="1.2%20%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%9A">1.2 类型断言：</h3> 
<p>当不确定typescript联合类型（<span style="color:#a2e043;">变量属于多种类型中之一</span>）的变量到底是哪一种的时候，需要使用到类型断言</p> 
<p>语法为：&lt;type&gt;value 或者 value as type（推荐）</p> 
<h2 id="2%20%E6%8E%A5%E5%8F%A3interface">2 接口interface可以看作一个复杂的类型</h2> 
<h3 id="2.1%20%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3">2.1 定义接口</h3> 
<pre><code class="language-TypeScript">interface Info {
    firstName: string;
    lastName: string;
}
const getFullName = ({ firstName, lastName } : Info) =&gt; return `${firstName} ${lastName}`</code></pre> 
<h3 id="2.2%20%E5%B1%9E%E6%80%A7%E8%A7%84%E5%88%99">2.2 属性规则</h3> 
<p>（1）可选属性</p> 
<pre><code class="language-TypeScript">interface Info {
    firstName: string;
    lastName?: string;
}
const getFullName = ({ firstName, lastName } : Info) =&gt; {
                        return `${firstName} ${lastName ? lastName : ""}`
                      }</code></pre> 
<p>（2）多余属性检查</p> 
<pre><code class="language-TypeScript">interface Info {
    firstName: string;
    lastName?: string;
}
const getFullName = ({ firstName, lastName } : Info) =&gt; {
    return `${firstName} ${lastName ? lastName : ""} ${size}`
    // error: Property 'size' does not exist on type 'Info'
}</code></pre> 
<p>绕开多余属性的检查：</p> 
<ul><li>使用类型断言</li></ul> 
<pre><code class="language-TypeScript">interface Info {
    firstName: string;
    lastName?: string;
}
const getFullName = ({ firstName, lastName, age } : Info) =&gt; {
    return `${firstName} ${lastName ? lastName : ""} ${age}`
}
getFullName({
    firstName: 'li',
    lastName: 'ming',
    age: 12
} as Info)</code></pre> 
<ul><li> 添加索引签名</li></ul> 
<pre><code class="language-TypeScript">interface Info {
    firstName: string;
    lastName?: string;
    [prop: string]: any;
}
const getFullName = ({ firstName, lastName, age } : Info) =&gt; {
    return `${firstName} ${lastName ? lastName : ""} ${age}`
}
getFullName({
    firstName: 'li',
    lastName: 'ming',
    age: 12
})</code></pre> 
<ul><li>利用类型兼容</li></ul> 
<pre><code class="language-TypeScript">interface Info {
    firstName: string;
    lastName?: string;
}
const getFullName = ({ firstName, lastName, age } : Info) =&gt; {
    return `${firstName} ${lastName ? lastName : ""} ${age}`
}
const object = {
    firstName: 'li',
    lastName: 'ming',
    age: 12
}
getFullName(object)</code></pre> 
<p>（3）只读属性</p> 
<pre><code class="language-TypeScript">interface Info {
    readonly name: string;
    age: number;
}
const student: Info = {
    name: 'Li Ming',
    age: 12
}
student.name = 'Zhang San' // Cannot assign to 'name' because it is a read-only property
student.age = 18</code></pre> 
<p><span style="color:#a2e043;"> 注：const和readonly的选择, 如果是定义一个常量，那用<code>const</code>，如果这个值是作为对象的属性，那请用<code>readonly，且const声明的变量对象其中的属性是可以修改的</code></span></p> 
<p>（4）函数类型</p> 
<pre><code class="language-TypeScript">// (a: type, b: type): type形式，其中()内为参数类型, :之后为函数返回值类型
interface func {
    (name: string, age: number): string
}
const boy: func = (name, age) =&gt; {
    return `${name} ${age}`
}</code></pre> 
<h3 id="2.3%20%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95">2.3 高级用法</h3> 
<p>（1）索引类型</p> 
<pre><code class="language-TypeScript">interface indexType {
    [id: number]: string;
}
const index: indexType = {
    0: "one",
    1: "two"
}
const index2: indexType = {
    m: "one",
// error 不能将类型"{ s: string; a: string; }"分配给类型"RoleDic"
}</code></pre> 
<p>（2）继承接口</p> 
<pre><code class="language-TypeScript">interface color {
    color: string;
}
interface book extends color {
    name: string
}
interface demo extends book {
    age: string
}
// interface demo {
    // color: string;
    // name: string;
    // age: string
// }
const people: demo = {
    color: 'red',
    name: 'zs',
    age: '12'
}</code></pre> 
<p>（3）混合类型的接口</p> 
<pre><code class="language-TypeScript">interface Sum {
    (): number;
    num1: number;
    num2: number;
}
const getSum = (): Sum =&gt; {
    const func = () =&gt; {
        return func.num1 + func.num2 // 此处的返回值通过第一项：number定义
    }
    func.num1 = 5
    func.num2 = 10
    return func
}
const sum = getSum()</code></pre> 
<p><span style="color:#ff9900;">混合类型的后几项为, 定义的函数对象里的属性规则</span></p> 
<h2 id="3%20%E5%87%BD%E6%95%B0">3 函数</h2> 
<h3 id="3.1%20%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B">3.1 函数类型</h3> 
<p>（1）简单定义</p> 
<pre><code class="language-TypeScript">function demo(arg1: number, arg2: number): string {
    return arg1 + arg2 + ''
} </code></pre> 
<p>（2）完整定义</p> 
<pre><code class="language-TypeScript">// 此处相当于变量的声明，规定此变量为函数类型
let demo: (arg1: number, arg2: number) =&gt; number
demo = (num1: number, num2: number): number =&gt; num1 + num2</code></pre> 
<p>（3）使用接口定义</p> 
<pre><code class="language-TypeScript">interface demoIf {
    (arg1: number, arg2: number): number
}
let add: demoIf = (num1: number, num2: number): number =&gt; num1 + num2</code></pre> 
<p>（4）使用类型别名</p> 
<pre><code class="language-TypeScript">type demo = (arg1: number, arg2: number) =&gt; number
let add: demo = (num1: number, num2: number): number =&gt; num1 + num2</code></pre> 
<h3 id="3.2%20%E5%8F%82%E6%95%B0">3.2 参数</h3> 
<p>（1）可选参数</p> 
<pre><code class="language-TypeScript">type demo = (arg1: number, arg2: number, arg3?: number) =&gt; number
let add: demo = (num1: number, num2: number, num3: any): any =&gt; {
    if (num3) {
        return num1 + num2 + num3
    } else {
        return num1 + num2
    }
}
console.log(add(1, 2)) // 3
console.log(add(1, 2, 3)) // 6
// 必选参数需要在可选参数的前面</code></pre> 
<p>（2）默认参数</p> 
<pre><code class="language-TypeScript">function add (num1: number, num2: number = 2): number {
    return num1 + num2
}</code></pre> 
<p>（3）剩余参数</p> 
<pre><code class="language-TypeScript">const handleData = (arg1: number, ...args: number[]) =&gt; {};</code></pre> 
<h3 id="3.3%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">3.3 函数重载</h3> 
<pre><code class="language-TypeScript">function fun (x: string): number
function fun (x: number): string
function fun (x: any): any {
    if (typeof x === 'string') {
        return x.length
    } else {
        return x.toString()
    }
}
console.log(fun(2)) // '2'
console.log(fun("1")) // 1
console.log(fun([1])) // error</code></pre> 
<p>注：重载只能用 function 来定义，不能使用接口、类型别名</p> 
<h2 id="4%20%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0">4 泛型函数</h2> 
<h3 id="4.1%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">4.1 基本语法</h3> 
<pre><code class="language-TypeScript">// 需要使用function
function demo&lt;G&gt;(str1: G): G {
    return str1
}
console.log(demo&lt;string&gt;('s')) // "s"</code></pre> 
<h3 id="4.2%20%E5%88%A9%E7%94%A8%3Ctype%3E%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B">4.2 利用&lt;type&gt;定义泛型类的函数和函数类的泛型</h3> 
<p>（1）定义泛型类型的函数</p> 
<pre><code class="language-TypeScript">type FunctionType&lt;TValue&gt; =(a: TValue) =&gt; TValue;
const demo: FunctionType&lt;string&gt; = (x: string): string =&gt; {
  return x
}</code></pre> 
<p>（2）定义泛型函数的类型（函数更为零活，参数多变）</p> 
<pre><code class="language-TypeScript">type FunctionType = &lt;TValue&gt;(a: TValue) =&gt; TValue;
const demo: FunctionType = &lt;TValue&gt;(x: TValue): TValue =&gt; {
  return x
}</code></pre> 
<p><span style="color:#ff9900;">&lt;&gt;里参数为函数中各个参数的类型。如&lt;A, B&gt; 即为函数中参数或者返回值需要用到的类型</span></p> 
<p>除了上述的定义方式，也可以使用interface或者函数直接定义使用</p> 
<h3 id="4.3%C2%A0%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F">4.3 泛型约束</h3> 
<pre><code class="language-TypeScript">interface valueWithJoin {
  join: Function
}
// TValue 继承接口valueWithJoin，代表实参必须有join这个属性且为Function类型才可以
type FunctionType = &lt;TValue extends valueWithJoin&gt;(a: TValue, b: string) =&gt; string[];
const demo: FunctionType = &lt;TValue extends valueWithJoin&gt;(x: TValue, y: string): string[] =&gt; {
  return (x.join("") + y).split("")
}
console.log(demo([1, 2], 'a')) // ["1", "2", "a"]</code></pre> 
<h3 id="4.4%C2%A0%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0">4.4 在泛型约束中使用类型参数</h3> 
<pre><code class="language-TypeScript">type getPropType = &lt;A, B extends keyof A&gt;(obj: A, index: B) =&gt; A[B]
const getProp: getPropType = &lt;A, B extends keyof A&gt;(obj: A, i: B) =&gt; obj[i]
console.log(getProp({num: 1, age: 20}, "num")) // 1
console.log(getProp({num: 1, age: 20}, "age")) // 20
console.log(getProp({num: 1, age: 20}, "name")) // error 类型“"name"”的参数不能赋给类型“"num" | "age"”的参数。</code></pre> 
<h2 id="5%20TS%E4%B8%AD%E7%9A%84%E7%B1%BB">5 TS中的类</h2> 
<h3 id="5.1%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">5.1 基本语法</h3> 
<pre><code class="language-TypeScript">class People {
  name: string;
  age: number;
  constructor (name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}
const zs = new People('zs', 20)</code></pre> 
<p>继承的使用和js基本相似</p> 
<h3 id="5.2%20%E4%BF%AE%E9%A5%B0%E7%AC%A6">5.2 修饰符</h3> 
<p>（1）public</p> 
<p>public表示公共的，用来指定在创建实例后可以通过实例访问的，也就是类定义的外部可以访问的属性和方法。默认是 public，但是 TSLint 可能会要求你必须用修饰符来表明这个属性或方法是什么类型的。</p> 
<pre><code class="language-TypeScript">class People {
  public name: string;
  public age: number;
  constructor (name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  public getName() {
    return this.name
  }
}
const zs = new People('zs', 20)
console.log(zs.getName()) // "zs"</code></pre> 
<p>（2）private</p> 
<p>此修饰符表示私有的，它修饰的属性在类的定义外面是没法访问的</p> 
<pre><code class="language-TypeScript">class People {
  public name: string;
  public age: number;
  constructor (name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  public getName() {
    return this.name
  }
  private getAge() {
    return this.age
  }
}
const zs = new People('zs', 20)
console.log(zs.getName()) // "zs"
console.log(zs.getAge()) // error 属性“getAge”为私有属性，只能在类“People”中访问</code></pre> 
<p><span style="color:#a2e043;">注：在子类的继承中也是无法使用父类的私有属性或方法</span></p> 
<p>（3）protected</p> 
<p>表示被保护的属性或方法，在实例中仍无法访问，但是不同于private，他可以在子类中访问</p> 
<p><span style="color:#ff9900;">super关键字可以访问的是受保护的方法和公共方法，所以会产生报错</span></p> 
<p>（4）readonly</p> 
<p>设置属性为只读，无法修改</p> 
<h3 id="5.3%20%E7%B1%BB%E9%87%8C%E7%9A%84%E5%B1%9E%E6%80%A7">5.3 类里的属性</h3> 
<p>（1）参数属性</p> 
<p>在constructor的参数中将修饰符放在前面可以简化类的书写</p> 
<pre><code class="language-TypeScript">class Demo {
  constructor (public name: string) {
    this.name = name 
    // 等同于在constructor前用public先声明
  }
}
const obj = new Demo('zs')</code></pre> 
<p>（2）静态属性</p> 
<p>在属性或方法前加static属性，创建实例的时候，不会生成此属性或者方法</p> 
<pre><code class="language-TypeScript">class Demo {
  constructor (public age: string) {
    this.age = age
  }
  public static getNumber() {
    return 123
  }
}
const obj = new Demo('zs')
console.log(obj) // { name: 'zs' }
console.log(Demo.getNumber()) // 123</code></pre> 
<p>只支持写在constructor外的属性和方法</p> 
<p>（3）可选类属性</p> 
<p>使用？占位，表示可以不传入这个属性或方法</p> 
<pre><code class="language-TypeScript">class Demo {
  constructor (public age: number, public name?: string) {
    this.age = age
    this.name = name
  }
  public static getNumber() {
    return 123
  }
}
const obj = new Demo(12)
console.log(obj) // { name: 12, name: undefined }
const obj2 = new Demo(12, 'zs')
console.log(obj2) // { age: 12, name: "zs" }</code></pre> 
<p>（4）存取器</p> 
<pre><code class="language-TypeScript">class getSetValue {
  private __fullName: string = 'zs'
  get fullName() {
    return this.__fullName
  }
  set fullName(value: string) {
    console.log('set')
    this.__fullName = value
  }
}
const lisi = new getSetValue()
lisi.fullName = 'lisi'
console.log(lisi.fullName)</code></pre> 
<p><span style="color:#ff9900;">注：get和set的命名需要一致，他们相当于两个公共的方法，在设置值时调用set对应的fullName（）方法给__fullName（与get和set的命名无关，可以是任何名字）赋一个值，在获取这个值时调用get对应的fullName获取这个值</span></p> 
<p>（5）抽象类</p> 
<p>一般用来被其余类继承的类，称为抽象类，不能直接用来创建实例对象，使用abstract关键字定义</p> 
<pre><code class="language-TypeScript">abstract class Demo {
  constructor (public age: number) {
    this.age = age
  }
  abstract returnAge(): number
}
class Son extends Demo {
  constructor (age: number) {
    super(age)
    this.age = age
  }
  returnAge() {
    return this.age
  }
}
const obj = new Son(18)
console.log(obj.returnAge()) // 18</code></pre> 
<p>抽象类里定义的抽象方法，需要继承类中先定义</p> 
<p>抽象方法和抽象存取器不能包含实际代码块</p> 
<p><span style="color:#ff9900;">注：实例的类型即是class声明的构造函数</span></p> 
<p>（6）类类型接口</p> 
<pre><code class="language-TypeScript">interface missProp {
  name: string;
  age: number;
}
class People implements missProp { // error 类型 "People" 中缺少属性 "age"，但类型 "missProp" 中需要该属性。
  constructor(public name: string) {
    this.name = name
  }
}</code></pre> 
<p>通过implements关键字让类的声明中必须包含接口规定的字段</p> 
<p><span style="color:#ff9900;">注：有一点需要注意，接口检测的是使用该接口定义的类创建的实例，所以通过static定义的静态属性依旧会报错</span></p> 
<h2 id="%C2%A06%20%E7%B1%BB%E5%9E%8B"> 6 类型</h2> 
<h3 id="6.1%20%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA">6.1 类型推论</h3> 
<h4 id="6.1.1%C2%A0%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">6.1.1 基础使用</h4> 
<pre><code class="language-TypeScript">let na = 'zs'
na = 123 // error 不能将类型“number”分配给类型“string”</code></pre> 
<p>直接将一个值赋值给一个变量，而不去声明他的类型，ts会自动推断出它的的类型，在后续赋值操作时，应保持和一开始赋的值的类型相同</p> 
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法，所以现在加了对参数<code>target</code>和返回值的类型定义之后就会报错</p> 
<p>（1）多类型联合</p> 
<p>在定义一个数组或元组这种拥有多种数据类型的值得时候，ts会将其中的各项元素的类型进行联合</p> 
<pre><code class="language-TypeScript">let tuple = [1, "q"]
tuple = [false] // error 不能将类型“boolean”分配给类型“string | number”

let value = Math.random() * 10 &gt; 5 ? 'abc' : 123
value = false // error 不能将类型“false”分配给类型“string | number”</code></pre> 
<p>（2）上下文类型</p> 
<pre><code class="language-TypeScript">
window.onmousedown = function(mouseEvent) {
  console.log(mouseEvent.a); // error 类型“MouseEvent”上不存在属性“a”
};</code></pre> 
<p>表达式左侧是 window.onmousedown(鼠标按下时发生事件)，因此 TypeScript 会推断赋值表达式右侧函数的参数是事件对象，因为左侧是 mousedown 事件，所以 TypeScript 推断 mouseEvent 的类型是鼠标按下事件。在回调函数中使用 mouseEvent 的时候，你可以访问鼠标事件对象的所有属性和方法，当访问不存在属性的时候，就会报错。</p> 
<h3 id="6.2%20%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7">6.2 类型兼容性</h3> 
<h4 id="6.2.1%20%E5%87%BD%E6%95%B0%E5%85%BC%E5%AE%B9%E6%80%A7">6.2.1 函数兼容性</h4> 
<p>（1）参数匹配</p> 
<p>如果x要赋值给y需要x的参数小于或等于y的参数个数，并且类型符合y参数类型，参数名无所谓</p> 
<pre><code class="language-TypeScript">let x = (a: number) =&gt; a.toString()
let y = (a: number, b: string) =&gt; a + b
y = x
x = y // error 不能将类型“(a: number, b: string) =&gt; string”分配给类型“(a: number) =&gt; string”</code></pre> 
<p>（2）剩余参数和可选参数</p> 
<pre><code class="language-TypeScript">let demo = (arg1: number, ...args: number[]): number[] =&gt; {
  return new Array(arg1, ...args)
}
console.log(demo(1, 2, 3)) // [1, 2, 3]
</code></pre> 
<p>剩余参数与可选参数类似，剩余参数可以看做和很多可选参数组合而成，传入剩余参数时，可以是0个也可以是很多个</p> 
<p>（3）函数参数的双向协变</p> 
<pre><code class="language-TypeScript">let demo = function (a: number | string): void {}
let demo2 = function (b: number): void {}
demo2 = demo</code></pre> 
<p>注：报错是tsconfig.json文件的"strictFunctionTypes"选项为false，默认为false，但是如果你设置了"strict"为true，需要显式设置"strictFunctionTypes"为false。</p> 
<p>（4）函数返回值类型</p> 
<p>和参数类型相似，函数的返回值类型也需要匹配才可以相互赋值</p> 
<p>（5）函数重载</p> 
<p>赋值的函数重载，需要在被赋值的函数重载中的每一条都包括</p> 
<pre><code class="language-TypeScript">function merge(arg1: number, arg2: number): number; // 这是merge函数重载的一部分
function merge(arg1: string, arg2: string): string; // 这也是merge函数重载的一部分
function merge(arg1: any, arg2: any) { // 这是merge函数实体
  return arg1 + arg2;
}
function sum(arg1: number, arg2: number): number; // 这是sum函数重载的一部分
function sum(arg1: any, arg2: any): any { // 这是sum函数实体
  return arg1 + arg2;
}
let func = merge;
func = sum; // error 不能将类型“(arg1: number, arg2: number) =&gt; number”分配给类型“{ (arg1: number, arg2: number): number; (arg1: string, arg2: string): string; }”
 </code></pre> 
<h3 id="6.3%20%E6%9E%9A%E4%B8%BE%E5%85%BC%E5%AE%B9%E6%80%A7">6.3 枚举兼容性</h3> 
<pre><code class="language-TypeScript">enum demo {
  one,
  two
}
let num = demo.two
num = 10
enum numb {
  one,
  two
}
let test = demo.one
test = numb.one // error 不能将类型“numb.one”分配给类型“demo”</code></pre> 
<p>枚举与数字类型兼容；</p> 
<p>枚举与枚举不兼容；</p> 
<p>枚举与字符串不兼容；</p> 
<h3 id="6.4%20%E7%B1%BB%E7%9A%84%E5%85%BC%E5%AE%B9">6.4 类的兼容</h3> 
<p>两个类的兼容，只看他们的实例对象，静态成员和公共方法不考虑</p> 
<p>（1）基本</p> 
<pre><code class="language-TypeScript">class People {
  static age: number;
  constructor (public name: string) {
    this.name = name
  }
}
class Dog {
  static master: string;
  constructor (public name: string) {
    this.name = name
  }
}
let zs: People = new People('zs')
let ahua: Dog = new Dog('ahua')
zs = ahua
console.log(zs) // Dog { name: 'ahua' }</code></pre> 
<p>（2）私有成员和受保护的成员</p> 
<pre><code class="language-TypeScript">class People {
  private age: number = 12;
  constructor (public name: string) {
    this.name = name
  }
}
class son extends People {
  constructor(name: string) {
    super(name)
    this.name = name
  }
}
class Dog {
  private age: number = 55;
  constructor (public name: string) {
    this.name = name
  }
}
let ls: People = new son('ls')
let zs: People = new Dog('zs') // error 不能将类型“Dog”分配给类型“People”。类型具有私有属性“age”的单独声明。</code></pre> 
<p>对于拥有私有成员或受保护成员的类，他只兼容自身的子类（继承自它）</p> 
<h3 id="6.5%C2%A0%E6%B3%9B%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7">6.5 泛型兼容性</h3> 
<pre><code class="language-TypeScript">interface Value&lt;V&gt; {}
let value1: Value&lt;string&gt; = 1;
let value2: Value&lt;number&gt;;

value2 = value1

interface ValueNext&lt;T&gt; {
  s: T
}

let value3: ValueNext&lt;string&gt; = { s: "a" };
let value4: ValueNext&lt;number&gt;;
value4 = value3 // error 不能将类型“ValueNext&lt;string&gt;”分配给类型“ValueNext&lt;number&gt;</code></pre> 
<p>ts是结构类型的语法，接口定义泛型，未使用的情况下，不做类型限制，所以两个变量彼此兼容，使用后，会对使用该接口的对象的属性进行类型限制，所以不兼容</p> 
<h2 id="7%20%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4">7 类型保护</h2> 
<p>与类型断言应用场景相似，类型保护相当于自己声明一个可以判断值得类型的函数</p> 
<p>（1）自定义类型保护</p> 
<pre><code class="language-TypeScript">function isString(value: string | number): value is string {
  // value is type(value是参数名，type是需要判断的类型)
  return typeof value === "string"
}

function getValue() {
  const random = Math.random() * 10
  if (random &gt; 5) {
    return 'string'
  } else {
    return 1
  }
}
const item = getValue()

// if (item.length) { 类型“"string" | 1”上不存在属性“length”
//   console.log(item.length)
// } else {
//   console.log(item.toFixed())
// }

if (isString(item)) {
  console.log(item.length)
} else {
  console.log(item.toFixed())  
}</code></pre> 
<p>（3）typeof 类型保护</p> 
<p>可以将上述的自定义函数，替换成typeof来进行判断，也可以起到同样的作用</p> 
<p>if (typeof item === "string") {}</p> 
<p>ts中typeof的书写规范</p> 
<ul><li> <p>只能使用等于和不等两种形式来比较</p> </li><li> <p>type 只能是<code>number</code>、<code>string</code>、<code>boolean</code>和<code>symbol</code>四种类型</p> </li></ul> 
<p>（4）instanceof 类型保护</p> 
<pre><code class="language-TypeScript">function typeConstructor() {
  const random = Math.random() * 10
  if (random &gt; 5) {
    return ['a']
  } else {
    return { name: 'zs' }
  }
}
const value = typeConstructor()
// 数组的构造函数也有Object，但对象的构造没有Array,所以需要先判断Array
if (value instanceof Array) {
  console.log(value[0])
} else {
  console.log(value.name)
}</code></pre> 
<h2 id="8%20%E6%98%BE%E7%A4%BA%E5%A4%8D%E5%88%B6%E6%96%AD%E8%A8%80">8 显示复制断言</h2> 
<h3 id="8.1%20null%E5%92%8Cundefined%E7%9A%84%E8%A1%A5%E5%85%85">8.1 null和undefined的补充</h3> 
<p>（1）严格模式的null和undefined赋值</p> 
<p>当我们在严格模式（tsconfig.js配置strictNullChecks为true）下，就不能将null和undefined赋值给除自身和void之外的类型，但是一个对象有时需要先设置为null或者undefined，可以使用以下方式解决：</p> 
<pre><code class="language-TypeScript">let obj: null | object = { name: 'zs' }
obj = null
obj = {}</code></pre> 
<p>（2）可选参数和可选属性</p> 
<p>开启了 strictNullChecks 后，可选参数会被加上 | undefined</p> 
<pre><code class="language-TypeScript">interface demo {
  name: string
  age?: number
}
const obj: demo = {
  name: 'zs',
  age: 12
}
obj.age = undefined // 不报错(property) demo.age?: number | undefined</code></pre> 
<h3 id="8.2%20%E6%98%BE%E7%A4%BA%E8%B5%8B%E5%80%BC%E6%96%AD%E8%A8%80">8.2 显示赋值断言</h3> 
<pre><code class="language-TypeScript">function judgeNull(num: number | null): string {
  // return num.toString() // error 对象可能为 "null"
  return num!.toString()
}</code></pre> 
<p><span style="color:#ff9900;">在可能为null的值后面加！，表示此值是不为null的情况</span></p> 
<h2 id="9%C2%A0%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B">9 类型别名和字面量类型</h2> 
<p>（1）类型别名</p> 
<pre><code class="language-TypeScript">type typeString = string
type demoType = { a: string, c: object }
type demoType1&lt;T&gt; = { a: T }

type demoType2 = { a: string, c?: demoType }
const demoObj: demoType = {
  a: 'zs',
  c: {
    a: 'ls',
    c: {
      a: 'zs',
    }
  }
}</code></pre> 
<p>注：</p> 
<ul><li>类型别名可以是一个具体的例子，如demoType</li><li>类型别名可以在别名中引用自身（只在对象中有用）</li><li>类型别名只是为其它类型起了个新名字来引用这个类型，所以当它为接口起别名时，不能使用 <code>extends</code> 和 <code>implements</code> </li></ul> 
<p>（2）字面量类型</p> 
<ul><li>字符串字面量（具体的值，而不是字符串类型）</li></ul> 
<pre><code class="language-TypeScript">type name = "zs"
let student1: name = 'ls' // error 不能将类型“"ls"”分配给类型“"zs"”</code></pre> 
<ul><li>  数字字面量（与字符串字面量类似）</li></ul> 
<h2 id="10%20%E5%8F%AF%E8%BE%A8%E8%AF%86%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B">10 可辨识联合类型</h2> 
<p>（1）要素</p> 
<ul><li> <p>具有普通的单例类型属性（这个要作为辨识的特征，也是重要因素）</p> </li><li> <p>一个类型别名，包含了那些类型的联合（即把几个类型封装为联合类型，并起一个别名）</p> </li><li> <p>case语句匹配结果</p> </li></ul> 
<pre><code class="language-TypeScript">type zs = {
  name: 'zs',
  hobby: string,
}
type ls = {
  name: 'ls',
  hobby: string,
}
type zw = {
  name: 'zw',
  hobby: string,
}
type student = zs | ls | zw
function getStudentHobby(student: student): string {
  switch (student.name) {
    case 'zs':
      return student.hobby = 'soccer';
    case 'ls':
      return student.hobby = 'read'
    case 'zw':
      return student.hobby = 'play'
  }
}</code></pre> 
<p>（2）完整性检查</p> 
<ul><li>开启 strictNullChecks，然后让函数的返回值类型为指定类型，此时少写一个case会报错</li></ul> 
<h2 id="11%20TS%E4%B8%AD%E7%9A%84this">11 TS中的this</h2> 
<p>ts中的this是一个类型，对于函数而言，this可以理解为对象的字面量类型或者函数的构造函数构造的一个和实例相同的类型，具体的使用其实和js的this相似，但是ts中可以更改this的类型为别的类型</p> 
<pre><code class="language-TypeScript">interface funRules&lt;N, T&gt; {
  info: T;
  play: N &amp; ThisType&lt;N &amp; T&gt;;
}
function demo&lt;N, T&gt;(obj: funRules&lt;N, T&gt;): N &amp; T {
  let info = obj.info || {}
  let play = obj.play || {}
  return { ...info, ...play } as N &amp; T
}
let demoPro = demo({
  info: { x: 0 },
  play: {
    // 没有 &amp; &lt;N &amp; T&gt; 报错：类型“{ add(a: number): any; }”上不存在属性“x”
    add(a: number): any {
      return this.x += a
    }
  }
})
console.log(demoPro.add(5)) // 5</code></pre> 
<p><span style="color:#ff9900;">补充：ThisType是一个内置的接口，用来在对象字面量中键入this，指定当前属性的this的类型</span></p> 
<h2 id="12%20%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B">12 索引类型</h2> 
<h3 id="12.1%20%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2">12.1 索引类型查询字符串</h3> 
<p>keyof操作符，连接一个类型的时候，会返回一个由这个类型所有属性名组成的联合类型</p> 
<pre><code class="language-TypeScript">interface People {
    name: string;
    age: number;
}
let newPeople: keyof People // 相当于 "name" | "age"
newPeople = 'name'
newPeople = 'age'
newPeople = 'a' // error 不能将类型“"a"”分配给类型“keyof People”</code></pre> 
<p>动态监测属性名的实现</p> 
<pre><code class="language-TypeScript">function getValue&lt;T, K extends keyof T&gt;(obj: T, attr: K): T[K] {
    return obj[attr]
}
const info = {
    name: 'zs',
    age: 18
}
let res = getValue(info, 'name') // 'zs'
let res2 = getValue(info, 'age') // 18
let res3 = getValue(info, 'play') // error 类型“"play"”的参数不能赋给类型“"name" | "age"”的参数</code></pre> 
<h3 id="12.2%20%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6">12.2 索引访问操作符</h3> 
<p>使用语法和访问数组和对象的属性一样，使用 []</p> 
<pre><code class="language-TypeScript">interface demo {
    name: 'zs'
}
type Name = demo['name']
let zs: Name = 18 // error 不能将类型“18”分配给类型“"zs"”。

interface demo {
    [name: string]: string
}
let Names: keyof demo = true // error 不能将类型“boolean”分配给类型“string | number”</code></pre> 
<p><span style="color:#a2e043;">如果接口的索引类型是 string 类型，那么实现该接口的对象的属性名设置为数值类型的值也是可以的，因为数值最后还是会先转换为字符串。这里一样，如果接口的索引类型设置为 string 的话，<code>keyof Obj&lt;number&gt;</code>等同于类型<code>number | string</code></span></p> 
<p>当tsconfig.json里<code>strictNullChecks</code>设为<code>false</code>时，通过<code>Type[keyof Type]</code>获取到的，是除去<code>never &amp; undefined &amp; null</code>这三个类型之后的字段值类型组成的联合类型</p> 
<h2 id="13%20%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B">13 映射类型</h2> 
<h3 id="13.1%20%E5%9F%BA%E7%A1%80">13.1 基础</h3> 
<p>使用keyof借助别的类型，映射一个新类型</p> 
<pre><code class="language-TypeScript">interface demo {
    name: string
}

type newDemo&lt;T&gt; = { readonly [P in keyof T]: T[P] }
type newDemoType = newDemo&lt;demo&gt;

let Name: newDemoType = { name: 'zs' }
Name.name = 'ls' // error 无法分配到 "name" ，因为它是只读属性</code></pre> 
<p><span style="color:#ff9900;">注：in在这里的作用相当于js中for...in....，可以将映射类型的属性名遍历并传入新的类型</span></p> 
<p>（2）内置的映射类型：</p> 
<pre><code class="language-TypeScript">// type Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P] };
// type Record&lt;K extends keyof any, T&gt; = { [P in K]: T };
// type Partial&lt;T&gt; = { [P in keyof T]?: T[P] };

// pick:
interface demo {
    name: string;
    age: number;
    hobby: string
}
const zs: demo = {
    name: 'zs',
    age: 18,
    hobby: 'soccer'
}
function copyObj&lt;T, K extends keyof T&gt;(obj: T, newObj: K[]): Pick&lt;T, K&gt; {
    let res = {} as Pick&lt;T, K&gt;
    newObj.forEach(item =&gt; res[item] = obj[item])
    return res
}
console.log(copyObj(zs, ['name', 'age'])) // {name: "zs", age: 18}

// Record:
interface reType {
    one: string,
    two: number,
    three: boolean
}
const reObj: reType = {
    one: 'one',
    two: 2,
    three: true
}
function recordFun&lt;K extends keyof any, T&gt;(obj: Record&lt;K, T&gt;, tran: (value: any) =&gt; T): Record&lt;K, T&gt; {
    let res = {} as Record&lt;K, T&gt;
    for (let key in obj) {
        res[key] = tran(key)
    }
    return res
}
console.log(recordFun(reObj, a =&gt; a)) // {one: "one", two: "two", three: "three"}</code></pre> 
<p>同态：两个相同类型的代数结构之间的结构保持映射，Readonly、Partial 和 Pick 是同态的，而 Record 不是，因为 Record 映射出的对象属性值是新的，和输入的值的属性值不同</p> 
<h3 id="13.2%20%E7%94%B1%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%8E%A8%E6%96%AD">13.2 由映射类型进行推断</h3> 
<p>对一个对象由映射类型进行包装后，也可以逆向操作，俗称拆包</p> 
<pre><code class="language-TypeScript">interface proxy&lt;O&gt; {
    get(): O;
    set(value: O): void
}
// 定义映射类型
type proxyType&lt;T&gt; = { [key in keyof T]: proxy&lt;T[key]&gt; }
// 定义处理函数
function proxyFun&lt;T&gt;(obj: T): proxyType&lt;T&gt; {
    let res = {} as proxyType&lt;T&gt;
    for (let key in obj) {
        res[key] = {
            get: () =&gt; obj[key],
            set: (value) =&gt; {
                obj[key] = value
            }
        }
    }
    return res
}
let obj = {
    name: 'zs',
    age: 18
}
let proxyObj = proxyFun(obj)
console.log(proxyObj.name.get()) // zs
proxyObj.name.set('ls')
console.log(proxyObj.name.get()) // ls  

// 拆包函数
function unproxyFun&lt;T&gt;(obj: proxyType&lt;T&gt;): T {
    let res = {} as T
    for (let key in obj) {
        res[key] = obj[key].get()
    }
    return res
}
let unproxyObj = unproxyFun(proxyObj)
console.log(unproxyObj) // {name: "ls", age: 18}

</code></pre> 
<ul><li>增加或者移除特定修饰符</li></ul> 
<p>映射类型中使用<code>+</code>和<code>-</code>符号作为前缀来指定增加还是删除修饰符</p> 
<ul><li>keyof和映射类型在2.9中的升级</li></ul> 
<p>keyof 和映射类型支持用 number 和 symbol 命名的属性</p> 
<ul><li>元组和数组上的映射类型</li></ul> 
<p>TS 在 3.1 版本中，在元组和数组上的映射类型会生成新的元组和数组，并不会创建一个新的类型，这个类型上会具有 push、pop 等数组方法和数组属性</p> 
<h2 id="14%20%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6">14 声明合并</h2> 
<p>声明合并是指ts会将相同名称的声明进行合并，合并后取并集</p> 
<h3 id="14.1%20%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">14.1 基础使用</h3> 
<pre><code class="language-TypeScript">interface demo {
    name: string
}
interface demo {
    age: number
}

let obj: demo = {
    name: 'zs',
    age: 18
} // interface demo = { name: string; age: number }</code></pre> 
<h3 id="14.2%20%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86">14.2 补充知识</h3> 
<p>TypeScript的所有声明概括起来，会创建这三种实体之一：<strong>命名空间、类型</strong>和<strong>值</strong>：</p> 
<ul><li> <p>命名空间的创建实际是创建一个对象，对象的属性是在命名空间里export导出的内容；</p> </li><li> <p>类型的声明是创建一个类型并赋给一个名字；</p> </li><li> <p>值的声明就是创建一个在JavaScript中可以使用的值。</p> </li></ul> 
<table><tbody><tr><th> <p>声明类型</p> </th><th> <p>创建了命名空间</p> </th><th> <p>创建了类型</p> </th><th> <p>创建了值</p> </th></tr><tr><td> <p>Namespace</p> </td><td> <p>√</p> </td><td> <p></p> </td><td> <p>√</p> </td></tr><tr><td> <p>Class</p> </td><td> <p></p> </td><td> <p>√</p> </td><td> <p>√</p> </td></tr><tr><td> <p>Enum</p> </td><td> <p></p> </td><td> <p>√</p> </td><td> <p>√</p> </td></tr><tr><td> <p>Interface</p> </td><td> <p></p> </td><td> <p>√</p> </td><td> <p></p> </td></tr><tr><td> <p>Type Alias类型别名</p> </td><td> <p></p> </td><td> <p>√</p> </td><td> <p></p> </td></tr><tr><td> <p>Function</p> </td><td> <p></p> </td><td> <p></p> </td><td> <p>√</p> </td></tr><tr><td> <p>Variable（变量）</p> </td><td> <p></p> </td><td> <p></p> </td><td> <p>√</p> </td></tr></tbody></table> 
<h3 id="%C2%A014.3%20%E5%90%88%E5%B9%B6%E6%8E%A5%E5%8F%A3"> 14.3 合并接口</h3> 
<p>（1）多个相同命名的接口的属性应该不同，且属性名相同，属性值不同时会报错</p> 
<p>（2）对于函数成员，每个同名函数成员都会被当成这个函数的重载，且合并时后面的接口具有更高的优先级</p> 
<h3 id="14.4%20%E5%90%88%E5%B9%B6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">14.4 合并命名空间</h3> 
<pre><code class="language-TypeScript">namespace demo {
    export const name = () =&gt; {}
}
namespace demo {
    export const age = () =&gt; {}
}

// namespace demo {
//     export const name = () =&gt; {}
//     export const age = () =&gt; {}
// }</code></pre> 
<p>注： 合并的只是导出的内容，对于没有导出的同名命名空间是无法访问其属性的</p> 
<h3 id="14.5%20%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%90%88%E5%B9%B6">14.5 不同类型合并</h3> 
<p>（1）命名空间和类</p> 
<p>类的定义需要在命名空间之前</p> 
<pre><code class="language-TypeScript">class Demo {
    add() {}
}
namespace Demo {
    export const age = 18
}
console.log(Demo.prototype); // {add: ƒ, constructor: ƒ}
console.dir(Demo.prototype.constructor); // { age: 18 }</code></pre> 
<p>（2）命名空间和函数</p> 
<p>函数的定义需要在命名空间之前</p> 
<p>（3）命名空间和枚举</p> 
<p>顺序前后没有要求，但合并的只是属性和值，不自动生成映射</p> 
<h2 id="15%20%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B">15 条件类型</h2> 
<h3 id="15.1%20%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">15.1 基础使用</h3> 
<p>和三元表达式类似，T是继承自string吗？是就继承string，不是就继承number</p> 
<pre><code class="language-TypeScript">type demo&lt;T&gt; = T extends string? string: number
let a: demo&lt;'a'&gt;
let b: demo&lt;1&gt;</code></pre> 
<h3 id="15.2%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B">15.2 分布式条件类型</h3> 
<p>当待检测的类型是联合类型，则该条件类型被称为“分布式条件类型”</p> 
<pre><code class="language-TypeScript">type TypeName&lt;T&gt; = T extends string
  ? string
  : T extends number
  ? number
  : T extends boolean
  ? boolean
  : T extends undefined
  ? undefined
  : T extends Function
  ? Function
  : object;
type Type1 = TypeName&lt;() =&gt; void&gt;; // Type1的类型是Function
type Type2 = TypeName&lt;string[]&gt;; // Type2的类型是object
type Type3 = TypeName&lt;(() =&gt; void) | string[]&gt;; // Type3的类型是object | Function
 </code></pre> 
<p>类似上述的例子，Type1的逻辑为，() =&gt; void 是继承自string吗？不是则继承自number吗？不是则继承自boolean吗？以此类推，Type1的类型就是Function</p> 
<pre><code class="language-TypeScript">type Diff&lt;T, U&gt; = T extends U ? never : T;
type Test = Diff&lt;string | number | boolean, undefined | number&gt;;
// Test的类型为string | boolean
 </code></pre> 
<p>上述例子，“string | number | boolean” 中number继承自“undefined | number”所以为never，剩下两个未继承则为string | boolean</p> 
<h3 id="15.3%C2%A0%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD-infer">15.3 条件类型的类型推断-infer</h3> 
<pre><code class="language-TypeScript">type demo&lt;T&gt; = T extends any[]? T[number]: T
// T[number]表示索引访问类型获取数组元素类型
// 此种写法可以替换为：
type demo2&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T;
// infer用来推断数组元素的类型为U</code></pre> 
<h3 id="15.4%20TS%E9%A2%84%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B">15.4 TS预定义条件类型</h3> 
<pre><code class="language-TypeScript">// Exclude&lt;T, U&gt;：从 T 中去掉属于 U 的类型
type exclude&lt;T, U&gt; = Exclude&lt;T, U&gt;
let demo1: exclude&lt;string | number, number&gt; = 1 // 不能将类型“number”分配给类型“string”
let demo2: exclude&lt;string | number, number&gt; = "1"

// Extract&lt;T, U&gt;，选取 T 中属于 U 的类型
type extract = Extract&lt;string | number, number&gt; // number

// NonNullable，从 T 中去掉 null 和 undefined
type nonNullable = NonNullable&lt;string | number | undefined | null&gt;; // string | number

// ReturnType，获取函数类型返回值类型
type returnType = ReturnType&lt;() =&gt; string&gt; // string

// InstanceType，获取构造函数类型的实例类型
// type InstanceType&lt;T extends new (...args: any[]) =&gt; any&gt; = T extends abstract new (...args: any[]) =&gt; infer R? R: any;
// abstract表示定义抽象类，抽象类的作用，作为类的模板，规范了其子类定义的标准，让代码更加规范
class demo {
    constructor(public Name: string) {
        this.Name = Name
    }
}
type instanceType = InstanceType&lt;typeof demo&gt;
// demo是构造函数不是类型，所以要将构造函数转为构造函数的类型，然后推断构造函数类型的实例类型</code></pre> 
<h2 id="16%20%E5%85%A5%E6%89%8B%E8%A3%85%E9%A5%B0%E5%99%A8">16 入手装饰器</h2> 
<h3 id="16.1%20%E5%9F%BA%E7%A1%80">16.1 基础</h3> 
<p>注：装饰器仍然是一项实验性特性，未来可能有所改变，所以如果你要使用装饰器，需要在 tsconfig.json 的编译配置中开启<code>experimentalDecorators</code>，将它设为 true</p> 
<p>（1）定义</p> 
<p>装饰器是一种新的声明，它能够作用于类声明、方法、访问符、属性和参数上。使用<code>@</code>符号加一个名字来定义，名字需要是一个函数，或者求值后是一个函数，这个函数在运行的时候被调用，被装饰的声明作为参数会自动传入</p> 
<p>装饰器要紧跟在要修饰的内容前面</p> 
<p>而且所有的装饰器不能用在声明文件(.d.ts)中，和任何外部上下文中（比如 declare，关于.d.ts 和 declare，我们都会在讲声明文件一课时学习）</p> 
<pre><code class="language-TypeScript">function setProp (target) {
    // ...
}
@setProp
 </code></pre> 
<p>函数中的参数表示要修饰的目标</p> 
<p>（2）装饰器工厂</p> 
<p>也是一个函数，且返回值仍是一个函数，返回的函数作为装饰器的调用函数，如果使用装饰器工厂，在定义修饰器的时候后面加（）</p> 
<pre><code class="language-TypeScript">function setProp () {
    return function (target) {
        // ...
    }
}
 
@setProp()
 </code></pre> 
<p>（3）装饰器的组合</p> 
<p>写多个装饰器，写法可以同一行定义，使用空格隔开，也可以换行 @xx @xxx</p> 
<p>注意：</p> 
<ul><li> <p>装饰器工厂从上到下依次执行，但是只是用于返回函数但不调用函数；</p> </li><li> <p>装饰器函数从下到上依次执行，也就是执行工厂函数返回的函数，调用函数。</p> </li></ul> 
<pre><code class="language-TypeScript">function demo1() {
    console.log(1)
    return function (target) {
        console.log(4);
    }
}
function demo2() {
    console.log(2);
    return function (target) {
        console.log(3);
    }
}

@demo1()
@demo2()
class Test {} // 1 2 3 4
</code></pre> 
<p>（4）装饰器顺序</p> 
<p>类的定义中不同声明上的装饰器将按以下规定的顺序引用：</p> 
<ul><li> <p>参数装饰器，方法装饰器，访问符装饰器或属性装饰器应用到每个实例成员；</p> </li><li> <p>参数装饰器，方法装饰器，访问符装饰器或属性装饰器应用到每个静态成员；</p> </li><li> <p>参数装饰器应用到构造函数；</p> </li><li> <p>类装饰器应用到类。</p> </li></ul> 
<h3 id="16.2%20%E8%A3%85%E9%A5%B0%E5%99%A8%E7%B1%BB%E5%9E%8B">16.2 装饰器类型</h3> 
<p>（1）类装饰器</p> 
<pre><code class="language-TypeScript">let sign = null
function demo1() {
    console.log(1)
    return function (target: Function) {
        sign = target
        console.log(target.name);
    }
}

@demo1() // Test
class Test {}
console.log(sign === Test); // true

</code></pre> 
<p><span style="color:#ff9900;">装饰器函数的target其实就是你要修饰的目标本身，对于上面这个例子，也就是说target（全局变量sign被赋值为这个target）代表的是要修饰的Test这个类，所以在控制台打印这个结果为true</span></p> 
<pre><code class="language-TypeScript">function demo1() {
    return function &lt;T extends { new (...args: any[]): {} }&gt;(target: T) {
        target.prototype.age = 18
        return class extends target {
            a = 'a';
            b = 'b'
        }
    }
}

@demo1() // Test
class Test {
    property = "property";
    a: string
    constructor (arg: string) {
        this.a = arg
    }
}
interface Test {
    age: number
}
// 通过装饰器，可以修改类的原型对象和构造函数

console.log(new Test('s')); // {property: "property", a: "a", b: "b"}
 </code></pre> 
<p>通过return返回值得方式，可以对实例对象属性的修改和覆盖，且以返回属性为主</p> 
<p>（2）方法装饰器</p> 
<p>方法装饰器用来处理类中方法，它可以处理方法的属性描述符，可以处理方法定义。方法装饰器在运行时也是被当做函数调用，含 3 个参数：</p> 
<ul><li> <p>装饰静态成员时是类的构造函数，装饰实例成员时是类的原型对象；</p> </li><li> <p>成员的名字；</p> </li><li> <p>成员的属性描述符（defineProperty）。</p> </li></ul> 
<pre><code class="language-TypeScript">function demo(
    target: any,
    propertyName: string,
    propertyDescriptor: PropertyDescriptor
) {
    console.log(target);
    propertyDescriptor.enumerable = true
}

class Demo {
    _name: string = 'zs'
    @demo
    getName() {
        return this._name
    }
}
let obj = new Demo()
console.log(obj); // { _name: "zs" }
for (let key in obj) {
    console.log(obj[key]); 
}
// true: zs   ƒ () { return this._name }
// false: zs
// 如果方法装饰器返回一个值，那么会用这个值作为方法的属性描述符对象
// 也就是propertyDescriptor.enumerable = true ==》 return { enumerable = true }</code></pre> 
<p>（3）访问器装饰器</p> 
<p>类中的get和set也就是访问器，参数也是三个，且与方法装饰器相似，用法也类似，不过操作的是get和set对应的那个属性的属性描述符</p> 
<p>（4）属性装饰器</p> 
<p>有两个参数，构造函数和成员名</p> 
<p>只能判断某个类中是否声明了此名字的属性</p> 
<p>（5）参数装饰器</p> 
<p>参数装饰器有 3 个参数，前两个和方法装饰器的前两个参数一模一样：</p> 
<ul><li> <p>装饰静态成员时是类的构造函数，装饰实例成员时是类的原型对象；</p> </li><li> <p>成员的名字；</p> </li><li> <p>参数在函数参数列表中的索引。</p> </li></ul> 
<p>写在需要装饰的方法定义的（）的参数之前，且作为函数调用</p> 
<pre><code class="language-TypeScript">function required(target: any, propertName: string, index: number) {
    console.log(`修饰的是${propertName}的第${index + 1}个参数`);
  }
  class Info {
    getInfo(prefix: string, @required infoType: string): any {
      return prefix + " " + this[infoType];
    }
  }
  const info = new Info();
  info.getInfo("hihi", "age"); // 修饰的是getInfo的第2个参数</code></pre> 
<h2 id="17%20typescript%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85">17 typescript知识点补充</h2> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a95ca66b817bdc98cd73e5337ec17780/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java实现加密（一）AES加解密</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba7be2d96af45cf8b07624d8d60a5bca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java实现十大排序算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>