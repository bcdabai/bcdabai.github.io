<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kubernetes访问控制 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kubernetes访问控制" />
<meta property="og:description" content="Kubernetes访问控制 kubernetes API 访问控制
Authentication(认证)
认证方式现共有8种,可以启用一种或多种认证方式,只要有一种认证方式通过,就不再进行其它方式的认证。通常启用X509 Client Certs和Service Accout Tokens两种认证方式。Kubernetes集群有两类用户:由Kubernetes管理的Service Accounts (服务账户)和(Users Accounts) 普通账户。k8s中账号的概念不是我们理解的账号,它并不真的存在,它只是形式上存在。 Authorization(授权)
必须经过认证阶段,才到授权请求,根据所有授权策略匹配请求资源属性,决定允许或拒绝请求。授权方式现共有6种,AlwaysDeny、AlwaysAllow、ABAC、RBAC、Webhook、Node。默认集群强制开启RBAC。 Admission Control(准入控制)
用于拦截请求的一种方式,运行在认证、授权之后,是权限认证链上的最后一环,对请求API资源对象进行修改和校验。 访问k8s的API Server的客户端主要分为两类:
kubectl :用户家目录中的 .kube/config 里面保存了客户端访问API Server的密钥相关信息,这样当用kubectl访问k8s时,它就会自动读取该配置文件,向API Server发起认证,然后完成操作请求。pod:Pod中的进程需要访问API Server,如果是人去访问或编写的脚本去访问,这类访问使用的账号为:UserAccount;而Pod自身去连接API Server时,使用的账号是:ServiceAccount,生产中后者使用居多。 kubectl向apiserver发起的命令,采用的是http方式,其实就是对URL发起增删改查的操作。
kubectl proxy --port=8888 &amp; curl http://localhost:8888/api/v1/namespaces/default curl http://localhost:8888/apis/apps/v1/namespaces/default/deployments 以上两种api的区别是:
api它是一个特殊链接,只有在核心v1群组中的对象才能使用。apis 它是一般API访问的入口固定格式名。 UserAccount与serviceaccount:
用户账户是针对人而言的。 服务账户是针对运行在 pod 中的进程而言的。用户账户是全局性的。 其名称在集群各 namespace 中都是全局唯一的,未来的用户资源不会做 namespace 隔离, 服务账户是 namespace 隔离的。通常情况下,集群的用户账户可能会从企业数据库进行同步,其创建需要特殊权限,并且涉及到复杂的业务流程。 服务账户创建的目的是为了更轻量,允许集群用户为了具体的任务创建服务账户 ( 即权限最小化原则 )。 创建serviceaccount:
kubectl create serviceaccount admin kubectl describe sa admin ##此时k8s为用户自动生成认证信息,但没有授权 添加secrets到serviceaccount中" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1a058543cb067965d9bea6c408b17273/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-10T12:32:53+08:00" />
<meta property="article:modified_time" content="2020-07-10T12:32:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kubernetes访问控制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>Kubernetes访问控制</h2> 
<p><strong>kubernetes API 访问控制</strong></p> 
<p><img alt="" height="524" src="https://images2.imgbox.com/51/62/kxTE5Urm_o.png" width="1200"></p> 
<p><img alt="" height="746" src="https://images2.imgbox.com/cb/dd/awZWTWy8_o.png" width="1030"> </p> 
<p> </p> 
<p><strong>Authentication(认证)</strong></p> 
<ul><li>认证方式现共有8种,可以启用一种或多种认证方式,只要有一种认证方式通过,就不再进行其它方式的认证。通常启用X509 Client Certs和Service Accout Tokens两种认证方式。</li><li>Kubernetes集群有两类用户:由Kubernetes管理的Service Accounts (服务账户)和(Users Accounts) 普通账户。k8s中账号的概念不是我们理解的账号,它并不真的存在,它只是形式上存在。</li></ul> 
<p><strong>Authorization(授权)</strong></p> 
<ul><li>必须经过认证阶段,才到授权请求,根据所有授权策略匹配请求资源属性,决定允许或拒绝请求。授权方式现共有6种,AlwaysDeny、AlwaysAllow、ABAC、RBAC、Webhook、Node。默认集群强制开启RBAC。</li></ul> 
<p><strong>Admission Control(准入控制)</strong></p> 
<ul><li>用于拦截请求的一种方式,运行在认证、授权之后,是权限认证链上的最后一环,对请求API资源对象进行修改和校验。</li></ul> 
<p> </p> 
<p> </p> 
<p><strong>访问k8s的API Server的客户端主要分为两类:</strong></p> 
<ul><li>kubectl :用户家目录中的 .kube/config 里面保存了客户端访问API Server的密钥相关信息,这样当用kubectl访问k8s时,它就会自动读取该配置文件,向API Server发起认证,然后完成操作请求。</li><li>pod:Pod中的进程需要访问API Server,如果是人去访问或编写的脚本去访问,这类访问使用的账号为:UserAccount;而Pod自身去连接API Server时,使用的账号是:ServiceAccount,生产中后者使用居多。</li></ul> 
<p><br><strong>kubectl向apiserver发起的命令,采用的是http方式,其实就是对URL发起增删改查的操作。</strong></p> 
<pre><code class="language-bash">kubectl proxy --port=8888 &amp;
curl http://localhost:8888/api/v1/namespaces/default
curl http://localhost:8888/apis/apps/v1/namespaces/default/deployments</code></pre> 
<p>以上两种api的区别是:</p> 
<ul><li>api它是一个特殊链接,只有在核心v1群组中的对象才能使用。</li><li>apis 它是一般API访问的入口固定格式名。</li></ul> 
<p> </p> 
<p><strong>UserAccount与serviceaccount:</strong></p> 
<ul><li>用户账户是针对人而言的。 服务账户是针对运行在 pod 中的进程而言的。</li><li>用户账户是全局性的。 其名称在集群各 namespace 中都是全局唯一的,未来的用户资源不会做 namespace 隔离, 服务账户是 namespace 隔离的。</li><li>通常情况下,集群的用户账户可能会从企业数据库进行同步,其创建需要特殊权限,并且涉及到复杂的业务流程。 服务账户创建的目的是为了更轻量,允许集群用户为了具体的任务创建服务账户 ( 即权限最小化原则 )。</li></ul> 
<p> </p> 
<p><strong>创建serviceaccount:</strong></p> 
<pre><code>kubectl create serviceaccount admin</code></pre> 
<pre><code>kubectl describe sa admin         ##此时k8s为用户自动生成认证信息,但没有授权</code></pre> 
<p>添加secrets到serviceaccount中</p> 
<pre><code>kubectl patch serviceaccount admin -p '{"imagePullSecrets": [{"name":
"myregistrykey"}]}'</code></pre> 
<p>把serviceaccount和pod绑定起来:</p> 
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: myapp
  labels:
    app: myapp
spec:
  containers:
  - name: myapp
    image: reg.harbor.com/library/game2048
    ports:
    - name: http
      containerPort: 80
  serviceAccountName: admin</code></pre> 
<p>将认证信息添加到serviceAccount中,要比直接在Pod指定imagePullSecrets要安全很多。</p> 
<p> </p> 
<p><strong>创建UserAccount:</strong></p> 
<pre><code>cd /etc/kubernetes/pki/
openssl genrsa -out test.key 2048
openssl req -new -key test.key -out test.csr -subj "/CN=test"
openssl x509 -req -in test.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out test.crt -days 365
openssl x509 -in test.crt -text -noout
kubectl config set-credentials test --client-certificate=/etc/kubernetes/pki/test.crt --client-key=/etc/kubernetes/pki/test.key --embed-certs=true
kubectl config view
kubectl config set-context test@kubernetes --cluster=kubernetes --user=test
kubectl config use-context test@kubernetes
kubectl get pod</code></pre> 
<p>此时用户通过认证,但还没有权限操作集群资源,需要继续添加授权。</p> 
<p> </p> 
<p><strong>RBAC(Role Based Access Control):基于角色访问控制授权</strong></p> 
<ul><li>允许管理员通过Kubernetes API动态配置授权策略。RBAC就是用户通过角色与权限进行关联。</li><li>RBAC只有授权,没有拒绝授权,所以只需要定义允许该用户做什么即可。</li><li>RBAC包括四种类型:Role、ClusterRole、RoleBinding、ClusterRoleBinding。</li></ul> 
<p><img alt="" height="366" src="https://images2.imgbox.com/e0/2e/2tMxnY3t_o.png" width="1200"></p> 
<p> </p> 
<p><strong>RBAC的三个基本概念 :</strong></p> 
<ul><li>Subject:被作用者,它表示k8s中的三类主体, user, group, serviceAccount</li><li>Role:角色,它其实是一组规则,定义了一组对 Kubernetes API 对象的操作权限。</li><li>RoleBinding:定义了“被作用者”和“角色”的绑定关系。</li></ul> 
<p> </p> 
<p><strong>Role 和 ClusterRole</strong></p> 
<ul><li>Role是一系列的权限的集合,Role只能授予单个namespace 中资源的访问权限。</li><li>ClusterRole 跟 Role 类似,但是可以在集群中全局使用。</li></ul> 
<p>Role示例</p> 
<pre><code>kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: default
  name: myrole
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list", "create", "update", "patch", "delete"]</code></pre> 
<p> </p> 
<p><strong>RoleBinding 和 ClusterRoleBinding</strong></p> 
<ul><li>RoleBinding是将Role中定义的权限授予给用户或用户组。它包含一个subjects列表(users,groups ,service accounts),并引用该Role。</li><li>RoleBinding是对某个namespace 内授权,ClusterRoleBinding适用在集群范围内使用。</li></ul> 
<p>RoleBinding示例:</p> 
<pre><code>kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: test-read-pods
  namespace: default
subjects:
- kind: User
  name: test
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: myrole
  apiGroup: rbac.authorization.k8s.io</code></pre> 
<p>ClusterRole示例</p> 
<pre><code>kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: myclusterrole
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list", "delete", "create", "update"]
- apiGroups: ["extensions", "apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]</code></pre> 
<p> </p> 
<p><strong>使用rolebinding绑定clusterRole:</strong></p> 
<pre><code>apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: rolebind-myclusterrole
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: myclusterrole
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: test</code></pre> 
<p> </p> 
<p><strong>创建clusterrolebinding:</strong></p> 
<pre><code>apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: clusterrolebinding-myclusterrole
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: myclusterrole
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: test</code></pre> 
<p> </p> 
<p><strong>服务账户的自动化</strong></p> 
<p>服务账户准入控制器(Service account admission controller)</p> 
<ul><li>如果该 pod 没有 ServiceAccount 设置,将其 ServiceAccount 设为 default。</li><li>保证 pod 所关联的 ServiceAccount 存在,否则拒绝该 pod。</li><li>如果 pod 不包含 ImagePullSecrets 设置,那么 将 ServiceAccount 中的ImagePullSecrets 信息添加到 pod 中。</li><li>将一个包含用于 API 访问的 token 的 volume 添加到 pod 中。</li><li>将挂载于 /var/run/secrets/kubernetes.io/serviceaccount 的 volumeSource 添加到pod 下的每个容器中。</li></ul> 
<p> </p> 
<p>Token 控制器(Token controller)</p> 
<ul><li>检测服务账户的创建,并且创建相应的 Secret 以支持 API 访问。</li><li>检测服务账户的删除,并且删除所有相应的服务账户 Token Secret。</li><li>检测 Secret 的增加,保证相应的服务账户存在,如有需要,为 Secret 增加 token。</li><li>检测 Secret 的删除,如有需要,从相应的服务账户中移除引用。</li></ul> 
<p> </p> 
<p>服务账户控制器(Service account controller)</p> 
<ul><li>服务账户管理器管理各命名空间下的服务账户,并且保证每个活跃的命名空间下存在一个名为 “default” 的服务账户</li></ul> 
<p> </p> 
<p>Kubernetes 还拥有“用户组”(Group)的概念:</p> 
<ul><li>ServiceAccount对应内置“用户”的名字是: system:serviceaccount:&lt;ServiceAccount名字 &gt;</li><li>用户组所对应的内置名字是: system:serviceaccounts:&lt;Namespace名字 &gt;</li></ul> 
<p>示例：</p> 
<p>1. 表示mynamespace中的所有ServiceAccount</p> 
<pre><code>subjects:
- kind: Group
  name: system:serviceaccounts:mynamespace
  apiGroup: rbac.authorization.k8s.io</code></pre> 
<p>2. 表示整个系统中的所有ServiceAccount</p> 
<pre><code>subjects:
- kind: Group
  name: system:serviceaccounts
  apiGroup: rbac.authorization.k8s.io</code></pre> 
<p> </p> 
<p>Kubernetes 还提供了四个预先定义好的 ClusterRole 来供用户直接使用:</p> 
<ul><li>cluster-amdin</li><li>admin</li><li>edit</li><li>view</li></ul> 
<p>示例：</p> 
<pre><code>kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: readonly-default
subjects:
- kind: ServiceAccount
  name: default
  namespace: default
roleRef:
  kind: ClusterRole
  name: view
  apiGroup: rbac.authorization.k8s.io</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd24f615b85557bf89119c84a653be85/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kubernetes调度</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1aa1a492a742b7c6c84a854c4cb9ff63/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">标签传播算法解读</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>