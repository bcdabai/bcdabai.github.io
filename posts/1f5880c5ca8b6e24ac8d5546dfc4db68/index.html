<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PIG框架学习3——Redisson 实现业务接口幂等 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PIG框架学习3——Redisson 实现业务接口幂等" />
<meta property="og:description" content="零、前言 ​ 业务接口幂等问题是在开发中遇到的，如果对业务接口代码不进行幂等控制，并且在前端没有对请求进行限制的情况下，可能会出现多次对接口调用，导致错误异常的发生。就上述情况，对PIGX自带的业务接口幂等实现进行了相关的学习，相关具体内容可以参考官方文档，本文章只是作为学习笔记。
一、接口幂等概念 幂等性原本是数学上的概念，在数学中表示对同一操作的多次执行，产生的结果与仅执行一次的结果相同。
用在接口上就可以理解为：同一个接口，多次发出同一个请求，必须保证操作只执行一次。 调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。
实现接口幂等性通常需要考虑以下几个方面：
①请求参数：确保接口请求中的所有参数都是唯一的，不能重复。比如，在生成订单编号时可以使用时间戳或随机数等方式来保证唯一性
②接口设计：接口应该设计为“幂等性操作”，即无论调用多少次，结果都应该相同。例如，修改密码的接口应该设计为只能修改一次，多次修改的请求会被忽略。
③数据库操作：如果接口需要对数据库进行操作，需要确保每次操作都是幂等的。可以通过添加唯一索引或使用乐观锁等方式来避免重复操作
④错误处理：当请求出现异常时，接口应该处理异常并返回相应的错误信息。例如，当订单已经存在时，接口应该返回订单已存在的错误信息，而不是尝试再次创建订单
二、PIGX中具体实现方式 1、依赖的引入 情况①：
如果是其他项目，可以从中央仓库中引入PIGX提供的实现接口幂等的依赖
&lt;dependency&gt; &lt;groupId&gt;com.pig4cloud.plugin&lt;/groupId&gt; &lt;artifactId&gt;idempotent-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.4.0&lt;/version&gt; &lt;/dependency&gt; 引入后的包内容如下所示
情况②：
如果项目中原先使用的就是pigx框架，那么在基础平台中的pigx-common-idempotent就已经自带
我们只需要引入pigx-common服务，就可以将实现接口幂等的依赖引入
2、Redis的配置 在配置文件中进行Redis的配置，设置redis存为我们的缓存中间件
通过如下配置，Spring框架会自动启用Redis作为缓存，并将Redis服务器的连接信息配置为指定的主机名和端口号
spring: cache: type: redis data: redis: host: 127.0.0.1 port: 6379 ①spring.cache 对应的配置类是CacheProperties，这个配置项用来指定缓存的类型。在上述示例中，我们将缓存类型设置为Redis，表示使用Redis作为缓存。
② spring.data.redis：这个配置项用来指定连接Redis所需的参数。在上述示例中，我们指定了Redis服务器的主机名为127.0.0.1，端口号为`6379
3、具体使用示例 pigx主要是通过AOP去实现业务接口幂等，其最核心的就是其Idempotent注解，其使用示例如下：
@Idempotent(key = &#34;#demo.username&#34;, expireTime = 3, info = &#34;请勿重复查询&#34;) @GetMapping(&#34;/test&#34;) public String test(Demo demo) { return &#34;success&#34;; } 通过使用@Idempotent注解，当多次请求进入test方法时，框架会根据key生成的唯一标识符判断是否已经执行过相同的请求。如果已经执行过，则直接返回之前的结果；如果没有执行过，则继续执行业务逻辑。
这样可以避免重复查询或操作带来的额外开销，并确保系统在重复请求时的一致性和可靠性。
三、原理分析 1、目录结构说明 对于PIGX自带的幂等插件idempotent的目录结构如下所示：
各目录内容说明如下：
- annotation // 关于@Idempotent注解的声明 - @Idempotent - aspect	// 关于AOP的切面方法 - IdempotentAspect - exception	// 自定义异常类 - IdempotentException - expression	// sqel表达式的解析工具 - ExpressionResolver - KeyResolver - IdempotentAutoConfiguration //幂等插件配置文件 - org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1f5880c5ca8b6e24ac8d5546dfc4db68/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-21T21:10:38+08:00" />
<meta property="article:modified_time" content="2024-01-21T21:10:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PIG框架学习3——Redisson 实现业务接口幂等</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_1"></a>零、前言</h4> 
<p>​ 业务接口幂等问题是在开发中遇到的，如果对业务接口代码不进行幂等控制，并且在前端没有对请求进行限制的情况下，可能会出现多次对接口调用，导致错误异常的发生。就上述情况，对PIGX自带的业务接口幂等实现进行了相关的学习，相关具体内容可以参考<a href="https://www.yuque.com/pig4cloud/pig/wiz3dl" rel="nofollow">官方文档</a>，本文章只是作为学习笔记。</p> 
<h4><a id="_7"></a>一、接口幂等概念</h4> 
<p>幂等性原本是数学上的概念，在数学中表示对同一操作的多次执行，产生的结果与仅执行一次的结果相同。</p> 
<p>用在接口上就可以理解为：<strong>同一个接口，多次发出同一个请求，必须保证操作只执行一次。</strong> 调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。</p> 
<p>实现接口幂等性通常需要考虑以下几个方面：</p> 
<p>①请求参数：确保接口请求中的所有参数都是唯一的，不能重复。比如，在生成订单编号时可以使用时间戳或随机数等方式来保证唯一性</p> 
<p>②接口设计：接口应该设计为“幂等性操作”，即无论调用多少次，结果都应该相同。例如，修改密码的接口应该设计为只能修改一次，多次修改的请求会被忽略。</p> 
<p>③数据库操作：如果接口需要对数据库进行操作，需要确保每次操作都是幂等的。可以通过添加唯一索引或使用乐观锁等方式来避免重复操作</p> 
<p>④错误处理：当请求出现异常时，接口应该处理异常并返回相应的错误信息。例如，当订单已经存在时，接口应该返回订单已存在的错误信息，而不是尝试再次创建订单</p> 
<h4><a id="PIGX_23"></a>二、PIGX中具体实现方式</h4> 
<h5><a id="1_25"></a>1、依赖的引入</h5> 
<p>情况①：</p> 
<p>如果是其他项目，可以从中央仓库中引入PIGX提供的实现接口幂等的依赖</p> 
<pre><code class="prism language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.pig4cloud.plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>idempotent-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>引入后的包内容如下所示<br> <img src="https://images2.imgbox.com/dd/b4/yiOXpWNM_o.png" alt="在这里插入图片描述"></p> 
<p>情况②：</p> 
<p>如果项目中原先使用的就是pigx框架，那么在基础平台中的<code>pigx-common-idempotent</code>就已经自带<br> <img src="https://images2.imgbox.com/b1/05/vaqPQwxg_o.png" alt="在这里插入图片描述"></p> 
<p>我们只需要引入<code>pigx-common</code>服务，就可以将实现接口幂等的依赖引入</p> 
<h5><a id="2Redis_54"></a>2、Redis的配置</h5> 
<p>在配置文件中进行Redis的配置，设置redis存为我们的缓存中间件</p> 
<p>通过如下配置，Spring框架会自动启用Redis作为缓存，并将Redis服务器的连接信息配置为指定的主机名和端口号</p> 
<pre><code class="prism language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cache</span><span class="token punctuation">:</span>
    <span class="token key atrule">type</span><span class="token punctuation">:</span> redis
  <span class="token key atrule">data</span><span class="token punctuation">:</span>
    <span class="token key atrule">redis</span><span class="token punctuation">:</span>
      <span class="token key atrule">host</span><span class="token punctuation">:</span> 127.0.0.1
      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>
</code></pre> 
<p>①<code>spring.cache </code> 对应的配置类是<code>CacheProperties</code>，这个配置项用来指定缓存的类型。在上述示例中，我们将缓存类型设置为Redis，表示使用Redis作为缓存。</p> 
<p>②<code> spring.data.redis</code>：这个配置项用来指定连接Redis所需的参数。在上述示例中，我们指定了Redis服务器的主机名为<code>127.0.0.1</code>，端口号为`6379</p> 
<h5><a id="3_76"></a>3、具体使用示例</h5> 
<p>pigx主要是通过AOP去实现业务接口幂等，其最核心的就是其<code>Idempotent</code>注解，其使用示例如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Idempotent</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">"#demo.username"</span><span class="token punctuation">,</span> expireTime <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> info <span class="token operator">=</span> <span class="token string">"请勿重复查询"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/test"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Demo</span> demo<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过使用<code>@Idempotent</code>注解，当多次请求进入<code>test</code>方法时，框架会根据<code>key</code>生成的唯一标识符判断是否已经执行过相同的请求。如果已经执行过，则直接返回之前的结果；如果没有执行过，则继续执行业务逻辑。</p> 
<p>这样可以避免重复查询或操作带来的额外开销，并确保系统在重复请求时的一致性和可靠性。</p> 
<h4><a id="_94"></a>三、原理分析</h4> 
<h5><a id="1_96"></a>1、目录结构说明</h5> 
<p>对于<code>PIGX</code>自带的幂等插件<code>idempotent</code>的目录结构如下所示：</p> 
<p><img src="https://images2.imgbox.com/83/53/Y0GpZBXH_o.png" alt="在这里插入图片描述"></p> 
<p>各目录内容说明如下：</p> 
<pre><code class="prism language-tex">- annotation     // 关于@Idempotent注解的声明
	- @Idempotent
- aspect		 // 关于AOP的切面方法
	- IdempotentAspect
- exception		 // 自定义异常类
	- IdempotentException
- expression	 // sqel表达式的解析工具
	- ExpressionResolver
	- KeyResolver
- IdempotentAutoConfiguration   //幂等插件配置文件

- org.springframework.boot.autoconfigure.AutoConfiguration.imports   //springboot自动配置文件
</code></pre> 
<h5><a id="2idempotent___122"></a>2、<code>@idempotent </code>注解 配置详细说明</h5> 
<h6><a id="21idempotent_124"></a>2.1、<code>@idempotent</code>注解源码</h6> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Inherited</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Idempotent</span> <span class="token punctuation">{<!-- --></span>

	<span class="token comment">/**
	 * 幂等操作的唯一标识，使用spring el表达式 用#来引用方法参数
	 * @return Spring-EL expression
	 */</span>
	<span class="token class-name">String</span> <span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>

	<span class="token comment">/**
	 * 有效期 默认：1 有效期要大于程序执行时间，否则请求还是可能会进来
	 * @return expireTime
	 */</span>
	<span class="token keyword">int</span> <span class="token function">expireTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token comment">/**
	 * 时间单位 默认：s
	 * @return TimeUnit
	 */</span>
	<span class="token class-name">TimeUnit</span> <span class="token function">timeUnit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">;</span>

	<span class="token comment">/**
	 * 提示信息，可自定义
	 * @return String
	 */</span>
	<span class="token class-name">String</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"重复请求，请稍后重试"</span><span class="token punctuation">;</span>

	<span class="token comment">/**
	 * 是否在业务完成后删除key true:删除 false:不删除
	 * @return boolean
	 */</span>
	<span class="token keyword">boolean</span> <span class="token function">delKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>①<code>key</code></p> 
<p><code>key</code>参数用于生成幂等性的唯一标识符，用于识别不同的请求或操作.具体来说，当多个请求或操作需要进行幂等性处理时，每个请求或操作需要有一个唯一的标识符来区分。这个标识符可以是请求参数、请求头信息、用户ID等等，根据实际场景而定。</p> 
<p>在示例中，我们使用了SpEL表达式<code>#demo.username</code>作为唯一标识符，表示使用<code>Demo</code>对象的<code>username</code>属性作为标识符。也就是说，当多个请求的<code>demo</code>对象的<code>username</code>属性相同时，这些请求被认为是重复的，并且只有第一个请求会被执行，后续的请求会直接返回上次执行的结果。</p> 
<p>②<code>expireTime</code></p> 
<p>幂等性键过期时间，单位为秒</p> 
<p>③<code>timeUnit</code></p> 
<p>用于设置幂等性键过期时间的单位，默认是秒</p> 
<p>④<code>info</code></p> 
<p>用于描述幂等性操作的提示信息，在某些情况下，当出现重复请求时，我们需要向客户端返回一些提示信息，告知客户端该请求已经被处理过，不能重复提交。因此，通过设置<code>info</code>参数，我们可以自定义提示信息，以便更好地向客户端反馈信息。</p> 
<p>⑤<code>delKey</code></p> 
<p>是否在业务完成后删除key true:删除 false:不删除， 默认为false。</p> 
<h5><a id="3IdempotentAspect_189"></a>3、<code>IdempotentAspect</code></h5> 
<h6><a id="31IdempotentAspect_191"></a>3.1、<code>IdempotentAspect</code>源码及相关解析：</h6> 
<pre><code class="prism language-java"><span class="token comment">/**
 * The Idempotent Aspect
 *
 * @author ITyunqing
 */</span>

<span class="token comment">//Spring框架中用于声明切面（Aspect）的注解</span>
<span class="token comment">//通过在类上添加@Aspect注解，将其标识为一个切面类。切面类中可以包含各种通知（advice）和切点（pointcut），用于定义切面的具体行为和拦截规则</span>
<span class="token annotation punctuation">@Aspect</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IdempotentAspect</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//通过slf4j的LoggerFactory（日志工厂）创建一个Logger对象，用于在IdempotentAspect类中记录日志信息</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> <span class="token constant">LOGGER</span> <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">IdempotentAspect</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//创建一个名为THREAD_CACHE的私有的静态常量ThreadLocal对象</span>
    <span class="token comment">//指定了泛型类型为Map&lt;String, Object&gt;，表示该ThreadLocal对象存储的值是一个键值对的映射</span>
    <span class="token comment">//通过ThreadLocal类的withInitial方法，传入一个Supplier接口实例，该Supplier接口用于提供初始值。在这里，使用HashMap::new作为Supplier接口的实现，创建一个新的HashMap作为初始值。</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token constant">THREAD_CACHE</span> <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//定义了一个常量字符串变量RMAPCACHE_KEY，表示缓存中的键名，用于在缓存中存储幂等性相关的数据</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">RMAPCACHE_KEY</span> <span class="token operator">=</span> <span class="token string">"idempotent"</span><span class="token punctuation">;</span>

    <span class="token comment">//定义了一个常量字符串变量KEY，表示幂等性数据的键名，用于在幂等性相关的数据中标识唯一的幂等性请求</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">KEY</span> <span class="token operator">=</span> <span class="token string">"key"</span><span class="token punctuation">;</span>

    <span class="token comment">//定义了一个常量字符串变量DELKEY，表示删除缓存数据的键名，用于在缓存中标识需要删除的幂等性数据</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">DELKEY</span> <span class="token operator">=</span> <span class="token string">"delKey"</span><span class="token punctuation">;</span>

    <span class="token comment">//通过spring的自动装配功能，将Redisson对象注入到当前类中</span>
	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> <span class="token class-name">Redisson</span> redisson<span class="token punctuation">;</span>

    <span class="token comment">//通过spring的自动装配功能，将KeyResolver对象注入到当前类中</span>
	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> <span class="token class-name">KeyResolver</span> keyResolver<span class="token punctuation">;</span>

    <span class="token comment">//通过spring的自动装配功能，将一个Optional&lt;KeyStrResolver&gt;对象注入到当前类中</span>
	<span class="token comment">//KeyStrResolver的一个可选注入项，它可以包含一个非空的值，也可以为空</span>
    <span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">KeyStrResolver</span><span class="token punctuation">&gt;</span></span> keyStrResolverOptional<span class="token punctuation">;</span>

    <span class="token comment">//该注解表示定义一个切入点，使用@annotation表达式来匹配被指定注解标记的方法。在这里，切入点匹配的条件是被com.pig4cloud.pigx.common.idempotent.annotation.Idempotent注解标记的方法</span>
	<span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(com.pig4cloud.pigx.common.idempotent.annotation.Idempotent)"</span><span class="token punctuation">)</span>
	<span class="token comment">//这是一个空方法体，作为切入点的定义。它没有任何实际的逻辑操作，只是用来定义一个切入点的名称</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pointCut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">}</span>

    
    <span class="token comment">//切面的前置通知（@Before）：它在切入点方法执行之前被调用</span>
	<span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pointCut()"</span><span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">beforePointCut</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//通过RequestContextHolder类可以获取当前线程的RequestAttributes对象</span>
        <span class="token comment">//将获取到的RequestAttributes对象强制转换为ServletRequestAttributes类型。ServletRequestAttributes是RequestAttributes的子接口，扩展了一些与Servlet请求相关的方法和属性</span>
        <span class="token class-name">ServletRequestAttributes</span> requestAttributes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServletRequestAttributes</span><span class="token punctuation">)</span> <span class="token class-name">RequestContextHolder</span>
				<span class="token punctuation">.</span><span class="token function">getRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">//获取当前请求的 HttpServletRequest 对象</span>
		<span class="token class-name">HttpServletRequest</span> request <span class="token operator">=</span> requestAttributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
        <span class="token comment">//将 joinPoint 转换为 MethodSignature 对象</span>
		<span class="token class-name">MethodSignature</span> signature <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MethodSignature</span><span class="token punctuation">)</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//通过 MethodSignature 对象获取到当前方法的 Method 对象</span>
        <span class="token class-name">Method</span> method <span class="token operator">=</span> signature<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//如果当前方法上没有使用注解@Idempotent，则return返回</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Idempotent</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">//如果当前方法上有使用注解@Idempotent，获得该注解信息</span>
        <span class="token comment">//通过调用 getAnnotation() 方法并传入 Idempotent.class 作为参数，可以获取到该方法上的 Idempotent 注解的实例对象</span>
		<span class="token class-name">Idempotent</span> idempotent <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Idempotent</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token class-name">String</span> key<span class="token punctuation">;</span>

		<span class="token comment">// 若没有配置 幂等 标识编号，则使用 url + 参数列表作为区分（作为生成幂等性的唯一标识符）</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasLength</span><span class="token punctuation">(</span>idempotent<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">String</span> url <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getRequestURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">String</span> argString <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>joinPoint<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			key <span class="token operator">=</span> url <span class="token operator">+</span> argString<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 使用jstl 规则区分（具体会在expression中进行讲解）</span>
			key <span class="token operator">=</span> keyResolver<span class="token punctuation">.</span><span class="token function">resolver</span><span class="token punctuation">(</span>idempotent<span class="token punctuation">,</span> joinPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

        <span class="token comment">//StrUtil.COLON：字符串常量：冒号 {@code ":"}</span>
        <span class="token comment">//如果keyStrResolverOptional存在，则设置key的值为KeyStrResolver调用extract(key, StrUtil.COLON)方法的结果值</span>
        <span class="token comment">//即在原先key的基础的前面加上租户id：</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>keyStrResolverOptional<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			key <span class="token operator">=</span> keyStrResolverOptional<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token constant">COLON</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

        <span class="token comment">//获取注解idempotent的有效期</span>
		<span class="token keyword">long</span> expireTime <span class="token operator">=</span> idempotent<span class="token punctuation">.</span><span class="token function">expireTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//获取注解idempotent的提示信息</span>
		<span class="token class-name">String</span> info <span class="token operator">=</span> idempotent<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//获取注解idempotent的时间单位</span>
		<span class="token class-name">TimeUnit</span> timeUnit <span class="token operator">=</span> idempotent<span class="token punctuation">.</span><span class="token function">timeUnit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//获取注解idempotent的是否在业务完成后删除key</span>
		<span class="token keyword">boolean</span> delKey <span class="token operator">=</span> idempotent<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// do not need check null</span>
        <span class="token comment">//RMapCache 是 Redisson 提供的一个接口，用于表示一个带有过期时间的分布式 Map 缓存，RMapCache 继承自 RMap 接口，提供了一些额外的方法，可以设置和获取缓存的过期时间，以及进行相关的缓存操作</span>
        <span class="token comment">//通过 redisson 对象调用 getMapCache(RMAPCACHE_KEY) 方法，传入参数 RMAPCACHE_KEY 来获取对应的缓存对象</span>
        <span class="token comment">//RMAPCACHE_KEY 是表示缓存的键值，可能是一个字符串或其他适当的类型</span>
		<span class="token class-name">RMapCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> rMapCache <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getMapCache</span><span class="token punctuation">(</span><span class="token constant">RMAPCACHE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//获取当前系统的时间，并将其转化为字符串，将其中的T替换为“ ”</span>
        <span class="token class-name">String</span> value <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"T"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
        <span class="token class-name">Object</span> v1<span class="token punctuation">;</span>
        <span class="token comment">//如果当前对应的键key已经有缓存对象，则抛出异常，异常信息为"[idempotent]:" + info</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> rMapCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// had stored</span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IdempotentException</span><span class="token punctuation">(</span><span class="token string">"[idempotent]:"</span> <span class="token operator">+</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">//使用 synchronized 关键字来对代码块进行同步，确保在多线程环境下的安全性</span>
        <span class="token comment">//通过 synchronized(this) 来锁定当前对象，以保证同一时间只有一个线程可以进入这个代码块</span>
		<span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">//将键值对放入缓存中</span>
            <span class="token comment">//该方法会返回之前关联到 key 上的值，如果该值为 null，则表示插入成功</span>
			v1 <span class="token operator">=</span> rMapCache<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> expireTime<span class="token punctuation">,</span> timeUnit<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//如果 v1 不为 null，即 putIfAbsent 返回了一个非空值，说明之前已经存在相同的键值对，此时抛出一个 IdempotentException 异常，表示幂等性校验失败</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> v1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IdempotentException</span><span class="token punctuation">(</span><span class="token string">"[idempotent]:"</span> <span class="token operator">+</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
            <span class="token comment">//如果 v1 为 null，表示 putIfAbsent 成功插入了新的键值对，记录一条日志信息，并打印当前存储的 key、value、过期时间等信息</span>
			<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
				<span class="token constant">LOGGER</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"[idempotent]:has stored key={},value={},expireTime={}{},now={}"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> expireTime<span class="token punctuation">,</span>
						timeUnit<span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
        
        <span class="token comment">//在当前线程中使用 ThreadLocal 来创建一个线程本地的 Map 对象，并将 key 和 delKey 存储到其中</span>
		<span class="token comment">//通过 THREAD_CACHE.get() 方法获取当前线程绑定的 Map&lt;String, Object&gt; 对象，存储到 map 变量中</span>
		<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token constant">THREAD_CACHE</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//将键值对 KEY 和对应的变量 key 存储到 map 中</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token constant">KEY</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//将键值对 DELKEY 和对应的变量 delKey 存储到 map 中</span>
		map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token constant">DELKEY</span><span class="token punctuation">,</span> delKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

    <span class="token comment">//切面的后置通知（@After）：它在切入点方法执行之后被调用</span>
	<span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"pointCut()"</span><span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPointCut</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//从当前线程中获取之前存储的 map 对象，并将其存储到 map 变量中</span>
		<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token constant">THREAD_CACHE</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
        <span class="token comment">//判断 map 是否为空，如果为空，则直接返回，不执行后续操作</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//获取一个名为 RMAPCACHE_KEY 的 RMapCache&lt;Object, Object&gt; 实例</span>
		<span class="token class-name">RMapCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> mapCache <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getMapCache</span><span class="token punctuation">(</span><span class="token constant">RMAPCACHE_KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//判断该 RMapCache 是否为空。如果为空，则直接返回，不执行后续操作</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mapCache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//从 map 中获取 key ，并将 key 转换为字符串类型保存到 key 变量中</span>
		<span class="token class-name">String</span> key <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">KEY</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//从 map 中获取 delKey， 将 delKey 强制转换为布尔型保存到 delKey 变量中</span>
		<span class="token keyword">boolean</span> delKey <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">DELKEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//delKey为真，则调用 mapCache.fastRemove(key) 方法从 RMapCache 中删除指定的键值对，并记录一条日志信息</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>delKey<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			mapCache<span class="token punctuation">.</span><span class="token function">fastRemove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token constant">LOGGER</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"[idempotent]:has removed key={}"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">//从当前线程中删除 map 对象。这样做是为了避免在下次请求时出现数据混淆的情况</span>
		<span class="token constant">THREAD_CACHE</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<h6><a id="32_368"></a>3.2、相关内容补充</h6> 
<p>① ThreadLocal</p> 
<p>ThreadLocal 是一个 Java 类，它提供了线程局部变量的支持。每个线程都可以独立地访问和修改自己的线程局部变量，而不会干扰其他线程的变量。</p> 
<p>使用 ThreadLocal 可以解决多线程并发访问共享变量时可能出现的线程安全问题。通过将数据存储在 ThreadLocal 对象中，每个线程都有自己独立的副本，线程之间的数据互不干扰。</p> 
<p>在使用 ThreadLocal 时，通常的做法是创建一个 ThreadLocal 对象，并使用 <code>set()</code> 方法来设置当前线程的变量值，使用 <code>get()</code> 方法来获取当前线程的变量值。可以通过 <code>remove()</code> 方法来清除当前线程的变量值。</p> 
<p>② Redisson</p> 
<p>Redisson是一个Java Redis客户端，提供了简单易用的API接口，支持分布式锁、分布式集合、分布式对象等功能。它基于Redis客户端（Jedis、Lettuce）封装了一系列的分布式操作接口，使得Java开发者可以方便地使用Redis实现分布式应用程序。</p> 
<p>Redisson的主要特点如下：</p> 
<ul><li>对Redis的高效封装：Redisson对Redis客户端进行了高效的封装，提供了简单易用的API接口，使得Java开发者可以方便地实现复杂的分布式应用程序。</li><li>分布式锁：Redisson提供了分布式锁的实现，支持可重入锁、公平锁、联锁、红锁等多种类型的锁，并且保证了锁的正确性和高可用性。</li><li>分布式集合：Redisson支持分布式Set、List、Queue、Deque、Map、SortedSet等集合类型的操作，可以方便地实现分布式计算、消息队列等功能。</li><li>分布式对象：Redisson支持分布式ExecutorService、ScheduledExecutorService、Semaphore、CountDownLatch、ReadWriteLock等对象类型的操作，可以方便地实现分布式任务调度、并发控制等功能。</li></ul> 
<p>③MethodSignature</p> 
<p>在 Spring AOP 中，joinPoint 是一个连接点（即程序执行过程中能够插入额外代码的点），它封装了当前方法的相关信息，包括方法名、参数等。</p> 
<p>MethodSignature 是 JoinPoint 的一个子类，它用于表示方法签名，即方法名和参数类型等信息。通过 MethodSignature 对象，我们可以获取到当前方法的 Method 对象，进而获取该方法的返回值类型、参数列表等信息。</p> 
<p>④KeyStrResolver</p> 
<p>其是一个接口，源码如下</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">KeyStrResolver</span> <span class="token punctuation">{<!-- --></span>

	<span class="token comment">/**
	 * 字符串加工
	 * @param in 输入字符串
	 * @param split 分割符
	 * @return 输出字符串
	 */</span>
	<span class="token class-name">String</span> <span class="token function">extract</span><span class="token punctuation">(</span><span class="token class-name">String</span> in<span class="token punctuation">,</span> <span class="token class-name">String</span> split<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/**
	 * 字符串获取
	 * @return 模块返回字符串
	 */</span>
	<span class="token class-name">String</span> <span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>其具体实现类<code>TenantKeyStrResolver</code>的源码如下所示</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @author lengleng
 * @date 2020/9/29
 * &lt;p&gt;
 * 租户字符串处理（方便其他模块获取）
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TenantKeyStrResolver</span> <span class="token keyword">implements</span> <span class="token class-name">KeyStrResolver</span> <span class="token punctuation">{<!-- --></span>

	<span class="token comment">/**
	 * 传入字符串增加 租户编号:in
	 * @param in 输入字符串
	 * @param split 分割符
	 * @return
	 */</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">extract</span><span class="token punctuation">(</span><span class="token class-name">String</span> in<span class="token punctuation">,</span> <span class="token class-name">String</span> split<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token class-name">TenantContextHolder</span><span class="token punctuation">.</span><span class="token function">getTenantId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> split <span class="token operator">+</span> in<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/**
	 * 返回当前租户ID
	 * @return
	 */</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token class-name">TenantContextHolder</span><span class="token punctuation">.</span><span class="token function">getTenantId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="4IdempotentException_461"></a>4、<code>IdempotentException</code>自定义异常类</h5> 
<h6><a id="41IdempotentException_463"></a>4.1、<code>IdempotentException</code>自定义异常类源码</h6> 
<pre><code class="prism language-java"><span class="token comment">//RuntimeException 运行时异常的实现类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IdempotentException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeException</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">//无参构造器</span>
	<span class="token keyword">public</span> <span class="token class-name">IdempotentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

    <span class="token comment">//有参构造器1</span>
	<span class="token keyword">public</span> <span class="token class-name">IdempotentException</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

    <span class="token comment">//有参构造器2</span>
	<span class="token keyword">public</span> <span class="token class-name">IdempotentException</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

    <span class="token comment">//有参构造器3</span>
	<span class="token keyword">public</span> <span class="token class-name">IdempotentException</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">super</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

    <span class="token comment">//有参构造器4</span>
	<span class="token keyword">protected</span> <span class="token class-name">IdempotentException</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> cause<span class="token punctuation">,</span> <span class="token keyword">boolean</span> enableSuppression<span class="token punctuation">,</span>
			<span class="token keyword">boolean</span> writableStackTrace<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> cause<span class="token punctuation">,</span> enableSuppression<span class="token punctuation">,</span> writableStackTrace<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<h5><a id="5KeyResolver_501"></a>5、唯一标志处理器<code>KeyResolver</code></h5> 
<h6><a id="51_KeyResolver_503"></a>5.1、 <code>KeyResolver</code>源码及解析</h6> 
<p>其中定义了一个解析处理key的抽象方法</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">KeyResolver</span> <span class="token punctuation">{<!-- --></span>

	<span class="token comment">/**
	 * 解析处理 key
	 * @param idempotent 接口注解标识
	 * @param point 接口切点信息
	 * @return 处理结果
	 */</span>
	<span class="token class-name">String</span> <span class="token function">resolver</span><span class="token punctuation">(</span><span class="token class-name">Idempotent</span> idempotent<span class="token punctuation">,</span> <span class="token class-name">JoinPoint</span> point<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

</code></pre> 
<h6><a id="52ExpressionResolver_524"></a>5.2、<code>ExpressionResolver</code>源码及其解析</h6> 
<p><code>ExpressionResolver</code>是<code>KeyResolver</code>的实现类，其主要的作用就是进行key的抽取，优先根据 spel 处理</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @author lengleng
 * &lt;p&gt;
 * 默认key 抽取， 优先根据 spel 处理
 * @date 2020-09-25
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExpressionResolver</span> <span class="token keyword">implements</span> <span class="token class-name">KeyResolver</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//创建一个 SpEL 表达式解析器实例SpelExpressionParser</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SpelExpressionParser</span> <span class="token constant">PARSER</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpelExpressionParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//创建一个 LocalVariableTableParameterNameDiscoverer 对象，用于获取方法参数的名称</span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">LocalVariableTableParameterNameDiscoverer</span> <span class="token constant">DISCOVERER</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LocalVariableTableParameterNameDiscoverer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//重写父类keyResolver的resolver方法</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">resolver</span><span class="token punctuation">(</span><span class="token class-name">Idempotent</span> idempotent<span class="token punctuation">,</span> <span class="token class-name">JoinPoint</span> point<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//通过 point.getArgs() 获取方法的参数数组</span>
		<span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arguments <span class="token operator">=</span> point<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取方法参数的名称数组</span>
		<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> params <span class="token operator">=</span> <span class="token constant">DISCOVERER</span><span class="token punctuation">.</span><span class="token function">getParameterNames</span><span class="token punctuation">(</span><span class="token function">getMethod</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//创建一个 StandardEvaluationContext 对象，用于提供表达式求值的上下文环境</span>
		<span class="token class-name">StandardEvaluationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardEvaluationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//如果方法参数的名称数组不为空且长度大于 0，则遍历参数名称数组，将参数名和对应的参数值存储到 context 中</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>params <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> params<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> params<span class="token punctuation">.</span>length<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				context<span class="token punctuation">.</span><span class="token function">setVariable</span><span class="token punctuation">(</span>params<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">,</span> arguments<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
        <span class="token comment">//使用 PARSER.parseExpression(idempotent.key()) 解析 idempotent.key() 字符串为一个 SpEL 表达式，并返回一个 Expression 对象</span>
		<span class="token class-name">Expression</span> expression <span class="token operator">=</span> <span class="token constant">PARSER</span><span class="token punctuation">.</span><span class="token function">parseExpression</span><span class="token punctuation">(</span>idempotent<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//调用 Expression 对象的 getValue() 方法，传入 context 和期望的结果类型 String.class，以获取表达式的求值结果</span>
        <span class="token keyword">return</span> expression<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/**
	 * 根据切点解析方法信息
	 * @param joinPoint 切点信息
	 * @return Method 原信息
	 */</span>
	<span class="token keyword">private</span> <span class="token class-name">Method</span> <span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//通过 joinPoint.getSignature() 获取切入点的方法签名，然后将其转换为 MethodSignature 类型，并赋值给 signature 变量</span>
		<span class="token class-name">MethodSignature</span> signature <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MethodSignature</span><span class="token punctuation">)</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//从方法签名中获取切入点方法，并赋值给 method 变量</span>
        <span class="token class-name">Method</span> method <span class="token operator">=</span> signature<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//判断切入点方法所在的类是否是一个接口。如果是接口，则执行以下代码块</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//通过 joinPoint.getTarget().getClass() 获取切入点目标对象的类，并使用该类调用 getDeclaredMethod() 方法来获取具体实现类中与切入点方法相同名称和参数类型的方法，并将得到的方法赋值给 method 变量</span>
				method <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span>joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
						method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> <span class="token operator">|</span> <span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//如果在获取具体实现类中的方法时抛出了 SecurityException 或 NoSuchMethodException 异常，会捕获并抛出一个具有该异常的 RuntimeException 异常</span>
				<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
        <span class="token comment">//返回获取到的方法对象</span>
		<span class="token keyword">return</span> method<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="6IdempotentAutoConfiguration_595"></a>6、幂等插件配置文件<code>IdempotentAutoConfiguration</code></h5> 
<h6><a id="61_597"></a>6.1、配置文件源码</h6> 
<pre><code class="prism language-java"><span class="token comment">//标记该类为配置类</span>
<span class="token comment">//proxyBeanMethods = false，表示Spring 将不会为配置类的方法生成代理对象，这样可以避免额外的代理开销</span>
<span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token comment">//指定在特定自动配置类RedisAutoConfiguration之后进行自动配置</span>
<span class="token annotation punctuation">@AutoConfigureAfter</span><span class="token punctuation">(</span><span class="token class-name">RedisAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IdempotentAutoConfiguration</span> <span class="token punctuation">{<!-- --></span>

	<span class="token comment">/**
	 * 生成IdempotentAspect切面类的bean实例
	 * 切面 拦截处理所有 @Idempotent
	 * @return Aspect
	 */</span>
	<span class="token annotation punctuation">@Bean</span>
	<span class="token keyword">public</span> <span class="token class-name">IdempotentAspect</span> <span class="token function">idempotentAspect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IdempotentAspect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/**
	 * 生成key 解析器的bean实例
	 * key 解析器
	 * @return KeyResolver
	 */</span>
	<span class="token annotation punctuation">@Bean</span>
	<span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span><span class="token class-name">KeyResolver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token class-name">KeyResolver</span> <span class="token function">keyResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ExpressionResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="7AutoConfigurationimports_633"></a>7、<code>AutoConfiguration.imports</code></h5> 
<h6><a id="71_635"></a>7.1、源码</h6> 
<pre><code>com.pig4cloud.pigx.common.idempotent.IdempotentAutoConfiguration
</code></pre> 
<h6><a id="72_643"></a>7.2、作用</h6> 
<p><code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 是一个 Spring Boot 的属性，用于指定需要在自动配置类中导入的其他配置类。</p> 
<p>在 Spring Boot 中，自动配置是一种机制，它根据应用程序的依赖和配置信息，自动创建并配置相应的 Bean 实例。而 <code>AutoConfiguration.imports</code> 属性则提供了一种扩展机制，允许开发人员在自动配置类中导入其他配置类，以实现更为灵活和定制化的自动配置。</p> 
<p>具体来说，<code>AutoConfiguration.imports</code> 属性是一个字符串数组，每个元素表示一个需要导入的配置类的全限定名。在自动配置过程中，Spring Boot 会自动加载这些配置类，并将它们合并到当前上下文中，以实现更全面的自动配置。</p> 
<h5><a id="8_653"></a>8、补充</h5> 
<p>1.请求开始前，根据key查询 查到结果：报错 | 未查到结果：存入key-value-expireTime</p> 
<p>2.请求结束后，直接删除key ，不管key是否存在，直接删除 是否删除，可配置</p> 
<p>3.expireTime过期时间，防止一个请求卡死，会一直阻塞，超过过期时间，自动删除</p> 
<p>过期时间要大于业务执行时间，需要大概评估下;</p> 
<p>4.此方案直接切的是接口请求层面。</p> 
<p>5.过期时间需要大于业务执行时间，否则业务请求1进来还在执行中，前端未做遮罩，或者用户跳转页面后再回来做重复请求2，在业务层面上看，结果依旧是不符合预期的。</p> 
<p>6.建议delKey = false。即使业务执行完，也不删除key，强制锁expireTime的时间。预防5的情况发生。</p> 
<p>7.实现思路：同一个请求ip和接口，相同参数的请求，在expireTime内多次请求，只允许成功一次。</p> 
<p>8.页面做遮罩，数据库层面的唯一索引，先查询再添加，等处理方式应该都处理下。</p> 
<p>9.此注解只用于幂等，不用于锁，100个并发这种压测，会出现问题，在这种场景下也没有意义，实际中用户也不会出现1s或者3s内手动发送了50个或者100个重复请求,或者弱网下有100个重复请求；</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/78871b3f242bbdb5e0c500d0691c7afe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">看书标记【R语言数据分析项目精解：理论、方法、实战 9】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac656ea75c1f301672a51c097fd87148/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构与算法】归并排序详解：归并排序算法，归并排序非递归实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>