<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于图的图像分割（Graph-Based Image Segmentation） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于图的图像分割（Graph-Based Image Segmentation）" />
<meta property="og:description" content="一、介绍
基于图的图像分割（Graph-Based Image Segmentation），论文《Efficient Graph-Based Image Segmentation》，P. Felzenszwalb, D. Huttenlocher，International Journal of Computer Vision, Vol. 59, No. 2, September 2004
论文下载和论文提供的C&#43;&#43;代码在这里。
Graph-Based Segmentation是经典的图像分割算法，其作者Felzenszwalb也是提出DPM（Deformable Parts Model）算法的大牛。
Graph-Based Segmentation算法是基于图的贪心聚类算法，实现简单，速度比较快，精度也还行。不过，目前直接用它做分割的应该比较少，很多算法用它作垫脚石，比如Object Propose的开山之作《Segmentation as Selective Search for Object Recognition》就用它来产生过分割（over segmentation）。
二、图的基本概念
因为该算法是将图像用加权图抽象化表示，所以补充图的一些基本概念。
1、图
是由顶点集V（vertices）和边集E（edges）组成，表示为G=(V, E)，顶点v∈V，在论文即为单个的像素点，连接一对顶点的边(vi, vj)具有权重w(vi, vj)，本文中的意义为顶点之间的不相似度（dissimilarity），所用的是无向图。
2、树
特殊的图，图中任意两个顶点，都有路径相连接，但是没有回路。如下图中加粗的边所连接而成的图。如果看成一团乱连的珠子，只保留树中的珠子和连线，那么随便选个珠子，都能把这棵树中所有的珠子都提起来。
如果顶点i和h这条边也保留下来，那么顶点h,i,c,f,g就构成了一个回路。
3、最小生成树（minimum spanning tree）
特殊的树，给定需要连接的顶点，选择边权之和最小的树。
论文中，初始化时每一个像素点都是一个顶点，然后逐渐合并得到一个区域，确切地说是连接这个区域中的像素点的一个MST。如下图，棕色圆圈为顶点，线段为边，合并棕色顶点所生成的MST，对应的就是一个分割区域。分割后的结果其实就是森林。
三、相似性
既然是聚类算法，那应该依据何种规则判定何时该合二为一，何时该继续划清界限呢？对于孤立的两个像素点，所不同的是灰度值，自然就用灰度的距离来衡量两点的相似性，本文中是使用RGB的距离，即
当然也可以用perceptually uniform的Luv或者Lab色彩空间，对于灰度图像就只能使用亮度值了，此外，还可以先使用纹理特征滤波，再计算距离，比如先做Census Transform再计算Hamming distance距离。
四、全局阈值 &gt;&gt; 自适应阈值，区域的类内差异、类间差异
上面提到应该用亮度值之差来衡量两个像素点之间的差异性。对于两个区域（子图）或者一个区域和一个像素点的相似性，最简单的方法即只考虑连接二者的边的不相似度。如下图，已经形成了棕色和绿色两个区域，现在通过紫色边来判断这两个区域是否合并。那么我们就可以设定一个阈值，当两个像素之间的差异（即不相似度）小于该值时，合二为一。迭代合并，最终就会合并成一个个区域，效果类似于区域生长：星星之火，可以燎原。
举例说明：
对于上右图，显然应该聚成上左图所示的3类：高频区h,斜坡区s,平坦区p。
如果我们设置一个全局阈值，那么如果h区要合并成一块的话，那么该阈值要选很大，但是那样就会把p和s区域也包含进来，分割结果太粗。如果以p为参考，那么阈值应该选特别小的值，那样的话p区是会合并成一块，但是h区就会合并成特别特别多的小块，如同一面支离破碎的镜子，分割结果太细。显然，全局阈值并不合适，那么自然就得用自适应阈值。对于p区该阈值要特别小，s区稍大，h区巨大。
先来两个定义，原文依据这两个附加信息来得到自适应阈值。
一个区域内的类内差异Int(C)：
可以近似理解为一个区域内部最大的亮度差异值，定义是MST中不相似度最大的一条边。
俩个区域的类间差异Diff(C1, C2)：
即连接两个区域所有边中，不相似度最小的边的不相似度，也就是两个区域最相似的地方的不相似度。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/708ed379ca581a6648aacd58729fb74c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-06T12:34:49+08:00" />
<meta property="article:modified_time" content="2017-12-06T12:34:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于图的图像分割（Graph-Based Image Segmentation）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>一、介绍</strong></p> 
<p>基于图的图像分割（Graph-Based Image Segmentation），论文《Efficient Graph-Based Image Segmentation》，P. Felzenszwalb, D. Huttenlocher，International Journal of Computer Vision, Vol. 59, No. 2, September 2004</p> 
<p>论文下载和论文提供的C++代码在<a target="_blank" href="http://cs.brown.edu/~pff/segment/" rel="nofollow noopener noreferrer">这里</a>。<br> </p> 
<p>Graph-Based Segmentation是经典的图像分割算法，其作者Felzenszwalb也是提出DPM（Deformable Parts Model）算法的大牛。</p> 
<p>Graph-Based Segmentation算法是基于图的贪心聚类算法，实现简单，速度比较快，精度也还行。不过，目前直接用它做分割的应该比较少，很多算法用它作垫脚石，比如Object Propose的开山之作《Segmentation as Selective Search for Object Recognition》就用它来产生过分割（over segmentation）。<br> </p> 
<p><strong>二、图的基本概念</strong></p> 
<p>因为该算法是将图像用加权图抽象化表示，所以补充图的一些基本概念。</p> 
<p>1、图</p> 
<p>是由顶点集V（vertices）和边集E（edges）组成，表示为<em><strong>G=(V, E)</strong></em>，顶点<em><strong>v∈V</strong></em>，在论文即为<u>单个的像素点</u>，连接一对顶点的边<em><strong>(vi, vj)</strong></em>具有权重<em><strong>w(vi, vj)</strong></em>，本文中的意义为顶点之间的<u>不相似度（dissimilarity）</u>，所用的是无向图。</p> 
<p>2、树</p> 
<p>特殊的图，图中任意两个顶点，都有路径相连接，但是没有回路。如下图中加粗的边所连接而成的图。如果看成一团乱连的珠子，只保留树中的珠子和连线，那么随便选个珠子，都能把这棵树中所有的珠子都提起来。</p> 
<p>如果顶点i和h这条边也保留下来，那么顶点h,i,c,f,g就构成了一个回路。<br> </p> 
<p><img src="https://images2.imgbox.com/96/83/9vH5Lqba_o.png" alt=""><br> </p> 
<p>3、最小生成树（minimum spanning tree）</p> 
<p>特殊的树，给定需要连接的顶点，选择边权之和最小的树。<br> </p> 
<p>论文中，初始化时每一个像素点都是一个顶点，然后逐渐合并得到一个区域，确切地说是连接这个区域中的像素点的一个MST。如下图，棕色圆圈为顶点，线段为边，合并棕色顶点所生成的MST，对应的就是一个分割区域。分割后的结果其实就是森林。<br> </p> 
<p><img src="https://images2.imgbox.com/f9/36/SeTzu5A2_o.png" alt=""><br> </p> 
<p><br> </p> 
<p><strong>三、相似性</strong></p> 
<p>既然是聚类算法，那应该依据何种规则判定何时该合二为一，何时该继续划清界限呢？对于孤立的两个像素点，所不同的是灰度值，自然就用灰度的距离来衡量两点的相似性，本文中是使用RGB的距离，即<br> </p> 
<p><img src="https://images2.imgbox.com/5d/70/FAnuk4JG_o.png" alt=""><br> </p> 
<p>当然也可以用perceptually uniform的Luv或者Lab色彩空间，对于灰度图像就只能使用亮度值了，此外，还可以先使用纹理特征滤波，再计算距离，比如先做Census Transform再计算Hamming distance距离。<br> </p> 
<p><strong>四、全局阈值 &gt;&gt; 自适应阈值，区域的类内差异、类间差异</strong></p> 
<p>上面提到应该用亮度值之差来衡量两个像素点之间的差异性。对于两个区域（子图）或者一个区域和一个像素点的相似性，最简单的方法即只考虑连接二者的边的不相似度。如下图，已经形成了棕色和绿色两个区域，现在通过紫色边来判断这两个区域是否合并。那么我们就可以设定一个阈值，当两个像素之间的差异（即不相似度）小于该值时，合二为一。迭代合并，最终就会合并成一个个区域，效果类似于区域生长：星星之火，可以燎原。<br> </p> 
<p><img src="https://images2.imgbox.com/33/60/IJ6hIzSe_o.png" alt=""><br> </p> 
<p>举例说明：</p> 
<p><img src="https://images2.imgbox.com/63/80/umDIhfUE_o.png" alt=""><br> </p> 
<p>对于上右图，显然应该聚成上左图所示的3类：高频区h,斜坡区s,平坦区p。</p> 
<p>如果我们设置一个全局阈值，那么如果h区要合并成一块的话，那么该阈值要选很大，但是那样就会把p和s区域也包含进来，分割结果太粗。如果以p为参考，那么阈值应该选特别小的值，那样的话p区是会合并成一块，但是h区就会合并成特别特别多的小块，如同一面支离破碎的镜子，分割结果太细。显然，全局阈值并不合适，那么自然就得用自适应阈值。对于p区该阈值要特别小，s区稍大，h区巨大。</p> 
<p>先来两个定义，原文依据这两个附加信息来得到自适应阈值。<br> </p> 
<p>一个区域内的类内差异<em><strong>Int(C)</strong></em>：</p> 
<p><img src="https://images2.imgbox.com/fb/11/UQOlhF68_o.png" alt=""><br> </p> 
<p>可以近似理解为一个区域内部最大的亮度差异值，定义是MST中不相似度最大的一条边。<br> </p> 
<p>俩个区域的类间差异<em><strong>Diff(C1, C2)</strong></em>：</p> 
<p><img src="https://images2.imgbox.com/c4/b6/3ZQM3fG5_o.png" alt=""><br> </p> 
<p>即连接两个区域所有边中，不相似度最小的边的不相似度，也就是两个区域最相似的地方的不相似度。<br> </p> 
<p>直观的判断，当：</p> 
<p><img src="https://images2.imgbox.com/b5/46/Tod7Pwjx_o.png" alt=""><br> </p> 
<p>时，两个区域应当合并！</p> 
<p><strong>五、算法步骤</strong></p> 
<p>1、计算每一个像素点与其8邻域或4邻域的不相似度。</p> 
<p><img src="https://images2.imgbox.com/75/87/ml8OlaWt_o.png" alt=""><br> </p> 
<p>如上图，实线为只计算4领域，加上虚线就是计算8邻域，由于是无向图，按照从左到右，从上到下的顺序计算的话，只需要计算右图中灰色的线即可。<br> </p> 
<p>2、将边按照不相似度non-decreasing排列（从小到大）排序得到<em><strong>e1, e2, ..., en</strong></em>。</p> 
<p>3、选择<em><strong>ei</strong></em></p> 
<p>4、对当前选择的边<strong>ej</strong>（vi和vj不属于一个区域）进行合并判断。设其所连接的顶点为<em><strong>(vi, vj)</strong></em>，</p> 
<p>if 不相似度小于二者内部不相似度：</p> 
<p>5、更新阈值以及类标号</p> 
<p>else：</p> 
<p>6、如果i &lt; n，则按照排好的顺序，选择下一条边转到Step 4，否则结束。</p> 
<p><strong><br> </strong></p> 
<p><strong>六、论文提供的代码</strong></p> 
<p>打开本博文最开始的连接，进入论文网站，下载C++代码。下载后，make编译程序。命令行运行格式：</p> 
<p></p> 
<pre><code class="language-cpp">/********************************************
sigma  对原图像进行高斯滤波去噪
k      控制合并后的区域的数量
min:   后处理参数，分割后会有很多小区域，当区域像素点的个数小于min时，选择与其差异最小的区域合并
input  输入图像（PPM格式）
output 输出图像（PPM格式）

sigma: Used to smooth the input image before segmenting it.
k:     Value for the threshold function.
min:   Minimum component size enforced by post-processing.
input: Input image.
output:Output image.

Typical parameters are sigma = 0.5, k = 500, min = 20.
Larger values for k result in larger components in the result.
*/
./segment sigma k min input output</code></pre> 
<br> 
<strong>七、OpenCV3.3 cv::ximgproc::segmentation::GraphSegmentation类</strong> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/segmentation.hpp</code></pre> 
<br> 
<br> 
<p></p> 
<p><br> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0927a3724ea177845b69ab9354748f61/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ffmpeg 提取关键帧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1d4ca6fbd88258c0bc3eb4d80a3826a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">08、PHP会不会过几年不流行了</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>