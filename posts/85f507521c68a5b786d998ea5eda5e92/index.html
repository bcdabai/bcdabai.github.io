<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring是如何管理Bean - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring是如何管理Bean" />
<meta property="og:description" content="常常听老师说容器，容器是什么？spring中是如何体现的？一直有疑惑，这两天看了一下Spring管理bean的Demo，对于Spring中的容器有了简单的认识。
我们知道，容器是一个空间的概念，一般理解为可盛放物体的地方。在Spring容器通常理解为BeanFactory或者ApplicationContext。我们知道spring的IOC容器能够帮我们创建对象，对象交给spring管理之后我们就不用手动去new对象。
BeanFactory与ApplicationContext的区别是什么？
BeanFactory采用了工厂设计模式，负责读取bean配置文档，管理bean的加载，实例化，维护bean之间的依赖关系，负责bean的声明周期。而ApplicationContext除了提供上述BeanFactory所能提供的功能之外，还提供了更完整的框架功能：国际化支持、aop、事务等。同时BeanFactory在解析配置文件时并不会初始化对象,只有在使用对象getBean()才会对该对象进行初始化，而ApplicationContext在解析配置文件时对配置文件中的所有对象都初始化了,getBean()方法只是获取对象的过程。
因此我们一般在使用的时候尽量使用ApplicationContext。
ApplicationContext是如何管理Bean呢？下面这个Demo简单模仿了这个原理：
1.建立一个类PersonServiceBean，并在xml文件中进行配置。
public class PersonServiceBean implements PersonService { public void save(){ System.out.println(&#34;我是save()方法&#34;); } } &lt;bean id=&#34;personService&#34; class=&#34;cn.itcast.service.impl.PersonServiceBean&#34;&gt;&lt;/bean&gt; 2.建立类BeanDefinition，提供一个构造函数，将其作为每个bean的公共转型类。
public class BeanDefinition { private String id;	private String className; public BeanDefinition(String id, String className) { this.id = id; this.className = className; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getClassName() { return className; } public void setClassName(String className) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/85f507521c68a5b786d998ea5eda5e92/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-02-28T20:16:18+08:00" />
<meta property="article:modified_time" content="2015-02-28T20:16:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring是如何管理Bean</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p> </p> 
<p>   常常听老师说容器，容器是什么？spring中是如何体现的？一直有疑惑，这两天看了一下Spring管理bean的Demo，对于Spring中的容器有了简单的认识。</p> 
<p>   我们知道，容器是一个空间的概念，一般理解为可盛放物体的地方。在Spring容器通常理解为BeanFactory或者ApplicationContext。我们知道spring的IOC容器能够帮我们创建对象，对象交给spring管理之后我们就不用手动去new对象。</p> 
<p>   BeanFactory与ApplicationContext的区别是什么？</p> 
<p>   BeanFactory采用了工厂设计模式，负责读取bean配置文档，管理bean的加载，实例化，维护bean之间的依赖关系，负责bean的声明周期。而ApplicationContext除了提供上述BeanFactory所能提供的功能之外，还提供了更完整的框架功能：国际化支持、aop、事务等。同时BeanFactory在解析配置文件时并不会初始化对象,只有在使用对象getBean()才会对该对象进行初始化，而ApplicationContext在解析配置文件时对配置文件中的所有对象都初始化了,getBean()方法只是获取对象的过程。</p> 
<p>   因此我们一般在使用的时候尽量使用ApplicationContext。</p> 
<p>   ApplicationContext是如何管理Bean呢？下面这个Demo简单模仿了这个原理：</p> 
<p>   1.建立一个类PersonServiceBean，并在xml文件中进行配置。</p> 
<p>    </p> 
<pre class="has"><code class="language-java">	public class PersonServiceBean implements PersonService   {
		public void save(){
			System.out.println("我是save()方法");
		}
	}
</code></pre> 
<pre class="has"><code class="language-html">&lt;bean id="personService" class="cn.itcast.service.impl.PersonServiceBean"&gt;&lt;/bean&gt;</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>  2.建立类BeanDefinition，提供一个构造函数，将其作为每个bean的公共转型类。</p> 
<p> </p> 
<pre class="has"><code class="language-java">public class BeanDefinition {
	
	private String id;	
	private String className;
	
	public BeanDefinition(String id, String className) {
		this.id = id;
		this.className = className;
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getClassName() {
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}
}
</code></pre> 
<p> </p> 
<p> </p> 
<p>   3.建立容器类tgbApplicationContext。</p> 
<p> </p> 
<p>    </p> 
<pre class="has"><code class="language-java">	/**
	 * 测试spring容器
	 * @author hegang
	 *
	 */
	public class tgbClassPathXMLApplicationContext {
		
		private List&lt;BeanDefinition&gt; beanDefines =new ArrayList&lt;BeanDefinition&gt;();
		private Map&lt;String,Object&gt; sigletons =new HashMap&lt;String,Object&gt;();
		
		
		public tgbClassPathXMLApplicationContext(String filename){
			this.readXML(filename);
			this.instanceBeans();
		}
	
		/**
		 * 完成bean的实例化
		 */
		private void instanceBeans() {
			for(BeanDefinition beanDefinition :  beanDefines){
				try {
					if(beanDefinition.getClassName()!=null &amp;&amp; !"".equals(beanDefinition.getClassName().trim())){
					  sigletons.put(beanDefinition.getClassName(),Class.forName(beanDefinition.getClassName()).newInstance());
					}
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
			}
			
		}
	
		/**
		 * 读取xml配置文件
		 * @param filename
		 */
		private void readXML(String filename) {
			SAXReader saxReader = new SAXReader(); //创建读取器
			Document document =null;
			try{
				URL xmlpath = this.getClass().getClassLoader().getResource(filename);
				document =saxReader.read(xmlpath);
				Map&lt;String,String&gt; nsMap =new HashMap&lt;String,String&gt;();
				nsMap.put("ns","http://www.springframework.org/schema/beans"); //加入命名空间
				XPath xsub = document.createXPath("//ns:beans/ns:bean"); //创建beans/bean查询路径
				 xsub.setNamespaceURIs(nsMap); // 设置命名空间
				List&lt;Element&gt; beans = xsub.selectNodes(document); // 获取文档下所有的bean节点
				for(Element element:beans){
					String id =element.attributeValue("id"); // 获取id属性值
					String clazz =element.attributeValue("class"); // 获取class属性值
					BeanDefinition beanDefine =new BeanDefinition(id,clazz);
					beanDefines.add(beanDefine);
				}
			
			} catch(Exception e){
				e.printStackTrace();
			}
			
		}
		
		/**
		 * 获取bean实例
		 * @param beanName
		 * @return
		 */
		public Object getBean(String beanName){
			return this.sigletons.get(beanName);
		}
	}
</code></pre> 
<p>     该类中拥有一个List&lt;BeanDefinition&gt;泛型集合类以及一个Map&lt;String,Object&gt;集合。通过查看代码我们知道这个容器类所做的事情如下：</p> 
<p>    a.读取配置文件bean.xml，并根据文件中bean的id,class属性实例化一个BeanDefinition，装入泛型集合中。</p> 
<p>    b.通过循环+反射，将List&lt;BeanDefinition&gt;中的bean加入到Map&lt;String,Object&gt;中，这里用反射将bean中的className属性转换为一个实例化的bean对象加入到了Map中。</p> 
<p>    c.提供一个对外的接口，通过传入参数获取该bean。</p> 
<p>  4.下面就是通过容器类获取具体bean的代码了。</p> 
<p> </p> 
<pre class="has"><code class="language-java">	public class SpringTest {
		@Test
		public void instanceSpring(){
			tgbClassPathXMLApplicationContext ctx =new tgbClassPathXMLApplicationContext("beans.xml");	
			PersonService personService =(PersonService) ctx.getBean("personService");
			personService.save();
		}
	}
</code></pre> 
<p>通过调用save()方法可以调到PersonServiceBean中去。</p> 
<p> </p> 
<p>通过这样的Demo，可以清楚看到Spring容器做的事情。它在初始化的时候将配置文件中bean以及相对应关系的配置都加入到ApplicationContext,通过一系列的转换将这些bean实例化，bean被它进行了管理，所以ApplicationContext就扮演了一个容器的角色。</p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f453b626bd81b16fd2e880134ee34a47/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【饥荒】介绍一些组件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2646e6bb655297b8da97762268b69e7b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PS和EPS</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>