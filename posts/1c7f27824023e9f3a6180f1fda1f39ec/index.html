<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GoLang EASY 游戏框架 之 应用项目&#43;教程 02 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GoLang EASY 游戏框架 之 应用项目&#43;教程 02" />
<meta property="og:description" content="1 Program Examples Overview 用easy 实现的 服务端 和客户端样例。
simple 项目构建了比较完备的目录结构，可以作为空项目拿到项目中直接应用。
传送门：https://github.com/slclub/easy
位置：
examples/simple examples/simple_client 2 Simple 比较简单的源码样例；
这是一个简单的服务端，你可以直接拿它做项目，扩展开发即可。
最基本的easy框架使用简单的游戏架构，不包含数据层；simple代码以极简化为主，项目扩展要 结构化一些目录多是空的 2.1 simple.Server 项目名：simple
目录结构：
-conf // 配置 --controller 控制器也就是解读消息的入口 --callback 放置一些基本的回调函数，如链接创建，服务平滑关闭等 --login 登陆模块 --player 用户玩家 --store 商铺 --world 大世界相关 --initialize 初始化，工程启动执行一次；与运行时无关 --lservers 接入easy监听服务 l 是 ```listen``` 当让也可以接入其他的监听服务 --message 消息定义 --models 数据模型，尽量只有数据结构的定义，和基本验证 --services 游戏逻辑存放区域，主要的逻辑都可以放在这里 --vendors 您项目的一些必要基础功能性的包，或者接入第三方包（且这个包需要配置等）；// 并非是替代 go mod 注意： go mod 中也有一个verdor 且会产生vendor文件夹 我们这里的vendors 仅仅是common 通用，基础，标准等的意思 这里的包之间互相依赖也少，或者说机会是无 比较大（功能性）的包引入后，总需要配置一些东西，甚至和自己的配置参数相关，那么放在这里改造一下（符合工程写法，结构要求等）就比较合适了 运行命令：go build &amp;&amp; ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1c7f27824023e9f3a6180f1fda1f39ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-12T14:28:48+08:00" />
<meta property="article:modified_time" content="2023-12-12T14:28:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GoLang EASY 游戏框架 之 应用项目&#43;教程 02</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1 Program Examples Overview</h3> 
<p>用easy 实现的 服务端 和客户端样例。</p> 
<p>simple 项目构建了比较完备的目录结构，可以作为空项目拿到项目中直接应用。</p> 
<p></p> 
<p>传送门：<a href="https://github.com/slclub/easy" title="https://github.com/slclub/easy">https://github.com/slclub/easy</a></p> 
<p>位置：</p> 
<ul><li>        examples/simple</li><li>        examples/simple_client</li></ul> 
<p>        </p> 
<p></p> 
<h3>2 Simple</h3> 
<p>比较简单的源码样例；</p> 
<p>这是一个简单的服务端，你可以直接拿它做项目，扩展开发即可。</p> 
<ul><li>最基本的easy框架使用</li><li>简单的游戏架构，不包含数据层；</li><li>simple代码以极简化为主，项目扩展要 结构化一些</li><li>目录多是空的</li></ul> 
<h4>2.1 simple.Server</h4> 
<p>项目名：simple</p> 
<p>目录结构：</p> 
<pre><code>-conf // 配置
--controller 控制器也就是解读消息的入口
    --callback 放置一些基本的回调函数，如链接创建，服务平滑关闭等
    --login 登陆模块
    --player 用户玩家
    --store 商铺
    --world 大世界相关
--initialize 初始化，工程启动执行一次；与运行时无关
--lservers 接入easy监听服务 l 是 ```listen``` 当让也可以接入其他的监听服务
--message 消息定义
--models 数据模型，尽量只有数据结构的定义，和基本验证
--services 游戏逻辑存放区域，主要的逻辑都可以放在这里
--vendors 您项目的一些必要基础功能性的包，或者接入第三方包（且这个包需要配置等）；// 并非是替代 go mod
    注意：
    go mod 中也有一个verdor 且会产生vendor文件夹
    我们这里的vendors 仅仅是common 通用，基础，标准等的意思
    这里的包之间互相依赖也少，或者说机会是无
    比较大（功能性）的包引入后，总需要配置一些东西，甚至和自己的配置参数相关，那么放在这里改造一下（符合工程写法，结构要求等）就比较合适了</code></pre> 
<p>运行命令：<span style="color:#fe2c24;">go build &amp;&amp; ./simple</span></p> 
<p></p> 
<h4>2.2 simple.Client</h4> 
<p>项目名：simple_client</p> 
<p>运行命令：<span style="color:#fe2c24;">go build &amp;&amp; ./simple_client</span></p> 
<p>测试simple服务端对应的客户端样例工程</p> 
<p></p> 
<h3>3 项目代码</h3> 
<h4>3.1 main</h4> 
<p>在main中Start() 中easy.Serv 可以传入多个服务组件。lservers.Server1()监听的是websocket，lservers.Server2()监听的是TCP。一个应用服务程序，可以容易的监听多个端口服务，且任意多个，多个同一类型的协议也是支持的。</p> 
<p>我们在easy.Serv统一阻断主goroutine，其他可以直接使用内置的go 方法直接调用，没有任何高级花哨的调用方式。</p> 
<pre><code class="language-Go">
import (
	"github.com/slclub/easy"
	"simple/initialize"
	"simple/lservers"
)

func main() {
	initialize.Init()
	Start()
}

func Start() {
	easy.Serv(
		lservers.Server1(), // websocket 监听服务 可以有多个
		lservers.Server2(), // tcp 服务
	)
}</code></pre> 
<p></p> 
<h4>3.2 lservers(listening service)</h4> 
<p>监听端口的服务，代码也很少，这里样例代码就没有按服务分文件。直接上源码：</p> 
<pre><code class="language-Go">func Server1() servers.ListenServer {
	return server1
}

func Server2() servers.ListenServer {
	return server2
}

func InitListenServer() {
	server1 = servers.NewWSServer()

	server1.Init(option.OptionWith(&amp;agent.Gate{
		Addr:            ":18080",
		Protocol:        typehandle.ENCRIPT_DATA_JSON,
		PendingWriteNum: 2000,
		LittleEndian:    true,
		MaxConnNum:      2000,
	}).Default(option.DEFAULT_IGNORE_ZERO))

	server2 = servers.NewTCPServer()
	server2.Init(option.OptionWith(&amp;agent.Gate{
		Addr:            ":18081",
		Protocol:        typehandle.ENCRIPT_DATA_JSON,
		PendingWriteNum: 2000,
		LittleEndian:    true,
		MaxConnNum:      2000,
	}).Default(option.DEFAULT_IGNORE_ZERO))
}</code></pre> 
<ul><li>servers 是easy的监听服务基础包package</li><li>server1 :=servers.NewWSServer() 是new一个websocket 服务</li><li>server1.Init()初始化</li><li>option.OptionWith 是我们的一个开放配置选择包，为了易用和方便，配置方式多样，默认值等而开发。</li></ul> 
<p><strong>参数：</strong></p> 
<p>        Addr：监听地址</p> 
<p>        Protocol：选用编码组件（快捷换编码的方式，换自定义编码组件在后续章节会说明）</p> 
<p>        PendingWriteNum：排队消息长度</p> 
<p>        LittleEndian：true=小端，false=大端</p> 
<p>        MaxConnNum：最大链接数</p> 
<p>        option.DEFAULT_IGNORE_ZERO: 如果赋值0值，或者没有给相应字段赋值，则使用默认值。其中Default方法等于use，类似中间件</p> 
<p></p> 
<h4>3.3 controller</h4> 
<p><strong>handle </strong></p> 
<p>控制器层面，MVC中的C，接收消息的下一步就是它了。用controller/login模块举例</p> 
<pre><code class="language-Go">

import (
	"github.com/slclub/easy/nets/agent"
	"reflect"
	"simple/vendors/log8q"
)

func HandleLogin(agent1 agent.Agent, arg any) {

	log8q.Log().Info("WS controller.Handle.Login info: ", reflect.TypeOf(arg).Elem().Name())
}

func HandleLoginTcp(agent2 agent.Agent, arg any) {
	log8q.Log().Info("TCP controller.Handle.Login info: ", reflect.TypeOf(arg).Elem().Name())
}
</code></pre> 
<p>分别是websocket 和Tcp 的login handle，它们做的事情是一样。写handle接收消息就是这样简单。</p> 
<ul><li>agent.Agent ： 理解成连接，可以绑定到你的对象上，业务逻辑所用的handle，你也可以再次封装下，函数签名类似：HandleXXX(player *Player, msg Any) 。</li><li>arg any ：是接收客户端的消息，我们直接粗暴的用reflect，查出它的结构体名字，以做测试验证。</li></ul> 
<p><strong>binding</strong></p> 
<p>做完handle需要将它与消息以及监听的服务绑定，绑定方法也很简单。直接上代码</p> 
<pre><code class="language-Go">
import (
	"github.com/slclub/easy/typehandle"
	"simple/controller/login"
	"simple/lservers"
	"simple/message/ID"
	"simple/message/json"
)

func InitBindingRoute() {
	r1 := lservers.Server1().Router()
	r1.Register(ID.LOGIN_REQ, &amp;json.LoginReq{}, typehandle.HandleMessage(login.HandleLogin))
}

func InitBindingRouteServer2() {
	r2 := lservers.Server2().Router()
	r2.Register(ID.LOGIN_REQ, &amp;json.LoginReq{}, typehandle.HandleMessage(login.HandleLoginTcp))
}</code></pre> 
<p>直接使用监听服务的Router() 获取路由，使用路由Register()绑定 消息ID，消息体，和消息handle，其中handle是可选的（response返回给客户端的消息是不需要handle的）。<br> 这样哪个监听服务对应哪个handle也是一目了然。</p> 
<p><strong>callback</strong></p> 
<p>这仅仅是笔者自己起的模块名字，目的是为了给连接Open和Close做监听回调的handle。与业务handle有点不同，少了个消息参数。</p> 
<pre><code class="language-Go">
import (
	"github.com/slclub/easy/nets/agent"
	"github.com/slclub/easy/servers"
	"simple/lservers"
	"simple/vendors/log8q"
)

func RegisterCallerToLservers() {
	lservers.Server1().Hook().Append(servers.CONST_AGENT_NEW, handleOnConnNew)
	lservers.Server1().Hook().Append(servers.CONST_AGENT_CLOSE, handleOnConnClose)
	lservers.Server1().Hook().Append(servers.CONST_SERVER_CLOSE, handleOnServerClose)

	lservers.Server2().Hook().Append(servers.CONST_AGENT_NEW, handleOnConnNew)
	lservers.Server2().Hook().Append(servers.CONST_AGENT_CLOSE, handleOnConnClose)
}

func handleOnConnNew(ag agent.Agent) {
	log8q.Log().Info("[CONNECTION.NEW] server create an new connection")
}

func handleOnConnClose(ag agent.Agent) {
	log8q.Log().Info("[CONNECTION.CLOSE] server closed an old connection")
}

// the current listening server is closing
// smoothly shutdown the server
func handleOnServerClose(ag agent.Agent) {
	// ag == nil
	// 执行一些 平滑停服务的逻辑
}
</code></pre> 
<p>同样需要我们用具体的监听服务，去调用钩子对象去Append添加链接的handle。需要注意我们使用的是Append，一个钩子可以添加多个handle。笔者相信为了性能大多数人仅仅会用一个，来完善自己链接在线逻辑。</p> 
<p>长链接的监听服务，可以共用此handle。</p> 
<p><strong>其他的controller </strong></p> 
<p>就是我们按照逻辑流程划分的业务模块，不再赘述了。</p> 
<p></p> 
<h3>4 vendors</h3> 
<p>笔者把一些引用第三方，需要我们简单封装，或配置等的，或者自己实现单独功能依赖少的包，可以放在vendors 下面作为third package存放之地。这个目录名不要用vendor，它是go默认使用vendor，这以前是一套项目部署方案，有了go mod 它就不香了。后来的很多人甚至没见过它。记得不要混淆vendors 和vendor。</p> 
<h4>4.1 log8q</h4> 
<p>笔者使用了自己写的log8q这个日志库，zip虽然性能高且强大，总有些记不住，特别依赖goland等IDE才好用一些。</p> 
<p>笔者按照log4j的思想撸了个日志的轮子，可配置级别，支持官方的log接口，也有自己简单的使用Info，Debug，Warn，Error，Fatal等级别，每一个传参数的方式都与fmt.Println类似。可以设置日志保留时间（30 * 86400）=30天。</p> 
<p>主打一个简单，易用，组件化，性能够用就好。</p> 
<p></p> 
<h3>5 Message 消息</h3> 
<p>由于go的import特性等，建议将消息定义为单独一个package，减少loop，import的概率。</p> 
<p>在message/register.go 中也是注册消息，是不是熟悉，在controller中我们也有消息注册绑定，其实全放在controller里注册也是可以的，在这里我们主要就是注册哪些没有handle的消息</p> 
<pre><code class="language-Go">
import (
	"simple/lservers"
	"simple/message/ID"
	"simple/message/json"
)

// 将不需要handle 处理的消息 尽量放在这里注册
// 可以将所有注册消息都放在这里也可以
func Init() {
	InitJson()
	InitProtobuf()
}

func InitJson() {
	r1 := lservers.Server1().Router()
	r1.Register(ID.LOGIN_RES, &amp;json.LoginRes{}, nil)

	r2 := lservers.Server2().Router()
	r2.Register(ID.LOGIN_RES, &amp;json.LoginRes{}, nil)
}

func InitProtobuf() {
	//r2 := lservers.SimpleServ1.Router()
}
</code></pre> 
<p></p> 
<h3>6 总结</h3> 
<p>致于其它的目录结构也没什么内容，介绍目录的结构的tree中说明就足够了。你有自己习惯可以改吗，不是硬性要求。整体看下来代码量很少的吧。</p> 
<p>一个完整的单机游戏工程，就构建完毕了。数据库缓存等就用gorm等即可。</p> 
<p>致于说单线程开发，在golang中使用 go 和channel 可以轻易的实现，安全稳定的goroutine。并不需要我们过多的给予定式封装，反而难用且性能低下。不同的需求用不同的方式去控制线程就好了。</p> 
<p>go是一个高并发语言，开携程像吃饭喝水一样简单，控制好携程数量可能稍有难度。所以我们不要被单线程思想限制住，并发控制好共有资源，代码也不见的就一定复杂，一定多。性能强力，资源占用少，开发方便，稳定性高就好了，服务器也就这点追求了。当然你能让你的代码变现金，那是比较实在的最求出发点不太一样是吧。</p> 
<p></p> 
<p>后期我会发布Aoi的package，单线程的，且与handle多线程互通有无。位置 EASY.vendors/aoi。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/691e1cbf3fe91ae4bd212597b7f4088b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Redis】深入理解 Redis 常用数据类型源码及底层实现（1.结构与源码概述）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce4db05aef21ccb58699bcb86d6f33a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">实现CompletableFuture的返回数据，放入每个list中</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>