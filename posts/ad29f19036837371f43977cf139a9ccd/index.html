<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构期末复习-哈希表的6种构造方法和4种解决冲突方法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构期末复习-哈希表的6种构造方法和4种解决冲突方法" />
<meta property="og:description" content="文章目录 哈希表的概念哈希表散列法存储的基本思想优点缺点哈希方法(杂凑法)哈希函数(杂凑函数)哈希表(杂凑表)冲突哈希方法必须解决以下两个问题构造好的哈希函数制定一个好的解决冲突的方案 哈希函数的构造方法直接定址法Hash(key)=a * key&#43;b (a、b为常数)优点缺点举例 除留余数法Hash(key)=key mod p (p是一个整数)特点关键技巧 数字分析法特点举例 平方取中法特点理由例 折叠法特点适用于移位法间界叠加法举例 随机数法Hash(key)=random(key) (random为随机函数)适用于 构造哈希函数的原则 解决冲突的方法开放定址法设计思路1.线性探测法Hi=(Hash(key)&#43;di) mod m ( 1≤i &lt; m )举例线性探测法的优点线性探测法的缺点 二次探测法伪随机探测法 链地址法(拉链法)基本思想举例 再哈希法(双哈希函数法)优点缺点 建立公共溢出区思路 冲突是不是比较讨厌 哈希表的查找效率分析几点结论 哈希表的概念 哈希表 即散列存储结构
散列法存储的基本思想 建立关键码字与其存储位置的对应关系，或者说，由关键码的值决定数据的存储地址
优点 查找速度极快 (O(1)) ,查找效率与元素个数n无关！
缺点 空间效率低
哈希方法(杂凑法) 选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。
哈希函数(杂凑函数) 哈希方法中使用的转换函数称为哈希函数(杂凑函数)
哈希表(杂凑表) 按上述思想构造的表称为哈希表(杂凑表)
冲突 通常关键码的集合比哈希地址集合大得多，因而经过哈希函数变换后，可能将不同的关键码映射到同一个哈希地址上，这种现象称为冲突。
哈希方法必须解决以下两个问题 构造好的哈希函数 所选函数尽可能简单，以便提高转换速度；所选函数对关键码计算出的地址，应在哈希地址集中大致均匀分布，以减少空间浪费。 制定一个好的解决冲突的方案 查找时，如果从哈希函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其它相关单元。
哈希函数的构造方法 直接定址法 Hash(key)=a * key&#43;b (a、b为常数) 优点 以关键码key的某个线性函数值为哈希地址，不会产生冲突.
缺点 要占用连续地址空间，空间效率低。
举例 除留余数法 Hash(key)=key mod p (p是一个整数) 特点 以关键码除以p的余数作为哈希地址。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ad29f19036837371f43977cf139a9ccd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-02T15:05:03+08:00" />
<meta property="article:modified_time" content="2021-07-02T15:05:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构期末复习-哈希表的6种构造方法和4种解决冲突方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">哈希表的概念</a></li><li><ul><li><a href="#_2" rel="nofollow">哈希表</a></li><li><a href="#_4" rel="nofollow">散列法存储的基本思想</a></li><li><a href="#_6" rel="nofollow">优点</a></li><li><a href="#_9" rel="nofollow">缺点</a></li><li><a href="#_12" rel="nofollow">哈希方法(杂凑法)</a></li><li><a href="#_16" rel="nofollow">哈希函数(杂凑函数)</a></li><li><a href="#_20" rel="nofollow">哈希表(杂凑表)</a></li><li><a href="#_24" rel="nofollow">冲突</a></li><li><a href="#_28" rel="nofollow">哈希方法必须解决以下两个问题</a></li><li><ul><li><a href="#_29" rel="nofollow">构造好的哈希函数</a></li><li><a href="#_34" rel="nofollow">制定一个好的解决冲突的方案</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_38" rel="nofollow">哈希函数的构造方法</a></li><li><ul><li><a href="#_40" rel="nofollow">直接定址法</a></li><li><ul><li><a href="#Hashkeya__keyb__ab_41" rel="nofollow">Hash(key)=a * key+b (a、b为常数)</a></li><li><a href="#_42" rel="nofollow">优点</a></li><li><a href="#_46" rel="nofollow">缺点</a></li><li><a href="#_49" rel="nofollow">举例</a></li></ul> 
   </li><li><a href="#_52" rel="nofollow">除留余数法</a></li><li><ul><li><a href="#Hashkeykey_mod_p___p_54" rel="nofollow">Hash(key)=key mod p (p是一个整数)</a></li><li><a href="#_55" rel="nofollow">特点</a></li><li><a href="#_58" rel="nofollow">关键</a></li><li><a href="#_61" rel="nofollow">技巧</a></li></ul> 
   </li><li><a href="#_65" rel="nofollow">数字分析法</a></li><li><ul><li><a href="#_66" rel="nofollow">特点</a></li><li><a href="#_69" rel="nofollow">举例</a></li></ul> 
   </li><li><a href="#_73" rel="nofollow">平方取中法</a></li><li><ul><li><a href="#_75" rel="nofollow">特点</a></li><li><a href="#_78" rel="nofollow">理由</a></li><li><a href="#_81" rel="nofollow">例</a></li></ul> 
   </li><li><a href="#_84" rel="nofollow">折叠法</a></li><li><ul><li><a href="#_85" rel="nofollow">特点</a></li><li><a href="#_88" rel="nofollow">适用于</a></li><li><a href="#_91" rel="nofollow">移位法</a></li><li><a href="#_94" rel="nofollow">间界叠加法</a></li><li><a href="#_97" rel="nofollow">举例</a></li></ul> 
   </li><li><a href="#_103" rel="nofollow">随机数法</a></li><li><ul><li><a href="#Hashkeyrandomkey___random_104" rel="nofollow">Hash(key)=random(key) (random为随机函数)</a></li><li><a href="#_105" rel="nofollow">适用于</a></li></ul> 
   </li><li><a href="#_109" rel="nofollow">构造哈希函数的原则</a></li></ul> 
  </li><li><a href="#_116" rel="nofollow">解决冲突的方法</a></li><li><ul><li><a href="#_117" rel="nofollow">开放定址法</a></li><li><ul><li><a href="#_118" rel="nofollow">设计思路</a></li><li><a href="#1_121" rel="nofollow">1.线性探测法</a></li><li><ul><li><a href="#HiHashkeydi_mod_m__1i__m__123" rel="nofollow">Hi=(Hash(key)+di) mod m ( 1≤i &lt; m )</a></li><li><a href="#_130" rel="nofollow">举例</a></li><li><a href="#_134" rel="nofollow">线性探测法的优点</a></li><li><a href="#_137" rel="nofollow">线性探测法的缺点</a></li></ul> 
    </li><li><a href="#_141" rel="nofollow">二次探测法</a></li><li><a href="#_151" rel="nofollow">伪随机探测法</a></li></ul> 
   </li><li><a href="#_155" rel="nofollow">链地址法(拉链法)</a></li><li><ul><li><a href="#_156" rel="nofollow">基本思想</a></li><li><a href="#_159" rel="nofollow">举例</a></li></ul> 
   </li><li><a href="#_163" rel="nofollow">再哈希法(双哈希函数法)</a></li><li><ul><li><a href="#_168" rel="nofollow">优点</a></li><li><a href="#_171" rel="nofollow">缺点</a></li></ul> 
   </li><li><a href="#_174" rel="nofollow">建立公共溢出区</a></li><li><ul><li><a href="#_176" rel="nofollow">思路</a></li></ul> 
   </li><li><a href="#_180" rel="nofollow">冲突是不是比较讨厌</a></li></ul> 
  </li><li><a href="#_187" rel="nofollow">哈希表的查找效率分析</a></li><li><ul><li><a href="#_201" rel="nofollow">几点结论</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>哈希表的概念</h2> 
<h3><a id="_2"></a>哈希表</h3> 
<p>即散列存储结构</p> 
<h3><a id="_4"></a>散列法存储的基本思想</h3> 
<p>建立关键码字与其存储位置的对应关系，或者说，由关键码的值决定数据的存储地址</p> 
<h3><a id="_6"></a>优点</h3> 
<p>查找速度极快 (O(1)) ,查找效率与元素个数n无关！</p> 
<h3><a id="_9"></a>缺点</h3> 
<p>空间效率低</p> 
<h3><a id="_12"></a>哈希方法(杂凑法)</h3> 
<p>选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。</p> 
<h3><a id="_16"></a>哈希函数(杂凑函数)</h3> 
<p>哈希方法中使用的转换函数称为哈希函数(杂凑函数)</p> 
<h3><a id="_20"></a>哈希表(杂凑表)</h3> 
<p>按上述思想构造的表称为哈希表(杂凑表)</p> 
<h3><a id="_24"></a>冲突</h3> 
<p>通常关键码的集合比哈希地址集合大得多，因而经过哈希函数变换后，可能将不同的关键码映射到同一个哈希地址上，这种现象称为冲突。</p> 
<h3><a id="_28"></a>哈希方法必须解决以下两个问题</h3> 
<h4><a id="_29"></a>构造好的哈希函数</h4> 
<ul><li>所选函数尽可能简单，以便提高转换速度；</li><li>所选函数对关键码计算出的地址，应在哈希地址集中大致均匀分布，以减少空间浪费。</li></ul> 
<h4><a id="_34"></a>制定一个好的解决冲突的方案</h4> 
<p>查找时，如果从哈希函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其它相关单元。</p> 
<h2><a id="_38"></a>哈希函数的构造方法</h2> 
<h3><a id="_40"></a>直接定址法</h3> 
<h4><a id="Hashkeya__keyb__ab_41"></a>Hash(key)=a * key+b (a、b为常数)</h4> 
<h4><a id="_42"></a>优点</h4> 
<p>以关键码key的某个线性函数值为哈希地址，不会产生冲突.</p> 
<h4><a id="_46"></a>缺点</h4> 
<p>要占用连续地址空间，空间效率低。</p> 
<h4><a id="_49"></a>举例</h4> 
<p><a href="https://imgtu.com/i/R60jmD" rel="nofollow"><img src="https://images2.imgbox.com/5b/e7/D1G6RrtN_o.png" alt="R60jmD.png"></a></p> 
<h3><a id="_52"></a>除留余数法</h3> 
<h4><a id="Hashkeykey_mod_p___p_54"></a>Hash(key)=key mod p (p是一个整数)</h4> 
<h4><a id="_55"></a>特点</h4> 
<p>以关键码除以p的余数作为哈希地址。</p> 
<h4><a id="_58"></a>关键</h4> 
<p>如何选取合适的p？</p> 
<h4><a id="_61"></a>技巧</h4> 
<p>若设计的哈希表长为m，则一般取p≤m且为质数(也可以是不包含小于20质因子的合数)</p> 
<h3><a id="_65"></a>数字分析法</h3> 
<h4><a id="_66"></a>特点</h4> 
<p>某关键字的某几位组合成哈希地址。所选的位应当是：各种符号在该位上出现的频率大致相同</p> 
<h4><a id="_69"></a>举例</h4> 
<p><a href="https://imgtu.com/i/R6DfIJ" rel="nofollow"><img src="https://images2.imgbox.com/f9/df/wCm1sgVb_o.png" alt="R6DfIJ.png"></a></p> 
<h3><a id="_73"></a>平方取中法</h3> 
<h4><a id="_75"></a>特点</h4> 
<p>对关键码平方后，按哈希表大小，取中间的若干位作为哈希地址</p> 
<h4><a id="_78"></a>理由</h4> 
<p>因为中间几位与数据的每一位都相关</p> 
<h4><a id="_81"></a>例</h4> 
<p>2589的平方值为6702921，可以取中间的029为地址</p> 
<h3><a id="_84"></a>折叠法</h3> 
<h4><a id="_85"></a>特点</h4> 
<p>将关键码自左到右分成位数相等的几部分（最后一部分位数可以短些），然后将这几部分叠加求和，并按哈希表表长，取后几位作为哈希地址。</p> 
<h4><a id="_88"></a>适用于</h4> 
<p>每一位上各符号出现概率大致相同的情况</p> 
<h4><a id="_91"></a>移位法</h4> 
<p>将各部分的最后一位对齐相加</p> 
<h4><a id="_94"></a>间界叠加法</h4> 
<p>从一端向另一端沿分割界来回折叠后,最后一位对齐相加</p> 
<h4><a id="_97"></a>举例</h4> 
<p>元素42751896<br> 移位法：427＋518＋96=1041<br> 间界叠加法：427 518 96—&gt; 724+518+69 =1311</p> 
<h3><a id="_103"></a>随机数法</h3> 
<h4><a id="Hashkeyrandomkey___random_104"></a>Hash(key)=random(key) (random为随机函数)</h4> 
<h4><a id="_105"></a>适用于</h4> 
<p>关键字长度不等的情况，造表和查找都很方便</p> 
<h3><a id="_109"></a>构造哈希函数的原则</h3> 
<ol><li>执行速度(即计算哈希函数所需的时间)</li><li>关键字的长度</li><li>哈希表的大小</li><li>关键字的分布情况</li><li>查找频率</li></ol> 
<h2><a id="_116"></a>解决冲突的方法</h2> 
<h3><a id="_117"></a>开放定址法</h3> 
<h4><a id="_118"></a>设计思路</h4> 
<p>有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。</p> 
<h4><a id="1_121"></a>1.线性探测法</h4> 
<h5><a id="HiHashkeydi_mod_m__1i__m__123"></a>Hi=(Hash(key)+di) mod m ( 1≤i &lt; m )</h5> 
<p>其中：<br> Hash(key)为哈希函数<br> m为哈希表长度<br> di 为增量序列 1，2，…m-1，且di=i(含义：一旦冲突，就找附近(下一个)空地址存入)</p> 
<h5><a id="_130"></a>举例</h5> 
<p><a href="https://imgtu.com/i/R6ci1s" rel="nofollow"><img src="https://images2.imgbox.com/84/95/AVttlVqa_o.png" alt="R6ci1s.png"></a></p> 
<h5><a id="_134"></a>线性探测法的优点</h5> 
<p>只要哈希表未被填满，保证能找到一个空地址单元存放有冲突的元素</p> 
<h5><a id="_137"></a>线性探测法的缺点</h5> 
<p>可能使第i个哈希地址的同义词存入第i+1个哈希地址，这样本应存入第i+1个哈希地址的元素变成了第i+2个哈希地址的同义词，……，<br> 因此，可能出现很多元素在相邻的哈希地址上“堆积”起来，大大降低了查找效率</p> 
<h4><a id="_141"></a>二次探测法</h4> 
<p>Hi=(Hash(key)±di) mod m</p> 
<p>其中：Hash(key)为哈希函数<br> m为哈希表长度，m要求是某个4k+3的质数；<br> di为增量序列 1²，-1²，2²，-2²，…，q²</p> 
<p><a href="https://imgtu.com/i/R6gVxA" rel="nofollow"><img src="https://images2.imgbox.com/91/a3/Mp884O03_o.png" alt="R6gVxA.png"></a></p> 
<h4><a id="_151"></a>伪随机探测法</h4> 
<p>若di为伪随机序列，就称为伪随机探测法</p> 
<h3><a id="_155"></a>链地址法(拉链法)</h3> 
<h4><a id="_156"></a>基本思想</h4> 
<p>将具有相同哈希地址的记录链成一个单链表，m个哈希地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。</p> 
<h4><a id="_159"></a>举例</h4> 
<p><a href="https://imgtu.com/i/R62Lc9" rel="nofollow"><img src="https://images2.imgbox.com/b5/0b/S7TgQXOp_o.png" alt="R62Lc9.png"></a></p> 
<h3><a id="_163"></a>再哈希法(双哈希函数法)</h3> 
<p>Hi=RHi(key) i=1, 2, …，k<br> RHi均是不同的哈希函数，当产生冲突时就计算另一个哈希函数，直到冲突不再发生。</p> 
<h4><a id="_168"></a>优点</h4> 
<p>不易产生聚集</p> 
<h4><a id="_171"></a>缺点</h4> 
<p>增加了计算时间</p> 
<h3><a id="_174"></a>建立公共溢出区</h3> 
<h4><a id="_176"></a>思路</h4> 
<p>除设立哈希基本表外，另设一个溢出向量表<br> 所有关键字和基本表中关键字为同义词的记录，不管它们由哈希函数得到的地址是什么，一旦发生冲突，都填入溢出表。</p> 
<h3><a id="_180"></a>冲突是不是比较讨厌</h3> 
<p>不一定</p> 
<p>正因为有冲突，使得文件加密后无法破译（不可逆，是单向散列函数，可用于数字签名）。</p> 
<p>利用了哈希表性质：源文件稍稍改动，会导致哈希表变动很大。</p> 
<h2><a id="_187"></a>哈希表的查找效率分析</h2> 
<p>使用平均查找长度ASL来衡量查找算法啊<br> ASL取决于</p> 
<ul><li>哈希函数</li><li>处理冲突的方法</li><li>哈希表的装填因子α</li></ul> 
<p>α=表中填入的记录数/哈希表的长度</p> 
<p>α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。</p> 
<p><a href="https://imgtu.com/i/R6WaZt" rel="nofollow"><img src="https://images2.imgbox.com/59/e9/WDjVVREq_o.png" alt="R6WaZt.png"></a></p> 
<h3><a id="_201"></a>几点结论</h3> 
<ul><li>对哈希表技术具有很好的平均性能，优于一些传统的技术</li><li>链地址法优于开地址法</li><li>除留余数法作哈希函数优于其它类型函数</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04d066c6827f265c2fade5a92685ec64/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Beyond Compare比较相同文件时仍显示红色 - 设置方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2296b2576022f40de923caec669810a0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用GEE（Google Earth Engine）在线处理NDVI、EVI、SAVI、NDMI等指数归一化教程！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>