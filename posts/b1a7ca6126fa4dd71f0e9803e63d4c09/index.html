<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>InfluxDB-简介、理论原理介绍以及InfluxDB入门操作 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="InfluxDB-简介、理论原理介绍以及InfluxDB入门操作" />
<meta property="og:description" content="文章目录 简介InfluxDB 的使用场景为什么不用关系型数据库1.X 的 TICK 技术栈与 2.X 的进一步融合influxDB 版本比较与选型 安装部署 InfluxDB下载安装进行初始化配置 理论和原理InfluxDB 行协议常用概念Prometheus 数据格式时序数据库中的数据模型普通关系型数据库中的表InfluxDB 中的数据表示理解序列的概念至关重要双索引设计与高效查询思路我一次只能查询一个序列吗时间线膨胀（高基数问题） 存储引擎LevelDBBoltDBTSM存储引擎 目录与文件结构WAL 文件TSM 文件HeaderBlocksIndex间接索引Footer InfluxDB 入门（借助 Web UI）数据源相关Load Data（加载数据）管理存储桶示例 1：创建 Bucket 并从文件导入数据管理 Telegraf 数据源示例 2：使用 Telegraf 将数据收集到 InfluxDB管理抓取任务示例 3：让 InfluxDB 主动拉取数据管理 API Token 查询工具Data Explorer示例 4：在 Data Explorer 使用查询构造器进行查询和可视化Notebook示例 5：使用 NoteBook 查询和可视化数据 简介 InfluxDB 的使用场景 InfluxDB 是一种时序数据库，时序数据库通常被用在监控场景，比如运维和 IOT（物联网）领域。这类数据库旨在存储时序数据并实时处理它们。
比如。我们可以写一个程序将服务器上 CPU 的使用情况每隔 10 秒钟向 InfluxDB 中写入一条数据。接着，我们写一个查询语句，查询过去 30 秒 CPU 的平均使用情况，然后让这个查询语句也每隔 10 秒钟执行一次。最终，我们配置一条报警规则，如果查询语句的执行结果&gt;xxx，就立刻触发报警。
上述就是一个指标监控的场景，在 IOT 领域中，也有大量的指标需要我们监控。比如， 机械设备的轴承震动频率，农田的湿度温度等等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b1a7ca6126fa4dd71f0e9803e63d4c09/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-06T16:34:33+08:00" />
<meta property="article:modified_time" content="2023-07-06T16:34:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">InfluxDB-简介、理论原理介绍以及InfluxDB入门操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">简介</a></li><li><ul><li><a href="#InfluxDB__3" rel="nofollow">InfluxDB 的使用场景</a></li><li><a href="#_11" rel="nofollow">为什么不用关系型数据库</a></li><li><a href="#1X__TICK__2X__35" rel="nofollow">1.X 的 TICK 技术栈与 2.X 的进一步融合</a></li><li><a href="#influxDB__65" rel="nofollow">influxDB 版本比较与选型</a></li></ul> 
   </li><li><a href="#_InfluxDB_107" rel="nofollow">安装部署 InfluxDB</a></li><li><ul><li><a href="#_109" rel="nofollow">下载安装</a></li><li><a href="#_143" rel="nofollow">进行初始化配置</a></li></ul> 
   </li><li><a href="#_163" rel="nofollow">理论和原理</a></li><li><ul><li><a href="#InfluxDB__165" rel="nofollow">InfluxDB 行协议</a></li><li><a href="#_347" rel="nofollow">常用概念</a></li><li><a href="#Prometheus__391" rel="nofollow">Prometheus 数据格式</a></li><li><a href="#_418" rel="nofollow">时序数据库中的数据模型</a></li><li><ul><li><a href="#_422" rel="nofollow">普通关系型数据库中的表</a></li><li><a href="#InfluxDB__455" rel="nofollow">InfluxDB 中的数据表示</a></li><li><a href="#_504" rel="nofollow">理解序列的概念至关重要</a></li><li><a href="#_518" rel="nofollow">双索引设计与高效查询思路</a></li><li><a href="#_532" rel="nofollow">我一次只能查询一个序列吗</a></li><li><a href="#_540" rel="nofollow">时间线膨胀（高基数问题）</a></li></ul> 
    </li><li><a href="#_548" rel="nofollow">存储引擎</a></li><li><ul><li><a href="#LevelDB_552" rel="nofollow">LevelDB</a></li><li><a href="#BoltDB_562" rel="nofollow">BoltDB</a></li><li><a href="#TSM_572" rel="nofollow">TSM存储引擎</a></li></ul> 
    </li><li><a href="#_629" rel="nofollow">目录与文件结构</a></li><li><ul><li><a href="#WAL__669" rel="nofollow">WAL 文件</a></li><li><a href="#TSM__684" rel="nofollow">TSM 文件</a></li><li><ul><li><a href="#Header_694" rel="nofollow">Header</a></li><li><a href="#Blocks_701" rel="nofollow">Blocks</a></li><li><a href="#Index_711" rel="nofollow">Index</a></li><li><a href="#_752" rel="nofollow">间接索引</a></li><li><a href="#Footer_764" rel="nofollow">Footer</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#InfluxDB__Web_UI_770" rel="nofollow">InfluxDB 入门（借助 Web UI）</a></li><li><ul><li><a href="#_774" rel="nofollow">数据源相关</a></li><li><ul><li><a href="#Load_Data_776" rel="nofollow">Load Data（加载数据）</a></li><li><a href="#_816" rel="nofollow">管理存储桶</a></li><li><a href="#_1_Bucket__849" rel="nofollow">示例 1：创建 Bucket 并从文件导入数据</a></li><li><a href="#_Telegraf__898" rel="nofollow">管理 Telegraf 数据源</a></li><li><a href="#_2_Telegraf__InfluxDB_948" rel="nofollow">示例 2：使用 Telegraf 将数据收集到 InfluxDB</a></li><li><a href="#_1130" rel="nofollow">管理抓取任务</a></li><li><a href="#_3_InfluxDB__1154" rel="nofollow">示例 3：让 InfluxDB 主动拉取数据</a></li><li><a href="#_API_Token_1196" rel="nofollow">管理 API Token</a></li></ul> 
    </li><li><a href="#_1272" rel="nofollow">查询工具</a></li><li><ul><li><a href="#Data_Explorer_1276" rel="nofollow">Data Explorer</a></li><li><a href="#_4_Data_Explorer__1351" rel="nofollow">示例 4：在 Data Explorer 使用查询构造器进行查询和可视化</a></li><li><a href="#Notebook_1416" rel="nofollow">Notebook</a></li><li><a href="#_5_NoteBook__1532" rel="nofollow">示例 5：使用 NoteBook 查询和可视化数据</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>简介</h3> 
<h4><a id="InfluxDB__3"></a>InfluxDB 的使用场景</h4> 
<p>InfluxDB 是一种时序数据库，时序数据库通常被用在监控场景，比如运维和 IOT（物联网）领域。这类数据库旨在存储时序数据并实时处理它们。</p> 
<p>比如。我们可以写一个程序将服务器上 CPU 的使用情况每隔 10 秒钟向 InfluxDB 中写入一条数据。接着，我们写一个查询语句，查询过去 30 秒 CPU 的平均使用情况，然后让这个查询语句也每隔 10 秒钟执行一次。最终，我们配置一条报警规则，如果查询语句的执行结果&gt;xxx，就立刻触发报警。</p> 
<p>上述就是一个指标监控的场景，在 IOT 领域中，也有大量的指标需要我们监控。比如， 机械设备的轴承震动频率，农田的湿度温度等等。</p> 
<h4><a id="_11"></a>为什么不用关系型数据库</h4> 
<p><strong>（1）写入性能</strong></p> 
<p>关系型数据库也是支持时间戳的，也能够基于时间戳进行查询。但是，从我们的使用场景出发，需要注意数据库的写入性能。通常，关系型数据库会采用 B+树数据结构，在数据写入时，有可能会触发叶裂变，从而产生了对磁盘的随机读写，降低写入速度。</p> 
<p>当前市面上的时序数据库通常都是采用<strong>LSM Tree</strong> 的变种，顺序写磁盘来增强数据的写入能力。网上有不少关于性能测试的文章，同学们可以自己去参考学习，通常时序数据库都会保证在单点每秒数十万的写入能力。</p> 
<p><strong>（2）数据价值</strong></p> 
<p>我们之前说，时序数据库一般用于指标监控场景。这个场景的数据有一个非常明显的特点就是冷热差别明显。通常，指标监控只会使用近期一段时间的数据，比如我只查询某个设备最近 10 分钟的记录，10 分钟前的数据我就不再用了。那么这 10 分钟前的数据，对我们来说就是冷数据，应该被压缩放到磁盘里去来节省空间。而热数据因为经常要用，数据库就应该让它留在内存里，等待查询。而市面上的时序数据库大都有类似的设计。</p> 
<p><strong>（3）时间不可倒流，数据只写不改</strong></p> 
<p>时序数据是描述一个实体在不同时间所处的不同状态。</p> 
<p><img src="https://images2.imgbox.com/07/69/iphqp0kp_o.png" alt=""></p> 
<p>就像是我们打开任务管理器，查看 CPU 的使用情况。我发现 CPU 占用率太高了，于是杀死了一个进程，但 10 秒前的数据不会因为我关闭进程再发生改变了。</p> 
<p>这是时序数据的一大特点。与之相应，时序数据库基本上是插入操作较多，而且还没有什么更新需求。</p> 
<h4><a id="1X__TICK__2X__35"></a>1.X 的 TICK 技术栈与 2.X 的进一步融合</h4> 
<p>根据上文的介绍，我们首先可以知道时序数据一般用在监控场景。大体上，数据的应用可以分为 4 步走。</p> 
<ol><li> <p>数据采集</p> </li><li> <p>存储</p> </li><li> <p>查询（包括聚合操作）</p> </li><li> <p>报警</p> </li></ol> 
<p>这样一看，只给一个数据库其实只能完成数据的存储和查询功能，上游的采集和下游的报警都需要自己来实现。因此 InfluxData 在 InfluxDB1.X 的时候推出了 TICK 生态来推出start 全套的解决方案。</p> 
<p>TICK4 个字母分别对应 4 个组件。</p> 
<ul><li> <p><strong>T : Telegraf - 数据采集组件，收集&amp;发送数据到 InfluxDB。</strong></p> </li><li> <p><strong>I : InfluxDB - 存储数据&amp;发送数据到Chronograf。</strong></p> </li><li> <p><strong>C : Chronograf - 总的用户界面，起到总的管理功能。</strong></p> </li><li> <p><strong>K : Kapacitor - 后台处理报警信息。</strong></p> </li></ul> 
<p><img src="https://images2.imgbox.com/1e/4b/ZGRVvmuY_o.png" alt="MMSIZE"></p> 
<p>到了 2.x，TICK 进一步融合，ICK 的功能全部融入了 InfluxDB，仅需安装 InfluxDB 就能得到一个管理页面，而且附带了定时任务和报警功能。</p> 
<h4><a id="influxDB__65"></a>influxDB 版本比较与选型</h4> 
<p><strong>（1）版本特性比较</strong></p> 
<p>2020 年 InfluxDB 推出了 2.0 的正式版。2.x 同 1.x 相比，底层引擎原理相差不大，但会涉及一些概念的转变（例如 db/rp 换成了 org/bucket）。另外，对于 TICK 生态来说，1.x 需要自己配置各个组件。2.x 则是更加方便集成，有很棒的管理页面。</p> 
<p>另外，在查询语言方面，1.x 是使用 InfluxQL 进行查询，它的风格近似 SQL。2.x 推出了 FLUX 查询语言，可以使用函数与管道符，是一种更符合时序数据特性的更具表现力的查询语言。</p> 
<p>（2）选型，本文档使用 <strong>InfluxDB 2.4</strong></p> 
<ul><li> <p>市场现状：目前企业里面用 InfluxDB 1.X 和 InfluxDB 2.X 都有人在用，数量上 InfluxDB1.X 占多一些。</p> </li><li> <p>易用性：在开发中，InfluxDB 1.X 集成生态会比较麻烦，InfluxDB 2.X 相对来说更加便利。</p> </li><li> <p>性能：InfluxDB 1.X 和 2.X 的内核原理基本一致，性能上差距不大。</p> </li><li> <p>集群：InfluxDB 从 0.11 版本开始，就闭源了集群功能的代码。也就是说，你只能免费试用 InfluxDB 的单节点版（ 开源）， 想要集群等功能就需要购买企业版。不过就 InfluxDB 1.8 来说，有开源项目根据 0.11 的代码思路提供了 InfluxDB 开源的集群方案。也有开源项目给 InfluxDB 2.3 增加了反向代理功能，让我们可以横向拓展 InfluxDB 的服务能力。项目参考地址：</p> <p>InfluxDB Cluster 对应 1.8.10：<a href="https://github.com/chengshiwen/influxdb-cluster">https://github.com/chengshiwen/influxdb-cluster</a></p> <p>InfluxDB Proxy 对应 1.2 - 1.8：<a href="https://github.com/chengshiwen/influx-proxy">https://github.com/chengshiwen/influx-proxy</a></p> <p>InfluxDB Proxy 对应 2.3：<a href="https://github.com/chengshiwen/influx-proxy/tree/influxdb-v2">https://github.com/chengshiwen/influx-proxy/tree/influxdb-v2</a></p> </li><li> <p>FLUX 语言支持：自 InfluxDB 1.7 和 InfluxDB 2.0 以来，InfluxDB 推出了一门独立的新的查询语言 FLUX，而且作为一个独立的项目来运作。InfluxData 公司希望 FLUX 语言能够成为一个像 SQL 一样的通用标准，而不仅仅是查询 InfluxDB 的特定语言。而且不管是你是选择 InfluxDB 1.X 还是 2.X 最终都会接触到FLUX。不过 2.X 对 FLUX 的支持性要更好一些。</p> </li><li> <p>InfluxDB 产品概况：</p> 
  <ul><li> <p>InfluxDB 1.8 在小版本上还在更新，主要是修复一些BUG，不再添加新特性</p> </li><li> <p>InfluxDB 2.4 这是 InfluxDB 较新的版本，仍然在增加新的特性。</p> </li><li> <p>InfluxDB 企业版 1.9 需要购买，相比开源版，它有集群功能。</p> </li><li> <p>InfluxDB Cloud，免部署，跑在 InfluxData 公司的云服务器上，你可以使用客户端来操作。功能上对应开源版的 2.4</p> </li></ul> </li><li> <p>2.x 与 1.x 的主要区别：两个版本的内核原理基本一致，性能上的差别不大。差别主要是在，权限管理方式不同，2.x TICK 的集成性比 1.x 好，1.x 中的 database 到了 2.x 中变成了 bucket 等。</p> </li></ul> 
<p>这里选择 Influx 2.4，学会使用 InfluxDB 2.4 后应当也能胜任 InfluxDB 1.7 及以上版本的开发。</p> 
<h3><a id="_InfluxDB_107"></a>安装部署 InfluxDB</h3> 
<h4><a id="_109"></a>下载安装</h4> 
<p>在 linux 环境下有两种安装方式：</p> 
<ul><li> <p>通过包管理工具安装，比如 apt 和yum</p> </li><li> <p>直接下载可执行二进制程序的压缩包</p> </li></ul> 
<p>这里选用第二种方式，可以使用下面的命令下载程序包：</p> 
<pre><code class="prism language-bash"><span class="token function">wget</span> https://dl.influxdata.com/influxdb/releases/influxdb2-2.4.0-linux-amd64.tar.gz
</code></pre> 
<p><img src="https://images2.imgbox.com/c5/3a/G12ACbMB_o.png" alt="MMSIZE"></p> 
<p>压缩包下载好后，将其解压到目标路径。</p> 
<pre><code class="prism language-bash"> <span class="token function">tar</span> -zxvf influxdb2-2.4.0-linux-amd64.tar.gz -C /opt/module
</code></pre> 
<p>Go 语言开发的项目一般来说会只打包成单独的二进制可执行文件，也就是解压后目录下的 influxd 文件，这一文件中全是编译后的本地码，可以直接跑在操作系统上，不需要安装额外的运行环境或者依赖。</p> 
<p><img src="https://images2.imgbox.com/24/4f/3YGHsmzn_o.png" alt="MMSIZE"></p> 
<p>现在，可以运行使用下面的命令，正式开启 InfluxDB 服务进程。</p> 
<pre><code class="prism language-bash"> ./influxd
</code></pre> 
<h4><a id="_143"></a>进行初始化配置</h4> 
<p>使用浏览器访问http://hadoop102:8086。如果是安装后的首次使用，InfluxDB 会返回一个初始化的引导界面。按照给定步骤完成操作就好。</p> 
<p><strong>（1）创建用户和初始化存储桶</strong></p> 
<p>点击GET STARTED 按钮，进入下一个步骤（添加用户）。如图所示，你需要填写、组织名称、用户名称、用户密码。</p> 
<p><img src="https://images2.imgbox.com/0a/d3/uCzH2nEK_o.png" alt="MMSIZE"></p> 
<p>填写完后点击CONTINUE 按钮进入下一步。</p> 
<p><strong>（2）配置完成</strong></p> 
<p>看到如图所示的页面，说明我们已经开始使用 tony 这一用户身份和InfluxDB 交互了。</p> 
<p><img src="https://images2.imgbox.com/84/ca/LVYpHvZn_o.png" alt="MMSIZE"></p> 
<h3><a id="_163"></a>理论和原理</h3> 
<h4><a id="InfluxDB__165"></a>InfluxDB 行协议</h4> 
<p>Telegraf的内部数据结构叫做InfluxDB行协议。如下图所示：</p> 
<p><img src="https://images2.imgbox.com/ca/1a/udT4IDPS_o.png" alt=""></p> 
<p>Telegraf本身是InfluxData公司专门为InfluxDB开发的数据采集器。上面这种数据格式是InfluxDB数据库使用的，只要数据符合上面这种格式，就能通过InfluxDB的API将数据导入数据库。所以，自家的插件当然支持自家的生态了，InfluxDB。</p> 
<p>与 CSV 相似，在 InfluxDB 行协议中，一条数据和另一条数据之间使用换行符分隔， 所以一行就是一条数据。另外，在时序数据库领域，一行数据一行数据由下面 4 种元素构成。</p> 
<ol><li> <p>measurement（测量名称）</p> </li><li> <p>Tag Set（标签集）</p> </li><li> <p>Field Set（字段集）</p> </li><li> <p>Timestamp（时间戳）</p> </li></ol> 
<p>接下来介绍一下它的几个构成部分。</p> 
<p><strong>（1）measurement（测量名称）</strong></p> 
<p>随着后面的学习，你会逐渐深入理解这个概念。目前，你可以将它理解为关系型数据库中的一张表。</p> 
<ul><li>必需</li><li>测量的名称。每个数据点都必须声明自己是哪个测量里面的 ，不可省略。</li><li>大小写敏感</li><li>不可以下划线 _ 开头</li></ul> 
<p><strong>（2）Tag Set（标签集）</strong></p> 
<p>标签应该用在一些值的范围有限的，不太会变动的属性上。比如传感器的类型和id等等。在InfluxDB中<strong>一个Tag相当于一个索引</strong>。给数据点加上Tag有利于将来对数据进行检索。但是如果索引太多了，就会减慢数据的插入速度。</p> 
<ul><li>可选</li><li>键值关系使用 = 表示</li><li>多个键值对之间使用英文逗号 , 分隔</li><li>标签的键和值都区分大小写</li><li>标签的键不能以下划线 _ 开头</li><li>键的数据类型：字符串</li><li>值的数据类型：字符串</li></ul> 
<p><strong>（3）Field Set（字段集）</strong></p> 
<ul><li>必需</li><li>一个数据点上所有的字段键值对，键是字段名，值是数据点的值。</li><li>一个数据点至少要有一个字段。</li><li>字段集的键是大小写敏感的。</li><li>字段</li><li>键的数据类型：字符串</li><li>值的数据类型：浮点数 | 整数 | 无符号整数 | 字符串 | 布尔值</li></ul> 
<p><strong>（4）Timestamp（时间戳）</strong></p> 
<ul><li>可选</li><li>数据点的Unix时间戳，每个数据点都可以指定自己的时间戳。</li><li>如果时间戳没有指定。那么InfluxDB就使用当前系统的时间戳。</li><li>数据类型：Unix timestamp</li><li>如果你的数据里的时间戳不是以纳秒为单位的，那么需要在数据写入时指定时间戳的精度。</li></ul> 
<p><strong>（5）空格</strong></p> 
<p>行协议中的空格决定了InfluxDB如何解释数据点。第一个未转义的空格将测量值&amp;Tag Set （标签集）与 Field Set（字段集） 分开。第二个未转义空格将Field Set（字段级）和时间戳分开。</p> 
<p><img src="https://images2.imgbox.com/7a/7a/An2AcroL_o.png" alt=""></p> 
<p><strong>（6）协议中的数据类型及其格式</strong></p> 
<p><strong>1）Float（浮点数）</strong></p> 
<p>IEEE-754标准的64位浮点数。这是默认的数据类型。</p> 
<p>示例：字段级值类型为浮点数的行协议</p> 
<pre><code class="prism language-bash">myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span><span class="token number">1.0</span>
myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span><span class="token number">1</span>
myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span>-1.234456e+78
</code></pre> 
<p><strong>2）Integer（整数）</strong></p> 
<p>有符号64位整数。需要在数字的尾部加上一个小写数字 i 。</p> 
<table><thead><tr><th>整数最小值</th><th>整数最大值</th></tr></thead><tbody><tr><td>-9223372036854775808i</td><td>9223372036854775807i</td></tr></tbody></table> 
<p>示例：字段值类型为有整数的</p> 
<p><strong>3）UInteger（无符号整数）</strong></p> 
<p>无符号64位整数。需要在数字的尾部加上一个小写数字 u 。</p> 
<table><thead><tr><th>无符号整数最小值</th><th>无符号整数最大值</th></tr></thead><tbody><tr><td>0u</td><td>18446744073709551615u</td></tr></tbody></table> 
<p>示例：字段值类型为无符号整数的航协议</p> 
<pre><code class="prism language-bash">myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span>1u
myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span>12485903u
</code></pre> 
<p><strong>4）String（字符串）</strong></p> 
<p>普通文本字符串，长度不能超过64KB</p> 
<p>示例：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">\</span># String measurement name, field key, and field value
myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span><span class="token string">"this is a string"</span>
</code></pre> 
<p><strong>5）Boolean（布尔值）</strong></p> 
<p>true或者false。</p> 
<p>示例：</p> 
<table><thead><tr><th>布尔值</th><th>支持的语法</th></tr></thead><tbody><tr><td>True</td><td>t, T, true, True, TRUE</td></tr><tr><td>False</td><td>f, F, false, False, FALSE</td></tr></tbody></table> 
<p>示例：</p> 
<pre><code class="prism language-bash">myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span>true
myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span>false
myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span>t
myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span>f
myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span>TRUE
myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span>FALSE
</code></pre> 
<p>不要对布尔值使用引号，否则会被解释为字符串</p> 
<p><strong>6）Unix Timestamp（Unix 时间戳）</strong></p> 
<p>如果你写时间戳，</p> 
<pre><code class="prism language-bash">myMeasurementName <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span><span class="token string">"fieldValue"</span> <span class="token number">1556813561098000000</span>
</code></pre> 
<p><strong>（7）注释</strong></p> 
<p>以井号 # 开头的一行会被当做注释。</p> 
<p>示例：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 这是一行数据</span>
myMeasurement <span class="token assign-left variable">fieldKey</span><span class="token operator">=</span><span class="token string">"string value"</span> <span class="token number">1556813561098000000</span>
</code></pre> 
<h4><a id="_347"></a>常用概念</h4> 
<p>与传统数据库中的名词做比较：</p> 
<table><thead><tr><th>influxDB中的名词</th><th>传统数据库中的概念</th></tr></thead><tbody><tr><td>database</td><td>数据库</td></tr><tr><td>measurement</td><td>数据库中的表</td></tr><tr><td>points</td><td>表里面的一行数据</td></tr></tbody></table> 
<p><strong>（1）Point</strong></p> 
<p>Point由时间戳（time）、数据（field）、标签（tags）组成。</p> 
<p>Point相当于传统数据库里的一行数据，如下表所示：</p> 
<table><thead><tr><th>Point属性</th><th>传统数据库中的概念</th></tr></thead><tbody><tr><td>time</td><td>每个数据记录时间，是数据库中的主索引(会自动生成)</td></tr><tr><td>fields</td><td>各种记录值（没有索引的属性）</td></tr><tr><td>tags</td><td>各种有索引的属性</td></tr></tbody></table> 
<p><strong>（2）Series</strong></p> 
<p>Series 相当于是 InfluxDB 中一些数据的集合，在同一个 database 中，retention policy、measurement、tag sets 、field完全相同的数据同属于一个 series，同一个 series 的数据在物理上会按照时间顺序排列存储在一起。</p> 
<p><strong>（3）Shard</strong></p> 
<p>Shard 在 InfluxDB 中是一个比较重要的概念，它和 retention policy 相关联。每一个存储策略下会存在许多 shard，每一个 shard 存储一个指定时间段内的数据，并且不重复，例如 7点-8点 的数据落入 shard0 中，8点-9点的数据则落入 shard1 中。<strong>每一个 shard 都对应一个底层的 tsm 存储引擎，有独立的 cache、wal、tsm file</strong>。</p> 
<p>这样做的目的就是为了可以通过时间来快速定位到要查询数据的相关资源，加速查询的过程，并且也让之后的批量删除数据的操作变得非常简单且高效。</p> 
<p>在 LSM Tree 中删除数据是通过给指定 key 插入一个删除标记的方式，数据并不立即删除，需要等之后对文件进行压缩合并时才会真正地将数据删除，所以删除大量数据在 LSM Tree 中是一个非常低效的操作。</p> 
<p><strong>而在 InfluxDB 中，通过 retention policy 设置数据的保留时间，当检测到一个 shard 中的数据过期后，只需要将这个 shard 的资源释放，相关文件删除即可，这样的做法使得删除过期数据变得非常高效。</strong></p> 
<p><strong>（4）Retention Policy</strong></p> 
<p>保留策略包括设置数据保存的时间以及在集群中的副本个数。</p> 
<p>默认的 RP 为 <strong>default</strong>，保存时间不限制，副本个数为 1，默认 RP 是可以修改的，并且我们可以创建新的 RP。s</p> 
<h4><a id="Prometheus__391"></a>Prometheus 数据格式</h4> 
<p>Prometheus 也是一种时序数据库，不过它通常被用在运维场景下。Prometheus 是开放原子基金会的第二个毕业项目，这个基金会的第一个毕业项目就是大名鼎鼎的k8s。</p> 
<p>同 InfluxDB 一样，Prometheus 也有自己的数据格式，只要数据符合这种格式就能被Prometheus 识别并写入数据库。而且 Prometheus 数据格式也是纯文本的。</p> 
<p>近期 Prometheus技术热度高涨，有一个名为 OpenMetris 的数据协议越来越流行，它致力于让全球的指标监控有一样的数据格式，而这个数据协议就是根据 Prometheus 数据格式改的，两者 100%兼容，足以见其影响力。</p> 
<p>Prometheus 数据格式主要包含四个元素：</p> 
<ol><li> <p>指标名称（必需）</p> </li><li> <p>标签集（可选）：标签集是一组键值对，键是标签的名称，值是具体的标签内容，而且值必须得是字符串。指标名称和标签共同组成索引。</p> </li><li> <p>值（必须）：必须满足浮点数格式</p> </li><li> <p>时间戳（可选）：Unix 毫秒级时间戳。</p> </li><li></ol> 
<p><img src="https://images2.imgbox.com/f6/a7/Qq3zupJo_o.png" alt="MSIZE"></p> 
<ul><li>第 1 个空格，将 指标名称&amp;标签集与指标值 分隔开</li><li>第 2 个空格，将 指标值与Unix 时间戳分隔开</li></ul> 
<h4><a id="_418"></a>时序数据库中的数据模型</h4> 
<p>想要正确使用时序数据库，就必须理解时序数据库管理数据的逻辑。这里，我们会和普通的 SQL（关系型）数据库做一下比较。</p> 
<h5><a id="_422"></a>普通关系型数据库中的表</h5> 
<p>下面这张表示 SQL（关系型）数据库中一个简单的示例。表中有创建索引和未创建索引的列。</p> 
<ul><li> <p>park_id、planet、time 是创建了索引的列。</p> </li><li> <p>_foodships 是未创建索引的列。</p> </li></ul> 
<pre><code class="prism language-sql"><span class="token operator">+</span><span class="token comment">---------+---------+---------------------+--------------+</span>
<span class="token operator">|</span> park_id <span class="token operator">|</span> planet <span class="token operator">|</span> <span class="token keyword">time</span> <span class="token operator">|</span> <span class="token comment">#_foodships |</span>
<span class="token operator">+</span><span class="token comment">---------+---------+---------------------+--------------+</span>
<span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> Earth <span class="token operator">|</span> <span class="token number">1429185600000000000</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> Earth <span class="token operator">|</span> <span class="token number">1429185601000000000</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> Earth <span class="token operator">|</span> <span class="token number">1429185602000000000</span> <span class="token operator">|</span> <span class="token number">15</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> Earth <span class="token operator">|</span> <span class="token number">1429185603000000000</span> <span class="token operator">|</span> <span class="token number">15</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> Saturn <span class="token operator">|</span> <span class="token number">1429185600000000000</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> Saturn <span class="token operator">|</span> <span class="token number">1429185601000000000</span> <span class="token operator">|</span> <span class="token number">9</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> Saturn <span class="token operator">|</span> <span class="token number">1429185602000000000</span> <span class="token operator">|</span> <span class="token number">10</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> Saturn <span class="token operator">|</span> <span class="token number">1429185603000000000</span> <span class="token operator">|</span> <span class="token number">14</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> Jupiter <span class="token operator">|</span> <span class="token number">1429185600000000000</span> <span class="token operator">|</span> <span class="token number">20</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> Jupiter <span class="token operator">|</span> <span class="token number">1429185601000000000</span> <span class="token operator">|</span> <span class="token number">21</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> Jupiter <span class="token operator">|</span> <span class="token number">1429185602000000000</span> <span class="token operator">|</span> <span class="token number">21</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> Jupiter <span class="token operator">|</span> <span class="token number">1429185603000000000</span> <span class="token operator">|</span> <span class="token number">20</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> Saturn <span class="token operator">|</span> <span class="token number">1429185600000000000</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> Saturn <span class="token operator">|</span> <span class="token number">1429185601000000000</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> Saturn <span class="token operator">|</span> <span class="token number">1429185602000000000</span> <span class="token operator">|</span> <span class="token number">6</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> Saturn <span class="token operator">|</span> <span class="token number">1429185603000000000</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+---------+---------------------+--------------+</span>
</code></pre> 
<h5><a id="InfluxDB__455"></a>InfluxDB 中的数据表示</h5> 
<p>上面的数据，如果换到 InfluxDB 中，会换一种形式进行表示。</p> 
<pre><code class="prism language-sql">name: foodships
tags: park_id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> planet<span class="token operator">=</span>Earth
<span class="token keyword">time</span> <span class="token comment">#_foodships</span>
<span class="token comment">---- ------------</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">00</span>Z <span class="token number">0</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">01</span>Z <span class="token number">3</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">02</span>Z <span class="token number">15</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">03</span>Z <span class="token number">15</span>
name: foodships
tags: park_id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> planet<span class="token operator">=</span>Saturn
<span class="token keyword">time</span> <span class="token comment">#_foodships</span>
<span class="token comment">---- ------------</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">00</span>Z <span class="token number">5</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">01</span>Z <span class="token number">9</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">02</span>Z <span class="token number">10</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">03</span>Z <span class="token number">14</span>
name: foodships
tags: park_id<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> planet<span class="token operator">=</span>Jupiter
<span class="token keyword">time</span> <span class="token comment">#_foodships</span>
<span class="token comment">---- ------------</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">00</span>Z <span class="token number">20</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">01</span>Z <span class="token number">21</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">02</span>Z <span class="token number">21</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">03</span>Z <span class="token number">20</span>
name: foodships
tags: park_id<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> planet<span class="token operator">=</span>Saturn
<span class="token keyword">time</span> <span class="token comment">#_foodships</span>
<span class="token comment">---- ------------</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">00</span>Z <span class="token number">5</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">01</span>Z <span class="token number">5</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">02</span>Z <span class="token number">6</span>
<span class="token number">2015</span><span class="token operator">-</span><span class="token number">04</span><span class="token operator">-</span><span class="token number">16</span>T12:<span class="token number">00</span>:<span class="token number">03</span>Z <span class="token number">5</span>
</code></pre> 
<ul><li> <p>InfluxDB 中的 measurement（foodships）相当于SQL（关系型）数据库中的表</p> </li><li> <p>InfluxDB 中的 tags（park_id 和planet）相当于 SQL（关系型）数据库中的索引列</p> </li><li> <p>InfluxDB 中的 fileds（在这里是#_foodships）相当于 SQL（关系型）数据库中的未建索引的列。</p> </li><li> <p>InfluxDB 中的数据点2015-04-16T12:00:00Z 5相当于SQL（关系型）数据库中的一行。</p> </li></ul> 
<h5><a id="_504"></a>理解序列的概念至关重要</h5> 
<p>简单来说，InfluxDB 这类数据库是用序列的方式来管理数据的。在 InfluxDB 中，唯一 的 measurement，tag_set 和 fileld（一个字段）组合是一个 series（序列）。比如下图中有 6 条连续的线，这里面每个条线就是一个序列。每一个序列的数据在内存和磁盘上紧密存放， 这样当你要查询这一序列的数据时，InfluxDB 可以很快定位到这一序列中的好多条数据。你也可以将measurement，tag，field 视为索引，而且它们本身就是索引。</p> 
<p><img src="https://images2.imgbox.com/f0/cf/ALnMRYug_o.png" alt="MSIZE"></p> 
<p><strong>以序列的方式管理数据</strong>是时序数据库和传统关系型数据库最不同的地方。传统的关系型数据库通常是以 record（记录或者行）的方式管理数据，这个时候，关系型数据库可以让你快速地通过索引定位到一条数据。</p> 
<p><img src="https://images2.imgbox.com/34/10/VippGFED_o.png" alt="MMSIZE"></p> 
<p>但是在时序场景下，我们通常需要查找某个设备最近一段时间的数据。这个时候对于传统关系型数据库来说，很可能需要多次寻址来找到多个 record 才能完成查询。而时序库是把索引打到一批次的数据上，所以在这种场景的下的读写，时序库性能是远强于 B+树数据库的。</p> 
<h5><a id="_518"></a>双索引设计与高效查询思路</h5> 
<p>我们之前说到你可以将 measurement、tag_set 和 field 视为索引，还没有提到最重要的时间。其实，在 InfluxDB 中时间也是索引，数据在入库时，会按时间戳进行排序。这样， 我们在进行查询时，一般遵循下面的思路。</p> 
<ol><li> <p>先指定要从哪个存储桶查询数据</p> </li><li> <p>指定数据的时间范围</p> </li><li> <p>指定 measurement、tag_set、和 field 说明我要查询哪个序列。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/20/48/KhLHzqlU_o.png" alt="MSIZE"></p> 
<h5><a id="_532"></a>我一次只能查询一个序列吗</h5> 
<p>一次只能查询一个序列，这显然是不合理的。</p> 
<p>假如，我现在只指定要查询 measurent 为 m1 和 tag1 为 hello 的数据，那么就会命中图中 4 条序列。所以实际上，measurement，tag，field 都是倒排索引。</p> 
<p><img src="https://images2.imgbox.com/69/61/TFzJN1Er_o.png" alt="MSIZE"></p> 
<h5><a id="_540"></a>时间线膨胀（高基数问题）</h5> 
<p>时间线膨胀是所有时序数据库都绕不过的问题。简单地来解释时间线膨胀，就是我们的时序数据库中序列太多了。</p> 
<p>当序列过多时，时序数据库的写入和读取性能通常都会有明显的下降。所以，当你去网上看一些时序数据库的压测文章时，需要注意文章有没有将序列数考虑进去。</p> 
<h4><a id="_548"></a>存储引擎</h4> 
<p>从 LevelDB（LSM Tree），到 BoltDB（mmap B+树），现在是自己实现的 TSM Tree 的算法，类似 LSM Tree，针对 InfluxDB 的使用做了特殊优化。</p> 
<h5><a id="LevelDB_552"></a>LevelDB</h5> 
<p>LevelDB 底层使用了 LSM Tree 作为数据结构，用于存储大量的 key 值有序的 K-V 数据，鉴于时序数据的特点，只要将时间戳放入 key 中，就可以非常快速的遍历指定时间范围内的数据。LSM Tree 将大量随机写变成顺序写，所以拥有很高的写吞吐量，并且 LevelDB 内置了压缩功能。</p> 
<p>数据操作被先顺序写入 WAL 日志中，成功之后写入内存中的 MemTable，当 MemTable 中的数据量达到一定阀值后，会转换为 Immutable MemTable，只读，之后写入 SSTable。SSTable 是磁盘上只读的用于存储有序键值对的文件，并且会持续进行合并，生成新的 SSTable。在 LevelDB 中是分了不同层级的 SSTable 用于存储数据。</p> 
<p>LevelDB 不支持热备份，它的变种 RocksDB 和 HyperLevelDB 实现了这个功能。</p> 
<p>最严重的问题是由于 InfluxDB 通过 shard 来组织数据，每一个 shard 对应的就是一个 LevelDB 数据库，而由于 LevelDB 的底层存储是大量 SSTable 文件，所以当用户需要存储长时间的数据，例如几个月或者一年的时候，会产生大量的 shard，从而消耗大量文件描述符，将系统资源耗尽。</p> 
<h5><a id="BoltDB_562"></a>BoltDB</h5> 
<p>之后 InfluxDB 采用了 BoltDB 作为数据存储引擎。BoltDB 是基于 LMDB 使用 Go 语言开发的数据库。同 LevelDB 类似的是，都可以用于存储 key 有序的 K-V 数据。</p> 
<p>虽然采用 BoltDB 的写效率有所下降，但是考虑到用于生产环境需要更高的稳定性，BoltDB 是一个合适的选择，而且 BoltDB 使用纯 Go 编写，更易于跨平台编译部署。</p> 
<p>最重要的是 BoltDB 的一个数据库存储只使用一个单独的文件。Bolt 还解决了热备的问题，很容易将一个 shard 从一台机器转移到另外一台。</p> 
<p>但是当数据库容量达到数GB级别时，同时往大量 series 中写入数据，相当于是大量随机写，会造成 IOPS 上升。</p> 
<h5><a id="TSM_572"></a>TSM存储引擎</h5> 
<p>TSM Tree 是 InfluxDB 根据实际需求在 LSM Tree 的基础上稍作修改优化而来。</p> 
<p>TSM 存储引擎主要由几个部分组成： cache、wal、tsm file、compactor。</p> 
<p><img src="https://images2.imgbox.com/ab/c8/4zU6JRWh_o.png" alt="MMSIZE"></p> 
<ul><li> <p><strong>Cache：cache</strong> 相当于是 LSM Tree 中的 <strong>memtable</strong>。在内存中是一个简单的 map 结构，这里的 key 为 <code>seriesKey + 分隔符 + filedName</code>，目前代码中的分隔符为 <code>#!~#</code>，entry 相当于是一个按照时间排序的存放实际值的数组，具体结构如下：</p> <pre><code class="prism language-go"><span class="token keyword">type</span> Cache <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    commit  sync<span class="token punctuation">.</span>Mutex
    mu      sync<span class="token punctuation">.</span>RWMutex
    store   <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>entry
    size    <span class="token builtin">uint64</span>              <span class="token comment">// 当前使用内存的大小</span>
    maxSize <span class="token builtin">uint64</span>              <span class="token comment">// 缓存最大值</span>

    <span class="token comment">// snapshots are the cache objects that are currently being written to tsm files</span>
    <span class="token comment">// they're kept in memory while flushing so they can be queried along with the cache.</span>
    <span class="token comment">// they are read only and should never be modified</span>
    <span class="token comment">// memtable 快照，用于写入 tsm 文件，只读</span>
    snapshot     <span class="token operator">*</span>Cache
    snapshotSize <span class="token builtin">uint64</span>
    snapshotting <span class="token builtin">bool</span>

    <span class="token comment">// This number is the number of pending or failed WriteSnaphot attempts since the last successful one.</span>
    snapshotAttempts <span class="token builtin">int</span>

    stats        <span class="token operator">*</span>CacheStatistics
    lastSnapshot time<span class="token punctuation">.</span>Time
<span class="token punctuation">}</span>
</code></pre> <p>插入数据时，实际上是同时往 cache 与 wal 中写入数据，可以认为 cache 是 wal 文件中的数据在内存中的缓存。当 InfluxDB 启动时，会遍历所有的 wal 文件，重新构造 cache，这样即使系统出现故障，也不会导致数据的丢失。</p> <p>cache 中的数据并不是无限增长的，有一个 maxSize 参数用于控制当 cache 中的数据占用多少内存后就会将数据写入 tsm 文件。如果不配置的话，默认上限为 25MB，每当 cache 中的数据达到阀值后，会将当前的 cache 进行一次快照，之后清空当前 cache 中的内容，再创建一个新的 wal 文件用于写入，剩下的 wal 文件最后会被删除，快照中的数据会经过排序写入一个新的 tsm 文件中。</p> </li><li> <p><strong>WAL</strong>：wal 文件的内容与内存中的 cache 相同，其作用就是为了持久化数据，当系统崩溃后可以通过 wal 文件恢复还没有写入到 tsm 文件中的数据。</p> <p>由于数据是被顺序插入到 wal 文件中，所以写入效率非常高。但是如果写入的数据没有按照时间顺序排列，而是以杂乱无章的方式写入，数据将会根据时间路由到不同的 shard 中，每一个 shard 都有自己的 wal 文件，这样就不再是完全的顺序写入，对性能会有一定影响。看到官方社区有说后续会进行优化，只使用一个 wal 文件，而不是为每一个 shard 创建 wal 文件。</p> <p>wal 单个文件达到一定大小后会进行分片，创建一个新的 wal 分片文件用于写入数据。</p> </li><li> <p><strong>TSM File</strong>：单个 tsm file 大小最大为 2GB，用于存放数据。</p> <p>TSM file 使用了自己设计的格式，对查询性能以及压缩方面进行了很多优化，在后面的章节会具体说明其文件结构。</p> </li><li> <p><strong>Compactor</strong>：compactor 组件在后台持续运行，每隔 1 秒会检查一次是否有需要压缩合并的数据。</p> <p>主要进行两种操作：</p> 
  <ul><li>一种是 cache 中的数据大小达到阀值后，进行快照，之后转存到一个新的 tsm 文件中。</li><li>另外一种就是合并当前的 tsm 文件，将多个小的 tsm 文件合并成一个，使每一个文件尽量达到单个文件的最大大小，减少文件的数量，并且一些数据的删除操作也是在这个时候完成。</li></ul> </li></ul> 
<h4><a id="_629"></a>目录与文件结构</h4> 
<p>InfluxDB 的数据存储主要有三个目录。</p> 
<p>默认情况下是 <strong>meta</strong>, <strong>wal</strong> 以及 <strong>data</strong> 三个目录：</p> 
<ul><li> <p><strong>meta</strong> 用于存储数据库的一些元数据，<strong>meta</strong> 目录下有一个 <code>meta.db</code> 文件。</p> </li><li> <p><strong>wal</strong> 目录存放预写日志文件，以 <code>.wal</code> 结尾。<strong>data</strong> 目录存放实际存储的数据文件，以 <code>.tsm</code> 结尾。这两个目录下的结构是相似的，其基本结构如下：</p> <pre><code class="prism language-bash"><span class="token comment"># wal 目录结构</span>
-- wal
   -- mydb
      -- autogen
         -- <span class="token number">1</span>
            -- _00001.wal
         -- <span class="token number">2</span>
            -- _00035.wal
      -- 2hours
         -- <span class="token number">1</span>
            -- _00001.wal

<span class="token comment"># data 目录结构</span>
-- data
   -- mydb
      -- autogen
         -- <span class="token number">1</span>
            -- 000000001-000000003.tsm
         -- <span class="token number">2</span>
            -- 000000001-000000001.tsm
      -- 2hours
         -- <span class="token number">1</span>
            -- 000000002-000000002.tsm
</code></pre> <p>其中 <strong>mydb</strong> 是数据库名称，<strong>autogen</strong> 和 <strong>2hours</strong> 是存储策略名称，再下一层目录中的以数字命名的目录是 shard 的 ID 值，比如 <strong>autogen</strong> 存储策略下有两个 shard，ID 分别为 1 和 2，shard 存储了某一个时间段范围内的数据。再下一级的目录则为具体的文件，分别是 <code>.wal</code> 和 <code>.tsm</code> 结尾的文件。</p> </li></ul> 
<h5><a id="WAL__669"></a>WAL 文件</h5> 
<p><img src="https://images2.imgbox.com/93/e1/4MpCfEYW_o.png" alt="MSIZE"></p> 
<p>wal 文件中的一条数据，对应的是一个 key(measument + tags + fieldName) 下的所有 value 数据，按照时间排序。</p> 
<ul><li><strong>Type (1 byte)</strong>: 表示这个条目中 value 的类型。</li><li><strong>Key Len (2 bytes)</strong>: 指定下面一个字段 key 的长度。</li><li><strong>Key (N bytes)</strong>: 这里的 key 为 measument + tags + fieldName。</li><li><strong>Count (4 bytes)</strong>: 后面紧跟着的是同一个 key 下数据的个数。</li><li><strong>Time (8 bytes)</strong>: 单个 value 的时间戳。</li><li><strong>Value (N bytes)</strong>: value 的具体内容，其中 float64, int64, boolean 都是固定的字节数存储比较简单，通过 Type 字段知道这里 value 的字节数。string 类型比较特殊，对于 string 来说，N bytes 的 Value 部分，前面 4 字节用于存储 string 的长度，剩下的部分才是 string 的实际内容。</li></ul> 
<h5><a id="TSM__684"></a>TSM 文件</h5> 
<p>单个 tsm 文件的主要格式如下：</p> 
<p><img src="https://images2.imgbox.com/f3/f2/drFNguUH_o.png" alt="MSIZE"></p> 
<p>主要分为四个部分： <strong>Header, Blocks, Index, Footer</strong>。</p> 
<p>其中 <strong>Index</strong> 部分的内容会被缓存在内存中，下面详细说明一下每一个部分的数据结构。</p> 
<h6><a id="Header_694"></a>Header</h6> 
<p><img src="https://images2.imgbox.com/18/f3/daG9qazx_o.png" alt="MMSIZE"></p> 
<ul><li><strong>MagicNumber (4 bytes)</strong>: 用于区分是哪一个存储引擎，目前使用的 tsm1 引擎，MagicNumber 为 <code>0x16D116D1</code>。</li><li><strong>Version (1 byte)</strong>: 目前是 tsm1 引擎，此值固定为 <code>1</code>。</li></ul> 
<h6><a id="Blocks_701"></a>Blocks</h6> 
<p><img src="https://images2.imgbox.com/c9/a9/mUuUiTO1_o.png" alt="MMSIZE"></p> 
<p>Blocks 内部是一些连续的 Block，block 是 InfluxDB 中的最小读取对象，每次读取操作都会读取一个 block。每一个 Block 分为 CRC32 值和 Data 两部分，CRC32 值用于校验 Data 的内容是否有问题。Data 的长度记录在之后的 Index 部分中。</p> 
<p><strong>Data 中的内容根据数据类型的不同，在 InfluxDB 中会采用不同的压缩方式</strong>，float 值采用了 Gorilla float compression，而 timestamp 因为是一个递增的序列，所以实际上压缩时只需要记录时间的偏移量信息。string 类型的 value 采用了 snappy 算法进行压缩。</p> 
<p>Data 的数据解压后的格式为 8 字节的时间戳以及紧跟着的 value，value 根据类型的不同，会占用不同大小的空间，其中 string 为不定长，会在数据开始处存放长度，这一点和 WAL 文件中的格式相同。</p> 
<h6><a id="Index_711"></a>Index</h6> 
<p><img src="https://images2.imgbox.com/30/8c/lRppzJjX_o.png" alt="MMSIZE"></p> 
<p>Index 存放的是前面 Blocks 里内容的索引。索引条目的顺序是先按照 key 的字典序排序，再按照 time 排序。InfluxDB 在做查询操作时，可以根据 Index 的信息快速定位到 tsm file 中要查询的 block 的位置。</p> 
<p>这张图只展示了其中一部分，用结构体来表示的话类似下面的代码：</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> BlockIndex <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    MinTime     <span class="token builtin">int64</span>
    MaxTime     <span class="token builtin">int64</span>
    Offset      <span class="token builtin">int64</span>
    Size        <span class="token builtin">uint32</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> KeyIndex <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    KeyLen      <span class="token builtin">uint16</span>
    Key         <span class="token builtin">string</span>
    Type        <span class="token builtin">byte</span>
    Count       <span class="token builtin">uint32</span>
    Blocks      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>BlockIndex
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Index <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>KeyIndex
</code></pre> 
<ul><li><strong>Key Len (2 bytes)</strong>: 下面一个字段 key 的长度。</li><li><strong>Key (N bytes)</strong>: 这里的 key 指的是 seriesKey + 分隔符 + fieldName。</li><li><strong>Type (1 bytes)</strong>: fieldName 所对应的 fieldValue 的类型，也就是 Block 中 Data 内的数据的类型。</li><li><strong>Count (2 bytes)</strong>: 后面紧跟着的 Blocks 索引的个数。</li></ul> 
<p>后面四个部分是 block 的索引信息，根据 Count 中的个数会重复出现，每个 block 索引固定为 28 字节，按照时间排序。</p> 
<ul><li><strong>Min Time (8 bytes)</strong>: block 中 value 的最小时间戳。</li><li><strong>Max Time (8 bytes)</strong>: block 中 value 的最大时间戳。</li><li><strong>Offset (8 bytes)</strong>: block 在整个 tsm file 中的偏移量。</li><li><strong>Size (4 bytes)</strong>: block 的大小。根据 Offset + Size 字段就可以快速读取出一个 block 中的内容。</li></ul> 
<h6><a id="_752"></a>间接索引</h6> 
<p>间接索引只存在于内存中，是为了可以快速定位到一个 key 在详细索引信息中的位置而创建的，可以被用于二分查找来实现快速检索。</p> 
<p><img src="https://images2.imgbox.com/52/69/NnvTfYsG_o.png" alt="MMSIZE"></p> 
<p>offsets 是一个数组，其中存储的值为每一个 key 在 Index 表中的位置，由于 key 的长度固定为 2字节，所以根据这个位置就可以找到该位置上对应的 key 的内容。</p> 
<p>当指定一个要查询的 key 时，就可以通过二分查找，定位到其在 Index 表中的位置，再根据要查询的数据的时间进行定位，由于 KeyIndex 中的 BlockIndex 结构是定长的，所以也可以进行一次二分查找，找到要查询的数据所在的 BlockIndex 的内容，之后根据偏移量以及 block 长度就可以从 tsm 文件中快速读取出一个 block 的内容。</p> 
<h6><a id="Footer_764"></a>Footer</h6> 
<p><img src="https://images2.imgbox.com/13/19/GwSpFFon_o.png" alt="MMSIZE"></p> 
<p>tsm file 的最后8字节的内容存放了 Index 部分的起始位置在 tsm file 中的偏移量，方便将索引信息加载到内存中。</p> 
<h3><a id="InfluxDB__Web_UI_770"></a>InfluxDB 入门（借助 Web UI）</h3> 
<p>借助 Web UI，我们可以更好地理解 InfluxDB 的功能划分。接下来，我们就从 Web UI入手，先了解InfluxDB 的基本功能。</p> 
<h4><a id="_774"></a>数据源相关</h4> 
<h5><a id="Load_Data_776"></a>Load Data（加载数据）</h5> 
<p><img src="https://images2.imgbox.com/e4/f2/Ru1czTQX_o.png" alt="MMSIZE"></p> 
<p>如图所示，页面上左侧的向上箭头，对应着 InfluxDB Web UI 的 Load Data（加载数据） 页面。</p> 
<p><strong>（1）上传数据文件</strong></p> 
<p>在 Web UI 上，你可以用文件的方式上传数据，前提是文件中的数据符合 InfluxDB 支持的类型，包括CSV、带Flux 注释的 CSV 和 InfluxDB 行协议。</p> 
<p><img src="https://images2.imgbox.com/b4/77/Wd1mU1R5_o.png" alt="MMSIZE"></p> 
<p>点击其中任意一个按钮，将进入数据的上传页面，页面中包含了详细的说明文档，包含你的数据应该符合什么格式，你要把数据放到哪个存储桶里，还包括用命令行来上传数据的命令模板。</p> 
<p><img src="https://images2.imgbox.com/9a/09/ULU8c2j4_o.png" alt="MMSIZE"></p> 
<p><strong>（2）写入 InfluxDB 的代码模板</strong></p> 
<p>InfluxDB 提供了各种编程语言的连接库，你甚至可以在前端嵌入向 InfluxDB 写入数据的代码，因为InfluxDB 向外提供了一套功能完整的REST API。</p> 
<p><img src="https://images2.imgbox.com/e1/71/HDHK0rWx_o.png" alt="MMSIZE"></p> 
<p>点击任何一个语言的 LOGO，你会看到使用这门语言，将数据写入到 InfluxDB 的代码模板。</p> 
<p><img src="https://images2.imgbox.com/e9/a8/ARIczJ6n_o.png" alt="MMSIZE"></p> 
<p>建议从这里拷贝初始化客户端的代码。</p> 
<p>配置Telegraf 的输入插件：</p> 
<p><img src="https://images2.imgbox.com/16/82/kiYgRLHd_o.png" alt="MMSIZE"></p> 
<p>Telegraf 是一个插件化的数据采集组件，在这里你可以找一下没有对应你的目标数据源的插件，点击它的 logo。可以看到这个插件配置的写法，但是关于这方面的内容，还是建议参考 Telegraf 的官方文档，那个更细更全一些。</p> 
<p><img src="https://images2.imgbox.com/82/b9/d9nSPPvh_o.png" alt="MMSIZE"></p> 
<h5><a id="_816"></a>管理存储桶</h5> 
<p>你可以将 InfluxDB 中的 bucket 理解为普通关系型数据库中的 database。在 Load data 页面上，点击上访的BUCKETS 选项卡，就可以进入bucket 管理页面了。</p> 
<p><img src="https://images2.imgbox.com/66/0f/Op0m2VND_o.png" alt="MMSIZE"></p> 
<blockquote> 
 <p><strong>InfluxDB 是一个无模式的数据库</strong>，也就是除了在输入数据之前需要显示创建存储桶（数据库），你不需要手动创建 measurement 或者指定各个 field 都是什么类型，你甚至可以前后在同一个measurement 下插入 filed 不同的数据。</p> 
</blockquote> 
<p>（1）创建 <strong>Bucket</strong></p> 
<p>点击右上角的 CREATE BUCKET 按钮，会有一个创建存储桶的弹窗，这里你可以给bucket 指定一个名称和数据的过期时间。比如，你设置过期时间为 6 小时，那 InfluxDB 就会自动把这个存储桶中距离当前时间超过 6 小时的数据删除。</p> 
<p><img src="https://images2.imgbox.com/1a/3e/r6ZwFOg1_o.png" alt="在这里插入图片描述"></p> 
<p>（2）调整 <strong>Bucket</strong> 的设置</p> 
<p>存储桶的过期时间的名称都是可以修改的，点击任一 Bucket 信息卡的 SETTINGS 按钮会弹出一个调整设置的会话框。</p> 
<p><img src="https://images2.imgbox.com/49/46/nJutOFvN_o.png" alt="MMSIZE"></p> 
<p>重命名是 InfluxDB 不建议的操作，因为大量的代码和 InfluxDB 定时任务都需要通过指定 Bucket 的名称来进行连接，贸然更改 Bucket 的名称可能导致这些程序无法正常工作。</p> 
<p>（3）设置 <strong>Label</strong></p> 
<p>在每个 Bucket 信息卡的左下方都有一个 Add a label 按钮，点击这个按钮，你可以为Bucket 添加一个标签。不过这个功能一般很少用</p> 
<p><img src="https://images2.imgbox.com/26/53/FaNOhvgb_o.png" alt="MMSIZE"></p> 
<p>（4）向 <strong>Bucket</strong> 添加数据</p> 
<p>每个存储桶信息卡的右边都有一个添加数据按钮，点击这个按钮可以快速导入一些数据。这里还可以创建一个抓取任务（被抓取的数据在格式上必须符合 prometheus 数据格式）</p> 
<h5><a id="_1_Bucket__849"></a>示例 1：创建 Bucket 并从文件导入数据</h5> 
<p>（1）创建 <strong>Bucket</strong></p> 
<p>将鼠标悬停在☝️ 左侧的按钮上，点击 Buckets，进入 Bucketde 的管理页面。</p> 
<p><img src="https://images2.imgbox.com/88/ea/x8YGXzYf_o.png" alt="MMSIZE"></p> 
<p>点击 CREATE BUCKET 按钮，指定一个名称，这里我们将其设为 example01， 删除策略保留默认的NEVER，表示永远不会删除数据</p> 
<p><img src="https://images2.imgbox.com/e4/8a/djNWlt5K_o.png" alt="MMSIZE"></p> 
<p>点击CREATE 按钮，可以看到我们的Buckets 已经创建成功了。</p> 
<p>（2）进入上传数据引导页面</p> 
<p>在 Load Data 页面，点击 Line Prtocol 进入 InfluxDB 行协议格式数据的上传引导页面。</p> 
<p><img src="https://images2.imgbox.com/db/57/qlKZ3gPu_o.png" alt="MMSIZE"></p> 
<p>（3）录入数据</p> 
<p><img src="https://images2.imgbox.com/58/23/m4gd6MyW_o.png" alt="MMSIZE"></p> 
<ol><li> <p>点击选择存储桶</p> </li><li> <p>选择ENTER MANUALLY，手动输入数据</p> </li><li> <p>将数据粘到输入框</p> </li><li> <p>在右侧指明时间精度，包括纳秒、微秒、毫秒和秒</p> </li></ol> 
<p>数据如下：</p> 
<pre><code class="prism language-bash">people,name<span class="token operator">=</span>tony <span class="token assign-left variable">age</span><span class="token operator">=</span><span class="token number">12</span>
people,name<span class="token operator">=</span>xiaohong <span class="token assign-left variable">age</span><span class="token operator">=</span><span class="token number">13</span>
people,name<span class="token operator">=</span>xiaobai <span class="token assign-left variable">age</span><span class="token operator">=</span><span class="token number">14</span>
people,name<span class="token operator">=</span>xiaohei <span class="token assign-left variable">age</span><span class="token operator">=</span><span class="token number">15</span>
people,name<span class="token operator">=</span>xiaohua <span class="token assign-left variable">age</span><span class="token operator">=</span><span class="token number">12</span>
</code></pre> 
<p>当前我们写的数据格式叫做 InfluxDB 行协议。</p> 
<p>最后点击 WRITE DATA，将数据写到 InfluxDB。如果出现 Data Written Successfully， 那么说明数据写入成功。</p> 
<h5><a id="_Telegraf__898"></a>管理 Telegraf 数据源</h5> 
<p>点击 Load Data 页面的 TELEGRAF 选项卡，可以快速生成一些 Telegraf 配置文件。并向外暴露一个端口，允许 telegraf 远程使用 InfluxDB 中生成的配置。</p> 
<p><img src="https://images2.imgbox.com/1b/e0/WX17mNyL_o.png" alt="MMSIZE"></p> 
<p>（1）什么是 <strong>Telegraf</strong></p> 
<p>Telegraf 是 InfluxDB 生态中的一个数据采集组件，它可以讲各种时序数据自动采集到InfluxDB。现在，Telegraf 不仅仅是 InfluxDB 的数据采集组件了，很多时序数据库都支持与 Telegraf 进行协作，不少类似的时序数据收集组件选择在 Telegraf 的基础上二次开发。</p> 
<p>（2）创建 <strong>Telegraf</strong> 配置文件</p> 
<p>InfluxDB 的 Web UI 为我们提供了几种最常用的 telegraf 配置模板，包括监控主机指标、云原生容器状态指标，nginx 和 redis 等。</p> 
<p><img src="https://images2.imgbox.com/97/43/VEwjkbKv_o.png" alt="MMSIZE"></p> 
<p>通过页面，你可以勾选几种监控目标，然后一步步操作去创建一个 Telegraf 的配置文出来。</p> 
<p>（3）管理 <strong>Telegraf</strong> 配置文件接口</p> 
<p>完成Telegraf 的配置后，页面上会多出一个关于 telegraf 实例的信息卡。如图所示：</p> 
<p><img src="https://images2.imgbox.com/09/7b/8bLLkIQ9_o.png" alt="MMSIZE"></p> 
<p>点击蓝色的 Setup Instructions。</p> 
<p><img src="https://images2.imgbox.com/49/ab/k1bWxb9g_o.png" alt="MMSIZE"></p> 
<p>会弹出一个对话框，引导你完成 telegraf 的配置。可以看到第三步的命令。</p> 
<pre><code class="prism language-bash">telegraf --config http://localhost:8086/api/v2/telegrafs/09dc7d49c444f000
</code></pre> 
<p>这个命令中有一个 URL，其实意思也就是 InluxDB 向外提供了一个 API，通过这个API 你可以访问到刚才生成的配置文件。</p> 
<p>（4）修改 <strong>Telegraf</strong> 配置</p> 
<p>已经生成的配置文件如何去修改呢？你可以点击卡片的标题。</p> 
<p><img src="https://images2.imgbox.com/17/32/R0o7xMjD_o.png" alt="MMSIZE"></p> 
<p>这个时候，会弹出一个配置文件的编辑页面，不过这个时候没有交互式的选项了，你需要自己直接面对配置文件。</p> 
<p><img src="https://images2.imgbox.com/ca/14/5vD5lumd_o.png" alt="MMSIZE"></p> 
<p>修改完配置文件后，记得点击右方的 SAVE CHANGES 保存修改。</p> 
<h5><a id="_2_Telegraf__InfluxDB_948"></a>示例 2：使用 Telegraf 将数据收集到 InfluxDB</h5> 
<p>在本示例中，我们会使用 Telegraf 这个工具将一台机器上的 CPU 使用情况转变成时序数据，写到我们的InfluxDB 中。</p> 
<p>（1）下载 <strong>Telegraf</strong></p> 
<p>可以使用下面的命令下载 telegraf：</p> 
<pre><code class="prism language-bash"><span class="token function">wget</span> https://dl.influxdata.com/telegraf/releases/telegraf-1.23.4_linux_amd64.tar.gz
</code></pre> 
<p><strong>（2）解压压缩包</strong></p> 
<p>将 telegraf 解压到目标路径。</p> 
<pre><code class="prism language-bash"> <span class="token function">tar</span> -zxvf telegraf-1.23.4_linux_amd64.tar.gz -C /opt/module/
</code></pre> 
<p>（3）创建一个新的 <strong>Bucket</strong></p> 
<p>创建一个名为 example02 的 buckets，因为是演示，所以可以将过期时间设为 1 小时。设置好后点击CREATE。</p> 
<p>（4）在 <strong>Web UI</strong> 上创建 <strong>telegraf</strong> 配置文件</p> 
<ol><li> <p>在左侧的工具栏上点击Telegraf 按钮。</p> </li><li> <p>点击右侧蓝色的 CREATE CONFIGURATION 创建 telegraf 配置文件</p> <p><img src="https://images2.imgbox.com/f2/44/VGzI3dUu_o.png" alt="MMSIZE"></p> </li><li> <p>在 Bucket 栏选择 example02，表示让 telegraf 将抓取到的数据写到 example02 存储桶中，下面的选项卡勾选 System。点击 CONTINUE。</p> <p><img src="https://images2.imgbox.com/c2/f8/O9QjqI6t_o.png" alt="MMSIZE"></p> </li><li> <p>点击 CONTINUE 按钮后，会进入一个配置插件的页面。你可以自己决定是否启用这些插件。这里需要给生成的 Telegraf 配置起一个名字，方便管理。</p> <p><img src="https://images2.imgbox.com/30/26/hIg1LwaX_o.png" alt="MMSIZE"></p> </li><li> <p>点击 CREATE AND VERIFY 按钮，这个时候其实 Telegraf 的配置就已经创建好了，你会进入一个Telegraf 的配置引导界面，如图所示：</p> <p><img src="https://images2.imgbox.com/09/55/v7WmfLfN_o.png" alt="MMSIZE"></p> </li></ol> 
<p>（5）声明 <strong>Telegraf</strong> 环境变量</p> 
<p>按照 Web UI 上的建议，首先，你要在部署 Telegraf 的主机上声明一个环境变量叫INFLUX_TOKEN，它是用来赋予 Telegraf 向 InfluxDB 写数据权限的。这里我们就不配环境变量了，请在单一的shell 会话下完成后面的操作。</p> 
<p>所以到你下载好 Telegraf 的机器上，执行下面的命令。（注意！TOKEN 是随机生成的， 请按照自己的情况修改命令）</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">INFLUX_TOKEN</span><span class="token operator">=</span>v4TsUzZWtqgot18kt_adS1r-7PTsMIQkbnhEQ7oqLCP2TQ5Q-PcUP6RMyTHLy4IryP1_2rIamNarsNqDc_S_eA<span class="token operator">==</span>
</code></pre> 
<p>（6）启动 <strong>Telegraf</strong></p> 
<p>首先 cd 到我们解压的 telegraf 目录。</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> /opt/module/telegraf-1.23.4
</code></pre> 
<p><img src="https://images2.imgbox.com/be/99/6zPg13Ey_o.png" alt="MMSIZE"></p> 
<p>telegraf 的可执行文件在 ./usr/bin 目录下。cd 过去。</p> 
<pre><code class="prism language-bash"> <span class="token builtin class-name">cd</span> ./usr/bin
</code></pre> 
<p>从 Web UI 中复制运行 telegraf 的命令，修改 host 然后执行，我的telegraf 和InfluxDB 在同一台机器上，所以可以使用 localhost。最终命令如下。</p> 
<p>运行效果如下图所示。</p> 
<p><img src="https://images2.imgbox.com/80/66/wkvyCNGl_o.png" alt="MMSIZE"></p> 
<p><strong>（7）验证数据采集结果</strong></p> 
<ol><li> <p>点击左侧按钮进入Data Explorer 页面。</p> </li><li> <p>在左下角第一个选项卡选择 example02，表示要从 example02 这个存储桶中查数据。</p> </li><li> <p>点击好第一个选项卡后，会自动弹出第二个选项卡，勾选 cpu。</p> </li><li> <p>点击右上方的 SUBMIT 按钮。</p> </li><li> <p>如果出现折线图，说明我们成功地使用Telegraf 把数据导进来了。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/18/23/gZyktz6k_o.png" alt="在这里插入图片描述"></p> 
<p><strong>（8）编写启停脚本</strong></p> 
<p>后面我们很多时候都要使用 telegraf 抓取的主机监控数据来进行查询演示。为了方便启停，我们编写一个shell 脚本来管理 telegraf 任务。</p> 
<ol><li> <p>首先 cd 到~/bin 路径下，如果~路径下没有 bin，就创建 bin 这个目录。通常，~/bin 是 PATH 环境变量包含的一个目录。</p> <pre><code class="prism language-bash"><span class="token builtin class-name">cd</span> ~
<span class="token function">mkdir</span> bin
<span class="token builtin class-name">cd</span> ~/bin
</code></pre> </li><li> <p>到~/bin 路径下创建一个文件 host_tel.sh</p> <pre><code class="prism language-bash"> <span class="token function">vim</span> host_tel.sh
</code></pre> </li><li> <p>键入如下内容</p> <pre><code class="prism language-shell"><span class="token shebang important">#!/bin/bash</span>
<span class="token function-name function">is_exist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token assign-left variable">pid</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> telegraf <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token function">grep</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2}'</span><span class="token variable">`</span></span>
    <span class="token comment"># 如果不存在返回 1，存在返回 0</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">${pid}</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    	<span class="token builtin class-name">return</span> <span class="token number">1</span>
    <span class="token keyword">else</span>
    	<span class="token builtin class-name">return</span> <span class="token number">0</span>
    <span class="token keyword">fi</span>
<span class="token punctuation">}</span>
<span class="token function-name function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    is_exist
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq <span class="token string">"0"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    	<span class="token function">kill</span> <span class="token variable">${pid}</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq <span class="token string">"0"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    	<span class="token builtin class-name">echo</span> <span class="token string">"进程号:<span class="token variable">${pid}</span>,弄死你"</span>
    <span class="token keyword">else</span>
    	<span class="token builtin class-name">echo</span> <span class="token string">"进程号:<span class="token variable">${pid}</span>,没弄死"</span>
    <span class="token keyword">fi</span>
    <span class="token keyword">else</span>
    	<span class="token builtin class-name">echo</span> <span class="token string">"本来没有 telegraf 进程"</span>
    <span class="token keyword">fi</span>
<span class="token punctuation">}</span>
<span class="token function-name function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    is_exist
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq <span class="token string">"0"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    	<span class="token builtin class-name">echo</span> <span class="token string">"跑着呢，pid 是<span class="token variable">${pid}</span>"</span>
    <span class="token keyword">else</span>
    	<span class="token builtin class-name">export</span> <span class="token assign-left variable">INFLUX_TOKEN</span><span class="token operator">=</span>v4TsUzZWtqgot18kt_adS1r-7PTsMIQkbnhEQ7oqLCP2TQ5Q-PcUP6RMyTHLy4IryP1_2rIamNarsNqDc_S_eA<span class="token operator">==</span>
    /opt/module/telegraf-1.23.4/usr/bin/telegraf --config http://localhost:8086/api/v2/telegrafs/09dcf4afcfd90000
    <span class="token keyword">fi</span>
<span class="token punctuation">}</span>
<span class="token function-name function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	is_exist
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq <span class="token string">"0"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    	<span class="token builtin class-name">echo</span> <span class="token string">"telegraf 跑着呢"</span>
    <span class="token keyword">else</span>
    	<span class="token builtin class-name">echo</span> <span class="token string">"telegraf 没有跑"</span>
    <span class="token keyword">fi</span>
<span class="token punctuation">}</span>
<span class="token function-name function">usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token builtin class-name">echo</span> <span class="token string">"哦！请你 start 或 stop 或 status"</span>
    <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">case</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token keyword">in</span>
    <span class="token string">"start"</span><span class="token punctuation">)</span>
    	start
   		<span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">"stop"</span><span class="token punctuation">)</span>
    	stop
    	<span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">"status"</span><span class="token punctuation">)</span>
    	status
    	<span class="token punctuation">;</span><span class="token punctuation">;</span>
    *<span class="token punctuation">)</span>
    	usage
    	<span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">esac</span> 最后
</code></pre> </li><li> <p>最后给这个脚本加上一个执行权限，你可以执行下面的代码。</p> <pre><code class="prism language-bash"><span class="token function">chmod</span> <span class="token number">755</span> ./host_tel.sh
</code></pre> <h5><a id="_1130"></a>管理抓取任务</h5> </li></ol> 
<p><strong>（1）什么是抓取任务</strong></p> 
<p>抓取任务就是你给定一个 URL，InfluxDB 每隔一段时间去访问这个链接，把访问到的数据入库。</p> 
<p>在 InfluxDB 1.x 的时候，类似的任务只能由Telegraf 来实现。在 InfluxDB 2.x 中，内置了抓取功能（但是定制性上不如 Telegraf，比如轮询间隔只能是 10 秒）</p> 
<p><img src="https://images2.imgbox.com/6c/97/rdIJAipz_o.png" alt="MMSIZE"></p> 
<p>另外， 目标 URL 暴露出来的数据格式必须得是 Prometheus 数据格式。</p> 
<p>（2）<strong>InfluxDB</strong> 自身暴露的监控接口</p> 
<p>你可以访问 http://localhost:8086/metrics 来查看 InfluxDB 暴露出来的性能数据。这里面有，InfluxDB 的 GC 情况</p> 
<p><img src="https://images2.imgbox.com/45/a3/F7MuDKUU_o.png" alt="MMSIZE"></p> 
<p>以及各个API 的使用情况，如图所示，说的是各个 API 被谁请求过多少次。</p> 
<p><img src="https://images2.imgbox.com/ca/e3/CR21oHLf_o.png" alt="MMSIZE"></p> 
<h5><a id="_3_InfluxDB__1154"></a>示例 3：让 InfluxDB 主动拉取数据</h5> 
<p><strong>（1）创建一个存储桶</strong></p> 
<p>创建了一个名为 example03 的存储桶。数据的过期时间设为 1 小时。</p> 
<p><strong>（2）创建抓取任务</strong></p> 
<ol><li> <p>进入抓取任务的管理页面</p> </li><li> <p>点击CREATE SCRAPER 按钮，创建抓取任务。</p> <p><img src="https://images2.imgbox.com/c2/c6/oA9fotx3_o.png" alt="MMSIZE"></p> </li><li> <p>在对话框上，给抓取任务起一个名字，此处命名为 example03_scraper</p> </li><li> <p>右方的下拉框上，选择我们刚才创建的存储桶，example03。</p> </li><li> <p>最下方设置一下目标路径，最后点击 CREATE</p> <p><img src="https://images2.imgbox.com/46/e2/eD0RB4OO_o.png" alt="MMSIZE"></p> </li><li> <p>如果页面上出现新的卡片，说明配置成功。接下来去看一下数据有没有进来。</p> <p><img src="https://images2.imgbox.com/80/ec/H9AXZK9g_o.png" alt="MMSIZE"></p> </li></ol> 
<p><strong>（3）验证抓取结果</strong></p> 
<ol><li> <p>点击左侧的按钮，打开Data Explorer</p> </li><li> <p>在左下角第一个卡片选择要从哪个存储桶抽取数据，本例对应的是 example03</p> </li><li> <p>第一个卡片选择好后，会自动弹出第二个卡片，你可以选择任意一个指标名称。</p> </li><li> <p>点击右侧的 SUBMIT 按钮，提交查询。</p> </li><li> <p>如果折线图成功加载，说明有数据了，抓取成功！</p> </li></ol> 
<p><img src="https://images2.imgbox.com/ce/fb/zamiFu1G_o.png" alt="MMSIZE"></p> 
<h5><a id="_API_Token_1196"></a>管理 API Token</h5> 
<p>点击左侧的 API Tokens 按钮，进入 API Token 的管理页面。</p> 
<p><img src="https://images2.imgbox.com/20/85/9FQ3DjMl_o.png" alt="MMSIZE"></p> 
<p>（1）<strong>API Token</strong> 是干什么用的</p> 
<p>简单来说，influxdb 会向外暴露一套 HTTP API。我们后面要学的命令行工具什么的， 其实都是封装的对 influxdb 的 http 请求。所以，在 InfluxDB 中，对权限的管理主要就体现在 API 的 Tokens 上。客户端会将 token 放到 http 的请求头上，influxdb 服务端就根据客户端发来的请求头部的 token，来判断你能不能对某个存储桶读写，能不能删除存储桶，创建仪表盘等。</p> 
<p>（2）查看 <strong>API Token</strong> 权限</p> 
<p>截至目前，我们还没有自己手动创建过 API Token。但是可以看到页面上已经有一些Token 了，这些 Token 是由我们之前示例里面的操作自动生成的。</p> 
<p><img src="https://images2.imgbox.com/3e/51/g84GxU2X_o.png" alt="MMSIZE"></p> 
<p>（3）了解 <strong>tony’s Token</strong></p> 
<p>现在，我们围绕着 InfluxDB 中已有的 Token 来学习相关的知识，我们的 InfluxDB 上现在只有初始化时创建的tony 账户，在 Token 列表中，我们可以看到有一个名为tony’s Token 的 token。</p> 
<p><img src="https://images2.imgbox.com/8b/a9/WtFTZCYP_o.png" alt="MMSIZE"></p> 
<ol><li>修改 <strong>token</strong> 的名称</li></ol> 
<p>点击 token 右边的符号，可以修改token 名称。</p> 
<ul><li> <p>没有客户端会用 token 的名称来调用 token，所以修改 token 名称不会影响已经部署的应用。</p> </li><li> <p>InfluxDB 从未要求 token 的名称必须全局唯一，所以名称重复也是可以的。</p> </li></ul> 
<ol start="2"><li> <p><strong>token</strong> 可以临时关停、也可以删除</p> <p>正如你说看到，token 卡片下面的 <strong>Active</strong> 按钮是一个开关，可以在启用和停用之间进行切换。</p> <p>同时，你也可以删除 token，但是这可能对你已经部署的应用产生不可挽回的影响。</p> </li><li> <p>查看 <strong>Token</strong> 权限</p> <p>点击 token 的名称，可以看到这个 token 具体有哪些权限。这里我们比较两个token，可以看到 tony’ Token 的权限很高。</p> <p><img src="https://images2.imgbox.com/f6/2c/YoZEnqK0_o.png" alt="MMSIZE"></p> <p>下面这个Token 是我们前面示例，生成Telegraf 配置的时候自动生成的 token。</p> <p><img src="https://images2.imgbox.com/89/79/MPiU3cRe_o.png" alt="MMSIZE"></p> <p>点开看一下它的权限。</p> <p><img src="https://images2.imgbox.com/ab/a0/HHSYe7fY_o.png" alt="MMSIZE"></p> <p>可以看到这个 token 的权限就小得多了，它只能向一个存储桶里写数据，查的权限都没有呢。</p> </li></ol> 
<p>（4）创建 <strong>API Token</strong></p> 
<p>页面的右方有一个 GENERATE API TOKEN。点一下会出来一个下拉菜单，这其实是Web UI 上的权限模板</p> 
<p><img src="https://images2.imgbox.com/1f/d3/MUWiZV9B_o.png" alt="MMSIZE"></p> 
<p>在 Web UI 上，有两种类型的模板让你可以快速创建 token。</p> 
<ul><li> <p>Read/Write API Token 仅读写存储桶的Token</p> <p>创建Token 时还可以限定这个Token 能操作哪些存储桶。</p> <p><img src="https://images2.imgbox.com/e9/f7/Ki8Cfw79_o.png" alt="MMSIZE"></p> </li><li> <p>All Access API Token 生成带所有权限的Token</p> <p><img src="https://images2.imgbox.com/f0/fd/DRNzQMS4_o.png" alt="MMSIZE"></p> </li></ul> 
<p>注意！InfluxDB 的 Token 是可以进行更细的管理的，Web UI 上给的只是生成 Token 的模板，准备了用户的常用需求，但不代表它的全部功能。</p> 
<h4><a id="_1272"></a>查询工具</h4> 
<p>S关于 InfluxDB 的查询，需要用户掌握一门叫 <strong>FLUX</strong> 的语言。本节暂时不讲解 FLUX 语言的知识，而是先了解InfluxDB 重要的两个开发工具——<strong>Data Explorer</strong> 和<strong>Notebook</strong>。</p> 
<h5><a id="Data_Explorer_1276"></a>Data Explorer</h5> 
<p>explorer，探险家、探索者的意思。所以正如其字面意思，你可以使用Data Explorer 探索数据，理解数据。说白了，就是你可以尝试性地写写 FLUX 查询语言（InfluxDB 独创的一门独立查询语言），看一下数据的效果。开发过程中，你可以将它作为一个 FLUX 语言的 IDE。但是，目前我们不会向大家讲解 FLUX 语言。</p> 
<p>点击左边的图标，进入Data Explorer。</p> 
<p>我们可以将 Data Explorer 的界面简单分为两个区域，上半部分为<strong>数据预览区</strong>，下半部分为<strong>查询编辑区</strong>。</p> 
<p><img src="https://images2.imgbox.com/66/6f/ylLTXUDj_o.png" alt="MMSIZE"></p> 
<p><strong>（1）查询编辑区</strong></p> 
<p>查询编辑区为你提供了两种查询工具，一个是查询构造器，一个是 FLUX 脚本编辑器。</p> 
<p>1）查询构造器</p> 
<p>你一进入 Data Explorer 页面，默认会打开查询构造器。使用查询构造器，你可以通过点按的方式完成查询。它背后的原理其实是根据你的设置，自动生成一条 FLUX 语句，提交给数据库完成查询。</p> 
<p>能够出现查询构造器这种东西，说明时序数据的查询之间遵循着某种规律。不同业务之间的查询步骤可能高度相似。</p> 
<p><img src="https://images2.imgbox.com/56/0e/cLDCAOJo_o.png" alt="MMSIZE"></p> 
<p>如上图，这是查询构造器的极简介绍。</p> 
<p>2）<strong>FLUX</strong> 脚本编辑器</p> 
<p>你可以手动将查询构造器切换为 <strong>FLUX</strong> 脚本编辑器。然后愉快地编写 FLUX 脚本，实现各种奇葩查询。编辑器十分友好，还带自动提示和函数文档。</p> 
<p><img src="https://images2.imgbox.com/f4/19/2q7YwTHH_o.png" alt="MMSIZE"></p> 
<p><strong>（2）数据预览区</strong></p> 
<p>数据预览区可以将你的数据展示出来。下图是一个效果图。</p> 
<p><img src="https://images2.imgbox.com/c8/57/4Yy7XgKV_o.png" alt="MMSIZE"></p> 
<p>默认情况下，数据预览区会将你的数据展示为一个折线图。不过除此之外，你还可以让数据展示为散点图、饼图或者查看原始数据等等。</p> 
<p>（3）其他功能</p> 
<p>除了查询和展示数据的功能外。Data Explorer 还有一些拓展功能</p> 
<ol><li><strong>将数据导出为</strong> <strong>CSV</strong></li></ol> 
<p>在执行查询之后，DataExplorer 允许你快速地将数据导出为一个 CSV 文件。</p> 
<p><img src="https://images2.imgbox.com/cc/9d/JeulQ5jX_o.png" alt="MMSIZE"></p> 
<ol start="2"><li><strong>将当前查询和可视化效果保存为仪表盘的一个单元</strong></li></ol> 
<p>你可以将当前的查询逻辑和图形展示保存为某个仪表盘的一部分。这个功能需要在查询逻辑已经实现的前提下，点击右上角的 SAVE AS 触达。</p> 
<p><img src="https://images2.imgbox.com/f1/62/lFkIMh2H_o.png" alt="MMSIZE"></p> 
<ol start="3"><li> <p><strong>创建定时任务</strong></p> <p><img src="https://images2.imgbox.com/9a/c6/G3PmctfJ_o.png" alt="MMSIZE"></p> <p>Data Explorer 中的查询逻辑可以保存为一个定时任务，也就是 TASK。这里提前说一下 InfluxDB 中的 TASK 是什么。TASK 其实是一个定时执行的 FLUX 语言写的脚本。因为FLUX 是一个脚本语言，所以它其实有一定的 IO 能力。可以使用 http 与外面的系统进行通信，还可以将计算完的数据回写给 InfluxDB。所以通常TASK 有两种使用场景。</p> 
  <ul><li>数据检查与报警。对查询后的结果进行一下条件判断，如果不合规，就使用 http向外通知报警。</li><li>聚合操作。在 InfluxDB 里开窗完成聚合计算，计算后的数据再写回到 InfluxDB， 这样下游 BI（数据看板）可以直接去查询聚合后的数据了，而不是每次都把数据从InfluxDB 里拉出来重新计算。这样可以减少 IO，不过会增加 InfluxDB 的压力。生产环境下需要根据实际情况进行取舍。</li></ul> </li></ol> 
<p> </p> 
<ol start="4"><li> <p><strong>定义全局变量</strong></p> <p>在 DataExplorer 里，你可以声明一些全局变量。全局变量的类型可以是 Map（键值对）、CSV 和 FLUX 脚本。这样，将来你可以直接引用这些变量，比如你的数据里有地区编码。你就可以将编码到地区名称的映射保存为一个全局Map，供以后每次查询时使用。</p> <p><img src="https://images2.imgbox.com/52/6a/m5GTJxXr_o.png" alt="MMSIZE"></p> </li></ol> 
<h5><a id="_4_Data_Explorer__1351"></a>示例 4：在 Data Explorer 使用查询构造器进行查询和可视化</h5> 
<p>（1）打开 <strong>Data Explorer</strong></p> 
<p>点击左侧的按钮，进入Data Explorer 页面。</p> 
<p><img src="https://images2.imgbox.com/43/76/x5GBir8P_o.png" alt="MMSIZE"></p> 
<p><strong>（2）设置查询条件</strong></p> 
<p>我们现在要查询的是 test_init 存储桶下的 go_goroutines 测量，这个测量反应的是我们InfluxDB 进程中的 goroutines（轻量级线程）数量。</p> 
<p>首先，在左下角的查询构造器的 FROM 选项卡，选择 test_init 存储桶</p> 
<p><img src="https://images2.imgbox.com/ad/01/wlrfJjW1_o.png" alt="MMSIZE"></p> 
<p>接着会弹出一个 Filter 选项卡，默认情况下这里是选择_measurement，此处我们选择go_goroutines。</p> 
<p><strong>（3）注意查询时间范围</strong></p> 
<p>右上角有一个带时钟符号的下拉菜单，这个菜单可以帮你纵向选择要查询数据的时间范围，通常默认是 1h。如下图所示：</p> 
<p><img src="https://images2.imgbox.com/5a/77/CmL54OrR_o.png" alt="MMMSIZE"></p> 
<p><strong>（4）注意右侧的窗口聚合选项</strong></p> 
<p>在查询构造器的最右边，有一个开窗聚合选项卡。使用查询构造器进行查询，就必须使用开窗聚合。默认情况下，DataExplorer 会根据你设置的查询时间范围，自动调整窗口大小，此处查询范围 1h 对应窗口大小 10s。</p> 
<p><img src="https://images2.imgbox.com/cf/be/WaDRFmnE_o.png" alt="MMMSIZE"></p> 
<p>同时，聚合方式默认是平均值。</p> 
<p><strong>（5）提交查询</strong></p> 
<p>点击右侧的 SUBMIT 按钮可以立刻提交查询。之后，数据展示区会出现相应的折线图。如下图所示：</p> 
<p><img src="https://images2.imgbox.com/6d/54/dpG3mbJ8_o.png" alt="MMSIZE"></p> 
<p>点击View Raw Data，可以看到原始数据。</p> 
<p><img src="https://images2.imgbox.com/43/ee/aQ537MDI_o.png" alt="MMSIZE"></p> 
<p><strong>（6）查询原理</strong></p> 
<p>我们使用查询构造器进行查询，其实是 Web UI 根据我们指定的查询条件生成了一套FLUX 查询脚本。点击SCRIPT EDITOR 按钮，可以看到查询构造器生成的 FLUX 脚本。</p> 
<p><img src="https://images2.imgbox.com/fa/e4/4n1ijw2U_o.png" alt="在这里插入图片描述"></p> 
<p><strong>（7）可视化原理</strong></p> 
<p>其实默认情况下的可视化，是依据返回数据中的_value 来展示的，但是有些时候，你想查询的数据可能字段名不会被判别为_value。它会安静地躺在原始数据中。</p> 
<p><img src="https://images2.imgbox.com/10/79/Tjl98XJy_o.png" alt="MMSIZE"></p> 
<h5><a id="Notebook_1416"></a>Notebook</h5> 
<p>Notebook 是 InfluxDB2.x 推出的功能，交互上模仿了 Jupyter NoteBook。它可以用于开发、文档编写、运行代码和展示结果。</p> 
<p>你可以将 InfluxDB 笔记本视为按照顺序处理数据的集合。每个步骤都由一个“单元格” 表示。一个单元格可以执行查询、可视化、处理或将数据写入存储桶等操作。Notebook 可以帮你完成下述操作：</p> 
<ul><li> <p>执行 FLUX 代码、可视化数据和添加注释性的片段</p> </li><li> <p>创建报警或者计划任务</p> </li><li> <p>对数据进行降采样或者清洗</p> </li><li> <p>生成要和团队分享的 Runbooks</p> </li><li> <p>将数据回写到存储桶</p> </li></ul> 
<p>Notebook 和 DataExplorer 相比，主要是交互风格上的不同。DataExplorer 倾向于一锤子买卖，而 Notebook 可以将数据展示拆分为一个又一个具体的步骤。另外，NoteBook 可以用来开发告警任务DataExplorer 则不能。</p> 
<p>（1）进入 <strong>Notebook</strong> 的导航界面</p> 
<p>点击左侧的按钮，即可进入 Notebook 的导航页面。</p> 
<p><img src="https://images2.imgbox.com/be/34/ReFZBmRc_o.png" alt="MMSIZE"></p> 
<p>导航页面分两个部分：</p> 
<ul><li> <p>上面是创建引导，除了创建一个空白的 Notebook，InfluxDB 还为你提供了 3 个模板。分别是 Set an Alert（设置一个报警）、Schedule a Task （调度一个任务）、write a Flux Script（写一个 Flux 脚本）。</p> </li><li> <p>下面是 Notebook 列表，过去你创建过的NoteBook 再这里都会展示出来。</p> </li></ul> 
<p>卡片上还有这个 Notebook 对应的创建时间和修改时间。通过卡片你可以对一个Notebook 重命名，还可以将它复制和删除。</p> 
<p>（2）<strong>创建一个空白的</strong> <strong>notebook</strong></p> 
<p>想要继续后面的步骤，我们必须先创建一个 Notebook。</p> 
<p>现在，你看到的就是 Notebook 的操作页面了。</p> 
<p><img src="https://images2.imgbox.com/6b/eb/HmTKerKx_o.png" alt="MMSIZE"></p> 
<p>（3）<strong>NoteBook 工作流</strong></p> 
<p>目前你看到的页面应当是如下图所示的样子。</p> 
<p><img src="https://images2.imgbox.com/27/33/oVg4ASTq_o.png" alt="MMSIZE"></p> 
<p>我们在页面中看到的一个又一个卡片，在 NoteBook 中叫做 Cell。一个 NoteBook 工作流就是多个 Cell 按照先后顺序组合起来的执行流程。这些 Cell 中间随时可以插入别的 Cell， 而且Cell 和Cell 还可以调换顺序。</p> 
<p>按照Cell 功能，Cell 可以按照下面的方式分类。</p> 
<p><img src="https://images2.imgbox.com/34/ee/bALeibns_o.png" alt="MMSIZE"></p> 
<ul><li> <p>数据源相关的Cell</p> 
  <ul><li> <p>查询构造器</p> </li><li> <p>直接编写 FLUX 脚本</p> </li></ul> </li><li> <p>可视化相关的Cell</p> 
  <ul><li> <p>将数据展示为一个Table</p> </li><li> <p>将数据展示为一张图</p> </li><li> <p>添加笔记。</p> </li></ul> </li><li> <p>行为Cell</p> 
  <ul><li> <p>进行报警</p> </li><li> <p>定时任务设定</p> </li></ul> </li></ul> 
<p>（4）<strong>工作流范式</strong></p> 
<p>在 NoteBook 里编写工作流通常是有套路可循的。</p> 
<p><img src="https://images2.imgbox.com/20/0f/WVeUXONt_o.png" alt="MMSIZE"></p> 
<p>通常一个 notebook 工作流以查询数据开始，后面的 Cell 跟上把数据展示出来，当数据需要进一步修改的时候，可以再加一个 FLUX 脚本 cell，notebook 为我们留了一个接口， 通过这种方式，后面的Flux cell 可以将前面的数据作为数据源进行查询。</p> 
<p>最终，notebook 工作流可以以任务设置或者报警操作作为整个工作流的终点，当然这不是强制要求。</p> 
<p>（5）<strong>NoteBook 控件</strong></p> 
<p>在 notebook 上存在下述几种控件</p> 
<ol><li> <p>时区转换</p> <p>右上角有一个 Local 按钮，通过这个按钮，你可以选择将日期时间显示为系统所设时区还是 UTC 时间。</p> <p><img src="https://images2.imgbox.com/3d/4e/WuVZ8hVe_o.png" alt="MMMSIZE"></p> </li><li> <p>仅显示可视化</p> <p>点击 Presentation 按钮，可以选择是否仅显示数据展示的 cell。如果开启这个选项，那么查询构造器和FLUX 脚本的Cell 就会被折叠。</p> </li></ol> 
<p><img src="https://images2.imgbox.com/6e/dc/dvDQz99B_o.png" alt=""></p> 
<ol start="3"><li> <p>删除按钮</p> <p>点击确定后，可以删除整个 notebook。</p> </li><li> <p>复制按钮</p> <p>右上角的复制按钮可以立刻为当前NoteBook 创建一个副本。</p> </li><li> <p>运行按钮</p> <p>RUN 按钮可以快速地执行Notebook 中的查询操作并重新渲染其中的可视化Cell。</p> </li></ol> 
<h5><a id="_5_NoteBook__1532"></a>示例 5：使用 NoteBook 查询和可视化数据</h5> 
<p><strong>（1）使用查询构造器进行查询</strong></p> 
<p>默认情况下，你创建的空白 NoteBook，自带 3 个 cell。</p> 
<p><img src="https://images2.imgbox.com/29/b7/vEH4vpMM_o.png" alt="MMSIZE"></p> 
<p>第一个 cell，默认是一个查询构造器，相对于 DataExplorer 来说，notebook 的查询构造器不同的地方在于它没有开窗聚合操作。</p> 
<p>此处，同样还是查询 test_init 中的 go_goroutines 测量。</p> 
<p><img src="https://images2.imgbox.com/c0/14/0omK25Q1_o.png" alt="MMSIZE"></p> 
<p><strong>（2）提交查询</strong></p> 
<p>点击RUN 按钮。</p> 
<p>可以看到下面的原始数据和折线图都出现了：</p> 
<p><img src="https://images2.imgbox.com/60/4c/PfyCzfPD_o.png" alt="MMSIZE"></p> 
<p><strong>（3）添加说明 cell</strong></p> 
<p>notebook 允许用户在工作流中加入说明性的 cell。我们选择在最前面加一个说明性 cell。</p> 
<p>首先，点击左侧的紫色＋号。</p> 
<p><img src="https://images2.imgbox.com/e8/3e/6JOUr1Q6_o.png" alt="MMSIZE"></p> 
<p>点击 NOTE 按钮。可以看到， 我们已经创建了一个说明 cell 。这里面还支持MarkDown 语法，</p> 
<p><img src="https://images2.imgbox.com/83/26/xyKOb7w1_o.png" alt="MMSIZE"></p> 
<p>点击右上右上角的PREVIEW 按钮，markdown 就会被渲染展示。</p> 
<p><img src="https://images2.imgbox.com/90/79/SZUpuLFx_o.png" alt="MMSIZE"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/33da3c89ad9a17a0e463edcc2ad79658/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx中斜杠(‘/‘)总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/05d73c091eef6fd4ef3920f590e163da/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java异常：Java.util.ConcurrentModificationException异常处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>