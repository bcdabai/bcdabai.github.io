<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>扩展OSGi控制台，通过web访问操作console，支持3.4、3.6 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="扩展OSGi控制台，通过web访问操作console，支持3.4、3.6" />
<meta property="og:description" content="当我们在开发基于OSGi的应用时，不可避免的要通过它的控制台进行相关调试。在开发阶段，调试可以直接在eclipse控制台输入相关命令，而当我们把程序部署到web服务器上后就不能再采用这样的方式了。但幸运的是，我们可以扩console以满足自己的需要，因此可以实现一个通过web访问console的方式。扩展conso可以参考基于 Equinox 的 OSGi Console 的研究和探索。
由于equinox 3.4和3.6在代码结构上的差异，要扩展一个通用的通过web控制的console，用反射是个好的选择，eg. FrameworkConsole的构造函数不一致，3.6已经没有OSGi这个类...以下是详细实现：
WebConsoleServlet.java，发布该servlet让客户端访问，并通过参数cmd传输相关的OSGi命令：
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&#34;text/html;charset=utf-8&#34;); response.setCharacterEncoding(&#34;utf-8&#34;); try { String command = request.getParameter(&#34;cmd&#34;); try { final CommandServiceFacade facade = CommandServiceFacade.INSTANCE; facade.setContext(Activator.bundleContext); facade.setOut(response); facade.execute(command); } catch (Exception e) { e.printStackTrace(); } } catch (Exception e) { e.printStackTrace(); } }CommandServiceFacade.java，封装具体实现： public class CommandServiceFacade { private static final String OSGI_VERION_3_4 = &#34;3.4&#34;; private static final String OSGI_VERION_3_6 = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8a11f67e335061ca9d680a9178fcdeae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-04-02T23:01:37+08:00" />
<meta property="article:modified_time" content="2013-04-02T23:01:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">扩展OSGi控制台，通过web访问操作console，支持3.4、3.6</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>         当我们在开发基于OSGi的应用时，不可避免的要通过它的控制台进行相关调试。在开发阶段，调试可以直接在eclipse控制台输入相关命令，而当我们把程序部署到web服务器上后就不能再采用这样的方式了。但幸运的是，我们可以扩console以满足自己的需要，因此可以实现一个通过web访问console的方式。扩展conso可以参考<a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-equnxc/" rel="nofollow">基于 Equinox 的 OSGi Console 的研究和探索</a>。</p> 
<p>         由于equinox 3.4和3.6在代码结构上的差异，要扩展一个通用的通过web控制的console，用反射是个好的选择，eg. FrameworkConsole的构造函数不一致，3.6已经没有OSGi这个类...以下是详细实现：</p> 
<p>WebConsoleServlet.java，发布该servlet让客户端访问，并通过参数cmd传输相关的OSGi命令：</p> 
<p></p> 
<pre><code class="language-java">	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException,
			IOException {
		response.setContentType("text/html;charset=utf-8");
		response.setCharacterEncoding("utf-8");
		try {
			String command = request.getParameter("cmd");
			try {
				final CommandServiceFacade facade = CommandServiceFacade.INSTANCE;
				facade.setContext(Activator.bundleContext);
				facade.setOut(response);
				facade.execute(command);
			} catch (Exception e) {
				e.printStackTrace();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}</code></pre>CommandServiceFacade.java，封装具体实现： 
<br> 
<p></p> 
<p></p> 
<pre><code class="language-java">public class CommandServiceFacade {
    private static final String OSGI_VERION_3_4 = "3.4";
    private static final String OSGI_VERION_3_6 = "3.6";

    /**
     * OSGi版本号.
     */
    private String osgiVersion = null;

    /**
     * bundle上下文容器.
     */
    private BundleContext context = null;

    /**
     * FrameworkConsole输出流，适用于OSGi3.4.
     */
    private PrintWriter out = null;

    /**
     * FrameworkConsole输出流，适用于OSGi3.6.
     */
    private OutputStream outputStream = null;

    /**
     * 单例.
     */
    public static final CommandServiceFacade INSTANCE = new CommandServiceFacade();

    /**
     * 私有构造函数.
     */
    private CommandServiceFacade() {
    }

    /**
     * 设置bundle上下文环境.
     * 
     * @param context
     *            bundle上下文容器.
     */
    public void setContext(final BundleContext context) {
        this.context = context;
    }

    /**
     * 设置Console输出流.
     */
    public void setOut(final HttpServletResponse response) {
        try {
            if (OSGI_VERION_3_6.equals(getOSGiVersion())) {
                this.outputStream = response.getOutputStream();
            } else if (OSGI_VERION_3_4.equals(getOSGiVersion())) {
                this.out = response.getWriter();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 设置控制台输出流.
     */
    public void setOut(final OutputStream os) {
        try {
            if (OSGI_VERION_3_6.equals(getOSGiVersion())) {
                this.outputStream = os;
            } else if (OSGI_VERION_3_4.equals(getOSGiVersion())) {
                this.out = new PrintWriter(new OutputStreamWriter(os, "GB2312"));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * &lt;pre&gt;
     * 执行控制台命令. 
     * 由于OSGi3.4和3.6在代码结构上的差异，要扩展一个通用的通过web控制的console，用反射是个好的选择.
     * eg. FrameworkConsole的构造函数不一致，3.6已经没有OSGi这个类...
     * &lt;/pre&gt;
     */
    public void execute(final String command) {
        if (null == command || command.length() == 0) {
            return;
        }
        final ClassLoader systemBundleCL = context.getBundle(0).getClass().getClassLoader();
        if (OSGI_VERION_3_6.equals(getOSGiVersion())) {
            try {
                final ServiceTracker cpTracker = new ServiceTracker(context, CommandProvider.class.getName(), null);
                cpTracker.open();
                final Class conSessClass = systemBundleCL
                        .loadClass("org.eclipse.osgi.framework.internal.core.FrameworkConsoleSession");
                final Constructor conSessConstructor = conSessClass.getConstructor(new Class[] { InputStream.class,
                        OutputStream.class, Socket.class });
                // Class FrameworkConsoleSession
                final Object conSess = conSessConstructor.newInstance(new Object[] {
                        new ByteArrayInputStream(command.getBytes()), outputStream, null });
                final Class fcClass = systemBundleCL
                        .loadClass("org.eclipse.osgi.framework.internal.core.FrameworkConsole");
                final Class csClass = systemBundleCL.loadClass("org.eclipse.osgi.framework.console.ConsoleSession");
                final Constructor fcConstructor = fcClass.getConstructor(new Class[] { BundleContext.class, csClass,
                        Boolean.TYPE, ServiceTracker.class });
                // Class FrameworkConsole
                final Object fc = fcConstructor
                        .newInstance(new Object[] { context, conSess, Boolean.FALSE, cpTracker });
                fcClass.getMethod("run", null).invoke(fc, null);
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else if (OSGI_VERION_3_4.equals(getOSGiVersion())) {
            try {
                final Class fcClass = systemBundleCL
                        .loadClass("org.eclipse.osgi.framework.internal.core.FrameworkConsole");
                final Class osgiClass = systemBundleCL.loadClass("org.eclipse.osgi.framework.internal.core.OSGi");
                final Constructor fcConstructor = fcClass.getConstructor(new Class[] { osgiClass, String[].class });
                // Class FrameworkConsole
                final Object fc = fcConstructor.newInstance(new Object[] { getOsgi(), new String[0] });
                final Class intpClass = systemBundleCL
                        .loadClass("org.eclipse.osgi.framework.internal.core.FrameworkCommandInterpreter");
                final Constructor intpConstructor = intpClass.getConstructor(new Class[] { String.class,
                        Object[].class, fcClass });
                // Class FrameworkCommandInterpreter
                final Object interpreter = intpConstructor.newInstance(new Object[] { command, getServices(), fc });
                final Field out = intpClass.getDeclaredField("out");
                out.setAccessible(true);
                out.set(interpreter, this.out);
                final Method nextArgument = intpClass.getMethod("nextArgument", null);
                final Method execute = intpClass.getMethod("execute", String.class);
                execute.invoke(interpreter, (String) nextArgument.invoke(interpreter, null));
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            // 暂不处理其他版本
        }
    }

    /**
     * 获取OSGi的版本，只取前2位.
     * 
     * @return OSGi的版本
     */
    private String getOSGiVersion() {
        if (null == this.osgiVersion &amp;&amp; context != null) {
            this.osgiVersion = context.getBundle(0).getHeaders().get(Constants.BUNDLE_VERSION).toString()
                    .substring(0, 3);
        }
        return this.osgiVersion;
    }

    /**
     * OSGi framework对象.
     * 
     * @return OSGi framework.
     */
    private static Object getOsgi() {
        Object osgi = null;
        try {
            Field osgiField = EclipseStarter.class.getDeclaredField("osgi");
            osgiField.setAccessible(true);
            osgi = osgiField.get(null);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return osgi;
    }

    /**
     * @return service对象数组.
     */
    private Object[] getServices() {
        final ServiceTracker cptracker = new ServiceTracker(context, CommandProvider.class.getName(), null);
        cptracker.open();
        final ServiceReference[] serviceRefs = cptracker.getServiceReferences();
        if (serviceRefs == null) {
            return new Object[0];
        }
        Util.dsort(serviceRefs, 0, serviceRefs.length);
        final Object[] serviceObjects = new Object[serviceRefs.length];
        for (int i = 0; i &lt; serviceRefs.length; i++) {
            serviceObjects[i] = context.getService(serviceRefs[i]);
        }
        return serviceObjects;
    }
}
</code></pre> 
<br> 
<p></p> 
<p><br> </p> 
<p><br> </p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/454e28c98066c1595fac3a947cd7b38a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[转]autowire属性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b0fd634c1f8813638ec4b983df18555/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QT中用Qpainter的drawText方法程序crash的可能原因</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>