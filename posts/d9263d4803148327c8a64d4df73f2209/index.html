<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32G0系列的启动配置与程序下载说明 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32G0系列的启动配置与程序下载说明" />
<meta property="og:description" content="目的
STM32G是意法半导体这两年新推出的系列芯片，相比原先的F系列的芯片有很多提升点，将来必将取代F系列芯片的地位。对于新芯片的应用来说能够正确下载与运行程序是比较重要的一点，这篇文章将对 STM32G0 系列芯片的启动配置与程序下载做个简单的说明。
启动配置
STM32G0系列芯片的启动配置相关内容在官方文档《AN5096：Getting started with STM32G0 Series hardware development》第三章中有详细的描述：
启动配置相关内容其实是不多的，下面将对这部分内容做个简单的说明。
STM32系列芯片程序启动方式分为下面三种：
Main Flash memory 从主闪存启动，想要运行我们自己的程序就要选择这种方式；
System memory 从系统存储区启动，想要通过串口下载程序就要选择这种方式；
Embbeded SRAM 从内存启动；
STM32G0系列芯片通过选项字节（option byte）中的 BOOT_LOCK、nBOOT1、nBOOT_SEL、nBOOT0这几位加上外部的 BOOT0 管脚的电平来确定启动方式。当 nBOOT_SEL 为 0 时， BOOT0 的值来源于外部的 BOOT0 管脚的电平，低电平为 0 ，高电平为 1 ；当 nBOOT_SEL 为 1 时， BOOT0 的值来源于 nBOOT0 的值。
芯片启动时会检查闪存地址0x080000000（即用户程序起始地址）处的数据，如果该数据为0xFFFFFFFF则表示用户程序为空，此时不管上面的那些设置程序会从 System memory 启动。
芯片在出厂后只要没有经过程序下载等操作启动时总是会从 System memory 启动。
程序下载
STM32系列系统程序下载通常通过串口进行，而使用串口下载程序重要的是要让芯片从 System memory 启动。
从上一章节内容可以知道芯片在初次烧写时就是从 System memory 启动的，你可以正常使用串口进行连接烧写，不需要关心外部 BOOT0 管脚的电平，如果连接不上就拉低下芯片 NRST 引脚复位下芯片试试。（如果还是连接不上就检查下芯片供电、线路连接、串口模块、串口驱动等试试。）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d9263d4803148327c8a64d4df73f2209/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-30T15:47:46+08:00" />
<meta property="article:modified_time" content="2022-05-30T15:47:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32G0系列的启动配置与程序下载说明</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>目的</strong><br> STM32G是意法半导体这两年新推出的系列芯片，相比原先的F系列的芯片有很多提升点，将来必将取代F系列芯片的地位。对于新芯片的应用来说能够正确下载与运行程序是比较重要的一点，这篇文章将对 STM32G0 系列芯片的启动配置与程序下载做个简单的说明。</p> 
<p><strong>启动配置</strong><br> <a href="https://www.infinigo.com/s?wd=STM32G0" rel="nofollow">STM32G0</a>系列芯片的启动配置相关内容在官方文档《AN5096：Getting started with STM32G0 Series hardware development》第三章中有详细的描述：</p> 
<p><img src="https://images2.imgbox.com/dd/9f/HtbfJCgS_o.png" alt="在这里插入图片描述"></p> 
<p>启动配置相关内容其实是不多的，下面将对这部分内容做个简单的说明。</p> 
<p>STM32系列芯片程序启动方式分为下面三种：</p> 
<p>Main Flash memory 从主闪存启动，想要运行我们自己的程序就要选择这种方式；<br> System memory 从系统存储区启动，想要通过串口下载程序就要选择这种方式；<br> Embbeded SRAM 从内存启动；<br> STM32G0系列芯片通过选项字节（option byte）中的 BOOT_LOCK、nBOOT1、nBOOT_SEL、nBOOT0这几位加上外部的 BOOT0 管脚的电平来确定启动方式。当 nBOOT_SEL 为 0 时， BOOT0 的值来源于外部的 BOOT0 管脚的电平，低电平为 0 ，高电平为 1 ；当 nBOOT_SEL 为 1 时， BOOT0 的值来源于 nBOOT0 的值。</p> 
<p>芯片启动时会检查闪存地址0x080000000（即用户程序起始地址）处的数据，如果该数据为0xFFFFFFFF则表示用户程序为空，此时不管上面的那些设置程序会从 System memory 启动。</p> 
<p>芯片在出厂后只要没有经过程序下载等操作启动时总是会从 System memory 启动。</p> 
<p><strong>程序下载</strong><br> STM32系列系统程序下载通常通过串口进行，而使用串口下载程序重要的是要让芯片从 System memory 启动。</p> 
<p>从上一章节内容可以知道芯片在初次烧写时就是从 System memory 启动的，你可以正常使用串口进行连接烧写，不需要关心外部 BOOT0 管脚的电平，如果连接不上就拉低下芯片 NRST 引脚复位下芯片试试。（如果还是连接不上就检查下芯片供电、线路连接、串口模块、串口驱动等试试。）</p> 
<p>在初次连接芯片烧写程序前特别需要注意的一点是配置选项字节（option byte）。默认情况下 nBOOT_SEL 和 nBOOT0 均为 1 ，也就是当你在这种情况下下载程序后下次芯片上电时将从 Main Flash memory 启动（不管外部BOOT0引脚上的电平是多少）。如果你下载的程序中没有操作对 nBOOT_SEL 和 nBOOT0 进行操作的话你再也无法通过串口重新下载程序或是修改选项字节了。</p> 
<p><img src="https://images2.imgbox.com/a5/83/CqJKeCBc_o.gif" alt="在这里插入图片描述"></p> 
<p>补救办法有，那就是通过ST-LINK连接芯片进行程序擦写或是修改选项字节。(修改完成后可能需要芯片断电然后重新上电才能通过串口连接)</p> 
<p><img src="https://images2.imgbox.com/7d/67/oSCMwDOH_o.gif" alt="在这里插入图片描述"></p> 
<p>如果更严重点，程序中把ST-LINK连接需要的 SWDIO 和 SWCLK 引脚用作它用了，ST-LINK也连接不上怎么办？解决方法也有，断开这两个引脚上别的电路连接，然后将芯片的 NRST 引脚保持下拉，这时候 STM32CubeProgrammer 上选择ST-LINK点击Connect，然后断开 NRST 的下拉，芯片会在启动的一瞬间被ST-LINK连接上。</p> 
<p><strong>通过程序修改 nBOOT_SEL</strong><br> 使用HAL库进行开发的话可以使用下面程序判断nBOOT_SEL数值并进行修改，注意修改option byte并写入后会重启芯片：<br> void Flash_OB_Handle(void) {<!-- --><br> FLASH_OBProgramInitTypeDef optionsbytesstruct;<br> bool UPDATE = false;</p> 
<pre><code>    HAL_FLASHEx_OBGetConfig(&amp;optionsbytesstruct);
    uint32_t userconfig = optionsbytesstruct.USERConfig;

    if((userconfig &amp; FLASH_OPTR_nBOOT_SEL_Msk) != OB_BOOT0_FROM_PIN) {
            userconfig &amp;= ~FLASH_OPTR_nBOOT_SEL_Msk;
            userconfig |= OB_BOOT0_FROM_PIN;
            UPDATE = true;
    }

    if(UPDATE) {
            optionsbytesstruct.USERConfig = userconfig;
            HAL_FLASH_Unlock();
            HAL_FLASH_OB_Unlock();
            HAL_FLASHEx_OBProgram(&amp;optionsbytesstruct);
            HAL_FLASH_OB_Launch();
            HAL_FLASH_OB_Lock();
            HAL_FLASH_Lock();
    }
</code></pre> 
<p>}</p> 
<p><strong>总结</strong><br> 了解上面内容后在STM32G0系列芯片上下载与运行程序应该就没什么问题了，配合STM32Cube等就可以愉快的使用新系列的芯片了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3bf81a7b24643e4002da1b0a487161b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux运行shell命令文件时，出现$‘\r‘: command not found报错的解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/504f7cb883b5b846c11249811b904643/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构笔记整理(严蔚敏版) 更新中...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>