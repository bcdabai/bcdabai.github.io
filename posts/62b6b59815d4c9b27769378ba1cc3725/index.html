<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Educational Codeforces Round 108 (Rated for Div. 2) 题解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Educational Codeforces Round 108 (Rated for Div. 2) 题解" />
<meta property="og:description" content="原题链接 A题 Red and Blue Beans 题意：给定\(r\)个红豆，\(b\)个蓝豆，将他们分到任意多个包中，要求每个包中红豆和蓝豆的差值不能超过\(d\)，可以则输出\(YES\)，否则输出\(NO\)。
贪心即可，将较小的那个放到不能放为止，然后在将另外一个顺次放进去。
代码： typedef long long LL; const int N = 200010; int main() { int T; scanf(&#34;%d&#34;, &amp;T); while (T -- ) { int a, b, c; scanf(&#34;%d%d%d&#34;, &amp;a, &amp;b, &amp;c); int res = abs(a - b); if (res == 0) puts(&#34;YES&#34;); else { int l = min(a, b); int x = res / l; int y = res % l; if (y &gt;= 1) x &#43;&#43; ; if (x &lt;= c) puts(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/62b6b59815d4c9b27769378ba1cc3725/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-30T04:05:00+08:00" />
<meta property="article:modified_time" content="2021-04-30T04:05:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Educational Codeforces Round 108 (Rated for Div. 2) 题解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown" style="font-size: 16px;"> 
 <h2 id="原题链接"><a href="https://codeforces.com/contest/1519," rel="noopener noopener noreferrer" title="戳这里" target="_blank">原题链接</a></h2> 
 <h3 id="a题-red-and-blue-beans"><a href="https://codeforces.com/contest/1519/problem/A" rel="noopener noopener noreferrer" target="_blank">A题 Red and Blue Beans</a></h3> 
 <p>题意：给定<span class="math inline">\(r\)</span>个红豆，<span class="math inline">\(b\)</span>个蓝豆，将他们分到任意多个包中，要求每个包中红豆和蓝豆的差值不能超过<span class="math inline">\(d\)</span>，可以则输出<span class="math inline">\(YES\)</span>，否则输出<span class="math inline">\(NO\)</span>。<br> 贪心即可，将较小的那个放到不能放为止，然后在将另外一个顺次放进去。</p> 
 <h4 id="代码">代码：</h4> 
 <pre class="has"><code>typedef long long LL;

const int N = 200010;

int main()
{
    int T;
    scanf("%d", &amp;T);
    while (T -- ) 
    {
        int a, b, c;
        scanf("%d%d%d", &amp;a, &amp;b, &amp;c);

        int res = abs(a - b);
        if (res == 0) puts("YES");
        else 
        {
            int l = min(a, b);
            int x = res / l;
            int y = res % l;
            if (y &gt;= 1) x ++ ;
            if (x &lt;= c) puts("YES");
            else puts("NO");
        }
    }

    return 0;
}</code></pre> 
 <hr> 
 <h3 id="b题-the-cake-is-a-lie"><a href="https://codeforces.com/contest/1519/problem/B" rel="noopener noopener noreferrer" target="_blank">B题 The Cake Is a Lie</a></h3> 
 <p>题意：给定一个棋盘，要求输出能否从<span class="math inline">\((1, 1)\)</span>走到<span class="math inline">\((n, m)\)</span>刚好花<span class="math inline">\(k\)</span>步，能则输出<span class="math inline">\(YES\)</span>，否则输出<span class="math inline">\(NO\)</span><br> sb题，找规律找了半天发现只有一种情况，直接判断就行。</p> 
 <h4 id="代码-1">代码：</h4> 
 <pre class="has"><code>typedef long long LL;
 
const int N = 110;
 
int n, m, k;
 
int main()
{
    int T;
    scanf("%d", &amp;T);
    while (T -- ) 
    {
        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
        
        int res = n - 1 + (m - 1) * n;
        if (res == k) puts("YES");
        else puts("NO");
    }
 
    return 0;
}</code></pre> 
 <hr> 
 <h3 id="c题-berland-regional"><a href="https://codeforces.com/contest/1519/problem/C" rel="noopener noopener noreferrer" target="_blank">C题 Berland Regional</a></h3> 
 <p>题意：给定编号<span class="math inline">\(1-n\)</span>的学校，每个学校有若干个人，要求对于<span class="math inline">\(1 - n\)</span>内的每个值<span class="math inline">\(k\)</span>都将这些人分成<span class="math inline">\(k\)</span>个人的小组，按从大到小排序，不足<span class="math inline">\(k\)</span>人则不分，要求将这些小组的值加起来输出。</p> 
 <p>对于朴素的做法肯定就是两层循环，但是题目给的范围太大<span class="math inline">\(2e5\)</span>，如果直接暴力会<span class="math inline">\(TLE\)</span>，所以我们就要对朴素做法进行优化。</p> 
 <p>我们经过思考后不难发现我们所要加上的值一定是，每个学校内的人的总数<span class="math inline">\(sum\)</span>所能包含的最大的k的倍数，而这个倍数就是<span class="math inline">\(sum-sum\%k\)</span>，因此我们对每一个<span class="math inline">\(k\)</span>值，就能找到能加的值得上限，这样我们只需要第一层循环<span class="math inline">\(1-n\)</span>，第二层循环<span class="math inline">\(k\)</span>值即可，这里由于我们<span class="math inline">\(k&gt;=sum\)</span>的无法组成小队，可以不用循环。同时我们可以使用前缀和进行优化。</p> 
 <h4 id="代码-2">代码：</h4> 
 <pre class="has"><code>typedef long long LL;
 
const int N = 200010;
 
int n, m, k;
int g[N], w[N];
vector&lt;LL&gt; s[N]; // 前缀和数组
LL res[N]; 
 
bool cmp(LL a, LL b) // 重载比较函数
{
    return a &gt; b;
}
 
int main()
{
    int T;
    scanf("%d", &amp;T);
    while (T -- ) 
    {
        scanf("%d", &amp;n);
        for (int i = 1; i &lt;= n; i ++ ) res[i] = 0, s[i].clear();
        for (int i = 1; i &lt;= n; i ++ ) scanf("%d", &amp;g[i]);
        for (int i = 1; i &lt;= n; i ++ ) scanf("%d", &amp;w[i]);
 
        for (int i = 1; i &lt;= n; i ++ ) s[g[i]].push_back((LL)w[i]);
        for (int i = 1; i &lt;= n; i ++ ) sort(s[i].begin(), s[i].end(), cmp);
 
        for (int i = 1; i &lt;= n; i ++ ) 
            for (int j = 1; j &lt; s[i].size(); j ++ ) 
                s[i][j] = s[i][j - 1] + s[i][j];
        
        for (int i = 1; i &lt;= n; i ++ ) 
            for (int j = 1; j &lt;= s[i].size(); j ++ ) 
            {
                int t = s[i].size();
                res[j] += s[i][t - t % j - 1]; // 下标从0开始
            }
 
        for (int i = 1; i &lt;= n; i ++ ) printf("%lld ", res[i]);
        printf("\n");
    }
 
    return 0;
}</code></pre> 
 <hr> 
 <h3 id="d题-maximum-sum-of-products"><a href="https://codeforces.com/contest/1519/problem/D" rel="noopener noopener noreferrer" target="_blank">D题 Maximum Sum of Products</a></h3> 
 <p>题意：给定两个序列<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>，要求翻转<span class="math inline">\(a\)</span>的一段子序列使得<span class="math inline">\(\sum_{i=1}^n a_i*b_i\)</span>最大。<br> 区间<span class="math inline">\(dp\)</span>(好像还可以暴力做)，<span class="math inline">\(f[l][r]\)</span>表示翻转<span class="math inline">\(l-r\)</span>区间之后<span class="math inline">\(\sum_{i=l}^r a_i*b_i\)</span>的值，之后再枚举一遍区间对<span class="math inline">\(res\)</span>取一个<span class="math inline">\(max\)</span>即可。<br> 状态转移方程为：<span class="math inline">\(f[i][j]=f[i+1][j-1]+a[i]*b[j]+a[j]*b[i]\)</span>。<br> 需要注意的是第一层循环必须是从大到小循环，因为我们会使用到<span class="math inline">\(i+1\)</span>。</p> 
 <h4 id="代码-3">代码：</h4> 
 <pre class="has"><code>const int N = 5010;
 
int n, m, k;
LL a[N], b[N];
LL f[N][N]; // f[l][r] 表示将l-r区间反转之后的值是多少
LL s[N];    
 
int main()
{
    cin &gt;&gt; n;
 
    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; b[i];
 
    for (int i = 1; i &lt;= n; i ++ ) s[i] = s[i - 1] + a[i] * b[i];
 
    for (int i = 1; i &lt;= n; i ++ ) f[i][i] = a[i] * b[i]; // 初始化，只翻转一个数
 
    for (int i = n - 1; i &gt;= 1; i -- ) 
        for (int j = i + 1; j &lt;= n; j ++ )
            f[i][j] = f[i + 1][j - 1] + a[i] * b[j] + a[j] * b[i];
 
    LL res = s[n];
    for (int i = 1; i &lt;= n; i ++ ) 
        for (int j = i + 1; j &lt;= n; j ++ ) 
            res = max(res, f[i][j] + s[i - 1] + s[n] - s[j]);
 
    cout &lt;&lt; res &lt;&lt; endl;
 
    return 0;
}</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2bdda8de65aec71100ddc9b95d2c7810/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Educational Codeforces Round 108 (Rated for Div. 2) A~D题解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90cd087acf6b2331504a7f0323c3e70f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysqldump 命令参数大全</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>