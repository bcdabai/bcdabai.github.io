<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>什么是GPIO？(详细介绍) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="什么是GPIO？(详细介绍)" />
<meta property="og:description" content="以STM32F4系列的单片机做例子
一.引入 单片机最小系统的组成： 芯片 &#43; 供电电路 &#43; 复位电路 &#43; 时钟（晶振）电路
一个完成的系统的组成 最小系统 &#43; 项目所需要的其他硬件（外设）
芯片： 整个系统的核心 相当于人类的大脑 会提供引脚与外部电路相连接 引脚（俗称 官方称呼“GPIO”）
二. GPIO GPIO是什么？ General Purpose Input Output 通用功能输出输出 GPIO就是从芯片内部引出来一根功能复用的口线（电线）
功能复用是指：GPIO的引脚可以由CPU配置成不同的功能 比如：输入功能 输出功能 模拟功能 复用功能等等
分析GPIO内部结构图如picture/STM32F4XX_GPIO内部结构.PNG 通过图我们可以得知 每个GPIO可以独立地被配置成不同的功能。 GPIO配置功能如下： (1)输入功能 CPU可以通过该GPIO的来获取外部电路输入的一个电平状态 输入功能又可以分为几种模式： a.带上拉的输入（input pull-up）
默认接一个上拉电阻 此时就算IO引脚没有外部输入信号时 CPU也能读到一个高电平 只有在外部电路输入低电平的时候 CPU读取到的才是低电平
b.带下拉的输入 默认接一个下拉电阻 此时就算IO引脚没有外部输入信号时 CPU也能读到一个低电平
只有在外部电路输入高电平的时候 CPU读取到的才是高电平 c.输入悬空
既不接上拉电阻 也不接下拉电阻 这种情况下 IO引脚的电平状态完全由外部输入所绝对 此时CPU可以通过读取数据的
操作来获取外部电路的工作状态
d.模拟输入
该引脚被设置为模拟输入的时候 能够获取到模拟信号 通过ADC转换为数字量
(2)输出功能 CPU可以通过该GPIO口往外部输出一个电平状态（相当于可以控制外部电路工作）
输出功能也可以分为以下两种模式 a.输出推挽 （PP: push-pull）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ea97d92d52fc2cc04f8eb1c8ca2f2052/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-26T15:52:19+08:00" />
<meta property="article:modified_time" content="2023-04-26T15:52:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">什么是GPIO？(详细介绍)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>以STM32F4系列的单片机做例子</p> 
<p>一.引入 </p> 
<p>    单片机最小系统的组成： <br>         <br>         芯片 + 供电电路 + 复位电路 + 时钟（晶振）电路<br>         <br>     一个完成的系统的组成 <br>     <br>         最小系统 + 项目所需要的其他硬件（外设）<br>     <br>     芯片： <br>         <br>         整个系统的核心 相当于人类的大脑  会提供引脚与外部电路相连接 <br>         引脚（俗称 官方称呼“GPIO”）</p> 
<p>二. GPIO </p> 
<p>    GPIO是什么？ <br>     General Purpose Input Output 通用功能输出输出 <br>     GPIO就是从芯片内部引出来一根功能复用的口线（电线）<br>     功能复用是指：GPIO的引脚可以由CPU配置成不同的功能 <br>     比如：输入功能 输出功能 模拟功能 复用功能等等<br>     <br>     分析GPIO内部结构图如picture/STM32F4XX_GPIO内部结构.PNG <br>     通过图我们可以得知 每个GPIO可以独立地被配置成不同的功能。 <br>     GPIO配置功能如下： <br>     (1)输入功能 <br>     <br>         CPU可以通过该GPIO的来获取外部电路输入的一个电平状态 <br>         输入功能又可以分为几种模式： <br>         a.带上拉的输入（input pull-up）<br>             默认接一个上拉电阻  <br>             此时就算IO引脚没有外部输入信号时  CPU也能读到一个高电平 <br>             只有在外部电路输入低电平的时候 CPU读取到的才是低电平</p> 
<p><img alt="" height="481" src="https://images2.imgbox.com/38/55/czZPsSox_o.png" width="775"><br>         b.带下拉的输入 <br>             默认接一个下拉电阻 <br>             此时就算IO引脚没有外部输入信号时 CPU也能读到一个低电平<br>             只有在外部电路输入高电平的时候 CPU读取到的才是高电平  </p> 
<p><img alt="" height="518" src="https://images2.imgbox.com/4f/c3/gWSLDuNX_o.png" width="742">         <br>         c.输入悬空<br>             既不接上拉电阻 也不接下拉电阻  <br>             这种情况下 IO引脚的电平状态完全由外部输入所绝对 此时CPU可以通过读取数据的<br>             操作来获取外部电路的工作状态</p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/c2/0e/vT4dHZFQ_o.png" width="754"><br>         d.模拟输入<br>             该引脚被设置为模拟输入的时候 能够获取到模拟信号 <br>             通过ADC转换为数字量</p> 
<p> </p> 
<p><img alt="" height="515" src="https://images2.imgbox.com/56/fa/rB6npisT_o.png" width="750"><br>     <br>     (2)输出功能 <br>     <br>         CPU可以通过该GPIO口往外部输出一个电平状态（相当于可以控制外部电路工作）<br>         输出功能也可以分为以下两种模式 <br>         a.输出推挽 （PP: push-pull）<br>             CPU往外写高电平（1）时，此时引脚输出一个高电平 <br>             CPU往外写低电平（0）时，此时引脚输出一个低电平  </p> 
<p><img alt="" height="442" src="https://images2.imgbox.com/2d/d9/dqF32I1Y_o.png" width="705"> <br>             <br>         b.输出开漏  (OD: open drain)<br>             不输出电压 <br>             CPU往外写低电平（0）时  此时引脚接VSS(GND)相当于接地<br>             CPU外外写高电平（1）时  此时引脚的电平状态由上下拉电阻决定</p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/a9/ab/N0Czg3BP_o.png" width="757"> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>    (3)复用功能 <br>         <br>         复用功能是指GPIO口用作其他的外设的功能口线 <br>         比如：<br>                 I2C USART SPI等等 <br>         <br>         每个GPIO口都可以被配置成多达16中复用功能 <br>         具体哪个引脚可以被复用成哪种功能 需要看原理图<br>     <br>     <br>     STM32F4xx共有144个GPIO引脚<br>     分为九组 记为GPIOA , GPIOB ... GPIOI<br>              简写PA PB ... PI <br>     <br>     每组有16根引脚 编号从0~15 <br>     也就是说： <br>             比如GPIOA这一组就有  <br>             GPIOA0                     PA0<br>             GPIOA1                     PA1 <br>             GPIOA2                     PA2<br>             ...<br>             GPIOA15                 PA15<br>     <br>     <br>     而这些GPIO的功能 都有独立的寄存器组（不同的GPIO硬件控制器）来配置他们  <br>     也就是说我们如果要使用比如GPIO口的输入功能的话 我们首先需要把对应寄存器组配置好。<br>     那么如果我们要去配置（访问）寄存器的话 就必须知道寄存器的地址  <br>     <br>     每组GPIO的地址分布如下：     参考：第 192 页的第 7.4.11 节：GPIO 寄存器映射<br>         <br>         <br>                 边界地址               外设            总线： <br>         0x4002 2000 - 0x4002 23FF     GPIOI    <br>         0x4002 1C00 - 0x4002 1FFF     GPIOH<br>         0x4002 1800 - 0x4002 1BFF     GPIOG        <br>         0x4002 1400 - 0x4002 17FF     GPIOF<br>         0x4002 1000 - 0x4002 13FF     GPIOE            AHB1<br>         0x4002 0C00 - 0x4002 0FFF     GPIOD<br>         0x4002 0800 - 0x4002 0BFF     GPIOC<br>         0x4002 0400 - 0x4002 07FF     GPIOB<br>         0x4002 0000 - 0x4002 03FF     GPIOA<br>     <br>     <br>     边界地址：指对应的寄存器组的起始地址（基址）和结束地址<br>     外设：     该寄存器组对应的硬件控制器<br>     总线：  该硬件控制器所处的系统时钟总线 <br>             请注意：任何一个硬件控制器想要去正常工作 都必须开启（使能）时钟 <br>                     而总线 就是给硬件控制器提供时钟的 <br>     </p> 
<p>那么有哪些寄存器呢？分别有什么用呢？ <br>     </p> 
<p>三.STM32F4XX GPIO寄存器 </p> 
<p>    每个通用 I/O 端口包括 <br>     4 个 32 位配置寄存器（GPIOx_MODER、GPIOx_OTYPER、GPIOx_OSPEEDR 和 GPIOx_PUPDR）<br>     2 个 32 位数据寄存器（GPIOx_IDR 和GPIOx_ODR）<br>     1 个 32 位置位/复位寄存器 (GPIOx_BSRR)<br>     1 个 32 位锁定寄存器(GPIOx_LCKR) <br>     2 个 32 位复用功能选择寄存器（GPIOx_AFRH 和 GPIOx_AFRL）。<br>         <br>     (1)GPIOx_MODER :功能模式选择寄存器<br>         <br>         偏移地址：0x00  (寄存器地址 = 基址 + 偏移地址)<br>         比如 ：GPIOA_MODER的地址 0x40020000 + 0x00 = 0x40020000<br>         <br>         该寄存器用来控制GPIOx(x=A,B,C...I)组的16个引脚的模式（4种：输入、输出，模拟，复用）<br>         一个寄存器是32bits 一组GPIOx共有16个引脚<br>         每个GPIO引脚占2bits<br>         2bits正好可以表示4种状态<br>         编号为y(y=0,1...15)的GPIO引脚在寄存器中的比特位为GPIOx_MODER[2y+1,2y]<br>         具体配置如下： <br>             GPIOx_MODER[2y,2y+1]                模式 <br>                 00                                输入模式 <br>                 01                                输出模式 <br>                 10                                复用模式 <br>                 11                                模拟模式<br>     <br>     <br>         例子： 用c代码将PF9配置称为输出模式<br>         <br>         分析： <br>             GPIOF组寄存器的起始地址（基址）：0x4002 1400  <br>             GPIOx_MODER的偏移地址是0x00 <br>             so:<br>                 GPIOF_MODER的寄存器地址：0x4002 1400 + 0x00 = 0x4002 1400<br>                 <br>             如果要将PF9设置为输出模式 就需要将 <br>                 GPIOF_MODER[2*9+1:2*9]  <br>                 GPIOF_MODER[19:18] ==&gt; 01<br>             <br>             把地址为0x40021400的寄存器中的bit19置为0 bit18置为1 怎么做到这两点呢？    <br>             通过地址我们就可以将寄存器中的bit置位 <br>             在STM32中 用unsigned long来表示地址的值<br>             <br>             unsigned long * p = (unsigned long *)0x4002 1400<br>             <br>             但是一般情况下我们会在地址的前面加上volatile 变成如下： <br>             <br>             volatile unsigned long * p = (volatile unsigned long *)0x4002 1400<br>             <br>             volatile的作用是作为指令关键字 禁止编译器优化 访问的就是实际地址<br>             而不会被编译器优化成别的地址 一般用于多线程的全局变量 中断处理函数访问<br>             的全局变量 状态寄存器。<br>             <br>             那么我们就可以通过指针p将地址0x40021400的寄存器中的bit19置为0 bit18置为1 <br>             操作如下： <br>                 <br>                     xxxxxxxxxxxx yy xxxxxxxxxxxxxxxxxx<br>                     <br>                     &lt;----12----&gt;    &lt;------  18 ------&gt;<br>                     <br>                 &amp;    111111111111 01 111111111111111111        &lt;=先把bit19置为0    <br>             <br>             ===&gt;    xxxxxxxxxxxx 0y xxxxxxxxxxxxxxxxxx<br>             <br>             <br>             1&lt;&lt;19    000000000000 10 000000000000000000<br>     <br>           ~(1&lt;&lt;19)    111111111111 01 111111111111111111<br>     <br>     <br>                     *p = *p &amp; ~(1&lt;&lt;19)<br>     <br>     <br>             再把bit18置为1 <br>                 <br>                 类似与上面操作 为： <br>                     <br>                     *p = *p | (1&lt;&lt; 18)<br>             <br>             所以我们分两步完成这个操作： <br>                 <br>                 *p = *p &amp; ~(1&lt;&lt;19)    <br>                 *p = *p | (1&lt;&lt; 18)<br>     <br>             但是实际上面的操作对寄存器进行了两次操作 效率太低 <br>             有点耗费硬件资源  我们对寄存器的修改必须一步到位 <br>             <br>             所以我们会先定义一个中间变量 用来记录寄存器的值 <br>             然后再通过中间变量 一步到位去修改寄存器的值 如下操作 <br>             <br>                 unsigned long r = 0 ;<br>                 r = *p ;  //先用r保存寄存器中的值 并按照需求修改r值 <br>                 <br>                 r &amp;= ~(1&lt;&lt;19);<br>                 r |= (1&lt;&lt;18);<br>                 <br>                 *p = r; //通过中间变量 一步到位修改寄存器的值<br>     <br>     <br>         例子： 将PA0配置为输入模式 <br>                用C语言配置一次  用汇编配置一次<br>     <br>                 C语言： <br>                 <br>                 volatile unsigned long * p = (volatile unsigned long * )0x40020000 <br>                 unsigned long r = 0 ;<br>                 r = *p;<br>                 <br>                 r &amp;= ~3 ; //把bit1和bit0都设置为0   00表示输入模式 <br>                 <br>                 *p = r;<br>                 <br>                 汇编： <br>                 <br>                 LDR R0,=0X40020000 <br>                 LDR    ,R1,[R0]         ;R1就相当于r     此指令相当于r = *p<br>                 BIC    R1,R1,#0X03        ; r &amp;= ~3  <br>                 STR R1,[R0]<br>                 <br>                 <br>     (2)GPIOx_OTYPER    :Output Type Register 输出类型选择寄存器</p> 
<p>        偏移地址：0x04<br>         该寄存器用来选择GPIOx(x=A,B...I)这组的16个GPIO引脚的输出类型 <br>         寄存器有32bits <br>         低16个bit用于保存对于编号引脚的输出类型 高16bit保留<br>         一个bit保存一个引脚 <br>         一个bit有两种状态 分别对应开漏输出和推挽输出<br>         <br>         每个GPIO引脚占1bit 编号为y(y=0,1,2...15)的引脚在该寄存器中对于的bit为GPIOx_OTYPER[y]<br>         具体配置如下： <br>             <br>             GPIOx_OTYPER[y]            输出类型 <br>                 1                    输出开漏（OD）<br>                 0                    输出推挽（PP）<br>                 <br>         <br>                 <br>     (3)GPIOx_OSPEEDR:Output Speed Register 输出速率寄存器 </p> 
<p>        偏移地址：0x08<br>         用于控制GPIOx组的16个GPIO引脚的输出速率 <br>         每个引脚占2bit <br>         编号为y的引脚在该寄存器中的bit位是GPIOx_OSPEEDR[2y+1:2y]<br>         具体配置如下： <br>         <br>             GPIOx_OSPEEDR                速率 <br>             <br>                 00                        2MHZ <br>                 01                        25MHZ <br>                 10                        50MHZ <br>                 11                        30pf则为100MHZ <br>                                         15pf则为80MHZ<br>         <br>                 <br>                 <br>     (4)GPIOx_PUPDR:Pull Up Pull Down Register 端口上拉/下拉寄存器<br>     <br>         偏移地址：0x0c <br>         该寄存器用来控制GPIOx组的16个引脚的上拉/下拉选择<br>         每个GPIO引脚占2bits <br>         编号为y的GPIO引脚在该寄存器中所在的bit为GPIOx_PUPDR[2y+1:2y]<br>         具体配置如下： <br>         <br>             GPIOx_PUPDR                上下拉选择 <br>                 00                    无上拉、无下拉 <br>                 01                    上拉 <br>                 10                    下拉 <br>                 11                    保留<br>         <br>                 <br>     (5)GPIOx_IDR: Input Data Register 输入数据寄存器 </p> 
<p>        偏移地址：0x10 <br>         该寄存器用来表示GPIOx这组的16个GPIO引脚的输入的电平状态值 <br>         每个GPIO引脚占1bits  该寄存器中高16bit保留没有使用 <br>         低16bit表示x组的16个引脚的电平状态<br>         比如：GPIOx_IDR[0] ==&gt;表示的就是该组的第0个引脚GPIOx0的输入电平状态<br>         具体配置如下： <br>         <br>             GPIOx_IDR[y]            编号为y的引脚的输入电平状态 <br>                 1                        高电平 <br>                 0                        低电平<br>         <br>         比如： <br>             CPU想要知道GPIOA0这个引脚输入的是高电平还是低电平？ <br>             思路： <br>                     if(GPIOA_IDR &amp; 0X01  == 0X01)<br>                     {<!-- --><br>                         PA0为高电平<br>                     }<br>                     else <br>                     {<!-- --><br>                         PA0为低电平<br>                     }<br>             <br>             ===&gt; <br>                     <br>                 volatile unsigned long * p =(volatile unsigned long *)(0x40020000+0x10)<br>                 if(*p &amp; 0x01)<br>                 {<!-- --><br>                     PA0为高电平<br>                 }<br>                 <br>     (6)GPIOx_ODR:Output Data Register 端口输出数据寄存器 <br>     <br>         偏移地址： 0x14<br>         该寄存器保存了该组16个GPIO引脚的输出电平状态 <br>         高16bit保留的 低16个bit就是对于编号的引脚的输出电平状态 <br>         具体配置如下： <br>         <br>             GPIOx_ODR[y]            编号为y的引脚的输出电平状态 <br>                 1                        高电平 <br>                 0                        低电平<br>     <br>             <br>                 <br>                 <br>                 <br>     (7)GPIOx_BSRR:Bit Set Reset Register 端口置位/复位寄存器 <br>             <br>         偏移地址：0x18<br>         置位：set  把bit位置为1 <br>         复位：reset 把bit位置为0<br>         该寄存器用来表示GPIOx组的16个GPIO引脚的输出状态 <br>         其中：<br>             高16bits为端口复位寄存器 <br>             低16bits为端口置位寄存器<br>         <br>         这个寄存器有点特殊  写1有效 写0无效<br>         将GPIOx_BSRR[31:16]置为1 表示将GPIOx15~GPIOx0设置为0 <br>         将GPIOx_BSRR[15:0]置为1 表示将GPIOx15~GPIOx0设置为1<br>         实现效果跟GPIOx_ODR一样 用来设置GPIO引脚的输出状态<br>         <br>         <br>     (8)GPIOx_LCKR    :锁定寄存器  </p> 
<p>    (9)GPIOx_AFRL:复用功能低位寄存器     偏移地址：0x20<br>     (10)GPIOx_AFRH:复用功能高位寄存器    偏移地址：0x24<br>         <br>         GPIOx_AFRL和GPIOx_AFRH这两个寄存器是放在一起使用的<br>         <br>         AFR:Alternate Function Register 复用功能选择寄存器 <br>         <br>         因为一个GPIO引脚最多有16个复用功能 那么1个GPIO引脚需要4个bit <br>         所以16个引脚就需要16*4 = 64bits 也就是2个寄存器的空间 <br>         <br>         GPIO引脚编号为0-7由GPIOx_AFRL进行配置 <br>                       8-15由GPIOx_AFRH进行配置<br>         <br>         <br>         具体的值表示哪个复用功能或者引脚有哪些复用功能 <br>         需要结合电路原理图和功能手册来看<br>         <br>         <img alt="" height="580" src="https://images2.imgbox.com/72/b5/BhG6Mhsi_o.png" width="1200"><br>         <br> 四. STM32F4XX GPIO时钟使能 </p> 
<p> </p> 
<p>    根据上述的寄存器 就可以去实现所有基于GPIO能够完成的功能配置了 <br>     比如： <br>         点亮led灯<br>         获取key按键的状态（按下/松开）<br>         控制蜂鸣器等等 <br>         <br>     但是我们在之前就提到过 任何一个硬件控制器想要工作 都必须去实现时钟使能<br>     （GPIO所有分组全部属于AHB1时钟总线）<br>     那么时钟的相关配置 请参考RCC部分（数据手册的第六章）    <br>     RCC: Reset Clock Control 复位时钟控制 基址：0x40023800<br>     那么现在我们的目的是使能GPIO分组时钟： <br>         RCC AHB1外设时钟使能寄存器（RCC_AHB1ENR）<br>         偏移地址：0x30 <br>         该寄存器的第0位到第8位分别控制GPIOA到GPIOI组时钟的使能： <br>             1        使能对于GPIO分组的时钟 <br>             0        禁止对应GPIO分组的时钟 <br>             <br>     比如：使能GPIOF组时钟  <br>           ==》RCC_AHB1ENR[5] -&gt; 1 <br>           <br>         C语言实现： <br>         <br>         volatile unsigned long * p = (volatile unsigned long *)(0x40023800 + 0x30);<br>         unsigned long r = 0; <br>         r = *p;<br>         r |= 1&lt;&lt;5; <br>         *p = r;<br>         <br>         <br>     GPIOF组的时钟使能后 就可以去配置GPIOF组的GPIO引脚了 <br>     配置后这些GPIO引脚可以与连接硬件电路正常工作了<br>     <br>     <br>     总结： <br>         利用寄存器来实现GPIO功能配置的步骤 <br>         <br>         1)配置GPIO分组时钟（RCC_AHB1ENR）<br>         2)配置GPIO功能模式（GPIOx_MODER）<br>         3)配置输出类型（输出功能）<br>         4)配置输出速率 <br>         5)配置上拉/下拉<br>         6)如果是输入模式 则通过GPIOx_IDR可以获取外部电路工作状态 <br>           如果是输出模式 则通过GPIOx_ODR或这GPIOx_BSRR来向外部输出一个电平信息 <br>           如果是复用模式 则后面再讲</p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/12/09/5r86KWbH_o.png" width="1154"><br>           <br>         <br>  <br>  </p> 
<p> </p> 
<p>    </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8df457acd1757daf5f5e4fce3722dd8c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java常见的100道面试题（内附答案及代码示例）持续更新</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59a22c6d5e0edc5b9aaf77d5bebbd1aa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue2下npm安装国际化i18n包报错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>