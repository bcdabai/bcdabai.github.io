<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>jmc线程转储_查找线程转储中的异常和错误 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="jmc线程转储_查找线程转储中的异常和错误" />
<meta property="og:description" content="jmc线程转储
线程转储是解决生产问题/调试生产问题的重要工件。 在像过去我们已经讨论了几种有效的线程转储故障模式： 堵车 ， 跑步机 ， RSI ， 一个 LL条条大路通罗马 .........。 在本文中，我们想介绍另一种线程转储故障排除模式。 How to capture thread dumps? There are 8 different options to capture thread dumps. You can use the option that is convenient to you. dumps. You can use the option that is convenient to you. 线程转储通常在线程堆栈跟踪中包含异常或错误。 应该检查在其堆栈跟踪中包含异常或错误的线程。 因为它们指出了问题的根源。 最近，一个应用程序引发了java.lang.OutOfMemoryError。 从此应用程序捕获了线程转储。 当我们分析线程转储时，我们会注意到一个特定的线程正在抛出java.lang.OutOfMemoryError： Thread 0x3ff781e764e0 at java.lang.OutOfMemoryError.&lt;init&gt;()V (OutOfMemoryError.java:48) at java.lang.ClassLoader.defineClass1(Ljava/lang/String;[BIILjava/security/ProtectionDomain;Ljava/lang/String;)Ljava/lang/Class; (Native Method) at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class; (ClassLoader.java:757) at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BII)Ljava/lang/Class; (ClassLoader.java:636) at sun." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6b364d8fcd6c0dc566f859295d2098ff/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-10T10:55:52+08:00" />
<meta property="article:modified_time" content="2020-07-10T10:55:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">jmc线程转储_查找线程转储中的异常和错误</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="entry" style="font-size: 16px;"> 
 <p>jmc线程转储</p> 
 <div class="e3lan-post"> 
  <div> 
   <span class="bt-uid-tg"></span> 
  </div> 
 </div> 
 <p> 线程转储是解决生产问题/调试生产问题的重要工件。 在像过去我们已经讨论了几种有效的线程转储故障模式： <a href="https://blog.fastthread.io/2016/03/07/thread-dump-analysis-pattern-ripple-effect/" rel="noreferrer noopener noopener noreferrer" target="_blank">堵车</a> ， <a href="https://blog.fastthread.io/2016/03/16/thread-dump-analysis-pattern-thread-mill/" rel="noreferrer noopener noopener noreferrer" target="_blank">跑步机</a> ， <a href="https://blog.fastthread.io/2016/02/22/thread-dump-analysis-pattern-repetitive-strain-injury-rsi/" rel="noreferrer noopener noopener noreferrer" target="_blank">RSI</a> ， <a href="https://blog.fastthread.io/2016/02/01/thread-dump-analysis-pattern-all-roads-lead-to-rome/" rel="nofollow">一个</a> <a href="https://blog.fastthread.io/2016/02/01/thread-dump-analysis-pattern-all-roads-lead-to-rome/" rel="noreferrer noopener noopener noreferrer" target="_blank">LL条条大路通罗马</a> .........。 在本文中，我们想介绍另一种线程转储故障排除模式。 </p> 
 <pre class="has"><code class="container"> How to capture thread dumps?  There are 8 different options to capture thread dumps. You can use the option that is convenient to you. dumps. You can use the option that is convenient to you. </code></pre> 
 <p> 线程转储通常在线程堆栈跟踪中包含异常或错误。 应该检查在其堆栈跟踪中包含异常或错误的线程。 因为它们指出了问题的根源。 </p> 
 <p> 最近，一个应用程序引发了java.lang.OutOfMemoryError。 从此应用程序捕获了线程转储。 当我们分析线程转储时，我们会注意到一个特定的线程正在抛出java.lang.OutOfMemoryError： </p> 
 <pre class="has"><code class="container"> Thread 0x3ff781e764e0 
   at java.lang.OutOfMemoryError.&lt;init&gt;()V (OutOfMemoryError.java:48) 
   at java.lang.ClassLoader.defineClass1(Ljava/lang/String;[BIILjava/security/ProtectionDomain;Ljava/lang/String;)Ljava/lang/Class; (Native Method) 
   at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class; (ClassLoader.java:757) 
   at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BII)Ljava/lang/Class; (ClassLoader.java:636) 
   at sun.reflect.GeneratedMethodAccessor37.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; (Unknown Source) 
   at sun.reflect.DelegatingMethodAccessorImpl.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; (DelegatingMethodAccessorImpl.java:43) 
   at java.lang.reflect.Method.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; (Method.java:498) 
   at com.sun.xml.bind.v2.runtime.reflect.opt.Injector.inject(Ljava/lang/String;[B)Ljava/lang/Class; (Injector.java:125) 
   at com.sun.xml.bind.v2.runtime.reflect.opt.Injector.inject(Ljava/lang/ClassLoader;Ljava/lang/String;[B)Ljava/lang/Class; (Injector.java:48) 
   at com.sun.xml.bind.v2.runtime.reflect.opt.AccessorInjector.prepare(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Class; (AccessorInjector.java:51) 
   at com.sun.xml.bind.v2.runtime.reflect.opt.OptimizedAccessorFactory.get(Ljava/lang/reflect/Field;)Lcom/sun/xml/bind/v2/runtime/reflect/Accessor; (OptimizedAccessorFactory.java:128) 
   at com.sun.xml.bind.v2.runtime.reflect.Accessor$FieldReflection.optimize(Lcom/sun/xml/bind/v2/runtime/JAXBContextImpl;)Lcom/sun/xml/bind/v2/runtime/reflect/Accessor; (Accessor.java:213) 
   at com.sun.xml.bind.v2.runtime.reflect.TransducedAccessor$CompositeTransducedAccessorImpl.&lt;init&gt;(Lcom/sun/xml/bind/v2/runtime/JAXBContextImpl;Lcom/sun/xml/bind/v2/runtime/Transducer;Lcom/sun/xml/bind/v2/runtime/reflect/Accessor;)V (TransducedAccessor.java:195) 
  : 
  : 
   at com.sun.xml.ws.client.WSServiceDelegate.getPort(Ljavax/xml/ namespace /QName;Ljava/lang/Class;[Ljavax/xml/ws/WebServiceFeature;)Ljava/lang/Object; (WSServiceDelegate.java:274) /QName;Ljava/lang/Class;[Ljavax/xml/ws/WebServiceFeature;)Ljava/lang/Object; (WSServiceDelegate.java:274) 
   at com.sun.xml.ws.client.WSServiceDelegate.getPort(Ljavax/xml/ namespace /QName;Ljava/lang/Class;)Ljava/lang/Object; (WSServiceDelegate.java:267) /QName;Ljava/lang/Class;)Ljava/lang/Object; (WSServiceDelegate.java:267) </code></pre> 
 <p> 从该堆栈跟踪中，我们能够确定该线程在尝试将xml转换为java对象时遇到了OutOfMemoryError。 </p> 
 <p> 显然没有为该应用程序分配足够的内存来处理大型XML有效负载。 因此，当将大型XML发送到此应用程序时，它开始抛出OutOfMemoryError。 当分配了足够的内存（即，增加-Xmx值）时，问题得到解决。 因此，在线程转储中查找“异常”或“错误”是确定问题根源的好模式。 </p> 
 <p> 但是在线程转储中查找异常或错误并不是一件容易的事。 因为线程转储往往包含数百或数千个线程。 每个线程将具有多行堆栈跟踪。 遍历堆栈跟踪的每一行以发现异常或错误是一个繁琐的过程。 线程转储分析工具在这里很方便。 您可能考虑使用免费的线程转储分析工具，例如： <a href="https://fastthread.io/" rel="noreferrer noopener noopener noreferrer" target="_blank">fastThread</a> ， <a href="https://www.ibm.com/support/pages/ibm-thread-and-monitor-dump-analyzer-java-tmda" rel="noreferrer noopener noopener noreferrer" target="_blank">IBM TDMA</a> ， <a href="https://github.com/yusuke/samurai">Samurai</a> …来分析应用程序线程转储。 </p> 
 <p> 将线程转储上载到fastThread应用程序时，它将生成根本原因分析报告。 此报告中的一节之一是“异常”。 在本节中，fastThread应用程序报告所有引发异常或错误的线程。 以下是本节的屏幕截图： </p> 
 <div class="wp-block-image"> 
  <figure class="aligncenter size-large" style="display:block;text-align:center;"> 
   <img src="https://images2.imgbox.com/6d/14/Jpz8qwpB_o.png" alt="" class="wp-image-105471" style="display:block;margin:0 auto"> 
   <figcaption> 
    <em><strong>图：fastThread报告中的“异常”部分</strong></em> 
   </figcaption> 
  </figure> 
 </div> 
 <p> 您可能会注意到，本节报告了所有在堆栈跟踪中具有“异常”或“错误”的线程。 如果本节中报告了任何线程，则应考虑调查那些线程堆栈跟踪以确定问题的根源。 </p> 
 <blockquote> 
  <p>翻译自: <a href="https://www.javacodegeeks.com/2020/06/look-for-exceptions-errors-in-thread-dumps.html" rel="nofollow">https://www.javacodegeeks.com/2020/06/look-for-exceptions-errors-in-thread-dumps.html</a></p> 
 </blockquote> 
 <p>jmc线程转储</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e5f6b15e35405418d72bfb9ad3ff181/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决adb报5037问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/921c3ac525b0720d27160ab393ba69aa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Navicat查看远程数据库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>