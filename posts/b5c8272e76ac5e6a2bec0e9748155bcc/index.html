<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>学习黑马JVM的笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="学习黑马JVM的笔记" />
<meta property="og:description" content="JVM详解 一、JVM介绍1.什么是JVM？2.有什么好处3.学习路线 二、内存结构1.程序计数器(Program Counter Registe)1.定义2.作用3.特点4.演示 2.虚拟机栈(Java Virtual Machine Stacks)1.定义2.演示3.问题解析4.栈内存溢出5.线程运行诊断（linux中） 3.本地方法栈4.堆(Heap)1.定义2.特点3.堆内存溢出4.堆内存诊断1.jps工具2.jmap工具3.jconsole工具4.演示1.jps2.jmap3.jconsole4.jvisualvm 也是一个可视化工具，功能更加强大 5.方法区1.定义2.特点3.组成4.方法区内存溢出1.8以前导致永久代内存溢出1.8以后导致元空间内存溢出 5.运行时常量池6.StringTable(串池)1.StringTable特性2.StringTable位置3.StringTable垃圾回收4.StringTable性能调优 6.直接内存1.定义2.ByteBuffer3.直接内存内存溢出4.直接内存释放原理5.分配和回收原理6.禁用显示回收对直接内存的影响 三、垃圾回收1.如何判断对象可以回收1.引用计数法1.定义2.弊端 2.可达性分析算法（java虚拟机采用的方法）1.定义2.哪些对象可以作为GC Root？3.如何查看GC Root对象 3.五种引用1.强引用：2.软引用：3.弱引用4.虚引用：5.终结器引用： 2.垃圾回收算法1.标记清除算法2.标记整理算法3.复制算法 3.分代回收3.1相关VM参数 4.垃圾回收器1.相关概念1.并行收集2.并发收集3.吞吐量 2.串行回收器1.特点2.Serial收集器3.ParNew 收集器4.Serial Old 收集器 3.吞吐量优先1.Parallel Scavenge 收集器2.**Parallel Old 收集器** 4.响应时间优先1.CMS 收集器 5.G11.定义2.使用场景3.相关JVM参数4.G1垃圾回收阶段1.Young Collection(新生代收集)2.Young Collection&#43; Concurrent Mark(新生代收集&#43;并发标记)3.Mixed Collection(混合收集) 5.Full GC6.Young Collection 跨代引用7.Remark（重新标记）8.JDK 8u20 字符串去重9.JDK 8u40 并发标记类卸载10.JDK 8u60 回收巨型对象11.JDK 9并发标记起始时间的调整 5.垃圾回收调优5.GC 调优1.调优领域2.确定目标3.最快的GC是不发生GC4.新生代调优5.幸存区调优6.老年代调优 四、类加载与字节码技术1.类文件结构1.魔数2.版本3.常量池4.访问标识与继承信息5.Field信息6.Method信息7 附加属性 2.字节码指令1.入门2 javap 工具3.图解方法执行流程1.代码2.编译后的字节码文件3.**常量池载入运行时常量池**4.**方法字节码载入方法区**5.main 线程开始运行，分配栈帧内存 4.通过字节码指令来分析问题5.构造方法1.cinit()V2.init()V 6.方法调用7.多态原理8.异常处理try-catch多个single-catchfinallyfinally中的return被吞掉的异常finally不带return 3.语法糖 编译器处理1.默认构造函数2.自动拆装箱3.泛型集合取值4.可变参数5.foreach6.switch字符串7.switch枚举8.枚举类9.匿名内部类 4.类加载阶段1.加载2.链接1.验证2.准备3.解析 3.初始化1.发生时机2.以下情况不会初始化 5.类加载器1.基本介绍2.启动类加载器3.扩展类加载器4.应用程序类加载器5.双亲委派模式概念 6.线程上下文类加载器7.自定义类加载器1.使用场景2.步骤3.案例 8.破坏双亲委派模式 6.运行期优化1.即时编译1.分层编译2.既时编译器(JIT)与解释器的区别3.逃逸分析4.方法内联1.**内联函数****2.JVM内联函数**5.字段优化 2.反射优化 五、内存模型1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b5c8272e76ac5e6a2bec0e9748155bcc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-02T22:44:42+08:00" />
<meta property="article:modified_time" content="2022-11-02T22:44:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">学习黑马JVM的笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>JVM详解</h4> 
 <ul><li><a href="#JVM_1" rel="nofollow">一、JVM介绍</a></li><li><ul><li><a href="#1JVM_3" rel="nofollow">1.什么是JVM？</a></li><li><a href="#2_7" rel="nofollow">2.有什么好处</a></li><li><a href="#3_14" rel="nofollow">3.学习路线</a></li></ul> 
  </li><li><a href="#_26" rel="nofollow">二、内存结构</a></li><li><ul><li><a href="#1Program_Counter_Registe_28" rel="nofollow">1.程序计数器(Program Counter Registe)</a></li><li><ul><li><a href="#1_30" rel="nofollow">1.定义</a></li><li><a href="#2_34" rel="nofollow">2.作用</a></li><li><a href="#3_38" rel="nofollow">3.特点</a></li><li><a href="#4_43" rel="nofollow">4.演示</a></li></ul> 
   </li><li><a href="#2Java_Virtual_Machine_Stacks_55" rel="nofollow">2.虚拟机栈(Java Virtual Machine Stacks)</a></li><li><ul><li><a href="#1_57" rel="nofollow">1.定义</a></li><li><a href="#2_65" rel="nofollow">2.演示</a></li><li><a href="#3_71" rel="nofollow">3.问题解析</a></li><li><a href="#4_83" rel="nofollow">4.栈内存溢出</a></li><li><a href="#5linux_88" rel="nofollow">5.线程运行诊断（linux中）</a></li></ul> 
   </li><li><a href="#3_97" rel="nofollow">3.本地方法栈</a></li><li><a href="#4Heap_109" rel="nofollow">4.堆(Heap)</a></li><li><ul><li><a href="#1_111" rel="nofollow">1.定义</a></li><li><a href="#2_117" rel="nofollow">2.特点</a></li><li><a href="#3_122" rel="nofollow">3.堆内存溢出</a></li><li><a href="#4_127" rel="nofollow">4.堆内存诊断</a></li><li><ul><li><a href="#1jps_131" rel="nofollow">1.jps工具</a></li><li><a href="#2jmap_136" rel="nofollow">2.jmap工具</a></li><li><a href="#3jconsole_140" rel="nofollow">3.jconsole工具</a></li><li><a href="#4_144" rel="nofollow">4.演示</a></li><li><ul><li><a href="#1jps_146" rel="nofollow">1.jps</a></li><li><a href="#2jmap_150" rel="nofollow">2.jmap</a></li><li><a href="#3jconsole_158" rel="nofollow">3.jconsole</a></li><li><a href="#4jvisualvm___162" rel="nofollow">4.jvisualvm 也是一个可视化工具，功能更加强大</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#5_166" rel="nofollow">5.方法区</a></li><li><ul><li><a href="#1_168" rel="nofollow">1.定义</a></li><li><a href="#2_172" rel="nofollow">2.特点</a></li><li><a href="#3_180" rel="nofollow">3.组成</a></li><li><a href="#4_192" rel="nofollow">4.方法区内存溢出</a></li><li><ul><li><a href="#18_212" rel="nofollow">1.8以前导致永久代内存溢出</a></li><li><a href="#18_216" rel="nofollow">1.8以后导致元空间内存溢出</a></li></ul> 
    </li><li><a href="#5_222" rel="nofollow">5.运行时常量池</a></li><li><a href="#6StringTable_235" rel="nofollow">6.StringTable(串池)</a></li><li><ul><li><a href="#1StringTable_253" rel="nofollow">1.StringTable特性</a></li><li><a href="#2StringTable_279" rel="nofollow">2.StringTable位置</a></li><li><a href="#3StringTable_293" rel="nofollow">3.StringTable垃圾回收</a></li><li><a href="#4StringTable_299" rel="nofollow">4.StringTable性能调优</a></li></ul> 
   </li></ul> 
   </li><li><a href="#6_309" rel="nofollow">6.直接内存</a></li><li><ul><li><a href="#1_311" rel="nofollow">1.定义</a></li><li><a href="#2ByteBuffer_321" rel="nofollow">2.ByteBuffer</a></li><li><a href="#3_333" rel="nofollow">3.直接内存内存溢出</a></li><li><a href="#4_337" rel="nofollow">4.直接内存释放原理</a></li><li><a href="#5_342" rel="nofollow">5.分配和回收原理</a></li><li><a href="#6_347" rel="nofollow">6.禁用显示回收对直接内存的影响</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_359" rel="nofollow">三、垃圾回收</a></li><li><ul><li><a href="#1_361" rel="nofollow">1.如何判断对象可以回收</a></li><li><ul><li><a href="#1_363" rel="nofollow">1.引用计数法</a></li><li><ul><li><a href="#1_365" rel="nofollow">1.定义</a></li><li><a href="#2_369" rel="nofollow">2.弊端</a></li></ul> 
    </li><li><a href="#2java_374" rel="nofollow">2.可达性分析算法（java虚拟机采用的方法）</a></li><li><ul><li><a href="#1_376" rel="nofollow">1.定义</a></li><li><a href="#2GC_Root_381" rel="nofollow">2.哪些对象可以作为GC Root？</a></li><li><a href="#3GC_Root_399" rel="nofollow">3.如何查看GC Root对象</a></li></ul> 
    </li><li><a href="#3_403" rel="nofollow">3.五种引用</a></li><li><ul><li><a href="#1_407" rel="nofollow">1.强引用：</a></li><li><a href="#2_411" rel="nofollow">2.软引用：</a></li><li><a href="#3_457" rel="nofollow">3.弱引用</a></li><li><a href="#4_464" rel="nofollow">4.虚引用：</a></li><li><a href="#5_471" rel="nofollow">5.终结器引用：</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2_482" rel="nofollow">2.垃圾回收算法</a></li><li><ul><li><a href="#1_484" rel="nofollow">1.标记清除算法</a></li><li><a href="#2_492" rel="nofollow">2.标记整理算法</a></li><li><a href="#3_502" rel="nofollow">3.复制算法</a></li></ul> 
   </li><li><a href="#3_514" rel="nofollow">3.分代回收</a></li><li><ul><li><a href="#31VM_525" rel="nofollow">3.1相关VM参数</a></li></ul> 
   </li><li><a href="#4_545" rel="nofollow">4.垃圾回收器</a></li><li><ul><li><a href="#1_547" rel="nofollow">1.相关概念</a></li><li><ul><li><a href="#1_551" rel="nofollow">1.并行收集</a></li><li><a href="#2_558" rel="nofollow">2.并发收集</a></li><li><a href="#3_564" rel="nofollow">3.吞吐量</a></li></ul> 
    </li><li><a href="#2_568" rel="nofollow">2.串行回收器</a></li><li><ul><li><a href="#1_576" rel="nofollow">1.特点</a></li><li><a href="#2Serial_583" rel="nofollow">2.Serial收集器</a></li><li><a href="#3ParNew__589" rel="nofollow">3.ParNew 收集器</a></li><li><a href="#4Serial_Old__595" rel="nofollow">4.Serial Old 收集器</a></li></ul> 
    </li><li><a href="#3_601" rel="nofollow">3.吞吐量优先</a></li><li><ul><li><a href="#1Parallel_Scavenge__617" rel="nofollow">1.Parallel Scavenge 收集器</a></li><li><a href="#2Parallel_Old__636" rel="nofollow">2.**Parallel Old 收集器**</a></li></ul> 
    </li><li><a href="#4_642" rel="nofollow">4.响应时间优先</a></li><li><ul><li><a href="#1CMS__657" rel="nofollow">1.CMS 收集器</a></li></ul> 
    </li><li><a href="#5G1_677" rel="nofollow">5.G1</a></li><li><ul><li><a href="#1_679" rel="nofollow">1.定义</a></li><li><a href="#2_688" rel="nofollow">2.使用场景</a></li><li><a href="#3JVM_694" rel="nofollow">3.相关JVM参数</a></li><li><a href="#4G1_706" rel="nofollow">4.G1垃圾回收阶段</a></li><li><ul><li><a href="#1Young_Collection_718" rel="nofollow">1.Young Collection(新生代收集)</a></li><li><a href="#2Young_Collection_Concurrent_Mark_732" rel="nofollow">2.Young Collection+ Concurrent Mark(新生代收集+并发标记)</a></li><li><a href="#3Mixed_Collection_748" rel="nofollow">3.Mixed Collection(混合收集)</a></li></ul> 
     </li><li><a href="#5Full_GC_765" rel="nofollow">5.Full GC</a></li><li><a href="#6Young_Collection__787" rel="nofollow">6.Young Collection 跨代引用</a></li><li><a href="#7Remark_809" rel="nofollow">7.Remark（重新标记）</a></li><li><a href="#8JDK_8u20__832" rel="nofollow">8.JDK 8u20 字符串去重</a></li><li><a href="#9JDK_8u40__849" rel="nofollow">9.JDK 8u40 并发标记类卸载</a></li><li><a href="#10JDK_8u60__853" rel="nofollow">10.JDK 8u60 回收巨型对象</a></li><li><a href="#11JDK_9_862" rel="nofollow">11.JDK 9并发标记起始时间的调整</a></li></ul> 
    </li><li><a href="#5_876" rel="nofollow">5.垃圾回收调优</a></li><li><a href="#5GC__878" rel="nofollow">5.GC 调优</a></li><li><ul><li><a href="#1_888" rel="nofollow">1.调优领域</a></li><li><a href="#2_896" rel="nofollow">2.确定目标</a></li><li><a href="#3GCGC_904" rel="nofollow">3.最快的GC是不发生GC</a></li><li><a href="#4_915" rel="nofollow">4.新生代调优</a></li><li><a href="#5_929" rel="nofollow">5.幸存区调优</a></li><li><a href="#6_934" rel="nofollow">6.老年代调优</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_936" rel="nofollow">四、类加载与字节码技术</a></li><li><ul><li><a href="#1_940" rel="nofollow">1.类文件结构</a></li><li><ul><li><a href="#1_1013" rel="nofollow">1.魔数</a></li><li><a href="#2_1020" rel="nofollow">2.版本</a></li><li><a href="#3_1030" rel="nofollow">3.常量池</a></li><li><a href="#4_1043" rel="nofollow">4.访问标识与继承信息</a></li><li><a href="#5Field_1056" rel="nofollow">5.Field信息</a></li><li><a href="#6Method_1063" rel="nofollow">6.Method信息</a></li><li><a href="#7__1069" rel="nofollow">7 附加属性</a></li></ul> 
   </li><li><a href="#2_1077" rel="nofollow">2.字节码指令</a></li><li><ul><li><a href="#1_1079" rel="nofollow">1.入门</a></li><li><a href="#2_javap__1096" rel="nofollow">2 javap 工具</a></li><li><a href="#3_1184" rel="nofollow">3.图解方法执行流程</a></li><li><ul><li><a href="#1_1186" rel="nofollow">1.代码</a></li><li><a href="#2_1203" rel="nofollow">2.编译后的字节码文件</a></li><li><a href="#3_1239" rel="nofollow">3.**常量池载入运行时常量池**</a></li><li><a href="#4_1244" rel="nofollow">4.**方法字节码载入方法区**</a></li><li><a href="#5main__1249" rel="nofollow">5.main 线程开始运行，分配栈帧内存</a></li></ul> 
    </li><li><a href="#4_1333" rel="nofollow">4.通过字节码指令来分析问题</a></li><li><a href="#5_1374" rel="nofollow">5.构造方法</a></li><li><ul><li><a href="#1cinitV_1376" rel="nofollow">1.cinit()V</a></li><li><a href="#2initV_1409" rel="nofollow">2.init()V</a></li></ul> 
    </li><li><a href="#6_1467" rel="nofollow">6.方法调用</a></li><li><a href="#7_1507" rel="nofollow">7.多态原理</a></li><li><a href="#8_1519" rel="nofollow">8.异常处理</a></li><li><ul><li><ul><li><a href="#trycatch_1521" rel="nofollow">try-catch</a></li><li><a href="#singlecatch_1559" rel="nofollow">多个single-catch</a></li><li><a href="#finally_1602" rel="nofollow">finally</a></li><li><a href="#finallyreturn_1663" rel="nofollow">finally中的return</a></li><li><a href="#_1715" rel="nofollow">被吞掉的异常</a></li><li><a href="#finallyreturn_1742" rel="nofollow">finally不带return</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#3_____1788" rel="nofollow">3.语法糖 编译器处理</a></li><li><ul><li><a href="#1_1794" rel="nofollow">1.默认构造函数</a></li><li><a href="#2_1814" rel="nofollow">2.自动拆装箱</a></li><li><a href="#3_1842" rel="nofollow">3.泛型集合取值</a></li><li><a href="#4_1894" rel="nofollow">4.可变参数</a></li><li><a href="#5foreach_1930" rel="nofollow">5.foreach</a></li><li><a href="#6switch_1991" rel="nofollow">6.switch字符串</a></li><li><a href="#7switch_2063" rel="nofollow">7.switch枚举</a></li><li><a href="#8_2129" rel="nofollow">8.枚举类</a></li><li><a href="#9_2168" rel="nofollow">9.匿名内部类</a></li></ul> 
   </li><li><a href="#4_2253" rel="nofollow">4.类加载阶段</a></li><li><ul><li><a href="#1_2255" rel="nofollow">1.加载</a></li><li><a href="#2_2272" rel="nofollow">2.链接</a></li><li><ul><li><a href="#1_2274" rel="nofollow">1.验证</a></li><li><a href="#2_2300" rel="nofollow">2.准备</a></li><li><a href="#3_2308" rel="nofollow">3.解析</a></li></ul> 
    </li><li><a href="#3_2312" rel="nofollow">3.初始化</a></li><li><ul><li><a href="#1_2317" rel="nofollow">1.发生时机</a></li><li><a href="#2_2326" rel="nofollow">2.以下情况不会初始化</a></li></ul> 
   </li></ul> 
   </li><li><a href="#5_2336" rel="nofollow">5.类加载器</a></li><li><ul><li><a href="#1_2338" rel="nofollow">1.基本介绍</a></li><li><a href="#2_2355" rel="nofollow">2.启动类加载器</a></li><li><a href="#3_2399" rel="nofollow">3.扩展类加载器</a></li><li><a href="#4_2445" rel="nofollow">4.应用程序类加载器</a></li><li><a href="#5_2456" rel="nofollow">5.双亲委派模式</a></li><li><ul><li><a href="#_2458" rel="nofollow">概念</a></li></ul> 
    </li><li><a href="#6_2510" rel="nofollow">6.线程上下文类加载器</a></li><li><a href="#7_2514" rel="nofollow">7.自定义类加载器</a></li><li><ul><li><a href="#1_2516" rel="nofollow">1.使用场景</a></li><li><a href="#2_2522" rel="nofollow">2.步骤</a></li><li><a href="#3_2531" rel="nofollow">3.案例</a></li></ul> 
    </li><li><a href="#8_2562" rel="nofollow">8.破坏双亲委派模式</a></li></ul> 
   </li><li><a href="#6_2571" rel="nofollow">6.运行期优化</a></li><li><ul><li><a href="#1_2573" rel="nofollow">1.即时编译</a></li><li><ul><li><a href="#1_2575" rel="nofollow">1.分层编译</a></li><li><a href="#2JIT_2587" rel="nofollow">2.既时编译器(JIT)与解释器的区别</a></li><li><a href="#3_2602" rel="nofollow">3.逃逸分析</a></li><li><a href="#4_2614" rel="nofollow">4.方法内联</a></li><li><ul><li><a href="#1_2616" rel="nofollow">1.**内联函数**</a></li><li><a href="#2JVM_2620" rel="nofollow">**2.JVM内联函数**</a></li><li><a href="#5_2626" rel="nofollow">5.字段优化</a></li></ul> 
     </li><li><a href="#2_2630" rel="nofollow">2.反射优化</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_2632" rel="nofollow">五、内存模型</a></li><li><ul><li><a href="#1JAVAJMM_2638" rel="nofollow">1.JAVA内存模型（JMM）</a></li><li><a href="#2_2650" rel="nofollow">2.原子性</a></li><li><ul><li><a href="#10_2654" rel="nofollow">1.问题提出：结果不一定为0</a></li><li><a href="#2_2680" rel="nofollow">2.问题分析</a></li><li><a href="#3_2749" rel="nofollow">3.解决方法</a></li></ul> 
   </li><li><a href="#3_2789" rel="nofollow">3.可见性</a></li><li><ul><li><a href="#1_2791" rel="nofollow">1.问题提出：退不出的循环</a></li><li><a href="#2_2809" rel="nofollow">2.问题分析</a></li><li><a href="#3_2820" rel="nofollow">3.解决方法</a></li></ul> 
   </li><li><a href="#4_2844" rel="nofollow">4.有序性</a></li><li><ul><li><a href="#1_2846" rel="nofollow">1.问题提出：诡异的结果？</a></li><li><a href="#2_2866" rel="nofollow">2.问题分析</a></li><li><a href="#3_2874" rel="nofollow">3.解决方法</a></li><li><a href="#4_2896" rel="nofollow">4.有序性理解</a></li><li><ul><li><a href="#_2898" rel="nofollow">指令重排</a></li></ul> 
    </li><li><a href="#5doublechecked_locking__2926" rel="nofollow">5.double-checked locking 模式实现单例</a></li></ul> 
   </li><li><a href="#5happensbefore_2999" rel="nofollow">5.happens-before</a></li><li><a href="#6CAS_3060" rel="nofollow">6.CAS与原子类</a></li><li><ul><li><a href="#1CAS_3062" rel="nofollow">1.CAS</a></li><li><a href="#2_3150" rel="nofollow">2.乐观锁与悲观锁</a></li><li><a href="#3_3155" rel="nofollow">3.原子操作类</a></li></ul> 
   </li><li><a href="#7synchronized_3182" rel="nofollow">7.synchronized优化</a></li><li><ul><li><a href="#1_3186" rel="nofollow">1.轻量级锁</a></li><li><a href="#2_3226" rel="nofollow">2.膨胀锁</a></li><li><a href="#3_3257" rel="nofollow">3.重量锁</a></li><li><a href="#4_3300" rel="nofollow">4.偏向锁</a></li><li><a href="#5_3354" rel="nofollow">5.其他优化</a></li><li><ul><li><a href="#1_3356" rel="nofollow">1.减少上锁的时间</a></li><li><a href="#2_3360" rel="nofollow">2.减少锁的粒度</a></li><li><a href="#3_3368" rel="nofollow">3.锁粗化</a></li><li><a href="#4_3378" rel="nofollow">4.锁消除</a></li><li><a href="#5_3382" rel="nofollow">5.读写分离</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="JVM_1"></a>一、JVM介绍</h2> 
<h3><a id="1JVM_3"></a>1.什么是JVM？</h3> 
<p>JVM（Java Virtual Machine) ：java程序的运行环境（Java 二进制字节码的运行环境）</p> 
<h3><a id="2_7"></a>2.有什么好处</h3> 
<p>1.一次编写，到处运行<br> 2.自动内存管理，垃圾回收功能</p> 
<p>JVM是一套规范</p> 
<h3><a id="3_14"></a>3.学习路线</h3> 
<p><strong>JVM内存结构</strong></p> 
<p><strong>垃圾回收</strong></p> 
<p><strong>类加载与字节码技术</strong></p> 
<p><strong>内存模型</strong></p> 
<p><img src="https://images2.imgbox.com/0a/3e/8vePtIKv_o.png" alt="image-20210728145955035"></p> 
<h2><a id="_26"></a>二、内存结构</h2> 
<h3><a id="1Program_Counter_Registe_28"></a>1.程序计数器(Program Counter Registe)</h3> 
<h4><a id="1_30"></a>1.定义</h4> 
<p>Program Counter Register 程序计数器(寄存器)</p> 
<h4><a id="2_34"></a>2.作用</h4> 
<ul><li><strong>记住下一条jvm指令的执行地址</strong></li></ul> 
<h4><a id="3_38"></a>3.特点</h4> 
<ul><li>线程是私有的</li><li>不会存在内存溢出（唯一不会出现溢出的区）</li></ul> 
<h4><a id="4_43"></a>4.演示</h4> 
<p>1.<strong>记住下一条jvm指令的执行地址</strong></p> 
<p>Java源代码经过编译成为二进制字节码(JVM指令)，二进制字节码经过解释器翻译为机器码，机器码交给CPU执行；<br> 程序计数器 (通过寄存器来实现) 在解释器执行时将下一条指令地址记住，解释器下次就会根据程序计数器中指令地址区执行下一条指令。<br> <img src="https://images2.imgbox.com/6e/55/bX4KAnb7_o.png" alt="image-20210728151436986"></p> 
<p>2.线程是私有的</p> 
<p>有多个线程，每个线程会有一个时间片，在线程1执行的时候会执行线程1的字节码，时间片用完会停止执行给其他线程使用。每个线程都有自己的程序寄存器。<img src="https://images2.imgbox.com/ca/da/rVs2Nwjr_o.png" alt="image-20210728151732130"></p> 
<h3><a id="2Java_Virtual_Machine_Stacks_55"></a>2.虚拟机栈(Java Virtual Machine Stacks)</h3> 
<h4><a id="1_57"></a>1.定义</h4> 
<p>Java Virtual Machine Stacks (Java 虚拟机栈 )</p> 
<ul><li>每个线程运行时需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧(正在运行的方法)，对应着当前正在执行的那个方法</li></ul> 
<h4><a id="2_65"></a>2.演示</h4> 
<p>每个方法运行时需要的内存就是一个栈帧</p> 
<p><img src="https://images2.imgbox.com/77/2b/zwmHMqCB_o.png" alt="image-20210728161204602"></p> 
<h4><a id="3_71"></a>3.问题解析</h4> 
<p>1，垃圾回收是否涉及栈内存？<br> 答：没有涉及，栈帧在运行完方法是将方法弹出栈，被自动回收掉，根本不需要垃圾回收。</p> 
<p>2，栈内存是越大越好吗？<br> 答：不是，栈内存越大，会让线程数变小，因为物理内存是一定的。</p> 
<p>3.方法内的局部变量是否线程安全？<br> 答：如果方法内局部变量没有逃离方法的作用范围，它是线程安全的。<br> 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全。(传入对象且返回对象需要考虑线程安全)</p> 
<h4><a id="4_83"></a>4.栈内存溢出</h4> 
<ul><li>栈帧过多导致栈内存溢出</li><li>栈帧过大导致栈内存溢出</li></ul> 
<h4><a id="5linux_88"></a>5.线程运行诊断（linux中）</h4> 
<p>定位</p> 
<ul><li>用 top 定位那个<strong>进程</strong>对CPU的占用过高</li><li>ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）</li><li>jstack 进程id 
  <ul><li>可以根据<strong>线程</strong>id找到有问题的线程，进一步定位到问题代码的行号</li></ul> </li></ul> 
<h3><a id="3_97"></a>3.本地方法栈</h3> 
<p><strong>本地方法接口</strong>：不是由Java编写的方法</p> 
<p>调用本地方法时就是使用的本地方法栈。</p> 
<p>native method</p> 
<p><img src="https://images2.imgbox.com/d0/14/v5kawLil_o.png" alt="image-20210728163427391"></p> 
<p>程序计数器和栈都是线程私有的</p> 
<h3><a id="4Heap_109"></a>4.堆(Heap)</h3> 
<h4><a id="1_111"></a>1.定义</h4> 
<p>Heap 堆</p> 
<ul><li>通过new 关键字，创建对象都会使用堆内存</li></ul> 
<h4><a id="2_117"></a>2.特点</h4> 
<ul><li>他是线程共享的，堆中对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul> 
<h4><a id="3_122"></a>3.堆内存溢出</h4> 
<p>对象内的内存满了，就会溢出。就像一直在一个ArrayList中一致添加数据就会导致堆内存溢出，下列代码就会导致堆内存溢出<br> <img src="https://images2.imgbox.com/23/6a/Rl790vCE_o.png" alt="image-20210731151223418"></p> 
<h4><a id="4_127"></a>4.堆内存诊断</h4> 
<p>windos中</p> 
<h5><a id="1jps_131"></a>1.jps工具</h5> 
<ul><li>查看当前系统中有哪些Java进程</li><li>列出所有正在运行的java进程，其中jps命令也是一个java程序，前面的数字就是对应的进程id。</li></ul> 
<h5><a id="2jmap_136"></a>2.jmap工具</h5> 
<ul><li>查看堆内存占用情况 jmap -heap 进程号</li></ul> 
<h5><a id="3jconsole_140"></a>3.jconsole工具</h5> 
<ul><li><strong>图形界面</strong>的，多功能的监测工具，可以连续监测</li></ul> 
<h5><a id="4_144"></a>4.演示</h5> 
<h6><a id="1jps_146"></a>1.jps</h6> 
<p><img src="https://images2.imgbox.com/3d/61/88vNVFHE_o.png" alt="image-20210731152405390"></p> 
<h6><a id="2jmap_150"></a>2.jmap</h6> 
<p>jmap -heap 进程号</p> 
<img src="https://images2.imgbox.com/c3/37/WcfzT57e_o.png" alt="image-20210731152455648"> 
<img src="https://images2.imgbox.com/4e/33/txuypWK6_o.png" alt="image-20210731152509338"> 
<h6><a id="3jconsole_158"></a>3.jconsole</h6> 
<p><img src="https://images2.imgbox.com/b2/b8/zp4rKFxB_o.png" alt="image-20210731152745758"></p> 
<h6><a id="4jvisualvm___162"></a>4.jvisualvm 也是一个可视化工具，功能更加强大</h6> 
<p><img src="https://images2.imgbox.com/b1/50/OMYVkLKs_o.png" alt="image-20210731153035852"></p> 
<h3><a id="5_166"></a>5.方法区</h3> 
<h4><a id="1_168"></a>1.定义</h4> 
<p>Method Area 方法区</p> 
<h4><a id="2_172"></a>2.特点</h4> 
<ul><li> <p>线程共享的区域</p> </li><li> <p>启动时创建</p> </li><li> <p>存储跟类结构相关的信息，属性、方法、构造方法</p> </li></ul> 
<h4><a id="3_180"></a>3.组成</h4> 
<p>1.6版本：PermGen 永久代(实现)<br> 1.7版本及以后：Metaspace 元空间(实现)</p> 
<p>永久代：字符串常量池在方法区中<br> 方法区在jvm内存中<br> 元空间：字符串常量池在堆中<br> 方法区在本地内存</p> 
<p><img src="https://images2.imgbox.com/eb/2d/Pexp08EX_o.png" alt="image-20210731161131722"></p> 
<h4><a id="4_192"></a>4.方法区内存溢出</h4> 
<ul><li>1.8以前会导致永久代内存溢出<br> 演示永久代内存溢出java. lang. OutOfMemoryError: PermGen space</li></ul> 
<pre><code>-XX:MaxPermSize=8m
</code></pre> 
<ul><li>1.8之后会导致元空间内存溢出<br> 演示元空间内存溢出java. lang . OutOfMemoryError: Metaspace</li></ul> 
<pre><code>-XX:MaxMetaspaceSize=8m
</code></pre> 
<h5><a id="18_212"></a>1.8以前导致永久代内存溢出</h5> 
<p><img src="https://images2.imgbox.com/de/07/DWrW0kLK_o.png" alt="image-20210731161542902"></p> 
<h5><a id="18_216"></a>1.8以后导致元空间内存溢出</h5> 
<p><img src="https://images2.imgbox.com/d2/56/eQ8QBSHI_o.png" alt="image-20210731161508854"></p> 
<p>可能溢出场景：spring、mybatis</p> 
<h4><a id="5_222"></a>5.运行时常量池</h4> 
<ul><li>常量池：就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li><li>运行时常量池：常量池是*.class文件中的，当该类被加载，他的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li></ul> 
<p><img src="https://images2.imgbox.com/7a/d8/KxvMq8mP_o.png" alt="image-20210731162622328"></p> 
<p>二进制字节码(类基本信息,常量池，类方法定，包含了虚拟机指令)</p> 
<p><img src="https://images2.imgbox.com/ca/40/kr6Zvn14_o.png" alt="image-20210731163130440"></p> 
<p><img src="https://images2.imgbox.com/49/c6/1KjGPZEE_o.png" alt="image-20210731163239085"></p> 
<h4><a id="6StringTable_235"></a>6.StringTable(串池)</h4> 
<p>程序运行时会将常量池中的字符串放入StringTable(串池)</p> 
<p>字符串在java程序中被大量使用，<strong>为了避免每次都创建相同的字符串对象</strong>及内存分配，JVM内部对字符串对象的创建做了一定的优化（一组指针指向Heap中的String对象的内存地址）。</p> 
<p>1.7版本之前StringTable放在方法区中，1.7之后放在堆中。原因：方法区的内存空间太小。</p> 
<p><strong>重点</strong>：下面判断</p> 
<p><img src="https://images2.imgbox.com/3a/86/WHuSXB7R_o.png" alt="image-20210802200831188"></p> 
<p>结果输出为false。s4是一个String对象，底层会用到StringBuilder的tostring方法创建对象。</p> 
<img src="https://images2.imgbox.com/c2/4e/4fNKxvDa_o.png" alt="image-20210802201108891"> 
<p>结果为true</p> 
<h5><a id="1StringTable_253"></a>1.StringTable特性</h5> 
<ul><li>常量池中的字符串仅是符号， <strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，避免创建重复的字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder(1.8)</strong></li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译期优化</strong>（编译时会先去串池中查看是否有这个这个字符串对象，有的话就不用创建）</li><li>使用intern方法，主动将串池中还没有的字符串对象放入串池 
  <ul><li>1.8 将字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，会把串池的对象返回。 
    <ul><li><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</li></ul> </li><li>1.6 将字符串对象尝试放入串池，如果有则不会放入，如果没有则会把此对象复制一份，放入串池，会把串池中的对象返回。 
    <ul><li><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></li></ul> </li></ul> </li></ul> 
<p>1.8</p> 
<p><img src="https://images2.imgbox.com/c6/cc/daLImbw9_o.png" alt="image-20210802203042630"></p> 
<p><img src="https://images2.imgbox.com/85/9b/L0UQjKxY_o.png" alt="image-20210802203211780"></p> 
<p>因为ab在最开始就创建，串池中已经有ab这个字符串，new String(“ab”) 在堆里是一个对象，用intern方法，发现字符串常量池中有ab，所以s与ab不相等。</p> 
<p>1.6.例题：</p> 
<p><img src="https://images2.imgbox.com/eb/35/KAg1zakn_o.png" alt="image-20210802203807522"></p> 
<p>最后false,x2是堆中的对象，x1是常量中cd，所以false.</p> 
<h5><a id="2StringTable_279"></a>2.StringTable位置</h5> 
<p>1.7版本之前StringTable放在方法区中，1.7之后放在堆中。原因：方法区的内存空间太小。</p> 
<p><img src="https://images2.imgbox.com/b0/2d/TzTQ7sxB_o.png" alt="image-20210802204048335"></p> 
<p><img src="https://images2.imgbox.com/19/7c/SHMl1UlQ_o.png" alt="image-20210802204208657"></p> 
<p>-Xmx10m</p> 
<p>打印并查看串池信息：-XX:+PrintStringTableStatistics</p> 
<h5><a id="3StringTable_293"></a>3.StringTable垃圾回收</h5> 
<p>StringTable在内存紧张时，会发生垃圾回收</p> 
<p><img src="https://images2.imgbox.com/03/8e/ubUxI1J8_o.png" alt="image-20210802204251999"></p> 
<h5><a id="4StringTable_299"></a>4.StringTable性能调优</h5> 
<ul><li> <p>调整</p> <pre><code>-XX:StringTableSize=桶个数
</code></pre> </li></ul> 
<h3><a id="6_309"></a>6.直接内存</h3> 
<h4><a id="1_311"></a>1.定义</h4> 
<p>direct memory</p> 
<p>不属于jvm管理</p> 
<ul><li>常见于nio操作时，用于数据缓冲区</li><li>分配回收成本高，但读写性能高</li><li><strong>不受JVM内存回收管理</strong></li></ul> 
<h4><a id="2ByteBuffer_321"></a>2.ByteBuffer</h4> 
<p>使用ByteBuffer比使用io的性能更高。</p> 
<p><img src="https://images2.imgbox.com/c4/92/qR0rwa9x_o.png" alt="image-20210804203422064"></p> 
<p>在没有用ByteBuffer时，系统的内部操作时下面这样的<br> <img src="https://images2.imgbox.com/43/86/8R3r1f9Q_o.png" alt="image-20210804203638059"></p> 
<p>使用了直接内存后，系统内部操作如下图。不再需要经过系统缓存区传给java缓冲区，他们<strong>共同划出一块缓冲区</strong>，java代码和系统都可以直接访问，大大的提升了效率。少了缓冲区的复制操作。<br> <img src="https://images2.imgbox.com/51/f4/ye6BXeMr_o.png" alt="image-20210804203746078"></p> 
<h4><a id="3_333"></a>3.直接内存内存溢出</h4> 
<p><img src="https://images2.imgbox.com/39/1a/5GGylfGK_o.png" alt="image-20210804204059257"></p> 
<h4><a id="4_337"></a>4.直接内存释放原理</h4> 
<p>直接内存的回收不是通过JVM的垃圾回收来释放的，拿到<strong>Unsafe</strong>对象，然后调用去分配和调用内存<br> <img src="https://images2.imgbox.com/da/dc/ooetapCg_o.png" alt="image-20210804204456040"></p> 
<h4><a id="5_342"></a>5.分配和回收原理</h4> 
<ul><li>使用了Unsafe 对象完成直接内存的分配回收，并主动回收需要<strong>主动调用freeMemory方法</strong></li><li>ByteBuffer的实现类内部，使用了<strong>Cleaner</strong> (虚引用) 来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存</li></ul> 
<h4><a id="6_347"></a>6.禁用显示回收对直接内存的影响</h4> 
<pre><code>-XX:+DisableExpIicitGC  显式的
</code></pre> 
<p>使用上面命令后，代码中调用显式回收将没有作用</p> 
<pre><code>System.gc();
</code></pre> 
<h2><a id="_359"></a>三、垃圾回收</h2> 
<h3><a id="1_361"></a>1.如何判断对象可以回收</h3> 
<h4><a id="1_363"></a>1.引用计数法</h4> 
<h5><a id="1_365"></a>1.定义</h5> 
<p>只要对象被引用就+1，引用两次就+2，如果某个变量不在引用就-1，当对象引用计数为0的时候就会被垃圾回收</p> 
<h5><a id="2_369"></a>2.弊端</h5> 
<img src="https://images2.imgbox.com/6e/63/0HxEFBRD_o.png" alt="image-20210807153700813"> 循环引用，A对象引用B对象，B对象引用计数+1，B对象引用A，A对象引用计数+1。当没有谁再引用他们，他们不能被垃圾回收，因为引用计数没有归零。python在早期垃圾回收用的引用计数法。 
<h4><a id="2java_374"></a>2.可达性分析算法（java虚拟机采用的方法）</h4> 
<h5><a id="1_376"></a>1.定义</h5> 
<ul><li>java虚拟机中的垃圾回收器采用的是可达性分析算法</li><li><strong>扫描堆中的对象，看是否能够沿着GC Root(根对象) 为起点的引用链找到该对象，找不到就可以进行垃圾回收</strong></li></ul> 
<h5><a id="2GC_Root_381"></a>2.哪些对象可以作为GC Root？</h5> 
<ul><li> <p>//System Class</p> </li><li> <p>//Natice Stack（本地栈）</p> </li><li> <p>//锁（同步锁机制）</p> </li><li> <p>//Thread(活动线程)</p> </li><li> <p><strong>a.</strong> java虚拟机栈中的引用的对象。</p> <p><strong>b</strong>.本地方法栈中的JNI（native方法）引用的对象</p> <p><strong>c</strong>.方法区中的类静态属性引用的对象。（一般指被static修饰的对象，加载类的时候就加载到内存中。）（static object)</p> <p><strong>d</strong>.方法区中的常量引用的对象。 (object)</p> </li></ul> 
<h5><a id="3GC_Root_399"></a>3.如何查看GC Root对象</h5> 
<p>通过MAT工具(Eclipse的Memory Analyzer)</p> 
<h4><a id="3_403"></a>3.五种引用</h4> 
<p><img src="https://images2.imgbox.com/7f/db/lxuAhBAu_o.png" alt="image-20210808211140283"></p> 
<h5><a id="1_407"></a>1.强引用：</h5> 
<p>只有GC Root 都不引用该对象时，才会回收强引用对象。</p> 
<h5><a id="2_411"></a>2.软引用：</h5> 
<p>有用但非必须的引用</p> 
<p>1.当GC Root 不在指向软引用对象时，且内存不足时，会回收软引用所引用的对象。<br> 2.可以配合引用队列来释放软引用自身。</p> 
<p>如上图 B对象不在引用A2对象且内存不足时，软引用所引用的A2对象会被回收。</p> 
<p>使用：</p> 
<pre><code>public class Demo1 {
	public static void main(String[] args) {
		final int _4M = 4*1024*1024;
		//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用
		List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
		SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M]);
	}
}
</code></pre> 
<p>软引用本身不会被清理，需要使用<strong>引用队列</strong></p> 
<pre><code>public class Demo1 {
	public static void main(String[] args) {
		final int _4M = 4*1024*1024;
		//使用引用队列，用于移除引用为空的软引用对象
		ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();
		//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用
		List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
		SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M],queue);

		//遍历引用队列，如果有元素，则移除
		Reference&lt;? extends byte[]&gt; poll = queue.poll();
		while(poll != null) {
			//引用队列不为空，则从集合中移除该元素
			list.remove(poll);
			//移动到引用队列中的下一个元素
			poll = queue.poll();
		}
	}
}
</code></pre> 
<h5><a id="3_457"></a>3.弱引用</h5> 
<p>1.当GC Root 不再指向弱引用对象时，不管内存是否不足，会回收弱引用所引用的对象。<br> 2.可以配合引用队列来释放弱引用自身。</p> 
<p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p> 
<h5><a id="4_464"></a>4.虚引用：</h5> 
<p>必须配合引用队列使用，主要配合 ByteBuffer 使用，当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，由 Reference Handler 线程调用虚引用相关方法释放直接内存。</p> 
<ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当被引用对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul> 
<h5><a id="5_471"></a>5.终结器引用：</h5> 
<p>无需手动编码，在其内部配合引用队列使用，</p> 
<p>在垃圾回收时，终结器引用入队（被引用对象 暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</p> 
<ul><li>当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到被引用的对象，然后调用被引用对象的finalize方法。调用以后，该对象再第二次GC就可以被垃圾回收了</li><li>如上图，B对象不再引用A4对象。这是终结器引用对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul> 
<p>引用队列：软引用和弱引用可以配合引用队列</p> 
<h3><a id="2_482"></a>2.垃圾回收算法</h3> 
<h4><a id="1_484"></a>1.标记清除算法</h4> 
<p><img src="https://images2.imgbox.com/b4/29/zSkqUeLb_o.png" alt="image-20210809151930958"><br> <strong>定义：<strong>在执行垃圾回收时，先标记完</strong>引用对象</strong>，然后垃圾收集器根据标识清除没有被标记的对象</p> 
<p><strong>优点</strong>：速度快<br> <strong>缺点：容易产生大量的内存碎片</strong>，如上图，清理没有引用的对象后，会存在内存的空间浪费。</p> 
<h4><a id="2_492"></a>2.标记整理算法</h4> 
<p><img src="https://images2.imgbox.com/a6/a2/AGwIUUbr_o.png" alt="image-20210809152342890"><br> <strong>定义</strong>：在执行垃圾回收时，先标记完引用的对象，然后清除没有被引用的对象，最后整理剩余的空间，避免因内存碎片导致的问题。</p> 
<p><strong>优点</strong>：不会存在内存碎片<br> <strong>缺点</strong>：速度慢，因为整理内存是为了避免内存浪费，所以整理需要消耗一定的时间，导致效率较低。</p> 
<p>时间换取空间</p> 
<h4><a id="3_502"></a>3.复制算法</h4> 
<p><img src="https://images2.imgbox.com/9f/02/kbM9DI4l_o.png" alt="image-20210809152736376"><br> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BwuRDFiy-1666189640764)(C:\Users\刘星\AppData\Roaming\Typora\typora-user-images\image-20210809153023339.png)]</p> 
<p><strong>定义</strong>：将内存分为两个等大小的区域，FROM和TO。先将FROM中被GC Root引用的对象进行标记，将存活的对象从FROM放入TO中，再回收FROM区域中没有被引用的对象。然后交换FROM和TO。</p> 
<p><strong>优点</strong>：这样避免的内存碎片的问题。<br> <strong>缺点</strong>：但需要双倍的内存空间。</p> 
<p>空间换取时间</p> 
<h3><a id="3_514"></a>3.分代回收</h3> 
<p><img src="https://images2.imgbox.com/01/e3/kx1TGNs0_o.png" alt="image-20210809160956701"><br> <img src="https://images2.imgbox.com/64/34/9IG1yIw8_o.png" alt="image-20210809161029646"><strong>回收流程</strong></p> 
<ul><li>对象首先分配在伊甸园区域</li><li>新生代伊甸园空间不足时，就会触发minor gc，伊甸园和幸存区From中存活的的对象复制到幸存区To中，存活的对象年龄加1并交换幸存区from和幸存区to。</li><li>minor gc会引发stop the world ，暂停其他用户的线程，等垃圾回收结束后，用户线程才恢复。</li><li>当对象寿命超过阈值时，会从新生代注入到老年代，最大寿命是15（4bit）。</li><li>当老年代空间不足，会先尝试触发minor gc， 如果空间仍不足，那么就触发full gc，stop the world 的时间更长。</li></ul> 
<h4><a id="31VM_525"></a>3.1相关VM参数</h4> 
<p>堆初始大小 ：-Xms</p> 
<p>堆最大大小 -Xmx 或 -XX:MaxHeapSize=size</p> 
<p>新生代大小： -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</p> 
<p>幸存区比例（动态）: -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</p> 
<p>幸存区比例 ：-XX:SurvivorRatio=ratio</p> 
<p>晋升阈值： -XX:MaxTenuringThreshold=threshold</p> 
<p>晋升详情： -XX:+PrintTenuringDistribution</p> 
<p>GC详情： -XX:+PrintGCDetails -verbose:gc</p> 
<p>FullGC 前 MinorGC： -XX:+ScavengeBeforeFullGC</p> 
<h3><a id="4_545"></a>4.垃圾回收器</h3> 
<h4><a id="1_547"></a>1.相关概念</h4> 
<p><strong>并行</strong>执行的线程之间不存在切换；<strong>并发</strong>操作系统会根据任务调度系统给线程分配线程的 CPU 执行时间，线程的执行会进行切换。</p> 
<h5><a id="1_551"></a>1.并行收集</h5> 
<p>并行：多个事情同一时刻进行<br> 在同一时刻，有多个程序在多个处理器上运行（每个处理器运行一个程序）。</p> 
<p>并行收集：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p> 
<h5><a id="2_558"></a>2.并发收集</h5> 
<p>并发： 指在某时刻只有一个事件在发生，某个时间段内由于 CPU <strong>交替</strong>执行，可以发生多个事件。 在同一cpu上同时运行多个程序。</p> 
<p>指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。<strong>用户程序在继续执行</strong>，而垃圾收集程序在另一个CPU上。</p> 
<h5><a id="3_564"></a>3.吞吐量</h5> 
<p>即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间））。例如：虚拟机共运行100分组，垃圾收集器花掉1分钟，那么吞吐量就是99%。</p> 
<h4><a id="2_568"></a>2.串行回收器</h4> 
<pre><code>-XX:+UseSerialGC = Serial + SerialOld
</code></pre> 
<p><img src="https://images2.imgbox.com/b1/6b/cDeJ5fWg_o.png" alt="image-20210812111420497"></p> 
<h5><a id="1_576"></a>1.特点</h5> 
<ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li><li>安全点：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</li><li>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态。</li></ul> 
<h5><a id="2Serial_583"></a>2.Serial收集器</h5> 
<p>Serial收集器是最基本的、发展历史最悠久的收集器。</p> 
<p><strong>特点</strong>：单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p> 
<h5><a id="3ParNew__589"></a>3.ParNew 收集器</h5> 
<p>ParNew收集器其实就是Serial收集器的多线程版本。</p> 
<p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，采用<strong>复制算法</strong>，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p> 
<h5><a id="4Serial_Old__595"></a>4.Serial Old 收集器</h5> 
<p>Serial Old是Serial收集器的老年代版本</p> 
<p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p> 
<h4><a id="3_601"></a>3.吞吐量优先</h4> 
<pre><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC
-XX:GCTimeRatio=ratio
-XX:MaxGCPauseMillis=ms
-XX:ParallelGCThreads=n
</code></pre> 
<img src="https://images2.imgbox.com/d8/81/C0Chtpi1_o.png" alt="image-20210812111315885"> 
<ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW(stop the world,停掉其他所有工作线程）时间最短</li><li>JDK1.8默认使用的垃圾回收器</li></ul> 
<h5><a id="1Parallel_Scavenge__617"></a>1.Parallel Scavenge 收集器</h5> 
<p>与吞吐量关系密切，故也称为<strong>吞吐量优先收集器</strong></p> 
<p><strong>特点</strong>：</p> 
<p>属于<strong>新生代收集器</strong>，也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是<strong>并行</strong>的多线程收集器（与ParNew收集器类似）</p> 
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p> 
<p><strong>GC自适应调节策略</strong>：</p> 
<p>Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p> 
<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p> 
<ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul> 
<h5><a id="2Parallel_Old__636"></a>2.<strong>Parallel Old 收集器</strong></h5> 
<p>是Parallel Scavenge收集器的老年代版本</p> 
<p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区</p> 
<h4><a id="4_642"></a>4.响应时间优先</h4> 
<pre><code>-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld
-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads
-XX:CMSInitiatingOccupancyFraction=percent
-XX:+CMSScavengeBeforeRemark
</code></pre> 
<p><img src="https://images2.imgbox.com/e4/28/z6l3qayV_o.png" alt="image-20210812111539929"></p> 
<ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li></ul> 
<h5><a id="1CMS__657"></a>1.CMS 收集器</h5> 
<p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p> 
<p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。<strong>并发收集</strong>、低停顿，但是会产生内存碎片</p> 
<p><strong>应用场景</strong>：适用于<strong>注重服务的响应速度</strong>，希望系统停顿时间最短，给用户带来更好的体验等场景下。如<strong>web程序、b/s服务</strong>。</p> 
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p> 
<p><strong>初始标记</strong>：标记GC Roots对象。速度很快但是<strong>仍存在Stop The World问题</strong></p> 
<p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，<strong>找出GC Roots对象所关联的对象且用户线程可并发执行</strong></p> 
<p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录(可达对象变不可达)。仍然存在Stop The World问题</p> 
<p><strong>并发清除</strong>：对没有标记的对象进行清除回收</p> 
<p><strong>CMS收集器</strong>的<strong>内存回收过程</strong>是与<strong>用户线程</strong>一起<strong>并发执行</strong>的</p> 
<h4><a id="5G1_677"></a>5.G1</h4> 
<h5><a id="1_679"></a>1.定义</h5> 
<p>Garbage First</p> 
<ul><li>2004年论文发布</li><li>2009 JDK 6u14体验</li><li>2012 JDK 7u4官方支持</li><li>2017 JDK 9 默认</li></ul> 
<h5><a id="2_688"></a>2.使用场景</h5> 
<ul><li>同时注重吞吐量（Throughput）和低延迟（Low latency)，默认的暂停时间是200ms。</li><li>超大堆内存，会将堆划分为多个等大的Region。</li><li><strong>整体上是标记 - 整理算法</strong>，<strong>两个Region（区域）之间是复制算法</strong>。</li></ul> 
<h5><a id="3JVM_694"></a>3.相关JVM参数</h5> 
<pre><code>-XX:+UserG1GC
-XX:G1HeapRegionSize=size
-XX:MaxGCPauseMillis=time
</code></pre> 
<p>第一个参数：开启G1<br> 第二个参数：设置Region大小，必须设置成，1，2，4，8这样的大小<br> 第三个参数：设置暂停时间ms</p> 
<h5><a id="4G1_706"></a>4.G1垃圾回收阶段</h5> 
<p><img src="https://images2.imgbox.com/6f/5e/RKvak5Oi_o.png" alt="image-20210814124404799"></p> 
<p>第一阶段对新生代进行收集（Young Collection），第二阶段对新生代的收集同时会执行并发标记（Young Collection+ Concurrent Mark） ，第三阶段对新生代、新生代幸存区和老年区进行混合收集（Mixed Collection），以此循环。</p> 
<p>Garbage First 将堆划分大小相等的一个个区域，<strong>每个区域都可以作为新生代、幸存区和老年代。</strong></p> 
<p>E代表伊甸园区域<br> S代表幸存区<br> O代表老年代</p> 
<h6><a id="1Young_Collection_718"></a>1.Young Collection(新生代收集)</h6> 
<ul><li>会STW（Stop The World），但相对于时间还是比较短的</li></ul> 
<p><img src="https://images2.imgbox.com/b4/5e/xwJLcVNf_o.png" alt="image-20210814124946569"></p> 
<img src="https://images2.imgbox.com/06/0e/gPvnM5gU_o.png" alt="image-20210814125457131"> 
<ul><li>新生代垃圾回收会将幸存对象以复制算法复制到幸存区。</li></ul> 
<p><img src="https://images2.imgbox.com/29/0d/W7OvMiWw_o.png" alt="image-20210814125704752"></p> 
<ul><li>新生代垃圾回收会将幸存对象以复制算法复制到幸存区，幸存区存活的对象达到阈值后会以复制算法复制到老年代</li></ul> 
<h6><a id="2Young_Collection_Concurrent_Mark_732"></a>2.Young Collection+ Concurrent Mark(新生代收集+并发标记)</h6> 
<p>初始标记：找到GC Root（根对象）<br> 并发标记：和应用程序并发执行，针对区域内所有的存活对象进行标记。</p> 
<ul><li> <p>在<strong>Young GC时</strong>会进行GC Root的**初始标记 **</p> </li><li> <p><strong>老年代占用堆空间比例达到阈值时</strong>，进行<strong>并发标记</strong>（不会STW),由下面的JVM参数决定</p> <pre><code>-XX:InitiatingHeapOccupancyPercent=percent   (默认45%)
</code></pre> </li></ul> 
<img src="https://images2.imgbox.com/a4/da/hAsUIGTi_o.png" alt="image-20210814131915515"> 当o占到45%就进行并发标记了 
<h6><a id="3Mixed_Collection_748"></a>3.Mixed Collection(混合收集)</h6> 
<p>会对 E、S、O进行全面垃圾回收</p> 
<p><strong>最终标记</strong>：在并发标记的过程中，可能会漏掉一些对象，因为并发标记的同时，其他用户线程还在工作，产生一些垃圾，所以进行最终标记。清理没被标记的对象。</p> 
<ul><li>最终标记（Remark）会STW</li><li><strong>拷贝存活</strong>（Evacuation）会STW</li></ul> 
<pre><code>-XX:MaxGCPauseMillis=ms
</code></pre> 
<p><img src="https://images2.imgbox.com/e3/de/itFNvccQ_o.png" alt="image-20210814132631602"></p> 
<p>过程：在进行混合回收时，新生代垃圾回收会将幸存对象以复制算法复制到幸存区，幸存区存活的对象达到阈值后会以复制算法复制到老年代，老年代中根据最大暂停时间有选择的进行回收，回收价值最高的，将老年代中存活下来的对象以复制算法重新赋值到一个新的老年代中。</p> 
<h5><a id="5Full_GC_765"></a>5.Full GC</h5> 
<p>SerialGC</p> 
<ul><li>新生代内存不足发生的垃圾收集- minor gc</li><li>老年代内存不足发生的垃圾收集- full gc</li></ul> 
<p>ParallelGC</p> 
<ul><li>新生代内存不足发生的垃圾收集- minor gc</li><li>老年代内存不足发生的垃圾收集- full gc</li></ul> 
<p>CMS</p> 
<ul><li>新生代内存不足发生的垃圾收集- minor gc</li><li>老年代内存不足，并发失败后，进行串行收集 full gc</li></ul> 
<p>G1</p> 
<ul><li>新生代内存不足发生的垃圾收集- minor gc</li><li>老年代内存不足，当垃圾回收速度跟不上产生速度，退化为一个串行收集，开始Full GC</li></ul> 
<h5><a id="6Young_Collection__787"></a>6.Young Collection 跨代引用</h5> 
<ul><li> <p>卡表与Remembered Set</p> 
  <ul><li><strong>Remembered Set</strong>存在于E中，<strong>用于保存新生代对象对应的脏卡</strong> 
    <ul><li>脏卡: 老年代被划分为多个区域(一个区域512K)，如果该<br> 区域引用了新生代对象，则该区域被称为<strong>脏卡</strong></li></ul> </li></ul> </li><li> <p>在引用变更时通过post-write barried + dirty card queue</p> </li><li> <p>concurrent refinement threads更新Remembered Set</p> </li><li> <p>新生代回收的跨代引用（老年代引用新生代）问题</p> <p><img src="https://images2.imgbox.com/1c/15/8VClST8x_o.png" alt="1629014846107"></p> </li></ul> 
<p>在进行新生代回收时要找到GC Root根对象。有一部分GC Root对象是来自老年代，老年代存活的对象很多，如果遍历老年代找根对象效率非常低，采用<strong>卡表</strong>（Card Table)的技术，将老年代分成一个个Card,每个Card差不多512k， 老年代其中一个对象引用了新生代对象，那么就称这个Card为脏卡（dirty card)。</p> 
<p><img src="https://images2.imgbox.com/2c/af/tSlIEEpL_o.png" alt="1629015161975"></p> 
<p>将来进行垃圾回收时不需要找整个老年代，只需要找脏卡区就行了</p> 
<h5><a id="7Remark_809"></a>7.Remark（重新标记）</h5> 
<pre><code>pre-write barrier+ satb_mark_queue
</code></pre> 
<p>在垃圾回收时，收集器处理对象的过程中</p> 
<p>黑色：已被处理，需要保留的<br> 灰色：正在处理中的<br> 白色：还未处理的</p> 
<p><img src="https://images2.imgbox.com/b1/e8/TP4Qinej_o.png" alt="1629015999303"></p> 
<p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p> 
<p>过程如下：</p> 
<ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为处理中状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul> 
<p><img src="https://images2.imgbox.com/02/fb/KadfZNMN_o.png" alt="1629016084105"></p> 
<h5><a id="8JDK_8u20__832"></a>8.JDK 8u20 字符串去重</h5> 
<p>过程</p> 
<ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别 
  <ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul> </li></ul> 
<p>优点与缺点</p> 
<ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul> 
<h5><a id="9JDK_8u40__849"></a>9.JDK 8u40 并发标记类卸载</h5> 
<p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p> 
<h5><a id="10JDK_8u60__853"></a>10.JDK 8u60 回收巨型对象</h5> 
<ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul> 
<p><img src="https://images2.imgbox.com/88/b2/gMyMtfIP_o.png" alt="1629017902056"></p> 
<h5><a id="11JDK_9_862"></a>11.JDK 9并发标记起始时间的调整</h5> 
<ul><li> <p>并发标记必须在堆空间占满前完成，否则退化为FullGC</p> </li><li> <p>JDK9之前需要使用-Xx: Initiat ingHeapOccupancyPercent</p> </li><li> <p>JDK9可以动态调整</p> 
  <ul><li> <p>-XX:InitiatingHeapoccupancyPercent 用来设置初始值</p> </li><li> <p>进行数据采样并动态调整</p> </li><li> <p>总会添加一个安全的空档空间</p> </li></ul> </li></ul> 
<h4><a id="5_876"></a>5.垃圾回收调优</h4> 
<h4><a id="5GC__878"></a>5.GC 调优</h4> 
<p>查看虚拟机参数命令</p> 
<pre><code>"F:\JAVA\JDK8.0\bin\java" -XX:+PrintFlagsFinal -version | findstr "GC"
</code></pre> 
<p>可以根据参数去查询具体的信息</p> 
<h5><a id="1_888"></a>1.调优领域</h5> 
<ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul> 
<h5><a id="2_896"></a>2.确定目标</h5> 
<p>低延迟/高吞吐量？ 选择合适的GC</p> 
<ul><li>CMS G1 ZGC</li><li>ParallelGC</li><li>Zing</li></ul> 
<h5><a id="3GCGC_904"></a>3.最快的GC是不发生GC</h5> 
<p>首先排除减少因为自身编写的代码而引发的内存问题</p> 
<ul><li>查看Full GC前后的内存占用，考虑以下几个问题 
  <ul><li>数据是不是太多？</li><li>数据表示是否太臃肿 
    <ul><li>对象图</li><li>对象大小</li></ul> </li><li>是否存在内存泄漏</li></ul> </li></ul> 
<h5><a id="4_915"></a>4.新生代调优</h5> 
<ul><li>新生代的特点 
  <ul><li>所有的new操作分配内存都是非常廉价的 
    <ul><li>TLAB</li></ul> </li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul> </li><li>新生代内存越大越好么？ 
  <ul><li>不是 
    <ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul> </li><li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li></ul> </li></ul> 
<h5><a id="5_929"></a>5.幸存区调优</h5> 
<ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul> 
<h5><a id="6_934"></a>6.老年代调优</h5> 
<h2><a id="_936"></a>四、类加载与字节码技术</h2> 
<p><img src="https://images2.imgbox.com/06/5a/Ac3I9xau_o.png" alt="1629117749253"></p> 
<h3><a id="1_940"></a>1.类文件结构</h3> 
<p>首先获得.class文件<br> 方法：</p> 
<pre><code>javac X:.../XX.java
</code></pre> 
<p>以下是字节码文件</p> 
<pre><code>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 
0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 
0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 
0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 
0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 
0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 
0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 
0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f 
0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 
0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 
0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 
0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 
0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 
0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 
0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64
0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 
0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 
0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 
0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 
0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 
0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 
0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 
0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 
0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 
0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 
0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 
0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 
0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 
0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 
0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 
0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 
0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 
0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 
0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a 
0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b 
0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 
0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 
0001120 00 00 02 00 14
</code></pre> 
<p>根据 JVM 规范，<strong>类文件结构</strong>如下</p> 
<pre><code>u4 			  magic
u2             minor_version;    
u2             major_version;    
u2             constant_pool_count;    
cp_info        constant_pool[constant_pool_count-1];    
u2             access_flags;    
u2             this_class;    
u2             super_class;   
u2             interfaces_count;    
u2             interfaces[interfaces_count];   
u2             fields_count;    
field_info     fields[fields_count];   
u2             methods_count;    
method_info    methods[methods_count];    
u2             attributes_count;    
attribute_info attributes[attributes_count];
</code></pre> 
<h4><a id="1_1013"></a>1.魔数</h4> 
<p>u4 magic<br> 对应着字节码文件的0~3个字节<br> 0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09<br> 表示是java</p> 
<h4><a id="2_1020"></a>2.版本</h4> 
<p>u2 minor_version;</p> 
<p>u2 major_version;</p> 
<p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09<br> 00 00 表示小版本<br> 00 34 主版本，表示52，代表JDK8</p> 
<h4><a id="3_1030"></a>3.常量池</h4> 
<p><img src="https://images2.imgbox.com/8b/d5/TAAmNts1_o.png" alt="1629118275331"></p> 
<p>8~9 字节，表示常量池长度，00 23 （35） 表示常量池有 #1~#34项，注意 #0 项不计入，也没有值 0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09</p> 
<p>第#1项 0a 表示一个 Method 信息，00 06 和 00 15（21） 表示它引用了常量池中 #6 和 #21 项来获得 这个方法的【所属类】和【方法名】 0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p> 
<p>第#2项 09 表示一个 Field 信息，00 16（22）和 00 17（23） 表示它引用了常量池中 #22 和 # 23 项 来获得这个成员变量的【所属类】和【成员变量名】 0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 <strong>09</strong><br> 0000020 <strong>00 16 00 17</strong> 08 00 18 0a 00 19 00 1a 07 00 1b 07</p> 
<p>略…</p> 
<h4><a id="4_1043"></a>4.访问标识与继承信息</h4> 
<p><img src="https://images2.imgbox.com/f8/90/VnBc9ABw_o.png" alt="1629118762947"></p> 
<p>21 表示该 class 是一个类，公共的<br> 0000660 29 56 <strong>00 21</strong> 00 05 00 06 00 00 00 00 00 02 00 01 05<br> 表示根据常量池中 #5 找到本类全限定名<br> 0000660 29 56 00 21 <strong>00 05</strong> 00 06 00 00 00 00 00 02 00 01 06<br> 表示根据常量池中 #6 找到父类全限定名<br> 0000660 29 56 00 21 00 05 <strong>00 06</strong> 00 00 00 00 00 02 00 01<br> 表示接口的数量，本类为 0<br> 0000660 29 56 00 21 00 05 00 06 <strong>00 00</strong> 00 00 00 02 00 01</p> 
<h4><a id="5Field_1056"></a>5.Field信息</h4> 
<p><img src="https://images2.imgbox.com/4b/c9/gOscQMjH_o.png" alt="1629118857319"></p> 
<p>表示<strong>成员变量</strong>数量，本类为 0<br> 0000660 29 56 00 21 00 05 00 06 00 00 <strong>00 00</strong> 00 02 00 01</p> 
<h4><a id="6Method_1063"></a>6.Method信息</h4> 
<p>表示方法数量，本类为 2<br> 0000660 29 56 00 21 00 05 00 06 00 00 00 00 <strong>00 02</strong> 00 01<br> 一个方法由 访问修饰符，名称，参数描述，方法属性数量，方法属性组成</p> 
<h4><a id="7__1069"></a>7 附加属性</h4> 
<p>00 01 表示附加属性数量<br> 00 13 表示引用了常量池 #19 项，即【SourceFile】<br> 00 00 00 02 表示此属性的长度<br> 00 14 表示引用了常量池 #20 项，即【HelloWorld.java】<br> 0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 0001120 00 00 02 00 14</p> 
<h3><a id="2_1077"></a>2.字节码指令</h3> 
<h4><a id="1_1079"></a>1.入门</h4> 
<p>public cn.itcast.jvm.t5.HelloWorld(); 构造方法的字节码指令<br> 2a =&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数<br> b7 =&gt; invokespecial 预备调用构造方法，哪个方法呢？<br> 00 01 引用常量池中 #1 项，即【 Method java/lang/Object.“init”😦)V 】<br> b1 表示返回</p> 
<p>public static void main(java.lang.String[]); 主方法的字节码指令<br> b2 =&gt; getstatic 用来加载静态变量，哪个静态变量呢？<br> 00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】<br> 12 =&gt; ldc 加载参数，哪个参数呢？<br> 03 引用常量池中 #3 项，即 【String hello world】<br> b6 =&gt; invokevirtual 预备调用成员方法，哪个方法呢？<br> 00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】<br> b1 表示返回</p> 
<h4><a id="2_javap__1096"></a>2 javap 工具</h4> 
<p>自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件</p> 
<pre><code>[root@localhost ~]# javap -v HelloWorld.class
Classfile /root/HelloWorld.class
Last modified Jul 7, 2019; size 597 bytes
MD5 checksum 361dca1c3f4ae38644a9cd5060ac6dbc
Compiled from "HelloWorld.java"
public class cn.itcast.jvm.t5.HelloWorld
minor version: 0
major version: 52
flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
#1 = Methodref #6.#21 // java/lang/Object."&lt;init&gt;":()V
#2 = Fieldref #22.#23 //
java/lang/System.out:Ljava/io/PrintStream;
#3 = String #24 // hello world
#4 = Methodref #25.#26 // java/io/PrintStream.println:
(Ljava/lang/String;)V
#5 = Class #27 // cn/itcast/jvm/t5/HelloWorld
#6 = Class #28 // java/lang/Object
#7 = Utf8 &lt;init&gt;
#8 = Utf8 ()V
#9 = Utf8 Code
#10 = Utf8 LineNumberTable
#11 = Utf8 LocalVariableTable
#12 = Utf8 this
#13 = Utf8 Lcn/itcast/jvm/t5/HelloWorld;
#16 = Utf8 args
#17 = Utf8 [Ljava/lang/String;
#18 = Utf8 MethodParameters
#19 = Utf8 SourceFile
#20 = Utf8 HelloWorld.java
#21 = NameAndType #7:#8 // "&lt;init&gt;":()V
#22 = Class #29 // java/lang/System
#23 = NameAndType #30:#31 // out:Ljava/io/PrintStream;
#24 = Utf8 hello world
#25 = Class #32 // java/io/PrintStream
#26 = NameAndType #33:#34 // println:(Ljava/lang/String;)V
#27 = Utf8 cn/itcast/jvm/t5/HelloWorld
#28 = Utf8 java/lang/Object
#29 = Utf8 java/lang/System
#30 = Utf8 out
#31 = Utf8 Ljava/io/PrintStream;
#32 = Utf8 java/io/PrintStream
#33 = Utf8 println
#34 = Utf8 (Ljava/lang/String;)V
{
public cn.itcast.jvm.t5.HelloWorld();
descriptor: ()V
flags: ACC_PUBLIC
Code:
stack=1, locals=1, args_size=1
0: aload_0
1: invokespecial #1 // Method java/lang/Object."
&lt;init&gt;":()V
4: return
LineNumberTable:
line 4: 0
LocalVariableTable:
Start Length Slot Name Signature
0 5 0 this Lcn/itcast/jvm/t5/HelloWorld;
public static void main(java.lang.String[]);
descriptor: ([Ljava/lang/String;)V
flags: ACC_PUBLIC, ACC_STATIC
Code:
stack=2, locals=1, args_size=1
0: getstatic #2 // Field
java/lang/System.out:Ljava/io/PrintStream;
3: ldc #3 // String hello world
5: invokevirtual #4 // Method
java/io/PrintStream.println:(Ljava/lang/String;)V
8: return
LineNumberTable:
line 6: 0
line 7: 8
LocalVariableTable:
Start Length Slot Name Signature
0 9 0 args [Ljava/lang/String;
MethodParameters:
Name Flags
args
}

</code></pre> 
<h4><a id="3_1184"></a>3.图解方法执行流程</h4> 
<h5><a id="1_1186"></a>1.代码</h5> 
<pre><code>package cn.itcast.jvm.t3.bytecode;
/**
* 演示 字节码指令 和 操作数栈、常量池的关系
*/
public class Demo3_1 {
public static void main(String[] args) {
int a = 10;
int b = Short.MAX_VALUE + 1;
int c = a + b;
System.out.println(c);
}
}
</code></pre> 
<h5><a id="2_1203"></a>2.编译后的字节码文件</h5> 
<pre><code>[root@localhost ~]# javap -v Demo3_1.class
Classfile /root/Demo3_1.class
Last modified Jul 7, 2019; size 665 bytes
MD5 checksum a2c29a22421e218d4924d31e6990cfc5
Compiled from "Demo3_1.java"
public class cn.itcast.jvm.t3.bytecode.Demo3_1
minor version: 0
major version: 52
flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
#1 = Methodref #7.#26 // java/lang/Object."&lt;init&gt;":()V
#2 = Class #27 // java/lang/Short
#3 = Integer 32768
#4 = Fieldref #28.#29 //
java/lang/System.out:Ljava/io/PrintStream;
#5 = Methodref #30.#31 // java/io/PrintStream.println:(I)V
#6 = Class #32 // cn/itcast/jvm/t3/bytecode/Demo3_1
#7 = Class #33 // java/lang/Object
#8 = Utf8 &lt;init&gt;
#9 = Utf8 ()V
#10 = Utf8 Code
#11 = Utf8 LineNumberTable
#12 = Utf8 LocalVariableTable
#13 = Utf8 this
#14 = Utf8 Lcn/itcast/jvm/t3/bytecode/Demo3_1;
#15 = Utf8 main
#16 = Utf8 ([Ljava/lang/String;)V
#17 = Utf8 args
#18 = Utf8 [Ljava/lang/String;
#19 = Utf8 a
...
</code></pre> 
<h5><a id="3_1239"></a>3.<strong>常量池载入运行时常量池</strong></h5> 
<p>常量池也属于方法区，只不过这里单独提出来了<br> <img src="https://images2.imgbox.com/ff/31/me3pydxt_o.png" alt="image-20210817205302331"></p> 
<h5><a id="4_1244"></a>4.<strong>方法字节码载入方法区</strong></h5> 
<p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），<strong>局部变量表</strong>中有4个槽位<br> <img src="https://images2.imgbox.com/e3/eb/LRMPensG_o.png" alt="image-20210817205352552"></p> 
<h5><a id="5main__1249"></a>5.main 线程开始运行，分配栈帧内存</h5> 
<p>main 线程开始运行，分配栈帧内存<br> <img src="https://images2.imgbox.com/04/7d/C2vVj0y5_o.png" alt="image-20210817205534973"><br> 绿色：局部变量表<br> 红色：操作数栈</p> 
<p><strong>执行引擎开始执行字节码</strong></p> 
<p><strong>bipush 10</strong></p> 
<ul><li> <p>将一个 byte 压入操作数栈</p> <p>（其长度会补齐 4 个字节），类似的指令还有</p> 
  <ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul> </li></ul> 
<p><strong>istore 1</strong><br> 将操作数栈栈顶元素弹出，放入局部变量表的slot 1中<br> 对应代码中的</p> 
<pre><code>a = 10
</code></pre> 
<p><img src="https://images2.imgbox.com/62/c0/aQHnZsiW_o.png" alt="image-20210818094435471"></p> 
<p><strong>ldc #3</strong><br> 读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中<br> <img src="https://images2.imgbox.com/7c/58/8aGdz7nz_o.png" alt="image-20210818094454221"></p> 
<p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p> 
<p><strong>istore 2</strong><br> 将操作数栈中的元素弹出，放到局部变量表的2号位置</p> 
<p><strong>iload1 iload2</strong></p> 
<p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p> 
<ul><li>因为只能在操作数栈中执行运算操作</li></ul> 
<p><img src="https://images2.imgbox.com/3c/cd/Zm86l9YD_o.png" alt="image-20210818094513242"></p> 
<p><strong>iadd</strong><br> 将操作数栈中的两个元素弹出栈并相加，结果在压入操作数栈中<br> <img src="https://images2.imgbox.com/66/5f/Vmu8UPej_o.png" alt="image-20210818094533394"></p> 
<p><strong>istore 3</strong></p> 
<p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p> 
<p><strong>getstatic #4</strong></p> 
<p>在运行时常量池中找到#4，发现是一个对象</p> 
<p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中<br> <img src="https://images2.imgbox.com/2f/33/xc6sP4FC_o.png" alt="image-20210818094600172"></p> 
<p><strong>iload 3</strong></p> 
<p>将局部变量表中3号位置的元素压入操作数栈中</p> 
<p><strong>invokevirtual 5</strong></p> 
<p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p> 
<p>生成新的栈帧（分配 locals、stack等）</p> 
<p>传递参数，执行新栈帧中的字节码</p> 
<p><img src="https://images2.imgbox.com/03/0c/8RYquKml_o.png" alt="image-20210818094633175"></p> 
<p>执行完毕，弹出栈帧</p> 
<p>清除 main 操作数栈内容<br> <img src="https://images2.imgbox.com/8c/e1/Hi1Vy6pH_o.png" alt="image-20210818094646948"></p> 
<p><strong>return</strong><br> 完成 main 方法调用，弹出 main 栈帧，程序结束</p> 
<h4><a id="4_1333"></a>4.通过字节码指令来分析问题</h4> 
<p>代码</p> 
<pre><code>public class Demo2 {
	public static void main(String[] args) {
		int i=0;
		int x=0;
		while(i&lt;10) {
			x = x++;
			i++;
		}
		System.out.println(x); //接过为0
	}
}
</code></pre> 
<p>最终的x结果为0， 通过分析字节码指令即可知晓</p> 
<pre><code>Code:
     stack=2, locals=3, args_size=1	//操作数栈分配2个空间，局部变量表分配3个空间
        0: iconst_0	//准备一个常数0
        1: istore_1	//将常数0放入局部变量表的1号槽位 i=0
        2: iconst_0	//准备一个常数0
        3: istore_2	//将常数0放入局部变量的2号槽位 x=0	
        4: iload_1		//将局部变量表1号槽位的数放入操作数栈中
        5: bipush        10	//将数字10放入操作数栈中，此时操作数栈中有2个数
        7: if_icmpge     21	//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空
       10: iload_2		//将局部变量2号槽位的数放入操作数栈中，放入的值是0
       11: iinc          2, 1	//将局部变量2号槽位的数加1，自增后，槽位中的值为1
       14: istore_2	//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0
       15: iinc          1, 1 //1号槽位的值自增1
       18: goto          4 //跳转到第4条指令
       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       24: iload_2
       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
       28: return
</code></pre> 
<h4><a id="5_1374"></a>5.构造方法</h4> 
<h5><a id="1cinitV_1376"></a>1.cinit()V</h5> 
<pre><code>public class Demo3 {
	static int i = 10;

	static {
		i = 20;
	}

	static {
		i = 30;
	}

	public static void main(String[] args) {
		System.out.println(i); //结果为30
	}
}
</code></pre> 
<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 <strong>static 静态代码块</strong>和<strong>静态成员赋值</strong>的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p> 
<pre><code>stack=1, locals=0, args_size=0
         0: bipush        10
         2: putstatic     #3                  // Field i:I
         5: bipush        20
         7: putstatic     #3                  // Field i:I
        10: bipush        30
        12: putstatic     #3                  // Field i:I
        15: return
</code></pre> 
<h5><a id="2initV_1409"></a>2.init()V</h5> 
<pre><code>public class Demo4 {
	private String a = "s1";

	{
		b = 20;
	}

	private int b = 10;

	{
		a = "s2";
	}

	public Demo4(String a, int b) {
		this.a = a;
		this.b = b;
	}

	public static void main(String[] args) {
		Demo4 d = new Demo4("s3", 30);
		System.out.println(d.a);
		System.out.println(d.b);
	}
}
</code></pre> 
<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p> 
<pre><code>Code:
     stack=2, locals=3, args_size=3
        0: aload_0
        1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
        4: aload_0
        5: ldc           #2                  // String s1
        7: putfield      #3                  // Field a:Ljava/lang/String;
       10: aload_0
       11: bipush        20
       13: putfield      #4                  // Field b:I
       16: aload_0
       17: bipush        10
       19: putfield      #4                  // Field b:I
       22: aload_0
       23: ldc           #5                  // String s2
       25: putfield      #3                  // Field a:Ljava/lang/String;
       //原始构造方法在最后执行
       28: aload_0
       29: aload_1
       30: putfield      #3                  // Field a:Ljava/lang/String;
       33: aload_0
       34: iload_2
       35: putfield      #4                  // Field b:I
       38: return
</code></pre> 
<h4><a id="6_1467"></a>6.方法调用</h4> 
<pre><code>public class Demo5 {
	public Demo5() {

	}

	private void test1() {

	}

	private final void test2() {

	}

	public void test3() {

	}

	public static void test4() {

	}

	public static void main(String[] args) {
		Demo5 demo5 = new Demo5();
		demo5.test1();
		demo5.test2();
		demo5.test3();
		Demo5.test4();
	}
}
</code></pre> 
<p>不同方法在调用时，对应的虚拟机指令有所区别</p> 
<ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用<strong>invokevirtual</strong>指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用<strong>invokestatic</strong>指令</li></ul> 
<h4><a id="7_1507"></a>7.多态原理</h4> 
<p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p> 
<p>在执行invokevirtual指令时，经历了以下几个步骤</p> 
<ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul> 
<h4><a id="8_1519"></a>8.异常处理</h4> 
<h6><a id="trycatch_1521"></a>try-catch</h6> 
<pre><code>public class Demo1 {
	public static void main(String[] args) {
		int i = 0;
		try {
			i = 10;
		}catch (Exception e) {
			i = 20;
		}
	}
}
</code></pre> 
<p>对应字节码指令</p> 
<pre><code>Code:
     stack=1, locals=3, args_size=1
        0: iconst_0
        1: istore_1
        2: bipush        10
        4: istore_1
        5: goto          12
        8: astore_2
        9: bipush        20
       11: istore_1
       12: return
     //多出来一个异常表
     Exception table:
        from    to  target type
            2     5     8   Class java/lang/Exception
</code></pre> 
<ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul> 
<h6><a id="singlecatch_1559"></a>多个single-catch</h6> 
<pre><code>public class Demo1 {
	public static void main(String[] args) {
		int i = 0;
		try {
			i = 10;
		}catch (ArithmeticException e) {
			i = 20;
		}catch (Exception e) {
			i = 30;
		}
	}
}
</code></pre> 
<p>对应的字节码</p> 
<pre><code>Code:
     stack=1, locals=3, args_size=1
        0: iconst_0
        1: istore_1
        2: bipush        10
        4: istore_1
        5: goto          19
        8: astore_2
        9: bipush        20
       11: istore_1
       12: goto          19
       15: astore_2
       16: bipush        30
       18: istore_1
       19: return
     Exception table:
        from    to  target type
            2     5     8   Class java/lang/ArithmeticException
            2     5    15   Class java/lang/Exception
</code></pre> 
<ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul> 
<h6><a id="finally_1602"></a>finally</h6> 
<pre><code>public class Demo2 {
	public static void main(String[] args) {
		int i = 0;
		try {
			i = 10;
		} catch (Exception e) {
			i = 20;
		} finally {
			i = 30;
		}
	}
}
</code></pre> 
<p>对应字节码</p> 
<pre><code>Code:
     stack=1, locals=4, args_size=1
        0: iconst_0
        1: istore_1
       -------------------------------------------------
        //try块
        2: bipush        10
        4: istore_1
        //try块执行完后，会执行finally    
        5: bipush        30
        7: istore_1
        8: goto          27
       -------------------------------------------------
       //catch块     
       11: astore_2 //异常信息放入局部变量表的2号槽位
       12: bipush        20
       14: istore_1
       //catch块执行完后，会执行finally        
       15: bipush        30
       17: istore_1
       -------------------------------------------------
       18: goto          27
       //出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   
       21: astore_3
       22: bipush        30
       24: istore_1
       -------------------------------------------------
       25: aload_3
       26: athrow  //抛出异常
       27: return
     Exception table:
        from    to  target type
            2     5    11   Class java/lang/Exception
            2     5    21   any
           11    15    21   any
</code></pre> 
<p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p> 
<p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p> 
<h6><a id="finallyreturn_1663"></a>finally中的return</h6> 
<pre><code>public class Demo3 {
	public static void main(String[] args) {
		int i = Demo3.test();
        //结果为20
		System.out.println(i);
	}

	public static int test() {
		int i;
		try {
			i = 10;
			return i;
		} finally {
			i = 20;
			return i;
		}
	}
}
</code></pre> 
<p>对应字节码</p> 
<pre><code>Code:
     stack=1, locals=3, args_size=0
        0: bipush        10
        2: istore_0
        3: iload_0
        4: istore_1  //暂存返回值
        5: bipush        20
        7: istore_0
        8: iload_0
        9: ireturn	//ireturn会返回操作数栈顶的整型值20
       //如果出现异常，还是会执行finally块中的内容，没有抛出异常
       10: astore_2
       11: bipush        20
       13: istore_0
       14: iload_0
       15: ireturn	//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！
     Exception table:
        from    to  target type
            0     5    10   any
</code></pre> 
<ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li><li>所以<strong>不要在finally中进行返回操作</strong></li></ul> 
<h6><a id="_1715"></a>被吞掉的异常</h6> 
<pre><code>public class Demo3 {
   public static void main(String[] args) {
      int i = Demo3.test();
      //最终结果为20
      System.out.println(i);
   }

   public static int test() {
      int i;
      try {
         i = 10;
         //这里应该会抛出异常
         i = i/0;
         return i;
      } finally {
         i = 20;
         return i;
      }
   }
}
</code></pre> 
<p>会发现打印结果为20，并未抛出异常</p> 
<h6><a id="finallyreturn_1742"></a>finally不带return</h6> 
<pre><code>public class Demo4 {
	public static void main(String[] args) {
	//最终结果为10
		int i = Demo4.test();
		System.out.println(i);
	}

	public static int test() {
		int i = 10;
		try {
			return i;
		} finally {
			i = 20;
		}
	}
}
</code></pre> 
<p>对应字节码</p> 
<pre><code>Code:
     stack=1, locals=3, args_size=0
        0: bipush        10
        2: istore_0 //赋值给i 10
        3: iload_0	//加载到操作数栈顶
        4: istore_1 //加载到局部变量表的1号位置
        5: bipush        20
        7: istore_0 //赋值给i 20
        8: iload_1 //加载局部变量表1号位置的数10到操作数栈
        9: ireturn //返回操作数栈顶元素 10
       10: astore_2
       11: bipush        20
       13: istore_0
       14: aload_2 //加载异常
       15: athrow //抛出异常
     Exception table:
        from    to  target type
            3     5    10   any
</code></pre> 
<p><strong>finally中有return时，会直接在finally中退出，导致try、catch中的return失效。</strong></p> 
<h3><a id="3_____1788"></a>3.语法糖 编译器处理</h3> 
<p>所谓的<strong>语法糖</strong> ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p> 
<p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p> 
<h4><a id="1_1794"></a>1.默认构造函数</h4> 
<pre><code>public class Candy1 {

}
</code></pre> 
<p>经过编译期优化后</p> 
<pre><code>public class Candy1 {
   //这个无参构造器是java编译器帮我们加上的
   public Candy1() {
      //即调用父类 Object 的无参构造方法，即调用 java/lang/Object." &lt;init&gt;":()V
      super();
   }
}
</code></pre> 
<h4><a id="2_1814"></a>2.自动拆装箱</h4> 
<p>基本类型和其包装类型的相互转换过程，称为拆装箱</p> 
<p>在JDK 5以后，它们的转换可以在编译期自动完成</p> 
<pre><code>public class Demo2 {
   public static void main(String[] args) {
      Integer x = 1;
      int y = x;
   }
}
</code></pre> 
<p>转换过程如下</p> 
<pre><code>public class Demo2 {
   public static void main(String[] args) {
      //基本类型赋值给包装类型，称为装箱
      Integer x = Integer.valueOf(1);
      //包装类型赋值给基本类型，称谓拆箱
      int y = x.intValue();
   }
}
</code></pre> 
<h4><a id="3_1842"></a>3.泛型集合取值</h4> 
<p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p> 
<pre><code>public class Demo3 {
   public static void main(String[] args) {
      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
      list.add(10);
      Integer x = list.get(0);
   }
}
</code></pre> 
<p>对应字节码</p> 
<pre><code>Code:
    stack=2, locals=3, args_size=1
       0: new           #2                  // class java/util/ArrayList
       3: dup
       4: invokespecial #3                  // Method java/util/ArrayList."&lt;init&gt;":()V
       7: astore_1
       8: aload_1
       9: bipush        10
      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      //这里进行了泛型擦除，实际调用的是add(Objcet o)
      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z

      19: pop
      20: aload_1
      21: iconst_0
      //这里也进行了泛型擦除，实际调用的是get(Object o)   
      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;
//这里进行了类型转换，将Object转换成了Integer
      27: checkcast     #7                  // class java/lang/Integer
      30: astore_2
      31: return
</code></pre> 
<p>所以调用get函数取值时，有一个类型转换的操作</p> 
<pre><code>Integer x = (Integer) list.get(0);
</code></pre> 
<p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p> 
<pre><code>int x = (Integer) list.get(0).intValue();
</code></pre> 
<h4><a id="4_1894"></a>4.可变参数</h4> 
<pre><code>public class Demo4 {
   public static void foo(String... args) {
      //将args赋值给arr，可以看出String...实际就是String[] 
      String[] arr = args;
      System.out.println(arr.length);
   }

   public static void main(String[] args) {
      foo("hello", "world");
   }
}
</code></pre> 
<p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p> 
<pre><code>public class Demo4 {
   public Demo4 {}

    
   public static void foo(String[] args) {
      String[] arr = args;
      System.out.println(arr.length);
   }

   public static void main(String[] args) {
      foo(new String[]{"hello", "world"});
   }
}
</code></pre> 
<p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p> 
<h4><a id="5foreach_1930"></a>5.foreach</h4> 
<pre><code>public class Demo5 {
	public static void main(String[] args) {
        //数组赋初值的简化写法也是一种语法糖。
		int[] arr = {1, 2, 3, 4, 5};
		for(int x : arr) {
			System.out.println(x);
		}
	}
}
</code></pre> 
<p>编译器会帮我们转换为</p> 
<pre><code>public class Demo5 {
    public Demo5 {}

	public static void main(String[] args) {
		int[] arr = new int[]{1, 2, 3, 4, 5};
		for(int i=0; i&lt;arr.length; ++i) {
			int x = arr[i];
			System.out.println(x);
		}
	}
}
</code></pre> 
<p><strong>如果是集合使用foreach</strong></p> 
<pre><code>public class Demo5 {
   public static void main(String[] args) {
      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
      for (Integer x : list) {
         System.out.println(x);
      }
   }
}
</code></pre> 
<p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p> 
<pre><code>public class Demo5 {
    public Demo5 {}
    
   public static void main(String[] args) {
      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
      //获得该集合的迭代器
      Iterator&lt;Integer&gt; iterator = list.iterator();
      while(iterator.hasNext()) {
         Integer x = iterator.next();
         System.out.println(x);
      }
   }
}
</code></pre> 
<h4><a id="6switch_1991"></a>6.switch字符串</h4> 
<pre><code>public class Demo6 {
   public static void main(String[] args) {
      String str = "hello";
      switch (str) {
         case "hello" :
            System.out.println("h");
            break;
         case "world" :
            System.out.println("w");
            break;
         default:
            break;
      }
   }
}
</code></pre> 
<p>在编译器中执行的操作</p> 
<pre><code>public class Demo6 {
   public Demo6() {
      
   }
   public static void main(String[] args) {
      String str = "hello";
      int x = -1;
      //通过字符串的hashCode+value来判断是否匹配
      switch (str.hashCode()) {
         //hello的hashCode
         case 99162322 :
            //再次比较，因为字符串的hashCode有可能相等
            if(str.equals("hello")) {
               x = 0;
            }
            break;
         //world的hashCode
         case 11331880 :
            if(str.equals("world")) {
               x = 1;
            }
            break;
         default:
            break;
      }

      //用第二个switch在进行输出判断
      switch (x) {
         case 0:
            System.out.println("h");
            break;
         case 1:
            System.out.println("w");
            break;
         default:
            break;
      }
   }
}
</code></pre> 
<p>过程说明：</p> 
<ul><li>在编译期间，单个的switch被分为了两个 
  <ul><li>第一个用来匹配字符串，并给x赋值 
    <ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul> </li><li>第二个用来根据x的值来决定输出语句</li></ul> </li></ul> 
<h4><a id="7switch_2063"></a>7.switch枚举</h4> 
<pre><code>public class Demo7 {
   public static void main(String[] args) {
      SEX sex = SEX.MALE;
      switch (sex) {
         case MALE:
            System.out.println("man");
            break;
         case FEMALE:
            System.out.println("woman");
            break;
         default:
            break;
      }
   }
}

enum SEX {
   MALE, FEMALE;
}
</code></pre> 
<p>编译器中执行的代码如下</p> 
<pre><code>public class Demo7 {
   /**     
    * 定义一个合成类（仅 jvm 使用，对我们不可见）     
    * 用来映射枚举的 ordinal 与数组元素的关系     
    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     
    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     
    */ 
   static class $MAP {
      //数组大小即为枚举元素个数，里面存放了case用于比较的数字
      static int[] map = new int[2];
      static {
         //ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1
         map[SEX.MALE.ordinal()] = 1;
         map[SEX.FEMALE.ordinal()] = 2;
      }
   }

   public static void main(String[] args) {
      SEX sex = SEX.MALE;
      //将对应位置枚举元素的值赋给x，用于case操作
      int x = $MAP.map[sex.ordinal()];
      switch (x) {
         case 1:
            System.out.println("man");
            break;
         case 2:
            System.out.println("woman");
            break;
         default:
            break;
      }
   }
}

enum SEX {
   MALE, FEMALE;
}
</code></pre> 
<h4><a id="8_2129"></a>8.枚举类</h4> 
<pre><code>enum SEX {
   MALE, FEMALE;
}
</code></pre> 
<p>转换后的代码</p> 
<pre><code>public final class Sex extends Enum&lt;Sex&gt; {   
   //对应枚举类中的元素
   public static final Sex MALE;    
   public static final Sex FEMALE;    
   private static final Sex[] $VALUES;
   
    static {       
    	//调用构造函数，传入枚举元素的值及ordinal
    	MALE = new Sex("MALE", 0);    
        FEMALE = new Sex("FEMALE", 1);   
        $VALUES = new Sex[]{MALE, FEMALE}; 
   }
 	
   //调用父类中的方法
    private Sex(String name, int ordinal) {     
        super(name, ordinal);    
    }
   
    public static Sex[] values() {  
        return $VALUES.clone();  
    }
    public static Sex valueOf(String name) { 
        return Enum.valueOf(Sex.class, name);  
    } 
   
}
</code></pre> 
<h4><a id="9_2168"></a>9.匿名内部类</h4> 
<pre><code>public class Demo8 {
   public static void main(String[] args) {
      Runnable runnable = new Runnable() {
         @Override
         public void run() {
            System.out.println("running...");
         }
      };
   }
}
</code></pre> 
<p>转换后的代码</p> 
<pre><code>public class Demo8 {
   public static void main(String[] args) {
      //用额外创建的类来创建匿名内部类对象
      Runnable runnable = new Demo8$1();
   }
}

//创建了一个额外的类，实现了Runnable接口
final class Demo8$1 implements Runnable {
   public Demo8$1() {}

   @Override
   public void run() {
      System.out.println("running...");
   }
}
</code></pre> 
<p>如果匿名内部类中引用了<strong>局部变量</strong></p> 
<pre><code>public class Demo8 {
   public static void main(String[] args) {
      int x = 1;
      Runnable runnable = new Runnable() {
         @Override
         public void run() {
            System.out.println(x);
         }
      };
   }
}
</code></pre> 
<p>转化后代码</p> 
<pre><code>public class Demo8 {
   public static void main(String[] args) {
      int x = 1;
      Runnable runnable = new Runnable() {
         @Override
         public void run() {
            System.out.println(x);
         }
      };
   }
}

final class Demo8$1 implements Runnable {
   //多创建了一个变量
   int val$x;
   //变为了有参构造器
   public Demo8$1(int x) {
      this.val$x = x;
   }

   @Override
   public void run() {
      System.out.println(val$x);
   }
}
</code></pre> 
<p>注意这同时解释了为什么匿名内部类引用局部变量时,局部变量必须是final的:因为在创建<br> Candy11$1对象时,将X的值赋值给了对象val的x属性，所以X不应该再发生变化。如果变化，那么val的x属性没有机会再跟着一起变化</p> 
<h3><a id="4_2253"></a>4.类加载阶段</h3> 
<h4><a id="1_2255"></a>1.加载</h4> 
<p>将类的字节码载入方法区中<br> 内部采用C++的instanceKlass描述java类，它的重要field有：<br> _java_mirror 即java的类镜像，例如对String来说，就是String.class，作用是把klass保留给java使用<br> _super 即父类<br> _fields 即成员变量<br> _methods 即方法<br> _constants 即类加载器<br> _vtable 虚方法表<br> _itable 接口方法表<br> 如果这个类还有父类没有加载，先加载父类<br> <strong>加载</strong>和<strong>链接</strong>可能是交替运行的<br> 注：instanceKlass 这样的<strong>元数据</strong>是存储在方法区（1.8后的元空间内），但 _java_mirror是存储在堆中<br> 可以通过前面介绍的HSDB工具查看<br> <img src="https://images2.imgbox.com/ab/24/Yk0SJI6F_o.png" alt="image-20210819111117807"></p> 
<h4><a id="2_2272"></a>2.链接</h4> 
<h5><a id="1_2274"></a>1.验证</h5> 
<ul><li>验证类是否复核JVM规范，安全性检查<br> 例如：修改HelloWorld。class的魔数，在控制台运行，报出异常</li></ul> 
<pre><code>E:\git\jvm\out\production\jvm&gt;java cn.itcast.jvm.t5.HelloWorld
Error: A JNI error has occurred, please check your installation and try again
Exception in thread "main" java.lang.ClassFormatError: Incompatible magic value
3405691578 in class file cn/itcast/jvm/t5/HelloWorld
at java.lang.ClassLoader.defineClass1(Native Method)
at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
at
java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)
at java.net.URLClassLoader.access$100(URLClassLoader.java:73)
at java.net.URLClassLoader$1.run(URLClassLoader.java:368)
at java.net.URLClassLoader$1.run(URLClassLoader.java:362)
at java.security.AccessController.doPrivileged(Native Method)
at java.net.URLClassLoader.findClass(URLClassLoader.java:361)
at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)
</code></pre> 
<h5><a id="2_2300"></a>2.准备</h5> 
<ul><li>为static变量分配空间，设置默认值 
  <ul><li>static 变量在JDK 7 之前存储于instanceKlass末尾（存储于方法区），从JDK 7开始，存储于_java_mirror 末尾（存储于堆中）</li><li>static变量<strong>分配空间</strong>和<strong>赋值</strong>时两个步骤，<strong>分配空间</strong>在<strong>准备阶段</strong>完成，<strong>赋值</strong>在<strong>初始化阶段</strong>完成</li><li>如果 static 变量是final的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li><li>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在<strong>初始化阶段</strong>完成</li></ul> </li></ul> 
<h5><a id="3_2308"></a>3.解析</h5> 
<ul><li>迅即将常量池中的符号引用图换位直接引用的过程</li></ul> 
<h4><a id="3_2312"></a>3.初始化</h4> 
<p>&lt;cinit&gt;()V 方法<br> 初始化即调用 &lt;cinit&gt;()V ，虚拟机会保证这个类的『构造方法』的线程安全</p> 
<h5><a id="1_2317"></a>1.发生时机</h5> 
<ul><li>main 方法所在的类,总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化,如果父类还没初始化，会引发</li><li>子类访问父类的静态变量,只会触发父类的初始化<br> Class.forName</li><li>new 会导致初始化</li></ul> 
<h5><a id="2_2326"></a>2.以下情况不会初始化</h5> 
<ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul> 
<p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p> 
<h3><a id="5_2336"></a>5.类加载器</h3> 
<h4><a id="1_2338"></a>1.基本介绍</h4> 
<p>Java虚拟机设计团队有意把类加载阶段中的**“通过一个类的全限定名来获取描述该类的二进制字节流”<strong>这个动作放到Java虚拟机</strong>外部<strong>去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为</strong>“类加载器”**（ClassLoader）</p> 
<p><strong>类与类加载器</strong></p> 
<p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p> 
<p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p> 
<table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table> 
<h4><a id="2_2355"></a>2.启动类加载器</h4> 
<p>Bootstrap ClassLoader</p> 
<p>可通过在控制台输入指令，使得类被启动类加器加载</p> 
<p>用 Bootstrap 类加载器加载类：</p> 
<pre><code>package cn.itcast.jvm.t3.load;
public class F {
static {
System.out.println("bootstrap F init");
}
}
</code></pre> 
<p>执行</p> 
<pre><code>package cn.itcast.jvm.t3.load;
public class Load5_1 {
public static void main(String[] args) throws ClassNotFoundException {
Class&lt;?&gt; aClass = Class.forName("cn.itcast.jvm.t3.load.F");
System.out.println(aClass.getClassLoader());
}
}
</code></pre> 
<p>输出</p> 
<pre><code>E:\git\jvm\out\production\jvm&gt;java -Xbootclasspath/a:. cn.itcast.jvm.t3.load.Load5
bootstrap F init
null
</code></pre> 
<ul><li>-Xbootclasspath 表示设置 bootclasspath</li><li>其中 /a:. 表示将当前目录追加至 bootclasspath 之后</li><li>可以用这个办法替换核心类 
  <ul><li>java -Xbootclasspath:</li><li>java -Xbootclasspath/a:&lt;追加路径&gt;</li><li>java -Xbootclasspath/p:&lt;追加路径&gt;</li></ul> </li></ul> 
<h4><a id="3_2399"></a>3.扩展类加载器</h4> 
<p>Extension ClassLoader</p> 
<p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。</p> 
<p>将代码打包放在JAVA_HOME/jre/lib/ext下，</p> 
<pre><code>package cn.itcast.jvm.t3.load;
public class G {
static {
System.out.println("ext G init");
}
}
</code></pre> 
<p>打包</p> 
<pre><code>E:\git\jvm\out\production\jvm&gt;jar -cvf my.jar cn/itcast/jvm/t3/load/G.class
已添加清单
正在添加: cn/itcast/jvm/t3/load/G.class(输入 = 481) (输出 = 322)(压缩了 33%)
</code></pre> 
<p>执行</p> 
<pre><code>package cn.itcast.jvm.t3.load;
public class Load5_1 {
public static void main(String[] args) throws ClassNotFoundException {
Class&lt;?&gt; aClass = Class.forName("cn.itcast.jvm.t3.load.F");
System.out.println(aClass.getClassLoader());
}
}
</code></pre> 
<p>输出</p> 
<pre><code>ext G init
sun.misc.Launcher$ExtClassLoader@29453f44
</code></pre> 
<h4><a id="4_2445"></a>4.应用程序类加载器</h4> 
<p>Application ClassLoader</p> 
<p>自己写的类都是由应用程序类加载器加载</p> 
<pre><code>Classs&lt;?&gt; aClass=Class.forName("cn.itcast.jvm.t3.load.F");
System.out.println(aClass.getClassLoader());
</code></pre> 
<h4><a id="5_2456"></a>5.双亲委派模式</h4> 
<h5><a id="_2458"></a>概念</h5> 
<p>指一个类在收到类加载请求后不会尝试自己加载这个类，而是把该类加载请求向上委派给其父类加载器去完成，其父类加载器在接收到该类加载请求后又会将其委派给自己的父类，以此类推，这样所有的类加载请求都被向上委派到启动类加载器中。若父类加载器在接收到类加载请求后发现自己也无法加载该类（通常原因是该类的Class文件在父类的类加载路径中不存在），则父类会将该信息反馈给子类并向下委派子类加载器加载该类，直到该类被成功加载，若找不到该类，则JVM会抛出ClassNotFoud异常。</p> 
<p>即调用类加载器ClassLoader 的 <strong>loadClass</strong> 方法时，查找类的规则</p> 
<p>loadClass源码</p> 
<pre><code>protected Class&lt;?&gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // 首先查找该类是否已经被该类加载器加载过了
        Class&lt;?&gt; c = findLoadedClass(name);
        //如果没有被加载过
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                //看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    //看是否被启动类加载器加载过
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
                //捕获异常，但不做任何处理
            }

            if (c == null) {
                //如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常
                //然后让应用类加载器去找classpath下找该类
                long t1 = System.nanoTime();
                c = findClass(name);

                // 记录时间
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
</code></pre> 
<h4><a id="6_2510"></a>6.线程上下文类加载器</h4> 
<p>默认使用应用程序类加载器</p> 
<h4><a id="7_2514"></a>7.自定义类加载器</h4> 
<h5><a id="1_2516"></a>1.使用场景</h5> 
<ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul> 
<h5><a id="2_2522"></a>2.步骤</h5> 
<ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法 
  <ul><li>不是重写loadClass方法，否则不会走双亲委派机制</li></ul> </li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul> 
<h5><a id="3_2531"></a>3.案例</h5> 
<pre><code>public class Load7 {
public static void main(String[] args) throws Exception {
MyClassLoader classLoader = new MyClassLoader();
Class&lt;?&gt; c1 = classLoader. loadClass( name: "MapImpl1");
Class&lt;?&gt; C2 = classLoader. loadClass( name: "MapImp11");
System. out. println(c1 == c2);
MyClassLoader classLoader2 = new MyClassLoader();
Class&lt;?&gt; C3 = classLoader2.loadClass( name: "MapImp11");
System. out. println(c1 == C3);
}
}
class MyClassLoader extends ClassLoader {
@Override. //. name. 就是类名称
protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
String path ="e:\\myclasspath\\"+name+".class" ;
try {
ByteArrayOutputStream OS = new ByteArray0utputStream( ); .
Files. copy(Paths . get(path), os);
//得到字节数组
byte[] bytes = os. toByteArray();
// byte[] -&gt; *.c1ass 数组编程字节码
return defineClass(name, bytes, of, 0,bytes.length);
} catch (IOException e) {
e. printStackTrace();
}
}
</code></pre> 
<h4><a id="8_2562"></a>8.破坏双亲委派模式</h4> 
<ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代 
  <ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul> </li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的 
  <ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul> </li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的 
  <ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul> </li></ul> 
<h3><a id="6_2571"></a>6.运行期优化</h3> 
<h4><a id="1_2573"></a>1.即时编译</h4> 
<h5><a id="1_2575"></a>1.分层编译</h5> 
<p>JVM 将执行状态分成了 5 个层次：</p> 
<ul><li>0层：(解释器)解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul> 
<p>profiling(分析) 是指在运行过程中收集一些程序执行状态，例如方法调用次数，循环的回边次数</p> 
<h5><a id="2JIT_2587"></a>2.既时编译器(JIT)与解释器的区别</h5> 
<ul><li><strong>解释器</strong> 
  <ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码解释为<strong>针对所有平台</strong>都<strong>通用</strong>的机器码</li></ul> </li><li><strong>即时编译器</strong> 
  <ul><li>将一些字节码<strong>编译</strong>为机器码，并存入Code Cache(代码缓存)，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，生成平台特定的机器码</li></ul> </li></ul> 
<p>大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行</p> 
<p>对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。</p> 
<p>执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p> 
<h5><a id="3_2602"></a>3.逃逸分析</h5> 
<p>java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p> 
<p>逃逸分析的 JVM 参数如下：</p> 
<ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul> 
<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p> 
<h5><a id="4_2614"></a>4.方法内联</h5> 
<h6><a id="1_2616"></a>1.<strong>内联函数</strong></h6> 
<p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p> 
<h6><a id="2JVM_2620"></a><strong>2.JVM内联函数</strong></h6> 
<p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的</p> 
<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p> 
<h6><a id="5_2626"></a>5.字段优化</h6> 
<h5><a id="2_2630"></a>2.反射优化</h5> 
<h2><a id="_2632"></a>五、内存模型</h2> 
<p>java 内存模型是Java Memory Model (JMM)的意思。</p> 
<h3><a id="1JAVAJMM_2638"></a>1.JAVA内存模型（JMM）</h3> 
<p>JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障</p> 
<p>JMM：<strong>屏蔽</strong>掉各种<strong>硬件</strong>和<strong>操作系统</strong>的<strong>内存访问差异</strong>，以实现让java程序在各种平台下都能达到<strong>一致性的内存访问</strong>结果。</p> 
<p><strong>JMM体现在以下几个方面</strong></p> 
<ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul> 
<h3><a id="2_2650"></a>2.原子性</h3> 
<p>指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着"同生共死"的感觉 。</p> 
<h4><a id="10_2654"></a>1.问题提出：结果不一定为0</h4> 
<pre><code>static int i = 0;
static Object obj = new Object();
public static void main(String[] args) throws InterruptedException {
Thread t1 = new Thread(() -&gt; {
for (int j = 0; j &lt; 5000; j++) {
i++;
}
});
Thread t2 = new Thread(() -&gt; {
for (int j = 0; j &lt; 5000; j++) {
i--;
}
});
t1.start();
t2.start();
t1.join();
t2.join();
System.out.println(i);
}
</code></pre> 
<p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p> 
<h4><a id="2_2680"></a>2.问题分析</h4> 
<p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作。</p> 
<p>例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p> 
<pre><code>getstatic   i // 获取静态变量i的值
iconst_ _1    //准备常量1
i add         //自增
gutstatic  i  //将修改后的值存入静态变量i
</code></pre> 
<p>而对应 i-- 也是类似：</p> 
<pre><code>getstatic   i // 获取静态变量i的值
iconst_ 1     //准备常量1
isub          //自减
putstatic   i // 将修改后的值存入静态变量i
</code></pre> 
<p>而Java的内存模型如下，完成静态变量的自增,自减需要在<strong>主存</strong>和<strong>线程内存</strong>中进行数据交换:<br> <img src="https://images2.imgbox.com/b3/7e/XMpnXnzf_o.png" alt="image-20210822110115976"></p> 
<p>如果是单线程回顺序执行（不会交错）没有出现问题<br> 下面是单线程的字节码</p> 
<pre><code>// 假设i的初始值为0
getstatic i // 线程1-获取静态变量i的值 线程内i=0
iconst_1 // 线程1-准备常量1
iadd // 线程1-自增 线程内i=1
putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1
getstatic i // 线程1-获取静态变量i的值 线程内i=1
iconst_1 // 线程1-准备常量1
isub // 线程1-自减 线程内i=0
putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=0
</code></pre> 
<p>如果是多线程则可能会出现交错运行：<br> 出现负数的情况：</p> 
<pre><code>// 假设i的初始值为0
getstatic i // 线程1-获取静态变量i的值 线程内i=0
getstatic i // 线程2-获取静态变量i的值 线程内i=0
iconst_1 // 线程1-准备常量1
iadd // 线程1-自增 线程内i=1
putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1
iconst_1 // 线程2-准备常量1
isub // 线程2-自减 线程内i=-1
putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1
</code></pre> 
<p>出现正数的情况</p> 
<pre><code>// 假设i的初始值为0
getstatic i // 线程1-获取静态变量i的值 线程内i=0
getstatic i // 线程2-获取静态变量i的值 线程内i=0
iconst_1 // 线程1-准备常量1
iadd // 线程1-自增 线程内i=1
iconst_1 // 线程2-准备常量1
isub // 线程2-自减 线程内i=-1
putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1
putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1
</code></pre> 
<h4><a id="3_2749"></a>3.解决方法</h4> 
<p>synchronized（同步关键字）</p> 
<p>语法</p> 
<pre><code>synchronized(对象){
	要作为原子操作的代码
}
</code></pre> 
<p>用synchronized解决并发问题</p> 
<pre><code>static int i = 0;
static Object obj = new Object();
public static void main(String[] args) throws InterruptedException {
Thread t1 = new Thread(() -&gt; {
for (int j = 0; j &lt; 5000; j++) {
synchronized (obj) {
i++;
}
}
});
Thread t2 = new Thread(() -&gt; {
for (int j = 0; j &lt; 5000; j++) {
synchronized (obj) {
i--;
}
}
});
t1.start();
t2.start();
t1.join();
t2.join();
System.out.println(i);
}
</code></pre> 
<h3><a id="3_2789"></a>3.可见性</h3> 
<h4><a id="1_2791"></a>1.问题提出：退不出的循环</h4> 
<p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止</p> 
<pre><code>static boolean run = true;
public static void main(String[] args) throws InterruptedException {
Thread t = new Thread(()-&gt;{
while(run){
// ....
}
});
t.start();
Thread.sleep(1000);		//这里停止的线程是主线程
run = false; // 线程t不会如预想的停下来
}
</code></pre> 
<h4><a id="2_2809"></a>2.问题分析</h4> 
<p>1.在初始状态，t线程刚开始从内存读取了run的值到工作内存。</p> 
<p><img src="https://images2.imgbox.com/e7/f5/unqthy3H_o.png" alt="image-20210822111802662"></p> 
<p>2.因为t线程要<strong>频繁</strong>从主内存中读取run的值，JIT（即时编译器）会将run的值缓存到自己工作内存的高速缓存中，减少对贮存中对run的访问，提高效率。<br> <img src="https://images2.imgbox.com/8b/e4/cbTRLyIO_o.png" alt="image-20210822112443534"></p> 
<p>3.1秒之后，main线程修改了run的值，并同步至主存，而t是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值。</p> 
<h4><a id="3_2820"></a>3.解决方法</h4> 
<p><strong>volatile</strong>(易变关键字)</p> 
<p>它可以用来修饰<strong>成员变量</strong>和静态成员变量，他可以<strong>避免线程从自己的工作缓存中查找变量的值</strong>，必须到<strong>主存</strong>中获取它的值，<strong>线程操作volatile变量都是直接操作主存</strong></p> 
<pre><code>volatile static boolean run = true;
public static void main(String[] args) throws InterruptedException {
Thread t = new Thread(()-&gt;{
while(run){
// ....
}
});
t.start();
Thread.sleep(1000);		//这里停止的线程是主线程
run = false; // 线程t不会如预想的停下来
}
</code></pre> 
<p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，<strong>一个线程对volatile变量的修改对另一个线程可见</strong>，<strong>不能保证原子性</strong>，仅用在一个写线程， 多个读线程的情况。</p> 
<p>synchronized语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized是属于<strong>重量级操作</strong>，性能相对更低。</p> 
<h3><a id="4_2844"></a>4.有序性</h3> 
<h4><a id="1_2846"></a>1.问题提出：诡异的结果？</h4> 
<pre><code>int num = 0;
boolean ready = false;
//线程1执行此方法
public void actor1(I_ _Result r) {
if(ready) {
r.r1 = num + num;
} else {
r.r1 = 1;
}
}
//线程2执行此方法
public void actor2(I_ _Result r) {
num = 2;
ready = true;
} 
</code></pre> 
<h4><a id="2_2866"></a>2.问题分析</h4> 
<p>执行结果有多少种？<br> <strong>情况1</strong>:线程1先执行,这时ready= false,所以进入else 分支结果为1。<br> <strong>情况2</strong>:线程2先执行num=2,但没来得及执行ready= true,线程1执行，还是进入else分支,结果为1。<br> <strong>情况3</strong>:线程2执行到ready= true,线程1执行，这回进入if分支，结果为4 (因为num已经执行过了)。<br> <strong>情况4</strong>:线程2执行ready=true，切换到线程1，进入if分支,相加为0,再切回线程2执行num= 2</p> 
<h4><a id="3_2874"></a>3.解决方法</h4> 
<p>volatile 修饰的变量，可以禁用<strong>指令重排</strong></p> 
<pre><code>int num = 0;
volatile boolean ready = false;
//线程1执行此方法
public void actor1(I_ _Result r) {
if(ready) {
r.r1 = num + num;
} else {
r.r1 = 1;
}
}
//线程2执行此方法
public void actor2(I_ _Result r) {
num = 2;
ready = true;
} 
</code></pre> 
<h4><a id="4_2896"></a>4.有序性理解</h4> 
<h5><a id="_2898"></a>指令重排</h5> 
<ul><li>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></li></ul> 
<pre><code>static int i;
static int j;
// 在某个线程内执行如下赋值操作
i = ...; // 较为耗时的操作
j = ...;
</code></pre> 
<p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时， 既可以是</p> 
<pre><code>i = ...; // 较为耗时的操作
j = ...;
</code></pre> 
<p>也可以是</p> 
<pre><code>j = ...;
i = ...; // 较为耗时的操作
</code></pre> 
<p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。</p> 
<h4><a id="5doublechecked_locking__2926"></a>5.double-checked locking 模式实现单例</h4> 
<p>例如著名的 double-checked locking 模式实现单例</p> 
<pre><code>public final class Singleton {
private Singleton() { }
private static Singleton INSTANCE = null;
public static Singleton getInstance() {
// 实例没创建，才会进入内部的 synchronized代码块
if (INSTANCE == null) {
	synchronized (Singleton.class) {
	// 也许有其它线程已经创建实例，所以再判断一次
		if (INSTANCE == null) {
			INSTANCE = new Singleton();
		}
	}
}
return INSTANCE;
}
}
</code></pre> 
<p>以上的实现特点是：</p> 
<ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li></ul> 
<p>但在多线程环境下，上面的代码是有问题的， INSTANCE = new Singleton() 对应的字节码为：</p> 
<pre><code>0: new #2 // class cn/itcast/jvm/t4/Singleton
3: dup
4: invokespecial #3 // Method "&lt;init&gt;":()V
7: putstatic #4 // Field INSTANCE:Lcn/itcast/jvm/t4/Singleton;
</code></pre> 
<p>其中4 7两步的顺序不是固定的,也许jvm会优化为:先将引用地址赋值给INSTANCE量后,再执行构造方法，如果两个线程tl, t2按如”下时间序列执行:</p> 
<pre><code>时间1 t1 线程执行到INSTANCE = new Singleton();
时间2 t1 线程分配空间，为Singleton对象生成 了引用地址(0处)
时间3 t1 线程将引用地址赋值给INSTANCE, 这时INSTANCE != null (7处)
时间4
t2线程进入getInstance()方法，发现INSTANCE != null (synchronized块外) ，直接返回
INSTANCE
时间5 t1 线程执行Singleton的构造方法(4处)
</code></pre> 
<p>这时tl还未完全将构造方法执行完毕,如果在构造方法中要执行很多初始化操作，那么t2拿到的是将是一个未初始化完毕的单例</p> 
<p>对INSTANCE使用volatile修饰即可，可以禁用指令重排，但要注意在<strong>JDK 5以上</strong>的版本的volatile才会真正有效</p> 
<pre><code>public final class Singleton {
private Singleton() { }

private  volatile static Singleton INSTANCE = null;
public static Singleton getInstance() {
	// 实例没创建，才会进入内部的 synchronized代码块
	if (INSTANCE == null) {
		synchronized (Singleton.class) {
		// 也许有其它线程已经创建实例，所以再判断一次
			if (INSTANCE == null) {
				INSTANCE = new Singleton();
			}
		}
	}
	return INSTANCE;
}
}
</code></pre> 
<h3><a id="5happensbefore_2999"></a>5.happens-before</h3> 
<p>happens-before 关系是用来描述两个操作的内存可见性的。如果操作 X happens-before 操作 Y，那么 X 的结果对于 Y 可见。<br> Java 内存模型底层是通过内存屏障（memory barrier）来禁止重排序的。</p> 
<p>happens-before规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结:</p> 
<ul><li>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</li></ul> 
<pre><code>volatile static int x;
new Thread(()-&gt;{
x = 10;
},"t1").start();
new Thread(()-&gt;{
System.out.println(x);
},"t2").start();
</code></pre> 
<ul><li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li></ul> 
<pre><code>static int x;
Thread t1 = new Thread(()-&gt;{
x = 10;
},"t1");
t1.start();
t1.join();   //mian线程会等待t1线程运行完再继续运行
System.out.println(x);
</code></pre> 
<ul><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通 过t2.interrupted 或 t2.isInterrupted）</li></ul> 
<pre><code>static int x;
public static void main(String[] args) {
Thread t2 = new Thread(()-&gt;{
while(true) {
if(Thread.currentThread().isInterrupted()) {
System.out.println(x);
break;
}
}
},"t2");
t2.start();
new Thread(()-&gt;{
try {
Thread.sleep(1000);
} catch (InterruptedException e) {
e.printStackTrace();
}
x = 10;
t2.interrupt();
},"t1").start();
while(!t2.isInterrupted()) {
Thread.yield();
}
System.out.println(x);

</code></pre> 
<h3><a id="6CAS_3060"></a>6.CAS与原子类</h3> 
<h4><a id="1CAS_3062"></a>1.CAS</h4> 
<p>CAS 即 Compare and Swap ，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执 行 +1 操作：</p> 
<p>对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B；如果不相等，则什么都不做。</p> 
<pre><code>// 需要不断尝试
while(true) {
int 旧值 = 共享变量 ; // 比如拿到了当前值 0
int 结果 = 旧值 + 1; // 在旧值 0 的基础上增加 1 ，正确结果是 1
/*
这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候
compareAndSwap 返回 false，重新尝试，直到：
compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰
*/
if( compareAndSwap ( 旧值, 结果 )) {
// 成功，退出循环
}
</code></pre> 
<p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于<strong>竞争不激烈、多核 CPU</strong> 的场景下。</p> 
<ul><li>因为没有使用 synchronized，所以<strong>线程不会陷入阻塞</strong>，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul> 
<p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令，下面是直接使用 Unsafe 对象进 行线程安全保护的一个例子</p> 
<pre><code>import sun.misc.Unsafe;
import java.lang.reflect.Field;
public class TestCAS {
public static void main(String[] args) throws InterruptedException {
DataContainer dc = new DataContainer();
int count = 5;
dc.increase();
}
});
t1.start();
t1.join();
System.out.println(dc.getData());
}
}
class DataContainer {
private volatile int data;
static final Unsafe unsafe;
static final long DATA_OFFSET;
static {
try {
// Unsafe 对象不能直接调用，只能通过反射获得
Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
theUnsafe.setAccessible(true);
unsafe = (Unsafe) theUnsafe.get(null);
} catch (NoSuchFieldException | IllegalAccessException e) {
throw new Error(e);
}
try {
// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性
DATA_OFFSET =
unsafe.objectFieldOffset(DataContainer.class.getDeclaredField("data"));
} catch (NoSuchFieldException e) {
throw new Error(e);
}
}
public void increase() {
int oldValue;
while(true) {
// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解
oldValue = data;
// cas 尝试修改 data 为 旧值 + 1，如果期间旧值被别的线程改了，返回 false
if (unsafe.compareAndSwapInt(this, DATA_OFFSET, oldValue, oldValue +
1)) {
return;
}
}
}
public void decrease() {
int oldValue;
while(true) {
oldValue = data;
if (unsafe.compareAndSwapInt(this, DATA_OFFSET, oldValue, oldValue -
1)) {
return;
}
}
}
</code></pre> 
<h4><a id="2_3150"></a>2.乐观锁与悲观锁</h4> 
<ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系， 我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁 你们都别想改，我改完了解开锁，你们才有机会。</li></ul> 
<h4><a id="3_3155"></a>3.原子操作类</h4> 
<p>juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、 AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的。</p> 
<p>可以使用 AtomicInteger 改写之前的例子：</p> 
<pre><code>// 创建原子整数对象
private static AtomicInteger i = new AtomicInteger(0);
public static void main(String[] args) throws InterruptedException {
Thread t1 = new Thread(() -&gt; {
for (int j = 0; j &lt; 5000; j++) {
i.getAndIncrement(); // 获取并且自增 i++
// i.incrementAndGet(); // 自增并且获取 ++i
}
});
i.getAndDecrement(); // 获取并且自减 i--
}
});
t1.start();
t2.start();
t1.join();
t2.join();
System.out.println(i);
}
</code></pre> 
<h3><a id="7synchronized_3182"></a>7.synchronized优化</h3> 
<p>Java HotSpot 虚拟机中，每个对象都有对象头(包括 class 指针和 Mark Word )。Mark Word(8个字节) 平常存储这个对象的 哈希码、分代年龄，当加锁时，这些信息根据情况被替换为标记为、线程锁记录指针、重量级锁指针、重量级锁指针、线程ID 等内容。</p> 
<h4><a id="1_3186"></a>1.轻量级锁</h4> 
<p>每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p> 
<pre><code class="prism language-java"><span class="token keyword">static</span> <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 同步块 A</span>
        <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 同步块 B</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<table><thead><tr><th align="center">线程1</th><th>对象 Mark Word</th><th>线程2</th></tr></thead><tbody><tr><td align="center">访问同步代码块A，把Mark信息复制到线程1的锁记录</td><td>01（无锁）</td><td>-</td></tr><tr><td align="center">CAS修改Mark为线程1的锁记录地址</td><td>01（无锁）</td><td>-</td></tr><tr><td align="center">成功(加锁)</td><td>00（轻量锁）线程1的锁记录地址</td><td>-</td></tr><tr><td align="center">执行同步代码块A</td><td>00（轻量锁）线程1的锁记录地址</td><td>-</td></tr><tr><td align="center">访问同步代码快B，吧Mark复制到线程1的锁记录</td><td>00（轻量锁）线程1的锁记录地址</td><td>-</td></tr><tr><td align="center">CAS修改Mark为线程1锁记录地址</td><td>00（轻量锁）线程1的锁记录地址</td><td>-</td></tr><tr><td align="center">失败(发现是自己的锁)</td><td>00（轻量锁）线程1的锁记录地址</td><td>-</td></tr><tr><td align="center">锁重入</td><td>00（轻量锁）线程1的锁记录地址</td><td>-</td></tr><tr><td align="center">执行同步块B</td><td>00（轻量锁）线程1的锁记录地址</td><td>-</td></tr><tr><td align="center">同步块B执行完毕</td><td>00（轻量锁）线程1的锁记录地址</td><td>-</td></tr><tr><td align="center">同步块A执行完毕</td><td>00（轻量锁）线程1的锁记录地址</td><td>-</td></tr><tr><td align="center">成功(解锁)</td><td>01（无锁）</td><td>-</td></tr><tr><td align="center">-</td><td>01（无锁）</td><td>访问同步块A，把Mark复制到线程2的锁记录</td></tr><tr><td align="center">-</td><td>01（无锁）</td><td>CAS修改Mark为线程2锁记录地址</td></tr><tr><td align="center">-</td><td>00（轻量锁）线程2的锁记录地址</td><td>成功(加锁)</td></tr><tr><td align="center">-</td><td>…</td><td>…</td></tr></tbody></table> 
<h4><a id="2_3226"></a>2.膨胀锁</h4> 
<p>如果再尝试加轻量级锁的过程中，CAS操作无法成功，这种情况就是有其它线程为此对象加上了轻量级锁(有竞争)，这是需要进行锁膨胀，将轻量级锁变为重量级锁。</p> 
<pre><code class="prism language-java"><span class="token keyword">static</span> <span class="token class-name">Object</span> obj<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">synchronized</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 同步块</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<table><thead><tr><th>线程 1</th><th>对象 Mark</th><th>线程 2</th></tr></thead><tbody><tr><td>把 Mark 复制到线程 1 的锁记录</td><td>01（无锁）</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>01（无锁）</td><td>-</td></tr><tr><td>成功（加锁）</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>访问同步块，把 Mark 复制 到线程 2</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>CAS 修改 Mark 为线程 2 锁 记录地址</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>失败（发现别人已经占了 锁）</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>CAS 修改 Mark 为重量锁</td></tr><tr><td>执行同步块</td><td>10（重量锁(monitorenter)）重量锁指针</td><td>阻塞中</td></tr><tr><td>行完毕</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>失败（解锁）</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>释放重量锁，唤起阻塞线程竞争(monitorexit)</td><td>01（无锁）</td><td>阻塞中</td></tr><tr><td>-</td><td>10（重量锁）</td><td>竞争重量锁</td></tr><tr><td>-</td><td>10（重量锁）</td><td>成功（加锁）</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table> 
<h4><a id="3_3257"></a>3.重量锁</h4> 
<p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自选成功(即这时候持锁线程已经退出同步块，释放了锁)，这时当前线程就可以避免阻塞。</p> 
<p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能 性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p> 
<p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等 待时间长了划算）</p> 
<p>Java 7 之后不能控制是否开启自旋功能</p> 
<p><strong>自旋重试成功的情况</strong></p> 
<table><thead><tr><th>线程 1 （cpu 1 上）</th><th>对象 Mark</th><th>线程 2 （cpu 2 上）</th></tr></thead><tbody><tr><td>-</td><td>10（重量锁）</td><td>-</td></tr><tr><td>访问同步块，获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行完毕</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>成功（解锁）</td><td>01（无锁）</td><td>自旋重试</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>成功（加锁）</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>执行同步块</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table> 
<p><strong>自旋重试失败的情况</strong></p> 
<table><thead><tr><th>线程 1 （cpu 1 上）</th><th>对象 Mark</th><th>线程 2 （cpu 2 上）</th></tr></thead><tbody><tr><td>-</td><td>10（重量锁）</td><td>-</td></tr><tr><td>访问同步块，获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>阻塞</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table> 
<h4><a id="4_3300"></a>4.偏向锁</h4> 
<p>轻量级锁在没有竞争时(就自己这个线程)， 每次重入仍然需要执行CAS操作。Java 6中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程Id是自己的就表示没有竞争，不用重新CAS.</p> 
<ul><li>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停(STW)</li><li>访问对象的hashCode也会撤销偏向锁</li><li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2,重置对象的Thread ID</li><li>撤销偏向和重偏向都是批量进行的，以类为单位</li><li>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li><li>可以主动使用-XX:-UseBiasedL ocking禁用偏向锁</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">static</span> <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 同步块 A</span>
		<span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 同步块 B</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li></ul> 
<pre><code class="prism language-java"><span class="token keyword">static</span> <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 同步块 A</span>
		<span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 同步块 B</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<table><thead><tr><th>线程 1</th><th>对象 Mark</th></tr></thead><tbody><tr><td>访问同步块 A，检查 Mark 中是否有线程 ID</td><td>执行完毕</td></tr><tr><td>尝试加偏向锁</td><td>101（无锁可偏向）对象 hashCod</td></tr><tr><td>成功</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行同步块 A</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>访问同步块 B，检查 Mark 中是否有线程 ID</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>是自己的线程 ID，锁是自己的，无需做更多操作</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行同步块 B</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行完毕</td><td>101（无锁可偏向）对象 hashCode</td></tr></tbody></table> 
<h4><a id="5_3354"></a>5.其他优化</h4> 
<h5><a id="1_3356"></a>1.减少上锁的时间</h5> 
<p>同步代码块中尽量短</p> 
<h5><a id="2_3360"></a>2.减少锁的粒度</h5> 
<p>将一个锁拆分为多个所提高并发度，例如：</p> 
<ul><li>ConcurrentHashMap</li><li>LongAdder分为base和cells 两部分。没有并发争用的时候或者是cells数组正在初始化的时候，会使用CAS来累加值到base；有并发争用，会初始化cells数组，数组有多少个cell,就允许有多少线程并行修改，最后将数组中每个cell累加，再加上base就是最终的值</li><li>LinkedBlockingQueue入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高</li></ul> 
<h5><a id="3_3368"></a>3.锁粗化</h5> 
<p>多次循环进入同步块不如同步块内多次循环 另外 JVM 可能会做如下优化，把多次 append 的加锁操作 粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p> 
<pre><code class="prism language-java"><span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
``````java
<span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="4_3378"></a>4.锁消除</h5> 
<p>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</p> 
<h5><a id="5_3382"></a>5.读写分离</h5> 
<p>CopyOnWriteArrayList ConyOnWriteSet</p> 
<p>参考：<br> https://wiki.openjdk.java.net/display/HotSpot/Synchronization<br> http://luojinping.com/2015/07/09/java锁优化/<br> https://www.infoq.cn/article/java-se-16-synchronized<br> https://www.jianshu.com/p/9932047a89be<br> https://www.cnblogs.com/sheeva/p/6366782.html<br> https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3fa198d5b3047fa5f1498b7540e1312d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基础模型量化学习扩展仓库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5402c245a93885a6785c644d21fc254d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《计算机网络：自顶向下方法》读书笔记 2：应用层和运输层</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>