<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法笔记（二）-快速排序，桶排序 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法笔记（二）-快速排序，桶排序" />
<meta property="og:description" content="目录 荷兰国旗问题快速排序经典快排荷兰国旗问题改进快排随机快排 堆排序什么是堆如何建立大根堆？堆应用（数据流的中位数）堆排序 荷兰国旗问题 问题一：
问题二：荷兰国旗问题
快速排序 经典快排 荷兰国旗问题改进快排 代码如下：同样为递归过程。只用两个变量，最后交换最后一个数和more位置即可，这样会少用一个变量（炫技）
经典快排一次只搞定一个位置的数，容易出现比较极端的情况，复杂度退化为O(N2)。
而荷兰国旗改进的快排一次能搞定所有=x的数，所以改进的快排更快。
如果每次都能刚好找准位置==区域在正中心，那么复杂度为O(N*logN)。
随机快排 因此引入随机快排：
随机找变量P，和最后一个位置交换，以最后一个位置为标志开始划分。
使用长期期望的方式来算出复杂度（涵盖率）。
停留在每个位置的概率相同，计算得出长期期望的复杂度O(N*logN)。因此随机快排好。
绕过数据状况带过来的影响：
运用随机打乱数据原本状况哈希函数打乱 随机快排是最常用的排序
基本上能用O(N*logN)的算法就用快排：代码简单，常数项少，额外空间复杂度O(logN)。mergesort还有数组的拷贝，输在常数项，额外空间复杂度O(N)。
空间复杂度O(logN)：
记录断点所需要的空间，只有记录下来了才能知道下一个划分区域在哪里。在随机快排中也是概率问题，如果不用随机快排，数据状况差的情况下空间复杂度到O(N)。
工程上不会有递归，都是迭代版本。工程上准备递归函数代价比较高，会记录有关无关的所有信息，常数时间大，而且栈多了不安全。所以基本上都要改为非递归版本。
堆排序 什么是堆 堆：完全二叉树，满二叉树属于完全二叉树。新的一层从左往右依次补齐，完全二叉树。
堆在实际中可用数组实现。
一个数组可以理解成为一颗完全二叉树。
左右孩子节点位置和父节点关系，数值计算，可以数组结构-&gt;完全二叉树。脑补二叉树相当于，实际上还是数组。对于零节点，其父节点是其本身。
堆就是完全二叉树
大根堆：
在这颗二叉树的任意子树中，最大值是其头部。
小根堆：
在这颗二叉树的任意子树中，最小值是其头部。
如何建立大根堆？ 每次加入一个数，该数如果大于父节点，则往上换，不断进行，从而将整个数组调整为大根堆。再重复加入数组中的数。代码实现：
建立大根堆的时间复杂度O(N)，二叉树高度（满二叉树）。
假设数组中有一个值变化了，如何重新调整为大根堆？
heapify，heapsize就比较灵活，可以面对任意大小的堆
不断下沉
堆应用（数据流的中位数） 当一个流，不断吐出数，要求时刻返回吐出序列的中位数。如果常规方法会非常耗费时间，每次都要排序。
堆顶弹出，给小根堆
减堆操作，弹出堆顶，首先和堆的最后一个数交换，然后heapsize - 1，再经过heapify，重新调整为大根堆。
保证较小的N/2个数在大根堆，较大的N/2个数在小根堆。小于等于大根堆的堆顶，则放入大根堆，如果此时跟小根堆的个数差值大于1，则从堆顶弹出，同理处理小根堆。
优先队列–堆，一个高度调整完就结束了，每次弹出，插入都只要承担logN的代价，这个非常小。
堆排序 利用堆结构完成的排序。
堆顶和现在堆最后一个数做交换，heapsize减一，重新调整为大根堆，循环该过程，直到所有数填完当前堆的最后一个位置，那么该数组整体有序。
代码如下：
非常重要，几乎所有贪心都用这个！ 堆排序很重要，堆更重要！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cba7a687ed41050a6f89379ef25b534e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-13T16:18:51+08:00" />
<meta property="article:modified_time" content="2021-08-13T16:18:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法笔记（二）-快速排序，桶排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">荷兰国旗问题</a></li><li><a href="#_9" rel="nofollow">快速排序</a></li><li><ul><li><a href="#_10" rel="nofollow">经典快排</a></li><li><a href="#_13" rel="nofollow">荷兰国旗问题改进快排</a></li><li><a href="#_23" rel="nofollow">随机快排</a></li></ul> 
   </li><li><a href="#_40" rel="nofollow">堆排序</a></li><li><ul><li><a href="#_41" rel="nofollow">什么是堆</a></li><li><a href="#_55" rel="nofollow">如何建立大根堆？</a></li><li><a href="#_65" rel="nofollow">堆应用（数据流的中位数）</a></li><li><a href="#_74" rel="nofollow">堆排序</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>荷兰国旗问题</h3> 
<p><img src="https://images2.imgbox.com/d5/d3/wtdHe2l3_o.png" alt="在这里插入图片描述"><br> 问题一：<br> <img src="https://images2.imgbox.com/25/3b/RwZo4TtW_o.png" alt="在这里插入图片描述"><br> 问题二：荷兰国旗问题<br> <img src="https://images2.imgbox.com/11/4c/IatIDsTB_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/80/aa/CtGNrz2U_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_9"></a>快速排序</h3> 
<h4><a id="_10"></a>经典快排</h4> 
<p><img src="https://images2.imgbox.com/f7/0b/MR6VJioI_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_13"></a>荷兰国旗问题改进快排</h4> 
<p><img src="https://images2.imgbox.com/ad/ad/xHJuZkaN_o.png" alt="在这里插入图片描述"><br> 代码如下：同样为递归过程。只用两个变量，最后交换最后一个数和more位置即可，这样会少用一个变量（炫技）<br> <img src="https://images2.imgbox.com/c0/ed/wrBAjMA9_o.png" alt="在这里插入图片描述"><br> 经典快排一次只搞定一个位置的数，容易出现比较极端的情况，复杂度退化为O(N<sup>2</sup>)。<br> <img src="https://images2.imgbox.com/2d/00/nhAKlX5t_o.png" alt="在这里插入图片描述"><br> 而荷兰国旗改进的快排一次能搞定所有=x的数，所以改进的快排更快。<br> <img src="https://images2.imgbox.com/ce/e7/PNTRymvK_o.png" alt="在这里插入图片描述"><br> 如果每次都能刚好找准位置==区域在正中心，那么复杂度为O(N*logN)。<br> <img src="https://images2.imgbox.com/04/a7/fADUlfas_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_23"></a>随机快排</h4> 
<p>因此引入随机快排：<br> 随机找变量P，和最后一个位置交换，以最后一个位置为标志开始划分。<br> 使用长期期望的方式来算出复杂度（涵盖率）。<br> 停留在每个位置的概率相同，计算得出长期期望的复杂度O(N*logN)。因此随机快排好。<br> <img src="https://images2.imgbox.com/ea/63/0tIVlTxt_o.png" alt="在这里插入图片描述"></p> 
<p><strong>绕过数据状况带过来的影响</strong>：</p> 
<ol><li>运用随机打乱数据原本状况</li><li>哈希函数打乱</li></ol> 
<p><strong>随机快排是最常用的排序</strong><br> 基本上能用O(N*logN)的算法就用快排：代码简单，常数项少，额外空间复杂度O(logN)。mergesort还有数组的拷贝，输在常数项，额外空间复杂度O(N)。<br> 空间复杂度O(logN)：<br> 记录断点所需要的空间，只有记录下来了才能知道下一个划分区域在哪里。在随机快排中也是概率问题，如果不用随机快排，数据状况差的情况下空间复杂度到O(N)。<br> <img src="https://images2.imgbox.com/47/16/BrdyX8wv_o.png" alt="在这里插入图片描述"><br> 工程上不会有递归，都是迭代版本。工程上准备递归函数代价比较高，会记录有关无关的所有信息，常数时间大，而且栈多了不安全。所以基本上都要改为非递归版本。</p> 
<h3><a id="_40"></a>堆排序</h3> 
<h4><a id="_41"></a>什么是堆</h4> 
<p><img src="https://images2.imgbox.com/49/45/S9mnxVzY_o.png" alt="在这里插入图片描述"><br> 堆：完全二叉树，满二叉树属于完全二叉树。新的一层从左往右依次补齐，完全二叉树。<br> 堆在实际中可用数组实现。<br> 一个数组可以理解成为一颗完全二叉树。<br> <img src="https://images2.imgbox.com/a5/8d/x8tGICfd_o.png" alt="在这里插入图片描述"><br> 左右孩子节点位置和父节点关系，数值计算，可以数组结构-&gt;完全二叉树。脑补二叉树相当于，实际上还是数组。对于零节点，其父节点是其本身。<br> <img src="https://images2.imgbox.com/69/e3/394p00pX_o.png" alt="在这里插入图片描述"><br> <strong>堆就是完全二叉树</strong><br> <strong>大根堆：</strong><br> <strong>在这颗二叉树的任意子树中，最大值是其头部。</strong><br> <strong>小根堆：</strong><br> <strong>在这颗二叉树的任意子树中，最小值是其头部。</strong></p> 
<h4><a id="_55"></a>如何建立大根堆？</h4> 
<p><img src="https://images2.imgbox.com/d9/47/9613aqAE_o.png" alt="在这里插入图片描述"><br> 每次加入一个数，该数如果大于父节点，则往上换，不断进行，从而将整个数组调整为大根堆。再重复加入数组中的数。代码实现：<br> <img src="https://images2.imgbox.com/0b/e4/Ewo7RwkD_o.png" alt="在这里插入图片描述"><br> 建立大根堆的时间复杂度O(N)，二叉树高度（满二叉树）。<br> <img src="https://images2.imgbox.com/b2/44/2Ahhpuw4_o.png" alt="在这里插入图片描述"><br> 假设数组中有一个值变化了，如何重新调整为大根堆？<br> heapify，heapsize就比较灵活，可以面对任意大小的堆<br> <img src="https://images2.imgbox.com/20/58/11557DQw_o.png" alt="在这里插入图片描述"><br> 不断下沉</p> 
<h4><a id="_65"></a>堆应用（数据流的中位数）</h4> 
<p>当一个流，不断吐出数，要求时刻返回吐出序列的中位数。如果常规方法会非常耗费时间，每次都要排序。<br> 堆顶弹出，给小根堆<br> <img src="https://images2.imgbox.com/67/0a/asuf3cnG_o.png" alt="在这里插入图片描述"><br> 减堆操作，弹出堆顶，首先和堆的最后一个数交换，然后heapsize - 1，再经过heapify，重新调整为大根堆。<br> <img src="https://images2.imgbox.com/96/18/38N9rRtr_o.png" alt="在这里插入图片描述"><br> 保证较小的N/2个数在大根堆，较大的N/2个数在小根堆。小于等于大根堆的堆顶，则放入大根堆，如果此时跟小根堆的个数差值大于1，则从堆顶弹出，同理处理小根堆。<br> <img src="https://images2.imgbox.com/cd/50/S2Szle6W_o.png" alt="在这里插入图片描述"><br> 优先队列–堆，一个高度调整完就结束了，每次弹出，插入都只要承担logN的代价，这个非常小。</p> 
<h4><a id="_74"></a>堆排序</h4> 
<p>利用堆结构完成的排序。<br> 堆顶和现在堆最后一个数做交换，heapsize减一，重新调整为大根堆，循环该过程，直到所有数填完当前堆的最后一个位置，那么该数组整体有序。<br> 代码如下：<br> <img src="https://images2.imgbox.com/da/d9/MbHP5ap0_o.png" alt="在这里插入图片描述"><br> <strong>非常重要，几乎所有贪心都用这个！</strong> 堆排序很重要，堆更重要！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cbb59a52043002693b66c47fbe6b352f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">文件服务器cpu内存设置,服务器内存配置于cpu的关系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b9f6a9b05535a9632967cd3a29af384/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">虚拟化服务器类型,虚拟化服务器类型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>