<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>探索异步交互：JavaScript AJAX 的全面指南 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="探索异步交互：JavaScript AJAX 的全面指南" />
<meta property="og:description" content="​🌈个人主页：前端青山
🔥系列专栏：JavaScript篇
🔖人终将被年少不可得之物困其一生
依旧青山,本期给大家带来JavaScript篇专栏内容:JavaScript-AjAx
目录
AJAX
AJAX 的优势
AJAX 的使用
创建一个 ajax 对象
配置链接信息
发送请求
一个基本的 ajax 请求
ajax 状态码
readyStateChange
responseText
ajax的工作原理
使用 ajax 发送请求时携带参数
发送一个带有参数的 get 请求
发送一个带有参数的 post 请求
get与post的区别？
get
post
封装 AJAX
确定一下使用的方式
Promise
什么是Promise?
promise使用语法
Promise原型对象的方法
处理多个异步
Promise的静态方法
Promise中的三种状态
ASYNC/AWAIT
async 和 await 关键字
async 关键字的用法
await 关键字的用法
缺点
解决方案
AJAX ajax 全名 async javascript and XML
是前后台交互的能力
也就是我们客户端给服务端发送消息的工具，以及接受响应的工具
是一个 默认异步 执行机制的功能
XML与JSON：都是可以跨平台、跨语言的一种数据格式。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5f6cfa4276f28bff3cbe9c7907e76de9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-08T13:30:00+08:00" />
<meta property="article:modified_time" content="2023-12-08T13:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">探索异步交互：JavaScript AJAX 的全面指南</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="199" src="https://images2.imgbox.com/2d/39/qkjlZHCV_o.png" width="354"></p> 
<p style="text-align:center;">​🌈个人主页：<a href="https://blog.csdn.net/2302_76329106?spm=1000.2115.3001.5343" title="前端青山">前端青山</a><br> 🔥系列专栏：JavaScript篇<br> 🔖<span style="color:#79c6cd;">人终将被年少不可得之物困其一生</span></p> 
<blockquote> 
 <p>依旧<span style="color:#79c6cd;">青山</span>,本期给大家带来JavaScript篇专栏内容:JavaScript-AjAx</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="AJAX-toc" style="margin-left:0px;"><a href="#AJAX" rel="nofollow">AJAX</a></p> 
<p id="AJAX%20%E7%9A%84%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#AJAX%20%E7%9A%84%E4%BC%98%E5%8A%BF" rel="nofollow">AJAX 的优势</a></p> 
<p id="AJAX%20%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#AJAX%20%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">AJAX 的使用</a></p> 
<p id="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20ajax%20%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20ajax%20%E5%AF%B9%E8%B1%A1" rel="nofollow">创建一个 ajax 对象</a></p> 
<p id="%E9%85%8D%E7%BD%AE%E9%93%BE%E6%8E%A5%E4%BF%A1%E6%81%AF-toc" style="margin-left:80px;"><a href="#%E9%85%8D%E7%BD%AE%E9%93%BE%E6%8E%A5%E4%BF%A1%E6%81%AF" rel="nofollow">配置链接信息</a></p> 
<p id="%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82-toc" style="margin-left:80px;"><a href="#%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82" rel="nofollow">发送请求</a></p> 
<p id="%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%20ajax%20%E8%AF%B7%E6%B1%82-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%20ajax%20%E8%AF%B7%E6%B1%82" rel="nofollow">一个基本的 ajax 请求</a></p> 
<p id="ajax%20%E7%8A%B6%E6%80%81%E7%A0%81-toc" style="margin-left:80px;"><a href="#ajax%20%E7%8A%B6%E6%80%81%E7%A0%81" rel="nofollow">ajax 状态码</a></p> 
<p id="readyStateChange-toc" style="margin-left:80px;"><a href="#readyStateChange" rel="nofollow">readyStateChange</a></p> 
<p id="responseText-toc" style="margin-left:80px;"><a href="#responseText" rel="nofollow">responseText</a></p> 
<p id="ajax%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#ajax%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">ajax的工作原理</a></p> 
<p id="%E4%BD%BF%E7%94%A8%20ajax%20%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%97%B6%E6%90%BA%E5%B8%A6%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E4%BD%BF%E7%94%A8%20ajax%20%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%97%B6%E6%90%BA%E5%B8%A6%E5%8F%82%E6%95%B0" rel="nofollow">使用 ajax 发送请求时携带参数</a></p> 
<p id="%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%20get%20%E8%AF%B7%E6%B1%82-toc" style="margin-left:80px;"><a href="#%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%20get%20%E8%AF%B7%E6%B1%82" rel="nofollow">发送一个带有参数的 get 请求</a></p> 
<p id="%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%20post%20%E8%AF%B7%E6%B1%82-toc" style="margin-left:80px;"><a href="#%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%20post%20%E8%AF%B7%E6%B1%82" rel="nofollow">发送一个带有参数的 post 请求</a></p> 
<p id="get%E4%B8%8Epost%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:0px;"><a href="#get%E4%B8%8Epost%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">get与post的区别？</a></p> 
<p id="get-toc" style="margin-left:40px;"><a href="#get" rel="nofollow">get</a></p> 
<p id="post-toc" style="margin-left:40px;"><a href="#post" rel="nofollow">post</a></p> 
<p id="%E5%B0%81%E8%A3%85%20AJAX-toc" style="margin-left:0px;"><a href="#%E5%B0%81%E8%A3%85%20AJAX" rel="nofollow">封装 AJAX</a></p> 
<p id="%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F" rel="nofollow">确定一下使用的方式</a></p> 
<p id="Promise-toc" style="margin-left:0px;"><a href="#Promise" rel="nofollow">Promise</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AFPromise%3F-toc" style="margin-left:0px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AFPromise%3F" rel="nofollow">什么是Promise?</a></p> 
<p id="promise%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95-toc" style="margin-left:0px;"><a href="#promise%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95" rel="nofollow">promise使用语法</a></p> 
<p id="Promise%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#Promise%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">Promise原型对象的方法</a></p> 
<p id="%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5-toc" style="margin-left:0px;"><a href="#%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5" rel="nofollow">处理多个异步</a></p> 
<p id="Promise%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#Promise%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" rel="nofollow">Promise的静态方法</a></p> 
<p id="Promise%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81-toc" style="margin-left:0px;"><a href="#Promise%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81" rel="nofollow">Promise中的三种状态</a></p> 
<p id="ASYNC%2FAWAIT-toc" style="margin-left:0px;"><a href="#ASYNC%2FAWAIT" rel="nofollow">ASYNC/AWAIT</a></p> 
<p id="async%20%E5%92%8C%20await%20%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px;"><a href="#async%20%E5%92%8C%20await%20%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">async 和 await 关键字</a></p> 
<p id="async%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#async%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95" rel="nofollow">async 关键字的用法</a></p> 
<p id="await%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#await%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95" rel="nofollow">await 关键字的用法</a></p> 
<p id="%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E7%BC%BA%E7%82%B9" rel="nofollow">缺点</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" rel="nofollow">解决方案</a></p> 
<h2 id="AJAX">AJAX</h2> 
<ul><li> <p><code>ajax</code> 全名 <code>async javascript and XML</code></p> </li><li> <p>是前后台交互的能力</p> </li><li> <p>也就是我们客户端给服务端发送消息的工具，以及接受响应的工具</p> </li><li> <p>是一个 <strong>默认异步</strong> 执行机制的功能</p> </li><li> <p>XML与JSON：都是可以跨平台、跨语言的一种数据格式。</p> </li><li> <p>JSON的格式：</p> 
  <ul><li>[] : 写在[]中的字符串，必须使用双引号 
    <ol><li>原生： [‘a’,“b”]</li><li>JSON： [“a”,“b”]</li></ol></li><li>{} : key 必须加双引号，value如果是字符串，必须加双引号 
    <ol><li>原生：{ name : ‘张三’} {name : “张三”} { ‘name’: ‘张三’} { “name”: “张三”}</li><li>JSON: { “name” : “张三” }</li></ol></li><li>在JSON的值中：不能出现 undefined/NaN/function/Infinity</li></ul></li><li> <p><em><strong>通过异步与服务器通信，将用户请求的数据通过回调函数返回，并利用javascript将数据动态的添加到页面中，且整个过程不需要重新加载整个页面就可以完成</strong></em></p> </li></ul> 
<h3 id="AJAX%20%E7%9A%84%E4%BC%98%E5%8A%BF"><a id="AJAX__19"></a>AJAX 的优势</h3> 
<ol><li>异步与服务器通信</li><li>不需要刷新页面就可以更新数据</li><li>减少服务器负担，实现前后端负载平衡</li><li>缺点： 搜索引擎的支持度不够，因为数据都不在页面上，搜索引擎搜索不到</li><li>缺点：没有历史记录</li><li>缺点：存在风险</li></ol> 
<h3 id="AJAX%20%E7%9A%84%E4%BD%BF%E7%94%A8"><a id="AJAX__30"></a>AJAX 的使用</h3> 
<ul><li>在 js 中有内置的构造函数来创建 ajax 对象</li><li>创建 ajax 对象以后，我们就使用 ajax 对象的方法去发送请求和接受响应</li></ul> 
<h4 id="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20ajax%20%E5%AF%B9%E8%B1%A1"><a id="_ajax__37"></a>创建一个 ajax 对象</h4> 
<pre><code class="language-javascript">// 除IE6所有浏览器都支持的
const xhr = new XMLHttpRequest()

// IE6
const xhr = new ActiveXObject('Mricosoft.XMLHTTP')
</code></pre> 
<ul><li>上面就是有了一个 ajax 对象</li><li>我们就可以使用这个 <code>xhr</code> 对象来发送 ajax 请求了</li></ul> 
<h4 id="%E9%85%8D%E7%BD%AE%E9%93%BE%E6%8E%A5%E4%BF%A1%E6%81%AF"><a id="_52"></a>配置链接信息</h4> 
<pre><code class="language-javascript">const xhr = new XMLHttpRequest()

// xhr 对象中的 open 方法是来配置请求信息的
// 第一个参数是本次请求的请求方式 get / post / put / ...
// 第二个参数是本次请求的 url 
// 第三个参数是本次请求是否异步，默认 true 表示异步，false 表示同步
// xhr.open('请求方式', '请求地址', 是否异步)
xhr.open('get', './data.php')
</code></pre> 
<ul><li>上面的代码执行完毕以后，本次请求的基本配置信息就写完了</li></ul> 
<h4 id="%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><a id="_69"></a>发送请求</h4> 
<pre><code class="language-javascript">const xhr = new XMLHttpRequest()
xhr.open('get', './data.php')

// 使用 xhr 对象中的 send 方法来发送请求
xhr.send()
</code></pre> 
<ul><li>上面代码是把配置好信息的 ajax 对象发送到服务端</li></ul> 
<h4 id="%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%20ajax%20%E8%AF%B7%E6%B1%82"><a id="_ajax__83"></a>一个基本的 ajax 请求</h4> 
<ul><li>一个最基本的 ajax 请求就是上面三步</li><li>但是光有上面的三个步骤，我们确实能把请求发送的到服务端</li><li>如果服务端正常的话，响应也能回到客户端</li><li>但是我们拿不到响应</li><li>如果想拿到响应，我们有两个前提条件 
  <ol><li>本次 HTTP 请求是成功的，也就是我们之前说的 http 状态码为 200 ~ 299</li><li>ajax 对象也有自己的状态码，用来表示本次 ajax 请求中各个阶段</li></ol></li></ul> 
<h4 id="ajax%20%E7%8A%B6%E6%80%81%E7%A0%81"><a id="ajax__95"></a>ajax 状态码</h4> 
<ul><li>ajax 状态码 - <code>xhr.readyState</code></li><li>是用来表示一个 ajax 请求的全部过程中的某一个状态 
  <ul><li><code>readyState === 0</code>： 表示未初始化完成，也就是 <code>open</code> 方法还没有执行</li><li><code>readyState === 1</code>： 表示配置信息已经完成，也就是执行完 <code>open</code> 之后</li><li><code>readyState === 2</code>： 表示 <code>send</code> 方法已经执行完成</li><li><code>readyState === 3</code>： 表示正在解析响应内容</li><li><code>readyState === 4</code>： 表示响应内容已经解析完毕，可以在客户端使用了</li></ul></li><li>这个时候我们就会发现，当一个 ajax 请求的全部过程中，只有当 <code>readyState === 4</code> 的时候，我们才可以正常使用服务端给我们的数据</li><li>所以，配合 http 状态码为 200 ~ 299 
  <ul><li>一个 ajax 对象中有一个成员叫做 <code>xhr.status</code></li><li>这个成员就是记录本次请求的 http 状态码的</li></ul></li><li>两个条件都满足的时候，才是本次请求正常完成</li></ul> 
<h4 id="readyStateChange"><a id="readyStateChange_112"></a>readyStateChange</h4> 
<ul><li> <p>在 ajax 对象中有一个事件，叫做 <code>readyStateChange</code> 事件</p> </li><li> <p>这个事件是专门用来监听 ajax 对象的 <code>readyState</code> 值改变的的行为</p> </li><li> <p>也就是说只要 <code>readyState</code> 的值发生变化了，那么就会触发该事件</p> </li><li> <p>所以我们就在这个事件中来监听 ajax 的 <code>readyState</code> 是不是到 4 了</p> <pre><code class="language-javascript">const xhr = new XMLHttpRequest()
xhr.open('get', './data.php')

xhr.send()

xhr.onreadyStateChange = function () {
  // 每次 readyState 改变的时候都会触发该事件
  // 我们就在这里判断 readyState 的值是不是到 4
  // 并且 http 的状态码是不是 200 ~ 299
  if (xhr.readyState === 4 &amp;&amp; /^2\d{2}$/.test(xhr.status)) {
    // 这里表示验证通过
    // 我们就可以获取服务端给我们响应的内容了
  }
}
</code></pre> </li></ul> 
<h4 id="responseText"><a id="responseText_141"></a>responseText</h4> 
<ul><li> <p>ajax 对象中的 <code>responseText</code> 成员</p> </li><li> <p>就是用来记录服务端给我们的响应体内容的</p> </li><li> <p>所以我们就用这个成员来获取响应体内容就可以</p> <pre><code class="language-javascript">const xhr = new XMLHttpRequest()
xhr.open('get', './data.php')

xhr.send()

xhr.onreadyStateChange = function () {
  if (xhr.readyState === 4 &amp;&amp; /^2\d{2|$/.test(xhr.status)) {
    // 我们在这里直接打印 xhr.responseText 来查看服务端给我们返回的内容
    console.log(xhr.responseText)
  }
}
</code></pre> </li></ul> 
<h2 id="ajax%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><a id="ajax_165"></a>ajax的工作原理</h2> 
<blockquote> 
 <p>前后端交互，首先需要创建一个XMLHttpRequest对象，通过这个对象的open方法与服务器建立连接，通过send方法将请求发送给服务器，最后通过事件监听，将后端请求的数据通过回调函数返回给前端。</p> 
</blockquote> 
<h3 id="%E4%BD%BF%E7%94%A8%20ajax%20%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%97%B6%E6%90%BA%E5%B8%A6%E5%8F%82%E6%95%B0"><a id="_ajax__169"></a>使用 ajax 发送请求时携带参数</h3> 
<ul><li>我们使用 ajax 发送请求也是可以携带参数的</li><li>参数就是和后台交互的时候给他的一些信息</li><li>但是携带参数 get 和 post 两个方式还是有区别的</li></ul> 
<h4 id="%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%20get%20%E8%AF%B7%E6%B1%82"><a id="_get__177"></a>发送一个带有参数的 get 请求</h4> 
<ul><li> <p>get 请求的参数就直接在 url 后面进行拼接就可以</p> <pre><code class="language-javascript">const xhr = new XMLHttpRequest()
// 直接在地址后面加一个 ?，然后以 key=value 的形式传递
// 两个数据之间以 &amp; 分割
xhr.open('get', './data.php?a=100&amp;b=200')

xhr.send()
</code></pre> 
  <ul><li>这样服务端就能接受到两个参数</li><li>一个是 a，值是 100</li><li>一个是 b，值是 200</li></ul></li></ul> 
<h4 id="%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%20post%20%E8%AF%B7%E6%B1%82"><a id="_post__196"></a>发送一个带有参数的 post 请求</h4> 
<ul><li> <p>post 请求的参数是携带在请求体中的，所以不需要再 url 后面拼接</p> <pre><code class="language-javascript">const xhr = new XMLHttpRequest()
xhr.open('get', './data.php')

// 如果是用 ajax 对象发送 post 请求，必须要先设置一下请求头中的 content-type
// 告诉一下服务端我给你的是一个什么样子的数据格式
xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded')

// 请求体直接再 send 的时候写在 () 里面就行
// 不需要问号，直接就是 'key=value&amp;key=value' 的形式
xhr.send('a=100&amp;b=200')
</code></pre> 
  <ul><li><code>application/x-www-form-urlencoded</code> 表示的数据格式就是 <code>key=value&amp;key=value</code></li></ul></li></ul> 
<h2 id="get%E4%B8%8Epost%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><a id="getpost_215"></a>get与post的区别？</h2> 
<h3 id="get"><a id="get_217"></a>get</h3> 
<ol><li>传递速度快</li><li>传递数据大小为1KB</li><li>参数在url地址后面传递</li><li>get以明文方式传递参数，所以不安全。</li><li>get会留下历史记录</li></ol> 
<h3 id="post"><a id="post_225"></a>post</h3> 
<ol><li> <p>传递速度慢</p> </li><li> <p>传递数据大小为 2MB</p> </li><li> <p>参数在http协议的请求体中传递</p> </li><li> <p>post传递参数相对安全。</p> </li><li> <p>不会留下历史记录</p> </li></ol> 
<h2 id="%E5%B0%81%E8%A3%85%20AJAX"><a id="_AJAX_234"></a>封装 AJAX</h2> 
<ul><li>ajax 使用起来太麻烦，因为每次都要写很多的代码</li><li>那么我们就封装一个 ajax 方法来让我们使用起来简单一些</li></ul> 
<h3 id="%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><a id="_241"></a>确定一下使用的方式</h3> 
<ul><li> <p>因为有一些内容可以不传递，我们可以使用默认值，所以选择对象传递参数的方式</p> <pre><code class="language-javascript">// 使用的时候直接调用，传递一个对象就可以
ajax({
  url: '', // 请求的地址
  type: '', // 请求方式
  async: '', // 是否异步
  data: '', // 携带的参数
  dataType: '', // 要不要执行 json.parse
  success: function () {} // 成功以后执行的函数
})
</code></pre> 
  <ul><li>确定好使用方式以后，就开始书写封装函数</li></ul></li></ul> 
<h2 id="Promise"><a id="Promise_259"></a>Promise</h2> 
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AFPromise%3F"><a id="Promise_261"></a>什么是Promise?</h2> 
<blockquote> 
 <p>ES6提出的异步编程解决方案.</p> 
 <p>承诺的意思，是一个专门用来解决异步 <strong>回调地狱</strong> 的问题</p> 
</blockquote> 
<ul><li><strong>回调地狱，其实就是回调函数嵌套过多导致的</strong></li><li>当代码成为这个结构以后，已经没有维护的可能了</li><li>所以我们要把代码写的更加的艺术一些</li></ul> 
<h2 id="promise%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95"><a id="promise_274"></a>promise使用语法</h2> 
<pre><code class="language-javascript">// 检测机构
//resolve : 处理异步时成功的状态
//reject : 处理异步时失败的状态
new Promise((resolve,reject) =&gt; {
    if(处理异步){
        resolve([参数]);
    }else{
        reject([参数]);
    }
})
</code></pre> 
<h2 id="Promise%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><a id="Promise_290"></a>Promise原型对象的方法</h2> 
<ol><li>then(([参数]) =&gt; {}) : 当Promise对象返回resolve时,可以通过then方法执行后续的操作.</li><li>catch([参数] =&gt; {}) : 当promise对象返回reject时,可以通过catch方法执行后续的操作.</li></ol> 
<h2 id="%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5"><a id="_295"></a>处理多个异步</h2> 
<pre><code class="language-javascript">new Promise((resolve,reject) =&gt; {
    if(处理异步){
        resolve([参数]);
    }else{
        reject([参数]);
    }
})
.then(() =&gt; {
    return new Promise(() =&gt; {

    })
})
.then(() =&gt; {
    return new Promise(() =&gt; {

    })
})
……
.then(() =&gt; {
    
})
</code></pre> 
<h2 id="Promise%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><a id="Promise_321"></a>Promise的静态方法</h2> 
<blockquote> 
 <p>Promise.all() 将调用所有的promse对象，全部返回resolve时，该对象才返回resolve。如果有一个promise返回reject时，该对象返回reject</p> 
</blockquote> 
<h2 id="Promise%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><a id="Promise_325"></a>Promise中的三种状态</h2> 
<ol><li>resolved(fulfilled) : 成功状态</li><li>pending : 进行中状态</li><li>rejected : 失败状态</li></ol> 
<ul><li> <p>这个时候，我们的代码已经改观了很多了</p> </li><li> <p>基本已经可以维护了</p> </li><li> <p>但是对于一个程序员来说，这个样子是不够的</p> </li><li> <p>我们还需要更加的简化代码</p> </li><li> <p>所以我们就需要用到一个 es7 的语法了</p> </li><li> <p>叫做 async/await</p> </li></ul> 
<h2 id="ASYNC%2FAWAIT"><a id="ASYNCAWAIT_347"></a>ASYNC/AWAIT</h2> 
<ul><li> <p><code>async/await</code> 是一个 es7 的语法</p> </li><li> <p>这个语法是 <strong>回调地狱的终极解决方案</strong></p> </li><li> <p>语法：</p> <pre><code class="language-javascript">async function fn() {
  const res = await promise对象
}
</code></pre> </li></ul> 
<h2 id="async%20%E5%92%8C%20await%20%E5%85%B3%E9%94%AE%E5%AD%97"><a id="async__await__361"></a>async 和 await 关键字</h2> 
<ul><li>注意： <strong>需要配合的必须是 Promise对象</strong></li><li>注意：<strong>Promise 语法的调用方案</strong></li><li>意义：<strong>可以把异步代码写的看起来像同步代码</strong></li></ul> 
<h3 id="async%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><a id="async__367"></a>async 关键字的用法</h3> 
<ul><li>直接书写在函数的前面，表示该函数是一个异步函数</li><li>意义： 表示在该函数内可以使用 await 关键字</li></ul> 
<h3 id="await%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><a id="await__372"></a>await 关键字的用法</h3> 
<ul><li>必须书写在一个有async关键字的函数内</li><li>await 后面等待的内容必须是一个promise对象</li><li>本该使用then接收的结果，可以直接定义变量接收</li></ul> 
<h3 id="%E7%BC%BA%E7%82%B9"><a id="_378"></a>缺点</h3> 
<ol><li>await 只能捕获到promise成功的状态</li><li>如果失败，会报错，终止程序继续执行</li></ol> 
<h3 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><a id="_383"></a>解决方案</h3> 
<ol><li>使用 try catch语法 
  <ul><li>语法: try { 执行代码 } catch(err) { 执行代码 }</li><li>首先执行 try 里面的代码, 如果不报错, catch 的代码不执行了</li><li>如果报错, 不会爆出错误, 不会终止程序执行, 而是执行 catch 的代码, 把错误信息给到 err 参数</li></ul></li><li>改变封装Promise的思路 
  <ol><li>让当前的 Promise 对象百分百成功,让成功和失败都按照 resolve 的形式来执行,只不过传递出去的参数, 记录一个表示成功或者失败的信息</li></ol></li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ae0195294fdab5a3d55773135f951f5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Video组件的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5f2c5516b12887f2bdef5cc745e82289/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GoLong的学习之路，进阶，Viper（yaml等配置文件的管理）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>