<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>swin-Transformer论文详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="swin-Transformer论文详解" />
<meta property="og:description" content="swin-Transformer论文详解 – 潘登同学的深度学习笔记 文章目录 swin-Transformer论文详解 -- 潘登同学的深度学习笔记 前言网络架构Swin transformer Block巧妙的Mask 实验 前言 swin-Transformer作为CVPR 21的最佳论文，在几乎所有下游任务都表现地很出色；swin-Transformer的全称是Hierarchical Vision Transformer using Shifted Windows；
核心是怎么采用Hierarchical的方式来应用Transformer，从而是的CV与NLP更好的融合；
在VIT那篇论文中，研究团队只是做了VIT用于图像分类的任务，并没有把所有任务都刷过，所以大家还是对Transformer用于CV领域有所担心，而swin-Transformer就是解决这种担心的；
将transformer用于CV领域还是有两大方面的难题的
语义尺度问题(对于空间上靠前的物体与靠后的物体的尺度是不同的，但是可能表示同样的语义信息)图片大小问题(因为VIT做了patch，得到的token长度都是定死的) 目标检测与语义分割的经典架构
目标检测要框不同尺寸的物体，常用架构就是FPN语义分割不仅要找到物体，还要画出来，常用架构就是U-Net VIT的问题
在做patch的时候，始终是在整张图上做patch，学的始终是整张图的信息一个patch中的序列长度，是随着整张图的长度变化而平方级别地变大没有CNN的先验知识 为什么把NLP的模型用于CV领域会表现的很好
因为Transformer具有很强地连接上下文的能力，在一张图片里面，所有物体不是孤立的而是有关系的 网络架构 以ImageNet的图片为例，输入图片大小为224x224x3；
Patch projection层： 每个patch的大小是4x4，那么就有56x56个patch，将patch展平得到4x4x3=48长度的token，所以输入就是[56x56]x48；Linear Embedding层： 接一层Embedding，得到[56x56]x96;Swin transformer Block：因为本质是transformer，所以输入输出维度一致，先不管；Patch Merging：是一种下采样的方式，这里是下采样两倍，就是把原特征图以2x2为一块框住，标上序号，将所有序号为1的挑出来作为一个张量，以此类推，得到 W 2 ∗ H 2 ∗ C \frac{W}{2}*\frac{H}{2}*C 2W​∗2H​∗C的四个张量，将其拼接得到 W 2 ∗ H 2 ∗ 4 C \frac{W}{2}*\frac{H}{2}*4C 2W​∗2H​∗4C; 但是为了与CNN的思想一致，就是一次改变通道数只是想让其翻倍，后面接了1x1的卷积，得到[28x28]x192;以恰当的方式重复4次以上过程接global average pooling将最后[7x7]x768的输出变为[1x1]x768； 如果是做分类的话，接FC得到[1x1]x1000； Swin transformer Block Swin transformer Block是Swin transformer的主要贡献，核心是只对每个窗口做自注意力，但是一个self-attention只能做一个序列，这里一个窗口就是一个序列，要做一个图的所有窗口，就要用多头注意力(这里的多头与之前的不一样，之前主要是为了并行计算的，现在真就是多头)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/96e8972452cf355682b456bd9aae56d0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-05T00:50:33+08:00" />
<meta property="article:modified_time" content="2022-06-05T00:50:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">swin-Transformer论文详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="swinTransformer___0"></a>swin-Transformer论文详解 – 潘登同学的深度学习笔记</h3> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#swinTransformer___0" rel="nofollow">swin-Transformer论文详解 -- 潘登同学的深度学习笔记</a></li></ul> 
  </li><li><a href="#_4" rel="nofollow">前言</a></li><li><a href="#_30" rel="nofollow">网络架构</a></li><li><ul><li><a href="#Swin_transformer_Block_44" rel="nofollow">Swin transformer Block</a></li><li><a href="#Mask_82" rel="nofollow">巧妙的Mask</a></li></ul> 
  </li><li><a href="#_103" rel="nofollow">实验</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_4"></a>前言</h2> 
<p>swin-Transformer作为CVPR 21的最佳论文，在几乎所有下游任务都表现地很出色；swin-Transformer的全称是<strong>Hierarchical Vision Transformer using Shifted Windows</strong>；<br> 核心是怎么采用Hierarchical的方式来应用Transformer，从而是的CV与NLP更好的融合；</p> 
<p>在VIT那篇论文中，研究团队只是做了VIT用于图像分类的任务，并没有把所有任务都刷过，所以大家还是对Transformer用于CV领域有所担心，而swin-Transformer就是解决这种担心的；</p> 
<p>将transformer用于CV领域还是有两大方面的难题的</p> 
<ul><li>语义尺度问题(对于空间上靠前的物体与靠后的物体的尺度是不同的，但是可能表示同样的语义信息)</li><li>图片大小问题(因为VIT做了patch，得到的token长度都是定死的)</li></ul> 
<p>目标检测与语义分割的经典架构</p> 
<ul><li>目标检测要框不同尺寸的物体，常用架构就是FPN</li><li>语义分割不仅要找到物体，还要画出来，常用架构就是U-Net</li></ul> 
<p>VIT的问题</p> 
<ul><li>在做patch的时候，始终是在整张图上做patch，学的始终是整张图的信息</li><li>一个patch中的序列长度，是随着整张图的长度变化而平方级别地变大</li><li>没有CNN的先验知识</li></ul> 
<p>为什么把NLP的模型用于CV领域会表现的很好</p> 
<ul><li>因为Transformer具有很强地连接上下文的能力，在一张图片里面，所有物体不是孤立的而是有关系的</li></ul> 
<p><img src="https://images2.imgbox.com/bc/cc/cKCJAJIk_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_30"></a>网络架构</h2> 
<p><img src="https://images2.imgbox.com/2b/e8/wBJGBfQn_o.png" alt="在这里插入图片描述"></p> 
<p>以ImageNet的图片为例，输入图片大小为224x224x3；</p> 
<ol><li>Patch projection层： 每个patch的大小是4x4，那么就有56x56个patch，将patch展平得到4x4x3=48长度的token，所以输入就是[56x56]x48；</li><li>Linear Embedding层： 接一层Embedding，得到[56x56]x96;</li><li>Swin transformer Block：因为本质是transformer，所以输入输出维度一致，先不管；</li><li>Patch Merging：是一种下采样的方式，这里是下采样两倍，就是把原特征图以2x2为一块框住，标上序号，将所有序号为1的挑出来作为一个张量，以此类推，得到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           W 
          
         
           2 
          
         
        
          ∗ 
         
         
         
           H 
          
         
           2 
          
         
        
          ∗ 
         
        
          C 
         
        
       
         \frac{W}{2}*\frac{H}{2}*C 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.21733em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.872331em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span style="margin-right: 0.13889em;" class="mord mathdefault mtight">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.21733em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.872331em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span style="margin-right: 0.08125em;" class="mord mathdefault mtight">H</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span></span></span></span></span>的四个张量，将其拼接得到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           W 
          
         
           2 
          
         
        
          ∗ 
         
         
         
           H 
          
         
           2 
          
         
        
          ∗ 
         
        
          4 
         
        
          C 
         
        
       
         \frac{W}{2}*\frac{H}{2}*4C 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.21733em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.872331em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span style="margin-right: 0.13889em;" class="mord mathdefault mtight">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.21733em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.872331em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span style="margin-right: 0.08125em;" class="mord mathdefault mtight">H</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">4</span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span></span></span></span></span>; 但是为了与CNN的思想一致，就是一次改变通道数只是想让其翻倍，后面接了1x1的卷积，得到[28x28]x192;</li><li>以恰当的方式重复4次以上过程</li><li>接global average pooling将最后[7x7]x768的输出变为[1x1]x768； 
  <ol><li>如果是做分类的话，接FC得到[1x1]x1000；</li></ol> </li></ol> 
<h3><a id="Swin_transformer_Block_44"></a>Swin transformer Block</h3> 
<p>Swin transformer Block是Swin transformer的主要贡献，核心是只<strong>对每个窗口做自注意力</strong>，但是一个self-attention只能做一个序列，这里一个窗口就是一个序列，要做一个图的所有窗口，就要用多头注意力(这里的多头与之前的不一样，之前主要是为了并行计算的，现在真就是多头)</p> 
<ul><li>最小的计算单元是一个patch： 长度为<strong>96</strong>的一个向量(作为一个token)；</li><li>中型计算单元为一个窗口： 总共有<strong>7x7</strong>个patch，也就对应序列长度为49；</li><li>(以第一层举例)总共有<strong>8x8</strong>(56/7)个窗口,那么就有64个多头；</li></ul> 
<p>为了说明相较于全局的patch(VIT中)，基于滑动窗口的自注意力能减少计算量，作者粗略计算了一下：</p> 
<ul><li> <p>一个图片有<strong>hxw</strong>个patch，每个patch的通道数是C</p> </li><li> <p>对于VIT来说，一个token进入QKV就是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           3 
          
          
          
            C 
           
          
            2 
           
          
         
        
          3C^2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">3</span><span class="mord"><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>的计算复杂度，Q与所有K之间内积(向量点乘)是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           h 
          
         
           w 
          
         
           C 
          
         
        
          hwC 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span></span></span></span></span>, 内积结果与所有V相乘就是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           h 
          
         
           w 
          
         
           C 
          
         
        
          hwC 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span></span></span></span></span>,最后所有一个QK对应的所有V都做一个FC层就是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            C 
           
          
            2 
           
          
         
        
          C^2 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p> </li><li> <p>那么总共有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           h 
          
         
           ∗ 
          
         
           w 
          
         
        
          h*w 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span></span></span></span></span>个token，所以总的计算复杂度就是<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            Ω 
           
          
            ( 
           
          
            M 
           
          
            S 
           
          
            A 
           
          
            ) 
           
          
            = 
           
          
            h 
           
          
            w 
           
          
            ( 
           
          
            4 
           
           
           
             C 
            
           
             2 
            
           
          
            + 
           
          
            2 
           
          
            h 
           
          
            w 
           
          
            C 
           
          
            ) 
           
          
         
           \Omega(MSA) = hw(4C^2 + 2hwC) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span style="margin-right: 0.10903em;" class="mord mathdefault">M</span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.11411em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span><span class="mopen">(</span><span class="mord">4</span><span class="mord"><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">h</span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span class="mclose">)</span></span></span></span></span></span></p> </li><li> <p>对于Swin transformer来说，可以套用上面的结果，一个窗口有<strong>MxM</strong>个patch，总共有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
           
           
             h 
            
           
             w 
            
           
           
           
             M 
            
           
             2 
            
           
          
         
        
          \frac{hw}{M^2} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.22511em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.880108em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span style="margin-right: 0.10903em;" class="mord mathdefault mtight">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.746314em;"><span class="" style="top: -2.786em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span style="margin-right: 0.02691em;" class="mord mathdefault mtight">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>个窗口，所以计算复杂度就是<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            Ω 
           
          
            ( 
           
          
            W 
           
          
            − 
           
          
            M 
           
          
            S 
           
          
            A 
           
          
            ) 
           
          
            = 
           
           
            
            
              h 
             
            
              w 
             
            
            
            
              M 
             
            
              2 
             
            
           
           
           
             M 
            
           
             2 
            
           
          
            ( 
           
          
            4 
           
           
           
             C 
            
           
             2 
            
           
          
            + 
           
          
            2 
           
           
           
             M 
            
           
             2 
            
           
          
            C 
           
          
            ) 
           
          
            = 
           
          
            h 
           
          
            w 
           
          
            ( 
           
          
            4 
           
           
           
             C 
            
           
             2 
            
           
          
            + 
           
          
            2 
           
           
           
             M 
            
           
             2 
            
           
          
            C 
           
          
            ) 
           
          
         
           \Omega(W-MSA) = \frac{hw}{M^2} M^2(4C^2 + 2M^2C) = hw(4C^2 + 2M^2C) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span style="margin-right: 0.13889em;" class="mord mathdefault">W</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.10903em;" class="mord mathdefault">M</span><span style="margin-right: 0.05764em;" class="mord mathdefault">S</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.05744em; vertical-align: -0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.37144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span style="margin-right: 0.10903em;" class="mord mathdefault">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.740108em;"><span class="" style="top: -2.989em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">h</span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span style="margin-right: 0.10903em;" class="mord mathdefault">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">4</span><span class="mord"><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.11411em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mord"><span style="margin-right: 0.10903em;" class="mord mathdefault">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.11411em; vertical-align: -0.25em;"></span><span class="mord mathdefault">h</span><span style="margin-right: 0.02691em;" class="mord mathdefault">w</span><span class="mopen">(</span><span class="mord">4</span><span class="mord"><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.11411em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mord"><span style="margin-right: 0.10903em;" class="mord mathdefault">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span style="margin-right: 0.07153em;" class="mord mathdefault">C</span><span class="mclose">)</span></span></span></span></span></span></p> </li><li> <p>对于VIT来说hw就是196,而现在降为了49；</p> </li></ul> 
<p>为了做滑动窗口之间的交互，在进入下一个transformer中需要对滑动窗口做shift，论文中shift的尺寸是每个窗口的一半,这里做了向下取整，使得所有滑动窗口向右、向下shift<strong>3个patch</strong>；</p> 
<ul><li>所以我们在网络架构图中看到的block单元中的transfromer个数一定是<strong>偶数</strong>个，因为一层普通的W-MSA完事之后一定要shift接一层SW-MSA</li></ul> 
<p>如图所示，但这样做会导致窗口的数量增加，而且窗口的大小也不相同；</p> 
<p><img src="https://images2.imgbox.com/19/2a/WW4bmczh_o.png" alt="在这里插入图片描述"></p> 
<p>有这样一些解决思路</p> 
<ol><li>直接不管，一个窗口的patch数量不一致就等于序列长度不一，直接mask掉就行；</li><li>给那些窗口大小比正常49个patch少的窗口补一圈零；</li></ol> 
<p>但上述的解决方案都会导致窗口数量增加，导致计算复杂度增加；</p> 
<h3><a id="Mask_82"></a>巧妙的Mask</h3> 
<p><strong>解决方案</strong></p> 
<ul><li>论文给出了割补法的解决方案如图所示,就是将左上角那些残缺不全的窗口补到右下角去；</li></ul> 
<p><img src="https://images2.imgbox.com/49/b3/tN9zeXN0_o.png" alt="在这里插入图片描述"></p> 
<p>但随之而来的会产生一个问题： 在做自注意力的时候，可能会导致不合适的自注意力，因为图片上方可能是天空，而下方是地面，一作自注意力后就会导致原本无关的东西变得相关，显然不合理；</p> 
<ul><li>所以论文采用了几个mask模板来解决自注意力的问题；如下图所示</li></ul> 
<p><img src="https://images2.imgbox.com/0e/2a/Nb1f71wF_o.png" alt="在这里插入图片描述"></p> 
<p>对于上图，其中的序号表示shift完之后的窗口；</p> 
<ul><li>0是一个完整的窗口，所以做self-attention直接做就行</li><li>3和6分别是两个窗口，其中窗口3的大小是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          4 
         
        
          ∗ 
         
        
          7 
         
        
       
         4*7 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">7</span></span></span></span></span>个patch，而6的窗口的大小则是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          3 
         
        
          ∗ 
         
        
          7 
         
        
       
         3*7 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">7</span></span></span></span></span>的；将3窗口的28个向量与6窗口的21个向量拼接得到矩阵，矩阵与自己的转置相乘(第一行乘每一列放到第一行上去(经典线代))，那么得到的新矩阵就如上图的window2所示，其中黄色的部分就是3与3、6与6矩阵相乘得到的数，紫色部分就是其3与6、6与3矩阵相乘的结果；</li><li>将一个事先定义好的mask模板，黄色部分是0,紫色部分是一个负很大的数与自注意力得到的结果相加，做softmax，自然就将不合适的部分mask掉了；</li></ul> 
<p>对于window1,window3的操作也类似，只不过在拼接矩阵的时候，对窗口1和窗口2的拼接是交错的(因为patch的序号是从左到右从上到下)，所以mask模板要做对应调整，window3就是融合了两者了；</p> 
<h2><a id="_103"></a>实验</h2> 
<p>实验部分就跳过，nb就完事了，在21年在ADE20k数据集上全面领跑目标检测与语义分割等下游任务；</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fe435ce489aad3925265bbefcb3216fb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">同步FIFO &#43; 异步FIFO 【设计详解及代码分享】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cd24f4e0b85d7a00fe1c03e7765b0039/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux中ifconfig的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>