<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【centos】【Redis】【systemd】Redis进程守护 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【centos】【Redis】【systemd】Redis进程守护" />
<meta property="og:description" content="Centos7中将redis服务写入systemctl
CentOS 7.x开始,CentOS开始使用systemd服务来代替daemon,比起原来的service和config两套命令，systemd整合了service和config的功能。Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。先安装一下redis，我这里是redis-6.2.3版本，不多说命令如下：
下载安装redis. $ cd /usr/local/redis
$ wget https://download.redis.io/releases/redis-6.2.3.tar.gz
$ tar xzf redis-6.2.3.tar.gz
$ cd redis-6.2.3
$ make
安装完成之后添加快捷方式进/usr/bin中以方便后期使用redis-cli。 $ cd /usr/local/redis
$ mkdir etc
$ cp redis-6.2.3/redis.conf etc/
$ ln -s /usr/local/redis/redis-6.2.3/src/redis-server /usr/bin/redis-server
$ ln -s /usr/local/redis/redis-6.2.3/src/redis-cli /usr/bin/redis-cli
这时redis就可以通过 redis-server /usr/local/redis/etc/redis.conf启动了。然后我们开始将其写入systemd中。进入/usr/lib/systemd/system/目录中，创建redis.service文件，.service文件定义一个服务，分为[Unit]，[Service]，[Install]三个部分，需要更改的就基本只有ExecStart这一行，即是你本机的redis启动命令。另外PIDFile保持和redis配置文件中一样。
$ cd /usr/lib/systemd/system/
$ vim redis.service
[Unit] Description=Redis #描述内容 #在哪些服务启动之后启动 After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=forking #PIDFile和redis.conf配置中一致 PIDFile=/var/run/redis_6379.pid ExecStart=/usr/local/redis/redis-6.2.3/src/redis-server /usr/local/redis/etc/redis.conf #重新加载和停止服务的命令 ExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true #系统以默认多用户方式启动时，此服务自动运行。 [Install] #Alias:服务别名 WantedBy=multi-user." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4b62e1068d67bedbd042d98328f546d4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-28T14:47:08+08:00" />
<meta property="article:modified_time" content="2023-04-28T14:47:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【centos】【Redis】【systemd】Redis进程守护</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Centos7中将redis服务写入systemctl<br> CentOS 7.x开始,CentOS开始使用systemd服务来代替daemon,比起原来的service和config两套命令，systemd整合了service和config的功能。Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。先安装一下redis，我这里是redis-6.2.3版本，不多说命令如下：</p> 
<h2><a id="redis_4"></a>下载安装redis.</h2> 
<p>$ cd /usr/local/redis<br> $ wget https://download.redis.io/releases/redis-6.2.3.tar.gz<br> $ tar xzf redis-6.2.3.tar.gz<br> $ cd redis-6.2.3<br> $ make</p> 
<h2><a id="usrbinrediscli_11"></a>安装完成之后添加快捷方式进/usr/bin中以方便后期使用redis-cli。</h2> 
<p>$ cd /usr/local/redis<br> $ mkdir etc<br> $ cp redis-6.2.3/redis.conf etc/<br> $ ln -s /usr/local/redis/redis-6.2.3/src/redis-server /usr/bin/redis-server<br> $ ln -s /usr/local/redis/redis-6.2.3/src/redis-cli /usr/bin/redis-cli<br> 这时redis就可以通过 redis-server /usr/local/redis/etc/redis.conf启动了。然后我们开始将其写入systemd中。进入/usr/lib/systemd/system/目录中，创建redis.service文件，.service文件定义一个服务，分为[Unit]，[Service]，[Install]三个部分，需要更改的就基本只有ExecStart这一行，即是你本机的redis启动命令。另外PIDFile保持和redis配置文件中一样。<br> $ cd /usr/lib/systemd/system/<br> $ vim redis.service</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>
<span class="token assign-left variable">Description</span><span class="token operator">=</span>Redis <span class="token comment">#描述内容</span>
<span class="token comment">#在哪些服务启动之后启动</span>
<span class="token assign-left variable">After</span><span class="token operator">=</span>syslog.target network.target remote-fs.target nss-lookup.target
 
<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>
<span class="token assign-left variable">Type</span><span class="token operator">=</span>forking
<span class="token comment">#PIDFile和redis.conf配置中一致</span>
<span class="token assign-left variable">PIDFile</span><span class="token operator">=</span>/var/run/redis_6379.pid
<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/local/redis/redis-6.2.3/src/redis-server /usr/local/redis/etc/redis.conf
<span class="token comment">#重新加载和停止服务的命令</span>
<span class="token assign-left variable">ExecReload</span><span class="token operator">=</span>/bin/kill -s HUP <span class="token variable">$MAINPID</span>
<span class="token assign-left variable">ExecStop</span><span class="token operator">=</span>/bin/kill -s QUIT <span class="token variable">$MAINPID</span>
<span class="token assign-left variable">PrivateTmp</span><span class="token operator">=</span>true
 
<span class="token comment">#系统以默认多用户方式启动时，此服务自动运行。</span>
<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>
<span class="token comment">#Alias:服务别名</span>
<span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>multi-user.target
　　保存好之后开始操作systemctl,首先要执行 systemctl daemon-reload 命令，重载systemd配置以引入redis.service。然后使用命令将redis.service加进开机启动：systemctl <span class="token builtin class-name">enable</span> redis.service。完成之后我们就可以启动redis服务。systemctl start redis.service。
</code></pre> 
<pre><code>发现redis.service启动启来了，但碰到一个问题，systemctl start redis.service执行之后就阻塞在那里，后台服务配置相关肯定有问题。在redis的配置文件中可以看到有两项配置daemonize和supervised，配置文件中说，如果以systemd启动daemonize配置将不会有什么影响（但我测试发现并不是这样）。应该同时修改daemonize yes和修改supervised配置。建议使用auto或者systemd。这两项配置修改掉任何一项发现systemctl start redis.service都会被阻塞运行：
</code></pre> 
<p>7</p> 
<h2><a id="When_Redis_is_supervised_by_upstart_or_systemd_this_parameter_has_no_impact_46"></a>When Redis is supervised by upstart or systemd, this parameter has no impact.</h2> 
<p>daemonize yes<br> #If you run Redis from upstart or systemd, Redis can interact with your</p> 
<h2><a id="supervision_tree_Options_49"></a>supervision tree. Options:</h2> 
<p>#supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET<br> #supervised auto - detect upstart or systemd method based on UPSTART_JOB or NOTIFY_SOCKET environment variables<br> supervised auto<br> systemctl其它命令：<br> 查看服务是否设置开机启动： systemctl is-enabled redis.service<br> 查看服务是否启动： systemctl is-active redis.service<br> 禁止服务开机启动： systemctl disable redis.service<br> 列出已经启动的unit: systemctl list-units （也可直接：systemctl）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/668a81b8a02af1d0f1f93c190eb40fb6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mixly温度传感器、声音光线传感器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d01dc3b18a1f698c83cc782dc84b92c8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux 下判断一个字符串ip是否合法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>