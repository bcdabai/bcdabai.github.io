<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>揭秘HTTP协议：深入了解互联网通信的核心！ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="揭秘HTTP协议：深入了解互联网通信的核心！" />
<meta property="og:description" content="文章目录 HTTPHTTP的消息结构HTTP 常用请求方法HTTP 状态码 HTTP HTTP 是超文本传输协议，HTTP是缩写，全称是 HyperText Transfer Protocol
超文本指的是 HTML、css、JavaScript和图片等，HTTP的出现就是为方便接收和发布超HTML页面，经过不断的发展，也可以用于发布接收一些音频、文件等。
HTTP 协议是用于客户端和服务端之间的通信，除此之外还有 TCP/IP 协议族在内的众多协议，请求文本资源的一方，我们称之为客户端（client），接收请求并提供相应的一方称为服务端（Server）
有时候，客户端和服务端身份是可以互换的，单就一条通信线路来讲，可以确定的是，由HTTP协议就可以区分谁是客户端谁是服务端
HTTP 的特点：
支持客户端、服务端模式，简单快速，http 允许任意传输类型的数据对象，无连接，限制每次连接处理一个请求，无状态，指明协议对事物处理没有标记的能力。灵活：允许任何数据对象，音频、视频、图片、文件等…无状态：任何两个请求之间没有必然的联系无连接：每次服务器在处理完请求后，就断开连接了，再请求就是新的连接，采用这种方式节省传输时间 HTTP1.0版的主要缺点
每个TCP 连接智能发送一个请求，发送数据完毕后，连接就关闭了，HTTP 是一种不保存状态，无状态协议，协议对于发送过来的请求或是响应都不做持久化处理
HTTP1.1虽然是无状态协议，但是为了实现期望的保存状态功能，于是引入了 Cookie技术，有了 Cookie，HTTP 协议通信，就可以管理状态了。
TCP 连接的新建成本很高，因为客户端需要和服务端 三次握手
交流端简单流程：客户端发起连接，客户端发起请求，服务端响应请求，服务端关闭链接
HTTP的消息结构 请求消息的结构：
一个请求消息是由 请求行，请求头字段，一个空行和消息主体 构成
消息主体是响应消息的承载数据
客户端：发送请求
GET/HTTP/1.1 Host: xiangi.love 服务器：发送响应
HTTP/1.1 200 OK Date: Tue, 10 Jul ... Content.Length: 362 Content.Type: text/html &lt;html&gt; ... Request Method：请求方法
Request URL：请求URL 的路径
Status Code 为状态码
Remote Address：地址
HTTP 是基于 TCP/IP 协议的应用层协议，不涉及数据包传输，规定了客户端和服务端之间的通讯方式，默认使用80端口" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6c0ebbee4ac63d9eb83b323b7a9e94da/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T21:57:31+08:00" />
<meta property="article:modified_time" content="2024-01-12T21:57:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">揭秘HTTP协议：深入了解互联网通信的核心！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#HTTP_1" rel="nofollow">HTTP</a></li><li><ul><li><a href="#HTTP_34" rel="nofollow">HTTP的消息结构</a></li><li><a href="#HTTP__100" rel="nofollow">HTTP 常用请求方法</a></li><li><a href="#HTTP__121" rel="nofollow">HTTP 状态码</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="HTTP_1"></a>HTTP</h2> 
<blockquote> 
 <p>HTTP 是超文本传输协议，HTTP是缩写，全称是 HyperText Transfer Protocol</p> 
</blockquote> 
<p>超文本指的是 HTML、css、JavaScript和图片等，HTTP的出现就是为方便接收和发布超HTML页面，经过不断的发展，也可以用于发布接收一些音频、文件等。</p> 
<p>HTTP 协议是用于客户端和服务端之间的通信，除此之外还有 TCP/IP 协议族在内的众多协议，请求文本资源的一方，我们称之为客户端（client），接收请求并提供相应的一方称为服务端（Server）</p> 
<p>有时候，客户端和服务端身份是可以互换的，单就一条通信线路来讲，可以确定的是，由HTTP协议就可以区分谁是客户端谁是服务端</p> 
<p>HTTP 的特点：</p> 
<ul><li>支持客户端、服务端模式，简单快速，http 允许任意传输类型的数据对象，无连接，限制每次连接处理一个请求，无状态，指明协议对事物处理没有标记的能力。</li><li>灵活：允许任何数据对象，音频、视频、图片、文件等…</li><li>无状态：任何两个请求之间没有必然的联系</li><li>无连接：每次服务器在处理完请求后，就断开连接了，再请求就是新的连接，采用这种方式节省传输时间</li></ul> 
<p><mark>HTTP1.0版的主要缺点</mark></p> 
<p>每个TCP 连接智能发送一个请求，发送数据完毕后，连接就关闭了，HTTP 是一种不保存状态，无状态协议，协议对于发送过来的请求或是响应都不做持久化处理</p> 
<p>HTTP1.1虽然是无状态协议，但是为了实现期望的保存状态功能，于是引入了 Cookie技术，有了 Cookie，HTTP 协议通信，就可以管理状态了。</p> 
<p><img src="https://images2.imgbox.com/d4/74/yhQNRXgx_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/82/88/uPaSGHkk_o.png" alt="在这里插入图片描述"></p> 
<p>TCP 连接的新建成本很高，因为客户端需要和服务端 三次握手</p> 
<p><mark>交流端简单流程</mark>：客户端发起连接，客户端发起请求，服务端响应请求，服务端关闭链接</p> 
<h3><a id="HTTP_34"></a>HTTP的消息结构</h3> 
<p>请求消息的结构：</p> 
<p>一个请求消息是由 <code>请求行，请求头字段，一个空行和消息主体</code> 构成</p> 
<p>消息主体是响应消息的承载数据</p> 
<p>客户端：发送请求</p> 
<pre><code class="prism language-txt">GET/HTTP/1.1
Host: xiangi.love
</code></pre> 
<p>服务器：发送响应</p> 
<pre><code class="prism language-txt">HTTP/1.1 200 OK
Date: Tue, 10 Jul ...
Content.Length: 362
Content.Type: text/html
&lt;html&gt;
...
</code></pre> 
<p><img src="https://images2.imgbox.com/4f/bd/JOQB9fBQ_o.png" alt="在这里插入图片描述"></p> 
<p>Request Method：请求方法<br> Request URL：请求URL 的路径<br> Status Code 为状态码<br> Remote Address：地址</p> 
<p>HTTP 是基于 TCP/IP 协议的应用层协议，不涉及数据包传输，规定了客户端和服务端之间的通讯方式，默认使用80端口</p> 
<p>HTTP 发送请求例子：</p> 
<p><img src="https://images2.imgbox.com/10/97/lsRlnV54_o.png" alt="在这里插入图片描述"></p> 
<p>服务器回应消息格式：</p> 
<p><img src="https://images2.imgbox.com/84/eb/dXC2tjqO_o.png" alt="在这里插入图片描述"></p> 
<p>响应头：</p> 
<p>Server 为服务器的名称，Location 为通知客户端新的资源位置，Content-Type 为数据类型，</p> 
<pre><code class="prism language-sh"><span class="token comment"># Content-Type 字段类型</span>
text/plain
text/html
text/css
image/jpeg
image/png
image/svg+xml
audio/mp4
video/mp4
application/javascript
application/pdf
application/zip
application/atom+xml
</code></pre> 
<h3><a id="HTTP__100"></a>HTTP 常用请求方法</h3> 
<p>常见的是 GET、POST 除此之外还有…</p> 
<pre><code class="prism language-sh"><span class="token number">1</span>.GET为获取资源数据
get方法用于请求指定的页面信息，并返回请求消息的主体

<span class="token number">2</span>.POST为提交资源数据
post方法用于向指定的资源提交数据

<span class="token number">3</span>.PUT为更新资源数据
<span class="token number">4</span>.DELETE为删除资源数据
<span class="token number">5</span>.HEAD为读取资源的元数据
<span class="token number">6</span>.OPTIONS为读取资源多支持的所有请求方法
<span class="token number">7</span>.TRACE为回显服务器收到额请求
<span class="token number">8</span>.CONNECT为保留将来使用
</code></pre> 
<p>HTTP 1.0 只有 GET、POST、HEAD 三种请求方式，其他的都是 1.1 新增的 其中包括（OPTOPNS、PUT、DELETE、TARCE、CONNECT）</p> 
<h3><a id="HTTP__121"></a>HTTP 状态码</h3> 
<p>200 成功！</p> 
<p>500 出bug了</p> 
<p>404 没有找到资源</p> 
<p>302 临时跳转，非永久性，以闪电五连鞭之势就完成了跳转</p> 
<p>301 永久性重定向，</p> 
<p><img src="https://images2.imgbox.com/64/1e/lRcb0VWa_o.png" alt="在这里插入图片描述"></p> 
<p>HTTP/2 版本主要增加以下几点：</p> 
<ul><li>是二进制协议，不再是纯文本。</li><li>支持一个 TCP 连接发起多请求，移除了 pipeline。</li><li>利用 HPACK 压缩头部，减少数据传输量。</li><li>允许服务端主动推送数据。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5122b54107109a7d358b83396d9c51e5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">终极Linux命令宝典：从入门到精通，一网打尽！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1bee67302968a8a2f4b54aa7e25e89a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">写在学习webkit过程的前面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>