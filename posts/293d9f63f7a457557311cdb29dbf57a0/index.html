<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java面试题总结（附答案） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java面试题总结（附答案）" />
<meta property="og:description" content="🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪 ，专注Java硬核干货分享，立志做到Java赛道全网Top N。
🏆本文收录于Java基础教程系列（进阶篇），本专栏是针对大学生、初级Java工程师精心打造，针对Java生态，逐个击破，不断学习，打通Java技术栈。
🏆订阅后，可以阅读Java基础教程系列（进阶篇）中全部文章，包含Java基础、Java高并发、Spring、MySQL等Java进阶技术栈。
🏆还可以订阅其姐妹篇，Java基础教程系列，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。
🏆哪吒多年工作总结：Java学习路线总结，搬砖工逆袭Java架构师。
🏆面试福音：10万字208道Java经典面试题总结(附答案)。
目录
一、JDK 和 JRE 有什么区别？
二、== 和 equals 的区别是什么？
三、final 在 java 中有什么作用？
四、java 中的 Math.round(-1.5) 等于多少？
五、String 属于基础的数据类型吗？
六、String str=&#34;i&#34;与 String str=new String(“i”)一样吗？
七、如何将字符串反转？
八、String 类的常用方法都有那些？
九、new String(&#34;a&#34;) &#43; new String(&#34;b&#34;) 会创建几个对象？
十、如何将字符串反转？
十一、String 类的常用方法都有那些？
十二、普通类和抽象类有哪些区别？
十三、接口和抽象类有什么区别？
十四、java 中 IO 流分为几种？
十五、BIO、NIO、AIO 有什么区别？
十六、Files的常用方法都有哪些？
十七、什么是反射？
十八、什么是 java 序列化？什么情况下需要序列化？
十九、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？
​二十、throw 和 throws 的区别？
二十一、final、finally、finalize 有什么区别？
二十二、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/293d9f63f7a457557311cdb29dbf57a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-04T22:30:07+08:00" />
<meta property="article:modified_time" content="2023-05-04T22:30:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java面试题总结（附答案）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>🏆作者简介：哪吒，CSDN2022博客之星Top1、CSDN2021博客之星Top2、多届新星计划导师✌、博客专家💪 ，专注Java硬核干货分享，立志做到Java赛道全网Top N。</p> 
 <p></p> 
 <p>🏆本文收录于<a href="https://blog.csdn.net/guorui_java/category_12196381.html" title="Java基础教程系列（进阶篇）">Java基础教程系列（进阶篇）</a>，本专栏是针对大学生、初级Java工程师精心打造，针对Java生态，逐个击破，不断学习，打通Java技术栈。</p> 
 <p></p> 
 <p>🏆订阅后，可以阅读Java基础教程系列（进阶篇）中全部文章，包含Java基础、Java高并发、Spring、MySQL等Java进阶技术栈。</p> 
 <p></p> 
 <p>🏆还可以订阅其姐妹篇，<a href="https://blog.csdn.net/guorui_java/category_11276743.html" title="Java基础教程系列">Java基础教程系列</a>，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。</p> 
 <p></p> 
 <p>🏆哪吒多年工作总结：<a href="https://blog.csdn.net/guorui_java/article/details/120098618" title="Java学习路线总结，搬砖工逆袭Java架构师">Java学习路线总结，搬砖工逆袭Java架构师</a>。</p> 
 <p></p> 
 <p>🏆面试福音：<a href="https://blog.csdn.net/guorui_java/article/details/119299329" title="10万字208道Java经典面试题总结(附答案)">10万字208道Java经典面试题总结(附答案)</a>。</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81JDK%20%E5%92%8C%20JRE%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81JDK%20%E5%92%8C%20JRE%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">一、JDK 和 JRE 有什么区别？</a></p> 
<p id="%E4%BA%8C%E3%80%81%3D%3D%20%E5%92%8C%20equals%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%3D%3D%20%E5%92%8C%20equals%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">二、== 和 equals 的区别是什么？</a></p> 
<p id="%E4%B8%89%E3%80%81final%20%E5%9C%A8%20java%20%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81final%20%E5%9C%A8%20java%20%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F" rel="nofollow">三、final 在 java 中有什么作用？</a></p> 
<p id="%E5%9B%9B%E3%80%81java%20%E4%B8%AD%E7%9A%84%20Math.round(-1.5)%20%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81java%20%E4%B8%AD%E7%9A%84%20Math.round%28-1.5%29%20%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91%EF%BC%9F" rel="nofollow">四、java 中的 Math.round(-1.5) 等于多少？</a></p> 
<p id="%E4%BA%94%E3%80%81String%20%E5%B1%9E%E4%BA%8E%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81String%20%E5%B1%9E%E4%BA%8E%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F" rel="nofollow">五、String 属于基础的数据类型吗？</a></p> 
<p id="%E5%85%AD%E3%80%81String%20str%3D%22i%22%E4%B8%8E%20String%20str%3Dnew%20String(%E2%80%9Ci%E2%80%9D)%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81String%20str%3D%22i%22%E4%B8%8E%20String%20str%3Dnew%20String%28%E2%80%9Ci%E2%80%9D%29%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F" rel="nofollow">六、String str="i"与 String str=new String(“i”)一样吗？</a></p> 
<p id="%E4%B8%83%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%83%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F" rel="nofollow">七、如何将字符串反转？</a></p> 
<p id="%E5%85%AB%E3%80%81String%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%85%AB%E3%80%81String%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F" rel="nofollow">八、String 类的常用方法都有那些？</a></p> 
<p id="%E4%B9%9D%E3%80%81new%20String(%22a%22)%20%2B%20new%20String(%22b%22)%20%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B9%9D%E3%80%81new%20String%28%22a%22%29%20%2B%20new%20String%28%22b%22%29%20%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F" rel="nofollow">九、new String("a") + new String("b") 会创建几个对象？</a></p> 
<p id="%E5%8D%81%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F" rel="nofollow">十、如何将字符串反转？</a></p> 
<p id="%E5%8D%81%E4%B8%80%E3%80%81String%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%B8%80%E3%80%81String%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F" rel="nofollow">十一、String 类的常用方法都有那些？</a></p> 
<p id="%E5%8D%81%E4%BA%8C%E3%80%81%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">十二、普通类和抽象类有哪些区别？</a></p> 
<p id="%E5%8D%81%E4%B8%89%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%B8%89%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">十三、接口和抽象类有什么区别？</a></p> 
<p id="%E5%8D%81%E5%9B%9B%E3%80%81java%20%E4%B8%AD%20IO%20%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E5%9B%9B%E3%80%81java%20%E4%B8%AD%20IO%20%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F" rel="nofollow">十四、java 中 IO 流分为几种？</a></p> 
<p id="%E5%8D%81%E4%BA%94%E3%80%81BIO%E3%80%81NIO%E3%80%81AIO%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%BA%94%E3%80%81BIO%E3%80%81NIO%E3%80%81AIO%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">十五、BIO、NIO、AIO 有什么区别？</a></p> 
<p id="%E5%8D%81%E5%85%AD%E3%80%81Files%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E5%85%AD%E3%80%81Files%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow">十六、Files的常用方法都有哪些？</a></p> 
<p id="%E5%8D%81%E4%B8%83%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%B8%83%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F" rel="nofollow">十七、什么是反射？</a></p> 
<p id="%E5%8D%81%E5%85%AB%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20java%20%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E5%85%AB%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20java%20%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F" rel="nofollow">十八、什么是 java 序列化？什么情况下需要序列化？</a></p> 
<p id="%E5%8D%81%E4%B9%9D%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%B9%9D%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">十九、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？</a></p> 
<p id="%E2%80%8B-toc" style="margin-left:40px;"><a href="#%E2%80%8B" rel="nofollow">​</a><a href="#%E4%BA%8C%E5%8D%81%E3%80%81throw%20%E5%92%8C%20throws%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">二十、throw 和 throws 的区别？</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81final%E3%80%81finally%E3%80%81finalize%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81final%E3%80%81finally%E3%80%81finalize%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">二十一、final、finally、finalize 有什么区别？</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81try-catch-finally%20%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%20catch%20%E4%B8%AD%20return%20%E4%BA%86%EF%BC%8Cfinally%20%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81try-catch-finally%20%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%20catch%20%E4%B8%AD%20return%20%E4%BA%86%EF%BC%8Cfinally%20%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F" rel="nofollow">二十二、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow">二十三、常见的异常类有哪些？</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81hashcode%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81hashcode%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F" rel="nofollow">二十四、hashcode是什么？有什么作用？</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81java%20%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81java%20%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">二十五、java 中操作字符串都有哪些类？它们之间有什么区别？</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E5%85%AD%E3%80%81java%20%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8D%81%E5%85%AD%E3%80%81java%20%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F" rel="nofollow">二十六、java 中都有哪些引用类型？</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%B8%83%E3%80%81%E5%9C%A8%20Java%20%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BB%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%9D%9E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8D%81%E4%B8%83%E3%80%81%E5%9C%A8%20Java%20%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BB%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%9D%9E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%9F" rel="nofollow">二十七、在 Java 中，为什么不允许从静态方法中访问非静态变量？</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%AF%B4%E8%AF%B4Java%20Bean%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%AF%B4%E8%AF%B4Java%20Bean%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83" rel="nofollow">二十八、说说Java Bean的命名规范</a></p> 
<p id="%E4%BA%8C%E5%8D%81%E4%B9%9D%E3%80%81Java%20Bean%20%E5%B1%9E%E6%80%A7%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E5%8D%81%E4%B9%9D%E3%80%81Java%20Bean%20%E5%B1%9E%E6%80%A7%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90" rel="nofollow">二十九、Java Bean 属性命名规范问题分析</a></p> 
<p id="%E4%B8%89%E5%8D%81%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20Java%20%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%3F-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E5%8D%81%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20Java%20%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%3F" rel="nofollow">三十、什么是 Java 的内存模型?</a></p> 
<p id="%E4%B8%89%E5%8D%81%E4%B8%80%E3%80%81%E5%9C%A8%20Java%20%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E5%86%99%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E5%8D%81%E4%B8%80%E3%80%81%E5%9C%A8%20Java%20%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E5%86%99%EF%BC%9F" rel="nofollow">三十一、在 Java 中，什么时候用重载，什么时候用重写？</a></p> 
<p id="%E4%B8%89%E5%8D%81%E4%BA%8C%E3%80%81%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%9B%B4%E5%80%BE%E5%90%91%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8E%A5%E5%8F%A3%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E5%8D%81%E4%BA%8C%E3%80%81%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%9B%B4%E5%80%BE%E5%90%91%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8E%A5%E5%8F%A3%EF%BC%9F" rel="nofollow">三十二、举例说明什么情况下会更倾向于使用抽象类而不是接口？</a></p> 
<p id="%E4%B8%89%E5%8D%81%E4%B8%89%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E5%8D%81%E4%B8%89%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">三十三、实例化对象有哪几种方式</a></p> 
<p id="%E4%B8%89%E5%8D%81%E5%9B%9B%E3%80%81byte%E7%B1%BB%E5%9E%8B127%2B1%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E5%8D%81%E5%9B%9B%E3%80%81byte%E7%B1%BB%E5%9E%8B127%2B1%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91" rel="nofollow">三十四、byte类型127+1等于多少</a></p> 
<hr id="hr-toc"> 
<h3 id="%E4%B8%80%E3%80%81JDK%20%E5%92%8C%20JRE%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">一、JDK 和 JRE 有什么区别？</h3> 
<p>JDK（Java Development Kit），Java开发工具包</p> 
<p>JRE（Java Runtime Environment），Java运行环境</p> 
<p>JDK中包含JRE，JDK中有一个名为jre的目录，里面包含两个文件夹bin和lib，bin就是JVM，lib就是JVM工作所需要的类库。</p> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/104247758" title="49天精通Java，第8天，JDK 和 JRE 、final 与 static 、堆和栈">49天精通Java，第8天，JDK 和 JRE 、final 与 static 、堆和栈</a></p> 
<h3 id="%E4%BA%8C%E3%80%81%3D%3D%20%E5%92%8C%20equals%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><a name="t2"></a>二、== 和 equals 的区别是什么？</h3> 
<ol><li>对于基本类型，==比较的是值；</li><li>对于引用类型，==比较的是地址；</li><li>equals不能用于基本类型的比较；</li><li>如果没有重写equals，equals就相当于==；</li><li>如果重写了equals方法，equals比较的是对象的内容；</li></ol> 
<h3 id="%E4%B8%89%E3%80%81final%20%E5%9C%A8%20java%20%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><a name="t3"></a>三、final 在 java 中有什么作用？</h3> 
<ol><li>final修饰的成员变量，必须在声明的同时赋值，一旦创建不可修改；</li><li>final修饰的方法，不能被子类重写；</li><li>final类中的方法默认是final的；</li><li>private类型的方法默认是final的；</li></ol> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/121191475" title="49天精通Java，第9天，java final关键字">49天精通Java，第9天，java final关键字</a></p> 
<h3 id="%E5%9B%9B%E3%80%81java%20%E4%B8%AD%E7%9A%84%20Math.round(-1.5)%20%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91%EF%BC%9F"><a name="t4"></a>四、java 中的 Math.round(-1.5) 等于多少？</h3> 
<p>Math提供了三个与取整有关的方法：ceil、floor、round</p> 
<p>1、ceil：向上取整；</p> 
<p>Math.ceil(11.3) = 12;</p> 
<p>Math.ceil(-11.3) = 11;</p> 
<p>2、floor：向下取整；</p> 
<p>Math.floor(11.3) = 11;</p> 
<p>Math.floor(-11.3) = -12;</p> 
<p>3、round：四舍五入；</p> 
<p>加0.5然后向下取整。</p> 
<p>Math.round(11.3) = 11;</p> 
<p>Math.round(11.8) = 12;</p> 
<p>Math.round(-11.3) = -11;</p> 
<p>Math.round(-11.8) = -12;</p> 
<h3 id="%E4%BA%94%E3%80%81String%20%E5%B1%9E%E4%BA%8E%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><a name="t5"></a>五、String 属于基础的数据类型吗？</h3> 
<p>不属于。</p> 
<p>八种基本数据类型：byte、short、char、int、long、double、float、boolean。</p> 
<h3 id="%E5%85%AD%E3%80%81String%20str%3D%22i%22%E4%B8%8E%20String%20str%3Dnew%20String(%E2%80%9Ci%E2%80%9D)%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F"><a name="t6"></a>六、String str="i"与 String str=new String(“i”)一样吗？</h3> 
<p>String str="i"会将起分配到常量池中，常量池中没有重复的元素，如果常量池中存中i，就将i的地址赋给变量，如果没有就创建一个再赋给变量。</p> 
<p>String str=new String(“i”)会将对象分配到堆中，即使内存一样，还是会重新创建一个新的对象。</p> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/120240687" title="【Java基础知识 8】String、StringBuilder、StringBuffer详解">【Java基础知识 8】String、StringBuilder、StringBuffer详解</a></p> 
<h3 id="%E4%B8%83%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F"><a name="t7"></a>七、如何将字符串反转？</h3> 
<p>将对象封装到stringBuilder中，调用reverse方法反转。</p> 
<p><img alt="" src="https://images2.imgbox.com/fe/8f/rTdfzISh_o.png"></p> 
<h3 id="%E5%85%AB%E3%80%81String%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><a name="t8"></a>八、String 类的常用方法都有那些？</h3> 
<p>1、常见String类的获取功能</p> 
<ul><li>length：获取字符串长度；</li><li>charAt(int index)：获取指定索引位置的字符；</li><li>indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引；</li><li>substring(int start)：从指定位置开始截取字符串,默认到末尾；</li><li>substring(int start,int end)：从指定位置开始到指定位置结束截取字符串；</li></ul> 
<p>2、常见String类的判断功能</p> 
<ul><li>equals(Object obj)： 比较字符串的内容是否相同,区分大小写；</li><li>contains(String str): 判断字符串中是否包含传递进来的字符串；</li><li>startsWith(String str): 判断字符串是否以传递进来的字符串开头；</li><li>endsWith(String str): 判断字符串是否以传递进来的字符串结尾；</li><li>isEmpty(): 判断字符串的内容是否为空串""；</li></ul> 
<p>3、常见String类的转换功能</p> 
<ul><li>byte[] getBytes(): 把字符串转换为字节数组；</li><li>char[] toCharArray(): 把字符串转换为字符数组；</li><li>String valueOf(char[] chs): 把字符数组转成字符串。valueOf可以将任意类型转为字符串；</li><li>toLowerCase(): 把字符串转成小写；</li><li>toUpperCase(): 把字符串转成大写；</li><li>concat(String str): 把字符串拼接；</li></ul> 
<p>4、常见String类的其他常用功能</p> 
<ul><li>replace(char old,char new) 将指定字符进行互换</li><li>replace(String old,String new) 将指定字符串进行互换</li><li>trim() 去除两端空格</li><li>int compareTo(String str) 会对照ASCII 码表 从第一个字母进行减法运算 返回的就是这个减法的结果，如果前面几个字母一样会根据两个字符串的长度进行减法运算返回的就是这个减法的结果，如果连个字符串一摸一样 返回的就是0。</li></ul> 
<p><img alt="" src="https://images2.imgbox.com/65/bd/6NQ88nrw_o.png"></p> 
<h3 id="%E4%B9%9D%E3%80%81new%20String(%22a%22)%20%2B%20new%20String(%22b%22)%20%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><a name="t9"></a>九、new String("a") + new String("b") 会创建几个对象？</h3> 
<p>对象1：new StringBuilder()</p> 
<p>对象2：new String("a")</p> 
<p>对象3：常量池中的"a"</p> 
<p>对象4：new String("b")</p> 
<p>对象5：常量池中的"b"</p> 
<p>深入剖析：StringBuilder中的toString()：</p> 
<p>对象6：new String("ab")</p> 
<p>强调一下，toString()的调用，在字符串常量池中，没有生成"ab"</p> 
<p>附加题：</p> 
<blockquote> 
 <p>String s1 = new String("1") + new String("1");//s1变量记录的地址为：new String<br> s1.intern();//在字符串常量池中生成"11"。如何理解：jdk6：创建了一个新的对象"11"，也就有新的地址；jdk7：此时常量池中并没有创建"11"，而是创建了一个指向堆空间中new String("11")的地址；<br> String s2 = "11";<br> System.out.println(s1 == s2);//jdk6:false;jdk7:true</p> 
</blockquote> 
<h3 id="%E5%8D%81%E3%80%81%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F"><a name="t10"></a>十、如何将字符串反转？</h3> 
<p>添加到StringBuilder中，然后调用reverse()。</p> 
<h3 id="%E5%8D%81%E4%B8%80%E3%80%81String%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><a name="t11"></a>十一、String 类的常用方法都有那些？</h3> 
<p>equals、length、contains、replace、split、hashcode、indexof、substring、trim、toUpperCase、toLowerCase、isEmpty等等。</p> 
<h3 id="%E5%8D%81%E4%BA%8C%E3%80%81%E6%99%AE%E9%80%9A%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><a name="t12"></a>十二、普通类和抽象类有哪些区别？</h3> 
<ol><li>抽象类不能被实例化；</li><li>抽象类可以有抽象方法，只需申明，无须实现；</li><li>有抽象方法的类一定是抽象类；</li><li>抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类；</li><li>抽象方法不能声明为静态、不能被static、final修饰。</li></ol> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/129963398" title="49天精通Java，第11天，java接口和抽象类的异同，default关键字">49天精通Java，第11天，java接口和抽象类的异同，default关键字</a></p> 
<h3 id="%E5%8D%81%E4%B8%89%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><a name="t13"></a>十三、接口和抽象类有什么区别？</h3> 
<p>1、接口</p> 
<ul><li>接口使用interface修饰；</li><li>接口不能实例化；</li><li>类可以实现多个接口；</li><li>①java8之前，接口中的方法都是抽象方法，省略了public abstract。②java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；</li></ul> 
<p>2、抽象类</p> 
<ul><li>抽象类使用abstract修饰；</li><li>抽象类不能被实例化；</li><li>抽象类只能单继承；</li><li>抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；</li><li>如果一个类继承了抽象类，①如果实现了所有的抽象方法，子类可以不是抽象类；②如果没有实现所有的抽象方法，子类仍然是抽象类。</li></ul> 
<h3 id="%E5%8D%81%E5%9B%9B%E3%80%81java%20%E4%B8%AD%20IO%20%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F"><a name="t14"></a>十四、java 中 IO 流分为几种？</h3> 
<p>1、按流划分，可以分为输入流和输出流；</p> 
<p>2、按单位划分，可以分为字节流和字符流；</p> 
<p>字节流：inputStream、outputStream；</p> 
<p>字符流：reader、writer；</p> 
<h3 id="%E5%8D%81%E4%BA%94%E3%80%81BIO%E3%80%81NIO%E3%80%81AIO%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><a name="t15"></a>十五、BIO、NIO、AIO 有什么区别？</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/123589971" title="一篇文章带你彻底吃透Java NIO">一篇文章带你彻底吃透Java NIO</a></p> 
<p>1、同步阻塞BIO</p> 
<p>一个连接一个线程。</p> 
<p>JDK1.4之前，建立网络连接的时候采用BIO模式，先在启动服务端socket，然后启动客户端socket，对服务端通信，客户端发送请求后，先判断服务端是否有线程响应，如果没有则会一直等待或者遭到拒绝请求，如果有的话会等待请求结束后才继续执行。</p> 
<p>2、同步非阻塞NIO</p> 
<p>NIO主要是想解决BIO的大并发问题，BIO是每一个请求分配一个线程，当请求过多时，每个线程占用一定的内存空间，服务器瘫痪了。</p> 
<p>JDK1.4开始支持NIO，适用于连接数目多且连接比较短的架构，比如聊天服务器，并发局限于应用中。</p> 
<p>一个请求一个线程。</p> 
<p>3、异步非阻塞AIO</p> 
<p>一个有效请求一个线程。</p> 
<p>JDK1.7开始支持AIO，适用于连接数目多且连接比较长的结构，比如相册服务器，充分调用OS参与并发操作。</p> 
<h3 id="%E5%8D%81%E5%85%AD%E3%80%81Files%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><a name="t16"></a>十六、Files的常用方法都有哪些？</h3> 
<ol><li>exist</li><li>createFile</li><li>createDirectory</li><li>write</li><li>read</li><li>copy</li><li>size</li><li>delete</li><li>move</li></ol> 
<h3 id="%E5%8D%81%E4%B8%83%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><a name="t17"></a>十七、什么是反射？</h3> 
<p>所谓反射，是java在运行时进行自我观察的能力，通过class、constructor、field、method四个方法获取一个类的各个组成部分。</p> 
<p>在Java运行时环境中，对任意一个类，可以知道类有哪些属性和方法。这种动态获取类的信息以及动态调用对象的方法的功能来自于反射机制。</p> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/108351185" title="【Java基础知识 15】java反射机制原理详解">【Java基础知识 15】java反射机制原理详解</a></p> 
<h3 id="%E5%8D%81%E5%85%AB%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20java%20%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><a name="t18"></a>十八、什么是 java 序列化？什么情况下需要序列化？</h3> 
<p>序列化就是一种用来处理对象流的机制。将对象的内容流化，将流化后的对象传输于网络之间。</p> 
<p>序列化是通过实现serializable接口，该接口没有需要实现的方法，implement Serializable只是为了标注该对象是可被序列化的，使用一个输出流（FileOutputStream）来构造一个ObjectOutputStream对象，接着使用ObjectOutputStream对象的writeObejct（Object object）方法就可以将参数的obj对象到磁盘，需要恢复的时候使用输入流。</p> 
<p>序列化是将对象转换为容易传输的格式的过程。</p> 
<p>例如，可以序列化一个对象，然后通过HTTP通过Internet在客户端和服务器之间传输该对象。在另一端，反序列化将从流中心构造成对象。</p> 
<p>一般程序在运行时，产生对象，这些对象随着程序的停止而消失，但我们想将某些对象保存下来，这时，我们就可以通过序列化将对象保存在磁盘，需要使用的时候通过反序列化获取到。</p> 
<p>对象序列化的最主要目的就是传递和保存对象，保存对象的完整性和可传递性。</p> 
<p>譬如通过网络传输或者把一个对象保存成本地一个文件的时候，需要使用序列化。</p> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/128027906" title="Java序列化与反序列化详解">Java序列化与反序列化详解</a></p> 
<h3 id="%E5%8D%81%E4%B9%9D%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><a name="t19"></a>十九、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？</h3> 
<p>1、什么要使用克隆？</p> 
<p>想对一个对象进行复制，又想保留原有的对象进行接下来的操作，这个时候就需要克隆了。</p> 
<p>2、如何实现对象克隆？</p> 
<ol><li>实现Cloneable接口，重写clone方法；</li><li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。</li><li>BeanUtils，apache和Spring都提供了bean工具，只是这都是浅克隆。</li></ol> 
<p>3、深拷贝和浅拷贝区别是什么？</p> 
<ul><li>浅拷贝：仅仅克隆基本类型变量，不克隆引用类型变量；</li><li>深克隆：既克隆基本类型变量，又克隆引用类型变量；</li></ul> 
<p>4、代码实例</p> 
<p></p> 
<h3 id="%E2%80%8B"><a name="t20"></a><img alt="" src="https://images2.imgbox.com/94/4e/8Szi38Ba_o.png"></h3> 
<h3><a name="t21"></a><img alt="" src="https://images2.imgbox.com/56/b9/8cm838iH_o.png"></h3> 
<h3 id="%E4%BA%8C%E5%8D%81%E3%80%81throw%20%E5%92%8C%20throws%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">二十、throw 和 throws 的区别？</h3> 
<p>1、throw</p> 
<ul><li>作用在方法内，表示抛出具体异常，由方法体内的语句处理；</li><li>一定抛出了异常；</li></ul> 
<p>2、throws</p> 
<ul><li>作用在方法的声明上，表示抛出异常，由调用者来进行异常处理；</li><li>可能出现异常，不一定会发生异常；</li></ul> 
<h3 id="%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81final%E3%80%81finally%E3%80%81finalize%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><a name="t22"></a>二十一、final、finally、finalize 有什么区别？</h3> 
<p>final可以修饰类，变量，方法，修饰的类不能被继承，修饰的变量不能重新赋值，修饰的方法不能被重写</p> 
<p>finally用于抛异常，finally代码块内语句无论是否发生异常，都会在执行finally，常用于一些流的关闭。</p> 
<p>finalize方法用于垃圾回收。</p> 
<p>一般情况下不需要我们实现finalize，当对象被回收的时候需要释放一些资源，比如socket链接，在对象初始化时创建，整个生命周期内有效，那么需要实现finalize方法，关闭这个链接。</p> 
<p>但是当调用finalize方法后，并不意味着gc会立即回收该对象，所以有可能真正调用的时候，对象又不需要回收了，然后到了真正要回收的时候，因为之前调用过一次，这次又不会调用了，产生问题。所以，不推荐使用finalize方法。</p> 
<h3 id="%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81try-catch-finally%20%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%20catch%20%E4%B8%AD%20return%20%E4%BA%86%EF%BC%8Cfinally%20%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><a name="t23"></a>二十二、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3> 
<p><a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/120190080" title="【Java基础知识 6】Java异常详解">【Java基础知识 6】Java异常详解</a></p> 
<p><img alt="" src="https://images2.imgbox.com/bf/6c/GZwnSPIQ_o.png"></p> 
<h3 id="%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><a name="t24"></a>二十三、常见的异常类有哪些？</h3> 
<ol><li>NullPointerException：空指针异常；</li><li>SQLException：数据库相关的异常；</li><li>IndexOutOfBoundsException：数组下角标越界异常；</li><li>FileNotFoundException：打开文件失败时抛出；</li><li>IOException：当发生某种IO异常时抛出；</li><li>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出此异常；</li><li>NoSuchMethodException：无法找到某一方法时，抛出；</li><li>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常；</li><li>NumberFormatException：当试图将字符串转换成数字时，失败了，抛出；</li><li>IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。</li><li>ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 </li></ol> 
<h3 id="%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81hashcode%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><a name="t25"></a>二十四、hashcode是什么？有什么作用？</h3> 
<p>Java中Object有一个方法：</p> 
<p>public native int hashcode();</p> 
<p>1、hashcode()方法的作用</p> 
<p>hashcode()方法主要配合基于散列的集合一起使用，比如HashSet、HashMap、HashTable。</p> 
<p>当集合需要添加新的对象时，先调用这个对象的hashcode()方法，得到对应的hashcode值，实际上hashmap中会有一个table保存已经存进去的对象的hashcode值，如果table中没有改hashcode值，则直接存入，如果有，就调用equals方法与新元素进行比较，相同就不存了，不同就存入。</p> 
<p>2、equals和hashcode的关系</p> 
<p>如果equals为true，hashcode一定相等； </p> 
<p>如果equals为false，hashcode不一定不相等；</p> 
<p>如果hashcode值相等，equals不一定相等；</p> 
<p>如果hashcode值不等，equals一定不等；</p> 
<p>3、重写equals方法时，一定要重写hashcode方法</p> 
<p>4、百度百科</p> 
<blockquote> 
 <p>hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。 </p> 
 <p>hashCode 的常规协定是： <br> 在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 <br> 如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。 <br> 以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。 <br> 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） </p> 
 <p>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p> 
</blockquote> 
<p><a name="t26"></a>5、小白解释</p> 
<blockquote> 
 <p>1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有<br> 例如内存中有这样的位置<br> 0  1  2  3  4  5  6  7  <br> 而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。<br> 但如果用hashcode那就会使效率提高很多。<br> 我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。</p> 
 <p>2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。<br> 也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。<br> 那么。重写了equals()，为什么还要重写hashCode()呢？<br> 想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊。</p> 
</blockquote> 
<h3 id="%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81java%20%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">二十五、java 中操作字符串都有哪些类？它们之间有什么区别？</h3> 
<p>1、String</p> 
<p>String是不可变对象，每次对String类型的改变时都会生成一个新的对象。</p> 
<p>2、StringBuilder</p> 
<p>线程不安全，效率高，多用于单线程。</p> 
<p>3、StringBuffer</p> 
<p>线程安全，由于加锁的原因，效率不如StringBuilder，多用于多线程。</p> 
<p>不频繁的字符串操作使用String，操作频繁的情况不建议使用String。</p> 
<p>StringBuilder &gt; StringBuffer &gt; String。</p> 
<h3 id="%E4%BA%8C%E5%8D%81%E5%85%AD%E3%80%81java%20%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F"><a name="t27"></a>二十六、java 中都有哪些引用类型？</h3> 
<p>1、强引用</p> 
<p>Java中默认声明的就是强引用，比如：</p> 
<pre><code class="language-java">Object obj = new Object();
obj = null;</code></pre> 
<p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象。如果想被回收，可以将对象置为null； </p> 
<p>2、软引用（SoftReference）</p> 
<p>在内存足够的时候，软引用不会被回收，只有在内存不足时，系统才会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会跑出内存溢出异常。</p> 
<pre><code class="language-java">byte[] buff = new byte[1024 * 1024];
SoftReference&lt;byte[]&gt; sr = new SoftReference&lt;&gt;(buff);</code></pre> 
<p><span style="color:#4d4d4d;">3、弱引用（WeakReference）</span></p> 
<p>进行垃圾回收时，弱引用就会被回收。</p> 
<p>4、虚引用（PhantomReference）</p> 
<p>5、引用队列（ReferenceQueue）</p> 
<p>引用队列可以与软引用、弱引用、虚引用一起配合使用。</p> 
<p>当垃圾回收器准备回收一个对象时，如果发现它还有引用，就会在回收对象之前，把这个引用加入到引用队列中。</p> 
<p>程序可以通过判断引用队列中是否加入了引用，来判断被引用的对象是否将要被垃圾回收，这样可以在对象被回收之前采取一些必要的措施。</p> 
<h3 id="%E4%BA%8C%E5%8D%81%E4%B8%83%E3%80%81%E5%9C%A8%20Java%20%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BB%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%9D%9E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%9F">二十七、在 Java 中，为什么不允许从静态方法中访问非静态变量？</h3> 
<ol><li>静态变量属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问；</li><li>非静态变量属于类的对象，只有在类的对象产生时，才会分配内存，通过类的实例去访问；</li><li>静态方法也属于类本身，但是此时没有类的实例，内存中没有非静态变量，所以无法调用。</li></ol> 
<h3 id="%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%AF%B4%E8%AF%B4Java%20Bean%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">二十八、说说Java Bean的命名规范</h3> 
<ol><li>JavaBean 类必须是一个公共类，并将其访问属性设置为 public</li><li>JavaBean 类必须有一个空的构造函数：类中必须有一个不带参数的公用构造器，此构造器也应该通过调用各个特性的设置方法来设置特性的缺省值。</li><li>一个javaBean类不应有公共实例变量，类变量都为private</li><li>持有值应该通过一组存取方法（getXxx 和 setXxx）来访问：对于每个特性，应该有一个带匹配公用 getter 和 setter 方法的专用实例变量。</li></ol> 
<p>属性为布尔类型，可以使用 isXxx() 方法代替 getXxx() 方法。</p> 
<p>通常属性名是要和 包名、类名、方法名、字段名、常量名作出区别的:</p> 
<p>首先:必须用英文，不要用汉语拼音</p> 
<p>1、包(package)</p> 
<p>用于将完成不同功能的类分门别类，放在不同的目录(包)下，包的命名规则：将公司域名反转作为包名。比如www.sohu.com 对于包名：每个字母都需要小写。比如：com.sohu.test;该包下的Test类的全名是：com.sohu.Test.Java 。</p> 
<p>如果定义类的时候没有使用package,那么java就认为我们所定义的类位于默认包里面(default package)。</p> 
<p>2、类</p> 
<p>首字母大写，如果一个类由多个单词构成，那么每个单词的首字母都大写，而且中间不使用任何的连接符。尽量使用英文。如ConnectionFactory</p> 
<p>3、方法</p> 
<p>首单词全部小写，如果一个方法由多个单词构成，那么从第二个单词开始首字母大写，不使用连接符。addPerson</p> 
<p>4、字段</p> 
<p>与方法相同。如ageOfPerson</p> 
<p>5、常量</p> 
<p>所有单词的字母都是大写，如果有多个单词，那么使用下划线链接即可。</p> 
<p>如：public static final int AGE_OF_PERSON = 20; //通常加上static</p> 
<h3 id="%E4%BA%8C%E5%8D%81%E4%B9%9D%E3%80%81Java%20Bean%20%E5%B1%9E%E6%80%A7%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><a name="t28"></a>二十九、Java Bean 属性命名规范问题分析</h3> 
<pre><code class="language-java">public class User {
	private String busName;
	private String pCount;
	private Boolean isRunning;
	//正确的命名方式，驼峰式的
	public String getBusName() {
		return busName;
	}
	public void setBusName(String busName) {
		this.busName = busName;
	}
    //这是什么？
	public String getpCount() {
		return pCount;
	}
	public void setpCount(String pCount) {
		this.pCount = pCount;
	}
    //这个也是不允许的
	public Boolean getIsRunning() {
		return isRunning;
	}
	public void setIsRunning(Boolean isRunning) {
		this.isRunning = isRunning;
	}
}</code></pre> 
<p>1. javabean属性命名尽量使用常规的驼峰式命名规则<br> 2. 属性名第一个单词尽量避免使用一个字母：如eBook， eMail。<br> 3. boolean属性名避免使用 “is” 开头的名称<br> 4. 随着jdk， eclipse， spring 等软件版本的不断提高， 底版本的出现的问题可能在高版本中解决了， 低版本原来正常的代码可能在高版本环境下不再支持。</p> 
<h3 id="%E4%B8%89%E5%8D%81%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20Java%20%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%3F"><a name="t29"></a>三十、什么是 Java 的内存模型?</h3> 
<p>在了解什么是 Java 内存模型之前，先了解一下为什么要提出 Java 内存模型。</p> 
<p>之前提到过并发编程有三大问题</p> 
<ol><li>CPU 缓存，在多核 CPU 的情况下，带来了可见性问题</li><li>操作系统对当前执行线程的切换，带来了原子性问题</li><li>译器指令重排优化，带来了有序性问题</li></ol> 
<p>为了解决并发编程的三大问题，提出了 JSR-133，新的 Java 内存模型，JDK 5 开始使用。</p> 
<p>简单总结下</p> 
<ol><li>Java 内存模型是 JVM 的一种规范</li><li>定义了共享内存在多线程程序中读写操作行为的规范</li><li>屏蔽了各种硬件和操作系统的访问差异，保证了 Java 程序在各种平台下对内存的访问效果一致</li><li>解决并发问题采用的方式：限制处理器优化和使用内存屏障</li><li>增强了三个同步原语（synchronized、volatile、final）的内存语义</li><li>定义了 happens-before 规则</li></ol> 
<h3 id="%E4%B8%89%E5%8D%81%E4%B8%80%E3%80%81%E5%9C%A8%20Java%20%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%87%8D%E5%86%99%EF%BC%9F"><a name="t30"></a>三十一、在 Java 中，什么时候用重载，什么时候用重写？</h3> 
<p>1、重载是多态的集中体现，在类中，要以统一的方式处理不同类型数据的时候，可以用重载。</p> 
<p>2、重写的使用是建立在继承关系上的，子类在继承父类的基础上，增加新的功能，可以用重写。</p> 
<p>3、简单总结：</p> 
<ol><li>重载是多样性，重写是增强剂；</li><li>目的是提高程序的多样性和健壮性，以适配不同场景使用时，使用重载进行扩展；</li><li>目的是在不修改原方法及源代码的基础上对方法进行扩展或增强时，使用重写；</li></ol> 
<p>生活例子：</p> 
<blockquote> 
 <p>你想吃一碗面，我给你提供了拉面，炒面，刀削面，担担面供你选择，这是重载；<br> 你想吃一碗面，我不但给你端来了面，还给你加了青菜，加了鸡蛋，这个是重写；</p> 
</blockquote> 
<p>设计模式：</p> 
<blockquote> 
 <p>cglib实现动态代理，核心原理用的就是方法的重写；</p> 
</blockquote> 
<p>详细解答：</p> 
<blockquote> 
 <p>Java的重载(overload) 最重要的应用场景就是构造器的重载，构造器重载后，提供多种形参形式的构造器，可以应对不同的业务需求，加强程序的健壮性和可扩展性，比如我们最近学习的Spring源码中的ClassPathXmlApplicationContext，它的构造函数使用重载一共提供了10个构造函数，这样就为业务的选择提供了多选择性。在应用到方法中时，主要是为了增强方法的健壮性和可扩展性，比如我们在开发中常用的各种工具类，比如我目前工作中的短信工具类SMSUtil, 发短信的方法就会使用重载，针对不同业务场景下的不同形参，提供短信发送方法，这样提高了工具类的扩展性和健壮性。<br> 总结：重载必须要修改方法(构造器)的形参列表，可以修改方法的返回值类型，也可以修改方法的异常信息即访问权限；使用范围是在同一个类中，目的是对方法(构造器)进行功能扩展，以应对多业务场景的不同使用需求。提高程序的健壮性和扩展性。<br>  java的重写(override) 只要用于子类对父类方法的扩展或修改，但是在我们开发中，为了避免程序混乱，重写一般都是为了方法的扩展，比如在cglib方式实现的动态代理中，代理类就是继承了目标类，对目标类的方法进行重写，同时在方法前后进行切面织入。</p> 
</blockquote> 
<p>总结：方法重写时，参数列表，返回值得类型是一定不能修改的，异常可以减少或者删除，但是不能抛出新的异常或者更广的异常，方法的访问权限可以降低限制，但是不能做更严格的限制。</p> 
<p>4、在里氏替换原则中，子类对父类的方法尽量不要重写和重载。（我们可以采用final的手段强制来遵循）</p> 
<h3 id="%E4%B8%89%E5%8D%81%E4%BA%8C%E3%80%81%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%9B%B4%E5%80%BE%E5%90%91%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8E%A5%E5%8F%A3%EF%BC%9F"><a name="t31"></a>三十二、举例说明什么情况下会更倾向于使用抽象类而不是接口？</h3> 
<p>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：在 Java 中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。</p> 
<p>接口通常被用来表示附属描述或行为如： Runnable 、 Clonable 、 Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable( 注：这里的意思是指如果把 Runnable 等实现为抽象类的情况 ) ，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</p> 
<p>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</p> 
<h3 id="%E4%B8%89%E5%8D%81%E4%B8%89%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><a name="t32"></a>三十三、实例化对象有哪几种方式</h3> 
<ul><li>new</li><li>clone()</li><li>通过反射机制创建</li></ul> 
<pre><code class="language-java">//用 Class.forName方法获取类，在调用类的newinstance（）方法
Class&lt;?&gt; cls = Class.forName("com.dao.User");
User u = (User)cls.newInstance();</code></pre> 
<ul><li>序列化反序列化</li></ul> 
<pre><code class="language-java">//将一个对象实例化后，进行序列化，再反序列化，也可以获得一个对象（远程通信的场景下使用）
ObjectOutputStream out = new ObjectOutputStream (new FileOutputStream("D:/data.txt"));
//序列化对象
out.writeObject(user1); 
out.close();
//反序列化对象
ObjectInputStream in = new ObjectInputStream(new FileInputStream("D:/data.txt"));
User user2 = (User) in.readObject();
System.out.println("反序列化user：" + user2);
in.close();</code></pre> 
<h3 id="%E4%B8%89%E5%8D%81%E5%9B%9B%E3%80%81byte%E7%B1%BB%E5%9E%8B127%2B1%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91">三十四、byte类型127+1等于多少</h3> 
<p>byte的范围是-128~127。</p> 
<p>字节长度为8位，最左边的是符号位，而127的二进制为01111111，所以执行+1操作时，01111111变为10000000。</p> 
<p>大家知道，计算机中存储负数，存的是补码的兴衰。左边第一位为符号位。</p> 
<p>那么负数的补码转换成十进制如下：</p> 
<p>一个数如果为正，则它的原码、反码、补码相同；一个正数的补码，将其转化为十进制，可以直接转换。</p> 
<p>已知一个负数的补码，将其转换为十进制数，步骤如下：</p> 
<ol><li>先对各位取反；</li><li>将其转换为十进制数；</li><li>加上负号，再减去1；</li></ol> 
<p>例如10000000，最高位是1，是负数，①对各位取反得01111111，转换为十进制就是127，加上负号得-127，再减去1得-128；</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/77/7b/hEjXGqtH_o.gif"></p> 
<p> 🏆本文收录于，<a class="link-info" href="https://blog.csdn.net/guorui_java/category_12196381.html" title="Java基础教程（进阶篇）">Java基础教程（进阶篇）</a></p> 
<p>目前已经700+订阅，CSDN最强Java专栏，包含全部Java基础知识点、Java8新特性、Java集合、Java多线程、Java代码实例，理论结合实战，实现Java的轻松学习。</p> 
<p>🏆哪吒多年工作总结：<a class="link-info" href="https://blog.csdn.net/guorui_java/article/details/120098618" title="Java学习路线总结，搬砖工逆袭Java架构师">Java学习路线总结，搬砖工逆袭Java架构师</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d5d9b5b48ffdb710611c09442a948bfc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">torch.cuda.OutOfMemoryError: CUDA out of memory.</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f0e019484ab27db90df41d9145bc40d9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Centos 8升级至Centos 8 Stream教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>