<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HCLA - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HCLA" />
<meta property="og:description" content="1、网络:是由网络连接设备（路由器、交换机等）通过传输介质（网线、光纤等）将网络终端设备（计算机、服务器等）连接起来进行数据交换、资源共享的平台
注释：服务器：指一台安装了服务操作系统的电脑
2、OSI七层参考模型（开放式系统互联模型）
OSI被分为七层：
1、应用层：通过人机交互来实现各种各样的服务
2、表示层 ：编码 解码 加密 解密
3、会话层：发现 建立 维持 终止会话进程
4、传输层：通过端口号来区分不同的服务
端口号（0-65535）又分为：1、静态端口号 2、动态端口号
1、静态端口号（1-1023）：
一个端口号代表一个服务，且成永久绑定关系
2、动态端口号（1024-65535）：
一个端口号代表一个服务，且呈暂时性绑定关系
0-—特殊端口号—保留端口号（在网络编程中使用代表所有端口号）
提供可靠的传输
可靠机制：确认 重传 排序 流控
TCP--传输控制协议
面向连接的可靠传输协议
UDP--用户数据报文协议
非面向连接的不可靠传输协议
面向连接---三次握手 四次挥手
三次握手：
四次挥手：
FIN--请求断开连接
ACK--确认
1、为什么要进行三次握手，握手为什么需要三次？
答：为了防止无效的连接请求报文到达服务器而引起错误
详细解释：
假设A给服务器发送了一个请求，但是由于网络原因迟迟没有到达B服务器。由于一直没收到服务器端的回复确认，所以就进行超时重传，上个就舍弃了，
然后新的请求很快的到达了B服务器，然后B服务器也很快的进行了响应，如果是两次握手的话，这样就建立了连接，但是上次因网络问题迟迟未到的第一个请求这时到达了B服务器，服务器依然会当成新的连接请求进行响应，（服务器只要响应，第二次握手就完成了）这时又会建立连接，这就会出现建立了两个连接的局面，然后这就会出现很多问题，例如服务器端认为完成了握手，可以发送数据了，于是一直处于等待数据状态，而发送端不理睬服务器端发来的请求（因为发送端的那个请求早就被清除了），不去发送数据，后果就是服务器一直等，这样就会浪费很多服务器资源
如果是三次握手的话，就会避免这个问题，因为比如第二次的新请求
2、挥手为什么需要四次？三次不可以吗？
答：确保数据能够完整传输。
当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。
但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，（按照常理的话，第二次和第三次挥手应该一起回复FIN=1和ACK=1的，但是因为服务器端可能有数据没发完，所以不能也立刻去主动申请关闭，所以要把ACK和FIN分开）
再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。
5、网络层：
根据IP地址来进行逻辑寻址
IPv4地址---有限的--用完了
IPv6地址---
IP协议--网际网络协议
6、数据链路层：
---交换机
LLC 逻辑链路控制子层
为上层服务提供FCS校验 --封装和解封装
MAC 媒介访问控制子层
根据MAC地址来进行物理寻址
MAC地址--物理地址---设备在出场之后烧录在网卡上的
7、物理层：
定义：电气电压 光学特性 接口规范
tcp报头： Resv---预留位--保留出来的----服务质量---" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7fdbca69314db7e7ea6077356815659c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-31T13:05:30+08:00" />
<meta property="article:modified_time" content="2021-10-31T13:05:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HCLA</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1、网络:是由<span style="color:#fe2c24;">网络连接设备</span>（路由器、交换机等）</strong></strong><strong><strong>通过<span style="color:#fe2c24;">传输介质（网线、光纤等）</span>将<span style="color:#fe2c24;">网络终端设备（计算机、服务器等）</span>连接起来进行数据交换</strong></strong><strong><strong>、</strong></strong><strong><strong>资源共享的平台</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>注释：服务器：指一台安装了服务操作系统的电脑</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2、OSI七层参考模型（开放式系统互联模型）</strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">OSI被分为七层：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1、应用层：通过人机交互来实现各种各样的服务</p> 
<p style="margin-left:.0001pt;text-align:justify;">2、表示层 ：编码 解码 加密 解密</p> 
<p style="margin-left:.0001pt;text-align:justify;">3、会话层：发现 建立 维持 终止会话进程</p> 
<p style="margin-left:.0001pt;text-align:justify;">4、传输层：通过<span style="color:#38d8f0;">端口号</span>来区分不同的服务</p> 
<p>端口号（0-65535）又分为：1、静态端口号  2、动态端口号</p> 
<p>1、静态端口号（1-1023）：</p> 
<p>一个端口号代表一个服务，且成永久绑定关系</p> 
<p>2、动态端口号（1024-65535）：</p> 
<p>一个端口号代表一个服务，且呈暂时性绑定关系</p> 
<p><strong><span style="color:#fe2c24;">0</span></strong>-—特殊端口号—保留端口号（在网络编程中使用代表所有端口号）</p> 
<p style="margin-left:.0001pt;text-align:justify;">提供可靠的传输</p> 
<p style="margin-left:.0001pt;text-align:justify;">可靠机制：<span style="color:#0000ff;">确认</span> <span style="color:#0000ff;">重传</span> 排序 流控</p> 
<p style="margin-left:.0001pt;text-align:justify;">TCP--传输控制协议</p> 
<p style="margin-left:.0001pt;text-align:justify;">面向连接的可靠传输协议</p> 
<p style="margin-left:.0001pt;text-align:justify;">UDP--用户数据报文协议</p> 
<p style="margin-left:.0001pt;text-align:justify;">非面向连接的不可靠传输协议</p> 
<p style="margin-left:.0001pt;text-align:justify;">面向连接---<strong><span style="color:#fe2c24;">三次握手 四次挥手</span></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">三次握手：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/3c/fc/nEsomfZ6_o.png"></p> 
<p></p> 
<p> </p> 
<p style="text-align:center;">四次挥手：<img alt="" src="https://images2.imgbox.com/77/8c/2Ceze3my_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;">FIN--请求断开连接</p> 
<p style="margin-left:.0001pt;text-align:justify;">ACK--确认</p> 
<p style="text-align:justify;"><span style="color:#0000ff;">1、为什么要进行三次握手</span><span style="color:#0000ff;">，</span><span style="color:#0000ff;">握手为什么需要三次</span><span style="color:#0000ff;">？</span></p> 
<p> 答：为了防止无效的连接请求报文到达服务器而引起错误</p> 
<p>详细解释：</p> 
<p>假设A给服务器发送了一个请求，但是由于网络原因迟迟没有到达B服务器。由于一直没收到服务器端的回复确认，所以就进行超时重传，上个就舍弃了，<br> 然后新的请求很快的到达了B服务器，然后B服务器也很快的进行了响应，如果是两次握手的话，这样就建立了连接，但是上次因网络问题迟迟未到的第一个请求这时到达了B服务器，服务器依然会当成新的连接请求进行响应，（服务器只要响应，第二次握手就完成了）这时又会建立连接，这就会出现建立了两个连接的局面，然后这就会出现很多问题，例如服务器端认为完成了握手，可以发送数据了，于是一直处于等待数据状态，而发送端不理睬服务器端发来的请求（因为发送端的那个请求早就被清除了），不去发送数据，后果就是服务器一直等，这样就会浪费很多服务器资源</p> 
<p>如果是三次握手的话，就会避免这个问题，因为比如第二次的新请求<br><span style="color:#4da8ee;">2</span>、<span style="color:#0000ff;">挥手为什么需要四次</span><span style="color:#0000ff;">？</span><span style="color:#0000ff;">三次不可以吗</span><span style="color:#0000ff;">？</span></p> 
<p><span style="color:#0000ff;">答：</span><span style="color:#0d0016;">确保数据能够完整传输。<br> 当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。<br> 但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，（按照常理的话，第二次和第三次挥手应该一起回复FIN=1和ACK=1的，但是因为服务器端可能有数据没发完，所以不能也立刻去主动申请关闭，所以要把ACK和FIN分开）<br> 再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">5、网络层：</p> 
<p style="margin-left:.0001pt;text-align:justify;">根据IP地址来进行逻辑寻址</p> 
<p style="margin-left:.0001pt;text-align:justify;">IPv4地址---有限的--用完了</p> 
<p style="margin-left:.0001pt;text-align:justify;">IPv6地址---</p> 
<p style="margin-left:.0001pt;text-align:justify;">IP协议--网际网络协议</p> 
<p style="margin-left:.0001pt;text-align:justify;">6、数据链路层：</p> 
<p style="margin-left:.0001pt;text-align:justify;">---交换机</p> 
<p style="margin-left:.0001pt;text-align:justify;">LLC 逻辑链路控制子层</p> 
<p style="margin-left:.0001pt;text-align:justify;">为上层服务提供FCS校验 --封装和解封装</p> 
<p style="margin-left:.0001pt;text-align:justify;">MAC 媒介访问控制子层</p> 
<p style="margin-left:.0001pt;text-align:justify;">根据MAC地址来进行物理寻址</p> 
<p style="margin-left:.0001pt;text-align:justify;">MAC地址--物理地址---设备在出场之后烧录在网卡上的</p> 
<p style="margin-left:.0001pt;text-align:justify;">7、物理层：</p> 
<p style="margin-left:.0001pt;text-align:justify;">定义：电气电压 光学特性 接口规范</p> 
<h4><strong>tcp报头：</strong></h4> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/57/ce/TQ6zNqpS_o.png"></strong></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;">Resv---预留位--保留出来的----服务质量---</p> 
<p style="margin-left:.0001pt;text-align:justify;">Rst--重置位 </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">Urg--紧急指针--urgent pointer</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">Ctl ---控制位--只有0和1  为0 不生效 为1 生效</p> 
<p style="margin-left:.0001pt;text-align:justify;">Window size --窗口大小 ---滑动窗口</p> 
<p style="margin-left:.0001pt;text-align:justify;">Checksum ---校验和</p> 
<p style="margin-left:.0001pt;text-align:justify;">Options---选项---有就有 没有就没有</p> 
<p style="margin-left:.0001pt;text-align:center;">UDP报头：<img alt="" src="https://images2.imgbox.com/25/30/f8oXR4dF_o.png"></p> 
<p>IP报头：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/28/b6/PKozpVLS_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;">Version   版本 IPv4</p> 
<p style="margin-left:.0001pt;text-align:justify;">IHL     IP header length</p> 
<p style="margin-left:.0001pt;text-align:justify;">Service type ---服务类型</p> 
<p style="margin-left:.0001pt;text-align:justify;">Packet length --数据包的长度</p> 
<p style="margin-left:.0001pt;text-align:justify;">标识 标志 片偏移 ----支撑跨层封装</p> 
<p style="margin-left:.0001pt;text-align:justify;">Time to live ---生存时间 主要作用--防止环路</p> 
<p style="margin-left:.0001pt;text-align:justify;">取值范围 0-255</p> 
<hr> 
<p style="margin-left:.0001pt;text-align:justify;">TCP/IP协议栈---以太网 （ethernet）：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/db/23/2kPKs4nz_o.png"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;">相同点： 二者都是模型化层次化 </p> 
<p style="margin-left:.0001pt;text-align:justify;">               下层对上层提供服务支持 </p> 
<p style="margin-left:.0001pt;text-align:justify;">               每层协议彼此相互独立 </p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">不同点：OSI先有模型才有协议  </p> 
<p style="margin-left:.0001pt;text-align:justify;">TCP/IP先有协议才有模型</p> 
<p style="margin-left:.0001pt;text-align:justify;">          TCP/IP协议栈只适用于TCP/IP网络层量不同</p> 
<p>信号衰减--&gt;物理加压---&gt;中继器---信号失真---&gt;交换机----&gt;广播风暴--&gt;路由器中继器---产生冲突路由器的作用：隔离广播域/划分广播域连接不同的网络</p> 
<p>交换机的作用：无限延长传输距离   实现单播   解决冲突域</p> 
<p>冲突域---可能产生冲突的地方</p> 
<p>广播域--广播的范围</p> 
<p>数据从设备的一个接口进入，从其他接口转发出去</p> 
<p> 默认情况下，一个交换机属于一个广播域</p> 
<p>解决冲突：</p> 
<p>FIFO --先入先出   First in first out</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df55550effc65983feed45a29b072b07/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">4种JavaScript实现千位分隔符的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/db090de4800e80593f0c9a6f43c22d6d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">软考架构设计师脑图总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>