<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023年福建农林大学程序设计校赛个人题解（无D解析) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2023年福建农林大学程序设计校赛个人题解（无D解析)" />
<meta property="og:description" content="2023年福建农林大学程序设计校赛个人题解（无D解析) A-这是一道原题 问题解析 从绿色材料合成到金色材料。
用 w h i l e while while 循环判断材料数是否能合成，能就合，合成后下一级材料数增加，原料数加上合成出的材料数。
AC代码 #include&lt;iostream&gt; using namespace std; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;math.h&gt; #include&lt;set&gt; #include &lt;random&gt; #include&lt;numeric&gt; #include&lt;string&gt; #include&lt;string.h&gt; #include&lt;iterator&gt; #include&lt;fstream&gt; #include&lt;map&gt; #include&lt;unordered_map&gt; #include&lt;stack&gt; #include&lt;list&gt; #include&lt;queue&gt; #include&lt;iomanip&gt; #include&lt;bitset&gt; //#pragma GCC optimize(2) //#pragma GCC optimize(3) #define endl &#39;\n&#39; #define int ll #define PI acos(-1) #define INF 0x3f3f3f3f typedef long long ll; typedef long double ld; typedef unsigned long long ull; typedef pair&lt;ll, ll&gt;PII; const int N = 2e5 &#43; 50, MOD = 1e9 &#43; 7; void hecheng(int&amp;a, int&amp;b) { while (a &gt;= 3) { int x = a / 3; a %= 3; a &#43;= x; b &#43;= x; } } void solve() { int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; hecheng(a, b); hecheng(b, c); hecheng(c, d); cout &lt;&lt; a &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fea649fb3955caca5f9963d57abc6f72/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-22T20:27:50+08:00" />
<meta property="article:modified_time" content="2023-05-22T20:27:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023年福建农林大学程序设计校赛个人题解（无D解析)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="2023D_0"></a>2023年福建农林大学程序设计校赛个人题解（无D解析)</h2> 
<h3><a id="Ahttpsacnowcodercomacmcontest58568A_2"></a><a href="https://ac.nowcoder.com/acm/contest/58568/A" rel="nofollow">A-这是一道原题</a></h3> 
<h4><a id="_4"></a>问题解析</h4> 
<p>从绿色材料合成到金色材料。</p> 
<p>用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         w 
        
       
         h 
        
       
         i 
        
       
         l 
        
       
         e 
        
       
      
        while 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span></span></span></span></span> 循环判断材料数是否能合成，能就合，合成后下一级材料数增加，原料数加上合成出的材料数。</p> 
<h4><a id="AC_10"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include &lt;random&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;
#include&lt;bitset&gt;

//#pragma GCC optimize(2)
//#pragma GCC optimize(3)

#define endl '\n'
#define int ll
#define PI acos(-1)
#define INF 0x3f3f3f3f
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 2e5 + 50, MOD = 1e9 + 7;

void hecheng(int&amp;a, int&amp;b)
{
    while (a &gt;= 3)
    {
        int x = a / 3;
        a %= 3;
        a += x;
        b += x;
    }
}

void solve()
{
    int a, b, c, d;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    hecheng(a, b);
    hecheng(b, c);
    hecheng(c, d);
    cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; d;
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    //cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}
</code></pre> 
<h3><a id="Bhttpsacnowcodercomacmcontest58568B_86"></a><a href="https://ac.nowcoder.com/acm/contest/58568/B" rel="nofollow">B-健康阳光，积极向上!</a></h3> 
<h4><a id="_88"></a>问题解析</h4> 
<p>想不到什么很好做法，直接暴力了。</p> 
<p>根据贪心来说，要想结果越小，删掉的质因数就要越大。</p> 
<p>对所有数进行质因数分解并记录下来，最后对所有质因数从大到小排序，把最前面 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span></span></span></span></span>个质数当作我们要删除的质因子。</p> 
<p>然后我们把剩下的质因子全部乘起来就行。</p> 
<p>分解因数的复杂度在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
         
         
           log 
          
         
           ⁡ 
          
         
        
          2 
         
        
        
        
          a 
         
        
          i 
         
        
       
         ) 
        
       
      
        O(\log_{2}{a_i}) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right: 0.0139em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.207em;"><span class="" style="top: -2.4559em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2441em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 到 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          n 
         
        
       
         ) 
        
       
      
        O(\sqrt n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0503em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8003em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal" style="padding-left: 0.833em;">n</span></span><span class="" style="top: -2.7603em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail" style="min-width: 0.853em; height: 1.08em;"> 
           <svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"> 
            <path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path> 
           </svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2397em;"><span class=""></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 之间 。</p> 
<h4><a id="AC_100"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include &lt;random&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;
#include&lt;bitset&gt;

//#pragma GCC optimize(2)
//#pragma GCC optimize(3)

#define endl '\n'
#define int ll
#define PI acos(-1)
#define INF 0x3f3f3f3f
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 2e5 + 50, MOD = 1e9 + 7;

int a[N];
vector&lt;int&gt;v;

void divide(int n)
{
    for (int i = 2; i &lt;= n / i; i++)
    {
        if (n % i == 0)
        {
            int s = 0;
            while (n % i == 0)
            {
                v.push_back(i);
                n /= i;
            }
        }
    }
    if (n &gt; 1)v.push_back(n);
}

void solve()
{
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    if (k &gt; 2e5 * 17)
    {
        cout &lt;&lt; 1 &lt;&lt; endl;
    }
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; a[i];
        divide(a[i]);
    }
    sort(v.begin(), v.end(), greater&lt;int&gt;());
    int ans = 1;
    for (int i = k; i &lt; v.size(); i++)
        ans = ans * v[i] % MOD;
    cout &lt;&lt; ans &lt;&lt; endl;
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    //cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}
</code></pre> 
<h3><a id="Chttpsacnowcodercomacmcontest58568C_195"></a><a href="https://ac.nowcoder.com/acm/contest/58568/C" rel="nofollow">C-字一色大四喜四杠子四暗刻单骑役满确定！</a></h3> 
<h4><a id="_197"></a>问题解析</h4> 
<p>遍历字符串看有没有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         7 
        
       
         z 
        
       
      
        7z 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">7</span><span class="mord mathnormal" style="margin-right: 0.044em;">z</span></span></span></span></span> 就行。</p> 
<h4><a id="AC_201"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include &lt;random&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;
#include&lt;bitset&gt;

//#pragma GCC optimize(2)
//#pragma GCC optimize(3)

#define endl '\n'
#define int ll
#define PI acos(-1)
#define INF 0x3f3f3f3f
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 2e5 + 50, MOD = 1e9 + 7;

void solve()
{
    int n;
    string s;
    cin &gt;&gt; n &gt;&gt; s;
    for (int i = 1; i &lt; n; i++)
    {
        if (s[i - 1] == '7' &amp;&amp; s[i] == 'z')
        {
            cout &lt;&lt; "YES" &lt;&lt; endl;
            return;
        }
    }
    cout &lt;&lt; "NO" &lt;&lt; endl;
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    //cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}
</code></pre> 
<h3><a id="D1000httpsacnowcodercomacmcontest58568D_272"></a><a href="https://ac.nowcoder.com/acm/contest/58568/D" rel="nofollow">D-荣！断幺九，一番，1000点！</a></h3> 
<h4><a id="_274"></a>问题解析</h4> 
<p>说实话，这题我没想懂，不咋打雀不知道是不是只要胡牌且没有幺九牌就是段幺九。而且也不知道给的牌型是不是已经胡了让判断胡的排序。不太懂，如果有出题人能帮我解个惑就好了。</p> 
<p>（代码学的一个大佬写的，感觉懂了点什么又好像没懂）</p> 
<h4><a id="AC_280"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include &lt;random&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;
#include&lt;bitset&gt;

//#pragma GCC optimize(2)
//#pragma GCC optimize(3)

#define endl '\n'
#define int ll
#define PI acos(-1)
#define INF 0x3f3f3f3f
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 2e5 + 50, MOD = 1e9 + 7;

void solve() 
{
    string s;
    cin &gt;&gt; s;
    int n = s.size();
    map&lt;string, int&gt;mymap;
    for (int i = 0; i &lt; n; i++)
    {
        if (s[i] == '1' || s[i] == '9' || s[i] == 'z')
        {
            cout &lt;&lt; "NO" &lt;&lt; endl;
            return;
        }
    }
    for (int i = 0; i &lt; n; i += 2)
    {
        string t;
        t += s[i];
        t += s[i + 1];
        mymap[t]++;
    }
    for (auto&amp; i : mymap)
    {
        if (i.second &gt;= 2)
        {
            map&lt;string, int&gt;mymap2;
            mymap2 = mymap;
            mymap2[i.first] -= 2;
            int cnt = 2;
            for (auto&amp; j : mymap2)
            {
                if (j.second &gt;= 3)
                {
                    j.second -= 3;
                    cnt += 3;
                }
                if (j.second != 0 &amp;&amp; j.first[0] - '0' &lt;= 7)
                {
                    string a = j.first;
                    a[0]++;
                    string b = a;
                    b[0]++;
                    while (j.second &gt; 0 &amp;&amp; mymap2[a] &gt; 0 &amp;&amp; mymap2[b] &gt; 0)
                    {
                        j.second--;
                        mymap2[a]--;
                        mymap2[b]--;
                        cnt += 3;
                    }
                }
            }
            if (cnt == 14)
            {
                cout &lt;&lt; "YES" &lt;&lt; endl;
                return;
            }
        }
    }
    cout &lt;&lt; "NO" &lt;&lt; endl;
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}
</code></pre> 
<h3><a id="Ehttpsacnowcodercomacmcontest58568E_396"></a><a href="https://ac.nowcoder.com/acm/contest/58568/E" rel="nofollow">E-可爱即是正义！</a></h3> 
<h4><a id="_398"></a>问题解析</h4> 
<p>区间前缀和模板，枚举所有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         r 
        
       
      
        r 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> 行 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         c 
        
       
      
        c 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></span> 列的子矩阵然后用矩阵前缀和快速算结果，维护最大值就行。</p> 
<p>注意数据可能使得最大的矩阵和为负数，维护最大值的变量初始值要够小。</p> 
<h4><a id="AC_404"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include &lt;random&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;
#include&lt;bitset&gt;

//#pragma GCC optimize(2)
//#pragma GCC optimize(3)

#define endl '\n'
#define int ll
#define PI acos(-1)
#define INF 0x3f3f3f3f
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 2e5 + 50, MOD = 1e9 + 7;

int a[2050][2050], s[2050][2050], n, m;

void init()
{
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++)
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
}

int get_sum(int x1, int y1, int x2, int y2)
{
    return s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1];
}

void solve()
{
    int r, c;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; c;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++)
            cin &gt;&gt; a[i][j];
    init();
    int mx = -1e18;
    for (int i = 1; i &lt;= n - r + 1; i++)
        for (int j = 1; j &lt;= m - c + 1; j++)
            mx = max(mx, get_sum(i, j, i + r - 1, j + c - 1));
    cout &lt;&lt; mx;
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    //cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}
</code></pre> 
<h3><a id="FBUGhttpsacnowcodercomacmcontest58568F_488"></a><a href="https://ac.nowcoder.com/acm/contest/58568/F" rel="nofollow">F-炉石传说这个游戏是没有（任何BUG）的！</a></h3> 
<h4><a id="_490"></a>问题解析</h4> 
<p>基础的计数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         p 
        
       
      
        dp 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span></span></span></span></span> 。</p> 
<p>设状态转移数组 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
      
        f 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span></span></span></span></span> ，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
      
        f[i] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span> 表示前 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> 个字符的分割方式有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
      
        f[i] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span> 种。</p> 
<p>状态转移：如果一个长为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         l 
        
       
         e 
        
       
         n 
        
       
      
        len 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span></span></span></span></span> 的字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         i 
        
       
      
        si 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span></span></span></span></span> 能匹配字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         t 
        
       
         r 
        
       
      
        str 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> 上 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         j 
        
       
      
        j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 到 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         j 
        
       
         − 
        
       
         l 
        
       
         e 
        
       
         n 
        
       
         + 
        
       
         1 
        
       
      
        j-len+1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 的这一段，则有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         [ 
        
       
         j 
        
       
         + 
        
       
         l 
        
       
         e 
        
       
         n 
        
       
         − 
        
       
         1 
        
       
         ] 
        
       
         = 
        
       
         f 
        
       
         [ 
        
       
         j 
        
       
         + 
        
       
         l 
        
       
         e 
        
       
         n 
        
       
         − 
        
       
         1 
        
       
         ] 
        
       
         + 
        
       
         f 
        
       
         [ 
        
       
         j 
        
       
         − 
        
       
         1 
        
       
         ] 
        
       
      
        f[j+len-1] = f[j+len-1] + f[j-1] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span> 。</p> 
<p>思路不难，主要是匹配字符串的方法。</p> 
<p>遍历字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         t 
        
       
         r 
        
       
      
        str 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> ，枚举每个位置 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         j 
        
       
      
        j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> ,判断以当前字符为起点是否有字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         i 
        
       
      
        si 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span></span></span></span></span> 能和它匹配。</p> 
<p>这里可以用字符串哈希快速匹配，预处理 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         t 
        
       
         r 
        
       
      
        str 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> 的哈希数组复杂度为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         l 
        
       
         e 
        
       
         n 
        
       
         g 
        
       
         t 
        
       
         h 
        
       
         ( 
        
       
         s 
        
       
         t 
        
       
         r 
        
       
         ) 
        
       
         ) 
        
       
      
        O(length(str)) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mclose">))</span></span></span></span></span> ，预处理 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> 个字符串 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
      
        s 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></span> 的哈希值的复杂度为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          ∑ 
         
         
         
           i 
          
         
           = 
          
         
           0 
          
         
        
          n 
         
        
       
         l 
        
       
         e 
        
       
         n 
        
       
         g 
        
       
         t 
        
       
         h 
        
       
         ( 
        
        
        
          s 
         
        
          i 
         
        
       
         ) 
        
       
         ) 
        
       
      
        O(\sum_{i=0}^nlength(s_i)) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.104em; vertical-align: -0.2997em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8043em;"><span class="" style="top: -2.4003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2997em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></span> 。</p> 
<p>每次匹配字符串复杂度为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         1 
        
       
         ) 
        
       
      
        O(1) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 。</p> 
<p>总复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          ∑ 
         
         
         
           i 
          
         
           = 
          
         
           0 
          
         
        
          n 
         
        
       
         l 
        
       
         e 
        
       
         n 
        
       
         g 
        
       
         t 
        
       
         h 
        
       
         ( 
        
        
        
          s 
         
        
          i 
         
        
       
         ) 
        
       
         ∗ 
        
       
         l 
        
       
         e 
        
       
         n 
        
       
         g 
        
       
         t 
        
       
         h 
        
       
         ( 
        
       
         s 
        
       
         t 
        
       
         r 
        
       
         ) 
        
       
         ) 
        
       
      
        O(\sum_{i=0}^n length(s_i) * length(str)) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.104em; vertical-align: -0.2997em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8043em;"><span class="" style="top: -2.4003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2997em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mclose">))</span></span></span></span></span></p> 
<h4><a id="AC_508"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include &lt;random&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;
#include&lt;bitset&gt;

//#pragma GCC optimize(2)
//#pragma GCC optimize(3)

#define endl '\n'
#define int ll
#define PI acos(-1)
#define INF 0x3f3f3f3f
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 2e5 + 50, MOD = 1e9 + 7;

int base = 13331;
ull hash_str[N], bpow[N], a[N];
int f[N];

void init(string s)
{
    int n = s.size();
    bpow[0] = 1;
    for (int i = 1; i &lt;= n; i++)
    {
        hash_str[i] = (hash_str[i-1] * base + s[i - 1]);
        bpow[i] = bpow[i - 1] * base;
    }
}

ull get_hash(int l, int r)
{
    return hash_str[r] - hash_str[l - 1] * bpow[r - l + 1];
}

void solve() {
    int n;
    string s;
    cin &gt;&gt; n &gt;&gt; s;
    vector&lt;string&gt;v(n);
    init(s);
    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; v[i];
        ull res = 0, len = v[i].size();
        for (int j = 1; j &lt;= len; j++)
        {
            res = (res * base + v[i][j - 1]);
        }
        a[i] = res;
    }
    int len = s.size();
    f[0] = 1;
    for (int i = 1; i &lt;= len; i++)
    {
        
        for (int j = 0; j &lt; n; j++)
        {
            int len2 = v[j].size();
            if (i + len2 - 1 &lt;= len)
            {
                if (get_hash(i, i + len2 - 1) == a[j])
                {
                    f[i + len2 - 1] = (f[i - 1] + f[i + len2 - 1]) % MOD;
                }
            }
        }
    }
    cout &lt;&lt; f[len] &lt;&lt; endl;
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    //cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}
</code></pre> 
<h3><a id="Ghttpsacnowcodercomacmcontest58568G_619"></a><a href="https://ac.nowcoder.com/acm/contest/58568/G" rel="nofollow">G-蒸蒸日上！</a></h3> 
<h4><a id="_621"></a>问题解析</h4> 
<p>出题人看来非常喜欢三国杀这款游戏呀，那我去给三国杀刷个好评罢。（逃）</p> 
<p>根据给的字符串输出对应的外号就行。</p> 
<h4><a id="AC_627"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include &lt;random&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;
#include&lt;bitset&gt;

//#pragma GCC optimize(2)
//#pragma GCC optimize(3)

#define endl '\n'
#define int ll
#define PI acos(-1)
#define INF 0x3f3f3f3f
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 2e5 + 50, MOD = 1e9 + 7;

void solve()
{
    string s;
    cin &gt;&gt; s;
    if (s == "XuSheng") s = "DaBao";
    else if (s == "GanNing") s = "DaGui";
    else if (s == "QuYi") s = "BaiMa";
    else if (s == "HuangZhong") s = "LaoBao";
    cout &lt;&lt; s;
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    //cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}
</code></pre> 
<h3><a id="H_httpsacnowcodercomacmcontest58568H_693"></a><a href="https://ac.nowcoder.com/acm/contest/58568/H" rel="nofollow">H-圆皱率_</a></h3> 
<h4><a id="_695"></a>问题解析</h4> 
<p>这题面真是给我笑死，不过我觉得题意不是很清楚，一开始都不理解要干啥，最好优化一下或者给样例加个解释罢。</p> 
<p>（话说我这种又玩原又玩粥又玩农的算啥皮）</p> 
<p>这题是想让你从里面选择一个子序列，使得子序列的和最大，但是不能让 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         a 
        
       
      
        aa 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">aa</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         A 
        
       
         A 
        
       
      
        AA 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">AA</span></span></span></span></span> 挨着。</p> 
<p>我们先把豌豆的三种基因状态 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         A 
        
       
         A 
        
       
         、 
        
       
         A 
        
       
         a 
        
       
         、 
        
       
         a 
        
       
         a 
        
       
      
        AA、Aa、aa 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">AA</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">A</span><span class="mord mathnormal">a</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">aa</span></span></span></span></span> 分别设为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
         、 
        
       
         2 
        
       
         、 
        
       
         3 
        
       
      
        1、2、3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">、</span><span class="mord">2</span><span class="mord cjk_fallback">、</span><span class="mord">3</span></span></span></span></span> 。</p> 
<p>动态规划。</p> 
<p>设二维状态转移数组 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
      
        f 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span></span></span></span></span> ，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
         [ 
        
       
         j 
        
       
         ] 
        
       
      
        f[i] [j] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span></span></span></span></span> 表示在前 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> 个豌豆中取，且最后一个豌豆状态为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         j 
        
       
      
        j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span></span></span></span></span> 的最大价值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
         [ 
        
       
         j 
        
       
         ] 
        
       
      
        f[i] [j] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span></span></span></span></span> ，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         j 
        
       
         = 
        
       
         0 
        
       
      
        j = 0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span> 表示一个豌豆都没取。</p> 
<p>状态转移：</p> 
<ul><li>每次都有：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          j 
         
        
          ] 
         
        
          = 
         
        
          f 
         
        
          [ 
         
        
          i 
         
        
          − 
         
        
          1 
         
        
          ] 
         
        
          [ 
         
        
          j 
         
        
          ] 
         
        
       
         f[i] [j] = f[i-1] [j] 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span></span></span></span></span> 。</li><li>如果当前的豌豆状态为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          1 
         
        
       
         1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> ，则 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          1 
         
        
          ] 
         
        
          = 
         
        
          m 
         
        
          a 
         
        
          x 
         
        
          ( 
         
        
          f 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          1 
         
        
          ] 
         
        
          ， 
         
        
          f 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          j 
         
        
          ] 
         
        
          + 
         
         
         
           a 
          
         
           i 
          
         
        
          ) 
         
        
          ( 
         
        
          j 
         
        
          = 
         
        
          0 
         
        
          , 
         
        
          1 
         
        
          , 
         
        
          2 
         
        
          ) 
         
        
       
         f[i] [1] = max(f[i] [1]，f[i] [j] + a_i) (j = 0,1,2) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span>。</li><li>如果当前的豌豆状态为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          2 
         
        
       
         2 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span> ，则 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          2 
         
        
          ] 
         
        
          = 
         
        
          m 
         
        
          a 
         
        
          x 
         
        
          ( 
         
        
          f 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          1 
         
        
          ] 
         
        
          ， 
         
        
          f 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          j 
         
        
          ] 
         
        
          + 
         
         
         
           a 
          
         
           i 
          
         
        
          ) 
         
        
          ( 
         
        
          j 
         
        
          = 
         
        
          0 
         
        
          , 
         
        
          1 
         
        
          , 
         
        
          2 
         
        
          , 
         
        
          3 
         
        
          ) 
         
        
       
         f[i] [2] = max(f[i] [1]，f[i] [j] + a_i) (j = 0,1,2,3) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span>。</li><li>如果当前的豌豆状态为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          3 
         
        
       
         3 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span></span></span></span></span> ，则 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          3 
         
        
          ] 
         
        
          = 
         
        
          m 
         
        
          a 
         
        
          x 
         
        
          ( 
         
        
          f 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          1 
         
        
          ] 
         
        
          ， 
         
        
          f 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          j 
         
        
          ] 
         
        
          + 
         
         
         
           a 
          
         
           i 
          
         
        
          ) 
         
        
          ( 
         
        
          j 
         
        
          = 
         
        
          0 
         
        
          , 
         
        
          2 
         
        
          , 
         
        
          3 
         
        
          ) 
         
        
       
         f[i] [3] = max(f[i] [1]，f[i] [j] + a_i) (j = 0,2,3) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span>。</li></ul> 
<p>最后答案为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
         a 
        
       
         x 
        
       
         ( 
        
       
         f 
        
       
         [ 
        
       
         n 
        
       
         ] 
        
       
         [ 
        
       
         j 
        
       
         ] 
        
       
         ) 
        
       
         ( 
        
       
         j 
        
       
         = 
        
       
         0 
        
       
         , 
        
       
         1 
        
       
         , 
        
       
         2 
        
       
         , 
        
       
         3 
        
       
         ) 
        
       
      
        max(f[n] [j]) (j=0,1,2,3) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mclose">])</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0572em;">j</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 。</p> 
<h4><a id="AC_718"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include &lt;random&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;
#include&lt;bitset&gt;

//#pragma GCC optimize(2)
//#pragma GCC optimize(3)

#define endl '\n'
#define int ll
#define PI acos(-1)
#define INF 0x3f3f3f3f
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 2e5 + 50, MOD = 1e9 + 7;

int a[N], f[N][4], b[N];


void solve()
{
    string s;
    int n;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= n; i++)
    {
        cin &gt;&gt; s;
        if (s == "AA")b[i] = 1;
        else if (s == "Aa")b[i] = 2;
        else b[i] = 3;
    }
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 0; j &lt;= 3; j++)
            f[i][j] = f[i - 1][j];
        if (b[i] == 1)
        {
            
            for (int j = 0; j &lt; 3; j++)
                f[i][b[i]] = max(f[i][b[i]], f[i - 1][j] + a[i]);
        }
        else if (b[i] == 2)
        {
            for (int j = 0; j &lt;= 3; j++)
                f[i][b[i]] = max(f[i][b[i]], f[i - 1][j] + a[i]);
        }
        else
        {
            for (int j = 0; j &lt;= 3; j++)
                if (j != 1)
                    f[i][b[i]] = max(f[i][b[i]], f[i - 1][j] + a[i]);
        }
    }
    int mx = 0;
    for (int i = 0; i &lt;= 3; i++)mx = max(mx, f[n][i]);
    cout &lt;&lt; mx;
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    //cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}
</code></pre> 
<h3><a id="I_httpsacnowcodercomacmcontest58568I_816"></a><a href="https://ac.nowcoder.com/acm/contest/58568/I" rel="nofollow">I-你说得对，但是……_</a></h3> 
<h4><a id="_818"></a>问题解析</h4> 
<p>但是原神是一款…………</p> 
<p>首先我们要知道，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 并不是一个质数，然后我们再知道，对于相邻的两个数，它们的最大公约数是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 。</p> 
<p>那么我们可以先按照 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
         = 
        
       
         i 
        
       
      
        a[i] = i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span> 的方式来排列，然后依次判断 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         g 
        
       
         c 
        
       
         d 
        
       
         ( 
        
       
         a 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
         ， 
        
       
         i 
        
       
         ) 
        
       
      
        gcd(a[i]，i) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></span> 是否为质数，如果为质数，我们就可以把它和下一位数：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         [ 
        
       
         i 
        
       
         + 
        
       
         1 
        
       
         ] 
        
       
      
        a[i+1] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span> 进行交换，这样可以保证 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
      
        a[i] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         [ 
        
       
         i 
        
       
         + 
        
       
         1 
        
       
         ] 
        
       
      
        a[i+1] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span> 和他们对应位置数的最大公约数都是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
       
      
        1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 。</p> 
<p>由于这一步会使得我们的字典序变大，所以如果 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         g 
        
       
         c 
        
       
         d 
        
       
         ( 
        
       
         a 
        
       
         [ 
        
       
         i 
        
       
         ] 
        
       
         ， 
        
       
         i 
        
       
         ) 
        
       
      
        gcd(a[i]，i) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></span> 不为质数，我们就不用交换了。</p> 
<p>特别的，如果 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         g 
        
       
         c 
        
       
         d 
        
       
         ( 
        
       
         a 
        
       
         [ 
        
       
         n 
        
       
         ] 
        
       
         ， 
        
       
         n 
        
       
         ) 
        
       
      
        gcd(a[n]，n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> 为质数，因为已经没有下一位了，所以我们只能和上一位，即：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         [ 
        
       
         n 
        
       
         − 
        
       
         1 
        
       
         ] 
        
       
      
        a[n-1] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span> 进行交换。</p> 
<p>这里判断质数我用的是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         M 
        
       
         i 
        
       
         l 
        
       
         l 
        
       
         e 
        
       
         r 
        
       
         − 
        
       
         R 
        
       
         a 
        
       
         b 
        
       
         i 
        
       
         n 
        
       
      
        Miller-Rabin 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7778em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0197em;">ll</span><span class="mord mathnormal" style="margin-right: 0.0278em;">er</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">R</span><span class="mord mathnormal">abin</span></span></span></span></span> 素性测试，不认识的大家可以学习一下。用试除法应该也是可以过的。</p> 
<h4><a id="AC_832"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include &lt;random&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;
#include&lt;bitset&gt;

//#pragma GCC optimize(2)
//#pragma GCC optimize(3)

#define endl '\n'
#define int ll
#define PI acos(-1)
#define INF 0x3f3f3f3f
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 2e5 + 50, MOD = 1e9 + 7;

int a[N];

int gcd(int a,int b)
{
    return a%b==0?b:gcd(b,a%b);
}

ll qmul(ll a,ll b,ll mod)//快速乘
{
    ll c=(ld)a/mod*b;
    ll res=(ull)a*b-(ull)c*mod;
    return (res+mod)%mod;
}
ll qpow(ll a,ll n,ll mod)//快速幂
{
    ll res=1;
    while(n)
    {
        if(n&amp;1) res=qmul(res,a,mod);
        a=qmul(a,a,mod);
        n&gt;&gt;=1;
    }
    return res;
}
bool is_prime(ll n)//Miller Rabin Test
{
    if(n&lt;3||n%2==0) return n==2;//特判
    ll u=n-1,t=0;
    while(u%2==0) u/=2,++t;
    ll ud[]={2,325,9375,28178,450775,9780504,1795265022};
    for(ll a:ud)
    {
        ll v=qpow(a,u,n);
        if(v==1||v==n-1||v==0) continue;
        for(int j=1;j&lt;=t;j++)
        {
            v=qmul(v,v,n);
            if(v==n-1&amp;&amp;j!=t){v=1;break;}//出现一个n-1，后面都是1，直接跳出
            if(v==1) return 0;//这里代表前面没有出现n-1这个解，二次检验失败
        }
        if(v!=1) return 0;//Fermat检验
    }
    return 1;
}

void solve()
{
    int n;
    cin &gt;&gt; n;
    for(int i=1;i&lt;=n;i++)a[i]=i;
    for (int i = 2; i &lt;= n; i ++)
    {
        int x=gcd(a[i],i);
        if(is_prime(x))
        {
            if(i&lt;n)swap(a[i],a[i+1]);
            else swap(a[i-1],a[i]);
        }
    }
    for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;" ";
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    //cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}
</code></pre> 
<h3><a id="Jhttpsacnowcodercomacmcontest58568J_949"></a><a href="https://ac.nowcoder.com/acm/contest/58568/J" rel="nofollow">J-蓝色妖精小姐的树</a></h3> 
<h4><a id="_951"></a>问题解析</h4> 
<p>从数据的方式和表情包来看，都告诉了我们这题用的是珂朵莉树。</p> 
<p>珂朵莉树是一个神奇的算法，专门负责处理这类区间修改（区间赋值）和区间询问问题，做法很暴力，所以一般只适用于随机数据，对于出题人自己造的数据，是可以把珂朵莉树给卡到超时的。</p> 
<p>具体的大伙可以去看看珂朵莉树的由来。</p> 
<p>至于树的问题，我们可以通过 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         d 
        
       
         f 
        
       
         s 
        
       
      
        dfs 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">df</span><span class="mord mathnormal">s</span></span></span></span></span> 序来确定每一个子树的根 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         u 
        
       
      
        u 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span></span> 负责的是哪个区间，修改这一整个子树，就相当于修改这个区间。</p> 
<h4><a id="AC_961"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include &lt;random&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;fstream&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;
#include&lt;bitset&gt;

//#pragma GCC optimize(2)
//#pragma GCC optimize(3)

#define endl '\n'
#define int ll
#define PI acos(-1)
#define INF 0x3f3f3f3f
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 1e5 + 50, MOD = 1e9 + 7;

struct node {
    int l, r;
    mutable int val;
    node(int l, int r = -1, int val = 0) :l(l), r(r), val(val) {}
    bool operator&lt;(const node&amp; o)const
    {
        return l &lt; o.l;
    }
};

set&lt;node&gt;s;

int qpow(int x, int k, int mod = 1e9 + 7)
{
    int num = 1;
    x %= mod;
    while (k)
    {
        if (k &amp; 1)num = num * x % mod;
        k &gt;&gt;= 1;
        x = (x * x) % mod;
    }
    return num;
}

//核心操作，将包含pos点的区间分成[l,pos-1]和[pos,r]两个区间
set&lt;node&gt;::iterator split(int pos)
{
    //找l不小于pos的第一个node
    auto it = s.lower_bound(node(pos));
    if (it != s.end() &amp;&amp; it-&gt;l == pos)
        return it;
    --it;
    if (pos &gt; it-&gt;r)return s.end();
    int l = it-&gt;l, r = it-&gt;r, val = it-&gt;val;
    s.erase(it);
    s.insert(node(l, pos - 1, val));
    //return的是插入节点后，该节点在set的iterator
    return s.insert(node(pos, r, val)).first;
}

//区间加值
void add(int l, int r, int val = 1)
{
    split(l);
    auto itr = split(r + 1), itl = split(l);
    //给itl到itr之间所有元素加上val
    for (; itl != itr; ++itl)itl-&gt;val += val;
}

//区间赋值
void assign(int l, int r, int val = 0)
{
    split(l);
    auto itr = split(r + 1), itl = split(l);
    //删除itl到itr-1的全部元素
    s.erase(itl, itr);
    s.insert(node(l, r, val));
}

//如果reversed为0，说明找第k小元素；反之找第k大元素
int myrank(int l, int r, int k, bool reversed = 0)
{
    if (reversed)k = r - l + 2 - k;
    split(l);
    auto itr = split(r + 1), itl = split(l);
    vector&lt;PII&gt;v;
    for (; itl != itr; ++itl)
        v.push_back({ itl-&gt;val,itl-&gt;r - itl-&gt;l + 1 });
    sort(v.begin(), v.end());
    for (auto i : v)
    {
        k -= i.second;
        if (k &lt;= 0)return i.first;
    }
    return -1;
}

//计算区间[l,r]所有元素的k次幂的和
int sum(int l, int r, int k, int mod = 1e9 + 7)
{
    split(l);
    auto itr = split(r + 1), itl = split(l);
    int res = 0;
    for (; itl != itr; ++itl)
        res = (res + (itl-&gt;r - itl-&gt;l + 1) * qpow(itl-&gt;val, k, mod) % mod) % mod;
    return res;
}

int seed, vmax;
int a[N], b[N];
PII c[N];

vector&lt;int&gt;tree[N];

int rnd()
{
    int ret = seed;
    seed = (seed * 7 + 13) % MOD;
    return ret;
}

void dfs(int x, int y, int&amp;z)
{
    z++;
    c[x].first = z;
    for (auto&amp; i : tree[x])
    {
        if (i == y)continue;
        
        dfs(i, x, z);
    }
    c[x].second = z;
}

void solve() 
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax;
    for (int i = 1; i &lt;= n; i++)
    {
        a[i] = (rnd() % vmax) + 1;
        //cout &lt;&lt; a[i] &lt;&lt; " ";
    }
    for (int i = 2; i &lt;= n; i++)
    {
        int x = (rnd() % (i - 1)) + 1;
        tree[i].push_back(x);
        tree[x].push_back(i);
    }
    int idx = 0;
    dfs(1, 0, idx);
    for (int i = 1; i &lt;= n; i++)
    {
        s.insert(node(c[i].first, c[i].first, a[i]));
    }
    //cout &lt;&lt; endl;
    for (int i = 1; i &lt;= m; i++)
    {
        int op = (rnd() % 2) + 1;
        int u = (rnd() % n) + 1;
        int x = (rnd() % vmax) + 1;
        int l = c[u].first, r = c[u].second;
        //cout &lt;&lt; op &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;
        if (op == 1)assign(l, r, x);
        else if (op == 2)cout &lt;&lt; sum(l, r, x) &lt;&lt; endl;
    }
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t = 1;
    //cin &gt;&gt; t;
    while (t--)
    {
        solve();
    }
    return 0;
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a91d5e7b9c92215b1a66be8ced9cfd8e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux运维进阶：git安装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6c99ce1cb97c7ee87159ca965f5a13ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">v-model使用及原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>