<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程的基础知识 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="编程的基础知识" />
<meta property="og:description" content="c的发展历史 void 类型 程序的入口成了_tmain()，这个和 VC6.0 中的 main 函数类似， 在前面加个 t，是为了对 unicode 项目的设置兼容，但它们都是程序执行的入口，其中 int argc 是程序的参数个数，_TCHAR* argv[]是参数数组。
程序的编译与链接，PE 格式 一个完整的 PE（Portable Executable）文件由 DOS 头，PE 文件头，块表，块 和调试信息（调试版本有效）组成
在 DOS 头部，以 e_magic 开头，它的值是固定的”0x5a4d”，即（MZ）开头。最开头的 是部分是 DOS 部首，DOS 部首由两部分组成：DOS 的 MZ 文件标志和 DOS stub(DOS 存根程序)。之所以设置 DOS 部首是微软为了兼容原有的 DOS 系统下的程序而设立的。 系统与程序的内存布局 在我们开始内核调试之前，首先我们需要对系统的内存内核层与应用层的布局有一个基本认 识。以 X86 为例，X86 支持 32 位寻址，因此可以支持最大 2^32=4GB 的虚拟内存空间（当然 也可以通过 PAE 将寻址空间扩大到 64GB，PAE 即 Physical address extension，x86 的处理器增加了额外的地址线以选择那些增加了的内存，所以实体内存的大小从 32 位增加到了 36 位。 最大的实体内存由 4GB 增加到了 64GB）。如下图所示，在 4G 的虚拟地址空间中，Windows系统的内存主要分为内核空间和应用层空间上下两部分，每部分各占约 2GB，其中还包括了 一个 64KB 的 NULL 空间以及非法区域，虚拟地址再通过页表机制映射到物理地址以便存取物理内存中的数据和指令。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/07e75b79aec986338dc842349fc7acd3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-17T21:27:56+08:00" />
<meta property="article:modified_time" content="2019-06-17T21:27:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">编程的基础知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>c的发展历史 </h2> 
<p><img alt="" class="has" height="474" src="https://images2.imgbox.com/62/7f/3B5HZVTc_o.png" width="248"></p> 
<hr> 
<h4>void 类型   </h4> 
<p><img alt="" class="has" height="198" src="https://images2.imgbox.com/a2/0f/7hjsSUfP_o.png" width="467"></p> 
<hr> 
<p><img alt="" class="has" height="348" src="https://images2.imgbox.com/d0/aa/Czp3Hgyh_o.png" width="886"></p> 
<hr> 
<p><img alt="" class="has" height="220" src="https://images2.imgbox.com/a5/0d/Ppg3MJVN_o.png" width="816"></p> 
<p><span style="color:#000000;">程序的入口成了</span><strong><span style="color:#000000;">_tmain()</span></strong><span style="color:#000000;">，这个和 </span><span style="color:#000000;">VC6.0 </span><span style="color:#000000;">中的 </span><strong><span style="color:#000000;">main </span></strong><span style="color:#000000;"><strong>函数</strong>类似， <strong>在前面加个 t</strong></span><strong><span style="color:#000000;">，是为了对 </span><span style="color:#000000;">unicode </span></strong><span style="color:#000000;"><strong>项目的设置兼容</strong>，但它们都是<strong>程序执行的入口</strong>，其中<strong> </strong></span><span style="color:#000000;"><strong>int argc 是程序的参数个数</strong>，_TCHAR* argv[]</span><span style="color:#000000;">是参数数组。</span></p> 
<hr> 
<blockquote> 
 <h2><span style="color:#000000;"><strong>程序的编译与链接，</strong></span><span style="color:#000000;"><strong>PE </strong></span><span style="color:#000000;"><strong>格式</strong></span></h2> 
 <p><span style="color:#000000;">一个<strong>完整的 PE</strong></span><span style="color:#000000;">（</span><span style="color:#000000;">Portable Executable</span><span style="color:#000000;">）</span><span style="color:#000000;">文件由 </span><strong><span style="color:#000000;">DOS </span></strong><span style="color:#000000;"><strong>头</strong>，</span><strong><span style="color:#000000;">PE </span></strong><span style="color:#000000;"><strong>文件头</strong>，<strong>块表</strong>，<strong>块</strong> 和<strong>调试信息（调试版本有效）</strong>组成</span></p> 
 <p><img alt="" class="has" height="466" src="https://images2.imgbox.com/9a/53/YrM66Bjx_o.png" width="415"></p> 
 <p><span style="color:#000000;">在<strong> </strong></span><strong><span style="color:#000000;">DOS </span></strong><span style="color:#000000;"><strong>头部</strong>，<strong>以 </strong></span><strong><span style="color:#000000;">e_magic </span></strong><span style="color:#000000;"><strong>开头</strong>，</span><span style="color:#3399ea;">它的值是固定的”0x5a4d”，即（MZ）开头</span><span style="color:#000000;">。最开头的 是部分是 DOS </span><span style="color:#000000;">部首，</span><span style="color:#000000;">DOS </span><span style="color:#000000;">部首由两部分组成：</span><strong><span style="color:#000000;">DOS </span><span style="color:#000000;">的 </span><span style="color:#000000;">MZ </span><span style="color:#000000;">文件标志和 </span><span style="color:#000000;">DOS stub(DOS </span><span style="color:#000000;">存根程序)</span></strong><span style="color:#000000;">。</span><span style="color:#3399ea;">之所以设置 DOS 部首是微软为了兼容原有的 DOS 系统下的程序而设立的。 </span></p> 
</blockquote> 
<hr> 
<blockquote> 
 <h2><span style="color:#000000;"><strong>系统与程序的内存布局 </strong></span></h2> 
 <p><span style="color:#000000;">在我们开始<strong>内核调试</strong>之前，首先我们需要对<strong>系统的内存</strong></span><span style="color:#3399ea;">内核层与应用层</span><span style="color:#000000;">的布局有一个基本认 识。以 X86 </span><span style="color:#000000;">为例，</span><span style="color:#000000;">X86 </span><span style="color:#000000;">支持 </span><span style="color:#000000;">32 </span><span style="color:#000000;">位寻址，因此可以支持最大 2^32=4GB 的虚拟内存空间（当然 也可以通过 PAE </span><span style="color:#000000;">将寻址空间扩大到 </span><span style="color:#000000;">64GB</span><span style="color:#000000;">，</span><span style="color:#000000;">PAE </span><span style="color:#000000;">即 </span><span style="color:#000000;">Physical address extension</span><span style="color:#000000;">，</span><strong><span style="color:#000000;">x86 </span></strong><span style="color:#000000;"><strong>的处理器增加了额外的地址线以选择那些增加了的内存</strong>，所以实体内存的大小从 32 </span><span style="color:#000000;">位增加到了 </span><span style="color:#000000;">36 </span><span style="color:#000000;">位。 最大的实体内存由 4GB </span><span style="color:#000000;">增加到了 </span><span style="color:#000000;">64GB</span><span style="color:#000000;">）。如下图所示，<strong>在 </strong></span><strong><span style="color:#000000;">4G </span></strong><span style="color:#000000;"><strong>的虚拟地址空间中</strong>，</span><span style="color:#000000;"><strong>Windows系统的内存</strong>主要分为</span><span style="color:#e579b6;">内核空间</span><span style="color:#000000;">和</span><span style="color:#e579b6;">应用层空间</span><span style="color:#000000;">上下两部分，<strong>每部分各占约 2GB</strong></span><span style="color:#000000;">，其中还包括了<strong> 一个 64KB </strong></span><strong><span style="color:#000000;">的 </span><span style="color:#000000;">NULL </span></strong><span style="color:#000000;"><strong>空间</strong>以及<strong>非法区域</strong>，</span><span style="color:#7c79e5;">虚拟地址再通过<strong>页表机制</strong>映射到物理地址以便存取物理内存中的数据和指令。</span></p> 
 <p><img alt="" class="has" height="439" src="https://images2.imgbox.com/3a/66/CXJn8358_o.png" width="476"></p> 
 <hr> 
 <p><span style="color:#000000;">X64</span><span style="color:#000000;">（</span><span style="color:#000000;">AMD64</span><span style="color:#000000;">）的内存布局与 </span><span style="color:#000000;">X86 </span><span style="color:#000000;">的内存布局类似，<strong>不同的地方在于各自空间的范围和大小不同</strong>，同时<strong> X64 </strong></span><strong><span style="color:#000000;">下还存在着一些空洞（</span><span style="color:#000000;">hole</span></strong><span style="color:#000000;"><strong>）</strong>。在 </span><span style="color:#000000;">X64 </span><span style="color:#000000;">内存理论上支持最大 </span><span style="color:#000000;">2^64的寻址空间，但实际上这个空间太大了，目前根本用不完，因此实际上的 X64 </span><span style="color:#000000;">系统一般都只支持到 40多位（比如</span><strong><span style="color:#000000;">Windows</span><span style="color:#000000;">支持</span><span style="color:#000000;">44</span><span style="color:#000000;">位最大寻址空间为</span><span style="color:#000000;">16TB</span></strong><span style="color:#000000;">，</span><strong><span style="color:#000000;">Linux </span><span style="color:#000000;">支持</span><span style="color:#000000;">48</span><span style="color:#000000;">位最大寻址空间</span><span style="color:#000000;">256TB </span></strong><span style="color:#000000;">等），支持的空间达到了 TB </span><span style="color:#000000;">级别。但是，无论是在<strong>内核空间</strong>还是在<strong>应用层空间</strong>，这些上 </span><span style="color:#000000;">TB的空间并不都是可用的，存在着所谓的空洞（HOLE</span><span style="color:#000000;">）。 </span></p> 
 <p><img alt="" class="has" height="459" src="https://images2.imgbox.com/19/37/p1pxAEzf_o.png" width="668"></p> 
 <p><img alt="" class="has" height="481" src="https://images2.imgbox.com/78/1e/IRIOZGGz_o.png" width="419"></p> 
</blockquote> 
<hr> 
<blockquote> 
 <h2><span style="color:#000000;"><strong>Bit </strong></span><span style="color:#000000;"><strong>与 </strong></span><span style="color:#000000;"><strong>Byte </strong></span></h2> 
 <p><strong><span style="color:#000000;">1byte=8bit </span></strong></p> 
 <p><strong><span style="color:#000000;">1 </span><span style="color:#000000;">个 </span><span style="color:#000000;">bit </span><span style="color:#000000;">只能存储 </span><span style="color:#000000;">2 </span><span style="color:#000000;">个信息：</span><span style="color:#000000;">0,1 </span></strong></p> 
 <p><span style="color:#000000;">1 </span><span style="color:#000000;">个 </span><span style="color:#000000;">byte </span><span style="color:#000000;">能存储：</span><span style="color:#000000;">2^8-1 </span><span style="color:#000000;">个信息：<strong>【</strong></span><strong><span style="color:#000000;">-128</span><span style="color:#000000;">，</span><span style="color:#000000;">127</span><span style="color:#000000;">】</span><span style="color:#000000;">or</span><span style="color:#000000;">【</span><span style="color:#000000;">0</span><span style="color:#000000;">，</span><span style="color:#000000;">255</span><span style="color:#000000;">】 </span></strong></p> 
 <p><span style="color:#000000;">数据存储位置：寄存器，内存，磁盘等</span></p> 
 <p><img alt="" class="has" height="313" src="https://images2.imgbox.com/66/07/v6LiwYjY_o.png" width="687"></p> 
</blockquote> 
<hr> 
<blockquote> 
 <h2><span style="color:#000000;"><strong>整数的编码与存储 </strong></span></h2> 
 <p><span style="color:#000000;"><strong>整数包括负数，零，和正数</strong>。</span><span style="color:#f33b45;"><strong>计算机中的整数分为有符号数和无符号数</strong></span><span style="color:#000000;">。有符号数的最高位表示符号：即最高位为 0</span><span style="color:#000000;">，表示正数，最高位为 </span><span style="color:#000000;">1</span><span style="color:#000000;">，表示负数。</span><span style="color:#f33b45;"><strong>无符号数表示非负数</strong></span><span style="color:#000000;">，<strong>整个位数都用来表示整数的值</strong>。 如果用 N </span><span style="color:#000000;">位来表示整数，那么</span><span style="color:#f33b45;">有符号数的范围为： [-2^(N-1)，(2^(N-1))-1]</span><span style="color:#000000;">；</span><span style="color:#e579b6;">无符号数的表示范围为[0，(2^N)-1]</span><span style="color:#000000;">。比如，用 </span><span style="color:#000000;">8 </span><span style="color:#000000;">位来表示有符号整数，</span><span style="color:#3399ea;">由于第 8 位用于表示了符号，因此，整数的表示范围为<strong>[-128，+127]</strong>；如果是表示无符号整数，则表示范围为<strong>[0，255]</strong>。</span><span style="color:#3399ea;"> </span></p> 
 <hr> 
 <p><span style="color:#000000;"><strong>整数的编码 </strong></span></p> 
 <p><span style="color:#000000;"><strong>整数的编码</strong>分为<strong>原码、反码、和补码</strong>。</span><span style="color:#f33b45;">计算里使用的是<strong>补码</strong>的存储方式</span><span style="color:#000000;">。</span></p> 
 <p><strong><span style="color:#000000;">对于 </span><span style="color:#000000;">8 </span><span style="color:#000000;">位整数来说，补码的表示范围为</span><span style="color:#000000;">[-128</span><span style="color:#000000;">， 127]</span></strong></p> 
 <p><img alt="" class="has" height="225" src="https://images2.imgbox.com/2c/a3/eb24wbKv_o.png" width="835"></p> 
 <h4><span style="color:#000000;">那么有了原码，计算机为什么还要用补码呢？</span></h4> 
 <p><span style="color:#000000;">补码的设计目的是： </span></p> 
 <p><span style="color:#000000;">⑴<strong>使符号位能与有效值部分</strong>一起参加运算，从而简化运算规则。 </span></p> 
 <p><span style="color:#000000;">⑵<strong>使减法运算转换为加法运算</strong>，进一步简化计算机中运算器的线路设计。 </span></p> 
 <p><span style="color:#000000;">此外，</span><span style="color:#f33b45;"><strong>在补码中用-128 代替了-0</strong></span><span style="color:#000000;">，所以</span><span style="color:#f33b45;"><strong>没有+0 和-0 之分</strong></span><span style="color:#000000;">，符合常理，所以补码的表示范围 </span></p> 
 <p><span style="color:#000000;">为： </span><span style="color:#000000;">-128~0~127 </span><span style="color:#000000;">共 </span><span style="color:#000000;">256 </span><span style="color:#000000;">个。 </span></p> 
 <p><span style="color:#000000;">注意：</span><strong><span style="color:#000000;">-128 </span><span style="color:#000000;">没有相对应的原码和反码，</span><span style="color:#000000;">-128 </span><span style="color:#000000;">的补码为：</span><span style="color:#000000;">10000000</span></strong></p> 
 <hr> 
 <h4><span style="color:#000000;"><strong>整数的存储 </strong></span></h4> 
 <p><span style="color:#000000;">整数的存储分为<strong>高位优先存储（</strong></span><strong><span style="color:#000000;">big-endian</span></strong><span style="color:#000000;"><strong>）</strong>和<strong>低位优先存储（</strong></span><strong><span style="color:#000000;">little-endian</span></strong><span style="color:#000000;"><strong>）</strong></span></p> 
 <p><span style="color:#3399ea;">高位优先存储：高位首先存在低地址。 </span></p> 
 <p><span style="color:#3399ea;">低位优先存储：低位首先存在低地址。</span></p> 
 <p><span style="color:#000000;">假设一个 </span><span style="color:#000000;">32 </span><span style="color:#000000;">位整数的值为 </span><span style="color:#000000;">25000</span><span style="color:#000000;">。</span><span style="color:#000000;">25000 </span><span style="color:#000000;">的补码为：</span><span style="color:#000000;"> 0x000061a8</span><span style="color:#000000;">，共 </span><span style="color:#000000;">4 </span><span style="color:#000000;">个字节</span><span style="color:#000000;">(</span><span style="color:#000000;">注意到， 在十六进制中，2 </span><span style="color:#000000;">个数为一个字节），其中最左边的 </span><span style="color:#000000;">00 </span><span style="color:#000000;">是最高位，然后依次为 </span><span style="color:#000000;">00 </span><span style="color:#000000;">次高位， 61 次低位，</span><span style="color:#000000;">a8 </span><span style="color:#000000;">低位。 那么在内存中如何存放这 </span><span style="color:#000000;">4 </span><span style="color:#000000;">个字节呢？也就是</span><span style="color:#f33b45;"><strong>内存中的低地址</strong></span><span style="color:#000000;">是<strong>优先存放最高位还是最低位呢</strong>？ 下图是这一个整数的低位优先和高位优先的存储实例： </span></p> 
 <p><img alt="" class="has" height="346" src="https://images2.imgbox.com/e6/b1/JiN3F3Pl_o.png" width="771"></p> 
 <p><span style="color:#000000;">在上图中，高位优先的系统中，会优先把高位的 </span><span style="color:#000000;">00 </span><span style="color:#000000;">存放在低地址；而低位优先的系统正好 相反，将低位 a8 </span><span style="color:#000000;">优先存放在内存中的低地址。 </span></p> 
 <p><span style="color:#000000;">如何判断一个系统是低位优先或者高位优先？</span><span style="color:#000000;"> 首先，来看整数 1 </span><span style="color:#000000;">在高位优先和低位优先的系统中的存储。</span></p> 
 <p><img alt="" class="has" height="340" src="https://images2.imgbox.com/fa/c8/a31TgebV_o.png" width="827"></p> 
 <hr> 
 <p><span style="color:#000000;">给出下面 </span><span style="color:#000000;">2 </span><span style="color:#000000;">种判断方法的代码： </span></p> 
 <pre class="has"><code class="language-cpp">//第一种方法：
bool is_integer_lower_store()
{
 int x = 0x1;
 char *p = (char *)&amp;x;
 if (*p == 1)
 return true;
 else
 return false;
}
//第二种方法：
typedef union {
 char c;
 int a;
} U;
bool is_integer_lower_store()
{
 U u;
 u.a = 1;
 if (u.c == 1)
 return true;
 else
 return false;
}</code></pre> 
 <p> <span style="color:#000000;">在这两种判断方法中，都利用了 <strong>0x01 </strong></span><strong><span style="color:#000000;">在低位优先中最低字节值为 </span><span style="color:#000000;">1</span><span style="color:#000000;">，在高位优先中最低值 为 0 </span></strong><span style="color:#000000;"><strong>的特性</strong>。用</span><span style="color:#f33b45;"><strong>一个</strong></span><span style="color:#3399ea;"><strong>指向字符的指针</strong></span><span style="color:#f33b45;"><strong>就可以获得 </strong></span><span style="color:#3399ea;"><strong>int 整数的第一个字节</strong></span><span style="color:#000000;">。获得了第一个字节的值，就可以根据上面的特性来判断出系统究竟是低位优先还是高位优先。</span></p> 
</blockquote> 
<blockquote> 
 <h3><span style="color:#000000;">题目：设计一个算法，改变一个整数的存储方式，即低位优先</span><span style="color:#000000;">&lt;--&gt;</span><span style="color:#000000;">高位优先 </span></h3> 
 <pre class="has"><code class="language-cpp">int change_int_storage(int val)
{
 int iRun = 0, i = 0;
 char* pByte= (char*)&amp;val; //指向整数的低地址，取一个字节
 i = sizeof(int)-1;
 while (i &gt;= 0)
 {
 //把整数的第 1 字节，第 2 字节，第 3 字节，第四 4 字节一次左移 24 位，16 位，8 位和 0 位
 iRun |= *pByte&lt;&lt;(i*8);
 pByte++;//前进一个字节
 i--;
 }
 return iRun;
}</code></pre> 
 <p> </p> 
</blockquote> 
<blockquote> 
 <h2><span style="color:#000000;"><strong>网络字节序 </strong></span></h2> 
 <p><span style="color:#000000;">       由于现实的系统中，<strong>不同的系统采取的</strong></span><span style="color:#3399ea;"><strong>整数存储的方式</strong></span><span style="color:#000000;"><strong>不一样</strong>，有的使用的是低位优先，有 的使用的是高位优先存储方式。 那么将一个整数值，通过网络从一台机器发送到另外一台机器之后，整数的存储方式可能就变了。 </span></p> 
 <p><span style="color:#000000;">      因此，为了使得<strong>整数在传输的过程中保持值不变</strong>，需要定义一个<strong>网络字节序</strong>和<strong>本地字节序</strong>。 也就是，把一个整数传输到网络的时候，统一转化为</span><span style="color:#f33b45;">网络字节序</span><span style="color:#000000;">。当这个整数通过网络传输到对方本地之后， 再统一把网络字节序转化为对应的本地字节序。 实际上，</span><span style="color:#f33b45;"><strong>网络字节序是高位优先存储方式</strong></span><span style="color:#000000;">。而到达对方系统之后，再根据对方使用的整数存储方法，转化为对应的本地字节序。 </span></p> 
 <p><span style="color:#000000;">      比如网络上有 </span><span style="color:#000000;">2 </span><span style="color:#000000;">台机器，一个整数 </span><span style="color:#000000;">0x12345678</span><span style="color:#000000;">，从一台系统中使用的是低位优先存储，传输到另外一台使用的是高位优先存储方式的机器中。 那么整数的传输为： </span></p> 
 <p><strong><span style="color:#000000;">            本地字节序：</span><span style="color:#000000;">0x78563421--&gt;</span><span style="color:#000000;">网络字节序：</span><span style="color:#000000;">0x12345678--&gt;</span><span style="color:#000000;">本地字节序：</span><span style="color:#000000;">0x12345678 </span></strong></p> 
 <p><span style="color:#000000;">      在实际的网络编程中，我们一般使用<strong> </strong></span><strong><span style="color:#000000;">htonl()</span></strong><span style="color:#000000;">来实现<strong>本地字节序到网络字节序转</strong>换； 使用 </span><strong><span style="color:#000000;">ntohl()</span></strong><span style="color:#000000;">来实现从<strong>网络字节序到本地字节序的转换</strong>。 </span></p> 
</blockquote> 
<hr> 
<blockquote> 
 <h2><span style="color:#000000;"><strong>进制转换</strong></span></h2> 
 <p><span style="color:#f33b45;"><strong>在计算机里，最基本的存储单位为字节</strong></span><span style="color:#000000;">（<strong>Byte</strong></span><strong><span style="color:#000000;">，常说的大 </span><span style="color:#000000;">B</span></strong><span style="color:#000000;">），</span><span style="color:#000000;">1 </span><span style="color:#000000;">个字节包含 </span><span style="color:#000000;">8 </span><span style="color:#000000;">位（</span><strong><span style="color:#000000;">bit</span></strong><span style="color:#000000;"><strong>，常 说的小 </strong>b</span><span style="color:#000000;">）。<strong>计算机的数据就是一个字节一个字节的形式存储在内存中。 </strong></span></p> 
 <p><span style="color:#000000;"><strong>内存的大小单位</strong>有 </span><span style="color:#000000;">KB</span><span style="color:#000000;">，</span><span style="color:#000000;">MB</span><span style="color:#000000;">，</span><span style="color:#000000;">GB</span><span style="color:#000000;">，</span><span style="color:#000000;">TB </span><span style="color:#000000;">等，它们之间的关系是： </span></p> 
 <p><span style="color:#000000;">1KB = 1024B </span></p> 
 <p><span style="color:#000000;">1MB = 1024*1024B </span></p> 
 <p><span style="color:#000000;">1GB = 1024*1024*1024B </span></p> 
 <p><span style="color:#000000;">1TB = 1024*1024*1024*1024B </span></p> 
 <p><span style="color:#000000;"><strong>计算机存储单位</strong>一般用 </span><span style="color:#000000;">B</span><span style="color:#000000;">，</span><span style="color:#000000;">KB</span><span style="color:#000000;">，</span><span style="color:#000000;">MB</span><span style="color:#000000;">，</span><span style="color:#000000;">GB</span><span style="color:#000000;">，</span><span style="color:#000000;">TB</span><span style="color:#000000;">，</span><span style="color:#000000;">PB</span><span style="color:#000000;">，</span><span style="color:#000000;">EB</span><span style="color:#000000;">，</span><span style="color:#000000;">ZB</span><span style="color:#000000;">，</span><span style="color:#000000;">YB</span><span style="color:#000000;">，</span><span style="color:#000000;">BB </span><span style="color:#000000;">来表示。 </span></p> 
 <p><span style="color:#000000;">1KB (Kilobyte </span><span style="color:#000000;">千字节</span><span style="color:#000000;">)=1024B </span></p> 
 <p><span style="color:#000000;">1MB (Megabyte </span><span style="color:#000000;">兆字节 简称</span><span style="color:#000000;">“</span><span style="color:#000000;">兆</span><span style="color:#000000;">”)=1024KB </span></p> 
 <p><span style="color:#000000;">1GB (Gigabyte </span><span style="color:#000000;">吉字节 又称</span><span style="color:#000000;">“</span><span style="color:#000000;">千兆</span><span style="color:#000000;">”)=1024MB </span></p> 
 <p><span style="color:#000000;">1TB (Trillionbyte </span><span style="color:#000000;">万亿字节 太字节</span><span style="color:#000000;">)=1024GB</span><span style="color:#000000;">，其中 </span><span style="color:#000000;">1024=2^10 ( 2 </span><span style="color:#000000;">的 </span><span style="color:#000000;">10 </span><span style="color:#000000;">次方</span><span style="color:#000000;">) </span></p> 
 <p><span style="color:#000000;">1PB</span><span style="color:#000000;">（</span><span style="color:#000000;">Petabyte </span><span style="color:#000000;">千万亿字节 拍字节）</span><span style="color:#000000;">=1024TB </span></p> 
 <p><span style="color:#000000;">1EB</span><span style="color:#000000;">（</span><span style="color:#000000;">Exabyte </span><span style="color:#000000;">百亿亿字节 艾字节）</span><span style="color:#000000;">=1024PB </span></p> 
 <p><span style="color:#000000;">1ZB (Zettabyte </span><span style="color:#000000;">十万亿亿字节 泽字节</span><span style="color:#000000;">)= 1024 EB </span></p> 
 <p><span style="color:#000000;">1YB (Yottabyte </span><span style="color:#000000;">一亿亿亿字节 尧字节</span><span style="color:#000000;">)= 1024 ZB </span></p> 
 <p><span style="color:#000000;">1BB (Brontobyte </span><span style="color:#000000;">一千亿亿亿字节</span><span style="color:#000000;">)= 1024 YB </span></p> 
 <hr> 
 <p><span style="color:#f33b45;"><strong>计算机中的数，是以二进制存在于内存中</strong></span></p> 
 <hr> 
 <p><span style="color:#000000;"><strong>10 </strong></span><span style="color:#000000;"><strong>进制转换为 </strong></span><span style="color:#000000;"><strong>16 </strong></span><span style="color:#000000;"><strong>进制 </strong></span>：<span style="color:#000000;">先把 10 </span><span style="color:#000000;">进制数转化为 </span><span style="color:#000000;">2 </span><span style="color:#000000;">进制数，然后再把 </span><span style="color:#000000;">2进制数转化为 16 </span><span style="color:#000000;">进制数。 </span></p> 
 <p><span style="color:#000000;">     比如，100 </span><span style="color:#000000;">对应的二进制我们很快就能求出来是：</span><span style="color:#000000;">1100100</span><span style="color:#000000;">，把这个 </span><span style="color:#000000;">2 </span><span style="color:#000000;">进制按照 </span><span style="color:#000000;">4 </span><span style="color:#000000;">位为一个 单位进行转化，0110 0100--&gt;64 </span><span style="color:#000000;">所以对应的 </span><span style="color:#000000;">16 </span><span style="color:#000000;">进制为：</span><span style="color:#000000;">0x64</span><span style="color:#000000;">。</span></p> 
</blockquote> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/47fc886780457869b613ae4e784b478c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JT808-2019和JT809-2019国标开发</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1173f1955073f6067ee076677d99a38b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何使用github生成jsDeliver自定义外部引入链接</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>