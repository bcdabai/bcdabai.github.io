<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式--代理模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式--代理模式" />
<meta property="og:description" content="程序的世界，从某种角度来说，存在两种角色， 功能提供者和功能使用者。一个良好的设计是提供者和使用者是松耦合的，提供者需要思考怎样设计才能做到对使用者影响最小。这就产生了一些设计原则和设计模式，指导提供者进行代码设计。
前人总结出来23种设计模式，今天看下代理模式。
代理模式分静态代理和动态代理。
静态代理， 代理类和被代理类实现相同接口，代理对象依赖被代理对象干活。代理类是服务提供者手动编写的，编译生成字节码由classloader加载。下面是静态代理的类图。
动态代理，与静态代理不同的是，代理类是程序运行过程中由一些框架帮助自动生成字节码文件由classloader加载。
根据框架不同，动态代理类或者实现被代理类的接口，或者直接继承被代理类。不管什么框架，动态代理类有一个共同点，动态代理类中的所有方法都是委托给一个handler实现。
我目前了解到的可以生成动态代理类的三种框架， JDK Proxy, CGLIB和Javassist。
JDK Proxy动态代理类图如下：
CGLIB动态代理类图如下：
Javassist动态代理类图如下：
代理模式的一些例子：
远程对象访问(RMI)，客户端的stub就是服务端服务的代理，客户端用户，就像调用本地服务一样调用远程服务，其实并不知道或者也不关心， RMI框架实际提供的服务对象是一个stub, stub封装了与远程对象通信的复杂流程。
Spring AOP是代理模式的典型应用，在不改变被代理对象的情况下，通过在其方法执行前后或者捕获某些异常等情况下添加一些业务逻辑，不改变业务接口却可以实现功能扩展。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/57f4aedb86e608eb495d8f1088f89ab8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-02-01T08:46:02+08:00" />
<meta property="article:modified_time" content="2018-02-01T08:46:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式--代理模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>程序的世界，从某种角度来说，存在两种角色， 功能提供者和功能使用者。一个良好的设计是提供者和使用者是松耦合的，提供者需要思考怎样设计才能做到对使用者影响最小。这就产生了一些设计原则和设计模式，指导提供者进行代码设计。</p> 
<p>前人总结出来23种设计模式，今天看下代理模式。</p> 
<p>代理模式分静态代理和动态代理。</p> 
<p>静态代理， 代理类和被代理类实现相同接口，代理对象依赖被代理对象干活。代理类是服务提供者手动编写的，编译生成字节码由classloader加载。下面是静态代理的类图。</p> 
<p><img src="https://images2.imgbox.com/95/5f/wUSnzTwU_o.png" alt=""><br></p> 
<p><br></p> 
<p>动态代理，与静态代理不同的是，代理类是程序运行过程中由一些框架帮助自动生成字节码文件由<span style="color:rgb(79,79,79);text-align:justify;">classloader</span>加载。</p> 
<p>根据框架不同，动态代理类或者实现被代理类的接口，或者直接继承被代理类。不管什么框架，动态代理类有一个共同点，动态代理类中的所有方法都是委托给一个handler实现。</p> 
<p>我目前了解到的可以生成动态代理类的三种框架， JDK Proxy, CGLIB和Javassist。</p> 
<p><br></p> 
<p>JDK Proxy动态代理类图如下：</p> 
<p><img src="https://images2.imgbox.com/c0/db/curvex8u_o.png" alt=""><br></p> 
<p><br></p> 
<p><br></p> 
<p>CGLIB动态代理类图如下：</p> 
<p><img src="https://images2.imgbox.com/b6/01/kIP16D8c_o.png" alt=""><br></p> 
<p><br></p> 
<p><br></p> 
<p>Javassist动态代理类图如下：</p> 
<p><img src="https://images2.imgbox.com/ad/e7/zeUicJdI_o.png" alt=""><br></p> 
<p></p> 
<p><br></p> 
<p>代理模式的一些例子：</p> 
<p>远程对象访问(RMI)，客户端的stub就是服务端服务的代理，客户端用户，就像调用本地服务一样调用远程服务，其实并不知道或者也不关心， RMI框架实际提供的服务对象是一个stub, stub封装了与远程对象通信的复杂流程。</p> 
<p>Spring AOP是代理模式的典型应用，在不改变被代理对象的情况下，通过在其方法执行前后或者捕获某些异常等情况下添加一些业务逻辑，不改变业务接口却可以实现功能扩展。</p> 
<div> 
 <br> 
</div> 
<br> 
<p><br></p> 
<p><br></p> 
<p><br></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8188e75dab67538bdb21355daa6dea5c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Tensorflow Estimators API使用介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f6ec7a5b10d0b5b0f23c6592b4a9e1e4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux查看历史命令history</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>