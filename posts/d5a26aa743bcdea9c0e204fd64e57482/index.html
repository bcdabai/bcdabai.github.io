<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>四、高性能 Go 语言发行版优化与落地实践 青训营笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="四、高性能 Go 语言发行版优化与落地实践 青训营笔记" />
<meta property="og:description" content=" 高性能 Go 语言发行版优化与落地实践 | 青训营笔记 这是我参与「第三届青训营 -后端场」笔记创作活动的的第4篇笔记
内存方面 一、自动内存管理 概念： Mutator：业务线程，分配新对象，修改对象指向关系（创建的goroutine）
Collector：GC线程，找到存活对象，回收死亡对象的内存空间
Serial GC：只有一个collector
Parallel GC：支持多个collectors同时回收的GC算法
Concurrent GC：mutator(s)和collector(s)可以同时执行
GC： GC算法：安全性、吞吐率、暂停时间、内存开销
追踪垃圾回收：
标记根对象标记可达对象清理不可达对象根据对象的生命周期使用不同的标记和清理策略 分代GC：
年龄：经历过GC的次数
目的：针对不同年龄年轻或者老年的对象，制定不同的GC策略，降低整体内存管理的开销
引用计数：
每个对象有与之关联的引用次数，大于0则是存活缺点是无法回收环形数据结构、维护引用计数开销较大 二、Go内存管理及优化 内存分配： 分块
缓存
管理优化
go的内存分配
实际优化方案：Balanced GC 编译器优化 一、编译器和静态分析 编译器结构： 静态分析： 过程内分析、过程间分析： 二、Go编译器优化 函数内联： 逃逸分析： 静态分析： 过程内分析、过程间分析： 二、Go编译器优化 函数内联： 逃逸分析： Beast mode " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d5a26aa743bcdea9c0e204fd64e57482/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-03T21:43:58+08:00" />
<meta property="article:modified_time" content="2022-07-03T21:43:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">四、高性能 Go 语言发行版优化与落地实践 青训营笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_Go____0"></a>高性能 Go 语言发行版优化与落地实践 | 青训营笔记</h2> 
<p>这是我参与「第三届青训营 -后端场」笔记创作活动的的第4篇笔记</p> 
<h3><a id="_4"></a>内存方面</h3> 
<h4><a id="_6"></a>一、自动内存管理</h4> 
<h5><a id="_8"></a>概念：</h5> 
<ul><li> <p>Mutator：业务线程，分配新对象，修改对象指向关系（创建的goroutine）</p> </li><li> <p>Collector：GC线程，找到存活对象，回收死亡对象的内存空间</p> </li><li> <p>Serial GC：只有一个collector</p> </li><li> <p>Parallel GC：支持多个collectors同时回收的GC算法</p> </li><li> <p>Concurrent GC：mutator(s)和collector(s)可以同时执行</p> <p><img src="https://images2.imgbox.com/91/25/20gR49Cw_o.png" alt="image-20220514194319723"></p> <p><img src="https://images2.imgbox.com/aa/2e/OmEcTM7I_o.png" alt="image-20220514194346802"></p> </li></ul> 
<h5><a id="GC_24"></a>GC：</h5> 
<ul><li> <p>GC算法：安全性、吞吐率、暂停时间、内存开销</p> </li><li> <p>追踪垃圾回收：</p> 
  <ul><li>标记根对象</li><li>标记可达对象</li><li>清理不可达对象</li><li>根据对象的生命周期使用不同的标记和清理策略</li></ul> </li><li> <p>分代GC：</p> 
  <ul><li> <p>年龄：经历过GC的次数</p> </li><li> <p>目的：针对不同年龄年轻或者老年的对象，制定不同的GC策略，降低整体内存管理的开销</p> <p><img src="https://images2.imgbox.com/23/3c/PJregqr9_o.png" alt="image-20220514195852135"></p> </li></ul> </li><li> <p>引用计数：</p> 
  <ul><li>每个对象有与之关联的引用次数，大于0则是存活</li><li>缺点是无法回收环形数据结构、维护引用计数开销较大</li></ul> </li></ul> 
<h4><a id="Go_48"></a>二、Go内存管理及优化</h4> 
<h5><a id="_50"></a>内存分配：</h5> 
<ul><li> <p>分块</p> </li><li> <p>缓存</p> </li><li> <p>管理优化</p> <p>go的内存分配</p> 
  <ul><li>实际优化方案：Balanced GC</li></ul> </li></ul> 
<h3><a id="_62"></a>编译器优化</h3> 
<h4><a id="_64"></a>一、编译器和静态分析</h4> 
<h5><a id="_66"></a>编译器结构：</h5> 
<h5><a id="_68"></a>静态分析：</h5> 
<h5><a id="_70"></a>过程内分析、过程间分析：</h5> 
<h4><a id="Go_72"></a>二、Go编译器优化</h4> 
<h5><a id="_74"></a>函数内联：</h5> 
<h5><a id="_76"></a>逃逸分析：</h5> 
<h4><a id="_78"></a>静态分析：</h4> 
<h5><a id="_80"></a>过程内分析、过程间分析：</h5> 
<h4><a id="Go_82"></a>二、Go编译器优化</h4> 
<h5><a id="_84"></a>函数内联：</h5> 
<h5><a id="_86"></a>逃逸分析：</h5> 
<h5><a id="Beast_mode_88"></a>Beast mode</h5>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df983bc8e20aa3e848a4197e42e21ca3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">三、高质量编程与性能调优实战 青训营笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/044f35397f0a0b77157057f5289e2d99/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">输入现在的日期,输出明天的日期</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>