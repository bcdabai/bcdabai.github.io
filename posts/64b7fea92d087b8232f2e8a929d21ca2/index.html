<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java集合（四）Map、HashMap - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java集合（四）Map、HashMap" />
<meta property="og:description" content="文章目录 【Map】一、Map简介二、常见Map实现类比较*2.1 HashMap和TreeMap2.2 HashMap和ConcurrentHashMap2.3 ConcurrentHashMap和Hashtable2.4 HashTable和HashMap 三、Map的相关问题3.1 Map接口提供了哪些不同的集合视图*3.2 在解决hash冲突的时候，为什么选择先用链表，再转红黑树*3.3 HashMap设计成数组（哈希表）&#43;链表（和红黑树）的优点 【HashMap】一、HashMap介绍1.1 HashMap的特点*1.2 HashMap的使用 二、从源码理解HashMap2.1 Node*2.2 哈希函数*2.3 创建HashMap对象2.4 添加元素*2.5 删除元素2.6 获取元素2.7 是否包含某个key/value2.8 遍历2.9 扩容机制* 三、HashMap常见问题3.1 HashMap的设计相关问题3.1.1 HashMap的数组长度为什么一定是2的次幂*3.1.2 HashMap默认加载因子为什么是0.75*3.1.3 HashMap链表转红黑树的阈值为什么是83.1.4 HashMap红黑树转链表的阈值为什么是63.1.5 HashMap是怎么解决哈希冲突的3.1.6 负载因子的大小，对HashMap有什么影响 3.2 HashMap在JDK1.7和JDK1.8中的区别*3.3 HashMap中的key*3.4 HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标3.5 HashMap在多线程下的问题3.5.1 JDK1.7中HashMap在多线程环境下的问题（死循环）*3.5.2 JDK1.8中HashMap在多线程环境下的问题（数据覆盖）* Java集合（一）集合框架概述
Java集合（二）List、ArrayList、LinkedList
Java集合（三）CopyOnWriteArrayList、Vector、Stack
Java集合（四）Map、HashMap
Java集合（五）LinkedHashMap、TreeMap
Java集合（六）Hashtable、ConcurrentHashMap
Java集合（七）Set、HashSet、LinkedHashSet、TreeSet
Java集合（八）BlockingQueue、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue
【Map】 一、Map简介 Collection接口的实现类中存储的是具体的单个元素，Map中存储的是键值对。
常用的Map实现类有：HashMap、LinkedHashMap、TreeMap、HashTable和ConcurrentHashMap。
优点缺点HashMap基于哈希表实现，查询快，效率高元素存储时无序，非线程安全LinkedHashMap基于哈希表和链表实现，可以保留元素插入时的顺序非线程安全TreeMap存储的元素有序非线程安全HashTable线程安全，不允许null值效率低ConcurrentHashMap线程安全，性能较好 至于具体使用哪个Map时，参考：
在Map中，HashMap是适用性最广的。也就是说如果要确定用Map，但不确定用哪种Map，一般可以使用HashMap。
如果要用线程安全的Map，就用ConcurrentHashMap。
二、常见Map实现类比较* 2.1 HashMap和TreeMap HashMapTreeMap是否线程安全非线程安全非线程安全元素是否排序否是效率高（哈希表）低（树）底层实现JDK1.7是数组&#43;链表，JDK1.8是数组&#43;链表&#43;红黑树红黑树适用场景元素不需要排序元素需要排序 2.2 HashMap和ConcurrentHashMap HashMapConcurrentHashMap是否线程安全非线程安全线程安全底层实现数组&#43;链表(JDK1.8之前)
数组&#43;链表&#43;红黑树(JDK1.8之后)segment数组&#43;链表(JDK1.8之前)
数组&#43;链表&#43;红黑树(JDK1.8之后)是否支持Null值键值都允许有Null键值都不允许有Null 可以将ConcurrentHashMap理解为HashMap的高并发版本。
2.3 ConcurrentHashMap和Hashtable ConcurrentHashMapHashtable线程安全的实现方式JDK1.7是segment分段锁
JDK1.8是CAS和synchronized全局synchronized锁效率高低默认大小1611扩容2倍newCapacity = oldCapacity * 2 &#43; 1底层数据结构JDK1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/64b7fea92d087b8232f2e8a929d21ca2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-26T20:19:27+08:00" />
<meta property="article:modified_time" content="2024-01-26T20:19:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java集合（四）Map、HashMap</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Map_11" rel="nofollow">【Map】</a></li><li><ul><li><a href="#Map_12" rel="nofollow">一、Map简介</a></li><li><a href="#Map_27" rel="nofollow">二、常见Map实现类比较*</a></li><li><ul><li><a href="#21_HashMapTreeMap_28" rel="nofollow">2.1 HashMap和TreeMap</a></li><li><a href="#22_HashMapConcurrentHashMap_36" rel="nofollow">2.2 HashMap和ConcurrentHashMap</a></li><li><a href="#23_ConcurrentHashMapHashtable_44" rel="nofollow">2.3 ConcurrentHashMap和Hashtable</a></li><li><a href="#24_HashTableHashMap_71" rel="nofollow">2.4 HashTable和HashMap</a></li></ul> 
   </li><li><a href="#Map_99" rel="nofollow">三、Map的相关问题</a></li><li><ul><li><a href="#31_Map_100" rel="nofollow">3.1 Map接口提供了哪些不同的集合视图*</a></li><li><a href="#32_hash_120" rel="nofollow">3.2 在解决hash冲突的时候，为什么选择先用链表，再转红黑树*</a></li><li><a href="#33_HashMap_122" rel="nofollow">3.3 HashMap设计成数组（哈希表）+链表（和红黑树）的优点</a></li></ul> 
  </li></ul> 
  </li><li><a href="#HashMap_125" rel="nofollow">【HashMap】</a></li><li><ul><li><a href="#HashMap_126" rel="nofollow">一、HashMap介绍</a></li><li><ul><li><a href="#11_HashMap_140" rel="nofollow">1.1 HashMap的特点*</a></li><li><a href="#12_HashMap_155" rel="nofollow">1.2 HashMap的使用</a></li></ul> 
   </li><li><a href="#HashMap_217" rel="nofollow">二、从源码理解HashMap</a></li><li><ul><li><a href="#21_Node_255" rel="nofollow">2.1 Node*</a></li><li><a href="#22__288" rel="nofollow">2.2 哈希函数*</a></li><li><a href="#23_HashMap_316" rel="nofollow">2.3 创建HashMap对象</a></li><li><a href="#24__349" rel="nofollow">2.4 添加元素*</a></li><li><a href="#25__461" rel="nofollow">2.5 删除元素</a></li><li><a href="#26__526" rel="nofollow">2.6 获取元素</a></li><li><a href="#27_keyvalue_562" rel="nofollow">2.7 是否包含某个key/value</a></li><li><a href="#28___586" rel="nofollow">2.8 遍历</a></li><li><a href="#29__608" rel="nofollow">2.9 扩容机制*</a></li></ul> 
   </li><li><a href="#HashMap_761" rel="nofollow">三、HashMap常见问题</a></li><li><ul><li><a href="#31_HashMap_762" rel="nofollow">3.1 HashMap的设计相关问题</a></li><li><ul><li><a href="#311_HashMap2_763" rel="nofollow">3.1.1 HashMap的数组长度为什么一定是2的次幂*</a></li><li><a href="#312_HashMap075_809" rel="nofollow">3.1.2 HashMap默认加载因子为什么是0.75*</a></li><li><a href="#313_HashMap8_813" rel="nofollow">3.1.3 HashMap链表转红黑树的阈值为什么是8</a></li><li><a href="#314_HashMap6_815" rel="nofollow">3.1.4 HashMap红黑树转链表的阈值为什么是6</a></li><li><a href="#315_HashMap_823" rel="nofollow">3.1.5 HashMap是怎么解决哈希冲突的</a></li><li><a href="#316_HashMap_840" rel="nofollow">3.1.6 负载因子的大小，对HashMap有什么影响</a></li></ul> 
    </li><li><a href="#32_HashMapJDK17JDK18_844" rel="nofollow">3.2 HashMap在JDK1.7和JDK1.8中的区别*</a></li><li><a href="#33_HashMapkey_888" rel="nofollow">3.3 HashMap中的key*</a></li><li><a href="#34_HashMaphashCodetable_896" rel="nofollow">3.4 HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标</a></li><li><a href="#35_HashMap_902" rel="nofollow">3.5 HashMap在多线程下的问题</a></li><li><ul><li><a href="#351_JDK17HashMap_903" rel="nofollow">3.5.1 JDK1.7中HashMap在多线程环境下的问题（死循环）*</a></li><li><a href="#352_JDK18HashMap_938" rel="nofollow">3.5.2 JDK1.8中HashMap在多线程环境下的问题（数据覆盖）*</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>    <a href="https://blog.csdn.net/m0_37741420/article/details/106884159" title="With a Title">Java集合（一）集合框架概述</a><br>     <a href="https://blog.csdn.net/m0_37741420/article/details/107013695" title="With a Title">Java集合（二）List、ArrayList、LinkedList</a><br>     <a href="https://blog.csdn.net/m0_37741420/article/details/107032686" title="With a Title">Java集合（三）CopyOnWriteArrayList、Vector、Stack</a><br>     Java集合（四）Map、HashMap<br>     <a href="https://blog.csdn.net/m0_37741420/article/details/123614527" title="With a Title">Java集合（五）LinkedHashMap、TreeMap</a><br>     <a href="https://blog.csdn.net/m0_37741420/article/details/135028798" title="With a Title">Java集合（六）Hashtable、ConcurrentHashMap</a><br>     <a href="https://blog.csdn.net/m0_37741420/article/details/112407684" title="With a Title">Java集合（七）Set、HashSet、LinkedHashSet、TreeSet</a><br>     <a href="https://blog.csdn.net/m0_37741420/article/details/120335698" title="With a Title">Java集合（八）BlockingQueue、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue</a></p> 
<h2><a id="Map_11"></a>【Map】</h2> 
<h3><a id="Map_12"></a>一、Map简介</h3> 
<p>  Collection接口的实现类中存储的是具体的单个元素，Map中存储的是键值对。<br>   常用的Map实现类有：HashMap、LinkedHashMap、TreeMap、HashTable和ConcurrentHashMap。</p> 
<table><thead><tr><th align="left"></th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">HashMap</td><td align="left">基于哈希表实现，查询快，效率高</td><td align="left">元素存储时无序，非线程安全</td></tr><tr><td align="left">LinkedHashMap</td><td align="left">基于哈希表和链表实现，可以保留元素插入时的顺序</td><td align="left">非线程安全</td></tr><tr><td align="left">TreeMap</td><td align="left">存储的元素有序</td><td align="left">非线程安全</td></tr><tr><td align="left">HashTable</td><td align="left">线程安全，不允许null值</td><td align="left">效率低</td></tr><tr><td align="left">ConcurrentHashMap</td><td align="left">线程安全，性能较好</td><td align="left"></td></tr></tbody></table> 
<p>  至于具体使用哪个Map时，参考：<br> <img src="https://images2.imgbox.com/a0/83/7PLdq9ey_o.png" alt="" width="500"><br>   <code>在Map中，HashMap是适用性最广的</code>。也就是说如果要确定用Map，但不确定用哪种Map，一般可以使用HashMap。<br>   如果要用线程安全的Map，就用ConcurrentHashMap。</p> 
<h3><a id="Map_27"></a>二、常见Map实现类比较*</h3> 
<h4><a id="21_HashMapTreeMap_28"></a>2.1 HashMap和TreeMap</h4> 
<table><thead><tr><th align="left"></th><th align="left">HashMap</th><th align="left">TreeMap</th></tr></thead><tbody><tr><td align="left">是否线程安全</td><td align="left">非线程安全</td><td align="left">非线程安全</td></tr><tr><td align="left">元素是否排序</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="left">效率</td><td align="left">高（哈希表）</td><td align="left">低（树）</td></tr><tr><td align="left">底层实现</td><td align="left">JDK1.7是数组+链表，JDK1.8是数组+链表+红黑树</td><td align="left">红黑树</td></tr><tr><td align="left">适用场景</td><td align="left">元素不需要排序</td><td align="left">元素需要排序</td></tr></tbody></table> 
<h4><a id="22_HashMapConcurrentHashMap_36"></a>2.2 HashMap和ConcurrentHashMap</h4> 
<table><thead><tr><th align="left"></th><th align="left">HashMap</th><th align="left">ConcurrentHashMap</th></tr></thead><tbody><tr><td align="left">是否线程安全</td><td align="left">非线程安全</td><td align="left">线程安全</td></tr><tr><td align="left">底层实现</td><td align="left">数组+链表(JDK1.8之前)<br>数组+链表+红黑树(JDK1.8之后)</td><td align="left">segment数组+链表(JDK1.8之前)<br>数组+链表+红黑树(JDK1.8之后)</td></tr><tr><td align="left">是否支持Null值</td><td align="left">键值都允许有Null</td><td align="left">键值都不允许有Null</td></tr></tbody></table> 
<p>  可以将ConcurrentHashMap理解为HashMap的高并发版本。</p> 
<h4><a id="23_ConcurrentHashMapHashtable_44"></a>2.3 ConcurrentHashMap和Hashtable</h4> 
<table><thead><tr><th align="left"></th><th align="left">ConcurrentHashMap</th><th align="left">Hashtable</th></tr></thead><tbody><tr><td align="left">线程安全的实现方式</td><td align="left">JDK1.7是segment分段锁<br>JDK1.8是CAS和synchronized</td><td align="left">全局synchronized锁</td></tr><tr><td align="left">效率</td><td align="left">高</td><td align="left">低</td></tr><tr><td align="left">默认大小</td><td align="left">16</td><td align="left">11</td></tr><tr><td align="left">扩容</td><td align="left">2倍</td><td align="left">newCapacity = oldCapacity * 2 + 1</td></tr><tr><td align="left">底层数据结构</td><td align="left">JDK1.7是数组+链表<br>JDK1.8是数组+链表+红黑树</td><td align="left">数组+链表</td></tr></tbody></table> 
<p>  ConcurrentHashMap和Hashtable最大的差异体现在实现线程安全的方式上。</p> 
<ul><li><strong>Hashtable（实现线程安全的方式）</strong><br>   Hashtable(同一把锁) ：使用synchronized来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态。如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，效率很低。<br> <img src="https://images2.imgbox.com/64/45/2fDO7K2G_o.png" alt=""></li><li><strong>JDK1.7版本的ConcurrentHashMap（实现线程安全的方式）</strong><br>   在JDK1.7中，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（<code>默认分配16个Segment，即最多同时有16个线程可以访问，是Hashtable效率的16倍</code>）<br>   ConcurrentHashMap中的Segment实现了ReentrantLock，所以Segment是一种可重入锁。<br>   一个ConcurrentHashMap里包含一个Segment数组。<code>Segment的结构和HashMap类似，是一种数组和链表结构</code>，一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment的锁。<br> <img src="https://images2.imgbox.com/b4/06/Pb4YL5MN_o.png" alt=""></li><li><strong>JDK1.8版本的ConcurrentHashMap</strong><br>   到了JDK1.8的时候，ConcurrentHashMap已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用synchronized和CAS来操作。<br> <img src="https://images2.imgbox.com/15/53/G95qXYVG_o.png" alt=""><br>   在并发环境下，选择Map实现类时，可以选择ConcurrentHashMap。<br>   虽然ConcurrentHashMap的整体性能要优于Hashtable，但在某些场景中，ConcurrentHashMap依然不能代替Hashtable。例如，在强一致的场景中ConcurrentHashMap就不适用，原因是ConcurrentHashMap中的get、size等方法没有用到锁，ConcurrentHashMap是弱一致性的，因此有可能会导致某次读无法马上获取到写入的数据。<br>   如果对数据有强一致要求，则需使用Hashtable；在大部分场景通常都是弱一致性的情况下，使用ConcurrentHashMap即可；如果数据量在千万级别，且存在大量增删改操作，则可以考虑使用ConcurrentSkipListMap。<br> <img src="https://images2.imgbox.com/19/a7/GZKkVPfO_o.png" alt=""></li></ul> 
<h4><a id="24_HashTableHashMap_71"></a>2.4 HashTable和HashMap</h4> 
<p>  HashTable和HashMap的不同点：</p> 
<table><thead><tr><th align="left"></th><th align="left">HashTable</th><th align="left">HashMap</th></tr></thead><tbody><tr><td align="left">线程安全性</td><td align="left">线程安全</td><td align="left">线程不安全</td></tr><tr><td align="left">效率</td><td align="left">低</td><td align="left">高</td></tr><tr><td align="left">对null key和null value的支持</td><td align="left">key、value都不能为null，否则会抛出空指针异常</td><td align="left">key、value都可为Null；<br>不过HashMap最多只允许一条记录的键为null；<br>允许多条记录的值为null。</td></tr><tr><td align="left">遍历方式</td><td align="left">支持Iterator和Enumeration两种遍历</td><td align="left">只支持Iterator遍历</td></tr><tr><td align="left">初始容量</td><td align="left">默认11</td><td align="left">默认16</td></tr><tr><td align="left">扩容大小</td><td align="left">2n+1</td><td align="left">2n</td></tr><tr><td align="left">底层结构</td><td align="left">数组+链表</td><td align="left">数组+链表+红黑树</td></tr></tbody></table> 
<ul><li><strong>是否支持fail-fast</strong><br>   HashMap的迭代器(Iterator)是fail-fast迭代器；而Hashtable的enumerator迭代器不是fail-fast的。<br>   HashMap提供对key的Set进行遍历，因此它是fail-fast的；HashTable提供对key的Enumeration进行遍历，它不支持fail-fast。</li><li><strong>计算hash值的方法</strong><br>  Hashtable直接使用对象的hashCode（即根据对象的地址或者字符串或者数字算出来的int类型的数值），然后再使用除留余数来获得最终的位置。 JDK1.8中Hashtable的哈希值计算方式：</li></ul> 
<pre><code class="prism language-java">   <span class="token keyword">int</span> hash <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">)</span> <span class="token operator">%</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
</code></pre> 
<p>  Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。<br>   HashMap为了提高计算效率，将哈希表的大小固定为了2的幂。在取模预算时，不需要做除法，只需要做位运算（位运算比除法的效率要高很多）。 JDK1.8中HashMap的哈希值计算方式：</p> 
<pre><code class="prism language-java">    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> h<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="Map_99"></a>三、Map的相关问题</h3> 
<h4><a id="31_Map_100"></a>3.1 Map接口提供了哪些不同的集合视图*</h4> 
<p>  Map接口提供三个集合视图。</p> 
<ul><li><strong>1、key的集合视图</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//a set view of the keys contained in this map</span>
	<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> <span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  返回Map中包含的所有key的一个Set视图。</p> 
<ul><li><strong>2、value的集合视图</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//a collection view of the values contained in this map</span>
	<span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  返回一个Map中包含的所有value的一个Collection视图。</p> 
<ul><li><strong>3、键值对的集合视图</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//a set view of the mappings contained in this map</span>
	<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  返回一个map钟包含的所有映射(键值对)的一个集合视图。</p> 
<h4><a id="32_hash_120"></a>3.2 在解决hash冲突的时候，为什么选择先用链表，再转红黑树*</h4> 
<p>  因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。<code>当元素小于8个的时候，链表结构可以保证查询性能</code>。当元素大于8个的时候， 红黑树搜索时间复杂度是O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是插入和删除节点的效率变慢了。如果一开始就用红黑树结构，元素太少，插入和删除节点的效率又比较慢，浪费性能。</p> 
<h4><a id="33_HashMap_122"></a>3.3 HashMap设计成数组（哈希表）+链表（和红黑树）的优点</h4> 
<p>  哈希表的优点：在哈希表中进行添加、删除、查找等操作，性能很好，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)。<br>   当哈希冲突时，一个节点就要保存多个数据。使用链表+红黑树，可以处理哈希冲突的情况，并且保存不错的查询效率。</p> 
<h2><a id="HashMap_125"></a>【HashMap】</h2> 
<h3><a id="HashMap_126"></a>一、HashMap介绍</h3> 
<p>  HashMap是基于哈希表的Map实现，其底层结构是数组，但数组中存的不是普通的某种类型的元素，存储的是链表或红黑树（1.7是数组+链表，1.8则是数组+链表+红黑树结构）。</p> 
<ul><li> <p><strong>哈希表</strong><br>   哈希表可以简单理解为<code>哈希表=哈希函数+数组</code>。比如一个键值对（key，value），哈希函数可以通过key计算出一个值，这个值就是数组的下标index，然后在数组的index把value存进去，这样就完成了一个键值对的存储。<br>   HashMap使用哈希表来存储的，哈希表为解决冲突，可以采用开放地址法和链地址法等来解决，<code>HashMap采用了链地址法</code>。链地址法简单来说就是数组加链表的结合，在每个数组元素上都有一个链表结构，当数据被hash后，得到数组下标位置，把数据放在对应数组下标元素的链表上。</p> </li><li> <p><strong>JDK1.7中的HashMap</strong><br> <img src="https://images2.imgbox.com/1c/52/SzTDwlip_o.png" alt=""><br>   HashMap里面是一个数组，数组中的每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类Entry的实例，Entry包含四个属性：key、value、hash和用于单向链表的next。</p> </li><li> <p><strong>JDK1.8中的HashMap结构</strong><br>   JDK1.8中对HashMap进行了一些修改，最大的不同就是利用了红黑树，所以其由数组+链表+红黑树组成。<br>   在JDK1.7中的HashMap中，查找元素时，根据hash值能够快速定位到数组的具体下标。之后需要顺着链表一个个比较下去才能找到我们需要的元素，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在JDK1.8中，当链表中的元素超过了8个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。<br>   JDK1.8版本里，HashMap的结构示例：<br> <img src="https://images2.imgbox.com/9b/57/Orf16lOY_o.png" alt=""></p> </li></ul> 
<h4><a id="11_HashMap_140"></a>1.1 HashMap的特点*</h4> 
<ul><li><strong>1、底层实现是 链表+数组+红黑树（JDK 1.8）</strong><br>   JDK 1.8的HashMap的数据结构是数组为主干，链表或红黑树为辅助（<code>链表节点较少时仍然是以链表存在，当链表节点较多时（大于8）会转为红黑树</code>）。当一个元素要存储HashMap时，先通过哈希方法找到要存入的数组的下标，然后将value存在对应的位置上。<br>   JDK1.8中引入红黑树，提高了HashMap的性能。</li><li><strong>2、HashMap的底层是个Node（键值对） 数组</strong><br>   在数组的具体索引位置，如果存在多个节点，则可能是以链表或红黑树的形式存在。</li><li><strong>3、HashMap的key和value都允许为空</strong></li><li><strong>4、HashMap的key不允许重复</strong><br>   当向HashMap中存入key相同的数据时，后者会覆盖前者，value允许重复。</li><li><strong>5、非线程安全</strong><br>   HashMap是非线程安全的，在并发场景下使用线程安全的集合ConcurrentHashMap来代替。</li><li><strong>6、元素无序</strong><br>   此处的无序指的是遍历HashMap中元素的顺序和存入HashMap中元素的顺序是基本不一致的(HashMap的遍历顺序是不确定的)。</li><li><strong>7、2倍扩容</strong><br>   2倍扩容可以保证元素减少哈希碰撞的概率，使元素分布得更加均匀。</li></ul> 
<h4><a id="12_HashMap_155"></a>1.2 HashMap的使用</h4> 
<ul><li><strong>1、构造方法</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//构造一个空的 HashMap ，具有默认初始容量（16）和默认负载因子（0.75）</span>
	<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//构造一个空的 HashMap，具有指定的初始容量和默认负载因子（0.75）</span>
	<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span>
	<span class="token comment">//构造一个空的 HashMap，具有指定的初始容量和负载因子</span>
	<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>2、遍历</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//获取HashMap中key的集合，用来遍历key</span>
	<span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span> <span class="token punctuation">&gt;</span></span> <span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//返回HashMap中Entry构成的Set，用来遍历&lt;key,value&gt;键值对</span>
	<span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//返回此HashMap中包含的value的集合</span>
	<span class="token keyword">public</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>3、获取某个key对应的value</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//返回到指定key所映射的value，不存在该key则返回null</span>
	<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span>
	<span class="token comment">//返回到指定key所映射的值，不存在该key则返回默认值</span>
	<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">getOrDefault</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> defaultValue<span class="token punctuation">)</span>	
</code></pre> 
<ul><li><strong>4、添加键值对</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//存入一个键值对，如果key存在则替换原有的键值对</span>
	<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>5、删除键值对</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//从该Map中删除指定key的映射</span>
	<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span>
	<span class="token comment">//删除指定key和指定value构成的键值对</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span>	
</code></pre> 
<ul><li><strong>6、键值对替换</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//替换指定key的value</span>
	<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span>
	<span class="token comment">//只有当指定key和指定value构成键值对时，才替换指定的value</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> oldValue<span class="token punctuation">,</span> <span class="token class-name">V</span> newValue<span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>7、包含判断</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//如果此HashMap包含指定key，则返回true</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span>
	<span class="token comment">//如果此HashMap包含指定value，则返回true</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value<span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>8、其他</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//判断HashMap中是否包含元素</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//清空HashMap</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	
	<span class="token comment">//返回此HashMap中键值对的数量</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	
</code></pre> 
<h3><a id="HashMap_217"></a>二、从源码理解HashMap</h3> 
<p>  先看一些变量：</p> 
<pre><code class="prism language-java">	<span class="token comment">//默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂</span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// aka 16</span>
	<span class="token comment">//最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） </span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>
	<span class="token comment">//默认负载因子</span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>
	<span class="token comment">//当桶(bucket)上的结点数大于这个值时会转成红黑树</span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token comment">//当桶(bucket)上的结点数小于这个值时树转链表</span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
	<span class="token comment">//桶中结构转化为红黑树对应的table的最小值</span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>
	<span class="token comment">//存储数据的Entry数组，长度是2的幂</span>
	<span class="token comment">//HashMap采用链表法解决冲突，每一个Entry本质上是一个单向链表</span>
	<span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
	<span class="token comment">//存放具体元素的集</span>
	<span class="token keyword">transient</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> entrySet<span class="token punctuation">;</span>
	<span class="token comment">//存放元素的个数，不等于数组的长度</span>
	<span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>
	<span class="token comment">//每次扩容和更改map结构的计数器</span>
	<span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>
	<span class="token comment">//临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>
	<span class="token keyword">int</span> threshold<span class="token punctuation">;</span>
	<span class="token comment">//负载因子</span>
	<span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>
</code></pre> 
<p>  从源码中能看出HashMap中的一些默认值：</p> 
<table><thead><tr><th align="left">类别</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">初始容量</td><td align="left">16</td></tr><tr><td align="left">最大容量</td><td align="left">2的30次方</td></tr><tr><td align="left">负载因子</td><td align="left">0.75</td></tr><tr><td align="left">链表转红黑树的节点阈值</td><td align="left">8</td></tr><tr><td align="left">红黑树转链表的节点阈值</td><td align="left">6</td></tr><tr><td align="left">链表转红黑树数组的元素个数阈值</td><td align="left">64</td></tr></tbody></table> 
<h4><a id="21_Node_255"></a>2.1 Node*</h4> 
<p>  在HashMap的底层数组中，存储的元素是Node。Node是HashMap 的一个内部类，其实现了Map.Entry接口，本质就是一个映射(键值对)。从Node的定义中只有next可以看出，<code>Node是单向的</code>：</p> 
<pre><code class="prism language-java">	<span class="token comment">//链表节点, 继承自Entry</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span> <span class="token comment">//哈希值，用来定位索引位置</span>
        <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>  <span class="token comment">//key</span>
        <span class="token class-name">V</span> value<span class="token punctuation">;</span>  <span class="token comment">//value</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>  <span class="token comment">//链表后置节点</span>

		<span class="token comment">//省略一些方法...</span>
		
		<span class="token comment">//每一个节点的hash值，是将key的hashCode和value的hashCode异或得到的</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>  可以看出：</p> 
<ul><li>1、HashMap的一个节点由4部分组成：哈希值、key、value和对下一个节点的引用。</li><li>2、hashcode，是根据key和value的哈希值共同计算的。</li><li>3、要比较两个节点是否相等时，节点中的key和value都相等才行。</li></ul> 
<h4><a id="22__288"></a>2.2 哈希函数*</h4> 
<p>  即hash(Object key)方法：</p> 
<pre><code class="prism language-java">	<span class="token comment">//JDK1.8中的哈希方法</span>
	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	     <span class="token keyword">int</span> h<span class="token punctuation">;</span>
	     <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>  HashMap的数据结构是：链表+数组/红黑树，所以HashMap里的元素位置应该尽量分布均匀些，使得每个位置上的元素尽量少（最理想的情况是每个位置只有一个元素）。<br>   我们可以将<code>hash</code>方法的内容分成两部分：</p> 
<pre><code class="prism language-java">	h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1、计算出key的哈希值</span>
	h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2、高位参与运算</span>
</code></pre> 
<p>  有了key对应的哈希值，就可以使用<code>(tab.length - 1) &amp; hash</code>来计算该key在数组中的下标，进而进行其他操作。<br>   不过在JDK1.8中，取模运算的步骤并没有被封装到hash方法里，什么时候用什么时候计算：</p> 
<pre><code class="prism language-java">	n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
	<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">;</span> <span class="token comment">//取模运算</span>
</code></pre> 
<p>  因此，JDK1.8中根据key计算对应的数组下标共三步：</p> 
<blockquote> 
 <ol><li>获取key的hashCode值。</li><li>高位运算。原始hashcode值的高16位异或低16位（<code>（h = key.hashCode()）^ （h &gt;&gt;&gt;16）</code>）</li><li>取模运算。</li></ol> 
</blockquote> 
<p>  HashMap底层的<code>数组长度length总是2的n次方时， h&amp;（length -1）运算等价于h % length （对length取模），但&amp;比%具有更高的效率</code>。<br> <img src="https://images2.imgbox.com/9d/8e/s2G8cAxS_o.png" alt=""></p> 
<h4><a id="23_HashMap_316"></a>2.3 创建HashMap对象</h4> 
<ul><li><strong>1、指定“容量大小”和“加载因子”</strong></li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>
                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY(2的30次方)                                     </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>
            initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>
        <span class="token comment">//加载因子不能小于0</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>
                                               loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>
        <span class="token comment">//根据初始容量，计算出扩容临界值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>2、其他的构造函数</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//只指定“容量大小”</span>
    <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token comment">//初始容量为16，加载因为为0.75</span>
    <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
</code></pre> 
<p>  在以上的三个构造方法中，常用的是无参构造方法。使用无参构造方法时，创建的HashMap初始容量为16，负载因子为0.75，图示：<br> <img src="https://images2.imgbox.com/97/96/4XtetyBX_o.png" alt=""></p> 
<h4><a id="24__349"></a>2.4 添加元素*</h4> 
<p>  HashMap中添加元素的过程：<br> <img src="https://images2.imgbox.com/07/05/2AyGNTpn_o.png" alt=""><br>   HashMap的put方法详细流程总结：</p> 
<ul><li>1、put(key, value)中直接调用了内部的putVal方法，并且先对key进行了hash操作。<br>   【<code>put方法中计算key的hash值，并调用putVal方法</code>】。</li><li>2、putVal方法中，先检查HashMap数据结构中的索引数组表是否位空，如果是的话则进行一次resize操作。<br>   【<code>判断数组是否为空，为空就扩容</code>】。</li><li>3、以HashMap索引数组表的长度减一与key的hash值进行与运算，得出在数组中的索引。如果索引指定的位置值为空，则新建一个k-v的新节点。<br>   【<code>如果计算出来的下标位置没值，直接插入</code>】。</li><li>4、如果不满足的3的条件，则说明索引指定的数组位置的已经存在内容，这个时候称之哈希碰撞。<br>   【<code>如果计算出来的位置没值，代表发生了哈希碰撞</code>】；</li><li>5、判断key索引到的节点（暂且称作被碰撞节点）的hash、key是否和当前待插入节点（新节点）的一致。如果新旧节点的内容不一致时，则再看被碰撞节点是否是树类型，如果是树类型的话，则按照树的操作去追加新节点内容；如果被碰撞节点不是树类型，则说明当前发生的碰撞在链表中（此时链表尚未转为红黑树），此时进入一轮循环处理逻辑中。<br>   【<code>判断发生哈希碰撞的位置是红黑树结构还是链表结构，如果是树类型的话，则按照树的操作去追加新节点，否则进入树结构处理逻辑</code>】。</li><li>6、循环中，先判断被碰撞节点的后继节点是否为空，为空则将新节点作为后继节点，作为后继节点之后并判断当前链表长度是否超过最大允许链表长度8，如果大于的话，需要进行一轮是否转树的判断；如果在一开始后继节点不为空，则先判断后继节点是否与新节点相同，相同的话就记录并跳出循环；如果两个条件判断都满足则继续循环，直至进入某一个条件判断然后跳出循环。<br>   【<code>挨个遍历链表上的Node的key和新插入节点的key是否相同，相同就替换value，否则追加。此过程中还要注意是否链表长度&gt;8，大于的话，就调用treeifyBin</code>】。</li><li>7、步骤8中转树的操作treeifyBin，如果map的索引表为空或者当前索引表长度还小于64（最大转红黑树的索引数组表长度），那么进行resize操作就行了；否则，就转换成红黑树，如果被碰撞节点不为空，那么就顺着被碰撞节点这条树往后新增该新节点。<br>   【<code>treeifyBin方法的逻辑：如果数组长度&gt;64才转换成红黑树，否则仅resize，再追加元素</code>】。</li><li>8、最后，回到那个被记住的被碰撞节点，如果它不为空，默认情况下，新节点的值将会替换被碰撞节点的值，同时返回被碰撞节点的值。<br>   【<code>返回旧value值</code>】。</li><li>9、在上面判断流程走完之后，计算HashMap全局的modCount值，并判断当前元素数是否大于容量扩充的阈值，大于的话则进行一轮resize操作。<br>   【<code>++modCount，再次判断是否需要扩容</code>】。</li></ul> 
<p>  HashMap的put方法简单流程总结：</p> 
<blockquote> 
 <ol><li>如果table没有初始化就先进行初始化过程。</li><li>使用hash算法计算key的索引。</li><li>判断索引处有没有存在元素，没有就直接插入。</li><li>如果索引处存在元素，则遍历插入，有两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入。</li><li>某个Node链表的数量大于阈值8 &amp;&amp; 数组容量 &gt;=64，就要转换成红黑树的结构。</li><li>添加成功后会检查是否需要扩容。</li></ol> 
</blockquote> 
<p>  添加元素代码：</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token comment">/**
     * @param hash 根据静态方法hash获得的hash值
     * @param key 键
     * @param value 值
     * @param onlyIfAbsent if true,当键相同时，不修改已存在的值
     * @param evict if false, the table is in creation mode. 不用管
     * @return previous value, or null if none 以前的value，或null
     */</span>
    <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//tab 哈希数组，p 该哈希桶的首节点，n hashMap的长度，i 计算出的数组下标</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
		<span class="token comment">//1.校验table是否为空或者length等于0，如果是则调用resize方法进行初始化</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 2.通过hash值计算索引位置，将该索引位置的头节点赋值给p，如果p为空则</span>
        <span class="token comment">//直接在该索引位置新增一个节点即可</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//发生了哈希碰撞（也就是该数组下标上已经存在着其它节点），有以下几种情况</span>
        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//e 临时节点的作用， k 存放该当前节点的key</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
            <span class="token comment">// 3.判断p节点的key和hash值是否跟传入的相等，如果相等, 则p节点</span>
            <span class="token comment">//即为要查找的目标节点，将p节点赋值给e节点（第一种情况）</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                e <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token comment">// 4.判断p节点是否为TreeNode, 如果是则调用红黑树的putTreeVal方法</span>
            <span class="token comment">//查找目标节点（第二种情况，hash值不等于首节点）</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 5.走到这代表p节点为普通链表节点，则调用普通的链表方法进行</span>
                <span class="token comment">//查找，使用binCount统计链表的节点数（第三种情况，hash值不等于首节点）</span>
                <span class="token comment">//遍历链表</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 6.如果p的next节点为空时，则代表找不到目标节点，则新增一个节点并插入链表尾部</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                         <span class="token comment">// 7.校验节点数是否超过8个，如果超过则调用treeifyBin方法</span>
                         <span class="token comment">//将链表节点转为红黑树节点，</span>
                        <span class="token comment">// 减一是因为循环是从p节点的下一个节点开始的</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> 
                        	<span class="token comment">//把这个链表转化成红黑树，然后直接退出循环</span>
                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 8.如果e节点的hash值和key值都与传入的相同，则e节点</span>
                    <span class="token comment">//即为目标节点，跳出循环</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token comment">// 将p指向下一个节点</span>
                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 9.如果e节点不为空，则代表目标节点存在，使用传入的value覆盖</span>
            <span class="token comment">//该节点的value，并返回oldValue</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
        <span class="token comment">// 10.如果插入节点后节点数超过阈值，则调用resize方法进行扩容</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="25__461"></a>2.5 删除元素</h4> 
<pre><code class="prism language-java"><span class="token comment">//移除某个节点</span>
<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span>
        <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span>
                           <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//tab 哈希数组，p 待删除节点的Node，n 长度，index 当前数组下标</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span>
    <span class="token comment">// 1.如果table不为空并且根据hash值计算出来的索引位置不为空, 将该位置的节点赋值给p</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//node 存储要删除的节点，e 临时变量，k 当前节点的key，v 当前节点的value</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> node <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span>
        <span class="token comment">// 2.如果p的hash值和key都与入参的相同, 则p即为要删除的目标节点, 赋值给node</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            node <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token comment">// 3.否则将p.next赋值给e，向下遍历节点</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 3.1 如果p是TreeNode则调用红黑树的方法查找节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 3.2 否则，进行普通链表节点的查找</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 当节点的hash值和key与传入的相同,则该节点即为目标节点</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>
                         <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        node <span class="token operator">=</span> e<span class="token punctuation">;</span>	
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>  <span class="token comment">// p节点赋值为本次结束的e，在下一次循环中，e为p的next节点</span>
                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// e指向下一个节点</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 4.如果node不为空(即根据传入key和hash值查找到目标节点)，则进行移除操作</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>
                             <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 4.1 如果是TreeNode则调用红黑树的移除方法</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 4.2 如果node是该索引位置的头节点则直接将该索引位置的值赋值为node的next节点，</span>
            <span class="token comment">// “node == p”只会出现在node是头节点的时候，如果node不是头节点，则node为p的next节点</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span>
                tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token comment">// 4.3 否则将node的上一个节点的next属性设置为node的next节点,</span>
            <span class="token comment">// 即将node节点移除, 将node的上下节点进行关联(链表的移除)</span>
            <span class="token keyword">else</span>
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
            <span class="token operator">--</span>size<span class="token punctuation">;</span>
            <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 5.返回被移除的节点</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="26__526"></a>2.6 获取元素</h4> 
<pre><code class="prism language-java"><span class="token comment">//以key为条件，找到返回value。没找到返回null</span>
<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//first 头结点，e 临时变量，n 长度,k key</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
    <span class="token comment">// 1.对table进行校验：table不为空 &amp;&amp; table长度大于0 &amp;&amp; </span>
    <span class="token comment">// table索引位置(使用table.length - 1和hash值进行位与运算)的节点不为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 2.检查first节点的hash值和key是否和入参的一样，如果一样则first即为目标节点，直接返回first节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment">// always check first node</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> first<span class="token punctuation">;</span>
        <span class="token comment">// 3.如果first不是目标节点，并且first的next节点不为空则继续遍历</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                <span class="token comment">// 4.如果是红黑树节点，则调用红黑树的查找目标节点方法getTreeNode</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 5.执行链表节点的查找，向下遍历链表, 直至找到节点的key和入参的key相等时,返回该节点</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 6.找不到符合的返回空</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="27_keyvalue_562"></a>2.7 是否包含某个key/value</h4> 
<p>  即containsKey和containsValue方法：</p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//调用核心方法getNode，判断是否存在对应节点</span>
		<span class="token keyword">return</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//其实就是遍历Node&lt;K,V&gt;数组，看要查询的指定value是否在数组的value中</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>
                        <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="28___586"></a>2.8 遍历</h4> 
<ul><li><strong>1、用于遍历键值对中的键</strong></li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> <span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> ks<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>ks <span class="token operator">=</span> keySet<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token punctuation">(</span>keySet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> ks<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>2、用于遍历键值对中的值</strong></li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> vs<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>vs <span class="token operator">=</span> values<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token punctuation">(</span>values <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> vs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>3、遍历键值对</strong></li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> es<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>es <span class="token operator">=</span> entrySet<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token punctuation">(</span>entrySet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EntrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> es<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="29__608"></a>2.9 扩容机制*</h4> 
<ul><li>1、在JDK1.8中，当HashMap中的键值数量对大于阀值（目前容量 * 负载因子）时或者初始化时，就调用resize方法进行扩容；</li><li>2、<strong>每次扩展的时候，都是扩展2倍</strong>；</li><li>3、<strong>扩展后Node对象的位置要么在原位置，要么移动到原始位置+增加的数组大小的位置</strong>。例如capacity为16，索引位置5的节点扩容后，只可能分布在新表<code>索引位置5</code>和<code>索引位置21（5+16）</code>。</li></ul> 
<p>  在putVal()中，在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12)，这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方。<br>   在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上。<br>   导致JDK1.8中，HashMap扩容后，同一个索引位置的节点重hash最多分布在两个位置的根本原因是：</p> 
<blockquote> 
 <ol><li>table的长度始终为2的n次方；</li><li>索引位置的计算方法为 “(table.length - 1) &amp; hash”。</li></ol> 
</blockquote> 
<p>  HashMap扩容是一个比较耗时的操作，定义HashMap时尽量给个接近的初始容量值。<br>   <code>1.8扩容</code>机制：当元素个数大于threshold时，会进行扩容，使用2倍容量的数组代替原有数组。<code>采用尾插入的方式将原数组元素拷贝到新数组</code>。1.8扩容之后链表元素相对位置没有变化，而1.7扩容之后链表元素会倒置。<br>   <code>1.7链表新节点采用的是头插法</code>，这样在线程一扩容迁移元素时，会将元素顺序改变，导致两个线程中出现元素的相互指向而形成循环链表，1.8采用了尾插法，避免了这种情况的发生。<br>   `头插法：1.7将新元素放到数组中，原始节点作为新节点的后继节点。尾插法：1.8遍历链表，将元素放置到链表的最后。</p> 
<p>  原数组的元素在重新计算hash之后，因为数组容量n变为2倍，那么n-1的mask范围在高位多1bit。在元素拷贝过程不需要重新计算元素在数组中的位置，只需要看看原来的hash值新增的那个bit是1还是0，是0的话索引没变，是1的话索引变成“原索引+oldCap”（根据 e.hash &amp; (oldCap - 1) == 0 判断） 。这样可以省去重新计算hash值的时间，而且由于新增的1bit是0还是1可以认为是随机的，因此resize的过程会均匀的把之前的冲突的节点分散到新的bucket。</p> 
<pre><code class="prism language-java"><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//oldTab 为当前表的哈希桶</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token comment">//记录一下原来哈希数组的长度、临界值</span>
    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
    <span class="token comment">//初始化新哈希表的长度和临界值</span>
    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 1.原数组的容量&gt;0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1.1 判断原数组的容量是否超过最大容量值（1 &lt;&lt; 30）：如果超过则将阈值设置</span>
        <span class="token comment">//为Integer.MAX_VALUE，并直接返回原数组。</span>
        <span class="token comment">// 此时oldCap * 2比Integer.MAX_VALUE大，因此无法进行重新分布，只是单纯地</span>
        <span class="token comment">//将阈值扩容到最大</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 1.2 否则，将newCap赋值为oldCap的2倍，如果newCap&lt;最大容量并且oldCap&gt;=16,</span>
        <span class="token comment">// 则将新阈值设置为原来的两倍</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token generics"><span class="token punctuation">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;</span><span class="token operator">&amp;</span>
                 oldCap <span class="token punctuation">&gt;</span></span><span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>
            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    <span class="token comment">// 2.如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    	<span class="token comment">//那么新表的容量就等于旧的阈值</span>
        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
    <span class="token comment">// 3.如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量/阈值参数的情况  </span>
    <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//此时新表的容量为默认的容量 16</span>
        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
        <span class="token comment">//新的阈值为默认容量16 * 默认加载因子0.75f = 12</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 4.//如果新的阈值是0，对应的是  当前表是空的，但是有阈值的情况</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//根据新表容量 和 加载因子 求出新的阈值</span>
        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
        <span class="token comment">//进行越界修复</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>
                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 5.//更新阈值 </span>
    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>
    <span class="token comment">//根据新的容量 构建新的哈希桶</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//更新哈希桶引用</span>
    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
    <span class="token comment">// 6.如果老数组不为空，则需遍历所有节点，将节点赋值给新数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//遍历老的哈希桶</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">//当前的节点 e</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
            <span class="token comment">//如果当前桶中有元素,则将链表赋值给e</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
                <span class="token comment">//把已经赋值之后的变量置位null, 以便垃圾收集器回收空间</span>
                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> 
                <span class="token comment">//如果当前链表中就一个元素，（没有发生哈希碰撞）</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                	<span class="token comment">//直接将这个元素放置在新的哈希桶里。</span>
                    <span class="token comment">//这里取下标 是用 哈希值 &amp; 桶的长度-1 。 </span>
                    <span class="token comment">//由于桶的长度是2的n次方，这么做其实是等于 一个模运算。但是效率更高</span>
                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token comment">// 8.如果是红黑树节点，则进行红黑树的重hash分布(跟链表的hash分布基本相同)</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，</span>
                <span class="token comment">//依次放入新哈希桶对应下标位置</span>
                <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">//因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来</span>
                    <span class="token comment">//的下标，即low位， 或者扩容后的下标，即high位。 </span>
                    <span class="token comment">//high位=  low位+原哈希桶容量</span>
                    <span class="token comment">//低位链表的头结点、尾节点</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token comment">//高位链表的头节点、尾节点</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> 
                    <span class="token comment">//临时节点 存放e的下一个节点</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
                    <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                        <span class="token comment">// 9.1 利用哈希值 &amp; 旧的容量，可以得到哈希值去模后，是大于等于</span>
                        <span class="token comment">//oldCap还是小于oldCap，等于0代表小于oldCap，应该存放在低位，</span>
                        <span class="token comment">//否则存放在高位</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        	<span class="token comment">// 如果loTail为空, 代表该节点为第一个节点</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
                            	<span class="token comment">// 则将loHead赋值为第一个节点</span>
                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span> 
                            <span class="token keyword">else</span>
                            	<span class="token comment">// 否则将节点添加在loTail后面</span>
                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>  
                            <span class="token comment">// 并将loTail赋值为新增的节点  </span>
                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span> 
                        <span class="token punctuation">}</span>
                        <span class="token comment">// 9.2 如果e的hash值与老数组的容量进行与运算为非0,则扩容后的</span>
                        <span class="token comment">//索引位置为高位</span>
                        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                        	<span class="token comment">// 如果hiTail为空, 代表该节点为第一个节点</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
                            	<span class="token comment">// 则将hiHead赋值为第一个节点</span>
                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span> 
                            <span class="token keyword">else</span>
                            	<span class="token comment">// 否则将节点添加在hiTail后面</span>
                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span> 
                            <span class="token comment">// 并将hiTail赋值为新增的节点   </span>
                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span> 
                        <span class="token punctuation">}</span>
                    <span class="token comment">// 并将hiTail赋值为新增的节点</span>
                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 10.将低位链表存放在原index处</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 11.将高位链表存放在新index处</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 12.返回新数组</span>
    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="HashMap_761"></a>三、HashMap常见问题</h3> 
<h4><a id="31_HashMap_762"></a>3.1 HashMap的设计相关问题</h4> 
<h5><a id="311_HashMap2_763"></a>3.1.1 HashMap的数组长度为什么一定是2的次幂*</h5> 
<p>  简单来说，就是让数据在哈希表上分布地更加均匀。</p> 
<p>  HashMap中根据key的哈希值计算下标的方式是<code>tab[i = (n - 1) &amp; hash]</code>，&amp;为二进制中的与运算。</p> 
<blockquote> 
 <p>与运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1;<br> 即：两位同时为“1”，结果才为“1”，否则为0。</p> 
</blockquote> 
<p>  因为HashMap的数组长度都是2的n次幂 ，那么对于这个数再减去1，转换成二进制的话，就肯定是最高位为0，其他位全是1的数。<br>   以数组长度为8为例，那8-1转成二进制的话，就是0111。 那我们举一个随便的hashCode值，与0111进行与运算看看结果如何：</p> 
<pre><code class="prism language-java"> 第一个key：        hashcode值：<span class="token number">10101001</span>    
                            <span class="token operator">&amp;</span>      <span class="token number">0111</span>                                      
                                   <span class="token number">0001</span>  （十进制为<span class="token number">1</span>）
 
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>                           
 第二个key：       hashcode值：<span class="token number">11101000</span>    
                           <span class="token operator">&amp;</span>       <span class="token number">0111</span>      
                                   <span class="token number">0000</span>  （十进制为<span class="token number">0</span>）
 
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>               
 第三个key：       hashcode值：<span class="token number">11101110</span>    
                          <span class="token operator">&amp;</span>       <span class="token number">0111</span>      
                                  <span class="token number">0110</span>  （十进制为<span class="token number">6</span>）
</code></pre> 
<p>  这样得到的数，就会完整的得到原hashcode值的低位值，不会受到与运算对数据的变化影响。<br>   如果数组容量为7，7减去1转换成二进制是0110，此时再进行与运算：</p> 
<pre><code class="prism language-java"> 第一个key：      hashcode值：<span class="token number">10101001</span>    
                         <span class="token operator">&amp;</span>       <span class="token number">0110</span>                                      
                                 <span class="token number">0000</span>  （十进制为<span class="token number">0</span>）
 
  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>                           
  第二个key：      hashcode值：<span class="token number">11101000</span>    
                          <span class="token operator">&amp;</span>       <span class="token number">0110</span>      
                                  <span class="token number">0000</span>  （十进制为<span class="token number">0</span>）
 
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>               
  第三个key：      hashcode值：<span class="token number">11101110</span>    
                          <span class="token operator">&amp;</span>       <span class="token number">0111</span>      
                                  <span class="token number">0110</span>  （十进制为<span class="token number">6</span>）
</code></pre> 
<p>  可以看到，当数组长度不为2的n次幂 的时候，低位不同的hashCode值与数组长度减一做与运算的时候，会出现重复的数据。<br>   <code>因为当数组容量不为2的n次幂 的话，对应的-1所转换的二进制数肯定有一位为0 , 这样不管hashCode值对应的该位，是0还是1 ,最终得到的该位上的数肯定是0，这带来的问题就是HashMap上的数组元素分布不均匀，而数组上的某些位置，永远也用不到</code>。<br>   图示：<br> <img src="https://images2.imgbox.com/f7/2e/bkY9IUdq_o.png" alt=""><br>   这将带来的问题就是HashMap数组的利用率太低，并且链表可能因为上边的(n - 1) &amp; hash运算结果碰撞率过高，导致链表太深。所以说HashMap的长度一定是2的次幂，否则会出现性能问题。</p> 
<h5><a id="312_HashMap075_809"></a>3.1.2 HashMap默认加载因子为什么是0.75*</h5> 
<p>  0.75是对空间和时间效率的一个平衡选择（提高空间利用率和减少查询成本的折中），空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低。<strong>根据泊松分布，loadFactor取0.75碰撞最小</strong>。加载因子一般不会修改，除非在时间和空间比较特殊的情况：<br>   1）如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值，如0.5。<br>   2）如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，如1。</p> 
<h5><a id="313_HashMap8_813"></a>3.1.3 HashMap链表转红黑树的阈值为什么是8</h5> 
<p>  如果hashCode分布良好，也就是 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为8的时候，概率仅为 0.00000006。这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。</p> 
<h5><a id="314_HashMap6_815"></a>3.1.4 HashMap红黑树转链表的阈值为什么是6</h5> 
<p>  在Java的HashMap实现中，当红黑树中的节点数量小于6时，会将红黑树重新转换为单链表。这个策略的主要目的是在内存和性能之间取得一种平衡，以避免浪费过多的内存，因为红黑树相对于单链表会占用更多的内存。<br>   以下是为什么会这样做的原因：</p> 
<blockquote> 
 <ol><li>内存开销：红黑树相对于单链表来说，需要更多的内存来存储额外的节点和树结构。在元素较少的情况下，使用红黑树会浪费内存，因为红黑树的节点结构比链表的节点结构复杂。当节点数量很小时，将红黑树转换为链表可以减少内存开销。</li><li>维护复杂性：红黑树的维护和操作相对于单链表来说更复杂，因此当元素数量较少时，使用链表可以更高效地执行操作，因为链表的简单性能更好。</li><li>避免过度优化：过早地将元素转换为红黑树可能会导致过度优化，因为红黑树的操作相对耗时，当元素数量很小时，这些操作可能会比链表更慢。因此，只有当链表中节点数量超过一定阈值时才转换为红黑树，以避免不必要的开销。</li></ol> 
</blockquote> 
<p>  这个阈值的默认值在不同版本的Java中可能有所不同，但通常在5到8之间。当元素数量超过这个阈值时，红黑树可以提供更好的性能，因为它的时间复杂度为O(log n)，而不是链表的O(n)。但当元素数量减少到阈值以下时，为了减少内存开销和操作的复杂性，将红黑树转换为链表是一个合理的优化选择。这个策略充分权衡了内存和性能之间的权衡。</p> 
<h5><a id="315_HashMap_823"></a>3.1.5 HashMap是怎么解决哈希冲突的</h5> 
<blockquote> 
 <p>  通过引入单向链表来解决Hash冲突。当出现Hash冲突时，比较新老key值是否相等，如果相等，新值覆盖旧值。如果不相等，新值会存入新的Node结点，指向老节点，形成链式结构，即链表。<br>   当Hash冲突发生频繁的时候，会导致链表长度过长，以致检索效率低，所以JDK1.8之后引入了红黑树，当链表长度大于8时，链表会转换成红黑书，以此提高查询性能。</p> 
</blockquote> 
<ul><li><strong>哈希</strong><br>   简单的说，哈希就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。<br>   所有散列函数都有如下一个基本特性：<code>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</code>。</li><li><strong>哈希冲突</strong><br>   当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希冲突）。</li><li><strong>解决Hash冲突的方法</strong><br>   有开放定址法、再哈希法、链地址法。<br>   <code>开放定址法</code>：又称开放定址法，当哈希碰撞发生时，从发生碰撞的那个单元起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。这个空闲单元又称为开放单元或者空白单元。<br>   <code>再哈希法</code>：提供多个不同的hash函数，当 R1=H1(key1) 发生冲突时，再计算 R2=H2(key1) ，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。</li><li><strong>HashMap是使用链表法解决哈希冲突</strong><br>   在哈希表中，每一个桶（bucket）都会对应一条链表，所有哈希值相同的元素放到相同槽位对应的链表中。<br> <img src="https://images2.imgbox.com/df/20/XljxihAm_o.png" alt=""><br>   在插入的时候，我们可以通过散列函数计算出对应的散列槽位，将元素插入到对应的链表即可，时间复杂度为O（1）；在查找或删除元素时，我们同样通过散列函数计算出对应的散列槽位，然后再通过遍历链表进行查找或删除，时间复杂度为O（k），k为链表长度。如果是红黑树，则时间复杂度为O(log k)。</li></ul> 
<h5><a id="316_HashMap_840"></a>3.1.6 负载因子的大小，对HashMap有什么影响</h5> 
<p>  负载因子的大小决定了hashmap的数据密度。<br>   负载因子如果太大的话，容易发生数据的碰撞，所链接的链表就会很长，每次插入或者查询的时候比较的次数就比较多，徒增功耗<br>   负载因子如果太小的话，就容易出发扩容机制，所链接的链表就会缩短，数据碰撞就会减小，但是会浪费很多的空间和内存，经常的扩容就会浪费很多的性能，导致数组中很多的内存没有被填充就被扩容，最后导致浪费。</p> 
<h4><a id="32_HashMapJDK17JDK18_844"></a>3.2 HashMap在JDK1.7和JDK1.8中的区别*</h4> 
<p>  JDK1.8之前，HashMap底层是数组和链表结合在一起使用。HashMap通过key的hashCode，经过扰动函数处理过后得到hash值，然后通过(n - 1) &amp; hash判断当前元素存放的位置（这里的n指的是数组的长度）。如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同。如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。<br>   所谓扰动函数指的就是HashMap的hash方法。使用hash方法也就是扰动函数是为了防止一些实现比较差的hashCode()方法 换句话说使用扰动函数之后可以减少碰撞。</p> 
<p>  总的来说，JDK1.8版本的HashMap主要解决或优化了以下问题：</p> 
<blockquote> 
 <p>1&gt;resize扩容优化（即扩容后哈希的计算方式）。<br> 2&gt;引入了红黑树，目的是避免单条链表过长而影响查询效率。<br> 3&gt;解决了多线程死循环问题。JDK1.8之前存在死循环的根本原因是在扩容后同一索引位置的节点顺序会反掉，JDK1.8将之前的头插法改成了尾插法。</p> 
</blockquote> 
<ul><li><strong>1、数据结构</strong><br>   JDK1.8之前采用的是拉链法（<code>数组 + 链表</code> ）。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。<br>   相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为8）&amp;&amp; 数组元素数量大于等于64时，将链表转化为红黑树，以减少搜索时间（<code>数组 + 链表 + 红黑树</code>）。在删除元素时，如红黑树节点数量数量小于等于6，会转回链表。</li><li><strong>2、hash值计算方式</strong><br>   JDK1.7中的做法是：扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算。具体看下JDK1.7中哈希值的计算方式：</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Hashing</span><span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>  JDK1.8中的做法是：扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算。哈希值的计算方式：</p> 
<pre><code class="prism language-java">	<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	     <span class="token keyword">int</span> h<span class="token punctuation">;</span>
	     <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong>3、扩容后存储位置的计算方式</strong><br>   JDK1.7中的做法是：全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）。<br>   JDK1.8中的做法是：按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）。</li></ul> 
<p>  JDK1.8中，HashMap扩容的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p> 
<ul><li><strong>4、添加数据的规则</strong><br>   JDK1.7中的做法是：<code>无冲突时，存放数组；冲突时，存放链表</code>。<br>   JDK1.8中的做法是： <code>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8 &amp; 数组容量 &gt;=64：树化并存放红黑树</code>。</li><li><strong>5、插入数据方式</strong><br>   JDK1.7中的做法是<code>头插法</code>（先将原位置的数据移到后1位，再插入数据到该位置，这样能提高插put操作的性能，但在多线程情况下有链表逆序和循环链表的问题–会导致死循环）。<br>   JDK1.8中的做法是<code>尾插法</code>（直接插入到链表尾部或红黑树）。</li></ul> 
<h4><a id="33_HashMapkey_888"></a>3.3 HashMap中的key*</h4> 
<p>  适合做HashMap中key的类，应该至少有2个特点：</p> 
<blockquote> 
 <ol><li>重写了equals和hashCode方法。重写equals方法有利于key的比较；重写hashCode方法有利于不同对象获得不同的hash值。</li><li>final类型，即不可变性，保证key的不可更改性，不会存在同一个对象获取到的hash值不同的情况。</li></ol> 
</blockquote> 
<p>  String、Integer等包装类符合这两点，所以适合做HashMap的key。String更常用一些。<br>   HashMap中的key可以为null，不建议用可变对象。如果是可变对象的话，对象的属性改变，则对象的Hashcode也改变，导致下次无法查到已存在Map中的数据。<br>   因此，如果可变对象在HashMap中被用作键，那就要小心在改变对象状态的时候，不要改变它的哈希值，即保证成员变量改变时，该对象的哈希值不变即可。</p> 
<h4><a id="34_HashMaphashCodetable_896"></a>3.4 HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标</h4> 
<p>  hashCode()方法返回的是int整数类型，其范围为-(2 <sup>31</sup>) 到 (2 <sup>31</sup> - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）~2 <sup>30</sup>，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，因此导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置。<br>   简单来说，<code>就是hashCode的值范围比HashMap的实际存储范围大</code>。</p> 
<ul><li><strong>那怎么解决呢（以JDK1.8中的实现为例）</strong><br>   1）HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；<br>   2）在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配"的问题。</li></ul> 
<h4><a id="35_HashMap_902"></a>3.5 HashMap在多线程下的问题</h4> 
<h5><a id="351_JDK17HashMap_903"></a>3.5.1 JDK1.7中HashMap在多线程环境下的问题（死循环）*</h5> 
<p>  代码示例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapInfiniteLoop</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0.75f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">"Thread1"</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">"Thread2"</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  Map初始化了一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个元素的时候，就要进行扩容。<br>   通过设置断点让线程1和线程2同时debug到transfer方法的首行。此时两个线程已成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;”这一行。然后放开线程2的断点，让线程2进行扩容，如图：<br> <img src="https://images2.imgbox.com/28/f6/btImbgNo_o.png" alt=""><br>   Thread1的e指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。<br>   线程一被调度回来执行，先执行newTable[i]=e，然后是e=next，导致了e指向了key(7)，而下一次循环的next=e.next导致了next指向了key(3)。<br> <img src="https://images2.imgbox.com/2c/f4/2ALbJLdm_o.png" alt=""><br>   e.next=newTable[i]导致key(3).next指向了key(7)。此时的key(7).next已经指向了key(3)，环形链表就出现了。</p> 
<p><img src="https://images2.imgbox.com/6f/e8/BzX0S8kk_o.png" alt=""><br>   于是，当用线程一调用map.get(11)时，就出现了死循环。<br>   在并发的情况，发生扩容时，采用头插法，可能会产生循环链表，在执行get的时候，会触发死循环，产生死锁，引起CPU的100%问题，所以一定要避免在并发环境下使用HashMap。</p> 
<h5><a id="352_JDK18HashMap_938"></a>3.5.2 JDK1.8中HashMap在多线程环境下的问题（数据覆盖）*</h5> 
<p>  JDK1.8中HashMap的确不会因为多线程put导致死循环（JDK1.7版本中的问题），但是依然有其他的弊端，比如数据丢失等等。<br>   数据丢失：当多线程put的时候，当index相同而又同时达到链表的末尾时，另一个线程put的数据会把之前线程put的数据覆盖掉，就会产生数据丢失。</p> 
<pre><code class="prism language-java">	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/49684fb705706ec72bed0e68367938aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java集合（三）CopyOnWriteArrayList、Vector、Stack</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6afb120360522455272705b2d99c0ce4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构（顺序表）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>