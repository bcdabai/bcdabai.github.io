<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>秒懂设计模式之建造者模式（Builder pattern） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="秒懂设计模式之建造者模式（Builder pattern）" />
<meta property="og:description" content="[版权申明]非商业目的注明出处可自由转载
博文地址：https://blog.csdn.net/ShuSheng0007/article/details/86619675
出自：shusheng007
设计模式汇总篇，答应我先点赞再收藏：
永不磨灭的设计模式（有这一篇真够了，拒绝标题党）
文章目录 前言定义使用场景解决的问题如何实现如何使用案例扩展传统Builder 模式使用 技术总结总结 前言 人在IT江湖飘，不懂设计模式咋装逼？
但是没写过5万行代码谈设计模式都是在瞎扯淡，咱先看看定义
In software engineering, a software design pattern is a general, reusable solution to a commonly occurring problem within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. It is a description or template for how to solve a problem that can be used in many different situations." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/81af9f111ab86e2889494c338547a9f0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-24T15:22:27+08:00" />
<meta property="article:modified_time" content="2019-01-24T15:22:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">秒懂设计模式之建造者模式（Builder pattern）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>[版权申明]非商业目的注明出处可自由转载<br> 博文地址：https://blog.csdn.net/ShuSheng0007/article/details/86619675<br> 出自：shusheng007</p> 
</blockquote> 
<p>设计模式汇总篇，答应我先点赞再收藏：</p> 
<p><a href="https://blog.csdn.net/ShuSheng0007/article/details/115980889">永不磨灭的设计模式（有这一篇真够了，拒绝标题党）</a></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_9" rel="nofollow">前言</a></li><li><a href="#_19" rel="nofollow">定义</a></li><li><a href="#_24" rel="nofollow">使用场景</a></li><li><a href="#_30" rel="nofollow">解决的问题</a></li><li><a href="#_93" rel="nofollow">如何实现</a></li><li><a href="#_148" rel="nofollow">如何使用</a></li><li><a href="#_157" rel="nofollow">案例</a></li><li><a href="#_160" rel="nofollow">扩展</a></li><li><ul><li><a href="#Builder__163" rel="nofollow">传统Builder 模式</a></li><li><a href="#_282" rel="nofollow">使用</a></li></ul> 
  </li><li><a href="#_305" rel="nofollow">技术总结</a></li><li><a href="#_307" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_9"></a>前言</h2> 
<p>人在IT江湖飘，不懂设计模式咋装逼？</p> 
<p>但是没写过5万行代码谈设计模式都是在瞎扯淡，咱先看看定义</p> 
<blockquote> 
 <p>In software engineering, a software design pattern is a general, reusable solution to a commonly occurring problem within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. It is a description or template for how to solve a problem that can be used in many different situations. Design patterns are formalized best practices that the programmer can use to solve common problems when designing an application or system.<br> 在软件工程领域，设计模式是一套通用的可复用的解决方案，用来解决在软件设计过程中产生的通用问题。它不是一个可以直接转换成源代码的设计，只是一套在软件系统设计过程中程序员应该遵循的最佳实践准则。</p> 
</blockquote> 
<p>咋样，这要是没点工作经验还搞个毛线，因为你完全不明白在说啥！你就记住了，没有设计模式，软件照样开发，就是在大型软件系统开发及维护过程中就痛苦不堪，最后在不断重构后你会发现尼玛竟然用了好多设计模式。</p> 
<p>工作中常常出现建造者模式的身影，所以整理记录一下，希望对自己和其他人都有一个帮助。希望你读完本文后可以在实际开发过程中用上Builder 模式，成功装一把逼，书生我就甚是欣慰了。</p> 
<h2><a id="_19"></a>定义</h2> 
<p>定义虽然基本没有屌用，因为大部分人都看不懂，但是还的说出来。。。</p> 
<blockquote> 
 <p>The intent of the Builder design pattern is to separate the construction of a complex object from its representation. By doing so the same construction process can create different representations.<br> 将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示</p> 
</blockquote> 
<h2><a id="_24"></a>使用场景</h2> 
<p>这个就非常重要了，因为如果你学了个东西，都不知道用来解决什么问题，你说有什么用？理解使用场景的的重要性要远高于你是不是会实现这个模式，因为只要你知道什么问题可以使用builder模式来解决，那你即使不会写，也可以在调查相关资料后完成。<br> 我不想说一些大而正确的术语来把你搞蒙，我们只针对具体的问题，至于延展性的思考，随着你知识的增长，逐渐会明白的。<a href="https://en.wikipedia.org/wiki/Builder_pattern" rel="nofollow">延展阅读</a></p> 
<p><strong>当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。</strong></p> 
<h2><a id="_30"></a>解决的问题</h2> 
<p>当一个类的构造函数参数超过4个，而且这些参数有些是可选的时，我们通常有两种办法来构建它的对象。<br> 例如我们现在有如下一个类计算机类<code>Computer</code>，其中cpu与ram是必填参数，而其他3个是可选参数，那么我们如何构造这个类的实例呢,通常有两种常用的方式：</p> 
<pre><code>public class Computer {
    private String cpu;//必须
    private String ram;//必须
    private int usbCount;//可选
    private String keyboard;//可选
    private String display;//可选
}
</code></pre> 
<p>第一：折叠构造函数模式（telescoping constructor pattern ），这个我们经常用,如下代码所示</p> 
<pre><code>public class Computer {
     ...
    public Computer(String cpu, String ram) {
        this(cpu, ram, 0);
    }
    public Computer(String cpu, String ram, int usbCount) {
        this(cpu, ram, usbCount, "罗技键盘");
    }
    public Computer(String cpu, String ram, int usbCount, String keyboard) {
        this(cpu, ram, usbCount, keyboard, "三星显示器");
    }
    public Computer(String cpu, String ram, int usbCount, String keyboard, String display) {
        this.cpu = cpu;
        this.ram = ram;
        this.usbCount = usbCount;
        this.keyboard = keyboard;
        this.display = display;
    }
}
</code></pre> 
<p>第二种：Javabean 模式，如下所示</p> 
<pre><code>public class Computer {
        ...

    public String getCpu() {
        return cpu;
    }
    public void setCpu(String cpu) {
        this.cpu = cpu;
    }
    public String getRam() {
        return ram;
    }
    public void setRam(String ram) {
        this.ram = ram;
    }
    public int getUsbCount() {
        return usbCount;
    }
...
}
</code></pre> 
<p>那么这两种方式有什么弊端呢？<br> 第一种主要是使用及阅读不方便。你可以想象一下，当你要调用一个类的构造函数时，你首先要决定使用哪一个，然后里面又是一堆参数，如果这些参数的类型很多又都一样，你还要搞清楚这些参数的含义，很容易就传混了。。。那酸爽谁用谁知道。<br> 第二种方式在构建过程中对象的状态容易发生变化，造成错误。因为那个类中的属性是分步设置的，所以就容易出错。</p> 
<p>为了解决这两个痛点，builder模式就横空出世了。</p> 
<h2><a id="_93"></a>如何实现</h2> 
<ol><li>在Computer 中创建一个静态内部类 Builder，然后将Computer 中的参数都复制到Builder类中。</li><li>在Computer中创建一个private的构造函数，参数为Builder类型</li><li>在Builder中创建一个<code>public</code>的构造函数，参数为Computer中必填的那些参数，cpu 和ram。</li><li>在Builder中创建设置函数，对Computer中那些可选参数进行赋值，返回值为Builder类型的实例</li><li>在Builder中创建一个<code>build()</code>方法，在其中构建Computer的实例并返回</li></ol> 
<p>下面代码就是最终的样子</p> 
<pre><code>public class Computer {
    private final String cpu;//必须
    private final String ram;//必须
    private final int usbCount;//可选
    private final String keyboard;//可选
    private final String display;//可选

    private Computer(Builder builder){
        this.cpu=builder.cpu;
        this.ram=builder.ram;
        this.usbCount=builder.usbCount;
        this.keyboard=builder.keyboard;
        this.display=builder.display;
    }
    //省略getter
    ...
    public static class Builder{
        private String cpu;//必须
        private String ram;//必须
        private int usbCount;//可选
        private String keyboard;//可选
        private String display;//可选
       
        public Builder(String cup,String ram){
            this.cpu=cup;
            this.ram=ram;
        }

        public Builder setUsbCount(int usbCount) {
            this.usbCount = usbCount;
            return this;
        }
        public Builder setKeyboard(String keyboard) {
            this.keyboard = keyboard;
            return this;
        }
        public Builder setDisplay(String display) {
            this.display = display;
            return this;
        }        
        public Computer build(){
            return new Computer(this);
        }
    }
}
</code></pre> 
<h2><a id="_148"></a>如何使用</h2> 
<p>在客户端使用链式调用，一步一步的把对象构建出来。</p> 
<pre><code>Computer computer=new Computer.Builder("因特尔","三星")
        .setDisplay("三星24寸")
        .setKeyboard("罗技")
        .setUsbCount(2)
        .build();
</code></pre> 
<h2><a id="_157"></a>案例</h2> 
<p>构建者模式是一个非常实用而常见的创建类型的模式（creational design pattern)，例如图片处理框架Glide，网络请求框架Retrofit等都使用了此模式。</p> 
<h2><a id="_160"></a>扩展</h2> 
<p>其实上面的内容是Builder在Java中一种简化的使用方式，经典的Builder 模式与其有一定的不同，如果没有兴趣的同学就可以不用往下读了。</p> 
<h3><a id="Builder__163"></a>传统Builder 模式</h3> 
<p>构建者模式UML图如下所示<br> <img src="https://images2.imgbox.com/e5/bc/wZ3f4Ss8_o.png" alt="在这里插入图片描述"><br> 如上图所示，builder模式有4个角色。</p> 
<ul><li>Product: 最终要生成的对象，例如 Computer实例。</li><li>Builder： 构建者的抽象基类（有时会使用接口代替）。其定义了构建Product的抽象步骤，其实体类需要实现这些步骤。其会包含一个用来返回最终产品的方法<code>Product getProduct()</code>。</li><li>ConcreteBuilder: Builder的实现类。</li><li>Director: 决定如何构建最终产品的算法. 其会包含一个负责组装的方法<code>void Construct(Builder builder)</code>， 在这个方法中通过调用builder的方法，就可以设置builder，等设置完成后，就可以通过builder的 <code>getProduct()</code> 方法获得最终的产品。</li></ul> 
<p>我们接下来将最开始的例子使用传统方式来实现一遍。</p> 
<p>第一步：我们的目标Computer类：</p> 
<pre><code>public class Computer {
    private String cpu;//必须
    private String ram;//必须
    private int usbCount;//可选
    private String keyboard;//可选
    private String display;//可选

    public Computer(String cpu, String ram) {
        this.cpu = cpu;
        this.ram = ram;
    }
    public void setUsbCount(int usbCount) {
        this.usbCount = usbCount;
    }
    public void setKeyboard(String keyboard) {
        this.keyboard = keyboard;
    }
    public void setDisplay(String display) {
        this.display = display;
    }
    @Override
    public String toString() {
        return "Computer{" +
                "cpu='" + cpu + '\'' +
                ", ram='" + ram + '\'' +
                ", usbCount=" + usbCount +
                ", keyboard='" + keyboard + '\'' +
                ", display='" + display + '\'' +
                '}';
    }
}
</code></pre> 
<p>第二步：抽象构建者类</p> 
<pre><code>public abstract class ComputerBuilder {
    public abstract void setUsbCount();
    public abstract void setKeyboard();
    public abstract void setDisplay();

    public abstract Computer getComputer();
}
</code></pre> 
<p>第三步：实体构建者类，我们可以根据要构建的产品种类产生多了实体构建者类，这里我们需要构建两种品牌的电脑，苹果电脑和联想电脑，所以我们生成了两个实体构建者类。</p> 
<p>苹果电脑构建者类</p> 
<pre><code>public class MacComputerBuilder extends ComputerBuilder {
    private Computer computer;
    public MacComputerBuilder(String cpu, String ram) {
        computer = new Computer(cpu, ram);
    }
    @Override
    public void setUsbCount() {
        computer.setUsbCount(2);
    }
    @Override
    public void setKeyboard() {
        computer.setKeyboard("苹果键盘");
    }
    @Override
    public void setDisplay() {
        computer.setDisplay("苹果显示器");
    }
    @Override
    public Computer getComputer() {
        return computer;
    }
}
</code></pre> 
<p>联想电脑构建者类</p> 
<pre><code>public class LenovoComputerBuilder extends ComputerBuilder {
    private Computer computer;
    public LenovoComputerBuilder(String cpu, String ram) {
        computer=new Computer(cpu,ram);
    }
    @Override
    public void setUsbCount() {
        computer.setUsbCount(4);
    }
    @Override
    public void setKeyboard() {
        computer.setKeyboard("联想键盘");
    }
    @Override
    public void setDisplay() {
        computer.setDisplay("联想显示器");
    }
    @Override
    public Computer getComputer() {
        return computer;
    }
}
</code></pre> 
<p>第四步：指导者类（Director）</p> 
<pre><code>public class ComputerDirector {
    public void makeComputer(ComputerBuilder builder){
        builder.setUsbCount();
        builder.setDisplay();
        builder.setKeyboard();
    }
}
</code></pre> 
<h3><a id="_282"></a>使用</h3> 
<p>首先生成一个director (1)，然后生成一个目标builder (2)，接着使用director组装builder (3),组装完毕后使用builder创建产品实例 (4)。</p> 
<pre><code>public static void main(String[] args) {
        ComputerDirector director=new ComputerDirector();//1
        ComputerBuilder builder=new MacComputerBuilder("I5处理器","三星125");//2
        director.makeComputer(builder);//3
        Computer macComputer=builder.getComputer();//4
        System.out.println("mac computer:"+macComputer.toString());

        ComputerBuilder lenovoBuilder=new LenovoComputerBuilder("I7处理器","海力士222");
        director.makeComputer(lenovoBuilder);
        Computer lenovoComputer=lenovoBuilder.getComputer();
        System.out.println("lenovo computer:"+lenovoComputer.toString());
}
</code></pre> 
<p>输出结果如下：</p> 
<pre><code>mac computer:Computer{cpu='I5处理器', ram='三星125', usbCount=2, keyboard='苹果键盘', display='苹果显示器'}
lenovo computer:Computer{cpu='I7处理器', ram='海力士222', usbCount=4, keyboard='联想键盘', display='联想显示器'}
</code></pre> 
<p>可以看到，文章最开始的使用方式是传统builder模式的变种， 首先其省略了director 这个角色，将构建算法交给了client端，其次将builder 写到了要构建的产品类里面，最后采用了链式调用。</p> 
<h2><a id="_305"></a>技术总结</h2> 
<p>日常工作中最为常见的就是使用文章开头的变种，而不是传统模式。本文传统模式实例构建的对象是可变的，我们也可以将其写成不可变对象，以场景而定吧</p> 
<h2><a id="_307"></a>总结</h2> 
<p>设计模式值得你刻意练习！</p> 
<p>最后，求关注，求点赞！有任何疑问可以评论留言，我会尽力回复的</p> 
<p><strong>Github源码地址：</strong><a href="https://github.com/shusheng007/design-patterns">design-patterns</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a12422b7e02cf6b4bf93aecb1de805a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">scrapy爬虫实战</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/05c6d48fbfa8c0e6cbf81bd291649750/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Maven新建工程pom.xml报错Failure to transfer org.codehaus.xxx from xxxx解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>