<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面向对象的四大基本特征和五大基本原则 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面向对象的四大基本特征和五大基本原则" />
<meta property="og:description" content="面向对象主要有四大特性
· 抽象
o 忽略一个主题中与当前目标无关的东西,专注的注意与当前目标有关的方面.(就是把现实世界中的某一类东西,提取出来,用程序代码表示,抽象出来的一般叫做类或者接口).抽象并不打算了解全部问题,而是选择其中的一部分,暂时不用部分细节.抽象包括两个方面,一个数据抽象,而是过程抽象.
o 数据抽象 --&gt;表示世界中一类事物的特征,就是对象的属性.比如鸟有翅膀,羽毛等(类的属性)
o 过程抽象 --&gt;表示世界中一类事物的行为,就是对象的行为.比如鸟会飞,会叫(类的方法)
· 封装
o 封装就是把过程和数据包围起来,对数据的访问只能通过特定的界面.如私有变量,用set,get方法获取
· 继承
o 一种联结类的层次模型,并且允许和鼓励类的重用,提供一种明确表达共性的方法.对象的一个新类可以从现有的类中派生,这个过程称为类继承.新类继承了原始类的特性,新类称为原始类的派生类(子类),原始类称为新类的基类(父类).派生类可以从它的父类哪里继承方法和实例变量,并且类可以修改或增加新的方法使之更适合特殊的需要.因此可以说,继承为了重用父类代码,同时为实现多态性作准备.
· 多态
o 多态是指允许不同类的对象对同一消息做出响应.多态性包括参数化多态性和包含多态性.多态性语言具有灵活/抽象/行为共享/代码共享的优势,很好的解决了应用程序函数同名问题.总的来说,方法的重写,重载与动态链接构成多态性.java引入多态的概念原因之一就是弥补类的单继承带来的功能不足.
o 动态链接 --&gt;对于父类中定义的方法,如果子类中重写了该方法,那么父类类型的引用将调用子类中的这个方法,这就是动态链接.
注意继承与重载:子类与父类的关系,重载方法的调用问题
子类对象可以直接当成父类对象用,但是反过来就不行.比如:人是父类,学生是人的子类,所以学生对象一定具备人对象的属性,但是人对象就未必具有学生对象的特性.但是子类对象当做父类来用,将失去子类所有特性,只保留与父类同名的属性和方法,此时可以对父类方法进行重写.
一个类中如果定义了重载的方法,则系统在调用方法时,会根据参数的类型自动选择调用合适的方法
五大基本原则 · 单一职责原则SRP(Single Responsibility Principle)
o 是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。
· 开放封闭原则OCP(Open－Close Principle) o 一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，
o 那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。
· 替换原则(the Liskov Substitution Principle LSP) o 子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，
o 也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。
· 依赖原则(the Dependency Inversion Principle DIP)
o 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，
o 这个时候，B不应当直接使用A中的具体类：而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到
o 了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。
· 接口分离原则(the Interface Segregation Principle ISP) o 模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ff8c09f54697432118ada8d01d44b39b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-28T10:32:05+08:00" />
<meta property="article:modified_time" content="2018-05-28T10:32:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面向对象的四大基本特征和五大基本原则</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="postBody" style="margin:5px 0px 0px;padding:5px 2px 5px 5px;line-height:1.5;font-family:Verdana, Arial, Helvetica, sans-serif;text-align:left;"> 
 <div class="blogpost-body" style="margin:0px 0px 20px;padding:0px;"> 
  <p style="margin:10px auto;line-height:1.5;"></p> 
  <p align="left" style="color:rgb(0,0,0);"><strong><span style="color:#000000;"><a href="https://www.cnblogs.com/gudulijia/p/5841607.html" rel="nofollow"><span style="color:#AA7A53;background:#FFFFFF;">面向对象主要有四大特性</span></a></span></strong></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">·        </span><span style="color:#000000;background:#FFFFFF;">抽象</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">忽略一个主题中与当前目标无关的东西</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">专注的注意与当前目标有关的方面</span><span style="color:#000000;background:#FFFFFF;">.(</span><span style="color:#000000;background:#FFFFFF;">就是把现实世界中的某一类东西</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">提取出来</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">用程序代码表示</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">抽象出来的一般叫做类或者接口</span><span style="color:#000000;background:#FFFFFF;">).</span><span style="color:#000000;background:#FFFFFF;">抽象并不打算了解全部问题</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">而是选择其中的一部分</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">暂时不用部分细节</span><span style="color:#000000;background:#FFFFFF;">.</span><span style="color:#000000;background:#FFFFFF;">抽象包括两个方面</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">一个数据抽象</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">而是过程抽象</span><span style="color:#000000;background:#FFFFFF;">.</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">数据抽象</span><span style="color:#000000;background:#FFFFFF;"> --&gt;</span><span style="color:#000000;background:#FFFFFF;">表示世界中一类事物的特征</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">就是对象的属性</span><span style="color:#000000;background:#FFFFFF;">.</span><span style="color:#000000;background:#FFFFFF;">比如鸟有翅膀</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">羽毛等</span><span style="color:#000000;background:#FFFFFF;">(</span><span style="color:#FF0000;background:#FFFFFF;">类的属性</span><span style="color:#000000;background:#FFFFFF;">)</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">过程抽象</span><span style="color:#000000;background:#FFFFFF;"> --&gt;</span><span style="color:#000000;background:#FFFFFF;">表示世界中一类事物的行为</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">就是对象的行为</span><span style="color:#000000;background:#FFFFFF;">.</span><span style="color:#000000;background:#FFFFFF;">比如鸟会飞</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">会叫</span><span style="color:#000000;background:#FFFFFF;">(</span><span style="color:#FF0000;background:#FFFFFF;">类的方法</span><span style="color:#000000;background:#FFFFFF;">)</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">·        </span><span style="color:#000000;background:#FFFFFF;">封装</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">封装就是把过程和数据包围起来</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">对数据的访问只能通过特定的界面</span><span style="color:#000000;background:#FFFFFF;">.</span><span style="color:#000000;background:#FFFFFF;">如私有变量</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">用</span><span style="color:#000000;background:#FFFFFF;">set,get</span><span style="color:#000000;background:#FFFFFF;">方法获取</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">·        </span><span style="color:#000000;background:#FFFFFF;">继承</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">一种联结类的层次模型</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">并且允许和鼓励类的重用</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">提供一种明确表达共性的方法</span><span style="color:#000000;background:#FFFFFF;">.</span><span style="color:#000000;background:#FFFFFF;">对象的一个新类可以从现有的类中派生</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">这个过程称为类继承</span><span style="color:#000000;background:#FFFFFF;">.</span><span style="color:#000000;background:#FFFFFF;">新类继承了原始类的特性</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">新类称为原始类的派生类</span><span style="color:#000000;background:#FFFFFF;">(</span><span style="color:#000000;background:#FFFFFF;">子类</span><span style="color:#000000;background:#FFFFFF;">),</span><span style="color:#000000;background:#FFFFFF;">原始类称为新类的基类</span><span style="color:#000000;background:#FFFFFF;">(</span><span style="color:#000000;background:#FFFFFF;">父类</span><span style="color:#000000;background:#FFFFFF;">).</span><span style="color:#000000;background:#FFFFFF;">派生类可以从它的父类哪里继承方法和实例变量</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">并且类可以修改或增加新的方法使之更适合特殊的需要</span><span style="color:#000000;background:#FFFFFF;">.</span><span style="color:#000000;background:#FFFFFF;">因此可以说</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">继承为了重用父类代码</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">同时为实现多态性作准备</span><span style="color:#000000;background:#FFFFFF;">.</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">·        </span><span style="color:#000000;background:#FFFFFF;">多态</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">多态是指允许不同类的对象对同一消息做出响应</span><span style="color:#000000;background:#FFFFFF;">.</span><span style="color:#000000;background:#FFFFFF;">多态性包括参数化多态性和包含多态性</span><span style="color:#000000;background:#FFFFFF;">.</span><span style="color:#000000;background:#FFFFFF;">多态性语言具有灵活</span><span style="color:#000000;background:#FFFFFF;">/</span><span style="color:#000000;background:#FFFFFF;">抽象</span><span style="color:#000000;background:#FFFFFF;">/</span><span style="color:#000000;background:#FFFFFF;">行为共享</span><span style="color:#000000;background:#FFFFFF;">/</span><span style="color:#000000;background:#FFFFFF;">代码共享的优势</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">很好的解决了应用程序函数同名问题</span><span style="color:#000000;background:#FFFFFF;">.</span><span style="color:#000000;background:#FFFFFF;">总的来说</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">方法的重写</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">重载与动态链接构成多态性</span><span style="color:#000000;background:#FFFFFF;">.java</span><span style="color:#000000;background:#FFFFFF;">引入多态的概念原因之一就是弥补类的单继承带来的功能不足</span><span style="color:#000000;background:#FFFFFF;">.</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">动态链接</span><span style="color:#000000;background:#FFFFFF;"> --&gt;</span><span style="color:#000000;background:#FFFFFF;">对于父类中定义的方法</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">如果子类中重写了该方法</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">那么父类类型的引用将调用子类中的这个方法</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">这就是动态链接</span><span style="color:#000000;background:#FFFFFF;">.<br><br><br></span></p> 
  <p style="color:rgb(0,0,0);"><span style="color:#000000;background:#FFFFFF;">注意继承与重载</span><span style="color:#000000;background:#FFFFFF;">:</span><span style="color:#000000;background:#FFFFFF;">子类与父类的关系</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">重载方法的调用问题</span></p> 
  <p style="color:rgb(0,0,0);"><span style="color:#000000;background:#FFFFFF;">　　子类对象可以直接当成父类对象用</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">但是反过来就不行</span><span style="color:#000000;background:#FFFFFF;">.</span><span style="color:#000000;background:#FFFFFF;">比如</span><span style="color:#000000;background:#FFFFFF;">:</span><span style="color:#000000;background:#FFFFFF;">人是父类</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">学生是人的子类</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">所以学生对象一定具备人对象的属性</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">但是人对象就未必具有学生对象的特性</span><span style="color:#000000;background:#FFFFFF;">.</span><span style="color:#000000;background:#FFFFFF;">但是子类对象当做父类来用</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">将失去子类所有特性</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">只保留与父类同名的属性和方法</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">此时可以对父类方法进行重写</span><span style="color:#000000;background:#FFFFFF;">.</span></p> 
  <p style="color:rgb(0,0,0);"><span style="color:#000000;background:#FFFFFF;">　　一个类中如果定义了重载的方法</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">则系统在调用方法时</span><span style="color:#000000;background:#FFFFFF;">,</span><span style="color:#000000;background:#FFFFFF;">会根据参数的类型自动选择调用合适的方法</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><strong><u><span style="color:#AA7A53;background:#FFFFFF;">五大基本原则</span><span style="color:#AA7A53;background:#FFFFFF;"> </span></u></strong></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">·        </span><span style="color:#000000;background:#FFFFFF;">单一职责原则</span><span style="color:#000000;background:#FFFFFF;">SRP(Single Responsibility Principle)</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">·        </span><span style="color:#000000;background:#FFFFFF;">开放封闭原则</span><span style="color:#000000;background:#FFFFFF;">OCP(Open</span><span style="color:#000000;background:#FFFFFF;">－</span><span style="color:#000000;background:#FFFFFF;">Close Principle) </span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">·        </span><span style="color:#000000;background:#FFFFFF;">替换原则</span><span style="color:#000000;background:#FFFFFF;">(the Liskov Substitution Principle LSP) </span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">·        </span><span style="color:#000000;background:#FFFFFF;">依赖原则</span><span style="color:#000000;background:#FFFFFF;">(the Dependency Inversion Principle DIP)</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">具体依赖抽象，上层依赖下层。假设</span><span style="color:#000000;background:#FFFFFF;">B</span><span style="color:#000000;background:#FFFFFF;">是较</span><span style="color:#000000;background:#FFFFFF;">A</span><span style="color:#000000;background:#FFFFFF;">低的模块，但</span><span style="color:#000000;background:#FFFFFF;">B</span><span style="color:#000000;background:#FFFFFF;">需要使用到</span><span style="color:#000000;background:#FFFFFF;">A</span><span style="color:#000000;background:#FFFFFF;">的功能，</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">这个时候，</span><span style="color:#000000;background:#FFFFFF;">B</span><span style="color:#000000;background:#FFFFFF;">不应当直接使用</span><span style="color:#000000;background:#FFFFFF;">A</span><span style="color:#000000;background:#FFFFFF;">中的具体类：</span><span style="color:#000000;background:#FFFFFF;">而应当由</span><span style="color:#000000;background:#FFFFFF;">B</span><span style="color:#000000;background:#FFFFFF;">定义一抽象接口，并由</span><span style="color:#000000;background:#FFFFFF;">A</span><span style="color:#000000;background:#FFFFFF;">来实现这个抽象接口，</span><span style="color:#000000;background:#FFFFFF;">B</span><span style="color:#000000;background:#FFFFFF;">只使用这个抽象接口：这样就达到</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">了依赖倒置的目的，</span><span style="color:#000000;background:#FFFFFF;">B</span><span style="color:#000000;background:#FFFFFF;">也解除了对</span><span style="color:#000000;background:#FFFFFF;">A</span><span style="color:#000000;background:#FFFFFF;">的依赖，反过来是</span><span style="color:#000000;background:#FFFFFF;">A</span><span style="color:#000000;background:#FFFFFF;">依赖于</span><span style="color:#000000;background:#FFFFFF;">B</span><span style="color:#000000;background:#FFFFFF;">定义的抽象接口。通过上层模块难以避免依赖下层模块，假如</span><span style="color:#000000;background:#FFFFFF;">B</span><span style="color:#000000;background:#FFFFFF;">也直接依赖</span><span style="color:#000000;background:#FFFFFF;">A</span><span style="color:#000000;background:#FFFFFF;">的实现，那么就可能造成循环依赖。一个常见的问题就是编译</span><span style="color:#000000;background:#FFFFFF;">A</span><span style="color:#000000;background:#FFFFFF;">模块时需要直接包含到</span><span style="color:#000000;background:#FFFFFF;">B</span><span style="color:#000000;background:#FFFFFF;">模块的</span><span style="color:#000000;background:#FFFFFF;">cpp</span><span style="color:#000000;background:#FFFFFF;">文件，而编译</span><span style="color:#000000;background:#FFFFFF;">B</span><span style="color:#000000;background:#FFFFFF;">时同样要直接包含到</span><span style="color:#000000;background:#FFFFFF;">A</span><span style="color:#000000;background:#FFFFFF;">的</span><span style="color:#000000;background:#FFFFFF;">cpp</span><span style="color:#000000;background:#FFFFFF;">文件。</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">·        </span><span style="color:#000000;background:#FFFFFF;">接口分离原则</span><span style="color:#000000;background:#FFFFFF;">(the Interface Segregation Principle ISP) </span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;">o    </span><span style="color:#000000;background:#FFFFFF;">模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来</span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;background:#FFFFFF;">                                              <img src="https://images2.imgbox.com/b5/0a/qbTqyWNH_o.png" alt=""></span></p> 
  <p align="left" style="color:rgb(0,0,0);"><span style="color:#000000;background:#FFFFFF;">作者:唐平                                                                                                                     部分信息来源于网络</span></p> 
  <p align="left"><span style="color:#000000;"><span style="background-color:rgb(255,255,255);">时间:2018-5-28</span></span></p> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1dd4131520745be95676a5bcca583f11/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">easyui学习之datagrid</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3cb232d86883c729c0a05004484fddef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android SDK Failed to fetch出错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>