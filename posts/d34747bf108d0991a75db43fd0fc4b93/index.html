<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java学习记录——错题总结（十） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java学习记录——错题总结（十）" />
<meta property="og:description" content="第一套 1.Java网络程序设计中,下列正确的描述是（）
正确答案: A D
Java网络编程API建立在Socket基础之上
Java网络接口只支持tcP以及其上层协议
Java网络接口只支持UDP以及其上层协议
Java网络接口支持IP以上的所有高层协议
2.以下哪些类是线程安全的（）
正确答案: A D E
Vector
HashMap
ArrayList
StringBuffer
Properties
A，Vector相当于一个线程安全的List
B，HashMap是非线程安全的，其对应的线程安全类是HashTable
C，Arraylist是非线程安全的，其对应的线程安全类是Vector
D，StringBuffer是线程安全的，相当于一个线程安全的StringBuilder
E，Properties实现了Map接口，是线程安全的
第二套 下面有关jdbc statement的说法错误的是？
正确答案: C
JDBC提供了Statement、PreparedStatement 和 CallableStatement三种方式来执行查询语句，其中 Statement 用于通用查询， PreparedStatement 用于执行参数化查询，而 CallableStatement则是用于存储过程
对于PreparedStatement来说，数据库可以使用已经编译过及定义好的执行计划，由于 PreparedStatement 对象已预编译过，所以其执行速度要快于 Statement 对象”
PreparedStatement中，“?” 叫做占位符，一个占位符可以有一个或者多个值
PreparedStatement可以阻止常见的SQL注入式攻击
征程头像征程
1.Statement、PreparedStatement和CallableStatement都是接口(interface)。
2.Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement。
3.
Statement接口提供了执行语句和获取结果的基本方法；
PreparedStatement接口添加了处理 IN 参数的方法；
CallableStatement接口添加了处理 OUT 参数的方法。
4.
a.Statement:
普通的不带参的查询SQL；支持批量更新,批量删除;
b.PreparedStatement:
可变参数的SQL,编译一次,执行多次,效率高;
安全性好，有效防止Sql注入等问题;
支持批量更新,批量删除;
c.CallableStatement:
继承自PreparedStatement,支持带参数的SQL操作;
支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;
Statement每次执行sql语句，数据库都要执行sql语句的编译 ，
最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d34747bf108d0991a75db43fd0fc4b93/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-23T16:11:32+08:00" />
<meta property="article:modified_time" content="2022-03-23T16:11:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java学习记录——错题总结（十）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>第一套</h3> 
<p>1.Java网络程序设计中,下列正确的描述是（）<br> 正确答案: A D<br> Java网络编程API建立在Socket基础之上<br> Java网络接口只支持tcP以及其上层协议<br> Java网络接口只支持UDP以及其上层协议<br> Java网络接口支持IP以上的所有高层协议</p> 
<p>2.以下哪些类是线程安全的（）<br> 正确答案: A D E<br> Vector<br> HashMap<br> ArrayList<br> StringBuffer<br> Properties</p> 
<p>A，Vector相当于一个线程安全的List<br> B，HashMap是非线程安全的，其对应的线程安全类是HashTable<br> C，Arraylist是非线程安全的，其对应的线程安全类是Vector<br> D，StringBuffer是线程安全的，相当于一个线程安全的StringBuilder<br> E，Properties实现了Map接口，是线程安全的</p> 
<h3><a id="_22"></a>第二套</h3> 
<p>下面有关jdbc statement的说法错误的是？<br> 正确答案: C<br> JDBC提供了Statement、PreparedStatement 和 CallableStatement三种方式来执行查询语句，其中 Statement 用于通用查询， PreparedStatement 用于执行参数化查询，而 CallableStatement则是用于存储过程<br> 对于PreparedStatement来说，数据库可以使用已经编译过及定义好的执行计划，由于 PreparedStatement 对象已预编译过，所以其执行速度要快于 Statement 对象”<br> PreparedStatement中，“?” 叫做占位符，一个占位符可以有一个或者多个值<br> PreparedStatement可以阻止常见的SQL注入式攻击</p> 
<p>征程头像征程<br> 1.Statement、PreparedStatement和CallableStatement都是接口(interface)。<br> 2.Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement。<br> 3.<br> Statement接口提供了执行语句和获取结果的基本方法；<br> PreparedStatement接口添加了处理 IN 参数的方法；<br> CallableStatement接口添加了处理 OUT 参数的方法。<br> 4.<br> a.Statement:<br> 普通的不带参的查询SQL；支持批量更新,批量删除;<br> b.PreparedStatement:<br> 可变参数的SQL,编译一次,执行多次,效率高;<br> 安全性好，有效防止Sql注入等问题;<br> 支持批量更新,批量删除;<br> c.CallableStatement:<br> 继承自PreparedStatement,支持带参数的SQL操作;<br> 支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;</p> 
<p>Statement每次执行sql语句，数据库都要执行sql语句的编译 ，<br> 最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement。</p> 
<p>PreparedStatement是预编译的，使用PreparedStatement有几个好处</p> 
<ol><li>在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。</li><li>安全性好，有效防止Sql注入等问题。</li><li>对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch；</li><li>代码的可读性和可维护性。<br> <strong>一个占位符必定只能对应一个值</strong></li></ol> 
<p>2.下面有关java hashmap的说法错误的是？<br> 正确答案: C<br> HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。<br> HashMap 的实现不是同步的，意味着它不是线程安全的<br> HashMap通过开放地址法解决哈希冲突（实际上是拉链法）<br> HashMap中的key-value都是存储在Entry数组中的</p> 
<ol><li> <p>开放定址法：线性探测再散列、二次探测再散列、再随机探测再散列；</p> </li><li> <p>再哈希法：换一种哈希函数；</p> </li><li> <p>链地址法 ：在数组中冲突元素后面拉一条链路，存储重复的元素；</p> </li><li> <p>建立一个公共溢出区：其实就是建立一个表，存放那些冲突的元素。</p> </li></ol> 
<p>什么时候会产生冲突</p> 
<p>HashMap中调用 hashCode() 方法来计算hashCode。</p> 
<p>由于在Java中两个不同的对象可能有一样的hashCode,所以不同的键可能有一样hashCode，从而导致冲突的产升。<br> HashMap底层是 数组和链表 的结合体。底层是一个线性数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。数组是 Entry[] 数组，静态内部类。 E ntry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用 next ，这就构成了链表。所以 很明显是链地址法。<br> 具体过程：<br> 当我们往HashMap中put元素的时候：当程序试图将一个key-value对放入HashMap中时，<br> 1 . 程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置；<br> 2 . 若 Entry 的存储位置上为 null ，直接存储该对象；若不为空，两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同，<br> 3 . 循环遍历链表，如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖；如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部</p> 
<p>3.有关会话跟踪技术描述正确的是（）<br> 正确答案: A B C<br> Cookie是Web服务器发送给客户端的一小段信息，客户端请求时，可以读取该信息发送到服务器端<br> 关闭浏览器意味着临时会话ID丢失，但所有与原会话关联的会话数据仍保留在服务器上，直至会话过期<br> 在禁用Cookie时可以使用URL重写技术跟踪会话<br> 隐藏表单域将字段添加到HTML表单并在客户端浏览器中显示</p> 
<p>D:隐藏域在页面中对于用户（浏览器）是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器。</p> 
<blockquote> 
 <p>1.隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器。<br> 2 .有些时候我们要给用户一信息，让他在提交表单时提交上来以确定用户身份，如sessionkey，等等．当然这些东西也能用cookie实现，但使用隐藏域就简单的多了．而且不会有浏览器不支持，用户禁用cookie的烦恼。</p> 
 <p>3 .有些时候一个form里有多个提交按钮，怎样使程序能够分清楚到底用户是按那一个按钮提交上来的呢？我们就可以写一个隐藏域，然后在每一个按钮处加上<br> οnclick="document.form.command.value=“xx”"然后我们接到数据后先检查command的值就会知道用户是按的<br> 那个按钮提交上来的。</p> 
 <p>4 .有时候一个网页中有多个form，我们知道多个form是不能同时提交的，但有时这些form确实相互作用，我们就可以在form中添加隐藏域来使它们联系起来。</p> 
 <ol start="5"><li> <p>javascript不支持全局变量，但有时我们必须用全局变量，我们就可以把值先存在隐藏域里，它的值就不会丢失了。</p> </li><li> <p>还有个例子，比如按一个按钮弹出四个小窗口，当点击其中的一个小窗口时其他三个自动关闭．可是IE不支持小窗口相互调用，所以只有在父窗口写个隐藏域，当小窗口看到那个隐藏域的值是close时就自己关掉。</p> </li></ol> 
</blockquote> 
<h3><a id="_108"></a>第三套</h3> 
<p>1.关于下面程序，哪些描述是正确的: ( )</p> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">While</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> x<span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span> x <span class="token punctuation">)</span>  <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"x minus one is "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            x <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: B<br> 行1有语法错误<br> 行4有语法错误<br> 行5有语法错误<br> 行6有语法错误<br> 行2有语法错误,loop是关键字<br> 程序能够正常编译和运行</p> 
<p>这个题主要考while（）中表达式的判断，在C语言中大于0的int值都会被认为是true，而java中没有这个机制，必须是boolean类型的。</p> 
<p>2.对于如下代码段</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">A</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">A</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">B</span> <span class="token punctuation">{<!-- --></span>
    _______
 
<span class="token punctuation">}</span>
</code></pre> 
<p>可以放入到横线位置，使程序正确编译运行，而且不产生错误的选项是（ ）</p> 
<p>正确答案: C<br> public void foo(){}<br> public int foo(){return 1;}<br> public A foo(B b){return b;}<br> public A foo(){return A;}</p> 
<p>重写 要求两同两小一大原则， 方法名相同，参数类型相同，子类返回类型小于等于父类方法返回类型， 子类抛出异常小于等于父类方法抛出异常， 子类访问权限大于等于父类方法访问权限。［注意：这里的返回类型必须要在有继承关系的前提下比较］</p> 
<p>重载 方法名必须相同，参数类型必须不同，包括但不限于一项，参数数目，参数类型，参数顺序<br> 再来说说这道题 A B 都是方法名和参数相同，是重写，但是返回类型没与父类返回类型有继承关系，错误 D 返回一个类错误 c的参数类型与父类不同，所以不是重写，可以理解为广义上的重载访问权限小于父类，都会显示错误<br> 虽然题目没点明一定要重载或者重写，但是当你的方法名与参数类型与父类相同时，已经是重写了，这时候如果返回类型或者异常类型比父类大，或者访问权限比父类小都会编译错误</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53f6a6a6531506fec352461e9f4eccac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux服务器mysql的root密码忘记怎么办？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30d5328caba8910597e78d40ee2c7492/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入理解padding_idx(nn.Embedding、nn.Embedding.from_pretrained）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>