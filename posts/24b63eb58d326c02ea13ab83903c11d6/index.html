<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式-工厂方法模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式-工厂方法模式" />
<meta property="og:description" content="一、工厂方法 1、生活场景 系统常见的数据导出功能：数据导出PDF、WORD等常见格式。
2、工厂方法模式 是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式。工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。
3、核心角色 抽象工厂角色
这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。
具体工厂角色
担任这个角色的是实现了抽象工厂接口的具体JAVA类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类。
抽象导出角色
工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。
具体导出角色
这个角色实现了抽象导出角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。
3、核心角色 抽象工厂角色
这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。
具体工厂角色
担任这个角色的是实现了抽象工厂接口的具体JAVA类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类。
抽象导出角色
工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。
具体导出角色
这个角色实现了抽象导出角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。
4、UML关系图 5、源代码实现 // 客户端角色 public class C01_FactoryMethod { public static void main(String[] args) { String data = &#34;&#34; ; ExportFactory factory = new ExportWordFactory () ; ExportFile exportWord = factory.factory(&#34;user-word&#34;) ; exportWord.export(data) ; factory = new ExportPdfFactory() ; ExportFile exportPdf =factory.factory(&#34;log-pdf&#34;) ; exportPdf.export(data) ; } } // 抽象工厂角色 interface ExportFactory { ExportFile factory (String type) ; } // 具体工厂角色 class ExportWordFactory implements ExportFactory { @Override public ExportFile factory(String type) { if (&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/24b63eb58d326c02ea13ab83903c11d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-24T16:31:43+08:00" />
<meta property="article:modified_time" content="2024-01-24T16:31:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式-工厂方法模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、工厂方法</h2> 
<h3>1、生活场景</h3> 
<p>        系统常见的数据导出功能：数据导出PDF、WORD等常见格式。</p> 
<h3>2、工厂方法模式</h3> 
<p>        是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式。工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。</p> 
<h3>3、核心角色</h3> 
<ul><li> <p>抽象工厂角色</p> </li></ul> 
<p>这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。</p> 
<ul><li> <p>具体工厂角色</p> </li></ul> 
<p>担任这个角色的是实现了抽象工厂接口的具体JAVA类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类。</p> 
<ul><li> <p>抽象导出角色</p> </li></ul> 
<p>工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。</p> 
<ul><li> <p>具体导出角色</p> </li></ul> 
<p>这个角色实现了抽象导出角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。</p> 
<h3>3、核心角色</h3> 
<ul><li> <p>抽象工厂角色</p> </li></ul> 
<p>这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。</p> 
<ul><li> <p>具体工厂角色</p> </li></ul> 
<p>担任这个角色的是实现了抽象工厂接口的具体JAVA类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类。</p> 
<ul><li> <p>抽象导出角色</p> </li></ul> 
<p>工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。</p> 
<ul><li> <p>具体导出角色</p> </li></ul> 
<p>这个角色实现了抽象导出角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。</p> 
<h3>4、UML关系图</h3> 
<p></p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/48/b3/iUBoNTAe_o.png" width="877"></p> 
<p></p> 
<h3>5、源代码实现</h3> 
<pre><code class="language-java">// 客户端角色
public class C01_FactoryMethod {
    public static void main(String[] args) {
        String data = "" ;
        ExportFactory factory = new ExportWordFactory () ;
        ExportFile exportWord = factory.factory("user-word") ;
        exportWord.export(data) ;
        factory = new ExportPdfFactory() ;
        ExportFile exportPdf =factory.factory("log-pdf") ;
        exportPdf.export(data) ;
    }
}
// 抽象工厂角色
interface ExportFactory {
    ExportFile factory (String type) ;
}
// 具体工厂角色
class ExportWordFactory implements ExportFactory {
    @Override
    public ExportFile factory(String type) {
        if ("user-word".equals(type)){
            return new ExportUserWordFile() ;
        } else if ("log-word".equals(type)){
            return new ExportLogWordFile() ;
        } else {
            throw new RuntimeException("没有找到对象") ;
        }
    }
}
class ExportPdfFactory implements ExportFactory {
    @Override
    public ExportFile factory(String type) {
        if ("user-pdf".equals(type)){
            return new ExportUserPdfFile() ;
        } else if ("log-pdf".equals(type)){
            return new ExportLogPdfFile() ;
        } else {
            throw new RuntimeException("没有找到对象") ;
        }
    }
}
// 抽象导出角色
interface ExportFile {
    boolean export (String data) ;
}
// 具体导出角色
class ExportUserWordFile implements ExportFile {
    @Override
    public boolean export(String data) {
        System.out.println("导出用户Word文件");
        return true;
    }
}
class ExportLogWordFile implements ExportFile {
    @Override
    public boolean export(String data) {
        System.out.println("导出日志Word文件");
        return true;
    }
}
class ExportUserPdfFile implements ExportFile {
    @Override
    public boolean export(String data) {
        System.out.println("导出用户Pdf文件");
        return true;
    }
}
class ExportLogPdfFile implements ExportFile {
    @Override
    public boolean export(String data) {
        System.out.println("导出日志Pdf文件");
        return true;
    }
}</code></pre> 
<h2>二、Spring应用</h2> 
<h3>1、场景描述</h3> 
<p>基于spring框架的配置实现如下流程：汽车工厂根据不同的国家，生产不同类型的汽车。</p> 
<h3>2、核心工厂类</h3> 
<pre><code class="language-java">public class ProductCar implements CarFactory {
    private Map&lt;String, CarEntity&gt; carMap = null;
    public ProductCar() {
        carMap = new HashMap&lt;&gt;();
        carMap.put("china", new CarEntity("中国", "黑色","红旗"));
        carMap.put("america", new CarEntity("美国", "白色","雪佛兰"));
    }
    @Override
    public CarEntity getCar(String type) {
        return carMap.get(type);
    }
}</code></pre> 
<h3>3、核心Xml配置文件</h3> 
<pre><code class="language-XML">&lt;bean id="productCarFactory" class="com.model.design.spring.node03.factoryMethod.ProductCar" /&gt;
&lt;bean id="car1" factory-bean="productCarFactory" factory-method="getCar"&gt;
    &lt;constructor-arg name="type" value="china" /&gt;
&lt;/bean&gt;
&lt;bean id="car2" factory-bean="productCarFactory" factory-method="getCar"&gt;
    &lt;constructor-arg name="type" value="america" /&gt;
&lt;/bean&gt;</code></pre> 
<h3>4、测试类</h3> 
<pre><code class="language-java">public class SpringTest {
    @Test
    public void test01 (){
        ApplicationContext context01 = new ClassPathXmlApplicationContext("/spring/spring-factorymethod.xml");
        CarEntity car1 = (CarEntity)context01.getBean("car1") ;
        CarEntity car2 = (CarEntity)context01.getBean("car2") ;
        System.out.println(car1);
        System.out.println(car2);
    }
}</code></pre> 
<p><strong>输出结果</strong></p> 
<pre><code class="language-java">CarEntity{country='中国', color='黑色', name='红旗'}
CarEntity{country='美国', color='白色', name='雪佛兰'}</code></pre> 
<h3>三、工厂方法小结</h3> 
<p>工厂方法中，把创建类的动作延迟，就是通过对应的工厂来生成类的对象，这种设计方式符合“开闭”原则。缺点就是当产品的种类过多的时候，需要定义很多产品对应的工厂类。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c807a1e6259953722212c2f7c7641b41/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">#Uniapp: uni.previewImage(OBJECT) 预览图片</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ec9568294555febeb4d3b3329769549/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">设计模式⑧ ：管理状态</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>