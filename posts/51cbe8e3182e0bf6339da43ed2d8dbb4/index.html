<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SQL 优化方案(规范) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SQL 优化方案(规范)" />
<meta property="og:description" content="SQL优化 1、SQL执行顺序2、前置条件2.1、使用explain分析SQL执行计划2.2、开启慢sql日志2.3、慢查询时间设置。默认情况下long_query_time的值为10秒，可以使用命令修改，也可以在my.cnf参数里面修改。 3、基础Sql优化3.1、小表驱动大表3.2、高效的分页3.3、分段查询3.4、注意范围查询语句3.5、查询SQL尽量不要使用select *，而是具体字段3.6、当只需要一条数据的时候，使用limit 13.7、如果排序字段没有用到索引，就尽量少排序3.8、如果限制条件中其他字段没有索引，尽量少用or3.9、避免在where子句中使用or来连接条件3.10、使用varchar代替char3.11、选择合理的字段类型3.12、尽量使用数值替代字符串类型3.13、查询尽量避免返回大量数据3.14、正确的建立索引3.15、指定查询的索引[建议]3.15.1、use index(索引): 推荐使用指定的索引 (最终用不用该索引,还需要mysql自己判断)3.15.2、ignore index(索引) : 忽略掉这个索引3.15.3、force index(索引): 强制使用该索引 3.16、是否使用了索引及其扫描类型3.17、优化like语句3.18、避免隐式类型转换3.19、索引不宜太多，一般5个以内3.20、索引不适合建在有大量重复数据的字段上3.21、where限定查询的数据3.22、避免在索引列上使用内置函数3.23、避免在where中对字段进行表达式操作3.24、避免在where子句中使用!=或&lt;&gt;操作符3.25、去重distinct过滤字段要少3.26、where中使用默认值代替null 4、高级SQL优化4.1、创建表时使用同一的编码4.2、insert插入优化4.3、批量插入性能提升4.4、update优化 (避免出现表锁)4.5、批量删除优化4.6、伪删除设计4.7、order by 排序优化 (排序时,使用有索引的字段进行排序)4.8、不使用ORDER BY RAND()4.9、count 优化 速度:count(*)&gt;count(1)&gt;count(字段)4.10、提高group by语句的效率4.11、复合索引最左特性4.12、排序字段创建索引4.13、删除冗余和重复的索引4.14、不要有超过5个以上的表连接4.15、用连接查询代替子查询[建议]4.16、inner join 、left join、right join，优先使用inner join4.17、join优化4.17.1、MySQL中没有full join，可以用以下方式来解决4.17.2、尽量使用inner join，避免left join4.17.3、合理利用索引4.17.4、利用小表去驱动大表4.17.5、巧用STRAIGHT_JOIN 4.18、in子查询的优化4.19、SQL语句中IN包含的值不应过多4.20、尽量使用union all替代union4.21、区分in和exists、not in和not exists 1、SQL执行顺序 SELECT DISTINCT column,… (选择字段 、去重)AGG_FUNC(column or expression),… (聚合函数)FROM [left_table] (选择表)&lt;join_type&gt; JOIN &lt;right_table&gt; (连接)ON &lt;join_condition&gt; (连接条件)WHERE &lt;where_condition&gt; (条件过滤)GROUP BY &lt;group_by_list&gt; (分组)HAVING &lt;having_condition&gt; (分组过滤)ORDER BY &lt;order_by_list&gt; (排序)LIMIT count OFFSET count; (分页) 2、前置条件 2.1、使用explain分析SQL执行计划 SQL很灵活，一个需求可以很多实现，那哪个最优呢？SQL提供了explain关键字，它可以分析你的SQL执行计划，看它是否最佳。Explain主要看SQL是否使用了索引。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/51cbe8e3182e0bf6339da43ed2d8dbb4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-06T11:52:33+08:00" />
<meta property="article:modified_time" content="2023-02-06T11:52:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SQL 优化方案(规范)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>SQL优化</h4> 
 <ul><li><a href="#1SQL_1" rel="nofollow">1、SQL执行顺序</a></li><li><a href="#2_13" rel="nofollow">2、前置条件</a></li><li><ul><li><a href="#21explainSQL_14" rel="nofollow">2.1、使用explain分析SQL执行计划</a></li><li><a href="#22sql_24" rel="nofollow">2.2、开启慢sql日志</a></li><li><a href="#23long_query_time10mycnf_48" rel="nofollow">2.3、慢查询时间设置。默认情况下long_query_time的值为10秒，可以使用命令修改，也可以在my.cnf参数里面修改。</a></li></ul> 
  </li><li><a href="#3Sql_64" rel="nofollow">3、基础Sql优化</a></li><li><ul><li><a href="#31_65" rel="nofollow">3.1、小表驱动大表</a></li><li><a href="#32_69" rel="nofollow">3.2、高效的分页</a></li><li><a href="#33_84" rel="nofollow">3.3、分段查询</a></li><li><a href="#34_89" rel="nofollow">3.4、注意范围查询语句</a></li><li><a href="#35SQLselect__94" rel="nofollow">3.5、查询SQL尽量不要使用select *，而是具体字段</a></li><li><a href="#36limit_1_109" rel="nofollow">3.6、当只需要一条数据的时候，使用limit 1</a></li><li><a href="#37_112" rel="nofollow">3.7、如果排序字段没有用到索引，就尽量少排序</a></li><li><a href="#38or_115" rel="nofollow">3.8、如果限制条件中其他字段没有索引，尽量少用or</a></li><li><a href="#39whereor_118" rel="nofollow">3.9、避免在where子句中使用or来连接条件</a></li><li><a href="#310varcharchar_139" rel="nofollow">3.10、使用varchar代替char</a></li><li><a href="#311_153" rel="nofollow">3.11、选择合理的字段类型</a></li><li><a href="#312_158" rel="nofollow">3.12、尽量使用数值替代字符串类型</a></li><li><a href="#313_165" rel="nofollow">3.13、查询尽量避免返回大量数据</a></li><li><a href="#314_169" rel="nofollow">3.14、正确的建立索引</a></li><li><a href="#315_178" rel="nofollow">3.15、指定查询的索引[建议]</a></li><li><ul><li><a href="#3151use_index___mysql_181" rel="nofollow">3.15.1、use index(索引): 推荐使用指定的索引 (最终用不用该索引,还需要mysql自己判断)</a></li><li><a href="#3152ignore_index___185" rel="nofollow">3.15.2、ignore index(索引) : 忽略掉这个索引</a></li><li><a href="#3153force_index__189" rel="nofollow">3.15.3、force index(索引): 强制使用该索引</a></li></ul> 
   </li><li><a href="#316_194" rel="nofollow">3.16、是否使用了索引及其扫描类型</a></li><li><a href="#317like_209" rel="nofollow">3.17、优化like语句</a></li><li><a href="#318_242" rel="nofollow">3.18、避免隐式类型转换</a></li><li><a href="#3195_259" rel="nofollow">3.19、索引不宜太多，一般5个以内</a></li><li><a href="#320_265" rel="nofollow">3.20、索引不适合建在有大量重复数据的字段上</a></li><li><a href="#321where_268" rel="nofollow">3.21、where限定查询的数据</a></li><li><a href="#322_281" rel="nofollow">3.22、避免在索引列上使用内置函数</a></li><li><a href="#323where_310" rel="nofollow">3.23、避免在where中对字段进行表达式操作</a></li><li><a href="#324where_330" rel="nofollow">3.24、避免在where子句中使用!=或&lt;&gt;操作符</a></li><li><a href="#325distinct_345" rel="nofollow">3.25、去重distinct过滤字段要少</a></li><li><a href="#326wherenull_364" rel="nofollow">3.26、where中使用默认值代替null</a></li></ul> 
  </li><li><a href="#4SQL_389" rel="nofollow">4、高级SQL优化</a></li><li><ul><li><a href="#41_390" rel="nofollow">4.1、创建表时使用同一的编码</a></li><li><a href="#42insert_395" rel="nofollow">4.2、insert插入优化</a></li><li><a href="#43_402" rel="nofollow">4.3、批量插入性能提升</a></li><li><a href="#44update___417" rel="nofollow">4.4、update优化 (避免出现表锁)</a></li><li><a href="#45_423" rel="nofollow">4.5、批量删除优化</a></li><li><a href="#46_450" rel="nofollow">4.6、伪删除设计</a></li><li><a href="#47order_by___459" rel="nofollow">4.7、order by 排序优化 (排序时,使用有索引的字段进行排序)</a></li><li><a href="#48ORDER_BY_RAND_465" rel="nofollow">4.8、不使用ORDER BY RAND()</a></li><li><a href="#49count______countcount1count_476" rel="nofollow">4.9、count 优化 速度:count(*)&gt;count(1)&gt;count(字段)</a></li><li><a href="#410group_by_482" rel="nofollow">4.10、提高group by语句的效率</a></li><li><a href="#411_497" rel="nofollow">4.11、复合索引最左特性</a></li><li><a href="#412_527" rel="nofollow">4.12、排序字段创建索引</a></li><li><a href="#413_552" rel="nofollow">4.13、删除冗余和重复的索引</a></li><li><a href="#4145_569" rel="nofollow">4.14、不要有超过5个以上的表连接</a></li><li><a href="#415_576" rel="nofollow">4.15、用连接查询代替子查询[建议]</a></li><li><a href="#416inner_join_left_joinright_joininner_join_594" rel="nofollow">4.16、inner join 、left join、right join，优先使用inner join</a></li><li><a href="#417join_604" rel="nofollow">4.17、join优化</a></li><li><ul><li><a href="#4171MySQLfull_join_609" rel="nofollow">4.17.1、MySQL中没有full join，可以用以下方式来解决</a></li><li><a href="#4172inner_joinleft_join_613" rel="nofollow">4.17.2、尽量使用inner join，避免left join</a></li><li><a href="#4173_616" rel="nofollow">4.17.3、合理利用索引</a></li><li><a href="#4174_619" rel="nofollow">4.17.4、利用小表去驱动大表</a></li><li><a href="#4175STRAIGHT_JOIN_623" rel="nofollow">4.17.5、巧用STRAIGHT_JOIN</a></li></ul> 
   </li><li><a href="#418in_628" rel="nofollow">4.18、in子查询的优化</a></li><li><a href="#419SQLIN_662" rel="nofollow">4.19、SQL语句中IN包含的值不应过多</a></li><li><a href="#420union_allunion_667" rel="nofollow">4.20、尽量使用union all替代union</a></li><li><a href="#421inexistsnot_innot_exists_685" rel="nofollow">4.21、区分in和exists、not in和not exists</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1SQL_1"></a>1、SQL执行顺序</h2> 
<ul><li>SELECT DISTINCT column,… (选择字段 、去重)</li><li>AGG_FUNC(column or expression),… (聚合函数)</li><li>FROM [left_table] (选择表)</li><li>&lt;join_type&gt; JOIN &lt;right_table&gt; (连接)</li><li>ON &lt;join_condition&gt; (连接条件)</li><li>WHERE &lt;where_condition&gt; (条件过滤)</li><li>GROUP BY &lt;group_by_list&gt; (分组)</li><li>HAVING &lt;having_condition&gt; (分组过滤)</li><li>ORDER BY &lt;order_by_list&gt; (排序)</li><li>LIMIT count OFFSET count; (分页)</li></ul> 
<h2><a id="2_13"></a>2、前置条件</h2> 
<h3><a id="21explainSQL_14"></a>2.1、使用explain分析SQL执行计划</h3> 
<p>SQL很灵活，一个需求可以很多实现，那哪个最优呢？SQL提供了explain关键字，它可以分析你的SQL执行计划，看它是否最佳。Explain主要看SQL是否使用了索引。</p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span>
</code></pre> 
<p>返回结果：<br> <img src="https://images2.imgbox.com/d6/93/nyFZYb3g_o.png" alt="在这里插入图片描述"><br> 不清楚EXPLAIN解析器的同学可以先去看看这篇文章: <a href="http://t.csdn.cn/UgXow" rel="nofollow">SQL EXPLAIN解析器</a></p> 
<h3><a id="22sql_24"></a>2.2、开启慢sql日志</h3> 
<p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，可以通过设置slow_query_log的值来开启，如下所示：</p> 
<p><strong>1、查询慢日志是否开启</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> ‘<span class="token operator">%</span>slow_query_log<span class="token operator">%</span>’<span class="token punctuation">;</span>
</code></pre> 
<p><strong>2、开启慢查询日志(OFF 为关闭 ON为开启)</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">set</span> <span class="token keyword">global</span> slow_query_log<span class="token operator">=</span><span class="token keyword">ON</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>注意：使用 set global slowquerylog=1 开启了慢查询日志只对当前数据库生效，MySQL重启后失效。如果要永久生效，就必须修改配置文件my.cnf</p> 
</blockquote> 
<p><strong>3、永久开启慢查询日志</strong></p> 
<pre><code class="prism language-sql">修改my<span class="token punctuation">.</span>cnf文件，增加或修改参数slow_query_log 和slow_query_log_file后，然后重启MySQL服务器，
    slow_query_log <span class="token operator">=</span><span class="token number">1</span>
    slow_query_log_file<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span><span class="token keyword">local</span><span class="token operator">/</span>mysql<span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>localhost<span class="token operator">-</span>slow<span class="token punctuation">.</span>log
</code></pre> 
<p><strong>4、设置日志路径和未使用索引的查询(有默认值，可以不设置)</strong></p> 
<pre><code class="prism language-sql">log<span class="token operator">-</span>slow<span class="token operator">-</span>queries <span class="token operator">=</span> <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token keyword">local</span><span class="token operator">/</span>mysql<span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>slow<span class="token punctuation">.</span>log <span class="token comment">#定义慢查询日志路径。</span>
log<span class="token operator">-</span>queries<span class="token operator">-</span><span class="token operator">not</span><span class="token operator">-</span><span class="token keyword">using</span><span class="token operator">-</span>indexes <span class="token comment">#未使用索引的查询也被记录到慢查询日志中（可选）。</span>
</code></pre> 
<h3><a id="23long_query_time10mycnf_48"></a>2.3、慢查询时间设置。默认情况下long_query_time的值为10秒，可以使用命令修改，也可以在my.cnf参数里面修改。</h3> 
<p><strong>1、查询慢日志时间</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> ‘long_query_time’<span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>注：如果设置了日志时间，对当前会话是无效的。所以用全局查询 show global variables like ‘long_query_time’;</p> 
</blockquote> 
<p><strong>2、设置慢查询日志时间</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">set</span> <span class="token keyword">global</span> long_query_time<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>3、查看总执行了多少次慢sql</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">show</span> <span class="token keyword">global</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'%slow%'</span><span class="token punctuation">;</span>  
</code></pre> 
<h2><a id="3Sql_64"></a>3、基础Sql优化</h2> 
<h3><a id="31_65"></a>3.1、小表驱动大表</h3> 
<ul><li>in 的话里面驱动外面，in适合里子查询是小表</li><li>exist 的话外面驱动里面，适合外面是小表</li></ul> 
<h3><a id="32_69"></a>3.2、高效的分页</h3> 
<p><strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">limit</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">;</span>
</code></pre> 
<p>mysql会查询10020条，然后丢弃前面10000条，这个比较浪费资源</p> 
<p><strong>正例：</strong></p> 
<pre><code class="prism language-sql"><span class="token comment">-- 可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点</span>
<span class="token keyword">select</span> id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age <span class="token keyword">from</span> <span class="token keyword">user</span> id<span class="token operator">&gt;</span><span class="token number">10000</span> <span class="token keyword">limit</span> <span class="token number">20</span><span class="token punctuation">;</span>
</code></pre> 
<p>找到上次分页最大id, 假如id是连续的，并且有序，可以用between</p> 
<blockquote> 
 <p>注意： between要在唯一索引上分页，不然会出现每页大小不一致问题。</p> 
</blockquote> 
<h3><a id="33_84"></a>3.3、分段查询</h3> 
<p>在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。</p> 
<p>如下图这个SQL语句，扫描的行数成百万级以上的时候就可以使用分段查询：<br> <img src="https://images2.imgbox.com/5c/ac/UUgEp4Jf_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="34_89"></a>3.4、注意范围查询语句</h3> 
<blockquote> 
 <p>注: &lt; &gt; &gt;= &lt;= 都有可能不走索引, 索引失效是因为DBMS发现全表扫描比走索引效率更高，因此就放弃了走索引, 当Mysql发现通过索引扫描的行记录数超过全表的10%-30%时，优化器可能会放弃走索引，自动变成全表扫描。</p> 
</blockquote> 
<p><strong>解决方式</strong>: 参照 3.16.3、force index(索引): 强制使用该索引</p> 
<h3><a id="35SQLselect__94"></a>3.5、查询SQL尽量不要使用select *，而是具体字段</h3> 
<p><strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student
</code></pre> 
<p><strong>正例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>SELECT*增加很多不必要的消耗（CPU、IO、内存、网络带宽）</li><li>字段多时，大表能达到100多个字段甚至达200多个字段</li><li>只取需要的字段，节省资源、减少网络开销</li><li>select * 进行查询时，很可能不会用到索引，就会造成全表扫描</li><li>增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名</li></ul> 
<h3><a id="36limit_1_109"></a>3.6、当只需要一条数据的时候，使用limit 1</h3> 
<p>为了使EXPLAIN中type列达到const类型，如果加上limit1，查找到就不用继续往后找了</p> 
<h3><a id="37_112"></a>3.7、如果排序字段没有用到索引，就尽量少排序</h3> 
<p>可以在程序中排序</p> 
<h3><a id="38or_115"></a>3.8、如果限制条件中其他字段没有索引，尽量少用or</h3> 
<p>or两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用union all或者是union（必要的时候）的方式来代替“or”会得到更好的效果。</p> 
<h3><a id="39whereor_118"></a>3.9、避免在where子句中使用or来连接条件</h3> 
<p>查询id为1或者薪水为3000的用户<br> <strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">OR</span> salary<span class="token operator">=</span><span class="token number">30000</span>
</code></pre> 
<p><strong>正例：使用union all</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">UNION</span> <span class="token keyword">ALL</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> salary<span class="token operator">=</span><span class="token number">30000</span>
</code></pre> 
<p><strong>分开两条sql写</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> salary<span class="token operator">=</span><span class="token number">30000</span>
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>使用or可能会使索引失效，从而全表扫描</li><li>对于or没有索引的salary这种情况，假设它走了id的索引，但是走到salary查询条件时，它还得全表扫描。也就是说整个过程需要三步：全表扫描+索引扫描+合并。如果它一开始就走全表扫描，直接一遍扫描就搞定。虽然mysql是有优化器的，处于效率与成本考虑，遇到or条件，索引还是可能失效的</li></ul> 
<h3><a id="310varcharchar_139"></a>3.10、使用varchar代替char</h3> 
<p><strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token identifier"><span class="token punctuation">`</span>deptname<span class="token punctuation">`</span></span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'部门名称'</span>
</code></pre> 
<p><strong>正例：</strong></p> 
<pre><code class="prism language-sql"><span class="token identifier"><span class="token punctuation">`</span>deptname<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'部门名称'</span>
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>varchar变长字段按数据内容实际长度存储，存储空间小，可以节省存储空间</li><li>char按声明大小存储，不足补空格</li><li>对于查询来说，在一个相对较小的字段内搜索，效率更高</li></ul> 
<h3><a id="311_153"></a>3.11、选择合理的字段类型</h3> 
<ul><li>能用数字类型就不用字符串，字符串处理速度比数字类型慢</li><li>尽量用小类型，比如：用bit存布尔值，用tinyint存枚举值等。</li><li>长度固定字符串用char，不固定用varchar</li></ul> 
<h3><a id="312_158"></a>3.12、尽量使用数值替代字符串类型</h3> 
<ul><li>主键（id）：primary key优先使用数值类型int，tinyint</li><li>性别（sex）：0-代表女，1-代表男；数据库没有布尔类型，mysql推荐使用tinyint</li><li>支付方式（payment）：1-现金、2-微信、3-支付宝、4-信用卡、5-银行卡</li><li>服务状态（state）：1-开启、2-暂停、3-停止</li><li>商品状态（state）：1-上架、2-下架、3-删除</li></ul> 
<h3><a id="313_165"></a>3.13、查询尽量避免返回大量数据</h3> 
<p>如果查询返回数据量很大，就会造成查询时间过长，网络传输时间过长。同时，大量数据返回也可能没有实际意义。如返回上千条甚至更多，用户也看不过来。<br> 通常采用分页，一页习惯10/20/50/100条。</p> 
<h3><a id="314_169"></a>3.14、正确的建立索引</h3> 
<p>索引的建立对sql的影响是非常大的,如果对索引不太理解的先看下这篇文章: <a href="http://t.csdn.cn/mPz1K" rel="nofollow">MySQL进阶:索引的使用及理解</a></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span>  <span class="token operator">*</span> <span class="token keyword">from</span> user_test  <span class="token keyword">WHERE</span> uid<span class="token operator">=</span><span class="token number">15988</span><span class="token punctuation">;</span>
<span class="token keyword">select</span>  <span class="token operator">*</span> <span class="token keyword">from</span> user_test  <span class="token keyword">WHERE</span> address<span class="token operator">=</span><span class="token number">15988</span><span class="token punctuation">;</span>  可以看到有索引的查找速度非常快<span class="token punctuation">.</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2f/57/XHHAvZRM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/59/0d/nF6GyKLk_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="315_178"></a>3.15、指定查询的索引[建议]</h3> 
<p>当sql查询的字段有多个索引的时候,mysql优化器会自动选择一个索引进行查询,我们也可以通过sql字段进行自定义</p> 
<h4><a id="3151use_index___mysql_181"></a>3.15.1、use index(索引): 推荐使用指定的索引 (最终用不用该索引,还需要mysql自己判断)</h4> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span>  <span class="token keyword">use</span> <span class="token keyword">index</span><span class="token punctuation">(</span>索引A<span class="token punctuation">)</span>  
</code></pre> 
<h4><a id="3152ignore_index___185"></a>3.15.2、ignore index(索引) : 忽略掉这个索引</h4> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span>  <span class="token keyword">ignore</span> <span class="token keyword">index</span><span class="token punctuation">(</span>索引A<span class="token punctuation">)</span> 
</code></pre> 
<h4><a id="3153force_index__189"></a>3.15.3、force index(索引): 强制使用该索引</h4> 
<pre><code class="prism language-sql"><span class="token comment">-- 有时候MySQL优化器采取它认为合适的索引来检索SQL语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用forceindex来强制优化器使用指定的索引。</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span>  <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>索引A<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="316_194"></a>3.16、是否使用了索引及其扫描类型</h3> 
<p><a href="http://t.csdn.cn/DY46i" rel="nofollow">SQL索引概念（详解B+树）</a><br> <strong>type：</strong></p> 
<ul><li><strong>ALL</strong> 全表扫描，没有优化，最慢的方式</li><li><strong>index</strong> 索引全扫描</li><li><strong>range</strong> 索引范围扫描，常用语&lt;，&lt;=，&gt;=，between等操作</li><li><strong>ref</strong> 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中</li><li><strong>eq_ref</strong> 类似ref，区别在于使用的是唯一索引，使用主键的关联查询</li><li><strong>const</strong> 当查询是对主键或者唯一键进行精确查询，系统会把匹配行中的其他列作为常数处理</li><li><strong>null MySQL</strong>不访问任何表或索引，直接返回结果</li><li><strong>System</strong> 表只有一条记录(实际中基本不存在这个情况)</li></ul> 
<blockquote> 
 <p>性能排行： System &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</p> 
</blockquote> 
<h3><a id="317like_209"></a>3.17、优化like语句</h3> 
<p>模糊查询，程序员最喜欢的就是使用like，但是like很可能会导致索引失效<br> <strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> NAME <span class="token operator">LIKE</span> <span class="token string">'%1'</span>
<span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> NAME <span class="token operator">LIKE</span> <span class="token string">'%1%'</span>
</code></pre> 
<p><strong>正例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> NAME <span class="token operator">LIKE</span> <span class="token string">'1%'</span>
</code></pre> 
<p><strong>理由：</strong><br> <strong>未使用索引：故意使用sex非索引字段</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> NAME<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">OR</span> sex<span class="token operator">=</span><span class="token number">1</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/5a/d6/dBmjspcq_o.png" alt="在这里插入图片描述"><br> <strong>主键索引生效</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/08/0b/bCGKbnmo_o.png" alt="在这里插入图片描述"><br> <strong>索引失效，type=ALL，全表扫描</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">LIKE</span> <span class="token string">'%1'</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3e/f8/iZBSRFiv_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="318_242"></a>3.18、避免隐式类型转换</h3> 
<p><strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token comment">#未使用索引</span>
<span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> NAME<span class="token operator">=</span><span class="token number">123</span>
</code></pre> 
<p><strong>正例：</strong></p> 
<pre><code class="prism language-sql"><span class="token comment">#使用索引</span>
<span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> NAME<span class="token operator">=</span><span class="token string">'123'</span>
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>为什么第一条语句未加单引号就不走索引了呢？这是因为不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL会做隐式的类型转换，把它们转换为数值类型再做比较</li><li>where子句中出现column字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定where中的参数类型。</li></ul> 
<h3><a id="3195_259"></a>3.19、索引不宜太多，一般5个以内</h3> 
<ul><li>索引并不是越多越好，虽其提高了查询的效率，但却会降低插入和更新的效率</li><li>索引可以理解为一个就是一张表，其可以存储数据，其数据就要占空间</li><li>索引表的一个特点，其数据是排序的，那排序要不要花时间呢？肯定要insert或update时有可能会重建索引，如果数据量巨大，重建将进行记录的重新排序，所以建索引需要慎重考虑，视具体情况来定</li><li>一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否有存在的必要</li></ul> 
<h3><a id="320_265"></a>3.20、索引不适合建在有大量重复数据的字段上</h3> 
<p>如性别字段。因为SQL优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，Mysql查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</p> 
<h3><a id="321where_268"></a>3.21、where限定查询的数据</h3> 
<p>数据中假定就一个男的记录<br> <strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> sex<span class="token operator">=</span><span class="token string">'男'</span>
</code></pre> 
<p><strong>正例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">AND</span> sex<span class="token operator">=</span><span class="token string">'男'</span>
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>需要什么数据，就去查什么数据，避免返回不必要的数据，节省开销</li></ul> 
<h3><a id="322_281"></a>3.22、避免在索引列上使用内置函数</h3> 
<p>业务需求：查询最近七天内新生儿（用学生表替代下）<br> 给birthday字段创建索引：</p> 
<pre><code class="prism language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> student <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> idx_birthday <span class="token punctuation">(</span>birthday<span class="token punctuation">)</span>
</code></pre> 
<p>当前时间加7天：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	
<span class="token keyword">SELECT</span> DATE_ADD<span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">INTERVAL</span> <span class="token number">7</span> <span class="token keyword">DAY</span><span class="token punctuation">)</span>
</code></pre> 
<p><strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student
<span class="token keyword">WHERE</span> DATE_ADD<span class="token punctuation">(</span>birthday<span class="token punctuation">,</span><span class="token keyword">INTERVAL</span> <span class="token number">7</span> <span class="token keyword">DAY</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>正例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student
<span class="token keyword">WHERE</span>  birthday <span class="token operator">&gt;=</span> DATE_ADD<span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">INTERVAL</span> <span class="token number">7</span> <span class="token keyword">DAY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>使用索引列上内置函数</li><li>索引失效<br> <img src="https://images2.imgbox.com/76/6e/s1XGreer_o.png" alt="在这里插入图片描述"><br> 索引有效：<br> <img src="https://images2.imgbox.com/58/ec/Q9Al292H_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="323where_310"></a>3.23、避免在where中对字段进行表达式操作</h3> 
<p><strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">=</span><span class="token operator">+</span><span class="token number">1</span>
</code></pre> 
<p><strong>正例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">1</span>
</code></pre> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span>
</code></pre> 
<p><strong>理由：</strong><br> SQL解析时，如果字段相关的是表达式就进行全表扫描<br> <img src="https://images2.imgbox.com/35/aa/NDnB1a8C_o.png" alt="在这里插入图片描述"><br> <strong>字段干净无表达式，索引生效</strong><br> <img src="https://images2.imgbox.com/de/a6/BxfgYhrv_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="324where_330"></a>3.24、避免在where子句中使用!=或&lt;&gt;操作符</h3> 
<p>应尽量避免在where子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。记住实现业务优先，实在没办法，就只能使用，并不是不能使用。如果不能使用，SQL也就无需支持了。</p> 
<p><strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> salary<span class="token operator">!=</span><span class="token number">3000</span>
</code></pre> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> salary<span class="token operator">&lt;&gt;</span><span class="token number">3000</span>
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>使用!=和&lt;&gt;很可能会让索引失效<br> <img src="https://images2.imgbox.com/69/f4/mI551x0l_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="325distinct_345"></a>3.25、去重distinct过滤字段要少</h3> 
<pre><code class="prism language-sql"><span class="token comment">#索引失效</span>
<span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student
</code></pre> 
<pre><code class="prism language-sql"><span class="token comment">#索引生效</span>
<span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student
</code></pre> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> NAME <span class="token keyword">FROM</span> student
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>带distinct的语句占用cpu时间高于不带distinct的语句。因为当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较、过滤的过程会占用系统资源，如cpu时间</li></ul> 
<h3><a id="326wherenull_364"></a>3.26、where中使用默认值代替null</h3> 
<p><strong>环境准备：</strong></p> 
<pre><code class="prism language-sql"><span class="token comment">#修改表，增加age字段，类型int，非空，默认值0</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> student <span class="token keyword">ADD</span> age <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-sql"><span class="token comment">#修改表，增加age字段的索引，名称为idx_age</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> student <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> idx_age <span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> age <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
</code></pre> 
<p><strong>正例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> age<span class="token operator">&gt;</span><span class="token number">0</span>
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>并不是说使用了is null 或者 is not null 就会不走索引了，这个跟mysql版本以及查询成本都有关</li><li>如果mysql优化器发现，走索引比不走索引成本还要高，就会放弃索引，这些条件 !=，&lt;&gt;，is null，is not null经常被认为让索引失效，其实是因为一般情况下，查询的成本高，优化器自动放弃索引的</li><li>如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思也相对清晰一点</li></ul> 
<h2><a id="4SQL_389"></a>4、高级SQL优化</h2> 
<h3><a id="41_390"></a>4.1、创建表时使用同一的编码</h3> 
<p>mysql多表联查时,如果表的字符集不一样,会有一个数据类型转换的过程</p> 
<p>例如: utf8 与utf8mb4前者是3字节unicode编码，后者是4字节unicode编码. 此时如果多表查询,则索引会失效</p> 
<h3><a id="42insert_395"></a>4.2、insert插入优化</h3> 
<ul><li>需要插入多条数据的时候使用批量插入,(多次插入需要频繁的建立连接,浪费资源)</li><li>多次插入数据时,采用手动提交事务 
  <ul><li>sql语句在执行的时候如下所示, 会自动开启事务和提交事务,可以手动开启事务,然后执行多条sql后,在手动提交事务,减少资源浪费</li></ul> </li></ul> 
<pre><code class="prism language-sql"><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>   执行<span class="token keyword">sql</span><span class="token punctuation">;</span>   <span class="token keyword">commit</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="43_402"></a>4.3、批量插入性能提升</h3> 
<p>大量数据提交，上千，上万，批量性能非常快，mysql独有<br> <strong>多条提交：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student <span class="token punctuation">(</span>id<span class="token punctuation">,</span>NAME<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'name1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student <span class="token punctuation">(</span>id<span class="token punctuation">,</span>NAME<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'name2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>批量提交：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student <span class="token punctuation">(</span>id<span class="token punctuation">,</span>NAME<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'name1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'name2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>默认新增SQL有事务控制，导致每条都需要事务开启和事务提交；而批量处理是一次事务开启和提交。自然速度飞升</li><li>数据量小体现不出来</li></ul> 
<h3><a id="44update___417"></a>4.4、update优化 (避免出现表锁)</h3> 
<p>innodb引擎使用update时,会有行锁/表锁两种模式, 如果 where 字段没有索引的时候会升级成表锁</p> 
<pre><code class="prism language-sql"><span class="token keyword">update</span> <span class="token keyword">table</span> <span class="token keyword">set</span> xx<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">where</span>  name<span class="token operator">=</span>xx   <span class="token punctuation">(</span>name没有索引<span class="token punctuation">,</span>此时是表锁<span class="token punctuation">)</span>
<span class="token keyword">update</span> <span class="token keyword">table</span> <span class="token keyword">set</span> xx<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">where</span>  id<span class="token operator">=</span>xx  <span class="token punctuation">(</span>id有索引<span class="token punctuation">,</span>此时是行锁<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="45_423"></a>4.5、批量删除优化</h3> 
<p>避免同时修改或删除过多数据，因为会造成cpu利用率过高，会造成锁表操作，从而影响别人对数据库的访问。</p> 
<p><strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token comment">#一次删除10万或者100万+？</span>
<span class="token keyword">delete</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id <span class="token operator">&lt;</span><span class="token number">100000</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-java">#采用单一循环操作，效率低，时间漫长
<span class="token keyword">for</span>（<span class="token class-name">User</span> user<span class="token operator">:</span>list）<span class="token punctuation">{<!-- --></span>
  delete from student<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>正例：</strong></p> 
<pre><code class="prism language-java">#分批进行删除，如每次<span class="token number">500</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
delete student where id<span class="token operator">&lt;</span><span class="token number">500</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-sql"><span class="token keyword">delete</span> student <span class="token keyword">where</span> id<span class="token operator">&gt;=</span><span class="token number">500</span> <span class="token operator">and</span> id<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>一次性删除太多数据，可能造成锁表，会有lock wait timeout exceed的错误，所以建议分批操作</li></ul> 
<h3><a id="46_450"></a>4.6、伪删除设计</h3> 
<p>商品状态（state）：1-上架、2-下架、3-删除</p> 
<p><strong>理由：</strong></p> 
<ul><li>这里的删除只是一个标识，并没有从数据库表中真正删除，可以作为历史记录备查</li><li>同时，一个大型系统中，表关系是非常复杂的，如电商系统中，商品作废了，但如果直接删除商品，其它商品详情，物流信息中可能都有其引用。</li><li>通过where state=1或者where state=2过滤掉数据，这样伪删除的数据用户就看不到了，从而不影响用户的使用</li><li>操作速度快，特别数据量很大情况下</li></ul> 
<h3><a id="47order_by___459"></a>4.7、order by 排序优化 (排序时,使用有索引的字段进行排序)</h3> 
<p>使用order by排序时,会出现两种情况 (explain查看Extra字段)<br> <img src="https://images2.imgbox.com/73/d8/gfmbwrXD_o.png" alt="在这里插入图片描述"></p> 
<ul><li>using fileSort : 全表扫描,读取出数据,然后再排序缓冲区进行排序. (排序字段没有索引)</li><li>using index: 通过索引直接返回有序的数据. 不需要额外排序(有索引,效率高)</li></ul> 
<h3><a id="48ORDER_BY_RAND_465"></a>4.8、不使用ORDER BY RAND()</h3> 
<p>想打乱返回的数据行?随机挑一个数据?真不知道谁发明了这种用法，但很多新手很喜欢这样用。但你确不了解这样做有多么可怕的性能问题。</p> 
<p>如果你真的想把返回的数据行打乱了，你有N种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL会不得不去执行RAND()函数(很耗CPU时间)，而且这是为了每一行记录去记行，然后再对其排序。就算是你用了Limit 1也无济于事(因为要排序)。</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">`</span>dynamic<span class="token punctuation">`</span></span> <span class="token keyword">order</span> <span class="token keyword">by</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">limit</span> <span class="token number">1000</span><span class="token punctuation">;</span>
</code></pre> 
<p>上面的SQL语句，可优化为：</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">`</span>dynamic<span class="token punctuation">`</span></span> t1 <span class="token keyword">join</span> <span class="token punctuation">(</span><span class="token keyword">select</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">`</span>dynamic<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">as</span> nid<span class="token punctuation">)</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>id <span class="token operator">&gt;</span> t2<span class="token punctuation">.</span>nidlimit <span class="token number">1000</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="49count______countcount1count_476"></a>4.9、count 优化 速度:count(*)&gt;count(1)&gt;count(字段)</h3> 
<p>inndb引擎的使用如下 (MyIASM默认存了数据总数,所以效率最高)</p> 
<ul><li>count(字段):遍历整张表 会把每一行的字段值取出来,然后返回</li><li>count(1): 遍历整张表,但不取值,对于返回的数据,放入1进去.然后累加</li><li>count(*):inndb引擎,特意做了优化,不会取出值,直接服务层进行累加</li></ul> 
<h3><a id="410group_by_482"></a>4.10、提高group by语句的效率</h3> 
<p>可以在执行到该语句前，把不需要的记录过滤掉<br> <strong>反例：先分组，再过滤</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> job，avg（salary） <span class="token keyword">from</span> employee  
<span class="token keyword">group</span> <span class="token keyword">by</span> job 
<span class="token keyword">having</span> job <span class="token operator">=</span><span class="token string">'president'</span> <span class="token operator">or</span> job <span class="token operator">=</span> <span class="token string">'managent'</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>正例：先过滤，后分组</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> job，avg（salary） <span class="token keyword">from</span> employee 
<span class="token keyword">where</span> job <span class="token operator">=</span><span class="token string">'president'</span> <span class="token operator">or</span> job <span class="token operator">=</span> <span class="token string">'managent'</span> 
<span class="token keyword">group</span> <span class="token keyword">by</span> job<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="411_497"></a>4.11、复合索引最左特性</h3> 
<p><strong>创建复合索引，也就是多个字段</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> student <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> idx_name_salary <span class="token punctuation">(</span>NAME<span class="token punctuation">,</span>salary<span class="token punctuation">)</span>
</code></pre> 
<p><strong>满足复合索引的左侧顺序，哪怕只是部分，复合索引生效</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> NAME<span class="token operator">=</span><span class="token string">'name1'</span>
</code></pre> 
<p><strong>没有出现左边的字段，则不满足最左特性，索引失效</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> salary<span class="token operator">=</span><span class="token number">3000</span>
</code></pre> 
<p><strong>复合索引全使用，按左侧顺序出现 name,salary，索引生效</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> NAME<span class="token operator">=</span><span class="token string">'陈子枢'</span> <span class="token operator">AND</span> salary<span class="token operator">=</span><span class="token number">3000</span>
</code></pre> 
<p><strong>虽然违背了最左特性，但MYSQL执行SQL时会进行优化，底层进行颠倒优化</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> salary<span class="token operator">=</span><span class="token number">3000</span> <span class="token operator">AND</span> NAME<span class="token operator">=</span><span class="token string">'name1'</span>
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>复合索引也称为联合索引</li><li>当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则</li><li>联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的</li></ul> 
<h3><a id="412_527"></a>4.12、排序字段创建索引</h3> 
<p>什么样的字段才需要创建索引呢？原则就是where和order by中常出现的字段就创建索引。</p> 
<pre><code class="prism language-sql"><span class="token comment">#使用*，包含了未索引的字段，导致索引失效</span>
<span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> NAME<span class="token punctuation">;</span>

<span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> NAME<span class="token punctuation">,</span>salary

<span class="token comment">#name字段有索引</span>
<span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> NAME

<span class="token comment">#name和salary复合索引</span>
<span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> NAME<span class="token punctuation">,</span>salary

<span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> salary<span class="token punctuation">,</span>NAME

<span class="token comment">#排序字段未创建索引，性能就慢</span>
<span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>NAME <span class="token keyword">FROM</span> student <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> sex
</code></pre> 
<h3><a id="413_552"></a>4.13、删除冗余和重复的索引</h3> 
<pre><code class="prism language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> student 

<span class="token comment">#创建索引index_name</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> student <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span>NAME<span class="token punctuation">)</span>

<span class="token comment">#删除student表的index_name索引</span>
<span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> student <span class="token punctuation">;</span>

<span class="token comment">#修改表结果，删除student表的index_name索引</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> student <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">;</span>

<span class="token comment">#主键会自动创建索引，删除主键索引</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> student <span class="token keyword">DROP</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e9/09/4ckIfxYy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4145_569"></a>4.14、不要有超过5个以上的表连接</h3> 
<ul><li>关联的表个数越多，编译的时间和开销也就越大</li><li>每次关联内存中都生成一个临时表</li><li>应该把连接表拆开成较小的几个执行，可读性更高</li><li>如果一定需要连接很多表才能得到数据，那么意味着这是个糟糕的设计了</li><li>阿里规范中，建议多表联查三张表以下</li></ul> 
<h3><a id="415_576"></a>4.15、用连接查询代替子查询[建议]</h3> 
<p>MySQL如果需要在两张以上表中查询数据的话，一般有两种实现方式</p> 
<ul><li>子查询</li><li>连接查询</li></ul> 
<p>子查询：</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">order</span> <span class="token keyword">where</span> user_id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name<span class="token operator">=</span><span class="token string">'zhang'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<p>子查询可以通过in实现<br> 优点：简单<br> 缺点：MySQL执行子查询时，需要创建临时表，查询完成后再删除临时表，有一些额外开销。</p> 
<p>可以改成连接查询<br> <strong>连接查询：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> o<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">order</span> o <span class="token keyword">inner</span> <span class="token keyword">join</span> <span class="token keyword">user</span> u <span class="token keyword">on</span> o<span class="token punctuation">.</span>user_id <span class="token operator">=</span> u<span class="token punctuation">.</span>id <span class="token keyword">where</span> u<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">'zhang'</span><span class="token punctuation">;</span> 
</code></pre> 
<h3><a id="416inner_join_left_joinright_joininner_join_594"></a>4.16、inner join 、left join、right join，优先使用inner join</h3> 
<p>三种连接结果相同，优先使用inner join，如果使用left join左边表尽量小</p> 
<ul><li>inner join 内连接，只保留两张表中完全匹配的结果集</li><li>left join会返回左表所有的行，即使在右表中没有匹配的记录</li><li>right join会返回右表所有的行，即使在左表中没有匹配的记录</li></ul> 
<p><strong>理由：</strong></p> 
<ul><li>如果inner join是等值连接，返回的行数比较少，所以性能相对会好一点</li><li>同理，使用了左连接，左边表数据结果尽量小，条件尽量放到左边处理，意味着返回的行数可能比较少。这是mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优</li></ul> 
<h3><a id="417join_604"></a>4.17、join优化</h3> 
<p><img src="https://images2.imgbox.com/d3/c0/sxVC8ZqQ_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>LEFT JOIN A表为驱动表，INNER JOIN MySQL会自动找出那个数据少的表作用驱动表，RIGHT JOIN B表为驱动表。</p> 
</blockquote> 
<h4><a id="4171MySQLfull_join_609"></a>4.17.1、MySQL中没有full join，可以用以下方式来解决</h4> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> A <span class="token keyword">left</span> <span class="token keyword">join</span> B <span class="token keyword">on</span> B<span class="token punctuation">.</span>name <span class="token operator">=</span> A<span class="token punctuation">.</span>namewhere B<span class="token punctuation">.</span>name <span class="token operator">is</span> nullunion allselect <span class="token operator">*</span> <span class="token keyword">from</span> B<span class="token punctuation">;</span>
</code></pre> 
<h4><a id="4172inner_joinleft_join_613"></a>4.17.2、尽量使用inner join，避免left join</h4> 
<p>参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。</p> 
<h4><a id="4173_616"></a>4.17.3、合理利用索引</h4> 
<p>被驱动表的索引字段作为on的限制字段。</p> 
<h4><a id="4174_619"></a>4.17.4、利用小表去驱动大表</h4> 
<p><img src="https://images2.imgbox.com/83/8f/v2xXkvqV_o.jpg" alt="在这里插入图片描述"><br> 从原理图能够直观的看出如果能够减少驱动表的话，减少嵌套循环中的循环次数，以减少 IO 总量及CPU运算的次数。</p> 
<h4><a id="4175STRAIGHT_JOIN_623"></a>4.17.5、巧用STRAIGHT_JOIN</h4> 
<p>inner join是由MySQL选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有group by、order by等「Using filesort」、「Using temporary」时。STRAIGHT_JOIN来强制连接顺序，在STRAIGHT_JOIN左边的表名就是驱动表，右边则是被驱动表。在使用STRAIGHT_JOIN有个前提条件是该查询是内连接，也就是inner join。其他连接不推荐使用STRAIGHT_JOIN，否则可能造成查询结果不准确。<br> <img src="https://images2.imgbox.com/50/f8/tQgwKtxk_o.jpg" alt="在这里插入图片描述"><br> 这个方式有时能减少3倍的时间。</p> 
<h3><a id="418in_628"></a>4.18、in子查询的优化</h3> 
<p>日常开发实现业务需求可以有两种方式实现：</p> 
<ul><li>一种使用数据库SQL脚本实现</li><li>一种使用程序实现</li></ul> 
<p>需求：查询所有部门的所有员工</p> 
<pre><code class="prism language-sql"><span class="token comment">#in子查询</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tb_user <span class="token keyword">WHERE</span> dept_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> tb_dept<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#这样写等价于：</span>

<span class="token comment">#先查询部门表</span>
<span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> tb_dept

<span class="token comment">#再由部门dept_id，查询tb_user的员工</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tb_user u<span class="token punctuation">,</span>tb_dept d <span class="token keyword">WHERE</span> u<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> d<span class="token punctuation">.</span>id
</code></pre> 
<p>假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下程序实现，可以抽象成这样的一个嵌套循环：</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span> resultSet<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token class-name">B</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token class-name">A</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token operator">==</span><span class="token class-name">B</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      resultSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的需求使用SQL就远不如程序实现，特别当数据量巨大时。<br> 理由：</p> 
<ul><li>数据库最费劲的就是程序链接的释放。假设链接了两次，每次做上百万次的数据集查询，查完就结束，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，就会额外花费很多实际，这样系统就受不了了，慢，卡顿</li></ul> 
<h3><a id="419SQLIN_662"></a>4.19、SQL语句中IN包含的值不应过多</h3> 
<p>MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。</p> 
<p>例如：select id from t where num in(1,2,3) 对于连续的数值，能用between就不要用in了；再或者使用连接来替换。</p> 
<h3><a id="420union_allunion_667"></a>4.20、尽量使用union all替代union</h3> 
<p><strong>反例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student
</code></pre> 
<p><strong>正例：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student
<span class="token keyword">UNION</span> <span class="token keyword">ALL</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student
</code></pre> 
<p><strong>理由：</strong></p> 
<ul><li>union和union all的区别是，union会自动去掉多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复</li><li>union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序</li><li>union在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION</li></ul> 
<h3><a id="421inexistsnot_innot_exists_685"></a>4.21、区分in和exists、not in和not exists</h3> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 表A <span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> 表B<span class="token punctuation">)</span>
</code></pre> 
<p>上面SQL语句相当于</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 表A <span class="token keyword">where</span> <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 表B <span class="token keyword">where</span> 表B<span class="token punctuation">.</span>id<span class="token operator">=</span>表A<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
</code></pre> 
<p>区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</p> 
<p>关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。如何高效的写出一个替代not exists的SQL语句？</p> 
<p><strong>原SQL语句：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> colname … <span class="token keyword">from</span> A表 <span class="token keyword">where</span> a<span class="token punctuation">.</span>id <span class="token operator">not</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> b<span class="token punctuation">.</span>id <span class="token keyword">from</span> B表<span class="token punctuation">)</span>
</code></pre> 
<p><strong>高效的SQL语句：</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> colname … <span class="token keyword">from</span> A表 <span class="token keyword">Left</span> <span class="token keyword">join</span> B表 <span class="token keyword">on</span> <span class="token keyword">where</span> a<span class="token punctuation">.</span>id <span class="token operator">=</span> b<span class="token punctuation">.</span>id <span class="token keyword">where</span> b<span class="token punctuation">.</span>id <span class="token operator">is</span> <span class="token boolean">null</span>
</code></pre> 
<p>取出的结果集如下图表示，A表不在B表中的数据<br> <img src="https://images2.imgbox.com/27/c3/LeJjD3Xv_o.jpg" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/47f16f6fb81ff15c8bd1a1e83348ea5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ClickHouse安装（单机版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df9471304d3f2add4e1dfa91aa3f31f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Codeforces Round #849 (Div. 4)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>