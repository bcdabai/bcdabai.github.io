<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>1.基于正点原子STM32F103外部中断实验（HAL库实现）（cubeMX） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="1.基于正点原子STM32F103外部中断实验（HAL库实现）（cubeMX）" />
<meta property="og:description" content="目录
1.简介
2.配置STM32cubeMX
1.新建文件，芯片选型
2.sys设置和RCC设置
3.配置GPIO输出 4.配置中断输入并开启中断
5.配置时钟
6.设置项目名称以及代码生成设置
3.Keil5里面打开工程并且编写程序
1.简介 这里单片机型号是正点原子F103ZET6精英板，keil5的版本是V5.14，cubeMX的版本是6.6.1
对于STM32的外部中断，中断请求源是外部的IO信号，而产生中断的方法就是通过外部IO口的电平变化，但是值得注意的是，STM32的每个IO口都可以作为外部中断的输入口。STM32F103 的中断控制器支持 19 个外部中断/事件请求，每个中断设有状态位，每个中断/事件都有独立的触发和屏蔽设置，STM32F103 的 19 个外部中断为：
EXTI 线 0~15：对应外部 IO 口的输入中断。
EXTI 线 16：连接到 PVD 输出。
EXTI 线 17：连接到 RTC 闹钟事件。
EXTI 线 18：连接到 USB 唤醒事件。
EXTI 线 19：连接到以太网唤醒事件。
这是GPIO和中断线的映射关系，可以看出每一个GPIO组的编号相同的IO口被分配在同一根中断线上，但是中断线每次只能连接一个IO口，所以我们要根据要求来判断中断线具体在哪一个IO口上。
硬件的使用不过多介绍，这里我们使用的是中断来检测按键， KEY0控制 DS0，按一次亮，再按一次灭；KEY1 控制 DS1，效果同上；WK_UP 则控制蜂鸣器。
引脚对应关系：
PB5-DS0 （低电平亮）
PE5-DS1 （低电平亮）
PB8-BEEP （高电平发声）
PE4-KEY0 （低电平有效）
PE3-KEY1 （低电平有效）
PA0-WK_UP （高电平有效）
2.配置STM32cubeMX 1.新建文件，芯片选型 选好之后点击Start Project,创建工程模板
2.sys设置和RCC设置 3.配置GPIO输出 注意:都要设置成推挽输出模式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/afe290e52930426ac9459843270f1ea8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-01T01:29:47+08:00" />
<meta property="article:modified_time" content="2022-09-01T01:29:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">1.基于正点原子STM32F103外部中断实验（HAL库实现）（cubeMX）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p></p> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="1.%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#1.%E7%AE%80%E4%BB%8B" rel="nofollow">1.简介</a></p> 
 <p id="2.%E9%85%8D%E7%BD%AESTM32cubeMX-toc" style="margin-left:40px;"><a href="#2.%E9%85%8D%E7%BD%AESTM32cubeMX" rel="nofollow">2.配置STM32cubeMX</a></p> 
 <p id="1.%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%EF%BC%8C%E8%8A%AF%E7%89%87%E9%80%89%E5%9E%8B-toc" style="margin-left:80px;"><a href="#1.%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%EF%BC%8C%E8%8A%AF%E7%89%87%E9%80%89%E5%9E%8B" rel="nofollow">1.新建文件，芯片选型</a></p> 
 <p id="2.sys%E8%AE%BE%E7%BD%AE%E5%92%8CRCC%E8%AE%BE%E7%BD%AE-toc" style="margin-left:80px;"><a href="#2.sys%E8%AE%BE%E7%BD%AE%E5%92%8CRCC%E8%AE%BE%E7%BD%AE" rel="nofollow">2.sys设置和RCC设置</a></p> 
 <p id="%C2%A03.%E9%85%8D%E7%BD%AEGPIO%E8%BE%93%E5%87%BA%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A03.%E9%85%8D%E7%BD%AEGPIO%E8%BE%93%E5%87%BA%C2%A0" rel="nofollow">3.配置GPIO输出 </a></p> 
 <p id="4.%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%AD%E8%BE%93%E5%85%A5%E5%B9%B6%E5%BC%80%E5%90%AF%E4%B8%AD%E6%96%AD-toc" style="margin-left:80px;"><a href="#4.%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%AD%E8%BE%93%E5%85%A5%E5%B9%B6%E5%BC%80%E5%90%AF%E4%B8%AD%E6%96%AD" rel="nofollow">4.配置中断输入并开启中断</a></p> 
 <p id="%C2%A05.%E9%85%8D%E7%BD%AE%E6%97%B6%E9%92%9F-toc" style="margin-left:80px;"><a href="#%C2%A05.%E9%85%8D%E7%BD%AE%E6%97%B6%E9%92%9F" rel="nofollow">5.配置时钟</a></p> 
 <p id="%C2%A06.%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%AE%BE%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%C2%A06.%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%AE%BE%E7%BD%AE" rel="nofollow">6.设置项目名称以及代码生成设置</a></p> 
 <p id="%C2%A03.Keil5%E9%87%8C%E9%9D%A2%E6%89%93%E5%BC%80%E5%B7%A5%E7%A8%8B%E5%B9%B6%E4%B8%94%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%C2%A03.Keil5%E9%87%8C%E9%9D%A2%E6%89%93%E5%BC%80%E5%B7%A5%E7%A8%8B%E5%B9%B6%E4%B8%94%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F" rel="nofollow"> 3.Keil5里面打开工程并且编写程序</a></p> 
 <hr id="hr-toc"> 
 <p></p> 
</blockquote> 
<p class="img-center"><img alt="" height="109" src="https://images2.imgbox.com/a1/00/XDqjVVd7_o.png" width="460"></p> 
<p></p> 
<h3 id="1.%E7%AE%80%E4%BB%8B">1.简介</h3> 
<blockquote> 
 <p>这里单片机型号是正点原子F103ZET6精英板，keil5的版本是V5.14，cubeMX的版本是6.6.1</p> 
</blockquote> 
<p id="1.%E7%AE%80%E4%BB%8B%EF%BC%9A">对于STM32的外部中断，中断请求源是外部的IO信号，而产生中断的方法就是通过外部IO口的电平变化，但是值得注意的是，STM32的每个IO口都可以作为外部中断的输入口。STM32F103 的中断控制器支持 19 个外部中断/事件请求，每个中断设有状态位，每个中断/事件都有独立的触发和屏蔽设置，STM32F103 的 19 个外部中断为：</p> 
<p>EXTI 线 0~15：对应外部 IO 口的输入中断。</p> 
<p>EXTI 线 16：连接到 PVD 输出。</p> 
<p>EXTI 线 17：连接到 RTC 闹钟事件。</p> 
<p>EXTI 线 18：连接到 USB 唤醒事件。</p> 
<p>EXTI 线 19：连接到以太网唤醒事件。</p> 
<p class="img-center"><img alt="" height="377" src="https://images2.imgbox.com/cf/42/UaFGKeAS_o.png" width="329"></p> 
<p>    这是GPIO和中断线的映射关系，可以看出每一个GPIO组的编号相同的IO口被分配在同一根中断线上，但是中断线每次只能连接一个IO口，所以我们要根据要求来判断中断线具体在哪一个IO口上。</p> 
<blockquote> 
 <p>    硬件的使用不过多介绍，这里我们使用的是中断来检测按键， KEY0控制 DS0，按一次亮，再按一次灭；KEY1 控制 DS1，效果同上；WK_UP 则控制蜂鸣器。</p> 
 <p>引脚对应关系：</p> 
 <p>PB5-DS0       （低电平亮）</p> 
 <p>PE5-DS1       （低电平亮）</p> 
 <p>PB8-BEEP    （高电平发声）</p> 
 <p>PE4-KEY0    （低电平有效）</p> 
 <p>PE3-KEY1    （低电平有效）</p> 
 <p>PA0-WK_UP （高电平有效）</p> 
</blockquote> 
<p></p> 
<h3 id="2.%E9%85%8D%E7%BD%AESTM32cubeMX">2.配置STM32cubeMX</h3> 
<h4 id="1.%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%EF%BC%8C%E8%8A%AF%E7%89%87%E9%80%89%E5%9E%8B">1.新建文件，芯片选型</h4> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/63/8e/JBWEqPzv_o.png" width="1200"></p> 
<p> 选好之后点击Start Project,创建工程模板</p> 
<h4 id="2.sys%E8%AE%BE%E7%BD%AE%E5%92%8CRCC%E8%AE%BE%E7%BD%AE">2.sys设置和RCC设置</h4> 
<p class="img-center"><img alt="" height="453" src="https://images2.imgbox.com/6b/2c/pV2A43r3_o.png" width="484"></p> 
<p></p> 
<p class="img-center"><img alt="" height="496" src="https://images2.imgbox.com/7c/1c/jq5xLcMn_o.png" width="493"></p> 
<h4 id="%C2%A03.%E9%85%8D%E7%BD%AEGPIO%E8%BE%93%E5%87%BA%C2%A0">3.配置GPIO输出 </h4> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/73/95/sTOqpYB1_o.png" width="1200"></p> 
<p> 注意:都要设置成推挽输出模式</p> 
<h4 id="4.%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%AD%E8%BE%93%E5%85%A5%E5%B9%B6%E5%BC%80%E5%90%AF%E4%B8%AD%E6%96%AD">4.配置中断输入并开启中断</h4> 
<p class="img-center"><img alt="" height="884" src="https://images2.imgbox.com/0c/fb/ycDMQG1c_o.png" width="1200"></p> 
<p>注意：KEY0和KEY1设置成下降沿触发，上拉电阻，WK_UP设置成上升沿触发，下拉电阻 </p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/73/58/YmnqoEBc_o.png" width="1200"></p> 
<p style="text-align:center;"></p> 
<h4 id="%C2%A05.%E9%85%8D%E7%BD%AE%E6%97%B6%E9%92%9F">5.配置时钟</h4> 
<p>如图，配置为最大的72MHz</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/3a/b7/p5wfct99_o.png" width="1200"></p> 
<h4 id="%C2%A06.%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%AE%BE%E7%BD%AE">6.设置项目名称以及代码生成设置</h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/45/9b/mXgJussp_o.png" width="1200"> <img alt="" height="842" src="https://images2.imgbox.com/2a/5c/wlTCMacE_o.png" width="1200"></p> 
<blockquote> 
 <p>勾上这个选项代码更加的简洁分明 ，然后生成代码</p> 
</blockquote> 
<h3 id="%C2%A03.Keil5%E9%87%8C%E9%9D%A2%E6%89%93%E5%BC%80%E5%B7%A5%E7%A8%8B%E5%B9%B6%E4%B8%94%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F"> 3.Keil5里面打开工程并且编写程序</h3> 
<p>keil5打开的时候如图：</p> 
<p><img alt="" height="864" src="https://images2.imgbox.com/2f/2c/RfZmSRr8_o.png" width="783"></p> 
<p>中断触发后在HAL里调用顺序是这样子的：<br>  </p> 
<pre><code class="language-cs">EXTI？_？_IRQHandler --&gt; HAL_GPIO_EXTI_IRQHandler --&gt; HAL_GPIO_EXTI_Callback</code></pre> 
<p></p> 
<blockquote> 
 <p>基本上每一个外设都有一个中断公共处理程序（<code>HAL_GPIO_EXTI_IRQHandler）</code>，我们需要在中断服务程序中调用它，这个中断公共处理程序会根据外设寄存器中的各个标志位分析产生中断的原因，然后进一步调用中断回调函数（<code>HAL_GPIO_EXTI_Callback</code>）</p> 
</blockquote> 
<p><img alt="" height="1128" src="https://images2.imgbox.com/60/c2/JQ3snMxG_o.png" width="1200"></p> 
<p> 由上图，我们在stm32f1xx_hal.c这个里面通过Ctrl+F搜索到相关函数进一步查看中断的触发程序</p> 
<p>代码如下：</p> 
<p></p> 
<pre><code class="language-cs">void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)//这个宏函数可以获取相应IO口的某个状态，所以就可以判断是不是GPIO_PIN引发的中断
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);//清除中断标志位
    HAL_GPIO_EXTI_Callback(GPIO_Pin);//调用中断回调函数
  }
}</code></pre> 
<pre><code class="language-cs">__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)</code></pre> 
<p>这里会发现回调函数前面有一个_weak的修饰，这里表示回调函数是一个弱函数，通俗表达就是系统定义了这样一个替补函数，如果用户不去定义这个函数的话，这个函数就会被编译；但是如果用户自己定义了同名，同返回值，同参数表的函数，就可以覆盖这个_weak函数，这样就可以实现函数在HAL库中先定义，并且用户还可以重写它。</p> 
<blockquote> 
 <p>这里再总结一下HAL库对于中断的完整处理过程：</p> 
 <p>1.中断请求源（如GPIO）请求中断</p> 
 <p>2.中断被触发，跳转到中断服务程序</p> 
 <p>3.中断服务程序调用中断公共处理函数</p> 
 <p>4.中断公共处理函数分析处理中断</p> 
 <p>5.处理结果就是调用公共中断回调函数1，2，3.....</p> 
</blockquote> 
<p>所以在每一次外部中断被触发，并且经过确认之后，就会调用回调函数，所以我们一般在回调函数里面编程。</p> 
<p>我们在<code>main.c</code>文件的最下方定义自己的回调函数来完成在中断中想实现的操作：</p> 
<pre><code class="language-cs">/* USER CODE BEGIN 0 */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
if(GPIO_Pin==GPIO_PIN_4 )
{
	HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_5);
}
if(GPIO_Pin==GPIO_PIN_3 )
{
	HAL_GPIO_TogglePin(GPIOE,GPIO_PIN_5);
}
if(GPIO_Pin==GPIO_PIN_0 )
{
	HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_8);
}
}

/* USER CODE END 0 */
</code></pre> 
<p>这一段代码相对来说很好理解，不过多解释。</p> 
<p></p> 
<blockquote> 
 <p>利用串口下载软件Flymcu烧录到开发板上，按下复位键，刚开始是所有的灯都亮了，蜂鸣器也在发声，按下那三个按键，这样就实现了上面所说的功能：</p> 
 <p>KEY0按一次红灯亮，再按一次灭；</p> 
 <p>KEY1 控制 绿灯，效果同上；</p> 
 <p>WK_UP 则控制蜂鸣器，也是一下响，一下停。</p> 
</blockquote> 
<p>附上main.c代码：</p> 
<pre><code class="language-cs">/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
if(GPIO_Pin==GPIO_PIN_4 )
{
	HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_5);
}
if(GPIO_Pin==GPIO_PIN_3 )
{
	
	HAL_GPIO_TogglePin(GPIOE,GPIO_PIN_5);
}
if(GPIO_Pin==GPIO_PIN_0 )
{
	
	HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_8);
}
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV2;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d2271a7cce908339b4cda34a33a0191/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">socket编程之socket()</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a2df1e2a73671131043a79e72bfd4ace/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js原生xhr获取响应头中数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>