<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Unity学习笔记】TextMeshPro文档(一) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Unity学习笔记】TextMeshPro文档(一)" />
<meta property="og:description" content="本人英语渣渣翻译，稍微删减了些自认为可以忽视的部分，原文地址 http://digitalnativestudios.com/textmeshpro/docs/textmeshpro-component/
Text Objects 提供了两个TextMesh Pro物体，一个用于Unity UI，另一个是用于3D场景。二者功能大体相同，但也有少许区别。本文使用用于UI那个来描述功能，也会指出二者的不同。
1 Text Objects 你可以通过GameObject&gt;UI&gt;Text-TextMeshPro来添加该UI物体。和其它UI物体一样，这个新物体也有Transform和Canvas Renderer组件，然后你就可以通过Text Mesh Pro组件来管理文本，你也可以将此组件添加到其它游戏物体中，它会自动的添加必要的属性。
1.1 UI Material 在Inspector面板也能看到渲染文本所用的material。通常情况下，UI物体是不会用这方式显示它们的material的，因为它们没有Mesh Renderer组件。在这里，它实际是inspector面板的一部分。如果你给这个物体添加更多的组件，它们会显示到material的下面，除非你改变它们的排序。（但是我没看到这种现象，可能版本更新了？）
通过这个material可以很方便的访问文本的材质。但是，它不允许UI物体的Material属性设置动画，这是Unity的UI解决方案的限制。
1.2 3D Text Object 3D物体通过GameObject&gt;3D Object&gt;Text-TextMeshPro来创建。创建的文本是平的，看起来就和UI文本一样。但是它是单独存在于游戏场景中的，而不是Canvas的子物体。（它和3D游戏物体一样，可以在3D空间中旋转缩放移动）
在这里，该物体有它自己的Mesh Renderer组件，Material属性也被显示得很好，并且material属性可以动画化。另外，尽管它是3D物体，但依然使用的是Rect Transform组件。
2 Text Input Box 文本输入框是用来输入文字的
2.1Right-to-left Mode 你可以勾选Enable RTL Editor单选框转换为从右到左的文本排列方式（相当于把字符的显示顺序颠倒，abc显示为cba），文本在显示前会将字符顺序颠倒过来。勾选后，Inspector面板上会多出一个RTL Text Input输入框，可以直接编辑已经反顺序的文字。
RTL模式仅仅是反转文本顺序，其它不变。
3 Main Settings 关于字体、字体风格、对齐方式等的设置
3.1 Font Asset TextMesh Pro使用它自己的字体资产(Font Asset)，你可以通过Font Asset Creator面板进行创建。默认使用的是LiberationSans SDF。
3.2 Material Preset 材质预设。每个字体资产都有默认的材质，你也可以为它创建自定义的材质。你可以使用这个下拉列表快速切换。
这个列表中的材质是通过搜索 名称中包含对应字体名字并且使用对应的字体图集纹理的材质 添加的。
3.3 Font Style 有七种字体风格供你选择。如果你想让其中部分文字效果不同，可以使用富文本（rich text）标签
前俩选项是粗体和斜体，它们的外观依赖字体资产（Font Asset）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3f4001779fbb07c0e13d8a91ece1054c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-28T17:15:01+08:00" />
<meta property="article:modified_time" content="2021-05-28T17:15:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Unity学习笔记】TextMeshPro文档(一)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本人英语渣渣翻译，稍微删减了些自认为可以忽视的部分，原文地址 <a href="http://digitalnativestudios.com/textmeshpro/docs/textmeshpro-component/" rel="nofollow">http://digitalnativestudios.com/textmeshpro/docs/textmeshpro-component/</a></p> 
<h2><a id="Text_Objects_2"></a>Text Objects</h2> 
<p>提供了两个TextMesh Pro物体，一个用于Unity UI，另一个是用于3D场景。二者功能大体相同，但也有少许区别。本文使用用于UI那个来描述功能，也会指出二者的不同。</p> 
<h3><a id="1_Text_Objects_5"></a>1 Text Objects</h3> 
<p>你可以通过GameObject&gt;UI&gt;Text-TextMeshPro来添加该UI物体。和其它UI物体一样，这个新物体也有Transform和Canvas Renderer组件，然后你就可以通过Text Mesh Pro组件来管理文本，你也可以将此组件添加到其它游戏物体中，它会自动的添加必要的属性。<br> <img src="https://images2.imgbox.com/58/5b/suwRu5ax_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="11_UI_Material_9"></a>1.1 UI Material</h4> 
<p>在Inspector面板也能看到渲染文本所用的material。通常情况下，UI物体是不会用这方式显示它们的material的，因为它们没有Mesh Renderer组件。在这里，它实际是inspector面板的一部分。如果你给这个物体添加更多的组件，它们会显示到material的下面，除非你改变它们的排序。（但是我没看到这种现象，可能版本更新了？）</p> 
<p>通过这个material可以很方便的访问文本的材质。但是，它不允许UI物体的Material属性设置动画，这是Unity的UI解决方案的限制。</p> 
<h4><a id="12_3D_Text_Object_14"></a>1.2 3D Text Object</h4> 
<p>3D物体通过GameObject&gt;3D Object&gt;Text-TextMeshPro来创建。创建的文本是平的，看起来就和UI文本一样。但是它是单独存在于游戏场景中的，而不是Canvas的子物体。（它和3D游戏物体一样，可以在3D空间中旋转缩放移动）<br> <img src="https://images2.imgbox.com/a0/b9/Zi5okEsU_o.png" alt="在这里插入图片描述"><br> 在这里，该物体有它自己的Mesh Renderer组件，Material属性也被显示得很好，并且material属性可以动画化。另外，尽管它是3D物体，但依然使用的是Rect Transform组件。</p> 
<h3><a id="2_Text_Input_Box_20"></a>2 Text Input Box</h3> 
<p>文本输入框是用来输入文字的<br> <img src="https://images2.imgbox.com/f1/38/cJ38kfSp_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="21Righttoleft_Mode_23"></a>2.1Right-to-left Mode</h4> 
<p>你可以勾选Enable RTL Editor单选框转换为从右到左的文本排列方式（相当于把字符的显示顺序颠倒，abc显示为cba），文本在显示前会将字符顺序颠倒过来。勾选后，Inspector面板上会多出一个RTL Text Input输入框，可以直接编辑已经反顺序的文字。<br> <img src="https://images2.imgbox.com/c3/ea/VyapfIxj_o.png" alt="在这里插入图片描述"><br> RTL模式仅仅是反转文本顺序，其它不变。</p> 
<h3><a id="3_Main_Settings_28"></a>3 Main Settings</h3> 
<p>关于字体、字体风格、对齐方式等的设置<br> <img src="https://images2.imgbox.com/bb/77/e9eBcqb8_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="31_Font_Assethttpsimgblogcsdnimgcn20210524210341885png_31"></a>3.1 Font Asset<img src="https://images2.imgbox.com/40/a3/Fjqmilwc_o.png" alt="在这里插入图片描述"></h4> 
<p>TextMesh Pro使用它自己的字体资产(Font Asset)，你可以通过Font Asset Creator面板进行创建。默认使用的是LiberationSans SDF。</p> 
<h4><a id="32_Material_Preset_34"></a>3.2 Material Preset</h4> 
<p><img src="https://images2.imgbox.com/f3/b8/WtkhMWdd_o.png" alt="在这里插入图片描述"></p> 
<p>材质预设。每个字体资产都有默认的材质，你也可以为它创建自定义的材质。你可以使用这个下拉列表快速切换。</p> 
<p>这个列表中的材质是通过搜索 名称中包含对应字体名字并且使用对应的字体图集纹理的材质 添加的。</p> 
<h4><a id="33_Font_Stylehttpsimgblogcsdnimgcn20210524210310392png_41"></a>3.3 Font Style<img src="https://images2.imgbox.com/b6/de/EuTe23gr_o.png" alt="在这里插入图片描述"></h4> 
<p>有七种字体风格供你选择。如果你想让其中部分文字效果不同，可以使用富文本（rich text）标签</p> 
<p>前俩选项是粗体和斜体，它们的外观依赖字体资产（Font Asset）。</p> 
<p>接着那俩是underlie和strikethrough表示下划线和删除线，效果就是在字体下面或者中间加一条横线。</p> 
<p>最后三是用来设置字母大小写的，功能分别是：小写，大写，和小写字母尺寸一样大的大写</p> 
<p>前四个可以随意选择，最后三同一时刻只能选一个。</p> 
<h4><a id="34_Font_Size_52"></a>3.4 Font Size</h4> 
<p><img src="https://images2.imgbox.com/b9/af/hdubN5s5_o.png" alt="在这里插入图片描述"><br> font size决定字符的大小，你可以使用固定大小，也可以使用自适应大小。</p> 
<p>当auto size勾选时，可以指定字符的最小和最大值。Text Mesh Pro将会自动计算，找到最适合的大小，确定的大小会显示在Font Size输入框中。</p> 
<p>WD%<br> WD%包含一个百分比值，表示控制最大的字符的宽度减少百分比。这会水平的挤压字符，使它们更高，通常只适用于数字。</p> 
<p>你还可以通过修改Line来减少行高从而适应更大的字体大小。</p> 
<p>当勾选了auto size，会花很多时间去计算字符合适的大小。所以只在必要的时候勾选它，并且要避免对频繁改变的动态文字使用此项。如果你的文本从不改变，你可以勾选此项，记住计算出的字体大小，然后取消勾选，并手动填入刚刚计算出的值。</p> 
<h4><a id="35_Vertex_Color_66"></a>3.5 Vertex Color</h4> 
<p><img src="https://images2.imgbox.com/f6/05/9ii8gI0D_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/a6/53/hKgRKA3V_o.png" alt="在这里插入图片描述"><br> Vertex Color用于为文本着色。除了使用统一颜色外，你也可以勾选Color Gradien从而对文本使用颜色渐变。（通过Color Mode，我们可以切换渐变颜色的个数）Four Corners Gradient表示为每个字符的四个角各选择一个颜色，然后进行渐变。可以为每个TextMesh Pro物体单独手动设置，也可以通过指定gradient preset来快速设置。</p> 
<p>这里的渐变颜色会与前面的Vertex Color相乘，所以如果想看原始渐变，就让Vertex Color颜色为白色。</p> 
<p>如果勾选了override tags，那么rich text的颜色会被忽视。</p> 
<h4><a id="36_Spacing_Options_75"></a>3.6 Spacing Options</h4> 
<p><img src="https://images2.imgbox.com/36/cd/nVndGksg_o.png" alt="在这里插入图片描述"><br> 字符之间、单词之间、行之间、段落之间的间距都可以修改。段落由换行符确定。你可以为每个TextMesh Pro单独设置，而不用调整字体资产（Font Asset）。</p> 
<p>这些设置也可以通过富文本（rich text）修改。</p> 
<h4><a id="37_Alignment_81"></a>3.7 Alignment</h4> 
<p><img src="https://images2.imgbox.com/1f/02/q7iXILbg_o.png" alt="在这里插入图片描述"><br> 文本对齐方式，分成了水平和垂直两组。</p> 
<h5><a id="371_Horizontal_85"></a>3.7.1 Horizontal</h5> 
<p>水平方向有四种对齐方式（实际上现在有六种），left、center、right模式控制行的对齐方式。不会改变行的内容，只改变行的位置。下面三图分别是lefr、center、right<br> <img src="https://images2.imgbox.com/13/14/z3We9pXB_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a8/14/NrWA2oBL_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/65/12/IfJYJ0X3_o.png" alt="在这里插入图片描述"><br> justify模式不会拉伸字符，而是会修改字符之间和单词之间的距离，从而让字符填充一整行。Wrap Mix的滑动条控制额外间距的比例。（要超过一行才能看到效果）<br> <img src="https://images2.imgbox.com/21/1a/oG9TjFPp_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="372_Vertical_92"></a>3.7.2 Vertical</h5> 
<p>垂直方向上一共有六种对齐方式，其中前三种Top、Middle、Bottom类似前面横向对齐方式的前三个，只不过是垂直的。</p> 
<p>第四个方式是baseline，它会调整内容的位置，从而让文本的第一行的基准线（应该是下划线位置）对齐文本显示区域的中间。</p> 
<p>第五个方式是midlie，它像是中线对齐，但是使用的是文本的网格边界来确定垂直位置，而不是行度量。“这在空间狭小的情况下很有用，否则上升和下降会延伸得太远。（百度翻译）”</p> 
<p>最后一个方式是capline，它和baseline方式差不多，只不过是用文本第一行的中间对齐文本显示区域的中间。</p> 
<h4><a id="38_Wrapping__Overflow_101"></a>3.8 Wrapping &amp; Overflow</h4> 
<p>当Wrapping设为Enabled，这可以确保文字不会显示到文本显示区域的外面（就是自动换行嘛）。对于单词也会正常换行，除非一个单词的就已经比一行的宽度要长。</p> 
<p>overflow属性决定文本比显示区域长的情况。overflow模式表示文本会延申到显示区域外面。Elipsis模式会把显示区域外的文字裁切掉（不显示）并在显示区域内文字末尾加上三个点…来表示有文字省略了。Truncate模式就是简单的把显示区域外卖的文字裁切掉。下图分别时Overflow、Ellipsis和truncate的图示：<br> <img src="https://images2.imgbox.com/e5/ef/FARAsBbW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/02/86/F14XD2WU_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d7/4c/hpx2YKHZ_o.png" alt="在这里插入图片描述"><br> Page模式会将文本划分为几页，你可以选择要显示哪一页。由于页面是单独显示的，所以垂直对齐按每页进行。也可以使用富文本手动插入分页符<br> <img src="https://images2.imgbox.com/45/d1/vJkrm0SH_o.png" alt="在这里插入图片描述"><br> Masking模式将会将文本按类似overflow的方式渲染，但是所有在显示区域外的文字会被shader隐藏，这只对UI物体有效，对3D物体无效。<br> Scroll Rect也有类似的用途，但不推荐使用。</p> 
<h4><a id="39_UV_Mapping_114"></a>3.9 UV Mapping</h4> 
<p>可以使用支持其他纹理的着色器将图像映射到文本顶部。UV映射选项控制纹理在文本上拉伸的方式。每个维度（横、竖）可以使用不同的设置。<s>左侧选项用于X标注，右侧选项用于Y标注。</s><br> 纹理的wrap模式需要设置为repear，否则将无法正确显示。</p> 
<p>Character模式会在每个字符的sprite上面拉伸纹理，因此每个字符显示相同的图像，根据其自身的纵横比拉伸。<br> <img src="https://images2.imgbox.com/7a/61/5uSJPh2N_o.png" alt="在这里插入图片描述"><br> Line模式会拉伸纹理到一行的整个宽度和高度。<br> <img src="https://images2.imgbox.com/49/fd/FNs78R88_o.png" alt="在这里插入图片描述"><br> Paragraph会拉伸纹理到整个文本。<br> <img src="https://images2.imgbox.com/3b/5a/XcvLlQ26_o.png" alt="在这里插入图片描述"><br> Match Aspect 确保在一个维度去缩放纹理从而保持原始比例。这样可以确保纹理不会变形，纹理的映射由另一个维度控制，所以你不能将俩维度都设置为Match Aspect。<br> <img src="https://images2.imgbox.com/b1/cd/aiEiSIOc_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>UV偏移可用于调整纹理在X和Y维度上的相对位置。当这些偏移被添加到纹理坐标时，要在视觉上正向移动纹理，必须应用负偏移。</p> 
 <p>还有一个行偏移量，当使用行或段落映射时，它会添加到每个连续行的X偏移量中。你可以使用这个倾斜纹理。<br> （百度翻译，太困了，今天到此为止）</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/fd/a7/DdcRABEr_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="310_Kerning_and_Padding_133"></a>3.10 Kerning and Padding</h4> 
<p>（这一项现在已经被搬到了Extra Setting里面）</p> 
<p>Kerning控制是否使用字体的kerning data。这对没有kerning data的字体无效。<br> Extra padding最小化用于渲染字符的sprites的大小。创建几何体是为了适应可见文本，但这并不总是完美的。为精灵添加额外的填充，以防止字形在精灵的边界处被切断。</p> 
<h3><a id="4_Extra_Settings_139"></a>4 Extra Settings</h3> 
<p>这一部分包含一些杂项设置。<br> <img src="https://images2.imgbox.com/cf/e1/ph63WGoR_o.png" alt="在这里插入图片描述"><br> Margins值可以用于在文本和显示区域边界之间添加空隙。你可以设置负值，使得文字超出容器边界。你也可以在场景中通过拖动黄色矩形边上的白色小方块来调整。<br> <img src="https://images2.imgbox.com/6b/db/Ssk2KplW_o.png" alt="在这里插入图片描述"><br> 富文本（Rich text）默认是开启的，你想关就关。如果关了，富文本的标签就会作为文字显示出来。</p> 
<p>对于raycast target，如果关了，UI就会忽视鼠标和文本的交互。</p> 
<p>当Parse Escape Character开启时，就会将带有反斜杠的字符转换为特定的字符。比如\n转化为换行，\t转换为制表符，等等。注意：这是指实际的文本，比如用户的驶入。在代码中，早就被编译器转化好了。</p> 
<p>可以通过脚本去限制文本的可见字符数，这可以用于慢慢显示文本。让Visible Descender和垂直对齐方式的bottom结合使用。当启用此项时，文本显示在底部并动态随着行数的增加而往上推，当不启用时，文本是从上往下显示。（我没太懂最后这句话的意思，因为按照我的理解，好像勾不勾选此项没啥区别。）</p> 
<h4><a id="41_3D_Text_Object_153"></a>4.1 3D Text Object</h4> 
<p>对于3D物体来说，有一丢丢不同、它没有margins和raycast-target设置。（同时多了一些设置）<br> <img src="https://images2.imgbox.com/c0/9a/vllCpvRC_o.png" alt="在这里插入图片描述"><br> Sorting Layer 和Order in Layer用于对物体的渲染顺序进行微调。</p> 
<blockquote> 
 <p>Orthographic mode should be enabled when using camera-aligned text with an orthographic camera. It instructs the shader to not use any perspective correction.</p> 
</blockquote> 
<p>Orthographic模式在要让文本对齐正交摄像机时使用，它要求shader不适用任何透视矫正（因为不是很确定，就把原文放在上面）。</p> 
<p>“默认情况下，四边形用于显示字符。启用的体积设置将激活另一种模式，在这种模式下，将使用立方体。这允许体积角色渲染，但目前没有着色器支持此功能。（百度翻译，现在似乎取消了该项？）”</p> 
<h3><a id="5_Text_Container_165"></a>5 Text Container</h3> 
<p>UI text物体使用UI Canvas确定它的位置和大小，这是通过RectTransform组件控制的。<br> 虽然3D text物体也有RectTransform组件，它并没有访问canvas的布局系统，相反，它有自己的容器组件（先版本默认情况下已经看不到这个组件了）。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29622369059d53cd7a4809e0eab765f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PTA 谁先倒</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6203b9477f49b81ae54d97d7cecf913e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">647.回文子串</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>