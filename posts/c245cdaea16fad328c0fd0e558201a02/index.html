<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hibernate的查询与更新技术 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hibernate的查询与更新技术" />
<meta property="og:description" content="1．Criteria 我的理解：Criteria就是Hibernate生成的一个由根据一定约束条件查询session或数据库而得到的结果的List和一些添加约束条件的方法所组成的对象。 （1）.创建criteria：Criteria crit = session.createCriteria(MyMessage.class)àList&lt;MyMessage&gt;对象 （2）.设置结果集最大个数：crit.setMaxResults(2) （3）.查询、得到结果集：List&lt;MyMessage&gt; messages = crit.list()，list函数执行带有条件的对Criteria对象集合的查询。 注意：如果不使用crit.uniqueResult()，Criteria.list()返回的就是一个List&lt;Object[]&gt; （4）.添加约束： Criteria.add(Criterion的实现类)； 原理：org.hibernate.criterion.Restrictions利用其静态方法创建单个或多个（or、and）约束条件的组合形成SimpleExpression对象，再有Criteria的add方法添加到Criteria对象，最后有list方法执行条件查询返回查询结果。 org.hibernate.criterion.Restrictions静态方法如下： 1） 单个约束： SimpleExpression extends Criterion; public static SimpleExpression ne(String propertyName,Object value); //!= public static SimpleExpression lt(String propertyName,Object value); //&lt; public static SimpleExpression gt(String propertyName,Object value); //&gt; public static SimpleExpression le(String propertyName,Object value); //&lt;= public static SimpleExpression ge(String propertyName,Object value); //&gt;= public static SimpleExpression like(String propertyName,Object value); //like //说明：此处的value有4种情况：“%subString”、“subString%”、“%subString%”、“subString” public static SimpleExpression like(String propertyName,Object subString, MatchMode); //like //说明：subString表示匹配字符串，MatchMode也有4个常量值： MatchMode." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c245cdaea16fad328c0fd0e558201a02/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-02-02T20:03:06+08:00" />
<meta property="article:modified_time" content="2013-02-02T20:03:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hibernate的查询与更新技术</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body"> 
 <p><strong>1．Criteria</strong> </p> 
 <p><strong>我的理解：</strong>Criteria就是Hibernate生成的一个由根据一定约束条件查询session或数据库而得到的结果的List和一些添加约束条件的方法所组成的对象。 </p> 
 <p><strong>（1）.创建criteria：</strong>Criteria crit = session.<strong>createCriteria(MyMessage.class)à</strong>List&lt;MyMessage&gt;对象 </p> 
 <p><strong>（2）.设置结果集最大个数：</strong>crit.<strong>setMaxResults(2)</strong> </p> 
 <p><strong>（3）.查询、得到结果集：</strong>List&lt;MyMessage&gt; messages = crit.<strong>list()，</strong>list函数执行带有条件的对Criteria对象集合的查询。 </p> 
 <p><strong>注意：</strong>如果不使用crit.uniqueResult()，Criteria.list()返回的就是一个List&lt;Object[]&gt; </p> 
 <p><strong>（4）.添加约束：</strong> </p> 
 <p><strong>Criteria.add(Criterion的实现类)；</strong> </p> 
 <p><strong>原理：</strong>org.hibernate.criterion.Restrictions利用其静态方法创建单个或多个（or、and）约束条件的组合形成SimpleExpression对象，再有Criteria的add方法添加到Criteria对象，最后有list方法执行条件查询返回查询结果。 </p> 
 <p>org.hibernate.criterion.Restrictions静态方法如下： </p> 
 <p><strong>1） 单个约束：</strong> </p> 
 <p><strong>SimpleExpression extends Criterion;</strong> </p> 
 <p>public static <strong>SimpleExpression ne</strong>(String propertyName,Object value); <strong>//!=</strong> </p> 
 <p>public static SimpleExpression <strong>lt</strong>(String propertyName,Object value); <strong>//&lt;</strong> </p> 
 <p>public static SimpleExpression <strong>gt</strong>(String propertyName,Object value); <strong>//&gt;</strong> </p> 
 <p>public static SimpleExpression <strong>le</strong>(String propertyName,Object value); <strong>//&lt;=</strong> </p> 
 <p>public static SimpleExpression <strong>ge</strong>(String propertyName,Object value); <strong>//&gt;=</strong> </p> 
 <p>public static SimpleExpression <strong>like</strong>(String propertyName,Object value); <strong>//like</strong> </p> 
 <p><strong>//说明：</strong>此处的value有4种情况：“%subString”、“subString%”、“%subString%”、“subString” </p> 
 <p>public static SimpleExpression <strong>like</strong>(String propertyName,Object subString, MatchMode); <strong>//like</strong> </p> 
 <p><strong>//说明</strong>：subString表示匹配字符串，MatchMode也有4个常量值： </p> 
 <p>MatchMode.ANYWHERE //相当于“%subString%” </p> 
 <p>MatchMode.END; //相当于“subString%” </p> 
 <p>MatchMode.EXACT; //相当于“subString” </p> 
 <p>MatchMode.START; //相当于“%subString” </p> 
 <p><strong>2） 多个约束：</strong> </p> 
 <p><strong>LogicalExpression extends Criterion;</strong> </p> 
 <p><strong>Conjunction extends Criterion;</strong> </p> 
 <p><strong>Disjunction extends Criterion;</strong> </p> 
 <p>Criteria的add方法可以添加多个约束，默认情况下他们之间的关系是and，下面介绍多个约束之间关系不唯一的添加方法： </p> 
 <p>public static <strong>LogicalExpression and</strong>(Criterion s1, Criterion s2); <strong>//or</strong> </p> 
 <p>public static LogicalExpression <strong>or</strong>(Criterion s1, Criterion s2); <strong>//and</strong> </p> 
 <p><strong>//说明：</strong>建立两个单个约束SimpleExpression之间的or、and关系，但是<strong>该方法不常用</strong> </p> 
 <p><strong>//常用方式如下：</strong> </p> 
 <p>Conjunction conjunction =Restrictions.<em>conjunction</em>(); </p> 
 <p>conjunction.add(SimpleExpression1); </p> 
 <p>conjunction.add(SimpleExpression2); </p> 
 <p>Disjunction disjunction=Restrictions.<em>disjunction</em>(); </p> 
 <p>disjunction.add(conjunction); </p> 
 <p>disjunction.add(SimpleExpression3); </p> 
 <p><strong>3） 直接使用sql语句</strong> </p> 
 <p>Retrictions.sqlRestriction(“{alias”.name like ‘%d%’”); </p> 
 <p>Retrictions.sqlRestriction(“{alias”.name like ?”,”%d%”,new.org.hibernate.type.StringType()); </p> 
 <p><strong>//说明：</strong>这样的做法不太常用，其中{alias}就代表表明，不用替换，name是表的某个字段名，第二个方法中根据？指定参数和参数类型，多于一个使用数组代替后两个参数。 </p> 
 <p><strong>（5）.分页：</strong> </p> 
 <p>crit.<strong>setMaxResults(rows</strong>); </p> 
 <p>crit.<strong>setFirstResult((currentPage - 1) * rows)</strong>; </p> 
 <p><strong>特别说明：</strong> </p> 
 <p><strong>public</strong> String execute() <strong>throws</strong> Exception { </p> 
 <p>Session session = HibernateSessionFactory.<em>getSession</em>(); </p> 
 <p>Criteria crit = session.createCriteria(entity); </p> 
 <p>crit.setMaxResults(rows); </p> 
 <p>crit.setFirstResult((currentPage - 1) * rows); </p> 
 <p>List list = crit.list(); </p> 
 <p><strong>for</strong> (Object obj : list) { </p> 
 <p>records.add(obj); </p> 
 <p>} </p> 
 <p>session.close(); </p> 
 <p><strong>return</strong> <em>SUCCESS</em>; </p> 
 <p>} </p> 
 <p>上面这个函数可以作为通用的分页函数: </p> 
 <p>entity：表示实体全名package.Entity </p> 
 <p>rows：表示页大小 </p> 
 <p>currentPage：表示当前页码（1，2，3...） </p> 
 <p>records：是查询得到的记录集，它的getter核setter方法类型既可以是List&lt;List&lt;String&gt;也可以是List&lt;Object&gt;,客户端都可以使用row[field]读取。 </p> 
 <p>field：未知表的字段值，可以建立一个fieldList的getter方法，返回String[] field.splid(“,”)。 </p> 
 <p><strong>详见std_example（pagination）</strong> </p> 
 <p><strong>（6）</strong>.持久化<strong><em>一个</em></strong>对象<strong>：</strong> </p> 
 <p>crit.setMaxResults(1); </p> 
 <p>crit.add(Restrictions.<em>eq</em>("id", 1)); </p> 
 <p>MyMessage message = (MyMessage) crit.<strong>uniqueResult()</strong>; </p> 
 <p><strong>必须保证</strong>查询结果集只有1条或者为null,否则将会抛出一个org.hibernate.NonUniqueResultException异常 </p> 
 <p><strong>（7）.对查询结构进行排序：</strong> </p> 
 <p>crit.addOrder(org.hibernate.criterion.Order.desc("id")); </p> 
 <p>//desc表示降序，asc表示升序，都是静态方法 </p> 
 <p><strong>（8）.多个Criteria之间的关联</strong> </p> 
 <p>Criteria crit1 = session.createCriteria("entity.Order"); </p> 
 <p>Criteria crit2=crit1.createCriteria("customer"); </p> 
 <p>存在关系的两个实体之间可以建立如上关系，单独操作！ </p> 
 <p><strong>（9）.聚合和分组（集合映射操作）</strong> </p> 
 <p>Criteria.<strong>setProjection</strong>(org.hibernate.criterion.<strong>AggregateProjection对象</strong>); </p> 
 <p>org.hibernate.criterion<strong>.Projections类的静态方法</strong>可以<strong>创建</strong>AggregateProjection对象 </p> 
 <p>例如： </p> 
 <p>crit.setProjection(Projections.<em>rowCount</em>()); </p> 
 <p>Integer value=(Integer)crit.uniqueResult(); </p> 
 <p>//统计记录总数 </p> 
 <p>Projections.groupProperty("name")//按照name分组 </p> 
 <p>Projections.<em>max</em>("id")//找最大值 </p> 
 <p>Projections.<em>sum</em>("id")//计算总和 等等还有很多，具体使用时再具体统计 </p> 
 <p><strong>org.hibernate.criterion.ProjectionList//可以建立一个映射集合</strong> </p> 
 <p>ProjectionList projList=<strong>Projections.<em>projectionList</em>()</strong>; </p> 
 <p>projList.add(Projections.groupProperty("name")); </p> 
 <p>projList.add(Projections.<em>rowCount</em>()); </p> 
 <p>projList.add(Projections.<em>max</em>("id")); </p> 
 <p>crit.setProjection(projList); </p> 
 <p>List results=crit.list(); </p> 
 <p>Object array[]=(Object[])<strong>results.get(0)</strong>; </p> 
 <p><strong>特别注意</strong> </p> 
 <p><strong>1.</strong>如果不适用crit.uniqueResult(),Criteria.list()返回的就是一个List&lt; Object[]&gt; </p> 
 <p><strong>2.</strong>约束条件添加的<strong>顺序</strong>和<strong>次数</strong>不一样返回的结果也不一样，<strong>尤其是对于分组约</strong> </p> 
 <p><strong>（10）.QBE (Query By Example)</strong> </p> 
 <p><strong>org.hibernate.criterion.Example implements Criterion;</strong> </p> 
 <p><strong>原理：</strong>利用Example的静态方法create来生成一个实现了Criterion的Example对象，供Criteria查询，而前面是通过显式的约束类来生成Criterion对象，这里约束的生成多了一个<strong>通过事例提炼约束</strong>的过程。 </p> 
 <p>MyMessage message = <strong>new</strong> MyMessage(); </p> 
 <p>message.setName("gb2312中文"); </p> 
 <p>Example example = Example.<em>create</em>(message); </p> 
 <p>example.enableLike();//验证没有通过的结论：所用String使用like查询 </p> 
 <p>example.excludeProperty("id");//忽略字段id </p> 
 <p>example.excludeNone();//忽略默认值为0的字段= example.excludeZeroes(); </p> 
 <p>crit.add(example); </p> 
 <p><strong>2．Query</strong> </p> 
 <p><strong>我的理解：</strong> </p> 
 <p><strong>a.HQLàSQL</strong> </p> 
 <p>HQL(Hibernate Query Language)，HQL就像SQL一样的查询语言，不同的是SQL是针对数据库中的表的而且不区分大小写；而HQL针对的是项目中的实体对象，查询的是实体对象的成员变量，其中变量名应准确描述，关键字和SQL基本一样，也不区分大小写；可以说HQL是面向对象的。 </p> 
 <p><strong>b.QueryàCriterria</strong> </p> 
 <p>Session通过createQuery(hql查询字符串)生成Query对象，Query和Critaria类似，他是Hibernate生成的一个由根据hql语句查询session或者数据库而得到的结果的List所组成的对象。他们的不同之处在于，Query把约束条件变成了HQL语句直接访问session得到查询结果，而Criteria是通过自身提供的方法和接口先构造出约束条件然后再访问session得到查询的结果。 </p> 
 <p><strong>（1）.创建query：</strong> String hql="from MyMessage"; </p> 
 <p>Query query=session.<strong>createQuery(hql)</strong>; <strong>à</strong>List&lt;Object&gt; List&lt;Object&gt; results = query.list(); </p> 
 <p>public Query createQuery(String queryString)throws HibernateException; </p> 
 <p><strong>（2）.HQL基本语法：</strong> </p> 
 <p><strong>1）from子句 </strong>返回List&lt;Entity&gt;或者List&lt;Entity[]&gt;<strong>对象集合</strong> </p> 
 <p><strong>from MyMessage </strong>// MyMessage：实体名，经过mapping的实体或其父类 </p> 
 <p><strong>from MyMessage as m</strong> //可以简化实体名为m,其中as可以省略，建议不要省略 </p> 
 <p><strong>from entity.MyMessage as m </strong>//如果类名有冲突可以使用package.className，当类没有经过mapping映射（如父类）那么必须使用package.calssName </p> 
 <p><strong>from EntityBean as b1,EntityBean2 as b2 </strong>//from后面可以跟多个Bean,用逗号隔开 </p> 
 <p><strong>from java.lang.Object </strong>//from后面可以跟Bean的父类，查询结果是所有子类Bean集合 </p> 
 <p>如果想让hibernate生成查询相关实体Bean的SQL语句可以为相关联的实体Bean建立一个父类。 </p> 
 <p><strong>2）select子句 </strong>返回List&lt;Object&gt;或者List&lt;Object[]&gt;<strong>属性集合</strong> </p> 
 <p><strong>select name ，id</strong> from MyMessage </p> 
 <p>// select后面跟需要返回的实体属性名,多个属性之间用逗号隔开 </p> 
 <p><strong>3）where子句</strong> </p> 
 <p>select name from MyMessage <strong><em>where id&gt;5</em></strong> </p> 
 <p>select name ,id from MyMessage <strong><em>where id&gt;5 and not(name like '%e%')</em></strong> </p> 
 <p>//类似于sql的where子句，其中多个条件之间有or和and关系 </p> 
 <p><strong>4）使用命名参数</strong>（相当于sql语句中带有的？，sql也支持） </p> 
 <p>Address address = <strong>new</strong> Address(); </p> 
 <p>address.setId(2); </p> 
 <p>sql = "from Employee as e where e.address=<strong><em>:address</em></strong>"; </p> 
 <p>query = session.createQuery(sql); </p> 
 <p>query.<strong><em>setEntity("address", address)</em></strong>; </p> 
 <p>如上所示，<strong>可以为加“：”参数设置指定类型的值</strong>，甚至可以使实体类型（此时使用的是实体的主键进行的查询）。 </p> 
 <p><strong>5） order by子句和group by子句</strong>（排序和分组） </p> 
 <p>例句：from MyMessage <strong>order by</strong> id <strong>desc,</strong>name <strong> asc</strong> </p> 
 <p>select count(*) ,name from MyMessage <strong>group by</strong> name <strong>order by</strong> id <strong>desc</strong> </p> 
 <p><strong>6） 关联查询</strong> </p> 
 <p>HQL支持如下四种关联: </p> 
 <p><strong>inner join </strong>//内关联 </p> 
 <p><strong>left outer join/left join </strong>//左外关联 </p> 
 <p><strong>right outer join/right join </strong>//右外关联 </p> 
 <p><strong>注意：</strong>当使用select语句时返回List&lt;Object[]&gt;(记录.字段数组)，如果存在1:2会生成两条记录； </p> 
 <p>当仅使用from时返回对象集合List&lt;entity[])(记录=对象)，如果存在1:2会出现两条一样的记录； </p> 
 <p><strong>例如：</strong> </p> 
 <p><strong>7） 聚合函数</strong> </p> 
 <p><strong>avg(...) </strong>//求属性平均值 </p> 
 <p><strong>sum(...) </strong>//求属性的总和 </p> 
 <p><strong>min(...) </strong>//求属性的最小值 </p> 
 <p><strong>max(...) </strong>//求属性的最大值 </p> 
 <p><strong>count(...或*或distict...) </strong>//求持久化对象数 </p> 
 <p><strong>8） Update,delete和insert语句</strong> </p> 
 <p><strong>例句：update Customer set name='sun' where name='bea'</strong> </p> 
 <p><strong>delete from Customer where name='sun'</strong> </p> 
 <p><strong>insert into MyMessage(id,name) select 50 ,name from MyMessage where id=2</strong> </p> 
 <p><strong>操作流程：</strong> </p> 
 <p>Transaction tx=session.beginTransaction(); </p> 
 <p>String hql="update Customer set name='sun' where name='bea'" ; </p> 
 <p>Query query=session.createQuery(hql); </p> 
 <p><strong>int</strong> count =query.executeUpdate(); </p> 
 <p>tx.commit(); </p> 
 <p><strong>注意：</strong>1.对数据库的更删改操作需要开启一个事物 </p> 
 <p>2.insert语句不支持values操作，因此必须制定插入的位置为select </p> 
 <p><strong>（3）.命名查询（避免hql或者sql语句硬编码到类中，利用配置文件）</strong> </p> 
 <p><strong>这样做的好处</strong> </p> 
 <p><strong>1）.可以共享查询语句</strong> </p> 
 <p><strong>2）.避免修改类</strong> </p> 
 <p><strong>3）.容易整理和测试查询语句</strong> </p> 
 <p><strong>例如：</strong> </p> 
 <p>&lt;?xml version="1.0"?&gt; </p> 
 <p>&lt;!DOCTYPE hibernate-mapping PUBLIC </p> 
 <p>"-//Hibernate/Hibernate Mapping DTD 3.0//EN" </p> 
 <p>"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt; </p> 
 <p>&lt;hibernate-mapping&gt; </p> 
 <p>&lt;query name="myhql"&gt; </p> 
 <p>&lt;![CDATA[select name from MyMessage where id=:id]]&gt; </p> 
 <p>&lt;/query&gt; </p> 
 <p>&lt;sql-query name="mysql"&gt; </p> 
 <p>&lt;![CDATA[select name from t_message where id=:id]]&gt; </p> 
 <p>&lt;/sql-query&gt; </p> 
 <p>&lt;/hibernate-mapping&gt; <strong>//配置文件</strong> </p> 
 <p>Query query =session.<strong>getNamedQuery("myhql")</strong>; </p> 
 <p>query.setInteger("id", 50); </p> 
 <p><strong>Session成员：public Query getNamedQuery(String queryName) throws HibernateException;</strong> </p> 
 <p><strong>也支持SQL的原理：</strong>当session.getNamedQuery(“mysql”)时根据标签&lt;query&gt; 返回Query对象，&lt;sql-query&gt;返回SQLQuery对象，然而SQLQuery是Query的子类，因此相当于执行了session.createSQLQuery("select name from t_message where id=:id")函数。 </p> 
 <p><strong>（4）.使用SQL</strong> </p> 
 <p><strong>原理</strong> </p> 
 <p>Session成员：public SQLQuery createSQLQuery(String queryString) throws HibernateException;该成员生成SQLQuery对象，之后操作与Query基本一样，不同在于query.list()默认返回当前记录的字段值（List&lt;Object[]）而不是对象，如果想让其返回对象，需要为sql语句查询的表alias对应实体Entity,工作成员如下： </p> 
 <p>Public SQLQuery addEntity(Class entityClass); </p> 
 <p>Public SQLQuery addEntity(String slias, Calss entityCalss); </p> 
 <p>另外如果使用聚合函数返回数值结果，需要使用以下成员： </p> 
 <p>Public void addScalar(String filedName,Object Hibernate.TYPE); </p> 
 <p><strong>事例：</strong> </p> 
 <p>String sql="select * from t_message m"; </p> 
 <p>SQLQuery query=session.createSQLQuery(sql); </p> 
 <p>query.addEntity("m",MyMessage.<strong>class</strong>); ... </p> 
 <p>sql="select count(*) as c from t_message"; </p> 
 <p>query=session.createSQLQuery(sql); </p> 
 <p>query.addScalar("c",Hibernate.<em>LONG</em>); </p> 
 <p>Long count=(Long)query.uniqueResult(); ...</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c43b1f2fc9bb0ca1249c113fae3949cf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hibernate HQL基础 限定查询条件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1b75dca5c8266e6d0192476874a2c82/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JS window.open() 用法与参数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>