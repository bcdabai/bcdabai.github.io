<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>iptables封ip段 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="iptables封ip段" />
<meta property="og:description" content="linux下实用iptables封ip段的一些常见命令： 封单个IP的命令是： iptables -I INPUT -s 211.1.0.0 -j DROP 封IP段的命令是： iptables -I INPUT -s 211.1.0.0/16 -j DROP iptables -I INPUT -s 211.2.0.0/16 -j DROP iptables -I INPUT -s 211.3.0.0/16 -j DROP 封整个段的命令是： iptables -I INPUT -s 211.0.0.0/8 -j DROP 封几个段的命令是： iptables -I INPUT -s 61.37.80.0/24 -j DROP iptables -I INPUT -s 61.37.81.0/24 -j DROP 想在服务器启动自运行的话有三个方法： 1、把它加到/etc/rc.local中 2、iptables-save &gt;;/etc/sysconfig/iptables可以把你当前的iptables规则放到/etc/sysconfig/iptables中，系统启动iptables时自动执行。 3、service iptables save 也可以把你当前的iptables规则放/etc/sysconfig/iptables中，系统启动iptables时自动执行。 后两种更好此，一般iptables服务会在network服务之前启来，更安全。 解封的话： iptables -D INPUT -s IP地址 -j REJECT iptables -F 全清掉了 假如61." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0291fc9406d3dcfddc61f9af7f8b445a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-09-28T21:01:39+08:00" />
<meta property="article:modified_time" content="2011-09-28T21:01:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">iptables封ip段</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <div>
   linux下实用iptables封ip段的一些常见命令： 
  <br> 
  <br> 封单个IP的命令是： 
  <br> iptables -I INPUT -s 211.1.0.0 -j DROP 
  <br> 
  <br> 封IP段的命令是： 
  <br> iptables -I INPUT -s 211.1.0.0/16 -j DROP 
  <br> iptables -I INPUT -s 211.2.0.0/16 -j DROP 
  <br> iptables -I INPUT -s 211.3.0.0/16 -j DROP 
  <br> 
  <br> 封整个段的命令是： 
  <br> iptables -I INPUT -s 211.0.0.0/8 -j DROP 
  <br> 
  <br> 封几个段的命令是： 
  <br> iptables -I INPUT -s 61.37.80.0/24 -j DROP 
  <br> iptables -I INPUT -s 61.37.81.0/24 -j DROP 
  <br> 
  <br> 想在服务器启动自运行的话有三个方法： 
  <br> 1、把它加到/etc/rc.local中 
  <br> 2、iptables-save &gt;;/etc/sysconfig/iptables可以把你当前的iptables规则放到/etc/sysconfig/iptables中，系统启动iptables时自动执行。 
  <br> 3、service iptables save 也可以把你当前的iptables规则放/etc/sysconfig/iptables中，系统启动iptables时自动执行。 
  <br> 后两种更好此，一般iptables服务会在network服务之前启来，更安全。 
  <br> 
  <br> 解封的话： 
  <br> iptables -D INPUT -s IP地址 -j REJECT 
  <br> iptables -F 全清掉了 
  <br> 
 </div> 
 <div> 
  <div>
    假如61.158.135.96-100这些ip都是同一个网站 
   <br> 就用如下命令： 
   <br> iptable -a forward -d 61.158.135.96/29 -j drop 
   <br> 其中“/29”是子网掩码。是封了96－103的8个ip。这样就可以封了这个网站了 
   <br> 
   <br> 这种方法是有一个问题，因为一个网站的ip并不一定都在同一个网段中，所以也许会漏过该杀的，又误杀好人 
   <br> 
   <br> 可以直接封杀域名： 
   <br> iptables -A FORWARD -d 
   <a href="http://www.xxx.com/" rel="nofollow"><span style="color:#015385;font-size:x-small;">www.xxx.com</span> </a> -j drop 
   <br> 
  </div> 
 </div> 
</div> 
<p> 网上的访问通过tcp/ip封包来进入主机系统的。在linux中它一般要同过ip过滤机制来实现第一层防护，如果通过了这层防护还的通过下一关的检查 那就是TCP_Wrappers 的功能。<br> 封包过滤( IP Filter )：<br> 封包过滤是 linux 提供的第一道防火墙呦！但是不同的核心版本会有不一样的封包过滤机制！以 2.2.xx 为核心的 Linux 主要以 ipchains 作为过滤机制，至于目前新版的 2.4.xx 则以 iptables 为机制！OK！既然我们的 Red Hat 7.1, 7.2, 7.3 为 kernel 2.4.xx ，所以用 iptables 来进行 IP 抵挡的工作啦！那么由于 TCP 封包里头有 IP 及 port ，所以要抵挡来源 IP 或者是自身的 port ，自然就很容易来进行啦！您目前只要知道 iptables 可以经由 TCP 的封包表投资料来进行分析的工作例如：和附规则的就通过，否则就把它丢弃 这样就防止不符合规则的人进入你的电脑。<br> 至于抵挡封包的工作则可以让 TCP_Wrappers 来进行<br> 要常常去看 /var/log/messages 与 /var/log/secure 这两个个档案！都是登陆登录记录等。<br> 要做好主机的防护，第一步就是要建立完善的密码规则啦！因为这个咚咚常常是 cracker 尝试入侵的第一步！你必须要建立好主机的密码规则，可以尝试以 chattr 来将 /etc/passwd 及 /etc/shadow 做成不可变更的档案！较为安全啦！<br> 做好安全的几个常见的工作<br> 1.升级与修补套件漏洞、及移除危险套件：<br> 2.每项系统服务的安全设定项目<br> 3.TCP_Wrappers 的基础防火设定<br> 4.iptables 的防火规则设定<br> 5.主机资源侦测系统( MRTG )<br> 6.登录档案分析系统：<br><br> iptables：<br> iptables 是 linux Kernel 2.4.xx 版本以上的主要 IP 过滤机制！他最大的功能就是可以过滤掉不要的 TCP 封包啦！当然功能还不止于此，他还可以用来进行 IP 伪装，以达成 NAT 的主机功能呢！ iptables 的工作方向，必须要依规则的顺序来分析，底下我们简单的谈一谈 iptables 的几个概念吧：<br> 有几个 tables ：<br> 跟之前版本的 ipchains 不同的地方是， iptables 可以自行定义一些 tables 的新规定！将可以让防火墙规则变的更为便于管理呢！基本上，原本的 iptable 至少有两个 table ，一个是 filter ( 预设的，没有填写 tables 时，就是 filter 这个 table 啦 )，一个则是相当重要的 nat table 。其中， filter 可以用来管理主机的安全，至于 nat 则是用来处理 NAT 的功能啦！<br> 清除规则：<br> iptables 的订定方法其实很简单，就是使用指令列的方式来订定而已，他的基础语法在清除规则时，是这样的：<br> [root @test /root]# /sbin/iptables [-FXZ]<br> 参数说明：<br> -F ：清除所有的已订定的规则；<br> -X ：杀掉所有使用者建立的 chain (应该说的是 tables ）啰；<br> -Z ：将所有的 chain 的计数与流量统计都归零<br> 范例：<br> [root @test /root]# /sbin/iptables -F<br> [root @test /root]# /sbin/iptables -X<br> [root @test /root]# /sbin/iptables -Z<br> 请注意，如果在远程联机的时候，『这三个指令必须要用 scripts 来连续执行』，不然肯定『会让你自己被主机挡在门外！』<br> 　<br> 定义政策( Policy )：<br> 清除规则之后，再接下来就是要设定规则的政策啦！这个所谓的政策指的是『当你的封包不在你的规则之内时，则该封包的通过与否，以 Policy 的设定为准』，例如：你设定了十条规则，但有一个封包来的时候，这十条规则都不适用，这个时候此一封包就会依据 Policy 的规定为准，来决定是否可以通过防火墙啰。通常这个政策在 INPUT 方面可以定义的比较严格一点，而 FORWARD 与 OUTPUT 则可以订定的松一些！<br> [root @test /root]# /sbin/iptables [-t tables] [-P] [INPUT,OUTPUT,FORWARD| PREROUTING,OUTPUT,POSTROUTING] [ACCEPT,DROP]<br> 参数说明：<br> -t 　　：定义 table ！<br> tables ：table 的名称，例如 nat 啰！<br> -P 　　：定义政策( Policy )。<br> INPUT　：封包为输入主机的方向；<br> OUTPUT ：封包为输出主机的方向；<br> FORWARD：封包为不进入主机而向外再传输出去的方向；<br> PREROUTING ：在进入路由之前进行的工作；<br> OUTPUT　 　：封包为输出主机的方向；<br> POSTROUTING：在进入路由之后进行的工作。<br> 范例：<br> [root @test /root]# /sbin/iptables -P INPUT ACCEPT<br> [root @test /root]# /sbin/iptables -P OUTPUT ACCEPT<br> [root @test /root]# /sbin/iptables -P FORWARD ACCEPT<br> [root @test /root]# /sbin/iptables -t nat -P PREROUTING ACCEPT<br> [root @test /root]# /sbin/iptables -t nat -P OUTPUT ACCEPT<br> [root @test /root]# /sbin/iptables -t nat -P POSTROUTING ACCEPT<br> 将预设的政策都定义为接受啰！<br> 　<br> 增加、插入规则：<br> 接下来则要定义规则啦！我们底下先完全以主机的角度来观察！可以这样来设定啦！<br> [root @test /root]# /sbin/iptables [-AI] [INPUT,OUTPUT,FORWARD] [-io interface] [-p TCP,UDP] [-s IP/network] [--sport ports] [-d IP/network] [--dport ports] -j [ACCEPT,DROP]<br> 参数说明：<br> -A 　　：新增加一条规则，该规则增加在最后面一行；<br> -I　　 ：在第一条规则加入；<br> INPUT　：封包为输入主机的方向；<br> OUTPUT ：封包为输出主机的方向；<br> FORWARD：封包为不进入主机而向外再传输出去的方向；<br> -i　　　 ：流入的网卡接口<br> -o　　　　：流出的网卡接口<br> interface ：网络卡接口，例如 ppp0, eth0, eth1....<br> -p ：请注意，这是小写呦！封包的协议啦！<br> TCP ：封包为 TCP 协议的封包；<br> UDP ：封包为 UDP 协议的封包；<br> -s ：来源封包的 IP 或者是 Network ( 网域 )；<br> --sport：来源封包的 port 号码；<br> -d ：目标主机的 IP 或者是 Network ( 网域 )；<br> --dport：目标主机的 port 号码；<br> -j 　　：动作，可以接底下的动作；<br> ACCEPT ：接受该封包<br> DROP　 ：丢弃封包<br> 范例：<br> [root @test /root]# /sbin/iptables -A INPUT -i lo -j ACCEPT<br> 所有的来自 lo 这个接口的封包，都予以接受<br> [root @test /root]# /sbin/iptables -A INPUT -i eth0 -p TCP -s 192.168.0.1 -j ACCEPT<br> 来自 192.168.0.1 这个 IP 的封包都予以接受<br> [root @test /root]# /sbin/iptables -A INPUT -i eth0 -p TCP -s 192.168.1.0/24 -j ACCEPT<br> 来自 192.168.1.0 这个 C Class 的网域的任何一部计算机，就予以接受！<br> [root @test /root]# /sbin/iptables -A INPUT -i eth0 -p TCP -s 192.168.1.25 -j DROP<br> 来自 192.168.1.25 的 IP 的封包，就直接全部给他丢弃！<br> [root @test /root]# /sbin/iptables -A INPUT -i eth0 -p TCP --dport 21 -j DROP<br> 只要想要进来 21 这个 port 的封包，就把他丢弃！<br> [root @test /root]# /sbin/iptables -A INPUT -i eth0 -p TCP -s 192.168.0.24 --dport 22 -j ACCEPT<br> 来自 192.168.0.24 的主机，想要到我的 port 22 时，就予以接受！<br> 请注意：防火墙的规则是『一行一行依序来检查的，若符合任何一条规则，则予以动作(接受或丢弃)，否则继续往下检查到最后一条』上<br> TCP_Wrappers：<br> 这个 TCP_Wrappers 实在是很简单的一个设定工作，因为他只要设定 /etc/hosts.allow 及 /etc/hosts.deny 就可以啦！基本上，他是经由 /usr/sbin/tcpd 这个程序来进行 TCP 的检验工作！而检验的方式则是以 /etc/hosts.allow 及 /etc/hosts.deny 来设定的啦！检验的流程是先以 /etc/hosts.allow 这个档案，检验完之后，在到 /etc/hosts.deny 去搜寻！好了，那么 hosts.allow 要怎样设定呢？<br> &lt;服务名称&gt; : :<br> 特别注意， network 可以使用 192.168.0.0/255.255.255.0 ，但不可使用 192.168.0.0/24 ！<br> [root @test /root]# vi /etc/hosts.allow<br> in.telnetd: 127.0.0.1 : allow<br> in.ftpd: 127.0.0.1 : allow<br> 本机的 127.0.0.1 开放 telnet 及 ftp 哩！<br> [root @test /root]# vi /etc/hosts.deny<br> in.telnetd: 192.168.2.3 : deny<br> 将 192.168.2.3 的 telnet 服务关掉！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8581a33c7ae856859fee2dd4e728e6b2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Invalid location of tag (form) 的提示 原因</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90cc1707871e64c6bf56f5bb2edb5400/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Web页面标签技术的使用(收集整理）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>