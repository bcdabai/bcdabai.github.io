<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>线性表--栈 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="线性表--栈" />
<meta property="og:description" content="1.什么是栈？ 栈是一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除
操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶；
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
后进先出
2.动态栈的实现 栈可以用前面章节介绍的数组或者链表的节点实现，数组相比之下更优越一下，动态开辟内存实现扩容，且在数组尾上插入数据代价较小（链表节点还得创建next指针）。
2.1栈的形式 2.2初始化 2.3入栈 2.4出栈 直接top-1就行，如果后序入栈会直接覆盖，也不影响后续出栈，调用栈顶等操作，因为这些操作都基于top的数值来进行的。
2.5调用栈顶 2.6返回有效数据个数 2.7判断是否为空栈 2.8销毁 3.代码 //Stack.h #pragma once #define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; #include &lt;stdbool.h&gt; typedef int StackDataType; //栈（stack） typedef struct Stack { StackDataType* arr;//数据 int capacity;//容量 int top;//栈顶，top初始化为0，则top为最后一个有效数据的下一位下标；\ top初始化为-1，则为最后一个有效数据下标 }Stack; //初始化 void StackInit(Stack* ps); //销毁 void StackDestroy(Stack* ps); //入栈 void StackPush(Stack* ps, StackDataType x); //出栈 void StackPop(Stack* ps); //调用栈顶 StackDataType StackTop(Stack* ps); //返回个数 int StackSize(Stack* ps); //判断是否为空栈 bool StackEmpty(Stack* ps); //Stack." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fe808bac5ebc932b37880d2b4fbc36b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-26T23:53:01+08:00" />
<meta property="article:modified_time" content="2024-01-26T23:53:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">线性表--栈</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.什么是栈？</h2> 
<p>栈是一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除<br> 操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出的原则。</p> 
<p>压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶；<br> 出栈：栈的删除操作叫做出栈。出数据也在栈顶。</p> 
<p><strong>后进先出</strong><br><img alt="" height="894" src="https://images2.imgbox.com/af/e5/VsS1i6hM_o.png" width="1200"></p> 
<h2> 2.动态栈的实现</h2> 
<p>栈可以用前面章节介绍的数组或者链表的节点实现，数组相比之下更优越一下，动态开辟内存实现扩容，且在数组尾上插入数据代价较小（链表节点还得创建next指针）。</p> 
<p><img alt="" height="613" src="https://images2.imgbox.com/1c/43/FXBWdkYV_o.png" width="1200"></p> 
<h3 style="background-color:transparent;"> 2.1栈的形式</h3> 
<h3><img alt="" height="392" src="https://images2.imgbox.com/8b/c1/6q1pN57T_o.png" width="1200"></h3> 
<h3 style="background-color:transparent;">2.2初始化</h3> 
<p><img alt="" height="532" src="https://images2.imgbox.com/78/30/wMHQO0R0_o.png" width="1200"></p> 
<h3 style="background-color:transparent;"> 2.3入栈</h3> 
<p><img alt="" height="824" src="https://images2.imgbox.com/b3/f1/aHN4JfWa_o.png" width="1200"></p> 
<p> <img alt="" height="475" src="https://images2.imgbox.com/28/81/iCdDXHin_o.png" width="1200"></p> 
<h3 style="background-color:transparent;"> 2.4出栈</h3> 
<p><img alt="" height="319" src="https://images2.imgbox.com/64/7f/KJt1ID1p_o.png" width="550"></p> 
<p> 直接top-1就行，如果后序入栈会直接覆盖，也不影响后续出栈，调用栈顶等操作，因为这些操作都基于top的数值来进行的。</p> 
<h3 style="background-color:transparent;">2.5调用栈顶</h3> 
<p><img alt="" height="356" src="https://images2.imgbox.com/da/ca/K5A0Y0Xd_o.png" width="800"></p> 
<h3 style="background-color:transparent;"> 2.6返回有效数据个数</h3> 
<p><img alt="" height="260" src="https://images2.imgbox.com/9b/ad/7VdvruK4_o.png" width="545"></p> 
<h3 style="background-color:transparent;"> 2.7判断是否为空栈</h3> 
<p><img alt="" height="296" src="https://images2.imgbox.com/6a/d6/j2dSRKrJ_o.png" width="488"></p> 
<h3 style="background-color:transparent;"> 2.8销毁</h3> 
<h3 style="background-color:transparent;"><img alt="" height="318" src="https://images2.imgbox.com/38/0b/xbtoKZWu_o.png" width="671"></h3> 
<h2> 3.代码</h2> 
<pre><code class="language-cpp">//Stack.h

#pragma once
#define _CRT_SECURE_NO_WARNINGS 1

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;

typedef int StackDataType;
//栈（stack）
typedef struct Stack
{
	StackDataType* arr;//数据
	int capacity;//容量
	int top;//栈顶，top初始化为0，则top为最后一个有效数据的下一位下标；\
	top初始化为-1，则为最后一个有效数据下标
}Stack;

//初始化
void StackInit(Stack* ps);
//销毁
void StackDestroy(Stack* ps);
//入栈
void StackPush(Stack* ps, StackDataType x);
//出栈
void StackPop(Stack* ps);
//调用栈顶
StackDataType StackTop(Stack* ps);
//返回个数
int StackSize(Stack* ps);
//判断是否为空栈
bool StackEmpty(Stack* ps);</code></pre> 
<pre><code class="language-cpp">//Stack.c


#include "Stack.h"

//初始化
void StackInit(Stack* ps)
{
	assert(ps);
	ps-&gt;arr = (StackDataType*)malloc(sizeof(StackDataType) * 4);//初始开辟容量4个
	if (ps-&gt;arr == NULL)//开辟失败
	{
		perror("Malloc Fail!");
		exit(1);
	}
	ps-&gt;capacity = 4; // 初始开辟容量4个
	ps-&gt;top = 0;//top初始化为0，则top为最后一个有效数据的下一位下标
}
//销毁
void StackDestroy(Stack* ps)
{
	assert(ps);
	free(ps-&gt;arr);
	ps-&gt;arr = NULL;
	ps-&gt;capacity = ps-&gt;top = 0;
}
//入栈
void StackPush(Stack* ps, StackDataType x)
{
	assert(ps);
	//需要扩容
	if (ps-&gt;top == ps-&gt;capacity)
	{
		//扩容为原来2倍
		StackDataType* temp = (StackDataType*)realloc(ps-&gt;arr, ps-&gt;capacity * 2 * sizeof(StackDataType));
		if (temp == NULL)//扩容失败
		{
			perror("Realloc Fail!");
			exit(1);
		}
		ps-&gt;arr = temp;
		ps-&gt;capacity = ps-&gt;capacity * 2;
	}
	//加入数据
	ps-&gt;arr[ps-&gt;top] = x;
	ps-&gt;top++;
}
//出栈
void StackPop(Stack* ps)
{
	assert(ps);
	//栈为空不能删
	assert(ps-&gt;top &gt; 0);
	ps-&gt;top--;
}
//调用栈顶
StackDataType StackTop(Stack* ps)
{
	assert(ps);
	//栈为空不能调用
	assert(ps-&gt;top &gt; 0);

	return ps-&gt;arr[ps-&gt;top - 1];
} 
//返回个数
int StackSize(Stack* ps)
{
	assert(ps);

	return ps-&gt;top;
}
//判断是否为空栈
bool StackEmpty(Stack* ps)
{
	assert(ps);
	//真为空，假不为空
	return ps-&gt;top == 0;
}</code></pre> 
<pre><code class="language-cpp">//Test.c


#include "Stack.h"

void test1()
{
	Stack ps;
	StackInit(&amp;ps);
	StackPush(&amp;ps, 1);
	StackPush(&amp;ps, 2);
	StackPush(&amp;ps, 3);
	StackPush(&amp;ps, 4);
	StackPush(&amp;ps, 5);
	printf("%d\n", StackSize(&amp;ps));
	while (!StackEmpty(&amp;ps))
	{
		printf("%d ", StackTop(&amp;ps));
		StackPop(&amp;ps);
	}
	printf("\n%d\n", StackSize(&amp;ps));
	StackDestroy(&amp;ps);
}

int main()
{
	test1();
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/beb3df2723a62c8735098616d81bb41d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【c&#43;&#43;学习】数据结构中的栈</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4fa22ab1fd93ad914357d22b93a9c25c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">FTP主被动模式详解、FTP服务器的搭建及FileZilla的安装使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>