<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>synchronized的介绍 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="synchronized的介绍" />
<meta property="og:description" content="1.synchronized的介绍和作用 synchronized是Java编程语言中的一个关键字，用于实现线程同步。在多线程编程中，多个线程可能同时访问共享资源，而这可能导致数据不一致或其他问题。为了避免这些问题，可以使用 synchronized 关键字来确保在任何时候只有一个线程可以访问共享资源。
使用synchronized就是为了保证线程的三个特性，及原子性、可见性、有序性。原子性：一个或多个操作时，保证要么全部执行成功，要么都不执行。可见性：一个线程操作时，另外的线程可以看见，里面的数据变化情况能看见。有序性：线程安装顺序进行操作。使用锁就是为了保证线程的安全。
2.synchronized的使用 public synchronized void lock(){ //方法 } ​ public void lock() { // 一些非关键代码 ​ synchronized (lockObject) { // 需要同步的代码块 } ​ // 一些非关键代码 } synchronized可以修饰静态方法、成员函数，同时还可以直接定义代码块。
3.synchronized的底层实现 在Java虚拟机（JVM）中，对象的内存结构主要分为三部分：对象头、实例数据、对齐填充。
对象头：
存储对象自身的运行时数据，比如哈希码、垃圾回收信息、同步锁等。
不同的虚拟机实现会在对象头中存储不同的信息，例如，在HotSpot虚拟机中，对象头占用的空间大小是与平台相关的。
实例数据：
存储对象的实际数据，即类的字段内容。
对于数组类型的对象，还包括数组长度等信息。
实例数据的大小取决于对象所属的类的字段定义。
对齐填充：
由于虚拟机的内存分配规则，对象的大小通常要求是8字节的整数倍。
对齐填充用于填充对象的实例数据，以满足对齐要求，使得对象的起始地址是8字节的整数倍。
对齐填充不包含实际的数据，仅仅是为了对齐。
对象头中Mark Word是重点
监视器（Monitor）图：借图
这个是获取Monitor和释放Monitor的流程。
在jdk1.6之前synchronized被称为重量级锁，在jdk1.6之后，进行了优化，引入了偏向锁和轻量锁。
4.synchronized的优化 4.1偏向锁 原理：
当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的MarkWord之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。 好处：
偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以提高带有同步但无竞争的程序性能。 4.2轻量级锁 原理：
将对象的Mark Word复制到栈帧中的Lock Recod中。Mark Word更新为指向Lock Record的指针。 好处：
在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。 4.3自旋锁和自适应自旋锁 轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。 ​ 自旋锁：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。但是它也存在缺点：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。 ​ 自适应自旋锁：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。 参考：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2bded7344fd510e2effad24cfd500a74/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-19T19:51:36+08:00" />
<meta property="article:modified_time" content="2024-01-19T19:51:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">synchronized的介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.synchronized的介绍和作用</h2> 
<p>synchronized是Java编程语言中的一个关键字，用于实现线程同步。在多线程编程中，多个线程可能同时访问共享资源，而这可能导致数据不一致或其他问题。为了避免这些问题，可以使用 synchronized 关键字来确保在任何时候只有一个线程可以访问共享资源。</p> 
<p>使用synchronized就是为了保证线程的三个特性，及原子性、可见性、有序性。原子性：一个或多个操作时，保证要么全部执行成功，要么都不执行。可见性：一个线程操作时，另外的线程可以看见，里面的数据变化情况能看见。有序性：线程安装顺序进行操作。使用锁就是为了保证线程的安全。</p> 
<h3>2.synchronized的使用</h3> 
<pre>public synchronized void lock(){
    //方法
}
​
public void lock() {
    // 一些非关键代码
​
    synchronized (lockObject) {
        // 需要同步的代码块
    }
​
    // 一些非关键代码
}</pre> 
<p>synchronized可以修饰静态方法、成员函数，同时还可以直接定义代码块。</p> 
<h3>3.synchronized的底层实现</h3> 
<p>在Java虚拟机（JVM）中，对象的内存结构主要分为三部分：对象头、实例数据、对齐填充。</p> 
<p><img alt="" height="533" src="https://images2.imgbox.com/1c/b5/H8OPZJTK_o.png" width="395"></p> 
<p>对象头：</p> 
<ul><li> <p>存储对象自身的运行时数据，比如哈希码、垃圾回收信息、同步锁等。</p> </li><li> <p>不同的虚拟机实现会在对象头中存储不同的信息，例如，在HotSpot虚拟机中，对象头占用的空间大小是与平台相关的。</p> </li></ul> 
<p>实例数据：</p> 
<ul><li> <p>存储对象的实际数据，即类的字段内容。</p> </li><li> <p>对于数组类型的对象，还包括数组长度等信息。</p> </li><li> <p>实例数据的大小取决于对象所属的类的字段定义。</p> </li></ul> 
<p>对齐填充：</p> 
<ul><li> <p>由于虚拟机的内存分配规则，对象的大小通常要求是8字节的整数倍。</p> </li><li> <p>对齐填充用于填充对象的实例数据，以满足对齐要求，使得对象的起始地址是8字节的整数倍。</p> </li><li> <p>对齐填充不包含实际的数据，仅仅是为了对齐。</p> </li></ul> 
<p>对象头中Mark Word是重点</p> 
<p><img alt="" height="343" src="https://images2.imgbox.com/82/37/AjUnyNot_o.png" width="1200"></p> 
<p>监视器（Monitor）图：借图</p> 
<p></p> 
<p class="img-center"><img alt="image-20231130202028161" height="431" src="https://images2.imgbox.com/e8/da/1A1nIGNK_o.png" width="773"></p> 
<p>这个是获取Monitor和释放Monitor的流程。</p> 
<p>在jdk1.6之前synchronized被称为重量级锁，在jdk1.6之后，进行了优化，引入了偏向锁和轻量锁。</p> 
<h3>4.synchronized的优化</h3> 
<h4>4.1偏向锁</h4> 
<p>原理：</p> 
<pre>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的MarkWord之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</pre> 
<p>好处：</p> 
<pre>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以提高带有同步但无竞争的程序性能。</pre> 
<h4>4.2轻量级锁</h4> 
<p>原理：</p> 
<pre>将对象的Mark Word复制到栈帧中的Lock Recod中。Mark Word更新为指向Lock Record的指针。</pre> 
<p>好处：</p> 
<pre>在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</pre> 
<h4>4.3自旋锁和自适应自旋锁</h4> 
<pre>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。
​
自旋锁：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。但是它也存在缺点：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。
​
自适应自旋锁：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</pre> 
<p>参考：</p> 
<p><a href="https://www.cnblogs.com/three-fighter/p/14396208.html" rel="nofollow" title="https://www.cnblogs.com/three-fighter/p/14396208.html">https://www.cnblogs.com/three-fighter/p/14396208.html</a></p> 
<p><a href="https://cloud.tencent.com/developer/article/1465413" rel="nofollow" title="深入理解synchronized底层原理，一篇文章就够了！-腾讯云开发者社区-腾讯云">深入理解synchronized底层原理，一篇文章就够了！-腾讯云开发者社区-腾讯云</a></p> 
<p><a href="https://zhuanlan.zhihu.com/p/377423211" rel="nofollow" title="面试官：请详细说下synchronized的实现原理 - 知乎">面试官：请详细说下synchronized的实现原理 - 知乎</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5754919a42f17f46336dfa7590c93016/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">198. 打家劫舍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/75ccad47b245698963d4344bfa4bdcf0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue3中reactive和ref函数及对比</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>