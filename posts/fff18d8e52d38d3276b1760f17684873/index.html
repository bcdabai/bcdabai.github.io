<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何解决C语言浮点数精度丢失的问题？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何解决C语言浮点数精度丢失的问题？" />
<meta property="og:description" content="测试网站：C语言在线运行,代码编译测试 - 在线编译器(nhooo.com)
1.循环加数据，误差越来越大：
float a = 99.2f; //float a = 1.3f; float b = 0; for(int i =0; i&lt;1000; i&#43;&#43;){ b = b &#43; a; } for(int i =0; i&lt;10000; i&#43;&#43;){ b = b &#43; a; } printf(&#34;%f\n&#34;, a); printf(&#34;---%f\n&#34;, b); 输出：
99.199997 ---99200.695312 ---991913.875000 1000次的时候还好。
10000次的时候，误差已经到了100。
解决方法：1.转化成整数再运算；在进行大量的浮点数运算时，为了提高运算的速度和准确性，可以考虑将小数转换为整数进行计算，再将结果转换回小数。
2.看看开源代码中C语言的算法是怎么算的；
3.都转成double，这样10000次计算结果是---991999.969482。尽量避免使用float类型。虽然float类型能够节省内存空间，但是其精度不够高，容易导致精度丢失。在精度要求比较高或需要进行复杂计算时，建议使用double类型。
2.比较两个数的大小，必须用一个float.h的宏定义EPS最小误差来定。大概0.000001.精确到6位。
double test=0.1; if(fabs(test-(1-0.9))&lt;0.0001) { printf(&#34;正常&#34;); } else { printf(&#34;what!!!&#34;); } 3.C语言发送双精度到Java语言，需要精确到前两位发送。具体思路是转换成字符。
float ddd = (float)( (a&#43;0.001)*100) / 100; printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fff18d8e52d38d3276b1760f17684873/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-28T13:46:39+08:00" />
<meta property="article:modified_time" content="2023-06-28T13:46:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何解决C语言浮点数精度丢失的问题？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>测试网站：<a href="https://www.nhooo.com/tool/c/" rel="nofollow" title="C语言在线运行,代码编译测试 - 在线编译器(nhooo.com)">C语言在线运行,代码编译测试 - 在线编译器(nhooo.com)</a></p> 
<p>1.循环加数据，误差越来越大：</p> 
<pre><code class="language-cpp">float a = 99.2f;
	//float a = 1.3f;
	float b = 0;

for(int i =0; i&lt;1000; i++){
		b = b + a;
	}

for(int i =0; i&lt;10000; i++){
		b = b + a;
	}

printf("%f\n", a);
	printf("---%f\n", b);

</code></pre> 
<p>输出：</p> 
<pre><code class="language-cpp">99.199997
---99200.695312
---991913.875000
</code></pre> 
<p>1000次的时候还好。</p> 
<p>10000次的时候，误差已经到了100。</p> 
<p>解决方法：1.转化成整数再运算；在进行大量的浮点数运算时，为了提高运算的速度和准确性，可以考虑将小数转换为整数进行计算，再将结果转换回小数。</p> 
<p>2.看看开源代码中C语言的算法是怎么算的；</p> 
<p>3.都转成double，这样10000次计算结果是---991999.969482。尽量避免使用float类型。虽然float类型能够节省内存空间，但是其精度不够高，容易导致精度丢失。在精度要求比较高或需要进行复杂计算时，建议使用double类型。</p> 
<p>2.比较两个数的大小，必须用一个float.h的宏定义EPS最小误差来定。大概0.000001.精确到6位。</p> 
<pre><code class="language-cpp">double test=0.1;
    if(fabs(test-(1-0.9))&lt;0.0001)
    {
        printf("正常");
    }
    else
    {
        printf("what!!!");
    }</code></pre> 
<p>3.C语言发送双精度到Java语言，需要精确到前两位发送。具体思路是转换成字符。</p> 
<pre><code class="language-cpp">float ddd = (float)( (a+0.001)*100) / 100;
	printf("四舍五入%f\n", ddd);

float ff=1024.58;
  double dd=12345678901234.58;
  char strff[21],strdd[21];
	sprintf(strff,"%.2f",ddd);
	printf("strff=%s\n",strff);  // 输出strff=1024.58
	float e = atof(strff);
	printf("%f\n", e);</code></pre> 
<p>输出</p> 
<pre><code class="language-cpp">四舍五入99.200996

strff=99.20
99.199997  二进制就是这样，想只显示两位是不可能的！</code></pre> 
<p>Java端再调用BigDecimal类型进行计算。在进行精度要求极高的计算时，可以使用Java提供的BigDecimal类型进行计算，它能够保证精度不会损失。不过注意：BigDecimal类型的计算效率较低</p> 
<p></p> 
<p>1. 由于计算机中浮点数表示的方式为近似值，所以在进行浮点数的比较时，需要使用特定的比较方式，避免误判。例如：Math.abs(a - b) &lt; 0.000001，表示a和b的差值小于0.000001。</p> 
<p>2. 在进行除法运算时，需要判断被除数是否为0，避免抛出异常。</p> 
<p>3. 浮点数中可能出现的NaN（Not a Number）或Infinity值需要进行特殊处理，否则可能导致程序异常终止。</p> 
<p>4.C、Java默认的是double类型，用小数最好不要用 .f ，否则会出现误差</p> 
<pre>C语言调用 Math.round 将小数四舍五入到整数
</pre> 
<p>float a = 99.4999;<br>     a = round(a);</p> 
<p>printf("%f\n", a);</p> 
<p></p> 
<p>5. Java 发送小数到C</p> 
<pre>//String value of 会丢失精度
NumberFormat nf = NumberFormat.getInstance();
nf.setGroupingUsed(false);
String s1 = nf.format(value);</pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/99989cac607542d91d44db237de12089/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是远程桌面连接？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5621454ad79a90b461a210e76302840b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何解决远程桌面无法连接问题？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>