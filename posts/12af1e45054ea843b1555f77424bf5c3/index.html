<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ARM Cortex-M内核中系统堆栈 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ARM Cortex-M内核中系统堆栈" />
<meta property="og:description" content="文章目录 有无OS的栈结构区别：裸机的任务栈结构带FreeRTOS操作系统的任务栈 ARM的寄存器有哪些特殊寄存器有哪些 关于FreeRTOS中的SP寄存器栈操作【压栈与弹栈的操作】一般函数嵌套调用时sp指针的变化Cortex-M内核的MSP与PSP作用 有无OS的栈结构区别： 裸机的任务栈结构 无OS的堆栈结构：此时每个任务的堆栈都在一起
带FreeRTOS操作系统的任务栈 在FreeRTOS中对线程、进程没有明显区分，统一称为任务。
有OS的堆栈结构：每个任务都有独立栈空间，用于保存上下文信息和全局变量
ARM的寄存器有哪些 ARM 架构的寄存器可以分为以下几类：
通用寄存器：ARM 架构有 17 个 32 位的通用寄存器，它们命名为 R0-R15，其中 R13-R15 被用作栈指针、链接寄存器（LR）和程序计数器（PC）。
状态寄存器：也称为程序状态寄存器（PSR），用于存储当前处理器的状态信息，例如条件码、中断使能位等。
特殊寄存器：包括控制寄存器、处理器 ID 寄存器、系统控制寄存器等，它们用于控制处理器的一些重要行为和特性。
浮点寄存器：ARMv7 架构引入了 VFP 协处理器，增加了 32 个浮点寄存器（S0-S31），可用于高精度浮点运算。
特殊寄存器有哪些 特殊寄存器是指在 ARM 架构中具有特殊用途的寄存器，包括以下几个：
控制寄存器（Control Register）：用于控制处理器的一些重要行为和特性，如异常处理、缓存设置等。
处理器 ID 寄存器（Processor ID Register）：用于标识处理器的类型和版本信息。
系统控制寄存器（System Control Register）：用于控制系统级的功能和特性，如内存管理单元（MMU）的设置、缓存控制等。
中断控制寄存器（Interrupt Control Register）：用于控制中断的使能和屏蔽，包括中断优先级、中断屏蔽位等。
定时器控制寄存器（Timer Control Register）：用于控制定时器的计数和触发方式，包括定时器的频率、计数模式等。
异常控制寄存器（Exception Control Register）：用于控制异常处理和异常向量表的地址。
这些特殊寄存器在 ARM 架构中扮演着关键的角色，可以控制和配置处理器的各种功能和特性，用于实现更高级的操作和控制。
关于FreeRTOS中的SP寄存器 一般来说Cortex-M系列有两种工作模式：
Thread Mode （线程模式）：程序按照编译好的代码顺序执行
​Handler Mode（中断模式）：收到中断信号并执行中断处理函数
所以，Cortex-M系列内核使用了双堆栈，即MSP和PSP
MSP ： Main_Stack_Pointer 主栈PSP ： Process_Stack_Pointer 任务栈SP ： 堆栈指针，指向最后一个被压入元素的地址 R13在任何时刻只能是其中一个，默认情况为MSP，可以通过控制寄存器：CONTROL寄存器的bit1来改变。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/12af1e45054ea843b1555f77424bf5c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-24T17:24:05+08:00" />
<meta property="article:modified_time" content="2023-09-24T17:24:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ARM Cortex-M内核中系统堆栈</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#OS_1" rel="nofollow">有无OS的栈结构区别：</a></li><li><ul><li><a href="#_3" rel="nofollow">裸机的任务栈结构</a></li><li><a href="#FreeRTOS_9" rel="nofollow">带FreeRTOS操作系统的任务栈</a></li></ul> 
  </li><li><a href="#ARM_15" rel="nofollow">ARM的寄存器有哪些</a></li><li><ul><li><a href="#_28" rel="nofollow">特殊寄存器有哪些</a></li></ul> 
  </li><li><a href="#FreeRTOSSP_46" rel="nofollow">关于FreeRTOS中的SP寄存器</a></li><li><a href="#_89" rel="nofollow">栈操作【压栈与弹栈的操作】</a></li><li><a href="#sp_98" rel="nofollow">一般函数嵌套调用时sp指针的变化</a></li><li><a href="#CortexMMSPPSP_118" rel="nofollow">Cortex-M内核的MSP与PSP作用</a></li></ul> 
</div> 
<p></p> 
<h2><a id="OS_1"></a>有无OS的栈结构区别：</h2> 
<h3><a id="_3"></a>裸机的任务栈结构</h3> 
<p>无OS的堆栈结构：此时每个任务的堆栈都在一起<br> <img src="https://images2.imgbox.com/7c/14/Wops2JiV_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="FreeRTOS_9"></a>带FreeRTOS操作系统的任务栈</h3> 
<p>在FreeRTOS中对线程、进程没有明显区分，统一称为任务。</p> 
<p>有OS的堆栈结构：每个任务都有独立栈空间，用于保存上下文信息和全局变量</p> 
<p><img src="https://images2.imgbox.com/c2/01/TjwMbcvW_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="ARM_15"></a>ARM的寄存器有哪些</h2> 
<p>ARM 架构的寄存器可以分为以下几类：</p> 
<ul><li> <p>通用寄存器：ARM 架构有 17 个 32 位的通用寄存器，它们命名为 R0-R15，其中 R13-R15 被用作栈指针、链接寄存器（LR）和程序计数器（PC）。</p> </li><li> <p>状态寄存器：也称为程序状态寄存器（PSR），用于存储当前处理器的状态信息，例如条件码、中断使能位等。</p> </li><li> <p>特殊寄存器：包括控制寄存器、处理器 ID 寄存器、系统控制寄存器等，它们用于控制处理器的一些重要行为和特性。</p> </li><li> <p>浮点寄存器：ARMv7 架构引入了 VFP 协处理器，增加了 32 个浮点寄存器（S0-S31），可用于高精度浮点运算。</p> </li></ul> 
<h3><a id="_28"></a>特殊寄存器有哪些</h3> 
<p>特殊寄存器是指在 ARM 架构中具有特殊用途的寄存器，包括以下几个：</p> 
<ol><li> <p>控制寄存器（Control Register）：用于控制处理器的一些重要行为和特性，如异常处理、缓存设置等。</p> </li><li> <p>处理器 ID 寄存器（Processor ID Register）：用于标识处理器的类型和版本信息。</p> </li><li> <p>系统控制寄存器（System Control Register）：用于控制系统级的功能和特性，如内存管理单元（MMU）的设置、缓存控制等。</p> </li><li> <p>中断控制寄存器（Interrupt Control Register）：用于控制中断的使能和屏蔽，包括中断优先级、中断屏蔽位等。</p> </li><li> <p>定时器控制寄存器（Timer Control Register）：用于控制定时器的计数和触发方式，包括定时器的频率、计数模式等。</p> </li><li> <p>异常控制寄存器（Exception Control Register）：用于控制异常处理和异常向量表的地址。</p> </li></ol> 
<p>这些特殊寄存器在 ARM 架构中扮演着关键的角色，可以控制和配置处理器的各种功能和特性，用于实现更高级的操作和控制。</p> 
<h2><a id="FreeRTOSSP_46"></a>关于FreeRTOS中的SP寄存器</h2> 
<p>一般来说Cortex-M系列有两种工作模式：</p> 
<ul><li> <p>Thread Mode （线程模式）：程序按照编译好的代码顺序执行</p> </li><li> <p>​Handler Mode（中断模式）：收到中断信号并执行中断处理函数</p> </li></ul> 
<p>所以，Cortex-M系列内核使用了双堆栈，即MSP和PSP</p> 
<ul><li>MSP ： Main_Stack_Pointer 主栈</li><li>PSP ： Process_Stack_Pointer 任务栈</li><li>SP ： 堆栈指针，指向最后一个被压入元素的地址</li></ul> 
<p>R13在任何时刻只能是其中一个，默认情况为MSP，可以通过控制寄存器：CONTROL寄存器的bit1来改变。<br> <img src="https://images2.imgbox.com/73/09/j2NwK9DH_o.png" alt="在这里插入图片描述"></p> 
<p>关于MSP和PSP的选用，其是通过CONTORL寄存器来配置，仅在Thread Mode下才可设置CONTORL寄存器。一般情况下，没有必要使用PSP，<code>除非是有os存在时</code>，MSP用于os内核的sp，而PSP用于thread级app的sp，这两个sp需严格分开。</p> 
<p><code>在编译器中</code>，可以通过r13（R13）或sp（SP）来访问堆栈（具体是MSP和PSP由当时环境决定）；也可以通过指定的MRS、MSR指令来访问MSP和PSP。</p> 
<p><img src="https://images2.imgbox.com/87/5a/RRMDwDjg_o.png" alt="在这里插入图片描述"></p> 
<p>控制寄存器有两个用途，其一用于定义特权级别，其二用于选择当前使用哪个堆栈指针。由两个比特来行使这两个职能。</p> 
<p><img src="https://images2.imgbox.com/15/a5/0ULrwfnr_o.png" alt="在这里插入图片描述"><br> 在裸机开发中，CONTROL的bit1始终是0，也就是说<code>裸机开发中全程使用程MSP</code>，并没有使用PSP。<code>在执行后台程序(大循环程序)SP使用的是MSP，在执行前台程序(中断服务程序)SP使用的是MSP</code>。</p> 
<p>​ <code>在OS开发中，当运行中断服务程序的时候CONTROL的bit1是0，SP使用的是MSP；当运行线程程序的时候CONTROL的bit1是1，SP使用的是PSP</code>。MSP是系统复位后（即其处于Handler Mode）的指定sp（vector table的前4Byte自动载入），用于处理异常中断。当结束Reset_Handler后，cpu进入正常运行状态（即其处于Thread Mode），仅在此状态下PSP才能被使用，当然MSP也可以使用。其后如有硬中断来临，则进入Handler Mode，如果硬件中断结束，则返回Thread Mode。</p> 
<h2><a id="_89"></a>栈操作【压栈与弹栈的操作】</h2> 
<p>Cortex-M0中堆栈方向是向低地址方向增长，为满堆栈机制。堆栈操作是通过PUSH和POP来完成操作的。实际上，除了POP指令可以从栈顶中取数据外；MOV指令也可从任意位置取数据，但不会影响栈结构（即不影响其sp）</p> 
<p>压栈与弹栈的操作：</p> 
<ul><li>压栈：SP先自减4，然后将待压入的数据存放到SP所指的地址</li><li>弹栈：从SP指针所指的地址读出数据，然后SP指针自增4</li></ul> 
<h2><a id="sp_98"></a>一般函数嵌套调用时sp指针的变化</h2> 
<p>在普通的函数嵌套调用中，当一个函数调用另一个函数时，程序会将<code>当前函数的执行现场（包括 PC（程序计数器）、当前函数的状态、参数、返回地址等）保存在当前函数的栈帧中</code>。接着，将栈指针 SP（stack pointer）移动到新的栈帧的栈顶位置（一般是上一个栈帧的底部位置），然后继续执行被调用的函数。</p> 
<p>在这个过程中，SP 指针的变化如下：</p> 
<ol><li> <p>进入被调用函数前：将当前函数的执行现场保存在当前函数的栈帧中，SP 指针不变。</p> </li><li> <p>进入被调用函数时：将新的栈帧的起始位置指定为上一个栈帧的底部，这个位置需要根据前一个栈帧的大小确定，即 SP 指针移动到新的栈帧的底部位置。</p> </li><li> <p>执行被调用函数时：如果有局部变量，则将这些变量分配在新的栈帧中。此时，SP 指针可能会进一步移动到这些变量的内存起始位置。</p> </li><li> <p>返回到调用函数时：将被调用函数的返回值或状态存储在新的栈帧中，并且<code>将 SP 指针恢复到上一个栈帧的底部位置</code>，以便取出当前函数的执行现场，同时恢复上一个栈帧中的现场并继续执行。</p> </li></ol> 
<p>需要注意的是，在函数嵌套调用过程中，递归调用、多层嵌套和异常处理等情况会使 SP 指针的变化更加复杂。因此，在编写和调试程序时，需要仔细注意栈帧的大小、内存分配和释放以及异常处理等问题，以确保程序的正确性和稳定性。</p> 
<h2><a id="CortexMMSPPSP_118"></a>Cortex-M内核的MSP与PSP作用</h2> 
<p>首先，设立双指针是为了保证OS的安全性和稳健性。通常来说，<code>操作系统和异常事件（中断或其他fault）使用MSP，用户程序（线程）使用PSP</code>。MSP与PSP指针之间的切换会在处理异常事件时自动完成。</p> 
<p>本质上，区别于用户程序使用PSP，操作系统和异常事件单独使用一个MSP指针的目的，<code>是为了保证栈数据不会被用户程序意外访问或栈空间被用户程序占用</code>。比如，当应用程序发生栈溢出问题时，必须要确保应用程序的故障不会影响到操作系统的运行和异常事件的处理——<code>也就需要保证始终要有栈空间来执行异常事件。</code></p> 
<p>裸机操作时，使用的就是MSP指针。其实OS在上电复位到切换线程之前用的都是MSP指针，也就是线程切换之前都是一个裸机程序的状态。</p> 
<p>参考博文：<br> <a href="https://blog.csdn.net/qq_45704265/article/details/118636952">关于FreeRTOS的底层实现和基础认识</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4cb6ac28f68d2fa423ace83c5d3109b8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows，macOS，Linux换行标识的前世今生，如何处理文本文件行尾的^M</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2caa975eee49963818958eb6570dea69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Dataset和DataLoader用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>