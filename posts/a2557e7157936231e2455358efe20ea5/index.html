<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;标准模板库(STL)——queue、priority_queue、stack、pair、algorithm头文件下的常用函数 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;标准模板库(STL)——queue、priority_queue、stack、pair、algorithm头文件下的常用函数" />
<meta property="og:description" content="文章目录 一、queue二、priority_queue三、stack四、pair五、algorithm头文件下的常用函数1、max()、min()、abs()：2、swap()：3、reverse()：4、next_permutation()：5、fill()：6、sort()：7、lower_bound()、upper_bound() 一、queue queue为队列，具有先进先出的特性。使用queue，需要添加#include&lt; queue &gt;和using namespace std;
1、queue的定义：
queue&lt;typename&gt; name;//typename可以是任意基本数据类型或容器 queue元素的访问：
由于queue本身就是一种先进先出的限制性数据结构，所以STL只能够提供front()来访问队首元素，用back()来访问队尾元素
#include&lt;queue&gt; #include&lt;stdio.h&gt; using namespace std; int main(){ queue&lt;int&gt; q; for(int i = 1 ; i &lt;= 5 ; i&#43;&#43;) q.push(i); printf(&#34;%d&#34;,q.front());//1 return 0; } 3、push()
push(x)：将x入队，插入到队尾的位置
4、pop()
令队首元素出队
#include&lt;queue&gt; #include&lt;stdio.h&gt; using namespace std; int main(){ queue&lt;int&gt; q; for(int i = 1 ; i &lt;= 5 ; i&#43;&#43;) q.push(i); for(int i = 1 ; i &lt;= 3 ; i&#43;&#43;) q." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a2557e7157936231e2455358efe20ea5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-07T14:50:36+08:00" />
<meta property="article:modified_time" content="2022-02-07T14:50:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;标准模板库(STL)——queue、priority_queue、stack、pair、algorithm头文件下的常用函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#queue_8" rel="nofollow">一、queue</a></li><li><a href="#priority_queue_68" rel="nofollow">二、priority_queue</a></li><li><a href="#stack_186" rel="nofollow">三、stack</a></li><li><a href="#pair_227" rel="nofollow">四、pair</a></li><li><a href="#algorithm_292" rel="nofollow">五、algorithm头文件下的常用函数</a></li><li><ul><li><ul><li><a href="#1maxminabs_293" rel="nofollow">1、max()、min()、abs()：</a></li><li><a href="#2swap_297" rel="nofollow">2、swap()：</a></li><li><a href="#3reverse_299" rel="nofollow">3、reverse()：</a></li><li><a href="#4next_permutation_317" rel="nofollow">4、next_permutation()：</a></li><li><a href="#5fill_347" rel="nofollow">5、fill()：</a></li><li><a href="#6sort_365" rel="nofollow">6、sort()：</a></li><li><a href="#7lower_boundupper_bound_454" rel="nofollow">7、lower_bound()、upper_bound()</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr color="#000000" size='1"'> 
<h2><a id="queue_8"></a>一、queue</h2> 
<p>queue为队列，具有先进先出的特性。使用queue，需要添加#include&lt; queue &gt;和using namespace std;</p> 
<p><strong>1、queue的定义：</strong></p> 
<pre><code>queue&lt;typename&gt; name;//typename可以是任意基本数据类型或容器
</code></pre> 
<p><strong>queue元素的访问：</strong><br> 由于queue本身就是一种先进先出的限制性数据结构，所以STL只能够提供front()来访问队首元素，用back()来访问队尾元素</p> 
<pre><code>#include&lt;queue&gt;
#include&lt;stdio.h&gt;
using namespace std;

int main(){
    queue&lt;int&gt; q;
    for(int i = 1 ; i &lt;= 5 ; i++)
        q.push(i);
    printf("%d",q.front());//1
    return 0;
}

</code></pre> 
<p><strong>3、push()</strong><br> push(x)：将x入队，插入到队尾的位置</p> 
<p><strong>4、pop()</strong><br> 令队首元素出队</p> 
<pre><code>#include&lt;queue&gt;
#include&lt;stdio.h&gt;
using namespace std;

int main(){
    queue&lt;int&gt; q;
    for(int i = 1 ; i &lt;= 5 ; i++)
        q.push(i);
    for(int i = 1 ; i &lt;= 3 ; i++)
        q.pop();
    printf("%d",q.front());//4
    return 0;
}

</code></pre> 
<p><strong>5、empty()</strong><br> 检测队列是否为空，如果是则返回true，不是则返回false</p> 
<p><strong>6、size()</strong><br> 返回队列中元素的个数</p> 
<p>注意：在使用front()和pop()函数之前，必须使用empty()函数判断队列是否为空，否则可能出现错误</p> 
<h2><a id="priority_queue_68"></a>二、priority_queue</h2> 
<p>优先队列，底层是用堆来实现的，在优先队列中，队首元素一定是当前队列中优先级最高的那一个。使用的时候要添加#include&lt; queue &gt;以及using namespace std;</p> 
<p><strong>1、priority_queue的定义：</strong></p> 
<pre><code>priority_queue&lt;typename&gt; name;
</code></pre> 
<p><strong>2、priority_queue容器内元素的访问：</strong><br> 与queue不同的是，优先队列没有front()和back()函数，只能够通过top()函数来访问队首元素</p> 
<pre><code>#include&lt;queue&gt;
#include&lt;stdio.h&gt;
using namespace std;

int main(){
    priority_queue&lt;int&gt; q;
    q.push(3);
    q.push(4);
    q.push(1);
    printf("%d",q.top());//4
    return 0;
}

</code></pre> 
<p><strong>3、push()：</strong><br> push(x)：令x入队</p> 
<p><strong>4、top()：</strong><br> 可以获得队首元素，实现容器内元素的访问</p> 
<p><strong>5、pop()：</strong><br> 令队首元素出队</p> 
<p><strong>6、empty()：</strong><br> 检测队列是否为空，若为空则返回true，否则返回false</p> 
<p><strong>7、size（）</strong><br> 返回优先队列中元素的个数</p> 
<p><strong>8、元素优先级设置</strong><br> (1)基本数据类型的优先级设置<br> 以int类型为例，下面两种定义是等价的：</p> 
<pre><code>priority_queue&lt;int&gt; q;

priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q;
</code></pre> 
<p>第二种方式中vector&lt; int &gt;是来承载底层数据结构堆得容器，而less&lt; int &gt;则是对第一个参数的比较类，<strong>less&lt; int &gt;表示数字大的优先级越大，greater&lt; int &gt;表示数字小的优先级越大</strong></p> 
<pre><code>#include&lt;queue&gt;
#include&lt;stdio.h&gt;
using namespace std;

int main(){
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//数字小的优先级越大
    q.push(3);
    q.push(4);
    q.push(1);
    printf("%d",q.top());//1
    return 0;
}

</code></pre> 
<p>(2)结构体优先级设置<br> 如用水果的名称和价格建立一个结构体，现在希望对水果价格高的优先极高，就需要重载“&lt;”小于号，重载大于号会编译错误。</p> 
<pre><code>struct fruit{
    string name;
    int price;
    friend bool operator &lt; (fruit f1 , fruit f2){
        return f1.price &lt; f2.price;
    }
};
</code></pre> 
<p>注意：优先队列中的这个函数与sort中的cmp函数的效果是相反的，设置f1.price&lt;f2.price是从小到大排列， 但是在优先队列中的效果是价格高的优先级高</p> 
<p>示例：想以价格低的水果优先级高</p> 
<pre><code>#include&lt;queue&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;

struct fruit{
    string name;
    int price;
    friend bool operator &lt; (fruit f1 , fruit f2){
        return f1.price &gt; f2.price;
    }
}f1,f2,f3;

int main(){
    priority_queue&lt;fruit&gt; q;
    f1.name = "桃子";
    f1.price = 3;
    f2.name = "梨子";
    f2.price = 4;
    f3.name = "苹果";
    f3.price = 1;
    q.push(f1);
    q.push(f2);
    q.push(f3);
    cout&lt;&lt;q.top().name&lt;&lt;" "&lt;&lt;q.top().price&lt;&lt;endl;
    return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/67/c6/oJ6wcMLI_o.png" alt="在这里插入图片描述"></p> 
<p>**常见用途：**可以解决一些贪心问题，也可以对迪杰斯特拉算法进行优化</p> 
<h2><a id="stack_186"></a>三、stack</h2> 
<p>栈：后进先出的容器。想要使用栈，必须添加#include&lt; stack &gt;并加上using namespace std;</p> 
<p><strong>1、stack的定义：</strong></p> 
<pre><code>stack&lt;typename&gt; name;
</code></pre> 
<p><strong>2、元素的访问：</strong><br> stack中只能通过top()来访问栈顶元素</p> 
<p><strong>3、push()：</strong><br> push(x)：将x入栈</p> 
<p><strong>4、pop()</strong><br> pop()用以弹出栈顶元素</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stack&gt;
using namespace std;

int main(){
    stack&lt;int&gt; s;
    for(int i = 1 ; i &lt;= 5 ; i++)
        s.push(i);
    for(int i = 1 ; i &lt;=3 ; i++)
        s.pop();
    printf("%d",s.top());//2
    return 0;
}

</code></pre> 
<p><strong>5、empty()：</strong><br> 检测stack是否为空，如果为空返回true，不为空则返回false</p> 
<p><strong>6、size()：</strong><br> 返回stack内的元素的个数</p> 
<h2><a id="pair_227"></a>四、pair</h2> 
<p>当想要将两个元素绑在一起作为一个合成元素、又不想定义结构体时，可以使用pair。也就是说，pair实际上可以看做一个内部有两个元素的结构体。想使用pair，要添加#include&lt; utility &gt;以及using namespace std。</p> 
<p><strong>1、pair的定义：</strong></p> 
<pre><code>pair&lt;typename1，typename2&gt; name;

如：
pair&lt;string，int&gt; p;

也可以定义的时候进行初始化：
pair&lt;string，int&gt; p("haha",5);
</code></pre> 
<p><strong>2、元素的访问：</strong><br> pair中只有两个元素，分别为first和second</p> 
<pre><code>#include&lt;utility&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

int main(){
    pair&lt;string,int&gt; p;
    p.first="haha";
    p.second=5;
    cout&lt;&lt;p.first&lt;&lt;" "&lt;&lt;p.second&lt;&lt;endl;
    p = make_pair("xixi",55);
    cout&lt;&lt;p.first&lt;&lt;" "&lt;&lt;p.second&lt;&lt;endl;
    p = pair&lt;string,int&gt;("heihie",555);
    cout&lt;&lt;p.first&lt;&lt;" "&lt;&lt;p.second&lt;&lt;endl;
    return 0;
}

</code></pre> 
<p><strong>3、比较:</strong><br> 两个pair类型可以通过==、!=、&lt;、&lt;=、&gt;、&gt;=比较大小，规则是先以first的大小作为标准，只有当first相等时再去判别second的大小</p> 
<p><strong>常见用途：</strong></p> 
<ul><li>用来代替二元结构体及其构造函数</li><li>作为map的键值对来进行插入</li></ul> 
<pre><code>#include&lt;utility&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;

int main(){
   map&lt;string,int&gt; mp;
   mp.insert(make_pair("heihei",5));
   mp.insert(pair&lt;string,int&gt;("haha",10));
   for(map&lt;string,int&gt;::iterator it = mp.begin();it!=mp.end();it++){
    cout&lt;&lt;it-&gt;first&lt;&lt;" "&lt;&lt;it-&gt;second&lt;&lt;endl;
   }
   return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/d7/da/Zo4VnpIh_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="algorithm_292"></a>五、algorithm头文件下的常用函数</h2> 
<h4><a id="1maxminabs_293"></a>1、max()、min()、abs()：</h4> 
<p>max(x,y)、min(x,y)返回x、y中的最大值和最小值。且参数必须是两个，如果有三个参数，可以使用max(x,max(y,z))的写法。<br> abs(x)返回x的绝对值。x必须是整数，如果是浮点数请用math头文件下的fabs</p> 
<h4><a id="2swap_297"></a>2、swap()：</h4> 
<p>swap(x,y)用来交换x、y的值</p> 
<h4><a id="3reverse_299"></a>3、reverse()：</h4> 
<p>reverse(it,it2)可以将数组指针在[it,it2)之间的元素或容器的迭代器在[it,it2）范围内的元素进行反转</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;

int main(){
    string str = "abcdefghi";
    reverse(str.begin()+2,str.begin()+6);
    for(int i = 0 ; i &lt; str.length() ; i++)
        printf("%c",str[i]);//abfedcghi
    return 0;
}

</code></pre> 
<h4><a id="4next_permutation_317"></a>4、next_permutation()：</h4> 
<p>给出一个序列在全排列中的下一个序列。<br> 例如：当n=3时的全排列</p> 
<pre><code>123
132
213
231
312
321
</code></pre> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;

int main(){
    int a[10]={1,2,3};
    do{
        printf("%d%d%d\n",a[0],a[1],a[2]);
    }while(next_permutation(a,a+3));
    return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/72/ee/z11SnnEb_o.png" alt="在这里插入图片描述"><br> 在到达全排列的最后一个时next_permutation会返回false，这样会方便退出循环</p> 
<h4><a id="5fill_347"></a>5、fill()：</h4> 
<p>可以将数组或容器中的某一段区间赋值为某个相同的值，与memset不同，这里的赋值可以是数组类型对应范围内的任何值</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;

int main(){
    int a[5]={1,2,3,4,5};
    fill(a,a+5,233);
    for(int i = 0 ; i &lt; 5 ; i++)
        printf("%d ",a[i]);
    return 0;
}

</code></pre> 
<h4><a id="6sort_365"></a>6、sort()：</h4> 
<p>是用来排序的函数：</p> 
<pre><code>sort(首元素地址，尾元素地址的下一个地址，比较函数)
</code></pre> 
<p>比较函数可以根据需要填写，如果不写，默认对前面给出的区间进行递增排序</p> 
<p>例如：对于char型数组从大到小排序(按字典序)</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;

bool cmp(char a , char b){
    return a&gt;b;
}

int main(){
    char a[] = {'T','W','A','K'};
    sort(a,a+4,cmp);;
    for(int i = 0 ; i &lt; 4 ; i++)
        printf("%c",a[i]);//WTKA
    return 0;
}

</code></pre> 
<p>如：对于结构体的排序定义，x不等时按照x从大到小排序，x相等时按照y从小到大排序</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;

struct node{
    int x,y;
}ssd[10];

bool cmp(node a , node b){
    if(a.x != b.x)
        return a.x &gt; b.x;
    else
        return a.y &lt; b.y;
}

int main(){
    ssd[0].x = 2;
    ssd[0].y = 2;
    ssd[1].x = 1;
    ssd[1].y = 3;
    ssd[2].x = 2;
    ssd[2].y = 1;
    sort(ssd,ssd+3,cmp);
    for(int i = 0 ; i &lt; 3 ; i++)
        printf("%d %d\n",ssd[i].x,ssd[i].y);
    return 0;
}
// 2 1
// 2 2
// 1 3

</code></pre> 
<p>容器的排序：在STL中，只有vector、string、deque时可以使用sort的，因为set和map这种容器本身就有序</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

bool cmp(int a , int b){
    return a&gt;b;
}

int main(){
    vector&lt;int&gt; vi;
    vi.push_back(3);
    vi.push_back(1);
    vi.push_back(2);
    sort(vi.begin(),vi.end(),cmp);
    for(int i = 0 ; i &lt; 3 ; i++)
        printf("%d ",vi[i]);
    return 0;
}

</code></pre> 
<h4><a id="7lower_boundupper_bound_454"></a>7、lower_bound()、upper_bound()</h4> 
<p>需要用在一个有序数组或者容器中。<br> lower_bound(first,last,val)寻找在数组或容器的[first,last)范围内第一个值大于等于val的元素的位置，如果是数组则返回该位置的指针，如果是容器，则返回该位置的迭代器<br> upper_bound(first,last,val)寻找在数组或容器的[first,last)范围内第一个值大于val的元素的位置，如果是数组则返回该位置的指针，如果是容器，则返回该位置的迭代器<br> 如果没有寻找到，则返回可以插入该元素的位置的指针或者迭代器</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;

int main(){
    int a[10] = {1,2,2,3,3,3,5,5,5,5};
    //寻找-1
    int* lowerPos = lower_bound(a,a+10,-1);
    int* upperPos = upper_bound(a,a+10,-1);
    printf("%d,%d\n",lowerPos-a,upperPos-a);//0,0

    //寻找3
    lowerPos = lower_bound(a,a+10,3);
    upperPos = upper_bound(a,a+10,3);
    printf("%d,%d\n",lowerPos-a,upperPos-a);//3,6

    return 0
}

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2d45f7ae01938a53682c6639f86e71e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Studio在build时一直停在：gradle: download maven-metadata.xml</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/41e1309fc49b5147604e14586ac2574d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JS中如何删除某个元素下的所有子元素（节点）？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>