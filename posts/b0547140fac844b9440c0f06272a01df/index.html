<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringCloud Gateway路由配置方式(不包含熔断) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringCloud Gateway路由配置方式(不包含熔断)" />
<meta property="og:description" content="如果请求的目标地址，是单个的URI资源路径，配置文件示例如下：
server: port: 8080 spring: application: name: api-gateway cloud: gateway: routes: -id: url-proxy-1 uri: https://blog.csdn.net predicates: -Path=/csdn 各字段含义如下：
id：我们自定义的路由 ID，保持唯一
uri：目标服务地址
predicates：路由条件，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。
上面这段配置的意思是，配置了一个 id 为 url-proxy-1的URI代理规则，路由的规则为：
当访问地址http://localhost:8080/csdn/1.jsp时，
会路由到上游地址https://blog.csdn.net/1.jsp。
2.2 基于代码的路由配置方式 转发功能同样可以通过代码来实现，我们可以在启动类 GateWayApplication 中添加方法 customRouteLocator() 来定制转发规则。
package com.springcloud.gateway; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.gateway.route.RouteLocator; import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder; import org.springframework.context.annotation.Bean; @SpringBootApplication public class GatewayApplication { public static void main(String[] args) { SpringApplication.run(GatewayApplication.class, args); } @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) { return builder." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b0547140fac844b9440c0f06272a01df/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-01T14:49:16+08:00" />
<meta property="article:modified_time" content="2021-12-01T14:49:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringCloud Gateway路由配置方式(不包含熔断)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>如果请求的目标地址，是单个的URI资源路径，配置文件示例如下：</p> 
<pre><code>server:
  port: 8080
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        -id: url-proxy-1
          uri: https://blog.csdn.net
          predicates:
            -Path=/csdn</code></pre> 
<p>各字段含义如下：</p> 
<p>id：我们自定义的路由 ID，保持唯一</p> 
<p>uri：目标服务地址</p> 
<p>predicates：路由条件，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。</p> 
<p>上面这段配置的意思是，配置了一个 id 为 url-proxy-1的URI代理规则，路由的规则为：</p> 
<p>当访问地址http://localhost:8080/csdn/1.jsp时，</p> 
<p>会路由到上游地址https://blog.csdn.net/1.jsp。</p> 
<h3 id="22-基于代码的路由配置方式">2.2 基于代码的路由配置方式</h3> 
<p>转发功能同样可以通过代码来实现，我们可以在启动类 GateWayApplication 中添加方法 customRouteLocator() 来定制转发规则。</p> 
<pre><code>package com.springcloud.gateway;
 
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
 
@SpringBootApplication
public class GatewayApplication {
 
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
 
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
                .route("path_route", r -&gt; r.path("/csdn")
                        .uri("https://blog.csdn.net"))
                .build();
    }
 
}</code></pre> 
<p></p> 
<p>我们在yaml配置文件中注销掉相关路由的配置，重启服务，访问链接：<a href="http://localhost:8080/" rel="nofollow" title="http://localhost:8080/">http://localhost:8080/</a> csdn， 可以看到和上面一样的页面，证明我们测试成功。</p> 
<p>上面两个示例中 uri 都是指向了我的CSDN博客，在实际项目使用中可以将 uri 指向对外提供服务的项目地址，统一对外输出接口。</p> 
<h3 id="23----和注册中心相结合的路由配置方式">2.3 和注册中心相结合的路由配置方式</h3> 
<p>在uri的schema协议部分为自定义的lb:类型，表示从微服务注册中心（如Eureka）订阅服务，并且进行服务的路由。</p> 
<p>一个典型的示例如下：</p> 
<pre><code>server:
  port: 8084
spring:
  cloud:
    gateway:
      routes:
      -id: seckill-provider-route
        uri: lb://seckill-provider
        predicates:
        - Path=/seckill-provider/**

      -id: message-provider-route
        uri: lb://message-provider
        predicates:
        -Path=/message-provider/**

application:
  name: cloud-gateway

eureka:
  instance:
    prefer-ip-address: true
  client:
    service-url:
      defaultZone: http://localhost:8888/eureka/

</code></pre> 
<p>注册中心相结合的路由配置方式，与单个URI的路由配置，区别其实很小，仅仅在于URI的schema协议不同。单个URI的地址的schema协议，一般为http或者https协议。</p> 
<h2 id="3---路由-匹配规则">3 路由 匹配规则</h2> 
<p>Spring Cloud Gateway 的功能很强大，我们仅仅通过 Predicates 的设计就可以看出来，前面我们只是使用了 predicates 进行了简单的条件匹配，其实 Spring Cloud Gataway 帮我们内置了很多 Predicates 功能。</p> 
<p>Spring Cloud Gateway 是通过 Spring WebFlux 的 HandlerMapping 做为底层支持来匹配到转发路由，Spring Cloud Gateway 内置了很多 Predicates 工厂，这些 Predicates 工厂通过不同的 HTTP 请求参数来匹配，多个 Predicates 工厂可以组合使用。</p> 
<p><a href="https://img-blog.csdnimg.cn/20200527213652534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NzIyNDc1,size_16,color_FFFFFF,t_70" rel="nofollow"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/1d/49/2tBUdCOx_o.png"></a></p> 
<p>gateWay的主要功能之一是转发请求，转发规则的定义主要包含三个部分</p> 
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Route（路由）</td><td>路由是网关的基本单元，由ID、URI、一组Predicate、一组Filter组成，根据Predicate进行匹配转发。</td><td></td></tr><tr><td>Predicate（谓语、断言）</td><td>路由转发的判断条件，目前SpringCloud Gateway支持多种方式，常见如：Path、Query、Method、Header等，写法必须遵循 key=vlue的形式</td><td></td></tr><tr><td>Filter（过滤器）</td><td>过滤器是路由转发请求时所经过的过滤逻辑，可用于修改请求、响应内容</td><td></td></tr></tbody></table> 
<blockquote> 
 <p>其中Route和Predicate必须同时申明</p> 
</blockquote> 
<p>例子：</p> 
<pre><code>//通过配置文件配置
spring:
  cloud:
    gateway:
      routes:
        - id: gate_route
          uri: http://localhost:9023
          predicates:
          ## 当请求的路径为gate、rule开头的时，转发到http://localhost:9023服务器上
            - Path=/gate/**,/rule/**
        ### 请求路径前加上/app
          filters:
          - PrefixPath=/app</code></pre> 
<p></p> 
<h3 id="31-------predicate-断言条件转发规则介绍">3.1 Predicate 断言条件(转发规则)介绍</h3> 
<p>Predicate 来源于 Java 8，是 Java 8 中引入的一个函数，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。</p> 
<p>在 Spring Cloud Gateway 中 Spring 利用 Predicate 的特性实现了各种路由匹配规则，有通过 Header、请求参数等不同的条件来进行作为条件匹配到对应的路由。网上有一张图总结了 Spring Cloud 内置的几种 Predicate 的实现。</p> 
<p style="text-align:center;"><a href="https://upload-images.jianshu.io/upload_images/19816137-bb046dbf19bee1b4.gif?imageMogr2/auto-orient/strip" rel="nofollow"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/d9/63/84JsD8OX_o.gif"></a></p> 
<p><br> [<br> 说白了 Predicate 就是为了实现一组匹配规则，方便让请求过来找到对应的 Route 进行处理，接下来我们接下 Spring Cloud GateWay 内置几种 Predicate 的使用。</p> 
<ul><li>转发规则（predicates），假设 转发uri都设定为<em><strong><a href="http://localhost:9023/" rel="nofollow" title="http://localhost:9023">http://localhost:9023</a></strong></em></li></ul> 
<table><thead><tr><th>规则</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>Path</td><td>- Path=/gate/<strong>,/rule/</strong></td><td>## 当请求的路径为gate、rule开头的时，转发到http://localhost:9023服务器上</td></tr><tr><td>Before</td><td>- Before=2017-01-20T17:42:47.789-07:00[America/Denver]</td><td>在某个时间之前的请求才会被转发到 http://localhost:9023服务器上</td></tr><tr><td>After</td><td>- After=2017-01-20T17:42:47.789-07:00[America/Denver]</td><td>在某个时间之后的请求才会被转发</td></tr><tr><td>Between</td><td>- Between=2017-01-20T17:42:47.789-07:00[America/Denver],2017-01-21T17:42:47.789-07:00[America/Denver]</td><td>在某个时间段之间的才会被转发</td></tr><tr><td>Cookie</td><td>- Cookie=chocolate, ch.p</td><td>名为chocolate的表单或者满足正则ch.p的表单才会被匹配到进行请求转发</td></tr><tr><td>Header</td><td>- Header=X-Request-Id, \d+</td><td>携带参数X-Request-Id或者满足\d+的请求头才会匹配</td></tr><tr><td>Host</td><td>- Host=www.hd123.com</td><td>当主机名为www.hd123.com的时候直接转发到http://localhost:9023服务器上</td></tr><tr><td>Method</td><td>- Method=GET</td><td>只有GET方法才会匹配转发请求，还可以限定POST、PUT等请求方式</td></tr></tbody></table> 
<h4 id="152-------通过请求参数匹配"><strong>1.5.2</strong> 通过请求参数匹配</h4> 
<p>Query Route Predicate 支持传入两个参数，一个是属性名一个为属性值，属性值可以是正则表达式。</p> 
<pre><code>server:
  port: 8080
spring:
  application:
  	 name: api-gateway
  cloud:
    gateway:
      routes:
        -id: gateway-service
          uri: https://www.baidu.com
          order: 0
          predicates:
            -Query=smile</code></pre> 
<p>这样配置，只要请求中包含 smile 属性的参数即可匹配路由。</p> 
<p>使用 curl 测试，命令行输入:</p> 
<p>curl localhost:8080?smile=x&amp;id=2</p> 
<p>经过测试发现只要请求汇总带有 smile 参数即会匹配路由，不带 smile 参数则不会匹配。</p> 
<p>还可以将 Query 的值以键值对的方式进行配置，这样在请求过来时会对属性值和正则进行匹配，匹配上才会走路由。</p> 
<pre><code>server:

  port: 8080

spring:

  application:

    name: api-gateway

  cloud:

    gateway:

      routes:

        -id: gateway-service

          uri: https://www.baidu.com

          order: 0

          predicates:

            -Query=keep, pu.</code></pre> 
<p></p> 
<p>这样只要当请求中包含 keep 属性并且参数值是以 pu 开头的长度为三位的字符串才会进行匹配和路由。</p> 
<p>使用 curl 测试，命令行输入:</p> 
<p>curl localhost:8080?keep=pub</p> 
<p>测试可以返回页面代码，将 keep 的属性值改为 pubx 再次访问就会报 404,证明路由需要匹配正则表达式才会进行路由。</p> 
<h4 id="153-------通过-header-属性匹配"><strong>1.5.3</strong> 通过 Header 属性匹配</h4> 
<p>Header Route Predicate 和 Cookie Route Predicate 一样，也是接收 2 个参数，一个 header 中属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。</p> 
<pre><code>server:
  port: 8080
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        -id: gateway-service
          uri: https://www.baidu.com
          order: 0
          predicates:
            - Header=X-Request-Id, \d+</code></pre> 
<p></p> 
<p>使用 curl 测试，命令行输入:</p> 
<p>curl <a href="http://localhost:8080/" rel="nofollow" title="http://localhost:8080">http://localhost:8080</a> -H "X-Request-Id:88"</p> 
<p>则返回页面代码证明匹配成功。将参数-H "X-Request-Id:88"改为-H "X-Request-Id:spring"再次执行时返回404证明没有匹配。</p> 
<h4 id="154-------通过-cookie-匹配"><strong>1.5.4</strong> 通过 Cookie 匹配</h4> 
<p>Cookie Route Predicate 可以接收两个参数，一个是 Cookie name ,一个是正则表达式，路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。</p> 
<pre><code>server:
  port: 8080
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        -id: gateway-service
          uri: https://www.baidu.com
          order: 0
          predicates:
            - Cookie=sessionId, test</code></pre> 
<p>使用 curl 测试，命令行输入:</p> 
<p>curl <a href="http://localhost:8080/" rel="nofollow" title="http://localhost:8080">http://localhost:8080</a> --cookie "sessionId=test"</p> 
<p>则会返回页面代码，如果去掉--cookie "sessionId=test"，后台汇报 404 错误。</p> 
<h4 id="155-------通过-host-匹配"><strong>1.5.5</strong> 通过 Host 匹配</h4> 
<p>Host Route Predicate 接收一组参数，一组匹配的域名列表，这个模板是一个 ant 分隔的模板，用.号作为分隔符。它通过参数中的主机地址作为匹配规则。</p> 
<pre><code>server:
  port: 8080
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        -id: gateway-service
          uri: https://www.baidu.com
          order: 0
          predicates:
            - Host=**.baidu.com</code></pre> 
<p></p> 
<p>使用 curl 测试，命令行输入:</p> 
<p>curl <a href="http://localhost:8080/" rel="nofollow" title="http://localhost:8080">http://localhost:8080</a> -H "Host: www.baidu.com"</p> 
<p>curl <a href="http://localhost:8080/" rel="nofollow" title="http://localhost:8080">http://localhost:8080</a> -H "Host: md.baidu.com"</p> 
<p>经测试以上两种 host 均可匹配到 host_route 路由，去掉 host 参数则会报 404 错误。</p> 
<h4 id="156-------通过请求方式匹配"><strong>1.5.6</strong> 通过请求方式匹配</h4> 
<p>可以通过是 POST、GET、PUT、DELETE 等不同的请求方式来进行路由。</p> 
<pre><code>server:
  port: 8080
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        -id: gateway-service
          uri: https://www.baidu.com
          order: 0
          predicates:
            - Method=GET</code></pre> 
<p></p> 
<p>使用 curl 测试，命令行输入:</p> 
<p># curl 默认是以 GET 的方式去请求</p> 
<p>curl <a href="http://localhost:8080/" rel="nofollow" title="http://localhost:8080">http://localhost:8080</a></p> 
<p>测试返回页面代码，证明匹配到路由，我们再以 POST 的方式请求测试。</p> 
<p># curl 默认是以 GET 的方式去请求</p> 
<p>curl -X POST <a href="http://localhost:8080/" rel="nofollow" title="http://localhost:8080">http://localhost:8080</a></p> 
<p>返回 404 没有找到，证明没有匹配上路由</p> 
<h4 id="157-------通过请求路径匹配"><strong>1.5.7</strong> 通过请求路径匹配</h4> 
<p>Path Route Predicate 接收一个匹配路径的参数来判断是否走路由。</p> 
<pre><code>server:
  port: 8080
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        -id: gateway-service
          uri: http://ityouknow.com
          order: 0
          predicates:
            -Path=/foo/{segment}</code></pre> 
<p></p> 
<p>如果请求路径符合要求，则此路由将匹配，例如：/foo/1 或者 /foo/bar。</p> 
<p>使用 curl 测试，命令行输入:</p> 
<p>curl <a href="http://localhost:8080/foo/1" rel="nofollow" title="http://localhost:8080/foo/1">http://localhost:8080/foo/1</a></p> 
<p>curl <a href="http://localhost:8080/foo/xx" rel="nofollow" title="http://localhost:8080/foo/xx">http://localhost:8080/foo/xx</a></p> 
<p>curl <a href="http://localhost:8080/boo/xx" rel="nofollow" title="http://localhost:8080/boo/xx">http://localhost:8080/boo/xx</a></p> 
<p>经过测试第一和第二条命令可以正常获取到页面返回值，最后一个命令报404，证明路由是通过指定路由来匹配。</p> 
<h4 id="158-------通过请求-ip-地址进行匹配"><strong>1.5.8</strong> 通过请求 ip 地址进行匹配</h4> 
<p>Predicate 也支持通过设置某个 ip 区间号段的请求才会路由，RemoteAddr Route Predicate 接受 cidr 符号(IPv4 或 IPv6 )字符串的列表(最小大小为1)，例如 192.168.0.1/16 (其中 192.168.0.1 是 IP 地址，16 是子网掩码)。</p> 
<pre><code>server:

  port: 8080
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        - id: gateway-service
          uri: https://www.baidu.com
          order: 0
          predicates:
            - RemoteAddr=192.168.1.1/24</code></pre> 
<p></p> 
<p>可以将此地址设置为本机的 ip 地址进行测试。</p> 
<p>curl localhost:8080</p> 
<p>如果请求的远程地址是 192.168.1.10，则此路由将匹配。</p> 
<h4 id="1510-组合使用"><strong>1.5.10</strong> <strong>组合使用</strong></h4> 
<pre><code>server:
  port: 8080
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        - id: gateway-service
          uri: https://www.baidu.com
          order: 0
          predicates:
            - Host=**.foo.org
            - Path=/headers
            - Method=GET
            - Header=X-Request-Id, \d+
            - Query=foo, ba.
            - Query=baz
            - Cookie=chocolate, ch.p
</code></pre> 
<p>​</p> 
<p>各种 Predicates 同时存在于同一个路由时，请求必须同时满足所有的条件才被这个路由匹配。</p> 
<p>一个请求满足多个路由的断言条件时，请求只会被首个成功匹配的路由转发</p> 
<h3 id="32-过滤器规则filter">3.2 过滤器规则（Filter）</h3> 
<h4 id="过滤器规则filter">过滤器规则（Filter）</h4> 
<table><thead><tr><th>过滤规则</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>PrefixPath</td><td>- PrefixPath=/app</td><td>在请求路径前加上app</td></tr><tr><td>RewritePath</td><td>- RewritePath=/test, /app/test</td><td>访问localhost:9022/test,请求会转发到localhost:8001/app/test</td></tr><tr><td>SetPath</td><td>SetPath=/app/{path}</td><td>通过模板设置路径，转发的规则时会在路径前增加app，{path}表示原请求路径</td></tr><tr><td>RedirectTo</td><td></td><td>重定向</td></tr><tr><td>RemoveRequestHeader</td><td></td><td>去掉某个请求头信息</td></tr></tbody></table> 
<p>注：当配置多个filter时，优先定义的会被调用，剩余的filter将不会生效</p> 
<h4 id="prefixpath">PrefixPath</h4> 
<p>对所有的请求路径添加前缀：</p> 
<pre><code>spring:
  cloud:
    gateway:
      routes:
      - id: prefixpath_route
        uri: https://example.org
        filters:
        - PrefixPath=/mypath
</code></pre> 
<p></p> 
<p>访问/hello的请求被发送到https://example.org/mypath/hello。</p> 
<h4 id="redirectto">RedirectTo</h4> 
<p>重定向，配置包含重定向的返回码和地址：</p> 
<pre><code>spring:
  cloud:
    gateway:
      routes:
      - id: prefixpath_route
        uri: https://example.org
        filters:
        - RedirectTo=302, https://acme.org
</code></pre> 
<p></p> 
<h4 id="removerequestheader">RemoveRequestHeader</h4> 
<p>去掉某个请求头信息：</p> 
<pre><code>spring:
  cloud:
    gateway:
      routes:
      - id: removerequestheader_route
        uri: https://example.org
        filters:
        - RemoveRequestHeader=X-Request-Foo</code></pre> 
<p></p> 
<p>去掉请求头信息 X-Request-Foo</p> 
<h4 id="removeresponseheader">RemoveResponseHeader</h4> 
<p>去掉某个回执头信息：</p> 
<pre><code>spring:
  cloud:
    gateway:
      routes:
      - id: removerequestheader_route
        uri: https://example.org
        filters:
        - RemoveResponseHeader=X-Request-Foo</code></pre> 
<p></p> 
<h4 id="removerequestparameter">RemoveRequestParameter</h4> 
<p>去掉某个请求参数信息：</p> 
<pre><code>spring:
  cloud:
    gateway:
      routes:
      - id: removerequestparameter_route
        uri: https://example.org
        filters:
        - RemoveRequestParameter=red</code></pre> 
<h4 id="rewritepath">RewritePath</h4> 
<p>改写路径：</p> 
<pre><code>spring:
  cloud:
    gateway:
      routes:
      - id: rewrite_filter
        uri: http://localhost:8081
        predicates:
        - Path=/test/**
        filters:
        - RewritePath=/where(?&lt;segment&gt;/?.*), /test(?&lt;segment&gt;/?.*)
</code></pre> 
<p></p> 
<p>/where/... 改成 test/...</p> 
<p>使用代码改下路径</p> 
<pre><code>	    RouteLocatorBuilder.Builder builder = routeLocatorBuilder.routes();
        builder
                .route("path_rote_at_guigu", r -&gt; r.path("/guonei")
                        .uri("http://news.baidu.com/guonei"))
                .route("csdn_route", r -&gt; r.path("/csdn")
                        .uri("https://blog.csdn.net"))
                .route("blog3_rewrite_filter", r -&gt; r.path("/blog3/**")
                        .filters(f -&gt; f.rewritePath("/blog3/(?&lt;segment&gt;.*)", "/$\\{segment}"))
                        .uri("https://blog.csdn.net"))
                .route("rewritepath_route", r -&gt; r.path("/baidu/**")
                        .filters(f -&gt; f.rewritePath("/baidu/(?&lt;segment&gt;.*)", "/$\\{segment}"))
                        .uri("http://www.baidu.com"))

                .build();</code></pre> 
<p></p> 
<h4 id="setpath">SetPath</h4> 
<p>设置请求路径，与RewritePath类似。</p> 
<pre><code>spring:
  cloud:
    gateway:
      routes:
      - id: setpath_route
        uri: https://example.org
        predicates:
        - Path=/red/{segment}
        filters:
        - SetPath=/{segment}</code></pre> 
<p></p> 
<p>如/red/blue的请求被转发到/blue。</p> 
<h4 id="setrequestheader">SetRequestHeader</h4> 
<p>设置请求头信息。</p> 
<pre><code>spring:
  cloud:
    gateway:
      routes:
      - id: setrequestheader_route
        uri: https://example.org
        filters:
        - SetRequestHeader=X-Request-Red, Blue</code></pre> 
<p></p> 
<h4 id="setstatus">SetStatus</h4> 
<p>设置回执状态码。</p> 
<pre><code>spring:
  cloud:
    gateway:
      routes:
      - id: setstatusint_route
        uri: https://example.org
        filters:
        - SetStatus=401</code></pre> 
<p></p> 
<h4 id="stripprefix">StripPrefix</h4> 
<p>跳过指定路径。</p> 
<pre><code>spring:
  cloud:
    gateway:
      routes:
      - id: nameRoot
        uri: https://nameservice
        predicates:
        - Path=/name/**
        filters:
        - StripPrefix=2</code></pre> 
<p></p> 
<p>请求/name/blue/red会转发到/red。</p> 
<h4 id="requestsize">RequestSize</h4> 
<p>请求大小。</p> 
<pre><code>spring:
  cloud:
    gateway:
      routes:
      - id: request_size_route
        uri: http://localhost:8080/upload
        predicates:
        - Path=/upload
        filters:
        - name: RequestSize
          args:
            maxSize: 5000000</code></pre> 
<p></p> 
<p>超过5M的请求会返回413错误。</p> 
<h4 id="default-filters">Default-filters</h4> 
<p>对所有请求添加过滤器。</p> 
<pre><code>spring:
  cloud:
    gateway:
      default-filters:
      - AddResponseHeader=X-Response-Default-Red, Default-Blue
      - PrefixPath=/httpbin</code></pre> 
<p>spring: cloud: gateway: default-filters: - AddResponseHeader=X-Response-Default-Red, Default-Blue - PrefixPath=/httpbin</p> 
<h3 id="33-通过代码进行配置">3.3 通过代码进行配置</h3> 
<p>通过代码进行配置，将路由规则设置为一个Bean即可：</p> 
<pre><code>	@Bean
	public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
		return builder.routes()
			.route("path_route", r -&gt; r.path("/get")
				.uri("http://httpbin.org"))
			.route("host_route", r -&gt; r.host("*.myhost.org")
				.uri("http://httpbin.org"))
			.route("rewrite_route", r -&gt; r.host("*.rewrite.org")
				.filters(f -&gt; f.rewritePath("/foo/(?&lt;segment&gt;.*)", "/${segment}"))
				.uri("http://httpbin.org"))
			.route("hystrix_route", r -&gt; r.host("*.hystrix.org")
				.filters(f -&gt; f.hystrix(c -&gt; c.setName("slowcmd")))
				.uri("http://httpbin.org"))
			.route("hystrix_fallback_route", r -&gt; r.host("*.hystrixfallback.org")
				.filters(f -&gt; f.hystrix(c -&gt; c.setName("slowcmd").setFallbackUri("forward:/hystrixfallback")))
				.uri("http://httpbin.org"))
			.route("limit_route", r -&gt; r
				.host("*.limited.org").and().path("/anything/**")
				.filters(f -&gt; f.requestRateLimiter(c -&gt; c.setRateLimiter(redisRateLimiter())))
				.uri("http://httpbin.org"))
			.build();
	}

</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d63f18c632f08e5373543852afe69c33/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaScript进阶七（对象）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e8b0ade5420a5fd00125532d48e6dbac/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">操作系统实验Ucore:Kernel_init(四)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>