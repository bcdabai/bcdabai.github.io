<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>你还在把Java当成Android官方开发语言吗？Kotlin了解一下！ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="你还在把Java当成Android官方开发语言吗？Kotlin了解一下！" />
<meta property="og:description" content="导语：2017年Google IO大会宣布使用Kotlin作为Android的官方开发语言，相比较与典型的面相对象的JAVA语言，Kotlin作为一种新式的函数式编程语言，也有人称之为Android平台的Swift语言。
本文由腾讯Bugly发表在腾讯云&#43;社区
先让我们看下实现同样的功能，Java和Kotiln的对比：
// JAVA，20多行代码，充斥着findViewById，类型转换，匿名内部类这样的无意义代码 public class MainJavaActivity extends Activity { @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView label = (TextView) findViewById(R.id.label); Button btn = (Button) findViewById(R.id.btn); label.setText(&#34;hello&#34;); label.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.d(&#34;Glen&#34;,&#34;onClick TextView&#34;); } }); btn.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v) { Log.d(&#34;Glen&#34;,&#34;onClick Button&#34;); } }); } } 复制代码 再来看Kotlin
// Kotlin,没有了冗余的findViewById，我们可以直接对资源id进行操作，也不需要匿名内部类的声明，更关注函数的实现本身，抛弃了复杂的格式 class MainKotlinActivity:Activity() { override fun onCreate(savedInstanceState: Bundle?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0581465eb859c844234b9122b382c69e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-21T02:35:56+08:00" />
<meta property="article:modified_time" content="2018-06-21T02:35:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">你还在把Java当成Android官方开发语言吗？Kotlin了解一下！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <blockquote> 
  <p>导语：2017年Google IO大会宣布使用Kotlin作为Android的官方开发语言，相比较与典型的面相对象的JAVA语言，Kotlin作为一种新式的函数式编程语言，也有人称之为Android平台的Swift语言。</p> 
 </blockquote> 
 <p><strong>本文由<a href="https://link.juejin.im?target=http%3A%2F%2Fbugly.qq.com" rel="nofollow">腾讯Bugly</a>发表在<a href="https://link.juejin.im?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%3Ffromsource%3Dwaitui" rel="nofollow">腾讯云+社区</a></strong></p> 
 <p>先让我们看下实现同样的功能，Java和Kotiln的对比：</p> 
 <pre><code class="hljs bash copyable">// JAVA，20多行代码，充斥着findViewById，类型转换，匿名内部类这样的无意义代码

public class MainJavaActivity extends Activity {
    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {        
    super.onCreate(savedInstanceState);
        <span class="hljs-built_in">set</span>ContentView(R.layout.activity_main);

        TextView label = (TextView) findViewById(R.id.label);
        Button btn = (Button) findViewById(R.id.btn);

        label.setText(<span class="hljs-string">"hello"</span>);
        label.setOnClickListener(new View.<span class="hljs-function"><span class="hljs-title">OnClickListener</span></span>() {           
            @Override
            public void onClick(View v) {
                Log.d(<span class="hljs-string">"Glen"</span>,<span class="hljs-string">"onClick TextView"</span>);
            }
        });
        btn.setOnClickListener(new View.<span class="hljs-function"><span class="hljs-title">OnClickListener</span></span>(){            
            @Override
            public void onClick(View v) {
                Log.d(<span class="hljs-string">"Glen"</span>,<span class="hljs-string">"onClick Button"</span>);
            }
        });
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p><strong>再来看Kotlin</strong></p> 
 <pre><code class="hljs bash copyable">// Kotlin,没有了冗余的findViewById，我们可以直接对资源id进行操作，也不需要匿名内部类的声明，更关注函数的实现本身，抛弃了复杂的格式
class MainKotlinActivity:<span class="hljs-function"><span class="hljs-title">Activity</span></span>() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        <span class="hljs-built_in">set</span>ContentView(R.layout.activity_main)

        R.id.label.setText(<span class="hljs-string">"hello"</span>)
        R.id.label.onClick { Log.d(<span class="hljs-string">"Glen"</span>,<span class="hljs-string">"onClick TextView"</span>) }
        R.id.btn.onClick { Log.d(<span class="hljs-string">"Glen"</span>,<span class="hljs-string">"onClick Button"</span>) }
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>实现这些需要借助Kotlin的扩展函数与高阶函数，本文主要介绍一下扩展函数。</p> 
 <h3 class="heading"><strong>1. Kotlin 扩展函数与扩展属性(Kotlin Extensions)</strong></h3> 
 <p>Kotlin 能够扩展一个类的新功能而无需继承该类，或者对任意的类使用像“装饰者(Decorator)”这样的设计模式。这些都是通过叫做“扩展(extensions)”的特殊声明实现的。Kotlin扩展声明既支持扩展函数也支持扩展属性，本文主要讨论扩展函数，至于扩展属性实现的机制类似。</p> 
 <p>扩展函数的声明非常简单，他的关键字是.，此外我们需要一个“接受者类型(recievier type)”来作为他的前缀。以类<code>MutableList&lt;Int&gt;</code>为例，现在为它扩展一个swap方法，如下：</p> 
 <pre><code class="hljs bash copyable">fun MutableList&lt;Int&gt;.swap(index1:Int,index2:Int) {
    val tmp = this[index1]
    this[index1] = this[index2]
    this[index2] = tmp
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p><code>MutableList&lt;T&gt;</code>是kotlin提供的基础库<code>collection</code>中的List容器类，这里在声明里作为“接受者类型”，.作为声明关键字，<code>swap</code>是扩展函数名，其余和Kotlin声明一个普通函数并无区别。</p> 
 <p>额外提一句，Kotlin的<code>this语法</code>要比JAVA更灵活，这里扩展函数体里的<code>this</code>代表的是接受者类型对象。</p> 
 <p>如果我们想要调用这个扩展函数，可以这样：</p> 
 <pre><code class="hljs bash copyable">fun <span class="hljs-function"><span class="hljs-title">use</span></span>(){
    val list = mutableListOf(1,2,3)
    list.swap(1,2)
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading"><strong>2. Kotlin扩展函数是怎么实现的</strong></h3> 
 <p>扩展函数的调用看起来就像是原生方法一样自然，使用起来也非常顺手，但是这样的方法会不会带来性能方面的掣肘呢？有必要探究一下Kotlin是如何实现扩展函数的，直接分析Kotlin源码难度还是挺大，还好Android Studio提供了一些工具，我们可以通过<code>Kotlin ByteCode</code>指令，查看Kotlin语言转换的字节码文件，仍以<code>MutableList&lt;Int&gt;</code>,<code>swap</code>为例，转换为字节码之后的文件如下：</p> 
 <pre><code class="hljs bash copyable">// ================com/example/glensun/demo/extension/MutableListDemoKt.class =================
// class version 50.0 (50)
// access flags 0x31

public final class com/example/glensun/demo/extension/MutableListDemoKt {  

   // access flags 0x19
  // signature (Ljava/util/List&lt;Ljava/lang/Integer;&gt;;II)V
  // declaration: void swap(java.util.List&lt;java.lang.Integer&gt;, int, int)
  public final static swap(Ljava/util/List;II)V
    @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0
   L0
    ALOAD 0
    LDC <span class="hljs-string">"<span class="hljs-variable">$receiver</span>"</span>
    INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull (Ljava/lang/Object;Ljava/lang/String;)V
   L1
    LINENUMBER 8 L1
    ALOAD 0
    ILOAD 1
    INVOKEINTERFACE java/util/List.get (I)Ljava/lang/Object;
    CHECKCAST java/lang/Number
    INVOKEVIRTUAL java/lang/Number.intValue ()I
    ISTORE 3
   L2
    LINENUMBER 9 L2
    ALOAD 0
    ILOAD 1
    ALOAD 0
    ILOAD 2
    INVOKEINTERFACE java/util/List.get (I)Ljava/lang/Object;
    INVOKEINTERFACE java/util/List.set (ILjava/lang/Object;)Ljava/lang/Object;
    POP
   L3
    LINENUMBER 10 L3
    ALOAD 0
    ILOAD 2
    ILOAD 3
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    INVOKEINTERFACE java/util/List.set (ILjava/lang/Object;)Ljava/lang/Object;
    POP
   L4
    LINENUMBER 11 L4
    RETURN
   L5
    LOCALVARIABLE tmp I L2 L5 3
    LOCALVARIABLE <span class="hljs-variable">$receiver</span> Ljava/util/List; L0 L5 0
    LOCALVARIABLE index1 I L0 L5 1
    LOCALVARIABLE index2 I L0 L5 2
    MAXSTACK = 4
    MAXLOCALS = 4

  @Lkotlin/Metadata;(mv={1, 1, 7}, bv={1, 0, 2}, k=2, d1={<!-- --><span class="hljs-string">"\u0000\u0012\n\u0000\n\u0002\u0010\u0002\n\u0002\u0010!\n\u0002\u0010\u0008\n\u0002\u0008\u0003\u001a \u0010\u0000\u001a\u00020\u0001*\u0008\u0012\u0004\u0012\u00020\u00030\u00022\u0006\u0010\u0004\u001a\u00020\u00032\u0006\u0010\u0005\u001a\u00020\u0003\u00a8\u0006\u0006"</span>}, d2={<!-- --><span class="hljs-string">"swap"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"index1"</span>, <span class="hljs-string">"index2"</span>, <span class="hljs-string">"production sources for module app"</span>})  
// compiled from: MutableListDemo.kt

}
// ================META-INF/production sources <span class="hljs-keyword">for</span> module app.kotlin_module =================
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>这里的字节码已经相当直观，更令人惊喜的是Android Studio还具备将字节码转为JAVA文件的能力，点击上面的Decompile按钮，可以得到如下JAVA代码：</p> 
 <pre><code class="hljs bash copyable">import java.util.List;
import kotlin.Metadata;
import kotlin.jvm.internal.Intrinsics;
import org.jetbrains.annotations.NotNull;

@Metadata(
   mv = {1, 1, 7},
   bv = {1, 0, 2},
   k = 2,
   d1 = {<!-- --><span class="hljs-string">"\u0000\u0012\n\u0000\n\u0002\u0010\u0002\n\u0002\u0010!\n\u0002\u0010\b\n\u0002\b\u0003\u001a \u0010\u0000\u001a\u00020\u0001*\b\u0012\u0004\u0012\u00020\u00030\u00022\u0006\u0010\u0004\u001a\u00020\u00032\u0006\u0010\u0005\u001a\u00020\u0003¨\u0006\u0006"</span>},
   d2 = {<!-- --><span class="hljs-string">"swap"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"index1"</span>, <span class="hljs-string">"index2"</span>, <span class="hljs-string">"production sources for module app"</span>}
)

public final class MutableListDemoKt {   
    public static final void swap(@NotNull List <span class="hljs-variable">$receiver</span>, int index1, int index2) {
      Intrinsics.checkParameterIsNotNull(<span class="hljs-variable">$receiver</span>, <span class="hljs-string">"<span class="hljs-variable">$receiver</span>"</span>);      
    int tmp = ((Number)<span class="hljs-variable">$receiver</span>.get(index1)).intValue();
      <span class="hljs-variable">$receiver</span>.set(index1, <span class="hljs-variable">$receiver</span>.get(index2));
      <span class="hljs-variable">$receiver</span>.set(index2, Integer.valueOf(tmp));
   }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>从得到的JAVA文件分析，扩展函数的实现非常简单，它没有修改接受者类型的成员，仅仅是通过静态方法来实现的。这样，我们虽然不必担心扩展函数会带来额外的性能消耗，但是它也不会带来性能上的优化。</p> 
 <h3 class="heading"><strong>3.更复杂的情况</strong></h3> 
 <p>下面来讨论一些更特殊的情况。</p> 
 <p><strong>3.1 当发生继承时</strong>，扩展函数由于本质上是静态方法，它会严格按照参数类型去执行调用，而不会去优先执行或者主动执行父类的方法，如下的例子所示：</p> 
 <pre><code class="hljs bash copyable">open class A

class B:A()

fun A.foo() = <span class="hljs-string">"a"</span>

fun B.foo() = <span class="hljs-string">"b"</span>

fun <span class="hljs-built_in">print</span>Foo(a:A){
   println(a.foo())
}

println(B())
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>上述例子的输出结果是a，因为扩展函数的入参类型是A，他将会严格按照入参类型执行函数调用。</p> 
 <p><strong>3.2 如果扩展函数和现有的类成员发生冲突</strong>，kotlin将会默认使用类成员，这一步选择是在编译期处理的，生成的字节码是将会是调用类成员的方法，如下例子：</p> 
 <pre><code class="hljs bash copyable">class C{    
    fun <span class="hljs-function"><span class="hljs-title">foo</span></span>() {println(<span class="hljs-string">"Member"</span>)}
}

fun C.<span class="hljs-function"><span class="hljs-title">foo</span></span>() {println(<span class="hljs-string">"Extension"</span>)}

println(C().foo())
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>上述的例子将会输出<code>Member</code>。Kotlin不允许扩展一个已有的成员，原因也很好理解，我们不希望扩展函数成为调用三方sdk的漏洞，不过如果你试图使用重载的方式创建扩展函数，这样是可行的。</p> 
 <p><strong>3.3 Kotlin严格区分了可能为空和不为空的入参类型</strong>，同样也应用在扩展函数的中，为了声明一个可能为空的接受者类型，可以参考如下例子：</p> 
 <pre><code class="hljs bash copyable">fun &lt;T&gt; MutableList&lt;T&gt;?.swap(index1:Int,index2:Int){
    <span class="hljs-keyword">if</span>(this == null){
        println(null)
        <span class="hljs-built_in">return</span>
    } 

    val tmp = this[index1]    
    this[index1] = this[index2]    
    this[index2] = tmp
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p><strong>3.4 我们有时候还希望能够添加类似JAVA的“静态函数”的扩展函数</strong>，这时需要借助“伴随对象(Companion Object)”来实现，如下这个例子：</p> 
 <pre><code class="hljs bash copyable">class D{
    companion object{
        val m = 1
    }
}

fun D.Companion.<span class="hljs-function"><span class="hljs-title">foo</span></span>(){
    println(<span class="hljs-string">"<span class="hljs-variable">$m</span> in extension"</span>)
}

D.foo()
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>上面的例子会输出<code>1 in extension</code>，注意这里调用foo这个扩展函数时，并不需要类D的实例，类似于JAVA的静态方法。</p> 
 <p><strong>3.5 如果留意前面的例子</strong>，我们会发现kotlin的<code>this</code>语法和JAVA不同，使用范围更灵活，仅以扩展函数为例，当在扩展函数里调用<code>this</code>时，指代的是接受者类型的实例，那么如果这个扩展函数声明在一个类内部，我们如何通过<code>this</code>获取到类的实例呢？可以参考下面的例子：</p> 
 <pre><code class="hljs bash copyable">class E{    
    fun <span class="hljs-function"><span class="hljs-title">foo</span></span>(){
        println(<span class="hljs-string">"foo in Class E"</span>)
    }

}
class F{    
    fun <span class="hljs-function"><span class="hljs-title">foo</span></span>(){
        println(<span class="hljs-string">"foo in Class F"</span>)
    }

    fun E.<span class="hljs-function"><span class="hljs-title">foo2</span></span>(){        
        this.foo()        
        this@F.foo()
    }
}

E().foo2()
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>这里使用了kotlin的this指定语法，关键字是@,后接指定的类型，上述例子的输出结果是</p> 
 <pre><code class="hljs bash copyable">foo <span class="hljs-keyword">in</span> Class E
foo <span class="hljs-keyword">in</span> Class F
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading"><strong>4. 扩展函数的作用域</strong></h3> 
 <p>一般来说，我们习惯将扩展函数直接定义在包内，例如：</p> 
 <pre><code class="hljs bash copyable">package com.example.extension

fun MutableList&lt;Int&gt;.swap(index1:Int,index2:Int) {
    val tmp = this[index1]
    this[index1] = this[index2]
    this[index2] = tmp
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>这样，在同一个包内可以直接调用改扩展函数，如果我们需要跨包调用扩展函数，我们需要通过import来指明，以上述的例子为例，可以通过<code>import com.example.extension.swap</code>来指定这个扩展函数，也可以通过<code>import com.example.extension.*</code>表示引入该包内的所有扩展函数。得益于Android Studio具备的自动联想能力，通常不需要我们主动输入<code>import</code>指令。</p> 
 <p>有时候，我们也会把扩展函数定义在类的内部，例如：</p> 
 <pre><code class="hljs bash copyable">class G {
    fun Int.<span class="hljs-function"><span class="hljs-title">foo</span></span>(){
        println(<span class="hljs-string">"foo in Class G"</span>)
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>这里的<code>Int.foo()</code>是一个定义在类G内部的扩展函数，在这个扩展函数里，我们直接使用<code>Int</code>类型作为接受者类型，因为我们将扩展函数定义在了类的内部，即使我们设置访问权限为<code>public</code>，它也只能在该类或者该类的子类中被访问，如果我们设置访问权限为private，那么在子类中也不能访问这个扩展函数。</p> 
 <h3 class="heading"><strong>5. 扩展函数的实际应用</strong></h3> 
 <p><strong>5.1 Utils工具类</strong></p> 
 <p>在JAVA中，我们习惯将工具类命名成<code>*Utils</code>，例如<code>FileUtils</code>,<code>StringUtils</code>等等，著名的<code>java.util.Collections</code>也是这么实现的。调用这些方法的时候，总觉得这些类名碍手碍脚的，例如这样：</p> 
 <pre><code class="hljs bash copyable">// Java

Collections.swap(list, Collections.binarySearch(list, Collections.max(otherList)), Collections.max(list));
Collections.max(list));
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>通过静态引用，能让情况看起来好一点，例如这样：</p> 
 <pre><code class="hljs bash copyable">// Java

swap(list, binarySearch(list, max(otherList)), max(list));
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>但是这样既没有IDE的自动联想提示，方法调用的主体也显得不明确。如果能做成下面这样就好了：</p> 
 <pre><code class="hljs bash copyable">// Java

list.swap(list.binarySearch(otherList.max()), list.max());
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>但是list是JAVA默认的基础类，在JAVA语言里，如果不使用继承，肯定是没法做到这样的，而在Kotlin中就可以借助扩展函数来实现啦。</p> 
 <p><strong>5.2 Android View 胶水代码</strong></p> 
 <p>回到最开始的例子，对于Android开发来说，对<code>findViewById()</code>这个方法一定不会陌生，为了获取一个View对象，我们总得先调用<code>findViewById()</code>然后再执行类型转换，这样无意义的胶水代码让<code>Activity</code>或者<code>Fragment</code>显得臃肿无比，例如：</p> 
 <pre><code class="hljs bash copyable">// JAVA

public class MainJavaActivity extends Activity {    
    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {        
        super.onCreate(savedInstanceState);
        <span class="hljs-built_in">set</span>ContentView(R.layout.activity_main);

        TextView label = (TextView) findViewById(R.id.label);
        Button btn = (Button) findViewById(R.id.btn);

        label.setText(<span class="hljs-string">"hello"</span>);
        label.setOnClickListener(new View.<span class="hljs-function"><span class="hljs-title">OnClickListener</span></span>() {            
            @Override
            public void onClick(View v) {
                Log.d(<span class="hljs-string">"Glen"</span>,<span class="hljs-string">"onClick TextView"</span>);
            }
        });
        btn.setOnClickListener(new View.<span class="hljs-function"><span class="hljs-title">OnClickListener</span></span>(){           
             @Override
            public void onClick(View v) {
                Log.d(<span class="hljs-string">"Glen"</span>,<span class="hljs-string">"onClick Button"</span>);
            }
        });
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>我们考虑利用扩展函数结合泛型，避免频繁的类型转换，扩展函数定义如下：</p> 
 <pre><code class="hljs bash copyable">//kotlin

fun &lt;T : View&gt; Activity.find(@IdRes id: Int): T {    
    <span class="hljs-built_in">return</span> findViewById(id) as T
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>调用的时候，如下：</p> 
 <pre><code class="hljs bash copyable">// Kotlin
...
    TextView label = find(R.id.label);
    Button btn = find(R.id.btn);
...
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>只是我们还是需要获取到<code>label</code>,<code>btn</code>，这样无意义的中间变量，如果在Int类上扩展，可以直接对<code>R.id.*</code>操作，这样更直接，再结合高阶函数，函数定义如下：</p> 
 <pre><code class="hljs bash copyable">//Kotlin

fun Int.setText(str:String){
    val label = find&lt;TextView&gt;(this).apply {
        text = str
    }
}

fun Int.onClick(click: ()-&gt;Unit){
    val tmp = find&lt;View&gt;(this).apply {
        <span class="hljs-built_in">set</span>OnClickListener{
            click()
        }
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>我们就可以这样调用：</p> 
 <pre><code class="hljs bash copyable">//Kotlin

R.id.label.setText(<span class="hljs-string">"hello"</span>)
R.id.label.onClick { Log.d(<span class="hljs-string">"Glen"</span>,<span class="hljs-string">"onClick TextView"</span>) }
R.id.btn.onClick { Log.d(<span class="hljs-string">"Glen"</span>,<span class="hljs-string">"onClick Button"</span>) }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>通常这些扩展函数可以放到基类中，根据扩展函数的作用域知识，我们可以在所有子类中都调用到这些方法，所以kotlin的<code>Activity</code>可以写成：</p> 
 <pre><code class="hljs bash copyable">// Kotlin
class MainKotlinActivity:<span class="hljs-function"><span class="hljs-title">KotlinBaseActivity</span></span>() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        <span class="hljs-built_in">set</span>ContentView(R.layout.activity_main)

        R.id.label.setText(<span class="hljs-string">"hello"</span>)
        R.id.label.onClick { Log.d(<span class="hljs-string">"Glen"</span>,<span class="hljs-string">"onClick TextView"</span>) }
        R.id.btn.onClick { Log.d(<span class="hljs-string">"Glen"</span>,<span class="hljs-string">"onClick Button"</span>) }
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>从原来JAVA冗余的20多行代码，精简到只需要3行代码，而且代码可读性更高，更加直观，这便是函数式编程语言Kotlin的强大威力。</p> 
 <hr> 
 <p><strong>问答</strong></p> 
 <p><a href="https://link.juejin.im?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Fask%2F46989%3FfromSource%3Dwaitui" rel="nofollow">什么是Kotlin的“接收器”？</a></p> 
 <p><strong>相关阅读</strong></p> 
 <p><a href="https://link.juejin.im?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1071662%3FfromSource%3Dwaitui" rel="nofollow">你为什么需要 Kotlin</a></p> 
 <p><a href="https://link.juejin.im?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1110463%3FfromSource%3Dwaitui" rel="nofollow">手Q Android线程死锁监控与自动化分析实践</a></p> 
 <p><a href="https://link.juejin.im?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1042358%3FfromSource%3Dwaitui" rel="nofollow">为什么说Kotlin的可读性比Java好？</a></p> 
 <hr> 
 <p><strong>此文已由作者授权腾讯云+社区发布，原文链接：https://cloud.tencent.com/developer/article/1146533?fromSource=waitui</strong></p> 
 <p><strong>欢迎大家前往<a href="https://link.juejin.im?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2F%3FfromSource%3Dwaitui" rel="nofollow">腾讯云+社区</a>或关注云加社区微信公众号（QcloudCommunity），第一时间获取更多海量技术实践干货哦~</strong></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ac89b50f9c2a2478b061d731121128f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python五子棋--博弈树</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5f7b2487813bbbf5ee7c35c7ac6ebbf2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【通俗易懂】机器学习中 L1 和 L2 正则化的直观解释</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>