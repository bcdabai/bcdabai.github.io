<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GitLab-CI入门 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GitLab-CI入门" />
<meta property="og:description" content="部门决定从SVN迁移到GIT之初，我们暂定的是使用Jenkins作为CI/CD的实现，不过秉承实用的思想我们最终决定直接启用GitLab内置的GitLab-CI作为我们目前的CI/CD实现。
1. 概述 GitLab-CI 即为 GitLab Continuous Integration，也就是GitLab自带的持续集成工具。其思想就是每次用户push代码到gitlab上时触发执行.gitlab-ci.yml 脚本，脚本的内容包括了测试，编译，部署等一系列自定义的内容。
与 Jenkins Pipeline 相比，GitLab-CI 更轻，更方便。它直接通过简单 yaml 文件定义 pipeline，相比与 jenkins 复杂的 groovy 语法，GitLab-CI 更简单。正如官方宣传的&#34;Don’t let your tools slow you down&#34;。
2. 配置GitLab-Runner 想要使用GitLab-CI，我们需要安装一些额外的组件GitLab-Runner。GitLab服务本身只负责任务的派发，具体的执行还是得交给Runner，这也符合最基本的设计准则——调度中心和执行分开，避免相互影响，方便迭代更新，也方便扩容。
GitLab Runner可以跑在一个单独的机子上。只需要这个机器需要能够访问GitLab服务本身。不过笔者建议进行单独安装，避免搅和在一起相互影响。软件开发是一个整体，前期偷的那点懒，之后会成倍地还回来。
这里以CentOS为例：
######## 准备工作 # 操作系统版本 $ rpm -q centos-release centos-release-7-7.1908.0.el7.centos.x86_64 # 更改hostname, 让CI执行日志更有辨识度 $ sudo hostname 252Server ######## 安装 # 下载可执行包 wget -O /usr/local/bin/gitlab-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-linux-amd64 # 赋予执行权限 chmod &#43;x /usr/local/bin/gitlab-runner # 创建runner用户 useradd --comment &#39;GitLab Runner&#39; --create-home gitlab-runner --shell /bin/bash ######## 注册Runner (目的是实现GitLab-Runner与GitLab-CI之间的信息互注册。Runner知道了自己需要操作哪个项目，CI也知道了该runner的存在。刷新Runners settings就可以看到新注册的Runner了。) # 注意以下输入项大部分是可以在之后进行界面化修改的, 所以不用过分担心." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dc5252cce6dc31e69de1ed540461b60c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-02T16:00:37+08:00" />
<meta property="article:modified_time" content="2020-04-02T16:00:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GitLab-CI入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>部门决定从SVN迁移到GIT之初，我们暂定的是使用Jenkins作为CI/CD的实现，不过秉承实用的思想我们最终决定直接启用GitLab内置的GitLab-CI作为我们目前的CI/CD实现。</p> 
</blockquote> 
<h4><a id="1__2"></a>1. 概述</h4> 
<p>GitLab-CI 即为 GitLab Continuous Integration，也就是GitLab自带的持续集成工具。其思想就是每次用户push代码到gitlab上时触发执行<code>.gitlab-ci.yml</code> 脚本，脚本的内容包括了测试，编译，部署等一系列自定义的内容。</p> 
<p>与 Jenkins Pipeline 相比，GitLab-CI 更轻，更方便。它直接通过简单 yaml 文件定义 pipeline，相比与 jenkins 复杂的 groovy 语法，GitLab-CI 更简单。正如官方宣传的"<a href="https://about.gitlab.com/webcast/mastering-ci-cd/" rel="nofollow">Don’t let your tools slow you down</a>"。</p> 
<h4><a id="2_GitLabRunner_7"></a>2. 配置GitLab-Runner</h4> 
<p>想要使用GitLab-CI，我们需要安装一些额外的组件GitLab-Runner。GitLab服务本身只负责任务的派发，具体的执行还是得交给Runner，这也符合最基本的设计准则——调度中心和执行分开，避免相互影响，方便迭代更新，也方便扩容。</p> 
<p>GitLab Runner可以跑在一个单独的机子上。只需要这个机器需要能够访问GitLab服务本身。不过笔者建议进行单独安装，避免搅和在一起相互影响。软件开发是一个整体，前期偷的那点懒，之后会成倍地还回来。</p> 
<p>这里以CentOS为例：</p> 
<pre><code class="prism language-bash"><span class="token comment">######## 准备工作</span>
<span class="token comment"># 操作系统版本</span>
$ rpm -q centos-release
centos-release-7-7.1908.0.el7.centos.x86_64
<span class="token comment"># 更改hostname, 让CI执行日志更有辨识度</span>
$ <span class="token function">sudo</span> <span class="token function">hostname</span> 252Server

<span class="token comment">######## 安装</span>
<span class="token comment"># 下载可执行包</span>
<span class="token function">wget</span> -O /usr/local/bin/gitlab-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-linux-amd64
<span class="token comment"># 赋予执行权限</span>
<span class="token function">chmod</span> +x /usr/local/bin/gitlab-runner
<span class="token comment"># 创建runner用户</span>
<span class="token function">useradd</span> --comment <span class="token string">'GitLab Runner'</span> --create-home gitlab-runner --shell /bin/bash

<span class="token comment">######## 注册Runner (目的是实现GitLab-Runner与GitLab-CI之间的信息互注册。Runner知道了自己需要操作哪个项目，CI也知道了该runner的存在。刷新Runners settings就可以看到新注册的Runner了。)</span>
<span class="token comment"># 注意以下输入项大部分是可以在之后进行界面化修改的, 所以不用过分担心.</span>
$ gitlab-runner register
Running <span class="token keyword">in</span> system-mode.                            

<span class="token comment"># 以下URL, TOKEN的来源参见下方截图                                                   </span>
Please enter the gitlab-ci coordinator URL <span class="token punctuation">(</span>e.g. https://gitlab.com/<span class="token punctuation">)</span>:
http://XXX.XXX.XXX.XXX/  <span class="token comment"># 注意这里使用默认端口80, 笔者经过尝试发现这里即使你特意配置了端口, 之后Runner拉取代码的时候依然是使用默认的80端口. 即使配置了clone_url也无效; 有知道的同学非常欢迎留言, 不甚感激.</span>
Please enter the gitlab-ci token <span class="token keyword">for</span> this runner:
XXXXXXXXXXXXXXXX 
Please enter the gitlab-ci description <span class="token keyword">for</span> this runner:
<span class="token punctuation">[</span>localhost.localdomain<span class="token punctuation">]</span>: XxxGoodName     <span class="token comment"># 取个好名字, 方便自己, 也方便他人.</span>
Please enter the gitlab-ci tags <span class="token keyword">for</span> this runner <span class="token punctuation">(</span>comma separated<span class="token punctuation">)</span>:
pioneer,maven <span class="token comment"># 使用逗号分割. </span>
Whether to run untagged builds <span class="token punctuation">[</span>true/false<span class="token punctuation">]</span>:  <span class="token comment"># 默认值为false。这句话的意思是：是否在没有标记tag的job上运行，如果选择默认值false，那没有标记tag的代码提交是不会触发gitlab runner的，如果做测试，最好填true。</span>
<span class="token punctuation">[</span>false<span class="token punctuation">]</span>: <span class="token boolean">false</span>
Whether to lock Runner to current project <span class="token punctuation">[</span>true/false<span class="token punctuation">]</span>:
<span class="token punctuation">[</span>false<span class="token punctuation">]</span>: <span class="token boolean">false</span>
Registering runner<span class="token punctuation">..</span>. succeeded                     runner<span class="token operator">=</span>ZXxxxx
Please enter the executor: docker, shell, virtualbox, docker+machine, docker-ssh+machine, docker-ssh, parallels, ssh, kubernetes:
shell
Runner registered successfully. Feel <span class="token function">free</span> to start it, but <span class="token keyword">if</span> it's running already the config should be automatically reloaded<span class="token operator">!</span> 

<span class="token comment">######## 安装Runner并作为服务运行</span>
gitlab-runner <span class="token function">install</span> --user<span class="token operator">=</span>gitlab-runner --working-directory<span class="token operator">=</span>/home/gitlab-runner
gitlab-runner start

<span class="token comment"># 查看服务状态</span>
<span class="token function">service</span> gitlab-runner status
</code></pre> 
<h6><a id="21_URLTOKEN_61"></a>2.1 获取配置项URL和TOKEN</h6> 
<p>Runner大体分为两类：</p> 
<ol><li>Shared Runner（所有项目共用的）<br> <img src="https://images2.imgbox.com/93/30/ahqWOXaE_o.png" alt="获取URL和TOKEN"></li><li>Specific Runner（针对特定的项目）<br> <img src="https://images2.imgbox.com/36/5c/tO4vZFzk_o.png" alt="获取URL和TOKEN"></li></ol> 
<h6><a id="22_GitLabRunner_68"></a>2.2 GitLab中的Runner信息</h6> 
<ol><li>GitLab知晓的Runner配置信息。<br> <img src="https://images2.imgbox.com/44/4a/54kwRWYK_o.png" alt="Runner配置信息"></li><li>归属于特定Project的Runner<br> <img src="https://images2.imgbox.com/4b/8e/OTM3opAZ_o.png" alt="归属于Project的Runner"></li></ol> 
<h6><a id="23__74"></a>2.3 几个关键路径</h6> 
<ol><li> <p>配置文件路径</p> <pre><code class="prism language-bash">/etc/gitlab-runner/config.toml              on *nix systems when GitLab Runner is executed as root <span class="token punctuation">(</span>this is also path <span class="token keyword">for</span> <span class="token function">service</span> configuration<span class="token punctuation">)</span>
~/.gitlab-runner/config.toml                on *nix systems when GitLab Runner is executed as non-root
./config.toml                               on other systems
</code></pre> </li><li> <p>工作目录<code>/home/gitlab-runner/</code></p> <pre><code class="prism language-bash">/home/gitlab-runner/
	.bash_history
	.bash_logout
	.bash_profile
	.bashrc
	builds
	cache
	.m2
	.oracle_jre_usage
	.ssh
</code></pre> </li></ol> 
<h4><a id="3_gitlabciyml_97"></a>3. 配置<code>.gitlab-ci.yml</code></h4> 
<p>这里直接给一个测试成功的SpringBoot应用编译, 打包, 部署的配置模板。</p> 
<pre><code class="prism language-yaml"><span class="token comment"># 缓存服务, 如果有文件需要多个stages共用，例如jar/war包</span>
<span class="token key atrule">cache</span><span class="token punctuation">:</span>
  <span class="token key atrule">paths</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> target/

<span class="token key atrule">variables</span><span class="token punctuation">:</span>
  <span class="token key atrule">USERNAME</span><span class="token punctuation">:</span> <span class="token string">"Xxxx"</span>
  <span class="token key atrule">PASSWORD</span><span class="token punctuation">:</span> <span class="token string">"Xxxx"</span>
  <span class="token key atrule">IP</span><span class="token punctuation">:</span> <span class="token string">"xx.xx.xx.xx"</span>
  
<span class="token comment"># 本次构建的阶段：build package deploy</span>
<span class="token key atrule">stages</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> build
<span class="token punctuation">-</span> package
<span class="token punctuation">-</span> deploy
<span class="token comment"># 构建 Job</span>
<span class="token key atrule">build</span><span class="token punctuation">:</span>
  <span class="token key atrule">stage</span><span class="token punctuation">:</span> build
  <span class="token key atrule">tags</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> maven
  <span class="token key atrule">script</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> echo "=============== 开始编译构建任务 ==============="
  <span class="token punctuation">-</span> mvn clean compile
<span class="token comment"># 打包</span>
<span class="token key atrule">package</span><span class="token punctuation">:</span>
  <span class="token key atrule">stage</span><span class="token punctuation">:</span> package
  <span class="token key atrule">tags</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> maven  <span class="token comment"># 这里和上面我们在注册Runner时候输入的maven tag对应</span>
  <span class="token key atrule">script</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> echo "=============== 开始打包任务  ==============="
  <span class="token comment"># 这里的 ./ 路径指代项目根目录, 即: /home/gitlab-runner/builds/a9240569/0/root/projectName/</span>
  <span class="token punctuation">-</span> mvn package <span class="token punctuation">-</span>Dmaven.test.skip=true <span class="token punctuation">-</span>P product <span class="token punctuation">-</span>Dbuild.assemblySavePath=./target/
<span class="token comment"># 部署</span>
<span class="token key atrule">deploy</span><span class="token punctuation">:</span>
  <span class="token key atrule">stage</span><span class="token punctuation">:</span> deploy
  <span class="token key atrule">tags</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> maven
  <span class="token key atrule">script</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> echo "=============== 开始部署任务  ==============="
  <span class="token comment"># 测试，是否能够通过 ssh 连通远程服务器</span>
  <span class="token punctuation">-</span> sshpass <span class="token punctuation">-</span>p $PASSWORD ssh <span class="token punctuation">-</span>o StrictHostKeychecking=no $USERNAME@$IP
  <span class="token punctuation">-</span> echo "=============== 将 war 包部署到远程服务器上  ==============="
  <span class="token punctuation">-</span> sshpass <span class="token punctuation">-</span>p $PASSWORD scp <span class="token punctuation">-</span>o StrictHostKeychecking=no target/projectName<span class="token punctuation">-</span>bin.zip $USERNAME@$IP<span class="token punctuation">:</span>/root/projectName<span class="token punctuation">-</span>bin.zip
  <span class="token punctuation">-</span> echo "=============== 开始执行  ==============="
  <span class="token comment"># 执行shell脚本的时候必须要用命令：source xx.sh，如果只是单纯的执行命令./xx.sh，则切换目录命令cd不会被执行</span>
  <span class="token punctuation">-</span> sshpass <span class="token punctuation">-</span>p $PASSWORD ssh <span class="token punctuation">-</span>o StrictHostKeychecking=no $USERNAME@$IP "cd /root &amp;&amp; source ./deploy.sh"  

</code></pre> 
<h4><a id="4__149"></a>4. 效果</h4> 
<p><img src="https://images2.imgbox.com/09/7c/t7aayfTX_o.png" alt="在这里插入图片描述"><br> 单个Pipeline内部：<br> <img src="https://images2.imgbox.com/09/91/kV6hW39b_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5_CI_153"></a>5. 关闭CI功能</h4> 
<ol><li>参见 <a href="https://docs.gitlab.com/ee/ci/enable_or_disable_ci.html" rel="nofollow">Office Site - enable_or_disable_ci</a>，实现在项目级别管理CI功能：<br> <img src="https://images2.imgbox.com/63/d4/0jW4U3UZ_o.png" alt="关闭CI功能-项目级"></li><li>全局范围内，依然是参见上述官方文档，这里就不展开了。</li></ol> 
<h4><a id="6__158"></a>6. 概念解释</h4> 
<p>我们有必要对GitLab中的一些组件进行了解。</p> 
<h6><a id="61_GitLabCI_160"></a>6.1 GitLab-CI</h6> 
<ol><li>GitLab-CI是GitLab Continuous Integration（Gitlab持续集成）的简称，是GitLab自带的一套持续集成工具。</li><li>从Gitlab的8.0版本开始，gitlab就全面集成了Gitlab-CI,并且对所有项目默认开启。（jenkins+webhook 也可以实现持续集成）</li><li>只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次合并请求（MR）或者push都会触发CI pipeline。</li></ol> 
<h6><a id="62_gitlabciyml_165"></a>6.2 .gitlab-ci.yml</h6> 
<p>这个是在git项目的根目录下的一个文件，记录了一系列的阶段和执行规则，包含一系列的执行脚本和指定的runner名称。GitLab-CI在push后会解析它，根据里面的内容调用runner来运行。</p> 
<h6><a id="63_GitLabRunner_168"></a>6.3 GitLab-Runner</h6> 
<p>GitLab-Runner是<code>.gitlab-ci.yml</code>脚本的运行器，Gitlab-Runner是基于Gitlab-CI的API进行构建的相互隔离的机器（或虚拟机）。GitLab Runner 不需要和Gitlab安装在同一台机器上，但是考虑到GitLab Runner的资源消耗问题和安全问题，也<strong>不建议这两者安装在同一台机器上</strong>。</p> 
<p>可以分类两种类型：Shared Runner和Specific Runner。</p> 
<ol><li>Shared Runner：所有工程都能够用的。只有系统管理员能够创建Shared Runner。</li><li>Specific Runner：只能为指定的工程服务。拥有该工程权限的人都能够为该工程创建Shared Runner。</li></ol> 
<h6><a id="64_Pipelineshttpsdocsgitlabcomeecipipelines_175"></a>6.4 <a href="https://docs.gitlab.com/ee/ci/pipelines/" rel="nofollow">Pipelines</a></h6> 
<p>Pipelines是定义于<code>.gitlab-ci.yml</code>中的不同阶段的不同任务。<br> 我们把Pipelines理解为流水线，流水线包含有多个阶段（stages），每个阶段包含有一个或多个工序（jobs），比如先购料、组装、测试、包装再上线销售，每一次push或者MR都要经过流水线之后才可以合格出厂。而<code>.gitlab-ci.yml</code>正是定义了这条流水线有哪些阶段，每个阶段要做什么事。</p> 
<p>任何提交或者merge request的合并都可以触发pipeline。</p> 
<p><strong>stages</strong><br> stages表示构建阶段。一次pipeline可以定义多个stages，他们特点如下：</p> 
<ol><li>所有stages会按照顺序运行。</li><li>所有stages完成后，该构建任务（pipeline)才会成功。</li><li>任何一个stage失败，后面的stages不会执行。</li></ol> 
<p><strong>job</strong><br> jobs表示构建工作，表示某个stage里面执行的工作。我们可以在stages里面定义多个jobs，这些jobs会有以下特点：</p> 
<ol><li>同一个stage中的的job会并行执行。</li><li>同一个stage中的全部jobs都成功时候，该stage才会成功。</li><li>如果任何一个job失败，那么该stage失败，即该构建任务失败。</li></ol> 
<h6><a id="65_Badgeshttpsdocsgitlabcomeeuserprojectbadgeshtml_194"></a>6.5 <a href="https://docs.gitlab.com/ee/user/project/badges.html" rel="nofollow">Badges(徽章)</a></h6> 
<p>当Pipelines执行完成，会生成徽章，你可以将这些徽章加入到你的README.md文件或者你的网站。</p> 
<h4><a id="7_Links_197"></a>7. Links</h4> 
<ol><li><a href="https://blog.csdn.net/wbf810207/article/details/90412358">gitlab-runner实现Spring Boot项目CI/CD</a></li><li><a href="https://blog.csdn.net/loy_184548/article/details/82113956">持续集成 Gitlab-CI 【Maven】</a></li><li><a href="https://docs.gitlab.com/ee/ci/introduction/" rel="nofollow">Office SIte - CI - Introduction</a></li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a286d9991c6a547ae25a5f5216164b8f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Join</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/368c52c58bc2a7275067a765a55663d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QQ 音乐加密音乐文件格式转换并附加专辑图片教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>