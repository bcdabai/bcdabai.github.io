<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>redis集群模式 -cluster - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="redis集群模式 -cluster" />
<meta property="og:description" content="当遇到大的数据占用redis内存，或者说高并发的数据和流量都超过了单台redis的处理能力的时候，我们就需要搭建使用redis的集群模式了。
RedisCluster是Redis 提供的集群化方案，它是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。
RedisCluster是去中心化的，我们需要将每个redis节点设置成集群模式，每个节点负责整个集群的一部分数据，每个节点负责的数据多少可能不一样。多个节点相互连接组成一个对等的集群，它们之间通过一种特殊的二进制协议相互交互集群信息。
当集群中的某一个的redis节点出现了异常，Rediscluster会完成节点的移除和故障转移。
因为 RedisCluster 是去中心化的，一个节点认为某个节点失联了并不代表所有的节点都认为它失联了。所以集群还得经过一次协商的过程，只有当大多数节点都认定了某个节点失联了，集群才认为该节点需要进行主从切换来容错。
Redis的集群至少是3主3从，且每个实例使用不同的配置文件。在cluster模式下，默认的,一般redis-master用于接收读写，而redis-slave则用于备份。
当有请求是在向slave发起时，会直接重定向到对应key所在的master来处理。 但如果不介意读取的是redis-cluster中有可能过期的数据并且对写请求不感兴趣时，则亦可通过readonly命令，将slave设置成可读，然后通过slave获取相关的key，达到读写分离。
哈希槽-slots
在cluster集群里会有16384个哈希槽(hash slot),在设置Redis的键(key)时，会先用CRC16算法对key运算，并用16384对运算结果取模，结果是多少，就把这个key放入该结果所编号的哈希槽里。
读取key的操作和写操作相反，先用上述公式求得对应的槽编号，再到对应的哈希槽里取
cluster集群中的每个节点会被平分到一定数量的哈希槽用来存储数据，这样不管是集群中那个几点进行key的操作都需要去16384个哈希槽中寻找对应的槽然后寻找key即可。
Cluster集群环境搭建：
Redis为了其高可用性，要求我们的集群几点数量至少是6个节点，这6个节点也会有节点形成主从关系,即3主3从的环境，并且对于从节点不需要我们进行之前主从的配置，也就是说这6个节点都是跟之前的主节点一样的差不多的配置，只不过需要我们在每个配置文件中开启Cluster集群模式，添加如下信息:
这里我们使用不同的端口号来模拟不同的redis节点 (如果服务器数量足够那么端口都是6379，只是IP7
同而已)。
创建6个节点成功之后，我们随意的进入其中一个容器，然后创建redis集群:
注意：
在redis的老的一些版本需要我们自己写shel脚本对redis集群中的16384个横位进行，而且必须分配完所有的哈希槽，脚本案例如下:
后来的版本中 Redis Cluster提供了 cluster create 命令创建集群，使用这个命令Redis 会自动把这些槽平均分布在集群实例上，这样就变得更加的方便。命令使用如下:
--cluster-replicas 1: 表示一个master配置几个slave节点，这里表示一主一从" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9f20c9d3c9561d6141552b99ea0e5c5e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-21T19:22:32+08:00" />
<meta property="article:modified_time" content="2023-03-21T19:22:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">redis集群模式 -cluster</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>当遇到大的数据占用redis内存，或者说高并发的数据和流量都超过了单台redis的处理能力的时候，我们就需要搭建使用redis的集群模式了。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>RedisCluster是Redis 提供的集群化方案，它是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>RedisCluster是去中心化的，我们需要将每个redis节点设置成集群模式，每个节点负责整个集群的一部分数据，每个节点负责的数据多少可能不一样。多个节点相互连接组成一个对等的集群，它们之间通过一种特殊的二进制协议相互交互集群信息。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>当集群中的某一个的redis节点出现了异常，Rediscluster会完成节点的移除和故障转移。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>因为 RedisCluster 是去中心化的，一个节点认为某个节点失联了并不代表所有的节点都认为它失联了。所以集群还得经过一次协商的过程，只有当大多数节点都认定了某个节点失联了，集群才认为该节点需要进行主从切换来容错。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>Redis的集群至少是3主3从，且每个实例使用不同的配置文件。在cluster模式下，默认的,一般redis-master用于接收读写，而redis-slave则用于备份。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>当有请求是在向slave发起时，会直接重定向到对应key所在的master来处理。 但如果不介意读取的是redis-cluster中有可能过期的数据并且对写请求不感兴趣时，则亦可通过readonly命令，将slave设置成可读，然后通过slave获取相关的key，达到读写分离。</p></li></ul> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">哈希槽-slots</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>在cluster集群里会有16384个哈希槽(hash slot),在设置Redis的键(key)时，会先用CRC16算法对key运算，并用16384对运算结果取模，结果是多少，就把这个key放入该结果所编号的哈希槽里。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>读取key的操作和写操作相反，先用上述公式求得对应的槽编号，再到对应的哈希槽里取</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>cluster集群中的每个节点会被平分到一定数量的哈希槽用来存储数据，这样不管是集群中那个几点进行key的操作都需要去16384个哈希槽中寻找对应的槽然后寻找key即可。</p></li></ul> 
 <p style=""></p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">Cluster集群环境搭建：</span></p> 
 <p style="">Redis为了其高可用性，要求我们的集群几点数量至少是6个节点，这6个节点也会有节点形成主从关系,即3主3从的环境，并且对于从节点不需要我们进行之前主从的配置，也就是说这6个节点都是跟之前的主节点一样的差不多的配置，只不过需要我们在每个配置文件中开启Cluster集群模式，添加如下信息:</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:469px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:25.159914%;height:0;"> 
    <img src="https://images2.imgbox.com/2a/51/ZyrST3nA_o.png" style="margin-left:;display:block;width:469px;margin-top:-25.159914%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">这里我们使用不同的端口号来模拟不同的redis节点 (如果服务器数量足够那么端口都是6379，只是IP7</p> 
 <p style="">同而已)。</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:726px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:13.0854%;height:0;"> 
    <img src="https://images2.imgbox.com/51/f7/CgSqoI7v_o.png" style="margin-left:;display:block;width:726px;margin-top:-13.0854%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">创建6个节点成功之后，我们随意的进入其中一个容器，然后创建redis集群:</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:729px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:5.0754457%;height:0;"> 
    <img src="https://images2.imgbox.com/a4/92/yEc9WW3P_o.png" style="margin-left:;display:block;width:729px;margin-top:-5.0754457%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">注意：</span></p> 
 <p style="">在redis的老的一些版本需要我们自己写shel脚本对redis集群中的16384个横位进行，而且必须分配完所有的哈希槽，脚本案例如下:</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:583px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:45.111492%;height:0;"> 
    <img src="https://images2.imgbox.com/87/21/AasHaLgr_o.png" style="margin-left:;display:block;width:583px;margin-top:-45.111492%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">后来的版本中 Redis Cluster提供了 cluster create 命令创建集群，使用这个命令Redis 会自动把这些槽平均分布在集群实例上，这样就变得更加的方便。命令使用如下:</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:769px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:8.322496%;height:0;"> 
    <img src="https://images2.imgbox.com/0c/d6/2pgrRp2l_o.png" style="margin-left:;display:block;width:769px;margin-top:-8.322496%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">--cluster-replicas 1: 表示一个master配置几个slave节点，这里表示一主一从</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:786px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:33.71501%;height:0;"> 
    <img src="https://images2.imgbox.com/62/c5/j7iuk2zs_o.png" style="margin-left:;display:block;width:786px;margin-top:-33.71501%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/407ec77255dd9f90ccb32ced24d743cf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Simscape仿真_开环倒立摆</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ab3af95c248802b5959d5acca43e25e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Simulink模型保存为高分辨率图片</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>