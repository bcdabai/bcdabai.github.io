<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker和k8s基础介绍 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker和k8s基础介绍" />
<meta property="og:description" content="一 Docker介绍 1.1 docker是什么 Docker 是一个开源项目， 诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0协议， 项目代码在 GitHub 上进行维护。Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容（ LXC）等技术。在 LXC 的基础上 Docker 进行了进一步的封装， 让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。
官方解释:
1.2 为什么要用docker 作为一种新兴的虚拟化方式， Docker 跟传统的虚拟化方式相比具有众多的优势。首先， Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。具体说来， Docker 在如下几个方面具有较大的优势:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f7287a78bd6f1135128867f1ad132385/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-20T16:05:16+08:00" />
<meta property="article:modified_time" content="2023-10-20T16:05:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker和k8s基础介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_Docker_0"></a>一 Docker介绍</h2> 
<h3><a id="11_docker_2"></a>1.1 docker是什么</h3> 
<p>  Docker 是一个开源项目， 诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0协议， 项目代码在 GitHub 上进行维护。Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容（ LXC）等技术。在 LXC 的基础上 Docker 进行了进一步的封装， 让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。<br> 官方解释:<br> <img src="https://images2.imgbox.com/3a/79/58aCHoEm_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="12_docker_6"></a>1.2 为什么要用docker</h3> 
<p>  作为一种新兴的虚拟化方式， Docker 跟传统的虚拟化方式相比具有众多的优势。首先， Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。具体说来， Docker 在如下几个方面具有较大的优势:</p> 
<ol><li><strong>更快速的交付和部署</strong>：对开发和运维（ devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后， 运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、 测试、部署的时间。</li><li><strong>更高效的虚拟化：</strong> Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。</li><li><strong>更轻松的迁移和扩展</strong> ：Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。</li><li><strong>更简单的管理</strong> ：使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</li></ol> 
<p>对比传统的虚拟机docker的好处：<br> <img src="https://images2.imgbox.com/d4/cd/L0BUSGHo_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="13_docker_15"></a>1.3 docker的基本概念</h3> 
<ol><li><strong>镜像(Image)</strong></li></ol> 
<blockquote> 
 <p>  镜像，从认识上简单的来说，就是面向对象中的类，相当于一个模板。从本质上来说，镜像相当于一个文件系统。Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p> 
</blockquote> 
<p>2.<strong>容器(Container)</strong></p> 
<blockquote> 
 <p>  容器，从认识上来说，就是类创建的实例，就是依据镜像这个模板创建出来的实体。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p> 
</blockquote> 
<p>3.<strong>仓库(Repository)</strong></p> 
<blockquote> 
 <p>  仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（ Registry）混为一谈，并不严格区分。 实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（ tag）。仓库分为公开仓库（ Public）和私有仓库（ Private） 两种形式。<br> 最大的公开仓库是 Docker Hub(https://hub.docker.com)存放了数量庞大的镜像供用户下载。 国内的公开仓库包括 Docker Pool(http://dockerpool.com) 等，可以提供大陆用户更稳定快速的访问。<br> 当然，用户也可以在本地网络内创建一个私有仓库。当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p> 
</blockquote> 
<h3><a id="14_docker_31"></a>1.4 docker的安装</h3> 
<ol><li>centos(7以上)</li></ol> 
<pre><code class="prism language-java">yum install docker
systemctl enable docker
systemctl start docker
</code></pre> 
<ol start="2"><li>Ubuntu</li></ol> 
<pre><code class="prism language-java">apt<span class="token operator">-</span>get update
apt<span class="token operator">-</span>get install <span class="token operator">-</span>y apt<span class="token operator">-</span>transport<span class="token operator">-</span>https ca<span class="token operator">-</span>certificates curl software<span class="token operator">-</span>properties<span class="token operator">-</span>common
curl <span class="token operator">-</span>fsSL https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>download<span class="token punctuation">.</span>docker<span class="token punctuation">.</span>com<span class="token operator">/</span>linux<span class="token operator">/</span>ubuntu<span class="token operator">/</span>gpg <span class="token operator">|</span> sudo apt<span class="token operator">-</span>key add <span class="token operator">-</span>
sudo add<span class="token operator">-</span>apt<span class="token operator">-</span>repository “deb <span class="token punctuation">[</span>arch<span class="token operator">=</span>amd64<span class="token punctuation">]</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>download<span class="token punctuation">.</span>docker<span class="token punctuation">.</span>com<span class="token operator">/</span>linux<span class="token operator">/</span>ubuntu $<span class="token punctuation">(</span>lsb_release <span class="token operator">-</span>cs<span class="token punctuation">)</span> stable”
apt<span class="token operator">-</span>get update
apt<span class="token operator">-</span>cache madison docker<span class="token operator">-</span>ce
#安装指定版
#apt<span class="token operator">-</span>get install docker<span class="token operator">-</span>ce<span class="token operator">=</span><span class="token number">17.12</span><span class="token number">.0</span>ce<span class="token operator">-</span><span class="token number">0</span>ubuntu
#安装最新版
apt<span class="token operator">-</span>get install docker<span class="token operator">-</span>ce
systemctl enable docker
systemctl start docker
</code></pre> 
<h3><a id="15_docker_56"></a>1.5 docker的基础命令</h3> 
<pre><code class="prism language-java"><span class="token number">1</span><span class="token punctuation">,</span>docker info<span class="token operator">:</span> 查看当前docker的所有配置信息
<span class="token number">2</span><span class="token punctuation">,</span>docker pull <span class="token punctuation">[</span>镜像名称<span class="token punctuation">]</span><span class="token operator">:</span>	远程拉取image<span class="token punctuation">.</span> eg<span class="token operator">:</span> <span class="token punctuation">[</span>docker pull library<span class="token operator">/</span>hello<span class="token operator">-</span>world <span class="token operator">-</span>等同于<span class="token operator">-&gt;</span> docker pull hello<span class="token operator">-</span>world<span class="token punctuation">]</span>其中library是image所在的组，docker官方的
    镜像都在这个组内<span class="token punctuation">.</span>docker pull hello<span class="token operator">-</span>world等同于 docker pull hello<span class="token operator">-</span>world<span class="token punctuation">.</span>
    拉取<span class="token class-name">DockPool</span>镜像<span class="token operator">:</span> docker pull dl<span class="token punctuation">.</span>dockerpool<span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">5000</span><span class="token operator">/</span><span class="token punctuation">{<!-- --></span><span class="token constant">IMAGE_NAME</span><span class="token punctuation">}</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span><span class="token constant">TAG</span><span class="token punctuation">}</span>
<span class="token number">3</span><span class="token punctuation">,</span>docker build	创建image
    docker build <span class="token operator">-</span>f cenosAddVimDockerfile <span class="token operator">-</span>t mycentos<span class="token operator">:</span><span class="token number">1.0</span> <span class="token punctuation">.</span>
<span class="token number">4</span><span class="token punctuation">,</span>docker images<span class="token operator">:</span>	列出本地所有的image
    docker load <span class="token operator">-</span>i 镜像名称<span class="token punctuation">.</span>tar
    docker tag <span class="token punctuation">[</span>镜像id<span class="token punctuation">]</span>   <span class="token punctuation">[</span>新镜像名称<span class="token punctuation">]</span><span class="token operator">:</span><span class="token punctuation">[</span>新镜像标签<span class="token punctuation">]</span>
    
<span class="token number">5</span><span class="token punctuation">,</span>docker run<span class="token operator">:</span> 运行容器container
    docker run <span class="token punctuation">[</span>可选参数<span class="token punctuation">]</span> image 命令 #启动容器（无镜像会先下载镜像）
    #参数说明
    <span class="token operator">--</span>name <span class="token operator">=</span> <span class="token string">"Name"</span>   容器名字
    <span class="token operator">-</span>c   后面跟待完成的命令
    <span class="token operator">-</span>d   以后台方式运行并且返回<span class="token constant">ID</span>，启动守护进程式容器
    <span class="token operator">-</span>i   使用交互方式运行容器，通常与t同时使用
    <span class="token operator">-</span>t   为容器重新分配一个伪输入终端。也即启动交互式容器
    <span class="token operator">-</span>p   指定容器端口    <span class="token operator">-</span>p 容器端口<span class="token operator">:</span>物理机端口  映射端口
    <span class="token operator">-</span><span class="token class-name">P</span>   随机指定端口
    <span class="token operator">-</span>v   给容器挂载存储卷 
        <span class="token operator">-</span>v  容器内路径               #匿名挂在
        <span class="token operator">-</span>v  卷名：容器内路径          #具名挂在
        <span class="token operator">-</span>v  <span class="token operator">/</span>宿主机路径：容器内路径    # 指定路径挂载
        <span class="token operator">-</span>v  <span class="token operator">/</span>宿主机路径：容器内路径<span class="token operator">:</span>ro   # 指定路径挂载<span class="token punctuation">,</span>并设置只读权限
        <span class="token operator">-</span>v  <span class="token operator">/</span>宿主机路径：容器内路径<span class="token operator">:</span>rw   # 指定路径挂载<span class="token punctuation">,</span>并设置读写权限默认是rw
    第一种：交互方式创建容器，退出后容器关闭<span class="token operator">:</span> docker run <span class="token operator">-</span>it 镜像名称<span class="token operator">:</span>标签 <span class="token operator">/</span>bin<span class="token operator">/</span>bash
    第二种：守护进程方式创建容器<span class="token operator">:</span> docker run <span class="token operator">-</span>id 镜像名称<span class="token operator">:</span>标签<span class="token punctuation">.</span>
        通过这种方式创建的容器，我们不会直接进入到容器界面，而是在后台运行了容器，如果我们需要进去，则还需要一个命令。
    docker exec <span class="token operator">-</span>it  containerID  <span class="token operator">/</span>bin<span class="token operator">/</span>bash<span class="token operator">:</span> 通过这种方式运行的容器，当使用exit退出时，容器不会停止，需要停止输入：docker stop containerID
    就可以停止容器，只有停止的容器才能删除<span class="token punctuation">.</span>
    docker attach containerID<span class="token operator">:</span>对于正在运行的容器，使用该命令可以进入容器，输入exti会停止容器
    docker rename 原容器名 新容器名

<span class="token number">6</span><span class="token punctuation">,</span>docker ps<span class="token operator">:</span>    列出当前运行的容器container
    docker container ls<span class="token operator">:</span> 列出本机正在运行的容器
    docker container ls <span class="token operator">-</span>all<span class="token operator">:</span> 列出本机所有容器，包括终止运行的容器
<span class="token number">7</span><span class="token punctuation">,</span>docker <span class="token punctuation">[</span>rm ｜ stop <span class="token operator">|</span> restart<span class="token punctuation">]</span> <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span><span class="token operator">:</span>	删除已经结束的容器container <span class="token operator">=</span><span class="token operator">&gt;</span> 等价于<span class="token operator">:</span>docker container rm <span class="token punctuation">[</span>containerID<span class="token punctuation">]</span><span class="token operator">:</span>
<span class="token number">8</span><span class="token punctuation">,</span>docker cp <span class="token punctuation">[</span>当前文件的<span class="token punctuation">]</span> <span class="token punctuation">[</span>容器id<span class="token operator">:</span><span class="token operator">/</span>容器下面的文件目录<span class="token punctuation">]</span>	在本地和容器之间拷贝文件
<span class="token number">9</span><span class="token punctuation">,</span>docker commit <span class="token operator">-</span>m <span class="token punctuation">[</span>提示信息<span class="token punctuation">]</span> <span class="token punctuation">[</span>容器id<span class="token punctuation">]</span> <span class="token punctuation">[</span>新镜像名称<span class="token punctuation">]</span><span class="token operator">:</span> 保存改动生成新的image
<span class="token number">10</span><span class="token punctuation">,</span>docker rmi	删除image
</code></pre> 
<h3><a id="16_docker_101"></a>1.6 docker私有仓库搭建</h3> 
<p><a href="https://blog.csdn.net/my_miuye/article/details/123030029">点击参考地址</a></p> 
<h3><a id="17_DockerFile_104"></a>1.7 DockerFile</h3> 
<p>  Dockerfile 是一个由一堆命令+参数构成的脚本，使用 docker build 即可执行脚本构建镜像，自动的去做一些事，主要用于进行持续集成。<br> 具体命令如下：</p> 
<pre><code class="prism language-java"><span class="token number">1.F</span><span class="token constant">ROM</span><span class="token operator">:</span>
    <span class="token number">1.F</span><span class="token constant">ROM</span>指定一个基础镜像， 一般情况下一个可用的 <span class="token class-name">Dockerfile</span>一定是<span class="token constant">FROM</span>为第一个指令。至于image则可以是任何合理存在的image镜像。
    <span class="token number">2.F</span><span class="token constant">ROM</span> 一定是首个非注释指令 <span class="token class-name">Dockerfile</span>。
    <span class="token number">3.F</span><span class="token constant">ROM</span> 可以在一个 <span class="token class-name">Dockerfile</span> 中出现多次，以便于创建混合的images。
    <span class="token number">4.</span>如果没有指定 tag ，latest 将会被指定为要使用的基础镜像版本
<span class="token number">2.</span><span class="token constant">MAINTAINER</span> <span class="token operator">|</span> <span class="token constant">LABEL</span><span class="token operator">:</span>
    这里是用于指定镜像制作者的信息。（已被弃用，目前是使用<span class="token constant">LABEL</span>代替）
    <span class="token constant">LABEL</span> 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：
    <span class="token constant">LABEL</span> <span class="token generics"><span class="token punctuation">&lt;</span>key<span class="token punctuation">&gt;</span></span><span class="token operator">=</span><span class="token generics"><span class="token punctuation">&lt;</span>value<span class="token punctuation">&gt;</span></span> <span class="token generics"><span class="token punctuation">&lt;</span>key<span class="token punctuation">&gt;</span></span><span class="token operator">=</span><span class="token generics"><span class="token punctuation">&lt;</span>value<span class="token punctuation">&gt;</span></span> <span class="token generics"><span class="token punctuation">&lt;</span>key<span class="token punctuation">&gt;</span></span><span class="token operator">=</span><span class="token generics"><span class="token punctuation">&lt;</span>value<span class="token punctuation">&gt;</span></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    比如我们可以添加镜像的作者：
        <span class="token constant">LABEL</span> org<span class="token punctuation">.</span>opencontainers<span class="token punctuation">.</span>image<span class="token punctuation">.</span>authors<span class="token operator">=</span><span class="token string">"runoob"</span>
<span class="token number">3.</span><span class="token constant">RUN</span><span class="token operator">:</span>
    用来修改镜像的命令，常用来安装库、程序以及配置程序。一条<span class="token constant">RUN</span>指令执行完毕后，会在当前镜像上创建一个新的镜像层，接下来对的指令会
    <span class="token number">1</span>在新的镜像上继续执行。
<span class="token number">4.</span><span class="token constant">CMD</span><span class="token operator">:</span> 用来设置启动容器时默认运行的命令。类似于 <span class="token constant">RUN</span> 指令，用于运行程序（只有最后一个会生效，可被替代）
<span class="token number">5.</span><span class="token constant">EXPOSE</span><span class="token operator">:</span> 用来指明容器内进程对外开放的端口，多个端口之间使用空格隔开。
<span class="token number">6.</span><span class="token constant">ENV</span><span class="token operator">:</span>#设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量                
    <span class="token number">1.</span><span class="token constant">ENV</span>指令可以用于为docker容器设置环境变量
    <span class="token number">2.</span><span class="token constant">ENV</span>设置的环境变量，可以使用 docker inspect命令来查看。同时还可以使用docker run <span class="token operator">--</span>env <span class="token operator">=</span>来修改环境变量。。
<span class="token number">7.</span><span class="token constant">ADD</span><span class="token operator">:</span>                   # 步骤：tomcat镜像，这个tomcat压缩包。添加内容。
    <span class="token constant">ADD</span> 将文件从路径 复制添加到容器内部路径 。向新镜像中添加文件，这个文件可以是一个主机文件，也可以是一个网络文件，
    也可以使一个文件夹。
    第一个参数：源文件（夹），如果是相对路径，它必须是相对于<span class="token class-name">Dockerfile</span>所在目录的相对路径。如果是<span class="token constant">URL</span>，会先下载下来，再添加到镜像里去。
    第二个参数：目标路径。如果源文件是主机上zip或者tar形式的压缩文件，<span class="token class-name">Docker</span>会先解压缩，然后将文件添加到镜像的指定位置。如果源文件是一个通过<span class="token constant">URL</span>指定的网络压缩文件，则不会解压。
<span class="token number">8.</span><span class="token constant">COPY</span><span class="token operator">:</span> <span class="token constant">COPY</span> 将文件从路径 复制添加到容器内部路径。必须是想对于源文件夹的一个文件或目录，也可以是一个远程的url， 
    是目标容器中的绝对路径。
<span class="token number">9.</span><span class="token constant">VOLUME</span><span class="token operator">:</span> 创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。
<span class="token number">10.</span><span class="token constant">USER</span><span class="token operator">:</span> 用于指定执行后续命令的用户和用户组<span class="token punctuation">,</span>这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。
<span class="token number">11.</span><span class="token constant">WORKDIR</span><span class="token operator">:</span> 为接下来执行的指令指定一个新的工作目录，这个目录可以使绝对目录，也可以是相对目录
<span class="token number">12.</span><span class="token constant">ENTRYPOINT</span><span class="token operator">:</span> 类似于 <span class="token constant">CMD</span> 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，会追加命令。
<span class="token number">13.</span><span class="token constant">ONBUILD</span><span class="token operator">:</span> 当构建一个被继承<span class="token class-name">Dokcerfile</span>，就会运行<span class="token constant">ONBUILD</span>的指令。出发执行。

注意：<span class="token constant">CMD</span>类似于 <span class="token constant">RUN</span> 指令，用于运行程序，但二者运行的时间点不同<span class="token operator">:</span>
    <span class="token constant">CMD</span> 在docker run 时运行。
    <span class="token constant">RUN</span> 是在 docker build。
作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。
    <span class="token constant">CMD</span> 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。
    如果 <span class="token class-name">Dockerfile</span> 中如果存在多个 <span class="token constant">CMD</span> 指令，仅最后一个生效。

</code></pre> 
<hr> 
<h2><a id="_Kubernetes_151"></a>二 Kubernetes介绍</h2> 
<h3><a id="21_Kubernetes_153"></a>2.1 Kubernetes是什么</h3> 
<p>  Kubernetes(<strong>通常称为K8s</strong>，K8s是将8个字母“ubernete”替换为“8”的缩写)是一个完备的分布式系统支撑平台。Kubernetes具有完备的集群管理能力，包括多层次的安全防护和准入机制/多租户应用支撑能力、透明的服务注册和服务发现机制、内建智能负载均衡器、强大的故障发现和自我修复功能、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制，以及多粒度的资源配额管理能力。同时kubernetes提供了完善的管理工具，这些工具覆盖了包括开发、测试部署、运维监控在内的各个环节；因此kubernetes是一个全新的基于容器技术的分布式架构解决方案，并且是一个一站式的完备的分布式系统开发和支撑平台。<br> <img src="https://images2.imgbox.com/84/53/VbdOZseG_o.png" alt="在这里插入图片描述"><br> 具体架构如上图所示，下面来详细介绍一下各个模块的功能</p> 
<h3><a id="22_Master_158"></a>2.2 Master介绍</h3> 
<p>  Kubernetes 里的Master指的是集群控制节点，每个Kubernetes集群里需要有一个Master节点来负责整个集群的管理和控制，基本上Kubernetes所有的控制命令都发给它，它负责具体的执行过程，我们后面执行的所有命令基本上都是在Master节点上运行的。如果Master宕机或不可用，那么集群内容器的管理都将失效master节点上运行一些关键进程：</p> 
<ul><li><strong>k8s API server（kube-apiserver）</strong>：提供了HTTP Rest接口的关键服务进程，是所有资源的增删改查的唯一入口，也是集群集群控制的入口进程。kubectl的命令会调用到api server，来实现资源的增删查改。</li><li><strong>kube-controller-manager</strong>：k8s所有资源对象的自动化控制中心。</li><li><strong>kube-scheduler</strong>：调度客户端操作请求，选择合适的Node节点运行资源，例如：pod调度进程。</li><li><strong>etcd服务</strong>：k8s里所有资源对象的数据全部是保存在etcd中的，etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。<br> <img src="https://images2.imgbox.com/ed/a7/mqKImFBE_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="23_Node_165"></a>2.3 Node介绍</h3> 
<p>  除了Master，集群中其他机器被称为Node节点，每个Node都会被Master分配一些工作负载docker容器，当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上去。<br> 每个Node节点上都运行着以下一组关键进程：</p> 
<ul><li><strong>kubelet</strong>：负责Pod对应容器的创建、停止等任务，同时与Master节点密切协作，实现集群管理的基本功能。</li><li><strong>kube-proxy</strong>：实现Kubernetes Service的通信与负载均衡机制的重要组件。</li><li><strong>Docker Engine(Docker)</strong>：Docker引擎，负责本机的容器创建和管理工作。</li></ul> 
<p><img src="https://images2.imgbox.com/e9/9f/JkvTMSDh_o.png" alt="在这里插入图片描述"><br>   查看当前nodes：kubectl get nodes<br> 然后通过下面命令查看某个node的详细信息：kubectl describe node &lt;node_name&gt;</p> 
<h3><a id="24_Kubernetes_MasterNode_175"></a>2.4 Kubernetes 中Master与Node工作内容</h3> 
<p>  在集群管理方面，Kubernets将集群中的机器划分为一个Master节点和一群工作节点(Node),其中，在Master节点上运行着集群管理相关的一组进程kube-apiserver、kube-controller-manager和kube-scheduler，这些进程实现了整个集群的资源管理、Pod调度、弹性收缩、安全控制、系统监控和纠错等管理功能，并且都是全自动完成的。Node作为集群中的工作节点，运行真正的应用程序，在Node上Kubernetes管理的最小运行单元是Pod。Node上运行着Kubernetes的kubelet、kube-proxy服务进程，这些服务进程负责Pod创建、启动、监控、重启、销毁、以及实现软件模式的负载均衡<br> <img src="https://images2.imgbox.com/82/a9/iHgbp8ma_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="25_Pod_178"></a>2.5 Pod介绍</h3> 
<p>  Pod是kubernetes最重要也最基本的概念，如图所示是Pod的组成示意图，我们看到每个Pod都有一个特殊的被称为“根容器”的Pause容器对应的镜像属于Kubernetes的平台的一部分，除了Pause容器，每个Pod还包含一个或多个紧密相关的用户业务容器。<br> <img src="https://images2.imgbox.com/f4/f1/6ROC1wxW_o.png" alt="在这里插入图片描述"><br>   每个pod由一个根容器的pause容器，其他是业务容器。k8s为每个pod分配了唯一的IP地址，<strong>一个pod里的多个容器共享pod IP</strong>。</p> 
<p>  pod其实有两种类型：<strong>普通的pod和静态pod</strong>，后者比较特殊，它并不存放在etcd存储中，而是存放在某个具体的Node上的一个具体文件中，并且只在此Node上启动运行。而普通的pod一旦被创建，就会被放入etcd中存储。随后被master调度到某个具体的Node上并进行绑定，随后该pod被对应的Node上的kubelet进程实例化成一组相关的docker容器并启动起来。</p> 
<p>  每个pod都可以对其使用的服务器上的计算资源设置限额，当前可以设置限额的源有CPU和memory两种。其中CPU的资源单位为CPU的数量。一般而言，一个CPU的配额已经算是相当大的一个资源配额，所以在k8s中，通常以千分之一的CPU配额为最小单位，以m来表示，通常一个容器的CPU配额为100-300m，即占用0.1-0.3个CPU。这个配额是个绝对值，不是占比。</p> 
<p>  在k8s中，一个计算资源进行配额限定需要设定两个参数：requests，资源的最小申请量，系统必须满足要求</p> 
<h3><a id="26_Label_189"></a>2.6 Label</h3> 
<p>  一个label是一个key=value的键值组合，然后可以通过label selector（标签选择器）查询和筛选拥有某些label的资源对象。(Label 相当于我们熟悉的标签,给某个资源对象定义一个Label,就相当于给它打了一个标签,随后可以通过Label Selector 标签选择器 查询和筛选有某些Label的资源对象。Kubernetes通过这种方式实现了类似SQL的简单又通用的对象查询机制)。</p> 
<p>label的重要使用场景：<br>   kube-controller进程通过资源对象RC上定义的label selector来筛选要监控的pod的数量，从而实现全自动控制流程。<br> kube-proxy进程通过service的label selector来选择对应的pod，自动建立起每个service到对应pod的请求转发路由表。从而实现service的智能负载均衡机制。</p> 
<h3><a id="27_RCReplication_Controller_196"></a>2.7 RC（Replication Controller）</h3> 
<p> &amp;emsp当我们定义了一个RC并提交到Kubernetes集群中以后,Master节点上的Controller Manager组件就得到通知,定期巡检系统中当前存活的目标Pod,并确保目标Pod实力的数量刚好等于此RC的期望值,如果有过多的Pod副本在运行,系统就会停掉一些Pod,否则系统就会再自动创建一些Pod。 可以说，通过RC,Kubernetes实现了用户应用集群的高可用性,并大大减少了传统IT需要手动的工作。RC定义了如下</p> 
<ol><li>Pod期待的副本数(replicas)</li><li>用于筛选目标Pod的Label Seletcor(标签选择器)</li><li>当Pod的副本小于预期(replicas)时，用于创建新Pod的Pod模板(template)<br> 删除RC并不会影响通过该RC已创建号的Pod。为了删除所有Pod，可以设置replicas的值为0，然后更新该RC。另外,kubectl提供了stop和delete命令来一次性删除RC和RC控制的全部Pod</li></ol> 
<h3><a id="28_HPAhorizontal_Pod_Authosacler_Pod_203"></a>2.8 HPA(horizontal Pod Authosacler Pod横向自动扩容)</h3> 
<p>通过手动执行kubectl scale命令，可以通过RC实现pod扩容。HPA，pod横向自动扩容，实现原理是通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性地挑战目标pod的副本数。有两种方式作为pod负载的度量指标。</p> 
<ol><li>CPU utilization percentage：是一个算术平均值，目标pod所有副本自身的CPU利用率的平均值。一个Pod自身的CPU利用率是该Pod当前CPU使用量除以它的Pod request的值。比如当我们定义一个Pod的pod request为0.4，而当前pod的cpu使用量为0.2，则使用率为50%。如此可以得出一个平均值，如果某一个时刻CPU utilization percentage超过80%，则表示当前副本数不够，需要进行扩容.</li><li>应用程序自定义的度量指标，比如服务在每秒内的相应的请求数。</li></ol> 
<h3><a id="29_Service_209"></a>2.9 Service</h3> 
<p>Service是Kubernetes里最核心的资源对象之一,Service定义了一个服务的访问入口地址,前端的应用(Pod)通过这个入口地址访问其背后的一组由Pod副本组成的集群实力。 Service与其后端Pod副本集群之间则是通过Label Selector来实现"无缝对接"。而RC的作用实际上是保证Service 的服务能力和服务质量处于预期的标准。<br> 每个pod会被分配一个独立的IP地址，也就是每个pod都提供一个独立的endpoint（IP+port）以被访问，那多个pod如何被客户端访问呢，k8s通过运行在每个Node上的kube-proxy进程，负责将对service的请求转发到后端某个pod实例上，也就实现了类似负载均衡器的功能，至于具体转发到哪个pod，则由负载均衡器的算法所决定。并且service不是共用一个负载均衡器的IP地址，而是每一个service分配了一个全局唯一的虚拟IP，这样每个服务就变成了具有唯一IP的通信节点，服务调用也就变成了最为基础的TCP通信问题。</p> 
<p>pod的Endpoint地址会随着Pod的销毁和重新创建而发生改变,因为新的Pod地址与之前的旧的Pod不同。而Service一旦被创建,Kubernetes就会自动为它分配一个可用的Cluster IP,而且在Service的整个声明周期内,它的Cluster IP不会发生改变。所以只要将Service的name与Service的Cluster IP地址做一个DNS域名映射即可解决问题。<br> <strong>k8s的服务发现机制</strong>：每个service都有一个唯一的cluster IP以及唯一的名字，而名字是由开发者自己定义的，部署的时候也没必要改变，所以完全可以固定在配置中，接下来的问题 就是如何通过service的名字找到对应的cluster IP。</p> 
<p>外部系统访问service的问题:<br> k8s中有三种IP：</p> 
<ol><li>Node IP：node节点的IP地址</li><li>Pod IP：pod的IP地址</li><li>cluster IP：service IP</li></ol> 
<p>首先，Node IP是k8s集群中每个节点的物理网卡的IP地址，这是一个真实存在的物理网络，所有属于这个网络的服务器之间都能直接通信，不管属不属于k8s集群。这也表明了k8s集群之外的节点访问k8s集群之内的某个节点后者TCP/IP服务的时候，必须要通过Node IP通信。</p> 
<p>其次，pod IP是每个Pod的IP地址，它是根据docker网桥的IP地址段进行分配的，通常是一个虚拟的二层网络，因此不同pod之间的通信就是通过Pod IP所在的虚拟二层网络进行通信的。而真实的TCP/IP流量则是通过Node IP所在的物理网卡流出的。</p> 
<p>Cluster IP,它是一个虚拟IP,但更像是一个伪造的IP网络</p> 
<ul><li>Cluster IP仅仅作用于Kubernetes Service对象，并由Kubernetes管理和分配IP地址(来源于Cluster IP地址池)</li><li>Cluster IP无法被Ping,因为没有一个"实体网络对象"来响应</li><li>在Kubernetes集群内,Node IP、Pod IP、Cluster IP之间的通信，采用的是Kubernetes自己设计的特殊路由规则</li></ul> 
<h3><a id="210__Volume__232"></a>2.10 Volume 存储卷</h3> 
<p>Volume是pod中能够被多个容器访问的共同目录。也就是被定义在pod上，然后被一个pod中的多个容器挂载到具体的文件目录下，其次，volume与pod生命周期相同，但与容器生命周期不相关，当容器终止或重启，volume中的数据也不会丢失</p> 
<h3><a id="211_namespace_235"></a>2.11 namespace命名空间</h3> 
<p>大多数情况下用于实现多租户的资源隔离，namespace通过将集群内部的资源对象分配到不同的namespace中，形成逻辑上分组的不同项目、小组，便于不同的分组在共享使用整个集群的资源的同时还能被分别管理。<br> namespace的定义很简单，如下所示的yaml定义了名为development的</p> 
<pre><code class="prism language-java">namespace
apiVersion<span class="token operator">:</span> v1
kind<span class="token operator">:</span> <span class="token class-name">Namespace</span>
metadata<span class="token operator">:</span>
	name<span class="token operator">:</span> development
</code></pre> 
<p>一旦创建了Namespace，我们在创建资源对象时就可以指定这个资源对象属于哪个namespace，比如下面，定义了名为busybox的Pod，放入development这个namespace里：</p> 
<pre><code class="prism language-java">apiVersion<span class="token operator">:</span> v1
kind<span class="token operator">:</span> <span class="token class-name">Pod</span>
metadata<span class="token operator">:</span>
name<span class="token operator">:</span> busybox
namespace<span class="token operator">:</span> development
</code></pre> 
<h3><a id="212_kubernetes_255"></a>2.12 kubernetes基础命令</h3> 
<p>1，kubectl get用来获取资源信息列表，可用来查看pod是否健康，当前的运行状态，重启了几次，生命周期等，是最常用的命令之一</p> 
<pre><code class="prism language-java">kubectl get pod<span class="token operator">:</span> 获取pod资源列表，默认获取<span class="token keyword">default</span>命名空间

kubectl get pod <span class="token operator">-</span>n kube<span class="token operator">-</span>system<span class="token operator">:</span> 获取kube<span class="token operator">-</span>system命名空间的pod资源列表

kubectl get pod <span class="token operator">--</span>all<span class="token operator">-</span>namespaces<span class="token operator">:</span> 获取所有命名空间的pod资源列表

kubectl get pod <span class="token operator">-</span>n kube<span class="token operator">-</span>system kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span><span class="token operator">:</span> 获取kube<span class="token operator">-</span>system命名空间中指定的pod：kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span>的信息。当查看某个具体的pod时，必须指明该pod所在的命名空间，像–all<span class="token operator">-</span>namespaces参数是不能使用的

kubectl get pod <span class="token operator">-</span>n kube<span class="token operator">-</span>system kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span> <span class="token operator">-</span>o wide<span class="token operator">:</span> 获取kube<span class="token operator">-</span>system命名空间中指定的pod：kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span>的信息，并且展示更多信息，包括pod ip，所在节点等信息

kubectl get pod <span class="token operator">-</span>n kube<span class="token operator">-</span>system kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span> <span class="token operator">-</span>o yaml<span class="token operator">:</span> 获取kube<span class="token operator">-</span>system命名空间中指定的pod：kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span>的信息，并且以yaml格式展示pod详细信息

kubectl get pod <span class="token operator">-</span>n kube<span class="token operator">-</span>system kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span> <span class="token operator">-</span>o json<span class="token operator">:</span> 获取kube<span class="token operator">-</span>system命名空间中指定的pod：kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span>的信息，并且以json格式展示pod详细信息

kubectl get pod <span class="token operator">--</span>all<span class="token operator">-</span>namespaces <span class="token operator">--</span>watch<span class="token operator">:</span> 监控pod资源的变化

上述命令中的pod为kubernetes集群中的一种资源对象，其它资源对象，例如：deployment、deamonset、endpoint、ingress、services、secrets等等，都可以用get命令，全部的资源对象详见这里
</code></pre> 
<p>2， kubectl describe: 打印所选资源的详细描述信息，当pod启动异常的时候也可以用该命令排查问题</p> 
<pre><code class="prism language-java">kubectl describe <span class="token operator">-</span>n kube<span class="token operator">-</span>system pod kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span>
描述pod：kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span>的详细信息

kubectl describe <span class="token operator">-</span>n kube<span class="token operator">-</span>system secrets kubernetes<span class="token operator">-</span>dashboard<span class="token operator">-</span>token<span class="token operator">-</span><span class="token number">9</span>mvxp
描述secrets详细信息，例如该命令可查询登录dashboard所需的token信息

container_name可以通过kubectl describe命令获得
kubectl describe pod calico<span class="token operator">-</span>node<span class="token operator">-</span>rw4c2 <span class="token operator">-</span>n kube<span class="token operator">-</span>system <span class="token operator">|</span> grep <span class="token operator">-</span><span class="token class-name">B</span> <span class="token number">1</span> “<span class="token class-name">Container</span> <span class="token constant">ID</span>”

</code></pre> 
<p>3，kubectl exec：与docker exec命令一样，kubectl exec 也是用来进入容器内部的</p> 
<pre><code class="prism language-java">kubectl exec <span class="token operator">-</span>it <span class="token operator">-</span>n kube<span class="token operator">-</span>system kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span> sh
进入kube<span class="token operator">-</span>system命名空间下的kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span>容器内部
仅当pod内只有一个容器的时候适用

kubectl exec <span class="token operator">-</span>it <span class="token operator">-</span>n kube<span class="token operator">-</span>system calico<span class="token operator">-</span>node<span class="token operator">-</span>rw4c2 <span class="token operator">-</span>c install<span class="token operator">-</span>cni sh
<span class="token operator">-</span>it：开启虚拟终端tty，并将标准输入传入容器中
<span class="token operator">-</span>i<span class="token punctuation">,</span> <span class="token operator">--</span>stdin<span class="token operator">=</span><span class="token boolean">false</span><span class="token operator">:</span> <span class="token class-name">Pass</span> stdin <span class="token keyword">to</span> <span class="token namespace">the</span> container
<span class="token operator">-</span>t<span class="token punctuation">,</span> <span class="token operator">--</span>tty<span class="token operator">=</span><span class="token boolean">false</span><span class="token operator">:</span> <span class="token class-name">Stdin</span> is a <span class="token constant">TTY</span>
当pod中有多个容器，需要进入指定的容器时适用，比上一条命令多了<span class="token operator">-</span>c container_name

</code></pre> 
<p>4，kubectl logs</p> 
<pre><code class="prism language-java">kubectl logs用来查看容器的日志，在定位问题时非常有用
kubectl logs <span class="token operator">-</span>n kube<span class="token operator">-</span>system <span class="token operator">-</span>f <span class="token operator">--</span>tail <span class="token number">10</span> kube<span class="token operator">-</span>apiserver<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">01</span>
<span class="token operator">-</span>f<span class="token operator">:</span> 动态打印日志
–tail <span class="token number">10</span><span class="token operator">:</span> 打印最后<span class="token number">10</span>行日志，不加该参数时默认会打印全部的日志，在日志非常多的时候非常有用
</code></pre> 
<p>5，kubectl scale</p> 
<pre><code class="prism language-java">kubectl scale用来对deployement、replicaset、statefulset等资源进行伸缩
kubectl scale deployment <span class="token operator">-</span>n kube<span class="token operator">-</span>system <span class="token operator">--</span>replicas<span class="token operator">=</span><span class="token number">2</span> kubernetes<span class="token operator">-</span>dashboard
–replicas<span class="token operator">=</span><span class="token number">2</span><span class="token operator">:</span> 指定副本数量为<span class="token number">2</span>
先设置replicas<span class="token operator">=</span><span class="token number">0</span>，再设置replicas<span class="token operator">=</span><span class="token number">1</span>可实现pod重启操作

</code></pre> 
<p>6，kubectl apply</p> 
<pre><code class="prism language-java">通过传入文件名或者标准输入来创建资源或配置

kubectl apply <span class="token operator">-</span>f <span class="token punctuation">.</span>
创建或更新当前目录所有的yaml文件描述的配置或资源

kubectl apply <span class="token operator">-</span>f <span class="token operator">/</span>home<span class="token operator">/</span>agms<span class="token operator">/</span>
创建或更新指定目录所有的yaml文件描述的配置或资源

kubectl apply <span class="token operator">-</span>f <span class="token operator">/</span>home<span class="token operator">/</span>agms<span class="token operator">/</span>a<span class="token punctuation">.</span>yaml
创建或更新指定yaml文件描述的配置或资源
</code></pre> 
<p>7，kubectl delete</p> 
<pre><code class="prism language-java">kubectl delete <span class="token operator">-</span>f <span class="token punctuation">.</span>
删除当前目录所有的yaml文件描述的配置或资源

kubectl delete <span class="token operator">-</span>f <span class="token operator">/</span>home<span class="token operator">/</span>agms<span class="token operator">/</span>
删除指定目录所有的yaml文件描述的配置或资源

kubectl delete <span class="token operator">-</span>f <span class="token operator">/</span>home<span class="token operator">/</span>agms<span class="token operator">/</span>a<span class="token punctuation">.</span>yaml
删除指定yaml文件描述的配置或资源

kubectl delete nodes k8s<span class="token operator">-</span><span class="token number">01</span>
按照节点名删除集群中的节点（慎用）
</code></pre> 
<p>8，kubectl explain</p> 
<pre><code class="prism language-java">列出受支持资源的字段、版本，各字段的描述、类型等，在编写yaml文件时非常有用

kubectl explain deployment<span class="token punctuation">.</span>spec
描述deployment资源的spec字段
</code></pre> 
<p>9，kubectl create</p> 
<pre><code class="prism language-java">通过命令行创建kubernetes资源或配置信息

kubectl create namespace fpi<span class="token operator">-</span>inc
创建一个fpi<span class="token operator">-</span>inc的命名空间

一般建议通过kubectl apply的方式来进行资源或配置的创建
</code></pre> 
<hr> 
<h2><a id="_k8s_370"></a>三 k8s搭建</h2> 
<p>因服务器原因搭建，大家参考其他博文吧。<br> 参考如下：<br> https://blog.csdn.net/qq_44214446/article/details/128531430</p> 
<hr> 
<p>参考文献：<br> https://blog.csdn.net/qq_60387497/article/details/121980495<br> https://blog.csdn.net/qq_38328477/article/details/86712892<br> https://blog.csdn.net/weixin_56790951/article/details/123510916</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7a9e378fb0c6fe0ab94864f8982c88f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">实现Linux下Word转PDF、Java调用命令方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b84e15cc770a0b9221bc1187ec870602/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL注入（DVWA靶场搭建及使用、sqlMap注入、sqlmap问题及解决办法）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>