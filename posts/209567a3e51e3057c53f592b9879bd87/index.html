<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>泛克里金和普通克里金_避免敌人！ 这是用克里制作的简单游戏。 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="泛克里金和普通克里金_避免敌人！ 这是用克里制作的简单游戏。" />
<meta property="og:description" content="泛克里金和普通克里金
你需要什么 Kree v1.9或最新版本 Eclipse IDE 您将学到什么 创建场景 创建一个游戏对象 向游戏对象添加组件 从用户那里获取输入 创建自定义组件 创造球员运动 使用Kree产生随机数 检测碰撞 制备 设置您的Java项目并将Kree添加到您的构建路径 创建一个名为避免的包 还请参见： Java 15：密封的类使Valhalla更近了一步 创建启动器类 package avoid;import dev.jabo.kree.Game;import dev.jabo.kree.Window;public class Launcher {public static void main(String[] args) {Window window = new Window(&#34;Avoid the Enemy&#34;, 800, 600);Game game = new Game(window);game.start();}} 在这一节课中，我们将添加主课。 在第11行中，我们将为窗口创建一个实例，该实例带有3个参数，分别是窗口标题，窗口宽度和窗口高度。 在第12行中，我们将为我们的Game创建一个实例，该实例采用Window参数。 在Game类中，所有操作（例如游戏循环，用户输入等）都将在此开始。 最后，我们有game.start()它将触发游戏的开始。 创建场景 在Kree中创建场景非常简单。 package avoid;import java.awt.Graphics;import dev.jabo.kree.Game;import dev." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/209567a3e51e3057c53f592b9879bd87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-10T15:47:31+08:00" />
<meta property="article:modified_time" content="2020-07-10T15:47:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">泛克里金和普通克里金_避免敌人！ 这是用克里制作的简单游戏。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="text" style="font-size: 16px;"> 
 <p>泛克里金和普通克里金</p> 
 <h3>你需要什么</h3> 
 <ul><li> Kree v1.9或最新版本 </li><li> Eclipse IDE </li></ul> 
 <h3>您将学到什么</h3> 
 <ul><li> 创建场景 </li><li> 创建一个游戏对象 </li><li> 向游戏对象添加组件 </li><li> 从用户那里获取输入 </li><li> 创建自定义组件 </li><li> 创造球员运动 </li><li> 使用Kree产生随机数 </li><li> 检测碰撞 </li></ul> 
 <h3>制备</h3> 
 <ol><li> 设置您的Java项目并将Kree添加到您的构建路径 </li><li> 创建一个名为<strong>避免</strong>的包 </li></ol> 
 <p> <strong>还请参见： <a href="https://jaxenter.com/java-15-news-170322.html" rel="noopener noreferrer noopener noreferrer" target="_blank">Java 15：密封的类使Valhalla更近了一步</a></strong> </p> 
 <h3>创建启动器类</h3> 
 <pre class="has"><code class="notranslate brush: java; title: ; notranslate" title="">package avoid;

import dev.jabo.kree.Game;
import dev.jabo.kree.Window;

public class Launcher {

public static void main(String[] args) {

Window window = new Window("Avoid the Enemy", 800, 600);
Game game = new Game(window);

game.start();

}

}</code></pre> 
 <p> 在这一节课中，我们将添加主课。 </p> 
 <p> 在第11行中，我们将为窗口创建一个实例，该实例带有3个参数，分别是窗口标题，窗口宽度和窗口高度。 </p> 
 <p> 在第12行中，我们将为我们的Game创建一个实例，该实例采用Window参数。 在Game类中，所有操作（例如游戏循环，用户输入等）都将在此开始。 </p> 
 <p> 最后，我们有<code>game.start()</code>它将触发游戏的开始。 </p> 
 <h3>创建场景</h3> 
 <p> 在Kree中创建场景非常简单。 </p> 
 <pre class="has"><code class="notranslate brush: java; title: ; notranslate" title="">package avoid;

import java.awt.Graphics;

import dev.jabo.kree.Game;
import dev.jabo.kree.Input;

public class GameScene extends Scene {

public GameScene(Game game) {
super(game);

}

@Override
public void Initialize() {

}

@Override
public void Render(Graphics g) {

}

@Override
public void Update() {

}

}</code></pre> 
 <p> 您可以在本教程中随时为您的场景命名，我们将使用<code>GameScene</code> 。 您的场景必须扩展Scene类，这样Kree才能了解您正在创建一个Scene。 </p> 
 <p> 将我们的GameScene类扩展到Scene Eclipse后，将给我们一个错误。 不要担心，我们只需要实现一些未实现的方法，例如Initialize，Render和Update。 </p> 
 <p> 创建场景后，将调用一次Initialize方法。 </p> 
 <p> Update＆Render方法每秒调用60次。 </p> 
 <h3>设置我们的活跃场景</h3> 
 <pre class="has"><code class="notranslate brush: java; title: ; notranslate" title="">package avoid;

import dev.jabo.kree.Game;
import dev.jabo.kree.SceneManager;
import dev.jabo.kree.Window;

public class Launcher {

public static void main(String[] args) {

Window window = new Window("Avoid the Enemy", 800, 600);
Game game = new Game(window);

GameScene gameScene = new GameScene(game);

SceneManager.setScene(gameScene);

game.start();

}

}</code></pre> 
 <p> 在第14行中，我们将创建带有1个参数的GameScene类的实例，在第16行中，将访问具有1个场景参数的SceneManager类方法setScene。 </p> 
 <blockquote> 
  <p> <code>game.start()</code>应该始终在主类的结尾 </p> 
 </blockquote> 
 <h3>创建我们的播放器并添加组件</h3> 
 <pre class="has"><code class="notranslate brush: java; title: ; notranslate" title="">package avoid;

import java.awt.Graphics;

import dev.jabo.kree.Game;
import dev.jabo.kree.GameObject;
import dev.jabo.kree.Scene;
import dev.jabo.kree.Vector2;
import dev.jabo.kree.components.MeshRenderer;

public class GameScene extends Scene {

private GameObject player;

public GameScene(Game game) {
super(game);

}

@Override
public void Initialize() {
player = new GameObject(this, "Player");
player.getTransform().setPosition(new Vector2(game.getWindow().getWindowWidth() / 2, game.getWindow().getWindowHeight() / 2));
player.getTransform().setScale(new Vector2(32, 32));
player.addComponent(new MeshRenderer());
}

@Override
public void Render(Graphics g) {

}

@Override
public void Update() {

}

}</code></pre> 
 <p> 在第22行中，我们正在将玩家对象初始化为一个新的GameObject，该对象带有2个参数，即父场景和GameObject名称。 </p> 
 <p> 在第23行中，我们将播放器的位置设置为窗口的中心，以进行访问上面代码所示的窗口中的一些变量的操作。 </p> 
 <p> 在第24行中，我们将对象的比例设置为32 x 32像素，最后，我们添加了一个名为MeshRenderer的组件，以根据玩家的位置和比例来渲染简单的矩形形状。 </p> 
  
 <h3>创建自定义组件并添加玩家移动</h3> 
 <pre class="has"><code class="notranslate brush: java; title: ; notranslate" title="">package avoid;

import java.awt.Graphics;

import dev.jabo.kree.Component;
import dev.jabo.kree.Input;
import dev.jabo.kree.Vector2;

public class Player extends Component {

private Vector2 playerTarget;

public Player() {

}

@Override
public void Update() {

if(gameObject == null)
return;

if(Input.leftMouseDown) {
playerTarget = Input.getMouse();
}

gameObject.getTransform().getPosition().moveTowards(playerTarget, 5f);

}

@Override
public void Render(Graphics g) {

}

}</code></pre> 
 <p> 在Kree中创建自定义组件与创建场景非常相似，但是在创建自定义组件时，我们需要将类扩展到Component类，以便可以将其添加到GameObject中。 </p> 
 <p> 在本教程中，我们将采用独特的方法来创建玩家的动作。 我们将采用的实现方式是，每当单击鼠标使用Kree在游戏中实现此操作时，玩家就会跟随鼠标，这非常简单，我们将在Vector2上使用名为<code>moveTowards</code>的方法，该方法需要2个参数，第一个是Vector2，浮动速度。 </p> 
 <p> 为了实现这一机制，我们将需要创建一个Vector2对象，该对象将成为我们的目标，并且在Update方法中，只要单击鼠标左键就可以对其进行更新。 </p> 
 <p> 在第20行中，您可能会有点困惑。 这是为了防止我们的程序在尝试访问GameObject时出错。 </p> 
 <p> 您可能会对我们正在访问的<code>gameobject</code>变量感到困惑。 基本上，将组件添加到<code>gameobject</code>会将<code>gameobject</code>变量分配给<code>gameobject</code> 。 </p> 
 <h3>创造敌人</h3> 
 <pre class="has"><code class="notranslate brush: java; title: ; notranslate" title="">package avoid;

import java.awt.Color;
import java.awt.Graphics;

import dev.jabo.kree.Game;
import dev.jabo.kree.GameObject;
import dev.jabo.kree.Random;
import dev.jabo.kree.Scene;
import dev.jabo.kree.Vector2;
import dev.jabo.kree.components.MeshRenderer;

public class GameScene extends Scene {

private GameObject player;
private GameObject enemy;

public GameScene(Game game) {
super(game);

}

@Override
public void Initialize() {
// Player
player = new GameObject(this, "Player");
player.getTransform().setPosition(new Vector2(game.getWindow().getWindowWidth() / 2, game.getWindow().getWindowHeight() / 2));
player.getTransform().setScale(new Vector2(32, 32));
player.addComponent(new MeshRenderer());
player.addComponent(new Player());

// Enemy
enemy = new GameObject(this, "Enemy");
enemy.getTransform().setPosition(new Vector2(Random.range(0, game.getWindow().getWindowWidth()), Random.range(0, game.getWindow().getWindowHeight())));
enemy.getTransform().setScale(new Vector2(32, 32));
enemy.addComponent(new MeshRenderer());
((MeshRenderer) enemy.getComponent("Mesh Renderer")).setColor(Color.RED);
}

@Override
public void Render(Graphics g) {

}

@Override
public void Update() {

enemy.getTransform().getPosition().moveTowards(player.getTransform().getPosition(), 3f);

}

}</code></pre> 
 <p> 创建敌人与创建玩家的过程类似，但是为了使我们的游戏更具多样性，我们在敌人的位置上增加了一些随机性。 </p> 
 <p> 用Kree生成随机数很简单，我们只需要访问Kree内置的Random类上的方法。 <code>Random.range(min, max)</code> </p> 
 <p> 为了使我们的敌人更加危险，我们添加了一个机制，使敌人应该跟随玩家，但要比玩家更慢，这样我们的敌人就不会过于强大。 </p> 
 <p> <strong>还请参见： <a href="https://jaxenter.com/integrating-python-with-java-170663.html" rel="noopener noreferrer noopener noreferrer" target="_blank">将Python与Java集成</a></strong> </p> 
 <h3>检测碰撞</h3> 
 <pre class="has"><code class="notranslate brush: java; title: ; notranslate" title="">package avoid;

import java.awt.Color;
import java.awt.Graphics;

import dev.jabo.kree.Debug;
import dev.jabo.kree.Game;
import dev.jabo.kree.GameObject;
import dev.jabo.kree.Random;
import dev.jabo.kree.Scene;
import dev.jabo.kree.Vector2;
import dev.jabo.kree.components.BoxCollider;
import dev.jabo.kree.components.MeshRenderer;

public class GameScene extends Scene {

private GameObject player;
private GameObject enemy;

public GameScene(Game game) {
super(game);

}

@Override
public void Initialize() {
// Player
player = new GameObject(this, "Player");
player.getTransform().setPosition(new Vector2(game.getWindow().getWindowWidth() / 2, game.getWindow().getWindowHeight() / 2));
player.getTransform().setScale(new Vector2(32, 32));
player.addComponent(new MeshRenderer());
player.addComponent(new Player());

// Enemy
enemy = new GameObject(this, "Enemy");
enemy.getTransform().setPosition(new Vector2(Random.range(0, game.getWindow().getWindowWidth()), Random.range(0, game.getWindow().getWindowHeight())));
enemy.getTransform().setScale(new Vector2(32, 32));
enemy.addComponent(new MeshRenderer());
((MeshRenderer) enemy.getComponent("Mesh Renderer")).setColor(Color.RED);
}

@Override
public void Render(Graphics g) {

}

@Override
public void Update() {


if(Vector2.distance(player.getTransform().getPosition(), enemy.getTransform().getPosition()) &lt; 16) {
Debug.log("We've been hit!");
}

enemy.getTransform().getPosition().moveTowards(player.getTransform().getPosition(), 3f);

}

}</code></pre> 
 <blockquote> 
  <p> 您可能会注意到，由于这一原因，我们没有使用<code>BoxCollider</code>类，原因是Kree v1.9上的BoxCollider是一个非常小的bug，将很快修复。 </p> 
 </blockquote> 
 <p> 为了检测敌人是否击中了我们的玩家，我们将使用Vecto2中的静态类，该类是将返回两个向量之间距离的距离。 </p> 
 <p> 您可以看到我们在这里使用了Debug类来调试我们的游戏。 当我们在代码中调试某些东西时，Debug类非常有用。 </p> 
 <h3>接下来做什么？</h3> 
 <p> 为了使我们的游戏更具可定制性，我们将在此处结束本教程。 让您的创造力决定下一步的发展。 </p> 
 <p> 但是，在我们结束之前，让我给您一些改善游戏的技巧： </p> 
 <ul><li> 添加用户界面！ </li><li> 添加粒子系统！ </li></ul> 
 <p> 恭喜您完成本教程！ </p> 
 <blockquote> 
  <p> 需要帮忙？ </p> 
  <p> 请随意浏览<a href="https://kree.gitbook.io/documentation/avoid-the-enemy" rel="noopener noreferrer noopener noreferrer" target="_blank">本网站</a>提供的文档。 </p> 
  <p> 加入我们，与<a href="https://discord.com/invite/m2hYa6F" rel="noopener noreferrer noopener noreferrer" target="_blank">Discord</a>携手共进。 </p> 
 </blockquote> 
 <blockquote> 
  <p>翻译自: <a href="https://jaxenter.com/kree-avoid-the-enemy-172088.html" rel="nofollow">https://jaxenter.com/kree-avoid-the-enemy-172088.html</a></p> 
 </blockquote> 
 <p>泛克里金和普通克里金</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b0482ac9c49f4c7096558fb6c6168c39/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android开发 - 收藏集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3aa12564fe19078c7ed4c3bbe4a68c11/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Quarkus 1.5.0.Final欢迎新的扩展</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>