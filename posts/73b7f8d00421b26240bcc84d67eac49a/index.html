<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux下java应用启动参数配置 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux下java应用启动参数配置" />
<meta property="og:description" content="实际部署java应用时，在sun jdk1.6的环境下，为使应用能够高效率长时间稳定运行，需要配置特定的虚拟机参数。每到此时都会想有没有一个基准配置用来供选择，使用基准配置就可以使服务器性能达到一个较高水准，下面就根据实际使用情况，列出必选配置与可选配置，供系统测试或系统上线使用。
一、必选：
1、jvm类型 -server 一定要作为第一个参数，在多个CPU时性能佳，默认模式。 默认，服务端模式，启动慢，运行快，占用内存较大，编译器优化 -client 客户端模式，启动快，占用内存较小，编译器优化 使用下列命令可以查看初始占用： java -client -XX:&#43;PrintFlagsFinal -version 2&gt;&amp;1 | grep -i -E &#39;heapsize|permsize|version&#39; -XX:&#43;PrintCommandLineFlags ，这个参数的作用是显示出VM初始化完毕后所有跟最初的默认值不同的参数及它们的值 java -XX:&#43;PrintCommandLineFlags -d64 64位java环境，建议需要使用4G以上内存时使用。同时添加压缩对象参数： -XX:&#43;UseCompressedOops -d32 32位java环境，普通情况下使用。 -DTEST=TEST1 设置环境变量TEST的值为TEST1 2、gc相关 -verbose:gc 打开gc日志开关 -Xloggc:./log/gc.log 将GC日志进行记录，后边可跟相对路径或绝对路径 -XX:&#43;PrintGCDetails JVM做GC时在gc日志里记录详细的gc信息 -XX:&#43;PrintGCTimeStamps 了解垃圾收集发生的时间 -XX:&#43;PrintGCApplicationStoppedTime 打印垃圾回收期间程序暂停的时间 回收器选择 JVM给了三种选择(三选一，默认为并行收集器)：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。 默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。 1、串行收集器 --适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。 --缺点：只能用于小型应用 -XX:&#43;UseSerialGC：设置串行收集器 2、并行收集器(吞吐量优先) --适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。 --缺点：应用响应时间可能较长 -XX:&#43;UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。 -XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。 -XX:&#43;UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。 -XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒），如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 -XX:&#43;UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时间或者收集频率等。 此参数建议使用并行收集器时，一直打开。 3、并发收集器(响应时间优先) --适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。 CMS， 全称Concurrent Low Pause Collector，是jdk1.4后期版本开始引入的新gc算法，在jdk5和jdk6中得到了进一步改进，它的主要适合场景是对响应时间的重要性需求 大于对吞吐量的要求，能够承受垃圾回收线程和应用线程共享处理器资源，并且应用中存在比较多的长生命周期的对象的应用。CMS是用于对tenured generation的回收，也就是年老代的回收，目标是尽量减少应用的暂停时间，减少FullGC发生的几率，利用和应用程序线程并发的垃圾回收线程来 标记清除年老代。 -XX:&#43;UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了。所以，此时年轻代大小最好用-Xmn设置。 -XX:&#43;UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/73b7f8d00421b26240bcc84d67eac49a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-05-18T10:03:51+08:00" />
<meta property="article:modified_time" content="2014-05-18T10:03:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux下java应用启动参数配置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>实际部署java应用时，在sun jdk1.6的环境下，为使应用能够高效率长时间稳定运行，需要配置特定的虚拟机参数。每到此时都会想有没有一个基准配置用来供选择，使用基准配置就可以使服务器性能达到一个较高水准，下面就根据实际使用情况，列出必选配置与可选配置，供系统测试或系统上线使用。</p> 
<p><br> </p> 
<p><strong><span style="font-size:14px">一、必选：</span></strong></p> 
<strong>1、jvm类型</strong> 
<br> 
<span style="white-space:pre"></span> 
<em>-server </em>一定要作为第一个参数，在多个CPU时性能佳，默认模式。 
<br> 
<span style="white-space:pre"></span> 
<em><span style="white-space:pre"></span> </em>默认，服务端模式，启动慢，运行快，占用内存较大，编译器优化 
<br> 
<span style="white-space:pre"></span> 
<em>-client </em>客户端模式，启动快，占用内存较小，编译器优化 
<br> 
<span style="white-space:pre"></span> 
<em>使用下列命令可以查看初始占用：</em> 
<br> 
<span style="white-space:pre"></span>java -client -XX:+PrintFlagsFinal -version 2&gt;&amp;1 | grep -i -E 'heapsize|permsize|version' 
<br> 
<span style="white-space:pre"></span>-XX:+PrintCommandLineFlags ，这个参数的作用是显示出VM初始化完毕后所有跟最初的默认值不同的参数及它们的值 
<br> 
<span style="white-space:pre"></span> 
<em>java -XX:+PrintCommandLineFlags</em> 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span> 
<em>-d64 </em>64位java环境，建议需要使用4G以上内存时使用。同时添加压缩对象参数： -XX:+UseCompressedOops 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span> 
<em>-d32 </em>32位java环境，普通情况下使用。 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span> 
<em>-DTEST=TEST1 </em>设置环境变量TEST的值为TEST1 
<br> 
<span style="white-space:pre"></span> 
<br> 
<strong>2、gc相关</strong> 
<br> 
<em>-verbose:gc </em> 
<span style="white-space:pre"></span>打开gc日志开关 
<br> 
<em>-Xloggc:./log/gc.log </em> 
<span style="white-space:pre"></span>将GC日志进行记录，后边可跟相对路径或绝对路径 
<br> 
<em>-XX:+PrintGCDetails</em> 
<span style="white-space:pre"></span>JVM做GC时在gc日志里记录详细的gc信息 
<br> 
<em>-XX:+PrintGCTimeStamps</em>  了解垃圾收集发生的时间 
<br> 
<em>-XX:+PrintGCApplicationStoppedTime </em>  打印垃圾回收期间程序暂停的时间 
<br> 
<span style="font-size:14px"><strong>回收器选择</strong></span> 
<br> JVM给了三种选择(三选一，默认为并行收集器)：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。 
<br> 默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。 
<br> 
<strong>1、串行收集器 </strong> 
<br> --适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。  
<br> --缺点：只能用于小型应用  
<br> 
<em>-XX:+UseSerialGC</em>：设置串行收集器  
<br> 
<strong>2、并行收集器(吞吐量优先) </strong> 
<br> --适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。  
<br> --缺点：应用响应时间可能较长  
<br> 
<em>-XX:+UseParallelGC</em>：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。  
<br> 
<em>-XX:ParallelGCThreads=20</em>：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。  
<br> 
<em>-XX:+UseParallelOldGC</em>：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。  
<br> 
<em>-XX:MaxGCPauseMillis=100</em>：设置每次年轻代垃圾回收的最长时间（单位毫秒），如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。  
<br> 
<em>-XX:+UseAdaptiveSizePolicy</em>：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时间或者收集频率等。  
<br> 此参数建议使用并行收集器时，一直打开。  
<br> 
<strong>3、并发收集器(响应时间优先)</strong>  
<br> --适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。 
<br> CMS， 全称Concurrent Low Pause Collector，是jdk1.4后期版本开始引入的新gc算法，在jdk5和jdk6中得到了进一步改进，它的主要适合场景是对响应时间的重要性需求 大于对吞吐量的要求，能够承受垃圾回收线程和应用线程共享处理器资源，并且应用中存在比较多的长生命周期的对象的应用。CMS是用于对tenured generation的回收，也就是年老代的回收，目标是尽量减少应用的暂停时间，减少FullGC发生的几率，利用和应用程序线程并发的垃圾回收线程来 标记清除年老代。  
<br> 
<em>-XX:+UseConcMarkSweepGC</em>：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了。所以，此时年轻代大小最好用-Xmn设置。 
<br> 
<em>-XX:+UseParNewGC</em>：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。  
<br> 
<em>-XX:+UseCMSCompactAtFullCollection</em>：打开对年老代的压缩。可能会影响性能，但是可以消除内存碎片。  
<br> 
<em>-XX:+CMSParallelRemarkEnabled </em> 降低标记停顿 
<br> 
<em>-XX:CMSFullGCsBeforeCompaction=</em>：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此参数设置运行次FullGC以后对内存空间进行压缩、整理。  
<br> 
<em>-XX:+CMSIncrementalMode</em>：设置为增量收集模式。一般适用于单CPU情况。  
<br> 
<em>-XX:CMSInitiatingOccupancyFraction=70</em>：表示年老代空间到70%时就开始执行CMS，确保年老代有足够的空间接纳来自年轻代的对象。  
<br> 注：如果使用 throughput collector(并行收集器) 和 concurrent low pause collector(并发收集器) 这两种垃圾收集器，需要适当的挺高内存大小，为多线程做准备。 
<br> 
<br> 
<strong>3、运行相关：<br> java堆内存设置 一般设置为同样的大小</strong> 
<br> 
<em>-Xms1024m </em>  
<span style="white-space:pre"></span>初始堆大小 
<br> 
<em>-Xmx1024m<span style="white-space:pre"> </span></em>最大堆大小 
<br> 
<em>-Xmn256m<span style="white-space:pre"> </span></em>年轻代大小 整个堆内存大小 = 年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能 
<span style="white-space:pre"></span>影响较大，Sun官方推荐配置为整个堆的3/8 
<br> 
<br> 
<strong>java中Permanent设置，用于保存class</strong> 
<br> 
<em>-XX:PermSize=512m<span style="white-space:pre"> </span></em>持久代(perm gen)初始值 
<br> 
<em>-XX:MaxPermSize=512m</em> 
<span style="white-space:pre"> </span>持久代(perm gen)最大值 
<br> 
<br> 
<br> 
<strong>4、调试相关：<br> 内存溢出时声称heapdump文件</strong> 
<br> 
<em>-XX:+HeapDumpOnOutOfMemoryError  </em> 
<br> 
<br> 
<br> 
<span style="font-size:14px">可选：</span> 
<br> 
<em>-Xnoclassgc </em>  关闭垃圾收集回收JAVA类的功能，从而使类可以更多的被重用，因此对性能稍有提高。 但是，即时在该类不被使用后它所使用的本机内存资源仍然被使用。 
<br> 
<span style="white-space:pre"></span> 若每次部署时重启，可以使用该参数，提高性能，若使用热部署，则去除该参数，否则会导致内存溢出。 
<br> 
<em>-XX:ErrorFile=./hs_err_pid&lt;pid&gt;.log  </em> 
<span style="white-space:pre"></span>如果JVM crash时，将错误日志输出到指定目录，默认输出在根目录下。 
<br> 
<span style="white-space:pre"></span>  
<br> 
<em>-XX:HeapDumpPath=./heapdump"</em>   
<span style="white-space:pre"> </span>配置-XX:+HeapDumpOnOutOfMemoryError后生效，heapdump文件的存放位置 
<br> 
<br> 
<br> 
<em>-XX:+DisableExplicitGC<span style="white-space:pre"> </span></em>禁止在运行期显式地调用 System.gc()。若程序中没有显示调用时不需要禁止，以便某些框架或引用资源正常回收垃圾 
<br> 
<em>-XX:SurvivorRatio=8<span style="white-space:pre"> </span></em>Eden与Survivor的占用比例。这里的8表示，一个survivor区占用 1/8 的新生代内存，因为survivor有2个，所以是 2/8，那么Eden的占比为 6/8 
<br> 
<br> 
<br> 
<strong>非稳态选项使用说明</strong> 
<br> -XX:+&lt;option&gt; 启用option 
<br> -XX:-&lt;option&gt; 不启用option 
<br> -XX:&lt;option&gt;=&lt;number&gt; 设定option的值为数字类型，可跟单位，例如 32k, 1024m, 2g 
<br> -XX:&lt;option&gt;=&lt;string&gt; 设定option的值为字符串，例如-XX:HeapDumpPath=./dump.core 
<br> 
<strong><br> 最后一个linux下一个完成的参数配置为(去掉换行符)：</strong> 
<br> 
<pre><code class="language-plain">#!/bin/sh
DATE=`date -d today +"%Y%m%d%H%M"`
java -server -verbose:gc -Xloggc:./log/gc$DATE.log -XX:+PrintGCDetails -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCTimeStamps -XX:+DisableExplicitGC
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./log
-XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection -XX:+CMSParallelRemarkEnabled
-XX:PermSize=128m -XX:MaxPermSize=256m -Xmn768m -Xms2048m -Xmx2048m
-Djava.library.path=. 
-DTEST=TEST1 
-jar org.eclipse.equinox.launcher_1.0.101.R34x_v20081125.jar -clean -refresh &amp;</code></pre> 
<strong><br> aix与linux的不同</strong> 
<br> 
<p><br> </p> 
<p></p> 
<pre><code class="language-plain">java -Dabs_node=m01_cs01 -Xms512m -Xmx2048m -Xdisableexplicitgc -Xgcpolicy:gencon -Xdump:heap:events=user -verbose:gc -Xverbosegclog:./log/gc.log -jar startup.jar -clean -refresh
</code></pre> 
<br> -Xms256m 初始堆内存 
<br> -Xmx1024m 
<span style="white-space:pre"> </span>最大堆内存 
<br> -Xdisableexplicitgc 禁止system.gc() 
<br> -Xgcpolicy:gencon 
<span style="white-space:pre"> </span>gc采用分代并发策略 
<br> -verbose:gc 
<span style="white-space:pre"> </span>打开gc日志 
<br> -Xdump:heap:events=user 
<span style="white-space:pre"> </span>使用kill -3 &lt;pid&gt;时可生成heapdump文件 
<br> 
<p>-Xverbosegclog:./log/gc.log<span style="white-space:pre"> </span>gc文件存放位置</p> 
<p>ibm jdk环境下gc的相关策略见 http://www.ibm.com/developerworks/cn/java/j-ibmjava2/</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4b174e6a955144f2698069bcb579cfce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ember学习（5）：计算型属性和使用@each聚合数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b4e1eddc6fad585db0078a24d326831/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux上安装oracle后，客户端连接报出ORA-12505的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>