<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>全网唯一的、DIY的Prometheus主备方案，生产未上，测试先行。 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="全网唯一的、DIY的Prometheus主备方案，生产未上，测试先行。" />
<meta property="og:description" content="写在开篇 关于prometheus的高可用方案，经过笔者不断的研究、对比、和搜索，发现不管是官方、还是各大搜索引擎搜索出来的方案，都不符合笔者的需求。因此，笔者自己设计了一套prometheus主备的方案。该方案是一个很low的方案，但经过不断的实践、验证，最后发现还挺实用。关于本方案，笔者以后还会找机会用go或者python开发一个带UI界面的prometheus主备管理器，让它的功能更加完善，做到更自动化和智能化。Prometheus是监控领域的新启之秀，潜力非常大，K8S内置对它直接支持，直接有提供exporter，而K8S又是未来基础架构的主力军。而监控方面，prometheus成为未来的主力军是胜券在握，把它玩透了你绝对不吃亏。好了，前戏有点多了。敬请大家的关注、点赞、转发。下面的正式进入主题！！！
DIY的prometheus主备方案架构图 方案说明
两台主机（master和slave）分别部署keepalived，让master主机接管VIP，注意：keepalived建议配置成非抢占模式之所以采用VIP的原因如下： 为了方便日常访问Prometheus页面和Alertmanager页面，在主备切换时，可无需更换访问ip。上层可视化应用（如grafana）通过VIP来对接Prometheus的数据源，当主备切换时，无需在grafana上修改对应的数据源。 日常由master主机处于工作状态，在master中，启动Promethues和Alertmanager组件，启动webhook脚本（告警消息推送脚本，用于将告警推送到其他平台）。slave主机备用状态，在slave中，需要启动Promethues组件（用于拉取指标数据），启动Alertmanager组件（用于接收警报消息），这里注意，webhook脚本需处于停止状态（不进行告警推送到其他平台）。这样做是为了规避推送重复告警的问题，虽然Alertmanager有自身的去重告警功能，但这样的设计根本就没有告警重复，已经将重复扼杀在摇篮里了。在接入监控对象时（部署对应的exporter），切记，仅需要在master上做配置即可， slave定期从master拉取配置文件（包括主配置文件、警报规则文件等），定期和master保持配置同步。master和slave的配置保持同步，意味着两边都会拉取被监控对象的监控指标数据。监控指标的拉取、警报的触发两台均一起工作，但告警的推送只有master在负责，slave不负责告警的推送，如果master不可用了，就需要将slave上的webhook脚本手动拉起来，由slave上的webhook脚本接管告警推送的任务。配置文件同步的做法是采用最原始、最简单、最粗暴的办法，master和slave的配置文件同步方案如下： Master主机：
master提供配置文件下载服务，由python自带的SimpleHTTPServer模块实现，且需要在prometheus或alertmanager规范安装路径下（如/usr/local/prometheus）进行SimpleHTTPServer模块的启动，拉起后，默认的监听端口是8000。master检测配置文件变化情况，如达到条件则触发备份和打包新的配置目录。在master上，设计了一个保存通知动作的文件notice_slave.action，配置发生变化写入1，配置没有发生变化写入0。同时，该检测脚本作为常驻进程在后台运行。 Slave主机：
slave从master下载通知动作的文件notice_slave.action，根据状态码（1和0）来决定接下来的动作，如果是1，则：从master下载配置压缩包、备份原有配置目录、解压新下载后的配置压缩包、热重启相关组件（prometheus、alertmanger），如果是0则什么都不做。 对于配置文件的同步，也是有两种实现方式的，要么是推，要么是拉，笔者的这个方案里是后者，笔者目前之所以折腾零散的shell脚本来去做高可用的管理，是为了能快速解决需求，因此才做了这个简陋的方案，笔者的原则是：困难的事情简单做，简单的事情咱不做（开玩笑哈！！！）。 当然，笔者以后会通过Go或者Python打造一个管理Promtheus主备的工具，且是带UI的管理工具，敬请期待推出！我不造车，我只造零件。
一、规划和规范 1. 设备规划（本示例为测试环境） 角色物理IPVIP安装组件告警推送方式master192.168.11.146192.168.11.203（当前接管）prometheus、alertmanager（均拉起）webhook方式，脚本拉起slave192.168.11.147prometheus、alertmanager（均拉起）webhook方式，脚本不拉起（备用） 2. 统一安装路径规范 master和slave主机的标准安装路径均为：/usr/local/，笔者安装组件后的环境如下:
/usr/local/keepalived （注意：建议keepalived配置成非抢占模式） /usr/local/prometheus /usr/local/alertmanager 至于安装路径的规范，请自行根据实际情况敲定。
3. prometheus组件配置文件和目录规范 所有配置文件统一标准路径：/usr/local/prometheus/conf/prometheus主配置文件：/usr/local/prometheus/conf/prometheus.yml按业务粒度，一个业务对应一个目录，业务下不同的监控对象都放在对应的业务目录下：/usr/local/prometheus/conf/business 特别说明1：请自行在prometheus组件的安装目录下创建conf目录，并将默认的prometheus.yml配置文件移动进去
特别说明2：请自行在prometheus组件的配置文件统一标准路径（./conf）下创建业务目录business
特别说明3：业务目录下，又包含两个目录：job和rule，job用于存放监控拉取配置文件，rule用于存放警报规则配置文件
配置文件目录和业务目录规划示范，如下:
/usr/local/prometheus/ # 这是规范的安装路径 /usr/local/prometheus/conf/ # 这是规范的配置目录 /usr/local/prometheus/conf/prometheus.yml # 这是主配置文件 /usr/local/prometheus/conf/business 这是按业务粒度规划的业务根目录 # 如下是业务A的规划案例： /usr/local/prometheus/conf/business/a_business/ 这是业务a的目录 /usr/local/prometheus/conf/business/a_business/job/oracle.yml 这是业务a下拉取oracle监控配置数据的yml配置文件 /usr/local/prometheus/conf/business/a_business/rule/oracle.rules 这是业务a下oracle的警报规则rules配置文件 特别说明：上述对业务A的配置文件规划案例非常重要，请务必参照此规范。
4. alertmanager组件配置文件和目录规范 关于Alertmanager组件的配置文件，相对来说没prometheus那么复杂，主要的规划还是在prometeus中
alertmanager的主配置文件统一标准路径放在prometeheus的conf中：/usr/local/prometheus/conf/alertmanager.yml 5. 备份路径规范 在master主机上，会自动备份原有的conf配置文件目录
Prometheus组件 统一备份路径为：/usr/local/prometheus/backup/
Alertmanager组件 不涉及到备份
6. 日志目录规范 在master主机和slave主机上运行的脚本日志均统一存放在指定目录
Prometheus组件 统一日志目录：/usr/local/prometheus/logs/" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/089865ae31404e40467507601a6be811/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-06T20:35:19+08:00" />
<meta property="article:modified_time" content="2022-06-06T20:35:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">全网唯一的、DIY的Prometheus主备方案，生产未上，测试先行。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>写在开篇</h2> 
<blockquote> 
 <p>关于prometheus的高可用方案，经过笔者不断的研究、对比、和搜索，发现不管是官方、还是各大搜索引擎搜索出来的方案，都不符合笔者的需求。因此，笔者自己设计了一套prometheus主备的方案。该方案是一个很low的方案，但经过不断的实践、验证，最后发现还挺实用。关于本方案，笔者以后还会找机会用go或者python开发一个带UI界面的prometheus主备管理器，让它的功能更加完善，做到更自动化和智能化。Prometheus是监控领域的新启之秀，潜力非常大，K8S内置对它直接支持，直接有提供exporter，而K8S又是未来基础架构的主力军。而监控方面，prometheus成为未来的主力军是胜券在握，把它玩透了你绝对不吃亏。好了，前戏有点多了。敬请大家的关注、点赞、转发。下面的正式进入主题！！！</p> 
</blockquote> 
<ul><li>DIY的prometheus主备方案架构图</li></ul> 
<p><img src="https://images2.imgbox.com/9d/42/tppFuC3o_o.png" alt="在这里插入图片描述"></p> 
<p><strong>方案说明</strong></p> 
<ol><li>两台主机（master和slave）分别部署keepalived，让master主机接管VIP，注意：keepalived建议配置成非抢占模式</li><li>之所以采用VIP的原因如下：</li></ol> 
<ul><li>为了方便日常访问Prometheus页面和Alertmanager页面，在主备切换时，可无需更换访问ip。</li><li>上层可视化应用（如grafana）通过VIP来对接Prometheus的数据源，当主备切换时，无需在grafana上修改对应的数据源。</li></ul> 
<ol start="3"><li>日常由master主机处于工作状态，在master中，启动Promethues和Alertmanager组件，启动webhook脚本（告警消息推送脚本，用于将告警推送到其他平台）。</li><li>slave主机备用状态，在slave中，需要启动Promethues组件（用于拉取指标数据），启动Alertmanager组件（用于接收警报消息），这里注意，webhook脚本需处于停止状态（不进行告警推送到其他平台）。这样做是为了规避推送重复告警的问题，虽然Alertmanager有自身的去重告警功能，但这样的设计根本就没有告警重复，已经将重复扼杀在摇篮里了。</li><li>在接入监控对象时（部署对应的exporter），<strong>切记，仅需要在master上做配置即可，</strong> slave定期从master拉取配置文件（包括主配置文件、警报规则文件等），定期和master保持配置同步。</li><li>master和slave的配置保持同步，意味着两边都会拉取被监控对象的监控指标数据。监控指标的拉取、警报的触发两台均一起工作，但告警的推送只有master在负责，slave不负责告警的推送，如果master不可用了，就需要将slave上的webhook脚本手动拉起来，由slave上的webhook脚本接管告警推送的任务。</li><li>配置文件同步的做法是采用最原始、最简单、最粗暴的办法，master和slave的配置文件同步方案如下：</li></ol> 
<p><strong>Master主机：</strong></p> 
<ul><li>master提供配置文件下载服务，由python自带的SimpleHTTPServer模块实现，且需要在prometheus或alertmanager规范安装路径下（如/usr/local/prometheus）进行SimpleHTTPServer模块的启动，拉起后，默认的监听端口是8000。</li><li>master检测配置文件变化情况，如达到条件则触发备份和打包新的配置目录。在master上，设计了一个保存通知动作的文件notice_slave.action，配置发生变化写入1，配置没有发生变化写入0。同时，该检测脚本作为常驻进程在后台运行。</li></ul> 
<p><strong>Slave主机：</strong></p> 
<ul><li>slave从master下载通知动作的文件notice_slave.action，根据状态码（1和0）来决定接下来的动作，如果是1，则：从master下载配置压缩包、备份原有配置目录、解压新下载后的配置压缩包、热重启相关组件（prometheus、alertmanger），如果是0则什么都不做。</li></ul> 
<blockquote> 
 <p>对于配置文件的同步，也是有两种实现方式的，要么是推，要么是拉，笔者的这个方案里是后者，笔者目前之所以折腾零散的shell脚本来去做高可用的管理，是为了能快速解决需求，因此才做了这个简陋的方案，笔者的原则是：困难的事情简单做，简单的事情咱不做（开玩笑哈！！！）。 当然，笔者以后会通过Go或者Python打造一个管理Promtheus主备的工具，且是带UI的管理工具，敬请期待推出！我不造车，我只造零件。</p> 
</blockquote> 
<hr> 
<h2><a id="_29"></a>一、规划和规范</h2> 
<h3><a id="1__30"></a>1. 设备规划（本示例为测试环境）</h3> 
<table><thead><tr><th>角色</th><th>物理IP</th><th>VIP</th><th>安装组件</th><th>告警推送方式</th></tr></thead><tbody><tr><td>master</td><td>192.168.11.146</td><td>192.168.11.203（当前接管）</td><td>prometheus、alertmanager（均拉起）</td><td>webhook方式，脚本拉起</td></tr><tr><td>slave</td><td>192.168.11.147</td><td></td><td>prometheus、alertmanager（均拉起）</td><td>webhook方式，脚本不拉起（备用）</td></tr></tbody></table> 
<h3><a id="2__38"></a>2. 统一安装路径规范</h3> 
<blockquote> 
 <p>master和slave主机的标准安装路径均为：/usr/local/，笔者安装组件后的环境如下:</p> 
</blockquote> 
<pre><code class="prism language-text">/usr/local/keepalived （注意：建议keepalived配置成非抢占模式）
/usr/local/prometheus
/usr/local/alertmanager
</code></pre> 
<blockquote> 
 <p>至于安装路径的规范，请自行根据实际情况敲定。</p> 
</blockquote> 
<h3><a id="3_prometheus_47"></a>3. prometheus组件配置文件和目录规范</h3> 
<ul><li>所有配置文件统一标准路径：/usr/local/prometheus/conf/</li><li>prometheus主配置文件：/usr/local/prometheus/conf/prometheus.yml</li><li>按业务粒度，一个业务对应一个目录，业务下不同的监控对象都放在对应的业务目录下：/usr/local/prometheus/conf/business</li></ul> 
<blockquote> 
 <p>特别说明1：请自行在prometheus组件的安装目录下创建conf目录，并将默认的prometheus.yml配置文件移动进去</p> 
</blockquote> 
<blockquote> 
 <p>特别说明2：请自行在prometheus组件的配置文件统一标准路径（./conf）下创建业务目录business</p> 
</blockquote> 
<blockquote> 
 <p>特别说明3：业务目录下，又包含两个目录：job和rule，job用于存放监控拉取配置文件，rule用于存放警报规则配置文件</p> 
</blockquote> 
<p><strong>配置文件目录和业务目录规划示范，如下:</strong></p> 
<pre><code class="prism language-text">/usr/local/prometheus/ # 这是规范的安装路径
/usr/local/prometheus/conf/ # 这是规范的配置目录
/usr/local/prometheus/conf/prometheus.yml # 这是主配置文件
/usr/local/prometheus/conf/business 这是按业务粒度规划的业务根目录

# 如下是业务A的规划案例：
/usr/local/prometheus/conf/business/a_business/ 这是业务a的目录
/usr/local/prometheus/conf/business/a_business/job/oracle.yml 这是业务a下拉取oracle监控配置数据的yml配置文件
/usr/local/prometheus/conf/business/a_business/rule/oracle.rules 这是业务a下oracle的警报规则rules配置文件
</code></pre> 
<blockquote> 
 <p>特别说明：上述对业务A的配置文件规划案例非常重要，请务必参照此规范。</p> 
</blockquote> 
<h3><a id="4_alertmanager_72"></a>4. alertmanager组件配置文件和目录规范</h3> 
<blockquote> 
 <p>关于Alertmanager组件的配置文件，相对来说没prometheus那么复杂，主要的规划还是在prometeus中</p> 
</blockquote> 
<ul><li>alertmanager的主配置文件统一标准路径放在prometeheus的conf中：/usr/local/prometheus/conf/alertmanager.yml</li></ul> 
<h3><a id="5__76"></a>5. 备份路径规范</h3> 
<p>在master主机上，会自动备份原有的conf配置文件目录</p> 
<ul><li>Prometheus组件</li></ul> 
<blockquote> 
 <p>统一备份路径为：/usr/local/prometheus/backup/</p> 
</blockquote> 
<ul><li>Alertmanager组件</li></ul> 
<blockquote> 
 <p>不涉及到备份</p> 
</blockquote> 
<h3><a id="6__85"></a>6. 日志目录规范</h3> 
<p>在master主机和slave主机上运行的脚本日志均统一存放在指定目录</p> 
<ul><li>Prometheus组件</li></ul> 
<blockquote> 
 <p>统一日志目录：/usr/local/prometheus/logs/</p> 
</blockquote> 
<ul><li>AlertManager组件</li></ul> 
<blockquote> 
 <p>统一日志目录：/usr/local/alertmanager/logs/</p> 
</blockquote> 
<hr> 
<h2><a id="_95"></a>二、组件安装部署</h2> 
<blockquote> 
 <p>注意：master和slave均需要安装如下组件</p> 
</blockquote> 
<ul><li>keepalived高可用组件</li><li>prometheus监控组件</li><li>alertmanager警报组件</li></ul> 
<blockquote> 
 <p>因组件的安装部署不是本文的主题，所以笔者在这里就不再撰写安装步骤，在此省略了哈，请自行安装好即可。</p> 
</blockquote> 
<hr> 
<h2><a id="prometheus_104"></a>三、prometheus配置文件目录同步部署</h2> 
<blockquote> 
 <p>说明1：均需要在master和slave上部署文件同步相关脚本</p> 
</blockquote> 
<blockquote> 
 <p>说明2：以下的每一步操作，请均进入到“/usr/local/prometheus/”目录下进行操作（此目录是之前已经定为安装规范的目录），如您的规范目录和笔者的不同，请进入到您自己的规范目录下。</p> 
</blockquote> 
<blockquote> 
 <p>说明3：以下涉及的脚本，涉及的目录：conf、backup、logs、cfmd5，请自行在规范的目录下进行创建即可。</p> 
</blockquote> 
<h3><a id="1_master_112"></a>1. master部署配置文件下载服务</h3> 
<ol><li><strong>通过python拉起简单的Http服务，默认监听端口为8000，创建脚本startPromconfSyncApi.sh</strong></li></ol> 
<p>startPromconfSyncApi.sh脚本内容如下：</p> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token function">nohup</span> /usr/bin/python -m SimpleHTTPServer <span class="token operator">&gt;</span> /dev/null <span class="token operator">&amp;</span>
</code></pre> 
<p>运行配置文件下载服务的脚本</p> 
<pre><code class="prism language-shell"><span class="token function">sh</span> startPromconfSyncApi.sh
</code></pre> 
<p>拉起http服务脚本后查看端口</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># netstat -tulnp | grep 8000</span>
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:8000            <span class="token number">0.0</span>.0.0:*               LISTEN      <span class="token number">1293</span>/python         
<span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># </span>
</code></pre> 
<ol start="2"><li><strong>创建配置文件变化检查脚本startTarPackConf.sh</strong></li></ol> 
<blockquote> 
 <p>注意，请在规范的安装路径/usr/local/prometheus/下面创建startTarPackConf.sh脚本，以及创建目录cfmd5</p> 
</blockquote> 
<p>startTarPackConf.sh脚本内容：</p> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token assign-left variable">time_log</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span> <span class="token string">"+%Y-%m-%d %H:%M:%S"</span><span class="token variable">`</span></span>
<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${time_log}</span> 配置检查器启动"</span>

<span class="token assign-left variable">task_wait_sec</span><span class="token operator">=</span><span class="token number">4</span>

<span class="token function">find</span> ./conf -type f -print0 <span class="token operator">|</span> <span class="token function">xargs</span> -0 md5sum <span class="token operator">&gt;</span> ./cfmd5/cfmd5.list

<span class="token keyword">while</span> <span class="token boolean">true</span>
<span class="token keyword">do</span>
  <span class="token assign-left variable">time_bak</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span> <span class="token string">"+%Y%m%d%H%M%S"</span><span class="token variable">`</span></span>
  <span class="token assign-left variable">time_log</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span> <span class="token string">"+%Y-%m-%d %H:%M:%S"</span><span class="token variable">`</span></span>

  md5sum -c ./cfmd5/cfmd5.list <span class="token operator">&gt;</span> ./cfmd5/check_cfmd5.log
  <span class="token assign-left variable">md5ret</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> ./cfmd5/check_cfmd5.log <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"FAILED"</span> <span class="token operator">|</span> <span class="token function">wc</span> -l<span class="token variable">`</span></span>

  <span class="token keyword">while</span> <span class="token boolean">true</span>
  <span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">${md5ret}</span> -gt <span class="token number">0</span> <span class="token punctuation">]</span>
    <span class="token keyword">then</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${time_log}</span> 配置文件发生变化，触发备份和打包压缩"</span>
      <span class="token function">mv</span> ./conf.tar.gz ./backup/conf.tar.gz_bak_<span class="token variable">${time_bak}</span>
      <span class="token function">tar</span> -zcf conf.tar.gz conf/
      <span class="token builtin class-name">echo</span> <span class="token number">1</span> <span class="token operator">&gt;</span> ./notice_slave.action
      <span class="token function">curl</span> -X POST http://127.0.0.1:9090/-/reload
      <span class="token builtin class-name">break</span>
    <span class="token keyword">else</span>
      <span class="token builtin class-name">echo</span> <span class="token number">0</span> <span class="token operator">&gt;</span> ./notice_slave.action
      <span class="token builtin class-name">break</span>
    <span class="token keyword">fi</span>
  <span class="token keyword">done</span>
  <span class="token function">find</span> ./conf -type f -print0 <span class="token operator">|</span> <span class="token function">xargs</span> -0 md5sum <span class="token operator">&gt;</span> ./cfmd5/cfmd5.list
  <span class="token function">sleep</span> <span class="token variable">${task_wait_sec}</span>
<span class="token keyword">done</span>
</code></pre> 
<blockquote> 
 <p>脚本实现说明：很简单，就是递归搜索conf目录下的所有配置文件且生成md5值保存在./cfmd5/cfmd5.list，并使用md5sum -c实时检查./cfmd5/cfmd5.list中的文件md5值是否有变化，且将结果输出到./cfmd5/check_cfmd5.log，再通过cat ./cfmd5/check_cfmd5.log进行过滤"FAILED"并统计，只要出现有"FAILED"，就认为配置文件有发生过变化，要么是增加了，要么是现有的配置文件做了修改。统计的结果保存在md5ret变量，判断条件就是md5ret结果大于0就触发北方和打包压缩配置目录，同时master中的配置文件发生变化后，也会自动触发热重启。接着将状态码1写入到./notice_slave.action文件中，如果没有变化，将状态码就是0。notice_slave.action文件是存储状态变化的（在这里就干脆叫通知文件吧！）。</p> 
</blockquote> 
<blockquote> 
 <p>关于通知文件（notice_slave.action）设计的详细说明：对slave端来讲，由slave主动拉取这个通知文件并读取结果，如果是1就触发拉取master打包好的压缩目录并解压，且继续热重启相应的组件，如果是0就啥也不干。</p> 
</blockquote> 
<blockquote> 
 <p>关于参数task_wait_sec=4，任务等待时间，master目前配置的是4秒，也就是每隔4秒检测一次。对于slave端，也有一个pull_wait_sec=2参数（目前是2秒），也就是每隔2秒拉取一次通知文件，并做判断。这里要注意，slave的pull_wait_sec拉取时间一定要小于master的task_wait_sec时间，别问为什么，自己思考去。</p> 
</blockquote> 
<p>拉起配置文件变化检查脚本</p> 
<pre><code class="prism language-shell"><span class="token comment"># 拉起</span>
<span class="token function">nohup</span> <span class="token function">sh</span> ./startTarPackConf.sh <span class="token operator">&gt;&gt;</span> ./logs/tar_pack.log <span class="token operator">&amp;</span>
</code></pre> 
<p>查看进程</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># ps -aux | grep tar</span>
root       <span class="token number">2473</span>  <span class="token number">0.0</span>  <span class="token number">0.3</span> <span class="token number">113284</span>   <span class="token number">848</span> pts/1    S    09:48   <span class="token number">0</span>:02 <span class="token function">sh</span> start_tar_pack_conf.sh
</code></pre> 
<blockquote> 
 <p>拉起后会作为后台进程常驻，需要停止的话，查看pid，然后kill掉即可。</p> 
</blockquote> 
<ol start="3"><li><strong>创建启动prometheus组件，脚本startPrometheusSvr.sh</strong></li></ol> 
<p>startPrometheusSvr.sh内容：</p> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token function">nohup</span> ./prometheus --storage.tsdb.retention.time<span class="token operator">=</span>180d --web.enable-lifecycle --config.file<span class="token operator">=</span>./conf/prometheus.yml --log.level<span class="token operator">=</span>warn --log.format<span class="token operator">=</span>json <span class="token operator">&gt;&gt;</span> ./logs/prometheus_run_status.log <span class="token operator">&amp;</span>
</code></pre> 
<blockquote> 
 <p>数据保留周期是180天，请根据实际情况调整，其他参数的意义请自行help</p> 
</blockquote> 
<blockquote> 
 <p>在上面脚本的启动参数中，也可以通过参数–storage.tsdb.path="data/"修改本地数据存储的路径，不指定的话，时序数据默认是在prometheus的data目录下，如需修改数据的存储路径，建议存放在性能好（SSD、高端磁盘阵列）、容量大的目录中。</p> 
</blockquote> 
<p>接着启动prometheus</p> 
<pre><code class="prism language-shell"><span class="token comment"># 拉起</span>
<span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># sh startPrometheusSvr.sh</span>
</code></pre> 
<p>查看进程，检查是否启动成功</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># ps -aux | grep prometheus</span>
root       <span class="token number">1201</span>  <span class="token number">0.0</span> <span class="token number">30.1</span> <span class="token number">1100628</span> <span class="token number">66840</span> pts/0   Sl   08:45   <span class="token number">0</span>:22 ./prometheus --web.enable-lifecycle --config.file<span class="token operator">=</span>./conf/prometheus.yml --log.level<span class="token operator">=</span>warn --log.format<span class="token operator">=</span>json
</code></pre> 
<ol start="4"><li><strong>为了方便热重启操作，创建脚本hot_restart_prometheus.sh，当修改了配置文件后，就手动执行这个脚本进行热重启</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token function">curl</span> -X POST http://127.0.0.1:9090/-/reload
</code></pre> 
<p>平滑重启示例</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># sh hot_restart_prometheus.sh </span>
</code></pre> 
<blockquote> 
 <p>在日常维护中，当配置文件发生了变更就可以利用该脚本进行平滑重启</p> 
</blockquote> 
<ol start="5"><li><strong>创建汇总启动脚本start_all.sh</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token function">sh</span> ./startPromconfSyncApi.sh
<span class="token function">nohup</span> <span class="token function">sh</span> ./startTarPackConf.sh <span class="token operator">&gt;&gt;</span> ./logs/tar_pack.log <span class="token operator">&amp;</span>
<span class="token function">sh</span> ./startPrometheusSvr.sh
</code></pre> 
<blockquote> 
 <p>以后就不用一个一个脚本拉起了，直接拉起该脚本即可一并启动</p> 
</blockquote> 
<ol start="6"><li><strong>为了增加安全性，仅允许slave主机访问配置文件拉取服务的端口（笔者这里是8000端口）</strong></li></ol> 
<p>在tcp协议中禁止所有的ip访问本机的8000端口，仅允许slave主机（192.168.11.147）访问本机的8000端口（注意按顺序执行）</p> 
<pre><code class="prism language-shell">iptables -I INPUT -p tcp --dport <span class="token number">8000</span> -j DROP
iptables -I INPUT -s <span class="token number">192.168</span>.11.147 -p tcp --dport <span class="token number">8000</span> -j ACCEPT
</code></pre> 
<p>查看规则</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># iptables -nvL</span>
Chain INPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">9</span> packets, <span class="token number">744</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination         
    <span class="token number">8</span>   <span class="token number">552</span> ACCEPT     tcp  --  *      *       <span class="token number">192.168</span>.11.147       <span class="token number">0.0</span>.0.0/0            tcp dpt:8000
    <span class="token number">0</span>     <span class="token number">0</span> DROP       tcp  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            tcp dpt:8000
</code></pre> 
<p>保存规则</p> 
<blockquote> 
 <p>注意：使用此命令的规则位置可以是任意的，此方式保存的规则在重启机器后无法自动生效，需要使用命令iptables-restart恢复），笔者这里是保存在了/etc/sysconfig/my-iptable-rule-script</p> 
</blockquote> 
<pre><code class="prism language-shell"><span class="token comment"># 保存</span>
<span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># iptables-save &gt; /etc/sysconfig/my-iptable-rule-script</span>

<span class="token comment"># 查看</span>
<span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># cat /etc/sysconfig/my-iptable-rule-script</span>
<span class="token comment"># Generated by iptables-save v1.4.21 on Mon May 30 10:37:12 2022</span>
*filter
:INPUT ACCEPT <span class="token punctuation">[</span><span class="token number">49</span>:4408<span class="token punctuation">]</span>
:FORWARD ACCEPT <span class="token punctuation">[</span><span class="token number">0</span>:0<span class="token punctuation">]</span>
:OUTPUT ACCEPT <span class="token punctuation">[</span><span class="token number">27</span>:4840<span class="token punctuation">]</span>
-A INPUT -s <span class="token number">192.168</span>.11.147/32 -p tcp -m tcp --dport <span class="token number">8000</span> -j ACCEPT
-A INPUT -p tcp -m tcp --dport <span class="token number">8000</span> -j DROP
COMMIT
<span class="token comment"># Completed on Mon May 30 10:37:12 2022</span>
</code></pre> 
<p>手动清空规则，模拟规则丢失后，从文件中加载</p> 
<pre><code class="prism language-shell"><span class="token comment"># 查看</span>
<span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># iptables -nvL</span>
Chain INPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">122</span> packets, <span class="token number">12944</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination         
    <span class="token number">0</span>     <span class="token number">0</span> ACCEPT     tcp  --  *      *       <span class="token number">192.168</span>.11.147       <span class="token number">0.0</span>.0.0/0            tcp dpt:8000
    <span class="token number">0</span>     <span class="token number">0</span> DROP       tcp  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            tcp dpt:8000

Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT <span class="token number">0</span> packets, <span class="token number">0</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination         

Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">86</span> packets, <span class="token number">14400</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination         
<span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># </span>

<span class="token comment"># 手动清空</span>
<span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># iptables -F</span>

<span class="token comment"># 清空后查看</span>
<span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># iptables -nvL</span>
Chain INPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">12</span> packets, <span class="token number">1056</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination         

Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT <span class="token number">0</span> packets, <span class="token number">0</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination         

Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">7</span> packets, <span class="token number">1080</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination         
<span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># </span>

<span class="token comment"># 使用iptables-restore命令还原iptables-save命令所备份的iptables配置</span>
<span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># iptables-restore &lt; /etc/sysconfig/my-iptable-rule-script </span>

<span class="token comment"># 还原后查看</span>
<span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># iptables -nvL</span>
Chain INPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">34</span> packets, <span class="token number">2992</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination         
    <span class="token number">0</span>     <span class="token number">0</span> ACCEPT     tcp  --  *      *       <span class="token number">192.168</span>.11.147       <span class="token number">0.0</span>.0.0/0            tcp dpt:8000
    <span class="token number">0</span>     <span class="token number">0</span> DROP       tcp  --  *      *       <span class="token number">0.0</span>.0.0/0            <span class="token number">0.0</span>.0.0/0            tcp dpt:8000

Chain FORWARD <span class="token punctuation">(</span>policy ACCEPT <span class="token number">0</span> packets, <span class="token number">0</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination         

Chain OUTPUT <span class="token punctuation">(</span>policy ACCEPT <span class="token number">18</span> packets, <span class="token number">2480</span> bytes<span class="token punctuation">)</span>
 pkts bytes target     prot opt <span class="token keyword">in</span>     out     <span class="token builtin class-name">source</span>               destination         
<span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># </span>
</code></pre> 
<blockquote> 
 <p>特别说明：预防规则重启后丢失的办法还有一种，就是将配置规则写入到启动文件中，如/etc/rc.local，笔者之前将规则保存在/etc/sysconfig/my-iptable-rule-script文件中，那么就可以将恢复的命令 iptables-restore &lt; /etc/sysconfig/my-iptable-rule-script 写入到/etc/rc.local中</p> 
</blockquote> 
<blockquote> 
 <p>特别注意：如果您的环境和笔者不一样，请自行更改为您自己的IP和端口即可。</p> 
</blockquote> 
<ol start="7"><li><strong>创建汇总停止脚本stop_all.sh</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token function">ps</span> -aux <span class="token operator">|</span> <span class="token function">grep</span> SimpleHTTPServer <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token function">grep</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2}'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">kill</span>
<span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> startTarPackConf.sh <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token function">grep</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2}'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">kill</span>
<span class="token function">ps</span> -aux <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token function">grep</span> <span class="token operator">|</span> <span class="token function">grep</span> prometheus <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2}'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">kill</span>
</code></pre> 
<blockquote> 
 <p>日常维护中，如有需要停止全部服务的需求，运行该脚本即可。</p> 
</blockquote> 
<hr> 
<h3><a id="2_slave_337"></a>2. slave部署配置文件拉取服务</h3> 
<blockquote> 
 <p>特别说明：在slave主机上，请在规范的目录下创建conf、logs、backup目录</p> 
</blockquote> 
<ol><li><strong>将首次安装完成的prometheus.yml文件移动到当前的conf目录下</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token function">mv</span> ./prometheus.yml ./conf/
</code></pre> 
<blockquote> 
 <p>之所以要移动slave本身的prometheus.yml，是因为要从master同步过来已经规划好的conf配置目录，拉取后会覆盖slave上的conf目录，以后都以master的配置为主</p> 
</blockquote> 
<ol start="2"><li><strong>准备启动prometheus组件的脚本</strong><br> 脚本/usr/local/prometheus/startPrometheusSvr.sh，代码：</li></ol> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token function">nohup</span> ./prometheus --storage.tsdb.retention.time<span class="token operator">=</span>180d --web.enable-lifecycle --config.file<span class="token operator">=</span>./conf/prometheus.yml --log.level<span class="token operator">=</span>warn --log.format<span class="token operator">=</span>json <span class="token operator">&gt;&gt;</span> ./logs/prometheus_run_status.log <span class="token operator">&amp;</span>
</code></pre> 
<blockquote> 
 <p>数据保留周期是180天，请根据实际情况调整，其他参数的意义请自行help</p> 
</blockquote> 
<blockquote> 
 <p>在上面脚本的启动参数中，也可以通过参数–storage.tsdb.path="data/"修改本地数据存储的路径，不指定的话，时序数据默认是在prometheus的data目录下，如需修改数据的存储路径，建议存放在性能好（SSD、高端磁盘阵列）、容量大的目录中。</p> 
</blockquote> 
<ol start="3"><li><strong>接着启动prometheus，并检查是否启动成功</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@prosvr-slave prometheus<span class="token punctuation">]</span><span class="token comment"># sh startPrometheusSvr.sh</span>
<span class="token punctuation">[</span>root@prosvr-slave prometheus<span class="token punctuation">]</span><span class="token comment"># ps -aux | grep prometheus</span>
root       <span class="token number">5107</span>  <span class="token number">3.7</span> <span class="token number">16.0</span> <span class="token number">768960</span> <span class="token number">35456</span> pts/0    Sl   <span class="token number">17</span>:18   <span class="token number">0</span>:00 ./prometheus --web.enable-lifecycle --config.file<span class="token operator">=</span>./conf/prometheus.yml --log.level<span class="token operator">=</span>warn --log.format<span class="token operator">=</span>json
root       <span class="token number">5114</span>  <span class="token number">0.0</span>  <span class="token number">0.4</span> <span class="token number">112812</span>   <span class="token number">976</span> pts/0    R+   <span class="token number">17</span>:18   <span class="token number">0</span>:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto prometheus
You have new mail <span class="token keyword">in</span> /var/spool/mail/root

<span class="token punctuation">[</span>root@prosvr-slave prometheus<span class="token punctuation">]</span><span class="token comment"># netstat -tulnp | grep prometheus</span>
tcp6       <span class="token number">0</span>      <span class="token number">0</span> :::9090                 :::*                    LISTEN      <span class="token number">5107</span>/./prometheus   
<span class="token punctuation">[</span>root@prosvr-slave prometheus<span class="token punctuation">]</span><span class="token comment"># </span>
</code></pre> 
<ol start="4"><li><strong>准备从master拉取配置文件目录的脚本startUpdateSyncConf.sh，代码：</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token assign-left variable">time_log</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span> <span class="token string">"+%Y-%m-%d %H:%M:%S"</span><span class="token variable">`</span></span>
<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${time_log}</span> 配置更新器启动"</span>

<span class="token assign-left variable">pull_wait_sec</span><span class="token operator">=</span><span class="token number">2</span>

<span class="token keyword">while</span> <span class="token boolean">true</span>
<span class="token keyword">do</span>
  <span class="token function">wget</span> http://192.168.11.146:8000/notice_slave.action -O notice_slave.action <span class="token operator">&gt;</span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span>
  <span class="token assign-left variable">status</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> ./notice_slave.action<span class="token variable">`</span></span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">${status}</span> -eq <span class="token number">1</span> <span class="token punctuation">]</span>
  <span class="token keyword">then</span>
    <span class="token assign-left variable">time_bak</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span> <span class="token string">"+%Y%m%d%H%M%S"</span><span class="token variable">`</span></span>
    <span class="token assign-left variable">time_log</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span> <span class="token string">"+%Y-%m-%d %H:%M:%S"</span><span class="token variable">`</span></span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${time_log}</span> 从master下载配置压缩包文件"</span>
    <span class="token function">wget</span> http://192.168.11.146:8000/conf.tar.gz -O conf.tar.gz
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${time_log}</span> 备份原有的配置目录"</span>
    <span class="token function">mv</span> ./conf ./backup/conf_bak_<span class="token variable">${time_bak}</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${time_log}</span> 解压下载后的配置压缩包"</span>
    <span class="token function">tar</span> -zxf conf.tar.gz
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">${time_log}</span> 热重启prometheus服务"</span>
    <span class="token function">curl</span> -X POST http://127.0.0.1:9090/-/reload
  <span class="token keyword">fi</span>
  <span class="token function">sleep</span> <span class="token variable">${pull_wait_sec}</span>
<span class="token keyword">done</span>                                              
</code></pre> 
<blockquote> 
 <p>pull_wait_sec参数控制每隔时间工作一次，首先会从master中拉取通知文件notice_slave.action，并读取里面的结果，如果是1，则说明master上的配置文件有变化，接着会执行一系列操作。如果是0，则什么也不做。</p> 
</blockquote> 
<ol start="5"><li><strong>创建热重启的脚本hot_restart_prometheus.sh</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token function">curl</span> -X POST http://127.0.0.1:9090/-/reload
</code></pre> 
<blockquote> 
 <p>日常维护中，在slave主机上，如有必要时方便手动执行热重启</p> 
</blockquote> 
<ol start="6"><li><strong>创建汇总启动脚本start_all.sh</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token function">nohup</span> <span class="token function">sh</span> startUpdateSyncConf.sh <span class="token operator">&gt;</span> ./logs/update_sync.log <span class="token operator">&amp;</span>
<span class="token function">sleep</span> <span class="token number">3</span>
<span class="token function">sh</span> ./startPrometheusSvr.sh
</code></pre> 
<blockquote> 
 <p>日常维护中，如需一次性拉起服务，执行该脚本即可</p> 
</blockquote> 
<ol start="7"><li><strong>创建汇总停止脚本stop_all.sh</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token function">ps</span> -aux <span class="token operator">|</span> <span class="token function">grep</span> startUpdateSyncConf.sh <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token function">grep</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2}'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">kill</span>
<span class="token function">ps</span> -aux <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token function">grep</span> <span class="token operator">|</span> <span class="token function">grep</span> prometheus <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2}'</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">kill</span>
</code></pre> 
<blockquote> 
 <p>日常维护中，如需一次性停止服务，执行该脚本即可</p> 
</blockquote> 
<hr> 
<h2><a id="mysql_425"></a>四、监控mysql案例</h2> 
<blockquote> 
 <p>prometheus如何监控mysql？很简单，只需要在运行mysql的主机上安装mysqld_exporter，mysqld_exporter的用途是啥？说白了它就是用来收集mysql数据库相关指标的程序（官方就有，而且是go语言写的），mysqld_exporter启动后默认监听9104端口（当然启动时可以通过相应参数进行更改），且它连接上数据库采集相应指标，并等着prometheus服务器来拉取。所以，需要在mysql中创建一个专门用于采集监控指标的数据库账号，让mysqld_exporter通过这个账号去登录数据库采集指标，且这个账号要有相关权限（合适的权限即可）。所以的合适，请自行根据实际情况决定要给什么权限，如果是生产环境，一般的原则是：最小原则、够用就好。</p> 
</blockquote> 
<ol><li><strong>mysql测试环境信息</strong></li></ol> 
<ul><li>以下是笔者的mysql测试环境</li></ul> 
<table><thead><tr><th>数据库</th><th>操作系统</th><th>IP</th></tr></thead><tbody><tr><td>mysql8.0</td><td>centos7</td><td>192.168.11.150</td></tr></tbody></table> 
<blockquote> 
 <p>说明：本篇只讲解如何使用Prometheus监控MySQL，MySQL本身的安装过程不在本篇范围内，请自行将MySQL安装好。</p> 
</blockquote> 
<ol start="2"><li><strong>下载mysqld_exporter</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token function">wget</span> https://github.com/prometheus/mysqld_exporter/releases/download/v0.14.0/mysqld_exporter-0.14.0.linux-amd64.tar.gz
</code></pre> 
<ol start="3"><li><strong>登录mysql创建用于采集指标数据的专有账户</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token comment"># 创建账号</span>
mysql<span class="token operator">&gt;</span> create user <span class="token string">'exporter_user'</span>@<span class="token string">'localhost'</span> identified by <span class="token string">'Root.123456'</span> with max_user_connections <span class="token number">3</span><span class="token punctuation">;</span>
Query OK, <span class="token number">0</span> rows affected <span class="token punctuation">(</span><span class="token number">0.06</span> sec<span class="token punctuation">)</span>

<span class="token comment"># 授权</span>
mysql<span class="token operator">&gt;</span> grant process, replication client, <span class="token keyword">select</span> on *.* to <span class="token string">'exporter_user'</span>@<span class="token string">'localhost'</span><span class="token punctuation">;</span>
Query OK, <span class="token number">0</span> rows affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment"># 刷新权限</span>
mysql<span class="token operator">&gt;</span> flush privileges<span class="token punctuation">;</span>
Query OK, <span class="token number">0</span> rows affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment"># 查看权限</span>
mysql<span class="token operator">&gt;</span> show grants <span class="token keyword">for</span> exporter_user@localhost<span class="token punctuation">\</span>G<span class="token punctuation">;</span>  
*************************** <span class="token number">1</span>. row ***************************
Grants <span class="token keyword">for</span> exporter_user@localhost: GRANT SELECT, PROCESS, REPLICATION CLIENT ON *.* TO <span class="token variable"><span class="token variable">`</span>exporter_user<span class="token variable">`</span></span>@<span class="token variable"><span class="token variable">`</span>localhost<span class="token variable">`</span></span>
<span class="token number">1</span> row <span class="token keyword">in</span> <span class="token builtin class-name">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

ERROR: 
No query specified

<span class="token comment"># 查看账号</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> user,host from mysql.user<span class="token punctuation">;</span>
+------------------+-----------+
<span class="token operator">|</span> user             <span class="token operator">|</span> <span class="token function">host</span>      <span class="token operator">|</span>
+------------------+-----------+
<span class="token operator">|</span> exporter         <span class="token operator">|</span> localhost <span class="token operator">|</span> <span class="token comment"># 这个，笔者曾经创建过的，不管它了</span>
<span class="token operator">|</span> exporter_user    <span class="token operator">|</span> localhost <span class="token operator">|</span> <span class="token comment"># 这个是刚刚创建好的，就用这个啦！</span>
<span class="token operator">|</span> mysql.infoschema <span class="token operator">|</span> localhost <span class="token operator">|</span>
<span class="token operator">|</span> mysql.session    <span class="token operator">|</span> localhost <span class="token operator">|</span>
<span class="token operator">|</span> mysql.sys        <span class="token operator">|</span> localhost <span class="token operator">|</span>
<span class="token operator">|</span> root             <span class="token operator">|</span> localhost <span class="token operator">|</span>
<span class="token operator">|</span> ttr1             <span class="token operator">|</span> localhost <span class="token operator">|</span>
+------------------+-----------+
<span class="token number">7</span> rows <span class="token keyword">in</span> <span class="token builtin class-name">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> 
</code></pre> 
<blockquote> 
 <p>关于mysql的数据库账号权限的授权和回收的知识，笔者以后会出一个专题，专门深入浅出的剖析，敬请大家的关注！</p> 
</blockquote> 
<ol start="4"><li><strong>部署mysqld_exporter</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token comment"># 下载完成后，解压，并移动到规定的目录下（目录可自定义哈）</span>
<span class="token function">tar</span> -zxf mysqld_exporter-0.14.0.linux-amd64.tar.gz 
<span class="token punctuation">[</span>root@mysql8db ~<span class="token punctuation">]</span><span class="token comment"># mkdir /usr/local/exporter/</span>
<span class="token punctuation">[</span>root@mysql8db ~<span class="token punctuation">]</span><span class="token comment"># mv mysqld_exporter-0.14.0.linux-amd64 /usr/local/exporter/mysqld_exporter</span>
<span class="token punctuation">[</span>root@mysql8db ~<span class="token punctuation">]</span><span class="token comment"># cd /usr/local/exporter/mysqld_exporter/</span>
<span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment"># ll</span>
total <span class="token number">14824</span>
-rw-r--r-- <span class="token number">1</span> <span class="token number">3434</span> <span class="token number">3434</span>    <span class="token number">11357</span> Mar  <span class="token number">5</span> 00:30 LICENSE
-rwxr-xr-x <span class="token number">1</span> <span class="token number">3434</span> <span class="token number">3434</span> <span class="token number">15163162</span> Mar  <span class="token number">5</span> 00:25 mysqld_exporter <span class="token comment"># 这个就是可执行程序</span>
-rw-r--r-- <span class="token number">1</span> <span class="token number">3434</span> <span class="token number">3434</span>       <span class="token number">65</span> Mar  <span class="token number">5</span> 00:30 NOTICE
</code></pre> 
<ol start="5"><li><strong>创建连接mysql的配置文件并启动mysqld_exporter</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token comment"># 创建连接mysql的配置文件</span>
<span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment"># cat &gt; exporter_conn_mysql.conf &lt;&lt;EOF</span>
<span class="token operator">&gt;</span> <span class="token punctuation">[</span>client<span class="token punctuation">]</span>
<span class="token operator">&gt;</span> <span class="token assign-left variable">user</span><span class="token operator">=</span>exporter_user
<span class="token operator">&gt;</span> <span class="token assign-left variable">password</span><span class="token operator">=</span>Root.123456
<span class="token operator">&gt;</span> EOF

<span class="token comment"># 查看创建好的配置文件</span>
<span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment"># cat exporter_conn_mysql.conf </span>
<span class="token punctuation">[</span>client<span class="token punctuation">]</span>
<span class="token assign-left variable">user</span><span class="token operator">=</span>exporter_user
<span class="token assign-left variable">password</span><span class="token operator">=</span>Root.123456
<span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment"># </span>
</code></pre> 
<ol start="6"><li><strong>启动mysqld_exporter</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token comment"># 为了方便启动，创建一个启动脚本</span>
<span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment"># cat &gt; start_mysqld_exporter.sh &lt;&lt;EOF</span>
<span class="token operator">&gt;</span> <span class="token function">nohup</span> ./mysqld_exporter --config.my-cnf<span class="token operator">=</span>./exporter_conn_mysql.conf <span class="token operator">&amp;</span>
<span class="token operator">&gt;</span> EOF
<span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment">#</span>

<span class="token comment"># 查看创建好的启动脚本 </span>
<span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment"># cat start_mysqld_exporter.sh </span>
<span class="token function">nohup</span> ./mysqld_exporter --config.my-cnf<span class="token operator">=</span>./exporter_conn_mysql.conf <span class="token operator">&amp;</span>
<span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment"># </span>

<span class="token comment"># 开始启动</span>
<span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment"># sh start_mysqld_exporter.sh </span>

<span class="token comment"># 启动后查看相关端口（默认的端口为9104）</span>
<span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment"># netstat -tulnp | grep mysql</span>
tcp6       <span class="token number">0</span>      <span class="token number">0</span> :::33060                :::*                    LISTEN      <span class="token number">1916</span>/mysqld         
tcp6       <span class="token number">0</span>      <span class="token number">0</span> :::3306                 :::*                    LISTEN      <span class="token number">1916</span>/mysqld         
tcp6       <span class="token number">0</span>      <span class="token number">0</span> :::9104                 :::*                    LISTEN      <span class="token number">2073</span>/./mysqld_expor <span class="token comment"># 这个就是啦！</span>
<span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment"># </span>
<span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment"># </span>
</code></pre> 
<blockquote> 
 <p>说明：咦！–config.my-cnf这个参数我咋知道的？当然是可以使用help啦!这样 ./mysqld_exporter --help 就可以知道有哪些选项啦！</p> 
</blockquote> 
<blockquote> 
 <p>还有一个奇怪的问题，怎么只有ipv6在监听？没有IPV4？其实不是啦！centos7以上，都是ipv6优先的原则，对ipv6的支持默认是开启的，ipv4其实也是有在监听的啦!</p> 
</blockquote> 
<ol start="7"><li><strong>启动后，通过浏览器访问指标页面</strong></li></ol> 
<ul><li>暴露的HTTP服务地址（http://192.168.11.150:9104/metrics）<br> <img src="https://images2.imgbox.com/59/d5/B9f7aQ59_o.png" alt="在这里插入图片描述"></li></ul> 
<blockquote> 
 <p>看到这些指标了吗？Prometheus服务端会周期性的从Exporter暴露的HTTP服务地址（通常是/metrics）拉取监控样本数据。</p> 
</blockquote> 
<p>指标内容简单说明：</p> 
<ul><li>HELP：用于解释当前指标的含义</li><li>TYPE：说明当前指标的数据类型</li></ul> 
<p>比如下面的一个指标</p> 
<pre><code class="prism language-text"># HELP mysql_up Whether the MySQL server is up. # MySQL服务器是否启动
# TYPE mysql_up gauge # 指标的数据类型是gauge，测量、检测的意思，也有仪表盘的意思？
mysql_up 1 # mysql_up反应当前的状态，当前的值为1，说明是启动的，也可能为0（停止状态）
</code></pre> 
<p>笔者去把Mysql给停止了，再次刷新指标页面，查看这个指标，发现确实变成了0</p> 
<p><img src="https://images2.imgbox.com/5c/18/UludpHm5_o.png" alt="在这里插入图片描述"></p> 
<ol start="8"><li><strong>查看采集过程输出的相关信息</strong></li></ol> 
<blockquote> 
 <p>刚刚是通过nohup将mysqld_exporter程序丢入到后台启动的，所以相关的输出信息默认是会写入nohup.out文件中</p> 
</blockquote> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@mysql8db mysqld_exporter<span class="token punctuation">]</span><span class="token comment"># tailf nohup.out </span>
<span class="token assign-left variable">ts</span><span class="token operator">=</span><span class="token number">2022</span>-05-21T13:40:01.735Z <span class="token assign-left variable">caller</span><span class="token operator">=</span>mysqld_exporter.go:277 <span class="token assign-left variable">level</span><span class="token operator">=</span>info <span class="token assign-left variable">msg</span><span class="token operator">=</span><span class="token string">"Starting mysqld_exporter"</span> <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token string">"(version=0.14.0, branch=HEAD, revision=ca1b9af82a471c849c529eb8aadb1aac73e7b68c)"</span>
<span class="token assign-left variable">ts</span><span class="token operator">=</span><span class="token number">2022</span>-05-21T13:40:01.735Z <span class="token assign-left variable">caller</span><span class="token operator">=</span>mysqld_exporter.go:278 <span class="token assign-left variable">level</span><span class="token operator">=</span>info <span class="token assign-left variable">msg</span><span class="token operator">=</span><span class="token string">"Build context"</span> <span class="token punctuation">(</span>gogo1.17.8,userroot@401d370ca42e
<span class="token punctuation">..</span>.
<span class="token punctuation">..</span>.
</code></pre> 
<blockquote> 
 <p>到此为止，在Mysql服务器主机上部署mysqld_exporter的任务算是大功告成。</p> 
</blockquote> 
<blockquote> 
 <p>接下来回到Prometheus Master中继续以下的操作</p> 
</blockquote> 
<ol start="9"><li><strong>在Prometheus Master中配置从mysqld_exporter收集监控数据</strong></li></ol> 
<blockquote> 
 <p>在Master中的prometheus主配置文件中的scrape_configs配置项添加基于文件的自动发现job</p> 
</blockquote> 
<blockquote> 
 <p>一定要注意：只需在master上做相关配置，slave主机会定时拉取master的配置目录和master保持同步，且slave的配置发生变更还会自动热重启使其生效，也就是说slave不用你操心，你只需管理好你的master就好。</p> 
</blockquote> 
<blockquote> 
 <p>再罗嗦一次：<strong>以下操作仅在master上操作。</strong></p> 
</blockquote> 
<p><strong>在主配置文件/usr/local/prometheus/conf/prometheus.yml中添加测试业务A的job</strong></p> 
<blockquote> 
 <p>说明：下面的job_name为prometheus_server是拉取prometheus本身的指标数据（也就是监控其本身），IP地址是指向VIP：192.168.11.203，指向VIP这是建议的做法。</p> 
</blockquote> 
<pre><code class="prism language-shell">scrape_configs:
  - job_name: <span class="token string">'prometheus_server'</span>
    static_configs:
    - targets: <span class="token punctuation">[</span><span class="token string">'192.168.11.203:9090'</span><span class="token punctuation">]</span>

  - job_name: <span class="token string">'测试业务A'</span>
    file_sd_configs:
    - files:
      - <span class="token string">'./business/test_bus_a/job/*.yml'</span>
      refresh_interval: 1s
</code></pre> 
<p><strong>参数说明：</strong></p> 
<ul><li>'测试业务A’的job_name：定义自发现的采集任务名称，按业务的维度进行定义名称，笔者这里叫“测试业务A”</li><li>file_sd_configs：这是基于文件的自动发现，即&lt;file_sd_configs&gt;，下面这块配置都是和file_sd_configs有关的，详细说明如下:</li></ul> 
<pre><code class="prism language-yaml">    <span class="token key atrule">file_sd_configs</span><span class="token punctuation">:</span> <span class="token comment"># 指定这是基于文件的自动发现</span>
    <span class="token punctuation">-</span> <span class="token key atrule">files</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'./business/test_bus_a/job/*.yml'</span> <span class="token comment"># 指定自动发现配置文件的路径，这里表示在该路径下发现所有.yml格式的配置文件</span>
      <span class="token key atrule">refresh_interval</span><span class="token punctuation">:</span> 1s <span class="token comment"># 自动发现间隔，时间默认是5秒，笔者这里设置了1秒。</span>
</code></pre> 
<ol start="10"><li><strong>在规划好的业务目录（business）下创建对应的业务文件夹：test_bus_a，以及在业务目录test_bus_a下面创建job目录，并进入job目录创建mysql.yml（该名称可自定义，也可叫mon_mysql.yml或者其他，主要你喜欢就好！）在mysql.yml中定义拉取mysql的监控指标数据</strong></li></ol> 
<ul><li>./conf/business/test_bus_a/job/mysql.yml的内容如下：</li></ul> 
<pre><code class="prism language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token string">'192.168.11.150:9104'</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">ip</span><span class="token punctuation">:</span> <span class="token string">'192.168.11.150'</span>
    <span class="token key atrule">monitype</span><span class="token punctuation">:</span> <span class="token string">'mysql'</span>
    <span class="token key atrule">project</span><span class="token punctuation">:</span> <span class="token string">'测试业务A'</span>
    <span class="token key atrule">business</span><span class="token punctuation">:</span> <span class="token string">'测试业务A'</span>
</code></pre> 
<p><strong>参数说明：</strong></p> 
<ul><li>targets：拉取目标，这里指向mysql服务器的IP地址，mysqld_exporter的端口是9104</li><li>labels：这是标签，标签的主要作用是可以通过指定的标签查询指定的数据。</li></ul> 
<blockquote> 
 <p>标签的作用：Prometheus中存储的数据为时间序列，是由Metric的名字和一系列的标签(键值对)唯一标识的, 不同的标签代表不同的时间序列，即通过指定标签查询指定数据。不同的标签代表不同的时间序列，即通过指定标签查询指定数据。指标+标签实现了查询条件的作用，可以指定不同的标签过滤不同的数据。</p> 
</blockquote> 
<p><strong>在Prometheus UI中对应的Labels信息如下图可见：</strong></p> 
<p><img src="https://images2.imgbox.com/f8/f4/b3N3laRs_o.png" alt="在这里插入图片描述"></p> 
<p><strong>假设有个需求，需要知道被监控的mysql服务器所在的机房位置，那么就可以增加一个自定义标签，如下：</strong></p> 
<ul><li>./conf/business/test_bus_a/job/mysql.yml</li></ul> 
<pre><code class="prism language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token string">'192.168.11.150:9104'</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">ip</span><span class="token punctuation">:</span> <span class="token string">'192.168.11.150'</span>
    <span class="token key atrule">monitype</span><span class="token punctuation">:</span> <span class="token string">'mysql'</span>
    <span class="token key atrule">project</span><span class="token punctuation">:</span> <span class="token string">'测试业务A'</span>
    <span class="token key atrule">business</span><span class="token punctuation">:</span> <span class="token string">'测试业务A'</span>
    <span class="token key atrule">region</span><span class="token punctuation">:</span> <span class="token string">'广州机房'</span>
</code></pre> 
<p>在Prometheus UI中可以看到：</p> 
<ul><li>不管你是用VIP、还是master、slave的物理IP去访问UI，结果都一样的，不信你试试。</li></ul> 
<p><img src="https://images2.imgbox.com/76/51/mF2cC7jg_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>自定义标签的主要应用场景：有了这些标签可以针对特定的标签去查询，比如笔者在上面的假设需求中，需要定义一个根据自定义标签region作为标识机房位置。总而言之，添加的标签越多，查询的维度就会越细。</p> 
</blockquote> 
<p><strong>在UI界面中的Graph面板中使用PromQL表达式查询特定监控指标的监控数据，如下查询“mysql_up”指标，如下图：</strong></p> 
<p><img src="https://images2.imgbox.com/0c/90/JlmkZCqp_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>PromQL是Prometheus自定义的一套强大的数据查询语言，除了使用监控指标作为查询关键字以为，还内置了大量的函数，帮助用户进一步对时序数据进行处理。例如使用rate()函数，可以计算在单位时间内样本数据的变化情况即增长率，通过PromQL我们可以非常方便的对数据进行查询，过滤，以及聚合，计算等操作。通过这些丰富的表达式语句，监控指标不再是一个单独存在的个体，而是一个个能够表达出正式业务含义的语言。当然，关于更多的PromQL知识，以后笔者会慢慢分享，本篇的重点是主备架构，可别跑题了呢！</p> 
</blockquote> 
<hr> 
<h2><a id="_659"></a>五、监控主机案例</h2> 
<blockquote> 
 <p>为了能够采集到主机的运行指标如CPU, 内存，磁盘等信息。可以使用Node Exporter。Node Exporter同样采用Golang编写，并且不存在任何的第三方依赖，只需要下载，解压即可运行。</p> 
</blockquote> 
<ol><li><strong>下载node_exporter并解压以及部署到指定目录</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token function">wget</span> https://github.com/prometheus/node_exporter/releases/download/v1.3.1/node_exporter-1.3.1.linux-amd64.tar.gz
<span class="token function">tar</span> -zxf node_exporter-1.3.1.linux-amd64.tar.gz
<span class="token function">mv</span> node_exporter-1.3.1.linux-amd64 /usr/local/exporter/node_exporter
<span class="token builtin class-name">cd</span> /usr/local/exporter/node_exporter/
</code></pre> 
<ol start="2"><li><strong>可通过help查看一堆启动参数</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@mysql8db node_exporter<span class="token punctuation">]</span><span class="token comment"># ./node_exporter --help</span>
usage: node_exporter <span class="token punctuation">[</span><span class="token operator">&lt;</span>flags<span class="token operator">&gt;</span><span class="token punctuation">]</span>

Flags:
  -h, --help                     Show context-sensitive <span class="token builtin class-name">help</span> <span class="token punctuation">(</span>also try --help-long and --help-man<span class="token punctuation">)</span>.
      --collector.bcache.priorityStats  
                                 Expose expensive priority stats.
      --collector.cpu.guest      Enables metric node_cpu_guest_seconds_total
      --collector.cpu.info       Enables metric cpu_info
<span class="token punctuation">..</span>.
<span class="token punctuation">..</span>.
</code></pre> 
<ol start="3"><li><strong>启动node_exporter</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token comment"># 丢入后台运行</span>
<span class="token punctuation">[</span>root@mysql8db node_exporter<span class="token punctuation">]</span><span class="token comment"># nohup ./node_exporter &amp;</span>

<span class="token comment"># 查看监听的端口</span>
<span class="token punctuation">[</span>root@mysql8db node_exporter<span class="token punctuation">]</span><span class="token comment"># netstat -tulnp | grep node_exporte</span>
tcp6       <span class="token number">0</span>      <span class="token number">0</span> :::9100                 :::*                    LISTEN      <span class="token number">1935</span>/./node_exporte 
<span class="token punctuation">[</span>root@mysql8db node_exporter<span class="token punctuation">]</span><span class="token comment"># </span>

<span class="token comment"># 通过nohup丢入后台运行，相关的输出会追加到nohup.out文件中，必要时可查看该文件诊断相关问题</span>
<span class="token punctuation">[</span>root@mysql8db node_exporter<span class="token punctuation">]</span><span class="token comment"># tailf nohup.out </span>
<span class="token assign-left variable">ts</span><span class="token operator">=</span><span class="token number">2022</span>-06-04T00:45:58.822Z <span class="token assign-left variable">caller</span><span class="token operator">=</span>node_exporter.go:115 <span class="token assign-left variable">level</span><span class="token operator">=</span>info <span class="token assign-left variable">collector</span><span class="token operator">=</span>thermal_zone
<span class="token assign-left variable">ts</span><span class="token operator">=</span><span class="token number">2022</span>-06-04T00:45:58.822Z <span class="token assign-left variable">caller</span><span class="token operator">=</span>node_exporter.go:115 <span class="token assign-left variable">level</span><span class="token operator">=</span>info <span class="token assign-left variable">collector</span><span class="token operator">=</span>time
<span class="token assign-left variable">ts</span><span class="token operator">=</span><span class="token number">2022</span>-06-04T00:45:58.822Z <span class="token assign-left variable">caller</span><span class="token operator">=</span>node_exporter.go:115 <span class="token assign-left variable">level</span><span class="token operator">=</span>info <span class="token assign-left variable">collector</span><span class="token operator">=</span>timex
<span class="token assign-left variable">ts</span><span class="token operator">=</span><span class="token number">2022</span>-06-04T00:45:58.822Z <span class="token assign-left variable">caller</span><span class="token operator">=</span>node_exporter.go:115 <span class="token assign-left variable">level</span><span class="token operator">=</span>info <span class="token assign-left variable">collector</span><span class="token operator">=</span>udp_queues
<span class="token punctuation">..</span>.
<span class="token punctuation">..</span>.
</code></pre> 
<blockquote> 
 <p>笔者没啥特殊的需求，所以无需额外在给定启动参数，直接丢入后台运行即可，默认的监听端口是9100</p> 
</blockquote> 
<ol start="4"><li><strong>通过浏览器查看node_exporter暴露的指标</strong></li></ol> 
<p><img src="https://images2.imgbox.com/bd/5c/Bdc4vqsJ_o.png" alt="在这里插入图片描述"></p> 
<ol start="5"><li><strong>在prometheus的master服务器中配置从node_exporter收集监控数据</strong></li></ol> 
<blockquote> 
 <p>假设笔者的这台主机是测试业务b（test_bus_b）的一台主机，请按照之前的业务目录规范，在规范的业务目录（conf/business）下创建业务文件夹test_bus_b。</p> 
</blockquote> 
<blockquote> 
 <p>再次罗嗦一次：仅需在master上做配置即可，slave会定时拉取masetr的配置目录，不要去管slave，OK？一个大男人那么罗嗦，真的很惹人讨厌啊！</p> 
</blockquote> 
<p><strong>在主配置文件中添加业务B的job</strong></p> 
<ul><li>主配置文件：/usr/local/prometheus/conf/prometheus.yml</li></ul> 
<pre><code class="prism language-shell">scrape_configs:
  - job_name: <span class="token string">'prometheus_server'</span>
    static_configs:
    - targets: <span class="token punctuation">[</span><span class="token string">'192.168.11.203:9090'</span><span class="token punctuation">]</span>

  - job_name: <span class="token string">'测试业务A'</span>
    file_sd_configs:
    - files:
      - <span class="token string">'./business/test_bus_a/job/*.yml'</span>
      refresh_interval: 1s

  - job_name: <span class="token string">'测试业务B'</span> <span class="token comment"># 这是新增加的测试业务B</span>
    file_sd_configs:
    - files:
      - <span class="token string">'./business/test_bus_b/job/*.yml'</span>
      refresh_interval: 1s
</code></pre> 
<p><strong>在规范的业务目录（conf/business）下创建业务文件夹test_bus_b，然后创建host.yml，增加targets（拉取目标）的配置</strong></p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@prosvr-master business<span class="token punctuation">]</span><span class="token comment"># cd /usr/local/prometheus/conf/business/</span>
<span class="token punctuation">[</span>root@prosvr-master business<span class="token punctuation">]</span><span class="token comment"># mkdir test_bus_b</span>
<span class="token punctuation">[</span>root@prosvr-master business<span class="token punctuation">]</span><span class="token comment"># cd test_bus_b/</span>
<span class="token punctuation">[</span>root@prosvr-master business<span class="token punctuation">]</span><span class="token comment"># mkdir job</span>
<span class="token punctuation">[</span>root@prosvr-master business<span class="token punctuation">]</span><span class="token comment"># cd job/</span>
<span class="token punctuation">[</span>root@prosvr-master job<span class="token punctuation">]</span><span class="token comment"># cat host.yml </span>
- targets:
  - <span class="token string">'192.168.11.150:9100'</span>
  labels:
    ip: <span class="token string">'192.168.11.150'</span>
    monitype: <span class="token string">'linux-centos7'</span>
    project: <span class="token string">'测试业务B'</span>
    business: <span class="token string">'测试业务B'</span>
    region: <span class="token string">'深圳机房'</span>
</code></pre> 
<p><strong>在Prometheus UI中查看新增的测试业务B</strong></p> 
<ul><li>不管你是用VIP、还是master、slave的物理IP去访问UI，结果都一样的，不信你试试。</li></ul> 
<p><img src="https://images2.imgbox.com/73/50/jaHarwBE_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>非常不错，只要检测到配置文件发生变化，master会自动热重启，slave也会自动拉取配置目录然后热重启，非常的省心、省力。自我感觉这个DIY的主备方案几乎接近完美，虽然没有用很高大上的语言、工具去实现，但笔者的这个思路自我感觉是非常的不错，这难道就是传说中的自我感觉良好？当然，笔者以后会通过Go或者Python打造一个管理Promtheus主备的工具，且是带UI的管理工具，敬请期待推出！我不造车，我只造零件。</p> 
</blockquote> 
<hr> 
<h2><a id="AlertManager_764"></a>六、AlertManager警报组件配置</h2> 
<blockquote> 
 <p>说明：基于二进制包的alertmanager组件请自行在master和slave中安装部署到规范的目录，之后继续下面的步骤。</p> 
</blockquote> 
<ol><li><strong>移动master和slave上的警报组件的主配置文件alertmanager.yml</strong></li></ol> 
<ul><li>在master和slave服务器上，alertmanager组件的二进制包解压到规范的目录后，将警报的主配置文件“alertmanager.yml”移动到prometheus组件的conf目录下</li></ul> 
<pre><code class="prism language-shell"><span class="token comment"># 移动后（也就是用mv命令移动），查看如下：</span>
<span class="token punctuation">[</span>root@prosvr-master conf<span class="token punctuation">]</span><span class="token comment"># pwd</span>
/usr/local/prometheus/conf
<span class="token punctuation">[</span>root@prosvr-master conf<span class="token punctuation">]</span><span class="token comment"># ll</span>
total <span class="token number">12</span>
-rw-r--r-- <span class="token number">1</span> <span class="token number">3434</span> <span class="token number">3434</span>  <span class="token number">348</span> Jun  <span class="token number">4</span> <span class="token number">13</span>:26 alertmanager.yml <span class="token comment"># 警报组件的主配置文件已经也在prometheus组件下的conf目录</span>
drwxr-xr-x <span class="token number">4</span> root root   <span class="token number">42</span> Jun  <span class="token number">4</span> 09:18 business
-rw-r--r-- <span class="token number">1</span> <span class="token number">3434</span> <span class="token number">3434</span> <span class="token number">1033</span> Jun  <span class="token number">4</span> <span class="token number">12</span>:27 prometheus.yml

<span class="token punctuation">[</span>root@prosvr-master conf<span class="token punctuation">]</span><span class="token comment"># </span>
</code></pre> 
<blockquote> 
 <p>特别注意：上述操作，在master和slave上都要操作，且在slave服务器移动alertmanager.yml配置文件后，往后就可以不用去管slave上的alertmanager.yml配置文件了，主要的配置变更都在master上进行就好，如果有变更，slave会自动拉取配置目录。通常警报组件的alertmanager.yml配置文件一旦配置好后，改动的频率比较少。</p> 
</blockquote> 
<blockquote> 
 <p>特别说明：之所以这么设计，有两个好处：1）配置的变更都在同一个目录下进行；2）利用了现有master和slave的配置目录同步能力</p> 
</blockquote> 
<ol start="2"><li><strong>在master上配置警报的主配置文件/usr/local/prometheus/conf/alertmanager.yml</strong></li></ol> 
<ul><li>在警报组件中配置告警消息发往的接口地址, 让其可以调用接口，配置方式很简单，只需要指定一下接口地址即可</li></ul> 
<pre><code class="prism language-shell">global:
  resolve_timeout: 5m
route:
  group_by: <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
  group_wait: 1s
  group_interval: 1s
  repeat_interval: 1000d
  receiver: <span class="token string">'web.hook'</span>
receivers:
- name: <span class="token string">'web.hook'</span>
  webhook_configs:
  - url: <span class="token string">'http://127.0.0.1:5001/webhook'</span>
    send_resolved: <span class="token boolean">true</span>
</code></pre> 
<blockquote> 
 <p>上述配置中，主要包含两大部分，路由（route）和接收器（receivers），所有的告警信息都会从配置中的顶级路由(route)进入路由树，根据路由规则将告警信息发送给相应的接收器。本篇主要是配置接收器，使用webhook的方式，假设是将告警消息推送到第三方平台。当然，在本篇仅为示例，打印出来而已。</p> 
</blockquote> 
<ol start="3"><li><strong>在master和slave上创建Alertmanager组件启动脚本</strong></li></ol> 
<ul><li>注意：该步骤一定要进入到/usr/local/alertmanager/目录下进行操作</li><li>创建脚本，名称：startAlertManagerSvr.sh</li></ul> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token function">nohup</span> ./alertmanager --config.file<span class="token operator">=</span>/usr/local/prometheus/conf/alertmanager.yml <span class="token operator">&gt;&gt;</span> ./logs/alert.log <span class="token operator">&amp;</span>
<span class="token punctuation">[</span>root@prosvr-master alertmanager<span class="token punctuation">]</span><span class="token comment"># </span>
</code></pre> 
<blockquote> 
 <p>注意：startAlertManagerSvr.sh脚本在masetr和slave中都要创建，且–config.file使用绝对路径指向alertmanager.yml</p> 
</blockquote> 
<p><strong>通过该脚本拉起alertmanager组件</strong></p> 
<pre><code class="prism language-shell"><span class="token function">sh</span> startAlertManagerSvr.sh
</code></pre> 
<blockquote> 
 <p>注意：master和slave都要拉起</p> 
</blockquote> 
<p>启动后，通过VIP或master和slave的物理IP都可以访问到警报的页面，笔者这里是使用VIP进行访问，如下图：</p> 
<p>在这里插入图片描述</p> 
<ol start="4"><li><strong>关联Prometheus与Alertmanager</strong></li></ol> 
<blockquote> 
 <p>注意：仅在master上配置即可，因为slave会从master上拉取</p> 
</blockquote> 
<ul><li>/usr/local/prometheus/conf/prometheus.yml</li></ul> 
<pre><code class="prism language-yaml"><span class="token key atrule">alerting</span><span class="token punctuation">:</span>
  <span class="token key atrule">alertmanagers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> 192.168.11.203<span class="token punctuation">:</span><span class="token number">9093</span>
</code></pre> 
<blockquote> 
 <p>笔者这里通过VIP跟Alertmanager组件通信，当prometheus中的警报规则触发了告警后，告警消息就会发送到警报组件监听的9093端口，由alertmanager组件进行处理</p> 
</blockquote> 
<ol start="5"><li><strong>配置警报规则文件的自动发现</strong></li></ol> 
<blockquote> 
 <p>注意：仅在master上配置即可</p> 
</blockquote> 
<ul><li>/usr/local/prometheus/conf/prometheus.yml</li></ul> 
<pre><code class="prism language-yaml"><span class="token key atrule">rule_files</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token string">"./business/test_bus_a/rule/*.rules"</span>
  <span class="token punctuation">-</span> <span class="token string">"./business/test_bus_b/rule/*.rules"</span>
</code></pre> 
<ol start="6"><li><strong>配置mysql的警报规则，当mysql挂掉后，使其触发警报</strong></li></ol> 
<blockquote> 
 <p>注意：仅在master上配置即可</p> 
</blockquote> 
<ul><li>/usr/local/prometheus/conf/business/test_bus_a/rule/mysql.rules</li></ul> 
<pre><code class="prism language-yaml"><span class="token key atrule">groups</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mysql<span class="token punctuation">-</span>alert
    <span class="token key atrule">rules</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">alert</span><span class="token punctuation">:</span> <span class="token string">"MysqlDown"</span>
      <span class="token key atrule">expr</span><span class="token punctuation">:</span> mysql_up<span class="token punctuation">{<!-- --></span>job="测试业务A"<span class="token punctuation">}</span>==0
      <span class="token key atrule">for</span><span class="token punctuation">:</span> 1m
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
      <span class="token key atrule">annotations</span><span class="token punctuation">:</span>
        <span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token string">"MySQL数据库服务:{<!-- -->{ $labels.ip }}发生停止告警"</span>
        <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"测试业务A的环境MySQL数据库服务:{<!-- -->{ $labels.ip }}已停止，当前UP状态值为：{<!-- -->{ $value }}，已触发告警条件：mysql_up = 0，持续时间：1m。"</span>
        <span class="token key atrule">alertLevel</span><span class="token punctuation">:</span> <span class="token number">5</span>
</code></pre> 
<blockquote> 
 <p>上面的案例很简单，expr是表达式，该表达式是说：如果mysql_up指标的值等于0那么就触发该警报</p> 
</blockquote> 
<p><strong>可以通过promtool工具检查警报规则配置文件是否有误</strong></p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># ./promtool check rules ./conf/business/test_bus_a/rule/mysql.rules </span>
Checking ./conf/business/test_bus_a/rule/mysql.rules
  SUCCESS: <span class="token number">1</span> rules found
</code></pre> 
<p><strong>配置文件发生了变更后，master会自动热重启，slave会自动拉取配置并热重启，直接在UI界面上可以查看到该规则</strong></p> 
<p><img src="https://images2.imgbox.com/1f/eb/pfgZ6plC_o.png" alt="在这里插入图片描述"></p> 
<ol start="7"><li><strong>笔者在这里假设用python编写了一个最简单的webhook接口，让其可以接收来自alertmanager的警报消息，然后打印出来</strong></li></ol> 
<blockquote> 
 <p>特别说明：只需在master上编写的webhook接口脚本，并且也放在规范的conf目录下：/usr/local/prometheus/conf/webhook.py，该API脚本会被slave拉取到</p> 
</blockquote> 
<ul><li>webhook.py简单的API代码如下：</li></ul> 
<pre><code class="prism language-python"><span class="token keyword">import</span> json
<span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token punctuation">,</span> request

app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>

<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/webhook'</span><span class="token punctuation">,</span> methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'POST'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">webhook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    data <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>request<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> <span class="token number">5001</span><span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>特别说明1：此示例API只是演示使用，请根据实际情况编写相关代码，本实例仅仅只是打印出来，并没有将告警推送到其他平台，如钉钉、邮件、或其他告警收敛平台。</p> 
</blockquote> 
<blockquote> 
 <p>特别说明2：如果您也想在您的测试环境将笔者的这个webhook.py跑起来，请自行安装python的flask库，笔者不在本篇讲解python的相关知识。python编程笔者后续会专门抽时间作为专题给大家分享，敬请您的关注。</p> 
</blockquote> 
<ol start="8"><li><strong>创建webhook API的启动脚本</strong></li></ol> 
<blockquote> 
 <p>说明：在master和slave都要创建startWebHook.sh脚本</p> 
</blockquote> 
<pre><code class="prism language-shell"><span class="token shebang important">#!/bin/sh</span>
<span class="token function">nohup</span> python ./conf/webhook.py <span class="token operator">&gt;&gt;</span> ./logs/webhook.log <span class="token operator">&amp;</span>
</code></pre> 
<ol start="9"><li><strong>仅在master上启动webhook API</strong></li></ol> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># sh startWebHook.sh </span>
</code></pre> 
<blockquote> 
 <p>特别注意：千万不要在slave上启动webhook API，具体原因在本篇的最前面已经有过解释（避免告警重复推送），只有当master不可用了，slave才拉起webhook API脚本进行承担告警推送的任务。</p> 
</blockquote> 
<ol start="10"><li><strong>模拟mysql故障，验证告警是否可以正常触发，验证由webhook是否可以正常接收</strong></li></ol> 
<ul><li>在master上用tailf命令实时监测./logs/webhook.log</li></ul> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@prosvr-master prometheus<span class="token punctuation">]</span><span class="token comment"># tailf ./logs/webhook.log </span>
 * Serving Flask app <span class="token string">"webhook"</span> <span class="token punctuation">(</span>lazy loading<span class="token punctuation">)</span>
 * Environment: production
   WARNING: This is a development server. Do not use it <span class="token keyword">in</span> a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://0.0.0.0:5001/ <span class="token punctuation">(</span>Press CTRL+C to quit<span class="token punctuation">)</span>
</code></pre> 
<p><strong>登录Mysql主机，停掉mysql</strong></p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>root@mysql8db ~<span class="token punctuation">]</span><span class="token comment"># cat stop_mysql.sh </span>
<span class="token comment">#!/bin/bash</span>
/usr/local/mysql8/bin/mysqladmin  -S /usr/local/mysql8/mysql.sock -uroot -pRoot.123456 <span class="token function">shutdown</span>

<span class="token punctuation">[</span>root@mysql8db ~<span class="token punctuation">]</span><span class="token comment"># </span>
<span class="token punctuation">[</span>root@mysql8db ~<span class="token punctuation">]</span><span class="token comment"># sh stop_mysql.sh </span>
mysqladmin: <span class="token punctuation">[</span>Warning<span class="token punctuation">]</span> Using a password on the <span class="token builtin class-name">command</span> line interface can be insecure.
<span class="token punctuation">[</span>root@mysql8db ~<span class="token punctuation">]</span><span class="token comment"># </span>
</code></pre> 
<p><strong>没过多久，webhook api就接收到了告警消息</strong></p> 
<p><img src="https://images2.imgbox.com/d1/a9/XNrvJLqy_o.png" alt="在这里插入图片描述"></p> 
<p><strong>同样，在Alertmanager告警页面中，也能看到告警消息</strong></p> 
<p><img src="https://images2.imgbox.com/8b/ea/9V8ndjmb_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_945"></a>写在最后</h2> 
<blockquote> 
 <p>到目前为止，该DIY的prometheus主备方案的全程搭建过程就已经完结了，期间涉及到很多知识点都还没有去深入的剖析，比如：PromQL，Metric类型，告警的分组、抑制、静默等等知识点。本篇的核心主题是把这个DIY的方案给搞起来，后续笔者会逐一分享更多关于prometheus的技能点，敬请大家的关注。谢谢！感谢您的关注，望多多转发、点赞。谢谢！</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b87b63c2bc902be68a6035c293d2d48e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">eclipse-加载Driver</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f240f29e669a56e84f3c0618ec7c6dc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mybatis的缓存</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>