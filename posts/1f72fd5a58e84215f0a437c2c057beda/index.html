<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vuex中的this.$store.commit和dispatch()使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vuex中的this.$store.commit和dispatch()使用" />
<meta property="og:description" content="一、为什么要用vuex？ 在vue的项目里常常会遇到父子组件间需要进行数据传递的情况，我们可以用熟悉的props 或者 $emit 等方式进行父子组件通信，但是，在项目稍微大一点的情况中，面对众多的不相关的平行组件，并且很多数据需要多个组件循环使用，这个时候在这些组件间传递数据，使用上述方法会比较麻烦，项目代码变得冗长，并且不利于组件的复用，提高了耦合度。
为了解决这一问题，我们需要使用Vue 的状态管理工具 Vuex
Vuex好处：
既使非父子组件间的数据共享也能变得简单明了让程序变得更加可维护（将数据抽离了出来）只要仓库里面的数据发生了变化，在其他组件里面数据被引用的地方也会自动更新 二、使用场景 平行组件之间传递数据，很多数据需要多个组件循环使用；如：用户的登录，注册；
有的时候我们只是需要动态的从一个组件中获取数据（官网称为“组件层级”：是个独立的控件，作用范围只在组件之内）然后想放到一个被官网称作“应用层级”（在项目的任意地方都可以随时获取和动态的修改，在修改之后，vue会为你的整个项目做更新）的地方。
三、环境配置与使用 1.安装vuex npm install vuex --save
2.新建文件夹store，在文件夹内新建index.js文件，用来组装模块并导出 store 的文件
index.js文件：
import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; // 告诉 vue “使用” vuex Vue.use(Vuex) // 创建一个对象来保存应用启动时的初始状态 // 需要维护的状态 const store = new Vuex.Store({ state: { // 放置初始状态 app启动的时候的全局的初始值 login: false,//用户登录状态 } }) // 整合初始状态和变更函数，我们就得到了我们所需的 store // 至此，这个 store 就可以连接到我们的应用中 export default store 然后在main.js/main.ts 中注册store
import Vue from &#39;vue&#39; import App from &#39;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1f72fd5a58e84215f0a437c2c057beda/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-09T17:19:33+08:00" />
<meta property="article:modified_time" content="2022-10-09T17:19:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vuex中的this.$store.commit和dispatch()使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、为什么要用vuex？</h3> 
<p>在vue的项目里常常会遇到<strong>父子组件间</strong>需要进行<strong>数据传递</strong>的情况，我们可以用熟悉的props 或者 $emit 等方式进行父子组件通信，但是，在项目稍微大一点的情况中，面对众多的不相关的平行组件，并且很多数据需要多个组件循环使用，这个时候在这些组件间传递数据，使用上述方法会比较麻烦，项目代码变得冗长，并且不利于组件的复用，提高了耦合度。</p> 
<p>为了解决这一问题，我们需要使用Vue 的状态管理工具<strong> Vuex</strong></p> 
<p></p> 
<p>Vuex好处：</p> 
<ul><li>既使非父子组件间的数据共享也能变得简单明了</li><li>让程序变得更加可维护（将数据抽离了出来）</li><li>只要仓库里面的数据发生了变化，在其他组件里面数据被引用的地方也会自动更新</li></ul> 
<h3>二、使用场景</h3> 
<p>平行组件之间传递数据，很多数据需要多个组件循环使用；如：用户的登录，注册；</p> 
<p>有的时候我们只是需要动态的从一个组件中获取数据（官网称为“组件层级”：是个独立的控件，作用范围只在组件之内）然后想放到一个被官网称作“应用层级”（在项目的任意地方都可以随时获取和动态的修改，在修改之后，vue会为你的整个项目做更新）的地方。</p> 
<h3>三、环境配置与使用</h3> 
<p>1.安装vuex </p> 
<p>npm install vuex --save</p> 
<p>2.新建文件夹store，在文件夹内新建index.js文件，用来组装模块并导出 store 的文件</p> 
<p>index.js文件：</p> 
<pre><code>import Vue from 'vue'
import Vuex from 'vuex'

// 告诉 vue “使用” vuex
Vue.use(Vuex)

// 创建一个对象来保存应用启动时的初始状态

// 需要维护的状态

const store = new Vuex.Store({
    
  state: {
    // 放置初始状态 app启动的时候的全局的初始值
   login: false,//用户登录状态
  }
    
})

// 整合初始状态和变更函数，我们就得到了我们所需的 store
// 至此，这个 store 就可以连接到我们的应用中
export default store
</code></pre> 
<p> 然后在<code>main.js/main.ts</code> 中注册store</p> 
<pre><code>import Vue from 'vue'
import App from './App'
import router from './router'
import store from './../store/index'

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  store,
  template: '&lt;App/&gt;',
  components: { App }
})

</code></pre> 
<p>这一步完成后，我们可以再任意组件中使用store中的数据，<strong>使用方法</strong>也很简单，就是<strong>使用<span style="color:#ff9900;">计算属性</span></strong>返回store中的数据到一个<strong>新</strong>属性上，然后在你模板中就可以使用这个属性值了：</p> 
<p>接下来在<strong>任意</strong>组件中使用</p> 
<pre><code>export default {
  ...
  data(){
	  value : "这又是修改后的value",
	},
  computed: {
    getTxt() {
      return this.$store.state.testTxt.tips;
    }
  },
   methods: {
    modifyTxt: function() {
      this.$store.commit('modifyTips', this.value)
    }
  }
  ...
}

</code></pre> 
<p>然后在index.js文件里可以修改</p> 
<pre><code>	const store = new Vuex.Store({
		  state: {
		   	   // 初始化全局的一个变量
		   	   testTxt: {"tips":"这是一条vuex的数据","id":1}
		  }，
		   mutations: {
			    modifyTips(state,msg) {
			      state.testTxt.tips= msg;
			    }
		  }
})
export default store
</code></pre> 
<p>3. 上面是一个简单的示例，稍微扩展一下：</p> 
<p><strong>初始化store.js</strong></p> 
<p>一般放到src/store/store.js下面</p> 
<pre><code class="hljs">import Vue from "vue";
import Vuex from "vuex";
 
Vue.use(Vuex)
 
const store = new Vuex.Store({
 state: {
    test:'x'
  },
  mutations: {
    changetest(state, xxx) {
      state.test= xxx
    }
  },
  actions:{
     changetest(context, xxx) {
      context.commit('changetest',xxx)
    }
  }，
  getters: {
    test2: state =&gt; state.test
  }
}）
export default store;</code></pre> 
<p><strong>state</strong>：相当于Vue的data</p> 
<p><strong>mutations</strong>：类似于事件，每个 mutation 都有一个字符串的事件类型 (type)和 一个回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数</p> 
<p><strong>actions: </strong>Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作</p> 
<p><strong>getters</strong>：可以认为是 store 的计算属性，就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算，接受 state 作为其第一个参数</p> 
<p>接下来可以用了。</p> 
<p><strong>使用Vuex</strong></p> 
<p>打开main.js，导入</p> 
<pre><code class="hljs">import Vue from "vue";
import App from "./App.vue";
import store from "./store";
 
new Vue({
  store,
  render: h =&gt; h(App)
}).$mount("#app");</code></pre> 
<p> 现在可以在所有App所有子组件里面使用Vuex了</p> 
<p><strong>如何使用 state</strong></p> 
<p>子组件能通过 this.$store 访问到</p> 
<pre><code class="hljs">this.$store.state.test
// x</code></pre> 
<p> <strong>如何使用 mutations</strong></p> 
<p>子组件能通过 this.$store.commit 访问到</p> 
<pre><code class="hljs">this.$store.commit('changetest',xxx)</code></pre> 
<p> 它会去把 changetest 提交到 mutation 执行 ，第二个是载荷(可以理解为参数)，大多数载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读</p> 
<p><strong>如何使用 actions</strong></p> 
<p>子组件能通过 this.$store.dispatch 访问到</p> 
<pre><code class="hljs">this.$store.dispatch('changetest'xxx)</code></pre> 
<p>它会去把 changetest 分发到 actions 在通过 actions 提交到 mutation 执行</p> 
<p><strong>如何使用 getters</strong></p> 
<p>子组件能通过 this.$store.getters 访问到</p> 
<pre><code class="hljs">this.$store.getters.test2
//x</code></pre> 
<h3>四、与dispatch比较</h3> 
<p>1. dispatch: 含有异步操作<br><strong>例如向后台提交数据，this.$store.dispatch('action方法名',值)</strong></p> 
<p>存储：</p> 
<pre><code>this.$store.dispatch('initUserInfo',friend);</code></pre> 
<p>取值：</p> 
<pre><code>this.$store.getters.userInfo;</code></pre> 
<p>2. commit:同步操作<br><strong>this.$store.commit('mutations方法名',值)</strong></p> 
<p>存储：</p> 
<pre><code>this.$store.commit('initUserInfo',friend);</code></pre> 
<p>取值：</p> 
<pre><code>this.$store.state.userInfo;</code></pre> 
<p>  参考：<a href="https://www.cnblogs.com/08291018wan/p/11264069.html" rel="nofollow" title="vuex中的this.$store.commit - 木昜 - 博客园">vuex中的this.$store.commit - 木昜 - 博客园</a><a href="https://blog.csdn.net/wf00334814/article/details/84348654" title="​​​​​小白VUE学习笔记3：Vuex的this.$store.commit和在Vue项目中引用公共方法_Funfction_Zero的博客-CSDN博客">​​​​​小白VUE学习笔记3：Vuex的this.$store.commit和在Vue项目中引用公共方法_Funfction_Zero的博客-CSDN博客</a></p> 
<p> <a href="https://blog.csdn.net/weixin_43953518/article/details/115006963?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-115006963-blog-84348654.pc_relevant_aa_2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-115006963-blog-84348654.pc_relevant_aa_2&amp;utm_relevant_index=5" title="vue store 存储 dispatch 和 commit的区别_前端打工人的博客-CSDN博客">vue store 存储 dispatch 和 commit的区别_前端打工人的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f2f4202872dd310207d03fb55728590d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nginx proxy_pass 转发规则配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a2f883a14cda033e0f06b79bea67c165/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MinIO分布式储存简介以及整合SpringBoot</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>