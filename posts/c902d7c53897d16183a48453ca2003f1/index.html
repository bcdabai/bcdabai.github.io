<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二分查找算法 四种题型六道题目总结，从此二分不迷路！ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二分查找算法 四种题型六道题目总结，从此二分不迷路！" />
<meta property="og:description" content="前言 二分查找在算法中一般有四类题目：
排序或通过排序后的数组，快速求某个值的下标 35.搜索插入位置 求某个值在数组中的左右端点 34.在排序数组中查找元素的第一个和最后一个位置 (中等) 通过条件判断进行二分查找 278.第一个错误的版本 875.爱吃香蕉的珂珂(中等) 局部有序的二分查找 33.搜索旋转排序数组(中等) 81.搜索旋转排序数组II(中等) 今天将这四类列举六道题，让大家一次看个够，从此二分不迷路！
35.搜索插入位置 https://leetcode-cn.com/problems/search-insert-position/solution/35sou-suo-cha-ru-wei-zhi-pythonji-chu-er-c0xq/
难度：简单
题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，
返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
示例 示例 1: 输入: [1,3,5,6], 5 输出: 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 分析 手写二分解题 class Solution: def searchInsert(self, nums, target): left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left &#43; right) // 2 if nums[mid] == target: return mid if nums[mid] &gt; target: right = mid - 1 else: left = mid &#43; 1 return left api解题 class Solution: def searchInsert(self, nums, target): return bisect." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c902d7c53897d16183a48453ca2003f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-14T01:03:33+08:00" />
<meta property="article:modified_time" content="2021-07-14T01:03:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二分查找算法 四种题型六道题目总结，从此二分不迷路！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <article class="_2rhmJa" style="font-size: 16px;"> 
 <h2>前言</h2> 
 <p>二分查找在算法中一般有四类题目：</p> 
 <ol><li>排序或通过排序后的数组，快速求某个值的下标</li></ol> 
 <ul><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsearch-insert-position%2Fsolution%2F35sou-suo-cha-ru-wei-zhi-pythonji-chu-er-c0xq%2F" rel="nofollow noopener noreferrer" target="_blank">35.搜索插入位置</a></li></ul> 
 <ol start="2"><li>求某个值在数组中的左右端点</li></ol> 
 <ul><li> <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Ffind-first-and-last-position-of-element-in-sorted-array%2Fsolution%2F34zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-zoga7%2F" rel="nofollow noopener noreferrer" target="_blank">34.在排序数组中查找元素的第一个和最后一个位置</a> (中等)</li></ul> 
 <ol start="3"><li>通过条件判断进行二分查找</li></ol> 
 <ul><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Ffirst-bad-version%2Fsolution%2F278di-yi-ge-cuo-wu-de-ban-ben-by-qingfen-gp99%2F" rel="nofollow noopener noreferrer" target="_blank">278.第一个错误的版本</a></li><li> <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fkoko-eating-bananas%2Fsolution%2F875-ai-chi-xiang-jiao-de-ke-ke-er-fen-ch-7you%2F" rel="nofollow noopener noreferrer" target="_blank">875.爱吃香蕉的珂珂</a>(中等)</li></ul> 
 <ol start="4"><li>局部有序的二分查找</li></ol> 
 <ul><li> <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsearch-in-rotated-sorted-array%2Fsolution%2F33sou-suo-xuan-zhuan-pai-xu-shu-zu-pytho-2oia%2F" rel="nofollow noopener noreferrer" target="_blank">33.搜索旋转排序数组</a>(中等)</li><li> <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsearch-in-rotated-sorted-array-ii%2Fsolution%2F81sou-suo-xuan-zhuan-pai-xu-shu-zu-ii-33-7lz5%2F" rel="nofollow noopener noreferrer" target="_blank">81.搜索旋转排序数组II</a>(中等)</li></ul> 
 <p>今天将这四类列举六道题，让大家一次看个够，从此二分不迷路！</p> 
 <h2><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsearch-insert-position%2Fsolution%2F35sou-suo-cha-ru-wei-zhi-pythonji-chu-er-c0xq%2F" rel="nofollow noopener noreferrer" target="_blank">35.搜索插入位置</a></h2> 
 <blockquote> 
  <p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsearch-insert-position%2Fsolution%2F35sou-suo-cha-ru-wei-zhi-pythonji-chu-er-c0xq%2F" rel="nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/search-insert-position/solution/35sou-suo-cha-ru-wei-zhi-pythonji-chu-er-c0xq/</a></p> 
  <p>难度：简单</p> 
 </blockquote> 
 <h3>题目</h3> 
 <p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，<br> 返回它将会被按顺序插入的位置。</p> 
 <p>你可以假设数组中无重复元素。</p> 
 <h3>示例</h3> 
 <pre class="has"><code>示例 1:
输入: [1,3,5,6], 5
输出: 
示例 2:
输入: [1,3,5,6], 2
输出: 1

示例 3:
输入: [1,3,5,6], 7
输出: 4

示例 4:
输入: [1,3,5,6], 0
输出: 0</code></pre> 
 <h3>分析</h3> 
 <h3>手写二分解题</h3> 
 <pre class="has"><code class="python">class Solution:
    def searchInsert(self, nums, target):
        left, right = 0, len(nums) - 1
        while left &lt;= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] &gt; target:
                right = mid - 1
            else:
                left = mid + 1
        return left</code></pre> 
 <h3>api解题</h3> 
 <pre class="has"><code class="python">class Solution:
    def searchInsert(self, nums, target):
        return bisect.bisect_left(nums, target)</code></pre> 
 <h2><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Ffind-first-and-last-position-of-element-in-sorted-array%2Fsolution%2F34zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-zoga7%2F" rel="nofollow noopener noreferrer" target="_blank">34.在排序数组中查找元素的第一个和最后一个位置</a></h2> 
 <blockquote> 
  <p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Ffind-first-and-last-position-of-element-in-sorted-array%2Fsolution%2F34zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-zoga7%2F" rel="nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/34zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-zoga7/</a></p> 
  <p>难度：中等</p> 
 </blockquote> 
 <h3>题目</h3> 
 <p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p> 
 <p>如果数组中不存在目标值 target，返回 [-1, -1]。</p> 
 <p>进阶：</p> 
 <ul><li>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</li></ul> 
 <h3>示例</h3> 
 <pre class="has"><code>示例 1：
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

示例 2：
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]

示例 3：
输入：nums = [], target = 0
输出：[-1,-1]</code></pre> 
 <h3>分析</h3> 
 <p>二分查找左右端点有一个小tips</p> 
 <ol><li>left = bisect_left(target)，如果left== length or nums[left] != target,<br> 表示没有找到该数字，返回[-1, -1]</li><li>在基于left的前提下，我们bisect_left(target + 1),<br> 即可获取target下一个数字的插入点，然后right -1就是结果了。</li></ol> 
 <h3>解题</h3> 
 <pre class="has"><code class="python">import bisect
class Solution:
    def searchRange(self, nums, target):
        left = bisect.bisect_left(nums,target)
        if left == len(nums) or nums[left] != target:
            return [-1,-1]
        right = bisect.bisect_left(nums,target+1)
        return [left,right - 1]</code></pre> 
 <h2><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Ffirst-bad-version%2Fsolution%2F278di-yi-ge-cuo-wu-de-ban-ben-by-qingfen-gp99%2F" rel="nofollow noopener noreferrer" target="_blank">278.第一个错误的版本</a></h2> 
 <blockquote> 
  <p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Ffirst-bad-version%2Fsolution%2F278di-yi-ge-cuo-wu-de-ban-ben-by-qingfen-gp99%2F" rel="nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/first-bad-version/solution/278di-yi-ge-cuo-wu-de-ban-ben-by-qingfen-gp99/</a></p> 
  <p>难度：简单</p> 
 </blockquote> 
 <h3>题目：</h3> 
 <p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p> 
 <p>假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。</p> 
 <p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p> 
 <h3>示例：</h3> 
 <pre class="has"><code>给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -&gt; false
调用 isBadVersion(5) -&gt; true
调用 isBadVersion(4) -&gt; true

所以，4 是第一个错误的版本。</code></pre> 
 <h3>分析</h3> 
 <p>这是一道标准的，读题3分钟解题30秒题目。<br> 其实只需要关注查找、尽可能少的次数这些关键字就可以判断出是一道二分查找的题目了。<br> 题目中虚拟构建了 <strong>isBadVersion</strong> 方法用于判断结果是True or False。</p> 
 <p>所以，今天只能说是力扣庆祝端午快乐的一道放水送分题...</p> 
 <h3>解题：</h3> 
 <pre class="has"><code class="python">class Solution:
    def firstBadVersion(self, n):
        left = 1
        right = n
        while left &lt; right:
            mid = (left + right) // 2
            if isBadVersion(mid):
                right = mid
            else:
                left = mid + 1
        return left</code></pre> 
 <h2><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fkoko-eating-bananas%2Fsolution%2F875-ai-chi-xiang-jiao-de-ke-ke-er-fen-ch-7you%2F" rel="nofollow noopener noreferrer" target="_blank">875.爱吃香蕉的珂珂</a></h2> 
 <blockquote> 
  <p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fkoko-eating-bananas%2Fsolution%2F875-ai-chi-xiang-jiao-de-ke-ke-er-fen-ch-7you%2F" rel="nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/koko-eating-bananas/solution/875-ai-chi-xiang-jiao-de-ke-ke-er-fen-ch-7you/</a></p> 
  <p>难度：中等</p> 
 </blockquote> 
 <h3>题目：</h3> 
 <p>珂珂喜欢吃香蕉。这里有N堆香蕉，第 i 堆中有piles[i]根香蕉。警卫已经离开了，将在H小时后回来。</p> 
 <p>珂珂可以决定她吃香蕉的速度K(单位：根/小时)。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。</p> 
 <p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p> 
 <p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K(K 为整数)。</p> 
 <h3>示例：</h3> 
 <p>示例 1：</p> 
 <p>输入: piles = [3,6,7,11], H = 8</p> 
 <p>输出: 4</p> 
 <p>示例2：</p> 
 <p>输入: piles = [30,11,23,4,20], H = 5</p> 
 <p>输出: 30</p> 
 <p>示例3：</p> 
 <p>输入: piles = [30,11,23,4,20], H = 6</p> 
 <p>输出: 23</p> 
 <h3>分析：</h3> 
 <p>由于1 &lt;= piles.length &lt;= 10^4, piles.length &lt;= H &lt;= 10^9所以肯定是二分查找没跑了。</p> 
 <p>下来看到最小时间，肯定是二分查找左边界。至于如何选择最大值，题目中描述：</p> 
 <p>“如果香蕉小于K根，他讲吃掉这堆的所有，并一小时内不会再吃更多香蕉”</p> 
 <p>所以我们最大值选择这个列表的max值即可。</p> 
 <h3>解题：</h3> 
 <pre class="has"><code class="python">class Solution:
    def minEatingSpeed(self, piles, h):
        def cost(k):
            t = 0
            for i in piles:
                t += (i + k - 1) // k
            return t

        left, right = 1, max(piles)
        while left &lt; right:
            mid = (left + right) // 2
            ret = cost(mid)
            if ret &lt;= h:
                right = mid
            else:
                left = mid + 1
        return left</code></pre> 
 <h2><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsearch-in-rotated-sorted-array%2Fsolution%2F33sou-suo-xuan-zhuan-pai-xu-shu-zu-pytho-2oia%2F" rel="nofollow noopener noreferrer" target="_blank">33.搜索旋转排序数组</a></h2> 
 <blockquote> 
  <p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsearch-in-rotated-sorted-array%2Fsolution%2F33sou-suo-xuan-zhuan-pai-xu-shu-zu-pytho-2oia%2F" rel="nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/33sou-suo-xuan-zhuan-pai-xu-shu-zu-pytho-2oia/</a></p> 
  <p>难度：中等</p> 
 </blockquote> 
 <h3>题目</h3> 
 <p>整数数组 nums 按升序排列，数组中的值 互不相同 。<br> 在传递给函数之前，nums 在预先未知的某个下标 k(0 &lt;= k &lt; nums.length)上进行了 旋转，<br> 使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]<br> (下标 从 0 开始 计数)。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br> 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，<br> 则返回它的下标，否则返回 -1 。</p> 
 <p>提示：</p> 
 <ul><li>1 &lt;= nums.length &lt;= 5000</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>nums 中的每个值都 独一无二</li><li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li><li>-10^4 &lt;= target &lt;= 10^4</li></ul> 
 <p>进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？</p> 
 <h3>示例</h3> 
 <pre class="has"><code>示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1</code></pre> 
 <h3>分析</h3> 
 <p>第一次看这个题的时候，这能算中等？循环判断在不在不就完了。暴力通过，咦，效率还挺高？<br> 沾沾自喜中看到了进阶要求，使用时间复杂度为O(log n)的方法完成...<br> O(log n)无疑二分才能实现，但是数组时无序的啊，我们先排序再二分？别逗，排序的时间复杂度就是O(n).<br> 那么如何对局部有序的数组进行二分搜索呢？让我们以示例1为例：<br> nums = [4,5,6,7,0,1,2], target = 0<br> 设置左右端点，left = 0 right = len(nums) -1。<br> 有的小伙伴们要问了，你求length不是要一个一个加起来，复杂度不是O(n)么，错！<br> 一定要记得Python的len()方法在获取数组长度时的时间复杂度是O(1).至于为啥篇幅原因百度吧...<br> mid = (0 + 6) // 2 == 3,此时nums[mid] == 7，下面开始判断。</p> 
 <ol><li>nums[mid]是否等于target，等于返回mid</li><li>关键来了，nums[mid]是否大于nums[left] 
   <ul><li>如果nums[left] &lt;= nums[mid] 
     <ul><li>nums[left] &lt;= target &lt; nums[mid],此时我们缩减right = mid - 1</li><li>否则，缩减left = mid + 1</li></ul> </li><li>如果nums[left] &gt; nums[mid] 
     <ul><li>nums[mid] &lt; target &lt;= nums[right],此时我们缩减left += 1</li><li>否则，缩减right = mid - 1<br> 我们通过将局部有序的数据进行分场景考虑的情况，完成了二分的实现，这就是局部有序数组的二分操作方式。</li></ul> </li></ul> </li></ol> 
 <h3>暴力解法</h3> 
 <pre class="has"><code class="python">class Solution:
    def search(self, nums, target):
        for i, num in enumerate(nums):
            if target == num:
                return i
        return -1</code></pre> 
 <h3>解题</h3> 
 <pre class="has"><code class="python">class Solution:
    def search(self, nums, target):
        left, right = 0, len(nums) - 1
        while left &lt;= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[left] &lt;= nums[mid]:
                if nums[left] &lt;= target &lt; nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] &lt; target &lt;= nums[right]:
                    left += 1
                else:
                    right -= 1
        return -1</code></pre> 
 <h2><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsearch-in-rotated-sorted-array-ii%2Fsolution%2F81sou-suo-xuan-zhuan-pai-xu-shu-zu-ii-33-7lz5%2F" rel="nofollow noopener noreferrer" target="_blank">81.搜索旋转排序数组II</a></h2> 
 <blockquote> 
  <p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsearch-in-rotated-sorted-array-ii%2Fsolution%2F81sou-suo-xuan-zhuan-pai-xu-shu-zu-ii-33-7lz5%2F" rel="nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/81sou-suo-xuan-zhuan-pai-xu-shu-zu-ii-33-7lz5/</a></p> 
  <p>难度：中等</p> 
 </blockquote> 
 <h3>题目</h3> 
 <p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</p> 
 <p>在传递给函数之前，nums 在预先未知的某个下标 k(0 &lt;= k &lt; nums.length)上进行了 旋转 ，<br> 使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]<br> (下标 从 0 开始 计数)。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</p> 
 <p>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。<br> 如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p> 
 <p>提示：</p> 
 <ul><li>1 &lt;= nums.length &lt;= 5000</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li><li>-10^4 &lt;= target &lt;= 10^4</li></ul> 
 <p>进阶：</p> 
 <ul><li>这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。</li><li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li></ul> 
 <h3>示例</h3> 
 <pre class="has"><code>示例 1：

输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
示例 2：

输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false</code></pre> 
 <h3>分析</h3> 
 <p>先回答进阶问题，nums 可能包含重复元素，这会影响到程序的时间复杂度吗？<br> 两种答案：</p> 
 <ol><li>不会，我就是暴力return target in nums 管你有没有重复值呢，哈哈。</li><li>会，使用二分查找局部有序时，当nums[mid] == nums[left]时，<br> 我无法知道他到底在翻转前的数组还是反转后的数组。只能left左移一位继续判断。</li></ol> 
 <p>好了，做这道题之前，强烈建议先看看它的基础版题目，然后再来做这道题：</p> 
 <ul><li><strong><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fsearch-in-rotated-sorted-array%2Fsolution%2F33sou-suo-xuan-zhuan-pai-xu-shu-zu-pytho-2oia%2F" rel="nofollow noopener noreferrer" target="_blank">33.搜索旋转排序数组</a></strong></li></ul> 
 <p>其实这道题，我们只需要根据33题的搜索改变一点判断就行，即当nums[left] == nums[mid] == nums[right],<br> 此时我们不知道该怎么移动，那就left += 1 right += 1,再去判断即可。</p> 
 <h3>解题</h3> 
 <pre class="has"><code class="python">class Solution:
    def search(self, nums, target):
        left, right = 0, len(nums) - 1
        while left &lt;= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return True
            if nums[left] == nums[mid] == nums[right]:
                left += 1
                right -= 1
                continue
            if nums[mid] &lt;= nums[right]:
                if nums[mid] &lt; target &lt;= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
            else:
                if nums[left] &lt;= target &lt; nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
        return False</code></pre> 
 <p>欢迎关注我的公众号: <strong>清风Python</strong>，带你每日学习Python算法刷题的同时，了解更多python小知识。</p> 
 <p>我的个人博客：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fqingfengpython.cn" rel="nofollow noopener noreferrer" target="_blank">https://qingfengpython.cn</a></p> 
 <p>力扣解题合集：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FBreezePython%2FAlgorithmMarkdown" rel="nofollow noopener noreferrer" target="_blank">https://github.com/BreezePython/AlgorithmMarkdown</a></p> 
</article>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/392d4da9d6c745bf83e91b61eddd51c4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机数值模拟仿真技术的优点,数值模拟的优缺点优点.ppt</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/da5366cff6615a7ac8a01aea0c14c3c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">事业单位 软考 计算机职称吗,事业单位认软考职称考试吗</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>