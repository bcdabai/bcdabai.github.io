<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>00_Ubuntu系统入门 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="00_Ubuntu系统入门" />
<meta property="og:description" content="目录
前言
一、Ubuntu系统安装
1.1 VMware15安装虚拟机不兼容，无法打开
1.2 Ubuntu联网问题
二、Ubuntu系统入门
2.1 Ubuntu系统初体验
2.2 Ubuntu终端操作
2.3 shell操作
2.3.1 shell简介
2.3.3 常用shell命令
2.4 APT下载工具
2.5Ubuntu 下文本编辑
2.5.1 安装 VIM 编辑器:
2.5.2 vim编辑器的使用
2.6 Linux 文件系统
2.6.1 Linux 文件系统简介以及类型
2.6.2 Linux 文件系统结构
2.6.3 文件操作命令
2、文件夹创建命令—mkdir
2.6.4 命令行进行文件的压缩和解压缩
2.6.5 文件查询和搜索（没怎么用过）
2.6.6文件类型
2.7 Linux 用户权限管理
2.7.1Ubuntu 用户系统
2.7.2权限管理
2.7.3 权限管理命令
2.8 Linux磁盘管理
2.8.1 Linux磁盘管理基本概念
2.8.2 磁盘管理命令
三、Linux C 编程入门
3.1 Hello World！
3.1.1编写代码
3.1.2 编译代码
3.2 GCC编译器" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4a4640c271abfde990a826ef19a02016/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-23T18:51:16+08:00" />
<meta property="article:modified_time" content="2022-10-23T18:51:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">00_Ubuntu系统入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80%E3%80%81Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85" rel="nofollow">一、Ubuntu系统安装</a></p> 
<p id="1.1%20VMware15%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8D%E5%85%BC%E5%AE%B9%EF%BC%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80-toc" style="margin-left:40px;"><a href="#1.1%20VMware15%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8D%E5%85%BC%E5%AE%B9%EF%BC%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80" rel="nofollow">1.1 VMware15安装虚拟机不兼容，无法打开</a></p> 
<p id="1.2%C2%A0Ubuntu%E8%81%94%E7%BD%91%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#1.2%C2%A0Ubuntu%E8%81%94%E7%BD%91%E9%97%AE%E9%A2%98" rel="nofollow">1.2 Ubuntu联网问题</a></p> 
<p id="%E4%BA%8C%E3%80%81Ubuntu%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Ubuntu%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8" rel="nofollow">二、Ubuntu系统入门</a></p> 
<p id="2.1%20Ubuntu%E7%B3%BB%E7%BB%9F%E5%88%9D%E4%BD%93%E9%AA%8C-toc" style="margin-left:40px;"><a href="#2.1%20Ubuntu%E7%B3%BB%E7%BB%9F%E5%88%9D%E4%BD%93%E9%AA%8C" rel="nofollow">2.1 Ubuntu系统初体验</a></p> 
<p id="%C2%A02.2%20Ubuntu%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%C2%A02.2%20Ubuntu%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C" rel="nofollow"> 2.2 Ubuntu终端操作</a></p> 
<p id="2.3%20shell%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#2.3%20shell%E6%93%8D%E4%BD%9C" rel="nofollow">2.3 shell操作</a></p> 
<p id="2.3.1%20shell%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px;"><a href="#2.3.1%20shell%E7%AE%80%E4%BB%8B" rel="nofollow">2.3.1 shell简介</a></p> 
<p id="2.3.3%20%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#2.3.3%20%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4" rel="nofollow">2.3.3 常用shell命令</a></p> 
<p id="2.4%C2%A0%20APT%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7-toc" style="margin-left:40px;"><a href="#2.4%C2%A0%20APT%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7" rel="nofollow">2.4  APT下载工具</a></p> 
<p id="2.5Ubuntu%20%E4%B8%8B%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91-toc" style="margin-left:40px;"><a href="#2.5Ubuntu%20%E4%B8%8B%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91" rel="nofollow">2.5Ubuntu 下文本编辑</a></p> 
<p id="2.5.1%20%E5%AE%89%E8%A3%85%20VIM%20%E7%BC%96%E8%BE%91%E5%99%A8%3A-toc" style="margin-left:80px;"><a href="#2.5.1%20%E5%AE%89%E8%A3%85%20VIM%20%E7%BC%96%E8%BE%91%E5%99%A8%3A" rel="nofollow">2.5.1 安装 VIM 编辑器:</a></p> 
<p id="2.5.2%20vim%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#2.5.2%20vim%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">2.5.2 vim编辑器的使用</a></p> 
<p id="2.6%20Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-toc" style="margin-left:40px;"><a href="#2.6%20Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" rel="nofollow">2.6 Linux 文件系统</a></p> 
<p id="2.6.1%20Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#2.6.1%20Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B" rel="nofollow">2.6.1 Linux 文件系统简介以及类型</a></p> 
<p id="2.6.2%20Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#2.6.2%20Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84" rel="nofollow">2.6.2 Linux 文件系统结构</a></p> 
<p id="2.6.3%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#2.6.3%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4" rel="nofollow">2.6.3 文件操作命令</a></p> 
<p id="2%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4%E2%80%94mkdir-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4%E2%80%94mkdir" rel="nofollow">2、文件夹创建命令—mkdir</a></p> 
<p id="2.6.4%C2%A0%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9-toc" style="margin-left:80px;"><a href="#2.6.4%C2%A0%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9" rel="nofollow">2.6.4 命令行进行文件的压缩和解压缩</a></p> 
<p id="2.6.5%C2%A0%E6%96%87%E4%BB%B6%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%90%9C%E7%B4%A2%EF%BC%88%E6%B2%A1%E6%80%8E%E4%B9%88%E7%94%A8%E8%BF%87%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.6.5%C2%A0%E6%96%87%E4%BB%B6%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%90%9C%E7%B4%A2%EF%BC%88%E6%B2%A1%E6%80%8E%E4%B9%88%E7%94%A8%E8%BF%87%EF%BC%89" rel="nofollow">2.6.5 文件查询和搜索（没怎么用过）</a></p> 
<p id="2.6.6%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#2.6.6%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B" rel="nofollow">2.6.6文件类型</a></p> 
<p id="2.7%C2%A0Linux%20%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-toc" style="margin-left:40px;"><a href="#2.7%C2%A0Linux%20%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86" rel="nofollow">2.7 Linux 用户权限管理</a></p> 
<p id="2.7.1Ubuntu%20%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F-toc" style="margin-left:80px;"><a href="#2.7.1Ubuntu%20%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F" rel="nofollow">2.7.1Ubuntu 用户系统</a></p> 
<p id="2.7.2%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#2.7.2%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86" rel="nofollow">2.7.2权限管理</a></p> 
<p id="2.7.3%20%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#2.7.3%20%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4" rel="nofollow">2.7.3 权限管理命令</a></p> 
<p id="2.8%20Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86-toc" style="margin-left:40px;"><a href="#2.8%20Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86" rel="nofollow">2.8 Linux磁盘管理</a></p> 
<p id="2.8.1%20Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#2.8.1%20Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">2.8.1 Linux磁盘管理基本概念</a></p> 
<p id="2.8.2%20%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#2.8.2%20%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4" rel="nofollow">2.8.2 磁盘管理命令</a></p> 
<p id="%E4%B8%89%E3%80%81Linux%20C%20%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81Linux%20C%20%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8" rel="nofollow">三、Linux C 编程入门</a></p> 
<p id="3.1%C2%A0Hello%20World%EF%BC%81-toc" style="margin-left:40px;"><a href="#3.1%C2%A0Hello%20World%EF%BC%81" rel="nofollow">3.1 Hello World！</a></p> 
<p id="3.1.1%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#3.1.1%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81" rel="nofollow">3.1.1编写代码</a></p> 
<p id="3.1.2%C2%A0%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#3.1.2%C2%A0%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81" rel="nofollow">3.1.2 编译代码</a></p> 
<p id="3.2%20GCC%E7%BC%96%E8%AF%91%E5%99%A8-toc" style="margin-left:40px;"><a href="#3.2%20GCC%E7%BC%96%E8%AF%91%E5%99%A8" rel="nofollow">3.2 GCC编译器</a></p> 
<p id="3.2.1%20gcc%20%E5%91%BD%E4%BB%A4-toc" style="margin-left:80px;"><a href="#3.2.1%20gcc%20%E5%91%BD%E4%BB%A4" rel="nofollow">3.2.1 gcc 命令</a></p> 
<p id="3.2.2%20%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E8%AD%A6%E5%91%8A-toc" style="margin-left:80px;"><a href="#3.2.2%20%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E8%AD%A6%E5%91%8A" rel="nofollow">3.2.2 编译错误警告</a></p> 
<p id="3.2.3%20%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B-toc" style="margin-left:80px;"><a href="#3.2.3%20%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B" rel="nofollow">3.2.3 编译流程</a></p> 
<p id="3.3%C2%A0Makefile%20%E5%9F%BA%E7%A1%80-toc" style="margin-left:40px;"><a href="#3.3%C2%A0Makefile%20%E5%9F%BA%E7%A1%80" rel="nofollow">3.3 Makefile 基础</a></p> 
<p id="3.3.1%20%E4%BD%95%E4%B8%BAMakefile-toc" style="margin-left:80px;"><a href="#3.3.1%20%E4%BD%95%E4%B8%BAMakefile" rel="nofollow">3.3.1 何为Makefile</a></p> 
<p id="3.3.2%C2%A0Makefile%20%E7%9A%84%E5%BC%95%E5%85%A5-toc" style="margin-left:80px;"><a href="#3.3.2%C2%A0Makefile%20%E7%9A%84%E5%BC%95%E5%85%A5" rel="nofollow">3.3.2 Makefile 的引入</a></p> 
<p id="3.4%20Makefile%20%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#3.4%20Makefile%20%E8%AF%AD%E6%B3%95" rel="nofollow">3.4 Makefile 语法</a></p> 
<p id="3.4.1%C2%A0Makefile%20%E8%A7%84%E5%88%99%E6%A0%BC%E5%BC%8F-toc" style="margin-left:80px;"><a href="#3.4.1%C2%A0Makefile%20%E8%A7%84%E5%88%99%E6%A0%BC%E5%BC%8F" rel="nofollow">3.4.1 Makefile 规则格式</a></p> 
<p id="3.4.2%C2%A0Makefile%20%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#3.4.2%C2%A0Makefile%20%E5%8F%98%E9%87%8F" rel="nofollow">3.4.2 Makefile 变量</a></p> 
<p id="3.4.3%C2%A0Makefile%20%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99-toc" style="margin-left:80px;"><a href="#3.4.3%C2%A0Makefile%20%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99" rel="nofollow">3.4.3 Makefile 模式规则</a></p> 
<p id="3.4.4%20Makefile%20%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#3.4.4%20Makefile%20%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%98%E9%87%8F" rel="nofollow">3.4.4 Makefile 自动化变量</a></p> 
<p id="3.4.5%C2%A0Makefile%20%E4%BC%AA%E7%9B%AE%E6%A0%87-toc" style="margin-left:80px;"><a href="#3.4.5%C2%A0Makefile%20%E4%BC%AA%E7%9B%AE%E6%A0%87" rel="nofollow">3.4.5 Makefile 伪目标</a></p> 
<p id="3.4.6%C2%A0Makefile%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD-toc" style="margin-left:80px;"><a href="#3.4.6%C2%A0Makefile%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD" rel="nofollow">3.4.6 Makefile 条件判断</a></p> 
<p id="3.4.7%C2%A0Makefile%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#3.4.7%C2%A0Makefile%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8" rel="nofollow">3.4.7 Makefile 函数使用</a></p> 
<p id="%E6%9C%AC%E7%AF%87%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%9C%AC%E7%AF%87%E6%80%BB%E7%BB%93" rel="nofollow">本篇总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80"><strong>前言</strong></h2> 
<blockquote> 
 <p><strong>        前一段时间学习Linux驱动，实在是迷糊了。</strong></p> 
 <p><strong>        决定利用闲余时间，整理笔记，争取消除困惑。</strong></p> 
 <p><strong>        打算从基础（Ubuntu入门）开始，把笔记整理一番。</strong></p> 
 <p><strong>        这篇主要是为了驱动学习做的前期工作。</strong></p> 
 <p><strong>        全文大量参考正点原子的教程，在此对正点原子团队表示感谢。</strong></p> 
</blockquote> 
<h2 id="%E4%B8%80%E3%80%81Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85"><strong>一、Ubuntu系统安装</strong></h2> 
<p><strong>        </strong>简单来说，分两步：1.安装VMware。2.安装Ubuntu。</p> 
<p>        过程很简单，我是参考正点原子教程安装的，当然也遇到了一些问题，总结如下：</p> 
<h3 id="1.1%20VMware15%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8D%E5%85%BC%E5%AE%B9%EF%BC%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80"><strong>1.1 VMware15安装虚拟机不兼容，无法打开</strong></h3> 
<p><strong> </strong>        先把VMware15卸载，然后安装VMware16。</p> 
<p>VMware15卸载参考：<a class="link-info" href="https://blog.csdn.net/qq_45011675/article/details/105476677" title="https://blog.csdn.net/qq_45011675/article/details/105476677">https://blog.csdn.net/qq_45011675/article/details/105476677</a></p> 
<p>VMware16安装教程：<a class="link-info" href="https://blog.csdn.net/m0_50519965/article/details/116175873" title="https://blog.csdn.net/m0_50519965/article/details/116175873">https://blog.csdn.net/m0_50519965/article/details/116175873</a></p> 
<h3 id="1.2%C2%A0Ubuntu%E8%81%94%E7%BD%91%E9%97%AE%E9%A2%98">1.2 Ubuntu联网问题</h3> 
<p><strong>        </strong>安装好的Ubuntu无法联网，下面是找的一种联网方式，可参考。</p> 
<p>链接：<a class="link-info" href="https://blog.csdn.net/wavehaha/article/details/109370826" title="让Ubuntu联网">让Ubuntu联网</a></p> 
<h2 id="%E4%BA%8C%E3%80%81Ubuntu%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8"><strong>二、Ubuntu系统入门</strong></h2> 
<h3 id="2.1%20Ubuntu%E7%B3%BB%E7%BB%9F%E5%88%9D%E4%BD%93%E9%AA%8C"><strong>2.1 Ubuntu系统初体验</strong></h3> 
<p><strong>        </strong>熟悉一下这个系统的图形界面，直接上图。</p> 
<p style="text-align:center;"><img alt="e4c3db349bd140299f67bf4f92fa5df6.png" src="https://images2.imgbox.com/46/0a/CxQ6bQXH_o.png"></p> 
<p><img alt="e0be0be473b443529eac2c16226dba44.png" src="https://images2.imgbox.com/35/8b/1wZsXH7G_o.png"></p> 
<p style="text-align:center;"><img alt="e9aa1a3c38d6459e8be3149efff42b6d.png" src="https://images2.imgbox.com/fc/03/xnPQUhxt_o.png"></p> 
<p style="text-align:center;"><img alt="1e50e24ef41d49fdbcc5d543078a6f4c.png" src="https://images2.imgbox.com/91/2a/bbrQGfTq_o.png"></p> 
<p style="text-align:center;"><img alt="0cd354ca84a84cc196fc2856ed02139a.png" src="https://images2.imgbox.com/d4/ee/eI6PySHt_o.png"></p> 
<p style="text-align:center;"> <img alt="f5981d87ebbb4d8fad1f30e2297febb9.png" src="https://images2.imgbox.com/bf/a3/aYGRxbk9_o.png"></p> 
<p></p> 
<h3 id="%C2%A02.2%20Ubuntu%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C"> 2.2 Ubuntu终端操作</h3> 
<p>        鼠标右击，选择打开终端。</p> 
<p style="text-align:center;"><img alt="191e16682c7243d9ba51b7e2bd2088f7.png" src="https://images2.imgbox.com/dd/a7/LW4YD8cz_o.png"></p> 
<p style="text-align:center;"><img alt="230056fb69f746afb88a4dd39bdf963f.png" src="https://images2.imgbox.com/69/0d/t8BYScUY_o.png"></p> 
<p>         命令“ls”是打印出当前所在目录中所有文件和文件夹。</p> 
<h3 id="2.3%20shell%E6%93%8D%E4%BD%9C">2.3 shell操作</h3> 
<h4 id="2.3.1%20shell%E7%AE%80%E4%BB%8B">2.3.1 shell简介</h4> 
<p>        严格意义上来讲，Shell 是一个应用程序，它负责接收用户输入的命令，然后根据命令做出相应的动作，Shell 负责将应用层或者用户输入的命令传递给系统内核，由操作系统内核来完成相应的工作，然后将结果反馈给应用层或者用户。</p> 
<p>2.3.2 <strong>Shell </strong><strong>基本操作 </strong></p> 
<div>
  Shell 命令的格式如下： 
</div> 
<blockquote> 
 <div>
   command -options [argument] 
 </div> 
</blockquote> 
<div> 
 <strong>command:  </strong>Shell 命令名称。 
</div> 
<div> 
 <strong>options</strong>：    选项，同一种命令可能有不同的选项，不同的选项其实现的功能不同。 
</div> 
<div> 
 <strong>argument</strong>：Shell 命令是可以带参数的，也可以不带参数运行。 
</div> 
<div>
  例子： 
</div> 
<blockquote> 
 <div> 
  <div>
    ls 
  </div> 
  <div>
    ls -l 
  </div> 
  <div>
    ls /usr 
  </div> 
 </div> 
</blockquote> 
<p> 运行结果如下：</p> 
<p><img alt="3c2aa245eaef4cf2ba7d4c14671a567e.png" src="https://images2.imgbox.com/cd/ca/RHHhzXno_o.png"></p> 
<p> 注：Shell 命令支持自动补全功能，使用自动补全功能以后我们只需要输入命令的前面一部分字母，然后按下 TAB 键，如果只有一个命令匹配的话就会自动补全这个命令剩下的字母。如果有多个命令匹配的话系统就会发出报警声音，此时在按下一次 TAB 键就会列出所有匹配的命令。</p> 
<h4 id="2.3.3%20%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4">2.3.3 常用shell命令</h4> 
<div> 
 <strong>1、目录信息查看命令 ls </strong> 
</div> 
<div>
          文件浏览命令 ls，格式如下： 
</div> 
<blockquote> 
 <p> ls [选项] [路径]</p> 
</blockquote> 
<div>
          ls 命令主要用于显示指定目录下的内容，列出指定目录下包含的所有的文件以及子目录，它的主要参数有：   
</div> 
<div> 
 <strong>-a  </strong>显示所有的文件以及子目录，包括以“.”开头的隐藏文件。 
</div> 
<div> 
 <strong>-l   </strong>显示文件的详细信息，比如文件的形态、权限、所有者、大小等信息。 
</div> 
<div> 
 <strong>-t   </strong>将文件按照创建时间排序列出。 
</div> 
<div> 
 <strong>-A  </strong>和-a 一样，但是不列出“.”(当前目录)和“..”(父目录)。 
</div> 
<div> 
 <strong>-R  </strong>递归列出所有文件，包括子目录中的文件。 
</div> 
<div></div> 
<div> 
 <div>
           Shell 命令里面的参数是可以组合在一起用的。 
 </div> 
</div> 
<div> 
 <strong>2、目录切换命令 cd </strong> 
</div> 
<div> 
 <strong>3、当前路径显示命令 pwd </strong> 
</div> 
<div> 
 <div> 
  <strong>4、系统信息查看命令 uname </strong> 
 </div> 
 <div> 
  <div> 
   <strong>5、清屏命令 clear </strong> 
  </div> 
  <div> 
   <div> 
    <strong>6、切换用户执行身份命令 sudo </strong> 
   </div> 
   <div> 
    <div> 
     <strong>7、添加用户命令 adduser </strong> 
    </div> 
    <div> 
     <div> 
      <strong>8、删除用户命令 deluser</strong> 
     </div> 
     <div> 
      <strong>9、切换用户命令 su</strong> 
     </div> 
     <div> 
      <strong>10、显示文件内容命令 cat </strong> 
     </div> 
     <div> 
      <div> 
       <strong>11、显示和配置网络属性命令 ifconfig </strong> 
      </div> 
      <div> 
       <div> 
        <strong>12、系统帮助命令 man </strong> 
       </div> 
       <div> 
        <strong>13、 系统重启命令 reboot </strong> 
       </div> 
       <div> 
        <div> 
         <strong>14、系统关闭命令 poweroff </strong> 
        </div> 
        <div> 
         <strong>15、软件安装命令 install </strong> 
        </div> 
        <h3 id="2.4%C2%A0%20APT%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7"><strong>2.4  APT下载工具</strong></h3> 
        <p><strong>       </strong>APT 工具常用的命令如下：</p> 
        <p><strong>1、更新本地数据库 </strong></p> 
        <blockquote> 
         <p>sudo apt-get update</p> 
        </blockquote> 
        <p>        这个命令会访问源地址，并且获取软件列表并保存在本电脑上。</p> 
        <p><strong>2、检查依赖关系 </strong></p> 
        <div>
                  有时候本地某些软件可能存在依赖关系，所谓依赖关系就是 A 软件依赖于 B 软件。通过如下命令可以查看依赖关系，如果存在依赖关系的话 APT 会提出解决方案： 
        </div> 
        <div></div> 
        <blockquote> 
         <div>
           sudo apt-get check 
         </div> 
        </blockquote> 
        <p><strong>3、软件安装 </strong></p> 
        <blockquote> 
         <p><strong>sudo apt-get install package-name</strong></p> 
        </blockquote> 
        <div>
                  上述命令是由“apt-get”和“install”组合在一起的，“package-name”就是要安装的软件名字，“apt-get”负责下载软件，“install”负责安装软件。比如我们要安装Ubuntu 下的串口工具“minicom”软件，我们就可以使用如下命令： 
        </div> 
        <blockquote> 
         <p><strong> </strong>sudo apt-get install minicom</p> 
        </blockquote> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<div>
          安装的过程中，会有如下所示询问： 
</div> 
<blockquote> 
 <div>
   您希望继续执行吗？[Y/n] 
 </div> 
</blockquote> 
<div>
          如果希望继续执行的话就输入 y，如果不希望继续执行的话就输入 n。 
</div> 
<div></div> 
<div> 
 <div> 
  <strong>4、软件更新 </strong> 
 </div> 
</div> 
<blockquote> 
 <p>        sudo apt-get upgrade package-name</p> 
</blockquote> 
<div> 
 <strong>5、卸载软件 </strong> 
</div> 
<blockquote> 
 <div>
   sudo apt-get remove package-name 
 </div> 
</blockquote> 
<h3 id="2.5Ubuntu%20%E4%B8%8B%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91"><strong>2.5</strong><strong>Ubuntu </strong><strong>下文本编辑</strong></h3> 
<p><strong>        我个人比较喜欢的文本编辑方式是：</strong></p> 
<p><strong>        在Windows上编辑后，拷贝到Ubuntu。</strong></p> 
<p><strong>        Windows：notepad++         Ubuntu：vim</strong></p> 
<h4 id="2.5.1%20%E5%AE%89%E8%A3%85%20VIM%20%E7%BC%96%E8%BE%91%E5%99%A8%3A">2.5.1 安装 VIM 编辑器:</h4> 
<blockquote> 
 <div>
   sudo apt-get install vim 
 </div> 
</blockquote> 
<h4 id="2.5.2%20vim%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8">2.5.2 vim编辑器的使用</h4> 
<p>        指令式的编辑器，不需要鼠标，也没有菜单，仅仅使用键盘来完成所有的编辑工作。</p> 
<p>        三种工作模式：输入模式、指令模式和底行模式，通过切换不同的模式可以完成不同的功能。</p> 
<p>        VIM 默认是以只读模式打开的文档，因此我们要切换到输入模式，切换到<strong>输入模式</strong>的命令如下：</p> 
<div> 
 <strong>        i  </strong>在当前光标所在字符的前面，转为输入模式。 
</div> 
<div> 
 <strong>        I  </strong>在当前光标所在行的行首转换为输入模式。 
</div> 
<div> 
 <strong>       </strong> 
 <strong> a</strong> 
 <strong> 在当前光标所在字符的后面，转为输入模式。</strong> 
</div> 
<div> 
 <strong>        A </strong>在光标所在行的行尾，转换为输入模式。 
</div> 
<div> 
 <strong>        o </strong>在当前光标所在行的下方，新建一行，并转为输入模式。 
</div> 
<div> 
 <strong>        O </strong>在当前光标所在行的上方，新建一行，并转为输入模式。 
</div> 
<div> 
 <strong>        s  </strong>删除光标所在字符。 
</div> 
<div> 
 <strong>        r   </strong>替换光标处字符。 
</div> 
<p>        按下键盘上的“a”键，这时候终端左下角会提 示“插入”字样，表示我们进入到了输入模式。</p> 
<p>        从 输入模式切换到指令模式：按下键盘的 ESC 键。</p> 
<p>        <strong>指令模式</strong>顾名思义就是输入指令的模式，这些指令是控制文本的指令：</p> 
<p><strong>1、移动光标指令： </strong></p> 
<div> 
 <strong>        h(或左方向键) </strong>光标左移一个字符。 
</div> 
<div> 
 <strong>        l(或右方向键) </strong> 光标右移一个字符。 
</div> 
<div> 
 <strong>        j(或下方向键)  </strong>光标下移一行。 
</div> 
<div> 
 <strong>        k(或上方向键) </strong>光标上移一行。 
</div> 
<div>
          nG                   光标移动到第 n 行首。 
</div> 
<div>
          n+                    光标下移 n 行。         
</div> 
<div> 
 <strong>        n- </strong>                    光标上移 n 行。 
</div> 
<div></div> 
<div> 
 <strong>2、屏幕翻滚指令 </strong> 
</div> 
<div></div> 
<div> 
 <strong>        Ctrl+f         </strong>屏幕向下翻一页，相当于下一页。 
</div> 
<div> 
 <strong>        Ctrl+b         </strong>屏幕向上翻一页，相当于上一页。 
</div> 
<div> 
 <strong>3、复制、删除和粘贴指令 </strong> 
</div> 
<div> 
 <strong>        cc        </strong>删除整行，并且修改整行内容。 
</div> 
<div> 
 <strong>        dd        </strong>删除改行，不提供修改功能。 
</div> 
<div> 
 <div> 
  <strong>        ndd      </strong>删除当前行向下 n 行。 
 </div> 
 <div> 
  <strong>        x           </strong>删除光标所在的字符。 
 </div> 
 <div> 
  <strong>        X           </strong>删除光标前面的一个字符。 
 </div> 
 <div> 
  <strong>        nyy       </strong>复制当前行及其下面 n 行。 
 </div> 
 <div> 
  <strong>        p            </strong>粘贴最近复制的内容。 
 </div> 
 <div></div> 
</div> 
<div>
          进入 
 <strong>底行模式</strong>的方式是先进入指令模式下，然后在指令模式下输入“：”进入底行模式。 
</div> 
<div>
  我们可以在 “：”后面输入命令，常用的命令如下： 
</div> 
<div> 
 <strong>        x         </strong>保存当前文档并且退出。 
</div> 
<div> 
 <strong>        q         </strong>退出。 
</div> 
<div> 
 <strong>        w         </strong>保存文档。 
</div> 
<div> 
 <strong>        q!         </strong>退出 VI/VIM，不保存文档。 
</div> 
<div>
           
 <div>
   还可以在指令模式下输入“/”进入底行模式，在“/”底行模式下我们可以在文本中搜索指定的内容。 
 </div> 
 <h3 id="2.6%20Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><strong>2.6 Linux </strong><strong>文件系统</strong></h3> 
 <p><strong>        </strong>操作系统的基本功能之一就是文件管理，而文件的管理是由文件系统来完成的。Linux 支持多种文件系统，本节我们就来讲解 Linux 下的文件系统、文件系统类型、文件系统结构和文件系统相关 Shell 命令。</p> 
 <h4 id="2.6.1%20Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B"><strong>2.6.1 Linux </strong><strong>文件系统简介以及类型 </strong></h4> 
 <p>       Linux 下常用的磁盘分割工具为： fdisk 工具。</p> 
 <p>        后面会用到：移植 Linux 的时候需要将 SD 卡分为两个分区来存储不同的东西。</p> 
 <p>        格式化：使用 fdisk 创建好分区以后也是要先在创建好的分区上面创建文件系统。</p> 
 <p>        在 Linux 下创建一个分区并且格式化好以后我们要将其 “挂载”到一个目录下才能访问这个分区。Linux 下我们使用 mount 命令来挂载磁盘。挂载磁盘的时候是需要确定挂载点 的，也就是你的这个磁盘要挂载到哪个目录下。  </p> 
 <p><strong>         ext4 文件系统</strong></p> 
 <p><strong>        </strong>在终端中输入如下命令来查询当前磁盘挂 载的是啥文件系统：</p> 
 <blockquote> 
  <div>
    df -T -h 
  </div> 
 </blockquote> 
 <h4 id="2.6.2%20Linux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><strong>2.6.2 Linux </strong><strong>文件系统结构 </strong></h4> 
 <p><strong>       </strong><strong>根目录</strong>“/”</p> 
 <p>        创建一个用户，系统会在/home 这个目录下创建一个以这个用户名命名的文件 夹，这个文件夹就是这个<strong>用户的根目录</strong>（“~”）。</p> 
 <blockquote> 
  <p></p> 
  <div>
    cd /         //进入到根目录“ / ” 
  </div> 
  <div>
    ls            //查看根目录“ / ”下的文件以及文件夹 
  </div> 
 </blockquote> 
 <div>
           根目录“/” 中的一些重要的文件夹： 
 </div> 
 <div></div> 
 <div> 
  <div> 
   <strong>/bin         </strong>存储一些二进制可执行命令文件，/usr/bin 也存放了一些基于用户的命令文件。 
  </div> 
  <div> 
   <strong>/sbin         </strong>存储了很多系统命令，/usr/sbin 也存储了许多系统命令。 
  </div> 
  <div> 
   <strong>/root         </strong>超级用户 root 的根目录文件。 
  </div> 
  <div> 
   <strong>/home         </strong>普通用户默认目录，在该目录下，每个用户都有一个以本用户名命名的文件夹。 
  </div> 
  <div> 
   <strong>/boot         </strong>存放 Ubuntu 系统内核和系统启动文件。 
  </div> 
  <div>
    /mnt         通常包括系统引导后被挂载的文件系统的挂载点。 
  </div> 
  <div> 
   <strong>/dev         </strong>存放设备文件，我们后面学习 Linux 驱动主要是跟这个文件夹打交道的。 
  </div> 
  <div> 
   <strong>/etc         </strong>保存系统管理所需的配置文件和目录。 
  </div> 
  <div> 
   <strong>/lib         </strong>保存系统程序运行所需的库文件，/usr/lib 下存放了一些用于普通用户的库文件。 
  </div> 
  <div> 
   <strong>/lost+found </strong>一般为空，当系统非正常关机以后，此文件夹会保存一些零散文件。 
  </div> 
  <div> 
   <strong>/var         </strong>存储一些不断变化的文件，比如日志文件 
  </div> 
  <div> 
   <strong>/usr         </strong>包括与系统用户直接有关的文件和目录，比如应用程序和所需的库文件。 
  </div> 
  <div> 
   <strong>/media         </strong>存放 Ubuntu 系统自动挂载的设备文件。 
  </div> 
  <div> 
   <strong>/proc         </strong>虚拟目录，不实际存储在磁盘上，通常用来保存系统信息和进程信息。 
  </div> 
  <div> 
   <strong>/tmp         </strong>存储系统和用户的临时文件，该文件夹对所有的用户都提供读写权限。 
  </div> 
  <div> 
   <strong>/opt         </strong>可选文件和程序的存放目录。 
  </div> 
  <div> 
   <strong>/sys         </strong>系统设备和文件层次结构，并向用户程序提供详细的内核数据信息。 
  </div> 
 </div> 
 <h4 id="2.6.3%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><strong>2.6.3 文件操作命令 </strong></h4> 
 <p><strong>1、创建新文件命令—touch </strong></p> 
 <blockquote> 
  <div> 
   <div>
     touch [参数] [文件名] 
   </div> 
  </div> 
 </blockquote> 
 <h4 id="2%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4%E2%80%94mkdir"><strong>2、文件夹创建命令—mkdir </strong></h4> 
 <blockquote> 
  <div>
    mkdir [参数] [文件夹名目录名] 
  </div> 
 </blockquote> 
 <div>
           主要参数如下： 
 </div> 
 <div> 
  <strong>        -p </strong>如所要创建的目录其上层目录目前还未创建，那么会一起创建上层目录。 
 </div> 
 <div></div> 
 <div> 
  <strong>3、文件及目录删除命令—rm </strong> 
 </div> 
 <div></div> 
 <blockquote> 
  <div> 
   <div>
     rm [参数] [目的文件或文件夹目录名] 
   </div> 
  </div> 
 </blockquote> 
 <div> 
  <div>
            命令主要参数如下： 
  </div> 
  <div> 
   <strong>        -d         </strong>直接把要删除的目录的硬连接数据删成 0，删除该目录。 
  </div> 
  <div> 
   <strong>        -f         </strong>强制删除文件和文件夹(目录)。 
  </div> 
  <div> 
   <strong>        -i         </strong>删除文件或者文件夹(目录)之前先询问用户。 
  </div> 
  <div> 
   <strong>        -r         </strong>递归删除，指定文件夹(目录)下的所有文件和子文件夹全部删除掉。 
  </div> 
  <div> 
   <strong>        -v         </strong>显示删除过程。 
  </div> 
  <div></div> 
  <div> 
   <strong>4、文件夹(目录)删除命令—rmdir </strong> 
  </div> 
  <blockquote> 
   <div> 
    <div>
      rmdir [参数] [文件夹(目录)] 
    </div> 
   </div> 
  </blockquote> 
 </div> 
 <div>
           命令主要参数如下： 
 </div> 
 <div> 
  <strong>        -p </strong>删除指定的文件夹(目录)以后，若上层文件夹(目录)为空文件夹(目录)的话就将其一起删除。 
 </div> 
 <div></div> 
 <div> 
  <strong>5、文件复制命令—cp </strong> 
 </div> 
 <div> 
  <strong>        </strong> 
  <blockquote> 
   <div>
     cp [参数] [源地址] [目的地址] 
   </div> 
  </blockquote> 
 </div> 
 <div>
           主要参数描述如下： 
 </div> 
 <div> 
  <strong>        -a         </strong>此参数和同时指定“-dpR”参数相同 
 </div> 
 <div> 
  <strong>        -d         </strong>在复制有符号连接的文件时，保留原始的连接。 
 </div> 
 <div> 
  <strong>        -f         </strong>强行复制文件，不管要复制的文件是否已经存在于目标目录。 
 </div> 
 <div> 
  <strong>        -I         </strong>覆盖现有文件之前询问用户。 
 </div> 
 <div> 
  <strong>        -p         </strong>保留源文件或者目录的属性。 
 </div> 
 <div> 
  <strong>        -r 或-R </strong>递归处理，将指定目录下的文件及子目录一并处理 
 </div> 
 <div></div> 
 <div> 
  <strong>6、文件移动命令—mv</strong> 
 </div> 
 <div></div> 
 <blockquote> 
  <div> 
   <div>
     mv [参数] [源地址] [目的地址] 
   </div> 
  </div> 
 </blockquote> 
 <div> 
  <div>
            主要参数描述如下： 
  </div> 
  <div> 
   <strong>        -b         </strong>如果要覆盖文件的话覆盖前先进行备份。 
  </div> 
  <div> 
   <strong>        -f         </strong>若目标文件或目录与现在的文件重复，直接覆盖目标文件或目录。 
  </div> 
  <div> 
   <strong>        -I         </strong>在覆盖之前询问用户。 
  </div> 
 </div> 
 <h4 id="2.6.4%C2%A0%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9"><strong>2.6.4 </strong><strong>命令行进行文件的压缩和解压缩</strong></h4> 
 <p>        命令行下进行压缩和解压缩常用的命令有三个：zip、unzip 和 tar。</p> 
 <div> 
  <strong>1、命令 zip：</strong>用于将一个或者多个文件压缩成一个.zip 结尾的文件 
 </div> 
 <div></div> 
 <blockquote> 
  <div>
    zip [参数] [压缩文件名.zip] [被压缩的文件] 
  </div> 
 </blockquote> 
 <div> 
  <div>
            主要参数函数如下： 
  </div> 
  <div> 
   <strong>        -b&lt;工作目录&gt;         </strong>指定暂时存放文件的目录。 
  </div> 
  <div> 
   <strong>        -d         </strong>从 zip 文件中删除一个文件。 
  </div> 
  <div> 
   <strong>        -F         </strong>尝试修复已经损毁的压缩文件。 
  </div> 
  <div> 
   <strong>        -g         </strong>将文件压缩入现有的压缩文件中，不需要新建压缩文件。 
  </div> 
  <div> 
   <strong>        -h         </strong>帮助。 
  </div> 
  <div> 
   <strong>        -j         </strong>只保存文件的名，不保存目录。 
  </div> 
  <div> 
   <strong>        -m         </strong>压缩完成以后删除源文件。 
  </div> 
  <div> 
   <strong>        -n&lt;字尾符号&gt;         </strong>不压缩特定扩展名的文件。 
  </div> 
  <div> 
   <strong>        -q         </strong>不显示压缩命令执行过程。 
  </div> 
  <div> 
   <strong>        -r         </strong>递归压缩，将指定目录下的所有文件和子目录一起压缩。 
  </div> 
  <div> 
   <strong>        -v         </strong>显示指令执行过程。 
  </div> 
  <div>
             
   <strong>-num         </strong>压缩率，为 1~9 的数值。 
  </div> 
  <div></div> 
  <div> 
   <strong>2、命令 unzip：</strong>用于对.zip 格式的压缩包进行解压 
  </div> 
  <div></div> 
  <blockquote> 
   <div> 
    <div>
      unzip [参数] [压缩文件名.zip] 
    </div> 
   </div> 
  </blockquote> 
  <div> 
   <div>
             主要参数如下： 
   </div> 
   <div> 
    <strong>        -l         </strong>显示压缩文件内所包含的文件。 
   </div> 
   <div> 
    <strong>        -t         </strong>检查压缩文件是否损坏，但不解压。 
   </div> 
   <div> 
    <strong>        -v         </strong>显示命令的执行过程。 
   </div> 
   <div> 
    <strong>        -Z         </strong>只显示压缩文件的注解。 
   </div> 
   <div> 
    <strong>        -C         </strong>压缩文件中的文件名称区分大小写。 
   </div> 
   <div> 
    <strong>        -j         </strong>不处理压缩文件中的原有目录路径。 
   </div> 
   <div> 
    <strong>        -L         </strong>将压缩文件中的全部文件名改为小写。 
   </div> 
   <div> 
    <strong>        -n         </strong>解压缩时不要覆盖原有文件。 
   </div> 
   <div> 
    <strong>        -P&lt;密码&gt;         </strong>解压密码。 
   </div> 
   <div> 
    <strong>        -q         </strong>静默执行，不显示任何信息。 
   </div> 
   <div> 
    <strong>        -x&lt;文件列表&gt;         </strong>指定不要处理.zip 中的哪些文件。 
   </div> 
   <div> 
    <strong>        -d&lt;目录&gt;         </strong>把压缩文件解到指定目录下。 
   </div> 
   <div></div> 
   <div> 
    <strong>3、命令 tar </strong> 
   </div> 
   <div></div> 
   <blockquote> 
    <div> 
     <div>
       tar [参数] [压缩文件名] [被压缩文件名] 
     </div> 
    </div> 
   </blockquote> 
   <div> 
    <div>
              常用参数如下： 
    </div> 
    <div> 
     <strong>        -c         </strong>创建新的压缩文件。 
    </div> 
    <div> 
     <strong>        -C&lt;目的目录&gt;         </strong>切换到指定的目录。 
    </div> 
    <div> 
     <strong>        -f&lt;备份文件&gt;         </strong>指定压缩文件。 
    </div> 
    <div> 
     <strong>        -j         </strong>用 tar 生成压缩文件，然后用 bzip2 进行压缩。 
    </div> 
    <div> 
     <strong>        -k         </strong>解开备份文件时，不覆盖已有的文件。 
    </div> 
    <div> 
     <strong>        -m         </strong>还原文件时，不变更文件的更改时间。 
    </div> 
    <div> 
     <strong>        -r         </strong>新增文件到已存在的备份文件的结尾部分。 
    </div> 
    <div> 
     <strong>        -t         </strong>列出备份文件内容。 
    </div> 
    <div> 
     <strong>        -v         </strong>显示指令执行过程。 
    </div> 
    <div> 
     <strong>        -w         </strong>遭遇问题时先询问用户。 
    </div> 
    <div> 
     <strong>        -x         </strong>从备份文件中释放文件，也就是解压缩文件。 
    </div> 
    <div> 
     <strong>        -z         </strong>用 tar 生成压缩文件，用 gzip 压缩。 
    </div> 
    <div> 
     <strong>        -Z         </strong>用 tar 生成压缩文件，用 compress 压缩。 
    </div> 
    <div>
              例：使用如下两个命令将 test1 文件夹压缩为.bz2 和.gz 这两个格式： 
    </div> 
    <blockquote> 
     <div> 
      <div>
        tar -vcjf test1.tar.bz2 test1 
      </div> 
      <div>
        tar -vczf test1.tar.gz test1 
      </div> 
     </div> 
    </blockquote> 
   </div> 
  </div> 
 </div> 
 <div>
           -vcjf 表示创建 bz2 格式的压缩文件，-vczf 表示创建.gz 格式的压缩文件。 
 </div> 
 <div></div> 
 <div>
           例：使用如下所示两行命令完成.bz2 和.gz 格式文件的解压缩： 
 </div> 
 <blockquote> 
  <div> 
   <div>
     tar -vxjf test1.tar.bz2 
   </div> 
   <div>
     tar -vxzf test2.tar.gz 
   </div> 
  </div> 
 </blockquote> 
 <div>
           -vxjf 用来完成.bz2 格式压缩文件的解压，-vxzf 用来完成.gz 格式压缩文件的解压。 
 </div> 
 <h4 id="2.6.5%C2%A0%E6%96%87%E4%BB%B6%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%90%9C%E7%B4%A2%EF%BC%88%E6%B2%A1%E6%80%8E%E4%B9%88%E7%94%A8%E8%BF%87%EF%BC%89">2.6.5 <strong>文件查询和搜索（没怎么用过）</strong></h4> 
 <p><strong>1、命令 find</strong></p> 
 <blockquote> 
  <p></p> 
  <div>
    find [路径] [参数] [关键字] 
  </div> 
 </blockquote> 
 <p><strong>2、命令 grep </strong></p> 
 <blockquote> 
  <div>
    grep [参数] 关键字 文件列表 
  </div> 
 </blockquote> 
 <h4 id="2.6.6%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B">2.6.6文件类型</h4> 
 <div>
           每个文件的详细信息占一行，每行 
  <strong>最前面一个符号</strong>就标记了当前文件类型。 
 </div> 
 <div>
            
  <div>
            -         普通文件，一些应用程序创建的，比如文档、图片、音乐等等。 
  </div> 
  <div> 
   <strong>        d         </strong>目录文件。 
  </div> 
  <div> 
   <strong>        c         </strong>字符设备文件，Linux 驱动里面的字符设备驱动，比如串口设备，音频设备等。 
  </div> 
  <div> 
   <strong>        b         </strong>块设备文件，存储设备驱动，比如硬盘，U 盘等。 
  </div> 
  <div> 
   <strong>        l         </strong>符号连接文件，相当于 Windows 下的快捷方式。 
  </div> 
  <div> 
   <strong>        s         </strong>套接字文件。 
  </div> 
  <div> 
   <strong>        p         </strong>管道文件，主要指 FIFO 文件。 
  </div> 
  <div></div> 
  <div>
            后面学习 Linux 驱动开发的时候基本是在和字符设备文件和块设备文件打交道。 
  </div> 
 </div> 
 <h3 id="2.7%C2%A0Linux%20%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">2.7 <strong>Linux </strong><strong>用户权限管理</strong></h3> 
 <h4 id="2.7.1Ubuntu%20%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F">2.7.1<strong>Ubuntu </strong><strong>用户系统</strong></h4> 
 <div>
   Ubuntu 下用户类型分为以下 3 类： 
 </div> 
 <div>
           ● 初次创建的用户，此用户可以完成比普通用户更多的功能。 
 </div> 
 <div>
           ● root 用户，系统管理员，系统中的玉皇大帝，拥有至高无上的权利。 
 </div> 
 <div>
           ● 普通用户，安装完操作系统以后被创建的用户。 
 </div> 
 <div>
           以上三种用户，每个用户都有一个 ID 号，称为 UID，操作系统通过 UID 来识别是哪个用户，用户相关信息可以在文件/etc/passwd 中查看到： 
 </div> 
 <blockquote> 
  <div>
    cat /etc/passwd 
  </div> 
 </blockquote> 
 <h4 id="2.7.2%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86">2.7.2<strong>权限管理 </strong></h4> 
 <div>
           Ubuntu 下我们会常跟用户权限打交道，权限就是用户对于系统资源的使用限制情况，root 用户拥有最大的权限，可以为所欲为，装系统的时候创建的用户拥有 root 用户的部分权限，其它普通用户的权限最低。 
 </div> 
 <div></div> 
 <div>
           做嵌入式开发重点关注的是 
  <strong>文件的权限</strong>问题。 
 </div> 
 <div></div> 
 <div> 
  <div>
            对于一个文件通常有三种权限：读(r)、写(w)和执行(x)，使用命令“ls -l”可以查看某个目录下所有文件的权限信息。 
  </div> 
  <div>
             
  </div> 
  <div>
             
   <div>
           以文件 test.c 为例讲解，文件 test.c 文件信息如下： 
   </div> 
   <blockquote> 
    <div>
      -rw-rw-r-- 1 wurao wurao 0 10 月 12 21:14 test.c 
    </div> 
   </blockquote> 
   <div>
             其中“-rw-rw-r--”表示文件权限与用户和用户组之间的关系， 
    <strong>第一位表示文件类型</strong>，上 一小节已经说了。 
    <strong>剩下的 9 位以 </strong> 
    <strong>3 位为一组</strong> 
    <strong>，分别表示</strong> 
    <strong>文件拥有者的权限</strong>，文件拥有者所在用户组的权限以及其它用户权限。后面的“wurao wurao”分别代表文件拥有者(用户)和该用户所在的用户组，因此文件 test.c 的权限情况如下： 
   </div> 
   <div>
             ①、文件 test.c 的拥有者是用户 wurao，其对文件 tesst.c 的权限是“rw-”，也就是对该文件拥有读和写两种权限。 
   </div> 
   <div>
             ②、用户 wurao 所在的用户组也叫做 wurao，其组内用户对于文件 test.c 的 
   </div> 
   <div>
     权限是“rw-”，也是拥有读和写这两种权限。 
   </div> 
   <div>
             ③、其它用户对于文件 test.c 的权限是“r--”，也就是只读权限。 
   </div> 
   <div></div> 
   <div>
              
    <strong>对于文件</strong>， 
    <strong>可读</strong>权限表示可以打开查看文件内容， 
    <strong>可写</strong>权限表示可以对文件进行修改， 
    <strong>可执行</strong>权限就是可以运行此文件(如果是软件的话)。 
   </div> 
   <div> 
    <strong>        对于文件夹</strong>，拥有 
    <strong>可读</strong>权限才可以使用命令ls 查看文件夹中的内容，拥有 
    <strong>可执行</strong>权限才能进入到文件夹内部。 
   </div> 
   <div>
             如果某个用户对某个文件 
    <strong>不具有相应的权限</strong>的话就不能进行相应的操作，比如根目录“/”下的文件只有 root 用户才有权限进行修改，如果以普通用户去修改的话就会 
    <strong>提示没有权限</strong>。 
   </div> 
   <div></div> 
   <div>
             遇到提示权限不够的时候都可以使用 
    <strong>sudo 命令</strong>暂时以 root 用户身份去执行。 
   </div> 
   <div></div> 
   <div> 
    <div>
              文件的权限有三种：读(r)、写(w)和执行(x)，除了用 r、w 和 x 表示以外， 我们也可以 
     <strong>使用二进制数表示</strong>，三种 
     <strong>权限</strong>就可以使用 3 位二进制数来表示，一种权限对应一个 二进制位，如果该位为 1 就表示具备此权限，如果该位为 0 就表示没不具备此权限。 
    </div> 
   </div> 
  </div> 
 </div> 
 <p><img alt="bcf2ff43539a4466abaed81f9fb5d442.png" src="https://images2.imgbox.com/9a/f3/mPvkrdZ3_o.png"></p> 
 <p>         权限所对应的八进制数字就是每个权限对应的位相加，比如权限 rwx 就是 4+2+1=7。前面的文件 test.c 其权限为“rw-rw-r--”，因此其十进制表示就是：664。</p> 
 <p>        另外我们也开始使用 a、u、g 和 o 表示文件的归属关系，用=、+和-表示文件权限的变化。</p> 
 <h4 id="2.7.3%20%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">2.7.3 权限管理命令</h4> 
 <p><strong>1、权限修改命令 chmod </strong></p> 
 <blockquote> 
  <p></p> 
  <div>
    chmod [参数] [文件名/目录名] 
  </div> 
 </blockquote> 
 <div>
   例：修改文件 test 的权限为 766 
 </div> 
 <div></div> 
 <blockquote> 
  <div>
    chomd 766 test 
  </div> 
 </blockquote> 
 <div> 
  <strong>2、文件归属者修改命令 chown（没怎么用过）</strong> 
 </div> 
 <div></div> 
 <div> 
  <blockquote> 
   <div>
     chown [参数] [用户名.&lt;组名&gt;] [文件名/目录] 
   </div> 
  </blockquote> 
 </div> 
 <h3 id="2.8%20Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86">2.8 Linux磁盘管理</h3> 
 <h4 id="2.8.1%20Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2.8.1 Linux磁盘管理基本概念</h4> 
 <div>
           在 Windows 下经常会遇到“分区”这个概念，在 Linux 中一般不叫“分区”而叫“ 
  <strong>挂载点</strong>”。 “挂载点”就是将一个硬盘的一部分做成文件夹的形式，这个文件夹的名字就是“挂载点”。 
 </div> 
 <div></div> 
 <div> 
  <div>
    文件/etc/fstab 详细的记录了 Ubuntu 中硬盘分区的情况： 
  </div> 
 </div> 
 <blockquote>
   cat /etc/fstab 
 </blockquote> 
 <div> 
  <div>
    可以通过如 下命令查看当前系统中的磁盘： 
  </div> 
  <blockquote> 
   <div>
     ls /dev/sd* 
   </div> 
  </blockquote> 
 </div> 
 <h4 id="2.8.2%20%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">2.8.2 磁盘管理命令</h4> 
 <p><strong>1、磁盘分区命令 fdisk（放在后面详细操作）</strong></p> 
 <blockquote> 
  <p></p> 
  <div>
    fdisk [参数] 
  </div> 
 </blockquote> 
 <div> 
  <div>
    比如我要对 U 盘（U 盘数据要先做好备份，防止数据丢失）进行分区，千万不要对自己装 
  </div> 
  <div>
    Ubuntu 系统进行分区！可以使用如下命令： 
  </div> 
  <blockquote> 
   <div>
     sudo fdisk /dev/sdb 
   </div> 
  </blockquote> 
  <div> 
   <strong>2、格式化命令 mkfs </strong> 
  </div> 
  <div> 
   <strong>3、挂载分区命令 mount </strong> 
  </div> 
  <div> 
   <div> 
    <strong>4、卸载命令 umount </strong> 
   </div> 
   <div></div> 
   <h2 id="%E4%B8%89%E3%80%81Linux%20C%20%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8">三、<strong>Linux C </strong><strong>编程入门</strong></h2> 
   <p>        Ubuntu 下也有一些可以进行编程的工具，但是大多都只是编辑器，也就是只能进行代码<strong>编辑</strong>。</p> 
   <p>        Ubuntu 下要<strong>编译</strong>的话就需要用到 <strong>GCC 编译器</strong>，使用 GCC 编译器肯定就要接触到<strong>Makefile</strong>。</p> 
   <h3 id="3.1%C2%A0Hello%20World%EF%BC%81">3.1 <strong>Hello World</strong><strong>！</strong></h3> 
   <p><strong>        </strong>编写代码包括两部分：<strong>代码编写</strong>和<strong>编译</strong><strong>。</strong></p> 
   <p>        代码编写用 notepad++ （Windows）和 VIM（Ubuntu）。</p> 
   <p>        编译：GCC 编译器。</p> 
   <h4 id="3.1.1%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81">3.1.1编写代码</h4> 
   <blockquote> 
    <p>cd ~</p> 
    <p>mkdir C_Program</p> 
    <p>cd C_Program</p> 
    <p>mkdir 3.1</p> 
   </blockquote> 
   <div>
     使用 VI 编辑器之前我们先做如下设置： 
   </div> 
   <div> 
    <strong>1、设置 TAB 键为 4 字节</strong> 
   </div> 
   <div> 
    <div>
              VI 编辑器默认 TAB 键为 8 空格，我们改成 4 空格，用 vi 打开文件/etc/vim/vimrc，在此文件最后面输入如下代码： 
    </div> 
    <blockquote> 
     <div>
       set ts=4 
     </div> 
    </blockquote> 
    <div>
              修改完成以后保存并关闭文件。 
    </div> 
   </div> 
   <div> 
    <strong>2、VIM 编辑器显示行号 </strong> 
   </div> 
   <div> 
    <div>
              VIM 编辑器默认是不显示行号的，不显示行号不利于代码查看，我们设置 VIM 编辑器显示行号，同样是通过在文件/etc/vim/vimrc 中添加代码来实现，在文件最后面加入下面一行代码即可： 
    </div> 
    <blockquote> 
     <div>
       set nu 
     </div> 
    </blockquote> 
    <div> 
     <div>
               VIM 编辑器可以自行定制，网上有很多的博客讲解如何设置 VIM。 
     </div> 
     <div></div> 
     <div> 
      <div>
                进入前面创建的“3.1”这个工程文 件夹里面，使用 vi 指令创建一个名为“main.c”的文件： 
      </div> 
      <blockquote> 
       <div>
         cd 3.1 
       </div> 
       <div>
         vi main.c 
       </div> 
      </blockquote> 
      <div> 
       <div>
                 然后在里面输入如下代码： 
       </div> 
       <div> 
        <pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{
    printf("Hello World!\n");
}</code></pre> 
        <div>
                  编写完成以后保存退出 vi 编辑器，可以使用“cat”命令查看代码是否编写成功: 
        </div> 
        <blockquote> 
         <div>
           cat main.c 
         </div> 
        </blockquote> 
        <h4 id="3.1.2%C2%A0%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81">3.1.2 <strong>编译代码</strong></h4> 
        <p><strong>        </strong>Ubuntu 下的 C 语言编译器是 GCC，GCC 编译器在我们安装 Ubuntu 的时候就已经默认安装好了，可以通过如下命令查看 GCC 编译器的版本号：</p> 
        <blockquote> 
         <p>gcc -v</p> 
        </blockquote> 
        <div>
                  如果想要 编译在 ARM 上运行的程序就需要针对 ARM 架构的 GCC 编译器，也就是 
         <strong>交叉编译器</strong>。我们进行 ARM 开发，因此肯定要安装针对 ARM 架构的 GCC 交叉编译器（在后面会用）。 
        </div> 
        <div></div> 
        <div> 
         <div>
                   
          <strong> 如何使用 GCC 编译器来编译 main.c 文件呢？</strong> 
         </div> 
         <div>
                   GCC 编译器是 
          <strong>命令模式</strong>的，因此需要输入命令来使用 gcc 编译器来编译文件，输入如下命令： 
         </div> 
         <blockquote> 
          <div>
            gcc main.c 
          </div> 
         </blockquote> 
        </div> 
        <div> 
         <div>
                   当编译完成以后会生成一个 a.out 文件，这个 a.out 就是编译生成的 
          <strong>可执行文件</strong>。 
         </div> 
         <div>
                    
          <div>
                     
           <strong>执行的方法</strong>很简单，使用命令： “ 
           <strong>./可执行文件</strong>” 
          </div> 
          <div>
                     
          </div> 
          <div>
                    a.out 这个文件名是 GCC 编译器自动命名的，自己能决定编译完生成的可执行文件名字： 
          </div> 
          <blockquote> 
           <div>
             gcc main.c –o main 
           </div> 
          </blockquote> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <h3 id="3.2%20GCC%E7%BC%96%E8%AF%91%E5%99%A8"><strong>3.2 GCC编译器</strong></h3> 
   <h4 id="3.2.1%20gcc%20%E5%91%BD%E4%BB%A4"><strong>3.2.1 gcc </strong><strong>命令</strong></h4> 
   <div>
             gcc 命 令格式如下： 
   </div> 
   <blockquote> 
    <div> 
     <div>
       gcc [选项] [文件名字] 
     </div> 
    </div> 
   </blockquote> 
   <div>
             主要选项如下： 
   </div> 
   <div>
             -c         只编译不链接为可执行文件，编译器将输入的.c 文件编译为.o 的目标文件。 
   </div> 
   <div>
             -o&lt;输出文件名&gt;         用来指定编译结束以后的输出文件名，如果不使用这个选项的话 GCC 默认编译出来的可执行文件名字为 a.out。 
   </div> 
   <div>
             -g         添加调试信息，如果要使用调试工具(如 GDB)的话就必须加入此选项，此选项指示编译的时候生成调试所需的符号信息。 
   </div> 
   <div>
             -O         对程序进行优化编译，如果使用此选项的话整个源代码在编译、链接的的时候都会进行优化，这样产生的可执行文件执行效率就高。 
   </div> 
   <div>
             -O2         比-O 更幅度更大的优化，生成的可执行效率更高，但是整个编译过程会很慢。 
   </div> 
   <h4 id="3.2.2%20%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E8%AD%A6%E5%91%8A">3.2.2 编译错误警告</h4> 
   <p>        GCC 编译器和其它编译器一样，不仅能够检测出错误类型，而且标记除了错误发生在哪个文件、哪一行，方便我们去修改代码。</p> 
   <h4 id="3.2.3%20%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B">3.2.3 编译流程</h4> 
   <p>        GCC 编译器的编译流程是：预处理、汇编、编译和链接。<strong>预处理</strong>就是对程序中的宏定义等相关的内容先进行前期的处理。<strong>汇编</strong>是先将 C 文件转换为汇编文件。当 C 文件转换为汇编文件以后就是文件<strong>编译</strong>了，编译过程就是将 C 源文件编译成.o 结尾的目标文件。编译生成的.o 文 件不能直接执行，而是需要最后的链接，如果你的工程有很多个 c 源文件的话最终就会有很 多.o 文件，将这些.o 文件<strong>链接</strong>在一起形成完整的一个可执行文件。</p> 
   <p>        上一小节演示的例程都只有一个文件，而且文件非常简单，因此可以直接使用 gcc 命令生成可执行文件，并没有先将 c 文件编译成.o 文件，然后在链接在一起。</p> 
   <h3 id="3.3%C2%A0Makefile%20%E5%9F%BA%E7%A1%80"><strong>3.3 Makefile </strong><strong>基础</strong></h3> 
   <h4 id="3.3.1%20%E4%BD%95%E4%B8%BAMakefile"><strong>3.3.1 何为Makefile</strong></h4> 
   <p>        通过在终端执行 gcc 命令来完成 C 文件的编译，如果我们的工程只有一两个 C 文件还好，需要输入的命令不多，<strong>当文件有几十、上百甚至上万个的时候用终端输入 GCC 命令的方法显然是不现实的。</strong></p> 
   <p><strong>        </strong>如果我们能够 编写一个文件，这个文件描述了编译哪些源码文件、如何编译那就好了，每次需要编译工程的时侯只需要使用这个文件就行了。</p> 
   <p>        为此提出了一个解决大 工程编译的工具：Make，<strong>描述哪些文件需要编译、哪些需要重新编译的文件就叫做 </strong><strong>Makefile</strong><strong>。</strong></p> 
   <p><strong>        </strong>Makefile 就跟脚本文件一样，<strong>Makefile 里面还可以执行系统命令</strong>。使用的时候只需要一 个 make 命令即可完成整个工程的自动编译，极大的<strong>提高了软件开发的效率</strong>。</p> 
   <p>        如果大家以前一 直使用 IDE 来编写 C 语言的话肯定没有听说过 Makefile 这个东西，其实这些 IDE 是有的，只 不过这些 IDE 对其进行了封装，提供给大家的是已经经过封装后的图形界面了，我们在 IDE 中添加要编译的 C 文件，然后点击按钮就完成了编译。</p> 
   <p>        作为一个<strong>专业的程序员</strong>，是 <strong>一定要懂得 Makefile</strong> 的，一是因为在 Linux 下你不得不懂 Makefile，再就是通过 Makefile 你就能了解整个工程的处理过程。</p> 
   <p>        由于 Makefile 的知识比较多，完全可以单独写本书，因此本章我们只讲解 Makefile 基础 入门，如果想详细的研究 Makefile，推荐大家阅读《跟我一起写 Makefile》这份文档。</p> 
   <h4 id="3.3.2%C2%A0Makefile%20%E7%9A%84%E5%BC%95%E5%85%A5"><strong>3.3.2 Makefile </strong><strong>的引入 </strong></h4> 
   <p><strong>        </strong>完成一个小工程：通过键盘输入两个整形数字，然后计算他们的和并将结果显示在屏幕上。</p> 
   <p>        包括以下文件：main.c，input.c ， calcu.c，input.h，calcu.h</p> 
   <p>        main.c 是主体</p> 
   <p>        input.c 负责接收从键盘输入的数值</p> 
   <p>        calcu.h 进行任意两个数相加</p> 
   <p>main.c :</p> 
   <pre><code class="language-cpp"> #include &lt;stdio.h&gt; 
 #include "input.h"
 #include "calcu.h"

 int main(int argc, char *argv[])
 { 
    int a, b, num; 

    input_int(&amp;a, &amp;b);
    num = calcu(a, b);
    printf("%d + %d = %d\r\n", a, b, num);
}</code></pre> 
   <div>
     input.c : 
   </div> 
   <div> 
    <pre><code class="language-cpp"> #include &lt;stdio.h&gt; 
 #include "input.h"

 void input_int(int *a, int *b) 
 { 
 printf("input two num:");
 scanf("%d %d", a, b);
 printf("\r\n");
 }</code></pre> 
    <p></p> 
   </div> 
   <div>
     calcu.c : 
   </div> 
   <pre><code class="language-cpp"> #include "calcu.h"

 int calcu(int a, int b) 
 { 
 return (a + b);
 }</code></pre> 
   <p>input.h :</p> 
   <pre><code class="language-cpp"> #ifndef _INPUT_H
 #define _INPUT_H

 void input_int(int *a, int *b);
 #endif</code></pre> 
   <p>calcu.h :</p> 
   <pre><code class="language-cpp"> #ifndef _CALCU_H
 #define _CALCU_H

 int calcu(int a, int b);
 #endif</code></pre> 
   <p>        接下来使用 3.1 节讲的方法来对其进行编 译，在终端输入如下命令：</p> 
   <blockquote> 
    <p>gcc main.c calcu.c input.c -o main</p> 
   </blockquote> 
   <div>
             上面命令的意思就是使用 gcc 编译器对 main.c、calcu.c 和 input.c 这三个文件进行编 译，编译生成的可执行文件叫做 main。 
   </div> 
   <div></div> 
   <p>        使用命令“gcc main.c calcu.c input.c -o main”看起来很简单，只需要一行就可以完成编译，但是我们这个工程只有三个文件！如果几千个文件呢？再就是如果有一个文件被修改了呢，<strong>使用上面的命令编译的时候所有的文件都会重新编译</strong>，如果工程有几万个文件(Linux 源码就有这么多文件)，想想这几万个文件编译一次所需要的时间就可怕。<strong>最好的办法肯定是哪个文件被修改了，只编译这个修改的文件即可，其它没有修改的文件就不需要再次重新编译了</strong>，为此我们改变我们的编译方法，如果第一次编译工程，我们先将工程中的文件都编译一遍，然后后面修改了哪个文件就编译哪个文件，命令如下：</p> 
   <blockquote> 
    <div>
      gcc -c main.c 
    </div> 
    <div>
      gcc -c input.c 
    </div> 
    <div>
      gcc -c calcu.c 
    </div> 
    <div>
      gcc main.o input.o calcu.o -o main 
    </div> 
   </blockquote> 
   <div> 
    <div>
              上述命令前三行分别是将 main.c、input.c 和 calcu.c 编译成对应的.o 文件，所以使用了“-c”选项，“-c”选项我们上面说了，是只编译不链接。最后一行命令是将编译出来的所有.o 文件链接成可执行文件 main。假如我们现在修改了 calcu.c 这个文件，只需要将 caclue.c这一个文件重新编译成.o 文件，然后再将所有的.o 文件链接成可执行文件，只需要下面两条命令即可： 
    </div> 
    <blockquote> 
     <div> 
      <div>
        gcc -c calcu.c 
      </div> 
      <div>
        gcc main.o input.o calcu.o -o main 
      </div> 
     </div> 
    </blockquote> 
   </div> 
   <p>        但是这样就又有一个问题，如果修改的文件一多，我自己可能都不记得哪个文件修改过了， 然后忘记编译，然后……，<strong>为此我们需要这样一个工具</strong>：</p> 
   <div>
             1、如果工程没有编译过，那么工程中的所有.c 文件都要被编译并且链接成可执行程序。 
   </div> 
   <div>
             2、如果工程中只有个别 C 文件被修改了，那么只编译这些被修改的 C 文件即可。 
   </div> 
   <div>
             3、如果工程的头文件被修改了，那么我们需要编译所有引用这个头文件的 C 文件，并且链接成可执行文件。 
   </div> 
   <div></div> 
   <p>        很明显，能够完成这个功能的就是 <strong>Makefile</strong> 了，在工程目录下创建名为“Makefile”的文件，文件名一定要叫做“Makefile”！区分大小写！</p> 
   <p>        在 Makefile 文件中输入如下代码：</p> 
   <pre><code class="language-cpp">main: main.o input.o calcu.o 
    gcc -o main main.o input.o calcu.o
main.o: main.c 
    gcc -c main.c 
input.o: input.c 
    gcc -c input.c 
calcu.o: calcu.c 
    gcc -c calcu.c 

clean:
    rm *.o
    rm main</code></pre> 
   <p>        上述<strong>代码中所有行首需要空出来的地方一定要使用“TAB”键！</strong>不要使用空格键！这是 Makefile 的语法要求。</p> 
   <p>        Makefile 编写好以后我们就可以使用 Make 命令来编译我们的工程了，直接在命令行中输入“<strong>make</strong>”即可，Make 命令会在当前目录下查找是否存在“Makefile”这个文件，如果存在的话就会按照 Makefile 里面定义的编译方式进行编译。</p> 
   <h3 id="3.4%20Makefile%20%E8%AF%AD%E6%B3%95"><strong>3.4 Makefile </strong><strong>语法 </strong></h3> 
   <h4 id="3.4.1%C2%A0Makefile%20%E8%A7%84%E5%88%99%E6%A0%BC%E5%BC%8F"><strong>3.4.1 Makefile </strong><strong>规则格式</strong></h4> 
   <pre><code class="language-cpp">目标… … : 依赖文件集合… …
命令 1
命令 2
… …</code></pre> 
   <p>        比如下面这条规则：</p> 
   <pre><code class="language-cpp">main : main.o input.o calcu.o
        gcc -o main main.o input.o calcu.o</code></pre> 
   <div>
             这条规则的目标是 main，main.o、input.o 和 calcu.o 是生成 main 的依赖文件，如果要更新目标 main，就必须要先更新它的所有依赖文件，如果依赖文件中的任何一个有更新，那么目标也必须更新，“更新”就是执行一遍规则中的命令列表。 
   </div> 
   <p>        命令列表中的每条命令必须以 TAB 键开始，不能使用空格！</p> 
   <p>        make 命令会为 Makefile 中的每个以 TAB 开始的命令创建一个 Shell 进程去执行。</p> 
   <p>        了解了 Makefile 的基本运行规则以后我们再来分析一下 3.3 中的 Makefile，代码如下：</p> 
   <pre><code class="language-cpp">main: main.o input.o calcu.o 
    gcc -o main main.o input.o calcu.o
main.o: main.c 
    gcc -c main.c 
input.o: input.c 
    gcc -c input.c 
calcu.o: calcu.c 
    gcc -c calcu.c 

clean:
    rm *.o
    rm main</code></pre> 
   <p>        上述代码中<strong>一共有 5 条规则</strong>，1~2 行为第一条规则，3~4 行为第二条规则，5~6 行为第三条规则，7~8 行为第四条规则，10~12 为第五条规则，make 命令在执行这个 Makefile 的时候其执行步骤如下：</p> 
   <p>        首先更新第一条规则中的 main，第一条规则的目标成为<strong>默认目标</strong>，<strong>只要默认目标更新了那么就完成了 Makefile 的工作</strong>，完成了整个 Makefile 就是为了完成这个工作。在第一次编译的时候由于 main 还不存在，因此第一条规则会执行，第一条规则<strong>依赖于</strong>文件 main.o、input.o和 calcu.o 这个三个.o 文件，这三个.o 文件目前还都没有，因此必须先更新这三个文件。make会查找以这三个.o 文件为目标的规则并执行。以 main.o 为例，发现更新 main.o 的是第二条规则，因此会执行第二条规则，第二条规则里面的命令为“gcc –c main.c”，这行命令很熟悉了吧，就是不链接编译 main.c，生成 main.o，其它两个.o 文件同理。最后一个规则目标是clean，它<strong>没有依赖文件</strong>，因此<strong>会默认为依赖文件都是最新的</strong>，所以其对应的命令不会执行，当我们想要执行 clean 的话可以直接使用命令“make clean”，执行以后就会删除当前目录下所有的.o 文件以及 main，因此 clean 的功能就是完成工程的清理。</p> 
   <p>        总结一下 <strong>Make 的执行过程</strong>：</p> 
   <blockquote> 
    <div>
      1) 
     <strong>make 命令</strong>会在 
     <strong>当前目录下 查找</strong>以 
     <strong>Makefile</strong>(makefile 其实也可以)命名的文件。 
    </div> 
    <div>
      2) 当找到 Makefile 文件以后就会 
     <strong>按照 </strong> 
     <strong>Makefile </strong> 
     <strong>中定义的规则</strong>去 
     <strong>编译生成最终的目标文件</strong>。 
    </div> 
    <div>
      3) 当发现目标文件 
     <strong>不存在</strong>，或者目标所依赖的文件比目标文件 
     <strong>新</strong>(也就是最后修改时间比目标文件晚) 的话就会执行后面的命令来 
     <strong>更新目标</strong>。 
    </div> 
   </blockquote> 
   <div>
             这就是 make 的执行过程，make 工具就是在 Makefile 中一层一层的查找依赖关系，并执行相应的命令。编译出最终的可执行文件。Makefile 的好处就是“自动化编译”，一旦写好了Makefile 文件，以后只需要一个 make 命令即可完成整个工程的编译， 
    <strong>极大的提高了开发效率</strong>。 
   </div> 
   <div>
              
    <div>
              总结一下，Makefile 中规则用来描述在什么情况下使用什么命令来构建一个特定的文件，这个文件就是规则的“目标”，为了生成这个“目标”而作为材料的其它文件称为“目标”的依赖，规则的命令是用来创建或者更新目标的。 
    </div> 
    <div>
              除了 Makefile 的“终极目标”所在的规则以外，其它规则的顺序在 Makefile 中是没有意义的，“终极目标”就是指在使用 make 命令的时候没有指定具体的目标时，make 默认的那个目标，它是 Makefile 文件中第一个规则的目标，如果 Makefile 中的 
     <strong>第一个规则</strong>有多个目标，那么这些目标中的 
     <strong>第一个目标</strong>就是 make 的“ 
     <strong>终极目标</strong>”。 
    </div> 
   </div> 
   <h4 id="3.4.2%C2%A0Makefile%20%E5%8F%98%E9%87%8F"><strong>3.4.2 Makefile </strong><strong>变量 </strong></h4> 
   <p>        跟 C 语言一样 Makefile 也支持变量的，先看一下前面的例子：</p> 
   <pre><code class="language-cpp">main: main.o input.o calcu.o
gcc -o main main.o input.o calcu.o</code></pre> 
   <div>
             上述 Makefile 语句中，main.o input.o 和 calcue.o 这三个依赖文件，我们输入了两遍，我们这个 Makefile 比较小，如果 Makefile 复杂的时候这种重复输入的工作就会非常费时间，而且非常容易输错，为了解决这个问题，Makefile 加入了变量支持。不像 C 语言中的变量有int、char 等各种类型， 
    <strong>Makefile 中的变量都是字符串</strong>。类似 C 语言中的宏。使用变量将上面的代码修改，修改以后如下所示： 
   </div> 
   <div> 
    <pre><code class="language-cpp">#Makefile 变量的使用
objects = main.o input.o calcu.o 
main: $(objects) 
    gcc -o main $(objects)</code></pre> 
    <p>        分析一下，第 1 行是<strong>注释</strong>，Makefile 中可以写注释，注释开头要用符号“#”。第 2 行我们<strong>定义了一个变量</strong> objects，并且给这个变量进行了<strong>赋值</strong>，其值为字符串“main.o input.o calcu.o”，第 3 和 4 行<strong>使用</strong>到了变量 objects，Makefile 中变量的<strong>引用方法</strong>是“<strong>$(变量名)</strong>”，比如本例中的“<strong>$(objects)</strong>” 就是使用变量 objects。</p> 
    <p>        Makefile 变量的赋值符有<strong>“=”</strong>，<strong>“:=”</strong>和<strong>“?=”</strong>，三种赋值符的区别：</p> 
    <p><strong>        1、赋值符“=” </strong></p> 
    <p><strong>        </strong>使用“=”在给变量的赋值的时候，不一定要用已经定义好的值，<strong>也可以使用后面定义的值</strong>，比如如下代码：</p> 
    <div> 
     <pre><code class="language-cpp">name = zzk
curname = $(name)
name = wurao

print: 
    @echo curname: $(curname)</code></pre> 
     <p>        我们来分析一下上述代码，第 1 行定义了一个变量 name，变量值为“zzk”，第 2 行也定义了一个变量 curname，curname 的变量值引用了变量 name，按照我们写 C 语言的经验此curname 的值就是“zzk”。第 3 行将变量 name 的值改为了“wurao”，第 5、6 行是输出变量 curname 的值。在 Makefile 要输出一串字符的话使用“echo”，就和 C 语言中的“printf”一样，第 6 行中的“echo”前面加了个“@”符号，因为 Make 在执行的过程中会自动输出命令执行过程，<strong>在命令前面加上“@”的话就不会输出命令执行过程</strong>，也可以测试一下不加“@” 的效果。</p> 
     <p>        使用“make”执行上述代码：</p> 
    </div> 
    <div> 
     <img alt="665e128fa1524c7e8e4e69c739518ff1.png" src="https://images2.imgbox.com/9a/27/5ZJ3Jd8A_o.png"> 
    </div> 
    <div>
               
    </div> 
    <div>
              可以看到 curname 的值不是“zzk”， 
     <strong>竟然是“wurao”</strong>，也就是变量“name”最后一次赋值的结果，这就是赋值符“=”的神奇之处。借助另外一个变量，可以将变量的真实值推到后面去定义。也就是 
     <strong>变量的真实值取决于它所引用的变量的最后一次有效值</strong>。 
    </div> 
    <div></div> 
    <p>        <strong>2、赋值符“:=” </strong></p> 
    <p>        修改代码如下：</p> 
    <pre><code class="language-cpp">name = zzk
curname := $(name) 
name = zuozhongkai

print: 
    @echo curname: $(curname)</code></pre> 
    <div>
              修改完成以后重新执行一下 Makefile，结果如下： 
    </div> 
    <div></div> 
    <div> 
     <img alt="a00b42fdab284f4fa212ec95b6381081.png" src="https://images2.imgbox.com/e4/d4/nTYuMSo5_o.png"> 
    </div> 
    <div></div> 
    <div>
              可以看到此时的 curname 是 zzk，不是 wurao了。这是因为 
     <strong>赋值符“:=”不会使用后面定义的变量，只能使用前面已经定义好的</strong>，这就是“=”和“:=”两个的区别。 
    </div> 
    <div></div> 
    <div>
               
     <strong>3、赋值符“?=” </strong> 
    </div> 
    <p>         “?=”是一个很有用的赋值符，比如下面这行代码：</p> 
    <pre><code class="language-cpp">curname ?= wurao</code></pre> 
    <div> 
     <div>
               上述代码的意思就是，如果变量 curname 前面没有被赋值，那么此变量就是“wurao”，如果前面已经赋过值了，那么就使用前面赋的值。 
     </div> 
     <div></div> 
     <div>
                
      <strong>4、变量追加“+=” </strong> 
     </div> 
     <div></div> 
    </div> 
    <div>
              Makefile 中的变量是字符串，有时候我们需要给前面已经定义好的变量添加一些字符串进去，此时就要使用到符号“+=”，比如如下所示代码： 
    </div> 
    <div> 
     <pre><code class="language-cpp">objects = main.o inpiut.o
objects += calcu.o</code></pre> 
     <p>        一开始变量 objects 的值为“main.o input.o”，后面我们给他追加了一个“calcu.o”，因此变量 objects 变成了“main.o input.o calcu.o”，这个就是变量的追加。</p> 
    </div> 
   </div> 
   <h4 id="3.4.3%C2%A0Makefile%20%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99">3.4.3 <strong>Makefile </strong><strong>模式规则</strong></h4> 
   <p>        在 3.3.2 小节中我们编写了一个 Makefile 文件用来编译工程，这个 Makefile 的内容如下：</p> 
   <pre><code class="language-cpp">main: main.o input.o calcu.o 
    gcc -o main main.o input.o calcu.o 
main.o: main.c 
    gcc -c main.c 
input.o: input.c 
    gcc -c input.c 
calcu.o: calcu.c 
    gcc -c calcu.c 

clean:
    rm *.o
    rm main</code></pre> 
   <div>
             上述 Makefile 中第 3~8 行是将对应的.c 源文件编译为.o 文件，每一个 C 文件都要写一个对应的规则， 
    <strong>如果工程中 C 文件很多的话显然</strong> 
    <strong>不能这么做</strong>。为此，我们可以使用 Makefile 中的 
    <strong>模式规则</strong>，通过模式规则我们就可以使用一条规则来将所有的.c 文件编译为对应的.o 文件。 
   </div> 
   <div></div> 
   <div>
             模式规则中， 
    <strong>至少在规则的目标定定义中要包涵“%”，否则就是一般规则，</strong>目标中的“%”表示对文件名的匹配， 
    <strong>“%”表示长度任意的非空字符串</strong>，比如“%.c”就是 
    <strong>所有的</strong>以.c 结尾的文件，类似与通配符，a.%.c 就表示以 a.开头，以.c 结束的所有文件。 
   </div> 
   <div></div> 
   <p>        <strong>当“%”出现在目标中的时候，目标中“%”所代表的值决定了依赖中的“%”值</strong>，使用方法如下：</p> 
   <blockquote> 
    <p>%.o : %.c<br> 命令</p> 
   </blockquote> 
   <p>        因此上面的 Makefile 可以改为如下形式：</p> 
   <pre><code class="language-cpp">objects = main.o input.o calcu.o
main: $(objects) 
    gcc -o main $(objects) 

%.o : %.c 
    #命令

clean: 
    rm *.o
    rm main</code></pre> 
   <p>        修改以后的 Makefile 还不能运行，因为第 6 行的命令我们还没写呢，第 6 行的命令我们需要借助另外一种强大的变量—<strong>自动化变量</strong>。</p> 
   <h4 id="3.4.4%20Makefile%20%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%98%E9%87%8F"><strong>3.4.4 Makefile </strong><strong>自动化变量</strong></h4> 
   <p>        上面讲的模式规则中，目标和依赖都是一系列的文件，每一次对模式规则进行解析的时候都会是不同的目标和依赖文件，而<strong>命令只有一行</strong>，<strong>如何通过一行命令来从不同的依赖文件中生成对应的目标呢？</strong>自动化变量就是完成这个功能的。所谓<strong>自动化变量</strong>就是这种变量<strong>会把模式中所定义的一系列的文件自动的挨个取出，直至所有的符合模式的文件都取完，</strong>自动化变量<strong>只应该出现在规则的命令中，</strong>常用的自动化变量如下表：</p> 
   <p><img alt="92f9738de1934e618485594568019a85.png" src="https://images2.imgbox.com/de/03/aLICbwhM_o.png"></p> 
   <p>         7 个自动化变量中，常用的三种：<strong>$@</strong>、<strong>$&lt;</strong> 和 <strong>$^ </strong>，我们使用自动化变量来完成上面的 Makefile，最终的完整代码如下所示：</p> 
   <pre><code class="language-cpp">objects = main.o input.o calcu.o 
main: $(objects) 
    gcc -o main $(objects)
 
%.o : %.c 
    gcc -c $&lt; 

clean: 
    rm *.o
    rm main</code></pre> 
   <div>
             上述代码代码就是修改后的完成的 Makefile，可以看出精简了很 多，核心就在于第 5、6 这两行，第 5 行使用了模式规则，第 6 行使用了自动化变量。 
   </div> 
   <h4 id="3.4.5%C2%A0Makefile%20%E4%BC%AA%E7%9B%AE%E6%A0%87"><strong>3.4.5 Makefile </strong><strong>伪目标 </strong></h4> 
   <div>
             Makefile 有一种特殊的目标——伪目标，一般的目标名都是要生成的文件，而伪目标不代表真正的目标名，在执行 make 命令的时候通过指定这个伪目标来执行其所在规则的定义的命令。 
   </div> 
   <div></div> 
   <div>
             使用伪目标的 
    <strong>主要是为了避免 Makefile 中定义的只执行命令的目标和工作目录下的实际文件出现名字冲突</strong>，有时候我们需要编写一个规则用来执行一些命令，但是这个规则不是用来创建文件的，比如在前面小节有如下代码用来完成清理工程的功能： 
   </div> 
   <div> 
    <pre><code class="language-cpp">clean:
    rm *.o
    rm main</code></pre> 
    <div>
              上述 
     <strong>规则中并没有创建文件 clean 的命令</strong>，因此工作目录下 
     <strong>永远都不会存在文件 clean</strong>，当我们输入“make clean”以后，后面的“rm *.o”和“rm main”总是会执行。可是如果我们 
     <strong>“手残”</strong>，在工作目录下创建一个名为“clean”的文件，那就不一样了，当执行“make clean”的时候，规则因为没有依赖文件，所以 
     <strong>目标被认为是最新的</strong>，因此后面的 rm 命令也就不会执行，我们预先设想的清理工程的功能也就无法完成。 
     <strong>为了避免这个问题，我们可以将 clean 声明为伪目标，</strong>声明方式如下： 
    </div> 
    <div> 
     <pre><code class="language-cpp">.PHONY : clean</code></pre> 
     <div>
               我们使用伪目标来更改Makefile，修改完成以后如下： 
     </div> 
     <div> 
      <pre><code class="language-cpp">objects = main.o input.o calcu.o 
main: $(objects) 
    gcc -o main $(objects) 

.PHONY : clean

%.o : %.c 
    gcc -c $&lt; 

clean:
    rm *.o
    rm main</code></pre> 
      <p>        上述代码第 5 行声明 clean 为伪目标，声明 clean 为伪目标以后不管当前目录下是否存在名为“clean”的文件，输入“make clean”的话规则后面的 rm 命令都会执行。</p> 
     </div> 
    </div> 
   </div> 
   <h4 id="3.4.6%C2%A0Makefile%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">3.4.6 <strong>Makefile </strong><strong>条件判断 </strong></h4> 
   <p><strong>        </strong>在 C 语言中我们通过条件判断语句来根据不同的情况来执行不同的分支，Makefile 也支持条件判断，语法有两种如下：</p> 
   <blockquote> 
    <p></p> 
    <div>
      &lt;条件关键字&gt; 
    </div> 
    <div>
              &lt;条件为真时执行的语句&gt; 
    </div> 
    <div>
      endif 
    </div> 
   </blockquote> 
   <div> 
    <div>
      以及： 
    </div> 
    <blockquote> 
     <div> 
      <div>
        &lt;条件关键字&gt; 
      </div> 
      <div>
                &lt;条件为真时执行的语句&gt; 
      </div> 
      <div>
        else 
      </div> 
      <div>
                &lt;条件为假时执行的语句&gt; 
      </div> 
      <div>
        endif 
      </div> 
     </div> 
    </blockquote> 
   </div> 
   <p>        其中<strong>条件关键字</strong>有 4 个：ifeq、ifneq、ifdef 和 ifndef，这四个关键字其实分为两对、 ifeq 与 ifneq、ifdef 与 ifndef，先来看一下 ifeq 和 ifneq，<strong>ifeq 用来判断是否相等</strong>，ifneq 就是判断是否不相等，ifeq 用法如下：     </p> 
   <blockquote> 
    <div>
      ifeq (&lt;参数 1&gt;, &lt;参数 2&gt;) 
    </div> 
    <div>
      ifeq ‘&lt;参数 1 &gt;’,‘ &lt;参数 2&gt;’ 
    </div> 
    <div>
      ifeq “&lt;参数 1&gt;”, “&lt;参数 2&gt;” 
    </div> 
    <div>
      ifeq “&lt;参数 1&gt;”, ‘&lt;参数 2&gt;’ 
    </div> 
    <div>
      ifeq ‘&lt;参数 1&gt;’, “&lt;参数 2&gt;” 
    </div> 
   </blockquote> 
   <div>
             上述用法中都是用来比较“参数 1”和“参数 2”是否相同，如果相同则为真，“参数 1”和“参数 2” 
    <strong>可以为函数返回值</strong>。ifneq 的用法类似，只不过 
    <strong>ifneq 是用来比较</strong>“参数 1”和“参数 2” 
    <strong>是否不相等</strong>，如果不相等的话就为真。 
   </div> 
   <div></div> 
   <div>
             ifdef 和 ifndef 的用法如下： 
    <blockquote> 
     <div>
       ifndef &lt;变量名&gt; 
     </div> 
    </blockquote> 
   </div> 
   <div> 
    <div>
              如果“变量名”的值非空，那么表示表达式为真，否则表达式为假。“变量名”同样可以是一个函数的返回值。ifndef 用法类似，但是含义与 ifdef 相反。 
    </div> 
   </div> 
   <h4 id="3.4.7%C2%A0Makefile%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8"><strong>3.4.7 Makefile </strong><strong>函数使用 </strong></h4> 
   <div>
             Makefile 支持函数，类似 C 语言一样，Makefile 中的函数 
    <strong>是已经定义好的</strong>，我们直接使用， 
    <strong>不支持我们自定义函数</strong>。make 所支持的函数不多，但是绝对够我们使用了，函数的用法如下： 
   </div> 
   <blockquote> 
    <div>
      $(函数名 参数集合) 
    </div> 
   </blockquote> 
   <p>或者</p> 
   <blockquote> 
    <div>
      ${函数名 参数集合} 
    </div> 
   </blockquote> 
   <div> 
    <div>
              可以看出，调用函数和调用普通变量一样，使用符号“$”来标识。 
     <strong>参数集合</strong>是函数的多个参数，参数之间以逗号“ 
     <strong>,</strong>”隔开，函数名和参数之间以“空格”分隔开，函数的调用以“$”开头。接下来我们介绍几个常用的函数，其它的函数大家可以参考《跟我一起写 Makefile》这份文档。 
    </div> 
   </div> 
   <div>
              
   </div> 
   <div> 
    <div> 
     <strong>        1、函数 subst </strong> 
    </div> 
   </div> 
   <div></div> 
   <div>
             函数 subst 用来完成字符串替换，调用形式如下： 
    <blockquote> 
     <div>
       $(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;) 
     </div> 
    </blockquote> 
   </div> 
   <div> 
    <div>
              此函数的功能是 
     <strong>将字符串&lt;text&gt;中的&lt;from&gt;内容替换为&lt;to&gt;，函数返回被替换以后的字符串</strong>，比如如下示例： 
    </div> 
    <blockquote> 
     <div>
       $(subst wurao,man,my name is wurao) 
     </div> 
    </blockquote> 
    <div>
              把字符串“my name is wurao”中的“wurao”替换为“man”，替换完成以后的字符串为“my name is man”。 
    </div> 
    <div></div> 
    <div>
               
     <strong>2、函数 patsubst </strong> 
    </div> 
    <div> 
     <div>
               函数 patsubst 用来完成模式字符串替换，使用方法如下： 
     </div> 
     <blockquote> 
      <div>
        $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;) 
      </div> 
     </blockquote> 
    </div> 
    <div>
              此函数 
     <strong>查找字符串&lt;text&gt;中的单词是否符合模式&lt;pattern&gt;，如果匹配就用&lt;replacement&gt;来替换掉</strong>，&lt;pattern&gt;可以使用包括通配符“%”，表示任意长度的字符串，函数返回值就是替换后的字符串。如果&lt;replacement&gt;中也包涵“%”，那么&lt;replacement&gt;中的“%”将是&lt;pattern&gt;中的那个“%”所代表的字符串，比如： 
    </div> 
    <blockquote> 
     <div> 
      <div>
        $(patsubst %.c,%.o,a.c b.c c.c) 
      </div> 
     </div> 
    </blockquote> 
    <div>
              将字符串“a.c b.c c.c”中的所有符合“%.c”的字符串，替换为“%.o”，替换完成以后的字符串为“a.o b.o c.o”。 
    </div> 
    <div></div> 
    <div>
               
     <strong>3、函数 dir </strong> 
    </div> 
    <div> 
     <div>
               函数 dir 用来获取目录，使用方法如下： 
     </div> 
     <blockquote> 
      <div>
        $(dir &lt;names…&gt;) 
      </div> 
     </blockquote> 
     <div>
               此函数用来 
      <strong>从文件名序列&lt;names&gt;中提取出目录部分</strong>，返回值是文件名序列&lt;names&gt;的目录部分，比如： 
     </div> 
     <blockquote> 
      <div>
        $(dir &lt;/src/a.c&gt;) 
      </div> 
     </blockquote> 
     <div>
               提取文件“/src/a.c”的目录部分，也就是“/src”。 
     </div> 
     <div></div> 
     <div>
                
      <strong>4、函数 notdir </strong> 
     </div> 
     <div></div> 
     <div> 
      <div>
                函数 notdir 看名字就是知道去除文件中的目录部分，也就是提取文件名，用法如下： 
      </div> 
     </div> 
     <div></div> 
     <blockquote> 
      <div> 
       <div>
         $(notdir &lt;names…&gt;) 
       </div> 
      </div> 
     </blockquote> 
     <div> 
      <div>
                此函数用于 
       <strong>从文件名序列&lt;names&gt;中提取出文件名非目录部分</strong>，比如： 
      </div> 
      <blockquote> 
       <div> 
        <div>
          $(notdir &lt;/src/a.c&gt;) 
        </div> 
       </div> 
      </blockquote> 
     </div> 
     <div> 
      <div>
                提取文件“/src/a.c”中的非目录部分，也就是文件名“a.c”。 
      </div> 
      <div></div> 
      <div>
                 
       <strong>5、函数 foreach</strong> 
       <div>
                 foreach 函数用来完成循环，用法如下： 
       </div> 
       <blockquote> 
        <div>
          $(foreach &lt;var&gt;, &lt;list&gt;,&lt;text&gt;) 
        </div> 
       </blockquote> 
       <div> 
        <div>
                  此函数的意思就是 
         <strong>把参数&lt;list&gt;中的单词逐一取出来放到参数&lt;var&gt;中，然后再执行&lt;text&gt; 所包含的表达式</strong>。每次&lt;text&gt;都会返回一个字符串，循环的过程中，&lt;text&gt;中所包含的每个字符串会以空格隔开，最后当整个循环结束时，&lt;text&gt;所返回的每个字符串所组成的整个字符串将会是函数 foreach 函数的返回值。 
        </div> 
       </div> 
       <div>
                  
        <div> 
         <strong>        6、函数 wildcard </strong> 
        </div> 
        <div>
                  通配符“%”只能用在规则中，只有在规则中它才会展开， 
         <strong>如果在变量定义和函数使用时，通配符不会自动展开</strong>，这个时候就要用到函数 wildcard，使用方法如下： 
        </div> 
        <blockquote> 
         <div>
           $(wildcard PATTERN…) 
         </div> 
        </blockquote> 
        <div>
          比如： 
        </div> 
        <blockquote> 
         <div>
           $(wildcard *.c) 
         </div> 
        </blockquote> 
       </div> 
       <div> 
        <div>
                  上面的代码是用来获取当前目录下所有的.c 文件，类似“%”。 
        </div> 
       </div> 
       <div></div> 
       <div>
                  
        <div>
                  本节只是对 Makefile 做了最基本的讲解，确保能够完成后续的学习，Makefile 还有大量的知识没有提到，有兴趣的可以自行参考《跟我一起写 Makefile》这份文档来深入学习 Makefile。 
        </div> 
       </div> 
       <div></div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <h2 id="%E6%9C%AC%E7%AF%87%E6%80%BB%E7%BB%93">本篇总结</h2> 
   <p>        重点是各种<strong>shell命令</strong>的使用和<strong>Makefile</strong>。</p> 
   <p>        shell多敲就会了，Makefile多学习几个例子便熟悉了。</p> 
   <p>       </p> 
   <p></p> 
  </div> 
 </div> 
</div> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3ce1961c9866adb962d11b5a04ebd17a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">envi神经网络分类原理,ENVI神经网络分类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b16ad29be78ec74fc187252ccd5b449d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">01_Linux 下的应用程序是如何调用驱动程序的?</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>