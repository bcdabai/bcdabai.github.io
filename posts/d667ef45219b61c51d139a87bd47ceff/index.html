<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>链路追踪、配置中心 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="链路追踪、配置中心" />
<meta property="og:description" content="1.链路追踪 在一次调用链路中，可能设计到多个微服务，如果在线上，某个微服务出现故障，如何快速定位故障所在额微服务呢。可以使用链路追踪技术。
1.1链路追踪介绍 在大型系统的微服务化构建中，一个系统被拆分成了许多微服务。这些模块负责不同的功能，组合成系统，最终可以提供丰富的功能。在这种架构中，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心【区域】，也就意味着这种架构形式也会存在一些问题：
l 如何快速发现问题？
l 如何判断故障影响范围？
l 如何梳理服务依赖？
l 如何分析链路性能问题以及实时容量规划
分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行==日志记录==，==性能监控==并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上IP、每个服务节点的请求状态200 500等等。 1.2 链路追踪使用的组件由哪些? 1.cat 由大众点评开源，基于Java开发的实时应用监控平台，包括实时应用监控，业务监控 。 集成 方案是通过代码埋点的方式来实现监控，比如： 拦截器，过滤器等。 对代码的侵入性很大，集成成本较高。风险较大。
2.pinpoint Pinpoint是韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点 是支持多种插件，UI功能强大，接入端无代码侵入。 你开源
3.skywalking 【未来企业会使用的多】
SkyWalking是本土开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多
种插件，UI功能较强，接入端无代码侵入。目前已加入Apache孵化器--开源。
4.Sleuth **（日志记录每一条链路上的所有节点，以及这些节点所在的机器，和耗时。）
zipkin** 由Twitter公司开源，开放源代码分布式的跟踪系统，用于收集服务的定时数据，以解决微 服务架构中的延迟问题，包括：==数据的收集、存储、查找和展现《图形化》==。该产品结合spring-cloud-sleuth 使用较为简单， 集成很方便， 但是功能较简单。
SpringCloud 提供的分布式系统中链路追踪解决方法
1.3 介绍sleuth springCloud Sleuth主要功能就是在分布式系统中提供追踪解决方案。它大量借用了Google Dapper的设计， 先来了解一下Sleuth中的术语和相关概念。
*1.Trace* *(一条完整链路--包含很多span(微服务接口))*
由一组Trace Id（贯穿整个链路）相同的Span串联形成一个树状结构。为了实现请求跟踪，当请求到达分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的标识（即TraceId），同时在分布式系统内部流转的时候，框架始终保持传递该唯一值，直到整个请求的返回。那么我们就可以使用该唯一标识将所有的请求串联起来，形成一条完整的请求链路。
*2.Span*
代表了一组基本的工作单元。为了统计各处理单元的延迟，当请求到达各个服务组件的时候，也通过一个唯一标识（SpanId）来标记它的开始、具体过程和结束。通过SpanId的开始和结束时间戳，就能统计该span的调用时间，除此之外，我们还可以获取如事件的名称。请求信息等元数据。
*3. Annotation*
用它记录一段时间内的事件，内部使用的重要注释：
l cs（Client Send）客户端发出请求，开始一个请求的命令
l sr（Server Received）服务端接受到请求开始进行处理， sr－cs = 网络延迟（服务调用的时间）
l ss（Server Send）服务端处理完毕准备发送到客户端，ss - sr = 服务器上的请求处理时间" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d667ef45219b61c51d139a87bd47ceff/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-19T09:46:32+08:00" />
<meta property="article:modified_time" content="2023-05-19T09:46:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">链路追踪、配置中心</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.链路追踪</h2> 
<p>在一次调用链路中，可能设计到多个微服务，如果在线上，某个微服务出现故障，如何快速定位故障所在额微服务呢。可以使用链路追踪技术。</p> 
<h3>1.1<strong>链路追踪介绍</strong></h3> 
<p>        在大型系统的微服务化构建中，一个系统被拆分成了许多微服务。这些模块负责不同的功能，组合成系统，最终可以提供丰富的功能。在这种架构中，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心【区域】，也就意味着这种架构形式也会存在一些问题：</p> 
<blockquote> 
 <p>l 如何快速发现问题？</p> 
 <p>l 如何判断故障影响范围？</p> 
 <p>l 如何梳理服务依赖？</p> 
 <p>l 如何分析链路性能问题以及实时容量规划</p> 
</blockquote> 
<p><img alt="" height="651" src="https://images2.imgbox.com/c5/e1/Rj93MKGv_o.png" width="1073"></p> 
<blockquote> 
 <p>        分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行==日志记录==，==性能监控==并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上IP、每个服务节点的请求状态200 500等等。  </p> 
</blockquote> 
<h3>1.2 链路追踪使用的组件由哪些?</h3> 
<blockquote> 
 <p><strong>1.cat</strong> 由大众点评开源，基于Java开发的实时应用监控平台，包括实时应用监控，业务监控 。 集成 方案是通过代码埋点的方式来实现监控，比如： 拦截器，过滤器等。 对代码的侵入性很大，集成成本较高。风险较大。</p> 
 <p><strong>2.pinpoint</strong> Pinpoint是韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点 是支持多种插件，UI功能强大，接入端无代码侵入。 你开源</p> 
 <p><strong>3.skywalking</strong> <strong>【未来企业会使用的多】</strong></p> 
 <p>SkyWalking是本土开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多</p> 
 <p>种插件，UI功能较强，接入端无代码侵入。目前已加入Apache孵化器--开源。</p> 
 <p></p> 
 <p><strong>4.Sleuth</strong> **（日志记录每一条链路上的所有节点，以及这些节点所在的机器，和耗时。）</p> 
 <ol><li> <p>zipkin** 由Twitter公司开源，开放源代码分布式的跟踪系统，用于收集服务的定时数据，以解决微 服务架构中的延迟问题，包括：==数据的收集、存储、查找和展现《图形化》==。该产品结合spring-cloud-sleuth 使用较为简单， 集成很方便， 但是功能较简单。</p> </li></ol> 
 <p>SpringCloud 提供的分布式系统中链路追踪解决方法</p> 
</blockquote> 
<h3>1.3 介绍sleuth</h3> 
<blockquote> 
 <p>springCloud Sleuth主要功能就是在分布式系统中提供追踪解决方案。它大量借用了Google Dapper的设计， 先来了解一下Sleuth中的术语和相关概念。</p> 
 <p><strong><em>*1.Trace*</em></strong> <strong><em>*(一条完整链路--包含很多span(微服务接口))*</em></strong></p> 
 <p>由一组Trace Id（贯穿整个链路）相同的Span串联形成一个树状结构。为了实现请求跟踪，当请求到达分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的标识（即TraceId），同时在分布式系统内部流转的时候，框架始终保持传递该唯一值，直到整个请求的返回。那么我们就可以使用该唯一标识将所有的请求串联起来，形成一条完整的请求链路。</p> 
 <p><strong><em>*2.Span*</em></strong></p> 
 <p>代表了一组基本的工作单元。为了统计各处理单元的延迟，当请求到达各个服务组件的时候，也通过一个唯一标识（SpanId）来标记它的开始、具体过程和结束。通过SpanId的开始和结束时间戳，就能统计该span的调用时间，除此之外，我们还可以获取如事件的名称。请求信息等元数据。</p> 
 <p><strong><em>*3. Annotation*</em></strong></p> 
 <p>用它记录一段时间内的事件，内部使用的重要注释：</p> 
 <p>l cs（Client Send）客户端发出请求，开始一个请求的命令</p> 
 <p>l sr（Server Received）服务端接受到请求开始进行处理， sr－cs = 网络延迟（服务调用的时间）</p> 
 <p>l ss（Server Send）服务端处理完毕准备发送到客户端，ss - sr = 服务器上的请求处理时间</p> 
 <p>l cr（Client Reveived）客户端接受到服务端的响应，请求结束。 cr - cs = 请求的总时</p> 
</blockquote> 
<h3>1.4 如何使用sleuth</h3> 
<p>在每一个微服务中引入相关依赖就可以。也可以在父工程引入相关依赖直接用于子工程</p> 
<pre><code class="language-XML">    &lt;!--父工程下引用--&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre> 
<p>  启动微服务，调用之后，我们可以在控制台观察到sleuth的日志输出</p> 
<p><img alt="" height="146" src="https://images2.imgbox.com/e5/16/1l3ObAzl_o.png" width="1200"></p> 
<blockquote> 
 <p> <strong>思考</strong>: 我们可以通过sleuth的日志，观察每个微服务执行的时间。但是这样会非常麻烦。能否把这些sleuth生成的日志，以图形化的形式展示。--我们可以使用zipkin来搜集sleuth生成的日志，并以图形化展示。</p> 
</blockquote> 
<h3> 1.5 zipkin介绍</h3> 
<p>Zipkin 是 Twitter 的一个开源项目，它基于Google Dapper实现，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的<strong>收集、存储展现、查找和</strong>我们可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的REST API接口来辅助我们查询跟踪数据以实现对分布式系统的监控程序，从而及时地发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源</p> 
<p>除了面向开发的 API 接口之外，它也提供了方便的UI组件来帮助我们直观的搜索跟踪信息和分析请求链路明细，比如：可以查询某段时间内各用户请求的处理时间等。</p> 
<p>Zipkin 提供了可插拔数据存储方式：In-Memory、MySql、Cassandra 以及 Elasticsearch。</p> 
<p><img alt="" height="631" src="https://images2.imgbox.com/bb/36/3cofqTJU_o.png" width="1079"></p> 
<blockquote> 
 <p>从上面的图可以看出zipkin需要一个服务端，而每个微服务就是客户端。  </p> 
</blockquote> 
<h3>1.6 启动zipkin服务器</h3> 
<p> （1）下载zipkin<img alt="" height="692" src="https://images2.imgbox.com/87/12/SCd7w6Xa_o.png" width="1200"></p> 
<p> （2）启动zipkin</p> 
<p>在zipkin的jar包目录下输入cmd进入黑窗口然后输入java -jar jar包名</p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/ce/cc/LT8Tf1Zp_o.png" width="1103"></p> 
<p> <img alt="" height="681" src="https://images2.imgbox.com/af/25/0kFFt53k_o.png" width="1170"></p> 
<p>（3）微服务接入zipkin服务端  </p> 
<p>  父工程引入相关依赖</p> 
<pre><code class="language-XML">   &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre> 
<p>（4）每个微服务接入zipkin服务端--配置文件</p> 
<pre><code class="language-XML">#zipkin服务端的地址
spring.zipkin.base-url=http://localhost:9411/</code></pre> 
<p>（5）访问一个链路</p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/c9/d3/ZqCdUSh7_o.png" width="1003"></p> 
<p><img alt="" height="723" src="https://images2.imgbox.com/d6/d0/U3LeIr90_o.png" width="1200"></p> 
<h2>2. 配置中心</h2> 
<blockquote> 
 <p><strong>思考</strong>: 商品微服务--搭建n个集群---它的配置一模一样。如果修改某个配置内容。你需要给每个微服务都要修改配置内容 商品微服务和订单微服务他们之间有没有公共配置。---需要对每个微服务都要修改</p> 
 <p>使用配置中心来管理每个微服务的配置文件。</p> 
</blockquote> 
<h3>2.1 哪些组件可以作为配置中心</h3> 
<blockquote> 
 <p>l <strong>Apollo*</strong>*------&gt;很多使用apollo**</p> 
 <p>Apollo是由携程开源的分布式配置中心。特点有很多，比如：配置更新之后可以实时生效，支持灰度发布功能，并且能对所有的配置进行版本管理、操作审计等功能，提供开放平台API。并且资料 也写的很详细。</p> 
 <p>l <strong>Disconf</strong></p> 
 <p>Disconf是由百度开源的分布式配置中心。它是基于Zookeeper来实现配置变更后实时通知和生效的。</p> 
 <p>l <strong>SpringCloud Config</strong></p> 
 <p>这是Spring Cloud中带的配置中心组件。它和Spring是无缝集成，使用起来非常方便，并且它的配置存储支持Git。不过它没有可视化的操作界面，配置的生效也不是实时的，需要重启或去刷新。</p> 
 <p>l <strong>Nacos</strong></p> 
 <p>这是SpingCloud alibaba技术栈中的一个组件，前面我们已经使用它做过服务注册中心。其实它也集成了服务配置的功能，我们可以直接使用它作为服务配置中心</p> 
</blockquote> 
<p>(1）在nacos配置中心创建微服务配置文件  </p> 
<p><img alt="" height="946" src="https://images2.imgbox.com/dc/10/iDEkzMF2_o.png" width="1200"></p> 
<p>（2）微服务使用配置中心中指定配置文件 --子工程</p> 
<pre><code class="language-XML">        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre> 
<p> （3）创建一个bootstrap.properties配置文件</p> 
<pre><code class="language-XML">#微服务的名称
spring.application.name=product
#指定配置中心的地址
spring.cloud.nacos.server-addr=192.168.28.252:8849,192.168.28.252:8850,192.168.28.252:8851</code></pre> 
<p>（4）在controller验证读取到配置中的内容</p> 
<pre><code class="language-java">  @Value("${student.name}") //读取配置文件中student.name的的属性值
    private String name;

    @GetMapping("getInfo")
    public String getInfo(){
        return name;
    }</code></pre> 
<p><img alt="" height="284" src="https://images2.imgbox.com/11/25/F8T2eTeO_o.png" width="894"></p> 
<p> <img alt="" height="903" src="https://images2.imgbox.com/dc/51/KNGyKA8G_o.png" width="1200"></p> 
<blockquote> 
 <p>bootstrap和application的区别</p> 
 <p>        bootstrap和application都是SpringBoot项目中的配置文件,他们的区 别主要有以下的几个方面：</p> 
 <p>(1)加载顺序区别 bootstrap配置文件是比application配置文件优先加载的,因为 bootstrap是由spring父上下文加载,而application是由子上下文加载</p> 
 <p></p> 
 <p>(2)优先级区别 bootstrap加载的配置信息是不能被application的相同配置覆盖的,如 果两个配置文件同时存在,也是以bootstrap为主</p> 
 <p></p> 
 <p>(3)应用场景区别 bootstrap常见应用场景</p> 
 <p>1.配置一些固定的,不能被覆盖的属性.用于一些系统级别的参数配置 本地的配置文件是默认不能覆盖远程的配置的</p> 
 <p>2.一些需要加密/解密的场景</p> 
 <p>3.当你使用了nacos配置中心时,这时需要在boostrap配置文件中添加 连接到配置中心的配置属性来加载外部配置中心的配置信息,专业翻译 如下</p> 
</blockquote> 
<p><img alt="" height="349" src="https://images2.imgbox.com/d9/76/43xpO7p5_o.png" width="722"> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/74ed0c3a0a02fe6ef37055108911fe07/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java通过FTPClient实现文件在指定文件夹的上传下载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cbd5af041af3722d21be0d9bfe691654/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue input 如何限制输入框输入空格</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>