<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>音频处理-2 WAV格式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="音频处理-2 WAV格式" />
<meta property="og:description" content="后续要将流量中的音频数据转为WAV格式文件，所以本节重点说下WAV格式。
WAV文件是在PC机平台上很常见的、最经典的多媒体音频文件,最早于1991年8月出现在Windows 3.1操作系统上,文件扩展名为WAV,是WaveFom的简写,也称为波形文件,可直接存储声音波形,还原的波形曲线十分逼真。WAV文件格式简称WAV格式是一种存储声音波形的数字音频格式,是由微软公司和IBM联合设计的,经过了多次修订,可用于Windows,Macintosh,Linix等多种操作系统,详述如下。
1 波形文件的存储过程 声源发出的声波通过话筒被转换成连续变化的电信号,经过放大、抗混叠滤波后,按固定的频率进行采样,每个样本是在一个采样周期内检测到的电信号幅度值;接下来将其由模拟电信号量化为由二进制数表示的积分值;最后编码并存储为音频流数据。有的应用为了节省存储空间,存储前,还要对采样数据先进行压缩。
2 WAV文件的编码 编码包括了两方面内容,一是按一定格式存储数据,二是采用一定的算法压缩数据。WAV格式对音频流的编码没有硬性规定,支持非压缩的PCM(Puls Code Modulation)脉冲编码调制格式,还支持压缩型的微软自适应分脉冲编码调制Microsoft ADPCM(Adaptive Differential Puls Code Modulation)、国际电报联盟(International Telegraph Union)制定的语音压缩标准ITUG.711 a-law、ITU G.711-law、IMA ADPCM、ITU G.723 ADPCM (Yamaha)、GSM 6.10、ITU G.721 ADPCM编码和其它压缩算法。MP3编码同样也可以运用在WAV中,只要安装相应的Decode,就可以播放WAV中的MP3音乐。
下面详细介绍一下 WAV 格式文件常见的10种压缩码形式 (Compression Code)。
2.1 PCM/uncompressed Pulse Code Modulation ，脉码调制信号。是模拟音频信号经模数转换（A/D 变换）直接形成的二进制序列，该文件没有附加的文件头和文件结束标志。 Windows的Convert工具可以把PCM音频格式的文件转换成 Microsoft 的 WAV 格式的文件。
PCM 脉码调制数字音频格式是 70 年代末发展起来的， 80年代初由飞利浦和索尼公司共同推出。 PCM 的音频格式也被 DVD-A 所采用，它支持立体声和 5.1 环绕声， 1999 年由DVD 讨论会发布和推出的。
PCM 的采样精度从14bit发展到16bit 、18bit 、20bit 直到 24bit ；采样频率从 44.1kHz发展到 192kHz 。到目前为止 PCM 这种单纯依赖提高采样规格的技术，其可改进的地方已经越来越来小。只是简单的增加 PCM 比特率和采样率，不能从底层改善它的根本问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/14ecb2c5b9c7d90ec24be2778130ca14/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-20T13:12:50+08:00" />
<meta property="article:modified_time" content="2022-01-20T13:12:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">音频处理-2 WAV格式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>后续要将流量中的音频数据转为WAV格式文件，所以本节重点说下WAV格式。</p> 
</blockquote> 
<p>WAV文件是在PC机平台上很常见的、最经典的多媒体音频文件,最早于1991年8月出现在Windows 3.1操作系统上,文件扩展名为WAV,是WaveFom的简写,也称为波形文件,可直接存储声音波形,还原的波形曲线十分逼真。WAV文件格式简称WAV格式是一种存储声音波形的数字音频格式,是由微软公司和IBM联合设计的,经过了多次修订,可用于Windows,Macintosh,Linix等多种操作系统,详述如下。</p> 
<h2><a id="1__4"></a>1 波形文件的存储过程</h2> 
<p>声源发出的声波通过话筒被转换成连续变化的电信号,经过放大、抗混叠滤波后,按固定的频率进行采样,每个样本是在一个采样周期内检测到的电信号幅度值;接下来将其由模拟电信号量化为由二进制数表示的积分值;最后编码并存储为音频流数据。有的应用为了节省存储空间,存储前,还要对采样数据先进行压缩。</p> 
<h2><a id="2__WAV_7"></a>2 WAV文件的编码</h2> 
<p>编码包括了两方面内容,一是按一定格式存储数据,二是采用一定的算法压缩数据。WAV格式对音频流的编码没有硬性规定,支持非压缩的PCM(Puls Code Modulation)脉冲编码调制格式,还支持压缩型的微软自适应分脉冲编码调制Microsoft ADPCM(Adaptive Differential Puls Code Modulation)、国际电报联盟(International Telegraph Union)制定的语音压缩标准ITUG.711 a-law、ITU G.711-law、IMA ADPCM、ITU G.723 ADPCM (Yamaha)、GSM 6.10、ITU G.721 ADPCM编码和其它压缩算法。MP3编码同样也可以运用在WAV中,只要安装相应的Decode,就可以播放WAV中的MP3音乐。</p> 
<p>下面详细介绍一下 WAV 格式文件常见的10种压缩码形式 (Compression Code)。</p> 
<h3><a id="21_PCMuncompressed_13"></a>2.1 PCM/uncompressed</h3> 
<p>Pulse Code Modulation ，脉码调制信号。是模拟音频信号经模数转换（A/D 变换）直接形成的二进制序列，该文件没有附加的文件头和文件结束标志。 Windows的Convert工具可以把PCM音频格式的文件转换成 Microsoft 的 WAV 格式的文件。</p> 
<p>PCM 脉码调制数字音频格式是 70 年代末发展起来的， 80年代初由飞利浦和索尼公司共同推出。 PCM 的音频格式也被 DVD-A 所采用，它支持立体声和 5.1 环绕声， 1999 年由DVD 讨论会发布和推出的。</p> 
<p>PCM 的采样精度从14bit发展到16bit 、18bit 、20bit 直到 24bit ；采样频率从 44.1kHz发展到 192kHz 。到目前为止 PCM 这种单纯依赖提高采样规格的技术，其可改进的地方已经越来越来小。只是简单的增加 PCM 比特率和采样率，不能从底层改善它的根本问题。</p> 
<h3><a id="22_Microsoft_ADPCM_20"></a>2.2 Microsoft ADPCM</h3> 
<p>Adaptive Differential Pulse Code Modulation ，自适应差分脉码调制信号。是一种数据压缩算法， 该算法利用了语音信号样点间的相关性， 并针对语音信号的非平稳特点， 使用了自适应预测和自适应量化。即对不同水平的差分序列，用一个相应参数 delta 作为平稳化参数去除差分序列的幅值，使得差分编码自动的适应数据间大幅度的跳跃。</p> 
<p>Microsoft ADPCM 是微软标准的 WAV 格式文件采用 ADPCM 编码的文件， 区分于 IMA ADPCM 文件。MS-ADPCM 编码是分块的， 每块有块头信息和编码数据。 对单声道信号，每块由 7 个字节组成， byte0 是块预测器 predictor ， byte1-2 是初始 delta ，byte3-4 和 byte5-6 分别是两个采样。</p> 
<h3><a id="23_ITU_G711_alaw_25"></a>2.3 ITU G.711 a-law</h3> 
<p>G.711 标准也是 PCM 码的一种。是国际电报联盟 (International Telegraph Union, ITU)订定出来的一套语音压缩标准，主要用于电话。它主要用脉冲编码调制对音频采样，采样率为 8kHz 。它利用一个 64kbit/s 未压缩通道传输语音讯号。起压缩率为 1:2 ，即把16位数据压缩成 8 位。 G.711是主流的波形声音编解码器。</p> 
<p>G.711 标准下主要有两种压缩算法。一种是 μ-law algorithm （又称 μ-law ），主要运用于北美和日本；另一种就是 a-law algorithm ，主要运用于欧洲和世界其他地区。其中， a-law 是特别设计用来方便<strong>计算机</strong>处理的。</p> 
<h3><a id="24_ITU_G711_law_30"></a>2.4 ITU G.711 μ-law</h3> 
<p>G.711 标准下的另一种压缩算法，主要运用于北美和日本，美国电话格式 (CCITT G.711) 就采用这种算法。</p> 
<h3><a id="25__IMA__ADPCM_33"></a>2.5 IMA ADPCM</h3> 
<p>IMA是ADPCM 中使用较多的一种算法。该算法中对量化步长的调整使用了简单的查表方法，对于一个输入的 PCM 值 X(n) ，将其与前一时刻的 X(n-1) 预测值做差值得到 d(n) ，然后根据当前的量化步长对 d(n) 进行编码，再用此 sample 点的编码值调整量化步长，同时还要得到当前 sample 点的预测值供下一 sample 点编码使用。通过此算法可将样点编码成4bit 的码流，一个符号位和三个幅度位。该算法较简单，通过查表简化了运算。编码后采用WAV 文件格式，对编码后的数据流进行了包装，由文件头和数据码流组成，文件头和标准WAV 格式文件一样，指出了音频数据所采用格式、采样率、比特率、块长度、比特数及声道数等信息。数据码流以块为单位，块头指出了该块起始的预测值和 index 值，码流中每 byte 的高四位和低四位分别对应一个 PCM 。当前该算法以其简单实用的特点广泛应用到数字音乐盒和数字录音笔中。</p> 
<h3><a id="26_ITU_G723_ADPCM_Yamaha_36"></a>2.6 ITU G.723 ADPCM (Yamaha)</h3> 
<p>G.723是ITU在1996 年制订成型的一种多媒体语音编解码标准。其典型应用包括 VoIP 服务、 H.324 视频电话、无线电话、数字卫星系统、数电倍增设备 (DCME) 、公共交换电话网 (PSTN) 、 ISDN 及各种多媒体语音信息产品。 G.723 标准传输码率有 5.3kbit/s 和 6.3kbit/s 两种，在编程过程中可随时切换。该标准主要包含了编码算法和解码算法。</p> 
<p>原理是：从采集的语音信号中解析出声道模型参数，构造一个合成滤波器，采用合适的激励源激励,编码传输的参数主要是激励源与合成滤波器的参数。 5.3kbit/s 的编码器采用代数码线预测激励（ACELP）；6.3kb/s 的编码器则采用多脉冲最大似然量化 (MP-MLQ) 激励。根据传输编码参数 ,可重构激励源与合成滤波器进行解码 ,还原出来的数字语音信号经 D/A 转换器转换成模拟语音信号。</p> 
<p>G.723 算法对语音信号有很好的编解码效果，同时也可处理音乐和其它声音信号 ,典型输入是 64kb/s(8k ×8)或 128kbit/s(8k ×16) 的 A-law 或 μ-law 的 PCM 采样语音信号。 每次处理一帧语音信号 ,每帧 240 个采样点 (30ms) 。在 5.3kbit/s 的码率下，每帧语音被压缩成 20个字节传输；在 6.3kbit/s 的码率下，每帧语音被压缩成 24 个字节传输。</p> 
<h3><a id="27_GSM_610_43"></a>2.7 GSM 6.10</h3> 
<p>是我们熟知的全球移动通讯系统 (Global System for Mobile communications) 定义的一种音频编解码标准。 广泛应用于无线通信设备如手机、 无线通讯终端中。 音频信号被压缩至介于 5.6kbit/s 和 13kbit/s 之间，这两种码率被分别叫做半率 (Half Rate) 和全率 (Full Rate)，最初大部分只有这两种码率的编码。编码基于线性预测编码算法 (Linear Predictive Coding, LPC) 。</p> 
<p>GSM 6.10 除了在比特率上有很出色的表现外， 这种编码的音频信号在空气信道中传输有着高保真度，因此广泛使用在无线通信设备的语音信号中。在1997年，GSM 进一步开发出了一种增强型全率编解码器 (Enhanced Full Rate, EFR) ，这种编码码流比特率为 12.2kbit/s 。</p> 
<h3><a id="28_ITU_G721_ADPCM_48"></a>2.8 ITU G.721 ADPCM</h3> 
<p>G.721 是 ITU-T 定义的一组标准协议组 G.7xx 其中之一，指的是 32kbit/s 的自适应差分脉冲编码调制 (ADPCM) 。除去上面介绍的三种，此协议组的其他码流标准如下：</p> 
<ul><li>G.722 ―― 64 kb/s 下的 7 kHz 音频编码</li><li>G.722.1 ―― 带有低帧损耗的具有免提操作的系统在 24kbit/s 和 32kbit/s 上的编码</li><li>G.722.2 ―― 利用自适应多频率宽带 (AMR-WB) 以 16kbit/s 多频率语音编码</li><li>G.726 ―― 40, 32, 24, 16kbit/s 自适应差分脉冲编码调制 (ADPCM)</li><li>G.727 ―― 5, 4, 3 和 2bit/s 嵌入式自适应差分脉冲编码调制 (ADPCM)</li><li>G.728 ―― 利用低延迟代码线性预测以 16 bit/s 进行语音编码</li><li>G.729 ―― 利用共扼结构－代数激励编码线性预测 (CS-ACELP) 以 8bit/s 进行语音编码</li></ul> 
<h3><a id="29_MPEG_58"></a>2.9 MPEG</h3> 
<p>Moving Pictures Experts Group ，动态图像专家组。 MPEG 是世界上最为著名的一种音视频压缩标准之一。 MPEG 标准主要有以下五个， MPEG-1 、MPEG-2 、MPEG-4 、MPEG-7 及 MPEG-21 等。该专家组建于 1988 年，专门负责为 CD 建立视频和音频标准，而成员都是为视频、 音频及系统领域的技术专家。 及后， 他们成功将声音和影像的记录脱离了传统的模拟方式， 建立了 ISO/IEC1172 压缩编码标准， 并制定出 MPEG- 格式， 令视听传播方面进入了数码化时代。因此，大家现时泛指的 MPEG-X 版本，就是由 ISO(International Organization for Standardization) 所制定而发布的视频、音频、数据的压缩标准。</p> 
<p>MPEG 标准的视频压缩编码技术主要利用了具有运动补偿的帧间压缩编码技术以减小时间冗余度，利用 DCT 技术以减小图像的空间冗余度，利用熵编码则在信息表示方面减小了统计冗余度。这几种技术的综合运用，大大增强了压缩性能。</p> 
<p>我们熟知的 MP3 格式的音频文件，就是 MPEG-1 layer3 的缩写。</p> 
<h3><a id="210_Experimental_65"></a>2.10 Experimental</h3> 
<p>称为实验性音频。 专门用来作音频信号处理的研究开发工作， 主要包括优化压缩算法提高压缩效率的工作。 这种类型的压缩码流基本不被主流解码器支持， 只在一些音频专家和发烧友的实验室里能够流畅的播放出来。</p> 
<p>Compression code 信息在WAV文件字段的第 21、22 个 byte ，通过十六进制查看器我们可以看到一个 WAV文件的压缩码类型。对应关系如下表：</p> 
<p>WAV文件遵循RIFF规则，其内容以区块（chunk）为最小单位进行存储。所以先要了解什么是RIFF。</p> 
<h2><a id="3_RIFF_71"></a>3 RIFF</h2> 
<p>RIFF全称为资源互换文件格式（Resources Interchange File Format），是Windows下大部分多媒体文件遵循的一种文件结构。RIFF文件所包含的数据类型由该文件的扩展名来标识，能以RIFF格式存储的数据有：</p> 
<ul><li>音频视频交错格式数据 .AVI</li><li>波形格式数据 .WAV</li><li>位图数据格式 .RDI</li><li>MIDI格式数据 .RMI</li><li>调色板格式 .PAL</li><li>多媒体电影 .RMN</li><li>动画光标 .ANI</li><li>其他的RIFF文件 .BND</li></ul> 
<h3><a id="31_CHUNK_82"></a>3.1 CHUNK</h3> 
<p>chunk是RIFF文件的基本存储单元，其基本结构如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">chunk</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token class-name">uint32_t</span> id<span class="token punctuation">;</span>   <span class="token comment">// 块标志</span>
	<span class="token class-name">uint32_t</span> size<span class="token punctuation">;</span> <span class="token comment">// 块大小</span>
	<span class="token class-name">uint8_t</span> data<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 块数据</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<table><thead><tr><th>字段</th><th>名称</th><th>端序</th><th>类型</th><th>大小</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>FOURCC</td><td>大端</td><td>字符</td><td>4字节</td><td>通常为Chunk ID，以标识块中所包含的数据。如：RIFF,LIST,fmt,data,WAV,AVI等，由于这种文件结构 最初是由Microsoft和IBM为PC机所定义，RIFF文件是按照小端 little-endian字节顺序写入的。</td></tr><tr><td>size</td><td>Data Field Size</td><td>小端</td><td>整形</td><td>4字节</td><td>块大小 存储在data域中的数据长度，不包含id和size的大小。</td></tr><tr><td>data</td><td>Data Field</td><td></td><td></td><td></td><td>包含数据，数据以字节为单位存放，如果数据长度为奇数，则最后添加一个空字节。</td></tr></tbody></table> 
<p>chunk是可以嵌套的，但是只有块标志为RIFF或者LIST的chunk才能包含其他的chunk。</p> 
<h3><a id="32_RIFF_chunk_100"></a>3.2 RIFF chunk</h3> 
<p>标志为RIFF的chunk是比较特殊的，每一个RIFF文件首先存放的必须是一个RIFF chunk，并且<strong>只能有且只有这一个</strong>标志为RIFF的chunk。RIFF的数据域的起始位置是一个4字节码（FOURCC），用于标识其数据域中chunk的数据类型；紧接着数据域的内容则是包含的subchunk，如下图：<br> <img src="https://images2.imgbox.com/d2/cf/dXurjGcL_o.png" alt="RIFF chunk"></p> 
<p>这是一个RIFF chunk中包含有两个subchunk，可以看出RIFF chunk的数据域：</p> 
<ul><li>首先是<strong>4字节的 类型码(Form Type 字符 大端)</strong>，比如WAV文件的类型码为"WAVE"。</li><li>接着是两个subchunk，每一个subchun有包含有自己的标识、数据域的大小以及数据域。</li></ul> 
<h3><a id="33_LIST_chunk_108"></a>3.3 LIST chunk</h3> 
<p>除了RIFF cunk可以嵌套其他的chunk外，另一个可以有subchunk的就是LIST chunk。<br> <img src="https://images2.imgbox.com/07/d2/nhCk64aO_o.png" alt="LIST chunk"><br> 上图的chuck的结构分析：</p> 
<ul><li>首先是RIFF文件必须的RIFF chunk，其数据域是一个subchunk，其类型为List。</li><li>其次List chuck的数据域的起始位置也有一个四字节类型码(List Type)，用于说明LIST数据域的数据内容。比如，类型码为"INFO"时，其数据域可能包括"ICOP"、"ICRD"块，用于记录文件版权和创建时间信息。</li><li>最后 这个 List chunk又包含了两个subchunk。</li></ul> 
<h3><a id="34_FourCC_116"></a>3.4 FourCC</h3> 
<p>ourCC 全称为Four-Character Codes，是一个4字节32位的标识符，通常用来标识文件的数据格式。例如，在音视频播放器中，可以通过 文件的FourCC来决定调用那种CODEC进行视音频的解码。例如：DIV3,DIV4,DIVX,H264等，对于音频则有：WAV,MP3等。对于上面的RIFF文件，则有：RIFF,WAVE,fmt,data等。FourCC是4个ASCII字符，不足四个字符的则在最后补充空格（不是空字符）。<br> 比如：</p> 
<pre><code>FourCC fmt，实际上是'f' 'm' 't' ' '。
</code></pre> 
<h2><a id="4_WAV_123"></a>4 WAV文件格式</h2> 
<p>WAV符合RIFF规范，其基本的组成单元也是chunk。一个WAV文件通常有三个chunk以及一个可选chunk，其在文件中的排列方式依次是：<strong>RIFF chunk</strong>，<strong>Format chunk</strong>，<strong>Fact chunk</strong>（附加块，可选），<strong>Data chunk</strong>。</p> 
<p>以最简单的无损WAV格式文件为例，此时文件的音频数据部分为PCM，比较简单，重点在于WAV头部。一个典型的WAV文件头部长度为44字节，包含了采样率，通道数，位深等信息。如下图：<br> <img src="https://images2.imgbox.com/9c/3f/fabxzvu9_o.png" alt="典型的WAV文件"></p> 
<h3><a id="41_RIFF_chunk_129"></a>4.1 RIFF chunk</h3> 
<table><thead><tr><th>偏移位置</th><th>大小(字节)</th><th>类型</th><th>端序</th><th>说明</th></tr></thead><tbody><tr><td>0x00-0x03</td><td>4</td><td>字符</td><td>大端</td><td>"RIFF"块(0x52494646)，标记为RIFF文件格式</td></tr><tr><td>0x04-0x07</td><td>4</td><td>整型</td><td>小端</td><td>块数据域大小（Chunk Size），即从下一个地址开始，到文件末尾的总字节数，或者文件总字节数-8。从0x08开始一直到文件末尾，都是ID为"RIFF"块的内容，其中会包含：fmt 块，fact 块(压缩编码格式要含有该块)，data块</td></tr><tr><td>0x08-0x0B</td><td>4</td><td>字符</td><td>大端</td><td>类型码(Form Type)，WAV文件格式标记，即"WAVE"四个字母</td></tr></tbody></table> 
<h3><a id="42_Format_chunk_136"></a>4.2 Format chunk</h3> 
<table><thead><tr><th>偏移位置</th><th>大小(字节)</th><th>类型</th><th>端序</th><th>说明</th></tr></thead><tbody><tr><td>0x0C-0x0F</td><td>4</td><td>字符</td><td>大端</td><td>"fmt "子块(0x666D7420)，注意末尾的空格</td></tr><tr><td>0x10-0x13</td><td>4</td><td>整形</td><td>小端</td><td>子块数据域大小（SubChunk Size）其数值不确定,取决于编码格式。可以是 16、 18 、20、40 等(见4.5表)</td></tr><tr><td>0x14-0x15</td><td>2</td><td>整形</td><td>小端</td><td>编码格式(Audio Format)，1代表PCM无损格式 (见4.5表)</td></tr><tr><td>0x16-0x17</td><td>2</td><td>整形</td><td>小端</td><td>声道数(Num Channels)，值为1则为单声道，为2则是双声道</td></tr><tr><td>0x18-0x1B</td><td>4</td><td>整形</td><td>小端</td><td>采样率(Sample Rate),主要有22.05KHz，44.1kHz和48KHz</td></tr><tr><td>0x1C-0x1F</td><td>4</td><td>整形</td><td>小端</td><td>码率(Byte Rate)，每秒数据字节数，SampleRate * Channels * BitsPerSample / 8</td></tr><tr><td>0x20-0x21</td><td>2</td><td>整形</td><td>小端</td><td>数据块对齐(BlockAlign)每个采样所需的字节数，BitsPerSample*Channels/8，在播放时需要一次处理多个该值大小的字节数据。</td></tr><tr><td>0x22-0x23</td><td>2</td><td>整形</td><td>小端</td><td>采样位数(Bits Per Sample)，单个采样位深，可选8、16或32</td></tr><tr><td>0x24-0x25</td><td>2</td><td></td><td></td><td>对基本格式块的扩充部分(详见扩展格式块,格式块的扩充)</td></tr></tbody></table> 
<p>这个区域只需要关心<code>NumChannels</code>，<code>SampleRate</code>，<code>BitsPerSample</code> 三个参数就可以了，其它的都是依据这三个计算出来的。</p> 
<h3><a id="43_Fact_chunk_151"></a>4.3 Fact chunk（扩展块）</h3> 
<p>当WAV文件采用非PCM编码时，扩展块才存在，并且使用的是扩展格式块，它是在基本格式块fmt扩充了一个的数据结构。此时，fmt块的fm_size为18（0x12），即4.2节图中 0x24-0x25两个字节会有00 00 填充。而PCM编码时，fmt块的fm_size为16（0x10）,就无0x24-0x25这两位。</p> 
<p>该数据的前两个字节，表示的扩展块的长度。紧接其后的是扩展的数据区，含有扩展的格式信息，其具体的长度取决于压缩编码的类型。当某种编码方式（如 ITU G.711 a-law）使扩展区的长度为0，扩展区的长度字段还必须保留，只是其值设置为0。</p> 
<table><thead><tr><th>偏移位置</th><th>大小(字节)</th><th>类型</th><th>端序</th><th>说明</th></tr></thead><tbody><tr><td>0x26-0x29</td><td>4</td><td>字符</td><td>大端</td><td>"fact"子块(0x66617374)</td></tr><tr><td>0x2A-0x2D</td><td>4</td><td>整形</td><td>小端</td><td>"fact"块长度</td></tr><tr><td>0x2E-不定</td><td></td><td>整形</td><td>小端</td><td>"fact"块数据，采样总数</td></tr></tbody></table> 
<p>factDataSize为，音频数据格式转换为PCM格式后的大小，如果是某种压缩格式，那么从此可以得出解压后的大小，对于解压时的计算很有好处。</p> 
<h3><a id="44_Data_164"></a>4.4 Data</h3> 
<p>真正地数据区紧接在Fmt或Fact块后。</p> 
<table><thead><tr><th>偏移位置</th><th>大小(字节)</th><th>类型</th><th>端序</th><th>说明</th></tr></thead><tbody><tr><td>不定</td><td>4</td><td>字符</td><td>大端</td><td>"data"子块 (0x64617461)</td></tr><tr><td>不定</td><td>4</td><td>整形</td><td>小端</td><td>子块数据域大小（SubChunk Size）</td></tr><tr><td>不定</td><td>N</td><td></td><td></td><td>音频数据 N = ByteRate * seconds</td></tr></tbody></table> 
<p>Data块中存放的是音频的采样数据，根据声道数和采样率的不同情况，布局如下（每列代表8bits）：</p> 
<ul><li><strong>8 Bit 单声道</strong></li></ul> 
<table><thead><tr><th>采样1</th><th>采样2</th></tr></thead><tbody><tr><td>数据1</td><td>数据2</td></tr></tbody></table> 
<ul><li><strong>8 Bit 双声道</strong></li></ul> 
<table><thead><tr><th>采样1</th><th></th><th>采样2</th><th></th></tr></thead><tbody><tr><td>声道1数据1</td><td>声道2数据1</td><td>声道1数据2</td><td>声道2数据2</td></tr></tbody></table> 
<ul><li><strong>16 Bit 单声道</strong></li></ul> 
<table><thead><tr><th>采样1</th><th></th><th>采样2</th><th></th></tr></thead><tbody><tr><td>数据1低字节</td><td>数据1高字节</td><td>数据1低字节</td><td>数据1高字节</td></tr></tbody></table> 
<ul><li><strong>16 Bit 双声道</strong></li></ul> 
<table><thead><tr><th>采样1</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>声道1数据1低字节</td><td>声道1数据1高字节</td><td>声道2数据1低字节</td><td>声道2数据1高字节</td></tr><tr><td><strong>采样2</strong></td><td></td><td></td><td></td></tr><tr><td>声道1数据2低字节</td><td>声道1数据2高字节</td><td>声道2数据2低字节</td><td>声道2数据2高字节</td></tr></tbody></table> 
<p>对于PCM数据，有以下两种的存储方式：</p> 
<ul><li>单声道，量化位数为8，使用偏移二进制码</li><li>除上面之外的，使用补码方式存储。</li></ul> 
<h3><a id="45__206"></a>4.5 常见的压缩编码格式</h3> 
<table><thead><tr><th>格式代码</th><th>格式名称</th><th>fmt 块长度</th><th>fact 块</th></tr></thead><tbody><tr><td>1(0x0001)</td><td>PCM/非压缩格式</td><td>16</td><td></td></tr><tr><td>2(0x0002)</td><td>Microsoft ADPCM</td><td>18</td><td>√</td></tr><tr><td>3(0x0003)</td><td>IEEE float</td><td>18</td><td>√</td></tr><tr><td>6(0x0006)</td><td>ITU G.711 a-law</td><td>18</td><td>√</td></tr><tr><td>7(0x0007)</td><td>ITU G.711 μ-law</td><td>18</td><td>√</td></tr><tr><td>49(0x0031)</td><td>GSM 6.10</td><td>20</td><td>√</td></tr><tr><td>64(0x0040)</td><td>ITU G.721ADPCM</td><td></td><td>√</td></tr><tr><td>65,534(0xFFFE)</td><td>见子格式块中的编码格式</td><td>40</td><td></td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb9a3a08b14f1a38921b3a52b572b2d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">102. 二叉树的层序遍历</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/969b8e973704729ec8df2d3b694cd71e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">我真太卷了，抖音程序员用代码写圣诞树层出不穷，8年开发经验老码侬都整懵了</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>