<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】面向对象——继承 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java】面向对象——继承" />
<meta property="og:description" content="继承 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。继承是is-a的相互关系 继承的优点 将所有子类的共同属性放入父类，实现代码共享，避免重复，提高开发效率可以使得修改扩展继承而来的实现比较简单 继承的缺陷 父类变，子类就必须变继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的继承是一种强耦合关系 特殊关键字 包package 包是类或接口的容器，是一个用于避免命名冲突的名空间，是一个逻辑命名的概念，与具体的物理位置无关
在具体的实现中，包名称经常和目录名称对应
什么是包 包是类的组织方式，提供名空间和访问控制类似于文件系统的组织 声明包中的类package 语法： package 包名称;
声明包要求是源代码文件的第一个语句。包定义之前可以添加注释信息程序中最多只能有一条package语句，没有包定义的源代码文件成为默认包中的一部分 //默认包中的类可以访问其它命名包或者只能同包访问，其它包不能访问默认包中的类 public class A1 { public void cc() { System.out.println(&#34;小胖子醒醒!&#34;); } } 程序中如果有package语句,该语句必须是第一条语句（前面只能有注释或空行）包的命名规则： 全小写使用域名反转的方式定义，例如延安餐饮集团yanan.com的项目，定义包名称为com.yanan如果细分还可以引入功能定义部分，例如数据库访问com.yanan.dao
包的作用 包能将相关的源代码文件组织在一起 com.yanan.dao其中存放操作数据库相关的类文件com.yanan.biz存放相关的业务类文件 包减少了名称冲突带来的问题可以使用package指明源文件中的类属于哪个具体的包
包的使用如果其他人想使用包中类，则需要使用全名 import java.util.Date; public class A{ public static void main(String[] args){ Date now=new Date(); //使用类的简称Date，而不是全名称java.util.Date } } //用法2：全称 java.util.Date now=new java.util.Date(); //不需要import 为了简化书写，Java提供了import语句： import package_name.*; import java.util.*; //使用java.util包中的所有类都不需要再使用import java.util.类名 引入包中的某一个类：import java.util.ArrayList;
引入包importJava缺省引入的包为java.lang System.out.println(&#34;显示输出&#34;);//不需要import java.lang.System //同包中的其它类不需要导入 package com." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5b196712dcfb9f3086af024c3fd1a245/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-21T19:03:23+08:00" />
<meta property="article:modified_time" content="2022-07-21T19:03:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】面向对象——继承</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>继承</h2> 
<ul><li>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</li><li>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</li><li>继承是is-a的相互关系</li></ul> 
<h4><a id="_4"></a>继承的优点</h4> 
<ul><li>将所有子类的共同属性放入父类，实现代码共享，避免重复，提高开发效率</li><li>可以使得修改扩展继承而来的实现比较简单</li></ul> 
<h4><a id="_7"></a>继承的缺陷</h4> 
<ul><li>父类变，子类就必须变</li><li>继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的</li><li>继承是一种强耦合关系</li></ul> 
<h4><a id="_11"></a>特殊关键字</h4> 
<h5><a id="package_12"></a>包package</h5> 
<p>包是类或接口的容器，是一个用于避免命名冲突的名空间，是一个逻辑命名的概念，与具体的物理位置无关</p> 
<p>在具体的实现中，包名称经常和目录名称对应</p> 
<h5><a id="_16"></a>什么是包</h5> 
<ul><li>包是类的组织方式，提供名空间和访问控制</li><li>类似于文件系统的组织</li></ul> 
<h6><a id="package_19"></a>声明包中的类package</h6> 
<p>语法： package 包名称;</p> 
<ul><li>声明包要求是源代码文件的第一个语句。包定义之前可以添加注释信息</li><li>程序中最多只能有一条package语句，没有包定义的源代码文件成为默认包中的一部分</li></ul> 
<pre><code class="prism language-java"><span class="token comment">//默认包中的类可以访问其它命名包或者只能同包访问，其它包不能访问默认包中的类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> A1 <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小胖子醒醒!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>程序中如果有package语句,该语句必须是第一条语句（前面只能有注释或空行）</li><li>包的命名规则： 
  <ul><li>全小写</li><li>使用域名反转的方式定义，例如延安餐饮集团yanan.com的项目，定义包名称为com.yanan</li><li>如果细分还可以引入功能定义部分，例如数据库访问com.yanan.dao<br> <strong>包的作用</strong></li></ul> </li><li>包能将相关的源代码文件组织在一起 
  <ul><li>com.yanan.dao其中存放操作数据库相关的类文件</li><li>com.yanan.biz存放相关的业务类文件</li></ul> </li><li>包减少了名称冲突带来的问题</li><li>可以使用package指明源文件中的类属于哪个具体的包<br> <strong>包的使用</strong></li><li>如果其他人想使用包中类，则需要使用全名</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token class-name">Date</span> now<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//使用类的简称Date，而不是全名称java.util.Date</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//用法2：全称</span>
<span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span> now<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//不需要import</span>
</code></pre> 
<ul><li>为了简化书写，Java提供了import语句： import package_name.*;</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span>
<span class="token comment">//使用java.util包中的所有类都不需要再使用import java.util.类名</span>
</code></pre> 
<ul><li>引入包中的某一个类：import java.util.ArrayList;<br> <strong>引入包import</strong></li><li>Java缺省引入的包为java.lang</li></ul> 
<pre><code class="prism language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示输出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不需要import java.lang.System</span>
<span class="token comment">//同包中的其它类不需要导入</span>
<span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yan</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yan</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token class-name">A</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">A1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//不需要import com.yan.A</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>引入包中的类： import 包名称.类名称;例如import java.util.Date;</li><li>引入整个包； import 包名称.* ;例如 import java.util.* ;</li><li>不引入包而是用类，则需要是用类的全名： 包名.类名,例如java.util.Date dd=new java.util.Date();<br> <strong>包说明</strong></li><li>package-info.java可以描述一个包的作用</li></ul> 
<pre><code class="prism language-java"><span class="token comment">//这是一个测试包</span>
<span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yan<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>package-info中不能定义public和private的类，但是可以定义friendly的类及包常量，提供给统一包下面的类进行共享</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yan<span class="token punctuation">.</span>a</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Constants</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NAME<span class="token operator">=</span><span class="token string">"Yanjun"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token annotation punctuation">@Data</span>
<span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token punctuation">{<!-- --></span> <span class="token comment">//包中的类可以直接使用</span>
<span class="token keyword">private</span> <span class="token class-name">String</span> className<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>最后针对注解的package作用域，后面继续讲解<br> <strong>范围限定词和包</strong></p> 
<pre><code class="prism language-java"><span class="token comment">//定义不包含再其它类中的外部类时，class前的范围限定词可以使用public或者默认</span>
<span class="token comment">//public 到处可见 没有限定词只能同包访问</span>
<span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yan</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token class-name">B</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//语法正确</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yan1</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token class-name">B</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">B1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//语法错误，因为B类是默认class</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//成员属性和成员方法:定义在class内部，除了构造器（匿名内部代码块）和析构器之外的其它内容</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token comment">//方法名称和类名称一致，包括大小写，而且没有返回类型声明---构造器</span>
<span class="token comment">//构造器方法不能直接调用，只能通过new运算符进行间接调用new A()系统自动执行A()方法</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token comment">//语法正确，但是不是构造器。可以直接调用,new A().A()</span>
<span class="token comment">//成员方法</span>
<span class="token keyword">public</span>范围限定词 返回数据类型 方法名称<span class="token punctuation">(</span>参数类型<span class="token number">1</span> 形参名称<span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//如果没有返回值则</span>
类型为<span class="token keyword">void</span>
<span class="token keyword">return</span> xxx<span class="token punctuation">;</span> 返回值必须和返回类型声明一致；如果返回类型为<span class="token keyword">void</span>则<span class="token keyword">return</span>后面不能
带任何数据
<span class="token punctuation">}</span> <span class="token comment">//成员方法的调用为 对象名.方法名称(实际参数列表)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_126"></a>基础练习</h5> 
<p>面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。在面向对象程序设计中,不必关心对象的具体实现。在传统的结构化程序设计中，算法是第一位的，数据结构是第二位的，即首先确定如何操作数，再考虑如何组织数据，以方便操作。而OOP则颠倒了这种次序，将数据放在第一位，然后再考虑操作数据的算法。</p> 
<h5><a id="_128"></a>抽象</h5> 
<p>忽略掉一个对象或实体的细节而只关注其本质特征的过程，可以简化功能与格式，帮助用户与对象交互是人类解决问题的基本法宝。良好的抽象策略可以控制问题的复杂程度，增强系统的通用性和可扩展性抽象主要包括过程抽象和数据抽象</p> 
<ul><li>过程抽象是将问题域中具有明确功能定义的操作抽取出来，并将其作为一个实体看待</li><li>数据抽象是较过程抽象更高级别的抽象方式，将描述客体的属性和行为绑定在一起，实现统一的抽象，从而达到对现实世界客体的真正模拟</li></ul> 
<h5><a id="_132"></a>类</h5> 
<p>类是构造对象的模板和蓝图。通俗地说，类相当于建筑的图纸，而对象相当于建筑物。由类构造对象的过程称为创建对象的实例。Java中通过关键字class定义“类”，后跟类名<br> 设计与编写类的过程实际上是一个对实体共有属性和行为的一个抽象的过程<br> 例如面对的是一个具体个体：赵小胖，为了将研究对象存储在计算机中，所以定义了一个新数据类型<br> Student<br> 分析问题域相关的属性：</p> 
<pre><code>class Student {
private Long id;如果使用包装类，则默认值为null
private String username=”yanjun”;
private int age;如果使用简单类型，则数值型默认为0,布尔型为false
}
</code></pre> 
<p>分析问题域相关的行为—方法</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>如果使用包装类，则默认值为<span class="token keyword">null</span>
<span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token operator">=</span>”yanjun”<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>定义类的目的就是为了在计算机中存储特定的对象，所以需要创建对应的对象，创建方法和简单类型中定义变量的含义一致</p> 
<pre><code class="prism language-java"><span class="token class-name">Student</span> s1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s1<span class="token punctuation">.</span>方法名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 调用成员方法
<span class="token keyword">new</span> <span class="token class-name">Stduent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>面向对象的编程可以认为是面向类的编程。编写类的过程，相当于我们定义了一种新的数据类型。<br> <strong>对象对象编程的核心是面向抽象编程，面向抽象编程的核心是面向接口编程</strong></p> 
<h5><a id="_163"></a>面向对象和面向过程的区别</h5> 
<p>面向过程：</p> 
<ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展<br> 面向对象：</li><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul> 
<h4><a id="_170"></a>特殊方法</h4> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

</code></pre> 
<p>理解main()方法语法及命令行参数：main方法入口是一个数组类型的参数，也可以给main方法传递参数，通过命令行在运行时传入参数即可。main方法的参数是String数组，命令行运行Java程序时，可以传入多个参数，参数与参数之间使用空格分开。args[0]访问第一个参数，args[1]访问第二个参数，args[3]访问第三个参数，该程序运行时，需要在命令行传入三个参数。<br> <strong>编码：</strong><br> 编写一个计算考试成绩的程序，输入10个学生的成绩，计算10个学生成绩的和。要求计算学生成绩的和用方法来实现，该方法计算10个学生的成绩和，并返回结果。</p> 
<h5><a id="_178"></a>构造器方法</h5> 
<p>构造函数是一种特殊的方法，不算是成员方法。主要用来在创建对象时初始化对象，即为对象成员变量<br> 赋初始值，总与new运算符一起使用在创建对象的语句中。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">//不能有返回值类型的声明，甚至void都不允许出现</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们，即构造函数的重载。</p> 
<pre><code class="prism language-java"><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 对应的构造器为<span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 对应的构造器为<span class="token class-name">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 因为没有<span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> kk<span class="token punctuation">)</span>这样的构造器，所以语法报错
</code></pre> 
<p>不算成员方法<br> <strong>构造器特点</strong><br> 函数名与类名相同，包括大小写<br> 不用定义返回值类型，不用写void。不能return具体指，可以使用return没有返回值<br> 没有具体的返回值<br> 一个类可以有多个不同的构造器，但是参数一定不能相同<br> 参数个数、参数类型、参数顺序</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token class-name">String</span> clz<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> clz<span class="token punctuation">,</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token comment">//语法报错，因为系统只能识</span>
别类型，并不识别形参名称
<span class="token punctuation">}</span>
</code></pre> 
<p>Java中并不识别参数名称<br> 在构造函数前面加上返回值就只是一般函数了<br> <strong>构造器作用</strong><br> 构造器用于给对象进行初始化，可创建对象 new 构造函数();</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token comment">//出现了2个同名的name变量，一个成员变量，一个局部变量。可以使用this进行区分，</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>name标识成员变量，直接使用name表示局部变量。
<span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按照就近原则，这个name用于指代局部变量</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当使用new运算符时自动进行调用，但是构造方法不能直接调用<br> 关键字 new 通常称为创建运算符，用于分配对象内存，并将该内存初始化为缺省值<br> 一旦 new 完成分配和初始化内存，它就将调用构造函数来执行对象初始化<br> 当定义Java类时没有定义构造器，则Java自动为类自动提供无参构造器, 将成员变量的值初始化为缺省值<br> 简单类型属性：数值型为0,boolean为false，char为\u0000<br> 复杂类型属性：null<br> 一旦创建了自己的构造函数，缺省的构造函数将不复存在</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span> <span class="token class-name">String</span> national<span class="token operator">=</span><span class="token string">"汉族"</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">this</span><span class="token punctuation">.</span>national<span class="token operator">=</span><span class="token string">"民族"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>创建对象都必须通过构造函数初始化<br> 每个类至少有一个构造方法。<br> 一个类中如果没有定义过构造函数，那么该类中会有一个默认的空参数构造函数</p> 
<pre><code>public class A{} //这里有系统自动提供的无参构造器
</code></pre> 
<p>如果在类中定义了指定的构造函数，那么类中的默认构造函数就没有了<br> 尽量不在类的构造器中创建、初始化大量的对象或执行某种复杂、耗时的运算逻辑<br> 一般函数和构造函数区别<br> 构造函数：对象创建时，就会调用与之对应的构造函数，对对象进行初始化 new A()<br> 一般函数：对象创建后，需要函数功能时才调用<br> 构造函数：对象创建时，会调用并且只调用一次<br> 一般函数：对象创建后，可以被调用多次<br> <strong>析构器方法</strong><br> 析构方法–析构器—在垃圾回收之前运行的方法—资源回收</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// TODO Auto-generated method stub</span>
<span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>由于垃圾回收的执行时机不确定，而且不能保证一定会执行析构器，所以一般不能使用析构方法执行资源回收<br> finalize()方法无法保证一定会执行，jdk10+已弃用此方法<br> final finally finalize</p> 
<h4><a id="_267"></a>总结继承</h4> 
<p>继承就是在已经存在的类的基础上进行扩展，从而产生新的类，支持了层次结构分类的概念。已经存在的类称为父类、超类或基类，而新产生的类称为子类或派生类。多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。多个类可以称为子类，单独这个类称为父类或者超类。<br> 通过 extends 关键字让类与类之间产生继承关系<br> 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子<br> 类从父类继承方法，使得子类具有父类相同的行为。<br> 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的<br> 功能，也可以用父类的功能，但不能选择性地继承父类。<br> 继承是is-a的相互关系<br> 在Java中父类所拥有的一切，子类都可以继承<br> 私有属性是否可被继承—两种答案<br> 子类除了拥有父类的属性和方法（拥有父类的所有成员，但是注意构造器和析构器不是成<br> 员），也可以创建自己的特性</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">String</span> type<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>
<span class="token comment">//这里就包含了方法pp</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以减少代码，而且易于维护<br> 建议的使用场景：把通用操作和方法放在父类中，将特殊的方法定义在子类中。好处在于：1、避免代码重复。2、避免了人为因素导致的不一致性</p> 
<h5><a id="_292"></a>继承的特性</h5> 
<p>1、Java中不支持多重继承。Java中要求任何的子类只能有一个直系的双亲类</p> 
<pre><code> public class A extends B,C{} //语法错误，因为A只能继承一个类或者不写继承
</code></pre> 
<p>原因：因为多继承容易出现问题。两个父类中有相同的方法，子类到底要执行哪一个是不确定的如果定义类但是没有extends，则意味着默认父类为java.lang.Object。这也就是说Java中的任意类都是Object的子类<br> 2、如果定义类但是没有extends，则意味着默认父类为java.lang.Object。这也就是说Java中的任意类都是Object的子类<br> 3、可以在子类中进行覆盖定义父类中的成员方法和成员属性</p> 
<pre><code>public class A{
protected long id;
}
public class B extends A{
protected String id;
}
</code></pre> 
<p>Java支持多层继承(继承体系)：Java中的所有类都直接或者间接的集成于java.lang.Object类<br> C继承B，B继承A，就会出现继承体系<br> 多层继承出现的继承体系中，通常看父类中的功能，了解该体系的基本功能，建立子类对象，即可使用该体系功能。<br> 定义继承需要注意：不要仅为了获取其他类中某个功能而去继承，类与类之间要有所属( “is a”)关系。<br> <strong>继承的优点</strong><br> 继承的出现提高了代码的复用性。继承的出现让类与类之间产生了关系，提供了多态的前提<br> 将所有子类的共同属性放入父类，实现代码共享，避免重复，提高开发效率<br> 可以使得修改扩展继承而来的实现比较简单<br> <strong>继承的缺陷</strong><br> 父类变，子类就必须变<br> 继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的<br> 继承是一种强耦合关系<br> <strong>继承的编码问题</strong></p> 
<pre><code>public class Person {
public Person() {
System.out.println("Person....");
}
}
public class Student extends Person{
public Student() {
System.out.println("student....");
}
public static void main(String[] args) {
Student s1=new Student();
}
}
</code></pre> 
<p>结论：上溯流程中先查找所有的父类，然后才从根类开始逐层调用构造器<br> <strong>应用继承的建议</strong><br> 建议的使用场景：把通用操作和方法放在父类中，将特殊的方法定义在子类中。<br> 好处在于：1、避免代码重复。2、避免了人为因素导致的不一致性<br> <strong>关键字final</strong><br> 意思是最终的、不可变的<br> <strong>修饰变量</strong><br> Final修饰变量时，变量被必须初始化，并且不能被修改。初始化可以定义final变量时直接初始化或者在构造函数中初始化<br> <strong>修饰局部变量</strong><br> <strong>修饰方法</strong><br> final修饰方法则该方法不能被子类重写<br> <strong>修饰类</strong><br> final修饰一个类,则该类不能被继承<br> <strong>扩展</strong><br> 表示字串的3种类型String、StringBuffer、StringBuilder都是final类型的类，所以都不允许继承<br> <strong>总结</strong><br> final 属性上可以声明的同时直接赋值或者在构造器中赋值<br> final临时变量，可以声明的同时赋值或者在第一次使用之前进行赋值<br> <strong>注意：final类型的变量一旦赋值则不允许修改，但是如果是复杂类型是不允许修改地址，但<br> 是可以修改属性</strong><br> final方法表示这个方法不允许在子类中重新定义（覆盖\重写）<br> final类表示这个类不允许被继承</p> 
<h6><a id="_358"></a>实现类不能被继承的方法</h6> 
<p>private私有构造器</p> 
<h6><a id="_360"></a>单例模式</h6> 
<p>模式：由专家总结出来的在某种情况下解决某类问题的最佳解决方案，是思想、是知识，是一种抽象的内容<br> 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br> 主要解决：一个全局使用的类频繁地创建与销毁。<br> 何时使用：当您想控制实例数目，节省系统资源的时候。<br> 单例模式有多种写法，最常见的是懒汉模式和饿汉模式</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f3b56da2e188dbc97fa2629e38b7baf4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vscode同时配置C和C&#43;&#43;编译环境（纯小白版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/39ca5f3d57bc927a22cbe29b961660d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Turtlebot3 Jetson NX在ROS环境下键盘控制小车移动旋转 - 配置环境以及控制设置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>