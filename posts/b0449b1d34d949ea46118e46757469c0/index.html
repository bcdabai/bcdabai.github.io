<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CE-RTI开源软件代码学习笔记（一） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CE-RTI开源软件代码学习笔记（一）" />
<meta property="og:description" content="1、int main(int argc, char *argv[]) 当刚看到这句话的时候，是没有什么感觉的，因为从刚开始接触c&#43;&#43;以来就经常见到这句话，只当它是所有c&#43;&#43;程序的开头罢了，当我看到接下来的代码中在利用()里面的参数时，我是懵圈的，我才发现我竟然不了解这句话的意思。
main函数可以带参数，这个参数可以认为是 main函数的形式参数。Ｃ语言规定main函数的参数只能有两个， 习惯上这两个参数写为argc和argv。
Ｃ语言还规定argc(第一个形参)必须是整型变量，argv( 第二个形参)必须是指向字符串的指针数组。
由于main函数不能被其它函数调用， 因此不可能在程序内部取得实际值。main函数的参数值是从操作系统命令行上获得的。当我们要运行一个可执行文件时，在DOS提示符下键入文件名，再输入实际参数即可把这些实参传送到main的形参中去。
DOS提示符下命令行的一般形式为： C:\&gt;可执行文件名 参数 参数……; 但是应该特别注意的是，main 的两个形参和命令行中的参数在
位置上不是一一对应的。因为,main的形参只有二个，而命令行中的参数个数原则上未加限制。argc参数表示了命令行中参数的个数(注意：文件名本身也算一个参数)，argc的值是在输入命令行时由系统按实际参数的个数自动赋予的。例如有命令行为： C:\&gt;e24 BASIC dbase FORTRAN由于文件名e24本身也算一个参数，所以共有4个参数，因此argc取得的值为4。argv参数是字符串指针数组，其各元素值为命令行中各字符串(参数均按字符串处理)的首地址。 指针数组的长度即为参数个数。数组元素初值由系统自动赋予，其中第0个参数是程序的全名。其表示如下所示：
main(int argc,char *argv){
while(argc--&gt;1)
printf(&#34;%s\n&#34;,*&#43;&#43;argv);
}
本例是显示命令行中输入的参数如果上例的可执行文件名为e24.exe，存放在A驱动器的盘内。
因此输入的命令行为： C:\&gt;e24 BASIC dBASE FORTRAN 则运行结果为：
BASIC
dBASE
FORTRAN
一般情况下，在windows下不太常用，只是在Linux程序中用的较多。
2、getenv()\putenv() getenv(const char* varName)：获取环境变量名称varName的环境变量的值
putenv(const char* varString)：将当前的环境变量varString添加的环境中,设置的环境仅对程序本身有效，不会反映到外部环境
3、std::signal(SIGINT, SignalHandler); signal函数原型：
void (*signal (int sig, void (*func)(int)))(int); 第一个参数为 整数，标识信号号码；第二个参数标识 一个指向信号处理函数的指针，即第二格参数其实是一个函数指针；
参考文档：http://wiki.jikexueyuan.com/project/cplusplus/signal-handling.html
http://blog.csdn.net/ta893115871/article/details/7475095
不过，signal函数大部分情况下是用在unix下，windows下的编程很少用到。
4、std::set_new_handler(NewHandler); std有一个set_new_handler函数，它接受和返回一个new_handler类型，用于设置当前当使用new操作符无法分配足够内存时而抛出bad_alloc异常的处理函数。new_handler其实是一个void (void)函数，你可以在头文件&lt;new&gt;中看到它的typedef：typedef void(*new_handler)();
所以std::set_new_handler其实是接受一个不接受参数也无返回值的函数的函数指针。而这个函数就被用来处理bad_alloc异常。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b0449b1d34d949ea46118e46757469c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-31T09:20:44+08:00" />
<meta property="article:modified_time" content="2022-10-31T09:20:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CE-RTI开源软件代码学习笔记（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1、int main(int argc, char *argv[])</h2> 
<p>当刚看到这句话的时候，是没有什么感觉的，因为从刚开始接触c++以来就经常见到这句话，只当它是所有c++程序的开头罢了，当我看到接下来的代码中在利用()里面的参数时，我是懵圈的，我才发现我竟然不了解这句话的意思。</p> 
<p><span style="background-color:#f5f5f5;color:#333333;">main函数可以带参数，这个参数可以认</span><span style="background-color:#f5f5f5;color:#333333;">为是 m</span><span style="background-color:#f5f5f5;color:#333333;">ain函数的形式参数。Ｃ语言规定main函数的参数只能有两个， 习惯上这两个参数写为argc和argv。</span></p> 
<p><span style="background-color:#f5f5f5;color:#333333;">Ｃ语言还规定argc(第一个形参)必须是整型变量，argv( 第二个形参)必须是指向字符串的指针数组。</span></p> 
<p><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;">由于main函数不能被其它函数调用， 因此不可能在程序内部取得实际值。<span style="background-color:#f5f5f5;color:#333333;">main函数的参数值是从操作系统命令行上获得的。<span style="background-color:#f5f5f5;color:#333333;">当我们要运行一个可执行文件时，在DOS提示符下键入文件名，再输入实际参数即可把这些实参传送到main的形参中去。</span></span></span></span></p> 
<p><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;">DOS提示符下命令行的一般形式为： C:\&gt;可执行文件名 参数 参数……; 但是应该特别注意的是，main 的两个形参和命令行中的参数在</span><br><span style="background-color:#f5f5f5;color:#333333;">位置上不是一一对应的。因为,main的形参只有二个，而命令行中的参数个数原则上未加限制。argc参数表示了命令行中参数的个数(注意：文件名本身也算一个参数)，argc的值是在输入命令行时由系统按实际参数的个数自动赋予的。例如有命令行为： C:\&gt;e24 BASIC dbase FORTRAN由于文件名e24本身也算一个参数，所以共有4个参数，因此argc取得的值为4。argv参数是字符串指针数组，其各元素值为命令行中各字符串(参数均按字符串处理)的首地址。 指针数组的长度即为参数个数。数组元素初值由系统自动赋予，<span style="background-color:#f5f5f5;color:#333333;">其中第0个参数是程序的全名</span>。其表示如下所示：</span><br><span style="background-color:#f5f5f5;color:#333333;">main(int argc,char *argv){<!-- --></span><br><span style="background-color:#f5f5f5;color:#333333;">while(argc--&gt;1)</span><br><span style="background-color:#f5f5f5;color:#333333;">printf("%s\n",*++argv);</span><br><span style="background-color:#f5f5f5;color:#333333;">}</span><br><span style="background-color:#f5f5f5;color:#333333;">本例是显示命令行中输入的参数如果上例的可执行文件名为e24.exe，存放在A驱动器的盘内。</span><br><span style="background-color:#f5f5f5;color:#333333;">因此输入的命令行为： C:\&gt;e24 BASIC dBASE FORTRAN </span><br><span style="background-color:#f5f5f5;color:#333333;">则运行结果为：</span><br><span style="background-color:#f5f5f5;color:#333333;">BASIC</span><br><span style="background-color:#f5f5f5;color:#333333;">dBASE</span><br><span style="background-color:#f5f5f5;color:#333333;">FORTRAN</span></span></span></span></span></p> 
<p><span style="color:#333333;">一般情况下，在windows下不太常用，只是在Linux程序中用的较多。</span></p> 
<h2><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;">2、getenv()\putenv()</span></span></span></span></span></h2> 
<p><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;">getenv(const char* varName)：获取环境变量名称<span style="background-color:#f5f5f5;color:#333333;">varName</span>的环境变量的值</span></span></span></span></span></span></p> 
<p><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;">putenv(<span style="background-color:#f5f5f5;color:#333333;">const char* varString</span>)：将当前的环境变量<span style="background-color:#f5f5f5;color:#333333;">varString</span>添加的环境中,设置的环境仅对程序本身有效，不会反映到外部环境</span></span></span></span></span></span></p> 
<h2><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;">3、std::signal(SIGINT, SignalHandler);</span></span></span></span></span></span></h2> 
<p><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;">signal函数原型：</span></span></span></span></span></span></p> 
<pre><code>void (*signal (int sig, void (*func)(int)))(int);</code></pre> 
<p></p> 
<p><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;">第一个参数为 整数，标识信号号码；第二个参数标识 一个指向信号处理函数的指针，即第二格参数其实是一个函数指针；</span></span></span></span></span></span></p> 
<p><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;">参考文档：http://wiki.jikexueyuan.com/project/cplusplus/signal-handling.html</span></span></span></span></span></span></p> 
<p><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;">http://blog.csdn.net/ta893115871/article/details/7475095</span></span></span></span></span></span></p> 
<p><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;">不过，signal函数大部分情况下是用在unix下，windows下的编程很少用到。</span></span></span></span></span></span></p> 
<h2><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;">4、std::set_new_handler(NewHandler);</span></span></span></span></span></span></h2> 
<p><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="color:#333333;">std有一个set_new_handler函数，它接受和返回一个new_handler类型，用于设置当前当使用new操作符无法分配足够内存时而抛出bad_alloc异常的处理函数。</span></span></span></span></span></span></span><span style="background-color:#f5f5f5;color:#333333;">new_handler其实是一个void (void)函数，你可以在头文件&lt;new&gt;中看到它的typedef：</span><span style="background-color:#f5f5f5;color:#333333;">typedef void(*new_handler)();</span></p> 
<p><span style="background-color:#f5f5f5;color:#333333;">所以std::set_new_handler其实是接受一个不接受参数也无返回值的函数的函数指针。而这个函数就被用来处理bad_alloc异常。</span></p> 
<p><span style="background-color:#f5f5f5;color:#333333;">这句话的意思就可以理解为：当程序中的new操作或着new[]操作失败时，将调用NewHandler指向的函数。</span></p> 
<h2><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="color:#333333;">5、<span style="color:#333333;">select()</span></span></span></span></span></span></span></span></h2> 
<p><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="background-color:#f5f5f5;color:#333333;"><span style="color:#333333;">select()函数：确定一个或多个套接口（Socket）的状态，对于每一个套接口，调用者可以查询它的可读性、可写性及错误状态信息。用fd_set结构来标识一组等待检查的套接口，在调用返回时，这格结构存有满足一定条件的套接口组的子集，并且select()返回满足条件的套接口的数目。有一组宏可用于对fd_set的操作，这些宏与unix软件中的兼容，但内部的表达是完全不同的。</span></span></span></span></span></span></span></p> 
<p>select()是属于一个比较大的范畴了，而且又分windows和unix的区别，具体资料不再此骜述，具体资料可参考一下资料：</p> 
<p>http://blog.csdn.net/pugu12/article/details/46863715</p> 
<p>http://blog.csdn.net/leo115/article/details/8097143</p> 
<p>http://www.cnblogs.com/renyuan/p/5100184.html</p> 
<p>http://blog.sina.com.cn/s/blog_4900f3fb0100k20a.html</p> 
<h2>6、std::auto_ptr&lt;&gt;</h2> 
<p>auto_ptr是一个模板类，定义如下：</p> 
<p><strong><span style="color:#0000ff;">template</span> &lt;<span style="color:#0000ff;">typename</span> </strong>Type<strong>&gt;<br><span style="color:#0000ff;">class</span></strong> auto_ptr {...}；</p> 
<p>它存储的是一个指向Type的指针。</p> 
<p>顾名思义，auto_ptr是一种智能指针，它包含一个动态分配内存的指针，并在它生命周期结束的时候，销毁包含的指针所指向的内存。</p> 
<p><span style="background-color:#fcfcfc;"> </span><span style="background-color:#fcfcfc;">auto_ptr构造函数：std::auto_ptr&lt;Billard&gt; billard(createBillard(args.demo_given, args.demo_arg, federate));</span></p> 
<p></p> 
<p><span style="background-color:#fcfcfc;">这句话的意思就是，用auto_ptr定义了一个Billard类的一个实例billard，同时为Billard的构造函数传递了参数 <span style="background-color:#fcfcfc;">createBillard(args.demo_given, args.demo_arg, federate)的返回值</span></span></p> 
<p></p> 
<p>参考文章：http://blog.csdn.net/monkey_d_meng/article/details/5901392</p> 
<p>http://blog.163.com/hbu_lijian/blog/static/126129153201242124741769/  </p> 
<h2>7、构造函数初始化</h2> 
<p>构造函数初始化成员变量有两种方式，一是传统的方式，即;</p> 
<p><span style="color:#333333;">CSomeClass::CSomeClass() </span><br> {<!-- --><span style="color:#333333;">x=0; </span><br><span style="color:#333333;">y=1; }</span></p> 
<p><span style="color:#333333;">还有一种是采用成员初始化列表的形式：</span></p> 
<p><span style="color:#333333;"><span style="color:#333333;">CSomeClass::CSomeClass() : x(0), y(1) </span><br><span style="color:#333333;">{ </span><br><span style="color:#333333;">} </span></span></p> 
<p><span style="color:#333333;"><span style="color:#333333;">采用成员初始化列表的形式有两格原因：</span></span></p> 
<p><span style="color:#333333;"><span style="color:#333333;">第一：当初始化另一个类的成员。如：</span></span></p> 
<p><span style="color:#333333;"><span style="color:#333333;"><span style="color:#333333;">class CMyClass { </span><br><span style="color:#333333;">CMember m_member; </span><br><span style="color:#333333;">public: </span><br><span style="color:#333333;">CMyClass(); </span><br><span style="color:#333333;">}; </span><br><span style="color:#333333;">//必须使用成员初始化列表 </span><br><span style="color:#333333;">CMyClass::CMyClass() : m_member(2) </span><br><span style="color:#333333;">{ </span><br><span style="color:#333333;">...</span><br><span style="color:#333333;">} </span></span></span></p> 
<p><span style="color:#333333;"><span style="color:#333333;"><span style="color:#333333;">没有其它办法将参数传递给m_member，如果成员是一个常量对象或者引用也是一样。根据C++的规则，常量对象和引用不能被赋值，它们只能被初始化。</span><span style="color:#333333;"> </span><br> 第二：基于效率的考虑，不再骜述。</span></span></p> 
<p><span style="color:#333333;"><span style="color:#333333;">需要说明的是，成员初始化列表是按照在类中成员声明的顺序进行初始化的，而不是按照在成员初始化列表里面定义的顺序。</span></span></p> 
<p>参考文章：http://blog.csdn.net/ianchoi/article/details/6917899</p> 
<h2>8、std::vector&lt;std::string&gt;</h2> 
<p><span style="color:#444444;">vector是C++标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的模板类和函数库。vector之所以被认为是一个容器，是因为它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。</span></p> 
<p>为了可以使用vector，必须在你的头文件中包含下面的代码：</p> 
<blockquote> 
 <p>#include &lt;vector&gt;</p> 
</blockquote> 
<p>vector属于std命名域的，因此需要通过命名限定，如下完成你的代码：</p> 
<blockquote> 
 <p>using std::vector;</p> 
</blockquote> 
<p>或者连在一起，使用全名：</p> 
<blockquote> 
 <p>std::vector;</p> 
</blockquote> 
<p>建议使用全局的命名域方式：</p> 
<blockquote> 
 <p>using namespace std;</p> 
</blockquote> 
<p>在后面的操作中全局的命名域方式会造成一些问题。vector容器提供了很多接口，在下面的表中列出vector的成员函数和操作。</p> 
<p>参考文章：http://blog.csdn.net/zhoujiaxq/article/details/9787341</p> 
<p>https://ceeji.net/blog/cpp-std-vector/</p> 
<p>http://blog.csdn.net/infoworld/article/details/15736305</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7e275f0c5ff925ce57f64774835b2f57/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言使用xml2库解析xml文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eaa2201575323a4d623914855aab37f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决 IDEA 控制台中文乱码（三种方法）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>