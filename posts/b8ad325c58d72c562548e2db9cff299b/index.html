<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>八大排序算法之六：快速排序（以中轴值作为排序基准） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="八大排序算法之六：快速排序（以中轴值作为排序基准）" />
<meta property="og:description" content="算法思想 快速排序是对冒泡排序的一种改进： 通过一趟排序，将要排序的数据分割成独立的2部分，其中一部分的所有数据都比另一部分的所有数据都要小，然后再按此方法
对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以达到整个数据变成有序序列。
快排（以中轴数作为基准）的实现： 对序列进行处理的操作，
目的是：依据选择的基准（这里采用的是中轴值pivot），将序列切分称为两个子序列（因为是依照值进行切分的，所以两个子序列大小不一定相等）具体的实现方式：
① 定义两个指针l、r，其中，l的初值为left，r的初值为right ；
② 确定此次划分的中轴值pivot = arr[（left &#43;right）/2] ；
③ 当l &lt; r的时候进行while循环，来进行对序列的按值划分:
&lt;1&gt;对l指针，从左向右遍历，直至遇到一个数，使得arr[l]&lt;pivot不成立；
&lt;2&gt;对r指针，从右向左遍历，直至遇到一个数，使得arr[r]&lt;pivot不成立；
此时，如果l &lt; r，就交换l、r对应的元素的值；否则，退出交换的循环【 如果l == r，表明：此时l(也是r)指针的左右两侧的子序列已经满足：左侧的子序列中的值，都小于等于pivot；右侧子序列中的值，都大于等于pivot。】
== &gt;直到退出进行元素交换的循环，完成了：基于中轴值pivot的，将一个序列按照元素值，划分为两个子序列的操作。
----在这个过程中，需要注意的是：
如果在某一次交换l、r对应的元素值之后，发现arr[l] == pivot，也就是进行交换之前arr[r] == pivot，应该将r指针向前移动一位；同理，如果在某一次交换l、r对应的元素值之后，发现arr[r] == pivot，也就是进行交换之前arr[l] == pivot，应该将l指针向后移动一位；
=&gt;这是因为，交换之前该位的值 == pivot，（那么跟它进行数据交换的位的值就 == pivot）.为防止特殊情况（交换之后该位的值仍==pivot），出现死循环，应该将对应的指针，沿着遍历的方向移动一位。
=&gt;这一点比较难理解，但是一定要注意，不然的话，在运行过程中，很可能会出现死循环（当发生两个等于pivot的值互换的时候）！！！！！！ 在对序列的处理完成后，就开始进入递归模块。 在这里需要注意的是：因为退出前边的处理模块的外层while循环，对应两种情况： 1）l&gt;r 2）l==r
但是，进行递归操作，必须保证：向左递归 和 向右递归到的时候，他们的递归边界不能重合（否则容易发生栈溢出）这是因为l==r退出前边的处理模块的外层while循环时，在进行递归之前，需要让l和r两个指针的位置错开。
—如果这么看不好理解的话，可以看代码实现，可能会比较好理解！！！ 算法实现 // 实现快速排序的方法 public static void quickSort(int[] arr, int left, int right) { int l = left; int r = right; int pivot = arr[(left &#43; right) / 2];// 排序的中轴值 int temp = 0;//用于交换对应元素的临时变量 //是进行递归前的处理操作 while(l &lt; r) { //从左向右找到第一个大于等于pivot的值 while(arr[l] &lt; pivot) { l &#43;= 1; } //从右向左找到第一个小于等于pivot的值 while(arr[r] &gt; pivot) { r -= 1; } //	System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b8ad325c58d72c562548e2db9cff299b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-03T16:02:52+08:00" />
<meta property="article:modified_time" content="2021-06-03T16:02:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">八大排序算法之六：快速排序（以中轴值作为排序基准）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h5><a id="_0"></a>算法思想</h5> 
<h6><a id="_1"></a>快速排序是对冒泡排序的一种改进：</h6> 
<p>通过一趟排序，将要排序的数据分割成独立的2部分，其中一部分的所有数据都比另一部分的所有数据都要小，然后再按此方法<br> 对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以达到整个数据变成有序序列。</p> 
<h6><a id="_4"></a>快排（以中轴数作为基准）的实现：</h6> 
<ol><li> <p>对序列进行处理的操作，</p> 
  <ul><li>目的是：依据选择的基准（这里采用的是中轴值pivot），将序列切分称为两个子序列（因为是依照值进行切分的，所以两个子序列大小不一定相等）</li><li>具体的实现方式：<br> ① 定义两个指针l、r，其中，l的初值为left，r的初值为right ；<br> ② 确定此次划分的中轴值pivot = arr[（left +right）/2] ；<br> ③ 当l &lt; r的时候进行while循环，来进行对序列的按值划分:<br> &lt;1&gt;对l指针，从左向右遍历，直至遇到一个数，使得arr[l]&lt;pivot不成立；<br> &lt;2&gt;对r指针，从右向左遍历，直至遇到一个数，使得arr[r]&lt;pivot不成立；<br> 此时，如果l &lt; r，就交换l、r对应的元素的值；否则，退出交换的循环【 如果l == r，表明：此时l(也是r)指针的左右两侧的子序列已经满足：左侧的子序列中的值，都小于等于pivot；右侧子序列中的值，都大于等于pivot。】<br> == &gt;直到退出进行元素交换的循环，完成了：基于中轴值pivot的，将一个序列按照元素值，划分为两个子序列的操作。<br> ----在这个过程中，需要注意的是：<br> 如果在某一次交换l、r对应的元素值之后，发现arr[l] == pivot，也就是进行交换之前arr[r] == pivot，应该将r指针向前移动一位；同理，如果在某一次交换l、r对应的元素值之后，发现arr[r] == pivot，也就是进行交换之前arr[l] == pivot，应该将l指针向后移动一位；<br> =&gt;这是因为，交换之前该位的值 == pivot，（那么跟它进行数据交换的位的值就 == pivot）.为防止特殊情况（交换之后该位的值仍==pivot），出现死循环，应该将对应的指针，沿着遍历的方向移动一位。<br> =&gt;这一点比较难理解，但是一定要注意，不然的话，在运行过程中，很可能会出现死循环（当发生两个等于pivot的值互换的时候）！！！！！！</li></ul> </li><li> <p>在对序列的处理完成后，就开始进入递归模块。 在这里需要注意的是：因为退出前边的处理模块的外层while循环，对应两种情况： 1）l&gt;r 2）l==r</p> 
  <ul><li>但是，进行递归操作，必须保证：向左递归 和 向右递归到的时候，他们的递归边界不能重合（否则容易发生栈溢出）</li><li>这是因为l==r退出前边的处理模块的外层while循环时，在进行递归之前，需要让l和r两个指针的位置错开。<br> —如果这么看不好理解的话，可以看代码实现，可能会比较好理解！！！</li></ul> </li></ol> 
<h5><a id="_25"></a>算法实现</h5> 
<pre><code class="prism language-java"><span class="token comment">// 实现快速排序的方法</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

		<span class="token keyword">int</span> l <span class="token operator">=</span> left<span class="token punctuation">;</span>
		<span class="token keyword">int</span> r <span class="token operator">=</span> right<span class="token punctuation">;</span>
		<span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 排序的中轴值</span>
		<span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//用于交换对应元素的临时变量</span>
		<span class="token comment">//是进行递归前的处理操作</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//从左向右找到第一个大于等于pivot的值</span>
			<span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				l <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//从右向左找到第一个小于等于pivot的值</span>
			<span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				r <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
<span class="token comment">//			System.out.println("l="+l+",r="+r);</span>
			<span class="token comment">//判断找到的两个值是否发生交叉或者重叠</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span> l <span class="token operator">&gt;=</span> r <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//交换对应的两个元素的值</span>
			temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
			arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>
			arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token comment">//			System.out.println("l="+l+",r="+r+",arr[l]="+arr[l]+",arr[r]="+arr[r]);</span>
			<span class="token comment">//判断发生交换的数，是否等于中轴值pivot，避免在下一轮循环时，在两个小的while循环处，形成死循环</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				r <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				l <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
<span class="token comment">//			System.out.println("l="+l+",r="+r);</span>
		<span class="token punctuation">}</span>
		
<span class="token comment">//		System.out.println("排序的pivot值为："+ pivot +""</span>
<span class="token comment">//				+ ",left="+left+",right="+right</span>
<span class="token comment">//						+ ",l="+l+",r="+r</span>
<span class="token comment">//				+ "排序的结果为："+Arrays.toString(arr));</span>
		
		<span class="token comment">/*
		 * 开始进行递归操作
		 * 分为两个方向：向左递归，向右递归
		 * ----
		 * 但是，在进行递归操作之前，应该对于走出上面的外层while循环的情况进行判断：是满足l==r结束的循环；还是满足l&gt;r结束的循环
		 * =&gt;如果是l==r，标明结束循环的地方，正好是元素值==pivot的地方。
		 * 在下一轮的递归中，不应该取本次的中轴值pivot作为序列的边界上的值。
		 * 应该将l、r两个指针，与pivot的下标值错开：
		 * l += 1;r -= 1;
		 * =&gt;如果是l&gt;r，则可以直接进行递归调用，进入下一轮的递归操作中去
		 */</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			l <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			r <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//进行递归调用</span>
		<span class="token comment">//向左递归</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//向右递归</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p>其实，之前总结过：以当前序列的第一个元素作为基准数进行排序的情况，链接如下：<br> <a href="https://blog.csdn.net/qq_47888755/article/details/115330391">快速排序----以第一个元素作为基准值</a><br> 遇到难的东西，不要慌，进下心来，一点点理解透彻，是可以解决的!!!</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53251da8be28b7aaa20657b2ded4dac6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux系统重置和修改root密码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/50e52481063c83afaba719c4245aef03/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c&#43;&#43;中如何实现十进制(Dec)与十六进制(Hex)之间的相互转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>