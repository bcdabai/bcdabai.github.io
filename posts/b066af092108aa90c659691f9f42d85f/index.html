<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go语言学习-基本 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go语言学习-基本" />
<meta property="og:description" content="命名 如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。（注意区分包内和包外，包内不仅指当前文件，包外是指在整个包的外部，注意这个包包含哪些文件）
声明 Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。
作用域的判断跟C是基本一样的，主要是要理解分析清楚实际是在哪里声明的，应该用在什么地方。
func 一个函数的声明由func关键字、函数名、参数列表、返回值列表（这个例子里的main函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。这样 func main() { 写出来的就是返回值是空的，还可以括号起来多个返回值。
函数和包级别的变量（package-level entities）可以任意顺序声明，并不影响其被调用。
在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。
var var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：
var 变量名字 类型 = 表达式 其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量，数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：
var i, j, k int // int, int, int var b, f, s = true, 2.3, &#34;four&#34; // bool, float64, string 下面这些都等价：
s := &#34;&#34; var s string var s = &#34;&#34; var s string = &#34;&#34; ​在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。
​注意：“:=”是一个变量声明语句，而“=”是一个变量赋值操作。
​简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。但简短变量声明语句中必须至少要声明一个新的变量。
​简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。
​比如一个变量 x 在函数外已经声明了，在函数里再有一个 x := 的话，函数里的这个 x 会被看作一个新的变量，在函数里对已有的 x 进行覆盖。因为“:=”是一个变量声明语句，而“=”是一个变量赋值操作，用 = 的话还是用原来的 x。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b066af092108aa90c659691f9f42d85f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-14T17:36:19+08:00" />
<meta property="article:modified_time" content="2021-05-14T17:36:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go语言学习-基本</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>命名</h2> 
<p>如果是在函数外部定义，那么将在<strong>当前包的所有文件中</strong>都可以访问。<strong>名字的开头字母的大小写决定了名字在包外的可见性</strong>。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。（注意区分包内和包外，包内不仅指当前文件，包外是指在整个包的外部，注意这个包包含哪些文件）<br> <br></p> 
<h2><a id="_8"></a>声明</h2> 
<p>Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。</p> 
<p>作用域的判断跟C是基本一样的，主要是要理解分析清楚实际是在哪里声明的，应该用在什么地方。</p> 
<h3><a id="func_18"></a>func</h3> 
<p>一个函数的声明由<code>func</code>关键字、函数名、参数列表、返回值列表（这个例子里的<code>main</code>函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。这样 <code>func main() {<!-- --></code> 写出来的就是返回值是空的，还可以括号起来多个返回值。</p> 
<p>函数和包级别的变量（package-level entities）可以任意顺序声明，并不影响其被调用。</p> 
<p><strong>在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。</strong><br> <br></p> 
<h3><a id="var_28"></a>var</h3> 
<p>var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> 变量名字 类型 <span class="token operator">=</span> 表达式
</code></pre> 
<p>其中“<em>类型</em>”或“<em>= 表达式</em>”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量，数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p> 
<p>可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token builtin">int</span>                 <span class="token comment">// int, int, int</span>
<span class="token keyword">var</span> b<span class="token punctuation">,</span> f<span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">2.3</span><span class="token punctuation">,</span> <span class="token string">"four"</span> <span class="token comment">// bool, float64, string</span>
</code></pre> 
<br> 
<p>下面这些都等价：</p> 
<pre><code class="prism language-go">s <span class="token operator">:=</span> <span class="token string">""</span>
<span class="token keyword">var</span> s <span class="token builtin">string</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">""</span>
<span class="token keyword">var</span> s <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">""</span>
</code></pre> 
<p>​在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p> 
<p>​注意：“:=”是一个变量声明语句，而“=”是一个变量赋值操作。</p> 
<p>​简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。但简短变量声明语句中必须至少要声明一个新的变量。</p> 
<p>​简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。</p> 
<br> 
<p>​比如一个变量 x 在函数外已经声明了，在函数里再有一个 x := 的话，函数里的这个 x 会被看作一个新的变量，在函数里对已有的 x 进行覆盖。因为“:=”是一个变量声明语句，而“=”是一个变量赋值操作，用 = 的话还是用原来的 x。</p> 
<br> 
<h3><a id="_72"></a>指针</h3> 
<p>如果用“var x int”声明语句声明一个x变量，那么&amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是<code>*int</code>。如果指针名字为p，<code>*p</code>表达式对应p指针指向的变量的值。</p> 
<p>调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。<code>p := new(int) // p, *int 类型, 指向匿名的 int 变量</code>。（new只是一个预定义的函数，它并不是一个关键字）</p> 
<p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> global <span class="token operator">*</span><span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> x <span class="token builtin">int</span>
    x <span class="token operator">=</span> <span class="token number">1</span>
    global <span class="token operator">=</span> <span class="token operator">&amp;</span>x
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    y <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>
    <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>f 函数里的 x 变量必须在堆上分配，<strong>因为它在函数退出后依然可以通过包一级的global变量找到</strong>，虽然它是在函数内部定义的；用Go语言的术语说，<strong>这个x局部变量从函数f中逃逸了</strong>。相反，当g函数返回时，变量<code>*y</code>将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code>并没有从函数g中逃逸，编译器可以选择在栈上分配<code>*y</code>的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。</p> 
<p>其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。如果将<strong>指向短生命周期对象的指针保存到具有长生命周期的对象中</strong>，特别是保存到全局变量时，<strong>会阻止对短生命周期对象的垃圾回收</strong>（从而可能影响程序的性能）。</p> 
<br> 
<h3><a id="type_103"></a>type（类型）</h3> 
<p>一个类型声明语句<strong>创建了一个新的类型名称，和现有类型具有相同的底层结构</strong>。新命名的类型提供了一个方法，<strong>用来分隔不同概念的类型</strong>，这样即使它们底层类型相同也是不兼容的。（就比如同样都是int的底层类型，有的类型名是num，有的类型名是time，那这两个就代表了不同的东西，就会看成是不同的类型来用，虽然其实都是int。然后之后num和time都会当成正常的类型来用，用的方法其实也跟int是一样的）</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> 类型名字 底层类型
</code></pre> 
<p>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。</p> 
<br> 
<p>下面的例子里，Celsius 和 Fahrenheit 就会被当成不同的类型来用，之间就需要类型转换。是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> Celsius <span class="token builtin">float64</span>    <span class="token comment">// 摄氏温度</span>
<span class="token keyword">type</span> Fahrenheit <span class="token builtin">float64</span> <span class="token comment">// 华氏温度</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
    AbsoluteZeroC Celsius <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">273.15</span> <span class="token comment">// 绝对零度</span>
    FreezingC     Celsius <span class="token operator">=</span> <span class="token number">0</span>       <span class="token comment">// 结冰点温度</span>
    BoilingC      Celsius <span class="token operator">=</span> <span class="token number">100</span>     <span class="token comment">// 沸水温度</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">CToF</span><span class="token punctuation">(</span>c Celsius<span class="token punctuation">)</span> Fahrenheit <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token function">Fahrenheit</span><span class="token punctuation">(</span>c<span class="token operator">*</span><span class="token number">9</span><span class="token operator">/</span><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre> 
<p>类型转换不会改变值本身，但是会使它们的语义发生变化。</p> 
<p>对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如<code>(*int)(0)</code>）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。</p> 
<p>数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的。这类转换可能改变值的表现。例如，将一个浮点数转为整数将丢弃小数部分。</p> 
<p>底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。</p> 
<p>​比较运算符<code>==</code>和<code>&lt;</code>也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较。（类型不同的就直接看成不同的，虽然可以类型转换。）</p> 
<br> 
<p>​命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。下面的声明语句，<strong>Celsius类型的参数c出现在了函数名的前面</strong>，表示声明的是Celsius类型的一个名叫String的方法，该方法返回该类型对象c带着°C温度单位的字符串：</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c Celsius<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%g°C"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre> 
<p>用的时候就是 <code>fmt.Println(c.String())</code></p> 
<br> # 赋值 
<p>元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句<strong>右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值</strong>。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样交换两个变量的值：</p> 
<pre><code class="prism language-go">x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> x

a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
</code></pre> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{<!-- --></span>
    x<span class="token punctuation">,</span> y <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
        x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> x<span class="token operator">+</span>y
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> x
<span class="token punctuation">}</span>
</code></pre> 
<p>有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右边一致。</p> 
<pre><code class="prism language-go">f<span class="token punctuation">,</span> err <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"foo.txt"</span><span class="token punctuation">)</span> <span class="token comment">// function call returns two values</span>
</code></pre> 
<br> 
<h2><a id="_184"></a>包</h2> 
<p>Go语言的代码通过<strong>包</strong>（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成，目录定义包的作用。每个源文件都以一条<code>package</code>声明语句开始，这个例子里就是<code>package main</code>，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。</p> 
<p>每个源文件中以包的声明语句开始，<strong>说明该源文件是属于哪个包</strong>。</p> 
<p>比如<code>fmt</code>包，就含有格式化输出、接收输入的函数。<code>Println</code>是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。</p> 
<pre><code class="prism language-go">	<span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hhh"</span><span class="token punctuation">,</span> <span class="token string">"123"</span><span class="token punctuation">)</span> <span class="token comment">//打印出来hhh和123之间是有空格的</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
</code></pre> 
<p>​</p> 
<p><strong><code>main</code>包比较特殊。它定义了一个独立可执行的程序，而不是一个库</strong>。在<code>main</code>里的<code>main</code> 函数 也很特殊，它是整个程序执行时的入口（译注：C系语言差不多都这样）。</p> 
<p>每个包都对应一个独立的名字空间。包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。如果一个名字是大写字母开头的，那么该名字是导出的。</p> 
<p>可以自己写一个包，放在某路径下，然后这样按照路径导入。这就导入了一个名字是 tempconv 的包。这个包里的各文件的开头都要有一个 <code>package tempconv</code>。</p> 
<pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token string">"gopl.io/ch2/tempconv"</span>
</code></pre> 
<p><strong>包的初始化：</strong></p> 
<p>可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
</code></pre> 
<p>这样的init初始化函数除了<strong>不能被调用或引用</strong>外，其他行为和普通函数类似。在每个文件中的init初始化函数，<strong>在程序开始执行时按照它们声明的顺序被自动调用</strong>。</p> 
<p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/861e20b2e4e59fd34d7f5e817a2979e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Go语言学习-数据类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c7bb39fc2700303d35c47f9a3f6fe52f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Arm64内存屏障</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>