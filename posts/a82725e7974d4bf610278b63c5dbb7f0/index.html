<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android中的Activity生命周期以及Task小结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android中的Activity生命周期以及Task小结" />
<meta property="og:description" content="关于activity和task的理解，网上可以找到一箩筐，中文的英文的，不过那始终是别人的理解，这里按照自己的思维习惯记录一下。
1、什么是task？
在Android中Task是为了完成特定功能的一些列activity的集合，是一个LIFO（Last In, First Out。后进先出）的栈，一个back stack（可以通过back键弹出top activity）。
要点：
1、不管Task A中的activity A是新建一个task还是在自己的task中启动activity B，在activity B中按返回键返回的始终是B前面一个activity A（如果A还存在的话），只有一种情况例外，activity B声明了launchMode为signalTask，如果这个时候后台任务中已经有一个Task B包含B，在B中按返回键将返回Task B中activity B的前面一个activity。下面这个图是典型的实例：
2、程序员可以通过下面两种方式来管理task。
1）在AndroidManifest.xml文件的activity属性中定义launchMode.
&#34;standard&#34;
默认的模式，系统会在启动这个activity的task中创建一个实例并把Intent传递给这个activity。这个activity可以被创建多次，各个实例可以存在与不同的task中，一个task也可以存在多个该activity实例。
&#34;singleTop&#34;
如果这个activity已经存在于当前任务并且是top activity，则系统不会另外创建一个实例（如果是standard模式则会另外创建一个），而是将Intent通过onNewIntent传递给这个实例。这个activity也可以被创建多次，各个实例可以存在与不同的task中，一个task同样可以存在多个这个activity的实例，前提是已经存在的activity不是当前任务的top activity。
&#34;singleTask&#34;
系统总是会创建一个新的task，并将这个activity初始化为这个新task的root activity。但是如果已经有另外一个task存在这个activity的实例，系统则不会另外创建，而是通过调用onNewIntent将intent传递给这个activity，任何时候都只有一个该activity的实例存在。（问题：这个时候如果这个activity不是top activity，在这个实例之上的其他activity如何处理？只是简单的将这个activity resume吗？&#34;Note: Although the activity starts in a new task, the BACK key still returns the user to the previous activity.&#34;,从这个note看似乎是这样的，需要测试一下。）
singleTask的意思应该是任何时候只有一个task存在这个activity的实例。
&#34;singleInstance&#34;
与single类似，只有一点不同，系统不会引入任何其他activity到包含这个activity的task中，也就是说，singleInstance的意思是，这个activity是它所在的task的唯一成员，它启动的任何activity都会在其他task中打开。
2）调用startActivity时传入相应的Intent flag。
&#34;FLAG_ACTIVITY_NEW_TASK&#34;
行为与singleTask一样。
&#34;FLAG_ACTIVITY_SINGLE_TOP&#34;
行为与singleTop一样。
&#34;FLAG_ACTIVITY_CLEAR_TOP&#34;
单独使用这个flag时，只在这个activity存在与当前task时起作用，如果这个activity不是top activity，会清掉它上面的所有activity，resume该activity，并且通过onNewIntent传入intent。
这个flag通常和FLAG_ACTIVITY_NEW_TASK一起使用，这时候就会找到后台中存在这个activity的task并且把他放到可以处理这个intent的状态中（清掉它上面的activity）
3、任何activity在收到新的Intent之前都会先被暂停，因此这之后onResume总会被调用到，引用至onNewItem.
4、从eg702t stk和utk的表现来看，即使一个activity已经自杀了（某个时候自己调用finish），也会被am当作仍然存在于task中，因此不再重新创建这个activity，有可能会直接调用onNewIntent，明天去试试。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a82725e7974d4bf610278b63c5dbb7f0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-10-30T00:50:39+08:00" />
<meta property="article:modified_time" content="2011-10-30T00:50:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android中的Activity生命周期以及Task小结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<div style="font-family:Verdana,Arial,Helvetica,sans-serif; margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; font:normal normal normal 13px/19px 'Lucida Grande','Lucida Sans Unicode',Tahoma,Verdana,sans-serif; padding-top:0.6em; padding-right:0.6em; padding-bottom:0.6em; padding-left:0.6em"> 
 <p><span style="font-family:Arial,Verdana,sans-serif; line-height:normal">关于activity和task的理解，网上可以找到一箩筐，中文的英文的，不过那始终是别人的理解，这里按照自己的思维习惯记录一下。</span></p> 
 <p style="font-family:Arial,Verdana,sans-serif; font-size:12px; line-height:normal"> 1、什么是task？</p> 
 <p style="font-family:Arial,Verdana,sans-serif; font-size:12px; line-height:normal"> 在Android中Task是为了完成特定功能的一些列activity的集合，是一个LIFO（Last In, First Out。后进先出）的栈，一个back stack（可以通过back键弹出top activity）。</p> 
 <p style="font-family:Arial,Verdana,sans-serif; font-size:12px; line-height:normal"> <br> </p> 
 <p style="font-family:Arial,Verdana,sans-serif; font-size:12px; line-height:normal"> <br> </p> 
 <p style="font-family:Arial,Verdana,sans-serif; font-size:12px; line-height:normal"> 要点：</p> 
 <p style="font-family:Arial,Verdana,sans-serif; font-size:12px; line-height:normal"> 1、不管Task A中的activity A是新建一个task还是在自己的task中启动activity B，在activity B中按返回键返回的始终是B前面一个activity A（如果A还存在的话），只有一种情况例外，activity B声明了launchMode为signalTask，如果这个时候后台任务中已经有一个Task B包含B，在B中按返回键将返回Task B中activity B的前面一个activity。下面这个图是典型的实例：</p> 
 <p style="font-family:Arial,Verdana,sans-serif; font-size:12px; line-height:normal"> <br> </p> 
 <p><img src="https://images2.imgbox.com/1c/70/8pp9DCGE_o.png" alt="diagram_backstack_singletask_multiactivity" width="737" height="372" style="border-top-width:0px; border-right-width:0px; border-bottom-width:0px; border-left-width:0px; border-style:initial; border-color:initial; border-style:initial; border-color:initial; border-style:initial; border-color:initial"></p> 
 <p>2、程序员可以通过下面两种方式来管理task。</p> 
 <p>  1）在AndroidManifest.xml文件的activity属性中定义launchMode.</p> 
 <p>    "standard"</p> 
 <p>    默认的模式，系统会在启动这个activity的task中创建一个实例并把Intent传递给这个activity。这个activity可以被创建多次，各个实例可以存在与不同的task中，一个task也可以存在多个该activity实例。</p> 
 <p>    "singleTop"</p> 
 <p>    如果这个activity已经存在于当前任务并且是top activity，则系统不会另外创建一个实例（如果是standard模式则会另外创建一个），而是将Intent通过onNewIntent传递给这个实例。这个activity也可以被创建多次，各个实例可以存在与不同的task中，一个task同样可以存在多个这个activity的实例，前提是已经存在的activity不是当前任务的top activity。</p> 
 <p>    "singleTask"</p> 
 <p>    系统总是会创建一个新的task，并将这个activity初始化为这个新task的root activity。但是如果已经有另外一个task存在这个activity的实例，系统则不会另外创建，而是通过调用onNewIntent将intent传递给这个activity，任何时候都只有一个该activity的实例存在。（<span style="color:rgb(255,0,0)">问题：这个时候如果这个activity不是top activity，在这个实例之上的其他activity如何处理？只是简单的将这个activity resume吗？"</span><span style="color:rgb(255,0,0)"><strong>Note:</strong><span style="line-height:16px"> Although the activity starts in a new task, the BACK key still returns the user to the previous activity.",从这个note看似乎是这样的，需要测试一下。</span></span>）</p> 
 <p>    singleTask的意思应该是任何时候只有一个task存在这个activity的实例。</p> 
 <p>    "singleInstance"</p> 
 <p>    与single类似，只有一点不同，系统不会引入任何其他activity到包含这个activity的task中，也就是说，singleInstance的意思是，这个activity是它所在的task的唯一成员，它启动的任何activity都会在其他task中打开。</p> 
 <p>  2）调用startActivity时传入相应的Intent flag。</p> 
 <p>    "FLAG_ACTIVITY_NEW_TASK"</p> 
 <p>    行为与singleTask一样。</p> 
 <p>    "FLAG_ACTIVITY_SINGLE_TOP"</p> 
 <p>    行为与singleTop一样。</p> 
 <p>    "FLAG_ACTIVITY_CLEAR_TOP"</p> 
 <p>    单独使用这个flag时，只在这个activity存在与当前task时起作用，如果这个activity不是top activity，会清掉它上面的所有activity，resume该activity，并且通过onNewIntent传入intent。</p> 
 <p>    这个flag通常和FLAG_ACTIVITY_NEW_TASK一起使用，这时候就会找到后台中存在这个activity的task并且把他放到可以处理这个intent的状态中（清掉它上面的activity）</p> 
 <p>3、任何activity在收到新的Intent之前都会先被暂停，因此这之后onResume总会被调用到，引用至onNewItem.</p> 
 <p>4、从eg702t stk和utk的表现来看，即使一个activity已经自杀了（某个时候自己调用finish），也会被am当作仍然存在于task中，因此不再重新创建这个activity，有可能会直接调用onNewIntent，明天去试试。</p> 
</div> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/82f7bb5f14f572507ffc1dcb3249c290/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">struts2 if 标签 test属性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d86b1437150bc9aece8e202b9bc498f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux Shell 脚本中字符串的连接方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>