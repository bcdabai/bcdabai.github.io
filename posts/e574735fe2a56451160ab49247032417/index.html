<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库之快照读与当前读 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库之快照读与当前读" />
<meta property="og:description" content="1、当前读 即读取最新提交的数据
select … for update
select ... lock in share mode
insert、update、delete，都会按最新提交的数据进行操作
当前读本质上是基于锁的并发读操作
2、快照读 读取某一个快照建立时（可以理解为某一时间点）的数据，也称为一致性读。快照读主要体现在 select 时，而不同隔离级别下，select 的行为不同
在 Serializable 隔离级别下 - 普通 select 也变成当前读，即加共享读锁
在 RC 隔离级别下 - 每次 select 都会建立新的快照
在 RR 隔离级别下
事务启动后，首次 select 会建立快照
如果事务启动选择了 with consistent snapshot，事务启动时就建立快照
基于旧数据的修改操作，会重新建立快照
快照读本质上读取的是历史数据（原理是回滚段），属于无锁查询
2.1、RR 下，快照建立时机 - 第一次 select 时 tx1tx2set session transaction isolation level repeatable read;start transaction;select * from account; /* 此时建立快照，两个账户为 1000 */update account set balance = 2000 where accountNo=1;select * from account; /* 两个账户仍为 1000 */ 快照一旦建立，以后的查询都基于此快照，因此 tx1 中第二次 select 仍然得到 1 号账户余额为 1000" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e574735fe2a56451160ab49247032417/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-29T20:03:07+08:00" />
<meta property="article:modified_time" content="2022-05-29T20:03:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库之快照读与当前读</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong>1、当前读</strong></h3> 
<p>即读取最新提交的数据</p> 
<ul><li> <p>select … for update</p> </li><li> <p>select ... lock in share mode</p> </li><li> <p>insert、update、delete，都会按最新提交的数据进行操作</p> </li></ul> 
<p>当前读本质上是基于锁的并发读操作</p> 
<p></p> 
<h3><strong>2、快照读</strong></h3> 
<p>读取某一个快照建立时（可以理解为某一时间点）的数据，也称为一致性读。快照读主要体现在 select 时，而不同隔离级别下，select 的行为不同</p> 
<ul><li> <p>在 Serializable 隔离级别下 - 普通 select 也变成当前读，即加共享读锁</p> </li><li> <p>在 RC 隔离级别下 - 每次 select 都会建立新的快照</p> </li><li> <p>在 RR 隔离级别下</p> 
  <ul><li> <p>事务启动后，首次 select 会建立快照</p> </li><li> <p>如果事务启动选择了 with consistent snapshot，事务启动时就建立快照</p> </li><li> <p>基于旧数据的修改操作，会重新建立快照</p> </li></ul></li></ul> 
<p>快照读本质上读取的是历史数据（原理是回滚段），属于无锁查询</p> 
<p></p> 
<h4><strong>2.1、RR 下，快照建立时机 - 第一次 select 时</strong></h4> 
<table><thead><tr><th><strong>tx1</strong></th><th><strong>tx2</strong></th></tr></thead><tbody><tr><td>set session transaction isolation level repeatable read;</td><td></td></tr><tr><td>start transaction;</td><td></td></tr><tr><td>select * from account; /* 此时建立快照，两个账户为 1000 */</td><td></td></tr><tr><td></td><td>update account set balance = 2000 where accountNo=1;</td></tr><tr><td>select * from account; /* 两个账户仍为 1000 */</td></tr></tbody></table> 
<ul><li> <p>快照一旦建立，以后的查询都基于此快照，因此 tx1 中第二次 select 仍然得到 1 号账户余额为 1000</p> </li></ul> 
<p><span style="color:#be191c;"><strong>如果 tx2 的 update 先执行</strong></span></p> 
<table><thead><tr><th><strong>tx1</strong></th><th><strong>tx2</strong></th></tr></thead><tbody><tr><td>set session transaction isolation level repeatable read;</td><td></td></tr><tr><td>start transaction;</td><td></td></tr><tr><td></td><td>update account set balance = 2000 where accountNo=1;</td></tr><tr><td>select * from account; /* 此时建立快照，1号余额已经为2000 */</td></tr></tbody></table> 
<p></p> 
<h4><strong>2.2、RR 下，快照建立时机 - 事务启动时</strong></h4> 
<p>如果希望事务启动时就建立快照，可以添加<span style="color:#956fe7;"><strong> with consistent snapshot</strong></span> 选项</p> 
<table><thead><tr><th><strong>tx1</strong></th><th><strong>tx2</strong></th></tr></thead><tbody><tr><td>set session transaction isolation level repeatable read;</td><td></td></tr><tr><td>start transaction with consistent snapshot; /* 此时建立快照，两个账户为 1000 */</td><td></td></tr><tr><td></td><td>update account set balance = 2000 where accountNo=1;</td></tr><tr><td>select * from account; /* 两个账户仍为 1000 */</td></tr></tbody></table> 
<h4><strong>2.3、RR 下，快照建立时机 - 修改数据时</strong>  </h4> 
<table><thead><tr><th><strong>tx1</strong></th><th><strong>tx2</strong></th></tr></thead><tbody><tr><td>set session transaction isolation level repeatable read;</td><td></td></tr><tr><td>start transaction;</td><td></td></tr><tr><td>select * from account; /* 此时建立快照，两个账户为 1000 */</td><td></td></tr><tr><td></td><td>update account set balance=balance+1000 where accountNo=1;</td></tr><tr><td>update account set balance=balance+1000 where accountNo=1;</td><td></td></tr><tr><td>select * from account; /* 1号余额为3000 */</td></tr></tbody></table> 
<ul><li> <p>tx1 内的修改必须重新建立快照，否则，就会发生丢失更新的问题</p> </li></ul> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e904db9c493074ac6b89926cd106114/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C语言习题】输入某年某月某日，判断这一天是这一年的第几天（用数组&#43;switch语句编程）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/da0edf160f9da5ef929000f62c76378e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WebAPI-修改元素样式的方法汇总</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>