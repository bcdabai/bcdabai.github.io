<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux系统编程】静态库和共享库 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Linux系统编程】静态库和共享库" />
<meta property="og:description" content="✍个人博客：https://blog.csdn.net/Newin2020?spm=1011.2415.3001.5343
📚专栏地址：Linux系统编程
📣专栏定位：整理一下 C&#43;&#43; 相关的知识点，供大家学习参考~
❤️如果有收获的话，欢迎点赞👍收藏📁，您的支持就是我创作的最大动力💪
🎏唠叨唠叨：在这个专栏里我会整理一些琐碎的 C&#43;&#43; 知识点，方便大家作为字典查询~
静态库和共享库 1. 区别 静态库
静态库在文件中静态展开，所以有多少文件就展开多少次，非常吃内存，100M 展开 100 次，就是 1G ，但是这样的好处就是静态加载的速度快。
动态库
使用动态库会将动态库加载到内存，10 个文件也只需要加载一次，然后这些文件用到库的时候临时去加载，速度慢一些，但是很省内存。
优缺点
动态库和静态库各有优劣，根据实际情况合理选用即可。
静态库：对空间要求较低，而时间要求较高的核心程序中。动态库：对时间要求较低，对空间要求较高。 2. 静态库制作 Linux ：libxxx.a
lib ：前缀（固定）xxx ：库的名字，自己起.a ：后缀（固定） Windows ：libxxx.lib
静态库生成指令
ar rcs libmylib.a file1.o r - 将文件插入备存文件中c - 建立备存文件s - 索引 生成步骤
第一步： 写好源代码。
第二步： 编译源代码生成 .o 文件。
第三步： 制作静态库。
第四步： 编译静态库到可执行文件中。
gcc test.c lib库名.a -o a.out 编译时出现了函数未定义的警告，可以忽略，让系统生成默认的定义。
下图可以发现 test.c 只占用了 209 大小，而 test 却占用了 16752 ，说明静态库是直接编译到文件中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7ca4a6a925e8da69c67ea929373bea2a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-28T12:30:14+08:00" />
<meta property="article:modified_time" content="2023-03-28T12:30:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux系统编程】静态库和共享库</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>✍个人博客：<a href="https://blog.csdn.net/Newin2020?spm=1011.2415.3001.5343">https://blog.csdn.net/Newin2020?spm=1011.2415.3001.5343</a><br> 📚专栏地址：<a href="https://blog.csdn.net/newin2020/category_12265968.html">Linux系统编程</a><br> 📣专栏定位：整理一下 C++ 相关的知识点，供大家学习参考~<br> ❤️如果有收获的话，欢迎点赞👍收藏📁，您的支持就是我创作的最大动力💪<br> 🎏唠叨唠叨：在这个专栏里我会整理一些琐碎的 C++ 知识点，方便大家作为字典查询~</p> 
</blockquote> 
<h4><a id="_6"></a>静态库和共享库</h4> 
<h5><a id="1__8"></a>1. 区别</h5> 
<p><strong>静态库</strong></p> 
<p>静态库在文件中静态展开，所以有多少文件就展开多少次，非常吃内存，<code>100M</code> 展开 <code>100</code> 次，就是 <code>1G</code> ，但是这样的好处就是静态加载的速度快。</p> 
<p><img src="https://images2.imgbox.com/fe/b7/mdW4GCNj_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WY8zT0Yg-1679977310186)(Linux系统编程.assets/image-20220828214312904.png)]"></p> 
<p><strong>动态库</strong></p> 
<p>使用动态库会将动态库加载到内存，<code>10</code> 个文件也只需要加载一次，然后这些文件用到库的时候临时去加载，速度慢一些，但是很省内存。</p> 
<p><img src="https://images2.imgbox.com/ef/f5/QopjhUQj_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Tbk18a5d-1679977310188)(Linux系统编程.assets/image-20220828214452492.png)]"></p> 
<p><strong>优缺点</strong></p> 
<p>动态库和静态库各有优劣，根据实际情况合理选用即可。</p> 
<ul><li>静态库：对空间要求较低，而时间要求较高的核心程序中。</li><li>动态库：对时间要求较低，对空间要求较高。</li></ul> 
<p><img src="https://images2.imgbox.com/bf/79/JPLH5RdW_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AZejWYSl-1679977310191)(Linux系统编程.assets/image-20220906142434581.png)]"></p> 
<h5><a id="2__36"></a>2. 静态库制作</h5> 
<p><code>Linux</code> ：<code>libxxx.a</code></p> 
<ul><li><code>lib</code> ：前缀（固定）</li><li><code>xxx</code> ：库的名字，自己起</li><li><code>.a</code> ：后缀（固定）</li></ul> 
<p><code>Windows</code> ：<code>libxxx.lib</code></p> 
<p><strong>静态库生成指令</strong></p> 
<pre><code class="prism language-bash">ar rcs libmylib.a file1.o
</code></pre> 
<ul><li>r - 将文件插入备存文件中</li><li>c - 建立备存文件</li><li>s - 索引</li></ul> 
<p><strong>生成步骤</strong></p> 
<p><strong>第一步：</strong> 写好源代码。</p> 
<p><img src="https://images2.imgbox.com/53/52/jw4ffy4R_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iCQgWXo7-1679977310192)(Linux系统编程.assets/image-20220828215250237.png)]"></p> 
<p><strong>第二步：</strong> 编译源代码生成 <code>.o</code> 文件。</p> 
<p><img src="https://images2.imgbox.com/e2/8f/IsqBvoCk_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HkpzsRqk-1679977310198)(Linux系统编程.assets/image-20220828215350493.png)]"></p> 
<p><strong>第三步：</strong> 制作静态库。</p> 
<p><img src="https://images2.imgbox.com/e5/be/VSWF6lYj_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ddciDntN-1679977310209)(Linux系统编程.assets/image-20220828215447563.png)]"></p> 
<p><strong>第四步：</strong> 编译静态库到可执行文件中。</p> 
<pre><code class="prism language-bash">gcc test.c lib库名.a -o a.out
</code></pre> 
<p><img src="https://images2.imgbox.com/e9/82/nFtpZTZM_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CwchdyWe-1679977310212)(Linux系统编程.assets/image-20220828220226568.png)]"></p> 
<blockquote> 
 <p>编译时出现了函数未定义的警告，可以忽略，让系统生成默认的定义。</p> 
</blockquote> 
<p>下图可以发现 <code>test.c</code> 只占用了 <code>209</code> 大小，而 <code>test</code> 却占用了 <code>16752</code> ，说明静态库是直接编译到文件中。</p> 
<p><img src="https://images2.imgbox.com/56/1a/Ny4oX8Pm_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LIhUojAS-1679977310216)(Linux系统编程.assets/image-20220828220531226.png)]"></p> 
<p>上面出现的警告，可以用编译器隐式声明来解决。编译器只能隐式声明返回值为 <code>int</code> 的函数形式：</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span>；
</code></pre> 
<p>如果函数不是返回的 <code>int</code> ，则隐式声明失效，所以会警告。</p> 
<p>那我们只用在 <code>test.c</code> 中加入函数声明即可：</p> 
<p><img src="https://images2.imgbox.com/8c/da/Gt6rzZ9i_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wU94RvU9-1679977310218)(Linux系统编程.assets/image-20220828221654295.png)]"></p> 
<p>这时候再编译就不会警告了：</p> 
<p><img src="https://images2.imgbox.com/86/5f/T1hZSn4T_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FPUBYSQ2-1679977310219)(Linux系统编程.assets/image-20220828221717703.png)]"></p> 
<p>但是这样子做需要库的使用者知道库里的函数，然后再一个一个加到代码里，不是很科学，我们可以用下面这种方法来加载静态库。</p> 
<p><img src="https://images2.imgbox.com/21/6e/bU1nHWZ9_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-huAlQ1Py-1679977310223)(Linux系统编程.assets/image-20220828222251544.png)]"></p> 
<p>右边的 <code>define</code> 为头文件守卫，防止在代码中多次 <code>include</code> 同一个头文件，多次展开静态库，带来的额外开销。</p> 
<p>然后我们同样进行编译，发现也不会报错，但是这样子写更好一些。</p> 
<p><img src="https://images2.imgbox.com/da/50/nxVTrSrW_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2chDyEDB-1679977310224)(Linux系统编程.assets/image-20220828222504612.png)]"></p> 
<p>当然，我们可以将静态库和头文件分别放至其他目录下，然后再模拟一遍。</p> 
<p><img src="https://images2.imgbox.com/fe/e9/2fb9iZV6_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aPjoqBHe-1679977310226)(Linux系统编程.assets/image-20220828224844129.png)]"></p> 
<p>然后运行结果。</p> 
<p><img src="https://images2.imgbox.com/96/fd/3fBU8oy3_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EbS6F6eW-1679977310228)(Linux系统编程.assets/image-20220828224939700.png)]"></p> 
<h5><a id="3__135"></a>3. 动态库制作</h5> 
<p><code>Linux</code> ：<code>libxxx.so</code></p> 
<ul><li> <p><code>lib</code> ：前缀（固定）</p> </li><li> <p><code>xxx</code> ：库的名字，自己起</p> </li><li> <p><code>.so</code> ：后缀（固定）</p> </li><li> <p>在 <code>Linux</code> 下是一个可执行文件</p> </li></ul> 
<p><code>Windows</code> ：<code>libxxx.dll</code></p> 
<p><strong>制作步骤</strong></p> 
<ol><li>将 <code>.c</code> 生成 <code>.o</code> 文件（生成与位置无关的代码 <code>-fPIC</code>）</li></ol> 
<pre><code class="prism language-bash">gcc -c add.c -o add.o -fPIC
</code></pre> 
<p>使用这个参数过后，生成的函数就和位置无关，挂上 <code>@plt</code> 标识，等待动态绑定。</p> 
<ol start="2"><li>使用 <code>gcc -shared</code> 制作动态库</li></ol> 
<pre><code class="prism language-bash">gcc -shared -o lib库名.so add.o sub.o div.o
</code></pre> 
<ol start="3"><li>编译可执行程序时指定所使用的动态库</li></ol> 
<p><code>-l</code> ：指定库名；<code>-L</code> ：指定库路径</p> 
<pre><code class="prism language-bash">gcc test.c -o a.out -l mymath -L ./lib
</code></pre> 
<ol start="4"><li>运行可执行程序 <code>./a.out</code></li></ol> 
<p><strong>过程演示</strong></p> 
<p>步骤一：生成位置无关的 <code>.o</code> 文件</p> 
<p><img src="https://images2.imgbox.com/8d/29/rDSspdUW_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-weLgB4zZ-1679977310229)(Linux系统编程.assets/image-20220830213028856.png)]"></p> 
<p>步骤二：制作动态库 <code>gcc -shared -o lib</code> 库名 <code>.so add.o</code></p> 
<p><img src="https://images2.imgbox.com/e8/44/9NqqxY9T_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FvFofyS6-1679977310231)(Linux系统编程.assets/image-20220830213130736.png)]"></p> 
<p>步骤三：编译程序</p> 
<p>文件分布如下：动态库在 <code>lib</code> 目录下，头文件在 <code>inc</code> 目录下。</p> 
<p><img src="https://images2.imgbox.com/7b/85/VVTBr9yh_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rbmwUAiz-1679977310232)(Linux系统编程.assets/image-20220830213817870.png)]"></p> 
<p>下面编译文件。</p> 
<p><img src="https://images2.imgbox.com/5a/4e/qrPzM4Ca_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Vmts60kk-1679977310233)(Linux系统编程.assets/image-20220830213916958.png)]"></p> 
<p>步骤四：执行文件，出错</p> 
<p><img src="https://images2.imgbox.com/39/6f/rhHIpE0l_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3UcVnTxH-1679977310234)(Linux系统编程.assets/image-20220830213945964.png)]"></p> 
<p>出错原因分析：</p> 
<ul><li>连接器：工作于链接阶段，工作时需要 <code>-l</code> 和 <code>-L</code> 。</li><li>动态链接器：工作于程序运行阶段，工作时需要提供动态库所在目录位置。</li></ul> 
<p><strong>解决方法</strong></p> 
<p>（1）通过环境变量，但是临时生效</p> 
<p>指定动态库路径并使其生效，然后再执行文件。</p> 
<p>通过环境变量指定动态库所在位置：</p> 
<pre><code class="prism language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span>动态库路径
</code></pre> 
<p><img src="https://images2.imgbox.com/88/eb/TVAKxyMG_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qMcyOwDq-1679977310235)(Linux系统编程.assets/image-20220830215702559.png)]"></p> 
<p>当关闭终端，再次执行 <code>a.out</code> 时，又报错。</p> 
<p>这是因为，环境变量是进程的概念，关闭终端之后再打开，是两个进程，环境变量发生了变化。</p> 
<p>（2）修改配置文件，永久生效</p> 
<p>要想永久生效（建议写入绝对路径）：</p> 
<ol><li> <p>需要修改 <code>bash</code> 的配置文件：<code>vi ~./bashrc</code> ，写入 <code>export LD_LIBRARY_PATH=动态库路径</code> 并保存。</p> </li><li> <p>修改后要使配置文件立即生效：<code>. .bashrc</code> 或者 <code>source .bashrc</code> 或者重开终端让其自己加载。</p> </li><li> <p>这下再执行 <code>a.out</code> 就不会报错了。</p> </li></ol> 
<p>（3）移动动态库（不推荐）</p> 
<p>拷贝自定义动态库 到 <code>/lib</code> (标准 <code>C</code> 库所在目录位置)</p> 
<p>（4）配置文件法（最难）</p> 
<p>① <code>sudo vi /etc/ld.so.conf</code></p> 
<p>② 写入动态库绝对路径保存</p> 
<p>③ <code>sudo ldconfig -v</code> 使配置文件生效</p> 
<p>④ <code>./a.out</code> 成功 — 使用 <code>ldd a.out</code> 查看</p> 
<h5><a id="4__256"></a>4. 工作原理</h5> 
<p><strong>静态库：</strong> GCC 进行链接时，会把静态库中代码打包到可执行程序中。</p> 
<p><strong>动态库：</strong> GCC 进行链接时，动态库的代码不会打包到可执行程序中。</p> 
<p>程序启动之后，动态库会被动态加载到内存中，通过 ldd 命令检查动态库依赖关系。</p> 
<p><strong>如何定位共享文件呢？</strong></p> 
<p>当系统加载可执行代码的时候，能够知道所依赖库的名字，但是还需要知道绝对路径。对于 elf 格式的可执行程序，是由 ld-linux.so 来完成的，它先后搜索 elf 文件的 DT_RPATH 段 --&gt; 环境变量 LD_LIBRARY_PATH --&gt; /etc/ld.so.cache 文件列表 --&gt; /lib/，/usr/lib 目录找到库文件后将其载入内存。</p> 
<h5><a id="5__270"></a>5. 区别</h5> 
<p><img src="https://images2.imgbox.com/04/0b/FxZ6FdLI_o.png" alt=""></p> 
<h6><a id="_275"></a>静态库</h6> 
<p><img src="https://images2.imgbox.com/3a/e8/ZR65ODVY_o.png" alt=""></p> 
<p><strong>优点：</strong></p> 
<ul><li>静态库被打包到应用程序中，加载速度快</li><li>发布程序无需提供静态库，移植方便</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>消耗系统资源，浪费内存</li><li>更新、部署、发布麻烦</li></ul> 
<p><img src="https://images2.imgbox.com/b9/56/FanBHHi1_o.png" alt=""></p> 
<h6><a id="_293"></a>动态库</h6> 
<p><img src="https://images2.imgbox.com/d3/14/1ibiJPvv_o.png" alt=""></p> 
<p><strong>优点：</strong></p> 
<ul><li>可以实现进程间资源共享（共享库）</li><li>更新、部署、发布简单</li><li>可以控制何时加载动态库</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>加载速度比静态库慢</li><li>发布程序时需要提供依赖的动态库</li></ul> 
<p><img src="https://images2.imgbox.com/9f/2a/PquLWGyN_o.png" alt=""></p> 
<blockquote> 
 <p>参考资料：<br> https://www.bilibili.com/video/BV1fy4y1b7TC/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=12c90255e5a0009cd588cada10859bd5<br> https://www.nowcoder.com/study/live/504</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86efd3d5412533a476f0c22abf4fbdb5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows环境下GPU版本pytorch安装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07f55960d341fc7883c0eac468d99fa6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【无标题】org.apache.hadoop.ipc.RemoteException</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>