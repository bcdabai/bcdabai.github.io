<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java多线程5---线程优化：线程池、锁优化 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java多线程5---线程优化：线程池、锁优化" />
<meta property="og:description" content="一、线程池 1、线程池优点 （1）提前创建多个线程放在线程池，使用时直接获取，使用完放回池中待用
避免频繁创建销毁线程的内存资源消耗，实现线程的重复利用。
（2）提高响应速度---减少了创建新线程的时间
（3）便于线程的管理（容器思想）
2、线程池的具体实现--executorService exexutor （1）通过exexutors调用newFixedThreadPool创建固定大小的线程池对象， ExecutorService 类型的对象
（2）通过该对象调用execute（）方法，将要启动的线程放入线程池
（3）关闭线程池--shutdown（）
//1、创建最大线程数为10的线程服务，线程池 ExecutorService threadServices=Executor.newFixedThreadPool(10); //2、执行，添加线程，添加线程数为当前线程池内线程数 threadServices.execute(new MyThread()); threadServices.execute(new MyThread()); threadServices.execute(new MyThread()); //3、关闭连接 threadServices.shutdown(); 【注】 创建线程池的几种方法（静态工厂方法） （1）newFixedThreadPool 固定大小的线程池 ---核心线程数也是最大线程数，不存在空闲线程，阻塞队列：LinkedBlockingQueue【快】
（2）newSingleThreadExecutor 单线程 ---适用于保证顺序执行任务的场景【慢】
（3）newCachedThreadPool 可伸缩线程池---最大线程数为integer最大值（2^31-1），阻塞队列：SynchoronousQueue【最快】
（4）newScheduleThreadPool ---最大线程数为integer最大值，不会回收工作线程，容易出现OOM
（5）newworkStealingPool ---jdk8新引入，创建持有足够线程的线程池支持给定的并行度， 通过多个队列减少竞争。
线程池启动线程的两种方式 service.execute（new 线程）----该线程是继承runnable接口的，没有返回值
service.submit（new 线程）----该线程是继承Callable接口的，有返回值
关闭线程池 shutdown---线程池的状态设为SHUTDOWN
中断没有正在执行任务的线程，不中断未完成的线程
shutdownNow--线程状态改为STOP
尝试停止正在执行或暂停任务的线程，并返回等待执行任务列表，中断未完成的线程
3、线程池的核心参数 核心线程数--corePoolSize--目前线程池中存在的线程数（长时间稳定存活的线程数） 线程数超过此数时，会通过线程空闲时间进行线程销毁
工作队列--workQueue--请求&gt;核心线程数部分，放入工作队列等待最大线程数--maxmumPoolSize--线程池允许的最多线程数拒绝策略--handler--当请求量&gt;最大线程数时，拒绝请求，选择合适的拒绝策略线程空闲时间--keep AliveTime---达到某个值被销毁，避免浪费内存资源 当线程数&lt;核心线程数---创建新线程
当请求数&gt;工作队列数--- 创建新线程 当请求数&gt;核心线程数----线程进入阻塞队列
当线程数&gt;核心线程数---按照线程空闲时间销毁线程
4、线程池执行过程 每当有新的任务到线程池时，
（1） 先判断线程池中当前线程数量是否达到了corePoolSize，若未达到，则新建线程运行此任务，且任务结束后将该线程保留在线程池中，不做销毁处理，若当前线程数量已达到corePoolSize，则进入下一步；
（2） 判断工作队列(workQueue)是否已满，未满则将新的任务提交到工作队列中，满了则进入下一步；
（3） 判断线程池中的线程数量是否达到了maxumunPoolSize，如果未达到，则新建一个工作线程来执行这个任务，如果达到了则使用饱和策略来处理这个任务。
【注】" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/512b7984d1b814fac01e8849c1366686/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-23T23:54:16+08:00" />
<meta property="article:modified_time" content="2021-09-23T23:54:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java多线程5---线程优化：线程池、锁优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、线程池</h2> 
<h3>1、线程池优点</h3> 
<p>  （1）提前创建多个线程放在线程池，使用时直接获取，使用完放回池中待用</p> 
<p>            避免频繁创建销毁线程的内存资源消耗，实现线程的重复利用。</p> 
<p>  （2）提高响应速度---减少了创建新线程的时间</p> 
<p>  （3）便于线程的管理（容器思想）</p> 
<h3>2、线程池的具体实现--executorService  exexutor  </h3> 
<p>（1）通过<strong>exexutors</strong>调用<strong>newFixedThreadPool</strong>创建<strong>固定大小</strong>的线程池对象，         </p> 
<p>          ExecutorService  类型的对象</p> 
<p>（2）通过该对象调用<strong>execute（）</strong>方法，将要启动的线程放入线程池</p> 
<p>（3）关闭线程池--<strong>shutdown（）</strong></p> 
<pre><code>//1、创建最大线程数为10的线程服务，线程池
ExecutorService  threadServices=Executor.newFixedThreadPool(10);
//2、执行，添加线程，添加线程数为当前线程池内线程数
 threadServices.execute(new MyThread());
 threadServices.execute(new MyThread());
 threadServices.execute(new MyThread());
//3、关闭连接
 threadServices.shutdown();</code></pre> 
<p>【注】    </p> 
<ul><li>创建线程池的几种方法（静态工厂方法）</li></ul> 
<blockquote> 
 <p>（1）<strong>newFixedThreadPool </strong>  固定大小的线程池 ---核心线程数也是最大线程数，不存在空闲线程，阻塞队列：LinkedBlockingQueue【快】</p> 
 <p>（2）<strong>newSingleThreadExecutor  </strong>单线程 ---适用于保证顺序执行任务的场景【慢】</p> 
 <p>（3）<strong>newCachedThreadPool  </strong>可伸缩线程池---最大线程数为integer最大值（2^31-1），阻塞队列：SynchoronousQueue【最快】</p> 
 <p>（4）<strong>newScheduleThreadPool  ---</strong>最大线程数为integer最大值，不会回收工作线程，容易出现OOM</p> 
 <p>（5）<strong>newworkStealingPool ---</strong>jdk8新引入，创建持有足够线程的线程池支持给定的并行度， 通过多个队列减少竞争。</p> 
</blockquote> 
<ul><li><strong>线程池启动线程的两种方式</strong></li></ul> 
<p><strong>  service.execute（new 线程）-</strong>---该线程是继承runnable接口的，没有返回值</p> 
<p><strong>  service.submit（new 线程）</strong>----该线程是继承Callable接口的，有返回值</p> 
<ul><li><strong>关闭线程池</strong></li></ul> 
<p><strong>   shutdown</strong>---线程池的状态设为SHUTDOWN</p> 
<p>                       中断没有正在执行任务的线程，不中断未完成的线程</p> 
<p><strong>   shutdownNow--</strong>线程状态改为STOP</p> 
<p>                      尝试停止正在执行或暂停任务的线程，并返回等待执行任务列表，中断未完成的线程</p> 
<p></p> 
<h3>3、线程池的核心参数</h3> 
<ul><li> 核心线程数--corePoolSize--目前线程池中存在的线程数（长时间稳定存活的线程数）</li></ul> 
<p>                                                    <span style="color:#4da8ee;">线程数超过此数时，会通过线程空闲时间进行线程销毁</span></p> 
<ul><li>工作队列--workQueue--请求&gt;核心线程数部分，放入工作队列等待</li><li>最大线程数--maxmumPoolSize--线程池允许的最多线程数</li><li>拒绝策略--handler--当请求量&gt;最大线程数时，拒绝请求，选择合适的拒绝策略</li><li>线程空闲时间--keep AliveTime---达到某个值被销毁，避免浪费内存资源</li><li></ul> 
<p>  当线程数&lt;核心线程数---创建新线程</p> 
<p>  当请求数&gt;工作队列数--- 创建新线程   </p> 
<p>  当请求数&gt;核心线程数----线程进入阻塞队列</p> 
<p>  当线程数&gt;核心线程数---按照线程空闲时间销毁线程</p> 
<p></p> 
<h3>4、线程池执行过程</h3> 
<p><br>  每当有新的任务到线程池时，<br> （1） 先判断线程池中当前线程数量是否达到了corePoolSize，若未达到，则新建线程运行此任务，且任务结束后将该线程保留在线程池中，不做销毁处理，若当前线程数量已达到corePoolSize，则进入下一步；<br> （2） 判断工作队列(workQueue)是否已满，未满则将新的任务提交到工作队列中，满了则进入下一步；<br> （3） 判断线程池中的线程数量是否达到了maxumunPoolSize，如果未达到，则新建一个工作线程来执行这个任务，如果达到了则使用饱和策略来处理这个任务。</p> 
<p> 【注】</p> 
<p>     在线程池中的线程数量超过corePoolSize时，每当有线程的空闲时间超过了keepAliveTime，这个线程就会被终止。直到线程池中线程的数量不大于corePoolSize为止。</p> 
<p>    corePoolSize：核心线程数----Java<span style="color:#4da8ee;"><strong>线程池中会长期保持corePoolSize个线程</strong></span></p> 
<p>    maximunPoolSize：线程池最大线程数</p> 
<p></p> 
<p>参考：<a href="https://blog.csdn.net/qq_33323054/article/details/106923732?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link" title="Java线程池核心线程数与最大线程数的区别_July的博客-CSDN博客_核心线程数和最大线程数">Java线程池核心线程数与最大线程数的区别_July的博客-CSDN博客_核心线程数和最大线程数</a></p> 
<h3>5、线程池的选择策略</h3> 
<p>  cpu密集型任务---<span style="color:#4da8ee;">切换频繁快</span>---<strong>小</strong>线程池</p> 
<p>  IO密集型任务---<span style="color:#4da8ee;">不是一直执行任务</span>---<strong>大</strong>线程池</p> 
<p>  依赖其他资源，如数据库连接池---<span style="color:#4da8ee;">等待时间久</span>---<strong>大</strong>线程池</p> 
<p>  优先级不同的任务---<span style="color:#4da8ee;">优先级队列</span>---priorityBlockingQueue</p> 
<h3>6、拒绝策略</h3> 
<p>  <strong>AbortPolicy</strong>---丢弃任务并抛出异常（ 默认使用）<strong>【丢弃+异常】</strong></p> 
<p><strong>  CallerRunsPolicy</strong>---重新尝试提交该任务<strong>【重新提交】</strong></p> 
<p><strong>  DiscardOldestPolicy</strong>---抛弃队列里等待最久的任务，并把当前任务加入队列<strong>【最久+队列】</strong></p> 
<p><strong>  DiscardPolicy</strong>---直接抛弃当前任务，但不抛异常<strong>【直接丢弃】</strong></p> 
<h3>7、阻塞队列（工作队列）</h3> 
<p>阻塞队列相当于一个缓冲区，生产者和消费者可以以此来通信</p> 
<p>常见阻塞队列：</p> 
<ul><li> <strong>ArrayBlockingQueue</strong> <span style="color:#4da8ee;">基于数组的</span><span style="color:#fe2c24;">有界</span><span style="color:#4da8ee;">阻塞队列</span></li></ul> 
<p>      即队列有界，其内部实现是将对象放到一个数组里</p> 
<ul><li><strong>LinkedBlockingQueue </strong><span style="color:#4da8ee;">基于链表的</span><span style="color:#fe2c24;">有界</span><span style="color:#4da8ee;">阻塞队列</span></li></ul> 
<p>     队列默认最大长度为Integer最大值 2^31-1</p> 
<ul><li><strong>LinkedTransferQueue</strong> <span style="color:#4da8ee;">基于链表的</span><span style="color:#fe2c24;">无界</span><span style="color:#4da8ee;">阻塞队列</span></li></ul> 
<p>     tryTransfer（）--若当前有消费者正在等待接收元素，可将生产者传入的元素立刻传输给消费者</p> 
<p>    Transfer（）--试探生产者传入的元素能否直接传给消费者，无消费者等待，则返回false</p> 
<p>区别：transfer：物理消费者是否消费都会立即返回（机制有点类似消息队列的推拉模式）</p> 
<ul><li><strong>LinkedBlockingDeque</strong> <span style="color:#4da8ee;">基于链表的双向阻塞队列</span></li></ul> 
<p>    队列两端插入和移出元素，多线程同时入队时减少竞争</p> 
<ul><li><strong>DelayBlockingQueue</strong> <span style="color:#4da8ee;">延时获取元素</span><span style="color:#fe2c24;">无界</span><span style="color:#4da8ee;">阻塞队列</span></li></ul> 
<p>     对元素持有直到一个特定的延迟到期</p> 
<p>    getDelay()：获取元素延期值，0或负值---过期，正值---需延期或等待清除的时间</p> 
<ul><li><strong>PriorityBlockingQueue</strong> <span style="color:#4da8ee;"> 具体优先级的</span><span style="color:#fe2c24;">无界</span><span style="color:#4da8ee;">阻塞队列 </span></li></ul> 
<p>     无界并发队列</p> 
<p>    具有排序规则，无法插入null值，插入到该队列的元素必须实现<strong>Comparable接口</strong></p> 
<ul><li><strong>SynchronousQueue</strong> <span style="color:#4da8ee;">同步队列</span></li></ul> 
<p>   每个put必须等待一个take  排队进行 </p> 
<h4 id="具有优先级的阻塞队列-priorityblockingqueue"></h4> 
<p>此部分参考：</p> 
<p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-BlockingQueue.html" rel="nofollow" title="JUC集合: BlockingQueue详解 | Java 全栈知识体系">JUC集合: BlockingQueue详解 | Java 全栈知识体系</a></p> 
<p>待补充</p> 
<p><span style="color:#0d0016;">【注】</span><span style="color:#fe2c24;">线程优化的重点:选择合适的线程池，并设置合适的核心参数</span></p> 
<p><span style="color:#fe2c24;">           关注响应时间、线程性能、线程和内存使用情况等方面</span></p> 
<p></p> 
<h2>二、锁优化</h2> 
<h3>（一）锁优化思路</h3> 
<p>   1.减少锁的持有时间（对需要同步的几行代码进行加锁）</p> 
<p>    2.减少锁的粒度 （ConcurrentHashMap采取对segment加锁而不是整个map加锁）</p> 
<p>    3.锁分离（将锁划分为读锁和写锁，相互不互斥）</p> 
<p>    4.锁粗化（一个间隔性地需要执行同步语句的线程中，如果在不连续的同步块间频繁加锁解锁是很耗性能的，因此把加锁范围扩大总体来说是优化的）<br><br>    此部分来源：<a href="https://www.jianshu.com/p/aa893f64dd70" rel="nofollow" title="java多线程锁的优化策略 - 简书">java多线程锁的优化策略 - 简书</a></p> 
<h3>（二）JVM锁优化</h3> 
<h4>1、自旋锁</h4> 
<p>   通过忙循环形式自旋等待，而不是对线程频繁挂起</p> 
<h4><br> 2、自适应自旋</h4> 
<p><br>     自适应自旋意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p> 
<h4><br> 3、锁清除</h4> 
<p>    将不可能存在共享数据竞争的锁进行消除。</p> 
<h4>4、锁粗化</h4> 
<p>    如果虚拟机探测到有一系列连续操作都对同一个对象反复加锁和解锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p> 
<h4>5、锁升级</h4> 
<p>  <strong>偏向锁（无CAS）----&gt;轻量级锁（CAS+自旋等待）-----&gt;重量级锁（CAS+阻塞队列）</strong></p> 
<p><br> 此部分详见锁机制部分：<a href="https://blog.csdn.net/qq_44641527/article/details/120384413?spm=1001.2014.3001.5501" title="(1条消息) Java多线程2---线程同步和异步、线程安全、锁机制_@snow＇的博客-CSDN博客">(1条消息) Java多线程2---线程同步和异步、线程安全、锁机制_@snow＇的博客-CSDN博客</a></p> 
<p>   </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8020d6c24fdd033fb011dc308293a732/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">常见游戏外挂分类及原理概述</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/12a620447527f408c8e243bf4d77c3c8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决gitclone报错 无法访问‘https://github.com/xxx.git/‘：GnuTLS recv error</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>