<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法题--哈希（两数之和、给定差值的组合、最小权重路径解法加步骤） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法题--哈希（两数之和、给定差值的组合、最小权重路径解法加步骤）" />
<meta property="og:description" content="目录
哈希算法思想
题目
两数之和
原题链接
解析
核心思想
答案
给定差值的组合
题目描述
解答要求
解析
核心思想
答案
最佳路径
题目描述
解答要求
解析
核心思想
递归步骤
答案
哈希算法思想 利用对象属性作为key值，通过唯一个key值，访问对应的存储的值。相当于形成映射关系，便于直接查找值。
例如一个数组有a、b、c三数，我们可以借用一个对象obj，让obj[&#34;a&#34;]=1、obj[&#34;b&#34;]=1、obj[&#34;c&#34;]=1，当我们需要查找该数组中是否包含d的时候就不需要遍历每个数，只需要判断obj[&#34;d&#34;]是否等于1即可。
题目 两数之和 给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。
（注：返回的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到）
输入：[3,2,4],6
返回值：[2,3]
说明：因为 2&#43;4=6 ，而 2的下标为2 ， 4的下标为3 ，又因为 下标2 &lt; 下标3 ，所以返回[2,3]
输入：[20,70,110,150],90
返回值：[1,2]
说明：20&#43;70=90
原题链接 两数之和_牛客题霸_牛客网
解析 核心思想 由于需要判断两数相加等于目标值的，所以可以采用减法，用目标值减去当前数对数组的每一位判断是否满足条件，得出下面注释的方法。
通过hash算法优化，将目标值减去当前数作为属性，当前数的序号作为值，当数组中有对应属性的值时即满足相加为目标值，返回序号。
答案 // 不使用hash算法，直接穷举 // function twoSum(numbers, target) { // let tmp = -1 // for (let i = 0; i &lt; numbers." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dbe5377dd771b4f33b4d06c878d3df54/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-15T15:06:17+08:00" />
<meta property="article:modified_time" content="2023-03-15T15:06:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法题--哈希（两数之和、给定差值的组合、最小权重路径解法加步骤）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="main-toc-toc" style="margin-left:0px;"><a href="#main-toc" rel="nofollow">哈希算法思想</a></p> 
<p id="%E9%A2%98%E7%9B%AE-toc" style="margin-left:0px;"><a href="#%E9%A2%98%E7%9B%AE" rel="nofollow">题目</a></p> 
<p id="%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-toc" style="margin-left:40px;"><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C" rel="nofollow">两数之和</a></p> 
<p id="%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-toc" style="margin-left:80px;"><a href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5" rel="nofollow">原题链接</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3" rel="nofollow">核心思想</a></p> 
<p id="%E7%AD%94%E6%A1%88-toc" style="margin-left:80px;"><a href="#%E7%AD%94%E6%A1%88" rel="nofollow">答案</a></p> 
<p id="%E7%BB%99%E5%AE%9A%E5%B7%AE%E5%80%BC%E7%9A%84%E7%BB%84%E5%90%88-toc" style="margin-left:40px;"><a href="#%E7%BB%99%E5%AE%9A%E5%B7%AE%E5%80%BC%E7%9A%84%E7%BB%84%E5%90%88" rel="nofollow">给定差值的组合</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" rel="nofollow">题目描述</a></p> 
<p id="%E8%A7%A3%E7%AD%94%E8%A6%81%E6%B1%82-toc" style="margin-left:80px;"><a href="#%E8%A7%A3%E7%AD%94%E8%A6%81%E6%B1%82" rel="nofollow">解答要求</a></p> 
<p id="%E7%AD%94%E6%A1%88-toc" style="margin-left:40px;"><a href="#%E7%AD%94%E6%A1%88" rel="nofollow">解析</a></p> 
<p id="%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3" rel="nofollow">核心思想</a></p> 
<p id="%E7%AD%94%E6%A1%88-toc" style="margin-left:80px;"><a href="#%E7%AD%94%E6%A1%88" rel="nofollow"> 答案</a></p> 
<p id="%E6%9C%80%E4%BD%B3%E8%B7%AF%E5%BE%84-toc" style="margin-left:40px;"><a href="#%E6%9C%80%E4%BD%B3%E8%B7%AF%E5%BE%84" rel="nofollow">最佳路径</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" rel="nofollow">题目描述</a></p> 
<p id="%E8%A7%A3%E7%AD%94%E8%A6%81%E6%B1%82-toc" style="margin-left:80px;"><a href="#%E8%A7%A3%E7%AD%94%E8%A6%81%E6%B1%82" rel="nofollow">解答要求</a></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3" rel="nofollow">核心思想</a></p> 
<p id="%E9%80%92%E5%BD%92%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#%E9%80%92%E5%BD%92%E6%AD%A5%E9%AA%A4" rel="nofollow">递归步骤</a></p> 
<p id="%C2%A0%E7%AD%94%E6%A1%88-toc" style="margin-left:80px;"><a href="#%C2%A0%E7%AD%94%E6%A1%88" rel="nofollow"> 答案</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>哈希算法思想</h2> 
<p>利用对象属性作为key值，通过唯一个key值，访问对应的存储的值。相当于形成映射关系，便于直接查找值。</p> 
<p>例如一个数组有a、b、c三数，我们可以借用一个对象obj，让obj["a"]=1、obj["b"]=1、obj["c"]=1，当我们需要查找该数组中是否包含d的时候就不需要遍历每个数，只需要判断obj["d"]是否等于1即可。</p> 
<h2 id="%E9%A2%98%E7%9B%AE">题目</h2> 
<h3 id="%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">两数之和</h3> 
<p>给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。</p> 
<p>（注：<strong>返回</strong>的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到）</p> 
<p>输入：[3,2,4],6</p> 
<p>返回值：[2,3]</p> 
<p>说明：因为 2+4=6 ，而 2的下标为2 ， 4的下标为3 ，又因为 下标2 &lt; 下标3 ，所以返回[2,3]</p> 
<p>输入：[20,70,110,150],90</p> 
<p>返回值：[1,2]</p> 
<p>说明：20+70=90</p> 
<h4 id="%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5">原题链接</h4> 
<p><a href="https://www.nowcoder.com/practice/20ef0972485e41019e39543e8e895b7f?tpId=295&amp;tqId=745&amp;ru=%2Fpractice%2F96bd6684e04a44eb80e6a68efc0ec6c5&amp;qru=%2Fta%2Fformat-top101%2Fquestion-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295" rel="nofollow" title="两数之和_牛客题霸_牛客网">两数之和_牛客题霸_牛客网</a></p> 
<h3 id="%E8%A7%A3%E6%9E%90">解析</h3> 
<h4 id="%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3">核心思想</h4> 
<p>由于需要判断两数相加等于目标值的，所以可以采用减法，用目标值减去当前数对数组的每一位判断是否满足条件，得出下面注释的方法。</p> 
<p>通过hash算法优化，将目标值减去当前数作为属性，当前数的序号作为值，当数组中有对应属性的值时即满足相加为目标值，返回序号。</p> 
<h4 id="%E7%AD%94%E6%A1%88">答案</h4> 
<pre><code class="language-javascript">// 不使用hash算法，直接穷举
// function twoSum(numbers, target) {
// 	let tmp = -1
// 	for (let i = 0; i &lt; numbers.length; i++) {
// 		tmp = numbers.findIndex((v, index) =&gt; v === target - numbers[i] &amp;&amp; i !== index)
// 		if (tmp !== -1) {
// 			return [i + 1, tmp + 1]
// 		}
// 	}
// }
function twoSum(numbers, target) {
	let map = {}
	for (let i = 0; i &lt; numbers.length; i++) {
		if (numbers[i] in map) {
			return [map[numbers[i]], i + 1];
		} else {
			map[target - numbers[i]] = i + 1;
		}
	}
}</code></pre> 
<h3 id="%E7%BB%99%E5%AE%9A%E5%B7%AE%E5%80%BC%E7%9A%84%E7%BB%84%E5%90%88">给定差值的组合</h3> 
<p>hash算法</p> 
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4> 
<p>给定一个数组，每个元素的值时唯一的，找出其中两个元素相减等于给定差值diff的所有不同组合的个数。</p> 
<p>组合是无序的，如：（1,4）和（4,1）表示的是同一个组合。</p> 
<h4 id="%E8%A7%A3%E7%AD%94%E8%A6%81%E6%B1%82">解答要求</h4> 
<p>时间限制：1000ms，内存限制：256MB</p> 
<p>输入</p> 
<p>输入三行：</p> 
<p>第一行为一个整数，表示给定差值diff；范围[-50000,50000]</p> 
<p>第二行也为一个数字，表示数组的长度；范围[2,102400]</p> 
<p>第三行为该数组，由单个空格分割的一组数字组成；其中元素的值范围[-20,102400]</p> 
<p>用例保证第三行数字和空格组成的字符串长度不超过64999</p> 
<p>输出</p> 
<p>1个整数，表示满足要求的不同组合的个数</p> 
<p>样例</p> 
<p>输入样例1</p> 
<p>3</p> 
<p>5</p> 
<p>1 3 2 5 4</p> 
<p>输出样例1</p> 
<p>2</p> 
<p>提示样例1</p> 
<p>数组为[1 3 2 5 4]，差值diff为3，其中4-1=3,5-2=3，共2个组合满足要求，因此输出2</p> 
<p>输入样例2</p> 
<p>-1</p> 
<p>3</p> 
<p>1 2 3</p> 
<p>输出样例2</p> 
<p>2</p> 
<p>提示样例2</p> 
<p>其中1-2=-1,2-3=-1，共2个组合满足要求，因此输出2。</p> 
<h3>解析</h3> 
<p>注意方法一中时间复杂度为n²，因为forEach中判断了一轮，includes中对数组同样也判断了一轮。而方法二直接用哈希算法，通过映射的值去查找，去掉了第二轮的判断，时间复杂度为n。</p> 
<h4>核心思想</h4> 
<p>方法一：先把数组从大到小排序，然后利用forEach对数组的每一位进行判断，减去绝对值diff后用includes函数判断是否存在于原数组中。</p> 
<p>方法二：利用对象的属性，每次添加一个数，使hash对象的属性和值与数相同，直接通过对象的属性名（该数减去diff或加上diff）对应的值是否为undefined来判断差值结果是否存在于原数组中。</p> 
<h4> 答案</h4> 
<pre><code class="language-javascript">//不使用哈希排序的方法，输入数组过长时，会超时。
// const proc = (arr, diff) =&gt; {
//     let sum = 0
//     arr.sort((a, b) =&gt; b - a)
//     diff = Math.abs(diff)
//     arr.forEach((v1, i1) =&gt; {
//         if (arr.length &gt; i1 + 2) {
//             if (arr.includes(v1 - diff, i1 + 1)) {
//                 sum++
//             }
//         }
//     })
//     return sum
// }
const proc = (arr, diff) =&gt; {
    if (diff === 0) {
        return 0
    }
    let sum = 0
    let hash = {}
    for (let i = 0; i &lt; arr.length; i++) {
        const num1 = arr[i];
        hash[num1] = num1;
        if (hash[num1 - diff] != undefined) {
            sum++
        }
        if (hash[num1 + diff] != undefined) {
            sum++
        }
    }
    return sum
}
console.log(proc([1, 3, 2, 5, 4], 3))</code></pre> 
<p></p> 
<h3 id="%E6%9C%80%E4%BD%B3%E8%B7%AF%E5%BE%84">最佳路径</h3> 
<p>hash算法、递归、DFS（深度优先算法）</p> 
<h4>题目描述</h4> 
<p>给定单板间的有向连接关系：如单板101到单板102存在连接，权值为10，其连接关系描述为101 102 10；单板102到单板101存在连接，权值为6，其连接关系描述为：102 101 6.</p> 
<p>基于单板间的有向连接关系，从起始单板到目的单板可能有0或多条可达的有向路径，某条路径权值是该路径上各连接的权值之和。</p> 
<p>给定夺组格式为起始单板目的单板的查询命令，请依次计算并返回其最佳路径权值；若某条最佳路径不存在，则该条最佳路径权值返回-1</p> 
<p>最佳路径的规则如下：</p> 
<p>经过的连接个数最小；</p> 
<p>若符合规则1的路径存在多条，选择权值最小的；</p> 
<h4>解答要求</h4> 
<p>时间限制：1000ms，内存限制：256MB</p> 
<p>输入</p> 
<p>首行为两个正整数n m</p> 
<p>n是单板间连接关系的数量，取值范围：[1,500]</p> 
<p>m是查询命令的个数，取值范围：[1,500]</p> 
<p>接下来n行，每行是连接关系，单板编号取值范围：[1,999]，权值取值范围：[1,100]；都为正整数</p> 
<p>接下来m行，每行是需要查询最佳路径权值的起始单板、目的单板的编号。</p> 
<p>输出</p> 
<p>m行，每行一个整数，表示对应起始单板、目的单板的最佳路径权值的查询结果</p> 
<p>样例</p> 
<p>输入样例1</p> 
<p>2 2</p> 
<p>100 101 10 </p> 
<p>102 101 5</p> 
<p>100 101</p> 
<p>102 100</p> 
<p>输出样例1</p> 
<p>10</p> 
<p>-1</p> 
<p>提示样例1</p> 
<p>输出第一行：单板100到单板101，最小经过1次跳转就可达，其权值为10，输出10输出第二行：单板102到单板100，没有路径可达，因此输出-1</p> 
<h4></h4> 
<h3>解析</h3> 
<p>1.注意这里用到es6中set集合进行判断是否为走过的路径，然后由于是深度优先，且每次调用后都会删除添加的路径，所以不用去浅复制。</p> 
<p>2.注意当大于已知解法经过的线段步数时可以不用继续走了。</p> 
<h4>核心思想</h4> 
<p>每次走一步，将以下一步为起点的线段存入数组中递归走多步</p> 
<h4 id="%E9%80%92%E5%BD%92%E6%AD%A5%E9%AA%A4">递归步骤</h4> 
<p>1.根据递归思想首找到f(x)表示什么，f（x）要表示当前位置，目标位置，经过线段次数，权重和、走过的位置（为避免重复）。</p> 
<p>2.找到f(x)和f(x-1)的联系， f(source, target, count, sum, set)，其中source根据走的线段更新，目标位置不变，count每次加一，sum加上走的线段权重，set中添加走过线段的终点。f(x)到f(x-1)根据以source为起点的线段条数走多步。</p> 
<p>3.找出口，当走的步数大于已知解法的经过线段次数时返回，小于时，source和target相等即找到了正确路径。</p> 
<h4 id="%C2%A0%E7%AD%94%E6%A1%88"> 答案</h4> 
<pre><code class="language-javascript">function dfs(source, target, count, sum, set) {
    //countGlobal记录了已有成功的经过的线段次数，如果大于就不进行运算了，减少多余的次数
    if (countGlobal &gt;= count) {
        //出口，当起点为终点时即找到了
        if (source == target) {
            //如果经过有向线段小于已有解法，则直接赋值
            if (count &lt; countGlobal) {
                countGlobal = count
                sumGlobal = sum
            }
            //如果等于，则比较权值weight
            if (count === countGlobal) {
                sumGlobal = Math.min(sumGlobal, sum)
            }
            return
        }
        //没有以当前source为起点的线段了，即走到终点了
        if (!pathMap[source]) {
            return
        }
        const nextList = pathMap[source]
        //以source为起点的线段有多条则需要每条都走一遍
        for (let i = 0; i &lt; nextList.length; i++) {
            const { snkBoard, weight } = nextList[i]
            //判断路径是否走过了
            if (!set.has(snkBoard)) {
                //添加当前走的路径
                set.add(snkBoard)
                dfs(snkBoard, target, count + 1, sum + weight, set)
                //删除之前走的路径，用于下次循环
                set.delete(snkBoard)
            }
        }
    }
}
const pathMap = {}
let countGlobal = 0
let sumGlobal = 0
const getBestRoute = (boardsList, connnectionsList) =&gt; {
    //利用hash算法来搜索指定起点的路径
    for (let con of connnectionsList) {
        if (!pathMap[con.srcBoard]) {
            pathMap[con.srcBoard] = []
        }
        pathMap[con.srcBoard].push({ snkBoard: con.snkBoard, weight: con.weight })
    }
    const res = []
    //对每个指定的路径进行计算
    for (let pair of boardsList) {
        let { srcBoard: source, snkBoard: target } = pair
        //记录经过的有向线段个数
        countGlobal = Number.MAX_VALUE
        //记录最小的weght总量
        sumGlobal = Number.MAX_VALUE
        //记录经过了的点，避免重复走
        const set = new Set()
        set.add(source)
        dfs(source, target, 0, 0, set)
        if (sumGlobal === Number.MAX_VALUE) {
            res.push(-1)
        } else {
            res.push(sumGlobal)
        }
    }
    return res
}
console.log(getBestRoute(
    [{ srcBoard: 100, snkBoard: 101 }, { srcBoard: 102, snkBoard: 100 }],
    [{ srcBoard: 100, snkBoard: 101, weight: 10 }, { srcBoard: 102, snkBoard: 101, weight: 5 }])
)</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e19e8d176137c454fcf9ebaadc38ea33/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot&#43;Vue登录注册</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a987cbc7fc539a96731b3f00192ab2a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python-猜词小游戏（优化）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>