<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ORACLE 碎片整理小结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ORACLE 碎片整理小结" />
<meta property="og:description" content="oracle碎片小结
我们在使用windows的时候，都知道要定期整理磁盘碎片，因为磁盘碎片会影响性能，给管理上带来额外的
负担。那oracle更是如此，当随着数据增加，oracle处理海量数据本身就已经很费力了啊，如果再有大量
的碎片，那就是雪上加霜啊。所以碎片要引起dba的高度重视，尽早发现尽早处理。
碎片是怎么产生的呢？
简单理解就是由于更新和删除产生一些碎小的不能被再次使用的空间，根据每种不同的碎片他们的产生也是有区别的
block-level的碎片，而block又分为data block和index block，在data block中存放的是row数据，在index block
中存放的是索引键值数据，所以按上面所说，block-level碎片有细分为row-level碎片和Index Leaf Block-level碎片。
oracle的每一个对象都是存储在segment中，而oracle的最小分配单位是extents（区），在数据更新删除中也会产生碎片
这一级别的碎片就是segment碎片。segment又存在datafile中，而tablespace又是包含datafile的逻辑概念。所以这一层
是tablespace-level碎片；tablespace是在disk上存储，所以这一层就是disk-level碎片。
简单图示如下
disk-level fragmention
tablespace-level fragmentation
segment-level fragmentation
block-level fragmentation
row-level fragmentation
index leaf block-level fragmentation
顺便提下oracle extents存在的理由
一个extents是由多个相连的block组成的，多个extents做成一个segment；extent是oracle的最小分配单位
extent的优点：
提高空间分配，释放的效率，降低管理block的资源成本提高扫描的效率，因为extent是由相连blocks做成的特性，可以一次读取更多的内容，较低io读写次数 extent的缺点
容易产生碎片
如何确定产生了碎片的呢？
一。表空间碎片确定参考
由于自由空间碎片是由几部分组成，如范围数量、最大范围尺寸等，我们可用 FSFI–Free Space Fragmentation Index
(自由空间碎片索引)值来直观体现：
FSFI=100*SQRT(max(extent)/sum(extents))*1/SQRT(SQRT(count(extents)))
可以看出，FSFI 的最大可能值为 100 (一个理想的单文件表空间)。随着范围的增加， FSFI 值缓慢下降，而随着最大范
围尺寸的减少，FSFI 值会迅速下降。通过如下语句查询FSFI：
select tablespace_name, sqrt(max(blocks) / sum(blocks)) * (100 / sqrt(sqrt(count(blocks)))) FSFI from dba_free_space group by tablespace_name order by 1; 在一个有着足够有效自由空间，且FSFI 值超过30的表空间中，很少会遇见有效自由空间的问题。当一个空间将要接近" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6ee2bffd3ad1e4e73d068327b350245b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-19T10:58:39+08:00" />
<meta property="article:modified_time" content="2020-11-19T10:58:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ORACLE 碎片整理小结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>oracle碎片小结<br> 我们在使用windows的时候，都知道要定期整理磁盘碎片，因为磁盘碎片会影响性能，给管理上带来额外的<br> 负担。那oracle更是如此，当随着数据增加，oracle处理海量数据本身就已经很费力了啊，如果再有大量<br> 的碎片，那就是雪上加霜啊。所以碎片要引起dba的高度重视，尽早发现尽早处理。</p> 
<p>碎片是怎么产生的呢？</p> 
<p>简单理解就是由于更新和删除产生一些碎小的不能被再次使用的空间，根据每种不同的碎片他们的产生也是有区别的</p> 
<p>block-level的碎片，而block又分为data block和index block，在data block中存放的是row数据，在index block<br> 中存放的是索引键值数据，所以按上面所说，block-level碎片有细分为row-level碎片和Index Leaf Block-level碎片。</p> 
<p>oracle的每一个对象都是存储在segment中，而oracle的最小分配单位是extents（区），在数据更新删除中也会产生碎片<br> 这一级别的碎片就是segment碎片。segment又存在datafile中，而tablespace又是包含datafile的逻辑概念。所以这一层<br> 是tablespace-level碎片；tablespace是在disk上存储，所以这一层就是disk-level碎片。</p> 
<p>简单图示如下</p> 
<p>disk-level fragmention<br> tablespace-level fragmentation<br> segment-level fragmentation<br> block-level fragmentation<br> row-level fragmentation<br> index leaf block-level fragmentation</p> 
<p>顺便提下oracle extents存在的理由</p> 
<p>一个extents是由多个相连的block组成的，多个extents做成一个segment；extent是oracle的最小分配单位</p> 
<p>extent的优点：</p> 
<ol><li>提高空间分配，释放的效率，降低管理block的资源成本</li><li>提高扫描的效率，因为extent是由相连blocks做成的特性，可以一次读取更多的内容，较低io读写次数</li></ol> 
<p>extent的缺点<br> 容易产生碎片</p> 
<p>如何确定产生了碎片的呢？</p> 
<p>一。表空间碎片确定参考</p> 
<p>由于自由空间碎片是由几部分组成，如范围数量、最大范围尺寸等，我们可用 FSFI–Free Space Fragmentation Index<br> (自由空间碎片索引)值来直观体现：</p> 
<p>FSFI=100*SQRT(max(extent)/sum(extents))*1/SQRT(SQRT(count(extents)))</p> 
<p>可以看出，FSFI 的最大可能值为 100 (一个理想的单文件表空间)。随着范围的增加， FSFI 值缓慢下降，而随着最大范<br> 围尺寸的减少，FSFI 值会迅速下降。通过如下语句查询FSFI：</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> tablespace_name<span class="token punctuation">,</span>
       sqrt<span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>blocks<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">sum</span><span class="token punctuation">(</span>blocks<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">/</span> sqrt<span class="token punctuation">(</span>sqrt<span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span>blocks<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> FSFI
  <span class="token keyword">from</span> dba_free_space
 <span class="token keyword">group</span> <span class="token keyword">by</span> tablespace_name
 <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<p>在一个有着足够有效自由空间，且FSFI 值超过30的表空间中，很少会遇见有效自由空间的问题。当一个空间将要接近<br> 可比参数时，就需要做碎片整理了（DMT空间可以整理，如果是LMT就无法整理）。（SMON 会将相邻的自由范围自动合并）</p> 
<p>temp表空间（非本地管理表空间） 回收<br> 可以将表空间的缺省存储参数pctincrease改为非0。一般将其设为1，如：<br> alter tablespace temp default storage(pctincrease 1);</p> 
<p>这样smon便会将自由范围自动合并。也可以手工合并自由范围：<br> alter tablespace temp coalesce;</p> 
<p>二。segment的碎片整理</p> 
<p>segment的碎片整理一般主要整理table和index</p> 
<p>9i之前碎片整理的方法</p> 
<ol><li> <p>exp/truncate/imp</p> </li><li></ol> 
<p>alter table table_name move stroage(initial 1m)<br> alter index index_name rebuild [tablespace tablespace_name] [nologging] [online]</p> 
<p>3.CTAS重组</p> 
<p>在10g之后，不但可以用以上两种方法，还提供了新的方法</p> 
<p>alter table &lt;table_name&gt; shrink space [ | compact | cascade ];</p> 
<p>compact:这个参数当系统的负载比较大时可以用，不降低HWM。如果系统负载较低时，直接用alter table table_name shrink space就一步到位了<br> cascade：这个参数是在shrink table的时候自动级联索引，相当于rebulid index。</p> 
<p>普通表</p> 
<p>shrink必须开启行迁移功能。<br> alter table table_name enable row movement ;</p> 
<p>保持HWM，相当于把块中数据打结实了<br> alter table table_name shrink space compact;</p> 
<p>回缩表与降低HWM<br> alter table table_name shrink space;</p> 
<p>回缩表与相关索引，降低HWM<br> alter table table_name shrink space cascade;</p> 
<p>回缩索引与降低HWM<br> alter index index_name shrink space</p> 
<p>虽然在10g中可以用shrink ，但也有些限制：</p> 
<p>1). 对cluster，cluster table，或具有Long，lob类型列的对象 不起作用。<br> 2). 不支持具有function-based indexes 或 bitmap join indexes的表<br> 3). 不支持mapping 表或index-organized表。<br> 4). 不支持compressed 表</p> 
<p>参考文档：<br> http://blog.csdn.net/wyzxg/archive/2010/05/28/5631721.aspx</p> 
<p>从9i开始index碎片的整理除了drop and create index，还可以 alter index skate.t1_idx rebuild nologging parallel 4 online ;</p> 
<p>表的碎片查找</p> 
<p>一种笨的方式就是ctas一个表和原来的做下比较，看看空间大小的变化，还有一种就方法就是看视图里数据（要及时analyze才准确）<br> 查看user_tables和user_segments</p> 
<p>eg:</p> 
<pre><code class="prism language-sql"><span class="token keyword">SQL</span><span class="token operator">&gt;</span> <span class="token keyword">select</span> num_rows<span class="token punctuation">,</span>blocks<span class="token punctuation">,</span>empty_blocks<span class="token punctuation">,</span>avg_space<span class="token punctuation">,</span>avg_row_len<span class="token punctuation">,</span>last_analyzed <span class="token keyword">from</span> user_tables <span class="token keyword">where</span> table_name<span class="token operator">=</span><span class="token string">'TEST1'</span><span class="token punctuation">;</span>
</code></pre> 
<p>NUM_ROWS BLOCKS EMPTY_BLOCKS AVG_SPACE AVG_ROW_LEN LAST_ANALYZED</p> 
<hr> 
<pre><code>393216        562           78         23          13 2010-5-27 21:
</code></pre> 
<p>AVG_SPACE:表示block内的空闲空间大小，根据pctfree参数来参考，这里以默认%10为准，在block=8192里，允许空间的空间是8192 × %10=819.2，也就是说在block剩余空间是819.2时，oracle就认为它是满块了，如果再有数据就要寻找新的block了，当表的AVG_SPACE远远大于819.2时，就说明有碎片了，因为块没有被充分利用，产生block-level碎片。可以通过alter table move来整理。</p> 
<p>那可以节省多少空间呢？</p> 
<p>数据的实际大小=AVG_ROW_LEN × NUM_ROWS=13 × 393216=5111808<br> 表的实际大小 =BLOCKS × block_size =562 * 8192 =4603904</p> 
<p>理论上AVG_ROW_LEN × NUM_ROWS &lt;= BLOCKS × block_size 如果相差比较大，那就需要整理，也可以粗略的算下可以节省多少空间，可现在实际上确<br> AVG_ROW_LEN × NUM_ROWS &gt; BLOCKS × block_size ,不知道的是什么原因？</p> 
<p>突然想到我这个test1表里最后一个字段是clob类型的，而clob在数据大于4k时（一个lob字段包括lobindex和lobsegment,），是存储在另外的log segment中的。</p> 
<p>而clob类型的d字段没有存储任何数据，查询user_lobs视图</p> 
<pre><code class="prism language-sql"><span class="token keyword">SQL</span><span class="token operator">&gt;</span> <span class="token keyword">select</span> ul<span class="token punctuation">.</span>table_name<span class="token punctuation">,</span>ul<span class="token punctuation">.</span>segment_name<span class="token punctuation">,</span> ul<span class="token punctuation">.</span>chunk<span class="token punctuation">,</span>se<span class="token punctuation">.</span>blocks<span class="token punctuation">,</span>se<span class="token punctuation">.</span>bytes <span class="token keyword">from</span> user_lobs ul<span class="token punctuation">,</span>user_segments se <span class="token keyword">where</span> ul<span class="token punctuation">.</span>segment_name<span class="token operator">=</span>se<span class="token punctuation">.</span>segment_name <span class="token operator">and</span> ul<span class="token punctuation">.</span>table_name<span class="token operator">=</span><span class="token string">'TEST1'</span><span class="token punctuation">;</span>
</code></pre> 
<p>TABLE_NAME SEGMENT_NAME CHUNK BLOCKS BYTES</p> 
<hr> 
<p>TEST1 SYS_LOB0000183465C00004$$ 8192 8 65536</p> 
<p>可这个65536和那两个差值还差很多，再说这8个block还是empty，搞不懂了，谁知道请指点，先谢谢了啊</p> 
<p>换个角度会什么样的？我又用CTAS穿件表test4，这回就符合理论值，无论用</p> 
<p>alter table table_name move,还是alter table table_name shrink space compact，都是符合理论值的</p> 
<p>create table test4 as select * from test1</p> 
<p>分析后： analyze table test4 compute statistics</p> 
<pre><code class="prism language-sql"><span class="token keyword">SQL</span><span class="token operator">&gt;</span> <span class="token keyword">select</span> num_rows<span class="token punctuation">,</span>blocks<span class="token punctuation">,</span>empty_blocks<span class="token punctuation">,</span>avg_space<span class="token punctuation">,</span>avg_row_len<span class="token punctuation">,</span>last_analyzed <span class="token keyword">from</span> user_tables <span class="token keyword">where</span> table_name<span class="token operator">=</span><span class="token string">'TEST4'</span><span class="token punctuation">;</span>
</code></pre> 
<p>NUM_ROWS BLOCKS EMPTY_BLOCKS AVG_SPACE AVG_ROW_LEN LAST_ANALYZED</p> 
<hr> 
<pre><code>393216        802            6        820          12 2010-5-28 12:
</code></pre> 
<p>数据的实际大小=AVG_ROW_LEN × NUM_ROWS=13 × 393216=5111808<br> 表的实际大小 =BLOCKS × block_size =562 * 8192 =6569984</p> 
<p>index碎片查找</p> 
<p>识别索引是否有碎片</p> 
<p>获得关于索引的信息，用下面的命令</p> 
<p>analyze index index_name validate structure 或validate index index_name</p> 
<p>analyze index index1 validate structure：是用来分析索引的数据块是否有坏块，以及根据分析得到的<br> 数据（存放在index_stats）來判断索引是否需要重新建立。</p> 
<p>运行命令后，然后在视图 index_stats查询，这个视图记录索引的一些信息，这个视图只有一个记录，所以在同一时间只能分析一个索引。</p> 
<p>1.删除的行数如占总的行数的30%，即del_lf_rows / lf_rows &gt; 0.3，那就考虑索引碎片整理<br> 2.如果”hight“大于4，可以考虑碎片整理<br> 3.如果索引的行数（LF_rows）远远小于‘LF_BLKS’ ，那就说明有了一个大的删除动作，需要整理碎片</p> 
<p>索引碎片整理方法</p> 
<ol><li>recreate index</li><li>alter index skate.idx_test rebuild nologging parallel 4 online ;</li><li>如果叶块是half-empty or near empty，可以运行“alter index coalesce”来合并</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81619b0841057bcbbee871a4baada33a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sqlplus 中的spool命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b52da327549d34571787821980c9b974/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">推荐系统深度学习篇-DCN网络介绍(2)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>