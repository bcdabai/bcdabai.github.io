<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>各类Java对象 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="各类Java对象" />
<meta property="og:description" content="概念的混淆:
新一代的开发者，学习某一概念的不同描述或是案例后，人脑会去抽象、提取其特征。这一过程可能造成语义扩散、概念扭曲。这是一个盲人摸象的过程。
写到这里时，我在想：“盲人摸象”与“抽象”的“象”是不是一个意思呢？我差点儿就混淆了我自己。虽然两个词语都有“提取部分特征”的意思，但时代背景、指代对象完全不同！
就像javabean和pojo的诞生背景、含义完全不同，但如今经常看到&#34;javabean是一个pojo&#34;,&#34;pojo是一个javabean&#34;的描述，简直就是鸡生蛋蛋生鸡，而不去考证鸟类的祖先。
在某一时间段，人们对某种编程困境感到烦恼，不少开发者脑中开始形成一种新的理开发理念
一些代表人物提出了他们的见解。同一时期可能对类似概念并发提出了不同表述，在后世可能会被归结、翻译成同一概念。 归结后混淆的例子：&#34;Service&#34;作为“服务”被用在了“业务逻辑”上，而&#34;Buiness Logic&#34;才是“业务逻辑”最好的描述归结后统一的例子： &#34;Component&#34;被翻译成了“构件”“组件”，现在统称组件 如果有官方组织维护概念，定义就有机会清晰；如javabean，我们有幸还能在Oracle维护的sun公司初版的教程上看到官方对它的描述。但是如果sun公司的网页全部被清空了呢？web在保存历史上还不够可靠。
当然，概念的初始版本也可能不完美或者不顺应时代（如架构方式）的转变，导致概念的转变。
sun公司也不可能复活过来大喊：不是的！javabean不是pojo!一种说法，作品在发布的那一刻，(解释权)就不属于作者了 本文会探讨这些概念，遵循唯物史观，尽力找出其时代背景、相对概念、演化过程，并标明材料出处。
组件模型 javaBean、EJB是以“组件”概念为基础提出的
根据Ian Sommerville《软件工程》第十版的总结,
书中提到了两种先人关于组件的定义。如今“组件”没有权威的组织去定义它。它公认的基础概念是&#34;一个程序单元&#34;。
面向对象、面向组件、面向服务是不同的软件工程思想。
组件和服务的概念可以兼容的，即组件可以是嵌入式的组件（嵌入其他代码中），也可以以服务的形式被其他应用使用。
原文简述：
基于构件的软件工程作为一种软件系统开发方法，是在20世纪90年代末期出现的。它的产生源于设计者们在使用面向对象的开发过程中所受到的挫折：面向对象开发不能够像人们所期待的那样完成广泛的复用。
传统嵌入式组件(非服务)自然不能单独运行，它需要容器：
对于充当程序单元而不是外部服务的构件来说，构件模型规定了必须由支持构件执行的中间件所提供的服务。Weinreich和Sametinger利用操作系统来类比解释构件模型：操作系统为应用提供一组通用服务（系统调用），组件模型也为组件体统一系列通用服务。
因此可以认为组件处于提供基础服务的“容器”中，如EJB在javaEE容器中
而javaBean就是一种组件，由sun定义其概念。最初的javaBean指前端GUI中的组件，如一个小窗口、按钮；
其他语言中前端GUI组件代表：VB（Visual Basic，win平台ui“控件”）,现代的web组件库（如vue的饿了么UI）
同这类前端组件一起出现的是同ide高度结合的、可视化界面编辑器。如VB控件编辑、Java的JBuilder。
由此名称衍生出的、由sun公司官方定义的还有一种Enterprise JavaBean，是JavaEE规范中的分布式（多用于服务端）组件。
组件与容器：EJB与javaEE平台；COM与.NET平台；
javabean项目 这篇文章应该以解释、论证定义为主 com组件 组件 相关里理论 与领域模型理论的关系 JavaBeans™ architecture -看来组件是一种架构？ 也许我的网站应该把目前学的知识在图中的位置展现出来，以好让我明白那是一种架构 and 个人理论同全局理论的矛盾-也许追求统一是一种哲学？ 组件在GUI有“行为”，但行为是业务逻辑吗？组件为了复用，复用的逻辑哪里都用，还算业务吗 当初想问的这个行为应该是类似js吧 三层架构业务层统一了逻辑，分层架构似乎和领域、组件时不一样的方向处理业务，类似AOP和三层架构一个横一个纵。那么有分层架构的单体GUI应用吗 容器与bean也在控件有类似的概念吗？还是说组件模型里的？EE有容器，servlet不是bean，docker也不是 说起来js也有监听器之类的东西，GUI架构里也提到早期的表单也有数据监听，，，是不是前端或者组件模型都有这个。也许也是前端的共性呢 为什么都不用构造函数了？明明mybatis的sqlsessionFactory工厂也用了。感觉一直在set，重复的set
JavaBean java是咖啡，bean是豆子。
JavaBean规范是由Sun公司定义的。JavaBean是遵守JavaBean API1规范的Java类，它是一个可以重复使用的组件。
JavaBeans™使组件复用变得容易. 开发者们使用其他人开发的组件时不需要了解其内部实现。
这个面向对象是不是也说过。果然一个抽象一个具体
容易复用是因为遵循统一且合理的规范：无参构造
那么这个前端的javabean有没有逻辑就要看前端组件架构的理论要不要业务逻辑了？那现在的后端，之前后端的ejb有业务逻辑，但pojo和三层架构取代了这个“业务逻辑生态位”，所以后端bean。，去哪里了？作为后端组件？那有逻辑吗？如果有的话，是不是意味着前端bean其实也有业务逻辑，也即一开始没有限制？ 我猜测组件架构应该是有业务逻辑的，因为ejb也是bean也是组件（？）或许是通用业务逻辑？ 看看mvvm这种纯前端模式吧业务逻辑放哪里 官方教程说了：只要让你的类长得像bean，工具们自己会认得
JavaBean主要规范：
bean组件具有属性（property）；通过提供getter/setter方法来实现属性； 同类的成员变量相比，“属性”是组件中的概念，对内封装变量、对外暴露给调用方。这是面向对象开发的“封装”概念的具体应用 要可以持久化(@Since jdk1.4) 上述描述经常出现在各大教程中。官网教程还介绍了bean的其他部分的称呼（确实比起实现接口那种必须填写的规范，更像是对可有可无部分的称呼）：
- 方法：“bean的方法”是设计bean能做什么。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/98eebf54e169480e16bd9e2a1cc2cd59/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-21T01:44:00+08:00" />
<meta property="article:modified_time" content="2024-01-21T01:44:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">各类Java对象</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>概念的混淆:<br> 新一代的开发者，学习某一概念的不同描述或是案例后，人脑会去<strong>抽象</strong>、提取其特征。这一过程可能造成语义扩散、概念扭曲。这是一个<strong>盲人摸象</strong>的过程。</p> 
<blockquote> 
 <p>写到这里时，我在想：“盲人摸象”与“抽象”的“象”是不是一个意思呢？我差点儿就混淆了我自己。虽然两个词语都有“提取部分特征”的意思，但时代背景、指代对象完全不同！<br> 就像javabean和pojo的诞生背景、含义完全不同，但如今经常看到"javabean是一个pojo","pojo是一个javabean"的描述，简直就是鸡生蛋蛋生鸡，而不去考证鸟类的祖先。</p> 
</blockquote> 
<ul><li> <p>在某一时间段，人们对某种编程困境感到烦恼，不少开发者脑中开始形成一种新的理开发理念</p> 
  <ul><li>一些代表人物提出了他们的见解。同一时期可能对类似概念并发提出了不同表述，在后世可能会被归结、翻译成同一概念。 
    <ul><li>归结后混淆的例子："Service"作为“服务”被用在了“业务逻辑”上，而"Buiness Logic"才是“业务逻辑”最好的描述</li><li>归结后统一的例子： "Component"被翻译成了“构件”“组件”，现在统称组件</li></ul> </li></ul> </li><li> <p>如果有官方组织维护概念，定义就有机会清晰；如javabean，我们有幸还能在Oracle维护的sun公司初版的教程上看到官方对它的描述。但是如果sun公司的网页全部被清空了呢？web在保存历史上还不够可靠。</p> </li><li> <p>当然，概念的初始版本也可能不完美或者不顺应时代（如架构方式）的转变，导致概念的转变。</p> 
  <ul><li>sun公司也不可能复活过来大喊：不是的！javabean不是pojo!</li><li>一种说法，作品在发布的那一刻，(解释权)就不属于作者了</li></ul> </li></ul> 
<p>本文会探讨这些概念，遵循唯物史观，尽力找出其时代背景、相对概念、演化过程，并标明材料出处。</p> 
<h2><a id="_23"></a>组件模型</h2> 
<p><em>javaBean、EJB是以“组件”概念为基础提出的</em><br> 根据Ian Sommerville《软件工程》第十版的总结,<br> 书中提到了两种先人关于组件的定义。如今“组件”没有权威的组织去定义它。它公认的基础概念是"一个程序单元"。<br> 面向对象、面向组件、面向服务是不同的软件工程思想。<br> 组件和服务的概念可以兼容的，即组件可以是嵌入式的组件（嵌入其他代码中），也可以以服务的形式被其他应用使用。</p> 
<blockquote> 
 <p>原文简述：<br> 基于构件的软件工程作为一种软件系统开发方法，是在20世纪90年代末期出现的。它的产生源于设计者们在使用面向对象的开发过程中所受到的挫折：面向对象开发不能够像人们所期待的那样完成广泛的复用。</p> 
</blockquote> 
<p>传统嵌入式组件(非服务)自然不能单独运行，它需要容器：</p> 
<blockquote> 
 <p>对于充当程序单元而不是外部服务的构件来说，构件模型规定了必须由<strong>支持构件执行的中间件</strong>所提供的<strong>服务</strong>。Weinreich和Sametinger利用操作系统来类比解释构件模型：操作系统为应用提供一组通用服务（系统调用），组件模型也为组件体统一系列通用服务。<br> <em>因此可以认为组件处于提供基础服务的“容器”中</em>，如EJB在javaEE容器中</p> 
</blockquote> 
<p>而javaBean就是一种组件，由sun定义其概念。最初的javaBean指前端GUI中的组件，如一个小窗口、按钮；<br> 其他语言中前端GUI组件代表：VB（Visual Basic，win平台ui“控件”）,现代的web组件库（如vue的饿了么UI）<br> 同这类前端组件一起出现的是同ide高度结合的、可视化界面编辑器。如VB控件编辑、Java的JBuilder。<br> 由此名称衍生出的、由sun公司官方定义的还有一种Enterprise JavaBean，是JavaEE规范中的分布式（多用于服务端）组件。</p> 
<p>组件与容器：EJB与javaEE平台；COM与.NET平台；</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> javabean项目</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 这篇文章应该以解释、论证定义为主</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> com组件</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 组件 相关里理论</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 与领域模型理论的关系</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> JavaBeans™ architecture -看来组件是一种架构？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 也许我的网站应该把目前学的知识在图中的位置展现出来，以好让我明白那是一种架构</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> and 个人理论同全局理论的矛盾-也许追求统一是一种哲学？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 组件在GUI有“行为”，但行为是业务逻辑吗？组件为了复用，复用的逻辑哪里都用，还算业务吗 
  <ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 当初想问的这个行为应该是类似js吧</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 三层架构业务层统一了逻辑，分层架构似乎和领域、组件时不一样的方向处理业务，类似AOP和三层架构一个横一个纵。那么有分层架构的单体GUI应用吗</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 容器与bean也在控件有类似的概念吗？还是说组件模型里的？EE有容器，servlet不是bean，docker也不是</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 说起来js也有监听器之类的东西，GUI架构里也提到早期的表单也有数据监听，，，是不是前端或者组件模型都有这个。也许也是前端的共性呢</li></ul> </li></ul> 
<p>为什么都不用构造函数了？明明mybatis的sqlsessionFactory工厂也用了。感觉一直在set，重复的set</p> 
<h2><a id="JavaBean_62"></a>JavaBean</h2> 
<p>java是咖啡，bean是豆子。<br> JavaBean规范是由Sun公司定义的。JavaBean是遵守JavaBean API<sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1">1</a></sup>规范的Java类，它是一个可以重复使用的<strong>组件</strong>。<br> JavaBeans™使组件复用变得容易. 开发者们使用其他人开发的组件时不需要了解其内部实现。</p> 
<blockquote> 
 <p>这个面向对象是不是也说过。果然一个抽象一个具体</p> 
</blockquote> 
<p><em>容易复用是因为遵循统一且合理的规范：无参构造</em></p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 那么这个前端的javabean有没有逻辑就要看前端组件架构的理论要不要业务逻辑了？那现在的后端，之前后端的ejb有业务逻辑，但pojo和三层架构取代了这个“业务逻辑生态位”，所以后端bean。，去哪里了？作为后端组件？那有逻辑吗？如果有的话，是不是意味着前端bean其实也有业务逻辑，也即一开始没有限制？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 我猜测组件架构应该是有业务逻辑的，因为ejb也是bean也是组件（？）或许是通用业务逻辑？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 看看mvvm这种纯前端模式吧业务逻辑放哪里</li></ul> 
<p>官方教程说了：只要让你的类长得像bean，工具们自己会认得</p> 
<p>JavaBean主要规范：</p> 
<ul><li>bean组件具有<strong>属性</strong>（property）；通过提供getter/setter方法来实现属性； 
  <ul><li>同类的成员变量相比，“属性”是组件中的概念，对内封装变量、对外暴露给调用方。这是面向对象开发的“封装”概念的具体应用</li></ul> </li><li>要可以持久化(@Since jdk1.4)</li></ul> 
<p>上述描述经常出现在各大教程中。官网教程还介绍了bean的其他部分的称呼（确实比起实现接口那种必须填写的规范，更像是对可有可无部分的称呼）：<br> <em>- 方法：“bean的方法”是设计bean能做什么。</em></p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 前端组件库的控件</li></ul> 
<p>JavaAPI文档中Bean包的描述:<br> 包含和开发Bean相关的类 – beans 是基于JavaBeans™ 架构的组件.<br> 但是，此包中的大多数类都是由bean编辑器使用的（即，用于自定义和组合bean以创建应用程序的开发环境，如eclipse的bean编辑器）。 特别是，这些类有助于bean编辑器创建可以自定义bean的可视化界面。 例如，bean可能包含bean编辑器可能不知道如何处理的特殊类型的属性。 通过使用PropertyEditor接口，bean开发人员可以为此特殊类型提供编辑器。<br> However, most of the classes in this package are meant to be used by a bean editor (that is, a development environment for customizing and putting together beans to create an application). In particular, these classes help the bean editor create a user interface that the user can use to customize the bean. For example, a bean may contain a property of a special type that a bean editor may not know how to handle. By using the PropertyEditor interface, a bean developer can provide an editor for this special type.<br> 官网教程中使用netbeans的bean编辑器，可视化编辑属性：<br> <img src="https://images2.imgbox.com/d8/3a/aJ0FGuWu_o.gif" alt="">可以看到该案例中的bean被编写了background等属性<br> java11的desktop模块中（9开始引入模块化系统）:<br> 定义AWT和Swing用户界面工具包，以及用于辅助功能，音频，图像，打印和JavaBeans的API。</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 事件是一开始给swing设计后来给其他设计了吗 
  <ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 和spring事件的关系</li></ul> </li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> BeanInfo和springbeaninfo如果有的话</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> DesignMode</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 长期持久性：ｘｍｌ可能那个时候ｘｍｌ比较流行吧</li></ul> 
<p>内省（Introspector）是Java语言对Bean类属性、事件的一种缺省处理方法。<br> Java中提供的一套API,专门用于访问某个属性的get,set方法，<br> 通常的操作: 通过Introspector获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器PropertyDescriptor，<br> 通过这个属性描述器就可以获取某个属性对应的getter/setter方法，最后运用反射技术执行方法</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">BeanInfo</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">IntrospectionException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">Introspector</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>beans<span class="token punctuation">.</span></span><span class="token class-name">PropertyDescriptor</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">InvocationTargetException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"Tina"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">BeanInfo</span> beanInfo <span class="token operator">=</span> <span class="token class-name">Introspector</span><span class="token punctuation">.</span><span class="token function">getBeanInfo</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 获取bean的属性(描述符)数组。将属性及其读写方法包装成描述符PropertyDescriptor，以数组形式返回</span>
            <span class="token class-name">PropertyDescriptor</span><span class="token punctuation">[</span><span class="token punctuation">]</span> descriptors <span class="token operator">=</span> beanInfo<span class="token punctuation">.</span><span class="token function">getPropertyDescriptors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 遍历bean的属性数组</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">PropertyDescriptor</span> descriptor <span class="token operator">:</span> descriptors<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token class-name">Method</span> writeMethod <span class="token operator">=</span> descriptor<span class="token punctuation">.</span><span class="token function">getWriteMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    writeMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">"Yoke"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">Method</span> readMethod <span class="token operator">=</span> descriptor<span class="token punctuation">.</span><span class="token function">getReadMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">Object</span> o <span class="token operator">=</span> readMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改之后的名字是: "</span> <span class="token operator">+</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>mybatis、spring也是基于javabean规范解析java类的。在使用mybatis配置映射关系时，可以看到同数据库"列"对应的是“属性”</p> 
 <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>author_id<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre> 
 <p>fastjson等框架通过识别get/set开头的方法来识别属性。曾经使用eclipse自动生成的getter/setter方法有bug：有些方法没有严格按get/set+驼峰式命名生成，导致fastjson无法识别属性，产生bug。<br> 因此，get/set方法才是判断属性的依据，属性 != 成员变量。一个成员变量没有getter/setter，就不会被遵循bean规范的工具识别为属性；而反过来，有时想要实现一个属性，不一定要定义成员变量：只要有“set属性名/get属性名”这样的方法，就足以被基于bean的工具识别为属性了。</p> 
</blockquote> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 写一个没变量的例子试试</li></ul> 
<p>规范的getter/setter是面向对象编程中“封装”这一抽象概念的具体案例，使组件具有更高的可重用性和安全性。<br> 而序列化是为了：持久化是为了保存组件的属性状态，以及通过网络传输在其他地方复现组件的状态等。</p> 
<blockquote> 
 <p>比起让调用方直接更改某个public属性，get/set方法封装好正确的使用方式，或是使属性只读。曾经很多人学习面向对象开发时，只学到了抽象的“封装”与隐藏概念，而javabean就是封装的一个具体实现方式：调用方知道<strong>属性</strong>（公有的方法），却不知道有什么<strong>变量</strong>。一些内部仅用于计算的私有成员变量没必要作为属性暴露给外边。</p> 
</blockquote> 
<p>现在的javaBean似乎逐渐演变成了是只有属性，没有业务逻辑的。原来的应该是没提吧</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">jsp:</span>useBean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>students<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.runoob.StudentsBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> 
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">jsp:</span>setProperty</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>students<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>firstName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>小强<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">jsp:</span>setProperty</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>students<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lastName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>王<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">jsp:</span>setProperty</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>students<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">jsp:</span>useBean</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h3><a id="_161"></a>补充</h3> 
<ul><li>boolean类型字段的读方法（getter）一般命名为isXyz()：</li></ul> 
<blockquote> 
 <p>阿里开发规范中专门提到，一些以javaBean为规范来解析类的框架/模板引擎（如FastJson,读取方法名来匹配生成的JSON对象的键名），会将isXXX()方法的对应属性解析成XXX而不是isXXX；因此boolean属性的属性名名不能以is开头，其setter可以以is开头并且会被框架正确解析；<br> <em>咱总不能属性名为isXXX,然后方法名为isIsXXX吧哈哈哈</em></p> 
</blockquote> 
<ul><li>只有getter的属性称为只读属性（read-only）。在甲骨文的官网教程中，还有一些现在不怎么提到的属性类型，比如带属性更改监听Listener的绑定属性。</li><li>JavaBean的命名和设计理念在很大程度上受到了Smalltalk编程语言的对象的影响。</li><li>@过时： Javabean不是JAVAEE规范之一，企业级的EJB Enterprise JavaBeans 才是。 JavaBean作为一种组件模型，可以和其他组件模型（如EJB）一起使用，被广泛地应用于各种Java应用程序的开发中。</li><li>java标准包中beans包。其中的一些方法是GUI时代使用的，比如属性更改监听器。类似MVVM的思想？</li></ul> 
<h4><a id="javabean_169"></a>javabean的历史</h4> 
<p>最初在1996年由Sun Microsystems提出。JavaBeans的目的是为了方便Java程序员编写可重用的组件，这些组件可以在不同的环境中移植和使用。<br> JavaBeans是许多Java开发平台的GUI的核心，如Eclipse、NetBeans和JBoss等。它们使用JavaBeans模型来让开发人员创建可重用的组件，可以通过组件容器来部署和使用。在JavaBeans规范中，使用了一些新的关键字和注释来标记组件的属性、事件和方法，这使得Java平台上的组件化开发变得更加简单和标准化。<br> 如上文所述，javaBean最早主要作为GUI组件，类似于现在的前端组件或者桌面开发中的"控件"。</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> Com</li></ul> 
<h4><a id="_174"></a>待定</h4> 
<p>mvc中的model可以用javabean，那里似乎（？）说javabean是要包含数据和行为；在三层架构中，被拆成了service；那么看来，本来的javabean带业务，所以也有用setter/getter里写写东西搞控制的说法？但是后来被拆分了？</p> 
<h3><a id="Spring_bean_176"></a>Spring bean</h3> 
<h4><a id="spring_177"></a>概念<sup class="footnote-ref"><a href="#fn2" rel="nofollow" id="fnref2">2</a></sup></h4> 
<p>在Spring中，构成你的应用程序的骨干并由Spring IoC容器管理的对象被称为Bean。Bean是一个由Spring IoC容器实例化、组装和管理的对象。否则，Bean只是你的应用程序中众多对象中的一个。Bean以及它们之间的依赖关系都反映在容器使用的配置元数据中。<br> org.springframework.beans 包遵守 JavaBeans 标准。JavaBean是一个具有默认无参数构造函数的类，它遵循一个命名惯例(getters/setters)<br> <em>具有默认无参构造函数可方便Spring等使用者新建一个对象，而不用去记忆应当如何向构造函数中传参数。如果想设置某个属性，应使用set方法</em><br> SpringBean除了遵循JavaBean规范，在容器本身中，这些Bean定义被表示为 BeanDefinition 对象，还具有一些Spring要用到的元数据：</p> 
<ul><li>一个全路径类名：通常，被定义的Bean的实际实现类。</li><li>Bean的行为配置元素，它说明了Bean在容器中的行为方式（scope、生命周期回调，等等）。</li><li>对其他Bean的引用，这些Bean需要做它的工作。这些引用也被称为合作者或依赖。</li><li>要在新创建的对象中设置的其他配置设置—​例如，pool的大小限制或在管理连接池的Bean中使用的连接数。</li></ul> 
<p>Bean定义：用xml或注解（@Configuration, @Bean, @Import等）来配置一个SpringBean。<br> *组件定义(创建类)定义了组件有哪些属性等；Spring的Bean定义xml或注解关联了对应的类、注入的依赖等 *<br> 当你创建一个Bean定义（definition）时，你创建了一个“配方”，用于创建该Bean定义（definition）是所定义的类的实际实例。Bean定义是一个“配方”的想法很重要，因为它意味着，就像一个类一样，你可以从一个“配方”中创建许多对象实例。</p> 
<h2><a id="JavaEE_JakartaEE_194"></a>JavaEE JakartaEE开发</h2> 
<p>1999年,jdk1.2年代，java分出三个版本，其中企业平台（主要用于服务端）的J2EE后来演变为javaEE-&gt;jakartaEE（由eclipse基金会接手）<br> javaEE需要EE环境，如eclipse基金会的GlassFish。完整的JavaEE环境的实现集web容器、EJB容器、依赖注入等于一身，十分重量级。<br> 对现在的程序员来说，其用法类似spring(依赖注入、控制反转、组件容器）和tomcat(web服务器、servlet容器)，但其实是spring以更好的方法实现功能，javaEE也互相学习的结果。spring由公司Pivotal支持（该公司也参与过12年左右的12306研发），且改进和提升新功能更快，现在也实现了一些EE规范，如SpringJPA；但spring不实现EE的组件容器，spring使用tomcat\jboss或者他们的servletAPI等来实现javaEE应用。<br> 现在EE甚至提供了类似spingboot起始页的脚手架网站：https://start.jakarta.ee/。下载后可以打包成War包运行在JavaEE容器如Eclipse GlassFish中，或是直接打包运行在docker中。<br> 如果添加Embedded Eclipse GlassFish依赖来使用嵌入式的GlassFish，可以像springboot使用嵌入式tomcat一样，不用在本地单独安装GlassFish环境。<br> 当然就算不使用一套EE，我们也经常单独引入其部分环境，如serveltAPI，javaMail。这种使用部分依赖的方式是最常见的，也可以同spring结合使用。<br> 问：VO called View Object, and also called as Value Object. what is the difference between they, or they just are two names for the same thing.</p> 
<p>答：Yes, you are correct. VO is short for View Object and Value Object. They are two names for the same thing. A View Object is an object that represents the data that will be displayed in the user interface. A Value Object is an object that represents a descriptive aspect of the domain with no conceptual identity. Its identity is based on its state rather than on its object identity and is immutable.</p> 
<p>answer from New Bing.</p> 
<p>Value Object翻译: "Value Object”是指代表领域中的描述性方面的对象，没有概念上的身份。它的身份基于其状态而不是其对象身份，并且是不可变的。</p> 
<h3><a id="EJB_208"></a>EJB</h3> 
<p>早期EJB和现在的有很大区别；根据百度百科，从EJB 3.0规范（JSR 220）开始为了迎合这个趋势相比于其前辈进行了一次激进的大跳跃。受到Spring 影响，EJB 3.0也使用所谓的“传统简单Java对象（POJO）”；同时，支持依赖注入来简化全异系统的集成与配置。Hibernate的创始人Gavin King参与了这一新版规范的制订，并对EJB大加提倡。Hibernate的许多特性也被引入到Java持久化API当中，从而取代原来的实体bean。EJB 3.0规范大幅采用Java注释（annotation）来对代码进行元数据修饰，从而消减了此前EJB编程的冗杂性。<br> 相应地，EJB 3.0几乎成为了一个全新的API，与此前的数版可谓毫无相似度可言 <sup class="footnote-ref"><a href="#fn3" rel="nofollow" id="fnref3">3</a></sup>。</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 为什么spring想到用pojo?</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 这只是注解模式的胜利吗？</li></ul> 
<p>EJB是一个<strong>封装了业务逻辑的服务端组件</strong><br> EJB 容器提供了 为企业 Bean 提供系统级服务，Bean 开发人员可以 专注于解决业务问题。EJB 容器，而不是 Bean 开发人员负责系统级服务，例如 事务管理和安全授权。<br> <em>这么看来，EJB相当于一个大而全的框架。</em></p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 单EJB就相当于重量级spring或者py中的django?那EE呢？<br> 同客户端的javaBean相比（平常说的javaBean?），EJB包含业务逻辑（这么说javaBean又不包含了？）</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> business logic 与 service</li></ul> 
<p>两种EJB</p> 
<table><tbody><tr><td>session 会话 </td><td>为客户端执行任务;也可以实现web服务</td></tr><tr><td>Message-driven</td><td>充当特定消息传递类型的侦听器， 例如 Java Message Service API</td></tr></tbody></table> 
<h4><a id="Session_bean_234"></a>Session 会话bean</h4> 
<p>会话 Bean 封装了可以调用的业务逻辑，可以被远程调用。<br> 客户端调用会话 Bean 的方法，然后服务器上的(Session Bean?应用程序？)为本地执行复杂的业务逻辑<br> <em>看起来像是员远程程序在本地的接口、句柄之类的。dubbo等微服务也是代码实现在远程，本地调用某个组件的方法来通知服务(service)运行；<br> 使用上也类似本地客户端MVC案例中，controller把view和model当作自己的成员直接调用他们的方法。也许我应该把他们仨放一个视图里</em><br> <em>这有些view和service分离的意思</em><br> Session Bean不持久化。<br> 三种类型：</p> 
<ul><li>有状态 Stateful Session Beans</li><li>无状态 Stateless Session Beans</li><li>单例 Singleton Session Beans</li></ul> 
<h4><a id="Messagedriven_Bean_245"></a>Message-driven Bean</h4> 
<p>消息驱动的 Bean 是 用于异步处理消息的应用程序。通常充当 JMS 消息侦听器，类似于事件 侦听器，但接收的是 JMS 消息而不是Event。可以处理 JMS 消息或其他类型的消息。</p> 
<p>消息驱动的 Bean 和会话之间最明显的区别 Bean 是客户端不通过 接口。<br> 当消息到达时，容器会调用消息驱动的 Bean 的onMessage方法来处理消息。JavaEE？为其封装了事务和回滚机制。</p> 
<h3><a id="_Session_Bean_250"></a>客户端访问 Session Bean</h3> 
<p>客户端通过buiness Interface或者无接口视图（ no-interface views）访问Session Bean<br> <em>Message-driven Bean没有这俩东西</em><br> 业务接口buiness Interface方式就是标准的java Interface。（像微服务那种通过接口调用（写好对应方法的？我记得也有光名字的。另外这种方式是不是形成了两边共同以来service包的项目结构？））<br> 企业bean的无接口视图只暴露公有方法的方式让客户端调用。<br> <em>看到这儿反而理解什么是接口了，是不是对使用者来说是接口。话说真有先定接口一起开发的么</em><br> 封装与隐藏，，哈。虽然对OOP初学者来讲可能用spring案例更好些，毕竟EJB用家少<br> 然后原文就是分层/CS架构隔离的那种布拉布拉，隔离客户端和企业bean什么的好处之云</p> 
<h4><a id="_Bean_259"></a>在客户机中使用企业 Bean</h4> 
<p>客户端获取一个企业bean的实例的方法：</p> 
<ul><li>依赖注入</li><li>Java注解</li><li>JNDI lookup, using the Java Naming and Directory Interface Java命名和目录接口语法</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 注解和依赖注入是两种？</li></ul> 
<p>依赖注入是获取企业 Bean 的最简单方法 参考。在 Java EE 服务器管理的环境中运行的客户机， JavaServer Faces Web 应用程序、JAX-RS Web Service、其他企业 Bean 或 Java EE 应用程序客户机支持通过注解@EJB实现依赖注入</p> 
<p>在 Java EE 服务器管理的环境之外运行的应用程序，例如 作为 Java SE 应用程序，必须执行显式查找。JNDI 支持 用于标识 Java EE 组件的全局语法，以简化此操作 显式查找。</p> 
<p>Create an enterprise bean implementation class that does not implement a business interface, indicating that the bean exposes a no-interface view to clients. For example:</p> 
<p>@Session<br> public class MyBean { … }<br> Annotate the business interface of the enterprise bean as a interface. For example:@Local</p> 
<p>@Local<br> public interface InterfaceName { … }<br> Specify the interface by decorating the bean class with and specify the interface name. For example:@Local</p> 
<p>@Local(InterfaceName.class)<br> public class BeanName implements InterfaceName { … }</p> 
<p>远程：<br> @Remote<br> public interface InterfaceName { … }</p> 
<h2><a id="POJO_288"></a>POJO</h2> 
<p>Plain Old Java Object是一种使用最简单的Java对象来表达轻量级域模型的编程风格。<br> 　　POJO是MartinFowler等人发明的一个术语，用来表示普通的Java对象。</p> 
<blockquote> 
 <p>在那次谈话中我们指出将业务逻辑(business logic)写进常规(regular)Java对象而不是使用<strong>Entity Beans</strong>的好处。我们疑惑为什么人们不喜欢在他们的系统中使用普通的对象，得到的结论是——普通的对象缺少一个响亮的名字。因此我们起了一个名字，并且取得了很好的效果。——Martin Fowler,2000<sup class="footnote-ref"><a href="#fn4" rel="nofollow" id="fnref4">4</a></sup></p> 
</blockquote> 
<p>此句中的POJO特征：相对于JavaEE中EJB相关概念Entity Beans诞生，与EJB一样负责业务逻辑，<br> 但是不用像EJB一样需要强制实现接口、重写方法等麻烦事。</p> 
<p><em>纯粹(pure,plain)、普通、常规(ordinary,regular)、老式(old)：相对于EJB1、2之流一定要实现接口而言（2000年只需要注解的EJB3还没有出现，但spring已经出现，需考察早期spring与pojo）。因此有人说“POJO是不强制实现任何特殊的Java框架的接口的类”，但这只是对pojo特征之一的抽象描述，而没有考虑到pojo的提出背景。这些做减法的概念做下来，我们发现只要用JavaSE的基础语法写个实现业务逻辑的类就是pojo了。起名为“POJO”只是为了强调这一点<br> POJO一词的考证和演化极为困难，同javabean不同，没有官方下场维护POJO定义，POJO的意思意思又经历了演变。可以说这个词被“污染”的极其严重。</em><br> 其他类似的描述都是这个意思：<br> 　　POJO包含业务逻辑或持久逻辑等，但不是JavaBean, EntityBean 或者 企业Bean（这些都指java官方定义的规范）。POJO不担当任何特殊的角色，也不实现任何特殊的Java框架的接口如，EJB， JDBC等等。（一说为不强制要求继承，而且也不要求注解）<br> 　　<em>但是如果说“pojo与数据库一一对应被orm使用”，我们发现orm如hibernate需要添加注解</em></p> 
<p><em>而另一些描述：pojo只有getter/setter，pojo 和orm对应，应该是后来pojo概念演化后，又再次被抽象某些特征描述。</em></p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 提出的时候是不是没想到注解，注解不用实现方法，即使生命周期方法？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 同前端javabean都要考虑的一个问题：为什么业务逻辑在后端，这应该就是“有没有业务逻辑”的讨论，因为前端javabean在前端，pojo提出时可以又业务逻辑，所以在后端</li></ul> 
<p><em>看起来MF最初的意思可能是写业务逻辑的，是作为服务端bean让前端直接调用吗？那他怎么解决远程调用问题？还是说存在大量本地用EJB的，管理不如直接调用？，，，怎么后来又变了</em></p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 那这段时间的Spring怎么想到的用pojo?hibernate怎么定义领域对象？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> servelt也是这么麻烦，我记得Web在EE是EJB2.X支持的？但web不用applet、javaclient的话，怎么用浏览器调用远程业务逻辑？两个EJB中又是怎么调用的远程逻辑？不是现在的微服务</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 领域这种思想范围比pojo这种只有java的概念大</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> spring比起buiniss logic，似乎用了@Service。是面向服务，还是为了包装业务逻辑？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> EJB是为了什么让业务逻辑放服务器？前端javaBean组件不用业务逻辑是为了视图层方便通用吗？ 
  <ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 进一步想，是不是COA的思想组件就不应有专业的业务逻辑？业务逻辑一定专业话吗？毕竟事务之类的框架支持了</li></ul> </li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 为什么高级语言的se版本都不直接把企业给支持了？什么是高级语言的最低标准，调用计算机？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> pojo分类哪里提出的？</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 充血模型与贫血模型与pojo运动</li></ul> 
<p>但相处久了就不爱了，程序员们渐渐发现，EJB虽然非常强大，但是使用起来太麻烦，编程的过程很重，并不轻量级。比如：<br> <img src="https://images2.imgbox.com/97/ad/WXuK6fUb_o.png" alt=""></p> 
<p>再比如：在实例等的继承上并不便捷，很多已经有的实例需要重新定义 等等。</p> 
<p>程序员们说：我就想更多的focus on业务逻辑，这些开发环境和开发过程的问题能不能不要烦我。</p> 
<p>于是大家发起了一场名为POJO的运动（Plain Ordinary Java Object / Pure Old Java Object即“普通Java对象”），这种精简、纯粹的Java对象编写方式称为POJO。</p> 
<p>2005年一个叫 Rod Johnson的大牛（他实际上是音乐学博士，牛人一般可能都“不务正业”），推出了一个叫做spring的开发框架，在这套框架下，编写Java程序是满足POJO的极简风格的，所以大受欢迎。</p> 
<p>他出过一本书《Expert one on one J2EE development without EJB》，要开发企业级程序without EJB，可以看出他的野心。</p> 
<p>另外，spring可以方便的对接很多其他处理框架，比如对接更为方便的数据库处理框架：Hiberate（想起了自己当年的本科毕设）等等。</p> 
<p>总之，这样一个spring框架真的帮助程序员们又一次脱离了苦海。虽然后来EJB也在简化开发风格，但是被spring框架拉走的程序员越来越多。</p> 
<blockquote> 
 <p>阿里Java开发手册中，也不建议在POJO的setter中添加业务逻辑，主要是为了方便debug，不需要操心setter的内部逻辑了，<strong>把业务逻辑限制在业务层范围内。</strong>（这里是结合了分层架构的思想）<br> 那么这里就混淆了似乎，不让pojo写业务逻辑了</p> 
</blockquote> 
<p>博主们常说POJO可分为DO / DTO / BO / VO 等。但如果早期pojo运动提到过拓展的话，更严谨的说法不是“分为了”各种对象，而是pojo因其简单而方便“拓展为”各类对象。<br> 阿里Java开发规范：</p> 
<ul><li> <p>DO（Data Object）/PO（Persistent Object）：和数据库表一 一对应，通过数据层（DAO）向上传输数据源对象。</p> </li><li> <p>DTO（Data Transfer Object ）：数据传输对象，Service或Manager向外传输的对象。</p> 
  <ul><li>Data Transfer Object（数据传输对象）：在进程间进行数据传递的对象，目的是减少进程间方法调用的次数。《企业应用架构模式》</li></ul> </li><li> <p>BO（Business Object）：业务对象，可以由Service层输出的封装业务逻辑的对象。</p> </li><li> <p>Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。</p> </li><li> <p>VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。？？输出这玩意儿？业务逻辑？怎么不直接service服务做业务逻辑</p> </li><li> <p>Value Object，有的也称为View Object，即值对象或页面对象。一般用于web层向view层封装并提供需要展现的数据。</p> </li></ul> 
<p>PO是由Hibernate纳入其实体容器（Entity Map）的对象，它代表了与数据库中某条记录对应的Hibernate实体，PO的变化在事务提交时将反应到实际数据库中。如果一个PO与Session对应的实体容器中分离（如Session关闭后的PO），那么此时，它又会变成一个VO。</p> 
<p>由Hibernate VO和Hibernate PO的概念，又引申出一些系统层次设计方面的问题。如在传统的MVC架构中，位于Model层的PO，是否允许被传递到其他层面。由于PO的更新最终将被映射到实际数据库中，如果PO在其他层面（如View层）发生了变动，那么可能会对Model 层造成意想不到的破坏。</p> 
<p>因此，一般而言，应该避免直接PO传递到系统中的其他层面，一种解决办法是，通过一个VO，通过属性复制使其具备与PO相同属性值，并以其为传输媒质（实际上，这个VO被用作Data Transfer Object，即所谓的DTO），将此VO传递给其他层面以实现必须的数据传送。<br> ————————————————<br> 版权声明：本文为CSDN博主「true…」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/zhanxxiao/article/details/109349444<br> 具体怎么使用，公司约定大于其定义，这里仅供参考。比如，在列表页中的VO要被EasyExcel导出成excel，那么这个导出类要直接复用VO吗？看公司习惯如何来决定。<br> 一个是阿里巴巴的开发手册中的定义<br> DO（ Data Object）这个等同于上面的PO<br> 另一个是在DDD（Domain-Driven Design）领域驱动设计中<br> DO（Domain Object）这个等同于上面的BO</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> idea连接数据库后标记的persistence对象</li></ul> 
<p>POJO—单数据库实体类<sup class="footnote-ref"><a href="#fn5" rel="nofollow" id="fnref5">5</a></sup><br> EJB–多数据库，远程实体，复杂应用<br> POJO 简单理解为 不包含业务逻辑的单纯用来存储数据的 java类即可。<br> 实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称<br> 当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。</p> 
<p>POJO是Plain Ordinary Java Objects的缩写不错，但是它通指没有使用Entity Beans的普通java对象，可以把POJO作为支持业务逻辑的协助类。</p> 
<p>POJO对象有时也被称为Data对象，大量应用于表现现实中的对象。<br> <em>个人总结：<br> 同javabean类似，pojo是一种规范，而不是编译器语法检查；<br> 同javabean不同，pojo没有任何官方组织下场维护规范，并证明自己的权威，导致如今溯源麻烦</em></p> 
<p>so DTO转VO这种pojo之间的转换，，最佳实践是什么，，或者好一些的实践<br> vo只留前端用的字段<br> 有的字段太大会导致报文too large</p> 
<p>上次说的那种，数据库里int表示状态，前端用字符串的，转换成String这一步你们是是转VO时干，还是字典也发到前端让前端干<br> 后端干<br> 比如长的数据long直接给前端<br> 数字类型的json<br> 会丢精度</p> 
<p>问：VO called View Object, and also called as Value Object. what is the difference between they, or they just are two names for the same thing.</p> 
<p>答：Yes, you are correct. VO is short for View Object and Value Object. They are two names for the same thing. A View Object is an object that represents the data that will be displayed in the user interface. A Value Object is an object that represents a descriptive aspect of the domain with no conceptual identity. Its identity is based on its state rather than on its object identity and is immutable.</p> 
<p>answer from New Bing.</p> 
<p>Value Object翻译: "Value Object”是指代表领域中的描述性方面的对象，没有概念上的身份。它的身份基于其状态而不是其对象身份，并且是不可变的。</p> 
<h2><a id="MVCMVVMModel_405"></a>MVC、MVVM等中的Model</h2> 
<blockquote> 
 <p>https://learn.microsoft.com/zh-cn/previous-versions/msp-n-p/hh848246(v=pandp.10) windows phone开发<br> MVVM 中的模型是应用程序域模型的实现，其中包括数据模型以及业务和验证逻辑。模型对象的示例包括存储库、业务对象、数据传输对象 （DTO）、普通旧 CLR 对象 （POCO） 以及生成的实体和代理对象。</p> 
</blockquote> 
<h3><a id="_410"></a>数据库概念</h3> 
<h2><a id="_412"></a>控件</h2> 
<p>学习顺序：<br> mvvm:view和数据直接关联<br> query:业务层直接传到数据层查询<br> DTO：查完了直接传回去</p> 
<h2><a id="COM_418"></a>COM</h2> 
<p>面向对象语言方便创建com？rust go python?<br> Microsoft 组件对象模型 (COM) 是一个独立于平台的分布式面向对象的系统，用于创建可以交互的二进制软件组件。 COM 是 Microsoft 的 OLE (复合文档的基础技术，) 、ActiveX (支持 Internet 的组件) 以及其他组件。</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 这是CBA在分布式上的实践？类似EJB?</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 微服务怎么就更合适分布式了感觉，服务直接成了分布式。组件分布式就这里这俩</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 通过使用 CoCreateGuid 函数或 COM 创作工具（例如在内部调用此函数的 Visual Studio）获取新的 CLSID。 这个有些像SerialID？</li></ul> 
<h2><a id="DDD_426"></a>DDD</h2> 
<h3><a id="domain_427"></a>领域驱动模型中的domain</h3> 
<blockquote> 
 <p>Domain Model（领域模型）：既包含行为，又包含数据的<strong>领域</strong>的对象模型。<br> 领域模型创建了一张由互联对象组成的网，其中的每一个对象都代表某个有意义的个体，可能大到一个公司或者小到订单中的一行。<br> 领域模型衍生出两种风格。简单领域模型看起来与数据库设计很类似，这种设计中几乎每一个数据库表都与一个领域对象对应。而复杂领域模型则与数据库设计不同，它使用继承、策略和其他设计模式，是一张由互联的细粒度对象组成的复杂网络。复杂领域模型更适合于复杂的逻辑，但它到数据库的映射比较困难。简单领域模型可以使用活动记录，而复杂领域模型需要使用数据映射器。<br> — 《企业应用架构模式》</p> 
</blockquote> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> domain的常量放在那里？pojo？</li></ul> 
<h3><a id="_434"></a>贫血模型</h3> 
<p>1.介绍</p> 
<p>贫血模型是指领域对象里只有get和set方法（POJO），所有的业务逻辑都不包含在内而是放在Business Logic层。<br> 2.优点</p> 
<p>各层单向依赖，结构清楚，易于实现和维护。</p> 
<p>设计简单易行，底层模型非常稳定。</p> 
<p>3.缺点</p> 
<p>domain object的部分比较紧密依赖的持久化domain logic被分离到Service层，显得不够OO。<br> <em>应该是说数据 逻辑没封装所以不够OO把</em><br> Service层过于厚重。</p> 
<p>4.代码样例</p> 
<p>我们一般使用三层架构进行业务开发：<br> Repository + Entity<br> Service + BO（Business Object）<br> Controller + VO（View Object）</p> 
<p>在三层架构业务开发中，大家经常使用基于贫血模型的开发模式。贫血模型是指业务逻辑全部放在service层，业务对象只包含数据不包含业务逻辑。</p> 
<h3><a id="_460"></a>充血模型</h3> 
<p>1.介绍</p> 
<p>充血模型是指数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p> 
<p>2.优点</p> 
<p>面向对象，Business Logic符合单一职责，不像在贫血模型里面那样包含所有的业务逻辑太过沉重</p> 
<p>3.缺点</p> 
<p>缺点是如何划分业务逻辑，什么样的逻辑应该放在Domain Object中，什么样的业务逻辑应该放在Business Logic中，这是很含糊的。</p> 
<p>那么切分的原则是什么呢：Rod Johnson提出原则是“case by case”，可重用度高的，和domain object状态密切关联的放在Domain Object中，可重用度低的，和domain object状态没有密切关联的放在Business Logic中。</p> 
<p>经过上面的讨论，如何区分domain logic和business logic，我想提出一个改进的区分原则：domain logic只应该和这一个domain object的实例状态有关，而不应该和一批domain object的状态有关。</p> 
<p>当你把一个logic放到domain object中以后，这个domain object应该仍然独立于持久层框架之外(Hibernate, JDO)，这个domain object仍然可以脱离持久层框架进行单元测试，这个domain object仍然是一个完备的，自包含的，不依赖于外部环境的领域对象，这种情况下，这个logic才是domain logic。</p> 
<p>4.代码样例</p> 
<p>在基于充血模型DDD开发模式中我们引入了Domain层。Domain层包含了业务对象BO，但并不是仅仅包含数据，这一层也包含业务逻辑，我们来看代码实例。</p> 
<p>三、对比分析</p> 
<p>1.为什么基于贫血模型的传统开发模式如此受欢迎？</p> 
<p>基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了 OOP 的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的 Web 项目，都是基于这种贫血模型的开发模式，甚至连 Java Spring 框架的官方 demo，都是按照这种开发模式来编写的。</p> 
<p>面向过程编程风格有种种弊端，比如，数据和操作分离之后，数据本身的操作就不受限制了。任何代码都可以随意修改数据。既然基于贫血模型的这种传统开发模式是面向过程编程风格的，那它又为什么会被广大程序员所接受呢？关于这个问题，主要是有下面三点原因。</p> 
<p>第一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。</p> 
<p>第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。</p> 
<p>第三点原因是，思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。你随便问一个旁边的大龄同事，基本上他过往参与的所有 Web 项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的。</p> 
<p>2.什么项目应该考虑使用基于充血模型的 DDD 开发模式？</p> 
<p>相对应的，基于充血模型的 DDD 开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。</p> 
<p>你可能会有一些疑问，这两种开发模式，落实到代码层面，区别不就是一个将业务逻辑放到 Service 类中，一个将业务逻辑放到 Domain 领域模型中吗？为什么基于贫血模型的传统开发模式，就不能应对复杂业务系统的开发？而基于充血模型的 DDD 开发模式就可以呢？</p> 
<p>实际上，除了我们能看到的代码层面的区别之外（一个业务逻辑放到 Service 层，一个放到领域模型中），还有一个非常重要的区别，那就是两种不同的开发模式会导致不同的开发流程。基于充血模型的 DDD 开发模式的开发流程，在应对复杂业务系统的开发的时候更加有优势。为什么这么说呢？我们先来回忆一下，我们平时基于贫血模型的传统的开发模式，都是怎么实现一个功能需求的。</p> 
<p>不夸张地讲，我们平时的开发，大部分都是 SQL 驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 SQL 语句来获取数据。之后就是定义 Entity、BO、VO，然后模板式地往对应的 Repository、Service、Controller 类中添加代码。</p> 
<p>业务逻辑包裹在一个大的 SQL 语句中，而 Service 层可以做的事情很少。SQL 都是针对特定的业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的 SQL 语句，这就可能导致各种长得差不多、区别很小的 SQL 语句满天飞。</p> 
<p>所以，在这个过程中，很少有人会应用领域模型、OOP 的概念，也很少有代码复用意识。对于简单业务系统来说，这种开发方式问题不大。但对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护。</p> 
<p>如果我们在项目中，应用基于充血模型的 DDD 的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。</p> 
<p>————————————————</p> 
<p>版权声明：本文为CSDN博主「、Dong」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 话说这样的分层考虑到程序员工作量分配了么？工作中的pm是怎么管pm分配的呢？还是说单纯假设会分开不同人？这个想法来自知乎评论区</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 事实上一个人实现一个小功能的话全部层都要实现，分层也可以被其他人复用，，，考虑这点，似乎不是为了分人而分层。</li></ul> 
<h2><a id="_543"></a>实体</h2> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>b2b<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>admin<span class="token punctuation">.</span>pms</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Entity基类
 *
 * @author ruoyi
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BaseEntity</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>
</code></pre> 
<p>这个有起止时间，这是实体该干的事吗？<br> 应该是数据库的概念，实体关系</p> 
<h2><a id="DTO_557"></a>DTO模式</h2> 
<p>使用 DTO 工厂<br> DTO 工厂可用于以一致且高效的方式创建 DTO。工厂也可用于在创建 DTO 之前验证数据。</p> 
<h2><a id="RESTFul_561"></a>RESTFul资源</h2> 
<h2><a id="_563"></a>拓展</h2> 
<p>Plain Old CLR Object 是 Java EE 编程界术语 plain old Java object 的玩法，由 Martin Fowler 于 2000 年提出。 [2] POCO 通常扩展为普通的旧 C# 对象，尽管可以使用任何面向 CLR 的语言创建 POCO。有时使用的替代首字母缩略词是普通的旧 .NET 对象。 https://wikimili.com/en/Plain_old_CLR_object#cite_note-2</p> 
<h2><a id="_565"></a>参考</h2> 
<ul><li>EJB学习资源 
  <ul><li><a href="https://javaee.github.io/javaee-spec/javadocs/" rel="nofollow">javaEE8API文档_EJB3.0</a></li><li><a href="https://javaee.github.io/tutorial/ejb-gettingstarted002.html#GIPSS" rel="nofollow">javaEE8官网教程_创建EJB3.0</a></li><li><a href="https://jakarta.ee/learn/docs/jakartaee-tutorial/current/entbeans/ejb-intro/ejb-intro.html#_accessing_enterprise_beans" rel="nofollow">Jakarta EE 教程_EJB</a> 甚至这个访问更快</li><li>EJB JSR规范：https://jcp.org/en/jsr/detail?id=220 更老版本的虽然sun公司网站已经不存在了，但可以从JSR上下载到文档</li></ul> </li></ul> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> @Component</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> POJO对象有时也被称为Data对象，大量应用于表现现实中的对象。如果项目中使用了Hibernate框架，有一个关联的xml文件，使对象与数据库中的表对应，对象的属性与表中的字段相对应。–博客园</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> rust python 组件模型</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 设计接口的时候想着大家按框架规矩走生命周期，没想到注解标注更方便？ 
  <ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 那多态使用是接口的优势了？</li></ul> </li></ul> 
<hr class="footnotes-sep"> 
<section class="footnotes"> 
 <ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://docs.oracle.com/javase/tutorial/javabeans/" rel="nofollow">oracle的JAVA Bean教程</a>该教程基于GUI和开发工具NetBeans。这种GUI组件的概念类似“控件”，如Visual Basic中的控件。在现在专注于服务端、更抽象的服务端组件的应用场景下，该教程中的GUI案例仅作理解，明白bean就是容易复用的<strong>组件</strong>规范即可。 <a href="#fnref1" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn2" class="footnote-item"><p><a href="https://springdoc.cn/spring/core.html#beans-introduction" rel="nofollow">Spring中文网对于bean的介绍</a> <a href="#fnref2" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn3" class="footnote-item"><p>王博, 陈莉君. JAVA BEAN的分析和应用[J]. 西安文理学院学报(自然科学版), 2008, 11(1):92-96. <a href="#fnref3" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn4" class="footnote-item"><p><a href="https://martinfowler.com/bliki/POJO.html" rel="nofollow">Martin Fowler</a>在领域驱动设计、架构模式、敏捷开发和持续交付等领域享有盛誉。曾出版图书《重构:改善既有代码的设计》、《领域特定语言》、《企业应用架构模式》等。<br> “GUI Architectures” <a href="#fnref4" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn5" class="footnote-item"><p>https://bbs.csdn.net/topics/360238939 处大佬们的讨论 <a href="#fnref5" rel="nofollow" class="footnote-backref">↩︎</a></p> </li></ol> 
</section>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/05210c7eef27cd4badbe813ba8aaa9ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 代理模式详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f265d2c581a48433ed82ebdf3b9f6845/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows下安装Nacos完整过程（傻瓜式教程）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>