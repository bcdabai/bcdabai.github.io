<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>用Tcp实现文件传输 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="用Tcp实现文件传输" />
<meta property="og:description" content="客户端client.h
#ifndef CLIENT_H #define CLIENT_H #include &lt;QWidget&gt; #include &lt;QUdpSocket&gt; #include &lt;QTcpSocket&gt; #include &lt;QFile&gt; #include &lt;QFileDialog&gt; #include &lt;QProgressBar&gt; #include &lt;QTimer&gt; #include &lt;QDebug&gt; #include &#34;stdlib.h&#34; namespace Ui { class client; } class client : public QWidget { Q_OBJECT public: explicit client(QWidget *parent = 0); Ui::client *ui; ~client(); private: QTcpSocket *tcpClient; QFile *localFile; QPushButton *btn1,*btn2; QDialog *dialog; //资源选择框 QPushButton *btn3; QProgressBar *bar1; QString filename; //保存文件路径 QByteArray outBlock; //数据缓冲区 qint64 totalBytes; //文件总字节数 qint64 fileSize; //文件名字的字节数 qint64 bytestoWrite; //尚未发送的字节数 qint64 bytesWritten; //已发送的字节数 qint64 loadSize; //每次发送数据的大小 private slots: void updateFileProgress(qint64 numBytes); //更新文件发送进度 void send_File(); //发送文件 void select_File(); //选择文件 void startTransfer(); //发送文件大小等信息 }; #endif // client." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ba06b772a220f069cf5946848c27ca0d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-03T17:09:54+08:00" />
<meta property="article:modified_time" content="2022-07-03T17:09:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">用Tcp实现文件传输</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>客户端client.h</p> 
<pre><code class="language-cpp">#ifndef CLIENT_H
#define CLIENT_H

#include &lt;QWidget&gt;
#include &lt;QUdpSocket&gt;
#include &lt;QTcpSocket&gt;
#include &lt;QFile&gt;
#include &lt;QFileDialog&gt;
#include &lt;QProgressBar&gt;
#include &lt;QTimer&gt;
#include &lt;QDebug&gt;

#include "stdlib.h"

namespace Ui {
class client;
}

class client : public QWidget
{
    Q_OBJECT

public:
    explicit client(QWidget *parent = 0);
    Ui::client *ui;
    ~client();

private:  


    QTcpSocket *tcpClient;
    QFile *localFile;
    QPushButton *btn1,*btn2;
    QDialog *dialog;    //资源选择框
    QPushButton *btn3;

    QProgressBar *bar1;

    QString filename;       //保存文件路径
    QByteArray outBlock;     //数据缓冲区
    qint64 totalBytes;       //文件总字节数
    qint64 fileSize;         //文件名字的字节数
    qint64 bytestoWrite;     //尚未发送的字节数
    qint64 bytesWritten;     //已发送的字节数
    qint64 loadSize;         //每次发送数据的大小
private slots:
    void updateFileProgress(qint64 numBytes);   //更新文件发送进度
    void send_File();       //发送文件
    void select_File();     //选择文件
    void startTransfer();   //发送文件大小等信息

};

#endif //
</code></pre> 
<p>client.cpp</p> 
<pre><code class="language-cpp">#include "client.h"
#include "ui_client.h"



client::client(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::boxing)
{
    ui-&gt;setupUi(this);
    tcpClient = new QTcpSocket(this);
    loadSize = 4*1024;
    totalBytes=0;
    bytestoWrite=0;
    bytesWritten=0;

    connect(tcpClient,SIGNAL(connected()),this,SLOT(startTransfer()));
    connect(ui-&gt;pushButton,SIGNAL(clicked(bool)),this,SLOT(select_File()));//连接选择文件按钮
    connect(ui-&gt;pushButton_4,SIGNAL(clicked(bool)),this,SLOT(send_File()));//连接发送文件按钮


 //只要数据已写入TCP套接字，byteswritten信号就会被发出
    connect(tcpClient,SIGNAL(bytesWritten(qint64)),this,SLOT(updateFileProgress(qint64)));
}

client::~client()
{
    delete ui;
}




void client::select_File()
{
   
    this-&gt;filename = QFileDialog::getOpenFileName(this,"Open a file","/a","files(*)");
    bar1-&gt;setValue(0);
}

void client::send_File()
{
    
    tcpClient-&gt;connectToHost("127.0.0.1",1234);//调试阶段用本机
}
void client::startTransfer()
{
    localFile = new QFile(filename);
    if(!localFile-&gt;open(QFile::ReadOnly))
    {
        qDdebug()&lt;&lt;"文件打开失败！"；
        return;
    }
    totalBytes = localFile-&gt;size();         //文件总大小
    QDataStream sendout(&amp;outBlock,QIODevice::WriteOnly);
    sendout.setVersion(QDataStream::Qt_4_8);
    QString currentFileName = filename.right(filename.size()-filename.lastIndexOf("/")-1);   
    sendout&lt;&lt;qint64(0)&lt;&lt;qint64(0)&lt;&lt;currentFileName;     //依次写入总大小信息空间，文件名大小信息空间，文件名
    totalBytes += outBlock.size();       //文件名大小和实际文件大小的总和
    sendout.device()-&gt;seek(0);
    //返回outblock的开始，用实际大小代替两个qint64空间
    sendout&lt;&lt;totalBytes&lt;&lt;qint64((outBlock.size()-sizeof(qint64)*2));
    bytestoWrite = totalBytes-tcpClient-&gt;write(outBlock);
    outBlock.resize(0);

}
void client::updateFileProgress(qint64 numBytes)
{
    bytesWritten += (int)numBytes;
    if(bytestoWrite&gt;0)
    {
        outBlock=localFile-&gt;read(qMin(bytestoWrite,loadSize));
        bytestoWrite -= ((int)tcpClient-&gt;write(outBlock));
        outBlock.resize(0);
    }
    else
    {
        localFile-&gt;close();
    }
    bar1-&gt;setMaximum(totalBytes);
    bar1-&gt;setValue(bytesWritten);
    dialog1-&gt;show();
    if(bytesWritten == totalBytes)
    {
      
        localFile-&gt;close();
        delete localFile;               
disconnect(tcpClient,SIGNAL(bytesWritten(qint64)),this,SLOT(updateFileProgress(qint64)));
        totalBytes=0;
        bytestoWrite=0;
        bytesWritten=0;
        tcpClient-&gt;close();
    }
}


</code></pre> 
<p>server.h</p> 
<pre><code class="language-cpp">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;
#include &lt;QApplication&gt;
#include &lt;QUdpSocket&gt;
#include &lt;QDebug&gt;
#include &lt;QThread&gt;
#include &lt;QTcpServer&gt;
#include &lt;QTcpSocket&gt;
#include &lt;QFile&gt;
#include &lt;QDataStream&gt;
#include &lt;QDir&gt;
#include &lt;QFileDialog&gt;
#include &lt;QSettings&gt;

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = 0);
    QTcpServer *fileserver;
    QTcpSocket *filesocket;
    ~MainWindow();
private:
    QString filename;     //存放文件名
    QFile *localfile;       //本地文件
    QByteArray inBlock;     //数据缓冲区
    qint64 totalBytes;      //文件总字节数
    qint64 bytestoWrite;    //尚未发送的字节数
    qint64 bytesWritten;    //已发送的字节数
    qint64 bytesReceived;   //已收到数据的大小
    qint64 filenameSize;    //存放文件名的大小
public slots:
    void acceptFileConnection();    //建立连接
    void updateFileProgres();       //更新进度，接受数据

};

#endif // MAINWINDOW_H
</code></pre> 
<p>server.cpp</p> 
<pre><code class="language-cpp">#include "mainwindow.h"
QSettings *configIni = new QSettings("config1.ini",QSettings::IniFormat);
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{

  

   filesocket = new QTcpSocket;
   fileserver = new QTcpServer;
   //tcp监听主代理传过来的文件信息
   fileserver-&gt;listen(QHostAddress("127.0.0.1"),1234);
   bytesReceived=0; //已经接受的数据包
   bytesReceived=0; //已经接受的数据包
   totalBytes=0;//总大小
   filenameSize=0;//文件名大小
   //当发现新连接时发出newConnection()信号
   connect(fileserver,SIGNAL(newConnection()),this,SLOT(acceptFileConnection()));

}

MainWindow::~MainWindow()
{
    delete recv_vm;
    delete recv_zhu;
    delete fileserver;
    delete filesocket;
    delete localfile;
}

void MainWindow::acceptFileConnection()
{
    filesocket = fileserver-&gt;nextPendingConnection();
    connect(filesocket,SIGNAL(readyRead()),this,SLOT(updateFileProgres()));//tcpsocket连接操作
  
}
void MainWindow::updateFileProgres()
{
    QDataStream infile(filesocket);
    infile.setVersion(QDataStream::Qt_4_8);
    if(bytesReceived&lt;= sizeof(qint64)*2)
    {
        //如果接收到的数据小于16个字节，那么是刚开始接收数据，保存到头文件
        if((filesocket-&gt;bytesAvailable()&gt;=sizeof(qint64))*2&amp;&amp;(filenameSize==0))
        {
            //总大小信息和文件名大小信息
           infile&gt;&gt;totalBytes&gt;&gt;filenameSize;
           bytesReceived += sizeof(qint64)*2;
        }
        if((filesocket-&gt;bytesAvailable()&gt;=filenameSize)&amp;&amp;(filenameSize!=0))
        {
            //接收文件名并建立文件
            infile&gt;&gt;filename;
            bytesReceived += filenameSize;
            localfile = new QFile(filename);         
			QString filePath ="/fff";
            QDir dir(filePath);
            bool exits = dir.exists(filePath);
            if(exits)
            {
                qDebug()&lt;&lt;"文件夹已经存在";
            }
            else
            {
                bool ok = dir.mkdir(filePath);
                if(ok)
                   qDebug()&lt;&lt;"文件夹不存在，创建成功";
            }
            filePath = dir.absolutePath()+QString("/%1").arg(filename);
            localfile = new QFile(filePath);
             if(!localfile-&gt;open(QFile::WriteOnly))
             {
                 qDebug()&lt;&lt;"打开失败";
                 return;
             }
        }
        else return;
    }
    //如果接收的数据小于总数据，那么写入文件
    if(bytesReceived&lt;totalBytes)
    {
        bytesReceived += filesocket-&gt;bytesAvailable();
        inBlock =filesocket-&gt;readAll();
        localfile-&gt;write(inBlock);
        inBlock.resize(0);
    }
    //接收数据完成时
    if(bytesReceived==totalBytes)
    {
        bytesReceived=0;
        totalBytes=0;
        filenameSize=0;
        localfile-&gt;close();
    }

}

</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf6c3824d56be8a7da5b8720f82f76e4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【大话通信】第四章</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/448a9debebc4395b2f9c3ad8c5091626/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">电子信息类推免经验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>