<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL 递归 CTE(公共表表达式) -___MySQL 教程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL 递归 CTE(公共表表达式) -___MySQL 教程" />
<meta property="og:description" content="原文地址 www.yiibai.com
最近在做项目管理的项目，其中有层级关联，多模块情况，感觉平时的树状数据库设计不太行，所以了解了一下，突然看到了关于MySQL在8.0上面迭代的更新，非常不错
在本教程中，您将了解 MySQL 递归 CTE(公共表表达式) 以及如何使用它来遍历分层数据。 自 MySQL 8.0 版以来简要介绍了公共表表达式或叫 CTE 的功能，因此需要 MySQL 8.0及以上版本
在本教程中，您将了解 MySQL 递归 CTE(公共表表达式) 以及如何使用它来遍历分层数据。
自 MySQL 8.0 版以来简要介绍了公共表表达式或叫 CTE 的功能，因此需要您在计算机上安装 MySQL 8.0，以便在本教程中练习本语句。
MySQL 递归 CTE 简介 递归公用表表达式 (CTE) 是一个具有引用 CTE 名称本身的子查询的 CTE。以下说明递归 CTE 的语法 -
WITH RECURSIVE cte_name AS ( initial_query -- anchor member UNION ALL recursive_query -- recursive member that references to the CTE name ) SELECT * FROM cte_name; 递归 CTE 由三个主要部分组成：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e274422d03f769f9eebdaac5644121b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T09:54:53+08:00" />
<meta property="article:modified_time" content="2024-01-09T09:54:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL 递归 CTE(公共表表达式) -___MySQL 教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>原文地址 <a href="https://www.yiibai.com/mysql/recursive-cte.html" rel="nofollow">www.yiibai.com</a></p> 
</blockquote> 
<blockquote> 
 <p>最近在做项目管理的项目，其中有层级关联，多模块情况，感觉平时的树状数据库设计不太行，所以了解了一下，突然看到了关于MySQL在8.0上面迭代的更新，非常不错</p> 
</blockquote> 
<blockquote> 
 <p>在本教程中，您将了解 MySQL 递归 CTE(公共表表达式) 以及如何使用它来遍历分层数据。 自 MySQL 8.0 版以来简要介绍了公共表表达式或叫 CTE 的功能，因此需要 MySQL 8.0及以上版本</p> 
</blockquote> 
<p>在本教程中，您将了解 MySQL 递归 CTE(公共表表达式) 以及如何使用它来遍历分层数据。</p> 
<blockquote> 
 <p>自 <em>MySQL 8.0</em> 版以来简要介绍了公共表表达式或叫 <em>CTE</em> 的功能，因此需要您在计算机上安装 MySQL 8.0，以便在本教程中练习本语句。</p> 
</blockquote> 
<ol><li>MySQL 递归 CTE 简介</li></ol> 
<hr> 
<p>递归<a href="http://www.yiibai.com/mysql/cte.html" rel="nofollow" title="公用表表达式(CTE)">公用表表达式 (CTE)</a> 是一个具有引用 <em>CTE</em> 名称本身的子查询的 <em>CTE</em>。以下说明递归 <em>CTE</em> 的语法 -</p> 
<pre><code>WITH RECURSIVE cte_name AS (
    initial_query  -- anchor member
    UNION ALL
    recursive_query -- recursive member that references to the CTE name
)
SELECT * FROM cte_name;
</code></pre> 
<p>递归 <em>CTE</em> 由三个主要部分组成：</p> 
<ul><li>形成 <em>CTE</em> 结构的基本结果集的初始查询 (<em>initial_query</em>)，初始查询部分被称为锚成员。</li><li>递归查询部分是引用 <em>CTE</em> 名称的查询，因此称为递归成员。递归成员由一个 <a href="http://www.yiibai.com/sql-union-mysql.html" rel="nofollow" title="UNION ALL">UNION ALL</a> 或<code>UNION DISTINCT</code>运算符与锚成员相连。</li><li>终止条件是当递归成员没有返回任何行时，确保递归停止。</li></ul> 
<p>递归 <em>CTE</em> 的执行顺序如下：</p> 
<ol><li> <p>首先，将成员分为两个：锚点和递归成员。</p> </li><li> <p>接下来，执行锚成员形成基本结果集 (<code>R0</code>)，并使用该基本结果集进行下一次迭代。</p> </li><li> <p>然后，将<code>Ri</code>结果集作为输入执行递归成员，并将<code>Ri+1</code>作为输出。</p> </li><li> <p>之后，重复第三步，直到递归成员返回一个空结果集，换句话说，满足终止条件。</p> </li><li> <p>最后，使用<code>UNION ALL</code>运算符将结果集从<code>R0</code>到<code>Rn</code>组合。</p> </li><li> <p>递归成员限制</p> </li></ol> 
<hr> 
<p>递归成员不能包含以下结构：</p> 
<ul><li>聚合函数，如 <a href="http://www.yiibai.com/mysql/max-function.html" rel="nofollow" title="MAX">MAX</a>，<a href="http://www.yiibai.com/mysql/min.html" rel="nofollow" title="MIN">MIN</a>，<a href="http://www.yiibai.com/mysql/sum.html" rel="nofollow" title="SUM">SUM</a>，<a href="http://www.yiibai.com/mysql/avg.html" rel="nofollow" title="AVG">AVG</a>，<a href="http://www.yiibai.com/mysql/count.html" rel="nofollow" title="COUNT">COUNT</a> 等</li><li><a href="http://www.yiibai.com/mysql/group-by.html" rel="nofollow" title="GROUP BY">GROUP BY</a> 子句</li><li><a href="http://www.yiibai.com/mysql/order-by.html" rel="nofollow" title="ORDER BY">ORDER BY</a> 子句</li><li><a href="http://www.yiibai.com/mysql/limit.html" rel="nofollow" title="LIMIT">LIMIT</a> 子句</li><li><a href="http://www.yiibai.com/mysql/distinct.html" rel="nofollow" title="DISTINCT">DISTINCT</a></li></ul> 
<p>请注意，上述约束不适用于锚定成员。 另外，只有在使用<code>UNION</code>运算符时，要禁止<code>DISTINCT</code>才适用。 如果使用<code>UNION DISTINCT</code>运算符，则允许使用<code>DISTINCT</code>。</p> 
<p>另外，递归成员只能在其子句中引用 <em>CTE</em> 名称，而不是引用任何<a href="http://www.yiibai.com/mysql/subquery.html" rel="nofollow" title="子查询">子查询</a>。</p> 
<ol start="3"><li>简单的 MySQL 递归 CTE 示例</li></ol> 
<hr> 
<p>请参阅以下简单的递归 <em>CTE</em> 示例：</p> 
<pre><code>WITH RECURSIVE cte_count (n) 
AS (
      SELECT 1
      UNION ALL
      SELECT n + 1 
      FROM cte_count 
      WHERE n &lt; 3
    )
SELECT n 
FROM cte_count;
</code></pre> 
<p>在此示例中，以下查询：</p> 
<pre><code>SELECT 1
</code></pre> 
<p>是作为基本结果集返回<code>1</code>的锚成员。</p> 
<p>以下查询 -</p> 
<pre><code>SELECT n + 1
FROM cte_count 
WHERE n &lt; 3
</code></pre> 
<p>是递归成员，因为它引用了<code>cte_count</code>的 <em>CTE</em> 名称。</p> 
<p>递归成员中的表达式<code>&lt;3</code>是终止条件。当<code>n</code>等于<code>3</code>，递归成员将返回一个空集合，将停止递归。</p> 
<p>下图显示了上述 <em>CTE</em> 的元素：</p> 
<p><img src="https://images2.imgbox.com/1b/18/MuwrgZXd_o.png" alt=""></p> 
<p>递归 <strong>CTE</strong> 返回以下输出：</p> 
<p><img src="https://images2.imgbox.com/b9/4c/ZkAbfged_o.png" alt=""></p> 
<p>递归 <em>CTE</em> 的执行步骤如下：</p> 
<ul><li>首先，分离锚和递归成员。</li><li>接下来，锚定成员形成初始行 (<code>SELECT 1</code>)，因此第一次迭代在<code>n = 1</code>时产生<code>1 + 1 = 2</code>。</li><li>然后，第二次迭代对第一次迭代的输出 (<code>2</code>) 进行操作，并且在<code>n = 2</code>时产生<code>2 + 1 = 3</code>。</li></ul> 
<ol><li> <p>之后，在第三次操作 (<code>n = 3</code>) 之前，满足终止条件 (<code>n &lt;3</code>)，因此查询停止。</p> </li><li> <p>最后，使用<code>UNION ALL</code>运算符组合所有结果集<code>1</code>,<code>2</code>和<code>3</code>。</p> </li><li> <p>使用 MySQL 递归 CTE 遍历分层数据</p> </li></ol> 
<hr> 
<p>我们将使用<a href="http://www.yiibai.com/mysql/sample-database.html" rel="nofollow" title="示例数据库(yiibaidb)">示例数据库 (yiibaidb)</a> 中的<code>employees</code>表进行演示。</p> 
<pre><code>mysql&gt; desc employees;
+----------------+--------------+------+-----+---------+-------+
| Field          | Type         | Null | Key | Default | Extra |
+----------------+--------------+------+-----+---------+-------+
| employeeNumber | int(11)      | NO   | PRI | NULL    |       |
| lastName       | varchar(50)  | NO   |     | NULL    |       |
| firstName      | varchar(50)  | NO   |     | NULL    |       |
| extension      | varchar(10)  | NO   |     | NULL    |       |
| email          | varchar(100) | NO   |     | NULL    |       |
| officeCode     | varchar(10)  | NO   | MUL | NULL    |       |
| reportsTo      | int(11)      | YES  | MUL | NULL    |       |
| jobTitle       | varchar(50)  | NO   |     | NULL    |       |
+----------------+--------------+------+-----+---------+-------+
8 rows in set
</code></pre> 
<p><code>employees</code>表具有引用<code>employeeNumber</code>字段的<code>reportsTo</code>字段。 <code>reportsTo</code>列存储经理的<code>ID</code>。总经理不会向公司的组织结构中的任何人报告，因此<code>reportsTo</code>列中的值为 <a href="http://www.yiibai.com/mysql/null.html" rel="nofollow" title="NULL">NULL</a>。</p> 
<p>您可以应用递归 <em>CTE</em> 以自顶向下的方式查询整个组织结构，如下所示：</p> 
<pre><code>WITH RECURSIVE employee_paths AS
  ( SELECT employeeNumber,
           reportsTo managerNumber,
           officeCode, 
           1 lvl
   FROM employees
   WHERE reportsTo IS NULL
     UNION ALL
     SELECT e.employeeNumber,
            e.reportsTo,
            e.officeCode,
            lvl+1
     FROM employees e
     INNER JOIN employee_paths ep ON ep.employeeNumber = e.reportsTo )
SELECT employeeNumber,
       managerNumber,
       lvl,
       city
FROM employee_paths ep
INNER JOIN offices o USING (officeCode)
ORDER BY lvl, city;
</code></pre> 
<p>让我们将查询分解成更小的部分，使其更容易理解。<br> <strong>首先</strong>，使用以下查询形成锚成员：</p> 
<pre><code>SELECT 
    employeeNumber, reportsTo managerNumber, officeCode
FROM
    employees
WHERE
    reportsTo IS NULL
</code></pre> 
<p>此查询 (锚成员) 返回<code>reportTo</code>为<code>NULL</code>的总经理。</p> 
<p><strong>其次</strong>，通过引用 <em>CTE</em> 名称来执行递归成员，在这个示例中为 <code>employee_paths</code>：</p> 
<pre><code>SELECT 
    e.employeeNumber, e.reportsTo, e.officeCode
FROM
    employees e
        INNER JOIN
    employee_paths ep ON ep.employeeNumber = e.reportsTo
</code></pre> 
<p>此查询 (递归成员) 返回经理的所有直接上级，直到没有更多的直接上级。 如果递归成员不返回直接上级，则递归停止。</p> 
<p><strong>第三</strong>，使用<code>employee_paths</code>的查询将 <em>CTE</em> 返回的结果集与<code>offices</code>表结合起来，以得到最终结果集合。</p> 
<p>以下是查询的输出：</p> 
<p><img src="https://images2.imgbox.com/3f/8d/uT1R0LDu_o.png" alt=""></p> 
<p>在本教程中，您已经了解了 MySQL 递归 <em>CTE</em> 以及如何使用它来遍历分层数据。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cf2282fc590804ee6847aafed584725f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">高级RAG(五)：TruLens 评估-扩大和加速LLM应用程序评估</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6f015682bf132b588e13e27b78838da1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Django全文搜索</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>