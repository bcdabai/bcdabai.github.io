<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spark SQL介绍和DataFrame概念以及其API的应用示范 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spark SQL介绍和DataFrame概念以及其API的应用示范" />
<meta property="og:description" content="Spark SQL介绍和DataFrame概念以及其API的应用示范 【以下内容都是自己在集群上学习截图展示】
Spark SQL介绍：
Spark SOL是用于结构化数据、半结构化数据处理的Spark高级模块，可用于从各种结构化数据源，例如JISON (半结构化)
文件、CSV文件、ORC文件(ORC文件格式是一种Hive的文件存储格式，可以提高Hive表的读、写以及处理数据的性能)、
Hive表、Parquest文件(新型列式存储格式，具有降低查询成本、高效压缩等优点，广泛用于大数据存储、分析领域)中读取
数据，然后在Spark程序内通过SQL语句对数据进行交互式查询，进而实现数据分析需求，也可通过标准数据库连接器
(JDBC/ODBC)连接传统关系型数据库，取出并转化关系数据库表，利用Spark SQL进行数据分析。
这里解释一下结构化数据:
结构化数据是指记录内容具有明确的结构信息且数据集内的每一条记录都符合结构规范的数据集合，是由二维表结构
来逻辑表达和实现的数据集合。可以类比传统数据库表来现解该定义，所谓的“明确结构”即是由预定义的表头(Schema)
表示的每一条记录由哪些字段组成以及各个字段的名称、类型、属性等信息。
Spark SQL的实现：
若需处理的数据集是典型结构化数据源，可在Spank程序中引入Spark SQL模块，首先读取待处理数据并将其转化为
Spark SQL的核心数据抽象---DataFrame,进而调用DataFrame API来对数据进有分析处理，也可以将DataFrame注册成表，
直接使用SQL语句在数据表上进行交互式查询。
DataFrame：
DataFrame的定义与RDD类似，即都是Spark 平台用以分布式并行计算的不可变分布式数据集合。与RDD最大的不同在于，
RDD仅仅是一条条数据的集合，并不了解每条数据的内容是怎样的，而DataFrame明确的了解何条数据有几个 命名字段组成， 即可以形象地理解为RDD是条条数据组成的一维表，面DataFrame 是何行数据 都有共同清晰的列划分的维表，每一行的内容
的Row对象组成DF。
概念上来说，它和关系型数据库的表或者R和Python中data frame 等价，只不过DataFrame在底层实现了更多优化。
从编程角度来说，DataFrame 尼Spark SQL模块所需处理的结构化数据的核心抽象，即在Spark程序中若想要使用简易的SQL
接口对数据进行分析，首先需型将所处理数据源转化为DataFrame对象，进而在DataFrame对象上调用各神API来实现需求，
DataFrame 可以从许乡结构化数据源加载并构造得到，如结构化数据文件，Hive中的表，外部数据库，已有的DataFrame API
支持多种高级程序讲言Scala、Java、 Python 和R，
DataFrame与RDD的区别：
RDD和DalaFrame均为Spark平台对数据的一种抽象，一 种组织方式，但是两者的地位或者说设计目的却截然不同。
RDD是整个Spark平台的存储、计算以及任务调度的逻辑基础，更具有通用性，适用于各类数据源，而DataFrame是只针对
结构化数据源的高层数据抽象，其中在DataFrame对象的创建过程中必须指定数据集的结构信息(Schema)，所以DataFrame
生来便具有专用性的数据抽象，只能读取具有鲜明结构的数据集。
下图直观地体现了DataFrame 和RDD的区别。左侧的RDDIPerson]虽然以Person类为类型参数，但Spark平台本身并不了解
Person 类的内部结构。而右侧的DataFrame却提供了详细的结构信息，使得Spark SQL可以清楚地知道该数据集中包含哪些列，
每列的名称和类型各是什么。DataFrame 多了数据的结构信息，即schema. RDD是分布式的Java 对象的集合，DalaFrame
则是分布式的Row对象的集合。DataFrame除了提供了比RDD更丰富的算子操作以外，更重要的特点是利用已知的结构信息
来提升执行效率、减少数据读取以及执行计划的优化，比如filter下推、裁剪等。
Spark SQL模块的编程主入口点是SparkSession, SparkSession 对象不仅为用户提供了创建DataFrame对象、读取外部
数据源并转化为DataFrame对象以及执行sql查询的API,还负责记录着用户希望Spark应用如何在Spark集群运行的控制、" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f2d4e3c2e8529fe19a266a29ddc9cd9b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-16T12:41:12+08:00" />
<meta property="article:modified_time" content="2020-08-16T12:41:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spark SQL介绍和DataFrame概念以及其API的应用示范</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong>Spark SQL介绍和DataFrame概念以及其API的应用示范</strong></h3> 
<p><strong>【以下内容都是自己在集群上学习截图展示】</strong></p> 
<p><strong>Spark SQL介绍：</strong></p> 
<p>Spark SOL是用于结构化数据、半结构化数据处理的Spark高级模块，可用于从各种结构化数据源，例如JISON (半结构化)</p> 
<p>文件、CSV文件、ORC文件(ORC文件格式是一种Hive的文件存储格式，可以提高Hive表的读、写以及处理数据的性能)、</p> 
<p>Hive表、Parquest文件(新型列式存储格式，具有降低查询成本、高效压缩等优点，广泛用于大数据存储、分析领域)中读取</p> 
<p>数据，然后在Spark程序内通过SQL语句对数据进行交互式查询，进而实现数据分析需求，也可通过标准数据库连接器</p> 
<p>(JDBC/ODBC)连接传统关系型数据库，取出并转化关系数据库表，利用Spark SQL进行数据分析。</p> 
<p>这里解释一下结构化数据:</p> 
<p>         结构化数据是指记录内容具有明确的结构信息且数据集内的每一条记录都符合结构规范的数据集合，是由二维表结构</p> 
<p>        来逻辑表达和实现的数据集合。可以类比传统数据库表来现解该定义，所谓的“明确结构”即是由预定义的表头(Schema)</p> 
<p>        表示的每一条记录由哪些字段组成以及各个字段的名称、类型、属性等信息。</p> 
<p> </p> 
<p><strong>Spark SQL的实现：</strong></p> 
<p>若需处理的数据集是典型结构化数据源，可在Spank程序中引入Spark SQL模块，首先读取待处理数据并将其转化为</p> 
<p>Spark SQL的核心数据抽象---DataFrame,进而调用DataFrame API来对数据进有分析处理，也可以将DataFrame注册成表，</p> 
<p>直接使用SQL语句在数据表上进行交互式查询。</p> 
<p><strong>DataFrame：</strong></p> 
<p><span style="color:#f33b45;">DataFrame的定义与RDD类似，即都是Spark 平台用以分布式并行计算的不可变分布式数据集合。与RDD最大的不同在于，</span></p> 
<p><span style="color:#f33b45;">RDD仅仅是一条条数据的集合，并不了解每条数据的内容是怎样的，而DataFrame明确的了解何条数据有几个 命名字段组成， </span></p> 
<p><span style="color:#f33b45;">即可以形象地理解为RDD是条条数据组成的一维表，面DataFrame 是何行数据 都有共同清晰的列划分的维表</span>，每一行的内容</p> 
<p>的Row对象组成DF。</p> 
<p>概念上来说，它和关系型数据库的表或者R和Python中data frame 等价，只不过DataFrame在底层实现了更多优化。</p> 
<p>从编程角度来说，DataFrame 尼Spark SQL模块所需处理的结构化数据的核心抽象，即在Spark程序中若想要使用简易的SQL</p> 
<p>接口对数据进行分析，首先需型将所处理数据源转化为DataFrame对象，进而在DataFrame对象上调用各神API来实现需求，</p> 
<p>DataFrame 可以从许乡结构化数据源加载并构造得到，如结构化数据文件，Hive中的表，外部数据库，已有的DataFrame API</p> 
<p>支持多种高级程序讲言Scala、Java、 Python 和R，</p> 
<p><strong>DataFrame与RDD的区别：</strong></p> 
<p> </p> 
<p>RDD和DalaFrame均为Spark平台对数据的一种抽象，一 种组织方式，但是两者的地位或者说设计目的却截然不同。</p> 
<p>RDD是整个Spark平台的存储、计算以及任务调度的逻辑基础，更具有通用性，适用于各类数据源，而DataFrame是只针对</p> 
<p>结构化数据源的高层数据抽象，其中在DataFrame对象的创建过程中必须指定数据集的结构信息(Schema)，所以DataFrame</p> 
<p>生来便具有专用性的数据抽象，只能读取具有鲜明结构的数据集。<br><br> 下图直观地体现了DataFrame 和RDD的区别。左侧的RDDIPerson]虽然以Person类为类型参数，但Spark平台本身并不了解</p> 
<p>Person 类的内部结构。而右侧的DataFrame却提供了详细的结构信息，使得Spark SQL可以清楚地知道该数据集中包含哪些列，</p> 
<p>每列的名称和类型各是什么。DataFrame 多了数据的结构信息，即schema. RDD是分布式的Java 对象的集合，DalaFrame</p> 
<p>则是分布式的Row对象的集合。DataFrame除了提供了比RDD更丰富的算子操作以外，更重要的特点是利用已知的结构信息</p> 
<p>来提升执行效率、减少数据读取以及执行计划的优化，比如filter下推、裁剪等。<br><img alt="" class="has" height="321" src="https://images2.imgbox.com/1f/07/xLMPnsKc_o.png" width="579"></p> 
<p><span style="color:#3399ea;">Spark SQL模块的编程主入口点是SparkSession, SparkSession 对象不仅为用户提供了创建DataFrame对象、读取外部</span></p> 
<p><span style="color:#3399ea;">数据源并转化为DataFrame对象以及执行sql查询的API,还负责记录着用户希望Spark应用如何在Spark集群运行的控制、</span></p> 
<p><span style="color:#3399ea;">调优参数，是Spark SQL的上下文环境，是运行的基础。</span></p> 
<p>DataFrame提供了一套丰富的API,让Spark变得更加平易近人，使得大数据分析的开发越来越容易。DataFrame API 将</p> 
<p>关系型的处理与过程型处理结合起来，可以对外部数据源(Hive、JSON 等)和Spark内建的分布式集合(RDD)进行关系型操作。</p> 
<p> </p> 
<p>DataFrame能处理的外部数据源，除了内置的Hive、JSON、 Parquet、JDBC以外，还包括CSV、Avro、HBase等多种数据</p> 
<p>源，Spark SQL多元一体的结构化数据处理能力正在逐渐释放。DataFrame 数据采用压缩的列式存储，对DataFrame的操作采用</p> 
<p>Catalyst一种<span style="color:#f33b45;">关系操作优化器</span>(也称为查询优化器)，因此效率更高。</p> 
<p>======================================================================================</p> 
<p>本节读取电影票房收人的数据文件，生成名为film的DataFrame,对读DataFrame应用各种Spark算子进行计算。</p> 
<p>首先准备数据。模拟生成电影票房收人的数据文件film. json、newFilm. json,从本地上传到Hdfs文件系统中，电影票房收人</p> 
<p>文件的格式包括6列:票房收人、制片地区、影片ID、语言代码、影片名、上映年份。电影票房收人的数据文件内容如下:</p> 
<p>生成数据的程序见：<a href="https://blog.csdn.net/qq_25948717/article/details/83113861">https://blog.csdn.net/qq_25948717/article/details/83113861</a></p> 
<p><img alt="" class="has" height="116" src="https://images2.imgbox.com/de/9f/gQVGheLF_o.png" width="310"></p> 
<p><img alt="" class="has" height="187" src="https://images2.imgbox.com/14/68/y68z7oOL_o.png" width="749"></p> 
<p>加载数据：</p> 
<p><img alt="" class="has" height="300" src="https://images2.imgbox.com/81/47/iIzndvwO_o.png" width="791"></p> 
<p>导入数据文件：</p> 
<p><img alt="" class="has" height="237" src="https://images2.imgbox.com/22/2c/NBpghaOs_o.png" width="749"></p> 
<p>将film对象赋值给df（DataFrame）</p> 
<p><img alt="" class="has" height="197" src="https://images2.imgbox.com/13/55/tFYX31pe_o.png" width="792"></p> 
<p>1.collect()：返回一个数组，包含DataFrame中全部数据记录</p> 
<p>  collectAsList():返回一个java list，包含DataFrame中全部数据记录</p> 
<p>  因为这两个方法是将集群中的目标变量的所有数据取回到一个结点当中，所以当你的单台结点的内存不足以放下DataFrame</p> 
<p>  中包含的数据时就会出错。因此，collec()、 collectAsList()不适用于特别大规模的数据集。</p> 
<p><img alt="" class="has" height="526" src="https://images2.imgbox.com/99/50/b1Gl7KhU_o.png" width="710"></p> 
<p>2. count：返回DataFrame的记录条数</p> 
<p><img alt="" class="has" height="64" src="https://images2.imgbox.com/62/0a/Qk5FATMf_o.png" width="373"></p> 
<p>3.describe：描述性统计：计数，平均值，标准差，max,min</p> 
<p><img alt="" class="has" height="210" src="https://images2.imgbox.com/5d/8b/rz9ZIntp_o.png" width="329"></p> 
<p>4.first  head</p> 
<p><img alt="" class="has" height="185" src="https://images2.imgbox.com/69/e7/i03z5wxj_o.png" width="796"></p> 
<p>5.show</p> 
<p><img alt="" class="has" height="463" src="https://images2.imgbox.com/16/78/t07VQumW_o.png" width="587"></p> 
<p>6.take</p> 
<p><img alt="" class="has" height="122" src="https://images2.imgbox.com/30/90/LxJI8SIq_o.png" width="583"></p> 
<p>7.cache   将DataFrame缓存到内存中</p> 
<p><img alt="" class="has" height="65" src="https://images2.imgbox.com/c5/1c/rLISebbw_o.png" width="664"></p> 
<p>8.cloumns、dtypes</p> 
<p><img alt="" class="has" height="120" src="https://images2.imgbox.com/c6/f0/D0DVflQm_o.png" width="768"></p> 
<p>9.printSchma、schema</p> 
<p><img alt="" class="has" height="277" src="https://images2.imgbox.com/45/db/3hG9GSnh_o.png" width="523"></p> 
<p>10.registerTempTable：将DataFrame注册为临时的表，注册成表后可用sql方法查询</p> 
<p><img alt="" class="has" height="450" src="https://images2.imgbox.com/41/a1/t2K4WeRN_o.png" width="745"></p> 
<p>11.toDF  不带参返回它本身，带参的时候重命名了列名</p> 
<p><img alt="" class="has" height="240" src="https://images2.imgbox.com/4a/fe/CQOrKmW8_o.png" width="597"></p> 
<p>12.persist（）、unpersist（）  ：将DataFrame以指定等级持久化内存和磁盘中。</p> 
<p>13.agg：聚合操作</p> 
<p>     DataFrame不需要经过group就可以执行统计操作</p> 
<p>      统计最大年份的平均票房收入</p> 
<p>     <img alt="" class="has" height="139" src="https://images2.imgbox.com/55/a1/6MUZtDQ5_o.png" width="480"></p> 
<p>     <img alt="" class="has" height="123" src="https://images2.imgbox.com/68/4f/6yp77CRy_o.png" width="553"></p> 
<p>14.apply：根据指定列名返回列</p> 
<p><img alt="" class="has" height="125" src="https://images2.imgbox.com/14/58/2HCOurTi_o.png" width="439"></p> 
<p>15.dinstinct：去掉重复的记录</p> 
<p>     dropDuplicates:根据指定字段（可多个字段组合）去重</p> 
<p><img alt="" class="has" height="450" src="https://images2.imgbox.com/ef/d2/2KU0XEzC_o.png" width="577"></p> 
<p><img alt="" class="has" height="374" src="https://images2.imgbox.com/78/13/Dx26Voip_o.png" width="599"></p> 
<p>16.except：两个DF做减法</p> 
<p><img alt="" class="has" height="281" src="https://images2.imgbox.com/ab/ee/DiTMOXD3_o.png" width="636"></p> 
<p>17.filter：过滤</p> 
<p><img alt="" class="has" height="680" src="https://images2.imgbox.com/33/71/87LcQvn1_o.png" width="604"></p> 
<p>18.groupBy：使用一个或者多个列对DataFrame进行分组</p> 
<p><img alt="" class="has" height="238" src="https://images2.imgbox.com/81/52/6qvp33HK_o.png" width="398"></p> 
<p>19.intersect(将两个DF同时存在的数据返回)，join</p> 
<p><img alt="" class="has" height="672" src="https://images2.imgbox.com/3c/75/7Dv3Uv1n_o.png" width="777"></p> 
<p>20.limit</p> 
<p><img alt="" class="has" height="182" src="https://images2.imgbox.com/ea/22/6BQnoMkz_o.png" width="594"></p> 
<p>20.sort，orderBy（sort的别名）：</p> 
<p><img alt="" class="has" height="611" src="https://images2.imgbox.com/11/50/9iwoE3vO_o.png" width="594"></p> 
<p>21.sample取样</p> 
<p>sanple(withReplacement:Boolean,fraction:Double,seed:Long)</p> 
<p>withReplacement=true表示重复抽样，fraction表示比例，seed指定因子抽样</p> 
<p><img alt="" class="has" height="701" src="https://images2.imgbox.com/a4/df/XtE4LQ90_o.png" width="593"></p> 
<p>22.select、unionAll</p> 
<p><img alt="" class="has" height="672" src="https://images2.imgbox.com/14/fd/Zvx0va81_o.png" width="532"></p> 
<p><img alt="" class="has" height="454" src="https://images2.imgbox.com/7f/9d/nzwG3v8z_o.png" width="603"></p> 
<p>23.withColumn和withColumnRenamed</p> 
<p><img alt="" class="has" height="478" src="https://images2.imgbox.com/5f/e7/FfaIjr1X_o.png" width="757"></p> 
<p>24.foreach：对DF中的数据记录进行遍历处理</p> 
<p>     map:将DF按照指定函数生成一个新的RDD</p> 
<p><img alt="" class="has" height="599" src="https://images2.imgbox.com/d7/f9/mgkPXPCI_o.png" width="678"></p> 
<p>25.注册表，然后用sql查询</p> 
<p><img alt="" class="has" height="511" src="https://images2.imgbox.com/5b/7b/DU8KQAmb_o.png" width="1190"></p> 
<p>26.全局临时表</p> 
<p>全局临时表(global temporary view)于临时表(temporay view)是相对的，全局临时表的作用范围是某个Spark应用程序内所有</p> 
<p>会话(SparkSession)，它会持续存在，在所有会话中共享，直到该Spark应用程序终止</p> 
<p>因此，若在同一个应用中不同的session中需重用一个临时表， 不妨将其注册为全局临时表，可避免多余IO,提高系统执行</p> 
<p>效率，当然如果某个临时表只在整个应用中的某个session中需使用，仅需注册为局部临时表，避免不必要的在内存中存储</p> 
<p>全局临时表</p> 
<p>另外，全局临时表与系统保留的数据库global temp相关联，引用时需用global temp标识，</p> 
<p>例如: SELECT * FROM global temp.viewl。</p> 
<p>下案列中可见new的session依然可以访问全局临时表：</p> 
<p><img alt="" class="has" height="601" src="https://images2.imgbox.com/f1/83/Jc7e9TtM_o.png" width="820"></p> 
<p>27.where</p> 
<p>  <img alt="" class="has" height="176" src="https://images2.imgbox.com/0f/04/DIrGaZof_o.png" width="532"></p> 
<p>28.drop</p> 
<p> <img alt="" class="has" height="276" src="https://images2.imgbox.com/ac/34/dOse11DZ_o.png" width="456"></p> 
<p>29.groubBy</p> 
<p>  <img alt="" class="has" height="568" src="https://images2.imgbox.com/32/d7/Fsux6Zp4_o.png" width="589"></p> 
<p><span style="color:#f33b45;">30.jion操作：</span></p> 
<p> 单字段：df1.join(df2,"name").show()</p> 
<p> 多字段：df1.join(df2,Seq("id","name"))</p> 
<p> 指定join的类型：df1.join(df2,Seq("id","name"),“right_outer”)</p> 
<p> 使用Column类型来join：df1.join(df2,df1("xxx")===df2("yyy")).show()</p> 
<p> 使用Column类型来join时指定类型：df1.join(df2,df1("xxx")===df2("yyy"),"cross").show()</p> 
<p>31.stat:计算指定字段或者指定字段之间的统计信息</p> 
<p>  统计该字段值出现频率在30%以上的内容</p> 
<p>  <img alt="" class="has" height="286" src="https://images2.imgbox.com/4c/8e/fyOIvpN7_o.png" width="650"></p> 
<p>corr求两列的相关性，cov求两列的协方差</p> 
<p> <img alt="" class="has" height="123" src="https://images2.imgbox.com/49/b8/YPYgWGlg_o.png" width="463"></p> 
<p>32.df.na.drop().show(5):具有空值列的行数据都会被删除</p> 
<p>     df.na.drop(Array("xxx")).show()：指定某列的行数据被删除</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ca7176eedd7ece35b994593297afd5c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用图像理解牛顿法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a2a2e8fa46ea2741f529d48c453039f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">hashcode()和equals()方法详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>