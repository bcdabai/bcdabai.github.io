<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>小美的树上染色 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="小美的树上染色" />
<meta property="og:description" content="美团2024届秋招笔试第一场编程真题
先提一个小知识：题目中凡是提到树结构都要使用图的存储方式，只有二叉树例外。
分析：在树结构中，孩子和父节点是相邻节点，而父节点可能有多个孩子节点。在染色的过程中，本质是父子节点满足条件就染成红色。具体染色策略以下图为例
图中节点权值均为1，也就是任意相邻节点都可以满足染色条件，显然我们不能先将a和b染色，那样就只有2个点能被染色，而是应该先染色&lt;f,b&gt;或 &lt;e,b&gt;，然后再&lt;a,c&gt; 或&lt;a,d&gt;，这样可以染4个点。下图又该先考虑染色那些节点呢？
这样总结出贪心策略：先处理叶子结点的染色，然后处理内部节点。比如上图，先处理&lt;g,f&gt;。如果能染色，哪么将g,f标记红色，同时&lt;f,b&gt;就不可能染色了如果不能染色，未来还可以继续试探&lt;f,b&gt;。
实现方法：先处理最外层节点（叶子），外层处理完了，这些叶子就可以不要了，往内层推进。
使用拓扑排序的思想。当然不是入度0节点入队，这可不是有向图。而是度为1（叶子）节点入队，从树叶向树根进行拓扑处理。
图问题的复杂度正常都是遍历所有的结点，也就是访问所有的点和边，此图n-1条边，复杂度为O(n)。
#include &lt;bits/stdc&#43;&#43;.h&gt; typedef long long ll; using namespace std; ll n,a[100005],d[100005],red[100005],v[100005],ans=0; vector &lt;int&gt; e[100005]; bool isP(ll x)/**&lt; 平方数判定 */ { ll y=(int)sqrt(x); return y*y==x; } int main() { ios::sync_with_stdio(0),cin.tie(0); int i,j,x,y; cin&gt;&gt;n; for(i=1;i&lt;=n;i&#43;&#43;) cin&gt;&gt;a[i]; for(i=1;i&lt;n;i&#43;&#43;) { cin&gt;&gt;x&gt;&gt;y; e[x].push_back(y),e[y].push_back(x); d[x]&#43;&#43;,d[y]&#43;&#43;;/**&lt; d数组统计度 */ } queue&lt;int&gt;q; for(i=1;i&lt;=n;i&#43;&#43;) if(d[i]==1)/**&lt; 度为1的入队*/ q.push(i); while(q.size())/**&lt; 模拟拓扑排序处理方法 */ { x=q.front(); v[x]=1;/**&lt; 标记这个节点，避免重新被入队处理 */ q.pop(); for(i=0;i&lt;e[x].size();i&#43;&#43;)/**&lt; 找到x所有邻接点 */ { y=e[x][i]; if(v[y]) /**&lt; y已经访问过，其实y一定是x的子节点 */ continue; if(red[x]==0&amp;&amp;red[y]==0&amp;&amp;isP(a[x]*a[y]))/**&lt; x和它父节点y满足条件 */ red[x]=red[y]=1,ans&#43;=2;/**&lt; 标记颜色，计数器&#43;2 */ d[y]--; if(d[y]==1)/**&lt; 度为1说明y子节点都处理完了，此时可以入队 */ q." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d80750355f4dda8c4a8c7dbd22d6442e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-19T09:25:15+08:00" />
<meta property="article:modified_time" content="2023-11-19T09:25:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">小美的树上染色</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>美团2024届秋招笔试第一场编程真题</p> 
<p><img alt="" height="552" src="https://images2.imgbox.com/d8/ee/eGzV8MKr_o.png" width="1200"><img alt="" height="437" src="https://images2.imgbox.com/3d/58/jZe279j6_o.png" width="1200">先提一个小知识：题目中凡是提到树结构都要使用图的存储方式，只有二叉树例外。</p> 
<p>分析：在树结构中，孩子和父节点是相邻节点，而父节点可能有多个孩子节点。在染色的过程中，本质是父子节点满足条件就染成红色。具体染色策略以下图为例</p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/43/98/3xU5hQvc_o.png" width="379"></p> 
<p>图中节点权值均为1，也就是任意相邻节点都可以满足染色条件，显然我们不能先将a和b染色，那样就只有2个点能被染色，而是应该先染色&lt;f,b&gt;或 &lt;e,b&gt;，然后再&lt;a,c&gt; 或&lt;a,d&gt;，这样可以染4个点。下图又该先考虑染色那些节点呢？</p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/fe/ff/MZeukbcX_o.png" width="497"></p> 
<p>这样总结出贪心策略：先处理叶子结点的染色，然后处理内部节点。比如上图，先处理&lt;g,f&gt;。如果能染色，哪么将g,f标记红色，同时&lt;f,b&gt;就不可能染色了如果不能染色，未来还可以继续试探&lt;f,b&gt;。</p> 
<p>实现方法：先处理最外层节点（叶子），外层处理完了，这些叶子就可以不要了，往内层推进。</p> 
<p>使用拓扑排序的思想。当然不是入度0节点入队，这可不是有向图。而是度为1（叶子）节点入队，从树叶向树根进行拓扑处理。</p> 
<p>图问题的复杂度正常都是遍历所有的结点，也就是访问所有的点和边，此图n-1条边，复杂度为O(n)。</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
typedef long long ll;
using namespace std;
ll n,a[100005],d[100005],red[100005],v[100005],ans=0;
vector &lt;int&gt; e[100005];
bool isP(ll x)/**&lt; 平方数判定 */
{
    ll y=(int)sqrt(x);
    return y*y==x;
}
int main()
{
    ios::sync_with_stdio(0),cin.tie(0);
    int i,j,x,y;
    cin&gt;&gt;n;
    for(i=1;i&lt;=n;i++)
        cin&gt;&gt;a[i];
    for(i=1;i&lt;n;i++)
    {
        cin&gt;&gt;x&gt;&gt;y;
        e[x].push_back(y),e[y].push_back(x);
        d[x]++,d[y]++;/**&lt; d数组统计度 */
    }
    queue&lt;int&gt;q;
    for(i=1;i&lt;=n;i++)
        if(d[i]==1)/**&lt; 度为1的入队*/
        q.push(i);
    while(q.size())/**&lt; 模拟拓扑排序处理方法 */
    {
        x=q.front();
        v[x]=1;/**&lt; 标记这个节点，避免重新被入队处理 */
        q.pop();
        for(i=0;i&lt;e[x].size();i++)/**&lt; 找到x所有邻接点 */
        {
            y=e[x][i];
            if(v[y]) /**&lt; y已经访问过，其实y一定是x的子节点 */
                continue;
            if(red[x]==0&amp;&amp;red[y]==0&amp;&amp;isP(a[x]*a[y]))/**&lt; x和它父节点y满足条件 */
                red[x]=red[y]=1,ans+=2;/**&lt; 标记颜色，计数器+2 */
            d[y]--;
            if(d[y]==1)/**&lt; 度为1说明y子节点都处理完了，此时可以入队 */
              q.push(y);
        }
    }
    cout&lt;&lt;ans;
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8804510ae36f62f5f85e29f67de2ba1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何使用websocket&#43;node.js实现pc后台与小程序端实时通信</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e1d3e23570a8e6cec03301ca2ef4195/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小美的排列构造</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>