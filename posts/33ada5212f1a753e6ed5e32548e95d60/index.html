<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【面试大全-缓存】-Redis必修课 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【面试大全-缓存】-Redis必修课" />
<meta property="og:description" content="为什么要用缓存 使用缓存的目的是提高读写性能，在实际业务场景下，更多是为了提高读的性能，带来更高的并发量，Redis的读写性能比Mysql好很多，这个时候可以把Mysql的热点数据同步到Redis中来。 Redis有哪些好处 读取速度快，响应快支持多种数据结构：字符串、列表、集合、有序集合、哈希等。支持事务，且操作遵守原子性其他丰富的功能：队列、主从复制、集群、数据持久化等。持久化存储，Redis提供RDB和AOP两种持久化存储方案，解决Redis挂掉数据丢失问题。缺点：内存数据库，受单台物理机器内存的大小，虽然Redis有过期策略，但还是需要提前预估和节约内存。修改配置文件，进行重启，时间比较久，这端时间不能提供服务。 为什么 使用 Redis 而不是用 Memcache 呢 Redis和Memcache都是将数据存放到内存中，都是内存数据库，不过Memcache还可以用于图片、视频等缓存。Memcache仅支持key-value数据结构、Redis不仅支持key-value数据结构，还支持list、set、hash等Redis当物理内存用完的时候，还可以将很久没用的value持久化到磁盘。存储数据安全，Memcache挂掉后数据不存在了，Redis定期持久化到磁盘。Memcache单个value最大1M,Redis单个最大512MRedis原生支持集群，Memcache没用原生支持集群，需要在客户端自己实现。 为什么Redis单线程模型效率也非常高 C语言开发、效率高纯内存操作基于非阻塞的IO多路复用单线程能够避免多线程上下文切换带来的额外开销 说说Redis的线程模型 Redis内部使用 文件事件处理器。因为这个文件事件是单线程的，所以Redis也叫做单线程的模型，它采用IO多路复用同事监听多个Soket，根据Soket上的事件来选择对应的事件处理器：文件事件处理器包含4个部分：多个SoketIO多路复用程序文件事件分派器事件处理器多个Soket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用会监听多个Soket，会将Soket产生的事件放入队列中进行排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器处理。 为什么Redis要把所有数据放在内存中 Redis将数据放在内存中有一个好处，那就是实现最快的速度对数据进行存取，如果数据存储在硬盘中，磁盘IO会严重影响Redis性能，而且Redis提供了持久化功能，不用担心服务器重启对内存中数据的影响，其次硬件越来越便宜的情况下，Redis也越来越受欢迎。 Redis缓存刷新策略有哪些 maxmemory-policy volatile-lruLRU（最久没有被访问的数据最闲被淘汰）LFU（最近没有被访问到的数据最先被淘汰）FIFO（最先进入的数据最闲被淘汰）超时剔除 Redis持久化方式方式有哪些，以及有什么区别 RDB AOF 两种持久化方式RDB持久化：快照的方式半持久化，记录所有的键值对，在某个节点将数据写入一个临时文件，持久化结束后，用和这个文件替换上次的文件，达到数据恢复。优点：只有一个dump.rdb文件，方便持久化或者数据恢复性能最大化，采用fork一个子进程来操作，让主进程继续处理命令，让子进程进行处理，保证了Redis的性能缺点：数据安全性低，RDB是间隔一段时间进行持久化，如果持久化时发生故障，会发生数据丢失，这种方式适合数据要求不严谨的时候。AOF持久化：所有命令按指定的协议持久化存储，保存为AOF文件优点：数据安全，可以通过配置每次都可以进行记录AOF机制的rewrite模式，可以对AOF命令合并重写，当误操作时，也可以删除某些命令进行恢复缺点：AOF比RDB文件要大，且恢复速度慢数据集大的时候，比RDB启动效率低 Redis持久化方式如何选择 不仅仅使用RDB这样回照成很多数据丢失也不仅仅使用AOF，AOF恢复速度慢，AOF每次都会记录命令，恢复难度可能增大Redis支持同事开启两种方式持久化方式，我们可以综合这两种机制，用AOF来保证数据不丢失，做为数据恢复的第一选择，用RDB来做不同程度的冷备，在AOF丢失或者损坏的时候，采用RDB进行恢复如果两种都开启，在Redis重启的时候，会采用AOF来加载数据，因为AOF数据更加完整 Redis事务的理解 Redis事务是一组组合命令，是Redis的最小执行单位，它可以保证一次执行多条命令，每个事务是一个单独的隔离操作，事务中所有的命令都会序列化，按顺序执行。Redis事务不支持回滚，回滚需要增加很多工作，Redis保持简单、快速的特性。 为什么Redis设计成单线程 多线程的话会设计到锁的操作，并且多线程会有线程切换上下文开销，而且CPU目前不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存和网络开销。 什么是 bigkey？会存在什么影响 bigkey是指占用内存比较大的key，比如一个字符串可以占用300M网络阻塞：获取key时，传输数据量比较大，增加带宽压力超时阻塞：因为bigkey占用的空间比较大，所以操作起来效率会比较低，导致出现阻塞的可能性增加。 Redis集群模式 Redis Sentinel：体量较小时，选择单机部署Redis Cluster：官方提供的集群解决方案，体量较大时，使用Redis Cluster，通过分片，使用更多内存。 Redis Cluster集群模式原理 所有节点相互相连集群节点挂掉会自动转移 Redis Cluster 集群方案什么情况下会导致整个集群不可用 Redis没有使用哈希一致性算法，使用的是哈希槽，Redis中哈希槽一共有16384个，假设有三个集群节点，挂掉一个节点时，在某段时间这段哈希槽是不可用的，也就是集群不可用。 Redis集群有哪几种 单节点单机模式也支持一主多从结构带有哨兵的集群部署 Redis常见性能问题有哪些 Master最好不要做持久化工作，入RDB快照，AOF日志文件如果数据比较重要，可以在slave开启AOF日志按秒进行配置持久化为了主从复制的安全性和稳定性，最好部署在同一局域网内主从复制不要用图状结构，用单向链表结构更为稳定，即 Master -&gt; Slave1 -&gt; Slave2 -&gt; Slave3 。如果master挂掉，Salve1立即启用做为master。 假设Redis有1亿个key，其中10w个key是以固定的title，如何将他们快速查找出来 我们可以使用 keys 和 scan 命令使用 keys 命令 ：可以使用keys进行全数据查询，当然Redis是单线程，数据量过大会进行阻塞，而且keys没有分页功能。使用 scan 命令：scan命令和keys命令一样具有匹配功能，但是scan命令不会阻塞线程，并且查找的数据可能存在重复，需要客户端自己去重，因为scan是通过游标进行查询的，所以不会导致Redis出现假死，scan在检索过程中，被删除的元素是不会被查询出来的，相对来说scan命令耗费的时间更长，但是不影响Redis正常使用。 什么情况下会导致Redis阻塞 Redis主机负载过高，也会导致系统崩溃数据持久化占用过多的资源对Redis的API使用不当，导致Redis出现问题外部服务器问题（cpu、内存、网络） 缓存和数据库哪个先更新呢 为了解决数据不至于问题，其中一种解决方案是使用读写串行化，可以通过队列来实现，但是可能存在读请求的挤压，读请求并发高。如果写入数据库和更新到缓存的值是一致的时候，这个时候可以同步更新缓存和数据库，如果对于写比较频繁，而读不频繁的时候，我们需要对对缓存进行删除，等读的时候再去获取如果写数据的值和缓存的值不一致的时候，写入缓存的数据需要通过几个表进行计算，那就没必要马上更新缓存，需要要删除缓存即可，等获取需要的时候再去进行计算一般的解决方案是先删除缓存数据，再更新数据库。常见的三种方式：先更新数据库库、再更新缓存先删除缓存，再更新数据库先更新数据库，再删除缓存。首先我们放入缓存的数据本来就不应该是实时性要求过高，比如用户余额，所以缓存的过期时间保证最终一致性是比较靠谱的。我们不应该过度设计增加系统的复杂度遇到实时性、一致性要求较高的，就应该查询数据库，即使可能性能不高。 怎么提高缓存命中率 提前加载业务数据到缓存中增加缓存存储空间，提高能够缓存的数据提高缓存的更新频率 Redis 如何解决 key 冲突 Redis中，如果key相同，后面一个会覆盖前面一个，如果要解决key冲突，就要有一套key命名规则，比如 按 业务 &#43; 系统 &#43; 子模块 等自定义命名规则。 Redis 报内存不足怎么处理 修改配置文件 maxmemory 参数，曾大内存设置缓存淘汰策略，提高内存的使用率使用Redis集群，提高存储量 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题 缓存雪崩：系统设置的缓存在同一时间大面积过期，这时业务都去查询DB，给DB造成很大的压力，可能导致服务器岩机。解决办法：讲缓存失效时间分散。缓存穿透：指用户查询的时候缓存里面没有，数据库里面也没有，这两就会导致查询2次无用的操作，这样就绕过缓存直接查询数据库。解决办法：1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/33ada5212f1a753e6ed5e32548e95d60/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-30T22:51:38+08:00" />
<meta property="article:modified_time" content="2023-01-30T22:51:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【面试大全-缓存】-Redis必修课</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>为什么要用缓存</h4> 
<ul><li>使用缓存的目的是提高读写性能，在实际业务场景下，更多是为了提高读的性能，带来更高的并发量，Redis的读写性能比Mysql好很多，这个时候可以把Mysql的热点数据同步到Redis中来。</li></ul> 
<h4><a id="Redis_3"></a>Redis有哪些好处</h4> 
<ul><li>读取速度快，响应快</li><li>支持多种数据结构：字符串、列表、集合、有序集合、哈希等。</li><li>支持事务，且操作遵守原子性</li><li>其他丰富的功能：队列、主从复制、集群、数据持久化等。</li><li>持久化存储，Redis提供RDB和AOP两种持久化存储方案，解决Redis挂掉数据丢失问题。</li><li><strong>缺点</strong>：</li><li>内存数据库，受单台物理机器内存的大小，虽然Redis有过期策略，但还是需要提前预估和节约内存。</li><li>修改配置文件，进行重启，时间比较久，这端时间不能提供服务。</li></ul> 
<h4><a id="__Redis__Memcache__13"></a>为什么 使用 Redis 而不是用 Memcache 呢</h4> 
<ul><li>Redis和Memcache都是将数据存放到内存中，都是内存数据库，不过Memcache还可以用于图片、视频等缓存。</li><li>Memcache仅支持key-value数据结构、Redis不仅支持key-value数据结构，还支持list、set、hash等</li><li>Redis当物理内存用完的时候，还可以将很久没用的value持久化到磁盘。</li><li>存储数据安全，Memcache挂掉后数据不存在了，Redis定期持久化到磁盘。</li><li>Memcache单个value最大1M,Redis单个最大512M</li><li>Redis原生支持集群，Memcache没用原生支持集群，需要在客户端自己实现。</li></ul> 
<h4><a id="Redis_21"></a>为什么Redis单线程模型效率也非常高</h4> 
<ul><li>C语言开发、效率高</li><li>纯内存操作</li><li>基于非阻塞的IO多路复用</li><li>单线程能够避免多线程上下文切换带来的额外开销</li></ul> 
<h4><a id="Redis_27"></a>说说Redis的线程模型</h4> 
<ul><li>Redis内部使用 <strong>文件事件处理器</strong>。因为这个文件事件是单线程的，所以Redis也叫做单线程的模型，它采用IO多路复用同事监听多个Soket，根据Soket上的事件来选择对应的事件处理器：</li><li>文件事件处理器包含4个部分：</li><li>多个Soket</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器</li><li>多个Soket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用会监听多个Soket，会将Soket产生的事件放入队列中进行排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器处理。</li></ul> 
<h4><a id="Redis_36"></a>为什么Redis要把所有数据放在内存中</h4> 
<ul><li>Redis将数据放在内存中有一个好处，那就是实现最快的速度对数据进行存取，如果数据存储在硬盘中，磁盘IO会严重影响Redis性能，而且Redis提供了持久化功能，不用担心服务器重启对内存中数据的影响，其次硬件越来越便宜的情况下，Redis也越来越受欢迎。</li></ul> 
<h4><a id="Redis_39"></a>Redis缓存刷新策略有哪些</h4> 
<ul><li>maxmemory-policy volatile-lru</li><li>LRU（最久没有被访问的数据最闲被淘汰）</li><li>LFU（最近没有被访问到的数据最先被淘汰）</li><li>FIFO（最先进入的数据最闲被淘汰）</li><li>超时剔除</li></ul> 
<h4><a id="Redis_46"></a>Redis持久化方式方式有哪些，以及有什么区别</h4> 
<ul><li><strong>RDB AOF</strong> 两种持久化方式</li><li><strong>RDB持久化</strong>：<strong>快照的方式半持久化</strong>，记录所有的键值对，在某个节点将数据写入一个<strong>临时文件</strong>，持久化结束后，用和这个文件<strong>替换</strong>上次的文件，达到数据恢复。</li><li><strong>优点：</strong></li><li>只有一个dump.rdb文件，方便持久化或者数据恢复</li><li>性能最大化，采用fork一个子进程来操作，让主进程继续处理命令，让子进程进行处理，保证了Redis的性能</li><li><strong>缺点：</strong></li><li>数据安全性低，RDB是间隔一段时间进行持久化，如果持久化时发生故障，会发生数据丢失，这种方式适合数据要求不严谨的时候。</li><li><strong>AOF持久化</strong>：所有命令按指定的协议持久化存储，保存为AOF文件</li><li><strong>优点：</strong></li><li>数据安全，可以通过配置每次都可以进行记录</li><li>AOF机制的rewrite模式，可以对AOF命令合并重写，当误操作时，也可以删除某些命令进行恢复</li><li><strong>缺点：</strong></li><li>AOF比RDB文件要大，且恢复速度慢</li><li>数据集大的时候，比RDB启动效率低</li></ul> 
<h4><a id="Redis_62"></a>Redis持久化方式如何选择</h4> 
<ul><li>不仅仅使用RDB这样回照成很多数据丢失</li><li>也不仅仅使用AOF，AOF恢复速度慢，AOF每次都会记录命令，恢复难度可能增大</li><li>Redis支持同事开启两种方式持久化方式，我们可以综合这两种机制，用AOF来保证数据不丢失，做为数据恢复的第一选择，用RDB来做不同程度的冷备，在AOF丢失或者损坏的时候，采用RDB进行恢复</li><li>如果两种都开启，在Redis重启的时候，会采用AOF来加载数据，因为AOF数据更加完整</li></ul> 
<h4><a id="Redis_68"></a>Redis事务的理解</h4> 
<ul><li>Redis事务是一组组合命令，是Redis的最小执行单位，它可以保证一次执行多条命令，每个事务是一个单独的隔离操作，事务中所有的命令都会序列化，按顺序执行。</li><li>Redis事务不支持回滚，回滚需要增加很多工作，Redis保持简单、快速的特性。</li></ul> 
<h4><a id="Redis_72"></a>为什么Redis设计成单线程</h4> 
<ul><li>多线程的话会设计到锁的操作，并且多线程会有线程切换上下文开销，而且CPU目前不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存和网络开销。</li></ul> 
<h4><a id="_bigkey_75"></a>什么是 bigkey？会存在什么影响</h4> 
<ul><li>bigkey是指占用内存比较大的key，比如一个字符串可以占用300M</li><li>网络阻塞：获取key时，传输数据量比较大，增加带宽压力</li><li>超时阻塞：因为bigkey占用的空间比较大，所以操作起来效率会比较低，导致出现阻塞的可能性增加。</li></ul> 
<h4><a id="Redis_80"></a>Redis集群模式</h4> 
<ul><li>Redis Sentinel：体量较小时，选择单机部署</li><li>Redis Cluster：官方提供的集群解决方案，体量较大时，使用Redis Cluster，通过分片，使用更多内存。</li></ul> 
<h4><a id="Redis_Cluster_84"></a>Redis Cluster集群模式原理</h4> 
<ul><li>所有节点相互相连</li><li>集群节点挂掉会自动转移</li></ul> 
<h4><a id="Redis_Cluster__88"></a>Redis Cluster 集群方案什么情况下会导致整个集群不可用</h4> 
<ul><li>Redis没有使用哈希一致性算法，使用的是哈希槽，Redis中哈希槽一共有16384个，假设有三个集群节点，挂掉一个节点时，在某段时间这段哈希槽是不可用的，也就是集群不可用。</li></ul> 
<h4><a id="Redis_91"></a>Redis集群有哪几种</h4> 
<ul><li>单节点单机模式</li><li>也支持一主多从结构</li><li>带有哨兵的集群部署</li></ul> 
<h4><a id="Redis_96"></a>Redis常见性能问题有哪些</h4> 
<ul><li>Master最好不要做持久化工作，入RDB快照，AOF日志文件</li><li>如果数据比较重要，可以在slave开启AOF日志按秒进行配置持久化</li><li>为了主从复制的安全性和稳定性，最好部署在同一局域网内</li><li>主从复制不要用图状结构，用单向链表结构更为稳定，即 Master -&gt; Slave1 -&gt; Slave2 -&gt; Slave3 。如果master挂掉，Salve1立即启用做为master。</li></ul> 
<h4><a id="Redis1key10wkeytitle_102"></a>假设Redis有1亿个key，其中10w个key是以固定的title，如何将他们快速查找出来</h4> 
<ul><li>我们可以使用 keys 和 scan 命令</li><li><strong>使用 keys 命令</strong> ：可以使用keys进行全数据查询，当然Redis是单线程，数据量过大会进行阻塞，而且keys没有分页功能。</li><li><strong>使用 scan 命令</strong>：scan命令和keys命令一样具有匹配功能，但是scan命令不会阻塞线程，并且查找的数据可能存在重复，需要客户端自己去重，因为scan是通过游标进行查询的，所以不会导致Redis出现假死，scan在检索过程中，被删除的元素是不会被查询出来的，相对来说scan命令耗费的时间更长，但是不影响Redis正常使用。</li></ul> 
<h4><a id="Redis_107"></a>什么情况下会导致Redis阻塞</h4> 
<ul><li>Redis主机负载过高，也会导致系统崩溃</li><li>数据持久化占用过多的资源</li><li>对Redis的API使用不当，导致Redis出现问题</li><li>外部服务器问题（cpu、内存、网络）</li></ul> 
<h4><a id="_113"></a>缓存和数据库哪个先更新呢</h4> 
<ul><li>为了解决数据不至于问题，其中一种解决方案是使用读写串行化，可以通过队列来实现，但是可能存在读请求的挤压，读请求并发高。</li><li>如果写入数据库和更新到缓存的值是一致的时候，这个时候可以同步更新缓存和数据库，如果对于写比较频繁，而读不频繁的时候，我们需要对对缓存进行删除，等读的时候再去获取</li><li>如果写数据的值和缓存的值不一致的时候，写入缓存的数据需要通过几个表进行计算，那就没必要马上更新缓存，需要要删除缓存即可，等获取需要的时候再去进行计算</li><li>一般的解决方案是先删除缓存数据，再更新数据库。</li><li>常见的三种方式：</li><li>先更新数据库库、再更新缓存</li><li>先删除缓存，再更新数据库</li><li>先更新数据库，再删除缓存。</li><li>首先我们放入缓存的数据本来就不应该是实时性要求过高，比如用户余额，所以缓存的过期时间保证最终一致性是比较靠谱的。</li><li>我们不应该过度设计增加系统的复杂度</li><li>遇到实时性、一致性要求较高的，就应该查询数据库，即使可能性能不高。</li></ul> 
<h4><a id="_126"></a>怎么提高缓存命中率</h4> 
<ul><li>提前加载业务数据到缓存中</li><li>增加缓存存储空间，提高能够缓存的数据</li><li>提高缓存的更新频率</li></ul> 
<h4><a id="Redis__key__131"></a>Redis 如何解决 key 冲突</h4> 
<ul><li>Redis中，如果key相同，后面一个会覆盖前面一个，如果要解决key冲突，就要有一套key命名规则，比如 按 业务 + 系统 + 子模块 等自定义命名规则。</li></ul> 
<h4><a id="Redis__134"></a>Redis 报内存不足怎么处理</h4> 
<ul><li>修改配置文件 maxmemory 参数，曾大内存</li><li>设置缓存淘汰策略，提高内存的使用率</li><li>使用Redis集群，提高存储量</li></ul> 
<h4><a id="_139"></a>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</h4> 
<ul><li><strong>缓存雪崩</strong>：系统设置的缓存在同一时间大面积过期，这时业务都去查询DB，给DB造成很大的压力，可能导致服务器岩机。</li><li>解决办法：讲缓存失效时间分散。</li><li><strong>缓存穿透</strong>：指用户查询的时候缓存里面没有，数据库里面也没有，这两就会导致查询2次无用的操作，这样就绕过缓存直接查询数据库。</li><li>解决办法：1.布隆过滤器：将所有可能存在的数据存在一个bitmap中，一个一定不存在的数据会被拦截掉，从而避免了对底层系统的压力。2.简单的方法：查询为空，继续缓存这个空的value，过期时间相对设置短一些。</li><li><strong>缓存预热</strong>：系统上线后，将相关系统的缓存直接存入缓存系统中，避免短时间内大量查询数据库。</li><li>解决方法：1.直接写个缓存刷新页面，上线时统一刷新。2.数据量不大时可以初始化加载。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e53602d6df1555b84ecece4198e27fdf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">仿牛客论坛项目Docker部署(ElasticSearch&#43;Redis&#43;Kafka&#43;MySQL)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a87457ccc984dbd7aa7e3aeadc73079/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java】SpringCloud使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>