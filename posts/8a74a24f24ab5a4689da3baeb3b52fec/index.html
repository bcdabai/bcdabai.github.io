<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>消息队列 Kafka ：入门 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="消息队列 Kafka ：入门" />
<meta property="og:description" content="消息队列 是什么 message queue，简称 MQ。拥有 FIFO 特性，主要用于不同进程或线程之间的通信，用来处理一系列的输入请求。
采用异步通信机制，也就是消息的发送者和接收者无需同时与消息队列进行数据交互，消息会一直保存在队列中，直到被接收者读取。每一条消息记录都包含了详细的数据说明，包括数据产生的时间，数据类型，特定的输入参数等。
作用 应用解耦：多个应用可以通过消息队列对相同的消息进行处理，应用之间相互独立，互不影响。异步处理：相比于串行和并行，异步更能减少时间。数据限流：控制高峰期的数据流量，避免系统崩溃。消息通信：点对点消息队列或聊天室等。 Kafka Linkedin 团队发现市面上的系统无法做到实时服务，所以就自己搞了一个，既满足实时处理的需求，又可以支持水平扩展的消息系统，还拥有着高吞吐量。
Kafka 是一个分布式实时数据流平台，可独立部署在单台服务器上，也可以部署在多台服务器上构成集群。提供了发布订阅功能，用户可以发送数据到 Kafka 集群中，也可以从 Kafka 集群中读取数据。
以下是几个核心的概念： 代理（Broker）
在 Kafka 集群中，一个 Kafka 进程（实例）被称为一个代理节点。通常在部署分布式 Kafka 集群时，一台服务器上部署一个 kafka 实例。
生产者（Producer）
Producer 将消息记录发送到Kafka 集群指定的主题（Topic）中进行存储，同时生产者也能通过自定义算法觉得将消息记录发送到哪个分区（Partition）。
例如，通过获取消息记录主键的hash值，然后使用该值对分区数取模运算，得到分区索引。
消费者（Consumer）
Consumer 从 Kafka 集群指定的主题中读取消息记录。
在读取主题数据时需要设置消费组别名 （GroupId），如果不设置，则 Kafka 消费者会默认生成一个消费组名称。
消费者组（Consumer Group）
消费者程序在读取 Kafka 系统主题 （Topic）中的数据时，通常会使用多个线程来执行。
一个消费者组可以包含一个或多个消费者程序，使用多分区和多线程模式可以极大提高读取数据的效率。
一般设置线程数小于分区数，避免造成资源浪费。
主题（Topic）
Kafka 系统通过主题来区分不同业务类型的消息记录。
例如：用户登录数据存储在主题A中，用户充值记录存储在主题B中，则如果应用程序只订阅了主题A，没有订阅主题B，那该应用程序只能读取主题A中的数据。
分区（Partition）
每一个主题（Topic）中可以有一个或者多个分区（Partition）。在 Kafka 系统的设计思想中，分区是基于物理层面上的，不同的分区对应着不同的数据文件。
Kafka 通过分区（Partition）来支持物理层面上的并发读写，以提高 Kafka 集群的吞吐量。
每个分区内部的消息记录是有序的，每个消息都有一个连续的偏移量序号。
一个分区只对应一个代理节点，一个代理节点可以管理多个分区。
副本（Replication）
在 Kafka 系统，每个 Topic 在创建时会要求指定它的副本数，默认是 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8a74a24f24ab5a4689da3baeb3b52fec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-01T16:23:35+08:00" />
<meta property="article:modified_time" content="2021-06-01T16:23:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">消息队列 Kafka ：入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>消息队列</h2> 
<h3><a id="_1"></a>是什么</h3> 
<p>message queue，简称 MQ。拥有 FIFO 特性，主要用于不同进程或线程之间的通信，用来处理一系列的输入请求。</p> 
<p>采用异步通信机制，也就是消息的发送者和接收者无需同时与消息队列进行数据交互，消息会一直保存在队列中，直到被接收者读取。每一条消息记录都包含了详细的数据说明，包括数据产生的时间，数据类型，特定的输入参数等。</p> 
<h3><a id="_6"></a>作用</h3> 
<ul><li>应用解耦：多个应用可以通过消息队列对相同的消息进行处理，应用之间相互独立，互不影响。</li><li>异步处理：相比于串行和并行，异步更能减少时间。</li><li>数据限流：控制高峰期的数据流量，避免系统崩溃。</li><li>消息通信：点对点消息队列或聊天室等。</li></ul> 
<h2><a id="Kafka_12"></a>Kafka</h2> 
<p>Linkedin 团队发现市面上的系统无法做到实时服务，所以就自己搞了一个，既满足实时处理的需求，又可以支持水平扩展的消息系统，还拥有着高吞吐量。</p> 
<p>Kafka 是一个分布式实时数据流平台，可独立部署在单台服务器上，也可以部署在多台服务器上构成集群。提供了发布订阅功能，用户可以发送数据到 Kafka 集群中，也可以从 Kafka 集群中读取数据。</p> 
<h4><a id="_17"></a>以下是几个核心的概念：</h4> 
<ol><li> <p>代理（Broker）</p> <p>在 Kafka 集群中，一个 Kafka 进程（实例）被称为一个代理节点。通常在部署分布式 Kafka 集群时，一台服务器上部署一个 kafka 实例。</p> </li><li> <p>生产者（Producer）</p> <p>Producer 将消息记录发送到Kafka 集群指定的主题（Topic）中进行存储，同时生产者也能通过自定义算法觉得将消息记录发送到哪个分区（Partition）。<br> 例如，通过获取消息记录主键的hash值，然后使用该值对分区数取模运算，得到分区索引。</p> </li><li> <p>消费者（Consumer）</p> <p>Consumer 从 Kafka 集群指定的主题中读取消息记录。<br> 在读取主题数据时需要设置消费组别名 （GroupId），如果不设置，则 Kafka 消费者会默认生成一个消费组名称。</p> </li><li> <p>消费者组（Consumer Group）</p> <p>消费者程序在读取 Kafka 系统主题 （Topic）中的数据时，通常会使用多个线程来执行。<br> 一个消费者组可以包含一个或多个消费者程序，使用多分区和多线程模式可以极大提高读取数据的效率。<br> 一般设置线程数小于分区数，避免造成资源浪费。</p> </li><li> <p>主题（Topic）</p> <p>Kafka 系统通过主题来区分不同业务类型的消息记录。<br> 例如：用户登录数据存储在主题A中，用户充值记录存储在主题B中，则如果应用程序只订阅了主题A，没有订阅主题B，那该应用程序只能读取主题A中的数据。</p> </li><li> <p>分区（Partition）</p> <p>每一个主题（Topic）中可以有一个或者多个分区（Partition）。在 Kafka 系统的设计思想中，分区是基于物理层面上的，不同的分区对应着不同的数据文件。<br> Kafka 通过分区（Partition）来支持物理层面上的并发读写，以提高 Kafka 集群的吞吐量。<br> 每个分区内部的消息记录是有序的，每个消息都有一个连续的偏移量序号。<br> 一个分区只对应一个代理节点，一个代理节点可以管理多个分区。</p> </li><li> <p>副本（Replication）</p> <p>在 Kafka 系统，每个 Topic 在创建时会要求指定它的副本数，默认是 1. 通过副本 （Replication）机制来保证 Kafka 分布式集群数据的高可用性。<br> 说白了，就是担心数据丢失。</p> </li><li> <p>记录（Record）</p> <p>被实际写到 Kafka 集群并且可以被消费者应用程序读取的数据，被称为记录 （Record）。每条记录包含了一个键（Key），值（Value），和时间戳（Timestamp）</p> </li></ol> 
<h4><a id="Kafka____59"></a>Kafka 工作机制 - 生产消息\消费消息</h4> 
<p><img src="https://images2.imgbox.com/d6/27/1oAhLX53_o.png" alt="在这里插入图片描述"></p> 
<ul><li>生产者负责写入消息数据，将 audit logs 等主动推送到 kafka 集群中进行存储</li><li>消费者负责读取消息数据，例如 Hadoop 的应用接口，ElasticSearch 的应用接口等</li></ul> 
<p>Kafka 是一个分布式系统，用 Zookeeper 来管理，协调 Kafka 集群的各个代理节点。当 Kafka 集群中添加了一个代理节点，或者某一台代理节点出现故障时， Zookeeper 服务将会通知生产者应用程序和消费者应用程序去其他的正常代理节点读写。</p> 
<h4><a id="kafka__67"></a>kafka 的使用范围</h4> 
<p>Kafka 拥有处理海量数据的能力。不仅在实时业务场景中有天然的优势，在处理某些场景中的离线任务也十分优秀。</p> 
<p>在实时业务场景中，Kafka 能够和 Spark 、Flink、Storm等实时计算引擎完美结合，同时，Kafka 也提供了应用接口（API），可以将主题（Topic ）中的数据导出到 Hive 仓库做离线计算。</p> 
<h5><a id="_71"></a>特性</h5> 
<ol><li> <p>高吞吐量</p> <p>比如运营商的日志，每秒产生的数据流十分巨大</p> </li><li> <p>高可用队列<br> 分布式消息队列都具有异步处理机制，还可以处理大量数据的积压，方便其他离线系统的定期数据加载。</p> </li><li> <p>低延时<br> 说白了，就是耗时少</p> </li><li> <p>分布式机制<br> 支持分区，分布式，能实时处理消息等特点，在机器发生故障时能保证数据不丢失</p> </li></ol> 
<h5><a id="_83"></a>适用场景</h5> 
<ol><li>日志收集：Kafka 将所有的日志收集到 Kafka 集群中，然后通过 Kafka 的统一接口将这些数据开放给不同的消费者。统一接口包括 Hadoop接口，HBase接口，ElasticSearch接口等。</li><li>消息系统：使用 Kafka 作为缓冲，减少服务器的压力，能够有效解耦生产者和消费者，以及缓冲消息数据</li><li>用户轨迹：可以记录浏览器用户或者app用户产生的各种记录，比如网页点击，搜索内容等。consumer 可以消费这些数据来做实时分析，或加载到 hive 数据仓库做离线数据分析与挖掘</li><li>运营监控数据：应该就是监控各个应用系统的数据</li><li>实现流处理：其实就是实时处理</li><li>事件源：</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1fd42ac79ccbd8309c29dcc17b0a334b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Cyclictest测试Linux内核的实时性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba0ff36749930626f7749c292cf7f5d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pygame实现鼠标键盘监听事件响应，有趣的实验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>