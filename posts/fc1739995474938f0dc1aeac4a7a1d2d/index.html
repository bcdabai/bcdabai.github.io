<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pring boot 常见http请求参数处理与自定义注解校验 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="pring boot 常见http请求参数处理与自定义注解校验" />
<meta property="og:description" content="在定义一个Rest接口时通常会利用GET、POST、PUT、DELETE来实现数据的增删改查；这几种方式有的需要传递参数，后台开发人员必须对接收到的参数进行参数验证来确保程序的健壮性
GET
一般用于查询数据，采用明文进行传输，一般用来获取一些无关用户信息的数据
POST
一般用于插入数据
PUT
一般用于数据更新
DELETE
一般用于数据删除
一般都是进行逻辑删除（即：仅仅改变记录的状态，而并非真正的删除数据）
@PathVaribale 获取url中的数据
@RequestParam 获取请求参数的值
@GetMapping 组合注解，是 @RequestMapping(method = RequestMethod.GET) 的缩写
@RequestBody 利用一个对象去获取前端传过来的数据
PathVaribale 获取url路径的数据
请求URL：
localhost:8080/hello/id 获取id值
实现代码如下：
@RestController
public class HelloController {
@RequestMapping(value=&#34;/hello/{id}/{name}&#34;,method= RequestMethod.GET)
public String sayHello(@PathVariable(&#34;id&#34;) Integer id,@PathVariable(&#34;name&#34;) String name){
return &#34;id:&#34;&#43;id&#43;&#34; name:&#34;&#43;name;
}
}
在浏览器中 输入地址：
localhost：8080/hello/100/hello
输出：
id:81name:hello
RequestParam 获取请求参数的值
获取url参数值，默认方式，需要方法参数名称和url参数保持一致
localhost:8080/hello?id=1000
@RestController
public class HelloController {
@RequestMapping(value=&#34;/hello&#34;,method= RequestMethod.GET)
public String sayHello(@RequestParam Integer id){
return &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fc1739995474938f0dc1aeac4a7a1d2d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-27T16:18:13+08:00" />
<meta property="article:modified_time" content="2019-10-27T16:18:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pring boot 常见http请求参数处理与自定义注解校验</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在定义一个Rest接口时通常会利用GET、POST、PUT、DELETE来实现数据的增删改查；这几种方式有的需要传递参数，后台开发人员必须对接收到的参数进行参数验证来确保程序的健壮性<br> GET<br> 一般用于查询数据，采用明文进行传输，一般用来获取一些无关用户信息的数据<br> POST<br> 一般用于插入数据<br> PUT<br> 一般用于数据更新<br> DELETE<br> 一般用于数据删除<br> 一般都是进行逻辑删除（即：仅仅改变记录的状态，而并非真正的删除数据）</p> 
<p>@PathVaribale 获取url中的数据<br> @RequestParam 获取请求参数的值<br> @GetMapping 组合注解，是 @RequestMapping(method = RequestMethod.GET) 的缩写<br> @RequestBody 利用一个对象去获取前端传过来的数据</p> 
<p>PathVaribale 获取url路径的数据<br> 请求URL：<br> localhost:8080/hello/id 获取id值</p> 
<p>实现代码如下：</p> 
<p>@RestController<br> public class HelloController {<!-- --><br>     @RequestMapping(value="/hello/{id}/{name}",method= RequestMethod.GET)<br>     public String sayHello(@PathVariable("id") Integer id,@PathVariable("name") String name){<!-- --><br>         return "id:"+id+" name:"+name;<br>     }<br> }<br><br> 在浏览器中 输入地址：<br> localhost：8080/hello/100/hello</p> 
<p>输出：<br> id:81name:hello</p> 
<p>RequestParam 获取请求参数的值<br> 获取url参数值，默认方式，需要方法参数名称和url参数保持一致<br> localhost:8080/hello?id=1000</p> 
<p>@RestController<br> public class HelloController {<!-- --><br>     @RequestMapping(value="/hello",method= RequestMethod.GET)<br>     public String sayHello(@RequestParam Integer id){<!-- --><br>         return "id:"+id;<br>     }<br> }<br><br> 输出：<br> id：100</p> 
<p>url中有多个参数时，如：<br> localhost:8080/hello?id=98&amp;&amp;name=helloworld<br> 具体代码如下：</p> 
<p>@RestController<br> public class HelloController {<!-- --><br>     @RequestMapping(value="/hello",method= RequestMethod.GET)<br>     public String sayHello(@RequestParam Integer id,@RequestParam String name){<!-- --><br>         return "id:"+id+ " name:"+name;<br>     }<br> }<br><br> 获取url参数值，执行参数名称方式<br> localhost:8080/hello?userId=1000</p> 
<p>@RestController<br> public class HelloController {<!-- --><br>     @RequestMapping(value="/hello",method= RequestMethod.GET)<br>     public String sayHello(@RequestParam("userId") Integer id){<!-- --><br>         return "id:"+id;<br>     }<br> }<br><br> 输出：<br> id：100</p> 
<p>注意<br> 不输入id的具体值，此时返回的结果为null。具体测试结果如下：<br> id：null<br> 不输入id参数，则会报如下错误：<br> whitelable Error Page错误</p> 
<p>GET参数校验<br> 用法：不输入id时，使用默认值<br> 具体代码如下：<br> localhost：8080/hello</p> 
<p>@RestController<br> public class HelloController {<!-- --><br>     @RequestMapping(value="/hello",method= RequestMethod.GET)<br>     //required=false 表示url中可以无id参数，此时就使用默认参数<br>     public String sayHello(@RequestParam(value="id",required = false,defaultValue = "1") Integer id){<!-- --><br>         return "id:"+id;<br>     }<br> }<br> 输出<br> id:1</p> 
<p>POST JSON参数校验<br> 常用校验注解</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/80/ef/gCdtsTHX_o.png"></p> 
<p>注意：<br> 接收到的参数默认都是字符串类型的<br> 有的注解只能用在String类型的属性上</p> 
<p>@JsonProperty可以实现前端的属性名和后台实体类的属性名不一致问题</p> 
<p>校验方式：<br> 使用@RequestBody @Valid 对JSON参数进行获取和校验。<br> 通过BindingResult bindingResult 去获取校验结果。</p> 
<p>BindingResult 源码：</p> 
<p>技巧01：利用BindingResult对象的hasErrors方法判断是否有参数错误<br> 技巧02：利用BindingResult对象的getFieldErrors方法获取所有有参数错误的属性<br> 技巧03：利用错误属性对象的getDefaultMessage去获取错误提示信息</p> 
<p>@RequestMapping(value = "/demo5",produces = MediaType.TEXT_PLAIN_VALUE)<br>     @ResponseBody<br>     public String test5(@RequestBody @Valid  User user , BindingResult bindingResult){<!-- --><br>         if(bindingResult.hasErrors()){<!-- --><br>             List&lt;ObjectError&gt; objectErrors = bindingResult.getAllErrors();<br>             System.out.println(objectErrors.toString());<br>             for(ObjectError objectError: objectErrors){<!-- --><br>                 System.out.println("objectError = " + objectError.getObjectName());<br>                 System.out.println("objectError = " + objectError.getDefaultMessage());<br>                 System.out.println("objectError = " + objectError.getCode());<br>                 System.out.println("objectError = " + objectError.getArguments());</p> 
<p>            }<br>         }<br>         String str =  user.toString();</p> 
<p>        return str;<br>     }<br><br> 对应User实体类代码：</p> 
<p><br> public class User {<!-- --><br>     @NotEmpty(message = "ID不能为空")<br>     @NotBlank(message = "ID不能为空哟")<br>     private String id;</p> 
<p>    @Min(value = 18)<br>     @Max(value = 30)<br>     private Integer age;</p> 
<p>    @NotEmpty(message = "昵称不能为空")<br>     @NotBlank(message = "昵称不能为空哟")<br>     @JsonProperty("nickname") //  当前端属性为nick后台接收对象的属性为nickName时可以用@JsonProperty来保持一致<br>     private String name;</p> 
<p>    ....省略get set方法<br><br> 自定义注解校验<br> 1、定义一个校验注解</p> 
<p>代码如下：</p> 
<p>import javax.validation.Constraint;<br> import javax.validation.Payload;<br> import java.lang.annotation.*;</p> 
<p>@Documented<br> @Retention(RetentionPolicy.RUNTIME)<br> @Target({ElementType.PARAMETER, ElementType.FIELD})<br> @Constraint(validatedBy = MyFormValidatorClass.class)<br> public @interface MyFormValidator {<!-- --><br>     String value();<br>     String message() default "name can be test";<br>     Class&lt;?&gt;[] groups() default {};<br>     Class&lt;? extends Payload&gt;[]  payload() default {};<br> }<br><br> 2、定义一个约束校验</p> 
<p><br> import javax.validation.ConstraintValidator;<br> import javax.validation.ConstraintValidatorContext;<br> import java.lang.annotation.Annotation;</p> 
<p>public class MyFormValidatorClass implements ConstraintValidator&lt;MyFormValidator, Object&gt;, Annotation {<!-- --><br>     private String values;</p> 
<p>    @Override<br>     public void initialize(MyFormValidator myFormValidator) {<!-- --><br>         this.values = myFormValidator.value();<br>     }</p> 
<p>    @Override<br>     public boolean isValid(Object value, ConstraintValidatorContext context) {<!-- --><br>         if("test".equals((String)value)){<!-- --><br>             return true;<br>         }<br>         return false;<br>     }</p> 
<p>    @Override<br>     public Class&lt;? extends Annotation&gt; annotationType() {<!-- --><br>         return null;<br>     }<br> }<br> 3、实体类中使用</p> 
<p>public class User2 {<!-- --><br>     @NotEmpty(message = "ID不能为空")<br>     @NotBlank(message = "ID不能为空哟")<br>     //自定义校验注解-校验id是否为test<br>     @MyFormValidator(value = "abc",message = "dd")<br>     private String id;</p> 
<p>    @Min(value = 18)<br>     @Max(value = 30)<br>     private Integer age;</p> 
<p>    @NotEmpty(message = "昵称不能为空")<br>     @NotBlank(message = "昵称不能为空哟")<br>     @JsonProperty("nickname") //  当前端属性为nick后台接收对象的属性为nickName时可以用@JsonProperty来保持一致<br><br> 4、测试代码：</p> 
<p>@RequestMapping(value = "/demo6",produces = MediaType.TEXT_PLAIN_VALUE)<br>     @ResponseBody<br>     public String test6(@RequestBody @Valid User2 user , BindingResult bindingResult){<!-- --><br>         if(bindingResult.hasErrors()){<!-- --><br>             List&lt;ObjectError&gt; objectErrors = bindingResult.getAllErrors();<br>             System.out.println(objectErrors.toString());<br>             for(ObjectError objectError: objectErrors){<!-- --><br>                 System.out.println("objectError = " + objectError.getObjectName());<br>                 System.out.println("objectError = " + objectError.getDefaultMessage());<br>                 System.out.println("objectError = " + objectError.getCode());<br>                 System.out.println("objectError = " + objectError.getArguments());</p> 
<p>            }<br>         }<br>         String str =  user.toString();</p> 
<p>        return str;<br>     }<br><br> 原文链接：https://blog.csdn.net/yunfeng482/article/details/79756233</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8098535ee232947aa51ac50a60426ca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Uipath创建文件夹</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f74ced7ff55f965857d28d591bb48a1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">死磕 java线程系列之线程池深入解析——生命周期</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>