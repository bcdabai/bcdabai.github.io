<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023年团体程序设计天梯赛（含部分题解） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2023年团体程序设计天梯赛（含部分题解）" />
<meta property="og:description" content="目录
个人总结
L1-1 最好的文档（模拟）
AC代码：
L1-2 什么是机器学习（模拟）
AC代码：
L1-3 程序员买包子（模拟）
AC代码：
L1-4 进化论（模拟）
AC代码：
L1-5 猜帽子游戏（模拟）
AC代码：
L1-6 剪切粘贴（模拟）
AC代码：
L1-7 分寝室（模拟）
AC代码：
L1-8 谁管谁叫爹（模拟）
AC代码：
L2-1 堆宝塔（栈）
AC代码：
L2-2 天梯赛的赛场安排（堆）
AC代码：
L2-3 锦标赛
（代码待补充）
L2-4 寻宝图（BFS）
AC代码：
L3-1 超能力者大赛
（代码待补充）
L3-2 完美树
（代码待补充）
L3-3 血染钟楼
（代码待补充）
个人总结 今年的天梯赛相比于去年确实是简单了，但依旧未能保住175的国三个奖（弱校勿喷），最终因为L2-2题干意思看的过于粗略导致代码敲完后发现不太对劲从而浪费了不少时间，最终还是没能A掉L2-2以150&#43;结束今年的天梯赛，发现天梯赛的题好像就是有点在玩文字游戏，光读题就耗费了不少时间，不同于其他平台的OJ，也有可能是我个人对题意的理解有偏差吧，总之感觉天梯赛的题目就是又臭又长还难理解，明年应该还会参加天梯赛，希望那时候能拿个个人国奖
L1-1 最好的文档（模拟） 有一位软件工程师说过一句很有道理的话：“Good code is its own best documentation.”（好代码本身就是最好的文档）。本题就请你直接在屏幕上输出这句话。
输入格式：
本题没有输入。
输出格式：
在一行中输出 Good code is its own best documentation.。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e2409542516d36a3c9d443f28b0435eb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-27T10:00:51+08:00" />
<meta property="article:modified_time" content="2023-04-27T10:00:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023年团体程序设计天梯赛（含部分题解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93" rel="nofollow">个人总结</a></p> 
<p id="L1-1%C2%A0%E6%9C%80%E5%A5%BD%E7%9A%84%E6%96%87%E6%A1%A3%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89-toc" style="margin-left:0px;"><a href="#L1-1%C2%A0%E6%9C%80%E5%A5%BD%E7%9A%84%E6%96%87%E6%A1%A3%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89" rel="nofollow">L1-1 最好的文档（模拟）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="L1-2%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89-toc" style="margin-left:0px;"><a href="#L1-2%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89" rel="nofollow">L1-2 什么是机器学习（模拟）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="L1-3%20%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%B0%E5%8C%85%E5%AD%90%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89-toc" style="margin-left:0px;"><a href="#L1-3%20%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%B0%E5%8C%85%E5%AD%90%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89" rel="nofollow">L1-3 程序员买包子（模拟）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="L1-4%20%E8%BF%9B%E5%8C%96%E8%AE%BA%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89-toc" style="margin-left:0px;"><a href="#L1-4%20%E8%BF%9B%E5%8C%96%E8%AE%BA%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89" rel="nofollow">L1-4 进化论（模拟）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="L1-5%20%E7%8C%9C%E5%B8%BD%E5%AD%90%E6%B8%B8%E6%88%8F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89-toc" style="margin-left:0px;"><a href="#L1-5%20%E7%8C%9C%E5%B8%BD%E5%AD%90%E6%B8%B8%E6%88%8F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89" rel="nofollow">L1-5 猜帽子游戏（模拟）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="L1-6%20%E5%89%AA%E5%88%87%E7%B2%98%E8%B4%B4%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89-toc" style="margin-left:0px;"><a href="#L1-6%20%E5%89%AA%E5%88%87%E7%B2%98%E8%B4%B4%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89" rel="nofollow">L1-6 剪切粘贴（模拟）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="L1-7%20%E5%88%86%E5%AF%9D%E5%AE%A4%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89-toc" style="margin-left:0px;"><a href="#L1-7%20%E5%88%86%E5%AF%9D%E5%AE%A4%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89" rel="nofollow">L1-7 分寝室（模拟）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="L1-8%20%E8%B0%81%E7%AE%A1%E8%B0%81%E5%8F%AB%E7%88%B9%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89-toc" style="margin-left:0px;"><a href="#L1-8%20%E8%B0%81%E7%AE%A1%E8%B0%81%E5%8F%AB%E7%88%B9%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89" rel="nofollow">L1-8 谁管谁叫爹（模拟）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="L2-1%20%E5%A0%86%E5%AE%9D%E5%A1%94%EF%BC%88%E6%A0%88%EF%BC%89-toc" style="margin-left:0px;"><a href="#L2-1%20%E5%A0%86%E5%AE%9D%E5%A1%94%EF%BC%88%E6%A0%88%EF%BC%89" rel="nofollow">L2-1 堆宝塔（栈）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="L2-2%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%9A%84%E8%B5%9B%E5%9C%BA%E5%AE%89%E6%8E%92%EF%BC%88%E5%A0%86%EF%BC%89-toc" style="margin-left:0px;"><a href="#L2-2%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%9A%84%E8%B5%9B%E5%9C%BA%E5%AE%89%E6%8E%92%EF%BC%88%E5%A0%86%EF%BC%89" rel="nofollow">L2-2 天梯赛的赛场安排（堆）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="L2-3%20%E9%94%A6%E6%A0%87%E8%B5%9B-toc" style="margin-left:0px;"><a href="#L2-3%20%E9%94%A6%E6%A0%87%E8%B5%9B" rel="nofollow">L2-3 锦标赛</a></p> 
<p id="%EF%BC%88%E4%BB%A3%E7%A0%81%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BB%A3%E7%A0%81%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89" rel="nofollow">（代码待补充）</a></p> 
<p id="L2-4%20%E5%AF%BB%E5%AE%9D%E5%9B%BE%EF%BC%88BFS%EF%BC%89-toc" style="margin-left:0px;"><a href="#L2-4%20%E5%AF%BB%E5%AE%9D%E5%9B%BE%EF%BC%88BFS%EF%BC%89" rel="nofollow">L2-4 寻宝图（BFS）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="L3-1%20%E8%B6%85%E8%83%BD%E5%8A%9B%E8%80%85%E5%A4%A7%E8%B5%9B-toc" style="margin-left:0px;"><a href="#L3-1%20%E8%B6%85%E8%83%BD%E5%8A%9B%E8%80%85%E5%A4%A7%E8%B5%9B" rel="nofollow">L3-1 超能力者大赛</a></p> 
<p id="%EF%BC%88%E4%BB%A3%E7%A0%81%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BB%A3%E7%A0%81%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89" rel="nofollow">（代码待补充）</a></p> 
<p id="L3-2%20%E5%AE%8C%E7%BE%8E%E6%A0%91-toc" style="margin-left:0px;"><a href="#L3-2%20%E5%AE%8C%E7%BE%8E%E6%A0%91" rel="nofollow">L3-2 完美树</a></p> 
<p id="%EF%BC%88%E4%BB%A3%E7%A0%81%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BB%A3%E7%A0%81%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89" rel="nofollow">（代码待补充）</a></p> 
<p id="L3-3%20%E8%A1%80%E6%9F%93%E9%92%9F%E6%A5%BC-toc" style="margin-left:0px;"><a href="#L3-3%20%E8%A1%80%E6%9F%93%E9%92%9F%E6%A5%BC" rel="nofollow">L3-3 血染钟楼</a></p> 
<p id="%EF%BC%88%E4%BB%A3%E7%A0%81%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BB%A3%E7%A0%81%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89" rel="nofollow">（代码待补充）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93">个人总结</h2> 
<p>今年的天梯赛相比于去年确实是简单了，但依旧未能保住175的国三个奖（弱校勿喷），最终因为L2-2题干意思看的过于粗略导致代码敲完后发现不太对劲从而浪费了不少时间，最终还是没能A掉L2-2以150+结束今年的天梯赛，发现天梯赛的题好像就是有点在玩文字游戏，光读题就耗费了不少时间，不同于其他平台的OJ，也有可能是我个人对题意的理解有偏差吧，总之感觉天梯赛的题目就是又臭又长还难理解，明年应该还会参加天梯赛，希望那时候能拿个个人国奖</p> 
<hr> 
<h2 id="L1-1%C2%A0%E6%9C%80%E5%A5%BD%E7%9A%84%E6%96%87%E6%A1%A3%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89">L1-1 最好的文档（模拟）</h2> 
<p>有一位软件工程师说过一句很有道理的话：“Good code is its own best documentation.”（好代码本身就是最好的文档）。本题就请你直接在屏幕上输出这句话。</p> 
<p><strong>输入格式：</strong></p> 
<p>本题没有输入。</p> 
<p><strong>输出格式：</strong></p> 
<p>在一行中输出 <code>Good code is its own best documentation.</code>。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>无</p> 
</blockquote> 
<p><strong>输出样例</strong>：</p> 
<blockquote> 
 <p>Good code is its own best documentation.</p> 
</blockquote> 
<h3 id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A">AC代码：</h3> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{

    cout &lt;&lt; "Good code is its own best documentation." &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="L1-2%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89">L1-2 什么是机器学习（模拟）</h2> 
<p style="text-align:center;"><img alt="" class="left" height="269" src="https://images2.imgbox.com/01/34/iCLxEzaw_o.jpg" width="215"></p> 
<p>什么是机器学习？上图展示了一段面试官与“机器学习程序”的对话： </p> 
<blockquote> 
 <p>面试官：9 + 10 等于多少？<br> 答：3<br> 面试官：差远了，是19。<br> 答：16<br> 面试官：错了，是19。<br> 答：18<br> 面试官：不，是19。<br> 答：19</p> 
</blockquote> 
<p>本题就请你模仿这个“机器学习程序”的行为。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入在一行中给出两个整数，绝对值都不超过 100，中间用一个空格分开，分别表示面试官给出的两个数字 A 和 B。</p> 
<p><strong>输出格式：</strong></p> 
<p>要求你输出 4 行，每行一个数字。第 1 行比正确结果少 16，第 2 行少 3，第 3 行少 1，最后一行才输出 A+B 的正确结果。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>9 10</p> 
</blockquote> 
<p><strong>输出样例</strong>：</p> 
<blockquote> 
 <p>3<br> 16<br> 18<br> 19</p> 
</blockquote> 
<h3>AC代码：</h3> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int a, b, sum;
    cin &gt;&gt; a &gt;&gt; b;
    sum = a + b;
    cout &lt;&lt; sum - 16 &lt;&lt; endl;
    cout &lt;&lt; sum - 3 &lt;&lt; endl;
    cout &lt;&lt; sum - 1 &lt;&lt; endl;
    cout &lt;&lt; sum &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="L1-3%20%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B9%B0%E5%8C%85%E5%AD%90%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89">L1-3 程序员买包子（模拟）</h2> 
<p style="text-align:center;"><img alt="" class="left" src="https://images2.imgbox.com/48/ac/nsS3O7I1_o.jpg"></p> 
<p> 这是一条检测真正程序员的段子：假如你被家人要求下班顺路买十只包子，如果看到卖西瓜的，买一只。那么你会在什么情况下只买一只包子回家？<br> 本题要求你考虑这个段子的通用版：假如你被要求下班顺路买 N 只包子，如果看到卖 X 的，买 M 只。那么如果你最后买了 K 只包子回家，说明你看到卖 X 的没有呢？</p> 
<p><strong>输入格式：</strong></p> 
<p>输入在一行中顺序给出题面中的 N、X、M、K，以空格分隔。其中 N、M 和 K 为不超过 1000 的正整数，X 是一个长度不超过 10 的、仅由小写英文字母组成的字符串。题目保证 N != M。</p> 
<p><strong>输出格式：</strong></p> 
<p>在一行中输出结论，格式为：</p> 
<ul><li>如果 K=N，输出 <code>mei you mai X de</code>；</li><li>如果 K=M，输出 <code>kan dao le mai X de</code>；</li><li>否则输出 <code>wang le zhao mai X de</code>.<br> 其中 <code>X</code> 是输入中给定的字符串 X。</li></ul> 
<p><strong>输入样例1：</strong></p> 
<blockquote> 
 <p>10 xigua 1 10</p> 
</blockquote> 
<p><strong>输出样例1</strong>：</p> 
<blockquote> 
 <p>mei you mai xigua de</p> 
</blockquote> 
<p><strong>输入样例2：</strong></p> 
<blockquote> 
 <p>10 huanggua 1 1</p> 
</blockquote> 
<p><strong>输出样例2：</strong></p> 
<blockquote> 
 <p>kan dao le mai huanggua de</p> 
</blockquote> 
<p><strong>输入样例3：</strong></p> 
<blockquote> 
 <p>10 shagua 1 250</p> 
</blockquote> 
<p><strong>输出样例3：</strong></p> 
<blockquote> 
 <p>wang le zhao mai shagua de</p> 
</blockquote> 
<h3>AC代码：</h3> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n, m, k;
    string x;
    cin &gt;&gt; n &gt;&gt; x &gt;&gt; m &gt;&gt; k;
    if (k == n) cout &lt;&lt; "mei you mai " &lt;&lt; x &lt;&lt; " de" &lt;&lt; endl;
    else if (k == m) cout &lt;&lt; "kan dao le mai " &lt;&lt; x &lt;&lt; " de" &lt;&lt; endl;
    else cout &lt;&lt; "wang le zhao mai " &lt;&lt; x &lt;&lt; " de" &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="L1-4%20%E8%BF%9B%E5%8C%96%E8%AE%BA%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89">L1-4 进化论（模拟）</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/51/51/kDWfHiIb_o.jpg"></p> 
<p>在“一年一度喜剧大赛”上有一部作品《进化论》，讲的是动物园两只猩猩进化的故事。猩猩吕严说自己已经进化了 9 年了，因为“三年又三年”。猩猩土豆指出“三年又三年是六年呐”……<br> 本题给定两个数字，以及用这两个数字计算的结果，要求你根据结果判断，这是吕严算出来的，还是土豆算出来的。 </p> 
<p><strong>输入格式：</strong></p> 
<p>输入第一行给出一个正整数 N，随后 N 行，每行给出三个正整数 A、B 和 C。其中 C 不超过 10000，其他三个数字都不超过 100。</p> 
<p><strong>输出格式：</strong></p> 
<p>对每一行给出的三个数，如果 C 是 A×B，就在一行中输出 <code>Lv Yan</code>；如果是 A+B，就在一行中输出 <code>Tu Dou</code>；如果都不是，就在一行中输出 <code>zhe du shi sha ya!</code>。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>3<br> 3 3 9<br> 3 3 6<br> 3 3 12</p> 
</blockquote> 
<p><strong>输出样例</strong>：</p> 
<blockquote> 
 <p>Lv Yan<br> Tu Dou<br> zhe du shi sha ya!</p> 
</blockquote> 
<h3>AC代码：</h3> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int i, n;
    vector&lt;string&gt;res;
    string item1 = "Lv Yan", item2 = "Tu Dou", item3 = "zhe du shi sha ya!";
    cin &gt;&gt; n;
    for (i = 0; i &lt; n; i++) {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        if (a * b == c) res.push_back(item1);
        else if (a + b == c) res.push_back(item2);
        else res.push_back(item3);
    }
    for (i = 0; i &lt; res.size(); i++) {
        cout &lt;&lt; res[i] &lt;&lt; endl;
    }

    system("pause");
    return 0;
}</code></pre> 
<h2 id="L1-5%20%E7%8C%9C%E5%B8%BD%E5%AD%90%E6%B8%B8%E6%88%8F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89">L1-5 猜帽子游戏（模拟）</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c9/b5/bfkjN7NA_o.png"></p> 
<p> 宝宝们在一起玩一个猜帽子游戏。每人头上被扣了一顶帽子，有的是黑色的，有的是黄色的。每个人可以看到别人头上的帽子，但是看不到自己的。游戏开始后，每个人可以猜自己头上的帽子是什么颜色，或者可以弃权不猜。如果没有一个人猜错、并且至少有一个人猜对了，那么所有的宝宝共同获得一个大奖。如果所有人都不猜，或者只要有一个人猜错了，所有宝宝就都没有奖。<br> 下面顺序给出一排帽子的颜色，假设每一群宝宝来玩的时候，都是按照这个顺序发帽子的。然后给出每一群宝宝们猜的结果，请你判断他们能不能得大奖。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入首先在一行中给出一个正整数 N（2&lt;N≤100），是帽子的个数。第二行给出 N 顶帽子的颜色，数字 <code>1</code> 表示黑色，<code>2</code> 表示黄色。<br> 再下面给出一个正整数 K（≤10），随后 K 行，每行给出一群宝宝们猜的结果，除了仍然用数字 <code>1</code> 表示黑色、<code>2</code> 表示黄色之外，<code>0</code> 表示这个宝宝弃权不猜。<br> 同一行中的数字用空格分隔。</p> 
<p><strong>输出格式：</strong></p> 
<p>对于每一群玩游戏的宝宝，如果他们能获得大奖，就在一行中输出 <code>Da Jiang!!!</code>，否则输出 <code>Ai Ya</code>。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>5<br> 1 1 2 1 2<br> 3<br> 0 1 2 0 0<br> 0 0 0 0 0<br> 1 2 2 0 2</p> 
</blockquote> 
<p><strong>输出样例</strong>：</p> 
<blockquote> 
 <p>Da Jiang!!!<br> Ai Ya<br> Ai Ya</p> 
</blockquote> 
<p><strong>思路： </strong>可以定义一个bool型变量flag用来记录是否有答错的，count记录总弃权人数，最终综合判断即可</p> 
<h3>AC代码：</h3> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int i, j, k, n;
    cin &gt;&gt; n;
    vector&lt;int&gt;nums(n, 0);
    vector&lt;string&gt;res;
    for (i = 0; i &lt; n; i++) {
        cin &gt;&gt; nums[i];
    }
    cin &gt;&gt; k;
    for (i = 0; i &lt; k; i++) {
        bool flag = true;
        int count = 0;
        for (j = 0; j &lt; n; j++) {
            int x;
            cin &gt;&gt; x;
            if (x == 0) {
                count++;
                continue;
            }
            if (x != nums[j]) flag = false;
        }
        if (count &lt; n &amp;&amp; flag) res.push_back("Da Jiang!!!");
        else res.push_back("Ai Ya");
    }
    for (i = 0; i &lt; res.size(); i++) {
        cout &lt;&lt; res[i] &lt;&lt; endl;
    }


    system("pause");
    return 0;
}</code></pre> 
<h2 id="L1-6%20%E5%89%AA%E5%88%87%E7%B2%98%E8%B4%B4%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89">L1-6 剪切粘贴（模拟）</h2> 
<p>使用计算机进行文本编辑时常见的功能是剪切功能（快捷键：Ctrl + X）。请实现一个简单的具有剪切和粘贴功能的文本编辑工具。</p> 
<p>工具需要完成一系列剪切后粘贴的操作，每次操作分为两步：</p> 
<ul><li>剪切：给定需操作的起始位置和结束位置，将当前字符串中起始位置到结束位置部分的字符串放入剪贴板中，并删除当前字符串对应位置的内容。例如，当前字符串为 <code>abcdefg</code>，起始位置为 3，结束位置为 5，则剪贴操作后， 剪贴板内容为 <code>cde</code>，操作后字符串变为 <code>abfg</code>。字符串位置从 1 开始编号。</li><li>粘贴：给定插入位置的前后字符串，寻找到插入位置，将剪贴板内容插入到位置中，并清除剪贴板内容。例如，对于上面操作后的结果，给定插入位置前为 <code>bf</code>，插入位置后为 <code>g</code>，则插入后变为 <code>abfcdeg</code>。如找不到应该插入的位置，则直接将插入位置设置为字符串最后，仍然完成插入操作。查找字符串时区分大小写。</li></ul> 
<p>每次操作后的字符串即为新的当前字符串。在若干次操作后，请给出最后的编辑结果。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入第一行是一个长度小于等于 200 的字符串 S，表示原始字符串。字符串只包含所有可见 ASCII 字符，不包含回车与空格。</p> 
<p>第二行是一个正整数 N (1≤N≤100)，表示要进行的操作次数。</p> 
<p>接下来的 N 行，每行是两个数字和两个<strong>长度不大于 5</strong> 的不包含空格的非空字符串，前两个数字表示需要剪切的位置，后两个字符串表示插入位置前和后的字符串，用一个空格隔开。如果有多个可插入的位置，选择最靠近当前操作字符串开头的一个。</p> 
<p>剪切的位置保证总是合法的。</p> 
<p><strong>输出格式：</strong></p> 
<p>输出一行，表示操作后的字符串。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>AcrosstheGreatWall,wecanreacheverycornerintheworld<br> 5<br> 10 18 ery cor<br> 32 40 , we<br> 1 6 tW all<br> 14 18 rnerr eache<br> 1 1 e r</p> 
</blockquote> 
<p><strong>输出样例</strong>：</p> 
<blockquote> 
 <p>he,allcornetrrwecaneacheveryGreatWintheworldAcross</p> 
</blockquote> 
<p><strong>思路：</strong>利用C++STL的string容器内的string::substr()取子串操作和string::find()查找子串操作以及string::insert()插入操作即可轻松解决，这里需要注意一下的是在插入的过程中我们需要将插入字符串的前后字符串综合到一块来考虑，在插入的时候下标加上对应前置子串的长度即可</p> 
<h3>AC代码：</h3> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int i, j, k, n;
    string s;
    cin &gt;&gt; s &gt;&gt; n;
    for (i = 0; i &lt; n; i++) {
        int a, b;
        string s1, s2;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s1 &gt;&gt; s2;
        string item = s.substr(a - 1, b - a + 1);
        s = s.substr(0, a - 1) + s.substr(b, s.length() - b);
        string s3 = s1 + s2;
        int index = s.find(s3);
        if (index == -1) s += item;
        else {
            s.insert(index + s1.length(), item);
        }
    }
    cout &lt;&lt; s &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="L1-7%20%E5%88%86%E5%AF%9D%E5%AE%A4%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89">L1-7 分寝室（模拟）</h2> 
<p>学校新建了宿舍楼，共有 n 间寝室。等待分配的学生中，有女生 n0​ 位、男生 n1​ 位。所有待分配的学生都必须分到一间寝室。所有的寝室都要分出去，最后不能有寝室留空。<br> 现请你写程序完成寝室的自动分配。分配规则如下：</p> 
<ul><li>男女生不能混住；</li><li>不允许单人住一间寝室；</li><li>对每种性别的学生，每间寝室入住的人数都必须相同；例如不能出现一部分寝室住 2 位女生，一部分寝室住 3 位女生的情况。但女生寝室都是 2 人一间，男生寝室都是 3 人一间，则是允许的；</li><li>在有多种分配方案满足前面三项要求的情况下，要求两种性别每间寝室入住的人数差最小。</li></ul> 
<p><strong>输入格式：</strong></p> 
<p>输入在一行中给出 3 个正整数 n0​、n1​、n，分别对应女生人数、男生人数、寝室数。数字间以空格分隔，均不超过 105。</p> 
<p><strong>输出格式：</strong></p> 
<p>在一行中顺序输出女生和男生被分配的寝室数量，其间以 1 个空格分隔。行首尾不得有多余空格。<br> 如果有解，题目保证解是唯一的。如果无解，则在一行中输出 <code>No Solution</code>。</p> 
<p><strong>输入样例1：</strong></p> 
<blockquote> 
 <p>24 60 10</p> 
</blockquote> 
<p><strong>输出样例1</strong>：</p> 
<blockquote> 
 <p>4 6</p> 
</blockquote> 
<p><strong>注意：</strong>输出的方案对应女生都是 24/4=6 人间、男生都是 60/6=10 人间，人数差为 4。满足前三项要求的分配方案还有两种，即女生 6 间（都是 4 人间）、男生 4 间（都是 15 人间）；或女生 8 间（都是 3 人间）、男生 2 间（都是 30 人间）。但因为人数差都大于 4 而不被采用。</p> 
<p><strong>输入样例2：</strong></p> 
<blockquote> 
 <p>29 30 10</p> 
</blockquote> 
<p><strong>输出样例2：</strong></p> 
<blockquote> 
 <p>No Solution</p> 
</blockquote> 
<p><strong>思路：</strong>对每个寝室数量进行枚举模拟判断即可</p> 
<h3>AC代码：</h3> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int i, j, k;
    int n0, n1, n;
    cin &gt;&gt; n0 &gt;&gt; n1 &gt;&gt; n;
    int res_a = 0, res_b = 0, minn = INT_MAX;
    for (i = 1; i &lt; n; i++) {
        if (n0 % i == 0 &amp;&amp; n1 % (n - i) == 0 &amp;&amp; n0 != i &amp;&amp; n1 != (n - i)) {
            int item1 = n0 / i;
            int item2 = n1 / (n - 1);
            if (abs(item1 - item2) &lt; minn) {
                minn = abs(item1 - item2);
                res_a = i, res_b = n - i;
            }
        }
    }
    if (res_a == 0 &amp;&amp; res_b == 0) cout &lt;&lt; "No Solution" &lt;&lt; endl;
    else cout &lt;&lt; res_a &lt;&lt; " " &lt;&lt; res_b &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="L1-8%20%E8%B0%81%E7%AE%A1%E8%B0%81%E5%8F%AB%E7%88%B9%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89">L1-8 谁管谁叫爹（模拟）</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/65/2e/v3PH7Nwq_o.jpg"></p> 
<p>《咱俩谁管谁叫爹》是网上一首搞笑饶舌歌曲，来源于东北酒桌上的助兴游戏。现在我们把这个游戏的难度拔高一点，多耗一些智商。<br> 不妨设游戏中的两个人为 A 和 B。游戏开始后，两人同时报出两个整数 NA​ 和 NB​。判断谁是爹的标准如下：</p> 
<ul><li>将两个整数的各位数字分别相加，得到两个和 SA​ 和 SB​。如果 NA​ 正好是 SB​ 的整数倍，则 A 是爹；如果 NB​ 正好是 SA​ 的整数倍，则 B 是爹；</li><li>如果两人同时满足、或同时不满足上述判定条件，则原始数字大的那个是爹。<br> 本题就请你写一个自动裁判程序，判定谁是爹。</li></ul> 
<p><strong>输入格式：</strong></p> 
<p>输入第一行给出一个正整数 N（≤100），为游戏的次数。以下 N 行，每行给出一对不超过 9 位数的正整数，对应 A 和 B 给出的原始数字。题目保证两个数字不相等。</p> 
<p><strong>输出格式：</strong></p> 
<p>对每一轮游戏，在一行中给出赢得“爹”称号的玩家（<code>A</code> 或 <code>B</code>）。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>4<br> 999999999 891<br> 78250 3859<br> 267537 52654299<br> 6666 120</p> 
</blockquote> 
<p><strong>输出样例</strong>：</p> 
<blockquote> 
 <p>B<br> A<br> B<br> A</p> 
</blockquote> 
<h3>AC代码：</h3> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int i, j, k, n;
    cin &gt;&gt; n;
    vector&lt;char&gt;res;
    for (i = 0; i &lt; n; i++) {
        int a, b, sum_a = 0, sum_b = 0, num_a, num_b;
        cin &gt;&gt; a &gt;&gt; b;
        num_a = a, num_b = b;
        while (a) {
            sum_a += a % 10;
            a /= 10;
        }
        while (b) {
            sum_b += b % 10;
            b /= 10;
        }
        if (num_a % sum_b == 0 &amp;&amp; num_b % sum_a == 0 || num_a % sum_b != 0 &amp;&amp; num_b % sum_a != 0) {
            if (num_a &gt; num_b) res.push_back('A');
            else res.push_back('B');
        } else {
            if (num_a % sum_b == 0) res.push_back('A');
            else res.push_back('B');
        }
    }
    for (i = 0; i &lt; res.size(); i++) {
        cout &lt;&lt; res[i] &lt;&lt; endl;
    }


    system("pause");
    return 0;
}</code></pre> 
<p></p> 
<h2 id="L2-1%20%E5%A0%86%E5%AE%9D%E5%A1%94%EF%BC%88%E6%A0%88%EF%BC%89">L2-1 堆宝塔（栈）</h2> 
<p style="text-align:center;"><img alt="" class="left" height="257" src="https://images2.imgbox.com/f7/c6/2GAel5Bs_o.jpg" width="339"></p> 
<p>堆宝塔游戏是让小朋友根据抓到的彩虹圈的直径大小，按照从大到小的顺序堆起宝塔。但彩虹圈不一定是按照直径的大小顺序抓到的。聪明宝宝采取的策略如下：</p> 
<ul><li>首先准备两根柱子，一根 A 柱串宝塔，一根 B 柱用于临时叠放。</li><li>把第 1 块彩虹圈作为第 1 座宝塔的基座，在 A 柱放好。</li><li>将抓到的下一块彩虹圈 C 跟当前 A 柱宝塔最上面的彩虹圈比一下，如果比最上面的小，就直接放上去；否则把 C 跟 B 柱最上面的彩虹圈比一下：</li><li> 
  <ul><li>如果 B 柱是空的、或者 C 大，就在 B 柱上放好；</li></ul></li><li> 
  <ul><li>否则把 A 柱上串好的宝塔取下来作为一件成品；然后把 B 柱上所有比 C 大的彩虹圈逐一取下放到 A 柱上，最后把 C 也放到 A 柱上。</li></ul></li></ul> 
<p>重复此步骤，直到所有的彩虹圈都被抓完。最后 A 柱上剩下的宝塔作为一件成品，B 柱上剩下的彩虹圈被逐一取下，堆成另一座宝塔。问：宝宝一共堆出了几个宝塔？最高的宝塔有多少层？</p> 
<p><strong>输入格式：</strong></p> 
<p>输入第一行给出一个正整数 N（≤103），为彩虹圈的个数。第二行按照宝宝抓取的顺序给出 N 个不超过 100 的正整数，对应每个彩虹圈的直径。</p> 
<p><strong>输出格式：</strong></p> 
<p>在一行中输出宝宝堆出的宝塔个数，和最高的宝塔的层数。数字间以 1 个空格分隔，行首尾不得有多余空格。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>11<br> 10 8 9 5 12 11 4 3 1 9 15</p> 
</blockquote> 
<p><strong>输出样例</strong>：</p> 
<blockquote> 
 <p>4 5</p> 
</blockquote> 
<p><strong>样例解释：</strong></p> 
<p>宝宝堆成的宝塔顺次为：</p> 
<ul><li>10、8、5</li><li>12、11、4、3、1</li><li>9</li><li>15、9</li></ul> 
<h3>AC代码：</h3> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int i, j, k, n, count = 0;
    cin &gt;&gt; n;
    vector&lt;int&gt;nums(n, 0);
    for (i = 0; i &lt; n; i++) {
        cin &gt;&gt; nums[i];
    }
    int maxx = INT_MIN;
    stack&lt;int&gt;st1, st2;
    for (i = 0; i &lt; n; i++) {
        if (st1.empty() || st1.top() &gt; nums[i]) st1.push(nums[i]);
        else {
            if (st2.empty() || st2.top() &lt; nums[i]) st2.push(nums[i]);
            else {
                int ans = 0;
                while (!st1.empty()) {
                    ans++;
                    st1.pop();
                }
                count++;
                maxx = max(maxx, ans);
                while (!st2.empty() &amp;&amp; st2.top() &gt; nums[i]) {
                    st1.push(st2.top());
                    st2.pop();
                }
                st1.push(nums[i]);
            }
        }
    }
    if (!st1.empty()) count++;
    if (!st2.empty()) count++;
    int ans = 0;
    while (!st1.empty()) {
        ans++;
        st1.pop();
    }
    maxx = max(maxx, ans);
    ans = 0;
    while (!st2.empty()) {
        ans++;
        st2.pop();
    }
    maxx = max(maxx, ans);

    cout &lt;&lt; count &lt;&lt; " " &lt;&lt; maxx &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="L2-2%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%9A%84%E8%B5%9B%E5%9C%BA%E5%AE%89%E6%8E%92%EF%BC%88%E5%A0%86%EF%BC%89">L2-2 天梯赛的赛场安排（堆）</h2> 
<p style="text-align:center;"><img alt="" class="left" height="196" src="https://images2.imgbox.com/bf/6b/ZCAO8hwo_o.jpg" width="200"></p> 
<p>天梯赛使用 OMS 监考系统，需要将参赛队员安排到系统中的虚拟赛场里，并为每个赛场分配一位监考老师。每位监考老师需要联系自己赛场内队员对应的教练们，以便发放比赛账号。为了尽可能减少教练和监考的沟通负担，我们要求赛场的安排满足以下条件：</p> 
<ul><li>每位监考老师负责的赛场里，队员人数不得超过赛场规定容量 C；</li><li>每位教练需要联系的监考人数尽可能少 —— 这里假设每所参赛学校只有一位负责联系的教练，且每个赛场的监考老师都不相同。</li></ul> 
<p>为此我们设计了多轮次排座算法，按照尚未安排赛场的队员人数从大到小的顺序，每一轮对当前未安排的人数最多的学校进行处理。记当前待处理的学校未安排人数为 n：</p> 
<ul><li>如果 n≥C，则新开一个赛场，将 C 位队员安排进去。剩下的人继续按人数规模排队，等待下一轮处理；</li><li>如果 n&lt;C，则寻找剩余空位数大于等于 n 的编号最小的赛场，将队员安排进去；</li><li>如果 n&lt;C，且找不到任何非空的、剩余空位数大于等于 n 的赛场了，则新开一个赛场，将队员安排进去。</li></ul> 
<p>由于近年来天梯赛的参赛人数快速增长，2023年超过了 480 所学校 1.6 万人，所以我们必须写个程序来处理赛场安排问题。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入第一行给出两个正整数 N 和 C，分别为参赛学校数量和每个赛场的规定容量，其中 0&lt;N≤5000，10≤C≤50。随后 N 行，每行给出一个学校的缩写（为长度不超过 6 的非空小写英文字母串）和该校参赛人数（不超过 500 的正整数），其间以空格分隔。题目保证每所学校只有一条记录。</p> 
<p><strong>输出格式：</strong></p> 
<p>按照输入的顺序，对每一所参赛高校，在一行中输出学校缩写和该校需要联系的监考人数，其间以 1 空格分隔。<br> 最后在一行中输出系统中应该开设多少个赛场。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>10 30<br> zju 30<br> hdu 93<br> pku 39<br> hbu 42<br> sjtu 21<br> abdu 10<br> xjtu 36<br> nnu 15<br> hnu 168<br> hsnu 20</p> 
</blockquote> 
<p><strong>输出样例</strong>：</p> 
<blockquote> 
 <p>zju 1<br> hdu 4<br> pku 2<br> hbu 2<br> sjtu 1<br> abdu 1<br> xjtu 2<br> nnu 1<br> hnu 6<br> hsnu 1<br> 16</p> 
</blockquote> 
<p><strong>思路：</strong>可以利用优先队列（最大堆）依次存放每个学校的参赛队员，依次对其进行判断，如果堆顶的人数小于赛场规定容量C，我们则将堆中的所有小于C的参赛队员存储到vector容器中依次进行遍历（双指针），将剩余人数进行凑齐，最终判断vector中无法凑齐的队员有几个赛场，对其进行额外分配即可</p> 
<h3>AC代码：</h3> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int i, j, k, n, c, ans = 0;
    cin &gt;&gt; n &gt;&gt; c;
    map&lt;string, int&gt;mp;
    map&lt;int, string&gt;mp1;
    vector&lt;int&gt;nums(n, 0);
    vector&lt;int&gt;res(n, 0);
    priority_queue&lt;pair&lt;int, string&gt;&gt;Q;
    for (i = 0; i &lt; n; i++) {
        string s;
        int x;
        cin &gt;&gt; s &gt;&gt; x;
        nums[i] = x;
        mp[s] = i;
        mp1[i] = s;
        Q.push({x, s});
    }
    while (!Q.empty()) {
        auto t = Q.top();
        int N = t.first;
        string name = t.second;
        if (N &gt;= c) {
            N -= c;
            res[mp[name]]++;
            ans++;
            Q.push({N, name});
        } else break;
        Q.pop();
    }
    vector&lt;pair&lt;int, string&gt;&gt;item;
    while (!Q.empty()) {
        auto t = Q.top();
        if (t.first != 0)
            item.push_back({t.first, t.second});
        Q.pop();
    }
    for (i = 0, j = item.size() - 1; i &lt; j; i++) {
        bool flag = false;
        while (i &lt; j &amp;&amp; item[i].first + item[j].first &lt;= c) {
            flag = true;
            item[i].first += item[j].first;
            item[j].first = 0;
            res[mp[item[j].second]]++;
            j--;
        }
        if (flag) {
            item[i].first = 0;
            res[mp[item[i].second]]++;
            ans++;
        }
    }
    for (i = 0;  i &lt; item.size(); i++) {
        if (item[i].first != 0) {
            res[mp[item[i].second]]++;
            ans++;
        }
    }

    for (i = 0; i &lt; res.size(); i++) {
        cout &lt;&lt; mp1[i] &lt;&lt; " " &lt;&lt; res[i] &lt;&lt; endl;
    }
    cout &lt;&lt; ans &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="L2-3%20%E9%94%A6%E6%A0%87%E8%B5%9B">L2-3 锦标赛</h2> 
<p>有 2k 名选手将要参加一场锦标赛。锦标赛共有 k 轮，其中第 i 轮的比赛共有 2k−i 场，每场比赛恰有两名选手参加并从中产生一名胜者。每场比赛的安排如下：</p> 
<ul><li>对于第 1 轮的第 j 场比赛，由第 (2j−1) 名选手对抗第 2j 名选手。</li><li>对于第 i 轮的第 j 场比赛（i&gt;1），由第 (i−1) 轮第 (2j−1) 场比赛的胜者对抗第 (i−1) 轮第 2j 场比赛的胜者。</li></ul> 
<p>第 k 轮唯一一场比赛的胜者就是整个锦标赛的最终胜者。<br> 举个例子，假如共有 8 名选手参加锦标赛，则比赛的安排如下：</p> 
<ul><li>第 1 轮共 4 场比赛：选手 1 vs 选手 2，选手 3 vs 选手 4，选手 5 vs 选手 6，选手 7 vs 选手 8。</li><li>第 2 轮共 2 场比赛：第 1 轮第 1 场的胜者 vs 第 1 轮第 2 场的胜者，第 1 轮第 3 场的胜者 vs 第 1 轮第 4 场的胜者。</li><li>第 3 轮共 1 场比赛：第 2 轮第 1 场的胜者 vs 第 2 轮第 2 场的胜者。</li></ul> 
<p>已知每一名选手都有一个能力值，其中第 i 名选手的能力值为 ai​。在一场比赛中，若两名选手的能力值不同，则能力值较大的选手一定会打败能力值较小的选手；若两名选手的能力值相同，则两名选手都有可能成为胜者。</p> 
<p>令 li,j​ 表示第 i 轮第 j 场比赛 <strong>败者</strong> 的能力值，令 w 表示整个锦标赛最终胜者的能力值。给定所有满足 1≤i≤k 且 1≤j≤2k−i 的 li,j​ 以及 w，请还原出 a1​,a2​,⋯,an​。</p> 
<p><strong>输入格式：</strong></p> 
<p>第一行输入一个整数 k（1≤k≤18）表示锦标赛的轮数。<br> 对于接下来 k 行，第 i 行输入 2k−i 个整数 li,1​,li,2​,⋯,li,2k−i​（1≤li,j​≤109），其中 li,j​ 表示第 i 轮第 j 场比赛 <strong>败者</strong> 的能力值。<br> 接下来一行输入一个整数 w（1≤w≤109）表示锦标赛最终胜者的能力值。</p> 
<p><strong>输出格式：</strong></p> 
<p>输出一行 n 个由单个空格分隔的整数 a1​,a2​,⋯,an​，其中 ai​ 表示第 i 名选手的能力值。如果有多种合法答案，请输出任意一种。如果无法还原出能够满足输入数据的答案，输出一行 <code>No Solution</code>。<br> 请勿在行末输出多余空格。</p> 
<p><strong>输入样例1：</strong></p> 
<blockquote> 
 <p>3<br> 4 5 8 5<br> 7 6<br> 8<br> 9</p> 
</blockquote> 
<p><strong>输出样例1</strong>：</p> 
<blockquote> 
 <p>7 4 8 5 9 8 6 5</p> 
</blockquote> 
<p><strong>输入样例2：</strong></p> 
<blockquote> 
 <p>2<br> 5 8<br> 3<br> 9</p> 
</blockquote> 
<p><strong>输出样例2：</strong></p> 
<blockquote> 
 <p>No Solution</p> 
</blockquote> 
<p><strong>提示：</strong></p> 
<p>本题返回结果若为<strong>格式错误</strong>均可视为<strong>答案错误</strong>。</p> 
<h3 id="%EF%BC%88%E4%BB%A3%E7%A0%81%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89">（代码待补充）</h3> 
<h2 id="L2-4%20%E5%AF%BB%E5%AE%9D%E5%9B%BE%EF%BC%88BFS%EF%BC%89">L2-4 寻宝图（BFS+连通块）</h2> 
<p>给定一幅地图，其中有水域，有陆地。被水域完全环绕的陆地是岛屿。有些岛屿上埋藏有宝藏，这些有宝藏的点也被标记出来了。本题就请你统计一下，给定的地图上一共有多少岛屿，其中有多少是有宝藏的岛屿。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入第一行给出 2 个正整数 N 和 M（1&lt;N×M≤10^5），是地图的尺寸，表示地图由 N 行 M 列格子构成。随后 N 行，每行给出 M 位个位数，其中 <code>0</code> 表示水域，<code>1</code> 表示陆地，<code>2</code>-<code>9</code> 表示宝藏。<br> 注意：两个格子共享一条边时，才是“相邻”的。宝藏都埋在陆地上。默认地图外围全是水域。</p> 
<p><strong>输出格式：</strong></p> 
<p>在一行中输出 2 个整数，分别是岛屿的总数量和有宝藏的岛屿的数量。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>10 11<br> 01000000151<br> 11000000111<br> 00110000811<br> 00110100010<br> 00000000000<br> 00000111000<br> 00114111000<br> 00110010000<br> 00019000010<br> 00120000001</p> 
</blockquote> 
<p><strong>输出样例</strong>：</p> 
<blockquote> 
 <p>7 2</p> 
</blockquote> 
<p><strong>思路：</strong>迷宫问题板子题，具体板子详见，对迷宫依次进行遍历求连通块即可</p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/G_matinal/article/details/128666885?spm=1001.2014.3001.5501" title="迷宫问题(bfs广度优先搜索)【模板】_bfs迷宫模板_清晨喝碗粥的博客-CSDN博客">迷宫问题(bfs广度优先搜索)【模板】_bfs迷宫模板_清晨喝碗粥的博客-CSDN博客</a></p> 
</blockquote> 
<h3>AC代码：</h3> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;string&gt;G;
vector&lt;vector&lt;bool&gt;&gt;visit;
typedef struct {
    int x, y;
}point;
vector&lt;pair&lt;int, int&gt;&gt;dirs = {<!-- -->{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
int n, m;
bool bfs(int start_x, int start_y) {
    bool flag = false;
    visit[start_x][start_y] = true;
    point start;
    start.x = start_x;
    start.y = start_y;
    queue&lt;point&gt;Q;
    Q.push(start);
    while (!Q.empty()) {
        auto t = Q.front();
        int x = t.x, y = t.y;
        int new_x, new_y;
        for (auto &amp; dir : dirs) {
            new_x = x + dir.first;
            new_y = y + dir.second;
            if (new_x &gt;= 0 &amp;&amp; new_x &lt; n &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; m) {
                if (!visit[new_x][new_y] &amp;&amp; G[new_x][new_y] != '0') {
                    if (G[new_x][new_y] != '1') flag = true;
                    visit[new_x][new_y] = true;
                    point p;
                    p.x = new_x;
                    p.y = new_y;
                    Q.push(p);
                }
            }
        }
        Q.pop();
    }
    return flag;
}
int main()
{
    int i, j, k, count = 0, ans = 0;
    cin &gt;&gt; n &gt;&gt; m;
    G.resize(n, "");
    visit.resize(n, vector&lt;bool&gt;(m, false));
    for (i = 0; i &lt; n; i++) {
        cin &gt;&gt; G[i];
    }
    for (i = 0; i &lt; n; i++) {
        for (j = 0; j &lt; m; j++) {
            if (!visit[i][j] &amp;&amp; G[i][j] != '0') {
                bool flag1 = bfs(i, j);
                bool flag2 = G[i][j] == '1' ? false : true;
                if (flag1 || flag2) ans++;
                count++;
            }
        }
    }
    cout &lt;&lt; count &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="L3-1%20%E8%B6%85%E8%83%BD%E5%8A%9B%E8%80%85%E5%A4%A7%E8%B5%9B">L3-1 超能力者大赛</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/16/03/tTNMJyxe_o.jpg"></p> 
<p>知乎上有这样一个话题：“全世界范围内突然出现 666 个超能力者，击败对手就能获得对手的超能力，最终获胜者将如何自处？”</p> 
<p>现在让我们来将这个超能力者大赛的规则具体化：给定 N 位超能力者（超能力者从 0 到 N−1 编号，你的编号为 0），分布在全世界 M 座城市中（城市从 0 到 M−1 编号），比赛从第 1 天开始，到第 D 天结束。每位超能力者有一个能力值 Ei​（i=0,⋯,N−1）。</p> 
<p>如果你的能力值<strong>大于等于</strong>对手的能力值，就可以将其击败，并且对方的能力值立刻直接累加到你的能力值上。但是，当你每次到达一座城市，击败一位对手后，就会惊动这座城市中所有剩下的超能力者（包括联盟）。这座城市中剩下的所有个体能力值<strong>小于等于</strong>你的超能力者就会立刻团结起来形成联盟，联盟的能力值等于所有联盟成员能力值的总和。联盟将从此作为一个整体进攻或防御你，你可将联盟等价地理解为一个超能力者，它还可能在后续的战斗中继续与其它弱小的同城选手或联盟合并。第二天，这个城市中任何能力值<strong>大于</strong>你的对手就会找上门来，而你为了自保，就只能赶紧离开这个城市……</p> 
<p>此外，还有如下补充规定：</p> 
<ul><li>你每天只能进行 1 场战斗，击败一个超能力者（包括联盟），或者被一个能力值<strong>大于</strong>你的超能力者（包括联盟）击败。</li><li>比赛中间没有一天可以休息，你或者在战斗，或者在去往另一个城市的路上。</li><li>当你到达一个城市时，会在到达的第二天进行战斗。</li><li>当你结束战斗要离开这个城市时，是第二天开始出发。</li></ul> 
<p>下面我们为你设计一套贪心算法，就请你验证一下，这个算法能否让你得到这个大赛的冠军。算法步骤很简单：</p> 
<ul><li>第 1 步：从所有超能力者（包括联盟）中找出一个与自己能力值最接近、同时自己能够击败的对手，用最短时间去到对方的城市，在到达后第二天击败之；</li><li>第 2 步：如果该城市中没有能力值<strong>大于</strong>你的超能力者（包括联盟），按照规则逐一击败之；如果该城市中已经没有超能力者、或你第二天没有必胜把握，则回到第 1 步。</li></ul> 
<p>重复上述步骤，直到你：</p> 
<ul><li>击败了所有超能力者；或</li><li>你已经无路可逃（即剩下的所有超能力者的能力值都<strong>大于</strong>你）；或</li><li>比赛终止时间到。</li></ul> 
<p>第 1 步中有可能遇到多个符合条件的对手，并列情况下优先选最近的；距离也并列的情况下选途径城市最少的；再有并列就选城市编号最小的。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入在第一行中给出 4 个正整数：N（≤10^5），为参加比赛的超能力者人数；M（≤200），为比赛涉及的城市数量；Me​ 为城市间直达通路的数量；D（≤1000）为比赛时长（以“天”为单位）。<br> 随后 N 行，第 i 行（i=0,⋯,N−1）给出第 i 位参赛者的信息，格式为：</p> 
<blockquote> 
 <p>所在城市编号 能力值</p> 
</blockquote> 
<p>其中<code>能力值</code>是不超过 1000 的正整数。<br> 接下来是城市通路信息，分 Me​ 行，每行给出一对城市间的双向直接通路信息，格式为：</p> 
<blockquote> 
 <p>城市1 城市2 通行时间</p> 
</blockquote> 
<p>其中<code>通行时间</code>为不超过 D/2 的正整数，以“天”为单位。题目保证每条道路的信息只出现一次，没有重复。</p> 
<p><strong>输出格式：</strong></p> 
<p>顺次输出你每一步的活动，每个活动占一行，格式为：</p> 
<blockquote> 
 <p>Get e at city on day d.</p> 
</blockquote> 
<p>表示第 <code>d</code> 天在编号为 <code>city</code> 的城市击败了一个能力值为 <code>e</code> 的对手。</p> 
<blockquote> 
 <p>Move from city1 to city2.</p> 
</blockquote> 
<p>表示从编号为 <code>city1</code> 的城市<strong>到达</strong>了编号为 <code>city2</code> 的城市。</p> 
<blockquote> 
 <p>WIN on day d with e!</p> 
</blockquote> 
<p>表示在第 <code>d</code> 天成为唯一的赢家，此时你的能力值是 <code>e</code></p> 
<blockquote> 
 <p><code>Lose on day d with e.</code></p> 
</blockquote> 
<p>表示在第 <code>d</code> 天走投无路成为输家，此时你的能力值是 <code>e</code>。</p> 
<blockquote> 
 <p>Game over with e.</p> 
</blockquote> 
<p>表示比赛结束你没能成为唯一赢家，此时你的能力值是 <code>e</code>。注意：比赛最后一天是先判断输赢，才判断结束的。即：如果最后一天剩下所有人都比你厉害，是判你输，而不是 Game over。</p> 
<p><strong>输入样例1：</strong></p> 
<blockquote> 
 <p>17 8 14 40<br> 1 10<br> 2 22<br> 0 3<br> 5 18<br> 6 10<br> 1 5<br> 3 106<br> 7 18<br> 5 10<br> 0 27<br> 4 18<br> 7 10<br> 4 10<br> 0 5<br> 3 85<br> 4 8<br> 3 9<br> 5 6 1<br> 5 2 1<br> 5 0 5<br> 5 3 6<br> 6 2 8<br> 6 3 3<br> 6 0 2<br> 2 0 2<br> 2 3 1<br> 0 3 4<br> 1 0 1<br> 1 3 1<br> 1 4 3<br> 1 7 3</p> 
</blockquote> 
<p><strong>输出样例1</strong>：</p> 
<blockquote> 
 <p>Move from 1 to 4.<br> Get 10 at 4 on day 4.<br> Move from 4 to 7.<br> Get 18 at 7 on day 11.<br> Get 10 at 7 on day 12.<br> Move from 7 to 0.<br> Get 27 at 0 on day 17.<br> Get 8 at 0 on day 18.<br> Move from 0 to 4.<br> Get 26 at 4 on day 23.<br> Move from 4 to 3.<br> Get 106 at 3 on day 28.<br> Get 94 at 3 on day 29.<br> Move from 3 to 2.<br> Get 22 at 2 on day 31.<br> Move from 2 to 5.<br> Get 18 at 5 on day 33.<br> Get 10 at 5 on day 34.<br> Move from 5 to 6.<br> Get 10 at 6 on day 36.<br> Move from 6 to 1.<br> Get 5 at 1 on day 40.<br> WIN on day 40 with 374!</p> 
</blockquote> 
<p><strong>样例1说明：</strong></p> 
<p>样例 1 描述了这样的战斗场景：</p> 
<p style="text-align:center;"><img alt="" height="372" src="https://images2.imgbox.com/6c/f7/9UpruSlI_o.jpg" width="507"></p> 
<p>你作为 0 号选手，初始能力值为 10，位于 1 号城市。<br> 与你能力值最接近的有 4 位选手，能力值都是 10，分别位于 4、5、6、7 号城市。他们距离你都是 3 天，其中途径城市最少的是 4、7 号城市，并列时选城市编号小的，所以选 4 号城市。于是你的第一个动作是 <code>Move from 1 to 4.</code>，在第 3 天到达了 4 号城市。<br> 第 4 天你击败了 12 号选手，于是 <code>Get 10 at 4 on day 4.</code>，能力值增长为 20。此时 4 号城市中剩下的两人都打不过你，但他们组成能力值为 26 的联盟后，你就不行了，所以从第 5 天开始你要逃走。<br> 下一个目标是与你最接近的能力值为 18 的两个选手，分别在 5、7 号城市。距离相等时选择中途只经过一个城市的 7 号城市，于是 <code>Move from 4 to 7.</code>，在第 10 天到达 7 号城市。<br> 第 11 天你击败了 7 号选手，于是 <code>Get 18 at 7 on day 11.</code>，能力值增长为 38。此时该城市中剩下的 11 号选手打不过你，所以你在第 12 天击败这个人，<code>Get 10 at 7 on day 12.</code> 后能力值增长为 48。这时 7 号城市已经被你清空。<br> 下一个目标是 0 号城市能力值为 27 的 9 号选手。你在第 16 天到达，然后 <code>Get 27 at 0 on day 17.</code>，同时该城市中剩下的两人组成联盟，但能力值一共只有 8，于是在第二天的战斗中被你消灭，<code>Get 8 at 0 on day 18.</code>。至此 0 号城市也被你清空，你的能力值达到了 83。<br> 这时 4 号城市那个能力值为 26 的联盟成为你的下一个目标，你花了 4 天时间回到 4 号城市，<code>Get 26 at 4 on day 23.</code>，能力值涨到了 109。</p> 
<p>以此类推，可得到剩余的结果。最终在比赛的最后一天 —— 第 40 天将 1 号城市清空，赢得了比赛。</p> 
<p><strong>输入样例2：</strong></p> 
<blockquote> 
 <p>7 4 5 30<br> 2 10<br> 2 10<br> 1 9<br> 1 25<br> 1 25<br> 0 40<br> 3 30<br> 0 1 1<br> 1 2 2<br> 2 3 3<br> 3 0 2<br> 1 3 3</p> 
</blockquote> 
<p><strong>输出样例2：</strong></p> 
<blockquote> 
 <p>Get 10 at 2 on day 1.<br> Move from 2 to 1.<br> Get 9 at 1 on day 4.<br> Lose on day 5 with 29.</p> 
</blockquote> 
<p><strong>输入样例3：</strong></p> 
<blockquote> 
 <p>7 4 5 7<br> 2 20<br> 2 9<br> 1 9<br> 1 25<br> 1 25<br> 0 40<br> 3 30<br> 0 1 1<br> 1 2 2<br> 2 3 3<br> 3 0 2<br> 1 3 3</p> 
</blockquote> 
<p><strong>输出样例3：</strong></p> 
<blockquote> 
 <p>Get 9 at 2 on day 1.<br> Move from 2 to 1.<br> Get 25 at 1 on day 4.<br> Get 34 at 1 on day 5.<br> Move from 1 to 0.<br> Get 40 at 0 on day 7.<br> Game over with 128.</p> 
</blockquote> 
<h3>（代码待补充）</h3> 
<h2 id="L3-2%20%E5%AE%8C%E7%BE%8E%E6%A0%91">L3-2 完美树</h2> 
<p>给定一棵有 N 个结点的树（树中结点从 1 到 N 编号，根结点编号为 1）。每个结点有一种颜色，或为黑，或为白。</p> 
<p>称以结点 u 为根的子树是 <strong>好的</strong>，若子树中黑色结点与白色结点的数量之差的绝对值不超过 1。称整棵树是 <strong>完美树</strong>，若对于所有 1 ≤ i ≤ N，以结点 i 为根的子树都是好的。</p> 
<p>你需要将整棵树变成完美树，为此你可以进行以下操作任意次（包括零次）：选择任意一个结点 i (1 ≤ i ≤ N)，改变结点 i 的颜色（若结点 i 目前是黑色则将其改为白色，若结点 i 目前是白色则将其改为黑色）。这次操作的代价为 Pi​。</p> 
<p>求将给定的树变为完美树的最小代价。</p> 
<p>注：以结点 i 为根的子树，由结点 i 以及结点 i 的所有后代结点组成。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入第一行为一个数 N (1≤N≤105)，表示树的结点个数。</p> 
<p>接下来的 N 行，第 i 行的前三个数为 Ci​,Pi​,Ki​ (1≤Pi​≤104,0≤Ki​≤N)，分别表示树上编号为 i 的结点的初始颜色（0 为白色，1 为黑色）、变换颜色的代价及孩子结点的数量。紧跟着有 Ki​ 个数，为孩子结点的编号。数字均用一个空格隔开，所有的编号保证在 1 到 N 里，且不会有环。</p> 
<p>数据中只包含一棵树。</p> 
<p><strong>输出格式：</strong></p> 
<p>输出一行一个数，表示将树 T 变为完美树的最小代价。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>10<br> 1 100 3 2 3 4<br> 0 20 1 7<br> 0 5 2 5 6<br> 0 8 1 10<br> 0 7 0<br> 0 2 0<br> 1 1 2 8 9<br> 0 15 0<br> 0 13 0<br> 1 8 0</p> 
</blockquote> 
<p><strong>输出样例</strong>：</p> 
<blockquote> 
 <p>15</p> 
</blockquote> 
<p><strong>提示：</strong></p> 
<p>样例中最佳的方案是：将 9 号点和 6 号点从白色变为黑色，此时代价为 13 + 2 = 15。</p> 
<h3>（代码待补充）</h3> 
<h2 id="L3-3%20%E8%A1%80%E6%9F%93%E9%92%9F%E6%A5%BC">L3-3 血染钟楼</h2> 
<p>九条可怜最近非常沉迷血染钟楼 —— 一款类狼人杀的身份推理类的游戏。在一局血染钟楼的游戏中，玩家们之间隐藏着一名"恶魔"，而所有善良玩家的目标就是将抽到恶魔身份的玩家绳之以法。</p> 
<p>今天，九条可怜和她的小伙伴们开了一局 n+1 名玩家参与的游戏，可怜的编号是 0，其他玩家编号从 1 到 n。<br> 可怜抽到的身份是占卜师，其技能如下（注意这儿和标准钟楼规则有出入）：</p> 
<ol><li>每个夜晚，你可以选择任意名玩家，并得知被选择的玩家中是否有恶魔。</li><li>有一名除你以外善良玩家始终被你的能力视为恶魔。</li></ol> 
<p>换句话说，在剩下的 n 名玩家中，存在着两名未知的玩家，如果这两名玩家均未被可怜选中，可怜就会得到信息 0，否则就会得到信息 1。<br> 在抽到身份的时候，可怜就对游戏开始的前 m 个夜晚进行了规划：她打算在第 i 个夜晚选中编号在区间 [li​,ri​] 内的所有玩家。<br> 因为血染钟楼的第一个夜晚通常比较漫长，所以可怜在百无聊赖之际开始了头脑风暴。如果一切顺利，在 m 晚之后，她将能得到 m 个 0 或 1 的信息，共有 2m 种不同的可能性。可怜想要知道在这些可能性中，有多少种结果是可能发生的且可以让她<strong>唯一</strong>确定被她技能识别的两名玩家。</p> 
<p><strong>输入格式：</strong></p> 
<p>第一行输入一个整数 t(1≤t≤10^3)，表示数据组数。<br> 第二行输入两个整数 n,m(1≤n,m≤10^5)，表示可怜以外的玩家数量以及可怜规划的夜晚数量。<br> 接下来 m 行每行两个整数 li​,ri​(1≤li​≤ri​≤n)，表示可怜的计划中在第 i 晚会被选中的玩家编号区间。<br> 输入保证所有数据中满足 n&gt;10^3 或 m&gt;10^3 的数据不超过 5 组。</p> 
<p><strong>输出格式：</strong></p> 
<p>对于每组数据，输出一行一个整数，表示满足条件的可能性数量。答案可能很大，你只需要输出对 998244353 取模后的结果。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>3<br> 4 1<br> 2 3<br> 5 4<br> 2 5<br> 1 3<br> 5 5<br> 2 4<br> 10 10<br> 1 2<br> 6 6<br> 3 7<br> 3 6<br> 1 8<br> 9 10<br> 1 6<br> 4 4<br> 8 8<br> 5 8</p> 
</blockquote> 
<p><strong>输出样例</strong>：</p> 
<blockquote> 
 <p>1<br> 2<br> 7</p> 
</blockquote> 
<p><strong>样例解释：</strong></p> 
<p>在第一组数据中，可怜得到的信息共有两种可能性：</p> 
<ol><li>得到的信息为 0，表明两名目标的玩家均不在区间 [2,3] 中，因此可以唯一确定他们的编号为 (1,4)。</li><li>得到的信息为 1，表明至少有一名目标的玩家在区间 [2,3] 中，此时共有四种可能性 (1,2),(1,3),(2,4),(3,4)，因此不能唯一确定。<br> 在第二组数据中，满足要求的两种可能性如下所示：</li><li>四天得到的信息依次为 1110，此时目标玩家的编号一定为 (1,5)。</li><li>四天得到的信息依次为 1011，此时目标玩家的编号一定为 (4,5)。<br> 容易验证其他 14 种可能性均不满足条件。</li></ol> 
<h3>（代码待补充）</h3> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94990adf983343fd5dad008df1ff707b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CentOS7.9镜像</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f94bdf10818e7d475169b6134f7efe5b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Git Stash 命令详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>