<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Lambda表达式、函数式接口、方法引用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Lambda表达式、函数式接口、方法引用" />
<meta property="og:description" content="什么是Lambda表达式 lambda表达式是JAVA8中提供的一种新的特性，它支持JAVA也能进行简单的“函数式编程”。
它是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。
Lambda 表达式是实现函数式接口的一种方式，可以看做匿名内部类的简写形式：它没有名称，但它有参数列表，函数主体，返回类型，可能还有一个可以抛出的异常列表。
Lambda 是一个匿名函数，可以把 Lambda表达式 理解为是一段可以传递的代码 (将代码像数据一样进行传递)。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升 ，JDK 也提供了大量的内置函数式接口供我们使用，使得 Lambda 表达式的运用更加方便、高效。
什么是函数式接口 定义：接口中只有一个抽象方法的接口。
函数式接口一般使用 @FunctionalInterface 注解修饰，目的是检查接口是否符合函数式接口规范。
注意点：
函数式接口中可以有 默认方法 和静态方法函数式接口重写父类的方法，并不会计入到自己的抽象方法中 函数式接口Runnable java.lang.Runnable 就是一种函数式接口，在 Runnable 接口中只声明了一个方法 void run()，我们使用匿名内部类来实例化函数式接口的对象，有了 Lambda 表达式，这一方式可以得到简化。
每个 Lambda 表达式都能隐式地赋值给函数式接口，例如，我们可以通过 Lambda 表达式创建 Runnable 接口的引用。
Runnable r = () -&gt; System.out.println(&#34;hello world&#34;); 当不指明函数式接口时，编译器会自动解释这种转化：
new Thread( () -&gt; System.out.println(&#34;hello world&#34;) ).start(); 因此，在上面的代码中，编译器会自动推断：根据线程类的构造函数签名 public Thread(Runnable r) { }，将该 Lambda 表达式赋给 Runnable 接口。
4类常用函数式接口 Consumer 消费型接口：接受一个参数并进行逻辑操作，无返回值；Supplier 供给型接口：不接受参数，操作后返回一个对象；Function&lt;T, R&gt; 函数型接口：接收一个泛型T对象，操作后返回泛型R对象；Predicate 断言型接口：接收一个参数，操作后返回一个 boolean 值； Consumer 接口定义：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/09c97cc2c4a4e6ffee550a7e0856c5c4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-20T16:34:14+08:00" />
<meta property="article:modified_time" content="2022-03-20T16:34:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Lambda表达式、函数式接口、方法引用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Lambda_0"></a>什么是Lambda表达式</h2> 
<ul><li> <p><code>lambda</code>表达式是<code>JAVA8</code>中提供的一种新的特性，它支持<code>JAVA</code>也能进行简单的<code>“函数式编程”</code>。</p> </li><li> <p>它是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。</p> </li><li> <p>Lambda 表达式是实现函数式接口的一种方式，可以看做匿名内部类的简写形式：它没有名称，但它有参数列表，函数主体，返回类型，可能还有一个可以抛出的异常列表。</p> </li><li> <p>Lambda 是一个匿名函数，可以把 Lambda表达式 理解为是一段可以传递的代码 (将代码像数据一样进行传递)。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升 ，JDK 也提供了大量的内置函数式接口供我们使用，使得 Lambda 表达式的运用更加方便、高效。</p> </li></ul> 
<h2><a id="_10"></a>什么是函数式接口</h2> 
<p>定义：接口中只有一个抽象方法的接口。</p> 
<p>函数式接口一般使用 <code>@FunctionalInterface</code> 注解修饰，目的是检查接口是否符合函数式接口规范。</p> 
<p>注意点：</p> 
<ul><li>函数式接口中可以有 默认方法 和静态方法</li><li>函数式接口重写父类的方法，并不会计入到自己的抽象方法中</li></ul> 
<h3><a id="Runnable_21"></a>函数式接口Runnable</h3> 
<p><code>java.lang.Runnable</code> 就是一种函数式接口，在 Runnable 接口中只声明了一个方法 <code>void run()</code>，我们使用匿名内部类来实例化函数式接口的对象，有了 Lambda 表达式，这一方式可以得到简化。</p> 
<p>每个 Lambda 表达式都能隐式地赋值给函数式接口，例如，我们可以通过 Lambda 表达式创建 Runnable 接口的引用。</p> 
<pre><code class="prism language-java">Runnable r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>当不指明函数式接口时，编译器会自动解释这种转化：</p> 
<pre><code class="prism language-java"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>
   <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>因此，在上面的代码中，编译器会自动推断：根据线程类的构造函数签名 <code>public Thread(Runnable r) { }</code>，将该 Lambda 表达式赋给 Runnable 接口。</p> 
<h3><a id="4_41"></a>4类常用函数式接口</h3> 
<ul><li>Consumer 消费型接口：接受一个参数并进行逻辑操作，无返回值；</li><li>Supplier 供给型接口：不接受参数，操作后返回一个对象；</li><li>Function&lt;T, R&gt; 函数型接口：接收一个泛型T对象，操作后返回泛型R对象；</li><li>Predicate 断言型接口：接收一个参数，操作后返回一个 boolean 值；</li></ul> 
<h2><a id="Consumer_48"></a>Consumer</h2> 
<p>接口定义：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">/**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */</span>
    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>消费型接口：接收一个参数进行处理，不返回结果。</p> 
<h2><a id="Supplier_67"></a>Supplier</h2> 
<p>接口定义：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Supplier</span><span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">/**
     * Gets a result.
     *
     * @return a result
     */</span>
    T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>供给型接口：不接受参数，返回一个泛型类型的对象；</p> 
<p>如何使用：使用时提供该接口的实现，并返回一个泛型类型的对象；</p> 
<h2><a id="Function_92"></a>Function</h2> 
<p>接口定义：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Function</span><span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">,</span> R<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">/**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */</span>
    R <span class="token function">apply</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>函数型接口：提供一个 T 类型的参数，返回一个 R 类型的结果。</p> 
<h2><a id="Predicate_112"></a>Predicate</h2> 
<p>接口定义：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Predicate</span><span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">/**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return {@code true} if the input argument matches the predicate,
     * otherwise {@code false}
     */</span>
    <span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>断言型接口：输入一个 T 类型的参数，返回 boolean 类型的结果。</p> 
<h2><a id="_133"></a>方法引用</h2> 
<p>方法引用是进一步简化 Lambda 表达式的写法。</p> 
<p>方法引用的格式：<code>类型或者对象 :: 引用的方法</code></p> 
<p>方法引用的四种形式：</p> 
<ol><li>静态方法的引用；</li><li>实例方法的引用；</li><li>特定类型方法的引用；</li><li>构造器引用；</li></ol> 
<h3><a id="_146"></a>静态方法的引用</h3> 
<p>格式： <code>类名 :: 静态方法名</code></p> 
<p>这里以 List Integer 转 String 为例：</p> 
<pre><code class="prism language-java">List<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//                  list.stream().map(s -&gt; String.valueOf(s));</span>
List<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> strs <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>注意点：前后参数一致的静态方法。</p> 
<h3><a id="_165"></a>实例方法的引用</h3> 
<p>格式：<code>实例对象 :: 方法名</code></p> 
<p>这里以 System.out 对象的实例方法 println(String x) 为例：</p> 
<pre><code class="prism language-java">List<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// lists.forEach(s -&gt; System.out.println(s));</span>
list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>注意点：前后参数一致。</p> 
<h3><a id="_184"></a>特定类型的方法引用</h3> 
<p>要点：参数列表中形参中的第一个参数作为了要调用方法的调用者，并且其余参数作为后面方法的实参，那么就可以用特定类型方法引用了。</p> 
<pre><code class="prism language-java">String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token string">"James"</span><span class="token punctuation">,</span> <span class="token string">"AA"</span><span class="token punctuation">,</span> <span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token string">"Patricia"</span><span class="token punctuation">,</span> <span class="token string">"Dlei"</span><span class="token punctuation">,</span> <span class="token string">"Robert"</span><span class="token punctuation">,</span> <span class="token string">"Boom"</span><span class="token punctuation">,</span>  <span class="token string">"Cao"</span><span class="token punctuation">,</span> <span class="token string">"black"</span><span class="token punctuation">,</span> <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token string">"Linda"</span><span class="token punctuation">,</span> <span class="token string">"cao"</span><span class="token punctuation">,</span> <span class="token string">"after"</span><span class="token punctuation">,</span> <span class="token string">"sBBB"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 按照元素的首字符(忽略大小写)升序排序</span>
Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span>  s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>  s1<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 特定类型的方法引用</span>
Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">,</span>  String<span class="token operator">:</span><span class="token operator">:</span>compareToIgnoreCase<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>当一个对象调用一个方法，方法的<code>参数</code>中包含一个<code>函数式接口</code>，该函数式接口的<code>第一个参数类型</code>是<code>这个对象的类</code>，那么这个<code>函数式接口</code>可用<code>方法引用代替</code>，并且替换用的方法可以不包含函数式接口的第一个参数（调用对象的类）。</p> 
<h3><a id="_202"></a>构造器引用</h3> 
<pre><code class="prism language-java">s <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> Student<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span>
</code></pre> 
<p>创建对象时，前后参数一致。</p> 
<h2><a id="_212"></a>总结</h2> 
<p>Lambda表达式是为了简化实现函数式接口的</p> 
<p>如果没有Lambda表达式，需要使用匿名内部类实现</p> 
<pre><code class="prism language-java">Consumer<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> s1<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>如果使用Lambda表达式</p> 
<pre><code class="prism language-java">Consumer<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> s1<span class="token operator">=</span> s2 <span class="token operator">-</span><span class="token operator">&gt;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>既然Lambda表达式是一种实现方式，那<code>函数式接口</code>是啥呢，顾名思义<code>接口</code>用来定义<code>行为</code>，（多说一句，类是抽象属性和行为，即抽象类别的，比如人，飞机等不同类别，接口是抽象行为的，即飞机会飞，人要内卷，飞和内卷都是行为的一种），函数式接口即一个接口只有一个抽象方法的接口，default与static的不算，然后加上注解<code>@FunctionalInterface</code>。</p> 
<p><code>函数式接口</code>就是<code>一类行为定义</code>，<code>Lambda表达式</code>就是简化实现这类行为的<code>表达式</code>。等于是有函数式接口才有Lambda表达式，单独成立都没有意义。Lambda表达式本质是一个语法糖，内部还是内部类，只是编译器给我们做了处理。</p> 
<p>最后我们总结下什么是<code>方法引用</code>。</p> 
<p><code>方法引用</code>其实是Lambda表达式的更简约写法,Lambda表达式需要实现函数式接口（即写方法实现），方法引用则是<code>直接使用</code>已经<code>存在</code>的<code>符合函数式接口定义</code>的<code>方法</code>。</p> 
<p>比如我们要实现一个int转String。</p> 
<p>如果没有方法引用</p> 
<pre><code class="prism language-java">Function<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">,</span>String<span class="token punctuation">&gt;</span></span> function<span class="token operator">=</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> number<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>实际上String.valueOf()已经实现了我们要的转换方法，且符合Function的定义，即有一个参数输入，一个参数输出。则我们可以直接使用该方法。</p> 
<pre><code class="prism language-java">Function<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">,</span>String<span class="token punctuation">&gt;</span></span> function<span class="token operator">=</span>String<span class="token operator">:</span><span class="token operator">:</span>valueOf<span class="token punctuation">;</span>
</code></pre> 
<p>这样极大的简化了我们的代码实现。</p> 
<p>再来一个简单例子。</p> 
<pre><code class="prism language-java">Consumer<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> s1<span class="token operator">=</span> s2 <span class="token operator">-</span><span class="token operator">&gt;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们定义了一个传入打印，Lambda写法如上。我们可以使用更简约的写法</p> 
<pre><code class="prism language-java">Consumer<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> s1<span class="token operator">=</span> System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">;</span>
</code></pre> 
<p>只要符合我们的函数式接口的方法定义，即是否有返回和参数个数。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
   
    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">default</span> Consumer<span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> <span class="token function">andThen</span><span class="token punctuation">(</span>Consumer<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">&gt;</span> after<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>after<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span> <span class="token function">accept</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> after<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如上，我们使用这个接口的时候，必须传入一个跟他定义一致的方法，都是没有返回，然后有一个参数传入。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b5cdeafe941f0989d83d0940fcedad2e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络编程(详)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a80ef466e098bacdda5f937433e47a0a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pinctrl子系统和gpio子系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>