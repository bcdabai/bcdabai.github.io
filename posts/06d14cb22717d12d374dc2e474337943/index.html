<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TVM的“hello world“基础流程 II - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TVM的“hello world“基础流程 II" />
<meta property="og:description" content="上一篇《TVM的“hello world“基础流程 I》中基于一个最基本的case介绍了TVM中计算的定义与schedule的构建。这篇沿用上一篇中的case，继续介绍接下去的一个重点部分，就是编译。
有了前面构建的schedule之后，接着就需要编译并生成目标代码了。这个工作主要由tvm.build()和relay.build()两个函数来完成。它们的区别在于应用目标的范围，前者用于单个算子，后者用于整个网络。由于网络可看作由算子组成，后者会调用前者。本例中是针对单个算子的，因此这里使用的是前者：
tgt = tvm.target.Target(target=&#34;llvm&#34;, host=&#34;llvm&#34;) fadd = tvm.build(s, [A, B, C], tgt, name=&#34;vecadd&#34;) 其中最主要的build()函数定义在driver/build_module.py文件中。该函数基于给定参数构建出可调用的目标函数。按照官方介绍里的说法，它主要做两个工作 ：
Lowering：将high-level的循环嵌套结构转换成最终的low-level的IR。Codegen：从low-level的IR生成目标机器代码。 该函数的第一个参数是前面构建出来的schedule，第二个参数是函数的参数列表，第三个参数是target。它提供用于lowering和codegen所需的目标平台信息。代码中对应的Target对象定义在target.*文件中。其构造函数有两个参数，其中第一个参数target指示目标平台的配置。其中的配置项比如：
kind: 平台类型，它基本决定了生成的代码是在什么处理器上运行。注册的target kind详细见target_kind.cc，有llvm, c, cuda, nvptx, romc, opencl, metal, vulkan, hexagon等。keys: 如kind是opencl的话，key可以是mali, opencl, gpu。device：对应实际运行的设备，它会添加到keys后面。libs：外部库，如cblas, cudnn, cublas, mkl这些。… 另外参数host与target类似，但它用于指示host平台。比如taret平台为cuda的话，毕竟GPU还是不能完全脱离CPU运行，因此还需要host的代码做胶水，如内存分配，kernel启动这些。默认为llvm。
Lowering过程可以单独用tvm.lower()函数完成，如：
m = tvm.lower(s, [A, B, C], name=&#34;vecadd&#34;) rt_mod = tvm.build(m, target=&#34;llvm&#34;) 也可以通过tvm.build()函数完成（因为它一进去就会先调用lower()函数）。lower()函数的主要流程相关代码：
lower(sch, args, name=&#34;main&#34;, ...) // driver/build_module.py // Handle add_lower_pass, if any. lower_phases0 = ... ... // According to the given schedule, form a function (in IRModule)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/06d14cb22717d12d374dc2e474337943/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-22T08:12:20+08:00" />
<meta property="article:modified_time" content="2021-08-22T08:12:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TVM的“hello world“基础流程 II</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>上一篇<a href="https://jinzhuojun.blog.csdn.net/article/details/117135551" rel="nofollow">《TVM的“hello world“基础流程 I》</a>中基于一个最基本的case介绍了TVM中计算的定义与schedule的构建。这篇沿用上一篇中的case，继续介绍接下去的一个重点部分，就是编译。</p> 
<p>有了前面构建的schedule之后，接着就需要编译并生成目标代码了。这个工作主要由<code>tvm.build()</code>和<code>relay.build()</code>两个函数来完成。它们的区别在于应用目标的范围，前者用于单个算子，后者用于整个网络。由于网络可看作由算子组成，后者会调用前者。本例中是针对单个算子的，因此这里使用的是前者：</p> 
<pre><code class="prism language-python">tgt <span class="token operator">=</span> tvm<span class="token punctuation">.</span>target<span class="token punctuation">.</span>Target<span class="token punctuation">(</span>target<span class="token operator">=</span><span class="token string">"llvm"</span><span class="token punctuation">,</span> host<span class="token operator">=</span><span class="token string">"llvm"</span><span class="token punctuation">)</span>
fadd <span class="token operator">=</span> tvm<span class="token punctuation">.</span>build<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token punctuation">[</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">]</span><span class="token punctuation">,</span> tgt<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"vecadd"</span><span class="token punctuation">)</span>
</code></pre> 
<p>其中最主要的<code>build()</code>函数定义在<code>driver/build_module.py</code>文件中。该函数基于给定参数构建出可调用的目标函数。按照官方介绍里的说法，它主要做两个工作 ：</p> 
<ul><li><strong>Lowering</strong>：将high-level的循环嵌套结构转换成最终的low-level的IR。</li><li><strong>Codegen</strong>：从low-level的IR生成目标机器代码。</li></ul> 
<p>该函数的第一个参数是前面构建出来的schedule，第二个参数是函数的参数列表，第三个参数是target。它提供用于lowering和codegen所需的目标平台信息。代码中对应的<code>Target</code>对象定义在<code>target.*</code>文件中。其构造函数有两个参数，其中第一个参数target指示目标平台的配置。其中的配置项比如：</p> 
<ul><li><strong>kind</strong>: 平台类型，它基本决定了生成的代码是在什么处理器上运行。注册的target kind详细见<code>target_kind.cc</code>，有llvm, c, cuda, nvptx, romc, opencl, metal, vulkan, hexagon等。</li><li><strong>keys</strong>: 如kind是opencl的话，key可以是mali, opencl, gpu。</li><li><strong>device</strong>：对应实际运行的设备，它会添加到keys后面。</li><li><strong>libs</strong>：外部库，如cblas, cudnn, cublas, mkl这些。</li><li>…</li></ul> 
<p>另外参数host与target类似，但它用于指示host平台。比如taret平台为cuda的话，毕竟GPU还是不能完全脱离CPU运行，因此还需要host的代码做胶水，如内存分配，kernel启动这些。默认为llvm。</p> 
<p>Lowering过程可以单独用<code>tvm.lower()</code>函数完成，如：</p> 
<pre><code class="prism language-python">m <span class="token operator">=</span> tvm<span class="token punctuation">.</span>lower<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token punctuation">[</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">]</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"vecadd"</span><span class="token punctuation">)</span>
rt_mod <span class="token operator">=</span> tvm<span class="token punctuation">.</span>build<span class="token punctuation">(</span>m<span class="token punctuation">,</span> target<span class="token operator">=</span><span class="token string">"llvm"</span><span class="token punctuation">)</span>
</code></pre> 
<p>也可以通过<code>tvm.build()</code>函数完成（因为它一进去就会先调用<code>lower()</code>函数）。<code>lower()</code>函数的主要流程相关代码：</p> 
<pre><code class="prism language-cpp"><span class="token function">lower</span><span class="token punctuation">(</span>sch<span class="token punctuation">,</span> args<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"main"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">// driver/build_module.py</span>
    <span class="token comment">// Handle add_lower_pass, if any.</span>
    lower_phases0 <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// According to the given schedule, form a function (in IRModule).</span>
    mod <span class="token operator">=</span> <span class="token function">form_irmodule</span><span class="token punctuation">(</span>sch<span class="token punctuation">,</span> args<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">// build_module.py</span>
        sch<span class="token punctuation">.</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token class-name">Schedule</span><span class="token operator">::</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// schedule_dataflow_rewrite.cc</span>
                <span class="token function">InjectInline</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token function">RebaseNonZeroMinLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token function">LegalizeInvalidAttach</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        bounds <span class="token operator">=</span> schedule<span class="token punctuation">.</span><span class="token function">InferBound</span><span class="token punctuation">(</span>sch<span class="token punctuation">)</span>  
            <span class="token function">InferBound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// bound.cc</span>
        stmt <span class="token operator">=</span> schedule<span class="token punctuation">.</span><span class="token function">ScheduleOps</span><span class="token punctuation">(</span>sch<span class="token punctuation">,</span> bounds<span class="token punctuation">)</span>
            <span class="token function">ScheduleOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// schedule_ops.cc</span>
                body <span class="token operator">=</span> <span class="token function">Stmt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">// scan init and scan updates</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                <span class="token keyword">for</span> each stage in schedule<span class="token operator">:</span> <span class="token comment">// in reverse order</span>
                    body <span class="token operator">=</span> <span class="token function">MakePipeline</span><span class="token punctuation">(</span>stage<span class="token punctuation">,</span> dom_map<span class="token punctuation">,</span> body<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
                SchedulePostProc post_proc
                post_proc<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span>sch<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token function">post_proc</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span>
        compact <span class="token operator">=</span> schedule<span class="token punctuation">.</span><span class="token function">VerifyCompactBuffer</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span>
        binds<span class="token punctuation">,</span> arg_list <span class="token operator">=</span> <span class="token function">get_binds</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> compact<span class="token punctuation">,</span> binds<span class="token punctuation">)</span>
        stmt <span class="token operator">=</span> schedule<span class="token punctuation">.</span><span class="token function">SchedulePostProcRewriteForTensorCore</span><span class="token punctuation">(</span>stmt<span class="token punctuation">,</span> sch<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
        <span class="token comment">// func type: PrimFunc</span>
        func <span class="token operator">=</span> schedule<span class="token punctuation">.</span><span class="token function">SchedulePostProcToPrimFunc</span><span class="token punctuation">(</span>arg_list<span class="token punctuation">,</span> stmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">// schedule_postproc_to_primfunc.cc</span>
            <span class="token comment">// Prepare parameters</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">return</span> tie<span class="token operator">::</span><span class="token function">PrimFunc</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> body<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
        <span class="token comment">// name: vecadd</span>
        func <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">with_attr</span><span class="token punctuation">(</span><span class="token string">"global_symbol"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
        <span class="token comment">// Set functions</span>
        <span class="token keyword">return</span> tvm<span class="token punctuation">.</span><span class="token function">IRModule</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>name<span class="token operator">:</span> func<span class="token punctuation">}</span><span class="token punctuation">)</span>
        
    <span class="token comment">// Phase 0: InjectPrefetch, StorageFlatten, BF16Legalize, NarrowDataType, Simplify</span>
    pass_list <span class="token operator">=</span> lower_phase0
    
    <span class="token comment">// Phase 1: LoopPartition, VectorizeLoop, InjectVirtualThread, InjectDoubleBuffer, StorageRewrite, UnrollLoop</span>
    pass_list <span class="token operator">+=</span> lower_phase1
    
    <span class="token comment">// Phase 3: Simplify, RemoveNoOp, RewriteUnsafeSelect, HoistIfThenElse</span>
    pass_list <span class="token operator">+=</span> lower_phase2
    
    <span class="token comment">// Apply the above passes.</span>
    optimize <span class="token operator">=</span> tvm<span class="token punctuation">.</span>transform<span class="token punctuation">.</span><span class="token function">Sequential</span><span class="token punctuation">(</span>pass_list<span class="token punctuation">)</span>
    mod <span class="token operator">=</span> <span class="token function">optimize</span><span class="token punctuation">(</span>mod<span class="token punctuation">)</span> 
    
    <span class="token comment">// mod type: tvm.ir.module.IRModule</span>
    <span class="token keyword">return</span> mod 
</code></pre> 
<p>它主要根据参数给的schedule与参数生成对应的<code>IRModule</code>对象（定义在<code>ir/module.h</code>中）。<code>IRModule</code>是软件栈中所有IR变换的基础单元。它维护函数与类型定义。这里的各种pass就是在<code>IRModule</code>上进行并吐出<code>IRModule</code>。</p> 
<p><img src="https://images2.imgbox.com/dc/79/OiM7tseE_o.png" alt="在这里插入图片描述"></p> 
<p>其中几个主要数据结构关系如下：<br> <img src="https://images2.imgbox.com/82/11/wgwrpVX4_o.png" alt="在这里插入图片描述"></p> 
<p><code>lower()</code>函数中有四个阶段，第一个阶段中通过<code>form_irmodule()</code>函数根据给定的schedule生成<code>IRModule</code>对象，然后在这个<code>IRModule</code>对象上应用4轮的pass。这些pass主要分为几个阶段，分别是：</p> 
<ul><li><strong>Phase 0</strong>：使用者自定义的pass。</li><li><strong>Phase 1</strong>：使用者自定义的pass。以及： 
  <ul><li>InjectPrefetch</li><li>StorageFlatten</li><li>BF16Legalize</li><li>NarrowDataType</li><li>Simplify</li></ul> </li><li><strong>Phase 2</strong>：使用者自定义的pass。以及： 
  <ul><li>LoopPartition</li><li>VectorizeLoop</li><li>InjectVirtualThread</li><li>InjectDoubleBuffer</li><li>StorageRewrite</li><li>UnrollLoop</li></ul> </li><li><strong>Phase 3</strong>：使用者自定义的pass。以及： 
  <ul><li>Simplify</li><li>RemoveNoOp</li><li>RewriteUnsafeSelect</li><li>HoistIfThenElse</li><li>InstrumentBoundCheckers</li></ul> </li></ul> 
<p>这此pass其实是编译构建过程中的精华之一。但限于篇幅（其实是我自己也没了解全。。。），以后再进一步讨论。</p> 
<p><code>lower()</code>函数的最后返回经过上面多轮pass优化后的<code>IRModule</code>对象。其中<code>form_irmodule()</code>函数是相对比较复杂的一部分，它主要负责生成最初的<code>IRModule</code>对象，其中几个关键步骤如下：</p> 
<ol><li><code>Schedule::normalize()</code>函数规范化给定的schedule。主要实现在<code>schedule_dataflow_rewrite.cc</code>文件中。它调用以下三个函数。本例比较简单，因此它们实际都没有起什么作用。。。 
  <ol><li><code>InjectInline()</code>函数处理算子内联。用到调度原语 <code>compute_inline</code>的话会用到。</li><li><code>RebaseNonZeroMinLoop()</code>函数将循环迭代的最小界置为0。感觉有点canonicalization的意思。</li><li><code>LegalizeInvalidAttach()</code>函数处理在使用调度原语<code>compute_at</code>时且目标迭代又被split或fuse情况下的合法化。</li></ol> </li><li><code>InferBound()</code>函数顾名思义就是边界推导（Bound inference），主要用于推导循环边界。更具体地，就是确定每个<code>IterVar</code>的范围，它返回<code>IterVar</code>到<code>Range</code>的映射，即每个循环变量的范围。这个信息在后面的<code>MakeLoopNest()</code>函数中用于确定for循环的范围，和在<code>BuildRealize()</code>函数中设置缓冲的大小。具体可参见官方文档 <a href="https://tvm.apache.org/docs/dev/inferbound.html" rel="nofollow">InferBound Pass</a>。</li><li><code>ScheduleOps()</code>函数基于前面经过一些处理后的<code>Schedule</code>对象和推导出来的循环边界产生<code>Stmt</code>对象。它表示一个初始的循环嵌套结构。C++层中的<code>Stmt</code>为所有语句（Statement）的容器。它的子类有<code>LetStmt</code>，<code>AttrStmt</code>，<code>AssertStmt</code>，<code>Store</code>，<code>Allocate</code>，<code>SeqStmt</code>，<code>IfThenElse</code>，<code>Evaluate</code>，<code>For</code>，<code>While</code>等等。该函数会处理schedule的依赖，核心部分是逆向遍历<code>Schedule</code>当中的<code>Stage</code>（对于上面例子中就是先Compute Op，再两个Placeholder Op）。对于每个stage（<code>PlaceholderOp</code>除外），根据其attach type调用相应的逻辑。 
  <ol><li>对于上面的例子，Compute Op没有attach在其它计算中，因此它对应Stage的attach type为<code>kGroupRoot</code>，因此这里调用<code>MakePipeline()</code>函数产生<code>Stmt</code>。这步比较关键比较复杂，后面再展开。</li><li>然后通过<code>SchedulePostProc</code>对象（继承自<code>StmtExprMutator</code>）对前面生成的<code>Stmt</code>进行后处理。</li></ol> </li><li><code>get_binds()</code>函数用于绑定buffer。它给每个参数张量分配buffer。如对于上面例子中的A, B, C三个张量，分别通过<code>tvm.tir.decl_buffer()</code>创建buffer并将之与张量绑定。</li><li><code>SchedulePostProcToPrimFunc()</code>函数基于<code>ScheduleOps()</code>产生的<code>Stmt</code>创建<code>PrimFunc</code>对象，它可以被用于TIR优化。<code>PrimFunc</code>代表包含了TIR statement的primitive function，它是low-level的代码表示。</li><li>创建<code>IRModule</code>对象。基于上面生成的对象封装成<code>IRModule</code>对象并返回。一个<code>IRModule</code>可以有多个函数，比较简单的情况下就一个。</li></ol> 
<p>上面第<code>ScheduleOps()</code>函数中会调用<code>MakePipeline()</code>函数针对ComputeOp对应Stage，返回一条由<code>Stmt</code>组成的pipeline，其大体流程相关代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token function">MakePipeline</span><span class="token punctuation">(</span>Stage<span class="token punctuation">,</span> unordered_map<span class="token operator">&lt;</span>IterVar<span class="token punctuation">,</span> Range<span class="token operator">&gt;</span><span class="token punctuation">,</span> Stmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">// schedule_ops.cc</span>
    producer <span class="token operator">=</span> s<span class="token operator">-&gt;</span>op<span class="token operator">-&gt;</span><span class="token function">BuildProvide</span><span class="token punctuation">(</span>stage<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">// ComputeOpNode::BuildProvide() in compute_op.cc</span>
        ComputeType ctype <span class="token operator">=</span> <span class="token function">DetectComputeType</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stage<span class="token punctuation">)</span>
        <span class="token function">MakeComputeStmt</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">// compute_op.cc</span>
            ComputeLoopNest n <span class="token operator">=</span> <span class="token class-name">ComputeLoopNest</span><span class="token operator">::</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">// compute_op.cc</span>
                ComputeLoopNest ret
                <span class="token comment">// make main loop nest</span>
                ret<span class="token punctuation">.</span>main_nest <span class="token operator">=</span> <span class="token function">MakeLoopNest</span><span class="token punctuation">(</span>stage<span class="token punctuation">,</span> dom_map<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">// op_utils.cc</span>
                    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>Stmt<span class="token operator">&gt;&gt;</span> nest
                    nest<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>leaf_iter_vars<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
                    <span class="token keyword">for</span> iter_var in leaf_iter_vars<span class="token operator">:</span>
                        nest<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">For</span><span class="token punctuation">(</span>var<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> dom<span class="token operator">-&gt;</span>extent<span class="token punctuation">,</span> kind<span class="token punctuation">,</span> no_op<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        nest<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">AttrStmt</span><span class="token punctuation">(</span>iv<span class="token punctuation">,</span> tir<span class="token operator">::</span>attr<span class="token operator">::</span>loop_scope<span class="token punctuation">,</span> iv<span class="token operator">-&gt;</span>var<span class="token punctuation">,</span> no_op<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            n<span class="token punctuation">.</span>init_nest<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">MakeIfNest</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>init_predicates<span class="token punctuation">)</span><span class="token punctuation">)</span>
            n<span class="token punctuation">.</span>main_nest<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">MakeIfNest</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>main_predicates<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> has reduce_axis<span class="token operator">:</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">else</span><span class="token operator">:</span>
                vector<span class="token operator">&lt;</span>Stmt<span class="token operator">&gt;</span> provides
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                <span class="token comment">// Array&lt;Stmt&gt; -&gt; SeqStmt</span>
                Stmt provide <span class="token operator">=</span> <span class="token class-name">SeqStmt</span><span class="token operator">::</span><span class="token function">Flatten</span><span class="token punctuation">(</span>provides<span class="token punctuation">)</span> <span class="token comment">// stmt.h</span>
                provide <span class="token operator">=</span> <span class="token function">MergeNest</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>main_nest<span class="token punctuation">,</span> provide<span class="token punctuation">)</span> <span class="token comment">// ir_utils.cc</span>
                <span class="token keyword">return</span> <span class="token function">Substitute</span><span class="token punctuation">(</span>provide<span class="token punctuation">,</span> n<span class="token punctuation">.</span>main_vmap<span class="token punctuation">)</span> <span class="token comment">// stmt_functor.cc</span>
    Stmt pipeline <span class="token operator">=</span> producer
    pipeline <span class="token operator">=</span> s<span class="token operator">-&gt;</span>op<span class="token operator">-&gt;</span><span class="token function">BuildRealize</span><span class="token punctuation">(</span>stage<span class="token punctuation">,</span> dom_map<span class="token punctuation">,</span> pipeline<span class="token punctuation">)</span> 
        <span class="token comment">// set the sizes of allocated buffers</span>
        <span class="token class-name">BaseComputeOpNode</span><span class="token operator">::</span><span class="token function">BuildRealize</span><span class="token punctuation">(</span>stage<span class="token punctuation">,</span> realize_map<span class="token punctuation">,</span> body<span class="token punctuation">)</span> <span class="token comment">// compute_op.cc</span>
            Stmt realize <span class="token operator">=</span> body
            realize <span class="token operator">=</span> tir<span class="token operator">::</span><span class="token function">ProducerRealize</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> <span class="token function">AttrStmt</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>op<span class="token punctuation">,</span> tir<span class="token operator">::</span>attr<span class="token operator">::</span>realize_scope<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> pipeline<span class="token punctuation">)</span>
    <span class="token keyword">return</span> pipeline
</code></pre> 
<p><code>MakePipeline()</code>函数主要步骤如下：</p> 
<ol><li><code>ComputeOpNode::BuildProvide()</code>函数主要创建<code>ComputeOp</code>对应的循环嵌套对应的那些<code>Stmt</code>对象并串成pipeline。 
  <ol><li>首先用<code>DetectComputeType()</code>函数检测计算类型。它遍历当前<code>Stage</code>的所有当前有效<code>IterVar</code>对象，并根据它们的属性判断计算类型，对于上面的简单例子这里为<code>ComputeType::kNormal</code>。</li><li>然后根据类型调用相应函数创建<code>Stmt</code>对象。这里对应地是调用<code>MakeComputeStmt()</code>函数。 
    <ol><li> <p>根据<code>Stage</code>对象和边界推导的结果通过<code>ComputeLoopNest::Create()</code>函数创建<code>ComputeLoopNest</code>对象。该对象表示循环嵌套，它几个主要成员：</p> 
      <ul><li><code>init_predicates</code>与<code>main_predicates</code>：类型为<code>vector&lt;PrimExpr&gt;</code>。表示每个循环的边界判断，调用<code>MakeBoundCheck()</code>函数来生成。</li><li><code>init_nest</code>与<code>main_nest</code>：类型为<code>vector&lt;vector&lt;Stmt&gt;&gt;</code>。 其中<code>main_nest</code>是最主要的表示循环嵌套的对象，对于上面的例子，经过split后这里包含两个for循环。</li></ul> </li><li> <p>根据<code>main_predicates</code>创建对应的<code>Stmt</code>（如有），用于在循环中判断该predicate是否成立，并添加到<code>main_nest</code>结构中。</p> </li><li> <p>根据有无reduce axis走不同的path。如果没有的话（如本例），对于<code>ComputeOp</code>的<code>body</code>中的每一个输出，创建<code>ProducerStore</code>对象，再通过<code>MergeNest()</code>函数将之与主嵌套<code>main_nest</code>合并。</p> </li><li> <p>通过<code>Substitute()</code>函数基于<code>main_vmap</code>（在<code>MakeLoopNest()</code>函数中准备）进行替换。</p> </li></ol> </li></ol> </li><li>如schedule中设置了double buffer（如<code>s[A].double_buffer</code>），则添加对应的<code>AttrStmt</code>。它通过增大额外的buffer来达到达到计算与访存的重叠。本例中没用到。</li><li>如传入的<code>consumer</code>有定义且不是no op（指无定义、const init的<code>EvaluateNode</code>，或者是长度为0的<code>SeqStmtNode</code>），则添加<code>SeqStmt</code>将<code>producer</code>与<code>consumer</code>串连起来。本例中也不适用。</li><li>调用<code>BuildRealize()</code>函数。对于每个输出的张量，在pipeline中加入<code>ProducerRealize</code>节点。</li><li>最后，在pipeline中添加<code>AttrStmt</code>节点标注操作的范围，并返回该pipeline。</li></ol> 
<p>对于前面vecadd的例子，得到的pipeline大致如下示意图：<br> <img src="https://images2.imgbox.com/7c/38/JoEOR96t_o.png" alt="在这里插入图片描述"></p> 
<p>整个<code>lower()</code>函数后完成后的IR（TIR）打印出来如下：</p> 
<pre><code>primfn(A_1: handle, B_1: handle, C_1: handle) -&gt; ()
  attr = {"global_symbol": "main", "tir.noalias": True}
  buffers = {C: Buffer(C_2: Pointer(float32), float32, [1024], []),
             B: Buffer(B_2: Pointer(float32), float32, [1024], []),
             A: Buffer(A_2: Pointer(float32), float32, [1024], [])}
  buffer_map = {A_1: A, B_1: B, C_1: C} {
  for (i.outer: int32, 0, 16) {
    for (i.inner: int32, 0, 64) {
      C_2[((i.outer*64) + i.inner)] = ((float32*)A_2[((i.outer*64) + i.inner)] + (float32*)B_2[((i.outer*64) + i.inner)])
    }
  }
}
</code></pre> 
<p>Lowering完成后，接下去就是build了。Build的主要流程相关代码如下：</p> 
<pre><code class="prism language-python">build<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># driver/build_module.py</span>
    input_mod <span class="token operator">=</span> lower<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> args<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> 

    mod_host_all <span class="token operator">=</span> tvm<span class="token punctuation">.</span>IRModule<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> tar<span class="token punctuation">,</span> input_mod <span class="token keyword">in</span> target_input_mod<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># build the lowered functions for a device with the given compilation</span>
        mod_host<span class="token punctuation">,</span> mdev <span class="token operator">=</span> _build_for_device<span class="token punctuation">(</span>input_mod<span class="token punctuation">,</span> tar<span class="token punctuation">,</span> target_host<span class="token punctuation">)</span>
            <span class="token comment"># input_mod type: IRModule</span>
            mod_mixed <span class="token operator">=</span> input_mod 
            <span class="token comment"># Apply passes:  ThreadSync, InferFragment, LowerThreadAllreduce, MakePackedAPI, SplitHostDevice</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token comment"># Device optimizations: Filter, LowerWarpMemory, ,Simplify, LowerDeviceStorageAccessInfo, LowerIntrin</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            mod_dev <span class="token operator">=</span> opt_device<span class="token punctuation">(</span>mod_mixed<span class="token punctuation">)</span> <span class="token comment"># IRModule</span>
            <span class="token comment"># Host optimization: LowerTVMBuiltin, LowerDeviceStorageAccessInfo, CustomDataType, LowerIntrin, CombineContextCall</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            mod_host <span class="token operator">=</span> opt_host<span class="token punctuation">(</span>mod_mixed<span class="token punctuation">)</span> <span class="token comment"># IRModule</span>
            
            <span class="token comment"># Build IRModule into Module</span>
            <span class="token comment"># If there are dev functions</span>
            rt_mod_dev <span class="token operator">=</span> codegen<span class="token punctuation">.</span>build_module<span class="token punctuation">(</span>mod_dev<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token comment"># target/codegen.py</span>
                _ffi_api<span class="token punctuation">.</span>Build<span class="token punctuation">(</span>mod<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token comment"># codegen.py</span>
            <span class="token comment"># mod_host type: IRModule, rt_mod_dev type: Module</span>
            <span class="token keyword">return</span> mod_host<span class="token punctuation">,</span> rt_mod_dev 
        mod_host_all<span class="token punctuation">.</span>update<span class="token punctuation">(</span>mod_host<span class="token punctuation">)</span>
            <span class="token comment"># Insert functions in another Module to current one</span>
            _ffi_api<span class="token punctuation">.</span>Module_Update<span class="token punctuation">(</span><span class="token punctuation">)</span>
                IRModuleNode<span class="token punctuation">:</span><span class="token punctuation">:</span>Update<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># ir/module.cc</span>
        device_modules<span class="token punctuation">.</span>append<span class="token punctuation">(</span>mdev<span class="token punctuation">)</span>
    <span class="token comment"># Generate a unified host module (type: runtime.Module)</span>
    rt_mod_host <span class="token operator">=</span> codegen<span class="token punctuation">.</span>build_module<span class="token punctuation">(</span>mod_host_all<span class="token punctuation">,</span> target_host<span class="token punctuation">)</span>
        <span class="token comment"># Create LLVMModuleNode and return the corresponding Module</span>
        _ffi_api<span class="token punctuation">.</span>Build<span class="token punctuation">(</span>mod<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token comment"># target/codegen.cc</span>
    <span class="token comment"># Import all modules</span>
    <span class="token keyword">for</span> mdev <span class="token keyword">in</span> device_modules<span class="token punctuation">:</span>
        rt_mod_host<span class="token punctuation">.</span>import_module<span class="token punctuation">(</span>mdev<span class="token punctuation">)</span>
            _LIB<span class="token punctuation">.</span>TVMModImport<span class="token punctuation">(</span>mod<span class="token punctuation">,</span> dep<span class="token punctuation">)</span> <span class="token comment"># c_runtime_api.cc</span>
                GetModuleNode<span class="token punctuation">(</span>mod<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span>Import<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment"># runtime/module.cc</span>
                    imports_<span class="token punctuation">.</span>emplace_back<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> rt_mod_host <span class="token comment"># runtime.module.Module</span>
</code></pre> 
<p><code>target_input_mod</code>包含了前面lowering输出的需要编译的<code>IRModule</code>及相应的target信息。比如LLVM(CPU)为target，就是：<code>{"llvm -keys=cpu -link-params=0", IRModule}</code>。如cuda为target，可能就是<code>{“cuda -keys=cuda,gpu -max_num_threads=1024 -thread_warp_size=32"， IRModule}</code>。对于简单的case（如本文这个），<code>target_input_mod</code>只包含一个元素，<code>_build_for_device()</code>函数返回host端的<code>IRModule</code>，以及target端的<code>Module</code>（如是cuda平台的话C++层对应<code>CUDAModuleNode</code>对象）。然后将host端<code>IRModule</code>生成一个统一的host模块，再将前面生成的对应target的<code>Module</code>（如有）导入其中。</p> 
<p>这里，其中<code>mod_host_all</code>与<code>mod_host</code>的类型为<code>tvm.ir.module.IRModule</code>。<code>rt_mod_host</code>与<code>mdev</code>的类型为<code>tvm.runtime.module.Module</code>。注意<code>mdev</code>只有当目标为非CPU（如GPU等）平台时才会有，当target为llvm（即for CPU）时mdev为空。</p> 
<p>这个流程大体示意图如下：<br> <img src="https://images2.imgbox.com/7b/da/myXataPi_o.png" alt="在这里插入图片描述"></p> 
<p>其中比较核心和重要的部分是<code>Build()</code>函数，实现在<code>codegen.cc</code>文件中。它会调用到具体后端的编译函数，进行目标代码生成。如cuda平台的话对应函数定义在<code>build_cuda_on.cc</code>文件中，llvm的话在<code>llvm_module.cc</code>文件中。以llvm后端为例，其主要流程相关代码为：</p> 
<pre><code class="prism language-cpp"><span class="token function">TVM_REGISTER_GLOBAL</span><span class="token punctuation">(</span><span class="token string">"target.build.llvm"</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">set_body_typed</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>IRModule mod<span class="token punctuation">,</span> Target target<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> runtime<span class="token operator">::</span>Module <span class="token punctuation">{<!-- --></span> 
        <span class="token keyword">auto</span> n <span class="token operator">=</span> make_object<span class="token operator">&lt;</span>LLVMModuleNode<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        n<span class="token operator">-&gt;</span><span class="token function">Init</span><span class="token punctuation">(</span>mod<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// llvm_module.cc</span>
            <span class="token function">InitializeLLVM</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                llvm<span class="token operator">::</span><span class="token function">InitializeAllTargetInfos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                llvm<span class="token operator">::</span><span class="token function">InitializeAllTargets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            unique_ptr<span class="token operator">&lt;</span>CodeGenLLVM<span class="token operator">&gt;</span> cg <span class="token operator">=</span> <span class="token class-name">CodeGenLLVM</span><span class="token operator">::</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">// codegen_llvm.cc</span>
                <span class="token comment">// Call the corresponding codegen backend according to the target.</span>
                <span class="token keyword">const</span> PackedFunc<span class="token operator">*</span> f <span class="token operator">=</span> runtime<span class="token operator">::</span><span class="token class-name">Registry</span><span class="token operator">::</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"tvm.codegen.llvm.target_"</span> <span class="token operator">+</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
                handle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
                <span class="token keyword">return</span> unique_ptr<span class="token operator">&lt;</span>CodeGenLLVM<span class="token operator">&gt;</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
                
            vector<span class="token operator">&lt;</span>PrimFunc<span class="token operator">&gt;</span> funcs<span class="token punctuation">;</span>
            <span class="token keyword">for</span> kv <span class="token operator">:</span> mod<span class="token operator">-&gt;</span>functions<span class="token operator">:</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                f <span class="token operator">=</span> Downcast<span class="token operator">&lt;</span>PrimFunc<span class="token operator">&gt;</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token operator">-&gt;</span><span class="token function">HasNonzeroAttr</span><span class="token punctuation">(</span>tir<span class="token operator">::</span>attr<span class="token operator">::</span>kIsEntryFunc<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    entry_func <span class="token operator">=</span> global_symbol<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                funcs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
            cg<span class="token operator">-&gt;</span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token string">"TVMMod"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">CodeGenCPU</span><span class="token operator">::</span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// codegen_cpu.cc</span>
                    <span class="token class-name">CodeGenLLVM</span><span class="token operator">::</span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// codegen_llvm.cc</span>
                    
            <span class="token keyword">for</span> f in funcs<span class="token operator">:</span>
                cg<span class="token operator">-&gt;</span><span class="token function">AddFunction</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// codegen_cpu.cc</span>
                    <span class="token class-name">CodeGenLLVM</span><span class="token operator">::</span><span class="token function">AddFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">AddFunctionInternal</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            llvm<span class="token operator">::</span>FunctionType<span class="token operator">*</span> ftype <span class="token operator">=</span> llvm<span class="token operator">::</span><span class="token class-name">FunctionType</span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token comment">// kGlobalSymbol: "global_symbol"</span>
                            global_symbol <span class="token operator">=</span> f<span class="token operator">-&gt;</span>GetAttr<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">(</span>tvm<span class="token operator">::</span>attr<span class="token operator">::</span>kGlobalSymbol<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            function_ <span class="token operator">=</span> llvm<span class="token operator">::</span><span class="token class-name">Function</span><span class="token operator">::</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            llvm<span class="token operator">::</span>BasicBlock<span class="token operator">*</span> entry <span class="token operator">=</span> llvm<span class="token operator">::</span><span class="token class-name">BasicBlock</span><span class="token operator">::</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> function_<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token class-name">IRBuilder</span><span class="token operator">::</span><span class="token function">SetInsertPoint</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">VisitStmt</span><span class="token punctuation">(</span>f<span class="token operator">-&gt;</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            builder_<span class="token operator">-&gt;</span><span class="token function">CreateRet</span><span class="token punctuation">(</span><span class="token function">ConstInt32</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> entry_func<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token operator">:</span>
                cg<span class="token operator">-&gt;</span><span class="token function">AddMainFunction</span><span class="token punctuation">(</span>entry_func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// codegen_cpu.cc</span>
                    <span class="token comment">// tvm_module_main : "__tvm_main__"</span>
                    llvm<span class="token operator">::</span>GlobalVariable<span class="token operator">*</span> global <span class="token operator">=</span> <span class="token keyword">new</span> llvm<span class="token operator">::</span><span class="token function">GlobalVariable</span><span class="token punctuation">(</span><span class="token operator">*</span>module_<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> tvm_module_main<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    global<span class="token operator">-&gt;</span><span class="token function">setInitializer</span><span class="token punctuation">(</span>llvm<span class="token operator">::</span><span class="token class-name">ConstantDataArray</span><span class="token operator">::</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token operator">*</span>ctx_<span class="token punctuation">,</span> entry_func_name<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    global<span class="token operator">-&gt;</span><span class="token function">setDLLStorageClass</span><span class="token punctuation">(</span>llvm<span class="token operator">::</span>GlobalVariable<span class="token operator">::</span>DLLExportStorageClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
            module_ <span class="token operator">=</span> cg<span class="token operator">-&gt;</span><span class="token function">Finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// CodeGenCPU::Finish() in codegen_cpu.cc</span>
                <span class="token class-name">CodeGenLLVM</span><span class="token operator">::</span><span class="token function">Finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// codegen_llvm.cc</span>
                    <span class="token class-name">CodeGenCPU</span><span class="token operator">::</span><span class="token function">AddStartupFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        function_ <span class="token operator">=</span> llvm<span class="token operator">::</span><span class="token class-name">Function</span><span class="token operator">::</span><span class="token function">Create</span><span class="token punctuation">(</span>ftype<span class="token punctuation">,</span> llvm<span class="token operator">::</span>Function<span class="token operator">::</span>InternalLinkage<span class="token punctuation">,</span><span class="token string">"__tvm_module_startup"</span><span class="token punctuation">,</span> module_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        llvm<span class="token operator">::</span>BasicBlock<span class="token operator">*</span> startup_entry <span class="token operator">=</span> llvm<span class="token operator">::</span><span class="token class-name">BasicBlock</span><span class="token operator">::</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token operator">*</span>ctx_<span class="token punctuation">,</span> <span class="token string">"entry"</span><span class="token punctuation">,</span> function_<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        llvm<span class="token operator">::</span><span class="token function">appendToGlobalCtors</span><span class="token punctuation">(</span><span class="token operator">*</span>module_<span class="token punctuation">,</span> function_<span class="token punctuation">,</span> <span class="token number">65535</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        builder_<span class="token operator">-&gt;</span><span class="token function">CreateRet</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">CodeGenLLVM</span><span class="token operator">::</span><span class="token function">Optimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// codegen_llvm.cc</span>
                        <span class="token comment">// Function pass manager</span>
                        FPassManager <span class="token function">fpass</span><span class="token punctuation">(</span>module_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">// Module pass manager</span>
                        MPassManager mpass<span class="token punctuation">;</span>
                        mpass<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>llvm<span class="token operator">::</span><span class="token function">createTargetTransformInfoWrapperPass</span><span class="token punctuation">(</span><span class="token function">getTargetIRAnalysis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        fpass<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>llvm<span class="token operator">::</span><span class="token function">createTargetTransformInfoWrapperPass</span><span class="token punctuation">(</span><span class="token function">getTargetIRAnalysis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        llvm<span class="token operator">::</span>PassManagerBuilder builder<span class="token punctuation">;</span>
                        builder<span class="token punctuation">.</span>Inliner <span class="token operator">=</span> llvm<span class="token operator">::</span><span class="token function">createFunctionInliningPass</span><span class="token punctuation">(</span>builder<span class="token punctuation">.</span>OptLevel<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        builder<span class="token punctuation">.</span>LoopVectorize <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
                        builder<span class="token punctuation">.</span>SLPVectorize <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
                        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                        <span class="token comment">// Run the function passes</span>
                        <span class="token keyword">for</span> mod in module_<span class="token operator">:</span>
                            fpass<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>mod<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        fpass<span class="token punctuation">.</span><span class="token function">doFinalization</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">// Run the module passes.</span>
                        mpass<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token operator">*</span>module_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> runtime<span class="token operator">::</span><span class="token function">Module</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>该函数中先创建<code>LLVMModuleNode</code>对象，然后调用它的<code>Init()</code>函数进行初始化，最后封装成<code>Module</code>对象返回。其中的<code>Init()</code>函数主要是将之前生成的TIR转为LLVM IR。它主要分几步：</p> 
<ol><li> <p><code>InitializeLLVM()</code>函数初始化LLVM环境。这里边主要是例行调用LLVM的一大坨初始化函数。</p> </li><li> <p>创建用于代码生成的<code>CodeGenLLVM</code>对象。这里由于target字符串为x86-64，因此工厂函数名为<code>tvm.codegen.llvm.target_x86-64</code>。该工厂函数中创建<code>CodeGenX86_64</code>对象。因为继承关系为<code>CodeGenX86_64 -&gt; CodeGenCPU -&gt; CodeGenLLVM</code>，所以返回的是<code>CodeGenLLVM</code>的指针。</p> </li><li> <p>类型为<code>IRModule</code>的参数<code>mod</code>中的<code>functions</code>成员包含了该模块中的函数。这一步中将这些函数存于类型<code>PrimFunc</code>的数组<code>funcs</code>中。对于标为入口函数（<code>kIsEntryFunc</code>）的函数，记录在<code>entry_func</code>变量中。</p> </li><li> <p>接下来初始化前面创建的<code>CodeGenX86_64</code>对象。先调用<code>CodeGenCPU::Init()</code>，它里边又会调用到<code>CodeGenLLVM::Init()</code>。前者主要创建一坨TVM运行时类型与函数。后者创建一些llvm中用于codegen的对象，如<code>IRBuilder</code>、<code>llvm::Module</code>和<code>llvm::MDBuilder</code>。</p> </li><li> <p>对前面放入<code>funcs</code>数组的每个函数，调用<code>CodeGenCPU::AddFunction()</code>函数进行代码生成。对本文涉及的case只有一个函数就是<code>vecadd()</code>。</p> 
  <ol><li>首先产生<code>llvm::Function</code>和<code>llvm::BasicBlock</code>对象，分别对应函数与基本块。前面在<code>loewr()</code>函数中将函数的名为<code>global_symbol</code>的属性设为相应的函数名（如vecadd）。这里将该属性取出，作为生成函数的链接时的symbol。</li><li>通过<code>VisitStmt()</code>函数遍历<code>IRModule</code>中的各节点并转为LLVM中对应的数据结构，生成LLVM IR。这是最关键的一步了。前面费了老大劲构建起的TIR主要就是为了这里的转换。举例来说，对于<code>ForNode</code>就会调用<code>CodeGenLLVM::VisitStmt_(ForNode *op)</code>函数。它继而会调用<code>CreateSerialFor()</code>函数来产生相应的LLVM IR。在优化pass中的<code>MakePackedAPI</code>（<code>make_packed_api.cc</code>）会添加一个<code>AttrStmt</code>，它对应一个值为目标函数名加<code>_compute_</code>后缀的<code>compute_scope</code>。这样，在code generation时 <code>CodeGenCPU::CreateComputeScope()</code>函数（为什么加<code>compute_scope</code>在该函数的注释中有提到）被调用。因此，最终的binary（可通过<code>fadd.export_library("vecadd.so")</code>语句导出）中大概会是这个样子：<br> <img src="https://images2.imgbox.com/62/77/TWJxajrz_o.png" alt="在这里插入图片描述"></li></ol> </li><li> <p><code>AddMainFunction()</code>函数设置主函数。如上面的例子中只有一个函数<code>vecadd()</code>，它也是主函数。这个symbol会放在<code>runtime::symbol::tvm_module_main</code>（即<code>__tvm_main__</code>)这个全局变量中。我们可以拿编译好binary验证这一点。用objdump命令dump导出的so文件，可以看到如下这段。如果将里边的0x766563616464的16进制转为ASCII，就是主函数的symbol名：vecadd。</p> </li></ol> 
<pre><code>0000000000003c87 &lt;__tvm_main__&gt;:    
    3c87:   76 65                   jbe    3cee &lt;__GNU_EH_FRAME_HDR+0x5e&gt;
    3c89:   63 61 64                movslq 0x64(%rcx),%esp
    3c8c:   64                      fs     
</code></pre> 
<ol start="7"><li>最后，调用<code>CodeGenCPU::Finish()</code>函数将LLVM IR生成后端代码。它实际调用<code>CodeGenLLVM::Finish()</code>函数，它会调用<code>CodeGenLLVM::Finish()</code>函数。它主要调用<code>CodeGenCPU::AddStartupFunction()</code>函数和<code>CodeGenLLVM::Optimize()</code>函数。前者创建<code>_tvm_module_startup</code>函数，然后将一些需要启动时调用的函数填入。后者主要利用LLVM pass做一些优化。主要是向量化和函数内联。llvm中两种自动向量化。具体可参见<a href="https://releases.llvm.org/12.0.0/docs/Vectorizers.html#the-slp-vectorizer" rel="nofollow">Auto-Vectorization in LLVM</a>。</li></ol> 
<p>其实，到这里编译还没有完全结束，只是构建好了LLVM的module。到这里，剩下的事情就是交给LLVM来编译生成可执行的binary了。真正生成可执行的binary是在第一次运行时通过<code>LazyInitJIT()</code>函数完成。 运行时会调用到<code>LLVMModuleNode::GetFunction()</code>函数。当它发现还未生成可执行binary时，会调用<code>LazyInitJIT()</code>函数。该函数通过<code>llvm::ExecutionEngine</code>将前面产生的<code>llvm::Module</code>编译成真正的（能在机器上跑的）binary。然后<code>GetFunctionAddr()</code>函数从中获得相应的函数指针，用于执行。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21544e88ba44b58d0c4f0ba5fcb7f0a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android模拟器中运行AR应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ca1e7b917d9b04ac4f9a89bab956a9c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vs2015 vs2017 编译zlib库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>