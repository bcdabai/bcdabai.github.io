<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java如何获取线程的返回值 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java如何获取线程的返回值" />
<meta property="og:description" content="java实现多线程有三种方式，分别是继承Thread类和实现Runnable,Callable接口，然而这三种方式的run()方法都是无返回值的，那么该如何实现获取线程的返回值呢？
1）主线程等待法
这是最简单的方法，通过判断返回值不为空从而得到返回值，缺点就是不能精准判断子线程是否执行完成，直接看代码：
public class TestThread extends Thread { public String value = null; @Override public void run() { System.out.println(&#34;TestThread start....&#34;); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&#34;TestThread end&#34;); value = &#34;TestThread&#34;; } } public class Test { public static void main(String[] args) throws InterruptedException { TestThread thread = new TestThread(); thread.start(); while (thread.value == null){ Thread.sleep(100); } System.out.println(thread.value); } } 2）使用Thread类的join()阻塞当前线程以等待子线程执行完成
public class Test { public static void main(String[] args) throws InterruptedException { TestThread thread = new TestThread(); thread." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e44657a2105ddb055ea3c776ff1d27e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-17T15:13:02+08:00" />
<meta property="article:modified_time" content="2022-04-17T15:13:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java如何获取线程的返回值</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>java实现多线程有三种方式，分别是继承Thread类和实现Runnable,Callable接口，然而这三种方式的run()方法都是无返回值的，那么该如何实现获取线程的返回值呢？</p> 
<p>1）主线程等待法</p> 
<p>这是最简单的方法，通过判断返回值不为空从而得到返回值，缺点就是不能精准判断子线程是否执行完成，直接看代码：</p> 
<pre><code>
public class TestThread extends Thread  {
    public String value = null;

    @Override
    public void run() {
        System.out.println("TestThread start....");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("TestThread end");

        value = "TestThread";
    }
}

public class Test {
    public static void main(String[] args) throws InterruptedException {
        TestThread thread = new TestThread();
        thread.start();

        while (thread.value == null){
            Thread.sleep(100);
        }

        System.out.println(thread.value);
    }
}</code></pre> 
<p>2）使用Thread类的join()阻塞当前线程以等待子线程执行完成</p> 
<pre><code>public class Test {
    public static void main(String[] args) throws InterruptedException {
        TestThread thread = new TestThread();
        thread.start();

        thread.join();

        System.out.println(thread.value);
    }
}</code></pre> 
<p>3）通过FutureTask类实现</p> 
<p>这种方式应该是比较推荐的，通过实现Callable接口，使用FutureTask启动子线程，通过FutureTask的get()方法即可精准的获取返回值</p> 
<pre><code>public class TestCallable implements Callable&lt;String&gt; {
    @Override
    public String call() throws Exception {
        System.out.println("TestCallable start....");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("TestCallable end");

        return "TestCallable";
    }
}

public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask&lt;String&gt; futureTask = new FutureTask(new TestCallable());
        Thread thread = new Thread(futureTask);
        thread.start();
        String value = futureTask.get();
        System.out.println(value);
    }
}
</code></pre> 
<p></p> 
<p>4）使用线程池</p> 
<p>我们还可以使用线程池，来统一管理线程，日常开发中使用最多的就是使用线程池处理某一部分的逻辑，等待所有的线程执行完成，才继续处理下一步骤</p> 
<pre><code>public class TestCallable implements Callable&lt;String&gt; {
    private int index;
    private long sleepTime;

    public TestCallable(){

    }

    public TestCallable(int index, long sleepTime) {
        this.index = index;
        this.sleepTime = sleepTime;
    }

    @Override
    public String call() throws Exception {
        System.out.println("TestCallable start...."+index);
        try {
            if(sleepTime &gt; 0){
                Thread.sleep(sleepTime);
            }
            else {
                Thread.sleep(5000);
            }

        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("TestCallable end...."+index);

        return "TestCallable"+index;
    }
}

public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {

        ExecutorService service = Executors.newFixedThreadPool(4);

        Future&lt;String&gt; future1 = service.submit(new TestCallable(1,5000));
        Future&lt;String&gt; future2 = service.submit(new TestCallable(2,6000));
        Future&lt;String&gt; future3 = service.submit(new TestCallable(3,7000));
        Future&lt;String&gt; future4 = service.submit(new TestCallable(4,8000));
        //用完线程池必须关闭，否则当前线程将不会结束
        service.shutdown();

        Map&lt;String,Future&lt;String&gt;&gt; futureMap = new HashMap&lt;&gt;();
        futureMap.put("future1",future1);
        futureMap.put("future2",future2);
        futureMap.put("future3",future3);
        futureMap.put("future4",future4);

        String[] keys = new String[]{"future1","future2","future3","future4"};

        while (!futureMap.isEmpty()){
            for(String key : keys){
                Future&lt;String&gt; future = futureMap.get(key);

                if(future != null &amp;&amp; future.isDone()){
                    System.out.println(future.get());
                    futureMap.remove(key);
                }
            }

            System.out.println(futureMap.size());
        }
    }
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb39b109766f31bfdf6e8e83934ce8db/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vuepress（一）：搭建个人博客</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e725b8c9c6c91394a57767a7fe3afceb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">记录一次spark2.x数据倾斜(隐藏的笛卡尔积)排查处理过程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>