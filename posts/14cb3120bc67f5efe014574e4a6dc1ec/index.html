<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JWT在线解码网址和结构介绍 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JWT在线解码网址和结构介绍" />
<meta property="og:description" content="JWT介绍 JWT简介JWT 概念JWT 优点 JWT 在线解码工具JWT 结构解析1.Header2.Payload3.Signature 写在最后 JWT简介 JWT 概念 JWT 全称为 JSON Web Token是目前最流行的跨域认证解决方案，官网地址链接，
JWT 优点 基于token的认证方式相比传统的session认证方式能够解决移动端和分布式开发中跨域问题，具有下列优点：
减少服务器压力：服务端不需要存储session信息，token可以携带登录用户服务器所需信息支持跨域访问：将token放到请求头中，就不需要cookie存储信息，所以跨域后不会因为cookie是无法跨域而导致信息丢失更适用于移动端：当客户端是非浏览器平台时或者cookie被禁止时，采用token认证方式会简单很多更适用CDN：可以通过内容分发网络请求服务端的所有资料无需考虑CSRF：由于不再依赖cookie，所以采用token认证方式不会发生CSRF，所以也就无需考虑CSRF的防御 JWT 在线解码工具 这个解码工具只能解析Base64编码后的header以及Payload部分，对于加密的Signature部分是无法解密的只有服务器端使用secretKey进行解密才能知道具体的内容。
JWT在线解码工具入口
JWT 结构解析 JWT由3部分组成：标头(Header)，有效载荷(Payload)和签名(Signature)。在传输的时候，会将JWT的三个部分分别进行Base64编码后，拼接成最终传输的字符串，也就是我们的Json Web Token。
JWTString=Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)&#43;&#34;.&#34;&#43;base64UrlEncode(payload),secret) header和payload可以直接利用base64解码出原文，从header中获取哈希签名的算法，从payload中获取有效数据
signature由于使用了不可逆的加密算法，无法解码出原文，它的作用是校验token有没有被篡改。服务端获取header中的加密算法之后，利用该算法加上secretKey对header、payload进行加密，比对加密后的数据和客户端发送过来的是否一致，注意其中secretKey只能保存在服务端，以保证数据的安全性。
1.Header JWT头是一个描述JWT元数据的JSON对象，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存
{ &#34;alg&#34;: &#34;HS256&#34;, &#34;typ&#34;: &#34;JWT&#34; } 2.Payload 有效载荷部分，JWT主体内容部分，是一个包含需要传递数据的JSON对象。 其中有七个默认字段供选择。
{ &#34;iss&#34;：发行人 &#34;exp&#34;：到期时间 &#34;sub&#34;：主题 &#34;aud&#34;：用户 &#34;nbf&#34;：在此之前不可用 &#34;iat&#34;：发布时间 &#34;jti&#34;：JWT ID用于标识该JWT } 以上默认字段并不要求强制使用。我们还可以自定义私有字段，一般会把包含用户信息的非保密数据放到payload中。
{ &#34;admin_id&#34;: &#34;93b5909c927c235ed5f9ee655e0e01abf988f5ebaeff4788542fde9573d79f3b4556c462b332493d2d34c7421dca804bf407dcf51815671cf8ce832165296441e3ca9b42ddc00a7e4914bbc536e1cec84afa6c61785c27b597b492de60baff8f&#34;, &#34;merchant_id&#34;: &#34;93b5909c927c235ed5f9ee655e0e01abf988f5ebaeff4788542fde9573d79f3b4556c462b332493d2d34c7421dca804bf407dcf51815671cf8ce832165296441e3ca9b42ddc00a7e4914bbc536e1cec84afa6c61785c27b597b492de60baff8f&#34; } 注意：默认情况下JWT是未加密的，只是采用base64算法，拿到JWT字符串后可以转换回原本的JSON数据，任何人都可以解读其内容，因此不要构建隐私信息字段，比如用户的密码一定不能保存到JWT中，以防止信息泄露。JWT只是适合在网络中传输一些非敏感的信息
3.Signature 签名哈希部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希，以确保数据不会被篡改。首先，需要指定一个密钥（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用header中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名
HMACSHA256(base64UrlEncode(header)&#43;&#34;.&#34;&#43;base64UrlEncode(payload),secret) 写在最后 JWT作为现在主流的验证方式，在各种语言中都有着对应使用方法，还是十分值得研究学习的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/14cb3120bc67f5efe014574e4a6dc1ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-29T10:49:31+08:00" />
<meta property="article:modified_time" content="2022-11-29T10:49:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JWT在线解码网址和结构介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>JWT介绍</h4> 
 <ul><li><a href="#JWT_1" rel="nofollow">JWT简介</a></li><li><ul><li><a href="#JWT__2" rel="nofollow">JWT 概念</a></li><li><a href="#JWT__4" rel="nofollow">JWT 优点</a></li></ul> 
  </li><li><a href="#JWT__11" rel="nofollow">JWT 在线解码工具</a></li><li><a href="#JWT__14" rel="nofollow">JWT 结构解析</a></li><li><ul><li><a href="#1Header_26" rel="nofollow">1.Header</a></li><li><a href="#2Payload_37" rel="nofollow">2.Payload</a></li><li><a href="#3Signature_64" rel="nofollow">3.Signature</a></li></ul> 
  </li><li><a href="#_70" rel="nofollow">写在最后</a></li></ul> 
</div> 
<p></p> 
<h2><a id="JWT_1"></a>JWT简介</h2> 
<h3><a id="JWT__2"></a>JWT 概念</h3> 
<p>JWT 全称为 <code>JSON Web Token</code>是目前最流行的跨域认证解决方案，<a href="https://jwt.io/" rel="nofollow">官网地址链接</a>，</p> 
<h3><a id="JWT__4"></a>JWT 优点</h3> 
<p>基于token的认证方式相比传统的session认证方式能够解决移动端和分布式开发中跨域问题，具有下列优点：</p> 
<ol><li>减少服务器压力：服务端不需要存储session信息，token可以携带登录用户服务器所需信息</li><li>支持跨域访问：将token放到请求头中，就不需要cookie存储信息，所以跨域后不会因为cookie是无法跨域而导致信息丢失</li><li>更适用于移动端：当客户端是非浏览器平台时或者cookie被禁止时，采用token认证方式会简单很多</li><li>更适用CDN：可以通过内容分发网络请求服务端的所有资料</li><li>无需考虑CSRF：由于不再依赖cookie，所以采用token认证方式不会发生CSRF，所以也就无需考虑CSRF的防御</li></ol> 
<h2><a id="JWT__11"></a>JWT 在线解码工具</h2> 
<p>这个解码工具只能解析<code>Base64</code>编码后的<code>header</code>以及<code>Payload</code>部分，对于加密的<code>Signature</code>部分是无法解密的只有服务器端使用<code>secretKey</code>进行解密才能知道具体的内容。<br> <a href="https://tooltt.com/jwt-decode/" rel="nofollow">JWT在线解码工具入口</a></p> 
<h2><a id="JWT__14"></a>JWT 结构解析</h2> 
<p>JWT由3部分组成：标头(<code>Header</code>)，有效载荷(<code>Payload</code>)和签名(<code>Signature</code>)。在传输的时候，会将JWT的三个部分分别进行<code>Base64</code>编码后，拼接成最终传输的字符串，也就是我们的Json Web Token。</p> 
<pre><code class="prism language-c">JWTString<span class="token operator">=</span><span class="token function">Base64</span><span class="token punctuation">(</span>Header<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Base64</span><span class="token punctuation">(</span>Payload<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HMACSHA256</span><span class="token punctuation">(</span><span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"."</span><span class="token operator">+</span><span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span>secret<span class="token punctuation">)</span>
</code></pre> 
<p><code>header</code>和<code>payload</code>可以直接利用<code>base64</code>解码出原文，从<code>header</code>中获取哈希签名的算法，从<code>payload</code>中获取有效数据<br> <code>signature</code>由于使用了不可逆的加密算法，无法解码出原文，它的作用是校验token有没有被篡改。服务端获取header中的加密算法之后，利用该算法加上<code>secretKey</code>对<code>header</code>、<code>payload</code>进行加密，比对加密后的数据和客户端发送过来的是否一致，注意其中<code>secretKey</code>只能保存在服务端，以保证数据的安全性。</p> 
<p><img src="https://images2.imgbox.com/6e/ba/bL0BeeVI_o.png" alt="JWT三部分"></p> 
<h3><a id="1Header_26"></a>1.Header</h3> 
<p>JWT头是一个描述JWT元数据的JSON对象，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存</p> 
<pre><code class="prism language-c"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"alg"</span><span class="token operator">:</span> <span class="token string">"HS256"</span><span class="token punctuation">,</span>
  <span class="token string">"typ"</span><span class="token operator">:</span> <span class="token string">"JWT"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/12/1f/1l6afMc3_o.png" alt="Header"></p> 
<h3><a id="2Payload_37"></a>2.Payload</h3> 
<p>有效载荷部分，<code>JWT</code>主体内容部分，是一个包含需要传递数据的<code>JSON</code>对象。 其中有七个默认字段供选择。</p> 
<pre><code class="prism language-c"><span class="token punctuation">{<!-- --></span>
	<span class="token string">"iss"</span>：发行人
	<span class="token string">"exp"</span>：到期时间
	<span class="token string">"sub"</span>：主题
	<span class="token string">"aud"</span>：用户
	<span class="token string">"nbf"</span>：在此之前不可用
	<span class="token string">"iat"</span>：发布时间
	<span class="token string">"jti"</span>：JWT ID用于标识该JWT
<span class="token punctuation">}</span>
</code></pre> 
<p>以上默认字段并不要求强制使用。我们还可以自定义私有字段，一般会把包含用户信息的非保密数据放到<code>payload</code>中。</p> 
<pre><code class="prism language-c"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"admin_id"</span><span class="token operator">:</span> <span class="token string">"93b5909c927c235ed5f9ee655e0e01abf988f5ebaeff4788542fde9573d79f3b4556c462b332493d2d34c7421dca804bf407dcf51815671cf8ce832165296441e3ca9b42ddc00a7e4914bbc536e1cec84afa6c61785c27b597b492de60baff8f"</span><span class="token punctuation">,</span>
  <span class="token string">"merchant_id"</span><span class="token operator">:</span> <span class="token string">"93b5909c927c235ed5f9ee655e0e01abf988f5ebaeff4788542fde9573d79f3b4556c462b332493d2d34c7421dca804bf407dcf51815671cf8ce832165296441e3ca9b42ddc00a7e4914bbc536e1cec84afa6c61785c27b597b492de60baff8f"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意：默认情况下<code>JWT</code>是未加密的，只是采用<code>base64</code>算法，拿到JWT字符串后可以转换回原本的<code>JSON</code>数据，任何人都可以解读其内容，因此不要构建隐私信息字段，比如用户的密码一定不能保存到<code>JWT</code>中，以防止信息泄露。<code>JWT</code>只是适合在网络中传输一些非敏感的信息<br> <img src="https://images2.imgbox.com/56/8a/ihs3HiuM_o.png" alt="载荷"></p> 
<h3><a id="3Signature_64"></a>3.Signature</h3> 
<p>签名哈希部分是对上面两部分数据签名，需要使用<code>base64</code>编码后的<code>header</code>和<code>payload</code>数据，通过指定的算法生成哈希，以确保数据不会被篡改。首先，需要指定一个密钥（<code>secret</code>）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用<code>header</code>中指定的签名算法（默认情况下为<code>HMAC SHA256</code>）根据以下公式生成签名</p> 
<pre><code class="prism language-c"><span class="token function">HMACSHA256</span><span class="token punctuation">(</span><span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"."</span><span class="token operator">+</span><span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span>secret<span class="token punctuation">)</span>
</code></pre> 
<h2><a id="_70"></a>写在最后</h2> 
<p><code>JWT</code>作为现在主流的验证方式，在各种语言中都有着对应使用方法，还是十分值得研究学习的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a9e8fd0f0f333d7d0a6c9eedff1b3f2d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">腾讯云开源项目Crane成FinOps首个认证降本增效开源方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f88edaa677232e10593e55cc100c9212/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">动态路由协议——OSPF</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>