<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>类加载器（classloader） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="类加载器（classloader）" />
<meta property="og:description" content="作者：ZeaTalk
链接：https://www.zhihu.com/question/49667892/answer/690161827
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
类加载器（classloader） 先从类加载器说起，凡事先问是什么，首先什么是类加载器？
我们知道，一个 *.java 的代码源文件要执行起来之前，必须通过 javac 构建抽象语法树并编译成字节码，字节码仍然是不能被机器所识别，那么一个 .class 文件要被机器识别并执行的前提就是将字节码转化成机器码加载到内存里，这一转化过程就是类加载的执行过程。
当然，这整个过程细节并非这个问题的讨论重点。
类加载器便是在在这个过程里的加载阶段起作用，负责将 .class 文件字节码提取出来，转化成二进制字节流。
（但是这离成为真正的类还有十万八千里。。。）
一个Java应用中通常存在三个类加载器（Classloader）：
Bootstrap Classloader 启动类加载器：负责加载&lt;JRE&gt;/lib 下的核心类库，此加载器本身内嵌于JVM，在 Java 中找不到具体的引用；Extension Classloader 扩展类加载器：负责加载&lt;JRE&gt;/lib/ext 下的扩展类库；Application Classloader 系统应用类加载器：负责-classpath 指定路径类库加载。 他们三者并非典型的继承关系，而是子指派父为自己的 parent。
（这里有个源码细节，由于启动类加载器是内嵌于 JVM 且无法被引用，因此 Extension Classloader 指派 parent 为 null，即等同于指派启动类加载器为自己的父加载器）
为了有足够灵活性，类加载器也是允许自定义的。这不禁思考，这么多类加载器之间是怎么协调类加载任务的？
这就引出了本文的重点，双亲委派模型。
双亲委派（parents deletation model） 双亲委派模型是什么？
The Java platform uses a delegation model for loading classes. The basic idea is that every class loader has a &#34;parent&#34; class loader." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bd165f0bc115ebfc33a2d373bf1efd84/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-15T15:32:56+08:00" />
<meta property="article:modified_time" content="2023-11-15T15:32:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">类加载器（classloader）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>作者：ZeaTalk<br> 链接：https://www.zhihu.com/question/49667892/answer/690161827<br> 来源：知乎<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>  </p> 
<h3><strong><u>类加载器（classloader）</u></strong></h3> 
<p>先从类加载器说起，凡事先问是什么，首先什么是类加载器？</p> 
<p>我们知道，一个 *.java 的代码<a href="https://www.zhihu.com/search?q=%E6%BA%90%E6%96%87%E4%BB%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690161827%7D" rel="nofollow" title="源文件">源文件</a>要执行起来之前，必须通过 javac 构建<a href="https://www.zhihu.com/search?q=%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690161827%7D" rel="nofollow" title="抽象语法树">抽象语法树</a>并编译成字节码，字节码仍然是不能被机器所识别，那么一个 .class 文件要被机器识别并执行的前提就是将字节码转化成机器码加载到内存里，这一转化过程就是类加载的执行过程。</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="169" src="https://images2.imgbox.com/ab/f5/niRiX1ec_o.png" width="572"></p> 
<p><br> 当然，这整个过程细节并非这个问题的讨论重点。</p> 
<p>类加载器便是在在这个过程里的<strong>加载阶段</strong>起作用，负责将 .class 文件字节码提取出来，转化成二进制字节流。</p> 
<p>（但是这离成为真正的类还有十万八千里。。。）</p> 
<p>一个Java应用中通常存在三个类加载器（Classloader）：</p> 
<ul><li><strong>Bootstrap Classloader 启动类加载器</strong>：负责加载&lt;JRE&gt;/lib 下的核心类库，此加载器本身内嵌于JVM，在 Java 中找不到具体的引用；</li><li><strong>Extension Classloader <a href="https://www.zhihu.com/search?q=%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690161827%7D" rel="nofollow" title="扩展类加载器">扩展类加载器</a></strong>：负责加载&lt;JRE&gt;/lib/ext 下的扩展类库；</li><li><strong>Application Classloader 系统应用类加载器</strong>：负责-classpath 指定路径类库加载。</li></ul> 
<p></p> 
<p class="img-center"><img alt="" height="379" src="https://images2.imgbox.com/b6/29/00Qw3rjR_o.png" width="545"></p> 
<p>他们三者并非典型的继承关系，而是子指派父为自己的 parent。</p> 
<p>（这里有个源码细节，由于启动类加载器是内嵌于 JVM 且无法被引用，因此 Extension Classloader 指派 parent 为 null，即等同于指派启动<a href="https://www.zhihu.com/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690161827%7D" rel="nofollow" title="类加载器">类加载器</a>为自己的父加载器）</p> 
<p>为了有足够灵活性，类加载器也是允许自定义的。这不禁思考，这么多类加载器之间是怎么协调类加载任务的？</p> 
<p>这就引出了本文的重点，双亲委派模型。</p> 
<p></p> 
<h3><strong><u>双亲委派（parents deletation model）</u></strong></h3> 
<p>双亲委派模型是什么？</p> 
<blockquote>
  The Java platform uses a delegation model for loading classes. The basic idea is that every class loader has a "parent" class loader. When loading a class, a class loader first "delegates" the search for the class to its parent class loader before attempting to find the class itself. 
</blockquote> 
<p>由于翻译问题，这里双亲的 “双” 并没有太多特殊含义，双亲就是父母。简单来说，当一个类加载器得到一个类加载任务 t 的时候，首先会委派其 parent A 去加载，A 拿到任务后，也会进一步委派到 A 的 parent B。层层向上<a href="https://www.zhihu.com/search?q=%E9%80%92%E5%BD%92&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690161827%7D" rel="nofollow" title="递归">递归</a>直到委派到启动类加载器。</p> 
<p>但我们知道，每个 classloader 负责的加载域是不一样的，启动类加载器需根据 t 给出的类全限定名（如 com.Test）在其所负责的域里搜寻此类字节码，如果找到，则加载之；如果找不到，则表示无法加载，把代理权限往下<strong>（父-&gt;子）</strong>转移，直到某个加载器在负责的加载域中找到该类为止。</p> 
<p></p> 
<p>这一逻辑的代码实现是这样的：</p> 
<p><strong>java.lang.ClassLoader#loadClass(java.lang.String, boolean)</strong></p> 
<pre><code>synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class&lt;?&gt; c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }
​
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find <a href="https://www.zhihu.com/search?q=the%20class&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690161827%7D" rel="nofollow" title="the class">the class</a>.
                    long t1 = System.nanoTime();
                    c = findClass(name);
​
                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }</code></pre> 
<p><strong>findLoadedClass ：</strong>先确认类加载任务指定的<a href="https://www.zhihu.com/search?q=%E7%B1%BB%E5%85%A8%E9%99%90%E5%AE%9A%E5%90%8D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690161827%7D" rel="nofollow" title="类全限定名">类全限定名</a>是否已经被加载，没有加载过才能委派；</p> 
<p><strong>findBootstrapClassOrNull ：</strong>如果 parent 为空这是指定了 bootstrap 加载器。</p> 
<p></p> 
<p>为什么要有双亲委派模型？</p> 
<p><br> 一个类在同一个类加载器中具有<strong>唯一性(Uniqueness)</strong>，而不同类加载器中是允许<a href="https://www.zhihu.com/search?q=%E5%90%8C%E5%90%8D%E7%B1%BB&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690161827%7D" rel="nofollow" title="同名类">同名类</a>存在的，这里的同名是指<strong>全限定名相同</strong>。但是在整个JVM里，纵然全限定名相同，若类加载器不同，则仍然不算作是同一个类，无法通过 instanceOf 、<a href="https://www.zhihu.com/search?q=equals&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690161827%7D" rel="nofollow" title="equals">equals</a> 等方式的校验。</p> 
<p>由于唯一性的存在，Class 被替换就有可能了，而双亲委派模型定义了一套类加载的优先层级，很好的防止核心类库被恶意替换。毕竟核心类库是 bootstrap classloader 加载的，而 <a href="https://www.zhihu.com/search?q=bootstrap&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690161827%7D" rel="nofollow" title="bootstrap">bootstrap</a> 是内嵌于JVM的，在双亲委派模型基础上，任何类加载任务都会交由 bootstrap classloader 这位大佬经手过目一次，只要是核心类库中的类，都会被 bootstrap classloader 加载，间接确保核心类库不被其他类加载器加载。</p> 
<p>换言之，在遵循了双亲委派模型的规则之下，是不允许出现核心类库被替换或取代的可能，即不能在自己的 classpath 定义 java.lang.*之类的Class去替换JRE 中的Class。</p> 
<p></p> 
<p>classloader 加载模型是否适用所有场景？</p> 
<p>未必。这个模型最大的局限在于，假定 A 作为 B 的 parent，A 加载的类 对 B 是可见的； 然而 B 加载的类 对 A 却是不可见的。</p> 
<p>这是由 classloader 加载模型中的<strong>可见性(visibility)</strong>决定的</p> 
<blockquote>
  Visibility principle allows child class loader to see all the classes loaded by parent ClassLoader, but parent class loader can not see classes loaded by child. 
</blockquote> 
<p>最典型不适用的场景便是 SPI 的使用。</p> 
<p></p> 
<h3><strong><u>SPI（Service Provider Interface）</u></strong></h3> 
<p></p> 
<p class="img-center"><img alt="" height="112" src="https://images2.imgbox.com/3f/54/isKdDJG9_o.png" width="562"></p> 
<p>Java 在核心类库中定义了许多接口，并且还给出了针对这些接口的调用逻辑，然而并未给出实现。开发者要做的就是定制一个实现类，在 META-INF/services 中注册实现类信息，以供核心类库使用。</p> 
<p></p> 
<p class="img-center"><img alt="" height="326" src="https://images2.imgbox.com/07/36/82uAWYkN_o.png" width="556"></p> 
<p>java.sql.Driver 是最为典型的 SPI 接口，java.sql.DriverManager 通过扫包的方式拿到指定的实现类，完成 DriverManager的初始化。</p> 
<p>等等，似乎有什么不对，根据双亲委派的可见性原则，<strong><a href="https://www.zhihu.com/search?q=%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690161827%7D" rel="nofollow" title="启动类加载器">启动类加载器</a></strong> 加载的 DriverManager 是不可能拿到 <strong>系统应用类加载器</strong> 加载的实现类 ，这似乎通过某种机制打破了双亲委派模型。</p> 
<p></p> 
<h3><strong><u>双亲委派模型并非强制模型</u></strong></h3> 
<p>SPI 是如何打破双亲委派模型的呢？</p> 
<p><strong>java.sql.DriverManager#loadInitialDrivers</strong></p> 
<pre><code>ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);
Iterator&lt;Driver&gt; driversIterator = loadedDrivers.<a href="https://www.zhihu.com/search?q=iterator&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690161827%7D" rel="nofollow" title="iterator">iterator</a>();
​
/* Load these drivers, so that they can be instantiated.
 * It may be the case that the driver class may not be there
 * i.e. there may be a packaged driver with the service class
 * as implementation of java.sql.Driver but the actual class
 * may be missing. In that case a java.util.ServiceConfigurationError
 * will be thrown at runtime by the VM trying to locate
 * and load the service.
 *
 * Adding a try catch block to catch those runtime errors
 * if driver not available in classpath but it's
 * packaged as service and that service is there in classpath.
 */
try{
    while(driversIterator.hasNext()) {
        driversIterator.next();
    }
} catch(Throwable t) {
// Do nothing
}
return null;</code></pre> 
<p><strong>java.util.ServiceLoader#load(java.lang.Class&lt;S&gt;)</strong></p> 
<pre><code>public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}</code></pre> 
<p>通过从线程上下文（ThreadContext）获取 classloader ，借助这个classloader 可以拿到实现类的 Class。</p> 
<p>（源码上讲，这里是通过 Class.forName 配合 classloader拿到的）</p> 
<p>线程上下文 classloader并非具体的某个loader，一般情况下是 application classloader， 但也可以通过 <strong>java.lang.Thread#setContextClassLoader </strong>这个方法指定 classloader。</p> 
<p></p> 
<p>综上，为什么说 Java SPI 的设计会违反双亲委派原则呢？</p> 
<p><strong>首先双亲委派原则本身并非 JVM 强制模型。</strong></p> 
<p>SPI 的调用方和接口定义方很可能都在 Java 的核心类库之中，而实现类交由开发者实现，然而实现类并不会被启动类加载器所加载，基于双亲委派的可见性原则，SPI 调用方无法拿到实现类。</p> 
<p>SPI Serviceloader 通过线程上下文获取能够加载实现类的classloader，一般情况下是 application classloader，绕过了这层限制，逻辑上打破了双亲委派原则。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04af1776978d0dd045cbb10ed3b1b38c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MATLAB的各种疑难杂症和小技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6f5a42f01e217c1ac98633d555814c6b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【函数】各种函数收集，持续更新~</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>