<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python | 打包文件 | 打包 py 文件为可执行文件 .exe - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python | 打包文件 | 打包 py 文件为可执行文件 .exe" />
<meta property="og:description" content="本文总结如何将 python 文件打包成可执行文件 .exe。
Updated: 2022 / 10 / 7
Python | 打包文件 | 打包 py 文件为可执行文件 .exe 总览Pyinstallerother 使用安装打包用法pyinstaller命令spec文件修改spec文件 pipenv 虚拟环境 应用简单的 .py 文件存在前提依赖的复杂项目问题、处理及注意事项 示例依赖资源文件Unix / Linux / MacOS仅打包 py 文件打包依赖资源文件先打包后修改spec先配置spec后打包 windows仅打包 py 文件 参考链接 总览 py 文件打包成 exe 文件的方式一共有三种：
py2exePyInstallercx_Freeze python 作为一门解释型脚本语言，它有三种发布方式 1：
py 文件
源码文件，运行需要使用者安装 Python 环境并且安装依赖的各种库；pyc 文件
pyc 文件是 Python 解释器可以识别的二进制码，可跨平台的，需要使用者安装相应版本的Python 和依赖库。可执行文件
不需要安装 python 环境和依赖库,可针对不同平台需要打包不同的可执行文件( Windows , Linux, Mac, …) Pyinstaller PyInstaller freezes (packages) Python applications into stand-alone executables, under Windows, GNU/Linux, Mac OS X, FreeBSD, Solaris and AIX." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/973358ea980440a5598e06a6a366de5c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-08T23:50:41+08:00" />
<meta property="article:modified_time" content="2022-10-08T23:50:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python | 打包文件 | 打包 py 文件为可执行文件 .exe</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文总结如何将 <code>python</code> 文件打包成可执行文件 <code>.exe</code>。</p> 
<p>Updated: 2022 / 10 / 7</p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>Python | 打包文件 | 打包 py 文件为可执行文件 .exe</h4> 
 <ul><li><a href="#_10" rel="nofollow">总览</a></li><li><ul><li><a href="#Pyinstaller_26" rel="nofollow">Pyinstaller</a></li><li><a href="#other_59" rel="nofollow">other</a></li></ul> 
  </li><li><a href="#_66" rel="nofollow">使用</a></li><li><ul><li><a href="#_80" rel="nofollow">安装</a></li><li><a href="#_97" rel="nofollow">打包</a></li><li><ul><li><a href="#_98" rel="nofollow">用法</a></li><li><ul><li><a href="#pyinstaller_111" rel="nofollow">pyinstaller命令</a></li><li><a href="#spec_168" rel="nofollow">spec文件</a></li><li><ul><li><a href="#spec_196" rel="nofollow">修改spec文件</a></li></ul> 
     </li><li><a href="#pipenv__320" rel="nofollow">pipenv 虚拟环境</a></li></ul> 
    </li><li><a href="#_341" rel="nofollow">应用</a></li><li><ul><li><a href="#_py__342" rel="nofollow">简单的 .py 文件</a></li><li><a href="#_349" rel="nofollow">存在前提依赖的复杂项目</a></li><li><a href="#_365" rel="nofollow">问题、处理及注意事项</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_441" rel="nofollow">示例</a></li><li><ul><li><a href="#_442" rel="nofollow">依赖资源文件</a></li><li><ul><li><a href="#Unix__Linux__MacOS_471" rel="nofollow">Unix / Linux / MacOS</a></li><li><ul><li><a href="#_py__476" rel="nofollow">仅打包 py 文件</a></li><li><a href="#_498" rel="nofollow">打包依赖资源文件</a></li><li><ul><li><a href="#spec_499" rel="nofollow">先打包后修改spec</a></li><li><a href="#spec_525" rel="nofollow">先配置spec后打包</a></li></ul> 
    </li></ul> 
    </li><li><a href="#windows_551" rel="nofollow">windows</a></li><li><ul><li><a href="#_py__556" rel="nofollow">仅打包 py 文件</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_601" rel="nofollow">参考链接</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_10"></a>总览</h2> 
<p><code>py</code> 文件打包成 <code>exe</code> 文件的方式一共有三种：</p> 
<ul><li><code>py2exe</code></li><li><code>PyInstaller</code></li><li><code>cx_Freeze</code></li></ul> 
<p><code>python</code> 作为一门解释型脚本语言，它有三种发布方式 <sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1">1</a></sup>：</p> 
<ul><li><code>py</code> 文件<br> 源码文件，运行需要使用者安装 <code>Python</code> 环境并且安装依赖的各种库；</li><li><code>pyc</code> 文件<br> <code>pyc</code> 文件是 <code>Python</code> 解释器可以识别的二进制码，可跨平台的，需要使用者安装相应版本的<code>Python</code> 和依赖库。</li><li>可执行文件<br> 不需要安装 <code>python</code> 环境和依赖库,可针对不同平台需要打包不同的可执行文件( <code>Windows</code> , <code>Linux</code>, <code>Mac</code>, …)</li></ul> 
<br> 
<h3><a id="Pyinstaller_26"></a>Pyinstaller</h3> 
<p><code>PyInstaller freezes (packages) Python applications into stand-alone executables, under Windows, GNU/Linux, Mac OS X, FreeBSD, Solaris and AIX.</code></p> 
<p>当通过 <code>Python</code> 开发的程序应用需要在其他设备上运行时，需要安装 <code>Python</code> 环境及相应的第三方库，但对方是非技术人员或在离线环境下时，搭建环境比较麻烦，此时可考虑使用 <code>PyInstaller</code> 工具将 <code>python</code> 解析器和脚本打包成一个可执行的文件。<br> 无论是生成的文件夹里的可执行文件或者只打包成一个可执行文件都可以直接运行，前者需要把整个文件夹都给别人。可能运行效率可能会降低，好处就是在使用者的机器上可以不用安装 <code>python</code> 和脚本所依赖的库。</p> 
<blockquote> 
 <ul><li>打包成一个文件夹 <sup class="footnote-ref"><a href="#fn2" rel="nofollow" id="fnref2">2</a></sup><br> <br></li></ul> 
 <blockquote> 
  <p>传输方便（压缩，解压到另外一个电脑，再双击 exe 文件就可以运行），而且debug方便。使用这一方式时，很容易调试在打包 <code>exe</code> 时出现问题。可以准确地看到 <code>pyinstaller</code> 收集了哪些文件到该文件夹。<br> 如果代码发生改变（不涉及依赖包的改变的话），只需要发给别人更新过的 <code>.exe</code> 文件即可。这比更新整个文件夹要方便地多。</p> 
 </blockquote> 
 <blockquote> 
  <p>但是，如果脚本引入了新的依赖包或更改了依赖包，则需要重新分发这一整个文件夹。</p> 
 </blockquote> 
 <ul><li>打包成一个单独的文件 <sup class="footnote-ref"><a href="#fn2" rel="nofollow" id="fnref2:1">2</a></sup><br> <br></li></ul> 
 <blockquote> 
  <p><code>pyinstaller</code> 可以把所有的脚本及其依赖包都打包到一个 <code>.exe</code> 文件中，优点是看不懂文件夹中其他内容的用户可以只得到一个是做什么的 <code>.exe</code> 文件。</p> 
 </blockquote> 
 <blockquote> 
  <p>但是每次更新都要重新发布全部内容（只有1个 <code>.exe</code> 但是体积会大一些），同时，单个文件比单个文件夹启动要慢。</p> 
 </blockquote> 
</blockquote> 
<p>利用 <code>PyInstaller</code> 对指定的的脚本打包时，会先分析脚本所依赖的其他脚本，然后根据导包路径去查找，把所有相关的脚本收集起来，包括 <code>Python</code> 解析器，然后根据你的命令参数可分别生成文件夹，或者打包成一个可执行文件。</p> 
<p><mark>注意</mark><br> <code>PyInstaller</code> 本身可跨平台使用，但通过 <code>PyInstaller</code> 打包出来的文件是无法跨平台的，比如在 <code>Linux</code> 下使用 <code>PyInstaller</code> 打包 <code>Python</code> 程序得到的文件只可在 <code>Linux</code> 下运行；在 <code>Windows</code> 下打包的只可在 <code>Windows</code> 下运行。使用 <code>Pyinstaller</code> 打包得到的 <code>.exe</code> 文件是特定于具体的操作系统和特定的 <code>python</code> 版本的。<br> 也就是说，不具备可移植性。</p> 
<p>若要为以下的环境准备发布版本：</p> 
<ul><li>不同的操作系统</li><li>不同的Python版本</li><li>32/64位不同</li></ul> 
<p>应该针对该平台进行打包，即可以在那个 <code>python</code> 版本，那个操作系统下运行 <code>Pyinstaller</code>。然后执行 <code>Pyinstaller</code> 的 <code>Python</code> 编译器是 <code>bundle</code>（包）的一部分，它会特定于具体的操作系统和特定的字长。</p> 
<br> 
<h3><a id="other_59"></a>other</h3> 
<p>参考这里 <sup class="footnote-ref"><a href="#fn3" rel="nofollow" id="fnref3">3</a></sup></p> 
<p>马克</p> 
<hr> 
<h2><a id="_66"></a>使用</h2> 
<pre><code>PyInstaller analyzes yourprogram.py and:

Writes yourprogram.spec in the same folder as the script
Creates a folder build in the same folder as the script if it does not exist
Writes some log files and working files in the build folder
Creates a folder dist in the same folder as the script if it does not exist
Writes the yourprogram executable folder in the dist folder
In the dist folder you find the bundled app you distribute to your users
</code></pre> 
<br> 
<h3><a id="_80"></a>安装</h3> 
<ul><li> <p>联网：<br> [x] 安装<br> <code>pip install pyinstaller</code>，或者，<br> <code>python -m pip install pyinstaller -i http://mirrors.aliyun.com/pypi/simple/</code>，使用 <code>-i</code> 指定镜像即可<br> [x] 更新<br> <code>pip install --upgrade pyinstaller</code></p> </li><li> <p>离线:<br> 先去官网下载离线安装源 (<code>https://pypi.org/project/PyInstaller/#files</code>)，再进行安装。</p> </li></ul> 
<p><mark>注意</mark> <sup class="footnote-ref"><a href="#fn4" rel="nofollow" id="fnref4">4</a></sup><br> <code>win</code> 安装 <code>PyInstaller</code> 时需要额外安装另外两个模块，<code>pywin32</code> 或 <code>pypiwin32</code>，以及 <code>pefile</code>。<br> 如果使用 <code>pip</code> 进行安装，但是还没有安装 <code>pywin32</code> 时，会自动安装 <code>pypiwin32</code>，<code>pefile</code> 没有时也会自动安装。</p> 
<br> 
<h3><a id="_97"></a>打包</h3> 
<h4><a id="_98"></a>用法</h4> 
<p>基本的命令为 <code>pyinstaller -option xxx.py</code>。</p> 
<p>其中 <code>xxx.py</code> 就是需要打包的 <code>python</code> 脚本，<code>option</code> 为 <code>pyinstaller</code> 中的参数选项，其中 <code>option</code> 默认为 <code>-D</code> 。</p> 
<p>打包完成后主要生成两个文件夹和一个 <code>spec</code> 文件：</p> 
<ol><li><code>dist</code> 文件夹，运行 <code>pyinstaller</code> 命令后会在相同路径下生成，该文件夹下应该会有一个跟程序同名的文件夹（除非使用 <code>pyinstaller -F</code> 命令打包），打包好的 <code>exe</code> 就在该文件夹下。</li></ol> 
<blockquote> 
 <p>如果在命令行中或者 <code>.spec</code> 文件中指定的 <code>.py</code> 文件不止一个，比如 <code>pyinstaller xxx1.py xxx2.py</code>，<code>pyinstaller</code> 会依次分析并执行，并把第一个 <code>py</code> 名称作为 <code>.spec</code> 和 <code>dist</code> 文件下的文件夹和程序的名称。</p> 
</blockquote> 
<ol start="3"><li><code>build</code> 文件夹，运行 <code>pyinstaller</code> 命令后会在相同路径下生成，相当于 <code>Pyinstaller</code> 的工作空间，<code>Pyinstaller</code> 运行相关的文件和日志都在这个文件夹中，打包完成后可以直接删除；</li><li><code>.spec</code> 文件，即配置文件，用于打包复杂的 <code>python</code> 项目。</li></ol> 
<br> 
<h5><a id="pyinstaller_111"></a>pyinstaller命令</h5> 
<ol><li><code>options</code> 参数说明</li></ol> 
<table><thead><tr><th align="center">参数名</th><th align="left">描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>-h</code> / <code>--help</code></td><td align="left">显示帮助信息</td><td align="left">无</td></tr><tr><td align="center"><code>-v</code> / <code>--version</code></td><td align="left">显示版本号</td><td align="left">无</td></tr><tr><td align="center"><code>--distpath</code></td><td align="left">生成文件放在哪里</td><td align="left">默认：当前目录的 <code>dist</code> 文件夹内</td></tr></tbody></table> 
<br> 
<ol start="2"><li>与生成结果有关参数</li></ol> 
<table><thead><tr><th align="center">参数名</th><th align="left">描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>-D</code></td><td align="left">生成 <code>one-folder</code> 的程序（默认），比如 <code>pyinstaller -D demo.py</code></td><td align="left">生成结果是一个目录，各种第三方依赖文件和 <code>DLL</code> 文件等和 <code>demo.exe</code> 同时存储在该目录下。<br><br>打包的文件始终在 <code>Pyinstaller</code> 的<code>bootloader</code>（根引导）中开始执行，这是打包的文件夹中可执行文件的核心。 <code>Pyinstaller bootloader</code> 是活动平台（<code>windows GNU</code> / <code>linux</code> / <code>Mac OS</code> 等）上的一个二进制可执行程序，当用户启动程序时，其实是 <code>bootloader</code> 在运行。<code>bootloader</code> 创建了一个临时的 <code>Python</code> 虚拟环境，这样 <code>Python</code> 编译器 (<code>interpreter</code>) 就可以在这个脚本文件夹中找到所有引入的模块 / 库。<code>bootloader</code> 启动了一个 <code>Python</code> 编译器的副本来执行脚本，后续的执行正常都是从这里开始的，提供被包括在脚本文件夹中所有支持的文件 <sup class="footnote-ref"><a href="#fn2" rel="nofollow" id="fnref2:2">2</a></sup>。</td></tr><tr><td align="center"><code>-F</code></td><td align="left">生成 <code>one-file</code> 的程序，比如 <code>pyinstaller -F demo.py</code></td><td align="left">只在 <code>dist</code> 文件夹中生成一个结果是 <code>demo.exe</code> 文件，不生成其他 <code>dll</code> 文件，适用于没有多依赖 <code>.py</code> 文件的单个文件。可以覆盖打包，无论打包多少次都将是最新的。<br><br>与 <code>-D</code> 模式生成的 <code>exe</code> 程序相比，在启动速度上会慢一些，因为它需要先解压 <code>exe</code> 文件并生成一个唯一的临时环境来运行程序，关闭环境时也会自动删除这个临时环境。而 <code>-D</code> 模式的程序本身就是解压好的，运行完也不需要执行删除操作。<br><br>这一点，在程序的大小比较大时，这个差别就很明显了 <sup class="footnote-ref"><a href="#fn2" rel="nofollow" id="fnref2:3">2</a></sup>。<br><br>运行程序的时候，也会有一个 <code>BootLoader</code>，但是会根据操作系统创建一个名为 <code>_MElxxxxxx</code> 的文件夹，用作这个程序的临时运行环境（不只是 <code>python</code> 环境），这个 <code>xxxxxx</code> 是一个随机的数字。<code>-F</code> 模式程序启动时因为需要解压并拷贝依赖和资源文件到临时运行环境 <code>_MExxxxxx</code>，所以启动速度比 <code>-D</code> 模式慢，运行结束后会删除临时运行环境的文件夹。在 <code>Linux</code> 和相关系统中，可能有 <code>no-execution</code> 选项，但是对于 <code>-F</code> 模式程序是不兼容的。由于 <code>_MElxxxxxx</code> 是唯一的，所以可以同时运行多个程序，多个程序互不干涉。如果程序崩溃了，或者强行结束（在 <code>win</code> 的任务管理器中杀死了进程），<code>_MElxxxxxx</code> 文件夹是不会被删除的，所以频繁崩溃或结束进程会导致有多个 <code>_MElxxxxxx</code> 文件夹，会非常占磁盘空间，可以使用 <code>--runtime-temdir</code> 指定 <code>_MElxxxxxx</code> 的存放位置。<code>-F</code> 模式程序如果在运行时遇到了权限问题，可以使用 <code>-D</code> 模式程序替代。</td></tr><tr><td align="center"><code>-K</code></td><td align="left"><code>-tk</code>，在部署时包含 <code>TCL / TK</code>。</td><td align="left"></td></tr><tr><td align="center"><code>-n NAME</code></td><td align="left"><code>--name NAME</code>，生成 <code>.exe</code> 文件和 <code>.spec</code> 的文件名</td><td align="left">默认为传入的 <code>.py</code> 脚本或者 <code>.spec</code> 文件的名称。</td></tr><tr><td align="center"><code>--specpath DIR</code></td><td align="left">指定生成 <code>spec</code> 文件的路径，默认为当前路径。</td><td align="left">比如，<code>pyinstaller --specpath ./SPEC demo1.py demo2.py</code></td></tr><tr><td align="center"><code>--distpath DIR</code></td><td align="left">指定生成 <code>dist</code> 的目录，默认为 <code>./dist</code></td><td align="left"></td></tr><tr><td align="center"><code>--workpath WORKPATH</code></td><td align="left">指定 <code>pyinstaller</code> 的工作目录，即 <code>build</code> 文件夹，默认为 <code>./build</code>。</td><td align="left"></td></tr><tr><td align="center"><code>-y</code> / <code>--noconfirm</code></td><td align="left">替换输出目录时不询问，默认输出目录是 <code>SPECPATH / dist / SPECNAME</code></td><td align="left"></td></tr><tr><td align="center"><code>--upx-dir UPX_DIR</code></td><td align="left">指定 <code>UPX</code> 程序的路径，默认为 <code>程序执行路径</code>， 即双击某个文件时，系统自动查找对应程序的路径。<code>UPX</code> 为一个压缩程序，需要自行下载，可以将 <code>exe</code> 压缩为 <code>zip</code> 格式的文件，并且压缩效率非常高。如果打包后的 <code>exe</code> 程序非常大的话，为了避免客户下载时文件太大的问题，可以使用 <code>UPX</code> 工具。</td><td align="left"></td></tr><tr><td align="center"><code>-d</code></td><td align="left"><code>-debug</code>，产生 <code>debug</code> 版本的可执行文件。比如 <code>pyinstaller demo.py -d</code></td><td align="left"></td></tr><tr><td align="center"><code>--noupx</code></td><td align="left">不需要 <code>UPX</code> （即便可用）</td><td align="left"></td></tr><tr><td align="center"><code>-a</code> / <code>--ascii</code></td><td align="left">不包含编码。在支持 <code>Unicode</code> 的 <code>python</code> 版本上默认包含所有的编码。</td><td align="left"></td></tr><tr><td align="center"><code>--clean</code></td><td align="left">在 <code>pyinstaller</code> 开始执行前清楚缓存并删除临时文件（一般存储在 <code>C:\Users\Administrator\AppData\Roaming\pyinstaller</code>）。</td><td align="left"></td></tr><tr><td align="center"><code>--log-level LEVEL</code></td><td align="left">指定打印的日志等级，默认为 <code>INFO</code>。日志等级有 <code>TRACE</code>, <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, <code>CRITICAL</code>。如果在打包时遇到了问题，为了方便定位问题，可以使用这个参数来查看特定级别的日志信息。</td><td align="left"></td></tr></tbody></table> 
<br> 
<ol start="3"><li>数据绑定和搜索相关的参数选项：</li></ol> 
<table><thead><tr><th align="center">参数名</th><th align="left">描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>--add-data SRC;DEST</code></td><td align="left">指定需要添加非二进制文件路径或者文件夹路径，比如图片和 <code>pdf</code> 文件等，这个选项可以使用多次。这个命令其实就是将需要的文件或者文件夹拷贝到指定的路径下，在 <code>-D</code> 模式下，可以看情况在程序打包完成后自己手动拷贝过去。</td><td align="left"></td></tr><tr><td align="center"><code>--add-binary SRC;DEST</code></td><td align="left">指定需要添加的二进制文件路径，比如 <code>DLL</code> 文件、动态链接库或者共享文件对象等，这个选项可以使用多次。同 <code>-add-data</code> 命令一样，是一个拷贝数据的功能。</td><td align="left"></td></tr><tr><td align="center"><code>-o DIR</code></td><td align="left"><code>--out=DIR</code>，指定 <code>spec</code> 文件的生成目录。如果没有制定，则默认使用当前的目录以生成 <code>spec</code> 文件。</td><td align="left"></td></tr><tr><td align="center"><code>-p DIR</code></td><td align="left"><code>--paths DIR</code>，设置导入路径 (和使用 <code>PYTHONPATH</code> 效果相似).可以用路径分割符 (<code>Windows</code> 使用分号, <code>Linux</code> 使用冒号)分割。<br><br>指定多个目录，也可以使用多个 <code>-p</code> 参数来设置多个导入路径，让 <code>pyinstaller</code> 自己去找程序需要的资源 <sup class="footnote-ref"><a href="#fn5" rel="nofollow" id="fnref5">5</a></sup>。</td><td align="left"></td></tr><tr><td align="center"><code>--hidden-import MODULENAME/--hiddenimport MODULENAME</code></td><td align="left">指定脚本中需要隐式导入的模块，比如在 <code>__import__</code> 、<code>imp.find_module()</code> 、<code>exec</code> 、<code>eval</code> 等语句中导入的模块，这些模块 <code>PyInstaller</code> 是找不到的，需要手动指定导入，这个选项可以使用多次。</td><td align="left"></td></tr><tr><td align="center"><code>--additional-hooks-dir HOOKSPATH</code></td><td align="left">指定额外 <code>hook</code> 文件（可以是 <code>py</code> 文件）的查找路径，这些文件的作用是在 <code>PyInstaller</code> 运行时改变一些 <code>Python</code> 或者其他库原有的函数或者变量的执行逻辑（并不会改变这些库本身的代码），以便能顺利的打包完成，这个选项可以使用多次。</td><td align="left"></td></tr><tr><td align="center"><code>--runtime-hook RUNTIME_HOOKS</code></td><td align="left">指定自定义的运行时 <code>hook</code> 文件路径（可以是 <code>py</code> 文件），在打好包的 <code>exe</code> 程序中，在运行这个<code>exe</code> 程序时，指定的 <code>hook</code> 文件会在所有代码和模块之前运行，包括 <code>main</code> 文件，以满足一些运行环境的特殊要求，这个选项可以使用多次。</td><td align="left"></td></tr><tr><td align="center"><code>--exclude-module EXCLUDES</code></td><td align="left">指定可以被忽略的可选的模块或包，因为某些模块只是 <code>PyInstaller</code> 根据自身的逻辑去查找的，这些模块对于 <code>exe</code> 程序本身并没有用到，但是在日志中还是会提示 <code>module not found</code> ，这种日志可以不用管，或者使用这个参数选项来指定不用导入，这个选项可以使用多次。</td><td align="left"></td></tr><tr><td align="center"><code>--key KEY</code></td><td align="left">指定用于 <code>Python</code> 字节码加密的 <code>key</code>，<code>key</code> 是一个16个字符的字符串。</td><td align="left"></td></tr></tbody></table> 
<ol start="4"><li><code>Windows</code> 和 <code>Mac</code> 特有的参数</li></ol> 
<table><thead><tr><th align="center">参数名</th><th align="left">描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>-c</code></td><td align="left">提供一个命令行窗口进行 <code>I/O</code>，比如 <code>pyinstaller -c demo.py</code></td><td align="left">与 <code>-w</code> 相反，默认含有此参数</td></tr><tr><td align="center"><code>-w</code></td><td align="left"><code>-</code>，程序运行后隐藏命令行窗口，比如 <code>pyinstaller -w demo.py</code></td><td align="left">编写 <code>GUI</code> 程序时使用此参数有用，比如当你不需要使用命令行窗口作为程序的 <code>I/O</code> 时；<br><br>如果想程序运行的时候与程序进行交互，则不加该参数。</td></tr><tr><td align="center"><code>-i</code></td><td align="left"><code>--icon</code>，为 <code>main.exe</code> 指定图标，比如 <code>pyinstaller -i D:\icons\demo.ico demo.py</code>。</td><td align="left">给生成的 <code>demo.exe</code> 文件设置一个自定义的图标 <code>D:\icons\demo.ico</code>。</td></tr></tbody></table> 
<br> 
<h5><a id="spec_168"></a>spec文件</h5> 
<p>当执行打包命令时，<code>PyInstaller</code> 首先建一个 <code>sepc</code> (<code>specification</code>) 文件 <code>script.spec</code>，默认放在当前文件夹下，默认名为 <code>xxx.spec</code> 配置文件。<br> <code>spec</code> 文件的作用是什么呢？生成 <code>spec</code> 文件时可以什么都不指定，它会告诉 <code>PyInstaller</code> 如何处理你的 <code>py</code> 文件，它会将你的 <code>py</code> 文件名字和输入的大部分参数进行编码。<code>PyInstaller</code> 通过执行 <code>spec</code> 文件中的内容来生成 <code>exe</code>，有点像 <code>makefile</code>。</p> 
<p><code>spec</code> 文件其实就是一个 <code>py</code> 文件，在编辑时可以直接将它当作一个 <code>py</code> 文件来使用。</p> 
<p>正常使用中我们是不需要管 <code>spec</code> 文件的，但是下面几种情况需要修改 <code>spec</code> 文件：</p> 
<ul><li> 
  <ol><li>需要打包资源文件；<br> 可以在 <code>spec</code> 文件中单独用一个列表变量来制定，可读性和可维护性会高很多。</li></ol> </li><li> 
  <ol start="2"><li>需要 <code>include</code> 一些 <code>PyInstaller</code> 不知道的库；<br> 比如 <code>.dll</code> 或者 <code>.so</code> 文件，同样可以在 <code>spec</code> 文件中单独用一个列表变量来制定。</li></ol> </li><li> 
  <ol start="3"><li>为可执行文件添加一些运行时的选项，比如 <code>run-time</code> 选项和<code>hook</code>文件；</li></ol> </li><li> 
  <ol start="4"><li>多程序打包。</li></ol> </li></ul> 
<p>若我们所需的场景符合上面所描述的任意一个，则需要在打包前生成 <code>spec</code> 文件并修改。生成一个纯粹的 <code>spec</code> 文件的命令如下：</p> 
<pre><code class="prism language-python">pyi<span class="token operator">-</span>makespec <span class="token operator">-</span>options xxx<span class="token punctuation">.</span>py <span class="token punctuation">[</span>other scripts<span class="token punctuation">]</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/63/2b/gxbahilX_o.png" alt="在这里插入图片描述" width="500"><br> 出现图片上的提示，即为生成 <code>spec</code> 文件成功。<br> 生成并修改 <code>spec</code> 文件后，可以根据 <code>spec</code> 文件进行打包，具体命令如下：</p> 
<pre><code class="prism language-python">pyinstaller xxx<span class="token punctuation">.</span>spec
</code></pre> 
<br> 
<h6><a id="spec_196"></a>修改spec文件</h6> 
<p><code>spec</code> 文件默认的结示例如下：</p> 
<pre><code class="prism language-python">block_cipher <span class="token operator">=</span> <span class="token boolean">None</span>


a <span class="token operator">=</span> Analysis<span class="token punctuation">(</span>
    <span class="token punctuation">[</span><span class="token string">'script.py'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    pathex<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    binaries<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    datas<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    hiddenimports<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    hookspath<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    hooksconfig<span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    runtime_hooks<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    excludes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    win_no_prefer_redirects<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
    win_private_assemblies<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
    cipher<span class="token operator">=</span>block_cipher<span class="token punctuation">,</span>
    noarchive<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
pyz <span class="token operator">=</span> PYZ<span class="token punctuation">(</span>a<span class="token punctuation">.</span>pure<span class="token punctuation">,</span> a<span class="token punctuation">.</span>zipped_data<span class="token punctuation">,</span> cipher<span class="token operator">=</span>block_cipher<span class="token punctuation">)</span>

exe <span class="token operator">=</span> EXE<span class="token punctuation">(</span>
    pyz<span class="token punctuation">,</span>
    a<span class="token punctuation">.</span>scripts<span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    exclude_binaries<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
    name<span class="token operator">=</span><span class="token string">'script'</span><span class="token punctuation">,</span>
    debug<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
    bootloader_ignore_signals<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
    strip<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
    upx<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
    console<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
    disable_windowed_traceback<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
    argv_emulation<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
    target_arch<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>
    codesign_identity<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>
    entitlements_file<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
coll <span class="token operator">=</span> COLLECT<span class="token punctuation">(</span>
    exe<span class="token punctuation">,</span>
    a<span class="token punctuation">.</span>binaries<span class="token punctuation">,</span>
    a<span class="token punctuation">.</span>zipfiles<span class="token punctuation">,</span>
    a<span class="token punctuation">.</span>datas<span class="token punctuation">,</span>
    strip<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
    upx<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
    upx_exclude<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    name<span class="token operator">=</span><span class="token string">'script'</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
</code></pre> 
<p><code>spec</code> 文件是一个 <code>python</code> 脚本，文件中主要包含4个 <code>class</code> : <code>Analysis</code>, <code>PYZ</code>, <code>EXE</code> 和<code>COLLECT</code> <sup class="footnote-ref"><a href="#fn4" rel="nofollow" id="fnref4:1">4</a></sup>’ <sup class="footnote-ref"><a href="#fn6" rel="nofollow" id="fnref6">6</a></sup>。</p> 
<table><thead><tr><th align="center">变量</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center"><code>a</code></td><td align="left"><code>Analysis</code> 的实例，要求传入各种脚本用于分析程序的导入和依赖。</td></tr><tr><td align="center"></td><td align="left"><code>scripts</code>，它是一个脚本列表，可以传入多个 <code>py</code> 脚本，效果与命令行中指定多 <code>py</code> 文件相同，即 <code>py</code> 文件不止一个时，比如 <code>pyinstaller xxx1.py xxx2.py</code>，<code>pyinstaller</code> 会依次分析并执行，并把第一个 <code>py</code> 名称作为 <code>spec</code> 和 <code>dist</code> 文件下的文件夹和程序的名称;</td></tr><tr><td align="center"></td><td align="left"><code>pathex</code>，同命令 <code>-p DIR / --paths DIR</code>，其实默认就有一个 <code>spec</code> 的目录，如果使用命令添加的话，会首先添加命令中指定的目录，再添加默认的路径。<br><br>它定义了打包的主目录（生成 <code>spec</code> 文件的时候会自动填充好主目录路径），对于在此目录下的 <code>py</code> 文件可以只写文件名不写路径。</td></tr><tr><td align="center"></td><td align="left"><code>datas</code>，添加数据文件，命令是 <code>--add-data</code>，<code>spec</code>。<br><br>文件中是 <code>Analysis</code> 的 <code>datas = []</code> 参数，<code>datas</code> 是一个元素为元祖的列表，每个元祖都有两个元素，元祖的基本格式为<code>（”原项目中资源文件路径” , ”打包后的文件路径”）</code>，都必须是字符串类型，元祖的第一个元素为数据文件或文件夹，元祖的第二个元素为运行时这些文件或文件夹的位置。<br><br>例如，<code>datas = [("src/README.txt", "."), ]</code>，也可以在命令中中这样写 <code>pyinstaller --add-data "src/README.txt; ." myscript.py</code>，表示打包时将文件 <code>src/README.txt</code> 添加到相对于 <code>spec</code> 文件的根目录下，指定文件时是相对于 <code>spec</code> 来进行寻找的，而不是要打包的 <code>exe</code> 程序路径。<br><br>可以使用通配符 <code>datas = [("/mygame/sfx/*.mp3", "sfx")]</code>，表示将 <code>/mygame/sfx/</code> 目录下的 <code>.mp3</code> 文件都拷贝到 <code>sfx</code> 文件夹中。<br>也可以添加整个文件夹 <code>datas=[("/mygame/data", "data")]</code>，表示将 <code>/mygame/data</code> 文件夹下所有的文件都拷贝到 <code>data</code> 文件夹下。</td></tr><tr><td align="center"></td><td align="left"><code>binaries</code>，添加二进制为摁键，效果同命令 <code>--add-binary</code>，也是一个列表，定义方式与 <code>datas</code> 参数一样。</td></tr><tr><td align="center"></td><td align="left"><code>hiddenimports</code>，同命令 <code>--hidden-import MODULENAME/--hiddenimport MODULENAME</code>。<br><br>一般而言都是在生成可执行程序<code>exe</code> 的过程中抛出 <code>No Module named xxx</code> 错误才会发现这些遗漏的模块，碰到这些异常，只需在 <code>spec</code> 文件中添加对应的遗漏模块即可。</td></tr><tr><td align="center"></td><td align="left"><code>hookspath</code>，同命令 <code>--additional-hooks-dir HOOKSPATH</code></td></tr><tr><td align="center"></td><td align="left"><code>runtime_hooks</code>，同命令 <code>--runtime-hook RUNTIME_HOOKS</code></td></tr><tr><td align="center"></td><td align="left"><code>exclude</code>，同命令 <code>--exclude-module EXCLUDES</code>，以排除某些用不到的模块 <sup class="footnote-ref"><a href="#fn5" rel="nofollow" id="fnref5:1">5</a></sup>。</td></tr><tr><td align="center"><code>PYZ</code></td><td align="left"><code>PYZ</code> 的实例，是一个 <code>.pyz</code> 文件，包含程序运行需要的所有依赖；</td></tr><tr><td align="center"><code>EXE</code></td><td align="left"><code>EXE</code> 的实例，这个类用来处理 <code>Analysis</code> 和 <code>PYZ</code> 的结果的，也是用来生成最后的 <code>exe</code> 可执行程序；</td></tr><tr><td align="center"></td><td align="left"><code>console</code>, 设置是否显示命令行窗口，和命令 <code>-w</code> / <code>-c</code> 作用一样。</td></tr><tr><td align="center"></td><td align="left"><code>icon</code>，设置程序图标，和命令 <code>-i</code> / <code>--icon</code> 作用一样。某些情况，直接执行 <code>pyinstaller xxx.py</code> 时生成的 <code>spec</code> 中没有这个参数，需要手动添加，参数值就是图片路径的字符串。</td></tr><tr><td align="center"><code>COLL</code></td><td align="left"><code>COLLECT</code> 类的实例，用于创建输出目录。<br>在 <code>-F</code> 模式下，是没有 <code>COLLECT</code> 实例的，并且所有的脚本、模块和二进制文件都包含在了最终生成的 <code>exe</code> 文件中。</td></tr></tbody></table> 
<br> 
<p>以下的全局变量也可以在 <code>spec</code> 文件中使用 <sup class="footnote-ref"><a href="#fn4" rel="nofollow" id="fnref4:2">4</a></sup>：</p> 
<table><thead><tr><th align="center">全局变量</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center"><code>DISPATH</code></td><td align="left">相对于 <code>dist</code> 文件夹的相对路径，如果 <code>--dispath</code> 参数选项呗指定了，则使用被指定的参数值。</td></tr><tr><td align="center"><code>HOMEPATH</code></td><td align="left"><code>pyinstaller</code> 查找的绝对路径，一般是 <code>python</code> 解释器的 <code>site-packages</code> 文件夹的绝对路径。</td></tr><tr><td align="center"><code>SPEC</code></td><td align="left">在命令行中指定的 <code>spec</code> 文件路径。</td></tr><tr><td align="center"><code>SPECHPATH</code></td><td align="left"><code>spec</code> 文件的文件名，不包括文件类型后缀。</td></tr><tr><td align="center"><code>specnm</code></td><td align="left"><code>spec</code> 文件的文件名，不含文件类型后缀。</td></tr><tr><td align="center"><code>workpath</code></td><td align="left">相对于 <code>build</code> 文件夹的相对路径，如果 <code>workpath=参数选项</code> 呗指定了，这使用呗指定的值。</td></tr><tr><td align="center"><code>WARNFILE</code></td><td align="left">在 <code>build</code> 文件夹中警告文件的全路径。一般是 <code>warn-myscript.txt</code>。</td></tr></tbody></table> 
<blockquote> 
 <p>当命令行和 <code>spec</code> 中指定了相同的参数选项，那么命令行的参数选项会被忽略。</p> 
</blockquote> 
<p>在对 <code>python</code> 项目进行打包修改 <code>sepc</code> 文件时，主要是以对 <code>analysis</code> 进行修改和配置为主。<br> 以针对多脚本、多目录的 <code>python</code> 项目为例，一般而言对 <code>spec</code> 文件的配置都包含如下一些操作：</p> 
<ul><li> 
  <ol><li><code>py</code> 文件打包配置<br> <code>Analysis</code> 的第一个参数（如 <code>[script.py]</code>）为需要解析的 <code>py</code> 脚本。针对多目录多脚本的 <code>python</code> 项目，打包时需要将所有相关的 <code>py</code> 脚本文件都添加到 <code>Analysis</code> 类里，即第一个参数中，参考 <sup class="footnote-ref"><a href="#fn7" rel="nofollow" id="fnref7">7</a></sup>’ <sup class="footnote-ref"><a href="#fn8" rel="nofollow" id="fnref8">8</a></sup> 中给出的例子。</li></ol> </li><li> 
  <ol start="2"><li>资源文件打包配置<br> 资源文件包括打包的 <code>python</code> 项目使用的相关文件，如模型配置文件、模型数据文件或者图标文件、文本文件等。<br> 对于此类资源文件的打包需要设置 <code>Analysis</code> 的 <code>datas</code>。比如， <code>('data','data')</code> 表示将 <code>C:\\Users\\RYW\\Desktop\\test\\data</code> 下的所有资源文件打包后放入打包结果路径下的 <code>data</code> 目录中，参考 <sup class="footnote-ref"><a href="#fn7" rel="nofollow" id="fnref7:1">7</a></sup>’ <sup class="footnote-ref"><a href="#fn8" rel="nofollow" id="fnref8:1">8</a></sup> 中给出的例子。</li></ol> </li><li> 
  <ol start="3"><li><code>Hidden import</code> 配置<br> <code>pyinstaller</code> 在进行打包时，会解析打包的 <code>python</code> 文件，自动寻找 <code>py</code> 源文件的依赖模块。但是 <code>pyinstaller</code> 解析模块时可能会遗漏某些模块（<code>not visible to the analysis phase</code>），造成打包后执行程序时出现类似 <code>No Module named xxx</code>。这时我们就需要在 <code>Analysis</code> 下 <code>hiddenimports</code> 中加入遗漏的模块，参考 <sup class="footnote-ref"><a href="#fn7" rel="nofollow" id="fnref7:2">7</a></sup>’ <sup class="footnote-ref"><a href="#fn8" rel="nofollow" id="fnref8:2">8</a></sup> 中给出的例子。</li></ol> </li><li> 
  <ol start="4"><li>递归深度设置<br> 在打包导入某些模块时，常会出现 <code>RecursionError: maximum recursion depth exceeded</code> 的错误，这可能是打包时出现了大量的递归超出了 <code>python</code> 预设的递归深度。因此需要在 <code>spec</code> 文件上添加递归深度的设置，设置一个足够大的值来保证打包的进行，即：</li></ol> </li></ul> 
<pre><code class="prism language-python"><span class="token keyword">import</span> sys
sys<span class="token punctuation">.</span>setrecursionlimit<span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span>
</code></pre> 
<br> 
<blockquote> 
 <p>运行时信息：</p> 
 <ul><li><code>__file__</code><br> 所有基于模块的使用到 <code>__file__</code> 属性的代码，在代码运行时表示的是当前脚本的绝对路径，但是打包后就是当前模块的模块名（即文件名 <code>xxx.py</code>）。<br> <br></li><li><code>sys.frozen</code><br> 源码运行时没有这个属性，打包后的程序添加了这个属性，值为True。<br> <br></li><li><code>sys._MEIPASS</code><br> 源码运行时没有这个属性，打包后的程序添加了这个属性，表示程序运行的绝对路径。<br> 对于 <code>-D</code> 模式程序，表示的是这个 <code>exe</code> 程序所在文件夹的绝对路径；<br> 对于 <code>-F</code> 模式程序，表示的是 <code>_MElxxxxxx</code> 的文件夹绝对路径，<code>_MElxxxxxx</code> 为 <code>exe</code> 解压后创建的临时运行环境的文件夹名称。对于 <code>exe</code> 程序每一次运行来说，它是唯一的。</li><li><code>sys.executable</code><br> 代码运行时表示运行的解释器绝对路径，比如 <code>C:\Python36\python.exe</code>，在打包的程序中就是 <code>exe</code> 程序文件的绝对路径，这个是用来定位用户运行该程序的真实位置。<br> <code>sys.argv[0]</code><br> 一般来说就是运行程序的绝对路径，但是在不同平台或者不同的方式启动程序时会有所不同，比如通过符号连接运行的 <code>sys.argv[0]</code> 就是符号名称，而不是真实的程序路径。</li></ul> 
</blockquote> 
<br> 
<h5><a id="pipenv__320"></a>pipenv 虚拟环境</h5> 
<p>打包生成的可执行文件过大的原因可能是因为 <code>anaconda</code> 环境下打包时引入了很多不必要的文件。<br> 最简办法是用 <code>pipenv</code> 创建纯净环境。在纯净环境下，<code>pip</code> 安装程序所需要的第三方库，再打包程序 <sup class="footnote-ref"><a href="#fn9" rel="nofollow" id="fnref9">9</a></sup>。</p> 
<ol><li><code>pip install pipenv</code></li><li><code>pipenv --python 3.9</code><br> 在当前目录创建3.9版本的 <code>python</code> 环境，注意 <code>python 3.9</code> 是利旧，利用旧有版本的 <code>python</code> 编译器，创建纯净的 <code>python 3.9</code> 虚拟环境;<br> 比如，当前 <code>python</code> 版本是 <code>3.9</code>，<code>pipenv --python 3.8</code> 就会报错，是利旧的方式，而不是新增的方式，创建虚拟环境。<br> 如果报 <code>virtualenv.py: error: no such option: --creator</code>，<code>Failed to create virtual environment</code>，则先使用 <code>pip install virtualenv --upgrade</code>，然后 <code>virtualenv --version</code> 确认 <code>virtualenv</code> 被成功安装和升级 <sup class="footnote-ref"><a href="#fn10" rel="nofollow" id="fnref10">10</a></sup>。</li><li><code>pipenv shell</code><br> 打开 <code>pipenv</code> 的命令行</li><li><code>pip install XXX</code><br> 在 <code>pipenv shell</code> 下安装所要打包的程序用到的第三方库。<br> 比如 <code>pandas</code>、<code>openpyxl</code>、以及打包所用的 <code>pyinstaller</code>。</li><li><code>pip list</code><br> 在 <code>pipenv shell</code> 下使用 <code>pip list</code> 查看已有的库文件，可以看到，环境很纯净，只有第三方库及其依赖文件。</li><li><code>pyinstaller -F xxx.py</code> 打包。</li></ol> 
<blockquote> 
 <p>如果期间因为某些原因操作中断后找不到此前创建的 <code>pipenv</code> 虚拟环境，参考这里 <sup class="footnote-ref"><a href="#fn11" rel="nofollow" id="fnref11">11</a></sup> 找回原有虚拟环境。</p> 
</blockquote> 
<br> 
<h4><a id="_341"></a>应用</h4> 
<h5><a id="_py__342"></a>简单的 .py 文件</h5> 
<p>对一个简单 <code>.py</code> 文件，当没有依赖的其他路径下的 <code>.py</code> 文件、没有间接依赖的其他包、没有依赖的资源文件时，可使用命令 <code>pyinstaller –F xxx.py</code> ，直接打包成一个 <code>exe</code> 文件。</p> 
<p>使用命令 <code>pyinstaller -c –F xxx.py</code> 直接打包 <code>xxx.py</code> 文件。</p> 
<br> 
<h5><a id="_349"></a>存在前提依赖的复杂项目</h5> 
<p>一般而言，实际的项目往往是复杂的，或有许多依赖的其他路径下的 <code>.py</code> 文件，或有许多间接依赖的包，或有许多设计的资源文件。</p> 
<p>针对多脚本的 <code>python</code> 项目可以通过修改 <code>spec</code> 文件的方法进行打包。</p> 
<blockquote> 
 <p>也可以通过核心命令 <code>pyinstaller -F xxx.py -p py_dir</code> 进行打包。但是在实际打包过程中或者即便打包成功后但是在执行可执行程序时，经常会遇到错误使得我们还是得去修改 <code>spec</code> 文件重新打包执行程序。因此，本文直接使用修改 <code>spec</code> 文件再根据 <code>spec</code> 文件的方法对这几种类型的 <code>python</code> 项目打包示例进行讲解，对于使用核心命令对多个程序进行打包的案例，可以参考这里 <sup class="footnote-ref"><a href="#fn12" rel="nofollow" id="fnref12">12</a></sup>，本文不再讲述。一般而言，大部分项目都会涉及多个脚本并包含数据资源文件。</p> 
</blockquote> 
<p>由 <code>spec</code> 配置文件打包发布完毕后，必定会在 <code>dist</code> 中生成一个文件夹，里面不只有生成的<code>exe</code> 文件，还有许多其他的依赖文件。此模式下，通常使用命令 <code>pyinstaller –D xxx.spec</code> 进行发布。</p> 
<p>基本步骤：</p> 
<ul><li> 
  <ol><li>生成 <code>spec文件</code><br> 执行命令 <code>pyi-makespec xxx.py</code> ，执行后生成 <code>xxx.spec</code> 文件（ <code>xxx.py</code> 是项目启动的入口文件）；</li></ol> </li><li> 
  <ol start="2"><li>完善 <code>spec</code> 文件中的内容</li></ol> </li><li> 
  <ol start="3"><li>根据 <code>spec</code> 再次进行打包</li></ol> </li></ul> 
<br> 
<h5><a id="_365"></a>问题、处理及注意事项</h5> 
<p>参考 <sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1:1">1</a></sup>’ <sup class="footnote-ref"><a href="#fn8" rel="nofollow" id="fnref8:3">8</a></sup></p> 
<ol><li> <p>当双击 <code>exe</code> 文件无法看到错误信息时，可尝试通过 <code>cmd</code> 进入对应目录后命令运行 <code>xxx.exe</code>;</p> </li><li> <p>当打包成功，且中间没有发生任何警告提示，但是运行程序时提示某个模块找不到，可能是 <code>--hidden-import=</code> 的问题。对于不知道 <code>hiddenimports</code> 里面具体依赖的包有哪些，一个笨办法是，在 <code>cmd</code> 下执行<code>xxx.exe</code>，根据提示的错误信息，逐一加上缺失的包 <sup class="footnote-ref"><a href="#fn7" rel="nofollow" id="fnref7:3">7</a></sup>。</p> </li><li> <p>杀毒软件可能会干预，最好打包发布前退出杀毒软件。</p> </li><li> <p><code>Unable to find "nltk_data" when adding binary and data files</code><br> 这种错误发生在生成 <code>exe</code> 可执行程序时，会导致生成 <code>exe</code> 失败。这是 <code>PyInstaller</code> 的 <code>hook</code> 文件夹在处理 <code>nltk</code> 时出现这样的错误，参考 <sup class="footnote-ref"><a href="#fn7" rel="nofollow" id="fnref7:4">7</a></sup>。</p> </li><li> <p><code>XGBoostLibraryNotFound:Connot find XGBoost Library in …</code> 的报错，参考 <sup class="footnote-ref"><a href="#fn7" rel="nofollow" id="fnref7:5">7</a></sup>。</p> </li><li> <p><code>FileNotFoundError:No such file or directory：…</code>（数据资源未能成功打包），参考 <sup class="footnote-ref"><a href="#fn7" rel="nofollow" id="fnref7:6">7</a></sup>。</p> </li><li> <p>无论在哪个目录下执行 <code>pyinstaller</code> 的命令，默认打包完成的文件或文件夹就在该目录。</p> </li><li> <p>路径最好为英文，没有中文字符。</p> </li><li> <p>脚本名称里应当没有特殊字符。</p> </li><li> <p>使用 <code>utf-8</code> 编码。</p> </li><li> <p>图标文件必须是正常格式，为 <code>.ico</code> 文件。</p> </li><li> <p>命令使用 <code>pyinstaller</code> 和 <code>pyinstaller.exe</code> 结果都是一样的。</p> </li><li> <p>参数的添加得在 <code>pyinstaller</code> 和 <code>demo.py</code> 文件中间，不能随意位置添加。</p> </li><li> <p>如果打包的代码中用到了静态文件，如图片和资源文件，需配置 <code>spec</code> 文件将相关文件复制到 <code>dist</code> 文件夹或其子文件夹下，否则 <code>exe</code> 文件会报找不到文件的错。</p> </li><li> <p>代码里导入 <code>python</code> 包最好使用 <code>from * import *</code> 的方式，而不是 <code>import *</code>,可以节省打包后的文件大小。因为使用 <code>import *</code> 时，<code>pyinstaller</code> 打包时会将 <code>python</code> 解释器及项目中使用的整个模块复制过去，此时打出来的包就会很大 <sup class="footnote-ref"><a href="#fn13" rel="nofollow" id="fnref13">13</a></sup>。</p> </li><li> <p>当使用错误的参数去打包或打包到一半中断等等此类运行到一半没了的情况，会导致原来的 <code>.py</code> 文件变成一个 <code>0 KB</code> 的空文件，里面的代码会全部消失。因此，最好复制一份代码出来，用这个副本进行打包。</p> </li><li> <p><code>pygame</code> 代码调试的时候要在结束时加 <code>quit()</code>，不然程序会崩溃。</p> </li><li> <p>如果在 <code>py</code> 文件中用到了多进程，且在 <code>windows</code> 下编译需要加一行代码在开头，<code>multiprocessing.freeze_support()</code></p> </li><li> <p>打包的时候要进入到能运行这个 <code>.py</code> 文件的虚拟环境中，不能在别的环境中对 <code>.py</code> 文件打包，不然打包的结果还是原来的环境，可能打包文件过大，或者引起缺失包等其他问题。</p> </li><li> <p>如果打包错误，可查看 <code>build</code> 里的 <code>warn_script.txt</code> 文档，里面详细记载了错误的原因。一般都是库丢失。</p> </li><li> <p>出现 <code>IndexError: tuple index out of range</code>，出现这个是由于当前的 <code>pyinstaller</code> 版本不支持 <code>python</code> 的版本。解决方法是修改 <code>pyinstaller</code> 的版本，<code>pip install pyinstaller == 适合你的版本</code>。</p> </li><li> <p>出现 <code>ImportError: C extension: No module named ‘pandas._libs.tslibs.timedeltas’</code>，出现这个是由于代码中引入了 <code>pandas</code> 库但是使用 <code>pyinstaller</code> 打包时显示模块缺失。可以选择：<br> 暂时忽略此模块，即打包时加上 <code>--hidden-import=pandas._libs.tslibs.timedeltas</code>。或者，<br> 在 <code>python3</code> 的安装路径下找到 <code>Pyinstaller/hooks</code> 的位置，如 <code>C:\Python36\Lib\site-packages\PyInstaller\hooks</code> 中新建文件 <code>hook-pandas.py</code> 并填写以下内容：</p> </li></ol> 
<pre><code class="prism language-python">hiddenimports <span class="token operator">=</span> <span class="token punctuation">[</span>
<span class="token comment"># all your previous hidden imports</span>
`pandas`<span class="token punctuation">:</span> `pandas<span class="token punctuation">.</span>_libs<span class="token punctuation">.</span>tslibs<span class="token punctuation">.</span>timedeltas`
<span class="token punctuation">]</span>
</code></pre> 
<ol start="23"><li> <p>出现 <code>module not found</code> 警告时，可能并不需要对此进行特殊处理。只是 <code>Pyinstaller</code> 根据自身的逻辑去查找相应的模块，因为它们并不是跟你的最终程序有关的。</p> </li><li> <p>出现 <code>File "c:\python36\lib\site-packages\PyInstaller\hooks\pre_safe_import_module\hook-setuptools.extern.six.moves.py", line 34, in pre_safe_import_module for real_module_name, six_module_name in real_to_six_module_name.items(): AttributeError: 'str' object has no attribute 'items'</code>, 解决方案是使用 <code>pip install --upgrade setuptools</code> 更新第三方库 <code>setuptools</code> <sup class="footnote-ref"><a href="#fn4" rel="nofollow" id="fnref4:3">4</a></sup>。</p> </li><li> <p>由 <code>pyinstaller</code> 打包的 <code>.py</code> 项目，路径建议使用 <code>os.path.join</code>，由此可以避免跨平台时由于路径表达不同导致的问题，且不会出现相对路径的问题 <sup class="footnote-ref"><a href="#fn13" rel="nofollow" id="fnref13:1">13</a></sup>。</p> </li><li> <p>为避免程序使用的图标无法显示、程序使用的关联文件无法关联，或者，程序使用的文件路径发生改变引入的问题，可以根据执行路径进行路径 "冻结“。参考这里 <sup class="footnote-ref"><a href="#fn14" rel="nofollow" id="fnref14">14</a></sup>。</p> </li><li> <p>如果本机安装了很多模块，使用 <code>pyinstaller</code> 打包的时候就会把已安装的模块都打包进去，从而导致打包生成的 <code>exe</code> 文件特别大。因此可以结合 <code>pipenv</code> 打包，参考这里 <sup class="footnote-ref"><a href="#fn7" rel="nofollow" id="fnref7:7">7</a></sup>。</p> </li><li> <p>在打包导入了 <code>pandas</code> 和 <code>numpy</code> 模块的 <code>.py</code> 文件时可能出现如下的报错：</p> </li></ol> 
<p><img src="https://images2.imgbox.com/ec/a6/4u5Wfmig_o.png" alt="在这里插入图片描述"><br> 按照提示先安装 <code>openpyxl</code>，此外还需要注意版本冲突 <sup class="footnote-ref"><a href="#fn15" rel="nofollow" id="fnref15">15</a></sup>，再进行打包。<br> 此时，可以通过修改 <code>.spec</code> 文件对 <code>pandas</code> 和 <code>numpy</code> 打包 <sup class="footnote-ref"><a href="#fn16" rel="nofollow" id="fnref16">16</a></sup>，或者使用 <code>pyinstaller -F --hidden-import pandas --hidden-import numpy</code> 命令进行打包 <sup class="footnote-ref"><a href="#fn17" rel="nofollow" id="fnref17">17</a></sup>。</p> 
<hr> 
<h2><a id="_441"></a>示例</h2> 
<h3><a id="_442"></a>依赖资源文件</h3> 
<p>在同一个目录下存在两个文件，一个 <code>script.py</code> 文件，一个 <code>Config.json</code> 文件。<br> <code>Script.py</code> 程序读写作为配置文件的 <code>Config.json</code> 文件。</p> 
<blockquote> 
 <p><code>.py</code> 文件中的方法可以使用 <code>sys.argv[1]</code> 以从控制台获取参数。<br><br> <code>sys.argv[]</code> 说白了就是一个从程序外部获取参数的桥梁，从外部取得的参数可以是多个，所以获得的是一个列表（<code>list</code>)，也就是说 <code>sys.argv</code> 其实可以看作是一个列表，所以才能用 <code>[]</code> 提取其中的元素。其第一个元素是程序本身，随后才依次是外部给予的参数 <sup class="footnote-ref"><a href="#fn18" rel="nofollow" id="fnref18">18</a></sup>。</p> 
</blockquote> 
<p><code>Config.json</code> 的文件内容如下，</p> 
<pre><code class="prism language-json"><span class="token string">"This is Config.json."</span>
</code></pre> 
<p><code>script.py</code> 的内容如下，</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> sys

<span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>项目的文件结构树如下：<br> <img src="https://images2.imgbox.com/0d/1e/OUzxKid1_o.png" alt="在这里插入图片描述" width="120"><br> 为确保代码可运行，可在cmd控制台中实验，如下，</p> 
<pre><code class="prism language-python">python script<span class="token punctuation">.</span>py Config<span class="token punctuation">.</span>json
</code></pre> 
<p>确认可传参正常运行后，准备开始打包 <code>exe</code>。</p> 
<br> 
<h4><a id="Unix__Linux__MacOS_471"></a>Unix / Linux / MacOS</h4> 
<p>参考这里 <sup class="footnote-ref"><a href="#fn19" rel="nofollow" id="fnref19">19</a></sup></p> 
<br> 
<h5><a id="_py__476"></a>仅打包 py 文件</h5> 
<ol><li>进入 <code>script.py</code> 所在目录，使用以下命令</li></ol> 
<pre><code class="prism language-python">pyinstaller <span class="token operator">-</span>F script<span class="token punctuation">.</span>py
</code></pre> 
<p>执行完毕后，若看到如下图所示的信息则表明打包成功：</p> 
<p><img src="https://images2.imgbox.com/4f/cc/nledheLD_o.png" alt="在这里插入图片描述"></p> 
<p>执行完毕后，会有 <code>dist</code> 目录生成，<code>dist</code> 目录下有同名可执行文件 <code>script.exe</code>，文件结构树如下：</p> 
<p><img src="https://images2.imgbox.com/37/27/p1pD5qSh_o.png" alt="在这里插入图片描述" width="120"></p> 
<ol start="2"><li>执行以下命令，若运行过程中无报错，则打包后的 <code>exe</code> 可正常使用。如下图所示：</li></ol> 
<p><img src="https://images2.imgbox.com/45/dc/dRmFlLHw_o.png" alt="在这里插入图片描述" width="500"><br> 或者，<br> <img src="https://images2.imgbox.com/34/d1/10tWGoA4_o.png" alt="在这里插入图片描述" width="500"><br> 该方法需要注意 <code>script.exe</code> 和 <code>Config.json</code> 文件的路径，否则极易出错。</p> 
<br> 
<h5><a id="_498"></a>打包依赖资源文件</h5> 
<h6><a id="spec_499"></a>先打包后修改spec</h6> 
<ol><li>进入 <code>script.py</code> 所在目录，使用以下命令</li></ol> 
<pre><code class="prism language-python">pyinstaller script<span class="token punctuation">.</span>py
</code></pre> 
<p>执行完毕后，若看到如下图所示的信息则表明打包成功：</p> 
<p><img src="https://images2.imgbox.com/e7/dd/vB7MAK92_o.png" alt="在这里插入图片描述" width="700"><br> 执行完毕后，会有 <code>dist</code> 目录生成，<code>dist</code> 目录下有同名子文件夹 <code>script</code>，同名子文件夹下有同名可执行文件 <code>script.exe</code>，文件结构树如下：</p> 
<p><img src="https://images2.imgbox.com/75/6e/8RBMCHId_o.png" alt="在这里插入图片描述" width="120"><br> 文件名称的列表如下：</p> 
<p><img src="https://images2.imgbox.com/fa/26/SdgGw4gK_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li>修改 <code>script.spec</code> 的内容，将 <code>Config.json</code> 添加到 <code>data</code> 中，表示将 <code>script.py</code> 所依赖的 <code>Config.json</code> 文件一同打包，如下所示：</li></ol> 
<p><img src="https://images2.imgbox.com/99/af/wu3Y262q_o.png" alt="在这里插入图片描述" width="300"><br> 3. 执行 <code>pyinstaller script.spec</code>，依据 <code>script.spec</code> 中的内容将 <code>Config.json</code> 打包至 <code>dist/script</code> 目录下，若看到如下所示的信息则表示打包成功：</p> 
<p><img src="https://images2.imgbox.com/ff/22/6YqxYGEG_o.png" alt="在这里插入图片描述" width="700"><br> 文件名称的列表如下：</p> 
<p><img src="https://images2.imgbox.com/59/61/rS5tCWRP_o.png" alt="在这里插入图片描述"><br> <br></p> 
<h6><a id="spec_525"></a>先配置spec后打包</h6> 
<ol><li>进入 <code>script.py</code> 所在目录，使用以下命令先生成 <code>script.spec</code> 文件</li></ol> 
<pre><code class="prism language-python">pyi<span class="token operator">-</span>makespec script<span class="token punctuation">.</span>py 
</code></pre> 
<p>执行完毕后，若看到如下图所示的信息则表明 <code>.spec</code> 文件生成：</p> 
<p><img src="https://images2.imgbox.com/9d/6e/GTCS3kqZ_o.png" alt="在这里插入图片描述"></p> 
<p>项目的文件结构树如下：</p> 
<p><img src="https://images2.imgbox.com/3e/44/Z6FgBi2n_o.png" alt="在这里插入图片描述" width="300"><br> <br></p> 
<ol start="2"><li>修改 <code>script.spec</code> 的 <code>datas</code>，以将程序所在同目录下的 <code>Config.json</code> 文件拷贝至打包后的程序所在根目录下，</li></ol> 
<p><img src="https://images2.imgbox.com/b5/28/BWJeSTy0_o.png" alt="在这里插入图片描述" width="250"></p> 
<ol start="3"><li>执行 <code>pyinstaller script.spec</code>，根据 <code>.spec</code> 内容对程序内容进行打包，出现以下信息时说明打包成功：<br> <img src="https://images2.imgbox.com/68/2c/bK6IMa90_o.png" alt="在这里插入图片描述"><br> 项目的文件结构树如下：<br> <img src="https://images2.imgbox.com/7c/a1/kj0X895z_o.png" alt="在这里插入图片描述" width="250"></li></ol> 
<br> 
<h4><a id="windows_551"></a>windows</h4> 
<p>下面的内容可参考这里 <sup class="footnote-ref"><a href="#fn20" rel="nofollow" id="fnref20">20</a></sup>。</p> 
<br> 
<h5><a id="_py__556"></a>仅打包 py 文件</h5> 
<ol><li>确认 <code>script.py</code> 可以接收 <code>Config.json</code> 作为参数传入并且正常运行。在 <code>pycharm</code> 终端或者 <code>cmd</code> 控制台输入：</li></ol> 
<pre><code class="prism language-python">python script<span class="token punctuation">.</span>py Config<span class="token punctuation">.</span>json
</code></pre> 
<p>如果可以看到正常的运行日志的输出，这说明可以从 <code>cmd</code> 控制台向 <code>.py</code> 文件中传递参数。下一步就是要打包成 <code>exe</code> 文件了。</p> 
<ol start="2"><li>进入 <code>script.py</code> 所在的目录，打包 <code>script.py</code>：</li></ol> 
<pre><code class="prism language-python">pyinstaller –F C<span class="token punctuation">:</span>\Users\Desktop\TEST\script<span class="token punctuation">.</span>py
</code></pre> 
<p>结果如下所示，则表明打包成 <code>exe</code> 成功：</p> 
<pre><code class="prism language-python"><span class="token number">6098</span> INFO<span class="token punctuation">:</span> Writing RT_GROUP_ICON <span class="token number">0</span> resource <span class="token keyword">with</span> <span class="token number">104</span> <span class="token builtin">bytes</span>
<span class="token number">6099</span> INFO<span class="token punctuation">:</span> Writing RT_ICON <span class="token number">1</span> resource <span class="token keyword">with</span> <span class="token number">3752</span> <span class="token builtin">bytes</span>
<span class="token number">6099</span> INFO<span class="token punctuation">:</span> Writing RT_ICON <span class="token number">2</span> resource <span class="token keyword">with</span> <span class="token number">2216</span> <span class="token builtin">bytes</span>
<span class="token number">6099</span> INFO<span class="token punctuation">:</span> Writing RT_ICON <span class="token number">3</span> resource <span class="token keyword">with</span> <span class="token number">1384</span> <span class="token builtin">bytes</span>
<span class="token number">6099</span> INFO<span class="token punctuation">:</span> Writing RT_ICON <span class="token number">4</span> resource <span class="token keyword">with</span> <span class="token number">37019</span> <span class="token builtin">bytes</span>
<span class="token number">6099</span> INFO<span class="token punctuation">:</span> Writing RT_ICON <span class="token number">5</span> resource <span class="token keyword">with</span> <span class="token number">9640</span> <span class="token builtin">bytes</span>
<span class="token number">6099</span> INFO<span class="token punctuation">:</span> Writing RT_ICON <span class="token number">6</span> resource <span class="token keyword">with</span> <span class="token number">4264</span> <span class="token builtin">bytes</span>
<span class="token number">6099</span> INFO<span class="token punctuation">:</span> Writing RT_ICON <span class="token number">7</span> resource <span class="token keyword">with</span> <span class="token number">1128</span> <span class="token builtin">bytes</span>
<span class="token number">6103</span> INFO<span class="token punctuation">:</span> Copying <span class="token number">0</span> resources to EXE
<span class="token number">6104</span> INFO<span class="token punctuation">:</span> Emedding manifest <span class="token keyword">in</span> EXE
<span class="token number">6104</span> INFO<span class="token punctuation">:</span> Updating manifest <span class="token keyword">in</span> C<span class="token punctuation">:</span>\Users\Desktop\TEST\dist\script<span class="token punctuation">.</span>exe<span class="token punctuation">.</span>notanexecutable
<span class="token number">6105</span> INFO<span class="token punctuation">:</span> Updating resource <span class="token builtin">type</span> <span class="token number">24</span> name <span class="token number">1</span> language <span class="token number">0</span>
<span class="token number">6109</span> INFO<span class="token punctuation">:</span> Appending PKG archive to EXE
<span class="token number">7934</span> INFO<span class="token punctuation">:</span> Building EXE <span class="token keyword">from</span> EXE<span class="token operator">-</span><span class="token number">00</span><span class="token punctuation">.</span>toc completed successfully<span class="token punctuation">.</span>
</code></pre> 
<p>打包结束后在当前文件夹生成 <code>dist</code> 和 <code>build</code> 两个文件夹和 <code>xxx.spec</code> 文件，其中 <code>dist</code> 文件夹中便是执行文件，里面会有个 <code>xxx.exe</code>。</p> 
<p>检验打包后可不可以使用，可以在 <code>Pycharm</code> 的终端或者 <code>cmd</code> 窗口验证结果：</p> 
<pre><code class="prism language-python">C<span class="token punctuation">:</span>\Users\Desktop\TEST\dist\script<span class="token punctuation">.</span>exe C<span class="token punctuation">:</span>\Users\Desktop\TEST\Config<span class="token punctuation">.</span>json
</code></pre> 
<p>若运行结果中无报错，则该打包后的 <code>exe</code> 文件可成功运行。</p> 
<p>需要注意地是：</p> 
<ul><li>通过 <code>cmd</code> 命令行传进的参数全是字符串类型的；</li><li>以上是在文件所在的文件夹下调用的 <code>cmd</code>，所以不需要写明文件地址，如果不是在文件所在的文件夹下，则需要加上文件路径。</li><li>以上描述内容是对于从 <code>cmd</code> 获取参数的，对于不需要获取参数的也同样适用，只是在 <code>cmd</code> 中不需要写参数而已。</li></ul> 
<hr> 
<h2><a id="_601"></a>参考链接</h2> 
<p>与 <code>tkinter</code> 相关的示例</p> 
<hr class="footnotes-sep"> 
<section class="footnotes"> 
 <ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/weixin_36450668/article/details/116897439">linux python封装成exe,pyinstaller打包python文件成exe(原理.安装.问题)</a> <a href="#fnref1" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref1:1" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn2" class="footnote-item"><p><a href="https://blog.csdn.net/Castlehe/article/details/107952649">python打包含有参数传递的exe程序</a> <a href="#fnref2" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref2:1" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref2:2" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref2:3" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn3" class="footnote-item"><p><a href="https://www.jianshu.com/p/560895b1334b" rel="nofollow">python打包成可执行文件app(Mac版)</a> <a href="#fnref3" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn4" class="footnote-item"><p><a href="https://www.cnblogs.com/guyuyun/p/11074424.html" rel="nofollow">Python三方库：PyInstaller（exe程序打包）</a> <a href="#fnref4" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref4:1" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref4:2" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref4:3" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn5" class="footnote-item"><p><a href="https://blog.csdn.net/weixin_42409884/article/details/109293327">pyinstaller打包exe程序步骤和添加依赖文件方法</a> <a href="#fnref5" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref5:1" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn6" class="footnote-item"><p><a href="https://yooziki.github.io/2020/10/1339689/" rel="nofollow">pyinstaller打包外置文件并使用</a> <a href="#fnref6" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn7" class="footnote-item"><p><a href="https://blog.csdn.net/weixin_42182448/article/details/113654663">利用pyinstaller将python项目脚本打包成可执行文件</a> <a href="#fnref7" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref7:1" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref7:2" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref7:3" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref7:4" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref7:5" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref7:6" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref7:7" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn8" class="footnote-item"><p><a href="https://string.quest/read/2487780" rel="nofollow">使用pyinstaller将python项目打包发布为exe可执行文件 - 探索字符串</a> <a href="#fnref8" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref8:1" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref8:2" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref8:3" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn9" class="footnote-item"><p><a href="https://blog.csdn.net/who18/article/details/117994684">解决pyinstaller打包文件过大的问题（Anaconda）</a> <a href="#fnref9" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn10" class="footnote-item"><p><a href="https://github.com/espressif/esp-idf/issues/8464">Installing Python environment and packages error , virtualenv.py: error: no such option: --seeder (IDFGH-6840)</a> <a href="#fnref10" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn11" class="footnote-item"><p><a href="https://lequ7.com/guan-yu-pythonpycharm-tian-jia-yi-cun-zai-de-pipenv-xu-ni-huan-jing-jie-shi-qi.html" rel="nofollow">关于python:pycharm-添加已存在的-pipenv-虚拟环境解释器</a> <a href="#fnref11" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn12" class="footnote-item"><p><a href="https://blog.csdn.net/maixiaochai/article/details/90052333?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">【Python】 —— pyinstaller 打包多个 py 文件为一个 exe</a> <a href="#fnref12" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn13" class="footnote-item"><p><a href="https://daimajiaoliu.com/daima/8c7338e3c44d408" rel="nofollow">linux 打包文件夹_Python利用PyInstaller打包</a> <a href="#fnref13" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref13:1" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn14" class="footnote-item"><p><a href="https://blog.csdn.net/vample/article/details/86476822">pyinstaller 打包程序的相对路径问题</a> <a href="#fnref14" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn15" class="footnote-item"><p><a href="https://www.bbsmax.com/A/Ae5RnDWr5Q/" rel="nofollow">pyinstaller打包程序包含openpyxl库问题解决</a> <a href="#fnref15" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn16" class="footnote-item"><p><a href="https://stackoverflow.com/questions/29109324/pyinstaller-and-pandas" rel="nofollow">PyInstaller and Pandas</a> <a href="#fnref16" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn17" class="footnote-item"><p><a href="https://www.jianshu.com/p/e00195d2ff36" rel="nofollow">pyinstaller打包exe，无法包含pandas、numpy解决办法</a> <a href="#fnref17" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn18" class="footnote-item"><p><a href="https://blog.csdn.net/m0_37264397/article/details/78996156">python命令行参数sys.argv的使用</a> <a href="#fnref18" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn19" class="footnote-item"><p><a href="https://blog.csdn.net/u010351326/article/details/102463896">python打包运行在Linux上</a> <a href="#fnref19" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn20" class="footnote-item"><p><a href="https://blog.csdn.net/fendouwhy/article/details/73245689">如何用pyinstaller将需要传参数的Python文件生成exe文件</a> <a href="#fnref20" rel="nofollow" class="footnote-backref">↩︎</a></p> </li></ol> 
</section>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/192b16ebd60760c6f4a0c55838d4afd4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle SQL语句进行新建用户</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f08eb72c257c38833e83267ebdaabd15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java中的继承</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>