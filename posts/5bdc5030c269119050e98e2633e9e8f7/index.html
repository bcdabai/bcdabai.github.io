<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>H.264帧结构和RTSP协议源码框架 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="H.264帧结构和RTSP协议源码框架" />
<meta property="og:description" content="目录
1、H264编码原理和基本概念
1.1、h.264编码原理
1.2、h.264编码相关的一些概念
2、H264的NAL单元详解
2.1、VCL和NAL的关系
2.2、H.264视频流分析工具
2.3、h264视频流总体分析
2.4、相关概念
3、H264的NAL单元---sps和pps
3.1、sps和pps详解
3.2、H264的profile和level
3.3、sequence
4、rtsp协议和源码框架
4.1、源码框架函数调用关系
4.2、直接发送与环状buffer发送
4.3、RTP发送一帧数据的两种不同发送格式-&gt;整发送和分包发送
1、H264编码原理和基本概念 1.1、h.264编码原理 (1)图像冗余信息：空间冗余、时间冗余
(2)视频编码关键点：压缩比高、算法复杂度小、还原度高
(3)H.264的2大组成部分：VCL和NAL
VCL关心如何进行视频压缩
NAL关心压缩后的视频流如何被网络传输和解码播放
1.2、h.264编码相关的一些概念 (1)宏块 MB（macroblock）：多个像素组成的一块，宏块是视频压缩算法的最基本单位
由于图像本身在局部，颜色具有相似性，所以可以把一幅图像分成若干个宏块
(2)片 slice：构成帧的一部分
一帧图像=若干个slice（可以是一个slice）
一个slice=若干个MB
一个MB=多个像素
(3)帧 frame：一整幅完整的图像
(4)I帧、B帧、P帧：帧有好几种类型
I帧：非参考帧，这一帧图像的内容只和本身有关，和前一帧后一帧图像的内容无关，一般作为起始帧，因为这一帧没有任何参考，所以只能对这一帧进行帧内压缩（空间冗余上的优化）
B帧：参考帧，这一帧图像的内容不光和本身有关，还和前一帧或后一帧图像的内容有关（空间冗余&#43;时间冗余的优化）
P帧：参考帧，这一帧图像的内容不光和本身有关，还和前一帧图像的内容有关（空间冗余&#43;时间冗余的优化）
(5)帧率 fps：一秒中有多少帧，帧率高（慢动作），帧率低（快动作）
(6)像素-&gt;宏块-&gt;片-&gt;帧-&gt;序列-&gt;码流
2、H264的NAL单元详解 2.1、VCL和NAL的关系 (1)VCL只关心编码部分，重点在于编码算法以及在特定硬件平台的实现，VCL输出的是编码后的纯视频流信息，没有任何头信息
(2)NAL关心的是VCL的输出纯视频流如何被表达和封包以利于网络传输
(3)SODB：String Of Data Bits（VCL输出的纯视频流）
(4)RBSP：Raw Byte Sequence Payload
(5)NALU：Network Abstraction Layer Units NALU是H264文件的基本组成单元
(6)关系：
SODB &#43; RBSP trailing bits = RBSP
NALU header(1 byte) &#43; RBSP = NALU" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5bdc5030c269119050e98e2633e9e8f7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-20T16:55:25+08:00" />
<meta property="article:modified_time" content="2023-08-20T16:55:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">H.264帧结构和RTSP协议源码框架</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"></p> 
<p style="margin-left:0px;"><a href="#1%E3%80%81H264%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">1、H264编码原理和基本概念</a></p> 
<p style="margin-left:40px;"><a href="#1.1%E3%80%81h.264%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86" rel="nofollow">1.1、h.264编码原理</a></p> 
<p style="margin-left:40px;"><a href="#1.2%E3%80%81h.264%E7%BC%96%E7%A0%81%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5" rel="nofollow">1.2、h.264编码相关的一些概念</a></p> 
<p style="margin-left:0px;"><a href="#2%E3%80%81H264%E7%9A%84NAL%E5%8D%95%E5%85%83%E8%AF%A6%E8%A7%A3" rel="nofollow">2、H264的NAL单元详解</a></p> 
<p style="margin-left:40px;"><a href="#2.1%E3%80%81VCL%E5%92%8CNAL%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow">2.1、VCL和NAL的关系</a></p> 
<p style="margin-left:40px;"><a href="#2.2%E3%80%81H.264%E8%A7%86%E9%A2%91%E6%B5%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7" rel="nofollow">2.2、H.264视频流分析工具</a></p> 
<p style="margin-left:40px;"><a href="#2.3%E3%80%81h264%E8%A7%86%E9%A2%91%E6%B5%81%E6%80%BB%E4%BD%93%E5%88%86%E6%9E%90" rel="nofollow">2.3、h264视频流总体分析</a></p> 
<p style="margin-left:40px;"><a href="#2.4%E3%80%81%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" rel="nofollow">2.4、相关概念</a></p> 
<p style="margin-left:0px;"><a href="#3%E3%80%81H264%E7%9A%84NAL%E5%8D%95%E5%85%83---sps%E5%92%8Cpps" rel="nofollow">3、H264的NAL单元---sps和pps</a></p> 
<p style="margin-left:40px;"><a href="#3.1%E3%80%81sps%E5%92%8Cpps%E8%AF%A6%E8%A7%A3" rel="nofollow">3.1、sps和pps详解</a></p> 
<p style="margin-left:40px;"><a href="#3.2%E3%80%81H264%E7%9A%84profile%E5%92%8Clevel" rel="nofollow">3.2、H264的profile和level</a></p> 
<p style="margin-left:40px;"><a href="#3.3%E3%80%81sequence" rel="nofollow">3.3、sequence</a></p> 
<p style="margin-left:0px;"><a href="#4%E3%80%81rtsp%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%BA%90%E7%A0%81%E6%A1%86%E6%9E%B6" rel="nofollow">4、rtsp协议和源码框架</a></p> 
<p style="margin-left:40px;"><a href="#4.1%E3%80%81%E6%BA%90%E7%A0%81%E6%A1%86%E6%9E%B6%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB" rel="nofollow">4.1、源码框架函数调用关系</a></p> 
<p style="margin-left:40px;"><a href="#4.2%E3%80%81%E7%9B%B4%E6%8E%A5%E5%8F%91%E9%80%81%E4%B8%8E%E7%8E%AF%E7%8A%B6buffer%E5%8F%91%E9%80%81" rel="nofollow">4.2、直接发送与环状buffer发送</a></p> 
<p style="margin-left:40px;"><a href="#4.3%E3%80%81RTP%E5%8F%91%E9%80%81%E4%B8%80%E5%B8%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E5%8F%91%E9%80%81%E6%A0%BC%E5%BC%8F-%3E%E6%95%B4%E5%8F%91%E9%80%81%E5%92%8C%E5%88%86%E5%8C%85%E5%8F%91%E9%80%81" rel="nofollow">4.3、RTP发送一帧数据的两种不同发送格式-&gt;整发送和分包发送</a></p> 
<hr> 
<p></p> 
<h2>1、H264编码原理和基本概念</h2> 
<h3>1.1、h.264编码原理</h3> 
<p>(1)图像冗余信息：空间冗余、时间冗余</p> 
<p>(2)视频编码关键点：压缩比高、算法复杂度小、还原度高</p> 
<p>(3)H.264的2大组成部分：VCL和NAL</p> 
<p>        VCL关心如何进行视频压缩</p> 
<p>        NAL关心压缩后的视频流如何被网络传输和解码播放</p> 
<h3>1.2、h.264编码相关的一些概念</h3> 
<p>(1)宏块 MB（macroblock）：多个像素组成的一块，宏块是视频压缩算法的最基本单位</p> 
<p>由于图像本身在局部，颜色具有相似性，所以可以把一幅图像分成若干个宏块</p> 
<p>(2)片 slice：构成帧的一部分</p> 
<p>        一帧图像=若干个slice（可以是一个slice）</p> 
<p>        一个slice=若干个MB</p> 
<p>        一个MB=多个像素</p> 
<p>(3)帧 frame：一整幅完整的图像</p> 
<p>(4)I帧、B帧、P帧：帧有好几种类型</p> 
<p>I帧：非参考帧，这一帧图像的内容只和本身有关，和前一帧后一帧图像的内容无关，一般作为起始帧，因为这一帧没有任何参考，所以只能对这一帧进行帧内压缩（空间冗余上的优化）</p> 
<p>B帧：参考帧，这一帧图像的内容不光和本身有关，还和前一帧或后一帧图像的内容有关（空间冗余+时间冗余的优化）</p> 
<p>P帧：参考帧，这一帧图像的内容不光和本身有关，还和前一帧图像的内容有关（空间冗余+时间冗余的优化）</p> 
<p>(5)帧率 fps：一秒中有多少帧，帧率高（慢动作），帧率低（快动作）</p> 
<p>(6)像素-&gt;宏块-&gt;片-&gt;帧-&gt;序列-&gt;码流</p> 
<h2>2、H264的NAL单元详解</h2> 
<h3>2.1、VCL和NAL的关系</h3> 
<p>(1)VCL只关心编码部分，重点在于编码算法以及在特定硬件平台的实现，VCL输出的是编码后的纯视频流信息，没有任何头信息</p> 
<p>(2)NAL关心的是VCL的输出纯视频流如何被表达和封包以利于网络传输</p> 
<p>(3)SODB：String Of Data Bits（VCL输出的纯视频流）</p> 
<p>(4)RBSP：Raw Byte Sequence Payload</p> 
<p>(5)NALU：Network Abstraction Layer Units        NALU是H264文件的基本组成单元</p> 
<p>(6)关系：</p> 
<p>SODB + RBSP trailing bits = RBSP</p> 
<p>NALU header(1 byte) + RBSP = NALU</p> 
<p>H264文件由若干个序列组成 -&gt; 序列由若干个帧/slice组成 -&gt; 帧/slice由分隔符和NALU单元组成 -&gt; 去掉NALU header得到RBSP -&gt; 去掉RBSP trailing得到SODB-&gt; VLC播放器解码播放SODB</p> 
<p>(7)总结：做编码器的人关心的是VCL部分；做视频传输和解码播放的人关心的是NAL部分</p> 
<h3>2.2、H.264视频流分析工具</h3> 
<p>(1)雷神作品：SpecialVH264.exe</p> 
<p>(2)国外工具：Elecard StreamEye Tools</p> 
<p>(3)二进制工具：winhex</p> 
<p>(4)网络抓包工具：wireshark</p> 
<p>(5)播放器：vlc</p> 
<h3>2.3、h264视频流总体分析</h3> 
<p>(1)h264标准有多个版本，可能会有差异，具体差异不详</p> 
<p>(2)网上看的资料有时讲法会有冲突，或者无法验证的差异</p> 
<p>(3)这里以海思平台为主、为准、为案例，不能保证其他平台也完全一样</p> 
<p>(4)海思平台编码出来的H.264码流（就是一个二进制文件）都是一个一个序列组成，序列包含：1sps+1pps+1sei+1I帧+若干p帧</p> 
<p><img alt="3a52b471bc984eb98d57f907f9d2e64d.png" src="https://images2.imgbox.com/c6/68/ZirjnVtv_o.png"></p> 
<h3>2.4、相关概念</h3> 
<p>(1)序列 sequence，一般一秒发一个sequence，也就是说sequence(除去sps、pps、sei)和帧率相等</p> 
<p>(2)分隔符：00 00 00 01的四字节组合，是用来做识别的，不是有效数据，表示一个slice的开始，表示我们有一个新的片到来。</p> 
<p><img alt="d8fcfe76a46d42b884f6c5575dcaa3a8.png" src="https://images2.imgbox.com/e8/98/ZkzUG8vi_o.png"></p> 
<p>帧的有效数据部分是不会出现（00 00 00 01）的，h264的标准规定有效数据不允许出现连续的3个00，会在第二个00后面，第三个00前面添加一个03进去，用（00 00 03 00）来表示（00 00 00）。</p> 
<p>(3)sps</p> 
<p>(4)pps</p> 
<p>(5)sei</p> 
<p>(6)NALU header：分隔符后的第一个字节</p> 
<p><img alt="914df4ea696f4168ab46dd2c24380990.png" src="https://images2.imgbox.com/da/80/NccZgMIK_o.png"></p> 
<p>NALU header有8个位</p> 
<p>bit7（forbidden_zero_bit）：禁止位，默认位0，值为1表示语法出错</p> 
<p>bit6~5（nal_ref_idc）：重要性，代表这一帧的内容在视频流中的重要程度，重要程度由大到小11&gt;10&gt;01&gt;00</p> 
<p>bit4~0（nal_unit_type）：NAL单元类型</p> 
<p><img alt="f4574dd7343640338fde646a0dbde61b.png" src="https://images2.imgbox.com/26/2d/q60R1Aeo_o.png"></p> 
<p>1：表示 非I帧，具体是P还是B帧不知道</p> 
<p>5：表示 I帧</p> 
<p>6：表示 SEI</p> 
<p>7：表示 SPS</p> 
<p>8：表示 PPS</p> 
<p>参考博文：</p> 
<p><a href="https://blog.csdn.net/jefry_xdz/article/details/8461343" title="H264(NAL简介与I帧判断)_h264 判断i帧_jefry_xdz的博客-CSDN博客">H264(NAL简介与I帧判断)_h264 判断i帧_jefry_xdz的博客-CSDN博客</a></p> 
<p></p> 
<h2 style="background-color:transparent;">3、H264的NAL单元---sps和pps</h2> 
<p>参考博文：</p> 
<p><a href="https://www.cnblogs.com/wainiwann/p/7477794.html" rel="nofollow" title="https://www.cnblogs.com/wainiwann/p/7477794.html">https://www.cnblogs.com/wainiwann/p/7477794.html</a></p> 
<h3>3.1、sps和pps详解</h3> 
<p>在H.264标准协议中规定了多种不同的NAL Unit类型，其中类型7表示该NAL Unit内保存的数据为Sequence Paramater Set（序列参数集），描述这个序列的参数信息都在这里。在H.264的各种语法元素中，SPS中的这些参数信息至关重要。如果其中的数据丢失或出现错误，那么解码过程很可能会失败。SPS和PPS中的信息会用于播放器的初始化使用。</p> 
<p>SPS中保存了一组视频序列的全局参数。所谓的视频序列即原始视频的一帧一帧的图像数据经过编码之后组成的序列。而每一帧的编码后数据所依赖的参数保存于图像参数集（PPS）中，例如P帧需要参考前面的帧进行编码，那么是怎么参考的，这个参考数据就保存在PPS中。</p> 
<p>一般情况SPS和PPS位于整个码流的起始位置。但在某些特殊情况下，在码流中间也可能出现这两种结构，主要原因可能为：</p> 
<ul><li>解码器需要在码流中间开始解码；</li><li>编码器在编码的过程中改变了码流的参数（如图像分辨率等）；</li></ul> 
<p>视频播放器为了让后续的解码过程可以使用SPS中包含的参数，必须对SPS其中的数据进行解析。其中H.264标准协议中规定的SPS格式位于文档的7.3.2.1.1部分，如下图所示：</p> 
<p><img alt="2c6060b688da4e33b1b62e52c1f37853.png" src="https://images2.imgbox.com/80/d6/pkLFP7tQ_o.png"></p> 
<p>(1) profile_idc：</p> 
<p>标识当前H.264码流的profile。我们知道，H.264中定义了三种常用的档次profile：</p> 
<p>基准档次：baseline profile;</p> 
<p>主要档次：main profile;</p> 
<p>扩展档次：extended profile;</p> 
<p>在H.264的SPS中，第一个字节表示profile_idc，根据profile_idc的值可以确定码流符合哪一种档次。判断规律为：</p> 
<p>profile_idc = 66（0x42） → baseline profile;</p> 
<p>profile_idc = 77 → main profile;</p> 
<p>profile_idc = 88 → extended profile;</p> 
<p>在新版的标准中，还包括了High、High 10、High 4:2:2、High 4:4:4、High 10 Intra、High 4:2:2 Intra、High 4:4:4 Intra、CAVLC 4:4:4 Intra等，每一种都由不同的profile_idc表示。</p> 
<p>当前码流中，profile_idc = 0x42 = 66 ，因此profile档次为 baseline profile;</p> 
<p><img alt="8eb9eae6d74d47e98d2ac45987d27d6e.png" src="https://images2.imgbox.com/5b/77/vJfprctS_o.png"></p> 
<p>(2) level_idc</p> 
<p>标识当前码流的Level。编码的Level定义了某种条件下的最大视频分辨率、最大视频帧率等参数，码流所遵从的level由level_idc指定。</p> 
<p><img alt="455fbb5138304c76a06574a73ec7fb0b.png" src="https://images2.imgbox.com/d9/b8/M7Qms0fa_o.png"></p> 
<p>当前码流中，level_idc = 0x1F = 31，因此码流的级别为3.1。</p> 
<p>Level为3.1的特性：</p> 
<p><img alt="c99f45c9897d4b54b2e145f722a362e6.png" src="https://images2.imgbox.com/74/33/34NSVu3s_o.png"></p> 
<h3>3.2、H264的profile和level</h3> 
<p>参考博文：</p> 
<p><a href="https://blog.csdn.net/xiaojun111111/article/details/52090185" title="h264中profile和level的含义_xiaojun11-的博客-CSDN博客">h264中profile和level的含义_xiaojun11-的博客-CSDN博客</a></p> 
<p>Profile是对视频压缩特性的描述（CABAC呀、颜色采样数等等），简而言之就是压缩算法的档次。Level是对视频本身特性的描述（码率、分辨率、fps）。</p> 
<p>简单来说，Profile越高，就说明采用了越高级的压缩特性（越高级的压缩算法）。Level越高，视频的码率、分辨率、fps越高。</p> 
<p>一些移动设备（手机、游戏机、PMP）由于性能有限，不支持全部高级视频压缩特性和高分辨率图像，只支持基础压缩特性和分辨率低一些的图像。为了让这个限制更加清晰明了，H264从低到高划分了很多Profile和Level。</p> 
<p>profile主要是定义了编码工具（压缩算法）的集合，不同的profile，包含了不同的编码技术；</p> 
<p>h.264的profile有三种Baseline Profile（基本的）、Main Profile（主线的）、High Profile（高等级的）</p> 
<h3>3.3、sequence</h3> 
<p>(1)一段h.264的码流其实就是多个sequence组成的</p> 
<p>(2)每个sequence均有固定结构：1sps+1pps+1sei+1I帧+若干p帧</p> 
<p>(3)sps和pps和sei描述该sequence的图像信息，这些信息有利于网络传输或解码</p> 
<p>(4)I帧是关键，丢了I帧整个sequence就废了，因为I帧是自参考的，其它的帧都参考于它，每个sequence有且只有1个I帧</p> 
<p>(5)p帧的个数等于fps-1</p> 
<p>(6)I帧越大则P帧可以越小，反之I帧越小则P帧会越大</p> 
<p>I帧越大，说明I帧本身压缩比例不高，参考信息比较多，比较详细，所以P帧就越好参考，就可以越小</p> 
<p>(7)I帧的大小取决于图像本身内容，和压缩算法的空间压缩部分</p> 
<p>如果图像本身色彩丰富、画面复制，那么I帧就会很大</p> 
<p>(8)P帧的大小取决于图像变化的剧烈程度</p> 
<p>(9)CBR和VBR下P帧的大小策略会不同，CBR时P帧大小基本恒定，VBR时变化会比较剧烈</p> 
<p>CBR：固定码率</p> 
<p>VBR：可变码率</p> 
<h2>4、rtsp协议和源码框架</h2> 
<p>rtsp协议参考：</p> 
<p>链接：https://pan.baidu.com/s/1IHU8vaFShMq3mOUz3c2iDw?pwd=0000 <br> 提取码：0000</p> 
<h3>4.1、源码框架函数调用关系</h3> 
<pre><code>main
	RtspServer_init
		RtspServerListen								    //线程函数---达到PLAY状态
			socket                            		        //创建TCP套接字
			setsockopt                                 	    //设置端口复用
			bind                                      	    //绑定服务器IP和端口
			listen								            //监听、并告诉linux系统这是个服务器
			while(accept)							        //不断等待客户端连接
				setsockopt
				for                                         //实际只执行一次
					RtspClientMsg                           //此函数是重点，创建一个线程去处理这此连接
					    pthread_detach                      //分离线程，子线程结束后自动回收资源
					    while                               //如果当前不是未连接状态
					    {
						    recv                            //读1024个字节
						    if(没读到)
						    {
							    退出线程
						    }
						    ParseRequestString              //解析客户端发来的Requst请求并填充字符串数组    

						    if(是OPTIONS请求)
							    OptionAnswer                //返回服务器提供的可用方法
								    sprintf                 //组包
								    strcat                  //连接RTSP头和sdp信息
								    send                    //发送
						    if(是DESCRIBE请求)
							    DescribeAnswer              //返回sdp包给播放器client去配置解码
								    GetLocalIP              //获取本地IP
     								    	ioctl
								    sprintf                 //组包
								    send                    //发送
						    if(是SETUP请求)
							    SetupAnswer
								    ParseTransportHeader    //解析客户端发来的SETUP Request，然后填充到变量中
								    GetLocalIP              //获取本地IP
								    sprintf                 //组包
								    send                    //发送
						    if(是PLAY请求)
							    PlayAnswer
								    sprintf                 //组包
								    send                    //发送
								    socket                  //创建一个UDPsocket
								    //由此可见，之前的TCPsocket是一个命令通道，这里的UDPsocket是一个传输数据的通道
						    if(是PAUSE请求)                 //暂停请求
							    PauseAnswer                 //源码分析得知，这里并没有实现暂停码流的传输
								    sprintf                 //组包
								    send                    //发送
						    if(是TEARDOWN请求)
							    TeardownAnswer
								    sprintf                 //组包
								    send                    //发送
								    close(udp)              //关闭数据传输通道UDPsocket
							    close(tcp)                  //关闭命令传输通道TCPsocket
					      }   
		vdRTPSendThread                                     //线程函数---发送流媒体的数据
			while(1)                                        //每5ms判断当前是否有数据要发送
			{
				if(!list_empty)                             //链表为空，则表明当前没有数据要发送
				{
					get_first_item                          //取出链表中第一个非空节点
					VENC_Sent//发送码流数据
						sendto                              //UDP发送
					list_del                                //从链表中把节点去掉
				}
				usleep(5000);                               //延时5ms
			}
	SAMPLE_VENC_720P_CLASSIC
		SAMPLE_COMM_VENC_StartGetStream
			SAMPLE_COMM_VENC_GetVencStreamProc              //线程函数
				HI_MPI_VENC_GetChnAttr
				SAMPLE_COMM_VENC_GetFilePostfix
				HI_MPI_VENC_GetFd
				while
				{
					HI_MPI_VENC_Query
					malloc
					HI_MPI_VENC_GetStream                   //获取一帧编码完的码流

					//以下两种方式二选一
					SAMPLE_COMM_VENC_Sentjin                //此函数是重点---编码完后直接发送
						VENC_Sent                           //直接发送    
					saveStream                              //此函数是重点---编码完后保存到环状buf中
						malloc                              //生成一个链表节点
						INIT_LIST_HEAD                      //初始化这个节点的next指针和prev指针都指向自己
						填充节点内容
						list_add_tail                       //将节点加入链表
					//当我将编码完的数据保存到环形链表后，此时链表就有节点数据了
					//然后就可以在 vdRTPSendThread 线程中发送了

					HI_MPI_VENC_ReleaseStream
					free
				}</code></pre> 
<h3>4.2、直接发送与环状buffer发送</h3> 
<p><strong>直接发送</strong>：编码完直接发送，编多少发多少</p> 
<p>代码体现在：</p> 
<pre><code>SAMPLE_COMM_VENC_GetVencStreamProc线程函数：
    HI_MPI_VENC_GetStream            //获取编码完的码流
    SAMPLE_COMM_VENC_Sentjin         //发送函数</code></pre> 
<p>缺陷：视频采集和编码速度 与 网络传输速度 都是变动的，速度不一定一致，会导致系统进入漫长的等待，不能更好的实时视频监控</p> 
<p></p> 
<p><strong>环状buffer发送</strong>：编码完放到环状buffer中，待发送</p> 
<p>环状buffer即环形链表，当生产者（获取码流的线程）编码完一帧数据就将这帧数据作为节点加入链表，消费者（发送线程）只管从中取。</p> 
<p>对比代码：SAMPLE_COMM_VENC_GetVencStreamProc线程函数中，调用HI_MPI_VENC_GetStream获取编码完的码流，调用saveStream将码流数据节点加入链表，vdRTPSendThread线程从链表中取走节点，然后调用VENC_Sent发送。</p> 
<p>当链表中没有节点，则消费者要阻塞，等待生产者编码完将数据节点加入链表。环形链表相比数组的优点是使用内存可以足够大，直到内存撑爆。</p> 
<p>代码体现在：</p> 
<pre><code>SAMPLE_COMM_VENC_GetVencStreamProc线程函数：
        HI_MPI_VENC_GetStream         //获取编码完的码流
        saveStream                    //编码完后保存到环状buf中
vdRTPSendThread线程函数：
        get_first_item                //取出链表中第一个非空节点
        VENC_Sent                     //发送码流数据
        list_del                      //从链表中把节点去掉</code></pre> 
<p>接下来就只用关注VENC_Sent函数内是怎么组包，然后通过UDP传输码流数据了。。</p> 
<h3>4.3、RTP发送一帧数据的两种不同发送格式-&gt;整发送和分包发送</h3> 
<p>关于rtp头的timestamp位：<br><a href="https://blog.csdn.net/jasonhwang/article/details/7316128" title="RTP timestamp与帧率及时钟频率的关系_帧率 时钟频率_jasonhwang的博客-CSDN博客">RTP timestamp与帧率及时钟频率的关系_帧率 时钟频率_jasonhwang的博客-CSDN博客</a></p> 
<p>关于RTP发送一帧数据的两种不同发送格式：整包发送和分包发送</p> 
<p><a href="https://www.cnblogs.com/yjg2014/p/6144977.html" rel="nofollow" title="https://www.cnblogs.com/yjg2014/p/6144977.html">https://www.cnblogs.com/yjg2014/p/6144977.html</a></p> 
<p>VENC_Sent函数全解：</p> 
<pre><code>HI_S32 VENC_Sent(char *buffer,int buflen)
{
    HI_S32 i;
    int is=0;
    int nChanNum=0;

    for(is=0;is&lt;MAX_RTSP_CLIENT;is++)
    {
        if(g_rtspClients[is].status!=RTSP_SENDING)//判断是否是 可发送 状态
        {
            continue;
        }
        int heart = g_rtspClients[is].seqnum % 10000;//seqnum：序列号，对10000取余
        
        char* nalu_payload;
        int nAvFrmLen = 0;
        int nIsIFrm = 0;
        int nNaluType = 0;
        char sendbuf[500*1024+32];

    
        nAvFrmLen = buflen;//音频或视频数据一帧的长度

        struct sockaddr_in server;
        server.sin_family=AF_INET;
           server.sin_port=htons(g_rtspClients[is].rtpport[0]);   //对方的端口       
           server.sin_addr.s_addr=inet_addr(g_rtspClients[is].IP);//对方的IP
        int    bytes=0;
        unsigned int timestamp_increse=0;
        
        timestamp_increse=(unsigned int)(90000.0 / 25);    //  两帧之间RTP timestamp的增量 = 时钟频率 / 帧率

        rtp_hdr =(RTP_FIXED_HEADER*)&amp;sendbuf[0];         //填充RTP包头
    
        rtp_hdr-&gt;payload     = RTP_H264;   
        rtp_hdr-&gt;version     = 2;                          //RTP版本号
        rtp_hdr-&gt;marker    = 0;           
        rtp_hdr-&gt;ssrc      = htonl(10);                   //信源标记

        if(nAvFrmLen&lt;=nalu_sent_len)    //如果这一帧数据的长度&lt;=1400
        {
            rtp_hdr-&gt;marker=1;                            //标记一帧的结束
            rtp_hdr-&gt;seq_no     = htons(g_rtspClients[is].seqnum++);     //下一帧的序列号
            nalu_hdr =(NALU_HEADER*)&amp;sendbuf[12]; 
            nalu_hdr-&gt;F=0; 
            nalu_hdr-&gt;NRI=  nIsIFrm; 
            nalu_hdr-&gt;TYPE=  nNaluType;
            nalu_payload=&amp;sendbuf[13];
            memcpy(nalu_payload,buffer,nAvFrmLen);
                    g_rtspClients[is].tsvid = g_rtspClients[is].tsvid+timestamp_increse;            
            rtp_hdr-&gt;timestamp=htonl(g_rtspClients[is].tsvid);
            bytes=nAvFrmLen+ 13 ;                
            sendto(udpfd, sendbuf, bytes, 0, (struct sockaddr *)&amp;server,sizeof(server));
        }
        else if(nAvFrmLen&gt;nalu_sent_len)    //如果这一帧数据的长度&gt;1400
        {
            int k=0,l=0;
            k=nAvFrmLen/nalu_sent_len;                    //这一帧数据的长度/1400
            l=nAvFrmLen%nalu_sent_len;                    //这一帧数据的长度对1400取余
            int t=0;        

            g_rtspClients[is].tsvid = g_rtspClients[is].tsvid+timestamp_increse;    //计算timestamp
            rtp_hdr-&gt;timestamp=htonl(g_rtspClients[is].tsvid);                 //把timestamp放入RTP包头       
            while(t&lt;=k)            //循环k+1次，也就是发k+1个包，代表这一帧发完
            {
                rtp_hdr-&gt;seq_no = htons(g_rtspClients[is].seqnum++);
                if(t==0)        //第一包
                {
                    rtp_hdr-&gt;marker=0;            //填充完RTP_header的12个字节后，接下来填充的是NALU的分包形式
                    fu_ind =(FU_INDICATOR*)&amp;sendbuf[12];//fu_indicato是NALU头的分包形式的第一部分
                    fu_ind-&gt;F= 0; 
                    fu_ind-&gt;NRI= nIsIFrm;
                    fu_ind-&gt;TYPE=28;                    //Type为FU-A
        
                    fu_hdr =(FU_HEADER*)&amp;sendbuf[13];    //fu_header     是NALU头的分包形式的第二部分
                    fu_hdr-&gt;E=0;
                    fu_hdr-&gt;R=0;
                    fu_hdr-&gt;S=1;                        //表示帧开始
                    fu_hdr-&gt;TYPE=nNaluType;                //NALU type
    
                    nalu_payload=&amp;sendbuf[14];    //填充完NALU的分包形式后，接下来开始填充有效数据
                    memcpy(nalu_payload,buffer,nalu_sent_len);
    
                    bytes=nalu_sent_len+14;        //发送的长度是有效数据长度＋14（14就是前面添加的这些信息）                
                    sendto( udpfd, sendbuf, bytes, 0, (struct sockaddr *)&amp;server,sizeof(server));
                    t++;
    
                }
                else if(k==t)    //最后一包
                {
                    rtp_hdr-&gt;marker=1;                    //标记一帧的结束
                    fu_ind =(FU_INDICATOR*)&amp;sendbuf[12]; 
                    fu_ind-&gt;F= 0 ;
                    fu_ind-&gt;NRI= nIsIFrm ;
                    fu_ind-&gt;TYPE=28;

                    fu_hdr =(FU_HEADER*)&amp;sendbuf[13];
                    fu_hdr-&gt;R=0;
                    fu_hdr-&gt;S=0;
                    fu_hdr-&gt;TYPE= nNaluType;
                    fu_hdr-&gt;E=1;                        //表示帧结束，和marker一样
                    nalu_payload=&amp;sendbuf[14];
                    memcpy(nalu_payload,buffer+t*nalu_sent_len,l);
                    bytes=l+14;        
                    sendto(udpfd, sendbuf, bytes, 0, (struct sockaddr *)&amp;server,sizeof(server));
                    t++;
                }
                else if(t&lt;k &amp;&amp; t!=0)    //中间的包
                {

                    rtp_hdr-&gt;marker=0;

                    fu_ind =(FU_INDICATOR*)&amp;sendbuf[12]; 
                    fu_ind-&gt;F=0; 
                    fu_ind-&gt;NRI=nIsIFrm;
                    fu_ind-&gt;TYPE=28;
                    fu_hdr =(FU_HEADER*)&amp;sendbuf[13];
                    //fu_hdr-&gt;E=0;
                    fu_hdr-&gt;R=0;
                    fu_hdr-&gt;S=0;
                    fu_hdr-&gt;E=0;                        //S=0,E=0表示既不是开头也不是结尾
                    fu_hdr-&gt;TYPE=nNaluType;
                    nalu_payload=&amp;sendbuf[14];
                    memcpy(nalu_payload,buffer+t*nalu_sent_len,nalu_sent_len);
                    bytes=nalu_sent_len+14;    
                    sendto(udpfd, sendbuf, bytes, 0, (struct sockaddr *)&amp;server,sizeof(server));
                    t++;
                }
            }
        }

    }

    //------------------------------------------------------------
}</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d9f228f955f378c18adb9c9c52ab1909/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity- 控制物体旋转、移动、缩放的功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb3a6cc730e61aa2b73085cbb8a7260d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">set_up_a_local_testing_server</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>