<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>js 实现多重罗盘转动 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="js 实现多重罗盘转动" />
<meta property="og:description" content="引子 这几天一直在忙一个可滑动的转盘的demo，网上也有类似的例子，但是根据老板的需求来改他们的代码，还不如重新写个完全符合需求的插件。
想法很美好，但是新手上路...
效果链接文末
需求 image 这个demo给的非常简单，能转动的地方有三处，内盘、外盘和指针，这三个上的集合的交集产生一个链接，通过中间的按钮跳转。
这个需求乍一看老简单老简单的，但是作为一个菜鸡第一次上道，堪比开碰碰车，头破血流。
分析 在做之前，也是根据自己的理解来写的旋转角度问题：
转盘转动的做法是：设定圆心为转动原点，动态的修改旋转角度；在touchmove 计算两点与中心点的角度。 在旋转上大体上需要明白的也就这两点，但是在实际计算角度上却有很多问题。
弯道1之计算角度 计算角度首先要用到的一个数学方法就是反函数，在JS中表示反函数的方法有两个：
Math.atanMath.atan2 说实话它们两个的区别对于本次demo真没有测出什么差异来，但是相比 atan在y特别大的时候会有误差产生的情况下，果断选择了atan2
(function($){ $.fn.CompassRotate=function(options){ var defaults={ trigger:document, centerX:0, centerY:0, debug:false },_this=this; var ops=$.extend(defaults,options); function Init(){ //初始化圆心点 if(ops.centerX==0 &amp;&amp; ops.centerY==0){ ops.centerX=_this.offset().left&#43;_this.width()/2; ops.centerY=_this.offset().top&#43;_this.height()/2 } $(ops.trigger).on(&#34;touchstart&#34;,function(event){ $(document).on(&#34;touchmove&#34;,movehandle); }); $(ops.trigger).on(&#34;touchend&#34;,function(event) { $(document).unbind(&#34;touchmove&#34;); }); } //鼠标移动时处理事件 function movehandle(event){ var touch = event.originalEvent.targetTouches[0]; var dis = angle(ops.centerX,ops.centerY,touch.pageX, touch.pageY); if(ops.debug) console.log(ops.centerX&#43;&#34;-&#34;&#43;ops.centerY&#43;&#34;|&#34;&#43;touch.pageX&#43;&#34;-&#34;&#43;touch.pageY&#43;&#34; &#34;&#43;dis); rotate(dis); } //计算两点的线在页面中的角度 function angle(centerx, centery, endx, endy) { var diff_x = endx - centerx, diff_y = endy - centery; var c=360 * Math." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/46243a2c2f5a904b9ff4ec8a07b70cb3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-17T02:08:49+08:00" />
<meta property="article:modified_time" content="2017-11-17T02:08:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">js 实现多重罗盘转动</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <h3 class="heading">引子</h3> 
 <blockquote> 
  <p>这几天一直在忙一个可滑动的转盘的demo，网上也有类似的例子，但是根据老板的需求来改他们的代码，还不如重新写个完全符合需求的插件。<br>想法很美好，但是新手上路...</p> 
 </blockquote> 
 <p>效果链接文末</p> 
 <h3 class="heading">需求</h3> 
 <p></p> 
 <figure> 
  <figcaption>
    image 
  </figcaption> 
 </figure> 
 <p></p> 
 <p>这个demo给的非常简单，能转动的地方有三处，内盘、外盘和指针，这三个上的集合的交集产生一个链接，通过中间的按钮跳转。</p> 
 <p>这个需求乍一看老简单老简单的，但是作为一个菜鸡第一次上道，堪比开碰碰车，头破血流。</p> 
 <h3 class="heading">分析</h3> 
 <p>在做之前，也是根据自己的理解来写的旋转角度问题：</p> 
 <ul><li>转盘转动的做法是：设定圆心为转动原点，动态的修改旋转角度；</li><li>在touchmove 计算两点与中心点的角度。</li></ul> 
 <p>在旋转上大体上需要明白的也就这两点，但是在实际计算角度上却有很多问题。</p> 
 <h3 class="heading">弯道1之计算角度</h3> 
 <p>计算角度首先要用到的一个数学方法就是反函数，在JS中表示反函数的方法有两个：</p> 
 <ul><li>Math.atan</li><li>Math.atan2</li></ul> 
 <p>说实话它们两个的区别对于本次demo真没有测出什么差异来，但是相比 atan在y特别大的时候会有误差产生的情况下，果断选择了atan2</p> 
 <pre><code class="hljs bash copyable">(<span class="hljs-keyword">function</span>($){
        $.fn.CompassRotate=<span class="hljs-keyword">function</span>(options){
            var defaults={
                trigger:document,           
                centerX:0,                     
                centerY:0,                      
                debug:<span class="hljs-literal">false</span>
            },_this=this;
            var ops=$.extend(defaults,options);
            <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">Init</span></span>(){
                //初始化圆心点
                <span class="hljs-keyword">if</span>(ops.centerX==0 &amp;&amp; ops.centerY==0){
                    ops.centerX=_this.offset().left+_this.width()/2;
                    ops.centerY=_this.offset().top+_this.height()/2
                }
                $(ops.trigger).on(<span class="hljs-string">"touchstart"</span>,<span class="hljs-keyword">function</span>(event){
                    $(document).on(<span class="hljs-string">"touchmove"</span>,movehandle);
                });
                $(ops.trigger).on(<span class="hljs-string">"touchend"</span>,<span class="hljs-keyword">function</span>(event) {
                    $(document).unbind(<span class="hljs-string">"touchmove"</span>);
                });
            }
            //鼠标移动时处理事件
            <span class="hljs-keyword">function</span> movehandle(event){
                var touch = event.originalEvent.targetTouches[0];
                var dis = angle(ops.centerX,ops.centerY,touch.pageX, touch.pageY);

                <span class="hljs-keyword">if</span>(ops.debug) console.log(ops.centerX+<span class="hljs-string">"-"</span>+ops.centerY+<span class="hljs-string">"|"</span>+touch.pageX+<span class="hljs-string">"-"</span>+touch.pageY+<span class="hljs-string">" "</span>+dis);

                rotate(dis);
            }
            //计算两点的线在页面中的角度
            <span class="hljs-keyword">function</span> angle(centerx, centery, endx, endy) {
                var diff_x = endx - centerx,
                    diff_y = endy - centery;
                var c=360 * Math.atan2(diff_y , diff_x) / (2 * Math.PI);
                c=c&lt;=0?(360+c):c;

                <span class="hljs-built_in">return</span> c; 
            }
            //设置角度
            <span class="hljs-keyword">function</span> rotate(angle,step){
                $(_this).css(<span class="hljs-string">"transform"</span>, <span class="hljs-string">"translate3d(-50%,-50%,0) rotateZ("</span> + angle + <span class="hljs-string">"deg)"</span>);
            }
            // 指针指向角度变化和生成url
            <span class="hljs-keyword">function</span> angleOrLink(angle) {
                Angle = angle;
            }
            Init();
        };
    })(jQuery);
    $(<span class="hljs-string">".box"</span>).CompassRotate({trigger:$(<span class="hljs-string">".box"</span>),debug:<span class="hljs-literal">true</span>});<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>啰里啰嗦不如直接贴上代码，大家看得更明白些。</p> 
 <h3 class="heading">弯道2之区域集合变化</h3> 
 <p>做过转盘抽奖的大佬都知道，每个奖品都对应一个角度集合，指针所转的角度[0,360]看看对应落在哪个集合上，而这个转盘也是同理，但是唯一不同的地方在于，内盘和外盘的集合是可变化的，并不是固定不变的。</p> 
 <pre><code class="hljs bash copyable">var insideCollection = [
    {
        /* GC+S1 */
        min: 270,
        max: 360,
        reverse: <span class="hljs-literal">false</span>,
        mark: <span class="hljs-string">'s1gc'</span>
    },
    {
        /* BC+AT */
        min: 0,
        max: 45,
        reverse: <span class="hljs-literal">false</span>,
        mark: <span class="hljs-string">'bcat'</span>
    },
    {
        /* BC+GT */
        min: 45,
        max: 90,
        reverse: <span class="hljs-literal">false</span>,
        index: <span class="hljs-string">'bcgt'</span>
    },
    {
        /* mCRC+FOLFOX */
        min: 90,
        max: 180,
        reverse: <span class="hljs-literal">false</span>,
        mark: <span class="hljs-string">'mCRC'</span>
    },
    {
        /* eCRC+化疗 */
        min: 225,
        max: 270,
        reverse: <span class="hljs-literal">false</span>,
        mark: <span class="hljs-string">'eCRC1'</span>
    },
    {
        /* eCRC+FOLFOX */
        min: 180,
        max: 225,
        reverse: <span class="hljs-literal">false</span>,
        mark: <span class="hljs-string">'eCRC2'</span>
    }

];
var outsideCollection = [
    {
        /* 研究 */
        min: 270,
        max: 342,
        reverse: <span class="hljs-literal">false</span>,
        mark: <span class="hljs-string">'研究'</span>
    },
    {
        /* 指南 */
        min: 342,
        max: 54,
        reverse: <span class="hljs-literal">true</span>,
        mark: <span class="hljs-string">'指南'</span>
    },
    {
        /* 竞品 */
        min: 54,
        max: 126,
        reverse: <span class="hljs-literal">false</span>,
        mark: <span class="hljs-string">'竞品'</span>

    },
    {
        /* 资料 */
        min: 126,
        max: 198,
        reverse: <span class="hljs-literal">false</span>,
        mark: <span class="hljs-string">'资料'</span>
    },
    {
        /* 机制 */
        min: 198,
        max: 270,
        reverse: <span class="hljs-literal">false</span>,
        mark: <span class="hljs-string">'机制'</span>
    }

];<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>min，max不用说了，就是表示集合，reverse 这个属性代表的是什么呢？<br>在做区间划分的时候，角度的变化永远都是0-360°，“0==360”。所以，当某个集合的区间是[340,25]的时候该怎么表示呢？<br>当然，每次转动都有且只有一个集合会面临这样的情况，所以我用一个属性来表示这个区间跨角度了。</p> 
 <pre><code class="hljs bash copyable">// 转盘区间分布变化
<span class="hljs-keyword">function</span> collectionChange(angle,array) {
    array.forEach(<span class="hljs-keyword">function</span> (ele,index) {
        ele.reverse = <span class="hljs-literal">false</span>;
    });
    array.forEach(<span class="hljs-keyword">function</span> (ele,index) {
        ele.min = (Number(angle)+Number(ele.min))%360;
        ele.max = (Number(angle)+Number(ele.max))%360;
        <span class="hljs-keyword">if</span>(ele.min &gt; ele.max){
            ele.reverse = <span class="hljs-literal">true</span>;
        }
    });
    console.log(array)
}<span class="copy-code-btn">复制代码</span></code></pre> 
 <p><em>mark</em> 也不用多谈，选中了集合该表示表示了呀。</p> 
 <p>代码贴到这也基本完成了大体功能，最后也是在点击链接的时候根据内外盘的 <em>mark</em> 来匹配链接了：</p> 
 <pre><code class="hljs bash copyable">$(<span class="hljs-string">'#compass_5'</span>).on(<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-title">function</span></span>(){
    var angle = Angle;
    // 内盘标号
    var link = contrast(insideCollection) + contrast(outsideCollection);
    console.log(link);
    <span class="hljs-keyword">function</span> contrast(array){
        var link ;
        array.forEach(<span class="hljs-keyword">function</span> (ele,index) {
            <span class="hljs-keyword">if</span>(angle &gt;= ele.min%360 &amp;&amp; angle &lt;= (ele.max%360 ==0?360:ele.max%360)){
                link = ele.mark;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ele.reverse){
                <span class="hljs-keyword">if</span>(angle&lt;=360 &amp;&amp; angle &gt;=270){
                    <span class="hljs-keyword">if</span>(angle &gt;= ele.min%360 &amp;&amp; angle &lt;= (ele.max%360 ==0?360:ele.max%360+360)){
                        link = ele.mark;
                    }
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(angle&gt;=0&amp;&amp;angle&lt;=90){
                    <span class="hljs-keyword">if</span>(angle+360 &gt;= ele.min%360 &amp;&amp; angle+360 &lt;= (ele.max%360 ==0?360:ele.max%360+360)){
                        link = ele.mark;
                    }
                }
            }
        });
        <span class="hljs-built_in">return</span> link;
    }
})<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading">弯道3之坑王之王</h3> 
 <p>上面说到功能大体完成了，那只是按部就班的在轮盘上只选择一个点进行转动，如果在不同位置多次转动，发现整个转盘瘫痪了——mark对应不上了。</p> 
 <p>做这个demo第一步，我是从一个简单的指针转盘开始起手的，也就是完成一个转动指针的基本操作，所以整套流程下来是可行的，因为这个指针订好了转动圆心，它的可选区域仅仅是辣么一小块，所以根本看不到为后面埋了多大坑。 </p> 
 <h4 class="heading">反函数计算角度问题</h4> 
 <pre><code class="hljs bash copyable">var c=360 * Math.atan2(diff_y , diff_x) / (2 * Math.PI); 
// c [-180,180];
c=c&lt;=0?(360+c):c;
// c [0,360];<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>这样计算角度对于指针来说，没什么问题，但是对于转盘上来说可能就是个噩梦。</p> 
 <p>因为它的着落点并不确定。</p> 
 <p>导致当你点到不同区域的时候，它会给你直接将转动的角度赋值，所以会造永远是中间那条线跟着手指滑动。</p> 
 <p></p> 
 <figure> 
  <figcaption>
    image 
  </figcaption> 
 </figure> 
 <p></p> 
 <p><a href="https://link.juejin.im?target=https%3A%2F%2Fsuiyang1714.github.io%2Fcompass.github.io%2F" rel="nofollow">坑王之王链接(chrome调试器里查看)</a></p> 
 <p>这样的操作遇到的坑就是起始位置随着手指的变动会导致各个区域的区间也应该发生相应的变化，所以在 <em>touchstart</em> 还要进行一步操作，计算上一次结束位置与目前位置的夹角，然后再次更改区间变化。</p> 
 <pre><code class="hljs bash copyable">$(ops.trigger).on(<span class="hljs-string">"touchstart"</span>,<span class="hljs-keyword">function</span>(event){
    var touch = event.originalEvent.changedTouches[0];
    var dis = angle(ops.centerX,ops.centerY,touch.pageX, touch.pageY);
    startAngle = dis;
    //再次滑动转盘后的角度与上一次结束角度不一致的情况(内盘)
    <span class="hljs-keyword">if</span>(startAngle != ops.initAngle_in &amp;&amp; ops.initAngle_in != 0){
        <span class="hljs-keyword">if</span>(ops.initAngle_in&gt;startAngle){
            insideDishAngleChangeSecondary((Number(startAngle+360)-ops.initAngle_in));
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ops.initAngle_in&lt; startAngle){
            insideDishAngleChangeSecondary((startAngle-ops.initAngle_in));
        }

    }
    $(document).on(<span class="hljs-string">"touchmove"</span>,movehandle);
});<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading">修改后的罗盘</h3> 
 <p>上一版的罗盘基本操作是将错就错，产生了一系列bug，虽然都克服了一系列bug，但还是都是在挖坑，只不过坑是平行挪动，这个坑挖不动了换了个方向继续挖而已。</p> 
 <h4 class="heading">岔路</h4> 
 <p>重新审视自己的思路时，才发现自己是多么的蠢。</p> 
 <p>之前的算法是手指指在哪里，开始点为0，结束点为所指点 ，在 <em>touchmove</em> 给罗盘赋角度值时，直接将两点形成的角度赋给了罗盘 <em>rotate(angle)</em>。之后的一系列操作都是为这个地方买单，无论是重新写个函数记录变换角度在 <em>touchmove</em> 开始之前赋给罗盘分布区间、还是中心点僵硬随着手指转动。</p> 
 <p>重新思考了下罗盘的转法，有了之前的铺垫，所以思路也变得特别清晰了。<br>实现这个需求，记录的数据一共有三个：</p> 
 <ul><li><em>actual_angle</em> ：开始点和结束点与中心点的夹角，这就是罗盘每次转动的度数，该值需要累加；</li><li><em>addAngle</em> ：每次转动结束后，需要给罗盘分布区间增加的值，该值等同于 <em>actual_angle</em>；</li><li><em>startAngle</em> ：<em>touchstart</em> 时手指着落点，即开始点。</li></ul> 
 <pre><code class="hljs bash copyable">$.fn.RotateH=<span class="hljs-keyword">function</span>(options){
    var defaults={
        trigger:document,           
        centerX:0,                      
        centerY:0,                      
        debug:<span class="hljs-literal">false</span>
    },_this=this;
    var ops=$.extend(defaults,options);
    var startAngle,addAngle,
        actual_angle = 0;
    //初始化
    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">Init</span></span>(){
        //初始化圆心点
        <span class="hljs-keyword">if</span>(ops.centerX==0 &amp;&amp; ops.centerY==0){
            ops.centerX=_this.offset().left+_this.width()/2;
            ops.centerY=_this.offset().top+_this.height()/2
        }
        $(ops.trigger).on(<span class="hljs-string">"touchstart"</span>,<span class="hljs-keyword">function</span>(event){
            var touch = event.originalEvent.changedTouches[0];
            var dis = angle(ops.centerX,ops.centerY,touch.pageX, touch.pageY);
            startAngle = dis;
            $(document).on(<span class="hljs-string">"touchmove"</span>,movehandle);
        });
        $(ops.trigger).on(<span class="hljs-string">"touchend"</span>,<span class="hljs-keyword">function</span>(event) {

            var touch = event.originalEvent.changedTouches[0];
            var dis = angle(ops.centerX,ops.centerY,touch.pageX, touch.pageY);

            //每次转动的角度
            <span class="hljs-keyword">if</span>(dis &gt;=startAngle){
                //罗盘累加转动度数
                actual_angle += (dis-startAngle);
                //区间每次增加度数
                addAngle = (dis-startAngle);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dis &lt;startAngle){
                actual_angle += (dis+360-startAngle);
                addAngle = (dis+360-startAngle)
            }
            <span class="hljs-keyword">if</span>(ops.collection) collectionChange(addAngle,ops.collection);
            <span class="hljs-keyword">else</span> angleOrLink(dis);
            $(document).unbind(<span class="hljs-string">"touchmove"</span>);
        });
    }
    //鼠标移动时处理事件
    <span class="hljs-keyword">function</span> movehandle(event){

        // 获取两点之间角度
        var touch = event.originalEvent.targetTouches[0];
        var dis = angle(ops.centerX,ops.centerY,touch.pageX, touch.pageY);
        var Angle = 0;

        <span class="hljs-keyword">if</span>(ops.debug) console.log(ops.centerX+<span class="hljs-string">"-"</span>+ops.centerY+<span class="hljs-string">"|"</span>+touch.pageX+<span class="hljs-string">"-"</span>+touch.pageY+<span class="hljs-string">" "</span>+dis);

        <span class="hljs-keyword">if</span>(ops.pointer){
            rotate(dis);
        }
        <span class="hljs-keyword">else</span> {
            //每次转动的角度
            <span class="hljs-keyword">if</span>(ops.debug) {
                console.log(<span class="hljs-string">"——————————————————————"</span>);
                console.log(<span class="hljs-string">'上次转动的角度：'</span>+actual_angle);
            }
            <span class="hljs-keyword">if</span>(dis &gt;=startAngle){
                Angle = dis-startAngle;
                <span class="hljs-keyword">if</span>(ops.debug) {
                    console.log(<span class="hljs-string">"转动角度："</span>+Angle);
                    console.log(<span class="hljs-string">"实际转动角度："</span>+(Angle+actual_angle));
                }
                rotate((Angle+actual_angle));
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dis &lt;startAngle){
                Angle = dis-startAngle+360;
                <span class="hljs-keyword">if</span>(ops.debug){
                    console.log(<span class="hljs-string">"转动角度："</span> + Angle);
                    console.log(<span class="hljs-string">"实际转动角度："</span>+(Angle+actual_angle));
                }
                rotate((Angle+actual_angle));
            }
        }
    }
    //计算两点的线在页面中的角度
    <span class="hljs-keyword">function</span> angle(centerx, centery, endx, endy) {
        var diff_x = endx - centerx,
            diff_y = endy - centery;
        var c=360 * Math.atan2(diff_y , diff_x) / (2 * Math.PI);
        c=c&lt;=0?(360+c):c;

        <span class="hljs-built_in">return</span> c;
    }
    //设置角度
    <span class="hljs-keyword">function</span> rotate(angle,step){
        $(_this).css(<span class="hljs-string">"transform"</span>, <span class="hljs-string">"translate3d(-50%,-50%,0) rotateZ("</span> + angle + <span class="hljs-string">"deg)"</span>);
    }
    // 转盘区间分布变化
    <span class="hljs-keyword">function</span> collectionChange(angle,array) {
        array.forEach(<span class="hljs-keyword">function</span> (ele,index) {
            ele.reverse = <span class="hljs-literal">false</span>;
        });
        array.forEach(<span class="hljs-keyword">function</span> (ele,index) {
            ele.min = (Number(angle)+Number(ele.min))%360;
            ele.max = (Number(angle)+Number(ele.max))%360;
            <span class="hljs-keyword">if</span>(ele.min &gt; ele.max){
                ele.reverse = <span class="hljs-literal">true</span>;
            }
        });
        <span class="hljs-keyword">if</span>(ops.debug) console.log(array);
    }
    // 指针所转角度
    <span class="hljs-keyword">function</span> angleOrLink(angle) {
        Angle = angle;
    }
    Init();
};<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>效果链接地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fsuiyang1714.github.io%2FperfectCompass.github.io%2F." rel="nofollow">perfectCompass.github.io</a> (这是个ipad demo，请在chrome调试器查看)</p> 
 <p>github 地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fsuiyang1714%2FperfectCompass.github.io" rel="nofollow">github.com/suiyang1714…</a></p> 
 <h3 class="heading">总结</h3> 
 <blockquote> 
  <p>这个demo最终是自己靠时间磨出来了的，没有特别高的技术含量，主要是在这个过程中思考。如果一开始想明白了每一步要干什么，也不会拐那么多的弯道了。<br>我一开始的想法是，罗盘先能转动，然后再考虑的区间变化，出现问题解决解决问题，没有看到为什么会出现这个问题。基本是走一步看一步。心好累。</p> 
 </blockquote> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb1c3446751d4071d65b3390b473907e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">重要的学习资料被删除了？恢复方法就在这里</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a1ac296256d5dfcfdefeb015b697b39a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">iOS-按钮单选与多选逻辑处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>