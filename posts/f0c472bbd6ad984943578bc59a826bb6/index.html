<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UNIX环境高级编程——文件和目录 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="UNIX环境高级编程——文件和目录" />
<meta property="og:description" content="4.1 引言 本章将描述文件系统的其他特征和文件的性质。
4.2 函数stat、fstat、fstatat和lstat 4个stat函数：
#include &lt;sys/stat.h&gt; int stat(const char *restrict pathname, struct stat *restrict buf); int fstat(int fd, struct stat *buf); int lstat(const char *restrict pathname, struct stat *restrict buf); int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag); // 所有4个函数的返回值：若成功，返回0；若出错，返回-1 stat函数返回与pathname命名文件有关的信息结构；fstat函数获得已在描述符fd上打开文件的有关信息；lstat函数类似于stat函数，但在当命名文件是一个符号链接时，返回该符号链接的有关信息，而不是由该符号链接引用的文件的信息；fstatat函数返回一个相当于当前打开目录（fd参数指向）的路径名返回文件统计信息。flag参数控制着是否跟随着一个符号链接，当AT_SYMLINK_NOFOLLOW标志被设置时，fstatat不会跟随符号链接，而是返回符号链接本身的信息，否则，在默认情况下，返回符号链接所指向的实际文件的信息；参数buf是一个stat类型的指针，由函数填充其结构。 4.3 文件类型 UNIX系统的文件类型包括：
普通文件：最常用的类型，包含了某种形式的数据；目录文件：包含了其他文件的名字以及指向与这些文件有关信息的指针；块特殊文件：提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行；字符特殊文件：提供对设备不带缓冲的访问，每次访问长度可变；FIFO：用于进程间通信，亦称管道；套接字：用于进程间的网络通信，也可用于在一台宿主机上进程之间的非网络通信；符号链接：指向另一个文件。 文件类型信息包含在stat结构的st_mode成员中，用下表中的宏确定，这些宏的参数为stat成员st_mode。
宏文件类型S_ISREG()普通文件S_ISDIR()目录文件S_ISCHR()字符特殊文件S_ISBLK()块特殊文件S_ISFIFO()管道或FIFOS_ISLNK()符号链接S_ISSOCK()套接字文件 POSIX.1允许实现将进程间通信（IPC）对象说明为文件，下表中的宏可用来从stat结构中确定IPC对象的类型，这些宏的参数为stat结构指针。
宏对象的类型S_TYPEISMQ()消息队列S_TYPEISSEM()信号量S_TYPEISSHM()共享存储对象 4.4 设置用户ID和设置组ID 与每个进程相关联的用户ID和组ID 实际用户ID 标识我们实际上是谁；
在登录时取自口令文件中的登录项；
在登录会话期间不改变，但超级用户可以修改。 实际组ID 有效用户ID 用于文件访问权限检查 有效组ID 附属组ID 保存的设置用户ID 由exec函数保存；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f0c472bbd6ad984943578bc59a826bb6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-05T21:15:07+08:00" />
<meta property="article:modified_time" content="2023-04-05T21:15:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UNIX环境高级编程——文件和目录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="41__0"></a>4.1 引言</h3> 
<p>本章将描述文件系统的其他特征和文件的性质。</p> 
<h3><a id="42_statfstatfstatatlstat_2"></a>4.2 函数stat、fstat、fstatat和lstat</h3> 
<p>4个<code>stat</code>函数：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict pathname<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>restrict buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fstat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">lstat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict pathname<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>restrict buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fstatat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict pathname<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>restrict buf<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 所有4个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li><code>stat</code>函数返回与<strong>pathname</strong>命名文件有关的信息结构；</li><li><code>fstat</code>函数获得已在描述符<strong>fd</strong>上打开文件的有关信息；</li><li><code>lstat</code>函数类似于<code>stat</code>函数，但在当命名文件是一个<strong>符号链接</strong>时，返回该符号链接的有关信息，而不是由该符号链接引用的文件的信息；</li><li><code>fstatat</code>函数返回一个相当于<strong>当前打开目录</strong>（<strong>fd</strong>参数指向）的路径名返回文件统计信息。<strong>flag</strong>参数控制着是否跟随着一个符号链接，当<strong>AT_SYMLINK_NOFOLLOW</strong>标志被设置时，<code>fstatat</code>不会跟随符号链接，而是返回符号链接本身的信息，否则，在默认情况下，返回符号链接所指向的实际文件的信息；</li><li>参数<strong>buf</strong>是一个<strong>stat</strong>类型的指针，由函数填充其结构。</li></ul> 
<h3><a id="43__20"></a>4.3 文件类型</h3> 
<p>UNIX系统的文件类型包括：</p> 
<ul><li><code>普通文件</code>：最常用的类型，包含了某种形式的数据；</li><li><code>目录文件</code>：包含了其他文件的名字以及指向与这些文件有关信息的指针；</li><li><code>块特殊文件</code>：提供对设备（如磁盘）<strong>带缓冲</strong>的访问，每次访问以固定长度为单位进行；</li><li><code>字符特殊文件</code>：提供对设备<strong>不带缓冲</strong>的访问，每次访问长度可变；</li><li><code>FIFO</code>：用于进程间通信，亦称<code>管道</code>；</li><li><code>套接字</code>：用于进程间的网络通信，也可用于在一台宿主机上进程之间的非网络通信；</li><li><code>符号链接</code>：指向另一个文件。</li></ul> 
<p>文件类型信息包含在<strong>stat</strong>结构的<strong>st_mode</strong>成员中，用下表中的宏确定，这些宏的参数为stat成员st_mode。</p> 
<table><thead><tr><th>宏</th><th>文件类型</th></tr></thead><tbody><tr><td>S_ISREG()</td><td>普通文件</td></tr><tr><td>S_ISDIR()</td><td>目录文件</td></tr><tr><td>S_ISCHR()</td><td>字符特殊文件</td></tr><tr><td>S_ISBLK()</td><td>块特殊文件</td></tr><tr><td>S_ISFIFO()</td><td>管道或FIFO</td></tr><tr><td>S_ISLNK()</td><td>符号链接</td></tr><tr><td>S_ISSOCK()</td><td>套接字文件</td></tr></tbody></table> 
<p>POSIX.1允许实现将进程间通信（IPC）对象说明为文件，下表中的宏可用来从<strong>stat</strong>结构中确定IPC对象的类型，这些宏的参数为<strong>stat</strong>结构指针。</p> 
<table><thead><tr><th>宏</th><th>对象的类型</th></tr></thead><tbody><tr><td>S_TYPEISMQ()</td><td>消息队列</td></tr><tr><td>S_TYPEISSEM()</td><td>信号量</td></tr><tr><td>S_TYPEISSHM()</td><td>共享存储对象</td></tr></tbody></table> 
<h3><a id="44_IDID_48"></a>4.4 设置用户ID和设置组ID</h3> 
<table><tbody><tr><th colspan="2"> 与每个进程相关联的用户ID和组ID </th></tr><tr><td> 实际用户ID </td><td rowspan="2"> 标识我们实际上是谁；<br>在登录时取自口令文件中的登录项；<br>在登录会话期间不改变，但超级用户可以修改。 </td></tr><tr><td> 实际组ID </td></tr><tr><td> 有效用户ID </td><td rowspan="3"> 用于文件访问权限检查 </td></tr><tr><td> 有效组ID </td></tr><tr><td> 附属组ID </td></tr><tr><td> 保存的设置用户ID </td><td rowspan="2"> 由exec函数保存；<br>在执行程序时包含了有效用户ID和有效组ID的副本。 </td></tr><tr><td> 保存的设置组ID </td></tr></tbody></table> 
<ul><li>通常，有效用户ID等于实际用户ID，有效组ID等于实际组ID；</li><li>每个文件有一个所有者和组所有者，所有者有<strong>stat</strong>结构的<strong>st_uid</strong>指定，组所有者则由<strong>st_gid</strong>指定；</li><li>当执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID通常是实际组ID；</li><li>可在文件模式字（<strong>st_mode</strong>）中设置一个特殊标志，其含义是“当执行此文件时，将进程的有效用户ID设置为文件所有者的用户ID（<strong>st_uid</strong>）”，在文件模式字中设置另一位，它将执行此文件的进程的有效组ID设置为文件的组所有者ID（<strong>st_gid</strong>），这两位分别被称为<strong>设置用户ID</strong>（set-user-ID）位和<strong>设置组ID</strong>（set-group-ID），可分别用常量<strong>S_ISUID</strong>和<strong>S_ISGID</strong>测试。</li></ul> 
<h3><a id="45__84"></a>4.5 文件访问权限</h3> 
<p><strong>st_mode</strong>值也包含了对文件的访问权限位，每个文件有9个访问权限位，可分3类：</p> 
<table border="1"><tbody><tr><th colspan="2"> 9个访问权限位 </th></tr><tr><td> st_mode屏蔽 </td><td> 含义 </td></tr><tr><td> S_IRUSR </td><td align="center" rowspan="3"> 用户读<br>用户写<br>用户执行 </td></tr><tr><td> S_IWUSR </td></tr><tr><td> S_IXUSR </td></tr><tr><td> S_IRGRP </td><td align="center" rowspan="3"> 组读<br>组写<br>组执行 </td></tr><tr><td> S_IWGRP </td></tr><tr><td> S_IXGRP </td></tr><tr><td> S_IROTH </td><td align="center" rowspan="3"> 其他读<br>其他写<br>其他执行 </td></tr><tr><td> S_IWOTH </td></tr><tr><td> S_IXOTH </td></tr></tbody></table> 
<h3><a id="46__126"></a>4.6 新文件和目录的所有权</h3> 
<ul><li>新文件的用户ID设置为进程的有效用户ID；</li><li>新文件的组ID可以是进程的有效组ID，也可以是它所在目录的组ID。</li></ul> 
<h3><a id="47_accessfaccessat_130"></a>4.7 函数access和faccessat</h3> 
<p><code>access</code>和<code>faccessat</code>函数是按<strong>实际用户ID</strong>和<strong>实际组ID</strong>进行访问权限测试：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">access</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">faccessat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>如果测试文件是否已经存在，<strong>mode</strong>就为<strong>F_OK</strong>，否则是下表常量的<strong>按位或</strong>：</li></ul> 
<table><thead><tr><th>mode</th><th>说明</th></tr></thead><tbody><tr><td>R_OK</td><td>测试读权限</td></tr><tr><td>W_OK</td><td>测试写权限</td></tr><tr><td>X_OK</td><td>测试执行权限</td></tr></tbody></table> 
<ul><li> <p>如果<strong>flag</strong>设置为AT_EACCESS，访问检查用的是调用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID。</p> </li><li> <p><code>faccessat</code>函数计算相对于打开目录（由<strong>fd</strong>参数指向）的<strong>pathname</strong>，<code>faccessat</code>函数与<code>access</code>函数在下面两种情况下是相同的：<br> （1）<strong>pathname</strong>参数为绝对路径；<br> （2）<strong>fd</strong>参数取值为<strong>AT_FDCWD</strong>而<strong>pathname</strong>参数为相对路径时。</p> </li></ul> 
<h3><a id="48_umask_153"></a>4.8 函数umask</h3> 
<p><code>umask</code>函数为进程设置文件模式创建屏蔽字，并返回之前的值：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>

mode_t <span class="token function">umask</span><span class="token punctuation">(</span>mode_t cmask<span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token comment">// 返回值：之前的文件创建屏蔽字</span>
</code></pre> 
<ul><li><strong>cmask</strong>参数是4.5节中9个常量的若干个按位“<code>或</code>”构成的；</li><li>文件模式创建屏蔽字中为1的位，在文件<strong>mode</strong>中的相应位一定被关闭。</li></ul> 
<h3><a id="49_chmodfchmodfchmodat_164"></a>4.9 函数chmod、fchmod和fchmodat</h3> 
<p><code>chmod</code>、<code>fchmod</code>和<code>fchmodat</code>这3个函数可以更改现有文件的访问权限：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">chmod</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fchmod</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fchmodat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 3个函数返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li><code>chmod</code>函数在指定的文件上进行操作；</li><li><code>fchmod</code>函数对已打开的文件进行操作；</li><li><code>fchmodat</code>计算相对于打开目录（由<strong>fd</strong>参数指向）的<strong>pathname</strong>，<strong>flag</strong>参数用于改变<code>fchmodat</code>的行为，当设置了<strong>AT_SYMLINK_NOFOLLOW</strong>标志时，<code>fchmodat</code>并不会跟随符号链接。</li></ul> 
<p>参数<strong>mode</strong>是下表中所有常量的按位或：</p> 
<table border="1"><tbody><tr><th colspan="2"> chmod函数的mode常量 </th></tr><tr><td> mode </td><td> 说明 </td></tr><tr><td align="left" rowspan="1"> S_ISUID<br>S_ISGID<br>S_ISVTX </td><td align="left" rowspan="1"> 执行时设置用户ID<br>执行时设置组ID<br>保存正文（粘着位）</td></tr><tr><td align="left" rowspan="1"> S_IRWXU<br>S_IRUSR<br>S_IWUSR<br>S_IXUSR </td><td align="left" rowspan="1"> 用户（所有者）读、写和执行<br>用户（所有者）读<br>用户（所有者）写<br>用户（所有者）执行</td></tr><tr><td align="left" rowspan="1"> S_IRWXG<br>S_IRGRP<br>S_IWGRP<br>S_IXGRP </td><td align="left" rowspan="1"> 组读、写和执行<br>组读<br>组写<br>组执行</td></tr><tr><td align="left" rowspan="1"> S_IRWXO<br>S_IROTH<br>S_IWOTH<br>S_IXOTH </td><td align="left" rowspan="1"> 其他读、写和执行<br>其他读<br>其他写<br>其他执行</td></tr></tbody></table> 
<h3><a id="410__206"></a>4.10 粘着位</h3> 
<p><code>S_ISVTX</code>被称为<strong>粘着位</strong>：如果一个可执行程序文件的这一位被设置了，那么当该程序第一次被执行，在其终止时，程序正文部分的一个副本仍被保存在<strong>交换区</strong>（程序的正文部分是机器指令）；交换区被作为一个<strong>连续</strong>文件来处理，这使得下次执行该程序时能较快地将其载入内存。</p> 
<h3><a id="411_chownfchownfchownatlchown_208"></a>4.11 函数chown、fchown、fchownat和lchown</h3> 
<p>下面几个<code>chown</code>函数可用于改变文件的用户ID和组ID，如果两个参数<strong>owner</strong>或<strong>group</strong>中的任意一个是**-1**，则对应的ID不变：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">chown</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> uid_t owner<span class="token punctuation">,</span> gid_t group<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fchown</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> uid_t owner<span class="token punctuation">,</span> gid_t group<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fchownat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> uid_t owner<span class="token punctuation">,</span> gid_t group<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">lchown</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> uid_t owner<span class="token punctuation">,</span> gid_t group<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 4个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>在符号链接情况下，<code>lchown</code>和<code>fchownat</code>（设置了<strong>AT_SYMLINK_NOFOLLOW</strong>标志）更改符号链接本身的所有者，而不是该符号链接所指向的文件的所有者；</li><li><code>fchown</code>函数改变<strong>fd</strong>参数指向的打开文件的所有者，因为它在一个已打开的文件上操作，所以不能用于改变符号链接的所有者；</li><li><code>fchownat</code>函数与<code>chown</code>或者<code>lchown</code>函数在下面两种情况下是相同的：<br> （1）<strong>pathname</strong>参数为绝对路径；<br> （2）<strong>fd</strong>参数取值为<strong>AT_FDCWD</strong>而<strong>pathname</strong>参数为相对路径；<br> 在这两种情况下，如果<strong>flag</strong>参数中设置了<strong>AT_SYMLINK_NOFOLLOW</strong>标志，<code>fchownat</code>与<code>lchown</code>行为相同，如果<strong>flag</strong>参数中清除了<strong>AT_SYMLINK_NOFOLLOW</strong>标志，则<code>fchownat</code>与<code>chown</code>行为相同。如果<strong>fd</strong>参数设置为打开目录的文件描述符，并且<strong>pathname</strong>参数是一个相对路径名，<code>fchownat</code>函数计算相对于打开目录的<strong>pathname</strong>。</li></ul> 
<h3><a id="412__227"></a>4.12 文件长度</h3> 
<p><strong>stat</strong>结构成员<strong>st_size</strong>表示以字节为单位的文件的长度，此字段只对普通文件、目录文件和符号链接有意义：</p> 
<ul><li>对于普通文件，其文件长度可以是0，在开始读这种文件时，将得到文件结束（end-of-file）指示；</li><li>对于目录，文件长度通常是一个数（如16或512）的整倍数；</li><li>对于符号链接，其文件长度是文件名中的实际字节数。</li></ul> 
<h3><a id="413__232"></a>4.13 文件截断</h3> 
<p>为了截断文件可以调用函数<code>truncate</code>和<code>ftruncate</code>：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">truncate</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> off_t length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">ftruncate</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> off_t length<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>这两个函数将一个现有文件长度截断为<strong>length</strong>；</li><li>如果该文件以前的长度大于<strong>length</strong>，则超过<strong>length</strong>以外的数据就不再能访问；</li><li>如果以前的长度小于<strong>length</strong>，文件长度将增加，在以前的文件尾端和新的文件尾端之间的数据将读作<strong>0</strong>（也就是可能在文件中创建了一个空洞）。</li></ul> 
<h3><a id="414__245"></a>4.14 文件系统</h3> 
<p>可以把一个磁盘分成一个或多个分区，每个分区可以包含一个文件系统，<code>i节点</code>是固定长度的记录项，它包含有关文件的大部分信息：<br> <img src="https://images2.imgbox.com/b3/eb/liValffV_o.png" alt="磁盘、分区和文件"></p> 
<p><img src="https://images2.imgbox.com/20/50/8uCF1eLM_o.png" alt="在这里插入图片描述"></p> 
<ul><li>任何一个文件可以有多个目录项指向其i节点，每个i节点中都有一个链接计数，其值是指向该i节点的目录项数，只有当链接计数减少至0时，才可以删除该文件（也就是可以释放该文件占用的数据块），在<strong>stat</strong>结构中，链接计数包含在<strong>st_nlink</strong>成员中，其基本系统数据类型是<strong>nlink_t</strong>，这种链接类型称为<strong>硬链接</strong>；</li><li>另外一种链接类型称为符号链接，符号链接文件的实际内容（在数据块中）包含了该符号链接所指向的文件的名字；</li><li>i节点包含了文件有关的所有信息：<strong>文件类型</strong>、<strong>文件访问权限位</strong>、<strong>文件长度</strong>和<strong>指向文件数据块的指针</strong>等，<strong>stat</strong>结构中的大多数信息都取自i节点，只有文件名和i节点编号存放在目录项中；</li><li>一个目录项不能指向另一个文件系统的i节点。</li></ul> 
<h3><a id="415_linklinkatunlinkublinkatremove_255"></a>4.15 函数link、linkat、unlink、ublinkat和remove</h3> 
<p>创建一个指向现有文件的<code>硬链接</code>的方法是使用<code>link</code>函数或<code>linkat</code>函数：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">link</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>existingpath<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>newpath<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">linkat</span><span class="token punctuation">(</span><span class="token keyword">int</span> efd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>existingpath<span class="token punctuation">,</span> <span class="token keyword">int</span> nfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>newpath<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>这两个函数创建一个新目录项<strong>newpath</strong>，它引用现有文件<strong>existingpath</strong>，如果<strong>newpath</strong>已经存在，则返回出错；</li><li>只创建<strong>newpath</strong>中的最后一个分量，路径中的其他部分应当已经存在，例如，如果<strong>newpath</strong>是/home/data/abc，则必须要求/home/data目录已经存在，这点和<code>mkdir</code>函数要求一样；</li><li>对于<code>linkat</code>函数，现有文件是通过<strong>efd</strong>和<strong>existingpath</strong>参数指定的，新的路径名是通过<strong>nfd</strong>和<strong>newpath</strong>参数指定的。默认情况下，如果两个路径名中的任一个是相对路径，那么它需要通过相对于对应的文件描述符进行计算；如果两个文件描述符中的任一个设置为<strong>AT_FDCWD</strong>，那么相应的路径名（如果它是相对路径）就通过相对于当前目录计算；如果任一路径名是绝对路径，相应的文件描述符参数就会被忽略；</li><li>当现有文件是符号链接时，如果在<strong>flag</strong>参数中设置了<strong>AT_SYMLINK_FOLLOW</strong>标志，就创建指向符号链接目标的链接，如果这个标志被清除，则创建一个指向符号链接本身的链接。</li></ul> 
<p>为了删除一个现有的目录项，可以调用<code>unlink</code>函数：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">unlinkat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>这两个函数删除目录项，并将由<strong>pathname</strong>所引用文件的链接计数减<strong>1</strong>；如果对该文件还有其他链接，则仍可通过其他链接访问该文件的数据；只有当链接计数达到<strong>0</strong>时，该文件内容才可被删除；</li><li>如果<strong>pathname</strong>参数是相对路径，那么计算相对于<strong>fd</strong>文件描述符代表的目录的路径名；如果<strong>fd</strong>参数设置为<strong>AT_FDCWD</strong>，那么通过相对于调用进程的当前工作目录来计算路径名；如果<strong>pathname</strong>参数是绝对路径名，那么<strong>fd</strong>参数被忽略；</li><li>如果<strong>flag</strong>参数设置为<strong>AT_REMOVEDIR</strong>，<code>unlinkat</code>函数类似于<code>rmdir</code>一样删除目录，如果这个标志被删除，<code>unlinkat</code>与<code>unlink</code>执行同样操作；</li><li>如果<strong>pathname</strong>是符号链接，那么<code>unlink</code>删除该符号链接，而不是删除该链接所引用的文件。</li></ul> 
<p>可以使用<code>remove</code>函数解除对一个文件或目录的链接：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
								<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>对于文件，<code>remove</code>的功能与<code>unlink</code>相同；</li><li>对于目录，<code>remove</code>的功能与<code>rmdir</code>相同。</li></ul> 
<h3><a id="416_renamerenameat_294"></a>4.16 函数rename和renameat</h3> 
<p>文件或目录可以用<code>rename</code>函数或者<code>renameat</code>函数进行重命名：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">rename</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>oldname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>newname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">renameat</span><span class="token punctuation">(</span><span class="token keyword">int</span> oldfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>oldname<span class="token punctuation">,</span> <span class="token keyword">int</span> newfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>newname<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>如果<strong>oldname</strong>指定了相对路径，就相对于<strong>oldfd</strong>参数引用的目录来计算<strong>oldname</strong>，<strong>newname</strong>类似；</li><li><strong>oldfd</strong>或<strong>newfd</strong>参数（或两者）都能设置成<strong>AT_FDCWD</strong>，此时相对于当前目录来计算相应的路径名。</li></ul> 
<h3><a id="417__306"></a>4.17 符号链接</h3> 
<p>符号链接是对一个文件的间接指针，它与硬链接不同，硬链接直接指向文件的i节点，引入符号链接的原因是为了避开硬链接的一些限制：</p> 
<ul><li>硬链接通常要求链接和文件位于同一文件系统；</li><li>只有超级用户才能创建指向目录的硬链接。</li></ul> 
<p>对符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可以创建指向目录的符号链接；符号链接一般用于将一个文件或整个目录结构移到系统中的另一个位置。</p> 
<h3><a id="418__312"></a>4.18 创建和读取符号链接</h3> 
<p>可以用<code>symlink</code>或<code>symlinkat</code>函数创建一个符号链接：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">symlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>actualpath<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>sympath<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">symlinkat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>actualpath<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>sympath<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>在创建此符号链接时，并不要求<strong>actualpath</strong>已经存在；</li><li><strong>actualpath</strong>和<strong>sympath</strong>并不需要位于同一文件系统中；</li><li><code>symlinkat</code>函数的<strong>sympath</strong>参数根据相对于打开文件描述符引用的目录（由<strong>fd</strong>参数指定）进行计算；如果<strong>sympath</strong>参数指定的是绝对路径或者<strong>fd</strong>参数设置了<strong>AT_FDCWD</strong>值，那么<code>symlinkat</code>就等同于<code>symlink</code>函数。</li></ul> 
<p>可以用<code>readlink</code>和<code>readlinkat</code>函数来打开符号链接本身：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

ssize_t <span class="token function">readlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict pathname<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict buf<span class="token punctuation">,</span> size_t bufsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">readlinkat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict pathname<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict buf<span class="token punctuation">,</span> size_t bufsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 两个函数的返回值：若成功，返回读取的字节数；若出错，返回-1</span>
</code></pre> 
<ul><li>如果函数成功执行，则返回读入<strong>buf</strong>的字节数，在<strong>buf</strong>中返回的符号链接的内容不以<strong>null</strong>字节终止；</li><li>当<strong>pathname</strong>参数指定的是绝对路径名或者<strong>fd</strong>参数的值为<strong>AT_FDCWD</strong>，<code>readlinkat</code>函数的行为与<code>readlink</code>相同；</li><li>如果<strong>fd</strong>参数是一个打开目录的有效文件描述符并且<strong>pathname</strong>参数是相对路径名，则<code>readlinkat</code>计算相对于由<strong>fd</strong>代表的打开目录的路径名。</li></ul> 
<h3><a id="419__338"></a>4.19 文件的时间</h3> 
<p>每个文件维护3个时间字段，保存在<strong>stat</strong>结构中：</p> 
<ul><li><strong>st_atime</strong>：文件数据的最后访问时间；</li><li><strong>st_mtime</strong>：文件数据的最后修改时间；</li><li><strong>st_ctime</strong>：i节点状态的最后更改时间。</li></ul> 
<h3><a id="420_futimensutimensatutimes_343"></a>4.20 函数futimens、utimensat和utimes</h3> 
<p>一个文件的访问时间和修改时间可以用<code>futimens</code>和<code>utimensat</code>函数修改，它们使用<strong>纳秒级</strong>精度的时间戳：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">futimens</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> times<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">utimensat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> times<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>这两个函数的<strong>times</strong>数组参数的第一个元素包含<strong>访问时间</strong>，第二个元素包含<strong>修改时间</strong>；</li><li><code>futimens</code>函数需要打开文件来更改它的时间；</li><li><code>utimensat</code>函数的<strong>pathname</strong>参数是相对于<strong>fd</strong>参数进行计算的，<strong>fd</strong>要么是打开目录的文件描述符，要么设置为特殊值<strong>AT_FDCWD</strong>；如果<strong>pathname</strong>指定了绝对路径，那么<strong>fd</strong>参数被忽略。</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">/* POSIX.1b structure for a time value.  This is like a `struct timeval' but
   has nanoseconds instead of microseconds.  */</span>
<span class="token keyword">struct</span> <span class="token class-name">timespec</span>
<span class="token punctuation">{<!-- --></span>
  __time_t tv_sec<span class="token punctuation">;</span>		<span class="token comment">/* Seconds.  */</span>
  __syscall_slong_t tv_nsec<span class="token punctuation">;</span>	<span class="token comment">/* Nanoseconds.  */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">utimes</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> times<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 函数返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li><code>utimes</code>函数对路径名进行操作；</li><li><strong>times</strong>参数是指向包含两个时间戳（<strong>访问时间</strong>和<strong>修改时间</strong>）元素的数组的指针，两个时间戳是用秒和<strong>微妙</strong>表示的。</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">/* A time value that is accurate to the nearest
   microsecond but also has a range of years.  */</span>
<span class="token keyword">struct</span> <span class="token class-name">timeval</span>
<span class="token punctuation">{<!-- --></span>
  __time_t tv_sec<span class="token punctuation">;</span>		<span class="token comment">/* Seconds.  */</span>
  __suseconds_t tv_usec<span class="token punctuation">;</span>	<span class="token comment">/* Microseconds.  */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="421_mkdirmkdiratrmdir_387"></a>4.21 函数mkdir、mkdirat和rmdir</h3> 
<p>用<code>mkdir</code>和<code>mkdirat</code>函数创建目录：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">mkdirat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 两个函数返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>这两个函数创建一个新目录，其中**.<strong>和</strong>…**目录项是自动创建的；</li><li>所指定的文件访问权限<strong>mode</strong>由进程的文件模式创建屏蔽字修改，对于目录通常至少要设置一个执行权限位，以允许访问该目录中的文件名；</li><li>当<code>mkdirat</code>函数的<strong>fd</strong>参数具有特殊值<strong>AT_FDCWD</strong>或者<strong>pathname</strong>参数指定了绝对路径名时，<code>mkdirat</code>和<code>mkdir</code>完全一样，否则，当<strong>fd</strong>参数是一个打开目录，相对路径名根据此打开目录来计算。</li></ul> 
<p>用<code>rmdir</code>函数删除目录：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">rmdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
								<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<h3><a id="422__409"></a>4.22 读目录</h3> 
<p>对某个目录具有访问权限的任一用户都可以读该目录，但为了防止文件系统产生混乱，只有内核才能写目录。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;dirent.h&gt;</span></span>

DIR <span class="token operator">*</span><span class="token function">opendir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
DIR <span class="token operator">*</span><span class="token function">fdopendir</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
								<span class="token comment">// 两个函数返回值：若成功，返回指针；若出错，返回NULL</span>
<span class="token keyword">struct</span> <span class="token class-name">dirent</span> <span class="token operator">*</span><span class="token function">readdir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
								<span class="token comment">// 返回值：若成功，返回指针；若在目录尾或出错，返回NULL</span>
<span class="token keyword">void</span> <span class="token function">rewinddir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">closedir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
								<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
<span class="token keyword">long</span> <span class="token function">telldir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
								<span class="token comment">// 返回值：与dp关联的目录中的当前位置</span>
<span class="token keyword">void</span> <span class="token function">seekdir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dp<span class="token punctuation">,</span> <span class="token keyword">long</span> loc<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="423_chdirfchdirgetcwd_427"></a>4.23 函数chdir、fchdir和getcwd</h3> 
<p>进程使用<code>chdir</code>或<code>fchdir</code>函数可以更改当前工作目录：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">chdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fchdir</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
								<span class="token comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>在这两个函数中，分别用<strong>pathname</strong>或打开文件描述符来指定新的当前工作目录；</li><li>当前工作目录是进程的一个属性，只影响调用<code>chdir</code>的进程本身，而不影响其他进程。</li></ul> 
<p>可以用<code>getcwd</code>函数获取当前工作目录完整的绝对路径名：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">getcwd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回buf；若出错，返回NULL</span>
</code></pre> 
<h3><a id="424__448"></a>4.24 设备特殊文件</h3> 
<ul><li>每个文件系统所在的存储设备都由其<strong>主、次设备号</strong>表示，设备号所用的数据类型是基本系统数据类型<strong>dev_t</strong>，主设备号标识设备驱动程序，次设备号标识特定的子设备；</li><li>通常可以使用两个宏：<code>major</code>和<code>minor</code>来访问主、次设备号；</li><li>系统中与每个文件名关联的<strong>st_dev</strong>值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的i节点；</li><li>只有<strong>字符特殊文件</strong>和<strong>块特殊文件</strong>才有<strong>st_rdev</strong>值，此值包含实际设备的设备号。</li></ul> 
<h3><a id="425__453"></a>4.25 文件访问权限位小结</h3> 
<p><img src="https://images2.imgbox.com/6f/97/LhxC0qjy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="426__457"></a>4.26 实例代码</h3> 
<p><a href="https://github.com/MinBadGuy/APUE/tree/main/chapter4">chapter4</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a54633eb87fb627fa67d70fe8ea228fb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LVGL学习笔记 26 - 色环ColorWheel</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eca70444a2bfd032cc07c376174ecbf2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【考研|数据结构】严蔚敏清华大学第2版笔记 第一章</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>