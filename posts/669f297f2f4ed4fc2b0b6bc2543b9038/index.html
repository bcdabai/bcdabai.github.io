<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【嵌入式】STM32F4的ADC采样——多通道、DMA、定时器触发 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【嵌入式】STM32F4的ADC采样——多通道、DMA、定时器触发" />
<meta property="og:description" content="文章目录 一、硬件原理简介1.1 ADC1.2 定时器1.3 DMA 二、软件配置2.1 ADC配置2.2 TIM配置2.3 DMA配置 最后.上代码 项目中需要对三个通道的电压进行一定频率的AD采样，由于采样过程贯穿整个任务，为了使采样过程尽可能不占用CPU资源，采用定时器触发的多通道ADC扫描采样，且采样数据由DMA传到RAM中的缓存。 这样做有以下几个好处：1、由定时器触发ADC采样，这样采样的频率可控，且定时器触发不会占用任何CPU资源；2、DMA进一步降低了任务对CPU的占有率。 一、硬件原理简介 1.1 ADC ADC的规则通道扫描采样不再赘述，配置好规则通道后，可以采用软件触发的方式开启AD转换，也可通过外部触发，如下图所示。可以通过定时器以及外部中断方式触发。
使用定时器触发时，最好实现的为TIM3_TRGO事件，这个事件将在下面介绍。也就是说当ADC转换配置为不连续模式时，每发生一次TIM3_TRGO事件，就会触发ADC进行一次规则通道的转换。
1.2 定时器 前面提到TIM3_TRGO事件，那什么是TIM3_TRGO呢。看下图，可以把它理解为一个定时器内部输出的信号，当满足一定条件时他就输出一个信号到其他外设，从而触发其他外设的某些操作。运用在ADC中即是触发ADC的一次规则通道转换。
1.3 DMA 其实这个没什么好说的，就是配置好，根据你所用的ADC来选择DMA设备，且配置相应的数据流和通道就好了。具体如何选择数据流和通道，看下图。
二、软件配置 提到外设的配置，怎么能少的了STM32Cube这个神器呢，了解了以上硬件原理后，我们可以使用STM32Cube轻松配置需要使用的外设，无非就三个外设——ADC、DMA、TIM。
2.1 ADC配置 这里我选用了ADC1的0、1、2三个通道作为采样通道
到外设配置里，如下图配置，打箭头的位置需要注意：1、由于实用的是定时器触发的AD转换，故 连续模式要disable，这样才能定时器触发一次就转换一次选中的3个规则通道；2、由于是多通道，所以要开启扫描模式；3、使用了DMA；4、外部触发方式选择TIM2的Trigger Out event，就是一直在说的TRGO。其他的诸如分频、左右对齐、AD转换位数、转换周期等都不是重点。
同时，由于使用了DMA，故在上图的DMA Setting选项卡中做如下设置：1、根据DMA硬件原理中的DMA映射选择DMA2的数据流0，通道在这里没有体现，应该是通道0，当STM32Cube生成代码时可以看到已经配置好了；2、开启循环模式，否则一次DMA转换完成后就停止了；3、由于有三个通道，一轮ADC转换完成后会有三个采样值，这三个采样值将依次触发DMA请求，所以需要设置DMA内存地址递增，否则1号通道的值就会覆盖0号的值，2号的值又会覆盖1号的值；4、由于STM32的ADC最大就是12位，所以配置为半字(16位)足够。
2.2 TIM配置 这里使用了TIM2，配置如下。实验中经过时钟树分频后，到TIM2的时钟为60MHz，此时配置TIM2预分频为35、重载值为375的向上计数模式，计数器每溢出一次就会产生一个更新事件。而按图中配置，更新事件将会触发TRGO信号。那么此时的采样频率为60MHz/35/375 = 3200Hz，也就是1秒钟触发3200次3通道的转换。
2.3 DMA配置 DMA没啥配置。。。因为在ADC配置中已经都配置好了，需要注意三点：1、就是要记得开启DMA中断，并在中断服务函数中及时的对AD采样值处理；2、开始DMA的ADC转换：HAL_ADC_Start_DMA(&amp;hadc1,buffer,3)，buffer即为DMA接收缓存，3表示DMA传输的数据大小，即传输3个半字后就产生传输完成中断；3、不用DMA的传输完成一半中断的话记得关掉，以免DMA中断服务被没必要的调用。
最后.上代码 当然，这些代码都是STM32Cube生成的，你需要做的仅仅就是写一个好用的DMA中断服务函数，具体流程就是判断来了传输完成中断-&gt;请标志位-&gt;将DMA缓存中的数据拷贝到数据处理的缓存，然后做什么就有你而定了。
void MX_GPIO_Init(void) { /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOH_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); } ADC_HandleTypeDef hadc1; DMA_HandleTypeDef hdma_adc1; /* ADC1 init function */ void MX_ADC1_Init(void) { ADC_ChannelConfTypeDef sConfig; /**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) */ hadc1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/669f297f2f4ed4fc2b0b6bc2543b9038/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-22T23:03:22+08:00" />
<meta property="article:modified_time" content="2019-08-22T23:03:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【嵌入式】STM32F4的ADC采样——多通道、DMA、定时器触发</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#_4" rel="nofollow">一、硬件原理简介</a></li><li><ul><li><a href="#11_ADC_5" rel="nofollow">1.1 ADC</a></li><li><a href="#12__8" rel="nofollow">1.2 定时器</a></li><li><a href="#13_DMA_10" rel="nofollow">1.3 DMA</a></li></ul> 
    </li><li><a href="#_14" rel="nofollow">二、软件配置</a></li><li><ul><li><a href="#21_ADC_16" rel="nofollow">2.1 ADC配置</a></li><li><a href="#22_TIM_21" rel="nofollow">2.2 TIM配置</a></li><li><a href="#23_DMA_23" rel="nofollow">2.3 DMA配置</a></li></ul> 
    </li><li><a href="#_25" rel="nofollow">最后.上代码</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<br> 项目中需要对三个通道的电压进行一定频率的AD采样，由于采样过程贯穿整个任务，为了使采样过程尽可能不占用CPU资源，采用定时器触发的多通道ADC扫描采样，且采样数据由DMA传到RAM中的缓存。 
<br> 这样做有以下几个好处：1、由定时器触发ADC采样，这样采样的频率可控，且定时器触发不会占用任何CPU资源；2、DMA进一步降低了任务对CPU的占有率。 
<p></p> 
<h4><a id="_4"></a>一、硬件原理简介</h4> 
<h5><a id="11_ADC_5"></a>1.1 ADC</h5> 
<p>ADC的规则通道扫描采样不再赘述，配置好规则通道后，可以采用软件触发的方式开启AD转换，也可通过外部触发，如下图所示。可以通过定时器以及外部中断方式触发。<img src="https://images2.imgbox.com/1f/e8/6AWNMoI5_o.png" alt="在这里插入图片描述"><br> 使用定时器触发时，最好实现的为TIM3_TRGO事件，这个事件将在下面介绍。也就是说当ADC转换配置为不连续模式时，每发生一次TIM3_TRGO事件，就会触发ADC进行一次规则通道的转换。</p> 
<h5><a id="12__8"></a>1.2 定时器</h5> 
<p>前面提到TIM3_TRGO事件，那什么是TIM3_TRGO呢。看下图，可以把它理解为一个定时器内部输出的信号，当满足一定条件时他就输出一个信号到其他外设，从而触发其他外设的某些操作。运用在ADC中即是触发ADC的一次规则通道转换。<img src="https://images2.imgbox.com/c8/9e/xzN8HbxM_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="13_DMA_10"></a>1.3 DMA</h5> 
<p>其实这个没什么好说的，就是配置好，根据你所用的ADC来选择DMA设备，且配置相应的数据流和通道就好了。具体如何选择数据流和通道，看下图。<br> <img src="https://images2.imgbox.com/31/ac/yfwtml8z_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d4/54/GYpG0qhb_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_14"></a>二、软件配置</h4> 
<p>提到外设的配置，怎么能少的了STM32Cube这个神器呢，了解了以上硬件原理后，我们可以使用STM32Cube轻松配置需要使用的外设，无非就三个外设——ADC、DMA、TIM。</p> 
<h5><a id="21_ADC_16"></a>2.1 ADC配置</h5> 
<p>这里我选用了ADC1的0、1、2三个通道作为采样通道<img src="https://images2.imgbox.com/4d/92/n6udAtri_o.png" alt="在这里插入图片描述"><br> 到外设配置里，如下图配置，打箭头的位置需要注意：1、由于实用的是定时器触发的AD转换，故 连续模式要disable，这样才能定时器触发一次就转换一次选中的3个规则通道；2、由于是多通道，所以要开启扫描模式；3、使用了DMA；4、外部触发方式选择TIM2的Trigger Out event，就是一直在说的TRGO。其他的诸如分频、左右对齐、AD转换位数、转换周期等都不是重点。<br> <img src="https://images2.imgbox.com/4b/39/eDxhP0vE_o.png" alt="在这里插入图片描述"><br> 同时，由于使用了DMA，故在上图的DMA Setting选项卡中做如下设置：1、根据DMA硬件原理中的DMA映射选择DMA2的数据流0，通道在这里没有体现，应该是通道0，当STM32Cube生成代码时可以看到已经配置好了；2、开启循环模式，否则一次DMA转换完成后就停止了；3、由于有三个通道，一轮ADC转换完成后会有三个采样值，这三个采样值将依次触发DMA请求，所以需要设置DMA内存地址递增，否则1号通道的值就会覆盖0号的值，2号的值又会覆盖1号的值；4、由于STM32的ADC最大就是12位，所以配置为半字(16位)足够。<img src="https://images2.imgbox.com/b3/e3/v0Y7lYYP_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="22_TIM_21"></a>2.2 TIM配置</h5> 
<p>这里使用了TIM2，配置如下。实验中经过时钟树分频后，到TIM2的时钟为60MHz，此时配置TIM2预分频为35、重载值为375的向上计数模式，计数器每溢出一次就会产生一个更新事件。而按图中配置，更新事件将会触发TRGO信号。那么此时的采样频率为60MHz/35/375 = 3200Hz，也就是1秒钟触发3200次3通道的转换。<img src="https://images2.imgbox.com/da/9b/CKpPvi5P_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="23_DMA_23"></a>2.3 DMA配置</h5> 
<p>DMA没啥配置。。。因为在ADC配置中已经都配置好了，需要注意三点：1、就是要记得开启DMA中断，并在中断服务函数中及时的对AD采样值处理；2、开始DMA的ADC转换：HAL_ADC_Start_DMA(&amp;hadc1,buffer,3)，buffer即为DMA接收缓存，3表示DMA传输的数据大小，即传输3个半字后就产生传输完成中断；3、不用DMA的传输完成一半中断的话记得关掉，以免DMA中断服务被没必要的调用。</p> 
<h4><a id="_25"></a>最后.上代码</h4> 
<p>当然，这些代码都是STM32Cube生成的，你需要做的仅仅就是写一个好用的DMA中断服务函数，具体流程就是判断来了传输完成中断-&gt;请标志位-&gt;将DMA缓存中的数据拷贝到数据处理的缓存，然后做什么就有你而定了。</p> 
<pre><code>void MX_GPIO_Init(void)
{

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

}

ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
  ADC_ChannelConfTypeDef sConfig;

    /**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
    */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV2;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
  hadc1.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T2_TRGO;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 3;
  hadc1.Init.DMAContinuousRequests = ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
  if (HAL_ADC_Init(&amp;hadc1) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
    */
  sConfig.Channel = ADC_CHANNEL_0;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
  if (HAL_ADC_ConfigChannel(&amp;hadc1, &amp;sConfig) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }
	
    /**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
    */
  sConfig.Channel = ADC_CHANNEL_1;
  sConfig.Rank = 2;
  if (HAL_ADC_ConfigChannel(&amp;hadc1, &amp;sConfig) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
    */
  sConfig.Channel = ADC_CHANNEL_2;
  sConfig.Rank = 3;
  if (HAL_ADC_ConfigChannel(&amp;hadc1, &amp;sConfig) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

}

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if(adcHandle-&gt;Instance==ADC1)
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* ADC1 clock enable */
    __HAL_RCC_ADC1_CLK_ENABLE();
  
    /**ADC1 GPIO Configuration    
    PA0-WKUP     ------&gt; ADC1_IN0
    PA1     ------&gt; ADC1_IN1
    PA2     ------&gt; ADC1_IN2 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);

    /* ADC1 DMA Init */
    /* ADC1 Init */
    hdma_adc1.Instance = DMA2_Stream0;
    hdma_adc1.Init.Channel = DMA_CHANNEL_0;
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&amp;hdma_adc1) != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}

void HAL_ADC_MspDeInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle-&gt;Instance==ADC1)
  {
  /* USER CODE BEGIN ADC1_MspDeInit 0 */

  /* USER CODE END ADC1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_ADC1_CLK_DISABLE();
  
    /**ADC1 GPIO Configuration    
    PA0-WKUP     ------&gt; ADC1_IN0
    PA1     ------&gt; ADC1_IN1
    PA2     ------&gt; ADC1_IN2 
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2);

    /* ADC1 DMA DeInit */
    HAL_DMA_DeInit(adcHandle-&gt;DMA_Handle);
  /* USER CODE BEGIN ADC1_MspDeInit 1 */

  /* USER CODE END ADC1_MspDeInit 1 */
  }
} 
void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();

}
TIM_HandleTypeDef htim2;

/* TIM2 init function */
void MX_TIM2_Init(void)
{
  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;

  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 35 - 1;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 375 - 1 ;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  if (HAL_TIM_Base_Init(&amp;htim2) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&amp;htim2, &amp;sClockSourceConfig) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&amp;htim2, &amp;sMasterConfig) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

}

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{

  if(tim_baseHandle-&gt;Instance==TIM2)
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* TIM2 clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
}

void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef* tim_baseHandle)
{

  if(tim_baseHandle-&gt;Instance==TIM2)
  {
  /* USER CODE BEGIN TIM2_MspDeInit 0 */

  /* USER CODE END TIM2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM2_CLK_DISABLE();
  /* USER CODE BEGIN TIM2_MspDeInit 1 */

  /* USER CODE END TIM2_MspDeInit 1 */
  }
} 
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/505652b2970ef2f33452697be71a76cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">idea SVN提交更新异常：Error：svn:E155037:Previous operation has not finished; run &#39;cleanup&#39; if it was interr</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/61d22779a3a7587ca0500bdd2c31df1c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Git remote: Unauthorized</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>