<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>leetcode-347-前K个高频元素(top k frequent elements)-java - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="leetcode-347-前K个高频元素(top k frequent elements)-java" />
<meta property="og:description" content="题目及测试
package pid374; /* 前K个高频元素 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 */ import java.util.List; public class main { public static void main(String[] args) { int[][] testTable = {{1,1,1,2,2,3},{1}}; int[] testTable2={2,1}; for (int i=0;i&lt;testTable.length;i&#43;&#43;) { test(testTable[i],testTable2[i]); } } private static void test(int[] ito,int ito2) { List&lt;Integer&gt; rtn; Solution solution=new Solution(); long begin = System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/042bb9a86770482cacc527bf61d0c29a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-30T10:47:13+08:00" />
<meta property="article:modified_time" content="2018-11-30T10:47:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">leetcode-347-前K个高频元素(top k frequent elements)-java</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>题目及测试</p> 
<pre class="has"><code class="language-java">package pid374;
/* 前K个高频元素

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]

示例 2:

输入: nums = [1], k = 1
输出: [1]

说明：

    你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
    你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。


*/

import java.util.List;

public class main {
	
	public static void main(String[] args) {
		int[][] testTable = {<!-- -->{1,1,1,2,2,3},{1}};
		int[] testTable2={2,1};
		for (int i=0;i&lt;testTable.length;i++) {
			test(testTable[i],testTable2[i]);
		}
	}
		 
	private static void test(int[] ito,int ito2) {
		List&lt;Integer&gt; rtn;
		Solution solution=new Solution();
		long begin = System.currentTimeMillis();
		for (int i = 0; i &lt; ito.length; i++) {
		    System.out.print(ito[i]+" ");		    
		}
		System.out.println();
		//开始时打印数组
		System.out.println("ito2="+ito2);
		rtn = solution.topKFrequent(ito,ito2);//执行程序
		long end = System.currentTimeMillis();	
		
		System.out.println(ito + ": rtn=" );
		System.out.println( " rtn=" );
		for (int i = 0; i &lt; rtn.size(); i++) {
		    System.out.print(rtn.get(i)+" ");
		}//打印结果几数组
		
		System.out.println();
		System.out.println("耗时：" + (end - begin) + "ms");
		System.out.println("-------------------");
	}

}
</code></pre> 
<p> </p> 
<p>解法1（成功，22ms，很快）</p> 
<p>其实该提就是对map的value进行排序，方法</p> 
<pre class="has"><code class="language-java">    List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(map.entrySet());  
    Collections.sort(list, new Comparator&lt;Entry&lt;Integer, Integer&gt;&gt;() {
        @Override
        public int compare(Entry&lt;Integer, Integer&gt; o1,
                Entry&lt;Integer, Integer&gt; o2) {
                if(o2.getValue().compareTo(o1.getValue())&gt;0){  
                    return 1;  
               }else if(o2.getValue().compareTo(o1.getValue())&lt;0){  
                    return -1;  
               }  else {
                   return 0;
               }
        }</code></pre> 
<p style="margin-left:0cm;">先建立map，key为int[i]，value为该值得次数，然后将map化为set，化为list，用collections。Sort对list排序，然后取出前k个的key即可</p> 
<pre class="has"><code class="language-java">package pid374;

import java.lang.reflect.Array;
import java.util.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

class Solution {
public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
    HashMap&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;();
    List&lt;Integer&gt; result=new ArrayList&lt;&gt;();
    int length=nums.length;
    for(int i=0;i&lt;length;i++){
    	int now=nums[i];
    	if(map.containsKey(now)){
    		map.put(now, map.get(now)+1);
    	}
    	else{
    		map.put(now,1);
    	}
    }
    List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(map.entrySet());  
    Collections.sort(list, new Comparator&lt;Entry&lt;Integer, Integer&gt;&gt;() {
        @Override
        public int compare(Entry&lt;Integer, Integer&gt; o1,
                Entry&lt;Integer, Integer&gt; o2) {
                if(o2.getValue().compareTo(o1.getValue())&gt;0){  
                    return 1;  
               }else if(o2.getValue().compareTo(o1.getValue())&lt;0){  
                    return -1;  
               }  else {
                   return 0;
               }
        }
                  
    });
    for(int i=0;i&lt;k;i++){
    	result.add(list.get(i).getKey());
    }
	return result;
    }
}

</code></pre> 
<p>解法2（成功，22ms，较快）</p> 
<p>对value，放入treemap中排序，</p> 
<pre class="has"><code class="language-java">	public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
		List&lt;Integer&gt; result=new ArrayList&lt;&gt;();
		int length=nums.length;
		if(length==0||k==0){
			return result;
		}
		// key为数字，value为数字出现的个数
		HashMap&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;();
		for(int i=0;i&lt;length;i++){
			int now=nums[i];
			if(map.containsKey(now)){
				map.put(now, map.get(now)+1);
			}else{
				map.put(now, 1);
			}
		}
		// key为数字出现的个数，value为数字
		TreeMap&lt;Integer, List&lt;Integer&gt;&gt; treeMap=new TreeMap&lt;&gt;();
		for(Integer now:map.keySet()){
			Integer num=map.get(now);
			if(treeMap.containsKey(num)){
				List&lt;Integer&gt; list=treeMap.get(num);
				list.add(now);
			}else{
				List&lt;Integer&gt; list=new ArrayList&lt;&gt;();
				list.add(now);
				treeMap.put(num, list);
			}
		}
		for(Integer num:treeMap.descendingMap().keySet()){
			List&lt;Integer&gt; list=treeMap.get(num);
			for(int i=0;i&lt;list.size();i++){
				result.add(list.get(i));
				k--;
				if(k==0){
					return result;
				}
			}
		}		
		return result;
	}</code></pre> 
<p>解法3（别人的）</p> 
<p>最小堆，对values，使用最小堆排序，对于 k 频率之后的元素不用再去处理，进一步优化时间复杂度。</p> 
<p><img alt="" class="has" height="768" src="https://images2.imgbox.com/86/17/XhCOsqwY_o.png" width="1024"></p> 
<p>借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率<br> 维护一个元素数目为 k的最小堆<br> 每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较<br> 如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中<br> 最终，堆中的 k个元素即为前 k个高频元素</p> 
<pre class="has"><code class="language-java">

class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
        HashMap&lt;Integer,Integer&gt; map = new HashMap();
        for(int num : nums){
            if (map.containsKey(num)) {
               map.put(num, map.get(num) + 1);
             } else {
                map.put(num, 1);
             }
        }
        // 遍历map，用最小堆保存频率最大的k个元素
        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {
            @Override
            public int compare(Integer a, Integer b) {
                return map.get(a) - map.get(b);
            }
        });
        for (Integer key : map.keySet()) {
            if (pq.size() &lt; k) {
                pq.add(key);
            } else if (map.get(key) &gt; map.get(pq.peek())) {
                pq.remove();
                pq.add(key);
            }
        }
        // 取出最小堆中的元素
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        while (!pq.isEmpty()) {
            res.add(pq.remove());
        }
        return res;
    }
}

</code></pre> 
<p>解法4（别人的）</p> 
<p>对values计数排序</p> 
<p><img alt="" class="has" height="768" src="https://images2.imgbox.com/84/05/bpXODXTV_o.png" width="1024"></p> 
<p> </p> 
<pre class="has"><code class="language-java">

//基于桶排序求解「前 K 个高频元素」
class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        List&lt;Integer&gt; res = new ArrayList();
        // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
        HashMap&lt;Integer,Integer&gt; map = new HashMap();
        for(int num : nums){
            if (map.containsKey(num)) {
               map.put(num, map.get(num) + 1);
             } else {
                map.put(num, 1);
             }
        }
        
        //桶排序
        //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标
        List&lt;Integer&gt;[] list = new List[nums.length+1];
        for(int key : map.keySet()){
            // 获取出现的次数作为下标
            int i = map.get(key);
            if(list[i] == null){
               list[i] = new ArrayList();
            } 
            list[i].add(key);
        }
        
        // 倒序遍历数组获取出现顺序从大到小的排列
        for(int i = list.length - 1;i &gt;= 0 &amp;&amp; res.size() &lt; k;i--){
            if(list[i] == null) continue;
            res.addAll(list[i]);
        }
        return res;
    }
}

</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb0c68ab40c9ccdc5cfafa8622055efc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FrameBuffer</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/94a1113fa68e2f2e0496a09ba382c969/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构: 栈与队列总结&#43;思维导图</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>