<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>老鸟必修代码精简技能：Lambda表达式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="老鸟必修代码精简技能：Lambda表达式" />
<meta property="og:description" content="点击上方“猿芯”，选择“设为星标”
后台回复&#34;1024&#34;，有份惊喜送给面试的你
Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。
1.1 语法组成 操作符为&#34; -&gt; &#34; ，被称为 Lambda 操作符或箭头操作符;
将 Lambda 分为两个部分：
左侧:指定了 Lambda 表达式需要的参数列表；
右侧:指定了 Lambda 体，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功能。
1.2 基本用法 1.2.1 未使用和使用Lambda表达式的区别 @Slf4j public class TestLambda { //未使用和使用lambda表达式，对比 static void testRunLambdaContrast(){ // 不使用lambda表达式，创建一个线程 Runnable runnable1 = new Runnable() { @Override public void run() { log.info(&#34;------ 不使用lambda表达式，创建一个线程 ------&#34;); } }; // 启动线程 new Thread(runnable1).start(); // 使用lambda表达式，创建一个线程 Runnable runnable2 = () -&gt; log.info(&#34;------ 使用lambda表达式，创建一个线程 ------&#34;); // 启动线程2 new Thread(runnable2)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c9e537ace7a0d544041aac6ac31b1133/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-18T09:04:53+08:00" />
<meta property="article:modified_time" content="2022-10-18T09:04:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">老鸟必修代码精简技能：Lambda表达式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:center;">点击上方“<strong>猿芯</strong>”，选择“<strong>设为星标</strong>”</p> 
 <p style="text-align:center;">后台回复"<strong>1024</strong>"，有份惊喜送给面试的你</p> 
 <p style="text-align:left;">Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p> 
 <h4>1.1 语法组成</h4> 
 <ol><li><p>操作符为" -&gt; " ，被称为 Lambda 操作符或箭头操作符;</p></li><li><p>将 Lambda 分为两个部分：</p> 
   <ol><li><p>左侧:指定了 Lambda 表达式需要的<strong>参数列表</strong>；</p></li><li><p>右侧:指定了 Lambda 体，是<strong>抽象方法的实现逻辑</strong>，也即Lambda 表达式<strong>要执行的功能。</strong></p></li></ol></li></ol> 
 <h4>1.2 基本用法</h4> 
 <h5>1.2.1 未使用和使用Lambda表达式的区别</h5> 
 <pre class="has"><code class="language-go">@Slf4j
public class TestLambda {
    
    //未使用和使用lambda表达式，对比
    static void testRunLambdaContrast(){
        // 不使用lambda表达式，创建一个线程
        Runnable runnable1 = new Runnable() {
            @Override
            public void run() {
                log.info("------ 不使用lambda表达式，创建一个线程 ------");
            }
        };
        // 启动线程
        new Thread(runnable1).start();

        // 使用lambda表达式，创建一个线程
        Runnable runnable2 = () -&gt; log.info("------ 使用lambda表达式，创建一个线程 ------");
        // 启动线程2
        new Thread(runnable2).start();
    }
    
    public static void main(String[] args) {
        
        //测试 未使用和使用lambda表达式，对比
        testRunLambdaContrast();
        
    }
    
}</code></pre> 
 <p style="text-align:left;">总结：未使用和使用Lambda表达式都可以实现抽象方法，但是使用Lambda方法后会更加简洁；</p> 
 <h5>1.2.2 带一个参数没有返回值</h5> 
 <h6>1.2.2.1 带一个参数没有返回值 标准写法</h6> 
 <pre class="has"><code class="language-go">// 借助java8中 消费型函数式接口，讲解基本用法
// 不使用lambda表达式实现
Consumer&lt;String&gt; consumer1 = new Consumer&lt;String&gt;() {
    @Override
    public void accept(String s) {
        log.info("------ 不使用lambda表达式，实现Consumer1接口，消费数据：{} ------",s);
    }
};

// 使用消费型接口1
consumer1.accept("kh96正在学习lambda表达式，标准写法");

// 使用lambda表达式，用法：带 1 个参数，没有返回值，标准写法
Consumer&lt;String&gt; consumer2 = (String s) -&gt; {
    log.info("------ 使用lambda表达式，实现Consumer2接口，消费数据：{} ------",s);
};

// 使用消费型接口2
consumer2.accept("kh96正在学习lambda表达式，标准写法");</code></pre> 
 <h6>1.2.2.2 简化写法：一个参数，可以省略类型声明</h6> 
 <pre class="has"><code class="language-go">//一个参数，可以省略类型声明
Consumer&lt;String&gt; consumer3 = (s) -&gt; {
    log.info("------ 使用lambda表达式，实现Consumer3接口，消费数据：{} ------",s);
};

consumer3.accept("kh96正在学习lambda表达式，一个参数，可以省略类型声明");</code></pre> 
 <h6>1.2.2.3 简化写法：一个参数，可以省略小括号（没有参数，多个参数不能省略）</h6> 
 <pre class="has"><code class="language-go">//一个参数，可以省略小括号（没有参数，多个参数不能省略）
Consumer&lt;String&gt; consumer4 = s -&gt; {
    log.info("------ 使用lambda表达式，实现Consumer4接口，消费数据：{} ------",s);
};

consumer4.accept("kh96正在学习lambda表达式，一个参数，可以省略小括号");</code></pre> 
 <h6>1.2.2.4 简化写法：实现只有一条语句，可以省略大括号（有多条语句，不可以省略）</h6> 
 <pre class="has"><code class="language-go">//实现只有一条语句，可以省略大括号（有多条语句，不可以省略）
Consumer&lt;String&gt; consumer5 = s -&gt; log.info("------ 使用lambda表达式，实现Consumer3接口，消费数据：{} ------",s);

consumer5.accept("kh96正在学习lambda表达式，实现只有一条语句，可以省略大括号");</code></pre> 
 <h6>1.2.2.5 简化写法：实现有多条语句，不可以省略大括号</h6> 
 <pre class="has"><code class="language-go">//实现有多条语句，不可以省略大括号
Consumer&lt;String&gt; consumer6 = s -&gt; {
    log.info("------ 使用lambda表达式，实现Consumer3接口，消费数据：{} ------",s);
    log.info("------ 使用lambda表达式，实现Consumer3接口，消费数据：{} ------",s);
};

consumer6.accept("kh96正在学习lambda表达式，实现有多条语句，不可以省略大括号");</code></pre> 
 <h5>1.2.3 带多个参数，有返回值</h5> 
 <h6>1.2.3.1 未使用 lambda 表达式，用法：带多个参数，有返回值</h6> 
 <pre class="has"><code class="language-go">// 借助Comparator接口，讲解多个参数
Comparator&lt;Integer&gt; comparator1 = new Comparator&lt;Integer&gt;() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o1.compareTo(o2);
    }
};

// 未使用lambda表达式，用法：带多个参数，有返回值
log.info("------ 不使用lambda表达式，实现Comparator接口，比较12,23的大小：{} ------",comparator1.compare(12,23));// 小于 -1,大于 1，等于 0</code></pre> 
 <h6>1.2.3.2 简化写法：省略参数类型，但是不可以省略小括号，一条语句省略大括号，跟返回值无关（不用手动加return）</h6> 
 <pre class="has"><code class="language-go">//省略参数类型，但是不可以省略小括号，一条语句省略大括号，跟返回值无关（不用手动加return）
Comparator&lt;Integer&gt; comparator2 = (o1,o2) -&gt; o1.compareTo(o2);

log.info("------ 使用lambda表达式，实现Comparator接口，比较23,12的大小：{} ------",comparator2.compare(23,12));// 大于 1</code></pre> 
 <h6>1.2.3.3 简化写法：多条语句不可以省略大括号，带返回值（需手动加return）</h6> 
 <pre class="has"><code class="language-go">//多条语句不可以省略大括号，带返回值（需手动加return）
Comparator&lt;Integer&gt; comparator3 = (o1,o2) -&gt; {
    log.info("------ 比较原数值为：{}，{}",o1,o2);
    return o1.compareTo(o2);
};
log.info("------ 使用lambda表达式，实现Comparator接口，比较22,22的大小：{} ------",comparator3.compare(22,22));// 等于 0</code></pre> 
 <h4>1.3 java8中提供的函数式接口</h4> 
 <h5>1.3.1 消费型接口 Consumer (方法有一个参数，没有返回值)</h5> 
 <h6>1.3.1.1 自定义方法 (使用接口的 void accept(T t) )</h6> 
 <pre class="has"><code class="language-go">//自定义方法，带有一个消费型接口参数，可以实现一个方法，处理不同的业务场景
static void useConsumer(Double salary,Consumer&lt;Double&gt; consumerDate){
    consumerDate.accept(salary);
}</code></pre> 
 <h6>1.3.1.2 方法调用</h6> 
 <pre class="has"><code class="language-go">static void testLambdaConsumer(){
    //场景，同一个接口，有多个实现，以前，必须要创建接口的多个实现类，现在使用lambda，把接口的实现交给调用方法传递

    //实现1：Tom发了5000工资，去买手机,模拟接口的第一个实现
    //以前，必须提供接口的实现类对象
    useConsumer(5000.0,salary -&gt; log.info("Tom,工资：{}，5000买手机",salary));

    //实现1：Tom发了10000工资，去买手机,买平板，模拟接口的第二个实现
    //以前，必须提供接口的 两个 实现类对象
    useConsumer(10000.0,slary -&gt; {
        log.info("JiMe工资：{}，5000买手机",slary);
        log.info("JiMe工资：{}，4000买平板",slary);
    });

}</code></pre> 
 <h6>1.3.1.3 测试结果</h6> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/74/a5/56jnGc0I_o.png" alt="c96c026d07aa4ef9b3d58b5c90ce0d90.png"></p> 
 <h5>1.3.2 供给型接口 Supplier(方法没有参数，可以返回任意类型的结果)</h5> 
 <h6>1.3.2.1 自定义方法 （使用接口的 T get() ）</h6> 
 <pre class="has"><code class="language-go">//带一个供给型参数，可以实现同一个方法，处理实现同一个方法，处理不同的业务场景，给的数据不同，返回的结果不同
static String useSupplier(Double salary, Supplier&lt;Double&gt; supplierData){
    //判断是否高薪的逻辑
    if(salary &gt; supplierData.get()){
        return "高薪";
    }
    return "底薪";
}</code></pre> 
 <h6>1.3.2.2 方法调用</h6> 
 <pre class="has"><code class="language-go">static void testLambdaSupplier(){

    //场景：不同的部门，针对高薪的判断条件不同，比如：学术部高于8000算高薪，教职部门高于5000算高薪
    //以前的写法：根据不同的不同，增加if...else 判断，随着部门的增加，你分的判断会越来越复杂

    log.info("--- 学术部：工资：{}，是否高薪：{} ---",9000.0,useSupplier(9000.0,() -&gt; 8000.0));
    log.info("--- 学术部：工资：{}，是否高薪：{} ---",7000.0,useSupplier(7000.0,() -&gt; 8000.0));
    log.info("--- 教职部：工资：{}，是否高薪：{} ---",7000.0,useSupplier(7000.0,() -&gt; 5000.0));
    log.info("--- 教职部：工资：{}，是否高薪：{} ---",4000.0,useSupplier(7000.0,() -&gt; 5000.0));

}</code></pre> 
 <h6>1.3.2.3 测试结果</h6> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/68/f1/rHlwHKYs_o.png" alt="94f62fbff20fa3f80e74234e557ac08a.png"></p> 
 <h5>1.3.3 断言型接口 Predicate（方法有一个参数，有返回值-布尔类型）</h5> 
 <h6>1.3.3.1 自定义方法 (使用接口的 boolean test(T t) )</h6> 
 <pre class="has"><code class="language-go">//将判断条件交给调用方法
static List&lt;String&gt; userPredicate(List&lt;String&gt; nameList, Predicate&lt;String&gt; predicateData){

    //定义要返回的姓名集合
    List&lt;String&gt; returnNameList = new ArrayList();

    //使用断言型接口，根据传过来的实现，返回不同的结果
    nameList.forEach(name -&gt;{
        //调用断言型接口的test方法，进行挑选数据
        if(predicateData.test(name)){
            returnNameList.add(name);
        }
    });

    //返回符合条件的集合数据
    return  returnNameList;

}</code></pre> 
 <h6>1.3.3.2 方法调用</h6> 
 <pre class="has"><code class="language-go">static void testLambdaPredicate(){

    //使用场景
    //已知姓名集合，根据不同的场景，筛选不同的姓名结果
    List&lt;String&gt; nameList = Arrays.asList("Lilei","Hanmeinei","lisi","zhangsan","xiaolong","xiaohu");

    //获取姓名集合中所有包含n的姓名集合,可以定义第一个方法，实现
    //获取集合中包含i 或者a的姓名集合，可以定义第二个方法，实现
    //随着规则的改变，实现的方法越来越多，去简化，所有的方法就是判断规则不同，其他都一样，可以使用断言型接口，优化

    //获取姓名集合中所有包含n的姓名集合
    List&lt;String&gt; nameList_n = userPredicate(nameList,name -&gt; name.contains("n"));
    log.info("姓名集合中所有包含n的姓名集合:{}",nameList_n);

    //获取集合中包含i 或者a的姓名集合
    List&lt;String&gt; nameList_i_a = userPredicate(nameList,name -&gt; name.contains("i") || name.contains("a"));
    log.info("获取集合中包含i 或者a的姓名集合:{}",nameList_i_a);

}</code></pre> 
 <h6>1.3.3.3 测试结果</h6> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/56/2a/Y7sn8Xid_o.png" alt="e2964cf436947b3c560c70411830cbff.png"></p> 
 <h5>1.3.4 函数接口 Function,有任意类型参数，有任意类型返回值</h5> 
 <h6>1.3.4.1 自定义方法（使用接口的R apply(T t) ） 和 方法调用</h6> 
 <pre class="has"><code class="language-go">static void testLambdaFunction(){

    Function&lt;Integer,Double&gt; function = num -&gt; new Random().nextInt(num)*1.0;

    log.info("--- 使用函数型接口，接收整数：{}，返回随机浮点型结果：{} ---",96,function.apply(96));
    
}</code></pre> 
 <h6>1.3.4.2 测试结果</h6> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/9a/10/DEwU13Ym_o.png" alt="8ed878bf0921e5f986cbcc38a876724d.png"></p> 
 <h5>1.3.5 自定义函数式接口</h5> 
 <pre class="has"><code class="language-go">// 自定义的函数式接口：带一个任意类型参数，返回String类型值
// 定义：凡是一个接口中，只有一个抽象方法，那这个接口就是函数式接口，可以别注解 //@FunctionalInterface修饰
@FunctionalInterface
public interface MyFunctionInterface&lt;T&gt; {

    //函数式接口中的唯一抽象方法
    String helloKh96(T t);

    //可以增加默认方法，允许的
    default void hiKH96(){
     //默认方法
    }

}</code></pre> 
 <h3>2、StreamAPI</h3> 
 <h4>2.1 创建流 有限流 和 无限流</h4> 
 <h5>2.1.1 有限流</h5> 
 <pre class="has"><code class="language-go">//有限流， 输出1，3，5，7，9 的平方
log.info("\n----- 输出1，3，5，7，9 的平方 -----");
Stream.of(1,3,5,7,9).forEach(num -&gt; System.out.print(num * num + ";"));</code></pre> 
 <p style="text-align:left;">测试结果：</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/d8/09/1C3PXzjq_o.png" alt="f5c6d6db19cb839ce28d20d926455a75.png"></p> 
 <h5>2.1.2 无线流</h5> 
 <h6>2.1.2.1 iterate</h6> 
 <pre class="has"><code class="language-go">//无限流：输出前18个奇数
log.info("\n ----- 输出前18个奇数 ------");
Stream.iterate(1,n -&gt; n+2).limit(10).forEach(num -&gt; System.out.print(num + ";"));</code></pre> 
 <h6>2.1.2.2 generate</h6> 
 <pre class="has"><code class="language-go">//无限流：输出10个随机数
log.info("\n ----- 输出前18个随机数 ------");
Stream.generate(() -&gt; new Random().nextInt(100)).limit(10).forEach(num -&gt; System.out.print(num+";"));</code></pre> 
 <p style="text-align:left;">测试结果：</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/00/ea/TTwy2DCK_o.png" alt="8bc12d5af14f0d95ca2bc45b2e422aab.png"></p> 
 <h4>2.2 创建流 基于数组 和 集合</h4> 
 <h5>2.2.1 基于数组</h5> 
 <pre class="has"><code class="language-go">//基于数组
int[] nums = {66,99,44,11,22,55,77,88};

//通过Arrays工具类提供的stream 方法
int min = Arrays.stream(nums).min().getAsInt();
int max = Arrays.stream(nums).max().getAsInt();
log.info("\n ------ 数组最小值为 ：{} --------",min);
log.info("\n ------ 数组最大值为 ：{} --------",max);</code></pre> 
 <p style="text-align:left;">测试结果：</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/8d/56/Y1vPCsOh_o.png" alt="752f9c12ece24d355af18a2254fb8892.png"></p> 
 <h5>2.2.2 基于集合</h5> 
 <pre class="has"><code class="language-go">//基于集合
List&lt;String&gt; nameList = Arrays.asList("Lilei","Hanmeinei","lisi","zhangsan","xiaolong","xiaohu");

//通过集合对象的stream方法
nameList.stream().map(name -&gt; name.toLowerCase()).forEach(System.out::println);</code></pre> 
 <p style="text-align:left;">测试结果：</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/27/0a/R3abt1Ej_o.png" alt="fc3a54c19eb64737401f812f841864a0.png"></p> 
 <h4>2.3 流的中间操作</h4> 
 <h5>2.3.1 筛选和切片</h5> 
 <h6>2.3.1.0 数据准备</h6> 
 <h6>2.3.1.0.1 bean</h6> 
 <pre class="has"><code class="language-go">//小说实体
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Story {

    // 编号
    private Integer id;

    // 书名
    private String name;

    // 作者
    private String author;

    // 价格
    private Double price;

    // 章节
    private Integer sections;

    // 分类
    private String category;

}</code></pre> 
 <h6>2.3.1.0.2 StoryUtil</h6> 
 <pre class="has"><code class="language-go">//小说工具类
public class StoryUtil {
    public static List&lt;Story&gt; stories = new ArrayList&lt;&gt;();
    static {
        stories.add(Story.builder().id(101).name("斗破苍穹").author("zhangsan").price(109.9).sections(1202).category("玄幻").build());
        stories.add(Story.builder().id(201).name("斗罗大陆").author("lisi").price(88.9).sections(999).category("科幻").build());
        stories.add(Story.builder().id(301).name("凡人修仙传").author("wangwu").price(77.9).sections(1303).category("武侠").build());
        stories.add(Story.builder().id(401).name("圣墟").author("zhuliu").price(121.9).sections(1404).category("玄幻").build());
        stories.add(Story.builder().id(501).name("吞噬星空").author("sunqi").price(135.9).sections(996).category("历史").build());
        stories.add(Story.builder().id(601).name("完美世界").author("zhaoba").price(66.9).sections(999).category("玄幻").build());
        stories.add(Story.builder().id(701).name("大王饶命").author("qianjiu").price(135.9).sections(997).category("玄幻").build());
        stories.add(Story.builder().id(801).name("大奉打更人").author("zhoushi").price(133.9).sections(1606).category("军事").build());
    }
}</code></pre> 
 <h6>2.3.1.1 筛选：filter</h6> 
 <pre class="has"><code class="language-go">//筛选： filter,相当于数据库中的where条件
log.info("-------------- 筛选： filter ----------------");
//查看小说集合中，价格大于100块的所有小说
StoryUtil.stories.stream().filter(story -&gt; story.getPrice() &gt; 100).forEach(System.out::println);

//练习：查看小说集合中，所有章节数大于1000且作者中包含n的小说
log.info("\n------- 查看小说集合中，所有章节数大于1000且作者中包含n的小说 ---------");
StoryUtil.stories.stream().filter(story -&gt; story.getSections() &gt; 1000 &amp;&amp; story.getAuthor().contains("n") ).forEach(System.out::println);</code></pre> 
 <p style="text-align:left;">测试结果1：</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/d5/27/6fER4m87_o.png" alt="4e9ede487ea292468aafde04bbafb8dc.png"></p> 
 <p style="text-align:left;">测试结果2：</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/ee/63/ZBtzPvjd_o.png" alt="922a5e620154661b692f9b130e9a02c0.png"></p> 
 <h6>2.3.1.2 截断：limit</h6> 
 <pre class="has"><code class="language-go">//截断： limit 相当于数据库的limit条数
log.info("\n---------- 截断： limit ---------");
//查询小说集合，所有价格大于100的前三本
StoryUtil.stories.stream().filter(story -&gt; story.getPrice() &gt;100).limit(3).forEach(System.out::println);</code></pre> 
 <p style="text-align:left;">测试结果：</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/d3/41/ftiYavcI_o.png" alt="bdca3d9cfc41bedc2d2a6af6c8ae4452.png"></p> 
 <h6>2.3.1.3 跳过：skip</h6> 
 <pre class="has"><code class="language-go">//跳过：skip,相当于数据库跳过数据条数
log.info("\n------------- 跳过：skip-----------------");
//查询小说集合，所有价格大于100的前三本,后的所有小说
log.info("\n------------- 查询小说集合，所有价格大于100的前三本,后的所有小说-----------------");
StoryUtil.stories.stream().filter(story -&gt; story.getPrice() &gt;100).skip(3).forEach(System.out::println);</code></pre> 
 <p style="text-align:left;">测试结果：</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/57/7d/sRmvAbKo_o.png" alt="285f32672bdacd178c40fe139713b714.png"></p> 
 <h6>2.3.1.4 去重：distinct</h6> 
 <pre class="has"><code class="language-go">//去重：distinct,相当于数据库中的去重,了解
log.info("\n------------- 去重：distinct,相当于数据库中的去重 -----------------");
Stream.of(22,33,55,11,66,33,55,11,55).distinct().forEach(System.out::println);</code></pre> 
 <p style="text-align:left;">测试结果：</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/be/55/Ei6lDVIk_o.png" alt="4b83ad3415ed72e5a741dbd287b4fa5a.png"></p> 
 <h5>2.3.2 映射和排序</h5> 
 <h6>2.3.2.1 映射：map</h6> 
 <pre class="has"><code class="language-go">//已知姓名集合
List&lt;String&gt; nameList = Arrays.asList("Lilei","Hanmeinei","lisi","zhangsan","xiaolong","xiaohu");

//映射：map,可以将流中发的元素进行转换或这提取，会自动指定的规则作用到所有的元素上，并返回一个新的流
log.info("-------------- 映射： map ----------------");

//将姓名集合中，所有包含i的姓名，转换为大写并输出
//nameList.stream().filter(name -&gt; name.contains("i")).map(name -&gt; name.toUpperCase()).forEach(System.out::println);
nameList.stream().filter(name -&gt; name.contains("i")).map(String::toUpperCase).forEach(System.out::println);</code></pre> 
 <p style="text-align:left;">测试结果：</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/8f/e6/3U0IhWZ9_o.png" alt="906a342041868e7df91cf88835de5d34.png"></p> 
 <h6>2.3.2.2 映射：map 输出单个属性</h6> 
 <pre class="has"><code class="language-go">//将小说集合中,章节小于1000的作者转换为大写，输出作者
log.info("\n-------------- 将小说集合中,章节小于1000的作者转换为大写，输出作者 --------------");
//StoryUtil.stories.stream().filter(story -&gt; story.getSections() &lt; 1000).map(story -&gt; story.getAuthor()).map(string -&gt; string.toUpperCase()).forEach(System.out::println);
StoryUtil.stories.stream().filter(story -&gt; story.getSections() &lt; 1000).map(Story::getAuthor).map(string -&gt; string.toUpperCase()).forEach(System.out::println);</code></pre> 
 <p style="text-align:left;">测试结果：</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/5d/d8/HcfLkZOd_o.png" alt="8df617dc7e360038b859c89046338244.png"></p> 
 <h6>2.3.2.3 映射： mapToInt</h6> 
 <pre class="has"><code class="language-go">//获取所有小说的书名长度
log.info("\n-------------- 获取所有小说的书名长度 --------------");
// StoryUtil.stories.stream().map(story -&gt; story.getName().length()).forEach(System.out::println);
StoryUtil.stories.stream().mapToInt(story -&gt; story.getName().length()).forEach(System.out::println);</code></pre> 
 <p style="text-align:left;">测试结果：<img src="https://images2.imgbox.com/38/af/cyqX5YSQ_o.png" alt="02ab3b96a1620de96944107d2349be4e.png"></p> 
 <h6>2.3.2.4 消费：peek</h6> 
 <pre class="has"><code class="language-go">//消费：peek,  将小说价格增加50元后，价格大于130的
log.info("\n-------------- 消费：peek,  将小说价格增加50元后，价格大于130的 --------------");
StoryUtil.stories.stream().peek(story -&gt; story.setPrice(story.getPrice()+50)).filter(story -&gt; story.getPrice()&gt;130).forEach(System.out::println);</code></pre> 
 <p style="text-align:left;">测试结果：</p> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/51/ba/UGMfh106_o.png" alt="233410132ee02a0357668ea56a78e88b.png"></p> 
 <h6>2.3.2.5 排序：sorted</h6> 
 <pre class="has"><code class="language-go">//排序：sorted ,给姓名排序
log.info("\n -------------- 排序：sorted ,给姓名排序 --------------");
nameList.stream().sorted().forEach(System.out::println);</code></pre> 
 <p style="text-align:left;"><img src="https://images2.imgbox.com/4c/db/uUFJz2PC_o.png" alt="ddc08f9be679c730db261dc2a71cfefa.png"></p> 
 <h6>2.3.2.6 自定义排序规则</h6> 
 <pre class="has"><code class="language-go">//自定义排序，先按照价格排序，价格相同，按照章节排序
log.info("\n--------- 自定义排序，先按照价格排序，价格相同，按照章节排序 ---------");
StoryUtil.stories.stream().sorted((s1,s2)-&gt;{
    int sortPrice = Double.compare(s1.getPrice(),s2.getPrice());
    if(sortPrice == 0){
        return Double.compare(s1.getSections(),s2.getSections());
    }
    return sortPrice;

}).forEach(System.out::println);</code></pre> 
 <p style="text-align:left;">测试结果：<img src="https://images2.imgbox.com/75/06/LzWEHR5F_o.png" alt="3c5045f164b3fee411639e4f3605b74d.png"></p> 
 <p><img title="金属质感分割线" src="https://images2.imgbox.com/26/ad/L9YPduka_o.jpg" alt="a67cc6d01fb003620af0e266779c66bd.jpeg"><br></p> 
 <p style="text-align:center;"><strong>往期推荐</strong></p> 
 <ol><li><p><a href="" rel="nofollow">肝九千字长文 | MyBatis-Plus 码之重器 lambda 表达式使用指南，开发效率瞬间提升80%</a><br></p></li><li><p><a href="" rel="nofollow">用 MHA 做 MySQL 读写分离，频繁爆发线上生产事故后，泪奔分享 Druid 连接池参数优化实战</a></p></li><li><p><a href="" rel="nofollow">微服务架构下，解决数据库跨库查询的一些思路</a></p></li><li><p><a href="" rel="nofollow">一文读懂阿里大中台、小前台战略</a></p></li></ol> 
 <p><strong><em>作者简介</em></strong><em>：</em><em>猿芯，<strong>一枚简单的北漂程序员。</strong></em><em>喜欢</em><em>用简单的文字记录工作与生活中的点点滴滴，愿与你一起分享程序员灵魂深处真正的内心独白</em><em>。我的微信号：</em><strong><em>WooolaDunzung</em></strong><em>，公众号【<strong>猿芯</strong>】</em><em>输入 <strong>1024 </strong>，有份面试惊喜送给你哦</em><em>。</em><br></p> 
 <p style="text-align:center;"><strong>&lt; END &gt;</strong></p> 
 <p>【猿芯】</p> 
 <p><img src="https://images2.imgbox.com/9b/22/559ZmWGs_o.jpg" alt="5d5dda6159a6ea5b6fe8a7310cb96fd9.jpeg"></p> 
 <p> 微信扫描二维码，关注我的公众号。</p> 
 <p>分享不易，莫要干想，如果觉得有点用的话，动动你的发财之手，一键三连击：<em>分享、点赞、在看</em>，你们的鼓励是我分享优质文章的最强动力 ^_^</p> 
 <p style="text-align:right;"><strong>分享、点赞、在看，3连3连！</strong><strong><img src="https://images2.imgbox.com/2e/e2/eNt1b47C_o.gif" alt="0ea7dddbdd429ef2eac55f1c93b2e274.gif"></strong></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f31b21ff0e8080172dbc540537ccc3f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Rockchip RK3588 User Guide DP</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/19cbb16dace9b549878cce1bfe589741/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vim学习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>