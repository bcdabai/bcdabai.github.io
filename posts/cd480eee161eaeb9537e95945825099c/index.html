<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>efuse相关知识 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="efuse相关知识" />
<meta property="og:description" content="efuse 文章目录 efuse背景知识Secure BootCPU内部安全机制bootROMiRAMefuseSecurity EngineFirst Stage Bootloader（FSBL）根信任建立 NVMPROM &amp; OTPPROMOTP memory 结构memory repairhardrepairsoftrepair macro 概述efuse是什么？efuse的作用及应用场景Antifuseefuse是如何使用的 efuse的工作模式相关信号eFuse操作模式编程模式（Program Mode）读取模式（Read Mode）非活动模式（Inactivate Mode） Efuse设计思路 背景知识 Secure Boot 【NVMEM子系统】一、Efuse介绍及安全启动浅析 安全启动Secure Boot，其主要目的是：以限制消费者能力，防止消费者从软硬件层面，对产品的部分关键系统进行读写，调试等高级权限，达到对产品的商业保密，知识产权的保护。
安全启动的安全模型是建立在消费者是攻击者的假设之上，一般常见的操作有：
刷机安装自定义的操作系统绕过厂家封闭的支付平台绕过系统保护，复制厂家保护的数字产品。 除此之外呢，有的比较专业的消费者，还可以：
使用数字示波器监听 CPU 和 RAM 、eMMC 之间的数据传输来读取非常底层的数据传输而且像 eMMC 这种芯片通常都是业界标准化的，攻击者甚至可以把芯片拆下来，然后用市面上现成的通用 eMMC 编程工具来读写上面的内容。 安全启动等级也有一个上限：这个上限通常是认为攻击者不至于能够剥离芯片的封装，然后用电子显微镜等纳米级别精度的显像设备来逆向芯片的内部结构。
简单来说：能成功攻破芯片安全机制的一次性投资成本至少需要在十万美元以上才可以认为是安全的。
CPU内部安全机制 【NVMEM子系统】一、Efuse介绍及安全启动浅析 bootROM BootROM是集成在CPU芯片的一个ROM空间，其主要用于存放一小段可执行程序，出厂的时候被烧录进去写死，不可修改。
CPU在通电之后，执行的第一条程序就在BootROM，用于初始化Secure Boot安全机制，加载Secure Boot Key密钥，从 存储介质中加载并验证 First Stage Bootloader（FSBL）；最后跳转进 FSBL 中。
iRAM 为了避免使用外部的RAM，支持Secure Boot的CPU都会内置一块很小的RAM，通常只有 16KB 到 64KB ，我们称之为 iRAM。
这块 iRAM 上的空间非常宝贵，bootROM 一般会用 4KB 的 iRAM 作为它的堆栈。FSBL 也会被直接加载到 iRAM 上执行。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cd480eee161eaeb9537e95945825099c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-12T16:44:01+08:00" />
<meta property="article:modified_time" content="2023-09-12T16:44:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">efuse相关知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="efuse_1"></a>efuse</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#efuse_1" rel="nofollow">efuse</a></li><li><ul><li><a href="#_4" rel="nofollow">背景知识</a></li><li><ul><li><a href="#Secure_Boot_6" rel="nofollow">Secure Boot</a></li><li><a href="#CPU_29" rel="nofollow">CPU内部安全机制</a></li><li><ul><li><a href="#bootROM_35" rel="nofollow">bootROM</a></li><li><a href="#iRAM_41" rel="nofollow">iRAM</a></li><li><a href="#efuse_47" rel="nofollow">efuse</a></li><li><a href="#Security_Engine_54" rel="nofollow">Security Engine</a></li><li><a href="#First_Stage_BootloaderFSBL_58" rel="nofollow">First Stage Bootloader（FSBL）</a></li><li><a href="#_62" rel="nofollow">根信任建立</a></li></ul> 
    </li><li><a href="#NVM_70" rel="nofollow">NVM</a></li><li><a href="#PROM__OTP_76" rel="nofollow">PROM &amp; OTP</a></li><li><ul><li><a href="#PROM_78" rel="nofollow">PROM</a></li><li><a href="#OTP_88" rel="nofollow">OTP</a></li></ul> 
    </li><li><a href="#memory__111" rel="nofollow">memory 结构</a></li><li><a href="#memory_repair_145" rel="nofollow">memory repair</a></li><li><ul><li><a href="#hardrepair_167" rel="nofollow">hardrepair</a></li><li><a href="#softrepair_173" rel="nofollow">softrepair</a></li></ul> 
    </li><li><a href="#macro_199" rel="nofollow">macro</a></li></ul> 
   </li><li><a href="#_209" rel="nofollow">概述</a></li><li><ul><li><a href="#efuse_211" rel="nofollow">efuse是什么？</a></li><li><a href="#efuse_259" rel="nofollow">efuse的作用及应用场景</a></li><li><a href="#Antifuse_301" rel="nofollow">Antifuse</a></li><li><a href="#efuse_305" rel="nofollow">efuse是如何使用的</a></li></ul> 
   </li><li><a href="#efuse_325" rel="nofollow">efuse的工作模式</a></li><li><ul><li><a href="#_329" rel="nofollow">相关信号</a></li><li><a href="#eFuse_333" rel="nofollow">eFuse操作模式</a></li><li><a href="#Program_Mode_363" rel="nofollow">编程模式（Program Mode）</a></li><li><a href="#Read_Mode_369" rel="nofollow">读取模式（Read Mode）</a></li><li><a href="#Inactivate_Mode_375" rel="nofollow">非活动模式（Inactivate Mode）</a></li></ul> 
   </li><li><a href="#Efuse_379" rel="nofollow">Efuse设计思路</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_4"></a>背景知识</h3> 
<h4><a id="Secure_Boot_6"></a>Secure Boot</h4> 
<blockquote> 
 <p><a href="https://zhuanlan.zhihu.com/p/606737996" rel="nofollow">【NVMEM子系统】一、Efuse介绍及安全启动浅析 </a></p> 
</blockquote> 
<p>安全启动<code>Secure Boot</code>，其主要目的是：<strong>以限制消费者能力，防止消费者从软硬件层面，对产品的部分关键系统进行读写，调试等高级权限，达到对产品的商业保密，知识产权的保护。</strong></p> 
<p><strong>安全启动的安全模型是建立在消费者是攻击者的假设之上</strong>，一般常见的操作有：</p> 
<ul><li>刷机安装自定义的操作系统</li><li>绕过厂家封闭的支付平台</li><li>绕过系统保护，复制厂家保护的数字产品。</li></ul> 
<p><strong>除此之外呢，有的比较专业的消费者，还可以</strong>：</p> 
<ul><li>使用数字示波器监听 <code>CPU</code> 和 <code>RAM</code> 、<code>eMMC</code> 之间的数据传输来读取非常底层的数据传输</li><li>而且像 <code>eMMC</code> 这种芯片通常都是业界标准化的，攻击者甚至可以把芯片拆下来，然后用市面上现成的通用 <code>eMMC</code> 编程工具来读写上面的内容。</li></ul> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/1a/19/fHyDWH2W_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>安全启动等级也有一个上限：这个上限通常是认为攻击者不至于能够剥离芯片的封装，然后用电子显微镜等纳米级别精度的显像设备来逆向芯片的内部结构。</p> 
<p>简单来说：<strong>能成功攻破芯片安全机制的一次性投资成本至少需要在十万美元以上才可以认为是安全的。</strong></p> 
<h4><a id="CPU_29"></a>CPU内部安全机制</h4> 
<blockquote> 
 <p><a href="https://zhuanlan.zhihu.com/p/606737996" rel="nofollow">【NVMEM子系统】一、Efuse介绍及安全启动浅析 </a></p> 
</blockquote> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/79/92/EFF7cGMS_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h5><a id="bootROM_35"></a>bootROM</h5> 
<p><code>BootROM</code>是集成在<code>CPU</code>芯片的一个<code>ROM</code>空间，其主要用于存放一小段可执行程序，出厂的时候被烧录进去写死，不可修改。</p> 
<p><code>CPU</code>在通电之后，执行的第一条程序就在<code>BootROM</code>，用于初始化<code>Secure Boot</code>安全机制，加载<code>Secure Boot Key</code>密钥，从 存储介质中加载并验证 <strong>First Stage Bootloader（FSBL）</strong>；最后跳转进 FSBL 中。</p> 
<h5><a id="iRAM_41"></a>iRAM</h5> 
<p>为了避免使用外部的<code>RAM</code>，支持<code>Secure Boot</code>的<code>CPU</code>都会内置一块很小的<code>RAM</code>，通常只有 16KB 到 64KB ，我们称之为 <strong>iRAM</strong>。</p> 
<p>这块 <code>iRAM</code> 上的空间非常宝贵，<code>bootROM</code> 一般会用 <code>4KB</code> 的 <code>iRAM</code> 作为它的堆栈。<code>FSBL</code> 也会被直接加载到 <code>iRAM</code> 上执行。</p> 
<h5><a id="efuse_47"></a>efuse</h5> 
<p>如上面所述，在<code>Secure Boot</code>中存放的是<strong>根密钥</strong>，用于安全启动的验证。</p> 
<ul><li>一般有两种根密钥：一个是加密解密用的<strong>对称密钥 Secure Boot Key</strong>，一般是 <strong>AES 128</strong> 的，每台设备都是随机生成不一样的；</li><li>另一个是一个 <strong>Secure Boot Signing Key 公钥</strong>，一般用的 <strong>RSA</strong> 或 <strong>ECC</strong>，这个是每个 <code>OEM</code> 自己生成的，每台设备用的都一样，有些芯片会存公钥的 <code>Hash</code> 来减少 <code>eFUSE</code> 的空间使用。</li></ul> 
<h5><a id="Security_Engine_54"></a>Security Engine</h5> 
<p>有些 CPU 中还会有一个专门负责加密解密的模块，我们称为 <strong>Security Engine</strong>。这个模块通常会有若干个<strong>密钥槽（Keyslots）</strong>，可以通过寄存器将密钥加载到任意一个 <code>Keyslot</code> 当中，通过寄存器操作 <code>DMA</code> 读写，可以使用 <code>Keyslot</code> 中的密钥对数据进行加密、解密、签名、<code>HMAC</code>、随机数生成等操作.</p> 
<h5><a id="First_Stage_BootloaderFSBL_58"></a>First Stage Bootloader（FSBL）</h5> 
<p><code>FSBL</code> 的作用是初始化 <code>PCB</code> 板上的其他硬件设备，给外部 <code>RAM</code> 映射内存空间，从 外部存储介质中加载验证并执行接下来的启动程序。</p> 
<h5><a id="_62"></a>根信任建立</h5> 
<ol><li><code>CPU</code>上电后执行<code>Boot ROM</code>的程序，其这一小段程序用于初始化<code>RAM</code>，并加载<code>Efuse</code>上的内容，判断其所处的运行模式是不是生产模式。</li><li>如果在生产模式，开启<code>Secure Boot</code>功能，把<code>Efuse</code>上保存的<code>Secure Boot Key</code>加载到<code>Security Engine</code>加密模块中处理。</li><li>从外部存储介质中加载<code>FSBL</code>，<code>FSBL</code>里面会有一个数字签名和公钥证书，<strong>bootROM</strong> 会验证这个签名的合法性，以及根证书的 <code>Hash</code> 是否和 <code>eFUSE</code> 中的 <code>Signing Key</code> 的 <code>Hash</code> 相同。</li><li>如果验证通过，说明 <code>FSBL</code> 的的确确是 <code>OEM</code> 正式发布的，没有受到过篡改。</li><li>然后<code>bootROM</code> 就会跳转到 <code>FSBL</code> 执行接下来的启动程序。</li></ol> 
<h4><a id="NVM_70"></a>NVM</h4> 
<p>非易失性存储器(NVM,Non-Volatile Memory)</p> 
<blockquote> 
 <p><a href="https://www.cnblogs.com/lanlancky/p/17051640.html" rel="nofollow">eFuse技术 </a></p> 
</blockquote> 
<h4><a id="PROM__OTP_76"></a>PROM &amp; OTP</h4> 
<h5><a id="PROM_78"></a>PROM</h5> 
<blockquote> 
 <p><a href="https://aijishu.com/a/1060000000179134" rel="nofollow">OTP 们：PROM, eFuse, Antifuse </a></p> 
</blockquote> 
<p>PROM, Programmable read-only memory, 是ROM 的一种，相较于传统ROM, 其数据不是在制造过程中写入的，而是在制造完成之后通过『 PROM programmer 』写入的。PROM 中的每个bit 由熔丝 ( fuse ) 或反熔丝 ( antifuse ) 锁定，根据采用的技术不同，可以在晶圆、测试或系统级进行编程。</p> 
<p><strong>典型的PROM 出厂后所有比特的值都是"1", 所谓的编程就是熔断对应比特将其值改写成"0", 这样的改写只能做一次。</strong></p> 
<p>熔断过程：通过在薄氧化物晶体管的栅极跟衬底之间施加一个高压脉冲，来熔断栅极跟衬底间的栅氧，如2nm 厚的栅氧需要大概6V 电压。晶体管栅极上的正向电压在栅极和衬底间形成一个反向通道，使隧穿电流通过栅氧，并在栅氧中产生更多电子陷阱，从而增加通过栅氧的电流，并最终使栅氧熔化并形成从栅极到衬底的导电沟道。形成导电通道所需的电流约为100 µA / 100 nm2，击穿发生的时间约为100 µs 或更短 。</p> 
<h5><a id="OTP_88"></a>OTP</h5> 
<blockquote> 
 <p><a href="https://aijishu.com/a/1060000000179134" rel="nofollow">OTP 们：PROM, eFuse, Antifuse </a></p> 
</blockquote> 
<p>OTP, One time programmable, 是一种特殊类型的非易失性存储器 ( non-volatile memory )，只允许编程一次，<strong>一旦被编程，数据永久有效。</strong></p> 
<blockquote> 
 <p><a href="https://zhuanlan.zhihu.com/p/606737996" rel="nofollow">【NVMEM子系统】一、Efuse介绍及安全启动浅析 </a></p> 
 <p><code>OTP(One Time Programmable)</code>是反熔丝的一种器件，就是说，当<code>OTP</code>存储单元未击穿时，它的逻辑状态为<code>0</code>；当击穿时，它的逻辑状态为<code>1</code>，也属于<strong>一次性可编程存储器</strong>。</p> 
 <p><strong>它的物理状态和逻辑状态正好和<code>eFuse</code>相反！</strong></p> 
 <blockquote> 
  <p><img src="https://images2.imgbox.com/45/6e/2X4s0DxG_o.png" alt="在这里插入图片描述"></p> 
 </blockquote> 
</blockquote> 
<p><mark>OTP和efuse的区别：</mark></p> 
<ul><li>从成本上讲，<code>eFuse</code>器件基本上是各个<code>Foundry</code>厂自己提供，因此通常意味着免费或者很少的费用，而<code>OTP</code>器件则通常是第三方<code>IP</code>厂家提供，这就要收费。</li><li>从器件面积上讲，eFuse的cell的面积更大，所以仅仅有小容量的器件可以考虑。当然如果需要大容量的，也可以多个eFuse Macro拼接，但是这意味着芯片面积的增加，成本也会增加；OTP的cell面积很小，所有相对来讲，可以提供更大容量的Macro可供使用。</li><li><code>OTP</code> 比 <code>eFuse</code> 安全性更好，<code>eFuse</code>的编程位可以通过电子显微镜看到，因此其存储的内容可以被轻易破解，但<code>OTP</code>在显微镜下无法区分编程位和未编程位，因此无法读取数据。</li><li><code>eFuse</code>默认导通，存储的是"1"，而<code>OTP</code>默认是断开，存储的是"0"，因此<code>OTP</code>的功耗也较<code>eFuse</code>小，面积也较<code>eFuse</code>小。</li></ul> 
<p>相较于MTP (multi-time programmable ) 如EEPROM, OTP 的面积更小而且不需要额外的制造步骤，因此广泛应用于low-cost 芯片中，<strong>OTP 常用于存储可靠且可重复读取的数据，如：启动程序、加密密钥、模拟器件配置参数等</strong>。</p> 
<h4><a id="memory__111"></a>memory 结构</h4> 
<blockquote> 
 <p><a href="https://blog.csdn.net/chengyq116/article/details/122571572">Memory Hierarchy - 存储器层次结构_memory结构</a></p> 
 <p><img src="https://images2.imgbox.com/a1/e2/iViqaB5q_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>[memory学习_memory 结构](https://blog.csdn.net/te55gybo/article/details/118499919#:~:text=存储器内部结构一般由存储阵列，地址译码器和输出控制电路组成。 我们把存储阵列以外的电路都称为外围电路（Periphery）。,存储阵列是memory的核心区域，它有许多存储单元组成，每个存储单元存放一位二值数据。 每次读出一组数据，称为一组字。)</p> 
 <p>存储器内部结构一般由存储阵列，地址译码器和输出控制电路组成。我们把存储阵列以外的电路都称为外围电路（Periphery）。</p> 
 <p>存储阵列是memory的核心区域，它有许多存储单元组成，每个存储单元存放一位二值数据。每次读出一组数据，称为一组字。一个字中所含的位数称为字长（Bit）。为了区别各个不同的字，给每个字赋予一个编号，称为地址，由译码器将地址代码转译。地址单元个数就是字数（Depth），用N表示，数值为2n次方，n为地址码的位数。</p> 
 <p>实际运用中，我们经常以字数（Depth）和字长（Bit）的乘积来表示存储器的容量。如下图中的ROM容量为28 X 1，有256个字，字长为1位，总共256个存储单元。容量越大，意味着能存储的数据越多。</p> 
 <p><img src="https://images2.imgbox.com/41/3d/LVoqqbXM_o.png" alt="在这里插入图片描述"></p> 
 <p>通常，大家还会看到类型HD，HC，HP等缩写，这些都是表征不同类型Bitcell和外围电路（Periphery）组成的。</p> 
 <p>HD：High Density Bitcell ，面积较小</p> 
 <p>HC：High Current Bitcell 高工作电流，access time较小</p> 
 <p>HP：High Performance Periphery ，速度快</p> 
 <p>LP：Low-Power Periphery ，功耗较小</p> 
 <p>ULP：Ultra-Low Power Periphery，超低功耗</p> 
 <p>ULL：Ultra-Low Leakage Periphery，超低漏电流</p> 
</blockquote> 
<blockquote> 
 <p><a href="http://www.wowotech.net/basic_tech/321.html" rel="nofollow">DRAM 原理 3 ：DRAM Device (wowotech.net)</a></p> 
 <p><a href="https://blog.csdn.net/chenming092100/article/details/78562730">DRAM基本单元最为通俗易懂的图文解说_dram存储单元结构_小豆子范德萨的博客-CSDN博客</a></p> 
</blockquote> 
<h4><a id="memory_repair_145"></a>memory repair</h4> 
<p>通常，设计Soc时，如果存储器的容量比较大，那么存储器在生产时出现坏点的概率就会增加，也就是说某个地址可能用不了。为了防止因为一个坏点就导致整个IC不能用，一般会选择在存储器内设置row redundancy或者column redundancy。</p> 
<blockquote> 
 <p><a href="https://bbs.eetop.cn/thread-302752-3-1.html" rel="nofollow">memory repair - eetop-可以看下大佬讨论</a></p> 
</blockquote> 
<blockquote> 
 <p><a href="https://blog.csdn.net/icxiaoge/article/details/79828979">什么是soft repair 和 hard repair？_memory hard repair</a></p> 
 <p>什么是repair？</p> 
 <p>Repair是一个过程，是存储器修复缺陷（信号线短路、断路等情况）的过程。</p> 
 <p>存储器中一般存在<a href="https://so.csdn.net/so/search?q=%E5%86%97%E4%BD%99&amp;spm=1001.2101.3001.7020">冗余</a>的信号线和单元，通过检查发现有问题的单元，从而用冗余的模块替换有缺陷的模块，保证存储的正常使用。</p> 
</blockquote> 
<p>Lane repair 一般存在于芯片上电的初始化流程中。Lane repair过程用来修复两个模块之间的连线，模块在设计的时候是有冗余的连线的。用冗余的连线替换有问题的连线就是Lane repair 过程。</p> 
<p>Lane repair 又分为hard lane repair 和 soft lane repair。Hard lane repair 通过读取出厂时写入到efuse中的固定数据来完成通道修复。soft lane repair 通过自身的硬件检测哪条信号有问题来完成通道修复。</p> 
<p>在上电初始化过程中，hard lanerepair 在前，soft lane repair。</p> 
<p>芯片在使用的过程中，会不断老化，某些信号通道会出现不稳定，速度降低等问题，hard lane repair只能解决出厂时存在的缺陷，而不能修复使用过程中出现的通道问题。每次芯片上电时，都会启动soft lane repair，修复此刻发现的问题，采用冗余的信号线替换已经不满足需求的信号线。</p> 
<h5><a id="hardrepair_167"></a>hardrepair</h5> 
<p>什么是hardrepair？</p> 
<p>Hard repair 同样处于芯片初始化流程中，在存储模块出厂前厂家会进行功能测试，发现有问题的模块和信号线后会生成相应的数据data0，并且将data0烧入到存储模块中，芯片初始化流程中，存储模块会将data0读取到相应的寄存器中repair_register，从而实现用冗余模块替换问题模块，保证存储功能正常。出厂后data0的数据就是固定不变的，这就是hard repair过程。</p> 
<h5><a id="softrepair_173"></a>softrepair</h5> 
<p>什么是softrepair？</p> 
<p>但是芯片在使用过程中，随着时间推移，存储内部在不断老化，有些存储单元出问题了，有些输入输出线出问题了，此时我们也希望存储能够自动修复，此时就需要soft repair了。soft repair同样处于芯片初始化流程中，但是在soft repair完成之后，存储模块中会存在相应的硬件电路判断模块是否有新缺陷，如果有缺陷，则产生相应的数据data1，data1传送给修复寄存器（repair_register不止一个），从而实现用冗余模块替换问题模块，保证存储功能正常。</p> 
<hr> 
<p><mark>hard repair与soft repair的区别？</mark></p> 
<p>芯片上电后，都会依次经历hard repair和soft repair。</p> 
<p>Hard repair 中的数据时出厂就固定的，而soft repair的数据是每次上电后初始化流程中，存储模块自己检测产生的。</p> 
<p>Hardrepair 只能修复出厂时的硬件缺陷，而soft repair 能够修复芯片使用过程中产生缺陷。</p> 
<p><mark>例子：</mark></p> 
<p>如图所示，存储DRAM和PHY模块间有1024根有效数据线和10冗余信号线。出厂时，检测发现有2根有效信号线有问题（短路，断路，传输速率不达标），此时产生修复数据data0,烧入到DRAM中，芯片上电后，hard lane repair 开始，将data0读取到修复配置寄存器中，使用冗余信号线中的两条替换有问题的两根信号线，这就是hard lane repair。</p> 
<p>Hard lane repair 完成后，会进入soft lane repair，此时存储芯片DRAM依靠内部的硬件检测电路检测到有5根信号线有问题，此时产生修复数据data1，将data1写到修复配置寄存器，使用冗余信号线中的5条替换有问题的5根信号线。</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/c4/c8/EhdL0FHV_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<hr> 
<h4><a id="macro_199"></a>macro</h4> 
<blockquote> 
 <p><a href="https://blog.csdn.net/Tao_ZT/article/details/102456649">数字后端基本概念介绍——Macro</a></p> 
 <p><a href="https://blog.csdn.net/lyfwill/article/details/81330081">ARM的memory Compiler总结_multiplexer width</a></p> 
</blockquote> 
<p>理解下 efuse macro</p> 
<h3><a id="_209"></a>概述</h3> 
<h4><a id="efuse_211"></a>efuse是什么？</h4> 
<p>之所以成为eFuse，因为其原理像电子保险丝一样。</p> 
<p><strong>efuse只能从0到1。主要功能是存一些不想被别人修改的数据(如密钥，出厂信息等等)，其次是冗余修复。</strong></p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/icxiaoge/article/details/83831118">芯片整体001：什么是efuse</a></p> 
 <p>eFuse的全称是“电子熔断器”（electronic fuse），是一种可编程电子保险丝，<strong>是一种用于存储信息和保护芯片的非易失性存储器件( ( non-volatile memory ))</strong>。它的原理是基于电子注入和热效应。在eFuse中，短电流脉冲被应用于热致电子发射，这会使电流通过一个非常小的导线。该电流会引起电线中的材料熔断，形成一个永久性的开路。这个过程是不可逆的，一旦eFuse被熔断，就不能再次编程。</p> 
 <p>Efuse是一次性可编程存储器(One time programmable)，在芯片出场之前会被写入信息，在一个芯片中，efuse的容量通常很小，一些芯片efuse只有128bit。</p> 
</blockquote> 
<blockquote> 
 <p><a href="https://aijishu.com/a/1060000000179134" rel="nofollow">OTP 们：PROM, eFuse, Antifuse </a></p> 
 <p>2004 年IBM 发明了eFuse, 不同于之前的可编程ROM, eFuse 不需要『体外编程器』，它利用EM ( electromigration ) 效应来实现『熔断』。eFuse 的发明可谓是革命性的，它不依赖于工艺，不需要新材料，不需要新工具，它结合了独特的软件算法和新的熔丝技术，根据条件的改变和系统需求动态调整和适应自身行为，在无需人工干预的情况下，可以监测并调整芯片的功能，以提高其质量、性能和功耗。最初因为『被编程』能力有限，eFuse 使用受限，但当与内建自测试 ( BIST ) 结合之后，它开始大放异彩。可以认真读一下当年IBM 的新闻稿。</p> 
</blockquote> 
<blockquote> 
 <p><a href="https://zhuanlan.zhihu.com/p/536007837" rel="nofollow">芯片信息安全（一）安全启动 </a></p> 
 <p>由于SOC可能会支持不同的启动方式，如xip启动可以直接从外部的norflash开始启动。因此在rom中集成bootrom镜像之后，还需要保证芯片每次启动时都必须从bootrom开始执行，否则攻击者还可以通过xip方式绕过整个secureboot流程。而一般xip启动模式都是在调试阶段用于问题定位的，因此在产品调试完成，启动secureboot前必须要关闭该模式。<strong>通常它可以通过OTP或EFUSE中的特定bit实现。</strong></p> 
</blockquote> 
<blockquote> 
 <p><a href="https://zhuanlan.zhihu.com/p/367624281" rel="nofollow">谈谈汽车芯片安全-下篇 </a></p> 
 <p>字段中的任何eFuse位都只能从0编程为1（融合），但是读取操作没有限制。OTP在安全中的应用一般可以存放一些固定不变的值，比如：</p> 
 <ul><li>每个设备唯一的根密钥（Master Key）</li><li>设备唯一ID（Device Unique ID）或者MAC 地址</li><li>一些安全配置或者秘密值（软件的Hash值，启动模式等）</li></ul> 
 <p>以上链接讲了efuse和secure boot的关系。</p> 
 <p><strong>芯片第一次 boot 时，软件 bootloader 根据以下步骤使能 Secure boot：</strong></p> 
 <p>…</p> 
 <p>bootloader通过烧写 efuse 中的 ABS_DONE_0 永久使能 secure boot。</p> 
 <p>…</p> 
</blockquote> 
<blockquote> 
 <p><a href="https://blog.csdn.net/qq_45763093/article/details/118081831">浅析安全启动（Secure Boot）附带EFUSE解析_efuse介绍及安全启动浅析</a></p> 
 <p>一般 eFUSE 的大小在 1KB 左右，OEM 从 CPU 厂家购买了芯片，组装了产品后，一般都要焼写 eFUSE 的内容，包括产品的运行模式：测试、开发、生产等。面向终端消费者的产品都会被焼写为生产模式。这个模式下 bootROM 会禁用很多权限，更大面积地限制用户的能力。</p> 
 <p>另外一个很重要的焼写内容就是根密钥了，一般有两种根密钥：一个是加密解密用的对称密钥 Secure Boot Key，一般是 AES 128 的，每台设备都是随机生成不一样的；另一个是一个 Secure Boot Signing Key 公钥，一般用的 RSA 或 ECC，这个是每个 OEM 自己生成的，每台设备用的都一样，有些芯片会存公钥的 Hash 来减少 eFUSE 的空间使用。</p> 
 <p>只有 Secure World（后面会介绍）才能访问 eFUSE 的寄存器。除了读写 eFUSE 的基础寄存器之外，还有一些控制寄存器可以禁止别的程序访问 eFUSE，来保护其中的密钥。因此 eFUSE 中的根密钥以及 bootROM 将作为 Secure Boot 的根信任。</p> 
</blockquote> 
<h4><a id="efuse_259"></a>efuse的作用及应用场景</h4> 
<blockquote> 
 <p><a href="https://blog.csdn.net/icxiaoge/article/details/83831118">芯片整体001：什么是efuse</a></p> 
 <p>eFuse可以被用于多个应用场景，例如芯片保护、电源管理、电路校准等。</p> 
 <p>在<strong>芯片保护</strong>方面，eFuse可以用于防止电路被过电压或过电流损坏，也可用于防篡改、防破解等;</p> 
 <p>在<strong>电源管理</strong>方面，eFuse可以用于控制电流和电压，确保电路正常工作;</p> 
 <p>在<strong>电路校准</strong>方面，eFuse可以用于校准电路参数，例如时钟频率和电流偏置等。</p> 
 <p>总的来说eFuse的优点是体积小、功耗低、可编程性强、可靠性高、不易被擦除等，因此在集成电路中得到了广泛应用。</p> 
</blockquote> 
<p><mark>Efuse还可用于存储MEM repair的存储修复数据</mark></p> 
<p>也可用于存储芯片的关键信息：如芯片可使用电源电压，关键时钟频率，芯片的版本号，生产日期。在厂家生产好die后，会进行测试，将芯片的信息写到efuse中去。</p> 
<p><strong>eFuse 应用范围很广，从模拟器件的调整、校准、修复到系统软件的现场更新，且被广泛应用于安全领域</strong>，但由于eFuse 的『编程结点』可以通过电子显微镜看到，因此其存储的内容可以被轻易破解。</p> 
<p>传统eFuse 的熔丝由多晶硅栅极层制成， 随着工艺几何尺寸的缩小和High-K 材料的使用，现在eFuse 的熔丝改由金属制成，随着时间的流逝，编程期间产生的『熔丝碎屑』会反向生长，这限制了eFuse 的可读次数。eFuse 的形状类似于领结，中心是一条窄金属条，较大的端头用作通孔和散热器的连接，受限于该形状，随着晶体管尺寸的减小，eFuse 的尺寸不能按比例减小，因此随着Macro 尺寸变大，eFuse 的密度并不能同比例增加，很少会超过4KB.</p> 
<p>顺应安全性和密度的需求，Antifuse 诞生。</p> 
<blockquote> 
 <p><a href="https://zhuanlan.zhihu.com/p/653516447" rel="nofollow">soc设计-efuse </a></p> 
 <p>简单就 eFuse功能 作以总结介绍，具体如下文：</p> 
 <p>（1）==Efuse被广泛利用最重要的一个原因就是能够对有缺陷的芯片进行修复，而且在修复的过程当中不需要外界的干预。==对于芯片的生产以及考虑到生产的成本，最重要的一点就是芯片生产的良率，若生产出有缺陷的芯片，而又不能修复。那处理的结果就只能是报废，这样的处理方式在很大程度上增加芯片的成本。<strong>Efuse技术的出现，即通过改变电路的某些电压，或者特意去关闭一些功能模块，这样即使芯片出现缺陷，但是依旧能去实现芯片要实现的某些功能</strong>。这样即使有生产出来的芯片有缺陷，通过Efuse技术去发现错误，并且对错误进行修复，这样一来芯片还是可以正常使用，所以**Efuse技术在提高芯片的良率以及降低芯片的成本上有很大的贡献。**另一方面，通过找到芯片易出错的地方，有助于以后芯片的改进，以前的熔丝都是单排的，只能进行一次的编程，<strong>而随着工艺的改进，现在Efuse采用的都是多排阵列，这就实现了Efuse的自我修复。</strong></p> 
 <p>（2）利用Efuse可以降低芯片的功耗以及增加芯片的可控性，由于Efuse可以进行编程，从而可以实现芯片关闭某些工作模块，当我们不需要某些模块时可以利用Efuse的编程来限制或者是屏蔽某些功能，从而可以<strong>降低芯片的功耗</strong>，也能进一步增加芯片的可控性。</p> 
 <p>（3）可提高芯片的安全性，利用Efuse技术，密码随时都可以进行修改，能有效的降低黑客的入侵。</p> 
 <p>（4）Efuse技术还可以降低制造的成本。在第一个功能应用中我们通过对芯片的修复，能减小芯片的报废而降低一部分成本，另外一个降低成本是通过芯片的集成多种不同的应用功能模块，当客户选择不同的功能时，不需要重新设计与制造，只需要通过Efuse技术来选择功能模块。这就在另一个层面来达到降低成本的效果。</p> 
 <p>（5）随着工艺的更微小化，Efuse利用电位迁移的技术，不仅不会对周边的电路造成破坏，而且还能对在封装后的芯片进行编程，这使得Efuse在芯片中的应用更为广泛。</p> 
 <p>（6）类似启动程序、加密密钥、模拟器件配置参数等。可通过efuse 控制着系统启动方式。模拟电路受工艺制造等误差的影响，流片回来的芯片往往需要对作参数校准，调试完成后将确定的值烧写到OTP中，芯片上电后OTP的值被装载到寄存器中，模拟电路参数完成校准。通过运用eFuse技术，允许计算机芯片的动态实时重新编程。Efuse可用于存储MEM repair的存储修复数据，也可用于保存芯片量产信息，以便后续追踪，如芯片可使用电源电压，芯片的版本号，生产日期。</p> 
 <p>Efuse对于芯片而言就像一个指挥官，它能够控制芯片中很多信号的的传输或者将其停止，这样就使得芯片中的其他电路能够更快的运转，Efuse不仅再一次的拯救芯片，还能提高芯片的效率。</p> 
</blockquote> 
<h4><a id="Antifuse_301"></a>Antifuse</h4> 
<h4><a id="efuse_305"></a>efuse是如何使用的</h4> 
<blockquote> 
 <p><a href="https://blog.csdn.net/icxiaoge/article/details/83831118">芯片整体001：什么是efuse</a></p> 
</blockquote> 
<p>在芯片出厂之前Efuse会被写入信息，efuse的容量通常不会很大，一些芯片efuse只有128bit，也存在部分芯片efuse容量超过1Kbit的，主要看芯片需求。</p> 
<p>如下所示128bit的efuse包含芯片电压字段、芯片版本号、芯片生产日期以及其他信息。</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/50/4b/dsBiTq2G_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>芯片在初次上电过程中会读取efuse中的电压字段数值，送到芯片外部的电源管理器，电源管理器在芯片初始上电前会提供一个标准的电压（假设为1.0v），在接受到efuse中的电压字段数值后会调节电压大小。如果芯片质量较好，电源管理器会将电源电压调节到较低值（0.8v），假设芯片质量一般，电压管理器将电源电压调节到稍高值（0.85v）。</p> 
<p>完成电源电压调整后，芯片会重新进行上电复位操作。</p> 
<blockquote> 
 <p><a href="https://toshiba-semicon-storage.com/cn/semiconductor/knowledge/highlighted-contents/articles/electronic-fuses-that-solve-the-problems-of-conventional-fuses/what-is-an-efuse-ic.html" rel="nofollow">eFuse IC是什么？ | 东芝半导体&amp;存储产品中国官网 </a></p> 
 <p>以上链接介绍了efuse实际芯片的外围电路及芯片功能</p> 
</blockquote> 
<h3><a id="efuse_325"></a>efuse的工作模式</h3> 
<blockquote> 
 <p><a href="https://zhuanlan.zhihu.com/p/653516447" rel="nofollow">soc设计-efuse </a></p> 
</blockquote> 
<h4><a id="_329"></a>相关信号</h4> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/4c/7a/rszk55by_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="eFuse_333"></a>eFuse操作模式</h4> 
<p>eFuse宏有三种操作模式，具体如下：</p> 
<p>（1）编程模式（Program mode）、</p> 
<p>（2）读取模式（Read mode）、</p> 
<p>（3）非活动模式（Inactive mode）。</p> 
<p>eFuse模块三种模式选择由其读选择信息（RDEN）和程序选择（PGMEN）的逻辑电平共同决定。</p> 
<p>工作模式：</p> 
<p>Mode 编程使能</p> 
<p>PGMEN 读取使能</p> 
<p>RDEN 模拟电源</p> 
<p>注意事项：</p> 
<p>（1） 编程使能和读使能不允许同时为H。</p> 
<p>（2） 除了在编程模式或读取模式下，不允许地址输入高电平，也就是说只有在编程或读取模式下才允许AEN为高电平。</p> 
<p>（3） 在编程模式或读取模式下，当AEN为高电平时，不允许端口(地址)切换。</p> 
<p>（4） 既不允许读取模式直接转换到编程模式，也不允许PGM模式直接转换到读取模式。</p> 
<h4><a id="Program_Mode_363"></a>编程模式（Program Mode）</h4> 
<p>在燃烧前，初始Fuse输出为“0”，燃烧后写入“1”。当编程模式(读使能RDEN=L，编程使能PGMEN=H)时，由地址A[11:0]（地址输入位）指定的EFUSE位将被AEN（地址使能位）的高脉冲烧毁。程序模式的详细时序见详解。D[7:0]在程序模式下未定义。</p> 
<p>注意:一根Fuse只能烧一次。</p> 
<h4><a id="Read_Mode_369"></a>读取模式（Read Mode）</h4> 
<p>如果RDEN=H，PGMEN=L，则EFUSE进入读取模式。读取模式的详细时序间详解。地址信号A[11]~A[9]为“无效”。4K = (4*1024) byte = 4096byte</p> 
<p>2^9 = 512 组织成512×8位的一次性可编程非易失性电熔丝存储单元。其中A[11:0]为地址输入，A[0]A[8]是有效单元，D[0]D[7]是读取模式下的并行数据输出。</p> 
<h4><a id="Inactivate_Mode_375"></a>非活动模式（Inactivate Mode）</h4> 
<p>如果编程模式和读取模式都不活动，则EFUSE进入非活动模式。非活动模式下的首选待机条件为AEN = L，RDEN = L，PGMEN=L，D[7:0]在非活动模式下未定义。</p> 
<h3><a id="Efuse_379"></a>Efuse设计思路</h3> 
<blockquote> 
 <p><a href="https://zhuanlan.zhihu.com/p/653516447" rel="nofollow">soc设计-efuse </a></p> 
</blockquote> 
<p>以烧录模式为例，时序图如下：</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/5c/b2/oqUybEIQ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>我们一般会在机台进行烧录，使用的接口可以是JTAG转APB，也可能是不太常用的SPI转APB或UARTM转APB，这三种接口都有一个缺点，就是配置delay比较长，所以说就堵死了我们只靠软件来进行配置的路。</p> 
<p>包括中兴，华为等大公司采用的都是软硬件结合的方法来进行烧录，时序如下图：</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/ff/7c/eIrR8bJ1_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>burn_start进入烧录状态，PGMIN中包含对PD,PS,CSB,PGENB等信号的控制，以满足efuse接口时序的setup和hold时间，进入真正的PGM状态后，配置一次ADDR，发起一次triger，来保证ADDR和strobe的时序关系。最后烧录完成，发起burn_end进入退出时序，以便进行二次烧录。</p> 
<p>当然还有更快的设计方法，就是ADDR提前写入软件寄存器，bit[x]=1代表这个地址需要被熔断，然后只需要一次triger就可以完成所有烧录，两者区别不大，因为机台对这点时间无感。</p> 
<p>同样的read时序也可以参考pgm时序，软硬件结合（利用counter）来满足模块的setup和hold时序要求。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/621698fe9aa55c9cddf9367e19796d67/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;中的双冒号(::) 使用小结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/33831aadf2edd75034afbe2b23700e84/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Redis安装配置，哨兵模式配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>