<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RunLoop终极解析:输入源，定时源，观察者，线程间通信，端口通信，NSPort，NSMessagePort，NSMachPort，NSPortMessage... - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RunLoop终极解析:输入源，定时源，观察者，线程间通信，端口通信，NSPort，NSMessagePort，NSMachPort，NSPortMessage..." />
<meta property="og:description" content="本文Demo传送门 RunloopDemo
前言 OSX / iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。
CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。
NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。
1. 如何查看RunLoop源代码 1.1 NSRunLoop源代码 NSRunLoop是Foundation框架里面的一个类，它的头文件可以在工程里面这样查看：
至于它的实现文件，暂时没有找到公开的资料。
1.2 CFRunLoopRef源代码 CFRunLoopRef 的代码是开源的，你可以在这里 opensource.apple.com/tarballs/CF… 下载到整个 CoreFoundation 的源码。为了方便跟踪和查看，你可以新建一个 Xcode 工程，把这堆源码拖进去看。
更多苹果源代码下载 苹果公开的源代码在这里可以下载，opensource.apple.com/tarballs/
例如，其中，有两个比较常见需要学习源码的下载地址：
runtime的源代码在opensource.apple.com/tarballs/ob…runloop(其实是整个 CoreFoundation)的源代码在opensource.apple.com/tarballs/CF… 当然，如果你想在github上在线查看源代码，可以点这里：runtime，runloop
2. 简析RunLoop源代码 2.1 Foundation相关Runloop的源码 NSRunLoop @interface NSRunLoop : NSObject { @private id _rl; id _dperf; id _perft; id _info; id	_ports; void	*_reserved[6]; } @property (class, readonly, strong) NSRunLoop *currentRunLoop; @property (class, readonly, strong) NSRunLoop *mainRunLoop API_AVAILABLE(macos(10." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/149df00dca14f5d11ad1c060f300d536/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-17T03:14:09+08:00" />
<meta property="article:modified_time" content="2018-05-17T03:14:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RunLoop终极解析:输入源，定时源，观察者，线程间通信，端口通信，NSPort，NSMessagePort，NSMachPort，NSPortMessage...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <p>本文Demo传送门 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fcimain%2FRunloopDemo" rel="nofollow">RunloopDemo</a></p> 
 <h3 class="heading">前言</h3> 
 <p>OSX / iOS 系统中，提供了两个这样的对象：<strong>NSRunLoop</strong> 和 <strong>CFRunLoopRef</strong>。</p> 
 <ul><li> <p><strong>CFRunLoopRef</strong> 是在 <strong>CoreFoundation</strong> 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。</p> </li><li> <p><strong>NSRunLoop</strong> 是基于 <strong>CFRunLoopRef</strong> 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p> </li></ul> 
 <h3 class="heading">1. 如何查看RunLoop源代码</h3> 
 <hr> 
 <h6 class="heading">1.1 NSRunLoop源代码</h6> 
 <p>NSRunLoop是Foundation框架里面的一个类，它的头文件可以在工程里面这样查看：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>至于它的实现文件，暂时没有找到公开的资料。</p> 
 <h6 class="heading">1.2 CFRunLoopRef源代码</h6> 
 <p>CFRunLoopRef 的代码是<a href="https://link.juejin.im?target=http%3A%2F%2Fopensource.apple.com%2Fsource%2FCF%2FCF-855.17%2FCFRunLoop.c" rel="nofollow">开源</a>的，你可以在这里 <a href="https://link.juejin.im?target=http%3A%2F%2Fopensource.apple.com%2Ftarballs%2FCF%2FCF-855.17.tar.gz" rel="nofollow">opensource.apple.com/tarballs/CF…</a> 下载到整个 CoreFoundation 的源码。为了方便跟踪和查看，你可以新建一个 Xcode 工程，把这堆源码拖进去看。</p> 
 <h6 class="heading">更多苹果源代码下载</h6> 
 <p>苹果公开的源代码在这里可以下载，<a href="https://link.juejin.im?target=https%3A%2F%2Fopensource.apple.com%2Ftarballs%2F" rel="nofollow">opensource.apple.com/tarballs/</a></p> 
 <p>例如，其中，有两个比较常见需要学习源码的下载地址：</p> 
 <ul><li>runtime的源代码在<a href="https://link.juejin.im?target=https%3A%2F%2Fopensource.apple.com%2Ftarballs%2Fobjc4%2F" rel="nofollow">opensource.apple.com/tarballs/ob…</a></li><li>runloop(其实是整个 CoreFoundation)的源代码在<a href="https://link.juejin.im?target=https%3A%2F%2Fopensource.apple.com%2Ftarballs%2FCF%2F" rel="nofollow">opensource.apple.com/tarballs/CF…</a></li></ul> 
 <p>当然，如果你想在github上在线查看源代码，可以点这里：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fcimain%2Fruntime" rel="nofollow">runtime</a>，<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fcimain%2FCoreFoudation" rel="nofollow">runloop</a></p> 
 <h3 class="heading">2. 简析RunLoop源代码</h3> 
 <hr> 
 <h5 class="heading">2.1 Foundation相关Runloop的源码</h5> 
 <h6 class="heading">NSRunLoop</h6> 
 <pre><code class="hljs bash copyable">@interface NSRunLoop : NSObject {
@private
    id          _rl;
    id          _dperf;
    id          _perft;
    id          _info;
    id		_ports;
    void	*_reserved[6];
}

@property (class, <span class="hljs-built_in">readonly</span>, strong) NSRunLoop *currentRunLoop;
@property (class, <span class="hljs-built_in">readonly</span>, strong) NSRunLoop *mainRunLoop API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));

@property (nullable, <span class="hljs-built_in">readonly</span>, copy) NSRunLoopMode currentMode;

- (CFRunLoopRef)getCFRunLoop CF_RETURNS_NOT_RETAINED;

- (void)addTimer:(NSTimer *)timer <span class="hljs-keyword">for</span>Mode:(NSRunLoopMode)mode;

- (void)addPort:(NSPort *)aPort <span class="hljs-keyword">for</span>Mode:(NSRunLoopMode)mode;
- (void)removePort:(NSPort *)aPort <span class="hljs-keyword">for</span>Mode:(NSRunLoopMode)mode;

- (nullable NSDate *)<span class="hljs-built_in">limit</span>DateForMode:(NSRunLoopMode)mode;
- (void)acceptInputForMode:(NSRunLoopMode)mode beforeDate:(NSDate *)<span class="hljs-built_in">limit</span>Date;

@end
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h5 class="heading">2.2 Core Foundation相关Runloop的源码</h5> 
 <h6 class="heading">__CFRunLoop</h6> 
 <pre><code class="hljs bash copyable">struct __CFRunLoop {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;			/* locked <span class="hljs-keyword">for</span> accessing mode list */
    __CFPort _wakeUpPort;			// used <span class="hljs-keyword">for</span> CFRunLoopWakeUp 
    Boolean _unused;
    volatile _per_run_data *_perRunData;              // reset <span class="hljs-keyword">for</span> runs of the run loop
    pthread_t _pthread;
    uint32_t _winthread;
    CFMutableSetRef _commonModes;
    CFMutableSetRef _commonModeItems;
    CFRunLoopModeRef _currentMode;
    CFMutableSetRef _modes;
    struct _block_item *_blocks_head;
    struct _block_item *_blocks_tail;
    CFTypeRef _counterpart;
};
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h6 class="heading">__CFRunLoopMode</h6> 
 <pre><code class="hljs bash copyable">struct __CFRunLoopMode {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */
    CFStringRef _name;
    Boolean _stopped;
    char _padding[3];
    CFMutableSetRef _sources0;
    CFMutableSetRef _sources1;
    CFMutableArrayRef _observers;
    CFMutableArrayRef _timers;
    CFMutableDictionaryRef _portToV1SourceMap;
    __CFPortSet _portSet;
    CFIndex _observerMask;
<span class="hljs-comment">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span>
    dispatch_source_t _timerSource;
    dispatch_queue_t _queue;
    Boolean _timerFired; // <span class="hljs-built_in">set</span> to <span class="hljs-literal">true</span> by the <span class="hljs-built_in">source</span> when a timer has fired
    Boolean _dispatchTimerArmed;
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if USE_MK_TIMER_TOO</span>
    mach_port_t _timerPort;
    Boolean _mkTimerArmed;
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if DEPLOYMENT_TARGET_WINDOWS</span>
    DWORD _msgQMask;
    void (*_msgPump)(void);
<span class="hljs-comment">#endif</span>
    uint64_t _timerSoftDeadline; /* TSR */
    uint64_t _timerHardDeadline; /* TSR */
};
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h6 class="heading">__CFRunLoopSource</h6> 
 <pre><code class="hljs bash copyable">struct __CFRunLoopSource {
    CFRuntimeBase _base;
    uint32_t _bits;
    pthread_mutex_t _lock;
    CFIndex _order;			/* immutable */
    CFMutableBagRef _runLoops;
    union {
	CFRunLoopSourceContext version0;	/* immutable, except invalidation */
        CFRunLoopSourceContext1 version1;	/* immutable, except invalidation */
    } _context;
};
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h6 class="heading">__CFRunLoopObserver</h6> 
 <pre><code class="hljs bash copyable">struct __CFRunLoopObserver {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;
    CFRunLoopRef _runLoop;
    CFIndex _rlCount;
    CFOptionFlags _activities;		/* immutable */
    CFIndex _order;			/* immutable */
    CFRunLoopObserverCallBack _callout;	/* immutable */
    CFRunLoopObserverContext _context;	/* immutable, except invalidation */
};
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h6 class="heading">__CFRunLoopTimer</h6> 
 <pre><code class="hljs bash copyable">struct __CFRunLoopTimer {
    CFRuntimeBase _base;
    uint16_t _bits;
    pthread_mutex_t _lock;
    CFRunLoopRef _runLoop;
    CFMutableSetRef _rlModes;
    CFAbsoluteTime _nextFireDate;
    CFTimeInterval _interval;		/* immutable */
    CFTimeInterval _tolerance;          /* mutable */
    uint64_t _fireTSR;			/* TSR units */
    CFIndex _order;			/* immutable */
    CFRunLoopTimerCallBack _callout;	/* immutable */
    CFRunLoopTimerContext _context;	/* immutable, except invalidation */
};
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading">3. Runloop的基本操作</h3> 
 <hr> 
 <h5 class="heading">3.1 如何创建线程对应的 Runloop?</h5> 
 <p>苹果不允许直接创建 <strong>RunLoop</strong>，它只提供了两个自动获取的函数：<strong>CFRunLoopGetMain()</strong> 和 <strong>CFRunLoopGetCurrent()</strong>。 当然，Foudation 框架也有对应的API。</p> 
 <h6 class="heading">Foundation</h6> 
 <pre><code class="hljs bash copyable">NSRunLoop *mainRunloop = [NSRunLoop mainRunLoop]; // 获得主线程对应的 runloop对象
NSRunLoop *currentRunloop = [NSRunLoop currentRunLoop]; // 获得当前线程对应的runloop对象
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h6 class="heading">Core Foundation</h6> 
 <pre><code class="hljs bash copyable">CFRunLoopRef maiRunloop = CFRunLoopGetMain(); // 获得主线程对应的 runloop对象
CFRunLoopRef maiRunloop = CFRunLoopGetCurrent(); // 获得当前线程对应的runloop对象
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h5 class="heading">3.2 底层如何获取RunLoop对象?</h5> 
 <p>获得runloop实现 (创建runloop)</p> 
 <pre><code class="hljs bash copyable">CFRunLoopRef CFRunLoopGetMain(void) {
    CHECK_FOR_FORK();
    static CFRunLoopRef __main = NULL; // no retain needed
    <span class="hljs-keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed
    <span class="hljs-built_in">return</span> __main;
}

CFRunLoopRef CFRunLoopGetCurrent(void) {
    CHECK_FOR_FORK();
    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);
    <span class="hljs-keyword">if</span> (rl) <span class="hljs-built_in">return</span> rl;
    <span class="hljs-built_in">return</span> _CFRunLoopGet0(pthread_self());
}

// should only be called by Foundation
// t==0 is a synonym <span class="hljs-keyword">for</span> <span class="hljs-string">"main thread"</span> that always works
CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) {
    <span class="hljs-keyword">if</span> (pthread_equal(t, kNilPthreadT)) {
	t = pthread_main_thread_np();
    }
    __CFSpinLock(&amp;loopsLock);
    <span class="hljs-keyword">if</span> (!__CFRunLoops) {
        __CFSpinUnlock(&amp;loopsLock);
	CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);
	CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());
	CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);
	<span class="hljs-keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) {
	    CFRelease(dict);
	}
	CFRelease(mainLoop);
        __CFSpinLock(&amp;loopsLock);
    }
    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
    __CFSpinUnlock(&amp;loopsLock);
    <span class="hljs-keyword">if</span> (!loop) {
	CFRunLoopRef newLoop = __CFRunLoopCreate(t);
        __CFSpinLock(&amp;loopsLock);
	loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
	<span class="hljs-keyword">if</span> (!loop) {
	    CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);
	    loop = newLoop;
	}
        // don<span class="hljs-string">'t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it
        __CFSpinUnlock(&amp;loopsLock);
	CFRelease(newLoop);
    }
    if (pthread_equal(t, pthread_self())) {
        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);
        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {
            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);
        }
    }
    return loop;
}
</span><span class="copy-code-btn">复制代码</span></code></pre> 
 <ul><li>【由上源码可得】：RunLoop 和 线程关系 
   <ul><li>1.每条线程都有唯一的一个与之对应的RunLoop对象。</li><li>2.主线程的RunLoop已经自动创建，子线程的RunLoop需要主动创建。</li><li>3.RunLoop在第一次获取时创建，在线程结束时销毁。</li></ul></li></ul> 
 <p>Runloop 对象是利用字典来进行存储，而且 Key:线程 -- Value:线程对应的 runloop。</p> 
 <h5 class="heading">3.3 RunLoop对象如何运行？</h5> 
 <h6 class="heading">① CFRunLoopRun</h6> 
 <p>RunLoop 其实内部就是do-while循环，在这个循环内部不断地处理各种任务（<code>比如Source、Timer、Observer</code>），通过判断result的值实现的。所以 可以看成是一个死循环。如果没有RunLoop，UIApplicationMain 函数执行完毕之后将直接返回，就是说程序一启动然后就结束；</p> 
 <pre><code class="hljs bash copyable">void CFRunLoopRun(void) {	/* DOES CALLOUT */
    int32_t result;
    <span class="hljs-keyword">do</span> {
        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, <span class="hljs-literal">false</span>);
        CHECK_FOR_FORK();
    } <span class="hljs-keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>源码得知：</p> 
 <ol><li>kCFRunLoopDefaultMode，默认情况下，runLoop是在这个mode下运行的，</li><li>runLoop的运行主体是一个do..while循环，除非停止或者结束，否则runLoop会一直运行下去</li></ol> 
 <h6 class="heading">② CFRunLoopRunInMode</h6> 
 <pre><code class="hljs bash copyable">SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean <span class="hljs-built_in">return</span>AfterSourceHandled) {     /* DOES CALLOUT */
    CHECK_FOR_FORK();
    <span class="hljs-built_in">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, <span class="hljs-built_in">return</span>AfterSourceHandled);
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>该方法，可以设置runLoop运行在哪个mode下modeName，超时时间seconds，以及是否处理完事件就返回returnAfterSourceHandled。</p> 
 <p>这两个方法实际调用的是同一个方法CFRunLoopRunSpecific，其返回是一个SInt32类型的值，根据返回值，来决定runLoop的运行状况。</p> 
 <h3 class="heading">4. RunLoop与线程</h3> 
 <hr> 
 <p>首先，iOS 开发中能遇到两个线程对象: <strong>pthread_t</strong> 和 <strong>NSThread</strong>。过去苹果有份<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.fenestrated.net%2F~macman%2Fmirrors%2FApple%2520Technotes%2520%28As%2520of%25202002%29%2Ftn%2Ftn2028.html" rel="nofollow">文档</a>标明了 <strong>NSThread</strong> 只是 <strong>pthread_t</strong> 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 <strong>mach thread</strong>。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 <strong>pthread_t</strong> 和 <strong>NSThread</strong> 是一一对应的。比如，你可以通过 <code>pthread_main_np()</code> 或 <code>[NSThread mainThread]</code> 来获取 <strong>主线程</strong>；也可以通过 <code>pthread_self()</code> 或 <code>[NSThread currentThread]</code> 来获取 <strong>当前线程</strong>。<strong>CFRunLoop</strong> 是基于 <strong>pthread</strong> 来管理的。</p> 
 <p>苹果不允许直接创建 <strong>RunLoop</strong>，它只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code> 和 <code>CFRunLoopGetCurrent()</code>。从上面的代码（第3.2节）可以看出，线程和 <strong>RunLoop</strong> 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 <strong>RunLoop</strong>，如果你不主动获取，那它一直都不会有。<strong>RunLoop</strong> 的创建是发生在第一次获取时，<strong>RunLoop</strong> 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 <strong>RunLoop</strong>（主线程除外）。</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h3 class="heading">5. RunLoop的五个类</h3> 
 <hr> 
 <p>在 <strong>Core Foundation</strong> 里面关于 <strong>RunLoop</strong> 有5个类:</p> 
 <table><thead><tr><th>序号</th><th>类</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><strong>CFRunloopRef</strong></td><td>【RunLoop本身】</td></tr><tr><td>2</td><td><strong>CFRunloopModeRef</strong></td><td>【Runloop的运行模式】</td></tr><tr><td>3</td><td><strong>CFRunloopSourceRef</strong></td><td>【Runloop要处理的事件源】</td></tr><tr><td>4</td><td><strong>CFRunloopTimerRef</strong></td><td>【Timer事件】</td></tr><tr><td>5</td><td><strong>CFRunloopObserverRef</strong></td><td>【Runloop的观察者（监听者）】</td></tr></tbody></table> 
 <p>他们的关系如下:</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h5 class="heading">5.1 CFRunLoop</h5> 
 <h6 class="heading">① 大致结构</h6> 
 <p>CFRunLoop 的结构大致如下：</p> 
 <pre><code class="hljs bash copyable">struct __CFRunLoop {
    CFMutableSetRef _commonModes;     // Set
    CFMutableSetRef _commonModeItems; // Set
    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
    CFMutableSetRef _modes;           // Set
    ...
};
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h6 class="heading">② CommonModes</h6> 
 <p>如上，有个概念叫 <strong>CommonModes</strong>：一个 Mode 可以将自己标记为"Common"属性：通过将其 ModeName 添加到 RunLoop 的 <strong>commonModes</strong> 中。例如：</p> 
 <pre><code class="hljs bash copyable">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES];
    [[NSRunLoop mainRunLoop] addTimer:timer <span class="hljs-keyword">for</span>Mode:NSRunLoopCommonModes];
    NSLog(@<span class="hljs-string">"%@"</span>,[NSRunLoop mainRunLoop]);
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h6 class="heading">③ CommonModeItems</h6> 
 <p>如上所示，添加 <strong>source</strong> 的时候，如果 modeName 传入<strong>kCFRunLoopCommonModes</strong> 或者 <strong>NSRunLoopCommonModes</strong>，则该 source 会被保存到 RunLoop 的 <strong>_commonModeItems</strong> 中，而且，会被添加到 <strong>commonModes</strong> 中的所有mode中去。</p> 
 <p>其实，每当 <strong>RunLoop</strong> 的内容发生变化时，<strong>RunLoop</strong> 都会自动将 <strong>_commonModeItems</strong> 里的 Source/Observer/Timer 同步到具有 <strong>Common</strong> 标记的所有Mode里。</p> 
 <h6 class="heading">④ 场景举例</h6> 
 <p>主线程的 <strong>RunLoop</strong> 里有两个预置的 Mode：<strong>kCFRunLoopDefaultMode</strong> 和 <strong>UITrackingRunLoopMode</strong>。这两个 Mode 都已经被标记为 <strong>Common</strong> 属性。</p> 
 <p>DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p> 
 <p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 <strong>commonModeItems</strong> 中。<strong>commonModeItems</strong> 被 RunLoop 自动更新到所有具有 <strong>Common</strong> 属性的 Mode 里去。</p> 
 <h6 class="heading">⑤ 特点</h6> 
 <p>一个 <strong>RunLoop</strong> 包含若干个 Mode，每个 Mode 又包含若干个<strong>Source</strong>/<strong>Timer</strong>/<strong>Observer</strong>。但是，运行的时候，一条线程对应一个 <strong>Runloop</strong>，<strong>Runloop</strong> 总是运行在某种特定的<strong>CFRunLoopModeRef</strong>（运行模式）下。</p> 
 <p>这是因为，在 <strong>Runloop</strong> 中有多个运行模式，每次调用 <strong>RunLoop</strong> 的主函数<code>__CFRunloopRun()</code> 时，只能指定其中一个 <strong>Mode</strong>（称 CurrentMode）运行， 如果需要切换 Mode，只能是退出 CurrentMode 切换到指定的 Mode 进入，目的以保证不同 Mode 下的 <code>Source / Timer / Observer</code> 互不影响。</p> 
 <p>每次调用 <strong>RunLoop</strong> 的主函数时，只能指定其中一个 Mode，这个Mode被称作 <strong>CurrentMode</strong>。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p> 
 <p><strong>Runloop</strong> 要有效，mode 里面 至少 要有一个 <strong>timer</strong> (定时器事件) 或者是 <strong>source</strong> (源);</p> 
 <h5 class="heading">5.2 CFRunLoopMode</h5> 
 <h6 class="heading">① 大致结构</h6> 
 <p><strong>CFRunLoopMode</strong> 的结构大致如下：</p> 
 <pre><code class="hljs bash copyable">struct __CFRunLoopMode {
    CFStringRef _name;            // Mode Name, 例如 @<span class="hljs-string">"kCFRunLoopDefaultMode"</span>
    CFMutableSetRef _sources0;    // Set
    CFMutableSetRef _sources1;    // Set
    CFMutableArrayRef _observers; // Array
    CFMutableArrayRef _timers;    // Array
    ...
};
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h6 class="heading">② Mode 及操作接口</h6> 
 <p><strong>CFRunLoopModeRef</strong> 类并没有对外暴露，只是通过 <strong>CFRunLoopRef</strong> 的接口进行了封装。<strong>CFRunLoopRef</strong> 获取 <strong>Mode</strong> 的接口：</p> 
 <pre><code class="hljs bash copyable">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);
CFRunLoopRunInMode(CFStringRef modeName, ...);
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>我们没有办法直接创建一个CFRunLoopMode对象，但是我们可以调用<code>CFRunLoopAddCommonMode</code> 传入一个字符串向 <strong>RunLoop</strong> 中添加 <strong>Mode</strong>，传入的字符串即为 Mode 的名字，Mode对象应该是此时在RunLoop内部创建的。</p> 
 <p>这里看一下<code>CFRunLoopAddCommonMode</code>源码。</p> 
 <pre><code class="hljs bash copyable">void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFStringRef modeName) {
    CHECK_FOR_FORK();
    <span class="hljs-keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="hljs-built_in">return</span>;
    __CFRunLoopLock(rl);
    //看rl中是否已经有这个mode，如果有就什么都不做
    <span class="hljs-keyword">if</span> (!CFSetContainsValue(rl-&gt;_commonModes, modeName)) {
        CFSetRef <span class="hljs-built_in">set</span> = rl-&gt;_commonModeItems ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModeItems) : NULL;
        //把modeName添加到RunLoop的_commonModes中
        CFSetAddValue(rl-&gt;_commonModes, modeName);
        <span class="hljs-keyword">if</span> (NULL != <span class="hljs-built_in">set</span>) {
            CFTypeRef context[2] = {rl, modeName};
            /* add all common-modes items to new mode */
            //这里调用CFRunLoopAddSource/CFRunLoopAddObserver/CFRunLoopAddTimer的时候会调用
            //__CFRunLoopFindMode(rl, modeName, <span class="hljs-literal">true</span>)，CFRunLoopMode对象在这个时候被创建
            CFSetApplyFunction(<span class="hljs-built_in">set</span>, (__CFRunLoopAddItemsToCommonMode), (void *)context);
            CFRelease(<span class="hljs-built_in">set</span>);
        }
    } <span class="hljs-keyword">else</span> {
    }
    __CFRunLoopUnlock(rl);
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>可以看得出：</p> 
 <ul><li>modeName不能重复，modeName是mode的唯一标识符</li><li>RunLoop的_commonModes数组存放所有被标记为common的mode的名称</li><li>添加commonMode会把commonModeItems数组中的所有source同步到新添加的mode中</li><li>CFRunLoopMode对象在CFRunLoopAddItemsToCommonMode函数中调用CFRunLoopFindMode时被创建</li></ul> 
 <h6 class="heading">③ mode item 及操作接口</h6> 
 <p><strong>Source/Timer/Observer</strong> 被统称为 <strong>mode item</strong>，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p> 
 <p>Mode 暴露的管理 <strong>mode item</strong> 的接口有下面几个，通过他们我们可以为Run Loop 添加 Source（ModeItem）。</p> 
 <pre><code class="hljs bash copyable">void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef <span class="hljs-built_in">source</span>, CFStringRef mode)
void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef <span class="hljs-built_in">source</span>, CFStringRef mode)
void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode)
void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode)
void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode)
void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode)
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>你只能通过 <strong>mode name</strong> 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 <strong>CFRunLoopModeRef</strong>。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p> 
 <p>这里只分析其中 <code>CFRunLoopAddSource</code> 的源码</p> 
 <pre><code class="hljs bash copyable">//添加<span class="hljs-built_in">source</span>事件
void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) {    /* DOES CALLOUT */
    CHECK_FOR_FORK();
    <span class="hljs-keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="hljs-built_in">return</span>;
    <span class="hljs-keyword">if</span> (!__CFIsValid(rls)) <span class="hljs-built_in">return</span>;
    Boolean <span class="hljs-keyword">do</span>Ver0Callout = <span class="hljs-literal">false</span>;
    __CFRunLoopLock(rl);
    //如果是kCFRunLoopCommonModes
    <span class="hljs-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
        //如果runloop的_commonModes存在，则copy一个新的复制给<span class="hljs-built_in">set</span>
        CFSetRef <span class="hljs-built_in">set</span> = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;
       //如果runl _commonModeItems为空
        <span class="hljs-keyword">if</span> (NULL == rl-&gt;_commonModeItems) {
            //先初始化
            rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);
        }
        //把传入的CFRunLoopSourceRef加入_commonModeItems
        CFSetAddValue(rl-&gt;_commonModeItems, rls);
        //如果刚才<span class="hljs-built_in">set</span> copy到的数组里有数据
        <span class="hljs-keyword">if</span> (NULL != <span class="hljs-built_in">set</span>) {
            CFTypeRef context[2] = {rl, rls};
            /* add new item to all common-modes */
            //则把<span class="hljs-built_in">set</span>里的所有mode都执行一遍__CFRunLoopAddItemToCommonModes函数
            CFSetApplyFunction(<span class="hljs-built_in">set</span>, (__CFRunLoopAddItemToCommonModes), (void *)context);
            CFRelease(<span class="hljs-built_in">set</span>);
        }
        //以上分支的逻辑就是，如果你往kCFRunLoopCommonModes里面添加一个<span class="hljs-built_in">source</span>，那么所有_commonModes里的mode都会添加这个<span class="hljs-built_in">source</span>
    } <span class="hljs-keyword">else</span> {
        //根据modeName查找mode
        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, <span class="hljs-literal">true</span>);
        //如果_sources0不存在，则初始化_sources0，_sources0和_portToV1SourceMap
        <span class="hljs-keyword">if</span> (NULL != rlm &amp;&amp; NULL == rlm-&gt;_sources0) {
            rlm-&gt;_sources0 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);
            rlm-&gt;_sources1 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);
            rlm-&gt;_portToV1SourceMap = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, NULL);
        }
        //如果_sources0和_sources1中都不包含传入的<span class="hljs-built_in">source</span>
        <span class="hljs-keyword">if</span> (NULL != rlm &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources0, rls) &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources1, rls)) {
            //如果version是0，则加到_sources0
            <span class="hljs-keyword">if</span> (0 == rls-&gt;_context.version0.version) {
                CFSetAddValue(rlm-&gt;_sources0, rls);
                //如果version是1，则加到_sources1
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (1 == rls-&gt;_context.version0.version) {
                CFSetAddValue(rlm-&gt;_sources1, rls);
                __CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.version1.info);
                <span class="hljs-keyword">if</span> (CFPORT_NULL != src_port) {
                    //此处只有在加到<span class="hljs-built_in">source</span>1的时候才会把souce和一个mach_port_t对应起来
                    //可以理解为，<span class="hljs-built_in">source</span>1可以通过内核向其端口发送消息来主动唤醒runloop
                    CFDictionarySetValue(rlm-&gt;_portToV1SourceMap, (const void *)(uintptr_t)src_port, rls);
                    __CFPortSetInsert(src_port, rlm-&gt;_portSet);
                }
            }
            __CFRunLoopSourceLock(rls);
            //把runloop加入到<span class="hljs-built_in">source</span>的_runLoops中
            <span class="hljs-keyword">if</span> (NULL == rls-&gt;_runLoops) {
                rls-&gt;_runLoops = CFBagCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeBagCallBacks); // sources retain run loops!
            }
            CFBagAddValue(rls-&gt;_runLoops, rl);
            __CFRunLoopSourceUnlock(rls);
            <span class="hljs-keyword">if</span> (0 == rls-&gt;_context.version0.version) {
                <span class="hljs-keyword">if</span> (NULL != rls-&gt;_context.version0.schedule) {
                    <span class="hljs-keyword">do</span>Ver0Callout = <span class="hljs-literal">true</span>;
                }
            }
        }
        <span class="hljs-keyword">if</span> (NULL != rlm) {
            __CFRunLoopModeUnlock(rlm);
        }
    }
    __CFRunLoopUnlock(rl);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">do</span>Ver0Callout) {
        // although it looses some protection <span class="hljs-keyword">for</span> the <span class="hljs-built_in">source</span>, we have no choice but
        // to <span class="hljs-keyword">do</span> this after unlocking the run loop and mode locks, to avoid deadlocks
        // <span class="hljs-built_in">where</span> the <span class="hljs-built_in">source</span> wants to take a lock <span class="hljs-built_in">which</span> is already held <span class="hljs-keyword">in</span> another
        // thread <span class="hljs-built_in">which</span> is itself waiting <span class="hljs-keyword">for</span> a run loop/mode lock
        rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, modeName); /* CALLOUT */
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>通过添加source的这段代码可以得出如下结论：</p> 
 <ul><li>如果modeName传入kCFRunLoopCommonModes，则该source会被保存到RunLoop的_commonModeItems中</li><li>如果modeName传入kCFRunLoopCommonModes，则该source会被添加到所有commonMode中</li><li>如果modeName传入的不是kCFRunLoopCommonModes，则会先查找该Mode，如果没有，会创建一个</li><li>同一个source在一个mode中只能被添加一次</li></ul> 
 <h6 class="heading">④ mode name</h6> 
 <p>苹果公开提供的 Mode 有两个：<strong>kCFRunLoopDefaultMode</strong> (NSDefaultRunLoopMode) 和 <strong>UITrackingRunLoopMode</strong>，你可以用这两个 Mode Name 来操作其对应的 Mode。</p> 
 <p>苹果还提供了一个操作 Common 标记的字符串：<strong>kCFRunLoopCommonModes</strong> (NSRunLoopCommonModes)，你可以用这个字符串来操作 <strong>Common Items</strong>，或标记一个 Mode 为 "Common"。使用时注意区分这个字符串和其他 mode name。</p> 
 <p>更完整的mode name如下表所示：</p> 
 <table><thead><tr><th>mode name</th><th>说明</th></tr></thead><tbody><tr><td><strong>kCFRunLoopDefaultMode</strong></td><td>App的默认Mode，通常主线程是在这个Mode下运行</td></tr><tr><td><strong>UITrackingRunLoopMode</strong></td><td>界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</td></tr><tr><td>UIInitializationRunLoopMode</td><td>在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</td></tr><tr><td>GSEventReceiveRunLoopMode</td><td>接受系统事件的内部 Mode，通常用不到</td></tr><tr><td><strong>kCFRunLoopCommonModes</strong></td><td>这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode</td></tr></tbody></table> 
 <h5 class="heading">5.3 CFRunLoopSourceRef (输入源)</h5> 
 <p>CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p> 
 <p>数据结构（source0/source1）：</p> 
 <pre><code class="hljs bash copyable">// <span class="hljs-built_in">source</span>0 (manual): order(优先级)，callout(回调函数)
CFRunLoopSource {order =..., {callout =... }}

// <span class="hljs-built_in">source</span>1 (mach port)：order(优先级)，port:(端口), callout(回调函数)
CFRunLoopSource {order = ..., {port = ..., callout =...}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ul><li> <p><strong>Source0</strong>：只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p> </li><li> <p><strong>Source1</strong>：包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p> </li></ul> 
 <h5 class="heading">5.4 CFRunLoopTimerRef (定时源)</h5> 
 <p>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Fcontent%2Fdocumentation%2FCoreFoundation%2FConceptual%2FCFDesignConcepts%2FArticles%2FtollFreeBridgedTypes.html%23%2F%2Fapple_ref%2Fdoc%2Fuid%2FTP40010677" rel="nofollow">Toll-Free Bridged</a> 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p> 
 <h5 class="heading">5.5 CFRunLoopObserverRef (观察者)</h5> 
 <p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p> 
 <pre><code class="hljs bash copyable">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
};
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading">6. 实战</h3> 
 <hr> 
 <h5 class="heading">6.1 设置输入源</h5> 
 <h6 class="heading">① performSelector</h6> 
 <p>performSelector同样是触发Source0事件。selector也是特殊的基于自定义的源.理论上来说,允许在当前线程向任何线程上执行发送消息,和基于端口的源一样,执行selector请求会在目标线程上序列化,减缓许多在线程上允许多个方法容易引起的同步问题.不像基于端口的源,一个selector执行完后会自动从run loop里面移除.</p> 
 <ul><li>主线程执行</li></ul> 
 <pre><code class="hljs bash copyable">dispatch_async(dispatch_get_global_queue(0, 0), ^{
    [self performSelectorOnMainThread:@selector(<span class="hljs-built_in">test</span>) withObject:nil <span class="hljs-built_in">wait</span>UntilDone:YES];
});
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ul><li>当前线程延时执行</li></ul> 
 <pre><code class="hljs bash copyable">// 内部会创建一个Timer到当前线程的runloop中（如果当前线程没runloop则方法无效；performSelector:onThread: 方法放到指定线程runloop中）
- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>当调用上述API，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p> 
 <ul><li>指定线程执行</li></ul> 
 <pre><code class="hljs bash copyable">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg <span class="hljs-built_in">wait</span>UntilDone:(BOOL)<span class="hljs-built_in">wait</span>;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>当调用 performSelector:onThread: 时，实际上其会创建一个Timer加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效.</p> 
 <ul><li>当前线程指定mode name并延时执行</li></ul> 
 <pre><code class="hljs bash copyable">// 只在NSDefaultRunLoopMode下执行(刷新图片)
[self.myImageView performSelector:@selector(<span class="hljs-built_in">set</span>Image:) withObject:[UIImage imageNamed:@<span class="hljs-string">""</span>] afterDelay:ti <span class="hljs-keyword">in</span>Modes:@[NSDefaultRunLoopMode]]; 
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h6 class="heading">② 自定义输入源</h6> 
 <p>自定义源：使用CFRunLoopSourceRef 类型相关的函数 (线程) 来创建自定义输入源。</p> 
 <ul><li>调用VC</li></ul> 
 <pre><code class="hljs bash copyable">-(void)<span class="hljs-built_in">test</span> {
    NSThread* aThread = [[NSThread alloc] initWithTarget:self selector:@selector(<span class="hljs-built_in">test</span>ForCustomSource) object:nil];
    self.aThread = aThread;
    [aThread start];
}

-(void)<span class="hljs-built_in">test</span>ForCustomSource{
    NSLog(@<span class="hljs-string">"starting thread......."</span>);
    
    NSRunLoop *myRunLoop = [NSRunLoop currentRunLoop];
    
   // 设置Run Loop observer的运行环境
    CFRunLoopObserverContext context = {0, (__bridge void *)(self), NULL, NULL, NULL};
    
    // 创建Run loop observer对象
    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities, YES, 0, &amp;myRunLoopObserver, &amp;context);
    <span class="hljs-keyword">if</span> (observer){
        CFRunLoopRef cfLoop = [myRunLoop getCFRunLoop];
        CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);
    }
    
    _source = [[ZXRunLoopSource alloc] init];
    [_source addToCurrentRunLoop];
    <span class="hljs-keyword">while</span> (!self.aThread.isCancelled)
    {
        NSLog(@<span class="hljs-string">"We can do other work"</span>);
        [myRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:5.0f]];
    }
    [_source invalidate];
    NSLog(@<span class="hljs-string">"finishing thread........."</span>);
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ul><li>自定义输入源</li></ul> 
 <pre><code class="hljs bash copyable">- (id)init
{
    CFRunLoopSourceContext  context = {0, (__bridge void *)(self), NULL, NULL, NULL, NULL, NULL,
        &amp;RunLoopSourceScheduleRoutine,
        RunLoopSourceCancelRoutine,
        RunLoopSourcePerformRoutine};
    
    _runLoopSource = CFRunLoopSourceCreate(NULL, 0, &amp;context);
    _commands = [[NSMutableArray alloc] init];
    
    <span class="hljs-built_in">return</span> self;
}

- (void)addToCurrentRunLoop
{
    //获取当前线程的runLoop(辅助线程)
    CFRunLoopRef runLoop = CFRunLoopGetCurrent();
    CFRunLoopAddSource(runLoop, _runLoopSource, kCFRunLoopDefaultMode);
}

/**
 *  调度例程
 *  当将输入源安装到run loop后，调用这个协调调度例程，将源注册到客户端（可以理解为其他线程）
 *
 */
void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)
{
    ZXRunLoopSource *obj = (__bridge ZXRunLoopSource*)info;
//    AppDelegate*   delegate = [[AppDelegate sharedAppDelegate];
    AppDelegate *delegate = [[UIApplication sharedApplication] delegate];
    RunLoopContext *theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];
    
    //发送注册请求
    [delegate performSelectorOnMainThread:@selector(registerSource:) withObject:theContext <span class="hljs-built_in">wait</span>UntilDone:YES];
}

/**
 *  处理例程
 *  在输入源被告知（signal <span class="hljs-built_in">source</span>）时，调用这个处理例程，这儿只是简单的调用了 [obj <span class="hljs-built_in">source</span>Fired]方法
 *
 */
void RunLoopSourcePerformRoutine (void *info)
{
    ZXRunLoopSource*  obj = (__bridge ZXRunLoopSource*)info;
    [obj <span class="hljs-built_in">source</span>Fired];
//    [NSTimer scheduledTimerWithTimeInterval:1.0 target:obj selector:@selector(timerAction:) userInfo:nil repeats:YES];
}

/**
 *  取消例程
 *  如果使用CFRunLoopSourceInvalidate/CFRunLoopRemoveSource函数把输入源从run loop里面移除的话，系统会调用这个取消例程，并且把输入源从注册的客户端（可以理解为其他线程）里面移除
 *
 */
void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)
{
    ZXRunLoopSource* obj = (__bridge ZXRunLoopSource*)info;
    AppDelegate* delegate = [AppDelegate sharedAppDelegate];
    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];
    
    [delegate performSelectorOnMainThread:@selector(removeSource:) withObject:theContext <span class="hljs-built_in">wait</span>UntilDone:NO];
}

- (void)<span class="hljs-built_in">source</span>Fired
{
    NSLog(@<span class="hljs-string">"Source fired: do some work, dude!"</span>);
    NSThread *thread = [NSThread currentThread];
    [thread cancel];
    
    //既然线程没了，就把AppDelegate缓存的runloop也给删了，以免下次调用CFRunLoopWakeUp(runloop);会崩溃，因为只有runloop没了线程
    [[AppDelegate sharedAppDelegate].sources removeObjectAtIndex:0];
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h6 class="heading">③ 端口输入源</h6> 
 <p>配置 NSMachPort 对象</p> 
 <p>为了和 NSMachPort 对象建立稳定的本地连接，你需要创建端口对象并将之加入相应的线程的 run loop。当运行辅助线程的时候，你传递端口对象到线程的主体入口点。辅助线程可以使用相同的端口对象将消息返回给原线程。</p> 
 <ul><li>VC调用</li></ul> 
 <pre><code class="hljs bash copyable">- (void)launchThreadForPort
{
    NSPort* myPort = [NSMachPort port];
    <span class="hljs-keyword">if</span> (myPort)
    {
        //这个类持有即将到来的端口消息
        [myPort <span class="hljs-built_in">set</span>Delegate:self];
        //将端口作为输入源安装到当前的 runLoop
        [[NSThread currentThread] <span class="hljs-built_in">set</span>Name:@<span class="hljs-string">"launchThreadForPort---Thread"</span>];
        [[NSRunLoop currentRunLoop] addPort:myPort <span class="hljs-keyword">for</span>Mode:NSDefaultRunLoopMode];
        //当前线程去调起工作线程
        MyWorkerClass *work = [[MyWorkerClass alloc] init];
        [NSThread detachNewThreadSelector:@selector(launchThreadWithPort:) toTarget:work withObject:myPort];
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>为了在线程间建立双向的通信，你需要让工作线程在签到的消息中发送自己的本地端口到主线程。主线程接收到签到消息后就可以知道辅助线程运行正常，并且供了发送消息给辅助线程的方法。</p> 
 <p>以下代码显示了主线程的 <code>handlePortMessage:</code> 方法。当由数据到达线程的本地端口时，该方法被调用。当签到消息到达时，此方法可以直接从辅助线程里面检索端口并保存下来以备后续使用。</p> 
 <ul><li>VC实现代理</li></ul> 
 <pre><code class="hljs bash copyable">//NSPortDelegate
<span class="hljs-comment">#define kCheckinMessage 100</span>
//处理从工作线程返回的响应
- (void) handlePortMessage: (id)portMessage {
    //消息的 id
    unsigned int messageId = (int)[[portMessage valueForKeyPath:@<span class="hljs-string">"msgid"</span>] unsignedIntegerValue];
    
    <span class="hljs-keyword">if</span> (messageId == kCheckinMessage) {
        
        //1. 当前主线程的port
        NSPort *<span class="hljs-built_in">local</span>Port = [portMessage valueForKeyPath:@<span class="hljs-string">"localPort"</span>];
        //2. 接收到消息的port（来自其他线程）
        NSPort *remotePort = [portMessage valueForKeyPath:@<span class="hljs-string">"remotePort"</span>];
        //3. 获取工作线程关联的端口，并设置给远程端口，结果同2
        NSPort *distantPort = [portMessage valueForKeyPath:@<span class="hljs-string">"sendPort"</span>];
        
        NSMutableArray *arr = [[portMessage valueForKeyPath:@<span class="hljs-string">"components"</span>] mutableCopy];
        <span class="hljs-keyword">if</span> ([arr objectAtIndex:0]) {
            NSData *data = [arr objectAtIndex:0];
            NSString * str  =[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
            NSLog(@<span class="hljs-string">""</span>);
        }
        NSLog(@<span class="hljs-string">""</span>);
        //为了以后的使用保存工作端口
//        [self storeDistantPort: distantPort];
    } <span class="hljs-keyword">else</span> {
        //处理其他的消息
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>对于辅助工作线程，你必须配置线程使用特定的端口以发送消息返回给主要线程。</p> 
 <p>以下显示了如何设置工作线程的代码。创建了线程的自动释放池后，紧接着创建工作对象驱动线程运行。工作对象的 <code>sendCheckinMessage:</code> 方法创建了工作线程的本地端口并发送签到消息回主线程。</p> 
 <ul><li>MyWorkerClass.m</li></ul> 
 <pre><code class="hljs bash copyable">- (void)launchThreadWithPort:(NSPort *)port {
    @autoreleasepool {
        
        //1. 保存主线程传入的port
        remotePort = port;
        
        //2. 设置子线程名字
        [[NSThread currentThread] <span class="hljs-built_in">set</span>Name:@<span class="hljs-string">"MyWorkerClassThread"</span>];
        
        //3. 开启runloop
        [[NSRunLoop currentRunLoop] run];
        
        //4. 创建自己port
        myPort = [NSPort port];
        
        //5.
        myPort.delegate = self;
        
        //6. 将自己的port添加到runloop
        //作用1、防止runloop执行完毕之后推出
        //作用2、接收主线程发送过来的port消息
        [[NSRunLoop currentRunLoop] addPort:myPort <span class="hljs-keyword">for</span>Mode:NSDefaultRunLoopMode];
        
        //7. 完成向主线程port发送消息
        [self sendPortMessage];
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>当使用 <strong>NSMachPort</strong> 的时候，本地和远程线程可以使用相同的端口对象在线程间进行单边通信。换句话说，一个线程创建的本地端口对象成为另一个线程的远程端口对象。</p> 
 <p>以下代码辅助线程的签到例程，该方法为之后的通信设置自己的本地端口，然后发送签到消息给主线程。它使用 <code>LaunchThreadWithPort:</code> 方法中收到的端口对象做为目标消息。</p> 
 <ul><li>MyWorkerClass.m</li></ul> 
 <pre><code class="hljs bash copyable">- (void)sendPortMessage {
    
    NSString *str1 = @<span class="hljs-string">"aaa111"</span>;
    NSString *str2 = @<span class="hljs-string">"bbb222"</span>;
    arr = [[NSMutableArray alloc] initWithArray:@[[str1 dataUsingEncoding:NSUTF8StringEncoding],[str2 dataUsingEncoding:NSUTF8StringEncoding]]];
    //发送消息到主线程，操作1
    [remotePort sendBeforeDate:[NSDate date]
                         msgid:kMsg1
                    components:arr
                          from:myPort
                      reserved:0];
    
    //发送消息到主线程，操作2
    //    [remotePort sendBeforeDate:[NSDate date]
    //                         msgid:kMsg2
    //                    components:nil
    //                          from:myPort
    //                      reserved:0];
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <blockquote> 
  <p><strong>注意</strong>：上述的一个API中 <code>components</code> 不能直接装NSString等数据，必须是NSData或者NSPort及其子类的实例对象。完整的API声明如下所示：</p> 
 </blockquote> 
 <pre><code class="hljs bash copyable">- (BOOL)sendBeforeDate:(NSDate *)<span class="hljs-built_in">limit</span>Date msgid:(NSUInteger)msgID components:(nullable NSMutableArray *)components from:(nullable NSPort *)receivePort reserved:(NSUInteger)headerSpaceReserved;
	// The components array consists of a series of instances
	// of some subclass of NSData, and instances of some
	// subclass of NSPort; since one subclass of NSPort does
	// not necessarily know how to transport an instance of
	// another subclass of NSPort (or could <span class="hljs-keyword">do</span> it even <span class="hljs-keyword">if</span> it
	// knew about the other subclass), all of the instances
	// of NSPort <span class="hljs-keyword">in</span> the components array and the <span class="hljs-string">'receivePort'</span>
	// argument MUST be of the same subclass of NSPort that
	// receives this message.  If multiple DO transports are
	// being used <span class="hljs-keyword">in</span> the same program, this requires some care.
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>实验验证</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <blockquote> 
  <ul><li>macOS特殊情况（iOS开发者可忽略）</li></ul> 
 </blockquote> 
 <p>为了和 NSMeaasgePort 的建立稳定的本地连接，你不能简单的在线程间传递端口对象。远程消息端口必须通过名字来获得。在 Cocoa 中这需要你给本地端口指定一个名字，并将名字传递到远程线程以便远程线程可以获得合适的端口对象用于通信。以下代码显示端口创建，注册到你想要使用消息端口的进程。</p> 
 <pre><code class="hljs bash copyable">- (void)fireAllCommandsOnRunLoop:(CFRunLoopRef)runLoop  
{  
    //当手动调用此方法的时候，将会触发 RunLoopSourceContext的performCallback  
    CFRunLoopSourceSignal(runLoopSource);  
    CFRunLoopWakeUp(runLoop);  
      
    NSPort *<span class="hljs-built_in">local</span>Port = [[NSMessagePort alloc] init];  
      
    // configure the port and add it to the current run loop  
    [<span class="hljs-built_in">local</span>Port <span class="hljs-built_in">set</span>Delegate:self];  
    [[NSRunLoop currentRunLoop] addPort:<span class="hljs-built_in">local</span>Port <span class="hljs-keyword">for</span>Mode:NSDefaultRunLoopMode];  
      
    // register the port using the specific name, and The name is unique  
    NSString *<span class="hljs-built_in">local</span>PortName = [NSString stringWithFormat:@<span class="hljs-string">"MyPortName"</span>];  
    // there is only NSMessagePortNameServer <span class="hljs-keyword">in</span> the mac os x system  
    [[NSMessagePortNameServer sharedInstance] registerPort:<span class="hljs-built_in">local</span>Port name:<span class="hljs-built_in">local</span>PortName];  
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>需要注意的是，只能在一个设备内程序间通信，不能在不同设备间通信。将端口名称注册到NSMessagePortNameServer里面，其他线程通过这个端口名称从NSMessagePortNameServer来获取这个端口对象。</p> 
 <p>根据name获取port的API为：</p> 
 <pre><code class="hljs bash copyable">- (NSPort *)portForName:(NSString *)name;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <pre><code class="hljs bash copyable">- (NSPort *)portForName:(NSString *)name host:(NSString *)host;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <blockquote> 
  <p><strong>区分</strong>：NSPort，NSMessagePort，NSMachPort，NSPortMessage</p> 
 </blockquote> 
 <h6 class="heading">❶ iOS和macOS都有的类: 在NSPort.h中可找到</h6> 
 <ul><li>NSPort</li></ul> 
 <pre><code class="hljs bash copyable">@interface NSPort : NSObject &lt;NSCopying, NSCoding&gt;

+ (NSPort *)port;

- (void)invalidate;
@property (<span class="hljs-built_in">readonly</span>, getter=isValid) BOOL valid;

- (void)<span class="hljs-built_in">set</span>Delegate:(nullable id &lt;NSPortDelegate&gt;)anObject;
- (nullable id &lt;NSPortDelegate&gt;)delegate;

- (void)scheduleInRunLoop:(NSRunLoop *)runLoop <span class="hljs-keyword">for</span>Mode:(NSRunLoopMode)mode;
- (void)removeFromRunLoop:(NSRunLoop *)runLoop <span class="hljs-keyword">for</span>Mode:(NSRunLoopMode)mode;

@property (<span class="hljs-built_in">readonly</span>) NSUInteger reservedSpaceLength;	
- (BOOL)sendBeforeDate:(NSDate *)<span class="hljs-built_in">limit</span>Date components:(nullable NSMutableArray *)components from:(nullable NSPort *) receivePort reserved:(NSUInteger)headerSpaceReserved;
- (BOOL)sendBeforeDate:(NSDate *)<span class="hljs-built_in">limit</span>Date msgid:(NSUInteger)msgID components:(nullable NSMutableArray *)components from:(nullable NSPort *)receivePort reserved:(NSUInteger)headerSpaceReserved;

<span class="hljs-comment">#if (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_WIN32)</span>
- (void)addConnection:(NSConnection *)conn toRunLoop:(NSRunLoop *)runLoop <span class="hljs-keyword">for</span>Mode:(NSRunLoopMode)mode NS_SWIFT_UNAVAILABLE(<span class="hljs-string">"Use NSXPCConnection instead"</span>) API_DEPRECATED(<span class="hljs-string">"Use NSXPCConnection instead"</span>, macosx(10.0, 10.13), ios(2.0,11.0), watchos(2.0,4.0), tvos(9.0,11.0));
- (void)removeConnection:(NSConnection *)conn fromRunLoop:(NSRunLoop *)runLoop <span class="hljs-keyword">for</span>Mode:(NSRunLoopMode)mode NS_SWIFT_UNAVAILABLE(<span class="hljs-string">"Use NSXPCConnection instead"</span>) API_DEPRECATED(<span class="hljs-string">"Use NSXPCConnection instead"</span>, macosx(10.0, 10.13), ios(2.0,11.0), watchos(2.0,4.0), tvos(9.0,11.0));

<span class="hljs-comment">#endif</span>

@end
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ul><li>NSMessagePort</li></ul> 
 <pre><code class="hljs bash copyable">@interface NSMessagePort : NSPort {
    @private
    void *_port;
    id _delegate;
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ul><li>NSMachPort</li></ul> 
 <pre><code class="hljs bash copyable">@interface NSMachPort : NSPort {
    @private
    id _delegate;
    NSUInteger _flags;
    uint32_t _machPort;
    NSUInteger _reserved;
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h6 class="heading">❷ 仅macOS支持的类: 在NSPortMessage.h中可找到</h6> 
 <ul><li>NSPortMessage</li></ul> 
 <pre><code class="hljs bash copyable"><span class="hljs-comment">#import &lt;Foundation/NSObject.h&gt;</span>

@class NSPort, NSDate, NSArray, NSMutableArray;

NS_ASSUME_NONNULL_BEGIN

@interface NSPortMessage : NSObject {
    @private
    NSPort 		*<span class="hljs-built_in">local</span>Port;
    NSPort 		*remotePort;
    NSMutableArray 	*components;
    uint32_t		msgid;
    void		*reserved2;
    void		*reserved;
}

- (instancetype)initWithSendPort:(nullable NSPort *)sendPort receivePort:(nullable NSPort *)replyPort components:(nullable NSArray *)components NS_DESIGNATED_INITIALIZER;

@property (nullable, <span class="hljs-built_in">readonly</span>, copy) NSArray *components;
@property (nullable, <span class="hljs-built_in">readonly</span>, retain) NSPort *receivePort;
@property (nullable, <span class="hljs-built_in">readonly</span>, retain) NSPort *sendPort;
- (BOOL)sendBeforeDate:(NSDate *)date;

@property uint32_t msgid;

@end

NS_ASSUME_NONNULL_END
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h5 class="heading">6.2 设置定时源</h5> 
 <h6 class="heading">6.2.1 使用系统Timer</h6> 
 <p>我们的定时器Timer是怎么写的呢？一般的做法是，在主线程（可能是某控制器的viewDidLoad方法）中，创建Timer。</p> 
 <p>可能会有两种写法，但是都有上面的问题，下面先看下Timer的两种写法：</p> 
 <pre><code class="hljs bash copyable">// 第一种写法
NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerUpdate) userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:timer <span class="hljs-keyword">for</span>Mode:NSDefaultRunLoopMode];
[timer fire];

// 第二种写法
[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerUpdate) userInfo:nil repeats:YES];
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>上面的两种写法其实是等价的。第二种写法，默认也是将timer添加到 <strong>NSDefaultRunLoopMode</strong> 下的，并且会自动fire。</p> 
 <blockquote> 
  <p><strong>可能的问题</strong>： 1.我们经常会在应用中看到tableView 的header 上是一个横向ScrollView，一般我们使用NSTimer，每隔几秒切换一张图片。可是当我们滑动tableView的时候，顶部的scollView并不会切换图片，这可怎么办呢？ 2.界面上除了有tableView，还有显示倒计时的Label，当我们在滑动tableView时，倒计时就停止了，这又该怎么办呢？</p> 
 </blockquote> 
 <p>要如何解决这一问题呢？ 解决方法很简单，我们只需要在添加timer 时，将mode 设置为NSRunLoopCommonModes即可。</p> 
 <pre><code class="hljs bash copyable">- (void)timerTest
{
    // 第一种写法
    NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerUpdate) userInfo:nil repeats:YES];
    [[NSRunLoop currentRunLoop] addTimer:timer <span class="hljs-keyword">for</span>Mode:NSRunLoopCommonModes];
    [timer fire];
    // 第二种写法，因为是固定添加到defaultMode中，就不要用了
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>还有一种方案，在子线程中添加Timer，也可以解决上面的问题，但是需要注意的是把timer加入到当前runloop后，必须让runloop 运行起来，否则timer仅执行一次。</p> 
 <pre><code class="hljs bash copyable">//首先是创建一个子线程
- (void)createThread
{
    NSThread *subThread = [[NSThread alloc] initWithTarget:self selector:@selector(timerTest) object:nil];
    [subThread start];
    self.subThread = subThread;
}

// 创建timer，并添加到runloop的mode中
- (void)timerTest
{
    @autoreleasepool {
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        NSLog(@<span class="hljs-string">"启动RunLoop前--%@"</span>,runLoop.currentMode);
        NSLog(@<span class="hljs-string">"currentRunLoop:%@"</span>,[NSRunLoop currentRunLoop]);
        // 第一种写法,改正前
    //    NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerUpdate) userInfo:nil repeats:YES];
    //    [[NSRunLoop currentRunLoop] addTimer:timer <span class="hljs-keyword">for</span>Mode:NSDefaultRunLoopMode];
    //    [timer fire];
        // 第二种写法
        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerUpdate) userInfo:nil repeats:YES];
    
        [[NSRunLoop currentRunLoop] run];
    }
}

//更新label
- (void)timerUpdate
{
    NSLog(@<span class="hljs-string">"当前线程：%@"</span>,[NSThread currentThread]);
    NSLog(@<span class="hljs-string">"启动RunLoop后--%@"</span>,[NSRunLoop currentRunLoop].currentMode);
    NSLog(@<span class="hljs-string">"currentRunLoop:%@"</span>,[NSRunLoop currentRunLoop]);
    dispatch_async(dispatch_get_main_queue(), ^{
        self.count ++;
        NSString *timerText = [NSString stringWithFormat:@<span class="hljs-string">"计时器:%ld"</span>,self.count];
        self.timerLabel.text = timerText;
    });
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>timer确实被添加到NSDefaultRunLoopMode中了。可是添加到子线程中的NSDefaultRunLoopMode里，无论如何滚动，timer都能够很正常的运转。这又是为啥呢？</p> 
 <p>这就是多线程与runloop的关系了，每一个线程都有一个与之关联的RunLoop，而每一个RunLoop可能会有多个Mode。CPU会在多个线程间切换来执行任务，呈现出多个线程同时执行的效果。执行的任务其实就是RunLoop去各个Mode里执行各个item。因为RunLoop是独立的两个，相互不会影响，所以在子线程添加timer，滑动视图时，timer能正常运行。</p> 
 <h6 class="heading">6.2.2 使用自定义Timer</h6> 
 <p>使用下面关键两行即可自定义Timer的事件</p> 
 <pre><code class="hljs bash copyable">CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,
                                                   &amp;myCFTimerCallback, &amp;timerContext);
CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes);
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>下面是一个例子：</p> 
 <pre><code class="hljs bash copyable">-(void)<span class="hljs-built_in">test</span>CustomTimer{
    // 获得当前thread的Run loop
    NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];
    CFRunLoopObserverContext context = {0, (__bridge void *)(self), NULL, NULL, NULL};
    // 创建Run loop observer对象
    // 第一个参数用于分配该observer对象的内存
    // 第二个参数用以设置该observer所要关注的的事件，详见回调函数myRunLoopObserver中注释
    // 第三个参数用于标识该observer是在第一次进入run loop时执行还是每次进入run loop处理时均执行
    // 第四个参数用于设置该observer的优先级
    // 第五个参数用于设置该observer的回调函数
    // 第六个参数用于设置该observer的运行环境
    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities, YES, 0, &amp;myRunLoopObserver, &amp;context);
    <span class="hljs-keyword">if</span> (observer){
        CFRunLoopRef cfLoop = [myRunLoop getCFRunLoop];
        CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);
    }
    
    CFRunLoopRef runLoop = CFRunLoopGetCurrent();
    CFRunLoopTimerContext timerContext = {0, NULL, NULL, NULL, NULL};
    CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,
                                                   &amp;myCFTimerCallback, &amp;timerContext);
    
    CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes);
    NSInteger loopCount = 2;
    <span class="hljs-keyword">do</span>{
        [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];
        loopCount--;
    }<span class="hljs-keyword">while</span> (loopCount);

}

void <span class="hljs-function"><span class="hljs-title">myCFTimerCallback</span></span>(){
    NSLog(@<span class="hljs-string">"-----++++-------"</span>);
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h5 class="heading">6.3 设置监听</h5> 
 <ul><li>添加监听</li></ul> 
 <pre><code class="hljs bash copyable">    // 设置Run Loop observer的运行环境
    CFRunLoopObserverContext context = {0, (__bridge void *)(self), NULL, NULL, NULL};
    // 创建Run loop observer对象
    // 第一个参数用于分配该observer对象的内存
    // 第二个参数用以设置该observer所要关注的的事件，详见回调函数myRunLoopObserver中注释
    // 第三个参数用于标识该observer是在第一次进入run loop时执行还是每次进入run loop处理时均执行
    // 第四个参数用于设置该observer的优先级
    // 第五个参数用于设置该observer的回调函数
    // 第六个参数用于设置该observer的运行环境
    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities, YES, 0, &amp;myRunLoopObserver, &amp;context);
    <span class="hljs-keyword">if</span> (observer){
        CFRunLoopRef cfLoop = [myRunLoop getCFRunLoop];
        CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <ul><li>监听回调</li></ul> 
 <pre><code class="hljs bash copyable">void myRunLoopObserver(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)
{
    switch(activity)
    {
            // 即将进入Loop
        <span class="hljs-keyword">case</span> kCFRunLoopEntry:
            NSLog(@<span class="hljs-string">"run loop entry"</span>);
            <span class="hljs-built_in">break</span>;
        <span class="hljs-keyword">case</span> kCFRunLoopBeforeTimers://即将处理 Timer
            NSLog(@<span class="hljs-string">"run loop before timers"</span>);
            <span class="hljs-built_in">break</span>;
        <span class="hljs-keyword">case</span> kCFRunLoopBeforeSources://即将处理 Source
            NSLog(@<span class="hljs-string">"run loop before sources"</span>);
            <span class="hljs-built_in">break</span>;
        <span class="hljs-keyword">case</span> kCFRunLoopBeforeWaiting://即将进入休眠
            NSLog(@<span class="hljs-string">"run loop before waiting"</span>);
            <span class="hljs-built_in">break</span>;
        <span class="hljs-keyword">case</span> kCFRunLoopAfterWaiting://刚从休眠中唤醒
            NSLog(@<span class="hljs-string">"run loop after waiting"</span>);
            <span class="hljs-built_in">break</span>;
        <span class="hljs-keyword">case</span> kCFRunLoopExit://即将退出Loop
            NSLog(@<span class="hljs-string">"run loop exit"</span>);
            <span class="hljs-built_in">break</span>;
        default:
            <span class="hljs-built_in">break</span>;
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading">7. 总结：Runloop与三个类的关系</h3> 
 <h5 class="heading">7.1 CoreFoudation</h5> 
 <p>对于三种mode，添加到runloop的API分别如下：</p> 
 <pre><code class="hljs bash copyable">CF_EXPORT Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef <span class="hljs-built_in">source</span>, CFRunLoopMode mode);
CF_EXPORT void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef <span class="hljs-built_in">source</span>, CFRunLoopMode mode);
CF_EXPORT void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef <span class="hljs-built_in">source</span>, CFRunLoopMode mode);

CF_EXPORT Boolean CFRunLoopContainsObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode);
CF_EXPORT void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode);
CF_EXPORT void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode);

CF_EXPORT Boolean CFRunLoopContainsTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode);
CF_EXPORT void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode);
CF_EXPORT void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode);
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h5 class="heading">7.2 Foundation</h5> 
 <p>对于 <strong>端口输入源</strong> 和 <strong>定时源</strong> 的mode，添加到NSRunloop的API分别如下：</p> 
 <pre><code class="hljs bash copyable">- (CFRunLoopRef)getCFRunLoop CF_RETURNS_NOT_RETAINED;

- (void)addTimer:(NSTimer *)timer <span class="hljs-keyword">for</span>Mode:(NSRunLoopMode)mode;

- (void)addPort:(NSPort *)aPort <span class="hljs-keyword">for</span>Mode:(NSRunLoopMode)mode;
- (void)removePort:(NSPort *)aPort <span class="hljs-keyword">for</span>Mode:(NSRunLoopMode)mode;

- (nullable NSDate *)<span class="hljs-built_in">limit</span>DateForMode:(NSRunLoopMode)mode;
- (void)acceptInputForMode:(NSRunLoopMode)mode beforeDate:(NSDate *)<span class="hljs-built_in">limit</span>Date;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>还有一种，对于NSTimer，有一个特别的API，这个API会默认把Timer加到 <strong>当前线程</strong> 中去。</p> 
 <pre><code class="hljs bash copyable">[NSTimer scheduledTimerWithTimeInterval:5.1 target:self selector:@selector(<span class="hljs-built_in">print</span>Message:) userInfo:nil repeats:YES];
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>所以说，当且仅当加到<strong>当前线程</strong>，下面两个添加NSTimer的方案方可等效：</p> 
 <pre><code class="hljs bash copyable">- (void)defalutTimer {
    [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(<span class="hljs-keyword">do</span>Time) userInfo:nil repeats:YES];
}

- (void)commonTimer {
    NSTimer *timer =[NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(<span class="hljs-keyword">do</span>Time) userInfo:nil repeats:YES];
    [[NSRunLoop currentRunLoop] addTimer:timer <span class="hljs-keyword">for</span>Mode:NSRunLoopCommonModes];
}
<span class="copy-code-btn">复制代码</span></code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cfe48a394c6237f32aaf01ed02669433/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">思维导图总结python数据类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eaa9a506b2a32fb8493186a92a7517e7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">charles连接不上手机(windows )</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>