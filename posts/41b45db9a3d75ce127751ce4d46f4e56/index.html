<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】常见习题练习 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java】常见习题练习" />
<meta property="og:description" content="Java 基础题目 1、Java语言特点 简单易学（Java语言和C语言和C&#43;&#43;语言很接近）面向对象（封装 继承 多态）平台无关性（Java虚拟机实现了平台无关性）支持网络编程（Java语言诞生就是为了简化网络编程设计的）支持多线程解释与编译共存的语言 2、JVM、 JDK 和 JRE JVM是运行java字节码的虚拟机。不同的平台有自己的虚拟机，因此java语言可以实现跨平台。JDK即Java Development Kit，是供Java开发人员使用的，其中有Java的开发工具，比如编译工具javac.exe，打包工具jar.exe，同时包含了jreJRE即Java Runtime Enviroment，是java的运行时环境，包括了jvm、java类库、java命令和其他的一些基础构件。 3、JAVA和C&#43;&#43;的区别？ 都是面向对象语言，支持封装继承多态。
java提供指针来直接访问内存，程序内存更加安全。java的类是单继承的，c&#43;&#43;放支持多继承，但java的接口可以多继承java它有自动内存管理垃圾回收机制GC。c语言中，字符串和数组最后都会有一个额外的字符’\0’来表示结束。 4、java语言编译与解释并存 java程序要先经过编译，后解释两个步骤，有java编写的程序需要先经过编译步骤，生成字节码文件，这种字节码必须由java解释器来执行。编译型语言指编译器将源代码一次性的翻译成可被特定平台执行的机器码。解释型语言指解释器将源代码逐行解释成可被特定平台执行的机器码并立即执行。 5、continue、break 和return的区别 在循环结构中，当发生了某种条件后提前终止循环。这时候就要用到这几个关键字：
continue：跳出当前的这一次循环，继续下一次循环。break:跳出整体的循环体，继续执行循环下面的语句。return：结束方法的运行。 6、java有哪些基本数据类型 基本数据类型：
数值型：byte(1个字节，默认值0) ，short(2个字节，默认值0) ， int(4个字节，默认值0) ， long(8个字节，默认值0L) ，float(4个字节，默认值0.0F) ，double(8个字节，默认值0.0D)字符型：char（2个字节，默认值’\u0000’）布尔型：boolean(1个字节，默认值false)
引用数据类型：类class接口interface数组[] 7、方法的返回值以及返回值在类的方法里的作用 方法的返回值就是获取到的某个方法体中代码执行后产生的结果。返回值的作用就是接收结果，使得它可以用于其他的操作。 8、面向对象和面向过程 面向对象主要是把事务给对象化，包括它的属性和行为。面向对象编程更贴近实际生活的思想。总体来说面向对象的底层还是面向过程，面向过程抽象成类，然后封装，方便使用就是面向对象。面向过程就是分析出解决问题的步骤，然后用函数把这些步骤一步一步实现，使用时候一次调用即可。 9、面向过程和面向对象的区别 面向过程：面向过程的性能比面向对象高。因为类调用时需要实例化，开销较大消耗资源，所以以性能为主要考虑因素时一般采用面向过程开发，比如单片机，嵌入式开发，Linux等。面向对象：面向对象易于维护，易复用，易扩展。因为面向对象有封装继承多态的特性，所以可以设计出低耦合的系统。 10、 &amp;和&amp;&amp; 的区别 相同点：&amp;和&amp;&amp;都可以用作逻辑与的运算符（and）不同点：
&amp;&amp; 具有短路与的功能。当 &amp; 运算符两边的表达式都为true时，整个运算结果才为true。而 &amp;&amp; 运算符，第一个表达式为false时，结果直接为false，不再进行第二个表达式。
&amp; 还可以做按位与运算符。 11、标识符和关键字的区别 标识符就是我们在写程序的时候为类，变量和方法取的名字。
但有一些标识符，被赋予了特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。
常见的关键字有：
关键字和保留字
12、数学库类中的常见算法 ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；floor的英文是地板，该方法就表示向下取整，Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；round方法表示四舍五入，算法为Math.floor(x&#43;0.5),即将原来的数字加上0.5后再向下取整，所以Math.round(11.5)的结果是12，Math.round(-11.5)的结果为-11. 编程练习 首先复习一下语法基础，再进行编程练习
统计位数为偶数的数字
给你一个整数数组 nums，请你返回其中位数为偶数的数字的个数。
示例 1：
输入：nums = [12,345,2,6,7896] 输出：2 解释： 12 是 2 位数字（位数为偶数） 345 是 3 位数字（位数为奇数） 2 是 1 位数字（位数为奇数） 6 是 1 位数字 位数为奇数） 7896 是 4 位数字（位数为偶数） 因此只有 12 和 7896 是位数为偶数的数字 示例 2：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/41b45db9a3d75ce127751ce4d46f4e56/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-11T19:41:53+08:00" />
<meta property="article:modified_time" content="2022-07-11T19:41:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】常见习题练习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Java__0"></a>Java 基础题目</h2> 
<h5><a id="1Java_1"></a>1、Java语言特点</h5> 
<ul><li>简单易学（Java语言和C语言和C++语言很接近）</li><li>面向对象（封装 继承 多态）</li><li>平台无关性（Java虚拟机实现了平台无关性）</li><li>支持网络编程（Java语言诞生就是为了简化网络编程设计的）</li><li>支持多线程</li><li>解释与编译共存的语言</li></ul> 
<h5><a id="2JVM_JDK__JRE_8"></a>2、JVM、 JDK 和 JRE</h5> 
<ul><li>JVM是运行java字节码的虚拟机。不同的平台有自己的虚拟机，因此java语言可以实现跨平台。</li><li>JDK即Java Development Kit，是供Java开发人员使用的，其中有Java的开发工具，比如编译工具javac.exe，打包工具jar.exe，同时包含了jre</li><li>JRE即Java Runtime Enviroment，是java的运行时环境，包括了jvm、java类库、java命令和其他的一些基础构件。</li></ul> 
<h5><a id="3JAVAC_12"></a>3、JAVA和C++的区别？</h5> 
<p>都是面向对象语言，支持封装继承多态。</p> 
<ul><li>java提供指针来直接访问内存，程序内存更加安全。</li><li>java的类是单继承的，c++放支持多继承，但java的接口可以多继承</li><li>java它有自动内存管理垃圾回收机制GC。</li><li>c语言中，字符串和数组最后都会有一个额外的字符’\0’来表示结束。</li></ul> 
<h5><a id="4java_18"></a>4、java语言编译与解释并存</h5> 
<ul><li>java程序要先经过编译，后解释两个步骤，有java编写的程序需要先经过编译步骤，生成字节码文件，这种字节码必须由java解释器来执行。</li><li>编译型语言指编译器将源代码一次性的翻译成可被特定平台执行的机器码。</li><li>解释型语言指解释器将源代码逐行解释成可被特定平台执行的机器码并立即执行。</li></ul> 
<h5><a id="5continuebreak_return_22"></a>5、continue、break 和return的区别</h5> 
<p>在循环结构中，当发生了某种条件后提前终止循环。这时候就要用到这几个关键字：</p> 
<ul><li>continue：跳出当前的这一次循环，继续下一次循环。</li><li>break:跳出整体的循环体，继续执行循环下面的语句。</li><li>return：结束方法的运行。</li></ul> 
<h5><a id="6java_27"></a>6、java有哪些基本数据类型</h5> 
<p>基本数据类型：</p> 
<ul><li>数值型：byte(1个字节，默认值0) ，short(2个字节，默认值0) ， int(4个字节，默认值0) ， long(8个字节，默认值0L) ，float(4个字节，默认值0.0F) ，double(8个字节，默认值0.0D)</li><li>字符型：char（2个字节，默认值’\u0000’）</li><li>布尔型：boolean(1个字节，默认值false)<br> 引用数据类型：</li><li>类class</li><li>接口interface</li><li>数组[]</li></ul> 
<h5><a id="7_36"></a>7、方法的返回值以及返回值在类的方法里的作用</h5> 
<ul><li>方法的返回值就是获取到的某个方法体中代码执行后产生的结果。</li><li>返回值的作用就是接收结果，使得它可以用于其他的操作。</li></ul> 
<h5><a id="8_39"></a>8、面向对象和面向过程</h5> 
<ul><li>面向对象主要是把事务给对象化，包括它的属性和行为。面向对象编程更贴近实际生活的思想。总体来说面向对象的底层还是面向过程，面向过程抽象成类，然后封装，方便使用就是面向对象。</li><li>面向过程就是分析出解决问题的步骤，然后用函数把这些步骤一步一步实现，使用时候一次调用即可。</li></ul> 
<h5><a id="9_42"></a>9、面向过程和面向对象的区别</h5> 
<ul><li>面向过程：面向过程的性能比面向对象高。因为类调用时需要实例化，开销较大消耗资源，所以以性能为主要考虑因素时一般采用面向过程开发，比如单片机，嵌入式开发，Linux等。</li><li>面向对象：面向对象易于维护，易复用，易扩展。因为面向对象有封装继承多态的特性，所以可以设计出低耦合的系统。</li></ul> 
<h5><a id="10___45"></a>10、 &amp;和&amp;&amp; 的区别</h5> 
<ul><li>相同点：&amp;和&amp;&amp;都可以用作逻辑与的运算符（and）</li><li>不同点：<br> &amp;&amp; 具有短路与的功能。当 &amp; 运算符两边的表达式都为true时，整个运算结果才为true。而 &amp;&amp; 运算符，第一个表达式为false时，结果直接为false，不再进行第二个表达式。<br> &amp; 还可以做按位与运算符。</li></ul> 
<h5><a id="11_50"></a>11、标识符和关键字的区别</h5> 
<p>标识符就是我们在写程序的时候为类，变量和方法取的名字。<br> 但有一些标识符，被赋予了特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。<br> 常见的关键字有：<br> 关键字和保留字</p> 
<h5><a id="12_55"></a>12、数学库类中的常见算法</h5> 
<ul><li>ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；</li><li>floor的英文是地板，该方法就表示向下取整，Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；</li><li>round方法表示四舍五入，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整，所以</li><li>Math.round(11.5)的结果是12，Math.round(-11.5)的结果为-11.</li></ul> 
<h3><a id="_61"></a>编程练习</h3> 
<p>首先复习一下语法基础，再进行编程练习<br> 统计位数为偶数的数字<br> 给你一个整数数组 nums，请你返回其中位数为偶数的数字的个数。<br> 示例 1：</p> 
<pre><code>输入：nums = [12,345,2,6,7896]
输出：2
解释：
12 是 2 位数字（位数为偶数）
345 是 3 位数字（位数为奇数）
2 是 1 位数字（位数为奇数）
6 是 1 位数字 位数为奇数）
7896 是 4 位数字（位数为偶数）
因此只有 12 和 7896 是位数为偶数的数字
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：nums = [555,901,482,1771]
输出：1
解释：
只有 1771 是位数为偶数的数字。
</code></pre> 
<p>提示：</p> 
<pre><code>1 &lt;= nums.length &lt;= 500
1 &lt;= nums[i] &lt;= 10^5
</code></pre> 
<h5><a id="_89"></a>两数之和</h5> 
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返<br> 回他们的数组下标。<br> 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br> 示例:</p> 
<pre><code>给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]
</code></pre> 
<h5><a id="_98"></a>寻找两个正序数组的中位数</h5> 
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求<br> 算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。<br> 示例 1:</p> 
<pre><code>nums1 = [1, 3]
nums2 = [2]
则中位数是 2.0
</code></pre> 
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]
则中位数是 (2 + 3)/2 = 2.5
</code></pre> 
<h5><a id="_113"></a>原地删除重复元素</h5> 
<p>给你一个有序数组 nums ，请你原地删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组<br> 的新长度。不要使用额外的数组空间，你必须在原地修改输入数组，并在使用 O(1) 额外空间的条件下完<br> 成。<br> 示例 1：</p> 
<pre><code>输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组
中超出新长度后面的元素。
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不
需要考虑数组中超出新长度后面的元素。
</code></pre> 
<h5><a id="_132"></a>移除元素</h5> 
<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长<br> 度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素<br> 的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br> 示例 1:</p> 
<pre><code>给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
</code></pre> 
<p>示例 2:</p> 
<pre><code>给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。
你不需要考虑数组中超出新长度后面的元素。
</code></pre> 
<h5><a id="_149"></a>搜索插入位置</h5> 
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，<br> 返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。<br> 示例 1:</p> 
<pre><code>输入: [1,3,5,6], 5
输出: 2
</code></pre> 
<p>示例 2:</p> 
<pre><code>输入: [1,3,5,6], 2
输出: 1
</code></pre> 
<p>示例 3:</p> 
<pre><code>输入: [1,3,5,6], 7
输出: 4
</code></pre> 
<p>示例 4:</p> 
<pre><code>输入: [1,3,5,6], 0
输出: 0
</code></pre> 
<h5><a id="_172"></a>寻找重复数</h5> 
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个<br> 重复的整数。假设只有一个重复的整数，找出这个重复的数。<br> 示例 1:</p> 
<pre><code>输入: [1,3,4,2,2]
输出: 2
</code></pre> 
<pre><code>输入: [3,1,3,4,2]
输出: 3
</code></pre> 
<p><strong>说明：</strong></p> 
<ul><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 O(1) 的空间。</li><li>时间复杂度小于 O(n2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ul> 
<h5><a id="_190"></a>颜色分类</h5> 
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br> 注意：不能使用代码库中的排序函数来解决这道题。<br> 示例:</p> 
<pre><code>输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
</code></pre> 
<p><strong>进阶：</strong></p> 
<ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。</li><li>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li></ul> 
<h5><a id="_201"></a>买卖股票的最佳时机</h5> 
<p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的<br> 最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易<br> （你必须在再次购买前出售掉之前的股票）。<br> 示例 1:</p> 
<pre><code>输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第2天（股票价格 = 1）的时候买入，在第3天（股票价格 = 5）的时候卖出, 这笔交易所能获
得利润 = 5-1 = 4 。随后在第4天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时
候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</code></pre> 
<p>示例 2:</p> 
<pre><code>输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易
所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为
这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</code></pre> 
<p>示例 3:</p> 
<pre><code>输入: prices = [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre> 
<h5><a id="_228"></a>寻找所有数组中消失的数字</h5> 
<p>给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出<br> 现一次。<br> 找到所有在 [1, n] 范围之间没有出现在数组中的数字。<br> 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额<br> 外空间内。<br> 示例:</p> 
<pre><code>输入:
[4,3,2,7,8,2,3,1]
输出:
[5,6]
</code></pre> 
<h5><a id="_241"></a>最短无序连续子数组</h5> 
<p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都<br> 会变为升序排序。你找到的子数组应是最短的，请输出它的长度。<br> 示例 1:</p> 
<pre><code>输入: [2, 6, 4, 8, 10, 9, 15]
输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
</code></pre> 
<p><strong>说明 :</strong></p> 
<ul><li>输入的数组长度范围在 [1, 10,000]。</li><li>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</li></ul> 
<h5><a id="_253"></a>旋转数组</h5> 
<p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。<br> 示例 1:</p> 
<pre><code>输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
</code></pre> 
<p>示例2：</p> 
<pre><code>输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释:
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
</code></pre> 
<h5><a id="_272"></a>旋转图像</h5> 
<p>给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。<br> 说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋<br> 转图像。<br> 示例 1:</p> 
<pre><code>给定 matrix =
[
[1,2,3],
[4,5,6],
[7,8,9]
],
原地旋转输入矩阵，使其变为:
[
[7,4,1],
[8,5,2],
[9,6,3]
]
</code></pre> 
<p>示例2：</p> 
<pre><code>给定 matrix =
[
[ 5, 1, 9,11],
[ 2, 4, 8,10],
[13, 3, 6, 7],
[15,14,12,16]
],
原地旋转输入矩阵，使其变为:
[
[15,13, 2, 5],
[14, 3, 4, 1],
[12, 6, 8, 9],
[16, 7,10,11]
]
</code></pre> 
<h5><a id="_308"></a>除自身以外数组的乘积</h5> 
<p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中output[i]等于nums中<br> 除 nums[i] 之外其余各元素的乘积。<br> 示例:</p> 
<pre><code>输入: [1,2,3,4]
输出: [24,12,8,6]
</code></pre> 
<p><strong>提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</strong></p> 
<h5><a id="_318"></a>判断能否形成等差数列</h5> 
<p>给你一个数字数组 arr。如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为<br> 等差数列 。如果可以重新排列数组形成等差数列，请返回 true ；否则，返回 false 。<br> 示例 1：</p> 
<pre><code>输入：arr = [3,5,1]
输出：true
解释：对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形
成等差数列。
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：arr = [1,2,4]
输出：false
解释：无法通过重新排序得到等差数列。
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li>2 &lt;= arr.length &lt;= 1000</li><li>-10^6 &lt;= arr[i] &lt;= 10^6</li></ul> 
<h5><a id="_337"></a>合并区间</h5> 
<p>给出一个区间的集合，请合并所有重叠的区间。<br> 示例 1:</p> 
<pre><code>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
</code></pre> 
<pre><code>输入: intervals = [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
</code></pre> 
<pre><code>提示： intervals[i][0] &lt;= intervals[i][1]
</code></pre> 
<h5><a id="_354"></a>进阶</h5> 
<p>100 ~ 50000之间有多少整数，其各位数字之和为5，分别是哪些数（例如整数1324的各位数字之和为 1+3+2+4 等于10（不为5）），并统计满足条件的整数有多少个</p> 
<pre><code>public class Test1 {
	//100 ~ 50000之间有多少整数，其各位数字之和为5，分别是哪些数（例如整数1324的各位数字之和为 1+3+2+4 等于10（不为5）），并统计满足条件的整数有多少个
	public static void main(String[] args) {
		int cc=0;
		for(int i=100;i&lt;=50000;i++) {
			//处理3位数
			if(i&gt;=100 &amp;&amp; i&lt;1000) {
				int l1=i/100;
				int l2=i%10;
				int l3=i/10%10;
				if(l1+l2+l3==5) {
					cc++;
					System.out.println(i);
				}
			}
			if(i&gt;=1000 &amp;&amp; i&lt;=10000) {
				int l1=i/1000;
				int l2=i%10;
				//1234   1  4
				int l3=i/100%10;
				int l4=i/10%10;
				if(l1+l2+l3+l4==5) {
					cc++;
					System.out.println(i);
				}
			}
			if(i&gt;=10000) {
				int l1=i/10000;
			}
		}
		System.out.println("滿足條件的數據個數為"+cc);
	}
//未尽事宜：1、是否有办法将相同的代码抽离出来，2、是否可以直接求数据，而不使用遍历所有数据的方法
}
</code></pre> 
<h5><a id="_392"></a>练习题</h5> 
<p>1、计算输入数据的阶乘值</p> 
<pre><code>System.out.println("请输入整数:");
Scanner sc=new Scanner(System.in);
int kk=sc.nextInt();
int res=1;
for(int k=1;k&lt;=kk;k++){
res*=k;//res=res*k
}
System.out.println(kk+"!="+res);
</code></pre> 
<p>2、互换两个数的值（不允许使用中间变量）</p> 
<ul><li>建立临时变量</li><li>加减运算交换</li><li>位运算方法</li></ul> 
<pre><code>		System.out.println("请输入第一个整数:");
		int num1 = sc.nextInt();
		System.out.println("请输入第二个整数:");
		int num2 = sc.nextInt();
		
		num1=num1+num2;
		num2=num1-num2;
		num1=num1-num2;
		
		System.out.println("交换后的第一个数是"+num1);
		System.out.println("交换后的第二个数是"+num2);
</code></pre> 
<p>3、输出三个数中的最大值和最小值</p> 
<pre><code>System.out.println("请输入第一个整数:");
		int number1= sc.nextInt();
		System.out.println("请输入第二个整数:");
		int number2 = sc.nextInt();
		System.out.println("请输入第三个整数:");
		int number3 = sc.nextInt();
		if(number1&gt;number2) {
			if(number2&gt;number3) {
				System.out.println("最大值："+number1);
				System.out.println("最小值："+number3);
			    }else{	
				System.out.println("最大值："+number1);
				System.out.println("最小值："+number2);
			    }
	        }else if(number1&gt;number3){
			System.out.println("最大值："+number2);
			System.out.println("最小值："+number3);			
		    }else if(number2&gt;number3){
			System.out.println("最大值："+number2);
			System.out.println("最小值："+number1);
			}else{
			System.out.println("最大值："+number3);
			System.out.println("最小值："+number1);
			}			
</code></pre> 
<p>4、输出1-100的奇数(每行输出6个)</p> 
<pre><code> int  j =  0 ;
         for ( int  i= 1 ; i&lt;= 100 ; i++){
             if  (i% 2  !=  0 ) {
                 j++;
                 System.out.print(i+ "  " );
                 if  (j% 6  ==  0 ) {
                 System.out.print( "\n" ); 
                 }
             }
         }
        System.out.print( "\n" ); 
</code></pre> 
<p>5、1-100求和(for while以及do/while的写法)</p> 
<pre><code>int sum = 0;
		//定义变量，来承接
		for (int i = 1; i &lt;= 100; i++) {
		   sum += i;
		 } System.out.println("和为：" + sum);
	 
		//while循环

		 int sum1 = 0;
		 int i = 1;
		 while (i&lt;=100){
		      sum1+=i;
		      i++;
		    }
		System.out.println("1~100的和为："+sum1);
		
		//do while循环
		int ii = 1;
        int sum2 = 0;
        do {
            sum2 += ii;
            ii++;
        } while (i &lt;= 100);
        System.out.println("1~100的和：" + sum2);
</code></pre> 
<p>6、1-100奇数求和</p> 
<pre><code> int  n =  0 ;
        for ( int  m= 1 ; m&lt;= 100 ; m++){
            if  (m% 2  !=  0 ) {
                n++;
           System.out.print(m+ "  " );
            }                
        }
</code></pre> 
<p>7、1~100可以被3整除的数</p> 
<pre><code>public class Test1 {
	public static void main(String[] args) {
		// 输出1-100之间能够被3整除的数,每行输出6个
		int cc = 0;
		for (int i = 1; i &lt; 101; i++) {
			if (i % 3 == 0) {
				System.out.print(i + "\t");
				cc++;
				if(cc%6==0)
					System.out.println();
			}
		}
	}
}
</code></pre> 
<p>8、求100 以内所有能被3 整除但不能被5 整除的个数</p> 
<pre><code>public class Test3 {
	public static void main(String[] args) {
		// 求100 以内所有能被3 整除但不能被5 整除的个数
		int cc = 0;
		int k = 1;
		do {
			if (k % 3 == 0 &amp;&amp; k % 5 != 0) {
				System.out.print(k+"\t");
				cc++;
				if(cc%6==0)
					System.out.println();
			}
		} while (k++ &lt; 100);
		System.out.println("\n1到100之间能够被3整除但是不能被5整除的整数个数为" + cc);
	}
}

</code></pre> 
<p>9、打印出所有的水仙花数</p> 
<pre><code>public class Test4 {
	public static void main(String[] args) {
		// 打印出所有的水仙花数
		// 水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身（例如：1^3 + 5^3+ 3^3 = 153
		for (int i = 100; i &lt; 1000; i++) {
			int gewei = i % 10;// 个位数
			int baiwei = i / 100;// 百位数
			int shiwei = i / 10 % 10;// 十位数
			if (gewei * gewei * gewei + baiwei * baiwei * baiwei + shiwei * shiwei * shiwei == i) {
				System.out.println(i);
			}
		}

	}
}
</code></pre> 
<p>10、判断一个数是否质数</p> 
<pre><code>public class Test5 {
public static void main(String[] args) {
	//判断一个数是否质数
	//质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。
	
	//键盘录入一个整数[自然数]
	int input=0;
	Scanner sc=new Scanner(System.in);
	System.out.println("请输入一个大于1的自然数");
	while(true) {
		input=sc.nextInt();
		if(input&lt;=1)
			System.out.println("输入的数据不合法!");
		else
			break;
	}
	//判断是否有&gt;=2并且&lt;自身的因数
	boolean ziShu=true;
	for(int k=2;k&lt;input;k++) {
		if(input%k==0) {
			ziShu=false;
			break;
		}
	}
	//根据判断结果输出提示信息
	if(ziShu)
		System.out.println(input+"是质数");
	else
		System.out.println(input+"不是质数");
}
}
</code></pre> 
<p>11、编程求出自然数101-205中的所有质数</p> 
<pre><code>public class Test6 {
//编程求出自然数101-205中的所有质数
	public static void main(String[] args) {
		int cc=0;
		for (int i = 101; i &lt;= 205; i++) {
			boolean bb=true;
			for(int k=2;k&lt;i;k++) {
				if(i%k==0) {
					bb=false;
					break;
				}
			}
			if(bb) {
				System.out.print(i+"\t");
				cc++;
				if(cc%6==0)
					System.out.println();
			}
		}
	}
}
</code></pre> 
<p>12、输入两个正整数m和n，求其最大公约数和最小公倍数</p> 
<pre><code> public static void main(String[] args) {
    //输入两个正整数m和n，求其最大公约数和最小公倍数
    int k1=12,k2=18;
    int begin=Math.min(k1, k2);
    for(int i=begin;i&gt;1;i--) {
      if(k1%i==0 &amp;&amp; k2%i==0) {
        System.out.println("最大公约数为"+i);
        break;
      }
    }
    
    begin=Math.max(k1, k2);
    for(int i=begin;i&lt;=k1*k2;i++) {
      if(i%k1==0 &amp;&amp; i%k2==0) {
        System.out.println("最小公倍数为"+i);
        break;
      }
    }
  }
</code></pre> 
<p>13、100 ~ 50000之间有多少整数，其各位数字之和为5，分别是哪些数（例如整数1324的各位数字之<br> 和为 1+3+2+4 等于10（不为5）），并统计满足条件的整数有多少个</p> 
<pre><code>public class Test1 {
	//100 ~ 50000之间有多少整数，其各位数字之和为5，分别是哪些数（例如整数1324的各位数字之和为 1+3+2+4 等于10（不为5）），并统计满足条件的整数有多少个
	public static void main(String[] args) {
		int cc=0;
		for(int i=100;i&lt;=50000;i++) {
			//处理3位数
			if(i&gt;=100 &amp;&amp; i&lt;1000) {
				int l1=i/100;
				int l2=i%10;
				int l3=i/10%10;
				if(l1+l2+l3==5) {
					cc++;
					System.out.println(i);
				}
			}
			if(i&gt;=1000 &amp;&amp; i&lt;=10000) {
				int l1=i/1000;
				int l2=i%10;
				//1234   1  4
				int l3=i/100%10;
				int l4=i/10%10;
				if(l1+l2+l3+l4==5) {
					cc++;
					System.out.println(i);
				}
			}
			if(i&gt;=10000) {
				int l1=i/10000;
			}
		}
		System.out.println("滿足條件的數據個數為"+cc);
	}
//未尽事宜：1、是否有办法将相同的代码抽离出来，2、是否可以直接求数据，而不使用遍历所有数据的方法
}
</code></pre> 
<p>14、鸡兔同笼共80个头，208只脚，鸡和兔各有几只</p> 
<pre><code>public class Test3 {
//鸡兔同笼共80个头，208只脚，鸡和兔各有几只
	public static void main(String[] args) {
//		for(int i=0;i&lt;=80;i++) {  //鸡的数量
//			for(int k=0;k&lt;=80-i;k++) {
//				if(2*i+k*4==208 &amp;&amp; i+k==80) {
//					System.out.println("鸡有"+i+"只，兔子有"+k+"只");
//				}
//			}
//		}
//	}
		//=======================
		for(int i=0;i&lt;=52;i++) {//兔子
			int k=80-i;//鸡
				if(4*i+k*2==208) {
					System.out.println("鸡有"+k+"只，兔子有"+i+"只");
				}
			}
		}
	//理解时间复杂度的概念，使用一定的方法减少循环次数，则可以提高代码的执行效率
	}

</code></pre> 
<p>15、鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何</p> 
<pre><code>public class Test4 {
public static void main(String[] args) {
	for(int i=0;i&lt;=20;i++) {
		for(int k=0;k&lt;34;k++) {
			for(int m=0;m&lt;301;m=m+3) {
				if(i+k+m==100 &amp;&amp; 5*i+3*k+m/3==100) {
					System.out.println("公鸡"+i+"只，母鸡"+k+"只,小鸡"+m+"只");
				}
			}
		}
	}
	//未尽事宜：参照Test3考虑如何减少循环计算次数
}
}

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df4e35004aa150c30e5aadcb87061074/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Java——SpringBoot的洗浴会所管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/72159142466b322a14db6410926f433f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;洛谷题解(32)——P5720</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>