<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 单元测试的 7 个技巧 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 单元测试的 7 个技巧" />
<meta property="og:description" content="测试是开发的一个非常重要的方面，可以在很大程度上决定一个应用程序的命运。良好的测试可以在早期捕获导致应用程序崩溃的问题，但较差的测试往往总是导致故障和停机。 虽然有三种主要类型的软件测试：单元测试，功能测试和集成测试，但是在这篇博文中，我们将讨论开发人员级单元测试。在我深入讲述具体细节之前，让我们先来回顾一下这三种测试的详细内容。
软件开发测试的类型
单元测试用于测试各个代码组件，并确保代码按照预期的方式工作。单元测试由开发人员编写和执行。大多数情况下，使用JUnit或TestNG之类的测试框架。测试用例通常是在方法级别写入并通过自动化执行。
集成测试检查系统是否作为一个整体而工作。集成测试也由开发人员完成，但不是测试单个组件，而是旨在跨组件测试。系统由许多单独的组件组成，如代码，数据库，Web服务器等。集成测试能够发现如组件布线，网络访问，数据库问题等问题。
功能测试通过将给定输入的结果与规范进行比较来检查每个功能是否正确实现。通常，这不是在开发人员级别的。功能测试由单独的测试团队执行。测试用例基于规范编写，并且实际结果与预期结果进行比较。有若干工具可用于自动化的功能测试，如Selenium和QTP。
如前所述，单元测试可帮助开发人员确定代码是否正常工作。在这篇博文中，我将提供在Java中单元测试的有用提示。
1.使用框架来用于单元测试
Java提供了若干用于单元测试的框架。TestNG和JUnit是最流行的测试框架。JUnit和TestNG的一些重要功能：
易于设置和运行。支持注释。允许忽略或分组并一起执行某些测试。支持参数化测试，即通过在运行时指定不同的值来运行单元测试。通过与构建工具，如Ant，Maven和Gradle集成来支持自动化的测试执行。 EasyMock是一个模拟框架，是单元测试框架，如JUnit和TestNG的补充。EasyMock本身不是一个完整的框架。它只是添加了创建模拟对象以便于测试的能力。例如，我们想要测试的一个方法可以调用从数据库获取数据的DAO类。在这种情况下，EasyMock可用于创建返回硬编码数据的MockDAO。这使我们能够轻松地测试我们意向的方法，而不必担心数据库访问。
2.谨慎使用测试驱动开发！
测试驱动开发（TDD）是一个软件开发过程，在这过程中，在开始任何编码之前，我们基于需求来编写测试。由于还没有编码，测试最初会失败。然后写入最小量的代码以通过测试。然后重构代码，直到被优化。
目标是编写覆盖所有需求的测试，而不是一开始就写代码，却可能甚至都不能满足需求。TDD是伟大的，因为它导致简单的模块化代码，且易于维护。总体开发速度加快，容易发现缺陷。此外，单元测试被创建作为TDD方法的副产品。
然而，TDD可能不适合所有的情况。在设计复杂的项目中，专注于最简单的设计以便于通过测试用例，而不提前思考可能会导致巨大的代码更改。此外，TDD方法难以用于与遗留系统，GUI应用程序或与数据库一起工作的应用程序交互的系统。另外，测试需要随着代码的改变而更新。
因此，在决定采用TDD方法之前，应考虑上述因素，并应根据项目的性质采取措施。
3.测量代码覆盖率
代码覆盖率衡量（以百分比表示）了在运行单元测试时执行的代码量。通常，高覆盖率的代码包含未检测到的错误的几率要低，因为其更多的源代码在测试过程中被执行。测量代码覆盖率的一些最佳做法包括：
使用代码覆盖工具，如Clover，Corbetura，JaCoCo或Sonar。使用工具可以提高测试质量，因为这些工具可以指出未经测试的代码区域，让你能够开发开发额外的测试来覆盖这些领域。每当写入新功能时，立即写新的测试覆盖。确保有测试用例覆盖代码的所有分支，即if / else语句。 高代码覆盖不能保证测试是完美的，所以要小心！
下面的 concat 方法接受布尔值作为输入，并且仅当布尔值为true时附加传递两个字符串：
&lt; class=&#34;hljs typescript&#34;&gt;public String concat(boolean append, String a,String b) { String result = null; If (append) { result = a &#43; b; } return result.toLowerCase(); } 以下是上述方法的测试用例：
&lt;class=&#34;hljs less&#34;&gt;@Test public void testStringUtil() { String result = stringUtil.concat(true, &#34;Hello &#34;, &#34;World&#34;); System.out.println(&#34;Result is &#34;&#43;result); } 在这种情况下，执行测试的值为true。当测试执行时，它将通过。当代码覆盖率工具运行时，它将显示100%的代码覆盖率，因为 concat 方法中的所有代码都被执行。但是，如果测试执行的值为false，则将抛出 NullPointerException 。所以100%的代码覆盖率并不真正表明测试覆盖了所有场景，也不能说明测试良好。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e92a0e777a3514d367e73a72eaa8e5ea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-21T09:54:02+08:00" />
<meta property="article:modified_time" content="2023-04-21T09:54:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 单元测试的 7 个技巧</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <table><tbody><tr><td><strong>测试是开发的一个非常重要的方面，可以在很大程度上决定一个应用程序的命运。良好的测试可以在早期捕获导致应用程序崩溃的问题，但较差的测试往往总是导致故障和停机。</strong></td></tr></tbody></table> 
<p>虽然有三种主要类型的软件测试：单元测试，功能测试和集成测试，但是在这篇博文中，我们将讨论开发人员级单元测试。在我深入讲述具体细节之前，让我们先来回顾一下这三种测试的详细内容。</p> 
<p></p> 
<p><strong>软件开发测试的类型</strong></p> 
<p>单元测试用于测试各个代码组件，并确保代码按照预期的方式工作。单元测试由开发人员编写和执行。大多数情况下，使用JUnit或TestNG之类的测试框架。测试用例通常是在方法级别写入并通过自动化执行。</p> 
<p>集成测试检查系统是否作为一个整体而工作。集成测试也由开发人员完成，但不是测试单个组件，而是旨在跨组件测试。系统由许多单独的组件组成，如代码，数据库，Web服务器等。集成测试能够发现如组件布线，网络访问，数据库问题等问题。</p> 
<p>功能测试通过将给定输入的结果与规范进行比较来检查每个功能是否正确实现。通常，这不是在开发人员级别的。功能测试由单独的测试团队执行。测试用例基于规范编写，并且实际结果与预期结果进行比较。有若干工具可用于自动化的功能测试，如Selenium和QTP。</p> 
<p>如前所述，单元测试可帮助开发人员确定代码是否正常工作。在这篇博文中，我将提供在Java中单元测试的有用提示。</p> 
<p><strong>1.使用框架来用于单元测试</strong></p> 
<p>Java提供了若干用于单元测试的框架。TestNG和JUnit是最流行的测试框架。JUnit和TestNG的一些重要功能：</p> 
<ul><li>易于设置和运行。</li><li>支持注释。</li><li>允许忽略或分组并一起执行某些测试。</li><li>支持参数化测试，即通过在运行时指定不同的值来运行单元测试。</li><li>通过与构建工具，如Ant，Maven和Gradle集成来支持自动化的测试执行。</li></ul> 
<p>EasyMock是一个模拟框架，是单元测试框架，如JUnit和TestNG的补充。EasyMock本身不是一个完整的框架。它只是添加了创建模拟对象以便于测试的能力。例如，我们想要测试的一个方法可以调用从数据库获取数据的DAO类。在这种情况下，EasyMock可用于创建返回硬编码数据的MockDAO。这使我们能够轻松地测试我们意向的方法，而不必担心数据库访问。</p> 
<p><strong>2.谨慎使用测试驱动开发！</strong></p> 
<p>测试驱动开发（TDD）是一个软件开发过程，在这过程中，在开始任何编码之前，我们基于需求来编写测试。由于还没有编码，测试最初会失败。然后写入最小量的代码以通过测试。然后重构代码，直到被优化。</p> 
<p>目标是编写覆盖所有需求的测试，而不是一开始就写代码，却可能甚至都不能满足需求。TDD是伟大的，因为它导致简单的模块化代码，且易于维护。总体开发速度加快，容易发现缺陷。此外，单元测试被创建作为TDD方法的副产品。</p> 
<p>然而，TDD可能不适合所有的情况。在设计复杂的项目中，专注于最简单的设计以便于通过测试用例，而不提前思考可能会导致巨大的代码更改。此外，TDD方法难以用于与遗留系统，GUI应用程序或与数据库一起工作的应用程序交互的系统。另外，测试需要随着代码的改变而更新。</p> 
<p>因此，在决定采用TDD方法之前，应考虑上述因素，并应根据项目的性质采取措施。</p> 
<p><strong>3.测量代码覆盖率</strong></p> 
<p>代码覆盖率衡量（以百分比表示）了在运行单元测试时执行的代码量。通常，高覆盖率的代码包含未检测到的错误的几率要低，因为其更多的源代码在测试过程中被执行。测量代码覆盖率的一些最佳做法包括：</p> 
<ul><li>使用代码覆盖工具，如Clover，Corbetura，JaCoCo或Sonar。使用工具可以提高测试质量，因为这些工具可以指出未经测试的代码区域，让你能够开发开发额外的测试来覆盖这些领域。</li><li>每当写入新功能时，立即写新的测试覆盖。</li><li>确保有测试用例覆盖代码的所有分支，即if / else语句。</li></ul> 
<p>高代码覆盖不能保证测试是完美的，所以要小心！</p> 
<p>下面的 concat 方法接受布尔值作为输入，并且仅当布尔值为true时附加传递两个字符串：</p> 
<pre>&lt; class="hljs typescript"&gt;public String concat(boolean append, String a,String b) {
        String result = null;
        If (append) {
            result = a + b;
                            }
        return result.toLowerCase();
}</pre> 
<p>以下是上述方法的测试用例：</p> 
<pre>&lt;class="hljs less"&gt;@Test
public void testStringUtil() {
     String result = stringUtil.concat(true, "Hello ", "World");
     System.out.println("Result is "+result);
}</pre> 
<p>在这种情况下，执行测试的值为true。当测试执行时，它将通过。当代码覆盖率工具运行时，它将显示100%的代码覆盖率，因为 concat 方法中的所有代码都被执行。但是，如果测试执行的值为false，则将抛出 NullPointerException 。所以100%的代码覆盖率并不真正表明测试覆盖了所有场景，也不能说明测试良好。</p> 
<p><strong>4.尽可能将测试数据外部化</strong></p> 
<p>在JUnit4之前，测试用例要运行的数据必须硬编码到测试用例中。这导致了限制，为了使用不同的数据运行测试，测试用例代码必须修改。但是，JUnit4以及TestNG支持外部化测试数据，以便可以针对不同的数据集运行测试用例，而无需更改源代码。</p> 
<p>下面的 MathChecker 类有方法可以检查一个数字是否是奇数：</p> 
<pre>&lt; class="hljs kotlin"&gt;public class MathChecker {
        public Boolean isOdd(int n) {
            if (n%2 != 0) {
                return true;
            } else {
                return false;
            }
        }
    }</pre> 
<p>以下是MathChecker类的TestNG测试用例：</p> 
<pre>&lt; class="hljs less"&gt;public class MathCheckerTest {
        private MathChecker checker;
        @BeforeMethod
        public void beforeMethod() {
          checker = new MathChecker();
        }
        @Test
        @Parameters("num")
        public void isOdd(int num) { 
          System.out.println("Running test for "+num);
          Boolean result = checker.isOdd(num);
          Assert.assertEquals(result, new Boolean(true));
        }
    }</pre> 
<p><strong>TestNG</strong></p> 
<p>以下是testng.xml（用于TestNG的配置文件），它具有要为其执行测试的数据：</p> 
<pre>&lt; class="hljs xml"&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;suite name="ParameterExampleSuite" parallel="false"&gt;
    &lt;test name="MathCheckerTest"&gt;
    &lt;classes&gt;
      &lt;parameter name="num" value="3"&gt;&lt;/parameter&gt;
      &lt;class name="com.stormpath.demo.MathCheckerTest"/&gt;
    &lt;/classes&gt;
     &lt;/test&gt;
     &lt;test name="MathCheckerTest1"&gt;
    &lt;classes&gt;
      &lt;parameter name="num" value="7"&gt;&lt;/parameter&gt;
      &lt;class name="com.stormpath.demo.MathCheckerTest"/&gt;
    &lt;/classes&gt;
     &lt;/test&gt;
    &lt;/suite&gt;</pre> 
<p>可以看出，在这种情况下，测试将执行两次，值3和7各一次。除了通过XML配置文件指定测试数据之外，还可以通过DataProvider注释在类中提供测试数据。</p> 
<p><strong>JUnit</strong></p> 
<p>与TestNG类似，测试数据也可以外部化用于JUnit。以下是与上述相同MathChecker类的JUnit测试用例：</p> 
<pre>&lt; class="hljs java"&gt;@RunWith(Parameterized.class)
    public class MathCheckerTest {
     private int inputNumber;
     private Boolean expected;
     private MathChecker mathChecker;
     @Before
     public void setup(){
         mathChecker = new MathChecker();
     }
        // Inject via constructor
        public MathCheckerTest(int inputNumber, Boolean expected) {
            this.inputNumber = inputNumber;
            this.expected = expected;
        }
        @Parameterized.Parameters
        public static Collection&lt;Object[]&gt; getTestData() {
            return Arrays.asList(new Object[][]{
                    {1, true},
                    {2, false},
                    {3, true},
                    {4, false},
                    {5, true}
            });
        }
        @Test
        public void testisOdd() {
            System.out.println("Running test for:"+inputNumber);
            assertEquals(mathChecker.isOdd(inputNumber), expected);
        }
    }</pre> 
<p>可以看出，要对其执行测试的测试数据由getTestData（）方法指定。此方法可以轻松地修改为从外部文件读取数据，而不是硬编码数据。</p> 
<p><strong>5.使用断言而不是Print语句</strong></p> 
<p>许多新手开发人员习惯于在每行代码之后编写System.out.println语句来验证代码是否正确执行。这种做法常常扩展到单元测试，从而导致测试代码变得杂乱。除了混乱，这需要开发人员手动干预去验证控制台上打印的输出，以检查测试是否成功运行。更好的方法是使用自动指示测试结果的断言。</p> 
<p>下面的 StringUti 类是一个简单类，有一个连接两个输入字符串并返回结果的方法：</p> 
<pre>&lt; class="hljs typescript"&gt;public class StringUtil {
        public String concat(String a,String b) {
            return a + b;
        }
    }</pre> 
<p>以下是上述方法的两个单元测试：</p> 
<pre>&lt; class="hljs less"&gt;@Test
    public void testStringUtil_Bad() {
         String result = stringUtil.concat("Hello ", "World");
         System.out.println("Result is "+result);
    }
    @Test
    public void testStringUtil_Good() {
         String result = stringUtil.concat("Hello ", "World");
         assertEquals("Hello World", result);
    }</pre> 
<p>testStringUtil\_Bad将始终传递，因为它没有断言。开发人员需要手动地在控制台验证测试的输出。如果方法返回错误的结果并且不需要开发人员干预，则testStringUtil\_Good将失败。</p> 
<p><strong>6.构建具有确定性结果的测试</strong></p> 
<p>一些方法不具有确定性结果，即该方法的输出不是预先知道的，并且每一次都可以改变。例如，考虑以下代码，它有一个复杂的函数和一个计算执行复杂函数所需时间（以毫秒为单位）的方法：</p> 
<pre>&lt; class="hljs java"&gt;public class DemoLogic {
    private void veryComplexFunction(){
        //This is a complex function that has a lot of database access and is time consuming
        //To demo this method, I am going to add a Thread.sleep for a random number of milliseconds
        try {
            int time = (int) (Math.random()*100);
            Thread.sleep(time);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
    public long calculateTime(){
        long time = 0;
        long before = System.currentTimeMillis();
        veryComplexFunction();
        long after = System.currentTimeMillis();
        time = after - before;
        return time;
    }
    }0</pre> 
<p>在这种情况下，每次执行 calculateTime 方法时，它将返回一个不同的值。为该方法编写测试用例不会有任何用处，因为该方法的输出是可变的。因此，测试方法将不能验证任何特定执行的输出。</p> 
<p><strong>7.除了正面情景外，还要测试负面情景和边缘情况</strong></p> 
<p>通常，开发人员会花费大量的时间和精力编写测试用例，以确保应用程序按预期工作。然而，测试负面测试用例也很重要。负面测试用例指的是测试系统是否可以处理无效数据的测试用例。例如，考虑一个简单的函数，它能读取长度为8的字母数字值，由用户键入。除了字母数字值，应测试以下负面测试用例：</p> 
<ul><li>用户指定非字母数字值，如特殊字符。</li><li>用户指定空值。</li><li>用户指定大于或小于8个字符的值。</li></ul> 
<p>类似地，边界测试用例测试系统是否适用于极端值。例如，如果用户希望输入从1到100的数字值，则1和100是边界值，对这些值进行测试系统是非常重要的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7f0429a6aea4d73e7bcaca2139bd27f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows上传文件报错（Django）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/75d10a9c80f7cc60816c1a4f6b15bf8f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Scratch （从零开始）- 介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>