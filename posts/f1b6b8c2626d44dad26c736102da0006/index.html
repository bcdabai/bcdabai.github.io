<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【网络教程】Iptables官方教程-学习笔记6-IPTABLES TARGETS - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【网络教程】Iptables官方教程-学习笔记6-IPTABLES TARGETS" />
<meta property="og:description" content="一、IPTABLES TAGRETS 本章节介绍Iptables 的目标和跳转(targets and jumps)，目标和跳转负责告诉规则如何处理与规则匹配部分完全匹配的包。“ACCEPT”和“DROP”是一对基础目标，他们是首先处理的。在学习目标是如何完成之前，我们先看下跳转是如何完成的。
跳转跟目标类似，但是跳转是在同一个表的链之间进行跳转。要跳转到一个特定的链，前提是该链已存在。通过“-N”命令创建一个用户定义的链，如下所示：
iptables -N tcp_packets 设置一个跳转目标如下所示：
iptables -A INPUT -p tcp -j tcp_packets 表示我们将从INPUT链跳转到tcp_packets链，并开始遍历tcp_packets链。当我们到达该tcp_packets链的末端，我们就会回到INPUT链，数据包开始从它跳转到另一个链(tcp_packets),按接下来的规则进行遍历。如果一个数据包在一个子链中被接受，它将在超集链中也被接受，并且它将不再遍历任何超集链。但是，请注意，包将以正常方式遍历其他表中的所有其他链。更多信息参考： Traversing of tables and chains【网络教程】IPtables官方教程–学习笔记3 目标(targets)是指要对有问题的包采取的操作。例如，基于我们的需求，我们可以接受或丢弃数据包。跳转到目标的操作可能会导致不同的结果，某些目标可以将导致包停止遍历上面所述的特定链和上级链，比如DROP和ACCEPT。被停止的规则将不会在链中或更高级的链中通过接下来的任一规则。其他目标可能对数据包采取行动，之后数据包将继续通过其余的规则。一个很好的例子是LOG、ULOG和TOS目标。这些目标可以记录数据包，破坏它们，然后将它们传递给同一组链中的其他规则。例如，我们可能希望这样做，以便我们还可以同时破坏特定包/流的TTL和TOS值。一些目标将接受额外的选项(使用什么TOS值等)，而其他目标不一定需要任何选项——但如果我们愿意，我们可以包括它们(日志前缀，伪装到端口等)。
下面就让我们来看看有IPTABLES有哪些目标。
1.1 ACCEPT target 这个目标不需要更多的选项。一旦完全满足数据包的匹配规范，并且指定ACCEPT为目标，则接受该规则，并且不再继续遍历当前链或同一表中的任何其他链。但是请注意，在一个链中接受的数据包仍然可能通过其他表中的链传输，并且仍然可能被丢弃。ACCEPT目标没有任何特别之处，它不需要也不可能向目标添加选项。要使用这个目标，只需指定-j ACCEPT。
注意：适配于Linux 内核2.3, 2.4, 2.5, 2.6
1.2 CLASSIFY target 分类目标可以被用于分类包的方式，可以被一对不同的qdisc(queue disciplines)使用。例如，atm、cbq、dsmark、pfifo_fast、htb和prio qdisc。更多请参考： Linux Advanced Routing and Traffic Control HOW-TO
分类目标仅在mangle表的POSTROUTING 链中有效
Option–set-classExampleiptables -t mangle -A POSTROUTING -p tcp --dport 80 -j CLASSIFY --set-class 20:10ExplanationThe CLASSIFY target only takes one argument, the --set-class." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f1b6b8c2626d44dad26c736102da0006/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-02T23:50:55+08:00" />
<meta property="article:modified_time" content="2022-12-02T23:50:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【网络教程】Iptables官方教程-学习笔记6-IPTABLES TARGETS</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="IPTABLES_TAGRETS_0"></a>一、IPTABLES TAGRETS</h2> 
<p>本章节介绍Iptables 的目标和跳转(targets and jumps)，目标和跳转负责告诉规则如何处理与规则匹配部分完全匹配的包。“ACCEPT”和“DROP”是一对基础目标，他们是首先处理的。在学习目标是如何完成之前，我们先看下跳转是如何完成的。</p> 
<p>跳转跟目标类似，但是跳转是在同一个表的链之间进行跳转。要跳转到一个特定的链，前提是该链已存在。通过“-N”命令创建一个用户定义的链，如下所示：</p> 
<pre><code class="prism language-shell">iptables <span class="token parameter variable">-N</span> tcp_packets
</code></pre> 
<p>设置一个跳转目标如下所示：</p> 
<pre><code class="prism language-powershell">iptables <span class="token operator">-</span>A INPUT <span class="token operator">-</span>p tcp <span class="token operator">-</span>j tcp_packets
</code></pre> 
<p>表示我们将从INPUT链跳转到tcp_packets链，并开始遍历tcp_packets链。当我们到达该tcp_packets链的末端，我们就会回到INPUT链，数据包开始从它跳转到另一个链(tcp_packets),按接下来的规则进行遍历。如果一个数据包在一个子链中被接受，它将在超集链中也被接受，并且它将不再遍历任何超集链。但是，请注意，包将以正常方式遍历其他表中的所有其他链。更多信息参考：<a href="https://blog.csdn.net/jackhh1/article/details/125952077?spm=1001.2014.3001.5501"> Traversing of tables and chains【网络教程】IPtables官方教程–学习笔记3 </a></p> 
<p>目标(targets)是指要对有问题的包采取的操作。例如，基于我们的需求，我们可以接受或丢弃数据包。跳转到目标的操作可能会导致不同的结果，某些目标可以将导致包停止遍历上面所述的特定链和上级链，比如DROP和ACCEPT。被停止的规则将不会在链中或更高级的链中通过接下来的任一规则。其他目标可能对数据包采取行动，之后数据包将继续通过其余的规则。一个很好的例子是LOG、ULOG和TOS目标。这些目标可以记录数据包，破坏它们，然后将它们传递给同一组链中的其他规则。例如，我们可能希望这样做，以便我们还可以同时破坏特定包/流的TTL和TOS值。一些目标将接受额外的选项(使用什么TOS值等)，而其他目标不一定需要任何选项——但如果我们愿意，我们可以包括它们(日志前缀，伪装到端口等)。</p> 
<p>下面就让我们来看看有IPTABLES有哪些目标。</p> 
<h3><a id="11_ACCEPT_target_19"></a>1.1 ACCEPT target</h3> 
<p>这个目标不需要更多的选项。一旦完全满足数据包的匹配规范，并且指定ACCEPT为目标，则接受该规则，并且不再继续遍历当前链或同一表中的任何其他链。但是请注意，在一个链中接受的数据包仍然可能通过其他表中的链传输，并且仍然可能被丢弃。ACCEPT目标没有任何特别之处，它不需要也不可能向目标添加选项。要使用这个目标，只需指定-j ACCEPT。</p> 
<p><strong>注意：适配于Linux 内核2.3, 2.4, 2.5, 2.6</strong></p> 
<h3><a id="12_CLASSIFY_target_24"></a>1.2 CLASSIFY target</h3> 
<p>分类目标可以被用于分类包的方式，可以被一对不同的qdisc(queue disciplines)使用。例如，atm、cbq、dsmark、pfifo_fast、htb和prio qdisc。更多请参考：<a href="https://www.lartc.org/" rel="nofollow"> Linux Advanced Routing and Traffic Control HOW-TO</a></p> 
<p>分类目标仅在mangle表的POSTROUTING 链中有效</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–set-class</td></tr><tr><td>Example</td><td>iptables -t mangle -A POSTROUTING -p tcp --dport 80 -j CLASSIFY --set-class 20:10</td></tr><tr><td>Explanation</td><td>The CLASSIFY target only takes one argument, the --set-class. This tells the target how to class the packet. The class takes 2 values separated by a coma sign, like this MAJOR:MINOR. Once again, if you want more information on this, check the <a href="https://www.lartc.org/" rel="nofollow">Linux Advanced Routing and Traffic Control HOW-TO</a> webpage.</td></tr></tbody></table> 
<h3><a id="13_CLUSTERRIP_target_34"></a>1.3 CLUSTERRIP target</h3> 
<p>CLUSTERIP目标用于以轮询方式创建响应相同IP和MAC地址的简单节点集群。这是一种简单的集群形式，您在参与集群的所有主机上设置一个Virtual IP (VIP)，然后在每个应该响应请求的主机上使用CLUSTERIP。CLUSTERIP匹配不需要特殊的负载平衡硬件或机器，它只是在机器集群的每个主机部分上执行它的工作。它是一个非常简单的集群解决方案，不适合大型和复杂的集群，它也没有内置心跳处理，但加心跳处理也可以用脚本实现。</p> 
<p>集群中的所有服务器都为一个虚拟IP使用一个通用的多播MAC，然后在CLUSTERIP目标中使用一个特殊的散列算法来确定哪些集群参与者应该响应每个连接。多播MAC是指以01:00:5e作为前24位的MAC地址。一个多播MAC的例子是01:00:5e:00:00:20。虚拟IP可以是任何IP地址，但在所有主机上也必须是相同的。</p> 
<p><strong>记住，CLUSTERIP可能会破坏SSH等协议。连接将正常进行，但是如果您尝试同一时间再次连接到同一主机，您可能连接到集群中的另一台计算机，使用不同的秘钥集，因此您的ssh客户机可能拒绝连接或给您错误。由于这个原因，这在某些协议中不能很好地工作，添加可用于维护和管理的单独地址可能是一个好主意。另一种解决方案是在参与集群的所有主机上使用相同的SSH密钥。</strong></p> 
<p>集群可以使用三种哈希模式进行负载平衡。第一个是只有源IP (sourceip)，第二个是源IP和源端口(sourceip-sourceport)，第三个是源IP、源端口和目的端口(sourceip-sourceport-destport)。第一个可能是一个好主意，你需要记住连接之间的状态，例如一个web服务器的购物车保持连接之间的状态，这种负载平衡可能会变得有点不平衡——不同的机器可能比其他机器获得更高的负载，等等——因为来自同一源IP的连接将到相同的服务器。sourceip-sourceport散列可能是一个好主意，如果您希望负载平衡稍微均匀一点，并且不必在每个服务器上的连接之间保存状态。例如，一个大型信息网页加上一个简单的搜索引擎可能是一个好主意。第三种也是最后一种散列模式sourceip-sourceport-destport可能是个好主意，因为您的主机上运行着多个服务，不需要在连接之间保留任何状态。例如，这可能是同一主机上的一个简单的ntp、dns和www服务器。因此，到每个新目的地的每个连接都将被“重新协商”——实际上没有进行任何协商，它基本上只是一个轮询系统，每个主机接收一个连接。</p> 
<p>每个CLUSTERIP 集群在/proc/net/ipt_CLUSTERIP路径下都有一个单独的文件，文件基于虚拟IP来存放。如果虚拟IP是192.168.0.5，我们可以cat /proc/net/ipt_CLUSTERIP/192.168.0.5 来查看该相应哪个节点。为了让这台机器为另一台机器应答，我们设节点2，使用echo “+2” &gt;&gt;/proc/net/ipt_CLUSTERIP / 192.168.0.5。要删除它，运行echo “-2” &gt;&gt;/proc/net/ipt_CLUSTERIP / 192.168.0.5。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–new</td></tr><tr><td>Example</td><td>iptables -A INPUT -p tcp -d 192.168.0.5 --dport 80 -j CLUSTERIP --new …</td></tr><tr><td>Explanation</td><td>This creates a new CLUSTERIP entry. It must be set on the first rule for a VIP, and is used to create a new cluster. If you have several rules connecting to the same CLUSTERIP you can omit the --new keyword in any secondary references to the same VIP.</td></tr><tr><td>Option</td><td>–hashmode</td></tr><tr><td>Example</td><td>iptables -A INPUT -p tcp -d 192.168.0.5 --dport 443 -j CLUSTERIP --new --hashmode sourceip …</td></tr><tr><td>Explanation</td><td>The --hashmode keyword specifies the kind of hash that should be created. The hashmode can be any of the following three.<br>sourceip<br>sourceip-sourceport<br>sourceip-sourceport-destport <br>The hashmodes has been extensively explained above. Basically, sourceip will give better performance and simpler states between connections, but not as good load-balancing between the machines. sourceip-sourceport will give a slightly slower hashing and not as good to maintain states between connections, but will give better load-balancing properties. The last one may create very slow hashing that consumes a lot of memory, but will on the other hand also create very good load-balancing properties.</td></tr><tr><td>Option</td><td>–clustermac</td></tr><tr><td>Example</td><td>iptables -A INPUT -p tcp -d 192.168.0.5 --dport 80 -j CLUSTERIP --new --hashmode sourceip --clustermac 01:00:5e:00:00:20 …</td></tr><tr><td>Explanation</td><td>The MAC address that the cluster is listening to for new connections. This is a shared Multicast MAC address that all the hosts are listening to. See above for a deeper explanation of this.</td></tr><tr><td>Option</td><td>–total-nodes</td></tr><tr><td>Example</td><td>iptables -A INPUT -p tcp -d 192.168.0.5 --dport 80 -j CLUSTERIP --new --hashmode sourceip --clustermac 01:00:5e:00:00:20 --total-nodes 2 …</td></tr><tr><td>Explanation</td><td>The --total-nodes keyword specifies how many hosts are participating in the cluster and that will answer to requests. See above for a deeper explanation.</td></tr><tr><td>Option</td><td>–local-node</td></tr><tr><td>Example</td><td>iptables -A INPUT -p tcp -d 192.168.0.5 --dport 80 -j CLUSTERIP --new --hashmode sourceip --clustermac 01:00:5e:00:00:20 --total-nodes 2 --local-node 1</td></tr><tr><td>Explanation</td><td>This is the number that this machine has in the cluster. The cluster answers in a round-robin fashion, so once a new connection is made to the cluster, the next machine answers, and then the next after that, and so on.</td></tr><tr><td>Option</td><td>–hash-init</td></tr><tr><td>Example</td><td>iptables -A INPUT -p tcp -d 192.168.0.5 --dport 80 -j CLUSTERIP --new --hashmode sourceip --clustermac 01:00:5e:00:00:20 --hash-init 1234</td></tr><tr><td>Explanation</td><td>Specifies a random seed for hash initialization.</td></tr></tbody></table> 
<p><strong>该目标违反了[ RFC 1812 - Requirements for IP Version 4 Routers]要求，因此要警惕可能出现的任何问题。具体来说，3.3.2节规定了一个路由器绝对不能信任另一个声称它正在使用多播mac的主机或路由器</strong></p> 
<h3><a id="14_CONNMARK_target_68"></a>1.4 CONNMARK target</h3> 
<p>ONNMARK目标用于在整个连接上设置标记，其方式与mark目标非常相似。然后，它可以与连接标记匹配一起使用。例如，假设我们在报头中看到一个特定的模式，我们不想只标记那个包，而是标记整个连接。在这种情况下，CONNMARK目标是一个完美的解决方案。CONNMARK目标在所有链和所有表中都可用，但请记住，nat表只由连接中的第一个包遍历，因此如果您试图将它用于这里的第一个包之后的后续包，那么CONNMARK目标将没有任何作用。它可以采用以下四种不同的选项之一。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–set-mark</td></tr><tr><td>Example</td><td>iptables -t nat -A PREROUTING -p tcp --dport 80 -j CONNMARK --set-mark 4</td></tr><tr><td>Explanation</td><td>This option sets a mark on the connection. The mark can be an unsigned long int, which means values between 0 and 4294967295l is valid. Each bit can also be masked by doing --set-mark 12/8. This will only allow the bits in the mask to be set out of all the bits in the mark. In this example, only the 4th bit will be set, not the 3rd. 12 translates to 1100 in binary, and 8 to 1000, and only the bits set in the mask are allowed to be set. Hence, only the 4th bit, or 8, is set in the actual mark.</td></tr><tr><td>Option</td><td>–save-mark</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING --dport 80 -j CONNMARK --save-mark</td></tr><tr><td>Explanation</td><td>The --save-mark target option is used to save the packet mark into the connection mark. For example, if you have set a packet mark with the MARK target, you can then move this mark to mark the whole connection with the --save-mark match. The mark can also be masked by using the --mask option described further down.</td></tr><tr><td>Option</td><td>–restore-mark</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING --dport 80 -j CONNMARK --restore-mark</td></tr><tr><td>Explanation</td><td>This target option restores the packet mark from the connection mark as defined by the CONNMARK. A mask can also be defined using the --mask option as seen below. If a mask is set, only the masked options will be set. Note that this target option is only valid for use in the mangle table.</td></tr><tr><td>Option</td><td>–mask</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING --dport 80 -j CONNMARK --restore-mark --mask 12</td></tr><tr><td>Explanation</td><td>The --mask option must be used in unison with the --save-mark and --restore-mark options. The --mask option specifies an and-mask that should be applied to the mark values that the other two options will give. For example, if the restored mark from the above example would be 15, it would mean that the mark was 1111 in binary, while the mask is 1100. 1111 and 1100 equals 1100.</td></tr></tbody></table> 
<h3><a id="15_CONNSECMARK_targe_85"></a>1.5 CONNSECMARK targe</h3> 
<p>CONNSECMARK目标将SELinux安全上下文标记设置为包标记或从包标记中设置。有关SELinux的更多信息，请阅读安全增强Linux主页。该目标仅在mangle表中有效，并与SECMARK目标一起使用，其中SECMARK目标用于设置原始标记，然后使用CONNSECMARK在整个连接上设置标记。SELinux超出了本文的范围，但基本上它是对Linux的强制访问控制的一个补充。这比大多数Linux和Unix安全控件的原始安全系统更细粒度。每个对象都可以有连接到它的安全属性或安全上下文，然后在允许或拒绝执行特定任务之前，将这些属性相互匹配。此目标将允许在连接上设置安全上下文。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–save</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING -p tcp --dport 80 -j CONNSECMARK --save</td></tr><tr><td>Explanation</td><td>Save the security context mark from the packet to the connection if the connection is not marked since before.</td></tr><tr><td>Option</td><td>–restore</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING -p tcp --dport 80 -j CONNSECMARK --restore</td></tr><tr><td>Explanation</td><td>If the packet has no security context mark set on it, the --restore option will set the security context mark associated with the connection on the packet.</td></tr></tbody></table> 
<h3><a id="16_DNAT_target_97"></a>1.6 DNAT target</h3> 
<p>DNAT目标用于进行目的网络地址转换(Destination Network Address Translation)。如果一个数据包被匹配，并且这是规则的目标，那么该数据包以及同一流中的所有后续数据包将被翻译，然后路由到正确的设备、主机或网络。这个目标可以是非常有用的，例如，当你有一个主机在局域网内运行你的web服务器，但没有真正的IP给它可以在互联网上工作。然后你可以告诉防火墙将所有的数据包转发到它自己的HTTP端口上，到局域网内的真正的web服务器上。我们也可以指定一个完整的目的IP地址范围，DNAT机制将为每个流随机选择目的IP地址。因此，通过这样做，我们将能够处理一种负载平衡。注意，DNAT目标仅在nat表中的PREROUTING和OUTPUT链中可用，以及从这些列出的链中调用的任何链中可用。注意，包含DNAT目标的链不能从任何其他链中使用，例如POSTROUTING链。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–to-destination</td></tr><tr><td>Example</td><td>iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination 192.168.1.1-192.168.1.10</td></tr><tr><td>Explanation</td><td>The --to-destination option tells the DNAT mechanism which Destination IP to set in the IP header, and where to send packets that are matched. The above example would send on all packets destined for IP address 15.45.23.67 to a range of LAN IP’s, namely 192.168.1.1 through 10. Note, as described previously, that a single stream will always use the same host, and that each stream will randomly be given an IP address that it will always be Destined for, within that stream. We could also have specified only one IP address, in which case we would always be connected to the same host. Also note that we may add a port or port range to which the traffic would be redirected to. This is done by adding, for example, an :80 statement to the IP addresses to which we want to DNAT the packets. A rule could then look like --to-destination 192.168.1.1:80 for example, or like --to-destination 192.168.1.1:80-100 if we wanted to specify a port range. As you can see, the syntax is pretty much the same for the DNAT target, as for the SNAT target even though they do two totally different things. Do note that port specifications are only valid for rules that specify the TCP or UDP protocols with the --protocol option.</td></tr></tbody></table> 
<p>由于DNAT需要做很多工作才能正常工作，所以我决定对如何使用它做一个更详细的解释。让我们举一个简单的例子来说明事情通常是如何进行的。我们想通过我们的互联网连接发布我们的网站。我们只有一个IP地址，HTTP服务器位于我们的内部网络。我们的防火墙有外部IP地址<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         I 
        
       
         N 
        
       
         E 
        
        
        
          T 
         
        
          I 
         
        
       
         P 
        
       
         ， 
        
       
         我 
        
       
         们 
        
       
         的 
        
       
         H 
        
       
         T 
        
       
         T 
        
       
         P 
        
       
         服 
        
       
         务 
        
       
         器 
        
       
         有 
        
       
         内 
        
       
         部 
        
       
         I 
        
       
         P 
        
       
         地 
        
       
         址 
        
       
      
        INET_IP，我们的HTTP服务器有内部IP地址 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord mathdefault" style="margin-right: 0.07847em;">I</span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mord cjk_fallback">服</span><span class="mord cjk_fallback">务</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">部</span><span class="mord mathdefault" style="margin-right: 0.07847em;">I</span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">址</span></span></span></span></span>HTTP_IP，最后防火墙有内部IP地址$LAN_IP。首先要做的是在nat表的PREROUTING链中添加以下简单的规则:</p> 
<pre><code class="prism language-powershell">iptables <span class="token operator">-</span>t nat <span class="token operator">-</span>A PREROUTING <span class="token operator">--</span>dst <span class="token variable">$INET_IP</span> <span class="token operator">-</span>p tcp <span class="token operator">--</span>dport 80 <span class="token operator">-</span>j DNAT \
<span class="token operator">--</span>to-destination <span class="token variable">$HTTP_IP</span>
</code></pre> 
<p>现在，所有从互联网发送到我们防火墙80端口的数据包都被重定向(或DNAT)到我们的内部HTTP服务器。如果您从互联网上进行测试，那么一切都应该非常完美。那么，如果您尝试从与HTTP服务器相同的本地网络上的主机进行连接，会发生什么情况呢?这根本行不通。这是路由的一个问题。我们从剖析正常情况下发生的事情开始。外部盒子有IP地址$EXT_BOX，以保持可读性。</p> 
<ol><li>数据包离开连接的主机到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          I 
         
        
          N 
         
        
          E 
         
         
         
           T 
          
         
           I 
          
         
        
          P 
         
        
          和 
         
        
          源 
         
        
       
         INET_IP和源 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord mathdefault" style="margin-right: 0.07847em;">I</span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mord cjk_fallback">和</span><span class="mord cjk_fallback">源</span></span></span></span></span>EXT_BOX。</li><li>数据包到达防火墙</li><li>防火墙DNAT数据包，并输送数据通过所有的链</li><li>数据包离开防火墙并传输到$HTTP_IP。</li><li>数据包到达HTTP服务器，HTTP框通过防火墙返回，如果路由数据库输入该框作为$EXT_BOX的网关的话。通常，这将是HTTP服务器的默认网关。</li><li>防火墙的Un-DNAT再次对数据包进行了处理，因此数据包看起来就像是从防火墙本身返回的。</li><li>回复包像往常一样返回到客户端$EXT_BOX。</li></ol> 
<p>现在，我们将考虑如果包是由与HTTP服务器本身在同一网络上的客户机生成的会发生什么。客户端拥有IP地址$LAN_BOX，而其余计算机保持相同的设置。</p> 
<ol><li>数据包离开<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          L 
         
        
          A 
         
         
         
           N 
          
         
           B 
          
         
        
          O 
         
        
          X 
         
        
          到 
         
        
       
         LAN_BOX到 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.10903em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mord cjk_fallback">到</span></span></span></span></span>INET_IP。</li><li>数据包抵达防火墙</li><li>数据包被DNAT处理，并执行所有其他所需的操作，但是，该包没有SNAT处理，因此在包上使用相同的源IP地址。</li><li>数据包离开防火墙并到达HTTP服务器</li><li>HTTP服务器尝试响应数据包，并在路由数据库中看到数据包来自同一网络上的本地框，因此尝试直接将数据包发送到原始的源IP地址(现在变成了目的IP地址)。</li><li>数据包到达客户端，客户端会感到困惑，因为返回的数据包不是来自它发送原始请求的主机。因此，客户端丢弃应答包，等待“真正的”应答。</li></ol> 
<p>这个问题的简单解决方案是SNAT所有进入防火墙并离开的数据包，我们知道我们对其进行了DNAT。例如，考虑上面的规则。我们SNAT数据包进入我们的防火墙，是注定<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         T 
        
       
         T 
        
        
        
          P 
         
        
          I 
         
        
       
         P 
        
       
         端 
        
       
         口 
        
       
         80 
        
       
         ， 
        
       
         这 
        
       
         样 
        
       
         他 
        
       
         们 
        
       
         看 
        
       
         起 
        
       
         来 
        
       
         就 
        
       
         像 
        
       
         他 
        
       
         们 
        
       
         来 
        
       
         自 
        
       
      
        HTTP_IP端口80，这样他们看起来就像他们来自 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord mathdefault" style="margin-right: 0.08125em;">H</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mord cjk_fallback">端</span><span class="mord cjk_fallback">口</span><span class="mord">8</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">看</span><span class="mord cjk_fallback">起</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">像</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">自</span></span></span></span></span>LAN_IP。这将迫使HTTP服务器将包发送回我们的防火墙，防火墙对包进行Un-DNAT处理并将它们发送到客户端。规则看起来是这样的:</p> 
<pre><code class="prism language-shell">iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> POSTROUTING <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">--dst</span> <span class="token variable">$HTTP_IP</span> <span class="token parameter variable">--dport</span> <span class="token number">80</span> <span class="token parameter variable">-j</span> SNAT <span class="token punctuation">\</span>
--to-source <span class="token variable">$LAN_IP</span>
</code></pre> 
<p>请记住，POSTROUTING链是在链的最后处理的，因此一旦到达特定的链，数据包就已经被DNAT处理了。这就是我们根据内部地址匹配数据包的原因。</p> 
<p>这是最后一条将严重损害您的日志记录的规则，因此建议不要使用此方法，但整个示例仍然是有效的。将会发生的事情是这样的，数据包来自互联网，经过SNAT和DNAT，最后到达HTTP服务器(例如)。HTTP服务器现在只看到请求，就像它来自防火墙一样，因此记录所有来自internet的请求，就像它们来自防火墙一样。</p> 
<p>这也可能产生更严重的影响。以LAN上的SMTP服务器为例，它允许来自内部网络的请求，并设置防火墙将SMTP通信转发给它。您现在已经有效地创建了一个开放中继SMTP服务器，但日志记录非常糟糕!</p> 
<p>这个问题的一个解决方案是简单地使SNAT规则在匹配部分更加具体，并且只对来自我们的LAN接口的数据包起作用。换句话说，还要在整个命令中添加–src $LAN_IP_RANGE。这将使规则只对来自LAN的流有效，因此不会影响源IP，所以日志看起来是正确的，但来自我们的LAN的流除外。</p> 
<p>换句话说，解决这些问题最好是为LAN设置一个单独的DNS服务器，或者实际设置一个单独的DMZ，如果有钱，最好是后者。</p> 
<pre><code class="prism language-shell">iptables <span class="token parameter variable">-t</span> nat <span class="token parameter variable">-A</span> OUTPUT <span class="token parameter variable">--dst</span> <span class="token variable">$INET_IP</span> <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">--dport</span> <span class="token number">80</span> <span class="token parameter variable">-j</span> DNAT <span class="token punctuation">\</span>
--to-destination <span class="token variable">$HTTP_IP</span>
</code></pre> 
<p>添加最后一条规则应该可以让一切正常运行。所有与HTTP服务器不在同一网络上的独立网络将顺利运行，所有与HTTP服务器在同一网络上的主机将能够连接，最后，防火墙也将能够进行正确的连接。现在一切正常，应该不会出现问题了。</p> 
<p><strong>每个人都应该意识到，这些规则只影响数据包如何正确地进行DNAT和SNAT。除了这些规则之外，您可能还需要在筛选表(FORWARD链)中添加额外的规则，以允许数据包也遍历这些链。不要忘记所有数据包都已经经过PREROUTING链，因此它们的目的地址应该已经被DNAT重写。</strong></p> 
<h3><a id="17_DROP_target_155"></a>1.7 DROP target</h3> 
<p>DROP目标所做的就是它所说的，它将包丢弃而不进行任何进一步的处理。一个数据包完美匹配一个规则，然后被丢弃将被阻塞。注意，这个操作在某些情况下可能会产生不必要的效果，因为它可能在任意一台主机上留下死套接字。在可能出现这种情况的情况下，更好的解决方案是使用REJECT目标，特别是当您想阻止端口扫描器获取太多信息时，例如关于过滤端口的信息等等。还要注意，如果一个包在子链中被执行了DROP操作，则该包将不会在当前表或任何其他表的任何主链中被处理。换句话说，数据包已经完全死亡。正如我们前面看到的，目标不会向任何方向发送任何类型的信息，也不会发送到路由器等中介。</p> 
<p>适用于：Linux内核 2.3， 2.4， 2.5， 2.6</p> 
<h3><a id="18_DSCP_target_161"></a>1.8 DSCP target</h3> 
<p>用来改变包内DSCP(Differentiated Services Field)标记目标，DSCP目标可以在TCP报文中设置任何DSCP值，这是一种告诉路由器报文优先级的方式。更多请参考：<a href="https://www.frozentux.net/iptables-tutorial/other/rfc2474.txt" rel="nofollow">RFC 2474 - Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers </a></p> 
<p>基本上，DSCP是一种将不同的服务划分为不同的类别，并以此为基础通过路由器给它们不同的优先级的方法。通过这种方式，您可以为交互TCP会话(如telnet、SSH、POP3)提供一个非常高速的连接，这可能不太适合大型批量传输。另一方面，如果连接是一个低重要性的连接(SMTP，或任何您分类为低优先级的连接)，您可以通过一个延迟比另一个网络更差的大型网络发送它，这比使用更快和更低延迟的连接更便宜。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–set-dscp</td></tr><tr><td>Example</td><td>iptables -t mangle -A FORWARD -p tcp --dport 80 -j DSCP --set-dscp 1</td></tr><tr><td>Explanation</td><td>This sets the DSCP value to the specified value. The values can be set either via class, see below, or with the --set-dscp, which takes either an integer value, or a hex value.</td></tr><tr><td>Option</td><td>–set-dscp-class</td></tr><tr><td>Example</td><td>iptables -t mangle -A FORWARD -p tcp --dport 80 -j DSCP --set-dscp-class EF</td></tr><tr><td>Explanation</td><td>This sets the DSCP field according to a predefined DiffServ class. Some of the possible values are EF, BE and the CSxx and AFxx values available. You can find more information at <a href="https://www.cisco.com/site/us/en/index.html" rel="nofollow">Implementing Quality of Service Policies with DSCP </a>site. Do note that the --set-dscp-class and --set-dscp commands are mutually exclusive, which means you can not use both of them in the same command!</td></tr></tbody></table> 
<h3><a id="19_ECN_target_175"></a>1.9 ECN target</h3> 
<p>如果使用方法正确，这个目标可以很好。简单地说，ECN目标可以用于从IPv4报头重置ECN位，或者正确地说，至少将它们重置为0。由于ECN在网络上是一个相对较新的事物，它存在一些问题。例如，它使用在原始RFC中定义的2位，使TCP协议为0。一些路由器和其他互联网设备将不转发这些位设置为1的数据包。如果您想从您的主机至少利用ECN的部分功能，您可以将ECN位重置为0，例如，对于您知道由于ECN而无法到达的特定网络。</p> 
<p>请注意，根据RFC的规定，我们不能在流中间打开ECN的，无论如何这是不可能的。流的两个端点都必须协商ECN。如果我们打开它，那么其中一个主机就不会意识到它，并且不能正确地响应ECN通知。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–ecn-tcp-remove</td></tr><tr><td>Example</td><td>iptables -t mangle -A FORWARD -p tcp --dport 80 -j ECN --ecn-tcp-remove</td></tr><tr><td>Explanation</td><td>The ECN target only takes one argument, the --ecn-tcp-remove argument. This tells the target to remove the ECN bits inside the TCP headers. Read above for more information.</td></tr></tbody></table> 
<h3><a id="110_LOG_target_options_185"></a>1.10 LOG target options</h3> 
<p>LOG目标是专门为记录数据包的详细信息而设计的。例如，这些可能被认为是非法的。或者，日志记录可以纯粹用于错误查找和错误查找。LOG目标将返回包的特定信息，例如大多数IP头和其他被认为感兴趣的信息。它通过内核日志记录工具(通常是syslogd)来实现这一点。然后，可以通过dmesg直接读取该信息，或者从syslogd日志中读取，或者通过其他程序或应用程序读取。这是一个用于调试规则集的极好目标，这样您就可以看到哪些包去了哪里，哪些规则应用于哪些包。还要注意，当您在生产防火墙上测试不是100%确定的规则时，使用LOG目标而不是DROP目标可能是一个非常好的主意，因为规则集中的语法错误可能会给用户带来严重的连通性问题。还需要注意的是，如果您正在使用非常广泛的日志记录，那么ULOG目标可能会很有趣，因为ULOG目标支持直接记录到MySQL数据库等。</p> 
<p>注意，如果你不需要直接记录到控制台，这不是iptables或Netfilter的问题，而是由你的syslogd配置引起的问题——最有可能的是/etc/syslog.conf。有关这类问题的更多信息，请阅读man syslog.conf。</p> 
<p>您可能还需要调整dmesg设置。Dmesg命令用于更改应该在控制台上显示的内核错误。Dmesg -n 1应该防止所有消息显示在控制台上，恐慌消息除外。dmesg消息级别与syslogd消息级别完全匹配，而且它只适用于来自内核工具的日志消息。更多信息，请参见man dmesg。</p> 
<p>LOG目标目前有五个选项，如下表所示：</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–log-level</td></tr><tr><td>Example</td><td>iptables -A FORWARD -p tcp -j LOG --log-level debug</td></tr><tr><td>Explanation</td><td>This is the option to tell iptables and syslog which log level to use. For a complete list of log levels read the syslog.conf manual. Normally there are the following log levels, or priorities as they are normally referred to: debug, info, notice, warning, warn, err, error, crit, alert, emerg and panic. The keyword error is the same as err, warn is the same as warning and panic is the same as emerg. Note that all three of these are deprecated, in other words do not use error, warn and panic. The priority defines the severity of the message being logged. All messages are logged through the kernel facility. In other words, setting kern.=info /var/log/iptables in your syslog.conf file and then letting all your LOG messages in iptables use log level info, would make all messages appear in the /var/log/iptables file. Note that there may be other messages here as well from other parts of the kernel that uses the info priority. For more information on logging I recommend you to read the syslog and syslog.conf man-pages as well as other HOWTOs etc.</td></tr><tr><td>Option</td><td>–log-prefix</td></tr><tr><td>Example</td><td>iptables -A INPUT -p tcp -j LOG --log-prefix “INPUT packets”</td></tr><tr><td>Explanation</td><td>This option tells iptables to prefix all log messages with a specific prefix, which can then easily be combined with grep or other tools to track specific problems and output from different rules. The prefix may be up to 29 letters long, including white-spaces and other special symbols.</td></tr><tr><td>Option</td><td>–log-tcp-sequence</td></tr><tr><td>Example</td><td>iptables -A INPUT -p tcp -j LOG --log-tcp-sequence</td></tr><tr><td>Explanation</td><td>This option will log the TCP Sequence numbers, together with the log message. The TCP Sequence numbers are special numbers that identify each packet and where it fits into a TCP sequence, as well as how the stream should be reassembled. Note that this option constitutes a security risk if the logs are readable by unauthorized users, or by the world for that matter. As does any log that contains output from iptables.</td></tr><tr><td>Option</td><td>–log-tcp-options</td></tr><tr><td>Example</td><td>iptables -A FORWARD -p tcp -j LOG --log-tcp-options</td></tr><tr><td>Explanation</td><td>The --log-tcp-options option logs the different options from the TCP packet headers and can be valuable when trying to debug what could go wrong, or what has actually gone wrong. This option does not take any variable fields or anything like that, just as most of the LOG options don’t.</td></tr><tr><td>Option</td><td>–log-ip-options</td></tr><tr><td>Example</td><td>iptables -A FORWARD -p tcp -j LOG --log-ip-options</td></tr><tr><td>Explanation</td><td>The --log-ip-options option will log most of the IP packet header options. This works exactly the same as the --log-tcp-options option, but instead works on the IP options. These logging messages may be valuable when trying to debug or track specific culprits, as well as for debugging - in just the same way as the previous option.</td></tr></tbody></table> 
<h3><a id="111_MARK_target_212"></a>1.11 MARK target</h3> 
<p>MARK目标用于设置与特定包相关联的Netfilter标记值。此目标仅在mangle表中有效，在此表之外无效。MARK值可以与Linux中的高级路由功能一起使用，通过不同的路由发送不同的包，并告诉它们使用不同的队列规程(qdisc)等。更多信息请参考：[Linux Advanced Routing and Traffic Control HOW-TO](https://www.lartc.org/。注意，标记值不是在实际的包中设置的，而是在内核中与包相关联的值。换句话说，您不能为一个包设置一个MARK，然后期望该MARK仍然存在于另一个主机上。如果这是你想要的，你最好使用TOS目标，它会破坏IP头中的TOS值。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–set-mark</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 2</td></tr><tr><td>Explanation</td><td>The --set-mark option is required to set a mark. The --set-mark match takes an integer value. For example, we may set mark 2 on a specific stream of packets, or on all packets from a specific host and then do advanced routing on that host, to decrease or increase the network bandwidth, etc.</td></tr></tbody></table> 
<h3><a id="112__MASQUERADE_target_221"></a>1.12 MASQUERADE target</h3> 
<p>MASQUERADE目标的使用方式与SNAT目标基本相同，但它不需要任何–to–source选项。这是因为MASQUERADE目标是用来处理拨号连接或DHCP连接的，它们在连接到相关网络时获得动态IP地址。这意味着您应该只对动态分配的IP连接使用MASQUERADE目标，而我们始终不知道IP连接的实际地址。如果您有一个静态IP连接，您应该使用SNAT目标。</p> 
<p>当您伪装一个连接时，这意味着我们设置在特定网络接口上使用的IP地址，而不是–to-source选项，并且IP地址会自动从有关特定接口的信息中获取。MASQUERADE目标还有一个效果，即当一个接口停止运行时，连接将被忘记，如果我们(例如)终止一个特定的接口，这是非常好的。如果我们使用SNAT目标，我们可能会留下许多旧的连接跟踪数据，这些数据将被放置数天，吞噬有用的连接跟踪内存。通常情况下，这是在处理每次可能被分配不同IP的拨号线路时的正确行为。万一我们被分配到一个不同的IP，连接无论如何都会丢失，保留条目多少有点愚蠢。</p> 
<p>即使你有一个静态IP，仍然可以使用MASQUERADE目标而不是SNAT，然而，这并不好，因为它会增加额外的开销，而且将来可能会出现不一致的情况，这会阻碍你现有的脚本，使它们“不可用”。</p> 
<p>注意，MASQUERADE目标只在nat表中的POSTROUTING链中有效，就像SNAT目标一样。MASQUERADE目标接受下面指定的一个选项，这是可选的。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–to-ports</td></tr><tr><td>Example</td><td>iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 1024-31000</td></tr><tr><td>Explanation</td><td>The --to-ports option is used to set the source port or ports to use on outgoing packets. Either you can specify a single port like --to-ports 1025 or you may specify a port range as --to-ports 1024-3000. In other words, the lower port range delimiter and the upper port range delimiter separated with a hyphen. This alters the default SNAT port-selection as described in the SNAT target section. The --to-ports option is only valid if the rule match section specifies the TCP or UDP protocols with the --protocol match.</td></tr></tbody></table> 
<h3><a id="113_MIRROR_target_236"></a>1.13 MIRROR target</h3> 
<p><strong>注意：MIRROR 目标很危险，只是作为新的连接和NAT代码的示例代码开发的。它会导致危险的事情发生，如果使用不当，很严重的DDoS/DoS将可能发生。不惜一切代价避免使用它!已从2.5和2.6内核中删除了，因为它的安全性很差!</strong></p> 
<p>MIRROR目标只是一个实验和演示目标，并且警告您不要使用它，因为它可能导致非常糟糕的循环，从而导致严重的拒绝服务(Denial of Service)。MIRROR目标用于颠倒IP报头中的源和目的字段，然后重传数据包。这可能会产生一些非常有趣的效果，我敢打赌，多亏了这个目标，到目前为止，不止一个红着脸的爆竹已经打破了自己的盒子。至少可以说，使用这个目标的效果是明显的。假设我们为计算机a的80端口设置了一个镜像目标。如果主机B来自yahoo.com，并试图访问主机a的HTTP服务器，那么镜像目标将返回雅虎主机自己的网页(因为这是请求的来源)。</p> 
<p>注意，MIRROR目标只在INPUT、FORWARD和PREROUTING链以及从这些链调用的任何用户定义链中有效。还要注意，从MIRROR目标发出的数据包不会被过滤器、nat或mangle表中的任何正常链看到，这可能会导致循环和其他问题。这可能会使目标成为不可预见的头痛的原因。例如，一个主机可能向另一个使用MIRROR命令的主机发送一个欺骗数据包，该数据包的TTL为255，同时欺骗它自己的数据包，使它看起来像是来自使用MIRROR命令的第三个主机。数据包将不断地来回弹跳，以确定要完成的跳数。如果只有1跳，则报文来回跳240 ~ 255次。换句话说，对于一个黑客来说，发送1500字节的数据并消耗掉您连接的380kbyte已经很不错了。请注意，这是破坏者或脚本小子(不管我们想叫他们什么)的最佳情况。</p> 
<h3><a id="114_NETMAP_target_244"></a>1.14 NETMAP target</h3> 
<p>NETMAP是SNAT和DNAT目标的一种新实现，它不改变IP地址的主机部分。它提供了标准SNAT和DNAT功能所没有的全网1:1 NAT功能。例如，假设我们有一个包含254个使用私有IP地址的主机的网络(一个/24网络)，我们刚刚得到一个新的/24公共IP网络。我们可以简单地使用NETMAP目标，如-j NETMAP -to 10.5.6.0/24，而不是四处走动并更改每个主机的IP，然后瞧，所有主机都被视为10.5.6。当它们离开防火墙时X。例如，192.168.0.26将变成10.5.6.26。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–to</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING -s 192.168.1.0/24 -j NETMAP --to 10.5.6.0/24</td></tr><tr><td>Explanation</td><td>This is the only option of the NETMAP target. In the above example, the 192.168.1.x hosts will be directly translated into 10.5.6.x.</td></tr></tbody></table> 
<p>Linux 2.5 2.6 有效</p> 
<h3><a id="115__NFQUEUE_target_256"></a>1.15 NFQUEUE target</h3> 
<p>NFQUEUE目标的使用方式与QUEUE目标非常相似，基本上是它的扩展。NFQUEUE目标允许为单独的和特定的队列发送包。队列由16位id标识。</p> 
<p>这个目标需要nfnetlink_queue内核支持才能运行。更多详情参考"QUEUE target"</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–queue-num</td></tr><tr><td>Example</td><td>iptables -t nat -A PREROUTING -p tcp --dport 80 -j NFQUEUE --queue-num 30</td></tr><tr><td>Explanation</td><td>The --queue-num option specifies which queue to use and to send the queue’d data to. If this option is skipped, the default queue 0 is used. The queue number is a 16 bit unsigned integer, which means it can take any value between 0 and 65535. The default 0 queue is also used by the QUEUE target.</td></tr></tbody></table> 
<p>Linux 2.6.14及以后版本有效</p> 
<h3><a id="116_NOTRACK_target_268"></a>1.16 NOTRACK target</h3> 
<p>此目标用于关闭所有匹配此规则的包的连接跟踪。目标只在原始表内部有效。Linux 2.6版本有效</p> 
<h3><a id="117_QUEUE_target_271"></a>1.17 QUEUE target</h3> 
<p>QUEUE目标用于对用户域程序和应用程序的数据包进行队列。它与与iptables无关的程序或实用程序一起使用，例如，与网络计费一起使用，或用于代理或过滤包的特定和高级应用程序。我们将不深入讨论这个目标，因为此类应用程序的编码超出了本教程的范围。首先，它会花费太多的时间，其次，这样的文档与Netfilter和iptables的编程方面没有任何关系。</p> 
<h3><a id="118_REDIRECT_target_274"></a>1.18 REDIRECT target</h3> 
<p>REDIRECT目标用于将包和流重定向到机器本身。例如，这意味着我们可以在我们自己的主机上将所有发送到HTTP端口的包重定向到一个HTTP代理，比如squid。本地生成的报文映射到127.0.0.1地址。换句话说，这将为转发的包或类似的东西将目的地址重写到我们自己的主机。当我们需要时，REDIRECT目标非常适合使用，例如，透明代理，LAN主机根本不知道代理。</p> 
<p>注意，REDIRECT目标只在nat表的PREROUTING和OUTPUT链中有效。它在只从这些链调用的用户定义链中也有效，而在其他任何地方都无效。REDIRECT目标只接受一个选项，如下所述。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–to-ports</td></tr><tr><td>Example</td><td>iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080</td></tr><tr><td>Explanation</td><td>The --to-ports option specifies the destination port, or port range, to use. Without the --to-ports option, the destination port is never altered. This is specified, as above, --to-ports 8080 in case we only want to specify one port. If we would want to specify a port range, we would do it like --to-ports 8080-8090, which tells the REDIRECT target to redirect the packets to the ports 8080 through 8090. Note that this option is only available in rules specifying the TCP or UDP protocol with the --protocol matcher, since it wouldn’t make any sense anywhere else.</td></tr></tbody></table> 
<h3><a id="119_REJECT_target_285"></a>1.19 REJECT target</h3> 
<p>REJECT目标的工作原理与DROP目标基本相同，但它也向发送被阻塞的包的主机发送回一个错误消息。到目前为止，REJECT目标只在INPUT、FORWARD和OUTPUT链或它们的子链中有效。毕竟，这将是唯一有意义的链，把这个目标。注意，所有使用REJECT目标的链只能由INPUT、FORWARD和OUTPUT链调用，否则它们将不起作用。目前只有一个选项可以控制这个目标如何工作的本质，尽管这反过来可能需要大量的变量。如果您具有TCP/IP的基本知识，那么它们中的大多数都相当容易理解。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–reject-with</td></tr><tr><td>Example</td><td>iptables -A FORWARD -p TCP --dport 22 -j REJECT --reject-with tcp-reset</td></tr><tr><td>Explanation</td><td>This option tells the REJECT target what response to send to the host that sent the packet that we are rejecting. Once we get a packet that matches a rule in which we have specified this target, our host will first of all send the associated reply, and the packet will then be dropped dead, just as the DROP target would drop it. The following reject types are currently valid: icmp-net-unreachable, icmp-host-unreachable, icmp-port-unreachable, icmp-proto-unreachable, icmp-net-prohibited and icmp-host-prohibited. The default error message is to send a port-unreachable to the host. All of the above are ICMP error messages and may be set as you wish. You can find further information on their various purposes in the appendix ICMP types. Finally, there is one more option called tcp-reset, which may only be used together with the TCP protocol. The tcp-reset option will tell REJECT to send a TCP RST packet in reply to the sending host. TCP RST packets are used to close open TCP connections gracefully. For more information about the TCP RST read RFC 793 - Transmission Control Protocol. As stated in the iptables man page, this is mainly useful for blocking ident probes which frequently occur when sending mail to broken mail hosts, that won’t otherwise accept your mail.</td></tr></tbody></table> 
<h3><a id="120_RETURN_target_294"></a>1.20 RETURN target</h3> 
<p>RETURN目标将导致当前数据包在它命中规则的地方停止通过链。如果它是另一条链的子链，数据包将继续通过上级链，就像什么都没有发生过一样。如果链是主链，例如INPUT链，则包上将采用默认策略。默认策略通常设置为ACCEPT、DROP或类似的策略。</p> 
<p>例如，假设一个数据包进入INPUT链，然后遇到它匹配的规则，该规则告诉它–jump EXAMPLE_CHAIN。然后，包将开始遍历EXAMPLE_CHAIN，突然它匹配一个特定的规则，该规则设置了–jump RETURN目标。然后它将跳转回INPUT链。另一个例子是数据包在INPUT链中命中了–jump RETURN规则。然后，就像前面描述的那样，它将被丢弃到默认策略中，在此链中不再执行任何操作。</p> 
<p>Linux 2.3 2.4 2.5 2.6有效</p> 
<h3><a id="121_SAME_target_301"></a>1.21 SAME target</h3> 
<p>同一个目标的工作方式几乎与SNAT目标相同，但它们仍然不同。基本上，同一目标将试图始终使用相同的传出IP地址的所有连接发起在您的网络上的一台主机。例如，假设您有一个/24网络(192.168.1.0)和3个IP地址(10.5.6.7-9)。现在，如果192.168.1.20第一次通过.7地址发出，防火墙将尝试保持该计算机始终通过该IP地址发出。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–to</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING -s 192.168.1.0/24 -j SAME --to 10.5.6.7-10.5.6.9</td></tr><tr><td>Explanation</td><td>As you can see, the --to argument takes 2 IP addresses bound together by a - sign. These IP addresses, and all in between, are the IP addresses that we NAT to using the SAME algorithm.</td></tr><tr><td>Option</td><td>–nodst</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING -s 192.168.1.0/24 -j SAME --to 10.5.6.7-10.5.6.9 --nodst</td></tr><tr><td>Explanation Under normal action, the SAME target is calculating the followup connections based on both destination and source IP addresses. Using the --nodst option, it uses only the source IP address to find out which outgoing IP the NAT function should use for the specific connection. Without this argument, it uses a combination of the destination and source IP address.</td><td></td></tr></tbody></table> 
<p>Linux 2.5 2.6 有效</p> 
<h3><a id="122_SECMARK_target_314"></a>1.22 SECMARK target</h3> 
<p>SECMARK目标用于在单个数据包上设置安全上下文标记，这是由SELinux和安全系统定义的。</p> 
<p>简单地说，SELinux是一个新的改进的安全系统，它将强制访问控制(MAC)添加到Linux中，由NSA实现，作为概念验证。SELinux基本上为不同的对象设置安全属性，然后将它们匹配到安全上下文中。SECMARK目标用于在包上设置安全上下文，然后可以在安全子系统中使用该上下文进行匹配。</p> 
<p><strong>该目标仅在mangle表有效</strong></p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–selctx</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING -p tcp --dport 80 -j SECMARK --selctx httpcontext</td></tr><tr><td>Explanation</td><td>The --selctx option is used to specify which security context to set on a packet. The context can then be used for matching inside the security systems of linux.</td></tr></tbody></table> 
<h3><a id="123_SNAT_target_326"></a>1.23 SNAT target</h3> 
<p>SNAT目标用于进行源网络地址转换，这意味着该目标将重写包的IP头中的源IP地址。例如，当多个主机必须共享一个Internet连接时，这就是我们想要的。然后我们可以在内核中打开ip转发，并编写一个SNAT规则，它将从我们本地网络发出的所有数据包转换为我们自己的Internet连接的源ip。如果不这样做，外部世界将不知道在哪里发送应答包，因为我们的本地网络大多使用IANA指定的IP地址，这些地址是分配给LAN网络的。如果我们这样转发这些数据包，互联网上没有人会知道它们实际上来自我们。SNAT目标完成完成这类工作所需的所有转换，让所有离开局域网的数据包看起来好像来自同一个主机，这个主机就是我们的防火墙。</p> 
<p>SNAT目标只在nat表中、在POSTROUTING链中有效。换句话说，这是您可以在其中使用SNAT的唯一链。SNAT只处理连接中的第一个包，之后使用同一连接的所有未来包也将被捕获。此外，POSTROUTING链中的初始规则将应用于同一流中的所有信息包。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–to-source</td></tr><tr><td>Example</td><td>iptables -t nat -A POSTROUTING -p tcp -o eth0 -j SNAT --to-source 194.236.50.155-194.236.50.160:1024-32000</td></tr><tr><td>Explanation</td><td>The --to-source option is used to specify which source the packet should use. This option, at its simplest, takes one IP address which we want to use for the source IP address in the IP header. If we want to balance between several IP addresses, we can use a range of IP addresses, separated by a hyphen. The --to–source IP numbers could then, for instance, be something like in the above example: 194.236.50.155-194.236.50.160. The source IP for each stream that we open would then be allocated randomly from these, and a single stream would always use the same IP address for all packets within that stream. We can also specify a range of ports to be used by SNAT. All the source ports would then be confined to the ports specified. The port bit of the rule would then look like in the example above, :1024-32000. This is only valid if -p tcp or -p udp was specified somewhere in the match of the rule in question. iptables will always try to avoid making any port alterations if possible, but if two hosts try to use the same ports, iptables will map one of them to another port. If no port range is specified, then if they’re needed, all source ports below 512 will be mapped to other ports below 512. Those between source ports 512 and 1023 will be mapped to ports below 1024. All other ports will be mapped to 1024 or above. As previously stated, iptables will always try to maintain the source ports used by the actual workstation making the connection. Note that this has nothing to do with destination ports, so if a client tries to make contact with an HTTP server outside the firewall, it will not be mapped to the FTP control port.</td></tr></tbody></table> 
<h3><a id="124_TCPMSS_target_337"></a>1.24 TCPMSS target</h3> 
<p>TCPMSS目标可以用来改变防火墙看到的TCP SYN包的MSS(最大段大小)值。MSS值用于控制特定连接的数据包的最大大小。在正常情况下，这意味着MTU(最大传输单元)值的大小减去40字节。这是用来克服一些ISP和服务器阻止ICMP分片所需的数据包，这可能会导致非常奇怪的问题，主要可以描述为:从您的防火墙/路由器所有工作都很完美，但在防火墙后面的本地主机不能交换大数据包。这可能意味着邮件服务器能够发送小邮件，但不能发送大邮件;web浏览器可以连接，但在没有接收到数据的情况下挂起;ssh可以正常连接，但scp在初始握手后挂起。换句话说，所有使用大数据包的程序都将无法工作。</p> 
<p>TCPMSS目标能够通过改变通过连接发出的数据包的大小来解决这些问题。请注意，我们只需要设置SYN包上的MSS，因为在此之后主机将处理MSS。目标接受两个参数。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–set-mss</td></tr><tr><td>Example</td><td>iptables -t mangle -A POSTROUTING -p tcp --tcp-flags SYN,RST SYN -o eth0 -j TCPMSS --set-mss 1460</td></tr><tr><td>Explanation The --set-mss argument explicitly sets a specific MSS value of all outgoing packets. In the example above, we set the MSS of all SYN packets going out over the eth0 interface to 1460 bytes – normal MTU for ethernet is 1500 bytes, minus 40 bytes is 1460 bytes. MSS only has to be set properly in the SYN packet, and then the peer hosts take care of the MSS automatically.</td><td></td></tr><tr><td>Option</td><td>–clamp-mss-to-pmtu</td></tr><tr><td>Example</td><td>iptables -t mangle -A POSTROUTING -p tcp --tcp-flags SYN,RST SYN -o eth0 -j TCPMSS --clamp-mss-to-pmtu</td></tr><tr><td>Explanation</td><td>The --clamp-mss-to-pmtu automatically sets the MSS to the proper value, hence you don’t need to explicitly set it. It is automatically set to PMTU (Path Maximum Transfer Unit) minus 40 bytes, which should be a reasonable value for most applications.</td></tr></tbody></table> 
<h3><a id="125_TOS_target_351"></a>1.25 TOS target</h3> 
<p>TOS目标用于在IP报头中设置服务类型字段。TOS字段由8位组成，用于帮助路由报文。这是可以在iproute2及其子系统中直接用于路由策略的字段之一。值得注意的是，如果您处理几个独立的防火墙和路由器，这是在这些路由器和防火墙之间的实际包中传播路由信息的唯一方法。如前所述，MARK目标—设置与特定包相关联的MARK—仅在内核中可用，不能与包一起传播。如果您觉得需要为特定的包或流传播路由信息，那么应该设置TOS字段，该字段是为此开发的。</p> 
<p>目前互联网上有很多路由器在这方面做得很糟糕，所以到目前为止，在将包发送到互联网之前尝试对TOS进行篡改可能是有点无用的。路由器最多不会注意到TOS字段。在最坏的情况下，他们将查看TOS字段并做错误的事情。然而，如上所述，如果您有一个具有多个路由器的大型广域网或局域网，那么TOS字段绝对可以得到很好的利用。实际上，您可以根据数据包的TOS值为它们提供不同的路由和首选项——即使这可能局限于您自己的网络。</p> 
<p><strong>该目标仅在mangle table内有效，并且外部无法使用，它只有一个选项</strong></p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–set-tos</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING -p TCP --dport 22 -j TOS --set-tos 0x10</td></tr><tr><td>Explanation</td><td>The --set-tos option tells the TOS mangler what TOS value to set onpackets that are matched. The option takes a numeric value, either in hex or in decimal value. As the TOS value consists of 8 bits, the value may be 0-255, or in hex 0x00-0xFF. Note that in the standard TOS target you are limited to using the named values available (which should be more or less standardized), as mentioned in the previous warning. These values are Minimize-Delay (decimal value 16, hex value 0x10), Maximize-Throughput (decimal value 8, hex value 0x08), Maximize-Reliability (decimal value 4, hex value 0x04), Minimize-Cost (decimal value 2, hex 0x02) or Normal-Service (decimal value 0, hex value 0x00). The default value on most packets is Normal-Service, or 0. Note that you can, of course, use the actual names instead of the actual hex values to set the TOS value; in fact this is generally to be recommended, since the values associated with the names may be changed in future. For a complete listing of the “descriptive values”, do an iptables -j TOS -h.</td></tr></tbody></table> 
<h3><a id="126_TTL_target_364"></a>1.26 TTL target</h3> 
<p>TTL目标用来修改IP报头中的Time to Live字段。它的一个有用的应用是将所有的Time to Live值更改为所有传出包的相同值。这样做的一个原因是，如果你有一个强大的ISP，它不允许你有多台机器连接到同一个互联网连接，并且积极地追求这一点。将所有TTL值设置为相同的值，将有效地使它们更难注意到您正在这样做。然后，我们可以将所有传出数据包的TTL值重置为一个标准化的值，例如Linux内核中指定的64。</p> 
<p>该目标仅在mangle table 有效</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–ttl-set</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-set 64</td></tr><tr><td>Explanation</td><td>The --ttl-set option tells the TTL target which TTL value to set on the packet in question. A good value would be around 64 somewhere. It’s not too long, and it is not too short. Do not set this value too high, since it may affect your network and it is a bit immoral to set this value to high, since the packet may start bouncing back and forth between two mis-configured routers, and the higher the TTL, the more bandwidth will be eaten unnecessarily in such a case. This target could be used to limit how far away our clients are. A good case of this could be DNS servers, where we don’t want the clients to be too far away.</td></tr><tr><td>Option</td><td>–ttl-dec</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-dec 1</td></tr><tr><td>Explanation</td><td>The --ttl-dec option tells the TTL target to decrement the Time To Live value by the amount specified after the --ttl-dec option. In other words, if the TTL for an incoming packet was 53 and we had set --ttl-dec 3, the packet would leave our host with a TTL value of 49. The reason for this is that the networking code will automatically decrement the TTL value by 1, hence the packet will be decremented by 4 steps, from 53 to 49. This could for example be used when we want to limit how far away the people using our services are. For example, users should always use a close-by DNS, and hence we could match all packets leaving our DNS server and then decrease it by several steps. Of course, the --set-ttl may be a better idea for this usage.</td></tr><tr><td>Option</td><td>–ttl-inc</td></tr><tr><td>Example</td><td>iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-inc 1</td></tr><tr><td>Explanation</td><td>The --ttl-inc option tells the TTL target to increment the Time To Live value with the value specified to the --ttl-inc option. This means that we should raise the TTL value with the value specified in the --ttl-inc option, and if we specified --ttl-inc 4, a packet entering with a TTL of 53 would leave the host with TTL 56. Note that the same thing goes here, as for the previous example of the --ttl-dec option, where the network code will automatically decrement the TTL value by 1, which it always does. This may be used to make our firewall a bit more stealthy to trace-routes among other things. By setting the TTL one value higher for all incoming packets, we effectively make the firewall hidden from trace-routes. Trace-routes are a loved and hated thing, since they provide excellent information on problems with connections and where it happens, but at the same time, it gives the hacker/cracker some good information about your upstreams if they have targeted you. For a good example on how this could be used, see the Ttl-inc.txt script.</td></tr></tbody></table> 
<h3><a id="127_ULOG_target_381"></a>1.27 ULOG target</h3> 
<p>ULOG目标用于提供匹配数据包的用户空间日志记录。如果匹配到报文并设置了ULOG目标，则通过netlink套接字将报文信息与整个报文一起进行多播。然后，一个或多个用户空间进程可以订阅各种多播组并接收数据包。换句话说，这是一种更完整、更复杂的日志记录工具，到目前为止只被iptables和Netfilter使用，它包含了更好的日志包记录工具。这个目标使我们能够将信息记录到MySQL数据库和其他数据库，使搜索特定数据包和对日志条目进行分组变得更加简单。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Option</td><td>–ulog-nlgroup</td></tr><tr><td>Example</td><td>iptables -A INPUT -p TCP --dport 22 -j ULOG --ulog-nlgroup 2</td></tr><tr><td>Explanation</td><td>The --ulog-nlgroup option tells the ULOG target which netlink group to send the packet to. There are 32 netlink groups, which are simply specified as 1-32. If we would like to reach netlink group 5, we would simply write --ulog-nlgroup 5. The default netlink group used is 1.</td></tr><tr><td>Option</td><td>–ulog-prefix</td></tr><tr><td>Example</td><td>iptables -A INPUT -p TCP --dport 22 -j ULOG --ulog-prefix "SSH connection attempt: "</td></tr><tr><td>Explanation</td><td>The --ulog-prefix option works just the same as the prefix value for the standard LOG target. This option prefixes all log entries with a user-specified log prefix. It can be 32 characters long, and is definitely most useful to distinguish different log-messages and where they came from.</td></tr><tr><td>Option</td><td>–ulog-cprange</td></tr><tr><td>Example</td><td>iptables -A INPUT -p TCP --dport 22 -j ULOG --ulog-cprange 100</td></tr><tr><td>Explanation</td><td>The --ulog-cprange option tells the ULOG target how many bytes of the packet to send to the user-space daemon of ULOG. If we specify 100 as above, we would copy 100 bytes of the whole packet to user-space, which would include the whole header hopefully, plus some leading data within the actual packet. If we specify 0, the whole packet will be copied to user-space, regardless of the packets size. The default value is 0, so the whole packet will be copied to user-space.</td></tr><tr><td>Option</td><td>–ulog-qthreshold</td></tr><tr><td>Example</td><td>iptables -A INPUT -p TCP --dport 22 -j ULOG --ulog-qthreshold 10</td></tr><tr><td>Explanation</td><td>The --ulog-qthreshold option tells the ULOG target how many packets to queue inside the kernel before actually sending the data to user-space. For example, if we set the threshold to 10 as above, the kernel would first accumulate 10 packets inside the kernel, and then transmit it outside to the user-space as one single netlink multi part message. The default value here is 1 because of backward compatibility, the user-space daemon did not know how to handle multi-part messages previously.</td></tr></tbody></table> 
<h2><a id="_400"></a>二、参考</h2> 
<p><a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#ECNMATCH" rel="nofollow">iptalbes tutorial</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d26ce7c206b950646101baa27aaf355d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux环境MySQL数据库主从复制保姆级教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/954fcb9ce00f9047be20378a87570f0f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Kibana配置ES集群（版本号8.3.3）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>