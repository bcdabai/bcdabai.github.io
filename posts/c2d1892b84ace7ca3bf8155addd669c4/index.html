<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言 文本文件读取、写入与定位（详细介绍） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言 文本文件读取、写入与定位（详细介绍）" />
<meta property="og:description" content="目录
文本文件相关介绍
1.打开文件
2.文件的读取
(1) fgetc 函数
（2）fgets 函数
（3）fscanf 函数
（4）fread 函数
3.关闭文件
fclose(FILE *stream );
4.文件的写入
（1）fpuc 函数
（2）fputs 函数
（3）fprintf 函数
（4）fwrite 函数
5.文本文件的指针定位
（1）rewind 函数
（2）fseek 函数
有时候我们想通过编程语言来操作外部文件，对外部文件进行读取和修改、或者创建文件以此达到想要的目的。对此，我通过这篇文章来介绍如何通过C语言来操作文本文件。
文本文件相关介绍 文本文件是一种计算机文件，它是一种典型的顺序文件，其文件的逻辑结构又属于流式文件。特别的是，文本文件是指以ASCII码方式(也称文本方式)存储的文件，更确切地说，英文、数字等字符存储的是ASCII码，而汉字存储的是机内码。文本文件中除了存储文件有效字符信息(包括能用ASCII码字符表示的回车、换行等信息)外，不能存储其他任何信息。
文本文件常用格式：
（1）.txt 纯文字文档，不携带字体的颜色、类型、以及相关修饰格式。
（2）.doc 是Microsoft Word创建的格式化文件，一般用于图文排版。
（3）.pdf 具有良好的加密性，一般多用于企业办公。
（4）.doc与.docx .doc文件是旧版World文档旧版文件格式，.docx是新版格式。
（5）.ASCLL 指含有用标准ASCII字符集编码的字符的数据和文本文件。
平时我们可以打开记事本或者文档来直接写入内容，然后保存起来，这就成功创建了一个文本文件，那么怎么通过C语言来去创建并且写入内容呢？下面是相关文本函数的简介。
标准头文件：#include&lt;stdio.h&gt;
这里我的文件相对路径是 text.txt
1.打开文件 函数：
FILE *fopen(char *filename, *type);
这个函数是返回一个指针类型，如果文本读取成功就返回文本的地址，如果读取失败就返回NULL空指针。
*type是表示操作编码，比如 r 表示对文件的读取、w 表示对文件的写入
示例：
FILE *fp; fp=fopen(&#34;text.txt&#34;,&#34;r&#34;);//表示对文件的读取 2.文件的读取 读取的操作：fopen(&#34;text.txt&#34;,&#34;r&#34;);
(1) fgetc 函数 原型：int fgetc( FILE *stream );" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c2d1892b84ace7ca3bf8155addd669c4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-12T21:50:15+08:00" />
<meta property="article:modified_time" content="2023-02-12T21:50:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言 文本文件读取、写入与定位（详细介绍）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D" rel="nofollow">文本文件相关介绍</a></p> 
<p id="1.%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#1.%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6" rel="nofollow">1.打开文件</a></p> 
<p id="2.%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96-toc" style="margin-left:40px;"><a href="#2.%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96" rel="nofollow">2.文件的读取</a></p> 
<p id="%C2%A0(1)%20fgetc%20%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%281%29%20fgetc%20%E5%87%BD%E6%95%B0" rel="nofollow"> (1) fgetc 函数</a></p> 
<p id="%EF%BC%882%EF%BC%89fgets%20%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89fgets%20%E5%87%BD%E6%95%B0" rel="nofollow">（2）fgets 函数</a></p> 
<p id="%EF%BC%883%EF%BC%89fscanf%20%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89fscanf%20%E5%87%BD%E6%95%B0" rel="nofollow">（3）fscanf 函数</a></p> 
<p id="%EF%BC%884%EF%BC%89fread%20%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89fread%20%E5%87%BD%E6%95%B0" rel="nofollow">（4）fread 函数</a></p> 
<p id="3.%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#3.%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6" rel="nofollow">3.关闭文件</a></p> 
<p id="fclose(FILE%20*stream%20)%3B-toc" style="margin-left:80px;"><a href="#fclose%28FILE%20*stream%20%29%3B" rel="nofollow">fclose(FILE *stream );</a></p> 
<p id="4.%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5-toc" style="margin-left:40px;"><a href="#4.%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5" rel="nofollow">4.文件的写入</a></p> 
<p id="%EF%BC%881%EF%BC%89fpuc%20%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89fpuc%20%E5%87%BD%E6%95%B0" rel="nofollow">（1）fpuc 函数</a></p> 
<p id="%EF%BC%882%EF%BC%89fputs%20%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89fputs%20%E5%87%BD%E6%95%B0" rel="nofollow">（2）fputs 函数</a></p> 
<p id="%EF%BC%883%EF%BC%89fprintf%20%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89fprintf%20%E5%87%BD%E6%95%B0" rel="nofollow">（3）fprintf 函数</a></p> 
<p id="%EF%BC%884%EF%BC%89fwrite%20%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89fwrite%20%E5%87%BD%E6%95%B0" rel="nofollow">（4）fwrite 函数</a></p> 
<p id="5.%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E9%92%88%E5%AE%9A%E4%BD%8D-toc" style="margin-left:40px;"><a href="#5.%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E9%92%88%E5%AE%9A%E4%BD%8D" rel="nofollow">5.文本文件的指针定位</a></p> 
<p id="%EF%BC%881%EF%BC%89rewind%20%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89rewind%20%E5%87%BD%E6%95%B0" rel="nofollow">（1）rewind 函数</a></p> 
<p id="%C2%A0%EF%BC%882%EF%BC%89fseek%20%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%EF%BC%882%EF%BC%89fseek%20%E5%87%BD%E6%95%B0" rel="nofollow"> （2）fseek 函数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><strong>        有时候我们想通过编程语言来操作外部文件，对外部文件进行读取和修改、或者创建文件以此达到想要的目的。对此，我通过这篇文章来介绍如何通过C语言来操作文本文件。</strong></p> 
<p>       </p> 
<h3 id="%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D">文本文件相关介绍</h3> 
<p><strong><span style="color:#38d8f0;">文本文件是一种计算机文件，它是一种典型的顺序文件，其文件的逻辑结构又属于流式文件。特别的是，文本文件是指以ASCII码方式(也称文本方式)存储的文件，更确切地说，英文、数字等字符存储的是ASCII码，而汉字存储的是机内码。文本文件中除了存储文件有效字符信息(包括能用ASCII码字符表示的回车、换行等信息)外，不能存储其他任何信息。</span></strong></p> 
<blockquote> 
 <p><strong>文本文件常用格式：</strong></p> 
 <p>（1）.txt  纯文字文档，不携带字体的颜色、类型、以及相关修饰格式。</p> 
 <p>（2）.doc  是Microsoft Word创建的格式化文件，一般用于图文排版。</p> 
 <p>（3）.pdf 具有良好的加密性，一般多用于企业办公。</p> 
 <p>（4）.doc与.docx  .doc文件是旧版World文档旧版文件格式，.docx是新版格式。</p> 
 <p>（5）.ASCLL 指含有用标准ASCII<a href="https://baike.so.com/doc/201915-213495.html" rel="nofollow" title="字符集">字符集</a>编码的字符的数据和文本文件。</p> 
</blockquote> 
<p>平时我们可以打开记事本或者文档来直接写入内容，然后保存起来，这就成功创建了一个文本文件，那么怎么通过C语言来去创建并且写入内容呢？下面是相关文本函数的简介。</p> 
<p><strong>标准头文件</strong>：<strong><span style="color:#fe2c24;">#include&lt;stdio.h&gt;</span></strong></p> 
<p><strong>这里我的文件相对路径是 text.txt</strong></p> 
<h3 id="1.%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6">1.打开文件</h3> 
<blockquote> 
 <p>函数：</p> 
 <p><span style="color:#fe2c24;">FILE *fopen(char *filename, *type);</span></p> 
 <p>这个函数是返回一个指针类型，如果文本读取成功就返回文本的地址，如果读取失败就返回NULL空指针。</p> 
 <p>*type是表示操作编码，比如 r 表示对文件的读取、w 表示对文件的写入</p> 
</blockquote> 
<p> <img alt="" height="384" src="https://images2.imgbox.com/a0/1b/j2UtaZjG_o.png" width="901"></p> 
<p>示例：</p> 
<pre><code class="language-cs">FILE *fp;

fp=fopen("text.txt","r");//表示对文件的读取</code></pre> 
<p></p> 
<h3 id="2.%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96">2.文件的读取</h3> 
<p><strong>读取的操作：fopen("text.txt","r");</strong></p> 
<h4 id="%C2%A0(1)%20fgetc%20%E5%87%BD%E6%95%B0"> (1) <span style="color:#fe2c24;">fgetc </span>函数</h4> 
<blockquote> 
 <p>原型：int fgetc( FILE *stream );</p> 
 <p>返回值：如果读取成功就返回一个读取的字符（类似于getchar）,直到读取完成返回EOF（阿斯克码数值为-1）表示结束。每次是读取一个字符，读取完成后，文件指针向后移动一个位置。</p> 
</blockquote> 
<p> 示例如下：</p> 
<p><strong>已知我的文件内容</strong></p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/d2/2c/WUmY08tw_o.png" width="1133"></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;//exit()函数的头文件
int main()
{
	FILE* fp;
	fp = fopen("text.txt", "r");
	if (feof(fp))
	{
		printf("NULL");
		exit(0);//表示如果读取为空文件就正常退出
	}
	char a;
	a = fgetc(fp);
	printf("%c", a);//在控制台输出读取的字符
}</code></pre> 
<p><img alt="" height="166" src="https://images2.imgbox.com/72/7b/KBwhIukC_o.png" width="535"></p> 
<p> fgetc函数每次是读取一个字符，读取完成后文件指针向后移动一个位置，当下一次读取就是第二个字符对此我们可以通过循环来实现文件内容的全部读取。例如：</p> 
<pre><code class="language-cpp">	char a;
	for(; (a = fgetc(fp))!=EOF;)
	printf("%c", a);</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89fgets%20%E5%87%BD%E6%95%B0"><strong>（2）<span style="color:#fe2c24;">fgets </span>函数</strong></h4> 
<blockquote> 
 <p>原型：char *fgets( char *str, int numChars, FILE *stream );</p> 
 <p>参数：str表示字符串的地址，numChars表示要读取字符最大个数，stream表示文件的地址</p> 
 <p>返回值：将文件的字符传入到字符串str的地址，然后返回str地址。</p> 
</blockquote> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;//exit()函数的头文件
int main()
{
	FILE* fp;
	fp = fopen("text.txt", "r");
	if (feof(fp))
	{
		printf("NULL");
		exit(0);//表示如果读取为空文件就正常退出
	}
	char s[100];
	fgets(s, 10, fp);//最大读取10个
	printf("%s", s);
}
</code></pre> 
<p><img alt="" height="129" src="https://images2.imgbox.com/54/de/r3AmnNwj_o.png" width="899"></p> 
<p></p> 
<h4 id="%EF%BC%883%EF%BC%89fscanf%20%E5%87%BD%E6%95%B0">（3）<span style="color:#fe2c24;">fscanf </span>函数</h4> 
<blockquote> 
 <p> 原型：int fscanf( FILE *stream, const char *format , argument ... );</p> 
 <p>参数：steam是文件地址，format是表示输出的参数，argument是表示输出的内容。</p> 
 <p>返回值：返回包括读取成功转换并且分配的字段数，如果读取错误或者读取到文件的末尾就返回EOF。</p> 
</blockquote> 
<p> 读取输出字符串：</p> 
<pre><code class="language-cpp">char s[100];
	fscanf(fp, "%s", s);//将读取的内容导入字符串s的地址
	printf("%s", s);</code></pre> 
<p>读取输出单个字符： </p> 
<pre><code class="language-cpp">char a;
	fscanf(fp, "%c", &amp;a);//读取单个字符导入a的地址
	printf("%c", a);</code></pre> 
<p> 读取输出整数：</p> 
<pre><code class="language-cpp">	int b;
	fscanf(fp, "%d", &amp;b);
	printf("%d", b);</code></pre> 
<p>fscanf是一个比较通用的函数，可以输出单个字符，多个字符，整形等。</p> 
<p></p> 
<h4 id="%EF%BC%884%EF%BC%89fread%20%E5%87%BD%E6%95%B0">（4）<strong><span style="color:#fe2c24;">fread </span>函数</strong></h4> 
<blockquote> 
 <p>原型：size_t fread( void *buffer, size_t size, size_t count, FILE *stream );</p> 
 <p>参数：buffer表示读取的类型的地址，size_t size表示读取需要的字节数，size_t count表示读取的个数，stream表示文本文件地址</p> 
 <p>返回值：<strong><code>fread</code></strong> 返回函数读取的完整项数，该数目可能小于 <em><code>count</code></em> 发生错误的情况，或者在到达 <em><code>count</code></em>之前遇到文件的末尾。</p> 
</blockquote> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;//exit()函数的头文件
int main()
{
	FILE* fp;

	fp = fopen("text.txt", "r");
	if (feof(fp))
	{
		printf("NULL");
		exit(0);//表示如果读取为空文件就正常退出
	}
//魔鬼细节：使用fread函数读取有限个字符要对字符串进行初始化，也就是给字符串加上终止符
	char a[7] = { 0 };//实际上我要读取6个字符，但是我初始化要7个，最后一个是表示终止符
		fread(a, sizeof(char), 6, fp);
		printf("%s", a);
}</code></pre> 
<pre><code class="language-cpp">	char a[7] ;
	memset(a, 0, sizeof(a));//我们还可以通过memset 函数来进行初始化，其头文件是#include&lt;string.h&gt;
		fread(a, 1, 6, fp);
		printf("%s", a);</code></pre> 
<p> fread函数是一个非常灵活的函数，我们可以用它来自定义读取文件字符的个数类型等等。</p> 
<p></p> 
<h3 id="3.%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6">3.关闭文件</h3> 
<h4 id="fclose(FILE%20*stream%20)%3B"><span style="color:#fe2c24;">fclose(FILE *stream );</span></h4> 
<p><span style="color:#0d0016;">stream是文本文件地址</span></p> 
<pre><code class="language-cpp">fclose(fp);//fp是文本地址 FILE *fp</code></pre> 
<p></p> 
<h3 id="4.%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5"><strong>4.文件的写入</strong></h3> 
<p><strong>写入的操作：fopen("text.txt","w");</strong></p> 
<p><span style="color:#fe2c24;"><strong>注意事项：写入文件后要关闭文件，否则文件内容可能会丢失。</strong></span></p> 
<h4 id="%EF%BC%881%EF%BC%89fpuc%20%E5%87%BD%E6%95%B0">（1）<span style="color:#fe2c24;">fpuc </span>函数</h4> 
<blockquote> 
 <p> 原型：int fputc( int c, FILE *stream );</p> 
 <p>参数：c表示要写入的字符，stream表示文件地址。</p> 
 <p>返回值：返回值是写入的一个字符，当返回EOF表示一个错误，结束写入。</p> 
 <p><span style="color:#fe2c24;">注意：</span>写入内容后，之前的内容会被销毁。</p> 
</blockquote> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;//exit()函数的头文件
int main()
{
	FILE* fp;

	fp = fopen("text.txt", "w");
	if (feof(fp))
	{
		printf("NULL");
		exit(0);//表示如果读取为空文件就正常退出
	}
	fputc('s', fp);//写入一个字符s
fclose(fp);
}</code></pre> 
<p>此时会发现运行结果控制台是没有什么显示的，我们可以去打开text文本文件去查看结果</p> 
<p><img alt="" height="278" src="https://images2.imgbox.com/6a/e8/tn17xcMq_o.png" width="1198"></p> 
<pre><code class="language-cpp">//类似于fgetc函数，我们也可以用循环来写入多字字符
char ch[10];
	scanf("%s", ch);
	for (int i = 0; ch[i]!='\0'; i++)
		fputc(ch[i], fp);</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89fputs%20%E5%87%BD%E6%95%B0">（2）<span style="color:#fe2c24;">fputs </span>函数</h4> 
<blockquote> 
 <p>原型：int fputs( const char *str, FILE *stream );</p> 
 <p>参数：str表示字符串，stream表示文件地址</p> 
 <p>返回值：如果每个函数成功，则返回非负值，即写入的字符串。 发生错误时，<strong><code>fputs</code></strong>  将返回 <code>EOF。</code></p> 
</blockquote> 
<p> 示例：</p> 
<pre><code class="language-cpp">fputs("china", fp);
//或者
char s[10];
scanf("%s,s);
fputs(s, fp);</code></pre> 
<h4 id="%EF%BC%883%EF%BC%89fprintf%20%E5%87%BD%E6%95%B0">（3）<span style="color:#fe2c24;">fprintf </span>函数</h4> 
<blockquote> 
 <p> 原型：int fprintf( FILE *stream, const char *format , argument ... );</p> 
 <p>参数：steam是文件地址，format是表示输出的参数，argument是表示输出的内容。</p> 
 <p>返回值：<strong><code>fprintf</code></strong> 返回已写入的字节数，如果输入错误就返回EOF表示输入结束。</p> 
</blockquote> 
<pre><code class="language-cpp">for(int i=0;i&lt;10;i++)
	fprintf(fp, "%d", i);//写入0~9</code></pre> 
<pre><code class="language-cpp">//字符串写入
char ch[20];
	scanf("%s", ch);
	fprintf(fp, "%s", ch);</code></pre> 
<h4 id="%EF%BC%884%EF%BC%89fwrite%20%E5%87%BD%E6%95%B0">（4）<span style="color:#fe2c24;">fwrite</span> 函数</h4> 
<blockquote> 
 <p> 原型：size_t fwrite( const void *buffer, size_t size, size_t count, FILE *stream );</p> 
 <p>参数：buffer表示读取的类型的地址，size_t size表示读取需要的字节数，size_t count表示读取的个数，stream表示文本文件地址。</p> 
 <p>返回值：<strong><code>fwrite</code></strong> 返回函数写入的完整项数，这可能小于 <em><code>count</code></em> 发生错误的情况。</p> 
</blockquote> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;//exit()函数的头文件
int main()
{
	FILE* fp;

	fp = fopen("text.txt", "w");
	if (feof(fp))
	{
		printf("NULL");
		exit(0);//表示如果读取为空文件就正常退出
	}
	int a[10];
	for (int i = 0; i &lt; 10; i++)//写入10个数字的数组
		scanf("%d", &amp;a[i]);
	for (int i = 0; i &lt; 10; i++)
		fwrite(&amp;a[i],sizeof(int),1,fp);
}</code></pre> 
<p><img alt="" height="209" src="https://images2.imgbox.com/b8/6a/6GkA8Jov_o.png" width="709"></p> 
<p><strong> 别惊讶，写入的结果不是数字，因为fwrite写入的内容会转换成阿斯克码字符，随机数在文件里面显示的应该是字符，而不是数字，所以会出现这些识别不了的符号。</strong></p> 
<p></p> 
<h3 id="5.%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E9%92%88%E5%AE%9A%E4%BD%8D">5.文本文件的指针定位</h3> 
<h4 id="%EF%BC%881%EF%BC%89rewind%20%E5%87%BD%E6%95%B0">（1）<span style="color:#fe2c24;">rewind </span>函数</h4> 
<blockquote> 
 <p>原型：void rewind(FILE *stream)</p> 
 <p>参数：stream是文件地址.</p> 
 <p>功能：将文本文件的指针返回到文本的开始位置。</p> 
</blockquote> 
<p> 示例：</p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/59/8e/USngNCRS_o.png" width="836"></p> 
<h4 id="%C2%A0%EF%BC%882%EF%BC%89fseek%20%E5%87%BD%E6%95%B0"> （2）<span style="color:#fe2c24;">fseek </span>函数</h4> 
<blockquote> 
 <p>原型：int fseek( FILE *stream, long offset, int origin );</p> 
 <p>参数：stream文本地址，offset表示移动的字节数（正数表示指针往右移，负数表示往左移）, origin表示初始位置。</p> 
 <p>功能：我们可以通过fseek函数来初始化指针的位置，然后进行读取或者写入。</p> 
</blockquote> 
<p> origin 初始位置的值如下，及其相应的功能<img alt="" height="203" src="https://images2.imgbox.com/b7/ec/W3IUE0mJ_o.png" width="921"></p> 
<p> <strong>示例：怎么去读取最后一行的字符串？</strong></p> 
<p>已知文件的内容：</p> 
<p><img alt="" height="293" src="https://images2.imgbox.com/ae/cc/yVqAXBd6_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;//exit()函数的头文件
int main()
{
	FILE* fp;

	fp = fopen("text.txt", "r");
	if (feof(fp))
	{
		printf("NULL");
		exit(0);//表示如果读取为空文件就正常退出
	}
	char a='a';
	fseek(fp, -1, SEEK_END);//把文件指针移动到文本末尾
	for (;a!='\n';)
	{
		a = fgetc(fp);//依次读取
		fseek(fp, -sizeof(char), SEEK_CUR);//由于每次读取了一个字符，文件指针会往后移动一个位置，所以要-2，从而实现在原先的基础上往上移动一个位置
	}
	fseek(fp,2, SEEK_CUR);//最后一次移动是在'\n'上面两个（字节）位置，所以要在次基础上向后移动两个位置
	char s[200] = { 0 };
	fgets(s,200, fp);
	puts(s);
	fclose(fp);
}</code></pre> 
<p>结果如下：</p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/d3/3f/ZG6Da4bE_o.png" width="838"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e43537b6da0a307a90092a66199d0cd9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">输入一个大于 2 的自然数，输出小于该数字的所有素数组成的集合。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d2444dac1d43752fa86274797d504d6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一些简单的Linux命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>