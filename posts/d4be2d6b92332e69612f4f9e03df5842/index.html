<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构复习 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构复习" />
<meta property="og:description" content="第一次测试 第一章 绪论 数据元素是数据的基本单位。数据项是是组成数据元素的最小单位。数据对象是性质相同的数据元素的集合。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。①逻辑结构：线性结构，树结构，图结构。数据类型是一个值的集合和定义在这个值集上的一组操作的总称。抽象数据类型ADT。
算法的时间复杂度：取决于问题的规模和待处理数据的初态。 由嵌套层次最深的语句的频度决定的。空间复杂度：对数据进行操作的辅助存储空间。
1.NlogN^2和NlogN具有相同的增长速度。T NlogN^2=2NlogN≈NlogN 2.N^2logN和NlogN^2具有相同的增长速度。F
3.(NlogN)/1000是O(N)的。F O(NlogN)&gt;O(N)NlogN的增长速度大于N的增长速度，A是B的说明A的增长速度小于B
4.N^2/1000是O(N)的。F A是B的说明A的增长速度小于B,根据函数图像来判断
5.100logN是O(N)的。T
6.
求整数n(n&gt;=0)的阶乘的算法如下，其时间复杂度为（ ）。
long fact(long n) { if (n&lt;=1) return 1； return n*fact(n-1)； } C.Θ(n) 基本语句为n*fact(n-1)；执行次数为n次、
7.
下列代码
for(i=0; i&lt;n; i&#43;&#43;) for(j=i; j&gt;0; j/=2) printf(“%d\n”, j); 的时间复杂度是：D.O(NlogN) 我不知道呀
8.
下面程序段的时间复杂度是（）。
x=90; y=100; while(y&gt;0) if(x&gt;100) { x=x-10; y--; } else x&#43;&#43;;A.O(1) 根据代码可知，语句都是只执行l一次 9.下列代码
if ( A &gt; B ) { for ( i=0; i&lt;N; i&#43;&#43; ) for ( j=N*N; j&gt;i; j-- ) A &#43;= B; } else { for ( i=0; i&lt;N*2; i&#43;&#43; ) for ( j=N*2; j&gt;i; j-- ) A &#43;= B; } 的时间复杂度是：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d4be2d6b92332e69612f4f9e03df5842/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-05T07:36:00+08:00" />
<meta property="article:modified_time" content="2022-07-05T07:36:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构复习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>第一次测试</h3> 
<h4>第一章 绪论</h4> 
<p><span style="color:#fe2c24;">数据元素</span>是<span style="color:#494949;">数据</span>的<span style="color:#fe2c24;">基本</span>单位。<span style="color:#fe2c24;">数据项</span>是是组成数据元素的<span style="color:#fe2c24;">最小</span>单位。<span style="color:#fe2c24;">数据对象</span>是<span style="color:#fe2c24;">性质相同</span>的数据元素的集合。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。①逻辑结构：线性结构，树结构，图结构。数据类型是一个值的集合和定义在这个值集上的一组操作的总称。抽象数据类型ADT。</p> 
<p>算法的时间复杂度：取决于问题的规模和待处理数据的初态。 由嵌套层次最深的语句的频度决定的。空间复杂度：对数据进行操作的辅助存储空间。</p> 
<p>1.NlogN^2和NlogN具有相同的增长速度。<span style="color:#fe2c24;">T</span>     <em>NlogN</em>^<em>2</em>=<em>2NlogN≈</em>NlogN   </p> 
<p>2.N^2logN和NlogN^2具有相同的增长速度。<span style="color:#fe2c24;">F</span></p> 
<p>3.(NlogN)/1000是O(N)的。<span style="color:#fe2c24;">F     O(NlogN)&gt;O(N)NlogN的增长速度大于N的增长速度，A是B的说明A的增长速度小于B</span></p> 
<p><span style="color:#0d0016;">4.</span>N^2/1000是O(N)的。<span style="color:#fe2c24;">F</span>        <span style="color:#fe2c24;">A是B的说明A的增长速度小于B,根据函数图像来判断</span></p> 
<p><span style="color:#0d0016;">5.</span>100logN是O(N)的。<span style="color:#fe2c24;">T</span></p> 
<p><span style="color:#0d0016;">6.</span></p> 
<p>求整数n(n&gt;=0)的阶乘的算法如下，其时间复杂度为（ ）。</p> 
<pre><code>long fact(long n)
{
if (n&lt;=1) return 1；
return n*fact(n-1)；
}</code></pre> 
<p>C.Θ(n)             基本语句为n*fact(n-1)；执行次数为n次、</p> 
<p>7.</p> 
<p><span style="background-color:#ffd900;">下列代码</span></p> 
<pre><code>for(i=0; i&lt;n; i++)
  for(j=i; j&gt;0; j/=2)
     printf(“%d\n”, j);
</code></pre> 
<p>的<span style="background-color:#ffd900;">时间复杂度是：</span><span style="color:#fe2c24;">D.O(NlogN)  <span style="background-color:#ffd900;"> 我不知道呀</span></span></p> 
<p><span style="color:#0d0016;">8.</span></p> 
<p>下面程序段的时间复杂度是（）。</p> 
<pre><code>x=90; y=100; while(y&gt;0) if(x&gt;100) { x=x-10; y--; } else x++;</code>A.O(1)    根据代码可知，语句都是只执行l一次</pre> 
<p>9.下列代码</p> 
<pre><code>if ( A &gt; B ) {
    for ( i=0; i&lt;N; i++ )
        for ( j=N*N; j&gt;i; j-- )
            A += B;
}
else {
    for ( i=0; i&lt;N*2; i++ )
        for ( j=N*2; j&gt;i; j-- )
            A += B;
}
</code></pre> 
<p>的时间复杂度是：</p> 
<p>C.O(N3)</p> 
<p>10.素数一般指质数。质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的</p> 
<p>自然数</p> 
<pre><code>//要判断一个整数N（&gt;10）是否素数，我们需要检查3到 sqrt(N)之间是否存在奇数可以整除N。则这个算法的时间复杂度是：
int N;
scanf("%d",&amp;N);
for(int i=3;i&lt;=sqrt(N);i++)
{
	if.......
}</code></pre> 
<p>可以理解成循环sqrt(N)次</p> 
<p><span style="background-color:#ffd900;">要判断一个整数N（&gt;10）是否素数，我们需要检查3到N​之间是否存在奇数可以整除N。则这个算法的时间复杂度是：A.O(sqrt(N)​)</span></p> 
<p>第二章   线性表</p> 
<p>1.顺序表中第一个元素的存储地址是<span style="color:#fe2c24;">s</span>100，每个元素的长度为<span style="color:#fe2c24;"><strong>L</strong></span>2，则第5<span style="color:#fe2c24;">n</span>个元素的地址<span style="color:#fe2c24;">T</span>是（ ）。T=s+(n-1)*L</p> 
<p>2.若设一个顺序表的长度为n，那么，在表中顺序查找一个值为x的元素时，在等概率的情况下，查找成功的数据平均比较次数为<span style="color:#ed7976;"> (n+1)/2</span>。<span style="color:#ed7976;">P27</span></p> 
<p>3.在向表中第i个元素（1≤i≤n+1）位置插入一个新元素时，为保持插入后表中原有元素的相对次序不变，需要从后向前依次后移   <span style="color:#ed7976;">n-i+1</span>个元素。<span style="color:#ed7976;">n-(i-1)  共n个元素，前i-1个元素不用动</span></p> 
<p>4.在删除表中第i个元素时，同样地，为保持删除后表中原有元素的相对次序不变，需要从前向后依次前移<span style="color:#ed7976;">n-i</span>个元素。要被删除的第i个元素不用变。让后面的把他覆盖就行</p> 
<p>5.</p> 
<blockquote> 
 <p>#include&lt;stdio.h&gt;<br> #include&lt;stdlib.h&gt;//前面的std都是一样的   lib  lib  lib  lib <br> #define MAXSIZE 100<br> typedef struct <br> {<!-- --><br>     int *elem;//存储空间的基地址。数组指针elem指示顺序表的基地址 <br>     int length;//顺序表的实际长度，可确定不同的顺序表 <br> }SqList;</p> 
 <p><br> //顺序表的初始化函数<br> void InitList(SqList *L,int n)//长度为n，要改变顺序表L，<br> //形参为指针变量 ，l是指向顺序表的指针 <br> {<!-- --><br>     L-&gt;elem=(int*)malloc(sizeof(int)*n);<br>     //L-&gt;elem=(指针类型)malloc(sizeof(原类型int)*n(构造n个整型元素的顺序表空间));<br>     L-&gt;length=n;<br>     for(int i=0;i&lt;n;i++)<br>     {<!-- --><br>         scanf("%d",&amp;L-&gt;elem[i]);<br>         //此处&amp;为取地址符，与日常的输入语句一样   scanf("%d",&amp;x);<br>     }<br> } </p> 
 <p><br> //顺序表的取值操作,取第i个元素 <br> int GetElem(SqList L,int i,int *e)//要改变主函数中e的值 <br> {<!-- --><br>     //首先判断i值是否合理，若不合理，返回0<br>     if(i&lt;1||i&gt;L.length)     return 0;//return是结束了整个函数，不再往下执行<br>     e=L.elem[i-1];<br>     return 1; <br>  } <br>  <br>  <br>  //顺序表的查找操作,查找元素e,返回位置序号<br>  int LocateElem(SqList L,ElemType e)<br>  {<!-- --><br>      //首先判定查找(指定元素)操作的不合法性：无<br>      int i=0;<br>      for(;i&lt;L-&gt;length;i++)<br>      {<!-- --><br>          if(L.elem[i]==e)<br>          return i+1;<br>     }<br>     return 0;<br>  }<br>  <br>  //顺序表的插入(后移)操作,在第i个元素的位置(下标为i-1)，插入元素e <br>  int ListInsert(SqList &amp;L,int i,ElemType e);<br>  {//用的是结构体指针变量，访问成员用箭头运算符 还是用点 ?<br>  <br>      //先判断插入位置是否合法，在最后一个元素的后面插入也是合法的 <br>      if(i&lt;1||i&gt;L.length+1) return 0; <br>      //还有存储空间已满否<br>      if(L.length==MAXSIZE) <br>        return 0; <br>      int j;<br>     for(j=L.length-1;j&gt;=i-1;j--)<br>     {<!-- --><br>         L.elem[j+1]=L.elem[j];<br>      } <br>      L.elem[i-1]=e;//第i个元素的位置(下标为i-1)<br>      L.length++;<br>      return 1;<br>  }<br>  <br>  <br>  int ListDelete(SqList &amp;L,int i)<br>  {<!-- --><br>      //先看删除的位置是否合法<br>      if(i&lt;1||i&gt;L.length)  return 0;//合法性判断 <br>      int j;<br>      for(j=i-1;j&lt;L.length;j++)<br>      {<!-- --><br>          L.elem[j]=L.elem[j+1];<br>       } <br>       //别忘了顺序表长度的变化<br>     L.length--;<br>      return 1;<br>  }</p> 
</blockquote> 
<h4>链表</h4> 
<p>1.某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用什么存储方式最节省运算时间？     <span style="color:#ed7976;">仅有尾指针的单循环链表</span></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2e7eed5373a7b6e73154b3c114c08dd9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">栈与队列 循环队列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f65077b90048201649110ebf92cfcaac/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MyBatis-plus中的Page出现返回total总为0的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>