<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言零基础项目：打地鼠，详细思路&#43;源码分享 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言零基础项目：打地鼠，详细思路&#43;源码分享" />
<meta property="og:description" content="程序简介 打地鼠，点击鼹鼠的小游戏。游戏界面是仿照 unity 书上的素材绘制的。纯手工绘制，不添加任何图片。
我喜欢打地鼠游戏，因为了解这个游戏，又有书配套的素材，我最先想的便是制作它。
相比于之前，这次重新制作，更新了一些东西。
添加了红眼鼹鼠，点击红眼鼹鼠会对分数产生特殊增减效果。鼹鼠是自己画的，所以如果愿意的话，可以有各种各样颜色的鼹鼠。增加这个功能的原意是代替“炸弹”。
游戏图片素材改为“手绘”，这是因为这个游戏素材不多，比较简单。遇到复杂游戏肯定还是要用图片，将程序和美工分开^-^。
代码更新，现在兼容 vc2010
vc2010：_stscanf_s，vc6.0：_stscanf
vc2010：_stprintf_s，vc6.0：_stprintf
程序运行展示 // 游戏进程头文件 // # include &lt;graphics.h&gt; # include &lt;string&gt; # include &lt;time.h&gt; # include &lt;stdlib.h&gt; // 头文件 // 头文件编译开始 #ifndef CIRCLE_H #define CIRCLE_H // 定义变量 static HWND hOut; // 画布 // 定义一个结构体，地洞 struct Node1 { int boxnum; // 地洞编号 int posx_hole, posy_hole; // 地洞坐标 int posx_gopher, posy_gopher; // 鼹鼠坐标 int time_life; // 剩余时间 int type; // 地洞状态 }; // 定义一个结构体，按钮 struct Node2 { int posx1, posy1, posx2, posy2; // 坐标 double r; // 圆按钮半径 LPTSTR text; // 按钮文本 int type; // 按钮激活状态 }; // 定义一个类，game class game { public: int carry_main (); // 游戏进程主循函数 void draw_button (); // 按钮绘制函数 void draw_word (double size, int posx, int posy, LPTSTR text); // 标题绘制函数 void creact_gopher (); // 生成鼹鼠函数 void draw_cloud (double posx, double posy, double size); // 云朵绘制函数 void draw_left_railing (double posx, double posy, double size); // 左栏杆绘制函数 void draw_left_fence (double posx, double posy, double size); // 左栅栏绘制函数 void draw_right_railing (double posx, double posy, double size); // 右栏杆绘制函数 void draw_right_fence (double posx, double posy, double size); // 右栅栏绘制函数 void draw_gopher (double posx, double posy, double size, int flag); // 鼹鼠绘制函数 void draw_hole (double posx, double posy, double size); // 地洞绘制函数 void carry_prepare (); // 准备进程主循函数 void initialization_prepare (); // 准备进程初始化函数 void draw_scene_prepare (); // 准备进程绘制函数 void carry_start (); // 开始进程主循函数 void initialization_start (); // 开始进程初始化函数 void draw_scene_start (); // 开始进程绘制函数 Node1 box[10]; // 地洞，预制 Node2 boxm[20]; // 按钮，预制 int num_button; // 按钮数量 int exit_carry; // 主进程主循函数控制参数 int exit_start; // 开始进程主循函数控制参数 int start_endtime; // 结束时间参数 int start_point; // 分数参数 int speed_creact; // 生成时间间隔参数 int speed_gopher_life; // 鼹鼠存在时间参数 int speed_gopher_beaten; // 鼹鼠被击打后僵直时间参数 int hole_full_end; // 溢满是否结束控制参数 int gopher_red_eye_num; // 红眼数量参数 int point_punishment; // 点击红眼得分改变参数 int every_creact_num; // 每次生成数量 clock_t start_t1; // 游戏开始系统时间参数 clock_t start_t2; // 游戏进行系统时间参数 }; // 头文件编译结束 #endif // 主程序源文件 // // 窗口初始化 void initialization () { // 窗口定义，整个程序仅定义一次 hOut = initgraph (800, 480); // 窗口标题 SetWindowText (hOut, _T (&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4cdf2c59bef87c852e8fae132da84ab7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-16T15:02:27+08:00" />
<meta property="article:modified_time" content="2023-02-16T15:02:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言零基础项目：打地鼠，详细思路&#43;源码分享</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">程序简介</span></h2> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">打地鼠，点击鼹鼠的小游戏。游戏界面是仿照 unity 书上的素材绘制的。纯手工绘制，不添加任何图片。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">我喜欢打地鼠游戏，因为了解这个游戏，又有书配套的素材，我最先想的便是制作它。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">相比于之前，这次重新制作，更新了一些东西。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">添加了红眼鼹鼠，点击红眼鼹鼠会对分数产生特殊增减效果。鼹鼠是自己画的，所以如果愿意的话，可以有各种各样颜色的鼹鼠。增加这个功能的原意是代替“炸弹”。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">游戏图片素材改为“手绘”，这是因为这个游戏素材不多，比较简单。遇到复杂游戏肯定还是要用图片，将程序和美工分开^-^。</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">代码更新，现在兼容 vc2010</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">vc2010：_stscanf_s，vc6.0：_stscanf</span></p> 
 <p style="text-align:left;"><span class="kdocs-fontSize" style="font-size:9pt;">vc2010：_stprintf_s，vc6.0：_stprintf</span></p> 
 <h2 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">程序运行展示</span></h2> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:62.972977%;height:0;"> 
    <img src="https://images2.imgbox.com/fb/6c/8Uu6UnfQ_o.gif" style="margin-left:;display:block;width:740px;margin-top:-62.972977%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">


// 游戏进程头文件 //


# include &lt;graphics.h&gt;
# include &lt;string&gt;
# include &lt;time.h&gt;
# include &lt;stdlib.h&gt;


// 头文件
// 头文件编译开始
#ifndef CIRCLE_H
#define CIRCLE_H


// 定义变量
static HWND hOut;                    // 画布


// 定义一个结构体，地洞
struct Node1
{
    int boxnum;                        // 地洞编号
    int posx_hole, posy_hole;        // 地洞坐标
    int posx_gopher, posy_gopher;    // 鼹鼠坐标
    int time_life;                    // 剩余时间
    int type;                        // 地洞状态
};


// 定义一个结构体，按钮
struct Node2
{
    int posx1, posy1, posx2, posy2;    // 坐标
    double r;                        // 圆按钮半径
    LPTSTR text;                    // 按钮文本
    int type;                        // 按钮激活状态
};


// 定义一个类，game
class game
{
public:
    int carry_main ();                                                    // 游戏进程主循函数
    void draw_button ();                                                // 按钮绘制函数
    void draw_word (double size, int posx, int posy, LPTSTR text);        // 标题绘制函数
    void creact_gopher ();                                                // 生成鼹鼠函数
    void draw_cloud (double posx, double posy, double size);            // 云朵绘制函数
    void draw_left_railing (double posx, double posy, double size);        // 左栏杆绘制函数
    void draw_left_fence (double posx, double posy, double size);        // 左栅栏绘制函数
    void draw_right_railing (double posx, double posy, double size);    // 右栏杆绘制函数
    void draw_right_fence (double posx, double posy, double size);        // 右栅栏绘制函数
    void draw_gopher (double posx, double posy, double size, int flag);    // 鼹鼠绘制函数
    void draw_hole (double posx, double posy, double size);                // 地洞绘制函数
    void carry_prepare ();                                                // 准备进程主循函数
    void initialization_prepare ();                                        // 准备进程初始化函数    
    void draw_scene_prepare ();                                            // 准备进程绘制函数
    void carry_start ();                                                // 开始进程主循函数
    void initialization_start ();                                        // 开始进程初始化函数
    void draw_scene_start ();                                            // 开始进程绘制函数
    Node1 box[10];                                                        // 地洞，预制
    Node2 boxm[20];                                                        // 按钮，预制
    int num_button;                                                        // 按钮数量
    int exit_carry;                                                        // 主进程主循函数控制参数
    int exit_start;                                                        // 开始进程主循函数控制参数
    int start_endtime;                                                    // 结束时间参数
    int start_point;                                                    // 分数参数
    int speed_creact;                                                    // 生成时间间隔参数
    int speed_gopher_life;                                                // 鼹鼠存在时间参数
    int speed_gopher_beaten;                                            // 鼹鼠被击打后僵直时间参数
    int hole_full_end;                                                    // 溢满是否结束控制参数
    int gopher_red_eye_num;                                                // 红眼数量参数
    int point_punishment;                                                // 点击红眼得分改变参数
    int every_creact_num;                                                // 每次生成数量        
    clock_t start_t1;                                                    // 游戏开始系统时间参数
    clock_t start_t2;                                                    // 游戏进行系统时间参数
};


// 头文件编译结束
#endif


// 主程序源文件 //


// 窗口初始化
void initialization ()
{
    // 窗口定义，整个程序仅定义一次
    hOut = initgraph (800, 480);
    // 窗口标题
    SetWindowText (hOut, _T ("打地鼠"));
}


// 总进程主循函数
void carry ()
{
    // 总进程参数初始化
    int exit_carry = 0;
    // 进程控制
    BeginBatchDraw ();
    // 创建游戏类对象
    game G;
    // 游戏进程
    while (exit_carry == 0)
    {
        // 执行游戏总进程，并接收游戏进程结束时返回值
        // 准备进程时，点击退出按钮结束返回 1
        // 开始进程时，点击返回按钮结束返回 0
        exit_carry = G.carry_main ();
    }
    EndBatchDraw ();
    // 关闭窗口
    closegraph ();
}


// 主函数
int main (void)
{
    // 初始化
    initialization ();
    // 总进程主循函数
    carry ();
    return 0;
}


// 游戏进程源文件 //



// 游戏进程主循函数
int game::carry_main ()
{
    // 游戏进程参数初始化
    exit_carry = 0;
    // 随机种子初始化
    srand ((unsigned)time (NULL));
    // 游戏难度参数初始化
    speed_creact = 5;
    speed_gopher_life = 30;
    speed_gopher_beaten = 10;
    gopher_red_eye_num = 5;
    point_punishment = -5;
    every_creact_num = 1;
    // 溢满参数初始化
    hole_full_end = 0;
    // 准备进程初始化函数
    initialization_prepare ();
    // 准备进程主循函数
    carry_prepare ();
    // 准备进程结束
    // 准备进程时，点击退出按钮结束，游戏进程参数为 1
    // 准备进程时，正常进入游戏，游戏进程参数为 0
    if (exit_carry == 0)
    {
        // 开始进程初始化函数
        initialization_start ();
        // 开始进程主循函数
        carry_start ();
    }
    // 开始进程结束
    // 点击返回按钮结束，或者正常游戏结束，游戏进程参数不变
    return exit_carry;
}


// 按钮绘制函数
void game::draw_button ()
{
    // 根据颜色结构体设置参数
    setlinecolor (RGB (125, 125, 125));
    setfillcolor (RGB (88, 88, 88));
    setbkcolor (RGB (88, 88, 88));
    settextcolor (RGB (250, 250, 250));
    settextstyle (30, 15, _T ("Consolas"));
    setlinestyle (PS_SOLID, 10);

    // 根据按钮数量参数绘制
    for (int i = 0; i &lt; num_button; i++)
    {
        if (boxm[i].type == 0)
        {
            // 边框
            fillroundrect (boxm[i].posx1, boxm[i].posy1, boxm[i].posx2, boxm[i].posy2, 25, 25);
            // 文字
            outtextxy (boxm[i].posx1 + (boxm[i].posx2 - boxm[i].posx1) / 2 - textwidth (boxm[i].text) / 2, boxm[i].posy1 + 15, boxm[i].text);
        }
    }
    FlushBatchDraw ();
}


// 文字绘制函数
void game::draw_word (double size, int posx, int posy, LPTSTR text)
{
    int i, j;

    // 参数设置，填充透明
    setbkmode (TRANSPARENT);
    settextstyle (int (size), int (size / 5 * 2), _T ("Consolas"));

    // 背景色的反色
    settextcolor (BLACK);
    // 范围绘制，构造阴影
    for (i = posx - 3; i &lt;= posx + 3; i++)
    {
        for (j = posy - 3; j &lt;= posy + 3; j++)
        {
            outtextxy (i, j, text);
        }
    }

    // 背景色
    settextcolor (WHITE);
    // 在阴影中绘制
    outtextxy (posx, posy, text);

    // 恢复填充
    setbkmode (OPAQUE);
    FlushBatchDraw ();
}


// 地洞绘制函数
void game::draw_hole (double posx, double posy, double size)
{
    POINT pts[100];

    setlinestyle (PS_SOLID, 2);
    // 设置
    setlinecolor (RGB (137, 98, 49));
    setfillcolor (RGB (193, 139, 79));
    pts[0].x = long (-236 * size + posx);    pts[0].y = long (-204 * size + posy);
    pts[1].x = long (-220 * size + posx);    pts[1].y = long (-235 * size + posy);
    pts[2].x = long (-187 * size + posx);    pts[2].y = long (-249 * size + posy);
    pts[3].x = long (-154 * size + posx);    pts[3].y = long (-256 * size + posy);
    pts[4].x = long (-106 * size + posx);    pts[4].y = long (-247 * size + posy);
    pts[5].x = long (-51 * size + posx);    pts[5].y = long (-243 * size + posy);
    pts[6].x = long (-25 * size + posx);    pts[6].y = long (-250 * size + posy);
    pts[7].x = long (13 * size + posx);    pts[7].y = long (-282 * size + posy);
    pts[8].x = long (52 * size + posx);    pts[8].y = long (-292 * size + posy);
    pts[9].x = long (90 * size + posx);    pts[9].y = long (-285 * size + posy);
    pts[10].x = long (97 * size + posx);    pts[10].y = long (-267 * size + posy);
    pts[11].x = long (118 * size + posx);    pts[11].y = long (-248 * size + posy);
    pts[12].x = long (150 * size + posx);    pts[12].y = long (-238 * size + posy);
    pts[13].x = long (185 * size + posx);    pts[13].y = long (-256 * size + posy);
    pts[14].x = long (213 * size + posx);    pts[14].y = long (-276 * size + posy);
    pts[15].x = long (254 * size + posx);    pts[15].y = long (-287 * size + posy);
    pts[16].x = long (287 * size + posx);    pts[16].y = long (-279 * size + posy);
    pts[17].x = long (325 * size + posx);    pts[17].y = long (-264 * size + posy);
    pts[18].x = long (342 * size + posx);    pts[18].y = long (-209 * size + posy);
    pts[19].x = long (328 * size + posx);    pts[19].y = long (-199 * size + posy);
    pts[20].x = long (306 * size + posx);    pts[20].y = long (-202 * size + posy);
    pts[21].x = long (271 * size + posx);    pts[21].y = long (-213 * size + posy);
    pts[22].x = long (246 * size + posx);    pts[22].y = long (-209 * size + posy);
    pts[23].x = long (217 * size + posx);    pts[23].y = long (-199 * size + posy);
    pts[24].x = long (186 * size + posx);    pts[24].y = long (-196 * size + posy);
    pts[25].x = long (143 * size + posx);    pts[25].y = long (-197 * size + posy);
    pts[26].x = long (101 * size + posx);    pts[26].y = long (-204 * size + posy);
    pts[27].x = long (60 * size + posx);    pts[27].y = long (-228 * size + posy);
    pts[28].x = long (47 * size + posx);    pts[28].y = long (-241 * size + posy);
    pts[29].x = long (26 * size + posx);    pts[29].y = long (-223 * size + posy);
    pts[30].x = long (2 * size + posx);    pts[30].y = long (-204 * size + posy);
    pts[31].x = long (-14 * size + posx);    pts[31].y = long (-198 * size + posy);
    pts[32].x = long (-42 * size + posx);    pts[32].y = long (-192 * size + posy);
    pts[33].x = long (-74 * size + posx);    pts[33].y = long (-190 * size + posy);
    pts[34].x = long (-108 * size + posx);    pts[34].y = long (-195 * size + posy);
    pts[35].x = long (-139 * size + posx);    pts[35].y = long (-203 * size + posy);
    pts[36].x = long (-167 * size + posx);    pts[36].y = long (-192 * size + posy);
    pts[37].x = long (-194 * size + posx);    pts[37].y = long (-181 * size + posy);
    pts[38].x = long (-206 * size + posx);    pts[38].y = long (-163 * size + posy);
    pts[39].x = long (-227 * size + posx);    pts[39].y = long (-161 * size + posy);
    pts[40].x = long (-236 * size + posx);    pts[40].y = long (-169 * size + posy);
    pts[41].x = long (-231 * size + posx);    pts[41].y = long (-198 * size + posy);
    pts[42].x = long (-226 * size + posx);    pts[42].y = long (-208 * size + posy);
    // 绘制
    fillpolygon (pts, 43);

}


// 云朵绘制函数
void game::draw_cloud (double posx, double posy, double size)
{
    POINT pts[100];
    setlinestyle (PS_SOLID, 1);
    // 设置
    setlinecolor (RGB (239, 250, 255));
    setfillcolor (RGB (239, 250, 255));
    pts[0].x = long (370 * size + posx);    pts[0].y = long (-230 * size + posy);
    pts[1].x = long (382 * size + posx);    pts[1].y = long (-241 * size + posy);
    pts[2].x = long (386 * size + posx);    pts[2].y = long (-243 * size + posy);
    pts[3].x = long (399 * size + posx);    pts[3].y = long (-241 * size + posy);
    pts[4].x = long (410 * size + posx);    pts[4].y = long (-240 * size + posy);
    pts[5].x = long (421 * size + posx);    pts[5].y = long (-236 * size + posy);
    pts[6].x = long (436 * size + posx);    pts[6].y = long (-240 * size + posy);
    pts[7].x = long (447 * size + posx);    pts[7].y = long (-242 * size + posy);
    pts[8].x = long (454 * size + posx);    pts[8].y = long (-238 * size + posy);
    pts[9].x = long (459 * size + posx);    pts[9].y = long (-231 * size + posy);
    pts[10].x = long (459 * size + posx);    pts[10].y = long (-222 * size + posy);
    pts[11].x = long (453 * size + posx);    pts[11].y = long (-216 * size + posy);
    pts[12].x = long (445 * size + posx);    pts[12].y = long (-212 * size + posy);
    pts[13].x = long (432 * size + posx);    pts[13].y = long (-212 * size + posy);
    pts[14].x = long (423 * size + posx);    pts[14].y = long (-212 * size + posy);
    pts[15].x = long (415 * size + posx);    pts[15].y = long (-212 * size + posy);
    pts[16].x = long (397 * size + posx);    pts[16].y = long (-215 * size + posy);
    pts[17].x = long (386 * size + posx);    pts[17].y = long (-211 * size + posy);
    pts[18].x = long (380 * size + posx);    pts[18].y = long (-211 * size + posy);
    pts[19].x = long (375 * size + posx);    pts[19].y = long (-219 * size + posy);
    pts[20].x = long (369 * size + posx);    pts[20].y = long (-229 * size + posy);
    // 绘制
    fillpolygon (pts, 21);
}


// 左栏杆绘制函数
void game::draw_left_railing (double posx, double posy, double size)
{
    POINT pts[100];
    setlinestyle (PS_SOLID, 1);
    // 绘制
    setlinecolor (RGB (238, 212, 89));
    setfillcolor (RGB (238, 212, 89));
    pts[0].x = long (-261 * size + posx);    pts[0].y = long (72 * size + posy);
    pts[1].x = long (-271 * size + posx);    pts[1].y = long (82 * size + posy);
    pts[2].x = long (-258 * size + posx);    pts[2].y = long (86 * size + posy);
    pts[3].x = long (-249 * size + posx);    pts[3].y = long (75 * size + posy);
    fillpolygon (pts, 4);

    setlinecolor (RGB (212, 189, 83));
    setfillcolor (RGB (212, 189, 83));
    pts[0].x = long (-271 * size + posx);    pts[0].y = long (83 * size + posy);
    pts[1].x = long (-271 * size + posx);    pts[1].y = long (151 * size + posy);
    pts[2].x = long (-258 * size + posx);    pts[2].y = long (159 * size + posy);
    pts[3].x = long (-258 * size + posx);    pts[3].y = long (85 * size + posy);
    fillpolygon (pts, 4);

    setlinecolor (RGB (243, 225, 135));
    setfillcolor (RGB (243, 225, 135));
    pts[0].x = long (-258 * size + posx);    pts[0].y = long (159 * size + posy);
    pts[1].x = long (-258 * size + posx);    pts[1].y = long (85 * size + posy);
    pts[2].x = long (-250 * size + posx);    pts[2].y = long (77 * size + posy);
    pts[3].x = long (-250 * size + posx);    pts[3].y = long (149 * size + posy);
    fillpolygon (pts, 4);
}


// 左栅栏绘制函数
void game::draw_left_fence (double posx, double posy, double size)
{
    POINT pts[100];
    setlinestyle (PS_SOLID, 1);

    setlinecolor (RGB (241, 217, 109));
    setfillcolor (RGB (241, 217, 109));
    pts[0].x = long (-173 * size + posx);    pts[0].y = long (-54 * size + posy);
    pts[1].x = long (-159 * size + posx);    pts[1].y = long (-75 * size + posy);
    pts[2].x = long (-156 * size + posx);    pts[2].y = long (-77 * size + posy);
    pts[3].x = long (-154 * size + posx);    pts[3].y = long (-75 * size + posy);
    pts[4].x = long (-155 * size + posx);    pts[4].y = long (-72 * size + posy);
    pts[5].x = long (-158 * size + posx);    pts[5].y = long (-67 * size + posy);
    pts[6].x = long (-170 * size + posx);    pts[6].y = long (-48 * size + posy);
    fillpolygon (pts, 7);
}


// 右栏杆绘制函数
void game::draw_right_railing (double posx, double posy, double size)
{
    POINT pts[100];
    setlinestyle (PS_SOLID, 1);
    // 绘制
    setlinecolor (RGB (238, 212, 89));
    setfillcolor (RGB (238, 212, 89));
    pts[0].x = long (494 * size + posx);    pts[0].y = long (132 * size + posy);
    pts[1].x = long (503 * size + posx);    pts[1].y = long (139 * size + posy);
    pts[2].x = long (515 * size + posx);    pts[2].y = long (135 * size + posy);
    pts[3].x = long (507 * size + posx);    pts[3].y = long (127 * size + posy);
    fillpolygon (pts, 4);

    setlinecolor (RGB (212, 189, 83));
    setfillcolor (RGB (212, 189, 83));
    pts[0].x = long (499 * size + posx);    pts[0].y = long (211 * size + posy);
    pts[1].x = long (502 * size + posx);    pts[1].y = long (139 * size + posy);
    pts[2].x = long (515 * size + posx);    pts[2].y = long (136 * size + posy);
    pts[3].x = long (512 * size + posx);    pts[3].y = long (209 * size + posy);
    fillpolygon (pts, 4);

    setlinecolor (RGB (243, 225, 135));
    setfillcolor (RGB (243, 225, 135));
    pts[0].x = long (493 * size + posx);    pts[0].y = long (132 * size + posy);
    pts[1].x = long (489 * size + posx);    pts[1].y = long (201 * size + posy);
    pts[2].x = long (499 * size + posx);    pts[2].y = long (211 * size + posy);
    pts[3].x = long (502 * size + posx);    pts[3].y = long (139 * size + posy);
    fillpolygon (pts, 4);
}


// 右栅栏绘制函数
void game::draw_right_fence (double posx, double posy, double size)
{
    POINT pts[100];
    // 绘制
    setlinestyle (PS_SOLID, 1);
    setlinecolor (RGB (241, 217, 109));
    setfillcolor (RGB (241, 217, 109));
    pts[0].x = long (405 * size + posx);    pts[0].y = long (-58 * size + posy);
    pts[1].x = long (393 * size + posx);    pts[1].y = long (-78 * size + posy);
    pts[2].x = long (394 * size + posx);    pts[2].y = long (-85 * size + posy);
    pts[3].x = long (398 * size + posx);    pts[3].y = long (-88 * size + posy);
    pts[4].x = long (402 * size + posx);    pts[4].y = long (-81 * size + posy);
    pts[5].x = long (411 * size + posx);    pts[5].y = long (-63 * size + posy);
    fillpolygon (pts, 6);
}


// 鼹鼠绘制函数
void game::draw_gopher (double posx, double posy, double size, int flag)
{
    int i;
    POINT pts[100];
    setlinestyle (PS_SOLID, 2);
    // 外轮廓
    setlinecolor (BLACK);
    setfillcolor (RGB (165, 106, 50));
    pts[0].x = long (-232 * size + posx);    pts[0].y = long (292.00 * size + posy);
    pts[1].x = long (-232 * size + posx);    pts[1].y = long (235.00 * size + posy);
    pts[2].x = long (-245 * size + posx);    pts[2].y = long (252.00 * size + posy);
    pts[3].x = long (-255 * size + posx);    pts[3].y = long (250.00 * size + posy);
    pts[4].x = long (-259 * size + posx);    pts[4].y = long (241.00 * size + posy);
    pts[5].x = long (-274 * size + posx);    pts[5].y = long (245.00 * size + posy);
    pts[6].x = long (-274 * size + posx);    pts[6].y = long (232.00 * size + posy);
    pts[7].x = long (-288 * size + posx);    pts[7].y = long (234.00 * size + posy);
    pts[8].x = long (-297 * size + posx);    pts[8].y = long (217.00 * size + posy);
    pts[9].x = long (-282 * size + posx);    pts[9].y = long (202.00 * size + posy);
    pts[10].x = long (-296 * size + posx);    pts[10].y = long (186.00 * size + posy);
    pts[11].x = long (-285 * size + posx);    pts[11].y = long (179.00 * size + posy);
    pts[12].x = long (-269 * size + posx);    pts[12].y = long (178.00 * size + posy);
    pts[13].x = long (-269 * size + posx);    pts[13].y = long (153.00 * size + posy);
    pts[14].x = long (-191 * size + posx);    pts[14].y = long (50.00 * size + posy);
    pts[15].x = long (-189 * size + posx);    pts[15].y = long (-133.00 * size + posy);
    pts[16].x = long (-217 * size + posx);    pts[16].y = long (-187.00 * size + posy);
    pts[17].x = long (-218 * size + posx);    pts[17].y = long (-231.00 * size + posy);
    pts[18].x = long (-201 * size + posx);    pts[18].y = long (-262.00 * size + posy);
    pts[19].x = long (-167 * size + posx);    pts[19].y = long (-287.00 * size + posy);
    pts[20].x = long (-138 * size + posx);    pts[20].y = long (-287.00 * size + posy);
    pts[21].x = long (-134 * size + posx);    pts[21].y = long (-279.00 * size + posy);
    pts[22].x = long (-119 * size + posx);    pts[22].y = long (-279.00 * size + posy);
    pts[23].x = long (-105 * size + posx);    pts[23].y = long (-260.00 * size + posy);
    pts[24].x = long (-84 * size + posx);    pts[24].y = long (-273.00 * size + posy);
    pts[25].x = long (-75 * size + posx);    pts[25].y = long (-280.00 * size + posy);
    pts[26].x = long (-37 * size + posx);    pts[26].y = long (-278.00 * size + posy);
    pts[27].x = long (-23 * size + posx);    pts[27].y = long (-287.00 * size + posy);
    pts[28].x = long (26 * size + posx);    pts[28].y = long (-286.00 * size + posy);
    pts[29].x = long (37 * size + posx);    pts[29].y = long (-274.00 * size + posy);
    pts[30].x = long (58 * size + posx);    pts[30].y = long (-278.00 * size + posy);
    pts[31].x = long (69 * size + posx);    pts[31].y = long (-269.00 * size + posy);
    pts[32].x = long (100 * size + posx);    pts[32].y = long (-269.00 * size + posy);
    pts[33].x = long (129 * size + posx);    pts[33].y = long (-295.00 * size + posy);
    pts[34].x = long (166 * size + posx);    pts[34].y = long (-294.00 * size + posy);
    pts[35].x = long (182 * size + posx);    pts[35].y = long (-286.00 * size + posy);
    pts[36].x = long (205 * size + posx);    pts[36].y = long (-259.00 * size + posy);
    pts[37].x = long (212 * size + posx);    pts[37].y = long (-237.00 * size + posy);
    pts[38].x = long (210 * size + posx);    pts[38].y = long (-223.00 * size + posy);
    pts[39].x = long (217 * size + posx);    pts[39].y = long (-212.00 * size + posy);
    pts[40].x = long (211 * size + posx);    pts[40].y = long (-188.00 * size + posy);
    pts[41].x = long (189 * size + posx);    pts[41].y = long (-136.00 * size + posy);
    pts[42].x = long (193 * size + posx);    pts[42].y = long (-83.00 * size + posy);
    pts[43].x = long (193 * size + posx);    pts[43].y = long (-9.00 * size + posy);
    pts[44].x = long (189 * size + posx);    pts[44].y = long (-1.00 * size + posy);
    pts[45].x = long (191 * size + posx);    pts[45].y = long (42.00 * size + posy);
    pts[46].x = long (230 * size + posx);    pts[46].y = long (90.00 * size + posy);
    pts[47].x = long (236 * size + posx);    pts[47].y = long (108.00 * size + posy);
    pts[48].x = long (254 * size + posx);    pts[48].y = long (119.00 * size + posy);
    pts[49].x = long (265 * size + posx);    pts[49].y = long (149.00 * size + posy);
    pts[50].x = long (276 * size + posx);    pts[50].y = long (160.00 * size + posy);
    pts[51].x = long (301 * size + posx);    pts[51].y = long (188.00 * size + posy);
    pts[52].x = long (302 * size + posx);    pts[52].y = long (202.00 * size + posy);
    pts[53].x = long (295 * size + posx);    pts[53].y = long (209.00 * size + posy);
    pts[54].x = long (296 * size + posx);    pts[54].y = long (235.00 * size + posy);
    pts[55].x = long (273 * size + posx);    pts[55].y = long (240.00 * size + posy);
    pts[56].x = long (272 * size + posx);    pts[56].y = long (254.00 * size + posy);
    pts[57].x = long (251 * size + posx);    pts[57].y = long (249.00 * size + posy);
    pts[58].x = long (234 * size + posx);    pts[58].y = long (232.00 * size + posy);
    pts[59].x = long (235 * size + posx);    pts[59].y = long (290.00 * size + posy);
    fillpolygon (pts, 60);
    setlinestyle (PS_SOLID, 1);
    // 左耳廓
    setlinecolor (RGB (249, 230, 218));
    setfillcolor (RGB (249, 230, 218));
    pts[0].x = long (-193 * size + posx);    pts[0].y = long (-181.00 * size + posy);
    pts[1].x = long (-160 * size + posx);    pts[1].y = long (-214.00 * size + posy);
    pts[2].x = long (-122 * size + posx);    pts[2].y = long (-243.00 * size + posy);
    pts[3].x = long (-139 * size + posx);    pts[3].y = long (-267.00 * size + posy);
    pts[4].x = long (-163 * size + posx);    pts[4].y = long (-270.00 * size + posy);
    pts[5].x = long (-181 * size + posx);    pts[5].y = long (-260.00 * size + posy);
    pts[6].x = long (-199 * size + posx);    pts[6].y = long (-235.00 * size + posy);
    pts[7].x = long (-198 * size + posx);    pts[7].y = long (-188.00 * size + posy);
    pts[8].x = long (-185 * size + posx);    pts[8].y = long (-169.00 * size + posy);
    fillpolygon (pts, 9);
    // 右耳廓
    pts[0].x = long (121 * size + posx);    pts[0].y = long (-256.00 * size + posy);
    pts[1].x = long (139 * size + posx);    pts[1].y = long (-273.00 * size + posy);
    pts[2].x = long (169 * size + posx);    pts[2].y = long (-273.00 * size + posy);
    pts[3].x = long (188 * size + posx);    pts[3].y = long (-254.00 * size + posy);
    pts[4].x = long (197 * size + posx);    pts[4].y = long (-235.00 * size + posy);
    pts[5].x = long (201 * size + posx);    pts[5].y = long (-216.00 * size + posy);
    pts[6].x = long (190 * size + posx);    pts[6].y = long (-193.00 * size + posy);
    pts[7].x = long (178 * size + posx);    pts[7].y = long (-181.00 * size + posy);
    pts[8].x = long (119 * size + posx);    pts[8].y = long (-254.00 * size + posy);
    fillpolygon (pts, 9);
    // 左耳毛
    setlinecolor (RGB (54, 36, 19));
    setfillcolor (RGB (54, 36, 19));
    pts[0].x = long (-181 * size + posx);    pts[0].y = long (-163.00 * size + posy);
    pts[1].x = long (-191 * size + posx);    pts[1].y = long (-178.00 * size + posy);
    pts[2].x = long (-187 * size + posx);    pts[2].y = long (-192.00 * size + posy);
    pts[3].x = long (-194 * size + posx);    pts[3].y = long (-211.00 * size + posy);
    pts[4].x = long (-188 * size + posx);    pts[4].y = long (-233.00 * size + posy);
    pts[5].x = long (-183 * size + posx);    pts[5].y = long (-214.00 * size + posy);
    pts[6].x = long (-174 * size + posx);    pts[6].y = long (-202.00 * size + posy);
    pts[7].x = long (-170 * size + posx);    pts[7].y = long (-206.00 * size + posy);
    pts[8].x = long (-170 * size + posx);    pts[8].y = long (-223.00 * size + posy);
    pts[9].x = long (-153 * size + posx);    pts[9].y = long (-228.00 * size + posy);
    pts[10].x = long (-167 * size + posx);    pts[10].y = long (-235.00 * size + posy);
    pts[11].x = long (-161 * size + posx);    pts[11].y = long (-260.00 * size + posy);
    pts[12].x = long (-148 * size + posx);    pts[12].y = long (-253.00 * size + posy);
    pts[13].x = long (-147 * size + posx);    pts[13].y = long (-243.00 * size + posy);
    pts[14].x = long (-140 * size + posx);    pts[14].y = long (-251.00 * size + posy);
    pts[15].x = long (-125 * size + posx);    pts[15].y = long (-238.00 * size + posy);
    pts[16].x = long (-134 * size + posx);    pts[16].y = long (-232.00 * size + posy);
    pts[17].x = long (-139 * size + posx);    pts[17].y = long (-223.00 * size + posy);
    pts[18].x = long (-151 * size + posx);    pts[18].y = long (-225.00 * size + posy);
    pts[19].x = long (-147 * size + posx);    pts[19].y = long (-201.00 * size + posy);
    pts[20].x = long (-168 * size + posx);    pts[20].y = long (-191.00 * size + posy);
    pts[21].x = long (-177 * size + posx);    pts[21].y = long (-182.00 * size + posy);
    pts[22].x = long (-177 * size + posx);    pts[22].y = long (-165.00 * size + posy);
    fillpolygon (pts, 22);
    // 右耳毛
    pts[0].x = long (117 * size + posx);    pts[0].y = long (-254.00 * size + posy);
    pts[1].x = long (134 * size + posx);    pts[1].y = long (-265.00 * size + posy);
    pts[2].x = long (138 * size + posx);    pts[2].y = long (-253.00 * size + posy);
    pts[3].x = long (154 * size + posx);    pts[3].y = long (-254.00 * size + posy);
    pts[4].x = long (157 * size + posx);    pts[4].y = long (-245.00 * size + posy);
    pts[5].x = long (146 * size + posx);    pts[5].y = long (-238.00 * size + posy);
    pts[6].x = long (154 * size + posx);    pts[6].y = long (-226.00 * size + posy);
    pts[7].x = long (160 * size + posx);    pts[7].y = long (-233.00 * size + posy);
    pts[8].x = long (165 * size + posx);    pts[8].y = long (-232.00 * size + posy);
    pts[9].x = long (165 * size + posx);    pts[9].y = long (-217.00 * size + posy);
    pts[10].x = long (157 * size + posx);    pts[10].y = long (-214.00 * size + posy);
    pts[11].x = long (167 * size + posx);    pts[11].y = long (-206.00 * size + posy);
    pts[12].x = long (174 * size + posx);    pts[12].y = long (-213.00 * size + posy);
    pts[13].x = long (180 * size + posx);    pts[13].y = long (-232.00 * size + posy);
    pts[14].x = long (182 * size + posx);    pts[14].y = long (-243.00 * size + posy);
    pts[15].x = long (190 * size + posx);    pts[15].y = long (-224.00 * size + posy);
    pts[16].x = long (187 * size + posx);    pts[16].y = long (-201.00 * size + posy);
    pts[17].x = long (187 * size + posx);    pts[17].y = long (-190.00 * size + posy);
    pts[18].x = long (194 * size + posx);    pts[18].y = long (-191.00 * size + posy);
    pts[19].x = long (181 * size + posx);    pts[19].y = long (-178.00 * size + posy);
    pts[20].x = long (163 * size + posx);    pts[20].y = long (-179.00 * size + posy);
    pts[21].x = long (165 * size + posx);    pts[21].y = long (-191.00 * size + posy);
    pts[22].x = long (154 * size + posx);    pts[22].y = long (-195.00 * size + posy);
    pts[23].x = long (150 * size + posx);    pts[23].y = long (-201.00 * size + posy);
    pts[24].x = long (154 * size + posx);    pts[24].y = long (-216.00 * size + posy);
    pts[25].x = long (139 * size + posx);    pts[25].y = long (-215.00 * size + posy);
    pts[26].x = long (137 * size + posx);    pts[26].y = long (-224.00 * size + posy);
    pts[27].x = long (145 * size + posx);    pts[27].y = long (-225.00 * size + posy);
    pts[28].x = long (136 * size + posx);    pts[28].y = long (-235.00 * size + posy);
    pts[29].x = long (128 * size + posx);    pts[29].y = long (-232.00 * size + posy);
    pts[30].x = long (118 * size + posx);    pts[30].y = long (-251.00 * size + posy);
    fillpolygon (pts, 31);
    // 左眼
    // 正常状态
    if (flag == 1)
    {
        setlinecolor (RGB (5, 2, 1));
        setfillcolor (RGB (5, 2, 1));
    }
    // 僵直状态
    else if (flag == 2)
    {
        setlinecolor (RGB (251, 252, 251));
        setfillcolor (RGB (251, 252, 251));
    }
    // 红眼状态
    else if (flag == 3)
    {
        setlinecolor (LIGHTRED);
        setfillcolor (LIGHTRED);
    }
    pts[0].x = long (-112 * size + posx);    pts[0].y = long (-201.00 * size + posy);
    pts[1].x = long (-75 * size + posx);    pts[1].y = long (-201.00 * size + posy);
    pts[2].x = long (-61 * size + posx);    pts[2].y = long (-186.00 * size + posy);
    pts[3].x = long (-55 * size + posx);    pts[3].y = long (-157.00 * size + posy);
    pts[4].x = long (-46 * size + posx);    pts[4].y = long (-116.00 * size + posy);
    pts[5].x = long (-45 * size + posx);    pts[5].y = long (-88.00 * size + posy);
    pts[6].x = long (-71 * size + posx);    pts[6].y = long (-66.00 * size + posy);
    pts[7].x = long (-101 * size + posx);    pts[7].y = long (-65.00 * size + posy);
    pts[8].x = long (-121 * size + posx);    pts[8].y = long (-68.00 * size + posy);
    pts[9].x = long (-141 * size + posx);    pts[9].y = long (-80.00 * size + posy);
    pts[10].x = long (-160 * size + posx);    pts[10].y = long (-101.00 * size + posy);
    pts[11].x = long (-160 * size + posx);    pts[11].y = long (-113.00 * size + posy);
    pts[12].x = long (-151 * size + posx);    pts[12].y = long (-128.00 * size + posy);
    pts[13].x = long (-150 * size + posx);    pts[13].y = long (-164.00 * size + posy);
    pts[14].x = long (-135 * size + posx);    pts[14].y = long (-185.00 * size + posy);
    pts[15].x = long (-115 * size + posx);    pts[15].y = long (-200.00 * size + posy);
    pts[16].x = long (-114 * size + posx);    pts[16].y = long (-200.00 * size + posy);
    fillpolygon (pts, 17);
    // 右眼
    pts[0].x = long (71 * size + posx);    pts[0].y = long (-199.00 * size + posy);
    pts[1].x = long (109 * size + posx);    pts[1].y = long (-201.00 * size + posy);
    pts[2].x = long (127 * size + posx);    pts[2].y = long (-185.00 * size + posy);
    pts[3].x = long (134 * size + posx);    pts[3].y = long (-167.00 * size + posy);
    pts[4].x = long (144 * size + posx);    pts[4].y = long (-142.00 * size + posy);
    pts[5].x = long (146 * size + posx);    pts[5].y = long (-123.00 * size + posy);
    pts[6].x = long (152 * size + posx);    pts[6].y = long (-123.00 * size + posy);
    pts[7].x = long (151 * size + posx);    pts[7].y = long (-100.00 * size + posy);
    pts[8].x = long (148 * size + posx);    pts[8].y = long (-90.00 * size + posy);
    pts[9].x = long (130 * size + posx);    pts[9].y = long (-74.00 * size + posy);
    pts[10].x = long (108 * size + posx);    pts[10].y = long (-66.00 * size + posy);
    pts[11].x = long (86 * size + posx);    pts[11].y = long (-61.00 * size + posy);
    pts[12].x = long (69 * size + posx);    pts[12].y = long (-67.00 * size + posy);
    pts[13].x = long (47 * size + posx);    pts[13].y = long (-82.00 * size + posy);
    pts[14].x = long (38 * size + posx);    pts[14].y = long (-89.00 * size + posy);
    pts[15].x = long (40 * size + posx);    pts[15].y = long (-145.00 * size + posy);
    pts[16].x = long (48 * size + posx);    pts[16].y = long (-163.00 * size + posy);
    pts[17].x = long (57 * size + posx);    pts[17].y = long (-188.00 * size + posy);
    pts[18].x = long (71 * size + posx);    pts[18].y = long (-199.00 * size + posy);
    fillpolygon (pts, 19);
    // 左眼影
    setlinecolor (RGB (48, 123, 48));
    setfillcolor (RGB (48, 123, 48));
    pts[0].x = long (-132 * size + posx);    pts[0].y = long (-116.00 * size + posy);
    pts[1].x = long (-130 * size + posx);    pts[1].y = long (-116.00 * size + posy);
    pts[2].x = long (-117 * size + posx);    pts[2].y = long (-105.00 * size + posy);
    pts[3].x = long (-104 * size + posx);    pts[3].y = long (-94.00 * size + posy);
    pts[4].x = long (-84 * size + posx);    pts[4].y = long (-95.00 * size + posy);
    pts[5].x = long (-74 * size + posx);    pts[5].y = long (-106.00 * size + posy);
    pts[6].x = long (-68 * size + posx);    pts[6].y = long (-102.00 * size + posy);
    pts[7].x = long (-67 * size + posx);    pts[7].y = long (-92.00 * size + posy);
    pts[8].x = long (-80 * size + posx);    pts[8].y = long (-84.00 * size + posy);
    pts[9].x = long (-118 * size + posx);    pts[9].y = long (-85.00 * size + posy);
    pts[10].x = long (-137 * size + posx);    pts[10].y = long (-100.00 * size + posy);
    pts[11].x = long (-142 * size + posx);    pts[11].y = long (-106.00 * size + posy);
    fillpolygon (pts, 12);
    // 右眼影
    pts[0].x = long (61 * size + posx);    pts[0].y = long (-110.00 * size + posy);
    pts[1].x = long (59 * size + posx);    pts[1].y = long (-93.00 * size + posy);
    pts[2].x = long (78 * size + posx);    pts[2].y = long (-81.00 * size + posy);
    pts[3].x = long (102 * size + posx);    pts[3].y = long (-80.00 * size + posy);
    pts[4].x = long (127 * size + posx);    pts[4].y = long (-99.00 * size + posy);
    pts[5].x = long (131 * size + posx);    pts[5].y = long (-108.00 * size + posy);
    pts[6].x = long (121 * size + posx);    pts[6].y = long (-116.00 * size + posy);
    pts[7].x = long (120 * size + posx);    pts[7].y = long (-118.00 * size + posy);
    pts[8].x = long (118 * size + posx);    pts[8].y = long (-119.00 * size + posy);
    pts[9].x = long (107 * size + posx);    pts[9].y = long (-100.00 * size + posy);
    pts[10].x = long (90 * size + posx);    pts[10].y = long (-96.00 * size + posy);
    pts[11].x = long (77 * size + posx);    pts[11].y = long (-95.00 * size + posy);
    pts[12].x = long (64 * size + posx);    pts[12].y = long (-110.00 * size + posy);
    fillpolygon (pts, 13);
    // 肚白
    setlinecolor (RGB (255, 249, 240));
    setfillcolor (RGB (255, 249, 240));
    pts[0].x = long (-28 * size + posx);    pts[0].y = long (-97.00 * size + posy);
    pts[1].x = long (-53 * size + posx);    pts[1].y = long (-76.00 * size + posy);
    pts[2].x = long (-86 * size + posx);    pts[2].y = long (-50.00 * size + posy);
    pts[3].x = long (-126 * size + posx);    pts[3].y = long (-16.00 * size + posy);
    pts[4].x = long (-172 * size + posx);    pts[4].y = long (46.00 * size + posy);
    pts[5].x = long (-195 * size + posx);    pts[5].y = long (71.00 * size + posy);
    pts[6].x = long (-239 * size + posx);    pts[6].y = long (129.00 * size + posy);
    pts[7].x = long (-236 * size + posx);    pts[7].y = long (143.00 * size + posy);
    pts[8].x = long (-254 * size + posx);    pts[8].y = long (151.00 * size + posy);
    pts[9].x = long (-260 * size + posx);    pts[9].y = long (177.00 * size + posy);
    pts[10].x = long (-264 * size + posx);    pts[10].y = long (186.00 * size + posy);
    pts[11].x = long (-283 * size + posx);    pts[11].y = long (191.00 * size + posy);
    pts[12].x = long (-274 * size + posx);    pts[12].y = long (200.00 * size + posy);
    pts[13].x = long (-272 * size + posx);    pts[13].y = long (210.00 * size + posy);
    pts[14].x = long (-284 * size + posx);    pts[14].y = long (220.00 * size + posy);
    pts[15].x = long (-280 * size + posx);    pts[15].y = long (225.00 * size + posy);
    pts[16].x = long (-278 * size + posx);    pts[16].y = long (229.00 * size + posy);
    pts[17].x = long (-266 * size + posx);    pts[17].y = long (230.00 * size + posy);
    pts[18].x = long (-266 * size + posx);    pts[18].y = long (237.00 * size + posy);
    pts[19].x = long (-254 * size + posx);    pts[19].y = long (239.00 * size + posy);
    pts[20].x = long (-250 * size + posx);    pts[20].y = long (242.00 * size + posy);
    pts[21].x = long (-242 * size + posx);    pts[21].y = long (236.00 * size + posy);
    pts[22].x = long (-231 * size + posx);    pts[22].y = long (230.00 * size + posy);
    pts[23].x = long (-214 * size + posx);    pts[23].y = long (226.00 * size + posy);
    pts[24].x = long (-204 * size + posx);    pts[24].y = long (236.00 * size + posy);
    pts[25].x = long (-212 * size + posx);    pts[25].y = long (266.00 * size + posy);
    pts[26].x = long (-211 * size + posx);    pts[26].y = long (292.00 * size + posy);
    pts[27].x = long (205 * size + posx);    pts[27].y = long (292.00 * size + posy);
    pts[28].x = long (202 * size + posx);    pts[28].y = long (220.00 * size + posy);
    pts[29].x = long (239 * size + posx);    pts[29].y = long (225.00 * size + posy);
    pts[30].x = long (256 * size + posx);    pts[30].y = long (243.00 * size + posy);
    pts[31].x = long (267 * size + posx);    pts[31].y = long (237.00 * size + posy);
    pts[32].x = long (276 * size + posx);    pts[32].y = long (230.00 * size + posy);
    pts[33].x = long (287 * size + posx);    pts[33].y = long (230.00 * size + posy);
    pts[34].x = long (290 * size + posx);    pts[34].y = long (198.00 * size + posy);
    pts[35].x = long (260 * size + posx);    pts[35].y = long (160.00 * size + posy);
    pts[36].x = long (240 * size + posx);    pts[36].y = long (131.00 * size + posy);
    pts[37].x = long (192 * size + posx);    pts[37].y = long (74.00 * size + posy);
    pts[38].x = long (167 * size + posx);    pts[38].y = long (45.00 * size + posy);
    pts[39].x = long (169 * size + posx);    pts[39].y = long (34.00 * size + posy);
    pts[40].x = long (128 * size + posx);    pts[40].y = long (-12.00 * size + posy);
    pts[41].x = long (95 * size + posx);    pts[41].y = long (-41.00 * size + posy);
    pts[42].x = long (68 * size + posx);    pts[42].y = long (-60.00 * size + posy);
    pts[43].x = long (29 * size + posx);    pts[43].y = long (-88.00 * size + posy);
    pts[44].x = long (14 * size + posx);    pts[44].y = long (-95.00 * size + posy);
    pts[45].x = long (-17 * size + posx);    pts[45].y = long (-96.00 * size + posy);
    pts[46].x = long (-27 * size + posx);    pts[46].y = long (-97.00 * size + posy);
    fillpolygon (pts, 47);
    // 左手指
    setlinecolor (RGB (114, 103, 93));
    setfillcolor (RGB (114, 103, 93));
    pts[0].x = long (-261 * size + posx);    pts[0].y = long (191.00 * size + posy);
    pts[1].x = long (-261 * size + posx);    pts[1].y = long (204.00 * size + posy);
    pts[2].x = long (-240 * size + posx);    pts[2].y = long (208.00 * size + posy);
    pts[3].x = long (-240 * size + posx);    pts[3].y = long (194.00 * size + posy);
    pts[4].x = long (-258 * size + posx);    pts[4].y = long (190.00 * size + posy);
    fillpolygon (pts, 5);
    // 右手指
    pts[0].x = long (263 * size + posx);    pts[0].y = long (210.00 * size + posy);
    pts[1].x = long (276 * size + posx);    pts[1].y = long (215.00 * size + posy);
    pts[2].x = long (285 * size + posx);    pts[2].y = long (207.00 * size + posy);
    pts[3].x = long (286 * size + posx);    pts[3].y = long (200.00 * size + posy);
    pts[4].x = long (277 * size + posx);    pts[4].y = long (197.00 * size + posy);
    pts[5].x = long (271 * size + posx);    pts[5].y = long (191.00 * size + posy);
    pts[6].x = long (272 * size + posx);    pts[6].y = long (203.00 * size + posy);
    pts[7].x = long (266 * size + posx);    pts[7].y = long (207.00 * size + posy);
    fillpolygon (pts, 8);
    // 嘴巴
    setlinecolor (BLACK);
    setfillcolor (RGB (252, 252, 251));
    pts[0].x = long (0 * size + posx);    pts[0].y = long (-45.00 * size + posy);
    pts[1].x = long (-21 * size + posx);    pts[1].y = long (-31.00 * size + posy);
    pts[2].x = long (-31 * size + posx);    pts[2].y = long (-7.00 * size + posy);
    pts[3].x = long (-27 * size + posx);    pts[3].y = long (8.00 * size + posy);
    pts[4].x = long (-6 * size + posx);    pts[4].y = long (58.00 * size + posy);
    pts[5].x = long (8 * size + posx);    pts[5].y = long (55.00 * size + posy);
    pts[6].x = long (33 * size + posx);    pts[6].y = long (1.00 * size + posy);
    pts[7].x = long (30 * size + posx);    pts[7].y = long (-16.00 * size + posy);
    pts[8].x = long (2 * size + posx);    pts[8].y = long (-48.00 * size + posy);
    fillpolygon (pts, 9);
    // 胡须
    setlinecolor (BLACK);
    pts[0].x = long (-90 * size + posx);    pts[0].y = long (-49.00 * size + posy);
    pts[1].x = long (-160 * size + posx);    pts[1].y = long (-70.00 * size + posy);
    pts[2].x = long (-271 * size + posx);    pts[2].y = long (-71.00 * size + posy);
    pts[3].x = long (-294 * size + posx);    pts[3].y = long (-59.00 * size + posy);
    for (i = 0; i &lt; 3; i++) { line (pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y); }
    // 胡须
    pts[0].x = long (-108 * size + posx);    pts[0].y = long (-34.00 * size + posy);
    pts[1].x = long (-194 * size + posx);    pts[1].y = long (-37.00 * size + posy);
    pts[2].x = long (-205 * size + posx);    pts[2].y = long (-30.00 * size + posy);
    pts[3].x = long (-251 * size + posx);    pts[3].y = long (-30.00 * size + posy);
    pts[4].x = long (-271 * size + posx);    pts[4].y = long (-21.00 * size + posy);
    pts[5].x = long (-292 * size + posx);    pts[5].y = long (-14.00 * size + posy);
    for (i = 0; i &lt; 5; i++) { line (pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y); }
    // 胡须
    pts[0].x = long (89 * size + posx);    pts[0].y = long (-51.00 * size + posy);
    pts[1].x = long (215 * size + posx);    pts[1].y = long (-100.00 * size + posy);
    pts[2].x = long (304 * size + posx);    pts[2].y = long (-98.00 * size + posy);
    for (i = 0; i &lt; 2; i++) { line (pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y); }
    // 胡须
    pts[0].x = long (110 * size + posx);    pts[0].y = long (-38.00 * size + posy);
    pts[1].x = long (158 * size + posx);    pts[1].y = long (-53.00 * size + posy);
    pts[2].x = long (264 * size + posx);    pts[2].y = long (-55.00 * size + posy);
    pts[3].x = long (311 * size + posx);    pts[3].y = long (-35.00 * size + posy);
    for (i = 0; i &lt; 3; i++) { line (pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y); }
    // 鼻孔
    setlinecolor (BLACK);
    setfillcolor (RGB (145, 142, 126));
    pts[0].x = long (-14 * size + posx);    pts[0].y = long (-65.00 * size + posy);
    pts[1].x = long (-7 * size + posx);    pts[1].y = long (-81.00 * size + posy);
    pts[2].x = long (-2 * size + posx);    pts[2].y = long (-68.00 * size + posy);
    pts[3].x = long (9 * size + posx);    pts[3].y = long (-67.00 * size + posy);
    pts[4].x = long (14 * size + posx);    pts[4].y = long (-79.00 * size + posy);
    pts[5].x = long (21 * size + posx);    pts[5].y = long (-66.00 * size + posy);
    fillpolygon (pts, 6);
    // 眼球
    // 正常状态
    if (flag == 1)
    {
        setlinecolor (WHITE);
        setfillcolor (WHITE);
    }
    // 僵直状态
    else if (flag == 2)
    {
        setlinecolor (RGB (190, 190, 190));
        setfillcolor (WHITE);
    }
    // 红眼状态
    else if (flag == 3)
    {
        setlinecolor (WHITE);
        setfillcolor (WHITE);
    }

    pts[0].x = long (-123 * size + posx);    pts[0].y = long (-176 * size + posy);
    pts[1].x = long (-132 * size + posx);    pts[1].y = long (-165 * size + posy);
    pts[2].x = long (-129 * size + posx);    pts[2].y = long (-154 * size + posy);
    pts[3].x = long (-122 * size + posx);    pts[3].y = long (-146 * size + posy);
    pts[4].x = long (-113 * size + posx);    pts[4].y = long (-142 * size + posy);
    pts[5].x = long (-102 * size + posx);    pts[5].y = long (-142 * size + posy);
    pts[6].x = long (-92 * size + posx);    pts[6].y = long (-153 * size + posy);
    pts[7].x = long (-94 * size + posx);    pts[7].y = long (-168 * size + posy);
    pts[8].x = long (-98 * size + posx);    pts[8].y = long (-177 * size + posy);
    pts[9].x = long (-106 * size + posx);    pts[9].y = long (-181 * size + posy);
    pts[10].x = long (-118 * size + posx);    pts[10].y = long (-181 * size + posy);
    fillpolygon (pts, 11);

    pts[0].x = long (78 * size + posx);    pts[0].y = long (-178.00 * size + posy);
    pts[1].x = long (72 * size + posx);    pts[1].y = long (-171.00 * size + posy);
    pts[2].x = long (74 * size + posx);    pts[2].y = long (-151.00 * size + posy);
    pts[3].x = long (83 * size + posx);    pts[3].y = long (-141.00 * size + posy);
    pts[4].x = long (101 * size + posx);    pts[4].y = long (-142.00 * size + posy);
    pts[5].x = long (108 * size + posx);    pts[5].y = long (-154.00 * size + posy);
    pts[6].x = long (106 * size + posx);    pts[6].y = long (-170.00 * size + posy);
    pts[7].x = long (101 * size + posx);    pts[7].y = long (-181.00 * size + posy);
    pts[8].x = long (92 * size + posx);    pts[8].y = long (-185.00 * size + posy);
    pts[9].x = long (81 * size + posx);    pts[9].y = long (-184.00 * size + posy);
    fillpolygon (pts, 10);
}



// 准备进程源文件 //


// 准备进程主循函数
void game::carry_prepare ()
{
    TCHAR s[25];
    int i, j;
    // 鼠标定义
    ExMessage m;
    // 准备进程控制参数初始化
    int    exit_prepare = 0;
    // 绘制界面
    draw_scene_prepare ();
    // 主循开始
    while (exit_prepare == 0)
    {
        if (peekmessage (&amp;m, EM_MOUSE | EM_KEY))
        {
            // 左键单击判断
            if (m.message == WM_LBUTTONDOWN)
            {
                // 判断是否点击了按钮，按钮状态是否为激活
                for (i = 0; i &lt; num_button; i++)
                {
                    if (m.x &gt; boxm[i].posx1 &amp;&amp; m.y &gt; boxm[i].posy1 &amp;&amp; m.x &lt; boxm[i].posx2 &amp;&amp; m.y &lt; boxm[i].posy2 &amp;&amp; boxm[i].type == 0)
                    {
                        break;
                    }
                }

                // 开始游戏按钮
                if (i == 0)
                {
                    // 开始进程控制参数置零
                    exit_start = 0;
                    // 准备进程控制参数置一，结束主循
                    exit_prepare = 1;
                }
                // 设置按钮
                else if (i == 1)
                {
                    // 按钮状态参数更新
                    boxm[0].type = 1;
                    boxm[1].type = 1;
                    boxm[2].type = 1;
                    boxm[3].type = 0;
                    boxm[4].type = 0;
                    boxm[5].type = 0;
                    boxm[6].type = 0;
                    boxm[7].type = 1;
                    boxm[8].type = 1;
                    boxm[9].type = 0;
                    boxm[10].type = 0;
                    boxm[11].type = 0;
                }
                // 退出按钮
                else if (i == 2)
                {
                    // 总进程控制参数置一，跳过开始进程
                    exit_carry = 1;
                    // 准备进程控制参数置一，结束主循
                    exit_prepare = 1;
                }
                // 设置生成间隔按钮
                else if (i == 3)
                {
                    InputBox (s, 10, _T ("设置生成间隔（0 ~ 30），0 等效为一次生成 9 个"));
                    _stscanf_s (s, _T ("%d"), &amp;j);
                    if (j &gt;= 0 &amp;&amp; j &lt;= 30)
                    {
                        speed_creact = j;
                    }
                    else
                    {
                        MessageBox (hOut, _T ("输入错误，不在范围内"), _T ("来自小豆子的提醒"), MB_OK);
                    }
                }
                // 设置存在时间按钮
                else if (i == 4)
                {
                    InputBox (s, 10, _T ("设置存在时间（0 ~ 200），0 为没有存在时间"));
                    _stscanf_s (s, _T ("%d"), &amp;j);
                    if (j &gt;= 0 &amp;&amp; j &lt;= 200)
                    {
                        speed_gopher_life = j;
                    }
                    else
                    {
                        MessageBox (hOut, _T ("输入错误，不在范围内"), _T ("来自小豆子的提醒"), MB_OK);
                    }
                }
                // 设置僵直时间按钮
                else if (i == 5)
                {
                    InputBox (s, 10, _T ("设置僵直时间（0 ~ 50），0 为没有僵直时间"));
                    _stscanf_s (s, _T ("%d"), &amp;j);
                    if (j &gt;= 0 &amp;&amp; j &lt;= 50)
                    {
                        speed_gopher_beaten = j;
                    }
                    else
                    {
                        MessageBox (hOut, _T ("输入错误，不在范围内"), _T ("来自小豆子的提醒"), MB_OK);
                    }
                }
                // 返回按钮
                else if (i == 6)
                {
                    // 按钮状态参数更新
                    boxm[0].type = 0;
                    boxm[1].type = 0;
                    boxm[2].type = 0;
                    boxm[3].type = 1;
                    boxm[4].type = 1;
                    boxm[5].type = 1;
                    boxm[6].type = 1;
                    if (hole_full_end == 0)
                    {
                        boxm[7].type = 0;
                        boxm[8].type = 1;
                    }
                    else if (hole_full_end == 1)
                    {
                        boxm[7].type = 1;
                        boxm[8].type = 0;
                    }
                    boxm[9].type = 1;
                    boxm[10].type = 1;
                    boxm[11].type = 1;
                }
                // 溢满结束状态切换按钮
                else if (i == 7 || i == 8)
                {
                    // 切换至开
                    if (hole_full_end == 0)
                    {
                        hole_full_end = 1;
                        boxm[7].type = 1;
                        boxm[8].type = 0;
                    }
                    // 切换至关
                    else if (hole_full_end == 1)
                    {
                        hole_full_end = 0;
                        boxm[7].type = 0;
                        boxm[8].type = 1;
                    }
                }
                // 设置红眼数量按钮
                else if (i == 9)
                {
                    InputBox (s, 10, _T ("设置红眼数量（0 ~ 10），0 为没有红眼，10 为全部是红眼"));
                    _stscanf_s (s, _T ("%d"), &amp;j);
                    if (j &gt;= 0 &amp;&amp; j &lt;= 10)
                    {
                        gopher_red_eye_num = j;
                    }
                    else
                    {
                        MessageBox (hOut, _T ("输入错误，不在范围内"), _T ("来自小豆子的提醒"), MB_OK);
                    }
                }
                // 设置红眼得分按钮
                else if (i == 10)
                {
                    InputBox (s, 10, _T ("设置红眼得分（-20 ~ 20），负数为惩罚，正数为奖励"));
                    _stscanf_s (s, _T ("%d"), &amp;j);
                    if (j &gt;= -20 &amp;&amp; j &lt;= 20)
                    {
                        point_punishment = j;
                    }
                    else
                    {
                        MessageBox (hOut, _T ("输入错误，不在范围内"), _T ("来自小豆子的提醒"), MB_OK);
                    }
                }
                // 设置生成数量按钮
                else if (i == 11)
                {
                    InputBox (s, 10, _T ("设置生成数量（0 ~ 10），0 为不生成鼹鼠"));
                    _stscanf_s (s, _T ("%d"), &amp;j);
                    if (j &gt;= 0 &amp;&amp; j &lt;= 10)
                    {
                        every_creact_num = j;
                    }
                    else
                    {
                        MessageBox (hOut, _T ("输入错误，不在范围内"), _T ("来自小豆子的提醒"), MB_OK);
                    }
                }
                if (i &lt; num_button &amp;&amp; exit_prepare == 0)
                {
                    // 点击按钮后，根据按钮激活参数，重新绘制界面
                    draw_scene_prepare ();
                    if (i == 1 || i == 3 || i == 4 || i == 5 || i == 9 || i == 10 || i == 11)
                    {
                        // 生成间隔
                        _stprintf_s (s, _T ("%0.1d"), speed_creact);
                        draw_word (30, 245, 125, s);

                        // 存在时间
                        _stprintf_s (s, _T ("%0.1d"), speed_gopher_life);
                        draw_word (30, 245, 225, s);

                        // 僵直时间
                        _stprintf_s (s, _T ("%0.1d"), speed_gopher_beaten);
                        draw_word (30, 245, 325, s);

                        // 红眼数量
                        _stprintf_s (s, _T ("%0.1d"), gopher_red_eye_num);
                        draw_word (30, 595, 125, s);

                        // 红眼得分
                        _stprintf_s (s, _T ("%0.1d"), point_punishment);
                        draw_word (30, 595, 225, s);

                        // 生成数量
                        _stprintf_s (s, _T ("%0.1d"), every_creact_num);
                        draw_word (30, 595, 325, s);

                    }
                    FlushBatchDraw ();
                }
            }
        }
    }
}


// 准备进程初始化函数    
void game::initialization_prepare ()
{
    // 按钮设置初始化
    // 按钮数量参数初始化
    num_button = 12;

    // 按钮结构体参数初始化
    boxm[0].posx1 = 300; boxm[0].posy1 = 110; boxm[0].posx2 = 500; boxm[0].posy2 = 170; boxm[0].text = _T ("普通模式"); boxm[0].type = 0;
    boxm[1].posx1 = 300; boxm[1].posy1 = 210; boxm[1].posx2 = 500; boxm[1].posy2 = 270; boxm[1].text = _T ("设置");        boxm[1].type = 0;
    boxm[2].posx1 = 300; boxm[2].posy1 = 410; boxm[2].posx2 = 500; boxm[2].posy2 = 470; boxm[2].text = _T ("退出");        boxm[2].type = 0;

    boxm[3].posx1 = 100; boxm[3].posy1 = 110; boxm[3].posx2 = 300; boxm[3].posy2 = 170; boxm[3].text = _T ("生成间隔___"); boxm[3].type = 1;
    boxm[4].posx1 = 100; boxm[4].posy1 = 210; boxm[4].posx2 = 300; boxm[4].posy2 = 270; boxm[4].text = _T ("存在时间___");    boxm[4].type = 1;
    boxm[5].posx1 = 100; boxm[5].posy1 = 310; boxm[5].posx2 = 300; boxm[5].posy2 = 370; boxm[5].text = _T ("僵直时间___");    boxm[5].type = 1;
    boxm[6].posx1 = 300; boxm[6].posy1 = 410; boxm[6].posx2 = 500; boxm[6].posy2 = 470; boxm[6].text = _T ("返回");        boxm[6].type = 1;
    boxm[9].posx1 = 450; boxm[9].posy1 = 110; boxm[9].posx2 = 650; boxm[9].posy2 = 170; boxm[9].text = _T ("红眼数量___"); boxm[9].type = 1;
    boxm[10].posx1 = 450; boxm[10].posy1 = 210; boxm[10].posx2 = 650; boxm[10].posy2 = 270; boxm[10].text = _T ("红眼得分___");    boxm[10].type = 1;
    boxm[11].posx1 = 450; boxm[11].posy1 = 310; boxm[11].posx2 = 650; boxm[11].posy2 = 370; boxm[11].text = _T ("生成数量___");    boxm[11].type = 1;

    boxm[7].posx1 = 300; boxm[7].posy1 = 310; boxm[7].posx2 = 500; boxm[7].posy2 = 370; boxm[7].text = _T ("溢满结束：关");    boxm[7].type = 0;
    boxm[8].posx1 = 300; boxm[8].posy1 = 310; boxm[8].posx2 = 500; boxm[8].posy2 = 370; boxm[8].text = _T ("溢满结束：开");    boxm[8].type = 1;
    // 得分
    start_point = 0;

}


// 准备进程绘制函数
void game::draw_scene_prepare ()
{
    // 画布绘制
    setbkcolor (WHITE);
    cleardevice ();
    // 按钮绘制
    draw_button ();
    // 标题绘制
    draw_word (50, 340, 20, _T ("打地鼠"));
    FlushBatchDraw ();
}


// 开始进程源文件 //



// 开始进程主循函数
void game::carry_start ()
{
    // 鼠标定义
    ExMessage m;
    int i;
    // 绘制
    draw_scene_start ();
    // 时间初始化
    start_t1 = clock ();
    start_t2 = clock ();
    // 结束时间初始化
    start_endtime = 30000;
    // 特殊情况处理
    // 生成时间间隔为 0，将等效为每次生成数量为 9
    if (speed_creact == 0)
    {
        speed_creact = 1;
        every_creact_num = 9;
    }
    // 普通模式
    while (exit_start == 0)
    {
        if (peekmessage (&amp;m, EM_MOUSE | EM_KEY))
        {
            // 左键单击判断
            if (m.message == WM_LBUTTONDOWN)
            {
                // 单击在田地范围
                if (m.x &lt; 639 &amp;&amp; m.x &gt; 256 &amp;&amp; m.y &gt; 124 &amp;&amp; m.y &lt; 475)
                {
                    // 判断是否点击了地洞
                    for (i = 0; i &lt; 9; i++)
                    {
                        // 矩形范围判断
                        if (m.x &gt; box[i].posx_hole - 25 &amp;&amp; m.y &gt; box[i].posy_hole - 85 &amp;&amp; m.x &lt; box[i].posx_hole + 35 &amp;&amp; m.y &lt; box[i].posy_hole - 20
                            &amp;&amp; (box[i].type == 1 || box[i].type == 3))
                        {
                            // 正常鼹鼠
                            if (box[i].type == 1)
                            {
                                // 增加得分
                                start_point++;
                            }
                            // 红眼鼹鼠
                            else if (box[i].type == 3)
                            {
                                // 减少得分
                                start_point += point_punishment;
                            }
                            // 更改为僵直状态
                            box[i].type = 2;
                            // 重置为僵直时间
                            box[i].time_life = speed_gopher_beaten;
                            break;
                        }
                    }
                }
                else
                {
                    // 判断是否点击了按钮
                    for (i = 0; i &lt; num_button; i++)
                    {
                        if (m.x &gt; boxm[i].posx1 &amp;&amp; m.y &gt; boxm[i].posy1 &amp;&amp; m.x &lt; boxm[i].posx2 &amp;&amp; m.y &lt; boxm[i].posy2 &amp;&amp; boxm[i].type == 0)
                        {
                            break;
                        }
                    }
                    // 返回按钮
                    if (i == 0)
                    {
                        exit_start = 1;
                    }
                }
                // 绘制                    
                draw_scene_start ();
            }
        }

        // 时间更新，以及退出判断
        start_t2 = clock ();
        if ((start_t2 - start_t1) % 100 &lt;= 10)
        {
            // 达到时间间隔，生成新鼹鼠
            if ((start_t2 - start_t1) % (speed_creact * 100) &lt;= 10)
            {
                // 根据每次生成数量参数进行生成
                for (i = 0; i &lt; every_creact_num; i++)
                {
                    creact_gopher ();
                    // 某次生成完已结束，直接结束循环，退出，避免生成多个结束提示框
                    if (exit_start != 0)
                    {
                        break;
                    }
                }
            }
            // 鼹鼠状态更新
            for (i = 0; i &lt; 9; i++)
            {
                // 存在时间减少
                if (box[i].type != 0)
                {
                    box[i].time_life--;
                }
                // 时间减少至零，鼹鼠消失，修改地洞参数
                if (box[i].time_life &lt;= 0)
                {
                    box[i].type = 0;
                }
            }
            draw_scene_start ();
            Sleep (10);
        }
        if ((start_t2 - start_t1) &gt;= start_endtime)
        {
            draw_scene_start ();
            // 退出提示
            MessageBox (hOut, _T ("时间到了，结束啦"), _T ("来自小豆子的提醒"), MB_OK);
            exit_start = 1;
        }
    }
}


// 开始进程初始化函数
void game::initialization_start ()
{
    int i;
    // 按钮设置初始化
    num_button = 1;

    boxm[0].posx1 = 710; boxm[0].posy1 = 130;    boxm[0].posx2 = 790; boxm[0].posy2 = 190;    boxm[0].text = _T ("返回"); boxm[0].type = 0;

    // 地洞参数初始化
    i = 0; box[i].posx_hole = 300; box[i].posy_hole = 250;
    i = 1; box[i].posx_hole = 420; box[i].posy_hole = 250;
    i = 2; box[i].posx_hole = 540; box[i].posy_hole = 250;
    i = 3; box[i].posx_hole = 280; box[i].posy_hole = 350;
    i = 4; box[i].posx_hole = 420; box[i].posy_hole = 350;
    i = 5; box[i].posx_hole = 560; box[i].posy_hole = 350;
    i = 6; box[i].posx_hole = 260; box[i].posy_hole = 450;
    i = 7; box[i].posx_hole = 420; box[i].posy_hole = 450;
    i = 8; box[i].posx_hole = 580; box[i].posy_hole = 450;

    for (i = 0; i &lt; 9; i++)
    {
        box[i].type = 0;
        box[i].posx_gopher = box[i].posx_hole + 5;
        box[i].posy_gopher = box[i].posy_hole - 52;
    }

    // 绘制
    draw_scene_start ();
}


// 开始进程绘制函数
void game::draw_scene_start ()
{
    int i;

    // 绘制主背景
    float posx, posy, size;
    POINT pts[100];

    setlinestyle (PS_SOLID, 1);
    // 天空
    setlinecolor (RGB (199, 234, 255));
    setfillcolor (RGB (199, 234, 255));
    fillrectangle (0, 0, 800, 120);
    // 土地
    setlinecolor (RGB (184, 147, 69));
    setfillcolor (RGB (184, 147, 69));
    fillrectangle (0, 120, 800, 480);

    setlinecolor (RGB (195, 152, 58));
    setfillcolor (RGB (195, 152, 58));
    pts[0].x = 240;    pts[0].y = 120;
    pts[1].x = 50;    pts[1].y = 480;
    pts[2].x = 780;    pts[2].y = 480;
    pts[3].x = 620;    pts[3].y = 120;
    fillpolygon (pts, 4);

    setlinecolor (RGB (152, 109, 58));
    setfillcolor (RGB (152, 109, 58));
    pts[0].x = 255;    pts[0].y = 120;
    pts[1].x = 75;    pts[1].y = 480;
    pts[2].x = 755;    pts[2].y = 480;
    pts[3].x = 605;    pts[3].y = 120;
    fillpolygon (pts, 4);

    // 树叶
    posx = 300; posy = 300; size = 1;
    setlinecolor (RGB (38, 153, 0));
    setfillcolor (RGB (38, 153, 0));
    pts[0].x = long (178 * size + posx);    pts[0].y = long (-231 * size + posy);
    pts[1].x = long (174 * size + posx);    pts[1].y = long (-225 * size + posy);
    pts[2].x = long (170 * size + posx);    pts[2].y = long (-220 * size + posy);
    pts[3].x = long (162 * size + posx);    pts[3].y = long (-214 * size + posy);
    pts[4].x = long (156 * size + posx);    pts[4].y = long (-214 * size + posy);
    pts[5].x = long (148 * size + posx);    pts[5].y = long (-214 * size + posy);
    pts[6].x = long (140 * size + posx);    pts[6].y = long (-217 * size + posy);
    pts[7].x = long (139 * size + posx);    pts[7].y = long (-221 * size + posy);
    pts[8].x = long (133 * size + posx);    pts[8].y = long (-217 * size + posy);
    pts[9].x = long (125 * size + posx);    pts[9].y = long (-216 * size + posy);
    pts[10].x = long (120 * size + posx);    pts[10].y = long (-220 * size + posy);
    pts[11].x = long (117 * size + posx);    pts[11].y = long (-219 * size + posy);
    pts[12].x = long (111 * size + posx);    pts[12].y = long (-217 * size + posy);
    pts[13].x = long (107 * size + posx);    pts[13].y = long (-217 * size + posy);
    pts[14].x = long (99 * size + posx);    pts[14].y = long (-221 * size + posy);
    pts[15].x = long (97 * size + posx);    pts[15].y = long (-228 * size + posy);
    pts[16].x = long (96 * size + posx);    pts[16].y = long (-229 * size + posy);
    pts[17].x = long (90 * size + posx);    pts[17].y = long (-229 * size + posy);
    pts[18].x = long (84 * size + posx);    pts[18].y = long (-227 * size + posy);
    pts[19].x = long (78 * size + posx);    pts[19].y = long (-230 * size + posy);
    pts[20].x = long (74 * size + posx);    pts[20].y = long (-233 * size + posy);
    pts[21].x = long (65 * size + posx);    pts[21].y = long (-241 * size + posy);
    pts[22].x = long (69 * size + posx);    pts[22].y = long (-251 * size + posy);
    pts[23].x = long (64 * size + posx);    pts[23].y = long (-251 * size + posy);
    pts[24].x = long (58 * size + posx);    pts[24].y = long (-254 * size + posy);
    pts[25].x = long (56 * size + posx);    pts[25].y = long (-260 * size + posy);
    pts[26].x = long (59 * size + posx);    pts[26].y = long (-267 * size + posy);
    pts[27].x = long (61 * size + posx);    pts[27].y = long (-269 * size + posy);
    pts[28].x = long (56 * size + posx);    pts[28].y = long (-274 * size + posy);
    pts[29].x = long (52 * size + posx);    pts[29].y = long (-277 * size + posy);
    pts[30].x = long (52 * size + posx);    pts[30].y = long (-284 * size + posy);
    pts[31].x = long (56 * size + posx);    pts[31].y = long (-287 * size + posy);
    pts[32].x = long (51 * size + posx);    pts[32].y = long (-294 * size + posy);
    pts[33].x = long (52 * size + posx);    pts[33].y = long (-300 * size + posy);
    pts[34].x = long (350 * size + posx);    pts[34].y = long (-300 * size + posy);
    pts[35].x = long (361 * size + posx);    pts[35].y = long (-295 * size + posy);
    pts[36].x = long (365 * size + posx);    pts[36].y = long (-288 * size + posy);
    pts[37].x = long (360 * size + posx);    pts[37].y = long (-278 * size + posy);
    pts[38].x = long (358 * size + posx);    pts[38].y = long (-276 * size + posy);
    pts[39].x = long (365 * size + posx);    pts[39].y = long (-269 * size + posy);
    pts[40].x = long (368 * size + posx);    pts[40].y = long (-261 * size + posy);
    pts[41].x = long (363 * size + posx);    pts[41].y = long (-257 * size + posy);
    pts[42].x = long (360 * size + posx);    pts[42].y = long (-251 * size + posy);
    pts[43].x = long (358 * size + posx);    pts[43].y = long (-247 * size + posy);
    pts[44].x = long (356 * size + posx);    pts[44].y = long (-245 * size + posy);
    pts[45].x = long (356 * size + posx);    pts[45].y = long (-241 * size + posy);
    pts[46].x = long (355 * size + posx);    pts[46].y = long (-238 * size + posy);
    pts[47].x = long (349 * size + posx);    pts[47].y = long (-234 * size + posy);
    pts[48].x = long (344 * size + posx);    pts[48].y = long (-233 * size + posy);
    pts[49].x = long (340 * size + posx);    pts[49].y = long (-226 * size + posy);
    pts[50].x = long (336 * size + posx);    pts[50].y = long (-222 * size + posy);
    pts[51].x = long (329 * size + posx);    pts[51].y = long (-220 * size + posy);
    pts[52].x = long (320 * size + posx);    pts[52].y = long (-220 * size + posy);
    pts[53].x = long (314 * size + posx);    pts[53].y = long (-222 * size + posy);
    pts[54].x = long (312 * size + posx);    pts[54].y = long (-225 * size + posy);
    pts[55].x = long (306 * size + posx);    pts[55].y = long (-220 * size + posy);
    pts[56].x = long (297 * size + posx);    pts[56].y = long (-218 * size + posy);
    pts[57].x = long (285 * size + posx);    pts[57].y = long (-216 * size + posy);
    pts[58].x = long (279 * size + posx);    pts[58].y = long (-220 * size + posy);
    pts[59].x = long (271 * size + posx);    pts[59].y = long (-222 * size + posy);
    pts[60].x = long (270 * size + posx);    pts[60].y = long (-226 * size + posy);
    pts[61].x = long (267 * size + posx);    pts[61].y = long (-220 * size + posy);
    pts[62].x = long (262 * size + posx);    pts[62].y = long (-215 * size + posy);
    pts[63].x = long (258 * size + posx);    pts[63].y = long (-213 * size + posy);
    pts[64].x = long (251 * size + posx);    pts[64].y = long (-214 * size + posy);
    pts[65].x = long (248 * size + posx);    pts[65].y = long (-217 * size + posy);
    pts[66].x = long (247 * size + posx);    pts[66].y = long (-218 * size + posy);
    pts[67].x = long (237 * size + posx);    pts[67].y = long (-228 * size + posy);
    pts[68].x = long (227 * size + posx);    pts[68].y = long (-235 * size + posy);
    pts[69].x = long (217 * size + posx);    pts[69].y = long (-242 * size + posy);
    pts[70].x = long (204 * size + posx);    pts[70].y = long (-244 * size + posy);
    pts[71].x = long (190 * size + posx);    pts[71].y = long (-242 * size + posy);
    pts[72].x = long (179 * size + posx);    pts[72].y = long (-239 * size + posy);
    fillpolygon (pts, 73);
    // 树枝
    posx = 300; posy = 295; size = 1;
    setlinecolor (RGB (122, 71, 18));
    setfillcolor (RGB (122, 71, 18));
    pts[0].x = long (174 * size + posx);    pts[0].y = long (-172 * size + posy);
    pts[1].x = long (171 * size + posx);    pts[1].y = long (-178 * size + posy);
    pts[2].x = long (173 * size + posx);    pts[2].y = long (-185 * size + posy);
    pts[3].x = long (187 * size + posx);    pts[3].y = long (-191 * size + posy);
    pts[4].x = long (196 * size + posx);    pts[4].y = long (-207 * size + posy);
    pts[5].x = long (192 * size + posx);    pts[5].y = long (-221 * size + posy);
    pts[6].x = long (188 * size + posx);    pts[6].y = long (-229 * size + posy);
    pts[7].x = long (183 * size + posx);    pts[7].y = long (-233 * size + posy);
    pts[8].x = long (180 * size + posx);    pts[8].y = long (-231 * size + posy);
    pts[9].x = long (176 * size + posx);    pts[9].y = long (-229 * size + posy);
    pts[10].x = long (172 * size + posx);    pts[10].y = long (-233 * size + posy);
    pts[11].x = long (153 * size + posx);    pts[11].y = long (-232 * size + posy);
    pts[12].x = long (134 * size + posx);    pts[12].y = long (-233 * size + posy);
    pts[13].x = long (116 * size + posx);    pts[13].y = long (-237 * size + posy);
    pts[14].x = long (110 * size + posx);    pts[14].y = long (-241 * size + posy);
    pts[15].x = long (107 * size + posx);    pts[15].y = long (-246 * size + posy);
    pts[16].x = long (113 * size + posx);    pts[16].y = long (-248 * size + posy);
    pts[17].x = long (119 * size + posx);    pts[17].y = long (-253 * size + posy);
    pts[18].x = long (123 * size + posx);    pts[18].y = long (-248 * size + posy);
    pts[19].x = long (128 * size + posx);    pts[19].y = long (-248 * size + posy);
    pts[20].x = long (134 * size + posx);    pts[20].y = long (-249 * size + posy);
    pts[21].x = long (136 * size + posx);    pts[21].y = long (-252 * size + posy);
    pts[22].x = long (146 * size + posx);    pts[22].y = long (-253 * size + posy);
    pts[23].x = long (147 * size + posx);    pts[23].y = long (-255 * size + posy);
    pts[24].x = long (157 * size + posx);    pts[24].y = long (-249 * size + posy);
    pts[25].x = long (163 * size + posx);    pts[25].y = long (-245 * size + posy);
    pts[26].x = long (171 * size + posx);    pts[26].y = long (-242 * size + posy);
    pts[27].x = long (178 * size + posx);    pts[27].y = long (-241 * size + posy);
    pts[28].x = long (175 * size + posx);    pts[28].y = long (-248 * size + posy);
    pts[29].x = long (173 * size + posx);    pts[29].y = long (-253 * size + posy);
    pts[30].x = long (173 * size + posx);    pts[30].y = long (-259 * size + posy);
    pts[31].x = long (174 * size + posx);    pts[31].y = long (-262 * size + posy);
    pts[32].x = long (178 * size + posx);    pts[32].y = long (-264 * size + posy);
    pts[33].x = long (179 * size + posx);    pts[33].y = long (-260 * size + posy);
    pts[34].x = long (183 * size + posx);    pts[34].y = long (-247 * size + posy);
    pts[35].x = long (186 * size + posx);    pts[35].y = long (-242 * size + posy);
    pts[36].x = long (192 * size + posx);    pts[36].y = long (-240 * size + posy);
    pts[37].x = long (197 * size + posx);    pts[37].y = long (-242 * size + posy);
    pts[38].x = long (199 * size + posx);    pts[38].y = long (-247 * size + posy);
    pts[39].x = long (197 * size + posx);    pts[39].y = long (-250 * size + posy);
    pts[40].x = long (193 * size + posx);    pts[40].y = long (-253 * size + posy);
    pts[41].x = long (191 * size + posx);    pts[41].y = long (-256 * size + posy);
    pts[42].x = long (190 * size + posx);    pts[42].y = long (-259 * size + posy);
    pts[43].x = long (196 * size + posx);    pts[43].y = long (-265 * size + posy);
    pts[44].x = long (198 * size + posx);    pts[44].y = long (-266 * size + posy);
    pts[45].x = long (203 * size + posx);    pts[45].y = long (-261 * size + posy);
    pts[46].x = long (208 * size + posx);    pts[46].y = long (-251 * size + posy);
    pts[47].x = long (206 * size + posx);    pts[47].y = long (-247 * size + posy);
    pts[48].x = long (208 * size + posx);    pts[48].y = long (-246 * size + posy);
    pts[49].x = long (219 * size + posx);    pts[49].y = long (-245 * size + posy);
    pts[50].x = long (223 * size + posx);    pts[50].y = long (-248 * size + posy);
    pts[51].x = long (226 * size + posx);    pts[51].y = long (-254 * size + posy);
    pts[52].x = long (228 * size + posx);    pts[52].y = long (-261 * size + posy);
    pts[53].x = long (227 * size + posx);    pts[53].y = long (-263 * size + posy);
    pts[54].x = long (234 * size + posx);    pts[54].y = long (-263 * size + posy);
    pts[55].x = long (233 * size + posx);    pts[55].y = long (-258 * size + posy);
    pts[56].x = long (232 * size + posx);    pts[56].y = long (-246 * size + posy);
    pts[57].x = long (236 * size + posx);    pts[57].y = long (-245 * size + posy);
    pts[58].x = long (241 * size + posx);    pts[58].y = long (-247 * size + posy);
    pts[59].x = long (250 * size + posx);    pts[59].y = long (-252 * size + posy);
    pts[60].x = long (248 * size + posx);    pts[60].y = long (-248 * size + posy);
    pts[61].x = long (248 * size + posx);    pts[61].y = long (-243 * size + posy);
    pts[62].x = long (259 * size + posx);    pts[62].y = long (-244 * size + posy);
    pts[63].x = long (270 * size + posx);    pts[63].y = long (-250 * size + posy);
    pts[64].x = long (272 * size + posx);    pts[64].y = long (-250 * size + posy);
    pts[65].x = long (272 * size + posx);    pts[65].y = long (-248 * size + posy);
    pts[66].x = long (270 * size + posx);    pts[66].y = long (-243 * size + posy);
    pts[67].x = long (266 * size + posx);    pts[67].y = long (-240 * size + posy);
    pts[68].x = long (259 * size + posx);    pts[68].y = long (-236 * size + posy);
    pts[69].x = long (250 * size + posx);    pts[69].y = long (-234 * size + posy);
    pts[70].x = long (248 * size + posx);    pts[70].y = long (-234 * size + posy);
    pts[71].x = long (244 * size + posx);    pts[71].y = long (-221 * size + posy);
    pts[72].x = long (246 * size + posx);    pts[72].y = long (-213 * size + posy);
    pts[73].x = long (246 * size + posx);    pts[73].y = long (-200 * size + posy);
    pts[74].x = long (250 * size + posx);    pts[74].y = long (-188 * size + posy);
    pts[75].x = long (253 * size + posx);    pts[75].y = long (-183 * size + posy);
    pts[76].x = long (255 * size + posx);    pts[76].y = long (-179 * size + posy);
    pts[77].x = long (259 * size + posx);    pts[77].y = long (-177 * size + posy);
    pts[78].x = long (262 * size + posx);    pts[78].y = long (-174 * size + posy);
    fillpolygon (pts, 79);
    // 树帽
    posx = 300; posy = 295; size = 1;
    setlinecolor (RGB (40, 176, 0));
    setfillcolor (RGB (40, 176, 0));
    pts[0].x = long (98 * size + posx);    pts[0].y = long (-255 * size + posy);
    pts[1].x = long (102 * size + posx);    pts[1].y = long (-250 * size + posy);
    pts[2].x = long (108 * size + posx);    pts[2].y = long (-245 * size + posy);
    pts[3].x = long (118 * size + posx);    pts[3].y = long (-253 * size + posy);
    pts[4].x = long (122 * size + posx);    pts[4].y = long (-247 * size + posy);
    pts[5].x = long (128 * size + posx);    pts[5].y = long (-245 * size + posy);
    pts[6].x = long (136 * size + posx);    pts[6].y = long (-253 * size + posy);
    pts[7].x = long (144 * size + posx);    pts[7].y = long (-254 * size + posy);
    pts[8].x = long (149 * size + posx);    pts[8].y = long (-260 * size + posy);
    pts[9].x = long (170 * size + posx);    pts[9].y = long (-271 * size + posy);
    pts[10].x = long (176 * size + posx);    pts[10].y = long (-264 * size + posy);
    pts[11].x = long (181 * size + posx);    pts[11].y = long (-266 * size + posy);
    pts[12].x = long (189 * size + posx);    pts[12].y = long (-276 * size + posy);
    pts[13].x = long (194 * size + posx);    pts[13].y = long (-268 * size + posy);
    pts[14].x = long (198 * size + posx);    pts[14].y = long (-270 * size + posy);
    pts[15].x = long (207 * size + posx);    pts[15].y = long (-268 * size + posy);
    pts[16].x = long (209 * size + posx);    pts[16].y = long (-264 * size + posy);
    pts[17].x = long (213 * size + posx);    pts[17].y = long (-264 * size + posy);
    pts[18].x = long (222 * size + posx);    pts[18].y = long (-264 * size + posy);
    pts[19].x = long (240 * size + posx);    pts[19].y = long (-262 * size + posy);
    pts[20].x = long (247 * size + posx);    pts[20].y = long (-257 * size + posy);
    pts[21].x = long (260 * size + posx);    pts[21].y = long (-251 * size + posy);
    pts[22].x = long (267 * size + posx);    pts[22].y = long (-258 * size + posy);
    pts[23].x = long (276 * size + posx);    pts[23].y = long (-256 * size + posy);
    pts[24].x = long (285 * size + posx);    pts[24].y = long (-254 * size + posy);
    pts[25].x = long (291 * size + posx);    pts[25].y = long (-256 * size + posy);
    pts[26].x = long (292 * size + posx);    pts[26].y = long (-259 * size + posy);
    pts[27].x = long (289 * size + posx);    pts[27].y = long (-263 * size + posy);
    pts[28].x = long (282 * size + posx);    pts[28].y = long (-261 * size + posy);
    pts[29].x = long (276 * size + posx);    pts[29].y = long (-260 * size + posy);
    pts[30].x = long (272 * size + posx);    pts[30].y = long (-264 * size + posy);
    pts[31].x = long (266 * size + posx);    pts[31].y = long (-262 * size + posy);
    pts[32].x = long (260 * size + posx);    pts[32].y = long (-260 * size + posy);
    pts[33].x = long (253 * size + posx);    pts[33].y = long (-261 * size + posy);
    pts[34].x = long (249 * size + posx);    pts[34].y = long (-264 * size + posy);
    pts[35].x = long (245 * size + posx);    pts[35].y = long (-266 * size + posy);
    pts[36].x = long (238 * size + posx);    pts[36].y = long (-264 * size + posy);
    pts[37].x = long (214 * size + posx);    pts[37].y = long (-266 * size + posy);
    pts[38].x = long (213 * size + posx);    pts[38].y = long (-269 * size + posy);
    pts[39].x = long (209 * size + posx);    pts[39].y = long (-272 * size + posy);
    pts[40].x = long (193 * size + posx);    pts[40].y = long (-280 * size + posy);
    pts[41].x = long (185 * size + posx);    pts[41].y = long (-277 * size + posy);
    pts[42].x = long (182 * size + posx);    pts[42].y = long (-273 * size + posy);
    pts[43].x = long (178 * size + posx);    pts[43].y = long (-271 * size + posy);
    pts[44].x = long (175 * size + posx);    pts[44].y = long (-271 * size + posy);
    pts[45].x = long (170 * size + posx);    pts[45].y = long (-273 * size + posy);
    pts[46].x = long (147 * size + posx);    pts[46].y = long (-262 * size + posy);
    pts[47].x = long (149 * size + posx);    pts[47].y = long (-267 * size + posy);
    pts[48].x = long (148 * size + posx);    pts[48].y = long (-269 * size + posy);
    pts[49].x = long (145 * size + posx);    pts[49].y = long (-265 * size + posy);
    pts[50].x = long (139 * size + posx);    pts[50].y = long (-259 * size + posy);
    pts[51].x = long (132 * size + posx);    pts[51].y = long (-258 * size + posy);
    pts[52].x = long (123 * size + posx);    pts[52].y = long (-260 * size + posy);
    pts[53].x = long (119 * size + posx);    pts[53].y = long (-256 * size + posy);
    pts[54].x = long (110 * size + posx);    pts[54].y = long (-255 * size + posy);
    pts[55].x = long (103 * size + posx);    pts[55].y = long (-257 * size + posy);
    pts[56].x = long (100 * size + posx);    pts[56].y = long (-258 * size + posy);


    fillpolygon (pts, 57);
    // 栏杆和栅栏
    for (i = 0; i &lt; 7; i++)
    {
        draw_left_railing (450 - i * 23, 10 + i * 43, 0.9);
        draw_left_fence (366 - i * 23, 200 + i * 43, 1);

        draw_right_railing (190 + i * 19, -40 + i * 43, 0.9);
        draw_right_fence (250 + i * 19, 213 + i * 43, 1);
    }
    i = 7;
    draw_left_railing (450 - i * 23, 10 + i * 43, 0.9);
    draw_right_railing (190 + i * 19, -40 + i * 43, 0.9);
    // 云朵
    draw_cloud (300, 300, 1);
    draw_cloud (-10, 200, 0.7);
    draw_cloud (-360, 350, 1.2);

    // 绘制鼹鼠
    for (i = 0; i &lt; 9; i++)
    {
        if (box[i].type != 0) { draw_gopher (box[i].posx_gopher, box[i].posy_gopher, 0.1, box[i].type); }
        draw_hole (box[i].posx_hole, box[i].posy_hole, 0.1);
    }

    // 绘制按钮
    draw_button ();

    // 绘制得分和时间
    TCHAR s[20];

    // 时间
    draw_word (30, 05, 125, _T ("时间："));
    _stprintf_s (s, _T ("%0.1f"), float ((start_endtime - (start_t2 - start_t1))) / 1000.0);
    draw_word (30, 10, 165, s);
    draw_word (30, 70, 165, _T ("秒"));

    // 得分
    draw_word (30, 10, 225, _T ("得分："));
    _stprintf_s (s, _T ("%0.1d"), start_point);
    draw_word (30, 10, 265, s);

    FlushBatchDraw ();
}


// 鼹鼠生成函数
void game::creact_gopher ()
{
    int i, j, k;
    // 空位检测
    k = 0;
    for (i = 0; i &lt; 9; i++)
    {
        if (box[i].type == 0)
        {
            k = 1;
            break;
        }
    }
    // 溢满退出检测
    if (hole_full_end == 1 &amp;&amp; k == 0)
    {
        // 退出提示
        exit_start = 1;
        draw_scene_start ();
        MessageBox (hOut, _T ("没有位置了，结束啦"), _T ("来自小豆子的提醒"), MB_OK);
    }
    // 有空位，则随机生成一只鼹鼠
    if (k == 1)
    {
        do
        {
            i = rand () % 9;
        } while (box[i].type != 0);
        // 是否是红眼
        j = rand () % (11 - gopher_red_eye_num);
        // 地洞状态更新
        // 正常鼹鼠
        if (j != 0 || gopher_red_eye_num == 0)
        {
            box[i].type = 1;
        }
        // 红眼鼹鼠
        else if (j == 0)
        {
            box[i].type = 3;
        }
        // 存在时间更新
        box[i].time_life = speed_gopher_life + 1;
    }
}</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a48b255fa68382884982251e6cb154c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win11完美卸载Oracle11G详细步骤如下</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/73039806867b390d2fb32754ea566fc6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jmeter:java.io.EOFException: Unexpected end of ZLIB input stream</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>