<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>手把手教你使用 CompletableFuture - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="手把手教你使用 CompletableFuture" />
<meta property="og:description" content="背景 在jdk5中，我们通过使用Future和Callable，可以在任务执行完毕后得到任务执行结果。可以使用isDone检测计算是否完成，使用cancle停止执行任务，使用阻塞方法get阻塞住调用线程来获取返回结果，使用阻塞方式获取执行结果，有违异步编程的初衷，而且Future的异常只能自己内部处理。
jdk8中加入了实现类CompletableFuture&lt;T&gt;，用于异步编程。底层做任务使用的是ForkJoin, 顾名思义，是将任务的数据集分为多个子数据集，而每个子集，都可以由独立的子任务来处理，最后将每个子任务的结果汇集起来。它是ExecutorService接口的一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程。 从api文档看，它实现了2个接口 CompletionStage&lt;T&gt;, Future&lt;T&gt;，CompletableFuture&lt;T&gt;拥有Future的所有特性。 CompletionStage支持lambda表达式，接口的方法的功能都是在某个阶段得到结果后要做的事情。 CompletableFuture内置lambda表达式，支持异步回调，结果转换等功能，它有以下Future实现不了的功能
合并两个相互独立的异步计算的结果。
等待异步任务的所有任务都完成。
等待异步任务的其中一个任务完成就返回结果。
任务完成后调用回调方法
任务完成的结果可以用于下一个任务。
任务完成时发出通知
提供原生的异常处理api
CompletableFuture的使用方法 首先说下获取结果方式 CompletableFuture获取结果的方式有如下4个方法：
1：get 阻塞获取结果，实现Future的get接口，显式抛出异常
2：getNow(T valueIfAbsent) 获取执行结果，如果当前任务未执行完成，则返回valueIfAbsent
3: join 执行完成后返回执行结果，或者抛出unchecked异常
4: T get(long timeout, TimeUnit unit) 在有限时间内获取数据
以下是CompletableFuture的创建对象以及api的使用
1: 创建CompletableFuture 对象 public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value) 静态方法，返回一个已经计算好的CompletableFuture 比如
@Testpublic void testStatic() { CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.completedFuture(&#34;test&#34;);	//判断cf是否 执行完毕 assertTrue(completableFuture.isDone());	//getNow获取结果，如果获取不到，返回默认值null assertEquals(&#34;test&#34;, completableFuture.getNow(null)); } completableFuture 还能主动结束运算，并显示处理异常，如下是异步执行的代码
@Test public void testActive() { CompletableFuture&lt;String&gt; completableFuture = new CompletableFuture();	new Thread(() -&gt; {	try { String string = null; string." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f32d575fce16b4597f25c3084e0d066e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-02T11:04:26+08:00" />
<meta property="article:modified_time" content="2020-06-02T11:04:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">手把手教你使用 CompletableFuture</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong>背景</strong></h3> 
<p>在jdk5中，我们通过使用Future和Callable，可以在任务执行完毕后得到任务执行结果。可以使用isDone检测计算是否完成，使用cancle停止执行任务，使用阻塞方法get阻塞住调用线程来获取返回结果，使用阻塞方式获取执行结果，有违异步编程的初衷，而且Future的异常只能自己内部处理。</p> 
<p>jdk8中加入了实现类CompletableFuture&lt;T&gt;，用于异步编程。底层做任务使用的是ForkJoin, 顾名思义，是将任务的数据集分为多个子数据集，而每个子集，都可以由独立的子任务来处理，最后将每个子任务的结果汇集起来。它是ExecutorService接口的一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程。 从api文档看，它实现了2个接口 CompletionStage&lt;T&gt;, Future&lt;T&gt;，CompletableFuture&lt;T&gt;拥有Future的所有特性。 CompletionStage支持lambda表达式，接口的方法的功能都是在某个阶段得到结果后要做的事情。 CompletableFuture内置lambda表达式，支持异步回调，结果转换等功能，它有以下Future实现不了的功能</p> 
<ul><li> <p>合并两个相互独立的异步计算的结果。</p> </li><li> <p>等待异步任务的所有任务都完成。</p> </li><li> <p>等待异步任务的其中一个任务完成就返回结果。</p> </li><li> <p>任务完成后调用回调方法</p> </li><li> <p>任务完成的结果可以用于下一个任务。</p> </li><li> <p>任务完成时发出通知</p> </li><li> <p>提供原生的异常处理api</p> </li></ul> 
<h3>CompletableFuture的使用方法</h3> 
<p>首先说下获取结果方式 CompletableFuture获取结果的方式有如下4个方法：</p> 
<p>1：get 阻塞获取结果，实现Future的get接口，显式抛出异常</p> 
<p>2：getNow(T valueIfAbsent) 获取执行结果，如果当前任务未执行完成，则返回valueIfAbsent</p> 
<p>3: join 执行完成后返回执行结果，或者抛出unchecked异常</p> 
<p>4: T get(long timeout, TimeUnit unit) 在有限时间内获取数据</p> 
<p>以下是CompletableFuture的创建对象以及api的使用</p> 
<h3>1: 创建CompletableFuture 对象</h3> 
<pre>public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value) 
</pre> 
<p>静态方法，返回一个已经计算好的CompletableFuture 比如</p> 
<pre><code>@Testpublic void testStatic() {
	CompletableFuture&lt;String&gt; completableFuture =              CompletableFuture.completedFuture("test");	//判断cf是否 执行完毕
	assertTrue(completableFuture.isDone());	//getNow获取结果，如果获取不到，返回默认值null
	assertEquals("test", completableFuture.getNow(null));
 }</code></pre> 
<p>completableFuture 还能主动结束运算，并显示处理异常，如下是异步执行的代码</p> 
<pre><code>@Test
public void testActive() {
	CompletableFuture&lt;String&gt; completableFuture = new CompletableFuture();	new Thread(() -&gt; {		try {
			String string = null;
			string.length();
			Thread.currentThread().sleep(2000);			
                        // 通知完成计算 ，并将结果complete返回
			completableFuture.complete("complete");
		} catch (Exception e) {
		    // 处理异常 在获取结果地方可以捕获到异常
		    completableFuture.completeExceptionally(e);
		}
	}).start();	
        try {
		// 同步等待返回结果  如果thread内部未发生异常并执行了complete方法，将得到字符串“complete”的结果
		System.out.println(completableFuture.join());
	} catch (Exception e) {
		//捕获线程内部的异常  捕获空指针异常
		System.out.println("发生异常了" + e.getMessage());
	}
}</code></pre> 
<h3>2: 使用工厂方式创建cf对象</h3> 
<p>CompletableFuture主要有以下四个工厂方式创建对象的静态方法:</p> 
<pre><code>public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) {  
    return asyncSupplyStage(asyncPool, supplier);
}
public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,Executor executor) {
  return asyncSupplyStage(screenExecutor(executor), supplier);
}
public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) {    
   return asyncRunStage(asyncPool, runnable);
}
public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor) {   
   return asyncRunStage(screenExecutor(executor), runnable);
}</code></pre> 
<p>Supplier是java8函数式编程的一个接口，是一个生产者，可以不接收参数。只有一个get方法返回一个泛型实例。 很明显，Async结尾的都是可以异步执行，runAsync 接收一个Runnable函数式接口类型参数，不返回结算结果。supplyAsync接收一个函数式接口类型Supplier ，可以返回计算结果。以上方法如果不指定执行任务的线程池Executor ，则默认使用ForkJoinPool.commonPoolcommonPool执行任务。这些接口都支持lambda实现异步的操作。 以下是SupplyAsync异步执行的简单示例</p> 
<pre><code>@Testpublic void testSupplyAsync() {
	CompletableFuture&lt;String&gt; cf = CompletableFuture.supplyAsync(() -&gt; {		//执行耗时任务
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}		return "glz";
	});	//获取结果
	System.out.println(cf.join());
}</code></pre> 
<h3>3: CompletableFuture 的异步回调功能</h3> 
<p>上面的方法，执行任务是异步操作。但是调用线程还在等待结果。我们还可以给cf添加回调方法，在任务执行完成后使用cf的结果再做下一步操作，转换。所以 执行以下方法时，cf已经计算完毕。</p> 
<pre><code>public &lt;U&gt; CompletionStage&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn);public &lt;U&gt; CompletionStage&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn);public &lt;U&gt; CompletionStage&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn,Executor executor);</code></pre> 
<p>从参数类型可以看到，这是接收一个cf计算的结果T,经过处理后返回参数类型为U的cf。 其中第一个方法是在cf完成的线程中调用。而带Async将在与调用者cf不同的线程中异步调用。</p> 
<pre><code>@Test
public void testThenApply() {
	CompletableFuture&lt;String&gt; cf = CompletableFuture.supplyAsync(() -&gt; {		// 执行耗时任务
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
               return "123";
	});
	// 这里cf的计算结果传个thenApply作为参数,执行字符串转int的方法，并返回一个cf对象cf1
	CompletableFuture&lt;Integer&gt; cf1 = cf.thenApply(Integer::parseInt);
	// cf1的计算结果作为参数x传给thenApply，返回一个心得cf对象 cf2.	CompletableFuture&lt;Double&gt; cf2 = cf1.thenApply(x -&gt; x * 0.01);
	// 获取最终结果
	System.out.println(cf2.join());
	//如果回调函数比较耗时，可以使用异步的方法thenApplyAsync}</code></pre> 
<h3>4: 运行完成时的代码，即对结果进行消耗</h3> 
<pre><code>public CompletionStage&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action); 
public CompletionStage&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action);
public CompletionStage&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action,Executor executor);</code></pre> 
<p>入参是Consumer ，执行Consumer 后没有返回结果，所以称为消耗。</p> 
<pre><code>@Test
public void thenAccept(){    
    CompletableFuture.supplyAsync(() -&gt; "gong").thenAccept(x -&gt; System.out.println(s+" lz"));
}</code></pre> 
<p>结果是 gong lz</p> 
<h3>5：上一步结果与下一步操作无关系</h3> 
<p>在执行cf后，如果得到的结果对下一步没有影响，也就是说下一步的操作并不关心上一步的结果，最终也不返回值，可以使用thenRun 参数传递一个Runnable.</p> 
<pre><code>public CompletionStage&lt;Void&gt; thenRun(Runnable action);public CompletionStage&lt;Void&gt; thenRunAsync(Runnable action);
public CompletionStage&lt;Void&gt; thenRunAsync(Runnable action,Executor executor);
@Test
public void thenRun() {
	CompletableFuture.supplyAsync(() -&gt; "hello").thenRun(() -&gt; System.out.println("hello world"));
}</code></pre> 
<h3>6: 对2个cf的结果进行组合thenCompose</h3> 
<pre><code>public &lt;U&gt; CompletionStage&lt;U&gt; thenCompose  (Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn); 
 public &lt;U&gt; CompletionStage&lt;U&gt; thenComposeAsync (Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn); 
 public &lt;U&gt; CompletionStage&lt;U&gt; thenComposeAsync (Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor);</code></pre> 
<p>thenCompose方法，可以将2个独立的任务进行流水线操作 。将当前cf的计算结果作为参数传递给后面的cf</p> 
<pre><code>@Test
public void testCompose() {
	CompletableFuture&lt;String&gt; cf = CompletableFuture.completedFuture("hello")
			.thenCompose(result -&gt; CompletableFuture.supplyAsync(() -&gt; {
				System.out.println(result);				
                                return "result";
			}));	
        System.out.println(cf.join());
}</code></pre> 
<h3>7： 结合2个cf的结果 thenCombine</h3> 
<p>可以将2个完全不相干的对象的结果整合起来，2项任务可以同时执行，比如一个对外的接口服务，既查询数据库中要查询数据的总量，也要返回具体某一页的数据，可以一个cf负责执行查询总条数count的sql，一个查询一页数据。BiFunction是合并结果数据的函数</p> 
<pre><code>public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</code></pre> 
<p>其中T是调用thenCombine的cf的结果数据，U是other的结果，v就是合并的结果类型。</p> 
<pre><code>@Test
public void testCombine() {
	CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; {		try {
			Thread.sleep(3000);
			System.out.println("cf1 is doning");
		} catch (InterruptedException e) {
			e.printStackTrace();
		} // 返回结果
		return "hello";
	});
	CompletableFuture&lt;String&gt; result = cf1.thenCombine(CompletableFuture.supplyAsync(() -&gt; {		try {
			Thread.sleep(500);
			System.out.println("cf2 is doning");
		} catch (InterruptedException e) {
			e.printStackTrace();
		}	
             return "world";		
	}), (x, y) -&gt; x + y);//合并2个操作结果
      System.out.println(result.join());
}</code></pre> 
<h3>8：消耗两个cf的结果，不返回结果</h3> 
<pre><code>&lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth(CompletableFuture&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; block)
CompletableFuture&lt;Void&gt; runAfterBoth(CompletableFuture&lt;?&gt; other, Runnable action)</code></pre> 
<p>对于2个cf，我们只想在他们执行完成时，消耗执行结果，但是不做数据返回，，我们只是希望当完成时得到通知. 此方法与thenCombine相似，只不过返回 CompletableFuture&lt;Void&gt; ,只做消耗处理</p> 
<pre><code>@Test
public void testAcceptBoth(){
    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; "100");
    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; 100);
    CompletableFuture&lt;Void&gt; future = future1.thenAcceptBoth(future2, (s, i) -&gt; System.out.println(Double.parseDouble(s + i)));

    try {
        future.get();
    } catch (InterruptedException e) {
        e.printStackTrace();
    } catch (ExecutionException e) {
        e.printStackTrace();
    }
}</code></pre> 
<h3>9：取计算速度最快的结果</h3> 
<p>针对两个CompletionStage，将计算最快的那个CompletionStage的结果用来作为下一步的消耗。 此方法接受Consumer只对结果进行消耗.</p> 
<pre><code>public CompletionStage&lt;Void&gt; acceptEither(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? super T&gt; action); 
 public CompletionStage&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? super T&gt; action); 
 public CompletionStage&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? super T&gt; action,Executor executor);</code></pre> 
<pre><code>@Test
public void acceptEither() {
	CompletableFuture.supplyAsync(() -&gt; {		
               try {	// 如果不加sleep，可能打印hello
			Thread.currentThread().sleep(10L);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}		return "hello";
	}).acceptEither(CompletableFuture.supplyAsync(() -&gt; "world"), result -&gt; {
		System.out.println(result);
	});
}</code></pre> 
<h3>10: 计算最快的cf的结果转换</h3> 
<p>针对两个CompletionStage，将计算的快的那个CompletionStage的结果用来作为下一步的转换操作。</p> 
<pre><code>public &lt;U&gt; CompletionStage&lt;U&gt; applyToEither(CompletionStage&lt;? extends T&gt; other,Function&lt;? super T, U&gt; fn);
public &lt;U&gt; CompletionStage&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other,Function&lt;? super T, U&gt; fn);
public &lt;U&gt; CompletionStage&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other,Function&lt;? super T, U&gt; fn,Executor executor);</code></pre> 
<p>fn是对 调用applyToEither的调用者和 other 2个计算最快的那个结果进行处理，传入t类型数据，返回一个CompletionStage</p> 
<pre><code>@Test
public void applyToEither() {
    double result = CompletableFuture.supplyAsync(() -&gt; {        
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }        return "0.001";
    }).applyToEither(CompletableFuture.supplyAsync(() -&gt; {       
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }        return "0.002";
    }), s -&gt; Double.valueOf(s)).join();   
     System.out.println(result);
}
    //由于返回0.002的cf睡眠时间比较短，先执行完毕，优先返回结果，所以2个cf最先返回0.002.最终result就是0.002</code></pre> 
<h3>11：2个cf都执行完后执行操作</h3> 
<p>2个cf都执行完后,执行操作Runnable,Runnable不关心2个cf的执行结果</p> 
<pre><code>public CompletionStage&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other,Runnable action);
public CompletionStage&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action);
public CompletionStage&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor);
    @Test
    public void runAfterBoth() {
	 CompletableFuture.supplyAsync(() -&gt; "m").runAfterBothAsync(CompletableFuture.supplyAsync(() -&gt;		"n"), () -&gt; System.out.println("hello world"));
    }</code></pre> 
<h3>12：处理cf数组</h3> 
<p>以上介绍的都是2个future的组合使用。cf还提供allOf，参数是cf数组，当数组中所有的cf都执行完成时，返回一个CompletableFuture&lt;Void&gt;。调用返回的cf的join方法阻塞等待cf数组中所有cf执行完成。 anyOf是当cf数组中任意一个cf执行完成后，就返回一个cf。</p> 
<pre><code>public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs);
public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs);</code></pre> 
<p>读者可自行编写示例代码</p> 
<h3>13: 异常处理</h3> 
<p>在上面手工创建cf对象中,介绍过异常的处理，同样使用工厂创建的cf也具有异常管理机制，读者可自行举一反三。</p> 
<h3>小结</h3> 
<p>本文简单介绍了cf的使用方法，读者可参阅java8实战这本书，更深入学习CompletableFuture的应用场景。</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3df2f0b7b6f42c42cb1628121cd5ee0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">详细简单的win中P，V操作（司机、售票员）C语言</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d985161dd4ee188b2fb0e2229060e279/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL操作时带数据库名与不带数据库名的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>