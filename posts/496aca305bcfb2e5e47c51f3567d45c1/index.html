<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;[面向对象的程序设计]_基础入门（上）(万字总结)（建议收藏！！！） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;[面向对象的程序设计]_基础入门（上）(万字总结)（建议收藏！！！）" />
<meta property="og:description" content="目录
1. C&#43;&#43;基础入门
1.1 变量 1.2 常量
1.3 关键字
1.4 标识符命名规则
1.5 数据类型
1.5.1 整型
1.5.2 sizeof 关键字
1.5.3 实型（浮点型）
1.5.4 字符型
1.5.5 转义字符
1.5.6 字符串类型
1.5.7 布尔类型
1.5.8 数据的输入
1.6 运算符
1.6.1 算术运算符 - 加减乘除运算
1.6.2 算术运算符 - 取模运算
1.6.3 算术运算符 - 递增递减
1.6.4 赋值运算符
1.6.5 比较运算符
1.6.6 逻辑运算符 - 非
1.6.7 逻辑运算符 - 与
1.6.8 逻辑运算符 - 或
1.7 程序流程结构
1.7.1 选择结构_单行if语句
1.7.2 选择结构_多行if语句
1.7.3 选择结构_多条件if语句
1.7.4 选择结构_嵌套if语句" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/496aca305bcfb2e5e47c51f3567d45c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-06T15:59:17+08:00" />
<meta property="article:modified_time" content="2023-12-06T15:59:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;[面向对象的程序设计]_基础入门（上）(万字总结)（建议收藏！！！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20C%2B%2B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-toc" style="margin-left:0px;"><a href="#1.%20C%2B%2B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8" rel="nofollow">1. C++基础入门</a></p> 
<p id="1.1%20%E5%8F%98%E9%87%8F%C2%A0-toc" style="margin-left:40px;"><a href="#1.1%20%E5%8F%98%E9%87%8F%C2%A0" rel="nofollow">1.1 变量 </a></p> 
<p id="1.2%20%E5%B8%B8%E9%87%8F-toc" style="margin-left:40px;"><a href="#1.2%20%E5%B8%B8%E9%87%8F" rel="nofollow">1.2 常量</a></p> 
<p id="1.3%20%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#1.3%20%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">1.3 关键字</a></p> 
<p id="1.4%20%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#1.4%20%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99" rel="nofollow">1.4 标识符命名规则</a></p> 
<p id="1.5%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#1.5%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">1.5 数据类型</a></p> 
<p id="1.5.1%20%E6%95%B4%E5%9E%8B-toc" style="margin-left:80px;"><a href="#1.5.1%20%E6%95%B4%E5%9E%8B" rel="nofollow">1.5.1 整型</a></p> 
<p id="1.5.2%20sizeof%20%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:80px;"><a href="#1.5.2%20sizeof%20%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">1.5.2 sizeof 关键字</a></p> 
<p id="1.5.3%20%E5%AE%9E%E5%9E%8B%EF%BC%88%E6%B5%AE%E7%82%B9%E5%9E%8B%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.5.3%20%E5%AE%9E%E5%9E%8B%EF%BC%88%E6%B5%AE%E7%82%B9%E5%9E%8B%EF%BC%89" rel="nofollow">1.5.3 实型（浮点型）</a></p> 
<p id="1.5.4%20%E5%AD%97%E7%AC%A6%E5%9E%8B-toc" style="margin-left:80px;"><a href="#1.5.4%20%E5%AD%97%E7%AC%A6%E5%9E%8B" rel="nofollow">1.5.4 字符型</a></p> 
<p id="1.5.5%20%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#1.5.5%20%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6" rel="nofollow">1.5.5 转义字符</a></p> 
<p id="1.5.6%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#1.5.6%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B" rel="nofollow">1.5.6 字符串类型</a></p> 
<p id="1.5.7%20%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#1.5.7%20%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B" rel="nofollow">1.5.7 布尔类型</a></p> 
<p id="1.5.8%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5-toc" style="margin-left:80px;"><a href="#1.5.8%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5" rel="nofollow">1.5.8 数据的输入</a></p> 
<p id="1.6%20%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#1.6%20%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">1.6 运算符</a></p> 
<p id="1.6.1%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97-toc" style="margin-left:80px;"><a href="#1.6.1%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97" rel="nofollow">1.6.1 算术运算符 - 加减乘除运算</a></p> 
<p id="1.6.2%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97-toc" style="margin-left:80px;"><a href="#1.6.2%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97" rel="nofollow">1.6.2 算术运算符 - 取模运算</a></p> 
<p id="1.6.3%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F-toc" style="margin-left:80px;"><a href="#1.6.3%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F" rel="nofollow">1.6.3 算术运算符 - 递增递减</a></p> 
<p id="1.6.4%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#1.6.4%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">1.6.4 赋值运算符</a></p> 
<p id="1.6.5%20%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#1.6.5%20%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">1.6.5 比较运算符</a></p> 
<p id="1.6.6%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E9%9D%9E-toc" style="margin-left:80px;"><a href="#1.6.6%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E9%9D%9E" rel="nofollow">1.6.6 逻辑运算符 - 非</a></p> 
<p id="1.6.7%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E4%B8%8E-toc" style="margin-left:80px;"><a href="#1.6.7%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E4%B8%8E" rel="nofollow">1.6.7 逻辑运算符 - 与</a></p> 
<p id="1.6.8%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E6%88%96-toc" style="margin-left:80px;"><a href="#1.6.8%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E6%88%96" rel="nofollow">1.6.8 逻辑运算符 - 或</a></p> 
<p id="1.7%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.7%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84" rel="nofollow">1.7 程序流程结构</a></p> 
<p id="1.7.1%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_%E5%8D%95%E8%A1%8Cif%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px;"><a href="#1.7.1%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_%E5%8D%95%E8%A1%8Cif%E8%AF%AD%E5%8F%A5" rel="nofollow">1.7.1 选择结构_单行if语句</a></p> 
<p id="1.7.2%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_%E5%A4%9A%E8%A1%8Cif%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px;"><a href="#1.7.2%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_%E5%A4%9A%E8%A1%8Cif%E8%AF%AD%E5%8F%A5" rel="nofollow">1.7.2 选择结构_多行if语句</a></p> 
<p id="1.7.3%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_%E5%A4%9A%E6%9D%A1%E4%BB%B6if%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px;"><a href="#1.7.3%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_%E5%A4%9A%E6%9D%A1%E4%BB%B6if%E8%AF%AD%E5%8F%A5" rel="nofollow">1.7.3 选择结构_多条件if语句</a></p> 
<p id="1.7.4%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_%E5%B5%8C%E5%A5%97if%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px;"><a href="#1.7.4%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_%E5%B5%8C%E5%A5%97if%E8%AF%AD%E5%8F%A5" rel="nofollow">1.7.4 选择结构_嵌套if语句</a></p> 
<p id="1.7.5%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E4%B8%89%E5%8F%AA%E5%B0%8F%E7%8C%AA%E7%A7%B0%E4%BD%93%E9%87%8D-toc" style="margin-left:80px;"><a href="#1.7.5%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E4%B8%89%E5%8F%AA%E5%B0%8F%E7%8C%AA%E7%A7%B0%E4%BD%93%E9%87%8D" rel="nofollow">1.7.5 选择结构案例_三只小猪称体重</a></p> 
<p id="1.7.6%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#1.7.6%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">1.7.6 选择结构案例_三目运算符</a></p> 
<p id="1.7.7%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_switch%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px;"><a href="#1.7.7%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_switch%E8%AF%AD%E5%8F%A5" rel="nofollow">1.7.7 选择结构_switch语句</a></p> 
<p id="1.7.8%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84_while%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px;"><a href="#1.7.8%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84_while%E8%AF%AD%E5%8F%A5" rel="nofollow">1.7.8 循环结构_while语句</a></p> 
<p id="1.7.9%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E7%8C%9C%E6%95%B0%E5%AD%97-toc" style="margin-left:80px;"><a href="#1.7.9%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E7%8C%9C%E6%95%B0%E5%AD%97" rel="nofollow">1.7.9 循环结构案例_猜数字</a></p> 
<p id="1.7.10%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84_dowhile%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px;"><a href="#1.7.10%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84_dowhile%E8%AF%AD%E5%8F%A5" rel="nofollow">1.7.10 循环结构_dowhile语句</a></p> 
<p id="1.7.11%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.7.11%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0" rel="nofollow">1.7.11 循环结构案例_水仙花数</a></p> 
<p id="1.7.12%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84_for%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px;"><a href="#1.7.12%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84_for%E5%BE%AA%E7%8E%AF" rel="nofollow">1.7.12 循环结构_for循环</a></p> 
<p id="1.7.13%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E6%95%B2%E6%A1%8C%E5%AD%90-toc" style="margin-left:80px;"><a href="#1.7.13%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E6%95%B2%E6%A1%8C%E5%AD%90" rel="nofollow">1.7.13 循环结构案例_敲桌子</a></p> 
<p id="1.7.14%20%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF-toc" style="margin-left:80px;"><a href="#1.7.14%20%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF" rel="nofollow">1.7.14 嵌套循环</a></p> 
<p id="1.7.15%20%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E6%A1%88%E4%BE%8B_%E4%B9%98%E6%B3%95%E5%8F%A3%E8%AF%80%E8%A1%A8-toc" style="margin-left:80px;"><a href="#1.7.15%20%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E6%A1%88%E4%BE%8B_%E4%B9%98%E6%B3%95%E5%8F%A3%E8%AF%80%E8%A1%A8" rel="nofollow">1.7.15 嵌套循环案例_乘法口诀表</a></p> 
<p id="1.7.16%20%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5_break%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px;"><a href="#1.7.16%20%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5_break%E8%AF%AD%E5%8F%A5" rel="nofollow">1.7.16 跳转语句_break语句</a></p> 
<p id="1.7.17%20%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5_continue-toc" style="margin-left:80px;"><a href="#1.7.17%20%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5_continue" rel="nofollow">1.7.17 跳转语句_continue</a></p> 
<p id="1.7.18%20%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5_goto-toc" style="margin-left:80px;"><a href="#1.7.18%20%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5_goto" rel="nofollow">1.7.18 跳转语句_goto</a></p> 
<p id="1.8%20%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#1.8%20%E6%95%B0%E7%BB%84" rel="nofollow">1.8 数组</a></p> 
<p id="1.8.1%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#1.8.1%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F" rel="nofollow">1.8.1 一维数组定义方式</a></p> 
<p id="1.8.2%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%20-%20%E6%95%B0%E7%BB%84%E5%90%8D-toc" style="margin-left:80px;"><a href="#1.8.2%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%20-%20%E6%95%B0%E7%BB%84%E5%90%8D" rel="nofollow">1.8.2 一维数组 - 数组名</a></p> 
<p id="1.8.3%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B%20-%20%E4%BA%94%E5%8F%AA%E5%B0%8F%E7%8C%AA%E7%A7%B0%E4%BD%93%E9%87%8D-toc" style="margin-left:80px;"><a href="#1.8.3%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B%20-%20%E4%BA%94%E5%8F%AA%E5%B0%8F%E7%8C%AA%E7%A7%B0%E4%BD%93%E9%87%8D" rel="nofollow">1.8.3 一维数组案例 - 五只小猪称体重</a></p> 
<p id="1.8.4%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B%20-%20%E5%85%83%E7%B4%A0%E9%80%86%E7%BD%AE-toc" style="margin-left:80px;"><a href="#1.8.4%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B%20-%20%E5%85%83%E7%B4%A0%E9%80%86%E7%BD%AE" rel="nofollow">1.8.4 一维数组案例 - 元素逆置</a></p> 
<p id="1.8.5%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%20-%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#1.8.5%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%20-%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" rel="nofollow">1.8.5 一维数组 - 冒泡排序</a></p> 
<p id="1.8.6%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#1.8.6%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F" rel="nofollow">1.8.6 二维数组定义方式</a></p> 
<p id="1.8.7%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%20-%20%E6%95%B0%E7%BB%84%E5%90%8D-toc" style="margin-left:80px;"><a href="#1.8.7%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%20-%20%E6%95%B0%E7%BB%84%E5%90%8D" rel="nofollow">1.8.7 二维数组 - 数组名</a></p> 
<p id="1.8.8%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B%20-%20%E8%80%83%E8%AF%95%E6%88%90%E7%BB%A9%E7%BB%9F%E8%AE%A1-toc" style="margin-left:80px;"><a href="#1.8.8%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B%20-%20%E8%80%83%E8%AF%95%E6%88%90%E7%BB%A9%E7%BB%9F%E8%AE%A1" rel="nofollow">1.8.8 二维数组案例 - 考试成绩统计</a></p> 
<p id="1.9%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#1.9%20%E5%87%BD%E6%95%B0" rel="nofollow">1.9 函数</a></p> 
<p id="1.9.1%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#1.9.1%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">1.9.1 函数的定义</a></p> 
<p id="1.9.2%20%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.9.2%20%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8" rel="nofollow">1.9.2 函数的调用</a></p> 
<p id="1.9.3%20%E5%80%BC%E4%BC%A0%E9%80%92-toc" style="margin-left:80px;"><a href="#1.9.3%20%E5%80%BC%E4%BC%A0%E9%80%92" rel="nofollow">1.9.3 值传递</a></p> 
<p id="1.9.4%20%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A0%B7%E5%BC%8F-toc" style="margin-left:80px;"><a href="#1.9.4%20%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A0%B7%E5%BC%8F" rel="nofollow">1.9.4 常见的样式</a></p> 
<p id="1.9.5%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E-toc" style="margin-left:80px;"><a href="#1.9.5%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E" rel="nofollow">1.9.5 函数的声明</a></p> 
<p id="1.9.6%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99-toc" style="margin-left:80px;"><a href="#1.9.6%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99" rel="nofollow">1.9.6 函数的分文件编写</a></p> 
<p id="1.10%20%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#1.10%20%E6%8C%87%E9%92%88" rel="nofollow">1.10 指针</a></p> 
<p id="1.10.1%20%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.10.1%20%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8" rel="nofollow">1.10.1 指针的定义和使用</a></p> 
<p id="1.10.2%20%E6%8C%87%E9%92%88%E6%89%80%E5%8D%A0%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4-toc" style="margin-left:80px;"><a href="#1.10.2%20%E6%8C%87%E9%92%88%E6%89%80%E5%8D%A0%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4" rel="nofollow">1.10.2 指针所占内存空间</a></p> 
<p id="1.10.3%20%E7%A9%BA%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#1.10.3%20%E7%A9%BA%E6%8C%87%E9%92%88" rel="nofollow">1.10.3 空指针</a></p> 
<p id="1.10.4%20%E9%87%8E%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#1.10.4%20%E9%87%8E%E6%8C%87%E9%92%88" rel="nofollow">1.10.4 野指针</a></p> 
<p id="1.10.5%20const%20%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#1.10.5%20const%20%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88" rel="nofollow">1.10.5 const 修饰指针</a></p> 
<p id="1.10.6%20%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#1.10.6%20%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84" rel="nofollow">1.10.6 指针和数组</a></p> 
<p id="1.10.7%20%E6%8C%87%E9%92%88%E5%92%8C%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.10.7%20%E6%8C%87%E9%92%88%E5%92%8C%E5%87%BD%E6%95%B0" rel="nofollow">1.10.7 指针和函数</a></p> 
<p id="1.10.8%20%E6%8C%87%E9%92%88%E9%85%8D%E5%90%88%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><a href="#1.10.8%20%E6%8C%87%E9%92%88%E9%85%8D%E5%90%88%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0%E6%A1%88%E4%BE%8B" rel="nofollow">1.10.8 指针配合数组和函数案例</a></p> 
<p id="1.11%20%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:40px;"><a href="#1.11%20%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">1.11 结构体</a></p> 
<p id="1.11.1%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.11.1%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8" rel="nofollow">1.11.1 结构体的定义和使用</a></p> 
<p id="1.11.2%20%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#1.11.2%20%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84" rel="nofollow">1.11.2 结构体数组</a></p> 
<p id="1.11.3%20%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#1.11.3%20%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88" rel="nofollow">1.11.3 结构体指针</a></p> 
<p id="1.11.4%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:80px;"><a href="#1.11.4%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">1.11.4 结构体嵌套结构体</a></p> 
<p id="1.11.5%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#1.11.5%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" rel="nofollow">1.11.5 结构体做函数参数</a></p> 
<p id="1.11.6%20%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%ADconst%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><a href="#1.11.6%20%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%ADconst%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">1.11.6 结构体中const使用场景</a></p> 
<p id="1.11.7%20%E7%BB%93%E6%9E%84%E4%BD%93%E6%A1%88%E4%BE%8B1-toc" style="margin-left:80px;"><a href="#1.11.7%20%E7%BB%93%E6%9E%84%E4%BD%93%E6%A1%88%E4%BE%8B1" rel="nofollow">1.11.7 结构体案例1</a></p> 
<p id="1.11.8%20%E7%BB%93%E6%9E%84%E4%BD%93%E6%A1%88%E4%BE%8B2-toc" style="margin-left:80px;"><a href="#1.11.8%20%E7%BB%93%E6%9E%84%E4%BD%93%E6%A1%88%E4%BE%8B2" rel="nofollow">1.11.8 结构体案例2</a></p> 
<p id="1.12%20%E9%80%9A%E8%AE%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-toc" style="margin-left:40px;"><a href="#1.12%20%E9%80%9A%E8%AE%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" rel="nofollow">1.12 通讯管理系统</a></p> 
<p id="1.12.1%20%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA-toc" style="margin-left:80px;"><a href="#1.12.1%20%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA" rel="nofollow">1.12.1 系统功能介绍及代码展示</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<hr id="hr-toc"> 
<p></p> 
<p>        <span style="color:#fe2c24;"><strong>C++ </strong></span><span style="color:#0d0016;">在 C 语言的基础上</span>进一步扩充和完善了 C 语言，成为一种面向对象的程序设计语言，C++ 应用广泛，支持多种编程范式，面向对象编程、泛型编程和过程化编程。从这里开始，我们踏上 C++ 的学习之路。<span style="background-color:#ffd900;">长路漫漫亦灿灿，祝我也祝所有看到这篇文章的朋友！！！</span></p> 
<h2 id="1.%20C%2B%2B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span style="color:#956fe7;"><strong>1. C++基础入门</strong></span></h2> 
<p>        相信大多数朋友和我一样，在学习 C 语言的过程中，都经历了从 HelloWorld 开始的程序编写；C++ 作为一门编程语言，首先我们就从 HelloWorld 开始书写！</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>用 C++ 书写 HelloWorld！！！<br>         </strong></span><span style="color:#0d0016;">编译平台：Visual Studio 2013；</span></p> 
 <p><span style="color:#0d0016;">        大家对 C++ 的创建过程一定很熟悉了，这里简单的回顾如何创建 C++ 工程！首先 <strong>文件 -&gt; 添加项目 -&gt; 添加空项目(合理设置路径和名称) -&gt; 源文件 -&gt; 添加新建项 -&gt; C++文件(合理设置文件名即可)</strong>。到这里，一个 C++ 的项目的创建成功！</span></p> 
 <pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
	system("pause");

	return 0;
}

//这里是一个 c++ 的程序框架，不管我们写任何 c++ 代码，都可以先写上这些代码
//至于为什么，我们往下学习！！！</code></pre> 
 <p>        当我们在<span style="color:#0d0016;"><strong> system("pause"); </strong></span>前加上<span style="color:#0d0016;"><strong> cout &lt;&lt; "Hello World" &lt;&lt; endl; </strong></span>以后，就可以打印出 Hello World 了，也就是说在 &lt;&lt; &lt;&lt; （双书名号）中加上要打印的字符即可打印出我们想要 Hello World 了。</p> 
 <p><img alt="" height="260" src="https://images2.imgbox.com/39/c1/GggdIqvM_o.png" width="535"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注释：</strong></span></p> 
 <p>        在代码中加一些说明和解释，方便自己或其他程序员阅读代码！！！</p> 
 <p>        在 C++ 中有两种格式的注释代码：</p> 
 <p>        <span style="color:#0d0016;"><strong>1. 单行注释： // 描述信号</strong></span></p> 
 <p>         通常放在一行代码的上方，或者一条语句的末尾，<span style="background-color:#ffd900;">对该行代码说明</span>。</p> 
 <p>        <span style="color:#0d0016;"><strong>2. 多行注释： /* 描述信息 */</strong></span></p> 
 <p>        通常放在一段代码的上方，<span style="background-color:#ffd900;">对该段代码做整体说明</span>。</p> 
 <p>        <span style="color:#4da8ee;"><strong>编译器在编译代码时，会忽略注释的内容。</strong></span></p> 
</blockquote> 
<h3 id="1.1%20%E5%8F%98%E9%87%8F%C2%A0"><span style="color:#4da8ee;">1.1 变量 </span></h3> 
<p>        <span style="color:#0d0016;"><strong>变量本质的作用</strong></span>：<span style="background-color:#ffd900;">给一段指定的内存空间起名，方便操作这段内存</span>。（首先我们知道 C++ 中的所有数据都会放在内存中，变量就相当于给这段内存起个名字，方便我们操作这段内存）</p> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：<span style="background-color:#ffd900;">数据类型  变量名  =  初始值；</span></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/10/6f/EB6vQOwQ_o.png" width="427"></p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/0c/1f/pXhWx8XP_o.png" width="549"></p> 
<h3 id="1.2%20%E5%B8%B8%E9%87%8F"><span style="color:#4da8ee;">1.2 常量</span></h3> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：用于记录程序中不可更改的数据。</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>C++ 定义常量的两种方式：</strong></span></p> 
 <p>        <span style="color:#0d0016;"><strong>1. #define 宏常量</strong></span>：<span style="background-color:#ffd900;">#define 常量名 常量值</span></p> 
 <p>        <span style="background-color:#ffd900;">通常在文件上方</span>，表示一个常量。</p> 
 <p>        <span style="color:#0d0016;"><strong>2. const 修饰的变量</strong></span>：<span style="background-color:#ffd900;">const 数据类型 常量名 = 常量值</span></p> 
 <p>        <span style="background-color:#ffd900;">通常在变量定义前加关键字 const</span>，修饰该变量为常量，不可修改。</p> 
</blockquote> 
<p><img alt="" height="400" src="https://images2.imgbox.com/bc/bc/Vg594u6z_o.png" width="604"></p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/ed/e1/H9vRiFlb_o.png" width="720"></p> 
<h3 id="1.3%20%E5%85%B3%E9%94%AE%E5%AD%97"><span style="color:#4da8ee;">1.3 关键字</span></h3> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">关键字是 C++ 中预先保留的单次（标识符）</span></p> 
<p>        <span style="color:#fe2c24;"><strong>在定义变量或常量的时候，不要用关键字。</strong></span></p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/9b/13/oo4P95Lj_o.png" width="519"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>在定义变量或常量的时候，不要用关键字。</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>        </strong></span><span style="color:#0d0016;">这句话的意思等同于<span style="background-color:#ffd900;">不要用关键字给变量或者常量起名称</span>。</span></p> 
 <pre><code>定义变量的时候：
    我们可以定义
    int a = 10;
    // 此时 a 表示给一段内存起了个名称，方便我们后续进行内存管理
    
    但是我们不可以定义
    int int = 10；
    // 上述代码的意思表示给一段内存起名称为 int，int 是 C++ 中的关键字
    // 这是程序就会报错</code></pre> 
 <p><span style="color:#fe2c24;"><strong>提示</strong></span>：在给变量或者常量起名称的时候，不要用 C++ 的关键字，否则会引起歧义！</p> 
</blockquote> 
<h3 id="1.4%20%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span style="color:#4da8ee;">1.4 标识符命名规则</span></h3> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">C++ 规定给</span><span style="background-color:#fe2c24;">标识符（变量、常量）</span><span style="background-color:#ffd900;">命名时，有自己的一套规则</span>。（<span style="color:#fe2c24;"><strong>标识符</strong></span>其实就是代表<span style="color:#fe2c24;"><strong>常量或者变量</strong></span>）（标识符其实就是我们给一段内存起的名字）</p> 
<ul><li>        标识符不能是关键字。        // 这个在上一节已经提到了，不可以<span style="background-color:#ffd900;"> int int = 10</span>；</li><li>        标识符只能由字母、数字、下划线组成。 // 给一段内存起名时 要注意：不可以掺杂 ￥……%……&amp;￥#￥@ 等符号，有明确的要求</li><li>        第一个字符必须为字母或下划线。    // 给一段内存起的名字开头有要求 必须为 ： Hello_ ； _Hello </li><li>        标识符中字母区分大小写。   // 给一段内存起的名字 中的字母要区分大小写</li></ul> 
<h3 id="1.5%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span style="color:#4da8ee;">1.5 数据类型</span></h3> 
<p>        C++ 规定在创建一个变量或者常量时，必须要<span style="color:#fe2c24;"><strong>指定出相应的数据类型</strong></span>，否则<span style="color:#fe2c24;"><strong>无法给变量分配内存</strong></span>。（数据类型存在的意义就是给变量分配合适的内存空间）</p> 
<h4 id="1.5.1%20%E6%95%B4%E5%9E%8B"><span style="color:#38d8f0;">1.5.1 整型</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">整型变量</span>表示的是<span style="background-color:#ffd900;">整数类型</span>的数据。</p> 
<p>        C++ 中能够表示整型的类型有有以下几种，<span style="color:#0d0016;"><strong>区别在于所占内存空间不同</strong></span>：</p> 
<p>        <span style="color:#0d0016;"><strong>数据类型</strong></span>                       <span style="color:#0d0016;"><strong> 占用空间</strong></span>                                                                                <span style="color:#0d0016;"><strong>取值范围</strong></span></p> 
<p>        short（短整型）                2字节                                                                          （<img alt="-2^{15}" class="mathcode" src="https://images2.imgbox.com/41/ce/Chmkiqam_o.png"> ~ <img alt="2^{15}-1" class="mathcode" src="https://images2.imgbox.com/f8/99/tFSeZCYS_o.png">）</p> 
<p>        int（整型）                        4字节                                                                          （<img alt="-2^{31}" class="mathcode" src="https://images2.imgbox.com/95/42/3Z5RD9Sx_o.png"> ~ <img alt="2^{31}-1" class="mathcode" src="https://images2.imgbox.com/10/f1/xyWjMzJA_o.png">）</p> 
<p>        long（长整型）        Windows为4字节，Linux为4字节(32位OS)，8字节(64位)  （<img alt="-2^{31}" class="mathcode" src="https://images2.imgbox.com/e1/47/lPHG1Yyh_o.png"> ~ <img alt="2^{31}-1" class="mathcode" src="https://images2.imgbox.com/75/57/ZNPGN3Q5_o.png">）</p> 
<p>        long long（长长整型）      8字节                                                                          （<img alt="-2^{63}" class="mathcode" src="https://images2.imgbox.com/ee/47/fQkaFVnh_o.png"> ~ <img alt="2^{63}-1" class="mathcode" src="https://images2.imgbox.com/80/52/vz8po2Kq_o.png">）</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/f5/d7/2vzYmZqF_o.png" width="379"></p> 
<p>        我们知道数据类型本质的区别是：<span style="color:#0d0016;"><strong>占用空间内存的大小不同！！！</strong>现在我们修改存储数据的大小，让其越界。比如说：短整型的范围是 -32768 ~ 32767；</span></p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/8d/09/TFUafFGJ_o.png" width="465"></p> 
<p>        现在可以看出，<span style="color:#0d0016;"><strong>短整型的范围为 -32768 ~ 32767</strong></span>，现在设置短整型的数值为 32768 ，越界之后的短整型数据显示为 -32768，显然与真实表达的数据不同！！！</p> 
<h4 id="1.5.2%20sizeof%20%E5%85%B3%E9%94%AE%E5%AD%97"><span style="color:#38d8f0;">1.5.2 sizeof 关键字</span></h4> 
<p>   <span style="color:#0d0016;"><strong>     作用</strong></span>：利用<span style="background-color:#ffd900;"> sizeof 关键字可以统计数据类型所占内存大小</span>。</p> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：sizeof（数据类型/变量）</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/9d/dc/bujc9jIX_o.png" width="602"></p> 
<h4 id="1.5.3%20%E5%AE%9E%E5%9E%8B%EF%BC%88%E6%B5%AE%E7%82%B9%E5%9E%8B%EF%BC%89"><span style="color:#38d8f0;">1.5.3 实型（浮点型）</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">用于表示小数</span>。</p> 
<p>        浮点型变量分为两种：</p> 
<p><span style="color:#0d0016;"><strong>        1. 单精度 float</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        2. 双精度 double</strong></span></p> 
<p>        两者的<span style="background-color:#ffd900;">区别</span>在于<span style="background-color:#ffd900;">表示的有效数据范围不同</span>。</p> 
<p>        <span style="color:#0d0016;"><strong>数据类型</strong></span>                        <span style="color:#0d0016;"><strong>占用空间 </strong></span>                       <span style="color:#0d0016;"><strong>有效数据范围</strong></span></p> 
<p>        float                                4字节                              7位有效数据</p> 
<p>        double                            8字节                          15 ~ 16位有效数据</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/a7/d4/6tFXKuKx_o.png" width="666"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注：</strong></span>这里解释一下 float num1 = 3.14f，为什么 3.14 后面会加上一个 f；（明确加上这个 f 后缀的意思表示的是 float 类型）</p> 
 <p>        首先如果不加这个 f 后缀，那么系统默认小数是 double 类型，然后 float num1 = 3.14；的意思表示的是将双精度浮点型的 3.14 转换为 float 类型，相比于加上后缀，中间是多一步转换过程的！</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>默认情况下，输出一个小数会显示 6 位有效数字！</strong></span></p> 
 <p><img alt="" height="400" src="https://images2.imgbox.com/68/eb/6SAcgDIq_o.png" width="495"></p> 
 <p>        <span style="color:#0d0016;"><strong>num2 初始值为 3.1415926，但是实际的打印结果为 3.14159；</strong></span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>科学计数法：</strong></span></p> 
 <p><img alt="" height="400" src="https://images2.imgbox.com/ed/54/ZxQvKhX0_o.png" width="663"></p> 
</blockquote> 
<h4 id="1.5.4%20%E5%AD%97%E7%AC%A6%E5%9E%8B"><span style="color:#38d8f0;">1.5.4 字符型</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">字符型变量用于显示单个字符</span></p> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：char ch = ‘a’;</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>注意1：</strong></span>在显示字符型变量时，用单引号将字符括起来，不要用双引号；</p> 
 <p><span style="color:#0d0016;"><strong>注意2：</strong></span>单引号内只能有一个字符，不可以是字符串；</p> 
 <p><span style="color:#0d0016;"><strong>注意3：</strong></span>C 和 C++ 中的字符型变量只占 <span style="background-color:#ffd900;">1 个字节</span>。</p> 
 <p><span style="color:#0d0016;"><strong>注意4：</strong></span><span style="background-color:#ffd900;">字符型变量并不是把字符本身放到内存中存储，而是将对应的 ASCII 编码放入到存储单元</span>。</p> 
</blockquote> 
<p><img alt="" height="400" src="https://images2.imgbox.com/cc/db/xNjFmyy7_o.png" width="858"></p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/1a/a9/DLITrTB4_o.png" width="614"></p> 
<h4 id="1.5.5%20%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span style="color:#38d8f0;">1.5.5 转义字符</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：用于<span style="background-color:#ffd900;">表示一些不能显示出来的 ASCII 字符</span>。</p> 
<p>        现阶段我们常用的 ASCII 字符有 \n  \\   \r；</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>\n：换行（LF），将当前位置移到下一行开头        ASCII 码值 010</strong></span></p> 
 <p><img alt="" height="250" src="https://images2.imgbox.com/8f/42/zfOaXQq4_o.png" width="412"></p> 
 <p>        可以看出，换行符 \n 等价于 换行标志 endl；</p> 
 <p><span style="color:#fe2c24;"><strong>\t：水平制表（HT），（跳到下一个 TAB 位置）        ASCII 码值 009</strong></span></p> 
 <p><img alt="" height="250" src="https://images2.imgbox.com/a2/d0/DOLs0QYA_o.png" width="390"></p> 
 <p>        反斜杠 + t 表示：在 反斜杠 + t 之前的基础上跳到下一个 TAB 位置，现在 Zhang 占用 5 个字符，那么后续会再空出 3 个字符的位置，然后才会打印 Hello World；</p> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/96/ac/xbEU5u66_o.png" width="586"></p> 
 <p><span style="color:#fe2c24;"><strong>\\：代表一个反斜线字符 “\”        ASCII 码值 092</strong></span></p> 
 <p><img alt="" height="250" src="https://images2.imgbox.com/bd/c9/PMVI2q6j_o.png" width="341"></p> 
 <p>        现在我要输出一个 \ ，那么必须要输出两个反斜杠，第一个反斜杠表示告诉编辑我要使用转义字符；</p> 
</blockquote> 
<h4 id="1.5.6%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span style="color:#38d8f0;">1.5.6 字符串类型</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">表示的是一串字符</span>。</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>两种风格：</strong></span></p> 
 <p>        1. C 风格字符串：char 变量名[] = “字符串值”;</p> 
 <p>        <span style="background-color:#ffd900;">C 风格的字符串要用中括号括起来</span>；</p> 
 <p>        2. C++ 风格字符串：string 变量名 = “字符串值”;</p> 
 <p>        <span style="background-color:#ffd900;">C++ 风格的字符串要引用头文件：#include &lt;string&gt;</span><br><img alt="" height="400" src="https://images2.imgbox.com/c6/70/63dXbtUN_o.png" width="494"></p> 
</blockquote> 
<h4 id="1.5.7%20%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span style="color:#38d8f0;">1.5.7 布尔类型</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">布尔数据类型代表真或假的值</span>。</p> 
<p>        bool 类型只有两个值：</p> 
<ul><li>        true --- 真（本质是 1）</li><li>        false --- 假（本质是 0）</li></ul> 
<p>        <span style="background-color:#ffd900;">bool 类型占 1 个字节大小</span>；</p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/ce/69/iDILdipU_o.png" width="529"></p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span>布尔类型创建 true 或者 false 的时候，只用在最开始定义一个 bool 类型即可！</p> 
<h4 id="1.5.8%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5"><span style="color:#38d8f0;">1.5.8 数据的输入</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">用于从键盘获取数据</span></p> 
<p>        <span style="color:#0d0016;"><strong>关键字</strong></span>：cin</p> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：cin&gt;&gt;变量</p> 
<p><img alt="" height="650" src="https://images2.imgbox.com/60/97/N0lLyWHx_o.png" width="420"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注：</strong></span></p> 
 <p>        cout 和 cin 可以记忆为：out 译为输出，in 译为输入，<span style="background-color:#ffd900;">cin 键盘输入，cout 显示器输出</span>；</p> 
</blockquote> 
<h3 id="1.6%20%E8%BF%90%E7%AE%97%E7%AC%A6"><span style="color:#4da8ee;">1.6 运算符</span></h3> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">用于执行代码的运算</span></p> 
<p><span style="color:#0d0016;"><strong>        运算符类型                                作用</strong></span></p> 
<p>        算术运算符                                用于处理四则运算</p> 
<p>        赋值运算符                                用于将表达式的值赋给变量</p> 
<p>        比较运算符                                用于表达式的比较，并返回一个真值或假值</p> 
<p>        逻辑运算符                                用于根据表达式的值返回真值或假值</p> 
<h4 id="1.6.1%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97"><span style="color:#38d8f0;">1.6.1 算术运算符 - 加减乘除运算</span></h4> 
<p>        算术运算符主要包括加减乘除四则运算，但是其中加法包括两种形式，+2、-2 表示数的正负性，2+1 、2-1 表示四则运算。</p> 
<p><img alt="" height="420" src="https://images2.imgbox.com/9b/00/ZpgLG3Mh_o.png" width="1073"></p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/46/72/kmtJUDSW_o.png" width="794"></p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/3c/c5/Uyftnfkm_o.png" width="559"></p> 
<h4 id="1.6.2%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97"><span style="color:#38d8f0;">1.6.2 算术运算符 - 取模运算</span></h4> 
<p><span style="color:#0d0016;"><strong>        运算符                        术语                        示例                        结果</strong></span></p> 
<p>           %                       取模（取余）              10%3                         1 </p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/b7/e2/xpTvDuns_o.png" width="812"></p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/92/3e/ZVcb3zRs_o.png" width="530"></p> 
<h4 id="1.6.3%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F"><span style="color:#38d8f0;">1.6.3 算术运算符 - 递增递减</span></h4> 
<p>        <span style="color:#0d0016;"><strong>        运算符                        术语                        示例                        结果<br>                    ++                        前置递减             a=2，b=++a；           a=3；b=3；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                   ++                        后置递减             a=2；b=a++；           a=3；b=2；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                   --                          前置递减             a=2；b=--a；             a=1；b=1；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                   --                          后置递减             a=2；b=a--；             a=1；b=2；</strong></span></p> 
<p><img alt="" height="230" src="https://images2.imgbox.com/07/0a/h5kCXrJj_o.png" width="457"></p> 
<p>        程序跑到这里，可以看到不管是<span style="color:#1c7331;"><strong>前置++</strong></span>还是<span style="color:#1c7331;"><strong>后置++</strong></span>，都可以实现数值加一，其实质等价于<span style="color:#fe2c24;"><strong> a = a + 1 </strong></span>；那么到底有什么本质区别呢？我们接着往下看：</p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/5c/04/wI7TWpEA_o.png" width="1044"></p> 
<h4 id="1.6.4%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span style="color:#38d8f0;">1.6.4 赋值运算符</span></h4> 
<p>        <span style="color:#0d0016;"><strong>        运算符                        术语                        示例                        结果<br>                     =                             赋值                    a=2，b=3；           a=2；b=3；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                   +=                          加等于                 a=0；a+=2；               a=2；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                   -=                           减等于                 a=5；a-=3；                a=2；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                   *=                           乘等于                 a=2；a*=2；               a=4；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                   /=                           除等于                 a=4；a/=2；               a=2；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                  %=                          模等于                 a=3；a%2；               a=1；       </strong></span></p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/f4/16/7SzOHntg_o.png" width="448"></p> 
<h4 id="1.6.5%20%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span style="color:#38d8f0;">1.6.5 比较运算符</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">用于表达式的比较，并返回一个真值或假值</span></p> 
<p><span style="color:#0d0016;"><strong>        运算符                        术语                        示例                        结果<br>            ==                          相等于                      4==3                          0</strong></span></p> 
<p><span style="color:#0d0016;"><strong>           !=                           不等于                      4!=3                           1</strong></span></p> 
<p><span style="color:#0d0016;"><strong>           &lt;                              小于                        4&lt;3                            0</strong></span></p> 
<p><span style="color:#0d0016;"><strong>           &gt;                              大于                        4&gt;3                            1</strong></span></p> 
<p><span style="color:#0d0016;"><strong>          &lt;=                         小于等于                    4&lt;=3                          0</strong></span></p> 
<p><span style="color:#0d0016;"><strong>          &gt;=                         大于等于                    4&gt;=1                          1</strong></span></p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/2f/2f/Iro3NTrc_o.png" width="865"></p> 
<h4 id="1.6.6%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E9%9D%9E"><span style="color:#38d8f0;">1.6.6 逻辑运算符 - 非</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">用于根据表达式的值返回真值或假值</span><span style="color:#fe2c24;"><strong>（注意：C++ 中定义只要不为 0 都为真，非假即真！）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        运算符                        术语                        示例                        结果<br>             ！                             非                          ！a               如果a为假，则！a为真；如果a为真，则！a为假；</strong></span></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/9d/6a/cg0HMnsp_o.png" width="479"></p> 
<h4 id="1.6.7%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E4%B8%8E"><span style="color:#38d8f0;">1.6.7 逻辑运算符 - 与</span></h4> 
<p><span style="color:#0d0016;"><strong>        运算符                        术语                        示例                        结果<br>           &amp;&amp;                             与                         a&amp;&amp;b             如果a和b都为真，则结果为真，否则为假；</strong></span></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/1c/8d/hhgfi6SO_o.png" width="479"></p> 
<h4 id="1.6.8%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%20-%20%E6%88%96"><span style="color:#38d8f0;">1.6.8 逻辑运算符 - 或</span></h4> 
<p><span style="color:#0d0016;"><strong>        运算符                        术语                        示例                        结果<br>             ||                               或                          a||b              如果a和b有一个为真，则结果为真，二者都为假时，结果为假；</strong></span></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/0a/e8/hGhnkRAe_o.png" width="479"></p> 
<h3 id="1.7%20%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%BB%93%E6%9E%84"><span style="color:#4da8ee;">1.7 程序流程结构</span></h3> 
<p>        C 和 C++ 支持最基本的三种程序运行结构：<span style="background-color:#ffd900;">顺序结构、选择结构、循环结构</span></p> 
<ul><li>        <span style="color:#0d0016;"><strong>顺序结构</strong></span>：程序按顺序执行，不发生跳转</li><li>        <span style="color:#0d0016;"><strong>选择结构</strong></span>：依据条件是否满足，有选择的执行相应功能</li><li>        <span style="color:#0d0016;"><strong>循环结构</strong></span>：依据条件是否满足，循环多次执行某段代码</li></ul> 
<h4 id="1.7.1%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_%E5%8D%95%E8%A1%8Cif%E8%AF%AD%E5%8F%A5"><span style="color:#38d8f0;">1.7.1 选择结构_单行if语句</span></h4> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：if{条件}{条件满足执行的语句}</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/ec/8a/HcAyMxRO_o.png" width="915"></p> 
<h4 id="1.7.2%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_%E5%A4%9A%E8%A1%8Cif%E8%AF%AD%E5%8F%A5"><span style="color:#38d8f0;">1.7.2 选择结构_多行if语句</span></h4> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：if{条件}{条件满足执行的语句}else{条件不满足执行的语句}；</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/e4/de/9WrOjUlN_o.png" width="575"></p> 
<h4 id="1.7.3%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_%E5%A4%9A%E6%9D%A1%E4%BB%B6if%E8%AF%AD%E5%8F%A5"><span style="color:#38d8f0;">1.7.3 选择结构_多条件if语句</span></h4> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：if{条件1}{条件1满足执行的语句}else if{条件2}{条件2满足执行的语句}……else{都不满足执行的语句}</p> 
<p><img alt="" height="700" src="https://images2.imgbox.com/93/a4/HMNNFNYB_o.png" width="491"></p> 
<h4 id="1.7.4%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_%E5%B5%8C%E5%A5%97if%E8%AF%AD%E5%8F%A5"><span style="color:#38d8f0;">1.7.4 选择结构_嵌套if语句</span></h4> 
<p>        <span style="color:#0d0016;"><strong>嵌套 if 语句</strong></span>：在 if 语句中，可以嵌套使用 if 语句，达到更精确的条件判断。</p> 
<p><img alt="" height="630" src="https://images2.imgbox.com/17/9b/HFF7kn0u_o.png" width="535"></p> 
<h4 id="1.7.5%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E4%B8%89%E5%8F%AA%E5%B0%8F%E7%8C%AA%E7%A7%B0%E4%BD%93%E9%87%8D"><span style="color:#38d8f0;">1.7.5 选择结构案例_三只小猪称体重</span></h4> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>练习案例</strong></span>：三只小猪称体重，有三只小猪 ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？</p> 
 <p><img alt="" height="550" src="https://images2.imgbox.com/33/d1/ga6WyRog_o.png" width="688"></p> 
</blockquote> 
<h4 id="1.7.6%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span style="color:#38d8f0;">1.7.6 选择结构案例_三目运算符</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">通过三目运算符实现简单的运算</span></p> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：<span style="background-color:#ffd900;">表达式1？表达式2：表达式3</span></p> 
<ul><li>        如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</li><li>        如果表达式1的值为假，执行表达式3，并返回表达式3的结果；</li></ul> 
<p><img alt="" height="350" src="https://images2.imgbox.com/ae/f5/0nu17SOd_o.png" width="419"></p> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">在 C++ 中三目运行符返回的是变量，可以继续赋值！</span></strong></p> 
 <p><img alt="" height="350" src="https://images2.imgbox.com/7e/03/HZsQTM8K_o.png" width="573"></p> 
</blockquote> 
<h4 id="1.7.7%20%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84_switch%E8%AF%AD%E5%8F%A5"><span style="color:#38d8f0;">1.7.7 选择结构_switch语句</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：执行多条件分支语句</p> 
<pre><code>switch语句语法：
switch（表达式）
{
    case 结果1:
        执行语句;
        break;
    case 结果2:
        执行语句;
        break;
    ……
    
    default:
        执行语句;
        break;
}</code></pre> 
<p><img alt="" height="550" src="https://images2.imgbox.com/a3/6f/zI7PERIV_o.png" width="419"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>if 和 switch 区别？</strong></span></p> 
 <p>        <span style="color:#0d0016;"><strong>switch 缺点</strong></span>：判断时候只能是整型或者字符型，不可以是一个区别；</p> 
 <p>        <span style="color:#0d0016;"><strong>switch 优点</strong></span>：结构清晰，执行效率高！</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注意1</strong></span>：<span style="background-color:#ffd900;">switch语句中表达式类型只能是整型或者字符型</span>；</p> 
 <p><span style="color:#fe2c24;"><strong>注意2</strong></span>：<span style="background-color:#ffd900;">case里如果没有break，那么程序会一直向下执行</span>；</p> 
 <p><span style="color:#fe2c24;"><strong>总结</strong></span>：与 if 语句相比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间。</p> 
</blockquote> 
<h4 id="1.7.8%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84_while%E8%AF%AD%E5%8F%A5"><span style="color:#38d8f0;">1.7.8 循环结构_while语句</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">满足循环条件，执行循环语句</span></p> 
<p>       <span style="color:#0d0016;"><strong> 语法</strong></span>：while(循环条件){循环语句}</p> 
<p>        <span style="color:#0d0016;"><strong>解释</strong></span>：只要循环条件为真，就执行循环语句</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/45/ce/S1etSnum_o.png" width="353"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注意</strong></span>：while 循环中一定要设置跳出循环的条件，否则就会出现死循环的现象！</p> 
</blockquote> 
<h4 id="1.7.9%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E7%8C%9C%E6%95%B0%E5%AD%97"><span style="color:#38d8f0;">1.7.9 循环结构案例_猜数字</span></h4> 
<p>        <span style="color:#fe2c24;"><strong>案例描述</strong></span>：<span style="background-color:#ffd900;">系统随机生成一个 1 到 100 之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或者过小，如果猜对恭喜玩家胜利，并且退出游戏！</span></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/88/d2/NsoYR6j9_o.png" width="382"></p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
using namespace std;


int main()
{
	// 1. 系统生成一个随机数
	int num = rand() % 100 + 1; // rand()%100 表示随机生成一个 0 - 99 的数字，现在要求生成一个 1-100 的数字，所以整体+1即可；
	// 这里注意：用rand生成的随机数每次都是一样的，为了保证每次的随机数都不一样，C++ 提供了另外一个函数
	// srand((unsigned int) time(NULL));
	// 使用此函数需要引用 time 时间头文件！

	// 2. 玩家进行猜测
	int Value = 0;
	int Count = 5;
	cout &lt;&lt; "请玩家输入您的数值：" &lt;&lt;  endl;
	cin &gt;&gt; Value;

	// 3. 判断玩家的猜测是否是这个随机数
	while (Count--)
	{
		if (Value&gt;num)
		{
			cout &lt;&lt; "您输入的数值过大，请重新输入" &lt;&lt; endl;
			cout &lt;&lt; "请玩家输入您的数值：" &lt;&lt; endl;
			cin &gt;&gt; Value;
		}
		else if (Value&lt;num)
		{
			cout &lt;&lt; "您输入的数值过小，请重新输入" &lt;&lt; endl;
			cout &lt;&lt; "请玩家输入您的数值：" &lt;&lt; endl;
			cin &gt;&gt; Value;
		}
		else
		{
			cout &lt;&lt; "恭喜您猜对了！！！" &lt;&lt; endl;
			break; // break 关键字用于跳出循环！
		}
	}
	cout &lt;&lt; "很遗憾未在有限次数内猜对！！！" &lt;&lt; endl;

	// 4. 猜对 推出游戏  猜错，提示玩家数值过大或者过小，重新返回第二步

	system("pause");

	return 0;
}</code></pre> 
<p><img alt="" height="420" src="https://images2.imgbox.com/9b/8a/O7ZQnFZJ_o.png" width="356"></p> 
<h4 id="1.7.10%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84_dowhile%E8%AF%AD%E5%8F%A5"><span style="color:#38d8f0;">1.7.10 循环结构_dowhile语句</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：满足循环条件，执行循环语句</p> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：do{循环语句}while（循环条件）;</p> 
<p><img alt="" height="330" src="https://images2.imgbox.com/33/97/Vj8q6ofh_o.png" width="458"></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>注意</strong></span>：<span style="background-color:#ffd900;">与 while 循环的区别在于 do……while 循环会先执行一次循环语句，再判断循环条件；也就是说哪怕循环条件不是成立的，循环语句也会执行一次</span>；</p> 
 <p><img alt="" height="700" src="https://images2.imgbox.com/bf/ca/CWnRxhYd_o.png" width="845"></p> 
</blockquote> 
<h4 id="1.7.11%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0"><span style="color:#38d8f0;">1.7.11 循环结构案例_水仙花数</span></h4> 
<p>        <span style="color:#0d0016;"><strong>案例描述</strong></span>：水仙花数是指一个 3 位数，它的每个位上的数字的 3 次幂之和等于它本身（用 do……while 循环语句求出 3 位数中的水仙花数）</p> 
<p>        例如：<img alt="1^{3}+5^{3}+3^{3}=153" class="mathcode" src="https://images2.imgbox.com/d4/59/ZFUE4vw5_o.png"></p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/b1/17/tMI5s9t5_o.png" width="881"></p> 
<h4 id="1.7.12%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84_for%E5%BE%AA%E7%8E%AF"><span style="color:#38d8f0;">1.7.12 循环结构_for循环</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：满足循环条件，执行循环语句</p> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：for(起始表达式；条件表达式；末尾循环体){循环语句；}</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/c7/62/oJmZ42p4_o.png" width="487"></p> 
<h4 id="1.7.13%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E6%A1%88%E4%BE%8B_%E6%95%B2%E6%A1%8C%E5%AD%90"><span style="color:#38d8f0;">1.7.13 循环结构案例_敲桌子</span></h4> 
<p>        <span style="color:#0d0016;"><strong>练习案例</strong></span>：从 1 开始数到数字 100，如果数字个位含有 7，或者数字十位含有 7，或者该数字是 7 的倍数，满足以上条件我们打印敲桌子，其余数字直接打印输出。</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/57/e9/JGnvvTHJ_o.png" width="939"></p> 
<h4 id="1.7.14%20%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span style="color:#38d8f0;">1.7.14 嵌套循环</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">在嵌套体中再嵌套一层循环，解决一些实际问题</span></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/f4/6b/Blqx9tQ1_o.png" width="428"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注意：</strong></span></p> 
 <p>        在嵌套循环中需要注意，两个循环设置的变量尽量不要设置为一样的；这样对初学者来说，可能不清楚 i 对应的究竟是哪一个循环，如果了解过的可能清楚，嵌套循环中的变量遵循就近原则，也就是离哪个循环越近，变量就属于哪一个循环。</p> 
 <pre><code>int main()
{
	// 1. 利用嵌套循环打印一个矩阵式的 * 图
    
    //通常认为：外层执行一次，内层执行一周；
    //外层循环
	for (int i = 1; i &lt; 11;i++)
	{
        //内层循环
		for (int i = 1; i &lt; 11; i++)
		{
			cout &lt;&lt;"* ";
		}
		/*cout &lt;&lt; endl;*/
		cout &lt;&lt; "\n";
	}

	system("pause");

	return 0;
}</code></pre> 
</blockquote> 
<h4 id="1.7.15%20%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E6%A1%88%E4%BE%8B_%E4%B9%98%E6%B3%95%E5%8F%A3%E8%AF%80%E8%A1%A8"><span style="color:#38d8f0;">1.7.15 嵌套循环案例_乘法口诀表</span></h4> 
<p>        <span style="color:#0d0016;"><strong>案例描述</strong></span>：利用嵌套循环，实现九九乘法表！</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/e0/7b/vjJNa2Pe_o.png" width="455"></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/53/fe/zl6FClHY_o.png" width="618"></p> 
<p><img alt="" height="700" src="https://images2.imgbox.com/a0/8d/1FbhMXEw_o.png" width="821"></p> 
<h4 id="1.7.16%20%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5_break%E8%AF%AD%E5%8F%A5"><span style="color:#38d8f0;">1.7.16 跳转语句_break语句</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：用于跳出<span style="background-color:#ffd900;">选择结构</span>或者<span style="background-color:#ffd900;">循环结构</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>break 使用的动机</strong></span>：</p> 
 <ul><li>        出现在 switch 条件语句中，作用是终止 case 并跳出 switch；</li><li>        出现在循环语句中，作用是跳出当前的循环语句；</li><li>        出现在嵌套循环中，跳出最近的内层循环语句；</li></ul> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>break 在 switch 语句中的作用：</strong></span></p> 
 <p><img alt="" height="500" src="https://images2.imgbox.com/05/a4/3fhi6L0t_o.png" width="812"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>break 在循环结构中的作用：</strong></span></p> 
 <p><img alt="" height="500" src="https://images2.imgbox.com/e9/fe/q1G8knJc_o.png" width="854"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>break 在嵌套语句中的作用：</strong></span></p> 
 <p><img alt="" height="550" src="https://images2.imgbox.com/f2/13/hjtI7Jq8_o.png" width="629"></p> 
</blockquote> 
<h4 id="1.7.17%20%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5_continue"><span style="color:#38d8f0;">1.7.17 跳转语句_continue</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：在<span style="background-color:#ffd900;">循环语句</span>中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/92/b2/G5gY4J5J_o.png" width="684"></p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/df/54/zwL6pWU4_o.png" width="503"></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/49/3f/mO62oepp_o.png" width="758"></p> 
<h4 id="1.7.18%20%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5_goto"><span style="color:#38d8f0;">1.7.18 跳转语句_goto</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：可以无条件跳转语句</p> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：goto 标记；</p> 
<p>        <span style="color:#0d0016;"><strong>解释</strong></span>：<span style="background-color:#ffd900;">如果标记的名称存在，执行到 goto 语句时，会跳转到标记的位置</span></p> 
<pre><code>1. *****

2. *****
    goto FLAG；    
3. *****

4. *****
FLAG:
5. *****

(goto关键字的作用就是：
    正常来说，如果没有goto关键字，那么程序是按照顺序来执行的，1 2 3 4 5；
    但是如果加上关键字goto，那么就会出现程序跳转的情况；
    也就是说现在程序的执行过程是 1 2 5 
    
    执行完第二条语句以后，出现关键字goto FLAG；（goto 关键字后通常接全大写的；）
    FALG加冒号表示跳转到的位置；)</code></pre> 
<p><img alt="" height="400" src="https://images2.imgbox.com/e5/25/tOUrlvSl_o.png" width="404"></p> 
<h3 id="1.8%20%E6%95%B0%E7%BB%84"><span style="color:#4da8ee;">1.8 数组</span></h3> 
<p>        所谓<span style="color:#fe2c24;"><strong>数组</strong></span>，就是一个<span style="color:#fe2c24;"><strong>集合</strong></span>，<span style="background-color:#ffd900;">里面存放了相同类型的数据元素</span>；</p> 
<ul><li>        特点1：数组中<span style="background-color:#ffd900;">每个数据元素都是相同的数据类型</span></li><li>        特点2：数组是由<span style="background-color:#ffd900;">连续的内存</span>位置组成的</li></ul> 
<h4 id="1.8.1%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span style="color:#38d8f0;">1.8.1 一维数组定义方式</span></h4> 
<p>        <span style="color:#fe2c24;"><strong>一维数组定义的三种方式：</strong></span></p> 
<ul><li>        1. 数据类型   数组名[ 数组长度 ]；</li><li>        2. 数据类型   数组名[ 数组长度 ] = { 值1，值2 ……}；</li><li>        3. 数据类型   数组名[  ] = { 值1，值2 ……}；</li></ul> 
<p><img alt="" height="300" src="https://images2.imgbox.com/68/ac/h1H5pQZn_o.png" width="453"></p> 
<p><img alt="" height="140" src="https://images2.imgbox.com/17/cf/O3qygHeh_o.png" width="582"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注</strong></span>：对于 <span style="background-color:#ffd900;">数据类型   数组名[ 数组长度 ] = { 值1，值2 ……}</span>；如果<span style="color:#fe2c24;"><strong>在初始化数据的时候，没有全部填写完，会用 0 来填补空缺</strong></span>！</p> 
 <p><img alt="" height="160" src="https://images2.imgbox.com/8c/62/CTvGoLrj_o.png" width="639"></p> 
</blockquote> 
<p><img alt="" height="150" src="https://images2.imgbox.com/6e/1a/FEprvGlE_o.png" width="466"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>1. 数组元素的下标是从 0 开始索引的！！！</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>2. 定义数组的时候，必须有初始长度；如果没有初始长度，那么必须给数组元素进行初始化，通过元素初始化的方式告诉数组初始长度；</strong></span></p> 
</blockquote> 
<h4 id="1.8.2%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%20-%20%E6%95%B0%E7%BB%84%E5%90%8D"><span style="color:#38d8f0;">1.8.2 一维数组 - 数组名</span></h4> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>一维数组名称的用途</strong></span><span style="color:#fe2c24;"><strong>（这很重要，认真分析）</strong></span><span style="color:#0d0016;"><strong>：</strong></span></p> 
 <ul><li>        1. 可以统计整个数组在内存中的长度</li><li>        2. 可以获取数组在内存中的首地址</li></ul> 
 <p><img alt="" height="600" src="https://images2.imgbox.com/dd/4a/y90Ax9gx_o.png" width="732"></p> 
</blockquote> 
<p><img alt="" height="250" src="https://images2.imgbox.com/97/cd/PUZ6Tfx7_o.png" width="582"></p> 
<blockquote> 
 <p>        这里可以很明显的发现：我们定义的数组类型是 int 类型，int 类型在内存中占用 4 个字节，这也说明了为什么整个数组在内存中占用 40 个字节；arr[0] 表示数组首元素所占的内存大小，单个元素也就是 int 类型，所占的内存大小为 4；让整个数组所占的内存大小除以单个元素所占的内存大小，得到了数组的长度：也就是 10；</p> 
</blockquote> 
<p><img alt="" height="250" src="https://images2.imgbox.com/02/68/Tuj74L7Z_o.png" width="490"></p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/5f/1c/qsLrSYxt_o.png" width="645"></p> 
<blockquote> 
 <p>        通过上述程序可以发现：数组名 arr 和 &amp;arr[0] 得到的地址是相同的，这再一次印证了数组名代表首元素的地址；</p> 
</blockquote> 
<p><img alt="" height="450" src="https://images2.imgbox.com/d0/1f/oe8khBdv_o.png" width="844"></p> 
<blockquote> 
 <p>        通过这里可以看出：数组的首元素和第二个元素之间差了 4 个字节，20231108~20231112；第二个元素和第三个元素；第三个元素和第四个元素都是如此；而 int 类型在内存中所占正好是 4 个字节；这也证明了数组中的元素在内存中是连续存放的！！！</p> 
</blockquote> 
<h4 id="1.8.3%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B%20-%20%E4%BA%94%E5%8F%AA%E5%B0%8F%E7%8C%AA%E7%A7%B0%E4%BD%93%E9%87%8D"><span style="color:#38d8f0;">1.8.3 一维数组案例 - 五只小猪称体重</span></h4> 
<p>        <span style="color:#0d0016;"><strong>案例描述</strong></span>：在一个数组中记录了五只小猪的体重，如 int arr[5] = {300，350，200，400，250}；找出并打印最重的小猪体重！！！</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/9f/0e/QEyKbHKy_o.png" width="885"></p> 
<h4 id="1.8.4%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B%20-%20%E5%85%83%E7%B4%A0%E9%80%86%E7%BD%AE"><span style="color:#38d8f0;">1.8.4 一维数组案例 - 元素逆置</span></h4> 
<p>        <span style="color:#0d0016;"><strong>案例描述</strong></span>：声明一个 5 个元素的数组，并且将数组元素逆置（原数组元素为：1,3,2,5,4，逆置后的数组为：4,5,2,3,1）</p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
using namespace std;


int main()
{
	// 1. 声明一个 5 个元素的数组，并且将数组元素逆置（例如 原数组元素为：1,3,2,5,4，逆置后的数组为：4,5,2,3,1）
	// 首先逆置存在两种情况：判断数组元素是奇数还是偶数；
	int arr[6] = { 300, 350, 200, 400, 250, 600 }; 
	int num = sizeof(arr) / sizeof(arr[0]);
	if (num%2==0) //偶数
	{
		int Select = 0;
		for (int i = 0; i &lt; num; i++)
		{
			if (i == num / 2)
			{
				break;
			}
			int start = arr[i];
			int end = arr[num - i - 1];
			Select = arr[i];
			arr[i] = arr[num - i - 1];
			arr[num - i - 1] = Select;
		}
	}
	else //奇数
	{
		int Select = 0;
		for (int i = 0; i &lt; num; i++)
		{
			if (i == num / 2)
			{
				break;
			}
			int start = arr[i];
			int end = arr[num - i - 1];
			Select = arr[i];
			arr[i] = arr[num - i - 1];
			arr[num - i - 1] = Select;
		}
	}
	for (int i = 0; i &lt; num;i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; endl;
	}

	system("pause");

	return 0;
}</code></pre> 
<p><img alt="" height="330" src="https://images2.imgbox.com/35/02/HoFnk3Nz_o.png" width="834"></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>上述算法略显繁琐，下面算法提供一种新的思路：</strong></span></p> 
 <pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
using namespace std;


int main()
{
	// 1. 声明一个 5 个元素的数组，并且将数组元素逆置（例如 原数组元素为：1,3,2,5,4，逆置后的数组为：4,5,2,3,1）
	int arr[6] = { 300, 350, 200, 400, 250, 600 }; 
	int num = sizeof(arr) / sizeof(arr[0]);
	// 打印原数组
	cout &lt;&lt; "元素逆置前：" &lt;&lt; endl;
	for (int i = 0; i &lt; num;i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; endl;
	}
	// 算法思路：首先定义数组的起始坐标和终止坐标
	int start = 0;  //数组起始坐标为 0
	int end = num - 1; //数组终止坐标为数组元素个数-1

	while (start&lt;end) // 一定要保证数组的起始坐标小于终止坐标
	// 否则互换两次相当于返回原数组
	{
		// 互换起始坐标和终止坐标，需要借助一个中间变量
		// 将起始坐标赋值给中间变量，让终止坐标覆盖起始坐标，再让中间变量覆盖终止坐标；
		int Temp = arr[start];
		arr[start] = arr[end];
		arr[end] = Temp;

		// 互换的过程中需要起始坐标不断向后移动，终止坐标不断向前移动；
		start++;
		end--;
	}
	// 打印逆置后的数组
	cout &lt;&lt; "元素逆置后：" &lt;&lt; endl;
	for (int i = 0; i &lt; num; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; endl;
	}
	system("pause");

	return 0;
}</code></pre> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/ee/5a/oaKiJIG3_o.png" width="304"></p> 
</blockquote> 
<h4 id="1.8.5%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%20-%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span style="color:#38d8f0;">1.8.5 一维数组 - 冒泡排序</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：最常用的排序算法，对数组内元素进行排序</p> 
<p><span style="color:#0d0016;"><strong>算法思想</strong></span>：</p> 
<ul><li>        1. 比较相邻的元素，如果第一个比第二个大，就交换它们两个。</li><li>        2. 对每一对相邻的元素做同样的工作，执行完毕后，找到第一个最大值。</li><li>        3. 重复以上的步骤，每次比较次数 -1，直到不需要比较。</li></ul> 
<p><img alt="" height="600" src="https://images2.imgbox.com/e1/e0/Cn4FDu0T_o.png" width="941"></p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
using namespace std;


int main()
{
	// 1. 将数组 {4,2,8,0,5,7,1,3,9,6} 进行升序排序;
	int arr[] = { 4, 2, 8, 0, 5, 7, 1, 3, 9, 6 };
	int num = sizeof(arr) / sizeof(arr[0]);
	// 排序前的数组
	cout &lt;&lt; "排序前的数组：" &lt;&lt; endl;
	for (int i = 0; i &lt; num; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; " ";
	}
	// 本次采用冒泡排序的思想
	for (int i = 0; i &lt; num;i++) // 外循环记录排序的轮数，也就是说第一轮排序会排出一个最大值；(每一轮排序都会得到一个最大值)
											  // 那么需要 数组元素-1 轮才能排完
										      // 第一轮得到一个最大值，那么下一轮排序时就会少一个数； 
											  // 10 个数：  8 7 6 5 4 3 2 1 0 轮
	{
		for (int j = 0; j &lt; num-i-1; j++) // 第一轮得到一个最大值，那么下一轮排序时就会少一个数；
														 // 也就是说每一次对比的数都会少一次
													     // 第一次 10 个数对比 9 次；9个数8次；8个数7次；7个数6次；2个数一次； 9 8 7 6 5 4 3 2 1
	// 也就是说外循环第0轮排序时，内循环循环9次；第1轮排序时，内循环循环8次；…… 第8轮循环时，内循环循环一次；
	// 外循环 8 7 6 5 4 3 2 1 0，外循环从 0 到 8，9次；对应于  sizeof(arr) / sizeof(arr[0])-1；跳出外循环；i&lt;num 等价于 sizeof(arr) / sizeof(arr[0])-1；
	// 内循环 1 2 3 4 5 6 7 8 9，外循环0对应内循环9，外循环1对应内循环8；sizeof(arr) / sizeof(arr[0])-i-1；
		{
			if (arr[j]&gt;arr[j + 1])
			{
				int Temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = Temp;
			}
		}
	}
	cout &lt;&lt; endl;
	// 排序后的数组
	cout &lt;&lt; "排序后的数组：" &lt;&lt; endl;
	for (int i = 0; i &lt; num; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	system("pause");

	return 0;
}</code></pre> 
<p><img alt="" height="200" src="https://images2.imgbox.com/96/9c/HHzS9or2_o.png" width="493"></p> 
<h4 id="1.8.6%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span style="color:#38d8f0;">1.8.6 二维数组定义方式</span></h4> 
<p>        二维数组就是在一维数组的基础上，多加了一个维度；</p> 
<p><span style="color:#0d0016;"><strong>二维数组定义的四种方式：</strong></span></p> 
<ul><li>        1. 数据类型   数组名[ 行数 ] [ 列数 ]；</li><li>        2. 数据类型   数组名[ 行数 ] [ 列数 ] = { { 数据1，数据2 }，{ 数据3，数据4 } }；</li><li>        3. 数据类型   数组名[ 行数 ] [ 列数 ] = {  数据1，数据2 ，数据3，数据4  }；</li><li>        4. 数据类型   数组名[  ] [ 列数 ] = {  数据1，数据2 ，数据3，数据4  }；</li></ul> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>1. 数据类型   数组名[ 行数 ] [ 列数 ]；</strong></span></p> 
 <p><img alt="" height="107" src="https://images2.imgbox.com/a3/06/FHe52gBS_o.png" width="489"></p> 
 <p> <img alt="" height="400" src="https://images2.imgbox.com/fb/56/zOdYKDhD_o.png" width="574"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong> 2. 数据类型   数组名[ 行数 ] [ 列数 ] = { { 数据1，数据2 }，{ 数据3，数据4 } }；</strong></span></p> 
 <p><img alt="" height="350" src="https://images2.imgbox.com/c9/61/G8Ai1vjR_o.png" width="620"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>3. 数据类型   数组名[ 行数 ] [ 列数 ] = {  数据1，数据2 ，数据3，数据4  }；</strong></span></p> 
 <p><img alt="" height="280" src="https://images2.imgbox.com/d6/59/NUiCnJxW_o.png" width="786"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong> 4. 数据类型   数组名[  ] [ 列数 ] = {  数据1，数据2 ，数据3，数据4  }；</strong></span></p> 
 <p><img alt="" height="250" src="https://images2.imgbox.com/ce/bd/Hw9xNMGx_o.png" width="588"></p> 
 <p><span style="color:#fe2c24;"><strong>注：</strong></span></p> 
 <p>        二维数组的行可以省略，但是列一定不能省略！！！因为程序需要根据列数去计算对应的行数；所以列万万不能省略！！！</p> 
 <p>        另外二维数组如果初始化的数组元素个数不足以平均分配，那么空缺的部分会用 0 来替补上！！！</p> 
</blockquote> 
<h4 id="1.8.7%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%20-%20%E6%95%B0%E7%BB%84%E5%90%8D"><span style="color:#38d8f0;">1.8.7 二维数组 - 数组名</span></h4> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>二维数组数组名的作用：</strong></span></p> 
 <p>        1. 查看二维数组所占内存空间的大小；</p> 
 <p>        2. 获取二维数组首地址；</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>1. 查看二维数组所占内存空间的大小；</strong></span></p> 
 <p><img alt="" height="500" src="https://images2.imgbox.com/30/69/viUnITFd_o.png" width="663"></p> 
 <p>        <span style="color:#0d0016;"><strong>至于结果是如何获得的</strong></span>：大家应该很清晰了，int 类型的数组，每个元素所占内存空间的大小为 4字节；那个 6 个元素所占内存空间大小为 24字节；第一行 3 个元素占用 12 个字节；</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>2. 获取二维数组首地址；</strong></span></p> 
 <p><img alt="" height="500" src="https://images2.imgbox.com/98/6e/uwOssG4j_o.png" width="818"></p> 
 <p>        通过上述程序可以发现：和一维数组一样，每个元素之间相差的都是 4 个字节，int 类型的字节大小！！！</p> 
</blockquote> 
<h4 id="1.8.8%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B%20-%20%E8%80%83%E8%AF%95%E6%88%90%E7%BB%A9%E7%BB%9F%E8%AE%A1"><span style="color:#38d8f0;">1.8.8 二维数组案例 - 考试成绩统计</span></h4> 
<p><span style="color:#0d0016;"><strong>考试成绩统计：</strong></span></p> 
<p>        案例描述：有三名同学（张三、李四、王五），在一次考试中的成绩分别如下表，请分别输出三名同学的<span style="color:#0d0016;"><strong>总成绩</strong></span>：</p> 
<p><img alt="" height="120" src="https://images2.imgbox.com/21/a5/MhTCoOZi_o.png" width="357"></p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/8a/27/WFKzgRxS_o.png" width="676"></p> 
<h3 id="1.9%20%E5%87%BD%E6%95%B0"><span style="color:#4da8ee;">1.9 函数</span></h3> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：<span style="background-color:#ffd900;">将一段经常使用的代码封装起来，减少代码的重复性！</span></p> 
<p>        一个较大的程序，一般分为若干程序块，每个模块实现特定的功能！</p> 
<h4 id="1.9.1%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span style="color:#38d8f0;">1.9.1 函数的定义</span></h4> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>函数的定义一般主要有 5 个步骤：</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>        1. 返回值类型        （看一下函数最后需要返回一个什么样的数据类型）</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>        2. 函数名        （给函数起个名字，方便我们后续调用）</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>        3. 参数表列        （看一看需不需要给函数输入参数，需要输入什么样的参数）</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>        4. 函数体语句        （函数真正要实现功能的程序）</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>        5. return 表达式        （写这个函数的时候，我们需不需要通过这个函数反馈给我们什么）</strong></span></p> 
 <pre><code>返回值类型  函数名(参数列表)
{
    函数体语句
    
    return 表达式
}</code></pre> 
</blockquote> 
<p><img alt="" height="350" src="https://images2.imgbox.com/c6/f2/LuynNRyX_o.png" width="586"></p> 
<h4 id="1.9.2%20%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span style="color:#38d8f0;">1.9.2 函数的调用</span></h4> 
<p>        <span style="color:#0d0016;"><strong>功能</strong></span>：<span style="background-color:#ffd900;">我们定义好的函数，如何去使用我们定义好的函数</span>；</p> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：函数名(参数)</p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
using namespace std;

// 定义加法函数
// 函数定义的时候，x 和 y 并没有真是数据；
// 它只是一个形式上的参数，简称形参
int Add(int x,int y)
{
	int sum = 0;
	sum = x + y;
	return sum;
}

int main()
{
	// 实现一个加法函数，功能是：传入两个整型数据，计算数据相加的结果，并且返回！！！

	// 33 66 称为实际参数，简称实参；
	// 当调用函数的时候，实际参数会传给形式参数；
	int num = Add(33, 66);
	cout &lt;&lt; "num=" &lt;&lt; num &lt;&lt; endl;

	system("pause");

	return 0;
}</code></pre> 
<h4 id="1.9.3%20%E5%80%BC%E4%BC%A0%E9%80%92"><span style="color:#38d8f0;">1.9.3 值传递</span></h4> 
<p>        所谓<span style="color:#0d0016;"><strong>值传递</strong></span>，就是函数调用时<span style="background-color:#ffd900;">实参将<strong><span style="color:#1c7331;">数值</span></strong>传入给形参</span></p> 
<p>        <span style="color:#0d0016;"><strong>值传递</strong></span>时，<span style="background-color:#ffd900;">如果形参发生改变，并不会影响到实参</span></p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/1d/61/ULZc5WJI_o.png" width="686"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>结论</strong></span>：<span style="color:#1c7331;"><strong>值传递时，形参的改变并不会影响到实参！！！</strong></span></p> 
 <p><img alt="" height="500" src="https://images2.imgbox.com/89/64/ATHVloKc_o.png" width="540"></p> 
 <p><span style="color:#956fe7;"><strong>        （这一句结论体现在结果中，首先实参 a b 是 10 和 20，最后打印的结果还是 10 和 20；在函数中形参发生互换！！！但是实参还是没有发生变化）</strong></span></p> 
 <p><img alt="" height="500" src="https://images2.imgbox.com/ad/99/lPriBj0v_o.png" width="850"></p> 
</blockquote> 
<h4 id="1.9.4%20%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A0%B7%E5%BC%8F"><span style="color:#38d8f0;">1.9.4 常见的样式</span></h4> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>常见函数的样式有 4 种：</strong></span></p> 
 <ul><li>        1. 无参数无返回值</li><li>        2. 有参数无返回值</li><li>        3. 无参数有返回值</li><li>        4. 有参数有返回值</li></ul> 
</blockquote> 
<pre><code>// 函数常见样式
// 1. 无参数无返回值
void test01()
{
	cout &lt;&lt; "This is test01" &lt;&lt; endl;
}
// 2. 有参数无返回值
void test02(int a)
{
	cout &lt;&lt; "This is test02 a=" &lt;&lt;a&lt;&lt; endl;
}
// 3. 无参数有返回值
int test03()
{
	int b = 666;
	cout &lt;&lt; "This is test03 b=" &lt;&lt; b &lt;&lt; endl;
	return b;
}
// 4. 有参数有返回值
int test04(int x)
{
	cout &lt;&lt; "This is test04 =" &lt;&lt; x &lt;&lt; endl;
	return x;
}

int main()
{
	test01();
	test02(66);
	test03();
	test04(666);

	system("pause");

	return 0;
}</code></pre> 
<h4 id="1.9.5%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span style="color:#38d8f0;">1.9.5 函数的声明</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p> 
<p>        函数的<span style="color:#0d0016;"><strong>声明可以多次</strong></span>，但是函数的<span style="color:#0d0016;"><strong>定义只能有一次</strong></span>；</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/88/56/7cUpM09M_o.png" width="669"></p> 
<blockquote> 
 <p>所谓<span style="color:#fe2c24;"><strong>函数的声明</strong></span>就是：</p> 
 <p>        程序运行时按照顺序上 CPU 运行的，如果上述程序把 Compare 函数放在 main 函数之后，那么程序就会报错！显示 Compare 函数未被定义！！！</p> 
 <p>        要解决这一问题，只需要在主函数 main 之上进行对应<span style="color:#fe2c24;"><strong>函数的声明</strong></span>即可！！！</p> 
 <p><img alt="" height="400" src="https://images2.imgbox.com/fc/15/mGzHhr5i_o.png" width="510"></p> 
</blockquote> 
<h4 id="1.9.6%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span style="color:#38d8f0;">1.9.6 函数的分文件编写</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：让代码结构更加清晰</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>函数分文件编写一般有 4 个步骤：</strong></span></p> 
 <p>        1. 创建后缀名为 .h 的头文件</p> 
 <p>        2. 创建后缀名为 .cpp 的源文件</p> 
 <p>        3. 在头文件中写函数的声明</p> 
 <p>        4. 在源文件中写函数的定义</p> 
</blockquote> 
<h3 id="1.10%20%E6%8C%87%E9%92%88"><span style="color:#4da8ee;">1.10 指针</span></h3> 
<p>        <span style="color:#0d0016;"><strong>指针的作用</strong></span>：<span style="background-color:#ffd900;">可以通过指针间接访问内存</span></p> 
<ul><li>        内存编号是从 0 开始记录的，一般用十六进制数字表示</li><li>        可以利用指针变量保存地址</li></ul> 
<h4 id="1.10.1%20%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span style="color:#38d8f0;">1.10.1 指针的定义和使用</span></h4> 
<p>        <span style="color:#0d0016;"><strong>指针变量定义语法</strong></span>：数据类型 * 变量名；</p> 
<p><img alt="" height="220" src="https://images2.imgbox.com/8d/53/BH6FUmw6_o.png" width="530"></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/d0/0b/9uFjohRg_o.png" width="455"></p> 
<blockquote> 
 <p>        <span style="color:#0d0016;"><strong>通过上述代码可以看出</strong></span>：指针 p 其实就是地址；</p> 
 <p>        通过上述代码结合上图我们再来深刻的认识什么是指针？？？首先定义变量 a，int a = 10；相当于在内存空间中开辟一个 4 字节大小内存空间，将这段内存空间起名为 a；</p> 
 <p>        定义指针 p；&amp;a 表示拿到变量 a 代表的内存，因为上图我们说到，内存空间是有自己的地址的：0x0000；&amp;a 也就相当于拿到地址 0x0000；指针 p 指向这段地址；</p> 
 <p>        所以也可以说<span style="color:#0d0016;"><strong>指针其实也就是地址</strong></span>！！！</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>如何使用指针呢 ？</strong></span></p> 
 <p>        可以通过解引用的方式来找到指针指向的内存！！！</p> 
 <p>        <span style="background-color:#ffd900;">指针前加上 * 号</span>就表示解引用！！！</p> 
 <p><img alt="" height="400" src="https://images2.imgbox.com/8a/7a/xM9gTOoR_o.png" width="595"></p> 
</blockquote> 
<h4 id="1.10.2%20%E6%8C%87%E9%92%88%E6%89%80%E5%8D%A0%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span style="color:#38d8f0;">1.10.2 指针所占内存空间</span></h4> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">这一节主要是解决一个问题 ？</span></strong></p> 
 <p>        指针也是一个数据类型，那么这种数据类型占用多少的内存空间呢？</p> 
</blockquote> 
<pre><code>int *p;
// 我们知道指针指向的内存空间存储的是地址；
// 假设指针 p 指向的内存空间存储的地址是 0x0000；

// 在 C++ 中规定：
//    32位操作系统下，不管什么类型的指针，统一占用 4 个字节大小！！！ 
//    64位操作系统下，占用 8 个字节大小！！！</code></pre> 
<p><img alt="" height="280" src="https://images2.imgbox.com/2d/c5/oDc83BHW_o.png" width="534"></p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/0e/d7/Uw6R5eG8_o.png" width="540"></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/27/10/nuyp4BsG_o.png" width="544"></p> 
<h4 id="1.10.3%20%E7%A9%BA%E6%8C%87%E9%92%88"><span style="color:#38d8f0;">1.10.3 空指针</span></h4> 
<p>        <span style="color:#0d0016;"><strong>空指针</strong></span>：指针变量指向内存中编号为 0 的空间（就是说内存是从编号 0 开始依次向后进行编号的，当有指针指向起始编号为 0 的地址时，我们称它为空指针！）</p> 
<p>        <span style="color:#0d0016;"><strong>用途</strong></span>：初始化指针变量（简单来说就是一开始你不知道指针应该指向哪里，就先让它指向 NULL，但是一旦到后期有地方可指以后，就让这个指针指向另外的地址！）</p> 
<p>        <span style="color:#0d0016;"><strong>注意</strong></span>：<span style="background-color:#ffd900;">空指针指向的内存是不可以访问的</span></p> 
<pre><code>int main()
{
	// 空指针
	// 1. 空指针用于给指针变量进行初始化
	int* p = NULL;
	// int* p;  // 如果我们这样定义一个指针，那么这个指针指向哪里是没有被明确定义的；

	// 2. 空指针是不可以进行访问的
	*p = 100; // 指针 p 指向的是地址为 0 的空间，这段地址是不可以被赋值的！
	// 事实上，0 ~ 255之间的内存编号是系统占用的，因此不可以进行访问！
	
	system("pause");

	return 0;
}</code></pre> 
<h4 id="1.10.4%20%E9%87%8E%E6%8C%87%E9%92%88"><span style="color:#38d8f0;">1.10.4 野指针</span></h4> 
<p>       <span style="color:#0d0016;"><strong> 野指针</strong></span>：<span style="background-color:#ffd900;">指针变量指向非法的内存空间</span></p> 
<pre><code>int main()
{
	// 野指针
	int* p = (int*)0x1100; // 这句代码的意思就是：定义一个 int* 类型的指针；
									   // 让这个指针指向地址 0x1100 对应的地址，但是 0x1100 只是一个十六进制的数
									   // 现在强制类型转换，把它转换成一个 int* 类型的指针，指针也就代表地址；
	// 但是我们再想：0x1100 这个地址并不是我们开辟的，也不是我们申请的，那我们没有权利去调用这段内存上对应的数据
	// 因此此时的指针 p 就称为野指针！！！
	cout &lt;&lt; *p &lt;&lt;endl;
	
	system("pause");

	return 0;
}
// 运行这段代码可以发现：系统崩溃！！！
// 在我们的程序中一定要避免出现野指针！！！</code></pre> 
<h4 id="1.10.5%20const%20%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88"><span style="color:#38d8f0;">1.10.5 const 修饰指针</span></h4> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>const 修饰指针有三种情况：</strong></span></p> 
 <p>        1. const 修饰指针 --- 常量指针</p> 
 <p>        2. const 修饰变量 --- 指针常量</p> 
 <p>        3. const 既修饰指针，又修饰常量</p> 
</blockquote> 
<p><img alt="" height="500" src="https://images2.imgbox.com/f2/c0/6rgDPkL6_o.png" width="1200"></p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/53/45/DN9Ge54z_o.png" width="536"></p> 
<h4 id="1.10.6%20%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span style="color:#38d8f0;">1.10.6 指针和数组</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：利用指针访问数组中的元素</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/d7/77/XIY5ONFb_o.png" width="486"></p> 
<p><span style="color:#fe2c24;"><strong>注：</strong></span>整型指针 ++ ，相当于在内存中向后偏移了 4 个字节；</p> 
<h4 id="1.10.7%20%E6%8C%87%E9%92%88%E5%92%8C%E5%87%BD%E6%95%B0"><span style="color:#38d8f0;">1.10.7 指针和函数</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：利用指针作函数的参数，可以修改实参的值</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/fd/f4/Ac1wo6P9_o.png" width="1131"></p> 
<h4 id="1.10.8%20%E6%8C%87%E9%92%88%E9%85%8D%E5%90%88%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0%E6%A1%88%E4%BE%8B"><span style="color:#38d8f0;">1.10.8 指针配合数组和函数案例</span></h4> 
<p>        <span style="color:#0d0016;"><strong>案例描述</strong></span>：封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p> 
<pre><code>void Bubble_Sort(int* p,int sz)
{
	for (int i = 0; i &lt; sz;i++)
	{
		for (int j = 0; j &lt; sz - i - 1; j++)
		{
			if (p[j]&gt;p[j+1])
			{
				int Temp = p[j];
				p[j] = p[j + 1];
				p[j + 1] = Temp;
			}
		}
	}
}

int main()
{
	// 封装一个函数，利用冒泡排序，实现对整型数组的升序排序
	int arr[] = { 6, 5, 3, 2, 9, 4, 7, 1, 8, 0, 10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	cout &lt;&lt; "排序前数组为：" &lt;&lt; endl;
	for (int i = 0; i &lt; sz; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	Bubble_Sort(arr,sz);
	cout &lt;&lt; "排序后数组为：" &lt;&lt; endl;
	for (int i = 0; i &lt; sz; i++)
	{
		cout &lt;&lt; arr[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	
	system("pause");

	return 0;
}</code></pre> 
<p><img alt="" height="400" src="https://images2.imgbox.com/c0/91/4qjT72e5_o.png" width="339"></p> 
<h3 id="1.11%20%E7%BB%93%E6%9E%84%E4%BD%93"><span style="color:#4da8ee;">1.11 结构体</span></h3> 
<p>        结构体属于<span style="background-color:#ffd900;">用户自定义的数据类型</span>，允许用户存储不同的数据类型（目前我们学习过的数据类型有：整型、浮点型、布尔型、字符型、字符串型等，这些都是系统给我们定义好的类型）</p> 
<h4 id="1.11.1%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span style="color:#38d8f0;">1.11.1 结构体的定义和使用</span></h4> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：<span style="background-color:#ffd900;">struct 结构体名{ 结构体成员变量 }；</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>通过结构体创建变量的方式有三种：</strong></span></p> 
 <ul><li>        struct  结构体名 变量名</li><li>        struct  结构体名 变量名 = { 成员1值，成员2值……}</li><li>        定义结构体时顺便创建变量</li></ul> 
</blockquote> 
<pre><code>// 创建结构体
// struct 结构体名称
struct Student 
{
	string name;
	int age;
	int score;
};

struct Stu
{
	string name;
	int age;
	int score;
}s3;  // 创建结构体时直接设置结构体变量

int main()
{
	// 结构体创建变量的方式有三种：
	// 1. struct  结构体名 变量名
	struct Student s1; // 创建结构体和创建一个变量是类似的，数据类型 + 变量名；其中 struct Student 就是数据类型，s1 是变量名
	s1.name = "张三";
	s1.age = 20;
	s1.score = 99;

	cout &lt;&lt; "姓名为：" &lt;&lt; s1.name &lt;&lt; "  " &lt;&lt; "年龄为：" &lt;&lt; s1.age &lt;&lt; "  " &lt;&lt; "分数为： " &lt;&lt; s1.score&lt;&lt; "  " &lt;&lt;endl;
	// 2. struct  结构体名 变量名 = { 成员1值，成员2值……}
	struct Student s2 = { "张三", 20, 99 };
	cout &lt;&lt; "姓名为：" &lt;&lt; s2.name &lt;&lt; "  " &lt;&lt; "年龄为：" &lt;&lt; s2.age &lt;&lt; "  " &lt;&lt; "分数为： " &lt;&lt; s2.score &lt;&lt; "  " &lt;&lt; endl;
	// 3.  定义结构体时顺便创建变量
	s3.name = "张三";
	s3.age = 20;
	s3.score = 99;
	cout &lt;&lt; "姓名为：" &lt;&lt; s3.name &lt;&lt; "  " &lt;&lt; "年龄为：" &lt;&lt; s3.age &lt;&lt; "  " &lt;&lt; "分数为： " &lt;&lt; s3.score &lt;&lt; "  " &lt;&lt; endl;
	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="220" src="https://images2.imgbox.com/ee/cb/gDwpNqhR_o.png" width="589"></p> 
<p><span style="color:#fe2c24;"><strong>其中，定义结构体时的关键字是 struct，不可以省略！</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>           创建结构体变量时，关键字 struct 可以省略！</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>           结构体变量利用操作符 “.” 访问成员！</strong></span></p> 
<h4 id="1.11.2%20%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span style="color:#38d8f0;">1.11.2 结构体数组</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：将自定义的结构体放入到数组中方便维护</p> 
<p>        <span style="color:#0d0016;"><strong>语法</strong></span>：<span style="background-color:#ffd900;">struct  结构体名  数组名[ 元素个数 ] = { { } ，{ } ……{ } }</span></p> 
<pre><code>// 创建结构体
// struct 结构体名称
struct Student 
{
	string name;
	int age;
	int score;
};


int main()
{
	// 创建结构体数组
	struct Student stuArray[3]=
	{
		{ "张三", 20, 98},
		{ "李四", 21, 99 },
		{ "王五", 22, 100 }
	};
	// 给结构体数组中的元素赋值
	// 我们可以通过创建结构体数组的时候就给结构体数组赋值
	// 当然也可以是单独的给其赋值
	stuArray[2].name = "赵六"; // 修改王五的名字改为赵六

	// 遍历结构体数组
	for (int i = 0; i &lt; 3;i++)
	{
		cout &lt;&lt; "姓名为：" &lt;&lt; stuArray[i].name &lt;&lt; "  " &lt;&lt; "年龄为：" &lt;&lt; stuArray[i].age &lt;&lt; "  " &lt;&lt; "分数为：" &lt;&lt; stuArray[i].score &lt;&lt; "  " &lt;&lt; endl;
	}

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="150" src="https://images2.imgbox.com/62/df/NRBfPKz1_o.png" width="416"></p> 
<h4 id="1.11.3%20%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span style="color:#38d8f0;">1.11.3 结构体指针</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：通过指针访问结构体中的成员</p> 
<p>        利用操作符<span style="color:#fe2c24;"><strong> -&gt; </strong></span>可以通过结构体指针访问结构体属性</p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/b5/23/LplCVOCJ_o.png" width="753"></p> 
<h4 id="1.11.4%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93"><span style="color:#38d8f0;">1.11.4 结构体嵌套结构体</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：结构体中的成员可以是另一个结构体</p> 
<p>        <span style="color:#0d0016;"><strong>例如</strong></span>：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/96/f5/4L4A9BN4_o.png" width="446"></p> 
<pre><code>// 定义学生结构体
struct student
{
	string name;
	int age;
	int score;
};

// 定义一个老师结构体
// 每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体
struct teacher
{
	int id;				// 教师编号
	string name;    // 教师姓名
	int age;			// 年龄
	struct student stu; // 老师辅导的学生
};


int main()
{
	// 结构体嵌套结构体
	struct teacher t;
	t.name = "张三";
	t.age = 35;
	t.id = 223;
	t.stu.name = "李四";
	t.stu.age = 20;
	t.stu.score = 100;

	cout &lt;&lt; "老师姓名为：" &lt;&lt; t.name&lt;&lt; endl;
	cout &lt;&lt; "老师年龄为：" &lt;&lt; t.age&lt;&lt; endl;
	cout &lt;&lt; "老师ID为：" &lt;&lt; t.id&lt;&lt; endl;
	cout &lt;&lt; "老师辅导的学生姓名为：" &lt;&lt; t.stu.name &lt;&lt; endl;
	cout &lt;&lt; "老师辅导的学生年龄为：" &lt;&lt; t.stu.age&lt;&lt; endl;
	cout &lt;&lt; "老师辅导的学生分数为：" &lt;&lt; t.stu.score &lt;&lt; endl;

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="250" src="https://images2.imgbox.com/47/1f/pwvZyIKS_o.png" width="560"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注意：</strong></span></p> 
 <p>        定义学生的结构体一定要定义在老师结构体的上面，因为程序是顺序执行的！一定要保证程序先看到学生结构体；</p> 
 <p>        因为老师结构体中的一个成员变量是学生结构体，如果学生结构体不在老师结构体上面，那么程序顺序执行时将显示学生结构体成员变量不存在，进而程序无法运行！！！</p> 
</blockquote> 
<h4 id="1.11.5%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span style="color:#38d8f0;">1.11.5 结构体做函数参数</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong></span>：将结构体作为参数向函数中传递</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>传递方式：</strong></span></p> 
 <ul><li>        值传递</li><li>        地址传递</li></ul> 
</blockquote> 
<pre><code>// 定义学生结构体
struct student
{
	string name;
	int age;
	int score;
};

// 1. 值传递
void PrintStudent1(struct student s)
{
	cout &lt;&lt; "学生的姓名为：" &lt;&lt; s.name &lt;&lt; endl;
	cout &lt;&lt; "学生的年龄为：" &lt;&lt; s.age &lt;&lt; endl;
	cout &lt;&lt; "学生的分数为：" &lt;&lt; s.score &lt;&lt; endl;
}
// 2. 地址传递
void PrintStudent2(struct student* s)
{
	cout &lt;&lt; "学生的姓名为：" &lt;&lt; s-&gt;name &lt;&lt; endl;
	cout &lt;&lt; "学生的年龄为：" &lt;&lt; s-&gt;age &lt;&lt; endl;
	cout &lt;&lt; "学生的分数为：" &lt;&lt; s-&gt;score &lt;&lt; endl;
}

int main()
{
	// 结构体做函数参数
	// 将学生传入到一个参数中，打印学生身上的所有信息
	struct student s;
	s.name = "张三";
	s.age = 20;
	s.score = 100;

	PrintStudent1(s); // 1. 值传递
	PrintStudent2(&amp;s); // 2. 地址传递

	system("pause");
	return 0;
}
</code></pre> 
<p><img alt="" height="200" src="https://images2.imgbox.com/22/e5/lmLS2o1r_o.png" width="525"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>值传递和地址传递的区别：</strong></span></p> 
 <p>        在之前的学习中，我们已经学习过了两者的区别，这里再次回顾一下：</p> 
 <p>        <span style="background-color:#ffd900;">值传递过程中，形参的改变不会影响到实参</span>。比如说，我在函数 void PrintStudent1(struct student s) 中修改了年龄大小，但是在 main 函数中打印年龄是不会变化的，如果在函数 void PrintStudent1(struct student s) 中打印年龄才会发送变化！！！</p> 
 <p>        <span style="background-color:#ffd900;">而地址传递过程中，形参的改变会影响到实参</span>。重复上述过程，在函数 void PrintStudent2(struct student* s) 中修改年龄的大小，此时不管是在函数 void PrintStudent2(struct student* s) 中打印，还是在 main 函数中打印，年龄都会发生变化！！！</p> 
</blockquote> 
<h4 id="1.11.6%20%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%ADconst%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span style="color:#38d8f0;">1.11.6 结构体中const使用场景</span></h4> 
<p>       <span style="color:#0d0016;"><strong> 作用</strong></span>：用 const 来防止误操作的出现！！！        </p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/90/07/kM3TzrUL_o.png" width="651"></p> 
<p>        <span style="color:#0d0016;"><strong>先来分析一下上述代码</strong></span>：上述是采用的值传递，可以发现，<span style="background-color:#ffd900;">值传递过程中形参的改变是不影响实参的</span>；值传递也存在明显的缺点，当值传递所要传递的数据量过大时，会出现过度占用内存空间的现象，因为值传递采用的是拷贝的方式，拷贝占用的内存字节数会过大！！！</p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/39/86/ZGwccKvb_o.png" width="676"></p> 
<p>        此时我们采用地址传递的方式：<span style="background-color:#ffd900;">地址传递形参的改变会影响到实参</span>。但是地址传递不会过度占用内存，因为地址 (也就是指针) 只会占用 4 个字节！！！</p> 
<pre><code>// 定义学生结构体
struct student
{
	string name;
	int age;
	int score;
};

// 1. 值传递
void PrintStudent1(const struct student* s)
{
	// s-&gt;age = 100; // 当加上 const 修饰之后该句就会报错！！！
	cout &lt;&lt; "学生的年龄为：" &lt;&lt; s-&gt;age &lt;&lt; endl;
}

int main()
{
	// 结构体做函数参数
	// 将学生传入到一个参数中，打印学生身上的所有信息
	struct student s;
	s.name = "张三";
	s.age = 20;
	s.score = 100;

	PrintStudent1(&amp;s); // 1. 地址传递
	cout &lt;&lt; "main函数中打印学生的年龄为：" &lt;&lt; s.age &lt;&lt; endl;

	system("pause");
	return 0;
}</code></pre> 
<p>        现在用 const 进行修饰，const 修饰起到了限制的作用，此时会发现 s-&gt;age = 100; 会报错！！！</p> 
<p>        这也是 const 显著的作用：<span style="color:#0d0016;"><strong>防止误操作的出现！！！</strong></span></p> 
<h4 id="1.11.7%20%E7%BB%93%E6%9E%84%E4%BD%93%E6%A1%88%E4%BE%8B1"><span style="color:#38d8f0;">1.11.7 结构体案例1</span></h4> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>案例描述</strong></span>：学校正在做毕设项目，每名老师带领 5 个学生，总共有 3 名老师，需求如下：设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放 5 名学生的数组作为成员，学生的成员有姓名、考试分数，创建数组存放 3 名老师，通过函数给每个老师及所带的学生赋值，最终打印出老师数据以及老师所带的学生数据。</p> 
</blockquote> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
using namespace std;

/*     学校正在做毕设项目，每名老师带领 5 个学生，总共有 3 名老师，需求如下：设计学生和老师的结构体，其中在老师的结构体中，
        有老师姓名和一个存放 5 名学生的数组作为成员，学生的成员有姓名、考试分数，创建数组存放 3 名老师，
        通过函数给每个老师及所带的学生赋值，最终打印出老师数据以及老师所带的学生数据。								*/

// 创建学生结构体
struct Student
{
	string Sname;  // 学生姓名
	int score;    // 学生分数
};

// 创建老师结构体
struct Teacher
{
	string Tname;  // 老师姓名
	struct Student stu[5]; // 学生数组
};

void allocationSpace(struct Teacher tArray[],int len)
{
	string Teachername = "ABCDEF";

	for (int i = 0; i &lt; len;i++)
	{
		tArray[i].Tname = "Teacher_";
		tArray[i].Tname = tArray[i].Tname + Teachername[i];  // 这两句代码实现往 Teacher_ 后面加上 ABCDEF，拼接
		// 给每名老师所带的学生赋值
		for (int j = 0; j &lt; 5; j++)
		{
			tArray[i].stu[j].Sname = "Student_";
			tArray[i].stu[j].Sname = tArray[i].stu[j].Sname + Teachername[j];  // 学生名字进行拼接

			int Random_Score = rand() % 41 + 60; // 定义随机数 rand() % 41 表示1~40，+60表示61~100分
			tArray[i].stu[j].score = Random_Score;
		}
	}
}

void Print(struct Teacher tArray[],int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		cout &lt;&lt; "老师姓名为：" &lt;&lt; tArray [i].Tname&lt;&lt; endl;
		for (int j = 0; j &lt; 5; j++)
		{
			cout &lt;&lt; "\t学生" &lt;&lt; tArray[i].stu[j].Sname &lt;&lt; "的分数为：" &lt;&lt; tArray[i].stu[j].score &lt;&lt; endl;
			// \t 为转义字符，对齐，空出 TAB 个字符
		}
	}
}

int main()
{
	// 定义随机数种子，使得每次输出的分数都不一样
	srand((unsigned int)time(NULL));
	// 1. 创建 3 名老师的数组
	struct Teacher tArray[3];

	// 2. 通过函数给 3 名老师的信息赋值，并给老师带的学生信息赋值
	int len = sizeof(tArray) / sizeof(tArray[0]);
	allocationSpace(tArray, len);

	// 3. 打印老师和学生的信息
	Print(tArray,len);

	system("pause");
	return 0;
}

</code></pre> 
<p><img alt="" height="350" src="https://images2.imgbox.com/bd/44/Xof0Zpjq_o.png" width="515"></p> 
<h4 id="1.11.8%20%E7%BB%93%E6%9E%84%E4%BD%93%E6%A1%88%E4%BE%8B2"><span style="color:#38d8f0;">1.11.8 结构体案例2</span></h4> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>案例描述</strong></span>：设计一个英雄的结构体，包括成员姓名，年龄；创建结构体数组，数组中存放五名英雄。通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果！</p> 
 <pre><code> 五名英雄的信息如下：
 {"刘备",23,"男"},
 {"关羽",22,"男"},
 {"张飞",20,"男"},
 {"赵云",21,"男"},
 {"貂蝉",19,"女"},</code></pre> 
</blockquote> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
using namespace std;

/*     设计一个英雄的结构体，包括成员姓名，年龄；创建结构体数组，数组中存放五名英雄。
        通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果！			*/

/*     五名英雄的信息如下：
		{ "刘备", 23, "男" },
		{ "关羽", 22, "男" },
		{ "张飞", 20, "男" },
		{ "赵云", 21, "男" },
		{ "貂蝉", 19, "女" },	*/

// 创建英雄结构体
struct Hero
{
	string Hreo_Name;  // 英雄名字
	int Hero_Age;	// 英雄年龄
	string Hero_Sex; // 英雄性别
};

// 冒泡排序
void BubbleSort(struct Hero tArray[],int len)
{
	for (int i = 0; i &lt; len; i++)
	{
		for (int j = 0; j &lt; len - i - 1; j++)
		{
			if (tArray[j].Hero_Age &gt; tArray[j + 1].Hero_Age)
			{
				struct Hero Temp = tArray[j];
				tArray[j] = tArray[j+1];
				tArray[j + 1] = Temp;
			}
		}
	}
}

int main()
{
	// 1. 创建结构体数组
	struct Hero tArray[5]=
	{
		{ "刘备", 23, "男" },
		{ "关羽", 22, "男" },
		{ "张飞", 20, "男" },
		{ "赵云", 21, "男" },
		{ "貂蝉", 19, "女" }
	};
	int len = sizeof(tArray) / sizeof(tArray[0]);
	// 2. 打印原始结构体数组
	cout &lt;&lt; "排序前：" &lt;&lt; endl;
	for (int i = 0; i &lt; len;i++)
	{
		cout &lt;&lt; "姓名为：" &lt;&lt; tArray[i].Hreo_Name&lt;&lt;" " ;
		cout &lt;&lt; "年龄为：" &lt;&lt; tArray[i].Hero_Age &lt;&lt; " ";
		cout &lt;&lt; "性别为：" &lt;&lt; tArray[i].Hero_Sex &lt;&lt; endl;
	}
	cout &lt;&lt; "排序后：" &lt;&lt; endl;
	// 3. 按照年龄进行冒泡排序
	BubbleSort(tArray,len);
	for (int i = 0; i &lt; len; i++)
	{
		cout &lt;&lt; "姓名为：" &lt;&lt; tArray[i].Hreo_Name &lt;&lt; " ";
		cout &lt;&lt; "年龄为：" &lt;&lt; tArray[i].Hero_Age &lt;&lt; " ";
		cout &lt;&lt; "性别为：" &lt;&lt; tArray[i].Hero_Sex &lt;&lt; endl;
	}

	system("pause");
	return 0;
}

</code></pre> 
<p><img alt="" height="250" src="https://images2.imgbox.com/06/d0/7sTsoKv7_o.png" width="426"></p> 
<h3 id="1.12%20%E9%80%9A%E8%AE%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span style="color:#4da8ee;">1.12 通讯管理系统</span></h3> 
<p>        截止到目前：C++ 的基础知识已经了解了，通过上面的学习，我们已经可以实现一些简单的程序编写了！</p> 
<p>        为了检验我们学习的成果，我们来实现一个通讯录管理系统的编写！！！</p> 
<h4 id="1.12.1%20%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA"><span style="color:#38d8f0;">1.12.1 系统功能介绍及代码展示</span></h4> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>系统中需要实现的功能如下</strong></span>：</p> 
 <p>        <span style="color:#0d0016;"><strong>添加联系人</strong></span>：向通讯录添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址）最多记录 1000 人</p> 
 <p>        <span style="color:#0d0016;"><strong>显示联系人</strong></span>：显示通讯录中所有联系人信息</p> 
 <p>       <span style="color:#0d0016;"><strong> 删除联系人</strong></span>：按照姓名进行删除指定联系人</p> 
 <p>        <span style="color:#0d0016;"><strong>查找联系人</strong></span>：按照姓名查看指定联系人信息</p> 
 <p>      <span style="color:#0d0016;"><strong>  修改联系人</strong></span>：按照姓名重新修改指定联系人</p> 
 <p>        <span style="color:#0d0016;"><strong>清空联系人</strong></span>：清空通讯录中所有信息</p> 
 <p>        <span style="color:#0d0016;"><strong>退出通讯录</strong></span>：退出当前使用通讯录</p> 
</blockquote> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
using namespace std;

// 用 C++ 编写一个通讯录管理系统
//		添加联系人：向通讯录添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址）最多记录 1000 人
//		显示联系人：显示通讯录中所有联系人信息
//		删除联系人：按照姓名进行删除指定联系人
//	    查找联系人：按照姓名查看指定联系人信息
//		修改联系人：按照姓名重新修改指定联系人
//		清空联系人：清空通讯录中所有信息
//		退出通讯录：退出当前使用通讯录

#define MAX 1000 // 宏定义定义通讯录的最大存在人数

// 菜单函数
void showMenu()
{
	cout &lt;&lt; "***************************" &lt;&lt; endl;
	cout &lt;&lt; "*****  1、添加联系人  *****" &lt;&lt; endl;
	cout &lt;&lt; "*****  2、显示联系人  *****" &lt;&lt; endl;
	cout &lt;&lt; "*****  3、删除联系人  *****" &lt;&lt; endl;
	cout &lt;&lt; "*****  4、查找联系人  *****" &lt;&lt; endl;
	cout &lt;&lt; "*****  5、修改联系人  *****" &lt;&lt; endl;
	cout &lt;&lt; "*****  6、清空联系人  *****" &lt;&lt; endl;
	cout &lt;&lt; "*****  0、退出通讯录  *****" &lt;&lt; endl;
	cout &lt;&lt; "***************************" &lt;&lt; endl;
}

// 退出功能
// 根据用户不同的选择，进入不同的功能，选用switch分支结构，将整个架构进行搭建
// 当用户选择0的时候，执行退出，选择其他先不做操作，也不会退出程序
// 这一步骤在main函数中实现

// 联系人结构体
struct People
{
	string m_Name; // 姓名
	int m_Sex;  // 这里之所以不用string，是因为可能除啦男和女还有中性！ 
	int m_Age; // 年龄
	string m_Phone; // 电话
	string m_Address; // 家庭住址
};

// 通讯录结构体
struct AddressBooks
{
	struct People PeopleAddress[MAX]; // 定义结构体数组记录通讯录可以存在的最大人数
	int m_Size; // 定义变量记录当前通讯录的人数
};

// 添加联系人
void AddPeople(struct AddressBooks* Chat)
{
	if (Chat-&gt;m_Size==MAX)   // 如果通讯录已满
	{
		cout &lt;&lt; "通讯录已满，添加失败！" &lt;&lt; endl;
	}
	else
	{
		// 添加姓名
		cout &lt;&lt; "请输入姓名：" &lt;&lt; endl;
		string name;
		cin &gt;&gt; name; // 自己定义姓名
		Chat-&gt;PeopleAddress[Chat-&gt;m_Size].m_Name = name; // 这里添加的数组个数为当前通讯录的人数
		// 性别
		cout &lt;&lt; "请输入性别：" &lt;&lt; endl;
		cout &lt;&lt; "1 --- 男" &lt;&lt; endl;
		cout &lt;&lt; "2 --- 女" &lt;&lt; endl;
		int sex;
		while (true) // while循环保证性别只能是男和女
		{
			cin &gt;&gt; sex;
			if (sex == 1 || sex == 2)
			{
				Chat-&gt;PeopleAddress[Chat-&gt;m_Size].m_Sex = sex;
				break;
			}
			cout &lt;&lt; "请重新选择：" &lt;&lt; endl;
		}
		// 年龄
		cout &lt;&lt; "请输入年龄：" &lt;&lt; endl;
		int age;
		while (true)
		{
			cin &gt;&gt; age;
			if (age&gt;0 &amp;&amp; age&lt;150) // 同样保证年龄只能在0~150
			{
				Chat-&gt;PeopleAddress[Chat-&gt;m_Size].m_Age = age;
				break;
			}
			cout &lt;&lt; "请重新输入：" &lt;&lt; endl;
		}
		// 电话
		cout &lt;&lt; "请输入电话：" &lt;&lt; endl;
		string Telephone;
		cin &gt;&gt; Telephone;
		Chat-&gt;PeopleAddress[Chat-&gt;m_Size].m_Phone = Telephone;
		// 家庭住址
		cout &lt;&lt; "请输入家庭住址：" &lt;&lt; endl;
		string Address;
		cin &gt;&gt; Address;
		Chat-&gt;PeopleAddress[Chat-&gt;m_Size].m_Address = Address;
	}
	cout &lt;&lt; "添加成功！" &lt;&lt; endl;
	// 通讯录人数加一，方便结构体数组进行下一个人信息的录入
	Chat-&gt;m_Size++;
	system("pause"); // 按任意键继续
	system("cls"); // 清屏
}

// 显示联系人
void ShowPeople(AddressBooks* Chat)
{
	if (Chat-&gt;m_Size == 0)
	{
		cout &lt;&lt; "通讯录记录为0！" &lt;&lt; endl;
	}
	else
	{
		for (int i = 0; i &lt; Chat-&gt;m_Size; i++)
		{
			// 这里解释两点：
			// 1. 之所以用 \t 转义字符，是因为如果每天信息都换行的话，那么当人数过多时，显示起来会很复杂，所以使用转移字符，空出 8 个字符大小的间隙
			// 2. 在打印性别时：之所以使用三目操作符(Chat-&gt;PeopleAddress[i].m_Sex == 1 ? "男" : "女")，是因为我们输入性别时定义的是 1 2，分别表示男女
			//     那么打印时会打印出 1 或者 2，为了使性别变成男或者女，这里使用三目操作符；加括号是为了提高运算优先级
			cout &lt;&lt; "姓名：" &lt;&lt; Chat-&gt;PeopleAddress[i].m_Name &lt;&lt; "\t";
			cout &lt;&lt; "性别：" &lt;&lt; (Chat-&gt;PeopleAddress[i].m_Sex == 1 ? "男" : "女") &lt;&lt; "\t";
			cout &lt;&lt; "年龄：" &lt;&lt; Chat-&gt;PeopleAddress[i].m_Age &lt;&lt; "\t";
			cout &lt;&lt; "电话：" &lt;&lt; Chat-&gt;PeopleAddress[i].m_Phone &lt;&lt; "\t";
			cout &lt;&lt; "住址：" &lt;&lt; Chat-&gt;PeopleAddress[i].m_Address &lt;&lt; endl;
		}
	}
	system("pause");
	system("cls");
}

// 检测联系人
// 因为后续不管是删除联系人还是查找、修改联系人都需要先找到这个联系人
// 如果联系人存在，返回联系人	所在数组的具体位置；如果不存在返回 -1；
int IsExist(AddressBooks* Chat,string name) // 参数1：通讯录；参数2：通过姓名检测联系人
{
	for (int i = 0; i &lt; Chat-&gt;m_Size;i++)
	{
		if (Chat-&gt;PeopleAddress[i].m_Name == name)
		{
			return i; // 找到这个人了，返回这个人在结构体数组中的位置
		}
	}
	return -1; // 遍历整个结构体数组都没有找到这个姓名，返回-1；
}

// 删除联系人
void DeletePeople(AddressBooks* Chat)
{
	cout &lt;&lt; "请输入要删除的联系人姓名：" &lt;&lt; endl;
	string name;
	cin &gt;&gt; name;
	int ret = IsExist(Chat,name);
	if (ret!=-1)
	{
		// 找到了 
		for (int i = ret; i &lt; Chat-&gt;m_Size;i++) // 因为ret记录的是要删除人所在结构体数组的下角标
		// 所以从这个下角标开始往后遍历；删除就是让后续的数据依次向前覆盖
		// 例如：1 2 3 4 5 6，要删除4，只需要让5覆盖4的位置，让6覆盖5的位置；最后让数据-1即可；
		{
			Chat-&gt;PeopleAddress[i] = Chat-&gt;PeopleAddress[i + 1]; // 让结构体数组后一个数据覆盖前一个数据
		}
		Chat-&gt;m_Size--; // 人数--
		cout &lt;&lt; "删除成功！" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "查无此人！" &lt;&lt; endl;
	}
	system("pause");
	system("cls");
}

// 查找联系人
void SearchPeople(AddressBooks* Chat)
{
	cout &lt;&lt; "请输入要查找的联系人姓名：" &lt;&lt; endl;
	string name;
	cin &gt;&gt; name;
	int ret = IsExist(Chat, name);
	if (ret != -1)
	{
		cout &lt;&lt; "姓名：" &lt;&lt; Chat-&gt;PeopleAddress[ret].m_Name &lt;&lt; "\t";
		cout &lt;&lt; "性别：" &lt;&lt; (Chat-&gt;PeopleAddress[ret].m_Sex==1?"男":"女") &lt;&lt; "\t";
		cout &lt;&lt; "年龄：" &lt;&lt; Chat-&gt;PeopleAddress[ret].m_Age &lt;&lt; "\t";
		cout &lt;&lt; "电话：" &lt;&lt; Chat-&gt;PeopleAddress[ret].m_Phone &lt;&lt; "\t";
		cout &lt;&lt; "住址：" &lt;&lt; Chat-&gt;PeopleAddress[ret].m_Address &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "查无此人！" &lt;&lt; endl;
	}
	system("pause");
	system("cls");
}

// 修改指定的联系人信息
void ModifyPeople(AddressBooks* Chat)
{
	cout &lt;&lt; "请输入要修改的联系人姓名：" &lt;&lt; endl;
	string name;
	cin &gt;&gt; name;
	int ret = IsExist(Chat, name);
	if (ret != -1)
	{
		// 姓名
		string name;
		cout &lt;&lt; "请输入姓名：" &lt;&lt; endl;
		cin &gt;&gt; name;
		Chat-&gt;PeopleAddress[ret].m_Name = name;
		// 性别
		cout &lt;&lt; "请输入性别：" &lt;&lt; endl;
		cout &lt;&lt; "1 --- 男" &lt;&lt; endl;
		cout &lt;&lt; "2 --- 女" &lt;&lt; endl;
		int sex;
		while (true) // while循环保证性别只能是男和女
		{
			cin &gt;&gt; sex;
			if (sex == 1 || sex == 2)
			{
				Chat-&gt;PeopleAddress[ret].m_Sex = sex;
				break;
			}
			cout &lt;&lt; "请重新选择：" &lt;&lt; endl;
		}
		// 年龄
		cout &lt;&lt; "请输入年龄：" &lt;&lt; endl;
		int age;
		while (true)
		{
			cin &gt;&gt; age;
			if (age&gt;0 &amp;&amp; age&lt;150) // 同样保证年龄只能在0~150
			{
				Chat-&gt;PeopleAddress[ret].m_Age = age;
				break;
			}
			cout &lt;&lt; "请重新输入：" &lt;&lt; endl;
		}
		// 电话
		cout &lt;&lt; "请输入电话：" &lt;&lt; endl;
		string Telephone;
		cin &gt;&gt; Telephone;
		Chat-&gt;PeopleAddress[ret].m_Phone = Telephone;
		// 家庭住址
		cout &lt;&lt; "请输入家庭住址：" &lt;&lt; endl;
		string Address;
		cin &gt;&gt; Address;
		Chat-&gt;PeopleAddress[ret].m_Address = Address;

		cout &lt;&lt; "修改成功！" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "查无此人！" &lt;&lt; endl;
	} 
	system("pause");
	system("cls");
}

// 清空联系人
void CleanPeople(AddressBooks* Chat)
{
	// 清空联系人比较简单，只需要逻辑上将通讯录的人数设置为 0 即可，访问不到联系人即可！
	cout &lt;&lt; "请慎重考虑是否清空联系人！" &lt;&lt; endl;
	cout &lt;&lt; "确定清空请输入：1" &lt;&lt; endl;  // 判断是否真正的清空！
	int num = 0;
	while (true)
	{
		cin &gt;&gt; num;
		if (num == 1)
		{
			Chat-&gt;m_Size = 0;
			cout &lt;&lt; "通讯录已清空！" &lt;&lt; endl;
		}
		cout &lt;&lt; "请输入正确的请求！" &lt;&lt; endl;
	}

	system("pause");
	system("cls");
}

int main()
{
	// 创建结构体变量
	AddressBooks Chat;
	// 初始化通讯录当前的人员个数
	Chat.m_Size = 0;
	int Select = 0;
	
	while (true) // 这里不要认为while(true)是死循环，永远退不出循环！当按下0时会退出程序
	// 这里之所以使用while循环，是为了保证按下 123456 的时候不会执行完对应程序就退出
	// 简单来说就是我添加完联系人之后不会退出程序，while循环会使得完成 case 1之后重新输入Select；进行后续的功能使用！
	{
		showMenu();
		cin &gt;&gt; Select;
		switch (Select)
		{
		case 1: // 1、添加联系人
			AddPeople(&amp;Chat); // 通过之前的学习，我们知道值传递形参的修改是不影响实参的，因此这个我们采用地址传递，通过形参的修改去影响具体的实参！
			break;
		case 2: // 2、显示联系人
			ShowPeople(&amp;Chat);
			break;
		case 3: // 3、删除联系人
			//{ // 当switch后面代码比较多时，此时switch会报错，加上大括号，表示下述代码是一个代码段；
			//	cout &lt;&lt; "请输入联系人的姓名：" &lt;&lt; endl;
			//	string name;
			//	cin &gt;&gt; name;
			//	if (IsExist(&amp;Chat, name) == -1)
			//	{
			//		cout &lt;&lt; "查无此人！" &lt;&lt; endl;
			//	}
			//	else
			//	{
			//		cout &lt;&lt; "找到此人！" &lt;&lt; endl;
			//	}
			//}
			DeletePeople(&amp;Chat);
			break;
		case 4: // 4、查找联系人
			SearchPeople(&amp;Chat);
			break;
		case 5: // 5、修改联系人
			ModifyPeople(&amp;Chat);
			break;
		case 6: // 6、清空联系人
			CleanPeople(&amp;Chat);
			break;
		case 0: // 0、退出通讯录
			cout &lt;&lt; "欢迎下次使用！" &lt;&lt; endl;
			system("pause"); // 退出提示按任意键继续！！！
			return 0;
			break;
		default:
			break;
		}
	}

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#1c7331;"><u><em><strong>上述代码基本上做了合理的注释，如果还有哪里不明白或者书写有误，欢迎留言更正！！！</strong></em></u></span></p> 
</blockquote> 
<h2></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1b170fcf26f7759306700dd863ab20c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用服务器的卡来运行python文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dc5f5b55d36b1f93c86b72f3ee1d5b11/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决elementuiplus的button组件点击之后仍然是hover的问题以及修改主题颜色之后button的颜色问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>