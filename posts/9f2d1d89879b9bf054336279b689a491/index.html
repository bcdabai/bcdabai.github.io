<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>简单理解Vue2的响应式原理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="简单理解Vue2的响应式原理" />
<meta property="og:description" content="使用Vue作为前端开发技术栈的同学，在使用Vue时都会有一些好奇：为啥我们的响应式变量要在data中定义？Vue是如何监听到变化，实现响应式的？这次我们就来探究一下，Vue2的响应式原理。
对象的响应式 修改属性描述实现响应式 首先我们来实现基础的响应式，即监听data数据的变化。我的代码中提供了较详细的注释。
// 判断是否属于object function isObject(obj) { // 注意 null的typeof 也是 &#39;object&#39; return typeof obj === &#34;object&#34; &amp;&amp; obj != null; } // 为入参提供响应式逻辑 export function observer(obj) { // 不是object 原样返回 if (!isObject(obj)) return obj; // 遍历对象，为每个属性增加响应性 for (const key in obj) { defineReactive(obj, key, obj[key]); } } // 存储真正的属性值 const _obj = {}; // 为每个属性增加响应性 function defineReactive(obj, key, value) { _obj[key] = value; Object.defineProperty(obj, key, { // 取值 get() { console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9f2d1d89879b9bf054336279b689a491/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-12T15:52:42+08:00" />
<meta property="article:modified_time" content="2023-11-12T15:52:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">简单理解Vue2的响应式原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>使用Vue作为前端开发技术栈的同学，在使用Vue时都会有一些好奇：为啥我们的响应式变量要在data中定义？Vue是如何监听到变化，实现响应式的？这次我们就来探究一下，Vue2的响应式原理。</p> 
<h2><a id="_2"></a>对象的响应式</h2> 
<h3><a id="_4"></a>修改属性描述实现响应式</h3> 
<p>首先我们来实现基础的响应式，即监听data数据的变化。我的代码中提供了较详细的注释。</p> 
<pre><code class="prism language-js"><span class="token comment">// 判断是否属于object</span>
<span class="token keyword">function</span> <span class="token function">isObject</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 注意 null的typeof 也是 'object'</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">&amp;&amp;</span> obj <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 为入参提供响应式逻辑</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">observer</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 不是object 原样返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token comment">// 遍历对象，为每个属性增加响应性</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 存储真正的属性值</span>
<span class="token keyword">const</span> _obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 为每个属性增加响应性</span>
<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  _obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 取值</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">取值: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>_obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> _obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 存值</span>
    <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">===</span> _obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">存值: 由 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>_obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 改为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>newValue<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      _obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在observer函数中，我们仅对object进行处理。我们对object的每个属性都增加独立的响应性。方法是使用<code>Object.defineProperty</code>。它可以修改对象现有属性的描述。我们把一个普通属性改为一个由getter，setter描述的属性。在get和set函数中就能够监听到属性值的存取和变化，进行处理。而真正的值却存储在另一个对象中。我们来看一下使用效果。</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> observer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./index.js'</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

data<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'你好'</span>
data<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token string">'js'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>a <span class="token operator">+</span> data<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们在对象中定义了几个属性，把对象通过响应式处理后再进行存取。</p> 
<pre><code class="prism language-sh"><span class="token comment"># 输出效果</span>
a存值: 由 <span class="token number">1</span> 改为 你好
b存值: 由 <span class="token number">2</span> 改为 js
a取值: 你好
b取值: js
你好js
</code></pre> 
<h3><a id="_70"></a>使用闭包优化数据存储</h3> 
<p>上面代码中定义一个内部对象来存储真正的数据。内部对象的key即是响应式对象的key。这时如果有多个对象都通过这个函数获得响应性，且定义了相同key的属性，此时这个内部存储就会产生覆盖的情况。那么我们要设多个存储变量来分别为不同的对象存储数据么？不需要，使用闭包，我们可以简单的做到这点，</p> 
<p>闭包指的是当一个函数执行结束后，其内部的资源并没有被完全释放，还可以被继续使用。利用这个特性，我们可以在函数闭包中存储部分变量，而不用定义一个内部对象来存储。</p> 
<pre><code class="prism language-js"><span class="token comment">// 为每个属性增加响应性</span>
<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 取值</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">取值: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 存值</span>
    <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">存值: 由 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 改为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>newValue<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们使用value作为闭包的关键变量。这时即使defineReactive函数结束后，由于内部的get和set函数依然在使用value变量，因此它并不会被销毁。当触发set函数修改属性值时，我们直接更改value为新的值。后续get函数取值时，也能拿到新值。</p> 
<h3><a id="_96"></a>深度监听嵌套对象</h3> 
<p>我们的已经实现的observer函数，只能对于对象的一层属性进行处理，对于多层嵌套对象我们的响应式是失效的，例如这样：</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token string">"js"</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果：</span>
<span class="token comment">// b取值: [object Object]</span>
</code></pre> 
<p>目前我们的代码只在<code>data.b</code>取值的时候有响应性，而对<code>data.b.c</code>赋值的时候，响应性就没有了。我们处理下嵌套对象的监听：</p> 
<pre><code class="prism language-js"><span class="token comment">// 为每个属性增加响应性</span>
<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 如果是嵌套对象，继续监听其属性</span>
  <span class="token function">observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 取值</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">取值: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 存值</span>
    <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">存值: 由 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 改为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>newValue<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>实现也非常简单，就是在defineReactive中对value进行递归监听，即如果value是object，则继续监听其属性。</p> 
<h3><a id="_134"></a>新增对象深度监听</h3> 
<p>试想这样一种情况：某个深度监听的对象属性，一开始并不是个对象，但是后来被改成了对象。又或者嵌套对象本身被替换成了另一个对象。这时候我们更改的这个嵌套对象，就是没有响应性的。举个例子：</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> observer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./index.js"</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

data<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">"你好"</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token string">'js'</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span>b<span class="token punctuation">.</span>d <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>a <span class="token operator">+</span> data<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>此时的输出为：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 输出效果</span>
a存值: 由 <span class="token number">1</span> 改为 你好
b存值: 由 <span class="token number">2</span> 改为 <span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>
b取值: <span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>
a取值: 你好
b取值: <span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>
你好js
</code></pre> 
<p>可以看到，对于修改b属性为对象后，新增的c属性没有被监听到。这里和Vue2的机制是一样的。此时在Vue中可以使用<code>Vue.set</code>来为新增的对象增加响应性。对于我们的代码来说，实现可以更简单：直接适配新增嵌套对象时的响应性处理（但是新增属性依然是不行的）。改动也很简单，对于进入set函数的对象新值增加响应性即可。</p> 
<pre><code class="prism language-js"><span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果存储的是一个对象，那么继续增加响应性</span>
  <span class="token function">observer</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">存值: 由 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 改为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>newValue<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这时的输出效果如下：（注意<code>data.b.d</code>为新增属性，这里依然没有加入响应性）。</p> 
<pre><code class="prism language-sh"><span class="token comment"># 输出效果</span>
a存值: 由 <span class="token number">1</span> 改为 你好
b存值: 由 <span class="token number">2</span> 改为 <span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>
b取值: <span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>
c存值: 由 <span class="token number">2</span> 改为 js
a取值: 你好
b取值: <span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>
c取值: js
你好js
</code></pre> 
<h3><a id="_185"></a>为新增属性增加响应性</h3> 
<p>上一节我们的新增属性<code>data.b.d</code>没有增加响应性，也就是说，一开始没有在data中定义的属性，是没有响应性的。Vue提供了<code>Vue.set</code>方法为这类新增属性增加响应性。正好，我们的<code>defineReactive</code>函数也能达到这个目的。来看一下例子。</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> observer<span class="token punctuation">,</span> defineReactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./index.js"</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

data<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">"你好"</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>b<span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token string">'js'</span><span class="token punctuation">;</span>
<span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span>d <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>a <span class="token operator">+</span> data<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>不管对于嵌套的新增属性，还是在data上绑定的新增属性，使用defineReactive函数都可以为其新增响应性。看下输出效果：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 输出效果</span>
a存值: 由 <span class="token number">1</span> 改为 你好
b存值: 由 <span class="token number">2</span> 改为 <span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>
b取值: <span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>
b取值: <span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>
c存值: 由 <span class="token number">2</span> 改为 js
d存值: 由 <span class="token number">3</span> 改为 <span class="token number">4</span>
a取值: 你好
b取值: <span class="token punctuation">[</span>object Object<span class="token punctuation">]</span>
c取值: js
你好js
</code></pre> 
<h2><a id="_221"></a>数组的响应式</h2> 
<p>使用<code>Object.defineProperty</code>是无法监听到数组的push等方法引发的变化，因此对于数组形式我们还要单独进行处理。我们重新包装数组的原型，重写原型方法。使数组在使用方法修改数组对象前，我们也能监听到。</p> 
<pre><code class="prism language-js"><span class="token comment">// 继承数组原型对象</span>
<span class="token keyword">const</span> arrProperty <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span class="token comment">// 重写部分数组原型方法</span>
<span class="token keyword">const</span> methods <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'push'</span><span class="token punctuation">,</span><span class="token string">'pop'</span><span class="token punctuation">,</span><span class="token string">'shift'</span><span class="token punctuation">,</span><span class="token string">'unshift'</span><span class="token punctuation">,</span><span class="token string">'splice'</span><span class="token punctuation">]</span>
methods<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">method</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  arrProperty<span class="token punctuation">[</span>method<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">数组</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>method<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">方法</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 重新调用对应的数组方法</span>
    <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>可以看到，我们对常用的数组方法进行了重写，在我们重写的函数内容，首先监听到改动，然后再重新调用真正的方法执行改动逻辑。</p> 
<p>然后在observer函数中，对数组进行特殊处理：</p> 
<pre><code class="prism language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">observer</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 不是object 原样返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token comment">// 如果是数组则修改原型</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> arrProperty
  <span class="token punctuation">}</span>
  <span class="token comment">// 遍历对象，为每个属性增加响应性</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>然后我们就能监听到数组方法的响应性了。看一下例子：</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> observer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./index.js"</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>
<span class="token function">observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>这时的输出效果如下：(后续都省略了get方法的输出)</p> 
<pre><code class="prism language-sh"><span class="token comment"># 输出效果</span>
<span class="token number">1</span>存值: 由 <span class="token number">2</span> 改为 <span class="token number">3</span>
数组push方法: <span class="token number">4</span>
<span class="token number">4</span>
</code></pre> 
<h2><a id="_274"></a>总结</h2> 
<p>这里仅仅是简单的理解了一些Vue2的响应式原理，并且简化了场景。实际上Vue2对于响应式的处理要复杂的多，还涉及到一些对象通信和和设计模式的方法。后面有时间的时候，我们会更详细的探讨，Vue2中是如何实现响应式的。</p> 
<h2><a id="_277"></a>参考</h2> 
<ul><li>Object.defineProperty() MDN<br> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</li><li>深入响应式原理 Vue 2.x 文档<br> https://v2.cn.vuejs.org/v2/guide/reactivity.html</li><li>Vue响应式原理 文章中用到的源码<br> https://github.com/jzplp/VueJz</li><li>Vue2 &amp; Vue3 响应式实现原理<br> https://juejin.cn/post/7253148953600262203</li><li>面试官: 能不能手写 Vue 响应式？（Vue2 响应式原理【完整版】）<br> https://juejin.cn/post/7079807948830015502</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/834e806675245ebc4b73b7da672521be/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Acwing - 算法基础课 - 笔记（动态规划 · 二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ee9e63048330e9a8a83a561abc753c2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构与算法 | 第四章：字符串</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>