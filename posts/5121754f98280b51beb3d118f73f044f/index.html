<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>容器技术之Docker&amp;K8S知识笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="容器技术之Docker&amp;K8S知识笔记" />
<meta property="og:description" content=" 本文带你快速了解Kubernetes与Docker 让你对容器与虚拟机的区别、Docker与K8S有一个快速的了解
目录
演变史容器与虚拟机的区别K8S与Docker概念DockerK8S参考文章 演变史 传统部署时代： 早期，将单一的应用服务运行在物理服务器上，无法给服务器的应用程序进行资源的限制，导致物理服务器之间的资源负载使用不均衡，就导致了服务器上的应用程序的性能下降，物理服务器的维护成本变得很高。
虚拟化部署时代： 作为解决方案，引入了虚拟化功能，它允许您在单个物理服务器的 CPU 上运行多个虚拟机VM。虚拟化功能允许应用程序在 VM 之间隔离，并提供安全级别，因为一个应用程序的信息不能被另一个应用程序自由地访问。
容器部署时代： 容器类似于 VM，但是它们具有轻量级的隔离属性，可以在应用程序之间共享操作系统OS。因此，容器被认为是目前最轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。由于它们与基础架构分离，因此可以跨云和 OS 分发进行移植。
容器与虚拟机的区别 容器技术为什么会这么火爆？说白了，就是因为它“轻”。
在容器技术之前，业界的网红是虚拟机。虚拟机技术的代表，是VMWare和OpenStack。
相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是相互隔离的，互不影响。而容器，它不需要虚拟出整个操作系统，只需要虚拟出一个小规模的环境。类似于“沙箱”。
容器是在linux上本机运行，并与其他容器共享主机的内核，它运行的一个独立的进程，不占用其他任何可执行文件的内存，非常轻量。
虚拟机运行的是一个完成的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多。
下表中列举了容器与虚拟机之间的区别：
K8S与Docker概念 Docker Docker本身并不是容器，它是创建容器的工具，是应用容器引擎。一句话总结就是，从仓库中拉取镜像，利用镜像生成容器。
Docker技术的三大核心概念，分别是：镜像（Image）、容器（Container）、仓库（Repository）。相关概念解释如下：
宿主机，Host，运行Docker所在的物理机，是Docker运行的系统环境。镜像，Image，相当于一个程序模板，通过这个模板可以生成很多个相似的容器。可以理解为Java中的类，它本身不具备执行运行的能力，是一个对象抽象的模板。每个镜像可以有多个版本，用tag来区分。镜像可以通过Dockerfile来构建。容器，Container，Docker运行的最小单位对象。它是通过镜像实例化出来的一个可运行对象。容器的修改，可以提交反作用于镜像，更新这个容器的模板。仓库，Repository，用于存储管理镜像的仓库，类似于git管理代码的仓库一样，可以管理多版本的镜像。 镜像、容器和仓库三者的关系如下：
K8S 就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。
就在这个时候，K8S出现了。
K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。
一个K8S系统，通常称为一个K8S集群（Cluster）。这个集群主要包括两个部分：一个Master节点（主节点），一群Node节点（计算节点）。Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。
概括来说 K8s 架构就是一个 Master 对应一群 Node 节点。下面我们来逐一介绍 K8s 架构图中的 Master 和 Node。
Master 节点结构如下：apiserver 即 K8s 网关，所有的指令请求都必须要经过 apiserver。Scheduler 调度器，使用调度算法，把请求资源调度到某一个 Node 节点。Controller 控制器，维护 K8s 资源对象。etcd 存储资源对象。Node 节点结构如下：Kubelet 在每一个 Node 节点都存在一份，在 Node 节点上的资源操作指令由 Kubelet 来执行。Kube-proxy 代理服务，处理服务间负载均衡。Pod 是 K8s 管理的基本单元（最小单元），Pod 内部是容器，K8s 不是直接管理容器，而是管理 Pod。Docker 运行容器的基础环境，容器引擎。Fluentd 日志收集服务。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5121754f98280b51beb3d118f73f044f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-21T16:46:44+08:00" />
<meta property="article:modified_time" content="2022-01-21T16:46:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">容器技术之Docker&amp;K8S知识笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>本文带你快速了解Kubernetes与Docker</h4> 
<p>让你对容器与虚拟机的区别、Docker与K8S有一个快速的了解</p> 
<p><strong>目录</strong></p> 
<ul><li>演变史</li><li>容器与虚拟机的区别</li><li>K8S与Docker概念</li><li>Docker</li><li>K8S</li><li>参考文章</li></ul> 
<hr> 
<h2></h2> 
<h2>演变史</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ca/77/tVdgkIq3_o.png"></p> 
<p></p> 
<p><strong>传统部署时代：</strong> 早期，将单一的应用服务运行在物理服务器上，无法给服务器的应用程序进行资源的限制，导致物理服务器之间的资源负载使用不均衡，就导致了服务器上的应用程序的性能下降，物理服务器的维护成本变得很高。</p> 
<p><strong>虚拟化部署时代：</strong> 作为解决方案，引入了虚拟化功能，它允许您在单个物理服务器的 CPU 上运行多个虚拟机VM。虚拟化功能允许应用程序在 VM 之间隔离，并提供安全级别，因为一个应用程序的信息不能被另一个应用程序自由地访问。</p> 
<p><strong>容器部署时代：</strong> 容器类似于 VM，但是它们具有轻量级的隔离属性，可以在应用程序之间共享操作系统OS。因此，容器被认为是目前最轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。由于它们与基础架构分离，因此可以跨云和 OS 分发进行移植。</p> 
<h2></h2> 
<h2>容器与虚拟机的区别</h2> 
<p>容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p> 
<p>在容器技术之前，业界的网红是<strong>虚拟机</strong>。虚拟机技术的代表，是<strong>VMWare</strong>和<strong>OpenStack</strong>。</p> 
<p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是<strong>相互隔离</strong>的，互不影响。而容器，它不需要虚拟出整个操作系统，只需要虚拟出一个小规模的环境。类似于“沙箱”。</p> 
<p>容器是在linux上本机运行，并与其他容器共享主机的内核，它运行的一个独立的进程，不占用其他任何可执行文件的内存，非常轻量。<br> 虚拟机运行的是一个完成的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f6/a8/4esBs5bR_o.png"></p> 
<p></p> 
<p>下表中列举了容器与虚拟机之间的区别：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e0/53/UK8miiJr_o.png"></p> 
<p></p> 
<h2></h2> 
<h2>K8S与Docker概念</h2> 
<h2>Docker</h2> 
<p>Docker本身并不是容器，它是创建容器的工具，是<strong>应用容器引擎</strong>。一句话总结就是，从仓库中拉取镜像，利用镜像生成容器。</p> 
<p>Docker技术的三大核心概念，分别是：镜像（Image）、容器（Container）、仓库（Repository）。相关概念解释如下：</p> 
<ul><li>宿主机，Host，运行Docker所在的物理机，是Docker运行的系统环境。</li><li>镜像，Image，相当于一个程序模板，通过这个模板可以生成很多个相似的容器。可以理解为Java中的类，它本身不具备执行运行的能力，是一个对象抽象的模板。每个镜像可以有多个版本，用tag来区分。镜像可以通过Dockerfile来构建。</li><li>容器，Container，Docker运行的最小单位对象。它是通过镜像实例化出来的一个可运行对象。容器的修改，可以提交反作用于镜像，更新这个容器的模板。</li><li>仓库，Repository，用于存储管理镜像的仓库，类似于git管理代码的仓库一样，可以管理多版本的镜像。</li></ul> 
<p>镜像、容器和仓库三者的关系如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/75/e2/CKYCgHAi_o.png"></p> 
<p></p> 
<h2>K8S</h2> 
<p>就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。</p> 
<p>就在这个时候，K8S出现了。</p> 
<p><strong>K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。</strong></p> 
<p>一个K8S系统，通常称为一个K8S集群（Cluster）。这个集群主要包括两个部分：一个Master节点（主节点），一群Node节点（计算节点）。Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c1/a5/8uAeprnV_o.png"></p> 
<p></p> 
<p>概括来说 K8s 架构就是一个 Master 对应一群 Node 节点。下面我们来逐一介绍 K8s 架构图中的 Master 和 Node。</p> 
<ul><li>Master 节点结构如下：apiserver 即 K8s 网关，所有的指令请求都必须要经过 apiserver。Scheduler 调度器，使用调度算法，把请求资源调度到某一个 Node 节点。Controller 控制器，维护 K8s 资源对象。etcd 存储资源对象。</li><li>Node 节点结构如下：Kubelet 在每一个 Node 节点都存在一份，在 Node 节点上的资源操作指令由 Kubelet 来执行。Kube-proxy 代理服务，处理服务间负载均衡。Pod 是 K8s 管理的基本单元（最小单元），Pod 内部是容器，K8s 不是直接管理容器，而是管理 Pod。Docker 运行容器的基础环境，容器引擎。Fluentd 日志收集服务。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dcaac530eb634d8065d93d4c871b707b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">modbus协议的常用测试工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a420b193ed4fd96b974fc881f610f462/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RocketMQ发送延迟消息时报错，发送同步消息却正常</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>