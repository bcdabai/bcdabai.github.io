<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言编程规范 学习笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言编程规范 学习笔记" />
<meta property="og:description" content="C语言编程规范 一、代码总体原则1、清晰2、简洁3、选择适合的风格，与代码原有风格保持一致 二、头文件背景术语定义原则 2.1 头文件中适合放置接口的声明，不适合放置实现原则 2.2 头文件应当职责单一原则 2.3 头文件应该向稳定的方向包含规则 2.1 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口规则 2.2 禁止头文件循环依赖规则 2.3 .c/.h文件禁止包含用不到的头文件规则 2.4 头文件应当自包含规则 2.5 总是编写内部#include保护符（#define 保护）规则 2.6 禁止在头文件中定义变量规则 2.7 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量规则 2.8 禁止在extern &#34;C&#34;中包含头文件建议 2.1 一个模块通常包含多个.c文件，建议放在同一个目录下，目录名即为模块名。为方便使用者，建议每一个模块提供一个.h，文件名为目录名。建议 2.2 如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的.h，文件名为子模块名。建议 2.3 头文件不要使用非习惯用法的扩展名，如.inc建议 2.4 同一产品统一包含头文件排列方式 三、函数背景原则 3.1 一个函数仅完成一件功能原则 3.2 重复代码尽可能提炼成函数规则 3.1 避免函数过长，新增函数不超过50行（非空非注释行）规则 3.2 避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层规则 3.3 可重入函数应避免使用共享变量；若需使用，则应通过互斥手段（关中断，信号量）对其加以保护规则 3.4 对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。缺省由调用者负责。规则 3.5 对函数的错误返回码要全面处理规则 3.6 设计高扇入，合理扇出（小于7）的函数规则 3.7 废弃代码（没有被调用的函数和变量）要及时清除建议 3.1 函数不变参数使用const建议 3.2 函数应避免使用全局变量、静态局部变量和I/O操作，不可避免的地方应集中使用建议 3.3 检查函数所有非参数输入的有效性，如数据文件、公共变量等建议 3.4 函数的参数个数不超过5个建议 3.5 除打印类函数外，不要使用可变长参函数建议 3.6 在源文件范围内声明和定义的所有函数，除非外部可见，否则应该增加static关键字 四、标识符命名与定义4.1 通用命名规则原则 4.1 标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解原则 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9733f4e134d606c75ac5283fbe6ab1e1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-11T19:18:40+08:00" />
<meta property="article:modified_time" content="2020-06-11T19:18:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言编程规范 学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>C语言编程规范</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、代码总体原则</a></li><li><ul><li><a href="#1_2" rel="nofollow">1、清晰</a></li><li><a href="#2_11" rel="nofollow">2、简洁</a></li><li><a href="#3_17" rel="nofollow">3、选择适合的风格，与代码原有风格保持一致</a></li></ul> 
  </li><li><a href="#_21" rel="nofollow">二、头文件</a></li><li><ul><li><a href="#_22" rel="nofollow">背景</a></li><li><a href="#_27" rel="nofollow">术语定义</a></li><li><a href="#_21__43" rel="nofollow">原则 2.1 头文件中适合放置接口的声明，不适合放置实现</a></li><li><a href="#_22__51" rel="nofollow">原则 2.2 头文件应当职责单一</a></li><li><a href="#_23__77" rel="nofollow">原则 2.3 头文件应该向稳定的方向包含</a></li><li><a href="#_21_ch_84" rel="nofollow">规则 2.1 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口</a></li><li><a href="#_22__91" rel="nofollow">规则 2.2 禁止头文件循环依赖</a></li><li><a href="#_23_ch_95" rel="nofollow">规则 2.3 .c/.h文件禁止包含用不到的头文件</a></li><li><a href="#_24__99" rel="nofollow">规则 2.4 头文件应当自包含</a></li><li><a href="#_25_includedefine__111" rel="nofollow">规则 2.5 总是编写内部#include保护符（#define 保护）</a></li><li><a href="#_26__137" rel="nofollow">规则 2.6 禁止在头文件中定义变量</a></li><li><a href="#_27_ccextern_139" rel="nofollow">规则 2.7 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量</a></li><li><a href="#_28_extern_C_145" rel="nofollow">规则 2.8 禁止在extern "C"中包含头文件</a></li><li><a href="#_21_ch_202" rel="nofollow">建议 2.1 一个模块通常包含多个.c文件，建议放在同一个目录下，目录名即为模块名。为方便使用者，建议每一个模块提供一个.h，文件名为目录名。</a></li><li><a href="#_22_h_209" rel="nofollow">建议 2.2 如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的.h，文件名为子模块名。</a></li><li><a href="#_23_inc_211" rel="nofollow">建议 2.3 头文件不要使用非习惯用法的扩展名，如.inc</a></li><li><a href="#_24__218" rel="nofollow">建议 2.4 同一产品统一包含头文件排列方式</a></li></ul> 
  </li><li><a href="#_236" rel="nofollow">三、函数</a></li><li><ul><li><a href="#_237" rel="nofollow">背景</a></li><li><a href="#_31__244" rel="nofollow">原则 3.1 一个函数仅完成一件功能</a></li><li><a href="#_32__264" rel="nofollow">原则 3.2 重复代码尽可能提炼成函数</a></li><li><a href="#_31_50_269" rel="nofollow">规则 3.1 避免函数过长，新增函数不超过50行（非空非注释行）</a></li><li><a href="#_32_4_276" rel="nofollow">规则 3.2 避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层</a></li><li><a href="#_33__311" rel="nofollow">规则 3.3 可重入函数应避免使用共享变量；若需使用，则应通过互斥手段（关中断，信号量）对其加以保护</a></li><li><a href="#_34__350" rel="nofollow">规则 3.4 对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。缺省由调用者负责。</a></li><li><a href="#_35__406" rel="nofollow">规则 3.5 对函数的错误返回码要全面处理</a></li><li><a href="#_36_7_443" rel="nofollow">规则 3.6 设计高扇入，合理扇出（小于7）的函数</a></li><li><a href="#_37__455" rel="nofollow">规则 3.7 废弃代码（没有被调用的函数和变量）要及时清除</a></li><li><a href="#_31_const_457" rel="nofollow">建议 3.1 函数不变参数使用const</a></li><li><a href="#_32_IO_483" rel="nofollow">建议 3.2 函数应避免使用全局变量、静态局部变量和I/O操作，不可避免的地方应集中使用</a></li><li><a href="#_33__489" rel="nofollow">建议 3.3 检查函数所有非参数输入的有效性，如数据文件、公共变量等</a></li><li><a href="#_34_5_509" rel="nofollow">建议 3.4 函数的参数个数不超过5个</a></li><li><a href="#_35__511" rel="nofollow">建议 3.5 除打印类函数外，不要使用可变长参函数</a></li><li><a href="#_36_static_513" rel="nofollow">建议 3.6 在源文件范围内声明和定义的所有函数，除非外部可见，否则应该增加static关键字</a></li></ul> 
  </li><li><a href="#_525" rel="nofollow">四、标识符命名与定义</a></li><li><ul><li><a href="#41__526" rel="nofollow">4.1 通用命名规则</a></li><li><ul><li><a href="#_41__546" rel="nofollow">原则 4.1 标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解</a></li><li><a href="#_42__558" rel="nofollow">原则 4.2 除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音</a></li><li><a href="#_41__586" rel="nofollow">规则 4.1 产品/项目组内部应保持统一的命名风格</a></li><li><a href="#_41__589" rel="nofollow">建议 4.1 用正确的反义词组命名具有互斥意义的变量或相反动作的函数等</a></li><li><a href="#_42__600" rel="nofollow">建议 4.2 尽量避免名字出现数字编号，除非逻辑上的确需编号</a></li><li><a href="#_43__610" rel="nofollow">建议 4.3 标识符前不应添加模块、项目、产品、部门的名称作为前缀</a></li><li><a href="#_44__616" rel="nofollow">建议 4.4 平台/驱动等适配代码的标识符命名风格保持和平台/驱动一致</a></li><li><a href="#_45__618" rel="nofollow">建议 4.5 重构/修改部分代码时，应保持和原有代码的命名风格一致</a></li></ul> 
   </li><li><a href="#42__620" rel="nofollow">4.2 文件命名规则</a></li><li><ul><li><a href="#_46__621" rel="nofollow">建议 4.6 文件命名统一采用小写字符</a></li></ul> 
   </li><li><a href="#43__623" rel="nofollow">4.3 变量命名规则</a></li><li><ul><li><a href="#_42_g__624" rel="nofollow">规则 4.2 全局变量应增加“g_”前缀</a></li><li><a href="#_43_s__625" rel="nofollow">规则 4.3 静态变量应增加“s_”前缀</a></li><li><a href="#_44_ijk_630" rel="nofollow">规则 4.4 禁止使用单字节命名变量，但允许定义i、j、k作为局部循环变量</a></li><li><a href="#_47__631" rel="nofollow">建议 4.7 不建议使用匈牙利命名法</a></li><li><a href="#_48__640" rel="nofollow">建议 4.8 使用名词或者形容词+名词方式命名变量</a></li></ul> 
   </li><li><a href="#44__641" rel="nofollow">4.4 函数命名规则</a></li><li><ul><li><a href="#49__642" rel="nofollow">建议4.9 函数名应以函数要执行的动作命名，一般采用动词或者动词+名词的结构</a></li><li><a href="#_410__647" rel="nofollow">建议 4.10 函数指针除了前缀，其他按照函数的命名规则命名</a></li></ul> 
   </li><li><a href="#45__648" rel="nofollow">4.5 宏的命名规则</a></li><li><ul><li><a href="#_45____649" rel="nofollow">规则 4.5 对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线“_” 的方式命名（枚举同样建议使用此方式定义）。</a></li><li><a href="#_46___654" rel="nofollow">规则 4.6 除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线“_”开头和结尾</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_656" rel="nofollow">五、变量</a></li><li><ul><li><a href="#_51__657" rel="nofollow">原则 5.1 一个变量只有一个功能，不能把一个变量用作多种用途</a></li><li><a href="#_52__681" rel="nofollow">原则 5.2 结构功能单一；不要设计面面俱到的数据结构</a></li><li><a href="#53__716" rel="nofollow">5.3 不用或者少用全局变量</a></li><li><a href="#_51__724" rel="nofollow">规则 5.1 防止局部变量与全局变量同名</a></li><li><a href="#_52__726" rel="nofollow">规则 5.2 通讯过程中使用的结构，必须注意字节序</a></li><li><a href="#_53__732" rel="nofollow">规则 5.3 严禁使用未经初始化的变量作为右值</a></li><li><a href="#_51__734" rel="nofollow">建议 5.1 构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象</a></li><li><a href="#_52__API___736" rel="nofollow">建议 5.2 使用面向接口编程思想，通过 API 访问数据：如果本模块的数据需要对外部模块开放 ，应提供接口函数来设置、获取，同时注意全局数据的访问互斥</a></li><li><a href="#_53__744" rel="nofollow">建议 5.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好</a></li><li><a href="#_54__786" rel="nofollow">建议 5.4 明确全局变量的初始化顺序，避免跨模块的初始化依赖</a></li><li><a href="#55__790" rel="nofollow">建议5.5 尽量减少没有必要的数据类型默认转换与强制转换</a></li></ul> 
  </li><li><a href="#_799" rel="nofollow">六、宏、常量</a></li><li><ul><li><a href="#_61__800" rel="nofollow">规则 6.1 用宏定义表达式时，要使用完备的括号</a></li><li><a href="#_62__815" rel="nofollow">规则 6.2 将宏所定义的多条表达式放在大括号中</a></li><li><a href="#_63__847" rel="nofollow">规则 6.3 使用宏时，不允许参数发生变化</a></li><li><a href="#_64__861" rel="nofollow">规则 6.4 不允许直接使用魔鬼数字</a></li><li><a href="#_61__870" rel="nofollow">建议 6.1 除非必要，应尽可能使用函数代替宏</a></li><li><a href="#_62_const_900" rel="nofollow">建议 6.2 常量建议使用const定义代替宏</a></li><li><a href="#_63_returngotocontinuebreak_917" rel="nofollow">建议 6.3 宏定义中尽量不使用return、goto、continue、break等改变流程的语句</a></li></ul> 
  </li><li><a href="#_931" rel="nofollow">七、质量保证</a></li><li><ul><li><a href="#_71__932" rel="nofollow">原则 7.1 代码质量保证优先原则</a></li><li><a href="#_72__942" rel="nofollow">原则 7.2 要时刻注意混淆的操作符</a></li><li><a href="#_73__979" rel="nofollow">原则 7.3 必须了解编译系统的内存分配方式，特别是编译系统对不同类型的变量的内存分配规则，如局部变量在何处分配、静态变量在何处分配等</a></li><li><a href="#_74__980" rel="nofollow">原则 7.4 不仅关注接口，同样要关注实现</a></li><li><a href="#_71__984" rel="nofollow">规则 7.1 禁止内存越界</a></li><li><a href="#_72__1009" rel="nofollow">规则 7.2 禁止内存泄漏</a></li><li><a href="#_73__1033" rel="nofollow">规则 7.3 禁止引用已经释放的内存空间</a></li><li><a href="#_74_1_1048" rel="nofollow">规则 7.4 编程时，要防止差1错误</a></li><li><a href="#_75_ifelse_ifelseswitchdefault_1059" rel="nofollow">规则 7.5 所有的if...else if结构应该由else子句结尾；switch语句必须有default分支</a></li><li><a href="#_71__1060" rel="nofollow">建议 7.1 函数中分配的内存，在函数退出之前要释放</a></li><li><a href="#_72_ifelseelse_1062" rel="nofollow">建议 7.2 if语句尽量加上else分支，对没有else分支的语句要小心对待</a></li><li><a href="#_73_goto_1063" rel="nofollow">建议 7.3 不要滥用goto语句</a></li><li><a href="#_74__1106" rel="nofollow">建议 7.4 时刻注意表达式是否会上溢、下溢</a></li></ul> 
  </li><li><a href="#_1124" rel="nofollow">八、程序效率</a></li><li><ul><li><a href="#_81__1125" rel="nofollow">原则 8.1 在保证软件系统的正确性、简洁、可维护性、可靠性及可测试性的前提下，提高代码效率</a></li><li><a href="#_82__1172" rel="nofollow">原则 8.2 通过对数据结构、程序算法的优化来提高效率</a></li><li><a href="#_81__1173" rel="nofollow">建议 8.1 将不变条件的计算移到循环体外</a></li><li><a href="#_82__1202" rel="nofollow">建议 8.2 对于多维大数组，避免来回跳跃式访问数组成员</a></li><li><a href="#_83__1227" rel="nofollow">建议 8.3 创建资源库，以减少分配对象的开销</a></li><li><a href="#_84_inline_1231" rel="nofollow">建议 8.4 将多次被调用的“小函数”改为inline函数或者宏实现</a></li></ul> 
  </li><li><a href="#_1237" rel="nofollow">九、注释</a></li><li><ul><li><a href="#_91__1238" rel="nofollow">原则 9.1 优秀的代码可以自我解释，不通过注释即可轻易读懂</a></li><li><a href="#_92__1272" rel="nofollow">原则 9.2 注释的内容要清楚、明了，含义明确，防止注释二义性</a></li><li><a href="#_93__1291" rel="nofollow">原则 9.3 在代码的功能、意图层次上进行注释，即注释解释代码难以直接表达的意图，而不是重复描述代码</a></li><li><a href="#_91__1321" rel="nofollow">规则 9.1 修改代码时，维护代码周边的所有注释，以保证注释与代码的一致性。不再有用的注释要删除</a></li><li><a href="#_92__1325" rel="nofollow">规则 9.2 文件头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者姓名、工号、内容、功能说明、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说</a></li><li><a href="#_93_____1347" rel="nofollow">规则 9.3 函数声明处注释描述函数功能、性能及用法，包括输 入和输出参数、函数返回值、可重入的要求等；定义处详细描述函数功能和实现要点，如实现的简要步骤、实现的理由、 设计约束 等。</a></li><li><a href="#_94__1349" rel="nofollow">规则 9.4 全局变量要有较详细的注释，包括对其功能、取值范围以及存取时注意事项等的说明</a></li><li><a href="#_95____1361" rel="nofollow">规则 9.5 注释应放在其代码上方相邻位置或右方，不可放在下面 。 如放于上方则需与其上面的代码用空行隔开，且与下方代码缩进相同</a></li><li><a href="#_96__switch__case__case__case__case__case__1377" rel="nofollow">规则 9.6 对于 switch 语句下的 case 语句，如果因为特殊情况需要处理完一个 case 后进入下一个 case 处理，必须在该 case 语句处理完、下一个 case 语句前加上明确的注释</a></li><li><a href="#_97__1399" rel="nofollow">规则 9.7 避免在注释中使用缩写，除非是业界通用或子系统内标准化的缩写</a></li><li><a href="#_98__1400" rel="nofollow">规则 9.8 同一产品或项目组统一注释风格</a></li><li><a href="#_91__1401" rel="nofollow">建议 9.1 避免在一行代码或表达式的中间插入注释。</a></li><li><a href="#_92__1403" rel="nofollow">建议 9.2 注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。对于有外籍员工的，由产品确定注释语言</a></li><li><a href="#_93__1405" rel="nofollow">建议 9.3 文件头、函数头、全局常量变量、类型定义的注释格式采用工具可识别的格式</a></li></ul> 
  </li><li><a href="#_1433" rel="nofollow">十、排版与格式</a></li><li><ul><li><a href="#_101_4_1434" rel="nofollow">规则 10.1 程序块采用缩进风格编写，每级缩进为4个空格</a></li><li><a href="#_102__1440" rel="nofollow">规则 10.2 相对独立的程序块之间、变量说明之后必须加空行</a></li><li><a href="#_103__1461" rel="nofollow">规则 10.3 一条语句不能过长，如不能拆分需要分行写。一行到底多少字符换行比较合适，产品可以自行确定</a></li><li><a href="#_104__1478" rel="nofollow">规则 10.4 多个短语句（包括赋值语句）不允许写在同一行内，即一行只写一条语句</a></li><li><a href="#_105__if__for__do__while__case__switch__default__1487" rel="nofollow">规则 10.5 if 、 for 、 do 、 while 、 case 、 switch 、 default 等语句独占一行</a></li><li><a href="#_106____1494" rel="nofollow">规则 10.6 在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格； 进行非对等操作时，如果 是关系密切的立即操作符（如－&gt;），后不应加空格</a></li><li><a href="#_101______1518" rel="nofollow">建议 10.1 注释符（包括„ /*‟„ //‟„ */‟ ）与注释内容之间要用一个空格进行分隔</a></li><li><a href="#_102__1522" rel="nofollow">建议 10.2 源程序中关系较为紧密的代码应尽可能相邻</a></li></ul> 
  </li><li><a href="#_1523" rel="nofollow">十一、表达式</a></li><li><ul><li><a href="#_111___1524" rel="nofollow">规则 11.1 表达式的值在标准所允许的任何运算次序下都应该是相同的</a></li><li><a href="#_111___1589" rel="nofollow">建议 11.1 函数调用不要作为另一个函 数的参数使用，否则对于代码的调试、阅读都不利</a></li><li><a href="#_112__if__1615" rel="nofollow">建议 11.2 赋值语句不要写在 if 等语句中，或者作为函数的参数使用</a></li><li><a href="#_113__1643" rel="nofollow">建议 11.3 用括号明确表达式的操作顺序，避免过分依赖默认优先级</a></li><li><a href="#_114__1668" rel="nofollow">建议 11.4 赋值操作符不能使用在产生布尔值的表达式上</a></li></ul> 
  </li><li><a href="#_1691" rel="nofollow">十二、代码编辑、编译</a></li><li><ul><li><a href="#_121__1692" rel="nofollow">规则 12.1 使用编译器的最高告警级别，理解所有的告警，通过修改代码而不是降低告警级别来消除所有告警</a></li><li><a href="#_122__1694" rel="nofollow">规则 12.2 在产品软件（项目组）中，要统一编译开关、静态检查选项以及相应告警清除策略</a></li><li><a href="#_123__PC__Lint__1698" rel="nofollow">规则 12.3 本地构建工具（如 PC- - Lint ）的配置应该和持续集成的一致</a></li><li><a href="#_124___1700" rel="nofollow">规则 12.4 使用版本控制（配置管理）系统，及时签入通过本地构建的代码，确保签入的代码不会 影响构建成功</a></li><li><a href="#_121__1702" rel="nofollow">建议 12.1 要小心地使用编辑器提供的块拷贝功能编程。</a></li></ul> 
  </li><li><a href="#_1703" rel="nofollow">十三、可测性</a></li><li><ul><li><a href="#_131___1704" rel="nofollow">原则 13.1 模块划分清晰，接口明确，耦合性小，有明确输入和输出，否则单元测试实施困难</a></li><li><a href="#_131___1712" rel="nofollow">规则 13.1 在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明</a></li><li><a href="#_13_2___1717" rel="nofollow">规则 13. 2 在同一项目组或产品组内，调测打印的日志要有统一的规定</a></li><li><a href="#_133___1723" rel="nofollow">规则 13.3 使用断言记录内部假设</a></li><li><a href="#_134____1727" rel="nofollow">规则 13.4 不能用断言来检查运行 时错误</a></li><li><a href="#_131___1733" rel="nofollow">建议 13.1 为单元测试和系统故障注入测试准备好方法和通道</a></li></ul> 
  </li><li><a href="#_1734" rel="nofollow">十四、安全性</a></li><li><ul><li><ul><li><a href="#_141__1736" rel="nofollow">原则 14.1 对用户输入进行检查</a></li></ul> 
   </li><li><a href="#141__1754" rel="nofollow">14.1 字符串操作安全</a></li><li><ul><li><a href="#_141__NULL__1755" rel="nofollow">规则 14.1 确保所有字符串是以 NULL 结束</a></li><li><a href="#_142___1777" rel="nofollow">规则 14.2 不要将边界不明确的字符串写到固定长度的数组中</a></li></ul> 
   </li><li><a href="#142__1802" rel="nofollow">14.2 整数安全</a></li><li><ul><li><a href="#_143__1804" rel="nofollow">规则 14.3 避免整数溢出</a></li><li><a href="#_144__1843" rel="nofollow">规则 14.4 避免符号错误</a></li><li><a href="#_145__1930" rel="nofollow">规则 14.5 避免截断错误</a></li></ul> 
   </li><li><a href="#143__1971" rel="nofollow">14.3 格式化输出安全</a></li><li><ul><li><a href="#_146__1972" rel="nofollow">规则 14.6 确保格式字符和参数匹配</a></li><li><a href="#_147__1988" rel="nofollow">规则 14.7 避免将用户输入作为格式化字符串的一部分或者全部</a></li></ul> 
   </li><li><a href="#144_IO_2064" rel="nofollow">14.4 文件I/O安全</a></li><li><ul><li><a href="#_148__strlen__2065" rel="nofollow">规则 14.8 避免使用 strlen() 计算二进制数据的长度</a></li><li><a href="#_149__int__IO__2099" rel="nofollow">规则 14.9 使用 int 类型变量来接受字符 I/O 函数的返回值</a></li></ul> 
   </li><li><a href="#145__2137" rel="nofollow">14.5 其它</a></li><li><ul><li><a href="#_1410___2138" rel="nofollow">规则 14.10 防止命令注入</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_2175" rel="nofollow">十五、单元测试</a></li><li><ul><li><a href="#_151__2176" rel="nofollow">规则 15.1 在编写代码的同时，或者编写代码前，编写单元测试试用例验证软件设计/编码的正确</a></li><li><a href="#_151__2177" rel="nofollow">建议 15.1 单元测试关注单元的行为而不是实现，避免针对函数的测试</a></li></ul> 
  </li><li><a href="#_2181" rel="nofollow">十六、可移植性</a></li><li><ul><li><a href="#_161__2182" rel="nofollow">规则 16.1 不能定义、重定义或取消定义标准库/平台中保留的标识符、宏和函数</a></li><li><a href="#_161__2183" rel="nofollow">建议 16.1 不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性</a></li><li><a href="#_162___2194" rel="nofollow">建议 16.2 除非为了满足特殊需求 ，避免使用嵌入式汇编</a></li></ul> 
  </li><li><a href="#_2197" rel="nofollow">十七、附件</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、代码总体原则</h2> 
<h3><a id="1_2"></a>1、清晰</h3> 
<p>1）<mark>代码是给人读的。</mark> 清晰的代码易于维护、易于重构。<br> 2）<mark>一般情况下，代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化。</mark></p> 
<blockquote> 
 <p>1.“程序必须为阅读它的人而编写，只是顺便用于机器执行。”——Harold Abelson 和 Gerald Jay<br> Sussman<br>   <br> 2.“编写程序应该以人为本，计算机第二。”——Steve McConnell</p> 
</blockquote> 
<h3><a id="2_11"></a>2、简洁</h3> 
<p>1）<mark>简洁的代码易于理解并且易于实现。</mark><br> 代码越长，就越难看懂，容易在修改时引入错误，意味着出错的地方越多，可靠性越低。<br> 2）<mark>提倡通过编写简洁明了的代码来提升代码可靠性。</mark><br> 3）<mark>废弃的代码（没有被调用的函数和全局变量）要及时清除，重复代码尽可能提炼成函数。</mark></p> 
<h3><a id="3_17"></a>3、选择适合的风格，与代码原有风格保持一致</h3> 
<p>1）产品所有人共同分享同一种风格所带来的好处，远远超出为了统一而付出的代价。<br> 2）<mark>重构/修改其它风格的代码时，比较明智的做法是根据现有代码的风格继续编写代码</mark>，或者使用格式转换工具进行转换成公司内部风格。</p> 
<h2><a id="_21"></a>二、头文件</h2> 
<h3><a id="_22"></a>背景</h3> 
<p><strong>对于C语言来说，头文件的设计体现了大部分的系统设计。</strong><br> 1）<mark>不合理的头文件布局是编译时间过长的根本原因。</mark><br> 2）不合理的头文件实际上是不合理的设计。</p> 
<h3><a id="_27"></a>术语定义</h3> 
<ul><li><strong>依赖：</strong> <em>这里特指编译依赖。</em><br> 若<code>x.h</code>包含了<code>y.h</code>，则称作<code>x</code>依赖<code>y</code>。</li></ul> 
<ol><li><strong>依赖关系会进行传导</strong><br> 如：<code>x.h</code>包含了<code>y.h</code>，<code>y.h</code>又包含了<code>z.h</code>，则x通过<code>y</code>依赖了<code>z</code>。</li><li><strong>依赖导致编译的时间上升</strong><br> 1）虽然依赖是不可避免的，也是必须的，但是不良的设计会导致整个系统的依赖关系无比复杂，使得任意一个文件的修改都要重新编译整个系统，导致编译时间巨幅上升。<br> 2）在一个设计良好的系统中，修改一个文件，只需要重新编译数个，甚至是一个文件。</li></ol> 
<blockquote> 
 <p>《google C++ Style Guide》1.2 头文件依赖 章节也给出了类似的阐述：<br> 1）若包含了头文件<code>aa.h</code>，则就引入了新的依赖：一旦<code>aa.h</code>被修改，任何直接和间接包含<code>aa.h</code>代码都会被重新编译。<br> 2）如果<code>aa.h</code>又包含了其他头文件如<code>bb.h</code>，那么<code>bb.h</code>的任何改变都将导致所有包含了<code>aa.h</code>的代码被重新编译，在敏捷开发方式下，代码会被频繁构建，漫长的编译时间将极大的阻碍频繁构建。<br> 3） 因此，我们倾向于减少包含头文件，尤其是在头文件中包含头文件，以控制改动代码后的编译时间。</p> 
</blockquote> 
<p>  合理的头文件划分体现了系统设计的思想，但是从编程规范的角度看，仍然有一些通用的方法，用来合理规划头文件。</p> 
<h3><a id="_21__43"></a>原则 2.1 头文件中适合放置接口的声明，不适合放置实现</h3> 
<p><em>说明：头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。</em><br> 1）<mark>内部使用的函数（相当于类的私有方法）声明不应放在头文件中。</mark><br> 2）<mark>内部使用的宏、枚举、结构定义不应放入头文件中。</mark><br> 3）<mark>变量定义不应放在头文件中，应放在.c文件中。</mark><br> 4）<mark>变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。</mark><br> 5）<mark>变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。</mark><br> 6）<mark>即使必须使用全局变量，也只应当在<code>.c</code>中定义全局变量，在.h中仅声明变量为全局的。</mark></p> 
<h3><a id="_22__51"></a>原则 2.2 头文件应当职责单一</h3> 
<p><em>说明：<br> 1）<mark>头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。</mark><br> 2）很多现有代码头文件过大，职责过多，再加上循环依赖问题，可能导致为了在<code>.c</code>中使用一个宏，而包含十几个头文件。</em></p> 
<pre><code class="prism language-c">示例： 如下是某平台定义WORD类型的头文件：

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;VXWORKS.H&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;KERNELLIB.H&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;SEMLIB.H&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;INTLIB.H&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;TASKLIB.H&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;MSGQLIB.H&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;STDIO.H&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;STDLIB.H&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;SYSLIB.H&gt;</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> WORD<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

说明：
<span class="token number">1</span>）这个头文件不但定义了基本数据类型WORD，还包含了stdio<span class="token punctuation">.</span>h syslib<span class="token punctuation">.</span>h等等不常用的头文件。
<span class="token number">2</span>）如果工程中有<span class="token number">10000</span>个源文件，而其中<span class="token number">100</span>个源文件使用了stdio<span class="token punctuation">.</span>h的printf，
<span class="token number">3</span>）由于上述头文件的职责过于庞大，而WORD又是每一个文件必须包含的，
<span class="token number">4</span>）从而导致stdio<span class="token punctuation">.</span>h<span class="token operator">/</span>syslib<span class="token punctuation">.</span>h等可能被不必要地展开了<span class="token number">9900</span>次，大大增加了工程的编译时间。
</code></pre> 
<h3><a id="_23__77"></a>原则 2.3 头文件应该向稳定的方向包含</h3> 
<p><em>说明：头文件的包含关系是一种依赖，一般来说，<mark>应当让不稳定的模块依赖稳定的模块，从而不稳定的模块发生变化时，不会影响（编译）稳定的模块。</mark></em></p> 
<blockquote> 
 <p>  就我们的产品来说，依赖的方向应该是：产品依赖于平台，平台依赖于标准库。某产品线平台的代码中已经包含了产品的头文件，导致平台无法单独编译，发布和测试，是一个非常糟糕的反例。</p> 
</blockquote> 
<p>1）<em><mark>除了不稳定的模块依赖于稳定的模块外，更好的方式是两个模块共同依赖于接口，</mark><br> 2）这样的任何一个模块的内部实现更改都不需要重新编译另一个模块。这里我们假设接口本身是稳定的。</em><br> 3）<strong>延伸阅读材料：</strong> 推荐开发人员使用“依赖倒置”原则，即由使用者制定接口，服务提供者实现接口。</p> 
<h3><a id="_21_ch_84"></a>规则 2.1 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口</h3> 
<p><em>说明：<mark>如果每一个<code>.c</code>文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，</mark> 如<code>main</code>函数所在的文件。</em></p> 
<blockquote> 
 <p>1）现有某些产品中，习惯一个<code>.c</code>文件对应两个头文件，一个用于存放对外公开的接口，一个用于存放内部需要用到的定义、声明等，以控制<code>.c</code>文件的代码行数。<br>         <br> 2）编者不提倡这种风格，这种风格的根源在于源文件过大，应首先考虑拆分<code>.c</code>文件，使之不至于太大。另外，一旦把私有定义、声明放到独立的头文件中，就无法从技术上避免别人<code>include</code>之，难保证这些定义最后真的只是私有的。</p> 
</blockquote> 
<p>  本规则反过来并不一定成立，有些特别简单的头文件，如命令ID定义头文件，不需要有对应的<code>.c</code>文件存在。</p> 
<h3><a id="_22__91"></a>规则 2.2 禁止头文件循环依赖</h3> 
<p><em>说明：<br> 1）头文件循环依赖，指<code>a.h</code>包含b.h，<code>b.h</code>包含<code>c.h</code>，<code>c.h</code>包含<code>a.h</code>之类导致任何一个头文件修改，都导致所有包含<code>a.h/b.h/c.h</code>的代码全部重新编译一遍。<br> 2）而如果是单向依赖，<code>a.h</code>包含<code>b.h</code>，<code>b.h</code>包含<code>c.h</code>，<code>c.h</code>不包含任何头文件，则修改<code>a.h</code>不会导致包含了<code>b.h/c.h</code>的源代码重新编译。</em></p> 
<h3><a id="_23_ch_95"></a>规则 2.3 .c/.h文件禁止包含用不到的头文件</h3> 
<p><em>说明：<br> 1）很多系统中头文件包含关系复杂，开发人员为了省事，可能不会去一一钻研，直接包含一切想到的头文件，甚至有些产品干脆发布了一个<code>god.h</code>，<br> 2）其中包含了所有头文件，然后发布给各个项目组使用，这种只图一时省事的做法，导致整个系统的编译时间进一步恶化，并对后来人的维护造成了巨大的麻烦。</em></p> 
<h3><a id="_24__99"></a>规则 2.4 头文件应当自包含</h3> 
<p><em>说明：<br> 1）简单地说<mark>自包含就是任意一个头文件均可独立编译。</mark><br> 2）如果一个头文件包含某个头文件，还要包含另一个头文件才能工作的话，就会增加交流障碍，给这个头文件的用户增添不必要的负担。</em></p> 
<blockquote> 
 <p>示例：<br> 如果<code>a.h</code>不是自包含，需要包含<code>b.h</code>才能编译，会带来危害：<br> 1）每个使用<code>a.h</code>头文件的<code>.c</code>文件，为了让引入的<code>a.h</code>的内容编译通过，都需要包含额外的头文件<code>b.h</code>。<br> 2）额外的头文件<code>b.h</code>必须在<code>a.h</code>之前进行包含，这在包含顺序上产生了依赖。</p> 
</blockquote> 
<p><strong>注意：</strong><br> 1）<mark>该规则需要与<code>.c/.h</code>文件禁止包含用不到的规则一起使用，</mark> 不能为了让<code>a.h</code>自包含，而在<code>a.h</code>中包含不必要的头文件。<br> 2）<code>a.h</code>要刚刚可以自包含，不能在<code>a.h</code>中多包含任何满足自包含之外的其他头文件。</p> 
<h3><a id="_25_includedefine__111"></a>规则 2.5 总是编写内部#include保护符（#define 保护）</h3> 
<p><em>说明：<br> 1）<mark>多次包含一个头文件可以通过认真的设计来避免。</mark><br> 2）<mark>如果不能做到这一点，就需要采取组织头文件内容被包含多于一次的机制。</mark><br> 3）<mark>为每个头文件配置一个宏，当头文件第一次被包含时就定义这个宏，并在头文件被在此包含时使用他以排除文件内容。</mark><br> 4）所有头文件都应当使用<code>#define</code>防止头文件被多重包含，命名格式为<code>FILENAME_H</code>，<mark>为了保证唯一性，更好的命名是PROJECTNAME_PATH_FILENAME_H。</mark></em></p> 
<blockquote> 
 <p>注：<br>   没有在宏最前面加上<code>'_'</code>，即使用<code>FILENAME_H</code>代替<code>_FILENAME_H _</code>，是因为一般以 <code>'_'</code>和<code>'__'</code> 开头的标识符为系统保留或者标准库使用，在有些静态检查工具中，若全局可见的标识符以 <code>'_'</code>开头会给出告警。</p> 
</blockquote> 
<p><strong>定义包含保护符时，应该遵守如下规则：<br> 1）保护符使用唯一名称。<br> 2）不要在受保护部分的前后放置代码或注释。</strong></p> 
<pre><code class="prism language-c">示例： 假定VOS工程的timer模块的timer<span class="token punctuation">.</span>h，其目录为VOS<span class="token operator">/</span>include<span class="token operator">/</span>timer<span class="token operator">/</span>timer<span class="token punctuation">.</span>h<span class="token punctuation">,</span>应按如下方式保护：
<span class="token macro property">#<span class="token directive keyword">ifndef</span> VOS_INCLUDE_TIMER_TIMER_H</span>
<span class="token macro property">#<span class="token directive keyword">define</span> VOS_INCLUDE_TIMER_TIMER_H</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
也可以使用如下简单方式保护：
<span class="token macro property">#<span class="token directive keyword">ifndef</span> TIMER_H</span>
<span class="token macro property">#<span class="token directive keyword">define</span> TIMER_H</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre> 
<p><strong>例外情况：</strong> 头文件的版权声明部分以及头文件的整体注释部分（如阐述此头文件的开发背景、使用注意事项等）可以放在保护符(<code>#ifndef XX_H</code>)前面。</p> 
<h3><a id="_26__137"></a>规则 2.6 禁止在头文件中定义变量</h3> 
<p><em>说明：<mark>在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义。</mark></em></p> 
<h3><a id="_27_ccextern_139"></a>规则 2.7 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量</h3> 
<p><em>说明：<br> 1）若<code>a.c</code>使用了<code>b.c</code>定义的<code>foo()</code>函数，则应当在<code>b.h</code>中声明<code>extern int foo(int input)； 2）</code>并在<code>a.c</code>中通过<code>#include &lt;b.h&gt;</code>来使用<code>foo</code>。<br> 3）禁止通过在<code>a.c</code>中直接写<code>extern int foo(int input)来使用foo；</code><br> 4）后面这种写法容易在<code>foo</code>改变时可能导致声明和定义不一致。</em></p> 
<h3><a id="_28_extern_C_145"></a>规则 2.8 禁止在extern "C"中包含头文件</h3> 
<p><em>说明：<mark>在<code>extern "C"</code>中包含头文件，会导致<code>extern "C"</code>嵌套</mark>，Visual Studio对<code>extern "</code>C"嵌套层次有限制，嵌套层次太多会编译错误。</em></p> 
<pre><code class="prism language-c">在<span class="token keyword">extern</span> <span class="token string">"C"</span>中包含头文件，可能会导致被包含头文件的原有意图遭到破坏。例如，存在a<span class="token punctuation">.</span>h和b<span class="token punctuation">.</span>h两个头文件：
<span class="token macro property">#<span class="token directive keyword">ifndef</span> A_H</span>
<span class="token macro property">#<span class="token directive keyword">define</span> A_H</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">define</span> a(value) foo(value)</span>
<span class="token macro property">#<span class="token directive keyword">else</span></span>
<span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment">//A_H</span>
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token macro property">#<span class="token directive keyword">ifndef</span> B_H</span>
<span class="token macro property">#<span class="token directive keyword">define</span> B_H</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{<!-- --></span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"a.h"</span></span>
<span class="token keyword">void</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token punctuation">}</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment">//B_H</span>
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
使用C<span class="token operator">++</span>预处理器展开b<span class="token punctuation">.</span>h将会得到：
<span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

说明：
<span class="token number">1</span>）按照a<span class="token punctuation">.</span>h作者的本意，函数foo是一个C<span class="token operator">++</span>的自由函数，其链接规范为“C<span class="token operator">++</span>”。
<span class="token number">2</span>）但在b<span class="token punctuation">.</span>h中，由于#include <span class="token string">"a.h"</span>被放到了<span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>的内部，函数foo的链接规范被不正确地更改了。
</code></pre> 
<pre><code class="prism language-c">示例：错误的使用方式：
<span class="token keyword">extern</span> <span class="token string">"C"</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"xxx.h"</span></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

正确的使用方式：
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"xxx.h"</span></span>
<span class="token keyword">extern</span> <span class="token string">"C"</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_21_ch_202"></a>建议 2.1 一个模块通常包含多个.c文件，建议放在同一个目录下，目录名即为模块名。为方便使用者，建议每一个模块提供一个.h，文件名为目录名。</h3> 
<p><em>说明：需要注意的是，<mark>这个.h并不是简单的包含所有内部的.h，它是为了模块使用者的方便，对外整体提供的模块接口。</mark></em></p> 
<blockquote> 
 <p>1）以Google test（简称GTest）为例，GTest作为一个整体对外提供C++单元测试框架，其1.5版本的gtest工程下有6个源文件和12个头文件。但是它对外只提供一个<code>gtest.h</code>，只要包含gtest.h即可使用GTest提供的所有对外提供的功能，使用者不必关系GTest内部各个文件的关系，即使以后GTest的内部实现改变了，比如把一个源文件<code>c</code>拆成两个源文件，使用者也不必关心，甚至如果对外功能不变，连重新编译都不需要。<br>         <br> 2）对于有些模块，其内部功能相对松散，可能并不一定需要提供这个.h，而是直接提供各个子模块或者<code>.c</code>的头文件。<br>         <br> 3）比如产品普遍使用的VOS，作为一个大模块，其内部有很多子模块，他们之间的关系相对比较松散，就不适合提供一个<code>vos.h</code>。而VOS的子模块，如<code>Memory</code>（仅作举例说明，与实际情况可能有所出入），其内部实现高度内聚，虽然其内部实现可能有多个<code>.c</code>和<code>.h</code>，但是对外只需要提供一个<code>Memory.h</code>声明接口。</p> 
</blockquote> 
<h3><a id="_22_h_209"></a>建议 2.2 如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的.h，文件名为子模块名。</h3> 
<p><em>说明：降低接口使用者的编写难度。</em></p> 
<h3><a id="_23_inc_211"></a>建议 2.3 头文件不要使用非习惯用法的扩展名，如.inc</h3> 
<p><em>说明：<br> 1）目前很多产品中使用了<code>.inc</code>作为头文件扩展名，这不符合c语言的习惯用法。<br> 2）在使用<code>.inc</code>作为头文件扩展名的产品，习惯上用于标识此头文件为私有头文件。<br> 3）但是从产品的实际代码来看，这一条并没有被遵守，一个<code>.inc</code>文件被多个<code>.c</code>包含比比皆是。<br> 4）本规范不提倡将私有定义单独放在头文件中，具体见 规则1.1。</em></p> 
<blockquote> 
 <p>  除此之外，使用.inc还导致source insight、Visual stduio等IDE工具无法识别其为头文件，导致很多功能不可用，如“跳转到变量定义处”。虽然可以通过配置，强迫IDE识别<code>.inc</code>为头文件，但是有些软件无法配置，如Visual Assist只能识别<code>.h</code>而无法通过配置识别<code>.inc</code>。</p> 
</blockquote> 
<h3><a id="_24__218"></a>建议 2.4 同一产品统一包含头文件排列方式</h3> 
<p><em>说明：常见的头文件排列方式：功能块排序、文件名排序、稳定度排序。</em></p> 
<pre><code class="prism language-c">示例<span class="token number">1</span>： 以升序方式排列头文件可以避免头文件被重复包含，如：
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;a.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;b.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;c/d.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;c/e.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;f.h&gt;</span></span>

示例<span class="token number">2</span>：以稳定度排序，建议将不稳定的头文件放在前面，如把产品的头文件放在平台的头文件前面，如下：
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;product.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;platform.h&gt;</span></span>

说明：
<span class="token number">1</span>）相对来说，product<span class="token punctuation">.</span>h修改较为频繁，
<span class="token number">2</span>）如果有错误，不必编译platform<span class="token punctuation">.</span>h就可以发现product<span class="token punctuation">.</span>h的错误，可以部分减少编译时间。
</code></pre> 
<h2><a id="_236"></a>三、函数</h2> 
<h3><a id="_237"></a>背景</h3> 
<p><strong>函数设计等精髓：编写整洁函数，同时把代码有效组织起来。</strong></p> 
<ul><li><strong>整洁函数要求：</strong> 代码简单直接、不隐藏设计者的意图、用干净利落的抽象和直截了当的控制语句将函数有机组织起来。</li><li><strong>代码的有效组织包括：</strong> 逻辑层组织和物理层组织两个方面。<br> 1）<strong>逻辑层</strong>，主要是把不同功能的函数通过某种联系组织起来，主要关注模块间的接口，也就是模块的架构。<br> 2）<strong>物理层</strong>，无论使用什么样的目录或者名字空间等，需要把函数用一种标准的方法组织起来。例如：设计良好的目录结构、函数名字、文件组织等，这样可以方便查找。</li></ul> 
<h3><a id="_31__244"></a>原则 3.1 一个函数仅完成一件功能</h3> 
<p><em>说明：<br> 1）<mark>一个函数实现多个功能，给开发、使用、维护都带来很大的困难。</mark><br> 2）将没有关联或者关联很弱的语句放到同一个函数中，会导致函数职责不明确，难以理解，那一侧是和改动。</em></p> 
<blockquote> 
 <p>案例：<code>realloc</code>。<br> 1）<mark>在标准C语言中，realloc是一个典型的不良设计。</mark><br> 2）这个函数的基本功能是重新分配内存，但它承担了太多的其他任务。<br> 3）如果传入的指针参数为<code>NULL</code>酒分配内存，如果传入的大小参数为0就释放内存。<br> 4）如果可行则就地重新分配，如果不可行则移到其他地方分配。<br> 5）如果没有足够可用的内存用来完成重新分配（扩大原来的内存块或者分配新的内存块），则返回<code>NULL</code>，而原来的内存块保持不变。<br> 6）<mark>这个函数不易扩展，容易导致问题。</mark></p> 
</blockquote> 
<pre><code class="prism language-c">例如下面代码容易导致内存泄漏：
<span class="token keyword">char</span> <span class="token operator">*</span>buffer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>XXX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
buffer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> NEW_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

说明：
    如果没有足够的内存用来完成重新分配，函数返回<span class="token constant">NULL</span>，导致buffer原来指向的内存丢失。
</code></pre> 
<h3><a id="_32__264"></a>原则 3.2 重复代码尽可能提炼成函数</h3> 
<p><em>说明：<br> 1）重复代码提炼成函数可以带来维护成本的降低。<br> 2）项目组应当使用代码重复度检查工具，在持续集成环境中持续检查代码重复度指标变化趋势，并对新增重复代码及时重构。<br> 3）<mark>当一段代码重复两次时，即应考虑消除重复，当代码重复度超过三次时，应当立刻着手消除重复。一般情况下，可以通过提炼成函数的形式消除重复代码。</mark></em></p> 
<h3><a id="_31_50_269"></a>规则 3.1 避免函数过长，新增函数不超过50行（非空非注释行）</h3> 
<p><em>说明：<br> 1）<mark>本规则仅对新增函数做要求，对已有函数修改时，建议不增加代码行。</mark><br> 2）过长的函数往往意味着函数功能不单一，过于复杂。<br> 3）函数的有效代码行数，即NBNC（非空非注释 ）应当在[1, 50]区间。<br> 4）<mark>例外：某些实现算法的函数，由于算法的聚合性与功能的全面性，可能会超过50行。</mark><br> 5）延伸阅读材料：<mark>业界普遍认为一个函数的代码行不要超过一个屏幕，避免来回翻页影响阅读。</mark></em></p> 
<h3><a id="_32_4_276"></a>规则 3.2 避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层</h3> 
<p><em>说明：<br> 1）<mark>本规则仅对新增函数做要求，对已有的代码建议不增加嵌套层次</mark><br> 2）函数的代码块嵌套深度指的是函数中的代码控制块（例如：<code>if、for、while、switch</code>等）之间互相包含等深度。<br> 3）每级嵌套都会增加代码阅读时等脑力消耗，因为需要在脑子里维护一个“栈”（比如，进入条件语句、进入循环……）。<br> 4）应该做进一步的功能分解，从而避免使代码的阅读者一次记住太多的上下文。优秀代码参考值：[1， 4]。</em></p> 
<pre><code class="prism language-c">示例：如下代码嵌套深度为<span class="token number">5.</span>
<span class="token keyword">void</span> serial <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Received<span class="token punctuation">)</span> <span class="token comment">//1</span>
   <span class="token punctuation">{<!-- --></span>
   		TmoCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
   		<span class="token keyword">switch</span> <span class="token punctuation">(</span>Buff<span class="token punctuation">)</span> <span class="token comment">//2</span>
   		 <span class="token punctuation">{<!-- --></span>
   			<span class="token keyword">case</span> AISGFLG<span class="token punctuation">:</span> <span class="token comment">//3</span>
   				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TiBuff<span class="token punctuation">.</span>Count <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span>
   						<span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TiBuff<span class="token punctuation">.</span>Buff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0xff</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>TiBuf<span class="token punctuation">.</span>Buff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> CurPa<span class="token punctuation">.</span>ADDR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//4</span>
   				<span class="token punctuation">{<!-- --></span>
   					Flg7E <span class="token operator">=</span> false<span class="token punctuation">;</span>
   					Received <span class="token operator">=</span> true<span class="token punctuation">;</span>
   				<span class="token punctuation">}</span>
   				<span class="token keyword">else</span> 
   				<span class="token punctuation">{<!-- --></span>
   					TiBuff<span class="token punctuation">.</span>Count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
   					Flg7D <span class="token operator">=</span> false<span class="token punctuation">;</span> 
   					Flg7E <span class="token operator">=</span> true<span class="token punctuation">;</span>
   				<span class="token punctuation">}</span>
               	<span class="token keyword">break</span><span class="token punctuation">;</span>
           	<span class="token keyword">default</span><span class="token punctuation">:</span> 
   				<span class="token keyword">break</span><span class="token punctuation">;</span> 
   		<span class="token punctuation">}</span> 
   	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_33__311"></a>规则 3.3 可重入函数应避免使用共享变量；若需使用，则应通过互斥手段（关中断，信号量）对其加以保护</h3> 
<p><em>说明：<br> 1）<mark>可重入函数是指可能被多个任务并发调用的函数。在多任务操作系统中，函数具有可重入性是多个任务可以共用此函数的必要条件。</mark><br> 2）共享变量指的全局变量和<code>static</code>变量。<br> 3）编写C语言的可重入函数时，不应使用<code>static</code>局部变量，否则必须是经过特殊处理，才能使函数具有可重入性。</em></p> 
<pre><code class="prism language-c">示例：函数square_exam返回g_exam平方值。那么如下函数不具有可重入性。
<span class="token keyword">int</span> g_exam<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token keyword">int</span> para<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">unsigned</span> <span class="token keyword">int</span> temp<span class="token punctuation">;</span>

   g_exam <span class="token operator">=</span> para<span class="token punctuation">;</span> <span class="token comment">//(**)</span>
   temp <span class="token operator">=</span> <span class="token function">square_exam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

说明：
<span class="token number">1</span>）此函数若被多个线程调用的话，其结果可能是未知的，
<span class="token number">2</span>）因为当（<span class="token operator">*</span><span class="token operator">*</span>）语句刚执行完后，另外一个使用本函数的线程可能正好被激活，
<span class="token number">3</span>）那么当新激活的线程执行到此函数时，将使g_exam赋于另一个不同的para值，
<span class="token number">4</span>）所以当控制重新回到”temp <span class="token operator">=</span> <span class="token function">square_exam</span><span class="token punctuation">(</span><span class="token punctuation">)</span>”后，计算出的temp很可能不是预想中的结果。

此函数应如下改进：
<span class="token keyword">int</span> g_exam<span class="token punctuation">;</span>
unsigend <span class="token keyword">int</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token keyword">int</span> para<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">unsigned</span> <span class="token keyword">int</span> temp<span class="token punctuation">;</span>

   <span class="token punctuation">[</span>申请信号量操作<span class="token punctuation">]</span>        <span class="token comment">//若申请不到“信号量”，说明另外的进程正处于</span>
   g_exam <span class="token operator">=</span> para<span class="token punctuation">;</span>        <span class="token comment">//给g_exam赋值并计算其平方过程中（即正在使用此</span>
   temp <span class="token operator">=</span> <span class="token function">square_exam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//信号），本进程必须等待其释放信号后，才可继</span>
   <span class="token punctuation">[</span>释放信号量操作<span class="token punctuation">]</span>       <span class="token comment">//续执行。其它线程必须等待本线程释放信号量后</span>
                        <span class="token comment">//才能再来使用本信号。</span>

   <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_34__350"></a>规则 3.4 对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。缺省由调用者负责。</h3> 
<p><em>说明：<br>   对于模块间接口函数的参数的合法性检查这一问题，往往有两个极端现象，即：<br> 1）要么是调用者和被调用者对参数均不作合法性检查，结果就遗漏了合法性检查这一必要的处理过程，造成问题隐患；<br> 2）要么就是调用者和被调用者均对参数进行合法性检查，这种情况虽然不会造成问题，但产生了冗余代码，降低了效率。</em></p> 
<pre><code class="prism language-c">示例：
下面部分代码在每一个函数中都写了一次，导致代码有较多的冗余。
如果函数的参数比较多，而且判断的条件比较复杂（比如：一个整形数字需要判断范围等），
那么冗余的代码会大面积充斥着业务代码。
<span class="token keyword">void</span> <span class="token function">PidMsgProc</span><span class="token punctuation">(</span>MsgBlock <span class="token operator">*</span>Msg<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   MsgProcItem <span class="token operator">*</span>func <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span> Msg <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span>  <span class="token comment">//冗余代码</span>
   <span class="token punctuation">{<!-- --></span> 
   	<span class="token keyword">return</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token function">GetMsgProcFun</span><span class="token punctuation">(</span>Msg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">func</span><span class="token punctuation">(</span>Msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">GetMsgProcFun</span><span class="token punctuation">(</span>MsgBlock <span class="token operator">*</span>Msg<span class="token punctuation">,</span> MsgProcItem <span class="token operator">*</span><span class="token operator">*</span>func<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span> Msg <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token comment">//冗余代码</span>
   <span class="token punctuation">{<!-- --></span> 
   	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span> 
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token operator">*</span>func <span class="token operator">=</span> VOS_NULL_PTR<span class="token punctuation">;</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>Index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> Index <span class="token operator">&lt;</span> <span class="token function">NELEM</span><span class="token punctuation">(</span>g_MsgProcTable<span class="token punctuation">)</span><span class="token punctuation">;</span> Index<span class="token operator">++</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
   		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>g_MsgProcTable<span class="token punctuation">[</span>Index<span class="token punctuation">]</span><span class="token punctuation">.</span>FlowType <span class="token operator">==</span> Msg<span class="token operator">-&gt;</span>FlowType<span class="token punctuation">)</span> 
   		<span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>g_MsgProcTable<span class="token punctuation">[</span>Index<span class="token punctuation">]</span><span class="token punctuation">.</span>Status <span class="token operator">==</span> Msg<span class="token operator">-&gt;</span>Status<span class="token punctuation">)</span>
   		<span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>g_MsgProcTable<span class="token punctuation">[</span>Index<span class="token punctuation">]</span><span class="token punctuation">.</span>MsgType <span class="token operator">==</span> Msg<span class="token operator">-&gt;</span>MsgType<span class="token punctuation">)</span><span class="token punctuation">)</span>
   		<span class="token punctuation">{<!-- --></span>
   			<span class="token operator">*</span>func <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>g_MsgProcTable<span class="token punctuation">[</span>Index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
   		<span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">ServiceProcess</span><span class="token punctuation">(</span><span class="token keyword">int</span> CbNo<span class="token punctuation">,</span> MsgBlock <span class="token operator">*</span>Msg<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>  Msg <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token comment">//冗余代码</span>
   <span class="token punctuation">{<!-- --></span> 
   	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token comment">// 业务处理代码</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_35__406"></a>规则 3.5 对函数的错误返回码要全面处理</h3> 
<p><em>说明：<br> 1）一个函数（标准库的函数/第三方库函数/用户定义的函数）能够提供一些指示错误发生的方法。<br> 2）这可以通过使用错误标记、特殊的返回数据或者其他手段，<mark>不管什么时候函数提供了这样的机制，调用程序该在函数返回时立刻检查错误指示。</mark></em></p> 
<pre><code class="prism language-c">示例：下面的代码导致宕机
FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"./writeAlaemLastTime.log"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> buff<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 读取最新的警告时间；由于文件writeAlarmLast.log为空，导致buff为空 */</span>
<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">long</span> fileTime <span class="token operator">=</span> <span class="token function">getAlarnTime</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 解析获取最新的警告时间；getAlarmTime函数未检查buff，导致宕机 */</span>
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
正确写法：
FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"./writeAlaemLastTime.log"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> buff<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token comment">//检查函数fscanf的返回值，确保读到数据 </span>
<span class="token punctuation">{<!-- --></span>
   <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">long</span> fileTime <span class="token operator">=</span> <span class="token function">getAlarnTime</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 解析获取最新的警告时间; */</span>
</code></pre> 
<h3><a id="_36_7_443"></a>规则 3.6 设计高扇入，合理扇出（小于7）的函数</h3> 
<p><em>说明：<strong>扇出</strong> 是指一个函数直接调用（控制）其他函数的数目，而<strong>扇入</strong> 是指有多少上级函数调用它。</em><br> <img src="https://images2.imgbox.com/95/7c/x67d0kbi_o.png" alt="在这里插入图片描述"><br> 1）扇出过大，表明函数过分复杂，需要控制和协调过多的下级函数；<br> 2）而扇出过小，例如：总是1，表明函数的调用层次可能过多，这样不利于程序阅读和函数结构的分析，并且程序运行时会对系统资源如堆栈空间等造成压力。<br> 3）通常函数比较合理的扇出（调度函数除外）通常3~5。<br> 4）扇出太大，一般是由于缺乏中间层次，可适当增加中间层次的函数。<br> 5）扇出太小，可把下级函数进一步分解多个函数，或合并到上级函数中。<br> 6）当然分解或合并函数时，不能改变要实现的功能，也不能违背函数间的独立性。<br> 7）扇入越大，表明使用此函数的上级函数越多，这样的函数使用效率高，但不能违背函数间的独立性而单纯地追求高扇入。<br> 8）公共模块中的函数及底层函数应该有较高的扇入。<br> 10）较良好的软件结构通常是顶层函数的扇出较高，中层函数函数的扇出较少，而底层函数则扇入到公共模块。</p> 
<h3><a id="_37__455"></a>规则 3.7 废弃代码（没有被调用的函数和变量）要及时清除</h3> 
<p><em>说明：程序中的废弃代码不仅占用额外空间，而且还常常影响程序的功能与性能，很可能给程序的测试、维护等造成不必要的麻烦。</em></p> 
<h3><a id="_31_const_457"></a>建议 3.1 函数不变参数使用const</h3> 
<p><em>说明：<mark>不变的值更易于理解/跟踪和分析，把const作为默认选项，在编译时会对其进行检查，使代码更牢固/更安全。</mark></em></p> 
<pre><code class="prism language-c">示例：C99标准 <span class="token number">7.21</span><span class="token number">.4</span><span class="token number">.4</span> 中strncmp的例子，不变参数声明为<span class="token keyword">const</span>。
<span class="token keyword">int</span> <span class="token function">strncmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">,</span> <span class="token keyword">register</span> size_t n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">register</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> u1<span class="token punctuation">,</span> u2<span class="token punctuation">;</span>
   
   <span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">--</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
   		u1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token operator">*</span>s1<span class="token operator">++</span><span class="token punctuation">;</span>
   		u2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token operator">*</span>s2<span class="token operator">++</span><span class="token punctuation">;</span>
   		
   		<span class="token keyword">if</span><span class="token punctuation">(</span>u1 <span class="token operator">!=</span> u2<span class="token punctuation">)</span>
   		<span class="token punctuation">{<!-- --></span>
   			<span class="token keyword">return</span> u1 <span class="token operator">-</span> u2<span class="token punctuation">;</span>
   		<span class="token punctuation">}</span>
   
   		<span class="token keyword">if</span><span class="token punctuation">(</span>u1 <span class="token operator">==</span> <span class="token string">'\0'</span><span class="token punctuation">)</span>
   		<span class="token punctuation">{<!-- --></span>
   			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
   		<span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_32_IO_483"></a>建议 3.2 函数应避免使用全局变量、静态局部变量和I/O操作，不可避免的地方应集中使用</h3> 
<ul><li>说明：<br> 1）带有内部 “存储器 ”的函数的功能可能是不可预测的，因为它的输出可能取决于内部存储器（如某标记）的状态。<br> 2）这样的函数既不易于理解又不利于测试和维护。<br> 3）在C语言中，函数的<code>static</code>局部变量是函数的内部存储器，有可能使函数的功能不可预测，<br> 4）然而，<mark>当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为<code>auto</code>，则返回为错针。</mark>*</li></ul> 
<h3><a id="_33__489"></a>建议 3.3 检查函数所有非参数输入的有效性，如数据文件、公共变量等</h3> 
<p><em>说明：<br> 1）函数的输入主要有两种：一种是参数输入；<br> 2）另一种是全局变量、数据文件的输入，即非参数输入。<br> 3）函数在使用输入参数之前，应进行有效性检查。</em></p> 
<pre><code class="prism language-c">示例：下面的代码导致宕机
hr <span class="token operator">=</span> root_node<span class="token operator">-&gt;</span><span class="token function">get_first_child</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>log_item<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//list.xml为空，导致读出log_item为空</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
hr <span class="token operator">=</span> log_item<span class="token operator">-&gt;</span><span class="token function">get_next_sibling</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>media_next_node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//log_item为空，导致宕机</span>

正确写法：确保读出的内容非空
hr <span class="token operator">=</span> root_node<span class="token operator">-&gt;</span><span class="token function">get_first_child</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>log_item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>log_item <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">//确保读出的内容非空</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> retValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
hr <span class="token operator">=</span> log_item<span class="token operator">-&gt;</span><span class="token function">get_next_sibling</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>media_next_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_34_5_509"></a>建议 3.4 函数的参数个数不超过5个</h3> 
<p><em>说明：<mark>函数的参数过多，会使得该函数易于引入错误，而且性能也比较低，使用过多的可变长参数函数将导致函数的维护难度大大增加。</mark></em></p> 
<h3><a id="_35__511"></a>建议 3.5 除打印类函数外，不要使用可变长参函数</h3> 
<p><em>说明：可变长参函数的处理过程比较复杂，容易引入错误，而且性能也比较低，使用过多的可变长参函数将导致函数的维护难度大大增加。</em></p> 
<h3><a id="_36_static_513"></a>建议 3.6 在源文件范围内声明和定义的所有函数，除非外部可见，否则应该增加static关键字</h3> 
<p><em>说明：<br> 1）如果一个函数只是在同一文件中的其他地方调用，那么就用<code>static</code>声明。<br> 2）使用<code>static</code>确保只是在声明它的文件可见的，并且避免了和其他文件标或库中的相同的标识符发生混淆的可能性。<br> 3）<mark>建议定义一个<code>STATIC</code>宏，在调试阶段，将<code>STATIC</code>定义为<code>static</code>，版本发布时，改为空，以便于后续的打热补丁等操作。</mark></em></p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">ifdef</span> _DEBUG</span>
<span class="token macro property">#<span class="token directive keyword">define</span> STATIC static</span>
<span class="token macro property">#<span class="token directive keyword">else</span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> STATIC</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre> 
<h2><a id="_525"></a>四、标识符命名与定义</h2> 
<h3><a id="41__526"></a>4.1 通用命名规则</h3> 
<p>目前比较使用的如下几种命名风格：</p> 
<ul><li><strong>unix like风格：</strong><br> 1）单词用小写字母，每个单词直接用下划线<code>'_'</code>分割，<br> 2）例如 <code>text_mutex，kernel_texy_address</code>。</li><li><strong>Windows风格：</strong><br> 1）大小写字母混用，单词连在一起，每个单词首字母大写。<br> 2）不过Windows风格如果遇到大写专利有用语时会有些别扭，<br> 3）例如命名一个读取RFC文本的函数，命名为<code>ReadRFCText</code>，看起来就没有unix like的<code>read_frc_text</code>清晰了。</li><li><strong>匈牙利命名法：</strong><br> 1）是计算机程序设计中的一种命名规则，用这种方法命名的变量显示了其数据类型。<br> 2）匈牙利命名主要包括三个部分：基本类型、一个或更多的前缀、一个限定词。<br> 3）这种命令法最初在20世纪80年代的微软公司广泛使用，并在win32API和MFC库中广泛的使用，但匈牙利命名法存在较多的争议，<br> 4）例如：.NET Framework，微软新的软件开发平台，除了接口类型一般不适用匈牙利命名法。<br> 5）.NET Framework指导方针建议程序员不要用匈牙利命名法，但是没有指明不要用系统匈牙利命名法还是匈牙利应用命名法，或者是两者都不要用。<br> 6）与此对比，Java的标准库中连接口类型也不加前缀。<br> 7）标识符的命名规则历来是一个敏感话题，典型的命名风格如unix风格、windows风格等等，从来无法达成共识。<br> 8）实际上，各种风格都有其优势也有其劣势，而且往往和个人的审美观有关。<br> 9）我们对标识符定义主要是为了让团队的代码看起来尽可能统一，有利于代码的后续阅读和修改，产品可以根据自己的实际需要指定命名风格，规范中不再做统一的规定。</li></ul> 
<h4><a id="_41__546"></a>原则 4.1 标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解</h4> 
<p><em>说明：<mark>尽可能给出描述性名称，不要节约空间，让别人很快理解你的代码更重要。</mark></em></p> 
<pre><code class="prism language-c">示例：好的命名：
<span class="token keyword">int</span> error_number<span class="token punctuation">;</span>
<span class="token keyword">int</span> number_of_completed_connection<span class="token punctuation">;</span>

不好的命名：使用模糊的缩写或随意的字符：
<span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token keyword">int</span> nerr<span class="token punctuation">;</span>
<span class="token keyword">int</span> n_comp_conns<span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_42__558"></a>原则 4.2 除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音</h4> 
<p><em>说明：<br> 1）较短的单词可通过去掉“元音”形成缩写，较长的单词可取单词的头几个字母形成缩写，一些单词有大家公认的缩写，常用单词的缩写必须统一。<br> 2）协议中的单词的缩写与协议保持一致。对于某个系统使用的专用缩写应该在注视或者某处做统一说明。</em></p> 
<pre><code class="prism language-c">示例：一些常见可以缩写的例子：
argument      可缩写为 arg
buffer        可缩写为 buff
clock         可缩写为 clk
command       可缩写为 cmd
compare       可缩写为 cmp
configuration 可缩写为 cfg
device        可缩写为 dev
error         可缩写为 err
hexadecimal   可缩写为 hex
increment     可缩写为 inc
initialize    可缩写为 init
maximum       可缩写为 max
message       可缩写为 msg
minimum       可缩写为 min
parameter     可缩写为 para
previous      可缩写为 prev
<span class="token keyword">register</span>      可缩写为 reg
semaphore     可缩写为 sem
statistic     可缩写为 stat
synchronize   可缩写为 sync
temp          可缩写为 tmp
</code></pre> 
<h4><a id="_41__586"></a>规则 4.1 产品/项目组内部应保持统一的命名风格</h4> 
<p><em>说明：Unix like和windows like风格均有其拥趸，产品应根据自己的部署平台，选择其中一种，并在产品内部保持一致。</em><br> <strong>例外：</strong> 即使产品之前使用匈牙利命名法，新代码也不应当使用。</p> 
<h4><a id="_41__589"></a>建议 4.1 用正确的反义词组命名具有互斥意义的变量或相反动作的函数等</h4> 
<pre><code class="prism language-c">示例：
add<span class="token operator">/</span>remove          begin<span class="token operator">/</span>end   create<span class="token operator">/</span>destroy
insert<span class="token operator">/</span>delete       first<span class="token operator">/</span>last  get<span class="token operator">/</span>release
increment<span class="token operator">/</span>decrement put<span class="token operator">/</span>get     add<span class="token operator">/</span>delete
lock<span class="token operator">/</span>unlock         open<span class="token operator">/</span>close  min<span class="token operator">/</span>max
old<span class="token operator">/</span>new             start<span class="token operator">/</span>stop  next<span class="token operator">/</span>previous
source<span class="token operator">/</span>target       show<span class="token operator">/</span>hide   send<span class="token operator">/</span>receive
source<span class="token operator">/</span>destination  copy<span class="token operator">/</span>paste  up<span class="token operator">/</span>down
</code></pre> 
<h4><a id="_42__600"></a>建议 4.2 尽量避免名字出现数字编号，除非逻辑上的确需编号</h4> 
<pre><code class="prism language-c">示例：如下命名，使人产生疑惑。
<span class="token macro property">#<span class="token directive keyword">define</span> EXAMPLE_0_TEST_</span>
<span class="token macro property">#<span class="token directive keyword">define</span> EXAMPLE_1_TEST_</span>

应改为有意义的单词命名
<span class="token macro property">#<span class="token directive keyword">define</span> EXAMPLE_UNIT_TEST_</span>
<span class="token macro property">#<span class="token directive keyword">define</span> EXAMPLE_ASSERT_TEST_</span>
</code></pre> 
<h4><a id="_43__610"></a>建议 4.3 标识符前不应添加模块、项目、产品、部门的名称作为前缀</h4> 
<p><em>说明：<br>   很多已有代码中已经习惯在文件名中增加模块名，<mark>这种写法类似匈牙利命名法，导致文件名不可读，并且带来如下问题：</mark></em><br> 1）第一眼看到的是模块名，而不是真正的文件功能，阻碍阅读；<br> 2）文件名太长；<br> 3）文件名和模块绑定，不利于维护和移植。</p> 
<h4><a id="_44__616"></a>建议 4.4 平台/驱动等适配代码的标识符命名风格保持和平台/驱动一致</h4> 
<p><em>说明：涉及到外购芯片以及配套的驱动，这部分的代码变动（包括为产品做适配的新增代码），应该保持原有的风格。</em></p> 
<h4><a id="_45__618"></a>建议 4.5 重构/修改部分代码时，应保持和原有代码的命名风格一致</h4> 
<p><em>说明：根据源代码现有的风格继续编写代码，有利于保持总体一致。</em></p> 
<h3><a id="42__620"></a>4.2 文件命名规则</h3> 
<h4><a id="_46__621"></a>建议 4.6 文件命名统一采用小写字符</h4> 
<p><em>说明：<mark>因为不同系统对文件名大小写处理会不同（如MS的DOS、Windows系统不区分大小写，但是Linux系统则区分），所以代码文件命名建议统一采用全小写字母命名。</mark></em></p> 
<h3><a id="43__623"></a>4.3 变量命名规则</h3> 
<h4><a id="_42_g__624"></a>规则 4.2 全局变量应增加“g_”前缀</h4> 
<h4><a id="_43_s__625"></a>规则 4.3 静态变量应增加“s_”前缀</h4> 
<p><em>说明：<br>   增加g_前缀或者s_前缀，原因如下：</em><br> 1）首先，全局变量十分危险，通过前缀使得全局变量更加醒目，促使开发人员对这些变量的使用更加小心。<br> 2）其次，从根本上说，应当尽量不使用全局变量，增加<code>g_</code>和<code>s_</code>前缀，会使得全局变量的名字显得很丑陋，从而促使开发人员尽量少使用全局变量。</p> 
<h4><a id="_44_ijk_630"></a>规则 4.4 禁止使用单字节命名变量，但允许定义i、j、k作为局部循环变量</h4> 
<h4><a id="_47__631"></a>建议 4.7 不建议使用匈牙利命名法</h4> 
<p><em>说明：<br> 1）<mark>变量命名需要说明的是变量的含义，而不是变量的类型。</mark><br> 2）<mark>在变量命名前增加类型说明，反而降低了变量的可读性；</mark><br> 3）<mark>更麻烦的问题是，如果修改了变量的类型定义，那么所有使用该变量的地方都需要修改。</mark></em></p> 
<blockquote> 
 <p>1)匈牙利命名法源于微软，然而却被很多人以讹传讹的使用。<br> 2)而现在即使是微软也不再推荐使用匈牙利命名法。<br> 3)历来对匈牙利命名法的一大诟病，就是导致了变量名难以阅读，这和本规范的指导思想也有冲突，<br> 4)所以本规范特意强调，变量命名不应采用匈牙利命名法，而应想法使变量名为一个有意义的词或词组，方便代码的阅读。</p> 
</blockquote> 
<h4><a id="_48__640"></a>建议 4.8 使用名词或者形容词+名词方式命名变量</h4> 
<h3><a id="44__641"></a>4.4 函数命名规则</h3> 
<h4><a id="49__642"></a>建议4.9 函数名应以函数要执行的动作命名，一般采用动词或者动词+名词的结构</h4> 
<pre><code class="prism language-c">示例：找到当前进程的当前目录
DWORD <span class="token function">GetCurrentDirectory</span><span class="token punctuation">(</span> DWORD BufferLength<span class="token punctuation">,</span> LPTSTR Buffer <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_410__647"></a>建议 4.10 函数指针除了前缀，其他按照函数的命名规则命名</h4> 
<h3><a id="45__648"></a>4.5 宏的命名规则</h3> 
<h4><a id="_45____649"></a>规则 4.5 对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线“_” 的方式命名（枚举同样建议使用此方式定义）。</h4> 
<pre><code class="prism language-c">示例：
<span class="token macro property">#<span class="token directive keyword">define</span> PI_ROUNDED 3.14</span>
</code></pre> 
<h4><a id="_46___654"></a>规则 4.6 除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线“_”开头和结尾</h4> 
<p><em>说明：<mark>一般来说，<code>“_”</code>开头、结尾的宏都是一些内部的定义。</mark></em></p> 
<h2><a id="_656"></a>五、变量</h2> 
<h3><a id="_51__657"></a>原则 5.1 一个变量只有一个功能，不能把一个变量用作多种用途</h3> 
<p><em>说明：一个变量只用来表示一个特定功能，不能把一个变量作多种用途，即同一变量取值不同时，其代表的意义也不同。</em></p> 
<pre><code class="prism language-c">示例：具有两种功能的反例
WORD <span class="token function">DelRelTimeQue</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	WORD Locate<span class="token punctuation">;</span>
	Locate <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> 
	Locate <span class="token operator">=</span> <span class="token function">DeleteFromQue</span><span class="token punctuation">(</span>Locate<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Locate具有两种功能：位置和函数DeleteFromQue的返回值 */</span>
	
	<span class="token keyword">return</span> Locate<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

正确做法：使用两个变量
WORD <span class="token function">DelRelTimeQue</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	WORD Ret<span class="token punctuation">;</span>
	WORD Locate<span class="token punctuation">;</span>
	Locate <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	Ret  <span class="token operator">=</span> <span class="token function">DeleteFromQue</span><span class="token punctuation">(</span>Locate<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> Ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre> 
<h3><a id="_52__681"></a>原则 5.2 结构功能单一；不要设计面面俱到的数据结构</h3> 
<p><em>说明：<br> 1）相关的一组信息才是构成一个结构体的基础，结构的定义应该可以明确的描述一个对象，而不是一组相关性不强的数据的集合。<br> 2）设计结构时应力争使结构代表一种现实事务的抽象，而不是同时代表多种。<br> 3）结构中的各元素应代表同一事务的不同侧面，而不应把描述没有关系或关系很弱的不同事务的元素放到同一结构中。</em></p> 
<pre><code class="prism language-c">示例：如下结构不太清晰、合理。
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> STUDENT_STRU
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* student's name */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> age<span class="token punctuation">;</span>      <span class="token comment">/* student's age */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> sex<span class="token punctuation">;</span>      <span class="token comment">/* student's sex, as follows */</span>
	<span class="token comment">/* 0 - FEMALE; 1 - MALE */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> teacher_name<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* the student teacher's name */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> teacher_sex<span class="token punctuation">;</span>      <span class="token comment">/* his teacher sex */</span>
<span class="token punctuation">}</span> STUDENT<span class="token punctuation">;</span>

若改为如下，会更合理些。
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> TEACHER_STRU
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* teacher name */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> sex<span class="token punctuation">;</span>     <span class="token comment">/* teacher sex, as follows */</span>
	<span class="token comment">/* 0 - FEMALE; 1 - MALE */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> teacher_ind<span class="token punctuation">;</span> <span class="token comment">/* teacher index */</span>
<span class="token punctuation">}</span> TEACHER<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> STUDENT_STRU
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* student's name */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> age<span class="token punctuation">;</span>      <span class="token comment">/* student's age */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> sex<span class="token punctuation">;</span>      <span class="token comment">/* student's sex, as follows */</span>
	<span class="token comment">/* 0 - FEMALE; 1 - MALE */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> teacher_ind<span class="token punctuation">;</span> <span class="token comment">/* his teacher index */</span>
<span class="token punctuation">}</span> STUDENT<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="53__716"></a>5.3 不用或者少用全局变量</h3> 
<p><em>说明：<br> 1）单个文件内部可以使用<code>static</code>的全局变量，可以将其理解为类的私有成员变量。<br> 2）全局变量应该是模块的私有数据，不能作用对外的接口使用，<br> 3）使用<code>static</code>类型定义，可以有效防止外部文件的非正常访问，<br> 4）建议定义一个<code>STATIC</code>宏，在调试阶段，将<code>STATIC</code>定义为<code>static</code>，<br> 5）版本发布时，改为空，以便于后续的打补丁等操作。<br> 6）<mark>直接使用其他模块的私有数据，将使模块间的关系逐渐走向“剪不断理还乱”的耦合状态，这种情形是不允许的。</mark></em></p> 
<h3><a id="_51__724"></a>规则 5.1 防止局部变量与全局变量同名</h3> 
<p><em>说明：尽管局部变量和全局变量的作用域不同而不会发生语法错误，但容易使人误解。</em></p> 
<h3><a id="_52__726"></a>规则 5.2 通讯过程中使用的结构，必须注意字节序</h3> 
<p><em>说明：<br> 1）通讯报文中，字节序是一个重要的问题，我司设备使用的cpu类型复杂多样，大小端、32位/64位的处理器也都有，如果结构会在报文交互过程中使用，必须考虑字节序问题。<br> 2）由于位域在不同字节序下，表现看起来差别更大，所以更需要注意。<br> 3）对于这种跨平台的交互，数据成员发送前，都应该进行主机序到网络序的转换；<br> 4）接收时，也必须进行网络序到主机序的转换。</em></p> 
<h3><a id="_53__732"></a>规则 5.3 严禁使用未经初始化的变量作为右值</h3> 
<p><em>说明：坚持建议4.3（在首次使用前初始化变量，初始化的地方离使用的地方越近越好。）可以有效避免未初始化错误。</em></p> 
<h3><a id="_51__734"></a>建议 5.1 构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象</h3> 
<p><em>说明：降低全局变量耦合度。</em></p> 
<h3><a id="_52__API___736"></a>建议 5.2 使用面向接口编程思想，通过 API 访问数据：如果本模块的数据需要对外部模块开放 ，应提供接口函数来设置、获取，同时注意全局数据的访问互斥</h3> 
<p><em>说明：<br>   避免直接暴露内部数据给外部模型使用，是防止模块间耦合最简单有效的方法：<br> 1）定义的接口应该有比较明确的意义，比如一个风扇管理功能模块，有自动和手动工作模式，<br> 2）那么设置、查询工作模块就可以定义接口为<br> 3）<code>SetFanWorkMode</code>，<code>GetFanWorkMode</code>；<br> 4）查询转速就可以定义为<code>GetFanSpeed</code>；<br> 5）风扇支持节能功能开关，可以定义<code>EnabletFanSavePower</code>等等。</em></p> 
<h3><a id="_53__744"></a>建议 5.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好</h3> 
<p><em>说明：<br> 1）未初始化变量是C和C++程序中错误的常见来源。<br> 2）在变量首次使用前确保正确初始化。<br> 3）在较好的方案中，变量的定义和初始化要做到亲密无间。</em></p> 
<pre><code class="prism language-c">示例：
<span class="token comment">//不可取的初始化：无意义的初始化</span>
<span class="token keyword">int</span> speedup_factor ＝ <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	speedup_factor <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>
	speedup_factor <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//不可取的初始化：初始化和声明分离</span>
<span class="token keyword">int</span> speedup_factor<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	speedup_factor <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>
	speedup_factor <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//较好的初始化：使用默认有意义的初始化</span>
<span class="token keyword">int</span> speedup_factor <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	speedup_factor <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//较好的初始化使用?:减少数据流和控制流的混合</span>
<span class="token keyword">int</span> speedup_factor <span class="token operator">=</span> condition<span class="token operator">?</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">//较好的初始化：使用函数代替复杂的计算流</span>
<span class="token keyword">int</span> speedup_factor <span class="token operator">=</span> <span class="token function">ComputeSpeedupFactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；
</code></pre> 
<h3><a id="_54__786"></a>建议 5.4 明确全局变量的初始化顺序，避免跨模块的初始化依赖</h3> 
<p><em>说明：<br> 1）<mark>系统启动阶段，使用全局变量前，要考虑到该全局变量在什么时候初始化，</mark><br> 2）<mark>使用全局变量和初始化全局变量，两者之间的时序关系，谁先谁后，一定要分析清楚，不然后果往往是低级而又灾难性的。</mark></em></p> 
<h3><a id="55__790"></a>建议5.5 尽量减少没有必要的数据类型默认转换与强制转换</h3> 
<p><em>说明：<mark>当进行数据类型强制转换时，其数据的意义、转换后的取值等都有可能发生变化，而这些细节若考虑不周，就很有可能留下隐患。</mark></em></p> 
<pre><code class="prism language-c">示例：如下赋值，多数编译器不产生告警，但值的含义还是稍有变化。
<span class="token keyword">char</span> ch<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> exam<span class="token punctuation">;</span>
ch <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
exam <span class="token operator">=</span> ch<span class="token punctuation">;</span> <span class="token comment">// 编译器不产生告警，此时exam为0xFFFF。</span>
</code></pre> 
<h2><a id="_799"></a>六、宏、常量</h2> 
<h3><a id="_61__800"></a>规则 6.1 用宏定义表达式时，要使用完备的括号</h3> 
<p><em>说明：因为宏只是简单的代码替换，不会像函数一样先将参数计算后，再传递。</em></p> 
<pre><code class="prism language-c">示例：如下定义的宏都存在一定的风险
<span class="token macro property">#<span class="token directive keyword">define</span> RECTANGLE_AREA(a, b) a * b</span>
<span class="token macro property">#<span class="token directive keyword">define</span> RECTANGLE_AREA(a, b) (a * b)</span>
<span class="token macro property">#<span class="token directive keyword">define</span> RECTANGLE_AREA(a, b) (a) * (b)</span>

正确的定义应为：
<span class="token macro property">#<span class="token directive keyword">define</span> RECTANGLE_AREA(a, b) ((a) * (b))</span>

这是因为：
<span class="token number">1</span><span class="token punctuation">)</span>如果定义 #define <span class="token function">RECTANGLE_AREA</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> a <span class="token operator">*</span> b  或 #define <span class="token function">RECTANGLE_AREA</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span> 则 c<span class="token operator">/</span><span class="token function">RECTANGLE_AREA</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>  将扩展成 c<span class="token operator">/</span>a <span class="token operator">*</span> b <span class="token punctuation">,</span> c  与 b 本应该是除法运算，结果变成了乘法运算，造成错误。
<span class="token number">2</span><span class="token punctuation">)</span>如果定义 #define <span class="token function">RECTANGLE_AREA</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> 则 <span class="token function">RECTANGLE_AREA</span><span class="token punctuation">(</span>c <span class="token operator">+</span> d<span class="token punctuation">,</span> e <span class="token operator">+</span> f<span class="token punctuation">)</span> 将扩展成： <span class="token punctuation">(</span>c <span class="token operator">+</span> d <span class="token operator">*</span> e <span class="token operator">+</span> f<span class="token punctuation">)</span><span class="token punctuation">,</span> d 与 e 先运算，造成错误。
</code></pre> 
<h3><a id="_62__815"></a>规则 6.2 将宏所定义的多条表达式放在大括号中</h3> 
<p><em>说明：<mark>更好的方法是多条语句写成<code>do while(0)</code>的方式。</mark></em></p> 
<pre><code class="prism language-c">示例：看下面的语句，只有宏的第一条表达式被执行。
<span class="token macro property">#<span class="token directive keyword">define</span> FOO(x) \
	printf("arg is %d\n", x); \
	do_something_useful(x);</span>
	
为了说明问题，下面<span class="token keyword">for</span>语句的书写稍不符规范
<span class="token keyword">for</span> <span class="token punctuation">(</span>blah <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> blah <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> blah<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token function">FOO</span><span class="token punctuation">(</span>blah<span class="token punctuation">)</span>
	
用大括号定义的方式可以解决上面的问题：
<span class="token macro property">#<span class="token directive keyword">define</span> FOO(x) { \
	printf("arg is %s\n", x); \
	do_something_useful(x); \
}</span>

但是如果有人这样调用：
<span class="token keyword">if</span> <span class="token punctuation">(</span>condition <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token function">FOO</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//后面加分号，使调用如同函数</span>
<span class="token keyword">else</span>
	<span class="token function">FOO</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
那么这个宏还是不能正常使用，所以必须这样定义才能避免各种问题：
<span class="token macro property">#<span class="token directive keyword">define</span> FOO(x) do { \
	printf("arg is %s\n", x); \
	do_something_useful(x); \
} while(0)</span>

用<span class="token keyword">do</span><span class="token operator">-</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>方式定义宏，完全不用担心使用者如何使用宏，也不用给使用者加什么约束。
</code></pre> 
<h3><a id="_63__847"></a>规则 6.3 使用宏时，不允许参数发生变化</h3> 
<pre><code class="prism language-c">示例：如下用法可能导致错误。
<span class="token macro property">#<span class="token directive keyword">define</span> SQUARE(a) ((a) * (a))</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b<span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token function">SQUARE</span><span class="token punctuation">(</span>a<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 结果：a = 7，即执行了两次增。</span>

正确的用法是：
b <span class="token operator">=</span> <span class="token function">SQUARE</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 结果：a = 6，即只执行了一次增。</span>
</code></pre> 
<p>1）同时也建议即使函数调用，也不要在参数中做变量变化操作，<br> 2）因为可能引用的接口函数，在某个版本升级后，变成了一个兼容老版本所做的一个宏，结果可能不可预知。</p> 
<h3><a id="_64__861"></a>规则 6.4 不允许直接使用魔鬼数字</h3> 
<p><em>说明：<br> 1）使用魔鬼数字的弊端：代码难以理解；<br> 2）如果一个有含义的数字多处使用，一旦需要修改这个数值，代价惨重。<br> 3）使用明确的物理状态或物理意义的名称能增加信息，并能提供单一的维护点。</em><br> <strong>解决途径：</strong><br> 1）对于局部使用的唯一含义的魔鬼数字，可以在代码周围增加说明注释，也可以定义局部<code>const</code>变量，变量命名自注释。<br> 2）对于广泛使用的数字，必须定义<code>const</code>全局变量/宏；同样变量/宏命名应是自注释的。<br> 3）0作为一个特殊的数字，作为一般默认值使用没有歧义时，不用特别定义。</p> 
<h3><a id="_61__870"></a>建议 6.1 除非必要，应尽可能使用函数代替宏</h3> 
<p>说明：<br> <strong>宏对比函数，有一些明显的缺点：</strong><br> 1）宏缺乏类型检查，不如函数调用检查严格。<br> 2）宏展开可能会产生意想不到的副作用，</p> 
<ul><li>如<code>#define SQUARE(a) (a) * (a)</code>这样的定义，如果是<code>SQUARE(i++)</code>，就会导致i被加两次；</li><li>如果是函数调用<code>double square(double a) {return a * a;}</code>则不会有此副作用。<br> 3）以宏形式写的代码难以调试难以打断点，不利于定位问题。<mark>宏如果调用的很多，会造成代码空间的浪费，不如函数空间效率高。</mark></li></ul> 
<pre><code class="prism language-c">示例：下面的代码无法得到想要的结果：
<span class="token macro property">#<span class="token directive keyword">define</span> MAX_MACRO(a, b) ((a) &gt; (b) ? (a) : (b))</span>
<span class="token keyword">int</span> <span class="token function">MAX_FUNC</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">testFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//注意参数类型：b在表示无符号时大于a</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"MACRO: max of a and b is: %d\n"</span><span class="token punctuation">,</span> <span class="token function">MAX_MACRO</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"FUNC : max of a and b is: %d\n"</span><span class="token punctuation">,</span> <span class="token function">MAX_FUNC</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
上
面宏代码调用中，结果是<span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span>，所以a只加了一次，所以最终的输出结果是：
MACRO<span class="token punctuation">:</span> max of a and b is<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span>
FUNC <span class="token punctuation">:</span> max of a and b is<span class="token punctuation">:</span> <span class="token number">2</span>
</code></pre> 
<h3><a id="_62_const_900"></a>建议 6.2 常量建议使用const定义代替宏</h3> 
<p><em>说明： “尽量用编译器而不用预处理”，因为<code>#define</code>经常被认为好象不是语言本身的一部分。</em></p> 
<p>看下面的语句：<br> 1）<code>#define ASPECT_RATIO 1.653</code><br> 编译器会永远也看不到<code>ASPECT_RATIO</code>这个符号名，因为在源码进入编译器之前，它会被预处理程序去掉，于是<code>ASPECT_RATIO</code>不会加入到符号列表中。<br> 2）如果涉及到这个常量的代码在编译时报错，就会很令人费解，因为报错信息指的是1.653，而不是<code>ASPECT_RATIO</code>。<br> 3）如果<code>ASPECT_RATIO</code>不是在你自己写的头文件中定义的，你就会奇怪1.653是从哪里来的，甚至会花时间跟踪下去。<br> 4）这个问题也会出现在符号调试器中，因为同样地，你所写的符号名不会出现在符号列表中。</p> 
<p>解决这个问题的方案很简单：<br> 5）不用预处理宏，定义一个常量：<br> <code>const double ASPECT_RATIO = 1.653;</code><br> 6）这种方法很有效，但有两个特殊情况要注意。首先，定义指针常量时会有点不同。<br> 7）因为常量定义一般是放在头文件中（许多源文件会包含它），除了指针所指的类型要定义成<code>const</code>外，重要的是指针也经常要定义成<code>const</code>。<br> 8）例如，要在头文件中定义一个基于char*的字符串常量，你要写两次<code>const</code>：<br> <code>const char * const authorName = "Scott Meyers";</code></p> 
<h3><a id="_63_returngotocontinuebreak_917"></a>建议 6.3 宏定义中尽量不使用return、goto、continue、break等改变流程的语句</h3> 
<p><em>说明：如果在宏定义中使用这些改变流程的语句，很容易引起资源泄漏问题，使用者很难自己察觉。</em></p> 
<pre><code class="prism language-c">示例：在某头文件中定义宏CHECK_AND_RETURN：
<span class="token macro property">#<span class="token directive keyword">define</span> CHECK_AND_RETURN(cond, ret) {if (cond == NULL_PTR){return ret;}}</span>

然后在某函数中使用<span class="token punctuation">(</span>只说明问题，代码并不完整<span class="token punctuation">)</span><span class="token punctuation">:</span>
pMem1 <span class="token operator">=</span> <span class="token function">VOS_MemAlloc</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">CHECK_AND_RETURN</span><span class="token punctuation">(</span>pMem1 <span class="token punctuation">,</span> ERR_CODE_XXX<span class="token punctuation">)</span>
pMem2 <span class="token operator">=</span> <span class="token function">VOS_MemAlloc</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">CHECK_AND_RETURN</span><span class="token punctuation">(</span>pMem2 <span class="token punctuation">,</span> ERR_CODE_XXX<span class="token punctuation">)</span> <span class="token comment">/*此时如果pMem2==NULL_PTR，则pMem1未释放函数就返
回了，造成内存泄漏。*/</span>
</code></pre> 
<p><mark>所以说，类似于<code>CHECK_AND_RETURN</code>这些宏，虽然能使代码简洁，但是隐患很大，使用须谨慎。</mark></p> 
<h2><a id="_931"></a>七、质量保证</h2> 
<h3><a id="_71__932"></a>原则 7.1 代码质量保证优先原则</h3> 
<p>1）<strong>正确性，</strong> 指程序要实现设计要求的功能。<br> 2）<strong>简洁性，</strong> 指程序易于理解并且易于实现。<br> 3）<strong>可维护性，</strong> 指程序被修改的能力，包括纠错、改进、新需求或功能规格变化的适应能力。<br> 4）<strong>可靠性，</strong> 指程序在给定时间间隔和环境条件下，按设计要求成功运行程序的概率。<br> 5）<strong>代码可测试性，</strong> 指软件发现故障并隔离、定位故障的能力，以及在一定的时间和成本前提下，进<br> 行测试设计、测试执行的能力。<br> 6）<strong>代码性能高效，</strong> 指是尽可能少地占用系统资源，包括内存和执行时间。<br> 7）<strong>可移植性，</strong> 指为了在原来设计的特定环境之外运行，对系统进行修改的能力。<br> 8）<strong>个人表达方式/个人方便性，</strong> 指个人编程习惯。</p> 
<h3><a id="_72__942"></a>原则 7.2 要时刻注意混淆的操作符</h3> 
<p><em>说明：包括易混淆和易用错操作符。</em></p> 
<pre><code class="prism language-c"><span class="token number">1</span>、易混淆的操作符
C语言中有些操作符很容易混淆，编码时要非常小心。
赋值操作符“<span class="token operator">=</span>”  逻辑操作符“<span class="token operator">==</span>”
关系操作符“<span class="token operator">&lt;</span>”  位操作符<span class="token string">"&lt;&lt;"</span>
关系操作符“<span class="token operator">&gt;</span>”  位操作符“<span class="token operator">&gt;&gt;</span>”
逻辑操作符“<span class="token operator">||</span>” 位操作符<span class="token string">"|"</span>
逻辑操作符“<span class="token operator">&amp;&amp;</span>” 位操作符<span class="token string">"&amp;"</span>
逻辑操作符<span class="token string">"!"</span>  位操作符“<span class="token operator">~</span>”

<span class="token number">2</span>、易用错的操作符
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 除操作符<span class="token string">"/"</span>
当除操作符“<span class="token operator">/</span>”的运算量是整型量时，运算结果也是整型。
如<span class="token punctuation">:</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>求余操作符<span class="token string">"%"</span>
求余操作符<span class="token string">"%"</span>的运算量只能是整型。
如：<span class="token number">5</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">1</span>，而<span class="token number">5.0</span><span class="token operator">%</span><span class="token number">2</span>是错误的。
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>自加、自减操作符“<span class="token operator">++</span>”、“<span class="token operator">--</span>”
示例<span class="token number">1</span>
	k <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	x <span class="token operator">=</span> k<span class="token operator">++</span><span class="token punctuation">;</span>
	执行后，x <span class="token operator">=</span> <span class="token number">5</span>，k <span class="token operator">=</span> <span class="token number">6</span>
示例<span class="token number">2</span>
	k <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	x <span class="token operator">=</span> <span class="token operator">++</span>k<span class="token punctuation">;</span>
	执行后，x <span class="token operator">=</span> <span class="token number">6</span>，k <span class="token operator">=</span> <span class="token number">6</span>
示例<span class="token number">3</span>
	k <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	x <span class="token operator">=</span> k<span class="token operator">--</span><span class="token punctuation">;</span>
	执行后，x <span class="token operator">=</span> <span class="token number">5</span>，k <span class="token operator">=</span> <span class="token number">4</span>
示例<span class="token number">4</span>
	k <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	x <span class="token operator">=</span> <span class="token operator">--</span>k<span class="token punctuation">;</span>
	执行后，x <span class="token operator">=</span> <span class="token number">4</span>，k <span class="token operator">=</span> <span class="token number">4</span>
</code></pre> 
<h3><a id="_73__979"></a>原则 7.3 必须了解编译系统的内存分配方式，特别是编译系统对不同类型的变量的内存分配规则，如局部变量在何处分配、静态变量在何处分配等</h3> 
<h3><a id="_74__980"></a>原则 7.4 不仅关注接口，同样要关注实现</h3> 
<p><em>说明：<br> 1）这个原则看似和 “面向接口 ”编程思想相悖，但是实现往往会影响接口，函数所能实现的功能，除了和调用者传递的参数相关，往往还受制于其他隐含约束，<br> 2）如：物理内存的限制，网络状况，具体看 “抽象漏洞原则 ”。</em></p> 
<h3><a id="_71__984"></a>规则 7.1 禁止内存越界</h3> 
<p><em>说明：<br> 1）<mark>内存操作主要是指对数组、指针、内存地址等的操作。</mark><br> 2）<mark>内存操作越界是软件系统主要错误之一，后果往往非常严重，所以当我们进行这些操作时一定要仔细小心。</mark></em></p> 
<pre><code class="prism language-c">示例：使用itoa（）将整型数转换为字符串时：
<span class="token keyword">char</span> TempShold<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>
<span class="token function">itoa</span><span class="token punctuation">(</span>ProcFrecy<span class="token punctuation">,</span>TempShold<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 数据库刷新间隔设为值1073741823时，系统监控后台coredump,
监控前台抛异常。*/</span>
TempShold是以‘\<span class="token number">0</span>’结尾的字符数组，只能存储<span class="token number">9</span>个字符，而ProcFrecy的最大值可达到<span class="token number">10</span>位，导致符
数组TempShold越界。

正确写法：一个<span class="token keyword">int</span>（<span class="token number">32</span>位）在－<span class="token number">2147483647</span>～<span class="token number">2147483648</span>之间，将数组TempShold设置成<span class="token number">12</span>位。
<span class="token keyword">char</span> TempShold<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>
<span class="token function">itoa</span><span class="token punctuation">(</span>ProcFrecy<span class="token punctuation">,</span>TempShold<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>坚持下列措施可以避免内存越界：</strong></p> 
<ul><li>数组的大小要考虑最大情况，避免数组分配空间不够。</li><li>避免使用危险函数<code>sprintf /vsprintf/strcpy/strcat/gets</code>操作字符串，使用相对安全的函数<code>snprintf/strncpy/strncat/fgets</code>代替。</li><li>使用<code>memcpy/memset</code>时一定要确保长度不要越界</li><li>字符串考虑最后的<code>’\0’</code>， 确保所有字符串是以<code>’\0’</code>结束</li><li>指针加减操作时，考虑指针类型长度</li><li>数组下标进行检查</li><li>使用时<code>sizeof</code>或者<code>strlen</code>计算结构/字符串长度，避免手工计算</li></ul> 
<h3><a id="_72__1009"></a>规则 7.2 禁止内存泄漏</h3> 
<p><em>说明：<mark>内存和资源（包括定时器/文件句柄/Socket队列/信号量/GUI等各种资源）泄漏是常见的错误。</mark></em></p> 
<pre><code class="prism language-c">示例：异常出口处没有释放内存
MsgDBDEV <span class="token operator">=</span> <span class="token punctuation">(</span>PDBDevMsg<span class="token punctuation">)</span><span class="token function">GetBuff</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span> DBDevMsg <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>MsgDBDEV <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

MsgDBAppToLogic <span class="token operator">=</span> <span class="token punctuation">(</span>LPDBSelfMsg<span class="token punctuation">)</span><span class="token function">GetBuff</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>DBSelfMsg<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> MsgDBAppToLogic <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// MsgDB _DEV 指向的内存丢失</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>坚持下列措施可以避免内存泄漏：</strong></p> 
<ul><li>异常出口处检查内存、定时器/文件句柄/Socket/队列/信号量/GUI等资源是否全部释放</li><li>删除结构指针时，必须从底层向上层顺序删除</li><li>使用指针数组时，确保在释放数组时，数组中的每个元素指针是否已经提前被释放了</li><li>避免重复分配内存</li><li>小心使用有<code>return、break</code>语句的宏，确保前面资源已经释放</li><li>检查队列中每个成员是否释放</li></ul> 
<h3><a id="_73__1033"></a>规则 7.3 禁止引用已经释放的内存空间</h3> 
<p><em>说明：<mark>在实际编程过程中，稍不留心就会出现一个模块中释放了某个内存块，而另一模块在随后的某个时刻又使用了它。要防止这种情况发生。</mark></em></p> 
<pre><code class="prism language-c">示例：一个函数返回的局部自动存储对象的地址，导致引用已经释放的内存空间
<span class="token keyword">int</span><span class="token operator">*</span> foobar <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> local_auto <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>local_auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>坚持下列措施可以避免引用已经释放的内存空间：</strong></p> 
<ul><li>内存释放后，把指针置为<code>NULL</code>；使用内存指针前进行非空判断。</li><li>耦合度较强的模块互相调用时，一定要仔细考虑其调用关系，防止已经删除的对象被再次使用。</li><li>避免操作已发送消息的内存。</li><li>自动存储对象的地址不应赋值给其他的在第一个对象已经停止存在后仍然保持的对象（具有更大作用域的对象或者静态对象或者从一个函数返回的对象）</li></ul> 
<h3><a id="_74_1_1048"></a>规则 7.4 编程时，要防止差1错误</h3> 
<p><em>说明：<br> 1）此类错误一般是由于把<code>“&lt;=”</code>误写成<code>“&lt;”</code>或<code>“&gt;=”</code>误写成<code>“&gt;”</code>等造成的，由此引起的后果，很多情况下是很严重的，所以编程时，一定要在这些地方小心。<br> 2）当编完程序后，应对这些操作符进行彻底检查。使用变量时要注意其边界值的情况。</em></p> 
<pre><code class="prism language-c">示例：如C语言中字符型变量，有效值范围为<span class="token operator">-</span><span class="token number">128</span>到<span class="token number">127</span>。故以下表达式的计算存在一定风险。
<span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
ch <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 127为ch的边界值，再加将使ch上溢到-128，而不是128</span>
sum <span class="token operator">+</span><span class="token operator">=</span> ch<span class="token punctuation">;</span> <span class="token comment">// 故sum的结果不是328，而是72。</span>
</code></pre> 
<h3><a id="_75_ifelse_ifelseswitchdefault_1059"></a>规则 7.5 所有的if…else if结构应该由else子句结尾；switch语句必须有default分支</h3> 
<h3><a id="_71__1060"></a>建议 7.1 函数中分配的内存，在函数退出之前要释放</h3> 
<p><em>说明：<mark>有很多函数申请内存，保存在数据结构中，要在申请处加上注释，说明在何处释放。</mark></em></p> 
<h3><a id="_72_ifelseelse_1062"></a>建议 7.2 if语句尽量加上else分支，对没有else分支的语句要小心对待</h3> 
<h3><a id="_73_goto_1063"></a>建议 7.3 不要滥用goto语句</h3> 
<p><em>说明：<br> 1）<code>goto</code>语句会破坏程序的结构性，所以除非确实需要，最好不使用<code>goto</code>语句。<br> 2）可以利用<code>goto</code>语句方面退出多重循环；<br> 3）同一个函数体内部存在大量相同的逻辑但又不方便封装成函数的情况下，譬如反复执行文件操作，对文件操作失败以后的处理部分代码（譬如关闭文件句柄，释放动态申请的内存等等），一般会放在该函数体的最后部分，再需要的地方就<code>goto</code>到那里，这样代码反而变得清晰简洁。<br> 4）实际也可以封装成函数或者封装成宏，但是这么做会让代码变得没那么直接明了。</em></p> 
<pre><code class="prism language-c">示例：
<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	
	p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">goto</span> Exit0<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">strcpy</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> <span class="token string">"this is p1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">goto</span> Exit0<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">strcpy</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> <span class="token string">"this is p2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	p3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p3 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">goto</span> Exit0<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">strcpy</span><span class="token punctuation">(</span>p3<span class="token punctuation">,</span> <span class="token string">"this is p3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 Exit0<span class="token punctuation">:</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// C标准规定可以free空指针</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_74__1106"></a>建议 7.4 时刻注意表达式是否会上溢、下溢</h3> 
<pre><code class="prism language-c">示例：如下程序将造成变量下溢。
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> size <span class="token punctuation">;</span>
…
<span class="token keyword">while</span> <span class="token punctuation">(</span>size<span class="token operator">--</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 将出现下溢</span>
<span class="token punctuation">{<!-- --></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// program code</span>
<span class="token punctuation">}</span>

当size等于<span class="token number">0</span>时，再减不会小于<span class="token number">0</span>，而是<span class="token number">0xFF</span>，故程序是一个死循环。应如下修改。
<span class="token keyword">char</span> size<span class="token punctuation">;</span> <span class="token comment">// 从unsigned char 改为char</span>
…
<span class="token keyword">while</span> <span class="token punctuation">(</span>size<span class="token operator">--</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// program code</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_1124"></a>八、程序效率</h2> 
<h3><a id="_81__1125"></a>原则 8.1 在保证软件系统的正确性、简洁、可维护性、可靠性及可测试性的前提下，提高代码效率</h3> 
<p>  本章节后面所有的规则和建议，都应在不影响前述可读性等质量属性的前提下实施。<br> <em>说明：<mark>不能一味地追求代码效率，而对软件的正确、简洁、可维护性、可靠性及可测试性造成影响。</mark></em></p> 
<pre><code class="prism language-c">产品代码中经常有如下代码：
<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>异常条件<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		异常处理<span class="token punctuation">;</span>
		<span class="token keyword">return</span> ERR_CODE_1<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span>异常条件）
	<span class="token punctuation">{<!-- --></span>
		异常处理<span class="token punctuation">;</span>
		<span class="token keyword">return</span> ERR_CODE_2<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	正常处理<span class="token punctuation">;</span>
	<span class="token keyword">return</span> SUCCESS<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
这样的代码看起来很清晰，而且也避免了大量的<span class="token keyword">if</span> <span class="token keyword">else</span>嵌套。但是从性能的角度来看，应该把执行概率较大的分支放在前面处理，由于正常情况下的执行概率更大，

若首先考虑性能，应如下书写：
<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>满足条件<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		正常处理<span class="token punctuation">;</span>
		<span class="token keyword">return</span> SUCCESS<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>概率比较大的异常条件<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		异常处理<span class="token punctuation">;</span>
		<span class="token keyword">return</span> ERR_CODE_1<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		异常处理<span class="token punctuation">;</span>
		<span class="token keyword">return</span> ERR_CODE_2<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
除非证明foo函数是性能瓶颈，否则按照本规则， 应优先选用前面一种写法。
</code></pre> 
<p>1）以性能为名，使设计或代码更加复杂，从而导致可读性更差，但是并没有经过验证的性能要求（比如实际的度量数据和目标的比较结果）作为正当理由，本质上对程序没有真正的好处。无法度量的优化行为其实根本不能使程序运行得更快。<br> 2）<mark>记住：让一个正确的程序更快速，比让一个足够快的程序正确，要容易得太多。大多数时候，不要把注意力集中在如何使代码更快上，应首先关注让代码尽可能地清晰易读和更可靠。</mark></p> 
<h3><a id="_82__1172"></a>原则 8.2 通过对数据结构、程序算法的优化来提高效率</h3> 
<h3><a id="_81__1173"></a>建议 8.1 将不变条件的计算移到循环体外</h3> 
<p><em>说明：将循环中与循环无关，不是每次循环都要做的操作，移到循环外部执行。</em></p> 
<pre><code class="prism language-c">示例一：
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	sum <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>
	back_sum <span class="token operator">=</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

对于此<span class="token keyword">for</span>循环来说语句“back_Sum <span class="token operator">=</span> sum<span class="token punctuation">;</span>” 没必要每次都执行，只需要执行一次即可，因此可以改为：
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	sum <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
back_sum <span class="token operator">=</span> sum<span class="token punctuation">;</span>

示例二：
<span class="token keyword">for</span> <span class="token punctuation">(</span>_UL i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">func_calc_max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//process;</span>
<span class="token punctuation">}</span>
函数<span class="token function">func_calc_max</span><span class="token punctuation">(</span><span class="token punctuation">)</span>没必要每次都执行，只需要执行一次即可，因此可以改为：
_UL max <span class="token operator">=</span> <span class="token function">func_calc_max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>_UL i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> max<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//process;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_82__1202"></a>建议 8.2 对于多维大数组，避免来回跳跃式访问数组成员</h3> 
<pre><code class="prism language-c">示例：多维数组在内存中是从最后一维开始逐维展开连续存储的。
下面这个对二维数组访问是以SIZE_B为步长跳跃访问，到尾部后再从头（第二个成员）开始，依此类推。局部性比较差，当步长较大时，可能造成cache不命中，反复从内存加载数据到cache。应该把i和j交换。
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SIZE_B<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> SIZE_A<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		sum <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

上面这段代码，在 SIZE_B 数值较大时，效率可能会比下面的代码低<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SIZE_B<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> SIZE_A<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		sum <span class="token operator">+</span><span class="token operator">=</span>  x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<h3><a id="_83__1227"></a>建议 8.3 创建资源库，以减少分配对象的开销</h3> 
<p><em>说明：<br> 1）<mark>例如，使用线程池机制，避免线程频繁创建、销毁的系统调用；</mark><br> 2）<mark>使用内存池，对于频繁申请、释放的小块内存，一次性申请一个大块的内存，当系统申请内存时，从内存池获取小块内存，使用完毕再释放到内存池中，避免内存申请释放的频繁系统调用。</mark></em></p> 
<h3><a id="_84_inline_1231"></a>建议 8.4 将多次被调用的“小函数”改为inline函数或者宏实现</h3> 
<p><em>说明：<mark>如果编译器支持<code>inline</code>，可以采用<code>inline</code>函数。否则可以采用宏。</mark></em><br> <strong>在做这种优化的时候一定要注意下面<code>inline</code>函数的优点：</strong><br> 1）其一编译时不用展开，代码SIZE小。<br> 2）其二可以加断点，易于定位问题，例如对于引用计数加减的时候。<br> 3）其三函数编译时，编译器会做语法检查。三思而后行。</p> 
<h2><a id="_1237"></a>九、注释</h2> 
<h3><a id="_91__1238"></a>原则 9.1 优秀的代码可以自我解释，不通过注释即可轻易读懂</h3> 
<p><em>说明：<mark>优秀的代码不写注释也可以轻易读懂，注释无法把糟糕的代码变好，需要很多注释来解释的代码往往存在坏味道，需要重构。</mark></em></p> 
<pre><code class="prism language-c">示例：注释不能消除代码的坏味道：
<span class="token comment">/* 判断m是否为素数*/</span>
<span class="token comment">/* 返回值：: 是素数，: 不是素数*/</span>
<span class="token keyword">int</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">/* 发现整除，表示m不为素数，结束遍历*/</span>
	<span class="token comment">/* 遍历中没有发现整除的情况，返回*/</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> k<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">/* 遍历中没有发现整除的情况，返回*/</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
重构代码后，不需要注释：
<span class="token keyword">int</span> <span class="token function">IsPrimeNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> sqrt_of_num <span class="token operator">=</span> sqrt <span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sqrt_of_num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_92__1272"></a>原则 9.2 注释的内容要清楚、明了，含义明确，防止注释二义性</h3> 
<p><em>说明：有歧义的注释反而会导致维护者更难看懂代码，正如带两块表反而不知道准确的时间。</em></p> 
<pre><code class="prism language-c">示例：注释与代码相矛盾，注释内容也不清楚，前后矛盾。
<span class="token comment">/* 上报网管时要求故障ID与恢复ID相一致*/</span>
<span class="token comment">/* 因此在此由告警级别获知是不是恢复ID */</span>
<span class="token comment">/* 若是恢复ID则设置为ClearId，否则设置为AlarmId */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>CLEAR_ALARM_LEVEL <span class="token operator">!=</span> RcData<span class="token punctuation">.</span>level<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">SetAlarmID</span><span class="token punctuation">(</span>RcData<span class="token punctuation">.</span>AlarmId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">SetAlarmID</span><span class="token punctuation">(</span>RcData<span class="token punctuation">.</span>ClearId<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

正确做法：修改注释描述如下：
<span class="token comment">/* 网管达成协议：上报故障ID与恢复ID由告警级别确定，若是清除级别，ID设置为ClearId，否则设为AlarmId。*/</span>
</code></pre> 
<h3><a id="_93__1291"></a>原则 9.3 在代码的功能、意图层次上进行注释，即注释解释代码难以直接表达的意图，而不是重复描述代码</h3> 
<p><em>说明：<br> 1）注释的目的是解释代码的目的、功能和采用的方法，提供代码以外的信息，帮助读者理解代码，防止没必要的重复注释信息。</em><br> 2）<mark>对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释。注释不是为了名词解释（what），而是说明用途（why）</mark></p> 
<pre><code class="prism language-c">示例：如下注释纯属多余。
<span class="token operator">++</span>i<span class="token punctuation">;</span> <span class="token comment">/* increment i */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>receive_flag<span class="token punctuation">)</span> <span class="token comment">/* if receive_flag is TRUE */</span>

如下这种无价值的注释不应出现（空洞的笑话，无关紧要的注释）。
<span class="token comment">/* 时间有限，现在是:04，根本来不及想为什么，也没人能帮我说清楚*/</span>

而如下的注释则给出了有用的信息：
<span class="token comment">/* 由于xx编号网上问题，在xx情况下，芯片可能存在写错误，此芯片进行写操作后，必须进行回读校验，如果回读不正确，需要再重复写-回读操作，最多重复三次，这样可以解决绝大多数网上应用时的写错误问题*/</span>
<span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">do</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">write_reg</span><span class="token punctuation">(</span>some_addr<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	time<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">read_reg</span><span class="token punctuation">(</span>some_addr<span class="token punctuation">)</span> <span class="token operator">!=</span> value<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释，出彩的或复杂的代码块前要加注释，如：
<span class="token comment">/* Divide result by two, taking into account that x contains the carry from the add. */</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> result<span class="token operator">-&gt;</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>result<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>result<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
	x <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_91__1321"></a>规则 9.1 修改代码时，维护代码周边的所有注释，以保证注释与代码的一致性。不再有用的注释要删除</h3> 
<p><em>说明：<br> 1）不要将无用的代码留在注释中，随时可以从源代码配置库中找回代码；<br> 2）即使只是想暂时排除代码，也要留个标注，不然可能会忘记处理它。</em></p> 
<h3><a id="_92__1325"></a>规则 9.2 文件头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者姓名、工号、内容、功能说明、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说</h3> 
<p><em>说明：<br> 1）通常头文件要对功能和用法作简单说明，源文件包含了更多的实现细节或算法讨论。<br> 2）版权声明格式：Copyright © Huawei Technologies Co., Ltd. 1998-2011. All rights reserved. 1998-2011根据实际需要可以修改， 1998是文件首次创建年份，而2011是最新文件修改年份。</em></p> 
<pre><code class="prism language-c">示例：下面这段头文件的头注释比较标准，当然，并不局限于此格式，但上述信息建议要包含在内。
<span class="token comment">/*************************************************
Copyright © Huawei Technologies Co., Ltd. 1998-2011. All rights reserved.
File name:    // 文件名
Author:  ID： Version: Date: // 作者、工号、版本及完成日期
Description: // 用于详细说明此程序文件完成的主要功能，与其他模块
             // 或函数的接口，输出值、取值范围、含义及参数间的控
             // 制、顺序、独立或依赖等关系
Others:      // 其它内容的说明
History:     // 修改历史记录列表，每条修改记录应包括修改日期、修改
             // 者及修改内容简述
1. Date:
Author: ID:
Modification:
2. ...
*************************************************/</span>
</code></pre> 
<h3><a id="_93_____1347"></a>规则 9.3 函数声明处注释描述函数功能、性能及用法，包括输 入和输出参数、函数返回值、可重入的要求等；定义处详细描述函数功能和实现要点，如实现的简要步骤、实现的理由、 设计约束 等。</h3> 
<p><em>说明：重要的、复杂的函数，提供外部使用的接口函数应编写详细的注释。</em></p> 
<h3><a id="_94__1349"></a>规则 9.4 全局变量要有较详细的注释，包括对其功能、取值范围以及存取时注意事项等的说明</h3> 
<pre><code class="prism language-c"><span class="token comment">/* The ErrorCode when SCCP translate */</span>
<span class="token comment">/* Global Title failure, as follows */</span> <span class="token comment">/* 变量作用、含义*/</span>
<span class="token comment">/* 0 －SUCCESS 1 －GT Table error */</span>
<span class="token comment">/* 2 －GT error Others －no use */</span> <span class="token comment">/* 变量取值范围*/</span>
<span class="token comment">/* only function SCCPTranslate() in */</span>
<span class="token comment">/* this modual can modify it, and other */</span>
<span class="token comment">/* module can visit it through call */</span>
<span class="token comment">/* the function GetGTTransErrorCode() */</span> <span class="token comment">/* 使用方法*/</span>
BYTE g_GTTranErrorCode<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_95____1361"></a>规则 9.5 注释应放在其代码上方相邻位置或右方，不可放在下面 。 如放于上方则需与其上面的代码用空行隔开，且与下方代码缩进相同</h3> 
<pre><code class="prism language-c">示例：
<span class="token comment">/* active statistic task number */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> MAX_ACT_TASK_NUMBER 1000</span>

<span class="token macro property">#<span class="token directive keyword">define</span> MAX_ACT_TASK_NUMBER 1000 </span><span class="token comment">/* active statistic task number */</span>
可按如下形式说明枚举<span class="token operator">/</span>数据<span class="token operator">/</span>联合结构。
<span class="token comment">/* sccp interface with sccp user primitive message name */</span>
<span class="token keyword">enum</span> SCCP_USER_PRIMITIVE
<span class="token punctuation">{<!-- --></span>
	N_UNITDATA_IND<span class="token punctuation">,</span> <span class="token comment">/* sccp notify sccp user unit data come */</span>
	N_NOTICE_IND<span class="token punctuation">,</span>   <span class="token comment">/* sccp notify user the No.7 network can not transmission this message */</span>
	N_UNITDATA_REQ<span class="token punctuation">,</span> <span class="token comment">/* sccp user's unit data transmission request*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_96__switch__case__case__case__case__case__1377"></a>规则 9.6 对于 switch 语句下的 case 语句，如果因为特殊情况需要处理完一个 case 后进入下一个 case 处理，必须在该 case 语句处理完、下一个 case 语句前加上明确的注释</h3> 
<p><em>说明：这样比较清楚程序编写者的意图，有效防止无故遗漏<code>break</code>语句。</em></p> 
<pre><code class="prism language-c">示例：
<span class="token keyword">case</span> CMD_FWD<span class="token punctuation">:</span>
	<span class="token function">ProcessFwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/* now jump into case CMD_A */</span>
<span class="token keyword">case</span> CMD_A<span class="token punctuation">:</span>
	<span class="token function">ProcessA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token comment">//对于中间无处理的连续case，已能较清晰说明意图，不强制注释。</span>
	<span class="token keyword">switch</span> <span class="token punctuation">(</span>cmd_flag<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">case</span> CMD_A<span class="token punctuation">:</span>
	<span class="token keyword">case</span> CMD_B<span class="token punctuation">:</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">ProcessCMD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	……
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_97__1399"></a>规则 9.7 避免在注释中使用缩写，除非是业界通用或子系统内标准化的缩写</h3> 
<h3><a id="_98__1400"></a>规则 9.8 同一产品或项目组统一注释风格</h3> 
<h3><a id="_91__1401"></a>建议 9.1 避免在一行代码或表达式的中间插入注释。</h3> 
<p><em>说明：除非必要，不应在代码或表达中间插入注释，否则容易使代码可理解性变差。</em></p> 
<h3><a id="_92__1403"></a>建议 9.2 注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。对于有外籍员工的，由产品确定注释语言</h3> 
<p><em>说明：注释语言不统一，影响程序易读性和外观排版，出于对维护人员的考虑，建议使用中文。</em></p> 
<h3><a id="_93__1405"></a>建议 9.3 文件头、函数头、全局常量变量、类型定义的注释格式采用工具可识别的格式</h3> 
<p><em>说明：采用工具可识别的注释格式，例如doxygen格式，方便工具导出注释形成帮助文档。</em></p> 
<pre><code class="prism language-c">以doxygen格式为例，文件头，函数和全部变量的注释的示例如下：

文件头注释：
<span class="token comment">/**
* @file （本文件的文件名eg：mib.h）
* @brief （本文件实现的功能的简述）
* @version 1.1 （版本声明）
* @author （作者，eg：张三）
* @date （文件创建日期，eg：2010年12月15日）
*/</span>

函数头注释：
<span class="token comment">/**
*@ Description:向接收方发送SET请求
* @param req - 指向整个SNMP SET 请求报文.
* @param ind - 需要处理的subrequest 索引.
* @return 成功：SNMP_ERROR_SUCCESS，失败：SNMP_ERROR_COMITFAIL
*/</span>
Int <span class="token function">commit_set_request</span><span class="token punctuation">(</span>Request <span class="token operator">*</span>req<span class="token punctuation">,</span> <span class="token keyword">int</span> ind<span class="token punctuation">)</span><span class="token punctuation">;</span>

全局变量注释：
<span class="token comment">/** 模拟的Agent MIB */</span>
agentpp_simulation_mib <span class="token operator">*</span> g_agtSimMib<span class="token punctuation">;</span>
函数头注释建议写到声明处。并非所有函数都必须写注释，建议针对这样的函数写注释：重要的、复杂的函数，提供外部使用的接口函数。
</code></pre> 
<h2><a id="_1433"></a>十、排版与格式</h2> 
<h3><a id="_101_4_1434"></a>规则 10.1 程序块采用缩进风格编写，每级缩进为4个空格</h3> 
<p><em>说明：<br> 1）当前各种编辑器/IDE都支持TAB键自动转空格输入，需要打开相关功能并设置相关功能。<br> 2）编辑器/IDE如果有显示TAB的功能也应该打开，方便及时纠正输入错误。<br> 3）IDE向导生成的代码可以不用修改。<br> 4）<mark>宏定义、编译开关、条件预处理语句可以顶格（或使用自定义的排版方案，但产品/模块内必须保持一致）。</mark></em></p> 
<h3><a id="_102__1440"></a>规则 10.2 相对独立的程序块之间、变量说明之后必须加空行</h3> 
<pre><code class="prism language-c">示例：如下例子不符合规范。
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">valid_ni</span><span class="token punctuation">(</span>ni<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// program code</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
repssn_ind <span class="token operator">=</span> ssn_data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>repssn_index<span class="token punctuation">;</span>
repssn_ni <span class="token operator">=</span> ssn_data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>ni<span class="token punctuation">;</span>

应如下书写：
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">valid_ni</span><span class="token punctuation">(</span>ni<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// program code</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

repssn_ind <span class="token operator">=</span> ssn_data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>repssn_index<span class="token punctuation">;</span>
repssn_ni <span class="token operator">=</span> ssn_data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>ni<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_103__1461"></a>规则 10.3 一条语句不能过长，如不能拆分需要分行写。一行到底多少字符换行比较合适，产品可以自行确定</h3> 
<p><em>说明：<br> 1）对于目前大多数的PC来说，132比较合适（80/132是VTY常见的行宽值）；<br> 2）对于新PC宽屏显示器较多的产品来说，可以设置更大的值。</em><br> <strong>换行时有如下建议：</strong></p> 
<ul><li>换行时要增加一级缩进，使代码可读性更好；</li><li>低优先级操作符处划分新行；换行时操作符应该也放下来，放在新行首；</li><li>换行时建议一个完整的语句放在一行，不要根据字符数断行</li></ul> 
<pre><code class="prism language-c">示例：
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>temp_flag_var <span class="token operator">==</span> TEST_FLAG<span class="token punctuation">)</span>
<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>temp_counter_var <span class="token operator">-</span> TEST_COUNT_BEGIN<span class="token punctuation">)</span> <span class="token operator">%</span> TEST_COUNT_MODULE<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> TEST_COUNT_THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token comment">// process code</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_104__1478"></a>规则 10.4 多个短语句（包括赋值语句）不允许写在同一行内，即一行只写一条语句</h3> 
<pre><code class="prism language-c">示例：
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token keyword">int</span> b<span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//不好的排版</span>

较好的排版
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b<span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_105__if__for__do__while__case__switch__default__1487"></a>规则 10.5 if 、 for 、 do 、 while 、 case 、 switch 、 default 等语句独占一行</h3> 
<p><em>说明：执行语句必须用缩进风格写，属于<code>if、for、do、while、case、switch、default</code>等下一个缩进级别</em><br> <strong>一般写<code>if、for、do、while</code>等语句都会有成对出现的<code>„{}‟</code>，对此有如下建议可以参考：</strong></p> 
<ul><li><code>if、for、do、while</code>等语句后的执行语句建议增加成对的<code>„{}‟</code>；</li><li>如果<code>if/else</code>配套语句中有一个分支有<code>„{}‟</code>，那么令一个分支即使一行代码也建议增加<code>„{}‟</code>；</li><li>添加<code>„{‟</code>的位置可以在<code>if</code>等语句后，也可以独立占下一行；独立占下一行时，可以和<code>if</code>在一个缩进级别，也可以在下一个缩进级别；但是如果<code>if</code>语句很长，或者已经有换行，建议<code>„{‟</code>使用独占一行的写法。</li></ul> 
<h3><a id="_106____1494"></a>规则 10.6 在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格； 进行非对等操作时，如果 是关系密切的立即操作符（如－&gt;），后不应加空格</h3> 
<p><em>说明：<br> 1）采用这种松散方式编写代码的目的是使代码更加清晰。<br> 2）在已经非常清晰的语句中没有必要再留空格，如括号内侧(即左括号后面和右括号前面)不需要加空格，多重括号间不必加空格，因为在C语言中括号已经是最清晰的标志了。<br> 3）在长语句中，如果需要加的空格非常多，那么应该保持整体清晰，而在局部不加空格。给操作符留空格时不要连续留两个以上空格。</em></p> 
<pre><code class="prism language-c">示例：
<span class="token number">1</span><span class="token punctuation">)</span> 逗号、分号只在后面加空格
	<span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
<span class="token number">2</span><span class="token punctuation">)</span> 比较操作符<span class="token punctuation">,</span> 赋值操作符<span class="token string">"="</span>、 <span class="token string">"+="</span>，算术操作符<span class="token string">"+"</span>、<span class="token string">"%"</span>，逻辑操作符<span class="token string">"&amp;&amp;"</span>、<span class="token string">"&amp;"</span>，位域操作符<span class="token string">"&lt;&lt;"</span>、<span class="token string">"^"</span>等双目操作符的前后加空格。
	<span class="token keyword">if</span> <span class="token punctuation">(</span>current_time <span class="token operator">&gt;=</span> MAX_TIME_VALUE<span class="token punctuation">)</span>
	a <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
	a <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	a <span class="token operator">=</span> b <span class="token operator">^</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"!"</span>、<span class="token string">"~"</span>、<span class="token string">"++"</span>、<span class="token string">"--"</span>、<span class="token string">"&amp;"</span>（地址操作符）等单目操作符前后不加空格。
	<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>         <span class="token comment">// 内容操作"*"与内容之间</span>
	flag <span class="token operator">=</span> <span class="token operator">!</span>is_empty<span class="token punctuation">;</span> <span class="token comment">// 非操作"!"与内容之间</span>
	p <span class="token operator">=</span> <span class="token operator">&amp;</span>mem<span class="token punctuation">;</span>         <span class="token comment">// 地址操作"&amp;" 与内容之间</span>
	i<span class="token operator">++</span><span class="token punctuation">;</span>              <span class="token comment">// "++","--"与内容之间</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"-&gt;"</span>、<span class="token string">"."</span>前后不加空格。
	p<span class="token operator">-&gt;</span>id <span class="token operator">=</span> pid<span class="token punctuation">;</span> <span class="token comment">// "-&gt;"指针前后不加空格</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">if</span>、<span class="token keyword">for</span>、<span class="token keyword">while</span>、<span class="token keyword">switch</span>等与后面的括号间应加空格，使<span class="token keyword">if</span>等关键字更为突出、明显。
	<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;=</span> b <span class="token operator">&amp;&amp;</span> c <span class="token operator">&gt;</span> d<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="_101______1518"></a>建议 10.1 注释符（包括„ /*‟„ //‟„ */‟ ）与注释内容之间要用一个空格进行分隔</h3> 
<p><em>说明：<br> 1）这样可以使注释的内容部分更清晰。</em><br> 2）现在很多工具都可以批量生成、删除<code>'//'</code>注释，这样有空格也比较方便统一处理。</p> 
<h3><a id="_102__1522"></a>建议 10.2 源程序中关系较为紧密的代码应尽可能相邻</h3> 
<h2><a id="_1523"></a>十一、表达式</h2> 
<h3><a id="_111___1524"></a>规则 11.1 表达式的值在标准所允许的任何运算次序下都应该是相同的</h3> 
<p><em>说明：<br> 1）<mark>除了少数操作符（函数调用操作符 <code>( )</code>、<code>&amp;&amp;</code>、<code>| |</code>、<code>? :</code>和 , （逗号）） 之外，子表达式所依据的运算次序是未指定的并会随时更改。</mark><br> 2）<mark>注意，运算次序的问题不能使用括号来解决，因为这不是优先级的问题。</mark></em></p> 
<pre><code class="prism language-c">将复合表达式分开写成若干个简单表达式，明确表达式的运算次序，就可以有效消除非预期副作用。
<span class="token number">1</span>）自增或自减操作符
示例：
	x <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> i<span class="token operator">++</span><span class="token punctuation">;</span> 
	b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> 的运算是先于还是后于 i <span class="token operator">++</span> 的运算，表达式会产生不同的结果，把自增运算做为单独的语句，
可以避免这个问题。
	x <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> i<span class="token punctuation">;</span> 
	i <span class="token operator">++</span><span class="token punctuation">;</span>
	
<span class="token number">2</span>）函数参数
说明：函数参数通常从右到左压栈，但函数参数的计算次序不一定与压栈次序相同。
示例：
	x <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span> i<span class="token operator">++</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
应该修改代码明确先计算第一个参数：
	i<span class="token operator">++</span><span class="token punctuation">;</span>
	x <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token number">3</span>）函数指针
说明：函数参数和函数自身地址的计算次序未定义。
示例：
	p<span class="token operator">-&gt;</span><span class="token function">task_start_fn</span><span class="token punctuation">(</span>p<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
求函数地址p与计算p<span class="token operator">++</span>无关，结果是任意值。必须单独计算p<span class="token operator">++</span>：
	p<span class="token operator">-&gt;</span><span class="token function">task_start_fn</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token operator">++</span><span class="token punctuation">;</span>
	
<span class="token number">4</span>）函数调用
示例：
	<span class="token keyword">int</span> g_var <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		g_var <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> g_var<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">int</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		g_var <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> g_var<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	编译器可能先计算<span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，也可能先计算<span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，由于x的结果依赖于函数<span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的计算次序（<span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>被调用时修改和使用了同一个全局变量），则上面的代码存在问题。
	
应该修改代码明确fun1<span class="token operator">/</span> fun2的计算次序：
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">5</span>）嵌套赋值语句
说明：表达式中嵌套的赋值可以产生附加的副作用。不给这种能导致对运算次序的依赖提供任何机会的最好做法是，不要在表达式中嵌套赋值语句。
示例：
	x <span class="token operator">=</span> y <span class="token operator">=</span> y <span class="token operator">=</span> z <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>
	x <span class="token operator">=</span> y <span class="token operator">=</span> y<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token number">6</span>）<span class="token keyword">volatile</span>访问
说明：限定符<span class="token keyword">volatile</span>表示可能被其它途径更改的变量，例如硬件自动更新的寄存器。编译器不会优化对<span class="token keyword">volatile</span>变量的读取。
示例：下面的写法可能无法实现作者预期的功能：
	<span class="token comment">/* volume变量被定义为volatile类型*/</span>
	UINT16 x <span class="token operator">=</span> <span class="token punctuation">(</span> volume <span class="token operator">&lt;&lt;</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token operator">|</span> volume<span class="token punctuation">;</span> <span class="token comment">/* 在计算了其中一个子表达式的时候，volume的值可能已
经被其它程序或硬件改变，导致另外一个子表达式的计算结果非预期，可能无法实现作者预期的功能
*/</span>
</code></pre> 
<h3><a id="_111___1589"></a>建议 11.1 函数调用不要作为另一个函 数的参数使用，否则对于代码的调试、阅读都不利</h3> 
<p><em>说明：如下代码不合理，仅用于说明当函数作为参数时，<mark>由于参数压栈次数不是代码可以控制的，可能造成未知的输出</mark>：</em></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> g_var<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	g_var <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> g_var<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	g_var <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> g_var<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	g_var <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"func1: %d, func2: %d\n"</span><span class="token punctuation">,</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g_var <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"func2: %d, func1: %d\n"</span><span class="token punctuation">,</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
上面的代码，使用断点调试起来也比较麻烦，阅读起来也不舒服，所以不要为了节约代码行，而写这种代码。
</code></pre> 
<h3><a id="_112__if__1615"></a>建议 11.2 赋值语句不要写在 if 等语句中，或者作为函数的参数使用</h3> 
<p><em>说明：<mark>因为if语句中，会根据条件依次判断，如果前一个条件已经可以判定整个条件，则后续条件语句不会再运行，所以可能导致期望的部分赋值没有得到运行。</mark></em></p> 
<pre><code class="prism language-c">示例：
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b<span class="token punctuation">;</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a: %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b: %d\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
作用函数参数来使用，参数的压栈顺序不同可能导致结果未知。

看如下代码，能否一眼看出输出结果会是什么吗？好理解吗？
<span class="token keyword">int</span> g_var<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	g_var <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"set 1st: %d, add 2nd: %d\n"</span><span class="token punctuation">,</span> g_var <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> g_var<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	g_var <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"add 1st: %d, set 2nd: %d\n"</span><span class="token punctuation">,</span> g_var<span class="token operator">++</span><span class="token punctuation">,</span> g_var <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_113__1643"></a>建议 11.3 用括号明确表达式的操作顺序，避免过分依赖默认优先级</h3> 
<p><em>说明：<br> 1）使用括号强调所使用的操作符，防止因默认的优先级与设计思想不符而导致程序出错；<br> 2）同时使得代码更为清晰可读，然而过多的括号会分散代码使其降低了可读性。</em></p> 
<pre><code class="prism language-c">下面是如何使用括号的建议<span class="token punctuation">:</span>
<span class="token number">1.</span> 一元操作符，不需要使用括号
x <span class="token operator">=</span> <span class="token operator">~</span>a<span class="token punctuation">;</span> <span class="token comment">/* 一元操作符，不需要括号*/</span>
x <span class="token operator">=</span> <span class="token operator">-</span>a<span class="token punctuation">;</span> <span class="token comment">/* 一元操作符，不需要括号*/</span>

<span class="token number">2.</span> 二元以上操作符，如果涉及多种操作符，则应该使用括号
x <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>                 <span class="token comment">/* 操作符相同，不需要括号*/</span>
x <span class="token operator">=</span> f <span class="token punctuation">(</span> a <span class="token operator">+</span> b<span class="token punctuation">,</span> c <span class="token punctuation">)</span>             <span class="token comment">/* 操作符相同，不需要括号*/</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;&amp;</span> b <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">)</span>               <span class="token comment">/* 操作符相同，不需要括号*/</span>
x <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> c <span class="token operator">+</span> d<span class="token punctuation">;</span>           <span class="token comment">/* 操作符不同，需要括号*/</span>
x <span class="token operator">=</span> <span class="token punctuation">(</span> a <span class="token operator">==</span> b <span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token punctuation">:</span> <span class="token punctuation">(</span> a –b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 操作符不同，需要括号*/</span>

<span class="token number">3</span> <span class="token punctuation">.</span>即使所有操作符都是相同的，如果涉及类型转换或者量级提升，也应该使用括号控制计算的次序。
以下代码将<span class="token number">3</span>个浮点数相加：
<span class="token comment">/* 除了逗号(,)，逻辑与(&amp;&amp;)，逻辑或(||)之外，C标准没有规定同级操作符是从左还是从右开始计算，
以上表达式存在种计算次序：f4 = (f1 + f2) + f3 或f4 = f1 + (f2 + f3)，浮点数计算过程中可能四舍五入，量级提升，
计算次序的不同会导致f4的结果不同，以上表达式在不同编译器上的计算结果可能不一样，
建议增加括号明确计算顺序*/</span>
f4 <span class="token operator">=</span> f1 <span class="token operator">+</span> f2 <span class="token operator">+</span> f3<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_114__1668"></a>建议 11.4 赋值操作符不能使用在产生布尔值的表达式上</h3> 
<p><em>说明：<br> 1）如果布尔值表达式需要赋值操作，那么赋值操作必须在操作数之外分别进行。<br> 2）这可以帮助避免<code>=</code>和<code>==</code>的混淆，帮助我们静态地检查错误。</em></p> 
<pre><code class="prism language-c">示例：
x <span class="token operator">=</span> y<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	foo <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

不能写成：
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span> x <span class="token operator">=</span> y <span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	foo <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
或者更坏的
<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	foo <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_1691"></a>十二、代码编辑、编译</h2> 
<h3><a id="_121__1692"></a>规则 12.1 使用编译器的最高告警级别，理解所有的告警，通过修改代码而不是降低告警级别来消除所有告警</h3> 
<p><em>说明：编译器是你的朋友，如果它发出某个告警，这经常说明你的代码中存在潜在的问题。</em></p> 
<h3><a id="_122__1694"></a>规则 12.2 在产品软件（项目组）中，要统一编译开关、静态检查选项以及相应告警清除策略</h3> 
<p><em>说明：<br> 1）如果必须禁用某个告警，应尽可能单独局部禁用，并且编写一个清晰的注释，说明为什么屏蔽。<br> 2）某些语句经编译/静态检查产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。</em></p> 
<h3><a id="_123__PC__Lint__1698"></a>规则 12.3 本地构建工具（如 PC- - Lint ）的配置应该和持续集成的一致</h3> 
<p><em>说明：两者一致，避免经过本地构建的代码在持续集成上构建失败。</em></p> 
<h3><a id="_124___1700"></a>规则 12.4 使用版本控制（配置管理）系统，及时签入通过本地构建的代码，确保签入的代码不会 影响构建成功</h3> 
<p><em>说明：及时签入代码降低集成难度。</em></p> 
<h3><a id="_121__1702"></a>建议 12.1 要小心地使用编辑器提供的块拷贝功能编程。</h3> 
<h2><a id="_1703"></a>十三、可测性</h2> 
<h3><a id="_131___1704"></a>原则 13.1 模块划分清晰，接口明确，耦合性小，有明确输入和输出，否则单元测试实施困难</h3> 
<p><em>说明：单元测试实施依赖于：</em></p> 
<ul><li>模块间的接口定义清楚、完整、稳定；</li><li>模块功能的有明确的验收条件（包括：预置条件、输入和预期结果）；</li><li>模块内部的关键状态和关键数据可以查询，可以修改；</li><li>模块原子功能的入口唯一；</li><li>模块原子功能的出口唯一；</li><li>依赖集中处理：和模块相关的全局变量尽量的少，或者采用某种封装形式。</li></ul> 
<h3><a id="_131___1712"></a>规则 13.1 在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明</h3> 
<p><em>说明：<br> 1）本规则是针对项目组或产品组的。<br> 2）<mark>代码至始至终只有一份代码，不存在开发版本和测试版本的说法。</mark> 测试与最终发行的版本是通过编译开关的不同来实现的。并且编译开关要规范统一。<br> 3）<mark>统一使用编译开关来实现测试版本与发行版本的区别，一般不允许再定义其它新的编译开关。</mark></em></p> 
<h3><a id="_13_2___1717"></a>规则 13. 2 在同一项目组或产品组内，调测打印的日志要有统一的规定</h3> 
<p><em>说明：统一的调测日志记录便于集成测试，具体包括：</em></p> 
<ul><li>统一的日志分类以及日志级别；</li><li>通过命令行、网管等方式可以配置和改变日志输出的内容和格式；</li><li>在关键分支要记录日志，日志建议不要记录在原子函数中，否则难以定位；</li><li>调试日志记录的内容需要包括文件名/模块名、代码行号、函数名、被调用函数名、错误码、错误发生的环境等。</li></ul> 
<h3><a id="_133___1723"></a>规则 13.3 使用断言记录内部假设</h3> 
<p><em>说明：<br> 1）断言是对某种内部模块的假设条件进行检查，如果假设不成立，说明存在编程、设计错误。<br> 2）断言可以对在系统中隐藏很深，用其它手段极难发现的问题进行定位，从而缩短软件问题定位时间，提高系统的可测性。</em></p> 
<h3><a id="_134____1727"></a>规则 13.4 不能用断言来检查运行 时错误</h3> 
<p><em>说明：<br> 1）断言是用来处理内部编程或设计是否符合假设；不能处理对于可能会发生的且必须处理的情况要写防错程序，而不是断言。<br> 2）如某模块收到其它模块或链路上的消息后，要对消息的合理性进行检查，此过程为正常的错误检查，不能用断言来实现。<br> 3）断言的使用是有条件的。<br> 4）断言只能用于程序内部逻辑的条件判断，而不能用于对外部输入数据的判断,因为在网上实际运行时，是完全有可能出现外部输入非法数据的情况。</em></p> 
<h3><a id="_131___1733"></a>建议 13.1 为单元测试和系统故障注入测试准备好方法和通道</h3> 
<h2><a id="_1734"></a>十四、安全性</h2> 
<p>  <mark>代码的安全漏洞大都是由代码缺陷导致，但不是所有代码缺陷都有安全风险。理解安全漏洞产生的原理和如何进行安全编码是减少软件安全问题最直接有效的办法。</mark></p> 
<h4><a id="_141__1736"></a>原则 14.1 对用户输入进行检查</h4> 
<p><em>说明：不能假定用户输入都是合法的，因为难以保证不存在恶意用户，即使是合法用户也可能由于误用误操作而产生非法输入。</em></p> 
<p><strong>用户输入通常需要经过检验以保证安全，特别是以下场景：</strong></p> 
<ul><li><mark>用户输入作为循环条件</mark></li><li><mark>用户输入作为数组下标</mark></li><li><mark>用户输入作为内存分配的尺寸参数</mark></li><li><mark>用户输入作为格式化字符串</mark></li><li><mark>用户输入作为业务数据（如作为命令执行参数、拼装sql语句、以特定格式持久化）</mark></li></ul> 
<p>   这些情况下如果不对用户数据做合法性验证，很可能导致DOS、内存越界、格式化字符串漏洞、命令注入、SQL注入、缓冲区溢出、数据破坏等问题。</p> 
<p><strong>可采取以下措施对用户输入检查：</strong></p> 
<ul><li><mark>用户输入作为数值的，做数值范围检查</mark></li><li><mark>用户输入是字符串的，检查字符串长度</mark></li><li><mark>用户输入作为格式化字符串的，检查关键字<code>“%”</code></mark></li><li><mark>用户输入作为业务数据，对关键字进行检查、转义</mark></li></ul> 
<h3><a id="141__1754"></a>14.1 字符串操作安全</h3> 
<h4><a id="_141__NULL__1755"></a>规则 14.1 确保所有字符串是以 NULL 结束</h4> 
<p><em>说明：<br> 1）C语言中<code>‟\0‟</code>作为字符串的结束符，即<code>NULL</code>结束符。标准字符串处理函数（如<code>strcpy()、strlen()</code>）依赖<code>NULL</code>结束符来确定字符串的长度。<br> 2）<mark>没有正确使用NULL结束字符串会导致缓冲区溢出和其它未定义的行为。</mark></em><br>   为了避免缓冲区溢出，常常会用相对安全的限制字符数量的字符串操作函数代替一些危险函数。如：</p> 
<ul><li>用<code>strncpy()</code>代替<code>strcpy()</code></li><li>用<code>strncat()</code>代替<code>strcat()</code></li><li>用<code>snprintf()</code>代替<code>sprintf()</code></li><li>用<code>fgets()</code>代替<code>gets()</code></li></ul> 
<p>  这些函数会截断超出指定限制的字符串，但是要注意它们并不能保证目标字符串总是以<code>NUL</code>L结尾。如果源字符串的前n个字符中不存在<code>NULL</code>字符，目标字符串就不是以<code>NULL</code>结尾。</p> 
<pre><code class="prism language-c">示例：
<span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">strncpy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">"0123456789abcdef"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
上述代码存在安全风险：在调用<span class="token function">strncpy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>后，字符数组a中的字符串是没有<span class="token constant">NULL</span>结束符的，也没有空间存放<span class="token constant">NULL</span>结束符。

正确写法：截断字符串，保证字符串以<span class="token constant">NULL</span>结束。
<span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">strncpy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">"0123456789abcdef"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_142___1777"></a>规则 14.2 不要将边界不明确的字符串写到固定长度的数组中</h4> 
<p><em>说明：<mark>边界不明确的字符串（如来自<code>gets()、getenv()、scanf()</code>的字符串），长度可能大于目标数组长度，直接拷贝到固定长度的数组中容易导致缓冲区溢出。</mark></em></p> 
<pre><code class="prism language-c">示例：
<span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>editor <span class="token operator">=</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">"EDITOR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>editor <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">strcpy</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> editor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
上述代码读取环境变量<span class="token string">"EDITOR"</span>的值，如果成功则拷贝到缓冲区buff中。而从环境变量获取到的字符串长度是不确定的，把它们拷贝到固定长度的数组中很可能导致缓冲区溢出。

正确写法：计算字符串的实际长度，使用malloc分配指定长度的内存
<span class="token keyword">char</span> <span class="token operator">*</span>buff<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>editor <span class="token operator">=</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">"EDITOR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>editor <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	buff <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>editor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>buff <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">strcpy</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> editor<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="142__1802"></a>14.2 整数安全</h3> 
<p>C99标准定义了整型提升（integer promotions）、整型转换级别（integer conversion rank）以及普通算术转换（usual arithmetic conversions）的整型操作。不过这些操作实际上也带来了安全风险。</p> 
<h4><a id="_143__1804"></a>规则 14.3 避免整数溢出</h4> 
<p><em>说明：<br> 1）当一个整数被增加超过其最大值时会发生整数上溢，被减小小于其最小值时会发生整数下溢。<br> 2）带符号和无符号的数都有可能发生溢出。</em></p> 
<pre><code class="prism language-c">示例<span class="token number">1</span>：有符号和无符号整数的上溢和下溢
<span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span>

i <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span> <span class="token comment">// 2,147,483,647</span>
i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// i=-2,147,483,648</span>

j <span class="token operator">=</span> UINT_MAX<span class="token punctuation">;</span> <span class="token comment">// 4,294,967,295;</span>
j<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"j = %u\n"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// j = 0</span>

i <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span> <span class="token comment">// -2,147,483,648;</span>
i<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// i = 2,147,483,647</span>

j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
j<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"j = %u\n"</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// j = 4,294,967,295</span>

示例<span class="token number">2</span>：整数下溢导致报文长度异常
<span class="token comment">/* 报文长度减去FSM头的长度*/</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> length<span class="token punctuation">;</span>

length <span class="token operator">-</span><span class="token operator">=</span> FSM_HDRLEN <span class="token punctuation">;</span>
处理过短报文时，length的长度可能小于FSM_HDRLEN，减法的结果小于。由于length是无符号数，结果返回了一个很大的数。

正确写法：增加长度检查
<span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">&lt;</span> FSM_HDRLEN <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> VOS_ERROR<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
length <span class="token operator">-</span><span class="token operator">=</span> FSM_HDRLEN <span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_144__1843"></a>规则 14.4 避免符号错误</h4> 
<p><em>说明：<br> 1）有时从带符号整型转换到无符号整型会发生符号错误，符号错误并不丢失数据，但数据失去了原来的含义。<br> 2）带符号整型转换到无符号整型，最高位（high-order bit）会丧失其作为符号位的功能。<br> 3）如果该带符号整数的值非负，那么转换后值不变；<br> 4）如果该带符号整数的值为负，那么转换后的结果通常是一个非常大的正数。</em></p> 
<pre><code class="prism language-c">示例：符号错误绕过长度检查
<span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 10</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span>  length<span class="token punctuation">;</span>
	<span class="token keyword">char</span>  buf<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	length <span class="token operator">=</span> <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果 atoi 返回 的长度 为负数</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span> length  <span class="token operator">&lt;</span> BUF_SIZE<span class="token punctuation">)</span> <span class="token comment">//  len 为负数， 长度检查 无效</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">memcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  length <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> <span class="token operator">*</span>  带符号的 len 被转换为 size_t 类型的无符号整数，负值
	被解释为一个极大的正整数。 <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 调用时引发 buf f 缓冲区溢出 <span class="token operator">*</span><span class="token operator">/</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Data copied\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Too many data\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

正确写法<span class="token number">1</span>：将len声明为无符号整型
<span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 10</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> length<span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	length <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">&lt;</span> BUF_SIZE<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">memcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Data copied\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Too much data\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

正确写法<span class="token number">2</span>：增加对len的更有效的范围校验
<span class="token macro property">#<span class="token directive keyword">define</span> BUF_SIZE 10</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> length<span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	length <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>length <span class="token operator">&lt;</span> BUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">memcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Data copied\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Too much data\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_145__1930"></a>规则 14.5 避免截断错误</h4> 
<p><em>说明：<br> 1）将一个较大整型转换为较小整型，并且该数的原值超出较小类型的表示范围，就会发生截断错误，原值的低位被保留而高位被丢弃。截断错误会引起数据丢失。<br> 2）<mark>使用截断后的变量进行内存操作，很可能会引发问题。</mark></em></p> 
<pre><code class="prism language-c">示例：
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> total <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> 
	<span class="token keyword">char</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">strcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">strcat</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
说明：
<span class="token number">1</span>）示例代码中total被定义为<span class="token keyword">unsigned</span> <span class="token keyword">short</span>，相对于<span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的返回值类型size_t（通常为unsignedlong）太小。
<span class="token number">2</span>）如果攻击者提供的两个入参长度分别为<span class="token number">65500</span>和<span class="token number">36</span>，<span class="token keyword">unsigned</span> <span class="token keyword">long</span>的<span class="token number">65500</span><span class="token operator">+</span><span class="token number">36</span><span class="token operator">+</span><span class="token number">1</span>会被取模截断，total的最终值是（<span class="token number">65500</span><span class="token operator">+</span><span class="token number">36</span><span class="token operator">+</span><span class="token number">1</span>）<span class="token operator">%</span><span class="token number">65536</span> <span class="token operator">=</span> <span class="token number">1</span>。<span class="token number">3</span>）<span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>只为buff分配了<span class="token number">1</span>字节空间，为<span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>和<span class="token function">strcat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的调用创造了缓冲区溢出的条件。

正确写法：将涉及到计算的变量声明为统一的类型， 并检查计算结果。
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t total <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>total <span class="token operator">&lt;=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>total <span class="token operator">&lt;=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">/* handle error */</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">char</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">strcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">strcat</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="143__1971"></a>14.3 格式化输出安全</h3> 
<h4><a id="_146__1972"></a>规则 14.6 确保格式字符和参数匹配</h4> 
<p><em>说明：<br> 1）使用格式化字符串应该小心，<mark>确保格式字符和参数之间的匹配，保留数量和数据类型。</mark><br> 2）格式字符和参数之间的不匹配会导致未定义的行为。<br> 3）大多数情况下，<mark>不正确的格式化字符串会导致程序异常终止。</mark></em></p> 
<pre><code class="prism language-c">示例：
<span class="token keyword">char</span> <span class="token operator">*</span>error_msg <span class="token operator">=</span> <span class="token string">"Resource not available to user."</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> error_type <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

<span class="token comment">/* 格式字符和参数的类型不匹配*/</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error (type %s): %d\n"</span><span class="token punctuation">,</span> error_type<span class="token punctuation">,</span> error_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 格式字符和参数的数量不匹配*/</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error: %s\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>  格式化字符串在编码时会大量使用，容易copy-paste省事，这就容易出现不匹配的错误。</p> 
<h4><a id="_147__1988"></a>规则 14.7 避免将用户输入作为格式化字符串的一部分或者全部</h4> 
<p><em>说明：<br> 1）<mark>调用格式化I/O函数时，不要直接或者间接将用户输入作为格式化字符串的一部分或者全部。</mark><br> 2）<mark>攻击者对一个格式化字符串拥有部分或完全控制，存在以下风险：进程崩溃、查看栈的内容、改写内存、甚至执行任意代码。</mark></em></p> 
<pre><code class="prism language-c">示例<span class="token number">1</span>：
<span class="token keyword">char</span> input<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">/* handle error */</span>
<span class="token punctuation">}</span>

input<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
说明：
<span class="token number">1</span>）上述代码input直接来自用户输入，并作为格式化字符串直接传递给<span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>。
<span class="token number">2</span>）当用户输入的是“<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s”，就可能触发无效指针或未映射的地址读取。
<span class="token number">3</span>）格式字符<span class="token operator">%</span>s显示栈上相应参数所指定的地址的内存。
<span class="token number">4</span>）这里input被当成格式化字符串，而没有提供参数，因此<span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>读取栈中任意内存位置，指导格式字符耗尽或者遇到一个无效指针或未映射地址为止。

正确做法：给<span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>传两个参数，第一个参数为”<span class="token operator">%</span>s”，目的是将格式化字符串确定下来；第二个参数为用户输入input。
<span class="token keyword">char</span> input<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">/* handle error */</span>
<span class="token punctuation">}</span>

input<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>s”<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">;</span>

示例<span class="token number">2</span>：
<span class="token keyword">void</span> <span class="token function">check_password</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>user<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>password<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token function">password</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">,</span> password<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msg<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">/* handle error condition */</span>
		<span class="token punctuation">}</span>
		
		<span class="token function">sprintf</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"%s login incorrect"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span>STDERR<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">syslog</span><span class="token punctuation">(</span>LOG_INFO<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">/*…*/</span>
<span class="token punctuation">}</span>
说明：
<span class="token number">1</span>）上述代码检查给定用户名及其口令是否匹配，当不匹配时显示一条错误信息，并将错误信息写入日志中。
<span class="token number">2</span>）同样的，如果user为” <span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s”，经过格式化函数<span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的拼装后，msg指向的字符串为” <span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s<span class="token operator">%</span>s login incorrect”，
<span class="token number">3</span>）在<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>调用中，msg将作为<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的格式化字符串，可能引发如同示例<span class="token number">1</span>一样的问题。
<span class="token number">4</span>）而且，<span class="token function">syslog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数也一样存在格式化字符串的问题。

正确做法：格式化字符串由代码确定，未经检查过滤的用户输入只能作为参数。
<span class="token keyword">void</span> <span class="token function">check_password</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>user<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>password<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token function">password</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">,</span> password<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msg<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">/* handle error condition */</span>
		<span class="token punctuation">}</span>
		
		<span class="token function">sprintf</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"%s password incorrect"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">syslog</span><span class="token punctuation">(</span>LOG_INFO<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="144_IO_2064"></a>14.4 文件I/O安全</h3> 
<h4><a id="_148__strlen__2065"></a>规则 14.8 避免使用 strlen() 计算二进制数据的长度</h4> 
<p><em>说明：<br> 1）<code>strlen()</code>函数用于计算字符串的长度，它返回字符串中第一个<code>NULL</code>结束符之前的字符的数量。<br> 2）因此用<code>strlen()</code>处理文件I/O函数读取的内容时要小心，因为这些内容可能是二进制也可能是文本。</em></p> 
<pre><code class="prism language-c">示例：
<span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUF_SIZE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">/* handle error */</span>
<span class="token punctuation">}</span>
buf<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
说明：
<span class="token number">1</span>）上述代码试图从一个输入行中删除行尾的换行符（\n）。
<span class="token number">2</span>）如果buf的第一个字符是<span class="token constant">NULL</span>，<span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>返回<span class="token number">0</span>，这时对buf进行数组下标为<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>的访问操作将会越界。

正确做法：在不能确定从文件读取到的数据的类型时，不要使用依赖<span class="token constant">NULL</span>结束符的字符串操作函数。
<span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUF_SIZE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	p <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">/* handle error condition */</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_149__int__IO__2099"></a>规则 14.9 使用 int 类型变量来接受字符 I/O 函数的返回值</h4> 
<p><em>说明：<br> 1）字符I/O函数<code>fgetc()</code>、<code>getc()</code>和<code>getchar()</code>都从一个流读取一个字符，并把它以int值的形式返回。<br> 2）如果这个流到达了文件尾或者发生读取错误，函数返回<code>EOF</code>。<code>fputc()</code>、<code>putc()</code>、<code>putchar()</code>和<code>ungetc()</code>也返回一个字符或<code>EOF</code>。<br> 3）如果这些I/O函数的返回值需要与<code>EOF</code>进行比较，不要将返回值转换为<code>char</code>类型。<br> 4）因为<code>char</code>是有符号8位的值，<code>int</code>是32位的值。如果<code>getchar()</code>返回的字符的ASCII值为<code>0xFF</code>，转换为<code>char</code>类型后将被解释为<code>EOF</code>。<br> 5）因为这个值被有符号扩展为<code>0xFFFFFFFF（EOF的值）</code>执行比较。</em></p> 
<pre><code class="prism language-c">示例：
<span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> ch<span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'\n'</span> <span class="token operator">&amp;&amp;</span> ch <span class="token operator">!=</span> <span class="token constant">EOF</span> <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;</span> BUF_SIZE <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
	buf<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> <span class="token comment">/* terminate NTBS */</span>

正确做法：使用<span class="token keyword">int</span>类型的变量接受<span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的返回值。
<span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> ch<span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ch <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> BUF_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		buf<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> ch<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> <span class="token comment">/* terminate NTBS */</span>

对于 <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>的平台，用<span class="token keyword">int</span>接收返回值也可能无法与<span class="token constant">EOF</span>区分，这时要用<span class="token function">feof</span><span class="token punctuation">(</span><span class="token punctuation">)</span>和<span class="token function">ferror</span><span class="token punctuation">(</span><span class="token punctuation">)</span>检测文件尾和文件错误。
</code></pre> 
<h3><a id="145__2137"></a>14.5 其它</h3> 
<h4><a id="_1410___2138"></a>规则 14.10 防止命令注入</h4> 
<p><em>说明：<br> 1）<code>C99函数system()</code>通过调用一个系统定义的命令解析器<code>（如UNIX的shell，Windows的CMD.exe）</code>来执行一个指定的程序/命令。<br> 2）类似的还有<code>POSIX的函数popen()。</code><br> 3）如果<code>system()</code>的参数由用户的输入组成，恶意用户可以通过构造恶意输入，改变<code>system()</code>调用的行为。</em></p> 
<pre><code class="prism language-c">示例：
<span class="token function">system</span><span class="token punctuation">(</span><span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token string">"any_exe %s"</span><span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
如果恶意用户输入参数：
happy<span class="token punctuation">;</span> useradd attacker
最终shell将字符串“any_exe happy<span class="token punctuation">;</span> useradd attacker”解释为两条独立的命令：

正确做法：使用POSIX函数<span class="token function">execve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>代替<span class="token function">system</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token keyword">void</span> secuExec <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>input<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	pid_t pid<span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">""</span><span class="token punctuation">,</span> input<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	
	pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execve</span><span class="token punctuation">(</span><span class="token string">"/usr/bin/any_exe"</span><span class="token punctuation">,</span> args<span class="token punctuation">,</span> envs<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Error executing any_exe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Windows环境可能对<span class="token function">execve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的支持不是很完善，建议使用Win32 API <span class="token function">CreateProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span>代替<span class="token function">system</span><span class="token punctuation">(</span><span class="token punctuation">)</span>。
</code></pre> 
<h2><a id="_2175"></a>十五、单元测试</h2> 
<h3><a id="_151__2176"></a>规则 15.1 在编写代码的同时，或者编写代码前，编写单元测试试用例验证软件设计/编码的正确</h3> 
<h3><a id="_151__2177"></a>建议 15.1 单元测试关注单元的行为而不是实现，避免针对函数的测试</h3> 
<p><em>说明：<br> 1）应该将被测单元看作一个被测的整体，根据实际资源、进度和质量风险，权衡代码覆盖、打桩工作量、补充测试用例的难度、被测对象的稳定程度等，一般情况下建议关注模块/组件的测试，尽量避免针对函数的测试。<br> 2）尽管有时候单个用例只能专注于某个具体函数的测试，但我们关注的应该是函数的行为而不是其具体实现细节。</em></p> 
<h2><a id="_2181"></a>十六、可移植性</h2> 
<h3><a id="_161__2182"></a>规则 16.1 不能定义、重定义或取消定义标准库/平台中保留的标识符、宏和函数</h3> 
<h3><a id="_161__2183"></a>建议 16.1 不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性</h3> 
<p><em>说明：使用标准的数据类型，有利于程序的移植。</em></p> 
<pre><code class="prism language-c">示例： 如下例子（在DOS下BC3<span class="token punctuation">.</span><span class="token number">1</span>环境中），在移植时可能产生的问题。
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">register</span> <span class="token keyword">int</span> index<span class="token punctuation">;</span> <span class="token comment">//寄存器变量</span>
	_AX <span class="token operator">=</span> <span class="token number">0x4000</span><span class="token punctuation">;</span>       <span class="token comment">//_AX是BC3.1提供的寄存器“伪变量”</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token comment">//program code</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_162___2194"></a>建议 16.2 除非为了满足特殊需求 ，避免使用嵌入式汇编</h3> 
<p><em>说明：程序中嵌入式汇编，一般都对可移植性有较大的影响。</em></p> 
<h2><a id="_2197"></a>十七、附件</h2> 
<p><a href="https://download.csdn.net/download/Richard_MZ/14022170">PDF</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/466f00acec6c8f06cefaafb2f186f1e0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用iai_kinect2标定kinectV2相机</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07a91d9eb277827cc5d42a59f0ded0dc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">unity 按键键值检测。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>