<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解 Java 垃圾回收机制 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入理解 Java 垃圾回收机制" />
<meta property="og:description" content="一：垃圾回收机制的意义
java 语言中一个显著的特点就是引入了java回收机制，是c&#43;&#43;程序员最头疼的内存管理的问题迎刃而解，它使得java程序员在编写程序的时候不在考虑内存管理。由于有个垃圾回收机制，java中的额对象不在有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存；
内存泄露：指该内存空间使用完毕后未回收，在不涉及复杂数据结构的一般情况下，java的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有是也将其称为“对象游离”；
二：垃圾回收机制的算法
java语言规范没有明确的说明JVM 使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做两件基本事情：（1）发现无用的信息对象；（2）回收将无用对象占用的内存空间。使该空间可被程序再次使用。
1。引用计数法（Reference Counting Collector）
1.1:算法分析：
引用计数算法是垃圾回收器中的早起策略，在这种方法中，堆中的每个对象实例都有一个引用计数器，点一个对象被创建时，且该对象实例分配给一个变量，该变量计数设置为1 ，当任何其他变量赋值为这个对象的引用时，计数加1 ，（a=b ，则b引用的对象实例计数器&#43;1）但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1，任何引用计数器为0 的对象实例可以当做垃圾收集。 当一个对象的实例被垃圾收集是，它引用的任何对象实例的引用计数器减1.
一、垃圾回收机制的意义
Java语言中一个显著的特点就是引入了垃圾回收机制，使c&#43;&#43;程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。
ps:内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。
二、垃圾回收机制中的算法
Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。
1.引用计数法(Reference Counting Collector)
1.1算法分析
引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器&#43;1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。
1.2优缺点
优点：
引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。
缺点：
无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.
1.3引用计数算法无法解决循环引用问题，例如：
1
2
3
4
5
6
7
8
9
10
11
12
public class Main {
public static void main(String[] args) {
MyObject object1 = new MyObject();
MyObject object2 = new MyObject();
object1.object = object2;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c280796ddb3b8cb9cef3b84603a36983/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-25T10:33:19+08:00" />
<meta property="article:modified_time" content="2022-04-25T10:33:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解 Java 垃圾回收机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:left;"><strong>一：垃圾回收机制的意义</strong></p> 
<p style="margin-left:0;text-align:left;">java  语言中一个显著的特点就是引入了java回收机制，是c++程序员最头疼的内存管理的问题迎刃而解，它使得java程序员在编写程序的时候不在考虑内存管理。由于有个垃圾回收机制，java中的额对象不在有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存；</p> 
<p style="margin-left:0;text-align:left;"> 内存泄露：指该内存空间使用完毕后未回收，在不涉及复杂数据结构的一般情况下，java的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有是也将其称为“对象游离”；</p> 
<p style="margin-left:0;text-align:left;">二：垃圾回收机制的算法</p> 
<p style="margin-left:0;text-align:left;">java语言规范没有明确的说明JVM 使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做两件基本事情：（1）发现无用的信息对象；（2）回收将无用对象占用的内存空间。使该空间可被程序再次使用。</p> 
<p style="margin-left:0;text-align:left;">1。引用计数法（Reference Counting Collector）</p> 
<p style="margin-left:0;text-align:left;">     1.1:算法分析：</p> 
<p style="margin-left:0;text-align:left;">      引用计数算法是垃圾回收器中的早起策略，在这种方法中，堆中的每个对象实例都有一个引用计数器，点一个对象被创建时，且该对象实例分配给一个变量，该变量计数设置为1 ，当任何其他变量赋值为这个对象的引用时，计数加1 ，（a=b ，则b引用的对象实例计数器+1）但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1，任何引用计数器为0 的对象实例可以当做垃圾收集。 当一个对象的实例被垃圾收集是，它引用的任何对象实例的引用计数器减1.</p> 
<p style="margin-left:0;text-align:left;"><strong>一、垃圾回收机制的意义</strong></p> 
<p style="margin-left:0;text-align:left;">Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。</p> 
<p style="margin-left:0;text-align:left;">ps:内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。</p> 
<p style="margin-left:0;text-align:left;"><strong>二、垃圾回收机制中的算法</strong></p> 
<p style="margin-left:0;text-align:left;">Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。</p> 
<p style="margin-left:0;text-align:left;"><strong>1.</strong><strong>引用计数法</strong><strong>(Reference Counting Collector)</strong></p> 
<p style="margin-left:0;text-align:left;">1.1算法分析</p> 
<p style="margin-left:0;text-align:left;">引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p> 
<p style="margin-left:0;text-align:left;">1.2优缺点</p> 
<p style="margin-left:0;text-align:left;">优点：</p> 
<p style="margin-left:0;text-align:left;">引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p> 
<p style="margin-left:0;text-align:left;">缺点：</p> 
<p style="margin-left:0;text-align:left;">无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p> 
<p style="margin-left:0;text-align:left;">1.3引用计数算法无法解决循环引用问题，例如：</p> 
<table border="1" cellspacing="0" style="width:477.5pt;"><tbody><tr><td style="border-color:#c0c0c0;"> <p style="margin-left:0;text-align:left;">1</p> <p style="margin-left:0;text-align:left;">2</p> <p style="margin-left:0;text-align:left;">3</p> <p style="margin-left:0;text-align:left;">4</p> <p style="margin-left:0;text-align:left;">5</p> <p style="margin-left:0;text-align:left;">6</p> <p style="margin-left:0;text-align:left;">7</p> <p style="margin-left:0;text-align:left;">8</p> <p style="margin-left:0;text-align:left;">9</p> <p style="margin-left:0;text-align:left;">10</p> <p style="margin-left:0;text-align:left;">11</p> <p style="margin-left:0;text-align:left;">12</p> </td><td style="border-color:#c0c0c0;"> <p style="margin-left:0;text-align:left;">public class Main {<!-- --></p> <p style="margin-left:0;text-align:left;">    public static void main(String[] args) {<!-- --></p> <p style="margin-left:0;text-align:left;">        MyObject object1 = new MyObject();</p> <p style="margin-left:0;text-align:left;">        MyObject object2 = new MyObject();</p> <p style="margin-left:0;text-align:left;">          </p> <p style="margin-left:0;text-align:left;">        object1.object = object2;</p> <p style="margin-left:0;text-align:left;">        object2.object = object1;</p> <p style="margin-left:0;text-align:left;">          </p> <p style="margin-left:0;text-align:left;">        object1 = null;</p> <p style="margin-left:0;text-align:left;">        object2 = null;</p> <p style="margin-left:0;text-align:left;">    }</p> <p style="margin-left:0;text-align:left;">}</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:left;">最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。</p> 
<p style="margin-left:0;text-align:left;"><strong>2.tracing</strong><strong>算法</strong><strong>(Tracing Collector) </strong><strong>或</strong><strong> </strong><strong>标记</strong><strong>-</strong><strong>清除算法</strong><strong>(mark and sweep)</strong></p> 
<p style="margin-left:0;text-align:left;">2.1根搜索算法</p> 
<p style="margin-left:0;text-align:left;">根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p> 
<p style="margin-left:0;text-align:left;">java中可作为GC Root的对象有</p> 
<p style="margin-left:0;text-align:left;">1.虚拟机栈中引用的对象（本地变量表）</p> 
<p style="margin-left:0;text-align:left;">2.方法区中静态属性引用的对象</p> 
<p style="margin-left:0;text-align:left;">3. 方法区中常量引用的对象</p> 
<p style="margin-left:0;text-align:left;">4.本地方法栈中引用的对象（Native对象）</p> 
<p style="margin-left:0;text-align:left;"><strong>2.2tracing</strong><strong>算法的示意图</strong></p> 
<p style="margin-left:0;text-align:left;"><strong>2.3</strong><strong>标记</strong><strong>-</strong><strong>清除算法分析</strong></p> 
<p style="margin-left:0;text-align:left;">标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p> 
<p style="margin-left:0;text-align:left;"><strong>3.compacting</strong><strong>算法</strong><strong> </strong><strong>或</strong><strong> </strong><strong>标记</strong><strong>-</strong><strong>整理算法</strong></p> 
<p style="margin-left:0;text-align:left;">标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p> 
<p style="margin-left:0;text-align:left;"><strong>4.copying</strong><strong>算法</strong><strong>(Compacting Collector)</strong></p> 
<p style="margin-left:0;text-align:left;">该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。</p> 
<p style="margin-left:0;text-align:left;"><strong>5.generation</strong><strong>算法</strong><strong>(Generational Collector)</strong></p> 
<p style="margin-left:0;text-align:left;">分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。</p> 
<p style="margin-left:0;text-align:left;"><strong>年轻代（</strong><strong>Young Generation</strong><strong>）</strong></p> 
<p style="margin-left:0;text-align:left;">1.所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p> 
<p style="margin-left:0;text-align:left;">2.新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p> 
<p style="margin-left:0;text-align:left;">3.当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收</p> 
<p style="margin-left:0;text-align:left;">4.新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)</p> 
<p style="margin-left:0;text-align:left;"><strong>年老代（</strong><strong>Old Generation</strong><strong>）</strong></p> 
<p style="margin-left:0;text-align:left;">1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p> 
<p style="margin-left:0;text-align:left;">2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p> 
<p style="margin-left:0;text-align:left;"><strong>持久代（</strong><strong>Permanent Generation</strong><strong>）</strong></p> 
<p style="margin-left:0;text-align:left;">用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p> 
<p style="margin-left:0;text-align:left;"><strong>三</strong><strong>.GC</strong><strong>（垃圾收集器）</strong></p> 
<p style="margin-left:0;text-align:left;">新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge</p> 
<p style="margin-left:0;text-align:left;">老年代收集器使用的收集器：Serial Old、Parallel Old、CMS</p> 
<p style="margin-left:0;text-align:left;"><strong>Serial</strong><strong>收集器（复制算法</strong><strong>)</strong></p> 
<p style="margin-left:0;text-align:left;">新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p> 
<p style="margin-left:0;text-align:left;"><strong>Serial Old</strong><strong>收集器</strong><strong>(</strong><strong>标记</strong><strong>-</strong><strong>整理算法</strong><strong>)</strong></p> 
<p style="margin-left:0;text-align:left;">老年代单线程收集器，Serial收集器的老年代版本。</p> 
<p style="margin-left:0;text-align:left;"><strong>ParNew</strong><strong>收集器</strong><strong>(</strong><strong>停止</strong><strong>-</strong><strong>复制算法</strong><strong>)</strong><strong>　</strong></p> 
<p style="margin-left:0;text-align:left;">新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p> 
<p style="margin-left:0;text-align:left;"><strong>Parallel Scavenge</strong><strong>收集器</strong><strong>(</strong><strong>停止</strong><strong>-</strong><strong>复制算法</strong><strong>)</strong></p> 
<p style="margin-left:0;text-align:left;">并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p> 
<p style="margin-left:0;text-align:left;"><strong>Parallel Old</strong><strong>收集器</strong><strong>(</strong><strong>停止</strong><strong>-</strong><strong>复制算法</strong><strong>)</strong></p> 
<p style="margin-left:0;text-align:left;">Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p> 
<p style="margin-left:0;text-align:left;"><strong>CMS(Concurrent Mark Sweep)</strong><strong>收集器（标记</strong><strong>-</strong><strong>清理算法）</strong></p> 
<p style="margin-left:0;text-align:left;">高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p> 
<p style="margin-left:0;text-align:left;"><strong>四、</strong><strong>GC</strong><strong>的执行机制</strong></p> 
<p style="margin-left:0;text-align:left;">由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p> 
<p style="margin-left:0;text-align:left;"><strong>Scavenge GC</strong></p> 
<p style="margin-left:0;text-align:left;">一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p> 
<p style="margin-left:0;text-align:left;"><strong>Full GC</strong></p> 
<p style="margin-left:0;text-align:left;">对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p> 
<p style="margin-left:0;text-align:left;">1.年老代（Tenured）被写满</p> 
<p style="margin-left:0;text-align:left;">2.持久代（Perm）被写满</p> 
<p style="margin-left:0;text-align:left;">3.System.gc()被显示调用</p> 
<p style="margin-left:0;text-align:left;">4.上一次GC之后Heap的各域分配策略动态变化</p> 
<p style="margin-left:0;text-align:left;"><strong>五、</strong><strong>Java</strong><strong>有了</strong><strong>GC</strong><strong>同样会出现内存泄露问题</strong></p> 
<p style="margin-left:0;text-align:left;">1.静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。</p> 
<table border="1" cellspacing="0" style="width:477.5pt;"><tbody><tr><td style="border-color:#c0c0c0;"> <p style="margin-left:0;text-align:left;">1</p> <p style="margin-left:0;text-align:left;">2</p> <p style="margin-left:0;text-align:left;">3</p> <p style="margin-left:0;text-align:left;">4</p> <p style="margin-left:0;text-align:left;">5</p> <p style="margin-left:0;text-align:left;">6</p> <p style="margin-left:0;text-align:left;">7</p> </td><td style="border-color:#c0c0c0;"> <p style="margin-left:0;text-align:left;">Static Vector v = new Vector();</p> <p style="margin-left:0;text-align:left;">for (int i = 1; i&lt;100; i++)</p> <p style="margin-left:0;text-align:left;">{<!-- --></p> <p style="margin-left:0;text-align:left;">    Object o = new Object();</p> <p style="margin-left:0;text-align:left;">    v.add(o);</p> <p style="margin-left:0;text-align:left;">    o = null;</p> <p style="margin-left:0;text-align:left;">}</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:left;">在这个例子中，代码栈中存在Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环中，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后， Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。</p> 
<p style="margin-left:0;text-align:left;">2.各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。</p> 
<p style="margin-left:0;text-align:left;">3.监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</p> 
<p style="margin-left:0;text-align:left;">一.如何确定某个对象是“垃圾”？</p> 
<p style="margin-left:0;text-align:left;">在这一小节我们先了解一个最基本的问题：如果确定某个对象是“垃圾”？既然垃圾收集器的任务是回收垃圾对象所占的空间供新的对象使用，那么垃圾收集器如何确定某个对象是“垃圾”？—即通过什么方法判断一个对象可以被回收了。</p> 
<p style="margin-left:0;text-align:left;">在java中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了。这种方式成为引用计数法。</p> 
<p style="margin-left:0;text-align:left;">这种方式的特点是实现简单，而且效率较高，但是它无法解决循环引用的问题，因此在Java中并没有采用这种方式（Python采用的是引用计数法）。看下面这段代码：</p> 
<table cellspacing="0" style="width:465pt;"><tbody><tr><td> <p style="margin-left:0;text-align:left;">1</p> <p style="margin-left:0;text-align:left;">2</p> <p style="margin-left:0;text-align:left;">3</p> <p style="margin-left:0;text-align:left;">4</p> <p style="margin-left:0;text-align:left;">5</p> <p style="margin-left:0;text-align:left;">6</p> <p style="margin-left:0;text-align:left;">7</p> <p style="margin-left:0;text-align:left;">8</p> <p style="margin-left:0;text-align:left;">9</p> <p style="margin-left:0;text-align:left;">10</p> <p style="margin-left:0;text-align:left;">11</p> <p style="margin-left:0;text-align:left;">12</p> <p style="margin-left:0;text-align:left;">13</p> <p style="margin-left:0;text-align:left;">14</p> <p style="margin-left:0;text-align:left;">15</p> <p style="margin-left:0;text-align:left;">16</p> </td><td style="width:439.5pt;"> <p style="margin-left:0;text-align:left;">public class Main {<!-- --></p> <p style="margin-left:0;text-align:left;">    public static void main(String[] args) {<!-- --></p> <p style="margin-left:0;text-align:left;">        MyObject object1 = new MyObject();</p> <p style="margin-left:0;text-align:left;">        MyObject object2 = new MyObject();</p> <p style="margin-left:0;text-align:left;"> </p> <p style="margin-left:0;text-align:left;">        object1.object = object2;</p> <p style="margin-left:0;text-align:left;">        object2.object = object1;</p> <p style="margin-left:0;text-align:left;"> </p> <p style="margin-left:0;text-align:left;">        object1 = null;</p> <p style="margin-left:0;text-align:left;">        object2 = null;</p> <p style="margin-left:0;text-align:left;">    }</p> <p style="margin-left:0;text-align:left;">}</p> <p style="margin-left:0;text-align:left;"> </p> <p style="margin-left:0;text-align:left;">class MyObject{<!-- --></p> <p style="margin-left:0;text-align:left;">    public Object object = null;</p> <p style="margin-left:0;text-align:left;">}</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:left;">最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。</p> 
<p style="margin-left:0;text-align:left;">为了解决这个问题，在Java中采取了 可达性分析法。该方法的基本思想是通过一系列的“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。</p> 
<p style="margin-left:0;text-align:left;">至于可达性分析法具体是如何操作的我暂时也没有看得很明白，如果有哪位朋友比较清楚的话请不吝指教。</p> 
<p style="margin-left:0;text-align:left;">下面来看个例子：</p> 
<table cellspacing="0" style="width:465pt;"><tbody><tr><td> <p style="margin-left:0;text-align:left;">1</p> <p style="margin-left:0;text-align:left;">2</p> <p style="margin-left:0;text-align:left;">3</p> <p style="margin-left:0;text-align:left;">4</p> <p style="margin-left:0;text-align:left;">5</p> <p style="margin-left:0;text-align:left;">6</p> <p style="margin-left:0;text-align:left;">7</p> </td><td style="width:444.5pt;"> <p style="margin-left:0;text-align:left;">Object aobj = new Object ( ) ;</p> <p style="margin-left:0;text-align:left;">Object bobj = new Object ( ) ;</p> <p style="margin-left:0;text-align:left;">Object cobj = new Object ( ) ;</p> <p style="margin-left:0;text-align:left;">aobj = bobj;</p> <p style="margin-left:0;text-align:left;">aobj = cobj;</p> <p style="margin-left:0;text-align:left;">cobj = null;</p> <p style="margin-left:0;text-align:left;">aobj = null;</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:left;">第几行有可能会使得某个对象成为可回收对象？第7行的代码会导致有对象会成为可回收对象。至于为什么留给读者自己思考。</p> 
<p style="margin-left:0;text-align:left;">再看一个例子：</p> 
<table cellspacing="0" style="width:465pt;"><tbody><tr><td> <p style="margin-left:0;text-align:left;">1</p> <p style="margin-left:0;text-align:left;">2</p> <p style="margin-left:0;text-align:left;">3</p> </td><td style="width:444.5pt;"> <p style="margin-left:0;text-align:left;">String str = new String("hello");</p> <p style="margin-left:0;text-align:left;">SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String("java"));</p> <p style="margin-left:0;text-align:left;">WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(new String("world"));</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:left;">这三句哪句会使得String对象成为可回收对象？第2句和第3句，第2句在内存不足的情况下会将String对象判定为可回收对象，第3句无论什么情况下String对象都会被判定为可回收对象。</p> 
<p style="margin-left:0;text-align:left;">最后总结一下平常遇到的比较常见的将对象判定为可回收对象的情况：</p> 
<p style="margin-left:0;text-align:left;">1）显示地将某个引用赋值为null或者将已经指向某个对象的引用指向新的对象，比如下面的代码：</p> 
<table cellspacing="0" style="width:465pt;"><tbody><tr><td> <p style="margin-left:0;text-align:left;">1</p> <p style="margin-left:0;text-align:left;">2</p> <p style="margin-left:0;text-align:left;">3</p> <p style="margin-left:0;text-align:left;">4</p> <p style="margin-left:0;text-align:left;">5</p> </td><td style="width:444.5pt;"> <p style="margin-left:0;text-align:left;">Object obj = new Object();</p> <p style="margin-left:0;text-align:left;">obj = null;</p> <p style="margin-left:0;text-align:left;">Object obj1 = new Object();</p> <p style="margin-left:0;text-align:left;">Object obj2 = new Object();</p> <p style="margin-left:0;text-align:left;">obj1 = obj2;</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:left;">2）局部引用所指向的对象，比如下面这段代码：</p> 
<table cellspacing="0" style="width:465pt;"><tbody><tr><td> <p style="margin-left:0;text-align:left;">1</p> <p style="margin-left:0;text-align:left;">2</p> <p style="margin-left:0;text-align:left;">3</p> <p style="margin-left:0;text-align:left;">4</p> <p style="margin-left:0;text-align:left;">5</p> <p style="margin-left:0;text-align:left;">6</p> <p style="margin-left:0;text-align:left;">7</p> <p style="margin-left:0;text-align:left;">8</p> </td><td style="width:444.5pt;"> <p style="margin-left:0;text-align:left;">void fun() {<!-- --></p> <p style="margin-left:0;text-align:left;"> </p> <p style="margin-left:0;text-align:left;">.....</p> <p style="margin-left:0;text-align:left;">    for(int i=0;i&lt;10;i++) {<!-- --></p> <p style="margin-left:0;text-align:left;">        Object obj = new Object();</p> <p style="margin-left:0;text-align:left;">        System.out.println(obj.getClass());</p> <p style="margin-left:0;text-align:left;">    }  </p> <p style="margin-left:0;text-align:left;">}</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:left;">循环每执行完一次，生成的Object对象都会成为可回收的对象。</p> 
<p style="margin-left:0;text-align:left;">3）只有弱引用与其关联的对象，比如：</p> 
<table cellspacing="0" style="width:465pt;"><tbody><tr><td> <p style="margin-left:0;text-align:left;">1</p> </td><td style="width:444.5pt;"> <p style="margin-left:0;text-align:left;">WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(new String("world"));</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:left;">二.典型的垃圾收集算法</p> 
<p style="margin-left:0;text-align:left;">在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，所以在此只讨论几种常见的垃圾收集算法的核心思想。</p> 
<p style="margin-left:0;text-align:left;">1.Mark-Sweep（标记-清除）算法</p> 
<p style="margin-left:0;text-align:left;">这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。具体过程如下图所示：</p> 
<p><img src="https://images2.imgbox.com/09/af/g9ADbfiB_o.png" alt="a248d818cea78f8d073d835f143cca19.png"></p> 
<p style="margin-left:0;text-align:left;">从图中可以很容易看出标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。</p> 
<p style="margin-left:0;text-align:left;">2.Copying（复制）算法</p> 
<p style="margin-left:0;text-align:left;">为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示：</p> 
<p><img src="https://images2.imgbox.com/e5/7f/u9GUTr4U_o.png" alt="f997561c89980d4fe241a4f5d53e336c.png"></p> 
<p style="margin-left:0;text-align:left;">这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。</p> 
<p style="margin-left:0;text-align:left;">很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。</p> 
<p style="margin-left:0;text-align:left;">3.Mark-Compact（标记-整理）算法</p> 
<p style="margin-left:0;text-align:left;">为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：</p> 
<p><img src="https://images2.imgbox.com/e0/19/pUsDT91c_o.png" alt="43b6e9aeeb79c5325f675a506c97a160.png"></p> 
<p style="margin-left:0;text-align:left;">4.Generational Collection（分代收集）算法</p> 
<p style="margin-left:0;text-align:left;">分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p> 
<p style="margin-left:0;text-align:left;">目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</p> 
<p style="margin-left:0;text-align:left;">而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。</p> 
<p style="margin-left:0;text-align:left;">注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。</p> 
<p style="margin-left:0;text-align:left;">三.典型的垃圾收集器</p> 
<p style="margin-left:0;text-align:left;">垃圾收集算法是 内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。下面介绍一下HotSpot（JDK 7)虚拟机提供的几种垃圾收集器，用户可以根据自己的需求组合出各个年代使用的收集器。</p> 
<p style="margin-left:0;text-align:left;">1.Serial/Serial Old</p> 
<p style="margin-left:0;text-align:left;">Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。</p> 
<p style="margin-left:0;text-align:left;">2.ParNew</p> 
<p style="margin-left:0;text-align:left;">ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。</p> 
<p style="margin-left:0;text-align:left;">3.Parallel Scavenge</p> 
<p style="margin-left:0;text-align:left;">Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。</p> 
<p style="margin-left:0;text-align:left;">4.Parallel Old</p> 
<p style="margin-left:0;text-align:left;">Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。</p> 
<p style="margin-left:0;text-align:left;">5.CMS</p> 
<p style="margin-left:0;text-align:left;">CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。</p> 
<p style="margin-left:0;text-align:left;">6.G1</p> 
<p style="margin-left:0;text-align:left;">G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。</p> 
<p style="margin-left:0;text-align:left;">下面补充一下关于内存分配方面的东西：</p> 
<p><img src="https://images2.imgbox.com/92/96/DM5F8V6N_o.png" alt="202cae9511c9f1bfdff087d1179dccea.png"></p> 
<p style="margin-left:0;text-align:left;">对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden Space和From Space，少数情况下会直接分配在老年代。如果新生代的Eden Space和From Space的空间不足，则会发起一次GC，如果进行了GC之后，Eden Space和From Space能够容纳该对象就放在Eden Space和From Space。在GC的过程中，会将Eden Space和From  Space中的存活对象移动到To Space，然后将Eden Space和From Space进行清理。如果在清理的过程中，To Space无法足够来存储某个对象，就会将该对象移动到老年代中。在进行了GC之后，使用的便是Eden space和To Space了，下次GC时会将存活对象复制到From Space，如此反复循环。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。</p> 
<p style="margin-left:0;text-align:left;">一般来说，大对象会被直接分配到老年代，所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组，比如：</p> 
<p style="margin-left:0;text-align:left;">byte[] data = new byte[4*1024*1024]</p> 
<p style="margin-left:0;text-align:left;">这种一般会直接在老年代分配存储空间。</p> 
<p style="margin-left:0;text-align:left;">当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和JVM的相关参数。</p> 
<p style="margin-left:0;text-align:left;"><strong>1. </strong><strong>垃圾回收的意义</strong><br> 　　在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在<a href="http://lib.csdn.net/base/javase" rel="nofollow" title="Java">Java</a>中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是"无用信息"，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。<br> 　　垃圾回收能自动释放内存空间，减轻编程的负担。这使Java 虚拟机具有一些优点。首先，它能使编程效率提高。在没有垃圾回收机制的时候，可能要花许多时间来解决一个难懂的存储器问题。在用Java语言编程的时候，靠垃圾回收机制可大大缩短时间。其次是它保护程序的完整性， 垃圾回收是Java语言安全性策略的一个重要部份。<br> 　　垃圾回收的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。其次垃圾回收<a href="http://lib.csdn.net/base/datastructure" rel="nofollow" title="算法">算法</a>的不完备性，早先采用的某些垃圾回收算法就不能保证100%收集到所有的废弃内存。当然随着垃圾回收算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。<br><strong>2. </strong><strong>垃圾收集的算法分析</strong><br> 　　Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。<br> 　　大多数垃圾回收算法使用了根集(root set)这个概念；所谓根集就是正在执行的Java程序可以访问的引用变量的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。垃圾回收首先需要确定从根开始哪些是可达的和哪些是不可达的，从根集可达的对象都是活动对象，它们不能作为垃圾被回收，这也包括从根集间接可达的对象。而根集通过任意路径不可达的对象符合垃圾收集的条件，应该被回收。下面介绍几个常用的算法。<br> 　　<strong>2.1. </strong><strong>引用计数法</strong><strong>(Reference Counting Collector)</strong><br> 　　引用计数法是唯一没有使用根集的垃圾回收的法，该算法使用引用计数器来区分存活对象和不再使用的对象。一般来说，堆中的每个对象对应一个引用计数器。当每一次创建一个对象并赋给一个变量时，引用计数器置为1。当对象被赋给任意变量时，引用计数器每次加1当对象出了作用域后(该对象丢弃不再使用)，引用计数器减1，一旦引用计数器为0，对象就满足了垃圾收集的条件。<br> 　　基于引用计数器的垃圾收集器运行较快，不会长时间中断程序执行，适宜地必须实时运行的程序。但引用计数器增加了程序执行的开销，因为每次对象赋给新的变量，计数器加1，而每次现有对象出了作用域生，计数器减1。<br> 　　<strong>2.2. tracing</strong><strong>算法</strong><strong>(Tracing Collector)</strong><br> 　　tracing算法是为了解决引用计数法的问题而提出，它使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器.<br> 　　<strong>2.3. compacting</strong><strong>算法</strong><strong>(Compacting Collector)</strong><br> 　　为了解决堆碎片问题，基于tracing的垃圾回收吸收了Compacting算法的思想，在清除的过程中，算法将所有的对象移到堆的一端，堆的另一端就变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。<br> 　　<strong>2.4. copying</strong><strong>算法</strong><strong>(Coping Collector)</strong><br> 　　该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成一个对象区和多个空闲区，程序从对象区为对象分配空间，当对象满了，基于coping算法的垃圾回收就从根集中扫描活动对象，并将每个活动对象复制到空闲区(使得活动对象所占的内存之间没有空闲间隔)，这样空闲区变成了对象区，原来的对象区变成了空闲区，程序会在新的对象区中分配内存。<br> 　　一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区域区，在对象区与空闲区域的切换过程中，程序暂停执行。<br> 　　<strong>2.5.</strong> <strong>generation</strong><strong>算法</strong><strong>(Generational Collector)</strong><br> 　　stop-and-copy垃圾收集器的一个缺陷是收集器必须复制所有的活动对象，这增加了程序等待时间，这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间比较长。因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代 (generation)。由于多数对象存在的时间比较短，随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在分代式的垃圾收集器运行后，上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常被回收，因而节省了时间。<br> 　　<strong>2.6. adaptive</strong><strong>算法</strong><strong>(Adaptive Collector)</strong><br> 　　在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。</p> 
<p style="margin-left:0;text-align:left;"><strong>3. System.gc()</strong><strong>方法</strong></p> 
<p style="margin-left:0;text-align:left;">      命令行参数透视垃圾收集器的运行<br> 　　使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。在命令行中有一个参数-verbosegc可以查看Java使用的堆内存的情况，它的格式如下：<br> 　　java -verbosegc classfile<br> 　　可以看个例子：<br> 　　</p> 
<p style="margin-left:0;text-align:left;"><strong>[java]</strong> <a href="http://blog.csdn.net/zsuguangh/article/details/6429592" title="view plain">view plain</a> <a href="http://blog.csdn.net/zsuguangh/article/details/6429592" title="copy">copy</a></p> 
<div style="margin-left:18pt;"> 
 <ol><li style="text-align:left;"><strong>class</strong> TestGC  </li><li style="text-align:left;">{  </li><li style="text-align:left;">    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args)  </li><li style="text-align:left;">    {  </li><li style="text-align:left;">　　    <strong>new</strong> TestGC();  </li><li style="text-align:left;">　　    System.gc();  </li><li style="text-align:left;">　　    System.runFinalization();  </li><li style="text-align:left;">　　 }  </li><li style="text-align:left;">}  </li></ol> 
</div> 
<p style="margin-left:0;text-align:left;">      <br> 　　在这个例子中，一个新的对象被创建，由于它没有使用，所以该对象迅速地变为不可达，程序编译后，执行命令： java -verbosegc TestGC 后结果为：<br> 　　[Full GC 168K-&gt;97K(1984K)， 0.0253873 secs]<br> 　　机器的环境为，Windows 2000 + JDK1.3.1，箭头前后的数据168K和97K分别表示垃圾收集GC前后所有存活对象使用的内存容量，说明有168K-97K=71K的对象容量被回收，括号内的数据1984K为堆内存的总容量，收集所需要的时间是0.0253873秒（这个时间在每次执行的时候会有所不同）。</p> 
<p style="margin-left:0;text-align:left;">      需要注意的是，调用System.gc()也仅仅是一个请求(建议)。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。</p> 
<p style="margin-left:0;text-align:left;"><strong>4. finalize()</strong><strong>方法</strong></p> 
<p style="margin-left:0;text-align:left;">      在JVM垃圾回收器收集一个对象之前，一般要求程序调用适当的方法释放资源，但在没有明确释放资源的情况下，Java提供了缺省机制来终止该对象心释放资源，这个方法就是finalize（）。它的原型为：<br> 　　protected void finalize() throws Throwable<br> 　　在finalize()方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。<br> 　　之所以要使用finalize()，是存在着垃圾回收器不能处理的特殊情况。假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由finalize()方法。</p> 
<p style="margin-left:0;text-align:left;">      特殊的区域例如：1）由于在分配内存的时候可能采用了类似 <a href="http://lib.csdn.net/base/c" rel="nofollow" title="C语言">C语言</a>的做法，而非JAVA的通常new做法。这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。<br>       换言之，finalize()的主要用途是释放一些其他做法开辟的内存空间，以及做一些清理工作。因为在JAVA中并没有提够像“析构”函数或者类似概念的函数，要做一些类似清理工作的时候，必须自己动手创建一个执行清理工作的普通方法，也就是override Object这个类中的finalize()方法。例如，假设某一个对象在创建过程中会将自己绘制到屏幕上，如果不是明确地从屏幕上将其擦出，它可能永远都不会被清理。如果在finalize()加入某一种擦除功能，当GC工作时，finalize()得到了调用，图像就会被擦除。要是GC没有发生，那么这个图像就会</p> 
<p style="margin-left:0;text-align:left;">被一直保存下来。</p> 
<p style="margin-left:0;text-align:left;">      一旦垃圾回收器准备好释放对象占用的存储空间，首先会去调用finalize()方法进行一些必要的清理工作。只有到下一次再进行垃圾回收动作的时候，才会真正释放这个对象所占用的内存空间。<br> 　　在普通的清除工作中，为清除一个对象，那个对象的用户必须在希望进行清除的地点调用一个清除方法。这与C++"析构函数"的概念稍有抵触。在C++中，所有对象都会破坏（清除）。或者换句话说，所有对象都"应该"破坏。若将C++对象创建成一个本地对象，比如在堆栈中创建（在Java中是不可能的，Java都在堆中），那么清除或破坏工作就会在"结束花括号"所代表的、创建这个对象的作用域的末尾进行。若对象是用new创建的（类似于Java），那么当程序员调用C++的 delete命令时（Java没有这个命令），就会调用相应的析构函数。若程序员忘记了，那么永远不会调用析构函数，我们最终得到的将是一个内存"漏洞"，另外还包括对象的其他部分永远不会得到清除。<br> 　　相反，Java不允许我们创建本地（局部）对象--无论如何都要使用new。但在Java中，没有"delete"命令来释放对象，因为垃圾回收器会帮助我们自动释放存储空间。所以如果站在比较简化的立场，我们可以说正是由于存在垃圾回收机制，所以Java没有析构函数。然而，随着以后学习的深入，就会知道垃圾收集器的存在并不能完全消除对析构函数的需要，或者说不能消除对析构函数代表的那种机制的需要（原因见下一段。另外finalize()函数是在垃圾回收器准备释放对象占用的存储空间的时候被调用的，绝对不能直接调用finalize()，所以应尽量避免用它）。若希望执行除释放存储空间之外的其他某种形式的清除工作，仍然必须调用Java中的一个方法。它等价于C++的析构函数，只是没后者方便。<br>       在C++中所有的对象运用delete()一定会被销毁，而JAVA里的对象并非总会被垃圾回收器回收。In another word, 1 对象可能不被垃圾回收，2 垃圾回收并不等于“析构”，3 垃圾回收只与内存有关。也就是说，并不是如果一个对象不再被使用，是不是要在finalize()中释放这个对象中含有的其它对象呢？不是的。因为无论对象是如何创建的，垃圾回收器都会负责释放那些对象占有的内存。</p> 
<p style="margin-left:0;text-align:left;"><strong>5. </strong><strong>触发主</strong><strong>GC</strong><strong>（</strong><strong>Garbage Collector</strong><strong>）的条件</strong></p> 
<p style="margin-left:0;text-align:left;">　　JVM进行次GC的频率很高,但因为这种GC占用时间极短,所以对系统产生的影响不大。更值得关注的是主GC的触发条件,因为它对系统影响很明显。总的来说,有两个条件会触发主GC:</p> 
<p style="margin-left:0;text-align:left;">　　1)当应用程序空闲时,即没有应用线程在运行时,GC会被调用。因为GC在优先级最低的线程中进行,所以当应用忙时,GC线程就不会被调用,但以下条件除外。</p> 
<p style="margin-left:0;text-align:left;">　　2)Java堆内存不足时,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,JVM会再进行两次GC作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。</p> 
<p style="margin-left:0;text-align:left;">　　由于是否进行主GC由JVM根据系统环境决定,而系统环境在不断的变化当中,所以主GC的运行具有不确定性,无法预计它何时必然出现,但可以确定的是对一个长期运行的应用来说,其主GC是反复进行的。</p> 
<p style="margin-left:0;text-align:left;"><strong>6. </strong><strong>减少</strong><strong>GC</strong><strong>开销的措施</strong></p> 
<p style="margin-left:0;text-align:left;">　　根据上述GC的机制,程序的运行会直接影响系统环境的变化,从而影响GC的触发。若不针对GC的特点进行设计和编码,就会出现内存驻留等一系列负面影响。为了避免这些影响,基本的原则就是尽可能地减少垃圾和减少GC过程中的开销。具体措施包括以下几个方面:</p> 
<p style="margin-left:0;text-align:left;">　　<strong>(1)</strong><strong>不要显式调用</strong><strong>System.gc()</strong></p> 
<p style="margin-left:0;text-align:left;">　　此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。</p> 
<p style="margin-left:0;text-align:left;">　　<strong>(2)</strong><strong>尽量减少临时对象的使用</strong></p> 
<p style="margin-left:0;text-align:left;">　　临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。</p> 
<p style="margin-left:0;text-align:left;">　　<strong>(3)</strong><strong>对象不用时最好显式置为</strong><strong>Null</strong></p> 
<p style="margin-left:0;text-align:left;">　　一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。</p> 
<p style="margin-left:0;text-align:left;">　　<strong>(4)</strong><strong>尽量使用</strong><strong>StringBuffer,</strong><strong>而不用</strong><strong>String</strong><strong>来累加字符串</strong></p> 
<p style="margin-left:0;text-align:left;">　　由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。</p> 
<p style="margin-left:0;text-align:left;">　　<strong>(5)</strong><strong>能用基本类型如</strong><strong>Int,Long,</strong><strong>就不用</strong><strong>Integer,Long</strong><strong>对象</strong></p> 
<p style="margin-left:0;text-align:left;">　　基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。</p> 
<p style="margin-left:0;text-align:left;">　　<strong>(6)</strong><strong>尽量少用静态对象变量</strong></p> 
<p style="margin-left:0;text-align:left;">　　静态变量属于全局变量,不会被GC回收,它们会一直占用内存。</p> 
<p style="margin-left:0;text-align:left;">　　<strong>(7)</strong><strong>分散对象创建或删除的时间</strong></p> 
<p style="margin-left:0;text-align:left;">　　集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。</p> 
<p style="margin-left:0;text-align:left;"> </p> 
<p style="margin-left:0;text-align:left;">      下面这个例子向大家展示了垃圾收集所经历的过程，并对前面的陈述进行了总结。</p> 
<p style="margin-left:0;text-align:left;">     </p> 
<p style="margin-left:0;text-align:left;"><strong>[java]</strong> <a href="http://blog.csdn.net/zsuguangh/article/details/6429592" title="view plain">view plain</a> <a href="http://blog.csdn.net/zsuguangh/article/details/6429592" title="copy">copy</a></p> 
<div style="margin-left:18pt;"> 
 <ol><li style="text-align:left;"><strong>class</strong> Chair {  </li><li style="text-align:left;">　　<strong>static</strong> <strong>boolean</strong> gcrun = <strong>false</strong>;  </li><li style="text-align:left;">　　<strong>static</strong> <strong>boolean</strong> f = <strong>false</strong>;  </li><li style="text-align:left;">　　<strong>static</strong> <strong>int</strong> created = 0;  </li><li style="text-align:left;">　　<strong>static</strong> <strong>int</strong> finalized = 0;  </li><li style="text-align:left;">　　<strong>int</strong> i;  </li><li style="text-align:left;">　　Chair() {  </li><li style="text-align:left;">　　    i = ++created;  </li><li style="text-align:left;">　　    <strong>if</strong>(created == 47)  </li><li style="text-align:left;">　　　      System.out.println("Created 47");  </li><li style="text-align:left;">　　}  </li><li style="text-align:left;">　　<strong>protected</strong> <strong>void</strong> finalize() {  </li><li style="text-align:left;">　　    <strong>if</strong>(!gcrun) {  </li><li style="text-align:left;">　　　      gcrun = <strong>true</strong>;  </li><li style="text-align:left;">　　　      System.out.println("Beginning to finalize after " + created + " Chairs have been created");  </li><li style="text-align:left;">　　    }  </li><li style="text-align:left;">　　    <strong>if</strong>(i == 47) {  </li><li style="text-align:left;">　　　      System.out.println("Finalizing Chair #47， " +"Setting flag to stop Chair creation");  </li><li style="text-align:left;">　　　      f = <strong>true</strong>;  </li><li style="text-align:left;">　　    }  </li><li style="text-align:left;">　　    finalized++;  </li><li style="text-align:left;">　　    <strong>if</strong>(finalized &gt;= created)  </li><li style="text-align:left;">　　　      System.out.println("All " + finalized + " finalized");  </li><li style="text-align:left;">　　}  </li><li style="text-align:left;">}  </li><li style="text-align:left;">  </li><li style="text-align:left;"><strong>public</strong> <strong>class</strong> Garbage {  </li><li style="text-align:left;">　　<strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li><li style="text-align:left;">　　<strong>if</strong>(args.length == 0) {  </li><li style="text-align:left;">　　　  System.err.println("Usage: /n" + "&lt;a href="http://lib.csdn.net/base/java" class='replace_word' title="Java 知识库" target='_blank' style='color:#df3434; font-weight:bold;'&gt;Java &lt;/a&gt;Garbage before/n or:/n" + "java Garbage after");  </li><li style="text-align:left;">　　　  <strong>return</strong>;  </li><li style="text-align:left;">　　}  </li><li style="text-align:left;">　　<strong>while</strong>(!Chair.f) {  </li><li style="text-align:left;">　　　  <strong>new</strong> Chair();  </li><li style="text-align:left;">　　　  <strong>new</strong> String("To take up space");  </li><li style="text-align:left;">　　}  </li><li style="text-align:left;">　　System.out.println("After all Chairs have been created:/n" + "total created = " + Chair.created +  </li><li style="text-align:left;">　　"， total finalized = " + Chair.finalized);  </li><li style="text-align:left;">　　<strong>if</strong>(args[0].equals("before")) {  </li><li style="text-align:left;">　　　　System.out.println("gc():");  </li><li style="text-align:left;">　　　　System.gc();  </li><li style="text-align:left;">　　　　System.out.println("runFinalization():");  </li><li style="text-align:left;">　　　　System.runFinalization();  </li><li style="text-align:left;">　　}  </li><li style="text-align:left;">　　System.out.println("bye!");  </li><li style="text-align:left;">　　<strong>if</strong>(args[0].equals("after"))  </li><li style="text-align:left;">　　　  System.runFinalizersOnExit(<strong>true</strong>);  </li><li style="text-align:left;">　　}  </li><li style="text-align:left;">}  </li></ol> 
</div> 
<p style="margin-left:0;text-align:left;">      上面这个程序创建了许多Chair对象，而且在垃圾收集器开始运行后的某些时候，程序会停止创建Chair。由于垃圾收集器可能在任何时间运行，所以我们不能准确知道它在何时启动。因此，程序用一个名为gcrun的标记来指出垃圾收集器是否已经开始运行。利用第二个标记f，Chair可告诉main()它应停止对象的生成。这两个标记都是在finalize()内部设置的，它调用于垃圾收集期间。另两个static变量--created以及 finalized--分别用于跟踪已创建的对象数量以及垃圾收集器已进行完收尾工作的对象数量。最后，每个Chair都有它自己的（非 static）int i，所以能跟踪了解它具体的编号是多少。编号为47的Chair进行完收尾工作后，标记会设为true，最终结束Chair对象的创建过程。<br><br><strong>7. </strong><strong>关于垃圾回收的几点补充</strong><br> 　　经过上述的说明，可以发现垃圾回收有以下的几个特点：<br> 　　（1）垃圾收集发生的不可预知性：由于实现了不同的垃圾回收算法和采用了不同的收集机制，所以它有可能是定时发生，有可能是当出现系统空闲CPU资源时发生，也有可能是和原始的垃圾收集一样，等到内存消耗出现极限时发生，这与垃圾收集器的选择和具体的设置都有关系。<br> 　　（2）垃圾收集的精确性：主要包括2 个方面：（a）垃圾收集器能够精确标记活着的对象；（b）垃圾收集器能够精确地定位对象之间的引用关系。前者是完全地回收所有废弃对象的前提，否则就可能造成内存泄漏。而后者则是实现归并和复制等算法的必要条件。所有不可达对象都能够可靠地得到回收，所有对象都能够重新分配，允许对象的复制和对象内存的缩并，这样就有效地防止内存的支离破碎。<br> 　　（3）现在有许多种不同的垃圾收集器，每种有其算法且其表现各异，既有当垃圾收集开始时就停止应用程序的运行，又有当垃圾收集开始时也允许应用程序的线程运行，还有在同一时间垃圾收集多线程运行。<br> 　　（4）垃圾收集的实现和具体的JVM 以及JVM的内存模型有非常紧密的关系。不同的JVM 可能采用不同的垃圾收集，而JVM 的内存模型决定着该JVM可以采用哪些类型垃圾收集。现在，HotSpot 系列JVM中的内存系统都采用先进的面向对象的框架设计，这使得该系列JVM都可以采用最先进的垃圾收集。<br> 　　（5）随着技术的发展，现代垃圾收集技术提供许多可选的垃圾收集器，而且在配置每种收集器的时候又可以设置不同的参数，这就使得根据不同的应用环境获得最优的应用性能成为可能。<br> 　　针对以上特点，我们在使用的时候要注意：<br> 　　（1）不要试图去假定垃圾收集发生的时间，这一切都是未知的。比如，方法中的一个临时对象在方法调用完毕后就变成了无用对象，这个时候它的内存就可以被释放。<br> 　　（2）Java中提供了一些和垃圾收集打交道的类，而且提供了一种强行执行垃圾收集的方法--调用System.gc()，但这同样是个不确定的方法。Java 中并不保证每次调用该方法就一定能够启动垃圾收集，它只不过会向JVM发出这样一个申请，到底是否真正执行垃圾收集，一切都是个未知数。<br> 　　（3）挑选适合自己的垃圾收集器。一般来说，如果系统没有特殊和苛刻的性能要求，可以采用JVM的缺省选项。否则可以考虑使用有针对性的垃圾收集器，比如增量收集器就比较适合实时性要求较高的系统之中。系统具有较高的配置，有比较多的闲置资源，可以考虑使用并行标记/清除收集器。<br> 　　（4）关键的也是难把握的问题是内存泄漏。良好的编程习惯和严谨的编程态度永远是最重要的，不要让自己的一个小错误导致内存出现大漏洞。<br> 　　（5）尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域(scope)后，自动设置为null，暗示垃圾收集器来收集该对象，还必须注意该引用的对象是否被监听，如果有，则要去掉监听器，然后再赋空值。</p> 
<p style="margin-left:0;text-align:justify;"> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e9f02e16baa32afaa5d7e6141076e5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ESP32 使用 Arduino 实现 OTA 更新</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e85e11818bb41969185408907a8c86bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java.io.UTFDataFormatException: encoded string too long: 270976 bytes</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>