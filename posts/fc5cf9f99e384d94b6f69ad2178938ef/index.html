<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GoLong的学习之路，进阶，微服务之序列化协议，Protocol Buffers V3 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GoLong的学习之路，进阶，微服务之序列化协议，Protocol Buffers V3" />
<meta property="og:description" content="这章是接上一章，使用RPC包，序列化中没有详细去讲，因为这一块需要看的和学习的地方很多。并且这一块是RPC中可以说是最重要的一块，也是性能的重要影响因子。今天这篇主要会讲其使用方式。
文章目录 Protocol Buffers V3 背景以及概念如何使用？分配字段编号指定字段规则 数据类型`标量类型``复合类型`枚举其他消息类型嵌套类型更新消息类型未知字段Anyoneofoneof 特性向后兼容性问题 Maps JSON 映射 Protocol Buffers V3 背景以及概念 序列化是系统通信的基础组件，在大数据、AI框架和云原生等分布式系统中广泛使用。
当对象需要跨进程、跨语言、跨节点传输、持久化、状态读写、复制时，都需要进行序列化，其性能和易用性影响运行效率和开发效率。
但是对于序列化框架而言，业内将其分为两类：静态序列化框架，动态序列化框架。
其中各有优缺点：
静态序列化框架 不支持对象引用和多态、需要提前生成代码等原因，无法作为领域对象直接面向应用进行跨语言开发常见的有：protobuf、flatbuffer、thrift 动态序列化框架 提供了易用性和动态性，但不支持跨语言，且性能存在显著不足，并不能满足高吞吐、低延迟和大规模数据传输场景需求常见的有：JDK序列化、Kryo、Fst、Hessian、Pickle 但是前几天阿里推出了Fury，号称比JDK快了170倍，并且兼具静态序列化和动态序列化的优点。这个下一章会讲。目前的gRPC框架是用protobuf搭建的。所以咱们先让自己的项目成功运行起来再说。所以这个后面再说。
Protocol Buffers是google开源的一种结构数据序列化机制，可跨语言、跨平台。
相比XML、JSON、Thrift等其他序列化格式，Protocol Buffers的序列化和反序列化性能是很高的，且Protocol Buffers序列化后是二进制流，因此数据大小和传输速度是很好的。
所以它非常适合在数据存储或 RPC 数据交换的场景下使用。
以下使用手法是翻译自官网
如何使用？ 定义一个 .proto 文件
定义一个搜索请求消息格式，其中每个搜索请求都包含:
一个查询词字符串你感兴趣的查询结果所在的特定页码数每一页应展示的结果数 syntax = &#34;proto3&#34;; message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; } 文件的第一行指定使用 proto3 语法。 如果不这样写，protocol buffer编译器将假定你使用 proto2。这个声明必须是文件的第一个非空非注释行。
SearchRequest 消息定义指定了三个字段(名称/值对) ，每个字段表示希望包含在此类消息中的每一段数据。每个字段都有一个名称和一个类型 指定字段类型：
两个整数page_number 和 result_per_page和一个字符串query(上面的例子)但是也可以为字段指定组合类型，包括枚举和其他消息类型 proto3语法主要包括：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fc5cf9f99e384d94b6f69ad2178938ef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-11T16:17:41+08:00" />
<meta property="article:modified_time" content="2023-12-11T16:17:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GoLong的学习之路，进阶，微服务之序列化协议，Protocol Buffers V3</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>这章是接上一章，使用<a href="https://blog.csdn.net/Cheer_RIO/article/details/134897294?spm=1001.2014.3001.5501">RPC包</a>，序列化中没有详细去讲，因为这一块需要看的和学习的地方很多。并且这一块是RPC中可以说是最重要的一块，也是性能的重要影响因子。今天这篇主要会讲其使用方式。</p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Protocol_Buffers_V3__4" rel="nofollow">Protocol Buffers V3 背景以及概念</a></li><li><a href="#_32" rel="nofollow">如何使用？</a></li><li><ul><li><a href="#_91" rel="nofollow">分配字段编号</a></li><li><ul><li><a href="#_116" rel="nofollow">指定字段规则</a></li></ul> 
   </li><li><a href="#_145" rel="nofollow">数据类型</a></li><li><ul><li><a href="#_149" rel="nofollow">`标量类型`</a></li><li><a href="#_162" rel="nofollow">`复合类型`</a></li><li><ul><li><a href="#_166" rel="nofollow">枚举</a></li><li><a href="#_275" rel="nofollow">其他消息类型</a></li><li><a href="#_331" rel="nofollow">嵌套类型</a></li><li><a href="#_370" rel="nofollow">更新消息类型</a></li><li><a href="#_400" rel="nofollow">未知字段</a></li><li><a href="#Any_406" rel="nofollow">Any</a></li><li><a href="#oneof_428" rel="nofollow">oneof</a></li><li><ul><li><a href="#oneof__455" rel="nofollow">oneof 特性</a></li><li><a href="#_482" rel="nofollow">向后兼容性问题</a></li></ul> 
     </li><li><a href="#Maps_493" rel="nofollow">Maps</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#JSON__512" rel="nofollow">JSON 映射</a></li></ul> 
</div> 
<p></p> 
<h2><a id="Protocol_Buffers_V3__4"></a>Protocol Buffers V3 背景以及概念</h2> 
<p>序列化是系统通信的基础组件，在<code>大数据</code>、<code>AI框架</code>和<code>云原生</code>等<code>分布式系统</code>中广泛使用。</p> 
<p>当对象需要<code>跨进程</code>、<code>跨语言</code>、<code>跨节点传输</code>、<code>持久化</code>、<code>状态读写</code>、<code>复制</code>时，都需要进行<code>序列化</code>，其<code>性能</code>和<code>易用性</code>影响<code>运行效率</code>和<code>开发效率</code>。</p> 
<p>但是对于序列化框架而言，业内将其分为两类：静态序列化框架，动态序列化框架。</p> 
<p>其中各有优缺点：</p> 
<ul><li>静态序列化框架 
  <ul><li>不支持对象引用和多态、需要提前生成代码等原因，<strong>无法作为领域对象直接面向应用进行跨语言开发</strong></li><li>常见的有：<code>protobuf</code>、<code>flatbuffer</code>、<code>thrift</code></li></ul> </li><li>动态序列化框架 
  <ul><li>提供了易用性和动态性，但<strong>不支持跨语言，且性能存在显著不足</strong>，并不能满足高吞吐、低延迟和大规模数据传输场景需求</li><li>常见的有：<code>JDK序列化</code>、<code>Kryo</code>、<code>Fst</code>、<code>Hessian</code>、<code>Pickle</code></li></ul> </li></ul> 
<blockquote> 
 <p>但是前几天阿里推出了Fury，号称比<code>JDK快了170倍</code>，并且兼具静态序列化和动态序列化的优点。这个下一章会讲。目前的<code>gRPC框架</code>是用<code>protobuf</code>搭建的。所以咱们先让自己的项目成功运行起来再说。所以这个后面再说。</p> 
</blockquote> 
<p><code>Protocol Buffers</code>是<code>google开源</code>的一种结构数据序列化机制，可跨语言、跨平台。</p> 
<p>相比<code>XML</code>、<code>JSON</code>、<code>Thrift</code>等其他序列化格式，Protocol Buffers的序列化和反序列化性能是很高的，且Protocol Buffers序列化后是二进制流，因此数据大小和传输速度是很好的。</p> 
<p>所以它非常适合在<code>数据存储</code>或 <code>RPC 数据交换</code>的场景下使用。</p> 
<p>以下使用手法是翻译自<a href="https://developers.google.com/protocol-buffers/docs/proto3" rel="nofollow">官网</a></p> 
<h2><a id="_32"></a>如何使用？</h2> 
<p>定义一个 <code>.proto</code> 文件</p> 
<p>定义一个搜索请求消息格式，其中每个搜索请求都包含:</p> 
<ul><li>一个查询词字符串</li><li>你感兴趣的查询结果所在的特定页码数</li><li>每一页应展示的结果数</li></ul> 
<pre><code class="prism language-go">syntax <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span>

message SearchRequest <span class="token punctuation">{<!-- --></span>
  <span class="token builtin">string</span> query <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin">int32</span> page_number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token builtin">int32</span> result_per_page <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>文件的第一行指定使用 proto3 语法。</li></ul> 
<blockquote> 
 <p>如果不这样写，protocol buffer编译器将假定你使用 proto2。这个声明必须是文件的第一个非空非注释行。</p> 
</blockquote> 
<ul><li><code>SearchRequest</code> 消息定义指定了三个字段(名称/值对) ，每个字段表示希望包含在此类消息中的每一段数据。每个字段都有一个名称和一个类型</li></ul> 
<p><strong>指定字段类型：</strong></p> 
<ul><li>两个整数<code>page_number </code>和 <code>result_per_page</code>和一个字符串<code>query</code>(上面的例子)</li><li>但是也可以为字段指定组合类型，包括枚举和其他消息类型</li></ul> 
<p><strong>proto3语法主要包括：</strong></p> 
<ol><li>消息（<code>message</code>）定义</li><li>服务（<code>service</code>）定义</li><li>其他部分语法</li></ol> 
<p>一个message内的字段一般包含：</p> 
<ul><li>数据类型</li><li>字段名</li><li>字段编号tag</li></ul> 
<p><strong>添加更多消息类型：</strong></p> 
<p>可以在一个<code>.proto</code> 文件中定义多个消息类型。定义与 SearchRequest 消息类型对应的应答消息格式SearchResponse，就可以将其添加到同一个.proto文件中。</p> 
<pre><code class="prism language-go">message SearchRequest <span class="token punctuation">{<!-- --></span>
  <span class="token builtin">string</span> query <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin">int32</span> page_number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token builtin">int32</span> result_per_page <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

message SearchResponse <span class="token punctuation">{<!-- --></span>
 <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>添加注释：</strong></p> 
<p>要给你的<code>.proto</code>文件添加注释，需要使用<code>C/C++</code>风格的<code>//</code>和<code>/* ... */</code>语法。</p> 
<p><strong>保留字段:</strong></p> 
<ul><li>如果通过完全删除字段或将其注释掉来更新消息类型，那么未来的用户在对该类型进行自己的更新时可以重用字段号。</li><li>如果其他人以后加载旧版本的相同<code>.proto</code>文件，这可能会导致严重的问题，包括数据损坏，隐私漏洞等等。</li></ul> 
<h3><a id="_91"></a>分配字段编号</h3> 
<p>消息定义中的每个字段都有一个 <strong><code>唯一的编号</code></strong>。</p> 
<p>这些字段编号用来在消息二进制格式中标识字段，在消息类型使用后<strong>就不能再更改</strong>。</p> 
<p><code>注意</code>：</p> 
<ul><li>范围<code>1</code>到<code>15</code>中的字段编号需要<code>一个字节</code>进行编码，包括字段编号和字段类型</li><li>范围<code>16</code>到<code>2047</code>的字段编号采用<code>两个字节</code></li></ul> 
<p><strong>应该为经常使用的消息元素保留数字1到15的编号。切记为将来可能添加的经常使用的元素留出一些编号。</strong></p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          可以指定的最小字段数是 
         
        
          1 
         
        
          ，最大的字段数是 
         
         
         
           2 
          
         
           29 
          
         
        
          − 
         
        
          1 
         
        
       
         可以指定的最小字段数是1，最大的字段数是 2^{29}−1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9474em; vertical-align: -0.0833em;"></span><span class="mord cjk_fallback">可以指定的最小字段数是</span><span class="mord">1</span><span class="mord cjk_fallback">，最大的字段数是</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">29</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span></span><br> 即536,870,911。</p> 
<p>也不能使用<code>19000</code>到<code>19999</code>，它们是预留给<code>Protocol Buffers</code>协议实现的。</p> 
<p>如果你在你的<code>.proto</code>文件中使用了预留的编号<code>Protocol Buffers</code>编译器就会报错。</p> 
<p>同样，你也不能使用任何之前保留的字段编号。</p> 
<h4><a id="_116"></a>指定字段规则</h4> 
<p>消息字段可以是下列字段之一：</p> 
<ul><li><code>singular</code>: 格式正确的消息可以有这个字段的零个或一个(但不能多于一个)。这是 proto3语法的默认字段规则。</li><li><code>repeated</code>: 该字段可以在格式正确的消息中重复任意次数(包括零次)。重复值的顺序将被保留。</li><li></ul> 
<p>确保这种情况不会发生的一种方法是<code>指定已删除字段</code>的字段编号(和<code>/</code>或<code>名称</code>，这也可能导致 JSON 序列化问题)是保留的<code>reserved</code></p> 
<p>如果将来有任何用户尝试使用这些字段标识符，<code>protocol buffer编译器</code>将发出提示。</p> 
<pre><code class="prism language-go">message Foo <span class="token punctuation">{<!-- --></span>
  reserved <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">9</span> to <span class="token number">11</span><span class="token punctuation">;</span>
  reserved <span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意：不能在同一个<code>reserved</code>语句中<code>混合字段名</code>和<code>字段编号</code>。</p> 
<p>当你使用<code> protocol buffer 编译器</code>来运行<code>.proto文件</code>时，编译器用你选择的语言生成你需要使用文件中描述的消息类型，包括获取和设置字段值，将消息序列化为输出流，以及从输入流解析消息的代码。</p> 
<ul><li>对 <code>C++</code>来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。</li><li>对于<code> Java</code>，编译器生成一个.java 文件，每种消息类型都有一个类，还有一个特殊的 Builder 类用于创建消息类实例。</li><li>对于<code> Kotlin</code>，除了 Java 生成的代码之外，编译器还生成一个每种消息类型的 .kt 文件，包含一个 DSL，可用于简化消息实例的创建。</li><li><code>Python</code> 稍有不同ー Python 编译器为.proto文件中的每个消息类型生成一个带静态描述符的模块，然后与 metaclass 一起使用，在运行时创建必要的 Python 数据访问类。</li><li>对于 <code>Go</code>，编译器为文件中的每种消息类型生成一个类型（type）到一个.pb.go 文件。</li><li>对于 <code>Ruby</code>，编译器生成一个.rb 文件，其中包含一个包含消息类型的 Ruby 模块。</li><li>对于 <code>Objective-C</code>，编译器从每个.proto文件生成一个 pbobjc.h 和 pbobjc.m 文件，.proto文件中描述的每种消息类型都有一个类。</li><li>对于 <code>C#</code> ，编译器生从每个.proto文件生成一个.cs 文件。.proto文件中描述的每种消息类型都有一个类。</li><li>对于 <code>Dart</code>，编译器为文件中的每种消息类型生成一个.pb.dart 文件。</li></ul> 
<h3><a id="_145"></a>数据类型</h3> 
<p>数据类型：<code>标量类型</code>和<code>复合类型</code></p> 
<h4><a id="_149"></a><code>标量类型</code></h4> 
<p><img src="https://images2.imgbox.com/45/ba/6lzrr9Ct_o.png" alt="在这里插入图片描述"><br> 当解析消息时，如果编码消息不包含特定的 singular 元素，则解析对象中的相应字段将设置为该字段的默认值。</p> 
<ul><li>对于字符串，默认值为空字符串。</li><li>对于字节，默认值为空字节。</li><li>对于布尔值，默认值为 false。</li><li>对于数值类型，默认值为零。</li><li>对于枚举，默认值是第一个定义的枚举值，该值必须为0。</li><li>对于消息字段，未设置该字段。其确切值与语言有关。</li><li>repeated 字段的默认值为空(通常是适当语言中的空列表)。</li></ul> 
<blockquote> 
 <p><code>请注意</code>，对于标量消息字段，一旦消息被解析，就无法判断字段是显式设置为默认值(例如，是否一个布尔值是被设置为<code> false</code>)还是根本没有设置: 在定义消息类型时应该牢记这一点。例如，如果你不希望某个行为在默认情况下也发生，那么就不要设置一个布尔值，该布尔值在设置为 <code>false</code> 时会开启某些行为。还要注意，如果将标量消息字段设置为默认值，则该值将不会在传输过程中序列化。</p> 
</blockquote> 
<h4><a id="_162"></a><code>复合类型</code></h4> 
<p>复合类型包括：枚举、嵌套其他message、Any（Map，Oneof）等</p> 
<h5><a id="_166"></a>枚举</h5> 
<p>在定义消息类型时，你可能希望其中一个字段只能是预定义的值列表中的一个值。</p> 
<p>可以通过在消息定义中添加一个枚举，为每个可能的值添加一个常量来非常简单地完成这项工作。</p> 
<pre><code class="prism language-go">message SearchRequest <span class="token punctuation">{<!-- --></span>
  <span class="token builtin">string</span> query <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin">int32</span> page_number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token builtin">int32</span> result_per_page <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  enum Corpus <span class="token punctuation">{<!-- --></span>
    UNIVERSAL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    WEB <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    IMAGES <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    LOCAL <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    NEWS <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    PRODUCTS <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    VIDEO <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  Corpus corpus <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>Corpus enum</code> 的第一个常量映射为零: 每个 <code>enum </code>定义必须包含一个常量，该常量映射为零作为它的第一个元素。</p> 
<ol><li>必须有一个零值，这样我们就可以使用0作为数值默认值。</li><li>零值必须是第一个元素，以便与 proto2语义兼容，其中第一个枚举值总是默认值。</li></ol> 
<p>你可以通过将相同的值分配给不同的枚举常量来定义别名。为此，你需要将 <code>allow _ alias</code> 选项设置为<code> true</code>，否则，当发现别名时，<code>protocol 编译器</code>将生成错误消息。</p> 
<p><code>内部定义</code></p> 
<pre><code class="prism language-go">message MyMessage1 <span class="token punctuation">{<!-- --></span>
  enum EnumAllowingAlias <span class="token punctuation">{<!-- --></span>
    option allow_alias <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    UNKNOWN <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    STARTED <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    RUNNING <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
message MyMessage2 <span class="token punctuation">{<!-- --></span>
  enum EnumNotAllowingAlias <span class="token punctuation">{<!-- --></span>
    UNKNOWN <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    STARTED <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意：枚举的常数必须在32位整数的范围内。</p> 
<blockquote> 
 <p>由于枚举值在传输时使用<code>变长编码</code>，因此负值效率低，因此不推荐使用。</p> 
</blockquote> 
<p>可以在消息定义中定义枚举，如上面的例子所示，也可以在外面定义——这样就可以在<code>.proto</code>文件中的消息定义中重用这些枚举。</p> 
<p><code>外部定义</code></p> 
<pre><code class="prism language-go">enum Ezarten <span class="token punctuation">{<!-- --></span>
        option allow_alias <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//开启枚举值重复开关</span>
        ZARTEN1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        ZARTEN2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        ZARTEN3 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        ZARTEN4 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//开启option allow_alias = true后枚举值可以重复</span>
    <span class="token punctuation">}</span>

<span class="token comment">//定义一个message类型</span>
message ZartenOne <span class="token punctuation">{<!-- --></span>
    <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token builtin">int32</span> age <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token builtin">int32</span> height <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    Ezarten ezarten <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以使用<code>_MessageType_._EnumType_ </code>语法，使用在一个消息中声明的<code>enum类型</code>作为不同消息中的字段类型。</p> 
<p><code>使用消息内的枚举</code><br> 若枚举定义在内部，其他message要使用这个枚举，可以使用 “message名.枚举名”的形式:</p> 
<pre><code class="prism language-go"><span class="token comment">//定义一个message类型</span>
message ZartenOne <span class="token punctuation">{<!-- --></span>
    <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token builtin">int32</span> age <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token builtin">int32</span> height <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    enum Ezarten <span class="token punctuation">{<!-- --></span>
        ZARTEN1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        ZARTEN2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        ZARTEN3 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Ezarten ezarten <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//定义一个message类型</span>
message ZartenTwo <span class="token punctuation">{<!-- --></span>
    <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token builtin">int32</span> age <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token builtin">int32</span> height <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    ZartenOne<span class="token punctuation">.</span>Ezarten ezarten <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>当对一个使用了枚举的<code>.proto文件</code>运行 <code>protocol buffer</code> 编译器的时候，对于 <code>Java</code>，<code> Kotlin</code>,或 <code>C++</code> 生成的代码中将有一个对应的<code>enum</code>，或者对于 <code>Python</code> 会生成一个特殊的<code>EnumDescriptor</code>类，它被用于在运行时生成的类中创建一组带有整数值的符号常量。</p> 
</blockquote> 
<p>生成的代码可能会受到特定于语言的枚举数限制(单种语言的数量低于千)</p> 
<p><code>反序列化</code>过程中，不可识别的枚举值将保留在消息中，尽管当消息被反序列化时，这种值的表示方式<code>依赖</code>于语言。</p> 
<ul><li>开放枚举：在支持值超出指定符号范围<code>(如 C++ 和 Go)</code>的<code>开放枚举类型</code>的语言中，未知枚举值仅存储为其底层的整数表示形式。</li><li>闭合枚举类型：在具有<code>闭合枚举类型</code> <code>(如 Java)</code>的语言中，枚举中的一个类型将用于表示一个无法识别的值，并且可以使用特殊的访问器访问底层的整数。</li></ul> 
<p>在这两种情况下，如果消息被序列化，那么不可识别的值仍然会与消息一起被序列化。</p> 
<h5><a id="_275"></a>其他消息类型</h5> 
<p>你可以使用其他消息类型作为字段类型:</p> 
<pre><code class="prism language-go">message SearchResponse <span class="token punctuation">{<!-- --></span>
  repeated Result results <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

message Result <span class="token punctuation">{<!-- --></span>
  <span class="token builtin">string</span> url <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token builtin">string</span> title <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  repeated <span class="token builtin">string</span> snippets <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>如果你希望用作字段类型的消息类型已经在另一个.proto文件中定义了，该怎么办？</strong></p> 
<p>你可以通过 <code>import </code>来使用来自其他<code>.proto</code>文件的定义。要导入另一个<code>.proto </code>的定义，你需要在文件顶部添加一个<code>import</code>语句</p> 
<pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token string">"myproject/other_protos.proto"</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>默认情况下，只能从直接导入的<code>.proto</code>文件中使用定义。但是，有时你可能需要将 <code>.proto </code>文件移动到新的位置。你可以在旧目录放一个占位的<code>.proto</code>文件使用<code>import public </code>概念将所有导入转发到新位置，而不必直接移动<code>.proto</code>文件并修改所有的地方。</p> 
</blockquote> 
<p><code>import public</code>依赖项可以被任何导入包含<code>import public</code>语句的<code>proto</code>的代码传递依赖。<br> 语法：</p> 
<ul><li><code>import</code></li><li><code>import public</code></li></ul> 
<ol><li>相同的是，在<code>文件A</code>中两者可以直接引用它们上一级proto文件B的内容。</li><li>不同的是，若文件B内使用了<code>import</code>引用文件C，则文件A不能使用文件C的内容；</li></ol> 
<p><strong>若文件B内使用了import public引用文件C，则文件A可以使用文件C的内容。</strong></p> 
<p>类似于编程语言中的类是否可以继承的含义。</p> 
<p>文件：<code>new.proto</code></p> 
<pre><code class="prism language-go">所有的定义都被移到了这里
</code></pre> 
<p>文件：<code>old.proto</code><br> 这是所有客户端都要导入的原型</p> 
<pre><code class="prism language-go"><span class="token keyword">import</span> public <span class="token string">"new.proto"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">"other.proto"</span><span class="token punctuation">;</span>
</code></pre> 
<p>文件：<code>client.proto</code><br> 你可以使用<code>old.proto</code>和<code>new.proto</code>，但是不能使用<code> other.proto</code></p> 
<blockquote> 
 <p><code>protocol</code> 编译器使用命令行<code>-I/--proto_path</code>参数指定的一组目录中搜索导入的文件。如果没有给该命令行参数，则查看调用编译器的目录。</p> 
</blockquote> 
<blockquote> 
 <p>一般来说，你应该将<code>--proto_path</code>参数设置为项目的根目录并为所有导入使用正确的名称。</p> 
</blockquote> 
<h5><a id="_331"></a>嵌套类型</h5> 
<p>方式1：</p> 
<pre><code class="prism language-go">message SearchResponse <span class="token punctuation">{<!-- --></span>
  message Result <span class="token punctuation">{<!-- --></span>
    <span class="token builtin">string</span> url <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token builtin">string</span> title <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    repeated <span class="token builtin">string</span> snippets <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  repeated Result results <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>方式2：<br> 要在其父消息类型之外重用此消息类型，通过_Parent_._Type_使用。</p> 
<pre><code class="prism language-go">message SomeOtherMessage <span class="token punctuation">{<!-- --></span>
  SearchResponse<span class="token punctuation">.</span>Result result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>方式3：一层又一层嵌入其中</p> 
<pre><code class="prism language-go">message Outer <span class="token punctuation">{<!-- --></span>                  <span class="token comment">// Level 0</span>
  message MiddleAA <span class="token punctuation">{<!-- --></span>  <span class="token comment">// Level 1</span>
    message Inner <span class="token punctuation">{<!-- --></span>   <span class="token comment">// Level 2</span>
      <span class="token builtin">int64</span> ival <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token builtin">bool</span>  booly <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  message MiddleBB <span class="token punctuation">{<!-- --></span>  <span class="token comment">// Level 1</span>
    message Inner <span class="token punctuation">{<!-- --></span>   <span class="token comment">// Level 2</span>
      <span class="token builtin">int32</span> ival <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token builtin">bool</span>  booly <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_370"></a>更新消息类型</h5> 
<p>在不破坏任何现有代码的情况下更新消息类型非常简单：只需记住以下规则:</p> 
<ul><li>不要更改任何现有字段的字段编号</li><li>如果添加新字段 
  <ul><li>那么任何使用“旧”消息格式通过代码序列化的消息仍然可以通过新生成的代码进行解析。 
    <ul><li>你应该记住这些元素的<code>默认值</code>，以便新代码能够正确地与旧代码生成的消息交互。</li><li>类似地，新代码创建的消息可以通过旧代码解析: 旧的二进制文件在解析时直接忽略新字段。</li></ul> </li></ul> </li><li>字段可以被删除，只要字段编号不再用于你更新的消息类型。 
  <ul><li>你可能希望改为重命名字段，或者为其添加"<code>OBSOLETE_</code>“前缀，或者声明字段编号为<code>reserved</code>，以便<code>.proto</code>的未来用户不可能不小心重复使用这个编号。</li></ul> </li><li><code>int32</code>、 <code>uint32</code>、 <code>int64</code>、 <code>uint64</code>和 <code>bool</code>都是兼容的——这意味着你可以在不破坏向前或向后兼容性的情况下将一个字段从这些类型中的一个更改为另一个。</li><li>如果一个数字被解析到一个并不适当的类型中，你会得到与在 C++ 中将数字转换为该类型相同的效果 
  <ul><li><strong>例如，如果一个64位的数字被读作 int32，它将被截断为32位</strong></li></ul> </li><li><code>sint32</code>和 <code>sint64</code>相互兼容，但与其他整数类型不兼容</li><li><code>string</code>和<code>bytes</code>是兼容的，只要字节是有效的 <code>UTF-8</code></li><li>如果字节包含消息的编码版本，则<code>嵌入的消息与bytes兼容</code></li><li><code>fixed32</code>与 <code>sfixed32</code>兼容 <code>fixed64</code>与 <code>sfixed64</code>兼容。</li><li>对于<code>string</code>、<code>bytes</code>和<code>消息字段</code>，<code>optional</code>字段与<code>repeated</code>字段兼容。 
  <ul><li>给定重复字段的序列化数据作为输入 
    <ul><li>如果该字段是<code>基本类型</code>字段，期望该字段为可选字段的客户端将接受最后一个输入值</li><li>如果该字段是<code>消息类型</code>字段，则合并所有输入元素</li></ul> </li><li>注意，这对于数字类型，包括 <code>bools</code> 和 <code>enums</code>通常是不安全的。 
    <ul><li>重复的数值类型字段可以按<code>packed</code>的格式序列化，如果是<code>optional</code>字段，则无法正确解析这些字段</li></ul> </li></ul> </li><li><code>Enum</code> 在格式方面与<code> int32</code>、 <code>uint32</code>、 <code>int64</code>和 <code>uint64</code>兼容(请注意，如果不适合，值将被截断)。 
  <ul><li>但是要注意，当消息被反序列化时，客户端代码可能会区别对待它们: 
    <ul><li>例如，未被识别的 <code>proto3</code> <code>enum</code>将保留在消息中，但是当消息被反序列化时，这种类型的表示方式依赖于语言。<code>Int</code>字段总是保留它们的值。</li></ul> </li></ul> </li><li>将单个值更改为新的<code>oneof</code>成员是安全的，并且二进制兼容。 
  <ul><li>如果确保没有代码一次设置多个字段，那么将<code>多个字段</code>移动到<code>新的oneof字段</code>中可能是安全的。</li><li>将任何字段移动到现有的字段中都是不安全的。</li></ul> </li></ul> 
<h5><a id="_400"></a>未知字段</h5> 
<p>未知字段是格式良好的协议缓冲区序列化数据，表示解析器不识别的字段。<br> <strong>当<code>旧二进制</code>解析由新二进制发送的带<code>有新字段</code>的数据时，这些<code>新字段</code>将成为旧二进制中的<code>未知字段</code>。</strong></p> 
<p>在<code>3.5版本</code>中，我们重新引入了未知字段的保存来匹配<code> proto2</code>行为。在3.5及以后的版本中，<code>解析期间保留未知字段，并将其包含在序列化输出中</code></p> 
<h5><a id="Any_406"></a>Any</h5> 
<p><code>Any </code>消息类型允许你将消息作为嵌入类型使用，而不需要其<code>.proto</code>定义。<code>Any</code>包含一个任意序列化的字节消息，以及一个解析为该消息的类型作为消息的全局唯一标识符的URL</p> 
<p>要使用<code>Any</code>类型，需要导入<code>google/protobuf/any.proto</code></p> 
<p>给定消息类型的默认类型 <code>URL</code> 是<code>type.googleapis.com/_packagename_._messagename_</code></p> 
<pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token string">"google/protobuf/any.proto"</span><span class="token punctuation">;</span>

message ErrorStatus <span class="token punctuation">{<!-- --></span>
  <span class="token builtin">string</span> message <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  repeated google<span class="token punctuation">.</span>protobuf<span class="token punctuation">.</span>Any details <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>不同的语言实现将支持运行库助手以类型安全的方式打包和解包 Any值：</p> 
<ul><li> <p>在java中，Any类型会有特殊的pack()和unpack()访问器，</p> </li><li> <p>在C++中，Any类型会有特殊的PackFrom()和UnpackTo()方法。</p> </li></ul> 
<h5><a id="oneof_428"></a>oneof</h5> 
<p>如果你有一条包含多个字段的消息，并且<code>最多</code>同时设置其中一个字段，那么你可以通过使用<code>oneof</code>来实现并节省内存，<code>优化</code></p> 
<p><code>oneof</code>字段类似于常规字段，只不过<code>oneof</code>中的所有字段共享内存，而且最多可以同时设置一个字段。</p> 
<p>设置其中的任何成员都会自动清除所有其他成员。</p> 
<p>根据所选择的语言，可以使用特殊 <code>case()</code>或 <code>WhichOneof()</code> 方法检查 <code>oneof</code> 中的哪个值被设置</p> 
<p>在生成的代码中，其中一个字段具有与常规字段相同的 <code>getter </code>和 <code>setter</code></p> 
<p>你还可以获得一个特殊的方法来检查其中一个设置了哪个值</p> 
<pre><code class="prism language-go">message SampleMessage <span class="token punctuation">{<!-- --></span>
  oneof test_oneof <span class="token punctuation">{<!-- --></span>
    <span class="token builtin">string</span> name <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    SubMessage sub_message <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>然后将其中一个字段添加到该字段的定义中。</p> 
<p>你可以添加任何类型的字段，除了<code>map字段</code>和<code>repeated</code>字段</p> 
<p>oneof有很多特性，具体的个人建议去看<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" rel="nofollow">文档</a>：</p> 
<h6><a id="oneof__455"></a>oneof 特性</h6> 
<ul><li>设置一个字段将自动清除该字段的所有其他成员。 
  <ul><li>因此，如果你设置了多个 oneof字段，那么只有最后设置的字段仍然具有值。</li></ul> </li><li>如果解析器在连接中遇到同一个成员的多个成员，则只有最后看到的成员用于解析消息。</li><li>oneof 不支持repeated。</li><li>反射 api 适用于 oneof 字段。</li><li>如果将 oneof 字段设置为默认值(例如将 int32 oneof 字段设置为0) ，则将设置该字段的“ case”，并在连接上序列化该值。</li><li>如果使用 C++ ，确保你的代码不会导致内存崩溃。 
  <ul><li>因为通过调用 set_name()方法已经删除了 sub_message</li></ul> </li></ul> 
<pre><code class="prism language-go">SampleMessage message<span class="token punctuation">;</span>
SubMessage<span class="token operator">*</span> sub_message <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">mutable_sub_message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
message<span class="token punctuation">.</span><span class="token function">set_name</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 删除name</span>
sub_message<span class="token operator">-</span><span class="token operator">&gt;</span>set_<span class="token operator">...</span>            <span class="token comment">// 这里的崩溃</span>
</code></pre> 
<ul><li>在C++中，如果你使用<code>Swap()</code>两个 <code>oneof </code>消息，每个消息，两个消息将拥有对方的值</li></ul> 
<pre><code class="prism language-go">SampleMessage msg1<span class="token punctuation">;</span>
msg1<span class="token punctuation">.</span><span class="token function">set_name</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
SampleMessage msg2<span class="token punctuation">;</span>
msg2<span class="token punctuation">.</span><span class="token function">mutable_sub_message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
msg1<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">CHECK</span><span class="token punctuation">(</span>msg1<span class="token punctuation">.</span><span class="token function">has_sub_message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">CHECK</span><span class="token punctuation">(</span>msg2<span class="token punctuation">.</span><span class="token function">has_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="_482"></a>向后兼容性问题</h6> 
<p>添加或删除一个字段时要小心。</p> 
<ul><li>如果检查<code>one of</code>的值返回<code>None</code>/<code>NOT_SET</code>，这可能意味着 <code>one of </code>没有被设置，或者它已经被设置为<code>one of</code>的不同版本中的一个字段。</li><li>这没有办法区分，因为没有办法知道未知字段是否是 oneof 的成员。</li></ul> 
<p>标签重用问题:</p> 
<ul><li><strong>将字段<code>移入</code>或<code>移出</code> <code>oneof</code></strong>：在序列化和解析消息之后，你可能会丢失一些信息(某些字段将被清除)。但是，你可以安全地将单个字段移动到新的<code> oneof</code> 字段中，并且如果已知只设置了一个字段，则可以移动多个字段。</li><li><strong>删除一个<code>oneof </code>字段再添加回来</strong>：这可能会在消息被序列化和解析后清除当前设置的 oneof 字段。</li><li><strong>拆分或合并<code>oneof</code></strong>：这与移动常规字段有类似的问题。</li></ul> 
<h5><a id="Maps_493"></a>Maps</h5> 
<p>如果你想创建一个关联映射作为你数据定义的一部分。</p> 
<blockquote> 
 <p>map&lt;key_type, value_type&gt; map_field = N;</p> 
</blockquote> 
<ul><li>其中<code>key_type</code>可以是任何整型或字符串类型(<strong>除了浮点类型和字节以外的任何标量类型</strong>)</li><li><code>value_type</code>可以是除另一个映射以外的任何类型。</li></ul> 
<pre><code class="prism language-go"><span class="token keyword">map</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> Project<span class="token operator">&gt;</span> projects <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>映射字段不能重复。</li><li>映射值的有线格式排序和映射迭代排序是未定义的，因此不能依赖于映射项的特定排序。</li><li>当为 <code>.proto </code>生成文本格式时，映射按键排序。数字键按数字排序。</li><li>当从连接解析或合并时，如果有重复的映射键，则使用最后看到的键。当从文本格式解析映射时，如果有重复的键，解析可能会失败</li><li>如果为映射字段提供了键但没有值，则该字段序列化时的行为与语言相关。在 <code>C++ </code>、 <code>Java</code>、<code> Kotlin</code> 和 <code>Python</code> 中，类型的默认值是序列化的，而在其他语言中，没有任何值是序列化的。</li></ul> 
<h2><a id="JSON__512"></a>JSON 映射</h2> 
<p><code>proto3</code>支持 <code>JSON </code>的规范编码，使得系统之间更容易共享数据。下表按类型逐一描述了编码。</p> 
<p>如果<code> json 编码</code>的数据中缺少某个值，或者该值为 null，那么在解析为<code>protocol buffer</code>时，该值将被解释为适当的默认值。如果一个字段在 <code>protocol buffer </code>中具有默认值，为了节省空间，默认情况下 <code>json </code>编码的数据中将省略该字段。具体实现可以提供在<code>JSON编码</code>中可选的默认值。</p> 
<p><img src="https://images2.imgbox.com/1e/8b/TJauqP7i_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/92/4c/3Ay2wvd2_o.png" alt="在这里插入图片描述"><br> 一个proto3协议 JSON 实现可能提供以下选项:</p> 
<ul><li><strong>提供默认值的字段</strong>：<code>在proto3 JSON 输出中</code>，值为默认值的字段被省略。可以提供一个选项，用默认值覆盖此行为和输出字段。</li><li><strong>忽略位置字段</strong>：<code>在缺省情况下</code>，Proto3 JSON 解析器应该拒绝未知字段，但在解析过程中可能会提供一个忽略未知字段的选项。</li><li><strong>使用 proto 字段名而不是小驼峰名称</strong>：<code>默认情况下</code>，proto3 JSON 打印机应该将字段名转换为 <code>lowerCamelCase</code>，并使用它作为 <code>JSON 名称</code>。 
  <ul><li>可以提供一个选项，用原型字段名作为 <code>JSON </code>名。需要<code>协议3 JSON 解析器同时接受转换后的</code> lowerCamelCase `名称和原始字段名称。</li></ul> </li><li><strong>以整数而不是字符串形式展示枚举值</strong>：<code>在 JSON 输出中</code>，默认情况下使用枚举值的名称。可以提供一个选项来代替使用枚举值的数值。</li></ul> 
<p>剩下的可以看：<a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Value" rel="nofollow">官方文档</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b0710e56b7370845f6cb67b34a9b952/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Django中db.sqlite3 文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b5012dfb910c216c9d7de37ac321c4f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">分布式批处理框架在大促场景下的设计与实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>