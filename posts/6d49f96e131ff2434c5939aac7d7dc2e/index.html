<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>libevent1.4 阅读记录二 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="libevent1.4 阅读记录二" />
<meta property="og:description" content="libevent大概框架已经了解，现在我们通过libevent封装的epoll了解一下libevent的I/O模型。
epollop结构体
1 struct epollop { 2 struct evepoll *fds;　//文件描述符事件数组，每个文件描述符对应的事件，这里将读写事件分开了。记录所有需要监听的事件 /* due to limitations in the epoll interface, we need to keep track of * all file descriptors outself. */ struct evepoll { struct event *evread; struct event *evwrite; }; 3 int nfds;　//文件描述符数量 4 struct epoll_event *events;　//epoll的事件结构数组
typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ } __EPOLL_PACKED; 在epoll_wait中返回就只包含2个信息：事件类型及其文件描述符。这是用来缓存此刻监听到的发生事件的信息的。 5 int nevents;　//可以缓存监听的events的数量 6 int epfd;　//epoll_create返回的epoll句柄 7 }; 我们仍然找一个demo，从demo的调用方式来分析libevent的epoll工作方式，参考libevent在异步socket中的使用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6d49f96e131ff2434c5939aac7d7dc2e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-21T22:42:00+08:00" />
<meta property="article:modified_time" content="2018-11-21T22:42:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">libevent1.4 阅读记录二</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>libevent大概框架已经了解，现在我们通过libevent封装的epoll了解一下libevent的I/O模型。</p> 
 <p>epollop结构体</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008080;">1</span> <span style="color:#0000ff;">struct</span><span style="color:#000000;"> epollop {
</span><span style="color:#008080;">2</span>     <span style="color:#0000ff;">struct</span> evepoll *<span style="color:#000000;">fds;　　　　<span style="color:#339966;">//文件描述符事件数组，每个文件描述符对应的事件，这里将读写事件分开了。记录所有需要监听的事件</span></span></pre> 
  <div style="color:#d4d4d4;font-family:'Droid Sans Mono', monospace, monospace, 'Droid Sans Fallback';font-weight:normal;font-size:14px;line-height:19px;"> 
   <div style="margin-left:210px;"> 
    <span style="color:#608b4e;">/* due to limitations in the epoll interface, we need to keep track of</span> 
   </div> 
   <div style="margin-left:210px;"> 
    <span style="color:#608b4e;"> * all file descriptors outself.</span> 
   </div> 
   <div style="margin-left:210px;"> 
    <span style="color:#608b4e;"> */</span> 
   </div> 
   <div style="margin-left:210px;"> 
    <span style="color:#569cd6;">struct<span style="color:#d4d4d4;"> evepoll {<!-- --></span></span> 
   </div> 
   <div style="margin-left:210px;"> 
    <span style="color:#d4d4d4;">    <span style="color:#569cd6;">struct<span style="color:#d4d4d4;"> event <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">evread;</span></span></span></span></span> 
   </div> 
   <div style="margin-left:210px;"> 
    <span style="color:#d4d4d4;">    <span style="color:#569cd6;">struct<span style="color:#d4d4d4;"> event <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">evwrite;</span></span></span></span></span> 
   </div> 
   <div style="margin-left:210px;"> 
    <span style="color:#d4d4d4;">};</span> 
   </div> 
  </div> 
  <pre><span style="color:#008080;">3</span>     <span style="color:#0000ff;">int</span><span style="color:#000000;"> nfds;　　　　　　　　　　<span style="color:#339966;">//文件描述符数量
</span></span><span style="color:#008080;">4</span>     <span style="color:#0000ff;">struct</span> epoll_event *<span style="color:#000000;">events;　　<span style="color:#339966;">//epoll的事件结构数组</span><br></span></pre> 
  <div style="color:#d4d4d4;font-family:'Droid Sans Mono', monospace, monospace, 'Droid Sans Fallback';font-weight:normal;font-size:14px;line-height:19px;"> 
   <div style="margin-left:270px;"> 
    <span style="color:#569cd6;">typedef<span style="color:#d4d4d4;"> <span style="color:#569cd6;">union<span style="color:#d4d4d4;"> epoll_data</span></span></span></span> 
   </div> 
   <div style="margin-left:270px;"> 
    <span style="color:#d4d4d4;">{<!-- --></span> 
   </div> 
   <div style="margin-left:270px;"> 
    <span style="color:#d4d4d4;"> <span style="color:#569cd6;">void<span style="color:#d4d4d4;"> <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">ptr;</span></span></span></span></span> 
   </div> 
   <div style="margin-left:270px;"> 
    <span style="color:#d4d4d4;"> <span style="color:#569cd6;">int<span style="color:#d4d4d4;"> fd;</span></span></span> 
   </div> 
   <div style="margin-left:270px;"> 
    <span style="color:#d4d4d4;"> <span style="color:#4ec9b0;">uint32_t<span style="color:#d4d4d4;"> u32;</span></span></span> 
   </div> 
   <div style="margin-left:270px;"> 
    <span style="color:#d4d4d4;"> <span style="color:#4ec9b0;">uint64_t<span style="color:#d4d4d4;"> u64;</span></span></span> 
   </div> 
   <div style="margin-left:270px;"> 
    <span style="color:#d4d4d4;">} <span style="color:#4ec9b0;">epoll_data_t<span style="color:#d4d4d4;">;</span></span></span> 
   </div> 
   <br> 
   <div style="margin-left:270px;"> 
    <span style="color:#569cd6;">struct<span style="color:#d4d4d4;"> <span style="color:#4ec9b0;">epoll_event</span></span></span> 
   </div> 
   <div style="margin-left:270px;"> 
    <span style="color:#d4d4d4;">{<!-- --></span> 
   </div> 
   <div style="margin-left:270px;"> 
    <span style="color:#d4d4d4;"> <span style="color:#4ec9b0;">uint32_t<span style="color:#d4d4d4;"> events;  <span style="color:#608b4e;">/* Epoll events */</span></span></span></span> 
   </div> 
   <div style="margin-left:270px;"> 
    <span style="color:#d4d4d4;"> <span style="color:#4ec9b0;">epoll_data_t<span style="color:#d4d4d4;"> data;    <span style="color:#608b4e;">/* User data variable */</span></span></span></span> 
   </div> 
   <div style="margin-left:270px;"> 
    <span style="color:#d4d4d4;">} __EPOLL_PACKED;</span> 
   </div> 
   <div style="margin-left:270px;"> 
    <span style="color:#339966;">在epoll_wait中返回就只包含2个信息：事件类型及其文件描述符。这是用来缓存此刻监听到的发生事件的信息的。</span> 
   </div> 
  </div> 
  <pre><span style="color:#008080;">5</span>     <span style="color:#0000ff;">int</span><span style="color:#000000;"> nevents;　　　　　　<span style="color:#339966;">//可以缓存监听的events的数量
</span></span><span style="color:#008080;">6</span>     <span style="color:#0000ff;">int</span><span style="color:#000000;"> epfd;　　　　　　　　<span style="color:#339966;">//epoll_create返回的epoll句柄
</span></span><span style="color:#008080;">7</span> };</pre> 
 </div> 
 <p>我们仍然找一个demo，从demo的调用方式来分析libevent的epoll工作方式，参考<a href="https://blog.csdn.net/maikforever/article/details/7520794">libevent在异步socket中的使用</a></p> 
 <p>第一个例子，虽然有些缺憾，但胜在短小，方便理解，后面可以在去看后面2个例子。由于libevent的signal是嵌入到I/O模型中的，和前面一样，这里跳过signal部分，后面再说。</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008080;">  1</span> <span style="color:#008000;">/*</span><span style="color:#008000;"> Port to listen on. </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">  2</span> <span style="color:#0000ff;">#define</span> SERVER_PORT 5555
<span style="color:#008080;">  3</span> 
<span style="color:#008080;">  4</span> <span style="color:#008000;">/*</span><span style="color:#008000;">*
</span><span style="color:#008080;">  5</span> <span style="color:#008000;"> * 这个结构是指定的客户端数据，这个例子中只指定了读事件对象。
</span><span style="color:#008080;">  6</span>  <span style="color:#008000;">*/</span>
<span style="color:#008080;">  7</span> <span style="color:#0000ff;">struct</span><span style="color:#000000;"> client
</span><span style="color:#008080;">  8</span> <span style="color:#000000;">{
</span><span style="color:#008080;">  9</span>     <span style="color:#0000ff;">struct</span> <span style="color:#0000ff;">event</span><span style="color:#000000;"> ev_read;
</span><span style="color:#008080;"> 10</span> <span style="color:#000000;">};
</span><span style="color:#008080;"> 11</span> 
<span style="color:#008080;"> 12</span> <span style="color:#008000;">/*</span><span style="color:#008000;">*
</span><span style="color:#008080;"> 13</span> <span style="color:#008000;"> * 将一个socket设置成非阻塞模式
</span><span style="color:#008080;"> 14</span>  <span style="color:#008000;">*/</span>
<span style="color:#008080;"> 15</span> <span style="color:#0000ff;">int</span>
<span style="color:#008080;"> 16</span> setnonblock(<span style="color:#0000ff;">int</span><span style="color:#000000;"> fd)
</span><span style="color:#008080;"> 17</span> <span style="color:#000000;">{
</span><span style="color:#008080;"> 18</span>     <span style="color:#0000ff;">int</span><span style="color:#000000;"> flags;
</span><span style="color:#008080;"> 19</span> 
<span style="color:#008080;"> 20</span>     flags =<span style="color:#000000;"> fcntl(fd, F_GETFL);
</span><span style="color:#008080;"> 21</span>     <span style="color:#0000ff;">if</span> (flags &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
</span><span style="color:#008080;"> 22</span>         <span style="color:#0000ff;">return</span><span style="color:#000000;"> flags;
</span><span style="color:#008080;"> 23</span>     flags |=<span style="color:#000000;"> O_NONBLOCK;
</span><span style="color:#008080;"> 24</span>     <span style="color:#0000ff;">if</span> (fcntl(fd, F_SETFL, flags) &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
</span><span style="color:#008080;"> 25</span>         <span style="color:#0000ff;">return</span> -<span style="color:#800080;">1</span><span style="color:#000000;">;
</span><span style="color:#008080;"> 26</span> 
<span style="color:#008080;"> 27</span>     <span style="color:#0000ff;">return</span> <span style="color:#800080;">0</span><span style="color:#000000;">;
</span><span style="color:#008080;"> 28</span> <span style="color:#000000;">}
</span><span style="color:#008080;"> 29</span> 
<span style="color:#008080;"> 30</span> <span style="color:#008000;">/*</span><span style="color:#008000;">*
</span><span style="color:#008080;"> 31</span> <span style="color:#008000;"> * 这个函数当客户端的socket可读时由libevent调用
</span><span style="color:#008080;"> 32</span>  <span style="color:#008000;">*/</span>
<span style="color:#008080;"> 33</span> <span style="color:#0000ff;">void</span>
<span style="color:#008080;"> 34</span> on_read(<span style="color:#0000ff;">int</span> fd, <span style="color:#0000ff;">short</span> ev, <span style="color:#0000ff;">void</span> *<span style="color:#000000;">arg)
</span><span style="color:#008080;"> 35</span> <span style="color:#000000;">{
</span><span style="color:#008080;"> 36</span>     <span style="color:#0000ff;">struct</span> client *client = (<span style="color:#0000ff;">struct</span> client *<span style="color:#000000;">)arg;
</span><span style="color:#008080;"> 37</span>     u_char buf[<span style="color:#800080;">8196</span><span style="color:#000000;">];
</span><span style="color:#008080;"> 38</span>     <span style="color:#0000ff;">int</span><span style="color:#000000;"> len, wlen;
</span><span style="color:#008080;"> 39</span> 
<span style="color:#008080;"> 40</span>     len = read(fd, buf, <span style="color:#0000ff;">sizeof</span><span style="color:#000000;">(buf));
</span><span style="color:#008080;"> 41</span>     <span style="color:#0000ff;">if</span> (len == <span style="color:#800080;">0</span><span style="color:#000000;">)
</span><span style="color:#008080;"> 42</span> <span style="color:#000000;">    {
</span><span style="color:#008080;"> 43</span>         <span style="color:#008000;">/*</span><span style="color:#008000;"> 客户端断开连接，在这里移除读事件并且释放客户数据结构 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;"> 44</span>         printf(<span style="color:#800000;">"</span><span style="color:#800000;">Client disconnected.\n</span><span style="color:#800000;">"</span><span style="color:#000000;">);
</span><span style="color:#008080;"> 45</span> <span style="color:#000000;">        close(fd);
</span><span style="color:#008080;"> 46</span>         event_del(&amp;client-&gt;<span style="color:#000000;">ev_read);
</span><span style="color:#008080;"> 47</span>         <span style="color:#0000ff;">free</span><span style="color:#000000;">(client);
</span><span style="color:#008080;"> 48</span>         <span style="color:#0000ff;">return</span><span style="color:#000000;">;
</span><span style="color:#008080;"> 49</span> <span style="color:#000000;">    }
</span><span style="color:#008080;"> 50</span>     <span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span> (len &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
</span><span style="color:#008080;"> 51</span> <span style="color:#000000;">    {
</span><span style="color:#008080;"> 52</span>         <span style="color:#008000;">/*</span><span style="color:#008000;"> 出现了其它的错误，在这里关闭socket，移除事件并且释放客户数据结构 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;"> 53</span>         printf(<span style="color:#800000;">"</span><span style="color:#800000;">Socket failure, disconnecting client: %s</span><span style="color:#800000;">"</span><span style="color:#000000;">,
</span><span style="color:#008080;"> 54</span> <span style="color:#000000;">               strerror(errno));
</span><span style="color:#008080;"> 55</span> <span style="color:#000000;">        close(fd);
</span><span style="color:#008080;"> 56</span>         event_del(&amp;client-&gt;<span style="color:#000000;">ev_read);
</span><span style="color:#008080;"> 57</span>         <span style="color:#0000ff;">free</span><span style="color:#000000;">(client);
</span><span style="color:#008080;"> 58</span>         <span style="color:#0000ff;">return</span><span style="color:#000000;">;
</span><span style="color:#008080;"> 59</span> <span style="color:#000000;">    }
</span><span style="color:#008080;"> 60</span> 
<span style="color:#008080;"> 61</span> 
<span style="color:#008080;"> 62</span> 
<span style="color:#008080;"> 63</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> 为了简便，我们直接将数据写回到客户端。通常我们不能在非阻塞的应用程序中这么做，
</span><span style="color:#008080;"> 64</span> <span style="color:#008000;">     * 我们应该将数据放到队列中，等待可写事件的时候再写回客户端。 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;"> 65</span>     wlen =<span style="color:#000000;"> write(fd, buf, len);
</span><span style="color:#008080;"> 66</span>     <span style="color:#0000ff;">if</span> (wlen &lt;<span style="color:#000000;"> len)
</span><span style="color:#008080;"> 67</span> <span style="color:#000000;">    {
</span><span style="color:#008080;"> 68</span>         <span style="color:#008000;">/*</span><span style="color:#008000;"> 我们没有把所有数据都写回。如果我们有适当的队列/缓存机制，
</span><span style="color:#008080;"> 69</span> <span style="color:#008000;">         * 我们能够在再次的可写事件中再次写入剩余的数据。因为这是一个简单的例子，
</span><span style="color:#008080;"> 70</span> <span style="color:#008000;">         * 我们仅仅舍去了没有写入的数据。 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;"> 71</span>         printf(<span style="color:#800000;">"</span><span style="color:#800000;">Short write, not all data echoed back to client.\n</span><span style="color:#800000;">"</span><span style="color:#000000;">);
</span><span style="color:#008080;"> 72</span> <span style="color:#000000;">    }
</span><span style="color:#008080;"> 73</span> <span style="color:#000000;">}
</span><span style="color:#008080;"> 74</span> 
<span style="color:#008080;"> 75</span> <span style="color:#008000;">/*</span><span style="color:#008000;">*
</span><span style="color:#008080;"> 76</span> <span style="color:#008000;"> * 当有一个连接请求准备被接受时，这个函数将被libevent调用。 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;"> 77</span> <span style="color:#0000ff;">void</span>
<span style="color:#008080;"> 78</span> on_accept(<span style="color:#0000ff;">int</span> fd, <span style="color:#0000ff;">short</span> ev, <span style="color:#0000ff;">void</span> *<span style="color:#000000;">arg)
</span><span style="color:#008080;"> 79</span> <span style="color:#000000;">{
</span><span style="color:#008080;"> 80</span>     <span style="color:#0000ff;">int</span><span style="color:#000000;"> client_fd;
</span><span style="color:#008080;"> 81</span>     <span style="color:#0000ff;">struct</span><span style="color:#000000;"> sockaddr_in client_addr;
</span><span style="color:#008080;"> 82</span>     socklen_t client_len = <span style="color:#0000ff;">sizeof</span><span style="color:#000000;">(client_addr);
</span><span style="color:#008080;"> 83</span>     <span style="color:#0000ff;">struct</span> client *<span style="color:#000000;">client;
</span><span style="color:#008080;"> 84</span> 
<span style="color:#008080;"> 85</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> 接受新的连接 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;"> 86</span>     client_fd = accept(fd, (<span style="color:#0000ff;">struct</span> sockaddr *)&amp;client_addr, &amp;<span style="color:#000000;">client_len);
</span><span style="color:#008080;"> 87</span>     <span style="color:#0000ff;">if</span> (client_fd == -<span style="color:#800080;">1</span><span style="color:#000000;">)
</span><span style="color:#008080;"> 88</span> <span style="color:#000000;">    {
</span><span style="color:#008080;"> 89</span>         warn(<span style="color:#800000;">"</span><span style="color:#800000;">accept failed</span><span style="color:#800000;">"</span><span style="color:#000000;">);
</span><span style="color:#008080;"> 90</span>         <span style="color:#0000ff;">return</span><span style="color:#000000;">;
</span><span style="color:#008080;"> 91</span> <span style="color:#000000;">    }
</span><span style="color:#008080;"> 92</span> 
<span style="color:#008080;"> 93</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> 设置客户端socket为非阻塞模式。 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;"> 94</span>     <span style="color:#0000ff;">if</span> (setnonblock(client_fd) &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
</span><span style="color:#008080;"> 95</span>         warn(<span style="color:#800000;">"</span><span style="color:#800000;">failed to set client socket non-blocking</span><span style="color:#800000;">"</span><span style="color:#000000;">);
</span><span style="color:#008080;"> 96</span> 
<span style="color:#008080;"> 97</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> 我们接受了一个新的客户，分配一个新的客户数据结构对象来保存这个客户的状态。 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;"> 98</span>     client = <span style="color:#0000ff;">calloc</span>(<span style="color:#800080;">1</span>, <span style="color:#0000ff;">sizeof</span>(*<span style="color:#000000;">client));
</span><span style="color:#008080;"> 99</span>     <span style="color:#0000ff;">if</span> (client ==<span style="color:#000000;"> NULL)
</span><span style="color:#008080;">100</span>         err(<span style="color:#800080;">1</span>, <span style="color:#800000;">"</span><span style="color:#800000;">malloc failed</span><span style="color:#800000;">"</span><span style="color:#000000;">);
</span><span style="color:#008080;">101</span> 
<span style="color:#008080;">102</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> 设置读事件，libevent将在客户端socket可读时调用on_read函数。
</span><span style="color:#008080;">103</span> <span style="color:#008000;">     * 我们也会我们也会不断的响应读事件，所以我们不用在每次读取时再次添加读事件。 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">104</span>     event_set(&amp;client-&gt;ev_read, client_fd, EV_READ|<span style="color:#000000;">EV_PERSIST, on_read,
</span><span style="color:#008080;">105</span> <span style="color:#000000;">              client);
</span><span style="color:#008080;">106</span> 
<span style="color:#008080;">107</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> 设置的事件并没有激活，使用添加事件让其激活。 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">108</span>     event_add(&amp;client-&gt;<span style="color:#000000;">ev_read, NULL);
</span><span style="color:#008080;">109</span> 
<span style="color:#008080;">110</span>     printf(<span style="color:#800000;">"</span><span style="color:#800000;">Accepted connection from %s\n</span><span style="color:#800000;">"</span><span style="color:#000000;">,
</span><span style="color:#008080;">111</span> <span style="color:#000000;">           inet_ntoa(client_addr.sin_addr));
</span><span style="color:#008080;">112</span> <span style="color:#000000;">}
</span><span style="color:#008080;">113</span> 
<span style="color:#008080;">114</span> <span style="color:#0000ff;">int</span>
<span style="color:#008080;">115</span> main(<span style="color:#0000ff;">int</span> argc, <span style="color:#0000ff;">char</span> **<span style="color:#000000;">argv)
</span><span style="color:#008080;">116</span> <span style="color:#000000;">{
</span><span style="color:#008080;">117</span>     <span style="color:#0000ff;">int</span><span style="color:#000000;"> listen_fd;
</span><span style="color:#008080;">118</span>     <span style="color:#0000ff;">struct</span><span style="color:#000000;"> sockaddr_in listen_addr;
</span><span style="color:#008080;">119</span>     <span style="color:#0000ff;">int</span> reuseaddr_on = <span style="color:#800080;">1</span><span style="color:#000000;">;
</span><span style="color:#008080;">120</span> 
<span style="color:#008080;">121</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> 接受连接请求的事件对象。 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">122</span>     <span style="color:#0000ff;">struct</span> <span style="color:#0000ff;">event</span><span style="color:#000000;"> ev_accept;
</span><span style="color:#008080;">123</span> 
<span style="color:#008080;">124</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> 初始化 libevent. </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">125</span> <span style="color:#000000;">    event_init();
</span><span style="color:#008080;">126</span> 
<span style="color:#008080;">127</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> 创建我们监听的socket。 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">128</span>     listen_fd = socket(AF_INET, SOCK_STREAM, <span style="color:#800080;">0</span><span style="color:#000000;">);
</span><span style="color:#008080;">129</span>     <span style="color:#0000ff;">if</span> (listen_fd &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
</span><span style="color:#008080;">130</span>         err(<span style="color:#800080;">1</span>, <span style="color:#800000;">"</span><span style="color:#800000;">listen failed</span><span style="color:#800000;">"</span><span style="color:#000000;">);
</span><span style="color:#008080;">131</span>     <span style="color:#0000ff;">if</span> (setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;<span style="color:#000000;">reuseaddr_on,
</span><span style="color:#008080;">132</span>                    <span style="color:#0000ff;">sizeof</span>(reuseaddr_on)) == -<span style="color:#800080;">1</span><span style="color:#000000;">)
</span><span style="color:#008080;">133</span>         err(<span style="color:#800080;">1</span>, <span style="color:#800000;">"</span><span style="color:#800000;">setsockopt failed</span><span style="color:#800000;">"</span><span style="color:#000000;">);
</span><span style="color:#008080;">134</span>     memset(&amp;listen_addr, <span style="color:#800080;">0</span>, <span style="color:#0000ff;">sizeof</span><span style="color:#000000;">(listen_addr));
</span><span style="color:#008080;">135</span>     listen_addr.sin_family =<span style="color:#000000;"> AF_INET;
</span><span style="color:#008080;">136</span>     listen_addr.sin_addr.s_addr =<span style="color:#000000;"> INADDR_ANY;
</span><span style="color:#008080;">137</span>     listen_addr.sin_port =<span style="color:#000000;"> htons(SERVER_PORT);
</span><span style="color:#008080;">138</span>     <span style="color:#0000ff;">if</span> (bind(listen_fd, (<span style="color:#0000ff;">struct</span> sockaddr *)&amp;<span style="color:#000000;">listen_addr,
</span><span style="color:#008080;">139</span>              <span style="color:#0000ff;">sizeof</span>(listen_addr)) &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
</span><span style="color:#008080;">140</span>         err(<span style="color:#800080;">1</span>, <span style="color:#800000;">"</span><span style="color:#800000;">bind failed</span><span style="color:#800000;">"</span><span style="color:#000000;">);
</span><span style="color:#008080;">141</span>     <span style="color:#0000ff;">if</span> (listen(listen_fd, <span style="color:#800080;">5</span>) &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
</span><span style="color:#008080;">142</span>         err(<span style="color:#800080;">1</span>, <span style="color:#800000;">"</span><span style="color:#800000;">listen failed</span><span style="color:#800000;">"</span><span style="color:#000000;">);
</span><span style="color:#008080;">143</span> 
<span style="color:#008080;">144</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> 设置socket为非阻塞模式，使用libevent编程这是必不可少的。 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">145</span>     <span style="color:#0000ff;">if</span> (setnonblock(listen_fd) &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
</span><span style="color:#008080;">146</span>         err(<span style="color:#800080;">1</span>, <span style="color:#800000;">"</span><span style="color:#800000;">failed to set server socket to non-blocking</span><span style="color:#800000;">"</span><span style="color:#000000;">);
</span><span style="color:#008080;">147</span> 
<span style="color:#008080;">148</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> 我们现在有了一个监听的socket，我们创建一个读事件，当有客户连接时，接收通知。 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">149</span>     event_set(&amp;ev_accept, listen_fd, EV_READ|<span style="color:#000000;">EV_PERSIST, on_accept, NULL);　　<span style="color:#339966;">//用epoll_wait的返回信息也可以完成监听连接请求，但是libevent封装的epoll并不理会连接请求，因此响应连接要我们自己处理。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　libevent的epoll_wait只处理异常，超时，及关心的事件发生。其中关心的事件只处理读事件，写事件，EPOLLERR（对应的文件描述符发生错误），<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　EPOLLHUP（对应的文件描述符被挂断）。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　这里是将监听连接注册到epoll中的读事件并持久化，当收到信息后调用on_accept接受连接，并为新连接上来的socket注册读事件。
</span></span><span style="color:#008080;">150</span>     event_add(&amp;<span style="color:#000000;">ev_accept, NULL);
</span><span style="color:#008080;">151</span> 
<span style="color:#008080;">152</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> 开始 libevent 的事件循环。 </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">153</span> <span style="color:#000000;">    event_dispatch();
</span><span style="color:#008080;">154</span> 
<span style="color:#008080;">155</span>     <span style="color:#0000ff;">return</span> <span style="color:#800080;">0</span><span style="color:#000000;">;
</span><span style="color:#008080;">156</span> }</pre> 
 </div> 
 <p><span style="font-size:18px;">1.前一篇提到过，在event_base_new(</span><span style="color:#569cd6;">void</span><span style="font-size:18px;">)过程中通过调用<span style="color:#0000ff;">base-&gt;evsel-&gt;init(<span style="color:#0000ff;">base<span style="color:#000000;">)</span></span></span>我们进行了I/O模型的初始化，在epoll中就是调用的epoll_init(struct event_base *base)</span></p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008080;"> 1</span> epoll_init(<span style="color:#0000ff;">struct</span> event_base *<span style="color:#0000ff;">base</span><span style="color:#000000;">)
</span><span style="color:#008080;"> 2</span> <span style="color:#000000;">{
</span><span style="color:#008080;"> 3</span>     <span style="color:#0000ff;">int</span><span style="color:#000000;"> epfd;　　　　　　　　<span style="color:#339966;">//epoll_create返回的epoll句柄，这个句柄会占用一个fd值。
</span></span><span style="color:#008080;"> 4</span>     <span style="color:#0000ff;">struct</span> epollop *<span style="color:#000000;">epollop;　　<span style="color:#339966;">//指向本篇开始提到的结构体的指针
</span></span><span style="color:#008080;"> 5</span> 
<span style="color:#008080;"> 6</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> Disable epollueue when this environment variable is set </span><span style="color:#008000;">*/</span>
<span style="color:#008080;"> 7</span>     <span style="color:#0000ff;">if</span> (evutil_getenv(<span style="color:#800000;">"</span><span style="color:#800000;">EVENT_NOEPOLL</span><span style="color:#800000;">"</span><span style="color:#000000;">))
</span><span style="color:#008080;"> 8</span>         <span style="color:#0000ff;">return</span><span style="color:#000000;"> (NULL);
</span><span style="color:#008080;"> 9</span> 
<span style="color:#008080;">10</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> Initalize the kernel queue </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">11</span>     <span style="color:#0000ff;">if</span> ((epfd = epoll_create(<span style="color:#800080;">32000</span>)) == -<span style="color:#800080;">1</span><span style="color:#000000;">) {
</span><span style="color:#008080;">12</span>         <span style="color:#0000ff;">if</span> (errno !=<span style="color:#000000;"> ENOSYS)
</span><span style="color:#008080;">13</span>             event_warn(<span style="color:#800000;">"</span><span style="color:#800000;">epoll_create</span><span style="color:#800000;">"</span><span style="color:#000000;">);
</span><span style="color:#008080;">14</span>         <span style="color:#0000ff;">return</span><span style="color:#000000;"> (NULL);
</span><span style="color:#008080;">15</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">16</span> 
<span style="color:#008080;">17</span> <span style="color:#000000;">    FD_CLOSEONEXEC(epfd);　　　　　　　　<span style="color:#339966;">//从定义来看是说在子进程中不能使用这个句柄，也就是子进程不能用这个epoll实例</span><br></span></pre> 
  <div style="color:#d4d4d4;font-family:'Droid Sans Mono', monospace, monospace, 'Droid Sans Fallback';font-weight:normal;font-size:14px;line-height:19px;"> 
   <div style="margin-left:300px;"> 
    <span style="color:#c586c0;">#ifdef<span style="color:#569cd6;"> <span style="color:#dcdcaa;">HAVE_SETFD</span></span></span> 
   </div> 
   <div style="margin-left:300px;"> 
    <span style="color:#c586c0;">#define<span style="color:#569cd6;"> <span style="color:#dcdcaa;">FD_CLOSEONEXEC<span style="color:#569cd6;">(<span style="color:#9cdcfe;">x<span style="color:#569cd6;">) <span style="color:#c586c0;">do<span style="color:#569cd6;"> { <span style="color:#d7ba7d;">\</span></span></span></span></span></span></span></span></span> 
   </div> 
   <div style="margin-left:300px;"> 
    <span style="color:#569cd6;"> <span style="color:#c586c0;">if<span style="color:#569cd6;"> (<span style="color:#dcdcaa;">fcntl<span style="color:#569cd6;">(x, F_SETFD, <span style="color:#b5cea8;">1<span style="color:#569cd6;">) <span style="color:#d4d4d4;">==<span style="color:#569cd6;"> <span style="color:#d4d4d4;">-<span style="color:#b5cea8;">1<span style="color:#569cd6;">) <span style="color:#d7ba7d;">\</span></span></span></span></span></span></span></span></span></span></span></span></span> 
   </div> 
   <div style="margin-left:300px;"> 
    <span style="color:#569cd6;"> <span style="color:#dcdcaa;">event_warn<span style="color:#569cd6;">(<span style="color:#ce9178;">"fcntl(%d, F_SETFD)"<span style="color:#569cd6;">, x); <span style="color:#d7ba7d;">\</span></span></span></span></span></span> 
   </div> 
   <div style="margin-left:300px;"> 
    <span style="color:#569cd6;">} <span style="color:#c586c0;">while<span style="color:#569cd6;"> (<span style="color:#b5cea8;">0<span style="color:#569cd6;">)</span></span></span></span></span> 
   </div> 
   <div style="margin-left:300px;"> 
    <span style="color:#c586c0;">#else</span> 
   </div> 
   <div style="margin-left:300px;"> 
    <span style="color:#c586c0;">#define<span style="color:#569cd6;"> <span style="color:#dcdcaa;">FD_CLOSEONEXEC<span style="color:#569cd6;">(<span style="color:#9cdcfe;">x<span style="color:#569cd6;">)</span></span></span></span></span></span> 
   </div> 
   <div style="margin-left:300px;"> 
    <span style="color:#c586c0;">#endif</span> 
   </div> 
  </div> 
  <pre><span style="color:#008080;">18</span> 
<span style="color:#008080;">19</span>     <span style="color:#0000ff;">if</span> (!(epollop = <span style="color:#0000ff;">calloc</span>(<span style="color:#800080;">1</span>, <span style="color:#0000ff;">sizeof</span>(<span style="color:#0000ff;">struct</span><span style="color:#000000;"> epollop))))
</span><span style="color:#008080;">20</span>         <span style="color:#0000ff;">return</span><span style="color:#000000;"> (NULL);
</span><span style="color:#008080;">21</span> 
<span style="color:#008080;">22</span>     epollop-&gt;epfd =<span style="color:#000000;"> epfd;
</span><span style="color:#008080;">23</span> 
<span style="color:#008080;">24</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> Initalize fields </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">25</span>     epollop-&gt;events = <span style="color:#0000ff;">malloc</span>(INITIAL_NEVENTS * <span style="color:#0000ff;">sizeof</span>(<span style="color:#0000ff;">struct</span><span style="color:#000000;"> epoll_event));
</span><span style="color:#008080;">26</span>     <span style="color:#0000ff;">if</span> (epollop-&gt;events ==<span style="color:#000000;"> NULL) {
</span><span style="color:#008080;">27</span>         <span style="color:#0000ff;">free</span><span style="color:#000000;">(epollop);
</span><span style="color:#008080;">28</span>         <span style="color:#0000ff;">return</span><span style="color:#000000;"> (NULL);
</span><span style="color:#008080;">29</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">30</span>     epollop-&gt;nevents =<span style="color:#000000;"> INITIAL_NEVENTS;
</span><span style="color:#008080;">31</span> 
<span style="color:#008080;">32</span>     epollop-&gt;fds = <span style="color:#0000ff;">calloc</span>(INITIAL_NFILES, <span style="color:#0000ff;">sizeof</span>(<span style="color:#0000ff;">struct</span><span style="color:#000000;"> evepoll));
</span><span style="color:#008080;">33</span>     <span style="color:#0000ff;">if</span> (epollop-&gt;fds ==<span style="color:#000000;"> NULL) {
</span><span style="color:#008080;">34</span>         <span style="color:#0000ff;">free</span>(epollop-&gt;<span style="color:#000000;">events);
</span><span style="color:#008080;">35</span>         <span style="color:#0000ff;">free</span><span style="color:#000000;">(epollop);
</span><span style="color:#008080;">36</span>         <span style="color:#0000ff;">return</span><span style="color:#000000;"> (NULL);
</span><span style="color:#008080;">37</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">38</span>     epollop-&gt;nfds =<span style="color:#000000;"> INITIAL_NFILES;
</span><span style="color:#008080;">39</span> 
<span style="color:#008080;">40</span>     evsignal_init(<span style="color:#0000ff;">base</span><span style="color:#000000;">);　　　　<span style="color:#339966;">//信号下一篇在说，跳过信号相关部分
</span></span><span style="color:#008080;">41</span> 
<span style="color:#008080;">42</span>     <span style="color:#0000ff;">return</span><span style="color:#000000;"> (epollop);
</span><span style="color:#008080;">43</span> }</pre> 
 </div> 
 <p><span style="font-size:18px;">2.event_add(</span><span style="color:#569cd6;">struct<span style="color:#d4d4d4;"> event <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">ev, <span style="color:#569cd6;">const<span style="color:#d4d4d4;"> <span style="color:#569cd6;">struct<span style="color:#d4d4d4;"> timeval <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">tv</span></span></span></span></span></span></span></span></span></span><span style="font-size:18px;">)中，只要事件是读|写|信号，并且不是已注册或已激活事件，都将调用对应的add注册成对应I/O模型的事件。这里包含信号前面已经提到过，是因为信号嵌入到了I/O模型中，这一篇不讨论信号。</span></p> 
 <p><span style="font-size:18px;">在epoll模型中就是epoll_add</span><span style="color:#dcdcaa;"><span style="color:#d4d4d4;">(<span style="color:#569cd6;">void<span style="color:#d4d4d4;"> <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">arg, <span style="color:#569cd6;">struct<span style="color:#d4d4d4;"> event <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">ev)</span></span></span></span></span></span></span></span></span></span></p> 
 <p> </p> 
 <p> </p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008080;"> 1</span> <span style="color:#0000ff;">static</span> <span style="color:#0000ff;">int</span>
<span style="color:#008080;"> 2</span> epoll_add(<span style="color:#0000ff;">void</span> *arg, <span style="color:#0000ff;">struct</span> <span style="color:#0000ff;">event</span> *<span style="color:#000000;">ev)
</span><span style="color:#008080;"> 3</span> <span style="color:#000000;">{
</span><span style="color:#008080;"> 4</span>     <span style="color:#0000ff;">struct</span> epollop *epollop =<span style="color:#000000;"> arg;
</span><span style="color:#008080;"> 5</span>     <span style="color:#0000ff;">struct</span> epoll_event epev = {<!-- --><span style="color:#800080;">0</span>, {<!-- --><span style="color:#800080;">0</span><span style="color:#000000;">}};
</span><span style="color:#008080;"> 6</span>     <span style="color:#0000ff;">struct</span> evepoll *<span style="color:#000000;">evep;
</span><span style="color:#008080;"> 7</span>     <span style="color:#0000ff;">int</span><span style="color:#000000;"> fd, op, events;
</span><span style="color:#008080;"> 8</span> 
<span style="color:#008080;"> 9</span>     <span style="color:#0000ff;">if</span> (ev-&gt;ev_events &amp;<span style="color:#000000;"> EV_SIGNAL)　　　　<span style="color:#339966;">//如果事件类型是信号，注册信号事件
</span></span><span style="color:#008080;">10</span>         <span style="color:#0000ff;">return</span><span style="color:#000000;"> (evsignal_add(ev));
</span><span style="color:#008080;">11</span> 
<span style="color:#008080;">12</span>     fd = ev-&gt;<span style="color:#000000;">ev_fd;
</span><span style="color:#008080;">13</span>     <span style="color:#0000ff;">if</span> (fd &gt;= epollop-&gt;<span style="color:#000000;">nfds) {　　　　　　<span style="color:#339966;">//如果这个要注册事件的文件描述符值超过已分配的文件描述符数组长度，调用realloc扩充epollop-&gt;fds的分配内存×2，直到这个值小于数组长度。将扩充部分置为0
</span></span><span style="color:#008080;">14</span>         <span style="color:#008000;">/*</span><span style="color:#008000;"> Extent the file descriptor array as necessary </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">15</span>         <span style="color:#0000ff;">if</span> (epoll_recalc(ev-&gt;ev_base, epollop, fd) == -<span style="color:#800080;">1</span><span style="color:#000000;">)
</span><span style="color:#008080;">16</span>             <span style="color:#0000ff;">return</span> (-<span style="color:#800080;">1</span><span style="color:#000000;">);
</span><span style="color:#008080;">17</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">18</span>     evep = &amp;epollop-&gt;<span style="color:#000000;">fds[fd];
</span><span style="color:#008080;">19</span>     op =<span style="color:#000000;"> EPOLL_CTL_ADD;
</span><span style="color:#008080;">20</span>     events = <span style="color:#800080;">0</span><span style="color:#000000;">;
</span><span style="color:#008080;">21</span>     <span style="color:#0000ff;">if</span> (evep-&gt;evread !=<span style="color:#000000;"> NULL) {　　<span style="color:#339966;">//该文件描述符已经存在读事件，修改时保留读事件
</span></span><span style="color:#008080;">22</span>         events |=<span style="color:#000000;"> EPOLLIN;
</span><span style="color:#008080;">23</span>         op =<span style="color:#000000;"> EPOLL_CTL_MOD;
</span><span style="color:#008080;">24</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">25</span>     <span style="color:#0000ff;">if</span> (evep-&gt;evwrite !=<span style="color:#000000;"> NULL) {　　<span style="color:#339966;">//该文件描述符已经存在写事件，修改时保留写事件
</span></span><span style="color:#008080;">26</span>         events |=<span style="color:#000000;"> EPOLLOUT;
</span><span style="color:#008080;">27</span>         op =<span style="color:#000000;"> EPOLL_CTL_MOD;
</span><span style="color:#008080;">28</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">29</span> 
<span style="color:#008080;">30</span>     <span style="color:#0000ff;">if</span> (ev-&gt;ev_events &amp;<span style="color:#000000;"> EV_READ)　　<span style="color:#339966;">//注册事件如果需要注册读事件，为该文件描述符添加读事件
</span></span><span style="color:#008080;">31</span>         events |=<span style="color:#000000;"> EPOLLIN;
</span><span style="color:#008080;">32</span>     <span style="color:#0000ff;">if</span> (ev-&gt;ev_events &amp;<span style="color:#000000;"> EV_WRITE)　　<span style="color:#339966;">//注册事件如果需要注册写事件，为该文件描述符添加写事件
</span></span><span style="color:#008080;">33</span>         events |=<span style="color:#000000;"> EPOLLOUT;
</span><span style="color:#008080;">34</span> 
<span style="color:#008080;">35</span>     epev.data.fd =<span style="color:#000000;"> fd;　　　　　　<span style="color:#339966;">//监听的文件描述符
</span></span><span style="color:#008080;">36</span>     epev.events =<span style="color:#000000;"> events;　　　　<span style="color:#339966;">//需要监听改文件描述符发生的事件
</span></span><span style="color:#008080;">37</span>     <span style="color:#0000ff;">if</span> (epoll_ctl(epollop-&gt;epfd, op, ev-&gt;ev_fd, &amp;epev) == -<span style="color:#800080;">1</span><span style="color:#000000;">)　　<span style="color:#339966;">//将该文件描述符需要监听的事件注册到epoll
</span></span><span style="color:#008080;">38</span>             <span style="color:#0000ff;">return</span> (-<span style="color:#800080;">1</span><span style="color:#000000;">);
</span><span style="color:#008080;">39</span> 
<span style="color:#008080;">40</span>     <span style="color:#008000;">/*</span><span style="color:#008000;"> Update events responsible </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">41</span>     <span style="color:#0000ff;">if</span> (ev-&gt;ev_events &amp;<span style="color:#000000;"> EV_READ)
</span><span style="color:#008080;">42</span>         evep-&gt;evread =<span style="color:#000000;"> ev;　　<span style="color:#339966;">//表明该文件描述符有读事件
</span></span><span style="color:#008080;">43</span>     <span style="color:#0000ff;">if</span> (ev-&gt;ev_events &amp;<span style="color:#000000;"> EV_WRITE)
</span><span style="color:#008080;">44</span>         evep-&gt;evwrite =<span style="color:#000000;"> ev;　　<span style="color:#339966;">//表明该文件描述符有写事件
</span></span><span style="color:#008080;">45</span> 
<span style="color:#008080;">46</span>     <span style="color:#0000ff;">return</span> (<span style="color:#800080;">0</span><span style="color:#000000;">);
</span><span style="color:#008080;">47</span> }</pre> 
 </div> 
 <p> </p> 
 <p><span style="font-size:18px;">3.事件注册完成后，event_base_loop()中监听这些事件event_dispatch(</span><span style="color:#569cd6;">struct<span style="color:#d4d4d4;"> event_base <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">base, <span style="color:#569cd6;">void<span style="color:#d4d4d4;"> <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">arg, <span style="color:#569cd6;">struct<span style="color:#d4d4d4;"> timeval <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">tv</span></span></span></span></span></span></span></span></span></span></span></span><span style="font-size:18px;">)，</span></p> 
 <p><span style="font-size:18px;">对于epoll模型，就是epoll_dispatch(</span><span style="color:#569cd6;">struct<span style="color:#d4d4d4;"> event_base <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">base, <span style="color:#569cd6;">void<span style="color:#d4d4d4;"> <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">arg, <span style="color:#569cd6;">struct<span style="color:#d4d4d4;"> timeval <span style="color:#d4d4d4;">*<span style="color:#d4d4d4;">tv</span></span></span></span></span></span></span></span></span></span></span></span><span style="font-size:18px;">)</span></p> 
 <p> </p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008080;"> 1</span> <span style="color:#0000ff;">static</span> <span style="color:#0000ff;">int</span>
<span style="color:#008080;"> 2</span> epoll_dispatch(<span style="color:#0000ff;">struct</span> event_base *<span style="color:#0000ff;">base</span>, <span style="color:#0000ff;">void</span> *arg, <span style="color:#0000ff;">struct</span> timeval *<span style="color:#000000;">tv)
</span><span style="color:#008080;"> 3</span> <span style="color:#000000;">{
</span><span style="color:#008080;"> 4</span>     <span style="color:#0000ff;">struct</span> epollop *epollop =<span style="color:#000000;"> arg;
</span><span style="color:#008080;"> 5</span>     <span style="color:#0000ff;">struct</span> epoll_event *events = epollop-&gt;<span style="color:#000000;">events;
</span><span style="color:#008080;"> 6</span>     <span style="color:#0000ff;">struct</span> evepoll *<span style="color:#000000;">evep;
</span><span style="color:#008080;"> 7</span>     <span style="color:#0000ff;">int</span> i, res, timeout = -<span style="color:#800080;">1</span><span style="color:#000000;">;
</span><span style="color:#008080;"> 8</span> 
<span style="color:#008080;"> 9</span>     <span style="color:#0000ff;">if</span> (tv !=<span style="color:#000000;"> NULL)
</span><span style="color:#008080;">10</span>         timeout = tv-&gt;tv_sec * <span style="color:#800080;">1000</span> + (tv-&gt;tv_usec + <span style="color:#800080;">999</span>) / <span style="color:#800080;">1000</span><span style="color:#000000;">;　　<span style="color:#339966;">//超时时间，单位ms,向上取整
</span></span><span style="color:#008080;">11</span> 
<span style="color:#008080;">12</span>     <span style="color:#0000ff;">if</span> (timeout &gt;<span style="color:#000000;"> MAX_EPOLL_TIMEOUT_MSEC) {　　<span style="color:#339966;">//超时时间超过linux内核可以等待的最长时间，取最长时间
</span></span><span style="color:#008080;">13</span>         <span style="color:#008000;">/*</span><span style="color:#008000;"> Linux kernels can wait forever if the timeout is too big;
</span><span style="color:#008080;">14</span> <span style="color:#008000;">         * see comment on MAX_EPOLL_TIMEOUT_MSEC. </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">15</span>         timeout =<span style="color:#000000;"> MAX_EPOLL_TIMEOUT_MSEC;
</span><span style="color:#008080;">16</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">17</span> 
<span style="color:#008080;">18</span>     res = epoll_wait(epollop-&gt;epfd, events, epollop-&gt;<span style="color:#000000;">nevents, timeout);
</span><span style="color:#008080;">19</span> 
<span style="color:#008080;">20</span>     <span style="color:#0000ff;">if</span> (res == -<span style="color:#800080;">1</span><span style="color:#000000;">) {　　　　<span style="color:#339966;">//返回-1,说明epoll_wait产生异常
</span></span><span style="color:#008080;">21</span>         <span style="color:#0000ff;">if</span> (errno !=<span style="color:#000000;"> EINTR) {　　<span style="color:#339966;">//在超时或监听到事件发生前收到的不是中断信号
</span></span><span style="color:#008080;">22</span>             event_warn(<span style="color:#800000;">"</span><span style="color:#800000;">epoll_wait</span><span style="color:#800000;">"</span><span style="color:#000000;">);
</span><span style="color:#008080;">23</span>             <span style="color:#0000ff;">return</span> (-<span style="color:#800080;">1</span><span style="color:#000000;">);
</span><span style="color:#008080;">24</span> <span style="color:#000000;">        }
</span><span style="color:#008080;">25</span> 
<span style="color:#008080;">26</span>         evsignal_process(<span style="color:#0000ff;">base</span><span style="color:#000000;">);　　<span style="color:#339966;">//信号处理，此处不说明
</span></span><span style="color:#008080;">27</span>         <span style="color:#0000ff;">return</span> (<span style="color:#800080;">0</span><span style="color:#000000;">);
</span><span style="color:#008080;">28</span>     } <span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span> (<span style="color:#0000ff;">base</span>-&gt;<span style="color:#000000;">sig.evsignal_caught) {　　<span style="color:#339966;">//监听的某种信号产生并处理，此处不说明
</span></span><span style="color:#008080;">29</span>         evsignal_process(<span style="color:#0000ff;">base</span><span style="color:#000000;">);
</span><span style="color:#008080;">30</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">31</span> 
<span style="color:#008080;">32</span>     event_debug((<span style="color:#800000;">"</span><span style="color:#800000;">%s: epoll_wait reports %d</span><span style="color:#800000;">"</span><span style="color:#000000;">, __func__, res));
</span><span style="color:#008080;">33</span> 
<span style="color:#008080;">34</span>     <span style="color:#0000ff;">for</span> (i = <span style="color:#800080;">0</span>; i &lt; res; i++<span style="color:#000000;">) {
</span><span style="color:#008080;">35</span>         <span style="color:#0000ff;">int</span> what =<span style="color:#000000;"> events[i].events;
</span><span style="color:#008080;">36</span>         <span style="color:#0000ff;">struct</span> <span style="color:#0000ff;">event</span> *evread = NULL, *evwrite =<span style="color:#000000;"> NULL;
</span><span style="color:#008080;">37</span>         <span style="color:#0000ff;">int</span> fd =<span style="color:#000000;"> events[i].data.fd;　　　　<span style="color:#339966;">//发生该事件的文件描述符
</span></span><span style="color:#008080;">38</span> 
<span style="color:#008080;">39</span>         <span style="color:#0000ff;">if</span> (fd &lt; <span style="color:#800080;">0</span> || fd &gt;= epollop-&gt;<span style="color:#000000;">nfds)
</span><span style="color:#008080;">40</span>             <span style="color:#0000ff;">continue</span><span style="color:#000000;">;
</span><span style="color:#008080;">41</span>         evep = &amp;epollop-&gt;<span style="color:#000000;">fds[fd];　　　　　<span style="color:#339966;">//发生该事件的文件描述符的事件类型（2个事件类型读、写）
</span></span><span style="color:#008080;">42</span> 
<span style="color:#008080;">43</span>         <span style="color:#0000ff;">if</span> (what &amp; (EPOLLHUP|<span style="color:#000000;">EPOLLERR)) {　　<span style="color:#339966;">//该文件描述符被挂断或发生错误（读事件应该是用来注销该文件描述符上的事件，这里不明白激活写事件是要干嘛）
</span></span><span style="color:#008080;">44</span>             evread = evep-&gt;<span style="color:#000000;">evread;　　　　<span style="color:#339966;">//如果有读事件，记录下来
</span></span><span style="color:#008080;">45</span>             evwrite = evep-&gt;<span style="color:#000000;">evwrite;　　 <span style="color:#339966;">//如果有写事件，记录下来
</span></span><span style="color:#008080;">46</span>         } <span style="color:#0000ff;">else</span><span style="color:#000000;"> {
</span><span style="color:#008080;">47</span>             <span style="color:#0000ff;">if</span> (what &amp;<span style="color:#000000;"> EPOLLIN) {　　<span style="color:#339966;">//该文件描述符可以读（包括对端SOCKET正常关闭）
</span></span><span style="color:#008080;">48</span>                 evread = evep-&gt;<span style="color:#000000;">evread;　　<span style="color:#339966;">//记录这个读事件
</span></span><span style="color:#008080;">49</span> <span style="color:#000000;">            }
</span><span style="color:#008080;">50</span> 
<span style="color:#008080;">51</span>             <span style="color:#0000ff;">if</span> (what &amp;<span style="color:#000000;"> EPOLLOUT) {　　<span style="color:#339966;">//文件描述符可以写
</span></span><span style="color:#008080;">52</span>                 evwrite = evep-&gt;<span style="color:#000000;">evwrite;　　<span style="color:#339966;">//记录这个写事件
</span></span><span style="color:#008080;">53</span> <span style="color:#000000;">            }
</span><span style="color:#008080;">54</span> <span style="color:#000000;">        }
</span><span style="color:#008080;">55</span> 
<span style="color:#008080;">56</span>         <span style="color:#0000ff;">if</span> (!(evread||<span style="color:#000000;">evwrite)) <span style="color:#339966;">//如果没有读或写事件发生，跳过该文件描述符的事件
</span></span><span style="color:#008080;">57</span>             <span style="color:#0000ff;">continue</span><span style="color:#000000;">;
</span><span style="color:#008080;">58</span> 
<span style="color:#008080;">59</span>         <span style="color:#0000ff;">if</span> (evread !=<span style="color:#000000;"> NULL)　　<span style="color:#339966;">//如果前面记录了读事件，将该事件插入到激活链表，且调用事件回调次数设为1
</span></span><span style="color:#008080;">60</span>             event_active(evread, EV_READ, <span style="color:#800080;">1</span><span style="color:#000000;">);
</span><span style="color:#008080;">61</span>         <span style="color:#0000ff;">if</span> (evwrite !=<span style="color:#000000;"> NULL)　　<span style="color:#339966;">//</span><span style="color:#000000;"><span style="color:#339966;">如果前面记录了写事件，将该事件插入到激活链表，且调用事件回调次数设为1</span></span>
</span><span style="color:#008080;">62</span>             event_active(evwrite, EV_WRITE, <span style="color:#800080;">1</span><span style="color:#000000;">);
</span><span style="color:#008080;">63</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">64</span> 
<span style="color:#008080;">65</span>     <span style="color:#0000ff;">if</span> (res == epollop-&gt;nevents &amp;&amp; epollop-&gt;nevents &lt;<span style="color:#000000;"> MAX_NEVENTS) {　　<span style="color:#339966;">//监听到的事件数量达到了分配的缓存上限，但没有达到MAX_NEVENTS，说明我们的缓存数组不够用了，扩充缓存监听事件的数组
</span></span><span style="color:#008080;">66</span>         <span style="color:#008000;">/*</span><span style="color:#008000;"> We used all of the event space this time.  We should
</span><span style="color:#008080;">67</span> <span style="color:#008000;">           be ready for more events next time. </span><span style="color:#008000;">*/</span>
<span style="color:#008080;">68</span>         <span style="color:#0000ff;">int</span> new_nevents = epollop-&gt;nevents * <span style="color:#800080;">2</span><span style="color:#000000;">;
</span><span style="color:#008080;">69</span>         <span style="color:#0000ff;">struct</span> epoll_event *<span style="color:#000000;">new_events;
</span><span style="color:#008080;">70</span> 
<span style="color:#008080;">71</span>         new_events = <span style="color:#0000ff;">realloc</span>(epollop-&gt;<span style="color:#000000;">events,
</span><span style="color:#008080;">72</span>             new_nevents * <span style="color:#0000ff;">sizeof</span>(<span style="color:#0000ff;">struct</span><span style="color:#000000;"> epoll_event));
</span><span style="color:#008080;">73</span>         <span style="color:#0000ff;">if</span><span style="color:#000000;"> (new_events) {
</span><span style="color:#008080;">74</span>             epollop-&gt;events =<span style="color:#000000;"> new_events;
</span><span style="color:#008080;">75</span>             epollop-&gt;nevents =<span style="color:#000000;"> new_nevents;
</span><span style="color:#008080;">76</span> <span style="color:#000000;">        }
</span><span style="color:#008080;">77</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">78</span> 
<span style="color:#008080;">79</span>     <span style="color:#0000ff;">return</span> (<span style="color:#800080;">0</span><span style="color:#000000;">);
</span><span style="color:#008080;">80</span> }</pre> 
 </div> 
 <p> </p> 
 <p>epoll到这里差不多结束了，处理已激活事件是在event框架的event_dispatch中，不属于I/O模型的部分，epoll模型还剩下注销事件，注销epoll这个模型实例。</p> 
 <p>epoll的监听事件一般都是持久化的（如果不是持久化的，参考上一篇最后），需要注销监听事件一般在客户端断开连接（读事件读到0个字节），而注销epoll模型实例，释放epoll的内存，意味着我们没有I/O模型和信号管理可用了，还只剩下计时器事件可用，功能基本也就结束了。</p> 
 <p>所以这里最后看看epoll注销事件epoll_del是怎么做的，注销epoll模型实例epoll_dealloc就省略了。</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008080;"> 1</span> <span style="color:#0000ff;">static</span> <span style="color:#0000ff;">int</span>
<span style="color:#008080;"> 2</span> epoll_del(<span style="color:#0000ff;">void</span> *arg, <span style="color:#0000ff;">struct</span> <span style="color:#0000ff;">event</span> *<span style="color:#000000;">ev)
</span><span style="color:#008080;"> 3</span> <span style="color:#000000;">{
</span><span style="color:#008080;"> 4</span>     <span style="color:#0000ff;">struct</span> epollop *epollop =<span style="color:#000000;"> arg;
</span><span style="color:#008080;"> 5</span>     <span style="color:#0000ff;">struct</span> epoll_event epev = {<!-- --><span style="color:#800080;">0</span>, {<!-- --><span style="color:#800080;">0</span><span style="color:#000000;">}};
</span><span style="color:#008080;"> 6</span>     <span style="color:#0000ff;">struct</span> evepoll *<span style="color:#000000;">evep;
</span><span style="color:#008080;"> 7</span>     <span style="color:#0000ff;">int</span><span style="color:#000000;"> fd, events, op;
</span><span style="color:#008080;"> 8</span>     <span style="color:#0000ff;">int</span> needwritedelete = <span style="color:#800080;">1</span>, needreaddelete = <span style="color:#800080;">1</span><span style="color:#000000;">;
</span><span style="color:#008080;"> 9</span> 
<span style="color:#008080;">10</span>     <span style="color:#0000ff;">if</span> (ev-&gt;ev_events &amp;<span style="color:#000000;"> EV_SIGNAL)　　<span style="color:#339966;">//如果该事件是信号，恢复该信号的到注册之前的默认处理。
</span></span><span style="color:#008080;">11</span>         <span style="color:#0000ff;">return</span><span style="color:#000000;"> (evsignal_del(ev));
</span><span style="color:#008080;">12</span> 
<span style="color:#008080;">13</span>     fd = ev-&gt;<span style="color:#000000;">ev_fd;
</span><span style="color:#008080;">14</span>     <span style="color:#0000ff;">if</span> (fd &gt;= epollop-&gt;<span style="color:#000000;">nfds)　　<span style="color:#339966;">//该文件描述符不在事件队列中，忽略
</span></span><span style="color:#008080;">15</span>         <span style="color:#0000ff;">return</span> (<span style="color:#800080;">0</span><span style="color:#000000;">);
</span><span style="color:#008080;">16</span>     evep = &amp;epollop-&gt;<span style="color:#000000;">fds[fd];
</span><span style="color:#008080;">17</span> 
<span style="color:#008080;">18</span>     op =<span style="color:#000000;"> EPOLL_CTL_DEL;
</span><span style="color:#008080;">19</span>     events = <span style="color:#800080;">0</span><span style="color:#000000;">;
</span><span style="color:#008080;">20</span> 
<span style="color:#008080;">21</span>     <span style="color:#0000ff;">if</span> (ev-&gt;ev_events &amp;<span style="color:#000000;"> EV_READ)
</span><span style="color:#008080;">22</span>         events |=<span style="color:#000000;"> EPOLLIN;
</span><span style="color:#008080;">23</span>     <span style="color:#0000ff;">if</span> (ev-&gt;ev_events &amp;<span style="color:#000000;"> EV_WRITE)
</span><span style="color:#008080;">24</span>         events |=<span style="color:#000000;"> EPOLLOUT;
</span><span style="color:#008080;">25</span> 
<span style="color:#008080;">26</span>     <span style="color:#0000ff;">if</span> ((events &amp; (EPOLLIN|EPOLLOUT)) != (EPOLLIN|<span style="color:#000000;">EPOLLOUT)) {　　<span style="color:#339966;">//如果该文件描述符上的事件不是同时有读和写事件
</span></span><span style="color:#008080;">27</span>         <span style="color:#0000ff;">if</span> ((events &amp; EPOLLIN) &amp;&amp; evep-&gt;evwrite !=<span style="color:#000000;"> NULL) {　　<span style="color:#339966;">//这是什么情况？理解不能
</span></span><span style="color:#008080;">28</span>             needwritedelete = <span style="color:#800080;">0</span><span style="color:#000000;">;
</span><span style="color:#008080;">29</span>             events =<span style="color:#000000;"> EPOLLOUT;
</span><span style="color:#008080;">30</span>             op =<span style="color:#000000;"> EPOLL_CTL_MOD;
</span><span style="color:#008080;">31</span>         } <span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span> ((events &amp; EPOLLOUT) &amp;&amp; evep-&gt;evread !=<span style="color:#000000;"> NULL) {
</span><span style="color:#008080;">32</span>             needreaddelete = <span style="color:#800080;">0</span><span style="color:#000000;">;
</span><span style="color:#008080;">33</span>             events =<span style="color:#000000;"> EPOLLIN;
</span><span style="color:#008080;">34</span>             op =<span style="color:#000000;"> EPOLL_CTL_MOD;
</span><span style="color:#008080;">35</span> <span style="color:#000000;">        }
</span><span style="color:#008080;">36</span> <span style="color:#000000;">    }
</span><span style="color:#008080;">37</span> 
<span style="color:#008080;">38</span>     epev.events =<span style="color:#000000;"> events;
</span><span style="color:#008080;">39</span>     epev.data.fd =<span style="color:#000000;"> fd;
</span><span style="color:#008080;">40</span> 
<span style="color:#008080;">41</span>     <span style="color:#0000ff;">if</span><span style="color:#000000;"> (needreaddelete)
</span><span style="color:#008080;">42</span>         evep-&gt;evread =<span style="color:#000000;"> NULL;　　<span style="color:#339966;">//将该文件描述符上的读事件置为NULL
</span></span><span style="color:#008080;">43</span>     <span style="color:#0000ff;">if</span><span style="color:#000000;"> (needwritedelete)
</span><span style="color:#008080;">44</span>         evep-&gt;evwrite =<span style="color:#000000;"> NULL;　　<span style="color:#339966;">//将该文件描述符上的写事件置为NULL
</span></span><span style="color:#008080;">45</span> 
<span style="color:#008080;">46</span>     <span style="color:#0000ff;">if</span> (epoll_ctl(epollop-&gt;epfd, op, fd, &amp;epev) == -<span style="color:#800080;">1</span><span style="color:#000000;">)
</span><span style="color:#008080;">47</span>         <span style="color:#0000ff;">return</span> (-<span style="color:#800080;">1</span><span style="color:#000000;">);
</span><span style="color:#008080;">48</span> 
<span style="color:#008080;">49</span>     <span style="color:#0000ff;">return</span> (<span style="color:#800080;">0</span><span style="color:#000000;">);
</span><span style="color:#008080;">50</span> }</pre> 
 </div> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/dyan1024/p/9998397.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a55a2470857f1e82d94dbb19f7a4b6b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python sklearn.cross_validation 模块导入失败</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27ef660325227d3bac870e13a3dbc322/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SeNet论文详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>