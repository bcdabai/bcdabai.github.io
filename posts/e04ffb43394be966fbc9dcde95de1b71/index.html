<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JS学习笔记】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【JS学习笔记】" />
<meta property="og:description" content="JS学习笔记 HTML和CSS相关知识点 什么是选择器？.xxx{} ,#xxx{} ,xxx{}, *xxx{},HTML中的&lt;body&gt;的JS会在页面加载时被执行&lt;head&gt;的JS会预先加载，但在被调用时才执行JS中如何获取html元素：document.querySelector(&#39;选择器&#39;)html 元素如何插入：containerMovements.insertAdjacentHTML(&#39;afterbegin&#39;,html) containerMovements.innerHTML JS小知识点 1. JS 的[ ] 引用表达式，比如
jonas[interest],interest = &#39;job&#39;可以访问到Jonas对象的job属性
[ ]内还可以是各种加减乘除形式的表达式，比如[&#39;day-${2&#43;4}&#39;] : {open:0;close:24}
2. JS的this 表示指向当前对象，注意：在函数中的函数如果有this将会使得其指向undefined，解决方法为用bind()，或者箭头函数，因为箭头函数对象不会被获取到。this 的好处在于，对象被赋值到新变量时，不需要更改内部的名称，只要属性一致就可以复用this.year，进而使用method borrowing
3. the spread operator 和 the rest pattern是相反的 前者将一个变量(arr)形成多个新变量(3,4,5)const newArr = [1,2,...arr]; ，
后者将多个变量(2,3)形成一个新变量(number)const add = function(...number){console.log(number);} add(2,3); add(2,3,4)。
4. JS 的短路： 短路||：一真(且非0，非undefined，非空)则真；
短路&amp;&amp;：一假则假，非假则后；
短路??：一真(且非undefined，非空)则真。
运算符返回内容不返回内容&amp;&amp;第一个falsy value 或 last value??第一个非null valuenull，undefined 5. JS 的entries： menu.entries() 数组的一个方法，会列出多个数组，每个数组有两个元素，[0] 是位置，[1]是数组的元素。对象也有这个方法，只是第一个位置不是表示位置的0123，而是key。for(const [i,el] of menu.entries()) {console.log(${i&#43;1}:${el})}
6. 函数的call(obj, arg)方法和bind(obj,arg)方法区别： 一个直接执行函数，一个返回一个函数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e04ffb43394be966fbc9dcde95de1b71/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-24T14:33:51+08:00" />
<meta property="article:modified_time" content="2023-10-24T14:33:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JS学习笔记】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="JS_0"></a>JS学习笔记</h2> 
<h3><a id="HTMLCSS_1"></a>HTML和CSS相关知识点</h3> 
<ol><li>什么是选择器？<code>.xxx{} ,#xxx{} ,xxx{}, *xxx{},</code></li><li>HTML中的<code>&lt;body&gt;</code>的JS会在页面加载时被执行<code>&lt;head&gt;</code>的JS会预先加载，但在被调用时才执行</li><li>JS中如何获取html元素：<code>document.querySelector('选择器')</code></li><li>html 元素如何插入：<code>containerMovements.insertAdjacentHTML('afterbegin',html)</code> <code>containerMovements.innerHTML</code></li></ol> 
<h3><a id="JS_6"></a>JS小知识点</h3> 
<h4><a id="1_JS___7"></a>1. JS 的[ ]</h4> 
<p>引用表达式，比如<br> <code>jonas[interest],interest = 'job'</code>可以访问到Jonas对象的job属性<br> [ ]内还可以是各种加减乘除形式的表达式，比如<code>['day-${2+4}'] : {open:0;close:24}</code></p> 
<h4><a id="2_JSthis_11"></a>2. JS的<code>this</code></h4> 
<p>表示指向当前对象，注意：在函数中的函数如果有this将会使得其指向undefined，解决方法为用<code>bind()</code>，或者箭头函数，因为箭头函数对象不会被获取到。this 的好处在于，对象被赋值到新变量时，不需要更改内部的名称，只要属性一致就可以复用<code>this.year</code>，进而使用method borrowing</p> 
<h4><a id="3_the_spread_operator__the_rest_pattern_13"></a>3. the spread operator 和 the rest pattern是相反的</h4> 
<p>前者将一个变量(arr)形成多个新变量(3,4,5)<code>const newArr = [1,2,...arr]; </code>，<br> 后者将多个变量(2,3)形成一个新变量(number)<code>const add = function(...number){console.log(number);} add(2,3); add(2,3,4)</code>。</p> 
<h4><a id="4_JS__16"></a>4. JS 的短路：</h4> 
<p>短路||：一真(且非0，非undefined，非空)则真；<br> 短路&amp;&amp;：一假则假，非假则后；<br> 短路??：一真(且非undefined，非空)则真。</p> 
<table><thead><tr><th>运算符</th><th>返回内容</th><th>不返回内容</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td>&amp;&amp;</td><td>第一个falsy value 或 last value</td><td></td></tr><tr><td>??</td><td>第一个非null value</td><td>null，undefined</td></tr></tbody></table> 
<h4><a id="5_JS_entries_25"></a>5. JS 的entries：</h4> 
<p><code>menu.entries()</code> 数组的一个方法，会列出多个数组，每个数组有两个元素，<code>[0]</code> 是位置，<code>[1]</code>是数组的元素。对象也有这个方法，只是第一个位置不是表示位置的0123，而是key。<code>for(const [i,el] of menu.entries()) {console.log(${i+1}:${el})}</code></p> 
<h4><a id="6_callobj_argbindobjarg_27"></a>6. 函数的<code>call(obj, arg)</code>方法和<code>bind(obj,arg)</code>方法区别：</h4> 
<p>一个直接执行函数，一个返回一个函数。</p> 
<h4><a id="7_JS_29"></a>7. JS中可以用下划线</h4> 
<p>可以帮助理解，不影响输出<code>const price = 345_99 ;console.log(price); &gt;&gt; 34599 </code></p> 
<h4><a id="8_JSJS_31"></a>8. JS是面向对象的语言，JS不使用类（万物皆对象）。</h4> 
<p>在JS中，不会创建类，也不会通过类来创建对象，JS创建对象有两种方法①使用Object定义并创建对象的实例<code>Person = new Object();Person.firstname = 'John';或者person = {firstname: 'John'};</code>②使用构造函数来定义对象，prototype来定义方法(所有对象都会至少继承于Object)，然后创建新的对象实例<code>const Person = function(name){this name = name;} ；Person.prototype = Object.create(Man.prototype)const person = new Person('John); </code></p> 
<h4><a id="9_JSprototype_33"></a>9. JS是基于prototype，而不是基于类的</h4> 
<p>在JS中，几乎所有对象都是Object的实例，都会从Object.prototype继承属性和方法</p> 
<h4><a id="10_ES6_classes_35"></a>10. ES6 classes：</h4> 
<p>是一种②的替代方案，看似类，其实质仍是基于构造函数，“Hide the truth nature of JS, but create a block that we used to.”</p> 
<h4><a id="11_JS__37"></a>11. JS 中的继承：</h4> 
<p>①用构造函数完成 Ⅰ<code>Person.call (this, firstname);</code>Ⅱ<code>Student.prototype = Object.create(Person.prototype); </code><br> ②用类完成Ⅰ<code>super(make,speed);</code>Ⅱ<code>class EV extends Car {...}</code></p> 
<h3><a id="_42"></a>复制对象</h3> 
<p>当某对象复制给新对象时，本质是创造了一个变量，该变量指向了原对象的地址，所以改变新对象的属性等于改变原对象的属性。<br> 解决方法：<br> ① 用Object.assign ( )<code>const friend = Object.assign({},me);//me是原对象</code><br> ②用The Spread operator <code>const newRestaurant = {...restaurant, founder:'Guiseppe'};</code></p> 
<h3><a id="Closure_47"></a>闭包Closure和返回函数</h3> 
<p>在一个函数内部创建另一个函数，内层函数中访问到其外层函数的变量，就会形成闭包.<br> 狭义的Closure通常是作为返回值，外部函数返回内部函数。<br> A closure makes a function remember all the variables that existed.</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">greet</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">greeting</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>greeting<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">greet</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'Jonas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用greet函数</span>

<span class="token comment">//箭头版</span>
<span class="token keyword">const</span> <span class="token function-variable function">greetArr</span> <span class="token operator">=</span> 
<span class="token parameter">greeting</span> <span class="token operator">=&gt;</span> <span class="token parameter">name</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>greeting<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>可以把函数定义在全局，赋值在局部，closure可以让全局访问到该函数</p> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> f<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">g</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>
	<span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//要先调用了g，才能调用f</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>理解Closure：<br> 本来函数外不能访问函数内的变量，因为作用域的问题；但是此时closure机制使得 某函数中能够访问该函数中的函数的变量。<br> 按道理内层函数中的变量应该只能在该内层函数中使用，但是该变量居然可以在外层函数被访问，这就是closure的魔力。</p> 
<h3><a id="Array_80"></a>Array的方法</h3> 
<p><img src="https://images2.imgbox.com/30/f1/ygQNHBBH_o.jpg" alt="来源：Jonas课程"></p> 
<h3><a id="Intersection_Observer_API_82"></a>Intersection Observer API</h3> 
<p>用于监听目标元素的可见部分（比例），当超过了<code>threshold</code>时，会执行指定的回调函数</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">root</span><span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#root"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">//根元素</span>
  <span class="token literal-property property">rootMargin</span><span class="token operator">:</span> <span class="token string">"0px"</span><span class="token punctuation">,</span> <span class="token comment">//传值形式类似于css的margin 传一个值则四个边都为0</span>
  <span class="token literal-property property">threshold</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">//触发条件 表示目标元素刚进入根元素时触发</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行回调函数内容'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>

<span class="token comment">//IntersectionObserver对象</span>
<span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> target <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#target"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//目标元素</span>
observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//开始监听该目标元素</span>

</code></pre> 
<h3><a id="prototype_chain_100"></a>失去prototype chain</h3> 
<p>如果将数据存储在浏览器的localStorage，再次调取会失去prototype chain<br> <img src="https://images2.imgbox.com/7f/f0/mM2G21XF_o.png" alt="上方是重新加载网页时获取的localStorage里的running对象，下方是在运行中输出的running对象"></p> 
<h3><a id="JS_103"></a>JS的异步性</h3> 
<p>其中，micro-tasks queue 中的promise可以插队<br> <img src="https://images2.imgbox.com/c2/1f/UODE6Csb_o.jpg" alt=""><br> 异步执行的东西（如加载图片，请求数据）都会在浏览器环境下执行，并放入callback queue和microtasks queue中，而不会在主线程call stack中执行，所以加载时也不会拖慢整个代码执行。<br> 异步性使得程序运行不完全按照代码的书写顺序。<br> <img src="https://images2.imgbox.com/0f/3f/9D1hGGyy_o.jpg" alt="分析代码执行顺序"><br> <img src="https://images2.imgbox.com/ab/bf/HnP47shP_o.jpg" alt="正确顺序"><br> timer是放在callback queue，promise是放在microtasks queue<br> <img src="https://images2.imgbox.com/bf/8a/JZBZxj17_o.jpg" alt=""><br> 不管promise有多长，promise（microtasks queue）可以优先于timer（callback queue）</p> 
<h3><a id="promisepromise_113"></a>创建promise，理解promise</h3> 
<p><img src="https://images2.imgbox.com/fc/d6/ZdsYPOMG_o.jpg" alt="在这里插入图片描述"><br> resolve函数和reject函数返回的分别是res和err</p> 
<p>创建promise两种方式：①new Promise（）②用Promisify</p> 
<p>promise 详解和手动实现promise：<a href="https://juejin.cn/post/7063377198014529572#heading-4" rel="nofollow">promise 详解和手动实现promise</a></p> 
<p>promise传入两个参数（分别为resolve函数和reject函数），<br> 如果promise状态为fulfilled则执行resolve函数，<br> 如果promise状态为rejected则执行reject函数；</p> 
<p>通过then方法可以对 Promise 中的resolve进行处理，<br> then方法(catch方法同理)的返回值是一个 Promise 实例，所以then可以连用；<br> then方法(catch方法同理)的返回值也可以是一个普通值，则该值作为一个新的promise的resolve()的返回值。</p> 
<p>可以将现成数据转化为一个promise<br> 可以直接promise.resolve()，相当于new promise ( resolve =&gt; { resolve() } )</p> 
<h3><a id="promise__132"></a>promise 方法</h3> 
<p>then ()<br> catch ()<br> finally ()</p> 
<p>all ([ ]) 创建多个promise</p> 
<p>allSettled () 该方法返回的 Promise 实例，会在所有 Promise 实例执行完毕后，状态方可变为fulfilled，并且只会是fulfilled</p> 
<p>race ([ ]) 返回第一个返回的promise</p> 
<p>any ([ ]) 返回第一个满足的promise，但是忽略reject</p> 
<h3><a id="Async_function_144"></a>Async function</h3> 
<p>keep running behind the scene, return a promise<br> <img src="https://images2.imgbox.com/29/57/MMCFNocT_o.jpg" alt="在这里插入图片描述"><br> 使用await 会返回紧跟着的promise的fulfilled状态下获取的值，相当于直接执行resolve()</p> 
<h3><a id="ES6_Modules_148"></a>ES6 Modules</h3> 
<p><img src="https://images2.imgbox.com/bd/76/lUjhauvU_o.jpg" alt="来源：Jonas课程ppt"><br> ES6 Module 也是以js文件存储，但是与一般的script.js具有差异（具体看右表）<br> JS的module和python的包类似，与python的异同点如下：</p> 
<p>同：</p> 
<ol><li>通过import导入依赖模块</li></ol> 
<p>异：</p> 
<ol><li>JS的模块要在html中指明文件类型是module<code>&lt;script type='module'&gt;&lt;/script&gt;</code></li><li>使用包中的变量或方法需要export，而python直接pd.xxx</li><li>JS的export default：<br> <img src="https://images2.imgbox.com/7c/f5/VUsH6FGH_o.jpg" alt="包内"><br> <img src="https://images2.imgbox.com/46/8b/jLnrKFLh_o.jpg" alt="包外调用"><br> export default 后面的东西可以被命名为add或其他名称，在导入时跟在import后面。</li><li>如果要获取包里所有变量，则使用import * as 包名 from ‘包名路径’，这样可以像python一样使用包</li><li>对JS来说，import导入不是普通的获取，而是建立一个连接，对包内的变量的改动将会影响包内本身变量的值。</li></ol> 
<h3><a id="NPMNode_Package_Manager_168"></a>NPM：Node Package Manager</h3> 
<p>在NPM出现以前，我们调用包都是通过<code>&lt;script&gt;</code>，但是总是需要手动在html中更改版本或者包名；</p> 
<p>安装：nodejs.org/en/ 网址<br> 查询：终端输入<code>npm -v</code></p> 
<p>每一个需要使用npm的项目，都要先初始化npm：终端输入<code>npm init</code><br> 于是可以定义各种文件属性，直接回车表示默认值<br> <img src="https://images2.imgbox.com/7d/36/AcO5KIk9_o.jpg" alt="终端截图"><br> npm 安装leaflet：<code>npm install leaflet</code><br> <img src="https://images2.imgbox.com/e6/be/jKADQhXB_o.jpg" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0593df7c1b7fa2ef791a600b16002dd4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">git pull Your configuration specifies to merge with the ref ‘refs/heads/xxxx‘ from the remote, but n</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9de52a494875177528acafa363c396bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux网络测试命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>