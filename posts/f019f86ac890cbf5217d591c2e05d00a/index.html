<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Argo workflow 案例练习和配置详细解析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Argo workflow 案例练习和配置详细解析" />
<meta property="og:description" content="参数化 - parameters hello-world-parameters.yaml文件解析
apiVersion: argoproj.io/v1alpha1 kind: Workflow metadata: generateName: hello-world-parameters- spec: entrypoint: whalesay # 调用 whalesay 模板 arguments: # 传递给函数的参数 parameters: # 声明参数 - name: message # Key value: hello world # value templates: - name: whalesay # whalesay 模板 inputs: parameters: - name: message container: image: docker/whalesay command: [cowsay] args: [&#34;{{inputs.parameters.message}}&#34;] 提交此工作流时，可以指定实际参数值：
[root@k8s-master01 argo]# argo submit -n argo arguments-parameters.yaml -p message=&#34;goodbye world&#34; [root@k8s-master01 argo]# argo logs -n argo hello-world-parameters-xxx 自定义 Parameter 数据生产端和消费端 output 作为生产端信息输出给 input 作为信息消费端，以parameter参数的方式。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f019f86ac890cbf5217d591c2e05d00a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-20T14:45:00+08:00" />
<meta property="article:modified_time" content="2022-02-20T14:45:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Argo workflow 案例练习和配置详细解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown" style="font-size: 16px;"> 
 <h2 id="参数化---parameters">参数化 - parameters</h2> 
 <p><code>hello-world-parameters.yaml</code>文件解析</p> 
 <pre class="has"><code class="language-yaml">apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: hello-world-parameters-
spec:

  entrypoint: whalesay    # 调用 whalesay 模板
  arguments:              # 传递给函数的参数
    parameters:           # 声明参数
    - name: message       # Key
      value: hello world  # value

  templates:
  - name: whalesay  # whalesay 模板
    inputs:
      parameters:
      - name: message
    container:
      image: docker/whalesay
      command: [cowsay]
      args: ["{<!-- -->{inputs.parameters.message}}"]</code></pre> 
 <p>提交此工作流时，可以指定<strong>实际参数值</strong>：</p> 
 <pre class="has"><code class="language-bash">[root@k8s-master01 argo]# argo submit -n argo arguments-parameters.yaml -p message="goodbye world"
[root@k8s-master01 argo]# argo logs -n argo hello-world-parameters-xxx</code></pre> 
 <p><img src="https://images2.imgbox.com/a0/5f/4mBPXvGa_o.png" alt="image-20220210101035695" style="outline: none;"></p> 
 <h2 id="自定义-parameter-数据生产端和消费端">自定义 Parameter 数据生产端和消费端</h2> 
 <p>output 作为生产端信息输出给 input 作为信息消费端，以<code>parameter</code>参数的方式。</p> 
 <pre class="has"><code class="language-yaml">apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: output-parameter-
spec:
  entrypoint: output-parameter
  templates:
  - name: output-parameter
    steps:
    # 产生参数
    - - name: generate-parameter
        template: nginx
    # 消费参数
    - - name: consume-parameter
        template: print-message
        arguments:
          parameters:
          - name: message
            value: "{<!-- -->{steps.generate-parameter.outputs.parameters.nginx-index}}"
  # 生产模板 nginx
  - name: nginx
    container:
      image: nginx:latest
      # 输出 logs，不影响实际的消费信息
      command: [sh, -c]
      args: ["sleep 1; cat /usr/share/nginx/html/index.html"]
    # 输出生产信息
    outputs:
      parameters:
      - name: nginx-index
      # 检查 path 文件是否存在，如果不存在，则输出 "Foobar"
        valueFrom:
          default: "Foobar"
          # 输出文件内容，作为 print-message 的输入内容
          path: /usr/share/nginx/html/index.html
  # 消费模板 print-message
  - name: print-message
    inputs:
      parameters:
      - name: message
    container:
      image: alpine:latest
      # 输出 outputs 过来的信息
      command: [echo]
      args: ["{<!-- -->{inputs.parameters.message}}"]</code></pre> 
 <p>生产端日志</p> 
 <p><img src="https://images2.imgbox.com/ed/08/tQdltJF4_o.png" alt="image-20220212133158906" style="outline: none;"></p> 
 <p>消费端日志</p> 
 <p><img src="https://images2.imgbox.com/ca/e5/pw6fatBN_o.png" alt="image-20220211170647031" style="outline: none;"></p> 
 <h2 id="steps-类型工作流">steps 类型工作流</h2> 
 <p><code>hello-hello-hello.yaml</code>文件解析</p> 
 <pre class="has"><code class="language-yaml">apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: steps-          # Workflow 的名称前缀
spec:
  entrypoint: hello-hello-hello # 表示第一个执行的模板名称，让工作流知道从哪个模板开始执行，类似于 main 函数

  # 该templates中有两个模板，分别是：hello-hello-hello和whalesay
  templates:
  - name: hello-hello-hello     # 第一个模板 hello-hello-hello 
    steps:                      # template 的类型是 steps
    # 一个 template 有多种类型，分别为：container、script、dag、steps、resource、suspend
    - - name: hello1            # 在 steps 类型中，[--] 表示顺序执行，[-] 表示并行执行
        template: whalesay      # 引用 whalesay 模板
        arguments:              # 传递给函数的参数
          parameters:           # 声明参数
          - name: message       # Key
            value: "hello1"     # value
    - - name: hello2a           # [--] 顺序执行
        template: whalesay
        arguments:
          parameters:
          - name: message
            value: "hello2a"
      - name: hello2b           # [-] 表示跟上一步并行运行
        template: whalesay
        arguments:
          parameters:
          - name: message
            value: "hello2b"

  - name: whalesay   # 第二个模板 whalesay 
    inputs:          # input、output 实现数据交互
      parameters:
      - name: message
    container:
      image: docker/whalesay  # 镜像名称
      command: [cowsay]       # 执行命令
      args: ["{<!-- -->{inputs.parameters.message}}"]  # 参数引用</code></pre> 
 <p>上面的工作流规范打印了三种不同的“hello”。hello-hello-hello模板由三个步骤组成。名为hello1的第一步将按顺序运行，而名为hello2a和hello2b的后面两个步骤将并行运行。使用argo CLI命令，我们可以图形化地显示这个工作流规范的执行历史，它显示了名为hello2a和hello2b的步骤彼此并行运行。</p> 
 <p><img src="https://images2.imgbox.com/d8/63/UPjPuE6I_o.png" alt="image-20220211094155895" style="outline: none;"></p> 
 <h2 id="dag工作流">DAG工作流</h2> 
 <p>作为指定步骤序列的另一种方法，您可以通过指定每个任务的依赖关系来将工作流定义为有向无环图(DAG)。对于复杂的工作流，这可以更容易维护，并且在运行任务时允许最大程度的并行性。</p> 
 <p>在下面的工作流中，步骤A首先运行，因为它没有依赖项。一旦<code>A</code>完成，步骤<code>B</code>和步骤<code>C</code>将并行运行。最后，一旦<code>B</code>和<code>C</code>完成，步骤<code>D</code>就可以运行了。</p> 
 <p><code>dag-diamond.yaml</code>文件解析</p> 
 <pre class="has"><code class="language-yaml">apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: dag-diamond-
spec:
  entrypoint: diamond
  # 分别有 echo 和 diamond 两个模板
  templates:
  - name: echo
    inputs:
      parameters:     # 声明参数
      - name: message
    container:
      image: alpine:3.7
      command: [echo, "{<!-- -->{inputs.parameters.message}}"]
  # 入口点模板
  - name: diamond
    # DAG声明
    dag:
      tasks:
      - name: A
        template: echo
        arguments:
          parameters: [{name: message, value: A}]
      - name: B
        # 任务B依赖于任务A
        dependencies: [A]
        template: echo
        arguments:
          parameters: [{name: message, value: B}]
      - name: C
        dependencies: [A]
        template: echo
        arguments:
          parameters: [{name: message, value: C}]
      - name: D
        # 任务D同时依赖于任务B、C
        dependencies: [B, C]
        template: echo
        arguments:
          parameters: [{name: message, value: D}]</code></pre> 
 <p><img src="https://images2.imgbox.com/10/8e/250iwZp6_o.png" alt="image-20220211101622960" style="outline: none;"></p> 
 <h2 id="artifacts-工作流">Artifacts 工作流</h2> 
 <p>通过 input/output 以及 artifacts 实现 Job 之间数据传递。</p> 
 <p>在工作流中，某些步骤产生或者消费构件，是很常见的需求。通常，前一环节的输出构件，用作下一环节的输入构件。</p> 
 <p>下面的例子包含两个Step，前一个步骤产生构件供后一个消费。</p> 
 <p><code>artifact-passing.yaml</code>文件解析</p> 
 <pre class="has"><code class="language-yaml">apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: artifact-passing-
spec:
  entrypoint: artifact-example
  templates:
  - name: artifact-example
    steps:
    # 产生构件
    - - name: generate-artifact
        template: whalesay
    # 消费构件
    - - name: consume-artifact
        template: print-message
        arguments:
          artifacts:
          # 绑定构件名message到generate-artifact，输出制品库 hello-art 内容
          - name: message
            from: "{<!-- -->{steps.generate-artifact.outputs.artifacts.hello-art}}"
 
  # 此模板产生构件
  - name: whalesay
    container:
      image: docker/whalesay:latest
      command: [sh, -c]
      args: ["cowsay hello world | tee /tmp/hello_world.txt"] 
    # 输出构件声明
    outputs:
      artifacts:
      - name: hello-art            # 生成制品共享 hello-art
        path: /tmp/hello_world.txt # 把这个文件打包后上传到制品库中
 
  # 此模板消费构件
  - name: print-message
    # 输入构件声明
    inputs:
      artifacts:
      - name: message
        path: /tmp/message
    container:
      image: alpine:latest
      command: [sh, -c]
      args: ["cat /tmp/message"]</code></pre> 
 <p>生产信息</p> 
 <p><img src="https://images2.imgbox.com/fb/a2/Wf8S3SBp_o.png" alt="image-20220211100015508" style="outline: none;"></p> 
 <p>消费信息</p> 
 <p><img src="https://images2.imgbox.com/79/ba/LF7gPDD3_o.png" alt="image-20220211100049730" style="outline: none;"></p> 
 <h2 id="scripts--results">Scripts &amp; Results</h2> 
 <p>很多情况下，我们仅仅希望 Template 来执行一个脚本：</p> 
 <pre class="has"><code class="language-yaml">apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: scripts-bash-
spec:
  entrypoint: bash-script-example
  templates:
  - name: bash-script-example
    steps:
    - - name: generate
        # 调用其中一个模板，分别有 gen-random-int-bash、python、javascript
        template: gen-random-int-python
    - - name: print
        template: print-message
        arguments:
          parameters:
          - name: message
            # 引用 result 此特殊的输出参数
            value: "{<!-- -->{steps.generate.outputs.result}}"
 
  - name: gen-random-int-bash
    # 在 script 关键字的 source 标签中，可以编写脚本
    # script 还导致执行脚本时的标准输出，保存为名为 result 的特殊输出参数
    script:
      image: debian:9.4
      command: [bash]
      # Shell 脚本随机生成一个数值
      source: |
        cat /dev/urandom | od -N2 -An -i | awk -v f=1 -v r=100 '{printf "%i\n", f + r * $1 / 65536}'
 
  - name: gen-random-int-python
    script:
      image: python:alpine3.6
      command: [python]
      # Python 脚本随机生成数值
      source: |
        import random
        i = random.randint(1, 100)
        print(i)
 
  - name: gen-random-int-javascript
    script:
      image: node:9.1-alpine
      command: [node]
      # JS 脚本随机生成数值
      source: |
        var rand = Math.floor(Math.random() * 100);
        console.log(rand);

  # 输出随机数模板 print-message
  - name: print-message
    inputs:
      parameters:
      - name: message
    container:
      image: alpine:latest
      command: [sh, -c]
      args: ["echo result was: {<!-- -->{inputs.parameters.message}}"]</code></pre> 
 <p>generate 模板调用 gen-random-int-python 任务随机生成个<code>50</code>数值，print 模板利用<code>result</code>特殊参数调用输出，如图所示。</p> 
 <p><img src="https://images2.imgbox.com/fe/7e/FudEnsGO_o.png" alt="image-20220212211251941" style="outline: none;"></p> 
 <p><img src="https://images2.imgbox.com/3d/77/caJaVAaR_o.png" alt="image-20220212211302761" style="outline: none;"></p> 
 <h2 id="退出处理器工作流">退出处理器工作流</h2> 
 <p>Exit handler是一种必然会在工作流结尾执行的模板，不论工作流执行成功与否。它的运用场景包括：</p> 
 <ul><li>工作流运行后清理</li><li>发送工作流状态的通知(例如，电子邮件/Slack)</li><li>将成功/失败状态传递为 Webhook 结果(例如GitHub Build Result)</li><li>重新提交工作流 或 提交另外一个工作流</li></ul> 
 <pre class="has"><code class="language-yaml">apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: exit-handlers-
spec:
  entrypoint: intentional-fail
  # 在工作流的末尾调用退出处理程序模板
  onExit: exit-handler
  templates:
  # 工作流主模板
  - name: intentional-fail
    container:
      image: alpine:latest
      command: [sh, -c]
      # exit 1 表示工作流异常退出，exit 0 表示工作流成功退出
      args: ["echo intentional failure; exit 1"]
 
  # 退出处理器模板
  # 主模板完成后，工作流状态可以通过全局变量{<!-- -->{workflow.status}}获取，其值是Succeeded, Failed, Error之一
  - name: exit-handler
    steps:
    # 无论工作流是否成功，都会调用 send-email 模板
    - - name: notify
        template: send-email
      # 如果工作流等于 Succeeded，才会调用 celebrate 模板
      - name: celebrate
        template: celebrate
        when: "{<!-- -->{workflow.status}} == Succeeded"
      # 如果工作流不等于 Succeeded，则会调用 cry 模板
      - name: cry
        template: cry
        when: "{<!-- -->{workflow.status}} != Succeeded"
  # send-email 模板信息
  - name: send-email
    container:
      image: alpine:latest
      command: [sh, -c]
      # 输出工作流名称和工作流状态
      args: ["echo send e-mail: {<!-- -->{workflow.name}} {<!-- -->{workflow.status}}"]
  # celebrate 模板信息
  - name: celebrate
    container:
      image: alpine:latest
      command: [sh, -c]
      args: ["echo hooray!"]
  # cry 模板信息
  - name: cry
    container:
      image: alpine:latest
      command: [sh, -c]
      args: ["echo boohoo!"]</code></pre> 
 <p>接下来分别演示工作流成功和不成功所执行的任务，只需要更改<code>exit 0/1</code>状态码即可。</p> 
 <p>演示工作流不成功：</p> 
 <p><img src="https://images2.imgbox.com/4d/7a/NIFXLi7L_o.png" alt="image-20220212224403703" style="outline: none;"></p> 
 <p><img src="https://images2.imgbox.com/05/8c/ODU5v2Qc_o.png" alt="image-20220212224519835" style="outline: none;"></p> 
 <p><img src="https://images2.imgbox.com/b6/0c/HkfwCBoe_o.png" alt="image-20220212224454586" style="outline: none;"></p> 
 <p>演示工作流成功：</p> 
 <p><img src="https://images2.imgbox.com/77/b4/VeBbuBxd_o.png" alt="image-20220212224552604" style="outline: none;"></p> 
 <p><img src="https://images2.imgbox.com/8a/b2/FSILkaip_o.png" alt="image-20220212224610458" style="outline: none;"></p> 
 <p><img src="https://images2.imgbox.com/38/ff/ToRsBrfv_o.png" alt="image-20220212224626056" style="outline: none;"></p> 
 <p>简单的将官方案例进行实践和配置详细解析，欢迎有研究Argo的大佬们一起交流交流，多多指教！</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2289b1c33006d45e330033ef27ff9437/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信猜谜语小程序源码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cfe22399c68c4ebb59fba7c4c6052a12/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vs2017安装驱动环境版本的选择</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>