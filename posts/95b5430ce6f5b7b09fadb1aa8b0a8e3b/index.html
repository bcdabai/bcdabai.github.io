<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>spring如何解决循环依赖 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="spring如何解决循环依赖" />
<meta property="og:description" content="文章目录 1、什么是循环依赖？2、怎么检测循环依赖3、Spring怎么解决循环依赖4、循环依赖的N种场景3.1、单例的setter注入3.2、多例的setter注入3.3、构造器注入3.4、单例的代理对象setter注入3.5、DependsOn循环依赖 5、出现循环依赖如何解决？5.1、生成代理对象产生的循环依赖5.2、DependsOn循环依赖5.3、多例循环依赖5.3、构造器循环依赖 这里我们主要分析Spring bean的循环依赖，以及Spring的解决方式。 通过这种解决方式，我们可以应用在我们实际开发项目中。
1、什么是循环依赖？
2、怎么检测循环依赖
3、循环依赖的N种场景
3、Spring怎么解决循环依赖
4、Spring对于循环依赖无法解决的场景
5、Spring解决循环依赖的方式我们能够学到什么？
以下基于spring5.0.x版本源码进行分析
1、什么是循环依赖？ 循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：
注意，这里不是函数的循环调用，是对象的相互依赖关系。循环调用其实就是一个死循环，除非有终结条件。
Spring中循环依赖场景主要有以下两种：
（1）field属性的循环依赖
（2）构造器的循环依赖
（3）DependsOn循环依赖
2、怎么检测循环依赖 检测循环依赖相对比较容易，Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。
3、Spring怎么解决循环依赖 Spring解决循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。
Spring的单例对象的初始化主要分为三步：
实例化：其实也就是调用对象的构造方法实例化对象注入：填充属性，这一步主要是对bean的依赖属性进行填充初始化：属性注入后，执行自定义初始化 从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。
那么我们要解决循环引用也应该从bean初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。
首先我们看源码，三级缓存主要指：
/** Cache of singleton objects: bean name --&gt; bean instance */ private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256); /** Cache of singleton factories: bean name --&gt; ObjectFactory */ private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16); /** Cache of early singleton objects: bean name --&gt; bean instance */ private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16); 这三级缓存分别指：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/95b5430ce6f5b7b09fadb1aa8b0a8e3b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-11T13:21:04+08:00" />
<meta property="article:modified_time" content="2022-03-11T13:21:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">spring如何解决循环依赖</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_16" rel="nofollow">1、什么是循环依赖？</a></li><li><a href="#2_27" rel="nofollow">2、怎么检测循环依赖</a></li><li><a href="#3Spring_29" rel="nofollow">3、Spring怎么解决循环依赖</a></li><li><a href="#4N_149" rel="nofollow">4、循环依赖的N种场景</a></li><li><ul><li><a href="#31setter_153" rel="nofollow">3.1、单例的setter注入</a></li><li><a href="#32setter_235" rel="nofollow">3.2、多例的setter注入</a></li><li><a href="#33_273" rel="nofollow">3.3、构造器注入</a></li><li><a href="#34setter_299" rel="nofollow">3.4、单例的代理对象setter注入</a></li><li><a href="#35DependsOn_361" rel="nofollow">3.5、DependsOn循环依赖</a></li></ul> 
  </li><li><a href="#5_388" rel="nofollow">5、出现循环依赖如何解决？</a></li><li><ul><li><a href="#51_391" rel="nofollow">5.1、生成代理对象产生的循环依赖</a></li><li><a href="#52DependsOn_397" rel="nofollow">5.2、DependsOn循环依赖</a></li><li><a href="#53_400" rel="nofollow">5.3、多例循环依赖</a></li><li><a href="#53_403" rel="nofollow">5.3、构造器循环依赖</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<p>这里我们主要分析Spring bean的循环依赖，以及Spring的解决方式。 通过这种解决方式，我们可以应用在我们实际开发项目中。</p> 
<p>1、什么是循环依赖？<br> 2、怎么检测循环依赖<br> 3、循环依赖的N种场景<br> 3、Spring怎么解决循环依赖<br> 4、Spring对于循环依赖无法解决的场景<br> 5、Spring解决循环依赖的方式我们能够学到什么？</p> 
<hr> 
<p><code>以下基于spring5.0.x版本源码进行分析</code></p> 
<h2><a id="1_16"></a>1、什么是循环依赖？</h2> 
<p>循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：<br> <img src="https://images2.imgbox.com/33/45/G7RnJJ7D_o.png" alt="循环依赖示例"></p> 
<p>注意，这里不是函数的循环调用，是对象的相互依赖关系。循环调用其实就是一个死循环，除非有终结条件。</p> 
<p>Spring中循环依赖场景主要有以下两种：<br> （1）field属性的循环依赖<br> （2）构造器的循环依赖<br> （3）DependsOn循环依赖</p> 
<h2><a id="2_27"></a>2、怎么检测循环依赖</h2> 
<p>检测循环依赖相对比较容易，Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。</p> 
<h2><a id="3Spring_29"></a>3、Spring怎么解决循环依赖</h2> 
<p>Spring解决循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。</p> 
<p>Spring的单例对象的初始化主要分为三步：</p> 
<ol><li><strong>实例化</strong>：其实也就是调用对象的构造方法实例化对象</li><li><strong>注入</strong>：填充属性，这一步主要是对bean的依赖属性进行填充</li><li><strong>初始化</strong>：属性注入后，执行自定义初始化</li></ol> 
<p><img src="https://images2.imgbox.com/8b/0a/OyBQnekL_o.png" alt="在这里插入图片描述"><br> 从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。</p> 
<p>那么我们要解决循环引用也应该从bean初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。</p> 
<p>首先我们看源码，三级缓存主要指：</p> 
<pre><code class="prism language-java">	<span class="token comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;&gt;</span> singletonFactories <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> earlySingletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这三级缓存分别指：<br> singletonObjects：单例对象的cache<br> singletonFactories ： 单例对象工厂的cache<br> earlySingletonObjects ：提前暴光的单例对象的Cache</p> 
<p>我们在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。主要调用方法就是：</p> 
<pre><code class="prism language-java">	<span class="token keyword">protected</span> Object <span class="token function">getSingleton</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		Object singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> singletonFactory <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>singletonFactory <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> singletonObject<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码需要解释两个参数：</p> 
<ul><li>allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象</li><li>isSingletonCurrentlyInCreation()判断当前单例bean是否正在创建中，也就是没有初始化完成(比如A的构造器依赖了B对象所以得先去创建B对象， 或则在A的populateBean过程中依赖了B对象，得先去创建B对象，这时的A就是处于创建中的状态。)</li></ul> 
<p>分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，如果获取到了则：<br> 从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</p> 
<pre><code class="prism language-java">	<span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>从上面三级缓存的分析，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory，定义如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ObjectFactory</span><span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>

	<span class="token comment">/**
	 * Return an instance (possibly shared or independent)
	 * of the object managed by this factory.
	 * @return the resulting instance
	 * @throws BeansException in case of creation errors
	 */</span>
	T <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>调用createBeanInstance实例化后，<strong>如果bean是单例，且允许从singletonFactories获取bean，并且当前bean正在创建中</strong>，那么就把beanName放入三级缓存(singletonFactories)中:<br> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p> 
<pre><code class="prism language-java"><span class="token comment">// Eagerly cache singletons to be able to resolve circular references</span>
<span class="token comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span>
<span class="token keyword">boolean</span> earlySingletonExposure <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences <span class="token operator">&amp;&amp;</span>
		<span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Eagerly caching bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span>
				<span class="token string">"' to allow for resolving potential circular references"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> ObjectFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> singletonFactory<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>singletonFactory<span class="token punctuation">,</span> <span class="token string">"Singleton factory must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>registeredSingletons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里就是解决循环依赖的关键，这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p> 
<p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况：<br> <img src="https://images2.imgbox.com/b9/bf/Y36AtUQc_o.png" alt="在这里插入图片描述"><br> spring初始化bean的过程如下：<br> 1&gt;首先尝试从一级缓存中获取serviceA实例，发现不存在并且serviceA不在创建过程中；<br> 2&gt;serviceA完成了初始化的第一步（实例化：调用createBeanInstance方法，即调用默认构造方法实例化）；<br> 3&gt;将自己(serviceA)提前曝光到singletonFactories中;<br> 4&gt;此时进行初始化的第二步（注入属性serviceB），发现自己依赖对象serviceB，此时就尝试去get(B)，发现B还没有被实create，所以走create流程;<br> 5&gt;serviceB完成了初始化的第一步（实例化：调用createBeanInstance方法，即调用默认构造方法实例化）；<br> 6&gt;将自己(serviceB)提前曝光到singletonFactories中;<br> 7&gt;此时进行初始化的第二步（注入属性serviceA）;<br> 8&gt;于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀);<br> 9&gt;B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中；<br> 10&gt;此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中;</p> 
<p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p> 
<h2><a id="4N_149"></a>4、循环依赖的N种场景</h2> 
<p><img src="https://images2.imgbox.com/89/6d/I9o7CHaS_o.png" alt="在这里插入图片描述"><br> <code>这里主要讲解spring是如何解决单例setter注入时的循环依赖问题，其他四种循环依赖场景后文再一一分析讲解</code></p> 
<h3><a id="31setter_153"></a>3.1、单例的setter注入</h3> 
<p>这种注入方式应该是spring用的最多的，代码如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceA</span> <span class="token punctuation">{<!-- --></span>

	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> ServiceB serviceB<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceB</span> <span class="token punctuation">{<!-- --></span>

	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> ServiceA serviceA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>spring内部有三级缓存：</p> 
<ul><li>singletonObjects 一级缓存，用于保存实例化、注入、初始化完成的bean实例</li><li>earlySingletonObjects 二级缓存，用于保存实例化完成的bean实例</li><li>singletonFactories 三级缓存，用于保存bean创建工厂，以便于后面扩展有机会创建代理对象。</li></ul> 
<p>下面用一张图告诉你，spring是如何解决循环依赖的：<br> 图1<br> <img src="https://images2.imgbox.com/9d/0f/jFrhRSpT_o.png" alt="图1"><br> 上面(3、Spring怎么解决循环依赖)中已经讲解过spring解决单例循环依赖的过程，这里细心的朋友可能会发现在这种场景中第二级缓存(<strong>earlySingletonObjects</strong>)作用不大。<br> <strong>那么问题来了，为什么要用第二级缓存呢？</strong><br> 试想一下，如果出现以下这种情况，我们要如何处理？</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceA</span> <span class="token punctuation">{<!-- --></span>

	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> ServiceB serviceB<span class="token punctuation">;</span>
	
	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> ServiceB serviceC<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceB</span> <span class="token punctuation">{<!-- --></span>

	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> ServiceA serviceA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceC</span> <span class="token punctuation">{<!-- --></span>

	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> ServiceA serviceA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>serviceA依赖于serviceB和serviceC，而serviceB依赖于serviceA，同时serviceC也依赖于serviceA。按照上图的流程可以把serviceA注入到serviceB，并且sServiceA的实例是从第三级缓存中获取的。假设不用第二级缓存，serviceA注入到serviceC的流程如图：<br> 图2<br> <img src="https://images2.imgbox.com/cd/1a/CB31vfp5_o.png" alt="在这里插入图片描述"><br> serviceA注入到serviceC又需要从第三级缓存中获取实例，而第三级缓存里保存的并非真正的实例对象，而是ObjectFactory对象。说白了，两次从三级缓存中获取都是ObjectFactory对象，而通过它创建的实例对象每次可能都不一样的。这样不是有问题？</p> 
<p>为了解决这个问题，spring引入的第二级缓存。上面图1其实serviceA对象的实例已经被添加到第二级缓存中了，而在serviceA注入到TestService3时，只用从第二级缓存中获取该对象即可。<br> 图3<br> <img src="https://images2.imgbox.com/10/62/Dz1xWdcn_o.png" alt="在这里插入图片描述"><br> 还有个问题，第三级缓存中为什么要添加ObjectFactory对象，直接保存实例对象不行吗？<br> 答：不行，因为假如你想对添加到三级缓存中的实例对象进行增强，直接用实例对象是行不通的。<br> 针对这种场景spring是怎么做的呢？<br> 答案就在AbstractAutowireCapableBeanFactory类doCreateBean方法的这段代码中：</p> 
<pre><code class="prism language-java"><span class="token comment">// Eagerly cache singletons to be able to resolve circular references</span>
<span class="token comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span>
<span class="token keyword">boolean</span> earlySingletonExposure <span class="token operator">=</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>allowCircularReferences <span class="token operator">&amp;&amp;</span>
		<span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>earlySingletonExposure<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Eagerly caching bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span>
				<span class="token string">"' to allow for resolving potential circular references"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>它定义了一个匿名内部类，通过getEarlyBeanReference方法获取代理对象，其实底层是通过AbstractAutoProxyCreator类的getEarlyBeanReference生成代理对象。</p> 
<h3><a id="32setter_235"></a>3.2、多例的setter注入</h3> 
<p>这种注入方法偶然会有，具体代码如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>ConfigurableBeanFactory<span class="token punctuation">.</span>SCOPE_PROTOTYPE<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceA</span> <span class="token punctuation">{<!-- --></span>

	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> ServiceB serviceB<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>ConfigurableBeanFactory<span class="token punctuation">.</span>SCOPE_PROTOTYPE<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceB</span> <span class="token punctuation">{<!-- --></span>

	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> ServiceA serviceA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可能你会认为这种情况spring容器启动会报错，其实是不会，为什么呢？其实在AbstractApplicationContext类的refresh方法中告诉了我们答案，它会调用finishBeanFactoryInitialization方法，该方法的作用是为了spring容器启动的时候提前初始化一些bean。该方法的内部又调用了beanFactory.preInstantiateSingletons()方法：<br> <img src="https://images2.imgbox.com/09/8e/dpwEG4Tc_o.png" alt="在这里插入图片描述"><br> 红框的地方明显能够看出：非抽象、单例 并且非懒加载的类才能被提前初始bean。而多例即SCOPE_PROTOTYPE类型的类，非单例，不会被提前初始化bean，所以程序能够正常启动。如何让它提前初始化bean呢？只需要再定义一个单例的类，在它里面注入serviceA:</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceC</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> ServiceA serviceA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>重新启动程序，执行结果：</p> 
<blockquote> 
 <p>Requested bean is currently in creation: Is there an unresolvable circular reference?</p> 
</blockquote> 
<p>果然出现了循环依赖。</p> 
<p>注意：这种循环依赖问题是无法解决的，因为它没有用缓存，每次都会生成一个新对象。</p> 
<h3><a id="33_273"></a>3.3、构造器注入</h3> 
<p>这种注入方式现在其实用的已经非常少了，但是我们还是有必要了解一下，看看如下代码：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceA</span> <span class="token punctuation">{<!-- --></span>

	<span class="token keyword">public</span> <span class="token function">ServiceA</span><span class="token punctuation">(</span>ServiceB serviceB<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceB</span> <span class="token punctuation">{<!-- --></span>

	<span class="token keyword">public</span> <span class="token function">ServiceB</span><span class="token punctuation">(</span>ServiceA serviceA<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果：</p> 
<blockquote> 
 <p>Requested bean is currently in creation: Is there an unresolvable circular reference?</p> 
</blockquote> 
<p>出现了循环依赖，为什么呢？<br> <img src="https://images2.imgbox.com/a2/78/YprakGtA_o.png" alt="在这里插入图片描述"><br> 从图中的流程看出构造器注入没能添加到三级缓存，也没有使用缓存，所以也无法解决循环依赖问题。</p> 
<h3><a id="34setter_299"></a>3.4、单例的代理对象setter注入</h3> 
<p>这种注入方式其实也比较常用，比如平时使用：@Async注解的场景，会通过AOP自动生成代理对象。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@EnableAsync</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceA</span> <span class="token punctuation">{<!-- --></span>

	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> ServiceB serviceB<span class="token punctuation">;</span>

	<span class="token annotation punctuation">@Async</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"async"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceB</span> <span class="token punctuation">{<!-- --></span>

	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> ServiceA serviceA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>程序启动会报错，出现了循环依赖：</p> 
<blockquote> 
 <p>org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name ‘serviceA’: Bean with name ‘serviceA’ has been injected into other beans [serviceB] in its raw version as part of a circular reference</p> 
</blockquote> 
<p>为什么会循环依赖呢？答案就在下面这张图中：<br> <img src="https://images2.imgbox.com/05/dc/Q8Njz8Th_o.png" alt="在这里插入图片描述"><br> 说白了，bean初始化完成之后，后面还有一步去检查：第二级缓存是否存在， 代理对象和原始对象是否相等。<br> <img src="https://images2.imgbox.com/50/ea/hFw5rsJe_o.png" alt="在这里插入图片描述"><br> 到此发现第二级缓存存在并且代理对象和原始对象是不相等，因此抛出上面异常。</p> 
<p>如果这时候把ServiceA改个名字，改成：ServiceC，其他的都不变。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceB</span> <span class="token punctuation">{<!-- --></span>

	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> ServiceC serviceC<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@EnableAsync</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceC</span> <span class="token punctuation">{<!-- --></span>

	<span class="token annotation punctuation">@Autowired</span>
	<span class="token keyword">private</span> ServiceB serviceB<span class="token punctuation">;</span>

	<span class="token annotation punctuation">@Async</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"async"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>再重新启动一下程序，成功了，没有报错了!!!<br> 这又是为什么？<br> 这就要从spring的bean加载顺序说起了，默认情况下，spring是按照文件完整路径递归查找的，按路径+文件名排序，排在前面的先加载。所以ServiceA比ServiceB先加载，而改了文件名称之后，ServiceB比ServiceC先加载。为什么ServiceB比ServiceC先加载就没问题呢？答案在下面这张图中：<br> <img src="https://images2.imgbox.com/fd/eb/JAfNuUE9_o.png" alt="在这里插入图片描述"><br> 这种情况ServiceC第二级缓存是空的，不需要跟原始对象判断，所以不会抛出循环依赖。</p> 
<h3><a id="35DependsOn_361"></a>3.5、DependsOn循环依赖</h3> 
<p>还有一种有些特殊的场景，比如我们需要在实例化Bean serviceA之前，先实例化Bean serviceB，这个时候就可以使用@DependsOn注解。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@DependsOn</span><span class="token punctuation">(</span><span class="token string">"serviceB"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceA</span> <span class="token punctuation">{<!-- --></span>
	
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@DependsOn</span><span class="token punctuation">(</span><span class="token string">"serviceA"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServiceB</span> <span class="token punctuation">{<!-- --></span>
	
<span class="token punctuation">}</span>
</code></pre> 
<p>程序启动之后，执行结果：</p> 
<blockquote> 
 <p>Circular depends-on relationship between ‘serviceB’ and ‘serviceA’</p> 
</blockquote> 
<p>这个例子中本来如果ServiceA和ServiceB都没有加@DependsOn注解是没问题的，反而加了这个注解会出现循环依赖问题。</p> 
<p>这又是为什么？</p> 
<p>答案在AbstractBeanFactory类的doGetBean方法的这段代码中：<br> <img src="https://images2.imgbox.com/01/3e/abchyVdc_o.png" alt="在这里插入图片描述"><br> 初始化bean前，它会检查dependsOn的实例有没有循环依赖，如果有循环依赖则抛异常。</p> 
<h2><a id="5_388"></a>5、出现循环依赖如何解决？</h2> 
<p>项目中如果出现循环依赖问题，说明是spring默认无法解决的循环依赖，要看项目的打印日志，属于哪种循环依赖。目前包含下面几种情况：<br> <img src="https://images2.imgbox.com/14/df/P5FJMK74_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="51_391"></a>5.1、生成代理对象产生的循环依赖</h3> 
<p>生成代理对象产生的循环依赖这类循环依赖问题解决方法很多，主要有：<br> 1、使用@Lazy注解，延迟加载<br> 2、使用@DependsOn注解，指定加载先后关系<br> 3、修改文件名称，改变循环依赖类的加载顺序</p> 
<h3><a id="52DependsOn_397"></a>5.2、DependsOn循环依赖</h3> 
<p>使用@DependsOn产生的循环依赖这类循环依赖问题要找到@DependsOn注解循环依赖的地方，迫使它不循环依赖就可以解决问题。</p> 
<h3><a id="53_400"></a>5.3、多例循环依赖</h3> 
<p>多例循环依赖这类循环依赖问题可以通过把bean改成单例的解决。</p> 
<h3><a id="53_403"></a>5.3、构造器循环依赖</h3> 
<p>构造器循环依赖这类循环依赖问题可以通过使用@Lazy注解解决。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/547e3c78ec8d977a9297ea74032d10e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《深入浅出强化学习：原理入门》学习笔记（2）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2da6b296cf3cd9650a5a218884194be4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">信息收集 ——C段扫描</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>