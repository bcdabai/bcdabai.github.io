<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ 基础篇 | 黑马 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RabbitMQ 基础篇 | 黑马" />
<meta property="og:description" content="目录
一、RabbitMQ简介
1、AMQP
2、基本概念
3、工作模式
4、JMS
5、小结
二、快速入门
简单模式
生产者
消费者
三、工作模式
1、Work queues 工作队列模式
2、Pub/Sub 订阅模式
3、Routing 路由模式
4、Topics 通配符模式
四、SpringBoot整合RabbitMQ
1、生产者
2、消费者
3、小结
一、RabbitMQ简介 1、AMQP AMQP，即 Advanced Message Queuing Protocol (高级消息队列协议)，是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP
2007年Rabbit 技术公司基于AMQP 标准开发的 RabbitMQ1.0 发布。
RabbitMQ采用 Erlang 语言开发，Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。
2、基本概念 Brocker：接收和分发消息的应用（RabbitMQ Server）
Virtual host：逻辑分区的概念，类似于网络中的namespace，当多个不同用户使用同一个rabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange/queue等
Connection：publisher/consumer 和 broker 之间的TCP连接
Channel：如果每次访问RabbitMQ都建立Connection。在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel是connection内部建立的逻辑连接，如果应用程序支持多线程，每个thread创建单独的channel进行通信，AMQP method包含了channel id帮助客户端和message broke识别channel，所以channel之间完全是隔离的。channel作为轻量级的connection极大减少了操作系统建立TCP connection的开销。
Exchange：message到达broker的第一站，根据分发规则，匹配查询表中的routing key，分发消息到queue中去
Queue：消息最终被送到这里等待consumer取走
Binding：exchange和queue之间的虚拟连接，binding中包含了routing key，binding信息被包含到exchange查询表中，用户message分发依据
3、工作模式 RabbitMQ 提供了6 种工作模式：简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing路由模式、Topics 主题模式、pC 远程调用模式(程调用，不太算 MQ;暂不作介绍)。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/697b1340d714c3d1a708aa9ba55b66de/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-20T09:19:36+08:00" />
<meta property="article:modified_time" content="2023-04-20T09:19:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ 基础篇 | 黑马</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81RabbitMQ%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81RabbitMQ%E7%AE%80%E4%BB%8B" rel="nofollow">一、RabbitMQ简介</a></p> 
<p id="1%E3%80%81AMQP-toc" style="margin-left:40px;"><a href="#1%E3%80%81AMQP" rel="nofollow">1、AMQP</a></p> 
<p id="2%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">2、基本概念</a></p> 
<p id="3%E3%80%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F" rel="nofollow">3、工作模式</a></p> 
<p id="4%E3%80%81JMS-toc" style="margin-left:40px;"><a href="#4%E3%80%81JMS" rel="nofollow">4、JMS</a></p> 
<p id="5%E3%80%81%E5%B0%8F%E7%BB%93-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E5%B0%8F%E7%BB%93" rel="nofollow">5、小结</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8" rel="nofollow">二、快速入门</a></p> 
<p id="%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F" rel="nofollow">简单模式</a></p> 
<p id="%E7%94%9F%E4%BA%A7%E8%80%85-toc" style="margin-left:80px;"><a href="#%E7%94%9F%E4%BA%A7%E8%80%85" rel="nofollow">生产者</a></p> 
<p id="%E6%B6%88%E8%B4%B9%E8%80%85-toc" style="margin-left:80px;"><a href="#%E6%B6%88%E8%B4%B9%E8%80%85" rel="nofollow">消费者</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F" rel="nofollow">三、工作模式</a></p> 
<p id="1%E3%80%81Work%20queues%20%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#1%E3%80%81Work%20queues%20%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F" rel="nofollow">1、Work queues 工作队列模式</a></p> 
<p id="%C2%A02%E3%80%81Pub%2FSub%20%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%C2%A02%E3%80%81Pub%2FSub%20%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F" rel="nofollow"> 2、Pub/Sub 订阅模式</a></p> 
<p id="3%E3%80%81Routing%20%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#3%E3%80%81Routing%20%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F" rel="nofollow">3、Routing 路由模式</a></p> 
<p id="4%E3%80%81Topics%20%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#4%E3%80%81Topics%20%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F" rel="nofollow">4、Topics 通配符模式</a></p> 
<p id="%E5%9B%9B%E3%80%81SpringBoot%E6%95%B4%E5%90%88RabbitMQ-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81SpringBoot%E6%95%B4%E5%90%88RabbitMQ" rel="nofollow">四、SpringBoot整合RabbitMQ</a></p> 
<p id="1%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85" rel="nofollow">1、生产者</a></p> 
<p id="2%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85" rel="nofollow">2、消费者</a></p> 
<p id="3%E3%80%81%E5%B0%8F%E7%BB%93-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%B0%8F%E7%BB%93" rel="nofollow">3、小结</a></p> 
<hr id="hr-toc"> 
<h2>一、RabbitMQ简介</h2> 
<h3 id="1%E3%80%81AMQP">1、AMQP</h3> 
<p><strong><span style="background-color:#fbd4d0;">AMQP</span></strong>，即 Advanced Message Queuing Protocol (高级消息队列协议)，是一个<span style="background-color:#fbd4d0;">网络协议</span>，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP</p> 
<p><img alt="" height="516" src="https://images2.imgbox.com/34/91/aP3C9CJc_o.png" width="1200"></p> 
<p>2007年Rabbit 技术公司基于AMQP 标准开发的 RabbitMQ1.0 发布。</p> 
<p>RabbitMQ采用<span style="background-color:#fbd4d0;"> Erlang </span>语言开发，Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/dd/17/VAKMK2or_o.png" width="1200"></p> 
<h3 id="2%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2、基本概念</h3> 
<p><strong><span style="background-color:#fbd4d0;">Brocker：</span></strong>接收和分发消息的应用（RabbitMQ Server）</p> 
<p><strong><span style="background-color:#fbd4d0;">Virtual host：</span></strong>逻辑分区的概念，类似于网络中的namespace，当多个不同用户使用同一个rabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange/queue等</p> 
<p><strong><span style="background-color:#fbd4d0;">Connection：</span></strong>publisher/consumer 和 broker 之间的TCP连接</p> 
<p><strong><span style="background-color:#fbd4d0;">Channel：</span></strong>如果每次访问RabbitMQ都建立Connection。在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel是connection内部建立的逻辑连接，如果应用程序支持多线程，每个thread创建单独的channel进行通信，AMQP method包含了channel id帮助客户端和message broke识别channel，所以channel之间完全是隔离的。channel作为轻量级的connection极大减少了操作系统建立TCP connection的开销。</p> 
<p><strong><span style="background-color:#fbd4d0;">Exchange：</span></strong>message到达broker的第一站，根据分发规则，匹配查询表中的routing key，分发消息到queue中去</p> 
<p><strong><span style="background-color:#fbd4d0;">Queue：</span></strong>消息最终被送到这里等待consumer取走</p> 
<p><strong><span style="background-color:#fbd4d0;">Binding：</span></strong>exchange和queue之间的虚拟连接，binding中包含了routing key，binding信息被包含到exchange查询表中，用户message分发依据</p> 
<h3 id="3%E3%80%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">3、工作模式</h3> 
<p>RabbitMQ 提供了6 种工作模式：简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing路由模式、Topics 主题模式、pC 远程调用模式(程调用，不太算 MQ;暂不作介绍)。</p> 
<p><img alt="" height="271" src="https://images2.imgbox.com/12/2c/1s5TlLyz_o.png" width="524"></p> 
<h3 id="4%E3%80%81JMS">4、JMS</h3> 
<ul><li>JMS即Java消息服务应用程序接口，是一个Java平台中关于面向消息中间件的API</li><li>JMS 即Java 消息服务(JavaMessage Service) 应用程序接口，是一个Java 平台中关于面向消息中间件的API</li><li>JMS 是JavaEE 规范中的一种，类比JDBC</li><li>很多消息中间件都实现了JMS规范，例如: ActiveMQ。RabbitMO 官方没有提供JMS 的实现包，但是开源社区有</li></ul> 
<h3 id="5%E3%80%81%E5%B0%8F%E7%BB%93">5、小结</h3> 
<ul><li>RabbitMQ是基于AMQP 协议使用 Erlang 语言开发的一款消息队列产品。</li><li>RabbitMQ提供了6种工作模式，我们学习5种。这是今天的重点。</li><li>AMQP 是协议，类比HTTP</li><li>JMS 是API 规范接口，类比JDBC</li></ul> 
<h2 id="%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">二、快速入门</h2> 
<h3 id="%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F">简单模式</h3> 
<p><img alt="" height="99" src="https://images2.imgbox.com/2d/e1/nWGSEmfk_o.png" width="283"></p> 
<h4 id="%E7%94%9F%E4%BA%A7%E8%80%85"><strong>生产者</strong></h4> 
<p>先创建两个模块一个生产者模块一个消费者的，然后分别引入rabbitMQ的依赖</p> 
<p><img alt="" height="747" src="https://images2.imgbox.com/a2/e5/FY0K1yQN_o.png" width="1075"></p> 
<p><img alt="" height="608" src="https://images2.imgbox.com/40/97/nUOJWMT9_o.png" width="1192"></p> 
<h4 id="%E6%B6%88%E8%B4%B9%E8%80%85">消费者</h4> 
<p>前面连接跟生产者的一样，就接收消息的发方法不一样用下面这个 </p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/86/1b/36hsWHcV_o.png" width="568"></p> 
<p><img alt="" height="549" src="https://images2.imgbox.com/7e/ad/Zqx9asPQ_o.png" width="1200"></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">三、工作模式</h2> 
<h3 id="1%E3%80%81Work%20queues%20%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F">1、Work queues 工作队列模式</h3> 
<p>多个消费者共同消费同个队列的消息，他们两个只有一个能拿到消息</p> 
<p>一个队列中如果有多个消费者，那么消费者之间对于同一个消息关系是竞争关系</p> 
<p><img alt="" height="269" src="https://images2.imgbox.com/46/fd/CL3GytKD_o.png" width="824"></p> 
<p><strong>应用场景：</strong>对于任务过重或任务较多情况使用工作队列可以提高任务处理速度，比如发短信服务器部署多个，只需要一个交接点成功发送即可。</p> 
<h3 id="%C2%A02%E3%80%81Pub%2FSub%20%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"> 2、Pub/Sub 订阅模式</h3> 
<p><img alt="" height="236" src="https://images2.imgbox.com/ad/13/Aj24MKUQ_o.png" width="1096"></p> 
<p>在订阅模型中，多了一个Exchange 角色，而且过程略有变化:</p> 
<ul><li>P:生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X(交换机)</li><li>C:消费者，消息的接收者，会一直等待消息到来</li><li>Queue:消息队列，接收消息、缓存消息</li><li>Exchange: 交换机(X)。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型: 
  <ul><li>&gt;Fanout:广播，将消息交给所有绑定到交换机的队列</li><li>&gt;Direct:定向，把消息交给符合指定routing key的队列</li><li>&gt;Topic:通配符，把消息交给符合routing pattern (路由模式) 的队列</li></ul></li></ul> 
<blockquote> 
 <p><strong>Exchange </strong>(交换机) 只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失!</p> 
</blockquote> 
<p><img alt="" height="419" src="https://images2.imgbox.com/9a/8e/QvEwIkUn_o.png" width="511"></p> 
<p>创建交换机的参数：</p> 
<p><img alt="" height="399" src="https://images2.imgbox.com/6a/34/SOnlE3q2_o.png" width="1200"></p> 
<p><img alt="" height="547" src="https://images2.imgbox.com/07/43/X6AYICoS_o.png" width="1200"></p> 
<h3 id="3%E3%80%81Routing%20%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F">3、Routing 路由模式</h3> 
<p>比如我们要让一个队列是发到保存数据库的，一个是输出控制台的，数据库只保存error，控制台都数据，这个时候就需要用到路由模式来匹配</p> 
<ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个 <span style="background-color:#fbd4d0;">RoutingKey (路由key)</span></li><li>消息的发送方在向Exchange发送消息时，也必须指定消息的<span style="background-color:#fbd4d0;"> RoutingKeyExchange</span></li><li>不再把消息交给每一个绑定的队列，而是根据消息的 Routing Key 进行判断，只有队列的Routingkey 与消息的 Routing key 完全一致，才会接收到消息</li></ul> 
<p><img alt="" height="248" src="https://images2.imgbox.com/b0/ad/uJnISZ8u_o.png" width="1050"></p> 
<p> <img alt="" height="194" src="https://images2.imgbox.com/6a/79/m8Pt1Jdw_o.png" width="835"></p> 
<p>路由模式要求队列在绑定交换机时要指定 routing key，消息会转发到符合 routing key 的队列。</p> 
<h3 id="4%E3%80%81Topics%20%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F">4、Topics 通配符模式</h3> 
<p><img alt="" height="352" src="https://images2.imgbox.com/bc/40/VHO8Apue_o.png" width="1200"></p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/54/f0/6Iuw5BJF_o.png" width="900"></p> 
<p>类型交换机的类型要改成topics  </p> 
<p>Topic 主题模式可以实现 Pub/Sub 发布与订阅模式和 Routing 路由模式的功能，只是Topic 在配置routing key的时候可以使用通配符，显得更加灵活</p> 
<h2 id="%E5%9B%9B%E3%80%81SpringBoot%E6%95%B4%E5%90%88RabbitMQ">四、SpringBoot整合RabbitMQ</h2> 
<h3 id="1%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85">1、生产者</h3> 
<ol><li>创建生产者SpringBoot工程</li><li>引入依赖坐标</li><li>编写yml配置，基本信息配置</li><li><span style="background-color:#fbd4d0;">定义交换机，队列以及绑定关系的配置类</span></li><li><span style="background-color:#fbd4d0;">注入RabbitTemplate，调用方法，完成消息发送</span></li></ol> 
<p><img alt="" height="249" src="https://images2.imgbox.com/fe/32/lBpt9KPf_o.png" width="747"></p> 
<p>写config配置类</p> 
<p><img alt="" height="812" src="https://images2.imgbox.com/b5/b1/wVnEfwJ2_o.png" width="1200"></p> 
<p>发送消息，templates上要加@AutoWire注解</p> 
<p><img alt="" height="420" src="https://images2.imgbox.com/2d/ab/RIlaquz0_o.png" width="1200"></p> 
<h3 id="2%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85">2、消费者</h3> 
<ol><li>创建消费者SpringBoot工程</li><li>引入start，依赖坐标</li><li>编写yml配置，基本信息配置</li><li><span style="background-color:#fbd4d0;">定义监听类，使用@RabbitListener注解完成队列监听</span></li></ol> 
<p>其他都和生产者一样的，就是做一个监听类，然后监听队列里的消息</p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/5b/26/96QjrYT3_o.png" width="701"></p> 
<h3 id="3%E3%80%81%E5%B0%8F%E7%BB%93">3、小结</h3> 
<ul><li>SpringBoot提供了快速整合RabbitMQ的方式</li><li>基本信息再xml中配置，队列交互机以及绑定关系在配置类中使用Bean的方式配置</li><li>生产端直接注入RabbitTemplate完成消息发送</li><li>消费端直接使用@RabbitListener完成消息接收</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e4fdc1bedd112746895ffad979f0c575/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">算法设计—分支法与回溯法的不同</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/190829057003e79a9d48eb1ed4c876b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SqlSugar ORM初体验(多数据库表结构迁移)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>