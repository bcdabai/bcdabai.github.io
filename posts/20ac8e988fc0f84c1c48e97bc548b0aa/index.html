<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详解SpringCloud之远程方法调用神器Fegin - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="详解SpringCloud之远程方法调用神器Fegin" />
<meta property="og:description" content="第1章：引言 咱们作为Java程序员，在微服务领域里，Spring Cloud可谓是个耳熟能详的大名。它提供了一套完整的微服务解决方案，其中就包括了服务间的通信。在这个微服务中，有一个成员特别引人注意，它就是Feign。
那Feign到底是什么呢？简单来说，Feign是一个声明式的Web服务客户端，它让编写Web服务客户端变得更加简单。我们不用再写一堆复杂的代码来处理HTTP请求，只需要通过简单的接口和注解，就能完成服务间的调用。
在微服务架构中，服务间的通信是一个核心问题。我们之前可能用过很多方式来实现这一点，比如使用RestTemplate。但Feign的出现，让这一切变得更加优雅和简洁。它不仅提供了客户端负载均衡的能力，还能与Spring Cloud的其他组件无缝集成，比如Eureka、Ribbon和Hystrix。
第2章：Feign的基本概念和原理 要理解Feign，咱们得先知道它背后的基本原理。Feign的核心在于它是如何简化HTTP客户端编程的。传统的客户端编程往往需要处理很多繁琐的工作，比如建立连接、发送请求、处理响应等。Feign通过提供一种声明式的方法，让这些工作变得轻而易举。
在Feign中，咱们只需要定义一个接口，然后在接口上添加一些注解，比如@FeignClient。这些注解里包含了调用远程服务所需的所有信息。Feign会根据这些信息，自动构建并发送HTTP请求。是不是听起来很酷？
接下来，小黑给大家看一个简单的例子。假设咱们有一个用户服务，需要调用订单服务的API获取订单信息。使用Feign的话，咱们可以这么做：
java
复制代码
@FeignClient(name = &#34;order-service&#34;) public interface OrderServiceClient { @RequestMapping(method = RequestMethod.GET, value = &#34;/orders/{userId}&#34;) List&lt;Order&gt; getOrdersByUserId(@PathVariable(&#34;userId&#34;) Long userId); } 在这个例子中，OrderServiceClient是一个Feign客户端，它通过@FeignClient注解指定了服务名。方法getOrdersByUserId通过@RequestMapping注解定义了调用的HTTP路径和方法。这样，当这个接口的方法被调用时，Feign就会自动向order-service服务发送一个GET请求到/orders/{userId}路径。
但Feign的神奇之处不止于此。它还提供了客户端负载均衡的功能，这是通过集成Ribbon实现的。Feign还能与Hystrix集成，提供熔断机制，确保在某个服务发生问题时，不会影响到整个系统的稳定性。
通过这些功能，Feign极大地简化了微服务之间的通信，让服务的调用就像调用本地方法一样简单。
第3章：Feign的配置与使用 首先，要使用Feign，咱们得在Spring Cloud项目中加入Feign的依赖。小黑这里用Maven作为例子，但如果咱们用的是Gradle或其他依赖管理工具，步骤也大同小异。
xml
复制代码
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 加入依赖后，下一步是在Spring Boot的主类上添加@EnableFeignClients注解，这样就启用了Feign的功能。
java
复制代码
@SpringBootApplication @EnableFeignClients public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 接着，咱们来创建一个Feign客户端。假设小黑要调用一个用户服务，那么首先定义一个接口，然后在接口上使用@FeignClient注解。在这个注解中，指定了要调用的服务的名称，这个名称对应着在Eureka或其他服务发现工具中注册的服务名。
java
复制代码
@FeignClient(name = &#34;user-service&#34;) public interface UserServiceClient { @GetMapping(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/20ac8e988fc0f84c1c48e97bc548b0aa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-27T21:05:05+08:00" />
<meta property="article:modified_time" content="2024-01-27T21:05:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详解SpringCloud之远程方法调用神器Fegin</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p class="img-center"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzimgs.com%2Fi%2F7E1BH4" rel="nofollow"><img alt="" height="591" src="https://images2.imgbox.com/98/6d/hCBP8rO7_o.png" width="1200"></a></p> 
<h4>第1章：引言</h4> 
<p>咱们作为Java程序员，在微服务领域里，Spring Cloud可谓是个耳熟能详的大名。它提供了一套完整的微服务解决方案，其中就包括了服务间的通信。在这个微服务中，有一个成员特别引人注意，它就是Feign。</p> 
<p>那Feign到底是什么呢？简单来说，Feign是一个声明式的Web服务客户端，它让编写Web服务客户端变得更加简单。我们不用再写一堆复杂的代码来处理HTTP请求，只需要通过简单的接口和注解，就能完成服务间的调用。</p> 
<p>在微服务架构中，服务间的通信是一个核心问题。我们之前可能用过很多方式来实现这一点，比如使用RestTemplate。但Feign的出现，让这一切变得更加优雅和简洁。它不仅提供了客户端负载均衡的能力，还能与Spring Cloud的其他组件无缝集成，比如Eureka、Ribbon和Hystrix。</p> 
<h4>第2章：Feign的基本概念和原理</h4> 
<p>要理解Feign，咱们得先知道它背后的基本原理。Feign的核心在于它是如何简化HTTP客户端编程的。传统的客户端编程往往需要处理很多繁琐的工作，比如建立连接、发送请求、处理响应等。Feign通过提供一种声明式的方法，让这些工作变得轻而易举。</p> 
<p>在Feign中，咱们只需要定义一个接口，然后在接口上添加一些注解，比如<code>@FeignClient</code>。这些注解里包含了调用远程服务所需的所有信息。Feign会根据这些信息，自动构建并发送HTTP请求。是不是听起来很酷？</p> 
<p>接下来，小黑给大家看一个简单的例子。假设咱们有一个用户服务，需要调用订单服务的API获取订单信息。使用Feign的话，咱们可以这么做：</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>@FeignClient(name = "order-service") public interface OrderServiceClient { @RequestMapping(method = RequestMethod.GET, value = "/orders/{userId}") List&lt;Order&gt; getOrdersByUserId(@PathVariable("userId") Long userId); } </code></p> 
<p>在这个例子中，<code>OrderServiceClient</code>是一个Feign客户端，它通过<code>@FeignClient</code>注解指定了服务名。方法<code>getOrdersByUserId</code>通过<code>@RequestMapping</code>注解定义了调用的HTTP路径和方法。这样，当这个接口的方法被调用时，Feign就会自动向<code>order-service</code>服务发送一个GET请求到<code>/orders/{userId}</code>路径。</p> 
<p>但Feign的神奇之处不止于此。它还提供了客户端负载均衡的功能，这是通过集成Ribbon实现的。Feign还能与Hystrix集成，提供熔断机制，确保在某个服务发生问题时，不会影响到整个系统的稳定性。</p> 
<p>通过这些功能，Feign极大地简化了微服务之间的通信，让服务的调用就像调用本地方法一样简单。</p> 
<h4>第3章：Feign的配置与使用</h4> 
<p>首先，要使用Feign，咱们得在Spring Cloud项目中加入Feign的依赖。小黑这里用Maven作为例子，但如果咱们用的是Gradle或其他依赖管理工具，步骤也大同小异。</p> 
<pre></pre> 
<p>xml</p> 
<p>复制代码</p> 
<p><code>&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; </code></p> 
<p>加入依赖后，下一步是在Spring Boot的主类上添加<code>@EnableFeignClients</code>注解，这样就启用了Feign的功能。</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>@SpringBootApplication @EnableFeignClients public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } </code></p> 
<p>接着，咱们来创建一个Feign客户端。假设小黑要调用一个用户服务，那么首先定义一个接口，然后在接口上使用<code>@FeignClient</code>注解。在这个注解中，指定了要调用的服务的名称，这个名称对应着在Eureka或其他服务发现工具中注册的服务名。</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>@FeignClient(name = "user-service") public interface UserServiceClient { @GetMapping("/users/{id}") User getUserById(@PathVariable("id") Long id); } </code></p> 
<p>在这个例子中，<code>UserServiceClient</code>就是一个Feign客户端，它通过<code>@GetMapping</code>注解定义了调用的具体路径。当调用<code>getUserById</code>方法时，Feign就会自动向<code>user-service</code>服务发送一个GET请求到<code>/users/{id}</code>路径。</p> 
<p>咱们可以在Spring的服务中直接注入这个客户端，就像注入其他Spring组件一样，然后像调用本地方法那样调用远程服务。</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>@Service public class UserService { @Autowired private UserServiceClient userServiceClient; public User getUser(Long id) { return userServiceClient.getUserById(id); } } </code></p> 
<p>在这个例子里，<code>UserService</code>是一个Spring服务，它注入了刚才定义的<code>UserServiceClient</code>。然后，在<code>getUser</code>方法中，直接调用了<code>userServiceClient.getUserById(id)</code>，这样就可以轻松地实现远程服务调用。</p> 
<h4>第4章：Feign中的负载均衡与服务调用</h4> 
<p>在微服务架构中，一个服务可能会有多个实例运行在不同的服务器上。这时，负载均衡就变得尤为重要，它可以帮助咱们将请求平均分配到各个服务实例上，避免某个实例过载。在Feign中，这个负载均衡是通过集成Ribbon来实现的。那么，小黑这就带咱们来看看Feign和Ribbon是如何携手工作的。</p> 
<p>Ribbon是一个客户端负载均衡器，它可以根据一定的规则，从多个服务实例中选择一个进行调用。在Feign中，Ribbon的集成几乎是透明的，咱们几乎不需要做太多额外的配置。</p> 
<p>举个例子，假设咱们有一个用户服务，它有多个实例。咱们使用Feign来调用这个服务：</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>@FeignClient(name = "user-service") public interface UserServiceClient { @GetMapping("/users/{id}") User getUserById(@PathVariable("id") Long id); } </code></p> 
<p>在这里，当咱们调用<code>getUserById</code>方法时，Feign内部会使用Ribbon来选择一个<code>user-service</code>的实例。Ribbon会根据配置的负载均衡策略（比如轮询、随机等），从所有可用的实例中选择一个。</p> 
<p>如果咱们想要自定义Ribbon的行为，可以通过配置文件来实现。比如，咱们可以在<code>application.properties</code>或<code>application.yml</code>中添加如下配置：</p> 
<pre></pre> 
<p>properties</p> 
<p>复制代码</p> 
<p><code>user-service.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RandomRule </code></p> 
<p>这段配置指定了对<code>user-service</code>服务采用随机的负载均衡策略。当然，Ribbon还有很多其他的配置项，比如重试机制、连接超时等，咱们可以根据自己的需求来进行调整。</p> 
<p>通过这种方式，Feign和Ribbon的结合使用，为微服务之间的通信提供了高效的负载均衡解决方案。它不仅使服务调用更加高效，还增加了系统的可用性和容错性。这就是为什么在微服务架构中，Feign和Ribbon的组合如此受欢迎的原因。</p> 
<h4>第5章：Feign中的熔断与容错处理</h4> 
<p>在微服务架构中，服务间的依赖是不可避免的。但是，当一个服务发生故障时，我们不希望这个故障像多米诺骨牌一样导致整个系统崩溃。这就是“熔断器”发挥作用的时刻了。在Feign中，熔断器的角色通常由Hystrix扮演。那么，小黑这就带咱们一探究竟，看看Feign如何使用Hystrix来提高系统的容错性。</p> 
<p>Hystrix是一个用于处理分布式系统的延迟和容错的库，它可以保护系统免受单个服务故障的影响。在Feign中启用Hystrix非常简单。首先，确保咱们的项目中加入了Hystrix的依赖。通常，在使用Spring Cloud时，这个依赖已经包含在内了。</p> 
<p>接下来，在<code>application.properties</code>或<code>application.yml</code>中启用Hystrix：</p> 
<pre></pre> 
<p>properties</p> 
<p>复制代码</p> 
<p><code>feign.hystrix.enabled=true </code></p> 
<p>这样就启用了Feign的Hystrix支持。现在，小黑给咱们演示如何在Feign客户端使用Hystrix来实现熔断功能。</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>@FeignClient(name = "user-service", fallback = UserServiceFallback.class) public interface UserServiceClient { @GetMapping("/users/{id}") User getUserById(@PathVariable("id") Long id); } @Component class UserServiceFallback implements UserServiceClient { @Override public User getUserById(Long id) { // 当调用失败时，返回一个预定义的“备用”用户 return new User("备用用户", "无法获取真实用户信息"); } } </code></p> 
<p></p> 
<p class="img-center"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzimgs.com%2Fi%2F7EUoz5" rel="nofollow"><img alt="" height="1041" src="https://images2.imgbox.com/5c/ac/dooGdGBE_o.png" width="1200"></a></p> 
<p>在这个例子中，<code>UserServiceClient</code>是一个Feign客户端，它通过<code>@FeignClient</code>注解指定了服务名和熔断时的回退类<code>UserServiceFallback</code>。这个回退类实现了相同的接口，并提供了备用的逻辑。当<code>user-service</code>服务不可用时，Feign会自动调用<code>UserServiceFallback</code>中的方法。</p> 
<p>通过这种方式，即使在<code>user-service</code>服务不可用的情况下，咱们的系统也可以继续运行，而不是完全失去响应。这种方法增加了系统的鲁棒性，提高了用户体验。</p> 
<p>Feign和Hystrix的结合使用，不仅提供了服务调用的简便性，还为微服务架构增加了必要的容错机制。这样的设计让系统即使面对个别服务的故障，也能保持整体的稳定性和可用性。</p> 
<h4>第6章：Feign中的日志记录和问题排查</h4> 
<p>当咱们在使用微服务进行开发时，日志记录是一个非常重要的环节，尤其是在跨服务调用的场景下。好的日志记录不仅能帮助咱们快速定位和解决问题，还能提供系统运行状态的有用信息。在Feign中，日志记录也是一个重要的部分，小黑这就来聊聊Feign如何处理日志。</p> 
<p>Feign提供了自己的日志机制，允许咱们记录每一次对远程服务的请求和响应。要在Feign中启用日志，首先需要定义一个日志级别。Feign提供了几种不同的日志级别，每个级别都会记录不同范围的信息。</p> 
<p>在Feign中设置日志级别的代码如下所示：</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>@Configuration public class FeignConfig { @Bean Logger.Level feignLoggerLevel() { // 设置日志级别为FULL，记录请求和响应的头信息、正文和元数据 return Logger.Level.FULL; } } </code></p> 
<p>在这个配置类中，咱们设置了Feign的日志级别为<code>FULL</code>。这意味着Feign会记录请求和响应的所有细节，包括头信息、正文和元数据。当然，还有其他级别如<code>NONE</code>、<code>BASIC</code>和<code>HEADERS</code>，咱们可以根据需要选择合适的级别。</p> 
<p>接下来，咱们需要在Feign客户端接口上指定这个配置类：</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>@FeignClient(name = "user-service", configuration = FeignConfig.class) public interface UserServiceClient { @GetMapping("/users/{id}") User getUserById(@PathVariable("id") Long id); } </code></p> 
<p>有了这些设置后，当咱们调用<code>UserServiceClient</code>中的方法时，Feign就会按照指定的日志级别记录信息。</p> 
<p>除了配置日志级别外，咱们还需要在<code>application.properties</code>或<code>application.yml</code>中设置Feign客户端的日志。例如：</p> 
<pre></pre> 
<p>properties</p> 
<p>复制代码</p> 
<p><code>logging.level.&lt;你的包名&gt;.UserServiceClient=DEBUG </code></p> 
<p>将上面的<code>&lt;你的包名&gt;</code>替换成包含<code>UserServiceClient</code>接口的包名。这样做能确保Feign客户端的日志输出到控制台或日志文件中。</p> 
<p>有了这些日志，当遇到问题时，咱们就可以通过查看请求的详细信息来帮助定位问题。比如，咱们可以查看请求的URL、请求参数、响应状态码以及响应体等信息。这在微服务架构中是非常有用的，因为它可以帮助咱们快速理解服务间交互的细节，从而有效地解决跨服务调用的问题。</p> 
<h4>第7章：Feign的高级特性和扩展</h4> 
<h5>自定义请求和响应的编解码器</h5> 
<p>在Feign中，默认使用了Spring MVC的编解码器来处理请求和响应。但有时候，咱们可能需要对这些编解码器进行定制，比如使用不同的JSON解析库，或者处理一些特殊的数据格式。</p> 
<p>这时，咱们可以自定义编解码器。举个例子，如果想要使用Gson作为JSON解析库，可以这样做：</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>public class GsonDecoder extends SpringDecoder { public GsonDecoder() { super(() -&gt; new HttpMessageConverters(new GsonHttpMessageConverter())); } } @Configuration public class FeignConfig { @Bean public Decoder feignDecoder() { return new GsonDecoder(); } } </code></p> 
<p></p> 
<p class="img-center"><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzimgs.com%2Fi%2F7E1k9m" rel="nofollow"><img alt="" height="879" src="https://images2.imgbox.com/ad/9c/ZCRRwlbF_o.png" width="1200"></a></p> 
<p>在这个例子中，<code>GsonDecoder</code>继承了<code>SpringDecoder</code>，并使用了<code>GsonHttpMessageConverter</code>来处理HTTP消息。然后，在配置类中注册这个自定义的解码器。</p> 
<h5>使用自定义拦截器</h5> 
<p>Feign也允许咱们添加自定义的拦截器，这在处理一些如身份验证、日志记录等横切关注点时非常有用。自定义拦截器可以在发送请求之前或之后执行一些逻辑。</p> 
<p>下面是一个自定义拦截器的例子：</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>public class CustomRequestInterceptor implements RequestInterceptor { @Override public void apply(RequestTemplate template) { // 在这里添加自定义逻辑，比如添加认证头 template.header("Authorization", "Bearer your_token"); } } @Configuration public class FeignConfig { @Bean public RequestInterceptor requestInterceptor() { return new CustomRequestInterceptor(); } } </code></p> 
<p>在这个例子中，<code>CustomRequestInterceptor</code>实现了<code>RequestInterceptor</code>接口，并在<code>apply</code>方法中添加了一个认证头。这样，每个通过Feign发送的请求都会包含这个头信息。</p> 
<p>通过使用这些高级特性和扩展，Feign变得更加强大和灵活。咱们可以根据具体的需求，对Feign进行定制和扩展，使其更好地服务于咱们的应用。这也正是Feign作为一个微服务工具库的魅力所在。</p> 
<h4>第8章：总结</h4> 
<p>在微服务架构中，服务间的通信是一个关键环节。Feign作为一个声明式的Web服务客户端，简化了这个过程。通过它，咱们可以轻松实现服务间的调用，就像调用本地方法一样简单。Feign的集成和使用，大大提高了开发效率，同时也使得代码更加简洁和优雅。</p> 
<p>Feign的负载均衡和熔断机制，提高了系统的可靠性和健壮性。在面对服务故障和网络问题时，这些机制可以确保系统的稳定运行，增强了系统的容错能力。</p> 
<p>技术总是在不断发展和变化的。Feign虽然已经很强大，但在未来的发展中，它还可以结合更多的新技术和理念。比如，随着云原生和容器化技术的兴起，Feign也许会与Kubernetes等技术更深入地结合，以适应更加动态和复杂的微服务环境。在微服务的道路上，总有新的挑战和机遇在等待咱们。加油！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/351addedd8a9775fe9467978fb4fa8e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">作为一名前后端开发,应该对Nginx有怎样的认识</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e708fb0bfe81a8cbe19c86dc74306060/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux命令-arj命令（用于创建和管理.arj压缩包）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>