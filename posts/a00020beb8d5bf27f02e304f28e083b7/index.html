<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【操作系统面试题（32道）与面试Linux命令大全】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【操作系统面试题（32道）与面试Linux命令大全】" />
<meta property="og:description" content="文章目录 操作系统面试题引论1.什么是操作系统？2.操作系统主要有哪些功能？ 操作系统结构3.什么是内核？4.什么是用户态和内核态？5.用户态和内核态是如何切换的？ 进程和线程6.并行和并发有什么区别？7.什么是进程上下文切换？8.进程有哪些状态？9.什么是僵尸进程？10.什么是孤儿进程？11.进程有哪些调度算法？12.进程间通信有哪些方式？13.进程和线程的联系和区别？14.线程上下文切换了解吗？15.线程有哪些实现方式？16.线程间如何同步？17.什么是死锁？18.死锁产生有哪些条件？19.如何避免死锁呢？20.活锁和饥饿锁了解吗？ 内存管理21.什么是虚拟内存？22.什么是内存分段？23.什么是内存分页？24.多级页表知道吗？25.什么是块表？26.分页和分段有什么区别？27.什么是交换空间？28.页面置换算法有哪些？ 文件29.硬链接和软链接有什么区别？ IO30.零拷贝了解吗？31.聊聊**阻塞与⾮阻塞** **I/O **、 **同步与异步** **I/O**？32.详细讲一讲I/O多路复用？ 常用的Linux命令1、绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？2、怎么查看当前进程？怎么执行退出？怎么查看当前路径？3、怎么清屏？怎么退出当前命令？怎么查看当前用户 id？查看指定帮助用什么命令？4、ls命令执行什么功能？ 可以带哪些参数，有什么区别？5、查看文件有哪些命令？6、列举几个常用的Linux命令。7、你平时是怎么查看日志的？1)、tail2)、head3)、cat4)、more5)、sed6)、less 8、建立软链接(快捷方式)，以及硬链接的命令9、目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？10、查看文件内容有哪些命令可以使用？11、随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”?12、终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？13、移动文件用哪个命令？改名用哪个命令？14、复制文件用哪个命令？如果需要连同文件夹一块复制呢？15、删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？16、Linux下命令有哪几种可使用的通配符？分别代表什么含义？17、用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)18、Grep命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行?19、Linux中进程有哪几种状态？在ps显示出来的信息中分别用什么符号表示的？20、怎么使一个命令在后台运行?21、利用ps怎么显示所有的进程? 怎么利用ps？22、哪个命令专门用来查看后台任务?23、把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令?24、终止进程用什么命令? 带什么参数?25、怎么查看系统支持的所有信号？26、搜索文件用什么命令? 格式是怎么样的?27、查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?28、使用什么命令查看用过的命令列表?29、使用什么命令查看磁盘使用空间？空闲空间呢?30、使用什么命令查看网络是否连通?31、使用什么命令查看IP地址及接口信息？32、查看各类环境变量用什么命令?33、查找命令的可执行文件是去哪查找的? 怎么对其进行设置及添加?34、通过什么命令查找执行命令?35、怎么对命令进行取别名？36、du和df的定义，以及区别？37、如果一个Linux新手想要知道当前系统支持的所有命令的列表，他需要怎么做？38、如果你的助手想要打印出当前的目录栈，你会建议他怎么做？39、你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？40、bash shell中的hash命令有什么作用？41、怎样一页一页地查看一个大文件的内容呢？42、数据字典属于哪一个用户的？43、怎样查看一个linux命令的概要与用法？假设你在/bin 目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？44、使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？ 操作系统面试题 引论 1.什么是操作系统？ 可以这么说，操作系统是一种运行在内核态的软件。
它是应用程序和硬件之间的媒介，向应用程序提供硬件的抽象，以及管理硬件资源。
2.操作系统主要有哪些功能？ 操作系统最主要的功能：
处理器（CPU）管理：CPU的管理和分配，主要指的是进程管理。内存管理：内存的分配和管理，主要利用了虚拟内存的方式。外存管理：外存（磁盘等）的分配和管理，将外存以文件的形式提供出去。I/O管理：对输入/输出设备的统一管理。 除此之外，还有保证自身正常运行的健壮性管理，防止非法操作和入侵的安全性管理。
操作系统结构 3.什么是内核？ 可以这么说，内核是一个计算机程序，它是操作系统的核心，提供了操作系统最核心的能力，可以控制操作系统中所有的内容
4.什么是用户态和内核态？ 内核具有很⾼的权限，可以控制 cpu、内存、硬盘等硬件，出于权限控制的考虑，因此⼤多数操作系统，把内存分成了两个区域：
内核空间，这个内存空间只有内核程序可以访问；⽤户空间，这个内存空间专⻔给应⽤程序使⽤，权限比较小； ⽤户空间的代码只能访问⼀个局部的内存空间，⽽内核空间的代码可以访问所有内存空间。因此，当程序使⽤⽤户空间时，我们常说该程序在⽤户态执⾏，⽽当程序使用内核空间时，程序则在内核态执⾏。
5.用户态和内核态是如何切换的？ 应⽤程序如果需要进⼊内核空间，就需要通过系统调⽤，来进入内核态：
内核程序执⾏在内核态，⽤户程序执⾏在⽤户态。当应⽤程序使⽤系统调⽤时，会产⽣⼀个中断。发⽣中断后， CPU 会中断当前在执⾏的⽤户程序，转⽽跳转到中断处理程序，也就是开始执⾏内核程序。内核处理完后，主动触发中断，把 CPU 执⾏权限交回给⽤户程序，回到⽤户态继续⼯作。
进程和线程 6.并行和并发有什么区别？ 并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器做到的并发，其实是利用时间片的轮转，例如有两个进程A和B，A运行一个时间片之后，切换到B，B运行一个时间片之后又切换到A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。
并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。
7.什么是进程上下文切换？ 对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种将 CPU 资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。
8.进程有哪些状态？ 当一个进程开始运行时，它可能会经历下面这几种状态：
上图中各个状态的意义：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a00020beb8d5bf27f02e304f28e083b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-13T13:21:44+08:00" />
<meta property="article:modified_time" content="2023-11-13T13:21:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【操作系统面试题（32道）与面试Linux命令大全】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">操作系统面试题</a></li><li><a href="#_3" rel="nofollow">引论</a></li><li><ul><li><a href="#1_5" rel="nofollow">1.什么是操作系统？</a></li><li><a href="#2_13" rel="nofollow">2.操作系统主要有哪些功能？</a></li></ul> 
  </li><li><a href="#_28" rel="nofollow">操作系统结构</a></li><li><ul><li><a href="#3_30" rel="nofollow">3.什么是内核？</a></li><li><a href="#4_36" rel="nofollow">4.什么是用户态和内核态？</a></li><li><a href="#5_47" rel="nofollow">5.用户态和内核态是如何切换的？</a></li></ul> 
  </li><li><a href="#_57" rel="nofollow">进程和线程</a></li><li><ul><li><a href="#6_59" rel="nofollow">6.并行和并发有什么区别？</a></li><li><a href="#7_67" rel="nofollow">7.什么是进程上下文切换？</a></li><li><a href="#8_75" rel="nofollow">8.进程有哪些状态？</a></li><li><a href="#9_94" rel="nofollow">9.什么是僵尸进程？</a></li><li><a href="#10_102" rel="nofollow">10.什么是孤儿进程？</a></li><li><a href="#11_108" rel="nofollow">11.进程有哪些调度算法？</a></li><li><a href="#12_146" rel="nofollow">12.进程间通信有哪些方式？</a></li><li><a href="#13_230" rel="nofollow">13.进程和线程的联系和区别？</a></li><li><a href="#14_249" rel="nofollow">14.线程上下文切换了解吗？</a></li><li><a href="#15_260" rel="nofollow">15.线程有哪些实现方式？</a></li><li><a href="#16_276" rel="nofollow">16.线程间如何同步？</a></li><li><a href="#17_321" rel="nofollow">17.什么是死锁？</a></li><li><a href="#18_327" rel="nofollow">18.死锁产生有哪些条件？</a></li><li><a href="#19_338" rel="nofollow">19.如何避免死锁呢？</a></li><li><a href="#20_362" rel="nofollow">20.活锁和饥饿锁了解吗？</a></li></ul> 
  </li><li><a href="#_376" rel="nofollow">内存管理</a></li><li><ul><li><a href="#21_378" rel="nofollow">21.什么是虚拟内存？</a></li><li><a href="#22_394" rel="nofollow">22.什么是内存分段？</a></li><li><a href="#23_410" rel="nofollow">23.什么是内存分页？</a></li><li><a href="#24_418" rel="nofollow">24.多级页表知道吗？</a></li><li><a href="#25_428" rel="nofollow">25.什么是块表？</a></li><li><a href="#26_436" rel="nofollow">26.分页和分段有什么区别？</a></li><li><a href="#27_445" rel="nofollow">27.什么是交换空间？</a></li><li><a href="#28_456" rel="nofollow">28.页面置换算法有哪些？</a></li></ul> 
  </li><li><a href="#_516" rel="nofollow">文件</a></li><li><ul><li><a href="#29_518" rel="nofollow">29.硬链接和软链接有什么区别？</a></li></ul> 
  </li><li><a href="#IO_530" rel="nofollow">IO</a></li><li><ul><li><a href="#30_532" rel="nofollow">30.零拷贝了解吗？</a></li><li><a href="#31_IO___IO_564" rel="nofollow">31.聊聊**阻塞与⾮阻塞** **I/O **、 **同步与异步** **I/O**？</a></li><li><a href="#32IO_598" rel="nofollow">32.详细讲一讲I/O多路复用？</a></li></ul> 
  </li><li><a href="#Linux_650" rel="nofollow">常用的Linux命令</a></li><li><ul><li><a href="#1__652" rel="nofollow">1、绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？</a></li><li><a href="#2_663" rel="nofollow">2、怎么查看当前进程？怎么执行退出？怎么查看当前路径？</a></li><li><a href="#3_id_672" rel="nofollow">3、怎么清屏？怎么退出当前命令？怎么查看当前用户 id？查看指定帮助用什么命令？</a></li><li><a href="#4ls__694" rel="nofollow">4、ls命令执行什么功能？ 可以带哪些参数，有什么区别？</a></li><li><a href="#5_700" rel="nofollow">5、查看文件有哪些命令？</a></li><li><a href="#6Linux_719" rel="nofollow">6、列举几个常用的Linux命令。</a></li><li><a href="#7_740" rel="nofollow">7、你平时是怎么查看日志的？</a></li><li><ul><li><a href="#1tail_745" rel="nofollow">1)、tail</a></li><li><a href="#2head_777" rel="nofollow">2)、head</a></li><li><a href="#3cat_785" rel="nofollow">3)、cat</a></li><li><a href="#4more_813" rel="nofollow">4)、more</a></li><li><a href="#5sed_839" rel="nofollow">5)、sed</a></li><li><a href="#6less_849" rel="nofollow">6)、less</a></li></ul> 
   </li><li><a href="#8_897" rel="nofollow">8、建立软链接(快捷方式)，以及硬链接的命令</a></li><li><a href="#9_904" rel="nofollow">9、目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？</a></li><li><a href="#10_929" rel="nofollow">10、查看文件内容有哪些命令可以使用？</a></li><li><a href="#11hello_world_944" rel="nofollow">11、随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”?</a></li><li><a href="#12_951" rel="nofollow">12、终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？</a></li><li><a href="#13_959" rel="nofollow">13、移动文件用哪个命令？改名用哪个命令？</a></li><li><a href="#14_964" rel="nofollow">14、复制文件用哪个命令？如果需要连同文件夹一块复制呢？</a></li><li><a href="#15_972" rel="nofollow">15、删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？</a></li><li><a href="#16Linux_981" rel="nofollow">16、Linux下命令有哪几种可使用的通配符？分别代表什么含义？</a></li><li><a href="#17_990" rel="nofollow">17、用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)</a></li><li><a href="#18Grep___1002" rel="nofollow">18、Grep命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行?</a></li><li><a href="#19Linuxps_1009" rel="nofollow">19、Linux中进程有哪几种状态？在ps显示出来的信息中分别用什么符号表示的？</a></li><li><a href="#20_1040" rel="nofollow">20、怎么使一个命令在后台运行?</a></li><li><a href="#21ps_ps_1046" rel="nofollow">21、利用ps怎么显示所有的进程? 怎么利用ps？</a></li><li><a href="#22_1055" rel="nofollow">22、哪个命令专门用来查看后台任务?</a></li><li><a href="#23_1060" rel="nofollow">23、把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令?</a></li><li><a href="#24__1067" rel="nofollow">24、终止进程用什么命令? 带什么参数?</a></li><li><a href="#25_1074" rel="nofollow">25、怎么查看系统支持的所有信号？</a></li><li><a href="#26__1079" rel="nofollow">26、搜索文件用什么命令? 格式是怎么样的?</a></li><li><a href="#27__1092" rel="nofollow">27、查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?</a></li><li><a href="#28_1099" rel="nofollow">28、使用什么命令查看用过的命令列表?</a></li><li><a href="#29_1104" rel="nofollow">29、使用什么命令查看磁盘使用空间？空闲空间呢?</a></li><li><a href="#30_1110" rel="nofollow">30、使用什么命令查看网络是否连通?</a></li><li><a href="#31IP_1115" rel="nofollow">31、使用什么命令查看IP地址及接口信息？</a></li><li><a href="#32_1120" rel="nofollow">32、查看各类环境变量用什么命令?</a></li><li><a href="#33__1128" rel="nofollow">33、查找命令的可执行文件是去哪查找的? 怎么对其进行设置及添加?</a></li><li><a href="#34_1162" rel="nofollow">34、通过什么命令查找执行命令?</a></li><li><a href="#35_1170" rel="nofollow">35、怎么对命令进行取别名？</a></li><li><a href="#36dudf_1176" rel="nofollow">36、du和df的定义，以及区别？</a></li><li><a href="#37Linux_1192" rel="nofollow">37、如果一个Linux新手想要知道当前系统支持的所有命令的列表，他需要怎么做？</a></li><li><a href="#38_1198" rel="nofollow">38、如果你的助手想要打印出当前的目录栈，你会建议他怎么做？</a></li><li><a href="#39_1206" rel="nofollow">39、你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？</a></li><li><a href="#40bash_shellhash_1212" rel="nofollow">40、bash shell中的hash命令有什么作用？</a></li><li><a href="#41_1222" rel="nofollow">41、怎样一页一页地查看一个大文件的内容呢？</a></li><li><a href="#42_1230" rel="nofollow">42、数据字典属于哪一个用户的？</a></li><li><a href="#43linuxbin__1236" rel="nofollow">43、怎样查看一个linux命令的概要与用法？假设你在/bin 目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？</a></li><li><a href="#44_1242" rel="nofollow">44、使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>操作系统面试题</h2> 
<h2><a id="_3"></a>引论</h2> 
<h3><a id="1_5"></a>1.什么是操作系统？</h3> 
<p>可以这么说，操作系统是一种运行在内核态的软件。</p> 
<p>它是应用程序和硬件之间的媒介，向应用程序提供硬件的抽象，以及管理硬件资源。</p> 
<p><img src="https://images2.imgbox.com/e6/3c/bMAFiyDs_o.png" alt="image-20231110211437932"></p> 
<h3><a id="2_13"></a>2.操作系统主要有哪些功能？</h3> 
<p>操作系统最主要的功能：</p> 
<ul><li>处理器（CPU）管理：CPU的管理和分配，主要指的是进程管理。</li><li>内存管理：内存的分配和管理，主要利用了虚拟内存的方式。</li><li>外存管理：外存（磁盘等）的分配和管理，将外存以文件的形式提供出去。</li><li>I/O管理：对输入/输出设备的统一管理。</li></ul> 
<p>除此之外，还有保证自身正常运行的健壮性管理，防止非法操作和入侵的安全性管理。</p> 
<p><img src="https://images2.imgbox.com/0c/99/Q3tPmdKH_o.png" alt="image-20231110211546959"></p> 
<h2><a id="_28"></a>操作系统结构</h2> 
<h3><a id="3_30"></a>3.什么是内核？</h3> 
<p>可以这么说，内核是一个计算机程序，它是操作系统的核心，提供了操作系统最核心的能力，可以控制操作系统中所有的内容</p> 
<h3><a id="4_36"></a>4.什么是用户态和内核态？</h3> 
<p>内核具有很⾼的权限，可以控制 cpu、内存、硬盘等硬件，出于权限控制的考虑，因此⼤多数操作系统，把内存分成了两个区域：</p> 
<ul><li>内核空间，这个内存空间只有内核程序可以访问；</li><li>⽤户空间，这个内存空间专⻔给应⽤程序使⽤，权限比较小；</li></ul> 
<p>⽤户空间的代码只能访问⼀个局部的内存空间，⽽内核空间的代码可以访问所有内存空间。因此，当程序使⽤⽤户空间时，我们常说该程序在<strong>⽤户态</strong>执⾏，⽽当程序使用内核空间时，程序则在<strong>内核态</strong>执⾏。</p> 
<h3><a id="5_47"></a>5.用户态和内核态是如何切换的？</h3> 
<p>应⽤程序如果需要进⼊内核空间，就需要通过系统调⽤，来进入内核态：</p> 
<p><img src="https://images2.imgbox.com/45/06/E1uqaYcR_o.png" alt="image-20231110211709561"></p> 
<p>内核程序执⾏在内核态，⽤户程序执⾏在⽤户态。当应⽤程序使⽤系统调⽤时，会产⽣⼀个中断。发⽣中断后， CPU 会中断当前在执⾏的⽤户程序，转⽽跳转到中断处理程序，也就是开始执⾏内核程序。内核处理完后，主动触发中断，把 CPU 执⾏权限交回给⽤户程序，回到⽤户态继续⼯作。</p> 
<h2><a id="_57"></a>进程和线程</h2> 
<h3><a id="6_59"></a>6.并行和并发有什么区别？</h3> 
<p>并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器做到的并发，其实是利用时间片的轮转，例如有两个进程A和B，A运行一个时间片之后，切换到B，B运行一个时间片之后又切换到A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</p> 
<p>并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。</p> 
<p><img src="https://images2.imgbox.com/ee/1e/Lr5cjptF_o.png" alt="image-20231110211828435"></p> 
<h3><a id="7_67"></a>7.什么是进程上下文切换？</h3> 
<p>对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种将 CPU 资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</p> 
<p><img src="https://images2.imgbox.com/6c/16/puGsYtaz_o.png" alt="image-20231111161917255"></p> 
<h3><a id="8_75"></a>8.进程有哪些状态？</h3> 
<p>当一个进程开始运行时，它可能会经历下面这几种状态：</p> 
<p>上图中各个状态的意义：</p> 
<ul><li>运⾏状态（<em>Runing</em>）：该时刻进程占⽤ CPU；</li><li>就绪状态（<em>Ready</em>）：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏；</li><li>阻塞状态（<em>Blocked</em>）：该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）⽽暂时停⽌运⾏，这时，即使给它CPU控制权，它也⽆法运⾏；</li></ul> 
<p><img src="https://images2.imgbox.com/77/2d/pGxET72Q_o.png" alt="image-20231111163643236"></p> 
<p>当然，进程还有另外两个基本状态：</p> 
<ul><li>创建状态（<em>new</em>）：进程正在被创建时的状态；</li><li>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；</li></ul> 
<p><img src="https://images2.imgbox.com/87/8b/Qsg2iQZ0_o.png" alt="image-20231111163706086"></p> 
<h3><a id="9_94"></a>9.什么是僵尸进程？</h3> 
<p>僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。</p> 
<p>僵尸进程一般发生有父子关系的进程中，一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中。</p> 
<h3><a id="10_102"></a>10.什么是孤儿进程？</h3> 
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程 (进程 ID 为 1 的进程) 所收养，并由 init 进程对它们完成状态收集工作。因为孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p> 
<h3><a id="11_108"></a>11.进程有哪些调度算法？</h3> 
<p>进程调度就是确定某一个时刻CPU运行哪个进程，常见的进程调度算法有：</p> 
<p><img src="https://images2.imgbox.com/bb/7a/aEHX2cD1_o.png" alt="image-20231111165343153"></p> 
<ul><li><strong>先来先服务</strong></li></ul> 
<p>非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对I/O密集型进程也不利，因为这种进程每次进行I/O操作之后又得重新排队。</p> 
<p><img src="https://images2.imgbox.com/ae/d8/Ais6uKzd_o.png" alt="image-20231111165417924"></p> 
<ul><li><strong>短作业优先</strong></li></ul> 
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p> 
<p><img src="https://images2.imgbox.com/f6/3b/bZsohV9t_o.png" alt="image-20231111165442919"></p> 
<ul><li><strong>优先级调度</strong></li></ul> 
<p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p> 
<p><img src="https://images2.imgbox.com/ea/0d/SXSovyks_o.png" alt="image-20231111165503121"></p> 
<ul><li><strong>时间片轮转</strong></li></ul> 
<p>将所有就绪进程按 先来先服务的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p> 
<p>时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。</p> 
<p><img src="https://images2.imgbox.com/5b/47/IzhG5qeH_o.png" alt="image-20231111165544767"></p> 
<ul><li><strong>最短剩余时间优先</strong></li></ul> 
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p> 
<h3><a id="12_146"></a>12.进程间通信有哪些方式？</h3> 
<p><img src="https://images2.imgbox.com/0e/2c/S3Hlxr9I_o.png" alt="image-20231111165636917"></p> 
<ul><li>管道：</li></ul> 
<p>管道可以理解成不同进程之间的对白，一方发声，一方接收，声音的介质可是是空气或者电缆，进程之间就可以通过管道，<strong>所谓的管道就是内核中的一串缓存</strong>，从管道的一端写入数据，就是缓存在了内核里，另一端读取，也是从内核中读取这段数据。</p> 
<p>管道可以分为两类：<strong>匿名管道</strong>和<strong>命名管道</strong>。匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道是双向的，可以实现本机任意两个进程通信。</p> 
<ul><li>信号 ：</li></ul> 
<p>信号可以理解成一种电报，发送方发送内容，指定接收进程，然后发出特定的软件中断，操作系统接到中断请求后，找到接收进程，通知接收进程处理信号。</p> 
<p>比如<code>kill -9 1050</code>就表示给PID为1050的进程发送<code>SIGKIL</code>信号。</p> 
<p>Linux系统中常用信号：</p> 
<p>（1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。</p> 
<p>（2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。</p> 
<p>（3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\键将产生该信号。</p> 
<p>（4）SIGBUS和SIGSEGV：进程访问非法地址。</p> 
<p>（5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。</p> 
<p>（6）SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。</p> 
<p>（7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。</p> 
<p>（8）SIGALRM：定时器信号。</p> 
<p>（9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p> 
<ul><li>消息队列：</li></ul> 
<p><strong>消息队列就是保存在内核中的消息链表</strong>，包括Posix消息队列和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p> 
<p><img src="https://images2.imgbox.com/bd/1c/RV07gqlw_o.png" alt="image-20231111170130897"></p> 
<ul><li>共享内存：</li></ul> 
<p><strong>共享内存的机制，就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写⼊的东西，另外的进程⻢上就能看到。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p> 
<p><img src="https://images2.imgbox.com/34/e1/oGoLQBbw_o.png" alt="image-20231111170003063"></p> 
<ul><li>信号量：</li></ul> 
<p>信号量我们可以理解成红绿灯，红灯行，绿灯停。<strong>它本质上是一个整数计数器</strong>，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p> 
<p>信号量表示资源的数量，控制信号量的⽅式有两种原⼦操作：</p> 
<p>P 操作是⽤在进⼊共享资源之前，V 操作是⽤在离开共享资源之后，这两个操作是必须成对出现的。</p> 
<p><img src="https://images2.imgbox.com/a2/a4/QWKsdibq_o.png" alt="image-20231111170148515"></p> 
<ol><li>⼀个是 <strong>P</strong> <strong>操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使⽤，进程可正常继续执⾏。</li><li>另⼀个是 <strong>V</strong> <strong>操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运⾏；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ol> 
<ul><li>Socket：</li></ul> 
<p>与其他通信机制不同的是，它可用于不同机器间的进程通信。</p> 
<p><strong>优缺点：</strong></p> 
<ul><li>管道：简单；效率低，容量有限；</li><li>消息队列：不及时，写入和读取需要用户态、内核态拷贝。</li><li>共享内存区：能够很容易控制容量，速度快，但需要注意不同进程的同步问题。</li><li>信号量：不能传递复杂消息，一般用来实现进程间的同步；</li><li>信号：它是进程间通信的唯一异步机制。</li><li>Socket：用于不同主机进程间的通信。</li></ul> 
<h3><a id="13_230"></a>13.进程和线程的联系和区别？</h3> 
<p>线程和进程的联系：</p> 
<p><strong>线程是进程当中的⼀条执⾏流程。</strong></p> 
<p>同⼀个进程内多个线程之间可以共享代码段、数据段、打开的⽂件等资源，但每个线程各⾃都有⼀套独⽴的寄存器和栈，这样可以确保线程的控制流是相对独⽴的。</p> 
<p><img src="https://images2.imgbox.com/8d/a9/cwwZ1rQb_o.png" alt="image-20231111170406229"></p> 
<p>线程与进程的⽐较如下：</p> 
<ul><li>调度：<strong>进程是资源（包括内存、打开的⽂件等）分配的单位</strong>，<strong>线程是 CPU 调度的单位</strong>；</li><li>资源：进程拥有⼀个完整的资源平台，⽽线程只独享必不可少的资源，如寄存器和栈；</li><li>拥有资源：线程同样具有就绪、阻塞、执⾏三种基本状态，同样具有状态之间的转换关系；</li><li>系统开销：线程能减少并发执⾏的时间和空间开销——创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</li></ul> 
<h3><a id="14_249"></a>14.线程上下文切换了解吗？</h3> 
<p>这还得看线程是不是属于同⼀个进程：</p> 
<ul><li>当两个线程不是属于同⼀个进程，则切换的过程就跟进程上下⽂切换⼀样；</li><li><strong>当两个线程是属于同⼀个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</strong>；</li></ul> 
<p>所以，线程的上下⽂切换相⽐进程，开销要⼩很多。</p> 
<h3><a id="15_260"></a>15.线程有哪些实现方式？</h3> 
<p>主要有三种线程的实现⽅式：</p> 
<ul><li><strong>内核态线程实现</strong>：在内核空间实现的线程，由内核直接管理直接管理线程。</li></ul> 
<p><img src="https://images2.imgbox.com/fc/e2/TueZxery_o.png" alt="image-20231111170626831"></p> 
<ul><li><strong>⽤户态线程实现</strong>：在⽤户空间实现线程，不需要内核的参与，内核对线程无感知。</li></ul> 
<p><img src="https://images2.imgbox.com/a0/85/Ugnzn9xm_o.png" alt="image-20231111170719900"></p> 
<ul><li><strong>混合线程实现</strong>：现代操作系统基本都是将两种方式结合起来使用。用户态的执行系统负责进程内部线程在非阻塞时的切换；内核态的操作系统负责阻塞线程的切换。即我们同时实现内核态和用户态线程管理。其中内核态线程数量较少，而用户态线程数量较多。每个内核态线程可以服务一个或多个用户态线程。</li></ul> 
<p><img src="https://images2.imgbox.com/83/45/bFPEsScQ_o.png" alt="image-20231111170824684"></p> 
<h3><a id="16_276"></a>16.线程间如何同步？</h3> 
<p>同步解决的多线程操作共享资源的问题，目的是不管线程之间的执行如何穿插，最后的结果都是正确的。</p> 
<p>我们前面知道线程和进程的关系：线程是进程当中的⼀条执⾏流程。所以说下面的一些同步机制不止针对线程，同样也可以针对进程。</p> 
<p><strong>临界区</strong>：我们把对共享资源访问的程序片段称为<code>临界区</code>，我们希望这段代码是<code>互斥</code>的，保证在某时刻只能被一个线程执行，也就是说一个线程在临界区执行时，其它线程应该被阻止进入临界区。</p> 
<p><img src="https://images2.imgbox.com/c6/e2/ee5NWGxX_o.png" alt="image-20231111170910506"></p> 
<p>临界区不仅针对线程，同样针对进程。</p> 
<p>临界区同步的一些实现方式：</p> 
<p>1、<strong>锁</strong></p> 
<p>使⽤加锁操作和解锁操作可以解决并发线程/进程的互斥问题。</p> 
<p>任何想进⼊临界区的线程，必须先执⾏加锁操作。若加锁操作顺利通过，则线程可进⼊临界区；在完成对临界资源的访问后再执⾏解锁操作，以释放该临界资源。</p> 
<p>加锁和解锁锁住的是什么呢？可以是<code>临界区对象</code>，也可以只是一个简单的<code>互斥量</code>，例如互斥量是<code>0</code>无锁，<code>1</code>表示加锁。</p> 
<p><img src="https://images2.imgbox.com/d2/b5/D333ejn7_o.png" alt="image-20231111170953239"></p> 
<p>根据锁的实现不同，可以分为<code>忙等待锁和</code>和<code>⽆忙等待锁</code>。</p> 
<p><code>忙等待锁和</code>就是加锁失败的线程，会不断尝试获取锁，也被称为自旋锁，它会一直占用CPU。</p> 
<p><code>⽆忙等待锁</code>就是加锁失败的线程，会进入阻塞状态，放弃CPU，等待被调度。</p> 
<p>2、<strong>信号量</strong></p> 
<p>信号量是操作系统提供的⼀种协调共享资源访问的⽅法。</p> 
<p>通常<strong>信号量表示资源的数量</strong>，对应的变量是⼀个整型（ sem ）变量。</p> 
<p>另外，还有<strong>两个原⼦操作的系统调⽤函数来控制信号量的</strong>，分别是：</p> 
<ul><li><em>P</em> 操作：将 sem 减 1 ，相减后，如果 sem &lt; 0 ，则进程/线程进⼊阻塞等待，否则继续，表明 P操作可能会阻塞；</li><li><em>V</em> 操作：将 sem 加 1 ，相加后，如果 sem &lt;= 0 ，唤醒⼀个等待中的进程/线程，表明 V 操作不会阻塞；</li></ul> 
<p>P 操作是⽤在进⼊临界区之前，V 操作是⽤在离开临界区之后，这两个操作是必须成对出现的。</p> 
<h3><a id="17_321"></a>17.什么是死锁？</h3> 
<p>在两个或者多个并发线程中，如果每个线程持有某种资源，而又等待其它线程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组线程产生了死锁。通俗的讲就是两个或多个线程无限期的阻塞、相互等待的一种状态。</p> 
<p><img src="https://images2.imgbox.com/b3/fa/qJdNCLPP_o.png" alt="image-20231111171116624"></p> 
<h3><a id="18_327"></a>18.死锁产生有哪些条件？</h3> 
<p>死锁产生需要<strong>同时</strong>满足四个条件：</p> 
<ul><li><strong>互斥条件</strong>：指线程对己经获取到的资源进行它性使用，即该资源同时只由一个线程占用。如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li><li><strong>请求并持有条件</strong>：指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源。</li><li><strong>不可剥夺条件</strong>：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源。</li><li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合 {T0，T1，T2,…… ，Tn} 中 T0 正在等待一 T1 占用的资源，Tl1正在等待 T2用的资源，…… Tn 在等待己被 T0占用的资源。</li></ul> 
<h3><a id="19_338"></a>19.如何避免死锁呢？</h3> 
<p>产⽣死锁的有四个必要条件：互斥条件、持有并等待条件、不可剥夺条件、环路等待条件。</p> 
<p>避免死锁，破坏其中的一个就可以。</p> 
<p><strong>消除互斥条件</strong></p> 
<p>这个是没法实现，因为很多资源就是只能被一个线程占用，例如锁。</p> 
<p><strong>消除请求并持有条件</strong></p> 
<p>消除这个条件的办法很简单，就是一个线程一次请求其所需要的所有资源。</p> 
<p><strong>消除不可剥夺条件</strong></p> 
<p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可剥夺这个条件就破坏掉了。</p> 
<p><strong>消除环路等待条件</strong></p> 
<p>可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。</p> 
<h3><a id="20_362"></a>20.活锁和饥饿锁了解吗？</h3> 
<p><strong>饥饿锁：</strong></p> 
<p>饥饿锁，这个饥饿指的是资源饥饿，某个线程一直等不到它所需要的资源，从而无法向前推进，就像一个人因为饥饿无法成长。</p> 
<p><strong>活锁：</strong></p> 
<p>在活锁状态下，处于活锁线程组里的线程状态可以改变，但是整个活锁组的线程无法推进。</p> 
<p>活锁可以用两个人过一条很窄的小桥来比喻：为了让对方先过，两个人都往旁边让，但两个人总是让到同一边。这样，虽然两个人的状态一直在变化，但却都无法往前推进。</p> 
<h2><a id="_376"></a>内存管理</h2> 
<h3><a id="21_378"></a>21.什么是虚拟内存？</h3> 
<p>我们实际的物理内存主要是主存，但是物理主存空间有限，所以一般现代操作系统都会想办法把一部分内存块放到磁盘中，用到的时候再装入主存，但是对用户程序而言，是不需要注意实际的物理内存的，为什么呢？因为有<code>虚拟内存</code>的机制。</p> 
<p><strong>简单说，虚拟内存是操作系统提供的⼀种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p> 
<p><strong>每个进程都有自己独立的地址空间</strong>，再由操作系统映射到到实际的物理内存。</p> 
<p>于是，这⾥就引出了两种地址的概念：</p> 
<p>程序所使⽤的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</p> 
<p>实际存在硬件⾥⾯的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</p> 
<p><img src="https://images2.imgbox.com/ed/fb/47awiUxC_o.png" alt="image-20231111171526423"></p> 
<h3><a id="22_394"></a>22.什么是内存分段？</h3> 
<p>程序是由若⼲个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就⽤分段（Segmentation）的形式把这些段分离出来。</p> 
<p>分段机制下的虚拟地址由两部分组成，<strong>段号</strong>和<strong>段内偏移量</strong>。</p> 
<p>虚拟地址和物理地址通过段表映射，段表主要包括<strong>段号</strong>、<code>段的界限</code>。</p> 
<p><img src="https://images2.imgbox.com/47/f4/xXARzA6D_o.png" alt="image-20231111171609517"></p> 
<p>我们来看一个映射，虚拟地址：段3、段偏移量500 ----&gt; 段基地址7000+段偏移量500 ----&gt; 物理地址：7500。</p> 
<p><img src="https://images2.imgbox.com/75/67/daIfa1kX_o.png" alt="image-20231111171715708"></p> 
<h3><a id="23_410"></a>23.什么是内存分页？</h3> 
<p><strong>分⻚是把整个虚拟和物理内存空间切成⼀段段固定尺⼨的⼤⼩</strong>。这样⼀个连续并且尺⼨固定的内存空间，我们叫<strong>⻚</strong>（<em>Page</em>）。在 Linux 下，每⼀⻚的⼤⼩为 4KB 。</p> 
<p>访问分页系统中内存数据需要两次的内存访问 ：一次是从内存中访问页表，从中找到指定的物理页号，加上页内偏移得到实际物理地址，第二次就是根据第一次得到的物理地址访问内存取出数据。</p> 
<p><img src="https://images2.imgbox.com/4a/1a/1lljhNim_o.png" alt="image-20231111171907098"></p> 
<h3><a id="24_418"></a>24.多级页表知道吗？</h3> 
<p>操作系统可能会有非常多进程，如果只是使用简单分页，可能导致的后果就是页表变得非常庞大。</p> 
<p>所以，引入了多级页表的解决方案。</p> 
<p>所谓的多级页表，就是把我们原来的单级页表再次分页，这里利用了<code>局部性原理</code>，除了顶级页表，其它级别的页表一来可以在需要的时候才被创建，二来内存紧张的时候还可以被置换到磁盘中。</p> 
<p><img src="https://images2.imgbox.com/35/98/OvTWt24z_o.png" alt="image-20231111172004537"></p> 
<h3><a id="25_428"></a>25.什么是块表？</h3> 
<p>同样利用了<code>局部性原理</code>，即在⼀段时间内，整个程序的执⾏仅限于程序中的某⼀部分。相应地，执⾏所访问的存储空间也局限于某个内存区域。</p> 
<p>利⽤这⼀特性，把最常访问的⼏个⻚表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯⽚中，加⼊了⼀个专⻔存放程序最常访问的⻚表项的 Cache，这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，通常称为⻚表缓存、转址旁路缓存、快表等。</p> 
<p><img src="https://images2.imgbox.com/8f/9e/u2skyjeK_o.png" alt="image-20231111172036389"></p> 
<h3><a id="26_436"></a>26.分页和分段有什么区别？</h3> 
<ul><li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</li><li>段的大小不固定，有它所完成的功能决定；页的大小固定，由系统决定</li><li>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li><li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li></ul> 
<h3><a id="27_445"></a>27.什么是交换空间？</h3> 
<p>操作系统把物理内存(Physical RAM)分成一块一块的小内存，每一块内存被称为页(page)。当内存资源不足时，Linux把某些页的内容转移至磁盘上的一块空间上，以释放内存空间。磁盘上的那块空间叫做交换空间(swap space),而这一过程被称为交换(swapping)。物理内存和交换空间的总容量就是虚拟内存的可用容量。</p> 
<p>用途：</p> 
<ul><li>物理内存不足时一些不常用的页可以被交换出去，腾给系统。</li><li>程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。</li></ul> 
<h3><a id="28_456"></a>28.页面置换算法有哪些？</h3> 
<p>在分页系统里，一个虚拟的页面可能在主存里，也可能在磁盘中，如果CPU发现虚拟地址对应的物理页不在主存里，就会产生一个缺页中断，然后从磁盘中把该页调入主存中。</p> 
<p>如果内存里没有空间，就需要从主存里选择一个页面来置换。</p> 
<p>常见的页面置换算法：</p> 
<p><img src="https://images2.imgbox.com/cc/9c/g3WceKQd_o.png" alt="image-20231111172256222"></p> 
<ul><li><strong>最佳⻚⾯置换算法（OPT）</strong></li></ul> 
<p>最佳⻚⾯置换算法是一个理想的算法，基本思路是，<strong>置换在未来最⻓时间不访问的⻚⾯</strong>。</p> 
<p>所以，该算法实现需要计算内存中每个逻辑⻚⾯的下⼀次访问时间，然后⽐较，选择未来最⻓时间不访问的⻚⾯。</p> 
<p>但这个算法是无法实现的，因为当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问。</p> 
<ul><li><strong>先进先出置换算法（FIFO）</strong></li></ul> 
<p>既然我们⽆法预知⻚⾯在下⼀次访问前所需的等待时间，那可以<strong>选择在内存驻留时间很⻓的⻚⾯进⾏中置换</strong>，这个就是「先进先出置换」算法的思想。</p> 
<p>FIFO的实现机制是使用链表将所有在内存的页面按照进入时间的早晚链接起来，然后每次置换链表头上的页面就行了，新加进来的页面则挂在链表的末端。</p> 
<p><img src="https://images2.imgbox.com/9c/99/o6JI7DQL_o.png" alt="image-20231111172636144"></p> 
<ul><li><strong>最近最久未使⽤的置换算法（LRU）</strong></li></ul> 
<p>最近最久未使⽤（<em>LRU</em>）的置换算法的基本思路是，发⽣缺⻚时，<strong>选择最⻓时间没有被访问的⻚⾯进⾏置换</strong>，也就是说，该算法假设已经很久没有使⽤的⻚⾯很有可能在未来较⻓的⼀段时间内仍然不会被使⽤。</p> 
<p>这种算法近似最优置换算法，最优置换算法是通过「未来」的使⽤情况来推测要淘汰的⻚⾯，⽽ LRU 则是通过<code>历史</code>的使⽤情况来推测要淘汰的⻚⾯。</p> 
<p>LRU 在理论上是可以实现的，但代价很⾼。为了完全实现 LRU，需要在内存中维护⼀个所有⻚⾯的链表，最近最多使⽤的⻚⾯在表头，最近最少使⽤的⻚⾯在表尾。</p> 
<p><img src="https://images2.imgbox.com/d1/b2/xcWm5Jid_o.png" alt="image-20231111172718110"></p> 
<p>困难的是，在每次访问内存时都必须要更新整个链表。在链表中找到⼀个⻚⾯，删除它，然后把它移动到表头是⼀个⾮常费时的操作。</p> 
<p>所以，LRU 虽然看上去不错，但是由于开销⽐较⼤，实际应⽤中⽐较少使⽤。</p> 
<ul><li><strong>时钟页面置换算法</strong></li></ul> 
<p>这个算法的思路是，把所有的⻚⾯都保存在⼀个类似钟⾯的环形链表中，⼀个表针指向最⽼的⻚⾯。</p> 
<p><img src="https://images2.imgbox.com/0c/bc/aGYBDy98_o.png" alt="image-20231111172753859"></p> 
<p>当发⽣缺⻚中断时，算法⾸先检查表针指向的⻚⾯：</p> 
<p>如果它的访问位位是 0 就淘汰该⻚⾯，并把新的⻚⾯插⼊这个位置，然后把表针前移⼀个位置；</p> 
<p>如果访问位是 1 就清除访问位，并把表针前移⼀个位置，重复这个过程直到找到了⼀个访问位为 0 的⻚⾯为⽌；</p> 
<ul><li><strong>最不常⽤置换算法</strong></li></ul> 
<p>最不常用算法（LFU），<strong>当发⽣缺⻚中断时，选择访问次数最少的那个⻚⾯，将其置换</strong>。</p> 
<p>它的实现⽅式是，对每个⻚⾯设置⼀个「访问计数器」，每当⼀个⻚⾯被访问时，该⻚⾯的访问计数器就累加 1。在发⽣缺⻚中断时，淘汰计数器值最⼩的那个⻚⾯。</p> 
<h2><a id="_516"></a>文件</h2> 
<h3><a id="29_518"></a>29.硬链接和软链接有什么区别？</h3> 
<ul><li>硬链接就是在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。删除任意一个条目，文件还是存在，只要引用数量不为 0。但是硬链接有限制，它不能跨越文件系统，也不能对目录进行链接。</li></ul> 
<p><img src="https://images2.imgbox.com/07/4c/u5P85EUr_o.png" alt="image-20231111172922573"></p> 
<ul><li>软链接相当于重新创建⼀个⽂件，这个⽂件有<strong>独⽴的</strong> <strong>inode</strong>，但是这个<strong>⽂件的内容是另外⼀个⽂件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外⼀个⽂件，所以<strong>软链接是可以跨⽂件系统的</strong>，甚⾄<strong>⽬标⽂件被删除了，链接⽂件还是在的，只不过打不开指向的文件了而已。</strong></li></ul> 
<p><img src="https://images2.imgbox.com/ae/a5/LJIYMtK4_o.png" alt="image-20231111173006338"></p> 
<h2><a id="IO_530"></a>IO</h2> 
<h3><a id="30_532"></a>30.零拷贝了解吗？</h3> 
<p>假如需要文件传输，使用传统I/O，数据读取和写入是用户空间到内核空间来回赋值，而内核空间的数据是通过操作系统的I/O接口从磁盘读取或者写入，这期间发生了多次用户态和内核态的上下文切换，以及多次数据拷贝。</p> 
<p><img src="https://images2.imgbox.com/c7/7f/iSB8JF9B_o.png" alt="image-20231111173059017"></p> 
<p>为了提升I/O性能，就需要<strong>减少用户态与内核态的上下文切换</strong>和<strong>内存拷贝的次数</strong>。</p> 
<p>这就用到了我们零拷贝的技术，零拷贝技术实现主要有两种：</p> 
<ul><li><strong>mmap + write</strong></li></ul> 
<p>mmap() 系统调⽤函数会直接把内核缓冲区⾥的数据「<strong>映射</strong>」到⽤户空间，这样，操作系统内核与⽤户空间就不需要再进⾏任何的数据拷⻉操作。</p> 
<p><img src="https://images2.imgbox.com/e9/56/6zY3i4CE_o.png" alt="image-20231111173122724"></p> 
<ul><li><strong>sendfile</strong></li></ul> 
<p>在 Linux 内核版本 2.1 中，提供了⼀个专⻔发送⽂件的系统调⽤函数 sendfile() 。</p> 
<p>⾸先，它可以替代前⾯的 read() 和 write() 这两个系统调⽤，这样就可以减少⼀次系统调⽤，也就减少了 2 次上下⽂切换的开销。</p> 
<p>其次，该系统调⽤，可以直接把内核缓冲区⾥的数据拷⻉到 socket 缓冲区⾥，不再拷⻉到⽤户态，这样就只有 2 次上下⽂切换，和 3 次数据拷⻉。</p> 
<p><img src="https://images2.imgbox.com/23/5f/0vwPcvrn_o.png" alt="image-20231111173147767"></p> 
<p>很多开源项目如Kafka、RocketMQ都采用了零拷贝技术来提升IO效率。</p> 
<h3><a id="31_IO___IO_564"></a>31.聊聊<strong>阻塞与⾮阻塞</strong> **I/O **、 <strong>同步与异步</strong> <strong>I/O</strong>？</h3> 
<ul><li><strong>阻塞I/O</strong></li></ul> 
<p>先来看看<strong>阻塞</strong> <strong>I/O</strong>，当⽤户程序执⾏ read ，线程会被阻塞，⼀直等到内核数据准备好，并把数据从内核缓冲区拷⻉到应⽤程序的缓冲区中，当拷⻉过程完成， read 才会返回。</p> 
<p>注意，<strong>阻塞等待的是<code>内核数据准备好</code>和<code>数据从内核态拷⻉到⽤户态</code>这两个过程</strong>。</p> 
<p><img src="https://images2.imgbox.com/bf/04/O39kF5mX_o.png" alt="image-20231111173234597"></p> 
<ul><li><strong>非阻塞I/O</strong></li></ul> 
<p>⾮阻塞的 read 请求在数据未准备好的情况下⽴即返回，可以继续往下执⾏，此时应⽤程序不断轮询内核，直到数据准备好，内核将数据拷⻉到应⽤程序缓冲区， read 调⽤才可以获取到结果。</p> 
<p><img src="https://images2.imgbox.com/42/20/r6HHjnqJ_o.png" alt="image-20231111173257944"></p> 
<ul><li><strong>基于非阻塞的I/O多路复用</strong></li></ul> 
<p>我们上面的非阻塞I/O有一个问题，什么问题呢？应用程序要一直轮询，这个过程没法干其它事情，所以引入了<strong>I/O</strong> <strong>多路复⽤</strong>技术。</p> 
<p>当内核数据准备好时，以事件通知应⽤程序进⾏操作。</p> 
<p><img src="https://images2.imgbox.com/a7/15/PoSxbmHH_o.png" alt="image-20231111173333765"></p> 
<p><strong>注意：⽆论是阻塞 I/O、还是⾮阻塞 I/O、非阻塞I/O多路复用，都是同步调⽤。因为它们在read调⽤时，内核将数据从内核空间拷⻉到应⽤程序空间，过程都是需要等待的，也就是说这个过程是同步</strong>的，如果内核实现的拷⻉效率不⾼，read调⽤就会在这个同步过程中等待⽐较⻓的时间。</p> 
<ul><li><strong>异步I/O</strong></li></ul> 
<p>真正的<strong>异步</strong> <strong>I/O</strong> 是<code>内核数据准备好</code>和<code>数据从内核态拷⻉到⽤户态</code>这两个过程都不⽤等待。</p> 
<p>发起 aio_read 之后，就⽴即返回，内核⾃动将数据从内核空间拷⻉到应⽤程序空间，这个拷⻉过程同样是异步的，内核⾃动完成的，和前⾯的同步操作不⼀样，应⽤程序并不需要主动发起拷⻉动作。</p> 
<p><img src="https://images2.imgbox.com/a5/d1/2TAtQKNM_o.png" alt="image-20231111173435877"></p> 
<h3><a id="32IO_598"></a>32.详细讲一讲I/O多路复用？</h3> 
<blockquote> 
 <p>我们先了解什么是I/O多路复用？</p> 
</blockquote> 
<p>我们在传统的I/O模型中，如果服务端需要支持多个客户端，我们可能要为每个客户端分配一个进程/线程。</p> 
<p>不管是基于重一点的进程模型，还是轻一点的线程模型，假如连接多了，操作系统是扛不住的。</p> 
<p>所以就引入了<strong>I/O多路复用</strong> 技术。</p> 
<p>简单说，就是一个进程/线程维护多个Socket，这个多路复用就是多个连接复用一个进程/线程。</p> 
<p><img src="https://images2.imgbox.com/14/37/Ed4ltdFF_o.png" alt="image-20231111173503502"></p> 
<p>我们来看看I/O多路复用三种实现机制：</p> 
<ul><li><strong>select</strong></li></ul> 
<p>select 实现多路复⽤的⽅式是：</p> 
<p>将已连接的 Socket 都放到⼀个<strong>⽂件描述符集合</strong>fd_set，然后调⽤ select 函数将fd_set集合拷⻉到内核⾥，让内核来检查是否有⽹络事件产⽣，检查的⽅式很粗暴，就是通过遍历fd_set的⽅式，当检查到有事件产⽣后，将此 Socket 标记为可读或可写， 接着再把整个fd_set拷⻉回⽤户态⾥，然后⽤户态还需要再通过遍历的⽅法找到可读或可写的 Socket，再对其处理。</p> 
<p>select 使⽤固定⻓度的 BitsMap，表示⽂件描述符集合，⽽且所⽀持的⽂件描述符的个数是有限制的，在Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最⼤值为 1024 ，只能监听 0~1023 的⽂件描述符。</p> 
<blockquote> 
 <p>select机制的缺点：</p> 
</blockquote> 
<p>（1）每次调用select，都需要把fd_set集合从用户态拷贝到内核态，如果fd_set集合很大时，那这个开销也很大，比如百万连接却只有少数活跃连接时这样做就太没有效率。</p> 
<p>（2）每次调用select都需要在内核遍历传递进来的所有fd_set，如果fd_set集合很大时，那这个开销也很大。</p> 
<p>（3）为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，一般为1024，如果想要修改会比较麻烦，可能还需要编译内核。</p> 
<p>（4）每次调用select之前都需要遍历设置监听集合，重复工作。</p> 
<ul><li><strong>poll</strong></li></ul> 
<p>poll 不再⽤ BitsMap 来存储所关注的⽂件描述符，取⽽代之⽤动态数组，以链表形式来组织，突破了select 的⽂件描述符个数限制，当然还会受到系统⽂件描述符限制。</p> 
<p>但是 poll 和 select 并没有太⼤的本质区别，都是使⽤线性结构存储进程关注的Socket集合，因此都需要遍历⽂件描述符集合来找到可读或可写的Socke，时间复杂度为O(n)，⽽且也需要在⽤户态与内核态之间拷⻉⽂件描述符集合，这种⽅式随着并发数上来，性能的损耗会呈指数级增⻓。</p> 
<ul><li><strong>epoll</strong></li></ul> 
<p>epoll 通过两个⽅⾯，很好解决了 select/poll 的问题。</p> 
<p>第⼀点，epoll 在内核⾥使⽤<strong>红⿊树来跟踪进程所有待检测的⽂件描述字</strong>，把需要监控的 socket 通过epoll_ctl() 函数加⼊内核中的红⿊树⾥，红⿊树是个⾼效的数据结构，增删查⼀般时间复杂度是O(logn) ，通过对这棵⿊红树进⾏操作，这样就不需要像 select/poll 每次操作时都传⼊整个 socket 集合，只需要传⼊⼀个待检测的 socket，<strong>减少了内核和⽤户空间⼤量的数据拷⻉和内存分配</strong>。</p> 
<p>第⼆点， epoll 使⽤事件驱动的机制，内核⾥<strong>维护了⼀个链表来记录就绪事件</strong>，当某个 socket 有事件发⽣时，通过回调函数，内核会将其加⼊到这个就绪事件列表中，当⽤户调⽤ epoll_wait() 函数时，只会返回有事件发⽣的⽂件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效率。</p> 
<p><img src="https://images2.imgbox.com/e0/19/I70JHn2k_o.png" alt="image-20231111173526699"></p> 
<p>epoll 的⽅式即使监听的 Socket 数量越多的时候，效率不会⼤幅度降低，能够同时监听的 Socket 的数⽬也⾮常的多了，上限就为系统定义的进程打开的最⼤⽂件描述符个数。因⽽，<strong>epoll</strong> <strong>被称为解决</strong> <strong>C10K</strong> <strong>问题的利器</strong>。</p> 
<h2><a id="Linux_650"></a>常用的Linux命令</h2> 
<h3><a id="1__652"></a>1、绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？</h3> 
<p>答：</p> 
<p>绝对路径： 如/etc/init.java</p> 
<p>当前目录和上层目录：./ …/</p> 
<p>主目录： ~/</p> 
<p>切换目录：cd</p> 
<h3><a id="2_663"></a>2、怎么查看当前进程？怎么执行退出？怎么查看当前路径？</h3> 
<p>答：</p> 
<p><strong>查看当前进程：ps</strong></p> 
<p><strong>执行退出：exit</strong></p> 
<p><strong>查看当前路径：pwd</strong></p> 
<h3><a id="3_id_672"></a>3、怎么清屏？怎么退出当前命令？怎么查看当前用户 id？查看指定帮助用什么命令？</h3> 
<p>答：</p> 
<p>清屏：clear</p> 
<p>退出当前命令：ctrl+c (立即终止当前正在运行的命令)</p> 
<p>执行睡眠 ：ctrl+z挂起当前进程fg恢复后台</p> 
<p>查看当前用户id：id -g -G -n -r -u -help -version</p> 
<p><strong>参数说明</strong>：</p> 
<ul><li>-g 或 --group 　显示用户所属群组的ID。</li><li>-G 或 --groups 　显示用户所属附加群组的ID。</li><li>-n 或 --name 　显示用户，所属群组或附加群组的名称。</li><li>-r 或 --real 　显示实际ID。</li><li>-u 或 --user 　显示用户ID。</li><li>-help 　显示帮助。</li><li>-version 　显示版本信息。</li></ul> 
<h3><a id="4ls__694"></a>4、ls命令执行什么功能？ 可以带哪些参数，有什么区别？</h3> 
<p>答：</p> 
<p>ls执行的功能： 列出指定目录中的目录，以及文件哪些参数以及区别：-a所有文件，-l详细信息，包括大小字节数，可读可写可执行的权限等</p> 
<h3><a id="5_700"></a>5、查看文件有哪些命令？</h3> 
<p>答：</p> 
<pre><code class="prism language-sh"><span class="token function">vi</span> 文件名 <span class="token comment">#编辑方式查看，可修改</span>

<span class="token function">cat</span> 文件名 <span class="token comment">#显示全部文件内容</span>

<span class="token function">more</span> 文件名 <span class="token comment">#分页显示文件内容</span>

<span class="token function">less</span> 文件名 <span class="token comment">#与more相似，更好的是可以往前翻页</span>

<span class="token function">tail</span> 文件名 <span class="token comment">#仅查看尾部，还可以指定行数</span>

<span class="token function">head</span> 文件名 <span class="token comment">#仅查看头部,还可以指定行数</span>
</code></pre> 
<h3><a id="6Linux_719"></a>6、列举几个常用的Linux命令。</h3> 
<p>答：</p> 
<p>列出文件列表：ls【参数 -a -l】</p> 
<p>创建目录和移除目录：mkdir rmdir</p> 
<p><strong>用于显示文件后几行内容：tail，例如： tail -n 1000：显示最后1000行</strong></p> 
<p>打包：tar -xvf</p> 
<p>打包并压缩：tar -zcvf</p> 
<p><strong>查找字符串：grep</strong></p> 
<p>显示当前所在目录：pwd</p> 
<p>创建空文件：touch</p> 
<p>编辑器：vim vi</p> 
<h3><a id="7_740"></a>7、你平时是怎么查看日志的？</h3> 
<p>答：</p> 
<p>Linux查看日志的命令有多种：tail、cat、tac、head、echo等，本文只介绍几种常用的方法。</p> 
<h4><a id="1tail_745"></a>1)、tail</h4> 
<p>最常用的一种查看方式</p> 
<p>命令格式: tail [必要参数] [选择参数] [文件]</p> 
<p>-f 循环读取</p> 
<p>-q 不显示处理信息</p> 
<p>-v 显示详细的处理信息</p> 
<p>-c&lt;数目&gt; 显示的字节数</p> 
<p>-n&lt;行数&gt; 显示行数</p> 
<p>-q, --quiet, --silent 从不输出给出文件名的首部</p> 
<p>-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒</p> 
<p>例如：</p> 
<p>tail -n 10 test.log 查询日志尾部最后10行的日志; tail -n +10 test.log 查询10行之后的所有日志; tail -fn 10 test.log 循环实时查看最后1000行记录(最常用的)</p> 
<p>一般还会配合着grep搜索用，例如;</p> 
<p>tail -fn 1000 test.log | grep ‘关键字’</p> 
<p>如果一次性查询的数据量太大,可以进行翻页查看，例如 ：</p> 
<p>tail -n 4700 aa.log |more -1000 可以进行多屏显示(ctrl + f 或者 空格键可以快捷键）</p> 
<h4><a id="2head_777"></a>2)、head</h4> 
<p>跟tail是相反的head是看前多少行日志</p> 
<p>head -n 10 test.log 查询日志文件中的头10行日志; head -n -10 test.log 查询日志文件除了最后10行的其他所有日志;</p> 
<p>head其他参数参考tail</p> 
<h4><a id="3cat_785"></a>3)、cat</h4> 
<p>cat 是由第一行到最后一行连续显示在屏幕上</p> 
<p>一次显示整个文件：</p> 
<p>$ cat filename</p> 
<p>从键盘创建一个文件：</p> 
<p>$cat &gt; filename</p> 
<p>将几个文件合并为一个文件：</p> 
<p>$cat file1 file2 &gt; file 只能创建新文件,不能编辑已有文件</p> 
<p>将一个日志文件的内容追加到另外一个：</p> 
<p>$cat -n textfile1 &gt; textfile2</p> 
<p>清空一个日志文件；</p> 
<p>$cat : &gt;textfile2</p> 
<p>注意：&gt; 意思是创建，&gt;&gt;是追加。千万不要弄混了。</p> 
<p>cat其他参数参考tail</p> 
<h4><a id="4more_813"></a>4)、more</h4> 
<p>more命令是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。more命令从前向后读取文件，因此在启动时就加载整个文件。</p> 
<p>该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：–More–（XX%）</p> 
<p>more的语法：more文件名</p> 
<p>Enter 向下n行，需要定义，默认为1行</p> 
<p>Ctrl f 向下滚动一屏</p> 
<p>空格键 向下滚动一屏</p> 
<p>Ctrl b返回上一屏</p> 
<p>= 输出当前行的行号</p> 
<p>:f 输出文件名和当前行的行号</p> 
<p>v 调用vi编辑器</p> 
<p>!命令调用Shell，并执行命令</p> 
<p>q退出more</p> 
<h4><a id="5sed_839"></a>5)、sed</h4> 
<p><strong>这个命令可以查找日志文件特定的一段 , 根据时间的一个范围查询，可以按照行号和时间范围查询按照行号</strong></p> 
<p><strong>sed -n ‘5,10p’ filename这样你就可以只查看文件的第5行到第10行。</strong></p> 
<p><strong>按照时间段</strong></p> 
<p><strong>sed -n ‘/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p’ test.log</strong></p> 
<h4><a id="6less_849"></a>6)、less</h4> 
<p>less命令在查询日志时，一般流程是这样的</p> 
<p>less log.log shift + G 命令到文件尾部 然后输入 ？加上你要搜索的关键字例如 ？1213 按 n 向上查找关键字 shift+n 反向查找关键字 less与more类似，使用less可以随意浏览文件，而more仅能向前移动，不能向后移动，而且 less 在查看 之前不会加载整个文件。</p> 
<p>less log2013.log 查看文件</p> 
<p>ps -ef | less ps查看进程信息并通过less分页显示</p> 
<p>history | less 查看命令历史使用记录并通过less分页显示</p> 
<p>less log2013.log log2014.log 浏览多个文件</p> 
<p>常用命令参数：</p> 
<p>-b &lt;缓冲区大小&gt; 设置缓冲区的大小</p> 
<p>-g 只标志最后搜索的关键词</p> 
<p>-i 忽略搜索时的大小写</p> 
<p>-m 显示类似more命令的百分比</p> 
<p>-N 显示每行的行号</p> 
<p>-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</p> 
<p>-Q 不使用警告音</p> 
<p>-s 显示连续空行为一行</p> 
<p>/字符串：向下搜索"字符串"的功能</p> 
<p>?字符串：向上搜索"字符串"的功能</p> 
<p>n：重复前一个搜索（与 / 或 ? 有关）</p> 
<p>N：反向重复前一个搜索（与 / 或 ? 有关）</p> 
<p>b 向后翻一页</p> 
<p>h 显示帮助界面</p> 
<p>q 退出less命令</p> 
<p>一般本人查日志配合应用的其他命令</p> 
<h3><a id="8_897"></a>8、建立软链接(快捷方式)，以及硬链接的命令</h3> 
<p>答：</p> 
<p>软链接： ln -s slink source</p> 
<p>硬链接： ln link source</p> 
<h3><a id="9_904"></a>9、目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？</h3> 
<p>答：</p> 
<p>创建目录： mkdir</p> 
<p>创建文件：典型的如touch，vi也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件复制文件： cp7文件权限修改用什么命令？格式是怎么样的？</p> 
<p>文件权限修改： chmod</p> 
<p>格式如下：</p> 
<p>chmod u+x file 给 file 的属主增加执行权限</p> 
<p>chmod 751 file 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</p> 
<p>chmod u=rwx, g=rx, o=x file 上例的另一种形式</p> 
<p>chmod =r file 为所有用户分配读权限</p> 
<p>chmod 444 file 同上例</p> 
<p>chmod a-wx, a+r file 同上例</p> 
<p>chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限</p> 
<h3><a id="10_929"></a>10、查看文件内容有哪些命令可以使用？</h3> 
<p>答：</p> 
<p>vi文件名 #编辑方式查看，可修改</p> 
<p>cat文件名 #显示全部文件内容</p> 
<p>more文件名 #分页显示文件内容</p> 
<p>less文件名#与 more 相似，更好的是可以往前翻页</p> 
<p>tail 文件名 #仅查看尾部，还可以指定行数</p> 
<p>head 文件名 #仅查看头部,还可以指定行数</p> 
<h3><a id="11hello_world_944"></a>11、随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”?</h3> 
<p>答：</p> 
<p>写文件命令：vi</p> 
<p>向屏幕输出带空格的字符串:echo hello world</p> 
<h3><a id="12_951"></a>12、终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？</h3> 
<p>答：</p> 
<p>终端 /dev/tty</p> 
<p>黑洞文件 /dev/null</p> 
<h3><a id="13_959"></a>13、移动文件用哪个命令？改名用哪个命令？</h3> 
<p>答：</p> 
<p>mv</p> 
<h3><a id="14_964"></a>14、复制文件用哪个命令？如果需要连同文件夹一块复制呢？</h3> 
<p>答：</p> 
<p>cp</p> 
<p>cp -r</p> 
<h3><a id="15_972"></a>15、删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？</h3> 
<p>答：</p> 
<p>rm</p> 
<p>rm -r</p> 
<p>rmdir</p> 
<h3><a id="16Linux_981"></a>16、Linux下命令有哪几种可使用的通配符？分别代表什么含义？</h3> 
<p>答：</p> 
<p>“?” 可替代单个字符。</p> 
<p>“*” 可替代任意多个字符。</p> 
<p>方括号 “ [charset]” 可替代charset集中的任何单个字符， 如 [a-z]， [abABC]</p> 
<h3><a id="17_990"></a>17、用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)</h3> 
<p>答：</p> 
<p>wc 命令</p> 
<p>-c统计字节数</p> 
<p>-l统计行数</p> 
<p>-w统计字数。</p> 
<h3><a id="18Grep___1002"></a>18、Grep命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行?</h3> 
<p>答：</p> 
<p>是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p> 
<p>grep [string] filename</p> 
<h3><a id="19Linuxps_1009"></a>19、Linux中进程有哪几种状态？在ps显示出来的信息中分别用什么符号表示的？</h3> 
<p>答：</p> 
<p>1、不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指进程不响应异步信号。</p> 
<p>2、暂停状态/跟踪状态：向进程发送一个SIGSTOP信号，它就会因响应该信号 而进入TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。正被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。</p> 
<p>3、就绪状态：在 run_queue 队列里的状态</p> 
<p>4、运行状态：在 run_queue 队列里的状态</p> 
<p>5、可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待socket 连接、等待信号量），而被挂起</p> 
<p>6、zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉</p> 
<p>7、退出状态</p> 
<p>D 不可中断 Uninterruptible（usually IO）</p> 
<p>R 正在运行，或在队列中的进程</p> 
<p>S 处于休眠状态</p> 
<p>T 停止或被追踪</p> 
<p>Z 僵尸进程</p> 
<p>W 进入内存交换（从内核 2.6 开始无效）</p> 
<p>X 死掉的进程</p> 
<h3><a id="20_1040"></a>20、怎么使一个命令在后台运行?</h3> 
<p>答：</p> 
<p>一般都是使用 &amp; 在命令结尾来让程序自动运行。(命令后可以不追加空格)</p> 
<h3><a id="21ps_ps_1046"></a>21、利用ps怎么显示所有的进程? 怎么利用ps？</h3> 
<p>答：</p> 
<p>ps -ef (system v 输出)</p> 
<p>ps -aux bsd 格式输出</p> 
<p>ps -ef | grep pid</p> 
<h3><a id="22_1055"></a>22、哪个命令专门用来查看后台任务?</h3> 
<p>答：</p> 
<p>job -l</p> 
<h3><a id="23_1060"></a>23、把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令?</h3> 
<p>答：</p> 
<p>把后台任务调到前台执行fg</p> 
<p>把停下的后台任务在后台执行起来bg</p> 
<h3><a id="24__1067"></a>24、终止进程用什么命令? 带什么参数?</h3> 
<p>答：</p> 
<p>kill [-s &lt;信息名称或编号&gt;] [程序] 或 kill [-l &lt;信息编号&gt;]</p> 
<p>kill -9 pid</p> 
<h3><a id="25_1074"></a>25、怎么查看系统支持的所有信号？</h3> 
<p>答：</p> 
<p>kill -l</p> 
<h3><a id="26__1079"></a>26、搜索文件用什么命令? 格式是怎么样的?</h3> 
<p>答：</p> 
<p>find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</p> 
<p>whereis 加参数与文件名</p> 
<p>locate 只加文件名</p> 
<p>find 直接搜索磁盘，较慢。</p> 
<p>find / -name “string*”</p> 
<h3><a id="27__1092"></a>27、查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?</h3> 
<p>答：</p> 
<p>查找自己所在的终端信息：who am i</p> 
<p>查看当前谁在使用该主机：who</p> 
<h3><a id="28_1099"></a>28、使用什么命令查看用过的命令列表?</h3> 
<p>答：</p> 
<p>history</p> 
<h3><a id="29_1104"></a>29、使用什么命令查看磁盘使用空间？空闲空间呢?</h3> 
<p>答：</p> 
<p>df -hl</p> 
<h3><a id="30_1110"></a>30、使用什么命令查看网络是否连通?</h3> 
<p>答：</p> 
<p>netstat</p> 
<h3><a id="31IP_1115"></a>31、使用什么命令查看IP地址及接口信息？</h3> 
<p>答：</p> 
<p>ifconfig</p> 
<h3><a id="32_1120"></a>32、查看各类环境变量用什么命令?</h3> 
<p>答：</p> 
<p>查看所有env</p> 
<p>查看某个，如home：env $HOME</p> 
<h3><a id="33__1128"></a>33、查找命令的可执行文件是去哪查找的? 怎么对其进行设置及添加?</h3> 
<p>答：</p> 
<p>whereis [-bfmsu] [-B &lt;目 录 &gt;…] [-M &lt;目 录 &gt;…] [-S &lt;目 录 &gt;…] [文 件 …]</p> 
<p>补充说明：whereis指令会在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。</p> 
<p>-b只查找二进制文件。</p> 
<p>-B &lt;目录&gt; 只在设置的目录下查找二进制文件。</p> 
<p>-f不显示文件名前的路径名称。</p> 
<p>-m 只查找说明文件。</p> 
<p>-M &lt;目录&gt; 只在设置的目录下查找说明文件。</p> 
<p>-s 只查找原始代码文件。</p> 
<p>-S &lt;目录&gt; 只在设置的目录下查找原始代码文件。</p> 
<p>-u 查找不包含指定类型的文件。</p> 
<p>w -h ich 指令会在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p> 
<p>-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</p> 
<p>-p 与-n 参数相同，但此处的包括了文件的路径。</p> 
<p>-w 指定输出时栏位的宽度。</p> 
<p>-V 显示版本信息</p> 
<h3><a id="34_1162"></a>34、通过什么命令查找执行命令?</h3> 
<p>答：</p> 
<p>which只能查可执行文件</p> 
<p>whereis只能查二进制文件、说明文档，源文件等</p> 
<h3><a id="35_1170"></a>35、怎么对命令进行取别名？</h3> 
<p>答：</p> 
<p>alias la=‘ls -a’</p> 
<h3><a id="36dudf_1176"></a>36、du和df的定义，以及区别？</h3> 
<p>答：</p> 
<p>du显示目录或文件的大小</p> 
<p>df显示每个&lt;文件&gt;所在的文件系统的信息，默认是显示所有文件系统。</p> 
<p>（文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如i节点，磁盘分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的，通常称为MetaData。）</p> 
<p>du命令是用户级的程序，它不考虑Meta Data，而df命令则查看文件系统的磁盘分配图并考虑Meta Data。</p> 
<p>df命令获得真正的文件系统数据，而du命令只查看文件系统的部分情况。</p> 
<h3><a id="37Linux_1192"></a>37、如果一个Linux新手想要知道当前系统支持的所有命令的列表，他需要怎么做？</h3> 
<p>答：</p> 
<p>使用命令compgen -c，可以打印出所有支持的命令列表。</p> 
<h3><a id="38_1198"></a>38、如果你的助手想要打印出当前的目录栈，你会建议他怎么做？</h3> 
<p>答：</p> 
<p>使用Linux命令dirs可以将当前的目录栈打印出来。</p> 
<p>[root@localhost ~]# dirs /usr/share/X11</p> 
<h3><a id="39_1206"></a>39、你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？</h3> 
<p>答：</p> 
<p>使用linux 命令’disown -r '可以将所有正在运行的进程移除。</p> 
<h3><a id="40bash_shellhash_1212"></a>40、bash shell中的hash命令有什么作用？</h3> 
<p>答：</p> 
<p>linux命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径,用该命令可以打印出你所使用过的命令以及执行的次数。</p> 
<p>[root@localhost ~]# hash hits command 2 /bin/ls 2 /bin/su</p> 
<h3><a id="41_1222"></a>41、怎样一页一页地查看一个大文件的内容呢？</h3> 
<p>答：</p> 
<p>通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个需要</p> 
<p>[root@localhost ~]# cat file_name.txt | more</p> 
<h3><a id="42_1230"></a>42、数据字典属于哪一个用户的？</h3> 
<p>答：</p> 
<p>数据字典是属于’SYS’用户的，用户‘SYS’ 和 ’SYSEM’是由系统默认自动创建的</p> 
<h3><a id="43linuxbin__1236"></a>43、怎样查看一个linux命令的概要与用法？假设你在/bin 目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？</h3> 
<p>答：</p> 
<p>使用命令whatis可以先出显示出这个命令的用法简要，比如，你可以使用whatis zcat去查看‘zcat’的介绍以及使用简要。</p> 
<h3><a id="44_1242"></a>44、使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？</h3> 
<p>答：</p> 
<p>使用命令repquota 能够显示出一个文件系统的配额信息</p> 
<p>【附 】只有root用户才能够查看其它用户配额 。</p> 
<blockquote> 
 <p>资料来源：</p> 
 <p><a href="https://mp.weixin.qq.com/s/KMGyn-FLkvzsMH06LV4OfQ" rel="nofollow">面试字节，被操作系统问挂了 </a></p> 
 <p><a href="https://blog.csdn.net/Hb2077/article/details/130638834?spm=1001.2014.3001.5506">linux命令（面试）_linux常见命令面试-CSDN博客</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f4a55fa0794617f00d5af59498a08400/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux中_银河麒麟V4.0.2_使用中_遇到问题_及解决_记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59f4c4103dc2f15c09203392b4b49395/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu 配置国内源</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>