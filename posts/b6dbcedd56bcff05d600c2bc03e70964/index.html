<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mesh写入GLTF（学习记录） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mesh写入GLTF（学习记录）" />
<meta property="og:description" content="目录
1.GLTF::BUffer* buffer=asset-&gt;packAccessors()什么意思？
2.unsigned char*啥意思？
3.bufferData=(unsigned char*)realloc(bufferData,1000&#43;2000)什么意思？
4.GLTF::BufferView* bufferView=new GLTF::BufferView(byteOffset,image-&gt;byteLength,buffer);什么意思？
5.std::memcpy(bufferData&#43;byteOffset,image-&gt;data,image-&gt;byteLength)什么意思 ？
6.rapidjson::StringBuffer s；什么意思？
7.int jsonPadding=(4-(jsonString.length()&amp;3))&amp;3什么意思？
8.reinterpret_cast(writeHeader)什么意思？ 9.std::clock_t start=std::clock()和std::clock_t end=std::clock()什么意思 ？
10.stream.seekp(std::streampos(8)) 什么意思？ 这边主要是阅读源码出现的一些代码问题，源码可不敢放
1.GLTF::BUffer* buffer=asset-&gt;packAccessors()什么意思？ asset-&gt;packAccessors()是对 GLTF（glTF）资源中的访问器（Accessor）进行打包的操作。
在 glTF 中，访问器用于描述和访问缓冲区（Buffer）中的数据。访问器可以指定数据的类型、组件类型、数量以及在缓冲区中的偏移量等信息。而缓冲区则存储着实际的二进制数据，例如顶点坐标、法线、纹理坐标等。
2.unsigned char*啥意思？ `unsigned char*` 是 C/C&#43;&#43; 语言中的数据类型，表示一个指向无符号字符（unsigned char）的指针。
无符号字符（unsigned char）是一种数据类型，用于表示 0 到 255 之间的整数值。它是一个占用 1 个字节的数据类型，通常用来表示字节（byte）数据。
指针（pointer）是用来存储内存地址的变量。通过指针，我们可以访问或操作该地址上存储的数据。
因此，`unsigned char*` 表示一个指向无符号字符数据的指针。可以使用该指针来访问、读取或修改内存中存储的无符号字符数据。
例如，下面是一个示例代码片段，演示如何声明一个 `unsigned char*` 类型的指针，并使用它访问内存中的数据：
```
unsigned char* ptr; // 声明一个 unsigned char* 类型的指针
unsigned char value = 42;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b6dbcedd56bcff05d600c2bc03e70964/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-25T09:32:23+08:00" />
<meta property="article:modified_time" content="2023-05-25T09:32:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mesh写入GLTF（学习记录）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.GLTF%3A%3ABUffer*%20buffer%3Dasset-%3EpackAccessors()%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F-toc" style="margin-left:0px;"><a href="#1.GLTF%3A%3ABUffer*%20buffer%3Dasset-%3EpackAccessors%28%29%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F" rel="nofollow">1.GLTF::BUffer* buffer=asset-&gt;packAccessors()什么意思？</a></p> 
<p id="2.unsigned%20char*%E5%95%A5%E6%84%8F%E6%80%9D%EF%BC%9F-toc" style="margin-left:0px;"><a href="#2.unsigned%20char*%E5%95%A5%E6%84%8F%E6%80%9D%EF%BC%9F" rel="nofollow">2.unsigned char*啥意思？</a></p> 
<p id="3.bufferData%3D(unsigned%20char*)realloc(bufferData%2C1000%2B2000)%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F-toc" style="margin-left:0px;"><a href="#3.bufferData%3D%28unsigned%20char*%29realloc%28bufferData%2C1000%2B2000%29%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F" rel="nofollow">3.bufferData=(unsigned char*)realloc(bufferData,1000+2000)什么意思？</a></p> 
<p id="%C2%A04.GLTF%3A%3ABufferView*%20bufferView%3Dnew%20GLTF%3A%3ABufferView(byteOffset%2Cimage-%3EbyteLength%2Cbuffer)%3B%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%C2%A04.GLTF%3A%3ABufferView*%20bufferView%3Dnew%20GLTF%3A%3ABufferView%28byteOffset%2Cimage-%3EbyteLength%2Cbuffer%29%3B%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F" rel="nofollow"> 4.GLTF::BufferView* bufferView=new GLTF::BufferView(byteOffset,image-&gt;byteLength,buffer);什么意思？</a></p> 
<p id="5.std%3A%3Amemcpy(bufferData%2BbyteOffset%2Cimage-%3Edata%2Cimage-%3EbyteLength)%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%C2%A0%EF%BC%9F-toc" style="margin-left:0px;"><a href="#5.std%3A%3Amemcpy%28bufferData%2BbyteOffset%2Cimage-%3Edata%2Cimage-%3EbyteLength%29%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%C2%A0%EF%BC%9F" rel="nofollow">5.std::memcpy(bufferData+byteOffset,image-&gt;data,image-&gt;byteLength)什么意思 ？</a></p> 
<p id="6.rapidjson%3A%3AStringBuffer%20s%EF%BC%9B%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F-toc" style="margin-left:0px;"><a href="#6.rapidjson%3A%3AStringBuffer%20s%EF%BC%9B%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F" rel="nofollow">6.rapidjson::StringBuffer s；什么意思？</a></p> 
<p id="%C2%A07.int%20jsonPadding%3D(4-(jsonString.length()%263))%263%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%C2%A07.int%20jsonPadding%3D%284-%28jsonString.length%28%29%263%29%29%263%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F" rel="nofollow"> 7.int jsonPadding=(4-(jsonString.length()&amp;3))&amp;3什么意思？</a></p> 
<p id="8.reinterpret_cast%3Cconst%20char*%3E(writeHeader)%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%C2%A0-toc" style="margin-left:0px;"><a href="#8.reinterpret_cast%3Cconst%20char*%3E%28writeHeader%29%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%C2%A0" rel="nofollow">8.reinterpret_cast(writeHeader)什么意思？ </a></p> 
<p id="9.std%3A%3Aclock_t%20start%3Dstd%3A%3Aclock()%E5%92%8Cstd%3A%3Aclock_t%20end%3Dstd%3A%3Aclock()%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%C2%A0%EF%BC%9F-toc" style="margin-left:0px;"><a href="#9.std%3A%3Aclock_t%20start%3Dstd%3A%3Aclock%28%29%E5%92%8Cstd%3A%3Aclock_t%20end%3Dstd%3A%3Aclock%28%29%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%C2%A0%EF%BC%9F" rel="nofollow">9.std::clock_t start=std::clock()和std::clock_t end=std::clock()什么意思 ？</a></p> 
<p id="10.stream.seekp(std%3A%3Astreampos(8))%20%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%C2%A0-toc" style="margin-left:0px;"><a href="#10.stream.seekp%28std%3A%3Astreampos%288%29%29%20%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%C2%A0" rel="nofollow">10.stream.seekp(std::streampos(8)) 什么意思？ </a></p> 
<hr id="hr-toc"> 
<p>这边主要是阅读源码出现的一些代码问题，源码可不敢放</p> 
<h2 id="1.GLTF%3A%3ABUffer*%20buffer%3Dasset-%3EpackAccessors()%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F">1.GLTF::BUffer* buffer=asset-&gt;packAccessors()什么意思？</h2> 
<blockquote> 
 <p>asset-&gt;packAccessors()是对 GLTF（glTF）资源中的访问器（Accessor）进行打包的操作。</p> 
 <p>在 glTF 中，访问器用于描述和访问缓冲区（Buffer）中的数据。访问器可以指定数据的类型、组件类型、数量以及在缓冲区中的偏移量等信息。而缓冲区则存储着实际的二进制数据，例如<strong>顶点坐标、法线、纹理坐标</strong>等。</p> 
</blockquote> 
<h2 id="2.unsigned%20char*%E5%95%A5%E6%84%8F%E6%80%9D%EF%BC%9F">2.unsigned char*啥意思？</h2> 
<blockquote> 
 <p><code>`unsigned char*` 是 C/C++ 语言中的数据类型，表示一个指向无符号字符（unsigned char）的指针。</code></p> 
 <p><code>无符号字符（unsigned char）是一种数据类型，用于表示 0 到 255 之间的整数值。它是一个占用 1 个字节的数据类型，通常用来表示字节（byte）数据。</code></p> 
 <p><code>指针（pointer）是用来存储内存地址的变量。通过指针，我们可以访问或操作该地址上存储的数据。</code></p> 
 <p><code>因此，`unsigned char*` 表示一个指向无符号字符数据的指针。可以使用该指针来访问、读取或修改内存中存储的无符号字符数据。</code></p> 
 <p><code>例如，下面是一个示例代码片段，演示如何声明一个 `unsigned char*` 类型的指针，并使用它访问内存中的数据：</code></p> 
 <p><code>```<br> unsigned char* ptr;  // 声明一个 unsigned char* 类型的指针</code></p> 
 <p><code>unsigned char value = 42;<br> ptr = &amp;value;  // 将指针指向 value 的内存地址</code></p> 
 <p><code>unsigned char data = *ptr;  // 通过指针访问内存中的数据<br> ```</code></p> 
 <p><strong><code>在上述示例中，`ptr` 是一个 `unsigned char*` 类型的指针，它指向了 `value` 变量的内存地址。通过 `*ptr`，我们可以访问该地址上存储的数据，并将其赋值给 `data` 变量。</code></strong></p> 
 <p><code>请注意，`unsigned char*` 类型的指针可以用于处理字节数据或二进制数据，并进行内存操作，但需要小心处理，避免访问非法内存地址或引起内存错误。</code></p> 
</blockquote> 
<h2 id="3.bufferData%3D(unsigned%20char*)realloc(bufferData%2C1000%2B2000)%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F">3.bufferData=(unsigned char*)realloc(bufferData,1000+2000)什么意思？</h2> 
<blockquote> 
 <p><strong>这行代码使用了 `realloc` 函数来重新分配内存给 `bufferData` 指针，并将其指向重新分配后的内存块。</strong></p> 
 <p>`realloc` 是 C/C++ 中的一个函数，用于重新分配动态内存的大小。它接受两个参数：原始内存块的指针和新的内存块大小。</p> 
 <p>在这个例子中，`bufferData` 是一个 `unsigned char*` 类型的指针，它指向一块已经分配的内存。通过调用 `realloc(bufferData, 1000+2000)`，内存块的大小将被重新分配为 3000 字节（1000+2000）。</p> 
 <p>如果重新分配成功，`realloc` 函数会返回指向新分配内存块的指针，这里将其赋值给 `bufferData`。如果重新分配失败，`bufferData` 的值将保持不变。</p> 
 <p>这个操作通常用于动态调整内存大小，以适应数据的变化。在重新分配内存时，旧的数据会被保留到新分配的内存块中（如果空间足够），但不保证旧数据的内容不会被修改。因此，在使用 `realloc` 后，应小心处理重新分配后的内存块，并确保在不再需要时正确释放内存。</p> 
</blockquote> 
<h2 id="%C2%A04.GLTF%3A%3ABufferView*%20bufferView%3Dnew%20GLTF%3A%3ABufferView(byteOffset%2Cimage-%3EbyteLength%2Cbuffer)%3B%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"> 4.GLTF::BufferView* bufferView=new GLTF::BufferView(byteOffset,image-&gt;byteLength,buffer);什么意思？</h2> 
<blockquote> 
 <p>这行代码创建了一个 `GLTF::BufferView` 对象，并使用指定的参数进行初始化。</p> 
 <p>在 glTF（gl Transmission Format）中，`BufferView` 是一个描述缓冲区视图的对象。缓冲区视图<strong>定义了访问缓冲区的偏移量、字节长度和步长等信息。</strong></p> 
 <p>根据提供的代码，这是一个通过构造函数创建 `GLTF::BufferView` 对象的示例。构造函数接受三个参数：</p> 
 <p>1. `byteOffset`：指定缓冲区视图在缓冲区中的字节偏移量。它表示从缓冲区的起始位置开始的偏移量，用于确定数据在缓冲区中的位置。</p> 
 <p>2. `image-&gt;byteLength`：表示缓冲区视图的字节长度。这通常是数据的大小或容量。</p> 
 <p>3. `buffer`：指向包含数据的缓冲区对象的指针。它可能是一个 `GLTF::Buffer` 对象或与其等效的类型。</p> 
 <p>通过使用这些参数，`GLTF::BufferView` 对象被创建并初始化。这个对象可以被用于描述 glTF 模型中的图像数据、顶点数据或其他需要在缓冲区中访问的数据。</p> 
</blockquote> 
<h2 id="5.std%3A%3Amemcpy(bufferData%2BbyteOffset%2Cimage-%3Edata%2Cimage-%3EbyteLength)%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%C2%A0%EF%BC%9F">5.std::memcpy(bufferData+byteOffset,image-&gt;data,image-&gt;byteLength)什么意思？</h2> 
<blockquote> 
 <p>这行代码使用 `std::memcpy` 函数<strong>将数据从 `image-&gt;data` 复制到 `bufferData` 的指定偏移位置。</strong></p> 
 <p>`std::memcpy` 是 C++ 标准库中的一个函数，用于在内存之间进行原始数据的拷贝。它接受三个参数：</p> 
 <p>1. `bufferData+byteOffset`：表示目标内存地址，它是 `bufferData` 指针加上 `byteOffset` 的结果。这样可以将数据复制到 `bufferData` 指针指向的内存地址的特定偏移位置。</p> 
 <p>2. `image-&gt;data`：表示源内存地址，它是指向源数据的指针。`image-&gt;data` 可能是一个指向图像数据的指针。</p> 
 <p>3. `image-&gt;byteLength`：表示要复制的字节数。这个值通常是数据的大小或容量。</p> 
 <p>通过调用 `std::memcpy(bufferData+byteOffset, image-&gt;data, image-&gt;byteLength)`，将源数据从 `image-&gt;data` 复制到目标内存地址 `bufferData` 的指定偏移位置。这个操作会按字节精确地复制源数据到目标位置。</p> 
 <p>这段代码的目的是将图像数据复制到特定的缓冲区中，以供 glTF 模型或其他使用该缓冲区的操作使用。通过指定偏移量和数据长度，可以确保图像数据被正确地复制到相应的位置。</p> 
</blockquote> 
<h2 id="6.rapidjson%3A%3AStringBuffer%20s%EF%BC%9B%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F">6.rapidjson::StringBuffers；什么意思？</h2> 
<blockquote> 
 <p>这行代码声明了一个名为 `s` 的变量，其类型是 `rapidjson::StringBuffer`。</p> 
 <p>`rapidjson::StringBuffer` 是<strong> RapidJSON 库</strong>中的一个类，用于构建 JSON 字符串。它提供了一种<strong>方便的方式来动态地构建和拼接 JSON 数据。</strong></p> 
 <p>通过创建 `rapidjson::StringBuffer` 对象，你可以使用其提供的方法将数据以 JSON 格式添加到缓冲区中。最后，你可以通过调用 `GetString()` 方法获取构建的 JSON 字符串。</p> 
 <p>以下是一个示例用法：</p> 
 <p>```cpp<br> rapidjson::StringBuffer s;  // 声明一个 rapidjson::StringBuffer 对象</p> 
 <p>rapidjson::Writer&lt;rapidjson::StringBuffer&gt; writer(s);  // 创建 Writer 对象，将 s 作为输出缓冲区</p> 
 <p>writer.StartObject();  // 开始构建 JSON 对象<br> writer.Key("name");  // 添加键<br> writer.String("John Doe");  // 添加字符串值<br> writer.EndObject();  // 结束 JSON 对象</p> 
 <p>const char* jsonString = s.GetString();  // 获取构建的 JSON 字符串</p> 
 <p>std::cout &lt;&lt; jsonString &lt;&lt; std::endl;  // 输出 JSON 字符串<br> ```</p> 
 <p>在上述示例中，我们创建了一个 `rapidjson::StringBuffer` 对象 `s`，然后使用 `rapidjson::Writer` 将数据写入缓冲区 `s` 中。最后，我们通过调用 `GetString()` 方法将构建的 JSON 字符串提取出来，并使用 `std::cout` 输出到控制台。</p> 
 <p>通过使用 `rapidjson::StringBuffer`，你可以方便地构建和操作 JSON 字符串，以适应你的特定需求。</p> 
</blockquote> 
<h2 id="%C2%A07.int%20jsonPadding%3D(4-(jsonString.length()%263))%263%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"> 7.int jsonPadding=(4-(jsonString.length()&amp;3))&amp;3什么意思？</h2> 
<blockquote> 
 <p>这行代码计算了一个名为 `jsonPadding` 的整数值。</p> 
 <p>首先，让我们逐步解析这行代码：</p> 
 <p>1. `jsonString.length()`：这是一个字符串成员函数，用于获取字符串的长度（字符数）。</p> 
 <p>2. `jsonString.length() &amp; 3`：这是一个按位与（bitwise AND）运算符。它对字符串长度执行按位与操作，其中 `3` 表示二进制 `11`。这个运算的目的是获取字符串长度的低两位的值。</p> 
 <p>3. `(4 - (jsonString.length() &amp; 3))`：这是一个简单的数学表达式，用于计算一个差值。它减去字符串长度的低两位的值（`jsonString.length() &amp; 3`）从 `4` 中，这样得到的结果是 `0` 到 `3` 之间的数值。</p> 
 <p>4. `(4 - (jsonString.length() &amp; 3)) &amp; 3`：这是另一个按位与运算符。它对上一步计算的结果执行按位与操作，其中 `3` 表示二进制 `11`。这个运算的目的是确保最终的值在 `0` 到 `3` 之间。</p> 
 <p><strong>综上所述，这行代码的目的是计算一个用于填充 JSON 字符串的整数值，以确保其长度是 `4` 的倍数。</strong>通过使用这个填充值，可以对 JSON 字符串进行对齐或填充操作，以满足特定的需求或格式要求。</p> 
 <p>填充值的计算是根据字符串长度的低两位进行的，使填充值的范围在 `0` 到 `3` 之间。例如，如果字符串长度的低两位是 `1`，则填充值为 `3`，意味着需要在字符串末尾添加三个填充字节，以使其总长度成为 `4` 的倍数。</p> 
</blockquote> 
<h2 id="8.reinterpret_cast%3Cconst%20char*%3E(writeHeader)%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%C2%A0">8.reinterpret_cast&lt;const char*&gt;(writeHeader)什么意思？ </h2> 
<blockquote> 
 <p>这行代码使用了 `reinterpret_cast` 运算符<strong>将 `writeHeader` 转换为 `const char*` 类型的指针</strong>。</p> 
 <p>`reinterpret_cast` 是 C++ 中的一种类型转换运算符，用于执行低级别的类型转换。它可以将一个指针转换为不同类型的指针，即使这些类型之间没有直接的继承或关联关系。</p> 
 <p>在这个例子中，`writeHeader` 可能是一个指针（或者是一个可以隐式转换为指针的表达式），而 `reinterpret_cast&lt;const char*&gt;(writeHeader)` 将其转换为 `const char*` 类型的指针。</p> 
 <p>`const char*` 是指向常量字符的指针，通常用于处理字符串或字节数组数据。通过将 `writeHeader` 转换为 `const char*`，我们可以将其解释为指向字符数据的指针，<strong>以便于读取、处理或传递给相应的函数或库</strong>。</p> 
 <p>需要注意的是，`reinterpret_cast` 是一种强制类型转换操作，它可以执行非类型安全的转换。因此，在使用 `reinterpret_cast` 进行转换时，需要确保类型转换的安全性和正确性，以避免潜在的问题和错误。</p> 
</blockquote> 
<h2 id="9.std%3A%3Aclock_t%20start%3Dstd%3A%3Aclock()%E5%92%8Cstd%3A%3Aclock_t%20end%3Dstd%3A%3Aclock()%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%C2%A0%EF%BC%9F">9.std::clock_t start=std::clock()和std::clock_t end=std::clock()什么意思？</h2> 
<blockquote> 
 <p>这行代码使用 `std::clock()` 函数获取当前的时钟周期数，并将其赋值给 `end` 变量。</p> 
 <p>`std::clock_t` 是 C++ 标准库中的一个整数类型，用于表示时钟周期数。时钟周期是指计算机处理器所执行的时钟周期数，通常用于<strong>衡量代码的执行时间</strong>。</p> 
 <p>`std::clock()` 是一个函数，用于获取当前的时钟周期数。它返回一个表示时钟周期数的值，可以用于计算代码执行的时间。</p> 
 <p>通过调用 `std::clock()` 函数并将其返回值赋值给 `end` 变量，我们可以记录某个时间点的时钟周期数。通常，<strong>在代码执行的开始和结束之间获取时钟周期数，可以计算出代码的执行时间或计算某个操作的时间消耗。</strong></p> 
 <p>需要注意的是，`std::clock()` 返回的时钟周期数的单位和精度可能因操作系统和编译器而异。为了得到更精确的时间测量，可以使用更高级别的计时库或函数，如 `std::chrono` 库提供的功能。</p> 
</blockquote> 
<h2 id="10.stream.seekp(std%3A%3Astreampos(8))%20%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%C2%A0">10.stream.seekp(std::streampos(8)) 什么意思？ </h2> 
<blockquote> 
 <p>这行代码使用 `stream.seekp()` 方法将输出流的写入位置（put pointer）设置到指定的位置。</p> 
 <p>`stream.seekp()` 是一个流操作函数，用于设置输出流的写入位置。它接受一个参数，表示要设置的新的写入位置。</p> 
 <p>在这个例子中，`std::streampos(8)` 创建了一个类型为 `std::streampos` 的对象，该对象表示位置为 8 的写入位置。</p> 
 <p><strong>通过调用 `stream.seekp(std::streampos(8))`，我们将输出流的写入位置移动到位置为 8 的位置。这意味着下一次写入操作将从该位置开始。</strong></p> 
 <p>`std::streampos` 是用于表示流位置的类型，它可以接受不同的表示方式，如整数、指针等，具体取决于流的类型和实现。</p> 
 <p>通过使用 `stream.seekp()`，可以在输出流中进行定位操作，以便在特定位置进行写入操作或跳过一定数量的字节。这对于特定的文件处理或流操作场景非常有用。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/49ebe83a01e92ce393ec17a39b5dc406/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">kali 单元07 渗透攻击</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/56961accbd44c5c1090d953662b2037b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言基础 --使用自定义函数，交换两个变量的值</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>