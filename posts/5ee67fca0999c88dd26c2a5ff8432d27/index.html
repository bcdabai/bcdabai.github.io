<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>中缀表达式转后缀表达式看完这一篇文章你就懂了 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="中缀表达式转后缀表达式看完这一篇文章你就懂了" />
<meta property="og:description" content="文章目录 一、什么是中缀表达式
二、什么是后缀表达式
三、后缀转中缀具体思路
四、代码实现
一、什么是中缀表达式 中缀表达式就是我们常用的算术表达方式，例如(12&#43;34)*5，运算符在两个数的中间，但是对于中缀表达式来说括号和加减乘除使得问题对于计算机非常复杂，为了有效的处理他们，波兰逻辑学家想到了一种不需要括号的后缀表达式，我们称之为逆波兰。
二、什么是中缀表达式 后缀表达式也称逆波兰式或逆波兰记法，它通过中缀表达式转换而来，没有括号，只有数字和运算符，运算符总在要计算的数字的后面，之所以叫后缀表达式 是因为所有的运算符号都要在数字后面出现才行。举个例子来说，假如中缀表达式是：(12&#43;34)*5那么转换为后缀表达式就是：12 34 &#43; 5 *
看到这里，你可能蒙圈了，我们先把中缀表达式计算出来，结果是230。
此时此刻你一定想问，如何计算？其实很简单:
每次从左往右找到第一个运算符的位置，然后拿到前面两个位置的元素，跟这个运算符进行&#43;-*/ 运算，运算完将运算符和这两个元素删掉，再将新算出来的元素添加到运算符前面的位置，每次都这样计算，当后缀表达式为空时，就可以得到最终的那个结果。
看到这里，你应该顿悟了吧，如果还不明白，后面我会给出代码，相信你会明白的。
三、后缀转中缀具体思路 接下来是思路：
第一步：定义两个栈，一个用来存储后缀表达式栈，一个用来存储中间的运算符栈。
第二步：写个循环，从左往右遍历中缀表达式。
第三步：在循环中处理数字和运算符即可
怎么处理呢？接下来就为大家讲解
如果遇到数字，代表他是要运算的值，直接入后缀表达式栈
如果遇到了运算符，可以分情况讨论，有以下情况
当前栈为空，那就代表是第一个运算符，入栈即可
当前栈不为空，当前运算符大于栈顶运算符，入栈即可，如果小于或等于当前运算符，直接将运算符栈弹至后缀表达式栈
遇到括号，也要分情况讨论，有以下情况
左括号，直接入栈即可
右括号，弹出运算符直至左括号为止(实际上就是把这个括号包含的所有运算符弹出)
还要注意一点：如果运算符当前栈顶是&#39;(&#39;,那么下一个运算符无论是什么都要入栈
表达式遍历完后，把运算符栈剩下的弹至后缀表达式栈即可
四、代码实现 /* 中缀表达式转为后缀表达式具体思路： 1.定义两个栈，一个栈用来存储后缀表达式，一个栈用来存储中间的运算符 (括号，&#43;，-，/，*这些) 2.如果遇到数字，直接入后缀表达式栈 3.如果遇到运算符了，分情况讨论： 第一种：括号，如果是左括号，直接入栈，如果是右括号，把栈顶的运算符 给到后缀表达式栈中即可 第二种：&#43;,-,*,/，这些，如果遇到运算符优先级大于栈顶的运算符，直接入 栈，如果遇到不大于栈顶的优先级的运算符，直接出栈，然后再把当前运算 符入栈即可(tips:注意如果是运算符优先级相同，把栈顶运算符出栈即可) 4.重复操作即可 */ #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;algorithm&gt; typedef double d; using namespace std; enum Operator //运算符优先级 { //左括号 右括号 加 减 乘 除 left_bracket=2,right_bracket=0,Add=0, Minus=0, Multiply=1,Div=1 }; int Get_Operator_size(char cc){ //根据符号返回对应的运算符优先级 switch (cc) { case &#39;&#43;&#39;: return Add; case &#39;-&#39;: return Minus; case &#39;*&#39;:return Multiply; case &#39;/&#39;:return Div; case &#39;(&#39;:return left_bracket; case &#39;)&#39;:return right_bracket; default: return -1; } } struct expression{ //后缀表达式数据 string str; //运算符或者要运算的数字 expression(string str):str(str){} expression(){} }; class Slove_expression{ public: Slove_expression(){} Slove_expression(string Expree):Expree(Expree){} inline void Set_Expression(string Expree) { this-&gt;Expree = Expree;} vector&lt;expression&gt; Get_Front_expression() { int p = 0; string temp; expression Next; while (p&lt;Expree." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5ee67fca0999c88dd26c2a5ff8432d27/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-14T19:56:58+08:00" />
<meta property="article:modified_time" content="2023-01-14T19:56:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">中缀表达式转后缀表达式看完这一篇文章你就懂了</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h3 style="">文章目录</h3> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>一、什么是中缀表达式</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>二、什么是后缀表达式</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>三、后缀转中缀具体思路</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>四、代码实现</p></li></ul> 
 <hr> 
 <hr> 
 <h2 style="">一、什么是中缀表达式</h2> 
 <p style="">中缀表达式就是我们常用的算术表达方式，例如<span class="kdocs-color" style="color:#DB7800;">(12+34)*5</span>，运算符在两个数的中间，但是对于中缀表达式来说括号和加减乘除使得问题对于计算机非常复杂，为了有效的处理他们，波兰逻辑学家想到了一种不需要括号的后缀表达式，我们称之为逆波兰。</p> 
 <p style=""></p> 
 <h2 style="">二、什么是中缀表达式</h2> 
 <p style="">后缀表达式也称逆波兰式或逆波兰记法，它通过中缀表达式转换而来，没有括号，只有数字和运算符，运算符总在要计算的数字的后面，之所以叫后缀表达式 是因为所有的运算符号都要在数字后面出现才行。举个例子来说，假如中缀表达式是：<span class="kdocs-color" style="color:#C21C13;">(12+34)*5</span>那么转换为后缀表达式就是：<span class="kdocs-color" style="color:#C21C13;">12 34 + 5 *</span></p> 
 <hr> 
 <p style="">看到这里，你可能蒙圈了，我们先把中缀表达式计算出来，结果是<span class="kdocs-color" style="color:#58A401;">230</span>。</p> 
 <p style="">此时此刻你一定想问，如何计算？其实很简单:</p> 
 <p style="">每次从左往右找到第一个运算符的位置，然后拿到前面两个位置的元素，跟这个运算符进行<span class="kdocs-color" style="color:#0E52D4;">+-*/</span> 运算，运算完将运算符和这两个元素删掉，再将新算出来的元素添加到运算符前面的位置，每次都这样计算，当后缀表达式为空时，就可以得到最终的那个结果。</p> 
 <p style=""></p> 
 <p style="">看到这里，你应该顿悟了吧，如果还不明白，后面我会给出代码，相信你会明白的。</p> 
 <p style=""></p> 
 <h2 style="">三、后缀转中缀具体思路</h2> 
 <p style=""></p> 
 <p style="">接下来是思路：</p> 
 <p style="">第一步：定义两个栈，一个用来存储后缀表达式栈，一个用来存储中间的运算符栈。</p> 
 <p style="">第二步：写个循环，从左往右遍历中缀表达式。</p> 
 <p style="">第三步：在循环中处理数字和运算符即可</p> 
 <p style="">怎么处理呢？接下来就为大家讲解</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>如果遇到数字，代表他是要运算的值，直接入后缀表达式栈</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>如果遇到了运算符，可以分情况讨论，有以下情况</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p> 当前栈为空，那就代表是第一个运算符，入栈即可</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>当前栈不为空，当前运算符大于栈顶运算符，入栈即可，如果小于或等于当前运算符，直接将运算符栈弹至后缀表达式栈</p></li></ul> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>遇到括号，也要分情况讨论，有以下情况</p></li></ol> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>左括号，直接入栈即可</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>右括号，弹出运算符直至左括号为止(实际上就是把这个括号包含的所有运算符弹出)</p></li></ul> 
 <ol start="4"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>还要注意一点：如果运算符当前栈顶是'(',那么下一个运算符无论是什么都要入栈</p></li></ol> 
 <ol start="5"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>表达式遍历完后，把运算符栈剩下的弹至后缀表达式栈即可</p></li></ol> 
 <hr> 
 <h2 style="">四、代码实现</h2> 
 <pre class="kdocs-cpp"><code class="language-cpp">/*
中缀表达式转为后缀表达式具体思路：
1.定义两个栈，一个栈用来存储后缀表达式，一个栈用来存储中间的运算符
(括号，+，-，/，*这些)
2.如果遇到数字，直接入后缀表达式栈
3.如果遇到运算符了，分情况讨论：
第一种：括号，如果是左括号，直接入栈，如果是右括号，把栈顶的运算符
给到后缀表达式栈中即可
第二种：+,-,*,/，这些，如果遇到运算符优先级大于栈顶的运算符，直接入
栈，如果遇到不大于栈顶的优先级的运算符，直接出栈，然后再把当前运算
符入栈即可(tips:注意如果是运算符优先级相同，把栈顶运算符出栈即可)
4.重复操作即可
*/
#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
typedef double d;
using namespace std;
enum Operator   //运算符优先级
{
    //左括号     右括号        加     减       乘         除
    left_bracket=2,right_bracket=0,Add=0, Minus=0, Multiply=1,Div=1
};
int Get_Operator_size(char cc){ //根据符号返回对应的运算符优先级
    switch (cc) {
    case '+': return Add;
    case '-': return Minus;
    case '*':return Multiply;
    case '/':return Div;
    case '(':return left_bracket;
    case ')':return right_bracket;
    default: return -1;
    }
}
struct expression{ //后缀表达式数据
    string str;     //运算符或者要运算的数字
    expression(string str):str(str){}
    expression(){}
};
class Slove_expression{
public:
    Slove_expression(){}
    Slove_expression(string Expree):Expree(Expree){}
    inline void Set_Expression(string Expree) { this-&gt;Expree = Expree;}
    vector&lt;expression&gt; Get_Front_expression() {
        int p = 0;
        string temp;
        expression Next;
        while (p&lt;Expree.size()) {
            if(Expree[p]&gt;='0'  &amp;&amp; Expree[p]&lt;='9')
            temp.push_back(Expree[p]);   //保存数据
            if ((p&gt;=1  &amp;&amp; Get_Operator_size(Expree[p])!=-1 &amp;&amp; Expree[p-1]&gt;= '0' 
                &amp;&amp; Expree[p - 1] &lt;= '9')
                || p+1==Expree.size()) {  //处理最后一个整数式子
                //遇到运算符了 并且前面是数字 让数字入栈
                Next.str = temp;
                Stack.push(Next);    //如果是参与运算的数字 直接入栈
                temp.erase(temp.begin(),temp.end());  //将里面的数据删掉 防止重复
            }
            if (Get_Operator_size(Expree[p])!=-1 &amp;&amp; (operation.empty() || 
             Get_Operator_size(Expree[p])&gt;Get_Operator_size(operation.top().str[0])
            ||  operation.top().str[0]=='('))
                //如果运算符栈为空 直接将运算符入栈  或者运算符优先级大于顶栈运算符 入栈即可
            {
                //cout &lt;&lt; Expree.substr(p, 1) &lt;&lt; endl;
                Next.str = Expree.substr(p,1);  //将运算符切割出来
                operation.push(Next);          //运算符入栈
            }
            else if(Get_Operator_size(Expree[p])!=-1){  //运算符优先级一样 或者走到)运算符了
                if (Expree[p] == ')')   //右括号处理方式
                {
                    while(operation.top().str[0]!='('){
                        Stack.push(operation.top());
                        operation.pop();
                    }
                    operation.pop();
                }
                else {  //非右括号
                    Stack.push(operation.top());    //将运算符栈顶出栈
                    operation.pop();
                    Next.str = Expree.substr(p, 1);
                    operation.push(Next);
                }
            }
            p++;
        }
        while (!operation.empty()){  //将剩下的运算符入栈
            Stack.push(operation.top());
            operation.pop();
        }
        vector&lt;expression&gt; arr;
        while (!Stack.empty()){
            expression curr = Stack.top();
            arr.insert(arr.begin(),curr);
            Stack.pop();
            //cout &lt;&lt; curr.str &lt;&lt; '\t';
        }
        //cout &lt;&lt; endl;
        return arr;
    }

private:
    stack&lt;expression&gt; Stack;    //后缀表达式栈
    stack&lt;expression&gt; operation;  //运算符栈
    string Expree;  //表达式
};
class Value{  //通过后缀表达式计算出具体的值
public:
    Value(){}
    Value(vector&lt;expression&gt; arr) :arr(arr){}
    inline void Set_Value_Arr(vector&lt;expression&gt; arr) { this-&gt;arr = arr; }
    d Two_Number_Value(d left,char cc,d right){
        switch (cc) {
        case '+': return left + right;
        case '-':return left - right;
        case '/':return left / right;
        case '*':return left * right;
        default:return -1;
        }
    }
    d Get_Value(){
        int p = 0;
        d two_Number;
        //加一个数据防止出现下标问题
        arr.push_back(expression(string("#")));
        while (1) {
            if (Get_Operator_size(arr[p].str[0]) != -1) {   //找到运算符了
                two_Number = Two_Number_Value(stod(arr[p - 2].str), arr[p].str[0],
                    stod(arr[p - 1].str));
                //cout &lt;&lt; two_Number &lt;&lt; endl;
                arr.erase(arr.begin()+p-2,arr.begin()+p+1);
                //cout &lt;&lt; arr.size() &lt;&lt; endl;
                if (arr.size()==1 &amp;&amp; (*(arr.begin())).str[0] == '#')
                    break;
                arr.insert(arr.begin()+p-2, expression(to_string(two_Number)));
                p -= 2;
            }
            p++;
         }
        return two_Number;
    }
private:
    vector&lt;expression&gt; arr;
};
signed main() {
    string str;
    Slove_expression* solve = new Slove_expression;
    Value* value = new Value;
    while (1) {
        cout &lt;&lt; "请输入表达式:";
        cin &gt;&gt; str;
        solve-&gt;Set_Expression(str);
        vector&lt;expression&gt; arr = solve-&gt;Get_Front_expression();
        value-&gt;Set_Value_Arr(arr);
        cout &lt;&lt; "reslt:"&lt;&lt;value-&gt;Get_Value();
        cout &lt;&lt; endl;
    }
    return 0;

}</code></pre> 
 <hr> 
 <p style="">总结：中缀表达式转后缀表达式实际上就是栈的运用，如果你不了解栈，建议了解完再来看本篇文章。</p> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7c74c4175f665047939923947bd1ec1a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">写个bat程序，搜索文件夹中带有指定关键词的文件，然后移动到指定的文件夹...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99b07e2359e1e8ad98fd98093c0ef7be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">搭建nacos环境(保姆级教程)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>