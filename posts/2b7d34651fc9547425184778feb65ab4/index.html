<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux-MySQL主从复制详解和配置--一主一从 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux-MySQL主从复制详解和配置--一主一从" />
<meta property="og:description" content="什么是主从复制 主从复制是用来建立一个和主数据库完全一致的数据库环境，称为从数据库；主数据库一般是准实时的业务数据库。
1.主从复制的作用 1.做数据的热备，作为后备数据库，主数据库服务器故障之后，可以切换到从数据库继续工作，避免数据丢失。
2.架构的扩展，业务量越来越大，I/O访问量过高，单机无法满足，此时做多库存储，减低磁盘I/O访问的频率，提高单个机器的I/O性能。
3.读写分离，使数据库能支撑更大的并发：
--在从服务器可以执行查询操作（读）,降低主服务器的压力（主库执行写操作，从库执行读操作，从而降低压力）。
--在从服务器进行备份，避免备份期间影响主服务器服务，确保数据安全。
2.主从复制的原理 实现整个主从复制，需要由slave服务器上的I/O线程和省去了线程共同完成。
要实现主从复制，首先必须打开master端的binlog 功能
主从复制过程实际上就是slave从master端获取相应的二进制日志（binlog），然后再在自己的slave端完全按照顺序执行日志中的时间，将其执行到自己的数据库中。
---------------------------------------------------------------------------------------------
1.在主库上把数据记录到binlog日志中，
2.从库I/O线程将主库上的日志复制到自己的中继日志中。
3.从库sql线程读取中继日志中的事件，将其执行到从数据库之上
----------------------------------------------------------------------------------------------
master 负责写 A
slave relay-log B
I/O 负责通信读取binlog日志
sql 负责写数据
步骤一：主库db的更新事件(update、insert、delete)被写到binlog
步骤二：从库发起连接，连接到主库
步骤三：此时主库创建一个binlog dump thread线程，把binlog的内容发送到从库
步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log.
步骤五：从库还会创建一个SQL线程，从relay log里面读取内容，将更新内容写入到slave的db.
面试题：
1.主从复制延迟比较大的原因：
主服务器配置高，从服务器配置低
并发量大导致主服务器读得慢，从服务器写得慢
网络延迟较高
从服务器的读写速度慢
从节点过多
2.从数据库的读的延迟问题了解吗？如何解决
半同步复制---解决数据丢失的问题
并行复制---解决从库复制延迟的问题
3.主从复制 一，binlog日志 首先两台机器都关闭防火墙和selinux 两台机器环境必须一致，时间也一致 # systemctl stop firewalld # setenforce 0 可以先进行域名解析 /etc/hosts 不解析也可以 后面配置的时候就要写ip # vim /etc/hosts 192.168.126.141 mysql-master 192.168.126.139 mysql-slave 添加两台机器的ip 即可 后面可以自定义 每台机器都要配置 如果有mysql 需要保证两台机器数据一致 所有这里进行了删除库内容删除日志等 省略了。。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2b7d34651fc9547425184778feb65ab4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-30T14:02:49+08:00" />
<meta property="article:modified_time" content="2023-08-30T14:02:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux-MySQL主从复制详解和配置--一主一从</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>什么是主从复制</h2> 
<p>主从复制是用来建立一个和主数据库完全一致的数据库环境，称为从数据库；主数据库一般是准实时的业务数据库。</p> 
<h2>1.主从复制的作用</h2> 
<blockquote> 
 <p>1.做数据的热备，作为后备数据库，主数据库服务器故障之后，可以切换到从数据库继续工作，避免数据丢失。<br> 2.架构的扩展，业务量越来越大，I/O访问量过高，单机无法满足，此时做多库存储，减低磁盘I/O访问的频率，提高单个机器的I/O性能。<br> 3.读写分离，使数据库能支撑更大的并发：<br>     --在从服务器可以执行查询操作（读）,降低主服务器的压力（主库执行写操作，从库执行读操作，从而降低压力）。<br>     --在从服务器进行备份，避免备份期间影响主服务器服务，确保数据安全。</p> 
</blockquote> 
<h2> 2.主从复制的原理</h2> 
<blockquote> 
 <p>实现整个主从复制，需要由slave服务器上的I/O线程和省去了线程共同完成。</p> 
 <p>要实现主从复制，首先必须打开master端的binlog 功能</p> 
 <p>主从复制过程实际上就是slave从master端获取相应的二进制日志（binlog），然后再在自己的slave端完全按照顺序执行日志中的时间，将其执行到自己的数据库中。</p> 
 <p>---------------------------------------------------------------------------------------------</p> 
 <p>1.在主库上把数据记录到binlog日志中，</p> 
 <p>2.从库I/O线程将主库上的日志复制到自己的中继日志中。</p> 
 <p>3.从库sql线程读取中继日志中的事件，将其执行到从数据库之上</p> 
 <p>----------------------------------------------------------------------------------------------</p> 
 <p>master        负责写                  A</p> 
 <p>slave           relay-log               B</p> 
 <p>I/O                  负责通信读取binlog日志</p> 
 <p>sql                  负责写数据</p> 
</blockquote> 
<p> <img alt="" height="483" src="https://images2.imgbox.com/b1/d2/POahxLlv_o.png" width="768"></p> 
<blockquote> 
 <p> 步骤一：主库db的更新事件(update、insert、delete)被写到binlog<br> 步骤二：从库发起连接，连接到主库<br> 步骤三：此时主库创建一个binlog dump thread线程，把binlog的内容发送到从库<br> 步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log.<br> 步骤五：从库还会创建一个SQL线程，从relay log里面读取内容，将更新内容写入到slave的db.</p> 
</blockquote> 
<blockquote> 
 <p>面试题：</p> 
 <p> 1.主从复制延迟比较大的原因：</p> 
 <p>主服务器配置高，从服务器配置低</p> 
 <p>并发量大导致主服务器读得慢，从服务器写得慢</p> 
 <p>网络延迟较高</p> 
 <p>从服务器的读写速度慢</p> 
 <p>从节点过多</p> 
 <p></p> 
 <p>2.从数据库的读的延迟问题了解吗？如何解决</p> 
 <p>半同步复制---解决数据丢失的问题</p> 
 <p>并行复制---解决从库复制延迟的问题</p> 
</blockquote> 
<h2>3.主从复制 一，binlog日志   </h2> 
<pre><code class="language-sql">首先两台机器都关闭防火墙和selinux    两台机器环境必须一致，时间也一致

# systemctl stop firewalld

# setenforce 0

可以先进行域名解析  /etc/hosts    不解析也可以   后面配置的时候就要写ip

# vim /etc/hosts

192.168.126.141  mysql-master
192.168.126.139  mysql-slave
添加两台机器的ip 即可   后面可以自定义  每台机器都要配置


</code></pre> 
<p>如果有mysql 需要保证两台机器数据一致    所有这里进行了删除库内容删除日志等   省略了。。</p> 
<p><img alt="" height="106" src="https://images2.imgbox.com/11/55/lZn6Lgkt_o.png" width="643"></p> 
<p></p> 
<h3><span style="color:#fe2c24;">配置主服务</span></h3> 
<p>在主服务器配置文件 /etc/my.cof 添加内容</p> 
<pre><code class="language-sql">在[mysqld]中添加
log-bin=/var/log/mysql-bin/mylog     //这是binlog日志存放的位置  可以自定义
server-id=1              服务器id   两台机器不能一样</code></pre> 
<p>创建存放binlog日志的文件</p> 
<pre><code class="language-sql"># mkdir /var/log/mysql

# chown -R mysql.mysql /var/log/mysql</code></pre> 
<p>重启服务</p> 
<p>   #  systemctl restart mysqld</p> 
<p>查找密码</p> 
<p> #  grep  password  /var/lib/mysqld.log</p> 
<p><img alt="" height="63" src="https://images2.imgbox.com/a4/8a/g7ci6STu_o.png" width="909"></p> 
<p> 修改密码</p> 
<pre><code class="language-sql"># mysqladmin -u root -p'%log6KKkmYDF' password 'Master@123'</code></pre> 
<p>创建主从同步用户</p> 
<pre><code class="language-sql"># mysql -uroot -pMaster@123

mysql&gt; grant replication slave on *.* to repl@'%' identified by 'Repl@123'；
 
mysql&gt; flush privileges;</code></pre> 
<p>然后再master上操作</p> 
<pre><code class="language-sql">mysql&gt; show master status\G</code></pre> 
<p><img alt="" height="210" src="https://images2.imgbox.com/ec/40/cIaun1vp_o.png" width="821"></p> 
<h3><span style="color:#0d0016;"> </span><span style="color:#fe2c24;">配置从服务器slave</span></h3> 
<p>先添加配置文件</p> 
<pre><code class="language-sql">[root@slave ~]# vim /etc/my.cnf


[mysqld]

server-id=2</code></pre> 
<p>启动服务</p> 
<p>设置密码</p> 
<p>#  grep password  /var/log/mysqld.log </p> 
<p><img alt="" height="63" src="https://images2.imgbox.com/c8/c7/27DdUcgt_o.png" width="913"></p> 
<pre><code class="language-sql">[root@slave ~]# mysqladmin -u root -p'mmlaoG#at0S&amp;' password 'Slave@123'</code></pre> 
<p>登录mysql</p> 
<pre><code class="language-sql">mysql&gt; \e
change master to
master_host='mysql-master',
master_user='repl',
master_password='Repl@123',
master_log_file='mylog.000001',
master_log_pos=154；
</code></pre> 
<p>启动slave并查看状态</p> 
<pre><code class="language-sql">mysql&gt; start slave;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show slave status\G</code></pre> 
<p><img alt="" height="771" src="https://images2.imgbox.com/ed/f7/VsyRba7b_o.png" width="1026"></p> 
<p> IO  和sql   都显示Yes  即为成功</p> 
<blockquote> 
 <p>参数解释</p> 
 <p>change  master ro </p> 
 <p>master_host='mysql-master'              #主服务器ip    前面域名配置过  没配置的可以直接写ip</p> 
 <p>master_user='repl'               #之前创建的主从用户    </p> 
 <p>master_password='Repl@123'     #主从用户的密码</p> 
 <p>master_log_file='mylog.000001'    #binlog日志文件名  这是master的  直接在master机器复制</p> 
 <p>master_log_pos=154   #日志位置    都在master上有显示的</p> 
</blockquote> 
<h3><span style="color:#fe2c24;">测试</span></h3> 
<p>在master上进行测试  创建一个库  ceshi </p> 
<p>未创建时 master 上显示的库</p> 
<p><img alt="" height="228" src="https://images2.imgbox.com/9d/73/tqnYsfWp_o.png" width="444"></p> 
<p>slave上的库</p> 
<p><img alt="" height="264" src="https://images2.imgbox.com/b7/12/qCPLauug_o.png" width="550"></p> 
<p>master上创建</p> 
<pre><code class="language-sql">mysql&gt; create database ceshi;
Query OK, 1 row affected (0.00 sec)

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| ceshi              |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)
</code></pre> 
<p> 在slave上查看</p> 
<pre><code class="language-sql">mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| ceshi              |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)</code></pre> 
<p> 二者都有ceshi这个库    主从配置完成！</p> 
<p></p> 
<h2>4.主从复制二，GTID基于事务ID复制</h2> 
<p>GTID   全局事务标识：global transaction identifiers</p> 
<p>是用来代替传统复制的方法，GTID复制与普通复制模式的最大不同就是不需要指定二进制文件名和位置。</p> 
<h3>1.GTID工作原理</h3> 
<blockquote> 
 <p>1、master更新数据时，会在事务前产生GTID，一同记录到binlog日志中。<br> 2、slave端的i/o 线程将变更的binlog，写入到本地的relay log中。<br> 3、sql线程从relay log中获取GTID，然后对比slave端的binlog是否有记录。<br> 4、如果有记录，说明该GTID的事务已经执行，slave会忽略。<br> 5、如果没有记录，slave就会从relay log中执行该GTID的事务，并记录到binlog。</p> 
</blockquote> 
<h3>2.配置主服务器master</h3> 
<p>还是关闭防火墙和selinux   两台机器环境一致  推荐删库删配置文件重安mysql</p> 
<p>两台机器域名解析</p> 
<pre><code class="language-sql">vim /etc/hosts
192.168.126.141  mysql-master
192.168.126.139  mysql-slave
</code></pre> 
<p>和上面一样都先更改密码 ，省略</p> 
<p><span style="color:#fe2c24;">在master上操作 修改配置文件</span></p> 
<pre><code class="language-sql">[mysqld]
log-bin=/var/log/mysql-bin/mylog
server-id=1
gtid_mode = ON
enforce_gtid_consistency=1
</code></pre> 
<p><br> gtid_mode = ON                          开启gtid<br> enforce_gtid_consistency=1        强制gtid</p> 
<p>开启mysql创建主从用户</p> 
<pre><code class="language-sql">mysql&gt; grant replication  slave on *.* to yonghu@'%' identified by 'Yonghu@123'
    -&gt; ;
mysql&gt; flush privileges;</code></pre> 
<p><span style="color:#fe2c24;">在slave上操作</span></p> 
<pre><code class="language-sql">[mysqld]
log-bin=/var/log/mysql-bin/mylog
server-id=2
gtid_mode = ON
enforce_gtid_consistency=1
master-info-repository=TABLE
relay-log-info-repository=TABLE
</code></pre> 
<p>进入mysql</p> 
<pre><code class="language-sql">mysql&gt;\e
change master to
master_host='mysql-master',
master_user='yonghu',
master_password='Yonghu@123',
master_auto_position=1;</code></pre> 
<p>启动slave  查看状态</p> 
<pre><code class="language-sql">mysql&gt; start slave;
mysql&gt; show slave status\G</code></pre> 
<p><img alt="" height="385" src="https://images2.imgbox.com/b4/63/MqqDTFiL_o.png" width="874"></p> 
<p>双Yes即可</p> 
<h3 style="background-color:transparent;"> 3.测试</h3> 
<p>初始状态master</p> 
<p><img alt="" height="275" src="https://images2.imgbox.com/08/1f/UZlG9PTI_o.png" width="476"></p> 
<p>初始状态slave</p> 
<p> <img alt="" height="254" src="https://images2.imgbox.com/f6/5a/0I0vL973_o.png" width="526"></p> 
<p>在master中创建一个ceshi库</p> 
<pre><code class="language-sql">mysql&gt; create database ceshi;
Query OK, 1 row affected (0.00 sec)

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| ceshi              |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)
</code></pre> 
<p> 在slave上查看</p> 
<pre><code class="language-sql">mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| ceshi              |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)
</code></pre> 
<p>都存在ceshi库  配置成功</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df655e082930cf4f79ec77456dfeb1d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">新手利用hexo在Gitee搭建第一个博客网站（2023巨细）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dfed94c5985ffc311c2a594b3c224e25/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu20.04下ROS2-foxy版本与PX4开发环境配置教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>