<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32 CubeMX 中断NVIC 实战 (超详细配30张高清图，附源码) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32 CubeMX 中断NVIC 实战 (超详细配30张高清图，附源码)" />
<meta property="og:description" content="STM32 CubeMX 中断NVIC 实战 (超详细配30张高清图，附源码) 1. 中断基础概念 STM32F407的嵌套向量中断控制器（Nested Vectored Interrupt Controller，NVIC）管理所有中断，它有82个可屏蔽中断，还有13个系统中断。82个可屏蔽中断和部分系统中断可配置中断优先级，总共有16个优先级。
触发条件： 中断是由外部事件触发的，这些事件可以是来自硬件（比如传感器输入、定时器结束等）或软件（比如系统调用或特定指令）的信号。响应过程： 当中断事件发生时，处理器暂停当前正在执行的任务，保存当前状态（比如程序计数器、寄存器状态等），然后跳转执行预定义的中断服务程序（ISR，Interrupt Service Routine）。中断服务程序： 这是一段专门设计来处理特定中断的代码。它会执行必要的操作以响应中断事件，可能会读取外部设备状态、清除中断标志、执行特定操作并最终恢复被打断的程序执行。中断优先级： 中断可以具有不同的优先级，允许系统在有多个中断发生时确定哪个中断应该首先被处理。 NVIC是ARM Cortex-M处理器内部的模块，负责管理处理器的中断。它的特性包括：
嵌套性： 允许不同优先级的中断按照其优先级被嵌套处理，优先级高的中断可以中断优先级低的中断。向量表： 每个中断都有一个唯一的编号（向量），这些向量存储在向量表中。当中断发生时，处理器通过查找向量表中的特定入口点来确定要执行的中断服务程序。优先级和控制： NVIC允许配置每个中断的优先级，并可以通过控制寄存器来使能或禁用特定的中断。 在STM32系列中，要使用中断，通常的步骤包括配置相关的外部硬件（如果需要）、配置NVIC以及编写中断服务程序。在初始化过程中，需要确保配置中断优先级和使能相应的中断。
2. 中断向量表 STM32F4系列使用的是ARM Cortex-M内核，中断向量表是处理器中的一组特殊地址，存储着每个中断服务程序的入口地址。当发生中断时，处理器会根据中断编号查找中断向量表，并跳转到相应中断服务程序的入口地址执行。
STM32F4的中断向量表结构： 存储位置： 中断向量表存储在处理器的内存中，通常位于微控制器的Flash起始地址处。在STM32F4中，中断向量表通常位于0x00000000的地址处，是一个连续的地址空间。向量表项： 每个中断有一个向量表项。这些项是连续存储的，每个项占据4个字节。中断服务程序入口地址： 每个向量表项存储着对应中断服务程序的入口地址。当中断发生时，处理器会根据中断编号找到相应的入口地址并跳转执行。 STM32F4的中断向量表组成： 在STM32F4中，中断向量表包括了两种类型的向量表项：
ARM Cortex-M处理器核心向量表： 这部分向量表项包含了Cortex-M处理器的核心中断服务程序入口地址，如： 初始栈指针（Initial Stack Pointer）复位（Reset）NMI（Non-Maskable Interrupt）Hard Fault等 STM32特定的外设中断向量表： 在ARM Cortex-M处理器核心向量表后面，是STM32特定的外设中断向量表项。这些项存储着与STM32F4系列相关的外设中断服务程序的入口地址，比如TIM1、TIM2、USART1等。如下图所示： 用STM32CubeMX生成代码后，在 startup_stm32f407zgtx.s 汇编文件中，我们可以看到中断向量表具体的定义和中断服务函数。
3. 中断优先级 在STM32F4系列中，中断优先级用于确定当多个中断同时发生时，处理器应该先处理哪个中断。这个优先级系统是由ARM Cortex-M内核提供支持的。
3.1 中断优先级的特点： 可编程性：
STM32F4允许针对每个可中断的外设配置中断优先级。这使得开发者可以根据系统需求对中断进行优先级管理。
优先级位数：
Cortex-M内核中的中断优先级分为抢占优先级（Preemption Priority）和子优先级（Subpriority）。在STM32F4中，通常抢占优先级占据较高的位数，子优先级占据较低的位数。
数值越小，优先级越高：
优先级数值越小，表示优先级越高。比如，抢占优先级数值为0的中断优先级最高。
3.2 中断优先级的配置： 在STM32F4中，使用NVIC（Nested Vectored Interrupt Controller）来配置中断优先级。配置中断优先级的步骤如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/90c5c426a5401002a2552d6c9f9e3096/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T20:56:32+08:00" />
<meta property="article:modified_time" content="2024-01-03T20:56:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32 CubeMX 中断NVIC 实战 (超详细配30张高清图，附源码)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="STM32_CubeMX_NVIC__30_0"></a>STM32 CubeMX 中断NVIC 实战 (超详细配30张高清图，附源码)</h2> 
<p><img src="https://images2.imgbox.com/45/dd/DsIhRdvW_o.png" alt="image-20231231175604434"></p> 
<h3><a id="1__8"></a>1. 中断基础概念</h3> 
<p>STM32F407的嵌套向量中断控制器（Nested Vectored Interrupt Controller，NVIC）管理所有中断，它有82个可屏蔽中断，还有13个系统中断。82个可屏蔽中断和部分系统中断可配置中断优先级，总共有16个优先级。</p> 
<ol><li><strong>触发条件</strong>： 中断是由外部事件触发的，这些事件可以是来自硬件（比如传感器输入、定时器结束等）或软件（比如系统调用或特定指令）的信号。</li><li><strong>响应过程</strong>： 当中断事件发生时，处理器暂停当前正在执行的任务，保存当前状态（比如程序计数器、寄存器状态等），然后跳转执行预定义的中断服务程序（ISR，Interrupt Service Routine）。</li><li><strong>中断服务程序</strong>： 这是一段专门设计来处理特定中断的代码。它会执行必要的操作以响应中断事件，可能会读取外部设备状态、清除中断标志、执行特定操作并最终恢复被打断的程序执行。</li><li><strong>中断优先级</strong>： 中断可以具有不同的优先级，允许系统在有多个中断发生时确定哪个中断应该首先被处理。</li></ol> 
<p>NVIC是ARM Cortex-M处理器内部的模块，负责管理处理器的中断。它的特性包括：</p> 
<ol><li><strong>嵌套性</strong>： 允许不同优先级的中断按照其优先级被嵌套处理，优先级高的中断可以中断优先级低的中断。</li><li><strong>向量表</strong>： 每个中断都有一个唯一的编号（向量），这些向量存储在向量表中。当中断发生时，处理器通过查找向量表中的特定入口点来确定要执行的中断服务程序。</li><li><strong>优先级和控制</strong>： NVIC允许配置每个中断的优先级，并可以通过控制寄存器来使能或禁用特定的中断。</li></ol> 
<p>在STM32系列中，要使用中断，通常的步骤包括配置相关的外部硬件（如果需要）、配置NVIC以及编写中断服务程序。在初始化过程中，需要确保配置中断优先级和使能相应的中断。</p> 
<h3><a id="2__27"></a>2. 中断向量表</h3> 
<p>STM32F4系列使用的是ARM Cortex-M内核，中断向量表是处理器中的一组特殊地址，存储着每个中断服务程序的入口地址。当发生中断时，处理器会根据中断编号查找中断向量表，并跳转到相应中断服务程序的入口地址执行。</p> 
<h5><a id="STM32F4_31"></a>STM32F4的中断向量表结构：</h5> 
<ol><li><strong>存储位置</strong>： 中断向量表存储在处理器的内存中，通常位于微控制器的Flash起始地址处。在STM32F4中，中断向量表通常位于0x00000000的地址处，是一个连续的地址空间。</li><li><strong>向量表项</strong>： 每个中断有一个向量表项。这些项是连续存储的，每个项占据4个字节。</li><li><strong>中断服务程序入口地址</strong>： 每个向量表项存储着对应中断服务程序的入口地址。当中断发生时，处理器会根据中断编号找到相应的入口地址并跳转执行。</li></ol> 
<h5><a id="STM32F4_37"></a>STM32F4的中断向量表组成：</h5> 
<p>在STM32F4中，中断向量表包括了两种类型的向量表项：</p> 
<ol><li><strong>ARM Cortex-M处理器核心向量表</strong>： 这部分向量表项包含了Cortex-M处理器的核心中断服务程序入口地址，如： 
  <ul><li>初始栈指针（Initial Stack Pointer）</li><li>复位（Reset）</li><li>NMI（Non-Maskable Interrupt）</li><li>Hard Fault等</li></ul> </li><li><strong>STM32特定的外设中断向量表</strong>： 在ARM Cortex-M处理器核心向量表后面，是STM32特定的外设中断向量表项。这些项存储着与STM32F4系列相关的外设中断服务程序的入口地址，比如TIM1、TIM2、USART1等。如下图所示：</li></ol> 
<p><img src="https://images2.imgbox.com/08/61/m0Fe8jfk_o.png" alt="image-20240101233803447"></p> 
<p>用STM32CubeMX生成代码后，在 <strong>startup_stm32f407zgtx.s</strong> 汇编文件中，我们可以看到中断向量表具体的定义和中断服务函数。</p> 
<p><img src="https://images2.imgbox.com/b8/07/fxYts43l_o.png" alt="image-20240102074829476"></p> 
<h3><a id="3__54"></a>3. 中断优先级</h3> 
<p>在STM32F4系列中，中断优先级用于确定当多个中断同时发生时，处理器应该先处理哪个中断。这个优先级系统是由ARM Cortex-M内核提供支持的。</p> 
<h5><a id="31__58"></a>3.1 中断优先级的特点：</h5> 
<ol><li> <p><strong>可编程性</strong>：<br> STM32F4允许针对每个可中断的外设配置中断优先级。这使得开发者可以根据系统需求对中断进行优先级管理。</p> </li><li> <p><strong>优先级位数</strong>：<br> Cortex-M内核中的中断优先级分为抢占优先级（Preemption Priority）和子优先级（Subpriority）。在STM32F4中，通常抢占优先级占据较高的位数，子优先级占据较低的位数。</p> </li><li> <p><strong>数值越小，优先级越高</strong>：<br> 优先级数值越小，表示优先级越高。比如，抢占优先级数值为0的中断优先级最高。</p> </li></ol> 
<h5><a id="32__69"></a>3.2 中断优先级的配置：</h5> 
<p>在STM32F4中，使用NVIC（Nested Vectored Interrupt Controller）来配置中断优先级。配置中断优先级的步骤如下：</p> 
<ol><li> <p><strong>确定优先级组分配</strong>：<br> Cortex-M内核允许将中断优先级分为不同的组，主要分为4-2-2（4位抢占优先级、2位子优先级）和3-1-4（3位抢占优先级、1位子优先级）两种模式。这决定了中断优先级的位分配，应根据系统需求进行选择。</p> </li><li> <p><strong>设置抢占优先级和子优先级</strong>：<br> 使用库函数或直接操作NVIC寄存器来为每个中断分配优先级。通常有函数如<code>NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)</code>用于设置中断的抢占优先级和子优先级。</p> </li><li> <p><strong>优先级的影响</strong>：<br> 在相同的优先级组中，较低位的抢占优先级数值越小，优先级越高；较低位的子优先级数值越小，优先级越高。</p> </li></ol> 
<h5><a id="33__82"></a>3.3 示例：</h5> 
<pre><code class="prism language-c"><span class="token comment">// 设置外设中断优先级为抢占优先级2，子优先级1</span>
<span class="token function">NVIC_SetPriority</span><span class="token punctuation">(</span>USART1_IRQn<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 启用USART1中断</span>
<span class="token function">NVIC_EnableIRQ</span><span class="token punctuation">(</span>USART1_IRQn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这个示例中，针对USART1的中断被配置为抢占优先级为2，子优先级为1。请注意，优先级配置必须在使能相应中断之前完成。</p> 
<p>了解并正确配置中断优先级对于确保在系统中正确处理中断，并按照预期的顺序处理多个中断事件至关重要。</p> 
<h3><a id="4_HAL_97"></a>4. 中断相关的HAL驱动程序</h3> 
<p>中断管理相关驱动程序的头文件是 <strong>stm32f4xx_hal_cortex.h</strong> ，常用函数如下图所示</p> 
<table><thead><tr><th align="left">函数名</th><th>功能</th></tr></thead><tbody><tr><td align="left"><strong>void</strong> <strong>HAL_NVIC_SetPriorityGrouping</strong>(uint32_t PriorityGroup);</td><td>设置4位二进制数的优先级分组策略</td></tr><tr><td align="left"><strong>void</strong> <strong>HAL_NVIC_SetPriority</strong>(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);</td><td>设置某个中断的抢占优先级和此优先级</td></tr><tr><td align="left"><strong>void</strong> <strong>HAL_NVIC_EnableIRQ</strong>(IRQn_Type IRQn);</td><td>启用某个中断</td></tr><tr><td align="left"><strong>void</strong> <strong>HAL_NVIC_DisableIRQ</strong>(IRQn_Type IRQn);</td><td>禁用某个中断</td></tr><tr><td align="left">uint32_t <strong>HAL_NVIC_GetPriorityGrouping</strong>(<strong>void</strong>);</td><td>返回当前的优先级分组策略</td></tr><tr><td align="left"><strong>void</strong> <strong>HAL_NVIC_GetPriority</strong>(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority);</td><td>返回某个中断的抢占优先级、次优先级数值</td></tr><tr><td align="left">uint32_t <strong>HAL_NVIC_GetPendingIRQ</strong>(IRQn_Type IRQn);</td><td>检查某个中断是否被挂起</td></tr><tr><td align="left"><strong>void</strong> <strong>HAL_NVIC_SetPendingIRQ</strong>(IRQn_Type IRQn);</td><td>设置某个中断的挂起标志，表示发生了中断</td></tr><tr><td align="left"><strong>void</strong> <strong>HAL_NVIC_ClearPendingIRQ</strong>(IRQn_Type IRQn);</td><td>清除某个中断挂起标志</td></tr></tbody></table> 
<h3><a id="5_EXTI_115"></a>5. 外部中断EXTI</h3> 
<p>外部中断（External Interrupt，通常称为EXTI）在STM32F4系列微控制器中是一个重要的功能，它允许外部事件（例如按键、传感器输入等）引发处理器的中断。STM32F4通过外部中断线（External Interrupt Lines）来处理外部事件，而这些中断线可以与GPIO引脚相连。外部I/O端口的电平可以有三种触发中断的方式：上升沿、下降沿和双边沿触发，如下图所示：</p> 
<h5><a id="STM32F4EXTI_119"></a>STM32F4的外部中断EXTI的特点：</h5> 
<ol><li><strong>支持多个外部中断线</strong>： STM32F4具有多个外部中断线，每个中断线可以连接到特定的GPIO引脚。</li><li><strong>多种触发方式</strong>： EXTI可以配置为触发不同的边沿或状态，例如上升沿触发、下降沿触发、上升和下降沿触发、低电平触发、高电平触发等。</li><li><strong>中断优先级</strong>： EXTI也可以配置其优先级，允许在多个中断发生时确定哪个中断应该首先被处理。</li><li><strong>软件和硬件触发</strong>： 可以通过软件手动触发外部中断，也可以通过外部引脚的电平或边沿触发中断。</li></ol> 
<p><img src="https://images2.imgbox.com/7c/77/q0fM2z2h_o.png" alt="image-20231231181514810"></p> 
<p>其原理如下图所示，外部中断是由外部I/O端口产生中断触发，单片机内核中止当前工作，并处理中断。这时就进入了中间部分，这里包括了“CPU参与”方框部分，有CPU进行参与。在中断模式下，CPU参与处理中断服务函数，进而点亮LED灯。</p> 
<p><img src="https://images2.imgbox.com/46/e9/UWw2hIVX_o.png" alt="image-20240101233255207"></p> 
<p>STM32F407有23个外部中断，每个输入线都可以单独配置触发事件，如上跳沿触发、下跳沿触发或双边沿触发。每个EXTI中断可以单独屏蔽，有独立的中断标志，可以单独清除或保持其中断标志。如下图所示，是外部有信号从右边输入线输入，通过边缘检测电路，判断其中断标志位，进而一步步输送到NVIC中断控制器中。</p> 
<p><img src="https://images2.imgbox.com/3d/5b/t7S6E61f_o.png" alt="image-20231231181535941"></p> 
<p>​ STM32F407有23个外部中断，每个输入线都可以单独配置触发事件，其中EXTI0至EXTI4的每个中断有独立的ISR，EXTI线[9:5]中断共用一个中断号，也就是共用ISR，EXTI线[15:10]中断也共用ISR，见下表所示。若共用的ISR，需要在ISR里在判断具体是哪个EXTI线产生的中断，然后做相应处理。</p> 
<p>另外7个EXTI线连接的不是某个实际的GPIO引脚，二十其他外设产生的事件信号。这7个EXTI线的中断有单独的ISR：</p> 
<ul><li>EXTI线16连接PVD输出；</li><li>EXTI线17连接RTC闹钟事件；</li><li>EXTI线18连接USB OTG FS唤醒事件；</li><li>EXTI线19连接以太网唤醒事件；</li><li></ul> 
<p><img src="https://images2.imgbox.com/88/d8/CBkrVkhA_o.png" alt="image-20240102080839382"></p> 
<h3><a id="6_STM32_CubeMX_156"></a>6. STM32 CubeMX配置实战</h3> 
<h5><a id="1__158"></a>1. 环境准备</h5> 
<ol><li>正点原子探索者 V2 (STM32F407ZGT6)</li><li>STM32CubeMX 6.2.0</li><li>STM32CubeIDE 1.14.0</li><li>ST-Link V2</li></ol> 
<h5><a id="2__165"></a>2. 硬件配置</h5> 
<p>从正点原子的原理图中，选择4个按键，2个LED灯作为本次实验的对象，用4个按键来控制2个LED灯实现不同功能的开关LED灯的效果。</p> 
<p><img src="https://images2.imgbox.com/b9/6d/1Rnz6Tmc_o.png" alt="image-20231214223415136"></p> 
<p>下图所示是4个按键KEY和LED对应的原理图，及相应的配置功能</p> 
<table><thead><tr><th>名称</th><th>端口</th><th>引脚功能</th><th>特性</th><th>初始电平</th></tr></thead><tbody><tr><td>KeyUp（WK_UP）</td><td>PA0</td><td>GPIO_EXTI0</td><td>Pull-down 下拉</td><td>N/A</td></tr><tr><td>KeyLeft（KEY2）</td><td>PE2</td><td>GPIO_EXTI2</td><td>Pull-up 上拉</td><td>N/A</td></tr><tr><td>KeyDown（KEY1）</td><td>PE3</td><td>GPIO_EXTI3</td><td>Pull-up 上拉</td><td>N/A</td></tr><tr><td>KeyRight（KEY0）</td><td>PE4</td><td>GPIO_EXTI4</td><td>Pull-up 上拉</td><td>N/A</td></tr><tr><td>LED1</td><td>PF9</td><td>Output</td><td>Pushpull推挽输出，</td><td>初始低电平</td></tr><tr><td>LED2</td><td>PF10</td><td>Output</td><td>Pushpull推挽输出，</td><td>初始低电平</td></tr></tbody></table> 
<p><img src="https://images2.imgbox.com/af/ea/7S8YtnmR_o.png" alt="image-20231214223643623"></p> 
<p><img src="https://images2.imgbox.com/d3/59/fC4xtZQ5_o.png" alt="image-20231214223745496"></p> 
<p><img src="https://images2.imgbox.com/a5/0c/IcZclwCh_o.png" alt="image-20231214224526507"></p> 
<p><img src="https://images2.imgbox.com/bd/16/H3P7ZRx8_o.png" alt="image-20231214224538399"></p> 
<h5><a id="3_CubeMX_194"></a>3. CubeMX配置</h5> 
<ol><li>按上一节的配置，我们GPIO的名字改为 “上下左右” 命名，更符合板子的命名方式</li></ol> 
<p><img src="https://images2.imgbox.com/1a/9b/zXFQhKYn_o.png" alt="image-20231228215158642"></p> 
<ol start="2"><li>将PA0端口改为GPIO_EXTI0，由外部中断来进行信号输入时的采集，如果是采集到的信号是设定的信号，（例如：上升沿或下降沿等），则会进入相应的中断中</li></ol> 
<p><img src="https://images2.imgbox.com/45/76/a74SOQm7_o.png" alt="image-20231228220031603"></p> 
<ol start="3"><li>同理剩下三个按键都改为GPIO_EXTIx的中断采集信号模式</li></ol> 
<p><img src="https://images2.imgbox.com/81/74/leLUEZ9E_o.png" alt="image-20231228220407150"></p> 
<ol start="4"><li>根据实际硬件原理图，将Key按键的GPIO端口设置为外部上升沿/下降沿触发</li></ol> 
<p><img src="https://images2.imgbox.com/f8/09/Pi8fG60T_o.png" alt="image-20231228221447267"></p> 
<ol start="5"><li>GPIO mode如下图所示</li></ol> 
<p><img src="https://images2.imgbox.com/50/4c/NdlMAQmc_o.png" alt="image-20231228220940924"></p> 
<ol start="6"><li>GPIO端口内部上下拉电阻选择</li></ol> 
<p><img src="https://images2.imgbox.com/b4/0c/DVsmYNsy_o.png" alt="image-20231228221003436"></p> 
<ol start="7"><li>按照下图所示选择相应的上升沿/下降沿的中断触发方式</li></ol> 
<p><img src="https://images2.imgbox.com/71/52/u6KHj4uv_o.png" alt="image-20240103075153650"></p> 
<ol start="8"><li>设置抢占优先级和非抢占优先级，并使能GPIO EXTI外部中断</li></ol> 
<p><img src="https://images2.imgbox.com/4e/c5/MZsQtRrx_o.png" alt="image-20231228222451066"></p> 
<p>注：4个GPIO的中断禁止设置成0，由于代码编写时用到了Systick系统时钟，系统时钟计时是靠这个中断来产生1ms的精准定时，如果4个GPIO设置成0，则会导致Systick计时被抢占，导致陷入HAL_Delay()的死循环中，无法出来</p> 
<p><img src="https://images2.imgbox.com/c6/68/bxk3d72S_o.png" alt="image-20231228222947257"></p> 
<ol start="9"><li>设置RCC时钟</li></ol> 
<p><img src="https://images2.imgbox.com/01/af/wVcR2hY8_o.png" alt="image-20231229081611163"></p> 
<ol start="10"><li>调试口本例中选用ST-Link，则选择JTAG（4 PIN）<img src="https://images2.imgbox.com/fa/70/2aU7cV0N_o.png" alt="image-20231215081805184"></li><li>进行时钟树配置，外部晶振为8M，时钟主频为168MHz</li></ol> 
<p><img src="https://images2.imgbox.com/ed/11/pJF0xoof_o.png" alt="image-20231229081730771"></p> 
<ol start="12"><li>Project Manager 配置，工具链选择STM32CubeIDE</li></ol> 
<p><img src="https://images2.imgbox.com/66/e0/5dvs7rDC_o.png" alt="image-20231229081935547"></p> 
<ol start="13"><li>代码生成配置</li></ol> 
<p><img src="https://images2.imgbox.com/b4/19/14XeDXvj_o.png" alt="image-20231229082016245"></p> 
<ol start="14"><li>点击右上角<strong>生成代码</strong></li></ol> 
<p><img src="https://images2.imgbox.com/69/09/T96ZlVEs_o.png" alt="image-20231229082146613"></p> 
<h3><a id="7_CubeIDE_269"></a>7. CubeIDE编程实战</h3> 
<h5><a id="71___271"></a>7.1 主程序</h5> 
<p>我们在CubeMX中配置完成后生成CubeIDE项目的代码，然后在CubeIDE中贷款刚生成的代码。</p> 
<p>所生成的代码已经完成了GPIO引脚的初始化，包括外部中断的初始化配置，还生成了外部中断ISR的代码框架。</p> 
<p>文件main.c中的主程序代码如下图所示，他调用了函数MX_GPIO_Init()进行GPIO引脚的初始化：</p> 
<pre><code class="prism language-c"><span class="token comment">/* Includes ------------------------------------------------------------------*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"main.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"gpio.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN 1 */</span>

  <span class="token comment">/* USER CODE END 1 */</span>

  <span class="token comment">/* MCU Configuration--------------------------------------------------------*/</span>

  <span class="token comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN Init */</span>

  <span class="token comment">/* USER CODE END Init */</span>

  <span class="token comment">/* Configure the system clock */</span>
  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN SysInit */</span>

  <span class="token comment">/* USER CODE END SysInit */</span>

  <span class="token comment">/* Initialize all configured peripherals */</span>
  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN 2 */</span>

  <span class="token comment">/* USER CODE END 2 */</span>

  <span class="token comment">/* Infinite loop */</span>
  <span class="token comment">/* USER CODE BEGIN WHILE */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/* USER CODE END WHILE */</span>

    <span class="token comment">/* USER CODE BEGIN 3 */</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE END 3 */</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>HAL_Init()函数用于HAL初始化，在CubeMX中设置的中断优先级分组策略是在这个函数里用代码实现的。HAL_Init()调用了一个弱函数HAL_MspInit()，在CubeMX生成的代码中有一个文件stm32f4xx_hal_msp.c，在这个文件里重新实现了函数<strong>HAL_MspInit</strong>()，其代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">/**
  * Initializes the Global MSP.
  */</span>
<span class="token keyword">void</span> <span class="token function">HAL_MspInit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN MspInit 0 */</span>

  <span class="token comment">/* USER CODE END MspInit 0 */</span>

  <span class="token function">__HAL_RCC_SYSCFG_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">__HAL_RCC_PWR_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">HAL_NVIC_SetPriorityGrouping</span><span class="token punctuation">(</span>NVIC_PRIORITYGROUP_2<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* System interrupt init*/</span>

  <span class="token comment">/* USER CODE BEGIN MspInit 1 */</span>

  <span class="token comment">/* USER CODE END MspInit 1 */</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们在CubeMX中为LED和按键的引脚都定义了用户标签，因此文件main.h中生成了这些引脚的引脚号、端口的宏定义，并且对于4个外部中断引脚，还有中断号的宏定义，全部定义如下：</p> 
<pre><code class="prism language-c"><span class="token comment">/* Private defines -----------------------------------------------------------*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KeyRight_Pin</span> <span class="token expression">GPIO_PIN_2</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KeyRight_GPIO_Port</span> <span class="token expression">GPIOE</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KeyRight_EXTI_IRQn</span> <span class="token expression">EXTI2_IRQn</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KeyDown_Pin</span> <span class="token expression">GPIO_PIN_3</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KeyDown_GPIO_Port</span> <span class="token expression">GPIOE</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KeyDown_EXTI_IRQn</span> <span class="token expression">EXTI3_IRQn</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KeyLeft_Pin</span> <span class="token expression">GPIO_PIN_4</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KeyLeft_GPIO_Port</span> <span class="token expression">GPIOE</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KeyLeft_EXTI_IRQn</span> <span class="token expression">EXTI4_IRQn</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED1_Pin</span> <span class="token expression">GPIO_PIN_9</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED1_GPIO_Port</span> <span class="token expression">GPIOF</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED2_Pin</span> <span class="token expression">GPIO_PIN_10</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED2_GPIO_Port</span> <span class="token expression">GPIOF</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KeyUp_Pin</span> <span class="token expression">GPIO_PIN_0</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KeyUp_GPIO_Port</span> <span class="token expression">GPIOA</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KeyUp_EXTI_IRQn</span> <span class="token expression">EXTI0_IRQn</span></span>
</code></pre> 
<h5><a id="72_GPIOEXTI_371"></a>7.2. GPIO和EXTI中断初始化</h5> 
<p>文件gpio.c中的函数MX_GPIO_Init()实现了GPIO引脚和EXTI中断的初始化，代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">/** Configure pins as
        * Analog
        * Input
        * Output
        * EVENT_OUT
        * EXTI
*/</span>
<span class="token keyword">void</span> <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

  GPIO_InitTypeDef GPIO_InitStruct <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">/* GPIO Ports Clock Enable */</span>
  <span class="token function">__HAL_RCC_GPIOE_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">__HAL_RCC_GPIOF_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">__HAL_RCC_GPIOH_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">__HAL_RCC_GPIOA_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">__HAL_RCC_GPIOB_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/*Configure GPIO pin Output Level */</span>
  <span class="token function">HAL_GPIO_WritePin</span><span class="token punctuation">(</span>GPIOF<span class="token punctuation">,</span> LED1_Pin<span class="token operator">|</span>LED2_Pin<span class="token punctuation">,</span> GPIO_PIN_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/*Configure GPIO pins : PEPin PEPin PEPin */</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Pin <span class="token operator">=</span> KeyRight_Pin<span class="token operator">|</span>KeyDown_Pin<span class="token operator">|</span>KeyLeft_Pin<span class="token punctuation">;</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Mode <span class="token operator">=</span> GPIO_MODE_IT_FALLING<span class="token punctuation">;</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Pull <span class="token operator">=</span> GPIO_PULLUP<span class="token punctuation">;</span>
  <span class="token function">HAL_GPIO_Init</span><span class="token punctuation">(</span>GPIOE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/*Configure GPIO pins : PFPin PFPin */</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Pin <span class="token operator">=</span> LED1_Pin<span class="token operator">|</span>LED2_Pin<span class="token punctuation">;</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Mode <span class="token operator">=</span> GPIO_MODE_OUTPUT_PP<span class="token punctuation">;</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Pull <span class="token operator">=</span> GPIO_NOPULL<span class="token punctuation">;</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Speed <span class="token operator">=</span> GPIO_SPEED_FREQ_LOW<span class="token punctuation">;</span>
  <span class="token function">HAL_GPIO_Init</span><span class="token punctuation">(</span>GPIOF<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/*Configure GPIO pin : PtPin */</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Pin <span class="token operator">=</span> KeyUp_Pin<span class="token punctuation">;</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Mode <span class="token operator">=</span> GPIO_MODE_IT_RISING<span class="token punctuation">;</span>
  GPIO_InitStruct<span class="token punctuation">.</span>Pull <span class="token operator">=</span> GPIO_PULLDOWN<span class="token punctuation">;</span>
  <span class="token function">HAL_GPIO_Init</span><span class="token punctuation">(</span>KeyUp_GPIO_Port<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* EXTI interrupt init*/</span>
  <span class="token function">HAL_NVIC_SetPriority</span><span class="token punctuation">(</span>EXTI0_IRQn<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">HAL_NVIC_EnableIRQ</span><span class="token punctuation">(</span>EXTI0_IRQn<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">HAL_NVIC_SetPriority</span><span class="token punctuation">(</span>EXTI2_IRQn<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">HAL_NVIC_EnableIRQ</span><span class="token punctuation">(</span>EXTI2_IRQn<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">HAL_NVIC_SetPriority</span><span class="token punctuation">(</span>EXTI3_IRQn<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">HAL_NVIC_EnableIRQ</span><span class="token punctuation">(</span>EXTI3_IRQn<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">HAL_NVIC_SetPriority</span><span class="token punctuation">(</span>EXTI4_IRQn<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">HAL_NVIC_EnableIRQ</span><span class="token punctuation">(</span>EXTI4_IRQn<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>这个函数前半部分是对LED和按键GPIO引脚的初始化设置，函数代码的后半部分是对4个外部中断的设置，主要是设置中断的优先级和开启中断，用到了函数HAL_NVIC_SetPriority()和HAL_NVIC_EnableIRQ()。</p> 
<h5><a id="73_EXTIISR_435"></a>7.3 EXTI中断的ISR</h5> 
<p>EXTI0到EXTI4都有独立的ISR，在文件stm32f4xx_it.c中自动生成了这4个ISR的代码框架，代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">/******************************************************************************/</span>
<span class="token comment">/* STM32F4xx Peripheral Interrupt Handlers                                    */</span>
<span class="token comment">/* Add here the Interrupt Handlers for the used peripherals.                  */</span>
<span class="token comment">/* For the available peripheral interrupt handler names,                      */</span>
<span class="token comment">/* please refer to the startup file (startup_stm32f4xx.s).                    */</span>
<span class="token comment">/******************************************************************************/</span>

<span class="token comment">/**
  * @brief This function handles EXTI line0 interrupt.
  */</span>
<span class="token keyword">void</span> <span class="token function">EXTI0_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN EXTI0_IRQn 0 */</span>

  <span class="token comment">/* USER CODE END EXTI0_IRQn 0 */</span>
  <span class="token function">HAL_GPIO_EXTI_IRQHandler</span><span class="token punctuation">(</span>GPIO_PIN_0<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN EXTI0_IRQn 1 */</span>

  <span class="token comment">/* USER CODE END EXTI0_IRQn 1 */</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
  * @brief This function handles EXTI line2 interrupt.
  */</span>
<span class="token keyword">void</span> <span class="token function">EXTI2_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN EXTI2_IRQn 0 */</span>

  <span class="token comment">/* USER CODE END EXTI2_IRQn 0 */</span>
  <span class="token function">HAL_GPIO_EXTI_IRQHandler</span><span class="token punctuation">(</span>GPIO_PIN_2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN EXTI2_IRQn 1 */</span>

  <span class="token comment">/* USER CODE END EXTI2_IRQn 1 */</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
  * @brief This function handles EXTI line3 interrupt.
  */</span>
<span class="token keyword">void</span> <span class="token function">EXTI3_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN EXTI3_IRQn 0 */</span>

  <span class="token comment">/* USER CODE END EXTI3_IRQn 0 */</span>
  <span class="token function">HAL_GPIO_EXTI_IRQHandler</span><span class="token punctuation">(</span>GPIO_PIN_3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN EXTI3_IRQn 1 */</span>

  <span class="token comment">/* USER CODE END EXTI3_IRQn 1 */</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
  * @brief This function handles EXTI line4 interrupt.
  */</span>
<span class="token keyword">void</span> <span class="token function">EXTI4_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* USER CODE BEGIN EXTI4_IRQn 0 */</span>

  <span class="token comment">/* USER CODE END EXTI4_IRQn 0 */</span>
  <span class="token function">HAL_GPIO_EXTI_IRQHandler</span><span class="token punctuation">(</span>GPIO_PIN_4<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN EXTI4_IRQn 1 */</span>

  <span class="token comment">/* USER CODE END EXTI4_IRQn 1 */</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们在前文分析了外部中断ISR的执行原理，这些ISR追钟都要调用回调函数<strong>HAL_GPIO_EXTI_Callback()</strong>，因此用户需要重新实现这个回调函数，实现设计功能。</p> 
<h5><a id="74__506"></a>7.4 编写用户功能代码</h5> 
<h6><a id="1__508"></a>1. 重现实现中断回调函数</h6> 
<p>我们要处理外部中断，只需要重新实现回调函数HAL_GPIO_EXTI_Callback()。此外，我们可以在任何一个文件内重新实现这个回调函数（例如在main.c中实现，也可以在gpio.c内实现)，并且无须在头文件中声明其函数原型。</p> 
<p>我们在文件gpio.c中重新实现这个函数，但需要注意，这个函数的代码必须写在一个代码沙箱内。在文件gpio.c中重新实现这个函数的代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">/* USER CODE BEGIN 2 */</span>

<span class="token keyword">void</span> <span class="token function">HAL_GPIO_EXTI_Callback</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> GPIO_Pin<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>GPIO_Pin <span class="token operator">==</span> KeyUp_Pin<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">HAL_GPIO_TogglePin</span><span class="token punctuation">(</span>LED1_GPIO_Port<span class="token punctuation">,</span> LED1_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">HAL_GPIO_TogglePin</span><span class="token punctuation">(</span>LED2_GPIO_Port<span class="token punctuation">,</span> LED2_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>GPIO_Pin <span class="token operator">==</span> KeyRight_Pin<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">HAL_GPIO_TogglePin</span><span class="token punctuation">(</span>LED1_GPIO_Port<span class="token punctuation">,</span> LED1_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>GPIO_Pin <span class="token operator">==</span> KeyLeft_Pin<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">HAL_GPIO_TogglePin</span><span class="token punctuation">(</span>LED2_GPIO_Port<span class="token punctuation">,</span> LED2_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>GPIO_Pin <span class="token operator">==</span> KeyDown_Pin<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">__HAL_GPIO_EXTI_GENERATE_SWIT</span><span class="token punctuation">(</span>GPIO_PIN_0<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token comment">/* USER CODE END 2 */</span>
</code></pre> 
<p>函数的参数GPIO_Pin是触发外部中断的中断线，可用于判断发生了哪个外部中断。函数代码的功能很直观，就是实现一下预想的示例功能：</p> 
<ul><li>按下KeyUp键时，使两个LED灯输出翻转，后面的延时是为了消除按键抖动的影响</li><li>按下KeyRight键时，使LED2输出翻转</li><li>按下KeyLeft键时，使LED1输出翻转</li><li>按下KeyDown键时，产生EXTI0软中断，模拟KeyUp键按下</li></ul> 
<h6><a id="2_HAL_GPIO_EXTI_IRQHandler_553"></a>2. 改写函数HAL_GPIO_EXTI_IRQHandler()的代码</h6> 
<p>完成回调函数代码后，我们就可以构建项目，并将其下载到开发板上进行测试了。但是运行时，按键按下后的响应不如预期，，例如按下KeyUp按键后，两个LED会亮灭两次，虽然加了延时进行消抖处理，但是还是有按键抖动的影响。分析后发现，这是由ISR中调用的外部中断通用处理函数HAL_GPIO_EXTI_IRQHandler()的代码引起的，这个函数的代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">/**
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin Specifies the pins connected EXTI line
  * @retval None
  */</span>
<span class="token keyword">void</span> <span class="token function">HAL_GPIO_EXTI_IRQHandler</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> GPIO_Pin<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* EXTI line interrupt detected */</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">__HAL_GPIO_EXTI_GET_IT</span><span class="token punctuation">(</span>GPIO_Pin<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">__HAL_GPIO_EXTI_CLEAR_IT</span><span class="token punctuation">(</span>GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_GPIO_EXTI_Callback</span><span class="token punctuation">(</span>GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>他检测到中断挂起标志后，先清除了中断挂起标志，然后再执行回调函数。一般的中断通用函数都是这样的处理流程，是为了硬件能够及时响应下一次中断。但是对于检测按键输入的外部中断，这是有问题的，因为清除中断挂起标志位后，按键的抖动就会触发下一次中断，并将中断挂起标志位置位，就会在执行一次回调函数。</p> 
<p>所以对于外部输入的中断按键检测，需要修改一下HAL_GPIO_EXTI_IRQHandler()的代码，将清除中断挂起标志位的功能放到后面，先执行回调函数，进行相应的按键功能检测，然后在清除中断标志位，所以修改的代码如下所示，这样，代码就没有问题了：</p> 
<pre><code class="prism language-c"><span class="token comment">/**
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin Specifies the pins connected EXTI line
  * @retval None
  */</span>
<span class="token keyword">void</span> <span class="token function">HAL_GPIO_EXTI_IRQHandler</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> GPIO_Pin<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token comment">/* EXTI line interrupt detected */</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">__HAL_GPIO_EXTI_GET_IT</span><span class="token punctuation">(</span>GPIO_Pin<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>

    <span class="token function">HAL_GPIO_EXTI_Callback</span><span class="token punctuation">(</span>GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">__HAL_GPIO_EXTI_CLEAR_IT</span><span class="token punctuation">(</span>GPIO_Pin<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是要注意，函数HAL_GPIO_EXTI_IRQHandler()时文件stm32f4xx_hal_gpio.c中HAL驱动的原始文件，这个函数里面没有代码沙箱。修改这个函数后，在CubeMX重新生成代码时，这个函数又变回原来的样子。所以，在使用CubeMX时，用户一定要将代码写在沙箱内，如果实在要修改HAL的原始代码，在CubeMX重新生成代码后又会还原回去，要记得再次该回去。</p> 
<h3><a id="8__601"></a>8. 代码开源</h3> 
<h6><a id="STM32_CubeMX_NVIC_httpsdownloadcsdnnetdownloadqq_3505776688694009_603"></a>工程代码地址：<a href="https://download.csdn.net/download/qq_35057766/88694009">STM32 CubeMX 中断NVIC 实战–源码</a></h6> 
<h6><a id="_605"></a>如果积分不够的朋友，点波关注，评论区留下邮箱，作者无偿提供代码和问题解答。欢迎大家关注和交流</h6>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d13f11783465fb40560e87d8ff252a49/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【AI】一文读懂大模型套壳——神仙打架？软饭硬吃？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5387eabb3c85a356a6316ca6875b19be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决printf无法打印输出的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>