<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java基础之线程安全问题以及线程安全集合类 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java基础之线程安全问题以及线程安全集合类" />
<meta property="og:description" content="线程安全问题 当多个线程同时访问同一个临界资源时,原子操作可能被破坏,会导致数据丢失, 就会触发线程安全问题
临界资源: 被多个线程同时访问的对象
原子操作: 线程访问临界资源的过程中不可更改和缺失的操作
互斥锁 每个对象都默认拥有互斥锁, 该锁默认不开启.
当开启互斥锁之后,线程想要访问对象,则在需要拥有时间片的基础上也拥有锁标记,锁标记只能被一个线程拥有,拥有时间片和锁标记的线程才能执行自身内容,在此期间,其他线程只能等正在执行的线程执行结束释放锁标记和时间片之后才能进入就绪状态
synchronized: 开启互斥锁的关键字
同步方法 思路: 在被线程同时访问的方法上加锁
访问修饰符 synchronized 返回值类型 方法名(参数列表){ } package com.by.util; ​ import java.util.ArrayList; import java.util.List; ​ /** * 工具类-操作集合属性 */ public class MyList { private List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); ​ /** * 给集合属性添加元素 * @param n 添加的元素值 synchronized: 同步方法 */ public synchronized void insert(int n){ list.add(n); } /** * 查看集合内容 */ public void query(){ System.out.println(&#34;集合长度: &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7852fd7cd39beb3ebd84444c68f35682/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-15T15:03:11+08:00" />
<meta property="article:modified_time" content="2024-01-15T15:03:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java基础之线程安全问题以及线程安全集合类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>线程安全问题</h3> 
<ul><li> <p>当多个线程同时访问同一个临界资源时,原子操作可能被破坏,会导致数据丢失, 就会触发线程安全问题</p> 
  <ul><li> <p>临界资源: 被多个线程同时访问的对象</p> </li><li> <p>原子操作: 线程访问临界资源的过程中不可更改和缺失的操作</p> </li></ul></li></ul> 
<h4>互斥锁</h4> 
<ul><li> <p>每个对象都默认拥有互斥锁, 该锁默认不开启.</p> </li><li> <p>当开启互斥锁之后,线程想要访问对象,则在需要拥有时间片的基础上也拥有锁标记,锁标记只能被一个线程拥有,拥有时间片和锁标记的线程才能执行自身内容,在此期间,其他线程只能等正在执行的线程执行结束释放锁标记和时间片之后才能进入就绪状态</p> </li><li> <p>synchronized: 开启互斥锁的关键字</p> </li></ul> 
<h5>同步方法</h5> 
<ul><li> <p>思路: 在被线程同时访问的方法上加锁</p> 
  <blockquote> 
   <pre>访问修饰符 synchronized 返回值类型 方法名(参数列表){   

  }
</pre> 
  </blockquote> <pre><code class="hljs">package com.by.util;
​
import java.util.ArrayList;
import java.util.List;
​
/**
 * 工具类-操作集合属性
 */
public class MyList {
    private List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
​
    /**
     * 给集合属性添加元素
     * @param n 添加的元素值
     synchronized: 同步方法
     */
    public synchronized void insert(int n){
        list.add(n);
    }
    /**
     * 查看集合内容
     */
    public void query(){
        System.out.println("集合长度: " + list.size());
        for (int i = 0; i &lt; list.size(); i++) {
            System.out.print(list.get(i)+"  ");
        }
    }
​
}</code></pre> <p></p> </li></ul> 
<h5>同步代码块</h5> 
<ul><li> <p>思路: 让参与临界资源对象访问的线程自身加锁</p> 
  <blockquote> 
   <pre>synchronized(临界资源对象){    //需要被认定为原子操作的代码 }
</pre> 
  </blockquote> </li><li> <p>使用: 所有访问同一临界资源的线程都需要同时添加同步代码块</p> <pre><code class="hljs">package com.by.test2;
​
import com.by.util.MyList;
​
public class TestMyList {
    public static void main(String[] args)throws Exception {
        //创建两个线程,同时操作工具类,线程1负责往集合中添加元素1-5,线程2负责往集合中添加元素6-10
        //添加结束之后查看集合内容
        //创建工具类对象
        MyList m = new MyList();
        Thread t1=new Thread(()-&gt;{
            for (int i = 1; i &lt;=5 ; i++) {
                synchronized (m) {
                    m.insert(i);
                }
            }
        });
​
        Thread t2=new Thread(()-&gt;{
            for (int i = 6; i &lt;=10 ; i++) {
                synchronized (m) {
                    m.insert(i);
                }
            }
        });
​
        t1.start();
        t2.start();
        //使t1和t2线程先进行添加操作
        t1.join();
        t2.join();
​
        //查看集合元素
        m.query();
    }
}
​</code></pre> <pre>​
/*
* 张三上厕所
* 李四上厕所
*
* 原子操作: 脱裤子--&gt;蹲下来--&gt;上厕所--&gt;擦屁股--&gt;穿裤子--&gt;冲水--&gt;走人
*
*临界资源: 厕所-坑位
*
*解决方式1:给厕所大门加锁
*解决方式2:自己给坑位加锁
* 
*
* */</pre> </li></ul> 
<h5>区别</h5> 
<ol><li> <p>同步方法: 线程执行需要同时争抢时间片和锁标记,写法简单但效率较慢</p> </li><li> <p>同步代码块: 线程只需要争抢时间片, 开启互斥锁的线程默认拥有锁标记, 效率较快但写法相对繁琐</p> </li></ol> 
<h3>线程安全的集合类</h3> 
<blockquote> 
 <p>悲观锁: 悲观的认为集合一定会出现线程安全问题,所以直接加锁</p> 
 <p>乐观锁: 乐观的认为集合一定不会出现线程安全问题,如果安全问题发生,再利用算法解决问题(无锁机制)</p> 
</blockquote> 
<blockquote> 
 <p>JDK5.0,发布了一批无锁机制的线程安全的集合类</p> 
 <p>都来自于java.util.concurrent包</p> 
</blockquote> 
<ol><li> <p>ConcurrentHashMap: CAS算法</p> 
  <blockquote> 
   <p>compare and swap: 比较并交换</p> 
   <p>原有值,预期值,结果值: 当原有值与预期值相等时才会将结果值放入内存</p> 
   <p>int i=1;</p> 
   <p>i++;</p> 
   <p>原有值: 1 预期值: 1 结果值:2</p> 
  </blockquote> </li><li> <p>CopyOnWriteArrayList:</p> 
  <ul><li> <p>当集合进行写(增删改)操作时,会先复制出一个副本,在副本中进行写操作,如果过程中出现线程安全问题,则舍弃当前副本,重新复制新的副本重复操作,直至副本中无异常,再将集合引用地址转换向副本地址,一次确保原集合中一定不会发生安全问题</p> </li><li> <p>特点: 舍弃写的效率提高读的效率,适用于读操作远多于写操作时</p> </li></ul></li><li> <p>CopyOnWriteArraySet:</p> 
  <ul><li> <p>原理与CopyOnWriteArrayList一致, 在写时会对元素进行去重</p> </li></ul></li></ol> 
<h3>掌握</h3> 
<ol><li> <p>什么是线程安全问题?</p> </li><li> <p>如何解决线程安全问题</p> </li><li> <p>同步方法和同步代码块的区别</p> </li><li> <p>线程安全的集合类及原理</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e09073bbf8dab306cb7f0ff8b3bff1b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[RK3399]tc358743芯片的HDMI IN播放视频有电流声</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c6aa1f18529339dba72dd4465d87bad5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">麦讯通：无需API开发，轻松实现电商平台和客服系统连接</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>