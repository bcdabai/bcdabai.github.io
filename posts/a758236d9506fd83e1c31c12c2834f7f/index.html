<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言进阶】你真的懂数据文件吗？一文带你了解什么是数据文件 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C语言进阶】你真的懂数据文件吗？一文带你了解什么是数据文件" />
<meta property="og:description" content="前言: 通过前面的学习，我们已经熟练掌握C语言个语法原理与使用，而今天这篇文章我们将要学习文件操作，来帮助我们更好的处理程序目标要求。
一、文件概述： 1.为什么使用文件： 我们前面学习结构体时，写了通讯录的程序。当我们运行这个程序时，可以给通讯录中增、删、查、改数据，但是此过程所载入的数据是放入内存中的，当我们退出程序时，载入通讯录的数据自然而然就不在了，等下次重新运行通讯录时，又要我们重新输入数据，如果使用这样的通讯录相当于没用。所以，我们的目的便是希望将数据可以保留起来，只有当我们删除的时候，数据才会删除，即尝试将数据持久化。而要实现数据持久化的方式一般有两种：使用数据库将数据存放在本地磁盘文件。
2.什么是文件： 我们通常所说的文件，一般是指存放在我们计算机本地硬盘上的文件。但是在我们的程序设计中，则指的是程序文件和数据文件两种文件（根据文件功能分类）。
①.程序文件：
程序文件主要包括源程序文件，目标文件和可执行程序文件。
源程序文件（后缀为c）：
目标文件(windows环境下后缀为.obj):
可执行文件（Windows环境下后缀为.exe):
②数据文件：
数据文件的内容不一定是程序，而是程序运行过程中所进行读写数据，比如程序运行中需要从中读取的数据，或者程序运行完毕所输出的文件。而我们今天所讨论的，正是这谢谢数据文件的相关操作。
在之前学习中，我们所有的输出，其操作对象都是终端，均是从键盘读取输入内容，并将处理结果输出致我们计算机显示器上进行反馈。而今天我们的目的就是将数据信息输入到我们的本地硬盘上，而当我们想要对数据进行操作时，在从本地硬盘进行读取。
③文件名：
文件跟我们人一样也有自己名字，只不过不叫名字而是文件标识符，而为了方便起见我们常常将这个文件标识符称为文件的文件名.文件名的存在就是为了便于我们进行识别和引用.
一个文件的文件名由三部分组成:文件路径&#43;文件名主干&#43;文件后缀。
以文件名&#34;D:\code\text.txt&#34;为例:
其 文件路径为:&#34;D:\code\&#34;,表示文件存放在硬盘D盘下的code文件夹里面. 文件主干:&#34;text&#34;,表示该文件的文件名为text. 文件后缀:&#34;.txt&#34;,表示该文件的文件类型是文本. 二、文件顺序读写: 文件的打开和关闭： 我们在使用或操作我们的文件之前，首先需要在我们的程序中将其打开，于是我们来研究文件打开和关闭方式。
①文件指针：
在我们缓冲文件系统中，最关键的一个概念就是“文件类型指针”，我们通常称之为“文件指针”。并且我们要知道，我们使用的每一个文件都在内存中开辟了相应的文件信息区，用于存放该文件的相关信息并且这谢谢信息都保存在一个结构体变量中。
并且这样的结构体类型是有系统声明的，取名为FILE。
例如在vs2013的头文件stdio.h中（非自定义结构体类型）就有该类型的声明：
struct _iobuf { char *_ptr; int _cnt; char *_base; int _flag; int _file; int _charbuf; int _bufsiz; char *_tmpfname; }; typedef struct _iobuf FILE; 使用不同的C语言编译器，FILE类型中所包含的信息可能不完全相同，但是都大同小异。每当我们打开一个本地文件时，系统就会依据我们打开的文件情况自动创建出一个FILE结构的变量，并填充该结构内的信息，其中的过程比较复杂我们无需关系，只需要知道存在这一过程即可。而这个由系统创建出来并填充的FILE结构变量，就是通过一个FILE类型文件指针类型进行调用和维护的。
FILE* p; //定义一个FILE类型的文件指针p； 像这样，我们就能创建出来一个文件指针，而接下来就可以使用这个文件指针p指向某个文件信息区（FILE类型的结构体变量），并通过该文件信息区所保存的信息来访问本地硬盘的文件了。也就是说，我们通过使用文件指针就可以找到与其相关联的文件了。
②文件的打开与关闭：
我们应当在读写文件之前打开文件，并在文件读写结束后关闭文件。同时ANSIC规定，使用fopen（file open）函数来打开文件，用fclose（file close）函数来关闭文件。
fopen使用格式：
FILE* p=fopen（const char* filename，const char* mod） 其中 “const char* filename”指文件名（是字符串）； 其中 “const char* mod”指文件打开模式（也是字符串）； int main() { //打开文件 FILE* p = fopen(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a758236d9506fd83e1c31c12c2834f7f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-06T18:33:56+08:00" />
<meta property="article:modified_time" content="2023-03-06T18:33:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言进阶】你真的懂数据文件吗？一文带你了解什么是数据文件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="">前言:</h2> 
 <p style="text-indent:1.4em;">通过前面的学习，我们已经熟练掌握C语言个语法原理与使用，而今天这篇文章我们将要学习文件操作，来帮助我们更好的处理程序目标要求。</p> 
 <h2 style="">一、文件概述：</h2> 
 <h3 style="">1.为什么使用文件：</h3> 
 <p style="text-indent:1.4em;">我们前面学习结构体时，写了通讯录的程序。当我们运行这个程序时，可以给通讯录中增、删、查、改数据，但是<span class="kdocs-bold" style="font-weight:bold;">此过程所载入的数据是放入内存中的，当我们退出程序时，载入通讯录的数据自然而然就不在了，等下次重新运行通讯录时，又要我们重新输入数据</span>，如果使用这样的通讯录相当于没用。所以，我们的目的便是希望将数据可以保留起来，只有当我们删除的时候，数据才会删除，即<span class="kdocs-bold" style="font-weight:bold;">尝试将数据持久化。</span>而要实现数据持久化的方式一般有两种：<span class="kdocs-bold" style="font-weight:bold;">使用数据库将数据存放在本地磁盘文件。</span></p> 
 <h3 style="">2.什么是文件：</h3> 
 <p style="text-indent:1.4em;">我们通常所说的文件，一般是指存放在我们计算机本地硬盘上的文件。但是在我们的程序设计中，则指的是<span class="kdocs-bold" style="font-weight:bold;">程序文件和数据文件</span>两种文件（根据文件功能分类）。</p> 
 <p style=""><span class="kdocs-color" style="color:#116AF0;">①.程序文件：</span></p> 
 <p style="">程序文件主要包括<span class="kdocs-bold" style="font-weight:bold;">源程序文件</span>，<span class="kdocs-bold" style="font-weight:bold;">目标文件</span>和<span class="kdocs-bold" style="font-weight:bold;">可执行程序文件。</span></p> 
 <p style="">源程序文件（后缀为c）：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1287px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:61.53846%;height:0;"> 
    <img src="https://images2.imgbox.com/f0/bc/JUCLOaDU_o.png" style="margin-left:;display:block;width:1287px;margin-top:-61.53846%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">目标文件(windows环境下后缀为.obj):</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1287px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:61.53846%;height:0;"> 
    <img src="https://images2.imgbox.com/08/0f/xVBLlgnE_o.png" style="margin-left:;display:block;width:1287px;margin-top:-61.53846%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">可执行文件（Windows环境下后缀为.exe):</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1287px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:61.53846%;height:0;"> 
    <img src="https://images2.imgbox.com/6d/e2/QYV7iGKY_o.png" style="margin-left:;display:block;width:1287px;margin-top:-61.53846%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-color" style="color:#116AF0;">②数据文件：</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-color" style="color:#080F17;">数据文件的内容<span class="kdocs-bold" style="font-weight:bold;">不一定是程序，而是程序运行过程中所进行读写数据</span>，比如程序运行中需要从中读取的数据，或者程序运行完毕所输出的文件。</span><span class="kdocs-color" style="color:#C21C13;">而我们今天所讨论的，正是这谢谢数据文件的相关操作。</span></p> 
 <p style="text-indent:1.4em;">在之前学习中，我们所有的输出，其操作对象都是终端，均是从键盘读取输入内容，并将处理结果输出致我们计算机显示器上进行反馈。而<span class="kdocs-bold" style="font-weight:bold;">今天我们的目的就是将数据信息输入到我们的本地硬盘上，而当我们想要对数据进行操作时，在从本地硬盘进行读取。</span></p> 
 <p style=""><span class="kdocs-color" style="color:#116AF0;">③文件名：</span></p> 
 <p style="text-indent:1.4em;">文件跟我们人一样也有自己名字，只不过不叫名字而是文件标识符，而为了方便起见我们常常<span class="kdocs-bold" style="font-weight:bold;">将这个文件标识符称为文件的文件名</span>.文件名的存在就是为了<span class="kdocs-bold" style="font-weight:bold;">便于我们进行识别和引用.</span></p> 
 <p style="text-indent:1.4em;">一个文件的文件名由三部分组成:文件路径+文件名主干+文件后缀。</p> 
 <p style="">以文件名"D:\code\text.txt"为例:</p> 
 <blockquote class="kdocs-blockquote" style="">
   其 
  <span class="kdocs-bold" style="font-weight:bold;">文件路径为:"D:\code\"</span>,表示文件存放在硬盘D盘下的code文件夹里面. 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">文件主干:"text",</span>表示该文件的文件名为text. 
  <br> 
  <span class="kdocs-bold" style="font-weight:bold;">文件后缀:".txt",</span>表示该文件的文件类型是文本. 
 </blockquote> 
 <h2 style="">二、文件顺序读写:</h2> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h3>文件的打开和关闭：</h3></li></ol> 
 <p style="text-indent:1.4em;">我们在<span class="kdocs-bold" style="font-weight:bold;">使用或操作我们的文件之前，首先需要在我们的程序中将其打开，于是我们来研究文件打开和关闭方式。</span></p> 
 <p style=""><span class="kdocs-color" style="color:#116AF0;">①文件指针：</span></p> 
 <p style="text-indent:1.4em;">在我们<span class="kdocs-bold" style="font-weight:bold;">缓冲文件系统中，最关键的一个概念就是“文件类型指针”，</span>我们通常称之为“<span class="kdocs-bold" style="font-weight:bold;">文件指针</span>”。并且我们要知道，<span class="kdocs-bold" style="font-weight:bold;">我们使用的每一个文件都在内存中开辟了相应的文件信息区，用于存放该文件的相关信息并且这谢谢信息都保存在一个结构体变量中。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-color" style="color:#DA326B;">并且这样的结构体类型是有系统声明的，取名为FILE。</span></p> 
 <p style="text-indent:1.4em;">例如在vs2013的头文件stdio.h中（非自定义结构体类型）就有该类型的声明：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
       };
typedef struct _iobuf FILE;</code></pre> 
 <p style="text-indent:1.4em;"><span class="kdocs-bold" style="font-weight:bold;">使用不同的C语言编译器，FILE类型中所包含的信息可能不完全相同，但是都大同小异。</span>每当我们打开一个本地文件时，系统就会<span class="kdocs-bold" style="font-weight:bold;">依据我们打开的文件情况自动创建出一个FILE结构的变量，并填充该结构内的信息，</span><span class="kdocs-color" style="color:#DA326B;">其中的过程比较复杂我们无需关系，只需要知道存在这一过程即可。</span>而这个由系统创建出来并填充的FILE结构变量，就是<span class="kdocs-bold" style="font-weight:bold;">通过一个FILE类型文件指针类型进行调用和维护的。</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">FILE* p;
//定义一个FILE类型的文件指针p；</code></pre> 
 <p style="padding-left:1.4em;">像这样，我们就能<span class="kdocs-color" style="color:#DA326B;">创建出来一个文件指针，</span><span class="kdocs-color" style="color:#080F17;">而接下来就可以<span class="kdocs-bold" style="font-weight:bold;">使用这个文件指针p指向某个文件信息区（FILE类型的结构体变量）</span>，<span class="kdocs-bold" style="font-weight:bold;">并通过该文件信息区所保存的信息来访问本地硬盘的文件了</span>。也就是说，我们通过使</span><span class="kdocs-color" style="color:#C21C13;">用文件指针就可以找到与其相关联的文件了</span><span class="kdocs-color" style="color:#080F17;">。</span></p> 
 <p style=""><span class="kdocs-color" style="color:#116AF0;">②文件的打开与关闭：</span></p> 
 <p style="text-indent:1.4em;">我们应当在<span class="kdocs-bold" style="font-weight:bold;">读写文件之前打开文件</span>，并在文件读写结束后关闭文件。同时<span class="kdocs-bold" style="font-weight:bold;">ANSIC规定，</span>使用<span class="kdocs-bold" style="font-weight:bold;">fopen（file open）函数来打开文件，用fclose（file close）函数来关闭文件。</span></p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">fopen使用格式：</span></p> 
 <blockquote class="kdocs-blockquote" style="">
   FILE* p=fopen（const char* filename，const char* mod） 
  <br>其中 
  <span class="kdocs-bold" style="font-weight:bold;">“const char* filename”指文件名（是字符串）；</span> 
  <br>其中 
  <span class="kdocs-bold" style="font-weight:bold;">“const char* mod”指文件打开模式（也是字符串）；</span> 
 </blockquote> 
 <pre class="kdocs-cpp"><code class="language-cpp">int main()
{
    //打开文件
    FILE* p = fopen("D:\\code\\text.txt", "r");
    //以“r”，即只读模式打开文件：d:\\code\\test.txt
    //这里我写的是绝对路径，还有一种是相对路径，也就是相对于这个代码的路径
    if (p == NULL)
    {
        perror("fopen");
        return 0;
    }
    printf("打开文件成功");
}</code></pre> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">fclose函数使用格式：</span></p> 
 <blockquote class="kdocs-blockquote" style="">
   int fclose ( FILE * stream ); “FILE * stream”指的是 
  <span class="kdocs-bold" style="font-weight:bold;">指向想要关闭的文件的文件指针</span> 
 </blockquote> 
 <pre class="kdocs-cpp"><code class="language-cpp">int main()
{
    //打开文件
    FILE* p = fopen("D:\\code\\text.txt", "r");
    //以“r”，即只读模式打开文件：d:\\code\\test.txt
    //这里我写的是绝对路径，还有一种是相对路径，也就是相对于这个代码的路径
    if (p == NULL)
    {
        perror("fopen");
        return 0;
    }
    printf("打开文件成功");
    fclose(p);
    p=NULL;
    if(p==NULL);
    {
        printf("关闭成功");
    }
    resturn 0;
}</code></pre> 
 <p style=""><span class="kdocs-color" style="color:#116AF0;">③文件打开模式：</span></p> 
 <blockquote class="kdocs-blockquote" style="">
   文件使用方式 含义 如果指定文件不存在 “r”（只读） 为了输入数据，打开一个已经存在的文本文件 出错 “w”（只写） 为了输出数据，打开一个文本文件 建立一个新的文件 “a” （追加） 向文本文件尾添加数据 建立一个新的文件 “rb”（只读） 为了输入数据，打开一个二进制文件 出错 “wb“ （只写） 为了输出数据，打开一个二进制文件 建立一个新的文件 “ab”（追加） 向一个二进制文件尾添加数据 出错 “r+”（读写） 为了读和写，打开一个文本文件 出错 “w+”（读写） 为了读和写，建议一个新的文件 建立一个新的文件 “a+”（读写） 打开一个文件，在文件尾进行读写 建立一个新的文件 “rb+”（读写） 为了读和写打开一个二进制文件 出错 “wb+”（读写） 为了读和写，新建一个新的二进制文件 建立一个新的文件 “ab+”（读写） 打开一个二进制文件，在文件尾进行读和写 建立一个新的文件 
 </blockquote> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h3>文件的顺序读写</h3></li></ol> 
 <p style="text-indent:1.4em;">首先我们先来看看都有什么文件读写的函数：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:887px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:47.914318%;height:0;"> 
    <img src="https://images2.imgbox.com/0a/56/ZgZnJ37z_o.png" style="margin-left:;display:block;width:887px;margin-top:-47.914318%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="text-indent:1.4em;">这里面其中比较常用的就是<span class="kdocs-bold" style="font-weight:bold;">fputc函数和fgetc函数</span>，我们一般通过<span class="kdocs-bold" style="font-weight:bold;">这两个函数来实现对文件内容的顺序读写。</span></p> 
 <p style="">这两个函数的使用格式：</p> 
 <blockquote class="kdocs-blockquote" style=""> 
  <span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#116AF0;"><span class="kdocs-bold" style="font-weight:bold;">int fputc ( int character, FILE * stream );</span></span></span> 
  <br> 
  <span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-color" style="color:#116AF0;"><span class="kdocs-bold" style="font-weight:bold;">int fgetc ( FILE * stream );</span></span></span> 
 </blockquote> 
 <p style=""><span class="kdocs-color" style="color:#080F17;">我们来看看这两个函数的使用方式，我们先在文本里面的内容：</span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1902px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:58.307045%;height:0;"> 
    <img src="https://images2.imgbox.com/0c/53/IorBi7oF_o.png" style="margin-left:;display:block;width:1902px;margin-top:-58.307045%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">可以看到，现在我们的文本里面没有任何内容，接着我们来使用”写“的模式打开这个文件，并<span class="kdocs-bold" style="font-weight:bold;">使用fputc函数来进行写入</span>：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
    FILE* pf = fopen("D://code//text.txt", "w");
    if (pf == NULL)
    {
        printf("打开失败");
        return 1;
    }
    
    char ch = 'a';
    for (ch = 'a'; ch &lt;= 'z'; ch++)
    {
        fputc(ch,pf);
        //使用fputc顺序写入字符a-z的字符
    }
    fclose(pf);
    pf = NULL;

    
    return 0;
}</code></pre> 
 <p style="text-indent:1.4em;">我们<span class="kdocs-bold" style="font-weight:bold;">等待程序编译运行并完成数据写入之后关闭程序</span>，这时我来看看文件内容是否由改变：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1902px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:58.307045%;height:0;"> 
    <img src="https://images2.imgbox.com/7a/85/Om8kI8ni_o.png" style="margin-left:;display:block;width:1902px;margin-top:-58.307045%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;">我们可以看到text.txt内容已经是我们刚刚要写入的内容了。这一过程有一个要点就是：<span class="kdocs-color" style="color:#C21C13;">一定要用fclose关闭文件，不然文件不会完成写入。</span></p> 
 <p style="text-indent:1.4em;">完成之后，我们再用<span class="kdocs-bold" style="font-weight:bold;">“读”</span>模式打开该文件，并使用fgetc函数来顺序读取该文件中的内容：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int main()
{
    FILE* pf = fopen("D://code//text.txt", "r");
    if (pf == NULL)
    {
        printf("打开失败");
        return 1;
    }
    int ch = fgetc(pf);
    while (ch!=EOF)
    {
        printf("%c\n", ch);
        ch = fgetc(pf);
    }

    
    
    fclose(pf);
    pf = NULL;


    return 0;
}</code></pre> 
 <p style="">程序运行结果：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1470px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.176872%;height:0;"> 
    <img src="https://images2.imgbox.com/77/02/x4AlA0Zd_o.png" style="margin-left:;display:block;width:1470px;margin-top:-52.176872%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">我们可以清楚看到，<span class="kdocs-color" style="color:#C21C13;">我们的程序实现了对文件数据顺序写入和读取</span>。</p> 
 <p style="">并且我们还可以用fputs函数来实现字符串的写入：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int main()
{
    FILE* pf = fopen("D://code//text.txt", "w");
    if (pf == NULL)
    {
        printf("打开失败");
        return 1;
    }
    
    fputs("hello world\n", pf);
    fputs("hehe", pf);
    fclose(pf);
    pf = NULL;
    
    return 0;
}</code></pre> 
 <p style="">同样的，我们也可以使用fgets函数来实现字符串的顺序读写：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int main()
{
    FILE* pf = fopen("D://code//text.txt", "r");
    if (pf == NULL)
    {
        printf("打开失败");
        return 1;
    }
    
    char arr[30] = { 0 };
    //定义字符数组用于存放读取到的字符串；
    fgets(arr, 13, pf);
    //从文件指针p指向文件处，读取最多256个字符，并将数据存放到字符数组arr中
    //该函数为按行读取，读取到换行转义字符\n处主动停止并转行
    printf("%s", arr);
    //想要读取两行就需要使用两次fgets函数
    fgets(arr, 13, pf);
    printf("%s", arr);


    fclose(pf);
    pf = NULL;
    
    return 0;
}</code></pre> 
 <p style="">程序运行结果：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1470px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.176872%;height:0;"> 
    <img src="https://images2.imgbox.com/b6/6f/EGNNKoKO_o.png" style="margin-left:;display:block;width:1470px;margin-top:-52.176872%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;">本文最终目的就是<span class="kdocs-bold" style="font-weight:bold;">结合文本操作将数据保存至本地硬盘中，从而实现对我们通讯录的使用进行优化</span>，于是我们可以<span class="kdocs-color" style="color:#C21C13;">使用fprintf函数实现将结构体变量的内容保存至本地硬盘中：</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">struct Stu
{
    char name[20];
    char sex[10];
    int age;
};
int main()
{
    FILE* pf = fopen("D://code//text.txt", "w");
    if (pf == NULL)
    {
        printf("打开失败");
        return 1;
    }
    
    struct Stu s1 = { "zhangsan","男",12 };
    fprintf(pf, "%s %s %d", s1.name, s1.sex, s1.age);
    //按照%s %s %d的格式将数据s1.name, s1.sex, s1.age写入pf指向的文件
    fclose(pf);
    pf = NULL;
    
    return 0;
}</code></pre> 
 <p style="text-indent:1.4em;"><span class="kdocs-bold" style="font-weight:bold;">等待程序编译运行并完成数据写入之后关闭程序，</span>这时候我们再去看文件内容，就会发现数据已经成功保存了：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1902px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:58.307045%;height:0;"> 
    <img src="https://images2.imgbox.com/34/d0/WW8Jjlvt_o.png" style="margin-left:;display:block;width:1902px;margin-top:-58.307045%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;">同样的，我们也可以用fscanf函数从本地硬盘文件中读取数据：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">struct Stu
{
    char name[20];
    char sex[10];
    int age;
};
int main()
{
    FILE* pf = fopen("D://code//text.txt", "r");
    if (pf == NULL)
    {
        printf("打开失败");
        return 1;
    }
    
    struct Stu s1 = { 0 };
    fscanf(pf, "%s %s %d", s1.name, s1.sex, &amp;(s1.age));
    //按照%s %s %d的格式，从pf指向的文件中将数据读取到s1.name, s1.sex, &amp;(s1.age)中；
    printf("% s % s % d", s1.name, s1.sex, (s1.age));
    fclose(pf);
    pf = NULL;
    
    return 0;
}</code></pre> 
 <p style="">上述代码运行结果：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1470px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.176872%;height:0;"> 
    <img src="https://images2.imgbox.com/f5/66/8nxRIjfz_o.png" style="margin-left:;display:block;width:1470px;margin-top:-52.176872%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h2 style="">三、文件随机读写：</h2> 
 <p style="text-indent:1.4em;">前面我们学习都是顺序读写，但是我们很多时候<span class="kdocs-bold" style="font-weight:bold;">并不是要进行顺序读写，而是进行随机读写</span><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">（伪随机，指不按照顺序依次进行读写）。</span></span></p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h3>fseek函数：</h3></li></ol> 
 <blockquote class="kdocs-blockquote" style="">
   fseek函数的作用是：个人那句文件指针的位置和偏移量来定位文件指针。 
 </blockquote> 
 <p style="">使用格式为：</p> 
 <blockquote class="kdocs-blockquote" style=""> 
  <span class="kdocs-fontSize" style="font-size:9pt;">int fseek ( FILE * stream, long int offset, int origin );</span> 
  <br> 
  <span class="kdocs-fontSize" style="font-size:9pt;">其中<span class="kdocs-bold" style="font-weight:bold;">”offset“为相对于指针位置的指针偏移量；</span></span> 
  <br> 
  <span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">其中“origin”为指针位置，其参数由三种：</span></span> 
  <br> 
  <span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">①"SEEK_CUR"表示文件指针当前位置；</span></span> 
  <br> 
  <span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">②”SEEK_END"表示文件末尾的位置；</span></span> 
  <br> 
  <span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">③”SEEK_SET"表示文件开始位置。</span></span> 
 </blockquote> 
 <p style="">使用示例：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int main()
{
    FILE* pf = fopen("D://code//text.txt", "r+");
    if (pf == NULL)
    {
        printf("打开失败");
        return 1;
    }
        char ch = 'a';
    for (ch = 'a'; ch &lt;= 'z'; ch++)
    {
        fputc(ch,pf);
        //使用fputc顺序写入字符a-z的字符
    }
    
    fseek(pf, 10, SEEK_SET);
    //使用fseek函数将文件指针从文件开始处指向偏移量为10处
    //偏移量为正表示向后移动，未付表示向前便宜

    //接下来进行读写
    char output;
    output = fgetc(pf);
    printf("%c ", output);

    fclose(pf);
    pf = NULL;
    
    return 0;
}</code></pre> 
 <p style="">输出结果：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1470px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.176872%;height:0;"> 
    <img src="https://images2.imgbox.com/8d/b2/7gNm0RYQ_o.png" style="margin-left:;display:block;width:1470px;margin-top:-52.176872%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h3 style="">2.ftell函数：</h3> 
 <blockquote class="kdocs-blockquote" style="">
   ftell函数的作用：返回文件指针相对于文件起始位置的偏移量; 
 </blockquote> 
 <p style="">使用格式为：</p> 
 <blockquote class="kdocs-blockquote" style=""> 
  <span class="kdocs-fontSize" style="font-size:9pt;">long int ftell ( FILE * stream );</span> 
 </blockquote> 
 <p style="">我们可以用上面代码来演示一下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int main()
{
    FILE* pf = fopen("D://code//text.txt", "r+");
    if (pf == NULL)
    {
        printf("打开失败");
        return 1;
    }
        char ch = 'a';
    for (ch = 'a'; ch &lt;= 'z'; ch++)
    {
        fputc(ch,pf);
        //使用fputc顺序写入字符a-z的字符
    }
    
    fseek(pf, 10, SEEK_SET);
    //使用fseek函数将文件指针从文件开始处指向偏移量为10处
    //偏移量为正表示向后移动，未付表示向前便宜

    long int ret=ftell(pf);

    //接下来进行读写
    char output;
    output = fgetc(pf);
    printf("%c ", output);

    printf("%d", ret);

    fclose(pf);
    pf = NULL;
    
    return 0;
}</code></pre> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1470px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.176872%;height:0;"> 
    <img src="https://images2.imgbox.com/e1/ff/TH68epLa_o.png" style="margin-left:;display:block;width:1470px;margin-top:-52.176872%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;">因为我们上面让其偏移了10，所以这时ftell还是返回了10；</p> 
 <h3 style="">3.rewind</h3> 
 <blockquote class="kdocs-blockquote" style="">
   rewind函数的作用是：是文件指针位置返回文件的起始位置； 
 </blockquote> 
 <p style="">使用格式：</p> 
 <blockquote class="kdocs-blockquote" style=""> 
  <span class="kdocs-fontSize" style="font-size:9pt;">void rewind ( FILE * stream );</span> 
 </blockquote> 
 <p style="">我们同样那上面代码来演示：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">struct Stu
{
    char name[20];
    char sex[10];
    int age;
};
int main()
{
    FILE* pf = fopen("D://code//text.txt", "r+");
    if (pf == NULL)
    {
        printf("打开失败");
        return 1;
    }
        char ch = 'a';
    for (ch = 'a'; ch &lt;= 'z'; ch++)
    {
        fputc(ch,pf);
        //使用fputc顺序写入字符a-z的字符
    }
    
    fseek(pf, 10, SEEK_SET);
    //使用fseek函数将文件指针从文件开始处指向偏移量为10处
    //偏移量为正表示向后移动，未付表示向前便宜

    long int ret=ftell(pf);

    //接下来进行读写
    char output;
    output = fgetc(pf);
    printf("%c \n", output);

    printf("第一次返回值：%d\n", ret);

    rewind(pf);
    ret = ftell(pf);
    printf("第二次返回值：%d\n", ret);


    fclose(pf);
    pf = NULL;
    
    return 0;
}</code></pre> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1470px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.176872%;height:0;"> 
    <img src="https://images2.imgbox.com/88/66/V66beDae_o.png" style="margin-left:;display:block;width:1470px;margin-top:-52.176872%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;">因为我们使用rewind函数让pf回到原点所以第二次fseek函数返回值为0；</p> 
 <h2 style="">总结：</h2> 
 <p style="text-indent:1.4em;">经过今天的学习，我们就掌握了程序对本地文件的调用与读写，就可以通过文件操作，实现对本地文件的修改与维护，同时也可以对我们之前的写的通讯录进行优化，这将是我们下章的内容，今天到此就结束啦，祝大家学有所成。</p> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25fcfa9cbf466d59daff46d0a976e554/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安装pyCharm后pip不能用，显示No module named pip如何解决?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f25c2807c39f01560ca88afb2e25c5a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">核心 Android 调节音量的过程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>