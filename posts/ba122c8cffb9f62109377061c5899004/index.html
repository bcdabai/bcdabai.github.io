<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot自动装配原理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot自动装配原理" />
<meta property="og:description" content="springboot自动装配原理 1、springboot自动装配的作用2、springboot怎样做到的自动装配（浅谈自动装配原理）2.1@SpringBootConfiguration2.2@ComponentScan2.3@EnableAutoConfiguration(重点)2.3.1@AutoConfigurationPackage2.3.2@Import({AutoConfigurationImportSelector.class})2.3.3按需开启自动配置项2.3.3.1、aop的自动配置案例 2.3.4如何查看自动配置了哪些呢2.3.4.1自己分析，pom.xml文件引入场景对应的自动配置一般都生效了2.3.4.2application.properties文件中配置debug=true就能在控制台打印出来自动配置报告 1、springboot自动装配的作用 springboot的自动装配实际上就是为了从spring工厂文件中获取到对应的需要进行自动装配的类，并生成相应的Bean对象，然后将它们交给spring容器来帮我们进行管理。
2、springboot怎样做到的自动装配（浅谈自动装配原理） 众所周知，@SpringBootApplication注解标明这个类是主配置类，它是一个组合注解，springboot通过运行这个类里面的main()方法来启动程序。
@SpringBootApplication public class AdminApplication { public static void main(String[] args) { SpringApplication.run(AdminApplication.class, args); } } 这个注解主要由三个子注解组成：
@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 下面我们来逐个讲解
2.1@SpringBootConfiguration j进入到SpringBootConfiguration类中发现，它被@Configuration注解标明，说明其实它就是个配置类
2.2@ComponentScan 指定要扫描哪些包
2.3@EnableAutoConfiguration(重点) 也是一个合成注解
2.3.1@AutoConfigurationPackage 自动配置包
给容器注入Register组件
通过Register给容器导入一系列组件，那么是怎么做到的呢，见下方step分解
step1:
AnnotationMetadata metadata
参数传的是这个注解的源信息，比如这个注解标注在哪里。
step2:
(String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0])
获取到标注的主类的包名
也就是通过registerBeanDefinitions这个方法，将某个包下的所有组件，全部注入进去。MainApplication所在包下。
2.3.2@Import({AutoConfigurationImportSelector.class}) step1：要给容器里面导入哪些，看这个selectImports方法返回的string数组里面有哪些，就导入哪些。
step2:
利用getAutoConfigurationEntry(annotationMetadata)]给容器批量导入组件
List configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
这127个全类名组件就是默认要导入到容器中的。
那么怎么知道这127个组件就是这个导入规则呢？
step3:进入到getCandidateConfigurations方法中，再层层向内进入，最终由loadSpringFactories方法加载得来所有组件。那么究竟是从哪里加载得来这些组件呢，继续往下看
step4：
从&#34;META-INF/spring.factories&#34;位置来加载一个文件，
所以就会默认扫描当前系统下，所有&#34;META-INF/spring.factories&#34;目录下的文件。
并不是所有的包下面都有这个目录，例如：
最核心的是这个包
spring-boot-autoconfigure-2.3.4.RELEASE.jar。那127个需要加载的组件，实际上是在这里写死的。
文件里面写死了，只要springboot一起动，就要给容器加载的类
其实就是在配置文件里面写死了，springboot一起动就要给容器中加载的所有配置类。
step4：虽然127个场景的自动配置springboot一股脑全加载了，但是哪些生效哪些不生效，按照条件装配规则（@Conditional），最终会按需配置，那么接下来就要了解下“按需配置”了。
2.3.3按需开启自动配置项 用两个案例来解释下" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ba122c8cffb9f62109377061c5899004/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-25T07:47:47+08:00" />
<meta property="article:modified_time" content="2023-08-25T07:47:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot自动装配原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>springboot自动装配原理</h4> 
 <ul><li><ul><li><a href="#1springboot_1" rel="nofollow">1、springboot自动装配的作用</a></li><li><a href="#2springboot_4" rel="nofollow">2、springboot怎样做到的自动装配（浅谈自动装配原理）</a></li><li><ul><li><a href="#21SpringBootConfiguration_24" rel="nofollow">2.1@SpringBootConfiguration</a></li><li><a href="#22ComponentScan_27" rel="nofollow">2.2@ComponentScan</a></li><li><a href="#23EnableAutoConfiguration_30" rel="nofollow">2.3@EnableAutoConfiguration(重点)</a></li><li><ul><li><a href="#231AutoConfigurationPackage_34" rel="nofollow">2.3.1@AutoConfigurationPackage</a></li><li><a href="#232ImportAutoConfigurationImportSelectorclass_51" rel="nofollow">2.3.2@Import({AutoConfigurationImportSelector.class})</a></li><li><a href="#233_78" rel="nofollow">2.3.3按需开启自动配置项</a></li><li><ul><li><a href="#2331aop_80" rel="nofollow">2.3.3.1、aop的自动配置案例</a></li></ul> 
     </li><li><a href="#234_103" rel="nofollow">2.3.4如何查看自动配置了哪些呢</a></li><li><ul><li><a href="#2341pomxml_104" rel="nofollow">2.3.4.1自己分析，pom.xml文件引入场景对应的自动配置一般都生效了</a></li><li><a href="#2342applicationpropertiesdebugtrue_105" rel="nofollow">2.3.4.2application.properties文件中配置debug=true就能在控制台打印出来自动配置报告</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1springboot_1"></a>1、springboot自动装配的作用</h3> 
<p>springboot的自动装配实际上就是为了从spring工厂文件中获取到对应的需要进行自动装配的类，并生成相应的Bean对象，然后将它们交给spring容器来帮我们进行管理。</p> 
<h3><a id="2springboot_4"></a>2、springboot怎样做到的自动装配（浅谈自动装配原理）</h3> 
<p>众所周知，@SpringBootApplication注解标明这个类是主配置类，它是一个组合注解，springboot通过运行这个类里面的main()方法来启动程序。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdminApplication</span> <span class="token punctuation">{<!-- --></span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">AdminApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>这个注解主要由三个子注解组成：</p> 
<pre><code>@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan
</code></pre> 
<p><img src="https://images2.imgbox.com/c6/19/Gbp5gbsa_o.png" alt="在这里插入图片描述">下面我们来逐个讲解</p> 
<h4><a id="21SpringBootConfiguration_24"></a>2.1@SpringBootConfiguration</h4> 
<p>j进入到SpringBootConfiguration类中发现，它被@Configuration注解标明，说明其实它就是个配置类<br> <img src="https://images2.imgbox.com/88/03/G2mKxlNl_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="22ComponentScan_27"></a>2.2@ComponentScan</h4> 
<p>指定要扫描哪些包</p> 
<h4><a id="23EnableAutoConfiguration_30"></a>2.3@EnableAutoConfiguration(重点)</h4> 
<p>也是一个合成注解</p> 
<p><img src="https://images2.imgbox.com/f9/a8/6KPu1PKq_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="231AutoConfigurationPackage_34"></a>2.3.1@AutoConfigurationPackage</h5> 
<p>自动配置包<br> 给容器注入Register组件<br> <img src="https://images2.imgbox.com/8b/cf/iT3fgjMA_o.png" alt="在这里插入图片描述"><br> 通过Register给容器导入一系列组件，那么是怎么做到的呢，见下方step分解<br> <img src="https://images2.imgbox.com/ba/57/8Qc2bh2o_o.png" alt="在这里插入图片描述">step1:<br> AnnotationMetadata metadata<br> 参数传的是这个注解的源信息，比如这个注解标注在哪里。<br> <img src="https://images2.imgbox.com/6b/b6/8QqME2eh_o.png" alt="在这里插入图片描述">step2:<br> (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0])<br> 获取到标注的主类的包名</p> 
<p><img src="https://images2.imgbox.com/dd/8a/IhwaZ74P_o.png" alt="在这里插入图片描述"></p> 
<p>也就是通过registerBeanDefinitions这个方法，将某个包下的所有组件，全部注入进去。MainApplication所在包下。</p> 
<h5><a id="232ImportAutoConfigurationImportSelectorclass_51"></a>2.3.2@Import({AutoConfigurationImportSelector.class})</h5> 
<p>step1：要给容器里面导入哪些，看这个selectImports方法返回的string数组里面有哪些，就导入哪些。</p> 
<p><img src="https://images2.imgbox.com/76/5f/vrq1qzuG_o.png" alt="在这里插入图片描述"></p> 
<p>step2:<br> 利用getAutoConfigurationEntry(annotationMetadata)]给容器批量导入组件<br> List configurations = this.getCandidateConfigurations(annotationMetadata, attributes);<br> 这127个全类名组件就是默认要导入到容器中的。<br> 那么怎么知道这127个组件就是这个导入规则呢？<br> <img src="https://images2.imgbox.com/34/5f/dps4sMH1_o.png" alt="在这里插入图片描述">step3:进入到getCandidateConfigurations方法中，再层层向内进入，最终由loadSpringFactories方法加载得来所有组件。那么究竟是从哪里加载得来这些组件呢，继续往下看<br> <img src="https://images2.imgbox.com/1a/3f/BHFzjv6i_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f9/68/Hy0nqtBT_o.png" alt="在这里插入图片描述">step4：<br> 从"META-INF/spring.factories"位置来加载一个文件，<br> 所以就会默认扫描当前系统下，所有"META-INF/spring.factories"目录下的文件。<br> 并不是所有的包下面都有这个目录，例如：<br> <img src="https://images2.imgbox.com/4e/90/wkzbGkmK_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/22/ef/bcjwKbfA_o.png" alt="在这里插入图片描述"></p> 
<p>最核心的是这个包<br> spring-boot-autoconfigure-2.3.4.RELEASE.jar。那127个需要加载的组件，实际上是在这里写死的。<br> 文件里面写死了，只要springboot一起动，就要给容器加载的类<br> <img src="https://images2.imgbox.com/cc/76/VarQenGT_o.png" alt="在这里插入图片描述"><br> 其实就是在配置文件里面写死了，springboot一起动就要给容器中加载的所有配置类。</p> 
<p>step4：虽然127个场景的自动配置springboot一股脑全加载了，但是哪些生效哪些不生效，按照条件装配规则（@Conditional），最终会按需配置，那么接下来就要了解下“按需配置”了。</p> 
<h5><a id="233_78"></a>2.3.3按需开启自动配置项</h5> 
<p>用两个案例来解释下</p> 
<h6><a id="2331aop_80"></a>2.3.3.1、aop的自动配置案例</h6> 
<p>step1:<br> @ConditionalOnProperty(prefix = “spring.aop”, name = “auto”, havingValue = “true”, matchIfMissing = true)<br> 判断配置文件中是否存在spring.aop.auto这个配置，并且它的值是true,那么AopAutoConfiguration这个类里面的代码就会生效。<br> matchIfMissing = true默认为就算用户没把havingValue = "true"配置成true，我也默认是true<br> <img src="https://images2.imgbox.com/d9/1f/04ysUC0u_o.png" alt="在这里插入图片描述">step2:@ConditionalOnClass(Advice.class)<br> 由于Advice这个包没有导入进来，所以AspectJAutoProxyingConfiguration这个类下的方法都没生效。<br> <img src="https://images2.imgbox.com/60/a5/0VLkVEoO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e2/0b/FPjHsNia_o.png" alt="在这里插入图片描述">step3:<br> @ConditionalOnMissingClass(“org.aspectj.weaver.Advice”)<br> @ConditionalOnProperty(prefix = “spring.aop”, name = “proxy-target-class”, havingValue = “true”,matchIfMissing = true)<br> 如果没有配置org.aspectj.weaver.Advice，则会检查spring.aop中是否有proxy-target-class这个配置，matchIfMissing = true即使没有也默认加载<br> <img src="https://images2.imgbox.com/4f/ae/dm1uwNKG_o.png" alt="在这里插入图片描述">step4:可以检查一下容器里面是否有这个组件</p> 
<pre><code class="prism language-java"><span class="token comment">//        返回IOC容器</span>
        <span class="token class-name">ConfigurableApplicationContext</span> run <span class="token operator">=</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">MainApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//        根据类型查看容器里面的组件</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> beanNamesForType <span class="token operator">=</span> run<span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span><span class="token class-name">AopAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"beanNamesForType===&gt;"</span> <span class="token operator">+</span> beanNamesForType<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1b/b3/5ZjBcM3p_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="234_103"></a>2.3.4如何查看自动配置了哪些呢</h5> 
<h6><a id="2341pomxml_104"></a>2.3.4.1自己分析，pom.xml文件引入场景对应的自动配置一般都生效了</h6> 
<h6><a id="2342applicationpropertiesdebugtrue_105"></a>2.3.4.2application.properties文件中配置debug=true就能在控制台打印出来自动配置报告</h6> 
<p><img src="https://images2.imgbox.com/64/53/C0RPls1s_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/568357456bf941004241ded893580de6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">写给前端同学的Nginx配置指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/19ebc3d5b62b90028856f34828c8426c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue-admin-template实现按钮级控制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>