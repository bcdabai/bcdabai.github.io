<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Cloud Alibaba实战之二：OpenFeign的使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Cloud Alibaba实战之二：OpenFeign的使用" />
<meta property="og:description" content="目录
OpenFeign简介
Feign能干什么
Feign和OpenFeign的区别
Spring Cloud Alibaba中OpenFeign的使用
1、OpenFeign简单使用
1.1、新建shop-common子模块
1.2、新建shop-order子模块​编辑添加配置文件
1.3、引入依赖
1.4、在其他模块中引用common公共模块
1.5、 shop-order模块代码
1.6、shop-user模块代码
1.7、启动服务
1.8、通过feign接口访问服务
2、OpenFeign的进阶使用 2.1、openfeign接口添加请求头信息
2.2、fallback的使用 总结
OpenFeign简介 Feign是一个声明式WebService客户端，使用Feign能让编写Web Service客户端更简单
它的使用方法是定义一个服务接口然后在上面添加注解，Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡
Feign能干什么 Feign旨在使编写Java Http客户端变得更容易
前面在使用Ribbon&#43;RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由它来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它（以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign即可），即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量
Feign集成了Ribbon，通过feign只需要定义服务绑定接口并且以声明式的方法，优雅而简单的实现了服务调用
Feign和OpenFeign的区别 Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务
OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequestMaping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMaping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。
Spring Cloud Alibaba中OpenFeign的使用 1、OpenFeign简单使用 前文中已经建立了一个标识店铺用户信息的shop-user模块，本文将新建一个管理店铺订单信息的shop-order模块和公共管理shop-common模块（其中shop-common模块下主要是一些工具类，被shop-common模块和shop-order模块依赖）。这样，我们就可以用两个服务测试feign接口的功能。
1.1、新建shop-common子模块 其中shop-common的引入如下依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.83&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在common中添加工具类，一些字符串操作和非空判断操作。 1.2、新建shop-order子模块" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7cc7f3e7836319d7c88ff04447a53593/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-02T17:38:43+08:00" />
<meta property="article:modified_time" content="2022-10-02T17:38:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Cloud Alibaba实战之二：OpenFeign的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="openfeign简介-toc" style="margin-left:0px;"><a href="#openfeign%E7%AE%80%E4%BB%8B" rel="nofollow">OpenFeign简介</a></p> 
<p id="Feign%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#Feign%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88" rel="nofollow">Feign能干什么</a></p> 
<p id="Feign%E5%92%8COpenFeign%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#Feign%E5%92%8COpenFeign%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">Feign和OpenFeign的区别</a></p> 
<p id="Spring%20Cloud%20Alibaba%E4%B8%ADOpenFeign%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#Spring%20Cloud%20Alibaba%E4%B8%ADOpenFeign%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">Spring Cloud Alibaba中OpenFeign的使用</a></p> 
<p id="1%E3%80%81OpenFeign%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#1%E3%80%81OpenFeign%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8" rel="nofollow">1、OpenFeign简单使用</a></p> 
<p id="%C2%A01.1%E3%80%81%E6%96%B0%E5%BB%BAshop-common%E5%AD%90%E6%A8%A1%E5%9D%97-toc" style="margin-left:80px;"><a href="#%C2%A01.1%E3%80%81%E6%96%B0%E5%BB%BAshop-common%E5%AD%90%E6%A8%A1%E5%9D%97" rel="nofollow">1.1、新建shop-common子模块</a></p> 
<p id="1.2%E3%80%81%E6%96%B0%E5%BB%BAshop-order%E5%AD%90%E6%A8%A1%E5%9D%97%E2%80%8B%E7%BC%96%E8%BE%91%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#1.2%E3%80%81%E6%96%B0%E5%BB%BAshop-order%E5%AD%90%E6%A8%A1%E5%9D%97%E2%80%8B%E7%BC%96%E8%BE%91%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">1.2、新建shop-order子模块​编辑添加配置文件</a></p> 
<p id="1.3%E3%80%81%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96-toc" style="margin-left:80px;"><a href="#1.3%E3%80%81%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96" rel="nofollow">1.3、引入依赖</a></p> 
<p id="1.4%C2%A0%E5%9C%A8%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%BC%95%E7%94%A8common%E5%85%AC%E5%85%B1%E6%A8%A1%E5%9D%97-toc" style="margin-left:80px;"><a href="#1.4%C2%A0%E5%9C%A8%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%BC%95%E7%94%A8common%E5%85%AC%E5%85%B1%E6%A8%A1%E5%9D%97" rel="nofollow">1.4、在其他模块中引用common公共模块</a></p> 
<p id="%C2%A01.5%E3%80%81%20shop-order%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A01.5%E3%80%81%20shop-order%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81" rel="nofollow"> 1.5、 shop-order模块代码</a></p> 
<p id="%C2%A01.6%E3%80%81%20shop-user%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%C2%A01.6%E3%80%81%20shop-user%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81" rel="nofollow"> 1.6、shop-user模块代码</a></p> 
<p id="%C2%A01.7%20%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%C2%A01.7%20%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" rel="nofollow"> 1.7、启动服务</a></p> 
<p id="1.8%E3%80%81%E9%80%9A%E8%BF%87feign%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#1.8%E3%80%81%E9%80%9A%E8%BF%87feign%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1" rel="nofollow">1.8、通过feign接口访问服务</a></p> 
<p id="2%E3%80%81OpenFeign%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%C2%A0-toc" style="margin-left:40px;"><a href="#2%E3%80%81OpenFeign%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%C2%A0" rel="nofollow">2、OpenFeign的进阶使用 </a></p> 
<p id="2.1%20openfeign%E6%8E%A5%E5%8F%A3%E6%B7%BB%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BF%A1%E6%81%AF-toc" style="margin-left:80px;"><a href="#2.1%20openfeign%E6%8E%A5%E5%8F%A3%E6%B7%BB%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BF%A1%E6%81%AF" rel="nofollow">2.1、openfeign接口添加请求头信息</a></p> 
<p id="2.2%E3%80%81fallback%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0-toc" style="margin-left:80px;"><a href="#2.2%E3%80%81fallback%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0" rel="nofollow">2.2、fallback的使用 </a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="openfeign简介">OpenFeign简介</h2> 
<p>Feign是一个声明式WebService客户端，使用Feign能让编写Web Service客户端更简单</p> 
<p>它的使用方法是<strong>定义一个服务接口然后在上面添加注解</strong>，Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡</p> 
<h3 id="Feign%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88"><strong>Feign能干什么</strong></h3> 
<p>Feign旨在使编写Java Http客户端变得更容易</p> 
<p>前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模板化的调用方法。但是<strong>在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用</strong>。所以，Feign在此基础上做了进一步封装，由它来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它（以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign即可），即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量</p> 
<p>Feign集成了Ribbon，通过feign只需要定义服务绑定接口并且以声明式的方法，优雅而简单的实现了服务调用</p> 
<h3 id="Feign%E5%92%8COpenFeign%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>Feign和OpenFeign的区别</strong></h3> 
<p>Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务</p> 
<p>OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequestMaping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMaping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</p> 
<h2></h2> 
<h2 id="Spring%20Cloud%20Alibaba%E4%B8%ADOpenFeign%E7%9A%84%E4%BD%BF%E7%94%A8">Spring Cloud Alibaba中OpenFeign的使用</h2> 
<h2 id="1%E3%80%81OpenFeign%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">1、OpenFeign简单使用</h2> 
<p>前文中已经建立了一个标识店铺用户信息的shop-user模块，本文将新建一个管理店铺订单信息的shop-order模块和公共管理shop-common模块（其中shop-common模块下主要是一些工具类，被shop-common模块和shop-order模块依赖）。这样，我们就可以用两个服务测试feign接口的功能。</p> 
<h4 id="%C2%A01.1%E3%80%81%E6%96%B0%E5%BB%BAshop-common%E5%AD%90%E6%A8%A1%E5%9D%97"> 1.1、新建shop-common子模块</h4> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="484" src="https://images2.imgbox.com/c6/cc/CRiUElP5_o.png" width="1001"></h4> 
<p>其中shop-common的引入如下依赖：</p> 
<pre><code class="language-XML">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
            &lt;version&gt;3.12.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.83&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-codec&lt;/groupId&gt;
            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
            &lt;version&gt;1.15&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre> 
<p>在common中添加工具类，一些字符串操作和非空判断操作。 </p> 
<h4 id="1.2%E3%80%81%E6%96%B0%E5%BB%BAshop-order%E5%AD%90%E6%A8%A1%E5%9D%97%E2%80%8B%E7%BC%96%E8%BE%91%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1.2、新建shop-order子模块<br><img alt="" height="497" src="https://images2.imgbox.com/fb/16/UgYKy25A_o.png" width="988">添加配置文件</h4> 
<p><img alt="" height="605" src="https://images2.imgbox.com/ef/26/8MeDELgD_o.png" width="1138"></p> 
<p>application.yml配置文件</p> 
<pre><code class="language-XML">server:
  port: 9091

spring:
  application:
    name: shop-order
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: alibaba
        group: alibaba
</code></pre> 
<p>bootstrap.properties配置文件</p> 
<pre><code class="language-XML">spring.application.name=shop-order
spring.cloud.nacos.config.server-addr=localhost:8848
spring.cloud.nacos.config.extension-configs[0].data-id=shop-order.yaml
spring.cloud.nacos.config.extension-configs[0].group=alibaba
spring.cloud.nacos.config.extension-configs[0].refresh=true
spring.cloud.nacos.config.file-extension=yml
spring.cloud.nacos.config.namespace=alibaba
spring.cloud.nacos.config.group=alibaba
</code></pre> 
<h4 id="1.3%E3%80%81%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96">1.<strong>3、引入依赖</strong></h4> 
<p>在父工程pom中引入starter-openfeign的依赖</p> 
<pre><code class="language-XML">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
            &lt;version&gt;3.1.1&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<h4 id="1.4%C2%A0%E5%9C%A8%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%BC%95%E7%94%A8common%E5%85%AC%E5%85%B1%E6%A8%A1%E5%9D%97">1.4、在其他模块中引用common公共模块</h4> 
<p><img alt="" height="672" src="https://images2.imgbox.com/1f/4d/JiCTL5Tw_o.png" width="1200"></p> 
<h4 id="%C2%A01.5%E3%80%81%20shop-order%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81"> 1.5、 shop-order模块代码</h4> 
<p>在order服务中先创建一个获取订单号的测试接口，建立一个controller层和service层，controller层代码分别如下：</p> 
<pre><code class="language-java">package com.alibabashop.order.controller;

import com.alibabashop.order.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/order")
public class OrderController {

    @Autowired
    private OrderService orderService;

    @GetMapping("getOrderNo")
    public String getOrderNo(String userId){
        return orderService.getOrderNo(userId);
    }

}
</code></pre> 
<p>service层实现类，目前没有查DB，做简单的判断</p> 
<pre><code class="language-java">package com.alibabashop.order.service.impl;

import com.alibabashop.order.service.OrderService;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;

@Service
public class OrderServiceImpl implements OrderService {
    @Override
    public String getOrderNo(String userId) {
        if (StringUtils.isNotEmpty(userId) &amp;&amp; userId.equals("testID12345")){
            return "当前的订单号是:12345";
        }else {
            throw new RuntimeException("单号不存在");
        }
    }
}
</code></pre> 
<p>启动类开启支持feign的远程调用的注解 @EnableFeignClients</p> 
<pre><code class="language-java">package com.alibabashop.order;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@EnableFeignClients
@ComponentScan(basePackages = {"com.alibabashop.*"})
public class ShopOrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ShopOrderApplication.class, args);
    }
}
</code></pre> 
<p> 代码结构如下：</p> 
<p><img alt="" height="655" src="https://images2.imgbox.com/5d/a1/OFNJt9GU_o.png" width="1200"></p> 
<p> </p> 
<h4 id="%C2%A01.6%E3%80%81%20shop-user%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81"> 1.6、shop-user模块代码</h4> 
<p>然后在user服务中创建一个OrderFeign接口用来调用order服务</p> 
<pre><code class="language-java">package com.alibabashop.user.fegin;


import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@FeignClient(value = "shop-order")
@Component
public interface OrderFeign {

    @GetMapping("order/getOrderNo")
    String getOrderNo(@RequestParam String userId);
}
</code></pre> 
<p>@FeignClient标签的常用属性如下：</p> 
<p>name/value：指定FeignClient的名称，如果项目使用了Ribbon，name属性会作为微服务的名称，用于服务发现<br> url: url一般用于调试，可以手动指定@FeignClient调用的地址<br> decode404:当发生http 404错误时，如果该字段位true，会调用decoder进行解码，否则抛出FeignException<br> configuration: Feign配置类，可以自定义Feign的Encoder、Decoder、LogLevel、Contract<br> fallback: 定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback指定的类必须实现@FeignClient标记的接口<br> fallbackFactory: 工厂类，用于生成fallback类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码<br> path: 定义当前FeignClient的统一前缀，当我们项目中配置了server.context-path,server.servlet-path时使用<br> value 属性的值是order服务的服务名称，也就是注册到注册中心中的服务名称。</p> 
<p><strong>注：需要注意的是接口的参数添加一个@RequestParam注解，其作用是如果不加默认的注解，Feign则会对参数默认加上@RequestBody注解，而RequestBody一定是包含在请求体中的，GET方式无法包含，将执行报错。</strong></p> 
<p>我们在user服务中建立一个controller和service调用feign接口来测试一下<br> controller层</p> 
<pre><code class="language-java">package com.alibabashop.user.controller;

import com.alibabashop.user.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("getOrderNo")
    public String getOrderNo(String userId){
        return userService.getOrderNo(userId);
    }
}


</code></pre> 
<p>service层</p> 
<pre><code class="language-java">package com.alibabashop.user.service.impl;

import com.alibabashop.user.fegin.OrderFeign;
import com.alibabashop.user.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.servlet.http.HttpServletRequest;

@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private OrderFeign orderFeign;


    @Override
    public String getOrderNo(String userId) {
        return orderFeign.getOrderNo(userId);
    }

}
</code></pre> 
<p> 代码结构如下：</p> 
<p><img alt="" height="667" src="https://images2.imgbox.com/d2/87/b3uLPhpk_o.png" width="1200"></p> 
<h4 id="%C2%A01.7%20%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1"> 1.7、启动服务</h4> 
<p>启动user服务的时候发现报错了，是因为SpringCloud Feign在Hoxton.M2 RELEASED版本之后抛弃了Ribbon，使用了spring-cloud-loadbalancer，所以我们这里还需要引入spring-cloud-loadbalancer的依赖。</p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/4e/51/A5TZAGXl_o.png" width="1200"></p> 
<pre><code class="language-XML">		&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;
            &lt;version&gt;3.1.1&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre> 
<p> 在父工程pom中引入负载均衡依赖之后重新启动项目，并查看nacos，发现服务已经注册成功。</p> 
<p><img alt="" height="647" src="https://images2.imgbox.com/2c/55/Vcqju8dF_o.png" width="1200"></p> 
<h4 id="1.8%E3%80%81%E9%80%9A%E8%BF%87feign%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1">1.8、通过feign接口访问服务</h4> 
<p>通过postman或者浏览器访问user服务，结果如下：</p> 
<p><img alt="" height="762" src="https://images2.imgbox.com/da/09/kPNcRey2_o.png" width="1200"></p> 
<h3 id="2%E3%80%81OpenFeign%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%C2%A0">2、OpenFeign的进阶使用 </h3> 
<h4 id="2.1%20openfeign%E6%8E%A5%E5%8F%A3%E6%B7%BB%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BF%A1%E6%81%AF"><strong>2.1、openfeign接口添加请求头信息</strong></h4> 
<p>有时候会在接口请求中传递一些头信息，其中有5种方式可以实现传递请求头信息：</p> 
<p>在@RequestMapping注解里添加headers属性<br> 在方法参数前面添加@RequestHeader注解<br> 在方法或者类上添加@Headers的注解<br> 在方法参数前面添加@HeaderMap注解<br> 实现RequestInterceptor接口</p> 
<p>本文只演示一个最简单的，在方法参数前面添加@RequestHeader注解。<br> 修改OrderFeign接口<br> 单个参数：</p> 
<pre><code class="language-java">@GetMapping("order/getOrderNo")
    String getOrderNo(@RequestParam String userId,@RequestParam String tenantId,@RequestHeader("Authorization") String token);
</code></pre> 
<p> 多个参数使用MultiValueMap:</p> 
<pre><code class="language-java">@GetMapping("order/getOrderNo")
    String getOrderNo(@RequestParam String userId, @RequestParam String tenantId, @RequestHeader MultiValueMap&lt;String, String&gt; headers);
</code></pre> 
<p>我们来测试下传递单个参数的情况<br><strong>user服务代码修改</strong><br> controller（添加HttpServletRequest参数）：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("getOrderNo")
    public String getOrderNo(String userId, String tenantId, HttpServletRequest request){
        return userService.getOrderNo(userId,tenantId,request);
    }
}
</code></pre> 
<p>service实现类（获取request中的头信息并传递给feign接口）</p> 
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private OrderFeign orderFeign;


    @Override
    public String getOrderNo(String userId, String tenantId, HttpServletRequest request) {
        return orderFeign.getOrderNo(userId,tenantId, request.getHeader("token"));
    }
}
</code></pre> 
<p>order服务代码修改：<br> controller（获取头信息中的参数）：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/order")
public class OrderController {

    @Autowired
    private OrderService orderService;

    @GetMapping("getOrderNo")
    public String getOrderNo(String userId, String tenantId, HttpServletRequest request){
        System.out.println("Authorization:" + request.getHeader("Authorization"));
        return orderService.getOrderNo(userId,tenantId);
    }

}</code></pre> 
<p>service（将传入的参数修改）：</p> 
<pre><code class="language-java">@Service
public class OrderServiceImpl implements OrderService {
    @Override
    public String getOrderNo(String userId,String tenantId) {
        System.out.println(tenantId);
        if (StringUtils.isNotEmpty(userId) &amp;&amp; userId.equals("testID12345")){
            return "当前的订单号是:12345";
        }else {
            throw new RuntimeException("单号不存在");
        }
    }
}</code></pre> 
<p>重启服务并用postman调用接口</p> 
<p><img alt="" height="515" src="https://images2.imgbox.com/05/7a/PwvqAZ1J_o.png" width="1200"></p> 
<p> 成功获取到头信息</p> 
<p><img alt="" height="293" src="https://images2.imgbox.com/3e/a5/02XLnq5q_o.png" width="1200"></p> 
<p></p> 
<h4 id="2.2%E3%80%81fallback%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0"><strong>2.2、fallback的使用</strong> </h4> 
<p>fallback: 定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback指定的类必须实现@FeignClient标记的接口</p> 
<p>然后我们看下怎么用。<br> 先定义一个容错的处理类 OrderFeignHandler：</p> 
<pre><code class="language-java">package com.alibabashop.user.handler;

import com.alibabashop.user.fegin.OrderFeign;
import org.springframework.stereotype.Component;

@Component
public class OrderFeignHandler implements OrderFeign {
    @Override
    public String getOrderNo(String userId, String tenantId, String token) {
        String fallback = "当前查询人数过多，请稍后重试！";
        return fallback;
    }
}</code></pre> 
<p>@FeignClient 注解添加fallback属性 fallback = OrderFeignHandler.class</p> 
<pre><code class="language-java">import com.alibabashop.user.handler.OrderFeignHandler;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestParam;

@FeignClient(value = "shop-order",fallback = OrderFeignHandler.class)
@Component
public interface OrderFeign {

    @GetMapping("order/getOrderNo")
    String getOrderNo(@RequestParam String userId,@RequestParam String tenantId
            ,@RequestHeader("Authorization") String token);
}
</code></pre> 
<p>重启user服务，先获取一下正常的数据<br> 正常返回订单号</p> 
<p><img alt="" height="762" src="https://images2.imgbox.com/fa/ce/Wubqw9hN_o.png" width="1200"> 我们在模拟一下异常的情况 修改order服务中的获取单号接口，找不到单号则抛异常</p> 
<pre><code class="language-java">@Service
public class OrderServiceImpl implements OrderService {
    @Override
    public String getOrderNo(String userId,String tenantId) {
        System.out.println(tenantId);
        if (StringUtils.isNotEmpty(userId) &amp;&amp; userId.equals("mdx123456")){
            return "O111222333444";
        }else {
            throw new RuntimeException("单号不存在");
        }
    }
}
</code></pre> 
<p>重启order服务，参数中传递一个不存在的订单号<br> 发现并没有返回我们想要的信息</p> 
<p><img alt="" height="808" src="https://images2.imgbox.com/07/9d/9PUxIaIU_o.png" width="1200"></p> 
<p>检查代码，发现我们少了配置sentinel，因为我们使用的是alibaba微服务体系，所以我们使用sentinel来做熔断 sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性(sentinel如何使用我们后面的章节会讲到)。</p> 
<p>在父工程pom下添加sentinel 依赖</p> 
<pre><code class="language-XML">		&lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud-alibaba.version}&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre> 
<p>yml配置文件添加feign开启sentinel的配置</p> 
<pre><code class="language-XML">feign:
  sentinel:
    enabled: true
</code></pre> 
<p>重启user服务，再次访问接口<br> 我们可以看到order服务抛出了订单号不存在的异常</p> 
<p><img alt="" height="393" src="https://images2.imgbox.com/34/f6/4eNabA5J_o.png" width="1200"></p> 
<p> 但是我们的接口成功返回了容错接口定义的信息</p> 
<p><img alt="" height="789" src="https://images2.imgbox.com/24/19/EvLvsj09_o.png" width="1200"></p> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p>至此，本文简单使用openfegin的目的就完成了。在本文的第一阶段，通过在项目中新建一个shop-order的子模块，在该模块中建立订单查询的逻辑，同时修改之前文章中的shop-user子模块下的代码，通过新建OrderFegin接口，配置该接口FeignClient的参数，指定需要访问的服务，即可实现调用该服务。此外，本文下半部分介绍了openfeign接口添加请求头信息和fallback属性的使用。同时提到了SpringCloud Alibaba用来做熔断的sentinel组件，下一篇我们将进行学习总结。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/84b3258cd5a27adbb9cc02a1820c4c95/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Cloud Alibaba实战之一：项目搭建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b3663838089be546564b039b66c810ab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用python破解zip压缩文件密码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>