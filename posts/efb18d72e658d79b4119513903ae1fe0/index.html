<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AQS - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AQS" />
<meta property="og:description" content="AQS 什么是AQS 我们在使用锁时，一般会有如下几点考虑：
希望这个锁是同一时间只能被一个线程获取的，还是能够被多个线程获取。当几个线程在同时争抢锁的占有权时，怎么处理没有获取到锁的线程某个线程一直获取不到锁，怎么处理中断 基于JVM实现的锁Synchronized只支持独占，并且无法处理中断，也不支持公平和非公平的选择。所以在JDK1.5时引入了基于AQS实现的锁，它们功能更加地强大，比如ReentrantLock、CountDownLatch、CyclicBarrier等等。
AQS即AbstractQueuedSynchronizer的缩写，它是Java并发用来构建锁和其他同步组件的基础框架。在内部维护了一个Volatile的变量state和一个CLH队列
state 代表着共享资源，获取和释放锁本质上就是对state进行的修改，修改成功则获取锁，否则会被加入到等待队列
state值描述0当前锁没有线程持有1被线程持有大于1同一个线程重复获得了锁（锁的可重入性） CLH队列 CLH队列：是一个FIFO的双端双向队列，如下图：
该队列由Node结点构成，每个Node结点维护一个pre引用和next引用，分别指向前驱节点和后继节点。AQS维护两个指针，分别指向队列的头结点和尾节点
CLH队列其实就是一个双端双向链表，当线程获取资源失败（tryAcquire失败）时会被构造成一个Node结点加入CLH队列，同时该线程会被阻塞。当持有锁的线程释放锁时会唤醒后继结点再次尝试获取锁
Node结点 获取锁失败的线程会被包装成一个Node结点加入到CLH队列中，它是AQS中的一个静态内部类，其中有一个int变量waitStatus标识结点的状态
waitStatus值描述CANCELLED (1)表示当前线程超时、中断SIGNAL （-1）表示后续节点会被唤醒PROPAGATE （-2）表示下一次唤醒是共享的，会无条件地传播下去（主要实现共享锁）waitStatus （0）初始状态 AQS的使用 AQS采用了模板方法模式进行设计，使用方法如下：
使用者继承AbstractQueuedSynchronizer并重写指定的方法（就是对于共享资源state的修改操作）
在具体的锁中创建一个内部类继承自AQS，并调用其模板方法
需要重写的方法：
方法名描述tryAcquire独占获取锁，成功返回true，失败falsetryRelease独占释放锁，等待队列中的其他线程此时将有机会获取到同步状态tryAcquireShared共享获取锁，返回值大于等于0表示成功tryReleaseShared共享释放锁，成功返回true 如何使用 首先，我们需要去继承AQS类，然后根据需要去重写对应的方法，比如要实现独占锁就去重写tryAcquire、tryRelease方法。最后在我们的锁中调用AQS的模板方法就可以了，而这些模板方法会调用我们重写的方法
public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } tryAcquire就是我们需要重写的，而像addWaiter、acquireQueued方法是AQS为我们写好的
AQS源码分析 接下来通过ReentrantLock、CoutDownLatch来分别讲下AQS的独占功能和共享功能以及整个加锁释放锁流程是怎么实现的
独占锁 假设这里有3个线程ThreadA、ThreadB、ThreadC，一个独占锁ReentrantLock
第一个线程获取锁 在进行锁的创建时通过传入的boolean值决定该锁是公平锁还是非公平锁。如果不传入值则默认是非公平锁
整个锁的获取流程如上图所示：首先线程调用lock方法开始尝试获取锁，然后会调用acquire方法，AQS会调用重写的tryAcquire方法
public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 任何一种基于AQS实现的独占锁都会来到这一步，各种锁通过对tryAcquire的不同的重写方式实现了不同的功能。比如ReentrantLock就是通过两个不同的内部类重写了tryAcquire方法来实现了公平与非公平锁
公平与非公平的区别就是公平锁在尝试获取时会进行一次判断，当前等待队列中是否有结点而且是当前结点的前驱节点
最开始等待队列是这个样子：
接着通过CAS操作更新state的值,更改成功，则获取锁成功
如果State的值不为0，也就是说当前锁已经被占有了，那就判断是否是重入地获得锁。
第一个线程时由于tryAcquire方法成功，因此能够直接获取锁
第二个线程尝试获取锁 依然是会调用tryAcquire方法，这里以公平锁为例" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/efb18d72e658d79b4119513903ae1fe0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-16T17:32:18+08:00" />
<meta property="article:modified_time" content="2020-11-16T17:32:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AQS</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="AQS_0"></a>AQS</h2> 
<h3><a id="AQS_2"></a>什么是AQS</h3> 
<p>我们在使用锁时，一般会有如下几点考虑：</p> 
<ul><li>希望这个锁是同一时间只能被一个线程获取的，还是能够被多个线程获取。</li><li>当几个线程在同时争抢锁的占有权时，怎么处理没有获取到锁的线程</li><li>某个线程一直获取不到锁，怎么处理中断</li></ul> 
<p>基于JVM实现的锁Synchronized只支持独占，并且无法处理中断，也不支持公平和非公平的选择。所以在JDK1.5时引入了基于AQS实现的锁，它们功能更加地强大，比如ReentrantLock、CountDownLatch、CyclicBarrier等等。</p> 
<p>AQS即AbstractQueuedSynchronizer的缩写，它是Java并发用来构建锁和其他同步组件的基础框架。在内部维护了一个Volatile的变量state和一个CLH队列</p> 
<h4><a id="state_14"></a>state</h4> 
<p>代表着共享资源，获取和释放锁本质上就是对state进行的修改，修改成功则获取锁，否则会被加入到等待队列</p> 
<table><thead><tr><th>state值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>当前锁没有线程持有</td></tr><tr><td>1</td><td>被线程持有</td></tr><tr><td>大于1</td><td>同一个线程重复获得了锁（锁的可重入性）</td></tr></tbody></table> 
<h4><a id="CLH_24"></a>CLH队列</h4> 
<p>CLH队列：是一个FIFO的双端双向队列，如下图：<br> <img src="https://images2.imgbox.com/9b/ca/5xs2whQh_o.png" alt="图片"></p> 
<p>该队列由Node结点构成，每个Node结点维护一个pre引用和next引用，分别指向前驱节点和后继节点。AQS维护两个指针，分别指向队列的头结点和尾节点</p> 
<p>CLH队列其实就是一个双端双向链表，当线程获取资源失败（tryAcquire失败）时会被构造成一个Node结点加入CLH队列，同时该线程会被阻塞。当持有锁的线程释放锁时会唤醒后继结点再次尝试获取锁</p> 
<h5><a id="Node_34"></a>Node结点</h5> 
<p>获取锁失败的线程会被包装成一个Node结点加入到CLH队列中，它是AQS中的一个静态内部类，其中有一个int变量waitStatus标识结点的状态</p> 
<table><thead><tr><th>waitStatus值</th><th>描述</th></tr></thead><tbody><tr><td>CANCELLED (1)</td><td>表示当前线程超时、中断</td></tr><tr><td>SIGNAL （-1）</td><td>表示后续节点会被唤醒</td></tr><tr><td>PROPAGATE （-2）</td><td>表示下一次唤醒是共享的，会无条件地传播下去（主要实现共享锁）</td></tr><tr><td>waitStatus （0）</td><td>初始状态</td></tr></tbody></table> 
<h3><a id="AQS_45"></a>AQS的使用</h3> 
<p>AQS采用了模板方法模式进行设计，使用方法如下：</p> 
<ul><li> <p>使用者继承AbstractQueuedSynchronizer并重写指定的方法（就是对于共享资源state的修改操作）</p> </li><li> <p>在具体的锁中创建一个内部类继承自AQS，并调用其模板方法</p> </li></ul> 
<p>需要重写的方法：</p> 
<table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>tryAcquire</td><td>独占获取锁，成功返回true，失败false</td></tr><tr><td>tryRelease</td><td>独占释放锁，等待队列中的其他线程此时将有机会获取到同步状态</td></tr><tr><td>tryAcquireShared</td><td>共享获取锁，返回值大于等于0表示成功</td></tr><tr><td>tryReleaseShared</td><td>共享释放锁，成功返回true</td></tr></tbody></table> 
<h4><a id="_62"></a>如何使用</h4> 
<p>首先，我们需要去继承AQS类，然后根据需要去重写对应的方法，比如要实现独占锁就去重写tryAcquire、tryRelease方法。最后在我们的锁中调用AQS的模板方法就可以了，而这些模板方法会调用我们重写的方法</p> 
<pre><code>public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre> 
<p>tryAcquire就是我们需要重写的，而像addWaiter、acquireQueued方法是AQS为我们写好的</p> 
<h3><a id="AQS_75"></a>AQS源码分析</h3> 
<p>接下来通过ReentrantLock、CoutDownLatch来分别讲下AQS的独占功能和共享功能以及整个加锁释放锁流程是怎么实现的</p> 
<h4><a id="_78"></a>独占锁</h4> 
<p><img src="https://images2.imgbox.com/56/34/AWQ5NgiF_o.jpg" alt=""></p> 
<p>假设这里有3个线程ThreadA、ThreadB、ThreadC，一个独占锁ReentrantLock</p> 
<h5><a id="_88"></a>第一个线程获取锁</h5> 
<p>在进行锁的创建时通过传入的boolean值决定该锁是公平锁还是非公平锁。如果不传入值则默认是非公平锁</p> 
<p>整个锁的获取流程如上图所示：首先线程调用lock方法开始尝试获取锁，然后会调用acquire方法，AQS会调用重写的tryAcquire方法</p> 
<pre><code>public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre> 
<p>任何一种基于AQS实现的独占锁都会来到这一步，各种锁通过对tryAcquire的不同的重写方式实现了不同的功能。比如ReentrantLock就是通过两个不同的内部类重写了tryAcquire方法来实现了公平与非公平锁</p> 
<p><img src="https://images2.imgbox.com/29/c6/NMRUlSC8_o.png" alt="图片"></p> 
<p>公平与非公平的区别就是公平锁在尝试获取时会进行一次判断，当前等待队列中是否有结点而且是当前结点的前驱节点</p> 
<p>最开始等待队列是这个样子：</p> 
<p><img src="https://images2.imgbox.com/d2/92/zCjpkurN_o.png" alt="图片"></p> 
<p>接着通过CAS操作更新state的值,更改成功，则获取锁成功</p> 
<p>如果State的值不为0，也就是说当前锁已经被占有了，那就判断是否是重入地获得锁。</p> 
<p>第一个线程时由于tryAcquire方法成功，因此能够直接获取锁</p> 
<h5><a id="_124"></a>第二个线程尝试获取锁</h5> 
<p>依然是会调用tryAcquire方法，这里以公平锁为例</p> 
<pre><code>public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre> 
<p>此时由于state状态不为0，并且获取锁的线程不是当前线程，因此tryAcquire方法会失败。就会将该线程加入等待队列中</p> 
<pre><code>private Node addWaiter(Node mode) {
        Node node = new Node(mode);

        for (;;) {
            Node oldTail = tail;
            if (oldTail != null) {
                U.putObject(node, Node.PREV, oldTail);  //将当前节点的pre结点设置为前尾节点
                if (compareAndSetTail(oldTail, node)) { //通过CAS操作将当前结点设置为尾节点
                    oldTail.next = node;
                    return node;
                }
            } else {
                initializeSyncQueue(); //如果等待队列没有初始化则先进行初始化
            }
        }
    }
</code></pre> 
<p>这里是一个自旋操作，假如当前尾节点不为空，说明等待队列已经被初始化，那么会通过CAS操作将当前结点设置为尾节点，否则会初始化这个队列。</p> 
<p><img src="https://images2.imgbox.com/cb/e4/PqGsixaU_o.png" alt="图片"></p> 
<p>不过初始化这个队列时并不会将当前结点作为头结点插入，而是会新建一个头结点，然后自旋再次进入将当前节点作为首节点。这样做的目的主要是为了后续的阻塞唤醒操作</p> 
<p><img src="https://images2.imgbox.com/09/c3/p3ze84o1_o.png" alt="图片"></p> 
<p>接着就是通过自旋获取锁或者进入阻塞状态</p> 
<pre><code>final boolean acquireQueued(final Node node, int arg) {
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor(); //获取当前节点的前驱结点
                if (p == head &amp;&amp; tryAcquire(arg)) { //只有前驱节点是头结点，也就是当前结点是等待队列中的第一个线程时才会再次尝试获取锁
                    setHead(node); //当前结点获取锁成功后则置为头结点
                    p.next = null; // help GC
                    return interrupted;
                }
                //假如不是首节点或者获取锁失败，那么就要判断是否应该进入阻塞状态
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } catch (Throwable t) {
            cancelAcquire(node);
            throw t;
        }
    }
</code></pre> 
<blockquote> 
 <p>定义头结点的目的是为了第一个获取锁失败的线程进入等待队列后使它能够进入阻塞状态</p> 
</blockquote> 
<pre><code>private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus; //获取前驱结点的状态
        if (ws == Node.SIGNAL) //表示前驱节点在将来是会唤醒当前结点的，当前节点可以放心地进入阻塞状态
           return true;
        if (ws &gt; 0) { //前驱节点被中断获异常，应该将前驱节点从队列中移出，并且为了保证当前节点能够进入阻塞状态需要往前寻找有效的前驱结点
          do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &gt; 0);
            pred.next = node;  //将重新找到的有效的前驱节点的next指向当前节点
        } else {
           pred.compareAndSetWaitStatus(ws, Node.SIGNAL); 
        }
        return false;
    }
</code></pre> 
<p>由于是一个自旋操作，所以就算前驱结点的状态不为SIGNAL,也会先将前驱节点的状态置为SIGNAL，然后后面会再次执行shouldParkAfterFailedAcquire方法，这一次成功后就能接着执行parkAndCheckInterrupt将当前结点阻塞</p> 
<p>一个线程是否能够进入阻塞状态和它的前驱节点有关，它必须得确保自己进入阻塞后将来能够被其他线程唤醒才会安心地阻塞。这也是为什么初始化队列时要新建一个头结点而不是直接将当前节点作为头结点的原因。因为当前结点是可能会阻塞的。</p> 
<pre><code>private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this); //阻塞当前节点
        return Thread.interrupted();
    }
</code></pre> 
<p>此时等待队列如下：</p> 
<p><img src="https://images2.imgbox.com/67/fb/prYBErzT_o.png" alt="图片"></p> 
<h5><a id="_230"></a>第三个线程获取锁</h5> 
<p>ThreadC线程尝试获取锁也是同样的，它会将ThreadB的waitStatus也变为SIGNAL</p> 
<p><img src="https://images2.imgbox.com/df/c5/McNQZseg_o.png" alt="图片"></p> 
<h5><a id="_236"></a>第一个线程释放锁</h5> 
<pre><code>protected final boolean tryRelease(int releases) {
            int c = getState() - releases; //并不是直接置为0，因为可能是重入锁
            if (Thread.currentThread() != getExclusiveOwnerThread()) //当前线程必须是锁的占有线程
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null); //将锁的占有线程清空
            }
            setState(c);
            return free;
        }
</code></pre> 
<p>释放锁的操作其实也是对State的值进行更改，因为是可重入的锁，所以并不是直接将State置为0</p> 
<pre><code>public final boolean release(int arg) {
        if (tryRelease(arg)) { //释放锁成功
            Node h = head;
            if (h != null &amp;&amp; h.waitStatus != 0)  //头结点非空并且头结点的状态不为0
                unparkSuccessor(h); //唤醒等待队列中的下一个结点
            return true;
        }
        return false;
    }
</code></pre> 
<pre><code> private void unparkSuccessor(Node node) {
    int ws = node.waitStatus; //获取头结点的状态
        if (ws &lt; 0)
            node.compareAndSetWaitStatus(ws, 0);
           Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) { //下一个结点被中断或者为空
            s = null;
            for (Node p = tail; p != node &amp;&amp; p != null; p = p.prev) //从尾部开始向前遍历将中断的结点从等待队列中移除
                if (p.waitStatus &lt;= 0)
                    s = p;
        }
        if (s != null)
            LockSupport.unpark(s.thread); //唤醒结点
    }
</code></pre> 
<p>首先会将前驱结点的waitStatus通过CAS操作设置为0，接下来会进行判断，假如当前节点的状态&gt;0，说明出现了异常，那么会从为尾节点开始到当前节点的所有中断的结点都从等待队列中移除，然后唤醒当前首节点。</p> 
<p>唤醒后首节点会通过自旋获取锁，这次获取成功将自己也置为头结点<br> <img src="https://images2.imgbox.com/d3/34/yewEtGIK_o.png" alt="图片"></p> 
<p>这就是独占锁的获取释放功能</p> 
<h4><a id="_293"></a>共享锁</h4> 
<p><img src="https://images2.imgbox.com/04/5e/smkJI9Wb_o.jpg" alt=""></p> 
<p>可以发现共享锁和独占锁的加锁流程几乎一致。</p> 
<p><img src="https://images2.imgbox.com/4d/2a/oyk7bVD2_o.png" alt="图片"></p> 
<p>这里以CountDownLatch为例</p> 
<p>在CountDownLatch中是await、countDown方法，其实就是acquire、release方法</p> 
<pre><code>public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
</code></pre> 
<pre><code>public void countDown() {
        sync.releaseShared(1);
    }
</code></pre> 
<blockquote> 
 <p>acquireShared和acquireSharedInterruptibly的区别就是后者被中断时会抛出异常</p> 
</blockquote> 
<p>初始化CountDownLatch时会传入一个值就是state的值，最开始不为0所以获取锁都会失败。因此都会调用doAcquireShared方法进入等待队列中，这里就和acquireQueued方法几乎一致</p> 
<pre><code>protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1; //state值为0时则获取锁成功，否则失败
        }
</code></pre> 
<p>最开始时各个线程调用await方法时，由于state都不为0，所以获取锁都失败</p> 
<p>此时的等待队列如下：</p> 
<p><img src="https://images2.imgbox.com/ac/d6/uBdzkUo0_o.png" alt="图片"></p> 
<p>因此会调用和独占锁类似的那一套流程，包装成结点加入等待队列中，然后判断是否阻塞，修改前驱结点的状态，当前线程进入阻塞状态</p> 
<p>当调用countDown方法后：</p> 
<pre><code>public void countDown() {
        sync.releaseShared(1); //释放锁
    }
</code></pre> 
<pre><code>public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }
</code></pre> 
<p>更新state的值。</p> 
<pre><code>protected boolean tryReleaseShared(int releases) {
              for (;;) { //自旋操作保证一定能够释放锁成功
                int c = getState();
                if (c == 0) //锁已经被释放了。因为锁是共享锁，所以可能存在并发释放的情况
                    return false;
                int nextc = c - 1;
                if (compareAndSetState(c, nextc))
                    return nextc == 0;
            }
        }
</code></pre> 
<p>释放共享锁成功后的操作</p> 
<pre><code>private void doReleaseShared() {
         for (;;) {
            Node h = head;
            if (h != null &amp;&amp; h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    if (!h.compareAndSetWaitStatus(Node.SIGNAL, 0))
                        continue;            // CAS操作失败
                    unparkSuccessor(h); //唤醒等待队列中的结点
                }
                else if (ws == 0 &amp;&amp;
                         !h.compareAndSetWaitStatus(0, Node.PROPAGATE)) //将头结点的状态置为PROPAGATE表示将才去传播的方式连续唤醒等待队列中的所有节点
                    continue;                
            }
            if (h == head)                   
                break; //假如头结点发生了改变
        }
    }
</code></pre> 
<p>此时的等待队列如下：</p> 
<p><img src="https://images2.imgbox.com/8d/e4/W1eCHUpy_o.png" alt="图片"></p> 
<p>唤醒等待队列里面的首节点后，会继续执行doAcquireShared里面的自旋操作，这一次由于state的值已经为0，所以tryAcquireShared为true，接下来就能够获取到锁。</p> 
<p>而和独占锁获取到锁不同的是：共享锁获取到锁后会调用setHeadAndPropagate方法：</p> 
<pre><code>private void doAcquireShared(int arg) {
        final Node node = addWaiter(Node.SHARED);
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    int r = tryAcquireShared(arg);
                    if (r &gt;= 0) {
                        setHeadAndPropagate(node, r); //将当前结点设置为头结点并继续唤醒下一个结点
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } catch (Throwable t) {
            cancelAcquire(node);
            throw t;
        }
    }
</code></pre> 
<pre><code>private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head; // Record old head for check below
        setHead(node);
        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
            (h = head) == null || h.waitStatus &lt; 0) {
            Node s = node.next;
            if (s == null || s.isShared())
                doReleaseShared();
        }
    }
</code></pre> 
<p>此时的等待队列如下：</p> 
<p><img src="https://images2.imgbox.com/41/82/GoHm0m5D_o.png" alt="图片"></p> 
<p>又会调用doReleaseShared方法，它会唤醒等待队列中的后续结点（也就是B结点）。由于上面调用countDownLatch后已经将State的状态置为0，并且setHeadAndPropagate方法将前驱节点置为头结点。因此后续节点自旋操作获取锁时也能成功</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb80f1d228810b3d185fd882ea612e10/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">iptv电视直播_IPTV电视直播系统apk运营—怎么让视频更流畅</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/635434f1563bffee76f34b35e21f45d8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android Studio Gradle下载慢解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>