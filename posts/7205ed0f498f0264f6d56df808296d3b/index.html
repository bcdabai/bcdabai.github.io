<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue11Vuex解说&#43;子父传参详细使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue11Vuex解说&#43;子父传参详细使用" />
<meta property="og:description" content="目录
1. vue组件间通讯
1.1 父子组件
1.2 消息总线
1.3 vuex
2. vuex使用
2.1 简介
2.2 安装
2.3 创建store模块
2.4 创建vuex的store实例并注册上面引入的各大模块
2.5 在main.js中导入vuex
3. 将折叠和展开效果使用vuex实现
3.1 在state.js中声明全局参数
3.2 设置全局参数
3.3 Main.vue组件
3.3.1 直接通过state获取状态值
3.3.2 getter方式获取store中的值
3.4 LeftAside.vue组件
4. 异步处理
4.1 异步修改参数
5. 异步调用后台方法
6. Vuex的常用辅助函数
7. vuex的模块化
8. vuex状态持久化
1. vue组件间通讯 1.1 父子组件 父组件--&gt;子组件，通过子组件的自定义属性：props子组件--&gt;父组件，通过自定义事件：this.$emit(&#39;事件名&#39;,参数1,参数2,...); 1.2 消息总线 这种方式需要另外创建一个vue实例，用来当做消息总线
1.3 vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。可以想象为一个“前端数据库”（数据仓库）， 让其在各个页面上实现数据的共享包括状态，并且可操作。
Vuex分成五个部分：
1.State：单一状态树
2.Getters：状态获取
3.Mutations：触发同步事件
4.Actions：提交mutation，可以包含异步操作
5.Module：将vuex进行分模块
2. vuex使用 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7205ed0f498f0264f6d56df808296d3b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-03T19:29:28+08:00" />
<meta property="article:modified_time" content="2022-11-03T19:29:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue11Vuex解说&#43;子父传参详细使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E8%AE%AF-toc" style="margin-left:0px;"><a href="#1.%20vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E8%AE%AF" rel="nofollow">1. vue组件间通讯</a></p> 
<p id="1.1%20%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6-toc" style="margin-left:40px;"><a href="#1.1%20%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6" rel="nofollow">1.1 父子组件</a></p> 
<p id="1.2%20%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF-toc" style="margin-left:40px;"><a href="#1.2%20%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF" rel="nofollow">1.2 消息总线</a></p> 
<p id="1.3%20vuex-toc" style="margin-left:40px;"><a href="#1.3%20vuex" rel="nofollow">1.3 vuex</a></p> 
<p id="2.%20vuex%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#2.%20vuex%E4%BD%BF%E7%94%A8" rel="nofollow">2. vuex使用</a></p> 
<p id="2.1%20%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#2.1%20%E7%AE%80%E4%BB%8B" rel="nofollow">2.1 简介</a></p> 
<p id="2.2%20%E5%AE%89%E8%A3%85-toc" style="margin-left:40px;"><a href="#2.2%20%E5%AE%89%E8%A3%85" rel="nofollow">2.2 安装</a></p> 
<p id="2.3%20%E5%88%9B%E5%BB%BAstore%E6%A8%A1%E5%9D%97-toc" style="margin-left:40px;"><a href="#2.3%20%E5%88%9B%E5%BB%BAstore%E6%A8%A1%E5%9D%97" rel="nofollow">2.3 创建store模块</a></p> 
<p id="2.4%20%E5%88%9B%E5%BB%BAvuex%E7%9A%84store%E5%AE%9E%E4%BE%8B%E5%B9%B6%E6%B3%A8%E5%86%8C%E4%B8%8A%E9%9D%A2%E5%BC%95%E5%85%A5%E7%9A%84%E5%90%84%E5%A4%A7%E6%A8%A1%E5%9D%97-toc" style="margin-left:40px;"><a href="#2.4%20%E5%88%9B%E5%BB%BAvuex%E7%9A%84store%E5%AE%9E%E4%BE%8B%E5%B9%B6%E6%B3%A8%E5%86%8C%E4%B8%8A%E9%9D%A2%E5%BC%95%E5%85%A5%E7%9A%84%E5%90%84%E5%A4%A7%E6%A8%A1%E5%9D%97" rel="nofollow">2.4 创建vuex的store实例并注册上面引入的各大模块</a></p> 
<p id="2.5%20%E5%9C%A8main.js%E4%B8%AD%E5%AF%BC%E5%85%A5vuex-toc" style="margin-left:40px;"><a href="#2.5%20%E5%9C%A8main.js%E4%B8%AD%E5%AF%BC%E5%85%A5vuex" rel="nofollow">2.5 在main.js中导入vuex</a></p> 
<p id="3.%20%E5%B0%86%E6%8A%98%E5%8F%A0%E5%92%8C%E5%B1%95%E5%BC%80%E6%95%88%E6%9E%9C%E4%BD%BF%E7%94%A8vuex%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#3.%20%E5%B0%86%E6%8A%98%E5%8F%A0%E5%92%8C%E5%B1%95%E5%BC%80%E6%95%88%E6%9E%9C%E4%BD%BF%E7%94%A8vuex%E5%AE%9E%E7%8E%B0" rel="nofollow">3. 将折叠和展开效果使用vuex实现</a></p> 
<p id="3.1%20%E5%9C%A8state.js%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.1%20%E5%9C%A8state.js%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0" rel="nofollow">3.1 在state.js中声明全局参数</a></p> 
<p id="3.2%20%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.2%20%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0" rel="nofollow">3.2 设置全局参数</a></p> 
<p id="3.3%20Main.vue%E7%BB%84%E4%BB%B6-toc" style="margin-left:0px;"><a href="#3.3%20Main.vue%E7%BB%84%E4%BB%B6" rel="nofollow">3.3 Main.vue组件</a></p> 
<p id="3.3.1%20%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87state%E8%8E%B7%E5%8F%96%E7%8A%B6%E6%80%81%E5%80%BC-toc" style="margin-left:80px;"><a href="#3.3.1%20%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87state%E8%8E%B7%E5%8F%96%E7%8A%B6%E6%80%81%E5%80%BC" rel="nofollow">3.3.1 直接通过state获取状态值</a></p> 
<p id="3.3.2%20getter%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96store%E4%B8%AD%E7%9A%84%E5%80%BC-toc" style="margin-left:80px;"><a href="#3.3.2%20getter%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96store%E4%B8%AD%E7%9A%84%E5%80%BC" rel="nofollow">3.3.2 getter方式获取store中的值</a></p> 
<p style="margin-left:0px;"><a href="#3.4%20LeftAside.vue%E7%BB%84%E4%BB%B6" rel="nofollow">3.4 LeftAside.vue组件</a></p> 
<p id="4.%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-toc" style="margin-left:0px;"><a href="#4.%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86" rel="nofollow">4. 异步处理</a></p> 
<p id="4.1%20%E5%BC%82%E6%AD%A5%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#4.1%20%E5%BC%82%E6%AD%A5%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0" rel="nofollow">4.1 异步修改参数</a></p> 
<p id="5.%20%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E5%90%8E%E5%8F%B0%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#5.%20%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E5%90%8E%E5%8F%B0%E6%96%B9%E6%B3%95" rel="nofollow">5. 异步调用后台方法</a></p> 
<p id="6.%20Vuex%E7%9A%84%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#6.%20Vuex%E7%9A%84%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0" rel="nofollow">6. Vuex的常用辅助函数</a></p> 
<p id="%C2%A07.%20vuex%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96-toc" style="margin-left:0px;"><a href="#%C2%A07.%20vuex%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96" rel="nofollow">7. vuex的模块化</a></p> 
<p id="8.%20vuex%E7%8A%B6%E6%80%81%E6%8C%81%E4%B9%85%E5%8C%96-toc" style="margin-left:0px;"><a href="#8.%20vuex%E7%8A%B6%E6%80%81%E6%8C%81%E4%B9%85%E5%8C%96" rel="nofollow">8. vuex状态持久化</a></p> 
<hr id="hr-toc"> 
<h2><span style="color:#fe2c24;">1. vue组件间通讯</span></h2> 
<h3 id="1.1%20%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6"><span style="color:#4da8ee;">1.1 父子组件</span></h3> 
<blockquote> 
 <ul><li>父组件--&gt;子组件，通过子组件的自定义属性：props</li><li>子组件--&gt;父组件，通过自定义事件：this.$emit('事件名',参数1,参数2,...);</li></ul> 
</blockquote> 
<h3 id="1.2%20%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF"><span style="color:#fe2c24;">1.2 消息总线</span></h3> 
<blockquote> 
 <p>这种方式需要另外创建一个vue实例，用来当做消息总线</p> 
</blockquote> 
<h3 id="1.3%20vuex"><span style="color:#4da8ee;">1.3 vuex</span></h3> 
<blockquote> 
 <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。可以想象为一个“前端数据库”（数据仓库）， 让其在各个页面上实现数据的共享包括状态，并且可操作。</p> 
</blockquote> 
<blockquote> 
 <p><strong>Vuex分成五个部分</strong>：<br> 1.State：单一状态树<br> 2.Getters：状态获取<br> 3.Mutations：触发同步事件<br> 4.Actions：提交mutation，可以包含异步操作<br> 5.Module：将vuex进行分模块</p> 
</blockquote> 
<h2 id="2.%20vuex%E4%BD%BF%E7%94%A8"><span style="color:#fe2c24;">2. vuex使用</span></h2> 
<h3 id="2.1%20%E7%AE%80%E4%BB%8B"><span style="color:#4da8ee;">2.1 简介</span></h3> 
<blockquote> 
 <p>Vuex是专门为vue应用程序开发的状态管理模式，将组件的共享状态抽取出来，以一个全局单例模式进行管理，组件树构成一个巨大的视图，不管组件在树的何种位置，任何组件都能获取到状态和触发行为。可以将其想象为一个“前端数据库”（数据仓库），让其在各个页面上实现数据的共享包括状态，并且可操作。（核心就是 解决组件间的通讯问题）</p> 
</blockquote> 
<h3 id="2.2%20%E5%AE%89%E8%A3%85"><span style="color:#4da8ee;">2.2 安装</span></h3> 
<p>进入项目目录：</p> 
<pre><code class="language-java">npm install vuex -S</code></pre> 
<h3 id="2.3%20%E5%88%9B%E5%BB%BAstore%E6%A8%A1%E5%9D%97"><span style="color:#4da8ee;">2.3 创建store模块</span></h3> 
<p>创建store目录及需要的文件：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/82/ba/6htaISMC_o.png"></p> 
<h3 id="2.4%20%E5%88%9B%E5%BB%BAvuex%E7%9A%84store%E5%AE%9E%E4%BE%8B%E5%B9%B6%E6%B3%A8%E5%86%8C%E4%B8%8A%E9%9D%A2%E5%BC%95%E5%85%A5%E7%9A%84%E5%90%84%E5%A4%A7%E6%A8%A1%E5%9D%97"><span style="color:#4da8ee;">2.4 创建vuex的store实例并注册上面引入的各大模块</span></h3> 
<p><img alt="" src="https://images2.imgbox.com/2a/be/XpYt0Sfo_o.png"></p> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">勘误</span>: new Vuex({})，修改为 new Vuex.Store({})</strong></p> 
</blockquote> 
<h3 id="2.5%20%E5%9C%A8main.js%E4%B8%AD%E5%AF%BC%E5%85%A5vuex"><span style="color:#4da8ee;">2.5 在main.js中导入vuex</span></h3> 
<p>main.js是vue应用程序的入口，在这个文件中导入vuex组件。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1d/d5/kj0UBsKR_o.png"></p> 
<blockquote> 
 <p> 通过在根实例中注册store选项，该store实例会注入到根组件下的所有子组件中，且子组件可以通过this.$store访问到。</p> 
</blockquote> 
<h2 id="3.%20%E5%B0%86%E6%8A%98%E5%8F%A0%E5%92%8C%E5%B1%95%E5%BC%80%E6%95%88%E6%9E%9C%E4%BD%BF%E7%94%A8vuex%E5%AE%9E%E7%8E%B0"><span style="color:#fe2c24;">3. 将折叠和展开效果使用vuex实现</span></h2> 
<h3 id="3.1%20%E5%9C%A8state.js%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0"><span style="color:#4da8ee;">3.1 在state.js中声明全局参数</span></h3> 
<blockquote> 
 <p>state.js的作用可以看作是存放全局参数的容器，组件可以通过state.js获取全局参数。</p> 
</blockquote> 
<pre><code class="language-javascript">//存放全局参数的容器，组件可以通过state.js获取全局参数
const state = {
  LeftAsideState: 'open'
}

export default state</code></pre> 
<h3 id="3.2%20%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0"><span style="color:#4da8ee;">3.2 设置全局参数</span></h3> 
<blockquote> 
 <p>当在TopNav.vue中点击展开或折叠时，需要将当前的状态设置到全局参数中，以便于其他组件可以获取到状态。<br> mutations：相当于setter方法，处理数据的唯一途径，state的改变或赋值只能在这里。</p> 
</blockquote> 
<p>1） mutations.js</p> 
<pre><code class="language-javascript">//Mutation 必须是同步函数。原因：异步方法，我们不知道什么时候状态会发生改变，所以也就无法追踪了
//如果我们需要异步操作，Mutations就不能满足我们需求了，这时候我们就需要Actions了
const mutations = {

  //state，即state.js中定义的state，借此可以访问state中定义的全局变量
  //payload: 载荷,保存传递参数的容器
  setLeftAsideState: (state, payload) =&gt; {
    //通过载荷为全局参数赋值，相当于setter
    state.LeftAsideState = payload.LeftAsideState;
  }

}

export default mutations</code></pre> 
<p>2）如何调用mutations.js中定义的setLeftAsideState为全局参数赋值？ 见一下示例：</p> 
<blockquote> 
 <p>当点击TopNav.vue组件中的折叠或展开按键时，需要将当前的状态设置到全局参数中，以便于其他组件可以获取到状态。</p> 
</blockquote> 
<p>TopNav.vue</p> 
<pre><code class="language-javascript"> //转换折叠图标的状态
      doToggle: function() {
        //如果原来为打开状态则点击后转换为折叠
        //如果原来为折叠状态则点击后转换为打开
        this.opened = !this.opened;

        //通过自定义事件将状态值传递个父组件，及Main.vue
        //相应的Main.vue组件中需要设置‘left-open-collapsed’
        //使用vuex方式后，将原来的实现方式注释
        //this.$emit("left-open-collapsed",this.opened);

        /*
         * 通过vuex进行组件间的通讯，当点击折叠或展开时设置全局参数，以便于
         * 其他组件获取状态。
         *
         *  第一种提交方式：
         * this.$store.commit(type, payload);
         * 参数type: 与mutations.js定义的方法名一致
         * 参数payload：载荷，是个json对象，其中的参数与state.js中定义的全局参数名一致
         * 该方法的作用是为全局参数LeftAsideState赋值。
         * 
         * 第二种提交方式：
         * this.$store.commit({type: 'setLeftAsideState', LeftAsideState: 'open'});
         * 即：将type参数与要设置的全局参数放在一个json对象中。
         */
        this.$store.commit("setLeftAsideState", {
          LeftAsideState : this.opened ? 'open' : 'collapsed'
        });
        
      }</code></pre> 
<h2 id="3.3%20Main.vue%E7%BB%84%E4%BB%B6"><span style="color:#4da8ee;">3.3 Main.vue组件</span></h2> 
<blockquote> 
 <p>Main.vue组件获取设置的全局变量（LeftAsideState）的值，并需要根据变量的值来改变自身的状态。<br> state中存放的状态值是响应式的，从store实例中读取状态最简单的方式是在计算属性中返回某个状态。</p> 
</blockquote> 
<h4 id="3.3.1%20%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87state%E8%8E%B7%E5%8F%96%E7%8A%B6%E6%80%81%E5%80%BC"><strong>3.3.1 直接通过state获取状态值</strong></h4> 
<p>Main.vue</p> 
<pre><code class="language-javascript">/*
 * 通过计算属性读取store中的值,并根据获取到的值返回展开或折叠样式。
 * 定义好计算属性后，通过绑定的方式使用
 * &lt;el-aside :&gt;
 */
computed: {
  leftAsideClass: function() {
    //可以通过以下的方式进行获取，但是不推荐。
    let tmp = this.$store.state.LeftAsideState;
    return tmp == 'open' ? "main-aside" : "main-aside-collapsed";
  }
}</code></pre> 
<blockquote> 
 <p>不推荐使用this.$store.state.LeftAsideState;获取状态值，后续使用getter方式获取。</p> 
</blockquote> 
<p>template部分<br> 使用计算属性设置el-aside的class属性</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;el-container class="main-container"&gt;
    &lt;!-- 侧边栏有折叠效果，通过class控制折叠还是显示的效果 --&gt;
    &lt;!--leftAsideClass 为定义的计算属性 --&gt;
    &lt;el-aside :class="leftAsideClass"&gt;
      &lt;!-- 原来使用父子组件传参方式，修改为vuex方式实现 --&gt;
      &lt;!-- &lt;LeftAside :opened="opened"&gt;&lt;/LeftAside&gt; --&gt;
      &lt;LeftAside&gt;&lt;/LeftAside&gt;
    &lt;/el-aside&gt;
    &lt;el-container&gt;
      &lt;el-header class="main-header"&gt;
        &lt;!-- 原来使用父子组件传参方式，修改为vuex方式实现 --&gt;
        &lt;!-- &lt;TopNav @left-open-collapsed="toggleLeftStat"&gt;&lt;/TopNav&gt; --&gt;
        &lt;TopNav&gt;&lt;/TopNav&gt;
      &lt;/el-header&gt;
      &lt;el-main class="main-center"&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
      &lt;/el-main&gt;
    &lt;/el-container&gt;
  &lt;/el-container&gt;
&lt;/template&gt;</code></pre> 
<p>启动服务，查看运行效果。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f9/e4/STJzUwXU_o.png"></p> 
<h4 id="3.3.2%20getter%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96store%E4%B8%AD%E7%9A%84%E5%80%BC">3.3.2 getter方式获取store中的值</h4> 
<p>编辑/store/getters.js</p> 
<pre><code class="language-javascript">//getters将state中定义的值暴露在this.$store.getters对象中
//可以通过如下代码访问:this.$store.getters.getLeftAsideState
const getters = {

  //参数state即为stroe中存放的state，在state.js定义
  getLeftAsideState: function(state) {
    return state.LeftAsideState;
  }

}

export default getters</code></pre> 
<p>将Main.vue组件中访问store中数据的方式修改为getters方式。</p> 
<pre><code class="language-javascript">/*
 * 通过计算属性读取store中的值,并根据获取到的值返回展开或折叠样式。
 */
computed: {
  leftAsideClass: function() {
    //可以通过以下的方式进行获取，但是不推荐。
    //let tmp = this.$store.state.LeftAsideState;

    //getters方式获取状态值
    let tmp = this.$store.getters.getLeftAsideState;
    return tmp == 'open' ? "main-aside" : "main-aside-collapsed";
  }
}</code></pre> 
<h3 id="3.4%20LeftAside.vue%E7%BB%84%E4%BB%B6"><span style="color:#4da8ee;">3.4 LeftAside.vue组件</span></h3> 
<pre><code class="language-javascript"> computed: {
      //通过计算属性获取定义在store中的状态值，并根据状态值来设定返回值，用于标记左侧栏展开或折叠的状态
      //因为命名冲突，可将上面再data中定义的同名属性删除.
      isCollapse: function() {
        return this.$store.getters.getLeftAsideState == 'open' ? false : true;
      }
    }</code></pre> 
<p>至此，展开或折叠效果使用vuex方式修改完毕。运行项目查看运行效果。</p> 
<h2 id="4.%20%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span style="color:#fe2c24;">4. 异步处理</span></h2> 
<blockquote> 
 <p>同步<br> 同步模式，即上述所说的单线程模式，一次只能执行一个任务，函数调用后需等到函数执行结束，<br> 返回执行的结果，才能进行下一个任务。如果这个任务执行的时间较长，就会导致「线程阻塞」</p> 
</blockquote> 
<pre><code class="language-javascript">var x = true;
while(x);
console.log("don't carry out"); //不会执行</code></pre> 
<blockquote> 
 <p>异步<br> 异步模式，即与同步模式相反，可以一起执行多个任务，函数调用后不会立即返回执行的结果，<br> 如果任务A需要等待，可先执行任务B，等到任务A结果返回后再继续回调。 异步常见的使用场景是后台耗时的任务。</p> 
</blockquote> 
<p>js中最常见的异步是定时器</p> 
<pre><code class="language-javascript">setTimeout(function(){
    console.log("async task .... ");
}, 3000);</code></pre> 
<h2 id="4.1%20%E5%BC%82%E6%AD%A5%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0"><span style="color:#4da8ee;">4.1 异步修改参数</span></h2> 
<blockquote> 
 <p>现做一个异步修改参数值的简单示例：</p> 
</blockquote> 
<p>1） 在store中声明一个参数</p> 
<pre><code class="language-javascript">//存放全局参数的容器，组件可以通过state.js获取全局参数
const state = {
  LeftAsideState: 'open',
  
  //声明一个存放人员名称的参数，设置默认值，用于演示异步修改参数
  PersonName:'张飞'
}

export default state</code></pre> 
<p>2） 在mutations.js中定义修改参数的方法：</p> 
<pre><code class="language-javascript">//Mutation 必须是同步函数。为什么呢？异步方法，我们不知道什么时候状态会发生改变，所以也就无法追踪了
//如果我们需要异步操作，Mutations就不能满足我们需求了，这时候我们就需要Actions了
const mutations = {

  //state，即state.js中定义的state，借此可以访问state中定义的全局变量
  //payload: 载荷,保存传递参数的容器
  setLeftAsideState: (state, payload) =&gt; {
    //通过载荷为全局参数赋值，相当于setter
    state.LeftAsideState = payload.LeftAsideState;
  },

  //设置人员名称，用于演示异步
  setPersonName: (state, payload) =&gt; {
    state.PersonName = payload.PersonName;
  }

}

export default mutations</code></pre> 
<p>3）在getters.js中定义获取参数的方法</p> 
<pre><code class="language-javascript">//getters将state中定义的值暴露在this.$store.getters对象中
//可以通过如下代码访问:this.$store.getters.getLeftAsideState
const getters = {

  //参数state即为stroe中存放的state，在state.js定义
  getLeftAsideState: function(state) {
    return state.LeftAsideState;
  },

  //定义获取人员名称的方法
  getPersonName: function(state) {
    return state.PersonName;
  }

}

export default getters</code></pre> 
<p>4） 编辑actions.js添加异步设置参数功能</p> 
<pre><code class="language-javascript">/*
 * Action与mutation定义语法类型，不同点：
 * 1) Action提交的是mutation，而不是直接变更状态，mutation直接变更状态
 * 2) Action可以包含任意异步操作
 * 3) Action的回调函数接收一个 context 上下文参数
 * 详见方法内的注释
 */
const actions = {

  /*
   * context为上下文参数，与 store 实例有着相同的方法和属性
   * context参数包含：state、rootState、getters、mutations、actions 五个属性
   * payload为负载，是一个存放需要传递的参数的容器，和mutations的含义一致
   */
  setPersonNameAsyn: function(context, payload) {
    
    //异步操作，第一个参数为一个匿名函数，第二参数为延迟的时间，单位为毫秒。
    //作用：在3秒或调用第一个参数定义的匿名函数。
    setTimeout(function() {
      
      //action提交的是mutation，而不能直接变更状态
      //第一个参数setPersonName即为mutation中定义的方法名
      //payload即为参数容器。
      //通过context的commit方法提交一个mutation，由mutation负责
      //修改参数，action负责提供异步功能，（mutation必须是同步的）
      context.commit('setPersonName', payload);
    }, 3000);
  }

}

export default actions</code></pre> 
<p>5） 编辑Home.vue用于演示异步设置操作</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;首页&lt;/h1&gt;
    &lt;p&gt;
      {<!-- -->{personName}}
    &lt;/p&gt;
    &lt;p&gt;
      &lt;button @click="setPersonName"&gt;异步设置人员名称&lt;/button&gt;
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    name: 'Home',
    data: function() {
      return {

      }
    },
    computed: {
      personName: function() {
        return this.$store.getters.getPersonName;
      }
    },
    methods: {
      setPersonName: function() {
        //调用定义在actions中的方法，调用方式如下：
        //this.$store.dispatch(type,payload);
        //第一个参数type: 定义在actions中的方法名
        //第二个参数payload：负载（一个json对象），即要传递的参数
        this.$store.dispatch('setPersonNameAsyn', {
          PersonName: '关羽'
        });
      }
    }
  }
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;</code></pre> 
<p>现在可以运行程序，体验异步操作。</p> 
<h2 id="5.%20%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E5%90%8E%E5%8F%B0%E6%96%B9%E6%B3%95"><span style="color:#fe2c24;">5. 异步调用后台方法</span></h2> 
<h3 id="5.1%20%E5%87%86%E5%A4%87%E5%90%8E%E5%8F%B0%E6%96%B9%E6%B3%95"><span style="color:#4da8ee;">5.1 准备后台方法</span></h3> 
<blockquote> 
 <p>准备一个后台接口，可以让其睡眠几秒钟再返回数据，以模拟耗时的后台处理过程。</p> 
</blockquote> 
<h3 id="5.2%20%E9%85%8D%E7%BD%AEapi%2Factions.js"><span style="color:#4da8ee;">5.2 配置api/actions.js</span></h3> 
<blockquote> 
 <p>配置api/action.js，加入准备好的后台接口。</p> 
</blockquote> 
<pre><code class="language-javascript">//VUEX 异步请求后台数据
'VUE_ASYN_REQ':'/userMsg/vueAsynAction!asynAction.action',</code></pre> 
<h3 id="5.3%20store%2Factions.js"><span style="color:#4da8ee;">5.3 store/actions.js</span></h3> 
<blockquote> 
 <p>在store/actions.js中增加发送ajax请求的方法。</p> 
</blockquote> 
<pre><code class="language-javascript">const actions = {
  
  ......
  
  /*
   * 在actions.js中无法直接获取vue实例的this对象，但需要该对象来获取axios
   * 对象，以便于发送ajax请求，可以通过payload参数由调用者传入vue实例的this
   * 对象。
   */
  getDataFromApiAsyn: function(context, payload) {
    let _this = payload._this;
    let url = _this.axios.urls.VUE_ASYN_REQ;

    _this.axios.post(url, {
      param: payload.PersonName
    }).then(resp =&gt; {

      //通过resp响应对象获取返回的数据，并赋予payload
      payload.PersonName = resp.data.data;

      //提交一个mutation，用于设置state中的参数。
      context.commit('setPersonName', payload);
    }).catch(error =&gt; {

    })
  }
  
  ......
  
 }</code></pre> 
<h3 id="5.4%20Home.vue"><span style="color:#4da8ee;">5.4 Home.vue</span></h3> 
<p>在Home.vue组件中，加入异步获取后台数据的方法。</p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;首页&lt;/h1&gt;
    &lt;p&gt;
      {<!-- -->{personName}}
    &lt;/p&gt;
    &lt;p&gt;
      &lt;button @click="setPersonName"&gt;异步设置人员名称&lt;/button&gt;
      &lt;button @click="doAjaxReq"&gt;异步获取后台数据&lt;/button&gt;
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    name: 'Home',

    data: function() {
      return {

      }
    },

    computed: {
      personName: function() {
        return this.$store.getters.getPersonName;
      }
    },

    methods: {
      setPersonName: function() {
        //调用定义在actions中的方法，调用方式如下：
        //this.$store.dispatch(type,payload);
        //第一个参数type: 定义在actions中的方法名
        //第二个参数payload：负载（一个json对象），即要传递的参数
        this.$store.dispatch('setPersonNameAsyn', {
          PersonName: '关羽'
        });
      },

      doAjaxReq: function() {
        //因为在actions中需要使用vue实例中的this参数，
        //所以在此处将this参数作为负载传入。
        this.$store.dispatch('getDataFromApiAsyn', {
          PersonName: '赵云',
          _this: this
        });
      }
    }
  }
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;</code></pre> 
<h2 id="6.%20Vuex%E7%9A%84%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span style="color:#fe2c24;"><strong>6. Vuex的常用辅助函数</strong></span></h2> 
<p>mapState/mapGetters/mapMutations/mapActions</p> 
<p>以mapGetters为例：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bb/02/WVoP98Kw_o.png"></p> 
<h2 id="%C2%A07.%20vuex%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96"><span style="color:#fe2c24;"> 7. vuex的模块化</span></h2> 
<blockquote> 
 <p>vuex的模块化是为了在大型项目中，更好的管理store中的数据。在大型项目中store中的数据会非常多，直接放在store中容器引发混乱，这时候就需要模块化的管理。</p> 
</blockquote> 
<p>示例：<br> 在store目录中创建一个usermsg目录，在其中创建一个user-msg.js，如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a0/ac/G0zPY7jA_o.png"></p> 
<p> 修改store/index.js文件：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f3/00/phQP5TP6_o.png"></p> 
<p>在Home.vue组件上测试：<br> 图一：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3f/44/eseNs3l5_o.png"></p> 
<p>图二：</p> 
<p><img alt="" src="https://images2.imgbox.com/6c/2d/d6NBPp10_o.png"></p> 
<p>还可以使用如下方式获取模块中的值：this.$store.state.userMsg.userName; 但不建议使用。</p> 
<h2 id="8.%20vuex%E7%8A%B6%E6%80%81%E6%8C%81%E4%B9%85%E5%8C%96"><span style="color:#fe2c24;">8. vuex状态持久化</span></h2> 
<blockquote> 
 <p>Vuex 解决了多视图之间的数据共享问题。但是运用过程中又带来了一个新的问题是，Vuex 的状态存储并不能持久化。也就是说当你存储在 Vuex 中的 store 里的数据，只要一刷新页面，数据就丢失了。</p> 
</blockquote> 
<blockquote> 
 <p>引入vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中。</p> 
</blockquote> 
<p>1） 安装</p> 
<pre><code class="language-javascript">npm install vuex-persist -S</code></pre> 
<p>2）导入及配置：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d2/82/HHbvcKKk_o.png"></p> 
<h2><span style="color:#ed7976;"> 以上就是今天的分享，感谢大家的观赏！！！</span></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/60019c623d584d8b1f8cf2fa6ca2d21d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FlinkSql的窗口使用以及运用案例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b7c2e10f3a6e6c09be81835eb03c266/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mac 安装 vue 环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>