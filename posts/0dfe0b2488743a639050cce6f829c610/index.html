<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java实现操作系统的进程调度-- 抢占式优先权调度算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java实现操作系统的进程调度-- 抢占式优先权调度算法" />
<meta property="og:description" content="大半年的失踪人口回归，陆续会把草稿箱里的10&#43;篇博客都补充完整，立flag！！！
优先权调度算法： 按照根据每个作业的优先数，依次执行每一个作业
非抢占式优先权调度算法：只确定一次作业的优先级，按照优先数由高到低依次执行每个作业，当前作业完成才能进行下一个作业
抢占式优先权调度算法：不同于非抢占式优先权调度算法，抢占式优先权调度算法会多次进行优先级排序。我们规定一个时间片，用来把一个作业分成多个部分。一个时间片内执行一个作业的一部分，每经过一个时间片，就进行一次优先级排序，每次都只执行优先级最高的作业，当然作业每执行一次，其优先级会降低。
有一群狮子抢食，同一时间只能一只狮子享用，根据物竞天择法则，应当是最强的那头先享用。
非抢占式是最强的吃完--&gt;第二强的吃完--&gt;........--&gt;最弱吃完。像是一个有序的狮群，每头都服从领袖。
而抢占式的竞争更激烈，即使是决斗中的胜者，也只能安稳的吃一口，在这一口之后就会有其他狮子来决斗，再由新获胜的狮子来进食，即一直是每轮比试中的第一名享用。像是一个无领袖的狮群，每个都想当领袖。
下面上代码：
pcb类： package Processscheduling2; public class Pcb { public int id; public String state=&#34;stop&#34;;//状态 F完成 W等待 R运行 public int youxianshu;//优先数 public int needtime;//作业长短 public Pcb(int id,int youxinashu,int needtime){ this.id=id; this.youxianshu=youxinashu; this.needtime=needtime; } public Pcb(int id,int needtime){ this.id=id; //	this.youxianshuu=youxinashu; this.needtime=needtime; } } 进程调度类： 偷个懒，用线程控制一个时间片的时间，也可以用系统时间差来规定时间片。
每执行一次，该作业所需时间-1，优先数-3
package Processscheduling2; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.Scanner; public class ProcessScheduling extends Thread { public static void main(String[] args) { // TODO Auto-generated method stub ProcessScheduling p = new ProcessScheduling(); p." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0dfe0b2488743a639050cce6f829c610/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-01T18:46:02+08:00" />
<meta property="article:modified_time" content="2019-05-01T18:46:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java实现操作系统的进程调度-- 抢占式优先权调度算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>大半年的失踪人口回归，陆续会把草稿箱里的10+篇博客都补充完整，立flag！！！</p> 
<blockquote> 
 <h2><strong>优先权调度算法</strong>：</h2> 
 <p>按照根据每个作业的优先数，依次执行每一个作业</p> 
 <p><strong> 非抢占式优先权调度算法</strong>：只确定一次作业的优先级，按照优先数由高到低依次执行每个作业，当前作业完成才能进行下一个作业</p> 
 <p><strong> 抢占式优先权调度算法</strong>：不同于<strong>非抢占式优先权调度算法，抢占式优先权调度算法</strong>会多次进行优先级排序。我们规定一个时间片，用来把一个作业分成多个部分。一个时间片内执行一个作业的一部分，每经过一个时间片，就进行一次优先级排序，每次都只执行优先级最高的作业，当然作业每执行一次，其优先级会降低。</p> 
 <p> </p> 
 <p>有一群狮子抢食，同一时间只能一只狮子享用，根据物竞天择法则，应当是最强的那头先享用。</p> 
 <p>非抢占式是最强的吃完--&gt;第二强的吃完--&gt;........--&gt;最弱吃完。像是一个有序的狮群，每头都服从领袖。</p> 
 <p>而抢占式的竞争更激烈，即使是决斗中的胜者，也只能安稳的吃一口，在这一口之后就会有其他狮子来决斗，再由新获胜的狮子来进食，即一直是每轮比试中的第一名享用。像是一个无领袖的狮群，每个都想当领袖。</p> 
</blockquote> 
<p>下面上代码：</p> 
<h3>pcb类：</h3> 
<pre class="has"><code class="language-java">package Processscheduling2;

public class Pcb {
public int id;
public String state="stop";//状态  F完成 W等待  R运行
public int youxianshu;//优先数
public int needtime;//作业长短
public  Pcb(int id,int youxinashu,int needtime){
	this.id=id;
	this.youxianshu=youxinashu;
	this.needtime=needtime;
	}

public  Pcb(int id,int needtime){
	this.id=id;
//	this.youxianshuu=youxinashu;
	this.needtime=needtime;
	}


}
</code></pre> 
<h3>进程调度类：</h3> 
<p>偷个懒，用线程控制一个时间片的时间，也可以用系统时间差来规定时间片。</p> 
<p><span style="color:#7c79e5;"><strong>每执行一次，该作业所需时间-1，优先数-3</strong></span></p> 
<pre class="has"><code class="language-java">package Processscheduling2;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Scanner;

public class ProcessScheduling extends Thread {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		ProcessScheduling p = new ProcessScheduling();
		p.select();
	}

	private int num;
	private ArrayList&lt;Pcb&gt; mes = new ArrayList&lt;Pcb&gt;();
	private ArrayList&lt;Pcb&gt; use = new ArrayList&lt;Pcb&gt;();
	private ArrayList&lt;Pcb&gt; finish = new ArrayList&lt;Pcb&gt;();
	private ArrayList&lt;Pcb&gt; run = new ArrayList&lt;Pcb&gt;();
	private boolean flag = true;
	private int count;
	private String option=null;
	private void select() {
		// TODO Auto-generated method stub
		System.out.println("******************************************");
		System.out.println("*************   优先级调度   ************");
			// 优先数
			System.out.println("请输入进程个数");
			Scanner scan = new Scanner(System.in);
			num = scan.nextInt();
			for (int i = 1; i &lt;= num; ++i) {
				System.out.println("请输入第" + i + "个进程名");
				Scanner sanid = new Scanner(System.in);
				int id = sanid.nextInt();
				System.out.println("请输入第" + i + "个进程优先数");
				Scanner sancount = new Scanner(System.in);
				int sanc = sanid.nextInt();
				System.out.println("请输入第" + i + "个进程所需服务时间");
				Scanner sanneed = new Scanner(System.in);
				int saneed = sanid.nextInt();
				mes.add(new Pcb(id, sanc, saneed));
				use.add(new Pcb(id, sanc, saneed));
				System.out.println("");
			}
			option="youxianshu";
			this.run();
		
	}
	private void judgeSort() {
		// 进行优先数排序PrioCreateProccess()
		for (int i = 0; i &lt; use.size(); ++i) {
			for (int j = 0; j &lt; use.size(); ++j) {
				if (use.get(i).youxianshu &gt; use.get(j).youxianshu) {
					int t = use.get(i).youxianshu;
					int tt = use.get(i).id;
					int ttt = use.get(i).needtime;
					use.get(i).youxianshu = use.get(j).youxianshu;
					use.get(i).id = use.get(j).id;
					use.get(i).needtime = use.get(j).needtime;
					use.get(j).youxianshu = t;
					use.get(j).id = tt;
					use.get(j).needtime = ttt;
				}
			}
		}
	}

	@Override
	public void run() {
	if(option=="youxianshu"){
		count = 0;
		judgeSort();
		count++;
		while (flag) {
			if (run == null) {
				run.add(use.get(0));
				System.out.println("还没有进程被调度");
			}
			use.get(0).youxianshu -= 3;
			use.get(0).needtime -= 1;
			use.get(0).state = "run";
			for (int h = 1; h &lt; use.size(); h++) {
				use.get(h).state = "wait";
			}
			for (int i = 0; i &lt; use.size(); ++i) {
				if (use.get(i).needtime == 0) {
					use.get(i).state = "finish";
				}
			}
			System.out.println("经过了" + (count) + "个时间片后，" + use.get(0).id + "被调用." + "还需" + use.get(0).needtime + "时间");
			System.out.println("经过时间片数" + "      " + "进程ID" + "     " + "该进程优先数" + "    " + "所需时间片数" + "     调度状态");
//打印未完成进程		
			for (int j = 0; j &lt; use.size(); j++)
				System.out.println(count + "                  " + use.get(j).id + "        " + use.get(j).youxianshu
						+ "              " + use.get(j).needtime + "             " + use.get(j).state);
//打印完成进程		
			for (int j = 0; j &lt; finish.size(); j++)
				System.out
						.println(count + "                  " + finish.get(j).id + "        " + finish.get(j).youxianshu
								+ "              " + finish.get(j).needtime + "               " + finish.get(j).state);
			judgeSort();
			count++;

			// 如果进程结束，就加入finish，从run中走
			for (int i = 0; i &lt; use.size(); ++i) {
				if (use.get(i).needtime == 0) {
					use.get(i).state = "finish";
					finish.add(use.get(i));
					use.remove(i);
				}
			}
			if (finish.size() == num) {
				flag = false;
				System.out.println("进程全部执行");
			}
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}}
}</code></pre> 
<h3>效果图：</h3> 
<p><img alt="" class="has" height="521" src="https://images2.imgbox.com/b8/9d/XIz3djhr_o.png" width="600"></p> 
<p><img alt="" class="has" height="514" src="https://images2.imgbox.com/7a/4b/OIencjtb_o.png" width="600"></p> 
<p><img alt="" class="has" height="535" src="https://images2.imgbox.com/38/59/GTxTvRFa_o.png" width="600"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/de198ca00723caf3f4025b3aa1be9ecb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">1350：【例4-11】最短网络(agrinet)  最小生成树kruskal</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f10d7dbb1804ded7080aeedfe3010d0a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ESP8266-WIFI模块使用AT指令连接外网服务器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>