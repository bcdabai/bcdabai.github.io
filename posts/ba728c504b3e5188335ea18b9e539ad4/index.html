<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python-docx实现保留原格式的批量替换 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python-docx实现保留原格式的批量替换" />
<meta property="og:description" content="工作需要，每次项目报告都需要填写许多表单，其中有很多字段仅需要简单替换，因此自己做了个根据提示符替换多个word多个内容的小程序，并保留原格式。 首先我把模板word中的代替换部分全部改为带有启动子#的提示符，如#name，#add，再创建一个字典，其键值对分别为提示符和替换内容。
dic = {&#39;#co_name&#39;: &#39;名称&#39;, &#39;#co_add&#39;: &#39;地址&#39;} 现在提供三种替换方法：
方法1：段落替换 doc = docx.Document(&#39;test.docx&#39;) for para in doc.paragraphs: for key,value in dic.items(): if key in para: para.text=para.text.replace(key,value) 这么做的优点是方便快捷，如果你不在乎替换掉的格式，替换内容的样式默认为段落样式，你可以在模板word中设置段落的样式进行统一控制。
若段落样式和替换内容的样式不同，该方法就无法实现。例：这是要替换的内容#name。替换后的#name并不会保持红色加粗，而是和段落样式保持一致。
方法2：runs替换（简易） 在paragraphs之下，还可以分为runs，runs即为连续的字块。
doc = docx.Document(&#39;test.docx&#39;) for para in doc.paragraphs: for run in para.runs: if run.text in list(dic.keys()) run.text=run.text.replace(run.text,dic[run.text]) 这样即可实现替换内容保持原样式，但这么做存在弊端，即提示符可能会被拆分为多个run。如果只做简单替换，提示符为name，采用上述方法即可。若替换内容众多，且提示符需要在word中一目了然，如上述采用了#co_name，那么该提示符会被分成4个runs，如#，co，_，name。此时就需要采用方法3。
方法3：runs替换（复杂） for para in doc.paragraphs: runs = para.runs for i, run in enumerate(runs): if run.text == &#39;#&#39;: count = i # 记录启动子位置 tmp = &#39;#&#39; # tmp写入启动子 while tmp not in list(dic." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ba728c504b3e5188335ea18b9e539ad4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-02T10:50:58+08:00" />
<meta property="article:modified_time" content="2023-07-02T10:50:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python-docx实现保留原格式的批量替换</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>工作需要，每次项目报告都需要填写许多表单，其中有很多字段仅需要简单替换，因此自己做了个根据提示符替换多个word多个内容的小程序，并保留原格式。 </p> 
<p>首先我把模板word中的代替换部分全部改为带有<strong>启动子#</strong>的<strong>提示符</strong>，如#name，#add，再创建一个字典，其键值对分别为<strong>提示符</strong>和<strong>替换内容</strong>。</p> 
<pre><code class="language-python">dic = {'#co_name': '名称', '#co_add': '地址'}</code></pre> 
<hr> 
<p> 现在提供三种替换方法：</p> 
<h2>方法1：段落替换</h2> 
<pre><code class="language-python">doc = docx.Document('test.docx')
for para in doc.paragraphs:
    for key,value in dic.items():
        if key in para:
            para.text=para.text.replace(key,value)</code></pre> 
<p>这么做的优点是方便快捷，如果你不在乎替换掉的格式，<strong>替换内容</strong>的样式默认为段落样式，你可以在模板word中设置段落的样式进行统一控制。</p> 
<p>若段落样式和替换内容的样式不同，该方法就无法实现。例：这是要替换的内容<strong><span style="color:#fe2c24;">#name</span></strong>。替换后的#name并不会保持<strong><span style="color:#fe2c24;">红色加粗</span></strong>，而是和段落样式保持一致。</p> 
<h2>方法2：runs替换（简易）</h2> 
<p>在paragraphs之下，还可以分为runs，runs即为连续的字块。</p> 
<pre><code class="language-python">doc = docx.Document('test.docx')
for para in doc.paragraphs:
    for run in para.runs:
        if run.text in list(dic.keys())
            run.text=run.text.replace(run.text,dic[run.text])</code></pre> 
<p>这样即可实现<strong>替换内容</strong>保持原样式，但这么做存在弊端，即<strong>提示符</strong>可能会被拆分为多个run。如果只做简单替换，提示符为name，采用上述方法即可。若替换内容众多，且提示符需要在word中一目了然，如上述采用了#co_name，那么该提示符会被分成4个runs，如#，co，_，name。此时就需要采用方法3。</p> 
<h2>方法3：runs替换（复杂）</h2> 
<pre><code class="language-python">for para in doc.paragraphs:
    runs = para.runs
    for i, run in enumerate(runs):
        if run.text == '#':
            count = i  # 记录启动子位置
            tmp = '#'  # tmp写入启动子
            while tmp not in list(dic.keys()):  # tmp继续写入启动子后的run，直到tmp和dic中的键匹配
                count += 1
                tmp += runs[count].text
                runs[count].clear()
            runs[i].text = runs[i].text.replace(runs[i].text, dic[tmp])</code></pre> 
<p>方法3实现了<strong>复杂提示符</strong>的替换功能，并保留原样式，实现逻辑如下：</p> 
<ol><li>启动子#会被单独识别为一个run，故遍历到<strong>启动子#</strong>时，替换过程开启；</li><li>count记录该<strong>提示符#</strong>是第几个run；</li><li>不断向tmp中添加runs，直到tmp等于dic中的某个键名（while循环）</li><li>向tmp添加run的同时，不断删除原本的run，即runs[count].clear()。可以理解为把<strong>启动子#</strong>后的run剪切到tmp中了；</li><li>while循环结束后开始替换，还记的count是记录提示符#的位置吗，直接将提示符#替换为<strong>替换内容，</strong>替换终止。</li></ol> 
<hr> 
<p>以上，我们便完成了三种方法的word文档内容替换，可以做如下总结：</p> 
<ol><li>如果不关心替换内容样式，用方法1</li><li>如果要求替换内容保留原样式，但提示符可以被识别为一个run，用方法2</li><li>如果要求替换内容保留原样式，但提示符不能被识别为一个run，用方法3</li></ol> 
<p>注：提示符之间不能有包含关系，如#co_name和#co_name_en，这样会导致后者无法被识别，这在word中手工替换也是同样的道理。 </p> 
<hr> 
<p> 此外，如果你还想替换word中的表格、页眉、页脚内容，只需要在上面多加几个循环：</p> 
<p>1、表格内容替换</p> 
<pre><code class="language-python">for table in doc.tables:
    for row in table.rows:
        for cell in row.cells
            for para in cell.paragraphs:
'''
后续内容同上述三个方法
'''
</code></pre> 
<p>2、页眉页脚内容替换</p> 
<pre><code class="language-python">for sec in doc.sections:
    for para in sec.header.paragraphs：
'''
后续内容同上述三个方法，如果想替换页脚，把header改为footer
'''</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2d4e3236221b403ea4747e2ebeb4fbeb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">汇编学习笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2976b30900f2e46be8952e4b68d8e5a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">最近在使用generator插件生成mybatis代码，遇到Could not autowire. No beans of ‘xxx‘ type found.异常</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>