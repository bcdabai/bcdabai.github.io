<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Docker】Linux中Docker镜像结构及自定义镜像，并且上传仓库可提供使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Docker】Linux中Docker镜像结构及自定义镜像，并且上传仓库可提供使用" />
<meta property="og:description" content="目录
一、镜像结构
1. 基本结构
2. 常用命令
二、自定义镜像
1. 基本镜像
2. 进阶镜像
3. 完善镜像
三、镜像上传仓库
每篇一获
一、镜像结构 自定义 Docker 镜像有很多用途，以下是一些主要的应用场景：
一致性环境：通过自定义镜像，您可以确保您的应用在不同的环境中（开发、测试、生产等）运行在完全一致的环境中。这可以避免&#34;在我机器上可以运行&#34;的问题。
快速部署：自定义镜像包含了运行应用所需的所有依赖，这使得部署过程变得非常快速和简单。只需运行一个命令，就可以在任何安装了 Docker 的机器上启动应用。
版本控制和回滚：每个 Docker 镜像都有一个唯一的标签，这使得版本控制变得非常简单。如果新版本的应用有问题，您可以很容易地回滚到旧版本的镜像。
微服务架构：在微服务架构中，每个服务都可以有自己的 Docker 镜像。这使得每个服务可以独立地更新和扩展，而不会影响其他服务。
持续集成/持续部署（CI/CD）：在 CI/CD 管道中，自定义镜像可以用于构建、测试和部署应用。这使得整个开发过程更加自动化，提高了开发效率。
1. 基本结构 Dockerfile 是一个文本文件，它包含了一组用户可以调用来创建镜像的指令。以下是 Dockerfile 的基本结构：
FROM：指定基础镜像，所有操作都基于这个基础镜像。例如：FROM ubuntu:18.04
LABEL：为镜像添加元数据及声明镜像的作者或者维护者的信息。
RUN：在镜像中运行命令，这些命令会在新的层上创建新的镜像。例如：RUN apt-get update
CMD：提供容器默认的可执行程序，可以包含可执行程序，也可以省略，如果省略，则必须在运行时通过命令行指定。例如：CMD [&#34;executable&#34;,&#34;param1&#34;,&#34;param2&#34;]
EXPOSE：声明运行时容器提供服务的网络端口。例如：EXPOSE 8080
ENV：设置环境变量。例如：ENV myName=&#34;John Doe&#34; myDog=Rex\ The\ Dog
ADD 和 COPY：将文件从 Docker 主机复制到 Docker 镜像中。ADD 有自动解压缩功能，COPY 则更为直接明了。
ENTRYPOINT：配置容器启动后执行的命令，并且不会被 docker run 提供的参数覆盖。
VOLUME：创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保存的数据等。
WORKDIR：设置工作目录，所有后续的操作（CMD、ENTRYPOINT、COPY 和 ADD）都会在这个目录下进行。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6c6ae4d6b7259e5835897e29615a0ffa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-13T22:54:04+08:00" />
<meta property="article:modified_time" content="2024-01-13T22:54:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Docker】Linux中Docker镜像结构及自定义镜像，并且上传仓库可提供使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E9%95%9C%E5%83%8F%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E9%95%9C%E5%83%8F%E7%BB%93%E6%9E%84" rel="nofollow">一、镜像结构</a></p> 
<p id="1.%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84" rel="nofollow">1. 基本结构</a></p> 
<p id="2.%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-toc" style="margin-left:40px;"><a href="#2.%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" rel="nofollow">2. 常用命令</a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F" rel="nofollow">二、自定义镜像</a></p> 
<p id="1.%20%E5%9F%BA%E6%9C%AC%E9%95%9C%E5%83%8F-toc" style="margin-left:40px;"><a href="#1.%20%E5%9F%BA%E6%9C%AC%E9%95%9C%E5%83%8F" rel="nofollow">1. 基本镜像</a></p> 
<p id="2.%20%E8%BF%9B%E9%98%B6%E9%95%9C%E5%83%8F-toc" style="margin-left:40px;"><a href="#2.%20%E8%BF%9B%E9%98%B6%E9%95%9C%E5%83%8F" rel="nofollow">2. 进阶镜像</a></p> 
<p id="3.%20%E5%AE%8C%E5%96%84%E9%95%9C%E5%83%8F-toc" style="margin-left:40px;"><a href="#3.%20%E5%AE%8C%E5%96%84%E9%95%9C%E5%83%8F" rel="nofollow">3. 完善镜像</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93" rel="nofollow">三、镜像上传仓库</a></p> 
<p id="%E6%AF%8F%E7%AF%87%E4%B8%80%E8%8E%B7-toc" style="margin-left:0px;"><a href="#%E6%AF%8F%E7%AF%87%E4%B8%80%E8%8E%B7" rel="nofollow">每篇一获</a></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E9%95%9C%E5%83%8F%E7%BB%93%E6%9E%84" style="background-color:transparent;">一、镜像结构</h2> 
<blockquote> 
 <p>自定义 Docker 镜像有很多用途，以下是一些主要的应用场景：</p> 
</blockquote> 
<ol><li> <p><em><span style="color:#be191c;"><strong>一致性环境</strong></span></em>：通过自定义镜像，您可以确保您的应用在不同的环境中（开发、测试、生产等）运行在完全一致的环境中。这可以避免"在我机器上可以运行"的问题。</p> </li><li> <p><em><span style="color:#b95514;"><strong>快速部署</strong></span></em>：自定义镜像包含了运行应用所需的所有依赖，这使得部署过程变得非常快速和简单。只需运行一个命令，就可以在任何安装了 Docker 的机器上启动应用。</p> </li><li> <p><em><span style="color:#1c7331;"><strong>版本控制和回滚</strong></span></em>：每个 Docker 镜像都有一个唯一的标签，这使得版本控制变得非常简单。如果新版本的应用有问题，您可以很容易地回滚到旧版本的镜像。</p> </li><li> <p><em><span style="color:#1a439c;"><strong>微服务架构</strong></span></em>：在微服务架构中，每个服务都可以有自己的 Docker 镜像。这使得每个服务可以独立地更新和扩展，而不会影响其他服务。</p> </li><li> <p><strong><em><span style="color:#1c7892;">持续集成/持续部署</span></em>（CI/CD）</strong>：在 CI/CD 管道中，自定义镜像可以用于构建、测试和部署应用。这使得整个开发过程更加自动化，提高了开发效率。</p> </li></ol> 
<h3 id="1.%20%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">1. 基本结构</h3> 
<blockquote> 
 <p>Dockerfile 是一个文本文件，它包含了一组用户可以调用来创建镜像的指令。以下是 Dockerfile 的基本结构：</p> 
</blockquote> 
<ol><li> <p><strong>FROM</strong>：指定基础镜像，所有操作都基于这个基础镜像。例如：<code>FROM ubuntu:18.04</code></p> </li><li> <p><strong>LABEL</strong>：为镜像添加元数据及声明镜像的作者或者维护者的信息。</p> </li><li> <p><strong>RUN</strong>：在镜像中运行命令，这些命令会在新的层上创建新的镜像。例如：<code>RUN apt-get update</code></p> </li><li> <p><strong>CMD</strong>：提供容器默认的可执行程序，可以包含可执行程序，也可以省略，如果省略，则必须在运行时通过命令行指定。例如：<code>CMD ["executable","param1","param2"]</code></p> </li><li> <p><strong>EXPOSE</strong>：声明运行时容器提供服务的网络端口。例如：<code>EXPOSE 8080</code></p> </li><li> <p><strong>ENV</strong>：设置环境变量。例如：<code>ENV myName="John Doe" myDog=Rex\ The\ Dog</code></p> </li><li> <p><strong>ADD</strong> 和 <strong>COPY</strong>：将文件从 Docker 主机复制到 Docker 镜像中。ADD 有自动解压缩功能，COPY 则更为直接明了。</p> </li><li> <p><strong>ENTRYPOINT</strong>：配置容器启动后执行的命令，并且不会被 docker run 提供的参数覆盖。</p> </li><li> <p><strong>VOLUME</strong>：创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保存的数据等。</p> </li><li> <p><strong>WORKDIR</strong>：设置工作目录，所有后续的操作（CMD、ENTRYPOINT、COPY 和 ADD）都会在这个目录下进行。</p> </li><li> <p><strong>USER</strong>：设置运行容器时的用户名或 UID。</p> </li><li> <p><strong>ONBUILD</strong>：当构建一个被继承的 Dockerfile 时运行命令，该指令添加到镜像中，稍后触发。</p> </li><li> <p><strong>MAINTAINER</strong> ：用于声明镜像的作者或者维护者的信息，它可以为使用者提供一种联系镜像创建者的方式。</p> </li></ol> 
<blockquote> 
 <p>需要注意的是，<strong>MAINTAINER</strong> 从 Docker 1.13.0 开始，这个指令已经被标记为已废弃，推荐使用 <strong><code>LABEL</code> </strong>指令来替代。</p> 
</blockquote> 
<p>例：</p> 
<pre><code class="hljs">MAINTAINER John Doe &lt;john.doe@example.com&gt;
</code></pre> 
<p> 如：</p> 
<pre><code class="hljs">LABEL maintainer="John Doe &lt;john.doe@example.com&gt;"</code></pre> 
<p><code>LABEL</code> 指令可以用于添加更多的元数据到镜像中，比如版本号、构建日期等等。</p> 
<blockquote> 
 <p>这些指令在 Dockerfile 中按照从上到下的顺序执行。每个指令都会在镜像上创建一个新的层，然后提交。</p> 
</blockquote> 
<p><strong>案例：</strong></p> 
<pre><code class="hljs"># 基于官方的 JDK 镜像
FROM openjdk:8-jdk
# 设置环境变量
ENV CATALINA_HOME /usr/local/tomcat
ENV PATH $CATALINA_HOME/bin:$PATH
# 安装 MySQL
RUN apt-get update &amp;&amp; apt-get install -y mysql-server
# 安装 Tomcat
RUN mkdir -p "$CATALINA_HOME"
WORKDIR $CATALINA_HOME
RUN curl -O https://downloads.apache.org/tomcat/tomcat-8/v8.5.61/bin/apache-tomcat-8.5.61.tar.gz \
&amp;&amp; tar -xvf apache-tomcat-8.5.61.tar.gz \
&amp;&amp; rm apache-tomcat-8.5.61.tar.gz
# 暴露端口
EXPOSE 8080
# 启动 Tomcat
CMD ["catalina.sh", "run"]</code></pre> 
<blockquote> 
 <p>这个 Dockerfile 会创建一个包含 JDK、MySQL 和 Tomcat 的 Docker 镜像。在构建镜像时，它会先从 Docker Hub 下载官方的 JDK 镜像作为基础镜像，然后安装 MySQL，接着下载并安装 Tomcat，最后设置启动命令为启动 Tomcat。</p> 
</blockquote> 
<blockquote> 
 <p>请注意，这只是一个基础示例，实际使用时可能需要根据具体需求进行修改和优化。例如，可能需要添加更多的环境变量，或者调整安装命令以适应特定的应用需求。</p> 
</blockquote> 
<h3 id="2.%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">2. 常用命令</h3> 
<p>以下是您提到的 Dockerfile 指令的详细解释：</p> 
<ol><li> <p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有两种格式：<code>RUN &lt;command&gt;</code>（shell 格式）和 <code>RUN ["executable", "param1", "param2"]</code>（exec 格式）。</p> </li><li> <p><strong>ENV</strong>：用于设置环境变量。这些变量以 <code>&lt;key&gt;=&lt;value&gt;</code> 的形式存在，可以在容器中被脚本或程序调用。</p> </li><li> <p><strong>COPY</strong>：将来自 Dockerfile 所在目录的文件或目录复制到容器中的一个新位置。</p> </li><li> <p><strong>ADD</strong>：与 COPY 类似，但是 ADD 允许后面的源参数是一个 URL，或者在源文件是一个 tar 文件的情况下，可以自动解压缩这个 tar 文件。</p> </li><li> <p><strong>EXPOSE</strong>：用于声明容器运行时监听的网络端口。</p> </li><li> <p><strong>WORKDIR</strong>：用于设置 RUN、CMD、ENTRYPOINT、COPY 和 ADD 指令的工作目录。</p> </li><li> <p><strong>ONBUILD</strong>：当镜像被用作其他 Dockerfile 的基础镜像时，ONBUILD 指令将会被触发执行。</p> </li><li> <p><strong>USER</strong>：用于设置接下来的 RUN、CMD 和 ENTRYPOINT 指令运行时的 UID。</p> </li><li> <p><strong>VOLUME</strong>：用于在容器中创建一个挂载点，用于连接 Docker 主机和容器的文件系统。</p> </li></ol> 
<p><strong>容器启动时自动执行指令：</strong></p> 
<p><strong>CMD</strong> 和 <strong>ENTRYPOINT</strong> 都是 Dockerfile 中用于指定容器启动时运行的命令的指令，但它们的用法和目的有所不同。</p> 
<ol><li> <p><strong>CMD</strong>：CMD 指令用于提供容器运行时的默认命令及其参数。在启动容器时，我们可以覆盖这些默认的参数。CMD 在 Dockerfile 中只应被定义一次，如果定义了多次，只有最后一次的定义会生效。CMD 有两种格式：</p> <p>如果 Dockerfile 中同时存在 CMD 和 ENTRYPOINT，CMD 中的参数会被添加到 ENTRYPOINT 中，作为其参数。</p> 
  <blockquote> 
   <ul><li><code>CMD ["executable","param1","param2"]</code>（exec 格式，推荐）</li><li><code>CMD command param1 param2</code>（shell 格式）</li></ul> 
  </blockquote> </li><li> <p><strong>ENTRYPOINT</strong>：ENTRYPOINT 的目的也是让容器以应用程序或服务的形式运行。与 CMD 不同，我们在启动容器时不能覆盖 ENTRYPOINT 指令提供的命令，但可以添加额外的参数。ENTRYPOINT 有两种格式：</p> <p>如果我们既想让容器以应用程序或服务的形式运行，又想让这些应用或服务接受参数，那么最好的做法是使用 ENTRYPOINT 和 CMD 一起使用，让 ENTRYPOINT 指定应用程序，而让 CMD 指定默认参数。</p> 
  <blockquote> 
   <ul><li><code>ENTRYPOINT ["executable", "param1", "param2"]</code>（exec 格式，推荐）</li><li><code>ENTRYPOINT command param1 param2</code>（shell 格式）</li></ul> 
  </blockquote> </li></ol> 
<h2 id="%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F" style="background-color:transparent;">二、自定义镜像</h2> 
<h3 id="1.%20%E5%9F%BA%E6%9C%AC%E9%95%9C%E5%83%8F" style="background-color:transparent;">1. 基本镜像</h3> 
<blockquote> 
 <p>首先进入虚拟机并且用<strong>MobaXterm</strong>这个工具连接，进入后先查看<strong>docker</strong>的服务/进程有没有开：</p> 
 <p>输入命令：<span style="color:#fe2c24;">systemctl status docker   </span><span style="color:#494949;">（查看</span><strong>docker</strong>的服务/进程<span style="color:#494949;">）</span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#494949;">以下是没有开启状态：</span></p> 
 <p style="text-align:center;"><span style="color:#494949;"><img alt="" src="https://images2.imgbox.com/17/bf/XGQhmq6E_o.png"></span></p> 
</blockquote> 
<blockquote> 
 <p> <span style="color:#494949;">以下是开启状态：</span></p> 
 <p style="text-align:center;"><span style="color:#494949;"><img alt="" src="https://images2.imgbox.com/c5/0e/mURyM95Y_o.png"></span></p> 
</blockquote> 
<blockquote> 
 <p>创建一个文件夹，来存放创建后的镜像，并且创建并编写 <strong>Dockerfile </strong>文件。</p> 
</blockquote> 
<blockquote> 
 <p id="%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E5%BA%94%E7%94%A8">创建文件夹：<span style="color:#fe2c24;">mkdir soft</span>      （名称soft，可以自己修改）</p> 
 <p>进入文件夹：<span style="color:#fe2c24;">cd soft/</span></p> 
 <p>创建并编辑<strong>Dockerfile文件</strong>：<span style="color:#fe2c24;">vim Dockerfile</span>    （文件名称不用改）</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ca/f8/aMdps76L_o.png"></p> 
<blockquote> 
 <p>进入文件后，按 <span style="color:#fe2c24;">i </span>进入编辑模式，然后将以下粘贴上，在按<span style="color:#fe2c24;">Esc</span>退出编辑模式，输入<span style="color:#fe2c24;"> :wq </span></p> 
 <p>保存编写内容并且退出文件。 </p> 
</blockquote> 
<blockquote> 
 <p>在<strong>Dockerfile文件中编写：</strong><br>  </p> 
 <pre><code class="hljs">#1.指定基础镜像，并且必须是第一条指令
FROM  centos
#2.指明该镜像的作者和其电子邮件
MAINTAINER  CloudJun  "jun737x@163.com"
#3.在构建镜像时，指定镜像的工作目录，之后的命令都是基于此工作目录，如果不存在，则会创建目录
WORKDIR  /test
#4.将文件从Docker主机复制到Docker镜像中
COPY spring.jar /test</code></pre> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/db/01/umRyQCH9_o.png"></p> 
<blockquote> 
 <p>创建编写完成后，通过 docker build 命令来创建镜像。</p> 
</blockquote> 
<blockquote> 
 <p>命令：<span style="color:#fe2c24;">docker build -t spring:v1 .</span></p> 
</blockquote> 
<blockquote> 
 <p>创建语句 docker build -t ，创建后这个镜像的名称spring，这个镜像的版本为 v1 ( 版本可以自己定义，如:0.1，1.0，v1，v2都可以)，其中的  <span style="color:#fe2c24;"><code>.</code> </span>表示在当前目录创建</p> 
</blockquote> 
<blockquote> 
 <p>再查看镜像：<span style="color:#fe2c24;">docker </span><span style="color:#fe2c24;">images</span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5f/30/6NYsweXk_o.png"></p> 
<blockquote> 
 <p>进入：<span style="color:#fe2c24;">docker run -it spring:v1 </span><span style="color:#0d0016;">（spring为镜像名称，后面的:v1是需要进入镜像的哪个版本）</span></p> 
</blockquote> 
<blockquote> 
 <p>之后看看当前目录是不是自己在<strong>Dockerfile</strong>文件中所设置的，及带进来的jar包是否存在</p> 
 <p>查看当前路径：<span style="color:#fe2c24;">pwd </span></p> 
 <p>查看文件：<span style="color:#fe2c24;">ls</span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6d/a6/JaqQIL13_o.png"></p> 
<h3 id="2.%20%E8%BF%9B%E9%98%B6%E9%95%9C%E5%83%8F" style="background-color:transparent;">2. 进阶镜像</h3> 
<blockquote> 
 <p>以上的镜像是不可以jar包中的项目运行的，因为镜像中没有jdk配置。</p> 
</blockquote> 
<blockquote> 
 <p>首先，需将本地的属于Linux的jdk和jre的压缩包拖到创建的文件夹中</p> 
 <p>如图：</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d6/62/2vf1nlYm_o.png"> </p> 
</blockquote> 
<blockquote> 
 <p>以下我们来进行完善以上的缺陷: </p> 
</blockquote> 
<p><strong>以下配置jdk，可以运行jar包项目</strong></p> 
<blockquote> 
 <p>输入命令，编辑<strong>Dockerfile文件</strong>：<span style="color:#fe2c24;">vim Dockerfile</span>   ，将原来的编写全部删除。</p> 
</blockquote> 
<blockquote> 
 <p><strong>删除</strong>：进入后先将输入键到第一行，再输入数字(输入的数字是看不到的如:12)，再按两下 d ，就会删除12行已编写的内容，当然输入13或者14就删除13或者14行，可以根据自己想删除多少行来进行输入</p> 
</blockquote> 
<blockquote> 
 <p>将以下编写的内容粘贴到<strong>Dockerfile</strong>文件中，按<span style="color:#fe2c24;">Esc</span>退出编辑模式，输入<span style="color:#fe2c24;"> :wq </span>保存编写内容并且退出文件。 </p> 
</blockquote> 
<pre><code class="hljs">#1.指定基础镜像，并且必须是第一条指令
FROM  centos
#2.指明该镜像的作者和其电子邮件
MAINTAINER  CloudJun  "jun737x@163.com"
#3.在构建镜像时，指定镜像的工作目录，之后的命令都是基于此工作目录，如果不存在，则会创建目录
WORKDIR  /test
#4.将文件从Docker主机将jdk及jar包复制到Docker镜像中，自动将jdk的压缩包进行解压
COPY  spring.jar /test
ADD  jdk-8u221-linux-x64.tar.gz  /test
#5.将jdk解压后配置环境变量
ENV JAVA_HOME=/test/jdk1.8.0_221
ENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV PATH=$JAVA_HOME/bin:$PATH
#6.容器启动时，需要执行的命令(执行jar包)
CMD java -jar spring.jar</code></pre> 
<p>如图<strong>(粘贴进去后全部注释了，可以手动删除前面的#解除注释)</strong>： </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/61/42/AdiHN2dU_o.png"></p> 
<blockquote> 
 <p>创建镜像：<span style="color:#fe2c24;">docker build -t spring:v2 . </span></p> 
</blockquote> 
<blockquote> 
 <p>再查看镜像：<span style="color:#fe2c24;">docker </span><span style="color:#fe2c24;">images</span></p> 
</blockquote> 
<blockquote> 
 <p>进入容器：<span style="color:#fe2c24;">docker run -it spring:v2      </span><span style="color:#0d0016;">(这里会自动启动jar包)</span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/14/b8/1bEcSmus_o.png"></p> 
<blockquote> 
 <p>已可以通过：<span style="color:#fe2c24;">docker run -itd spring:v2   </span><span style="color:#0d0016;">（在后台运行）</span></p> 
</blockquote> 
<blockquote> 
 <p>再进入：<span style="color:#fe2c24;">docker exec -it 24696887b11eeb7ea229221e94f7b0cac03526551854319db80aef21b2d12ca4 bash</span></p> 
 <p style="text-align:center;"><span style="color:#494949;">( 其中bash前面是运行后的编号，根据运行后的编号进入到该容器中)</span></p> 
</blockquote> 
<blockquote> 
 <p>查看jar及解压后的jdk，还可以输入命令查看jdk环境：<span style="color:#fe2c24;">echo $JAVA_HOME</span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ee/16/xjJCs3cO_o.png"></p> 
<p style="background-color:transparent;"><strong>以下配置jre，可以运行jar包项目及优化储存</strong></p> 
<blockquote> 
 <p>输入命令，编辑<strong>Dockerfile文件</strong>：<span style="color:#fe2c24;">vim Dockerfile</span>   ，将原来的编写全部删除。</p> 
</blockquote> 
<blockquote> 
 <p>将以下编写的内容粘贴到<strong>Dockerfile</strong>文件中，按<span style="color:#fe2c24;">Esc</span>退出编辑模式，输入<span style="color:#fe2c24;"> :wq </span>保存编写内容并且退出文件。 </p> 
 <p></p> 
 <pre><code class="hljs">#1.指定基础镜像，并且必须是第一条指令
FROM  centos
#2.指明该镜像的作者和其电子邮件
MAINTAINER  CloudJun  "jun737x@163.com"
#3.在构建镜像时，指定镜像的工作目录，之后的命令都是基于此工作目录，如果不存在，则会创建目录
WORKDIR  /test
#4.将文件从Docker主机jre包复制到Docker镜像中，自动将jdk的压缩包进行解压
COPY  spring.jar /test
ADD  jre-8u391-linux-x64.tar.gz  /test
#5.将jre解压后配置环境变量
ENV JAVA_HOME=/test/jre1.8.0_391
ENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV PATH=$JAVA_HOME/bin:$PATH
#6.容器启动时，需要执行的命令(执行jar包)
CMD java -jar spring.jar</code></pre> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a6/af/1vVLkprc_o.png"> </p> 
<blockquote> 
 <p>创建镜像：<span style="color:#fe2c24;">docker build -t spring:v3 .</span></p> 
</blockquote> 
<blockquote> 
 <p>再查看镜像：<span style="color:#fe2c24;">docker </span><span style="color:#fe2c24;">images</span></p> 
</blockquote> 
<blockquote> 
 <p>运行：<span style="color:#fe2c24;">docker run -itd spring:v3</span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2b/dc/fg1VTePi_o.png"></p> 
<blockquote> 
 <p><strong>虽然储存的减少可能很小，但是当需要量上来是时候也是节省了大量的储存空间的。</strong></p> 
</blockquote> 
<h3 id="3.%20%E5%AE%8C%E5%96%84%E9%95%9C%E5%83%8F" style="background-color:transparent;">3. 完善镜像</h3> 
<blockquote> 
 <p>需要将储存控制到很少可以使用这个镜像<strong>jeanblanchard/alpine-glibc</strong>，这个镜像所需的储存很少，而通过这个镜像自定义出来的镜像也会少很多。</p> 
</blockquote> 
<blockquote> 
 <p>首先需要下载这个镜像：<span style="color:#fe2c24;">docker pull jeanblanchard/alpine-glibc</span></p> 
</blockquote> 
<blockquote> 
 <p>再查看镜像的信息：<span style="color:#fe2c24;">docker </span><span style="color:#fe2c24;">images</span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f6/59/QRd0AnTX_o.png"></p> 
<blockquote> 
 <p>可以看到所需的储存空间很少。</p> 
</blockquote> 
<blockquote> 
 <p>然后我们将指定的镜像修改为这个镜像将<strong>Dockerfile文件，再次镜像编辑为以下内容。</strong></p> 
</blockquote> 
<blockquote> 
 <pre><code class="hljs">#1.指定基础镜像，并且必须是第一条指令
FROM  jeanblanchard/alpine-glibc
#2.指明该镜像的作者和其电子邮件
MAINTAINER  CloudJun  "jun737x@163.com"
#3.在构建镜像时，指定镜像的工作目录，之后的命令都是基于此工作目录，如果不存在，则会创建目录
WORKDIR  /test
#4.将文件从Docker主机jre包复制到Docker镜像中，自动将jdk的压缩包进行解压
COPY  spring.jar /test
ADD  jre-8u391-linux-x64.tar.gz  /test
#5.将jre解压后配置环境变量
ENV JAVA_HOME=/test/jre1.8.0_391
ENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
ENV PATH=$JAVA_HOME/bin:$PATH
#6.容器启动时，需要执行的命令(执行jar包)
CMD java -jar spring.jar</code></pre> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/73/0e/vS9Jk9iQ_o.png"></p> 
<blockquote> 
 <p>创建镜像：<span style="color:#fe2c24;">docker build -t spring:v4 .</span></p> 
</blockquote> 
<blockquote> 
 <p>再查看镜像：<span style="color:#fe2c24;">docker </span><span style="color:#fe2c24;">images</span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/80/d3/ziJPRnfl_o.png"></p> 
<blockquote> 
 <p><strong>现在这样的需要的储存空间就相对少了一半，更加的节省了资源空间。</strong></p> 
</blockquote> 
<blockquote> 
 <p>现在映射端口运行：<span style="color:#fe2c24;">docker run -itd --name s1 -p 8080:8080 spring:v4</span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ef/74/ufxifL0i_o.png"></p> 
<blockquote> 
 <p>之后在主机浏览器中访问虚拟机IP的访问路径：</p> 
 <p></p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b5/9d/Fe6F218t_o.png"></p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93" style="background-color:transparent;">三、镜像上传仓库</h2> 
<blockquote> 
 <p>首先需要在我们的阿里云账号中开启镜像仓库，点击用户左边的控制器，点击容器镜像服务ACR，点击实例列表，在其中点击创建个人版本的，企业版要米，创建后需要设置密码。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4e/2b/NmLAbTiC_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/25/b3/F2bvmtXz_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/29/68/GfDS6ViQ_o.png"></p> 
<blockquote> 
 <p>之后将以上的登入凭证复制粘贴到虚拟机中执行命令，前面的$不用复制进去，之后会镜像密码的输入，是自己设置的容器镜像服务密码，以下说明登入成功：</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e7/d9/ax1mlkaM_o.png"></p> 
<blockquote> 
 <p>创建仓库：在实例列表中点击命名空间——&gt;之后创建命名空间即可</p> 
 <p>如图：</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/33/32/i4Sx22QF_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bf/5c/FQKOfIWx_o.png"></p> 
<blockquote> 
 <p>之后创建一个仓库，仓库名称可以自己取</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d0/d3/Camh2pTg_o.png"></p> 
<blockquote> 
 <p>有其中的之后也可以绑定到账号中去，这里没有就可以选择本地仓库 </p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ad/f1/uTTvmDIS_o.png"></p> 
<blockquote> 
 <p>之后将需要上传推送到仓库的镜像取个别名，在将这个镜像绑定为阿里云的仓库，阿里云仓库在镜像仓库的第三部的将镜像推送到Registry中有命令。</p> 
</blockquote> 
<blockquote> 
 <p>第一个命令为登入，第二个命令为绑定阿里云仓库，第三个命令为上传推送到仓库</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cc/45/zKHv6Axx_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/61/3c/PbXtWPb6_o.png"></p> 
<blockquote> 
 <p>现在我们将虚拟机中共的镜像删除，删除后可以在次重阿里仓库中拉取下来。</p> 
</blockquote> 
<blockquote> 
 <p>删除：<span style="color:#fe2c24;">docker rmi 镜像名:v1 </span>  （v1版本号）</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5e/0f/P4Lls73h_o.png"></p> 
<blockquote> 
 <p>拉取下载命令：<span style="color:#fe2c24;">docker pull 仓库中的创建名称:v1    </span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/03/8d/E6ox4Uog_o.png"></p> 
<h2 id="%E6%AF%8F%E7%AF%87%E4%B8%80%E8%8E%B7" style="background-color:transparent;">每篇一获</h2> 
<blockquote> 
 <p>学习并掌握在 Linux 中使用 Dockerfile 自定义镜像以及上传到阿里云仓库的技术，对您的技术能力和职业发展都有着重要的意义。</p> 
</blockquote> 
<ol><li> <p><em><span style="color:#b95514;"><strong>提升技术能力</strong></span></em>：Docker 是一种流行的容器化技术，它可以帮助您将应用及其依赖打包在一起，实现快速、一致的部署。通过学习和使用 Docker，您可以更深入地理解容器化技术，提升您的技术能力。同时，使用 Dockerfile 自定义镜像，可以让您更好地理解 Docker 镜像的构建过程，进一步提升您的 Docker 技术能力。</p> </li><li> <p><em><span style="color:#1c7331;"><strong>提高工作效率</strong></span></em>：使用 Dockerfile 自定义镜像，可以帮助您快速、一致地构建和部署应用。您只需要编写一次 Dockerfile，就可以在任何支持 Docker 的平台上重复使用，大大提高了您的工作效率。此外，通过将镜像上传到阿里云仓库，您可以方便地在不同的环境中共享和使用这些镜像，进一步提高您的工作效率。</p> </li><li> <p><em><span style="color:#1a439c;"><strong>扩大职业发展机会</strong></span></em>：掌握 Docker 和阿里云仓库的使用，可以扩大您的职业发展机会。Docker 和阿里云都是目前 IT 行业中非常热门的技术，掌握这些技术可以让您在求职市场上具有更大的竞争优势。</p> </li><li> <p><em><span style="color:#1c7892;"><strong>提升团队协作能力</strong></span></em>：通过使用阿里云仓库共享 Docker 镜像，您的团队可以更方便地共享和协作开发工作，提升团队的协作能力。</p> </li><li> <p><em><span style="color:#511b78;"><strong>提高应用的可移植性</strong></span></em>：使用 Docker 可以提高应用的可移植性，使应用可以在不同的环境中一致地运行，降低了应用部署的复杂性。</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b4b3de5bb593cdd0241882a904251632/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue3-计算属性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67aab2111cb6e94fc17d1bd97fb2e46f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringCloud Aliba-Nacos-从入门到学废【1】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>