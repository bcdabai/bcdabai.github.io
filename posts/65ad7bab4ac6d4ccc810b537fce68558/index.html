<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Objective-C 基础入门（三） 读写文件与回调 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Objective-C 基础入门（三） 读写文件与回调" />
<meta property="og:description" content="目录
四、通过 NSString 和 NSData 读写文件
1.通过 NSString 写入文件
NSError
2.通过 NSString 读取文件
3.将 NSData 对象的数据写入文件
4.从文件读取数据到 NSData 对象
五、回调
1.运行循环
2.目标 - 动作对
3.辅助对象
4.通知
5.回调与对象所有权
6.Block 对象
声明 Block 变量
编写 Block 对象
传递 Block 对象
使用 typedef 修饰 Block
外部变量
在 Block 变量中使用 self
四、通过 NSString 和 NSData 读写文件 1.通过 NSString 写入文件 在将字符串对象写入文件时，要指定字符串编码。字符串编码是描述字符和代表的数字之间的映射关系。常用的编码有 ASII编码、UTF-8 和 UTF-16。
NSMutableString *str = [NSMutableString new]; for(int i=0;i&lt;10;i&#43;&#43;) { [str appendString:@&#34;Aaron is cool!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/65ad7bab4ac6d4ccc810b537fce68558/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-15T17:27:33+08:00" />
<meta property="article:modified_time" content="2020-05-15T17:27:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Objective-C 基础入门（三） 读写文件与回调</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"> </p> 
<p id="%E5%9B%9B%E3%80%81%E9%80%9A%E8%BF%87%20NSString%20%E5%92%8C%20NSData%20%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E9%80%9A%E8%BF%87%20NSString%20%E5%92%8C%20NSData%20%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6" rel="nofollow">四、通过 NSString 和 NSData 读写文件</a></p> 
<p id="1.%E9%80%9A%E8%BF%87%20NSString%20%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#1.%E9%80%9A%E8%BF%87%20NSString%20%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6" rel="nofollow">1.通过 NSString 写入文件</a></p> 
<p id="NSError-toc" style="margin-left:80px;"><a href="#NSError" rel="nofollow">NSError</a></p> 
<p id="2.%E9%80%9A%E8%BF%87%20NSString%20%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#2.%E9%80%9A%E8%BF%87%20NSString%20%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6" rel="nofollow">2.通过 NSString 读取文件</a></p> 
<p id="3.%E5%B0%86%20NSData%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#3.%E5%B0%86%20NSData%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6" rel="nofollow">3.将 NSData 对象的数据写入文件</a></p> 
<p id="%C2%A04.%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%88%B0%20NSData%20%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#%C2%A04.%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%88%B0%20NSData%20%E5%AF%B9%E8%B1%A1" rel="nofollow"> 4.从文件读取数据到 NSData 对象</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%9B%9E%E8%B0%83-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%9B%9E%E8%B0%83" rel="nofollow">五、回调</a></p> 
<p id="1.%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF-toc" style="margin-left:40px;"><a href="#1.%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF" rel="nofollow">1.运行循环</a></p> 
<p id="2.%E7%9B%AE%E6%A0%87%20-%20%E5%8A%A8%E4%BD%9C%E5%AF%B9-toc" style="margin-left:40px;"><a href="#2.%E7%9B%AE%E6%A0%87%20-%20%E5%8A%A8%E4%BD%9C%E5%AF%B9" rel="nofollow">2.目标 - 动作对</a></p> 
<p id="3.%E8%BE%85%E5%8A%A9%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#3.%E8%BE%85%E5%8A%A9%E5%AF%B9%E8%B1%A1" rel="nofollow">3.辅助对象</a></p> 
<p id="%C2%A04.%E9%80%9A%E7%9F%A5-toc" style="margin-left:40px;"><a href="#%C2%A04.%E9%80%9A%E7%9F%A5" rel="nofollow"> 4.通知</a></p> 
<p id="5.%E5%9B%9E%E8%B0%83%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83-toc" style="margin-left:40px;"><a href="#5.%E5%9B%9E%E8%B0%83%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83" rel="nofollow">5.回调与对象所有权</a></p> 
<p id="%C2%A06.Block%20%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#%C2%A06.Block%20%E5%AF%B9%E8%B1%A1" rel="nofollow"> 6.Block 对象</a></p> 
<p id="%E5%A3%B0%E6%98%8E%20Block%20%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#%E5%A3%B0%E6%98%8E%20Block%20%E5%8F%98%E9%87%8F" rel="nofollow">声明 Block 变量</a></p> 
<p id="%E7%BC%96%E5%86%99%20Block%20%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#%E7%BC%96%E5%86%99%20Block%20%E5%AF%B9%E8%B1%A1" rel="nofollow">编写 Block 对象</a></p> 
<p id="%E4%BC%A0%E9%80%92%C2%A0Block%20%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#%E4%BC%A0%E9%80%92%C2%A0Block%20%E5%AF%B9%E8%B1%A1" rel="nofollow">传递 Block 对象</a></p> 
<p id="%E4%BD%BF%E7%94%A8%20typedef%20%E4%BF%AE%E9%A5%B0%20Block-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%20typedef%20%E4%BF%AE%E9%A5%B0%20Block" rel="nofollow">使用 typedef 修饰 Block</a></p> 
<p id="%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F" rel="nofollow">外部变量</a></p> 
<p id="%E5%9C%A8%20Block%20%E5%8F%98%E9%87%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%20self-toc" style="margin-left:80px;"><a href="#%E5%9C%A8%20Block%20%E5%8F%98%E9%87%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%20self" rel="nofollow">在 Block 变量中使用 self</a></p> 
<hr id="hr-toc"> 
<h2 id="%E5%9B%9B%E3%80%81%E9%80%9A%E8%BF%87%20NSString%20%E5%92%8C%20NSData%20%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6">四、通过 NSString 和 NSData 读写文件</h2> 
<h3 id="1.%E9%80%9A%E8%BF%87%20NSString%20%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6">1.通过 NSString 写入文件</h3> 
<p style="text-indent:33px;">在将字符串对象写入文件时，<strong>要指定字符串编码</strong>。字符串编码是描述字符和代表的数字之间的映射关系。常用的编码有 ASII编码、UTF-8 和 UTF-16。</p> 
<pre><code class="language-objectivec">NSMutableString *str = [NSMutableString new];
for(int i=0;i&lt;10;i++)
{
    [str appendString:@"Aaron is cool!\n"];
}

[str writeToFile:@"/tem/cool.txt"
      atomically:YES 
        encoding:NSUTF8StringEncoding
           error:NULL];
NSLog(@"done writing /cool.txt");</code></pre> 
<h4 id="NSError">NSError</h4> 
<p style="text-indent:33px;">NSError 表示了写入文件时出现的<strong>各种类型错误描述</strong>。除了要将执行结果（bool 值）还需将错误描述返回给调用方。可以使用“引用传递”，在调用函数时，<span style="color:#f33b45;"><strong>传入一个指向某个变量的引用</strong></span>，这个变量可以直接保存或修改相应的值，其内存地址就是要传入的引用。</p> 
<pre><code class="language-objectivec">NSMutableString *str = [NSMutableString new];
for(int i=0;i&lt;10;i++)
{
    [str appendString:@"Aaron is cool!\n"];
}

声明一个指向 NSError 对象的指针，但是不创建相应的对象
实际上，只有当发生错误时，才会由 writeToFile 创建相应的 NSError 对象
NSError *error；

BOOL b = [str writeToFile:@"/tem/cool.txt"
               atomically:YES 
                 encoding:NSUTF8StringEncoding
                    error:&amp;error];

检查返回的 Bool 值，如果出错，查询 NSError 对象输出错误描述
if(b)
    NSLog(@"done");
else
    NSLog(@"writing failed: %@",[error localizedDescription]);</code></pre> 
<h3 id="2.%E9%80%9A%E8%BF%87%20NSString%20%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6">2.通过 NSString 读取文件</h3> 
<pre><code class="language-objectivec">NSError *error；
NSString *str = [[NSString alloc] 
 initWithContentsOfFile:@"/etc/resolv.conf"
               encoding:NSASCIIStringEncoding
                  error:&amp;error];

如果载入失败返回 nil
if(!str)
    NSLog(@"read failed: %@",[error localizedDescription]);
else
    NSLog(@"resolv.conf: %@",str);</code></pre> 
<h3 id="3.%E5%B0%86%20NSData%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6">3.将 NSData 对象的数据写入文件</h3> 
<p style="text-indent:33px;">NSData 对象代表内存中的某块缓冲区，保存了相应字节数的数据。例如可以让程序通过某个网址下载数据，并将得到的数据保存在 NSDate 实例中，然后将数据写入文件。</p> 
<p style="text-align:center;"><img alt="" height="520" src="https://images2.imgbox.com/72/02/XWswVhVy_o.png" width="652"></p> 
<p style="text-indent:33px;"><span style="color:#f33b45;"><strong>writeToFile：options：error</strong></span> 方法设置参数通过 option 传入，常见的设置是使用 <strong>NSDataWritingAtomic </strong>应用原子操作，处理新下载文件替换旧文件，下载时断电等情况，要么生成一个完整的文件，要么不改变原有状态。所以改进后应为 <strong><span style="color:#f33b45;">option：NSDataWritingAtomic</span>。</strong></p> 
<blockquote> 
 <p><strong>NSURLConnection 已经过期，</strong> NSURLSession是NSURLConnection 的替代者</p> 
</blockquote> 
<h3 id="%C2%A04.%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%88%B0%20NSData%20%E5%AF%B9%E8%B1%A1"> 4.从文件读取数据到 NSData 对象</h3> 
<pre><code class="language-objectivec">NSData *readData = [NSData dataWithContentsOfFile:@"/tmp/google.png"];
NSLog(@"The file has %lu bytes",(unsigned long)[readData length]);</code></pre> 
<h2 id="%E4%BA%94%E3%80%81%E5%9B%9E%E8%B0%83">五、回调</h2> 
<p style="text-indent:33px;">本章创建一个事件驱动的程序，这个程序能保持运行、等待事件发生，并作出相应的处理，除非人为主动关闭，程序不会自己退出，会一直在后台等待时间的发生。</p> 
<p style="text-indent:33px;">回调（callback）就是讲<span style="color:#f33b45;"><strong>一段可执行的代码和一个特定的事件绑定起来，事件发生即调用</strong></span>。Objective-C 中有四种途径实现回调：</p> 
<ul><li><strong>目标 - 动作对</strong>：<u>向<span style="color:#f33b45;"><strong>一个对象</strong></span>发送<span style="color:#f33b45;"><strong>一个回调</strong></span></u>，程序开始等待前要求“<strong>当事件发生时，向指定的对象发送某个特定的消息</strong>”。</li><li><strong>辅助对象</strong>：<u>向<span style="color:#f33b45;"><strong>一个对象</strong></span>发送<strong><span style="color:#f33b45;">多个回调</span></strong></u>。程序开始等待前要求“<strong>当事件发生时，<span style="color:#f33b45;">向遵守相应协议的辅助对象发送消息</span></strong>”。常见的辅助对象：<span style="color:#f33b45;"><strong>委托对象 数据源</strong></span></li><li><strong>通知</strong>：<u>可以处理<span style="color:#f33b45;"><strong>发给多个对象的回调</strong></span></u>，OC 中提供一种成为 通知中心 的对象，在程序开始等待前可以告知通知中心：“某个对象正在等待某些特定的通知，通知出现时向指定对象发送特定的消息”。</li><li><strong>Block 对象</strong>：<span style="color:#f33b45;"><strong>block 是一段可执行的代码</strong></span>，程序开始等待前声明一个 Block 对象，当事件发生时执行这段 Block 对象。</li></ul> 
<h3 id="1.%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF">1.运行循环</h3> 
<p style="text-indent:33px;">事件驱动的程序需要有一个对象专门等待事件的发生。OS X 系统有一个名为 NSRunLoop （运行循环）的类，会持续等待并在的定的事件发生时触发回调。创建循环的代码如下：</p> 
<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;
int main()
{
    @autoreleasepool{
        [[NSRunLoop currentRunLoop] run];
    }
    return 0;
}</code></pre> 
<p>程序运行后没有返回 run 方法，此时一直在运行循环等待着事件发生，可以选择 Product - Stop 结束循环。</p> 
<h3 id="2.%E7%9B%AE%E6%A0%87%20-%20%E5%8A%A8%E4%BD%9C%E5%AF%B9">2.<strong>目标 - 动作对</strong></h3> 
<p style="text-indent:33px;">首先<strong>创建 计时器，设定延迟、目标和动作</strong>。<u>指定延迟时间后，计时器回想设定的目标发送指定的消息</u>。下面创建一个拥有 NSRunLoop 对象和 NSTimer 对象的程序。每隔2秒 NSTimer 对象会向其目标发送指定的动作消息。此外还要创建一个 BNRLogger 类，将被设置为 NSTimer 对象的目标。此处<strong>目标 - 动作对</strong>为<strong> <span style="color:#f33b45;">BNRLogger - updateLastTime</span>。</strong></p> 
<p style="text-align:center;"><img alt="" height="101" src="https://images2.imgbox.com/35/03/yUoKWPER_o.png" width="609"></p> 
<p>在 BNRLogger.h 中，声明相应的动作方法：</p> 
<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;
@interface BNRLogger : NSObject
@property (nonatomic) NSDate *lastTime;
-(NSString *)lastTimeString;
-()updateLastTime:(NSTimer *)t;
@end</code></pre> 
<p style="text-align:center;"><img alt="" height="476" src="https://images2.imgbox.com/c8/15/Ho8vtxj6_o.png" width="654"></p> 
<p>所有的 BNRLogger 共享一个 dateFormatter 实例，所以声明为 static。</p> 
<p style="text-indent:33px;">在 main.m 中，创建一个 BNRLogger 实例，让它成为 NSTimer 的目标，将其 action 设置为 updateLastTime。</p> 
<p style="text-align:center;"><img alt="" height="206" src="https://images2.imgbox.com/cd/dd/bIrJXeAd_o.png" width="610"></p> 
<p>其中<strong>使用了 <span style="color:#f33b45;">@selector 语句传递动作消息的名称给相应方法。</span></strong>此时需要传递相应的实参，不能只传递方法的名字。计时器很简单，<strong><span style="color:#f33b45;">“只是在指定的时刻触发事件，这种情况适合用<strong>目标 - 动作对来实现回调”</strong></span>。</strong></p> 
<blockquote> 
 <p>selector 选择器：</p> 
 <p style="text-indent:33px;">当一个方法需要一个选择器做为实参（就像 scheduledTimerInterval：target：selector：userInfo：repeats：那样）时，需要进行方法的查询，如果使用方法的实际名称进行查询，那么会导致查询速度过慢。实际上编译器会为每个使用过的方法附上一个唯一的数字（即成为选择器），运行时通过数字查询索要调用的方法。通过编译指令 <strong><span style="color:#f33b45;">@selector </span></strong>可以得到与方法名相对应的选择器。</p> 
</blockquote> 
<h3 id="3.%E8%BE%85%E5%8A%A9%E5%AF%B9%E8%B1%A1">3.辅助对象</h3> 
<p style="text-indent:33px;">四.3中使用了 NSURLConnection 的实例方法从 Web 服务器获取数据。会有以下两个问题：</p> 
<ul><li>获取数据时会阻塞主线程，用户界面失去响应</li><li>某些情况下无法实现回调，如 Web 服务器要求提供用户名密码</li></ul> 
<p style="text-indent:33px;">所以通常会以 <span style="color:#f33b45;"><strong>异步 </strong></span>模式使用 NSURLConnection，此时 NSURLConnection 不会一次发送全部数据，而是分多次发送块状数据发送过程中会发生：得到数据、要求提供认证信息 或 获取数据失败 等事件，程序要准备好响应这些事件。</p> 
<p style="text-indent:33px;">此时 BNRLogger 实例将会成为 NSURLConnection 的<strong>辅助对象。</strong></p> 
<p style="text-align:center;"><img alt="" height="259" src="https://images2.imgbox.com/46/b1/LsxxNMSX_o.png" width="636"></p> 
<p style="text-indent:33px;">创建一个  NSURLConnection 对象，<strong>设置 BNRLogger 实例为它的委托对象（delegate）</strong>：</p> 
<p style="text-align:center;"><img alt="" height="91" src="https://images2.imgbox.com/e9/50/x4dSU9OZ_o.png" width="580"></p> 
<p>然后在 BNRLogger 中实现响应特定时事件的回调方法。不需要自己去声明这些方法，它们已经在<span style="color:#f33b45;"><strong>协议</strong></span>中声明过了。<span style="color:#f33b45;"><strong>协议是一系列预先写好的方法声明。</strong></span></p> 
<p style="text-align:center;"><img alt="" height="191" src="https://images2.imgbox.com/ce/ad/jXdF4GSp_o.png" width="646"></p> 
<p style="text-indent:33px;"> 作为 NSURLConnection 的委托对象，BNRLogger 需要相应三条消息，来自 NSURLConnectionDataDelegate 和 NSURLConnectionDelegate 协议。</p> 
<p style="text-align:center;"><img alt="" height="77" src="https://images2.imgbox.com/59/74/UOsmxq5h_o.png" width="550"></p> 
<p style="text-align:center;"><img alt="" height="29" src="https://images2.imgbox.com/60/60/CoEJhOkb_o.png" width="410"></p> 
<p> 以 <span style="color:#f33b45;"><strong>异步 </strong></span>模式使用 NSURLConnection，还需要使用一个 NSMutableData 实例。</p> 
<p style="text-align:center;"><img alt="" height="730" src="https://images2.imgbox.com/cf/9e/dnDRX7HH_o.png" width="643"></p> 
<p style="text-align:center;"><img alt="" height="67" src="https://images2.imgbox.com/46/f1/YGngrtaL_o.png" width="642"></p> 
<p style="text-align:center;"><img alt="" height="78" src="https://images2.imgbox.com/bc/c6/d4CGAUZu_o.png" width="608"></p> 
<h3 id="%C2%A04.%E9%80%9A%E7%9F%A5"> 4.通知</h3> 
<p style="text-indent:33px;">A对B的变化感兴趣，就注册为B的观察者，当B发生变化时通知A，告知B发生了变化。这就是观察者模式。观察者模式定义了一种<strong>一对多的依赖关系</strong>，让多个观察者对象同时监听某一个主题对象。这个主体对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己或者做出相应的一些动作。</p> 
<blockquote> 
 <p>相关的类</p> 
 <p>1、NSNotification</p> 
 <p style="text-indent:33px;">这个类可以理解为一个消息对象，其中有三个成员变量。</p> 
 <p style="text-indent:33px;">1） 这个成员变量是这个消息对象的唯一标识，用于辨别消息对象。</p> 
 <p style="text-indent:33px;"> @property (readonly, copy) NSString *name; </p> 
 <p style="text-indent:33px;">2）这个成员变量定义一个对象，可以理解为针对某一个对象的消息。</p> 
 <p style="text-indent:33px;"> @property (readonly, retain) id object; </p> 
 <p style="text-indent:33px;">3）这个成员变量是一个字典，可以用其来进行传值。</p> 
 <p style="text-indent:33px;"> 1 @property (readonly, copy) NSDictionary *userInfo; </p> 
 <p>2、NSNotificationCenter</p> 
 <p style="text-indent:33px;">概念： 这个类是一个通知中心，使用单例设计，每个应用程序都会有一个默认的通知中心。用于调度通知的发送的接受。</p> 
 <p style="text-indent:33px;"> 以NSNotificationCenter为中心，观察者往Center中注册对某个主题对象的变化感兴趣，主题对象通过NSNotificationCenter 进行变化广播。所有的观察和监听行为都向同一个中心注册，所有对象的变化也都通过同一个中心向外广播。</p> 
</blockquote> 
<p style="text-indent:33px;">当系统的时区设置发生变化时，会向通知中心发布 NSSystemTimeZoneDidChangeNotification 通知，然后通知中心会将该通知转发给相关的程序中的很多对象。这些对象都可以通过通知中心将自己注册成为<span style="color:#f33b45;"><strong>观察者</strong></span>。</p> 
<p style="text-align:center;"><img alt="" height="132" src="https://images2.imgbox.com/e7/d2/pCW0SsjG_o.png" width="610"></p> 
<p style="text-align:center;"><img alt="" height="115" src="https://images2.imgbox.com/4a/fa/6WMdee6q_o.png" width="646"></p> 
<p style="text-indent:33px;"> 向通知中心注册观察者时，可以指定某个特定的通知名（例如：NSSystemTimeZoneDidChangeNotification）以及通知发布的来源（比如只想收到这个窗口大小调整的通知），两个参数都可以设置为 nil，可会接收到所有对象发出的每条通知。</p> 
<h3 id="5.%E5%9B%9E%E8%B0%83%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83">5.回调与对象所有权</h3> 
<p style="text-indent:33px;">不论哪种类型的回调，必须注意陷入强引用循环的风险。</p> 
<p style="text-align:center;"><img alt="" height="182" src="https://images2.imgbox.com/78/a5/QQ1LHDnx_o.png" width="294"></p> 
<p style="text-indent:33px;">所以在编写代码时要遵循以下原则：</p> 
<ul><li>对象成为另一个对象的目标，在 dealloc 方法中目标指针赋为 nil：</li></ul> 
<pre><code class="language-objectivec">-(void)dealloc{
    [buttonThatKeepsSendingMeMessages setTarget:nil];
}</code></pre> 
<ul><li>对象成为另一个对象的委托对象或数据源，在 dealloc 方法中取消相应的关联：</li></ul> 
<pre><code class="language-objectivec">-(void)dealloc{
    [windowThatBossesMeAround setDelegate:nil];
    [tableViewThatBegsForData setDataSource:nil];
}</code></pre> 
<ul><li>通知中心如果将某个对象注册为观察者，通常应该在释放该对象时将其移除通知中心:</li></ul> 
<pre><code class="language-objectivec">-(void)dealloc{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}</code></pre> 
<h3 id="%C2%A06.Block%20%E5%AF%B9%E8%B1%A1"> 6.Block 对象</h3> 
<p style="text-indent:33px;">与 C++ 中的 lamda 函数很相似。Block 对象是一段代码，是在花括号中的一套指令，但是<span style="color:#f33b45;"><strong>没有函数名</strong></span>，相应的位置只有一个 ^ 符号。与函数不同的是，Block <strong>定义在函数或者方法内部</strong>，并<u><strong>能够访问在函数或者方法范围内 Block 之外的任何变量</strong></u>。<span style="color:#f33b45;"><strong>^ 符号表示这段代码是一个 Block 对象</strong></span>。如下示例：</p> 
<pre><code class="language-objectivec">^(double dividend, double divisor){
    NSLog(@"This is an instruction within a block.");
    double quotient = dividend / divisor;
    return quotient;
}</code></pre> 
<p>这段代码中的 Block 对象有两个实参，还返回一个 double 类型的值。Block 对象可以被当成一个实参来传递给可以接受 block 的方法。</p> 
<h4 id="%E5%A3%B0%E6%98%8E%20Block%20%E5%8F%98%E9%87%8F">声明 Block 变量</h4> 
<p style="text-align:center;"><img alt="" height="313" src="https://images2.imgbox.com/eb/02/AK9E0sNp_o.png" width="642"></p> 
<p>这段代码实现的功能是去除数组中所有字符串中的元音字符。</p> 
<p style="text-align:center;"><img alt="" height="170" src="https://images2.imgbox.com/29/6b/dR5XGT7Z_o.png" width="516"></p> 
<p style="text-indent:33px;">Block 的声明需要包括 Block 的返回类型、Block名称、实参类型。</p> 
<h4 id="%E7%BC%96%E5%86%99%20Block%20%E5%AF%B9%E8%B1%A1">编写 Block 对象</h4> 
<p style="text-indent:33px;">同在 main.m 中，编写代码，将 Block 对象赋给变量：</p> 
<pre><code class="language-objectivec">...
void(^devowelizer)(id, NSUInteger ,BOOL *);
devowelizer = ^(id string, NSUInteger i ,BOOL *stop){
    NSMutableString *newString =[NSMutableString stringWithString:string];
    
    / 枚举数组中的字符串，将所有出现的元音字母替换成空字符串
    for(NSString *s in vowels){
        NSRange fullRange = NSMakeRange(0,[newString length]);
        [newString replaceOccurencesOfString:s
                                  withString:@""
                                     options:NSCaseInsensitiveSearch
                                       range:fullRange]
    }
    [devowelizedStrings addObject:newString];
};    / Block 变量赋值结束
...</code></pre> 
<p><strong>Block 对象与其他回调:</strong></p> 
<p style="text-indent:33px;">之前介绍的两种回调机制：辅助对象 与 通知中心，程序可以在特定的事件发生的时候调用 指定的方法。虽然以上的两种回调机制可以很好的完成任务，但是也有一个缺点，即<strong><u>回调的设置代码</u>与<u>回调方法的具体实现</u><span style="color:#f33b45;">无法写在同一段代码中</span></strong>，甚至会出现在不同的文件中。通过 Block 对象，可以将与回调相关的代码写在同一代码段中。</p> 
<p style="text-align:center;"><img alt="" height="336" src="https://images2.imgbox.com/9a/34/x8Zknvtw_o.png" width="639"></p> 
<h4 id="%E4%BC%A0%E9%80%92%C2%A0Block%20%E5%AF%B9%E8%B1%A1">传递 Block 对象</h4> 
<p style="text-indent:33px;">在 main.m 中，调用 enumerateObjectsUsingBlock： 传入 devowelizer。</p> 
<pre><code class="language-objectivec">[oldStrings enumerateObjectsUsingBlock：devowelizer];</code></pre> 
<p><u>enumerateObjectsUsingBlock：方法要求传入的</u> Block 对象的三个实参类型是固定的，<strong>这三个参数是传入 Block 的参数，系统已经为其设置好了相应的变量</strong>，可以在 block 代码中利用这三个参数实现定制功能。</p> 
<ol><li>第一个是 id 指针，<span style="color:#f33b45;"><strong>指向当前（枚举）的对象</strong></span>。</li><li>第二个是 NSUInteger，其值是<span style="color:#f33b45;"><strong>当前对象在数组中的索引</strong></span>。</li><li>第三个是 BOOL 指针，默认为 NO，如果运行过程中如果<span style="color:#f33b45;"><strong>触发某条件后将该值设为 YES，则数组对象会在执行完当前的 Block 对象后终止枚举</strong></span>。如下例：</li></ol> 
<p style="text-align:center;"><img alt="" height="129" src="https://images2.imgbox.com/aa/c9/CeFySUej_o.png" width="513"></p> 
<h4 id="%E4%BD%BF%E7%94%A8%20typedef%20%E4%BF%AE%E9%A5%B0%20Block">使用 typedef 修饰 Block</h4> 
<p style="text-indent:33px;">一般在实现文件的顶部，或者头文件内使用 typedef。</p> 
<p>#import &lt;Foundation/Foundation.h&gt;<br><span style="color:#f33b45;"><strong>typedef void (^ArrayEnumerationBlock)(id, NSUInteger, BOOL *);</strong></span></p> 
<p>int main()<br> {<!-- --><br>        autoreleasepool{<!-- --><br>        ...<br>        /声明 Block 变量<br>        <s>void (^devowelizer)(id, NSUInteger, BOOL *);</s><br>        <span style="color:#f33b45;"><strong>ArrayEnumerationBlock devowelizer;</strong></span></p> 
<p>       /将 Block 对象赋给变量<br>        devowelizer = ^(id string, NSUInteger i, BOOL *stop){<!-- --><br>        ...</p> 
<p>匿名 Block 对象，参考直接使用 lamda 函数的用法。</p> 
<h4 id="%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F">外部变量</h4> 
<p style="text-indent:33px;">Block 对象通常会在其代码中使用外部创建的其他变量，在 block 内部可以直接使用外部变量。非局部变量会<span style="color:#f33b45;"><strong>以 const 变量被拷贝并存储到 block 中</strong></span>,也就是说在 block 中是只读的。如果尝试在 block 内部给外部变量赋值,会抛出编译器错误。</p> 
<p>1)在block内部可以访问block外部的变量</p> 
<p>2)在block内部不可以修改block "外部的变量"</p> 
<p>3)给外部变量<span style="color:#f33b45;"><strong>加上 </strong></span><code><span style="color:#f33b45;"><strong>__block</strong></span></code>关键字,则这个局部变量可以在block内部进行修改</p> 
<p><strong>注意:</strong></p> 
<p>1、静态变量和全局变量在加和不加<code>__block</code>都会直接引用变量地址。也就意味着在没有加<code>__block</code>关键字的情况下可以修改变量的值。</p> 
<p>2、常量变量(<code>NSString *a=@"hello";</code> <code>a</code>为变量,<code>@“hello”</code>为常量。)<br> 　　不加<code>__block</code>类型，block会直接取常量值(浅拷贝)。<br> 　　加<code>__block</code>类型，block会去引用变量的地址。(如:a变量,a = @"abc".可以任意修改a指向的内容不影响原变量)</p> 
<h4 id="%E5%9C%A8%20Block%20%E5%8F%98%E9%87%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%20self">在 Block 变量中使用 self</h4> 
<p style="text-indent:33px;">如果需要写一个使用 self 的 Block 对象，就必须多做一些工作来避免造成强引用循环。当 BNREmployee 实例调用到 Block 对象时，实例有一个指向 Block 对象（myBlock）的指针，这个 Block 对象会捕获 self，所以它有一个指回 BNREmployee 实例的指针，所以会陷入强引用循环。</p> 
<p style="text-indent:33px;">所以需要在 Block <span style="color:#f33b45;"><strong>对象外声明一个 __weak 指针</strong></span>，将这个指针指向 Block 实例的 self。最后<span style="color:#f33b45;"><strong>在 Block 中使用这个新的指针</strong></span>。</p> 
<pre><code class="language-objectivec">__weak BNREmployee *weakSelf = self;    /弱引用
myBlock = ^{
    BNREmployee *innerSelf = weakSelf;  /局部强引用
    NSLog(@"Employee: %@",innerSelf);
};</code></pre> 
<p>此处如果在使用多线程时，self 指向的对象可能在 Block 执行的时候被释放，所以不能直接使用 weakSelf，而是<span style="color:#f33b45;"><strong>通过 innerSelf 创建一个局部强引用</strong></span>，如果 innerSelf 复制成功，则此时 BNREmployee 就不会被析构。并且由于 innerSelf 是内部的局部变量，在 Block 运行结束后会正常释放。</p> 
<p>注意：如果在 Block 中使用了对象的实例变量，此时也相当于直接使用了 self 指针，所以强调也要通过 innerSelf.employeeID 方式调用。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/90d0881650b2fe59d3c3f6fafae502a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ifstream 的使用方法介绍 一(转载)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3194c704704df9e0439449aa5b8b6aa0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Proxmox ve（Pve） 安装windows server</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>