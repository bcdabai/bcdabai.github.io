<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kubernetes存储之Volumes - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kubernetes存储之Volumes" />
<meta property="og:description" content="Volumes配置管理 容器中的文件在磁盘上是临时存放的,这给容器中运行的特殊应用程序带来一些问题。首先,当容器崩溃时,kubelet 将重新启动容器,容器中的文件将会丢失,因为容器会以干净的状态重建。其次,当在一个 Pod 中同时运行多个容器时,常常需要在这些容器之间共享文件。 Kubernetes 抽象出 Volume 对象来解决这两个问题。Kubernetes 卷具有明确的生命周期,与包裹它的 Pod 相同。 因此,卷比 Pod 中运行的任何容器的存活期都长,在容器重新启动时数据也会得到保留。 当然,当一个 Pod 不再存在时,卷也将不再存在。也许更重要的是,Kubernetes 可以支持许多类型的卷,Pod 也能同时使用任意数量的卷。卷不能挂载到其他卷,也不能与其他卷有硬链接。 Pod 中的每个容器必须独立地指定每个卷的挂载位置。 Kubernetes 支持下列类型的卷:
awsElasticBlockStore 、azureDisk、azureFile、cephfs、cinder、configMap、csidownwardAPI、emptyDir、fc (fibre channel)、flexVolume、flockergcePersistentDisk、gitRepo (deprecated)、glusterfs、hostPath、iscsi、local、nfs、persistentVolumeClaim、projected、portworxVolume、quobyte、rbdscaleIO、secret、storageos、vsphereVolume emptyDir卷： 当 Pod 指定到某个节点上时,首先创建的是一个 emptyDir 卷,并且只要 Pod 在该节点上运行,卷就一直存在。 就像它的名称表示的那样,卷最初是空的。 尽管Pod 中的容器挂载 emptyDir 卷的路径可能相同也可能不同,但是这些容器都可以读写 emptyDir 卷中相同的文件。 当 Pod 因为某些原因被从节点上删除时,emptyDir 卷中的数据也会永久删除。
emptyDir 的使用场景:
缓存空间,例如基于磁盘的归并排序。为耗时较长的计算任务提供检查点,以便任务能方便地从崩溃前状态恢复执行。在 Web 服务器容器服务数据时,保存内容管理器容器获取的文件。 默认情况下, emptyDir 卷存储在支持该节点所使用的介质上;这里的介质可以是磁盘或 SSD 或网络存储,这取决于您的环境。 但是,您可以将 emptyDir.medium 字段设置为 &#34;Memory&#34;,以告诉 Kubernetes 为您安装 tmpfs(基于内存的文件系统)。 虽然tmpfs 速度非常快,但是要注意它与磁盘不同。 tmpfs 在节点重启时会被清除,并且您所写入的所有文件都会计入容器的内存消耗,受容器内存限制约束。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cb01d6b8f27585146164135618997ad0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-05T01:45:54+08:00" />
<meta property="article:modified_time" content="2020-07-05T01:45:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kubernetes存储之Volumes</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<h2 id="Volumes%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86">Volumes配置管理</h2> 
<ul><li>容器中的文件在磁盘上是临时存放的,这给容器中运行的特殊应用程序带来一些问题。首先,当容器崩溃时,kubelet 将重新启动容器,容器中的文件将会丢失,因为容器会以干净的状态重建。其次,当在一个 Pod 中同时运行多个容器时,常常需要在这些容器之间共享文件。 Kubernetes 抽象出 Volume 对象来解决这两个问题。</li><li>Kubernetes 卷具有明确的生命周期,与包裹它的 Pod 相同。 因此,卷比 Pod 中运行的任何容器的存活期都长,在容器重新启动时数据也会得到保留。 当然,当一个 Pod 不再存在时,卷也将不再存在。也许更重要的是,Kubernetes 可以支持许多类型的卷,Pod 也能同时使用任意数量的卷。</li><li>卷不能挂载到其他卷,也不能与其他卷有硬链接。 Pod 中的每个容器必须独立地指定每个卷的挂载位置。</li></ul> 
<p> </p> 
<p><strong>Kubernetes 支持下列类型的卷:</strong></p> 
<ul><li>awsElasticBlockStore 、azureDisk、azureFile、cephfs、cinder、configMap、csi</li><li>downwardAPI、emptyDir、fc (fibre channel)、flexVolume、flocker</li><li>gcePersistentDisk、gitRepo (deprecated)、glusterfs、hostPath、iscsi、local、</li><li>nfs、persistentVolumeClaim、projected、portworxVolume、quobyte、rbd</li><li>scaleIO、secret、storageos、vsphereVolume</li></ul> 
<p> </p> 
<h3 id="emptyDir%E5%8D%B7%EF%BC%9A">emptyDir卷：</h3> 
<p style="text-indent:33px;">当 Pod 指定到某个节点上时,首先创建的是一个 emptyDir 卷,并且只要 Pod 在该节点上运行,卷就一直存在。 就像它的名称表示的那样,卷最初是空的。 尽管Pod 中的容器挂载 emptyDir 卷的路径可能相同也可能不同,但是这些容器都可以读写 emptyDir 卷中相同的文件。 当 Pod 因为某些原因被从节点上删除时,emptyDir 卷中的数据也会永久删除。</p> 
<p style="text-indent:0;"> </p> 
<p style="text-indent:0;"><strong>emptyDir 的使用场景:</strong></p> 
<ul><li style="text-indent:0px;">缓存空间,例如基于磁盘的归并排序。</li><li style="text-indent:0px;">为耗时较长的计算任务提供检查点,以便任务能方便地从崩溃前状态恢复执行。</li><li style="text-indent:0px;">在 Web 服务器容器服务数据时,保存内容管理器容器获取的文件。</li></ul> 
<p style="text-indent:0;"> </p> 
<p style="text-indent:33px;">默认情况下, emptyDir 卷存储在支持该节点所使用的介质上;这里的介质可以是磁盘或 SSD 或网络存储,这取决于您的环境。 但是,您可以将 emptyDir.medium 字段设置为 "Memory",以告诉 Kubernetes 为您安装 tmpfs(基于内存的文件系统)。 虽然tmpfs 速度非常快,但是要注意它与磁盘不同。 tmpfs 在节点重启时会被清除,并且您所写入的所有文件都会计入容器的内存消耗,受容器内存限制约束。</p> 
<p style="text-indent:0;"> </p> 
<p style="text-indent:0;"><strong>emptyDir 示例：</strong></p> 
<pre><code class="language-bash">vim emptyDir_demo.yaml
</code></pre> 
<pre><code>  1 apiVersion: v1
  2 kind: Pod
  3 metadata:
  4   name: vol1
  5 spec:
  6   containers:
  7   - name: vm1
  8     image: reg.harbor.com/library/busyboxplus
  9     command: ["sleep", "300"]
 10     volumeMounts:
 11     - mountPath: /cache
 12       name: cache-volume
 13   - name: vm2
 14     image: reg.harbor.com/library/nginx
 15     volumeMounts:
 16     - mountPath: /usr/share/nginx/html
 17       name: cache-volume
 18   volumes:
 19   - name: cache-volume
 20     emptyDir:
 21       medium: Memory
 22       sizeLimit: 100Mi
</code></pre> 
<p style="text-indent:0;"><img alt="" height="541" src="https://images2.imgbox.com/58/bf/10n3c9Yu_o.png" width="1033"></p> 
<pre><code class="language-bash">kubectl create -f emptyDir_demo.yaml 
kubectl get pods -o wide</code></pre> 
<p style="text-indent:0;"><img alt="" height="153" src="https://images2.imgbox.com/66/9e/tKJoT7fw_o.png" width="1097"></p> 
<pre><code class="language-bash">kubectl exec vol1 -it -- /bin/sh</code></pre> 
<p style="text-indent:0;"><img alt="" height="405" src="https://images2.imgbox.com/6c/46/jLaU8fP0_o.png" width="1155"></p> 
<p style="text-indent:0px;">可以看到文件超过sizeLimit,则一段时间后(1-2分钟)会被kubelet evict掉。之所以不是“立即”被evict,是因为kubelet是定期进行检查的,这里会有一个时间差。</p> 
<p style="text-indent:0px;"><strong>emptydir缺点:</strong></p> 
<ul><li style="text-indent:0px;">不能及时禁止用户使用内存。虽然过1-2分钟kubelet会将Pod挤出,但是这个时间内,其实对node还是有风险的;</li><li style="text-indent:0px;">影响kubernetes调度,因为emptydir并不涉及node的resources,这样会造成Pod“偷偷”使用了node的内存,但是调度器并不知晓;</li><li style="text-indent:0px;">用户不能及时感知到内存不可用</li></ul> 
<p style="text-indent:0px;"> </p> 
<h3 id="hostPath%E5%8D%B7%3A" style="text-indent:0px;">hostPath卷:</h3> 
<p style="text-indent:33px;">hostPath卷能将主机节点文件系统上的文件或目录挂载到您的 Pod 中。 虽然这不是大多数 Pod需要的,但是它为一些应用程序提供了强大的逃生舱。</p> 
<p style="text-indent:0;"> </p> 
<p style="text-indent:0;"><strong>hostPath常见用法：</strong></p> 
<ul><li style="text-indent:0px;">运行一个需要访问 Docker 引擎内部机制的容器,挂载 /var/lib/docker 路径。</li><li style="text-indent:0px;">在容器中运行 cAdvisor 时,以 hostPath 方式挂载 /sys。</li><li style="text-indent:0px;">允许 Pod 指定给定的 hostPath 在运行 Pod 之前是否应该存在,是否应该创建以及应该以什么方式存在。</li></ul> 
<p style="text-indent:0;">除了必需的 path 属性之外,用户可以选择性地为 hostPath卷指定type。</p> 
<p style="text-indent:0;"><img alt="" height="472" src="https://images2.imgbox.com/e8/f5/uInoiR18_o.png" width="1200"></p> 
<p style="text-indent:0;"> </p> 
<p style="text-indent:0;">当使用这种类型的卷时要注意:</p> 
<ul><li style="text-indent:0px;">具有相同配置(例如从 podTemplate 创建)的多个 Pod 会由于节点上文件的不同而在不同节点上有不同的行为。</li><li style="text-indent:0px;">当Kubernetes 按照计划添加资源感知的调度时,这类调度机制将无法考虑由 hostPath 使用的资源。</li><li style="text-indent:0px;">基础主机上创建的文件或目录只能由 root 用户写入。您需要在 特权容器 中以 root 身份运行进程,或者修改主机上的文件权限以便容器能够写入 hostPath 卷。</li></ul> 
<p style="text-indent:0;"><strong>hostPath 示例</strong></p> 
<pre><code class="language-bash">vim hostPath_demo.yaml</code></pre> 
<pre><code class="language-bash">  1 apiVersion: v1
  2 kind: Pod
  3 metadata:
  4   name: test-pd
  5 spec:
  6   containers:
  7   - name: test-container
  8     image: reg.harbor.com/library/nginx
  9     volumeMounts:
 10     - mountPath: /test-pd
 11       name: test-volume
 12   volumes:
 13   - name: test-volume
 14     hostPath:
 15       path: /data
 16       type: DirectoryOrCreate
</code></pre> 
<p style="text-indent:0;"><img alt="" height="329" src="https://images2.imgbox.com/ca/e0/uaagRIrM_o.png" width="686"></p> 
<pre><code class="language-bash">kubectl create -f hostPath_demo.yaml
kubectl get pod -o wide
</code></pre> 
<p style="text-indent:0;"><img alt="" height="203" src="https://images2.imgbox.com/e3/5b/IbihSEcw_o.png" width="1089"></p> 
<p>可以看到pod在server2节点，在pod节点查看，创建了本不存在的/data目录 </p> 
<p style="text-indent:0;"><img alt="" height="102" src="https://images2.imgbox.com/9d/bb/az3qkdKO_o.png" width="492"></p> 
<p style="text-indent:0;"> </p> 
<h3 id="NFS%E5%8D%B7" style="text-indent:0px;">NFS卷</h3> 
<pre><code class="language-bash">vim nfs_demo.yaml</code></pre> 
<pre><code class="language-bash">  1 apiVersion: v1
  2 kind: Pod
  3 metadata:
  4   name: nginx
  5 spec:
  6   containers:
  7   - name: nginx
  8     image: reg.harbor.com/library/nginx
  9     ports:
 10     - containerPort: 80
 11     volumeMounts:
 12     - mountPath: /usr/share/nginx/html
 13       readOnly: false
 14       name: nginx-data
 15   volumes:
 16   - name: nginx-data
 17     nfs:
 18       server: 192.168.1.103
 19       path: "/nfsdata"
</code></pre> 
<p>这里我在server3（192.168.1.103）已经部署了nfs，共享了/nfsdata目录（目录下index.html文件hello world） </p> 
<p style="text-indent:0;"><img alt="" height="215" src="https://images2.imgbox.com/5a/e3/A11hjhz1_o.png" width="624"></p> 
<p style="text-indent:0;">测试访问</p> 
<p style="text-indent:0;"><img alt="" height="108" src="https://images2.imgbox.com/78/ce/q2wJy1oa_o.png" width="929"></p> 
<p> </p> 
<ul><li style="text-indent:0px;">PersistentVolume(持久卷,简称PV)是集群内,由管理员提供的网络存储的一部分。就像集群中的节点一样,PV也是集群中的一种资源。它也像Volume一样,是一种volume插件,但是它的生命周期却是和使用它的Pod相互独立的。PV这个API对象,捕获了诸NFS、ISCSI、或其他云存储系统的实现细节。</li><li style="text-indent:0px;">PersistentVolumeClaim(持久卷声明,简称PVC)是用户的一种存储请求。它和Pod类似,Pod消耗Node资源,而PVC消耗PV资源。Pod能够请求特定的资源(如CPU和内存)。PVC能够请求指定的大小和访问的模式(可以被映射为一次读写或者多次只读)。</li><li style="text-indent:0px;">有两种PV提供的方式:静态和动态。</li></ul> 
<ol><li style="text-indent:0px;">静态PV:集群管理员创建多个PV,它们携带着真实存储的详细信息,这些存储对于集群用户是可用的。它们存在于Kubernetes API中,并可用于存储使用。</li><li style="text-indent:0px;">动态PV:当管理员创建的静态PV都不匹配用户的PVC时,集群可能会尝试专门地供给volume给PVC。这种供给基于StorageClass。</li></ol> 
<ul><li style="text-indent:0px;">PVC与PV的绑定是一对一的映射。没找到匹配的PV,那么PVC会无限期得处于unbound未绑定状态。</li></ul> 
<p style="text-indent:0;"> </p> 
<p style="text-indent:0;"><strong>使用</strong></p> 
<p style="text-indent:33px;">Pod使用PVC就像使用volume一样。集群检查PVC,查找绑定的PV,并映射PV给Pod。对于支持多种访问模式的PV,用户可以指定想用的模式。一旦用户拥有了一个PVC,并且PVC被绑定,那么只要用户还需要,PV就一直属于这个用户。用户调度Pod,通过在Pod的volume块中包含PVC来访问PV。<br>  </p> 
<p style="text-indent:0;"><strong>释放</strong></p> 
<p style="text-indent:33px;">当用户使用PV完毕后,他们可以通过API来删除PVC对象。当PVC被删除后,对应的PV就被认为是已经是“released”了,但还不能再给另外一个PVC使用。前一个PVC的属于还存在于该PV中,必须根据策略来处理掉。<br>  </p> 
<p style="text-indent:0;"><strong>回收</strong></p> 
<p style="text-indent:33px;">PV的回收策略告诉集群,在PV被释放之后集群应该如何处理该PV。当前,PV可以被Retained(保留)、 Recycled(再利用)或者Deleted(删除)。保留允许手动地再次声明资源。对于支持删除操作的PV卷,删除操作会从Kubernetes中移除PV对象,还有对应的外部存储(如AWS EBS,GCE PD,Azure Disk,或者Cinder volume)。动态供给的卷总是会被删除。</p> 
<p style="text-indent:33px;"> </p> 
<p style="text-indent:0;"> </p> 
<p style="text-indent:0;"><strong>NFS PV 示例</strong></p> 
<pre><code class="language-bash">vim nfs_pv.yaml</code></pre> 
<pre><code class="language-bash">  1 apiVersion: v1
  2 kind: PersistentVolume
  3 metadata:
  4   name: pv-test
  5 spec:
  6   capacity:
  7     storage: 5Gi
  8   volumeMode: Filesystem
  9   accessModes:
 10     - ReadWriteOnce
 11   persistentVolumeReclaimPolicy: Recycle
 12   storageClassName: slow
 13   mountOptions:
 14     - hard
 15     - nfsvers=4.1
 16   nfs:
 17     path: /nfs
 18     server: 192.168.1.103
</code></pre> 
<p style="text-indent:0;"><img alt="" height="110" src="https://images2.imgbox.com/c4/b9/0AdKdsCz_o.png" width="956"></p> 
<p style="text-indent:0;"> </p> 
<p style="text-indent:0;"><strong>访问模式</strong></p> 
<ul><li>ReadWriteOnce -- 该volume只能被单个节点以读写的方式映射</li><li>ReadOnlyMany -- 该volume可以被多个节点以只读方式映射</li><li>ReadWriteMany -- 该volume可以被多个节点以读写的方式映射</li></ul> 
<p style="text-indent:0;">在命令行中,访问模式可以简写为:</p> 
<ul><li>RWO - ReadWriteOnce</li><li>ROX - ReadOnlyMany</li><li>RWX - ReadWriteMany</li></ul> 
<p style="text-indent:0px;"> </p> 
<p style="text-indent:0px;"><strong>回收策略</strong></p> 
<ul><li>Retain:保留,需要手动回收</li><li>Recycle:回收,自动删除卷中数据</li><li>Delete:删除,相关联的存储资产,如AWS EBS,GCE PD,Azure Disk,or OpenStack Cinder卷都会被删除</li></ul> 
<p style="text-indent:0px;">当前,只有NFS和HostPath支持回收利用,AWS EBS,GCE PD,Azure Disk,or OpenStack Cinder卷支持删除操作。</p> 
<p style="text-indent:0px;"> </p> 
<p style="text-indent:0px;"><strong>状态:</strong></p> 
<ul><li>Available:空闲的资源,未绑定给PVC</li><li>Bound:绑定给了某个PVC</li><li>Released:PVC已经删除了,但是PV还没有被集群回收</li><li>Failed:PV在自动回收中失败了</li><li>命令行可以显示PV绑定的PVC名称。</li></ul> 
<p style="text-indent:0px;"> </p> 
<p style="text-indent:0px;"><strong>NFS持久化存储实战:</strong></p> 
<ul><li style="text-indent:0px;">安装配置NFS服务:</li></ul> 
<pre><code class="language-bash">yum install -y nfs-utils
systemctl start nfs-server
mkdir -m 777 /nfsdata
vim /etc/exports</code></pre> 
<p style="text-indent:0px;"><img alt="" height="21" src="https://images2.imgbox.com/ce/66/20BvDlsL_o.png" width="229"> </p> 
<pre><code class="language-bash">exportfs -rv
</code></pre> 
<p style="text-indent:0px;"> </p> 
<ul><li style="text-indent:0px;">创建NFS PV卷:</li></ul> 
<pre><code class="language-bash">vim pv1.yaml
</code></pre> 
<pre><code class="language-bash">  1 apiVersion: v1
  2 kind: PersistentVolume
  3 metadata:
  4   name: nfs-pv1
  5 spec:
  6   capacity:
  7     storage: 1Gi
  8   volumeMode: Filesystem
  9   accessModes:
 10     - ReadWriteOnce
 11   persistentVolumeReclaimPolicy: Recycle
 12   storageClassName: nfs
 13   nfs:
 14     path: /nfsdata
 15     server: 192.168.1.103
</code></pre> 
<pre><code class="language-bash">kubectl create -f pv1.yaml
kubectl get pv</code></pre> 
<p><img alt="" height="109" src="https://images2.imgbox.com/32/95/xXz0bkAV_o.png" width="935"></p> 
<p> </p> 
<ul><li>创建PVC</li></ul> 
<pre><code class="language-bash">vim pvc1.yaml
</code></pre> 
<pre><code class="language-bash">  1 apiVersion: v1
  2 kind: PersistentVolumeClaim
  3 metadata:
  4   name: pvc1
  5 spec:
  6   storageClassName: nfs
  7   accessModes:
  8     - ReadWriteOnce
  9   resources:
 10     requests:
 11       storage: 1Gi
</code></pre> 
<pre><code class="language-bash">kubectl create -f pvc1.yaml
kubectl get pvc
</code></pre> 
<p><img alt="" height="131" src="https://images2.imgbox.com/cb/3d/QoA03uHf_o.png" width="861"></p> 
<p> </p> 
<ul><li>Pod挂载PV</li></ul> 
<pre><code class="language-bash">vim pod-pv.yaml
</code></pre> 
<pre><code class="language-bash">  1 apiVersion: v1
  2 kind: Pod
  3 metadata:
  4   name: test-pd
  5 spec:
  6   containers:
  7   - name: nginx
  8     image: reg.harbor.com/library/nginx
  9     volumeMounts:
 10     - mountPath: /usr/share/nginx/html
 11       name: pv1
 12   volumes:
 13   - name: pv1
 14     persistentVolumeClaim:
 15       claimName: pvc1
</code></pre> 
<pre><code class="language-bash">kubectl create -f pod-pv.yaml 
kubectl get pods test-pd -o wide
</code></pre> 
<p><img alt="" height="272" src="https://images2.imgbox.com/f9/85/TGFtmfDs_o.png" width="959"></p> 
<p>通过curl访问，可以看出，我们将nfs挂载到pv，然后将pv挂载到nginx发布目录，访问到的页面正是nfs共享的</p> 
<p>在nfs共享目录更改</p> 
<p><img alt="" height="67" src="https://images2.imgbox.com/32/bd/TknHKBtq_o.png" width="422"></p> 
<p>再访问</p> 
<p><img alt="" height="91" src="https://images2.imgbox.com/16/bd/LWpwHYUl_o.png" width="388"></p> 
<p> </p> 
<ul><li>StorageClass提供了一种描述存储类(class)的方法,不同的class可能会映射到不同的服务质量等级和备份策略或其他策略等。</li><li>每个 StorageClass 都包含 provisioner、parameters 和 reclaimPolicy 字段, 这些字段会在StorageClass需要动态分配 PersistentVolume 时会使用到</li></ul> 
<p><strong>StorageClass的属性</strong></p> 
<ul><li>Provisioner(存储分配器):用来决定使用哪个卷插件分配 PV,该字段必须指定。可以指定内部分配器,也可以指定外部分配器。外部分配器的代码地址为: kubernetes-incubator/external-storage,其中包括NFS和Ceph等。</li><li>Reclaim Policy(回收策略):通过reclaimPolicy字段指定创建的Persistent Volume的回收策略,回收策略包括:Delete 或者 Retain,没有指定默认为Delete。</li><li>更多属性查看:https://kubernetes.io/zh/docs/concepts/storage/storage-classes/</li></ul> 
<p> </p> 
<p><strong>NFS Client Provisioner是一个automatic provisioner,使用NFS作为存储,自动创建PV和对应的PVC,本身不提供NFS存储,需要外部先有一套NFS存储服务。</strong></p> 
<ul><li>PV以 ${namespace}-${pvcName}-${pvName}的命名格式提供(在NFS服务器上)</li><li>PV回收的时候以 archieved-${namespace}-${pvcName}-${pvName} 的命名格式(在NFS服务器上)</li><li>nfs-client-provisioner源码地址:<a href="https://github.com/kubernetes-incubator/external-storage/tree/master/nfs-client">https://github.com/kubernetes-incubator/external-storage/tree/master/nfs-client</a></li></ul> 
<p> </p> 
<p><strong>NFS动态分配PV示例:</strong></p> 
<p>配置授权</p> 
<pre><code class="language-bash">vim rbac.yaml</code></pre> 
<pre><code>apiVersion: v1
kind: ServiceAccount
metadata:
  name: nfs-client-provisioner
# replace with namespace where provisioner is deployed
  namespace: default

---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: nfs-client-provisioner-runner
rules:
  - apiGroups: [""]
    resources: ["persistentvolumes"]
    verbs: ["get", "list", "watch", "create", "delete"]
  - apiGroups: [""]
    resources: ["persistentvolumeclaims"]
    verbs: ["get", "list", "watch", "update"]
  - apiGroups: ["storage.k8s.io"]
    resources: ["storageclasses"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create", "update", "patch"]

---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: run-nfs-client-provisioner
subjects:
  - kind: ServiceAccount
    name: nfs-client-provisioner
# replace with namespace where provisioner is deployed
    namespace: default
roleRef:
  kind: ClusterRole
  name: nfs-client-provisioner-runner
  apiGroup: rbac.authorization.k8s.io

---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: leader-locking-nfs-client-provisioner
# replace with namespace where provisioner is deployed
  namespace: default
rules:
  - apiGroups: [""]
    resources: ["endpoints"]
    verbs: ["get", "list", "watch", "create", "update", "patch"]

---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: leader-locking-nfs-client-provisioner
# replace with namespace where provisioner is deployed
  namespace: default
subjects:
  - kind: ServiceAccount
    name: nfs-client-provisioner 
# replace with namespace where provisioner is deployed
    namespace: default
roleRef:
  kind: Role
  name: leader-locking-nfs-client-provisioner
  apiGroup: rbac.authorization.k8s.io
</code></pre> 
<pre><code class="language-bash">kubectl create -f rbac.yaml </code></pre> 
<p><img alt="" height="116" src="https://images2.imgbox.com/5e/ec/c7g6jkV1_o.png" width="775"></p> 
<p> </p> 
<p>部署NFS Client Provisioner</p> 
<pre><code class="language-bash">vim deployment.yaml</code></pre> 
<pre><code class="language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nfs-client-provisioner
  labels:
    app: nfs-client-provisioner
  namespace: default
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: nfs-client-provisioner
  template:
    metadata:
      labels:
        app: nfs-client-provisioner
    spec:
      serviceAccountName: nfs-client-provisioner
      containers:
      - name: nfs-client-provisioner
        image: reg.harbor.com/library/nfs-client-provisioner  ##我是提前从阿里云镜像仓库下载好上传到私有harbor仓库的
        volumeMounts:
          - name: nfs-client-root
            mountPath: /persistentvolumes
        env:
          - name: PROVISIONER_NAME
            value: huayu.com/nfs
          - name: NFS_SERVER
            value: 192.168.1.103
          - name: NFS_PATH
            value: /nfsdata
      volumes:
      - name: nfs-client-root
        nfs:
          server: 192.168.1.103
          path: "/nfsdata"
</code></pre> 
<pre><code class="language-bash">kubectl create -f deployment.yaml </code></pre> 
<p> </p> 
<p>创建 NFS SotageClass</p> 
<pre><code class="language-bash">vim class.yaml</code></pre> 
<pre><code>  1 apiVersion: storage.k8s.io/v1
  2 kind: StorageClass
  3 metadata:
  4   name: managed-nfs-storage
  5 provisioner: huayu.com/nfs
  6 parameters:
  7   archiveOnDelete: "false"
</code></pre> 
<p>archiveOnDelete: "false"表示在删除时不会对数据进行打包</p> 
<pre><code class="language-bash">kubectl create -f class.yaml 
kubectl get storageclasses.storage.k8s.io 
</code></pre> 
<p><img alt="" height="145" src="https://images2.imgbox.com/5d/f4/UDnQqEeR_o.png" width="961"></p> 
<p> </p> 
<p>创建PVC</p> 
<pre><code class="language-bash">vim test-claim.yaml</code></pre> 
<pre><code>  1 kind: PersistentVolumeClaim
  2 apiVersion: v1
  3 metadata:
  4   name: nfs-pv1
  5   annotations:
  6     volume.beta.kubernetes.io/storage-class: "managed-nfs-storage"
  7 spec:
  8   accessModes:
  9     - ReadWriteMany
 10   resources:
 11     requests:
 12       storage: 100Mi
</code></pre> 
<p> </p> 
<pre><code class="language-bash"> kubectl create -f test-claim.yaml </code></pre> 
<p><img alt="" height="71" src="https://images2.imgbox.com/f3/de/NbrMPOwn_o.png" width="1093"></p> 
<p> </p> 
<p>创建测试Pod</p> 
<pre><code class="language-bash">vim test-pod.yaml      ##将pv1挂载到本机目录，写入success </code></pre> 
<pre><code>  1 kind: Pod
  2 apiVersion: v1
  3 metadata:
  4   name: test-pod
  5 spec:
  6   containers:
  7   - name: test-pod
  8     image: reg.harbor.com/library/busybox
  9     command:
 10       - "/bin/sh"
 11     args:
 12       - "-c"
 13       - "touch /mnt/SUCCESS &amp;&amp; exit 0 || exit 1"
 14     volumeMounts:
 15     - name: nfs-pvc
 16       mountPath: "/mnt"
 17   restartPolicy: "Never"
 18   volumes:
 19   - name: nfs-pvc
 20     persistentVolumeClaim:
 21       claimName: nfs-pv1
</code></pre> 
<pre><code class="language-bash">kubectl create -f test-pod.yaml 
</code></pre> 
<p>NFS服务端查看</p> 
<pre><code class="language-bash">ls default-nfs-pv1-pvc-82c2aa9e-ae0b-424a-b245-6da8f359524e/</code></pre> 
<p><img alt="" height="58" src="https://images2.imgbox.com/d7/59/1kZ73R3i_o.png" width="810"></p> 
<p> </p> 
<ul><li>默认的 StorageClass 将被用于动态的为没有特定 storage class 需求的PersistentVolumeClaims 配置存储:(只能有一个默认StorageClass)</li><li>如果没有默认StorageClass,PVC 也没有指定storageClassName 的值,那么意味着它只能够跟 storageClassName 相同的 PV 进行绑定。</li></ul> 
<p>设置StorageClass为默认</p> 
<pre><code class="language-bash">kubectl patch storageclasses.storage.k8s.io managed-nfs-storage  -p '{"metadata":
{"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'
</code></pre> 
<p><img alt="" height="110" src="https://images2.imgbox.com/25/2c/R9GX8N1I_o.png" width="1119"></p> 
<p> </p> 
<h3>StatefulSet</h3> 
<p><strong>StatefulSet通过Headless Service维持Pod的拓扑状态</strong></p> 
<p>创建Headless service</p> 
<pre><code>vim headless.yaml
</code></pre> 
<pre><code>  1 apiVersion: v1
  2 kind: Service
  3 metadata:
  4   name: nginx
  5   labels:
  6     app: nginx
  7 spec:
  8   ports:
  9   - port: 80
 10     name: web
 11   clusterIP: None
 12   selector:
 13     app: nginx
</code></pre> 
<p> </p> 
<p>StatefulSet控制器</p> 
<pre><code class="language-bash">vim stateful.yaml
</code></pre> 
<pre><code>  1 apiVersion: apps/v1
  2 kind: StatefulSet
  3 metadata:
  4   name: web
  5 spec:
  6   serviceName: "nginx"
  7   replicas: 2
  8   selector:
  9     matchLabels:
 10       app: nginx
 11   template:
 12     metadata:
 13       labels:
 14         app: nginx
 15     spec:
 16       containers:
 17       - name: nginx
 18         image: reg.harbor.com/library/nginx
 19         ports:
 20         - containerPort: 80
 21           name: web
</code></pre> 
<pre><code class="language-bash">kubectl create -f stateful.yaml 
kubectl create -f headless.yaml
kubectl get statefulsets.apps</code></pre> 
<p><img alt="" height="134" src="https://images2.imgbox.com/f3/74/jlIs3u6B_o.png" width="557"></p> 
<pre><code class="language-bash">kubectl get services
kubectl get pod -o wide</code></pre> 
<p><img alt="" height="252" src="https://images2.imgbox.com/2a/93/A6QeCWrq_o.png" width="1200"></p> 
<p> </p> 
<p><strong>StatefulSet将应用状态抽象成了两种情况:</strong></p> 
<ul><li>拓扑状态:应用实例必须按照某种顺序启动。新创建的Pod必须和原来Pod的网络标识一样</li><li>存储状态:应用的多个实例分别绑定了不同存储数据。</li></ul> 
<p>StatefulSet给所有的Pod进行了编号,编号规则是:$(statefulset名称)-$(序号),从0开始</p> 
<p>Pod被删除后重建,重建Pod的网络标识也不会改变,Pod的拓扑状态按照Pod的“名字+编号”的方式固定下来,并且为每个Pod提供了一个固定且唯一的访问入口,即Pod对应的DNS记录。</p> 
<pre><code class="language-bash">dig -t A web-0.nginx.default.svc.cluster.local @10.96.0.10
</code></pre> 
<p><img alt="" height="413" src="https://images2.imgbox.com/ff/12/HICT871E_o.png" width="973"></p> 
<pre><code class="language-bash">kubectl get pods -o wide</code></pre> 
<p><img alt="" height="133" src="https://images2.imgbox.com/15/07/ZfojSJGb_o.png" width="1200"></p> 
<pre><code class="language-bash">kubectl delete pod --all
kubectl get pods -o wide
</code></pre> 
<p><img alt="" height="331" src="https://images2.imgbox.com/22/84/IKfmuqjd_o.png" width="1200"></p> 
<pre><code class="language-bash">dig -t A web-0.nginx.default.svc.cluster.local @10.96.0.10
</code></pre> 
<p><img alt="" height="419" src="https://images2.imgbox.com/7b/3d/rQw9c5yO_o.png" width="949"></p> 
<p> </p> 
<p><strong>PV和PVC的设计,使得StatefulSet对存储状态的管理有了可能</strong></p> 
<pre><code class="language-bash">vim statefulset.yaml 
</code></pre> 
<pre><code>  1 apiVersion: apps/v1
  2 kind: StatefulSet
  3 metadata:
  4   name: web
  5 spec:
  6   serviceName: "nginx-svc"
  7   replicas: 3
  8   selector:
  9     matchLabels:
 10       app: nginx
 11   template:
 12     metadata:
 13       labels:
 14         app: nginx
 15     spec:
 16       containers:
 17       - name: nginx
 18         image: reg.harbor.com/library/nginx
 19         volumeMounts:
 20         - name: www
 21           mountPath: /usr/share/nginx/html
 22   volumeClaimTemplates:
 23   - metadata:
 24       name: www
 25     spec:
 26       storageClassName: managed-nfs-storage
 27       accessModes:
 28       - ReadWriteOnce
 29       resources:
 30         requests:
 31           storage: 1Gi
</code></pre> 
<p>Pod的创建也是严格按照编号顺序进行的。比如在web-0进入到running状态,并且Conditions为Ready之前,web-1一直会处于pending状态</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/49/a4/AsqaT3MF_o.png" width="1061"></p> 
<p> </p> 
<p>StatefulSet还会为每一个Pod分配并创建一个同样编号的PVC。这样,kubernetes就可以通过Persistent Volume机制为这个PVC绑定对应的PV,从而保证每一个Pod都拥有一个独立的Volume。</p> 
<p><img alt="" height="219" src="https://images2.imgbox.com/b1/94/kKasDEKU_o.png" width="1094"></p> 
<p><br><br><strong>kubectl 弹缩</strong><br> 首先,想要弹缩的StatefulSet. 需先清楚是否能弹缩该应用.</p> 
<pre><code class="language-bash">kubectl get statefulsets &lt;stateful-set-name&gt;</code></pre> 
<p><strong>改变StatefulSet副本数量</strong></p> 
<pre><code>kubectl scale statefulsets &lt;stateful-set-name&gt; --replicas=&lt;new-replicas&gt;</code></pre> 
<p><strong>如果StatefulSet开始由 kubectl apply 或 kubectl create --save-config 创建,更新StatefulSet manifests中的 .spec.replicas, 然后执行命令 kubectl apply</strong></p> 
<pre><code>kubectl apply -f &lt;stateful-set-file-updated&gt;</code></pre> 
<p><strong>也可以通过命令 kubectl edit 编辑该字段:</strong></p> 
<pre><code>kubectl edit statefulsets &lt;stateful-set-name&gt;</code></pre> 
<p><strong>使用 kubectl patch:</strong></p> 
<pre><code>kubectl patch statefulsets &lt;stateful-set-name&gt; -p '{"spec":{"replicas":&lt;new-replicas&gt;}}'</code></pre> 
<p> </p> 
<p><strong>使用statefullset部署mysql主从集群:</strong></p> 
<p><a href="https://kubernetes.io/zh/docs/tasks/run-application/run-replicated-stateful-application/" rel="nofollow">https://kubernetes.io/zh/docs/tasks/run-application/run-replicated-stateful-application/</a></p> 
<p><img alt="" height="703" src="https://images2.imgbox.com/f0/ac/FJi4Lqzn_o.png" width="1057"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd7edabb4feb4382ff0e4024ccd30225/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vivado ILA在线逻辑仪使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/965f256f8aaf4d35b09a1084a2724c38/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java为什么调用接口，就可以调用到接口的实现类的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>