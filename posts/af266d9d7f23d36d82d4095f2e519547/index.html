<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第十三届蓝桥杯省赛JavaA组解析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第十三届蓝桥杯省赛JavaA组解析" />
<meta property="og:description" content="public class Main{
public static void main(String[] args){
System.out.println(4&#43;(20-1)&#43;20*(22-1));
}
答案：443
方法一：蛮力算法，注意Long.MAX_VALUE为：9223372036854775807，闲着没事干儿可以用这个方法，答案约等于2e15&lt;9e18(Long的最大值)，可以循环出结果
public class Main {
public static void main(String[] args) {
long m=Long.MAX_VALUE;
for(long i=0;i&lt;m;i&#43;&#43;) {
if(
i%2==1&amp;&amp;
i%3==1&amp;&amp;
i%4==1&amp;&amp;
i%5==1&amp;&amp;
i%6==1&amp;&amp;
i%7==1&amp;&amp;
i%8==1&amp;&amp;
//此处省略
i%48==41&amp;&amp;
i%49==46
) {
System.out.println(i);
}else {
System.out.println(&#34;没有找到&#34;);
}
}
}
}
方法二：利用步长逐步累加
public class Main{
public static void main(String[] args) { int[] a = {
0, 0,//为了使a[i]与i匹配，这里放入0填充a[0],a[1]
1, 2, 1, 4, 5, 4, 1, 2, 9, 0, 5, 10," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/af266d9d7f23d36d82d4095f2e519547/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-06T23:43:07+08:00" />
<meta property="article:modified_time" content="2023-04-06T23:43:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第十三届蓝桥杯省赛JavaA组解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="900" src="https://images2.imgbox.com/fb/38/L88oINHN_o.png" width="842"></p> 
<p>public class Main{<!-- --><br>     public static void main(String[] args){<!-- --><br>         System.out.println(4+(20-1)+20*(22-1));<br> }</p> 
<p>答案：443</p> 
<p><img alt="" height="876" src="https://images2.imgbox.com/fd/c3/H2Hfejqe_o.png" width="841"></p> 
<p> 方法一：蛮力算法，注意Long.MAX_VALUE为：9223372036854775807，闲着没事干儿可以用这个方法，答案约等于2e15&lt;9e18(Long的最大值)，可以循环出结果</p> 
<p>public class Main {<!-- --></p> 
<p>    public static void main(String[] args) {<!-- --><br>         long m=Long.MAX_VALUE;<br>         for(long i=0;i&lt;m;i++) {<!-- --><br>                 if(<br>                         i%2==1&amp;&amp;<br>                         i%3==1&amp;&amp;<br>                         i%4==1&amp;&amp;<br>                         i%5==1&amp;&amp;<br>                         i%6==1&amp;&amp;<br>                         i%7==1&amp;&amp;<br>                         i%8==1&amp;&amp;<br>                         //此处省略<br>                         i%48==41&amp;&amp;<br>                         i%49==46<br>                         ) {<!-- --><br>                     System.out.println(i);<br>                 }else {<!-- --><br>                     System.out.println("没有找到");<br>                 }<br>         }<br>     }<br> }<br>  </p> 
<p>方法二：利用步长逐步累加</p> 
<p>public class Main{<!-- --><br>     <br>     public static void main(String[] args) {   <br>         int[] a = {<!-- --><br>                 0, 0,//为了使a[i]与i匹配，这里放入0填充a[0],a[1]<br>                 1, 2, 1, 4, 5, 4, 1, 2, 9, 0, 5, 10,<br>                 11, 14, 9, 0, 11, 18, 9, 11, 11, 15, 17, 9,<br>                 23, 20, 25, 16, 29, 27, 25, 11, 17, 4, 29, 22,<br>                 37, 23, 9, 1, 11, 11, 33, 29, 15, 5, 41, 46<br>                 };<br>         long begin = 1;//满足题给条件的第一个模2的情况，即模2等于1的情况<br>         long step = 1;<br>         for (int i = 2; i &lt; a.length - 1; i++) {<!-- --><br>             step = lcm(step, i);//每个步长本质就是前面i-1个数（除数）的最小公倍数<br>             while (begin% (i + 1) != a[i + 1]) {<!-- --><br>                 begin += step;//步长的作用就是为满足下一次模运算而逐步累加到目标值<br>             }<br>         }<br>         System.out.println(begin);<br>     }</p> 
<p>    //求最大公约数,不用考虑a，b的大小关系，可以自动调整<br>     private static long gcd(long a, long b) {<!-- --><br>         if (b == 0) return a;<br>         return gcd(b, a % b);<br>     }</p> 
<p>    //求最小公倍数<br>     private static long lcm(long a, long b) {<!-- --><br>         return (a * b)/ gcd(a, b) ;<br>     }<br> }<br> 答案：2022040920220409</p> 
<p><img alt="" height="865" src="https://images2.imgbox.com/dc/e0/S1ZqO4vZ_o.png" width="823"></p> 
<p>import java.util.Scanner;</p> 
<p>public class Mian {<!-- --></p> 
<p>    public static void main(String[] args) {<!-- --><br>         Scanner sc=new Scanner(System.in);<br>         int n=sc.nextInt();<br>         int a[]=new int[n];<br>         for(int i=0;i&lt;a.length;i++) {<!-- --><br>             a[i]=sc.nextInt();<br>         }<br>         long s = 0;<br>         for(int i=0;i&lt;a.length;i++) {<!-- --><br>             for(int j=i+1;j&lt;a.length;j++) {<!-- --><br>                 s+=a[i]*a[j];<br>             }<br>         }<br>         System.out.print(s);<br>     }</p> 
<p>}</p> 
<p>样例答案：117</p> 
<p><img alt="" height="845" src="https://images2.imgbox.com/c5/9c/YpaIJX82_o.png" width="834"></p> 
<p> 法一：</p> 
<p>public class Main{<!-- --></p> 
<p>    public static void main(String[] args) {<!-- --><br>         Scanner sc=new Scanner(System.in);<br>         int a=sc.nextInt();<br>         int b=sc.nextInt(),m;<br>         m=Math.abs(a-b);        /*假设m可被a+k，b+k整除，那么a%m=b%m,则(a-b)%m=0,要使得m最大，只需要令a-b的绝对值等于m即可。*/<br>         System.out.print((m-a%m)%m);        /*因为（a+k）%m=0，则a%m（或b%m）得到一个余数，而k值就是m-a%d，k值要保证最小，那么用k%m即可得到结果。*/<br>     }<br> }</p> 
<p>法二：</p> 
<p>令m=|a-b|，m就是a，b的最大公约数或者是最大公约数的最大倍数，即m确定了公约数的上限，m的大小位置有两个，一个是m在（a,b）之间，另一个是m比a和b都小。</p> 
<p>第一种情况下，k值就是m-min（a，b）</p> 
<p>第二种情况下，找到一个最小整数n，使得m*n&gt;a，则k=m*n-a；或者找到一个最小整数n，使得m*n&gt;b，则k=m*n-b</p> 
<p>import java.util.*;<br> public class Main {<!-- --><br>     public static void main(String args[]){<!-- --><br>         Scanner in=new Scanner(System.in);<br>         long a,b;<br>         long m;<br>         a=in.nextLong();<br>         b=in.nextLong();<br>         m=Math.abs(a-b);<br>         long k=0;<br>         if(a==m||b==m) k=0;<br>         else if(m&lt;=a&amp;&amp;m&lt;=b) {<!-- --><br>             long temp;<br>             long t;<br>            t=Math.max(a,b)/m+1;<br>            k=t*m-Math.max(a, b);<br>         }<br>         else {<!-- --><br>             k=m-Math.min(a, b);<br>         }<br>         System.out.println(k);<br>     }<br> }</p> 
<p><img alt="" height="779" src="https://images2.imgbox.com/6d/08/Rs41cExF_o.png" width="838"></p> 
<p> 参见：<a href="https://blog.csdn.net/Wuxynb/article/details/124933300?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168077094516800211527442%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168077094516800211527442&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-124933300-null-null.142%5Ev81%5Einsert_down1,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%9C%82%E5%B7%A2%E9%97%AE%E9%A2%98java&amp;spm=1018.2226.3001.4187" title="(12条消息) 第十三届蓝桥杯【蜂巢】最简单的解法_Wuxy1999的博客-CSDN博客">(12条消息) 第十三届蓝桥杯【蜂巢】最简单的解法_Wuxy1999的博客-CSDN博客</a></p> 
<p> <img alt="" height="761" src="https://images2.imgbox.com/e4/72/ME8giVii_o.png" width="830"></p> 
<p> import java.util.Scanner;<br> public class Main {<!-- --><br>     public static void main(String[] args) {<!-- --><br>              Scanner sc = new Scanner(System.in);<br>              int n= sc.nextInt();<br>              long num=1;             <br>              long sum=1;<br>              long []dp=new long[n+1];<br>              dp[0]=0;<br>              dp[1]=0;<br>              for (int i = 2; i &lt;=n ; i++) {<!-- --><br>                  dp[i]=(dp[i-1]*(i)+num*sum)%998244353;<br>                  sum=(sum+i)%998244353;<br>                  num=(num*i)%998244353;<br>              }<br>              System.out.println(dp[n]);<br>     }<br> }</p> 
<p>此处用到动态规划，数值n的全排列的价值可分为两部分，一部分是dp[n-1]*n，另外一部分是（n-1）!*(1+2+...+n-1)。</p> 
<p>第一部分，dp[n-1]的价值假定已经确定，那么插入第n个数字的时候，每一个原排列会新产生n个新排列，那么全部新排列的价值就是dp[n-1]*n。例如，dp[4-1]的价值已经确定是9，那么插入第4个数字（也就是4），第一个原排列123会产生4123,1423,1243,1234四个新排列，而原排列一共有3！个，那么新的排列总共就有24个，但这24个排列在不考虑数字4引起的价值变化的前提下，全排列价值仅发生倍数变化，就是dp[3]*4，价值变化的原因也仅仅是排列数量的增多而已。</p> 
<p></p> 
<p>第二部分，我们的第一部分已经考虑了插入第n个数字后，排列增多引起的价值变化，但我们没有考虑第n个数字引起的价值变化。n-1个数字的排列有(n-1)!个，而对于每个排列，排列的间隔不会改变，数字n的插入位置有n种选择，插入数字n后，n的前面有几个数字，那么这个排列因为n的价值就是几（n在这个排列里面最大）。例如排列123，插入4，就有4123,1423,1243,1234，价值分别为0,1,2,3。所以，插入n引起的价值变化有（n-1）!*(1+2+...+n-1)。</p> 
<p><img alt="" height="664" src="https://images2.imgbox.com/98/40/f7o4jJiZ_o.png" width="750"></p> 
<p> </p> 
<p><img alt="" height="572" src="https://images2.imgbox.com/13/27/uqbDkB5k_o.png" width="757"></p> 
<p>法一：此方法思路简单，但已经超时</p> 
<p>import java.util.Scanner;<br> public class Main {<!-- --><br>     public static void main(String[] args) {<!-- --><br>         long x=0;<br>         int n;<br>         Scanner s=new Scanner(System.in);<br>         n=s.nextInt();<br>         for(int i=1;i&lt;n+1;i++) {<!-- --><br>             x+=f(i);<br>         }<br>         System.out.print(x%(1e9+7));<br>     }<br>     private static long f(long x) {<!-- --><br>         long a=0;<br>         for(long i=1;i&lt;x+1;i++) {<!-- --><br>             if(x%i==0)a+=i*i;<br>         }<br>         return a;        <br>     }<br> }</p> 
<p>法二：仅适用问题规模较小时，摘自https://blog.csdn.net/qq_46311811/article/details/124067689</p> 
<p>import java.util.Scanner;</p> 
<p>public class Main{<!-- --><br>     public static void main(String[] args) {<!-- --><br>         Scanner sc = new Scanner(System.in);<br>         int n = sc.nextInt();<br>         sc.close();</p> 
<p>        long[] arr = new long[n + 1];<br>         long sum = 0;<br>         for (long i = 1; i &lt; arr.length; i++) {<!-- --><br>             long j = i;<br>             while (j &lt; arr.length) {<!-- --><br>                 arr[(int) j] = (arr[(int) j] + i * i) % 1000000007;<br>                 j += i;<br>             }<br>             sum = (sum + arr[(int) i]) % 1000000007;<br>         }</p> 
<p>        System.out.println(sum);<br>     }<br> }<br> 法三：最优算法，摘自https://blog.csdn.net/feng8403000/article/details/128891276</p> 
<p>import java.util.Scanner;<br> public class Main{<!-- --><br>     public static void main(String[] args) {<!-- --><br>         final long N = 1000000007;<br>         final long inv6 = 166666668;<br>         Scanner sc = new Scanner(System.in);<br>         long res = 0, temp = 0, sum = 0;<br>         long n, l, r, k;<br>         n = sc.nextInt();<br>         sc.close();<br>         for (long i = 1; i &lt;= n; i = r + 1) {<!-- --><br>             l = i;<br>             k = n / i;<br>             r = n / (n / l);<br>             temp = sum;<br>             sum = r * (r + (long) 1) % N * ((long) 2 * r + 1) % N * inv6 % N;<br>             res = (res + k * (sum - temp) + N) % N;<br>         }<br>         System.out.println(res);<br>     }<br> }<br><img alt="" height="697" src="https://images2.imgbox.com/83/c5/6dlZ0jYr_o.png" width="739"></p> 
<p> </p> 
<p>import java.util.Arrays;<br> import java.util.Scanner;<br> public class Main {<!-- --><br>     public static void main(String[] args) {<!-- --><br>         Scanner sc = new Scanner(System.in);<br>         int n,k ;<br>         n = sc.nextInt();<br>         k = sc.nextInt();<br>         int a[]= new int[n];<br>         for(int i=0;i&lt;a.length;i++) {<!-- --><br>             a[i] = sc.nextInt();<br>         }<br>         //Arrays.sort(a);<br>         System.out.println(f(a,k));        <br>     }<br>     private static  long f(int b[], int k) {<!-- --><br>         int count = 0;//用于计数    <br>         int location = 0;//用于标记在数组中的位置<br>         while(location &lt;= b.length -k) {//按步长k移动到最后b.length%k时，可以退出循环<br>             long min = Integer.MAX_VALUE;<br>             int c = 0;<br>             for(int i=location ;i&lt;location+k;i++){//在步长k内进行循环，找到最小值<br>                 if(b[i] &lt;= min) {<!-- --><br>                     min = b[i];<br>                     c = i;//假定序列已经按升序进行排列<br>                 }<br>             }<br>             for(int i=location;i&lt;location+k;i++) {<!-- --><br>                 b[i]-=min;//这里的min就是连续k个数统一减小的次数<br>             }<br>             count+=min;<br>             location=c+1;//记录下一次起始位置<br>         }        <br>         for(int j=location;j&lt;b.length;j++) {//此时只能一个数一次一次的减小<br>             count+=b[j];<br>         }<br>         return count;<br>     }    <br> }</p> 
<p><img alt="" height="563" src="https://images2.imgbox.com/51/ec/XklB8tgs_o.png" width="750"></p> 
<p>摘录自<a href="https://blog.csdn.net/qq_46311811/article/details/124067689" title="2022年蓝桥杯省赛java A组考后总结_java蓝桥杯a组_Hydrion-Qlz的博客-CSDN博客">2022年蓝桥杯省赛java A组考后总结_java蓝桥杯a组_Hydrion-Qlz的博客-CSDN博客</a></p> 
<p>import java.io.BufferedReader;<br> import java.io.IOException;<br> import java.io.InputStreamReader;<br> import java.io.StreamTokenizer;</p> 
<p>public class Main{<!-- --><br>     static BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));<br>     static StreamTokenizer in = new StreamTokenizer(bf);</p> 
<p>    static int nextInt() throws IOException {<!-- --><br>         in.nextToken();<br>         return (int) in.nval;<br>     }</p> 
<p>    public static void main(String[] args) throws IOException {<!-- --><br>         int N = nextInt();<br>         int M = nextInt();<br>         int Q = nextInt();<br>         int[][] knowArr = new int[N][N];<br>         int[][] givenArr = new int[M][2];<br>         for (int i = 0; i &lt; givenArr.length; i++) {<!-- --><br>             int l = nextInt() - 1;<br>             int r = nextInt() - 1;<br>             int S = nextInt();<br>             knowArr[l][r] = S;<br>             // 以l为终点<br>             if (l &gt; 0) {<!-- --><br>                 for (int j = 0; j &lt; N &amp;&amp; j &lt; l; j++) {<!-- --><br>                     if (knowArr[j][l - 1] != 0) {<!-- --><br>                         knowArr[j][r] = knowArr[j][l - 1] + S;<br>                     }<br>                 }<br>             }<br>             // 以l为起点<br>             if (l &lt; N - 1) {<!-- --><br>                 for (int j = l + 1; j &lt; N; j++) {<!-- --><br>                     if (knowArr[l][j] != 0) {<!-- --><br>                         if (j &lt; r) {<!-- --><br>                             knowArr[j + 1][r] = S - knowArr[l][j];<br>                         } else if (j &gt; r) {<!-- --><br>                             knowArr[r + 1][j] = knowArr[l][j] - S;<br>                         }<br>                     }<br>                 }<br>             }<br>             // 以r为终点<br>             if (r &gt; 0) {<!-- --><br>                 for (int j = 0; j &lt; N &amp;&amp; j &lt; r; j++) {<!-- --><br>                     if (knowArr[j][r] != 0) {<!-- --><br>                         if (j &lt; l) {<!-- --><br>                             knowArr[j][l - 1] = knowArr[j][r] - S;<br>                         } else if (j &gt; l) {<!-- --><br>                             knowArr[l][j - 1] = S - knowArr[j][r];<br>                         }<br>                     }<br>                 }<br>             }<br>             // 以r为起点<br>             if (r &lt; N - 1) {<!-- --><br>                 for (int j = r + 1; j &lt; N; j++) {<!-- --><br>                     if (knowArr[r][j] != 0) {<!-- --><br>                         knowArr[l][j] = S + knowArr[r][j];<br>                     }<br>                 }<br>             }<br>         }</p> 
<p>        for (int i = 0; i &lt; Q; i++) {<!-- --><br>             int l = nextInt() - 1;<br>             int r = nextInt() - 1;<br>             if (knowArr[l][r] != 0) {<!-- --><br>                 System.out.println(knowArr[l][r]);<br>             } else {<!-- --><br>                 System.out.println("UNKNOWN");<br>             }<br>         }<br>     }<br> }</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bc02f67cfc6ec640f0b150318783c6a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Manjaor连接wifi失败，wifi设备状态为unclaimed</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f3109679fb353382403fdfd94774bd8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">开关电源设计时如何减小地弹</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>