<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中super关键字介绍 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中super关键字介绍" />
<meta property="og:description" content="由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用 super 关键字。super 可以用来访问父类的构造方法、普通方法和属性。
super 关键字的功能：
在子类的构造方法中显式的调用父类构造方法访问父类的成员方法和变量。 1、使用super调用父类的构造方法 super必须是子类构造方法中头一条语句
当我们在父类中定义多个构造方法时，应当包括一个不带参数的构造方法，以防子类省略super时出现错误。
声明父类 Person 和子类 Student，在 Person 类中定义一个带有参数的构造方法，代码如下：
public class Person { public Person(String name) { } } public class Student extends Person { } 会发现 Student 类出现编译错误，提示必须显式定义构造方法，错误信息如下：
Implicit super constructor Person() is undefined for default constructor. Must define an explicit constructor
在本例中 JVM 默认给 Student 类加了一个无参构造方法，而在这个方法中默认调用了 super()，但是 Person 类中并不存在该构造方法，所以会编译错误。
如果一个类中没有写任何的构造方法，JVM 会生成一个默认的无参构造方法。在继承关系中，由于在子类的构造方法中，第一条语句默认为调用父类的无参构造方法（即默认为 super()，一般这行代码省略了）。所以当在父类中定义了有参构造方法，但是没有定义无参构造方法时，编译器会强制要求我们定义一个相同参数类型的构造方法。 子类 Student 继承了 Person 类，使用 super 语句来定义 Student 类的构造方法。示例代码如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/704a60bd5a498eda39d32a48742632df/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-18T23:09:08+08:00" />
<meta property="article:modified_time" content="2020-09-18T23:09:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中super关键字介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用 super 关键字。super 可以用来访问父类的构造方法、普通方法和属性。<br><br> super 关键字的功能：</p> 
<ul><li>在子类的构造方法中显式的调用父类构造方法</li><li>访问父类的成员方法和变量。</li></ul> 
<h3>1、使用super调用父类的构造方法</h3> 
<p>super必须是子类构造方法中头一条语句</p> 
<p style="margin-left:0in;"><span style="color:#000000;">当我们在父类中定义多个构造方法时，应当</span><span style="color:#000000;"><strong>包括一个不带参数的构造方法</strong></span><span style="color:#000000;">，以防子类省略</span><span style="color:#000000;">super</span><span style="color:#000000;">时出现</span><span style="color:#000000;">错误</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0in;">声明父类 Person 和子类 Student，在 Person 类中定义一个带有参数的构造方法，代码如下：</p> 
<pre><code class="language-java">public class Person {
    public Person(String name) {

    }
}
public class Student extends Person {

}</code></pre> 
<p>会发现 Student 类出现编译错误，提示必须显式定义构造方法，错误信息如下：</p> 
<blockquote> 
 <p>Implicit super constructor Person() is undefined for default constructor. Must define an explicit constructor</p> 
</blockquote> 
<p>在本例中 JVM 默认给 Student 类加了一个无参构造方法，而在这个方法中默认调用了 super()，但是 Person 类中并不存在该构造方法，所以会编译错误。<br><br> 如果一个类中没有写任何的构造方法，JVM 会生成一个默认的无参构造方法。在继承关系中，由于在子类的构造方法中，第一条语句默认为调用父类的无参构造方法（即默认为 super()，一般这行代码省略了）。所以当在父类中定义了有参构造方法，但是没有定义无参构造方法时，编译器会强制要求我们定义一个相同参数类型的构造方法。 </p> 
<p>子类 Student 继承了 Person 类，使用 super 语句来定义 Student 类的构造方法。示例代码如下：</p> 
<pre><code class="language-java">public class Student extends Person {
    public Student(String name, int age, String birth) {
        super(name, age); // 调用父类中含有2个参数的构造方法
    }

    public Student(String name, int age, String sex, String birth) {
        super(name, age, sex); // 调用父类中含有3个参数的构造方法
    }
}</code></pre> 
<p> 从上述 Student 类构造方法代码可以看出，super 可以用来直接调用父类中的构造方法，使编写代码也更加简洁方便。<br> 编译器会自动在子类构造方法的第一句加上<code>super();</code>来调用父类的无参构造方法，必须写在子类构造方法的第一句，也可以省略不写。通过 super 来调用父类其它构造方法时，只需要把相应的参数传过去。</p> 
<pre><code class="language-java">public class Student 
{
	int number;
	String name;
	Student(){
	}
	Student(int number, String name){
		this.number = number;
		this.name = name;
	}
	public int getNumber(){
		return number;
	}
	public String getName(){
		return name;
	}
}</code></pre> 
<pre><code class="language-java">public class UniverStudent extends Student
{
	boolean isMarriage;   //子类新增的结婚属性
	UniverStudent(int number, String name, boolean b){
		super(number, name);
	}
	public boolean getIsMarriage(){
		return isMarriage;
	}
}</code></pre> 
<pre><code class="language-java">public class Example5_6 
{
	public static void main(String[] args) 
	{
		UniverStudent zhang = new UniverStudent(20111, "张三", false);
		int number = zhang.getNumber();
		String name = zhang.getName();
		boolean marriage = zhang.getIsMarriage();
		System.out.println(name + "的学号是：" + number);
		if(marriage == true){
			System.out.println(name + "已婚");
		}
		else{
			System.out.println(name + "未婚");
		}
	}
}</code></pre> 
<p><img alt="" height="39" src="https://images2.imgbox.com/fa/a1/D75k4bNJ_o.png" width="163"></p> 
<h3>2、调用被隐藏的成员变量和方法</h3> 
<p>使用 super 访问父类中的成员与 this 关键字的使用相似，只不过它引用的是子类的父类，语法格式如下：</p> 
<blockquote> 
 <pre><code class="language-html hljs">super.member</code></pre> 
</blockquote> 
<p>其中，member 是父类中的属性或方法。使用 super 访问父类的属性和方法时不用位于第一行。</p> 
<p style="margin-left:0in;"><span style="color:#000000;">子类中想使用被子类隐藏的成员变量或方法就可以使用关键字</span><span style="color:#000000;">super</span><span style="color:#000000;">。比如</span><span style="color:#000000;">super.x</span><span style="color:#000000;">、</span><span style="color:#000000;">super.play</span><span style="color:#000000;">()</span><span style="color:#000000;">就是访问和调用被子类隐藏的成员变量</span><span style="color:#000000;">x</span><span style="color:#000000;">和方法</span><span style="color:#000000;">play()</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0in;"><span style="color:#000000;">当</span><span style="color:#000000;">super</span><span style="color:#000000;">调用隐藏的方法时，该方法中出现的成员变量是指被隐藏的成员变量</span></p> 
<p style="margin-left:0in;"><img alt="" height="310" src="https://images2.imgbox.com/55/f0/1p0VF6Nv_o.png" width="444"></p> 
<pre><code class="language-java">public class Sum 
{
	int n;
	public double f(){
		double sum = 0;
		for(int i = 1; i&lt;= n; i++){
			sum += i;
		}
		return sum;
	}
}</code></pre> 
<pre><code class="language-java">public class Average extends Sum 
{
	double n;  //子类继承的int型变量n被隐藏
	public double f(){
		double c;
		super.n = (int)n;  //double类型变量n做int转换，将结果赋给隐藏的int型变量n
		c = super.f();
		return c + n;
	}
	public double g(){
		double c;
		c = super.f();
		return c - n;
	}
}</code></pre> 
<pre><code class="language-java">public class Example5_7 
{
	public static void main(String[] args) 
	{
		Average aver = new Average();
		aver.n = 100.5678;
		double result1 = aver.f();
		double result2 = aver.g();
		System.out.println("result1 = " + result1);
		System.out.println("result2 = " + result2);
	}
}</code></pre> 
<p><img alt="" height="35" src="https://images2.imgbox.com/e0/e0/tst77woa_o.png" width="172"></p> 
<p>如果改写成（颠倒顺序）</p> 
<pre><code class="language-java">double result2 = aver.g();

double result1 = aver.f();</code></pre> 
<p>运行结果：</p> 
<blockquote> 
 <p>result1 = 5150.5678</p> 
 <p>result2 = -100.5678</p> 
</blockquote> 
<p>因为执行“aver.g();”的过程中需要执行"super.f();"，super.f()中出现的n是隐藏的n且n还没有赋值。默认为0；</p> 
<h3>3、super和this的区别</h3> 
<p>this 指的是当前对象的引用，super 是当前对象的父对象的引用。下面先简单介绍一下 super 和 this 关键字的用法。<br><br><strong>super 关键字的用法：</strong></p> 
<ul><li>super.父类属性名：调用父类中的属性</li><li>super.父类方法名：调用父类中的方法</li><li>super()：调用父类的无参构造方法</li><li>super(参数)：调用父类的有参构造方法</li></ul> 
<p>如果构造方法的第一行代码不是 this() 和 super()，则系统会默认添加 super()。</p> 
<p><br><strong>this 关键字的用法：</strong></p> 
<ul><li>this.属性名：表示当前对象的属性</li><li>this.方法名(参数)：表示调用当前对象的方法</li></ul> 
<p>当局部变量和成员变量发生冲突时，使用<code>this.</code>进行区分。</p> 
<p><strong>关于 <a href="http://c.biancheng.net/java/" rel="nofollow">Java</a> super 和 this 关键字的异同，可简单总结为以下几条。</strong></p> 
<ol><li>子类和父类中变量或方法名称相同时，用 super 关键字来访问。可以理解为 super 是指向自己父类对象的一个指针。在子类中调用父类的构造方法。</li><li>this 是自身的一个对象，代表对象本身，可以理解为 this 是指向对象本身的一个指针。在同一个类中调用其它方法。</li><li>this 和 super 不能同时出现在一个构造方法里面，因为 this 必然会调用其它的构造方法，其它的构造方法中肯定会有 super 语句的存在，所以在同一个构造方法里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this( ) 和 super( ) 都指的是对象，所以，均不可以在 static 环境中使用，包括 static 变量、static 方法和 static 语句块。</li><li>从本质上讲，this 是一个指向对象本身的指针, 然而 super 是一个 Java 关键字。</li></ol> 
<p>在 Animal 类和 Cat 类中分别定义了 public 类型的 name 属性和 private 类型的 name 属性，并且 Cat 类继承 Animal 类。那么，我们可以在 Cat 类中通过 super 关键字来访问父类 Animal 中的 name 属性，通过 this 关键字来访问本类中的 name 属性，如下面的代码：</p> 
<pre><code class="language-java">// 父类Animal的定义
public class Animal {
    public String name; // 动物名字
}

//子类Cat的定义
public class Cat extends Animal {
    private String name; // 名字

    public Cat(String aname, String dname) {
        super.name = aname; // 通过super关键字来访问父类中的name属性
        this.name = dname; // 通过this关键字来访问本类中的name属性
    }

    public String toString() {
        return "我是" + super.name + "，我的名字叫" + this.name;
    }

    public static void main(String[] args) {
        Animal cat = new Cat("动物", "喵星人");
        System.out.println(cat);
    }
}</code></pre> 
<blockquote> 
 <pre><code class="language-html hljs">我是动物，我的名字叫喵星人</code></pre> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee51ae8798e6a04a489ec16c10f445d1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安装Ubuntu18.04基于VirtualBox</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/61a510a2f433afb496f6db0fb79761de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">正在创建系统还原点_如何使Windows在启动时自动创建系统还原点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>