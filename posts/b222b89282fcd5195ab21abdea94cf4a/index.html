<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【7】基于多设计模式下的同步&amp;异步日志系统-代码设计 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【7】基于多设计模式下的同步&amp;异步日志系统-代码设计" />
<meta property="og:description" content="8.5 日志落地(LogSink)类设计（简单工厂模式） 1.⽇志落地类主要负责落地⽇志消息到⽬的地。
它主要包括以下内容：
• Formatter⽇志格式化器：主要是负责格式化⽇志消息，
• mutex互斥锁：保证多线程⽇志落地过程中的线程安全，避免出现交叉输出的情况。
这个类⽀持可扩展，其成员函数log设置为纯虚函数，当我们需要增加⼀个log输出⽬标， 可以增加⼀个类继承⾃该类并重写log⽅法实现具体的落地⽇志逻辑。
2.⽬前实现了三个不同⽅向上的⽇志落地：
• 标准输出：StdoutSink
• 固定⽂件：FileSink
• 滚动⽂件：RollSink
2.1滚动⽇志⽂件输出的必要性：
▪ 由于机器磁盘空间有限， 我们不可能⼀直⽆限地向⼀个⽂件中增加数据
▪ 如果⼀个⽇志⽂件体积太⼤，⼀⽅⾯是不好打开，另⼀⽅⾯是即时打开了由于包含数据巨⼤，也不利于查找我们需要的信息
▪ 所以实际开发中会对单个⽇志⽂件的⼤⼩也会做⼀些控制，即当⼤⼩超过某个⼤⼩时（如1GB），我们就重新创建⼀个新的⽇志⽂件来滚动写⽇志。 对于那些过期的⽇志， ⼤部分企业内部都有专⻔的运维⼈员去定时清理过期的⽇志，或者设置系统定时任务，定时清理过期⽇志。
2.2⽇志⽂件的滚动思想：
⽇志⽂件滚动的条件有两个:⽂件⼤⼩ 和 时间。我们可以选择：
▪ ⽇志⽂件在⼤于 1GB 的时候会更换新的⽂件
▪ 每天定点滚动⼀个⽇志⽂件
本项⽬基于⽂件⼤⼩的判断滚动⽣成新的⽂件
#ifndef __M_SINK_H__ #define __M_SINK_H__ #include &#34;util.hpp&#34; #include &#34;message.hpp&#34; #include &#34;formatter.hpp&#34; #include &lt;memory&gt; #include &lt;mutex&gt; namespace bitlog{ class LogSink { public: using ptr = std::shared_ptr&lt;LogSink&gt;; LogSink() {} virtual ~LogSink() {} virtual void log(const char *data, size_t len) = 0; }; class StdoutSink : public LogSink { public: using ptr = std::shared_ptr&lt;StdoutSink&gt;; StdoutSink() = default; void log(const char *data, size_t len) { std::cout." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b222b89282fcd5195ab21abdea94cf4a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-15T23:00:43+08:00" />
<meta property="article:modified_time" content="2023-12-15T23:00:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【7】基于多设计模式下的同步&amp;异步日志系统-代码设计</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="85_LogSink_0"></a>8.5 日志落地(LogSink)类设计（简单工厂模式）</h3> 
<p><mark>1.⽇志落地类主要负责落地⽇志消息到⽬的地。</mark><br> 它主要包括以下内容：<br> • Formatter⽇志格式化器：主要是负责格式化⽇志消息，<br> • mutex互斥锁：保证多线程⽇志落地过程中的线程安全，避免出现交叉输出的情况。<br> 这个类⽀持可扩展，其成员函数log设置为纯虚函数，当我们需要增加⼀个log输出⽬标， 可以增加⼀个类继承⾃该类并重写log⽅法实现具体的落地⽇志逻辑。<br> <mark>2.⽬前实现了三个不同⽅向上的⽇志落地：</mark><br> • 标准输出：StdoutSink<br> • 固定⽂件：FileSink<br> • 滚动⽂件：RollSink<br> <strong>2.1</strong>滚动⽇志⽂件输出的必要性：</p> 
<blockquote> 
 <p>▪ 由于机器磁盘空间有限， 我们不可能⼀直⽆限地向⼀个⽂件中增加数据<br> ▪ 如果⼀个⽇志⽂件体积太⼤，⼀⽅⾯是不好打开，另⼀⽅⾯是即时打开了由于包含数据巨⼤，也不利于查找我们需要的信息<br> ▪ 所以实际开发中会对单个⽇志⽂件的⼤⼩也会做⼀些控制，即当⼤⼩超过某个⼤⼩时（如1GB），我们就重新创建⼀个新的⽇志⽂件来滚动写⽇志。 对于那些过期的⽇志， ⼤部分企业内部都有专⻔的运维⼈员去定时清理过期的⽇志，或者设置系统定时任务，定时清理过期⽇志。</p> 
</blockquote> 
<p><strong>2.2</strong>⽇志⽂件的滚动思想：</p> 
<blockquote> 
 <p>⽇志⽂件滚动的条件有两个:⽂件⼤⼩ 和 时间。我们可以选择：<br> ▪ ⽇志⽂件在⼤于 1GB 的时候会更换新的⽂件<br> ▪ 每天定点滚动⼀个⽇志⽂件</p> 
</blockquote> 
<p>本项⽬基于⽂件⼤⼩的判断滚动⽣成新的⽂件</p> 
<pre><code>#ifndef __M_SINK_H__
#define __M_SINK_H__
#include "util.hpp"
#include "message.hpp"
#include "formatter.hpp"
#include &lt;memory&gt;
#include &lt;mutex&gt;
namespace bitlog{
class LogSink {
 public:
 using ptr = std::shared_ptr&lt;LogSink&gt;;
 LogSink() {}
 virtual ~LogSink() {}
 virtual void log(const char *data, size_t len) = 0;
};
class StdoutSink : public LogSink {
 public:
 using ptr = std::shared_ptr&lt;StdoutSink&gt;;
 StdoutSink() = default;
 void log(const char *data, size_t len) {
 std::cout.write(data, len);
 }
};
class FileSink : public LogSink {
 public:
 using ptr = std::shared_ptr&lt;FileSink&gt;;
 FileSink(const std::string &amp;filename):_filename(filename) {
 util::file::create_directory(util::file::path(filename));
 _ofs.open(_filename, std::ios::binary | std::ios::app);
 assert(_ofs.is_open());
 }
 const std::string &amp;file() {return _filename; }
 void log(const char *data, size_t len) {
 _ofs.write((const char*)data, len);
 if (_ofs.good() == false) {
 std::cout &lt;&lt; "⽇志输出⽂件失败！\n";
 }
 }
 private:
 std::string _filename;
 std::ofstream _ofs;
};
class RollSink : public LogSink {
 public:
 using ptr = std::shared_ptr&lt;RollSink&gt;;
 RollSink(const std::string &amp;basename, size_t max_fsize):
 _basename(basename), _max_fsize(max_fsize), _cur_fsize(0){
 util::file::create_directory(util::file::path(basename));
 }
 void log(const char *data, size_t len) {
 initLogFile();
 _ofs.write(data, len);
 if (_ofs.good() == false) {
 std::cout &lt;&lt; "⽇志输出⽂件失败！\n";
 }
 _cur_fsize += len;
 }
 private:
 void initLogFile() {
 if (_ofs.is_open() == false || _cur_fsize &gt;= _max_fsize) {
 _ofs.close();
 std::string name = createFilename();
 _ofs.open(name, std::ios::binary | std::ios::app);
 assert(_ofs.is_open());
 _cur_fsize = 0;
 return;
 }
 return;
 } 
 std::string createFilename() {
 time_t t = time(NULL);
 struct tm lt;
 localtime_r(&amp;t, &amp;lt);
 std::stringstream ss;
 ss &lt;&lt; _basename;
 ss &lt;&lt; lt.tm_year + 1900;
 ss &lt;&lt; lt.tm_mon + 1;
 ss &lt;&lt; lt.tm_mday;
 ss &lt;&lt; lt.tm_hour;
 ss &lt;&lt; lt.tm_min;
 ss &lt;&lt; lt.tm_sec;
 ss &lt;&lt; ".log";
 return ss.str();
 }
 private:
 std::string _basename;
 std::ofstream _ofs;
 size_t _max_fsize;
 size_t _cur_fsize;
};
class SinkFactory {
 public:
 template&lt;typename SinkType, typename ...Args&gt;
 static LogSink::ptr create(Args &amp;&amp;...args) {
 return std::make_shared&lt;SinkType&gt;(std::forward&lt;Args&gt;(args)...);
 }
};
}
#endif
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/69a64be5c14ebd646e48ef8b1bef961f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第一次上北京接受CCTV采访畅聊开源话题，这将是人生最有纪念意义的事情了!...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a33bb379e436f95860512f7ebe58a2cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue 使用高德地图插件 vue-amap文章</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>