<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>golang读取文件 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="golang读取文件" />
<meta property="og:description" content="/*
go读取文件
读写文件是很多程序的基本任务
*/
package main
import (
&#34;bufio&#34;
&#34;fmt&#34;
&#34;io&#34;
&#34;io/ioutil&#34;
&#34;os&#34;
)
/*
读取文件的函数调用大多需要检查错误
使用下面这个错误检查方法可以方便点
*/
func check(e error) {
if e != nil {
panic(e)
}
}
/*
知识点：
ioutil.ReadFile 读取整个文件内容到内存
make([]byte, 5)
os.Open()
f.Read()
string(b1)
*/
func main() {
//最基本的文件读写任务就是把整个文件的内容读取到内存
dat, err := ioutil.ReadFile(&#34;tmp/dat&#34;)
check(err)
fmt.Print(string(dat))
/*
有的时候你想更多地控制到底层
是读取文件的那个部分
这个时你可以使用 os.open 打开一个文件获取一个 os.File对象
*/
f, err := os.Open(&#34;tmp/dat&#34;)
/*
从这个文件中读取一些字节 并且由于字节数组长度所限
最多读取5个字节 另外还需要注意实际能够读取的字节数量
*/
b1 := make([]byte, 5)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/922f1c63175283ab1f5a33ab357014d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-16T10:58:36+08:00" />
<meta property="article:modified_time" content="2019-09-16T10:58:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">golang读取文件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>/*<br>    go读取文件<br>    读写文件是很多程序的基本任务<br> */</p> 
<p>package main</p> 
<p>import (<br>     "bufio"<br>     "fmt"<br>     "io"<br>     "io/ioutil"<br>     "os"<br> )</p> 
<p>/*<br>    读取文件的函数调用大多需要检查错误<br>    使用下面这个错误检查方法可以方便点<br> */</p> 
<p>func check(e error) {<!-- --><br>     if e != nil {<!-- --><br>         panic(e)<br>     }<br> }</p> 
<p>/*<br>    知识点：<br>       ioutil.ReadFile 读取整个文件内容到内存<br>       make([]byte, 5)<br>       os.Open()<br>       f.Read()<br>       string(b1)</p> 
<p>*/<br> func main() {<!-- --><br>     //最基本的文件读写任务就是把整个文件的内容读取到内存<br>     dat, err := ioutil.ReadFile("tmp/dat")<br>     check(err)<br>     fmt.Print(string(dat))</p> 
<p>    /*<br>        有的时候你想更多地控制到底层<br>        是读取文件的那个部分<br>        这个时你可以使用 os.open 打开一个文件获取一个 os.File对象<br>     */</p> 
<p>    f, err := os.Open("tmp/dat")<br>     /*<br>        从这个文件中读取一些字节 并且由于字节数组长度所限<br>        最多读取5个字节 另外还需要注意实际能够读取的字节数量<br>     */<br>     b1 := make([]byte, 5)<br>     n1, err := f.Read(b1)<br>     check(err)<br>     fmt.Printf("%d bytes:%s \n", n1, string(b1))</p> 
<p>    /*<br>        你也可以使用Seek来跳转到文件中的一个已知到位置<br>        并从哪个位置 读取数据<br>     */</p> 
<p>    o2, err := f.Seek(6, 0)<br>     check(err)<br>     b2 := make([]byte, 2)<br>     n2, err := f.Read(b2)<br>     check(err)<br>     fmt.Printf("%d bytes %s\n", n2, string(b2))</p> 
<p>    /*<br>        io包提供了一些帮助文件读取的函数<br>        例如上面的方法如果是 使用方法 ReadAtLeast函数来实现<br>        将使得程序更健壮<br>     */</p> 
<p>    o3, err := f.Seek(6, 0)<br>     check(err)<br>     b3 := make([]byte, 2)<br>     n3, err := io.ReadAtLeast(f, b3, 2)<br>     check(err)<br>     fmt.Printf("%d %s", n3, string(b3))</p> 
<p>    /*<br>        没有内置的rewind方法 当时可以使用Seek(0,0)来实现<br>     */</p> 
<p>    _, err := f.Seek(0, 0)<br>     check(err)</p> 
<p>    /*<br>        bufio包提供了缓冲读取文件的方法 这将使得文件读取更加高效<br>     */</p> 
<p>    r4 := bufio.NewReader(f)<br>     b4, err := r4.Peek(5)<br>     check(err)<br>     fmt.Printf("%s", string(b4))</p> 
<p>    /*<br>        最后关闭文件<br>        一版来讲 这个方法会在打开文件的时候<br>        使用defer 来延迟关闭<br>     */<br>     f.Close()<br> }</p> 
<p>/*<br>    评论： 1.原始读写<br>           2.ioutil读写<br>           3.bufio读写<br> */<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0bebe82147cac73a509ac0124c200e98/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Fastadmin 后台上传视频</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7ed9ed39c5ca1f6e51e9612da84c55a1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QT on Android  UI界面设计了但是APP界面不变的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>