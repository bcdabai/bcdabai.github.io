<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二叉树的构造(如何唯一确定一棵二叉树?附证明) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二叉树的构造(如何唯一确定一棵二叉树?附证明)" />
<meta property="og:description" content="二叉树的构造(如何唯一确定一棵二叉树?附证明) 一些直观的认识 ▪ 同一棵二叉树具有唯一先序序列、中序序列和后序序列。
▪ 不同的二叉树可能具有相同的先序序列、中序序列和后序序列。
通过上面两个例子的验证：
▪ 仅有一个先序序列（或中序序列、后序序列），无法确定这颗二叉树的树形！
▪ 思考：给定先序序列、中序和后序遍历序列中任意两个，是否可以唯一确定这颗二叉树的树形？
二叉树的构造 （1） 同时给定一棵二叉树的先序序列和中序序列，就能唯一确定棵二叉树？
​ • 是！
​ • 定理1
（2） 同时给定一棵二叉树的中序序列和后序序列，就能唯一确定这棵二叉树？
​ • 是
​ • 定理2
（3） 同时给定一棵二叉树的先序序列和后序序列，就能唯一确定这棵二叉树吗？
​ • 否
下面我们给出证明：
定理1 ▪ 任何n(n&gt;=0)个不同节点的二叉树,都可由它的中序序列和先序序列唯一地确定。
证明（数学归纳法） • 基础: 当 n=0 时,二叉树为空,结论正确.
• 假设: 设节点数小于n的任何二叉树,都可以由其先序序列和中序序列唯一地确定
• 归纳: 已知某二叉树具有n(n&gt;0)个不同节点,其先序序列是a0a1 …an-1;中序序列是b0b1…bk-1bk&#43;1…bn-1 .
​ ▪ 先序遍历“根-左-右”,a0 必定是二叉树的根节点
​ ▪ a0 必然在中序序列中出现,设在中序序列中必有某个bk(0&lt;=k&lt;=n-1)就是根节点a0。
• 由于bk是根节点,中序遍历“左-根-右”，故中序遍历中
​ ▪ b0b1…bk-1必是根节点bk(a0)左子树的中序序列,即bk的左子树有k个节点
​ ▪ bk&#43;1…bn-1必是根节点bk(a0)右子树的中序序列,即bk的右子树有n-k-1个节点
• 对应先序序列,紧跟在根节点a0之后的k个节点a1…ak是左子树的先序序列,ak&#43;1…an-1,这n-k-1就是右子树的先序序列." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/36af93e37d0e77e3739fc787b7dbb165/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-11T18:08:56+08:00" />
<meta property="article:modified_time" content="2022-12-11T18:08:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二叉树的构造(如何唯一确定一棵二叉树?附证明)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_1"></a>二叉树的构造(如何唯一确定一棵二叉树?附证明)</h3> 
<h3><a id="_3"></a>一些直观的认识</h3> 
<p>▪ 同一棵二叉树具有唯一先序序列、中序序列和后序序列。</p> 
<p>▪ 不同的二叉树可能具有相同的先序序列、中序序列和后序序列。</p> 
<img src="https://images2.imgbox.com/5f/0b/2NpNpJ94_o.png" alt="image-20221210201231984"> 
<img src="https://images2.imgbox.com/21/23/QDRCZKVZ_o.png" alt="image-20221210201256846"> 
<p>通过上面两个例子的验证：</p> 
<blockquote> 
 <p>▪ 仅有一个先序序列（或中序序列、后序序列），无法确定这颗二叉树的树形！</p> 
 <p>▪ 思考：给定先序序列、中序和后序遍历序列中任意两个，是否可以唯一确定这颗二叉树的树形？</p> 
</blockquote> 
<h3><a id="_19"></a>二叉树的构造</h3> 
<p>（1） 同时给定一棵二叉树的先序序列和中序序列，就能唯一确定棵二叉树？</p> 
<p>​ <strong>• 是！</strong></p> 
<p>​ • 定理1</p> 
<p>（2） 同时给定一棵二叉树的中序序列和后序序列，就能唯一确定这棵二叉树？</p> 
<p>​ <strong>• 是</strong></p> 
<p>​ • 定理2</p> 
<p>（3） 同时给定一棵二叉树的先序序列和后序序列，就能唯一确定这棵二叉树吗？</p> 
<p>​ <strong>• 否</strong></p> 
<p>下面我们给出证明：</p> 
<h4><a id="1_41"></a>定理1</h4> 
<blockquote> 
 <p>▪ 任何n(n&gt;=0)个不同节点的二叉树,都可由它的中序序列和先序序列唯一地确定。</p> 
</blockquote> 
<h4><a id="_45"></a>证明（数学归纳法）</h4> 
<blockquote> 
 <p>• 基础: 当 n=0 时,二叉树为空,结论正确.</p> 
 <p>• 假设: 设节点数小于n的任何二叉树,都可以由其先序序列和中序序列唯一地确定</p> 
 <p>• 归纳: 已知某二叉树具有n(n&gt;0)个不同节点,其先序序列是a<sub>0</sub>a<sub>1</sub> …a<sub>n-1</sub>;中序序列是b<sub>0</sub>b<sub>1</sub>…b<sub>k-1</sub>b<sub>k+1</sub>…b<sub>n-1</sub> .</p> 
 <p>​ ▪ 先序遍历“根-左-右”,a<sub>0</sub> 必定是二叉树的根节点</p> 
 <p>​ ▪ a<sub>0</sub> 必然在中序序列中出现,设在中序序列中必有某个b<sub>k</sub>(0&lt;=k&lt;=n-1)就是根节点a<sub>0</sub>。</p> 
 <img src="https://images2.imgbox.com/02/c1/16aW8FmR_o.png" alt="image-20221210210634563"> 
 <p>• 由于bk是根节点,中序遍历“左-根-右”，故中序遍历中</p> 
 <p>​ ▪ b<sub>0</sub>b<sub>1</sub>…b<sub>k-1</sub>必是根节点b<sub>k</sub>(a0)<strong><mark>左子树的中序序列</mark></strong>,即b<sub>k</sub>的左子树有k个节点</p> 
 <p>​ ▪ b<sub>k+1</sub>…b<sub>n-1</sub>必是根节点b<sub>k</sub>(a0)<mark><strong>右子树的中序序列</strong></mark>,即b<sub>k</sub>的右子树有n-k-1个节点</p> 
 <p>• 对应先序序列,紧跟在根节点a<sub>0</sub>之后的k个节点a<sub>1</sub>…a<sub>k</sub>是左子树的先序序列,a<sub>k+1</sub>…a<sub>n-1</sub>,这n-k-1就是右子树的先序序列.</p> 
 <p>• 根据归纳假设,子先序序列a<sub>1</sub>…a<sub>k</sub>和子序序列b<sub>0</sub>b<sub>1</sub>…b<sub>k-1</sub>可以唯一地确定根节点a<sub>0</sub>的左子树,而先序序列a<sub>k+1</sub>…a<sub>n-1</sub>和子中序序列b<sub>k+1</sub>…b<sub>n-1</sub>可以唯一地确定根节点a<sub>0</sub>的右子树.</p> 
 <img src="https://images2.imgbox.com/de/f3/NrE98wY4_o.png" alt="image-20221210212041852"> 
 <hr> 
 <p>通过上面的证明,我们从先序遍历和中序遍历进行逐层分解,唯一确定了一个二叉树.进而逆向证明了二叉树是可以通过其先序遍历和中序遍历唯一确定.</p> 
</blockquote> 
<p>我们观察下面例子:</p> 
<img src="https://images2.imgbox.com/bb/a6/mOsRONKI_o.png" alt="image-20221210214837749"> 
<blockquote> 
 <p>①通过先序遍历序列的第一个节点,即可确定二叉树的根。</p> 
 <p>②我们根据得到的根查找<strong>中序遍历</strong>序列,就可以找到此二叉树的根。</p> 
 <p>​ 根据中序遍历的特点就可以得知:根节点的左边就是其左子树的中序遍历序列,其右边就是其右子树的中序遍历序列</p> 
 <p>③我们通过查找中序序列的根的左边的节点个数，就可以确定二叉树的左子树，根据根右边的节点个数，就可以确定二叉树的右子树。</p> 
 <p>④ 根据中序序列的第二个节点，就可以确定下一层级的根节点，然后拿这个根节点去查找中序遍历的序列，就可以找到此层级的左子树和右子树，以此类推。</p> 
</blockquote> 
<p>所以我们可以根据上面证明的性质，进行二叉树的构造</p> 
<h4><a id="_91"></a>算法实现</h4> 
<p>框架：</p> 
<pre><code class="prism language-c">BTNode <span class="token operator">*</span><span class="token function">CreateBT1</span><span class="token punctuation">(</span>先序序列<span class="token punctuation">,</span>中序序列<span class="token punctuation">,</span>处理的本层级的二叉树节点个数<span class="token punctuation">)</span>

<span class="token punctuation">{<!-- --></span>
	如果传入的二叉树节点个数是<span class="token number">0</span><span class="token punctuation">,</span>则返回空<span class="token punctuation">;</span>

    否则<span class="token punctuation">,</span>为新节点申请空间<span class="token punctuation">;</span>
    
    在先序序列第一个节点确定二叉树的根<span class="token punctuation">;</span>
    
    拿着根节点在中序序列找到根节点位置k<span class="token punctuation">;</span>
    
    然后我们拿着这个序列就可以确定本层级的根的左右子树<span class="token punctuation">,</span>
    就可以构造下一层级的二叉树了<span class="token punctuation">.</span>

	返回构造的二叉树即可<span class="token punctuation">;</span>        
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/bf/a9/UNt0qtyE_o.png" alt="image-20221211163945664"></p> 
<h4><a id="_116"></a>代码实现:</h4> 
<pre><code class="prism language-c"><span class="token comment">//传入先序序列,中序序列,本层级处理的二叉树节点个数</span>
BTNode <span class="token operator">*</span><span class="token function">CreateBT1</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pre<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>in<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//定义访问二叉树的指针</span>
    BTNode <span class="token operator">*</span>s<span class="token punctuation">;</span>
    <span class="token comment">//定义寻找二叉树的根的中间变量</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token comment">//定义根节点的位置k</span>
    <span class="token keyword">int</span> k<span class="token punctuation">;</span>
    <span class="token comment">//先判断二叉树是否为空</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>        
    <span class="token comment">//如果通过上述验证,则不为空,为根节点申请空间</span>
    s <span class="token operator">=</span> <span class="token punctuation">(</span>BTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//根节点数据区赋值,即为先序序列pre的第一个字符</span>
    s<span class="token operator">-&gt;</span>data <span class="token operator">=</span> <span class="token operator">*</span>pre<span class="token punctuation">;</span>
    <span class="token comment">//现在根找到了,就去找二叉树的左右子树</span>
    <span class="token comment">//这就需要借助中序序列了,中序序列遍历顺序为左-&gt;根-&gt;右,所以先找到根,就可以找到其左子树</span>
    <span class="token comment">//在中序中找根节点的位置k</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>p<span class="token operator">=</span>in<span class="token punctuation">;</span>p<span class="token operator">&lt;</span>in<span class="token operator">+</span>n<span class="token punctuation">;</span>p<span class="token operator">++</span><span class="token punctuation">)</span>	<span class="token comment">//in是传入的in数组开始的位置</span>
    <span class="token punctuation">{<!-- --></span>
         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token operator">==</span><span class="token operator">*</span>pre<span class="token punctuation">)</span>
         <span class="token punctuation">{<!-- --></span>
             <span class="token keyword">break</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>    
    <span class="token punctuation">}</span>
    <span class="token comment">//找到根节点的位置,我们就找到了此层级的二叉树的根,同时我们也就可以通过中序序列数组                                    </span>
    <span class="token comment">//确定二叉树左子树的个数和右子树的个数, 为下一层级构造做准备</span>
	k <span class="token operator">=</span> p<span class="token operator">-</span>in<span class="token punctuation">;</span>	<span class="token comment">//根开始位置减去数组开始位置,就是左子树个数</span>
    <span class="token comment">//构造左右子树</span>
    s<span class="token operator">-&gt;</span>lchild <span class="token operator">=</span> <span class="token function">CreateBT1</span><span class="token punctuation">(</span>pre<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>in<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//pre+1:下一层级的左子树根,我们对先序序列指针后移一位</span>
    <span class="token comment">//in: 中序序列,左子树仍然是从头开始</span>
    <span class="token comment">//k : 左子树个数就是上面求的</span>
	s<span class="token operator">-&gt;</span>rchild <span class="token operator">=</span> <span class="token function">CreateBT1</span><span class="token punctuation">(</span>pre<span class="token operator">+</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">-</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//右子树的根,我们既然已经知道左子树的个数,就知道根在先序序列第几位</span>
    <span class="token comment">//pre+k+1: 右子树的先序序列是根右边的,我们通过查个数即可知道其开始的位序=开始+左子树+1</span>
    <span class="token comment">//p+1: 右子树的中序序列是根右边开始的,所以从根的位置p+1即可</span>
    <span class="token comment">//n-k-1: 右子树的个数是总是减去左子树,再减去根</span>
    <span class="token comment">//最后返回构造的二叉树即可</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="2_165"></a>定理2</h4> 
<p>▪ 任何n (n&gt;0)个不同节点的二叉树,都可由它的中序序列和后序序列唯一地确定.</p> 
<p>证明:</p> 
<p>如下图:</p> 
<img src="https://images2.imgbox.com/66/30/JhIQmULO_o.png" alt="image-20221211171417540"> 
<p>通过构造二叉树的先序序列和中序序列,后序序列,我们可以发现,每一步都是有条不紊的,每一步都是分层次的,我们通过构造序列的过程,逆向可以构造出二叉树,就间接地证明了,这个定义的合法性.</p> 
<h3><a id="_179"></a>思维拓展:</h3> 
<p>为什么中序遍历和先序遍历</p> 
<p>中序遍历和后序遍历可以唯一确定一棵二叉树</p> 
<p>定时先序遍历和后序遍历就不能呢?</p> 
<p>我们可以从同一层级的构造上面进行直观理解:</p> 
<p>中序遍历是 : 左-根-右 ----&gt;通过根, 就可以唯一确定本层次的左右子树的节点个数</p> 
<p>先序遍历: 根-左-右 -----&gt;根是必然是第一个, 不确定的就是左子树和右子数</p> 
<p>后序遍历: 左-右-根 -----&gt;根必然是最后一个节点,不确定的就是左子树和右子树</p> 
<p>这样就理解了吧,我们下节ヾ(￣▽￣)Bye&gt;Bye!</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d690d5718ed02e2108539467e3b1e6a8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Cloud 集成 Hystrix 熔断器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/760e7c04466eb95b7d1f7a6d9e0bce69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PostgreSQL数据库常用操作(20221210)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>