<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CAN XL ：CAN协议家族新成员 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CAN XL ：CAN协议家族新成员" />
<meta property="og:description" content="十年之前，你不认识我，我也不认识CAN FD。如今，CAN FD已经陆续进入乘用车领域，几乎所有汽车制造商都将在未来几年内逐步推出搭载CAN FD的乘用车。那十年之后，车载网络又会向什么方向发展呢？
根据现在的形势来看，车载架构将从历史悠久的平面网络方案迁移到与域相关的方案。而域相关的车载网络体系结构，就需要通用的标准化高层协议。对于高层协议来说，它们应尽可能独立于下层协议，这样不同通信技术的专用技术和商业功能就能够被使用。当然，要支持TCP / IP，经典的CAN和CAN FD并不是最好的下层方法。因此，CiA（CAN in Automation，以下简称CiA）及其成员已经开始开发具有支持10 Mbit / s甚至更多的物理层的CAN XL。虽然TCP / IP不一定是最佳的传输/网络层的解决方案，但是DoIP已经在ISO中标准化并且广泛应用了，所以能够支持TCP/IP对于CAN XL来说还是非常重要的。
CAN XL规范尚未最终确定，仍然存在一些未解决的问题。已经决定的是数据字段长度最大为2048字节和11位优先级字段。此外，该协议为使用的下一个更高协议提供8位指示符。可以说这是不适合经典OSI参考模型的嵌入式层设置参数。这样的嵌入式层设置参数对于其他高层协议也将很有帮助，以简化多协议堆栈。如今，标准化了太多不同的高层协议，它们并不完全独立于所使用的较低层协议。一些ISO专家希望克服这一点。
CAN XL原计划于3月中旬在德国-巴登举行的国际CAN大会（iCC）上正式推出。今年晚些时候，当CAN XL规范发布并且相关的互操作性测试证明了第一个实现的互操作性时，CiA会将它们提交给ISO进行国际标准化。
下面就一起来看一下CAN XL与CAN FD的异同。
▲ 图 1：CAN FD, CAN XL帧格式
与CAN FD相比，CAN XL增加了位的数量；这些附加位位于报文头与报文末尾处；大多数的所需位是CRC，必须增加它才能保护超出的更多的字节。 CAN FD&amp; CAN XL报头比较
▲ 图 2：CAN FD, CAN XL帧头部
上图中顶部的黑线表示隐性，底部的黑线表示显性。那么我们分析上图可得出以下结论：
SOF和11位的CAN ID场在CAN、CAN FD、CAN XL中是通用的；CAN FD和CAN XL始终不支持RTR远程请求；CAN XL不支持IDE标识符扩展（29位CAN ID），该位始终处于显性；隐性FDF位指示CAN FD，隐性FDF、XLF位指示CAN XL；CAN FD中res位始终处于显性，隐性BRS位（波特率切换）会提升传输速率；CAN FD中ESI位通常处于显性，但处于被动错误时会变为隐性；CAN XL中resXL位是隐性的，可用于将来的扩展；CAN XL中AL1、DH1和DL1作为新的波特率切换序列；CAN XL中Payload 8-bit用于不同数据包的预定义多路复用位；CAN XL中DLC是一个11位整数，其中数据字节数是该整数加1；CAN XL中Header-CRC用于保证DLC正确，DLC定义数据CRC从何处开始。 ▲ 表 1：DLC编码表
CAN FD&amp; CAN XL报尾比较" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0af9301778db42928698cc150670c375/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-30T10:36:44+08:00" />
<meta property="article:modified_time" content="2022-11-30T10:36:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CAN XL ：CAN协议家族新成员</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>十</strong>年之前，你不认识我，我也不认识CAN FD。如今，CAN FD已经陆续进入乘用车领域，几乎所有汽车制造商都将在未来几年内逐步推出搭载CAN FD的乘用车。那十年之后，车载网络又会向什么方向发展呢？</p> 
<p>根据现在的形势来看，车载架构将从历史悠久的平面网络方案迁移到与域相关的方案。而域相关的车载网络体系结构，就需要通用的标准化高层协议。对于高层协议来说，它们应尽可能独立于下层协议，这样不同通信技术的专用技术和商业功能就能够被使用。当然，要支持TCP / IP，经典的CAN和CAN FD并不是最好的下层方法。因此，CiA（CAN in Automation，以下简称CiA）及其成员已经开始开发具有支持10 Mbit / s甚至更多的物理层的CAN XL。虽然TCP / IP不一定是最佳的传输/网络层的解决方案，但是DoIP已经在ISO中标准化并且广泛应用了，所以能够支持TCP/IP对于CAN XL来说还是非常重要的。</p> 
<p>CAN XL规范尚未最终确定，仍然存在一些未解决的问题。已经决定的是数据字段长度最大为2048字节和11位优先级字段。此外，该协议为使用的下一个更高协议提供8位指示符。可以说这是不适合经典OSI参考模型的嵌入式层设置参数。这样的嵌入式层设置参数对于其他高层协议也将很有帮助，以简化多协议堆栈。如今，标准化了太多不同的高层协议，它们并不完全独立于所使用的较低层协议。一些ISO专家希望克服这一点。</p> 
<p>CAN XL原计划于3月中旬在德国-巴登举行的国际CAN大会（iCC）上正式推出。今年晚些时候，当CAN XL规范发布并且相关的互操作性测试证明了第一个实现的互操作性时，CiA会将它们提交给ISO进行国际标准化。</p> 
<p>下面就一起来看一下CAN XL与CAN FD的异同。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c6/a3/ZnnZf1su_o.png"></p> 
<p>▲ 图 1：CAN FD, CAN XL帧格式</p> 
<ul><li>与CAN FD相比，CAN XL增加了位的数量；</li><li>这些附加位位于报文头与报文末尾处；</li><li>大多数的所需位是CRC，必须增加它才能保护超出的更多的字节。</li></ul> 
<p><strong>CAN FD&amp; CAN XL报头比较</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/08/7f/3wHqth3M_o.png"></p> 
<p>▲ 图 2：CAN FD, CAN XL帧头部</p> 
<p>上图中顶部的黑线表示隐性，底部的黑线表示显性。那么我们分析上图可得出以下结论：</p> 
<ul><li>SOF和11位的CAN ID场在CAN、CAN FD、CAN XL中是通用的；</li><li>CAN FD和CAN XL始终不支持RTR远程请求；</li><li>CAN XL不支持IDE标识符扩展（29位CAN ID），该位始终处于显性；</li><li>隐性FDF位指示CAN FD，隐性FDF、XLF位指示CAN XL；</li><li>CAN FD中res位始终处于显性，隐性BRS位（波特率切换）会提升传输速率；</li><li>CAN FD中ESI位通常处于显性，但处于被动错误时会变为隐性；</li><li>CAN XL中resXL位是隐性的，可用于将来的扩展；</li><li>CAN XL中AL1、DH1和DL1作为新的波特率切换序列；</li><li>CAN XL中Payload 8-bit用于不同数据包的预定义多路复用位；</li><li>CAN XL中DLC是一个11位整数，其中数据字节数是该整数加1；</li><li>CAN XL中Header-CRC用于保证DLC正确，DLC定义数据CRC从何处开始。</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2b/7e/vIjRS1Cx_o.png"></p> 
<p>▲ 表 1：DLC编码表</p> 
<p><strong>CAN FD&amp; CAN XL报尾比较</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/62/38/hbnTHOgz_o.png"></p> 
<p>▲ 图 3：CAN FD, CAN XL帧尾</p> 
<ul><li>对于相同的数据长度，CAN XL中较长的报头可能需要较长的CRC；</li><li>CAN XL包含用于波特率切换位，确保向前的兼容性；</li><li>CAN XL CRC之后是波特率的切换模式，而不是CRC定界符；</li><li>为了确保重新同步到未来格式的帧末尾，集成格式：将CAN XL中放置NACK添加到旧ACK中。</li></ul> 
<p><strong>CAN XL的波特率转换</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d7/5b/gxURLiGi_o.png"></p> 
<p>▲ 图 4：CAN XL帧格式</p> 
<ul><li>DH1和DL1之间边缘的波特率增加；</li><li>DH2和DL2之间边缘的波特率降低；</li><li>AL1位包含一个特殊模式，它可以切换CAN驱动器进入高波特率模式；</li><li>AH1位包含一个特殊模式，它将使CAN驱动器脱离高波特率模式。</li></ul> 
<p>CAN XL每个CAN帧中有更多的数据：1—2048字节，并且在数据部分增加了波特率，具有更好的故障保护措施，可为下一代CAN做更好的准备。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/10/6b/Zwis7Fcb_o.png"></p> 
<p>上文曾说到，CAN XL是CiA为了填补CAN FD与100Base-T1之间的空白而提出的解决方案。相应的，IEEE已经于2019年标准化了一个适用于汽车的10Mbps以太网版本(10BASE-T1S)。那么，这两种方案之间的对比是自然少不了的，本人才疏学浅，只能就个人对10Base-T1S和CAN XL这两种技术的理解来进行比较，主要是从发布的标准进行定性的一些比较。</p> 
<p>首先从规范成熟度来看，10Base-T1S已经发布了标准文档。CAN XL规范还没有最终确定，仍有一些悬而未决的问题待决定。</p> 
<p>接下来对比两者的具体性能。从数据净载荷来看，两种技术都可以达到10Mbps。但是为了兼容老的CAN规范，CAN XL帧的头部和尾部速率较低，这其实降低了整个的传输速率。在兼容性方面，CAN XL可以实现对大多数CAN/CAN FD应用的兼容，但是不支持远程帧和29bit的ID场，这就导致在商用车领域的应用受到了限制。10BASE-T1S继承以太网的良好特性，很多成熟的基于TCP/IP的工业界软件都容易移植到新的车载以太网协议上去。而且在以交换机为核心的车载网络中是如鱼得水的。</p> 
<p>CAN XL继承了CAN的良好特性，可以保证收发数据无丢失，这个特性都是固化在CAN控制器中的。10Base-T1S跟其他以太网协议一样，需要通过较高层的协议（如TCP）才能检测出数据丢失，而且依赖于软件实现。CAN XL跟CAN一样，可以检测故障并从故障中恢复出来，当帧头部速率1Mbps时可以在23us内恢复，但TCP/IP却要花几十ms才能从故障中恢复过来。所以，可以说在数据安全性上CAN XL略胜一筹。</p> 
<p>最后分析一下很多OEM厂家最关心的话题——成本。CAN控制器目前是集成到处理器芯片中的，这减少了一部分软件成本也保证了一致性。除去交换机的成本因素不谈，就单个处理器芯片来说，可能会有一些处理器集成10Base-T1S控制器，但由于以太网软件协议栈的缘故可能会增加一些软件成本，而且还会带来协议一致性的问题。同时，受限于25m的最长通信线路和最大8个节点，会导致在一些特殊域使用起来要分多个网段，增加成本。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7e/28/oyaSeDHn_o.png"></p> 
<p>▲ 表2：CAN XL与10Base-T1S对比</p> 
<p>当然，CAN XL还是需要等ISO进行国际标准化之后才能够真正的登上历史舞台，但是，现在已经给人们提供了一个新的高速稳定的传输方案。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/729010509a9f8c6ba284a0b551a1eff7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pytorch初学笔记（五）：torchvision中dataset的最详细使用（以CIFAR10和MNIST为例）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/02c592f45ffa5690634f8376321865d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器存储</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>