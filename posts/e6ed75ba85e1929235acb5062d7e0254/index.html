<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker·1（简介、安装、基本使用） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker·1（简介、安装、基本使用）" />
<meta property="og:description" content="目录 1. 什么是Docker1.1. 什么是容器1.2. 什么是Docker 2. 安装Docker3. 镜像操作3.1. 拉取镜像3.2. 卸载镜像/容器3.3. 使用镜像/容器 4. 相关指令说明 1. 什么是Docker 1.1. 什么是容器 虚拟机： 操作系统是一个很笨重的程序，即是啥都不干，虚拟本身都要占用很多内存和磁盘，并且启动很慢（操作系统要从头到尾把该检测的都检测了，该加载的都加载上）。
容器： 类似于码头的集装箱——相互隔离、长期反复使用、快速装载和卸载、规格标准，在港口和船上都可以摆放。
虚拟机&amp;Docker的隔离：
隔离： 虚拟机：现代软件开发的一大目的就是隔离，通过将应用程序部署在不同的虚拟机中从而实现隔离容器：只隔离应用程序的运行时环境（程序运行依赖的各种库以及配置）但容器之间可以共享同一个操作系统 容器的优势：轻量级且占用的资源更少，与操作系统动辄几G的内存占用相比，容器技术只需数M空间，因此我们可以在同样规格的硬件上大量部署容器，而且不同于操作系统数分钟的启动时间容器几乎瞬时启动 1.2. 什么是Docker Docker： Go语言开源项目，docker将程序以及程序所有的依赖都打包到docker container。Docker可以把程序所需要的环境装在容器里面，以做到一次容器配置，程序处处可运行。
组成（理解）：
dockerfile——源代码image——可执行的程序container——进程 关键指令：
docker build
docker编译docker file：client在接收到请求后转发给docker daemon，接着docker daemon根据docker file创建出“可执行程序”image docker run
docker daemon（守护进程，负责管理容器和镜像的生命周期，以及提供其他相关的管理和维护功能）将image加载到内存执行，跑起来的image就是container docker pull
docker daemon接收到命令后向docker registry（镜像库）发送image下载请求 Docker的关键组件：
容器技术：Docker使用容器技术来隔离应用程序及其依赖项。每个容器都包含了一个应用程序及其所有的依赖项，并且彼此相互隔离。这使得应用程序的部署、管理和扩展变得更加简单和高效。镜像：Docker使用镜像来定义容器的运行环境。镜像是一个轻量级的、可执行的独立软件包，包含了运行应用程序所需的所有文件和配置。Docker通过读取镜像来创建和运行容器。Docker守护进程：Docker守护进程是Docker引擎的核心组件，负责管理容器和镜像的生命周期。它接收来自Docker客户端的命令和请求，并在后台运行容器和执行相关的操作。Docker注册中心：Docker注册中心用于存储和共享镜像。它提供了一个中央化的存储和分发机制，使得镜像可以轻松地在不同的机器和环境之间传输和共享。Docker CLI（命令行接口）：Docker CLI是Docker的命令行工具，用于与Docker守护进程进行交互。通过Docker CLI，用户可以创建、运行、停止、删除容器和镜像等操作。Docker网络：Docker网络负责管理容器之间的网络通信以及容器与外部网络的连接。它提供了一种灵活的网络模型，使得容器可以轻松地相互通信并暴露给外部世界。Docker存储驱动：Docker使用存储驱动来管理容器的文件系统和卷。不同的存储驱动可以根据需求选择，以满足不同的性能和可靠性要求。 2. 安装Docker 本文全的案例与指令全是基于Centos7.6！！！
注意：Docker默认安装目录：/var/lib/docker
查看docker稳定版本，并选择安装：
# 在存储库中列出可用版本 yum list docker-ce --showduplicates | sort -r # 安装 yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e6ed75ba85e1929235acb5062d7e0254/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T15:44:23+08:00" />
<meta property="article:modified_time" content="2024-01-04T15:44:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker·1（简介、安装、基本使用）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1_Docker_3" rel="nofollow">1. 什么是Docker</a></li><li><ul><li><a href="#11__5" rel="nofollow">1.1. 什么是容器</a></li><li><a href="#12_Docker_26" rel="nofollow">1.2. 什么是Docker</a></li></ul> 
  </li><li><a href="#2_Docker_61" rel="nofollow">2. 安装Docker</a></li><li><a href="#3__102" rel="nofollow">3. 镜像操作</a></li><li><ul><li><a href="#31__106" rel="nofollow">3.1. 拉取镜像</a></li><li><a href="#32__123" rel="nofollow">3.2. 卸载镜像/容器</a></li><li><a href="#33__135" rel="nofollow">3.3. 使用镜像/容器</a></li></ul> 
  </li><li><a href="#4__200" rel="nofollow">4. 相关指令说明</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_Docker_3"></a>1. 什么是Docker</h2> 
<h3><a id="11__5"></a>1.1. 什么是容器</h3> 
<center> 
 <img src="https://images2.imgbox.com/79/1a/ZxVegSY7_o.gif" width="40%"> 
 <center> 
  <img src="https://images2.imgbox.com/24/be/RiuREQqv_o.png" width="40%"> 
 </center> 
</center> 
<p><strong>虚拟机：</strong> 操作系统是一个很笨重的程序，即是啥都不干，虚拟本身都要占用很多内存和磁盘，并且启动很慢（操作系统要从头到尾把该检测的都检测了，该加载的都加载上）。</p> 
<center> 
 <img src="https://images2.imgbox.com/60/f7/R2YdtTyH_o.png" width="40%"> 
</center> 
<p><strong>容器：</strong> 类似于码头的集装箱——相互隔离、长期反复使用、快速装载和卸载、规格标准，在港口和船上都可以摆放。</p> 
<center> 
 <img src="https://images2.imgbox.com/b7/3f/OkRjqXzG_o.png" width="60%"> 
</center> 
<p><strong>虚拟机&amp;Docker的隔离：</strong></p> 
<ul><li>隔离： 
  <ul><li>虚拟机：现代软件开发的一大目的就是隔离，通过将应用程序部署在不同的虚拟机中从而实现隔离</li><li>容器：只隔离应用程序的运行时环境（程序运行依赖的各种库以及配置）但容器之间可以共享同一个操作系统</li></ul> </li><li>容器的优势：<strong>轻量级且占用的资源更少</strong>，与操作系统动辄几G的内存占用相比，容器技术只需数M空间，因此我们可以在同样规格的硬件上<strong>大量部署容器</strong>，而且不同于操作系统数分钟的启动时间容器几乎瞬时启动</li></ul> 
<h3><a id="12_Docker_26"></a>1.2. 什么是Docker</h3> 
<center> 
 <img src="https://images2.imgbox.com/d4/b8/6KWPeK0l_o.png" width="40%"> 
</center> 
<p><strong>Docker：</strong> Go语言开源项目，docker将程序以及程序所有的依赖都打包到docker container。Docker可以把程序所需要的环境装在容器里面，以做到一次容器配置，程序处处可运行。</p> 
<p><strong>组成（理解）：</strong></p> 
<center> 
 <img src="https://images2.imgbox.com/6d/15/Cnm6cuId_o.png" width="40%"> 
</center> 
<ul><li>dockerfile——源代码</li><li>image——可执行的程序</li><li>container——进程</li></ul> 
<p><strong>关键指令：</strong></p> 
<ul><li><code>docker build</code><br> docker编译docker file：client在接收到请求后转发给docker daemon，接着docker daemon根据docker file创建出“可执行程序”image</li></ul> 
<center> 
 <img src="https://images2.imgbox.com/f6/f7/DvvS5T8P_o.png" width="60%"> 
</center> 
<ul><li><code>docker run</code><br> docker daemon<font color="#999aaa" size="1">（守护进程，负责管理容器和镜像的生命周期，以及提供其他相关的管理和维护功能）</font>将image加载到内存执行，跑起来的image就是container</li></ul> 
<center> 
 <img src="https://images2.imgbox.com/3a/01/GtcUv2kn_o.png" width="60%"> 
</center> 
<ul><li><code>docker pull</code><br> docker daemon接收到命令后向docker registry（镜像库）发送image下载请求</li></ul> 
<center> 
 <img src="https://images2.imgbox.com/6e/8a/Llb1492N_o.png" width="60%"> 
</center> 
<p><strong>Docker的关键组件：</strong></p> 
<ul><li><strong>容器技术</strong>：Docker使用容器技术来隔离应用程序及其依赖项。每个容器都包含了一个应用程序及其所有的依赖项，并且彼此相互隔离。这使得应用程序的部署、管理和扩展变得更加简单和高效。</li><li><strong>镜像</strong>：Docker使用镜像来定义容器的运行环境。镜像是一个轻量级的、可执行的独立软件包，包含了运行应用程序所需的所有文件和配置。Docker通过读取镜像来创建和运行容器。</li><li><strong>Docker守护进程</strong>：Docker守护进程是Docker引擎的核心组件，负责管理容器和镜像的生命周期。它接收来自Docker客户端的命令和请求，并在后台运行容器和执行相关的操作。</li><li><strong>Docker注册中心</strong>：Docker注册中心用于存储和共享镜像。它提供了一个中央化的存储和分发机制，使得镜像可以轻松地在不同的机器和环境之间传输和共享。</li><li><strong>Docker CLI（命令行接口）</strong>：Docker CLI是Docker的命令行工具，用于与Docker守护进程进行交互。通过Docker CLI，用户可以创建、运行、停止、删除容器和镜像等操作。</li><li><strong>Docker网络</strong>：Docker网络负责管理容器之间的网络通信以及容器与外部网络的连接。它提供了一种灵活的网络模型，使得容器可以轻松地相互通信并暴露给外部世界。</li><li><strong>Docker存储驱动</strong>：Docker使用存储驱动来管理容器的文件系统和卷。不同的存储驱动可以根据需求选择，以满足不同的性能和可靠性要求。</li></ul> 
<h2><a id="2_Docker_61"></a>2. 安装Docker</h2> 
<p><strong>本文全的案例与指令全是基于Centos7.6！！！</strong></p> 
<blockquote> 
 <p><strong>注意：Docker默认安装目录：<font color="red">/var/lib/docker</font></strong></p> 
</blockquote> 
<ol><li> <p>查看docker稳定版本，并选择安装：</p> <pre><code class="prism language-powershell"><span class="token comment"># 在存储库中列出可用版本</span>
yum list docker-ce <span class="token operator">--</span>showduplicates <span class="token punctuation">|</span> <span class="token function">sort</span> <span class="token operator">-</span>r
<span class="token comment"># 安装</span>
yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-<span class="token function">cli</span><span class="token operator">-</span>&lt;VERSION_STRING&gt; containerd<span class="token punctuation">.</span>io
</code></pre> </li><li> <p>CentOS7 系统 CentOS-Extras 库中已带 Docker，可以直接安装</p> <pre><code class="prism language-powershell">yum update
<span class="token comment"># 安装必要依赖</span>
<span class="token comment">#  yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span>
yum install <span class="token operator">-</span>y yum-utils device-mapper-persistent-<span class="token keyword">data</span> lvm2
<span class="token comment"># 设置yum源（2选1）</span>
  <span class="token comment"># 阿里</span>
  yum-config-manager <span class="token operator">--</span><span class="token function">add-repo</span> http:<span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com/docker-ce/linux/centos/docker-ce<span class="token punctuation">.</span>repo
  <span class="token comment"># 中央</span>
  yum-config-manager <span class="token operator">--</span><span class="token function">add-repo</span> http:<span class="token operator">/</span><span class="token operator">/</span>download<span class="token punctuation">.</span>docker<span class="token punctuation">.</span>com/linux/centos/docker-ce<span class="token punctuation">.</span>repo
<span class="token comment"># 可以查看所有仓库中所有docker版本，并选择特定版本安装</span>
yum list docker-ce <span class="token operator">--</span>showduplicates <span class="token punctuation">|</span> <span class="token function">sort</span> <span class="token operator">-</span>r
yum install docker-ce-18<span class="token punctuation">.</span>03<span class="token punctuation">.</span>1<span class="token punctuation">.</span>ce
</code></pre> </li><li> <p>安装之后启动 Docker 服务，并配置开机自启动</p> <pre><code class="prism language-powershell"><span class="token comment"># 启动Docker服务，也可以使用 systemctl start docker 启动服务</span>
service docker <span class="token function">start</span>
<span class="token comment"># 设置开机自启动</span>
chkconfig docker on
<span class="token comment"># 查看Docker是否开机自启动</span>
systemctl is-enabled docker
</code></pre> </li><li> <p>卸载Docker，可参考这篇博客：<a href="https://blog.csdn.net/zqd_java/article/details/122249755">https://blog.csdn.net/zqd_java/article/details/122249755</a></p> </li></ol> 
<h2><a id="3__102"></a>3. 镜像操作</h2> 
<p><strong>此部分以拉取Postgresql:14.2的镜像为例</strong></p> 
<h3><a id="31__106"></a>3.1. 拉取镜像</h3> 
<blockquote> 
 <p>如果拉取镜像报错报错：missing signature key<br> 处理： 查看docker版本<code>docker version</code><br> docker版本太老，需要重装<br> <img src="https://images2.imgbox.com/6e/d2/smtTBslt_o.png" width="80%"><br> 安装最新的Docker：<code>yum install docker-ce -y</code></p> 
</blockquote> 
<ol><li>拉取pg镜像 
  <ul><li><code>docker search postgres</code> 查看远程仓库有哪些版本的postgres 
    <ul><li><code>docker pull postgres:14.2</code> 拉取Postgresql</li></ul> </li><li><code>docker images</code> 展示本地镜像<br> 仓库 镜像标记 ID（唯一） 创建时间 大小<br> <img src="https://images2.imgbox.com/7d/5e/zd5WD0ci_o.png" width="80%"></li></ul> </li></ol> 
<h3><a id="32__123"></a>3.2. 卸载镜像/容器</h3> 
<p><code>docker rmi imagesId</code> 通过镜像ID卸载镜像<br> <img src="https://images2.imgbox.com/50/3a/NSwlji9y_o.png" width="80%"><br> 如果一个镜像正在被一个容器所使用，那就删除这个容器，再卸载镜像，或者 <code>docker rmi -f ImageId</code> 强制卸载<br> <img src="https://images2.imgbox.com/a0/5e/K2QdBZTu_o.png" width="80%"><br> 如何删除一个容器<br> <img src="https://images2.imgbox.com/30/f6/4tHOlt3O_o.png" width="80%"></p> 
<ul><li>查看容器列表（查看所有容器，如果不加 --all，只查正在跑的容器）：<code>docker container list --all</code>，也可以用<code>docker ps</code></li><li>停止容器：<code>docker stop ContainerId</code></li><li>删除容器：<code>docker rm ContainerId</code></li></ul> 
<h3><a id="33__135"></a>3.3. 使用镜像/容器</h3> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <ol><li>默认情况下，Docker容器中的PostgreSQL数据目录通常位于容器内部的<font color="red">/var/lib/postgresql/data</font>路径下</li><li>刚拉下来Postgresql镜像并不会立即创建一个数据目录，而是需要运行起来容器之后才会创建</li><li><strong>最好初始化一个docker卷来持久化Postgresql的数据，并将其挂载到PostgreSQL容器的/var/lib/postgresql/data目录</strong></li></ol> 
</blockquote> 
<p><strong>配置postgreSQL14.2镜像：</strong></p> 
<ol><li> <p>创建一个docker卷持久化Postgresql的数据<br> docker卷：<code>volume</code>，一个持久的存储区域，可以用来保存数据，即使容器被删除或重新创建，数据仍然可以保留（注：卷名必须唯一）</p> <pre><code class="prism language-powershell">docker volume create psql-<span class="token keyword">data</span>
</code></pre> </li><li> <p>创建并运行容器</p> <pre><code class="prism language-powershell"><span class="token comment"># docker run -d --name 容器名 -v docker卷:psql数据目录 -e POSTGRES_USER=用户名 -e POSTGRES_PASSWORD=密码 -p 端口 repository:tag</span>
docker run <span class="token operator">--</span>privileged=true <span class="token operator">-</span>d <span class="token operator">--</span>name mypg <span class="token operator">-</span>v psql-<span class="token keyword">data</span>:<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib/postgresql/<span class="token keyword">data</span> <span class="token operator">-</span>e POSTGRES_USER=postgres <span class="token operator">-</span>e POSTGRES_PASSWORD=admin <span class="token operator">-</span>p 5432:5432 postgres:14<span class="token punctuation">.</span>2
</code></pre> </li><li> <p>验证持久目录<br> <strong>注意：</strong> 直接<code>ls /var/lib/postgresql/data</code>可能会报错——ls: cannot access</p> <pre><code class="prism language-powershell"><span class="token namespace">[root@VM-8-9-centos lib]</span><span class="token comment"># ls /var/lib/postgresql/data</span>
<span class="token function">ls</span>: cannot access <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib/postgresql/<span class="token keyword">data</span>: No such file or directory
</code></pre> <p>当使用<code>-v</code>选项将宿主机上的目录挂载到容器内时，Docker会在宿主机上创建一个卷，并使用容器内的路径来映射它。如我将psql-data卷挂载到了容器的/var/lib/postgresql/data目录。<br> 但是，/var/lib/postgresql/data这个路径是PostgreSQL容器的内部路径，而不是宿主机上的实际路径。当我尝试在宿主机上使用ls命令列出这个路径时，它会提示“No such file or directory”，因为该路径在宿主机上并不存在。<br> 应该使用Docker提供的命令和工具，而不是直接在宿主机上访问该路径。应该用<code>docker exec &lt;container_name_or_id&gt; &lt;command&gt;</code>在容器内部执行指令。</p> <pre><code class="prism language-powershell"><span class="token namespace">[root@VM-8-9-centos lib]</span><span class="token comment"># docker exec -it mypg ls /var/lib/postgresql/data</span>
base          pg_ident<span class="token punctuation">.</span>conf  pg_serial     pg_tblspc    postgresql<span class="token punctuation">.</span>auto<span class="token punctuation">.</span>conf
global        pg_logical     pg_snapshots  pg_twophase  postgresql<span class="token punctuation">.</span>conf
pg_commit_ts  pg_multixact   pg_stat       PG_VERSION   postmaster<span class="token punctuation">.</span>opts
pg_dynshmem   pg_notify      pg_stat_tmp   pg_wal       postmaster<span class="token punctuation">.</span>pid
pg_hba<span class="token punctuation">.</span>conf   pg_replslot    pg_subtrans   pg_xact
</code></pre> </li><li> <p>连接数据库<br> 报错原因和上面是一样的</p> <pre><code class="prism language-powershell"><span class="token namespace">[root@VM-8-9-centos ~]</span><span class="token comment"># psql -U postgres -h localhost -p 5432 -d postgres</span>
<span class="token operator">-</span>bash: psql: command not found
</code></pre> <p>换个指令：<code>docker exec -it mypg psql -U postgres -h localhost -p 5432 -d postgres</code></p> <pre><code class="prism language-powershell"><span class="token namespace">[root@VM-8-9-centos ~]</span><span class="token comment"># docker exec -it mypg psql -U postgres -h localhost -p 5432 -d postgres</span>
psql <span class="token punctuation">(</span>14<span class="token punctuation">.</span>2 <span class="token punctuation">(</span>Debian 14<span class="token punctuation">.</span>2-1<span class="token punctuation">.</span>pgdg110+1<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">Type</span> <span class="token string">"help"</span> <span class="token keyword">for</span> help<span class="token punctuation">.</span>

postgres=<span class="token comment">#</span>
</code></pre> </li><li> <p>开启密码校验：可以看到，无须密码就登录进去了，现在就需要去修改一下配置文件了<br> 就是要找到<font color="red">pg_hba.conf</font>文件的目录，然后修改</p> <pre><code class="prism language-powershell"><span class="token namespace">[root@VM-8-9-centos ~]</span><span class="token comment"># find / -name pg_hba.conf</span>
<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib/docker/volumes/psql-<span class="token keyword">data</span><span class="token operator">/</span>_data/pg_hba<span class="token punctuation">.</span>conf
<span class="token namespace">[root@VM-8-9-centos ~]</span><span class="token comment"># vim /var/lib/docker/volumes/psql-data/_data/pg_hba.conf</span>
</code></pre> <p>改前：<br> <img src="https://images2.imgbox.com/65/36/deEsHJ1I_o.png" width="60%"><br> 改后：<br> <img src="https://images2.imgbox.com/fe/2f/7clQEdPw_o.png" width="60%"></p> </li><li> <p>重启容器就OK了<br> <img src="https://images2.imgbox.com/c3/04/ofNpzXC2_o.png" width="60%"></p> </li></ol> 
<h2><a id="4__200"></a>4. 相关指令说明</h2> 
<p>为了方便阅读，这里对文中的相关指令做一些说明。</p> 
<p>Docker常用指令：都是<code>docker</code>开头的指令。</p> 
<table><thead><tr><th align="left">指令</th><th align="left">说明</th><th align="left">案例</th></tr></thead><tbody><tr><td align="left"><code>docker pull</code></td><td align="left">拉取镜像</td><td align="left">docker pull postgres:14.2</td></tr><tr><td align="left"><code>docker version</code></td><td align="left">查看docker版本</td><td align="left"></td></tr><tr><td align="left"><code>docker search</code></td><td align="left">查看远程仓库的镜像版本</td><td align="left">docker search postgres</td></tr><tr><td align="left"><code>docker images</code></td><td align="left">展示本地镜像</td><td align="left"></td></tr><tr><td align="left"><code>docker rmi</code></td><td align="left">卸载镜像</td><td align="left">docker rmi imagesId<br>docker rmi -f imagesId</td></tr><tr><td align="left"><code>docker container list</code><br><code>docker container list --all</code></td><td align="left">展示在运行的容器<br>展示本地所有容器</td><td align="left"></td></tr><tr><td align="left"><code>docker ps</code></td><td align="left">展示正在跑的容器</td><td align="left"></td></tr><tr><td align="left"><code>docker stop</code></td><td align="left">停止容器运行</td><td align="left">docker stop ContainerId</td></tr><tr><td align="left"><code>docker rm</code></td><td align="left">卸载容器</td><td align="left">docker rm ContainerId<br>docker rm -f ContainerId</td></tr><tr><td align="left"><code>docker volume</code></td><td align="left">docker卷操作</td><td align="left">docker volume create psql-data<br>创建一个叫psql-data的卷</td></tr><tr><td align="left"><code>docker run</code></td><td align="left">创建并运行容器</td><td align="left">docker run --privileged=true -d --name mypg -v psql-data:/var/lib/postgresql/data -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=admin -p 5432:5432 postgres:14.2</td></tr><tr><td align="left"><code>docker exec</code></td><td align="left">在容器内部执行指令</td><td align="left">docker exec -it mypg ls /var/lib/postgresql/data</td></tr><tr><td align="left"><code>docker satrt</code></td><td align="left">运行容器</td><td align="left">docker satrt name</td></tr><tr><td align="left"><code>docker restart</code></td><td align="left">重启容器</td><td align="left">docker restart name</td></tr></tbody></table> 
<p>一些Centos7操作：</p> 
<table><thead><tr><th align="left">操作</th><th align="left">指令</th></tr></thead><tbody><tr><td align="left">修改环境变量</td><td align="left"><code>vi /etc/profile</code><br><code>export 变量名=$PATH:文件目录</code><br><code>source /etc/profile</code></td></tr><tr><td align="left">查看环境变量</td><td align="left"><code>echo $变量名</code>或<code>env</code></td></tr><tr><td align="left">删除环境变量</td><td align="left"><code>unset 变量名</code>或<code>unset *.*</code></td></tr></tbody></table> 
<p>对比which、whereis、find、locate：</p> 
<ul><li> <p><strong><code>which</code></strong>——用于查找可直接执行的命令，且<font color="red">只在$PATH路径（环境变量）中搜索</font>，只返回第一个匹配的文件路径，但可以通过<code>-a</code>选项返回所有匹配结果</p> <pre><code class="prism language-powershell"><span class="token namespace">[root@VM-8-9-centos bin]</span><span class="token comment"># which docker</span>
<span class="token operator">/</span>usr/bin/docker
</code></pre> </li><li> <p><strong><code>whereis</code></strong>——在<font color="red">$PATH路径基础上增加了一些系统目录的查找</font>，查找范围比which稍大，查找速度快。可以通过选项-b限定只搜索二进制文件</p> <pre><code class="prism language-powershell"><span class="token namespace">[root@VM-8-9-centos bin]</span><span class="token comment"># whereis docker</span>
docker: <span class="token operator">/</span>usr/bin/docker <span class="token operator">/</span>etc/docker <span class="token operator">/</span>usr/share/man/man1/docker<span class="token punctuation">.</span>1<span class="token punctuation">.</span>gz
</code></pre> </li><li> <p><strong><code>find</code></strong>——直接搜索整个文件目录的任意文件，默认从根目录开始搜索，匹配名字</p> <pre><code class="prism language-powershell"><span class="token namespace">[root@VM-8-9-centos bin]</span><span class="token comment"># find / -name docker</span>
<span class="token operator">/</span>sys/fs/cgroup/devices/docker
<span class="token operator">/</span>sys/fs/cgroup/cpuset/docker
<span class="token operator">/</span>sys/fs/cgroup/hugetlb/docker
<span class="token operator">/</span>sys/fs/cgroup/net_cls<span class="token punctuation">,</span>net_prio/docker
<span class="token operator">/</span>sys/fs/cgroup/pids/docker
<span class="token operator">/</span>sys/fs/cgroup/freezer/docker
<span class="token operator">/</span>sys/fs/cgroup/cpu<span class="token punctuation">,</span>cpuacct/docker
<span class="token operator">/</span>sys/fs/cgroup/blkio/docker
<span class="token operator">/</span>sys/fs/cgroup/memory/docker
<span class="token operator">/</span>sys/fs/cgroup/perf_event/docker
<span class="token operator">/</span>sys/fs/cgroup/systemd/docker
<span class="token operator">/</span>etc/docker
<span class="token operator">/</span>usr/share/bash-completion/completions/docker
<span class="token operator">/</span>usr/bin/docker
<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib/docker
<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib/docker/overlay2/07892f16155c27680887056014518b9bda0c79aa0da2a3973dcc6d68c337a9a8/<span class="token function">diff</span><span class="token operator">/</span>etc/dpkg/dpkg<span class="token punctuation">.</span>cfg<span class="token punctuation">.</span>d/docker
<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib/docker/overlay2/b6417229db3f6b31cfc75c95453e44541e6c172e961631dd92de966a100bbe3f/<span class="token function">diff</span><span class="token operator">/</span>etc/dpkg/dpkg<span class="token punctuation">.</span>cfg<span class="token punctuation">.</span>d/docker
<span class="token operator">/</span>run/docker
</code></pre> </li><li> <p><code>locate</code>——超快速查找任意文件。它会从Linux内置的索引数据库查找文件的路径，索引速度超快。刚刚新建的文件可能需要一定时间才能加入该索引数据库，可以通过执行<code>updatedb</code>命令来强制更新一次索引，这样确保不会遗漏文件。该命令通常会返回大量匹配项，可以使用<code>-r</code>选项通过正则表达式来精确匹配</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0fc8821e33d426ec56247474a223f355/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">spring boot dispatcherServlet注册到tomcat及tomcat请求如何找到dispatcherServlet</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3719a6bc8042b28e70b6bab0e4eb9c41/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">支付宝沙箱支付</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>