<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中构造函数能调用虚函数吗？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中构造函数能调用虚函数吗？" />
<meta property="og:description" content="环境：XPSP3 VS2005
今天黑总给应聘者出了一个在C&#43;&#43;的构造函数中调用虚函数的问题，具体的题目要比标题复杂，大体情况可以看如下的代码：
class Base{public:Base(){Fuction();}virtual void Fuction(){cout &lt;&lt; &#34;Base::Fuction&#34; &lt;&lt; endl;}};class A : public Base{public:A(){Fuction();}virtual void Fuction(){cout &lt;&lt; &#34;A::Fuction&#34; &lt;&lt; endl;}};// 这样定义一个A的对象，会输出什么？A a; 首先回答标题的问题，调用当然是没有问题的，但是获得的是你想要的结果吗？或者说你想要什么样的结果？
有人说会输出：
A::FuctionA::Fuction 如果是这样，首先我们回顾下C&#43;&#43;对象模型里面的构造顺序，在构造一个子类对象的时候，首先会构造它的基类，如果有多层继承关系，实际上会从最顶层的基类逐层往下构造（虚继承、多重继承这里不讨论），如果是按照上面的情形进行输出的话，那就是说在构造Base的时候，也就是在Base的构造函数中调用Fuction的时候，调用了子类A的Fuction，而实际上A还没有开始构造，这样函数的行为就是完全不可预测的，因此显然不是这样，实际的输出结果是：
Base::FuctionA::Fuction 据说在JAVA中是上一种输出（感觉有点匪夷所思）。
我们来单步看一下到底发生了什么？在A的构造函数里面首先会去调用Base的构造函数，Base的构造函数如下：
class Base
{
public:
Base()
00411600 push ebp 00411601 mov ebp,esp 00411603 sub esp,0CCh 00411609 push ebx 0041160A push esi 0041160B push edi 0041160C push ecx 0041160D lea edi,[ebp-0CCh] 00411613 mov ecx,33h 00411618 mov eax,0CCCCCCCCh 0041161D rep stos dword ptr es:[edi] 0041161F pop ecx 00411620 mov dword ptr [ebp-8],ecx 00411623 mov eax,dword ptr [this] 00411626 mov dword ptr [eax],offset Base::`vftable&#39; (41770Ch)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/08bad8b254bcc015c3f9c5fee6339737/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-08-31T00:07:49+08:00" />
<meta property="article:modified_time" content="2011-08-31T00:07:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中构造函数能调用虚函数吗？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-family:Microsoft YaHei">      环境：XPSP3 VS2005</span></p> 
<p>        <span style="font-family:Microsoft YaHei">今天黑总给应聘者出了一个在C++的构造函数中调用虚函数的问题，具体的题目要比标题复杂，大体情况可以看如下的代码：</span></p> 
<pre><code class="language-cpp">class Base
{
public:
	Base()
	{
		Fuction();
	}

	virtual void Fuction()
	{
		cout &lt;&lt; "Base::Fuction" &lt;&lt; endl;
	}
};

class A : public Base
{
public:
	A()
	{
		Fuction();
	}

	virtual void Fuction()
	{
		cout &lt;&lt; "A::Fuction" &lt;&lt; endl;
	}
};

// 这样定义一个A的对象，会输出什么？
A a;</code></pre> 
<p><span style="font-family:Microsoft YaHei">        首先回答标题的问题，调用当然是没有问题的，但是获得的是你想要的结果吗？或者说你想要什么样的结果？</span></p> 
<p><span style="font-family:Microsoft YaHei">        有人说会输出：</span></p> 
<pre><code class="language-html">A::Fuction
A::Fuction</code></pre> 
<p><span style="font-family:Microsoft YaHei">        如果是这样，首先我们回顾下C++对象模型里面的构造顺序，在构造一个子类对象的时候，首先会构造它的基类，如果有多层继承关系，实际上会从最顶层的基类逐层往下构造（虚继承、多重继承这里不讨论），如果是按照上面的情形进行输出的话，那就是说在构造Base的时候，也就是在Base的构造函数中调用Fuction的时候，调用了子类A的Fuction，而实际上A还没有开始构造，这样函数的行为就是完全不可预测的，因此显然不是这样，实际的输出结果是：</span></p> 
<span style="font-family:Microsoft YaHei"></span> 
<pre><code class="language-html">Base::Fuction
A::Fuction</code></pre> 
<p><span style="font-family:Microsoft YaHei">        据说在JAVA中是上一种输出（感觉有点匪夷所思）。</span></p> 
<p><span style="font-family:Microsoft YaHei">        我们来单步看一下到底发生了什么？在A的构造函数里面首先会去调用Base的构造函数，Base的构造函数如下：</span></p> 
<p><span style="font-family:Microsoft YaHei">class Base<br> {<!-- --><br> public:<br>  Base()<br> 00411600  push        ebp  <br> 00411601  mov         ebp,esp <br> 00411603  sub         esp,0CCh <br> 00411609  push        ebx  <br> 0041160A  push        esi  <br> 0041160B  push        edi  <br> 0041160C  push        ecx  <br> 0041160D  lea         edi,[ebp-0CCh] <br> 00411613  mov         ecx,33h <br> 00411618  mov         eax,0CCCCCCCCh <br> 0041161D  rep stos    dword ptr es:[edi] <br> <strong><span style="color:#cc0000">0041161F  pop         ecx  <br> 00411620  mov         dword ptr [ebp-8],ecx <br> 00411623  mov         eax,dword ptr [this] <br> 00411626  mov         dword ptr [eax],offset Base::`vftable' (41770Ch)<br> </span></strong> {<!-- --><br>   Fuction();<br> <strong><span style="color:#cc0000">0041162C  mov         ecx,dword ptr [this] <br> 0041162F  call        Base::Fuction (4111A9h)</span></strong></span></p> 
<p><span style="font-family:Microsoft YaHei"> }<br> 00411634  mov         eax,dword ptr [this] <br> 00411637  pop         edi  <br> 00411638  pop         esi  <br> 00411639  pop         ebx  <br> 0041163A  add         esp,0CCh <br> 00411640  cmp         ebp,esp <br> 00411642  call        @ILT+460(__RTC_CheckEsp) (4111D1h) <br> 00411647  mov         esp,ebp <br> 00411649  pop         ebp  <br> 0041164A  ret</span></p> 
<p><span style="font-family:Microsoft YaHei">        从单步跟踪来看，注意黑色加粗的那部分汇编代码，ecx中存放的是对象的地址（0x0012ff60，我的机器上的情况看下图，有图有真相），首先是设置vtable的地址到对象的前四个字节（不同的编译器可能不同），然后就直接调用了Base::Fuction函数，并没有走虚机制，而我们此时看虚表中的状态，虚表已经填充的是0x4111a9，注意虚表的地址0x0041770c，而此时对象地址0x0012FF60前四个字节存放的正是0x0041770c。</span><br> <img alt="" src="https://images2.imgbox.com/8e/ce/81aCH2l3_o.gif"><br> <span style="font-family:Microsoft YaHei">        继续跟踪，流程又回到A的构造函数中，再次注意加粗部分的代码，从基类Base的构造函数返回后，在A的构造函数中，重设了虚表指针，现在的虚表指针是（0x417700h），同样调用Fuction的时候直接调用了A::Fuction函数，并没有使用虚机制，而且此时虚表0x417700h指向的位置存放的0x41110e正是A::Fuction的地址。</span></p> 
<p><span style="font-family:Arial"><img alt="" src="https://images2.imgbox.com/31/64/JtcAKbXZ_o.gif"></span></p> 
<p><span style="font-family:Microsoft YaHei">class A : public Base<br> {<!-- --><br> public:<br>  A()<br> 00411590  push        ebp  <br> 00411591  mov         ebp,esp <br> 00411593  sub         esp,0CCh <br> 00411599  push        ebx  <br> 0041159A  push        esi  <br> 0041159B  push        edi  <br> 0041159C  push        ecx  <br> 0041159D  lea         edi,[ebp-0CCh] <br> 004115A3  mov         ecx,33h <br> 004115A8  mov         eax,0CCCCCCCCh <br> 004115AD  rep stos    dword ptr es:[edi] <br> 004115AF  pop         ecx  <br> 004115B0  mov         dword ptr [ebp-8],ecx <br> 004115B3  mov         ecx,dword ptr [this] <br> </span><span style="font-family:Microsoft YaHei"><strong><span style="color:#cc0000">004115B6  call        Base::Base (411140h) <br> 004115BB  mov         eax,dword ptr [this] <br> 004115BE  mov         dword ptr [eax],offset A::`vftable' (417700h)<br> </span></strong> {<!-- --><br>   Fuction();<br> </span><span style="font-family:Microsoft YaHei"><strong><span style="color:#cc0000">004115C4  mov         ecx,dword ptr [this] <br> 004115C7  call        A::Fuction (41110Eh)<br> </span></strong> }<br> 004115CC  mov         eax,dword ptr [this] <br> 004115CF  pop         edi  <br> 004115D0  pop         esi  <br> 004115D1  pop         ebx  <br> 004115D2  add         esp,0CCh <br> 004115D8  cmp         ebp,esp <br> 004115DA  call        @ILT+460(__RTC_CheckEsp) (4111D1h) <br> 004115DF  mov         esp,ebp <br> 004115E1  pop         ebp  <br> 004115E2  ret</span></p> 
<p><span style="font-family:微软雅黑"></span><br> <span style="font-family:Microsoft YaHei">        </span>其实事情就是这么简单。</p> 
<p><span style="font-family:微软雅黑"></span> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8da32ff79812e7078620a317dd92fa29/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Sandboxie 3.56 Final 特别版</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3322a15c067698fee7d13406628cde41/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安装 VS2008 HRESULT -2147023293 失败解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>