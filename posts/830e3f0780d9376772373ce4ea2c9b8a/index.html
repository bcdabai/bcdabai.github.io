<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>7分钟带你细致解析4个Java算法必刷题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="7分钟带你细致解析4个Java算法必刷题" />
<meta property="og:description" content="1.两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] &#43; nums[1] == 9 ，返回 [0, 1] 。 示例 2：
输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：
输入：nums = [3,3], target = 6 输出：[0,1] 提示：
2 &amp;lt;= nums.length &amp;lt;= 104-109 &amp;lt;= nums[i] &amp;lt;= 109-109 &amp;lt;= target &amp;lt;= 109只会存在一个有效答案 **进阶：**你可以想出一个时间复杂度小于 O(n^2) 的算法吗？
解题 1.双层循环（时间复杂度 O(n^2)）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/830e3f0780d9376772373ce4ea2c9b8a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-21T17:20:40+08:00" />
<meta property="article:modified_time" content="2022-11-21T17:20:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">7分钟带你细致解析4个Java算法必刷题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3></h3> 
<h2><strong>1.两数之和</strong></h2> 
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p> 
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p> 
<p>你可以按任意顺序返回答案。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：nums = [3,2,4], target = 6
输出：[1,2]
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：nums = [3,3], target = 6
输出：[0,1]
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>2 &amp;lt;= nums.length &amp;lt;= 104</code></li><li><code>-109 &amp;lt;= nums[i] &amp;lt;= 109</code></li><li><code>-109 &amp;lt;= target &amp;lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul> 
<p>**进阶：**你可以想出一个时间复杂度小于 <code>O(n^2)</code> 的算法吗？</p> 
<h4>解题</h4> 
<p>1.双层循环（时间复杂度 <code>O(n^2)</code>）</p> 
<pre><code>var twoSum = function (nums, target) {
    let res = []
    for (let i = 0; i &amp;lt; nums.length - 1; i++) {
        for (let j = i + 1; j &amp;lt; nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                res[0] = i;
                res[1] = j;
                return res;
            }
        }
    }
};
</code></pre> 
<p>提交截图</p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/0e/0b/x19SmT9l_o.png"></p> 
<p> </p> 
<p></p> 
<p>2.使用对象来装进行判断（时间复杂度 <code>O(n)</code>）</p> 
<pre><code>var twoSum = function (nums, target) {
  let hash = {};
  for (let i = 0; i &amp;lt; nums.length; i++) {
    //判断目标值减去数组里面对应的值如果在对象里面存在的话 返回对应的下标
    if (hash[target - nums[i]] !== undefined) {
      return [i, hash[target - nums[i]]];
    }
    //将数组里面的值当做对象的key 将对应的下标当作值
    hash[nums[i]] = i;
  }
  //未找到返回空数组
  return [];
};
</code></pre> 
<p>提交截图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d6/34/bVAJ7OmO_o.png"> </p> 
<p> </p> 
<p></p> 
<h3>2.两数相加</h3> 
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p> 
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p> 
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p> 
<p><strong>示例 1：</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a8/f6/nZST4vwl_o.jpg"></p> 
<pre><code>输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：l1 = [0], l2 = [0]
输出：[0]
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &amp;lt;= Node.val &amp;lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul> 
<h4>解题（链表）</h4> 
<pre><code>/**
 * 定义的链表  val表示值 next表示下一个
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
   //声明一个链表节点 c表示余数默认为0
   let list=new ListNode(),c=0;
   //声明当前的节点
   let cur=list, all;
   //循环判断对应的节点是否为0
   while(l1||l2||c!=0){
       //将当前节点 指向一个新的节点
       cur.next=new ListNode();
       //再将新节点得到（一步步走到底）
       cur=cur.next;
       //得到对应的指向value值
       all=0+c;
       //判断l1的值不为0
       if(l1){
           //将对应节点的值加上之前节点的值
            all+=parseInt(l1.val);
           //继续往下走
            l1=l1.next;
       }
       //判断l2的值不为0
       if(l2){
           //将对应的值加上之前的节点的值
            all+=parseInt(l2.val);
           //继续往下走
            l2=l2.next;
       }
       //将当前的节点的值存入
       cur.val=all%10;
       //得到对应的余数
       c=parseInt(all/10);
      
   }
   //返回list的下一个节点（默认第一个节点为空）
   return list.next;
};
</code></pre> 
<p>提交截图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/48/c8/4iVuUPXY_o.png"> </p> 
<p> </p> 
<p></p> 
<h3>3.无重复字符的最长子串</h3> 
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p> 
<p><strong>示例 1:</strong></p> 
<pre><code>输入: s = &amp;quot;abcabcbb&amp;quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。
</code></pre> 
<p><strong>示例 2:</strong></p> 
<pre><code>输入: s = &amp;quot;bbbbb&amp;quot;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。
</code></pre> 
<p><strong>示例 3:</strong></p> 
<pre><code>输入: s = &amp;quot;pwwkew&amp;quot;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>0 &amp;lt;= s.length &amp;lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul> 
<h4>解题</h4> 
<p>1.暴力破解（以每个字符串为开头遍历一遍，也就是总共遍历两遍。<code>O(n^2)</code>）</p> 
<pre><code>//暴力解法+Set
var lengthOfLongestSubstring = function(s) {
    //记录长度
    let count=0;
    for(let i=0;i&amp;lt;s.length;i++){
        //实例化set完成去重操作
        let set=new Set();
        //长度默认为0
        let max=0;
        //第二层遍历
        let j=i;
        //如果set不包含对应的元素以及遍历的下标小于长度进入
        while(j&amp;lt;s.length&amp;&amp;!set.has(s[j])){
            //将内容添加到set
            set.add(s[j]);
            //长度++
            max++;
            //控制往后走
            j++;
        }
        //比对得到最大值
        count=Math.max(count,max);
    }
    return count;
};
</code></pre> 
<p>提交截图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/27/82/GHgr3lOh_o.png"> </p> 
<p> </p> 
<p></p> 
<p>2.贪心算法（将不重复的字符串长度记录等有重复字符串的时候将前面的截取 比对长度记录最大值 从这个字符开始继续前面的操作 <code>O(n)</code>）</p> 
<p>2.1 代码</p> 
<pre><code>var lengthOfLongestSubstring = function(s) {
    let subs = &amp;apos;&amp;apos;;
    let res = 0;
    for (let i = 0; i &amp;lt; s.length; i++) {
        //判断是否包含重复字符串
        const index = subs.indexOf(s[i]);
        //如果有重复的字符串
        if (index !== -1) {
            //比对 记录这个长度
            res = Math.max(res, subs.length);
			//截取对应的字符串（将对应的字符串前面的内容取出 拿出重复的内容）
            subs = subs.substr(index + 1);
        }
        //字符串拼接
        subs += s[i];
    }
    //最后比对最大值返回
    return Math.max(res, subs.length);
};
</code></pre> 
<p>2.2 代码</p> 
<pre><code>var lengthOfLongestSubstring = function(s) {
    let minIndex = 0
    let count = 0
    //遍历
    for(let i = 0; i &amp;lt; s.length; i++){
        //判断是否重复项之前是否出现 最小下标前移
        if(s.indexOf(s[i], minIndex) &amp;lt; i) minIndex = s.indexOf(s[i], minIndex) + 1
        //没有找到 给长度赋值
        else count = Math.max(count, i - minIndex + 1)
    }
    //返回长度
    return count
};
</code></pre> 
<p>2.3 代码</p> 
<pre><code>var lengthOfLongestSubstring = function(s) {
    //准备一个数组来保存对应的字符串
    let arr = []
    //记录最大长度
    let max = 0
    //遍历字符串
    for (let i = 0; i &amp;lt; s.length; i ++) {
        //判断数组中是否有重复元素
        let index = arr.indexOf(s[i]);
        //如果找到了对应的元素删除之前的内容
        index &amp;gt; -1 &amp;&amp; arr.splice(0, index + 1)
        //将对应的字符串添加到数组
        arr.push(s[i])
        //获取最大值
        max = Math.max(arr.length, max)
    }
    return max;
};
</code></pre> 
<p>提交截图（以上三种的思想和速度差不多）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9a/a1/JBLjbuUV_o.png"> </p> 
<p> </p> 
<p></p> 
<h3>4.最长回文子串</h3> 
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：s = &amp;quot;babad&amp;quot;
输出：&amp;quot;bab&amp;quot;
解释：&amp;quot;aba&amp;quot; 同样是符合题意的答案。
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：s = &amp;quot;cbbd&amp;quot;
输出：&amp;quot;bb&amp;quot;
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &amp;lt;= s.length &amp;lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul> 
<h4>解题</h4> 
<p>回文字概述</p> 
<p>从两边向中间，不断比较头尾字符是否相同，也就是对应的内容是否对称。</p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cc/f0/KGpChzii_o.jpg"></p> 
<p></p> 
<p><strong>中心扩展方法</strong></p> 
<p>中心扩展方法的思路:</p> 
<p>遍历每一个字符，向两边扩展找到以其为中心的最长回文子串， 最后比较所有的回文字的长度得到最长。</p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1a/0f/YxQvKK0Y_o.jpg"></p> 
<p></p> 
<p>回文字也分俩种情况</p> 
<p>一种是奇数</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/94/1e/GWHPmJ3N_o.jpg"></p> 
<p> </p> 
<p></p> 
<p>一种是偶数</p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d0/4a/Ri1YPXu8_o.jpg"></p> 
<p></p> 
<p><strong>实现代码</strong></p> 
<pre><code>//中心扩展函数 参数为字符串s 左下标l 有下标r
function search(s,l,r){
    let left=l;
    let right=r;
    //判断是否在区间 以及对应的左指针和右指针是否指向同一个值
    while(left&amp;gt;=0&amp;&amp;right&amp;lt;s.length&amp;&amp;s[left]===s[right]){
        //左指针前移
        left--;
        //右指针前移
        right++;
    }
    //返回对应的长度 最大下标-最小下标-1
    return right-left-1;
}
//本题主函数
function longestPalindrome(s){
    //默认开始位置和结束位置为0
    let start=end=0;
    //循环遍历字符串
    for(let i=0;i&amp;lt;s.length;i++){
        //中心扩展 奇数情况
        let count1=search(s,i,i);
        //中心扩展 偶数情况
        let count2=search(s,i,i+1);
        //得到俩种扩展的最大长度
        let len=Math.max(count1,count2);
        //如果对应的长度超出开始位置和结束位置
        if(len&amp;gt;end-start){
            //开始位置前移
            start=i-Math.floor((len-1)/2);
            //结束位置后移
            end=i+Math.floor((len/2));
        }
    }
    //返回对应的字符串
    return s.slice(start,end+1);
};
</code></pre> 
<p>提交截图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/09/d1/Cu0ouKBF_o.png"> </p> 
<p> </p> 
<p></p> 
<p><strong>马拉车算法 Manacher</strong></p> 
<p>Manachar算法主要是处理字符串中关于回文串的问题的，它可以在 O（n） 的时间处理出以字符串中每一个字符为中心的回文串半径，由于将原字符串处理成<strong>两倍长度的新串</strong>，在每两个字符之间<strong>加入一个特定的特殊字符</strong>，因此原本长度为偶数的回文串就成了以中间特殊字符为中心的<strong>奇数长度的回文串</strong>了。</p> 
<p>如图：我们可以在每个字符间插入"#"，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 "^" 和 "$"，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/74/b9/WJ1Sos2W_o.jpg"></p> 
<p>首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 "#" 的原字符串的总长度。例如下图中下标是 6 的地方。可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 "#c#b#c#b#c#"。而去掉 # 恢复到原来的字符串，变成 "cbcbc"，它的长度刚好也就是 5。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/da/26/hB2NwQMd_o.jpg"></p> 
<p>求原字符串下标</p> 
<p>用 P 的下标 i 减去 P [ i ]，再除以 2 ，就是原字符串的开头下标了。</p> 
<p>例如我们找到 P[ i ] 的最大值为 5 ，也就是回文串的最大长度是 5 ，对应的下标是 6 ，所以原字符串的开头下标是 （6 - 5 ）/ 2 = 0 。所以我们只需要返回原字符串的第 0 到 第 （5 - 1）位就可以了。</p> 
<p>求每个 P [ i ]</p> 
<p>接下来是算法的关键了，它充分利用了回文串的对称性。</p> 
<p>我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ] 。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。</p> 
<p>让我们考虑求 P [ i ] 的时候，如下图。</p> 
<p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ee/e9/YsrghK7p_o.jpg"></p> 
<p>我们现在要求 P [ i ]， 如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror ，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3 。</p> 
<p>但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。</p> 
<p>1. 超出了 R</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5f/20/0UYk3VfC_o.jpg"></p> 
<p>当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7 ，为什么呢，因为我们从 i 开始往后数 7 个，等于 22 ，已经超过了最右的 R ，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。</p> 
<p>2. P [ i_mirror ] 遇到了原字符串的左边界</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/15/e0/gCIyPjmN_o.jpg"></p> 
<p>此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 "#" == "#" ，之后遇到了 "^"和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p> 
<p>3. i 等于了 R</p> 
<p>此时我们先把 P [ i ] 赋值为 0 ，然后通过中心扩展法一步一步扩展就行了。</p> 
<p>考虑 C 和 R 的更新</p> 
<p>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/12/44/HedRe7I4_o.jpg"></p> 
<p>此时的 P [ i ] 求出来将会是 3 ，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R ，我们需要把 C 更新成 i 的值，也就是 10 ，R 更新成 13。继续下边的循环。</p> 
<p>代码</p> 
<pre><code>//插入字符解决奇偶问题
function preProcess(s) {
    //获取字符串长度
    let n = s.length;
    //如果当前长度为0
    if (n == 0) {
        return &amp;quot;^$&amp;quot;;
    }
    //接收新字符串变量 开头为^
    let ret = &amp;quot;^&amp;quot;;
    //遍历添加#号
    for (let i = 0; i &amp;lt; n; i++){
        ret = ret + &amp;quot;#&amp;quot; + s.charAt(i);
    }
    //添加结束
    ret = ret + &amp;quot;#$&amp;quot;;
    //返回新字符串
    return ret;
}
// 马拉车算法
function longestPalindrome(str) {
    //接收新字符串
    let S = preProcess(str);
    let n = S.length;// 保留新字符串的长度
    let len = new Array(n);//新建一个长度为n的数组
    let center = 0, right = 0;// 初始回文串中心点击 及右边界
    // 从第 1 个字符开始
    for (let i = 1; i &amp;lt; n - 1; i++) {
        // 找到i后面的对称位
        let mirror = 2 * center - i;
        //判断i在右边界范围内
        if (right &amp;gt; i) {
            // i 在右边界的范畴内，看看i的对称点的回文串长度，以及i到右边界的长度，取两个较小的那个
            // 不能溢出之前的边界，否则就得核心拓展
            len[i] = Math.min(right - i, len[mirror]);
        } else {
            // 超过范畴了，核心拓展
            len[i] = 0;
        }
        
        // 核心拓展 如果对应的俩边是回文 长度+1
        while (S.charAt(i + 1 + len[i]) == S.charAt(i - 1 - len[i])) {
            len[i]++;
        }

        //如果对应的位置加长度超出右边界
        if (i + len[i] &amp;gt; right) {
            // 更新核心
            center = i;
            // 更新右边界
            right = i + len[i];
        }
    }
    // 通过回文长度数组找出最长的回文串
    let maxLen = 0;
    let centerIndex = 0;
    //循环遍历
    for (let i = 1; i &amp;lt; n - 1; i++) {
        //如果长度大于当前的最大长度 重新赋值
        if (len[i] &amp;gt; maxLen) {
            maxLen = len[i]; //将长度赋给最大值
            centerIndex = i; //中心位置变化
        }
    }
    //原字符串的开始位置
    let start = (centerIndex - maxLen) / 2;
    //截取返回
    return str.substring(start, start + maxLen);
}
</code></pre> 
<p>提交截图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1e/76/VsDEDWU8_o.png"> </p> 
<p> </p> 
<p></p> 
<p>动态规划（DP）此处效率过低</p> 
<pre><code>/**
 * @param {string} s
 * @return {string}
 */ 
var longestPalindrome = function(s){
   let lplang = 1 // 最长长度
    let start = 0 // 当最长长度更新时同时缓存起始点

    let len = s.length
    
    let dp = [] // 缓存结果
    
    // 长度 1 2 单独处理
    for(let i=0; i&amp;lt;len; i++) {
        if(dp[i] === undefined) {
            dp[i] = [] // 初始化二维数组
        }
        dp[i][i] = true // 自己是自己的回文
        // 找出长度为2的回文
        if(s[i] === s[i+1]) {
            dp[i][i+1] = true // 缓存结果
            start = i
            lplang = 2 // 比如两个连续的 aa 也是回文，并且标记最长长度
        }
    }
    
    // 动态规划 找最优子，比如 aa 是回文，那么 baab 只需要判断 b === b &amp;&amp; （aa: 缓存的结果）
    // L 为子串长度，首先找出长度为3的回文，然后是4，5...
    // 同时通过 L 计算 子串终点 i+L-1，起始点+长度-1 = 终点
    for(let L=3; L&amp;lt;=len; L++) {
        for(let i=0; i+L-1&amp;lt;len; i++) {
                // 越往后便利次数越少 当L是16的时候 只遍历1次 判断s[0]s[15]是否相等
            let j = i+L-1 // 第一次对比的是 s[0] === s[2]
            if(s[i] === s[j] &amp;&amp; dp[i+1][j-1]) {
                // 两头相等 并且 子是回文
                dp[i][j] = true // 缓存结果 先缓存的是所有的最短的子串结果
                start = i
                lplang = L // 因为L是从小到大便利的 所以后面的回文长度就是最长的
            }
        }
    }
    return s.substr(start,lplang)
}
</code></pre> 
<p>提交截图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9b/bb/jkCbWZl5_o.png"> </p> 
<hr> 
<p>帮助到你的话就点个关注吧~</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f5d4561727f9fac7fd31a6360b170ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Docker ENV 与 ARG 详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d09df74df9cfaecdbd209227dfa1d442/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">测试平台python函数驱动</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>