<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于 IDEA 进行 Maven 工程构建 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于 IDEA 进行 Maven 工程构建" />
<meta property="og:description" content="1. 构建概念和构建过程 项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。
项目构建是软件开发过程中至关重要的一部分，它能够大大提高软件开发效率，使得开发人员能够更加专注于应用程序的开发和维护，而不必关心应用程序的构建细节。
同时，项目构建还能够将多个开发人员的代码汇合到一起，并能够自动化项目的构建和部署，大大降低了项目的出错风险和提高开发效率。常见的构建工具包括 Maven、Gradle、Ant 等。
2. 命令方式项目构建 命令描述mvn compile编译项目，生成target文件 （java 类编译为字节码文件）mvn package打包项目，生成jar或war文件mvn clean清理编译或打包后的项目结构mvn install打包后上传到maven本地仓库mvn deploy只打包，上传到maven私服仓库mvn site生成站点mvn test执行测试源码 2.1 mvn compile 现在 java 工程中创建一个 User 类
这里需要有 get、set 、toString 等方法，需要用到 lombok 这个 jar 包，来自动实现这些方法
访问 jar 包查询网站： https://mvnrepository.com/
搜索 lombok
选择一个使用较多的版本即可
将依赖放置在当前 java 工程的 pom.xml 中，刷新 maven
使用 lombok 的注解
@data：生成 get、set、toString 等方法
@AllArgsConstructor：生成有参构造方法
@NoArgsConstructor：生成无参构造
@Getter、@Setter：用于产生 get、set 方法
由于是通过命令行来执行，首先右键打开工程所在文件夹
进入到当前工程
mvn 相关的命令必须在 pom.xml 目录下使用，在地址栏输入 cmd 回车
从而直接定位到当前目录
这是由于利用 jenv 进行 JDK 版本管理时，在更换路径后，此路径没有 JDK 版本" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/486363ad64123ae0bac348843eff356b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T14:14:24+08:00" />
<meta property="article:modified_time" content="2024-01-22T14:14:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于 IDEA 进行 Maven 工程构建</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1__0"></a>1. 构建概念和构建过程</h2> 
<p>项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。</p> 
<p>项目构建是软件开发过程中至关重要的一部分，它能够大大提高软件开发效率，使得开发人员能够更加专注于应用程序的开发和维护，而不必关心应用程序的构建细节。</p> 
<p>同时，项目构建还能够将多个开发人员的代码汇合到一起，并能够自动化项目的构建和部署，大大降低了项目的出错风险和提高开发效率。常见的构建工具包括 Maven、Gradle、Ant 等。</p> 
<p><img src="https://images2.imgbox.com/01/d2/ZACp9hrr_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2__11"></a>2. 命令方式项目构建</h2> 
<table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>mvn compile</td><td>编译项目，生成target文件 （java 类编译为字节码文件）</td></tr><tr><td>mvn package</td><td>打包项目，生成jar或war文件</td></tr><tr><td>mvn clean</td><td>清理编译或打包后的项目结构</td></tr><tr><td>mvn install</td><td>打包后上传到maven本地仓库</td></tr><tr><td>mvn deploy</td><td>只打包，上传到maven私服仓库</td></tr><tr><td>mvn site</td><td>生成站点</td></tr><tr><td>mvn test</td><td>执行测试源码</td></tr></tbody></table> 
<h3><a id="21_mvn_compile_25"></a>2.1 mvn compile</h3> 
<p>现在 java 工程中创建一个 User 类<br> <img src="https://images2.imgbox.com/f3/e4/IdGnHWmn_o.png" alt="在这里插入图片描述"></p> 
<p>这里需要有 get、set 、toString 等方法，需要用到 lombok 这个 jar 包，来自动实现这些方法</p> 
<p><strong>访问 jar 包查询网站：</strong> <a href="https://mvnrepository.com/" rel="nofollow">https://mvnrepository.com/</a></p> 
<p>搜索 lombok<br> <img src="https://images2.imgbox.com/1c/53/2HnUkEKu_o.png" alt="在这里插入图片描述"></p> 
<p>选择一个使用较多的版本即可<br> <img src="https://images2.imgbox.com/d6/bd/w9cSCnqi_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d1/28/KmUFJMix_o.png" alt="在这里插入图片描述"></p> 
<p>将依赖放置在当前 java 工程的 pom.xml 中，刷新 maven<br> <img src="https://images2.imgbox.com/d1/20/MA9A8hik_o.png" alt="在这里插入图片描述"></p> 
<p>使用 lombok 的注解</p> 
<p>@data：生成 get、set、toString 等方法<br> <img src="https://images2.imgbox.com/81/d4/cLrJT9j9_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/bb/40/qsKL5kJi_o.png" alt="在这里插入图片描述"></p> 
<p>@AllArgsConstructor：生成有参构造方法<br> <img src="https://images2.imgbox.com/39/b1/8SQ1kChm_o.png" alt="在这里插入图片描述"></p> 
<p>@NoArgsConstructor：生成无参构造<br> <img src="https://images2.imgbox.com/66/30/SKXB6F5m_o.png" alt="在这里插入图片描述"></p> 
<p>@Getter、@Setter：用于产生 get、set 方法</p> 
<p>由于是通过命令行来执行，首先右键打开工程所在文件夹<br> <img src="https://images2.imgbox.com/ae/bf/RzLZ2qM7_o.png" alt="在这里插入图片描述"></p> 
<p>进入到当前工程<br> <img src="https://images2.imgbox.com/d9/1b/jgOyupPn_o.png" alt="在这里插入图片描述"></p> 
<p>mvn 相关的命令必须在 pom.xml 目录下使用，在地址栏输入 cmd 回车</p> 
<p><img src="https://images2.imgbox.com/c9/56/a2RUKjWg_o.png" alt="在这里插入图片描述"></p> 
<p>从而直接定位到当前目录<br> <img src="https://images2.imgbox.com/7d/10/KV7es6nG_o.png" alt="在这里插入图片描述"></p> 
<p>这是由于利用 jenv 进行 JDK 版本管理时，在更换路径后，此路径没有 JDK 版本<br> <img src="https://images2.imgbox.com/5e/5d/8D7Ais80_o.png" alt="在这里插入图片描述"></p> 
<p>因此需要在此路径下添加 JDK 版本：<br> <img src="https://images2.imgbox.com/c4/47/Fn1EyGoJ_o.png" alt="在这里插入图片描述"></p> 
<p>再次执行就成功啦（其中会涉及到 maven 插件的使用，因为构建 maven 实际上就是在使用那些插件，maven-compiler-plugin:3.1:compile）<br> <img src="https://images2.imgbox.com/02/cc/9zUOt0h1_o.png" alt="在这里插入图片描述"></p> 
<p>会看到产生了一个新目录 target，每次构建都会放在 target 目录中<br> <img src="https://images2.imgbox.com/9f/b3/TCwWipPz_o.png" alt="在这里插入图片描述"></p> 
<p>字节码文件以 .class 为后缀<br> <img src="https://images2.imgbox.com/ed/14/1LXDyEsk_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22_mvn_clean_88"></a>2.2 mvn clean</h3> 
<p>将之前编译的结果清理掉</p> 
<p><img src="https://images2.imgbox.com/5e/38/mVgVIoeu_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="23_mvn_test_93"></a>2.3 mvn test</h3> 
<p>先在 maven 工程下面的 test/java 中创建一个 test 类，注意这个测试类的类名一定要以 Test 开头或者 Test 结尾<br> <img src="https://images2.imgbox.com/1f/88/EZ4ispId_o.png" alt="在这里插入图片描述"></p> 
<p>测试需要使用到 junit 这个依赖 jar 包</p> 
<p><strong>同理访问 jar 包查询网站：</strong> <a href="https://mvnrepository.com/" rel="nofollow">https://mvnrepository.com/</a></p> 
<p>搜索 junit ，并选择最多的人的一个版本，添加到 pom.xml 中</p> 
<p><img src="https://images2.imgbox.com/68/4d/jujaJwjw_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d6/91/VJvS9jjs_o.png" alt="在这里插入图片描述"></p> 
<p>通过 mvn test 命令即可执行 test 下的测试类<br> <img src="https://images2.imgbox.com/85/82/INip9oqI_o.png" alt="在这里插入图片描述"></p> 
<p><strong>注：</strong> 可通过 mvn clean test，依次先执行 clean 再执行 test</p> 
<hr> 
<p><strong>测试报告</strong><br> <img src="https://images2.imgbox.com/b2/8b/P6TTv6t5_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/eb/2d/Aklv5B82_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="24_mvn_package_121"></a>2.4 mvn package</h3> 
<p>打成 jar 包</p> 
<p>注意命名是：maven 工程名 - maven 版本<br> <img src="https://images2.imgbox.com/fa/9b/fdr3HI9G_o.png" alt="在这里插入图片描述"></p> 
<p>在执行打包的过程中，会对核心功能和测试功能进行编译，测试不通过会导致打包失败</p> 
<p>注意打包后的文件，是对核心代码进行代码，测试文件是没有打包的，因为测试是发生在打包之前，打包成功，说明测试没有问题。因此打包为 jar 包和 war 包都没有测试文件<br> <img src="https://images2.imgbox.com/3f/04/ikS1oRZh_o.png" alt="在这里插入图片描述"></p> 
<p>下面对 web 工程打包为 war 包</p> 
<p><img src="https://images2.imgbox.com/8b/f1/Ehvyd4lm_o.png" alt="在这里插入图片描述"></p> 
<p>进入到 web 工程的 pom.xml 文件下<br> <img src="https://images2.imgbox.com/ed/84/Ms7Dc9fh_o.png" alt="在这里插入图片描述"></p> 
<p>如果报错，可能是war包打包插件和jdk版本不匹配：pom.xml 添加以下代码即可</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- jdk17 和 war包版本插件不匹配 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>maven-war-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.2.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>打包后文件<br> <img src="https://images2.imgbox.com/50/bd/9YlsAPHO_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="25_mvn_install_161"></a>2.5 mvn install</h3> 
<p>如果想要使用自己的 maven 项目，就需要将其打包为 jar 包，比如在 maven_web 中使用 maven_java 这个工程。</p> 
<p>首先在 maven_jave 工程的 pom.xml 中复制坐标，如下图<br> <img src="https://images2.imgbox.com/19/ab/nxpj7apN_o.png" alt="在这里插入图片描述"></p> 
<p>放入到 maven_web 工程的 pom.xml 的 depenence 标签中<br> <img src="https://images2.imgbox.com/87/89/DDToHcRj_o.png" alt="在这里插入图片描述"></p> 
<p>这个时候 maven_java 作为一个 jar 包依赖，可以被 maven_web 所使用</p> 
<p>下面对 maven_web 进行打包：发现报错了，报错原因是没有找到 maven_java 工程这个依赖<br> <img src="https://images2.imgbox.com/25/2b/BX1et77p_o.png" alt="在这里插入图片描述"></p> 
<p>为什么呢？因为在 pom.xml 中设置都依赖首先会去本地仓库中寻找，没有会去中央仓库中寻找，而我们建立的 maven_java 工程即不在本地也不在中央仓库，因此报错。</p> 
<p>因此，这个时候就要用到 mvn install ，将 jar 和 war 包安装到本地仓库，在 java 工程下，通过执行 mvn install 将这个工程 jar 包添加到本地仓库中。<br> <img src="https://images2.imgbox.com/2e/5e/qqm8VvGd_o.png" alt="在这里插入图片描述"></p> 
<p>这个时候再去 maven_web 进行打包，就可以打包成功啦<br> <img src="https://images2.imgbox.com/ba/f9/XfeJop7w_o.png" alt="在这里插入图片描述"></p> 
<p>因此如果要使用自己的工程，首先需要将其 install 到自己的本地仓库中，否则是找不到的。</p> 
<p>注意：打包（package）和安装（install）的区别是什么</p> 
<p>打包是将工程打成jar或war文件，保存在target目录下</p> 
<p>安装是将当前工程所生成的jar或war文件，安装到本地仓库，会按照坐标保存到指定位置</p> 
<h3><a id="_jar__install__192"></a>上述讲解了 jar 包通过 install 安装到本地仓库，具体安装到哪里呢？</h3> 
<p>先找到 maven_java 工程的坐标，然后一层一层去寻找<br> <img src="https://images2.imgbox.com/a0/1f/plb7Nm8o_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/15/07/rKRXni9i_o.png" alt="在这里插入图片描述"><br> 其所有的本地仓库的 jar 均均是如此，通过 pom.xml 中的坐标去寻找</p> 
<h2><a id="3__200"></a>3. 可视化方式项目构建</h2> 
<p><img src="https://images2.imgbox.com/d2/9c/fX7Rht8H_o.png" alt="在这里插入图片描述"></p> 
<ul><li>Lifecycle：生命周期</li><li>Plugins：插件</li><li>Dependences：工程依赖<br> <img src="https://images2.imgbox.com/6a/f5/9hXmSmL0_o.png" alt="在这里插入图片描述"></li></ul> 
<p>package：java 工程打 jar 包，web 工程打 war 包。</p> 
<p><img src="https://images2.imgbox.com/18/16/NSxkeNos_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4__216"></a>4. 构建插件、命令、生命周期命令之间关系</h2> 
<ul><li> <p><strong>构建生命周期</strong></p> <p>我们发现一个情况！当我们执行package命令也会自动执行compile命令！</p> <pre><code class="prism language-xml">[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ mybatis-base-curd ---
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ mybatis-base-curd ---
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ mybatis-base-curd ---
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ mybatis-base-curd ---
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ mybatis-base-curd ---
[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ mybatis-base-curd ---
[INFO] Building jar: D:\javaprojects\backend-engineering\part03-mybatis\mybatis-base-curd\target\mybatis-base-curd-1.0-SNAPSHOT.jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  5.013 s
[INFO] Finished at: 2023-06-05T10:03:47+08:00
[INFO] ------------------------------------------------------------------------
</code></pre> <p>这种行为就是因为构建生命周期产生的！构建生命周期可以理解成是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！！！</p> <p><strong>构建周期作用：会简化构建过程</strong></p> <p>例如：项目打包 mvn clean package即可。 </p> <p>主要两个构建生命周期：</p> 
  <ul><li> <p>清理周期：主要是对项目编译生成文件进行清理</p> <p>包含命令：clean </p> </li></ul> </li><li> <p>默认周期：定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分</p> <pre><code>包含命令：compile -  test - package - install - deploy
</code></pre> </li><li> <p><strong>插件、命令、周期三者关系（了解）</strong></p> <p>周期→包含若干命令→包含若干插件</p> <p>使用周期命令构建，简化构建过程！</p> <p>最终进行构建的是插件！</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/da4ce81ccdc3d1e8207b89d8e58d5252/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【算法系列】一文彻底讲懂隐马尔可夫模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e22ea8f8170443e02cce9b5cd4eead66/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024-01-19（SpringCloud&amp;ThreadLocal）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>