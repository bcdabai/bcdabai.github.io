<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43; 中的回调函数 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43; 中的回调函数" />
<meta property="og:description" content="看了 https://www.bilibili.com/video/av39240401?t=4023 以后记录了一下
//1 回调函数是一种讲双向依赖改为单向依赖的好方法 //2 常见回调函数：pthread //3 函数指针 //4 回调函数：回调函数是一种在定义的模块不运行，交给另一个模块运行的函数 //回调函数的应用：尤其在调用的对象是一个黑盒子，通常是别的公司打包好的某个库，你编程时想要改变库里的某些默认行为，这是用回调函数是最好的 //5 回调函数的适用条件： //模块之间互相独立，存在相互调用关系 //两个模块处在不同的层次，为了确保单向依赖（单项调用），通常在下层设置函数指针，在上层设置回调函数。 1 常见的回调函数 //常见的回调函数 #include &lt;iostream&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; //回调函数 void* cb(void *arg) { std::cout&lt;&lt;&#34;call back running&#34;&lt;&lt;pthread_self()&lt;&lt;std::endl; return NULL; } int main() { pthread_t tid; pthread_create(&amp;tid, NULL, cb, NULL); //将cb 做参数传进去 pthread_join(tid, NULL); pthread_t tid2; pthread_create(&amp;tid2, NULL, cb, NULL); pthread_join(tid, NULL); } 2 函数指针 //函数指针 #include &lt;stdio.h&gt; void fun1(void) { printf(&#34;fun1\n&#34;); } void fun2(void) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/602761b0aafe255eb58658d6e31d6bab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-10T10:41:16+08:00" />
<meta property="article:modified_time" content="2019-12-10T10:41:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43; 中的回调函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>看了 https://www.bilibili.com/video/av39240401?t=4023 以后记录了一下</p> 
<pre><code>//1 回调函数是一种讲双向依赖改为单向依赖的好方法

//2 常见回调函数：pthread

//3 函数指针

//4 回调函数：回调函数是一种在定义的模块不运行，交给另一个模块运行的函数
//回调函数的应用：尤其在调用的对象是一个黑盒子，通常是别的公司打包好的某个库，你编程时想要改变库里的某些默认行为，这是用回调函数是最好的

//5 回调函数的适用条件：
//模块之间互相独立，存在相互调用关系
//两个模块处在不同的层次，为了确保单向依赖（单项调用），通常在下层设置函数指针，在上层设置回调函数。
</code></pre> 
<h2><a id="1__17"></a>1 常见的回调函数</h2> 
<pre><code>//常见的回调函数
#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

//回调函数
void* cb(void *arg)
{
    std::cout&lt;&lt;"call back running"&lt;&lt;pthread_self()&lt;&lt;std::endl;
    return NULL;
}

int main()
{
    pthread_t tid;
    pthread_create(&amp;tid, NULL, cb, NULL);   //将cb 做参数传进去
    pthread_join(tid, NULL);

    pthread_t tid2;
    pthread_create(&amp;tid2, NULL, cb, NULL);
    pthread_join(tid, NULL);
}
</code></pre> 
<h2><a id="2__44"></a>2 函数指针</h2> 
<pre><code>//函数指针

#include &lt;stdio.h&gt;

void fun1(void)
{
    printf("fun1\n");
}

void fun2(void)
{
    printf("fun2\n");
}

int main(void)
{
    void (*p)(void);//函数指针，只能指向无参无返回值的函数
    void (*p1)(int,int);//另一个函数指针，能够指向两个整型参数无返回值的函数
    char (*p2)(int);//函数指针，指向有一个整形参数，一个返回值的函数

    void *(*p3)(int *);
    //只能指向这样的函数
    //void *fun(int *a)


    //函数指针赋值，必须要格式（函数头）相同
    p = fun1;//让p这个指针指向fun1的整个函数

    //函数实际上就是一个代码块，这个代码块执行到最后会返回

    p();//函数指针的运行（简写的运行方法），实际就是它指向的函数对象的运行
    (*p)();//原始的运行方法

    p = fun2;//修改p的指向
    p();//运行p指向的对象

}
</code></pre> 
<h2><a id="3__86"></a>3 回调函数的应用</h2> 
<h6><a id="maincpp_87"></a>main.cpp:</h6> 
<pre><code>#include &lt;stdio.h&gt;
#include "run.h"

int mystep_cb(int i)
{
    printf("记秒到时,i=%d\n",i);
    return 2018;
}

int main(void)
{
    cb_install(mystep_cb);

    run();

}
</code></pre> 
<h6><a id="runh_108"></a>run.h:</h6> 
<pre><code>#include &lt;unistd.h&gt;
#include &lt;iostream&gt;

//希望在run的循环里，每隔1秒运行一个函数，这个函数由main来指定（函数放在main.cpp里面）
//void (*step)(void)=NULL;//定义一个函数指针，在循环里运行

//void (*step)(int)=NULL;

int (*step)(int)=NULL;

//无限运行的函数，每秒ct自增1,
void run(void)
{
    int ct = 0;
    while(1)
    {
        if(step!=NULL)//有赋值才运行，否则不运行
        {
            int r = step(ct);
            std::cout&lt;&lt;"r = "&lt;&lt;r&lt;&lt;std::endl;
        }
        else
            std::cout&lt;&lt;"the pointer step is NULL"&lt;&lt;std::endl;
        ct++;
        sleep(1);
    }
}

void cb_install(int (*p)(int))
{
    step = p;
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/227c69b0da3742c49a6e2ab5b888f5f8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Apache Impala 基本介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3bdd9c7c30f2ec922fa0b512b2c085a4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue 鼠标移入移出事件（移入出现按钮），element-ui表格移入移出</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>