<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式的六大原则 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式的六大原则" />
<meta property="og:description" content="一、&#34;开放－封闭&#34;原则(OCP) Open-Closed Principle原则讲的是：一个软件实体应当对扩展开放，对修改关闭
二、 里氏代换原则（LSP） Liskov Substitution Principle（里氏代换原则）：子类型(subtype)必须能够替换它们的基类型。
三、 依赖倒置原则(DIP) 依赖倒置（Dependence Inversion Principle）原则讲的是：要依赖于抽象，不要依赖于具体。
抽象不应当依赖于细节；细节应当依赖于抽象；要针对接口编程，不针对实现编程。
四、 接口隔离原则（ISP） 接口隔离原则（Interface Segregation Principle）讲的是：使用多个专门的接口比使用单一的总接口总要好。换而言之，从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小接口上的。
实现方法：
1、 使用委托分离接口
2、 使用多重继承分离接口
五、 合成/聚合复用原则（CARP） 合成/聚合复用原则（Composite/Aggregate Reuse Principle或CARP）经常又叫做合成复用原则（Composite Reuse Principle或CRP），就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新对象通过向这些对象的委派达到复用已有功能的目的。
简而言之，要尽量使用合成/聚合，尽量不要使用继承。
区分&#34;Has-A&#34;与&#34;Is-A&#34;
&#34;Is-A&#34;是严格的分类学意义上定义，意思是一个类是另一个类的&#34;一种&#34;。而&#34;Has-A&#34;则不同，它表示某一个角色具有某一项责任。
六、 迪米特法则（LoD） 迪米特法则（Law of Demeter或简写LoD）又叫最少知识原则（Least Knowledge Principle或简写为LKP），也就是说，一个对象应当对其它对象有尽可能少的了解。
迪米特法则与设计模式
Facade模式、Mediator模式
创建型模式种类 • Singleton单例模式，保证一个类仅有一个实例
• Factory Method工厂方法模式，定义一个创建对象的接口，并控制用哪一个类进行实例化
• Abstract Factory–抽象工厂模式，创建一系列相关或相互依赖的对象
• Prototype–原型模式，通过拷贝现有对象来生成新对象（克隆方法）
• Builder–生成器模式，将构造对象实例的代码逻辑移到类的外部
结构型模式 • 结构型模式涉及到如何组合类或对象，以获得更大的结构
• 结构型类模式采用继承机制来组合接口或实现
• 结构型对象模式描述了如何对一些对象进行组合，从而实现新功能的一些方法
Adapter适配器模式，将一个类的接口转换成客户希望的另外一个接口，使得原本由于
接口不兼容而不能一起工作的那些类可以一起工作适配器（Adapter）模式
•桥梁（Bridge）模式，将抽象部分与它的实现部分分离，使它们都可以独立地变化
• Composite组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性合成（Composite）模式
• Decorator 装饰模式，动态地给一个对象添加一些额外的职责装饰（Decorator）模式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ed0f07c5218f235fa1bacc9a6bc02bcf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-21T10:55:37+08:00" />
<meta property="article:modified_time" content="2018-08-21T10:55:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式的六大原则</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 style="margin-left:0pt;">一、"开放－封闭"原则(OCP)</h4> 
<p style="margin-left:0pt;">Open-Closed Principle原则讲的是：一个软件实体应当对扩展开放，对修改关闭</p> 
<h4 style="margin-left:0pt;"><a name="_Toc97607157"></a>二、 里氏代换原则（LSP）</h4> 
<p style="margin-left:0pt;">Liskov Substitution Principle（里氏代换原则）：子类型(subtype)必须能够替换它们的基类型。</p> 
<h4 style="margin-left:0pt;"><a name="_Toc97607159"></a>三、 依赖倒置原则(DIP) </h4> 
<p style="margin-left:0pt;">依赖倒置（Dependence Inversion Principle）原则讲的是：要依赖于抽象，不要依赖于具体。</p> 
<p style="margin-left:0pt;">抽象不应当依赖于细节；细节应当依赖于抽象；要针对接口编程，不针对实现编程。</p> 
<h4 style="margin-left:0pt;"><a name="_Toc97607160"></a>四、 接口隔离原则（ISP）</h4> 
<p style="margin-left:0pt;">接口隔离原则（Interface Segregation Principle）讲的是：使用多个专门的接口比使用单一的总接口总要好。换而言之，从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小接口上的。</p> 
<p style="margin-left:0pt;">实现方法：<br> 1、 使用委托分离接口<br> 2、 使用多重继承分离接口</p> 
<h4 style="margin-left:0pt;"><a name="_Toc97607161"></a>五、 合成/聚合复用原则（CARP）</h4> 
<p style="margin-left:0pt;">合成/聚合复用原则（Composite/Aggregate Reuse Principle或CARP）经常又叫做合成复用原则（Composite Reuse Principle或CRP），就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新对象通过向这些对象的委派达到复用已有功能的目的。</p> 
<p style="margin-left:0pt;">简而言之，要尽量使用合成/聚合，尽量不要使用继承。</p> 
<p style="margin-left:0pt;">区分"Has-A"与"Is-A"</p> 
<p style="margin-left:0pt;">"Is-A"是严格的分类学意义上定义，意思是一个类是另一个类的"一种"。而"Has-A"则不同，它表示某一个角色具有某一项责任。</p> 
<h4 style="margin-left:0pt;"><a name="_Toc97607162"></a>六、 迪米特法则（LoD）</h4> 
<p style="margin-left:0pt;">迪米特法则（Law of Demeter或简写LoD）又叫最少知识原则（Least Knowledge Principle或简写为LKP），也就是说，一个对象应当对其它对象有尽可能少的了解。</p> 
<p style="margin-left:0pt;">迪米特法则与设计模式<br> Facade模式、Mediator模式</p> 
<h4><strong><strong><strong>创建型模式种类</strong></strong></strong></h4> 
<p style="margin-left:0pt;">• Singleton单例模式，保证一个类仅有一个实例</p> 
<p style="margin-left:0pt;">• <a name="_Hlk257363244">Factory Method</a>工厂方法模式，定义一个创建对象的接口，并控制用哪一个类进行实例化</p> 
<p style="margin-left:0pt;">• Abstract Factory–抽象工厂模式，创建一系列相关或相互依赖的对象</p> 
<p style="margin-left:0pt;">• Prototype–原型模式，通过拷贝现有对象来生成新对象（克隆方法）</p> 
<p style="margin-left:0pt;">• Builder–生成器模式，将构造对象实例的代码逻辑移到类的外部</p> 
<h4><strong><strong><strong>结构型模式</strong></strong></strong></h4> 
<p style="margin-left:0pt;">• 结构型模式涉及到如何组合类或对象，以获得更大的结构</p> 
<p style="margin-left:0pt;">• 结构型类模式采用继承机制来组合接口或实现</p> 
<p style="margin-left:0pt;">• 结构型对象模式描述了如何对一些对象进行组合，从而实现新功能的一些方法</p> 
<p style="margin-left:0pt;">Adapter适配器模式，将一个类的接口转换成客户希望的另外一个接口，使得原本由于</p> 
<p style="margin-left:0pt;">接口不兼容而不能一起工作的那些类可以一起工作<a href="#_Hlk257378718" rel="nofollow"><strong><u><span style="color:#0000ff;"><strong><u>适配器（Adapter）模式</u></strong></span></u></strong></a></p> 
<p style="margin-left:0pt;">•<a href="#_Hlk257383997" rel="nofollow"><strong><u><span style="color:#0000ff;"><strong><u>桥梁（Bridge）模式</u></strong></span></u></strong></a>，将抽象部分与它的实现部分分离，使它们都可以独立地变化</p> 
<p style="margin-left:0pt;">• Composite组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性<a href="#_Hlk257384073" rel="nofollow"><strong><u><span style="color:#0000ff;"><strong><u>合成（Composite）模式</u></strong></span></u></strong></a></p> 
<p style="margin-left:0pt;">• Decorator 装饰模式，动态地给一个对象添加一些额外的职责<a href="#_Hlk257381643" rel="nofollow"><strong><u><span style="color:#0000ff;"><strong><u>装饰（Decorator）模式</u></strong></span></u></strong></a></p> 
<p style="margin-left:0pt;">• Facade 外观模式，为子系统中的一组接口提供一个一致的界面，使得这一子系统更加容易使用</p> 
<p style="margin-left:0pt;">• Flyweight 享元模式，运用共享技术有效地支持大量细粒度的对象<a href="#_Hlk257382316" rel="nofollow"><strong><u><span style="color:#0000ff;"><strong><u>享元（Flyweight）模式</u></strong></span></u></strong></a></p> 
<p style="margin-left:0pt;">• Proxy代理模式，为其他对象提供一种代理以控制对这个对象的访问<a href="#_Hlk257382275" rel="nofollow"><strong><u><span style="color:#0000ff;"><strong><u>代理（Proxy）模式</u></strong></span></u></strong></a></p> 
<h4><strong><strong><strong>行为型模式</strong></strong></strong></h4> 
<p style="margin-left:0pt;">• 行为型模式涉及到算法和对象间职责的分配</p> 
<p style="margin-left:0pt;">• 行为型模式不仅描述对象或类的模式，还描述它们之间的通信模式，将注意力转移到对象间的联系方式上来</p> 
<p style="margin-left:0pt;">行为型模式种类</p> 
<p style="margin-left:0pt;">• Chain of responsibility– 职责链模式，使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系<a href="#_Hlk257384332" rel="nofollow"><strong><u><span style="color:#0000ff;"><strong><u>职责链（Chain of Responsibility）模式</u></strong></span></u></strong></a></p> 
<p style="margin-left:0pt;">• <a href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F" rel="nofollow"><strong><u><span style="color:#0000ff;"><strong><u>Command</u></strong></span></u></strong><strong><u><span style="color:#0000ff;"><strong><u>–</u></strong></span></u></strong><strong><u> </u></strong><strong><u><span style="color:#0000ff;"><strong><u>命令模式</u></strong></span></u></strong></a>，将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作</p> 
<p style="margin-left:0pt;">• Interpreter 解释器模式，给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子</p> 
<p style="margin-left:0pt;">• Iterator迭代器模式，提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示</p> 
<p style="margin-left:0pt;">• Mediator中介者模式，用一个中介对象来封装一系列的对象交互</p> 
<p style="margin-left:0pt;">• Memento 备忘录模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</p> 
<p style="margin-left:0pt;">• Observer观察者模式，定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新(事件)</p> 
<p style="margin-left:0pt;">• State状态模式，允许一个对象在其内部状态改变时改变它的行为</p> 
<p style="margin-left:0pt;">• Strategy– 策略模式，定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换</p> 
<p style="margin-left:0pt;">• TemplateMethod 模板方法模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中（使用继承，把公共的方法放到基类就属于模板）</p> 
<p style="margin-left:0pt;">• Visitor访问者模式，表示一个作用于某对象结构中的各元素的操作</p> 
<p style="margin-left:0pt;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8fb661e5250a6807a5e1530de69e9cc6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">1031. 等腰三角形</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a67bc6444c2b850a34b674cc21fe6f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HCNA认证课程—VRP基础操作总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>