<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JS继承以及class类继承 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JS继承以及class类继承" />
<meta property="og:description" content="继承的概念： 在原有的基础之上我们要进行继承，可以直接从父方法或者父类中的属性和方法，达到不用重复定义即可直接使用，就是代码的复用
ES5继承的方式有哪些？ 原型链继承：将父方法的实例化对象赋给子方法的原型，子方法既可调用父方法自身的属性和方法，还可以使用父方法原型中的属性和方法，不足地地方就是无法传递参数。
function Nation() { this.name = &#39;张飞&#39; this.age = &#39;男&#39; } Nation.prototype.skills = &#39;当阳桥喝退百万师&#39; Nation.prototype.poem = function() { console.log(&#39;子承父之志&#39;); } function Address() { this.name = &#39;张星彩&#39; this.age = &#39;女&#39; } Address.prototype = new Nation() let address = new Address() console.log(address); console.log(address.name, address.age, address.skills); address.poem(); 构造函数继承 定义一个父函数和子函数，子函数通过call方法或者allpy改变指向从而实现继承效果，
父方法.call(this,参数列表)，缺点是不能使用父方法原型中的属性，可以传递参数
function Car(brand, color) { this.brand = brand this.color = color } Car.prototype.skills = &#39;直线之王&#39; function Knsg() { this.speed = &#39;每小时500公里&#39; Car." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/91305035643e65211f7e0a7b50a272b3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-04T21:35:01+08:00" />
<meta property="article:modified_time" content="2022-05-04T21:35:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JS继承以及class类继承</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>继承的概念：</h3> 
<p>        在原有的基础之上我们要进行继承，可以直接从父方法或者父类中的属性和方法，达到不用重复定义即可直接使用，就是代码的复用</p> 
<h3>ES5继承的方式有哪些？</h3> 
<p>        原型链继承：将父方法的实例化对象赋给子方法的原型，子方法既可调用父方法自身的属性和方法，还可以使用父方法原型中的属性和方法，不足地地方就是无法传递参数。</p> 
<p></p> 
<pre><code class="language-javascript">function Nation() {
    this.name = '张飞'
    this.age = '男'
}
Nation.prototype.skills = '当阳桥喝退百万师'
Nation.prototype.poem = function() {
    console.log('子承父之志');
}
function Address() {
    this.name = '张星彩'
    this.age = '女'
}
Address.prototype = new Nation()
let address = new Address()
console.log(address);
console.log(address.name, address.age, address.skills);
address.poem();</code></pre> 
<h3>构造函数继承</h3> 
<p>        定义一个父函数和子函数，子函数通过call方法或者allpy改变指向从而实现继承效果，</p> 
<p>父方法.call(this,参数列表)，缺点是不能使用父方法原型中的属性，可以传递参数</p> 
<pre><code class="language-javascript">function Car(brand, color) {
    this.brand = brand
    this.color = color
}
Car.prototype.skills = '直线之王'

function Knsg() {
    this.speed = '每小时500公里'
    Car.call(this, 'jesko', 'red')
}
let knsg = new Knsg()
console.log(knsg);</code></pre> 
<h3>Class类及Class继承：</h3> 
<p>        ES6提供了更新传统的语言写法，引入Class类，作为对象的模板，ES6中的class可以当作是一个语法糖，它的大部分功能，ES5都可以做到，新的class写法让对象原型的写法更加清晰</p> 
<pre><code class="language-javascript">class Jukuzhou {
    constructor(name, age, address) {
        this.name = name
        this.age = age
        this.address = address
    }
    skills() {
        console.log('十八般武艺和十八般武器');
    }
}
let ydj = new Jukuzhou('妖刀姬', '女', '森罗谷')
console.log(ydj);
let jch = new Jukuzhou('季沧海', '男', '不舟滩')
console.log(jch);
let gqh = new Jukuzhou('顾清寒', '女', '天人城')
console.log(gqh);</code></pre> 
<h3>class的继承：</h3> 
<p>        还可以使用extends关键字实现，super()父类的方法</p> 
<pre><code class="language-javascript">class Animal {
    constructor(name) {
            this.name = name // 指定名字
    }
    main() {
        console.log(`${this.name}练习两年半`);
    }
}
class Chicken extends Animal {
    static num = 1;
    constructor(name) {
        super(name)
        this.overalls = '背带裤'
        this.love = '唱跳rap篮球'
    }
    skills() {
        console.log(`${this.name}会唱跳rap篮球`);
    }
}
let chicken = new Chicken('鸡哥')
console.log(chicken);
chicken.main()
chicken.skills()</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/75c661299e47612009b9cfb155c332ee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构与算法：快速幂——求幂运算 O(logN)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f90c353276a4c0d309867587c2a50cf1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用华为模拟器ENSP写一个完整的校园网（第一节）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>