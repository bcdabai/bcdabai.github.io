<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（！详解 Pytorch实战：①）kaggle猫狗数据集二分类：加载（集成/自定义）数据集 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（！详解 Pytorch实战：①）kaggle猫狗数据集二分类：加载（集成/自定义）数据集" />
<meta property="og:description" content="这系列的文章是我对Pytorch入门之后的一个总结，特别是对数据集生成加载这一块加强学习
另外，这里有一些比较常用的数据集，大家可以进行下载：
需要注意的是，本篇文章使用的PyTorch的版本是v0.10.0
《深度学习常用的数据集，包括各种数据跟图像数据》
《kaggle猫狗大战[包含训练(25000张猫狗照片)和测试数据集(12500张猫狗照片)》
目录
一、加载已被集成在Pytorch中的数据集 1、torchvision和torchvision.datasets：数据集
2、torchvision.transforms和torchvision.transforms.Compose：图像预处理
torchvision.transforms.ToTensor（）
torchvision.transforms.Normalize(mean, std, inplace=False) 3、torch.utils.data.DataLoader和torch.utils.data.Dataset
torch.utils.data.DataLoader
torch.utils.data.Dataset
二、加载自定义数据集
1、torchvision.datasets.DatasetFolder
2、torchvision.datasets.ImageFolder
三、加载本地kaggle猫狗数据集
一、加载已被集成在Pytorch中的数据集 在这第一大块的内容中，可以了解到几个函数：
torchvision和torchvision.datasets
torchvision.transforms和torchvision.transforms.Compose
torch.utils.data.DataLoader / DataLoaderIter和torch.utils.data.Dataset
1、torchvision和torchvision.datasets：数据集 《PyTorch如何加载数据集（自定义数据集）》这篇博客通过代码展示了Pytorch加载数据集的两种方法，对于已被集成在Pytoch内的数据集：比如CIFAR-10，CIFAR-100，MNIST等等，此类数据集可以直接使用Pytorch的内置函数（torchvision.datasets.XXX来直接加载）
Pytorch中官方文档对torchvision的解释：torchvision — Torchvision 0.10.0 documentation (pytorch.org)
这个Pytorch中的一个库，torchvision包包含了一些比较流行的数据集（datasets）、模型架构（model architectures）和用于计算机视觉常见的图像转换（image transformations for computer vision）
另外这里还有一些比较常见的库，例如：
torchtext：包含数据处理的实用工具和自然语言处理方面的的流行数据集torchaudio：包含一些音频I/O，音频方面的转化和流行的数据集…… Pytorch中官方文档对torchvision.datasets的解释：torchvision.datasets — Torchvision 0.10.0 documentation (pytorch.org)
所有的数据集都是torch.utils.data.Dataset的子类，就是说这些数据集已经实现了__getitem__（）“返回索引”和__len__“返回长度”的方法。因此它们都可以传递给torch.utils.data.Dataset，它可以使用torch.multiprocessing并行加载多个样本
比如：
imagenet_data = torchvision.datasets.ImageNet(&#39;path/to/imagenet_root/&#39;) # 图片集的路径 data_loader = torch.utils.data.DataLoader(imagenet_data, batch_size=4, shuffle=True, num_workers=args.nThreads) 所有的数据集都使用相同的API，同时都用两个常见的参数transform和target_transforms去将输入（X）和标签（Y）分别进行张量转换
不过你也可以使用base classes创造自己的数据集
回到这里来……
对于加载已被集成在Pytoch内的数据集，我们以CIFAR为例（通过下面程序进行加载 torchvision.datasets.CIFAR10）：
对于其中参数如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/eda58d4cf8f90f5d94b00590ee1f7d32/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-24T21:56:33+08:00" />
<meta property="article:modified_time" content="2021-08-24T21:56:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（！详解 Pytorch实战：①）kaggle猫狗数据集二分类：加载（集成/自定义）数据集</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>这系列的文章是我对Pytorch入门之后的一个总结，特别是对数据集生成加载这一块加强学习</strong></p> 
 <p><strong>另外，这里有一些比较常用的数据集，大家可以进行下载：</strong></p> 
 <p><strong>需要注意的是，本篇文章使用的PyTorch的版本是v0.10.0</strong></p> 
 <p><strong><a href="https://blog.csdn.net/yangdashi888/article/details/70503874">《深度学习常用的数据集，包括各种数据跟图像数据》</a></strong></p> 
 <p><strong><a href="https://blog.csdn.net/qq_42583263/article/details/103642492">《kaggle猫狗大战[包含训练(25000张猫狗照片)和测试数据集(12500张猫狗照片)》</a></strong></p> 
</blockquote> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%8A%A0%E8%BD%BD%E5%B7%B2%E8%A2%AB%E9%9B%86%E6%88%90%E5%9C%A8Pytorch%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%8A%A0%E8%BD%BD%E5%B7%B2%E8%A2%AB%E9%9B%86%E6%88%90%E5%9C%A8Pytorch%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%C2%A0" rel="nofollow">一、加载已被集成在Pytorch中的数据集 </a></p> 
<p id="1%E3%80%81torchvision%E5%92%8Ctorchvision.datasets%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%9B%86-toc" style="margin-left:40px;"><a href="#1%E3%80%81torchvision%E5%92%8Ctorchvision.datasets%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%9B%86" rel="nofollow">1、torchvision和torchvision.datasets：数据集</a></p> 
<p id="2%E3%80%81torchvision.transforms%E5%92%8Ctorchvision.transforms.Compose%EF%BC%9A%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86-toc" style="margin-left:40px;"><a href="#2%E3%80%81torchvision.transforms%E5%92%8Ctorchvision.transforms.Compose%EF%BC%9A%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86" rel="nofollow">2、torchvision.transforms和torchvision.transforms.Compose：图像预处理</a></p> 
<p id="torchvision.transforms.ToTensor%EF%BC%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#torchvision.transforms.ToTensor%EF%BC%88%EF%BC%89" rel="nofollow">torchvision.transforms.ToTensor（）</a></p> 
<p id="torchvision.transforms.Normalize(mean%2C%C2%A0std%2C%C2%A0inplace%3DFalse)%C2%A0-toc" style="margin-left:80px;"><a href="#torchvision.transforms.Normalize%28mean%2C%C2%A0std%2C%C2%A0inplace%3DFalse%29%C2%A0" rel="nofollow">torchvision.transforms.Normalize(mean, std, inplace=False) </a></p> 
<p id="3%E3%80%81torch.utils.data.DataLoader%E5%92%8Ctorch.utils.data.Dataset-toc" style="margin-left:40px;"><a href="#3%E3%80%81torch.utils.data.DataLoader%E5%92%8Ctorch.utils.data.Dataset" rel="nofollow">3、torch.utils.data.DataLoader和torch.utils.data.Dataset</a></p> 
<p id="torch.utils.data.DataLoader-toc" style="margin-left:80px;"><a href="#torch.utils.data.DataLoader" rel="nofollow">torch.utils.data.DataLoader</a></p> 
<p id="torch.utils.data.Dataset-toc" style="margin-left:80px;"><a href="#torch.utils.data.Dataset" rel="nofollow">torch.utils.data.Dataset</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%8A%A0%E8%BD%BD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E9%9B%86-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%8A%A0%E8%BD%BD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E9%9B%86" rel="nofollow">二、加载自定义数据集</a></p> 
<p id="1%E3%80%81torchvision.datasets.DatasetFolder-toc" style="margin-left:40px;"><a href="#1%E3%80%81torchvision.datasets.DatasetFolder" rel="nofollow">1、torchvision.datasets.DatasetFolder</a></p> 
<p id="2%E3%80%81torchvision.datasets.ImageFolder-toc" style="margin-left:40px;"><a href="#2%E3%80%81torchvision.datasets.ImageFolder" rel="nofollow">2、torchvision.datasets.ImageFolder</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%8A%A0%E8%BD%BD%E6%9C%AC%E5%9C%B0kaggle%E7%8C%AB%E7%8B%97%E6%95%B0%E6%8D%AE%E9%9B%86-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%8A%A0%E8%BD%BD%E6%9C%AC%E5%9C%B0kaggle%E7%8C%AB%E7%8B%97%E6%95%B0%E6%8D%AE%E9%9B%86" rel="nofollow">三、加载本地kaggle猫狗数据集</a></p> 
<hr id="hr-toc"> 
<h2 id="%E4%B8%80%E3%80%81%E5%8A%A0%E8%BD%BD%E5%B7%B2%E8%A2%AB%E9%9B%86%E6%88%90%E5%9C%A8Pytorch%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%C2%A0">一、加载已被集成在Pytorch中的数据集 </h2> 
<blockquote> 
 <p><strong>在这第一大块的内容中，可以了解到几个函数：</strong></p> 
 <p><strong>torchvision和torchvision.datasets</strong></p> 
 <p><strong>torchvision.transforms和torchvision.transforms.Compose</strong></p> 
 <p><strong>torch.utils.data.DataLoader / DataLoaderIter</strong><strong>和<code>torch.utils.data.Dataset</code></strong></p> 
</blockquote> 
<h3 id="1%E3%80%81torchvision%E5%92%8Ctorchvision.datasets%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%9B%86">1、torchvision和torchvision.datasets：数据集</h3> 
<p id="articleContentId"><strong><a href="https://blog.csdn.net/a1819797401/article/details/98872840">《PyTorch如何加载数据集（自定义数据集）》</a>这篇博客通过代码展示了Pytorch加载数据集的两种方法，对于已被集成在Pytoch内的数据集：比如CIFAR-10，CIFAR-100，MNIST等等，此类数据集可以直接使用Pytorch的内置函数（torchvision.datasets.XXX来直接加载）</strong></p> 
<blockquote> 
 <p><strong>Pytorch中官方文档对torchvision的解释：</strong><a href="https://pytorch.org/vision/stable/index.html" rel="nofollow">torchvision — Torchvision 0.10.0 documentation (pytorch.org)</a></p> 
 <p><strong>这个Pytorch中的一个库，torchvision包包含了一些比较流行的数据集（datasets）、模型架构（model architectures）和用于计算机视觉常见的图像转换（image transformations for computer vision）</strong></p> 
 <p><strong>另外这里还有一些比较常见的库，例如：</strong></p> 
 <ul><li>torchtext：包含数据处理的实用工具和自然语言处理方面的的流行数据集</li><li>torchaudio：包含一些音频I/O，音频方面的转化和流行的数据集</li><li>……</li></ul> 
 <p><strong>Pytorch中官方文档对torchvision.datasets的解释：</strong><a href="https://pytorch.org/vision/stable/datasets.html" rel="nofollow">torchvision.datasets — Torchvision 0.10.0 documentation (pytorch.org)</a></p> 
 <p><strong>所有的数据集都是torch.utils.data.Dataset的子类，就是说这些数据集已经实现了__getitem__（）“返回索引”和__len__“返回长度”的方法。因此它们都可以传递给torch.utils.data.Dataset，它可以使用torch.multiprocessing并行加载多个样本</strong></p> 
 <p><strong>比如：</strong></p> 
 <pre><code class="language-python">imagenet_data = torchvision.datasets.ImageNet('path/to/imagenet_root/')  # 图片集的路径
data_loader = torch.utils.data.DataLoader(imagenet_data,
                                          batch_size=4,
                                          shuffle=True,
                                          num_workers=args.nThreads)</code></pre> 
 <p><strong>所有的数据集都使用相同的API，同时都用两个常见的参数transform和target_transforms去将输入（X）和标签（Y）分别进行张量转换</strong></p> 
 <p><strong>不过你也可以使用<a href="https://pytorch.org/vision/stable/datasets.html#base-classes-datasets" rel="nofollow">base classes</a>创造自己的数据集</strong></p> 
</blockquote> 
<p><strong>回到这里来……</strong></p> 
<p><strong>对于加载已被集成在Pytoch内的数据集，我们以CIFAR为例（通过下面程序进行加载          <code>torchvision.datasets.CIFAR10</code>）：</strong></p> 
<p><img alt="" height="72" src="https://images2.imgbox.com/f9/d1/CrMpQsa4_o.png" width="654"></p> 
<p><strong> 对于其中参数如下：</strong></p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/c9/08/4gz4SbCo_o.png" width="666"></p> 
<p><strong>那么，<code>torchvision.datasets.CIFAR10 </code>加载数据集之后，返回的是什么呢？</strong> </p> 
<p> <img alt="" height="258" src="https://images2.imgbox.com/f4/f4/JeLT0IFw_o.png" width="637"></p> 
<p> 这里的关于这条函数的源文件：<strong><a href="https://pytorch.org/vision/stable/_modules/torchvision/datasets/cifar.html#CIFAR10" rel="nofollow">SOURCE CODE FOR TORCHVISION.DATASETS.CIFAR</a></strong></p> 
<p><strong>因此，加载内置数据集的例程如下：</strong></p> 
<pre><code class="language-python">transform_train = transforms.Compose([
    #transforms.ToPILImage(),
    transforms.RandomCrop(32, padding=4),
    transforms.RandomHorizontalFlip(),
    transforms.RandomRotation(15),
    transforms.ToTensor(),
    transforms.Normalize(mean, std)
])

cifar10_training = torchvision.datasets.CIFAR100(root='./data', 
                                                  train=True,
												  download=True, 
                                                  transform=transform_train)

cifar10_training_loader = DataLoader(cifar100_training, 
                                      shuffle=shuffle, 
                                      num_workers=num_workers, 
                                      batch_size=batch_size)
</code></pre> 
<p> <strong>接下来看看transforms的具体用法</strong></p> 
<h3 id="2%E3%80%81torchvision.transforms%E5%92%8Ctorchvision.transforms.Compose%EF%BC%9A%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86">2、<strong>torchvision.</strong>transforms和<strong>torchvision.</strong>transforms.Compose：图像预处理</h3> 
<blockquote> 
 <p><strong>Pytorch中官方文档对torchvision.transforms的解释：</strong><a href="https://pytorch.org/vision/stable/transforms.html#torchvision-transforms" rel="nofollow">torchvision.transforms — Torchvision 0.10.0 documentation (pytorch.org)</a></p> 
 <p><img alt="" height="172" src="https://images2.imgbox.com/bb/0d/8uUSWKh2_o.png" width="178"></p> 
 <p> <strong>transforms其实也是torchvision当中作为图像转换的一个包，图像可以通过函数compose连接在一起。大多的图像转换都是可以同时接收PIL图像和张量图像的，也可以单独接收PIL图像或者张量图像的。</strong></p> 
 <p><strong>torchvision.transforms:常用的数据预处理方法，提升泛化能力，包括：数据中心化、数据标准化、缩放、裁剪、旋转、翻转、填充、噪声添加、灰度变换、线性变换、仿射变换、亮度、饱和度及对比度变换等。数据增强又称为数据增广，数据扩增，它是对训练集进行变换，使训练集更丰富，从而让模型更具泛化能力。</strong></p> 
 <p><strong>不仅如此，除了接收单独的图像之外也可以接收处理成批量的图片，也就是我们在神经网络中经常遇到的batch。一张张量图像的大小表示为（C,H,W）---&gt;（channel， height， wight），但是a batch of 张量图像则表示为（B,C,H,W）---&gt;（batch， channel， height， wight）</strong></p> 
 <p><strong>同时，图像的数据应当进行归一化</strong></p> 
</blockquote> 
<p><strong>如果需要转换的参数有很多，那就需要通过<code>torchvision.transforms.Compose</code>(<em>transforms</em>)将所有的转换类型组合到一起。但是此类转换，并不支持torchscript。</strong></p> 
<p><strong>（torchscript语言自身是python语言的一个子类，目的是将Pytorch模型转化成torchscript好方便在C++的环境中进行调用模型，如需要进行转换，这要使用torch.nn.Sequential函数，这里就不详细说明了，可点击官方文档进行参考）</strong></p> 
<p><strong>我们看看<code>torchvision.transforms.Compose</code>(<em>transforms</em>)的使用方法：</strong></p> 
<p><img alt="" height="233" src="https://images2.imgbox.com/a9/ed/u0jGH8Wh_o.png" width="1078"></p> 
<p> <strong>那常见的transforms有哪些呢？哪些在我们的项目中需要用到的呢？</strong></p> 
<p></p> 
<blockquote> 
 <ul><li> <h4 id="torchvision.transforms.ToTensor%EF%BC%88%EF%BC%89"><code>torchvision.transforms.</code><code>ToTensor（）</code></h4> </li></ul> 
 <p>        <strong>将PIL或者numpy.ndarray转化为张量，但是有一个需要注意的是！！！对于这一条函数而言，如果，PIL图像的模式属于 (L, LA, P, I, F, RGB, YCbCr, RGBA, CMYK, 1)中的，或者是将PIL Image 或者numpy.ndarray的数据类型是dtype = np.uint8的，那就：</strong></p> 
 <p><strong>numpy.ndarray (H x W x C) in the range [0, 255]</strong></p> 
 <p><strong>转化为   </strong> <strong>torch.FloatTensor of shape (C x H x W) in the range [0.0, 1.0]</strong></p> 
</blockquote> 
<blockquote> 
 <ul><li> <h4 id="torchvision.transforms.Normalize(mean%2C%C2%A0std%2C%C2%A0inplace%3DFalse)%C2%A0"><strong><code>torchvision.transforms.</code><code>Normalize</code>(<em>mean</em>, <em>std</em>, <em>inplace=False</em>)</strong> </h4> </li></ul> 
 <p><strong>        使用均值和标准差对张量图像（不支持PIL图像）进行归一化，对n个通道都进行归一化，那么output[channel] = (input[channel] - mean[channel]) / std[channel]</strong></p> 
 <p><img alt="" height="96" src="https://images2.imgbox.com/99/e9/LHD1W09B_o.png" width="652"></p> 
 <p><strong>关于计算图像的均值和方差，这篇文章写的不错，如果想要了解，请看这篇文章，推荐：<a href="https://hulin.blog.csdn.net/article/details/116600119" rel="nofollow">《PyTorch数据归一化处理：transforms.Normalize及计算图像数据集的均值和方差》</a>，这里摘录一些重点：</strong></p> 
 <p><img alt="" height="252" src="https://images2.imgbox.com/cb/f7/MvRx0GLv_o.png" width="480"> </p> 
</blockquote> 
<p><strong> 其他的一些预处理的操作可以参考官方文档以及这篇博客：<a href="https://blog.csdn.net/weixin_37799689/article/details/106213198">《pytorch使用——（五）transforms详解》</a></strong></p> 
<p></p> 
<h3 id="3%E3%80%81torch.utils.data.DataLoader%E5%92%8Ctorch.utils.data.Dataset">3、<strong>torch.utils.data.DataLoader和</strong><code>torch.utils.data.</code><code>Dataset</code></h3> 
<p><strong>我们一点一点来分析……torch.utils.data这个Python API</strong></p> 
<blockquote> 
 <p><strong>Pytorch中官方文档对torch.utils.data的解释：</strong><a href="https://pytorch.org/docs/stable/data.html" rel="nofollow">torch.utils.data — PyTorch 1.9.0 documentation</a></p> 
 <p><strong>在官方文档中，对于这个API的第一句话就提到了torch.utils.data.DataLoader，说它是Pytorch的核心数据加载工具，不仅提供数据集可以进行python迭代，同时也支持（这些功能在官方文档中有详细的说明，大致的意思是数据集加载可自定义修改且方便迭代，同时可以成批加载单类或多分类的数据，且有内存记忆的功能）</strong></p> 
 <p><img alt="" height="172" src="https://images2.imgbox.com/17/a5/2E42nanF_o.png" width="338"></p> 
 <p><strong>具体的含义可以通过</strong> <strong>DataLoader的参数体现出来</strong></p> 
 <p><img alt="" height="180" src="https://images2.imgbox.com/59/ad/zlStdTKr_o.png" width="741"></p> 
</blockquote> 
<blockquote> 
 <ul><li> <h4 id="torch.utils.data.DataLoader"><strong>torch.utils.data.DataLoader</strong></h4> </li></ul> 
 <p><strong>        主要用来将自定义的数据读取接口的输出或者PyTorch已有的数据读取接口的输入按照batch size封装成Tensor，后续只需要再包装成Variable即可作为模型的输入，因此该接口有点承上启下的作用，比较重要</strong></p> 
 <ul><li> <p><strong>dataset (<a href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset" rel="nofollow"><em>Dataset</em></a>) – 数据读取接口（比如</strong>torchvision.datasets.ImageFolde<strong>），该输出是</strong>torch.utils.data.Dataset<strong>类的对象（或者继承该类的自定义的对象）</strong></p> </li><li> <p><strong>batch_size (<a href="https://docs.python.org/3/library/functions.html#int" rel="nofollow"><em>int</em></a><em>, </em><em>optional</em>) – 批训练数据量的大小，一般为2的指数：32/64/128……(default: <code>1</code>).</strong></p> </li><li> <p><strong>shuffle (<a href="https://docs.python.org/3/library/functions.html#bool" rel="nofollow"><em>bool</em></a><em>, </em><em>optional</em>) –打乱数据集，一般在训练数据时采用 (default: <code>False</code>).</strong></p> </li><li> <p><strong>sampler (<a href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Sampler" rel="nofollow"><em>Sampler</em></a><em> or </em><em>Iterable</em><em>, </em><em>optional</em>) – 定义从数据集中提取样本的策略. Can be any <code>Iterable</code> with <code>__len__</code> implemented. If specified, <code>shuffle</code> must not be specified.</strong></p> </li><li> <p><strong>batch_sampler (<a href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Sampler" rel="nofollow"><em>Sampler</em></a><em> or </em><em>Iterable</em><em>, </em><em>optional</em>) – like <code>sampler</code>, but returns a batch of indices at a time. 一般同<code>batch_size</code>, <code>shuffle</code>, <code>sampler</code>, and <code>drop_last等参数互斥，默认即可</code></strong></p> </li><li> <p><strong>num_workers (<a href="https://docs.python.org/3/library/functions.html#int" rel="nofollow"><em>int</em></a><em>, </em><em>optional</em>) – 加载数据集所用的进程数，可理解为参与数据提取的CPU核数，加快数据提取的速度 (default: <code>0</code>)</strong></p> </li><li> <p><strong>collate_fn (<em>callable</em><em>, </em><em>optional</em>) – 合并样本清单以形成小批量。用来处理不同情况下的输入dataset的封装，一般采用默认即可，除非你自定义的数据读取输出非常少见。</strong></p> </li><li> <p><strong>pin_memory (<a href="https://docs.python.org/3/library/functions.html#bool" rel="nofollow"><em>bool</em></a><em>, </em><em>optional</em>) – If <code>True</code>,数据加载器将把张量复制到CUDA内存中，然后返回它们。也就是一个数据拷贝的问题。</strong></p> </li><li> <p><strong>drop_last (<a href="https://docs.python.org/3/library/functions.html#bool" rel="nofollow"><em>bool</em></a><em>, </em><em>optional</em>) – 如果数据集大小不能被批大小整除，则设置为True，以删除最后一个不完整的批。如果数据集的大小不能被批处理的大小整除，那么最后的批处理会更小。</strong><strong>(default: <code>False</code>)</strong></p> </li><li> <p><strong>timeout (<em>numeric</em><em>, </em><em>optional</em>) – 设置一个正数表示数据读取超时 (default: <code>0</code>)</strong></p> </li><li> <p><strong>worker_init_fn (<em>callable</em><em>, </em><em>optional</em>) – If not <code>None</code>, this will be called on each worker subprocess with the worker id (an int in <code>[0, num_workers - 1]</code>) as input, after seeding and before data loading. (default: <code>None</code>)</strong></p> </li><li> <p><strong>generator (<a href="https://pytorch.org/docs/stable/generated/torch.Generator.html#torch.Generator" rel="nofollow"><em>torch.Generator</em></a><em>, </em><em>optional</em>) – If not <code>None</code>, this RNG will be used by RandomSampler to generate random indexes and multiprocessing to generate base_seed for workers. (default: <code>None</code>)</strong></p> </li><li> <p><strong>prefetch_factor (<a href="https://docs.python.org/3/library/functions.html#int" rel="nofollow"><em>int</em></a><em>, </em><em>optional</em><em>, </em><em>keyword-only arg</em>) – Number of samples loaded in advance by each worker. <code>2</code> means there will be a total of 2 * num_workers samples prefetched across all workers. (default: <code>2</code>)</strong></p> </li><li> <p><strong>persistent_workers (<a href="https://docs.python.org/3/library/functions.html#bool" rel="nofollow"><em>bool</em></a><em>, </em><em>optional</em>) – If <code>True</code>, the data loader will not shutdown the worker processes after a dataset has been consumed once. This allows to maintain the workers Dataset instances alive. (default: <code>False</code>)</strong></p> </li></ul> 
 <p><img alt="" height="41" src="https://images2.imgbox.com/dd/54/qKJhS7iV_o.png" width="631"></p> 
 <p><img alt="" height="172" src="https://images2.imgbox.com/6b/ff/NQEiBgn9_o.png" width="992"></p> 
 <p><strong>如果想要对DataLoader（其实就是实现DataLoader的功能）了解更多，推荐文章：<a href="https://wangsp.blog.csdn.net/article/details/84146704" rel="nofollow">《PyTorch—torch.utils.data.DataLoader 数据加载类》</a></strong></p> 
</blockquote> 
<blockquote> 
 <ul><li> <h4 id="torch.utils.data.Dataset"><code>torch.utils.data.</code><code>Dataset</code></h4> </li></ul> 
 <p>        <strong>提供数据集的一个抽象的类，当我们需要用到自定义的数据集时，可以去继承Dataset类并覆盖__len__()和__getitem__()方法，其中__len__()返回数据集的样本个数，getitem(index)返回训练集的第index个样本</strong></p> 
</blockquote> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%8A%A0%E8%BD%BD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E9%9B%86">二、加载自定义数据集</h2> 
<blockquote> 
 <p><strong>根据官网的说明，</strong>Base classes for custom datasets（自定义数据集）：<a href="https://pytorch.org/vision/stable/datasets.html#base-classes-for-custom-datasets" rel="nofollow">torchvision.datasets — Torchvision 0.10.0 documentation (pytorch.org)</a></p> 
 <p><strong>一共有两类：</strong></p> 
 <ul><li><strong><code>torchvision.datasets.</code><code>DatasetFolder</code></strong></li><li><strong><code>torchvision.datasets.</code><code>ImageFolder</code></strong></li></ul> 
 <p></p> 
</blockquote> 
<h3 id="1%E3%80%81torchvision.datasets.DatasetFolder">1、torchvision.datasets.DatasetFolder</h3> 
<p><img alt="" height="104" src="https://images2.imgbox.com/dc/d3/nXQkkoLy_o.png" width="649"></p> 
<p><strong> DatasetFolder具体的参数是：</strong></p> 
<ul><li> <p><strong>root (<em>string</em>) – 根目录路径，比如root目录下包含cat和dog两个文件夹（两个类）</strong></p> </li><li> <p><strong>loader (<em>callable</em>) – 一种函数，可以由给定的路径加载图片</strong></p> </li><li> <p><strong>extensions (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" rel="nofollow"><em>tuple</em></a><em>[</em><em>string</em><em>]</em>) – 允许的扩展列表。扩展名和有效文件都不应该被传递</strong></p> </li><li> <p><strong>transform (<em>callable</em><em>, </em><em>optional</em>) – 一种函数或转换，前面提到过 transform，E.g, <code>transforms.RandomCrop</code> for images.</strong></p> </li><li> <p><strong>target_transform (<em>callable</em><em>, </em><em>optional</em>) – 同前</strong></p> </li><li> <p><strong>is_valid_file –检查文件是否有误</strong></p> </li></ul> 
<p> <img alt="" height="258" src="https://images2.imgbox.com/0e/5f/Di7WQDbo_o.png" width="637"></p> 
<blockquote> 
 <p> <strong> DatasetFolder</strong><strong>这是一个通用的数据加载器，通过重写</strong><a href="https://pytorch.org/vision/stable/datasets.html#torchvision.datasets.DatasetFolder.find_classes" rel="nofollow"><code>find_classes()</code></a><strong>这个方法可以获得文件的目录结构（这个就是说在py文件里面你可以重写这个方法，这样可以灵活的应用数据集的文件）</strong></p> 
 <p><img alt="" height="54" src="https://images2.imgbox.com/b3/28/qzeJu2ZO_o.png" width="601">  </p> 
 <p><strong>但是一般文件目录需要遵守下面的结构框架：</strong></p> 
 <p> <img alt="" height="267" src="https://images2.imgbox.com/34/69/gp22qmxv_o.png" width="201"></p> 
 <p> <strong>这里的dictionary指的是包含分类（dog/cat/caw……）文件夹的根目录文件（如上图）相当于前面的self.root，如果找不到相应的目录文件，就会返回错误FileNotFoundError，如果准确无误，那么返回：一个元组  各种分类的列表，以及对应各种分类对应索引的字典</strong></p> 
 <p><strong>(Tuple[List[<a href="https://docs.python.org/3/library/stdtypes.html#str" rel="nofollow">str</a>], Dict[<a href="https://docs.python.org/3/library/stdtypes.html#str" rel="nofollow">str</a>, <a href="https://docs.python.org/3/library/functions.html#int" rel="nofollow">int</a>]])</strong></p> 
 <p><strong>假设我的目录结构为：</strong></p> 
 <p><img alt="" height="190" src="https://images2.imgbox.com/6c/40/DdyKVEUs_o.png" width="178"></p> 
 <p><strong> find_classes(root)源码如下：</strong></p> 
 <p><strong>该函数的参数：dir = root，调用DatasetFolder类时使用的目录，多为travel，test等</strong></p> 
 <pre><code class="language-python">def find_classes(dir):
#这里的dir则表示为".../root"
    classes = [d for d in os.listdir(dir) if os.path.isdir(os.path.join(dir, d))]   
    # 遍历dir目录下的所有子目录名称(dog和cat)并将其存在classes中
    # classes = [dog,cat]
    classes.sort()
    # 由于Python版本的不同可能需要更换为sorted(classes)
    class_to_idx = {classes[i]: i for i in range(len(classes))}
    # class_to_idx就是将类别转化为数字表示，class_to_idx = {dog:0；cat:1}
    # 创建一个字典，将类别与数字对应
    return classes, class_to_idx
    # classes = [dog,cat]
    # class_to_idx = {dog:0；cat:1}
</code></pre> 
 <p><strong>可以看到只是在读取文件的路径和形式有些许区别，在使用不同的数据集时需要我们自己去调整具体细节，最后可以输出classes, class_to_idx这样的形式即可＜（＾－＾）＞</strong></p> 
</blockquote> 
<p></p> 
<h3 id="2%E3%80%81torchvision.datasets.ImageFolder">2、torchvision.datasets.ImageFolder</h3> 
<p><strong>实际上是继承</strong><a href="https://pytorch.org/vision/stable/datasets.html#torchvision.datasets.DatasetFolder" rel="nofollow"><code>DatasetFolder</code></a><strong>的，他们的方法都是一样的，同样的方法定义数据集</strong></p> 
<p><img alt="" height="105" src="https://images2.imgbox.com/58/6c/R9HDiSOM_o.png" width="667"></p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/d7/c5/BGZztCBZ_o.png" width="665"></p> 
<p><img alt="" height="277" src="https://images2.imgbox.com/fa/a0/LG2qw4Ai_o.png" width="605"></p> 
<p><strong>返回的dataset都有以下三种属性：</strong></p> 
<ul><li><strong><code>self.classes</code>：用一个 list 保存类别名称</strong></li><li><strong><code>self.class_to_idx</code>：类别对应的索引，与不做任何转换返回的 target 对应</strong></li><li><strong><code>self.imgs</code>：保存(img-path, class) tuple的 list</strong></li></ul> 
<p> <strong>推荐博客：</strong></p> 
<p><a href="https://blog.csdn.net/qq_39507748/article/details/105394808">《pytorch学习笔记七：torchvision.datasets.ImageFolder使用详解》</a></p> 
<p></p> 
<p><strong>程序案例：</strong></p> 
<pre><code class="language-python">from torchvision.datasets import ImageFolder
from torchvision import transforms

#加上transforms
normalize=transforms.Normalize(mean=[.5,.5,.5],std=[.5,.5,.5])
transform=transforms.Compose([
    transforms.RandomCrop(180),
    transforms.RandomHorizontalFlip(),
    transforms.ToTensor(), #将图片转换为Tensor,归一化至[0,1]
    normalize
])

dataset=ImageFolder('./data/train',transform=transform)
</code></pre> 
<p><strong>得到的<code>dataset</code>,它的结构就是[(img_data,class_id),(img_data,class_id),…],下面我们打印第一个元素：【（图像tensor数据，标签），（图像tensor数据，标签），……】</strong></p> 
<p><img alt="" height="542" src="https://images2.imgbox.com/bd/d7/djRREdGO_o.png" width="624"></p> 
<p> <strong>再看一下<code>dataset</code>的三个属性：</strong></p> 
<p><img alt="" height="295" src="https://images2.imgbox.com/6e/f5/sBetEqda_o.png" width="628"></p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%8A%A0%E8%BD%BD%E6%9C%AC%E5%9C%B0kaggle%E7%8C%AB%E7%8B%97%E6%95%B0%E6%8D%AE%E9%9B%86">三、加载本地kaggle猫狗数据集</h2> 
<p><strong>文件目录</strong></p> 
<p><strong>└─kaggle<br>     ├─test<br>     └─train</strong></p> 
<p><strong>在train文件夹下：</strong></p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/59/f0/tYI5AYDM_o.png" width="700"></p> 
<p><strong>在test文件夹下：</strong></p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/3d/f9/MdZ4oLa0_o.png" width="700"></p> 
<p><strong> 仔细看小猫小狗，可以发现它们姿态不一，有的站着，有的眯着眼睛，有的甚至和其他可识别物体比如桶、人混在一起。同时，小猫们的图片尺寸也不一致，有的是竖放的长方形，有的是横放的长方形，但我们最终需要是合理尺寸的图片。所以需要进行图片处理，并把图片转化成Tensor作为模型的输入。（参考推荐博客：<a href="https://blog.csdn.net/weixin_37813036/article/details/90718310?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162981259116780264088981%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162981259116780264088981&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-90718310.first_rank_v2_pc_rank_v29&amp;utm_term=Kaggle%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%ABPytorch&amp;spm=1018.2226.3001.4187">《pytorch实现kaggle猫狗识别（超详细）》</a>）</strong></p> 
<pre><code class="language-python">data_transform = transforms.Compose([
    transforms.Resize(84),
    transforms.CenterCrop(84),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

train_dataset = datasets.ImageFolder(root='E:/AI学习/数据集/图像分类数据集/kaggle猫狗数据集/kaggle/train/', transform=data_transform)

train_loader = torch.utils.data.DataLoader(train_dataset, 
                                           batch_size=batch_size, 
                                           shuffle=True,
                                           num_workers=num_workers)

</code></pre> 
<p></p> 
<p><strong>在下一篇博客中，我们会记录：</strong></p> 
<p><strong>（！详解  Pytorch实战：②）kaggle猫狗数据集二分类：……</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1b7771856ca67b368202a540c0e99a80/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">go get 不了，就使用 go.mod中的replace来引入远程包(需要把远程包下载在本地)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4b9d5834251f5ec701c1a0554bbc2345/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">crm_用户管理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>