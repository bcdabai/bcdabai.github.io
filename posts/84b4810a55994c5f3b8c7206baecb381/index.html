<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>compose--修饰符Modifier - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="compose--修饰符Modifier" />
<meta property="og:description" content="上次介绍了compose中大多数的标准组件，此外还有两个重要的组件：列表LazyColumn和LazyRow，以及约束布局ConstraintLayout，在使用它们之前，先来认识Modifier
修饰符Modifier Modifier之前已经运用过，它能做的事情很多，不仅仅是改变组件的样式，还能够改变组件的位置，以及自定义交互事件，关于Modifier的所有用法，可以查看官方文档：https://developer.android.google.cn/jetpack/compose/modifiers-list，这边只介绍常用的
一、Modifier顺序 首先我们必须要知道的是：Modifier的设置是有顺序的，下面的代码分别在设置padding之前和之后为Box设置点击事件：
@Preview @Composable fun MyModifier1() { Row( horizontalArrangement = Arrangement.SpaceAround, verticalAlignment = Alignment.CenterVertically, modifier = Modifier.fillMaxSize() ) { Box( modifier = Modifier .size(100.dp) .background( color = MaterialTheme.colorScheme.primary, shape = MaterialTheme.shapes.medium ) .clickable { } .padding(40.dp) ) Box( modifier = Modifier .size(100.dp) .background( color = MaterialTheme.colorScheme.primary, shape = MaterialTheme.shapes.medium ) .padding(20.dp) .clickable { } ) } } 效果如下，左边为padding之前，padding之后，可以看到之后再设置点击事件，整个组件的点击范围变小了：
二、操作 对组件的操作有很多，如点击、长按、双击、拖拽、选中等
1.clickable-点击 clickable之前就使用过了，除了点击外，还有一些其他属性和提供无障碍操作(残疾人)使用：
fun Modifier.clickable( interactionSource: MutableInteractionSource,// 只有第一次按下才会发送，并更新状态 indication: Indication?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/84b4810a55994c5f3b8c7206baecb381/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-09T14:57:43+08:00" />
<meta property="article:modified_time" content="2022-12-09T14:57:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">compose--修饰符Modifier</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <article class="_2rhmJa" style="font-size: 16px;"> 
 <p>上次介绍了compose中大多数的标准组件，此外还有两个重要的组件：列表<code>LazyColumn</code>和<code>LazyRow</code>，以及约束布局<code>ConstraintLayout</code>，在使用它们之前，先来认识<code>Modifier</code></p> 
 <h4>修饰符Modifier</h4> 
 <p><code>Modifier</code>之前已经运用过，它能做的事情很多，不仅仅是改变组件的样式，还能够改变组件的位置，以及自定义交互事件，关于<code>Modifier</code>的所有用法，可以查看官方文档：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Fcompose%2Fmodifiers-list" rel="nofollow noopener noreferrer" target="_blank">https://developer.android.google.cn/jetpack/compose/modifiers-list</a>，这边只介绍常用的</p> 
 <h4>一、Modifier顺序</h4> 
 <p>首先我们必须要知道的是：<code>Modifier</code>的设置是有顺序的，下面的代码分别在设置<code>padding</code>之前和之后为<code>Box</code>设置点击事件：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyModifier1() {
    Row(
        horizontalArrangement = Arrangement.SpaceAround,
        verticalAlignment = Alignment.CenterVertically,
        modifier = Modifier.fillMaxSize()
    ) {
        Box(
            modifier = Modifier
                .size(100.dp)
                .background(
                    color = MaterialTheme.colorScheme.primary,
                    shape = MaterialTheme.shapes.medium
                )
                .clickable {

                }
                .padding(40.dp)
        )

        Box(
            modifier = Modifier
                .size(100.dp)
                .background(
                    color = MaterialTheme.colorScheme.primary,
                    shape = MaterialTheme.shapes.medium
                )
                .padding(20.dp)
                .clickable {

                }
        )
    }
}</code></pre> 
 <p>效果如下，左边为<code>padding</code>之前，<code>padding</code>之后，可以看到之后再设置点击事件，整个组件的点击范围变小了：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/53/68/uN8Crh7q_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h4>二、操作</h4> 
 <p>对组件的操作有很多，如点击、长按、双击、拖拽、选中等</p> 
 <h5>1.clickable-点击</h5> 
 <p><code>clickable</code>之前就使用过了，除了点击外，还有一些其他属性和提供无障碍操作(残疾人)使用：</p> 
 <pre class="has"><code class="kotlin">fun Modifier.clickable(
    interactionSource: MutableInteractionSource,// 只有第一次按下才会发送，并更新状态
    indication: Indication?,// 按下效果 如水波纹
    enabled: Boolean = true,
    onClickLabel: String? = null,//无障碍访问标签
    role: Role? = null,//为无障碍访问描述元素的类型
    onClick: () -&gt; Unit
)</code></pre> 
 <h5>2.combinedClickable-点击、长按、双击</h5> 
 <p><code>combinedClickable</code>组合了点击、长按、双击：</p> 
 <pre class="has"><code class="kotlin">@ExperimentalFoundationApi
fun Modifier.combinedClickable(
    interactionSource: MutableInteractionSource,
    indication: Indication?,
    enabled: Boolean = true,
    onClickLabel: String? = null,
    role: Role? = null,
    onLongClickLabel: String? = null,
    onLongClick: (() -&gt; Unit)? = null,
    onDoubleClick: (() -&gt; Unit)? = null,
    onClick: () -&gt; Unit
)</code></pre> 
 <p>例子：</p> 
 <pre class="has"><code class="kotlin">@OptIn(ExperimentalFoundationApi::class)
@Preview
@Composable
fun MyCombineClick() {
    val snackbarState by remember { mutableStateOf(SnackbarHostState()) }
    val scope = rememberCoroutineScope()

    Box(
        modifier = Modifier
            .fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = "点我",
            color = Color.White,
            modifier = Modifier
                .combinedClickable(
                    onClick = {
                        scope.launch {
                            snackbarState.showSnackbar(
                                "onClick",
                                duration = SnackbarDuration.Short
                            )
                        }
                    },
                    onDoubleClick = {
                        scope.launch {
                            snackbarState.showSnackbar(
                                "onDoubleClick",
                                duration = SnackbarDuration.Short
                            )
                        }
                    },
                    onLongClick = {
                        scope.launch {
                            snackbarState.showSnackbar(
                                "onLongClick",
                                duration = SnackbarDuration.Short
                            )
                        }
                    }
                )
                .background(MaterialTheme.colorScheme.secondary, MaterialTheme.shapes.small)
                .padding(10.dp)
        )

        SnackbarHost(hostState = snackbarState, modifier = Modifier.align(Alignment.BottomCenter))
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/04/d8/yh2GVnbz_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>3.draggable-拖拽</h5> 
 <p><code>draggable</code>让组件可以响应拖动：</p> 
 <pre class="has"><code class="koltin">fun Modifier.draggable(
    state: DraggableState,
    orientation: Orientation,// 水平还是竖直方向
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource? = null,
    startDragImmediately: Boolean = false,//是否立即拖动，防止其他手势检测器对“向下”事件做出反应
    onDragStarted: suspend CoroutineScope.(startedPosition: Offset) -&gt; Unit = {},//拖动开始
    onDragStopped: suspend CoroutineScope.(velocity: Float) -&gt; Unit = {},//拖动结束
    reverseDirection: Boolean = false//是否反转方向
)</code></pre> 
 <p>例子：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyDraggable() {
    var offset by remember { mutableStateOf(0f) }
    val state = rememberDraggableState(onDelta = { delta -&gt;
        offset += delta
    })
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = "拽我",
            modifier = Modifier
                .offset { IntOffset(offset.roundToInt(), 0) }//偏移组件
                .draggable(
                    state = state,
                    orientation = Orientation.Horizontal,// 水平拖拽
                )
                .background(Color.Cyan, RoundedCornerShape(5.dp))
                .padding(10.dp)
        )
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/dc/4e/Ge9M00En_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>4.swipeable-滑动</h5> 
 <p><code>swipeable</code>类似于<code>Switch</code>的效果，可以定义多个锚点，以及判定切换锚点滑动的阈值：</p> 
 <pre class="has"><code class="kotlin">@ExperimentalMaterialApi
fun &lt;T&gt; Modifier.swipeable(
    state: SwipeableState&lt;T&gt;,
    anchors: Map&lt;Float, T&gt;,// 锚点集合
    orientation: Orientation,// 可滑动的方向
    enabled: Boolean = true,
    reverseDirection: Boolean = false,
    interactionSource: MutableInteractionSource? = null,
    thresholds: (from: T, to: T) -&gt; ThresholdConfig = { _, _ -&gt; FixedThreshold(56.dp) },// 滑动阈值，超于多少就滑动到下个锚点，反之则滑回来
    resistance: ResistanceConfig? = resistanceConfig(anchors.keys),
    // 滑动手指放开时，距离阈值没达到，但加速度达到阈值，则切换到下个锚点
    velocityThreshold: Dp = VelocityThreshold
)</code></pre> 
 <p>例子：</p> 
 <pre class="has"><code class="kotlin">@OptIn(ExperimentalMaterialApi::class)
@Preview
@Composable
fun MySwipeable() {
    // 表示运行到哪个锚点的状态
    val swipeableState = rememberSwipeableState(initialValue = 0)
    val width = 100.dp

    Box(
        modifier = Modifier
            .width(200.dp)
            .border(
                1.dp,
                Color.Red,
                RoundedCornerShape(5.dp)
            )
            .swipeable(
                state = swipeableState,
                anchors = mapOf(//锚点集合，表示每个锚点滑动的距离
                    0f to 0,
                    with(LocalDensity.current) {//dp-&gt;px
                        width.toPx()
                    } to 1),
                orientation = Orientation.Horizontal//水平滑动
            ),
        contentAlignment = Alignment.TopStart
    ) {
        Button(
            onClick = { /*TODO*/ },
            modifier = Modifier
                .offset { IntOffset(swipeableState.offset.value.roundToInt(), 0) }// 根据滑动状态进行偏移操作
                .width(width) // 按钮宽度也设置为100dp
        ) {
            Text(text = "滑我", color = Color.White)
        }
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/80/11/wnDPK8xY_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h4>三、对齐方式</h4> 
 <p>除了前面介绍布局时每个布局自带属性的对齐方式外，<code>Modifier</code>也为各个不同的布局作用域(<code>BoxScope</code>、<code>RowScope</code>、<code>ColumnScope</code>)设置了单独的布局方式，在这些作用域中，我们可以使用下面的对齐方式</p> 
 <h5>1.BoxScope</h5> 
 <p><code>align</code>:将内容元素拉取到 <code>Box</code> 中的特定 <code>Alignment</code></p> 
 <p>例子：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyBoxScope() {
    Box(modifier = Modifier.fillMaxSize()) {
        Button(
            onClick = { /*TODO*/ },
            modifier = Modifier.align(Alignment.Center)//将组件位于Box的中央
        ) {
            Text(text = "hi")
        }
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/e3/7c/EfCJCZbm_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>2.RowScope</h5> 
 <h6>2.1 align</h6> 
 <p><code>align</code>：设置元素在<code>Row</code>中的垂直对齐方式：<code>Top</code>顶部、<code>CenterHorizontally</code>垂直居中、<code>End</code>底部</p> 
 <p>例子：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyRowScope() {
    Row(modifier = Modifier.fillMaxSize()) {
        Text(
            text = "align-CenterVertically",
            modifier = Modifier
                .align(Alignment.CenterVertically)
                .background(Color.LightGray, RoundedCornerShape(3.dp))
                .padding(10.dp)
        )
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/e2/5f/AiWksfiB_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h6>2.2 alignBy</h6> 
 <p><code>alignBy</code>：使其 <code>alignmentLine</code> 与同样配置为 <code>alignBy</code> 的同级元素对齐。</p> 
 <p>例子：</p> 
 <pre class="has"><code class="kotln">@Preview
@Composable
fun MyRowScope2() {
    Row(modifier = Modifier.fillMaxSize()) {
        Text(
            text = "align-line1",
            modifier = Modifier
                .alignBy(FirstBaseline)
                .background(Color.LightGray, RoundedCornerShape(3.dp))
                .padding(10.dp)
        )
        Text(
            text = "align-line2",
            fontSize = 20.sp,
            modifier = Modifier
                .alignBy(FirstBaseline)
                .background(Color.LightGray, RoundedCornerShape(3.dp))
                .padding(10.dp)
        )
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/7c/65/zJDPJX2y_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <p><code>ColumnScope</code>也是差不多的使用方式，这边就不做多介绍了</p> 
 <h4>四、动画</h4> 
 <h5>1.animateItemPlacement</h5> 
 <p><code>animateItemPlacement</code>是作用于列表组件下的作用域中，可为列表Item元素添加动画效果</p> 
 <h5>2.animateEnterExit</h5> 
 <p><code>animateEnterExit</code>：在<code>AnimatedVisibilityScope</code>动画可见作用域中自定义进入和出去的动画效果</p> 
 <p>例子：</p> 
 <pre class="has"><code class="kotlin">@OptIn(ExperimentalAnimationApi::class)
@Preview
@Composable
fun MyAnimeScope() {
    var visible by remember { mutableStateOf(false) }

    Row(modifier = Modifier.fillMaxSize()) {
        Button(onClick = { visible = !visible }) {
            Text(text = "点我")
        }
        
        // 带动画的效果组件
        AnimatedVisibility(visible = visible) {
            Icon(
                Icons.Default.Info, contentDescription = null,
                // 自己指定进入和出去的动画
                modifier = Modifier.animateEnterExit(enter = scaleIn(), exit = scaleOut())
            )
        }
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/e0/38/SPMb3I4C_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h4>五、边框</h4> 
 <p><code>border</code>：可以为组件加上一个边框，需要指定<code>Shape</code>背景形状，还支持<code>Brush</code>(<a href="https://www.jianshu.com/p/ef733b6559d5" rel="nofollow noopener noreferrer" target="_blank"><strong>Shader(点击跳转详情)</strong></a>)</p> 
 <p>例子：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyBorder() {
    Box(
        modifier = Modifier
            .size(100.dp)
            .padding(start = 10.dp, top = 10.dp)
            .border(
                1.dp,// 边框粗细1dp
                Brush.linearGradient(
                    0f to Color.Cyan.copy(alpha = 0.5f),
                    1f to Color.Magenta
                ),// 线性渲染
                RoundedCornerShape(10.dp)// 形状带圆角
            )
    )
}</code></pre> 
 <p>预览效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/de/e6/7Ilj3iYD_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h4>六、绘图</h4> 
 <h5>1.alpha</h5> 
 <p><code>alpha</code>直接改变该组件的透明度：</p> 
 <pre class="has"><code class="kotln">@Preview
@Composable
fun MyAlpha() {
   Row {
       Box(
           modifier = Modifier
               .background(Color.Red)
               .size(50.dp)
       ) {

       }

       Box(
           modifier = Modifier
               .alpha(0.2f)
               .background(Color.Red)
               .size(50.dp)
       ) {

       }
   }
}</code></pre> 
 <p>预览效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/4a/b7/jxmmNodw_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>2.drawBehind</h5> 
 <p><code>drawBehind</code>提供一个画布，用于在绘制在内容后方：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyDrawBehind() {
    Text(
        text = "hi",
        modifier = Modifier.drawBehind {
            // 画个圆形背景
            drawCircle(color = Color.Cyan, 10f)
        }
    )
}</code></pre> 
 <p>预览效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/eb/b8/RjOvklCI_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>3.clip</h5> 
 <p><code>clip</code>是将组件内容显示的画布进行裁剪，不可与<code>background</code>同时使用：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyClip() {
    Box(modifier = Modifier.clip(CircleShape)) {
        Box(
            Modifier
                .size(50.dp)
                .background(color = Color.Cyan))
    }
}</code></pre> 
 <p>预览效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/c3/a2/Wmkrm5fA_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>4.drawWithContent</h5> 
 <p><code>drawWithContent</code>允许开发者在布局内容前后进行绘制，通过<code>drawContent()</code>方法绘制内容：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyDrawWithContent() {
    Text(
        text = "hi",
        modifier = Modifier.drawWithContent {
            // 先绘制内容
            this.drawContent()
            // 画个圆形背景
            drawCircle(color = Color.Cyan, 10f)
        }
    )
}</code></pre> 
 <p>预览效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/46/c4/WZf78Cso_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>5.indication</h5> 
 <p><code>indication</code>为交互设置效果，如水波纹，该效果在前面<code>clickable</code>等操作中也可以设置，<code>pointerInput</code>在后续指针中：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyIndication() {
    val interactionSource = remember { MutableInteractionSource() }

    Text(
        text = "hi",
        modifier = Modifier
            .indication(
                interactionSource = interactionSource,
                indication = rememberRipple(color = Color.Red) //红色水波纹
            )
            // 添加手势    
            .pointerInput(interactionSource, true) {
                this.detectTapGestures(
                    // 按下事件
                    onPress = { offset -&gt;
                        val pressInteraction = PressInteraction.Press(offset)
                        // 触发水波纹
                        interactionSource.emit(pressInteraction)
                    }
                )
            }
            .size(100.dp),
        textAlign = TextAlign.Center
    )
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/f7/dd/QbOPoGO3_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>6.paint</h5> 
 <p><code>paint</code>允许传入一个<code>painter</code>画笔，来对整个组件进行渲染：</p> 
 <pre class="has"><code class="kotlin">fun Modifier.paint(
    painter: Painter,
    sizeToIntrinsics: Boolean = true,
    alignment: Alignment = Alignment.Center,
    contentScale: ContentScale = ContentScale.Inside,
    alpha: Float = DefaultAlpha,
    colorFilter: ColorFilter? = null
)</code></pre> 
 <p>例子：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyPaint() {
    // 红色画笔
    val painter = ColorPainter(Color.Red)

    Box(modifier = Modifier.size(100.dp).paint(painter = painter)) {
        Text("hi")
    }
}</code></pre> 
 <p>预览效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/62/b7/uLo8KHp1_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>7.shadow</h5> 
 <p><code>shadow</code>为组件设置一个阴影：</p> 
 <pre class="has"><code class="kotlin">@Stable
fun Modifier.shadow(
    elevation: Dp,// 阴影大小 
    shape: Shape = RectangleShape, //形状
    clip: Boolean = elevation &gt; 0.dp,
    ambientColor: Color = DefaultShadowColor,
    spotColor: Color = DefaultShadowColor,
)</code></pre> 
 <p>例子：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyShadow() {
    Box(
        modifier = Modifier
            .size(100.dp),
        contentAlignment = Alignment.Center
    ) {
        Box(
            modifier = Modifier
                .size(50.dp)
                .shadow(2.dp)
        ) {

        }
    }
}</code></pre> 
 <p>预览效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/6d/c8/74f7V8gW_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h4>七、焦点</h4> 
 <h5>1.onFocusChanged</h5> 
 <p><code>onFocusChanged</code>可以监听组件焦点的变化，需要和<code>focusRequester</code>、<code>focusable</code>配合使用：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyFocus() {
    var focused by remember { mutableStateOf(false) }
    val focusRequester = remember { FocusRequester() }

    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Box(
            modifier = Modifier
                .focusRequester(focusRequester)//绑定焦点请求者
                .onFocusChanged { focusStat -&gt;
                    focused = focusStat.isFocused
                }
                .focusable()
                .size(50.dp)
                .background(if (focused) Color.Cyan else Color.Red)
        ) {

        }

        Button(
            onClick = { focusRequester.requestFocus() },//点击触发焦点获取
            modifier = Modifier.align(Alignment.BottomCenter)
        ) {
            Text("click")
        }
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/82/d0/1sqOoBhw_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h4>八、布局</h4> 
 <h5>1.layout</h5> 
 <p>使用<code>layout</code>摆放组件，和传统的自定义控件一样，<code>layout</code>是用于摆放位置的，下面小程序实现功能为基于<code>baseLine</code>进行一个偏移，最后通过重新</p> 
 <pre class="has"><code class="koltin">fun Modifier.baseLineToTop(
    dp: Dp
) = this.then(//当前Modifier进行组合
    layout { measurable, constraints -&gt;
        // 预先测量下组件
        val placeable = measurable.measure(constraints)
        // 获取baseline，为baseline到组件顶部的距离
        val baseLine = placeable[FirstBaseline]
        // 偏移后，组件的高度 = 原有高度+偏移量-baseline
        val height = placeable.height + dp.roundToPx() - baseLine
        // 重新定义组件的整体宽高
        layout(placeable.width, height) {
            //重新摆放组件,y轴进行偏移
            placeable.placeRelative(0, dp.roundToPx() - baseLine)
        }
    }
)

@Preview
@Composable
fun MyCustomLayoutModifier() {
    Row {
        Text(
            "hi",
            modifier = Modifier.baseLineToTop(24.dp)
        )

        Spacer(modifier = Modifier.width(20.dp))

        Text(
            "hi"
        )
    }
}</code></pre> 
 <p>预览效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/13/1e/D0yl2KhA_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h4>九、内边距</h4> 
 <h5>1.absolutePadding</h5> 
 <p><code>absolutePadding</code>和<code>padding</code>的区别在于，<code>absolutePadding</code>总认为是从左往右，从上往下摆放控件的，<code>CompositionLocal</code>会在后续进行介绍：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyPadding() {
    CompositionLocalProvider(LocalLayoutDirection provides LayoutDirection.Rtl) {// 从右往左摆放组件
        Row(modifier = Modifier.height(IntrinsicSize.Min)) {
            Box(
                modifier = Modifier
                    .size(100.dp)
                    .padding(10.dp, 10.dp, 20.dp, 10.dp)
                    .background(Color.Red)
            ) {
                Text("hi")
            }
            Divider(
                modifier = Modifier
                    .width(1.dp)
                    .fillMaxHeight()
            )
            Box(
                modifier = Modifier
                    .size(100.dp)
                    .absolutePadding(10.dp, 10.dp, 20.dp, 10.dp)
                    .background(Color.Blue)
            ) {
                Text("hi")
            }
        }
    }
}</code></pre> 
 <p>预览效果，由于进行了反转，蓝色才是使用了<code>absolutePadding</code>：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/a8/82/lBg66kHd_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h4>十、指针</h4> 
 <p>除了操作中介绍的几种改变组件交互效果外，还可以使用<code>pointerInput</code>来自定义更自由的操作，它包含了一切触摸事件的监听，并且后续的效果由你自己定义</p> 
 <h5>1.pointerInput</h5> 
 <p><code>pointerInput</code>就是处理触摸事件的一个修饰，官方推荐传入一个<code>key</code>，来确定何时取消上次的处理</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyPointer() {
    var offsetX by remember { mutableStateOf(0f) }
    var offsetY by remember { mutableStateOf(0f) }

    Box(modifier = Modifier.fillMaxSize()) {
        Text(
            text = "hi",
            color = Color.White,
            modifier = Modifier
                .offset { IntOffset(offsetX.roundToInt(), offsetY.roundToInt()) }
                .background(
                    MaterialTheme.colorScheme.primary,
                    MaterialTheme.shapes.medium
                )
                .padding(10.dp)
                .pointerInput(Unit) {
                    detectTransformGestures { centroid: Offset, pan: Offset, zoom: Float, rotation: Float -&gt;
                        pan.apply {
                            offsetX += x
                            offsetY += y
                        }
                    }
                },
            style = MaterialTheme.typography.labelMedium
        )
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/2b/27/hWsvpINr_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h4>十一、变换</h4> 
 <p>变换的效果包含：旋转，缩放，以及上面使用过的平移</p> 
 <h5>1.rotate</h5> 
 <p><code>rotate</code>传入一个角度，以旋转组件：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyTrans() {
    var rotationState by remember { mutableStateOf(0f) }

    Box(
        modifier = Modifier
            .rotate(rotationState)
            .padding(10.dp)
            .size(300.dp)
            .background(Color.Red)
            .pointerInput(Unit) {
                detectTransformGestures { centroid: Offset, pan: Offset, zoom: Float, rotation: Float -&gt;
                    rotationState += rotation
                }
            }
    )
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/92/88/QJv6J0t4_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>2.scale</h5> 
 <p><code>scale</code>可以将组件进行缩放</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyTrans2() {
    var scaleState by remember { mutableStateOf(1f) }

    Box(
        modifier = Modifier
            .scale(scaleState)
            .padding(10.dp)
            .size(300.dp)
            .background(Color.Red)
            .pointerInput(Unit) {
                detectTransformGestures { centroid: Offset, pan: Offset, zoom: Float, rotation: Float -&gt;
                    scaleState *= zoom
                }
            }
    )
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/6d/6f/8GICWMYx_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h4>十一、图形</h4> 
 <p><code>graphicsLayer</code>就是有关组件显示的一切状态，包含了所有变换效果、透明度、背景shape、阴影，配合<code>transformable</code>能够对变换进行快速的处理：</p> 
 <pre class="has"><code class="kotlin">fun Modifier.graphicsLayer(
    scaleX: Float,
    scaleY: Float,
    alpha: Float,
    translationX: Float,
    translationY: Float,
    shadowElevation: Float,
    rotationX: Float,
    rotationY: Float,
    rotationZ: Float,
    cameraDistance: Float,
    transformOrigin: TransformOrigin,
    shape: Shape,
    clip: Boolean,
    renderEffect: RenderEffect?,
    ambientShadowColor: Color,
    spotShadowColor: Color
)</code></pre> 
 <p>例子：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyGraphicsLayer() {
    var scale by remember { mutableStateOf(1f) }
    var rotation by remember { mutableStateOf(0f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    val transformState =
        rememberTransformableState { zoomChange: Float, panChange: Offset, rotationChange: Float -&gt;
            scale *= zoomChange
            rotation += rotationChange
            offset += panChange
        }

    Box(
        modifier = Modifier
            .graphicsLayer {
                scaleX = scale
                scaleY = scale
                rotationZ = rotation
                translationX = offset.x
                translationY = offset.y
            }
            .padding(10.dp)
            .size(300.dp)
            .background(Color.Red)
            .transformable(transformState)
    )
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/74/5a/XTIjtoY9_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h4>十二、滚动</h4> 
 <p><code>Modifier</code>还能为组件添加可以滚动的支持，以及内嵌滚动、根据滚动状态显示或隐藏组件的支持</p> 
 <h5>1.verticalScroll</h5> 
 <p><code>verticalScroll</code>可以让组件支持竖直滑动：</p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyScrollable() {
    val state = rememberScrollState()

    Column(
        modifier = Modifier
            .padding(10.dp)
            .size(300.dp)
            .background(MaterialTheme.colorScheme.primary)
            .verticalScroll(state)
    ) {
        repeat(10) { index -&gt;
            Text(text = "hi${index}", modifier = Modifier.height(50.dp))
        }
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/9b/ca/9dsS4Gij_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>2.overscroll</h5> 
 <p><code>overscroll</code>就是给组件加上滚动到边缘的效果：</p> 
 <pre class="has"><code class="kotlin">@OptIn(ExperimentalFoundationApi::class)
@Preview
@Composable
fun MyScrollable2() {
    val state = rememberScrollState()

    Box(modifier = Modifier.fillMaxSize()) {
        Column(
            modifier = Modifier
                .padding(10.dp)
                .size(300.dp)
                .verticalScroll(state)
                .overscroll(ScrollableDefaults.overscrollEffect())//滑动到顶部和底部的涟漪效果
        ) {
            repeat(50) { index -&gt;
                Text(text = "hi${index}", modifier = Modifier.height(50.dp))
            }
        }

        ExtendedFloatingActionButton(
            text = { Text(text = "点我") },
            icon = { Icon(Icons.Default.Close, contentDescription = null) },
            onClick = { /*TODO*/ },
            expanded = state.isScrollInProgress,
            modifier = Modifier.align(Alignment.BottomCenter)
        )
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/4d/07/hueGpdmD_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>3.nestedScroll</h5> 
 <p><code>nestedScroll</code>将内容组件的滑动事件进行分享，以达到联动的效果：</p> 
 <pre class="has"><code class="kotlin">@OptIn(ExperimentalFoundationApi::class, ExperimentalMaterial3Api::class)
@Preview
@Composable
fun MyScrollable3() {
    val state = rememberScrollState()

    val toolbarHeight = 48.dp
    val toolbarHeightPx = with(LocalDensity.current) { toolbarHeight.roundToPx().toFloat() }
    val toolbarOffsetHeightPx = remember { mutableStateOf(0f) }
    val nestedScrollConnection = remember {
        object : NestedScrollConnection {
            override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset {
                //y方向的偏移量
                val delta = available.y
                val newOffset = toolbarOffsetHeightPx.value + delta
                toolbarOffsetHeightPx.value = newOffset.coerceIn(-toolbarHeightPx, 0f)
                return Offset.Zero
            }
        }
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .nestedScroll(nestedScrollConnection)
    ) {
        Column(
            modifier = Modifier
                .padding(10.dp)
                .size(300.dp)
                .verticalScroll(state)
                .overscroll(ScrollableDefaults.overscrollEffect())//滑动到顶部和底部的涟漪效果
        ) {
            repeat(50) { index -&gt;
                Text(text = "hi${index}", modifier = Modifier.height(50.dp))
            }
        }

        TopAppBar(
            modifier = Modifier
                .height(toolbarHeight)
                .offset { IntOffset(x = 0, y = toolbarOffsetHeightPx.value.roundToInt()) },
            title = {
                Text(
                    stringResource(id = R.string.app_name)
                )
            },
            colors = TopAppBarDefaults.smallTopAppBarColors(containerColor = MaterialTheme.colorScheme.primary)
        )
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/ca/96/2CpDfaXd_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h4>十三、其他</h4> 
 <p>其他再列举一些常用的修饰</p> 
 <h5>1.blur</h5> 
 <p><code>blur</code>实现模糊滤镜效果，效果参考传统安卓处理方式：<a href="https://www.jianshu.com/p/d5253637512f" rel="nofollow noopener noreferrer" target="_blank">Android滤镜--Alpha值滤镜处理之MaskFilter</a></p> 
 <pre class="has"><code class="kotlin">@Preview
@Composable
fun MyBlur() {
    Row(horizontalArrangement = Arrangement.SpaceAround, modifier = Modifier.fillMaxWidth()) {

        Image(
            painter = painterResource(id = R.drawable.ic_launcher_background),
            contentDescription = null,
            modifier = Modifier.blur(50.dp)
        )

        Image(
            painter = painterResource(id = R.drawable.ic_launcher_background),
            contentDescription = null
        )
    }
}</code></pre> 
 <p>预览效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/40/4f/PnYRwQAd_o.png" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
 <h5>2.pullRefresh</h5> 
 <p><code>pullRefresh</code>让组件支持下拉刷新，配合<code>PullRefreshState</code>来显示<code>PullRefreshIndicator</code>刷新指示器：</p> 
 <pre class="has"><code class="kotlin">@OptIn(ExperimentalFoundationApi::class, ExperimentalMaterialApi::class)
@Preview
@Composable
fun MyPullRefresh() {
    val state = rememberScrollState()
    var refreshing by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()
    val refreshState = rememberPullRefreshState(
        refreshing = refreshing,
        onRefresh = {
            scope.launch {
                refreshing = true
                delay(1500)
                refreshing = false
            }
        }
    )

    Box(
        modifier = Modifier.pullRefresh(refreshState) //下拉刷新
    ) {
        Column(
            modifier = Modifier
                .padding(10.dp)
                .size(300.dp)
                .verticalScroll(state)
                .overscroll(ScrollableDefaults.overscrollEffect())//滑动到顶部和底部的涟漪效果

        ) {
            repeat(50) { index -&gt;
                Text(text = "hi${index}", modifier = Modifier.height(50.dp))
            }
        }

        PullRefreshIndicator(// 刷新指示器
            refreshing,
            refreshState,
            modifier = Modifier.align(Alignment.TopCenter)
        )
    }
}</code></pre> 
 <p>效果：</p> 
 <div class="image-package"> 
  <div class="image-container"> 
   <div class="image-view" style="text-align: center;"> 
    <img src="https://images2.imgbox.com/2d/66/s8Jg0f8Q_o.gif" style="outline: none;"> 
   </div> 
  </div> 
 </div> 
</article>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/788f79b362624d432b04fd78b810d39f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SSM框架-SSM整合</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/067a5307a3b4778752943f3a6b613acf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信小程序第四篇：生成图片并保存到手机相册</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>