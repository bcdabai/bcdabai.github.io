<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【前端八股文】vue系列：vue的优点和特点、生命周期、ref、$nextTick - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【前端八股文】vue系列：vue的优点和特点、生命周期、ref、$nextTick" />
<meta property="og:description" content="文章目录 vue的优点和特点双向数据绑定虚拟DOM组件化 生命周期十个阶段相关功能题外话：数据请求在created和mouted的区别 ref$nextTick参考 本系列目录：【前端八股文】目录总结
是以《代码随想录》八股文为主的笔记。详情参考在文末。
代码随想录的博客_CSDN博客-leecode题解,ACM题目讲解,代码随想录领域博主
vue的优点和特点 双向数据绑定虚拟DOM组件化 双向数据绑定 通过MVVM实现数据的双向绑定让开发者不在操作DOM对象，有更多时间去思考业务逻辑。
MVVM，即Model-View-ViewModel。
Model：代表数据模型，也可以在Model中定义数据修改和业务逻辑View：代表UI组件，将数据模型转换成UI展现出来ViewModel：同步View和Model的对象 在出现MVVM之前：
开发者在代码中大量调用相同的DOM API，操作冗余大量的DOM操作使页面的渲染性能降低Model频繁变化，开发者需要主动更新到View；用户操作使View发生变化，开发者也要将其同步到Model，工作繁琐 MVVM的出现很好地解决了上述问题。
在MVVM架构下，View和Model没有直接联系，而通过ViewModel交互Model和ViewModel之间的交互是双向的View和ViewModel双向数据绑定View数据的变化会同步到Model中，反之亦然（即数据之间的同步是全自动的） 虚拟DOM 在频繁操作的情况下，使用虚拟DOM，把多次操作合并为一次，推送到真实的DOM。
组件化 降低耦合度调试方便提高可维护性 生命周期 十个阶段 beforeCreate（创建前）created（创建后）beforeMount（挂载前）mounted（挂载后）beforeUpdate（更新前）updated（更新后）activated（激活前）deactivated（激活后）beforeDestory（销毁前）destoryed（销毁后） 生命周期钩子： 生命周期事件的别名。
Vue生命周期详解_渣渣苏的博客-CSDN博客
流程图：
相关功能 题外话：数据请求在created和mouted的区别 created是在组件实例创建完成时立刻调用，这时候页面dom节点未生成；mounted是在页面dom节点渲染完毕之后立刻执行。触发时机上created是比mounted要更早的。 两者的相同点：都能拿到实例对象的属性和方法。
讨论这个问题本质就是触发的时机：
放在mounted中的请求可能导致页面闪动（因为此时页面dom结构已经生成）但在页面加载前完成请求，则不会出现此情况建议对页面内容的改动放在created生命周期当中 ref ref：被用来给元素或子组件注册引用信息， 引用信息将会注册在父组件的 $refs 对象上，如果是在普通的DOM元素上使用，引用指向的就是 DOM 元素，如果是在子组件上，引用就指向组件的实例。$refs：是一个对象，持有已注册过 ref 的所有的子组件。 ref用于辅助开发者获取DOM元素或组件的引用，以及用于在父子组件中获取对方的某个元素进行取值，调用方法等。
在每个Vue组件实例上，都包含一个$refs对象，里面存储着对应DOM元素或组件的引用。
具体操作：
vue中ref的作用 - 简书 (jianshu.com)
Vue教程(ref和$refs的使用) - 腾讯云开发者社区-腾讯云 (tencent.com)
此方法很便利，但尽量不要使用。在没有其他办法的时候再使用。
注意：$refs只会在组件渲染完成之后生效，且不是响应式的。若用$refs获取不到想要的元素或引用，可以试试使用nextTick。
$nextTick 写的很好的解析 ： vue.nextTick()方法的使用详解（简单明了）
官方文档：nextTick | Vue3 (vue3js.cn)
定义：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。
原因：
vue中的数据不是一改变就立马更新的，而是异步更新的（否则性能较差，举例：对DOM改变10000次数据）更新数据的事件会放到任务队列中，任务队列有去重逻辑，可以优化性能因此，修改数据后不会立即触发视图，若我们需要实时获取新的DOM，可以通过调用nextTick实现 10000次更新数据举例：不异步更新就会执行一万次，消耗性能" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d04882ef0b7f76c1ff11eacdc1370155/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-22T21:23:57+08:00" />
<meta property="article:modified_time" content="2023-03-22T21:23:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【前端八股文】vue系列：vue的优点和特点、生命周期、ref、$nextTick</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#vue_6" rel="nofollow">vue的优点和特点</a></li><li><ul><li><a href="#_12" rel="nofollow">双向数据绑定</a></li><li><a href="#DOM_39" rel="nofollow">虚拟DOM</a></li><li><a href="#_42" rel="nofollow">组件化</a></li></ul> 
   </li><li><a href="#_48" rel="nofollow">生命周期</a></li><li><ul><li><a href="#_50" rel="nofollow">十个阶段</a></li><li><a href="#_73" rel="nofollow">相关功能</a></li><li><a href="#createdmouted_78" rel="nofollow">题外话：数据请求在created和mouted的区别</a></li></ul> 
   </li><li><a href="#ref_91" rel="nofollow">ref</a></li><li><a href="#nextTick_114" rel="nofollow">$nextTick</a></li><li><a href="#_154" rel="nofollow">参考</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>本系列目录：<a href="https://blog.csdn.net/karshey/article/details/129112049">【前端八股文】目录总结</a><br> 是以《代码随想录》八股文为主的笔记。详情参考在文末。<br> <a href="https://blog.csdn.net/youngyangyang04">代码随想录的博客_CSDN博客-leecode题解,ACM题目讲解,代码随想录领域博主</a></p> 
<h3><a id="vue_6"></a>vue的优点和特点</h3> 
<ul><li>双向数据绑定</li><li>虚拟DOM</li><li>组件化</li></ul> 
<h4><a id="_12"></a>双向数据绑定</h4> 
<p>通过<code>MVVM</code>实现<mark>数据的双向绑定</mark>让开发者不在操作DOM对象，有更多时间去思考业务逻辑。</p> 
<p>MVVM，即<code>Model-View-ViewModel</code>。</p> 
<ul><li>Model：代表<strong>数据模型</strong>，也可以在Model中定义数据修改和业务逻辑</li><li>View：代表<strong>UI组件</strong>，将数据模型转换成UI展现出来</li><li>ViewModel：同步View和Model的对象</li></ul> 
<p><img src="https://images2.imgbox.com/41/3c/XqGKZpcR_o.png" alt="在这里插入图片描述"><br> 在出现MVVM之前：</p> 
<ul><li>开发者在代码中大量调用相同的DOM API，操作冗余</li><li>大量的DOM操作使页面的渲染性能降低</li><li>Model频繁变化，开发者需要主动更新到View；用户操作使View发生变化，开发者也要将其同步到Model，工作繁琐</li></ul> 
<p>MVVM的出现很好地解决了上述问题。</p> 
<ul><li>在MVVM架构下，View和Model没有直接联系，而通过ViewModel交互</li><li>Model和ViewModel之间的交互是双向的</li><li>View和ViewModel双向数据绑定</li><li>View数据的变化会同步到Model中，反之亦然（即数据之间的同步是全自动的）</li></ul> 
<p><img src="https://images2.imgbox.com/5d/3d/zfN2PTRr_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="DOM_39"></a>虚拟DOM</h4> 
<p>在频繁操作的情况下，使用虚拟DOM，把多次操作合并为一次，推送到真实的DOM。</p> 
<h4><a id="_42"></a>组件化</h4> 
<ul><li>降低耦合度</li><li>调试方便</li><li>提高可维护性</li></ul> 
<h3><a id="_48"></a>生命周期</h3> 
<h4><a id="_50"></a>十个阶段</h4> 
<ul><li>beforeCreate（创建前）</li><li>created（创建后）</li><li>beforeMount（挂载前）</li><li>mounted（挂载后）</li><li>beforeUpdate（更新前）</li><li>updated（更新后）</li><li>activated（激活前）</li><li>deactivated（激活后）</li><li>beforeDestory（销毁前）</li><li>destoryed（销毁后）</li></ul> 
<p>生命周期钩子： 生命周期事件的别名。</p> 
<p><img src="https://images2.imgbox.com/04/cf/sysVmNRK_o.png" alt="在这里插入图片描述"><br> <a href="https://blog.csdn.net/su2231595742/article/details/115186957">Vue生命周期详解_渣渣苏的博客-CSDN博客</a></p> 
<p><img src="https://images2.imgbox.com/b4/6a/sH4q0jpm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e5/83/IN4Yh7vq_o.png" alt="在这里插入图片描述"><br> 流程图：</p> 
<p><img src="https://images2.imgbox.com/f4/e1/KZw1wTVo_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_73"></a>相关功能</h4> 
<p><img src="https://images2.imgbox.com/91/4d/RdohQedu_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="createdmouted_78"></a>题外话：数据请求在created和mouted的区别</h4> 
<ul><li><code>created</code>是在<strong>组件实例创建完成时</strong>立刻调用，这时候<strong>页面dom节点未生成</strong>；</li><li><code>mounted</code>是在<strong>页面dom节点渲染完毕</strong>之后立刻执行。</li><li>触发时机上<code>created</code>是比<code>mounted</code>要更早的。</li></ul> 
<p>两者的相同点：都能拿到实例对象的属性和方法。</p> 
<p>讨论这个问题本质就是<mark>触发的时机</mark>：</p> 
<ul><li>放在<code>mounted</code>中的请求可能导致<strong>页面闪动</strong>（因为此时页面dom结构已经生成）</li><li>但在页面加载前完成请求，则不会出现此情况</li><li>建议对页面内容的改动放在<code>created</code>生命周期当中</li></ul> 
<h3><a id="ref_91"></a>ref</h3> 
<ul><li>ref：被用来给<strong>元素或子组件</strong>注册引用信息， 引用信息将会注册在父组件的 <code>$refs</code> 对象上，如果是在普通的DOM元素上使用，引用指向的就是 <strong>DOM 元素</strong>，如果是在子组件上，引用就<strong>指向组件的实例</strong>。</li><li>$refs：是一个对象，持有已注册过 ref 的所有的子组件。</li></ul> 
<p>ref用于辅助开发者<strong>获取DOM元素或组件的引用</strong>，以及用于在<strong>父子组件</strong>中获取对方的某个元素进行<strong>取值，调用方法</strong>等。</p> 
<p>在每个Vue组件实例上，都包含一个$refs对象，里面存储着对应DOM元素或组件的引用。</p> 
<p>具体操作：<br> <a href="https://www.jianshu.com/p/623c8b009a85" rel="nofollow">vue中ref的作用 - 简书 (jianshu.com)</a><br> <a href="https://cloud.tencent.com/developer/article/1479575" rel="nofollow">Vue教程(ref和$refs的使用) - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p> 
<blockquote> 
 <p>此方法很便利，但尽量不要使用。在没有其他办法的时候再使用。</p> 
</blockquote> 
<p>注意：<code>$refs</code>只会在<strong>组件渲染完成</strong>之后生效，且不是响应式的。若用<code>$refs</code>获取不到想要的元素或引用，可以试试使用<code>nextTick</code>。</p> 
<h3><a id="nextTick_114"></a>$nextTick</h3> 
<p>写的很好的解析 ：<a href="https://blog.csdn.net/zhouzuoluo/article/details/84752280"> vue.nextTick()方法的使用详解（简单明了）</a></p> 
<p>官方文档：<a href="https://vue3js.cn/global/nextTick.html" rel="nofollow">nextTick | Vue3 (vue3js.cn)</a></p> 
<p>定义：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。</p> 
<p>原因：</p> 
<ul><li>vue中的数据不是一改变就立马更新的，而是<strong>异步更新</strong>的（否则性能较差，举例：对DOM改变10000次数据）</li><li>更新数据的事件会放到<strong>任务队列</strong>中，任务队列有<strong>去重</strong>逻辑，可以优化性能</li><li>因此，修改数据后不会立即触发视图，若我们需要<strong>实时获取新的DOM</strong>，可以通过调用nextTick实现</li></ul> 
<p>10000次更新数据举例：不异步更新就会执行一万次，消耗性能</p> 
<pre><code class="prism language-javascript"><span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>num<span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	num <span class="token operator">=</span> i
<span class="token punctuation">}</span>
</code></pre> 
<p>nextTick使用举例：<strong>nextTick后获取DOM的value是更新后的值</strong></p> 
<pre><code class="prism language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> createApp<span class="token punctuation">,</span> nextTick <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> message <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'Hello!'</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> <span class="token function-variable function">changeMessage</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token parameter">newMessage</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      message<span class="token punctuation">.</span>value <span class="token operator">=</span> newMessage
      <span class="token comment">// 这里获取DOM的value是旧值</span>
      <span class="token keyword">await</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// nextTick 后获取DOM的value是更新后的值</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Now DOM is updated'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="_154"></a>参考</h3> 
<p><a href="https://vue3js.cn/interview/vue/vue.html#%E4%B8%89%E3%80%81vue%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7" rel="nofollow">面试官：有使用过vue吗？说说你对vue的理解 | web前端面试 - 面试官系列 (vue3js.cn)</a><br> <a href="https://blog.csdn.net/czj1049561601/article/details/115078883">前端面试–谈谈你对MVVM的理解？如何回答_mvvm的理解面试_Ajiia的博客-CSDN博客</a><br> <a href="https://blog.csdn.net/su2231595742/article/details/115186957">Vue生命周期详解_渣渣苏的博客-CSDN博客</a><br> <a href="https://juejin.cn/post/6989496048557228046" rel="nofollow">Vue请求是在Created还是Mounted？ - 掘金 (juejin.cn)</a><br> <a href="https://vue3js.cn/interview/vue/lifecycle.html#%E4%B8%89%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B" rel="nofollow">面试官：请描述下你对vue生命周期的理解？在created和mounted这两个生命周期中请求数据有什么区别呢？ | web前端面试 - 面试官系列 (vue3js.cn)</a><br> <a href="https://www.jianshu.com/p/623c8b009a85" rel="nofollow">vue中ref的作用 - 简书 (jianshu.com)</a><br> <a href="https://cloud.tencent.com/developer/article/1479575" rel="nofollow">Vue教程(ref和$refs的使用) - 腾讯云开发者社区-腾讯云 (tencent.com)</a><br> <a href="https://vue3js.cn/interview/vue/nexttick.html#%E4%B8%80%E3%80%81nexttick%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">面试官：Vue中的nextTick有什么作用？ | web前端面试 - 面试官系列 (vue3js.cn)</a><br> <a href="https://blog.csdn.net/zhouzuoluo/article/details/84752280"> vue.nextTick()方法的使用详解（简单明了）</a><br> <a href="https://vue3js.cn/global/nextTick.html" rel="nofollow">nextTick | Vue3 (vue3js.cn)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8a8251f5ce2ad667bb1e95bf4ce3e968/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS在循环的时候碰到值相等的就赋值跳出循环</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/489441bbf7ba7c74da0ec78b467b11ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">KMP算法(快速手算求模式串的next),超详细KMP的子串匹配流程并用伪代码实现KMP算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>