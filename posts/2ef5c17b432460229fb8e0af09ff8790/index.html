<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二叉树小练习（leetcode） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二叉树小练习（leetcode）" />
<meta property="og:description" content="二叉树小练习 1.根据二叉树创建字符串 需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。
题目链接
class Solution { public: string tree2str(TreeNode* root){ string str; _tree2str(root,str); return str; } void _tree2str(TreeNode* root,string&amp; str) { if(root==nullptr) { return; } str &#43;= to_string(root-&gt;val); //左不为空 或者 左为空右不为空 if(root-&gt;left || root-&gt;right) { str &#43;= &#34;(&#34;; _tree2str(root-&gt;left,str); str &#43;= &#34;)&#34;; } //右不为空 if(root-&gt;right) { str &#43;= &#34;(&#34;; _tree2str(root-&gt;right,str); str &#43;= &#34;)&#34;; } return; } }; 2.二叉树的层序遍历 层序遍历Ⅰ 逐层地，从左到右访问所有节点
层序遍历Ⅱ 按从叶子节点所在层到根节点所在的层，逐层从左向右遍历
层序遍历Ⅱ就是在层序遍历Ⅰ的基础上进行一个逆序，所以就只写一个层序遍历Ⅱ
class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) { queue&lt;TreeNode*&gt; q; vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL){ return res; } q." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2ef5c17b432460229fb8e0af09ff8790/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-25T21:22:36+08:00" />
<meta property="article:modified_time" content="2022-03-25T21:22:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二叉树小练习（leetcode）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>二叉树小练习</h2> 
<h3><a id="1_2"></a>1.根据二叉树创建字符串</h3> 
<p>需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p> 
<p><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/" rel="nofollow">题目链接</a></p> 
<pre><code class="prism language-c++">class Solution {
public:
    string tree2str(TreeNode* root){
        string str;
        _tree2str(root,str);
        return str;
    }

    void _tree2str(TreeNode* root,string&amp; str) {
        if(root==nullptr)
        {
            return;
        }
        str += to_string(root-&gt;val);
        
        //左不为空 或者 左为空右不为空
        if(root-&gt;left || root-&gt;right)
        {
            str += "(";
            _tree2str(root-&gt;left,str);
            str += ")";
        }       

        //右不为空
        if(root-&gt;right)
        {
            str += "(";
            _tree2str(root-&gt;right,str);
            str += ")";
        }
        return;
    }
};
</code></pre> 
<h3><a id="2_46"></a>2.二叉树的层序遍历</h3> 
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" rel="nofollow">层序遍历Ⅰ</a> 逐层地，从左到右访问所有节点</p> 
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" rel="nofollow">层序遍历Ⅱ</a> 按从叶子节点所在层到根节点所在的层，逐层从左向右遍历</p> 
<p>层序遍历Ⅱ就是在层序遍历Ⅰ的基础上进行一个逆序，所以就只写一个层序遍历Ⅱ</p> 
<pre><code class="prism language-C++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
        queue&lt;TreeNode*&gt; q;
        vector&lt;vector&lt;int&gt;&gt; res;
        if(root==NULL){
            return res;
        }
        q.push(root);
        while(!q.empty())
        {
            vector&lt;int&gt; temp;
            for(int i=q.size();i&gt;0;i--)
            {
                TreeNode* node = q.front();
                q.pop();
                temp.push_back(node-&gt;val);
                if(node-&gt;left!=NULL){
                    q.push(node-&gt;left);
                } 
                if(node-&gt;right!=NULL){
                    q.push(node-&gt;right);
                }
            }
            res.push_back(temp);
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
</code></pre> 
<h3><a id="3_89"></a>3.二叉树的最近公共祖先</h3> 
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p> 
<p>公共祖先的定义：对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p> 
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" rel="nofollow">题目链接</a></p> 
<pre><code class="prism language-C++">class Solution {
public:
    bool FindPath(TreeNode* root,stack&lt;TreeNode*&gt;&amp; path, TreeNode* x)
    {
        if(root==nullptr)
        {
            return false;
        }
        path.push(root);
        if(root==x)
        {
            return true;
        }
        if(FindPath(root-&gt;left,path,x))
        {
            return true;
        }
        if(FindPath(root-&gt;right,path,x))
        {
            return true;
        }
        //左右都没找到
        path.pop();
        return false;
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
    {
        stack&lt;TreeNode*&gt; p_path;
        stack&lt;TreeNode*&gt; q_path;
        FindPath(root,p_path,p);
        FindPath(root,q_path,q);

        stack&lt;TreeNode*&gt;* longPath = &amp;p_path;
        stack&lt;TreeNode*&gt;* shortPath = &amp;q_path;
        if(p_path.size() &lt; q_path.size())
        {
            swap(longPath,shortPath);
        }
        //长的先走
        while(longPath-&gt;size()&gt;shortPath-&gt;size())
        {
            longPath-&gt;pop();
        }
        //同时走
        while(longPath-&gt;top()!=shortPath-&gt;top())
        {
            longPath-&gt;pop();
            shortPath-&gt;pop();
        }
        return longPath-&gt;top();
    }
};
</code></pre> 
<h3><a id="4_155"></a>4.二叉搜索树和双向链表</h3> 
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p> 
<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" rel="nofollow">题目链接</a></p> 
<pre><code class="prism language-C++">class Solution {
public:
    Node *pre, *head;
    void dfs(Node* cur) {
        if(cur == nullptr)
        {
            return;
        }
        dfs(cur-&gt;left);
        if(pre != nullptr)
        {
            pre-&gt;right = cur;
        }
        else
        {
            head = cur;
        }
        cur-&gt;left = pre;
        pre = cur;
        dfs(cur-&gt;right);
    }

    Node* treeToDoublyList(Node* root) {
        if(root == nullptr)
        {
            return nullptr;
        }
        dfs(root);
        head-&gt;left = pre;
        pre-&gt;right = head;
        return head;
    }
};
</code></pre> 
<h3><a id="5_199"></a>5.根据一棵树的前序遍历与中序遍历构造二叉树</h3> 
<p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p> 
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" rel="nofollow">题目链接</a></p> 
<pre><code class="prism language-c++">class Solution {
public:
    TreeNode* _buildTree(vector&lt;int&gt;&amp; preorder,int&amp; pi,vector&lt;int&gt;&amp; inorder,int inBegin,int inEnd)
    {
        if(inBegin&gt;inEnd)
        {
            return nullptr;
        }
        TreeNode* root = new TreeNode(preorder[pi]);
        ++pi;
        //查找root在中序遍历中的位置，划分左右子树
        int rooti=inBegin;
        while(rooti&lt;=inEnd)
        {
            if(root-&gt;val==inorder[rooti])
                break;
            else
                ++rooti;
        }
        root-&gt;left = _buildTree(preorder,pi,inorder,inBegin,rooti-1);
        root-&gt;right = _buildTree(preorder,pi,inorder,rooti+1,inEnd);
        return root;
    }
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) 
    {
        int i=0;
        return _buildTree(preorder,i,inorder,0,inorder.size()-1);
    }
};
</code></pre> 
<h3><a id="6_239"></a>6.根据一棵树的中序遍历与后序遍历构造二叉树</h3> 
<p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p> 
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" rel="nofollow">题目链接</a></p> 
<pre><code class="prism language-c++">//5.6题目和5.5类似，就在5.5的基础上稍微改造了一下
class Solution {
public:
    TreeNode* _buildTree(vector&lt;int&gt;&amp; postorder,int&amp; pi,vector&lt;int&gt;&amp; inorder,int inBegin,int inEnd)
    {
        if(inBegin&gt;inEnd)
        {
            return nullptr;
        }
        TreeNode* root = new TreeNode(postorder[pi]);
        --pi;
        //查找root在中序遍历中的位置，划分左右子树
        int rooti=inBegin;
        while(rooti&lt;=inEnd)
        {
            if(root-&gt;val==inorder[rooti])
                break;
            else
                ++rooti;
        }
        root-&gt;right = _buildTree(postorder,pi,inorder,rooti+1,inEnd);
        root-&gt;left = _buildTree(postorder,pi,inorder,inBegin,rooti-1);
        return root;
    }
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) 
    {
        int i=postorder.size()-1;
        return _buildTree(postorder,i,inorder,0,inorder.size()-1);
    }
};
</code></pre> 
<h3><a id="7_280"></a>7.二叉树的前序遍历（非递归）</h3> 
<p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" rel="nofollow">题目链接</a></p> 
<pre><code class="prism language-c++">class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; st;
        vector&lt;int&gt; ret;
        TreeNode* cur = root;
        while(!st.empty()||cur)//cur指向哪个节点就表示开始前序访问这棵树
        {
            //访问左路节点，左路节点入栈
            while(cur)
            {
                ret.push_back(cur-&gt;val);
                st.push(cur);
                cur = cur-&gt;left;
            }

            //依次取左路节点的右子树出来访问
            TreeNode* top = st.top();
            st.pop();
            //子问题去访问这些右子树
            cur = top-&gt;right;
        }
        return ret;
    }
};
</code></pre> 
<h3><a id="8_314"></a>8.二叉树的中序遍历（非递归）</h3> 
<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" rel="nofollow">题目链接</a></p> 
<pre><code class="prism language-c++">class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; st;
        vector&lt;int&gt; ret;
        TreeNode* cur = root;
        while(!st.empty()||cur)//cur指向哪个节点就表示开始前序访问这棵树
        {
            //左路节点入栈
            while(cur)
            {
                st.push(cur);
                cur = cur-&gt;left;
            }
            //依次取左路节点的右子树出来
            TreeNode* top = st.top();
            ret.push_back(top-&gt;val);
            st.pop();
            //子问题去访问这些右子树
            cur = top-&gt;right;
        }
        return ret;
    }
};
</code></pre> 
<h3><a id="9_347"></a>9.二叉树的后序遍历（非递归）</h3> 
<p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" rel="nofollow">题目链接</a></p> 
<pre><code class="prism language-c++">class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; st;
        vector&lt;int&gt; ret;
        TreeNode* cur = root;
        TreeNode* prev = nullptr;
        while(!st.empty()||cur)//cur指向哪个节点就表示开始前序访问这棵树
        {
            //左路节点入栈
            while(cur)
            {
                st.push(cur);
                cur = cur-&gt;left;
            }

            //取到一个栈顶元素，他的左路节点已经访问完了
            //如果他的右为空或者右子树已经访问完了，那么我们就可以访问栈顶元素
            TreeNode* top = st.top();
            if(top-&gt;right==nullptr || top-&gt;right==prev)
            {
                st.pop();
                ret.push_back(top-&gt;val);
                prev = top;
            }
            else
            {
                cur = top-&gt;right;
            }    
        }
        return ret;
    }
};
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/64fe1df2f9c866cbfd4d584ca578fc14/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">设计模式：单例模式案例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0fd8c5615a3e5566f523a087c97a610c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">POE供电标准之802.3af、802.3at、802.3bt解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>