<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>自动化运维工具—Ansible - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="自动化运维工具—Ansible" />
<meta property="og:description" content="一、Ansible概述 1.1 Ansible是什么 Ansible是一个基于Python开发的配置管理和应用部署工具，现在也在自动化管理领域大放异彩。它融合了众多老牌运维工具的优点，Pubbet和Saltstack能实现的功能，Ansible基本上都可以实现。
Ansible能批量配置、部署、管理上千台主机。比如以前需要切换到每个主机上执行的一或多 个操作，使用Ansible只需在固定的一台Ansible控制节点上去完成所有主机的操住。
Ansible是基于模块工作的，它只是提供了一-种运行框架，它本身没有完成任务的能力，真正执行操作的是Ansible的模块，比如copy模块用于拷贝文件到远程主机上，service模块用于管理服务的启动、停止、重启等。
1.2 Ansible的四个组件： Inventory 主机清单（主机组）Modules 模块Plugins 插件Playbooks 剧本（相当于脚本） 1.3 Ansible的特性 （1）特性一：
Ansible其中一个比较鲜明的特性Agentless，即无Agent的存在（无代理端，即无客户端），它就像普通命令一样， 并非c/s软件，也只需在某个作为控制节点的主机上安装一次Ansible即可，通常它基于ssh连接来控制远程主机，远程主机上不需要安装Ansible或其它额外的服务。
使用者在使用时，在服务器终端输入命令或者playbooks，会通过预定好的规则将playbook拆解为play（一个play就是一个Linux操作），再组织成ansible可以识别的任务，调用模块和插件，根据主机清单通过SSH将临时文件发给远程的客户端执行并返回结果，执行结束后自动删除。
（2）特性二：
Ansible的另一个比较鲜明的特性是它的绝大多数模块都具备幂等性（idempotence）。所谓幂等性，指的是多次操作或多次执行对系统资源的影响是一致的。
比如执行 systemctl stop xxx 命令来停止服务，当发现要停止的目标服务已经处于停止状态，它什么也不会做，所以多次停止的结果仍然是停止，不会改变结果，它是幂等的，而systemctl restart xxx是非幂等的。
Ansible的很多模块在执行时都会先判断目标节点是否要执行任务，所以，可以放心大胆地让Ansible去执行任务，重复执行某个任务绝大多数时候不会产生任何副作用。
二、Ansible 环境安装部署 实验环境：
角色IP安装工具管理端192.168.126.27ansible被管理端192.168.126.28无需安装被管理端192.168.126.29无需安装被管理端192.168.126.26无需安装 安装部署：
hostnamectl set-hostname ansible #iptables默认放通ssh 所以不用关闭防火墙 #1、管理端安装ansible yum install -y epel-release #先安装epel源 yum install -y ansible #安装ansible ​ #ansible目录结构 [root@ansible ~]# cd /etc/ansible [root@ansible ansible]# tree . ├── ansible.cfg ├── hosts └── roles ​ 1 directory, 2 files ​ ​ #2、配置主机清单，修改/etc/ansible/hosts文件 cd /etc/ansible vim hosts [webservers] #配置组名 192." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a3078312a3d248d3c5db32aa18da6f73/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-14T08:28:31+08:00" />
<meta property="article:modified_time" content="2023-06-14T08:28:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">自动化运维工具—Ansible</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、Ansible概述</h2> 
<h3>1.1 Ansible是什么</h3> 
<p>Ansible是一个基于Python开发的配置管理和应用部署工具，现在也在自动化管理领域大放异彩。它融合了众多老牌运维工具的优点，Pubbet和Saltstack能实现的功能，Ansible基本上都可以实现。</p> 
<p>Ansible能批量配置、部署、管理上千台主机。比如以前需要切换到每个主机上执行的一或多 个操作，使用Ansible只需在固定的一台Ansible控制节点上去完成所有主机的操住。</p> 
<p>Ansible是基于模块工作的，它只是提供了一-种运行框架，它本身没有完成任务的能力，真正执行操作的是Ansible的模块，比如copy模块用于拷贝文件到远程主机上，service模块用于管理服务的启动、停止、重启等。</p> 
<h3>1.2 Ansible的四个组件：</h3> 
<ul><li>Inventory 主机清单（主机组）</li><li>Modules 模块</li><li>Plugins 插件</li><li>Playbooks 剧本（相当于脚本）</li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/14/02/xFWRT7U9_o.png"></p> 
<p></p> 
<h3>1.3 Ansible的特性</h3> 
<p><strong>（1）特性一：</strong></p> 
<p>Ansible其中一个比较鲜明的特性<strong>Agentless，即无Agent的存在（无代理端，即无客户端）</strong>，它就像普通命令一样， 并非c/s软件，也只需在某个作为控制节点的主机上安装一次Ansible即可，通常它基于ssh连接来控制远程主机，远程主机上不需要安装Ansible或其它额外的服务。</p> 
<p>使用者在使用时，在服务器终端输入命令或者playbooks，会通过预定好的规则将playbook拆解为play（一个play就是一个Linux操作），再组织成ansible可以识别的任务，调用模块和插件，根据主机清单通过SSH将临时文件发给远程的客户端执行并返回结果，执行结束后自动删除。</p> 
<p><strong>（2）特性二：</strong></p> 
<p>Ansible的另一个比较鲜明的特性是它的<strong>绝大多数模块都具备幂等性</strong>（idempotence）。所谓幂等性，指的是多次操作或多次执行对系统资源的影响是一致的。</p> 
<p>比如执行 <code>systemctl stop xxx</code> 命令来停止服务，当发现要停止的目标服务已经处于停止状态，它什么也不会做，所以多次停止的结果仍然是停止，不会改变结果，它是幂等的，而systemctl restart xxx是非幂等的。</p> 
<p>Ansible的很多模块在执行时都会先判断目标节点是否要执行任务，所以，可以放心大胆地让Ansible去执行任务，重复执行某个任务绝大多数时候不会产生任何副作用。</p> 
<p></p> 
<h2>二、Ansible 环境安装部署</h2> 
<p>实验环境：</p> 
<table><thead><tr><th>角色</th><th>IP</th><th>安装工具</th></tr></thead><tbody><tr><td>管理端</td><td>192.168.126.27</td><td>ansible</td></tr><tr><td>被管理端</td><td>192.168.126.28</td><td>无需安装</td></tr><tr><td>被管理端</td><td>192.168.126.29</td><td>无需安装</td></tr><tr><td>被管理端</td><td>192.168.126.26</td><td>无需安装</td></tr></tbody></table> 
<p>安装部署：</p> 
<pre><code> hostnamectl set-hostname ansible #iptables默认放通ssh  所以不用关闭防火墙
 
 #1、管理端安装ansible
 yum install -y epel-release   #先安装epel源
 yum install -y ansible        #安装ansible
 ​
 #ansible目录结构
 [root@ansible ~]# cd /etc/ansible
 [root@ansible ansible]# tree
 .
 ├── ansible.cfg
 ├── hosts
 └── roles
 ​
 1 directory, 2 files
 ​
 ​
 #2、配置主机清单，修改/etc/ansible/hosts文件
 cd /etc/ansible
 vim hosts
 [webservers]    #配置组名
 192.168.126.28   #组里包含被管理的主机IP或主机名（主机名需要先修改/etc/hosts文件）
 192.168.126.29
 ​
 [dbservers]      #第二个组
 192.168.126.26
 ​
 #3、ansible默认使用ssh连接，所以管理前要设置免密登录
 #配置密钥对验证
 ssh-keygen -t rsa    #一路回车，生成密钥文件
 ​
 vim /etc/ssh/ssh_config      #修改ssh客户端配置文件
 StrictHostKeyChecking no     #35行，取消注释，将ask修改为no，开启免交互
 ​
 systemctl restart sshd       #重启sshd
 ​
 #使用sshpass，以免交互的方式将公钥文件传给被管理端，实现免密登录
 sshpass -p '123456' ssh-copy-id root@192.168.126.28
 sshpass -p '123456' ssh-copy-id root@192.168.126.29
 sshpass -p '123456' ssh-copy-id root@192.168.126.26
 ​
 #如果被管理端主机有很多台，可以通过sshpass和for循环写一个脚本，实现多台主机免密登录。
</code></pre> 
<p></p> 
<h2>三、ansible常用的命令行模块</h2> 
<p><strong>ansible管理命令：</strong></p> 
<pre><code> ansible &lt;组名&gt; -m &lt;模块&gt; -a &lt;参数列表&gt;
 ​
 ansible &lt;主机IP&gt; -m &lt;模块&gt; -a &lt;参数列表&gt;
 ​
 ansible &lt;主机名&gt; -a &lt;参数列表&gt;      #不加-m指定模块默认使用command
 ​
 #选项解释
 -m: 指定模块
 -a: 指定命令
</code></pre> 
<p><strong>查看ansible的模块：</strong></p> 
<pre><code> ansible-doc -l   #列出所有已安装的模块，按q退出
 ​
 ansible-doc -l | wc -l   #统计总共有多少模块
 3387
 ​
 ansible-doc -s 模块   #查看指定模块的描述信息和操作动作</code></pre> 
<h3>3.1 command模块</h3> 
<p><strong>在远程主机执行命令，不支持管道、重定向等shell的特性。</strong></p> 
<pre><code> ansible-doc -s command   #-s列出指定模块的描述信息和操作动作
 ​
 #指定ip执行date
 ansible 192.168.126.28 -m command -a 'date'   #-a指定命令
 ​
 #指定组执行date命令
 ansible webservers -m command -a 'date'     #指定webservers组执行date命令
 ansible dbservers -m command -a' date'      #指定dbservers组执行date命令
 ansible all -m command -a ' date'           #all代表所有hosts 主机
 ansible all -a 'date'                      #如省略-m模块，则默认运行command 模块
 ​
 ​
 ##常用的参数:
 chdir：在远程主机上运行命令前提前进入目录
 creates：判断指定文件是否存在，如果存在，不执行后面的操作
 removes：判断指定文件是否存在，如果存在，执行后面的操作
 ​
 #无论管理端当前在哪个目录，执行命令都是在被管理端的家目录进行操作，可以使用chdir参数先切换目录
 ansible dbservers -m command -a "chdir=/home ls ./"   #切换到/home目录下再执行命令
 ​
 #creates判断目标主机的指定是否存在，如果存在，则不执行后面的操作
 ansible dbservers -m command -a "creates=/data/f1.txt date"
 ansible dbservers -m command -a "creates=/data/aa.txt date"
 ​
 #removes判断目标主机的指定是否存在，如果存在，执行后面的操作
 ansible dbservers -m command -a "removes=/data/f1.txt date"
 ansible dbservers -m command -a "removes=/data/aa.txt date"
</code></pre> 
<h4>常用参数示例：</h4> 
<p>（1）chdir</p> 
<p>在远程主机上运行命令前提前进入目录。</p> 
<pre><code> #无论管理端当前在哪个目录，执行命令都是在被管理端的家目录进行操作，可以使用chdir参数切换目录。
 ​
 #目标主机切换到/home/目录后，再执行命令
 [root@ansible ~]# ansible dbservers -m command -a "chdir=/home ls ./"
 192.168.126.26 | CHANGED | rc=0 &gt;&gt;
 zy006

 #目标主机切换到/opt/目录后，再执行命令
 [root@ansible ~]# ansible dbservers -m command -a "chdir=/opt ls ./"
 192.168.126.26 | CHANGED | rc=0 &gt;&gt;
 rh
</code></pre> 
<p>（2）creates</p> 
<p>判断指定文件是否存在，如果不存在，则执行后面的操作。</p> 
<pre><code> #creates判断目标主机的指定文件是否存在，因为不存在，所以执行后面的命令
 [root@ansible ~]# ansible dbservers -m command -a 'creates=/opt/f1.txt touch /opt/f1.txt'
 [WARNING]: Consider using the file module with state=touch rather than running
 'touch'.  If you need to use command because file is insufficient you can add
 'warn: false' to this command task or set 'command_warnings=False' in
 ansible.cfg to get rid of this message.
 192.168.126.26 | CHANGED | rc=0 &gt;&gt;

 #在dbservers 设定的节点192.168.126.26上查看
 [root@zy6 ~]# ls /opt
 f1.txt  rh                   #f1.txt文件通过ansible command模块创建成功

 #相反若f1.txt 提前存在就不会执行创建命令
</code></pre> 
<p>（3）removes</p> 
<p>判断指定文件是否存在，如果存在，则执行后面的操作</p> 
<pre><code>#判断/opt/f1.txt是否存在，因为存在，所以执行后面的rm -rf命令
[root@ansible ~]# ansible dbservers -m command -a 'removes=/opt/f1.txt rm -rf /opt/f1.txt'
[WARNING]: Consider using the file module with state=absent rather than running
'rm'.  If you need to use command because file is insufficient you can add
'warn: false' to this command task or set 'command_warnings=False' in
ansible.cfg to get rid of this message.
192.168.126.26 | CHANGED | rc=0 &gt;&gt;


#在dbservers 设定的节点192.168.126.26上查看
[root@zy6 /]# ls /opt
rh                         #f1.txt已经被删除
 </code></pre> 
<h3>3.2 shell模块</h3> 
<p>在远程主机执行命令，相当于调用远程主机的shell进程，然后在该shell下打开一个子shell运行命令。支持管道符号和重动向等功能。</p> 
<pre><code> ansible-doc -s shell  #查看shell模块的描述信息和操作动作
 ​
 #shell模块支持重定向功能
 ansible dbservers -m shell -a 'echo hello&gt; /opt/abc.txt'
 ​
 #shell模块支持管道符号。
 ansible dbservers -m shell -a 'echo 123456| passwd -stdin zy006'   #免交互的方式修改用户密码
 ​
 #过滤出ens33网卡的地址
 ansible dbservers -m shell -a 'ifconfig ens33 | awk "NR==2 {print $2}"'  #要在$前加\让awk使用，不然ansible会认为是变量
</code></pre> 
<h4><strong>示例1：</strong></h4> 
<p>shell模块支持重定向功能。</p> 
<pre><code> #shell模块支持重定向功能
[root@ansible ~]# ansible dbservers -m shell -a 'echo hello &gt; /opt/abc.txt'
192.168.126.26 | CHANGED | rc=0 &gt;&gt;


#查看
[root@zy6 opt]# ls
abc.txt  rh
[root@zy6 opt]# cat abc.txt 
hello
</code></pre> 
<h4><strong>示例2：</strong></h4> 
<p>shell模块支持管道符号。</p> 
<pre><code>#免交互的方式修改用户密码
 ansible dbservers -m shell -a 'echo 123456| passwd --stdin zy006'
 ​
 #过滤出ens33网卡的地址
[root@ansible ~]# ansible dbservers -m shell -a 'ifconfig ens33 | awk "NR==2 {print $2}"'
192.168.126.26 | CHANGED | rc=0 &gt;&gt;
        inet 192.168.126.26  netmask 255.255.255.0  broadcast 192.168.126.255

[root@ansible ~]# ansible dbservers -m shell -a 'ifconfig ens33 | awk "NR==2 {print \$2}"'
192.168.126.26 | CHANGED | rc=0 &gt;&gt;
192.168.126.26  
 #注意：外面已经有单引号了，所以awk要使用双引号。且要在$前加\让awk使用，不然ansible会认为是变量。
</code></pre> 
<h3>3.3 cron模块</h3> 
<p>在远程主机定义任务计划。其中有两种状态(state) :</p> 
<ul><li>present 表示添加（可以省略）</li><li>absent 表示移除。</li></ul> 
<pre><code> ansible-doc -s cron    #查看cron模块包含的操作动作
 ​
 #常用的参数: 
 minute/hour/day/month/weekday:分/时/日/月/周
 job:任务计划要执行的命令，尽量使用绝对路径。
 name:任务计划的名称。
</code></pre> 
<h4><strong>示例1：</strong></h4> 
<p>写一个计划任务，要求每周2,5的0点30备份/var/log/messages，任务名称为backup system log</p> 
<pre><code>[root@ansible ~]# ansible webservers -m cron -a 'minute="30" hour="0" weekday="2,5" job="/usr/bin/cp -f /var/log/messages" name="backup system log"'
192.168.126.28 | CHANGED =&gt; {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": true, 
    "envs": [], 
    "jobs": [
        "backup system log"
    ]
}
192.168.126.29 | CHANGED =&gt; {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    }, 
    "changed": true, 
    "envs": [], 
    "jobs": [
        "backup system log"
    ]
}


#在webservers两个节点上查看
[root@zy8 ~]# crontab -l
#Ansible: backup system log
30 0 * * 2,5 /usr/bin/cp -f /var/log/messages

[root@zy9 ~]# crontab -l
#Ansible: backup system log
30 0 * * 2,5 /usr/bin/cp -f /var/log/messages</code></pre> 
<h4><strong>示例：移除计划性任务</strong></h4> 
<pre><code> #移除计划性任务backup system log。如果加入该计划时没有名字，name=None即可。
 [root@ansible ~]# ansible webservers -m cron -a 'name="backup system log" state=absent'
 ​
 #查看目标主机的计划任务
 ansible dbservers -a 'crontab -l'
</code></pre> 
<h3>3.4 user模块</h3> 
<pre><code>ansible-doc -s user    #查看user模块包含的操作动作</code></pre> 
<p><strong>常用参数：</strong></p> 
<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>用户名，必选参数。</td></tr><tr><td>state=present 或 absent</td><td>创建账号或者删除账号，present表示 创建，absent 表示删除。</td></tr><tr><td>system=yes 或 no</td><td>是否为系统账号。</td></tr><tr><td>uid</td><td>用户uid。</td></tr><tr><td>group</td><td>用户基本组。</td></tr><tr><td>groups</td><td>用户附加组。</td></tr><tr><td>shell</td><td>默认使用的登录shell</td></tr><tr><td>move_home=yes 或 no</td><td>如果设置的家目录已经存在，是否将已经存在的家目录进行移动。</td></tr><tr><td>password</td><td>用户的密码，建议使用加密后的字符串。</td></tr><tr><td>comment</td><td>用户的注释信息。</td></tr><tr><td>remove=yes 或 no</td><td>表示当state=absent时，是否删除用户的家目录。即删除用户时，是否同时删除家目录。yes表示删除用户的家目录。</td></tr></tbody></table> 
<h4>示例1：</h4> 
<pre><code> [root@ansible ~]# ansible dbservers -m user -a 'name="test01" uid="9527" groups="wheel"'
   #创建用户test01  uid  并且加入wheel组
 ansible dbservers -a 'tail -1 /etc/passwd'     #查看目标主机的用户账号文件
 ​
 
[root@ansible ~]# ansible dbservers -m user -a 'name="test01" uid="9527" groups="wheel"'
 #再次执行相同命令，状态为success,而不是changed，因为user模块不具有幂等性。


[root@ansible ~]# ansible dbservers -m user -a'name="test02" shell="/sbin/nologin" create_home=no'
#创建用户test02 并设置shell环境nologin，不创建家目录


#删除用户test01 并且删除用户家目录，若要保留用户家目录 remove=no
[root@ansible ~]# ansible dbservers -m user -a 'name="test01" state=absent remove=yes'</code></pre> 
<h4>示例2：</h4> 
<pre><code> #创建名称为test01的用户，uid为9526，添加附加组wheel
 ansible dbservers -m user -a 'name="test01" uid=9526 groups=wheel'
 ansible dbservers -a 'grep test01 /etc/passwd'
 ​
 #之后为test01用户设置密码，并且让其不可登录系统。
 ansible dbservers -m user -a 'name="test01" password="123456" shell="/sbin/nologin"'
 ansible dbservers -a 'grep test01 /etc/passwd'
 ansible dbservers -a 'grep test01 /etc/shadow'
 ​
 #删除用户test01，且删除家目录
 ansible dbservers -m user -a 'name="test01" state=absent remove=yes'
 ansible dbservers -a 'id test01' 
 ansible dbservers -a 'ls /home'
</code></pre> 
<h3>3.5 group模块</h3> 
<p>管理用户组的模块。</p> 
<p>注意：字符串类型的值建议加双引号，防止有空格。数字和布尔值不要加双引号。</p> 
<pre><code> ansible-doc -s group    #查看group模块包含的操作动作
 ​
 #创建ky组，设置为系统组。
 [root@ansible ~]# ansible dbservers -m group -a 'name="ky" gid=1234 system=yes'
 ansible dbservers -a 'tail -3 /etc/group'   #远程查看组
 ​
 #创建用户test02，设置为系统用户，加入基本组ky组。
 [root@ansible ~]# ansible dbservers -m user -a 'name="test02" groups="1234"'
 ansible dbservers -a 'id test02'  #远程查看test02信息
</code></pre> 
<h3>3.6 copy模块</h3> 
<p>用于将本地文件复制到远程主机。</p> 
<pre><code> ansible-doc -s copy     #查看copy模块包含的操作动作</code></pre> 
<p><strong>常用参数：</strong></p> 
<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>指出源文件的路径（位于控制节点，即管理端），可以使用相对路径或绝对路径，支持直接指定目录，如果源是目录则目标也要是目录。</td></tr><tr><td>dest</td><td>指出复制文件的目标及位置，使用绝对路径，如果源是目录则目标也要是目录，如果目标文件已经存在会覆盖原有的内容。</td></tr><tr><td>mode</td><td>指出复制时，目标文件的权限。</td></tr><tr><td>owner</td><td>指出复制时，目标文件的属主。</td></tr><tr><td>group</td><td>指出复制时，目标文件的属组。</td></tr><tr><td>content</td><td>指出复制到目标主机上的内容，不能与src一起使用。</td></tr></tbody></table> 
<h4>示例1：</h4> 
<pre><code> #将本地的/etc/hosts文件，复制到远程主机的/opt/目录下，并重命名为hosts.bak，文件属主设置为 
 root、属组设置为ky，权限设置为640。
 [root@ansible ~]# ansible dbservers -m copy -a 'src=/etc/hosts dest=/opt/hosts.bak 
 owner=root group=ky mode=640'
 ansible dbservers -a 'ls -l /data'     #查看文件权限
</code></pre> 
<h4>示例2：</h4> 
<pre><code> #将hello world写入远程主机的/opt/abc.txt文件中
 [root@ansible ~]# ansible dbservers -m copy -a 'content="hello world" dest=/opt/abc.txt'
 ansible dbservers -a 'cat /opt/abc.txt'
</code></pre> 
<h3>3.7 file模块</h3> 
<p>为远程主机创建/删除文件或目录，设置文件属性。</p> 
<p><strong>主要参数如下：</strong></p> 
<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>path</td><td>指定远程服务器的路径，也可以写成"dest"，"name"</td></tr><tr><td>state</td><td>状态，可以将值设定为directory表示创建目录，设定为touch表示创建文件，设定为link表示创建软链接，设定为hard表示创建硬连接，设定为absent表示删除目录文件或链接</td></tr><tr><td>mode</td><td>文件复制到远程并设定权限，默认file=644，directory=755</td></tr><tr><td>owner</td><td>文件复制到远程并设定属主，默认为root</td></tr><tr><td>group</td><td>文件复制到远程并设定属组，默认为root</td></tr><tr><td>recurese</td><td>递归修改</td></tr><tr><td>src</td><td>指的是目标主机上的源文件。与copy模块不同。</td></tr></tbody></table> 
<h4>示例1：修改文件的属主、属组、权限等</h4> 
<pre><code> ansible-doc -s file    #查看file模块包含的动作
 ​
 #修改文件的属主、属组、权限等。
 [root@ansible ~]# ansible dbservers -m file -a 'path=/opt/hosts.bak owner=test02 
 group=root mode=777'
 ansible dbservers -a 'ls -l /opt'
</code></pre> 
<h4>示例2：创建软链接文件</h4> 
<pre><code> #设置/opt/123.txt 为/opt/abc.txt的链接文件。state=link表示创建软链接。
 [root@ansible ~]# ansible dbservers -m file -a 'src=/opt/abc.txt state=link 
 path=/opt/123.txt'
 ansible dbservers -a 'ls -l /opt'
 ​
 #注意：src指的是目标主机上的源文件，与copy模块不同。</code></pre> 
<h4><strong>示例3：创建和删除文件、目录</strong></h4> 
<pre><code> #创建一个文件
 [root@ansible ~]# ansible dbservers -m file -a 'path=/opt/456.txt state=touch'
 ansible dbservers -a 'ls /opt'
 ​
 #删除文件/opt/456.txt
 [root@ansible ~]# ansible dbservers -m file -a 'path=/opt/456.txt state=absent'
 ansible dbservers -a 'ls /opt'
 ​
 #创建一个目录
 ansible dbservers -m file -a 'path=/opt/abc state=directory'
 ansible dbservers -a 'ls -l /opt'</code></pre> 
<h3>3.8 hostname模块</h3> 
<p>用于管理远程主机上的主机名。</p> 
<pre><code>ansible dbservers -m hostname -a 'name=centos7-6'  #修改dbservers组的主机名</code></pre> 
<h3>3.9 ping模块</h3> 
<p>测试远程主机的连通性。</p> 
<pre><code>[root@ansible ~]# ansible all -m ping  #测试所有主机的连通性</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/7d/1c/1Rs0Q3hH_o.png"></p> 
<h3>3.10 yum模块</h3> 
<p>在远程主机上安装与卸载软件包， 需要被管理端配置好yum源。</p> 
<p><strong>主要的参数如下：</strong></p> 
<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>指定安装软件包名或软件包URL</td></tr><tr><td>state</td><td>指定yum对应的方法，present(默认)、installed表示安装、latest表示安装最新版本软件包；absent、removed表示卸载。支持多程序一起安装，用逗号隔开。</td></tr><tr><td>enablerepo</td><td>允许从哪些仓库获取软件</td></tr><tr><td>disablerepo</td><td>禁止从哪些仓库获取软件</td></tr><tr><td>exclude</td><td>排除某些软件包，例如kernel</td></tr><tr><td>download_only</td><td>仅下载软件包，不安装</td></tr><tr><td>disable_gpg_check</td><td>不进行gpg检测</td></tr><tr><td>update_cache</td><td>可以在安装包的同时更新yum缓存</td></tr></tbody></table> 
<p><strong>示例：</strong></p> 
<pre><code> ansible-doc -s yum     #查看yum模块包含的操作动作
 ​
 ansible dbservers -m yum -a 'name=httpd'     #安装httpd服务
 ansible dbservers -m yum -a 'name=httpd state=absent'   #卸载httpd服务
 ​
 #yum一次性卸载所有主机的httpd服务
 ansible all -m yum -a "name=httpd state=absent"
</code></pre> 
<p></p> 
<p></p> 
<h3>3.11 service/systemd 模块</h3> 
<p>用于管理远程主机上的服务的运行状态。</p> 
<p><strong>主要参数如下：</strong></p> 
<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>指定需要控制的服务名称</td></tr><tr><td>state</td><td>指定服务状态，其值可以为stopped、started、reloaded、restarted、status</td></tr><tr><td>enabled</td><td>指定服务是否为开机启动，yes为启动，no为不启动</td></tr><tr><td>daemon_reload</td><td>yes：重启systemd服务，让unit文件生效</td></tr></tbody></table> 
<p>示例：</p> 
<pre><code> ansible-doc -s service     #查看service模块包含的操作动作
 ​
 #查看web服务器httpd运行状态
 ansible webservers -a 'systemctl status httpd'
 ​
 #启动httpd服务，并设置为开机自启
 ansible webservers -m service -a 'name=httpd state=started enabled=true'</code></pre> 
<p></p> 
<h3>3.12 script 模块</h3> 
<p>实现远程批量运行本地的shell脚本。</p> 
<p>注意：<strong>script模块不具有幂等性。所以建议用剧本来执行。</strong></p> 
<pre><code> ansible-doc -s script
 ​
 #在本地写一个脚本
 vim test.sh
 #!/bin/bash
 echo "hello ansible from script" &gt; /opt/script.txt
 ​
 chmod +x test.sh                              #给脚本执行权限
 ansible dbservers -m script -a 'test.sh'      #远程运行本地脚本
 ansible dbservers -a 'cat /opt/script.txt'   #查看生成的文件内容是否为指导内容
 
 
 #再次运行相同脚本，状态为changed，而不是successs，因为script模块不具有幂等性
 ansible dbservers -m script -a 'test.sh'</code></pre> 
<h3>3.13 setup 模块</h3> 
<p>facts组件是用来收集被管理节点信息的，使用setup 模块可以获取这些信息。</p> 
<pre><code> ansible-doc -s setup   #查看setup模块包含的操作动作
 ​
 #获取dbservers组主机的facts信息
 ansible dbservers -m setup
 ​
 #使用filter参数可以筛选指定的facts信息
 ansible dbservers -m setup -a 'filter=*ipv4'
</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2a/f4/LNV85qUT_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/62/cf/merHxgTw_o.png"></p> 
<h2>3.14 mount 模块</h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:666px;"><tbody><tr><td>src</td><td>定义挂载设备的路径</td></tr><tr><td>path</td><td>定义挂载到哪个目录，必须指定</td></tr><tr><td>fstype</td><td>指定挂载文件的系统类型，必须指定，xfs、iso9660、nfs...</td></tr><tr><td>opts</td><td>定义挂载的参数，defaults、rw、ro...</td></tr><tr><td>state</td><td>定义挂载的状态，mounted（进行挂载，修改/etc/fstab信息）、absent（永久性卸载，并修改 /etc/fstab信息）、unmounted（临时卸载，不修改/etc/fstab信息）</td></tr></tbody></table> 
<pre><code>#挂载文件系统
ansible-doc -s mount

ansible dbservers -m mount -a 'src=/dev/sr0 path=/mnt state=mounted fstype=iso9660'</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5b/d6/GEdOtGKc_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/99/dc/nKntDUbe_o.png"></p> 
<h2>3.15. archive 模块 </h2> 
<h4>打包压缩</h4> 
<p>常用的参数：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:666px;"><tbody><tr><td>path</td><td>必须参数，远程主机上需要被打包压缩的源文件/目录</td></tr><tr><td>dest</td><td>打包压缩后的包文件路径(包文件的父目录必须存在);如果包文件已存在，则会被覆盖</td></tr><tr><td>format</td><td>指定压缩类型，包括: bz2、gz（默认）、tar、xz、zip</td></tr><tr><td>remove=yes|no</td><td>是否删除源文件</td></tr></tbody></table> 
<pre><code>#远程主机上/etc/yum.repos.d/目录 打包压缩成/opt/repo.zip  格式为zip
ansible dbservers -m archive -a 'path=/etc/yum.repos.d/ dest=/opt/repo.zip format=zip'


#远程主机上/opt目录下的abc.txt和123.txt文件打包压缩成/opt/abc123.tar.gz  格式为tar.gz 并且删除源文件  
ansible dbservers -m archive -a 'path=/opt/abc.txt,/opt/123.txt dest=/opt/abc123.tar.gz format=gz remove=yes'

注意：删除源文件后目录仍然会保留下来</code></pre> 
<h2>3.16 unarchive 模块</h2> 
<h4>解包解压缩</h4> 
<p>常用参数：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:666px;"><tbody><tr><td>copy</td><td>默认为 copy=yes ，拷贝的文件从 ansible 主机复制到远程主机，copy=no 表示在远程主机上寻找源文件解压</td></tr><tr><td>src</td><td>tar包源路径，可以是 ansible 主机上的路径，也可以是远程主机上的路径，如果是远程主机上的路径，则需设置 copy=no</td></tr><tr><td>dest</td><td>解压后文件的目标绝对路径</td></tr><tr><td>remote_src</td><td>和 copy 功能一样且互斥，设置 remote_src=yes 表示文件在远程主机上，设置为 remote_src=no 表示文件在 ansible 主机上</td></tr></tbody></table> 
<pre><code>#将 ansible 主机的压缩文件拷贝到到远程主机并解压
ansible dbservers -m unarchive -a 'src=/opt/abc.tar.gz dest=/root copy=yes'
或者
ansible dbservers -m unarchive -a 'src=/opt/abc.tar.gz dest=/root remote_src=no'

#在远程主机解包
ansible dbservers -m unarchive -a 'src=/opt/123.tar.gz dest=/root copy=no'
或者
ansible dbservers -m unarchive -a 'src=/opt/123.tar.gz dest=/root remote_src=yes'</code></pre> 
<h2>3.17 replace 模块</h2> 
<p><strong>类似于sed命令，主要也是基于正则进行匹配和替换</strong></p> 
<p>常用的参数:</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:666px;"><tbody><tr><td>path</td><td>必须参数，指定要修改的文件</td></tr><tr><td>regexp</td><td>必须参数，指定一个正则表达式</td></tr><tr><td>replace</td><td>替换regexp参数匹配到的字符串</td></tr><tr><td>backup=yes|no</td><td>修改源文件前创建一个包含时间戳信息的备份文件</td></tr><tr><td>before</td><td>如果指定，则仅替换/删除此匹配之前的内容，可以和after参数结合使用</td></tr><tr><td>after</td><td>如果指定，则仅替换/删除此匹配之后的内容，可以和before参数结合使用</td></tr><tr><td>owner</td><td>修改文件用户名</td></tr><tr><td>group</td><td>修改文件组名</td></tr><tr><td>mode</td><td>修改文件权限</td></tr></tbody></table> 
<pre><code>[root@zy6 ~]# vim /opt/test.txt
11 22 33 44 55 66
aa bb cc dd ee ff
1a 2b 3c 4d 5e 6f

#匹配 33 并修改为 cc
[root@ansible ~]# ansible dbservers -m replace -a 'path=/opt/test.txt regexp="33" replace="cc"'

#匹配到任意一个或多个开头的行增加注释
[root@ansible ~]# ansible dbservers -m replace -a 'path=/opt/test.txt regexp="^(.*)" replace="#\1"'

#取消注释
[root@ansible ~]#  ansible dbservers -m replace -a 'path=/opt/test.txt regexp="^#(.*)" replace="\1"'

#匹配以 a 开头的后面有一个或者多个字符的行，并在前面添加 # 注释
[root@ansible ~]# ansible dbservers -m replace -a 'path=/opt/test.txt regexp="^(a.*)" replace="#\1"'

#匹配cc之前的3并且修改为three
[root@ansible ~]# [root@ansible ~]# ansible dbservers -m replace -a 'path=/opt/test.txt regexp="3" replace="three" before=cc'</code></pre> 
<h2>总结</h2> 
<p><strong>Ansible的特性：</strong></p> 
<p>（1）Ansible其中一个比较鲜明的特性Agentless，即无Agent的存在，只需在某个作为控制节点的主机上安装一次Ansible即可，通常它基于ssh连接来控制远程主机，远程主机上不需要安装Ansible或其它额外的服务。</p> 
<p>（2）Ansible的另一个比较鲜明的特性是它的绝大多数模块都具备幂等性（idempotence）。所谓幂等性，指的是多次操作或多次执行对系统资源的影响是一致的。</p> 
<p><strong>注意：script模块不具有幂等性。所以建议用剧本来执行。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0ffd80ea22c5e0ba61067e20087590a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在JS文件中加载另一个JS文件的教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9669b47bcc2a499f7026fc24a6e479d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Kettle报错No repository exists on the specified connection. To create a repository</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>