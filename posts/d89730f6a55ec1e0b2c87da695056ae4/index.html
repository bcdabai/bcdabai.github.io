<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>简单复习最小生成树算法-Prim和Kruskal - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="简单复习最小生成树算法-Prim和Kruskal" />
<meta property="og:description" content="参考资料：
https://blog.csdn.net/qq_41754350/article/details/81460643https://blog.csdn.net/qq_41754350/article/details/81271567https://zhuanlan.zhihu.com/p/34922624 Prim算法 Prim针对点，而Kruskal针对边。Prim只适合无向带权图。维持一个集合，一开始选定一个点作为初始集合，另维持一个prev和dist列表。dist列表表示初始集合到其余所有点的距离，prev表示新加入集合的节点的前一个节点。它的加入策略是：不属于集合的且离集合最近的点。
即：Prim算法不断加入节点，直到所有节点都加入集合。
需要注意Prim和Dijkstra算法很相似，Dijkstra也是维持一个节点列表，并不断往集合中添加节点，但是Dijkstra也适合有向图，而且Dijkstra计算的是单一源节点到其余所有节点的最短距离，而Prim生成的是使得所有边的权值之和最小。
Kruskal算法 Kruskal算法是针对边的算法，采用并查集的方法。其首先以每个顶点单独作为一个集合，然后对所有边进行排序，选取最短的边，如果该边中两个节点不属于同一个并查集，那么就将这两个节点所属的并查集合并为同一个并查集，n个节点，共需要n-1条有效边。
并查集：定义一个father列表，一开始每个节点的father都是它自己，然后加入新节点后，新节点的father定义为这个并查集的总的father，然后每次判断两个节点是否在同一个并查集时，只需判断他们father是否相同即可。关于father的查找，可以用father[x] == x来判断，为True，就找到了该并查集的father。
同时father列表也可以用于保存最小生成树的形状。
而如果不需要保存最小生成树的形状，也可以在A、B并查集合并时，让B集中所有元素的father都等于A的father，这样每个节点都能直接找到最终father，能加快速度。
每发现一条有效边时，需要保存其权重，作为最终的权值之和。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d89730f6a55ec1e0b2c87da695056ae4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-10T09:32:18+08:00" />
<meta property="article:modified_time" content="2021-04-10T09:32:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">简单复习最小生成树算法-Prim和Kruskal</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考资料：</p> 
<ul><li>https://blog.csdn.net/qq_41754350/article/details/81460643</li><li>https://blog.csdn.net/qq_41754350/article/details/81271567</li><li>https://zhuanlan.zhihu.com/p/34922624</li></ul> 
<h3><a id="Prim_5"></a>Prim算法</h3> 
<p>Prim针对点，而Kruskal针对边。<strong>Prim只适合无向带权图</strong>。维持一个集合，一开始选定一个点作为初始集合，另维持一个prev和dist列表。dist列表表示初始集合到其余所有点的距离，prev表示新加入集合的节点的前一个节点。它的加入策略是：不属于集合的且离集合最近的点。<br> 即：Prim算法不断加入节点，直到所有节点都加入集合。<br> 需要注意Prim和Dijkstra算法很相似，Dijkstra也是维持一个节点列表，并不断往集合中添加节点，但是<strong>Dijkstra也适合有向图</strong>，而且Dijkstra计算的是单一源节点到其余所有节点的最短距离，而Prim生成的是使得所有边的权值之和最小。</p> 
<h3><a id="Kruskal_10"></a>Kruskal算法</h3> 
<p>Kruskal算法是针对边的算法，采用并查集的方法。其首先以每个顶点单独作为一个集合，然后<strong>对所有边进行排序</strong>，选取最短的边，如果该边中两个节点不属于同一个并查集，那么就将这两个节点所属的并查集合并为同一个并查集，n个节点，共需要n-1条有效边。<br> 并查集：定义一个father列表，一开始每个节点的father都是它自己，然后加入新节点后，新节点的father定义为这个并查集的总的father，然后每次判断两个节点是否在同一个并查集时，只需判断他们father是否相同即可。关于father的查找，可以用father[x] == x来判断，为True，就找到了该并查集的father。<br> 同时father列表也可以用于保存最小生成树的形状。<br> 而如果不需要保存最小生成树的形状，也可以在A、B并查集合并时，让B集中所有元素的father都等于A的father，这样每个节点都能直接找到最终father，能加快速度。<br> 每发现一条有效边时，需要保存其权重，作为最终的权值之和。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29a1afaee67c82087c6a3e3d8b6c3f80/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">查看SqlServer版本</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab11680672ab7049f7a2e9e2b5b896f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Oracle无法标识锁定数据文件,启动错误ORA-01157: 无法标识/锁定数据文件 解决方案...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>