<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>运筹优化问题-离散优化算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="运筹优化问题-离散优化算法" />
<meta property="og:description" content="启发式算法（heuristic algorithm)是相对于最优化算法提出的。一个问题的最优算法求得该问题每个实例的最优解。也就是说，在允许运行时长足够长的 情况下，确保得到一个最优方案。但是大量重要的ILP和INLP问题，并不存在多项式时间的解法，因此，启发式算法可以这样定义：一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。
计算机科学的两大基础目标，就是发现可证明其执行效率良好且可得最佳解或次佳解的算法。而启发式算法则试图一次提供一或全部目标。 例如它常能发现很不错的解，但也没办法证明它不会得到较坏的解；它通常可在合理时间解出答案，但也没办法知道它是否每次都可以这样的速度求解。
有时候人们会发现在某些特殊情况下，启发式算法会得到很坏的答案或效率极差，然而造成那些特殊情况的数据组合，也许永远不会在现实世界出现。因此现实世界中启发式算法常用来解决问题。启发式算法处理许多实际问题时通常可以在合理时间内得到不错的答案。
启发式算法可分为传统启发式算法和元启发式算法。传统启发式算法包括构造型方法、局部搜索算法、松弛方法、解空间缩减算法等。 元启发式算法包括禁忌搜索算法、模拟退火算法、遗传算法、蚁群优化算法、粒子群优化算法、人工鱼群算法、人工蜂群算法、人工神经网络算法等。
传统启发式算法 1.构造性启发式算法 该算法逐个选择离散决策变量的值，直到得到一个完整的可行解位置。该方法从部分解开始，一次只选择一个决策变量的值，经常在完成第一次可行方案时停止。
基础的构造性搜索算法，从每一个自由决策变量的离散分类开始，在每次迭代中，在当前决策解固定的情况下，一个先前的自由变量固定为一个可行值，也就是说，当我们替换以前的固定值并且采用自由变量时，为新分量所选定的值不应该产生违反约束的情况。在最简单的情况下，当没有自由变量存在时，搜索过程停止。
构造性搜索的主要难点在于，如何选择下一个待固定的自由变量并且确定它的值，而贪婪或者短视算法是解决这一问题最常见的方法。
贪婪算法的规则是，在目前已知内容的基础上，选择固定被选中概率最大的变量，从而得到更好的可行解。由于该算法在进行下次选择时只能依靠局部信息，因此在一般情况下这样做存在一定风险，在贪婪算法中一个只有少数变量固定的并且看起来变现很好的解实际上会迫使搜索进入可行空间中非常差的区域。
实际上，构造性搜索算法更适合求解大规模，并且通常是非线性的高度组合的离散模型或者需要快速求解的情况下，一般采用分支定界，分支切割等。
2.局部搜索 在搜索过程中，始终选择当前点的邻居中与离目标最近者的方向搜索。
算法过程
（1）随机选择一个初始的可能解x0 ∈D，xb=x0,P=N(xb);
//D是问题的定义域， xb用于记录到目标位置的最优解，P为xb的邻域。
（2）如果不满足结束条件，则： //结束条件为循环次数或P为空等
（3）Begin；
（4）选择P的一个子集P&#39;，xn为P’的最优解 ； //P’可根据问题特点，选择适当大小的子集。可按概率选择
（5）如果f(xn)&lt;f(xb)，则xb=xn，P=N(xb)，转(2)； //重新计算P，f(x)为指标函数
（6）否则P=P-P&#39;，转(2)；
（7）End；
（8）输出计算结果；
（9）结束 ；
3.爬山法 将搜索过程比作爬山过程，在没有任何有关山顶的其他信息的情况下，沿着高度增加的方向爬。如果相邻状态没有比当前值更高，则算法停止，认为当前值即为顶峰。
算法过程 （1） 设置初始状态n=s0为当前状态;
（2） 如果当前状态已达标，算法结束，搜索成功;
（3）获取当前状态n的若干个临近状态m,计算这些h(m), nextn=min{h(m)}；
（4） IF h(n) &lt; h(nextn) THEN n:=nextn;
ELSE 取当前状态为最佳状态并退出;
（5） GOTO (2)步;
该算法在单峰的条件下，必能达到山顶。 显而易见爬山法对于复杂情况的求解会遇到以下问题： （1）局部极值 （2）山脊：造成一系列的局部极值 （3）高原：平坦的局部极值区域——解决办法：继续侧向移动 目前有些改进的爬山法，比如随机爬山法、首选爬山法等等不再细说。它是禁忌搜索（Tabu Search）的基础，TS算法是在其上改进而来。
元启发式算法（Meta-heuristic Algorithm） 元启发式算法是启发式算法的改进，是随机算法与局部搜索算法相结合的产物。元启发式是一个迭代生成过程，通过对不同概念的智能组合，该过程以启发式算法实现对搜索空间的探索和开发。在这个过程中，学习策略被用来获取和掌握信息，以有效地发现近似最优解。
1.禁忌搜索算法 标记已经解得的局部最优解或求解过程，并在进一步的迭代中避开这些局部最优解或求解过程。局部搜索的缺点在于，太过于对某一局部区域以及其邻域的搜索，导致一叶障目。为了找到全局最优解，禁忌搜索就是对于找到的一部分局部最优解，有意识地避开它，从而或得更多的搜索区域
（1）给定一个禁忌表（Tabu List）H=null,并选定一个初始解X_now." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5a040fe5c97f6feafd8855f4393b9a00/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-29T17:08:21+08:00" />
<meta property="article:modified_time" content="2023-09-29T17:08:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">运筹优化问题-离散优化算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <div id="article_content" class="article_content clearfix"> 
 <div id="content_views" class="htmledit_views"> 
  <p><a href="https://so.csdn.net/so/search?q=%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" rel="noopener noreferrer">启发式算法</a>（heuristic algorithm)是相对于最优化算法提出的。一个问题的最优算法求得该问题每个实例的最优解。也就是说，在允许运行时长足够长的 情况下，确保得到一个最优方案。但是大量重要的ILP和INLP问题，并不存在<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E9%A1%B9%E5%BC%8F&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" rel="noopener noreferrer">多项式</a>时间的解法，因此，启发式算法可以这样定义：一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。</p> 
  <p>计算机科学的两大基础目标，就是发现可证明其执行效率良好且可得最佳解或次佳解的算法。而启发式算法则试图一次提供一或全部目标。 例如它常能发现很不错的解，但也没办法证明它不会得到较坏的解；它通常可在合理时间解出答案，但也没办法知道它是否每次都可以这样的速度求解。</p> 
  <p>有时候人们会发现在某些特殊情况下，启发式算法会得到很坏的答案或效率极差，然而造成那些特殊情况的数据组合，也许永远不会在现实世界出现。因此现实世界中启发式算法常用来解决问题。启发式算法处理许多实际问题时通常可以在合理时间内得到不错的答案。</p> 
  <p>启发式算法可分为传统启发式算法和元启发式算法。传统启发式算法包括构造型方法、局部搜索算法、松弛方法、解空间缩减算法等。 元启发式算法包括禁忌搜索算法、模拟退火算法、遗传算法、蚁群优化算法、粒子群优化算法、人工鱼群算法、人工蜂群算法、人工神经网络算法等。</p> 
  <h3>传统启发式算法</h3> 
  <h4>1.构造性启发式算法</h4> 
  <p>该算法逐个选择离散决策变量的值，直到得到一个完整的可行解位置。该方法从部分解开始，一次只选择一个决策变量的值，经常在完成第一次可行方案时停止。</p> 
  <p>基础的构造性搜索算法，从每一个自由决策变量的离散分类开始，在每次迭代中，在当前决策解固定的情况下，一个先前的自由变量固定为一个可行值，也就是说，当我们替换以前的固定值并且采用自由变量时，为新分量所选定的值不应该产生违反约束的情况。在最简单的情况下，当没有自由变量存在时，搜索过程停止。</p> 
  <p>构造性搜索的主要难点在于，如何选择下一个待固定的自由变量并且确定它的值，而贪婪或者短视算法是解决这一问题最常见的方法。</p> 
  <p>贪婪算法的规则是，在目前已知内容的基础上，选择固定被选中概率最大的变量，从而得到更好的可行解。由于该算法在进行下次选择时只能依靠局部信息，因此在一般情况下这样做存在一定风险，在贪婪算法中一个只有少数变量固定的并且看起来变现很好的解实际上会迫使搜索进入可行空间中非常差的区域。</p> 
  <p>实际上，构造性搜索算法更适合求解大规模，并且通常是非线性的高度组合的离散模型或者需要快速求解的情况下，一般采用分支定界，分支切割等。</p> 
  <h4>2.局部搜索</h4> 
  <p>在搜索过程中，始终选择当前点的邻居中与离目标最近者的方向搜索。</p> 
  <p>算法过程</p> 
  <blockquote> 
   <p>（1）随机选择一个初始的可能解x0 ∈D，xb=x0,P=N(xb);<br>      //D是问题的定义域， xb用于记录到目标位置的最优解，P为xb的邻域。<br> （2）如果不满足结束条件，则： <br>     //结束条件为循环次数或P为空等<br> （3）Begin；<br> （4）选择P的一个子集P'，xn为P’的最优解 ；      <br>     //P’可根据问题特点，选择适当大小的子集。可按概率选择<br> （5）如果f(xn)&lt;f(xb)，则xb=xn，P=N(xb)，转(2)；    <br>     //重新计算P，f(x)为指标函数<br> （6）否则P=P-P'，转(2)；<br> （7）End；<br> （8）输出计算结果；<br> （9）结束 ；</p> 
  </blockquote> 
  <h4 id="爬山法">3.爬山法</h4> 
  <p>将搜索过程比作爬山过程，在没有任何有关山顶的其他信息的情况下，沿着高度增加的方向爬。如果相邻状态没有比当前值更高，则算法停止，认为当前值即为顶峰。</p> 
  <h4 id="算法过程-1">算法过程</h4> 
  <blockquote> 
   <p>（1） 设置初始状态n=s0为当前状态;<br> （2） 如果当前状态已达标，算法结束，搜索成功;<br> （3）获取当前状态n的若干个临近状态m,计算这些h(m), nextn=min{h(m)}；<br> （4） IF h(n) &lt; h(nextn) <br>     THEN  n:=nextn;<br>     ELSE 取当前状态为最佳状态并退出;<br> （5） GOTO (2)步;</p> 
  </blockquote> 
  <p>该算法在单峰的条件下，必能达到山顶。 <br> 显而易见爬山法对于复杂情况的求解会遇到以下问题： <br> （1）局部极值 <br> （2）山脊：造成一系列的局部极值 <br> （3）高原：平坦的局部极值区域——解决办法：继续侧向移动 <br> 目前有些改进的爬山法，比如随机爬山法、首选爬山法等等不再细说。它是禁忌搜索（Tabu Search）的基础，TS算法是在其上改进而来。</p> 
  <h3>元启发式算法（Meta-heuristic Algorithm）</h3> 
  <p>元启发式算法是启发式算法的改进，是随机算法与局部搜索算法相结合的产物。元启发式是一个迭代生成过程，通过对不同概念的智能组合，该过程以启发式算法实现对搜索空间的探索和开发。在这个过程中，学习策略被用来获取和掌握信息，以有效地发现近似最优解。</p> 
  <h4>1.禁忌搜索算法</h4> 
  <p>标记已经解得的局部最优解或求解过程，并在进一步的迭代中避开这些局部最优解或求解过程。局部搜索的缺点在于，太过于对某一局部区域以及其邻域的搜索，导致一叶障目。为了找到全局最优解，禁忌搜索就是对于找到的一部分局部最优解，有意识地避开它，从而或得更多的搜索区域</p> 
  <blockquote> 
   <p>（1）给定一个禁忌表（Tabu List）H=null,并选定一个初始解X_now.<br> （2）如果满足停止规则，则停止计算，输出结果；否则，在X_now的领域中选出满足不受禁忌的候选集N(X_now).</p> 
   <p>在N(X_now)中选择一个评价值最贱的解X_next，X_next：=X_now；更新历史记录H, 重复步骤（2）.</p> 
  </blockquote> 
  <p> TS算法构成要素:</p> 
  <p>(1)编码方式</p> 
  <p>将不相同的n件物品分为m组，可以用的编码：</p> 
  <p>a、带分隔符的顺序编码</p> 
  <p>以自然数1~n分别代表n件物品，n个数加上m-1个分割符号混编在一起，随机排列。如：1-3-4-0-2-6-7-5-0-8-9</p> 
  <p>b、自然数编码</p> 
  <p>编码的每一位分别代表一件物品，而每一位的值代表该物品所在的分组。如：1-2-1-1-2-2-2-3-3</p> 
  <p>(2)初始解的获取</p> 
  <p>可以随机给出初始解，也可以事先使用其他启发式等算法给出一个较好的初始解。  </p> 
  <p>(3)移动邻域</p> 
  <p>移动是从当前解产生新解的途径，例如上述问题中用移动s产生新解s(x)。从当前解可以进行的所有移动构成邻域，也可以理解为从当前解经过“一步”可以到达的区域。</p> 
  <p>(4)禁忌表</p> 
  <p>禁忌表的作用：防止搜索出现循环</p> 
  <p>a.记录前若干步走过的点、方向或目标值，禁止返回</p> 
  <p>b.表是动态更新的</p> 
  <p>c.表的长度称为Tabu-Size</p> 
  <p>禁忌表的主要指标（两项指标）</p> 
  <p>禁忌对象：禁忌表中被禁的那些变化元素</p> 
  <p>禁忌长度：禁忌的步数</p> 
  <p>禁忌对象（三种变化）</p> 
  <p>以状态本身或者状态的变化作为禁忌对象</p> 
  <p>以状态分量以及分量的变化作为禁忌对象</p> 
  <p>采用类似的等高线做法，以目标值变化作为禁忌对象</p> 
  <p>禁忌长度:可以是一个固定的常数(T=c),也可以是动态变化的，可按照某种规则或公式在区间内变化。</p> 
  <p>禁忌长度过短，一旦陷入局部最优点，出现循环无法跳出；<br> 禁忌长度过长，候选解全部被禁忌，造成计算时间较大，也可能造成计算无法继续下去。<br> (5)渴望水平函数</p> 
  <p>A(x，s)一般为历史上曾经达到的最好目标值，若有C(s(x))&lt;A(x，s)则S(x)是不受T表限制。即使s(x)∈T，仍可取 x=s(x)。A(x，s)称为渴望水平函数。</p> 
  <p>(6)停止准则</p> 
  <p>a.给定最大迭代步数（最常用 )</p> 
  <p>b.设定某个对象的最大禁忌频率。</p> 
  <p>c.设定适配值的偏离阈值。</p> 
  <p>对搜索性能有影响的因素：<br><strong>禁忌长度</strong><br> 控制其他变量，单就禁忌长度的选择而言，禁忌长度越短，机器内存占用越少，解禁范围更大（搜索范围上限越大），但很容易造成搜索循环（实际去搜索的范围却很小），过早陷入局部最优。禁忌长度过长又会导致计算时间过长。</p> 
  <p><strong>特赦规则</strong><br> 通俗定义：对于在禁忌的对象，如果出现以下情况，不论现在对象的禁忌长度如何，均设为0 <br> （1）基于评价值的规则，若出现一个解的目标值好于前面任何一个最佳候选解，可特赦； <br> （2）基于最小错误的规则，若所有对象都被禁忌，特赦一个评价值最小的解； <br> （3）基于影响力的规则，可以特赦对目标值影响大的对象。</p> 
  <p><strong>候选集</strong><br> 候选集的大小，过大增加计算内存和计算时间，过小过早陷入局部最优。候选集的选择一般由邻域中的邻居组成，可以选择所有邻居，也可以选择表现较好的邻居，还可以随机选择几个邻居。</p> 
  <p><strong>评价函数</strong><br> 评价函数分为直接评价函数和间接评价函数。 <br> 直接评价函数：上述例子，均直接使用目标值作为评价函数。 <br> 间接评价函数：反映目标函数特性的函数（会比目标函数的计算更为简便，用以减少计算时间等）。</p> 
  <p><strong>终止规则</strong><br> 禁忌算法是一个启发式算法，我们不可能让搜索过程无穷进行，所以一些直观的终止规则就出现了 <br> （1）确定步数终止，无法保证解的效果，应记录当前最优解； <br> （2）频率控制原则，当某一个解、目标值或元素序列的频率超过一个给定值时，终止计算； <br> （3）目标控制原则，如果在一个给定步数内，当前最优值没有变化，可终止计算。</p> 
  <h4>2.模拟退火(SA,Simulated Annealing)</h4> 
  <p>爬山法是完完全全的贪心法，每次都鼠目寸光的选择一个当前最优解，因此只能搜索到局部的最优值。模拟退火其实也是一种贪心算法，但是它的搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。</p> 
  <p><strong>模拟退火算法描述</strong>：<br>         若J( Y(i+1) )&gt;= J( Y(i) )  (即移动后得到更优解)，则总是接受该移动</p> 
  <p>        若J( Y(i+1) )&lt; J( Y(i) )  (即移动后的解比当前解要差)，则以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定）</p> 
  <p>　　这里的“一定的概率”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。</p> 
  <p>　　根据热力学的原理，在温度为T时，出现能量差为dE的降温的概率为P(dE)，表示为：P(dE) = exp( dE/(kT) )</p> 
  <p>　　其中k是一个常数，exp表示自然指数，且dE&lt;0。这条公式说白了就是：温度越高，出现一次能量差为dE的降温的概率就越大；温度越低，则出现降温的概率就越小。又由于dE总是小于0（否则就不叫退火了），因此dE/kT &lt; 0 ，所以P(dE)的函数取值范围是(0,1) 。</p> 
  <p>　　随着温度T的降低，P(dE)会逐渐降低。</p> 
  <p><strong>使用模拟退火算法解决旅行商问题</strong><br> 旅行商问题 ( TSP , Traveling Salesman Problem ) ：有N个城市，要求从其中某个问题出发，唯一遍历所有城市，再回到出发的城市，求最短的路线。</p> 
  <p>旅行商问题属于所谓的NP完全问题，精确的解决TSP只能通过穷举所有的路径组合，其时间复杂度是O(N!) 。</p> 
  <p>使用模拟退火算法可以比较快的求出TSP的一条近似最优路径。</p> 
  <p><strong>模拟退火解决TSP的思路：</strong></p> 
  <p>a. 产生一条新的遍历路径P(i+1)，计算路径P(i+1)的长度L( P(i+1) )</p> 
  <p>b. 若L(P(i+1)) &lt; L(P(i))，则接受P(i+1)为新的路径，否则以模拟退火的那个概率接受P(i+1) ，然后降温</p> 
  <p>c. 重复步骤1，2直到满足退出条件。</p> 
  <p>产生新的遍历路径的方法有很多，下面列举其中3种：<br> a. 随机选择2个节点，交换路径中的这2个节点的顺序。</p> 
  <p>b. 随机选择2个节点，将路径中这2个节点间的节点顺序逆转。</p> 
  <p>c. 随机选择3个节点m，n，k，然后将节点m与n间的节点移位到节点k后面。</p> 
  <h4>3.遗传算法</h4> 
  <p>遗传算法（Genetic Algorithm, GA）起源于对生物系统所进行的计算机模拟研究。它是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解。</p> 
  <p>相关术语</p> 
  <p>编码(coding)：将物体的表现型用编码的方式转为程序可控的基因型。</p> 
  <p>比如现在要计算北京、天津、广东、新疆这四个城市的一条最优路径，但算法程序不能够直接处理北京、天津、广东、新疆这些数据，所以我们得给它们编上号，北京（0）、天津（1）、广东（2）、新疆（3），路径（天津-&gt;新疆-&gt;北京-&gt;广东）可以表示成基因型串结构数据 （1302），这样算法程序只要直接处理它们的编号就行了。<br> （1）二进制编码，基因用0或1表示（常用于解决01背包问题）</p> 
  <p>如：基因A：00100011010 (代表一个个体的染色体)<br> （2）互换编码（用于解决排序问题，如旅行商问题和调度问题）</p> 
  <p>如旅行商问题中，一串基因编码用来表示遍历的城市顺序，如：234517986，表示九个城市中，先经过城市2，再经过城市3，依此类推。<br> 解码(decoding)：基因型到表现型的映射。</p> 
  <p>基因型(genotype)：参数的因子；</p> 
  <p>表现型(phenotype)：根据不同因子最终展现的形态；</p> 
  <p>适应度(fitness)：度量某个结果的好坏。</p> 
  <p>进化(evolution)：不断剔除差的结果，最终逐步留下好的结果。</p> 
  <p>选择(selection)：以一定的概率从种群中选择若干个个体留下，并繁殖。选择过程是一种基于适应度的优胜劣汰的过程。</p> 
  <p>复制(reproduction)：将父本、母本的基因复制，以便产生下一代。</p> 
  <p>交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交；</p> 
  <p>（1）单交叉点法 （用于二进制编码）</p> 
  <p>选择一个交叉点,子代在交叉点前面的基因从一个父代基因那里得到,后面的部分从另外一个父代基因那里得到。如：交叉前00000|01110000000010000<br> ​11100|00000111111000101<br> ​交叉后：<br> ​00000|00000111111000101<br> ​11100|01110000000010000<br> ​（2）双交叉点法 （用于二进制编码）<br> ​选择两个交叉点,子代基因在两个交叉点间部分来自一个父代基因,其余部分来自于另外一个父代基因.<br> ​如：交叉前：<br> ​01 |0010| 11<br> ​11 |0111| 01<br> ​交叉后：<br> ​11 |0010| 01<br> ​01 |0111| 11<br> ​（3）基于“ 与/或 ”交叉法 （用于二进制编码）<br> ​对父代按位"与”逻辑运算产生一子代A;按位”或”逻辑运算产生另一子代B。该交叉策略在解背包问题中效果较好 .<br> ​如：交叉前：<br> ​01001011<br> ​11011101<br> ​交叉后：<br> ​01001001<br> ​11011111<br> ​（4）单交叉点法 （用于互换编码）<br> ​选择一个交叉点，子代的从初始位置出发的部分从一个基因复制，然后在另一个基因中扫描，如果某个位点在子代中没有，就把它添加进去。<br> ​如：交叉前：<br> ​87213 | 09546<br> ​98356 | 71420<br> ​交叉后：<br> ​87213 | 95640<br> ​98356 | 72104<br> ​（5）部分匹配交叉（PMX）法（用于互换编码）<br> ​先随机产生两个交叉点，定义这两点间的区域为匹配区域，并用交换两个父代的匹配区域。<br> ​父代A：872 | 130 | 9546<br> ​父代B：983 | 567 | 1420    变为：<br> ​TEMP A: 872 | 567 | 9546<br> ​TEMP B: 983 | 130 | 1420<br> ​对于 TEMP A、TEMP Ｂ中匹配区域以外出现的数码重复，要依据匹配区域内的位置逐一进行替换。匹配关系：1&lt;——&gt;５　３&lt;——&gt;６　７&lt;——&gt;０<br> ​子代Ａ：802 | 567 | 9143<br> ​子代Ｂ：986 | 130 | 5427<br> ​（6）顺序交叉法(OX) （用于互换编码）<br> ​从父代Ａ随机选一个编码子串，放到子代Ａ的对应位置；子代Ａ空余的位置从父代Ｂ中按Ｂ的顺序选取（与己有编码不重复）。同理可得子代Ｂ。<br> ​父代A: 872 | 139 | 0546<br> ​父代B: 983 | 567 | 1420<br> ​交叉后：<br> ​子代A: 856 | 139 | 7420<br> ​子代B: 821 | 567 | 3904<br> ​（7）循环交叉（CX）（用于互换编码）<br> ​CX同OX交叉都是从一个亲代中取一些城市，而其它城市来自另外一个亲代，但是二者不同之处在于：OX中来自第一个亲代的编码子串是随机产生的，而CX却不是，它是根据两个双亲相应位置的编码而确定的。<br> ​父代A：1 2 3 4 5 6 7 8 9<br> ​父代B：5 4 6 9 2 3 7 8 1<br> ​可得循环基因：1-&gt;5-&gt;2-&gt;4-&gt;3-&gt;6-&gt;9-&gt;7-&gt;8<br> ​子代Ｂ的编码同理。（循环基因 5-&gt;1-&gt;4-&gt;2-&gt;6-&gt;3-&gt;9-&gt;7-&gt;8）<br> 变异(mutation)：交叉后可能（很小的概率）对染色体进行更改，来防止算法过早收敛而陷入局部最优解中。</p> 
  <p>变异概率Pm不能太小，这样降低全局搜索能力；也不能太大，Pm &gt; 0.5，这时GA退化为随机搜索。</p> 
  <p>（1）基本位变异算子（用于二进制编码）</p> 
  <p>基本位变异算子是指对个体编码串随机指定的某一位或某几位基因作变异运算。对于基本遗传算法中用二进制编码符号串所表示的个体，若需要进行变异操作的某一基因座上的原有基因值为0，则变异操作将其变为1；反之，若原有基因值为1，则变异操作将其变为0。</p> 
  <p>变异前：000001110000000010000</p> 
  <p>变异后：000001110001000010000</p> 
  <p>（2）逆转变异算子（用于互换编码）（源代码中使用类似此方法）</p> 
  <p>在个体中随机挑选两个逆转点，再将两个逆转点间的基因交换。</p> 
  <p>变异前：1346798205</p> 
  <p>变异后：1246798305</p> 
  <p>个体（individual）：指染色体带有特征的实体；</p> 
  <p>种群（population）：个体的集合，该集合内个体数称为种群的大小</p> 
  <p>遗传算法步骤<br> 对潜在问题进行编码，初始化基因组，并根据基因组随机初始化种群，并指定繁衍代数。</p> 
  <p>计算种群中每个个体的适应度，选择一定数目的留下，其余淘汰。</p> 
  <p>在留下的个体中，随机繁衍，对分母基因进行交叉（极小概率变异），产生下一代。</p> 
  <p>回到第2步进行循环。直到达到指定的繁衍代数</p> 
  <h4>4.蚁群优化算法</h4> 
  <p>简单介绍一下蚁群算法的思路。我们尝试复原一下蚂蚁寻找食物的场景。想象有一只蚂蚁找到了食物，这时它需要将食物带回蚁穴。对于这一只蚂蚁而言，它显然并不知道应该怎么走。那么，这只蚂蚁有可能会随机选择一条路线。</p> 
  <p>这条路线很可能是一条远路。但是，蚂蚁一路上留下了记号，也就是信息素。如果这只蚂蚁继续不停地搬运食物，或者有许多其他蚂蚁一块搬运的话。他们总会在运气好的时候走到更快往返的路线上。蚂蚁选择的路越好，相同时间内往返的次数也就更多，也就在路上留下了更多的信息素。</p> 
  <p>于是，蚂蚁们总会发现，有一些路径的信息素更浓，这些路径就是更好的路线。于是蚂蚁也就更多地向信息素更浓的路径上偏移。蚂蚁们不停重复这个过程，最终总能找到一条确定的路线，而这条路线就是蚂蚁们找到的最优路径。</p> 
  <p>蚁群算法步骤<br> 初始化蚂蚁数量、可行路段、每条路段距离、每条路段的初始信息素大小等信息</p> 
  <p>设定蚂蚁的起点、终点。</p> 
  <p>蚂蚁从起点出发根据信息素浓度，有一定的概率性选择路段，浓度越高，概率越大，逐步回到终点。</p> 
  <p>在蚂蚁走过的路径上，根据每条路段的长度按比例释放信息素，短的路段释放的信息素多，长的路段释放的信息素少。</p> 
  <p>对所有路段的信息素进行挥发。</p> 
  <p>回到第二步进行循环，直到蚂蚁数量迭代完。</p> 
  <h4>5.粒子群优化算法</h4> 
  <p>粒子群算法是模拟群体智能所建立起来的一种优化算法，粒子群算法可以用鸟类在一个空间内随机觅食为例，所有的鸟都不知道食物具体在哪里，但是他们知道大概距离多远，最简单有效的方法就是搜寻目前离食物最近的鸟的周围区域。所以，粒子群算法就是把鸟看成一个个粒子，并且他们拥有位置和速度这两个属性，然后根据自身已经找到的离食物最近的解和参考整个共享于整个集群中找到的最近的解去改变自己的飞行方向，最后我们会发现，整个集群大致向同一个地方聚集。而这个地方是离食物最近的区域，条件好的话就会找到食物。这就是粒子群算法。</p> 
  <p>算法描述   <br> 所以，我们需要一个pbest来记录个体搜索到的最优解，用gbest来记录整个群体在一次迭代中搜索到的最优解。速度和粒子位置的更新公式如下：</p> 
  <p>    v[i] = w * v[i] + c1 * rand() *(pbest[i] - present[i]) + c2 * rand() * (gbest - present[i])    </p> 
  <p>    present[i]=present[i]+v[i]                                                      </p> 
  <p>    其中v[i]代表第i个粒子的速度，w代表惯性权值,c1和c2表示学习参数，rand()表示在0-1之间的随机数,pbest[i]代表第i个粒子搜索到的最优值,gbest代表整个集群搜索到的最优值,present[i]代表第i个粒子的当前位置。</p> 
  <p>标准PSO算法的流程：<br> 　　Step1:初始化一群微粒(群体规模为m)，包括随机位置和 速度；</p> 
  <p>　　Step2:评价每个微粒的适应度；</p> 
  <p>　　Step3:对每个微粒，将其适应值与其经过的最好位置 pbest作比较，如果较好，则将其作为当前的 最好位置pbest;</p> 
  <p>　　Step4:对每个微粒，将其适应值与其经过的最好位置 gbest作比较，如果较好，则将其作为当前的 最好位置gbest;</p> 
  <p>　　Step5:根据(2)、(3)式调整微粒速度和位置；</p> 
  <p>　　Step6：未达到结束条件则转Step2。</p> 
  <h4>6.人工鱼群算法</h4> 
  <p>在一片水域中，鱼往往能自行或尾随其他鱼找到营养物质多的地方，因而鱼生存数目最多的地方一般就是本水域中营养物质最多的地方，人工鱼群算法就是根据这一特点，通过构造人工鱼来模仿鱼群的觅食、聚群及追尾行为，从而实现寻优。</p> 
  <p>以下是鱼的几种典型行为:</p> 
  <p>(1)觅食行为：一般情况下鱼在水中随机地自由游动,当发现食物时,则会向食物逐渐增多的方向快速游去。</p> 
  <p>(2)聚群行为:鱼在游动过程中为了保证自身的生存和躲避危害会自然地聚集成群，鱼聚群时所遵守的规则有三条：</p> 
  <p>分隔规则：尽量避免与临近伙伴过于拥挤;</p> 
  <p>对准规则:尽量与临近伙伴的平均方向一致;</p> 
  <p>内聚规则:尽量朝临近伙伴的中心移动。</p> 
  <p>(3)追尾行为：当鱼群中的一条或几条鱼发现食物时,其临近的伙伴会尾随其快速到达食物点。</p> 
  <p>(4)随机行为：单独的鱼在水中通常都是随机游动的，这是为了更大范围地寻找食物点或身边的伙伴。</p> 
  <p>特点：</p> 
  <p>1)具有较快的收敛速度，可以用于解决有实时性要求的问题；</p> 
  <p>2)对于一些精度要求不高的场合，可以用它快速的得到一个可行解；</p> 
  <p>3)不需要问题的严格机理模型，甚至不需要问题的精确描述，这使得它的应用范围得以延伸。</p> 
  <p>停止条件：</p> 
  <p>1) 判断连续多次所得的均方差小于允许的误差；</p> 
  <p>2)判断某个区域的人工鱼群的数目达到某个比率；</p> 
  <p>3)连续多次所获取的值均不能超过已找到的极值。</p> 
  <p>4）迭代次数达到预设次数</p> 
  <p></p> 
  <h4>7.人工蜂群算法</h4> 
  <p>为了解决多变量函数优化问题Karaboga在2005年提出了人工蜂群算法ABC模型。</p> 
  <p>1、 蜜蜂采蜜机理</p> 
  <p>蜜蜂是一种群居昆虫，虽然单个昆虫的行为极其简单，但是由单个简单的个体所组成的群体却表现出极其复杂的行为。真实的蜜蜂种群能够在任何环境下，以极高的效率从食物源（花朵）中采集花蜜；同时，它们能适应环境的改变。</p> 
  <p>蚁群产生群体智慧的最小搜索模型包含基本的三个组成要素：食物源、被雇佣的蜜蜂和未被雇佣的蜜蜂。两种最基本的行为模型：为食物源招募蜜蜂和放弃某个食物源。</p> 
  <p>(1) 食物源</p> 
  <p>食物源的价值由多方面因素决定，如：离蜂巢的远近、包含花蜜的丰富程度和获得花蜜的难易程度。使用单一的参数，食物源的“收益率”来代表以上各个因素。</p> 
  <p>(2) 被雇佣的蜜蜂</p> 
  <p>也称引领蜂，其与所采集的食物源一一对应。引领蜂储存有食物源的相关信息(相对与蜂巢的距离、方向和食物源的丰富程度等)并把这些信息以一定的概率与其他蜜蜂分享。</p> 
  <p>(3) 未被雇佣的蜜蜂</p> 
  <p>其主要任务是寻找和开采食物源。有两种未被雇佣的蜜蜂：侦查蜂和跟随蜂。侦查蜂搜索附近的新食物源；跟随蜂等在蜂巢里面并通过与引领蜂分享相关信息找到食物源。一般情况下，侦查蜂的数量是蜂群的5%--20%</p> 
  <p>在群体智慧形成过程中，蜜蜂间交换信息是最重要的一环。舞蹈区是蜂巢中最为重要的信息交换地。蜜蜂的舞蹈也叫摇摆舞。食物源的信息在舞蹈区通过摇摆舞的形式与其他蜜蜂共享，引领蜂通过摇摆舞的持续时间等来表现食物源的收益率，故跟随蜂可以观察到大量的舞蹈并依据收益率来选择到哪个食物源采蜜。收益率与食物源被选择的可能性成正比。因而，蜜蜂被招募到一个食物源的概率与食物源的收益率成正比。</p> 
  <p>初始时刻，蜜蜂以侦查蜂的方式搜索。其搜索可以由系统的先验知识决定，也可以完全随机。经过一轮侦查后，若蜜蜂找到食物源，蜜蜂利用它本身的存储能力记录位置信息并开始采蜜。此时，蜜蜂将称为“被雇佣者”。蜜蜂在食物源采蜜后回到蜂巢卸下蜂蜜，然后将有如下选择：</p> 
  <p>(1) 放弃食物源而成为非雇佣蜂；</p> 
  <p>(2) 跳摇摆舞为所对应的食物源招募更多的蜜蜂，然后回到食物源采蜜；</p> 
  <p>(3) 继续在食物源采蜜而不进行招募。</p> 
  <p>对于非雇佣蜂有如下选择：</p> 
  <p>(1) 转变为侦查蜂并搜索蜂巢附近的食物源，其搜索可以由先验知识决定也可以完全随机；</p> 
  <p>(2) 在观察完摇摆舞以后，被雇佣成为跟随蜂，开始搜索对应食物源领域并采蜜。</p> 
  <p>2、 ABC算法原理</p> 
  <p>在基本ABC算法中，人工蜂群包含三种个体：雇佣蜂、观察蜂和侦查蜂</p> 
  <p>每个雇佣蜂对应一个确定的蜜源(解向量)，并在迭代中对蜜源的领域进行搜索。</p> 
  <p>根据蜜源的丰富程度(适应值的大小)采用轮盘赌的方式雇佣观察蜂采蜜(搜索新蜜源)</p> 
  <p>如果蜜源多次更新没有改进，则放弃该蜜源，雇佣蜂转为侦查蜂随机搜索新蜜源。</p> 
  <p>(1) 随机初始化</p> 
  <p>(2) 新蜜源的更新搜索公式</p> 
  <p>(3) 观察蜂选择雇佣蜂的概率</p> 
  <p>(4) 侦查蜂的产生</p> 
  <p>为了防止算法陷入局部最优，当蜜源迭代limit次没有改进时，便放弃该蜜源，并且将该蜜源记录在禁忌表中，同时该蜜源对应的雇佣蜂转变为侦查蜂按式(1)随机产生一个新的位置代替原蜜源。</p> 
  <p>3、 控制参数</p> 
  <p>(1) 蜜源的个数(与雇佣蜂或观察蜂相等)SN</p> 
  <p>(2) 算法终止的最大进化数(maximum evaluation number)MEN</p> 
  <p>(3) Limit</p> 
  <p>基本ABC算法的流程为</p> 
  <p>(1) 根据式(1)初始化种群解xi，i=1,2，…,SN;</p> 
  <p>(2) 计算种群中各蜜蜂的适应值</p> 
  <p>(3) cycle=1</p> 
  <p>(4) repeat</p> 
  <p>(5) 雇佣蜂根据(2)产生新的解vi并计算适应值</p> 
  <p>(6) 雇佣蜂根据贪心策略选择蜜源</p> 
  <p>(7) 根据(3)式计算选择蜜源xi的概率pi</p> 
  <p>(8) 观察蜂根据概率pi选择蜜源xi，根据(2)式在该蜜源附近产生新的蜜源vi，并计算新蜜源vi的适应值</p> 
  <p>(9) 观察蜂根据贪心算法选择蜜源</p> 
  <p>(10) 决定是否存在需要放弃的蜜源，如果存在，根据(1)式随机产生一个蜜源代替它</p> 
  <p>(11) 记录最优解</p> 
  <p>(12) cycle = cycle + 1</p> 
  <p>(13) until cycle=MCN</p> 
  <p>4、 算法可能的改进方式</p> 
  <p>(1) 新蜜源的搜索领域(2)式的改进(如：其他拓扑邻域)</p> 
  <p>(2) 观察蜂选择雇佣蜂的概率(3)式的改进(如：动态的)</p> 
  <h4>8.人工神经网络算法</h4> 
  <p>这里不用多说了。</p> 
  <p>总结：</p> 
  <p>启发式算法蕴含着许多人生哲学，它虽不是数学方法，其思想更类似于人类解决问题的思想和一些人生中总结的道理，值得好好体会。最后用网上一段描述局部搜索的例子来作为总结：</p> 
  <p>为了找出地球上最高的山，一群有志气的兔子们开始想办法。</p> 
  <p>· 兔子朝着比现在高的地方跳去。他们找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是Iterative Improvement，它不能保证局部最优值就是全局最优值。</p> 
  <p>·兔子喝醉了。他随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，他渐渐清醒了并朝最高方向跳去。这就是模拟退火。</p> 
  <p>·兔子们知道一个兔的力量是渺小的。他们互相转告着，哪里的山已经找过，并且找过的每一座山他们都留下一只兔子做记号。他们制定了下一步去哪里寻找的策略。这就是禁忌搜索。</p> 
  <p>兔子们吃了失忆药片，并被发射到太空，然后随机落到了地球上的某些地方。他们不知道自己的使命是什么。但是，如果你过几年就杀死一部分海拔低的兔子，多产的兔子们自己就会找到珠穆朗玛峰。这就是遗传算法。</p> 
  <p><img alt="" class="has" height="427" src="https://images2.imgbox.com/db/67/8kNyLh1K_o.jpg" width="845"></p> 
  <p>参考：https://blog.csdn.net/zj15527620802/article/details/82121414 </p> 
 </div> 
 <div> 
  <div></div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0a06dc0b8b8c9e71ea4d35aad5d82f79/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微服务治理：构建强大、健壮的分布式系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fe014c5a241a398fe90e562ec9229ca3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">freertos中函数调用和启动第一个任务(栈相关!!!!!!）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>