<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VC Ping IP的类 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VC Ping IP的类" />
<meta property="og:description" content="Pingip.cpp #include “stdafx.h” #include “ping.h” void CPing::Ping(UINT nRetries,LPCSTR pstrHost,HWND hWnd) { SOCKET	rawSocket; LPHOSTENT lpHost; UINT	nLoop; int nRet; struct sockaddr_in saDest; struct sockaddr_in saSrc; DWORD	dwTimeSent; DWORD	dwElapsed; u_char cTTL; m_hWnd = hWnd; CString str; //创建一个Raw套接字 rawSocket = socket(AF_INET,SOCK_RAW,IPPROTO_ICMP); if (rawSocket == SOCKET_ERROR) { CString strMsg; strMsg.Format(“创建套接字发生错误 – WSAError: %ld”,WSAGetLastError()); //发送报错信息 SendMessage(m_hWnd,WM_MSG_STATUS,0,(LPARAM) AllocBuffer(strMsg)); return; } //获得主机信息 lpHost = gethostbyname(pstrHost); //构造目标套接字地址信息 saDest.sin_addr.s_addr = *((u_long FAR *)(lpHost-&gt;h_addr)); saDest.sin_family = AF_INET; saDest." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f5e77b196ae7619beb00228fb8d7564f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-05T01:47:20+08:00" />
<meta property="article:modified_time" content="2019-07-05T01:47:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VC Ping IP的类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body">
  Pingip.cpp 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-cpp">#include “stdafx.h”
#include “ping.h”
void CPing::Ping(UINT nRetries,LPCSTR pstrHost,HWND hWnd)
{
SOCKET	  rawSocket;
LPHOSTENT lpHost;
UINT	  nLoop;
int       nRet;
struct    sockaddr_in saDest;
struct    sockaddr_in saSrc;
DWORD	  dwTimeSent;
DWORD	  dwElapsed;
u_char    cTTL;
m_hWnd = hWnd;
CString str;
//创建一个Raw套接字
rawSocket = socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);
if (rawSocket == SOCKET_ERROR)
{
CString strMsg;
strMsg.Format(“创建套接字发生错误 – WSAError: %ld”,WSAGetLastError());
//发送报错信息
SendMessage(m_hWnd,WM_MSG_STATUS,0,(LPARAM) AllocBuffer(strMsg));
return;
}
//获得主机信息
lpHost = gethostbyname(pstrHost);
//构造目标套接字地址信息
saDest.sin_addr.s_addr = *((u_long FAR *)(lpHost-&gt;h_addr));
saDest.sin_family = AF_INET;
saDest.sin_port = 70;
//ping
for (nLoop = 0; nLoop &lt; nRetries; nLoop++)
{
//发送ICMP回应请求
SendEchoRequest(rawSocket, &amp;saDest);
nRet = WaitForEchoReply(rawSocket);
if (!nRet)
{
str.Format(“Request Timed Out”);
SendMessage(m_hWnd,WM_MSG_STATUS,3,(LPARAM)AllocBuffer(str));
}
else
{
//获得回应
dwTimeSent = RecvEchoReply(rawSocket,&amp;saSrc,&amp;cTTL);
//计算时间
dwElapsed = GetTickCount() – dwTimeSent;
str.Format(“Reply from: %s: bytes=%d time=%ldms TTL=%d”,
inet_ntoa(saSrc.sin_addr),REQ_DATASIZE,dwElapsed,cTTL);
SendMessage(m_hWnd,WM_MSG_STATUS,2,(LPARAM)AllocBuffer(str));
Sleep(1000);
}
}
nRet = closesocket(rawSocket);
if (nRet == SOCKET_ERROR)
{
CString strMsg;
strMsg.Format(“关闭套接字发生错误 – WSAError: %ld”,WSAGetLastError());
//发送报错信息
SendMessage(m_hWnd,WM_MSG_STATUS,0,(LPARAM) AllocBuffer(strMsg));
}
}
//发送ICMPECHO数据包请求
int CPing::SendEchoRequest(SOCKET s,LPSOCKADDR_IN lpstToAddr)
{
static ECHOREQUEST echo;
static nId = 1;
static nSeq = 1;
int nRet;
//构造回应请求
echo.icmpHdr.Type = 8;
echo.icmpHdr.Code = 0;
echo.icmpHdr.Checksum = 0;
echo.icmpHdr.ID = nId++;
echo.icmpHdr.Seq = nSeq++;
for(nRet=0;nRet&lt;REQ_DATASIZE;nRet++)
echo.cData[nRet] = ‘ ‘+nRet;
//保存发送时间
echo.dwTime = GetTickCount();
echo.icmpHdr.Checksum = in_cksum((u_short *)&amp;echo,sizeof(ECHOREQUEST));
//发送请求
nRet = sendto(s,(LPSTR)&amp;echo,sizeof(ECHOREQUEST),0,
(LPSOCKADDR)lpstToAddr,sizeof(SOCKADDR_IN));
if (nRet == SOCKET_ERROR)
{
CString strMsg;
strMsg.Format(“发送数据时发生错误 – WSAError: %ld”,WSAGetLastError());
//发送报错信息
SendMessage(m_hWnd,WM_MSG_STATUS,0,(LPARAM) AllocBuffer(strMsg));
}
return (nRet);
}
//接收ICMPECHO数据包回应
DWORD CPing::RecvEchoReply(SOCKET s,LPSOCKADDR_IN lpsaFrom,u_char *pTTL)
{
ECHOREPLY echoReply;
int nRet;
int nAddrLen = sizeof(struct sockaddr_in);
//接收请求回应
nRet = recvfrom(s,(LPSTR)&amp;echoReply,sizeof(ECHOREPLY),0,
(LPSOCKADDR)lpsaFrom,&amp;nAddrLen);
//检查返回值
if (nRet == SOCKET_ERROR)
{
CString strMsg;
strMsg.Format(“接收数据时发生错误 – WSAError: %ld”,WSAGetLastError());
//发送报错信息
SendMessage(m_hWnd,WM_MSG_STATUS,0,(LPARAM) AllocBuffer(strMsg));
}
//返回发送的时间
*pTTL = echoReply.iphdr.TTL;
return(echoReply.echorequest.dwTime);
}
//等待回应
int CPing::WaitForEchoReply(SOCKET s)
{
struct timeval Time;
fd_set fds;
fds.fd_count = 1;
fds.fd_array[0] = s;
Time.tv_sec = 1;
Time.tv_usec = 0;
return(select(1,&amp;fds,NULL,NULL,&amp;Time));
}
//转换地址
u_short CPing::in_cksum(u_short *addr,int len)
{
register int nleft = len;
register u_short *n = addr;
register u_short answer;
register int sum = 0;
while(nleft &gt; 1)
{
sum += *n++;
nleft -= 2;
}
if(nleft == 1)
{
u_short	u = 0;
*(u_char *)(&amp;u) = *(u_char *)n;
sum += u;
}
sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff);
sum += (sum &gt;&gt; 16);
answer = ~sum;
return (answer);
}
char* CPing::AllocBuffer(CString strMsg)
{
int nLen = strMsg.GetLength();
char *pBuffer = new char[nLen+1];
strcpy(pBuffer,(const char*)strMsg);
ASSERT(pBuffer != NULL);
return pBuffer;
}
</code></pre> 
 </div> 
 <p>pingip.h</p> 
 <p> </p> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-cpp">// Ping.h
//
#define REQ_DATASIZE 32	//Echo请求数据的大小
class CPing
{
public:
static char* AllocBuffer(CString strMsg);
HWND m_hWnd; //窗口句柄
void Ping(UINT nRetries,LPCSTR pstrHost,HWND hWnd);
int WaitForEchoReply(SOCKET s);
//ICMP回应的请求和回答函数
int	SendEchoRequest(SOCKET, LPSOCKADDR_IN);
DWORD RecvEchoReply(SOCKET, LPSOCKADDR_IN,u_char *pTTL);
u_short in_cksum(u_short *addr, int len);
protected:
};
typedef struct IP_HDR
{
u_char  VIHL;	   //Version and IHL
u_char	TOS;	   //Type Of Service
short	TotLen;	   //总长度
short	ID;	   //标识
short	FlagOff;	   //标记
u_char	TTL;	   //生命期
u_char	Protocol;	   //协议
u_short	Checksum;	   //检查和
struct	in_addr iaSrc; //源地址
struct	in_addr iaDst; //目的地址
}IPHDR, *PIPHDR;
typedef struct IC_MPHDR
{
u_char	Type;	  //类型
u_char	Code;	  //编码
u_short	Checksum; //检查和
u_short	ID;	  //标识
u_short	Seq;	  //顺序
char	Data;	  //数据
}ICMPHDR, *PICMPHDR;
typedef struct ICMPECHOREQUEST
{
ICMPHDR icmpHdr;
DWORD	dwTime;
char	cData[REQ_DATASIZE];
}ECHOREQUEST, *PECHOREQUEST;
typedef struct ICMPECHOREPLY
{
IPHDR	iphdr;
ECHOREQUEST	echorequest;
char    cFiller[256];
}ECHOREPLY, *PECHOREPLY;
</code></pre> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/rogee/archive/2011/05/24/2055892.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c8235112ac255a96b673b0662af8891f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">屏幕截图的函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d37d17dc32ba80123e09004dbaa5040b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MFC窗体控件随窗体变化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>