<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android事件传递(四)：总结篇 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android事件传递(四)：总结篇" />
<meta property="og:description" content="Android事件传递(一)：Activity、View、ViewGroup及dispatchtouchEvent、onTouchEvent梳理
Android事件传递(二)：事件动作 DOWN 在Activity、View、ViewGroup传递
Android事件传递(三)：事件动作 UP 在Activity、View、ViewGroup传递
下面源码基于Android11 API30
文章里会用到上篇文章的布局例子这里先做一个初始化 ，让他们都返回默认值 重写方法dispatchTouchEvent重写onTouchEventisClickableMyLinearLayoutOutreturn super.dispatchTouchEvent(ev);return super.onTouchEvent(event); MyLinearLayoutreturn super.dispatchTouchEvent(ev);return super.onTouchEvent(event); MyButtonreturn super.dispatchTouchEvent(ev);return super.onTouchEvent(event);手动置为false 1 Activity在事件传递的特殊位置 Activity对于 dispatchTouchEvent 和 onTouchEvent分为两种情况
1 有控件接收处理事件，它和其它布局差不多，dispatchTouchEvent从它开始，返回被处理事件的控件拦截它也被拦截。
2 没有控件处理事件的的时候,这时候就有点不一样了，我们来看下源码
public class Activity extends ContextThemeWrapper implements Window.Callback,...... { ......省略其它代码...... public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } ✍这里没有子控件接收处理事件，getWindow().superDispatchTouchEvent(ev) 最终返回值是false if (getWindow().superDispatchTouchEvent(ev)) { return true; } ✍ 这个就会走到这里，调用它的onTouchEvent方法 return onTouchEvent(ev); } public void onUserInteraction() { } } 所以没有控件接收处理事件，对于UP动作Activity依旧会执行！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/72b15910f4c8cc59230f276ea569b04c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-23T16:41:50+08:00" />
<meta property="article:modified_time" content="2021-03-23T16:41:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android事件传递(四)：总结篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://blog.csdn.net/u011288271/article/details/114881303">Android事件传递(一)：Activity、View、ViewGroup及dispatchtouchEvent、onTouchEvent梳理</a></p> 
<p><a href="https://blog.csdn.net/u011288271/article/details/114979903">Android事件传递(二)：事件动作 DOWN 在Activity、View、ViewGroup传递</a></p> 
<p><a href="https://blog.csdn.net/u011288271/article/details/115121917">Android事件传递(三)：事件动作 UP 在Activity、View、ViewGroup传递</a></p> 
<p>下面源码基于<span style="color:#f33b45;"><strong>Android11 API30</strong></span></p> 
<p>文章里会用到上篇文章的布局例子这里先做一个初始化 ，让他们都返回默认值 </p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td> </td><td style="width:271px;">重写方法dispatchTouchEvent</td><td style="width:301px;">重写onTouchEvent</td><td style="width:220px;">isClickable</td></tr><tr><td>MyLinearLayoutOut</td><td style="width:271px;">return super.dispatchTouchEvent(ev);</td><td style="width:301px;">return super.onTouchEvent(event);</td><td style="width:220px;"> </td></tr><tr><td>MyLinearLayout</td><td style="width:271px;">return super.dispatchTouchEvent(ev);</td><td style="width:301px;">return super.onTouchEvent(event);</td><td style="width:220px;"> </td></tr><tr><td>MyButton</td><td style="width:271px;">return super.dispatchTouchEvent(ev);</td><td style="width:301px;">return super.onTouchEvent(event);</td><td style="width:220px;">手动置为false</td></tr></tbody></table> 
<p> </p> 
<h2>1 Activity在事件传递的特殊位置</h2> 
<p>Activity对于 dispatchTouchEvent 和 onTouchEvent分为两种情况</p> 
<p>1 有控件接收处理事件，它和其它布局差不多，dispatchTouchEvent从它开始，返回被处理事件的控件拦截它也被拦截。</p> 
<p>2 没有控件处理事件的的时候,这时候就有点不一样了，我们来看下源码</p> 
<pre><code class="language-java">public class Activity extends ContextThemeWrapper
        implements Window.Callback,...... {     
 
        ......省略其它代码......
 
  
   
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
             
            onUserInteraction(); 
        }
        ✍这里没有子控件接收处理事件，getWindow().superDispatchTouchEvent(ev)
           最终返回值是false
        if (getWindow().superDispatchTouchEvent(ev)) {
           
            return true;
        }
        ✍ 这个就会走到这里，调用它的onTouchEvent方法
        return onTouchEvent(ev);
    }
  
 
    public void onUserInteraction() {
        
    }
 
}</code></pre> 
<p>所以没有控件接收处理事件，对于UP动作Activity依旧会执行！</p> 
<p>还是用上一篇文章的例子，只不过用文章最开始的把 MyLinearLayout 里重写的 onTouchEvent 返回值改为默认 return super.onTouchEvent(event); MyButton还是设置 android:clickable="false"，这样就没有任何控件接收处理事件了，再点击MyButton,日志如下：</p> 
<pre><code>2021-03-23 15:47:11.260 I/lyw:  MainActivity      dispatchTouchEvent Down
2021-03-23 15:47:11.261 I/lyw:  MyLinearLayoutOut dispatchTouchEvent ACTION_DOWN
2021-03-23 15:47:11.261 I/lyw:  MyLinearLayout    dispatchTouchEvent ACTION_DOWN
2021-03-23 15:47:11.261 I/lyw:  MyButton          dispatchTouchEvent ACTION_DOWN

2021-03-23 15:47:11.261 I/lyw:  MyButton          onTouchEvent ACTION_DOWN
2021-03-23 15:47:11.261 I/lyw:  MyLinearLayout    onTouchEvent ACTION_DOWN
2021-03-23 15:47:11.261 I/lyw:  MyLinearLayoutOut onTouchEvent ACTION_DOWN
2021-03-23 15:47:11.261 I/lyw:  MainActivity      onTouchEvent Down

2021-03-23 15:47:11.363 I/lyw:  MainActivity      dispatchTouchEvent Up
2021-03-23 15:47:11.364 I/lyw:  MainActivity      onTouchEvent Up</code></pre> 
<h2>2 OnTouch、OnTouchEvent 、 OnClickListener 执行顺序</h2> 
<p>在文章2 中我们也分析过了先判断OnTouch 再判断OnTouchEvent 最后判断 OnClickListener，这就是这三者的执行先后顺序。</p> 
<h2>3 重写dispatchTouchEvent 拦截事件的问题</h2> 
<h3>3.1 文章最开始的表格初始化内容开始修改，把MyLinearLayout重写的dispatchTouchEvent方法改为 return true。</h3> 
<pre><code>2021-03-23 15:54:42.610 I/lyw:  MainActivity      dispatchTouchEvent Down
2021-03-23 15:54:42.610 I/lyw:  MyLinearLayoutOut dispatchTouchEvent ACTION_DOWN
2021-03-23 15:54:42.610 I/lyw:  MyLinearLayout    dispatchTouchEvent ACTION_DOWN

2021-03-23 15:54:42.720 I/lyw:  MainActivity      dispatchTouchEvent Up
2021-03-23 15:54:42.720 I/lyw:  MyLinearLayoutOut dispatchTouchEvent ACTION_UP
2021-03-23 15:54:42.720 I/lyw:  MyLinearLayout    dispatchTouchEvent ACTION_UP</code></pre> 
<p>看到日志人都懵了，咋回事，想象中dispatchTouchEvent返回值return true;事件应该交给MyLinearLayout的onTouchEvent来处理啊。怎么没有一个onTouchEvent被调用了？</p> 
<pre><code class="language-java">在MyLiearLayoutOut的dispatchTouchEvent方法中调用到
 ✍ 🔺 嵌套循环起源 
  if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
        ✍ 这个child就是MyLiearLayout
  }
 然后在dispatchTransformedTouchEvent中
 private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {


                if (child == null) {
                    handled = super.dispatchTouchEvent(event);
                } else {
          
                  ✍child为MyLiearLayout，而我们重写了它的dispatchTouchEvent
                     就不会再调用它的父类ViewGroup的dispatchTouchEvent
                     而是调用我们重写的方法return true;
                    handled = child.dispatchTouchEvent(event);
 
                    
                }


}
然后回到 MyLiearLayoutOut 嵌套循环起源 那里为true,进入判断条件,
newTouchTarget = addTouchTarget(child, idBitsToAssign);
alreadyDispatchedToNewTouchTarget = true;
再往后就走到
 if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
 } else {
      if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
                handled = true;
       } else { 
         ......        
       }
}
 return handled;
就结束到上一层布局，也是一样逻辑，逐层向外就没有一层会调用onTouchEvent。
仔细想一样返回值一般是由View的dispatchTouchEvent开始逐个验证onTouchListener，onTouchEvent,onClicklistener三个条件，而我们直接重写返回true，好像会让外层布局
以为已经有控件消费掉了就不用了验证自己了，只要把消费事件的child保存下来，用来传递
后续UP动作就可以了。</code></pre> 
<h3>3.2 那我们把MyLinearLayout重写dispatchTouchEvent 改成return false；是什么情况：</h3> 
<pre><code>2021-03-23 15:59:17.840 I/lyw:  MainActivity      dispatchTouchEvent Down
2021-03-23 15:59:17.840 I/lyw:  MyLinearLayoutOut dispatchTouchEvent ACTION_DOWN
2021-03-23 15:59:17.840 I/lyw:  MyLinearLayout    dispatchTouchEvent ACTION_DOWN

2021-03-23 15:59:17.840 I/lyw:  MyLinearLayoutOut onTouchEvent ACTION_DOWN
2021-03-23 15:59:17.840 I/lyw:  MainActivity      onTouchEvent Down

2021-03-23 15:59:17.951 I/lyw:  MainActivity      dispatchTouchEvent Up
2021-03-23 15:59:17.951 I/lyw:  MainActivity      onTouchEvent Up</code></pre> 
<p>事件依旧被拦截了，只不过因为return false，所以它的外层开始验证自身是否消费该事件：</p> 
<pre><code class="language-java">在MyLiearLayoutOut的dispatchTouchEvent方法中调用到
 ✍ 🔺 嵌套循环起源 
  if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
        ✍ 这个child就是MyLiearLayout
  }
 然后在dispatchTransformedTouchEvent中
 private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {


                if (child == null) {
                    handled = super.dispatchTouchEvent(event);
                } else {
          
                  ✍child为MyLiearLayout，而我们重写了它的dispatchTouchEvent
                     return false;
                    handled = child.dispatchTouchEvent(event);
 
                    
                }


}
然后回到 MyLiearLayoutOut 嵌套循环起源 那里为false,没有进入判断条件mFirstTouchTarget == null
再往后就走到
  if (mFirstTouchTarget == null) {
         ✍走这里验证自身是否处理该事件      
         handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
 } else {
      
         ......        
        
}
return handled;
 
最终没有任何控件接收处理事件，UP事件只有Activity被调用了。
</code></pre> 
<p><strong>小结：</strong></p> 
<p><strong>我们重写 dispatchTouchEvent 无论 return true 或者 return false,事件都会被拦截了，不再向内层传递，而且也不会回调该控件的onTouchEvent方法。</strong></p> 
<p><strong>那我们想在某控件拦截事件并交给它处理咋办？有专门的 onInterceptTouchEvent 方法，重写该方法返回true就可以了，然后会验证该控件是不是要接收消费事件。</strong></p> 
<p><strong>那要不要重写dispatchTouchEvent 方法呢？ 弄明白原理可能在某种场景下有奇效。。。？</strong></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7d3b7cff8c589c29c732f96aa18d2f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vant Cascader 级联选择 异步加载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de4cfbb29b84d1cfd5af6903a3de2825/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">树莓派学习（二） 安装anaconda</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>