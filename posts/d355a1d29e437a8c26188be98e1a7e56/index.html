<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>参照完整性 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="参照完整性" />
<meta property="og:description" content="1. 什么是参照完整性?
——————–
参照完整性(完整性约束)是数据库设计中的一个重要概念，当数据库中的一个表与一个或多个表进行关联时都会涉及到参照完整性。比如下面这个例子：
文章分类表 - categories
category_id name
1 SQL Server
2 Oracle
3 PostgreSQL
5 SQLite
文章表 - articles
article_id category_id title
1 1 aa
2 2 bb
3 4 cc
可见以上两个表之间是通过category_id，其中categories表有4条记录，articles表有3条记录。
然而可能因为某种原因我们删掉了categories 表中category_id=4的记录，而articles表却还是有一条category_id=4的记录，很明显，category_id=4的这条记录不应该存在在articles表中，这样会很容易造成数据错乱。
相反，外键关系(Foreign Key relationships)讨论的是父表(categories)与子表(articles)的关系，通过引入外键(Foreign Key)这个概念来保证参照完整性(Referential integrity)，将使会数据库变的非常简单。比如，要要做到删除categories表中category_id=4记录的同时删除 articles 表中category_id=4的所有记录，如果没有引入外键的话，我们就必须执行2条SQL语句才行；如果有外键的话，可以很容易的用一条SQL语句就可以达到要求。
2. 使用外键的条件
—————–
MySQL只在v3.23.34版本以后才引入外键的，所以在这之前的版本就别想了:)，除此之外，还必须具备以下几个条件：
1) 在my.cnf配置文件中打开InnoDB引擎支持。
# Uncomment the following if you are using InnoDB tables
innodb_data_home_dir = /var/db/mysql/
innodb_data_file_path = ibdata1:10M:autoextend
innodb_log_group_home_dir = /var/db/mysql/
innodb_log_arch_dir = /var/db/mysql/" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d355a1d29e437a8c26188be98e1a7e56/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-10-04T11:10:00+08:00" />
<meta property="article:modified_time" content="2010-10-04T11:10:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">参照完整性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><br>1. 什么是参照完整性?<br>——————–<br>参照完整性(完整性约束)是数据库设计中的一个重要概念，当数据库中的一个表与一个或多个表进行关联时都会涉及到参照完整性。比如下面这个例子：<br>文章分类表 -   categories<br>category_id      name<br>1                SQL Server<br>2                Oracle<br>3                PostgreSQL<br>5                SQLite</p> 
<p>文章表 - articles<br>article_id       category_id      title<br>1                1                aa<br>2                2                bb<br>3                4                cc</p> 
<p>可见以上两个表之间是通过category_id，其中categories表有4条记录，articles表有3条记录。</p> 
<p>然而可能因为某种原因我们删掉了categories 表中category_id=4的记录，而articles表却还是有一条category_id=4的记录，很明显，category_id=4的这条记录不应该存在在articles表中，这样会很容易造成数据错乱。</p> 
<p>相反，外键关系(Foreign Key relationships)讨论的是父表(categories)与子表(articles)的关系，通过引入外键(Foreign Key)这个概念来保证参照完整性(Referential integrity)，将使会数据库变的非常简单。比如，要要做到删除categories表中category_id=4记录的同时删除 articles 表中category_id=4的所有记录，如果没有引入外键的话，我们就必须执行2条SQL语句才行；如果有外键的话，可以很容易的用一条SQL语句就可以达到要求。</p> 
<p>2. 使用外键的条件<br>—————–<br>MySQL只在v3.23.34版本以后才引入外键的，所以在这之前的版本就别想了:)，除此之外，还必须具备以下几个条件：</p> 
<p>     1) 在my.cnf配置文件中打开InnoDB引擎支持。<br>     # Uncomment the following if you are using InnoDB tables<br>     innodb_data_home_dir = /var/db/mysql/<br>     innodb_data_file_path = ibdata1:10M:autoextend<br>     innodb_log_group_home_dir = /var/db/mysql/<br>     innodb_log_arch_dir = /var/db/mysql/</p> 
<p>     2) 相关联的表都必须采用InnoDB引擎。</p> 
<p>     3) 相关联的字段都必须建立所以。<br>     MySQL v4.0版本以后，定义外键时会自动建立所以，所以在 v4.0 版本以前（含v4.0版本）必须手工定义索引。</p> 
<p>     4) 相关联的字段必须采用类似的数据类型，或者说可转换的数据类型，当然相同类型是最好不过了。<br>     比如父表的字段是TINYINT类型，则子表只能采用TINYINT、SMALLINT、INT、BIGINT等几种类型。</p> 
<p>3. 外键语法参考<br>—————<br>可以通过 CREATE TABLE 或者 ALTER TABLE 来定义外键。<br>CREATE TABLE 语法：<br>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name<br>     [(create_definition,…)]</p> 
<p>create_definition:<br>     column_definition<br>   | [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name,…) [reference_definition]</p> 
<p>column_definition:<br>     col_name type [NOT NULL | NULL] [DEFAULT default_value]<br>         [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY]<br>         [COMMENT ’string’] [reference_definition]</p> 
<p>index_col_name:<br>     col_name [(length)] [ASC | DESC]</p> 
<p>reference_definition:<br>     REFERENCES tbl_name [(index_col_name,…)]<br>                [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]<br>                [ON DELETE reference_option]<br>                [ON UPDATE reference_option]</p> 
<p>reference_option:<br>     RESTRICT | CASCADE | SET NULL | NO ACTION</p> 
<p>ALTER TABLE 语法：<br>ALTER [IGNORE] TABLE tbl_name<br>     alter_specification [, alter_specification] …</p> 
<p>alter_specification:<br>   | ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name,…)<br>   | ADD [CONSTRAINT [symbol]] UNIQUE [INDEX] [index_name] [index_type] (index_col_name,…)<br>   | ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name,…) [reference_definition]<br>   | DROP FOREIGN KEY fk_symbol</p> 
<p>4. 定义外键<br>———–<br>mysql&gt; CREATE TABLE categories (<br>     -&gt; category_id tinyint(3) unsigned NOT NULL AUTO_INCREMENT,<br>     -&gt; name varchar(30) NOT NULL,<br>     -&gt; PRIMARY KEY(category_id)<br>     -&gt; ) ENGINE=INNODB;<br>Query OK, 0 rows affected (0.36 sec)</p> 
<p>mysql&gt; INSERT INTO categories VALUES (1, ‘SQL Server’), (2, ‘Oracle’), (3, ‘PostgreSQL’), (4, ‘MySQL’), (5, ‘SQLite’);<br>Query OK, 5 rows affected (0.48 sec)<br>Records: 5   Duplicates: 0   Warnings: 0</p> 
<p>mysql&gt; CREATE TABLE members (<br>     -&gt; member_id INT(11) UNSIGNED NOT NULL,<br>     -&gt; name VARCHAR(20) NOT NULL,<br>     -&gt; PRIMARY KEY(member_id)<br>     -&gt; ) ENGINE=INNODB;<br>Query OK, 0 rows affected (0.55 sec)</p> 
<p>mysql&gt; INSERT INTO members VALUES (1, ‘test’), (2, ‘admin’);<br>Query OK, 2 rows affected (0.44 sec)<br>Records: 2   Duplicates: 0   Warnings: 0</p> 
<p>mysql&gt; CREATE TABLE articles (<br>     -&gt; article_id INT(11) unsigned NOT NULL AUTO_INCREMENT,<br>     -&gt; title varchar(255) NOT NULL,<br>     -&gt; category_id tinyint(3) unsigned NOT NULL,<br>     -&gt; member_id int(11) unsigned NOT NULL,<br>     -&gt; INDEX (category_id),<br>     -&gt; FOREIGN KEY (category_id) REFERENCES categories (category_id),<br>     -&gt; CONSTRAINT fk_member FOREIGN KEY (member_id) REFERENCES members (member_id),<br>     -&gt; PRIMARY KEY(article_id)<br>     -&gt; ) ENGINE=INNODB;<br>Query OK, 0 rows affected (0.63 sec)</p> 
<p>注意：对于非InnoDB表，FOREIGN KEY子句会被忽略掉。<br>如果遇到如下错误：<br>ERROR 1005: Can’t create table ‘./test/articles.frm’ (errno: 150)<br>请仔细检查以下定义语句，常见的错误一般都是表类型不是INNODB、相关联的字段写错了、缺少索引等等。</p> 
<p>至此categories.category_id和articles.category_id、members.member_id和 articles.member_id已经建立外键关系，只有 articles.category_id 的值存在与 categories.category_id 表中并且articles.member_id的值存在与members.member_id表中才会允许被插入或修改。例如：</p> 
<p>mysql&gt; INSERT INTO articles (category_id, member_id, title) VALUES (6, 1, ‘foo’);<br>ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`test/articles`, CONSTRAINT `articles_ibfk_1` FOREIGN KEY (`category_id`)REFERENCES `categories` (`id`))</p> 
<p>mysql&gt; INSERT INTO articles (category_id, member_id, title) VALUES (3, 3, ‘foo’);<br>ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`test/articles`, CONSTRAINT `fk_member` FOREIGN KEY (`member_id`) REFERENCES `members` (`member_id`))</p> 
<p>可见上面两条语句都会出现错误，因为在categories表中并没有category_id=6、members表中也没有member_id=3的记录，所以不能插入。而下面这条SQL语句就可以。</p> 
<p>mysql&gt; INSERT INTO articles (category_id, member_id, title) VALUES (3, 2, ‘bar’);<br>Query OK, 1 row affected (0.03 sec)</p> 
<p>5. 删除外键定义<br>—————<br>不知道大家有没有发现，在前面定义外键的时候articles.member_id外键比articles.category_id子句多了一个CONSTRAINT fk_member ？<br>这个fk_member就是用来删除外键定义用的，如下所示：<br>mysql&gt; ALTER TABLE articles DROP FOREIGN KEY fk_member;<br>Query OK, 1 row affected (0.25 sec)<br>Records: 1   Duplicates: 0   Warnings: 0</p> 
<p>这样articles.member_id外键定义就被删除了，但是如果定义时没有指定CONSTRAINT fk_symbol （即外键符号）时该怎么删除呢？别急，没有指定时，MySQL会自己创建一个，可以通过以下命令查看：</p> 
<p>mysql&gt; SHOW CREATE TABLE articles;<br>+———-+————————————+<br>| Table     | Create Table                        |<br>+———-+————————————+<br>| articles | CREATE TABLE `articles` (<br>   `article_id` int(11) unsigned NOT NULL auto_increment,<br>   `category_id` tinyint(3) unsigned NOT NULL,<br>   `member_id` int(11) unsigned NOT NULL,<br>   `title` varchar(255) NOT NULL,<br>   PRIMARY KEY   (`article_id`),<br>   KEY `category_id` (`category_id`),<br>   KEY `member_id` (`member_id`),<br>   CONSTRAINT `articles_ibfk_1` FOREIGN KEY (`category_id`) REFERENCES `categories` (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=latin1           |<br>+———-+————————————+<br>1 row in set (0.01 sec)</p> 
<p>可以看出articles.category_id的外键符号为articles_ibfk_1，因为就可以执行以下命令删除外键定义：</p> 
<p>mysql&gt; ALTER TABLE articles DROP FOREIGN KEY articles_ibfk_1;<br>Query OK, 1 row affected (0.66 sec)<br>Records: 1   Duplicates: 0   Warnings: 0</p> 
<p>6. 总结<br>——-<br>引入外键的缺点是会使速度和性能下降，当然外键所带来的优点还有很多，本文仅讨论如何定义、删除外键。至于外键的实际应用将会在以后的文章中介绍。</p> 
<p>  </p> 
<p>本文来自CSDN博客，转载请标明出处：<a href="http://blog.csdn.net/hongsejiaozhu/archive/2007/10/08/1815362.aspx">http://blog.csdn.net/hongsejiaozhu/archive/2007/10/08/1815362.aspx</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8effa542c12afb9fa18bde40b08ac6c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Reactive框架:简化异步及事件驱动编程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf708f8cdf0d4d47d990b3602e0247f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MFC中实现简单的位图显示、处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>