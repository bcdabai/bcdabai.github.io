<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>插值法(最邻近，双线性，双三次）的原理及实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="插值法(最邻近，双线性，双三次）的原理及实现" />
<meta property="og:description" content="插值法(最邻近，双线性，双三次）的原理及实现 常用的插值方法有最邻近插值法、双现象插值法和双三次插值法等，主要用于图像的放大或缩小。
缩小图像（或称为下采样（subsampled） 或降采样（downsampled） ） 的主要目的有两个： 1、 使得图像符合显示区域的大小； 2、 生成对应图像的缩略图。
放大图像（或称为上采样（upsampling） 或图像插值（interpolating） ） 的主要目的是放大原图像,从而可以显示在更高分辨率的显示设备上。
一、最邻近插值法
最邻近插值（The nearest interpolation）即是选取一个最靠近的像素为它的像素值，这是最简单的一种插值方法，不需要计算。在待求像素的四邻像素中，将距离待求像素最近的邻接像素灰度值赋予待求像素。设i&#43;u, j&#43;v (i, j为正整数， u, v为大于零小于1的小数， 下同)为待求象素坐标， 则待求象素灰度的值 f(i&#43;u, j&#43;v) 如下图所示：
如果(i&#43;u, j&#43;v)落在A区，即u&lt;0.5, v&lt;0.5，则将左上角象素的灰度值赋给待求象素，同理，落在B区则赋予右上角的象素灰度值，落在C区则赋予左下角象素的灰度值，落在D区则赋予右下角象素的灰度值。
特点：最邻近元法计算量较小，但可能会造成插值生成的图像灰度上的不连续，在灰度变化的地方可能出现明显的锯齿状。
代码块：
import cv2 import numpy as np def function(img): height,width,channels =img.shape emptyImage=np.zeros((800,800,channels),np.uint8) sh=800/height sw=800/width for i in range(800): for j in range(800): x=int(i/sh) y=int(j/sw) emptyImage[i,j]=img[x,y] return emptyImage img=cv2.imread(&#34;lenna.png&#34;) zoom=function(img) print(zoom.shape) cv2.imshow(&#34;nearest interp&#34;,zoom) cv2.imshow(&#34;image&#34;,img) cv2.waitKey(0) 二、双线性插值法
双线性插值（Bilinear interpolation）：已知X-Y平面内四个像素点的坐标 (x0, y0) 、（x1, y0）、（x0, y1） (x1, y1)，要得到四点构成 区间内某一点上的像素值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c60c551fc06bc82b7ca87eefa6f0c15a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-10T01:11:25+08:00" />
<meta property="article:modified_time" content="2021-02-10T01:11:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">插值法(最邻近，双线性，双三次）的原理及实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>插值法(最邻近，双线性，双三次）的原理及实现</h3> 
<p>常用的插值方法有最邻近插值法、双现象插值法和双三次插值法等，主要用于图像的放大或缩小。</p> 
<p>缩小图像（或称为下采样（subsampled） 或降采样（downsampled） ） 的主要目的有两个： 1、 使得图像符合显示区域的大小； 2、 生成对应图像的缩略图。</p> 
<p>放大图像（或称为上采样（upsampling） 或图像插值（interpolating） ） 的主要目的是放大原图像,从而可以显示在更高分辨率的显示设备上。</p> 
<p><strong>一、最邻近插值法</strong></p> 
<p>最邻近插值（The nearest interpolation）即是选取一个最靠近的像素为它的像素值，这是最简单的一种插值方法，不需要计算。在待求像素的四邻像素中，将距离待求像素最近的邻接像素灰度值赋予待求像素。设i+u, j+v (i, j为正整数， u, v为大于零小于1的小数， 下同)为待求象素坐标， 则待求象素灰度的值 f(i+u, j+v) 如下图所示：<br> <img src="https://images2.imgbox.com/c2/1c/ioECgXmE_o.png" alt=""><br> 如果(i+u, j+v)落在A区，即u&lt;0.5, v&lt;0.5，则将左上角象素的灰度值赋给待求象素，同理，落在B区则赋予右上角的象素灰度值，落在C区则赋予左下角象素的灰度值，落在D区则赋予右下角象素的灰度值。</p> 
<p>特点：最邻近元法计算量较小，但可能会造成插值生成的图像灰度上的不连续，在灰度变化的地方可能出现明显的锯齿状。</p> 
<p>代码块：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span>
    height<span class="token punctuation">,</span>width<span class="token punctuation">,</span>channels <span class="token operator">=</span>img<span class="token punctuation">.</span>shape
    emptyImage<span class="token operator">=</span>np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span><span class="token number">800</span><span class="token punctuation">,</span>channels<span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>
    sh<span class="token operator">=</span><span class="token number">800</span><span class="token operator">/</span>height
    sw<span class="token operator">=</span><span class="token number">800</span><span class="token operator">/</span>width
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            x<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>i<span class="token operator">/</span>sh<span class="token punctuation">)</span>
            y<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>j<span class="token operator">/</span>sw<span class="token punctuation">)</span>
            emptyImage<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token operator">=</span>img<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span>
    <span class="token keyword">return</span> emptyImage

img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"lenna.png"</span><span class="token punctuation">)</span>
zoom<span class="token operator">=</span>function<span class="token punctuation">(</span>img<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>zoom<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"nearest interp"</span><span class="token punctuation">,</span>zoom<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"image"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre> 
<p><strong>二、双线性插值法</strong></p> 
<p>双线性插值（Bilinear interpolation）：已知X-Y平面内四个像素点的坐标 (x0, y0) 、（x1, y0）、（x0, y1） (x1, y1)，要得到四点构成 区间内某一点上的像素值。</p> 
<p>2.1单线性插值</p> 
<p>由简入难，先了解下单线性插值的原理：</p> 
<p>已知数据 (x0, y0) 与 (x1, y1)，要计算 [x0, x1] 区间内某一位置 x 在直线上的y值。如下图所示：<br> <img src="https://images2.imgbox.com/cd/1d/W8vVLoFj_o.png" alt=""><br> 单线性插值用一句话概括就是用x和x0，x1的距离作为一个权重，用于y0和y1的加权。双线性插值本质上就是在两个方向上做线性插值。</p> 
<p>2.2双线性插值</p> 
<p>在数学上，双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值。如下图所示：<br> <img src="https://images2.imgbox.com/04/76/gkjLtwo2_o.png" alt=""><br> 假如我们想得到未知函数 f 在点 P = (x, y) 的值，假设我们已知函数 f 在 Q11 = (x1, y1), Q12 = (x1, y2), Q21 = (x2, y1) , Q22 = (x2, y2) 四个点的值。最常见的情况，f就是一个像素点的像素值。分别在 x 、y方向做两次单线性插值，得到：<br> <img src="https://images2.imgbox.com/f2/2d/P7DLUQBG_o.png" alt=""><br> 由于图像双线性插值只会用相邻的4个点， 因此上述公式的分母都是1。</p> 
<p>特点：1、如果源图像和目标图像的原点（0， 0） 均选择左上角， 然后根据插值公式计算目标图像每点像素， 假设你需要将一幅5x5的图像缩小成3x3， 那么源图像和目标图像各个像素之间的对应关系如下：<br> <img src="https://images2.imgbox.com/51/04/2FOBK8Jg_o.png" alt="在这里插入图片描述"><br> 即如果源图像和目标图像的原点（0， 0） 均选择左上角（或者右下角），那么有可能能会出现最右边和最下边的像素实际上并没有参与计算，而且目标图像的每个像素点计算出的灰度值也相对于源图像偏左偏上的情况。如果要解决这一问题，就需要将源图像和目标图像几何中心的对齐。<br> <img src="https://images2.imgbox.com/5e/34/ncoT9gh1_o.png" alt="在这里插入图片描述"></p> 
<p>要通过双线性插值的方法计算出dst中每一个像素点的像素值，需要通过dst像素点的坐标对应到src图像当中的坐标，然后通过双线性插值的方法算出src中相应坐标的像素值。二者的坐标对应关系为：</p> 
<p>srcX=dstX* (srcWidth/dstWidth) ,</p> 
<p>srcY = dstY * (srcHeight/dstHeight)</p> 
<p>考虑到如果将源图像和目标图像几何中心的对齐，如保持src图像不动，仅移动dst图像，则移动距离一定是1/2*(src_size-dst_size),那么上式可以修正为：</p> 
<p>srcX=dstX* (srcWidth/dstWidth)+0.5*(srcWidth/dstWidth-1)</p> 
<p>srcY = dstY* (srcHeight/dstHeight)+0.5*(srcHeight/dstHeight-1)</p> 
<p>证明过程如下：<br> <img src="https://images2.imgbox.com/29/64/uFK8gyMT_o.jpg" alt="在这里插入图片描述"><br> 2、双线性插值运算过程存在着大量的浮点数运算，相对而言是一个较为耗时的过程，直接进行计算的话，由于计算的srcX和srcY 都是浮点数，后续会进行大量的乘法，而图像数据量又大，速度不会理想，解决思路是：浮点运算→→整数运算→→”&lt;&lt;左右移按位运算”。</p> 
<p>3、没有灰度不连续的缺点， 图像看起来更光滑。</p> 
<p>代码块：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> cv2
 
<span class="token triple-quoted-string string">'''
python implementation of bilinear interpolation
'''</span> 
<span class="token keyword">def</span> <span class="token function">bilinear_interpolation</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span>out_dim<span class="token punctuation">)</span><span class="token punctuation">:</span>
    src_h<span class="token punctuation">,</span> src_w<span class="token punctuation">,</span> channel <span class="token operator">=</span> img<span class="token punctuation">.</span>shape
    dst_h<span class="token punctuation">,</span> dst_w <span class="token operator">=</span> out_dim<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> out_dim<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"src_h, src_w = "</span><span class="token punctuation">,</span> src_h<span class="token punctuation">,</span> src_w<span class="token punctuation">)</span>
    <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"dst_h, dst_w = "</span><span class="token punctuation">,</span> dst_h<span class="token punctuation">,</span> dst_w<span class="token punctuation">)</span>
    <span class="token keyword">if</span> src_h <span class="token operator">==</span> dst_h <span class="token operator">and</span> src_w <span class="token operator">==</span> dst_w<span class="token punctuation">:</span>
        <span class="token keyword">return</span> img<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
    dst_img <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>dst_h<span class="token punctuation">,</span>dst_w<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>
    scale_x<span class="token punctuation">,</span> scale_y <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>src_w<span class="token punctuation">)</span> <span class="token operator">/</span> dst_w<span class="token punctuation">,</span> <span class="token builtin">float</span><span class="token punctuation">(</span>src_h<span class="token punctuation">)</span> <span class="token operator">/</span> dst_h
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> dst_y <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>dst_h<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> dst_x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>dst_w<span class="token punctuation">)</span><span class="token punctuation">:</span>
 
                <span class="token comment"># find the origin x and y coordinates of dst image x and y</span>
                <span class="token comment"># use geometric center symmetry</span>
                <span class="token comment"># if use direct way, src_x = dst_x * scale_x</span>
                src_x <span class="token operator">=</span> <span class="token punctuation">(</span>dst_x <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">*</span> scale_x<span class="token operator">-</span><span class="token number">0.5</span>
                src_y <span class="token operator">=</span> <span class="token punctuation">(</span>dst_y <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">*</span> scale_y<span class="token operator">-</span><span class="token number">0.5</span>
 
                <span class="token comment"># find the coordinates of the points which will be used to compute the interpolation</span>
                src_x0 <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>src_x<span class="token punctuation">)</span><span class="token punctuation">)</span>
                src_x1 <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>src_x0 <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span>src_w <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
                src_y0 <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>src_y<span class="token punctuation">)</span><span class="token punctuation">)</span>
                src_y1 <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>src_y0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> src_h <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
 
                <span class="token comment"># calculate the interpolation</span>
                temp0 <span class="token operator">=</span> <span class="token punctuation">(</span>src_x1 <span class="token operator">-</span> src_x<span class="token punctuation">)</span> <span class="token operator">*</span> img<span class="token punctuation">[</span>src_y0<span class="token punctuation">,</span>src_x0<span class="token punctuation">,</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>src_x <span class="token operator">-</span> src_x0<span class="token punctuation">)</span> <span class="token operator">*</span> img<span class="token punctuation">[</span>src_y0<span class="token punctuation">,</span>src_x1<span class="token punctuation">,</span>i<span class="token punctuation">]</span>
                temp1 <span class="token operator">=</span> <span class="token punctuation">(</span>src_x1 <span class="token operator">-</span> src_x<span class="token punctuation">)</span> <span class="token operator">*</span> img<span class="token punctuation">[</span>src_y1<span class="token punctuation">,</span>src_x0<span class="token punctuation">,</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>src_x <span class="token operator">-</span> src_x0<span class="token punctuation">)</span> <span class="token operator">*</span> img<span class="token punctuation">[</span>src_y1<span class="token punctuation">,</span>src_x1<span class="token punctuation">,</span>i<span class="token punctuation">]</span>
                dst_img<span class="token punctuation">[</span>dst_y<span class="token punctuation">,</span>dst_x<span class="token punctuation">,</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>src_y1 <span class="token operator">-</span> src_y<span class="token punctuation">)</span> <span class="token operator">*</span> temp0 <span class="token operator">+</span> <span class="token punctuation">(</span>src_y <span class="token operator">-</span> src_y0<span class="token punctuation">)</span> <span class="token operator">*</span> temp1<span class="token punctuation">)</span>
 
    <span class="token keyword">return</span> dst_img
 
 
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'lenna.png'</span><span class="token punctuation">)</span>
    dst <span class="token operator">=</span> bilinear_interpolation<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">700</span><span class="token punctuation">,</span><span class="token number">700</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'bilinear interp'</span><span class="token punctuation">,</span>dst<span class="token punctuation">)</span>
    cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre> 
<p><strong>三、双三次插值法</strong></p> 
<p>双三次插值又称立方卷积插值。三次卷积插值是一种更加复杂的插值方式。该算法利用待采样点周围16个点的灰度值作三次插值，不仅考虑到4 个直接相邻点的灰度影响，而且考虑到各邻点间灰度值变化率的影响。三次运算可以得到更接近高分辨率图像的放大效果，但也导致了运算量的急剧增加。</p> 
<p>数学原理如下：<br> <img src="https://images2.imgbox.com/7c/83/lsfnYW83_o.png" alt="在这里插入图片描述"></p> 
<p>特点：双三次曲线插值方法计算量最大，但后的图像效果最好。这种算法是一很常见的算法，普遍用在图像编辑软件、打印机驱动和数码相机上。</p> 
<p>代码块参考资料：https://blog.csdn.net/u013185349/article/details/84841202?utm_term=python%E6%9C%80%E9%82%BB%E8%BF%91%E6%8F%92%E5%80%BC&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2<sub>all</sub>sobaiduweb~default-2-84841202&amp;spm=3001.4430</p> 
<p>参考资料：<br> 最邻近插值法：<br> https://blog.csdn.net/qq_25015749/article/details/106288238</p> 
<p>双线性插值法：<br> https://blog.csdn.net/weixin_36670529/article/details/103125041<br> https://www.cnblogs.com/yssongest/p/5303151.html</p> 
<p>双三次插值法：<br> https://blog.csdn.net/nandina179/article/details/85330552<br> https://blog.csdn.net/qq_29058565/article/details/52769497<br> https://blog.csdn.net/u013185349/article/details/84841202?utm_term=python%E6%9C%80%E9%82%BB%E8%BF%91%E6%8F%92%E5%80%BC&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2<sub>all</sub>sobaiduweb~default-2-84841202&amp;spm=3001.4430</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee8efeb09c4546e931864946e0f40cbb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">7-2 一元多项式的乘法与加法运算 (20 分) （链表实现）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf0bcea6df947dd50c52365d3b12ff99/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">3.17 Python赋值运算符（入门必读)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>