<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring源码分析总结——Mybatis的整合 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring源码分析总结——Mybatis的整合" />
<meta property="og:description" content="该文章基于《Spring源码深度解析》撰写，感谢郝佳老师的奉献
Mybatis与Spring整合 和之前分析的步骤相同，我们先从工厂方法开始分析，对于Mybatis整合的工厂类就是org.mybatis.Spring.SqlSessionFactoryBean 其中有两个值得一提的接口，就是 InitializingBean接口：实现此接口的bean会在初始化时调用器afterPropertiesSet方法来进行bean的逻辑初始化，并通过configuration实例来承载每一步所获取的信息，为创建SqlSessionFactory实例作准备。 FactoryBean接口：将getBean方法转换为getObject方法，所以实际上得到的是通过onfiguration属性和getObject方法返回的初始化后的sqlSessionFactory属性
接下来时另一个配置bean MapperFactoryBean 我们通过区分两种获取XXMapper的方式可以看出一些区别： 1.单独使用Mybatis时： XXMapper xxmapper = sqlsession.getMapper(XXMapper.class); 2.Spring整合之后 XXMapper xxmapper = (XXMapper)context.getBean(“XXMapperID”)； Mapper的类继承关系如上图所示，可以看到它和SqlSessionFactoryBean一样实现了InitializingBean接口和FactoryBean接口，这两个接口的功能就不再赘述。 InitializingBean接口： 需要注意的是InitializingBean接口的afterPropertiesSet()是由DaoSupport类实现的，在该父类的方法中实现了以下几个功能： 1.父类对于sqlSesion不为空的验证，sqlSession作为根据接口创建映射器代理的接触类一定不可以为空，而sqlSession又是在设定sqlSessionFactory属性时完成的，所以实际上将会检测： &lt;bean id=… class=”org.mybatis.Spring.mapper.MapperFactoryBean”&gt; &lt;property name=”sqlSessionFactory” ref=..&gt;该属性是否存在 &lt;bean&gt; 2.映射接口的验证（sqlSession会根据接口动态的创建相应代理类，所以接口必不可少） 3.映射文件存在性验证 FactoryBean接口 源代码
public T getObject() throws Exception { return this.getSqlSession().getMapper(this.mapperInterface); } 很简单，就是将已经注册的MapperInterface返回
如果我们需要指定搜索的包路径我们需要在applicationContext.xml中添加额外的配置
&lt;bean class=&#34;org.mybatis.Spring.mapper.MapperScannerConfigurer&#34;&gt; &lt;property name=&#34;basePackage&#34; value=&#34;指定的搜索路径&#34;&gt; &lt;/bean&gt; 这时我们又会引入新的类MapperScannerConfigurer，看一下这个类的类层次结构： 其中出现了我们一直提到的接口InitializingBean接口，但是结果并没有那么顺利，这个接口的作用只是对一堆属性的验证代码。 但是我们还有一个经常出现的接口BeanFactoryPostProcessor及其子类BeanDefinitionRegistryPostProcessor接口，这两个接口都会在Spring初始化的过程中进行调用。 首先看BeanFactoryPostProcessor接口的postProcessBeanFactory方法
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { } 这是一个空实现，看看BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法：
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { if (this.processPropertyPlaceHolders) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f5169495765fca36531b18618516ea27/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-11T00:43:13+08:00" />
<meta property="article:modified_time" content="2018-03-11T00:43:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring源码分析总结——Mybatis的整合</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>该文章基于《Spring源码深度解析》撰写，感谢郝佳老师的奉献</strong></p> 
<h2 id="mybatis与spring整合">Mybatis与Spring整合</h2> 
<p>和之前分析的步骤相同，我们先从工厂方法开始分析，对于Mybatis整合的工厂类就是<strong>org.mybatis.Spring.SqlSessionFactoryBean</strong> <br> <img src="https://images2.imgbox.com/7c/13/MSmC6pXV_o.png" alt="逻辑层次" title=""> <br> 其中有两个值得一提的接口，就是 <br> <strong>InitializingBean接口</strong>：实现此接口的bean会在初始化时调用器afterPropertiesSet方法来进行bean的逻辑初始化，并通过configuration实例来承载每一步所获取的信息，为创建SqlSessionFactory实例作准备。 <br> <strong>FactoryBean接口</strong>：将getBean方法转换为getObject方法，所以实际上得到的是通过onfiguration属性和getObject方法返回的初始化后的sqlSessionFactory属性</p> 
<p>接下来时另一个配置bean <strong>MapperFactoryBean</strong> <br> 我们通过区分两种获取XXMapper的方式可以看出一些区别： <br> 1.单独使用Mybatis时： <br> XXMapper xxmapper = sqlsession.getMapper(XXMapper.class); <br> 2.Spring整合之后 <br> XXMapper xxmapper = (XXMapper)context.getBean(“XXMapperID”)； <br> <img src="https://images2.imgbox.com/d4/e6/184FUt9G_o.png" alt="类继承关系" title=""> <br> Mapper的类继承关系如上图所示，可以看到它和SqlSessionFactoryBean一样实现了InitializingBean接口和FactoryBean接口，这两个接口的功能就不再赘述。 <br> <strong>InitializingBean接口</strong>： <br> 需要注意的是InitializingBean接口的afterPropertiesSet()是由DaoSupport类实现的，在该父类的方法中实现了以下几个功能： <br> 1.父类对于sqlSesion不为空的验证，sqlSession作为根据接口创建映射器代理的接触类一定不可以为空，而sqlSession又是在设定sqlSessionFactory属性时完成的，所以实际上将会检测： <br> &lt;bean id=… class=”org.mybatis.Spring.mapper.MapperFactoryBean”&gt; <br> &lt;property name=”<strong>sqlSessionFactory</strong>” ref=..&gt;<strong>该属性是否存在</strong> <br> &lt;bean&gt; <br> 2.映射接口的验证（sqlSession会根据接口动态的创建相应代理类，所以接口必不可少） <br> 3.映射文件存在性验证 <br> <strong>FactoryBean接口</strong> <br> 源代码</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> T <span class="hljs-title">getObject</span>() <span class="hljs-keyword">throws</span> Exception {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getSqlSession().getMapper(<span class="hljs-keyword">this</span>.mapperInterface);
}</code></pre> 
<p>很简单，就是将已经注册的MapperInterface返回</p> 
<p>如果我们需要指定搜索的包路径我们需要在applicationContext.xml中添加额外的配置</p> 
<pre class="prettyprint"><code class="language-java hljs ">&lt;bean class=<span class="hljs-string">"org.mybatis.Spring.mapper.MapperScannerConfigurer"</span>&gt;
    &lt;property name=<span class="hljs-string">"basePackage"</span> value=<span class="hljs-string">"指定的搜索路径"</span>&gt;
&lt;/bean&gt;</code></pre> 
<p>这时我们又会引入新的类MapperScannerConfigurer，看一下这个类的类层次结构： <br> <img src="https://images2.imgbox.com/66/69/o5VNO0XU_o.png" alt="类层次结构" title=""> <br> 其中出现了我们一直提到的接口<strong>InitializingBean接口</strong>，但是结果并没有那么顺利，这个接口的作用只是对一堆属性的验证代码。 <br> 但是我们还有一个经常出现的接口<strong>BeanFactoryPostProcessor</strong>及其子类<strong>BeanDefinitionRegistryPostProcessor</strong>接口，这两个接口都会在Spring初始化的过程中进行调用。 <br> 首先看BeanFactoryPostProcessor接口的postProcessBeanFactory方法</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span>(ConfigurableListableBeanFactory beanFactory) {
}</code></pre> 
<p>这是一个空实现，看看BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span>(BeanDefinitionRegistry registry) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.processPropertyPlaceHolders) {
            <span class="hljs-keyword">this</span>.processPropertyPlaceHolders();<span class="hljs-comment">//1</span>
        }

        ClassPathMapperScanner scanner = <span class="hljs-keyword">new</span> ClassPathMapperScanner(registry);
        scanner.setAddToConfig(<span class="hljs-keyword">this</span>.addToConfig);
        scanner.setAnnotationClass(<span class="hljs-keyword">this</span>.annotationClass);
        scanner.setMarkerInterface(<span class="hljs-keyword">this</span>.markerInterface);
        scanner.setSqlSessionFactory(<span class="hljs-keyword">this</span>.sqlSessionFactory);
        scanner.setSqlSessionTemplate(<span class="hljs-keyword">this</span>.sqlSessionTemplate);
        scanner.setSqlSessionFactoryBeanName(<span class="hljs-keyword">this</span>.sqlSessionFactoryBeanName);
        scanner.setSqlSessionTemplateBeanName(<span class="hljs-keyword">this</span>.sqlSessionTemplateBeanName);
        scanner.setResourceLoader(<span class="hljs-keyword">this</span>.applicationContext);
        scanner.setBeanNameGenerator(<span class="hljs-keyword">this</span>.nameGenerator);
        scanner.registerFilters();<span class="hljs-comment">//2</span>
      scanner.scan(StringUtils.tokenizeToStringArray(<span class="hljs-keyword">this</span>.basePackage, <span class="hljs-string">",; \t\n"</span>));<span class="hljs-comment">//3</span>
 }</code></pre> 
<p>我们首先关注this.processPropertyPlaceHolders()这个部分，这个函数有一个很重要的说明，就是BeanDefinitionRegistris方法会在应用启动时就开始调用，并且会早于BeanFactoryPostProcessors调用，这就意味着PropertyResourceConfigurers并未被加载，所以所有对属性文件的引用都会失效。所以我们需要在MapperScannerConfigurer的配置文件中显式的配置processPropertyPlaceHolders如下配置所示：</p> 
<pre class="prettyprint"><code class="language-java hljs ">&lt;bean class = <span class="hljs-string">"org.mybatis.Spring.mapper.MapperScannerConfigurer&gt;
    &lt;property ...&gt;
    &lt;property name="</span>processPropertyPlaceHolders<span class="hljs-string">" value="</span><span class="hljs-keyword">true</span><span class="hljs-string">"&gt;
    //通过显示得配置引导程序进入processPropertyPlaceHolders方法
    //从而显示地读取属性文件
&lt;/bean&gt;</span></code></pre> 
<p>接下来我们关注2号注解scanner.registerFilters();//2这个方法主要是根据前一段代码的属性配置生成对应的过滤器，主要处理了： <br> 1.annotationClass属性（根据设置的annotationClass生成能够达到用户效果的过滤器） <br> 2.markerInterface属性（目的同上） <br> 3.全局默认处理（随上面两者的值进行改变，如果都未设定将生成默认过滤器接受所有接口文件） <br> 4.package-info.java处理（排出package-info命名的Java文件）</p> 
<p>最后就是注释3scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, “,; \t\n”));//3收尾的工作了，这个方法主要完成了下面的步骤： <br> 1.首先根据传入的包信息生成绝对路径，并且生成相应的bean <br> 2.根据前面第二步注册的过滤器来控制扫描的结果 <br> 3.根据不同类型的bean进行不同的操作</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fec71bfe84faa15456fca0622617b942/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IIS7如何实现访问HTTP跳转到HTTPS访问</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e7d834684df057be59e8d7de5b694856/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">粒子群算法（初步）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>