<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《剑指offer》专题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《剑指offer》专题" />
<meta property="og:description" content="1 基础知识 面试题3：数组中重复的数字 https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/
class Solution { public int findRepeatNumber(int[] nums) { Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 1; i&#43;&#43;) { if (nums[i] == nums[i &#43; 1]) { return nums[i]; } } return Integer.MAX_VALUE; } } 面试题4：二维数组中的查找 https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/
class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix.length &lt; 1 || matrix[0].length &lt; 1) { return false; } int i = 0; int j = matrix[i]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4e574e4fa81aa663d3a2f0a6358830c9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-19T16:03:43+08:00" />
<meta property="article:modified_time" content="2022-11-19T16:03:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《剑指offer》专题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1 基础知识</h3> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%983%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">面试题3：数组中重复的数字</h4> 
<p><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/?favorite=xb9nqhhg" rel="nofollow" title="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int findRepeatNumber(int[] nums) {
        Arrays.sort(nums);
        for (int i = 0; i &lt; nums.length - 1; i++) {
            if (nums[i] == nums[i + 1]) {
                return nums[i];
            }
        }
        return Integer.MAX_VALUE;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%984%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">面试题4：二维数组中的查找</h4> 
<p><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/?favorite=xb9nqhhg" rel="nofollow" title="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if (matrix.length &lt; 1 || matrix[0].length &lt; 1) {
            return false;
        }
        int i = 0;
        int j = matrix[i].length - 1;
        while (i &lt; matrix.length &amp;&amp; j &gt;= 0) {
            if (matrix[i][j] == target) {
                return true;
            } else if (matrix[i][j] &gt; target) {
                j--;
            } else {
                i++;
            }
        }
        return false;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E5%AE%985%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC">面试官5：替换空格</h4> 
<p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/" rel="nofollow" title="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">https://leetcode.cn/problems/ti-huan-kong-ge-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public String replaceSpace(String s) {
        char[] cArray = s.toCharArray();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; cArray.length; i++) {
            sb.append(Character.isSpaceChar(cArray[i]) ? "%20" : cArray[i]);
        }
        return sb.toString();
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%986%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">面试题6：从尾到头打印链表</h4> 
<p><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" rel="nofollow" title="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

    public int[] reversePrint(ListNode head) {
        if (head == null) {
            return new int[0];
        }
        reverse(head);
        int[] array = new int[list.size()];
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = list.get(i);
        }
        return array;
    }

    public void reverse(ListNode head) {
        if (head.next != null) {
            reversePrint(head.next);
        }
        list.add(head.val);
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%989%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">面试题9：用两个栈实现队列</h4> 
<p><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" rel="nofollow" title="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</a></p> 
<pre><code class="language-java">class CQueue {
    Stack&lt;Integer&gt; stack1;
    Stack&lt;Integer&gt; stack2;

    public CQueue() {
        stack1 = new Stack();
        stack2 = new Stack();
    }

    public void appendTail(int value) {
        stack2.push(value);
    }

    public int deleteHead() {
        int head = -1;
        if (stack1.size() &gt; 0 || stack2.size() &gt; 0) {
            if (stack1.size() == 0 &amp;&amp; stack2.size() &gt; 0) {
                while (stack2.size() &gt; 0) {
                    stack1.push(stack2.pop());
                }
            }
            head = stack1.pop();
        }
        return head;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9810-1%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">面试题10-1：斐波那契数列</h4> 
<p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/" rel="nofollow" title="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/</a></p> 
<pre><code class="language-java">class Solution {
   public int fib(int n) {
        int x = 0;
        int y = 1;
        int z = 1;
        while (n &gt; 0) {
            z = (x + y) % 1000000007;
            x = y;
            y = z;
            n--;
        }
        return x;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9810-2%EF%BC%9A%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98">面试题10-2：青蛙跳台阶问题</h4> 
<p><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" rel="nofollow" title="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    Map&lt;Integer, Integer&gt; map = new HashMap();

    public int numWays(int n) {
        if (n == 1) {
            return 1;
        }
        if (n == 2) {
            return 2;
        }
        if (n &gt; 2) {
            if (map.containsKey(n)) {
                return map.get(n);
            }
            int num = (numWays(n - 1) + numWays(n - 2)) % 1000000007;
            map.put(n, num);
            return num;
        }
        return 1;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9811%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">面试题11：旋转数组的最小数字</h4> 
<p><a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" rel="nofollow" title="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int minArray(int[] numbers) {
        if (numbers.length == 0) {
            return Integer.MAX_VALUE;
        }
        int result = numbers[0];
        for (int i = 0; i &lt; numbers.length - 1; i++) {
            if (numbers[i] &gt; numbers[i + 1]) {
                return numbers[i + 1];
            }
        }
        return result;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9812%EF%BC%9A%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84">面试题12：矩阵中的路径</h4> 
<p><a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/" rel="nofollow" title="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public boolean exist(char[][] board, String word) {
        if ("".equals(word)) {
            return true;
        }
        if (board.length == 0 || board[0].length == 0) {
            return false;
        }
        boolean[][] passed = new boolean[board.length][board[0].length];
        char[] cArray = word.toCharArray();
        List&lt;String&gt; starts = new ArrayList();
        for (int i = 0; i &lt; board.length; i++) {
            for (int j = 0; j &lt; board[0].length; j++) {
                if (board[i][j] == cArray[0]) {
                    starts.add(i + "," + j);
                }
            }
        }
        if (!starts.isEmpty()) {
            for (int k = 0; k &lt; starts.size(); k++) {
                String[] strs = starts.get(k).split(",");
                int x = Integer.parseInt(strs[0]);
                int y = Integer.parseInt(strs[1]);
                passed[x][y] = true;
                if (next(board, cArray, x, y, 1, passed)) {
                    return true;
                }
                passed[x][y] = false;
            }
        }
        return false;
    }

    public boolean next(char[][] board, char[] cArray, int x, int y, int next, boolean[][] passed) {
        if (next == cArray.length) {
            return true;
        }
        boolean bool;
        if (x &gt; 0 &amp;&amp; board[x - 1][y] == cArray[next] &amp;&amp; !passed[x - 1][y]) {
            passed[x - 1][y] = true;
            bool = next(board, cArray, x - 1, y, next + 1, passed);
            passed[x - 1][y] = false;
            if (bool) {
                return true;
            }
        }
        if (y &gt; 0 &amp;&amp; board[x][y - 1] == cArray[next] &amp;&amp; !passed[x][y - 1]) {
            passed[x][y - 1] = true;
            bool = next(board, cArray, x, y - 1, next + 1, passed);
            passed[x][y - 1] = false;
            if (bool) {
                return true;
            }
        }
        if (x &lt; board.length - 1 &amp;&amp; board[x + 1][y] == cArray[next] &amp;&amp; !passed[x + 1][y]) {
            passed[x + 1][y] = true;
            bool = next(board, cArray, x + 1, y, next + 1, passed);
            passed[x + 1][y] = false;
            if (bool) {
                return true;
            }
        }
        if (y &lt; board[0].length - 1 &amp;&amp; board[x][y + 1] == cArray[next] &amp;&amp; !passed[x][y + 1]) {
            passed[x][y + 1] = true;
            bool = next(board, cArray, x, y + 1, next + 1, passed);
            passed[x][y + 1] = false;
            if (bool) {
                return true;
            }
        }
        return false;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9813%EF%BC%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4">面试题13：机器人的运动范围</h4> 
<p><a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" rel="nofollow" title="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    int count;

    public int movingCount(int m, int n, int k) {
        count = 0;
        boolean[][] booleans = new boolean[m][n];
        analyze(m, n, 0, 0, k, booleans);
        return count;
    }

    public void analyze(int m, int n, int i, int j, int k, boolean[][] booleans) {
        if (getCompareResult(i) + getCompareResult(j) &lt;= k &amp;&amp; !booleans[i][j]) {
            booleans[i][j] = true;
            count++;
        }
        if (i &gt; 0 &amp;&amp; getCompareResult(i - 1) + getCompareResult(j) &lt;= k &amp;&amp; !booleans[i - 1][j]) {
            analyze(m, n, i - 1, j, k, booleans);
        }
        if (j &gt; 0 &amp;&amp; getCompareResult(i) + getCompareResult(j - 1) &lt;= k &amp;&amp; !booleans[i][j - 1]) {
            analyze(m, n, i, j - 1, k, booleans);
        }
        if (i &lt; m - 1 &amp;&amp; getCompareResult(i + 1) + getCompareResult(j) &lt;= k
            &amp;&amp; !booleans[i + 1][j]) {
            analyze(m, n, i + 1, j, k, booleans);
        }
        if (j &lt; n - 1 &amp;&amp; getCompareResult(i) + getCompareResult(j + 1) &lt;= k
            &amp;&amp; !booleans[i][j + 1]) {
            analyze(m, n, i, j + 1, k, booleans);
        }
    }

    public int getCompareResult(int num) {
        int sum = 0;
        while (num != 0) {
            sum = sum + num % 10;
            num = num / 10;
        }
        return sum;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9814-1%EF%BC%9A%E5%89%AA%E7%BB%B3%E5%AD%90">面试题14-1：剪绳子</h4> 
<p><a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/" rel="nofollow" title="https://leetcode.cn/problems/jian-sheng-zi-lcof/">https://leetcode.cn/problems/jian-sheng-zi-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int cuttingRope(int n) {
        // 由题意，m&gt;=2
        int max = Integer.MIN_VALUE;
        int mMax;
        int base;
        int rest;
        for (int m = 2; m &lt;= n; m++) {
            base = n / m;
            rest = n % m;
            // m个数，rest个base+1，m-rest个base
            mMax = (int) (Math.pow(base, m - rest) * Math.pow(base + 1, rest));
            if (mMax &gt; max) {
                max = mMax;
            }
        }
        return max;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9815%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">面试题15：二进制中1的个数</h4> 
<p><a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" rel="nofollow" title="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int hammingWeight(int n) {
        int count = 0;
        for (int i = 0; i &lt; 32; i++) {
            if ((n &amp; (1 &lt;&lt; i)) != 0) {
                count++;
            }
        }
        return count;
    }
}</code></pre> 
<h3 id="2%20%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F">2 代码质量</h3> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9816%EF%BC%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9">面试题16：数值的整数次方</h4> 
<p><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" rel="nofollow" title="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    Map&lt;Long, Double&gt; map = new HashMap&lt;&gt;();

    public double myPow(double x, int n) {
        if (x == 0 &amp;&amp; n &lt; 0) {
            return 0;
        }
        long lnl;
        if (n != Integer.MIN_VALUE) {
            lnl = n &gt; 0 ? n : -n;
        } else {
            lnl = 2147483648L;
        }
        double result = getResult(x, lnl);
        if (n &gt; 0) {
            return result;
        } else {
            return 1.0 / result;
        }
    }

    public double getResult(double x, long n) {
        if (n == 0) {
            return 1;
        }
        if (n == 1) {
            return x;
        }
        if (map.containsKey(n)) {
            return map.get(n);
        }
        if (n % 2 == 0) {
            map.put(n, getResult(x, n / 2) * getResult(x, n / 2));

        } else {
            map.put(n, getResult(x, n / 2) * getResult(x, n / 2) * x);
        }
        return map.get(n);
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9817%EF%BC%9A%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0">面试题17：打印从1到最大的n位数</h4> 
<p><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" rel="nofollow" title="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int[] printNumbers(int n) {
        int count = (int) (Math.pow(10, n) - 1);
        int[] result = new int[count];
        for (int i = 0; i &lt; count; i++) {
            result[i] = i + 1;
        }
        return result;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9818%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9">面试题18：删除链表的节点</h4> 
<p><a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/" rel="nofollow" title="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        if (head == null) {
            return null;
        }
        if (head.next == null) {
            if (head.val == val) {
                return null;
            } else {
                return head;
            }
        }
        ListNode p1 = new ListNode(0);
        p1.next = head;
        ListNode p2 = head.next != null ? head.next : null;
        ListNode p3 = p1;
        while (p2 != null) {
            if (head.val == val) {
                p1.next = p2;
                break;
            }
            p2 = p2.next != null ? p2.next : null;
            head = head.next;
            p1 = p1.next;
        }
        if (head.val == val) {
            p1.next = p2;
        }
        return p3.next != null ? p3.next : null;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9820%EF%BC%9A%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">面试题20：表示数值的字符串</h4> 
<p><a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" rel="nofollow" title="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    static List&lt;Character&gt; list;
    static {
        list = new ArrayList();
        list.add('0');
        list.add('1');
        list.add('2');
        list.add('3');
        list.add('4');
        list.add('5');
        list.add('6');
        list.add('7');
        list.add('8');
        list.add('9');
    }

    public boolean isNumber(String s) {
        String trimS = s.trim();
        String upTrimS = trimS.toUpperCase();
        if ("".equals(upTrimS)) {
            return false;
        }
        char[] charS = upTrimS.toCharArray();

        boolean containsE = false;
        for (int i = 0; i &lt; charS.length; i++) {
            if (charS[i] == 'e' || charS[i] == 'E') {
                containsE = true;
                break;
            }
        }
        if (containsE) {
            if (charS[0] == 'E' || charS[charS.length - 1] == 'E') {
                return false;
            }
            String[] byE = upTrimS.split("E");
            if (byE.length != 2) {
                return false;
            }
            char[] spilt1 = byE[0].toCharArray();
            char[] spilt2 = byE[1].toCharArray();
            if (spilt1.length == 0) {
                return false;
            }
            if (!isIntNumber(spilt2)) {
                return false;
            }
            charS = spilt1;
        }

        int countPoint = 0;
        boolean containsNum = false;
        for (int k = 0; k &lt; charS.length; k++) {
            if (k == 0 &amp;&amp; (charS[k] == '+' || charS[k] == '-')) {
                continue;
            }
            if (charS[k] == '.') {
                countPoint++;
                continue;
            }
            if (!list.contains(charS[k])) {
                return false;
            } else {
                containsNum = true;
            }
        }
        if (!containsNum || countPoint &gt; 1) {
            return false;
        }

        return true;
    }

    public boolean isIntNumber(char[] array) {
        for (int j = 0; j &lt; array.length; j++) {
            if (j == 0 &amp;&amp; (array[j] == '+' || array[j] == '-')) {
                if (array.length == 1) {
                    return false;
                }
                continue;
            }
            if (!list.contains(array[j])) {
                return false;
            }
        }
        return true;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9821%EF%BC%9A%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2">面试题21：调整数组顺序使奇数位于偶数前面</h4> 
<p><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" rel="nofollow" title="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    int mark;

    public int[] exchange(int[] nums) {
        if (nums.length &lt; 2) {
            return nums;
        }
        int p1 = 0;
        int p2 = nums.length - 1;
        while (p1 &lt; p2) {
            if (nums[p1] % 2 == 1) {
                p1++;
                continue;
            }
            if (nums[p2] % 2 == 0) {
                p2--;
                continue;
            }
            mark = nums[p1];
            nums[p1] = nums[p2];
            nums[p2] = mark;
            p1++;
            p2--;
        }
        return nums;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9822%EF%BC%9A%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">面试题22：链表中倒数第k个节点</h4> 
<p><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" rel="nofollow" title="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    int      count = Integer.MIN_VALUE;
    ListNode Kth;

    public ListNode getKthFromEnd(ListNode head, int k) {
        if (head == null) {
            return null;
        }
        getKth(head, k);
        return Kth;
    }

    public void getKth(ListNode head, int k) {
        if (head.next == null) {
            count = 1;
        } else {
            getKth(head.next, k);
            count++;
        }
        if (count == k) {
            Kth = head;
        }
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9824%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">面试题24：反转链表</h4> 
<p><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/" rel="nofollow" title="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    ListNode p1;
    ListNode p2;

    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        while (head.next != null) {
            p2 = head.next;
            head.next = p1;
            p1 = head;
            head = p2;
        }
        head.next = p1;
        return head;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9825%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">面试题25：合并两个排序的链表</h4> 
<p><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" rel="nofollow" title="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        ListNode stone = new ListNode(0);
        ListNode current = stone;
        while (l1 != null || l2 != null) {
            if (l1.val &lt;= l2.val) {
                current.next = l1;
                l1 = l1.next != null ? l1.next : new ListNode(Integer.MAX_VALUE);
            } else {
                current.next = l2;
                l2 = l2.next != null ? l2.next : new ListNode(Integer.MAX_VALUE);
            }
            current = current.next;
            if (l1.val == Integer.MAX_VALUE &amp;&amp; l2.val == Integer.MAX_VALUE) {
                break;
            }
        }
        return stone.next;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9826%EF%BC%9A%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">面试题26：树的子结构</h4> 
<p><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/" rel="nofollow" title="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    boolean is = false;

    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if (B == null) {
            return is;
        }
        dfs(A, B, B.val);
        return is;
    }

    public void dfs(TreeNode node1, TreeNode node2, int root) {
        if (node1 == null) {
            return;
        }
        if (!is){
            if (node1.val == root) {
                is = compare(node1, node2);
            }
            dfs(node1.left, node2, root);
            dfs(node1.right, node2, root);
        }
    }

    public boolean compare(TreeNode node1, TreeNode node2) {
        if (node1 == null) {
            return false;
        }
        if (node1.val != node2.val) {
            return false;
        }
        boolean b1 = true;
        boolean b2 = true;
        if (node2.left != null) {
            b1 = compare(node1.left, node2.left);
        }
        if (node2.right != null) {
            b2 = compare(node1.right, node2.right);
        }
        return b1 &amp;&amp; b2;
    }
}</code></pre> 
<h3 id="3%20%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">3 解题思路</h3> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9827%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F">面试题27：二叉树的镜像</h4> 
<p><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/" rel="nofollow" title="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    TreeNode treeNode;

    public TreeNode mirrorTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        mirror(root);
        return root;
    }

    public void mirror(TreeNode node) {
        treeNode = node.left;
        node.left = node.right;
        node.right = treeNode;
        if (node.left != null) {
            mirror(node.left);
        }
        if (node.right != null) {
            mirror(node.right);
        }
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9828%EF%BC%9A%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91">面试题28：对称的二叉树</h4> 
<p><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/" rel="nofollow" title="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return compare(root.left, root.right);
    }

    public boolean compare(TreeNode node1, TreeNode node2) {
        if (node1 == null &amp;&amp; node2 == null) {
            return true;
        }
        if (node1 == null || node2 == null) {
            return false;
        }
        if (node1.val != node2.val) {
            return false;
        }
        return compare(node1.left, node2.right) &amp;&amp; compare(node1.right, node2.left);
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9829%EF%BC%9A%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5">面试题29：顺时针打印矩阵</h4> 
<p><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" rel="nofollow" title="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    int           mark = 0;                // 0:向右 1:向下 2:向左 3:向上
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

    public int[] spiralOrder(int[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return new int[0];
        }
        work(matrix, 0, 0, 0, matrix[0].length - 1, 0, matrix.length - 1);
        int[] result = new int[list.size()];
        for (int k = 0; k &lt; result.length; k++) {
            result[k] = list.get(k);
        }
        return result;
    }

    public void work(int[][] matrix, int i, int j, int left, int right, int top, int bottom) {
        if (left &gt; right || top &gt; bottom) {
            return;
        }
        list.add(matrix[i][j]);
        if (mark == 0) {
            if (j &lt; right) {
                work(matrix, i, j + 1, left, right, top, bottom);
            } else {
                top++;
                mark = 1;
                work(matrix, i + 1, j, left, right, top, bottom);
            }
            return;
        }
        if (mark == 1) {
            if (i &lt; bottom) {
                work(matrix, i + 1, j, left, right, top, bottom);
            } else {
                right--;
                mark = 2;
                work(matrix, i, j - 1, left, right, top, bottom);
            }
            return;
        }
        if (mark == 2) {
            if (j &gt; left) {
                work(matrix, i, j - 1, left, right, top, bottom);
            } else {
                bottom--;
                mark = 3;
                work(matrix, i - 1, j, left, right, top, bottom);
            }
            return;
        }
        if (mark == 3) {
            if (i &gt; top) {
                work(matrix, i - 1, j, left, right, top, bottom);
            } else {
                left++;
                mark = 0;
                work(matrix, i, j + 1, left, right, top, bottom);
            }
            return;
        }
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9830%EF%BC%9A%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88">面试题30：包含min函数的栈</h4> 
<p><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/" rel="nofollow" title="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/</a></p> 
<pre><code class="language-java">class MinStack {
    Stack&lt;Integer&gt; stack1;
    Stack&lt;Integer&gt; stack2;
    int            min;

    public MinStack() {
        stack1 = new Stack();
        stack2 = new Stack();
        min = Integer.MAX_VALUE;
    }

    public void push(int x) {
        stack1.push(x);
        if (x &lt; min) {
            min = x;
        }
        stack2.push(min);
    }

    public void pop() {
        stack1.pop();
        stack2.pop();
        if (!stack2.empty()) {
            min = stack2.peek();
        } else {
            min = Integer.MAX_VALUE;
        }
    }

    public int top() {
        return stack1.peek();
    }

    public int min() {
        return stack2.peek();
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9831%EF%BC%9A%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97">面试题31：栈的压入、弹出序列</h4> 
<p><a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" rel="nofollow" title="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        if (pushed.length != popped.length) {
            return false;
        }
        if (pushed.length == 0) {
            return true;
        }
        // 一个数据出栈时，必须是栈顶元素或未进栈元素
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int count = 0;

        for (int i = 0; i &lt; popped.length; i++) {
            if (stack.contains(popped[i])) {
                if (stack.peek() != popped[i]) {
                    return false;
                }
                stack.pop();
                continue;
            }
            for (int j = count; j &lt; pushed.length; j++) {
                stack.add(pushed[j]);
                count++;
                if (pushed[j] == popped[i]) {
                    stack.pop();
                    break;
                }
            }
        }

        if (stack.size() == 0) {
            return true;
        } else {
            return false;
        }
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9832-1%EF%BC%9A%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">面试题32-1：从上到下打印二叉树</h4> 
<p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" rel="nofollow" title="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    List&lt;Integer&gt;   list  = new ArrayList&lt;&gt;();
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();

    public int[] levelOrder(TreeNode root) {
        if (root == null) {
            return new int[0];
        }
        addNode(root);
        while (!queue.isEmpty()) {
            addNode(queue.poll());
        }
        int[] array = new int[list.size()];
        for (int i = 0; i &lt; list.size(); i++) {
            array[i] = list.get(i);
        }
        return array;
    }

    public void addNode(TreeNode node) {
        list.add(node.val);
        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9832-2%EF%BC%9A%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%912">面试题32-2：从上到下打印二叉树2</h4> 
<p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" rel="nofollow" title="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    List&lt;List&lt;Integer&gt;&gt;         lists        = new ArrayList&lt;&gt;(); //result
    Map&lt;Integer, List&lt;Integer&gt;&gt; levelListMap = new HashMap&lt;&gt;();   //key:level, value:list
    Map&lt;TreeNode, Integer&gt;      nodeLevelMap = new HashMap&lt;&gt;();   //key:node, value:level
    Queue&lt;TreeNode&gt;             queue        = new LinkedList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        if (root == null) {
            return new ArrayList&lt;&gt;();
        }
        nodeLevelMap.put(root, 1);
        addNode(root);
        while (!queue.isEmpty()) {
            addNode(queue.poll());
        }
        for (int i = 1; true; i++) {
            if (levelListMap.containsKey(i)) {
                lists.add(levelListMap.get(i));
            } else {
                break;
            }
        }
        return lists;
    }

    public void addNode(TreeNode node) {
        if (!levelListMap.containsKey(nodeLevelMap.get(node))) {
            levelListMap.put(nodeLevelMap.get(node), new ArrayList&lt;&gt;());
        }
        levelListMap.get(nodeLevelMap.get(node)).add(node.val);

        if (node.left != null) {
            queue.add(node.left);
            nodeLevelMap.put(node.left, nodeLevelMap.get(node) + 1);
        }
        if (node.right != null) {
            queue.add(node.right);
            nodeLevelMap.put(node.right, nodeLevelMap.get(node) + 1);
        }
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9832-3%EF%BC%9A%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%913">面试题32-3：从上到下打印二叉树3</h4> 
<p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" rel="nofollow" title="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    List&lt;List&lt;Integer&gt;&gt;         lists        = new ArrayList&lt;&gt;();
    Map&lt;Integer, List&lt;Integer&gt;&gt; levelListMap = new HashMap&lt;&gt;();   //key:level, value:list
    Map&lt;TreeNode, Integer&gt;      nodeLevelMap = new HashMap&lt;&gt;();   //key:node, value:level
    Queue&lt;TreeNode&gt;             queue        = new LinkedList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        if (root == null) {
            return new ArrayList&lt;&gt;();
        }
        nodeLevelMap.put(root, 1);
        addNode(root);
        while (!queue.isEmpty()) {
            addNode(queue.poll());
        }
        for (int i = 1; true; i++) {
            if (levelListMap.containsKey(i)) {
                lists.add(levelListMap.get(i));
            } else {
                break;
            }
        }
        return lists;
    }

    public void addNode(TreeNode node) {
        if (!levelListMap.containsKey(nodeLevelMap.get(node))) {
            levelListMap.put(nodeLevelMap.get(node), new ArrayList&lt;&gt;());
        }
        if (nodeLevelMap.get(node) % 2 == 1) {
            levelListMap.get(nodeLevelMap.get(node)).add(node.val);
        } else {
            levelListMap.get(nodeLevelMap.get(node)).add(0, node.val); //头插入
        }

        if (node.left != null) {
            queue.add(node.left);
            nodeLevelMap.put(node.left, nodeLevelMap.get(node) + 1);
        }
        if (node.right != null) {
            queue.add(node.right);
            nodeLevelMap.put(node.right, nodeLevelMap.get(node) + 1);
        }
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9833%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97">面试题33：二叉搜索树的后序遍历序列</h4> 
<p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" rel="nofollow" title="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    boolean is = true;

    public boolean verifyPostorder(int[] postorder) {
        if (postorder.length == 0) {
            return true;
        }
        work(postorder, postorder.length - 1);
        return is;
    }

    public void work(int[] postorder, int right) {
        if (postorder[0] &gt; postorder[right]) {
            for (int i = 0; i &lt; right; i++) {
                if (postorder[i] &lt; postorder[right]) {
                    is = false;
                }
            }
        } else {
            boolean change = false;
            for (int i = 0; i &lt; right; i++) {
                if (postorder[i] &gt; postorder[right]) {
                    change = true;
                }
                if (change &amp;&amp; postorder[i] &lt; postorder[right]) {
                    is = false;
                }
            }
        }
        if (right &gt; 0) {
            work(postorder, right - 1);
        }
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9834%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84">面试题34：二叉树中和为某一值的路径</h4> 
<p><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" rel="nofollow" title="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    List&lt;List&lt;Integer&gt;&gt; lists  = new ArrayList&lt;&gt;();
    Stack&lt;TreeNode&gt;     stack1 = new Stack&lt;&gt;();
    Stack&lt;TreeNode&gt;     stack2 = new Stack&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) {
        if (root == null) {
            return new ArrayList&lt;&gt;();
        }
        int currentSum = root.val;
        work(root, currentSum, target);
        return lists;
    }

    public void work(TreeNode node, int currentSum, int target) {
        stack1.push(node);
        if (node.left == null &amp;&amp; node.right == null &amp;&amp; target - currentSum == 0) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
            TreeNode tn;
            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            while (!stack2.isEmpty()) {
                tn = stack2.pop();
                list.add(tn.val);
                stack1.push(tn);
            }
            lists.add(list);
        }
        if (node.left != null) {
            work(node.left, currentSum + node.left.val, target);
        }
        if (node.right != null) {
            work(node.right, currentSum + node.right.val, target);
        }
        stack1.pop();
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9835%EF%BC%9A%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">面试题35：复杂链表的复制</h4> 
<p><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/" rel="nofollow" title="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;();
    Node            p1;
    Node            p2;

    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }
        p1 = head;
        Node head2 = new Node(0);
        p2 = head2;
        while (p1 != null) {
            p2.next = new Node(p1.val);
            p2 = p2.next;
            p2.random = p1.random;
            map.put(p1, p2);
            if (p1.next != null) {
                p1 = p1.next;
            } else {
                p1 = null;
            }
        }

        p2 = head2.next;
        while (p2 != null) {
            p2.random = map.get(p2.random);
            if (p2.next != null) {
                p2 = p2.next;
            } else {
                p2 = null;
            }
        }

        return head2.next;
    }
}</code></pre> 
<h4>面试题36：二叉搜索树与双向链表</h4> 
<p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" rel="nofollow" title="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    Node pre = null;
    Node head;

    public Node treeToDoublyList(Node root) {
        if (root == null) {
            return null;
        }
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }

    public void dfs(Node node) {
        if (node == null) {
            return;
        }
        dfs(node.left);
        if (head == null) {
            head = node;
        }
        if (pre != null) {
            pre.right = node;
            node.left = pre;
        }
        pre = node; // 4
        dfs(node.right);
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9838%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97">面试题38：字符串的排列</h4> 
<p><a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/" rel="nofollow" title="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public String[] permutation(String s) {
        if (s.length() == 0) {
            return new String[] { "" };
        }
        char[] chars = s.toCharArray();
        Arrays.sort(chars);

        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();
        String current;
        int currentLength = 0;
        for (int i = 0; i &lt; chars.length; i++) {
            currentLength++;
            if (queue.isEmpty()) {
                queue.add(String.valueOf(chars[i]));
                continue;
            }
            while (!queue.isEmpty()) {
                if (queue.peek().length() == currentLength) {
                    break;
                }
                current = ((LinkedList&lt;String&gt;) queue).pop();
                for (int k = 0; k &lt;= current.length(); k++) {
                    StringBuilder sb = new StringBuilder();
                    sb.append(current);
                    sb.insert(k, chars[i]);
                    queue.add(sb.toString());
                }
            }
        }

        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        set.addAll(queue);
        String[] strs = set.stream().toArray(String[]::new);

        return strs;
    }
}</code></pre> 
<h3 id="4%20%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87">4 优化时间和空间效率</h3> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9839%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97">面试题39：数组中出现次数超过一半的数字</h4> 
<p><a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" rel="nofollow" title="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int majorityElement(int[] nums) {
        if (nums.length == 1 || nums.length == 2) {
            return nums[0];
        }
        Arrays.sort(nums);
        return nums[nums.length / 2];
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9840%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0">面试题40：最小的k个数</h4> 
<p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/" rel="nofollow" title="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        Arrays.sort(arr);
        int[] result = new int[k];
        for (int i = 0; i &lt; k; i++) {
            result[i] = arr[i];
        }
        return result;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9841%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">面试题41：数据流中的中位数</h4> 
<p><a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" rel="nofollow" title="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</a></p> 
<pre><code class="language-java">class MedianFinder {
    List&lt;Integer&gt; list;
    double        median;

    public MedianFinder() {
        list = new ArrayList&lt;&gt;();
    }

    public void addNum(int num) {
        if (list.size() == 0 || list.get(list.size() - 1) &lt;= num) {
            list.add(num);
        } else {
            for (int i = 0; i &lt; list.size(); i++) {
                if (list.get(i) &gt; num) {
                    list.add(i, num);
                    break;
                }
            }
        }
    }

    public double findMedian() {
        if (list.size() % 2 == 1) {
            median = (double) list.get(list.size() / 2);
        } else {
            median = (double) (list.get(list.size() / 2 - 1) + list.get(list.size() / 2)) / 2;
        }
        return median;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9842%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">面试题42：连续子数组的最大和</h4> 
<p><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" rel="nofollow" title="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int maxSubArray(int[] nums) {
        int sum = 0;
        int maxSum = Integer.MIN_VALUE;
        int maxNum = Integer.MIN_VALUE;
        for (int i = 0; i &lt; nums.length; i++) {
            sum = sum + nums[i];
            if (nums[i] &gt; 0 &amp;&amp; sum &gt; maxSum) {
                maxSum = sum;
            }
            if (sum &lt; 0) {
                sum = 0;
            }
            if (nums[i] &gt; maxNum) {
                maxNum = nums[i];
            }
        }
        if (maxSum &lt; 0) {
            maxSum = maxNum;
        }
        return maxSum;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9844%EF%BC%9A%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E6%95%B0%E5%AD%97">面试题44：数字序列中某一位数字</h4> 
<p><a href="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" rel="nofollow" title="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int findNthDigit(int n) {
        if (n &lt; 10) {
            return n;
        }
        long sum = 0L;
        long lastSum = 0L;
        int k = 0;
        while (sum &lt; n) {
            lastSum = sum;
            sum = (long) (sum + 9 * Math.pow(10, k) * (k + 1));
            k++;
        }

        long rest = n - lastSum;
        long begin = (long) Math.pow(10, k - 1);
        long result = begin + (rest - 1) / k;

        char[] chars = String.valueOf(result).toCharArray();
        int index = (int) ((rest - 1) % k);

        return (int) Long.parseLong(String.valueOf(chars[index]));
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9846%EF%BC%9A%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2">面试题46：把数字翻译成字符串</h4> 
<p><a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" rel="nofollow" title="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    Map&lt;Integer, Integer&gt; map = new HashMap();

    public int translateNum(int num) {
        if (num == 0) {
            return 1;
        }
        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        while (num != 0) {
            list.add(0, num % 10);
            num = num / 10;
        }
        return getNum(list, list.size() - 1);
    }

    public int getNum(List&lt;Integer&gt; list, int index) {
        if (map.containsKey(index)) {
            return map.get(index);
        }
        if (index == 0) {
            return 1;
        }
        if (index == 1) {
            if ((list.get(index - 1) == 1) || (list.get(index - 1) == 2 &amp;&amp; list.get(index) &lt;= 5)) {
                return 2;
            }
            return 1;
        }
        if ((list.get(index - 1) == 1) || (list.get(index - 1) == 2 &amp;&amp; list.get(index) &lt;= 5)) {
            map.put(index, getNum(list, index - 1) + getNum(list, index - 2));
        } else {
            map.put(index, getNum(list, index - 1));
        }
        return map.get(index);
    }
}
</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9847%EF%BC%9A%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC">面试题47：礼物的最大价值</h4> 
<p><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/" rel="nofollow" title="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();

    public int maxValue(int[][] grid) {
        if (grid.length &lt; 1 || grid[0].length &lt; 1) {
            return 0;
        }
        int m = grid.length;
        int n = grid[0].length;
        int result = getValue(grid, m - 1, n - 1);
        return result;
    }

    public int getValue(int[][] grid, int x, int y) {
        if (x &lt; 0 || y &lt; 0) {
            return 0;
        }
        if (map.containsKey(x + "," + y)) {
            return map.get(x + "," + y);
        } else {
            map.put(x + "," + y,
                grid[x][y] + compare(getValue(grid, x - 1, y), getValue(grid, x, y - 1)));
            return map.get(x + "," + y);
        }
    }

    public int compare(int a, int b) {
        return a &gt;= b ? a : b;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9848%EF%BC%9A%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2">面试题48：最长不含重复字符的子字符串</h4> 
<p><a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" rel="nofollow" title="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    Set&lt;Character&gt; set = new HashSet&lt;&gt;();

    public int lengthOfLongestSubstring(String s) {
        if ("".equals(s)) {
            return 0;
        }
        char[] arr = s.toCharArray();
        int maxSize = 0;
        int begin = 0;
        int current = 0;
        while (current &lt; arr.length) {
            if (!set.contains(arr[current])) {
                set.add(arr[current]);
                if (maxSize &lt; current - begin + 1) {
                    maxSize = current - begin + 1;
                }
            } else {
                while (arr[begin] != arr[current]) {
                    set.remove(arr[begin]);
                    begin++;
                }
                begin++;
            }
            current++;
        }
        return maxSize;
    }
}</code></pre> 
<h4>面试题49：丑数</h4> 
<p><a href="https://leetcode.cn/problems/chou-shu-lcof/" rel="nofollow" title="https://leetcode.cn/problems/chou-shu-lcof/">https://leetcode.cn/problems/chou-shu-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int nthUglyNumber(int n) {
        int p2 = 0;
        int p3 = 0;
        int p5 = 0;
        int[] dp = new int[n];
        dp[0] = 1;
        for(int i = 1; i &lt; n; i++){
            dp[i] = Math.min(dp[p2] * 2, Math.min(dp[p3] * 3, dp[p5] * 5));
            if(dp[i] == dp[p2] * 2){
                p2++;
            }
            if(dp[i] == dp[p3] * 3){
                p3++;
            }
            if(dp[i] == dp[p5] * 5){
                p5++;
            }
        }
        return dp[n - 1];
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9850%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6">面试题50：第一个只出现一次的字符</h4> 
<p><a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" rel="nofollow" title="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public char firstUniqChar(String s) {
        if ("".equals(s)) {
            return ' ';
        }
        char[] cArray = s.toCharArray();
        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
        int count;
        for (int i = 0; i &lt; cArray.length; i++) {
            count = 1;
            if (map.containsKey(cArray[i])) {
                count = map.get(cArray[i]) + 1;
            }
            map.put(cArray[i], count);
        }
        for (int j = 0; j &lt; cArray.length; j++) {
            if (map.get(cArray[j]) == 1) {
                return cArray[j];
            }
        }
        return ' ';
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9852%EF%BC%9A%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9">面试题52：两个链表的第一个公共节点</h4> 
<p><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" rel="nofollow" title="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p> 
<pre><code class="language-java">public class Solution {
    Stack&lt;ListNode&gt; stack1 = new Stack&lt;&gt;();
    Stack&lt;ListNode&gt; stack2 = new Stack&lt;&gt;();
    ListNode        node1;
    ListNode        node2;
    ListNode        result;

    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        result = null;
        while (headA != null) {
            stack1.push(headA);
            headA = headA.next != null ? headA.next : null;
        }
        while (headB != null) {
            stack2.push(headB);
            headB = headB.next != null ? headB.next : null;
        }
        while (!stack1.isEmpty() &amp;&amp; !stack2.isEmpty()) {
            node1 = stack1.pop();
            node2 = stack2.pop();
            if (node1 != node2) {
                return result;
            }
            result = node1;
        }
        return result;
    }
}</code></pre> 
<h3>5 综合能力</h3> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9853-1%EF%BC%9A%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%971">面试题53-1：在排序数组中查找数字1</h4> 
<p><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" rel="nofollow" title="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public static int search(int[] nums, int target) {
        if (nums.length == 0) {
            return 0;
        }
        Arrays.sort(nums);
        int left = 0;
        int right = nums.length - 1;
        int mid = left + (right - left) / 2;
        int key = binarySearch(nums, target, left, right, mid);
        if (key == -1) {
            return 0;
        } else {
            int count = 0;
            int cIndex = key;
            while (cIndex &gt;= left) {
                if (nums[cIndex] == target) {
                    count++;
                    cIndex--;
                } else {
                    break;
                }
            }
            cIndex = key + 1;
            while (cIndex &lt;= right) {
                if (nums[cIndex] == target) {
                    count++;
                    cIndex++;
                } else {
                    break;
                }
            }
            return count;
        }
    }

    public static int binarySearch(int[] nums, int target, int left, int right, int mid) {
        if (left &gt; right) {
            return -1;
        }
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[mid] &gt; target) {
            right = mid - 1;
            mid = left + (right - left) / 2;
            return binarySearch(nums, target, left, right, mid);
        }
        if (nums[mid] &lt; target) {
            left = mid + 1;
            mid = left + (right - left) / 2;
            return binarySearch(nums, target, left, right, mid);
        }
        return -1;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9853-2%EF%BC%9A0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97">面试题53-2：0～n-1中缺失的数字</h4> 
<p><a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/" rel="nofollow" title="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int missingNumber(int[] nums) {
        if (nums[0] != 0) {
            return 0;
        }
        int sub;
        for (int i = 0; i &lt; nums.length - 1; i++) {
            sub = nums[i + 1] - nums[i];
            if (sub == 2) {
                return nums[i] + 1;
            }
        }
        return nums.length;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9854%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9">面试题54：二叉搜索树的第k大节点</h4> 
<p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" rel="nofollow" title="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    int      count = Integer.MIN_VALUE;
    TreeNode tn;

    public int kthLargest(TreeNode root, int k) {
        search(root, k);
        return tn.val;
    }

    public void search(TreeNode node, int k) {
        if (node == null) {
            return;
        }
        if (node.right == null &amp;&amp; count == Integer.MIN_VALUE) {
            count = 1;
        }
        search(node.right, k);
        if (count == k) {
            tn = node;
        }
        count++;
        search(node.left, k);
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9855-1%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">面试题55-1：二叉树的深度</h4> 
<p><a href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/" rel="nofollow" title="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    Map&lt;TreeNode, Integer&gt; map      = new HashMap&lt;&gt;();
    int                    maxLevel = Integer.MIN_VALUE;

    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        dfs(root, 1);
        return maxLevel;
    }

    public void dfs(TreeNode node, int level) {
        if (map.containsKey(node)) {
            return;
        }
        map.put(node, level);
        if (maxLevel &lt; level) {
            maxLevel = level;
        }
        if (node.left != null) {
            dfs(node.left, level + 1);
        }
        if (node.right != null) {
            dfs(node.right, level + 1);
        }
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9855-2%EF%BC%9A%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">面试题55-2：平衡二叉树</h4> 
<p><a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/" rel="nofollow" title="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/">https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    Map&lt;TreeNode, Integer&gt; map = new HashMap&lt;&gt;(); // 记录从每个节点到叶子节点的树高

    public boolean isBalanced(TreeNode root) {
        if (dfs(root) == -1) {
            return false;
        } else {
            return true;
        }
    }

    public int dfs(TreeNode node) {
        if (node == null) {
            return 0;
        }
        if (map.containsKey(node)) {
            return map.get(node);
        }
        int lHeigth = dfs(node.left);
        int rHeigth = dfs(node.right);
        if (lHeigth == -1 || rHeigth == -1) {
            return -1;
        }
        if (lHeigth - rHeigth &gt; 1 || lHeigth - rHeigth &lt; -1) {
            return -1;
        }
        lHeigth++;
        rHeigth++;
        map.put(node, bigger(lHeigth, rHeigth));
        return map.get(node);
    }

    public int bigger(int left, int right) {
        if (left &gt;= right) {
            return left;
        } else {
            return right;
        }
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9856-1%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">面试题56-1：数组中数字出现的次数</h4> 
<p><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" rel="nofollow" title="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int[] singleNumbers(int[] nums) {
        // 显然，nums.length 大于等于2
        int xor = nums[0];
        for (int i = 1; i &lt; nums.length; i++) {
            xor = xor ^ nums[i];
        }
        int n = 0;
        while (xor != 0) {
            xor = xor &gt;&gt; 1;
            n++;
        }
        int left = 0;
        int right = nums.length - 1;
        int tmp;
        while (left &lt;= right) {
            if (!indexNIs1(nums[left], n)) {
                left++;
                continue;
            }
            if (indexNIs1(nums[right], n)) {
                right--;
                continue;
            }
            tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
            left++;
            right--;
        }
        int mid = 0;
        for (int i = 0; i &lt; nums.length; i++) {
            if (indexNIs1(nums[i], n)) {
                mid = i;
                break;
            }
        }
        int result1 = nums[0];
        for (int i = 1; i &lt; mid; i++) {
            result1 = result1 ^ nums[i];
        }
        int result2 = nums[mid];
        for (int i = mid + 1; i &lt; nums.length; i++) {
            result2 = result2 ^ nums[i];
        }
        return new int[] { result1, result2 };
    }

    public boolean indexNIs1(int num, int n) {
        return (num &gt;&gt; (n - 1)) % 2 == 1;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9856-2%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0II">面试题56-2：数组中数字出现的次数II</h4> 
<p><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" rel="nofollow" title="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int singleNumber(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        Arrays.sort(nums);
        int tmp = Integer.MAX_VALUE;
        boolean already = true;
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] != tmp &amp;&amp; already) {
                tmp = nums[i];
                already = false;
                continue;
            }
            if (nums[i] == tmp) {
                already = true;
            }
        }
        return tmp;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9857-1%EF%BC%9A%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97">面试题57-1：和为s的两个数字</h4> 
<p><a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/" rel="nofollow" title="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        Arrays.sort(nums);
        int p1 = 0;
        int p2 = nums.length - 1;
        while (p1 &lt; p2) {
            if (target == nums[p1] + nums[p2]) {
                return new int[] { nums[p1], nums[p2] };
            }
            if (target &gt; nums[p1] + nums[p2]) {
                p1++;
            } else {
                p2--;
            }
        }
        return new int[0];
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9857-2%EF%BC%9A%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97">面试题57-2：和为s的连续正数序列</h4> 
<p><a href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" rel="nofollow" title="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int[][] findContinuousSequence(int target) {
        // 求最大序列长度times
        int sum = 0;
        int times = 0;
        while (sum &lt; target) {
            times++;
            sum = sum + times;
        }
        if (sum != target) {
            times--;
        }

        // 求满足要求的序列长度
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for (int i = 2; i &lt;= times; i++) {
            if (i % 2 == 0 &amp;&amp; target % (target / i + target / i + 1) == 0) {
                list.add(i);
            }
            if (i % 2 == 1 &amp;&amp; target % i == 0) {
                list.add(i);
            }
        }

        // 按满足要求的序列长度，对target进行拆分
        int[][] result = new int[list.size()][];
        for (int j = 0; j &lt; list.size(); j++) {
            int tmp = list.get(j);
            int[] array = new int[tmp];

            if (tmp % 2 == 0) {
                int base = target / tmp;
                int half = tmp / 2;
                for (int k = 0; k &lt; array.length; k++) {
                    array[k] = base - half + 1 + k;
                }
            }

            if (tmp % 2 == 1) {
                int base = target / tmp;
                int half = tmp / 2;
                for (int k = 0; k &lt; array.length; k++) {
                    array[k] = base - half + k;
                }
            }
            result[list.size() - 1 - j] = array;
        }

        return result;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9858-1%EF%BC%9A%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F">面试题58-1：翻转单词顺序</h4> 
<p><a href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/" rel="nofollow" title="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/">https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public String reverseWords(String s) {
        if ("".equals(s)) {
            return "";
        }
        String[] strings = s.split(" ");
        StringBuilder sb = new StringBuilder();
        for (int i = strings.length - 1; i &gt;= 0; i--) {
            if (!"".equals(strings[i])) {
                sb.append(strings[i] + " ");
            }
        }
        return sb.toString().trim();
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9858-2%EF%BC%9A%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">面试题58-2：左旋转字符串</h4> 
<p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" rel="nofollow" title="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public String reverseLeftWords(String s, int n) {
        if (n &gt;= s.length()) {
            return s;
        }
        String s1 = s.substring(0, n);
        String s2 = s.substring(n);
        return s2 + s1;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9861%EF%BC%9A%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90">面试题61：扑克牌中的顺子</h4> 
<p><a href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" rel="nofollow" title="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();

    public boolean isStraight(int[] nums) {
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        int count0 = 0;
        int tmp;
        for (int i = 0; i &lt; nums.length; i++) {
            tmp = nums[i];
            if (tmp &lt; 0 || tmp &gt; 13) {
                return false;
            }
            if (tmp != 0) {
                if (set.contains(tmp)) {
                    return false;
                }
                set.add(tmp);
                if (tmp &gt; max) {
                    max = tmp;
                }
                if (tmp &lt; min) {
                    min = tmp;
                }
            } else {
                count0++;
                if (count0 == 5) {
                    return true;
                }
            }
        }
        return max - min + 1 &lt;= 5;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9863%EF%BC%9A%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6">面试题63：股票的最大利润</h4> 
<p><a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/" rel="nofollow" title="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length &lt;= 1) {
            return 0;
        }
        int maxProfit = Integer.MIN_VALUE;
        int sum = 0;
        int[] subPrices = new int[prices.length - 1];
        for (int i = 0; i &lt; prices.length - 1; i++) {
            subPrices[i] = prices[i + 1] - prices[i];
        }
        for (int j = 0; j &lt; subPrices.length; j++) {
            sum = sum + subPrices[j];
            if (sum &lt; 0) {
                sum = 0;
            }
            if (sum &gt; maxProfit) {
                maxProfit = sum;
            }
        }
        return maxProfit;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9864%EF%BC%9A%E6%B1%821%2B2%2B%E2%80%A6%2Bn">面试题64：求1+2+…+n</h4> 
<p><a href="https://leetcode.cn/problems/qiu-12n-lcof/" rel="nofollow" title="https://leetcode.cn/problems/qiu-12n-lcof/">https://leetcode.cn/problems/qiu-12n-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int sumNums(int n) {
        int sum = 0;
        boolean bool = n &gt; 0 &amp;&amp; (sum = n + sumNums(n - 1)) &gt; 0;
        return sum;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9865%EF%BC%9A%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95">面试题65：不用加减乘除做加法</h4> 
<p><a href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" rel="nofollow" title="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    public int add(int a, int b) {
        int sum;
        int carry;
        while (b != 0) {
            sum = a ^ b;
            carry = (a &amp; b) &lt;&lt; 1;
            a = sum;
            b = carry;
        }
        return a;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9866%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84">面试题66：构建乘积数组</h4> 
<p><a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/" rel="nofollow" title="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/">https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();

    public int[] constructArr(int[] a) {
        if (a.length == 0) {
            return new int[] {};
        }
        if (a.length == 1) {
            return new int[] { 1 };
        }
        int leftTotal = 1;
        int current = 0;
        int[] b = new int[a.length];
        while (current &lt; a.length) {
            int rightTotal = 1;
            if (map.containsKey(current + 1)) {
                rightTotal = map.get(current + 1);
            } else {
                for (int i = a.length - 1; i &gt; current; i--) {
                    rightTotal *= a[i];
                    map.put(i, rightTotal);
                }
            }
            b[current] = leftTotal * rightTotal;
            leftTotal *= a[current];
            current++;
        }
        return b;
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9868-1%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">面试题68-1：二叉搜索树的最近公共祖先</h4> 
<p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" rel="nofollow" title="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    TreeNode current;
    TreeNode result;

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (p.val &gt; q.val) {
            current = p;
            p = q;
            q = current;
        }
        current = root;
        work(current, p, q);
        return result;
    }

    public void work(TreeNode current, TreeNode p, TreeNode q) {
        if (current.val &gt; p.val &amp;&amp; current.val &lt; q.val) {
            result = current;
        } else if (current.val == p.val) {
            result = p;
        } else if (current.val == q.val) {
            result = q;
        } else if (current.val &gt; p.val &amp;&amp; current.val &gt; q.val) {
            work(current.left, p, q);
        } else if (current.val &lt; p.val &amp;&amp; current.val &lt; q.val) {
            work(current.right, p, q);
        }
    }
}</code></pre> 
<h4 id="%E9%9D%A2%E8%AF%95%E9%A2%9868-2%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">面试题68-2：二叉树的最近公共祖先</h4> 
<p><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" rel="nofollow" title="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/</a></p> 
<pre><code class="language-java">class Solution {
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    List&lt;TreeNode&gt;  path1 = new ArrayList&lt;&gt;();
    List&lt;TreeNode&gt;  path2 = new ArrayList&lt;&gt;();

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return null;
        }
        dfs(root, p, q);
        TreeNode common = root;
        int index = 0;
        while (index &lt; path1.size() &amp;&amp; index &lt; path2.size()) {
            if (path1.get(index) == path2.get(index)) {
                common = path1.get(index);
            }
            index++;
        }
        return common;
    }

    public void dfs(TreeNode node, TreeNode p, TreeNode q) {
        stack.push(node);
        if (node.val == p.val) {
            path1.addAll(stack);
        }
        if (node.val == q.val) {
            path2.addAll(stack);
        }
        if (node.left != null) {
            dfs(node.left, p, q);
        }
        if (node.right != null) {
            dfs(node.right, p, q);
        }
        stack.pop();
    }
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf410fa1271bfaa2cf1f731b95bfbc67/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UE4基础学习笔记———零碎知识04</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/80f5da87ff192da21792e07527014149/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用python中的turtle库绘制常见图形（三角形、正方形、五边形、六边形、圆、同心圆、边切圆、奥运五环）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>