<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>七大原则&#43;23种设计模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="七大原则&#43;23种设计模式" />
<meta property="og:description" content="目录 设计模式的意义1. 七大原则1.1 单一职责原则1.2 接口隔离原则1.3 依赖倒转(倒置)原则1.4 里氏替换原则1.5 开闭原则1.6 迪米特法则1.7 合成复用原则小结 2. UML类图3. 设计模式3.1单例模式3.2抽象工厂模式3.3原型模式3.4建造者模式3.5适配器模式类适配器对象适配器接口适配器Spring源码适配器模式分析 3.7桥接模式3.8装饰模式3.9组合模式3.10外观模式 菜鸟教程更香
设计模式的意义 编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，复用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)，具有更好的
代码复用性可读性可扩展性可靠性 (当我们增加新的功能后，对原来的功能没有影响)使程序呈现高内聚，低耦合的特性 1. 七大原则 设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础
设计模式常用的七大原则有:
单一职责原则接口隔离原则依赖倒转(倒置)原则里氏替换原则开闭原则迪米特法则合成复用原则 1.1 单一职责原则 大白话解释：一个类就是一个最小的功能单位
描述
一个类应该只负责一项职责。
如类A负责两个不同职责：职责1，职责2。 当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2。
实例
假设有一个“交通工具”类，他的作用只有一个，就是“运行交通工具”，假设它只有一个run方法，打印“交通工具 xx 在地上跑”这句话。
如果我们的交通工具只是车，这个类没有问题，如果交通工具加上“飞机”、“船”，那么“交通工具 飞机 在地上跑”、“交通工具 船 在地上跑”就不符合实际。
由于交通工具有多个，因此这个类不符合“单一职责原则”。
我们可以将其改为3个类，“水上交通工具”、“空中交通工具”、“陆地交通工具”，分别对海陆空负责（单一职责）。
此外，由于这个类的功能比较单一，只有run方法，我们也可以在方法级别上实现单一职责原则，即为该类创建“水上运行”、“空中运行”、“陆地运行”方法。
注意事项与细节
降低类的复杂度，一个类只负责一项职责。提高类的可读性，可维护性降低变更引起的风险通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违 反单一职责原则；如果类中方法数量足够少，可以在方法级别保持单一职责原则 1.2 接口隔离原则 大白话解释：实现接口的所有类都应当觉得接口中没有多余的方法
Interface Segregation Principle
描述
客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。
实例
A通过调用B，需要操作1、2、3，
C通过调用D，需要操作1、4、5，
但是B、D都实现了1、2、3、4、5，显然B、D都实现了多余的方法。
若要符合“接口隔离原则”，只需要让B、D实现必需的接口即可。
然而，实际中我们不一定能确定B是否真的不需要4、5方法，也不能确定D是否真的不需要2、3方法。
因此，不是说学好设计模式就万事大吉的。
实际还得多方面考虑。
1.3 依赖倒转(倒置)原则 大白话解释：我们都是用接口声明一个变量，而不是直接使用具体类（如声明一个ArrayList，最左边用的是List接口；声明一个HashMap，最左边用的是Map）
Dependence Inversion Principle" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ae7ec2a0881cb08fc8b3c5845c8ffae6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-18T22:27:38+08:00" />
<meta property="article:modified_time" content="2020-03-18T22:27:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">七大原则&#43;23种设计模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_9" rel="nofollow">设计模式的意义</a></li><li><a href="#1__18" rel="nofollow">1. 七大原则</a></li><li><ul><li><a href="#11__31" rel="nofollow">1.1 单一职责原则</a></li><li><a href="#12__56" rel="nofollow">1.2 接口隔离原则</a></li><li><a href="#13__77" rel="nofollow">1.3 依赖倒转(倒置)原则</a></li><li><a href="#14__111" rel="nofollow">1.4 里氏替换原则</a></li><li><a href="#15__138" rel="nofollow">1.5 开闭原则</a></li><li><a href="#16__151" rel="nofollow">1.6 迪米特法则</a></li><li><a href="#17__173" rel="nofollow">1.7 合成复用原则</a></li><li><a href="#_186" rel="nofollow">小结</a></li></ul> 
  </li><li><a href="#2_UML_192" rel="nofollow">2. UML类图</a></li><li><a href="#3__196" rel="nofollow">3. 设计模式</a></li><li><ul><li><a href="#31_234" rel="nofollow">3.1单例模式</a></li><li><a href="#32_247" rel="nofollow">3.2抽象工厂模式</a></li><li><a href="#33_258" rel="nofollow">3.3原型模式</a></li><li><a href="#34_365" rel="nofollow">3.4建造者模式</a></li><li><a href="#35_507" rel="nofollow">3.5适配器模式</a></li><li><ul><li><a href="#_519" rel="nofollow">类适配器</a></li><li><a href="#_540" rel="nofollow">对象适配器</a></li><li><a href="#_549" rel="nofollow">接口适配器</a></li><li><a href="#Spring_563" rel="nofollow">Spring源码适配器模式分析</a></li></ul> 
   </li><li><a href="#37_594" rel="nofollow">3.7桥接模式</a></li><li><a href="#38_610" rel="nofollow">3.8装饰模式</a></li><li><a href="#39_624" rel="nofollow">3.9组合模式</a></li><li><a href="#310_656" rel="nofollow">3.10外观模式</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<p><a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html" rel="nofollow">菜鸟教程更香</a></p> 
<h2><a id="_9"></a>设计模式的意义</h2> 
<p>编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，复用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)，具有更好的</p> 
<ul><li>代码复用性</li><li>可读性</li><li>可扩展性</li><li>可靠性 (当我们增加新的功能后，对原来的功能没有影响)</li><li>使程序呈现高内聚，低耦合的特性</li></ul> 
<h2><a id="1__18"></a>1. 七大原则</h2> 
<p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础</p> 
<p>设计模式常用的七大原则有:</p> 
<ul><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转(倒置)原则</li><li>里氏替换原则</li><li>开闭原则</li><li>迪米特法则</li><li>合成复用原则</li></ul> 
<h3><a id="11__31"></a>1.1 单一职责原则</h3> 
<blockquote> 
 <p>大白话解释：一个类就是一个最小的功能单位</p> 
</blockquote> 
<p><strong>描述</strong><br> <mark>一个类应该只负责一项职责</mark>。<br> 如类A负责两个不同职责：职责1，职责2。 当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2。</p> 
<p><strong>实例</strong><br> 假设有一个“交通工具”类，他的作用只有一个，就是“运行交通工具”，假设它只有一个run方法，打印“交通工具 xx 在地上跑”这句话。</p> 
<p>如果我们的交通工具只是车，这个类没有问题，如果交通工具加上“飞机”、“船”，那么“交通工具 飞机 在地上跑”、“交通工具 船 在地上跑”就不符合实际。</p> 
<p>由于交通工具有多个，因此这个类不符合“单一职责原则”。<br> 我们可以将其改为3个类，“水上交通工具”、“空中交通工具”、“陆地交通工具”，分别对海陆空负责（单一职责）。</p> 
<p>此外，由于这个类的功能比较单一，只有run方法，我们也可以在方法级别上实现单一职责原则，即为该类创建“水上运行”、“空中运行”、“陆地运行”方法。</p> 
<p><strong>注意事项与细节</strong></p> 
<ul><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违 反单一职责原则；<code>如果类中方法数量足够少，可以在方法级别保持单一职责原则</code></li></ul> 
<h3><a id="12__56"></a>1.2 接口隔离原则</h3> 
<blockquote> 
 <p>大白话解释：实现接口的所有类都应当觉得接口中没有多余的方法</p> 
</blockquote> 
<p>Interface Segregation Principle<br> <strong>描述</strong><br> 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。</p> 
<p><strong>实例</strong><br> <img src="https://images2.imgbox.com/b0/4f/aRwqBY6T_o.png" alt="在这里插入图片描述"><br> A通过调用B，需要操作1、2、3，<br> C通过调用D，需要操作1、4、5，<br> 但是B、D都实现了1、2、3、4、5，显然B、D都实现了多余的方法。</p> 
<p><img src="https://images2.imgbox.com/aa/7d/114L7EO7_o.png" alt="在这里插入图片描述"><br> 若要符合“接口隔离原则”，只需要让B、D实现必需的接口即可。</p> 
<blockquote> 
 <p>然而，实际中我们不一定能确定B是否真的不需要4、5方法，也不能确定D是否真的不需要2、3方法。<br> 因此，不是说学好设计模式就万事大吉的。<br> 实际还得多方面考虑。</p> 
</blockquote> 
<h3><a id="13__77"></a>1.3 依赖倒转(倒置)原则</h3> 
<blockquote> 
 <p>大白话解释：我们都是用接口声明一个变量，而不是直接使用具体类（如声明一个ArrayList，最左边用的是List接口；声明一个HashMap，最左边用的是Map）</p> 
</blockquote> 
<p>Dependence Inversion Principle<br> <strong>描述</strong></p> 
<ul><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒转(倒置)的中心思想是<code>面向接口编程</code></li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。<code>以抽象为基础搭建的架构比以细节为基础的架构要稳定的多</code>。(在java中，抽象指的是接口或抽象类，细节就是具体的实现类)</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li></ul> 
<blockquote> 
 <p>就是一句话，前期设计应当从最基本、最核心的抽象入手，构建接口。</p> 
</blockquote> 
<p><strong>实例</strong><br> 用户（User类）通过receive方法接收信息（Message类）。<br> 如果用户接受的消息包括Email、QQ、WeChat…等多种方式，那么我们就需要在User类中写多个receive重载函数分别接收不同的消息类。<br> 然而，谁也不知道以后还会有什么消息类，这就导致每次增加一个消息类，我们都得对User类进行修改。</p> 
<p>如果Message不是类，而是一个接口，receive接收的是Message接口，就能解决问题。<br> 只需要让各种不同的消息类实现Message接口，receive就能够接收他们；如果出现新的消息类，也只需要增加该消息类并实现Message接口即可，不需要对原有代码进行更改。</p> 
<p><strong>依赖关系传递的方式</strong></p> 
<ul><li>声明接口传递：在普通方法参数中声明接口</li><li>构造方法传递：在构造方法参数中声明接口</li><li>setter方法传递：类中有个接口成员，该成员通过setter声明</li></ul> 
<p><strong>注意事项和细节</strong></p> 
<ul><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好</li><li>变量的<code>声明类型尽量是抽象类或接口</code>， 这样我们的变量引用和实际对象间，就存在 一个缓冲层，利于程序扩展和优化</li><li>继承时遵循里氏替换原则</li></ul> 
<h3><a id="14__111"></a>1.4 里氏替换原则</h3> 
<blockquote> 
 <p>大白话解释：少继承、别重写父类方法</p> 
</blockquote> 
<p><strong>OO中的继承，产生的问题</strong></p> 
<ul><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li><li>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承， 则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li></ul> 
<p>解决以上问题，考虑里氏替换原则。</p> 
<p><strong>描述</strong><br> Liskov Substitution Principle</p> 
<ul><li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1 的子类型。换句话说，<code>所有引用基类的地方必须能透明地使用其子类的对象</code>。</li><li>在使用继承时，遵循里氏替换原则，在子类中<code>尽量不要重写父类的方法</code></li><li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过<code>聚合</code>，<code>组合</code>，<code>依赖</code> 来解决问题。.</li></ul> 
<p><strong>实例</strong><br> 类A的fun1是减法器，类B继承了类A；但是类B不小心将fun1重写成了加法器。<br> 假设极端情况，类A就只有fun1方法，那么类B继承类A就没有必要了，把A唯一的方法都重写了。</p> 
<p>实际编程中常常重写父类的方法，但是整个继承体系的复用性、稳定性较差。<br> 一般可以这么做：让原来的父类A和子类B都继承一个更通俗的基类，取消AB继承关系，AB直接采用聚合、组合、依赖的关系实现方法调用。</p> 
<p>比如上述实例，A和B都继承一个基础类Base（为了保证一些基本方法），然后B中声明一个成员类A，此时B可以写一个方法调用A的专有方法即可。</p> 
<h3><a id="15__138"></a>1.5 开闭原则</h3> 
<blockquote> 
 <p>大白话解释：写的系统易于扩展，不允许修改。</p> 
</blockquote> 
<p>Open Closed Principle<br> <strong>描述</strong></p> 
<ul><li>开闭原则是编程中最基础、最重要的设计原则</li><li>一个软件实体如类，模块和函数应该<code>对扩展开放，对修改关闭</code>。<mark>用抽象构建框架，用实现扩展细节</mark></li><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则</li></ul> 
<h3><a id="16__151"></a>1.6 迪米特法则</h3> 
<blockquote> 
 <p>大白话解释：减少类之间的依赖</p> 
</blockquote> 
<p><strong>描述</strong></p> 
<ul><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li></ul> 
<p>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，<code>对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部</code>。<code>对外除了提供的public 方法，不泄露任何信息</code></p> 
<p>迪米特法则还有个更简单的定义：<code>只与直接的朋友通信</code></p> 
<blockquote> 
 <p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系， 我们就说这两个对象之间是朋友关系。<br> 耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现<code>成员变量</code>，<code>方法参数</code>，<code>方法返回值</code>中<code>的类</code>为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，<code>陌生的类最好不要以局部变量的形式出现在类的内部</code>。</p> 
</blockquote> 
<p>此外，有时候我们也会引入了“陌生的朋友”而不自知。<br> 比如较长的调用链，调用链中可能生成了多个陌生的类，这也是不被允许的。</p> 
<p>迪米特法则的目的在于降低类之间的耦合度。</p> 
<h3><a id="17__173"></a>1.7 合成复用原则</h3> 
<blockquote> 
 <p>大白话解释：多用组合、聚合，少用继承</p> 
</blockquote> 
<p><strong>描述</strong><br> 尽量使用合成/聚合的方式，而不是使用继承。</p> 
<p>如果仅仅是为了让B类使用A类的方法，就让B继承A，只是徒增耦合。<br> 我们只需要在B中聚合一个A的对象，或者将A作为B的某个方法参数。</p> 
<h3><a id="_186"></a>小结</h3> 
<ul><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的松耦合设计而努力</li></ul> 
<h2><a id="2_UML_192"></a>2. UML类图</h2> 
<p><a href="https://www.jianshu.com/p/57620b762160" rel="nofollow">点击此处进行学习</a></p> 
<h2><a id="3__196"></a>3. 设计模式</h2> 
<p>设计模式分为三种类型，共23种</p> 
<ul><li>创建型模式：单例模式、工厂模式、抽象工厂模式、原型模式、建造者模式。</li><li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</li><li>行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者 模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式(责任链模式)。</li></ul> 
<p>大白话解释：<br> 创建型模式：</p> 
<ul><li>单例模式：创建一个对象，使得整个系统中，这个对象有且仅有一个。</li><li>工厂模式：多个类的创建交给一个工厂，客户端给出所需的类的类型，工厂返回该对象</li><li>抽象工厂模式：给每一类产品都创建一个工厂</li><li>原型模式：利用一个对象本体（称为原型），克隆出另一个</li><li>建造者模式：一个对象的创建过程比较复杂，通过一系列建造过程完成创建</li></ul> 
<p>结构型模式：</p> 
<ul><li>适配器模式：将类通过一个“转换器”转换某些属性让它变得适合使用</li><li>桥接模式：将类的某一可变属性抽出来作为类组合进去（几何图形有三种颜色，将三种颜色抽取出来作为三个类）</li><li>装饰模式：把类放进去加工一下，得到具有额外功能的类</li><li>组合模式：具有树形结构的类群，使用组合模式让其变成一个树</li><li>外观模式：一大堆类的运行放在一个类中（外观），一键调用</li><li>享元模式：实现元素共享</li><li>代理模式：为了控制对象的访问，加一个代理人</li></ul> 
<p>行为型模式：</p> 
<ul><li>模板方法模式：把执行流程（算法）都放在一个方法中，形成一个模板</li><li>命令模式：将所有命令单独抽出来作为类来调用，而不是作为方法</li><li>访问者模式：A进入B中（B某个方法使用了A），调用A的方法访问B（A的方法中又需要传入B）</li><li>迭代器模式：遍历类</li><li>观察者模式：一对多关系时，这个一想要通知多个对象</li><li>中介者模式：让客户与多个类的沟通，都通过一个中介类</li><li>备忘录模式：记录一个类的状态</li><li>解释器模式：解释一串表达式</li><li>状态模式：一个流程存在特别多的状态，使用状态模式</li><li>策略模式：把类的某一类方法（策略）抽出来作为类，实现动态改变</li><li>职责链模式(责任链模式)：拦截链，轮着一个拦一个</li></ul> 
<h3><a id="31_234"></a>3.1单例模式</h3> 
<p>单例模式有八种实现方法（有一种是错误示范）：</p> 
<ul><li>饿汉式(静态常量)</li><li>饿汉式（静态代码块）</li><li>懒汉式(线程不安全)</li><li>懒汉式(线程安全，同步方法)</li><li>懒汉式(线程安全，同步代码块)</li><li>双重检查</li><li>静态内部类</li><li>枚举</li></ul> 
<p><a href="https://gitee.com/sxuer/designPattern/tree/master/out/production/designPattern/creationMode/singleton" rel="nofollow">代码以及注释详解</a></p> 
<h3><a id="32_247"></a>3.2抽象工厂模式</h3> 
<p><a href="https://blog.csdn.net/u012156116/article/details/80857255">简单工厂模式</a><br> <img src="https://images2.imgbox.com/e0/5b/0wbi9jhE_o.png" alt="在这里插入图片描述"><br> AbstractProduct：抽象类产品，比如说披萨<br> ConcreteProduct：具体的产品，比如说中国披萨，美国披萨，巴西披萨等<br> SimpleFactory：用于创建披萨类，依赖于抽象披萨<br> FacrotyClient：工厂的使用者，通过FactoryClient，调用SimpleFactory生成不同的披萨。</p> 
<p><a href="https://gitee.com/sxuer/designPattern/tree/master/src/creationMode" rel="nofollow">所有代码以及解释</a></p> 
<h3><a id="33_258"></a>3.3原型模式</h3> 
<p>原型模式（Prototype Pattern）是<code>用于创建重复的对象</code>，同时又能保证性能。<br> Spring的bean.xml中配置的bean，scope可以选择单例，也可以选择prototype，即原型模式创建。<br> 如果你的bean中有初始化信息，那么通过prototype模式创建的bean，都会带上这些初始化信息</p> 
<p>原理：实现Cloneable接口，利用Object的clone，实现克隆</p> 
<p>浅拷贝：使用clone克隆的对象，基本类型是值传递（新的对象），引用类型只是地址传递（依旧是指向旧的对象，如果此时对该对象修改，也会影响原有对象）。</p> 
<p>深拷贝：<br> 对于拷贝对象中的引用类型，也实现Cloneable接口，然后对其单独处理。但是这种方式局限性太大，不推荐，直接学习另一种方式，利用<code>反序列化</code></p> 
<p>原理：序列化之后，能够保存所有“值信息”<br> 反序列化得到的是一个新的对象。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrototypePattern</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Sheep s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sheep</span><span class="token punctuation">(</span><span class="token string">"duoli"</span><span class="token punctuation">,</span><span class="token string">"black"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Sheep friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sheep</span><span class="token punctuation">(</span><span class="token string">"friend"</span><span class="token punctuation">,</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s1<span class="token punctuation">.</span><span class="token function">setFriend</span><span class="token punctuation">(</span>friend<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Sheep s2 <span class="token operator">=</span> <span class="token punctuation">(</span>Sheep<span class="token punctuation">)</span> s1<span class="token punctuation">.</span><span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">getFriend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>s2<span class="token punctuation">.</span><span class="token function">getFriend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Sheep</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String color<span class="token punctuation">;</span>

    <span class="token comment">// 深拷贝测试对象</span>
    <span class="token keyword">private</span> Sheep friend<span class="token punctuation">;</span>

    <span class="token function">Sheep</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span>String color<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token operator">=</span>color<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token string">"Sheep{"</span> <span class="token operator">+</span>
                <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>
                <span class="token string">", color='"</span> <span class="token operator">+</span> color <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>
                <span class="token string">", friend="</span> <span class="token operator">+</span> friend <span class="token operator">+</span>
                <span class="token string">'}'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    Object <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        ByteArrayOutputStream bos <span class="token operator">=</span> null<span class="token punctuation">;</span>
        ObjectOutputStream oos <span class="token operator">=</span> null<span class="token punctuation">;</span>
        ObjectInputStream ois <span class="token operator">=</span> null<span class="token punctuation">;</span>
        ByteArrayInputStream bis <span class="token operator">=</span> null<span class="token punctuation">;</span>


        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 序列化</span>
            bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">)</span><span class="token punctuation">;</span>
            oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 反序列化</span>
            bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bis<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>Sheep<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> ClassNotFoundException e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>bos <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    bos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>oos <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    oos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>bis <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    bis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ois <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    ois<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFriend</span><span class="token punctuation">(</span>Sheep friend<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>friend <span class="token operator">=</span> friend<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> Sheep <span class="token function">getFriend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> friend<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</li><li>不用重新初始化对象，而是<code>动态地获得对象运行时的状态</code></li><li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li><li>在实现深克隆的时候可能需要比较复杂的代码</li><li>缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则</li></ol> 
<h3><a id="34_365"></a>3.4建造者模式</h3> 
<p>BuilderPattern<br> 盖房子，需要逐步完成一系列工序才能得到最终的房子。<br> 建造者模式，就是将产品（房子）与产品构造过程（一系列工序）进行解耦。</p> 
<p>涉及角色：<br> 产品：Product，比如一栋房子<br> 抽象建造者：Builder，大家一直认为施工队该有的基本操作<br> 具体建造者：ConcreteBuilder，实际开工的工人，只提供动作，指挥者让干嘛就干嘛<br> 指挥者：Director，工头（隔离了老板与工人直接接触，负责控制房子的生产过程）</p> 
<p>调用过程：<br> （客户端）老板告诉（指挥者）工头，我要“这种”房子（指定建造者，<br> 工人），工头对这类房子的建造方式已经记住了，然后告诉工人开始搭建，最后工头将房子交给老板。</p> 
<p>此处老板指定建造者，而不是老板定制（指定）房子，是因为：<br> 如果定制房子，老板就得对房子的参数非常熟悉才行<br> 如果有新的建造者加入，就得更改客户端代码</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> creationMode<span class="token punctuation">.</span>_4_builderPattern<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BuilderPattern</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 老板跟包工头说要一个小平房</span>
        Director director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteHouseBuilderOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        House result1 <span class="token operator">=</span> director<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 老板跟包工头说要一栋高楼</span>
        director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteHouseBuilderTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        House result2 <span class="token operator">=</span> director<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 产品：房子</span>
<span class="token keyword">class</span> <span class="token class-name">House</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Integer height<span class="token punctuation">;</span>
    <span class="token function">House</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> Integer <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> height<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setHeight</span><span class="token punctuation">(</span>Integer height<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token string">"House{"</span> <span class="token operator">+</span>
                <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>
                <span class="token string">", height="</span> <span class="token operator">+</span> height <span class="token operator">+</span>
                <span class="token string">'}'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 抽象建造者</span>
<span class="token keyword">interface</span> <span class="token class-name">AbstractHouseBuilder</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token function">buildStepOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">buildStepTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    House <span class="token function">getResule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体建造者：工人1号</span>
<span class="token keyword">class</span> <span class="token class-name">ConcreteHouseBuilderOne</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractHouseBuilder</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> House house <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">House</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildStepOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>house<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"小平房"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildStepTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>house<span class="token punctuation">.</span><span class="token function">setHeight</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> House <span class="token function">getResule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> house<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体建造者：工人2号</span>
<span class="token keyword">class</span> <span class="token class-name">ConcreteHouseBuilderTwo</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractHouseBuilder</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> House house <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">House</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildStepOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>house<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"大高楼"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildStepTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>house<span class="token punctuation">.</span><span class="token function">setHeight</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> House <span class="token function">getResule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> house<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 指挥者：包工头</span>
<span class="token keyword">class</span> <span class="token class-name">Director</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> AbstractHouseBuilder builderOne<span class="token punctuation">;</span>

    <span class="token function">Director</span><span class="token punctuation">(</span>AbstractHouseBuilder builderOne<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>builderOne <span class="token operator">=</span> builderOne<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    House <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        builderOne<span class="token punctuation">.</span><span class="token function">buildStepOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        builderOne<span class="token punctuation">.</span><span class="token function">buildStepTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> builderOne<span class="token punctuation">.</span><span class="token function">getResule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>StringBuilder使用的建造者模式</strong></p> 
<ul><li>Appendable 接口定义了多个append方法(抽象方法), 即Appendable 为抽象建造者, 定义了抽象方法</li><li>AbstractStringBuilder 实现了 Appendable 接口方法，这里的AbstractStringBuilder 已经是建造者，只是不能实例化</li><li>StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的 实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了 AbstractStringBuilder</li></ul> 
<p><strong>特点</strong></p> 
<ul><li>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同 的产品对象</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程， 系统扩展方便，符合 “开闭原则”</li><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<code>如果产品之间的差异性很大，则不适合使用建造者模式</code>，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化， 导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.</li><li><code>抽象工厂模式VS建造者模式</code>：抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用<code>抽象工厂模式不需要关心构建过程</code>，只关心什么产品由什么工厂生产即可。而建造者模式则是<code>要求按照指定的蓝图</code>建造产品，它的主要目的是通过完成一系列工序而产生一个新产品</li></ul> 
<h3><a id="35_507"></a>3.5适配器模式</h3> 
<p><strong>描述</strong></p> 
<ol><li>适配器模式(<code>Adapter</code> Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是<code>兼容性</code>，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(<code>Wrapper</code>)</li><li>适配器模式属于结构型模式</li><li>主要分为三类：<code>类适配器模式</code>、<code>对象适配器模式</code>、<code>接口适配器模式</code></li></ol> 
<p><strong>工作原理</strong></p> 
<ol><li>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼 容</li><li>从用户的角度看不到被适配者，是解耦的</li><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li><li>用户收到反馈结果，感觉只是和目标接口交互，如图<br> <img src="https://images2.imgbox.com/83/11/qXO0Ppfc_o.png" alt="在这里插入图片描述"></li></ol> 
<h4><a id="_519"></a>类适配器</h4> 
<p>Adapter类，通过<code>继承</code> src类，实现 dst 类接口，完成src-&gt;dst的适配。</p> 
<p><strong>实例</strong><br> <img src="https://images2.imgbox.com/85/90/8OzLWLoM_o.png" alt="在这里插入图片描述"></p> 
<p>国家只提供了220V电压，我们的手机需要5V电压，因此需要一个适配器。</p> 
<p>适配器继承220V电压（为了拿到电压），然后实现5V的接口（相当于适配器变压标准）。<br> 接着手机充电的时候，只需要遵循5V接口就行了。<br> 然后用户Client左拿适配器（充电器），右拿手机，就可以充电了。</p> 
<p><strong>注意事项</strong></p> 
<ol><li>Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要求dst必须是接口，有一定局限性;</li><li>src类的方法在Adapter中都会暴露出来，也增加了使用的成本。</li><li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。</li></ol> 
<h4><a id="_540"></a>对象适配器</h4> 
<p>Adapter类，通过<code>持有</code> src类，实现 dst 类接口， 完成src-&gt;dst的适配。</p> 
<p><strong>细节</strong></p> 
<ol><li>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。 根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承src的 局限性问题，也不再要求dst必须是接口。</li><li>使用成本更低，更灵活。</li></ol> 
<h4><a id="_549"></a>接口适配器</h4> 
<ol><li>一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式。</li><li>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</li><li>适用于一个接口不想使用其所有的方法的情况。</li></ol> 
<p><strong>实例</strong><br> <img src="https://images2.imgbox.com/19/86/c3ZBInPD_o.png" alt="在这里插入图片描述"></p> 
<p>如上图，接口提供了4个方法，如果我们直接实现接口，将不得不实现全部方法。<br> 但是我们加一个适配器，实现接口中的全部方法（但是都是空方法，没有写具体实现），<br> 然后A继承适配器，就可以有选择的重写自己想要的方法。</p> 
<h4><a id="Spring_563"></a>Spring源码适配器模式分析</h4> 
<p><img src="https://images2.imgbox.com/c7/29/88Fc5NrH_o.png" alt="在这里插入图片描述"></p> 
<p>实现逻辑：前端发起请求，DispatchServlet调用doDispatch（）方法，调用controller方法。</p> 
<p>为什么应用适配器模式：前端发起的请求有多种，可能需要HttpController进行处理，也可能是SimpleController或者AnnotationController进行处理，但是我们并不知道要用哪个；最简单的方式就是在处理的时候用if-else对请求类别进行甄别，然后调用对应controller；但是，显然这种模式违背了OCP原则。</p> 
<p>适配器模式：<br> 处理请求的控制器接口；<br> 分别处理请求的三个具体控制器；<br> 每个具体的控制器都有一个对应的适配器，这些适配器都遵循同一个适配器接口。<br> dispatchServlet拿到请求之后，通过适配器判断控制器类型，并调用控制器方法。</p> 
<p>模拟运行轨迹：<br> 前端发起Http请求==》DispatcherServlet拿到请求，调用doDispatch（）<br> <mark>》doDispatch（）拿到该请求，交给HandlerAdapter适配器进行类别判断</mark>》判断结果为Http请求，此时用HttpHandlerAdapter调用HTTPController中的方法，处理请求。</p> 
<hr> 
<p><strong>适配器模式注意事项</strong></p> 
<ol><li>三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。</li><li>类适配器：以类给到，在Adapter里，就是将src当做类，<code>继承</code><br> 对象适配器：以对象给到，在Adapter里，将src作为一个对象，<code>持有</code><br> 接口适配器：以接口给到，在Adapter里，将src作为一个接口，<code>实现</code></li><li>Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。</li><li>实际开发中，实现起来不拘泥于上述三种经典形式</li></ol> 
<h3><a id="37_594"></a>3.7桥接模式</h3> 
<p>考虑这么一个问题：有“圆形”“正方形”“三角形”三个形状，然后有“红色”“绿色”“蓝色”三种颜色，现在我们需要“红色正方形”、“绿色正方形”、“蓝色正方形”、“红色三角形”、“绿色三角形”、“蓝色三角形”、“红色圆形”、“绿色圆形”、“蓝色圆形”，需要几个类？<br> 如果是按x色x形分别建类，那么显然需要3*3个类。<br> 这种实现快速简单，但是却难以扩展。比如我们现在多了一个绿色，那么就得再建三个“绿色xx形”，形成类爆炸。</p> 
<p>这就是理解桥接模式的方式——属性维度。<br> 将每一维，都单独抽出来，然后通过组合聚合的形式放在一个桥接类中。</p> 
<p><img src="https://images2.imgbox.com/ad/81/jLjqwSjp_o.png" alt="在这里插入图片描述"><br> 这个“抽象”与“实现”的区别，网上并没有找到结论。<br> 个人觉得，没啥区别，抽象接口直接跟Client交互，并且组合实现类，因此，可以将重要的“属性”作为抽象。<br> 或者说，抽象与实现是主从关系，实现属于抽象，比如说“颜色属于形状，因此形状是抽象，颜色是实现”。</p> 
<p>此外，个人觉得这个二维维度可以扩展成多维。</p> 
<h3><a id="38_610"></a>3.8装饰模式</h3> 
<p><strong>定义</strong><br> 在不改变原有对象的基础之上，将功能附加到对象上。提供了比继承更有弹性的替代方案（扩展原有对象功能）</p> 
<p><strong>优点</strong></p> 
<ul><li>扩展一个类的功能或者给一个类添加附加职责</li><li>给一个对象动态的添加功能，或动态撤销功能。</li></ul> 
<p><img src="https://images2.imgbox.com/45/29/mk6bIGOV_o.png" alt="在这里插入图片描述"><br> 类图特点：</p> 
<ul><li>被装饰者和装饰器都实现同一个接口（抽象类），该接口中有被装饰者的<code>可装饰属性</code>相关方法 
  <blockquote> 
   <p>比如说用调味品装饰咖啡，那么咖啡的描述和价格就是可装饰属性，此时该顶级接口应当带上描述和价格，只有这样，才能在装饰后对这些属性进行动态修改。</p> 
  </blockquote> </li></ul> 
<h3><a id="39_624"></a>3.9组合模式</h3> 
<p>常见这种形式：</p> 
<ul><li>一个用户有多个订单，一个订单有多个订单详情，一个订单详情有多个商品</li><li>一个学校有多个学院，一个学院有多个系，一个系有多个班，一个班有多个同学</li></ul> 
<p>这种模式，可以抽象为<code>一棵树</code>。<br> 学校是一个根节点，同学是叶子节点。</p> 
<p>这就是组合模式。</p> 
<p><img src="https://images2.imgbox.com/ff/12/TuHqejyi_o.png" alt="在这里插入图片描述"></p> 
<ul><li>ClientApp是调用方，只跟Component发生关联</li><li>Component是抽象节点，包含根节点和叶子节点的所有默认行为</li><li>Composite是非叶子节点</li><li>Leaf是叶子节点。</li></ul> 
<p>注意：</p> 
<ul><li>Component作为抽象类时，将<code>叶子节点也包含的行为</code>作为抽象方法，让叶子也能实现；将<code>叶子节点不包含的行为</code>(如移除子节点和增加子节点)写一个默认实现，抛出不支持调用的异常，让其他子节点自己实现。</li><li>一般情况下，尽管都是非叶子节点，但是也可能实现不一致（比如增加一个学院和增加一个系，实际逻辑不一样），因此不能只写一个非叶子节点，可能存在多个很相似的非叶子节点</li></ul> 
<p>其他细节：</p> 
<ul><li>简化客户端操作。客户端只需要面对一致的对象而<code>不用考虑整体部分或者节点叶子</code>的问题。</li><li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系， 客户端不用做出任何改动.</li><li>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点 或者叶子从而创建出复杂的树形结构</li><li>需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.</li><li>要求较高的抽象性，<code>如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式</code></li></ul> 
<p>划重点：树形结构适合、能帮助客户端忽略节点和叶子的差异性、如果节点和叶子本身存在较大差异则不适合使用组合模式（比如学校和学生的操作肯定存在较大差异，建议将学生、班级从这个树状结构排除，让系作为叶子节点）</p> 
<h3><a id="310_656"></a>3.10外观模式</h3> 
<p>考虑：<br> 家庭影院系统</p> 
<ul><li>幕布的开关</li><li>投影仪的开关，亮度调节，节目选择</li><li>躺椅的准备与收起</li></ul> 
<p>看电影的步骤：<br> 准备躺椅<br> 打开幕布<br> 打开投影仪，调节亮度，选择节目</p> 
<p>结束看电影的步骤：<br> 关闭投影仪<br> 关闭幕布<br> 收起躺椅</p> 
<p>如果是用户直接面对躺椅、幕布、投影仪，那他就得一步一步操作（尽管这里看起来不复杂），假设是一个子系统非常多的大系统，那么这些一步一步操作就会非常复杂。</p> 
<p>可以这么做：<br> 弄一个Facade类，<code>组合</code>幕布、投影仪、躺椅，用户只需要输入一个电影名，这个影院系统就自动完成所有准备工作。</p> 
<p><img src="https://images2.imgbox.com/17/30/qE9hUfPM_o.png" alt="在这里插入图片描述"><br> 外观模式的注意事项和细节</p> 
<ul><li>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性</li><li>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展</li><li>通过合理的使用外观模式，可以帮我们更好的划分访问的层次</li><li>当系统需要进行<code>分层设计</code>时，可以考虑使用Facade模式</li><li>在<code>维护一个遗留</code>的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口， 让新系统与Facade类交互，提高复用性</li><li>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。 要以<code>让系统有层次，利于维护为目的</code>。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/77cc43c2561a930036e5a09dbffcaade/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【你应该掌握的】深入浅出typescript</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53bea458b2e886c4aec18f258620fe12/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Lua学习笔记——异常处理pcall、xpcall</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>