<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>吉林大学 计算机网络自顶向下方法 期末复习第六章 链路层和局域网 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="吉林大学 计算机网络自顶向下方法 期末复习第六章 链路层和局域网" />
<meta property="og:description" content="计算机网络自顶向下方法 链路层和局域网 6.1 链路层概述6.1.2 链路层在何处实现 6.2 差错检测和纠正技术6.2.2 检验和（TCP和UDP用的）6.2.3 循环冗余检测 6.3 多路访问链路和协议6.3.1信道划分协议6.3.2随机接入协议6.3.3 轮流协议 6.4 交换局域网6.4.1 链路层寻址和ARP6.4.2 以太网 6.1 链路层概述 尽管任一链路层的基本服务都是将数据报通过单一链路从一个节点移动到相邻节点，但所提供的细节随着链路层协议的不同而变化。链路层协议所能提供的可能包括
成帧：在每个网络层数据报经链路传送之前，几乎所有的链路层协议都是将其用链路层帧封装起来。链路接入：媒体访问控制协议规定了帧在链路上的规则。可靠交付：当链路层协议提供可靠的服务时，它保证无差错地经链路层移动到每个网络层数据报差错检测和纠正：当帧中的一个比特作为 1 传输时，接收方节点中的链路层硬件可能不正确地将其判断为 0，反之亦然。这种比特差错是由信号衰减和电磁噪声导致的。因为没有必要转发一个有差错的数据报，所以许多链路层协议提供一种机制来检测这样的比特差错。通过让发送节点在帧中包括差错检测比特，让接收节点进行差错检查，以此来完成这项工作。 6.1.2 链路层在何处实现 链路层的主体部分是在网络适配器中实现的，网络适配器有时也称为网络接口卡位于网络适配器核心的时链路层控制器，该控制器通常是一个实现了许多链路层服务（成帧、链路接入、差错检测）的专用芯片，但部分链路层是在运行于主机 CPU 上的软件中实现的。链路层的软件组件实现了高层链路层功能，如组装链路层寻址信息和激活控制器硬件。在接收端，链路层软件响应控制器中断（例如，由于一个或多个帧的到达），处理差错条件和将数据报向上传递给网络层。所以，链路层是硬件和软件的结合体。
在发送端，控制器取得了由协议栈较高层生成并存储在主机内存中的数据报，在链路层帧中封装该数据报（填写该帧的各个字段），然后遵循链路接入协议将该帧传进通信链路中。在接收端，控制器接收了整个帧，抽取出网络层数据报。如果链路层执行差错检测，则需要发送控制器在该帧的首部设置差错检测比特，由接收控制器执行差错检测。
6.2 差错检测和纠正技术 假设要发送的信息 D 有 d 比特。在偶校验方案中，发送方只需包含一个附加的比特，选择它的值，使得这 d&#43;1 比特（初始信息加上一个校验比特）中 1 的总数是偶数。对于奇校验方案，选择校验比特值使得有奇数个 1。下图描述了一个偶校验的方案，单个校验比特被存放在一个单独的字段中。
但是如果出现了偶数个比特差错，就无法检测出来。
单比特奇偶校验方案的二维一般化方案。这里 D 中的 d 个比特被划分为 i 行 j 列。对每行和每列计算奇偶值。产生的 i&#43;j&#43;1 奇偶比特构成了链路层帧的差错检测比特。
假设在初始 d 比特信息中出现了单个比特差错。使用这种二维奇偶校验 （two-dimensional parity）方案，包含比特值改变的列和行的校验值都将会岀现差错。 因此接收方还可以利用存在奇偶校验差错的列和行的索引来实际识别发生差错的比特并纠正它。二维奇偶校验也能够检测（但不能纠正！）一个分组中两个比特差错的任何组合。
6.2.2 检验和（TCP和UDP用的） 一个简单检验和方法就是将所有比特的整数加起来，并且用得到的和作为差错检测比特。因特网检验和（Internet checksum）就基于这种方法，即数据的字节作为 16 比特的整数对待并求和。这个和的反码形成了携带在报文段首部的因特网检验和。接收方通过对接收的数据（包括检验和）的和取反码，并且检测其结果是否为全 1 比特来检测检验和。如果这些比特中有任何比特是 0，就可以指示出差错。
6.2.3 循环冗余检测 CRC运算实际上就是在数据长为k的后面添加供差错检测用的n位冗余码，然后构成帧k&#43;n位发送出去。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/63e9c3f372b2f57b66ba2a217f390951/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-03T11:41:34+08:00" />
<meta property="article:modified_time" content="2023-06-03T11:41:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">吉林大学 计算机网络自顶向下方法 期末复习第六章 链路层和局域网</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>计算机网络自顶向下方法 链路层和局域网</h4> 
 <ul><li><a href="#61__2" rel="nofollow">6.1 链路层概述</a></li><li><ul><li><a href="#612__9" rel="nofollow">6.1.2 链路层在何处实现</a></li></ul> 
  </li><li><a href="#62__17" rel="nofollow">6.2 差错检测和纠正技术</a></li><li><ul><li><a href="#622_TCPUDP_28" rel="nofollow">6.2.2 检验和（TCP和UDP用的）</a></li><li><a href="#623__32" rel="nofollow">6.2.3 循环冗余检测</a></li></ul> 
  </li><li><a href="#63__58" rel="nofollow">6.3 多路访问链路和协议</a></li><li><ul><li><a href="#631_65" rel="nofollow">6.3.1信道划分协议</a></li><li><a href="#632_82" rel="nofollow">6.3.2随机接入协议</a></li><li><a href="#633__199" rel="nofollow">6.3.3 轮流协议</a></li></ul> 
  </li><li><a href="#64__214" rel="nofollow">6.4 交换局域网</a></li><li><ul><li><a href="#641_ARP_215" rel="nofollow">6.4.1 链路层寻址和ARP</a></li><li><a href="#642___243" rel="nofollow">6.4.2 以太网</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="61__2"></a>6.1 链路层概述</h2> 
<p>尽管任一链路层的基本服务都是将数据报通过单一链路从一个节点移动到相邻节点，但所提供的细节随着链路层协议的不同而变化。链路层协议所能提供的可能包括</p> 
<ul><li>成帧：在每个网络层数据报经链路传送之前，几乎所有的链路层协议都是将其用链路层帧封装起来。</li><li>链路接入：媒体访问控制协议规定了帧在链路上的规则。</li><li>可靠交付：当链路层协议提供可靠的服务时，它保证无差错地经链路层移动到每个网络层数据报</li><li>差错检测和纠正：当帧中的一个比特作为 1 传输时，接收方节点中的链路层硬件可能不正确地将其判断为 0，反之亦然。这种比特差错是由信号衰减和电磁噪声导致的。因为没有必要转发一个有差错的数据报，所以许多链路层协议提供一种机制来检测这样的比特差错。通过让发送节点在帧中包括差错检测比特，让接收节点进行差错检查，以此来完成这项工作。</li></ul> 
<h3><a id="612__9"></a>6.1.2 链路层在何处实现</h3> 
<p>链路层的主体部分是在网络适配器中实现的，网络适配器有时也称为网络接口卡位于网络适配器核心的时链路层控制器，该控制器通常是一个实现了许多链路层服务（成帧、链路接入、差错检测）的专用芯片，但部分链路层是在运行于主机 CPU 上的软件中实现的。链路层的软件组件实现了高层链路层功能，如组装链路层寻址信息和激活控制器硬件。在接收端，链路层软件响应控制器中断（例如，由于一个或多个帧的到达），处理差错条件和将数据报向上传递给网络层。所以，链路层是硬件和软件的结合体。</p> 
<p><img src="https://images2.imgbox.com/ee/02/TW5cE6ji_o.png" alt="请添加图片描述" width="400"></p> 
<p>在发送端，控制器取得了由协议栈较高层生成并存储在主机内存中的数据报，在链路层帧中封装该数据报（填写该帧的各个字段），然后遵循链路接入协议将该帧传进通信链路中。在接收端，控制器接收了整个帧，抽取出网络层数据报。如果链路层执行差错检测，则需要发送控制器在该帧的首部设置差错检测比特，由接收控制器执行差错检测。</p> 
<h2><a id="62__17"></a>6.2 差错检测和纠正技术</h2> 
<p>假设要发送的信息 D 有 d 比特。在偶校验方案中，发送方只需包含一个附加的比特，选择它的值，使得这 d+1 比特（初始信息加上一个校验比特）中 1 的总数是偶数。对于奇校验方案，选择校验比特值使得有奇数个 1。下图描述了一个偶校验的方案，单个校验比特被存放在一个单独的字段中。</p> 
<p><img src="https://images2.imgbox.com/b7/6e/FZmcyraV_o.png" alt="请添加图片描述" width="400"><br> 但是如果出现了偶数个比特差错，就无法检测出来。</p> 
<p>单比特奇偶校验方案的二维一般化方案。这里 D 中的 d 个比特被划分为 i 行 j 列。对每行和每列计算奇偶值。产生的 i+j+1 奇偶比特构成了链路层帧的差错检测比特。<br> <img src="https://images2.imgbox.com/89/1f/mBRhcw4j_o.png" alt="请添加图片描述" width="400"></p> 
<p>假设在初始 d 比特信息中出现了单个比特差错。使用这种二维奇偶校验 （two-dimensional parity）方案，包含比特值改变的列和行的校验值都将会岀现差错。 因此接收方还可以利用存在奇偶校验差错的列和行的索引来实际识别发生差错的比特并纠正它。二维奇偶校验也能够检测（但不能纠正！）一个分组中两个比特差错的任何组合。</p> 
<h3><a id="622_TCPUDP_28"></a>6.2.2 检验和（TCP和UDP用的）</h3> 
<p>一个简单检验和方法就是将所有比特的整数加起来，并且用得到的和作为差错检测比特。因特网检验和（Internet checksum）就基于这种方法，即数据的字节作为 16 比特的整数对待并求和。这个和的反码形成了携带在报文段首部的因特网检验和。接收方通过对接收的数据（包括检验和）的和取反码，并且检测其结果是否为全 1 比特来检测检验和。如果这些比特中有任何比特是 0，就可以指示出差错。</p> 
<h3><a id="623__32"></a>6.2.3 循环冗余检测</h3> 
<p>CRC运算实际上就是在数据长为k的后面添加供差错检测用的n位冗余码，然后构成帧k+n位发送出去。</p> 
<p>首先来介绍几个概念<br> (1)模2运算：实际上是按位异或运算，即相同为0，相异为1，也就是不考虑进位、借位的二进制加减运算。如：1111+1010 = 0101<br> (2)FCS：其实就是冗余码，帧检验序列(Frame Check Sequence)<br> (3)生成多项式：其实就是除数，比如下面将要用到的除数p = 1101<br> 计算n位冗余码</p> 
<p>现假定待传输的数据M = 101001(k = 6)，除数p = 1101 (n = 3)比n多一位<br> 这n位冗余码可以用下面的方法得出。<br> (1)用二进制的模2运算进行(2^n)乘M的运算,相当于在M后面添加n个0。<br> 即M后面添加3个0<br> (2)现在得到M = 101001000(k+n = 9)位的数除以除数p(n = 3)位，<br> 得到商是Q(不关心)，余数R =001（n位）R就是冗余码FCS</p> 
<p>现在加上FCS后发送的帧是101001001</p> 
<p>在接收端把接收到的数据M = 101001001以帧为单位进行CRC检验：把收到的每一个帧都除以相同的除数p(模2运算)，然后检查得到的余数R。<br> 如果在传输过程中没有差错，那么经过检验后得到余数R肯定是0。 <img src="https://images2.imgbox.com/ba/c9/gik0kVKO_o.png" alt="请添加图片描述" width="400"><br> 在接收端把接收到的数据M = 101001001以帧为单位进行CRC检验：把收到的每一个帧都除以相同的除数p(模2运算)，然后检查得到的余数R。<br> 如果在传输过程中没有差错，那么经过检验后得到余数R肯定是0。</p> 
<p>(1)余数R = 0，则判断这个帧没有问题，就接受<br> (2)余数R != 0,则判断这个帧有差错，就丢弃。</p> 
<h2><a id="63__58"></a>6.3 多路访问链路和协议</h2> 
<p>网络链路有两种类型：点对点和广播链路。点对点由链路一端的单个发送方和链路另一端的单个接收方组成，如点对点和高级数据链路控制。广播链路能够让多个发送方和接收结点都连接到相同的、单一的、共享的广播信道上。</p> 
<p>对于广播链路而言，因为所有结点都能传输帧，所以多个结点同时传输帧时，传输的帧在所有的接收方处发生碰撞，导致没有一个接收结点能够有效地获得任何传输的帧。解决这个问题则需要多路访问协议，结点通过这些协议来规范它们在共享的广播信道上的传输行为，从而协调多个发送和接收结点对一个共享广播信道的访问。</p> 
<p>多路访问协议分为3种类型：信道划分协议、随机接入协议、轮流协议。</p> 
<h3><a id="631_65"></a>6.3.1信道划分协议</h3> 
<p>时分多路复用：TDM将划分为时间帧，并进一步划分每个时间帧为N个时隙，然后把每个时隙分配各N个结点中的一个，无论何时有结点在有分组要发送时，他在循环的TDM帧中指派给他的时隙内传输分组比特。</p> 
<p><img src="https://images2.imgbox.com/0d/14/rjzDukeP_o.png" alt="请添加图片描述" width="400"><br> TDM消除了碰撞个且非常公平：每个结点在每个帧时间内得到了专用的传输速率R/Nbps的平均速率，然而它有两个主要缺陷：</p> 
<ul><li>首先，结点被限制于R/Nbps的平均速率，即使当它是唯一有分组要发送的结点时。</li><li>其次，结点必须总是等待他在传输序列中的轮次 ，即使他是唯一一个有帧要发送的结点。</li></ul> 
<p>频分多路复用：FDM将R bps信道划分为不同的频段（每个频道具有R/N带宽）并把每个频率分配给N个结点中的一个。</p> 
<p><img src="https://images2.imgbox.com/de/04/SkJl3O5i_o.png" alt="请添加图片描述" width="400"></p> 
<p>FDM具有和TDM同样的优点和缺点：它避免了碰撞，在N个结点之间公平地划分了带宽。但是他也限制了一个结点只能使用R/N的带宽，即使当他是唯一一个有分组要发送的结点时。</p> 
<p>码分多址（CDMA）：CDMA对每一个结点分配一种不同的编码，然后每个结点用它唯一的编码来对它发送的数据进行编码。如果精心选择这些编码，就能做到使不同的结点同时传输，并且他们各自相应的接收方仍能正确接收发送方编码的数据，而不在乎其他结点的干扰传输。</p> 
<h3><a id="632_82"></a>6.3.2随机接入协议</h3> 
<p>在随机接入协议中，一个传输结点总是以信道的全部速率（即R bps）进行发送。当有碰撞时，涉及碰撞的每个结点反复地重发它的帧，到该帧无碰撞地通过为止。但是当一个结点经历一次碰撞时，他不必立刻重发该帧。相反，它在重发该帧前等待一个随机时延。涉及碰撞的每个结点独立地选择随机时延。</p> 
<p>在随机接入协议中，一个传输节点总是以信道的全部速率（即R bps）进行发送</p> 
<p>当有碰撞时，涉及碰撞的每个节点反复地重发它的帧（也就是分组），到该帧无碰撞地通过为止</p> 
<p>当一个节点经历一次碰撞时，它在重发该帧之前等待一个随机时延。因为每个碰撞的节点是独立地选择随机时延，所以可能有些节点之一所选择的时延充分小于其他碰撞节点的时延，并因此能够无碰撞地将它的帧在信道中发出</p> 
<p><strong>1.时隙 ALOHA</strong></p> 
<p>假设：</p> 
<ul><li>所有帧是等长的</li><li>时间被划分成相等的时隙L/R，每个时隙可发送一帧</li><li>节点只在时隙开始时发送帧</li><li>节点在时钟上是同步的</li><li>如果两个或多个节点在一个时隙传输，所有的站点都能检测到冲突</li><li></ul> 
<p>运行:令p是一个概率</p> 
<ul><li>当节点获取新的帧，在下一个时隙传输</li><li>传输时没有检测到冲突，成功传输（节点能够在下 一时隙发送新帧）</li><li>检测时如果检测到冲突，失败（节点在每一个随后的时隙以概率p重传帧直到成功）</li></ul> 
<p>优点：</p> 
<ul><li>节点可以以信道带宽全速连续传输</li><li>高度分布：仅需要节点之间在时隙上的同步<br> 简单</li></ul> 
<p>缺点：</p> 
<ul><li>存在冲突，浪费时隙</li><li>即使有帧要发送，仍然有可能存在空闲的时隙</li><li>如果节点检测冲突的时间&lt;帧传输的时间，必须传完</li><li>需要时钟上同步<br> 效率：当有大量的活跃节点且每个节点总有大量的帧要发送时，长期运行中成功时隙的份额</li></ul> 
<p>例：</p> 
<p><img src="https://images2.imgbox.com/21/82/mr1OXahf_o.png" alt="请添加图片描述" width="400"></p> 
<p>假设N个节点，每个节点都有很多帧要发送， 在每个时隙中的传输概率是p</p> 
<ul><li>一个节点成功传输概率是p(1-p)N-1<br> 任何一个节点的成功概率是= Np(1-p)N-1</li><li>N个节点的最大效率：</li></ul> 
<p>求出使f=Np(1-p)N-1，N为无穷大时的极限为1/e=0.37（求导取极限）<br> 最好情况：信道利用率37%</p> 
<p><strong>2.ALOHA</strong></p> 
<p>是非时隙、完全分散的协议。无须节点间在时间上同步。</p> 
<p>当有帧需要传输：马上传输</p> 
<p>冲突的概率增加：</p> 
<p>帧在t0发送，和其它在[t0-1, t0+1]区间内开始发送的帧冲突<br> 和当前帧冲突的区间（其他帧在此区间开始传输）增大了一倍<br> 纯ALOHA的效率：</p> 
<p>P(指定节点成功)=P(节点传输)·P(其它节点在[t0-1,t0]不传)·P(其它节点在[t0,t0 +1不传] = p·(1-p)N-1·(1-p)N-1=p·(1-p)2(N-1)</p> 
<p>N趋向无穷大，p=1/(2e)=17.5%</p> 
<p><strong>3.载波侦听多路访问(CSMA)</strong></p> 
<p>规则：</p> 
<ul><li>载波侦听：一个节点在传输前先听信道。如果侦听到信道空闲，传送整个帧</li><li>碰撞检测：当一个传输节点在传输时一直在侦听此信道。如果侦听到信道忙，推迟传送<br> 人类类比：不要打断别人正在进行的说话!</li></ul> 
<p>冲突仍然可能发生:由传播延迟造成：两个节点可能侦听不到正在进行的传输</p> 
<p><img src="https://images2.imgbox.com/7f/c0/C7O8FnUb_o.png" alt="请添加图片描述" width="400"></p> 
<ul><li>在时刻t0,节点B侦听到信道是空闲的，开始向两侧传播</li><li>时刻t1，由于B没有到达D，因此D开始传播</li><li>一段时间后B,D冲突，B的传输开始在D干扰D的传输</li></ul> 
<p>整个冲突帧的传输时间都被浪费了，是无效的传输</p> 
<p>注意：传播延迟（距离）决定了冲突的概率</p> 
<p><strong>具有碰撞检测的载波侦听多路访问（CSMA/CD）</strong></p> 
<p><img src="https://images2.imgbox.com/20/58/qZj14D4R_o.png" alt="请添加图片描述" width="400"></p> 
<p>与CSMA不同之处：当某节点执行碰撞检测时，一旦它检测到碰撞将立即停止传输<br> 在多路访问协议中加入碰撞检测，通过不传输一个无用的、损坏的帧，将有助于改善协议的性能<br> 对信道的浪费减少了</p> 
<p>以太网CSMA/CD算法</p> 
<ul><li>适配器从网络层获取数据报，创建帧，放入帧适配器缓存中</li><li>发送前适配器侦听信道，如果空闲开始传送帧，如果忙碌则等到空闲再发送</li><li>传输过程中检测冲突没有冲突则成功发送该帧。检测到冲突则放弃，之后尝试重发</li><li>如果发送方适配器检测到冲突，除放弃外，还发送一个Jam信号，所有听到冲突的适配 器也是如此，即让所有站点都知道冲突</li><li>如果放弃，适配器进入指数退避状态。在第m次失败后，适配器随机选择一个{0，1，2，n，2n-1}中选择一个K值，等待K·512比特时间，然后转到步骤2 ，即二进制指数后 退算法</li></ul> 
<p>指数退避:</p> 
<p>目标：适配器试图适应当前负载，在一个变化的碰撞窗口中随机选择时间点尝试重发</p> 
<p>首次碰撞：在{0，1}选择K；延迟K*512比特时间<br> 第2次碰撞：在{0，1，2，3}选择K<br> …<br> 第10次碰撞：在{0，1，2，3，……，1023}选择K</p> 
<h3><a id="633__199"></a>6.3.3 轮流协议</h3> 
<p>多路访问协议的两个理想特性是：1.当只有一个结点活跃时，该结点具有R bps的吞吐量 2.当有M个结点活跃时，每个活跃结点的吞吐量接近R/M bps。ALOHA和CSMA只满足第一个特性。而轮流协议能够满足两个特性。轮流协议中比较重要的两个协议是轮询协议和令牌传递协议。</p> 
<p><strong>轮询协议</strong></p> 
<p>轮询协议：要求这些结点之一要被指定为主结点。主结点以循环的方式轮询每个结点。特别是，主结点告诉每个结点能够传输的帧的最多数量。</p> 
<p>轮询协议消除了困扰随机接入协议的碰撞和空时隙，这使得轮询取得的效率高得多。但是他也有一些缺点，第一个缺点是引入了轮询时延，即同时一个结点“它可以传输”所需的时间（只有一个结点时使得速率小于R bps）。第二个缺点是如果主结点故障，整个信道都变得不可操作。</p> 
<p><strong>令牌传递协议</strong><br> 令牌传递协议：一个称为令牌的小的特殊帧在结点之间以某种固定的次序传递。当一个结点收到令牌时，仅当它有一些帧要发送时，他才持有这个令牌。否则，他立即向下一个结点转发该令牌。</p> 
<p>令牌传递是分散的，并有很高的效率，但是他也有一些问题。如果一个结点故障，则会导致整个信道崩溃。或者如果一个结点偶然网际了释放令牌，则必须调用某些恢复步骤使令牌返回到循环中来。</p> 
<h2><a id="64__214"></a>6.4 交换局域网</h2> 
<h3><a id="641_ARP_215"></a>6.4.1 链路层寻址和ARP</h3> 
<p><strong>MAC地址（LAN地址，物理地址，链路层地址）</strong><br> 并不是主机或路由器具有链路层地址，而是它们的适配器（网络接口）具有链路层地址。具有多个网络接口的主机或路由器也有多个链路层地址，就像它也有多个IP地址一样。</p> 
<p>链路层交换机并没有与其接口相关联的链路层地址，交换机透明地执行在主机与路由器之间承载数据报的任务。</p> 
<p>MAC地址的作用是在链路层标识每块网络适配器，使得能够再广播信道上寻找目标节点。</p> 
<p>MAC地址长度为6字节，通常用十六进制表示法，如5C-66-AB-90-75-B1。前24bit由IEEE统一管理，生产公司可以从中购买一组号码；后24bit由生产厂商自行分配。所以没有任何两块适配器有相同的MAC地址。</p> 
<p>MAC地址具有扁平接口，如果一台主机移动位置，它的MAC地址不会改变（和主机本身相关），IP地址会发生改变（和网络环境相关）。MAC地址像身份证号；IP地址像邮政地址，有层次，会改变。</p> 
<p>MAC地址像身份证号，IP地址像邮政地址，有层次，会改变。</p> 
<p>当某适配器要向目的适配器发送一个帧时，发送适配器将目的适配器的MAC地址插入该帧，发送到局域网上，适配器可以接受一个并非向它寻址的帧，当适配器接受一个帧时，检查帧中的目的MAC地址与自己的MAC地址是否匹配，若匹配则取出数据报，向上传递，否则丢弃。</p> 
<p>适配器通过MAC广播地址FF-FF-FF-FF-FF-FF来广播。</p> 
<p><strong>地址解析协议（ARP）</strong><br> ARP的作用是根据目标的IP地址获取其MAC地址。</p> 
<p>DNS为因特网中任何地方的主机解析主机名，而ARP只为在同一个子网上的主机和路由器接口解析IP地址。</p> 
<p>每台主机和路由器在内存中有一个ARP表，包含IP地址到MAC地址的映射关系，过期时间20分钟。映射关系包含IP地址，MAC地址和TTL（寿命）。</p> 
<p>如发送方的ARP表中没有目的主机的相关信息，那么发送方适配器通过MAC广播地址发送查询分组，子网中的每个适配器都把ARP分组向上传递给ARP模块，检查自己的IP地址和分组中的目的IP地址是否一致，匹配的主机发送回一个ARP响应分组，然后查询主机更新它的ARP表，并发送它的IP数据报。</p> 
<p>ARP协议是一个跨越链路层和网络层的协议。</p> 
<h3><a id="642___243"></a>6.4.2 以太网</h3> 
<p>以太网占领了现有的有线局域网市场，就像因特网之于全球联网的地位。<br> 集线器是一种物理层设备，作用于比特而不是帧。当0或1的比特到达一个接口时，集线器只是重新生成这个比特，将其能量强度放大，并将该比特向其他所有接口传输出去。所有接口都会收到信号，但只有目的主机会接受信号。<br> 基于集线器的星形拓扑的以太网也是一个广播局域网，现在位于中心的集线器被交换机所取代。<br> 交换机是无碰撞的存储转发分组交换机，运行在链路层。<br> <strong>（1）以太网帧结构</strong></p> 
<p>数据字段（46~1500字节）：承载了IP数据报（如），超过1500字节的数据报需要分片；若小于46字节，需要填充到46字节。<br> 目的地址（6字节）：目的适配器的MAC地址。当目的适配器收到一个以太网帧，若目的地址是自己的MAC地址或广播地址，将数据字段传给网络层，其他则丢弃。<br> 源地址（6字节）：传输该帧的适配器的MAC地址。<br> 类型字段（2字节）：允许以太网复用多种网络层协议类型。<br> CRC（4字节）：差错检测<br> 前同步码（8字节）：以太网帧以8字节的前同步码开始，前7个字节用于唤醒接收适配器，同步发送方接收方时钟，第8个字节最后两个比特（11）警告目的适配器，重要内容来了。<br> 以太网技术向网络层提供不可靠、无连接服务。没有通过CRC校验的以太网帧会被丢弃，因此数据报流有时会有一些空隙（UDP不会填补空隙，TCP会要求发送方填补空隙）。</p> 
<p><strong>（2）以太网技术</strong></p> 
<p>早期10BASE-2和10BASE-5标准规定两种类型的同轴电缆的10Mbps以太网，每种标准限制在500米，通过转发器得到更长运行距离。</p> 
<p>100BASE-5：BASE表示基带以太网。前面的数字代表速率。5表示传输距离为500m。<br> 今天的以太网，节点经点对点由双绞铜线或光纤构成的线段与一台交换机相连。</p> 
<p>现代交换机是全双工的，一台交换机和一个结点能同时向对方发送帧而没有干扰。在基于交换机的以太局域网中，没有必要使用MAC协议了。</p> 
<p>6.4.3 链路层交换机<br> 交换机的任务：接收入链路层帧，转发到出链路。</p> 
<p>交换机自身对子网中的主机和路由器是透明的，主机/路由器向另一个主机/路由器寻址一个帧，顺利将帧发送进局域网，并不知道交换机的存在。</p> 
<p><strong>（1）转发和过滤</strong></p> 
<p>过滤决定一个帧应该被转发到某个接口还是应当将其丢弃。</p> 
<p>转发决定一个帧应该被导向哪个接口，并将其移动到那些接口。</p> 
<p>交换机表中包含MAC地址，通往该MAC地址的接口，表项建立时间。</p> 
<p>例如：</p> 
<p>从A接口到达的帧需要从B接口转发，那么从B接口转发即可。<br> 从A接口到达的帧需要从A接口转发，那么直接丢弃该帧。<br> 交换机表中没有找到该帧的目的地址，那么向所有接口广播转发数据帧。<br> <strong>（2）自学习</strong></p> 
<p>交换机可以自动地配置交换机表，而无需人为干预，因此交换机是即插即用设备。</p> 
<p>建立交换机表步骤：</p> 
<ul><li>交换机表初始为空。</li><li>从某个接口收到帧以后，交换机表会存储该帧的源地址字段中的MAC地址和收到该帧的接口以及接收时间。</li><li>如果一段时间内没有收到某个MAC地址发来的帧，那么将其从交换机表中删除。</li></ul> 
<p>也就是说，交换机记录它所接收的帧的信息，判断某个接口背后的MAC地址。</p> 
<p><strong>（3）链路交换机的性质</strong></p> 
<p>消除碰撞：交换机可以缓存帧，并且保证一次只在网段上传输一个帧。<br> 异质的电路：交换机可以兼容不同类型的链路连接，甚至支持原有的设备和新设备混用。<br> 管理：能够识别某个适配器的异常或者某段链路的异常。</p> 
<p><strong>（4）交换机与路由器比较</strong></p> 
<p>交换机是链路层的分组交换机（使用MAC地址转发），路由器是网络层的分组交换机（使用IP地址转发）。</p> 
<p>交换机的优点：</p> 
<ul><li>即插即用</li><li>具有相对更高的转发和过滤速率</li></ul> 
<p>交换机的缺点：</p> 
<ul><li>面对大的交换网络，超高的ARP流量和广播风暴，没有较好的应对能力。</li><li>结构被限制为生成树，处理能力弱。</li></ul> 
<p>路由器的优点：</p> 
<ul><li>IP地址是有层次的，因此不会出现路由器循环。</li><li>可以以丰富的结构构建因特网结构，并选择最短路径。</li><li>对链路层的广播风暴提供防火墙保护。</li></ul> 
<p>路由器的缺点：</p> 
<ul><li>需要人为配置路由器转发表。</li></ul> 
<p>综上，对于几百台主机构成的小网络来说，交换机就足够了，但是对于几千台甚至更多的主机来说，需要路由器来配合交换机使用。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/48877f9ad219a2dfd2efee8c971f7850/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">allegro 17.4 笔记一</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/deb132bc8e1774b66e9ccd3e5424b951/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PostgreSql根据给的时间范围统计15分钟粒度、小时粒度、天粒度、周粒度、月粒度工单</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>