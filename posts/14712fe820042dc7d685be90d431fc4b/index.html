<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言——函数栈帧的创建和销毁 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言——函数栈帧的创建和销毁" />
<meta property="og:description" content="主题： 什么时函数栈帧？理解函数栈帧能解决什么问题？函数栈帧的创建和销毁解析 1.什么时函数栈帧 我们在写C语言代码的时候，经常会把一个独立的功能抽象为函数，所以C程序是以函数为基本单位的。那函数是如何调用的？函数的返回值又是如何待会的？函数参数是如何传递的？这些问题都和函数栈帧有关系。函数栈帧（stack frame）就是函数调用过程中在程序的调用栈（call stack）所开辟的空间，这些空间是用来存放： 函数参数和函数返回值临时变量（包括函数的非静态的局部变量以及编译器自动生产的其他临时变量）保存上下文信息（包括在函数调用前后需要保持不变的寄存器） 2. 理解函数栈帧能解决什么问题？ 只要理解了函数栈帧的创建和销毁，以下问题就能够很好的理解了： 局部变量是如何创建的？为什么局部变量不初始化内容是随机的？函数电泳时参数是如何传递的？传参的顺序是怎样的？函数的形参和实参分别是怎样实例化的？函数的返回值是如何带回的？ 让我们一起走进函数栈帧的创建和销毁的过程中吧！ 3. 函数栈帧的创建和销毁解析 3.1 什么是栈？ 栈（stack）是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函
数，没有局部变量，也就没有我们如今看到的所有的计算机语言。在经典的计算机科学中，栈被定义为一种特殊的容器，用户可以将数据压入栈中（入栈，push），也可
以将已经压入栈中的数据弹出（出栈，pop），但是栈这个容器必须遵守一条规则：先入栈的数据后出
栈（First In Last Out， FIFO）。就像叠成一叠的术，先叠上去的书在最下面，因此要最后才能取出。在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据
从栈顶弹出。压栈操作使得栈增大，而弹出操作使得栈减小。在经典的操作系统中，栈总是向下增长（由高地址向低地址）的。在我们常见的i386或者x86-64下，栈顶由成为 esp 的寄存器进行定位的。 3.2 认识相关寄存器和汇编指令 3.2.1 相关寄存器 3.2.2 相关汇编指令 3.3 解析函数栈帧的创建和销毁 3.3.1 预备知识 首先我们达成一些预备知识才能有效的帮助我们理解，函数栈帧的创建和销毁。 每一次函数调用，都要为本次函数调用开辟空间，就是函数栈帧的空间这块空间的维护是使用了2个寄存器： esp 和 ebp ， ebp 记录的是栈底的地址， esp 记录的是栈顶
的地址。 如图所示： 函数栈帧的创建和销毁过程，在不同的编译器上实现的方法大同小异，本次演示以VS2019为例。 3.3.2 函数的调用堆栈 演示代码：
#include &lt;stdio.h&gt; int Add(int x, int y) { int z = 0; z = x &#43; y; return z; } int main() { int a = 3; int b = 5; int ret = 0; ret = Add(a, b); printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/14712fe820042dc7d685be90d431fc4b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-14T15:45:42+08:00" />
<meta property="article:modified_time" content="2024-01-14T15:45:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言——函数栈帧的创建和销毁</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_1"></a>主题：</h2> 
<ul><li>什么时函数栈帧？</li><li>理解函数栈帧能解决什么问题？</li><li>函数栈帧的创建和销毁解析</li></ul> 
<h2><a id="1_6"></a>1.什么时函数栈帧</h2> 
<blockquote> 
 <ul><li>我们在写C语言代码的时候，经常会把一个独立的功能抽象为函数，所以C程序是以函数为基本单位的。</li><li>那函数是如何调用的？函数的返回值又是如何待会的？函数参数是如何传递的？</li><li>这些问题都和函数栈帧有关系。</li><li>函数栈帧（stack frame）就是函数调用过程中在程序的调用栈（call stack）所开辟的空间，</li><li>这些空间是用来存放：</li></ul> 
 <ol><li>函数参数和函数返回值</li><li>临时变量（包括函数的非静态的局部变量以及编译器自动生产的其他临时变量）</li><li>保存上下文信息（包括在函数调用前后需要保持不变的寄存器）</li></ol> 
</blockquote> 
<h2><a id="2__16"></a>2. 理解函数栈帧能解决什么问题？</h2> 
<blockquote> 
 <ul><li>只要理解了函数栈帧的创建和销毁，以下问题就能够很好的理解了：</li></ul> 
 <ol><li>局部变量是如何创建的？</li><li>为什么局部变量不初始化内容是随机的？</li><li>函数电泳时参数是如何传递的？传参的顺序是怎样的？</li><li>函数的形参和实参分别是怎样实例化的？</li><li>函数的返回值是如何带回的？</li></ol> 
 <ul><li>让我们一起走进函数栈帧的创建和销毁的过程中吧！</li></ul> 
</blockquote> 
<h2><a id="3__26"></a>3. 函数栈帧的创建和销毁解析</h2> 
<h3><a id="31__27"></a>3.1 什么是栈？</h3> 
<blockquote> 
 <ul><li>栈（stack）是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函<br> 数，没有局部变量，也就没有我们如今看到的所有的计算机语言。</li><li>在经典的计算机科学中，栈被定义为一种特殊的容器，用户可以将数据压入栈中（入栈，push），也可<br> 以将已经压入栈中的数据弹出（出栈，pop），但是栈这个容器必须遵守一条规则：先入栈的数据后出<br> 栈（First In Last Out， FIFO）。就像叠成一叠的术，先叠上去的书在最下面，因此要最后才能取出。</li><li>在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据<br> 从栈顶弹出。压栈操作使得栈增大，而弹出操作使得栈减小。</li><li>在经典的操作系统中，栈总是向下增长（由高地址向低地址）的。</li><li>在我们常见的i386或者x86-64下，栈顶由成为 esp 的寄存器进行定位的。</li></ul> 
</blockquote> 
<h3><a id="32__38"></a>3.2 认识相关寄存器和汇编指令</h3> 
<h4><a id="321_httpscbianchengnetviewct336eihtmltextE5AF84E5AD98E599A8EFBC88RegisterEFBC89E698AFE4BB80E4B988EFBC9F20E78EB0E4BBA3E9AB98E680A7E883BD20CPU20E4B8ADE587A0E58D81E4B8AAE5AF84E5AD98E599A8E4B99FE5B0B1E5A49FE794A8E4BA86E38082E5AF84E5AD98E599A8EFBC88RegisterEFBC89E698AF20CPU20E4B8ADE794A8E4BA8EE5AD98E582A8E695B0E68DAEE79A84E58D95E58583E3808220E59CA8E8BF90E7AE97E599A8E38081E68EA7E588B6E599A8E4B8ADEFBC8CE983BDE99C80E8A681E69C89E8AEB0E5BF86E58A9FE883BDE79A84E58D95E58583E69DA5E4BF9DE5AD98E4BB8EE5AD98E582A8E599A8E4B8ADE8AFBBE58F96E79A84E695B0E68DAEEFBC8CE4BBA5E58F8AE4BF9DE5AD98E8BF90E7AE97E599A8E7949FE68890E79A84E695B0E68DAEEFBC8CE8BF99E6A0B7E79A84E58D95E58583E5B0B1E698AFE5AF84E5AD98E599A8E3808220E8BF99E4B880E7B3BBE58897E58D95E58583E4BDBFE794A8E2809CE5AF84E5AD98E599A8E2809DE79A84E5908DE7A7B0E4B8BBE8A681E698AFE4B8BAE4BA86E5928CE5AD98E582A8E599A8EFBC88MemoryEFBC89E79BB8E58CBAE58886E38082_39"></a>3.2.1 相关<a href="https://c.biancheng.net/view/ct336ei.html#:~:text=%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Register%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%20%E7%8E%B0%E4%BB%A3%E9%AB%98%E6%80%A7%E8%83%BD%20CPU%20%E4%B8%AD%E5%87%A0%E5%8D%81%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E4%B9%9F%E5%B0%B1%E5%A4%9F%E7%94%A8%E4%BA%86%E3%80%82,%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Register%EF%BC%89%E6%98%AF%20CPU%20%E4%B8%AD%E7%94%A8%E4%BA%8E%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8D%95%E5%85%83%E3%80%82%20%E5%9C%A8%E8%BF%90%E7%AE%97%E5%99%A8%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%EF%BC%8C%E9%83%BD%E9%9C%80%E8%A6%81%E6%9C%89%E8%AE%B0%E5%BF%86%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8D%95%E5%85%83%E6%9D%A5%E4%BF%9D%E5%AD%98%E4%BB%8E%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%E8%AF%BB%E5%8F%96%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BF%9D%E5%AD%98%E8%BF%90%E7%AE%97%E5%99%A8%E7%94%9F%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%99%E6%A0%B7%E7%9A%84%E5%8D%95%E5%85%83%E5%B0%B1%E6%98%AF%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82%20%E8%BF%99%E4%B8%80%E7%B3%BB%E5%88%97%E5%8D%95%E5%85%83%E4%BD%BF%E7%94%A8%E2%80%9C%E5%AF%84%E5%AD%98%E5%99%A8%E2%80%9D%E7%9A%84%E5%90%8D%E7%A7%B0%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%BA%E4%BA%86%E5%92%8C%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88Memory%EF%BC%89%E7%9B%B8%E5%8C%BA%E5%88%86%E3%80%82" rel="nofollow">寄存器</a></h4> 
<p><img src="https://images2.imgbox.com/b1/d9/AZvhst3X_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="322__41"></a>3.2.2 相关汇编指令</h4> 
<p><img src="https://images2.imgbox.com/42/84/T055NFXC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="33__45"></a>3.3 解析函数栈帧的创建和销毁</h3> 
<h4><a id="331__47"></a>3.3.1 预备知识</h4> 
<blockquote> 
 <ul><li>首先我们达成一些预备知识才能有效的帮助我们理解，函数栈帧的创建和销毁。</li></ul> 
 <ol><li>每一次函数调用，都要为本次函数调用开辟空间，就是函数栈帧的空间</li><li>这块空间的维护是使用了2个寄存器： <strong>esp</strong> 和 <strong>ebp</strong> ， <strong>ebp</strong> 记录的是栈底的地址， <strong>esp</strong> 记录的是栈顶<br> 的地址。</li></ol> 
 <ul><li>如图所示：</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/82/b5/Ul2sWVKj_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ol start="3"><li>函数栈帧的创建和销毁过程，在不同的编译器上实现的方法大同小异，本次演示以VS2019为例。</li></ol> 
</blockquote> 
<h4><a id="332__58"></a>3.3.2 函数的调用堆栈</h4> 
<p>演示代码：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	z <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
	<span class="token keyword">return</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <ul><li>这段代码，如果我们在VS2019编译器上调试，调试进入Add函数后，我们就可以观察到函数的调用堆栈<br> （右击勾选【显示外部代码】），如下图：</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/2d/8e/e7MGCZZM_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>函数调用堆栈是反馈函数调用逻辑的，那我们可以清晰的观察到， <strong>main</strong> 函数调用之前，是由<br> <strong>invoke_main</strong> 函数来调用 <strong>main</strong> 函数。 在 invoke_main 函数之前的函数调用我们就暂时不考虑了。</li><li>那我们可以确定， invoke_main 函数应该会有自己的栈帧， main 函数和 Add 函数也会维护自己的栈<br> 帧，每个函数栈帧都有自己的 ebp 和 esp 来维护栈帧空间。</li><li>那接下来我们从main函数的栈帧创建开始讲解：</li></ul> 
</blockquote> 
<h4><a id="334__91"></a>3.3.4 准备环境</h4> 
<blockquote> 
 <ul><li>为了让我们研究函数栈帧的过程足够清晰，不要太多干扰，我们可以关闭下面的选项，让汇编代码中排<br> 除一些编译器附加的代码：</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ab/2d/5MyYXD8z_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="335__97"></a>3.3.5 转到反汇编</h4> 
<blockquote> 
 <ul><li>调试到 <strong>main</strong> 函数开始执行的第一行，点击鼠标转到反汇编</li><li>注：VS编译器每次调试都会为程序重新分配内存，课件中的反汇编代码是一次调试代码过程中数据，每<br> 次调试略有差异。</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4b/25/iMTWbhuz_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>转到反汇编后的代码如下：</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e4/fa/uGlpH6gN_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="336__109"></a>3.3.6 函数栈帧的创建</h4> 
<blockquote> 
 <ul><li>这里我们看到 <strong>main</strong> 函数转化来的汇编代码如上图所示，</li><li>接下来我们就一行行拆解代码</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/0a/91/CyLnfwSM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9f/68/UeIlhzZh_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>上面这段代码最后四句，等价于下面的伪代码：</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/9c/61/WtwwXABr_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>上述代码的图示为：</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/6c/b6/82jzflKE_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>小知识：烫烫烫烫烫烫烫烫~</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/28/ef/ZTYndSs0_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>之所以上面的程序输出“烫”这么一个奇怪的字，是因为 <strong>main</strong> 函数调用时，</li><li>在栈区开辟的空间的其中每一个字节都被初始化为 <strong>0xCC</strong>，</li><li>而 <strong>arr</strong> 数组是一个未初始化的数组，恰好在这块空间上创建的，<strong>0xCCCC</strong>（两个连续排列的<strong>0xCC</strong>）的汉字编码就是“烫”，</li><li>所以 <strong>0xCCCC</strong> 被当作文本就是“烫”。</li></ul> 
</blockquote> 
<ul><li>接下来我们再分析main函数中的核心代码：</li></ul> 
<p><img src="https://images2.imgbox.com/de/59/MiWZ9V8r_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>对应的图解为：</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/2e/41/P8GaIioZ_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>Add函数的传参：</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/dd/80/LiuW9bfB_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>调用过程：</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/02/da/5gLFAeQA_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li><strong>call</strong> 指令是要执行函数调用逻辑的，在执行 <strong>call</strong> 指令之前先会把 <strong>call</strong> 指令的下一条指令的地址进行压栈<br> 操作，这个操作是为了解决当函数调用结束后要回到 <strong>call</strong> 指令的下一条指令的地方，继续往后执行。</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4d/52/1xiFwwkG_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>当我们跳转到 <strong>Add</strong> 函数，就要开始观察 <strong>Add</strong> 函数的反汇编代码了。</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a6/7f/4zXuB6D0_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>代码执行到 <strong>Add</strong> 函数的时候，就要开始创建 <strong>Add</strong> 函数的栈帧空间了。</li><li>在 <strong>Add</strong> 函数中创建栈帧的方法和在main函数中是相似的，在栈帧空间的大小上略有差异而已。</li></ul> 
 <ol><li>将 <strong>main</strong> 函数的 <strong>ebp</strong> 压栈</li><li>计算新的 <strong>ebp</strong> 和 <strong>esp</strong></li><li>将 <strong>ebx ， esi ， edi</strong> 寄存器的值保存</li><li>计算求和，在计算求和的时候，我们是通过 ebp 中的地址进行偏移访问到了函数调用前压栈进去的<br> 参数，这就是形参访问。</li><li>将求出的和放在 <strong>eax</strong> 寄存器中准备带回</li></ol> 
</blockquote> 
<p><img src="https://images2.imgbox.com/11/81/CgJEMLmy_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="337__167"></a>3.3.7 函数栈帧的销毁</h4> 
<blockquote> 
 <ul><li>当函数调用结束返回的时候，前面创建的函数栈帧也开始销毁。</li><li>那具体是怎么销毁的呢？我们看一下反汇编代码。</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/24/35/YHTp8Ytm_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>回到了 <strong>call</strong> 指令的下一条指令的地方：</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/39/02/zuKkOICa_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ul><li>但调用完Add函数，回到main函数的时候，继续往下执行，可以看到：</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8e/27/ro5MlYwl_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="338__181"></a>3.3.8 拓展了解</h4> 
<p>其实返回对象时内置类型时，一般都是通过寄存器来带回返回值的，返回对象如果时较大的对象时，一<br> 般会在主调函数的栈帧中开辟一块空间，然后把这块空间的地址，隐式传递给被调函数，在被调函数中<br> 通过地址找到主调函数中预留的空间，将返回值直接保存到主调函数的。具体可以参考<a href="https://yxj-books.readthedocs.io/zh-cn/latest/programming/ProgrammerSelfCultivation/ch10.html" rel="nofollow">程序员的自我修养</a></p> 
<p>最后，<br> 如果以上代码或表述有问题，<br> 欢迎一起交流。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/575d3174242bf89d8478ac2e699d98de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信商家转账到零钱怎么开通？场景模板</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2afb12869107be8f4580e008814cf917/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">八. 实战：CUDA-BEVFusion部署分析-导出带有spconv的SCN网络的onnx</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>