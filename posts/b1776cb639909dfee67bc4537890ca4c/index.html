<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kafka——集群 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kafka——集群" />
<meta property="og:description" content="文章目录 集群1. 搭建个集群2. 集群发送消息3. 集群消费3.1 Procuder3.2 Consumer 4. 消费顺序 集群 对于kafka来说，一个单独的broker意味着kafka集群中只有一个节点。要想增加kafka集群中的节点数量，只需要多启动几个broker实例即可，为了有更好的理解，现在我们在一台机器上同时启动三个broker实例。
1. 搭建个集群 建立好2个broker的配置文件：
cp config/server.properties config/server-1.properties cp config/server.properties config/server-2.properties 针对配置文件进行修改：
server-1.properties
#broker.id属性在kafka集群中必须要是唯一 broker.id=1 #kafka部署的机器ip和提供服务的端口号 listeners=PLAINTEXT://192.168.65.60:9093 log.dir=/usr/local/data/kafka-logs-1 #kafka连接zookeeper的地址，要把多个kafka实例组成集群，对应连接的zookeeper必须相同 zookeeper.connect=192.168.65.60:2181 config/server-2.properties:
broker.id=2 listeners=PLAINTEXT://192.168.65.60:9094 log.dir=/usr/local/data/kafka-logs-2 zookeeper.connect=192.168.65.60:2181 确定这两个实例：
bin/kafka-server-start.sh -daemon config/server-1.properties bin/kafka-server-start.sh -daemon config/server-2.properties 现在我们创建一个新的topic，副本数设置为3，分区数设置为2：
bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 2 --topic my-replicated-topic 查看一下topic的情况：
bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic leader节点负责给定partition 的所有读写请求，同一个topic不同分区的leader副本一般不一样（为了容灾）。比如图上一共有两个分区，分区1的leader在broker11，分区0的leader在broker0。replicas 表示某个partition在哪几个broker上存在备份。不管这几个点是不是“leader”，甚至这个节点挂了，也会列出。isr 是replicas的一个子集，它只列出当前还存活着的，并且已同步备份了该partition的节点。 2. 集群发送消息 现在我们向新建的 my-replicated-topic 中发生了一些message，kafka集群可以加上所有kafka节点：
./kafka-console-producer.sh --broker-list localhost:9092,localhost:9093,localhost:9094 --topic my-replicated-topic 现在我们向新建的 my-replicated-topic 中发送一些message，kafka集群可以加上所有kafka节点：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b1776cb639909dfee67bc4537890ca4c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-21T17:27:10+08:00" />
<meta property="article:modified_time" content="2021-07-21T17:27:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kafka——集群</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">集群</a></li><li><ul><li><a href="#1__5" rel="nofollow">1. 搭建个集群</a></li><li><a href="#2__47" rel="nofollow">2. 集群发送消息</a></li><li><a href="#3__76" rel="nofollow">3. 集群消费</a></li><li><ul><li><a href="#31_Procuder_80" rel="nofollow">3.1 Procuder</a></li><li><a href="#32_Consumer_82" rel="nofollow">3.2 Consumer</a></li></ul> 
   </li><li><a href="#4__97" rel="nofollow">4. 消费顺序</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>集群</h2> 
<p>对于kafka来说，一个单独的broker意味着kafka集群中只有一个节点。要想增加kafka集群中的节点数量，只需要多启动几个broker实例即可，为了有更好的理解，现在我们在一台机器上同时启动三个broker实例。</p> 
<h3><a id="1__5"></a>1. 搭建个集群</h3> 
<p><strong>建立好2个broker的配置文件：</strong></p> 
<pre><code class="prism language-shell"><span class="token function">cp</span> config/server.properties config/server-1.properties
<span class="token function">cp</span> config/server.properties config/server-2.properties
</code></pre> 
<p><strong>针对配置文件进行修改：</strong><br> server-1.properties</p> 
<pre><code class="prism language-properties">#broker.id属性在kafka集群中必须要是唯一
broker.id=1
#kafka部署的机器ip和提供服务的端口号
listeners=PLAINTEXT://192.168.65.60:9093   
log.dir=/usr/local/data/kafka-logs-1
#kafka连接zookeeper的地址，要把多个kafka实例组成集群，对应连接的zookeeper必须相同
zookeeper.connect=192.168.65.60:2181
</code></pre> 
<p>config/server-2.properties:</p> 
<pre><code class="prism language-properties">broker.id=2
listeners=PLAINTEXT://192.168.65.60:9094
log.dir=/usr/local/data/kafka-logs-2
zookeeper.connect=192.168.65.60:2181
</code></pre> 
<p><strong>确定这两个实例：</strong></p> 
<pre><code class="prism language-shell">bin/kafka-server-start.sh -daemon config/server-1.properties
bin/kafka-server-start.sh -daemon config/server-2.properties
</code></pre> 
<p><strong>现在我们创建一个新的topic，副本数设置为3，分区数设置为2：</strong></p> 
<pre><code class="prism language-shell">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 2 --topic my-replicated-topic
</code></pre> 
<p><strong>查看一下topic的情况：</strong></p> 
<pre><code class="prism language-shell">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic
</code></pre> 
<p><img src="https://images2.imgbox.com/58/fa/DxGy1dKu_o.png" alt="在这里插入图片描述"></p> 
<ul><li>leader节点负责给定partition 的所有读写请求，同一个topic不同分区的leader副本一般不一样（为了容灾）。比如图上一共有两个分区，分区1的leader在broker11，分区0的leader在broker0。</li><li>replicas 表示某个partition在哪几个broker上存在备份。不管这几个点是不是“leader”，甚至这个节点挂了，也会列出。</li><li>isr 是replicas的一个子集，它只列出当前还存活着的，并且已同步备份了该partition的节点。</li></ul> 
<h3><a id="2__47"></a>2. 集群发送消息</h3> 
<p><strong>现在我们向新建的 my-replicated-topic 中发生了一些message，kafka集群可以加上所有kafka节点：</strong></p> 
<pre><code class="prism language-shell">./kafka-console-producer.sh --broker-list localhost:9092,localhost:9093,localhost:9094 --topic my-replicated-topic
</code></pre> 
<p><strong>现在我们向新建的 my-replicated-topic 中发送一些message，kafka集群可以加上所有kafka节点：</strong></p> 
<pre><code class="prism language-shell">./kafka-console-consumer.sh --bootstrap-server localhost:9092,localhost:9093,localhost:9094 --from-beginning --topic my-replicated-topic
</code></pre> 
<p><strong>现在我们来测试我们容错性，因为broker1目前是my-replicated-topic的分区0的leader，所以我们要将其kill：</strong></p> 
<pre><code class="prism language-shell"><span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> server.properties <span class="token comment">## 找到broker进程。</span>
<span class="token function">kill</span> 48028 <span class="token comment">## 杀死掉</span>
</code></pre> 
<p><strong>现在执行命令：</strong></p> 
<pre><code class="prism language-shell">bin/kafka-topics.sh --describe --zookeeper localhost:9092 --topic my-replicated-topic
</code></pre> 
<p><img src="https://images2.imgbox.com/c0/50/sionpziW_o.png" alt="在这里插入图片描述"><br> 我们可以看到，分区0的leader节点已经变成了broker0.要注意的是，在isr中，已经没有1号节点，leader的选举也是从ISR（in-sync replica）中进行的。<br> 此时，我们依然可以消费消息：</p> 
<pre><code class="prism language-shell">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092,localhost:9093,localhost:9094 --from-beginning --topic my-replicated-topic
my <span class="token function">test</span> msg 1
my <span class="token function">test</span> msg 2
</code></pre> 
<p>查看主题分区对应的leader信息：<br> <img src="https://images2.imgbox.com/ca/c0/75EN2cb3_o.png" alt="在这里插入图片描述"><br> <strong>kafka将很多集群关键信息记录在zookeeper里，保证自己的无状态，从而在水平扩容时非常方便。</strong></p> 
<h3><a id="3__76"></a>3. 集群消费</h3> 
<p>log的partitions分布在kafka集群中不同的broker上，每个broker可以请求备份其他broker上partition上的数据。kafka集群支持配置一个partition备份的数量。<br> 针对每个partition，都有一个broker起到“leader”作用，0个或多个其他的broker作为“follwers”的作用。leader处理所有的针对这个partition的读写请求，而followers被动复制leader的结果，不提供读写（主要是为了保证多副本数据与消费的一致性）。如果这个leader失效了，其中的一个follower将会自动的变成新的leader。</p> 
<h4><a id="31_Procuder_80"></a>3.1 Procuder</h4> 
<p>生产者将消息发送到topic中去，通知负责选择message发送到topic的哪一个partition中。通过round-robin做简单的负载均衡。也可以根据消息中的某个关键字来进行区分。通常第二种方式使用的更多。</p> 
<h4><a id="32_Consumer_82"></a>3.2 Consumer</h4> 
<p>传统的消息传递模式有2中：队列（queue）和（publish-subscribe）</p> 
<ul><li>queue模式：多个consumer从服务器中读取数据，消息只会到达一个consumer。</li><li>publish-subscribe模式：消息会被广播给所有的consumer。</li></ul> 
<p>kafka基于这2中模式提供了一种consumer的抽象概念：consumer-group</p> 
<ul><li>queue模式：所有的consumer都位于同一个consumer group 下</li><li>publish-subscribe模式：所有的consumer都有着自己唯一的consumer group<br> <img src="https://images2.imgbox.com/ea/69/JEa0otcQ_o.png" alt="在这里插入图片描述"><br> 上图说明：由2个broker组成的kafka集群，某个主题总共有4个partition（P0-P3），分别位于不同的broker上。这个集群由2个consumer group消费，A有2个consumer instances，B有4个。<br> 通常一个topic 会有几个consumer group。每个consumer group 都是一个逻辑上的订阅者（logical subscriber）。每个consumer group 有多个consumer instance组成，从而达到可扩展和容灾的功能。</li></ul> 
<h3><a id="4__97"></a>4. 消费顺序</h3> 
<p>一个partition同一时刻在一个consumer group 中只能有一个consumer instance消费，从而保证消费顺序。<br> consumer group 中的consumer instance 的数量不能比一个Topic中的partition的数量多，否则，多出来的consumer消费不到消息。<br> Kafka只能在partition 的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的顺序性。<br> 如果有在总体上保证消费顺序的需求，那么我们可以通过将topic的partition数量设置为1，将consumer group 中的consumer instance的数量也设置为1，但是这样会影响性能，所以kafka的顺序消费很少用。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/31e2e9acc19e75bb1429b257d44aa806/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">从函数式编程和面向对象的思考到Vue3的函数式编程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a9c183c7f4a4ba0d5141f4dd21f97435/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数学建模——BP神经网络模型Python代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>