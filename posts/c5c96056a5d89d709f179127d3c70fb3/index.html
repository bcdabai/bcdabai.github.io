<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Hadoop】（七）Yarn 详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Hadoop】（七）Yarn 详解" />
<meta property="og:description" content="文章目录 一、Yarn概述二、Yarn的重要概念三、Yarn基本架构1）ResourceManager（RM）2）ApplicationMaster（AM）3）NodeManager（NM）4）Container 四、Yarn工作机制 一、Yarn概述 Yarn是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而mapreduce等运算程序则相当于运行于操作系统之上的应用程序。
二、Yarn的重要概念 1）Yarn并不清楚用户提交的程序的运行机制
2）Yarn只提供运算资源的调度（用户程序向Yarn申请资源，Yarn就负责分配资源）
3）Yarn中的主管角色叫ResourceManager
4）Yarn中具体提供运算资源的角色叫NodeManager
5）这样一来，Yarn其实就与运行的用户程序完全解耦，就意味着Yarn上可以运行各种类型的分布式运算程序（mapreduce只是其中的一种），比如mapreduce、storm程序，spark程序……
6）所以，spark、storm等运算框架都可以整合在Yarn上运行，只要他们各自的框架中有符合Yarn规范的资源请求机制即可。
7）Yarn就成为一个通用的资源调度平台，从此，企业中以前存在的各种运算集群都可以整合在一个物理集群上，提高资源利用率，方便数据共享。
三、Yarn基本架构 从YARN的架构图来看，它主要由ResourceManager、NodeManager、ApplicationMaster和Container等以下几个组件构成。
1）ResourceManager（RM） YARN分层结构的本质是ResourceManager。这个实体控制整个集群并管理应用程序向基础计算资源的分配。ResourceManager将各个资源部分（计算、内存、带宽等）精心安排给基础NodeManager（YARN的每节点代理）。ResourceManager还与ApplicationMaster一起分配资源，与NodeManager一起启动和监视它们的基础应用程序。在此上下文中，ApplicationMaster承担了以前的TaskTracker的一些角色，ResourceManager承担了JobTracker 的角色。
总的来说，RM有以下作用
（1）处理客户端请求
（2）启动或监控ApplicationMaster
（3）监控NodeManager
（4）资源的分配与调度
2）ApplicationMaster（AM） ApplicationMaster管理在YARN内运行的每个应用程序实例。ApplicationMaster负责协调来自ResourceManager的资源，并通过NodeManager监视容器的执行和资源使用（CPU、内存等的资源分配）。请注意，尽管目前的资源更加传统（CPU 核心、内存），但未来会带来基于手头任务的新资源类型（比如图形处理单元或专用处理设备）。从YARN角度讲，ApplicationMaster是用户代码，因此存在潜在的安全问题。YARN假设ApplicationMaster存在错误或者甚至是恶意的，因此将它们当作无特权的代码对待。
总的来说,AM有以下作用
（1）负责数据的切分
（2）为应用程序申请资源并分配给内部的任务
（3）任务的监控与容错
3）NodeManager（NM） NodeManager管理YARN集群中的每个节点。NodeManager提供针对集群中每个节点的服务，从监督对一个容器的终生管理到监视资源和跟踪节点健康。MRv1通过插槽管理Map 和Reduce任务的执行，而NodeManager管理抽象容器，这些容器代表着可供一个特定应用程序使用的针对每个节点的资源。
总的来说，NM有以下作用
（1）管理单个节点上的资源
（2）处理来自ResourceManager的命令
（3）处理来自ApplicationMaster的命令
4）Container Container是YARN中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当AM向RM申请资源时，RM为AM返回的资源便是用Container表示的。YARN会为每个任务分配一个Container，且该任务只能使用该Container中描述的资源。
总的来说，Container有以下作用
对任务运行环境进行抽象，封装CPU、内存等多维度的资源以及环境变量、启动命令等任务运行相关的信息
要使用一个YARN集群，首先需要一个包含应用程序的客户的请求。ResourceManager协商一个容器的必要资源，启动一个ApplicationMaster来表示已提交的应用程序。通过使用一个资源请求协议，ApplicationMaster协商每个节点上供应用程序使用的资源容器。执行应用程序时，ApplicationMaster监视容器直到完成。当应用程序完成时，ApplicationMaster从 ResourceManager注销其容器，执行周期就完成了。
通过上面的讲解，应该明确的一点是，旧的Hadoop架构受到了JobTracker的高度约束，JobTracker负责整个集群的资源管理和作业调度。新的YARN架构打破了这种模型，允许一个新ResourceManager管理跨应用程序的资源使用，ApplicationMaster负责管理作业的执行。这一更改消除了一处瓶颈，还改善了将Hadoop集群扩展到比以前大得多的配置的能力。此外，不同于传统的MapReduce，YARN允许使用MPI( Message Passing Interface) 等标准通信模式，同时执行各种不同的编程模型，包括图形处理、迭代式处理、机器学习和一般集群计算。
四、Yarn工作机制 1）Yarn运行机制
2）工作机制详解
（0）Mr程序提交到客户端所在的节点
（1）Yarnrunner向Resourcemanager申请一个Application。
（2）rm将该应用程序的资源路径返回给yarnrunner
（3）该程序将运行所需资源提交到HDFS上
（4）程序资源提交完毕后，申请运行mrAppMaster
（5）RM将用户的请求初始化成一个task
（6）其中一个NodeManager领取到task任务。
（7）该NodeManager创建容器Container，并产生MRAppmaster
（8）Container从HDFS上拷贝资源到本地
（9）MRAppmaster向RM 申请运行maptask容器
（10）RM将运行maptask任务分配给另外两个NodeManager，另两个NodeManager分别领取任务并创建容器。
（11）MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动maptask，maptask对数据分区排序。
（12）MRAppmaster向RM申请2个容器，运行reduce task。
（13）reduce task向maptask获取相应分区的数据。
（14）程序运行完毕后，MR会向RM注销自己。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c5c96056a5d89d709f179127d3c70fb3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-17T23:30:17+08:00" />
<meta property="article:modified_time" content="2019-12-17T23:30:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Hadoop】（七）Yarn 详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#Yarn_1" rel="nofollow">一、Yarn概述</a></li><li><a href="#Yarn_3" rel="nofollow">二、Yarn的重要概念</a></li><li><a href="#Yarn_12" rel="nofollow">三、Yarn基本架构</a></li><li><ul><li><a href="#1ResourceManagerRM_16" rel="nofollow">1）ResourceManager（RM）</a></li><li><a href="#2ApplicationMasterAM_25" rel="nofollow">2）ApplicationMaster（AM）</a></li><li><a href="#3NodeManagerNM_33" rel="nofollow">3）NodeManager（NM）</a></li><li><a href="#4Container_41" rel="nofollow">4）Container</a></li></ul> 
   </li><li><a href="#Yarn_49" rel="nofollow">四、Yarn工作机制</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="Yarn_1"></a>一、Yarn概述</h3> 
<p>Yarn是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而mapreduce等运算程序则相当于运行于操作系统之上的应用程序。</p> 
<h3><a id="Yarn_3"></a>二、Yarn的重要概念</h3> 
<p>1）Yarn并不清楚用户提交的程序的运行机制<br> 2）Yarn只提供运算资源的调度（用户程序向Yarn申请资源，Yarn就负责分配资源）<br> 3）Yarn中的主管角色叫ResourceManager<br> 4）Yarn中具体提供运算资源的角色叫NodeManager<br> 5）这样一来，Yarn其实就与运行的用户程序完全解耦，就意味着Yarn上可以运行各种类型的分布式运算程序（mapreduce只是其中的一种），比如mapreduce、storm程序，spark程序……<br> 6）所以，spark、storm等运算框架都可以整合在Yarn上运行，只要他们各自的框架中有符合Yarn规范的资源请求机制即可。<br> 7）Yarn就成为一个通用的资源调度平台，从此，企业中以前存在的各种运算集群都可以整合在一个物理集群上，提高资源利用率，方便数据共享。</p> 
<h3><a id="Yarn_12"></a>三、Yarn基本架构</h3> 
<p><img src="https://images2.imgbox.com/45/cb/xFy7j6ji_o.png" alt="在这里插入图片描述"><br> 从YARN的架构图来看，它主要由ResourceManager、NodeManager、ApplicationMaster和Container等以下几个组件构成。</p> 
<h4><a id="1ResourceManagerRM_16"></a>1）ResourceManager（RM）</h4> 
<p>YARN分层结构的本质是ResourceManager。这个实体控制整个集群并管理应用程序向基础计算资源的分配。ResourceManager将各个资源部分（计算、内存、带宽等）精心安排给基础NodeManager（YARN的每节点代理）。ResourceManager还与ApplicationMaster一起分配资源，与NodeManager一起启动和监视它们的基础应用程序。在此上下文中，ApplicationMaster承担了以前的TaskTracker的一些角色，ResourceManager承担了JobTracker 的角色。<br> 总的来说，RM有以下作用<br> （1）处理客户端请求<br> （2）启动或监控ApplicationMaster<br> （3）监控NodeManager<br> （4）资源的分配与调度</p> 
<h4><a id="2ApplicationMasterAM_25"></a>2）ApplicationMaster（AM）</h4> 
<p>ApplicationMaster管理在YARN内运行的每个应用程序实例。ApplicationMaster负责协调来自ResourceManager的资源，并通过NodeManager监视容器的执行和资源使用（CPU、内存等的资源分配）。请注意，尽管目前的资源更加传统（CPU 核心、内存），但未来会带来基于手头任务的新资源类型（比如图形处理单元或专用处理设备）。从YARN角度讲，ApplicationMaster是用户代码，因此存在潜在的安全问题。YARN假设ApplicationMaster存在错误或者甚至是恶意的，因此将它们当作无特权的代码对待。<br> 总的来说,AM有以下作用<br> （1）负责数据的切分<br> （2）为应用程序申请资源并分配给内部的任务<br> （3）任务的监控与容错</p> 
<h4><a id="3NodeManagerNM_33"></a>3）NodeManager（NM）</h4> 
<p>NodeManager管理YARN集群中的每个节点。NodeManager提供针对集群中每个节点的服务，从监督对一个容器的终生管理到监视资源和跟踪节点健康。MRv1通过插槽管理Map 和Reduce任务的执行，而NodeManager管理抽象容器，这些容器代表着可供一个特定应用程序使用的针对每个节点的资源。<br> 总的来说，NM有以下作用<br> （1）管理单个节点上的资源<br> （2）处理来自ResourceManager的命令<br> （3）处理来自ApplicationMaster的命令</p> 
<h4><a id="4Container_41"></a>4）Container</h4> 
<p>Container是YARN中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当AM向RM申请资源时，RM为AM返回的资源便是用Container表示的。YARN会为每个任务分配一个Container，且该任务只能使用该Container中描述的资源。<br> 总的来说，Container有以下作用</p> 
<p>对任务运行环境进行抽象，封装CPU、内存等多维度的资源以及环境变量、启动命令等任务运行相关的信息<br> 要使用一个YARN集群，首先需要一个包含应用程序的客户的请求。ResourceManager协商一个容器的必要资源，启动一个ApplicationMaster来表示已提交的应用程序。通过使用一个资源请求协议，ApplicationMaster协商每个节点上供应用程序使用的资源容器。执行应用程序时，ApplicationMaster监视容器直到完成。当应用程序完成时，ApplicationMaster从 ResourceManager注销其容器，执行周期就完成了。<br> 通过上面的讲解，应该明确的一点是，旧的Hadoop架构受到了JobTracker的高度约束，JobTracker负责整个集群的资源管理和作业调度。新的YARN架构打破了这种模型，允许一个新ResourceManager管理跨应用程序的资源使用，ApplicationMaster负责管理作业的执行。这一更改消除了一处瓶颈，还改善了将Hadoop集群扩展到比以前大得多的配置的能力。此外，不同于传统的MapReduce，YARN允许使用MPI( Message Passing Interface) 等标准通信模式，同时执行各种不同的编程模型，包括图形处理、迭代式处理、机器学习和一般集群计算。</p> 
<h3><a id="Yarn_49"></a>四、Yarn工作机制</h3> 
<p>1）Yarn运行机制<br> <img src="https://images2.imgbox.com/3a/d9/0aAEDZNQ_o.png" alt="在这里插入图片描述"><br> 2）工作机制详解<br> （0）Mr程序提交到客户端所在的节点<br> （1）Yarnrunner向Resourcemanager申请一个Application。<br> （2）rm将该应用程序的资源路径返回给yarnrunner<br> （3）该程序将运行所需资源提交到HDFS上<br> （4）程序资源提交完毕后，申请运行mrAppMaster<br> （5）RM将用户的请求初始化成一个task<br> （6）其中一个NodeManager领取到task任务。<br> （7）该NodeManager创建容器Container，并产生MRAppmaster<br> （8）Container从HDFS上拷贝资源到本地<br> （9）MRAppmaster向RM 申请运行maptask容器<br> （10）RM将运行maptask任务分配给另外两个NodeManager，另两个NodeManager分别领取任务并创建容器。<br> （11）MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动maptask，maptask对数据分区排序。<br> （12）MRAppmaster向RM申请2个容器，运行reduce task。<br> （13）reduce task向maptask获取相应分区的数据。<br> （14）程序运行完毕后，MR会向RM注销自己。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bafa6d49d13a32d54abfa9d12da48782/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">web服务高级使用     Samba共享</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e7e19b066b14efd9be30247b7bf97e4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mybatis-plus的配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>