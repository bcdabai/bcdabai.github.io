<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图形和图像函数 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="图形和图像函数" />
<meta property="og:description" content="图形和图像函数包含在graphics.h里面 (一) 像素函数 56. putpiel() 画像素点函数 57. getpixel()返回像素色函数 (二) 直线和线型函数 58. line() 画线函数 59. lineto() 画线函数 60. linerel() 相对画线函数 61. setlinestyle() 设置线型函数 62. getlinesettings() 获取线型设置函数 63. setwritemode() 设置画线模式函数 (三)、多边形函数 64. rectangle() 画矩形函数 65. bar() 画条函数 66. bar3d() 画条块函数 67. drawpoly() 画多边形函数 (四)、 圆、弧和曲线函数 68. getaspectratio()获取纵横比函数 69. circle()画圆函数 70. arc() 画圆弧函数 71. ellipse()画椭圆弧函数 72. fillellipse() 画椭圆区函数 73. pieslice() 画扇区函数 74. sector() 画椭圆扇区函数 75. getarccoords()获取圆弧坐标函数 (五)、 填充函数 76. setfillstyle() 设置填充图样和颜色函数 77. setfillpattern() 设置用户图样函数 78." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/21f2e4964aef83cbc2d5c22ed4aa7358/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2008-10-29T17:23:00+08:00" />
<meta property="article:modified_time" content="2008-10-29T17:23:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图形和图像函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <font style="FONT-SIZE: 13pt" color="#ff6600">图形和图像函数包含在graphics.h里面 <br><br>(一) 像素函数 <br>56. putpiel() 画像素点函数 <br>57. getpixel()返回像素色函数 <br>(二) 直线和线型函数 <br>58. line() 画线函数 <br>59. lineto() 画线函数 <br>60. linerel() 相对画线函数 <br>61. setlinestyle() 设置线型函数 <br>62. getlinesettings() 获取线型设置函数 <br>63. setwritemode() 设置画线模式函数 <br>(三)、多边形函数 <br>64. rectangle() 画矩形函数 <br>65. bar() 画条函数 <br>66. bar3d() 画条块函数 <br>67. drawpoly() 画多边形函数 <br>(四)、 圆、弧和曲线函数 <br>68. getaspectratio()获取纵横比函数 <br>69. circle()画圆函数 <br>70. arc() 画圆弧函数 <br>71. ellipse()画椭圆弧函数 <br>72. fillellipse() 画椭圆区函数 <br>73. pieslice() 画扇区函数 <br>74. sector() 画椭圆扇区函数 <br>75. getarccoords()获取圆弧坐标函数 <br>(五)、 填充函数 <br>76. setfillstyle() 设置填充图样和颜色函数 <br>77. setfillpattern() 设置用户图样函数 <br>78. floodfill() 填充闭域函数 <br>79. fillpoly() 填充多边形函数 <br>80. getfillsettings() 获取填充设置函数 <br>81. getfillpattern() 获取用户图样设置函数 <br>(六)、图像函数 <br>82. imagesize() 图像存储大小函数 <br>83. getimage() 保存图像函数 <br>84. putimage() 输出图像函数 <br><br><br><br>四、图形和图像函数 <br>对许多图形应用程序，直线和曲线是非常有用的。但对有些图形只能靠操作单个像素才能画出。当然如果没有画像素的功能，就无法操作直线和曲线的函数。而且通过大规模使用像素功能，整个图形就可以保存、写、擦除和与屏幕上的原有图形进行叠加。 <br>(一) 像素函数 <br><br>56. putpixel() 画像素点函数 <br>功能： 函数putpixel() 在图形模式下屏幕上画一个像素点。 <br>用法： 函数调用方式为void putpixel(int x,int y,int color); <br>说明： 参数x,y为像素点的坐标，color是该像素点的颜色，它可以是颜色符号名，也可以是整型色彩值。 <br>此函数相应的头文件是graphics.h <br>返回值： 无 <br>例： 在屏幕上(6,8)处画一个红色像素点： <br>putpixel(6,8,RED); <br><br>57. getpixel()返回像素色函数 <br>功能： 函数getpixel()返回像素点颜色值。 <br>用法： 该函数调用方式为int getpixel(int x,int y); <br>说明： 参数x,y为像素点坐标。 <br>函数的返回值可以不反映实际彩色值，这取决于调色板的设置情况(参见setpalette()函数)。 <br>这个函数相应的头文件为graphics.h <br>返回值： 返回一个像素点色彩值。 <br>例： 把屏幕上(8,6)点的像素颜色值赋给变量color。 <br>color=getpixel(8,6); <br><br>(二) 直线和线型函数 <br>有三个画直线的函数，即line(),lineto(),linerel()。这些直线使用整型坐标，并相对于当前图形视口，但不一定受视口限制，如果视口裁剪标志clip为真，那么直线将受到视口边缘截断；如果clip为假，即使终点坐标或新的当前位置在图形视口或屏幕极限之外，直线截断到屏幕极限。 <br>有两种线宽及几种线型可供选择，也可以自己定义线图样。下面分别介绍直线和线型函数。 <br><br>58. line() 画线函数 <br>功能： 函数line()使用当前绘图色、线型及线宽，在给定的两点间画一直线。 <br>用法： 该函数调用方式为void line(int startx,int starty,int endx,int endy); <br>说明： 参数startx,starty为起点坐标,endx,endy为终点坐标，函数调用前后，图形状态下屏幕光标(一般不可见)当前位置不改变。 <br>此函数相应的头文件为graphics.h <br>返回值： 无 <br>例： 见函数60.linerel()中的实例。 <br><br>59. lineto() 画线函数 <br>功能： 函数lineto()使用当前绘图色、线型及线宽，从当前位置画一直线到指定位置。 <br>用法： 此函数调用方式为void lineto(int x,int y); <br>说明： 参数x,y为指定点的坐标，函数调用后，当前位置改变到指定点(x,y)。 <br>该函数对应的头文件为graphics.h <br>返回值： 无 <br>例： 见函数60.linerel()中的实例。 <br><br>60.linerel() 相对画线函数 <br>功能： 函数linerel() 使用当前绘图色、线型及线宽，从当前位置开始，按指定的水平和垂直偏移距离画一直线。 <br>用法： 这个函数调用方式为void linerel(int dx,int dy); <br>说明： 参数dx,dy分别是水平偏移距离和垂直偏移距离。 <br>函数调用后，当前位置变为增加偏移距离后的位置，例如，原来的位置是(8,6)，调用函数linerel(10,18)后，当前位置为(18,24)。 <br>返回值：无 <br>例： 下面的程序为画线函数调用实例： <br>＃i nclude&lt;graphics.h&gt; <br>void main() <br>{ <br>int driver,mode; <br>driver=DETECT; <br>mode=0; <br>initgraph(&amp;driver,&amp;mode,""); <br>setcolor(15); <br>line(66,66,88,88); <br>lineto(100,100); <br>linerel(36,64); <br>getch(); <br>restorecrtmode(); <br>} <br><br>61. setlinestyle() 设置线型函数 <br>功能： setlinestyle() 为画线函数设置当前线型，包括线型、线图样和线宽。 <br>用法： setlinestyle() 函数调用方式为void setlinestyle(int stly,unsigned pattern,int width); <br>说明： 参数style为线型取值，也可以用相应名称表示，如表1-10中所示。 <br>参数pattern用于自定义线图样，它是16位(bit)字，只有当style=USERBIT_LINE(值为1)时，pattern的值才有意义，使用用户自定义线图样，与图样中“1”位对应的像素显示，因此，pattern=0xFFFF，则画实线；pattern=0x9999，则画每隔两个像素交替显示的虚线，如果要画长虚线，那么pattern的值可为0xFF00和0xF00F，当style不为USERBIT_LINE值时，虽然pattern的值不起作用，但扔须为它提供一个值，一般取为0。 <br>参数wigth用来设定线宽，其取值见表1-11，表中给出了两个值，即1和3，实际上，线宽取值为2也是可以接受的。 <br>若用非法参数调用setlinestyle()函数，那么graphresult()会返回错误代码，并且当前线型继续有效。 <br>Turbo C提供的线型与线宽定义在头文件graphics.h中，表1-10和1-11分别列出了参数的取值与含义。 <br><br>表1-10 线型 <br>----------------------------------------------------- <br>名 称 取 值 含 义 <br>----------------------------------------------------- <br>SOLID_LINE 0 实线 <br>DOTTED_LINE 1 点线 <br>CNTER_LINE 2 中心线 <br>DASHED_LINE 3 虚线 <br>USERBIT_LINE 4 用户自定义线型 <br>----------------------------------------------------- <br><br>表1-11 线宽 <br>----------------------------------------------------------- <br>名 称 取 值 说 明 <br>----------------------------------------------------------- <br>NORM_WIDTH(常宽) 1 一个像素宽(缺省值) <br>THICK_WIDTH(加宽) 3 三个像素宽 <br>----------------------------------------------------------- <br><br>这个函数的头文件是graphics.h <br>返回值： 无 <br>例： 下面的程序显示了BC中所提供的线型图样： <br>＃i nclude&lt;graphics.h&gt; <br>void main() <br>{ <br>int driver,mode; <br>driver=DETECT; <br>mode=0; <br>initgraph(&amp;driver,&amp;mode,""); <br>for(i=0;i&lt;4;i++) <br>{ <br>setlinestyle(i,0,1); <br>line(i*50,200,i*50+60,200) <br>} <br>getch(); <br>restorecrtmode(); <br>} <br><br>62. getlinesettings() 获取线型设置函数 <br>功能： 函数getlinesettings() 用当前设置的线型、线图样和线宽填 写linesettingstype型结构。 <br>用法： 函数调用方式为void getlinesettings(struct linesettingstype *info); <br>说明： 此函数调用执行后，当前的线型、线图样和线宽值被装入info指向的结构里，从而可从该结构中获得线型设置。 <br>linesettingstype型结构定义如下： <br>struct linesettingstype { <br>int linestyle; <br>unsigned upattern; <br>int thickness; <br>}; <br>其中linestyle用于存放线型，线型值为表1-10中的各值之一。 <br>upattern用为装入用户自定义线图样，这是16位字，每一位等于一个像素，如果哪个位被设置，那么该像素打开，否则关闭。 <br>thickness为线宽值存放的变量，可参见表1-11。 <br>getlinesettings()函数对应的头文件为graphics.h <br>返回值： 返回的线型设置存放在info指向的结构中。 <br>例： 把当前线型的设置写入info结构： <br>struct linesettingstype info; <br>getlinesettings(&amp;info); <br><br><br>63.setwritemode() 设置画线模式函数 <br>功能： 函数setwritemode() 设置画线模式 <br>用法： 函数调用方式为 void setwritemode()(int mode); <br>说明： 参数mode只有两个取值0和1，若mode为0，则新画的线将复盖屏幕上原有的图形，此为缺省画线输出模式。如果mode为1，那么新画的像素点与原有图形的像素点先进行异或(XOR)运算，然后输出到屏幕上，使用这种画线输出模式，第二次画同一图形时，将擦除该图形。调用setwritemode()设置的画线输出模式只影响函数line(),lineto(),linerel(),recangle()和drawpoly()。 <br>setwritemode()函数对应的头文件是graphics.h <br>返回值： 无 <br>例： 设置画线输出模式为0： <br>setwritemode(0); <br><br>(三)、多边形函数 <br>对多边形，无疑可用画直线函数来画出它，但直接提供画多边形的函数会给用户很大方便。最常见的多边形有矩形、矩形块(或称条形)、多边形和多边形块，我们还把长方形条块也放到这里一起考虑，虽然它不是多边形，但它的特例就是矩形(块)。下面直接介绍画多边形的函数。 <br><br>64. rectangle() 画矩形函数 <br>功能： 函数rectangle() 用当前绘图色、线型及线宽，画一个给定左上角与右下角的矩形(正方形或长方形)。 <br>用法： 此函数调用方式为void rectangle(int left,int top,int right,int bottom); <br>说明： 参数left,top是左上角点坐标，right,bottom是右下角点坐标。如果有一个以上角点不在当前图形视口内，且裁剪标志clip设置的是真(1)，那么调用该函数后，只有在图形视口内的矩形部分才被画出。 <br>这个函数对应的头文件为graphics.h <br>返回值： 无 <br>例： 下面的程序画一些矩形实例： <br>＃i nclude&lt;graphics.h&gt; <br>void main() <br>{ <br>int driver,mode; <br>driver=DETECT; <br>mode=0; <br>initgrpah(&amp;driver,&amp;mode,""); <br>rectangle(80,80,220,200); <br>rectangle(140,99,180,300); <br>rectangle(6,6,88,88); <br>rectangle(168,72,260,360); <br>getch(); <br>restorecrtmode(); <br>} <br><br>65. bar() 画条函数 <br>功能： 函数bar()用当前填充图样和填充色(注意不是给图色)画出一个指定上左上角与右下角的实心长条形(长方块或正方块)，但没有四条边线)。 <br>用法： bar()函数调用方式为void bar(int left,int top,int right,int bottom); <br>说明： 参数left,topright,bottom分别为左上角坐标与右下角坐标，它们和调用函数rectangle()的情形相同，调用此函数前，可用setfillstyle()或setfillpattern()设置当前填充图样和填充色。 <br>注意此函数只画没有边线的条形，如果要画有边线的的条形，可调用下面的函数bar3d()来画，并将深度参数设为0，同时topflag参数要设置为真，否则该条形无顶边线。 <br>这 应的头文件为graphics.h <br>返回值： 无 <br>例： 见函数bar3d()中的实例。 <br><br>66.bar3d() 画条块函数 <br>功能： 函数bar3d() 使用当前绘图色、线型及线宽画出三维长方形条块，并用当前填充图样和填 充色填充该三维条块的表面。 <br>用法： 此函数调用方式为void bar3d(int left,int top,int right,int bottom,int depth,int topflag); <br>说明： 参数left,top,right,bottom分另为左上角与右下角坐标，这与bar()函数中的一样。参数depth为条块的深度，以像素为单位，通常按宽度的四分之一计算。深度方向通过屏显纵横比调节为约45度(即这时x/y比设置为1：1)。 <br>参数topflag相当于一个布尔参数，如果设置为1(真)那么条块上放一顶面；若设置为0(假)，则三维条形就没有顶面，这样可使多个三维条形叠加在一起。 <br>要使图形更加美观，可利用函数floodfill()或setfillpattern()来选择填充图样和填充色(参见本小节(五)填充函数 )。 <br>bar3d()函数对应的头文件为graphics.h <br>返回值： 无 <br>例： 下面的程序画一个条形和条块： <br>＃i nclude&lt;graphics.h&gt; <br>void main() <br>{ <br>int driver,mode; <br>driver=DETECT; <br>mode=0; <br>initgraph(&amp;driver,&amp;mode,""); <br>setfillstyle(SOLID-FILL,GREEN); <br>bar(60,80,220,160); <br>setfillstyle(SOLID-FILL,RED); <br>bar3d(260,180,360,240,20,1); <br>getch(); <br>restorecrtmode(); <br>} <br><br>67. drawpoly() 画多边形函数 <br>功能： 函数drawpoly() 用当前绘图色、线型及线宽，画一个给定若干点所定义的多边形。 <br>用法： 此函数调用方式为void drawpoly(int pnumber,int *points); <br>说明： 参数pnumber为多边形的顶点数；参数points指向整型数组，该数组中是多边形所有顶点(x,y)坐标值，即一系列整数对，x坐标值在前。显然整型数组的维数至少为顶点数的2倍，在定义了多边形所有顶点的数组polypoints时，顶点数目可通过计算sizeof(polypoints)除以2倍的sizeof(int)得到，这里除以2倍的原因是每个顶点有两个整数坐标值。另外有一点要注意，画一个n个顶点的闭合图形，顶点数必须等于n+1，并且最后一点(第n+1)点坐标必须等于第一点的坐标。 <br>drawpoly()函数对应的头文件为grpahics.h <br>返回值： 无 <br>例： 下面的程序画一个封闭星形图与一个不封闭星形图： <br>＃i nclude&lt;graphics.h&gt; <br>void main() <br>{ <br>int driver,mode; <br>static int polypoints1[18]={100,100,110,120,100,130,120,125,140,140,130,120, <br>140,110,120,115,100,100}; <br>static int polypoints2[18]={180,100,210,120,200,130,220,125,240,140,230,120, <br>240,110,220,115,220,110}; <br>driver=DETECT; <br>mode=0; <br>initgraph(&amp;driver,&amp;mode,""); <br>drawpoly(9,polypoints1); <br>drawpoly(9,polypoints2); <br>getch(); <br>restorecrtmode(); <br>} <br><br>(四)、 圆、弧和曲线函数 <br>在一个屏幕上画得很圆的图形到另一个屏幕上可能被压扁或拉长，这是因为每一种显示卡与之相应的显示模式都有一个纵横比。纵横比是指像素的水平方向大小与垂直方向大小的比值。如VGA显示卡由于偈素基本上是正方形，所以纵横比为1.000。 <br>为了保证几何图形基本按预计情况显示在屏幕上，用屏显的纵横比来计算和纠正不同硬件及显示卡产生的畸变。计算纵横比所需要的水平方向和垂直方向的比例系数可调用函数getaspectratio()获得。 <br><br>68. getaspectratio()获取纵横比函数 <br>功能： 函数getaspectratio()返回x方向和y方向的比例系数，用这两个整型值可计算某一特定屏显的纵横比。 <br>用法： 此函数调用方式为void getaspectratio(int xasp,int yasp); <br>说明： 参数xasp指向的变量存放返回的x方向比例系数；参数yasp指向的变量存放返回的y方向比例系数。通常y方向比例系数为10 000， x方向比例系数不大于10 000(这是因为大多数屏幕像素高比宽长)。 <br>注意纵横比自动用作下面函数arc(),circle()和pieslice()中的标尺因子，使屏幕上圆或弧正常显示。但用ellipse()函数画椭圆必须调用本函数获取纵横比作为标尺因子，否则不予调整。纵横比可用于其它几何图形，目的是校正和显示图形。 <br>getaspectratio()函数对应的头文件为graphics.h <br>返回值： 返回x与y方向比例系数分别存放在xasp和yasp所指向的变量中。 <br>例： 下面的程序显示纵横比： <br>int xasp,yasp; <br>float aspectratio; <br>getaspectratio(&amp;xasp,&amp;yasp); <br>aspectratio=xasp/yasp; <br>printf("aspect ratio: %f",aspectratio); <br><br>69. circle()画圆函数 <br>功能： 函数circle()使用当前绘图色并以实线画一个完整的圆。 <br>用法：该函数调用方式为void circle(int x,int y,int radius); <br>说明： 参数x,y为圆心坐标，radius为圆半径，用像素个素表示。注意，调用circle()函数画圆时不用当前线型。 <br>不同于ellipse()函数，只用单个半径radius参数调用circle()函数，故屏显纵横比可以自动调节，以产生正确的显示图。 <br>此函数对应的头文件为graphics.h <br>返回值： 无 <br>例： 画六个同心圆，圆心在（100,100）。 <br>＃i nclude&lt;graphics.h&gt; <br>void main() <br>{ <br>int driver,mode; <br>driver=DETECT; <br>mode=0; <br>initgraph(&amp;driver,&amp;mode,""); <br>circle(100,100,10); <br>circle(100,100,20); <br>circle(100,100,30); <br>circle(100,100,40); <br>circle(100,100,50); <br>circle(100,100,60); <br>getch(); <br>restorecrtmode(); <br>} <br><br>70. arc() 画圆弧函数 <br>功能： 函数arc()使用当前绘图色并以实线画一圆弧。 <br>用法： 函数调用方式为void arc(int x,int y,int startangle,int endangle,int radius); <br>说明： 参数x,y为圆心坐标，startangle与endangle分别为起始角与终止角，radius为半径。圆心坐标和半径以像素个数给出，起始角和终止角以度为单位，0度位于右边，90度位于顶部，180度位于左边，底部是270度。同往常一样，360度与0度重合。角度按逆时针方向增加，但并不要求终止角一定比起始角大。例如指定300度和90度分别为起始角和终止角，与指定300度和450度分别为起始角和终止角可画出相同的弧。大于360度可作为参数，它将被化到0度￣360度范围里。函数arc()能画封闭圆，只要取起始角为0度，终止角为360度即可。此函数中，屏显纵横比可自动调节。 <br>arc()函数对应的头文件为graphics.h <br>返回值： 无 <br>例： 以（200,200）为圆心，100为半径，从0度到120度画圆弧： <br>＃i nclude&lt;graphics.h <br>void main() <br>{ <br>int driver,mode; <br>driver=DETECT; <br>mode=0; <br>initgraph(&amp;drivwer,&amp;mode,""); <br>setcolor(WHITE); <br>arc(200,200,0,120,100); <br>getch(); <br>restorecrtmode(); <br>}<br></font>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/478058b03b5a40909f05b47d71e1e22c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">拉响红色警报 IT科技行业裁员风暴已经到来！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92bbe3738e88204218fbc138ae1fe558/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ping 命令详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>