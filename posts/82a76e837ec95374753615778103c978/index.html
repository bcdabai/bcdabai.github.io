<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从 Mysql binlog 过滤抽取指定条件的SQL语句 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从 Mysql binlog 过滤抽取指定条件的SQL语句" />
<meta property="og:description" content="适用场景 适用于希望从mysql的binlog恢复数据。并且希望快速抽取出自己关注的部分数据表，以及特定数据的SQL操作脚本。可以进行精准恢复。 使用须知 Mysql开启了binlog日志功能，并确实记录了想要查找的SQL语句本次使用到了 Linux系统的 grep命令 用于过滤并抽取目标sql脚本到新的文件（效率好高，近2百兆的日志文件瞬间完成过滤写入新文件）。windows 可以尝试安装 grep命令试试，本人没测试过。 开始 获取Mysql的binlog文件 根据mysql的配置找到binlog文件
查找 binlog 文件位置，可以执行语句
SHOW VARIABLES LIKE &#39;log_%&#39;; 关注 字段： log_bin_basename 。后面的value是路径&#43;最后的是binlog文件名，所以访问路径要去掉最后路径分隔符的那个字符串。
例如：D:\mysql-5.6.20-winx64\mysql-5.6.20-winx64\data\mysql-bin
实际binlog文件路径：D:\mysql-5.6.20-winx64\mysql-5.6.20-winx64\data
结尾的myslq-bin 是binlog日志生成的文件名前缀。
解析binlog文件，获取可读的SQL文件 使用命令 mysqlbinlog。只要windows或者Linux上安装过Mysql 命令行可识别此命令就可以用。
# 参数介绍 inlog --base64-output=decode-rows -v /全路径（如果执行命令时不跟binlog文件在一个目录下）/要解析的binlog文件名 --result-file=结果sql脚本文件 # 例子: inlog --base64-output=decode-rows -v /opt/data/mysql-bin.000118 --result-file=000118.sql 节选了一个update（相对其他操作内容更复杂）语句内容如下。
忽略每行开头的### 符号和用@列的顺序号替代了列名,就是一个标准的 SQL语句，
### UPDATE `testdb`.`test_table` ### WHERE ### @1=614305 ### @2=182759 ### @3=182749 ### @4=6668 ### @5=1876 ### @6=NULL ### @7=1668128408 ### @8=1 ### @9=0 ### SET ### @1=614305 ### @2=182759 ### @3=182749 ### @4=6668 ### @5=1876 ### @6=NULL ### @7=1668136095 ### @8=2 ### @9=0 grep命令简介 本次使用的 grep命令是在Linux环境上，所以把解析好的sql文件我上传到了Linux服务器进行后续操作" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/82a76e837ec95374753615778103c978/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-27T19:19:28+08:00" />
<meta property="article:modified_time" content="2022-11-27T19:19:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从 Mysql binlog 过滤抽取指定条件的SQL语句</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_1"></a>适用场景</h3> 
<ol><li>适用于希望从mysql的binlog恢复数据。</li><li>并且希望快速抽取出自己关注的部分数据表，以及特定数据的SQL操作脚本。可以进行精准恢复。</li></ol> 
<h3><a id="_4"></a>使用须知</h3> 
<ol><li>Mysql开启了binlog日志功能，并确实记录了想要查找的SQL语句</li><li>本次使用到了 Linux系统的 grep命令 用于过滤并抽取目标sql脚本到新的文件（效率好高，近2百兆的日志文件瞬间完成过滤写入新文件）。windows 可以尝试安装 grep命令试试，本人没测试过。</li></ol> 
<h3><a id="_8"></a>开始</h3> 
<h4><a id="Mysqlbinlog_9"></a>获取Mysql的binlog文件</h4> 
<p>根据mysql的配置找到binlog文件</p> 
<blockquote> 
 <p>查找 binlog 文件位置，可以执行语句</p> 
 <pre><code class="prism language-mysql">SHOW VARIABLES LIKE 'log_%';
</code></pre> 
 <p>关注 字段： log_bin_basename 。后面的value是路径+最后的是binlog文件名，所以访问路径要去掉最后路径分隔符的那个字符串。<br> 例如：D:\mysql-5.6.20-winx64\mysql-5.6.20-winx64\data\mysql-bin<br> 实际binlog文件路径：D:\mysql-5.6.20-winx64\mysql-5.6.20-winx64\data<br> 结尾的myslq-bin 是binlog日志生成的文件名前缀。</p> 
</blockquote> 
<h4><a id="binlogSQL_20"></a>解析binlog文件，获取可读的SQL文件</h4> 
<p>使用命令 <code>mysqlbinlog</code>。只要windows或者Linux上安装过Mysql 命令行可识别此命令就可以用。</p> 
<pre><code class="prism language-shell"><span class="token comment"># 参数介绍</span>
inlog --base64-output<span class="token operator">=</span>decode-rows <span class="token parameter variable">-v</span> /全路径（如果执行命令时不跟binlog文件在一个目录下）/要解析的binlog文件名 --result-file<span class="token operator">=</span>结果sql脚本文件
<span class="token comment"># 例子:</span>
inlog --base64-output<span class="token operator">=</span>decode-rows <span class="token parameter variable">-v</span> /opt/data/mysql-bin.000118 --result-file<span class="token operator">=</span>000118.sql
</code></pre> 
<p>节选了一个update（相对其他操作内容更复杂）语句内容如下。<br> 忽略每行开头的<code>###</code> 符号和用<code>@列的顺序号</code>替代了列名,就是一个标准的 SQL语句，</p> 
<pre><code class="prism language-log">### UPDATE `testdb`.`test_table`
### WHERE
###   @1=614305
###   @2=182759
###   @3=182749
###   @4=6668
###   @5=1876
###   @6=NULL
###   @7=1668128408
###   @8=1
###   @9=0
### SET
###   @1=614305
###   @2=182759
###   @3=182749
###   @4=6668
###   @5=1876
###   @6=NULL
###   @7=1668136095
###   @8=2
###   @9=0
</code></pre> 
<h4><a id="grep_54"></a>grep命令简介</h4> 
<p>本次使用的 grep命令是在Linux环境上，所以把解析好的sql文件我上传到了Linux服务器进行后续操作</p> 
<blockquote> 
 <p>windows 安装 grep工具是否完全支持相同语法，以及性能如何我没测试过，有兴趣的小伙伴可以试试，评论解惑下<br> windows 有类似 grep 的 findstr 命令，但是语法不一样，我也没试过。</p> 
</blockquote> 
<p>grep 命令可以对一堆<strong>文本文件</strong>或管道符流转来的数据进行<strong>筛选（支持正则表达式）</strong>，并可以将结果输出到控制台或者<strong>写入文件</strong>里。<br> 加粗的3个地方是本次我们要用到的grep的地方</p> 
<pre><code class="prism language-shell"><span class="token comment"># 注意参数的大小写！</span>
<span class="token comment"># 注意参数的大小写！</span>
<span class="token comment"># 注意参数的大小写！</span>
<span class="token function">grep</span> <span class="token punctuation">[</span>-abcEFGhHilLnqrsvVwxy<span class="token punctuation">]</span><span class="token punctuation">[</span>-A<span class="token operator">&lt;</span>显示命中行之后的行数<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-B<span class="token operator">&lt;</span>显示命中行之前的行数<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-E<span class="token operator">&lt;</span>正则表达式<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>要被查找的文件<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&gt;</span>输出到的文件（没有路径就是当前命令所在目录） 
<span class="token comment"># 样例</span>
<span class="token function">grep</span> <span class="token parameter variable">-B</span> <span class="token number">4</span> <span class="token parameter variable">-A</span> <span class="token number">4</span>   <span class="token parameter variable">-E</span> <span class="token string">"(@2=182759|@2=581940|@2=582021)"</span>  mysql-bin.000118 <span class="token operator">&gt;</span> /opt/binlog_000118.txt
</code></pre> 
<p>解释：</p> 
<ol><li>查找 符合正则 -E “(@2=182759|@2=581940|@2=582021)”<br> @2=182759或@2=182759|或@2=182759 的所在行。</li><li>-B 4：命中所在行， 并查找命中行向上数的4行一起作为结果返回</li><li>-A 4：命中所在行 ，并输出向下数的4行 内容一起作为结果返回</li><li>mysql-bin.000118 ：被查找的文件。（示例由于命令是在跟这个文件所在文件夹下打的命令，如果不是同文件夹，需要打全路径或相对路径）</li><li> 
  <blockquote> 
   <p>/opt/binlog_000118.txt :把查找结果<strong>覆盖</strong>输出到 /opt/binlog_000118.txt 文件里（不需要提前生成该文件。）</p> 
  </blockquote> </li></ol> 
<blockquote> 
 <p>Tips：</p> 
 <ol><li>如果只是想先在控制台看看输出结果确认是否符合筛选预期，不想把结果写入文件。可以去掉 <code>&gt; /opt/binlog_000118.txt</code> 即可</li><li>如果不想覆盖结果，而是基于文件现有内容继续追加 使用 <code>&gt;&gt;</code> 替换文件前的符号<code>&gt;</code></li></ol> 
</blockquote> 
<p>实际执行效果</p> 
<ol><li>语句1观察要点：由于原文本含有 2行命中内容，命中了2次。2次命中结果中间用单独的一行<code>---</code>进行了分割</li><li>语句2观察要点：<code>-B 4</code>变为 <code>-B 5</code>。结果却变为一条了！至于原理。。。菜狗我也不懂，只是把现象跟大家说明下。如果相邻的命中结果 -A -B (或者-C 数字,命中行的前后多取 数字 行数，-C 4 等效于 -A 4 -B 4），前后相接了，比如一段文字共20行，-A -B 命中第一次命中包含了 1-4行，第二次命中只需要 命中5-任一行grep会自动合并结果为1条！而不是2条。<s>至于如何强拆为2条？我不会！</s> 欢迎读者评论赐教谢谢！</li></ol> 
<pre><code class="prism language-linxu"># 1.txt 内容是之前截取的update的SQL语句
# 语句1
[root@Master home]# grep  -B 4 -A 4 -E "(@2=182759|@2=581940|@2=582021)" 1.txt
### UPDATE `testdb`.`test_table`
### WHERE
###   @1=614305
###   @2=182759
###   @3=182749
###   @4=6668
###   @5=1876
###   @6=NULL
--
###   @8=1
###   @9=0
### SET
###   @1=614305
###   @2=182759
###   @3=182749
###   @4=6668
###   @5=1876
###   @6=NULL

# 语句2：跟语句1的区别 -B后面参数由4改为5了
[root@Master home]# grep -B 5 -A 4   -E "(@2=182759|@2=581940|@2=582021)" 1.txt
### UPDATE `testdb`.`test_table`
### WHERE
###   @1=614305
###   @2=182759
###   @3=182749
###   @4=6668
###   @5=1876
###   @6=NULL
###   @7=1668128408
###   @8=1
###   @9=0
### SET
###   @1=614305
###   @2=182759
###   @3=182749
###   @4=6668
###   @5=1876
###   @6=NULL

</code></pre> 
<blockquote> 
 <p>详细版可以百度搜索去学习，这里附带一个推荐讲解链接供学习<br> <a href="https://blog.csdn.net/zhangcongyi420/article/details/125577669">linux grep命令使用详解</a></p> 
</blockquote> 
<h4><a id="grep_137"></a>实操从grep抽取想要的内容到新的文件</h4> 
<p>已上面模拟的 Update 的sql脚本举例。</p> 
<h4><a id="__testdbtest_table2182759UPDATE_SQLUpdate_140"></a>场景： 抽取恢复数据表 <code>testdb</code>.<code>test_table</code>，@2=182759相关的UPDATE SQL脚本，恢复Update之前的数据。</h4> 
<p>思路梳理，首先确定最终目标是抽取以下内容( ### where 所在行之下，### SET 所在行之上部分），之后再去Excel或者其他文本工具处理就好说了。</p> 
<pre><code class="prism language-log">###   @1=614305
###   @2=182759
###   @3=182749
###   @4=6668
###   @5=1876
###   @6=NULL
###   @7=1668128408
###   @8=1
###   @9=0
</code></pre> 
<ol><li>先根据 UPDATE 锁定指定的数据库表并获取其下 10行数据 （对应本示例是到内容 <code>### @9=0</code> 这一行）</li></ol> 
<pre><code class="prism language-log">### UPDATE `testdb`.`test_table`
</code></pre> 
<pre><code class="prism language-linux"># 注意！需要对字符  ` 进行转义  
# 这里 -E 可以去掉，因为 里面压根没有正则。。。懒得删除了，不碍事的
grep -A 10  -E  "### UPDATE \`testdb\`.\`test_table\`" 1.txt &gt;step_1.txt
</code></pre> 
<ol start="2"><li>再筛选出 @2=182759 所在行，以及上1行和下7行的内容</li></ol> 
<pre><code class="prism language-linux"># 注意！需要对字符  ` 进行转义  
# 这里 -E 可以去掉，因为 里面压根没有正则。。。懒得删除了，不碍事的
grep -A 7 -B 1  -E  "@2=182759" step_1.txt &gt;step_2.txt
</code></pre> 
<ol start="3"><li>使用管道符完善脚本,管道符 <code>|</code> ,可以把管道符左边的数据内容作为右边的数据输入源头。</li></ol> 
<pre><code class="prism language-linux">grep -A 10  -E  "### UPDATE \`testdb\`.\`test_table\`" 1.txt  | grep -A 7 -B 1  -E  "@2=182759"  &gt;step_2.txt
</code></pre> 
<ol start="4"><li>根据需要，使用文本编辑器和EXCEL处理出最终想要的结果内容。<br> 使用文本编辑器批量替换点无用的 字符 比如<code>###</code> ；如果想分割结果集，可以借助<code>---</code>替换为想要的内容。</li></ol> 
<p><strong>-The End-</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41d6a6694b41082a66e493560d98a403/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CentOS环境下Minio的安装，并实现文件的上传</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ef892ae1b91ba077b736b8048c51079/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RFSoC应用笔记 - RF数据转换器 -22- API使用指南之配置DAC相关工作状态和中断相关函数使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>