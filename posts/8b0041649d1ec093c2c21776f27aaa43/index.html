<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CF793D Presents in Bankopolis/Namomo Spring Camp 每日一题 Week 1Day2 No Crossing - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CF793D Presents in Bankopolis/Namomo Spring Camp 每日一题 Week 1Day2 No Crossing" />
<meta property="og:description" content="Namomo Spring Camp 每日一题 Week 1Day2 No Crossing Problem Statement 一个有 n n n个点 m m m条边的有向图, 你需要找到恰好经过 k k k个点的最短路径, 要求每次选的边不能越过之前已经经过的节点. 即对于路径中 x → y x\to y x→y. 不存在以前经过的点 t t t使得三者编号满足 min ⁡ ( x , y ) ≤ t ≤ max ⁡ ( x , y ) \min(x,y)\leq t\leq \max(x,y) min(x,y)≤t≤max(x,y).
Solution 首先我们考虑选择一条边 x → y x\to y x→y. 如果 x &lt; y x&lt;y x&lt;y那么后续我们选择路径的时候不能经过点 k k k满足 k &lt; x k&lt;x k&lt;x的点, 如果 x &gt; y x&gt;y x&gt;y那么后续选择路径的时候不能经过点 k k k满足 k &gt; x k&gt;x k&gt;x的点." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8b0041649d1ec093c2c21776f27aaa43/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-28T12:26:06+08:00" />
<meta property="article:modified_time" content="2022-02-28T12:26:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CF793D Presents in Bankopolis/Namomo Spring Camp 每日一题 Week 1Day2 No Crossing</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Namomo_Spring_Camp__Week_1Day2_No_Crossing_0"></a>Namomo Spring Camp 每日一题 Week 1Day2 No Crossing</h3> 
<h4><a id="Problem_Statement_2"></a>Problem Statement</h4> 
<p>一个有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>个点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
      
        m 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>条边的有向图, 你需要找到恰好经过<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span>个点的最短路径, 要求每次选的边不能越过之前已经经过的节点. 即对于路径中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         → 
        
       
         y 
        
       
      
        x\to y 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span>. 不存在以前经过的点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         t 
        
       
      
        t 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord mathdefault">t</span></span></span></span></span>使得三者编号满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         min 
        
       
         ⁡ 
        
       
         ( 
        
       
         x 
        
       
         , 
        
       
         y 
        
       
         ) 
        
       
         ≤ 
        
       
         t 
        
       
         ≤ 
        
       
         max 
        
       
         ⁡ 
        
       
         ( 
        
       
         x 
        
       
         , 
        
       
         y 
        
       
         ) 
        
       
      
        \min(x,y)\leq t\leq \max(x,y) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.77194em; vertical-align: -0.13597em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mclose">)</span></span></span></span></span>.</p> 
<h4><a id="Solution_6"></a>Solution</h4> 
<p>首先我们考虑选择一条边<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         → 
        
       
         y 
        
       
      
        x\to y 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span>. 如果<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         &lt; 
        
       
         y 
        
       
      
        x&lt;y 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span>那么后续我们选择路径的时候不能经过点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span>满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         &lt; 
        
       
         x 
        
       
      
        k&lt;x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.73354em; vertical-align: -0.0391em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>的点, 如果<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         &gt; 
        
       
         y 
        
       
      
        x&gt;y 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span>那么后续选择路径的时候不能经过点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span>满足<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
         &gt; 
        
       
         x 
        
       
      
        k&gt;x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.73354em; vertical-align: -0.0391em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>的点.</p> 
<p>如果我们直接建图, 一开始我们能够经过<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         n 
        
       
      
        n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>上的任意节点, 然后没选择一条边就会减少可以到达的节点数目, 使得可以到达的节点减少, 并且我们可以知道可以到达节点一定是连续的.</p> 
<p>如果我们之间进行DP, 我们进行分类讨论来确定可以到达那些节点, 非常地麻烦.</p> 
<p>我们考虑反向建边, 我们建立反向边之后. 题意等价于我当前<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         → 
        
       
         y 
        
       
      
        x\to y 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span>后<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         ≤ 
        
       
         k 
        
       
         ≤ 
        
       
         y 
        
       
      
        x\leq k\leq y 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.77194em; vertical-align: -0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.83041em; vertical-align: -0.13597em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span>的点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         k 
        
       
      
        k 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span>都是不能够再次达到的. 这样就避免了分类讨论的问题.</p> 
<p>我们设<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
         
         
           i 
          
         
           , 
          
         
           v 
          
         
           , 
          
         
           l 
          
         
           , 
          
         
           r 
          
         
        
       
      
        f_{i,v,l,r} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.980548em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>表示选择<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         i 
        
       
      
        i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span>条边, 当前处于<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         v 
        
       
      
        v 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>点, 不可以再次到达<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         [ 
        
       
         l 
        
       
         , 
        
       
         r 
        
       
         ] 
        
       
      
        [l,r] 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mclose">]</span></span></span></span></span>这个区间内的点的最小花费.</p> 
<p>那么我们可以简单得得到一个转移方程: <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          f 
         
         
         
           i 
          
         
           + 
          
         
           1 
          
         
           , 
          
         
           T 
          
          
          
            o 
           
          
            v 
           
          
         
           , 
          
         
           min 
          
         
           ⁡ 
          
         
           { 
          
         
           l 
          
         
           , 
          
         
           T 
          
          
          
            o 
           
          
            v 
           
          
         
           } 
          
         
           , 
          
         
           max 
          
         
           ⁡ 
          
         
           { 
          
         
           r 
          
         
           , 
          
         
           T 
          
          
          
            o 
           
          
            v 
           
          
         
           } 
          
         
        
       
         = 
        
       
         min 
        
       
         ⁡ 
        
       
         { 
        
        
        
          f 
         
         
         
           i 
          
         
           , 
          
         
           v 
          
         
           , 
          
         
           l 
          
         
           , 
          
         
           r 
          
         
        
       
         + 
        
        
        
          W 
         
        
          v 
         
        
       
         } 
        
       
      
        f_{i+1,To_v,\min\{l,To_v\},\max\{r,To_v\}}=\min\{f_{i,v,l,r}+W_v\} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.04964em; vertical-align: -0.3552em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.5198em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.164543em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mop mtight">min</span><span class="mopen mtight">{<!-- --></span><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.164543em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mclose mtight">}</span><span class="mpunct mtight">,</span><span class="mop mtight">max</span><span class="mopen mtight">{<!-- --></span><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">r</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.164543em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mclose mtight">}</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3552em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.03611em; vertical-align: -0.286108em;"></span><span class="mop">min</span><span class="mopen">{<!-- --></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span>.</p> 
<p>时间复杂度<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         能 
        
       
         过 
        
       
         ) 
        
       
      
        O(能过) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">过</span><span class="mclose">)</span></span></span></span></span>.</p> 
<p>优化方式:</p> 
<ul><li>为了避免无用的状态, 我们可以用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          m 
         
        
          a 
         
        
          p 
         
        
       
         map 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span></span></span></span></span>或<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          u 
         
        
          n 
         
        
          o 
         
        
          r 
         
        
          d 
         
        
          e 
         
        
          r 
         
        
          e 
         
        
          d 
         
        
          _ 
         
        
          m 
         
        
          a 
         
        
          p 
         
        
       
         unordered\_map 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.00444em; vertical-align: -0.31em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord" style="margin-right: 0.02778em;">_</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span></span></span></span></span>直接去维护可以达到的状态.</li><li>如果我们事先对每一个节点的出边<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          u 
         
        
       
         u 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span></span></span></span></span>, 其出边<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ( 
         
        
          u 
         
        
          , 
         
        
          v 
         
        
          ) 
         
        
       
         (u,v) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span></span></span></span></span>按<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          v 
         
        
       
         v 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>排序后. 那么转移时候的可行边一定是一个前缀和一个后缀.</li><li>如果想用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          u 
         
        
          n 
         
        
          o 
         
        
          r 
         
        
          d 
         
        
          e 
         
        
          r 
         
        
          e 
         
        
          d 
         
        
          _ 
         
        
          m 
         
        
          a 
         
        
          p 
         
        
       
         unordered\_map 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.00444em; vertical-align: -0.31em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord" style="margin-right: 0.02778em;">_</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span></span></span></span></span>维护<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          D 
         
        
          P 
         
        
       
         DP 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span></span></span></span></span>值需要一个Hash建立一个双射区间<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          [ 
         
        
          l 
         
        
          , 
         
        
          r 
         
        
          ] 
         
        
       
         [l,r] 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mclose">]</span></span></span></span></span>映射到一个整数. 这里我们不妨用下列映射<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          [ 
         
        
          l 
         
        
          , 
         
        
          r 
         
        
          ] 
         
        
          → 
         
        
          l 
         
        
          − 
         
        
          1 
         
        
          + 
         
        
          r 
         
        
          × 
         
        
          n 
         
        
       
         [l,r]\to l-1+r\times n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>那么<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          K 
         
        
          e 
         
        
          y 
         
        
          → 
         
        
          [ 
         
        
          K 
         
        
          e 
         
        
          y 
         
         
         
         
         
           m 
          
         
           o 
          
         
           d 
          
           
        
          N 
         
        
          + 
         
        
          1 
         
        
          , 
         
        
          K 
         
        
          e 
         
        
          y 
         
        
          / 
         
        
          N 
         
        
          ] 
         
        
       
         Key\to[Key\mod N+1,Key/N] 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right: 0.666667em;"></span></span><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mclose">]</span></span></span></span></span>.</li></ul> 
<h4><a id="Code_28"></a>Code</h4> 
<pre><code class="prism language-c++"># define Fast_IO std::ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
# include "unordered_map"
# include "algorithm"
# include "iostream"
# include "cstdlib"
# include "cstring"
# include "cstdio"
# include "vector"
# include "bitset"
# include "queue"
# include "cmath"
# include "map"
# include "set"

using namespace std;

const int maxm=1e2+10;
const int INF=1&lt;&lt;30;

int N,K,M;
vector&lt;pair&lt;int,int&gt; &gt; Edge[maxm];
unordered_map&lt;int,int&gt; DP1[maxm],DP2[maxm];

int Hash(pair&lt;int,int&gt; Now){
	return Now.first-1+Now.second*N;
}
pair&lt;int,int&gt; Inv_Hash(int H){
	return {H%N+1,H/N};
}

int main(){
	int i,j,k,A,B,C,L,R,Cost,W,To,Ans;
	pair&lt;int,int&gt; Interval,Now_Edge;
	scanf("%d%d%d",&amp;N,&amp;K,&amp;M);
	if(K==0 || K==1){
		printf("0");
		return 0;
	}
	for(i=1;i&lt;=M;i++){
		scanf("%d%d%d",&amp;A,&amp;B,&amp;C);
		Edge[B].push_back({A,C});
		DP2[A][Hash({min(A,B),max(A,B)})]=DP2[A][Hash({min(A,B),max(A,B)})]==0?C:min(C,DP2[A][Hash({min(A,B),max(A,B)})]);
	}
	for(i=1;i&lt;=N;i++) sort(Edge[i].begin(),Edge[i].end());
	/*for(i=1;i&lt;=N;i++){
		for(auto To:Edge[i]){
			printf("Edge:%d-&gt;%d:%d\n",i,To.first,To.second);
		}
	}*/
//	printf("%d %d",Inv_Hash(Hash({1,2})).first,Inv_Hash(Hash({1,2})).second);
	for(i=1;i&lt;K-1;i++){
		for(j=1;j&lt;=N;j++){
			swap(DP2[j],DP1[j]);
			DP2[j].clear();
		}
		for(j=1;j&lt;=N;j++){
			for(auto Now:DP1[j]){
				Interval=Inv_Hash(Now.first);
				L=Interval.first,R=Interval.second;
				Cost=Now.second;
				for(k=0;k&lt;Edge[j].size();k++){
					Now_Edge=Edge[j][k];
					To=Now_Edge.first,W=Now_Edge.second;
					if(To&gt;=L &amp;&amp; To&lt;=R) continue;
					DP2[To][Hash({min(L,To),max(R,To)})]=DP2[To][Hash({min(L,To),max(R,To)})]==0?Cost+W:min(DP2[To][Hash({min(L,To),max(R,To)})],Cost+W);
				}
			}
		}
	}
	Ans=INF;
	for(i=1;i&lt;=N;i++){
		for(auto Now:DP2[i]){
			Ans=min(Ans,Now.second);
		}
	}
	printf("%d",Ans==INF?-1:Ans);
	return 0;
}
</code></pre> 
<h4><a id="Link_111"></a>Link</h4> 
<p>Link1: <a href="http://oj.daimayuan.top/course/10/problem/437" rel="nofollow">Daimayuan Online Judge 437</a>.</p> 
<p>Link2: <a href="https://codeforces.com/contest/793/problem/D" rel="nofollow">CF793D Presents in Bankopolis</a>.</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/658daaa68813e423a2edc8bef1bf51a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nodejs使用exceljs批量导出图片到excel并将excel下载到本地</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bbd63ef26007cdc07d1475ea3a9171f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux Ubuntu查看IP信息的两种方式Ubuntu中检查你的 IP 地址</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>