<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>COM三大接口:IUnknown、IClassFactory、IDispatch - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="COM三大接口:IUnknown、IClassFactory、IDispatch" />
<meta property="og:description" content="转载自：http://blog.sina.com.cn/s/blog_86d10dc701014m2v.html
(1)COM组件有三个最基本的接口类，分别是IUnknown、IClassFactory、IDispatch。
（1、1）
COM规范规定任何组件、任何接口都必须从IUnknown继承，IUnknown包含三个函数，分别是 QueryInterface、AddRef、Release。这三个函数是无比重要的，而且它们的排列顺序也是不可改变的。
QueryInterface用于查询组件实现的其它接口，说白了也就是看看这个组件的父类中还有哪些接口类，AddRef用于增加引用计数，Release用于减少引用计数。引用计数也是COM中的一个非常重要的概念。大体上简单的说来可以这么理解，COM组件是个DLL，当客户程序要用它时就要把它装到内存里。另一方面，一个组件也不是只给你一个人用的，可能会有很多个程序同时都要用到它。但实际上DLL只装载了一次，即内存中只有一个COM组件，那COM组件由谁来释放？由客户程序吗？不可能，因为如果你释放了组件，那别人怎么用，所以只能由COM组件自己来负责。所以出现了引用计数的概念，COM维持一个计数，记录当前有多少人在用它，每多一次调用计数就加一，少一个客户用它就减一，当最后一个客户释放它的时侯，COM知道已经没有人用它了，它的使用已经结束了，那它就把它自己给释放了。
引用计数是COM编程里非常容易出错的一个地方，但所幸VC的各种各样的类库里已经基本上把AddRef的调用给隐含了，在我的印象里，我编程的时侯还从来没有调用过AddRef，我们只需在适当的时侯调用Release。至少有两个时侯要记住调用Release，第一个是调用了 QueryInterface以后，第二个是调用了任何得到一个接口的指针的函数以后，记住多查MSDN 以确定某个函数内部是否调用了AddRef，如果是的话那调用Release的责任就要归你了。 IUnknown的这三个函数的实现非常规范但也非常烦琐，容易出错，所幸的事我们可能永远也不需要自己来实现它们。
IUnknown{public:BEGIN_INTERFACEvirtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid,void __RPC_FAR *__RPC_FAR *ppvObject) = 0;virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;virtual ULONG STDMETHODCALLTYPE Release( void) = 0;};（1、2）
IClassFactory的作用是创建COM组件。我们已经知道COM组件实际上就是一个类，那我们平常是怎么实例化一个类对象的？是用&#39;new’命令!很简单吧，COM组件也一样如此。但是谁来new它呢？不可能是客户程序，因为客户程序不可能知道组件的类名字，如果客户知道组件的类名字那组件的可重用性就要打个大大的折扣了，事实上客户程序只不过知道一个代表着组件的128位的数字串而已，这个等会再介绍。所以客户无法自己创建组件，而且考虑一下，如果组件是在远程的机器上，你还能new出一个对象吗？所以创建组件的责任交给了一个单独的对象，这个对象就是类厂。每个组件都必须有一个与之相关的类厂，这个类厂知道怎么样创建组件，当客户请求一个组件对象的实例时，实际上这个请求交给了类厂，由类厂创建组件实例，然后把实例指针交给客户程序。
这个过程在跨进程及远程创建组件时特别有用，因为这时就不是一个简单的new操作就可以的了，它必须要经过调度，而这些复杂的操作都交给类厂对象去做了。IClassFactory最重要的一个函数就是CreateInstance，顾名思议就是创建组件实例，一般情况下我们不会直接调用它，API函数都为我们封装好它了，只有某些特殊情况下才会由我们自己来调用它，这也是VC编写COM组件的好处，使我们有了更多的控制机会，而VB给我们这样的机会则是太少太少了。
IClassFactory : public IUnknown{public:virtual HRESULT STDMETHODCALLTYPE CreateInstance( IUnknown *pUnkOuter,REFIID riid,void **ppvObject) = 0;virtual HRESULT STDMETHODCALLTYPE LockServer( BOOL fLock) = 0;};（1、3）IDispatch叫做调度接口。它的作用何在呢？这个世上除了C&#43;&#43;还有很多别的语言，比如VB、 VJ、VBScript、JavaScript等等。可以这么说，如果这世上没有这么多乱七八糟的语言，那就不会有IDispatch。:-)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/66e212ce964e319e7fa7dadfb016a917/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-07-17T14:46:50+08:00" />
<meta property="article:modified_time" content="2012-07-17T14:46:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">COM三大接口:IUnknown、IClassFactory、IDispatch</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p>转载自：<a href="http://blog.sina.com.cn/s/blog_86d10dc701014m2v.html" rel="nofollow">http://blog.sina.com.cn/s/blog_86d10dc701014m2v.html</a></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <strong>(1)COM<span style="font-family:宋体">组件有三个最基本的接口类，<span style="color:red">分别是</span></span><span style="color:red">IUnknown</span><span style="font-family:宋体; color:red">、</span><span style="color:red">IClassFactory</span><span style="font-family:宋体; color:red">、</span><span style="color:red">IDispatch</span><span style="font-family:宋体; color:red"><span style="font-family:宋体; color:red">。</span></span></strong></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> （1、1）</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px">  <wbr></wbr>COM<span style="font-family:宋体">规范规定<span style="color:red">任何组件、任何接口都必须从</span></span><span style="color:red">IUnknown</span><span style="font-family:宋体; color:red">继承</span><span style="font-family:宋体">，</span>IUnknown<span style="font-family:宋体">包含三个函数，分别是</span> <wbr></wbr><span style="color:red">QueryInterface</span><span style="font-family:宋体; color:red">、</span><span style="color:red">AddRef</span><span style="font-family:宋体; color:red">、</span><span style="color:red">Release</span><span style="font-family:宋体; color:red">。</span><span style="font-family:宋体">这三个函数是无比重要的，而且它们的排列顺序也是不可改变的。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> QueryInterface<span style="font-family:宋体">用于查询组件实现的其它接口，说白了也就是<span style="color:red">看看这个组件的父类中还有哪些接口类</span>，</span>AddRef<span style="font-family:宋体">用于增加引用计数，</span>Release<span style="font-family:宋体">用于减少引用计数。引用计数也是</span>COM<span style="font-family:宋体">中的一个非常重要的概念。大体上简单的说来可以这么理解，</span>COM<span style="font-family:宋体">组件是个</span>DLL<span style="font-family:宋体">，当客户程序要用它时就要把它装到内存里。另一方面，一个组件也不是只给你一个人用的，可能会有很多个程序同时都要用到它。但实际上</span>DLL<span style="font-family:宋体">只装载了一次，即<span style="color:#990000">内存中只有一个</span></span><span style="color:#990000">COM</span><span style="font-family:宋体"><span style="color:#990000">组件</span>，那</span>COM<span style="font-family:宋体">组件由<span style="color:red">谁来释放</span>？由客户程序吗？不可能，因为如果你释放了组件，那别人怎么用，所以只能由</span><span style="color:red">COM</span><span style="font-family:宋体; color:red">组件自己来负责</span><span style="font-family:宋体">。所以出现了引用计数的概念，</span>COM<span style="font-family:宋体">维持一个计数，记录当前有多少人在用它，每多一次调用计数就加一，少一个客户用它就减一，当最后一个客户释放它的时侯，</span>COM<span style="font-family:宋体">知道已经没有人用它了，它的使用已经结束了，那它就把它自己给释放了。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">引用计数是</span>COM<span style="font-family:宋体">编程里非常容易出错的一个地方，但所幸</span>VC<span style="font-family:宋体">的各种各样的类库里已经基本上把</span>AddRef<span style="font-family:宋体">的调用给隐含了，在我的印象里，我编程的时侯还从来没有调用过</span>AddRef<span style="font-family:宋体">，我们只需在适当的时侯调用</span>Release<span style="font-family:宋体">。至少有两个时侯要记住调用</span>Release<span style="font-family:宋体">，第一个是调用了</span> <wbr></wbr>QueryInterface<span style="font-family:宋体">以后，第二个是调用了任何得到一个接口的指针的函数以后，记住多查</span>MSDN <wbr></wbr><span style="font-family:宋体">以确定某个函数内部是否调用了</span>AddRef<span style="font-family:宋体">，如果是的话那调用</span>Release<span style="font-family:宋体">的责任就要归你了。</span> <wbr></wbr>IUnknown<span style="font-family:宋体">的这三个函数的实现非常规范但也非常烦琐，容易出错，所幸的事我们可能永远也不需要自己来实现它们。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> </p> 
<pre><code class="language-cpp">IUnknown
        {
        public:
            BEGIN_INTERFACE
            virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
                REFIID riid,
                void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
            
            virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;
            
            virtual ULONG STDMETHODCALLTYPE Release( void) = 0;
     
        };
</code></pre> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <br>  </p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> （1、2）</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="color:red"><span style="color:red"></span>IClassFactory</span><span style="font-family:宋体; color:red">的作用是创建</span><span style="color:red">COM</span><span style="font-family:宋体; color:red">组件</span><span style="font-family:宋体">。我们已经知道</span><span style="color:red">COM</span><span style="font-family:宋体; color:red">组件实际上就是一个类</span><span style="font-family:宋体">，那我们平常是怎么实例化一个类对象的？是用</span>'new<span style="font-family:宋体">’命令</span>!<span style="font-family:宋体">很简单吧，</span>COM<span style="font-family:宋体">组件也一样如此。但是谁来</span>new<span style="font-family:宋体">它呢？不可能是客户程序，因为客户程序不可能知道组件的类名字，如果客户知道组件的类名字那组件的可重用性就要打个大大的折扣了，事实上客户程序只不过知道一个代表着组件的</span>128<span style="font-family:宋体">位的数字串而已，这个等会再介绍。所以客户无法自己创建组件，而且考虑一下，<span style="color:#cc0000">如果组件是在远程的机器上，你还能</span></span><span style="color:#cc0000">new</span><span style="font-family:宋体"><span style="color:#cc0000">出一个对象吗</span>？所以创建组件的责任交给了一个单独的对象，这个对象就是<span style="color:red">类厂</span>。<span style="color:red">每个组件都必须有一个与之相关的类厂</span>，这个类厂知道怎么样创建组件，当客户请求一个组件对象的实例时，实际上这个请求交给了类厂，<span style="color:#cc0000">由类厂创建组件实例，然后把实例指针交给客户程序</span>。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">这个过程在跨进程及远程创建组件时特别有用，因为这时就不是一个简单的</span>new<span style="font-family:宋体">操作就可以的了，<span style="color:#cc0000">它必须要经过调度</span>，而这些复杂的操作都交给类厂对象去做了。</span>IClassFactory<span style="font-family:宋体">最重要的一个函数就是</span><span style="color:red">CreateInstance</span><span style="font-family:宋体">，顾名思议就是创建组件实例，一般情况下我们不会直接调用它，</span>API<span style="font-family:宋体">函数都为我们封装好它了，只有某些特殊情况下才会由我们自己来调用它，这也是</span>VC<span style="font-family:宋体">编写</span>COM<span style="font-family:宋体">组件的好处，使我们有了更多的控制机会，而</span>VB<span style="font-family:宋体">给我们这样的机会则是太少太少了。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px">  </p> 
<pre><code class="language-cpp">IClassFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            IUnknown *pUnkOuter,
            REFIID riid,
            void **ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockServer( 
            BOOL fLock) = 0;
        
    };
</code></pre> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <br>  </p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="color:red">（1、3）IDispatch</span><span style="font-family:宋体; color:red">叫做调度接口</span><span style="font-family:宋体">。它的作用何在呢？这个世上除了</span>C++<span style="font-family:宋体">还有很多别的语言，比如</span>VB<span style="font-family:宋体">、</span> <wbr></wbr>VJ<span style="font-family:宋体">、</span>VBScript<span style="font-family:宋体">、</span>JavaScript<span style="font-family:宋体">等等。可以这么说，如果这世上没有这么多乱七八糟的语言，那就不会有</span>IDispatch<span style="font-family:宋体">。</span>:-)</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px">  <wbr></wbr><span style="font-family:宋体">我们知道</span><span style="color:red">COM</span><span style="font-family:宋体; color:red">组件是</span><span style="color:red">C++</span><span style="font-family:宋体; color:red">类，是靠虚函数表来调用函数的</span><span style="font-family:宋体">，对于</span>VC<span style="font-family:宋体">来说毫无问题，这本来就是针对</span>C++<span style="font-family:宋体">而设计的，<span style="color:#990000">以前</span></span><span style="color:#990000">VB<span style="font-family:宋体">不行，现在</span>VB<span style="font-family:宋体">也可以用指针了，也可以通过</span>VTable<span style="font-family:宋体">来调用函数了，</span>VJ</span><span style="font-family:宋体"><span style="color:#990000">也可以，但还是有些语言不行，那就是脚本语言</span>，典型的如</span> <wbr></wbr>VBScript<span style="font-family:宋体">、</span>JavaScript<span style="font-family:宋体">。<span style="color:#cc0000">不行的原因在于它们并不支持指针，连指针都不能用还怎么用多态性啊，还怎么调这些虚函数</span>啊。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">唉，没办法，也不能置这些脚本语言于不顾吧，现在网页上用的都是这些脚本语言，<span style="color:#006600">而分布式应用也是</span></span><span style="color:#006600">COM</span><span style="font-family:宋体"><span style="color:#006600">组件的一个主要市场</span>，它不得不被这些脚本语言所调用，既然虚函数表的方式行不通，我们只能另寻他法了。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">时势造英雄，</span>IDispatch<span style="font-family:宋体">应运而生。</span>:-) <wbr></wbr><span style="font-family:宋体">调度接口把<span style="color:red">每一个函数每一个属性都编上号</span>，<span style="color:#990000">客户程序要调用这些函数属性的时侯就把这些编号传给</span></span><span style="color:#990000">IDispatch<span style="font-family:宋体">接口就行了，</span>IDispatch</span><span style="font-family:宋体"><span style="color:#990000">再根据这些编号调用相应的函数</span>，仅此而已。当然实际的过程远比这复杂，仅给一个编号就能让别人知道怎么调用一个函数那不是天方夜潭吗，你总得让别人知道你要调用的函数要带什么参数，参数类型什么以及返回什么东西吧，而要以一种统一的方式来处理这些问题是件很头疼的事。</span><span style="color:red">IDispatch</span><span style="font-family:宋体; color:red">接口的主要函数是</span><span style="color:red">Invoke</span><span style="font-family:宋体">，客户程序都调用它，然后</span>Invoke<span style="font-family:宋体">再调用相应的函数，如果看一看</span>MS<span style="font-family:宋体">的类库里实现</span> <wbr></wbr>Invoke<span style="font-family:宋体">的代码就会惊叹它实现的复杂了，因为你必须考虑各种参数类型的情况，所幸我们不需要自己来做这件事，而且可能永远也没这样的机会。</span>:-)</p> 
<p> </p> 
<pre><code class="language-cpp">IDispatch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount( 
            UINT *pctinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
            UINT iTInfo,
            LCID lcid,
            ITypeInfo **ppTInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames( 
            REFIID riid,
            LPOLESTR *rgszNames,
            UINT cNames,
            LCID lcid,
            DISPID *rgDispId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invoke( 
            DISPID dispIdMember,
            REFIID riid,
            LCID lcid,
            WORD wFlags,
            DISPPARAMS *pDispParams,
            VARIANT *pVarResult,
            EXCEPINFO *pExcepInfo,
            UINT *puArgErr) = 0;
        
    };
</code></pre> 
<p><br> </p> 
<p> </p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <strong><strong></strong>(2) dispinterface<span style="font-family:宋体">接口、</span>Dual<span style="font-family:宋体">接口以及</span>Custom<span style="font-family:宋体">接口</span></strong></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">这一小节放在这里似乎不太合适，因为这是在</span>ATL<span style="font-family:宋体">编程时用到的术语。我在这里主要是想谈一下<span style="color:#cc0000">自动化接口</span>的好处及缺点，用这三个术语来解释可能会更好一些，而且以后迟早会遇上它们，我将以一种通俗的方式来解释它们，可能并非那么精确，就好象用伪代码来描述算法一样<span style="font-family:宋体">。</span>-:)</span></p> 
<p><span style="font-family:宋体"></span> </p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="color:#990000"><span style="font-family:宋体">所谓的自动化接口就是用</span>IDispatch</span><span style="font-family:宋体"><span style="color:#990000">实现的接口</span>。我们已经讲解过</span>IDispatch<span style="font-family:宋体">的作用了，它的好处就是脚本语言象</span>VBScript<span style="font-family:宋体">、</span> <wbr></wbr>JavaScript<span style="font-family:宋体">也能用</span>COM<span style="font-family:宋体">组件了，从而基本上做到了与语言无关。</span><span style="font-family:宋体">它的缺点主要有两个：</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">（2、1）第一个就是速度慢效率低。这是显而易见的，通过虚函数表一下子就可以调用函数了，而通过</span>Invoke<span style="font-family:宋体">则等于中间转了道手续，尤其是需要把函数参数转换成一种规范的格式才去调用函数，耽误了很多时间。所以一般若非是迫不得已我们都想用</span>VTable<span style="font-family:宋体">的方式调用函数以获得高效率。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">（2、2）<span style="color:#990000">第二个缺点就是只能使用规定好的所谓的自动化数据类型</span>。如果不用</span>IDispatch<span style="font-family:宋体">我们可以想用什么数据类型就用什么类型，</span>VC<span style="font-family:宋体">会自动给我们生成相应的调度代码。而用自动化接口就不行了，因为</span>Invoke<span style="font-family:宋体">的实现代码是</span>VC<span style="font-family:宋体">事先写好的，而它不能事先预料到我们要用到的所有类型，它只能根据一些常用的数据类型来写它的处理代码，而且它也要考虑不同语言之间的数据类型转换问题。所以</span><span style="color:#660000">VC</span><span style="font-family:宋体"><span style="color:#660000">自动化接口生成的调度代码只适用于它所规定好的那些数据类型</span>，当然这些数据类型已经足够丰富了，但不能满足自定义数据结构的要求。你也可以自己写调度代码来处理你的自定义数据结构，但这并不是一件容易的事。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">考虑到</span>IDispatch<span style="font-family:宋体">的种种缺点</span>(<span style="font-family:宋体">它还有一个缺点，就是使用麻烦，</span>:-) )<span style="font-family:宋体">现在一般都<span style="color:#990000">推荐写双接口组件</span>，称为</span><span style="color:red">dual</span><span style="font-family:宋体; color:red">接口，实际上就是从</span><span style="color:red">IDispatch</span><span style="font-family:宋体; color:red">继承的接口</span><span style="font-family:宋体">。我们知道任何接口都必须从</span> <wbr></wbr>IUnknown<span style="font-family:宋体">继承，</span>IDispatch<span style="font-family:宋体">接口也不例外。那从</span>IDispatch<span style="font-family:宋体">继承的接口实际上就等于有两个基类，一个是</span>IUnknown<span style="font-family:宋体">，一个是</span>IDispatch<span style="font-family:宋体">，所以它可以以两种方式来调用组件，<span style="color:#cc0000">可以通过</span></span><span style="color:#cc0000"> <wbr></wbr>IUnknown<span style="font-family:宋体">用虚函数表的方式调用接口方法，也可以通过</span>IDispatch::Invoke</span><span style="font-family:宋体"><span style="color:#cc0000">自动化调度来调用</span>。这就有了很大的灵活性，这个组件既可以用于</span>C++<span style="font-family:宋体">的环境也可以用于脚本语言中，同时满足了各方面的需要。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">相对比的，</span><span style="color:red">dispinterface</span><span style="font-family:宋体; color:red">是一种纯粹的自动化接口</span><span style="font-family:宋体">，可以简单的就把它看作是</span>IDispatch<span style="font-family:宋体">接口</span> <wbr></wbr>(<span style="font-family:宋体">虽然它实际上不是的</span>)<span style="font-family:宋体">，这种接口就只能通过自动化的方式来调用，</span><span style="color:#006600">COM</span><span style="font-family:宋体"><span style="color:#006600">组件的事件</span>一般都用的是这种形式的接口。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="color:red">Custom</span><span style="font-family:宋体; color:red">接口就是从</span><span style="color:red">IUnknown</span><span style="font-family:宋体; color:red">接口派生的类</span><span style="font-family:宋体">，显然它就<span style="color:red">只能用虚函数表的方式</span>来调用接口了</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <strong><strong></strong>(3) COM<span style="font-family:宋体">组件种类</span></strong></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体"><span style="font-family:宋体"></span>有三种，<span style="color:red">进程内</span>、<span style="color:red">本地</span>、<span style="color:red">远程</span>。对于</span><span style="font-family:宋体; color:red">后两者情况必须调度</span><span style="font-family:宋体">接口指针及函数参数。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> COM<span style="font-family:宋体">是一个</span>DLL<span style="font-family:宋体">，它有三种运行模式。它可以是进程内的，即和调用者在同一个进程内，也可以和调用者在同一个机器上但在不同的进程内，还可以根本就和调用者在两台机器上。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">这里有一个根本点需要牢记，就是</span>COM<span style="font-family:宋体">组件它只是一个</span>DLL<span style="font-family:宋体">，它自己是运行不起来的，必须有一个进程象父亲般照顾它才行，即</span>COM<span style="font-family:宋体">组件必须在一个进程内</span>.<span style="font-family:宋体">那谁充当看护人的责任呢？先说说调度的问题。调度是个复杂的问题，以我的知识还讲不清楚这个问题，我只是一般性的谈谈几个最基本的概念。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">（3、1）我们知道对于</span>WIN32<span style="font-family:宋体">程序，每个进程都拥有</span>4GB<span style="font-family:宋体">的虚拟地址空间，每个进程都有其各自的编址，同一个数据块在不同的进程里的编址很可能就是不一样的，所以存在着进程间的地址转换问题。这就是调度问题。对于本地和远程进程来说，</span><span style="color:#990000">DLL <wbr></wbr></span><span style="font-family:宋体"><span style="color:#990000">和客户程序在不同的编址空间</span>，<span style="color:#cc0000">所以要传递接口指针到客户程序必须要经过调度。</span></span><span style="color:#cc0000">Windows <wbr></wbr></span><span style="font-family:宋体"><span style="color:#cc0000">已经提供了现成的调度函数，就不需要我们自己来做这个复杂的事情了</span>。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">（3、2）对远程组件来说函数的参数传递是另外一种调度。</span>DCOM<span style="font-family:宋体">是以</span>RPC<span style="font-family:宋体">为基础的，<span style="color:#990000">要在网络间传递数据必须遵守标准的网上数据传输协议，数据传递前要先打包，传递到目的地后要解包，这个过程就是调度，这个过程很复杂，不过</span></span><span style="color:#990000">Windows<span style="font-family:宋体">已经把一切都给我们做好了，一般情况下我们不需要自己来编写调度</span>DLL</span><span style="font-family:宋体"><span style="font-family:宋体">。</span></span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">我们刚说过一个</span>COM<span style="font-family:宋体">组件必须在一个进程内。<span style="color:#990000">对于本地模式的组件一般是以</span></span><span style="color:#990000">EXE</span><span style="font-family:宋体"><span style="color:#990000">的形式出现，所以它本身就已经是一个进程</span>。<span style="color:#cc0000">对于远程</span></span><span style="color:#cc0000">DLL</span><span style="font-family:宋体"><span style="color:#cc0000">，我们必须找一个进程，这个进程必须包含了调度代码以实现基本的调度</span>。这个进程就是</span><span style="color:red">dllhost.exe</span><span style="font-family:宋体">。这是</span>COM<span style="font-family:宋体">默认的</span>DLL<span style="font-family:宋体">代理。实际上在分布式应用中，我们应该用</span><span style="color:red">MTS</span><span style="font-family:宋体">来作为</span>DLL<span style="font-family:宋体">代理，因为</span>MTS<span style="font-family:宋体">有着很强大的功能，是专门的用于管理分布式</span>DLL<span style="font-family:宋体">组件的工具。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">调度离我们很近又似乎很远，我们编程时很少关注到它，这也是</span>COM<span style="font-family:宋体">的一个优点之一，既平台无关性，无论你是远程的、本地的还是进程内的，编程是一样的，一切细节都由</span>COM<span style="font-family:宋体">自己处理好了，所以我们也不用深究这个问题，只要有个概念就可以了，当然如果你对调度有自己特殊的要求就需要深入了解调度的整个过程了，这里推荐一本<span style="color:red">《</span></span><span style="color:red">COM+</span><span style="font-family:宋体; color:red">技术内幕》，</span><span style="font-family:宋体">这绝对是一本讲调度的好书。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <strong><strong></strong>(4) COM<span style="font-family:宋体">组件的核心是</span>IDL<span style="font-family:宋体">。</span></strong></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">我们希望软件是一块块拼装出来的，但不可能是没有规定的胡乱拼接，总是要遵守一定的标准，各个模块之间如何才能亲密无间的合作，必须要事先共同制订好它们之间交互的规范，这个规范就是接口。我们知道接口实际上都是纯虚类</span><span style="font-family:宋体; color:red">(#add 抽象类,纯虚类不知哪个sb提出来的,搞不明白还瞎jb出概念</span><span style="font-family:宋体">)，它里面定义好了很多的纯虚函数，等着某个组件去实现它，这个接口就是两个完全不相关的模块能够组合在一起的关键试想一下如果我们是一个应用软件厂商，我们的软件中需要用到某个模块，我们没有时间自己开发，所以我们想到市场上找一找看有没有这样的模块，我们怎么去找呢？也许我们需要的这个模块在业界已经有了标准，已经有人制订好了标准的接口，有很多组件工具厂商已经在自己的组件中实现了这个接口，那我们寻找的目标就是这些已经实现了接口的组件，我们不关心组件从哪来，它有什么其它的功能，我们只关心它是否很好的实现了我们制订好的接口。这种接口可能是业界的标准，也可能只是你和几个厂商之间内部制订的协议，但总之它是一个标准，是你的软件和别人的模块能够组合在一起的基础，是</span>COM<span style="font-family:宋体">组件通信的标准。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> COM<span style="font-family:宋体">具有语言无关性，它可以用任何语言编写，也可以在任何语言平台上被调用。但至今为止我们一直是以</span>C++<span style="font-family:宋体">的环境中谈</span>COM<span style="font-family:宋体">，那它的语言无关性是怎么体现出来的呢？或者换句话说，我们怎样才能以语言无关的方式来定义接口呢？前面我们是直接用纯虚类的方式定义的，但显然是不行的，除了</span>C++<span style="font-family:宋体">谁还认它呢？<span style="color:red">正是出于这种考虑，微软决定采用</span></span><span style="color:red">IDL</span><span style="font-family:宋体; color:red">来定义接口</span><span style="font-family:宋体">。说白了，</span>IDL<span style="font-family:宋体">实际上就是一种大家都认识的语言，用它来定义接口，不论放到哪个语言平台上都认识它。我们可以想象一下理想的标准的组件模式，我们总是从</span>IDL<span style="font-family:宋体">开始，先用</span>IDL<span style="font-family:宋体">制订好各个接口，然后把实现接口的任务分配不同的人，有的人可能善长用</span>VC<span style="font-family:宋体">，有的人可能善长用</span>VB<span style="font-family:宋体">，这没关系，作为项目负责人我不关心这些，我只关心你把最终的</span>DLL <wbr></wbr><span style="font-family:宋体">拿给我。这是一种多么好的开发模式，可以用任何语言来开发，也可以用任何语言来欣赏你的开发成果。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <strong><strong></strong>(5) COM<span style="font-family:宋体">组件的运行机制，即</span>COM<span style="font-family:宋体">是怎么跑起来的。</span></strong></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">这部分我们将构造一个创建</span>COM<span style="font-family:宋体">组件的最小框架结构，然后看一看其内部处理流程是怎样的</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> IUnknown *pUnk=NULL;</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> IObject *pObject=NULL;</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> CoInitialize(NULL);</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> CoCreateInstance(CLSID_Object, CLSCTX_INPROC_SERVER, NULL, IID_IUnknown, (void**)&amp;pUnk);</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> pUnk-&gt;QueryInterface(IID_IOjbect, (void**)&amp;pObject);</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> pUnk-&gt;Release();</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> pObject-&gt;Func();</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> pObject-&gt;Release();</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> CoUninitialize();</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">这就是一个典型的创建</span>COM<span style="font-family:宋体">组件的框架，不过我的兴趣在</span>CoCreateInstance<span style="font-family:宋体">身上，让我们来看看它内部做了一些什么事情。以下是它内部实现的一个伪代码</span>:</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> CoCreateInstance(....)</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> {<!-- --></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> .......</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> IClassFactory *pClassFactory=NULL;</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="color:red">CoGetClassObject</span>(CLSID_Object, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **)&amp;pClassFactory);</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> pClassFactory-&gt;<span style="color:red">CreateInstance</span>(NULL, IID_IUnknown, (void**)&amp;pUnk);</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> pClassFactory-&gt;Release();</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> ........</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> }</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">这段话的意思就是先得到类厂对象，再通过类厂创建组件从而得到</span>IUnknown<span style="font-family:宋体">指针。继续深入一步，看看</span>CoGetClassObject<span style="font-family:宋体">的内部伪码：</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px">  <wbr></wbr></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> CoGetClassObject(.....)</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> {<!-- --></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> //<span style="font-family:宋体">通过查注册表</span>CLSID_Object<span style="font-family:宋体">，得知组件</span>DLL<span style="font-family:宋体">的位置、文件名</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> //<span style="font-family:宋体">装入</span>DLL<span style="font-family:宋体">库</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> //<span style="font-family:宋体">使用函数</span>GetProcAddress(...)<span style="font-family:宋体">得到</span>DLL<span style="font-family:宋体">库中函数</span>DllGetClassObject<span style="font-family:宋体">的函数指针。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> //<span style="font-family:宋体">调用</span>DllGetClassObject</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> }</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> DllGetClassObject<span style="font-family:宋体">是干什么的，它是用来获得类厂对象的。只有先得到类厂才能去创建组件</span>.</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <span style="font-family:宋体">下面是</span>DllGetClassObject<span style="font-family:宋体">的伪码：</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> DllGetClassObject(...)</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> {<!-- --></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> ......</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> CFactory* pFactory= new CFactory; //<span style="font-family:宋体">类厂对象</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> pFactory-&gt;QueryInterface(IID_IClassFactory, (void**)&amp;pClassFactory);</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> //<span style="font-family:宋体">查询</span>IClassFactory<span style="font-family:宋体">指针</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> pFactory-&gt;Release();</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> ......</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> }</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> CoGetClassObject<span style="font-family:宋体">的流程已经到此为止，现在返回</span>CoCreateInstance<span style="font-family:宋体">，看看</span>CreateInstance<span style="font-family:宋体">的伪码：</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> CFactory::CreateInstance(.....)</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> {<!-- --></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> ...........</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> CObject *pObject = new CObject; //<span style="font-family:宋体">组件对象</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> pObject-&gt;QueryInterface(IID_IUnknown, (void**)&amp;pUnk);</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> pObject-&gt;Release();</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> ...........</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> }</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px">  <wbr></wbr></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <strong>(6) <wbr></wbr><span style="font-family:宋体">一个典型的</span><span style="font-family:宋体; color:red">自注</span><span style="font-family:宋体; color:red">册的</span>COM DLL<span style="font-family:宋体">所必有的四个函数</span></strong></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> DllGetClassObject:<span style="font-family:宋体">用于获得类厂指针</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> DllRegisterServer:<span style="font-family:宋体">注册一些必要的信息到注册表中</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> DllUnregisterServer:<span style="font-family:宋体">卸载注册信息</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> DllCanUnloadNow:<span style="font-family:宋体">系统空闲时会调用这个函数，以确定是否可以卸载</span>DLL</p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px">  <wbr></wbr></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> DLL<span style="font-family:宋体">还有一个函数是</span>DllMain,<span style="font-family:宋体">这个函数在</span>COM<span style="font-family:宋体">中并不要求一定要实现它，但是在</span>VC<span style="font-family:宋体">生成的组件中自动都包含了它，它的作用主要是得到一个全局的实例对象。</span></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px">  <wbr></wbr></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px"> <strong>(7) <wbr></wbr><span style="font-family:宋体">注册表在</span>COM<span style="font-family:宋体">中的重要作用</span></strong></p> 
<p style="text-align:left; line-height:20px; background-color:rgb(255,255,255); margin:5px auto; font-family:verdana,Arial,helvetica,sans-seriff; color:rgb(75,75,75); font-size:13px">  <wbr></wbr><span style="font-family:宋体">首先要知道</span>GUID<span style="font-family:宋体">的概念，</span>COM<span style="font-family:宋体">中所有的类、接口、类型库都用</span>GUID<span style="font-family:宋体">来唯一标识，</span>GUID<span style="font-family:宋体">是一个</span>128<span style="font-family:宋体">位的字串，根据特制算法生成的</span>GUID<span style="font-family:宋体">可以保证是全世界唯一的。</span> <wbr></wbr><span style="color:#cc0000">COM</span><span style="font-family:宋体"><span style="color:#cc0000">组件的创建，查询接口都是通过注册表进行的</span>。<span style="color:#cc0000">有了注册表，应用程序就不需要知道组件的</span></span><span style="color:#cc0000">DLL<span style="font-family:宋体">文件名、位置，只需要根据</span>CLSID</span><span style="font-family:宋体"><span style="color:#cc0000">查就可以了</span>。当版本升级的时侯，只要改一下注册表信息就可以神不知鬼不觉的转到新版本的</span>DLL<span style="font-family:宋体"><span style="font-family:宋体">。</span> </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5fbf20aead53f90ad4fbe85019c192b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">高手给菜鸟学习Linux的10个建议</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e436432edbe7455eb74e184d6e988ae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux网络编程socket错误分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>