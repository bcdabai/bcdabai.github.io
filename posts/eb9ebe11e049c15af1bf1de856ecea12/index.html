<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[并查集] UOJ#61. UR#5 怎样更有力气 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[并查集] UOJ#61. UR#5 怎样更有力气" />
<meta property="og:description" content="这题调的我心态爆炸
大概就是可以把这条链分成若干联通块，联通块之间能连边就直接连
因为每条边只会被缩一次，所以复杂度是有保证的
#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;map&gt; #include &lt;set&gt; using namespace std; typedef long long ll; const int N=300010; int n,m,p,cnt,G[N],fa[N][25],dpt[N],fat[N],nxt[N],size[N]; struct Wrk{ int u,v,w,t; friend bool operator &lt;(Wrk a,Wrk b){ return a.w&lt;b.w; } }w[N]; struct iedge{ int t,nx; }E[N&lt;&lt;1]; inline void addedge(int x,int y){ E[&#43;&#43;cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt; E[&#43;&#43;cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt; } void dfs(int x,int f){ fa[x][0]=f; dpt[x]=dpt[f]&#43;1; for(int i=1;i&lt;=19;i&#43;&#43;) fa[x][i]=fa[fa[x][i-1]][i-1]; for(int i=G[x];i;i=E[i].nx) if(E[i].t!=f) dfs(E[i].t,x); } pair&lt;int,int&gt; ud[N]; int cnt0,iG[N],inxt[N]; int Gfat(int x){ return fat[x]==x?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/eb9ebe11e049c15af1bf1de856ecea12/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-26T11:40:10+08:00" />
<meta property="article:modified_time" content="2017-10-26T11:40:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[并查集] UOJ#61. UR#5 怎样更有力气</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>这题调的我心态爆炸</p> 
<p>大概就是可以把这条链分成若干联通块，联通块之间能连边就直接连</p> 
<p>因为每条边只会被缩一次，所以复杂度是有保证的</p> 
<pre class="prettyprint"><code class="language-c++ hljs cpp"><span class="hljs-preprocessor">#include &lt;cstdio&gt;</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;map&gt;</span>
<span class="hljs-preprocessor">#include &lt;set&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">300010</span>;

<span class="hljs-keyword">int</span> n,m,p,cnt,G[N],fa[N][<span class="hljs-number">25</span>],dpt[N],fat[N],nxt[N],size[N];
<span class="hljs-keyword">struct</span> Wrk{
    <span class="hljs-keyword">int</span> u,v,w,t;
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(Wrk a,Wrk b){
        <span class="hljs-keyword">return</span> a.w&lt;b.w;
    }
}w[N];

<span class="hljs-keyword">struct</span> iedge{
    <span class="hljs-keyword">int</span> t,nx;
}E[N&lt;&lt;<span class="hljs-number">1</span>];

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> addedge(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y){
    E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;
    E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;
}

<span class="hljs-keyword">void</span> dfs(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> f){
    fa[x][<span class="hljs-number">0</span>]=f; dpt[x]=dpt[f]+<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">19</span>;i++) fa[x][i]=fa[fa[x][i-<span class="hljs-number">1</span>]][i-<span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=G[x];i;i=E[i].nx)
        <span class="hljs-keyword">if</span>(E[i].t!=f) dfs(E[i].t,x);
}

pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; ud[N];
<span class="hljs-keyword">int</span> cnt0,iG[N],inxt[N];

<span class="hljs-keyword">int</span> Gfat(<span class="hljs-keyword">int</span> x){
    <span class="hljs-keyword">return</span> fat[x]==x?x:fat[x]=Gfat(fat[x]);
}

<span class="hljs-keyword">int</span> Gnxt(<span class="hljs-keyword">int</span> x){
    <span class="hljs-keyword">return</span> nxt[x]==x?(Gfat(x)==Gfat(fa[x][<span class="hljs-number">0</span>])?nxt[x]=Gnxt(fa[x][<span class="hljs-number">0</span>]):x):nxt[x]=Gnxt(nxt[x]);
}

ll ans=<span class="hljs-number">0</span>;
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> nd[N];

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> lca(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y){
    <span class="hljs-keyword">if</span>(dpt[x]&lt;dpt[y]) swap(x,y);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">19</span>;~i;i--)
        <span class="hljs-keyword">if</span>(dpt[fa[x][i]]&gt;=dpt[y]) x=fa[x][i];
    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">19</span>;~i;i--)
        <span class="hljs-keyword">if</span>(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];
}


pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; A[N],lim[N],B[N]; <span class="hljs-keyword">int</span> tt,lt;

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> nc(){
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">100000</span>],*p1=buf,*p2=buf;
    <span class="hljs-keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="hljs-number">1</span>,<span class="hljs-number">100000</span>,stdin),p1==p2)?EOF:*p1++;
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> rea(<span class="hljs-keyword">int</span> &amp;x){
    <span class="hljs-keyword">char</span> c=nc(); x=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(;c&gt;<span class="hljs-string">'9'</span>||c&lt;<span class="hljs-string">'0'</span>;c=nc());<span class="hljs-keyword">for</span>(;c&gt;=<span class="hljs-string">'0'</span>&amp;&amp;c&lt;=<span class="hljs-string">'9'</span>;x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">'0'</span>,c=nc());
}

<span class="hljs-keyword">int</span> main(){
    rea(n); rea(m); rea(p);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>,x;i&lt;=n;i++)
        rea(x),addedge(x,i);
    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) 
        rea(w[i].u),rea(w[i].v),rea(w[i].w),w[i].t=i;
    sort(w+<span class="hljs-number">1</span>,w+<span class="hljs-number">1</span>+m);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,t,u,v;i&lt;=p;i++){
        rea(t); rea(u); rea(v);
        ud[++cnt0]={u,v}; inxt[cnt0]=iG[t]; iG[t]=cnt0;
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) fat[i]=nxt[i]=i;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++){
        <span class="hljs-keyword">int</span> u=w[i].u,v=w[i].v,cur=w[i].w,LCA=lca(w[i].u,w[i].v);
        tt=<span class="hljs-number">0</span>; 

        <span class="hljs-keyword">for</span>(; Gnxt(u)!=Gnxt(LCA); u=fa[Gnxt(u)][<span class="hljs-number">0</span>])
            A[++tt]={Gfat(u),dpt[u]-dpt[Gnxt(u)]+<span class="hljs-number">1</span>};
        <span class="hljs-keyword">for</span>(; Gnxt(v)!=Gnxt(LCA); v=fa[Gnxt(v)][<span class="hljs-number">0</span>])
            A[++tt]={Gfat(v),dpt[v]-dpt[Gnxt(v)]+<span class="hljs-number">1</span>};
        A[++tt]={Gfat(LCA),dpt[u]+dpt[v]-<span class="hljs-number">2</span>*dpt[LCA]+<span class="hljs-number">1</span>};
        sort(A+<span class="hljs-number">1</span>,A+<span class="hljs-number">1</span>+tt); <span class="hljs-keyword">int</span> nsize=<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=tt;i++)
            <span class="hljs-keyword">if</span>(A[i].first==A[i-<span class="hljs-number">1</span>].first) A[nsize].second+=A[i].second;
            <span class="hljs-keyword">else</span> A[++nsize]=A[i];
        tt=nsize;
        lt=<span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> d=w[i].t;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=iG[d];i;i=inxt[i]){
            <span class="hljs-keyword">int</span> u=Gfat(ud[i].first),v=Gfat(ud[i].second);
            <span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span>(u&lt;v) swap(v,u);
            lim[++lt]={u,v};
        }
        sort(lim+<span class="hljs-number">1</span>,lim+<span class="hljs-number">1</span>+lt);
        <span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>,cnt=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=tt;i++){
            <span class="hljs-keyword">while</span>(lim[k].first==A[i].first &amp;&amp; k&lt;=lt) size[Gfat(lim[k].second)]++,k++;
            <span class="hljs-keyword">int</span> ncnt=<span class="hljs-number">0</span>,cc=<span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt;j++){
                <span class="hljs-keyword">if</span>(size[B[j].first]!=<span class="hljs-number">1L</span>L*B[j].second*A[i].second){
                    ans+=cur; cc+=B[j].second;
                    fat[B[j].first]=A[i].first;
                }
                <span class="hljs-keyword">else</span>{
                    B[++ncnt]=B[j];
                }
                size[B[j].first]=<span class="hljs-number">0</span>;
            }
            cnt=ncnt; B[++cnt]={Gfat(A[i].first),A[i].second+cc};
        }
        <span class="hljs-comment">//cout&lt;&lt;ans&lt;&lt;endl;</span>
    }
    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/91f30331cfccbe4cf3d1008705f7efba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言snprintf()函数用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3a28e243f0e592f00fecb73a7fb81724/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js数据操作（es6）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>