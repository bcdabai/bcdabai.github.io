<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅谈vue3中computed和watch - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅谈vue3中computed和watch" />
<meta property="og:description" content="1.computed是什么？ 在vue世界中，computed是一个叫计算机属性的玩意，他是响应式的，这意味着当计算属性所依赖的数据发生变化时，计算属性会自动重新计算，并更新相关的 DOM，下面是一个简单的案例
&lt;template&gt; &lt;input type=&#34;text&#34; v-model=&#34;one&#34;&gt; &lt;br/&gt; &lt;input type=&#34;text&#34; v-model=&#34;two&#34;&gt; &lt;div&gt;{{str}}&lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import {computed, ref} from &#34;vue&#34;; const one=ref(0) const two=ref(0) let str=computed(()=&gt;{ return parseInt(one.value)&#43;parseInt(two.value) }) &lt;/script&gt; 这样做的好处在于：每当 one 或 two 发生变化时，&lt;div&gt;中的 {{str}} 将会自动更新为 one 和 two 的和。这是因为 computed 是一个响应式计算的属性，这意味着当其依赖的数据（即 one 或 two）发生变化时，它将重新计算并更新自身的结果。由于 computed 是惰性的，它只会在其依赖项发生变化后才进行计算，因此它可以避免不必要的计算和性能开销，总的来说，&lt;div&gt;中的 {{str}} 始终保持最新，而无需手动更新，这就是使用 computed 进行响应式计算的好处。
2.Vue 中计算属性的好处主要体现在以下几个方面 2.1.简化模板逻辑 计算属性可以使模板更加清晰和简洁。它允许你将复杂的逻辑抽离到计算属性中，使模板更专注于 UI 的呈现，降低了模板的复杂度，提高了代码的可读性。
2.2.依赖追踪 Vue 会追踪所有计算属性的依赖关系，在依赖的数据发生变化时自动更新计算属性，而无需手动管理更新逻辑。这带来了更高的开发效率和代码可维护性。
2.3.缓存性 计算属性是基于它们的响应式依赖进行缓存的。只有当依赖发生改变时，才会重新计算。这意味着在多次访问计算属性时，Vue 可以避免不必要的计算，提高了性能和效率。
2.4.更容易维护代码 将复杂的计算逻辑抽象成计算属性，使得代码更易维护。计算属性可以被多个模板中复用，而不需要重复编写逻辑，降低了代码重复率。
如果不使用计算属性，相同的逻辑可能会散布在模板、方法和生命周期钩子中，导致代码难以维护、理解和调试。而使用计算属性，则可以将这些逻辑集中到一个地方，更好地组织代码。总的来说，使用计算属性能够使代码更加清晰、高效和易维护，降低了重复代码的编写，提高了开发效率。它有助于将 UI 的渲染逻辑和数据处理逻辑分离，使得代码结构更加清晰，提高了开发体验和代码质量。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/72518ad17e2159c31d554d5b243eb1d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-09T10:05:40+08:00" />
<meta property="article:modified_time" content="2023-11-09T10:05:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅谈vue3中computed和watch</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1.computed是什么？</h3> 
<p>        在vue世界中，computed是一个叫计算机属性的玩意，他是响应式的，这意味着当计算属性所依赖的数据发生变化时，计算属性会自动重新计算，并更新相关的 DOM，下面是一个简单的案例</p> 
<pre><code class="language-javascript">&lt;template&gt;
&lt;input type="text" v-model="one"&gt;
  &lt;br/&gt;
&lt;input type="text" v-model="two"&gt;
 &lt;div&gt;{<!-- -->{str}}&lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import {computed, ref} from "vue";

const one=ref(0)
const two=ref(0)
let str=computed(()=&gt;{
  return parseInt(one.value)+parseInt(two.value)
})
&lt;/script&gt;</code></pre> 
<p><img alt="" height="97" src="https://images2.imgbox.com/78/ea/mqmVWaWb_o.png" width="449"></p> 
<p><strong>        这样做的好处在于：</strong>每当 <code>one</code> 或 <code>two</code> 发生变化时，&lt;div&gt;中的 <code>{<!-- -->{str}}</code> 将会自动更新为 <code>one</code> 和 <code>two</code> 的和。这是因为 <code>computed</code> 是一个响应式计算的属性，这意味着当其依赖的数据（即 <code>one</code> 或 <code>two</code>）发生变化时，它将重新计算并更新自身的结果。由于 <code>computed</code> 是惰性的，它只会在其依赖项发生变化后才进行计算，因此它可以避免不必要的计算和性能开销，总的来说，&lt;div&gt;中的 <code>{<!-- -->{str}}</code> 始终保持最新，而无需手动更新，这就是使用 <code>computed</code> 进行响应式计算的好处。</p> 
<h3>2.Vue 中计算属性的好处主要体现在以下几个方面</h3> 
<h4>2.1.简化模板逻辑</h4> 
<p>      计算属性可以使模板更加清晰和简洁。它允许你将复杂的逻辑抽离到计算属性中，使模板更专注于 UI 的呈现，降低了模板的复杂度，提高了代码的可读性。</p> 
<h4>2.2.依赖追踪</h4> 
<p>        Vue 会追踪所有计算属性的依赖关系，在依赖的数据发生变化时自动更新计算属性，而无需手动管理更新逻辑。这带来了更高的开发效率和代码可维护性。</p> 
<h4>2.3.缓存性</h4> 
<p>       计算属性是基于它们的响应式依赖进行缓存的。只有当依赖发生改变时，才会重新计算。这意味着在多次访问计算属性时，Vue 可以避免不必要的计算，提高了性能和效率。</p> 
<h4>2.4.更容易维护代码</h4> 
<p>     将复杂的计算逻辑抽象成计算属性，使得代码更易维护。计算属性可以被多个模板中复用，而不需要重复编写逻辑，降低了代码重复率。</p> 
<p>        如果不使用计算属性，相同的逻辑可能会散布在模板、方法和生命周期钩子中，导致代码难以维护、理解和调试。而使用计算属性，则可以将这些逻辑集中到一个地方，更好地组织代码。总的来说，使用计算属性能够使代码更加清晰、高效和易维护，降低了重复代码的编写，提高了开发效率。它有助于将 UI 的渲染逻辑和数据处理逻辑分离，使得代码结构更加清晰，提高了开发体验和代码质量。</p> 
<h3>3.watch是什么？</h3> 
<p>     <code>watch</code> 是一个全局的函数和对象，用于监听数据变化并进行相应的响应。它可以监听任何 Vue 实例的数据或方法的变化，每当被监视的数据发生变化时，它就会触发回调函数，可以用于处理 UI 更新、异步任务和其他操作。</p> 
<p>       到这里有人会问，好像都是数据改变就触发，用watch照样可以执行上面的计算机属性操作，那他们有什么区别？</p> 
<pre><code class="language-javascript">&lt;template&gt;
&lt;input type="text" v-model="one"&gt;
  &lt;br/&gt;
&lt;input type="text" v-model="two"&gt;
 &lt;div&gt;{<!-- -->{sum}}&lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import {ref, watch} from "vue";
const one=ref(0)
const two=ref(0)
const sum=ref(0)
watch([one, two], () =&gt; {
  sum.value = Number.parseInt(one.value) + Number.parseInt(two.value);
});
&lt;/script&gt;</code></pre> 
<p>        效果是一样的，但是眼光的小伙伴就看到我拿了一个响应式变量来接，意思就是，侦听器（watch）他不是响应式的，<strong>watch<code>只是监听数据变化，而并非直接更改数据。如果要使数据具有响应性，请确保它是响应式的。如果您想要更新视图中的数据，请确保调用</code>Vue.set<code>或</code>this.$set` 更新响应式变量，所以上面我拿了一个响应式变量<span style="color:#fe2c24;">sum</span>接</strong></p> 
<p>       相比之下，<code>computed</code> 是一种计算属性，可以基于原始数据或其他计算属性进行复杂的运算，并返回一个新的值。每次依赖的数据发生改变时，都会重新计算结果。<code>computed</code> 在实现 MVVM 观察模型的时候是非常有用的，因为它可以自动更新视图中的数据。 Vue 3 的 <code>watch</code> 和 <code>computed</code> 都可以用来处理数据变化，但是它们的设计理念不同。</p> 
<h4>computed和watch区别：</h4> 
<ul><li><code>computed</code> 更适合用来缓存结果，它是懒加载的，只有在依赖数据发生变化时才会重新计算。它用于计算复杂的表达式，但不能监听非引用类型的数据变化。</li><li><code>watch</code> 更灵活，它可以监听任何数据变化，包括非引用类型的数据，也可以执行异步操作。但当使用 <code>watch</code> 来执行复杂操作或异步任务时，可能会降低性能，因为它会在每次数据变化时都执行一次。 总的来说，<code>computed</code> 更适合用来缓存计算结果，而 <code>watch</code> 更适合用来监听数据变化并执行副作用。建议优先考虑使用 <code>computed</code> ，只有当 <code>computed</code> 无法满足需求时再考虑使用 <code>watch</code> </li></ul> 
<p><strong>注：vue3 版本中不再支持非引用类型监听，vue2还是支持的</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/022ffb9c52be6c25c60df78160f42ec4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">分享66个Python管理系统源代码总有一个是你想要的</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/579acde027faa45dac81f93913ffb82d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">达梦--存储过程创建定时任务插入数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>