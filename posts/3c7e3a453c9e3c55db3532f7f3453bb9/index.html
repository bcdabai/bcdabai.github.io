<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pod重启策略和状态解释 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="pod重启策略和状态解释" />
<meta property="og:description" content="一、重启策略：Pod在遇到故障之后重启的动作1、always2、never3、onfailure3.1 非0状态3.2 为0状态 二、探针附：pod各种状态解释：1、Pod一直处于Pending状态2、Pod一直处于Waiting 或 ContainerCreating状态3、Pod 一直处于CrashLoopBackOff状态4、Pod处于Error状态5、Pod 处于Terminating或 Unknown状态 一、重启策略：Pod在遇到故障之后重启的动作 1：Always：当容器终止退出后，总是重启容器，默认策略
2：OnFailure：当容器异常退出（退出状态码非0）时，重启容器
3：Never：当容器终止退出，从不重启容器。
（注意：k8s中不支持重启Pod资源，只有删除重建，重建）
1、always [root@master test]# vim always.yaml apiVersion: v1 kind: Pod metadata: name: foo spec: containers: - name: busybox image: busybox args: - /bin/sh - -c - sleep 30; exit 3 [root@master test]# kubectl apply -f always.yaml 创建中
运行中
出错了
立即重启
证明重启策略默认是always，总是自动拉取
2、never [root@master test]# vim never.yaml apiVersion: v1 kind: Pod metadata: name: foo01 namespace: zy spec: containers: - name: busybox image: busybox args: - /bin/sh - -c - sleep 30; exit 3 restartPolicy: Never [root@master test]# kubectl apply -f never." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3c7e3a453c9e3c55db3532f7f3453bb9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-01T10:11:58+08:00" />
<meta property="article:modified_time" content="2022-03-01T10:11:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pod重启策略和状态解释</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4> </h4> 
 <ul><li><a href="#Pod_1" rel="nofollow">一、重启策略：Pod在遇到故障之后重启的动作</a></li><li><ul><li><a href="#1always_7" rel="nofollow">1、always</a></li><li><a href="#2never_38" rel="nofollow">2、never</a></li><li><a href="#3onfailure_64" rel="nofollow">3、onfailure</a></li><li><ul><li><a href="#31_0_65" rel="nofollow">3.1 非0状态</a></li><li><a href="#32_0_90" rel="nofollow">3.2 为0状态</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_125" rel="nofollow">二、探针</a></li><li><a href="#pod_171" rel="nofollow">附：pod各种状态解释：</a></li><li><ul><li><a href="#1PodPending_172" rel="nofollow">1、Pod一直处于Pending状态</a></li><li><a href="#2PodWaiting__ContainerCreating_175" rel="nofollow">2、Pod一直处于Waiting 或 ContainerCreating状态</a></li><li><a href="#3Pod_CrashLoopBackOff_184" rel="nofollow">3、Pod 一直处于CrashLoopBackOff状态</a></li><li><a href="#4PodError_189" rel="nofollow">4、Pod处于Error状态</a></li><li><a href="#5Pod_Terminating_Unknown_192" rel="nofollow">5、Pod 处于Terminating或 Unknown状态</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Pod_1"></a>一、重启策略：Pod在遇到故障之后重启的动作</h2> 
<p>1：Always：当容器终止退出后，总是重启容器，默认策略<br> 2：OnFailure：当容器异常退出（退出状态码非0）时，重启容器<br> 3：Never：当容器终止退出，从不重启容器。<br> （注意：k8s中不支持重启Pod资源，只有删除重建，重建）</p> 
<h3><a id="1always_7"></a>1、always</h3> 
<pre><code>[root@master test]# vim always.yaml
apiVersion: v1
kind: Pod
metadata:
  name: foo
spec:
  containers:
  - name: busybox
    image: busybox
    args:
    - /bin/sh
    - -c
    - sleep 30; exit 3
</code></pre> 
<p><img src="https://images2.imgbox.com/a9/5a/gSw8a7P4_o.png" alt="在这里插入图片描述"></p> 
<pre><code>[root@master test]# kubectl apply -f always.yaml 
</code></pre> 
<p>创建中<br> <img src="https://images2.imgbox.com/6e/70/A8TObIFQ_o.png" alt="在这里插入图片描述"><br> 运行中<br> <img src="https://images2.imgbox.com/15/e5/fJreYhpS_o.png" alt="在这里插入图片描述"><br> 出错了<br> <img src="https://images2.imgbox.com/15/81/n5FxQ5GH_o.png" alt="在这里插入图片描述"><br> 立即重启<br> <img src="https://images2.imgbox.com/08/a6/63GMA5xb_o.png" alt="在这里插入图片描述"><br> 证明重启策略默认是always，总是自动拉取</p> 
<h3><a id="2never_38"></a>2、never</h3> 
<pre><code>[root@master test]# vim never.yaml
apiVersion: v1
kind: Pod
metadata:
  name: foo01
  namespace: zy
spec:
  containers:
  - name: busybox
    image: busybox
    args:
    - /bin/sh
    - -c
    - sleep 30; exit 3
  restartPolicy: Never
</code></pre> 
<p><img src="https://images2.imgbox.com/c7/96/IWQylg0x_o.png" alt="在这里插入图片描述"></p> 
<pre><code>[root@master test]# kubectl apply -f never.yaml
</code></pre> 
<p><img src="https://images2.imgbox.com/d2/15/3FQ405eT_o.png" alt="在这里插入图片描述"><br> 这时pod故障后就一直不重启了</p> 
<h3><a id="3onfailure_64"></a>3、onfailure</h3> 
<h4><a id="31_0_65"></a>3.1 非0状态</h4> 
<pre><code>[root@master test]# vim onfailure.yaml
apiVersion: v1
kind: Pod
metadata:
  name: foo02
  namespace: zy
spec:
  containers:
  - name: busybox
    image: busybox
    args:
    - /bin/sh
    - -c
    - sleep 20; exit 3
  restartPolicy: OnFailure
</code></pre> 
<p><img src="https://images2.imgbox.com/45/7a/pkkrDn7D_o.png" alt="在这里插入图片描述"></p> 
<pre><code>[root@master test]# kubectl apply -f onfailure.yaml
</code></pre> 
<p><img src="https://images2.imgbox.com/52/33/Ivdpu6Ie_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/31/80/xv1N1rRt_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="32_0_90"></a>3.2 为0状态</h4> 
<pre><code>[root@master test]# mv onfailure.yaml onfailure0.yaml 
[root@master test]# vim onfailure0.yaml
apiVersion: v1
kind: Pod
metadata:
  name: foo03
  namespace: zy
spec:
  containers:
  - name: busybox
    image: busybox
    args:
    - /bin/sh
    - -c
    - sleep 20; exit 0
  restartPolicy: OnFailure

</code></pre> 
<p><img src="https://images2.imgbox.com/64/f1/snq9k4AS_o.png" alt="在这里插入图片描述"></p> 
<pre><code>[root@master test]# kubectl apply -f onfailure0.yaml
</code></pre> 
<p><img src="https://images2.imgbox.com/46/f7/5pIenpek_o.png" alt="在这里插入图片描述"><br> 退出后显示的完成，说明正常退出，只是完成了这个动作，并不是错误。</p> 
<pre><code>[root@master test]# kubectl delete -f .
pod "foo" deleted
pod "foo01" deleted
pod "foo03" deleted
</code></pre> 
<h2><a id="_125"></a>二、探针</h2> 
<p>健康检查：又称为探针（Probe）<br> （注意：）规则可以同时定义<br> livenessProbe(存活性探针) 如果检查失败，将杀死容器，根据Pod的restartPolicy来操作。<br> ReadinessProbe(就绪性探针) 如果检查失败，kubernetes会把Pod的IP：port信息从service endpoints中剔除。</p> 
<p>Probe支持三种检查方法：<br> httpGet发送http(的GET)请求，返回200-400范围状态码为成功。<br> exec执行 shell命令返回状态码是0为成功（例如:/bin/sh -c cat /var/run/nginx.pid）。<br> tcpSocket 发起TCP Socket建立成功(三次握手的方式建立连接，建立成功，则为健康、否则，则为失败)</p> 
<p>1、exec</p> 
<pre><code>[root@master test]# vim exec.yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-exec
  namespace: zy
spec:
  containers:
  - name: liveness
    image: busybox
    args:
    - /bin/sh
    - -c
    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/healthy
      initialDelaySeconds: 5
      periodSeconds: 5
</code></pre> 
<p><img src="https://images2.imgbox.com/a8/83/vlnHR6se_o.png" alt="在这里插入图片描述"></p> 
<p>在配置文件中，您可以看到/Pod具有单个Container ,该period9econds 字段指定Kucaeet应该每5秒执行一次活动性探测。该initialle1sy$conda字股告诉知cbee在执行第一个保影之前应等待5秒。为了执行探测，kubet cat /try/heolthy在容器中执行命令。如果命令成功执行，则返回，并且lubelet认l为Container仍然健康。如果命令返回非零值，则妙火ubelet将杀死Container并重新启动它。</p> 
<p><img src="https://images2.imgbox.com/8d/ea/UznCIl3k_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/25/fe/mI13fCSh_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="pod_171"></a>附：pod各种状态解释：</h2> 
<h3><a id="1PodPending_172"></a>1、Pod一直处于Pending状态</h3> 
<p>Pending状态意味着Pod的YAML文件已经提交给Kubernetes，API对象已经被创建并保存在Etcd当中。但是，这个Pod里有些容器因为某种原因而不能被顺利创建。比如，调度不成功(可以通过kubectl describe pod命令查看到当前Pod的事件，进而判断为什么没有调度)。可能原因:资源不足（集群内所有的Node都不满足该Pod请求的CPU、内存、GPU等资源);HostPort.已被占用(通常推荐使用Service对外开放服务端口)。</p> 
<h3><a id="2PodWaiting__ContainerCreating_175"></a>2、Pod一直处于Waiting 或 ContainerCreating状态</h3> 
<p>首先还是通过 kubectl describe pod命令查看当前Pod的事件。可能的原因有:<br> 1、镜像拉取失败，比如镜像地址配置错误、拉取不了国外镜像源（gcr.io)、私有镜像密钥配置错误、镜像太大导致拉取超E(可以适当调整kubelet的-image-pull-progress-deadline和-runtime-request-timeout选项)等。<br> 2、CNI网络错误，一般需要检查CNI网络插件的配置，比如:无法配置Pod 网络、无法分配IP地址。<br> 3、容器无法启动，需要检查是否打包了正确的镜像或者是否配置了正确的容器参数<br> 4、Failed create pod sandbox，查看kubelet日志，原因可能是磁盘坏道（input/output error)。<br> Pod 一直处于ImagePullBackOff状态<br> 通常是镜像名称配置错误或者私有镜像的密钥配置错误导致。</p> 
<h3><a id="3Pod_CrashLoopBackOff_184"></a>3、Pod 一直处于CrashLoopBackOff状态</h3> 
<p>此状态说明容器曾经启动了，但又异常退出。这时可以先查看一下容器的日志。<br> 通过命令kubectl logs 和kubectl logs --previous 可以发下一些容器退出的原因，比如:容器进程退出、健康检查失败退出;此时如果还未发现线索，还而已到容器内执行命令(kubectl exec cassandra - cat /var.log/cassandra/system.loq)来进一步查看退出原因;如果还是没有线索，那就需要SSH登录该Pod所在的Node上，查看Kubelet或者Docker的日志进一步排查。</p> 
<h3><a id="4PodError_189"></a>4、Pod处于Error状态</h3> 
<p>通常处于Error状态说明Pod启动过程中发生了错误。常见的原因:依赖的ConfigMap、Secret或PV等不存在;请求的资源超过了管理员设置的限制，比如超过了LimitRange等;违反集群的安全策略，比如违反了PodSecurityPolicy.等;容器无法操作集群内的资源，比如开启RDAC后，需要为ServiceAccount配置角色绑定。</p> 
<h3><a id="5Pod_Terminating_Unknown_192"></a>5、Pod 处于Terminating或 Unknown状态</h3> 
<p>从v1.5开始,Kubernetes,不会因为Node失联而删除其上正在运行的Pod，而是将其标记为Terminating或 Unknown 状态。想要删除这些状态的Pod有三种方法:<br> 1、从集群中删除Node。使用公有云时，kube-controller-manager会在VM删除后自动删除对应的Node<br> 而在物理机部署的集群中，需要管理员手动删除Node (kubectl delete node)。<br> 2、Node恢复正常。,kubelet会重新跟kube-apiserver通信确认这些Pod的期待状态,进而再决定删除或者继续运行这些Pod,用户强制删除，用户可以执行(kubectl delete pods pod-name --grace-period=0 --force）强制删除Pod。除非明确知道pod的确处于停止状态）比如node所在VM或物理机已经关机，否则不建议使用该方法，特别时statefulset管理的POD</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aed597b8ed66be2b5a2256c9e79e3320/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">openvino yoloface4点模型部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7d4c5f11c35bd05e5fe38d756d5b8a19/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是ts(typeScript)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>