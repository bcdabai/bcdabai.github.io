<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Rust基础②】流程控制、模式匹配 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Rust基础②】流程控制、模式匹配" />
<meta property="og:description" content="文章目录 4 流程控制4.1 if else表达式4.2 循环控制4.2.1 for循环4.2.2 while循环4.2.3 loop循环 5 模式匹配5.1 match和if let5.1.1 match匹配使用match表达式赋值模式绑定`_`通配符 5.1.2 if let 匹配5.1.3 matches! 宏 5.2 解构Option5.3 认识模式match 分支if let 分支while let 条件循环for 循环let 语句函数参数let 和 if let 5.3 [全模式列表](https://course.rs/basic/match-pattern/all-patterns.html) 4 流程控制 4.1 if else表达式 if condition == true { // A... } else { // B... } 该代码读作：若 condition 的值为 true，则执行 A 代码，否则执行 B 代码。例如：
fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3f15ac9cddbc0f539746b9f4c89962c2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-13T15:00:00+08:00" />
<meta property="article:modified_time" content="2023-10-13T15:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Rust基础②】流程控制、模式匹配</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#4__1" rel="nofollow">4 流程控制</a></li><li><ul><li><a href="#41_if_else_3" rel="nofollow">4.1 if else表达式</a></li><li><a href="#42__35" rel="nofollow">4.2 循环控制</a></li><li><ul><li><a href="#421_for_37" rel="nofollow">4.2.1 for循环</a></li><li><a href="#422_while_112" rel="nofollow">4.2.2 while循环</a></li><li><a href="#423_loop_130" rel="nofollow">4.2.3 loop循环</a></li></ul> 
  </li></ul> 
  </li><li><a href="#5__157" rel="nofollow">5 模式匹配</a></li><li><ul><li><a href="#51_matchif_let_159" rel="nofollow">5.1 match和if let</a></li><li><ul><li><a href="#511_match_161" rel="nofollow">5.1.1 match匹配</a></li><li><ul><li><a href="#match_182" rel="nofollow">使用match表达式赋值</a></li><li><a href="#_205" rel="nofollow">模式绑定</a></li><li><a href="#__257" rel="nofollow">`_`通配符</a></li></ul> 
    </li><li><a href="#512_if_let__263" rel="nofollow">5.1.2 if let 匹配</a></li><li><a href="#513_matches__301" rel="nofollow">5.1.3 matches! 宏</a></li></ul> 
   </li><li><a href="#52_Option_315" rel="nofollow">5.2 解构Option</a></li><li><a href="#53__347" rel="nofollow">5.3 认识模式</a></li><li><ul><li><ul><li><a href="#match__359" rel="nofollow">match 分支</a></li><li><a href="#if_let__379" rel="nofollow">if let 分支</a></li><li><a href="#while_let__389" rel="nofollow">while let 条件循环</a></li><li><a href="#for__410" rel="nofollow">for 循环</a></li><li><a href="#let__422" rel="nofollow">let 语句</a></li><li><a href="#_462" rel="nofollow">函数参数</a></li><li><a href="#let__if_let_487" rel="nofollow">let 和 if let</a></li></ul> 
   </li></ul> 
   </li><li><a href="#53_httpscoursersbasicmatchpatternallpatternshtml_509" rel="nofollow">5.3 [全模式列表](https://course.rs/basic/match-pattern/all-patterns.html)</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="4__1"></a>4 流程控制</h2> 
<h3><a id="41_if_else_3"></a>4.1 if else表达式</h3> 
<pre><code class="prism language-rust"><span class="token keyword">if</span> condition <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// A...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// B...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>该代码读作：若 <code>condition</code> 的值为 <code>true</code>，则执行 <code>A</code> 代码，否则执行 <code>B</code> 代码。例如：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> condition <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token keyword">if</span> condition <span class="token punctuation">{<!-- --></span>
        <span class="token number">5</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token number">6</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of number is: {}"</span><span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><strong><code>if</code> 语句块是表达式</strong>，这里我们使用 <code>if</code> 表达式的返回值来给 <code>number</code> 进行赋值：<code>number</code> 的值是 <code>5</code></li><li>用 <code>if</code> 来赋值时，要保证每个分支返回的类型一样(事实上，这种说法不完全准确，见<a href="https://course.rs/appendix/expressions.html#if%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">这里</a>)，此处返回的 <code>5</code> 和 <code>6</code> 就是同一个类型，如果返回类型不一致就会报错</li></ul> 
<p>可以将 <code>else if</code> 与 <code>if</code>、<code>else</code> 组合在一起实现更复杂的条件分支判断</p> 
<h3><a id="42__35"></a>4.2 循环控制</h3> 
<h4><a id="421_for_37"></a>4.2.1 for循环</h4> 
<p>核心就在于 <code>for</code> 和 <code>in</code> 的联动，语义表达如下：</p> 
<pre><code class="prism language-rust"><span class="token keyword">for</span> 元素 <span class="token keyword">in</span> 集合 <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 使用元素干一些你懂我不懂的事情</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>例如：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..=</span><span class="token number">5</span> <span class="token punctuation">{<!-- --></span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码循环输出一个从 1 到 5 的序列。</p> 
<p>注意，使用 <code>for</code> 时我们往往使用集合的引用形式，除非你不想在后面的代码中继续使用该集合（比如我们这里使用了 <code>container</code> 的引用）。如果不使用引用的话，所有权会被转移（move）到 <code>for</code> 语句块中，后面就无法再使用这个集合了)</p> 
<p>如果想在循环中，<strong>修改该元素</strong>，可以使用 <code>mut</code> 关键字：</p> 
<pre><code class="prism language-rust"><span class="token keyword">for</span> item <span class="token keyword">in</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> collection <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>总结如下：</p> 
<table><thead><tr><th>使用方法</th><th>等价使用方式</th><th>所有权</th></tr></thead><tbody><tr><td><code>for item in collection</code></td><td><code>for item in IntoIterator::into_iter(collection)</code></td><td>转移所有权</td></tr><tr><td><code>for item in &amp;collection</code></td><td><code>for item in collection.iter()</code></td><td>不可变借用</td></tr><tr><td><code>for item in &amp;mut collection</code></td><td><code>for item in collection.iter_mut()</code></td><td>可变借用</td></tr></tbody></table> 
<p>如果想在循环中<strong>获取元素的索引</strong>：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// `.iter()` 方法把 `a` 数组变成一个迭代器</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> a<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"第{}个元素是{}"</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>两种循环方式：</p> 
<pre><code class="prism language-rust"><span class="token comment">// 第一种</span>
<span class="token keyword">let</span> collection <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>collection<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> item <span class="token operator">=</span> collection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 第二种</span>
<span class="token keyword">for</span> item <span class="token keyword">in</span> collection <span class="token punctuation">{<!-- --></span>

<span class="token punctuation">}</span>
</code></pre> 
<p>第一种方式是循环索引，然后通过索引下标去访问集合，第二种方式是直接循环集合中的元素，优劣如下：</p> 
<ul><li><strong>性能</strong>：第一种使用方式中 <code>collection[index]</code> 的索引访问，会因为边界检查(Bounds Checking)导致运行时的性能损耗 —— Rust 会检查并确认 <code>index</code> 是否落在集合内，但是第二种直接迭代的方式就不会触发这种检查，因为编译器会在编译时就完成分析并证明这种访问是合法的</li><li><strong>安全</strong>：第一种方式里对 <code>collection</code> 的索引访问是非连续的，存在一定可能性在两次访问之间，<code>collection</code> 发生了变化，导致脏数据产生。而第二种直接迭代的方式是连续访问，因此不存在这种风险</li></ul> 
<p>使用 <code>continue</code> 可以跳过当前当次的循环，开始下次的循环；使用 <code>break</code> 可以直接跳出当前整个循环</p> 
<h4><a id="422_while_112"></a>4.2.2 while循环</h4> 
<p>如果你需要一个条件来循环，当该条件为 <code>true</code> 时，继续循环，条件为 <code>false</code>，跳出循环，那么 <code>while</code> 就非常适用：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> n <span class="token operator">&lt;=</span> <span class="token number">5</span>  <span class="token punctuation">{<!-- --></span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}!"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

        n <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"我出来了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="423_loop_130"></a>4.2.3 loop循环</h4> 
<p><code>loop</code> 就是一个简单的无限循环，你可以在内部实现逻辑通过 <code>break</code> 关键字来控制循环何时结束。当使用 <code>loop</code> 时，必不可少的伙伴是 <code>break</code> 关键字，它能让循环在满足某个条件时跳出：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">loop</span> <span class="token punctuation">{<!-- --></span>
        counter <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> counter <span class="token operator">==</span> <span class="token number">10</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">break</span> counter <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The result is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码当 <code>counter</code> 递增到 <code>10</code> 时，就会通过 <code>break</code> 返回一个 <code>counter * 2</code> 的值，最后赋给 <code>result</code> 并打印出来。</p> 
<p>这里有几点值得注意：</p> 
<ul><li><strong>break 可以单独使用，也可以带一个返回值</strong>，有些类似 <code>return</code></li><li><strong>loop 是一个表达式</strong>，因此可以返回一个值</li></ul> 
<h2><a id="5__157"></a>5 模式匹配</h2> 
<h3><a id="51_matchif_let_159"></a>5.1 match和if let</h3> 
<h4><a id="511_match_161"></a>5.1.1 match匹配</h4> 
<p><code>match</code> 的通用形式：</p> 
<pre><code class="prism language-rust"><span class="token keyword">match</span> target <span class="token punctuation">{<!-- --></span>
    模式<span class="token number">1</span> <span class="token operator">=&gt;</span> 表达式<span class="token number">1</span><span class="token punctuation">,</span>
    模式<span class="token number">2</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        语句<span class="token number">1</span><span class="token punctuation">;</span>
        语句<span class="token number">2</span><span class="token punctuation">;</span>
        表达式<span class="token number">2</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    _ <span class="token operator">=&gt;</span> 表达式<span class="token number">3</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>该形式清晰的说明了何为模式，何为模式匹配：将模式与 <code>target</code> 进行匹配，即为模式匹配</p> 
<ul><li><code>match</code> 的匹配必须要穷举出所有可能，因此这里用 <code>_</code> 来代表未列出的所有可能性</li><li><code>match</code> 的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同</li></ul> 
<h5><a id="match_182"></a>使用match表达式赋值</h5> 
<p><code>match</code> 本身也是一个表达式，因此可以用它来赋值：</p> 
<pre><code class="prism language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">{<!-- --></span>
   <span class="token class-name">Ipv4</span><span class="token punctuation">,</span>
   <span class="token class-name">Ipv6</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> ip1 <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token class-name">Ipv6</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> ip_str <span class="token operator">=</span> <span class="token keyword">match</span> ip1 <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token class-name">Ipv4</span> <span class="token operator">=&gt;</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span>
        _ <span class="token operator">=&gt;</span> <span class="token string">"::1"</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> ip_str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>因为这里匹配到 <code>_</code> 分支，所以将 <code>"::1"</code> 赋值给了 <code>ip_str</code>。</p> 
<h5><a id="_205"></a>模式绑定</h5> 
<p>模式匹配的一个重要功能是从模式中取出绑定的值。</p> 
<p>模式绑定的例子：</p> 
<pre><code class="prism language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Action</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Say</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">MoveTo</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">ChangeColorRGB</span><span class="token punctuation">(</span><span class="token keyword">u16</span><span class="token punctuation">,</span> <span class="token keyword">u16</span><span class="token punctuation">,</span> <span class="token keyword">u16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> actions <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token class-name">Action</span><span class="token punctuation">::</span><span class="token class-name">Say</span><span class="token punctuation">(</span><span class="token string">"Hello Rust"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Action</span><span class="token punctuation">::</span><span class="token class-name">MoveTo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Action</span><span class="token punctuation">::</span><span class="token class-name">ChangeColorRGB</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> action <span class="token keyword">in</span> actions <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">match</span> action <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Action</span><span class="token punctuation">::</span><span class="token class-name">Say</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token class-name">Action</span><span class="token punctuation">::</span><span class="token class-name">MoveTo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"point from (0, 0) move to ({}, {})"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token class-name">Action</span><span class="token punctuation">::</span><span class="token class-name">ChangeColorRGB</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> g<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"change color into '(r:{}, g:{}, b:0)', 'b' has been ignored"</span><span class="token punctuation">,</span>
                    r<span class="token punctuation">,</span> g<span class="token punctuation">,</span>
                <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行后输出：</p> 
<pre><code class="prism language-shell">$ <span class="token function">cargo</span> run
   Compiling world_hello v0.1.0 <span class="token punctuation">(</span>/Users/sunfei/development/rust/world_hello<span class="token punctuation">)</span>
    Finished dev <span class="token punctuation">[</span>unoptimized + debuginfo<span class="token punctuation">]</span> target<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span>.16s
     Running <span class="token variable"><span class="token variable">`</span>target/debug/world_hello<span class="token variable">`</span></span>
Hello Rust
point from <span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">0</span><span class="token punctuation">)</span> move to <span class="token punctuation">(</span><span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">)</span>
change color into <span class="token string">'(r:255, g:255, b:0)'</span>, <span class="token string">'b'</span> has been ignored

</code></pre> 
<h5><a id="__257"></a><code>_</code>通配符</h5> 
<p><code>match</code> 的匹配必须穷尽所有情况，即穷尽匹配，Rust 编译器清晰地知道 <code>match</code> 中有哪些分支没有被覆盖, 这种行为能强制我们处理所有的可能性。</p> 
<p>通过将 <code>_</code> 其放置于其他分支后，<code>_</code> 将会匹配所有遗漏的值。<code>()</code> 表示返回<strong>单元类型</strong>与所有分支返回值的类型相同，所以当匹配到 <code>_</code> 后，什么也不会发生。</p> 
<h4><a id="512_if_let__263"></a>5.1.2 if let 匹配</h4> 
<p>有时会遇到只有一个模式的值需要被处理，其它值直接忽略的场景，如果用 <code>match</code> 来处理就要写成下面这样：</p> 
<pre><code class="prism language-rust">    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">3u8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">match</span> v <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        _ <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>我们只想要对 <code>Some(3)</code> 模式进行匹配, 不想处理任何其他 <code>Some&lt;u8&gt;</code> 值或 <code>None</code> 值。但是为了满足 <code>match</code> 表达式（穷尽性）的要求，写代码时必须在处理完这唯一的成员后加上 <code>_ =&gt; ()</code>，这样会增加不少无用的代码。</p> 
<p>俗话说“杀鸡焉用牛刀”，我们完全可以用 <code>if let</code> 的方式来实现：</p> 
<pre><code class="prism language-rust"><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> v <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这两种匹配对于新手来说，可能有些难以抉择，但是只要记住一点就好：<strong>当你只要匹配一个条件，且忽略其他条件时就用 <code>if let</code> ，否则都用 <code>match</code></strong>。</p> 
<p>无论是 <code>match</code> 还是 <code>if let</code>，他们都可以在模式匹配时覆盖掉老的值，绑定新的值:</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> age<span class="token operator">=</span><span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"匹配前b：{:?}"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//3</span>
  <span class="token keyword">if</span> <span class="token keyword">let</span> b<span class="token operator">=</span>age<span class="token punctuation">{<!-- --></span>
      <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"b:{:?}"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Some(30)</span>
  <span class="token punctuation">}</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"匹配后b：{:?}"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//3</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="513_matches__301"></a>5.1.3 matches! 宏</h4> 
<p><code>matches!</code>宏可以将一个表达式跟模式进行匹配，然后返回匹配的结果 <code>true</code> or <code>false</code>。</p> 
<p>例如：</p> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token char">'f'</span><span class="token punctuation">;</span>
<span class="token macro property">assert!</span><span class="token punctuation">(</span><span class="token macro property">matches!</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token char">'A'</span><span class="token punctuation">..=</span><span class="token char">'Z'</span> <span class="token operator">|</span> <span class="token char">'a'</span><span class="token punctuation">..=</span><span class="token char">'z'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">assert!</span><span class="token punctuation">(</span><span class="token macro property">matches!</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">if</span> x <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="52_Option_315"></a>5.2 解构Option</h3> 
<p><code>Opention</code>枚举用来解决Rust中变量是否有值的问题，定义如下：</p> 
<pre><code class="prism language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">None</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>简单解释就是：<strong>一个变量要么有值：<code>Some(T)</code>, 要么为空：<code>None</code></strong>。</p> 
<p>使用 <code>Option&lt;T&gt;</code>，是为了从 <code>Some</code> 中取出其内部的 <code>T</code> 值以及处理没有值的情况，为了演示这一点，下面一起来编写一个函数，它获取一个 <code>Option&lt;i32&gt;</code>，如果其中含有一个值，将其加一；如果其中没有值，则函数返回 <code>None</code> 值：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">plus_one</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">match</span> x <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token class-name">None</span><span class="token punctuation">,</span>
        <span class="token class-name">Some</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> five <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> six <span class="token operator">=</span> <span class="token function">plus_one</span><span class="token punctuation">(</span>five<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> none <span class="token operator">=</span> <span class="token function">plus_one</span><span class="token punctuation">(</span><span class="token class-name">None</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>plus_one</code> 接受一个 <code>Option&lt;i32&gt;</code> 类型的参数，同时返回一个 <code>Option&lt;i32&gt;</code> 类型的值(这种形式的函数在标准库内随处所见)，在该函数的内部处理中，如果传入的是一个 <code>None</code> ，则返回一个 <code>None</code> 且不做任何处理；如果传入的是一个 <code>Some(i32)</code>，则通过模式绑定，把其中的值绑定到变量 <code>i</code> 上，然后返回 <code>i+1</code> 的值，同时用 <code>Some</code> 进行包裹。</p> 
<h3><a id="53__347"></a>5.3 认识模式</h3> 
<p>模式是 Rust 中的特殊语法，它用来匹配类型中的结构和数据，模式一般由以下内容组合而成：</p> 
<ul><li>字面值</li><li>解构的数组、枚举、结构体或者元组</li><li>变量</li><li>通配符</li><li>占位符</li></ul> 
<p>所有可能认识到模式的地方：</p> 
<h5><a id="match__359"></a>match 分支</h5> 
<pre><code class="prism language-rust"><span class="token keyword">match</span> <span class="token constant">VALUE</span> <span class="token punctuation">{<!-- --></span>
    <span class="token constant">PATTERN</span> <span class="token operator">=&gt;</span> <span class="token constant">EXPRESSION</span><span class="token punctuation">,</span>
    <span class="token constant">PATTERN</span> <span class="token operator">=&gt;</span> <span class="token constant">EXPRESSION</span><span class="token punctuation">,</span>
    <span class="token constant">PATTERN</span> <span class="token operator">=&gt;</span> <span class="token constant">EXPRESSION</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如上所示，<code>match</code> 的每个分支就是一个<strong>模式</strong>，因为 <code>match</code> 匹配是穷尽式的，因此我们往往需要一个特殊的模式 <code>_</code>，来匹配剩余的所有情况：</p> 
<pre><code class="prism language-rust"><span class="token keyword">match</span> <span class="token constant">VALUE</span> <span class="token punctuation">{<!-- --></span>
    <span class="token constant">PATTERN</span> <span class="token operator">=&gt;</span> <span class="token constant">EXPRESSION</span><span class="token punctuation">,</span>
    <span class="token constant">PATTERN</span> <span class="token operator">=&gt;</span> <span class="token constant">EXPRESSION</span><span class="token punctuation">,</span>
    _ <span class="token operator">=&gt;</span> <span class="token constant">EXPRESSION</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="if_let__379"></a>if let 分支</h5> 
<p><code>if let</code> 往往用于匹配一个模式，而忽略剩下的所有模式的场景：</p> 
<pre><code class="prism language-rust"><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token constant">PATTERN</span> <span class="token operator">=</span> <span class="token constant">SOME_VALUE</span> <span class="token punctuation">{<!-- --></span>

<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="while_let__389"></a>while let 条件循环</h5> 
<p>一个与 <code>if let</code> 类似的结构是 <code>while let</code> 条件循环，它允许只要模式匹配就一直进行 <code>while</code> 循环。下面展示了一个使用 <code>while let</code> 的例子：</p> 
<pre><code class="prism language-rust"><span class="token comment">// Vec是动态数组</span>
<span class="token keyword">let</span> <span class="token keyword">mut</span> stack <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 向数组尾部插入元素</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// stack.pop从数组尾部弹出元素</span>
<span class="token keyword">while</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>top<span class="token punctuation">)</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个例子会打印出 <code>3</code>、<code>2</code> 接着是 <code>1</code>。<code>pop</code> 方法取出动态数组的最后一个元素并返回 <code>Some(value)</code>，如果动态数组是空的，将返回 <code>None</code>，对于 <code>while</code> 来说，只要 <code>pop</code> 返回 <code>Some</code> 就会一直不停的循环。一旦其返回 <code>None</code>，<code>while</code> 循环停止。可以使用 <code>while let</code> 来弹出栈中的每一个元素。</p> 
<h5><a id="for__410"></a>for 循环</h5> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> v<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{} is at index {}"</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里使用 <code>enumerate</code> 方法产生一个迭代器，该迭代器每次迭代会返回一个 <code>(索引，值)</code> 形式的元组，然后用 <code>(index,value)</code> 来匹配。</p> 
<h5><a id="let__422"></a>let 语句</h5> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> <span class="token constant">PATTERN</span> <span class="token operator">=</span> <span class="token constant">EXPRESSION</span><span class="token punctuation">;</span>
</code></pre> 
<p>是的， 该语句我们已经用了无数次了，它也是一种模式匹配：</p> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre> 
<p>这其中，<code>x</code> 也是一种模式绑定，代表将<strong>匹配的值绑定到变量 x 上</strong>。因此，在 Rust 中,<strong>变量名也是一种模式</strong>，只不过它比较朴素很不起眼罢了。</p> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>上面将一个元组与模式进行匹配(<strong>模式和值的类型必需相同！</strong>)，然后把 <code>1, 2, 3</code> 分别绑定到 <code>x, y, z</code> 上。</p> 
<p>模式匹配要求两边的类型必须相同，否则就会导致下面的报错：</p> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
error<span class="token punctuation">[</span><span class="token constant">E0308</span><span class="token punctuation">]</span><span class="token punctuation">:</span> mismatched types
 <span class="token operator">-</span><span class="token punctuation">-&gt;</span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">5</span>
  <span class="token operator">|</span>
<span class="token number">4</span> <span class="token operator">|</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">|</span>     <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span>   <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> this expression has <span class="token keyword">type</span> `<span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>integer<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>integer<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>integer<span class="token punctuation">}</span><span class="token punctuation">)</span>`
  <span class="token operator">|</span>     <span class="token operator">|</span>
  <span class="token operator">|</span>     expected a tuple with <span class="token number">3</span> elements<span class="token punctuation">,</span> found one with <span class="token number">2</span> elements
  <span class="token operator">|</span>
  <span class="token operator">=</span> note<span class="token punctuation">:</span> expected tuple `<span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>integer<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>integer<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>integer<span class="token punctuation">}</span><span class="token punctuation">)</span>`
             found tuple `<span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span>`
<span class="token class-name">For</span> more information about this error<span class="token punctuation">,</span> <span class="token keyword">try</span> `rustc <span class="token operator">-</span><span class="token operator">-</span>explain <span class="token constant">E0308</span>`<span class="token punctuation">.</span>
error<span class="token punctuation">:</span> could not compile `playground` due to previous error
</code></pre> 
<p>对于元组来说，元素个数也是类型的一部分！</p> 
<h5><a id="_462"></a>函数参数</h5> 
<p>函数参数也是模式：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 代码</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其中 <code>x</code> 就是一个模式，你还可以在参数中匹配元组：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">print_coordinates</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Current location: ({}, {})"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> point <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_coordinates</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>point<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>&amp;(3, 5)</code> 会匹配模式 <code>&amp;(x, y)</code>，因此 <code>x</code> 得到了 <code>3</code>，<code>y</code> 得到了 <code>5</code>。</p> 
<h5><a id="let__if_let_487"></a>let 和 if let</h5> 
<p>对于以下代码，编译器会报错：</p> 
<pre><code class="prism language-rust"><span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> some_option_value<span class="token punctuation">;</span>
</code></pre> 
<p>因为右边的值可能不为 <code>Some</code>，而是 <code>None</code>，这种时候就不能进行匹配，也就是上面的代码遗漏了 <code>None</code> 的匹配。</p> 
<p>类似 <code>let</code> , <code>for</code>和<code>match</code> 都必须要求完全覆盖匹配，才能通过编译( 不可驳模式匹配 )。</p> 
<p>但是对于 <code>if let</code>，就可以这样使用：</p> 
<pre><code class="prism language-rust"><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> some_option_value <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>因为 <code>if let</code> 允许匹配一种模式，而忽略其余的模式( 可驳模式匹配 )。</p> 
<h3><a id="53_httpscoursersbasicmatchpatternallpatternshtml_509"></a>5.3 <a href="https://course.rs/basic/match-pattern/all-patterns.html" rel="nofollow">全模式列表</a></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a962be28ed46a1fb4c6195854dfc20b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PG14归档失败解决办法archiver failed on wal_lsn</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/029a0375c59b7939a3cd6e07dbbbced0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">通过API接口获取大量的数据后，需要对这些数据进行处理和分析，以实现业务目标</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>