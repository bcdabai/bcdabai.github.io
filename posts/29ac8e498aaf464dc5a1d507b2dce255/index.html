<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java-mybatis-自定义interceptor拦截器-获取原生sql补全公共参数 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java-mybatis-自定义interceptor拦截器-获取原生sql补全公共参数" />
<meta property="og:description" content="java-mybatis-自定义interceptor拦截器-获取原生sql补全公共参数 环境 pgsql &#43; jdk1.8 &#43; mybatis &#43; springboot
一、引言 数据使用PGSQL存储，由于业务场景扩充，使用固定的Schema不能满足业务存储需求，亟需修改代码逻辑将原来在代码中写死的Schema名称改为动态可变形式。
最简单的方法是将所有引用 mySchema 的地方使用 ${schameName} 替换，再修改调用方法调用处，将schemaName传入。
--原查询脚本 select * from mySchema.myTable; --替换后的形式 select * from ${mySchema}.myTable; 之所以用${mySchema}占位符，是因为拼接表名不能使用参数化方式传参；
好吧，全局搜下需要修改的位置，看看有多少：
--查询结果为： Find in Files 300&#43; matches in 30&#43; files 分析了匹配的文件，发现引用位置有的在 xml 中，有的在 @Select、@Update等注解中，果断放弃！！！
想到了用mybatis的拦截器，不需要修改调用方法的形参，使用非侵入性的修改就可以完成参数注入；
先看下拦截器相关基础资料。
二、四种mybatis拦截器 Mybatis提供了四个可拦截对象是： Executor sql的内部执行器ParameterHandler 拦截参数的处理StatementHandler 拦截sql的构建ResultSetHandler 拦截结果的处理 这4中不同类型的拦截器的拦截顺序为从上到下的顺序为：
Executor -&gt; ParameterHandler -&gt; StatementHandler -&gt; ResultSetHandler
如果相同类型的拦截器,比如Executor类型的拦截器有两个,则执行顺序为将拦截器添加到SqlSessionFactory的逆向顺序执行；
比如SqlSessionFactory中先添加了Executor类型的A拦截器,在添加了Executor类型的B拦截器,则会先执行B拦截器,再执行A拦截器；
声明拦截器 使用@Intercepts、@Signature注解声明拦截器 @Component @Intercepts({ @Signature(type = StatementHandler.class, method = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/29ac8e498aaf464dc5a1d507b2dce255/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-17T16:04:46+08:00" />
<meta property="article:modified_time" content="2022-11-17T16:04:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java-mybatis-自定义interceptor拦截器-获取原生sql补全公共参数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="javamybatisinterceptorsql_1"></a>java-mybatis-自定义interceptor拦截器-获取原生sql补全公共参数</h2> 
<blockquote> 
 <p>环境 pgsql + jdk1.8 + mybatis + springboot</p> 
</blockquote> 
<h3><a id="_4"></a>一、引言</h3> 
<p>数据使用PGSQL存储，由于业务场景扩充，使用固定的Schema不能满足业务存储需求，亟需修改代码逻辑将原来在代码中写死的Schema名称改为动态可变形式。<br> 最简单的方法是将所有引用 mySchema 的地方使用 ${schameName} 替换，再修改调用方法调用处，将schemaName传入。</p> 
<pre><code>--原查询脚本
select * from mySchema.myTable;
--替换后的形式
select * from ${mySchema}.myTable;
</code></pre> 
<blockquote> 
 <p>之所以用${mySchema}占位符，是因为拼接表名不能使用参数化方式传参；<br> 好吧，全局搜下需要修改的位置，看看有多少：</p> 
</blockquote> 
<pre><code>--查询结果为：
Find in Files 300+ matches in 30+ files
</code></pre> 
<p>分析了匹配的文件，发现引用位置有的在 xml 中，有的在 @Select、@Update等注解中，果断放弃！！！<br> 想到了用mybatis的拦截器，不需要修改调用方法的形参，使用非侵入性的修改就可以完成参数注入；<br> 先看下拦截器相关基础资料。</p> 
<h3><a id="mybatis_24"></a>二、四种mybatis拦截器</h3> 
<h4><a id="Mybatis_25"></a>Mybatis提供了四个可拦截对象是：</h4> 
<ul><li>Executor sql的内部执行器</li><li>ParameterHandler 拦截参数的处理</li><li>StatementHandler 拦截sql的构建</li><li>ResultSetHandler 拦截结果的处理</li></ul> 
<blockquote> 
 <p>这4中不同类型的拦截器的拦截顺序为从上到下的顺序为：<br> Executor -&gt; ParameterHandler -&gt; StatementHandler -&gt; ResultSetHandler<br> 如果相同类型的拦截器,比如Executor类型的拦截器有两个,则执行顺序为将拦截器添加到SqlSessionFactory的逆向顺序执行；<br> 比如SqlSessionFactory中先添加了Executor类型的A拦截器,在添加了Executor类型的B拦截器,则会先执行B拦截器,再执行A拦截器；</p> 
</blockquote> 
<h4><a id="_35"></a>声明拦截器</h4> 
<ul><li>使用@Intercepts、@Signature注解声明拦截器</li></ul> 
<pre><code>@Component
@Intercepts({
    @Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class, Integer.class})
})
public class SchemaParamsterInterceptor implements Interceptor {
}
</code></pre> 
<ul><li>@Signature注解参数说明 
  <ul><li>type 四个可拦截类的class对象；</li><li>method 类中的方法名称，入上述的prepare就是StatementHandler中的prepare方法；</li><li>args 方法的形参类型，数量类型与拦截类中的方法声明一致；</li></ul> </li></ul> 
<h4><a id="_50"></a>注册拦截器</h4> 
<ul><li>使用 @Configuration配置注解</li></ul> 
<pre><code>@Configuration
public class MybatisConfig {
    @Autowired
    private List&lt;SqlSessionFactory&gt; sqlSessionFactoryList;
    /**
     * mybatis 拦截器注册
     */
    @PostConstruct
    public void addSqlInterceptor() {
        SchemaParamsterInterceptor interceptor = new SchemaParamsterInterceptor();
        for (SqlSessionFactory sqlSessionFactory : sqlSessionFactoryList) {
            sqlSessionFactory.getConfiguration().addInterceptor(interceptor);
        }
    }
}
</code></pre> 
<h3><a id="_70"></a>三、动态参数注入方案：</h3> 
<h4><a id="sql_71"></a>方案一：使用正常的sql占位符${…}</h4> 
<p>思路是在sql定义中使用标准占位符 ${schemaName}，在拦截器中判断原始SQL中是否出现${schemaName}字符，出现了就注入schemaName参数。<br> 优点：可以兼容标准调用，开发者对于schameName可传可不传，不传就可以自动注入，显示传入则使用传入的参数；</p> 
<ul><li>使用ParameterHandler拦截器遇到的问题： 
  <ul><li>sql定义中写了${schemaName}占位符但是没传入，在Executor拦截器中就异常了，根本走不到ParameterHandler拦截器；</li><li>那试着用Executor拦截器；</li></ul> </li><li>使用Executor拦截器遇到的问题： 
  <ul><li>测试失败，因为传入参数类型的类型不固定（map、pojo、基础类型）不方便判断和注入；</li></ul> </li></ul> 
<pre><code>@Component
@Intercepts({
        @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
})
public class SchemaParamsterInterceptor implements Interceptor {

    @Override
    public Object plugin(Object target) {
        return Interceptor.super.plugin(target);
    }

    @Override
    public void setProperties(Properties properties) {
        Interceptor.super.setProperties(properties);
    }
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        // 拦截 Executor 的 query 方法 生成sql前将 任意参数 设置到实体中
        if (invocation.getTarget() instanceof Executor ) {
            //&amp;&amp; "query".equals(invocation.getMethod().getName())
            return invokeQuery(invocation);
        }
        return null;
    }

    /** 获取原始sql */
    private String getRawSQL(Invocation invocation) throws NoSuchFieldException, IllegalAccessException {
        //反射获取 SqlSource 对象，通过此对象获取原始SQL
        MappedStatement ms = (MappedStatement) invocation.getArgs()[0];
        /** SqlSource{@link org.apache.ibatis.mapping.SqlSource}的实现类比较多，不方便在所有实现类中解析原始SQL*/
        SqlSource sqlSource = ms.getSqlSource();
        //通过MappedStatement.SqlSource对象获取原生sql不太靠谱！！！
        if(sqlSource instanceof DynamicSqlSource) {
            DynamicSqlSource dynamicSqlSource = (DynamicSqlSource) ms.getSqlSource();
            if (dynamicSqlSource == null)
                return null;
            //反射获取 TextSqlNode 对象
            Field sqlNodeField = dynamicSqlSource.getClass().getDeclaredField("rootSqlNode");
            sqlNodeField.setAccessible(true);
            TextSqlNode rootSqlNode = (TextSqlNode) sqlNodeField.get(dynamicSqlSource);
            //反射获取原生sql
            Field textField = rootSqlNode.getClass().getDeclaredField("text");
            textField.setAccessible(true);
            String sql = String.valueOf(textField.get(rootSqlNode));
            return sql;
        }
        if(sqlSource instanceof RawSqlSource) {
            RawSqlSource rawSqlSource = (RawSqlSource) ms.getSqlSource();
            if (rawSqlSource == null)
                return null;
            //反射获取 TextSqlNode 对象
            Field sqlSourceField = rawSqlSource.getClass().getDeclaredField("sqlSource");
            sqlSourceField.setAccessible(true);
            StaticSqlSource staticSqlSource = (StaticSqlSource) sqlSourceField.get(rawSqlSource);
            //反射获取原生sql
            Field sqlField = staticSqlSource.getClass().getDeclaredField("sql");
            sqlField.setAccessible(true);
            String sql = String.valueOf(sqlField.get(staticSqlSource));
            return sql;
        }
        return null;
    }

    private Object invokeQuery(Invocation invocation) throws Exception {
        //todo 按需添加注入參數提高性能
//        String sql = getRawSQL(invocation);
//        if(StringUtils.isBlank(sql) || sql.indexOf(schemaParamsPlaceholder)==-1)
//            return null;

        Executor executor = (Executor) invocation.getTarget();

        // 获取第一个参数
        MappedStatement ms = (MappedStatement) invocation.getArgs()[0];
        // mybatis的参数对象
        Object paramObj = invocation.getArgs()[1];
        if (paramObj == null) {
            MapperMethod.ParamMap&lt;Object&gt; param = new MapperMethod.ParamMap&lt;&gt;();
            paramObj = param;
        }
        //执行脚本
        processParam(paramObj);
        RowBounds rowBounds = (RowBounds)invocation.getArgs()[2];
        ResultHandler resultHandler  = (ResultHandler)invocation.getArgs()[3];
        return executor.query(ms, paramObj,rowBounds,resultHandler);
    }
    /** 处理参数对象 */
    private void processParam(Object parameterObject) throws IllegalAccessException, InvocationTargetException {
        //如果是map且map的key中没有需要的参数，则添加到参数map中
        if (parameterObject instanceof Map) {
            String schemaName = "mySchema";
            ((Map) parameterObject).putIfAbsent("schemaName", schemaName);
            return;
        }
    }
}
</code></pre> 
<h4><a id="_176"></a>方案二：使用非标准占位符</h4> 
<p>思路：使用自定的占位符，这样就可以跳过参数定义校验，在sql预处理时将占位符替换为正确的schema名；<br> 优点：可以兼容xml和通过注解定义的sql,支持所有类型sql如：select、insert、delete、update；<br> 缺点：不能兼容显示传入的参数，所有执行的sql都会被拦截；</p> 
<pre><code>/***
 * schema参数动态注入
 */
@Log4j
@Component
@Intercepts({
        @Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class, Integer.class})
})
public class SchemaParamsterInterceptor implements Interceptor {
    /** SQL中的占位符 */
    private static final String schemaPlaceholder = "_schemaName";
    

    @Override
    public Object plugin(Object target) {
        return Interceptor.super.plugin(target);
    }

    @Override
    public void setProperties(Properties properties) {
        Interceptor.super.setProperties(properties);
    }
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        //
        if(invocation.getTarget() instanceof  StatementHandler){
            if("prepare".equals(invocation.getMethod().getName()))
                return invokeStatementHandlerPrepare(invocation);
        }
        return null;
    }

    private Object invokeStatementHandlerPrepare(Invocation invocation) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InvocationTargetException {
        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();
        BoundSql boundSql = statementHandler.getBoundSql();
        String sql = boundSql.getSql();
        log.debug("prepare~~~~~~~~~~~~~~~begin");
        System.out.println(sql);
        if(StringUtils.isNotEmpty(sql) &amp;&amp; sql.indexOf(schemaPlaceholder)&gt;-1){
            String adminSchema = "mySchema";
            sql = sql.replaceAll(schemaPlaceholder,adminSchema);
            //通过反射回写
            Field sqlNodeField = boundSql.getClass().getDeclaredField("sql");
            sqlNodeField.setAccessible(true);
            sqlNodeField.set(boundSql,sql);
            log.debug("prepare~~~~~~~~~~~~~~~replace");
            log.debug(sql);
        }
        log.debug("prepare~~~~~~~~~~~~~~~end");


        return invocation.proceed();
    }
}

</code></pre> 
<h3><a id="_238"></a>四、结论</h3> 
<p>使用方案二，完美解决了动态替换schame的需求。<br> 项目中使用 Replace in Files 将原来的固定schame名称，替换为 _schemaName 占位符。<br> 代码完美运行！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a6b114fc6aa0dd39d78c457b3d41a376/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">传奇外网架设常见的问题及解决办法-传奇创建人物失败/不开门/PAK显示密码错误/脚本错误</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dd20ed4eb31f2018421cdbdffd53506f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">电力电子技术实验-单相桥式全控整流电路实验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>