<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>多线程与高并发（13）——Java常见并发容器总结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="多线程与高并发（13）——Java常见并发容器总结" />
<meta property="og:description" content="本文总结常见的并发容器，包含ConcurrentHashMap、CopyOnWriteArrayList 、ConcurrentLinkedQueue、BlockingQueue 、ConcurrentSkipListMap，本文仅做简单的总结，不做详细的源码分析。
一、ConcurrentHashMap HashMap不是线程安全的，ConcurrentHashMap是线程安全的。
ConcurrentHashMap的数组结构也是Node 数组 &#43; 链表 / 红黑树，同时它采用的Synchronized 锁加CAS的机制，引用了锁升级的策略，所以性能方面没有太多问题。
在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。
这里不过多总结了，回头单独写一篇文章，从源码理解ConcurrentHashMap。
二、CopyOnWriteArrayList CopyOnWriteArrayList 是一个线程安全且读操作无锁的ArrayList ，ArrayList 是什么呢，查询速度很快，有序且可重复，底层是一个数组。
public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable { 由于日常使用时，读操作远远大于写操作，类似于ReentrantReadWriteLock（读写锁），为了进一步增加读取的效率，这里直接就不给读操作加锁，而且：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。
我们先看读操作源码：
@SuppressWarnings(&#34;unchecked&#34;) private E get(Object[] a, int index) { return (E) a[index]; } public E get(int index) { return get(getArray(), index); } final Object[] getArray() { return array; } 嗯，平平无奇，就是正常获取数组的值。
再看写操作的代码，我们看add的源码：
public boolean add(E e) { final ReentrantLock lock = this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e99da3a18d0ddad2d498c0e094fecf31/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-30T17:24:16+08:00" />
<meta property="article:modified_time" content="2022-11-30T17:24:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">多线程与高并发（13）——Java常见并发容器总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文总结常见的并发容器，包含ConcurrentHashMap、CopyOnWriteArrayList 、ConcurrentLinkedQueue、BlockingQueue 、ConcurrentSkipListMap，本文仅做简单的总结，不做详细的源码分析。</p> 
<h3><a id="ConcurrentHashMap_1"></a>一、ConcurrentHashMap</h3> 
<p>HashMap不是线程安全的，ConcurrentHashMap是线程安全的。<br> ConcurrentHashMap的数组结构也是<strong>Node 数组 + 链表 / 红黑树</strong>，同时它采用的<strong>Synchronized 锁加CAS的机制</strong>，引用了锁升级的策略，所以性能方面没有太多问题。<br> <strong>在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。</strong><br> 这里不过多总结了，回头单独写一篇文章，从源码理解ConcurrentHashMap。</p> 
<h3><a id="CopyOnWriteArrayList_6"></a>二、CopyOnWriteArrayList</h3> 
<p><strong>CopyOnWriteArrayList 是一个线程安全且读操作无锁的ArrayList</strong> ，ArrayList 是什么呢，查询速度很快，有序且可重复，底层是一个数组。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{<!-- --></span>

</code></pre> 
<p>由于日常使用时，读操作远远大于写操作，类似于ReentrantReadWriteLock（读写锁），为了进一步增加读取的效率，这里<strong>直接就不给读操作加锁</strong>，而且：<strong>写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。</strong><br> 我们先看读操作源码：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> array<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>嗯，平平无奇，就是正常获取数组的值。<br> 再看写操作的代码，我们看add的源码：</p> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        <span class="token comment">//加锁</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token comment">//拷贝</span>
            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">//释放锁</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>CopyOnWriteArrayList 我们看名字就知道，在写操作时，进行复制。在复制的副本中进行操作，然后再替换原来的数据，这样就不会阻碍读操作了。上面源码中也是，先加锁，防止复制多个副本，然后操作副本，然后写回原处。<br> 从计算机的角度来看：复制旧内存块，改写新内存，然后指针指向新内存，回收就内存。</p> 
<h3><a id="ConcurrentLinkedQueue_54"></a>三、ConcurrentLinkedQueue</h3> 
<p>ConcurrentLinkedQueue是非阻塞队列，主要使用 CAS 非阻塞算法来实现线程安全。<br> 从名字可以看出，ConcurrentLinkedQueue使用链表作为其数据结构，ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。<br> 这里不作过多的解读了，后续有时间专门出一篇源码总结。</p> 
<h3><a id="BlockingQueue_58"></a>四、BlockingQueue</h3> 
<p>BlockingQueue是阻塞队列。 BlockingQueue 是一个先进先出的队列（Queue），为什么说是阻塞（Blocking）的呢？是因为 BlockingQueue 支持当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。<br> BlockingQueue 在生产者-消费者的场景中，是支持多消费者和多生产者的，说的其实就是线程安全问题。<br> BlockingQueue常用的实现类有：ArrayBlockingQueue、LinkedBlockingQueue 、PriorityBlockingQueue 。</p> 
<blockquote> 
 <p>ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁 ReentrantLock，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。<br> ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到ArrayBlockingQueue。</p> 
</blockquote> 
<p>若想保证公平性，采用代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>LinkedBlockingQueue 底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE 。</p> 
</blockquote> 
<blockquote> 
 <p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。<br> PriorityBlockingQueue 并发控制采用的是可重入锁 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。</p> 
</blockquote> 
<h3><a id="ConcurrentSkipListMap_78"></a>五、ConcurrentSkipListMap</h3> 
<p>ConcurrentSkipListMap表示使用跳表实现map。跳表是什么呢，看下图（图片引用：https://javaguide.cn/java/concurrent/java-concurrent-collections.html#priorityblockingqueue）：<br> <img src="https://images2.imgbox.com/81/fb/k9ghfIw2_o.png" alt="在这里插入图片描述"><br> 跳表的本质是同时维护了多个链表，并且链表是分层的，最底层是所有元素的链表，每上面一层链表都是下面一层的子集。跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。<br> 如果查18的话，本来要查18次，现在只需要查1，7，13，13，17，17，18这7个就行了。<br> 跳表是一种利用空间换时间的算法。<br> 使用跳表实现 Map 和使用哈希算法实现 Map 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。<br> 本文参考：<br> https://javaguide.cn/java/concurrent/java-concurrent-collections.html#concurrentskiplistmap</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d30421aa6ac68e91aa195a2b053084ee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;继承的相关访问归纳</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/91245ea6c60ddb03824ac4605cfb35eb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CIFAR-10 数据集简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>