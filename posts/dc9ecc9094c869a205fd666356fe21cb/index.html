<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker 基本命令使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker 基本命令使用" />
<meta property="og:description" content="文章目录 （一）Docker 基础命令
（二）Docker 镜像命令 （三）Docker 容器命令
（四）Docker 运维命令
本篇文章不仅仅是生硬的命令大全，也是我个人对docker学习使用的一步步总结，通过一个个示例来加深各位看官对docker相关命令的理解以及记忆
（一）Docker 基础命令 systemctl start docker 启动Docker命令
systemctl stop docker 关闭docker
systemctl restart docker 重启docker
systemctl enable docker docker设置随服务启动而自启动
systemctl status docker 查看docker 运行状态（运行中输入命令后会看到绿色的active）
docker version / docker info 查看docker 版本号信息
docker 帮助命令
docker --help 忘记了某些命令便可使用此进行查看与回顾
忘记拉取命令不知道可以带哪些参数 咱可以这样使用
docker pull --help
（二）Docker 镜像命令 Docker官方镜像搜索
docker images 查看自己服务器中docker 镜像列表
docker search 镜像名 搜索镜像 列如：docker search --filter=STARS=9000 mysql 搜索 STARS &gt;9000的 mysql 镜像" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dc9ecc9094c869a205fd666356fe21cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-18T11:16:52+08:00" />
<meta property="article:modified_time" content="2023-03-18T11:16:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker 基本命令使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>文章目录</h2> 
<p>（一）Docker 基础命令</p> 
<p>（二）Docker 镜像命令 </p> 
<p>（三）Docker 容器命令</p> 
<p>（四）Docker 运维命令</p> 
<p>本篇文章不仅仅是生硬的命令大全，也是我个人对<a href="https://so.csdn.net/so/search?q=docker&amp;spm=1001.2101.3001.7020" title="docker">docker</a>学习使用的一步步总结，通过一个个示例来加深各位看官对docker相关命令的理解以及记忆</p> 
<h2>（一）Docker 基础命令</h2> 
<blockquote> 
 <p>systemctl start docker          启动Docker命令<br> systemctl stop docker          关闭docker<br> systemctl restart docker       重启docker<br> systemctl enable docker      docker设置随服务启动而自启动<br> systemctl status docker       查看docker 运行状态（运行中输入命令后会看到绿色的active）<br> docker version        /         docker info   查看docker 版本号信息</p> 
 <p><img alt="" height="486" src="https://images2.imgbox.com/fa/c0/bnyWCyAf_o.png" width="496"></p> 
 <p><strong>docker 帮助命令</strong></p> 
 <p>docker --help                  忘记了某些命令便可使用此进行查看与回顾</p> 
 <p><span style="color:#fe2c24;"><strong>忘记拉取命令不知道可以带哪些参数 咱可以这样使用</strong></span></p> 
 <p>docker pull --help<br><img alt="" height="207" src="https://images2.imgbox.com/c6/10/pfPHvrRo_o.png" width="613"></p> 
</blockquote> 
<h2>（二）Docker 镜像命令 </h2> 
<p><a href="https://hub.docker.com/search?type=image&amp;q=" rel="nofollow" title="      Docker官方镜像搜索">      Docker官方镜像搜索</a></p> 
<blockquote> 
 <p>docker images                        <strong>查看自己服务器中docker 镜像列表</strong></p> 
 <p>docker search 镜像名             <strong>搜索镜像    </strong><br> 列如：docker search --filter=STARS=9000 mysql 搜索 STARS &gt;9000的 mysql 镜像</p> 
 <p><img alt="" height="52" src="https://images2.imgbox.com/79/55/g20lURnF_o.png" width="646"></p> 
 <p>docker pull 镜像名         /         docker pull 镜像名:tag                 </p> 
 <p><strong>拉取镜像 不加tag(版本号) 该镜像的最新版本latest 加:tag 则是拉取指定版本</strong></p> 
 <p></p> 
 <p><strong>docker run 镜像名          /         docker run 镜像名:Tag              运行镜像</strong><br> 运行后出现端口被占用  使用<code> Ctrl+C<strong><span style="color:#fe2c24;">(</span></strong></code><span style="color:#ff0000;">注：此方式虽然可以退出容器，但此种命令操作方式却是错误的，详细缘由请见下文的容器命令<strong>)</strong></span></p> 
 <p></p> 
 <p><strong>docker中 run 命令是十分复杂的 有什么持久运行 映射端口 设置容器别名 数据卷挂载</strong></p> 
 <hr> 
 <p><strong>删除镜像</strong> ------<span style="color:#fe2c24;">当前镜像没有被任何容器使用才可以删除</span></p> 
 <p>docker rmi -f 镜像名/镜像ID                                删除一个</p> 
 <p>docker rmi -f 镜像名/镜像ID 镜像名/镜像ID    删除多个其镜像ID或镜像用用空格隔开即可</p> 
 <p>docker rmi -f $(docker images -aq)        删除全部镜像 -a 意思为显示全部, -q 意思为只显示ID</p> 
 <hr> 
 <p><strong>强制删除镜像</strong></p> 
 <p>docker image rm 镜像名称/镜像ID</p> 
 <p>镜像的基础命令就到这里 下方会使用更复杂的 docker run 命令 来根据镜像启动容器</p> 
 <hr> 
 <p><strong>保存镜像</strong><br> 将我们的镜像 保存为tar 压缩文件 这样方便镜像转移和保存 ,然后 可以在任何一台安装了docker的服务器上 加载这个镜像</p> 
 <p>命令：        docker save 镜像名/镜像ID -o 镜像保存在哪个位置与名字</p> 
 <hr> 
 <p><strong>加载镜像（</strong>任何装 docker 的地方加载镜像保存文件,使其恢复为一个镜像<strong>）</strong></p> 
 <p>命令：        docker load -i                 镜像保存文件位置</p> 
 <p><span style="color:#fe2c24;">加载文件 恢复为镜像</span><br><img alt="" height="91" src="https://images2.imgbox.com/d5/a8/Uh3inZor_o.png" width="531"></p> 
 <p><strong>查看镜像 测试镜像功能是否正常 <span style="color:#fe2c24;">run</span> 一下</strong></p> 
 <p></p> 
 <p> <strong>镜像标签</strong></p> 
 <p><strong>        <span style="color:#38d8f0;">有的时候呢，我们需要对一个镜像进行分类或者版本迭代操作，比如我们一个微服务已经打为docker镜像，但是想根据环境进行区分为develop环境与alpha环境，这个时候呢，我们就可以使用Tag，来进对镜像做一个标签添加，从而行进区分；版本迭代逻辑也是一样，根据不同的tag进行区分</span></strong></p> 
 <p><strong><span style="color:#0d0016;">app:1.0.0 基础镜像<br> # 分离为开发环境<br> app:develop-1.0.0   <br> # 分离为alpha环境<br> app:alpha-1.0.0   </span></strong></p> 
 <p></p> 
 <p><strong><span style="color:#0d0016;">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span></strong></p> 
 <p><strong><span style="color:#0d0016;">docker tag 源镜像名:TAG 想要生成新的镜像名:新的TAG</span></strong></p> 
 <p><strong><span style="color:#0d0016;"># 如果省略TAG 则会为镜像默认打上latest TAG<br> docker tag aaa bbb<br> # 上方操作等于 docker tag aaa:latest bbb:test</span></strong></p> 
 <p></p> 
 <p><strong><span style="color:#0d0016;">如下：</span></strong></p> 
 <p><strong><span style="color:#0d0016;"># 我们根据镜像 quay.io/minio/minio 添加一个新的镜像 名为 aaa 标签Tag设置为1.2.3<br> docker tag quay.io/minio/minio:1.2.3 aaa:1.2.3</span></strong></p> 
 <p><strong><span style="color:#0d0016;"># 我们根据镜像 app-user:1.0.0 添加一个新的镜像 名为 app-user 标签Tag设置为alpha-1.0.0<br> docker tag app-user:1.0.0 app-user:alpha-1.0.0</span></strong><br><img alt="" height="155" src="https://images2.imgbox.com/63/b8/uxfzWFN2_o.png" width="531"></p> 
</blockquote> 
<h2>（三）docker 容器命令</h2> 
<p>  前言已经说了 docker 容器 就好比 咱java中的new出来对象（docker run 镜像 产生一个该镜            像具体容器实例）,docker 容器的启动需要 镜像的支持</p> 
<blockquote> 
 <p>docker  ps                                    查看正在运行的容器列表</p> 
 <p>docker  ps   -a                              查看所有容器（包括正在运行和停止运行的容器）</p> 
 <p>docker stop 容器ID/容器名           停止容器</p> 
 <p>docker restart 容器ID/容器名        启动容器</p> 
 <p>docker kill 容器ID/容器名              kill容器</p> 
 <p>docker rename 容器ID/容器名 新容器名         更换容器名</p> 
 <p><strong>删除容器</strong></p> 
 <p>docker rm -f 容器名/容器ID                           删除一个容器</p> 
 <p>docker rm -f 容器名/容器ID 容器名/容器ID   删除多个容器 空格隔开要删除的容器名或容器ID</p> 
 <p>docker rm -f $(docker ps -aq)                       删除全部容器</p> 
 <p><strong>容器文件拷贝（</strong><span style="color:#fe2c24;">无论容器是否开启 都可以进行拷贝</span><strong>）</strong></p> 
 <p>#docker cp 容器ID/名称:文件路径  要拷贝到外部的路径 |  要拷贝到外部的路径  容器ID/名称:文件路径<br> #从容器内 拷出<br> docker cp 容器ID/名称: 容器内路径  容器外路径<br> #从外部 拷贝文件到容器内<br> docker  cp 容器外路径 容器ID/名称: 容器内路径</p> 
 <p> <strong>查看容器日志</strong></p> 
 <p>docker logs -f --tail=要查看末尾多少行 默认all 容器ID</p> 
 <p>docker logs  容器ID/名称</p> 
 <p><strong>进入容器</strong></p> 
 <p><strong>方式一</strong></p> 
 <p><strong>docker exec -it 容器名/容器ID /bin/bash</strong></p> 
 <p><strong>方式二</strong> （推荐使用 exec 方式）</p> 
 <p>docker attach 容器名/容器ID<br><strong>从容器内 退出到自己服务器中</strong> （<span style="color:#fe2c24;">需注意 两个退出命令的区别</span>）</p> 
 <p>exit        直接退出 未添加 -d(持久化运行容器) 时 执行此参数 容器会被关闭</p> 
 <p>Ctrl + p + q        优雅退出 --- 无论是否添加-d 参数 执行此命令容器都不会被关闭</p> 
 <p></p> 
 <p><span style="color:#fe2c24;">启动容器时，使用</span><span style="color:#38d8f0;">docker run</span><span style="color:#fe2c24;">命令时 添加参数<code>--restart=always</code> 便表示，该容器随docker服务启动而自动启动</span></p> 
 <p><span style="color:#0d0016;">如下：</span></p> 
 <p><span style="color:#0d0016;">docker run -itd --name redis002 -p 8888:6379 --restart=always  redis:5.0.5 /bin/bash</span></p> 
 <p></p> 
 <p><strong>运行容器</strong></p> 
 <p># -it 表示 与容器进行交互式启动 -d 表示可后台运行容器 （守护式运行）  --name 给要运行的容器 起的名字  /bin/bash  交互路径<br> docker run -it -d --name 要取的别名 镜像名:Tag /bin/bash </p> 
 <p>如下：</p> 
 <p>启动一个redis 把它的别名取为redis001 并交互式运行 需要的命令 —我这里指定版本号为5.0.5</p> 
 <p>#1. 拉取redis 镜像<br> docker pull redis:5.0.5<br> #2.命令启动<br> docker run -it -d --name redis001 redis:5.0.5 /bin/bash<br><img alt="" height="44" src="https://images2.imgbox.com/40/e8/LQNJk2Dz_o.png" width="785"><br> redis 使用了6379 端口 那么我们在关闭防火墙或开启了安全组的情况下 是否可以进行访问</p> 
 <p></p> 
 <p>为了 区分 咱们使用linux 命令 查看一下</p> 
 <p># <span style="color:#fe2c24;">netstat</span>是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息<br> netstat -untlp</p> 
 <p><img alt="" height="148" src="https://images2.imgbox.com/ad/66/qSY083zx_o.png" width="771"></p> 
 <p> <strong>可以发现redis容器启动占用的 6379端口netstat 没有显示出来使用 redis desktop manger 连接测试一下</strong></p> 
 <p><img alt="" height="455" src="https://images2.imgbox.com/17/26/9Qhc8274_o.png" width="430"></p> 
 <p><strong>为什么不行呢 已经确定了 docker 中 redis 容器已经是在运行中 且占有端口 6379啊？</strong></p> 
 <p><strong>因为：占用的6379端口 仅仅是在容器中内部本身的端口,与宿主机的6379端口并无联系，我们通过宿主机Ip:6379访问此redis示例，那自然是找不到的哟！</strong></p> 
 <hr> 
 <p><strong>这里，来补充一点Docker容器的知识！</strong></p> 
 <p><strong><span style="color:#ff0000;">每一个 Docker容器都是独立和安全的应用平台（我们可以理解为，每一个docker容器都相当于在我们的服务器上占用资源然后开辟了属于自己的一个空间（也可以理解为服务器））</span></strong></p> 
 <p><img alt="" height="241" src="https://images2.imgbox.com/8b/b9/G0mQyQBP_o.png" width="741"></p> 
 <p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;"><strong>这是Docker 一大特点，每个容器之间环境都是隔离的!!!</strong></span></span></p> 
 <p>我们甚至可以在一个服务器上，使用docker镜像，来跑出N个 mysql实例（尽管，他们的默认端口都是一样的，但还是那句话，容器间，环境是隔离的。A容器中的3306 与B容器的3306毫无关系，因为其不在一个世界呀!）</p> 
 <p></p> 
 <p><span style="color:#fe2c24;"><strong>默认情况下，我们是无法通过宿主机（安装docker的服务器）端口来直接访问容器的 ,因为docker容器自己开辟空间的端口与宿主机端口没有联系…</strong></span></p> 
 <p></p> 
 <p>如果外部想要访问容器，那必须得让容器中的端口与宿主机的端口建立联系绑定起来，这个正式的概念叫做 容器端口映射</p> 
 <p></p> 
 <p>有了端口映射，我们就可以将宿主机端口与 容器端口绑定起来，比如 我们建立宿主机的6379端口与容器redis6379端口绑定起来，那么再访问宿主机Ip:6379 就可以访问到对应容器了！</p> 
 <hr> 
 <p>docker stop 容器名/容器ID        <strong>停止容器</strong></p> 
 <p><img alt="" height="91" src="https://images2.imgbox.com/b8/a4/tgqYEKar_o.png" width="531"></p> 
 <p><strong>删除容器</strong></p> 
 <p>docker rm -f 容器名/容器ID                           删除一个容器</p> 
 <p>docker rm -f 容器名/容器ID 容器名/容器ID   删除多个容器 空格隔开要删除的容器名或容器ID</p> 
 <p>docker rm -f $(docker ps -aq)                       删除全部容器</p> 
 <p></p> 
 <p><strong>容器端口与服务器端口映射</strong></p> 
 <p>-p 宿主机端口:容器端口                                 命令</p> 
 <p></p> 
 <p>还是使用前方的 redis 镜像 尝试 将6379端口 映射到服务器的8888 如果成功了的话 那么咱们访问服务器的8888端口就会访问到咱们的 docker 中 的容器 redis002</p> 
 <p></p> 
 <p>-p 8888:6379 解析 将容器内部的 6379端口与docker 宿主机（docker装在哪台服务器 哪台服务器就是宿主机）8888 端口进行映射 那通过外部访问宿主机8888端口 即可访问到 docker 容器 6379 端口了</p> 
 <p><br> docker run -itd --name redis002 -p 8888:6379 redis:5.0.5 /bin/bash<br><img alt="" height="303" src="https://images2.imgbox.com/4b/f5/yZBpd4WG_o.png" width="1016"></p> 
 <p>在运行后 发现服务器的 8888 端口显示已被docker-proxy 所占用了</p> 
 <p><img alt="" height="479" src="https://images2.imgbox.com/66/1f/thxs1boH_o.png" width="628"></p> 
 <p></p> 
 <p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;"><strong><span style="color:#ff0000;">那么容器端口映射有没有什么限制呢？</span></strong></span></span></p> 
 <p style="margin-left:0;"></p> 
 <p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;"><span style="color:#ffa500;">有的，虽说每个容器之间，环境都是隔离的，但是宿主机每个端口都是一个，8888端口被redis002容器绑定了，那么其他所有的容器都不可以使用8888这个端口了!!!</span></span></span></p> 
 <hr> 
 <p><strong>进入容器方式一</strong></p> 
 <p><strong>docker exec -it 容器名/容器ID /bin/bash</strong></p> 
 <p><strong>进入容器方式二</strong> （推荐使用 exec 方式）</p> 
 <p>docker attach 容器名/容器ID<br><strong>从容器内 退出到自己服务器中</strong> （<span style="color:#fe2c24;">需注意 两个退出命令的区别</span>）</p> 
 <p>exit        直接退出 未添加 -d(持久化运行容器) 时 执行此参数 容器会被关闭</p> 
 <p>Ctrl + p + q        优雅退出 --- 无论是否添加-d 参数 执行此命令容器都不会被关闭</p> 
 <hr> 
 <p><span style="color:#fe2c24;">启动容器时，使用</span><span style="color:#38d8f0;">docker run</span><span style="color:#fe2c24;">命令时 添加参数<code>--restart=always</code> 便表示，该容器随docker服务启动而自动启动</span></p> 
 <p><span style="color:#0d0016;">如下：</span></p> 
 <p><span style="color:#0d0016;">docker run -itd --name redis002 -p 8888:6379 --restart=always  redis:5.0.5 /bin/bash</span></p> 
 <p></p> 
 <p><strong>这个时候有小伙伴着急了，我都已经启动一个容器好久了，跑了很多数据了，现在才告诉我可以设置自启动？我把容器删了再启动，我数据咋办？？？</strong></p> 
 <p></p> 
 <p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;"><strong><span style="color:#ff0000;">方法一：担心数据丢了，这说明你在跑容器的时候没有进行数据挂载吧？？？</span></strong></span></span></p> 
 <p style="margin-left:0;"><span style="color:#38d8f0;">简单来讲，就是将容器内的数据与外部宿主机文件绑定起来，类似一个双持久化，当容器删除时，宿主机文件数据目录仍在，下次启动容器只要将数据目录指向宿主机数据所在位置即可恢复！</span></p> 
 <p style="margin-left:0;">具体请参考：<a href="https://blog.csdn.net/leilei1366615/article/details/106269231" title="docker 文件分层与数据卷挂载">docker 文件分层与数据卷挂载</a></p> 
 <hr> 
 <p style="margin-left:0;">命令:        -v 宿主机文件存储位置:容器内文件位置</p> 
 <p><strong>如此操作，就将 容器内指定文件挂载到了宿主机对应位置，-v命令可以多次使用，即一个容器可以同时挂载多个文件</strong></p> 
 <p><span style="color:#fe2c24;">-v 宿主机文件存储位置:容器内文件位置 -v 宿主机文件存储位置:容器内文件位置 -v 宿主机文件存储位置:容器内文件位置</span><br> 如下：</p> 
 <p># 运行一个docker redis 容器 进行 端口映射 两个数据卷挂载 设置开机自启动<br> docker run -d -p 6379:6379 --name redis505 --restart=always  -v /var/lib/redis/data/:/data -v /var/lib/redis/conf/:/usr/local/etc/redis/redis.conf  redis:5.0.5 --requirepass "password"</p> 
 <p><strong>此方法完了你很无语？那还不是得删容器？是呀！没错！那么为什么你有数据恢复需求而没有想到数据持久化，数据恢复备份，数据卷挂载？自己DEMO的吃亏，是为了平时开发少扣脑壳多摸鱼！</strong></p> 
 <p><strong><span style="color:#ff0000;">方法二：不想删容器，又想让这个容器设置开机自启动，那么我们修改其启动配置即可！</span></strong></p> 
 <p><strong><span style="color:#ff0000;">docker  update --restart=always 容器Id 或者 容器名  </span></strong><strong><span style="color:#ff0000;">或    </span></strong><strong><span style="color:#ff0000;">docker container update --restart=always 容器Id 或者 容器名</span></strong></p> 
 <p>如上，虽然不删容器就设置了自启动需求满足了，但是，危不危险，这个容器有没有需要数据恢复的情况？自己考量吧！！！</p> 
 <p><strong>更换容器名        </strong>docker rename 容器ID/容器名 新容器名</p> 
 <p><img alt="" height="139" src="https://images2.imgbox.com/2d/5f/sYK8MmRG_o.png" width="784"></p> 
</blockquote> 
<h2><strong>（四）Docker 运维命令</strong></h2> 
<blockquote> 
 <p><strong>查看docker工作目录                        sudo docker info | grep "Docker Root Dir"</strong><br><strong>查看docker磁盘占用总体情况          du -hs /var/lib/docker/ </strong></p> 
 <p><strong>查看Docker的磁盘使用具体情况      docker system df</strong></p> 
 <p><strong>删除 无用的容器和 镜像   如下：      </strong></p> 
 <p><strong>#  删除异常停止的容器<br> docker rm `docker ps -a | grep Exited | awk '{print $1}'` <br>  <br> #  删除名称或标签为none的镜像<br> docker rmi -f  `docker images | grep '&lt;none&gt;' | awk '{print $3}'`</strong></p> 
 <p></p> 
 <p><strong>清除所有无容器使用的镜像（</strong>此命令只要是镜像无容器使用（容器正常运行）都会被删除，包括容器临时停止<strong>）</strong></p> 
 <p>docker system prune -a</p> 
 <p></p> 
 <p><strong>查找大文件                                                            find / -type f -size +100M -print0 | xargs -0 du -h | sort -nr</strong></p> 
 <p><strong>查找指定docker使用目录下大于指定大小文件     find / -type f -size +100M -print0 | xargs -0 du -h | sort -nr |grep '/var/lib/docker/overlay2/*'</strong></p> 
</blockquote> 
<hr> 
<p> 本文章参考：<a href="https://blog.csdn.net/leilei1366615/article/details/106267225" title="博客">博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fbbdd1055a16c585f3cac2581a35ae9b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NLP(VII)：使用sklearn进行文本情感分类（下）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/510f0be52b4e445fb56cbfc0fe2d3e50/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】还不懂算法复杂度？一文带你速解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>