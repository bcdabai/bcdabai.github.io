<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>盘点一下PostgreSQL和MySQL的区别点 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="盘点一下PostgreSQL和MySQL的区别点" />
<meta property="og:description" content="上期有说，数据环境切换，由MySQL换成PostgreSQL。
那么为了大家以后少踩坑，简单总结了下我曾踩过的坑和需要注意的点。
首先PostgreSQL有一个模式的概念。
一、格式区别：
和Oracle一样,PostgreSQL也是严格区分大小写。
二、符号区别：
和Oracle一样PostgreSQL中，&#34; &#34; 双引号是区分库名，关键字等，而MySQL则是反单引号(tab键上方的键)，pg查询时字符类型的字段必须使用单引号，而MySQL带有优化器（不是必须）。
三、自增区别：
MySQL中使用auto_increment ，在需要的列指定自增，而pg中需要设置自增序列。
（1）使用SQL语句
①创建表时
CREATE table infisa_template_config(id serial ); ②表已存在
&lt;--设置序列从1开始，自增1--&gt; CREATE SEQUENCE user_id_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1; &lt;--设置序列--&gt; ALTER table user ALTER column id SET DEFAULT nextval(&#39;user_id_seq&#39;); (2)使用可视化工具
连接navicat15（或者使用DBeaver）
点击序列
可以通过可视化界面新建序列
注：同步数据的话，推荐通过sql方式新建序列。
四、函数区别：
(1)时间转化
①时间转字符串：
MySQL: date_format(a.tag_create_date,‘%Y-%m-%d %H:%i:%s’)
PostgreSQL: to_char(a.tag_create_date,‘yyyy-mm-dd HH:MM:SS’)
②字符串转时间：
MySQL: date_format(a.tag_create_date,‘%Y-%m-%d %H:%i:%s’)
PostgreSQL: to_date(a.tag_create_date,‘yyyy-mm-dd HH:MM:SS’)
(2) IFNULL()函数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7203fa6fd74b1da33c20220b4b944567/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-10T14:22:52+08:00" />
<meta property="article:modified_time" content="2022-11-10T14:22:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">盘点一下PostgreSQL和MySQL的区别点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>上期有说，数据环境切换，由MySQL换成PostgreSQL。<br> 那么为了大家以后少踩坑，简单总结了下我曾踩过的坑和需要注意的点。<br> 首先PostgreSQL有一个模式的概念。<br> <strong>一、格式区别：</strong></p> 
<p>和Oracle一样,PostgreSQL也是严格区分大小写。</p> 
<p><strong>二、符号区别：</strong></p> 
<p>和Oracle一样PostgreSQL中，" " 双引号是区分库名，关键字等，而MySQL则是<code>反单引号</code>(tab键上方的键)，pg查询时字符类型的字段必须使用单引号，而MySQL带有优化器（不是必须）。</p> 
<p><strong>三、自增区别：</strong></p> 
<p>MySQL中使用auto_increment ，在需要的列指定自增，而pg中需要设置自增序列。</p> 
<p>（1）使用SQL语句<br> ①创建表时</p> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">table</span> infisa_template_config<span class="token punctuation">(</span>id <span class="token keyword">serial</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>②表已存在</p> 
<pre><code class="prism language-sql"><span class="token operator">&lt;</span><span class="token comment">--设置序列从1开始，自增1--&gt;</span>
<span class="token keyword">CREATE</span> SEQUENCE user_id_seq <span class="token keyword">START</span> <span class="token keyword">WITH</span> <span class="token number">1</span>  
INCREMENT <span class="token keyword">BY</span> <span class="token number">1</span>  <span class="token keyword">NO</span> MINVALUE  <span class="token keyword">NO</span> MAXVALUE  CACHE <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token comment">--设置序列--&gt;</span>
<span class="token keyword">ALTER</span> <span class="token keyword">table</span> <span class="token keyword">user</span> <span class="token keyword">ALTER</span> <span class="token keyword">column</span> id <span class="token keyword">SET</span> <span class="token keyword">DEFAULT</span> nextval<span class="token punctuation">(</span><span class="token string">'user_id_seq'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>(2)使用可视化工具<br> 连接navicat15（或者使用DBeaver）<br> <img src="https://images2.imgbox.com/ce/93/jVnqQvTi_o.png" alt="在这里插入图片描述"><br> 点击序列<br> <img src="https://images2.imgbox.com/f3/07/ahoUbLsc_o.png" alt="在这里插入图片描述"><br> 可以通过可视化界面新建序列<br> <img src="https://images2.imgbox.com/5f/fd/3UkLq4Of_o.png" alt="在这里插入图片描述"><br> 注：同步数据的话，推荐通过sql方式新建序列。</p> 
<p><strong>四、函数区别：</strong><br> <strong>(1)时间转化</strong></p> 
<p>①时间转字符串：</p> 
<p>MySQL: date_format(a.tag_create_date,‘%Y-%m-%d %H:%i:%s’)</p> 
<p>PostgreSQL: to_char(a.tag_create_date,‘yyyy-mm-dd HH:MM:SS’)</p> 
<p>②字符串转时间：</p> 
<p>MySQL: date_format(a.tag_create_date,‘%Y-%m-%d %H:%i:%s’)</p> 
<p>PostgreSQL: to_date(a.tag_create_date,‘yyyy-mm-dd HH:MM:SS’)</p> 
<p><strong>(2) IFNULL()函数</strong></p> 
<p>MySQL: IFNULL(a.idm,‘’)</p> 
<p>PostgreSQL: COALESCE(a.id,‘’)</p> 
<p><strong>(3) sysdate()函数</strong></p> 
<p>MySQL: SELECT sysdate()</p> 
<p>PostgreSQL: SELECT now()</p> 
<p><strong>(4) find_in_set()函数（允许在逗号分隔的字符串列表中查找指定字符串的位置）</strong></p> 
<p>MySQL: SELECT t.dept_id FROM sys_dept t WHERE find_in_set(‘100’, ancestors)</p> 
<p>PostgreSQL: SELECT t.dept_id FROM sys_dept t WHERE ‘100’ = ANY (string_to_array(ancestors, ‘,’))</p> 
<p><strong>(5)group_concat()函数</strong></p> 
<p>MySQL: select a.name,group_concat(distinct city)from user_city a group by a.name;</p> 
<p>PostgreSQL: select a.name,array_to_string(array_agg(distinct a.city),‘,’)from user_city a group by a.name;</p> 
<p><strong>(6)LIMIT</strong></p> 
<p>MySQL: select id,name from hospital.ods_user_basic limit 10,2;</p> 
<p>PostgreSQL: select id,name from hospital.ods_user_basic limit 10 offset 2;</p> 
<p><strong>（7）DISTINCT</strong></p> 
<p>MYSQL: select DISTINCT b.id from hospital.ods_user_basic as b</p> 
<p>PostgreSQL: select DISTINCT ON (b.id) b.* from hospital.ods_user_basic as b</p> 
<p>(注：pg中祛重+排序 ，使用distinct on (列1) order by 列1 )</p> 
<p>（8）MyBatis-Plus整合MySQL、PostgreSQL，LIKE使用<br> MySQL：</p> 
<pre><code class="prism language-xml">	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkReportPage<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reportResultMap<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
       SELECT
       *
       FROM
       infisa_medical_report
       WHERE is_deleted=0 AND status = 1 AND name LIKE concat('%',#{handleTask.name},'%')
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>PostgreSQL:</p> 
<pre><code class="prism language-xml">	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkReportPage<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reportResultMap<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
       SELECT
       *
       FROM
       infisa_medical_report
       WHERE is_deleted=0 AND status = 1 AND name like concat('%',#{handleTask.name}::varchar,'%')
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>（注：pg必须指定模糊查询列的数据类型，否则会报错）</p> 
<p><strong>五、数据类型转化（针对于PostgreSQL）：</strong><br> MySQL、Oracle等都是默认对数据类型进行了隐式的转换，在其他数据库varchar等字符串类型和数字可以进行自动的隐式转换，但是PG确没有这么处理，官方文档中也有针对pg的数据转换方式。</p> 
<p><strong>解决办法：</strong><br> <strong>①强转（在查询字段上指定数据类型）</strong></p> 
<p>a.a1 = b.b1::int8 或者 a.a1::varchar = b.b1</p> 
<p><strong>②隐式类型转化（创建类型转换）</strong></p> 
<p>–注:创建cast需要有pg_cast系统表的权限<br> –注:当创建类型转换使用自动隐式转换的话如果出现多个匹配的转换此时pg会因为不知道选择哪一个去处理类型转换而报错，<br> –如果出现多个隐式自动转换都匹配此时还是需要手动添加转换以达到效果，或者删除多余的类型转换<br> CREATE CAST (INTEGER AS VARCHAR) WITH INOUT AS IMPLICIT;<br> CREATE CAST (VARCHAR AS INTEGER) WITH INOUT AS IMPLICIT;<br> CREATE CAST (BIGINT AS VARCHAR) WITH INOUT AS IMPLICIT;<br> CREATE CAST (VARCHAR AS BIGINT) WITH INOUT AS IMPLICIT;</p> 
<p>附：<br> <strong>③查询当前类型转化：</strong></p> 
<p>–这个查询是当前所有的CAST，具体字段的定义同样可以参阅PG数据库官方文档里的描述<br> select<br> (select typname from pg_type where oid = t.castsource) as “castsource”,<br> (select typname from pg_type where oid = t.casttarget) as “casttarget”,<br> castcontext,<br> castmethod<br> from pg_cast as t</p> 
<p><strong>④删除类型转化：</strong></p> 
<p>DROP CAST (varchar as bigint); DROP CAST (bigint as varchar);</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/beaf73055073af50b774c829ba7f1485/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flink中的窗口函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bed7988335ba2c0631fe31897550ef65/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mAP@0.5与mAP@0.5:0.95的含义</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>