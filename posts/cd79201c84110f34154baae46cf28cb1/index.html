<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Cross ViT - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Cross ViT" />
<meta property="og:description" content="1、为什么要用Multi-Scale的ViT？
patch大小会影响ViT的准确性和复杂性；具有细粒度的patch大小，ViT性能更好，但会导致更高的FLOPs和显存消耗。例如，patch大小为16的ViT比patch大小为32的ViT好6%，但前者需要更多4×的FLOPs。
受此启发，作者提出的方法是利用来自更细粒度的patch大小的优点，同时平衡复杂性。更具体地说，作者首先引入了一个双分支ViT，其中每个分支处理不同patch大小的特征，然后采用一个简单而有效的模块来融合分支之间的信息。
此图为Cross-Attention Multi-Scale Vision Transformer，即CrossViT的网络结构。模型主要由K个多尺度Transformer编码器组成，其中每个编码器由两个分支组成：
L-Branch ：
大分支利用粗粒度的patch大小(Pl)，更多的Transformer编码器和更大的embedding维度。
S-Branch ：
小分支对细粒度的patch大小(Ps))进行操作，具有更少的编码器和更小的embedding维度。
两个分支的输出特征在Cross-Attention中融合L次，利用末端的两个分支对CLS token进行预测。对于两个分支的每个token，作者还在多尺度Transformer编码器之前添加了一个可学习的位置embedding，以学习位置信息。
2、多尺度特征融合：
有效的特征融合是学习多尺度特征表示的关键。在本文中作者探索了四种策略：
（a）All-Attention Fusion是简单地concat来自两个分支的所有token，而不考虑每个token的属性。因为所有的token都是通过自注意模块计算的，其时间复杂度也是跟输入特征大小呈二次关系。
（b）Class Token Fusion只将 CLS Token 融合，因为它可以被视为一个分支的全局表示。
（c）Pairwise Fusion成对融合，根据它们的空间位置将它们合并。其中相对应空间位置的 Token 融合在一起，CLS Token 则分别融合。但是，这两个分支处理不同大小的patch，因此具有不同数量的patch token。因此作者首先执行插值操作来对齐空间大小，然后以成对的方式融合两个分支的patch token。
（d）Cross-attentions Fusion交叉注意力，将来自一个分支的 CLS Token 和来自另一个分支的 Patch Token 融合在一起。为了更有效地融合多尺度特征，作者首先利用每个分支的CLS token作为代理，在另一个分支的patch token之间交换信息，然后将其投影到自己的分支。
由于CLS token已经学习了自己分支中所有patch token之间的抽象信息，因此与另一个分支中的patch token的交互有助于融合不同尺度的信息。与其他分支token融合后，CLS token在下一层Transformer编码器上再次与自己的patch token交互，在这一步中，它又能够将来自另一个分支的学习信息传递给自己的patch token，以丰富每个patch token的表示。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cd79201c84110f34154baae46cf28cb1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-06T23:51:08+08:00" />
<meta property="article:modified_time" content="2023-02-06T23:51:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Cross ViT</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="">1、为什么要用Multi-Scale的ViT？</p> 
 <p style=""> patch大小会影响ViT的准确性和复杂性；具有细粒度的patch大小，ViT性能更好，但会导致更高的FLOPs和显存消耗。例如，patch大小为16的ViT比patch大小为32的ViT好6%，但前者需要更多4×的FLOPs。</p> 
 <p style="">受此启发，作者提出的方法是利用来自更细粒度的patch大小的优点，同时平衡复杂性。更具体地说，作者首先引入了一个<span class="kdocs-bold" style="font-weight:bold;">双分支ViT</span>，其中每个分支处理<span class="kdocs-bold" style="font-weight:bold;">不同patch大小</span>的特征，然后采用一个简单而有效的模块来<span class="kdocs-bold" style="font-weight:bold;">融合</span>分支之间的信息。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:496px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:120.76613%;height:0;"> 
    <img src="https://images2.imgbox.com/c2/71/7my0L3zv_o.png" style="margin-left:;display:block;width:496px;margin-top:-120.76613%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">此图为Cross-Attention Multi-Scale Vision Transformer，即CrossViT的网络结构。模型主要由K个多尺度Transformer编码器组成，其中每个编码器由两个分支组成：</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">L-Branch ：</span></p> 
 <p style="">大分支利用粗粒度的patch大小(Pl)，更多的Transformer编码器和更大的embedding维度。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">S-Branch ：</span></p> 
 <p style="">小分支对细粒度的patch大小(Ps))进行操作，具有更少的编码器和更小的embedding维度。</p> 
 <p style="">两个分支的输出特征在<span class="kdocs-bold" style="font-weight:bold;">Cross-Attention</span>中融合L次，利用末端的两个分支对CLS token进行预测。对于两个分支的每个token，作者还在多尺度Transformer编码器之前添加了一个可学习的<span class="kdocs-bold" style="font-weight:bold;">位置embedding</span>，以学习位置信息。</p> 
 <p style="text-align:left;">2、多尺度特征融合：</p> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">有效的特征融合</span>是学习多尺度特征表示的关键。在本文中作者探索了四种策略：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1306px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:20.214396%;height:0;"> 
    <img src="https://images2.imgbox.com/71/4f/8yl1ZfzV_o.png" style="margin-left:;display:block;width:1306px;margin-top:-20.214396%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">（a）All-Attention Fusion</span>是简单地<span class="kdocs-bold" style="font-weight:bold;">concat</span>来自两个分支的<span class="kdocs-bold" style="font-weight:bold;">所有</span>token，而不考虑每个token的属性。因为所有的token都是通过自注意模块计算的，其时间复杂度也是跟<span class="kdocs-bold" style="font-weight:bold;">输入特征大小呈二次关系</span>。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">（b）Class Token Fusion</span>只将 CLS Token 融合，因为它可以被视为一个分支的全局表示。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">（c）Pairwise Fusion</span>成对融合，根据它们的<span class="kdocs-bold" style="font-weight:bold;">空间位置</span>将它们合并。其中相对应空间位置的 Token 融合在一起，CLS Token 则分别融合。但是，这两个分支处理不同大小的patch，因此具有不同数量的patch token。因此作者首先执行<span class="kdocs-bold" style="font-weight:bold;">插值操作</span>来对齐空间大小，然后以成对的方式融合两个分支的patch token。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">（d）Cross-attentions Fusion交叉注意力</span>，将来自一个分支的 CLS Token 和来自另一个分支的 Patch Token 融合在一起。为了更有效地融合多尺度特征，作者首先利用每个分支的CLS token作为代理，在另一个分支的patch token之间交换信息，然后将其投影到自己的分支。</p> 
 <p style="">由于CLS token已经学习了自己分支中所有patch token之间的抽象信息，因此与另一个分支中的patch token的交互有助于融合不同尺度的信息。与其他分支token融合后，CLS token在下一层Transformer编码器上再次与自己的patch token交互，在这一步中，它又能够将来自另一个分支的学习信息传递给自己的patch token，以丰富每个patch token的表示。</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:56.216217%;height:0;"> 
    <img src="https://images2.imgbox.com/bd/9d/nXt3Tgay_o.png" style="margin-left:;display:block;width:740px;margin-top:-56.216217%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/176eb08a09bb2755f880302cc76387ef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">web前端设计模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2961518ee85606f0288ef878b1505579/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">(十四) Docker容器重量级监控: CAdvisor&#43;InfluxDB&#43;Granfana</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>