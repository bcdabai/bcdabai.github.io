<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>场景文字的两类检测算法综述---基于回归和分割的方法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="场景文字的两类检测算法综述---基于回归和分割的方法" />
<meta property="og:description" content="系列文章目录 文章目录 系列文章目录前言一、目标检测目标检测中几个基础概念边界框（bounding box）锚框（Anchor box）交并比 文本检测 基于目标检测的算法 二、图像分割文本检测基于图像分割的算法 前言 # 引言
自然场景文本检测识别（Scene Text Recognition, STR）是计算机视觉中的一个重要领域。它在图像搜索，即时翻译和机器人导航等应用中有着至关重要的作用：例如识别照片和视频中的标志、路牌、商店名称等。相比于发展成熟的文档文本识别技术（OCR），STR显然更具挑战性。OCR善于识别平面上的白纸黑字，而自然场景中的文本具有复杂的光照、遮挡、角度、字体和3D阴影。
需要大致提及一下目标检测和图像分割基础知识
一、目标检测 目标检测任务，就是在图像中检测出物体的存在、位置与类别。目标检测的主流算法分为两步法和一步法两种。
（1） 两步法
在两步法中，我们需要首先找出目标存在的区域，再将该区域的内容识别出来。我们也可以理解为从一张大图片中先截出各个目标的小图片，再对小图片做图像分类任务。但实际操作中，由于检测目标的存在位置与小图片的识别都需要多层卷积神经网络得到的语义信息，因此这两个任务可以共享一个骨干卷积神经网络，得到了卷积层语义特征后，再分别用于后续的子任务。
在检测目标存在和位置的任务中，我们需要输出矩形目标框的位置，通常使用预设锚框的方法。我们对卷积层上的每个像素点，预设好几个不同大小和长宽比的目标框提案，我们称之为锚框。在Faster RCNN中，作者使用了三种大小和三种长宽比，一共九种锚框。这些锚框代表着我们预设的目标可能存在的区域。在骨干网络的基础之上，我们预测每个锚框对应于目标或背景的二分类概率和锚框相对于真实目标框的位置偏差。例如，Faster RCNN中额外增加3x3和1x1卷积层，最终的1x1卷积层使用6N个卷积核，N=9为锚框的种类数。对于每一个锚框，我们分别输出该锚框是目标和背景的概率（2N），该锚框与真实锚框中心位置在x和y方向的偏差(2N)，和该锚框与真实锚框长和宽的偏差(2N)。拥有这些信息之后，我们便可以取概率大的锚框并修正其位置大小作为模型的预测结果。另外，除了预设锚框的方法以外，还可以直接预测每个像素点到目标框上下左右的距离。
在得到了目标所在区域后，我们需要将该区域输入到识别网络做图像分类。然而，由于图像识别网络通常需要固定长宽的输入窗格，而目标区域的形状千差万别，我们需要将目标区域通过ROI Pooling或ROI Align转化为符合识别网络要求的大小。在这一过程中，我们通常保持目标区域的纵横比不变，确定缩放比例使得目标区域的长边与窗格的短边对齐，对于目标区域短边的方向则通过补零以对齐窗格。假设原目标区域比窗格大，在ROI Pooling中，窗格中的每一个格点对应原目标区域中多个格点，我们用极大值或平均值聚合再用极大值或平均值来聚合这多个格点的值；在ROI Align中，我们先将窗格中的格点坐标线性映射到原目标区域，由于映射后的点很可能不在目标区域的格点上，我们使用插值法得到该位置的值。
目标检测中几个基础概念 边界框（bounding box） 检测任务需要同时预测物体的类别和位置，因此需要引入一些跟位置相关的概念。通常使用边界框（bounding box，bbox）来表示物体的位置，边界框是正好能包含物体的矩形框，如 所示，图中3个人分别对应3个边界框。
注意
在阅读代码时，请注意使用的是哪一种格式的表示方式。 图片坐标的原点在左上角，x轴向右为正方向，y轴向下为正方向。 锚框（Anchor box） 锚框与物体边界框不同，是由人们假想出来的一种框。先设定好锚框的大小和形状，再以图像上某一个点为中心画出矩形框。在下图中，以像素点[300, 500]为中心可以使用下面的程序生成3个框，如图中蓝色框所示，其中锚框A1跟人像区域非常接近。
在目标检测模型中，通常会以某种规则在图片上生成一系列锚框，将这些锚框当成可能的候选区域。模型对这些候选区域是否包含物体进行预测，如果包含目标物体，则还需要进一步预测出物体所属的类别。还有更为重要的一点是，由于锚框位置是固定的，它不大可能刚好跟物体边界框重合，所以需要在锚框的基础上进行微调以形成能准确描述物体位置的预测框，模型需要预测出微调的幅度。在训练过程中，模型通过学习不断的调整参数，最终能学会如何判别出锚框所代表的候选区域是否包含物体，如果包含物体的话，物体属于哪个类别，以及物体边界框相对于锚框位置需要调整的幅度。
交并比 文本检测 基于目标检测的算法 这一类算法在骨干卷积网络的基础上，增加卷积层提出文本框提案，再执行两个子任务：判断提案对应于文本的概率和回归调节正样本提案的位置。文本框提案既可通过预设锚框的方式（如PRPN，TextBoxes&#43;&#43;），也可通过直接预测的方式（如EAST，ABCNet）。相比于常规的目标检测，文本目标通常为长条形、具有较大的纵横比，而且可能存在旋转歪斜的情况。因此，此类算法通常使用扁平竖高的文本框、旋转文本框或者直接使用多边形文本框，从而可以判别歪斜的文本。
RRPN
TextBoxes&#43;&#43;
EAST
ABCNet
例如，在TextBoxes&#43;&#43;中，作者预设了一系列长宽比为1，2，3，5，1/2，1/3，1/5的锚框以刻画不同形状的文本。在骨干网络的基础上，模型增加了卷积层输出每个位置上每个锚框对应于文本的概率和位置回归。图中的绿色和黑色虚线都是预设的锚框，绿色对应于正例而黑色对应于负例。在对正例做位置回归时，模型同时执行两个任务，一个是计算最小的包含文本的四边形（黄色实线）的顶点坐标相对于锚框的位置偏移，如图中红线所示；另一个是计算最小的包含文本的水平矩形（绿色实线）相对于锚框的位置偏移。这两个任务可以用于不同的应用。
二、图像分割 图像分割任务的与目标检测非常类似，目的在于找出图片中的各种目标。然而不同之处在于，目标检测需要输出矩形目标框，而图像分割需要找出所有对应于相同目标的像素点。
图像分割任务同样需要卷积神经网络输出的深层语义特征，因此它通常也在骨干卷积网络的基础上，增加一个任务。以Mask RCNN为例，模型在识别网络增加一个子任务，用少量卷积层，对每一个目标类生成一个二值的mapping，判断每一个像素点是否属于该目标类。模型最后采用识别网络的识别结果类对应的mapping作为图像分割任务的输出。
文本检测基于图像分割的算法 第二类算法的研究者认为，使用预设形状的文本框无法很好地描述某些特殊形状的文本（如纵横比过大或者弧形）。他们受图像分割工作的启发，另辟蹊径，先从像素层面做分类，判别每一个像素点是否属于一个文本目标和它与周围像素的连接情况，再将相邻像素结果整合为一个文本框。这种做法可以适应任何形状和角度的文本，典型代表有pixelLink，CRAFT等。
pixelLink
CRAFT
由于场景文字的大小形状的多样，使用基于分割的检测方法往往更好，但是大部分基于分割的方法需要复杂的后处理将像素级别的结果组合成文字行，在预测时开销往往很大。例如PSENet使用连续尺度扩张的方式后处理；LSAE计算像素之间的特征距离来聚类。这里具体介绍一下DB net 网络结构。
大部分检测模型用上图的方式做后处理（蓝色箭头）。第一种，设置一个固定的阈值，把分割图转化成二值化图，然后用一些启发式的方法例如聚类把像素处理成文字行；而作者的方法（红色箭头），把二值化的操作放到网络里面同时优化，这样每个像素点的阈值都可以自适应地预测，这样就可以更好地区分前景与背景。常规的二值化方法是不可微的，DB提出了Differentiable Binarization，一种近似的方法来做二值化，这种方法在与分割网络一起使用时是完全可微的。
DB module有四个优点：
1.作者的模型在5个基准数据集上表现得更好，包括处理横向、纵向和卷曲文字。
2.作者的模型比之前的方法快得多，得益于DB可以生成高可靠的二值图，显著地简化了后处理。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/09e6f76a02abeeb07fd83879956b1fe3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-21T13:37:41+08:00" />
<meta property="article:modified_time" content="2021-01-21T13:37:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">场景文字的两类检测算法综述---基于回归和分割的方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_3"></a>系列文章目录</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_3" rel="nofollow">系列文章目录</a></li><li><a href="#_12" rel="nofollow">前言</a></li><li><a href="#_22" rel="nofollow">一、目标检测</a></li><li><ul><li><a href="#_34" rel="nofollow">目标检测中几个基础概念</a></li><li><ul><li><a href="#bounding_box_36" rel="nofollow">边界框（bounding box）</a></li><li><a href="#Anchor_box_49" rel="nofollow">锚框（Anchor box）</a></li><li><a href="#_55" rel="nofollow">交并比</a></li></ul> 
   </li><li><a href="#__59" rel="nofollow">文本检测 基于目标检测的算法</a></li></ul> 
  </li><li><a href="#_69" rel="nofollow">二、图像分割</a></li><li><ul><li><a href="#_78" rel="nofollow">文本检测基于图像分割的算法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr color="#000000" size='1"'> 
<h2><a id="_12"></a>前言</h2> 
<p><font color="#999AAA"># 引言<br> 自然场景文本检测识别（Scene Text Recognition, STR）是计算机视觉中的一个重要领域。它在图像搜索，即时翻译和机器人导航等应用中有着至关重要的作用：例如识别照片和视频中的标志、路牌、商店名称等。相比于发展成熟的文档文本识别技术（OCR），STR显然更具挑战性。OCR善于识别平面上的白纸黑字，而自然场景中的文本具有复杂的光照、遮挡、角度、字体和3D阴影。</font></p> 
<hr color="#000000" size='1"'> 
<p>需要大致提及一下目标检测和图像分割基础知识</p> 
<h2><a id="_22"></a>一、目标检测</h2> 
<p>目标检测任务，就是在图像中检测出物体的存在、位置与类别。目标检测的主流算法分为两步法和一步法两种。</p> 
<p>（1） 两步法</p> 
<p>在两步法中，我们需要首先找出目标存在的区域，再将该区域的内容识别出来。我们也可以理解为从一张大图片中先截出各个目标的小图片，再对小图片做图像分类任务。但实际操作中，由于检测目标的存在位置与小图片的识别都需要多层卷积神经网络得到的语义信息，因此这两个任务可以共享一个骨干卷积神经网络，得到了卷积层语义特征后，再分别用于后续的子任务。<br> <img src="https://images2.imgbox.com/59/74/pnJ3fIVb_o.png" alt="在这里插入图片描述"><br> 在检测目标存在和位置的任务中，我们需要输出矩形目标框的位置，通常使用预设锚框的方法。我们对卷积层上的每个像素点，预设好几个不同大小和长宽比的目标框提案，我们称之为锚框。在Faster RCNN中，作者使用了三种大小和三种长宽比，一共九种锚框。这些锚框代表着我们预设的目标可能存在的区域。在骨干网络的基础之上，我们预测每个锚框对应于目标或背景的二分类概率和锚框相对于真实目标框的位置偏差。例如，Faster RCNN中额外增加3x3和1x1卷积层，最终的1x1卷积层使用6N个卷积核，N=9为锚框的种类数。对于每一个锚框，我们分别输出该锚框是目标和背景的概率（2N），该锚框与真实锚框中心位置在x和y方向的偏差(2N)，和该锚框与真实锚框长和宽的偏差(2N)。拥有这些信息之后，我们便可以取概率大的锚框并修正其位置大小作为模型的预测结果。另外，除了预设锚框的方法以外，还可以直接预测每个像素点到目标框上下左右的距离。</p> 
<p><img src="https://images2.imgbox.com/ae/c1/Cfkkf6Nn_o.png" alt="在这里插入图片描述"><br> 在得到了目标所在区域后，我们需要将该区域输入到识别网络做图像分类。然而，由于图像识别网络通常需要固定长宽的输入窗格，而目标区域的形状千差万别，我们需要将目标区域通过ROI Pooling或ROI Align转化为符合识别网络要求的大小。在这一过程中，我们通常保持目标区域的纵横比不变，确定缩放比例使得目标区域的长边与窗格的短边对齐，对于目标区域短边的方向则通过补零以对齐窗格。假设原目标区域比窗格大，在ROI Pooling中，窗格中的每一个格点对应原目标区域中多个格点，我们用极大值或平均值聚合再用极大值或平均值来聚合这多个格点的值；在ROI Align中，我们先将窗格中的格点坐标线性映射到原目标区域，由于映射后的点很可能不在目标区域的格点上，我们使用插值法得到该位置的值。</p> 
<h3><a id="_34"></a>目标检测中几个基础概念</h3> 
<h4><a id="bounding_box_36"></a>边界框（bounding box）</h4> 
<p>检测任务需要同时预测物体的类别和位置，因此需要引入一些跟位置相关的概念。通常使用边界框（bounding box，bbox）来表示物体的位置，边界框是正好能包含物体的矩形框，如 所示，图中3个人分别对应3个边界框。<br> <img src="https://images2.imgbox.com/fb/e6/pazUrNyp_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/60/c3/vfIlo4jY_o.png" alt="在这里插入图片描述"></p> 
<hr color="#000000" size='1"'> 
<p><strong>注意</strong></p> 
<pre><code>在阅读代码时，请注意使用的是哪一种格式的表示方式。
图片坐标的原点在左上角，x轴向右为正方向，y轴向下为正方向。
</code></pre> 
<hr color="#000000" size='1"'> 
<h4><a id="Anchor_box_49"></a>锚框（Anchor box）</h4> 
<p>锚框与物体边界框不同，是由人们假想出来的一种框。先设定好锚框的大小和形状，再以图像上某一个点为中心画出矩形框。在下图中，以像素点[300, 500]为中心可以使用下面的程序生成3个框，如图中蓝色框所示，其中锚框A1跟人像区域非常接近。</p> 
<p><img src="https://images2.imgbox.com/87/b4/upl6AyCJ_o.png" alt="在这里插入图片描述"><br> 在目标检测模型中，通常会以某种规则在图片上生成一系列锚框，将这些锚框当成可能的候选区域。模型对这些候选区域是否包含物体进行预测，如果包含目标物体，则还需要进一步预测出物体所属的类别。还有更为重要的一点是，由于锚框位置是固定的，它不大可能刚好跟物体边界框重合，所以需要在锚框的基础上进行微调以形成能准确描述物体位置的预测框，模型需要预测出微调的幅度。在训练过程中，模型通过学习不断的调整参数，最终能学会如何判别出锚框所代表的候选区域是否包含物体，如果包含物体的话，物体属于哪个类别，以及物体边界框相对于锚框位置需要调整的幅度。</p> 
<h4><a id="_55"></a>交并比</h4> 
<p><img src="https://images2.imgbox.com/e2/48/fXMCaTV3_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="__59"></a>文本检测 基于目标检测的算法</h3> 
<p>这一类算法在骨干卷积网络的基础上，增加卷积层提出文本框提案，再执行两个子任务：判断提案对应于文本的概率和回归调节正样本提案的位置。文本框提案既可通过预设锚框的方式（如PRPN，TextBoxes++），也可通过直接预测的方式（如EAST，ABCNet）。相比于常规的目标检测，文本目标通常为长条形、具有较大的纵横比，而且可能存在旋转歪斜的情况。因此，此类算法通常使用扁平竖高的文本框、旋转文本框或者直接使用多边形文本框，从而可以判别歪斜的文本。<br> <a href="https://link.zhihu.com/?target=https://arxiv.org/abs/1703.01086" rel="nofollow">RRPN</a><br> <a href="https://link.zhihu.com/?target=https://arxiv.org/abs/1801.02765" rel="nofollow">TextBoxes++</a><br> <a href="https://link.zhihu.com/?target=https://arxiv.org/abs/1704.03155" rel="nofollow">EAST</a><br> <a href="https://link.zhihu.com/?target=https://arxiv.org/abs/2002.10200" rel="nofollow">ABCNet</a></p> 
<p>例如，在TextBoxes++中，作者预设了一系列长宽比为1，2，3，5，1/2，1/3，1/5的锚框以刻画不同形状的文本。在骨干网络的基础上，模型增加了卷积层输出每个位置上每个锚框对应于文本的概率和位置回归。图中的绿色和黑色虚线都是预设的锚框，绿色对应于正例而黑色对应于负例。在对正例做位置回归时，模型同时执行两个任务，一个是计算最小的包含文本的四边形（黄色实线）的顶点坐标相对于锚框的位置偏移，如图中红线所示；另一个是计算最小的包含文本的水平矩形（绿色实线）相对于锚框的位置偏移。这两个任务可以用于不同的应用。<br> <img src="https://images2.imgbox.com/4d/6a/gyFOPnIx_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_69"></a>二、图像分割</h2> 
<p>图像分割任务的与目标检测非常类似，目的在于找出图片中的各种目标。然而不同之处在于，目标检测需要输出矩形目标框，而图像分割需要找出所有对应于相同目标的像素点。</p> 
<p><img src="https://images2.imgbox.com/1f/0b/mBAbz8ZX_o.png" alt="在这里插入图片描述"><br> 图像分割任务同样需要卷积神经网络输出的深层语义特征，因此它通常也在骨干卷积网络的基础上，增加一个任务。以Mask RCNN为例，模型在识别网络增加一个子任务，用少量卷积层，对每一个目标类生成一个二值的mapping，判断每一个像素点是否属于该目标类。模型最后采用识别网络的识别结果类对应的mapping作为图像分割任务的输出。</p> 
<h3><a id="_78"></a>文本检测基于图像分割的算法</h3> 
<p>第二类算法的研究者认为，使用预设形状的文本框无法很好地描述某些特殊形状的文本（如纵横比过大或者弧形）。他们受图像分割工作的启发，另辟蹊径，先从像素层面做分类，判别每一个像素点是否属于一个文本目标和它与周围像素的连接情况，再将相邻像素结果整合为一个文本框。这种做法可以适应任何形状和角度的文本，典型代表有pixelLink，CRAFT等。</p> 
<p><img src="https://images2.imgbox.com/f8/5b/s4phFChG_o.png" alt="在这里插入图片描述"></p> 
<p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/1801.01315" rel="nofollow">pixelLink</a><br> <a href="https://link.zhihu.com/?target=https://arxiv.org/abs/1904.01941" rel="nofollow">CRAFT</a></p> 
<p>由于场景文字的大小形状的多样，使用基于分割的检测方法往往更好，但是大部分基于分割的方法需要复杂的后处理将像素级别的结果组合成文字行，在预测时开销往往很大。例如PSENet使用连续尺度扩张的方式后处理；LSAE计算像素之间的特征距离来聚类。这里具体介绍一下DB net 网络结构。</p> 
<p>大部分检测模型用上图的方式做后处理（蓝色箭头）。第一种，设置一个固定的阈值，把分割图转化成二值化图，然后用一些启发式的方法例如聚类把像素处理成文字行；而作者的方法（红色箭头），把二值化的操作放到网络里面同时优化，这样每个像素点的阈值都可以自适应地预测，这样就可以更好地区分前景与背景。常规的二值化方法是不可微的，DB提出了Differentiable Binarization，一种近似的方法来做二值化，这种方法在与分割网络一起使用时是完全可微的。<br> <img src="https://images2.imgbox.com/d3/25/qd010yW2_o.png" alt="在这里插入图片描述"><br> DB module有四个优点：</p> 
<p>1.作者的模型在5个基准数据集上表现得更好，包括处理横向、纵向和卷曲文字。</p> 
<p>2.作者的模型比之前的方法快得多，得益于DB可以生成高可靠的二值图，显著地简化了后处理。</p> 
<p>3.即使使用轻量级的骨架网络，DB表现也很好，跟Resnet-18组合使用效果提升很多。</p> 
<p>4.DB模块在inference过程中可以去掉，不会有更多的内存/时间开销。<br> <img src="https://images2.imgbox.com/f1/22/uT6MX1dA_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/cb/f0/jbR28O8z_o.png" alt="在这里插入图片描述"></p> 
<p>参考：<a href="https://zhuanlan.zhihu.com/p/139062842" rel="nofollow">DBnet 综述</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d9ed1a8425e4e2f8a0686c4dd5fe722/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">maven工程cloud项目子工程依赖报错unknow</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c0352760caa8af9956d48fb9c4f0610f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android——如何在电脑里找到手机中的图片或者视频</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>