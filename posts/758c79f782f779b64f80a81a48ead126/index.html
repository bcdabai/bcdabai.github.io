<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UNIX环境高级编程——进程间通信 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="UNIX环境高级编程——进程间通信" />
<meta property="og:description" content="15.1 引言 本章将说明进程之间相互通信技术——进程间通信（InterProcess Communication，IPC）。
IPC类型包括：
前10种IPC形式通常限于同一台主机的两个进程之间的IPC；最后2种是仅有的支持不同主机上两个进程之间的IPC。 15.2 管道 管道是通过调用pipe函数创建的：
#include &lt;unistd.h&gt; int pipe(int fd[2]); // 返回值：若成功，返回0；若出错，返回-1 经由参数fd返回两个文件描述符：fd[0]为读而打开，fd[1]为写而打开；fd[1]的输出是fd[0]的输入；fstat函数对管道的每一端都返回一个FIFO类型（命名管道）的文件描述符，可以用S_ISFIFO宏来测试管道。 单个进程中的管道几乎没有任何用处。通常，进程会先调用pipe，接着调用fork，从而创建从父进程到子进程的IPC通道，反之亦然：
对于从父进程到子进程的管道，父进程关闭管道的读端（fd[0]），子进程关闭写端（fd[1]）：
对于一个从子进程到父进程的管道，父进程关闭fd[1]， 子进程关闭fd[0]。 当管道的一端被关闭后，下列两条规则起作用：
（1）当读（read）一个写端已被关闭的管道时，在所有数据都被读取后，read返回0，表示文件结束；
（2）如果写（write）一个读端已被关闭的管道，则产生信号SIGPIPE，write返回-1，errno设置为EPIPE。
15.3 函数popen和pclose 常见的操作是创建一个连接到另一个进程的管道，然后读其输出或向其输入端发送数据，为此，标准I/O库提供了两个函数popen和pclose：
#include &lt;stdio.h&gt; FILE *popen(const char *cmdstring, const char *type); // 返回值：若成功，返回文件指针；若出错，返回NULL int pclose(FILE *fp);； // 返回值：若成功，返回cmdstring的终止状态；若出错，返回-1 这两个函数实现的操作是：创建一个管道，fork一个子进程，关闭未使用的管道端，执行一个shell运行命令，然后等待命令终止；函数popen先执行fork，然后调用exec执行cmdstring，并且返回一个标准I/O文件指针；如果type是“r”，则文件指针连接到cmdstring的标准输出；如果type是“w”，则文件指针连接到cmdstring的标准输入：
pclose函数关闭标准I/O流，等待命令终止，然后返回shell的终止状态。 15.4 协同进程 协同进程通常在shell的后台运行，其标准输入和标准输出通过管道连接到另一个程序。协同进程有连接到另一个进程的两个单向管道：一个接到其标准输入，另一个则来自其标准输出。我们想将数据写到其标准输入，经其处理后，再从标准输出读取数据。
15.5 FIFO FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用，而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是，通过FIFO，不相关的进程也能交换数据。
FIFO是一种文件类型，通过stat结构的st_mode成员的编码可以知道文件是否是FIFO类型，可以通过S_ISFIFO宏对此进行测试。
FIFO的路径名存在于文件系统中，创建FIFO类似于创建文件：
#include &lt;sys/stat.h&gt; int mkfifo(const char *path, mode_t mode); int mkfifoat(int fd, const char *path, mode_t mode); // 两个函数的返回值：若成功，返回0；若出错，返回-1 mode参数的规格说明与open函数中的mode相同；mkfifoat函数可以被用来在fd文件描述符表示的目录相关的位置创建一个FIFO，像其他*at函数一样，有3种情形：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/758c79f782f779b64f80a81a48ead126/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-15T07:19:30+08:00" />
<meta property="article:modified_time" content="2023-06-15T07:19:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UNIX环境高级编程——进程间通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="151__0"></a>15.1 引言</h3> 
<p>本章将说明进程之间相互通信技术——进程间通信（InterProcess Communication，IPC）。</p> 
<p>IPC类型包括：<br> <img src="https://images2.imgbox.com/37/11/JYceQ1nX_o.png" alt="在这里插入图片描述"></p> 
<ul><li>前10种IPC形式通常限于同一台主机的两个进程之间的IPC；</li><li>最后2种是仅有的支持不同主机上两个进程之间的IPC。</li></ul> 
<h3><a id="152__7"></a>15.2 管道</h3> 
<p>管道是通过调用<code>pipe</code>函数创建的：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>经由参数<strong>fd</strong>返回两个文件描述符：fd[0]为读而打开，fd[1]为写而打开；fd[1]的输出是fd[0]的输入；</li><li><code>fstat</code>函数对管道的每一端都返回一个<strong>FIFO</strong>类型（命名管道）的文件描述符，可以用<strong>S_ISFIFO</strong>宏来测试管道。</li></ul> 
<p>单个进程中的管道几乎没有任何用处。通常，进程会先调用<code>pipe</code>，接着调用<code>fork</code>，从而创建从父进程到子进程的IPC通道，反之亦然：<br> <img src="https://images2.imgbox.com/f2/32/PAradO6C_o.png" alt="在这里插入图片描述"></p> 
<ul><li>对于从父进程到子进程的管道，父进程关闭管道的读端（fd[0]），子进程关闭写端（fd[1]）：<br> <img src="https://images2.imgbox.com/2f/b2/HP8eHIUU_o.png" alt="在这里插入图片描述"></li><li>对于一个从子进程到父进程的管道，父进程关闭fd[1]， 子进程关闭fd[0]。</li></ul> 
<p>当管道的一端被关闭后，下列两条规则起作用：<br> （1）当读（<code>read</code>）一个写端已被关闭的管道时，在所有数据都被读取后，<code>read</code>返回0，表示文件结束；<br> （2）如果写（<code>write</code>）一个读端已被关闭的管道，则产生信号<strong>SIGPIPE</strong>，<code>write</code>返回-1，errno设置为<strong>EPIPE</strong>。</p> 
<h3><a id="153_popenpclose_28"></a>15.3 函数popen和pclose</h3> 
<p>常见的操作是创建一个连接到另一个进程的管道，然后读其输出或向其输入端发送数据，为此，标准I/O库提供了两个函数<code>popen</code>和<code>pclose</code>：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

FILE <span class="token operator">*</span><span class="token function">popen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cmdstring<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回文件指针；若出错，返回NULL</span>
<span class="token keyword">int</span> <span class="token function">pclose</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>；
										<span class="token comment">// 返回值：若成功，返回cmdstring的终止状态；若出错，返回-1</span>
</code></pre> 
<ul><li>这两个函数实现的操作是：创建一个管道，<code>fork</code>一个子进程，关闭未使用的管道端，执行一个shell运行命令，然后等待命令终止；</li><li>函数<code>popen</code>先执行<code>fork</code>，然后调用<code>exec</code>执行<strong>cmdstring</strong>，并且返回一个标准I/O文件指针；如果<strong>type</strong>是“<strong>r</strong>”，则文件指针连接到<strong>cmdstring</strong>的标准输出；如果<strong>type</strong>是“<strong>w</strong>”，则文件指针连接到<strong>cmdstring</strong>的标准输入：<br> <img src="https://images2.imgbox.com/9f/50/z2w75C3f_o.png" alt="在这里插入图片描述"></li><li><code>pclose</code>函数关闭标准I/O流，等待命令终止，然后返回shell的终止状态。</li></ul> 
<h3><a id="154__44"></a>15.4 协同进程</h3> 
<p>协同进程通常在shell的后台运行，其标准输入和标准输出通过管道连接到另一个程序。协同进程有连接到另一个进程的两个单向管道：一个接到其标准输入，另一个则来自其标准输出。我们想将数据写到其标准输入，经其处理后，再从标准输出读取数据。</p> 
<h3><a id="155_FIFO_46"></a>15.5 FIFO</h3> 
<p><strong>FIFO</strong>有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用，而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是，通过FIFO，不相关的进程也能交换数据。</p> 
<p>FIFO是一种文件类型，通过<strong>stat</strong>结构的<strong>st_mode</strong>成员的编码可以知道文件是否是FIFO类型，可以通过<strong>S_ISFIFO</strong>宏对此进行测试。</p> 
<p>FIFO的路径名存在于文件系统中，创建FIFO类似于创建文件：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">mkfifoat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
												<span class="token comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li><strong>mode</strong>参数的规格说明与<code>open</code>函数中的<strong>mode</strong>相同；</li><li><code>mkfifoat</code>函数可以被用来在fd文件描述符表示的目录相关的位置创建一个FIFO，像其他*at函数一样，有3种情形：<br> （1）如果<strong>path</strong>参数指定的是绝对路径名，则<strong>fd</strong>参数会被忽略掉，并且<code>mkfifoat</code>函数的行为和<code>mkfifo</code>类似；<br> （2）如果<strong>path</strong>参数指定的是相对路径名，则<strong>fd</strong>参数是一个打开目录的有效文件描述符，路径名和目录有关；<br> （3）如果<strong>path</strong>参数指定的是相对路径名，并且<strong>fd</strong>参数有一个特殊值<strong>AT_FDCWD</strong>，则路径名以当前目录开始，<code>mkfifoat</code>和<code>mkfifo</code>类似。</li><li>当用<code>mkfifo</code>或者<code>mkfifoat</code>创建FIFO时，要用<code>open</code>来打开它，当<code>open</code>一个FIFO时，非阻塞标志（<strong>O_NONBLOCK</strong>）会产生下列影响：<br> （1）在一般情况下（没有指定<strong>O_NONBLOCK</strong>），只读<code>open</code>要阻塞到某个其他进程为写而打开这个FIFO为止；类似地，只写<code>open</code>要阻塞到某个其他进程为读而打开它为止；<br> （2）如果指定了<strong>O_NONBLOCK</strong>，则只读<code>open</code>立即返回；但是，如果没有进程为读而打开一个FIFO，那么只写<code>open</code>将返回-1，并将errno设置成<strong>ENXIO</strong>。</li></ul> 
<h3><a id="156_XSI_IPC_69"></a>15.6 XSI IPC</h3> 
<p>有3种称作XSI IPC的IPC：消息队列、信号量以及共享存储器。</p> 
<h4><a id="1561__71"></a>15.6.1 标识符和键</h4> 
<ul><li>每个内核中的IPC结构（消息队列、信号量或共享内存段）都用一个非负整数的<strong>标识符</strong>（identifier）加以引用；</li><li>标识符是IPC对象的内部名，为使多个合作进程能够在同一IPC对象上汇聚，需要提供一个外部命名方案，为此，每个IPC对象都与一个<strong>键</strong>（key）相关联，将这个键作为该对象的外部名；这个键的数据类型是基本系统数据类型key_t，通常被定义为长整型，这个键由内核变换成标识符。</li></ul> 
<h4><a id="1562__74"></a>15.6.2 权限结构</h4> 
<p>XSI IPC为每一个IPC结构关联了一个<code>ipc_perm</code>结构，该结构规定了权限和所有者，它至少包括下列成员：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span> <span class="token punctuation">{<!-- --></span>
	uid_t	uid<span class="token punctuation">;</span>	<span class="token comment">/* owner's effective user id */</span>
	gid_t	gid<span class="token punctuation">;</span>	<span class="token comment">/* owner's effective group id */</span>
	uid_t	cuid<span class="token punctuation">;</span>	<span class="token comment">/* creator's effective user id */</span>
	gid_t	cgid<span class="token punctuation">;</span>	<span class="token comment">/* creator's effective group id */</span>
	mode_t	mode<span class="token punctuation">;</span>	<span class="token comment">/* access modes */</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="1563__87"></a>15.6.3 结构限制</h4> 
<h4><a id="1564__88"></a>15.6.4 优点和缺点</h4> 
<h3><a id="157__89"></a>15.7 消息队列</h3> 
<p>消息队列是消息的链接表，存储在内核中，由消息队列标识符标识，每个队列都有一个<code>msqid_ds</code>结构与其相关联：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">msgid_ds</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span>	<span class="token class-name">ipc_perm</span>	msg_perm<span class="token punctuation">;</span>		<span class="token comment">/* see Section 15.6.2 */</span>
	msgqnum_t			msg_qnum<span class="token punctuation">;</span>		<span class="token comment">/* # of messages on queue */</span>
	msglen_t			msg_qbytes<span class="token punctuation">;</span>		<span class="token comment">/* max # of bytes on queue */</span>
	pid_t				msg_lspid<span class="token punctuation">;</span>		<span class="token comment">/* pid of last msgsnd() */</span>
	pid_t				msg_lrpid<span class="token punctuation">;</span>		<span class="token comment">/* pid of last msgrcv() */</span>
	time_t				msg_stime<span class="token punctuation">;</span>		<span class="token comment">/* last-msgsnd() time */</span>
	time_t				msg_rtime<span class="token punctuation">;</span>		<span class="token comment">/* last-msgrcv() time */</span>
	time_t				msg_ctime<span class="token punctuation">;</span>		<span class="token comment">/* last-change time */</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>		
</code></pre> 
<p><code>msgget</code>用于创建一个新队列或打开一个现有队列：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">msgget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值；若成功，返回消息队列ID；若出错，返回-1</span>
</code></pre> 
<p><code>msgctl</code>函数对队列执行多种操作：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">msgctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li><strong>cmd</strong>参数指定对<strong>msqid</strong>指定的队列要执行的命令： 
  <ul><li><strong>IPC_STAT</strong>：取此队列的msqid_ds结构，并将它存放在<strong>buf</strong>指向的结构中；</li><li><strong>IPC_SET</strong>：将字段msg_perm.uid、msg_perm.gid、msg_perm.mode和msg_qbytes从<strong>buf</strong>指向的结构赋值到与这个队列相关的msqid_ds结构中；</li><li><strong>IPC_RMID</strong>：从系统中删除该消息队列以及仍在该队列中的所有数据，这种删除立即生效。</li></ul> </li></ul> 
<p><code>msgsnd</code>将新消息添加到队列尾端：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">msgsnd</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t nbytes<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li> <p><strong>ptr</strong>参数指向一个长整型数，它包含了正的整型消息类型，其后紧接着的时消息数据（若<strong>nbytes</strong>是0，则无消息数据）。若发送的最长消息是512字节的，则可定义下列结构，<strong>ptr</strong>就是一个指向mymesg结构的指针：</p> <pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">mymesg</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">long</span>	mtype<span class="token punctuation">;</span>			<span class="token comment">/* positive message type */</span>
	<span class="token keyword">char</span>	mtext<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">/* message data, of length nbytes */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p>参数<strong>flag</strong>的值可以指定为<strong>IPC_NOWAIT</strong>，这类似于文件I/O的非阻塞I/O标志。若消息队列已满，则指定<strong>IPC_NOWAIT</strong>使得<code>msgsnd</code>立即出错返回<strong>EAGAIN</strong>；如果没有指定<strong>IPC_NOWAIT</strong>，则进程会一直阻塞到：有空间可以容纳要发送的消息；或者从系统中删除了此队列；或者捕捉到一个信号，并从信号处理程序返回；在第二种情况下，会返回<strong>EIDRM</strong>错误（“标识符被删除”），最后一种情况则返回<strong>EINTR</strong>错误；</p> </li><li> <p>当<code>msgsnd</code>返回成功时，消息队列相关的msqid_ds结构会随之更新，表明调用的进程ID（<strong>msg_lspid</strong>）、调用的时间（<strong>msg_stime</strong>）以及队列中新增的消息（<strong>msg_qnum</strong>）。</p> </li></ul> 
<p><code>msgrcv</code>用于从队列中取消息：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>

ssize_t <span class="token function">msgrcv</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t nbytes<span class="token punctuation">,</span> <span class="token keyword">long</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回消息数据部分的长度；若出错，返回-1</span>
</code></pre> 
<ul><li><strong>ptr</strong>参数指向一个长整型数（其中存储的是返回的消息类型），其后跟随的是存储实际消息数据的缓冲区；</li><li><strong>nbytes</strong>指定数据缓冲区的长度；</li><li>若返回的消息长度大于<strong>nbytes</strong>，而且在<strong>flag</strong>中设置了<strong>MSG_NOERROR</strong>位，则该消息会被截断；如果没有设置这一标志，而消息又太长，则出错返回<strong>E2BIG</strong>（消息仍留在队列中）；</li><li>参数<strong>type</strong>可以指定想要哪一种消息，<strong>type</strong>值非<strong>0</strong>用于以<strong>非先进先出</strong>次序读消息： 
  <ul><li><strong>type == 0</strong>：返回队列中的第一个消息；</li><li><strong>type &gt; 0</strong>：返回队列中消息类型为<strong>type</strong>的第一个消息；</li><li><strong>type &lt; 0</strong>：返回队列中消息类型值小于等于<strong>type</strong>绝对值的消息，如果这种消息有若干个，则取类型值最小的消息。</li></ul> </li><li>可以将<strong>flag</strong>值指定为<strong>IPC_NOWAIT</strong>，使操作不阻塞，这样，如果没有所指定类型的消息可用，则<code>msgrcv</code>返回-1，error设置为<strong>ENOMSG</strong>；如果没有指定<strong>IPC_NOWAIT</strong>，则进程会一直阻塞到有了指定类型的消息可用，或者从系统中删除了此队列（返回-1，errno设置为<strong>EIDRM</strong>），或者捕捉到一个信号并从信号处理程序返回（返回-1，errno设置为<strong>EINTR</strong>）；</li><li><code>msgrcv</code>成功执行时，内核会更新与该消息队列相关联的msqid_ds结构，以指示调用者的进程ID（<strong>msg_lrpid</strong>）和调用时间（<strong>msg_rtime</strong>），并指示队列中的消息数减少了1个（<strong>msg_qnum</strong>）。</li></ul> 
<h3><a id="158__164"></a>15.8 信号量</h3> 
<p>信号量是一个<strong>计数器</strong>，用于为多个进程提供对<strong>共享数据对象</strong>的访问。</p> 
<p>内核为每个XSI信号量集合维护者一个<code>semid_ds</code>结构：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">semid_ds</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span>	<span class="token class-name">ipc_perm</span>	sem_perm<span class="token punctuation">;</span>	<span class="token comment">/* see Section 15.6.2 */</span>
	<span class="token keyword">unsigned</span>	<span class="token keyword">short</span>	sem_nsems<span class="token punctuation">;</span>	<span class="token comment">/* # of semaphores in set */</span>
	time_t				sem_otime<span class="token punctuation">;</span>	<span class="token comment">/* last-semop() time */</span>
	time_t				sem_ctime<span class="token punctuation">;</span>	<span class="token comment">/* last-change time */</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>每个信号量由一个无名结构表示，它至少包含下列成员：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span>	<span class="token keyword">short</span>	semval<span class="token punctuation">;</span>		<span class="token comment">/* semaphore value, always &gt;= 0 */</span>
	pid_t				sempid<span class="token punctuation">;</span>		<span class="token comment">/* pid for last operation */</span>
	<span class="token keyword">unsigned</span>	<span class="token keyword">short</span>	semncnt<span class="token punctuation">;</span>	<span class="token comment">/* # processes awaiting semval &gt; curval */</span>
	<span class="token keyword">unsigned</span> 	<span class="token keyword">short</span>	semzcnt<span class="token punctuation">;</span>	<span class="token comment">/* # processes awaiting semval == 0 */</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>想使用XSI信号量时，首先需要通过函数<code>semget</code>来获得一个信号量ID：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">semget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> <span class="token keyword">int</span> nsems<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回信号量ID；若出错，返回-1</span>
</code></pre> 
<ul><li><strong>nsems</strong>是该集合中的信号量数；如果是创建新集合，则必须指定<strong>nsems</strong>；如果是引用现有集合，则将<strong>nsems</strong>指定为<strong>0</strong>。</li></ul> 
<p><code>semctl</code>函数包含了多种信号量操作：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">semctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">int</span> semnum<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* union semun arg */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：（见下）</span>
</code></pre> 
<ul><li> <p>第4个参数是可选的，是否使用取决于所请求的命令，如果使用该参数，则其类型是<code>semun</code>，它是多个命令特定参数的联合：</p> <pre><code class="prism language-cpp"><span class="token keyword">union</span> semun <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span>						val<span class="token punctuation">;</span>		<span class="token comment">/* for SETVAL */</span>
	<span class="token keyword">struct</span>		<span class="token class-name">semid_ds</span>	<span class="token operator">*</span>buf<span class="token punctuation">;</span>		<span class="token comment">/* for IPC_STAT and IPC_SET */</span>
	<span class="token keyword">unsigned</span>	<span class="token keyword">short</span>		<span class="token operator">*</span>array<span class="token punctuation">;</span>		<span class="token comment">/* for GETALL and SETALL */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p><strong>cmd</strong>参数指定下列10种命令中的一种，这些命令是运行在<strong>semid</strong>指定的信号量集合上的。其中有5种命令是针对一个特定的信号量值的，它们用<strong>semnum</strong>指定该信号量集合中的一个成员。<strong>semnum</strong>值在0和nsems-1之间，包括0和nsems-1：</p> 
  <ul><li><strong>IPC_STAT</strong>：对此集合取semid_ds结构，并存储在由arg.buf指向的结构中；</li><li><strong>IPC_SET</strong>：按arg.buf指向的结构中的值，设置与此集合相关的结构中的sem_perm.uid、sem_perm.gid和sem_perm.mode字段；</li><li><strong>IPC_RMID</strong>：从系统中删除该信号量集合，这种删除是立即发生的；</li><li><strong>GETVAL</strong>：返回成员semnum的semval值；</li><li><strong>SETVAL</strong>：设置成员semnum的semval值，该值由arg.val指定；</li><li><strong>GETPID</strong>：返回成员semnum的sempid值；</li><li><strong>GETNCNT</strong>：返回成员semnum的semncnt值；</li><li><strong>GETZCNT</strong>：返回成员semnum的semzcnt值；</li><li><strong>GETALL</strong>：取该集合中所有的信号量值，这些值存储在arg.array指向的数组中；</li><li><strong>SETALL</strong>：将该集合中所有的信号量值设置成arg.array指向的数组中的值；</li></ul> </li><li> <p>对于除<strong>GETALL</strong>以外的所有GET命令，<code>semctl</code>函数都返回相应值。对于其他命令，若成功则返回值为0，若出错，则设置errno并返回-1。</p> </li></ul> 
<p>函数<code>semop</code>自动执行信号量集合上的操作数组：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">semop</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> semoparray<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> size_t nops<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>参数<strong>semoparray</strong>是一个指针，它指向一个由<code>sembuf</code>结构表示的信号量操作数组，参数<strong>nops</strong>规定该数组中操作的数量（元素数）：<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">sembuf</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span>	<span class="token keyword">short</span>	sem_num<span class="token punctuation">;</span>	<span class="token comment">/* member # in set (0, 1, ..., nsems-1) */</span>
	<span class="token keyword">short</span>				sem_op<span class="token punctuation">;</span>		<span class="token comment">/* operation(negative, 0 or pasitive)*/</span>
	<span class="token keyword">short</span>				sem_flg<span class="token punctuation">;</span>	<span class="token comment">/* IPC_NOWAIT, SEM_UNDO */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
  <ul><li>sem_op为正值，对应于进程释放的占用的资源数，sem_op值会加到信号量的值上；</li><li>若sem_op为负值，则表示要获取由该信号量控制的资源；</li><li>若sem_op为0，则表示调用进程希望等待到该信号量值变成0。</li></ul> </li><li><code>semop</code>函数具有原子性，它或者执行数组中的所有操作，或者一个也不做。</li></ul> 
<h3><a id="159__251"></a>15.9 共享存储</h3> 
<p>共享存储允许两个或多个进程共享一个给定的存储区，因为数据不需要在客户进程和服务器进程之间复制，所以这是最快的一种IPC。</p> 
<p>内核为每个共享存储段维护着一个结构，该结构至少要为每个共享存储段包含以下成员：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span>	<span class="token class-name">ipc_perm</span>	shm_perm<span class="token punctuation">;</span>	<span class="token comment">/* see Section 15.6.2 */</span>
	size_t				shm_segsz<span class="token punctuation">;</span>	<span class="token comment">/* size of segment in bytes */</span>
	pid_t				shm_lpid<span class="token punctuation">;</span>	<span class="token comment">/* pid of last shmop() */</span>
	pid_t				shm_cpid<span class="token punctuation">;</span>	<span class="token comment">/* pid of creator */</span>
	shmatt_t			shm_nattch<span class="token punctuation">;</span>	<span class="token comment">/* number of current attaches */</span>
	time_t				shm_atime<span class="token punctuation">;</span>	<span class="token comment">/* last-attach time */</span>
	time_t				shm_dtime<span class="token punctuation">;</span>	<span class="token comment">/* last-detach time */</span>
	time_t				shm_ctime<span class="token punctuation">;</span>	<span class="token comment">/* last-change time */</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>调用的第一个函数通常是<code>shmget</code>，它获得一个共享存储标识符：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回共享存储ID；若出错，返回-1</span>
</code></pre> 
<ul><li>参数<strong>size</strong>是该共享存储段的长度，以字节为单位，实现通常将其向上取为系统页长的整数倍；如果正在创建一个新段（通常在服务器进程中），则必须指定其<strong>size</strong>，如果正在引用一个现存的段（一个客户进程），则将<strong>size</strong>指定为0。</li></ul> 
<p><code>shmctl</code>函数对共享存储段执行多种操作：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li> <p><strong>cmd</strong>参数指定下列5种命令中的一种，使其在<strong>shmid</strong>指定的段上执行：</p> 
  <ul><li><strong>IPC_STAT</strong>：取此段的shmid_ds结构，并将它存储在<strong>buf</strong>指向的结构中；</li><li><strong>IPC_SET</strong>：按buf指向的结构中的值设置与此共享存储段相关的shmid_ds结构中的下列3个字段：shm_perm.uid、shm_perm.gid、shm_perm.mode；</li><li><strong>IPC_RMID</strong>：从系统中删除该存储段。因为每个共享存储段维护着一个连接计数（shmid_ds结构中的shm_nattach字段），所以除非使用该段的最后一个进程终止或与该段分离，否则不会实际上删除该存储段。不管此段是否仍在使用，该段标识符都会被立即删除，所以不能再用<code>shmat</code>与该段连接。</li></ul> </li><li> <p>Linux和Solaris提供了另外两种命令，它们只能由超级用户执行，但它们并非Single UNIX Specification的组成部分：</p> 
  <ul><li><strong>SHM_LOCK</strong>：在内存中对共享存储段加锁；</li><li><strong>SHM_UNLOCK</strong>：解锁共享存储段。</li></ul> </li></ul> 
<p>一旦创建了一个共享存储段，进程就可调用<code>shmat</code>将其连接到它的地址空间中：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回指向共享存储段的指针；若出错，返回-1</span>
</code></pre> 
<ul><li>共享存储段连接到调用进程的哪个地址上与<strong>addr</strong>参数以及<strong>flag</strong>中是否指定<strong>SHM_RND</strong>位有关： 
  <ul><li>如果<strong>addr</strong>为<strong>0</strong>，则此段连接到由内核选择的第一个可用地址上，这是<strong>推荐</strong>的使用方式；</li><li>如果<strong>addr</strong>非<strong>0</strong>，并且没有指定<strong>SHM_RND</strong>，则此段连接到<strong>addr</strong>所指定的地址上；</li><li>如果<strong>addr</strong>非<strong>0</strong>，并且指定了<strong>SHM_RND</strong>，则此段连接到 <code>(addr - (addr mod SHMLBA))</code>所表示的地址上。<strong>SHM_RND</strong>命令的意思是“取整”；<strong>SHMLBA</strong>的意思是“低边界地址倍数”，它总是2的乘方；该算式是将地址向下取最近1个<strong>SHMLBA</strong>的倍数。</li></ul> </li><li>如果在<strong>flag</strong>中指定了<strong>SHM_RDONLY</strong>位，则以只读方式连接此段，否则以读写方式连接此段；</li><li>如果<code>shmat</code>成功执行，那么内核将使与该共享存储段相关的shmid_ds结构中的<strong>shm_nattch</strong>计数其值加1。</li></ul> 
<p>当对共享存储段的操作已经结束时，则调用<code>shmdt</code>与该段分离：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li><strong>addr</strong>参数是以前调用<code>shmat</code>时的返回值；</li><li>如果成功，<code>shmdt</code>将使相关shmid_ds结构中的<strong>shm_nattch</strong>计数器值减1；</li><li><code>shmdt</code>并不从系统中删除其标识符以及相关的数据结构，该标识符仍然存在，直至某个进程（一般是服务器进程）带<strong>IPC_RMID</strong>命令的调用<code>shmctl</code>特地删除它为止。</li></ul> 
<h3><a id="1510_POSIX_322"></a>15.10 POSIX信号量</h3> 
<p>POSIX信号量有两种形式：<strong>命名的</strong>和<strong>未命名的</strong>。未命名信号量只存在于内存中，并要求能使用信号量的进程必须可以访问内存，这意味着它们只能应用在同一进程中的线程，或者不同进程中已经映射相同内存内容到它们的地址空间中的数据；命名信号量可以通过名字访问，可以被任何已知它们名字的进程中的线程使用。</p> 
<p>可以调用<code>sem_open</code>函数来创建一个新的命名信号量或者使用一个现有信号量：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>

sem_t <span class="token operator">*</span><span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/* mode_t mode, unsigned int value */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回指向信号量的指针；若出错，返回SEM_FAILED</span>
</code></pre> 
<ul><li>当使用一个现有的命名信号量时，仅需指定信号量的名字<strong>name</strong>和<strong>oflag</strong>参数的<strong>0</strong>值；</li><li>当<strong>oflag</strong>参数有<strong>O_CREAT</strong>标志集时，如果命名信号量不存在，则创建一个新的；如果它已经存在，则会被使用，但是不会有额外的初始化发生；</li><li>当指定<strong>O_CREAT</strong>标志时，需要提供两个额外的参数：<strong>mode</strong>参数指定谁可以访问信号量，<strong>mode</strong>的取值和打开文件的权限位相同；<strong>value</strong>参数用来指定信号量的初始值。</li></ul> 
<p>当完成信号量操作时，可以调用<code>sem_close</code>函数来释放任何信号量相关的资源：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">sem_close</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<p>可以使用<code>sem_unlink</code>函数来销毁一个命名信号量：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li><code>sem_unlink</code>函数删除信号量的名字，如果没有打开的信号量引用，则该信号量会被销毁；否则，销毁将延迟到最后一个打开的引用关闭。</li></ul> 
<p>可以使用<code>sem_wait</code>或者<code>sem_trywait</code>函数来实现信号量的减1操作：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">sem_trywait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_wait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>使用<code>sem_wait</code>函数时，如果信号量计数是0就会发生阻塞，直到成功使信号量减1或者被信号中断时才返回；</li><li>可以使用<code>sem_trywait</code>函数来避免阻塞，如果信号量是0，则不会阻塞，而是会返回-1并且将errno置为<strong>EAGAIN</strong>。</li></ul> 
<p><code>sem_timewait</code>函数阻塞一段确定的时间：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">sem_timedwait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>restrict sem<span class="token punctuation">,</span>
				  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>restrict tsptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>如果超时到期并且信号量计数没能减1，<code>sem_timedwait</code>将返回-1且将errno设置为<strong>ETIMEDOUT</strong>。</li></ul> 
<p>可以调用<code>sem_post</code>函数使信号量值增1：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">sem_post</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>调用<code>sem_post</code>时，如果在调用<code>sem_wait</code>（或者<code>sem_timedwait</code>）中发生进程阻塞，那么进程会被唤醒并且被<code>sem_post</code>增1的信号量计数会再次被<code>sem_wait</code>（或者<code>sem_timedwait</code>）减1。</li></ul> 
<p>可以调用<code>sem_init</code>函数来创建一个未命名的信号量：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li><strong>pshared</strong>参数表明是否在多个进程中使用信号量，如果是，将其设置成一个非0值；</li><li><strong>value</strong>参数指定了信号量的初始值；</li><li>需要声明一个<strong>sem_t</strong>类型的变量并把它的地址传递给<code>sem_init</code>来实现初始化，如果要在两个进程之间使用信号量，需要确保<strong>sem</strong>参数指向两个进程之间共享的内存范围。</li></ul> 
<p>对未命名信号量的使用已经完成时，可以调用<code>sem_destroy</code>函数丢弃它：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">sem_destroy</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<p><code>sem_getvalue</code>函数可以用来检索信号量的值：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">sem_getvalue</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>restrict sem<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>restrict valp<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">// 返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<ul><li>成功后，<strong>valp</strong>指向的整数值将包含信号量值。</li></ul> 
<h3><a id="1511__420"></a>15.11 客户进程-服务器进程属性</h3> 
<h3><a id="_421"></a>实例代码</h3> 
<p><a href="https://github.com/MinBadGuy/APUE/tree/main/chapter15">chapter15</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f1881d561095fbf963657004e30d717/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">学生成绩管理系统（逻辑清楚-简单实用）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dc934afb032f89a835be7147151969b7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux---虚拟机配置固定IP</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>