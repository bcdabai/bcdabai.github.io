<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深度学习：混合精度训练 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深度学习：混合精度训练" />
<meta property="og:description" content="深度学习：混合精度训练 前言混合精度训练核心技术权重备份损失缩放梯度裁剪动态调整学习率 优势与弊端代码示例 参考文献 前言 浮点数据类型主要分为双精度Double（FP64）、单精度Float（FP32）和半精度Half（FP16）。FP64浮点数据采用8个字节共64位，来进行的编码存储的一种数据类型；FP32浮点数据采用4个字节共32位来表示；FP16浮点数据则采用2个字节共16位来表示。
默认情况下，大多数深度学习框架（比如Pytorch）都采用32位浮点算法进行训练，混合精度训练可以在神经网络训练过程中，针对不同的层，采用不同的数据精度（比如半精度16位）进行计算，从而实现降低显存和加快速度的目的。
混合精度训练 在此主要介绍了混合精度训练的核心技术、优缺点和代码示例。
核心技术 混合精度训练过程中，主要使用了权重备份和损失缩放两大方法，此外还可以引入梯度裁剪和动态调整学习率等相关技术，提高训练稳定性，从而发挥混合精度训练的优势，并尽可能避免混合精度训练的弊端。
权重备份 如果直接全部采用FP16的精度进行模型训练，由于梯度幅值本身非常小，参数更新的时候乘上学习率就更小了，容易导致 NAN 或者参数更新失败（无法更新）的问题，故模型参数更新需要采用 FP32 格式上操作，因此需要维护一份 FP32 的模型参数副本，并利用FP16的梯度更新FP32模型的参数。值得注意的是，这里备份的模型副本增加的主要是静态内存。只要动态内存的值基本都是使用FP16来进行存储，则最终模型与整网络使用FP32进行训练相比起来， 内存占用也基本能够减半。
损失缩放 使用损失缩放的原因是 FP16 的梯度表示范围比较窄，如果不做处理，大量非零梯度会遇到溢出问题，那么即使后续是采用 FP32 参数更新也是没用的。故需要设置一个缩放系数（loss scale），将前向传播得到的Loss进行放大，放大到 16 精度可表示范围，但是需要注意在反向传播后需要除以缩放系数，将权重缩小后更新模型的参数。
动态损失缩放：上面提到的损失缩放都是使用一个默认值对损失值进行缩放，为了充分利用FP16的动态范围，可以更好地缓解舍入误差，尽量使用比较大的放大倍数。总结动态损失缩放算法，就是每当梯度溢出时候减少损失缩放规模，并且间歇性地尝试增加损失规模，从而实现在不引起溢出的情况下使用最高损失缩放因子，更好地恢复精度。
梯度裁剪 由于半精度浮点数表示的梯度较小，容易出现数值溢出或数值过小的问题。为了解决这个问题，采用梯度裁剪的方法，限制梯度的范围，防止梯度消失或爆炸。
动态调整学习率 随着训练的进行，动态地调整学习率以适应使用半精度浮点数时可能出现的数值不稳定性。这有助于提高训练的稳定性和收敛速度。
优势与弊端 混合精度训练的核心思想是将神经网络中的参数和梯度使用更低位数的浮点数表示，通常是16位半精度浮点数。混合精度的优势在于主要在于减小显存占用和加快训练速度方面。
减少显存占用：FP16的位宽是FP32的一半，因此权重等参数所占用的内存也是原来的一半，从而可以使用更大的模型或更多的数据进行训练。加快通讯效率：对于分布式训练，特别是在大模型训练的过程中，通讯的开销往往会增大训练时间，使用低精度的数据，由于较小的位宽可以提高通讯效率，从而加快模型训练。计算效率更高：使用低精度的数据，执行运算性能也更高，从而加快模型训练，特别是在支持混合精度的硬件上（如NVIDIA的Volta架构及以后的GPU）。 弊端在于：
数据溢出：FP16数据类型的有效数据范围比FP32数据类型的有效数据范围小，使用FP16替换FP32就会出现上溢（Overflow）或下溢（Underflow），从而容易出现数值不稳定性的问题，需要采用一些技术手段来处理。精度损失：FP16和FP32的最小间隔（精确度）不同，从FP32转换到FP16就会出现强制舍入，从而带来一定的精度损失。训练不稳定：使用混合精度训练容易出现NAN和参数无法更新的问题，需要精心设计超参数，以提高训练的稳定性。硬件依赖： 混合精度训练的效果受到硬件支持的限制，只有支持半精度浮点数运算的硬件才能发挥其优势。 代码示例 为了演示混合精度训练的流程，下面是Pytorch官方代码示例，供参考：
# Creates model and optimizer in default precision model = Net().cuda() optimizer = optim.SGD(model.parameters(), ...) # Creates a GradScaler once at the beginning of training. scaler = GradScaler() for epoch in epochs: for input, target in data: optimizer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/470995cf4fb95c0ba0f8f8e84f286061/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-16T17:24:19+08:00" />
<meta property="article:modified_time" content="2023-12-16T17:24:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深度学习：混合精度训练</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>深度学习：混合精度训练</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#_8" rel="nofollow">混合精度训练</a></li><li><ul><li><a href="#_10" rel="nofollow">核心技术</a></li><li><ul><li><a href="#_16" rel="nofollow">权重备份</a></li><li><a href="#_18" rel="nofollow">损失缩放</a></li><li><a href="#_22" rel="nofollow">梯度裁剪</a></li><li><a href="#_24" rel="nofollow">动态调整学习率</a></li></ul> 
   </li><li><a href="#_26" rel="nofollow">优势与弊端</a></li><li><a href="#_39" rel="nofollow">代码示例</a></li></ul> 
  </li><li><a href="#_74" rel="nofollow">参考文献</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p>浮点数据类型主要分为双精度Double（FP64）、单精度Float（FP32）和半精度Half（FP16）。FP64浮点数据采用8个字节共64位，来进行的编码存储的一种数据类型；FP32浮点数据采用4个字节共32位来表示；FP16浮点数据则采用2个字节共16位来表示。<br> <img src="https://images2.imgbox.com/75/e4/443TJMfn_o.png" alt="在这里插入图片描述"></p> 
<p>默认情况下，大多数深度学习框架（比如Pytorch）都采用32位浮点算法进行训练，混合精度训练可以在神经网络训练过程中，针对不同的层，采用不同的数据精度（比如半精度16位）进行计算，从而实现降低显存和加快速度的目的。</p> 
<h2><a id="_8"></a>混合精度训练</h2> 
<p>在此主要介绍了混合精度训练的核心技术、优缺点和代码示例。</p> 
<h3><a id="_10"></a>核心技术</h3> 
<p>混合精度训练过程中，主要使用了权重备份和损失缩放两大方法，此外还可以引入梯度裁剪和动态调整学习率等相关技术，提高训练稳定性，从而发挥混合精度训练的优势，并尽可能避免混合精度训练的弊端。</p> 
<p><img src="https://images2.imgbox.com/ed/ce/S4IJuFxw_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_16"></a>权重备份</h4> 
<p>如果直接全部采用FP16的精度进行模型训练，由于梯度幅值本身非常小，参数更新的时候乘上学习率就更小了，容易导致 NAN 或者参数更新失败（无法更新）的问题，故模型参数更新需要采用 FP32 格式上操作，因此需要维护一份 FP32 的模型参数副本，并利用FP16的梯度更新FP32模型的参数。值得注意的是，这里备份的模型副本增加的主要是静态内存。只要动态内存的值基本都是使用FP16来进行存储，则最终模型与整网络使用FP32进行训练相比起来， 内存占用也基本能够减半。</p> 
<h4><a id="_18"></a>损失缩放</h4> 
<p>使用损失缩放的原因是 FP16 的梯度表示范围比较窄，如果不做处理，大量非零梯度会遇到溢出问题，那么即使后续是采用 FP32 参数更新也是没用的。故需要设置一个缩放系数（loss scale），将前向传播得到的Loss进行放大，放大到 16 精度可表示范围，但是需要注意在反向传播后需要除以缩放系数，将权重缩小后更新模型的参数。</p> 
<p>动态损失缩放：上面提到的损失缩放都是使用一个默认值对损失值进行缩放，为了充分利用FP16的动态范围，可以更好地缓解舍入误差，尽量使用比较大的放大倍数。总结动态损失缩放算法，就是每当梯度溢出时候减少损失缩放规模，并且间歇性地尝试增加损失规模，从而实现在不引起溢出的情况下使用最高损失缩放因子，更好地恢复精度。</p> 
<h4><a id="_22"></a>梯度裁剪</h4> 
<p>由于半精度浮点数表示的梯度较小，容易出现数值溢出或数值过小的问题。为了解决这个问题，采用梯度裁剪的方法，限制梯度的范围，防止梯度消失或爆炸。</p> 
<h4><a id="_24"></a>动态调整学习率</h4> 
<p>随着训练的进行，动态地调整学习率以适应使用半精度浮点数时可能出现的数值不稳定性。这有助于提高训练的稳定性和收敛速度。</p> 
<h3><a id="_26"></a>优势与弊端</h3> 
<p>混合精度训练的核心思想是将神经网络中的参数和梯度使用更低位数的浮点数表示，通常是16位半精度浮点数。混合精度的优势在于主要在于减小显存占用和加快训练速度方面。</p> 
<ul><li>减少显存占用：FP16的位宽是FP32的一半，因此权重等参数所占用的内存也是原来的一半，从而可以使用更大的模型或更多的数据进行训练。</li><li>加快通讯效率：对于分布式训练，特别是在大模型训练的过程中，通讯的开销往往会增大训练时间，使用低精度的数据，由于较小的位宽可以提高通讯效率，从而加快模型训练。</li><li>计算效率更高：使用低精度的数据，执行运算性能也更高，从而加快模型训练，特别是在支持混合精度的硬件上（如NVIDIA的Volta架构及以后的GPU）。</li></ul> 
<p>弊端在于：</p> 
<ul><li>数据溢出：FP16数据类型的有效数据范围比FP32数据类型的有效数据范围小，使用FP16替换FP32就会出现上溢（Overflow）或下溢（Underflow），从而容易出现数值不稳定性的问题，需要采用一些技术手段来处理。</li><li>精度损失：FP16和FP32的最小间隔（精确度）不同，从FP32转换到FP16就会出现强制舍入，从而带来一定的精度损失。</li><li>训练不稳定：使用混合精度训练容易出现NAN和参数无法更新的问题，需要精心设计超参数，以提高训练的稳定性。</li><li>硬件依赖： 混合精度训练的效果受到硬件支持的限制，只有支持半精度浮点数运算的硬件才能发挥其优势。</li></ul> 
<h3><a id="_39"></a>代码示例</h3> 
<p>为了演示混合精度训练的流程，下面是Pytorch官方代码示例，供参考：</p> 
<pre><code class="prism language-python"><span class="token comment"># Creates model and optimizer in default precision </span>
model <span class="token operator">=</span> Net<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span> 
optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> 
 
<span class="token comment"># Creates a GradScaler once at the beginning of training. </span>
scaler <span class="token operator">=</span> GradScaler<span class="token punctuation">(</span><span class="token punctuation">)</span> 
 
<span class="token keyword">for</span> epoch <span class="token keyword">in</span> epochs<span class="token punctuation">:</span> 
 <span class="token keyword">for</span> <span class="token builtin">input</span><span class="token punctuation">,</span> target <span class="token keyword">in</span> data<span class="token punctuation">:</span> 
        optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span> 
 
 <span class="token comment"># Runs the forward pass with autocasting. </span>
 <span class="token keyword">with</span> autocast<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> 
            output <span class="token operator">=</span> model<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span> 
            loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>output<span class="token punctuation">,</span> target<span class="token punctuation">)</span> 
 
 <span class="token comment"># Scales loss.  Calls backward() on scaled loss to create scaled gradients. </span>
 <span class="token comment"># Backward passes under autocast are not recommended. </span>
 <span class="token comment"># Backward ops run in the same dtype autocast chose for corresponding forward ops. </span>
        scaler<span class="token punctuation">.</span>scale<span class="token punctuation">(</span>loss<span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span> 
 
 <span class="token comment"># scaler.step() first unscales the gradients of the optimizer's assigned params. </span>
 <span class="token comment"># If these gradients do not contain infs or NaNs, optimizer.step() is then called, </span>
 <span class="token comment"># otherwise, optimizer.step() is skipped. </span>
        scaler<span class="token punctuation">.</span>step<span class="token punctuation">(</span>optimizer<span class="token punctuation">)</span> 
 
 <span class="token comment"># Updates the scale for next iteration. </span>
        scaler<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">)</span> 
</code></pre> 
<h2><a id="_74"></a>参考文献</h2> 
<ol><li><a href="https://blog.51cto.com/u_16099268/6696537" rel="nofollow">https://blog.51cto.com/u_16099268/6696537</a></li><li><a href="https://zhuanlan.zhihu.com/p/375224982" rel="nofollow">https://zhuanlan.zhihu.com/p/375224982</a></li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/358c7f1818b2198bb828193db02f9650/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python基础教程——制作简单计算器（完整版，附源码）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ee08d13ec101d8e6c9ab1819fbc5efc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python基础教程——制作一个宿舍管理系统（完整版，附源码）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>