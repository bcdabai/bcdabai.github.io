<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker简述与基础部署详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker简述与基础部署详解" />
<meta property="og:description" content="目录
docker概述
docker的核心思想
docker三大组件
docker优势
容器和虚拟机之间的区别
容器在内核中支持的重要技术
命名空间（Namespaces）
控制组（Control Groups，cgroups）
写时复制技术（Copy-on-Write）
docker组成
docker基础命令
容器生命周期管理：
镜像管理：
网络与数据卷管理：
容器执行与交互：
Docker Compose 与 Swarm：
其他常用命令：
最常用的命令
docker运行命令的流程
部署实例
安装docker
docker镜像操作
docker容器操作
docker官网：https://www.docker.com docker中文库:https://www.docker.org.cn/
Docker是一种开源的容器化平台，用于轻松打包、交付和运行应用程序。Docker的主要优势在于它提供了一种轻量级、可移植、自包含的容器化技术，使得应用程序及其所有依赖项能够在任何环境中运行，而无需担心环境差异性和依赖关系问题。
docker概述 Docker是一个开源项目，于2013年初诞生，最初是dotCloud公司内部的一个业余项目。它基于Google公司推出的Go语言实现，并于后来加入了Linux基金会，遵从了Apache 2.0协议，项目代码在GitHub上进行维护。Docker自开源以来受到广泛的关注和讨论。
Docker的主要特点和功能包括：
轻量化虚拟化： Docker利用Linux内核的容器技术，实现了轻量级的虚拟化。容器可以隔离应用进程和资源，但与传统的虚拟机相比，它们更加轻便且启动更快。
跨平台性： Docker容器可以在任何支持Docker的平台上运行，无论是开发、测试还是生产环境，保证了应用的一致性。
快速部署： Docker容器可以在几秒钟内启动，相比传统虚拟机的分钟级别启动时间更加迅速，提高了应用的部署效率。
易于管理： Docker提供了简单而强大的命令行工具和API，使得容器的创建、部署、复制和移动变得非常容易。
版本控制： Docker支持镜像的版本控制，可以方便地管理应用的不同版本，简化了应用的升级和回滚过程。
总体而言，Docker的出现极大地简化了应用的开发、部署和管理过程，推动了容器化技术的发展。通过使用Docker，开发者可以更方便地构建、打包和交付应用，同时提高了系统的可移植性和可扩展性。
docker的核心思想 Docker的核心思想是实现&#34;Build, Ship and Run Any App, Anywhere&#34;，即通过对应用的封装、分发、部署、运行生命周期进行管理，达到应用组件“一次封装，到处运行”的目的。以下是Docker思想的关键要点：
封装（Packaging）： Docker利用容器技术，将应用及其依赖项打包成一个独立的容器。这个容器包含了应用的代码、运行时、系统工具、系统库等，形成了一个可移植的封闭环境。
分发（Distribution）： Docker容器可以轻松地在不同的环境中进行分发。这是因为Docker容器包含了所有应用所需的依赖项，而不受底层系统的影响。这使得开发、测试和生产环境之间的迁移变得更加简便。
部署（Deployment）： Docker容器可以在任何支持Docker的环境中部署，而不受操作系统和硬件的限制。这为应用的部署提供了更大的灵活性，可以在不同的云平台、物理机或虚拟机上运行。
运行（Runtime）： Docker容器提供了一个隔离的运行时环境，使得应用可以在相互隔离的容器中独立运行。这种隔离性质保证了容器之间的互不干扰，同时提供了更高的安全性。
一次封装，到处运行： Docker的目标是实现应用组件的一次封装，然后可以在任何地方运行，无论是开发者的本地机器、测试环境还是生产服务器。这种一致性简化了开发、测试和部署的过程。
总的来说，Docker的思想是通过容器技术实现应用的轻量化封装和隔离，使得应用能够方便地在不同环境中运行，从而提高开发、测试和部署的效率，并增强了应用的可移植性和可扩展性。
docker三大组件 Docker的三大组件是镜像（Image）、容器（Container）和仓库（Repository）。
镜像（Image）：
镜像是Docker应用的基础。它是一个只读的文件和文件夹组合，包含了容器运行时所需的所有基础文件和配置信息。镜像是容器的静态定义，可以看作是应用程序的打包和分发形式。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3e4c98ba3a6cb87bda87544bbec80745/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T09:05:30+08:00" />
<meta property="article:modified_time" content="2024-01-12T09:05:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker简述与基础部署详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="docker-toc" style="margin-left:0px;"><a href="#docker" rel="nofollow">docker概述</a></p> 
<p id="docker-1-toc" style="margin-left:0px;"><a href="#docker-1" rel="nofollow">docker的核心思想</a></p> 
<p id="docker-2-toc" style="margin-left:0px;"><a href="#docker-2" rel="nofollow">docker三大组件</a></p> 
<p id="docker-3-toc" style="margin-left:0px;"><a href="#docker-3" rel="nofollow">docker优势</a></p> 
<p id="%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">容器和虚拟机之间的区别</a></p> 
<p id="-1-toc" style="margin-left:0px;"><a href="#-1" rel="nofollow">容器在内核中支持的重要技术</a></p> 
<p id="namespaces-toc" style="margin-left:40px;"><a href="#namespaces" rel="nofollow">命名空间（Namespaces）</a></p> 
<p id="controlgroupscgroups-toc" style="margin-left:40px;"><a href="#controlgroupscgroups" rel="nofollow">控制组（Control Groups，cgroups）</a></p> 
<p id="copyonwrite-toc" style="margin-left:40px;"><a href="#copyonwrite" rel="nofollow">写时复制技术（Copy-on-Write）</a></p> 
<p id="docker%E7%BB%84%E6%88%90-toc" style="margin-left:0px;"><a href="#docker%E7%BB%84%E6%88%90" rel="nofollow">docker组成</a></p> 
<p id="docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4-toc" style="margin-left:0px;"><a href="#docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4" rel="nofollow">docker基础命令</a></p> 
<p id="%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%EF%BC%9A" rel="nofollow">容器生命周期管理：</a></p> 
<p id="%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86%EF%BC%9A" rel="nofollow">镜像管理：</a></p> 
<p id="-2-toc" style="margin-left:80px;"><a href="#-2" rel="nofollow">网络与数据卷管理：</a></p> 
<p id="-3-toc" style="margin-left:80px;"><a href="#-3" rel="nofollow">容器执行与交互：</a></p> 
<p id="dockercomposeswarm-toc" style="margin-left:80px;"><a href="#dockercomposeswarm" rel="nofollow">Docker Compose 与 Swarm：</a></p> 
<p id="-4-toc" style="margin-left:80px;"><a href="#-4" rel="nofollow">其他常用命令：</a></p> 
<p id="-5-toc" style="margin-left:40px;"><a href="#-5" rel="nofollow">最常用的命令</a></p> 
<p id="docker%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E6%B5%81%E7%A8%8B-toc" style="margin-left:40px;"><a href="#docker%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E6%B5%81%E7%A8%8B" rel="nofollow">docker运行命令的流程</a></p> 
<p id="%E9%83%A8%E7%BD%B2%E5%AE%9E%E4%BE%8B-toc" style="margin-left:0px;"><a href="#%E9%83%A8%E7%BD%B2%E5%AE%9E%E4%BE%8B" rel="nofollow">部署实例</a></p> 
<p id="%E5%AE%89%E8%A3%85docker-toc" style="margin-left:0px;"><a href="#%E5%AE%89%E8%A3%85docker" rel="nofollow">安装docker</a></p> 
<p id="docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C" rel="nofollow">docker镜像操作</a></p> 
<p id="docker%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#docker%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C" rel="nofollow">docker容器操作</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><em>docker官网</em>：https://www.docker.com <em>docker中文库</em>:https://www.docker.org.cn/</p> 
<p>Docker是一种开源的容器化平台，用于轻松打包、交付和运行应用程序。Docker的主要优势在于它提供了一种轻量级、可移植、自包含的容器化技术，使得应用程序及其所有依赖项能够在任何环境中运行，而无需担心环境差异性和依赖关系问题。</p> 
<h2 id="docker">docker概述</h2> 
<p>Docker是一个开源项目，于2013年初诞生，最初是dotCloud公司内部的一个业余项目。它基于Google公司推出的Go语言实现，并于后来加入了Linux基金会，遵从了Apache 2.0协议，项目代码在GitHub上进行维护。Docker自开源以来受到广泛的关注和讨论。</p> 
<p>Docker的主要特点和功能包括：</p> 
<ul><li> <p><strong>轻量化虚拟化：</strong> Docker利用Linux内核的容器技术，实现了轻量级的虚拟化。容器可以隔离应用进程和资源，但与传统的虚拟机相比，它们更加轻便且启动更快。</p> </li><li> <p><strong>跨平台性：</strong> Docker容器可以在任何支持Docker的平台上运行，无论是开发、测试还是生产环境，保证了应用的一致性。</p> </li><li> <p><strong>快速部署：</strong> Docker容器可以在几秒钟内启动，相比传统虚拟机的分钟级别启动时间更加迅速，提高了应用的部署效率。</p> </li><li> <p><strong>易于管理：</strong> Docker提供了简单而强大的命令行工具和API，使得容器的创建、部署、复制和移动变得非常容易。</p> </li><li> <p><strong>版本控制：</strong> Docker支持镜像的版本控制，可以方便地管理应用的不同版本，简化了应用的升级和回滚过程。</p> </li></ul> 
<p>总体而言，Docker的出现极大地简化了应用的开发、部署和管理过程，推动了容器化技术的发展。通过使用Docker，开发者可以更方便地构建、打包和交付应用，同时提高了系统的可移植性和可扩展性。</p> 
<h2 id="docker-1">docker的核心思想</h2> 
<p>Docker的核心思想是实现"Build, Ship and Run Any App, Anywhere"，即通过对应用的封装、分发、部署、运行生命周期进行管理，达到应用组件“一次封装，到处运行”的目的。以下是Docker思想的关键要点：</p> 
<ul><li> <p><strong>封装（Packaging）：</strong> Docker利用容器技术，将应用及其依赖项打包成一个独立的容器。这个容器包含了应用的代码、运行时、系统工具、系统库等，形成了一个可移植的封闭环境。</p> </li><li> <p><strong>分发（Distribution）：</strong> Docker容器可以轻松地在不同的环境中进行分发。这是因为Docker容器包含了所有应用所需的依赖项，而不受底层系统的影响。这使得开发、测试和生产环境之间的迁移变得更加简便。</p> </li><li> <p><strong>部署（Deployment）：</strong> Docker容器可以在任何支持Docker的环境中部署，而不受操作系统和硬件的限制。这为应用的部署提供了更大的灵活性，可以在不同的云平台、物理机或虚拟机上运行。</p> </li><li> <p><strong>运行（Runtime）：</strong> Docker容器提供了一个隔离的运行时环境，使得应用可以在相互隔离的容器中独立运行。这种隔离性质保证了容器之间的互不干扰，同时提供了更高的安全性。</p> </li><li> <p><strong>一次封装，到处运行：</strong> Docker的目标是实现应用组件的一次封装，然后可以在任何地方运行，无论是开发者的本地机器、测试环境还是生产服务器。这种一致性简化了开发、测试和部署的过程。</p> </li></ul> 
<p>总的来说，Docker的思想是通过容器技术实现应用的轻量化封装和隔离，使得应用能够方便地在不同环境中运行，从而提高开发、测试和部署的效率，并增强了应用的可移植性和可扩展性。</p> 
<h2 id="docker-2">docker三大组件</h2> 
<p>Docker的三大组件是镜像（Image）、容器（Container）和仓库（Repository）。</p> 
<p><strong>镜像（Image）：</strong></p> 
<ul><li> <p>镜像是Docker应用的基础。它是一个只读的文件和文件夹组合，包含了容器运行时所需的所有基础文件和配置信息。镜像是容器的静态定义，可以看作是应用程序的打包和分发形式。</p> </li><li> <p>镜像是Docker容器启动的先决条件，每个容器都基于一个镜像运行。开发者可以从已有的镜像构建新的镜像，也可以分享和获取镜像从而实现应用程序的快速部署。</p> </li></ul> 
<p><strong>容器（Container）：</strong></p> 
<ul><li> <p>容器是镜像的运行实体，是一个独立、轻量的执行环境。容器包含了运行应用程序所需的可写文件层，以及容器中的进程属于运行状态。</p> </li><li> <p>每个容器都是一个独立的环境，具有初建、运行、停止、暂停和删除等五种状态。容器的本质是在宿主机上运行的一个进程，但通过命名空间隔离和资源限制，容器内部无法看到宿主机上的其他进程、环境变量、网络等信息。</p> </li></ul> 
<p><strong>仓库（Repository）：</strong></p> 
<ul><li> <p>Docker的镜像仓库类似于代码仓库，用来存储和分发Docker镜像。镜像仓库可以分为公共镜像仓库和私有镜像仓库。</p> </li><li> <p>公共镜像仓库中包含了许多由开发者分享的常用镜像，最著名的是Docker Hub。私有镜像仓库则用于组织内部的镜像存储和分享，可以通过搭建私有仓库（如Docker Registry）实现。</p> </li></ul> 
<p>这三大组件共同构成了Docker的基础架构，使得开发者能够方便地构建、打包、分发和运行应用程序。通过使用这些组件，Docker实现了应用组件“一次封装，到处运行”的理念。</p> 
<h2 id="docker-3">docker优势</h2> 
<ul><li> <p><strong>轻量化：</strong> Docker利用容器技术，在一个单独的容器中封装了应用及其依赖项，相比传统的虚拟机，容器更为轻量，启动更快，占用更少的资源。</p> </li><li> <p><strong>可移植性：</strong> Docker容器可以在任何支持Docker的平台上运行，无论是开发者的本地机器、测试环境还是生产服务器。这提高了应用的可移植性，避免了在不同环境中出现兼容性问题。</p> </li><li> <p><strong>一致性：</strong> Docker容器包含了应用及其所有依赖项，确保了在不同阶段（开发、测试、生产）的一致性。开发人员可以在本地构建和测试容器，然后将相同的容器部署到生产环境中，减少了因环境差异导致的问题。</p> </li><li> <p><strong>快速部署：</strong> Docker容器可以在几秒钟内启动，相比传统虚拟机的分钟级别启动时间更加迅速。这提高了应用的部署效率，对于快速迭代和持续集成/持续部署（CI/CD）流程非常有利。</p> </li><li> <p><strong>资源利用效率：</strong> 由于Docker容器共享宿主操作系统的内核，容器的资源占用更为有效。多个容器可以在同一台宿主机上运行，共享操作系统资源，提高了资源的利用效率。</p> </li><li> <p><strong>灵活性：</strong> Docker容器可以轻松扩展或缩减，适应不同工作负载的需求。容器的快速启动和停止使得动态扩展和缩减应用实例变得更加容易。</p> </li><li> <p><strong>版本控制：</strong> Docker支持镜像的版本控制，可以方便地管理应用的不同版本。这简化了应用的升级和回滚过程，同时提供了更好的版本管理机制。</p> </li></ul> 
<p>总的来说，Docker的优势在于提供了一种轻量、可移植、一致、快速部署的容器化解决方案，为开发、测试和部署过程带来了许多便利，推动了应用交付和运维的现代化</p> 
<p></p> 
<h2 id="%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>容器和虚拟机之间的区别</strong></h2> 
<p><strong>在于其架构和资源利用方式。</strong></p> 
<p><strong>容器：</strong></p> 
<ul><li> <p>运行在宿主机上的容器，共享主机的操作系统内核，这使得它们非常轻量级。</p> </li><li> <p>容器只需包含应用及其依赖项，不需要完整的操作系统镜像。</p> </li><li> <p>每个容器运行一个独立的进程，它们之间相互隔离，但共享主机的资源。因此，容器非常快速启动，并占用的资源相对较少。</p> </li></ul> 
<p><strong>虚拟机：</strong></p> 
<ul><li> <p>虚拟机则运行在宿主机上，但是每个虚拟机都有自己的完整操作系统镜像。</p> </li><li> <p>每个虚拟机通过虚拟机管理程序（如Hypervisor）访问主机资源。这意味着每个虚拟机都需要模拟完整的硬件。</p> </li><li> <p>各个虚拟机相对独立，不共享主机操作系统内核，因此虚拟机的启动和部署需要更多的资源，并且启动时间较长。</p> </li></ul> 
<p>这种差异使得容器在资源利用和启动速度方面具有优势。它们更适合于快速部署和持续集成/持续部署（CI/CD）等场景，而虚拟机通常更适用于需要完全隔离的情况，如运行不同操作系统的应用或需要更高级别的隔离。</p> 
<pre><code>Docker与虚拟机的区别：
特性                        Docker容器                    虚拟机
启动速度                    秒级                      分钟级
计算能力损耗                 几乎无                         损耗 50%左右
性能                        接近原生                    弱于
系统支持量（单机）            上千个                     几十个
隔离性                        资源隔离/限制             完全隔离
</code></pre> 
<h2 id="-1">容器在内核中支持的重要技术</h2> 
<p>Docker的本质是一个运行在宿主机上的进程，利用Linux内核提供的命名空间（namespace）和控制组（cgroup）等特性实现了容器的资源隔离和管理。</p> 
<h3 id="namespaces"><strong>命名空间（Namespaces）</strong></h3> 
<ul><li><strong>命名空间（Namespaces）：</strong> Docker利用命名空间隔离不同的系统资源，如进程、网络、文件系统、用户等。每个容器都有自己的命名空间，使得它们看起来像是在独立的环境中运行，互不干扰。</li></ul> 
<ol><li> <p><strong>PID Namespace（进程隔离）：</strong> 这种 Namespace 使得每个容器都拥有独立的进程 ID（PID）空间，即每个容器都认为自己是系统上唯一的进程。这样可以防止一个容器中的进程影响到其他容器中的进程。</p> </li><li> <p><strong>Mount Namespace（文件系统隔离）：</strong> Mount Namespace 允许每个容器拥有独立的文件系统挂载点。一个容器内的文件系统变更不会影响其他容器，使得每个容器都有自己的文件系统视图。</p> </li><li> <p><strong>Network Namespace（网络隔离）：</strong> 这种 Namespace 允许每个容器拥有独立的网络接口、IP 地址、路由表等网络资源。每个容器都认为自己独占一套网络资源，实现了容器之间的网络隔离。</p> </li><li> <p><strong>UTS Namespace（主机名隔离）：</strong> UTS Namespace 允许每个容器有独立的主机名和域名。这样可以防止容器之间产生主机名冲突。</p> </li><li> <p><strong>IPC Namespace（进程间通信隔离）：</strong> IPC Namespace 允许每个容器有独立的进程间通信资源，如消息队列、信号量等。这使得容器内的进程无法直接干扰其他容器内的进程。</p> </li><li> <p><strong>User Namespace（用户隔离）：</strong> User Namespace 允许将容器内的进程映射到不同的用户和用户组 ID，从而实现容器内外用户的隔离。</p> </li></ol> 
<h3 id="controlgroupscgroups"><strong>控制组（Control Groups，cgroups）</strong></h3> 
<p><strong>控制组（Control Groups，cgroups）：</strong> Docker使用cgroups对容器的资源进行限制和管理，如CPU、内存、磁盘等。这使得能够有效地控制和分配资源，防止容器之间出现资源争用和耗尽。</p> 
<p><strong>CPU 隔离：</strong> 使用 cgroup，可以将一组进程限制在特定的 CPU 核心上运行。这可以通过设置 cgroup 中的 CPU affinity 来实现，确保进程组只能在指定的 CPU 核心上执行。</p> 
<p>示例：</p> 
<pre><code># 创建一个 cgroup，并设置 CPU affinity
mkdir /sys/fs/cgroup/cpu/mygroup
echo 0-2 &gt; /sys/fs/cgroup/cpu/mygroup/cpuset.cpus
</code></pre> 
<p><strong>内存隔离：</strong> cgroup 允许您限制进程组对系统内存的使用，并为每个 cgroup 设置内存限制。这确保一个 cgroup 内的进程无法超过其分配的内存限额。</p> 
<p>示例：</p> 
<pre><code># 创建一个 cgroup，并设置内存资源限制
mkdir /sys/fs/cgroup/memory/mygroup
echo 500M &gt; /sys/fs/cgroup/memory/mygroup/memory.limit_in_bytes
</code></pre> 
<p><strong>网络隔离：</strong> 使用 Network Namespace 结合 cgroup，可以实现网络隔离。每个 cgroup 可以拥有独立的网络命名空间，使得容器内的进程无法直接访问其他 cgroup 内的网络资源。</p> 
<p>示例：</p> 
<pre><code># 创建一个 cgroup，并设置网络隔离
mkdir /sys/fs/cgroup/net_cls/mygroup
echo 1234 &gt; /sys/fs/cgroup/net_cls/mygroup/net_cls.classid
</code></pre> 
<p><strong>进程隔离：</strong> cgroup 允许将进程组织在一起，并对整个组施加资源限制。这样，一个 cgroup 内的进程无法影响其他 cgroup 内的进程，实现了一定程度的进程隔离。</p> 
<p>示例：</p> 
<pre><code># 创建一个 cgroup，并将进程加入其中
mkdir /sys/fs/cgroup/cpu/mygroup
echo $$ &gt; /sys/fs/cgroup/cpu/mygroup/cgroup.procs
</code></pre> 
<p></p> 
<h3 id="copyonwrite"><strong>写时复制技术（Copy-on-Write）</strong></h3> 
<ul><li> <p><strong>写时复制技术（Copy-on-Write）：</strong> Docker利用写时复制技术实现了高效的文件操作。当容器需要修改文件时，Docker并不直接修改原始文件，而是在修改时创建副本，只有在必要时才对文件进行复制和修改，节省了存储空间，并提高了文件操作的效率。</p> <p>在不同的上下文中，Copy-on-Write 可以有不同的应用，以下是几个例子：</p> </li></ul> 
<ol><li> <p><strong>文件系统：</strong> 在文件系统中，COW 可以用于创建快照。当创建一个快照时，不会立即复制整个文件系统，而是共享原始文件系统的数据。只有在对文件系统进行更改时，才会复制被修改的数据块，确保新的快照和原始文件系统之间的数据一致性。</p> </li><li> <p><strong>进程创建：</strong> 在操作系统中，当一个进程 fork（创建子进程）时，子进程最初与父进程共享相同的内存。只有在子进程或父进程尝试修改内存内容时，才会发生实际的内存复制。这样可以减少内存的实际复制，提高效率。</p> </li><li> <p><strong>虚拟内存管理：</strong> COW 也在虚拟内存管理中发挥作用。当多个进程共享相同的内存页时，这些页被标记为只读。只有在某个进程尝试写入这些页时，才会为该进程创建一个私有的副本，从而实现对内存的隔离。</p> </li><li> <p><strong>数据库系统：</strong> 在数据库系统中，COW 可以用于实现事务隔离。当一个事务读取数据时，它与其他事务共享相同的数据。只有在事务尝试修改数据时，才会创建数据的副本，以确保事务之间的隔离性。</p> </li></ol> 
<p>这些技术使得Docker能够创建、管理和运行容器，使得容器具有轻量、高效、隔离的特性。容器虽然运行在宿主机上，但利用这些技术达到了与宿主机和其他容器相互独立、高效利用资源的效果，为应用程序的部署和运行提供了便利和效率。</p> 
<h2 id="docker%E7%BB%84%E6%88%90">docker组成</h2> 
<p><img alt="" height="921" src="https://images2.imgbox.com/60/f8/o5VLZIsf_o.png" width="1200"></p> 
<p>Docker由多个组件组成，这些组件协同工作，提供了容器化应用的构建、运行和管理环境。以下是Docker的主要组成部分：</p> 
<ul><li> <p><strong>Docker Daemon（Docker守护进程）：</strong></p> </li><li> <p>Docker Daemon是一个运行在宿主机上的后台服务，负责管理Docker的容器。它接收来自Docker客户端的命令，并通过Docker API执行这些命令。Docker Daemon与宿主机的内核通信，负责创建、运行和管理容器。</p> </li><li> <p><strong>Docker Client（Docker客户端）：</strong></p> </li><li> <p>Docker客户端是与Docker Daemon进行交互的命令行工具或图形用户界面。开发者通过Docker客户端发送命令给Docker Daemon，执行诸如构建镜像、创建容器、查看日志等操作。</p> </li><li> <p><strong>Docker Image（Docker镜像）：</strong></p> </li><li> <p>Docker镜像是应用程序和其依赖项的打包，包含了容器运行所需的文件系统、库、工具、环境变量等。镜像是只读的，由多个层组成。Docker支持从已有的镜像构建新的镜像。</p> </li><li> <p><strong>Docker Container（Docker容器）：</strong></p> </li><li> <p>Docker容器是基于Docker镜像创建的运行实例。容器是独立、可移植的单元，包含应用程序及其运行环境。每个容器都在宿主机上运行一个独立的进程，并通过命名空间和cgroup实现资源隔离。</p> </li><li> <p><strong>Docker Registry（Docker仓库）：</strong></p> </li><li> <p>Docker仓库用于存储和分享Docker镜像。Docker Hub是一个公共的Docker仓库，包含了大量开发者分享的镜像。企业可以搭建私有的Docker仓库，用于组织内部的镜像存储和分享。</p> </li><li> <p><strong>Docker Compose：</strong></p> </li><li> <p>Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。通过编写一个<code>docker-compose.yml</code>文件，可以定义应用程序的服务、网络、卷等配置，然后通过一个命令启动整个应用。</p> </li><li> <p><strong>Docker Swarm：</strong></p> </li><li> <p>Docker Swarm是Docker官方提供的用于容器编排和集群管理的工具。它允许将多个Docker守护进程组成一个集群，以便实现容器的高可用性、负载均衡等特性。</p> </li></ul> 
<p>这些组件共同构建了Docker的生态系统，使得容器化应用的构建、部署和管理变得更加简单和高效</p> 
<h2 id="docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4">docker基础命令</h2> 
<h4 id="%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%EF%BC%9A">容器生命周期管理：</h4> 
<ul><li> <p><strong>创建与启动：</strong></p> </li><li> <p><code>docker create</code>: 创建一个新的容器，但不启动它。</p> </li><li> <p><code>docker run</code>: 创建并启动一个容器。</p> </li><li> <p><code>docker start</code>: 启动一个已经存在的容器。</p> </li><li> <p><strong>停止与删除：</strong></p> </li><li> <p><code>docker stop</code>: 停止一个运行中的容器。</p> </li><li> <p><code>docker restart</code>: 重启一个容器。</p> </li><li> <p><code>docker kill</code>: 强制停止一个运行中的容器。</p> </li><li> <p><code>docker rm</code>: 删除一个或多个容器。</p> </li><li> <p><strong>暂停与恢复：</strong></p> </li><li> <p><code>docker pause</code>: 暂停一个运行中的容器。</p> </li><li> <p><code>docker unpause</code>: 恢复一个暂停的容器。</p> </li><li> <p><strong>查看与管理：</strong></p> </li><li> <p><code>docker ps</code>: 列出当前正在运行的容器。</p> </li><li> <p><code>docker ps -a</code>: 列出所有的容器，包括停止的。</p> </li><li> <p><code>docker inspect</code>: 显示容器的详细信息。</p> </li><li> <p><code>docker logs</code>: 查看容器的日志输出。</p> </li></ul> 
<h4 id="%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86%EF%BC%9A">镜像管理：</h4> 
<ul><li> <p><strong>查看与拉取：</strong></p> </li><li> <p><code>docker images</code> 或 <code>docker image ls</code>: 列出本地所有的镜像。</p> </li><li> <p><code>docker pull</code>: 从仓库中拉取镜像。</p> </li><li> <p><strong>构建与发布：</strong></p> </li><li> <p><code>docker build</code>: 根据Dockerfile构建镜像。</p> </li><li> <p><code>docker tag</code>: 给镜像打标签。</p> </li><li> <p><code>docker push</code>: 将镜像推送到仓库。</p> </li><li> <p><code>docker rmi</code>: 删除一个或多个本地镜像。</p> </li></ul> 
<h4 id="-2">网络与数据卷管理：</h4> 
<ul><li> <p><strong>网络操作：</strong></p> </li><li> <p><code>docker network ls</code>: 列出所有的网络。</p> </li><li> <p><code>docker network create</code>: 创建一个新的网络。</p> </li><li> <p><code>docker network connect</code>: 将容器连接到网络。</p> </li><li> <p><code>docker network disconnect</code>: 将容器从网络中断开。</p> </li><li> <p><strong>数据卷操作：</strong></p> </li><li> <p><code>docker volume ls</code>: 列出所有的数据卷。</p> </li><li> <p><code>docker volume create</code>: 创建一个新的数据卷。</p> </li><li> <p><code>docker volume rm</code>: 删除一个或多个数据卷。</p> </li></ul> 
<h4 id="-3">容器执行与交互：</h4> 
<ul><li> <p><strong>命令执行：</strong></p> </li><li> <p><code>docker exec</code>: 在运行中的容器中执行命令。</p> </li><li> <p><strong>交互式 Shell：</strong></p> </li><li> <p><code>docker run -it</code>: 以交互式模式运行容器，通常与 <code>/bin/bash</code> 等交互式Shell一起使用。</p> </li></ul> 
<h4 id="dockercomposeswarm">Docker Compose 与 Swarm：</h4> 
<p>Docker Compose 主要用于本地开发和测试环境，而 Docker Swarm 用于构建和管理生产环境中的容器集群。</p> 
<ul><li> <p><strong>Docker Compose：</strong></p> </li><li> <p><code>docker-compose up</code>: 启动Docker Compose定义的服务。</p> </li><li> <p><code>docker-compose down</code>: 停止并删除Docker Compose定义的服务。</p> </li><li> <p><strong>Docker Swarm：</strong></p> </li><li> <p><code>docker swarm init</code>: 初始化一个Swarm。</p> </li><li> <p><code>docker service create</code>: 在Swarm中创建一个服务。</p> </li><li> <p><code>docker node ls</code>: 列出Swarm中的节点信息。</p> </li></ul> 
<h4 id="-4">其他常用命令：</h4> 
<ul><li> <p><code>docker info</code>: 显示Docker系统信息。</p> </li><li> <p><code>docker version</code>: 显示Docker版本信息。</p> </li><li> <p><code>docker inspect</code>: 显示详细的对象信息。</p> </li><li> <p><code>docker search</code>: 在Docker Hub中搜索镜像。</p> </li></ul> 
<p>这些命令涵盖了Docker的各个方面，允许用户创建、管理、发布和运行容器化应用。通过使用这些命令，用户可以有效地进行容器化工作流程的管理和操作。</p> 
<h3 id="-5">最常用的命令</h3> 
<ul><li> <p><strong>容器生命周期管理命令：</strong></p> </li><li> <p><code>docker create</code>: 创建一个新的容器，但不启动它。</p> </li><li> <p><code>docker start</code>: 启动一个已经存在的容器。</p> </li><li> <p><code>docker stop</code>: 停止一个运行中的容器。</p> </li><li> <p><code>docker restart</code>: 重启一个容器。</p> </li><li> <p><code>docker kill</code>: 强制停止一个运行中的容器.</p> </li><li> <p><code>docker rm</code>: 删除一个或多个容器。</p> </li><li> <p><code>docker pause</code>: 暂停一个运行中的容器。</p> </li><li> <p><code>docker unpause</code>: 恢复一个暂停的容器.</p> </li><li> <p><strong>镜像管理命令：</strong></p> </li><li> <p><code>docker pull</code>: 从仓库中拉取镜像。</p> </li><li> <p><code>docker images</code> 或 <code>docker image ls</code>: 列出本地所有的镜像。</p> </li><li> <p><code>docker build</code>: 根据 Dockerfile 构建镜像。</p> </li><li> <p><code>docker tag</code>: 给镜像打标签。</p> </li><li> <p><code>docker rmi</code>: 删除一个或多个本地镜像。</p> </li><li> <p><strong>导入导出与保存加载命令：</strong></p> </li><li> <p><code>docker save -o xxx.tar</code>: 将镜像保存为 tar 归档文件。</p> </li><li> <p><code>docker load -i xxx.tar</code>: 从 tar 归档文件中加载镜像。</p> </li><li> <p><code>docker export</code>: 将容器导出为 tar 归档文件。</p> </li><li> <p><code>docker import</code>: 从 tar 归档文件中导入容器。</p> </li><li> <p><strong>搜索与登录命令：</strong></p> </li><li> <p><code>docker search</code>: 在 Docker Hub 中搜索镜像。</p> </li><li> <p><code>docker login -u</code>: 登录到 Docker Hub。</p> </li><li> <p><strong>推送与拉取命令：</strong></p> </li><li> <p><code>docker push</code>: 将镜像推送到仓库。</p> </li><li> <p><code>docker pull</code>: 从仓库中拉取镜像。</p> </li><li> <p><strong>容器操作与查看命令：</strong></p> </li><li> <p><code>docker ps</code>: 列出当前正在运行的容器。</p> </li><li> <p><code>docker ps -a</code>: 列出所有的容器，包括停止的。</p> </li><li> <p><code>docker inspect</code>: 显示容器的详细信息。</p> </li><li> <p><code>docker logs</code>: 查看容器的日志。</p> </li><li> <p><strong>其他命令：</strong></p> </li><li> <p><code>docker run</code>: 创建并启动一个容器。</p> </li><li> <p><code>docker kill</code>: 强制停止一个运行中的容器。</p> </li><li> <p><code>docker cp</code>: 从容器复制文件到主机或者从主机复制文件到容器。</p> </li></ul> 
<p></p> 
<h3 id="docker%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E6%B5%81%E7%A8%8B">docker运行命令的流程</h3> 
<p><img alt="" height="1029" src="https://images2.imgbox.com/9c/d1/XMRtMN8x_o.png" width="1200"></p> 
<ul><li> <p><strong>Docker客户端发送命令：</strong> 在命令行界面或终端中，用户使用<code>docker run</code>命令启动容器，比如<code>docker run -it ubuntu bash</code>。</p> </li><li> <p><strong>检查本地镜像：</strong> Docker 客户端首先检查本地是否存在指定镜像（在这个例子中是<code>ubuntu</code>）。如果本地没有这个镜像，它会执行下载操作。</p> </li><li> <p><strong>从注册中心拉取镜像：</strong> 如果本地没有所需的镜像，Docker 客户端会向默认的镜像仓库（如Docker Hub）发出请求以下载镜像。镜像仓库中存储了大量镜像供用户使用。下载的命令是<code>docker pull ubuntu</code>。</p> </li><li> <p><strong>镜像拉取完成：</strong> 一旦镜像下载完成，它会保存在本地的镜像仓库中，可以通过<code>docker images</code>命令查看。</p> </li><li> <p><strong>创建容器：</strong> 接下来，Docker 客户端根据下载的镜像创建容器。容器是镜像的一个实例，包含了运行时的文件系统和必要的运行环境。<code>docker run</code>命令的参数（比如<code>-it</code>、<code>ubuntu</code>、<code>bash</code>）指定了容器的交互方式和要运行的命令。</p> </li><li> <p><strong>容器启动：</strong> 创建容器后，Docker 会启动该容器。在这个例子中，会启动一个交互式的 Ubuntu 容器，并在容器中启动 Bash shell。</p> </li><li> <p><strong>用户与容器交互：</strong> 用户可以在 Bash shell 中执行各种命令，这些命令将在这个 Ubuntu 容器中执行。用户可以在容器内部进行文件操作、安装软件包、运行应用程序等。</p> </li><li> <p><strong>停止容器：</strong> 当用户退出容器或者容器内部的应用程序执行完毕后，容器会停止运行。这时可以使用<code>docker stop</code>命令停止容器。</p> </li></ul> 
<h2 id="%E9%83%A8%E7%BD%B2%E5%AE%9E%E4%BE%8B">部署实例</h2> 
<p>在centos中部署，为方便演示，关闭了防火墙和安全机制</p> 
<pre><code># 停止防火墙服务和关闭 SELinux
systemctl stop firewalld.service
setenforce 0
</code></pre> 
<p>这部分命令用于停止防火墙服务和关闭SELinux。这可能是为了确保Docker的正常运行而禁用了一些网络和安全功能。在生产环境中，请确保了解关闭SELinux和停止防火墙可能带来的安全风险。</p> 
<h2 id="%E5%AE%89%E8%A3%85docker">安装docker</h2> 
<pre><code># 安装依赖包
yum install -y yum-utils device-mapper-persistent-data lvm2
</code></pre> 
<ul><li> <p>yum-utils：提供了 yum-config-manager 工具。</p> </li><li> <p>device mapper： 是Linux内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构。</p> </li><li> <p>device mapper存储驱动程序需要 device-mapper-persistent-data 和 lvm2。</p> </li></ul> 
<pre><code># 设置阿里云镜像源
yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre> 
<p>这部分命令用于将Docker的yum源设置为阿里云镜像源。使用镜像源可以加速软件包的下载速度，提高安装效率。</p> 
<pre><code># 安装 Docker-CE 并设置为开机自动启动
yum install -y docker-ce docker-ce-cli containerd.io  # 安装最新版本
docker-ce-20.10.18
</code></pre> 
<p>这部分命令用于安装Docker-CE及其相关组件，并设置Docker服务在系统启动时自动启动。安装的Docker版本为20.10.18。最后两行命令用于启动和设置Docker服务。在这之前，通过yum-config-manager已经将yum源设置为阿里云镜像源。</p> 
<ul><li>安装好的Docker系统有两个程序，Docker服务端和Docker客户端。其中Docker服务端是一个服务进程，负责管理所有容器。 Docker客户端则扮演着Docker服务端的远程控制器，可以用来控制Docker的服务端进程。大部分情况下Docker服务端和客户端运行在一台机器上。</li></ul> 
<pre><code># 查看 Docker 版本信息
docker version

# Docker 信息查看
docker info

Client:
 Context:    default
 Debug Mode: false
 Plugins:
  app: Docker App (Docker Inc., v0.9.1-beta3)
  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)

Server:
 Containers: 0                    # 当前运行中的容器数量
  Running: 0
  Paused: 0
  Stopped: 0
 Images: 1                        # 存储的镜像数量
 Server Version: 20.10.3          # Docker 服务器版本
 Storage Driver: overlay2         # Docker 使用的存储驱动
  Backing Filesystem: xfs         # 宿主机上的底层文件系统
  Supports d_type: true
  Native Overlay Diff: true
 Logging Driver: json-file
 Cgroup Driver: cgroupfs           # Cgroups 驱动
 Cgroup Version: 1
 Plugins:
  Volume: local
  Network: bridge host ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
 Swarm: inactive
 Runtimes: io.containerd.runtime.v1.linux runc io.containerd.runc.v2
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: 269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc version: ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 init version: de40ad0
 Security Options:
  seccomp
   Profile: default
 Kernel Version: 3.10.0-693.el7.x86_64     # 宿主机的内核版本
 Operating System: CentOS Linux 7 (Core)
 OSType: linux
 Architecture: x86_64
 CPUs: 1
 Total Memory: 976.3MiB
 Name: localhost.localdomain
 ID: Y4ES:FTH2:ZJL7:MRVE:RJVB:WJIB:S7BV:C5IZ:LMBR:E4G5:QWSM:SNDT
 Docker Root Dir: /var/lib/docker        # Docker 数据存储目录
 Debug Mode: false
 Registry: https://index.docker.io/v1/   # Docker Registry 地址
 Labels:
 Experimental: false
 Insecure Registries:
  127.0.0.0/8
 Registry Mirrors:                      # Docker 镜像加速站点
  https://6ijb8ubo.mirror.aliyuncs.com/
 Live Restore Enabled: false
</code></pre> 
<p>这份脚本主要用于查看Docker的版本信息、容器和镜像数量、服务器配置、以及一些其他相关的配置参数。通过这些信息，可以更好地了解Docker的当前状态和配置。</p> 
<h2 id="docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C">docker镜像操作</h2> 
<p>Docker镜像的搜索、获取和加速下载的一组命令和步骤</p> 
<pre><code># 搜索镜像
# 格式：docker search 关键字
docker search nginx

# 获取镜像 nginx
# 格式：docker pull 仓库名称[:标签]
# 如果下载镜像时不指定标签，则默认会下载仓库中最新版本的镜像，即选择标签为 latest 标签。
docker pull nginx

# 镜像加速下载
# 浏览器访问 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 获取镜像加速器配置

# 创建 Docker 配置目录
mkdir -p /etc/docker

# 配置 Docker 镜像加速
tee /etc/docker/daemon.json &lt;&lt;-'EOF'
{
  "registry-mirrors": ["https://ae3f5qei.mirror.aliyuncs.com"]
}
EOF

# 重新加载 Docker 配置
systemctl daemon-reload

# 重启 Docker 服务
systemctl restart docker
</code></pre> 
<p>首先是Docker镜像的搜索命令 <code>docker search</code>，然后演示了如何通过 <code>docker pull</code> 命令获取指定仓库（这里是nginx）的镜像。最后，通过访问阿里云容器镜像服务，配置Docker镜像加速器，以提高下载速度。配置信息被写入 <code>/etc/docker/daemon.json</code> 文件中，然后通过重新加载 Docker 配置并重启 Docker 服务来使配置生效。</p> 
<pre><code># 查看镜像信息
# 镜像下载后存放在 /var/lib/docker 。
# Docker 相关的本地资源存放在 /var/lib/docker/ 目录下，其中 containers 目录存放容器信息，image 目录存放镜像信息，overlay2 目录下存放具体的镜像底层文件。

# 查看下载的镜像文件信息
cat /var/lib/docker/image/overlay2/repositories.json

# 查看下载到本地的所有镜像
docker images

REPOSITORY   TAG       IMAGE ID       CREATED      SIZE
nginx        latest    ae2feff98a0c   1 days ago   112MB
</code></pre> 
<p>上述命令首先提到了Docker镜像下载后存放的路径 <code>/var/lib/docker</code>，并介绍了该目录结构。然后通过 <code>cat</code> 命令查看了具体下载到本地的镜像文件信息，其路径为 <code>/var/lib/docker/image/overlay2/repositories.json</code>。最后，使用 <code>docker images</code> 命令列出了所有本地已下载的镜像，包括其仓库名、标签、镜像ID、创建时间和占用的磁盘空间大小。在这个例子中，只有一个名为 <code>nginx</code> 的镜像，标签为 <code>latest</code>。</p> 
<p><strong>解释：</strong></p> 
<ul><li> <p><strong>REPOSITORY</strong>: 镜像所属的仓库，表示镜像的来源和分类。</p> </li><li> <p><strong>TAG</strong>: 镜像的标签信息，用于区分同一仓库中不同版本或配置的镜像。</p> </li><li> <p><strong>IMAGE ID</strong>: 镜像的唯一ID号，是一个长字符串，用于唯一标识一个特定的镜像。</p> </li><li> <p><strong>CREATED</strong>: 镜像的创建时间，表示该镜像是什么时候构建的。</p> </li><li> <p><strong>SIZE</strong>: 镜像的大小，显示该镜像占用磁盘空间的大小。在你的例子中，这列被标记为 <code>VIRTUAL SIZE</code>，是因为它显示的是包括所有层（layers）的总大小，而不是单个镜像的实际磁盘占用。</p> </li><li> <p><strong>获取镜像详细信息</strong>：</p> </li></ul> 
<pre><code>docker inspect ae2feff98a0c
</code></pre> 
<p>此命令将显示与指定镜像ID关联的详细信息。</p> 
<ul><li><strong>为本地的镜像添加新的标签</strong>：</li></ul> 
<pre><code>docker tag nginx:latest nginx:web
</code></pre> 
<p>此命令将给本地的nginx镜像添加一个新标签<code>web</code>。</p> 
<pre><code>docker images | grep nginx
</code></pre> 
<p>该命令将显示所有包含“nginx”的本地镜像，以确认新标签已成功添加。</p> 
<ul><li><strong>删除镜像</strong>：</li></ul> 
<pre><code>docker rmi nginx:web
#当一个镜像有多个标签时，只是删除其中指定的标签
</code></pre> 
<p>此命令将删除名为<code>nginx:web</code>的本地镜像。</p> 
<p>注意：如果镜像被容器使用，应先删除依赖该镜像的所有容器，然后再删除镜像。可以使用以下命令删除容器：</p> 
<pre><code>docker rmi &lt;容器ID或容器名称&gt;
</code></pre> 
<p>然后再执行删除镜像的命令。</p> 
<ul><li><strong>存出镜像</strong>：将镜像保存为本地文件</li></ul> 
<pre><code>docker save -o nginx nginx:latest
#存出镜像命名为nginx存在当前目录下
</code></pre> 
<p>此命令将名为<code>nginx:latest</code>的本地镜像保存为文件<code>nginx</code>。</p> 
<pre><code>ls -lh
</code></pre> 
<p>查看当前目录下的文件，确认保存的镜像文件已创建。</p> 
<ul><li><strong>载入镜像</strong>：将镜像文件导入到镜像库中</li></ul> 
<pre><code>docker load &lt; nginx
</code></pre> 
<p>或者</p> 
<pre><code>docker load -i nginx
</code></pre> 
<p>这两个命令用于将之前保存的镜像文件导入到本地镜像库中。</p> 
<ul><li><strong>上传镜像到Docker Hub</strong>：</li></ul> 
<pre><code>docker tag nginx:latest soscscs/nginx:web
#添加新的标签时必须在前面加上自己的dockerhub的username
</code></pre> 
<p>此命令将本地的<code>nginx:latest</code>标签重新命名为<code>dockerhub的username/nginx:web</code>，以便上传到Docker Hub。</p> 
<pre><code>docker login #登录公共仓库
</code></pre> 
<p>使用此命令登录到Docker Hub，输入用户名、密码和邮箱完成注册和登录。</p> 
<pre><code>docker push soscscs/nginx:web    #上传镜像
</code></pre> 
<p>上传镜像到Docker Hub的公共仓库。</p> 
<h2 id="docker%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C">docker容器操作</h2> 
<p>容器创建：就是将镜像加载到容器的过程。 新创建的容器默认处于停止状态，不运行任何程序，需要在其中发起一个进程来启动容器。</p> 
<ul><li><strong>容器创建</strong>:</li></ul> 
<pre><code>格式：docker create [选项] 镜像
常用选项：
-i：让容器开启标准输入
-t：让 Docker 分配一个伪终端 tty
-it :合起来实现和容器交互的作用，运行一个交互式会话 shell 
</code></pre> 
<pre><code>docker create -it nginx:latest /bin/bash
</code></pre> 
<p>此命令将使用<code>nginx:latest</code>镜像创建一个交互式容器，同时运行<code>/bin/bash</code>作为容器的启动命令。选项 <code>-it</code> 实现了和容器的交互。</p> 
<ul><li><strong>查看容器的运行状态</strong>:</li></ul> 
<pre><code>docker ps -a
#-a 选项可以显示所有的容器
</code></pre> 
<p>此命令将显示所有容器的运行状态，包括已停止的容器。列出的信息包括容器ID、加载的镜像、运行的程序、创建时间、当前状态、端口映射和容器名称。</p> 
<p>示例输出：</p> 
<pre><code>CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS    PORTS     NAMES
8b0a7be0ff58   nginx:latest   "/docker-entrypoint.…"   57 seconds ago   Created             inspiring_swanson

容器的ID号       加载的镜像     运行的程序               创建时间       当前的状态  端口映射  名称
</code></pre> 
<p>其中，<code>STATUS</code> 列显示容器的当前状态，这里是 <code>Created</code> 表示容器已创建但未运行。</p> 
<ul><li> <p>请注意，要查看运行中的容器，可以省略 <code>-a</code> 选项。例如：<code>docker ps</code></p> </li><li> <p>如果要启动已创建的容器，可以使用 <code>docker start &lt;容器ID&gt;</code> 命令。</p> </li><li> <p><strong>启动容器：</strong></p> </li><li> <p>使用 <code>docker start 容器的ID/名称</code> 命令来启动已经创建过但处于停止状态的容器。</p> </li><li> <p>使用 <code>docker ps -a</code> 命令查看所有容器的状态。</p> <p>示例：</p> </li></ul> 
<pre><code>docker start 8b0a7be0ff58
docker ps -a
</code></pre> 
<ul><li> <p><strong>创建并启动容器：</strong></p> </li><li> <p>使用 <code>docker run</code> 命令可以直接创建并启动容器，相当于先执行 <code>docker create</code> 然后再执行 <code>docker start</code>。</p> </li><li> <p>容器需要有一个前台进程，否则容器会直接退出。</p> </li><li> <p>docker 容器默认会把容器内部第一个进程，也就是 pid=1 的程序作为docker容器是否正在运行的依据，如果docker容器中 pid = 1 的进程挂了，那么docker容器便会直接退出，也就是说Docker容器中必须有一个前台进程，否则认为容器已经挂掉。</p> <p>示例：</p> </li></ul> 
<pre><code>docker run centos:7 /usr/bin/bash -c ls /
docker ps -a
#会发现创建了一个新容器并启动执行一条 shell 命令，之后就停止了
</code></pre> 
<ul><li> <p><strong>在后台持续运行容器：</strong></p> </li><li> <p>使用 <code>docker run -d</code> 命令可以使容器在后台以守护形式运行。</p> </li><li> <p>如果希望容器一直保持运行状态，可以在容器内运行一个持续运行的程序。</p> <p>示例：</p> </li></ul> 
<pre><code>docker run -d centos:7 /usr/bin/bash -c "while true; do echo hello; done"
docker ps -a                    #可以看出容器始终处于 UP，运行状态
CONTAINER ID   IMAGE      COMMAND                  CREATED          STATUS         PORTS     NAMES
2592d3fad0fb   centos:7   "/usr/bin/bash -c 'w…"   2 seconds ago    Up 2 seconds             peaceful_chatelet
</code></pre> 
<ul><li> <p><strong>创建并在后台持续运行容器：</strong></p> </li><li> <p>使用 <code>docker run -itd --name 容器名称 镜像:标签 /bin/bash</code> 可以创建并在后台持续运行容器。</p> <p>示例：</p> </li></ul> 
<pre><code>docker run -itd --name test1 centos:7 /bin/bash
</code></pre> 
<p><strong>Docker 在后台的标准运行过程</strong></p> 
<ol><li><strong>检查本地是否存在指定的镜像：</strong></li></ol> 
<ul><li>Docker首先会检查本地是否已经存在所需的镜像。如果本地不存在，则会从配置的镜像仓库（通常是Docker Hub或其他私有仓库）中下载。</li></ul> 
<ol><li><strong>利用镜像创建并启动一个容器：</strong></li></ol> 
<ul><li>使用 <code>docker run</code> 命令，Docker根据指定的镜像创建并启动一个新的容器实例。</li></ul> 
<ol><li><strong>分配一个文件系统给容器，在只读的镜像层外面挂载一层可读写层：</strong></li></ol> 
<ul><li>Docker为每个容器分配一个文件系统。容器的文件系统包括一个只读的镜像层和一个可读写的层。这可读写层用于存储容器内部的文件变化，使得容器可以在运行时进行文件修改而不影响原始镜像。</li></ul> 
<ol><li><strong>从宿主主机配置的网桥接口中桥接一个虚拟机接口到容器中：</strong></li></ol> 
<ul><li>Docker使用网络桥接（bridge）来连接容器与宿主主机以及其他容器。每个容器都被分配一个唯一的IP地址，并通过桥接网络与主机和其他容器通信。</li></ul> 
<ol><li><strong>分配一个地址池中的 IP 地址给容器：</strong></li></ol> 
<ul><li>每个容器都被分配一个IP地址，以便在容器之间进行通信。Docker根据配置的网络模式（默认使用bridge模式）为容器分配IP地址。</li></ul> 
<ol><li><strong>执行用户指定的应用程序，执行完毕后容器被终止运行：</strong></li></ol> 
<ul><li>Docker运行容器内部的指定应用程序或进程。容器内的这个应用程序通常是容器的主进程，当该应用程序执行完毕时，容器会自动停止运行。</li></ul> 
<p>这个流程描述了Docker容器的生命周期，从创建到启动运行，再到应用程序执行完毕后的停止。</p> 
<ul><li> <p><strong>终止容器运行：</strong></p> </li><li> <p>使用 <code>docker stop 容器的ID/名称</code> 命令可以停止正在运行的容器。</p> </li><li> <p>使用 <code>docker ps -a</code> 命令查看所有容器的状态，确保已经停止。</p> <p>示例：</p> </li></ul> 
<pre><code>docker stop 2592d3fad0fb
docker ps -a
</code></pre> 
<ul><li> <p><strong>容器的进入：</strong></p> </li><li> <p>使用 <code>docker exec</code> 命令可以进入正在运行的容器进行命令操作。</p> </li><li> <p>格式：<code>docker exec -it 容器ID/名称 /bin/bash</code></p> 
  <ul><li> <p><code>-i</code> 选项表示让容器的输入保持打开；</p> </li><li> <p><code>-t</code> 选项表示让 Docker 分配一个伪终端。</p> </li></ul><p>示例：</p> </li></ul> 
<pre><code>docker start 2592d3fad0fb   # 进入容器前，确保容器正在运行
docker exec -it 2592d3fad0fb /bin/bash
ls
exit  # 退出容器后，容器仍在运行
docker ps -a
</code></pre> 
<ul><li> <p><strong>创建并进入容器：</strong></p> </li><li> <p>使用 <code>docker run -it</code> 可以创建并进入容器，不加 <code>-d</code> 选项会直接进入容器。</p> </li><li> <p>示例：<code>docker run -it centos:7 bash</code></p> </li><li> <p><strong>容器的导出与导入：</strong></p> </li><li> <p>使用 <code>docker export</code> 命令可以将已经创建的容器导出为一个文件。</p> </li><li> <p>格式：<code>docker export 容器ID/名称 &gt; 文件名</code></p> </li><li> <p>使用 <code>docker import</code> 命令可以通过导出的文件创建一个新的镜像。</p> </li><li> <p>格式：<code>cat 文件名 | docker import - 镜像名称:标签</code></p> <p>示例：</p> </li></ul> 
<pre><code>docker export 2592d3fad0fb &gt; centos7.tar
cat centos7.tar | docker import - centos7:test
</code></pre> 
<ul><li> <p><strong>删除容器：</strong></p> </li><li> <p>使用 <code>docker rm</code> 命令可以删除一个或多个容器。</p> </li><li> <p>格式：<code>docker rm [-f] 容器ID/名称</code></p> </li><li> <p><code>-f</code> 选项表示强制删除正在运行的容器。</p> <p>示例：</p> </li></ul> 
<pre><code>docker stop 2592d3fad0fb
docker rm 2592d3fad0fb

# 或者使用批量操作
docker ps -a | awk 'NR&gt;=2{print "docker stop "$1}' | bash
docker ps -a | awk 'NR&gt;=2{print "docker rm "$1}' | bash

# 强制删除正在运行的容器
docker rm -f 2592d3fad0fb
</code></pre> 
<ul><li> <p><strong>批量删除容器和镜像：</strong></p> </li><li> <p>使用 <code>xargs</code> 结合命令来批量停止和删除容器，以及删除镜像。</p> </li><li> <p>示例：</p> <pre><code>docker ps -a | awk 'NR&gt;=2{print $1}' | xargs docker stop
docker ps -a | awk 'NR&gt;=2{print $1}' | xargs docker rm
docker images | awk 'NR&gt;=2{print "docker rmi "$3}' | bash
docker images | grep none | awk '{print $3}' | xargs docker rmi
</code></pre> </li></ul> 
<ul><li> <p><strong>批量清理后台停止的容器：</strong></p> </li><li> <p>使用 <code>docker rm $(docker ps -a -q)</code> 可以一次性删除所有后台停止的容器。</p> <p>示例：</p> </li></ul> 
<pre><code>docker rm $(docker ps -a -q)
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a4e644773b107a0019e8fda71c52bed0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">系统性学习vue-组件及脚手架</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c0afba737f07083a4da10797cd9103f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ELK日志分析系统，ELFK详解部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>