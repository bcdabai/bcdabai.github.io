<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python学习笔记--字典和集合 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python学习笔记--字典和集合" />
<meta property="og:description" content="字典 添加键值对 为字典添加新的键值对很简单，直接给不存在的 key 赋值即可，具体语法格式如下：
dictname[key] = value
对各个部分的说明：
dictname 表示字典名称。key 表示新的键。value 表示新的值，只要是 Python 支持的数据类型都可以。 修改键值对 Python 字典中键（key）的名字不能被修改，我们只能修改值（value）。
字典中各元素的键必须是唯一的，因此，如果新添加元素的键与已存在元素的键相同，那么键所对应的值就会被新的值替换掉，以此达到修改元素值的目的。
是否存在指定键值对 如果要判断字典中是否存在指定键值对，首先应判断字典中是否有对应的键。判断字典是否包含指定键值对的键，可以使用 in 或 not in 运算符。 keys()、values() 和 items() 方法 将这三个方法放在一起介绍，是因为它们都用来获取字典中的特定数据：
keys() 方法用于返回字典中的所有键（key）；values() 方法用于返回字典中所有键对应的值（value）；items() 用于返回字典中所有的键值对（key-value）。 处理上面的返回数据可以：
1) 使用 list() 函数，将它们返回的数据转换成列表， 2) 使用 for in 循环遍历它们的返回值
a = {&#39;数学&#39;: 95, &#39;语文&#39;: 89, &#39;英语&#39;: 90} b = list(a.keys()) print(b) a = {&#39;数学&#39;: 95, &#39;语文&#39;: 89, &#39;英语&#39;: 90} for k in a.keys(): print(k,end=&#39; &#39;) print(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fda24662de726d1138d0197397b773c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-10T15:12:18+08:00" />
<meta property="article:modified_time" content="2022-08-10T15:12:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python学习笔记--字典和集合</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>字典</h3> 
<h2><strong>添加键值对</strong></h2> 
<p>为字典添加新的键值对很简单，直接给不存在的 key 赋值即可，具体语法格式如下：</p> 
<p>dictname[key] = value</p> 
<p>对各个部分的说明：</p> 
<ul><li>dictname 表示字典名称。</li><li>key 表示新的键。</li><li>value 表示新的值，只要是 Python 支持的数据类型都可以。</li></ul> 
<h2>修改键值对</h2> 
<p>Python 字典中键（key）的名字不能被修改，我们只能修改值（value）。<br><br> 字典中各元素的键必须是唯一的，因此，如果新添加元素的键与已存在元素的键相同，那么键所对应的值就会被新的值替换掉，以此达到修改元素值的目的。</p> 
<h2>是否存在指定键值对</h2> 
<p>如果要判断字典中是否存在指定键值对，首先应判断字典中是否有对应的键。判断字典是否包含指定键值对的键，可以使用 in 或 not in 运算符。 </p> 
<h3>keys()、values() 和 items() 方法</h3> 
<p>将这三个方法放在一起介绍，是因为它们都用来获取字典中的特定数据：</p> 
<ul><li>keys() 方法用于返回字典中的所有键（key）；</li><li>values() 方法用于返回字典中所有键对应的值（value）；</li><li>items() 用于返回字典中所有的键值对（key-value）。</li></ul> 
<p> 处理上面的返回数据可以：</p> 
<p>1) 使用 list() 函数，将它们返回的数据转换成列表， </p> 
<p>2) 使用 for in 循环遍历它们的返回值</p> 
<p></p> 
<pre><code class="language-python">a = {'数学': 95, '语文': 89, '英语': 90}
b = list(a.keys())
print(b)


a = {'数学': 95, '语文': 89, '英语': 90}
for k in a.keys():
    print(k,end=' ')
print("\n---------------")
for v in a.values():
    print(v,end=' ')
print("\n---------------")
for k,v in a.items():
    print("key:",k," value:",v)</code></pre> 
<h3>copy() 方法</h3> 
<p>copy() 方法返回一个字典的拷贝，也即返回一个具有相同键值对的新字典。 </p> 
<h3>update() 方法</h3> 
<p>update() 方法可以使用一个字典所包含的键值对来更新己有的字典。<br><br> 在执行 update() 方法时，如果被更新的字典中己包含对应的键值对，那么原 value 会被覆盖；如果被更新的字典中不包含对应的键值对，则该键值对被添加进去。 </p> 
<h3>pop() 和 popitem() 方法</h3> 
<p>pop() 和 popitem() 都用来删除字典中的键值对，不同的是，pop() 用来删除指定的键值对，而 popitem() 用来随机删除一个键值对，它们的语法格式如下：</p> 
<p>dictname.pop(key)<br> dictname.popitem()</p> 
<p>其中，dictname 表示字典名称，key 表示键。</p> 
<h3>setdefault() 方法</h3> 
<p>setdefault() 方法用来返回某个 key 对应的 value，其语法格式如下：</p> 
<p>dictname.setdefault(key, defaultvalue)</p> 
<p>说明，dictname 表示字典名称，key 表示键，defaultvalue 表示默认值（可以不写，不写的话是 None）。<br><br> 当指定的 key 不存在时，setdefault() 会先为这个不存在的 key 设置一个默认的 defaultvalue，然后再返回 defaultvalue。<br><br> 也就是说，setdefault() 方法总能返回指定 key 对应的 value：</p> 
<ul><li>如果该 key 存在，那么直接返回该 key 对应的 value；</li><li>如果该 key 不存在，那么先为该 key 设置默认的 defaultvalue，然后再返回该 key 对应的 defaultvalue。</li></ul> 
<h3>集合 </h3> 
<h3>向 set 集合中添加元素</h3> 
<p>set 集合中添加元素，可以使用 set 类型提供的 add() 方法实现，该方法的语法格式为：</p> 
<blockquote> 
 <p>setname.add(element)</p> 
</blockquote> 
<p>其中，setname 表示要添加元素的集合，element 表示要添加的元素内容。 </p> 
<h3>从set集合中删除元素</h3> 
<p>删除现有 set 集合中的指定元素，可以使用 remove() 方法，该方法的语法格式如下：</p> 
<blockquote> 
 <p>setname.remove(element)</p> 
</blockquote> 
<p>使用此方法删除集合中元素，需要注意的是，如果被删除元素本就不包含在集合中，则此方法会抛出 KeyError 错误。</p> 
<p></p> 
<table><caption>
   set方法 
 </caption><tbody><tr><th>方法名</th><th>语法格式</th><th>功能</th><th>实例</th></tr><tr><td>add()</td><td>set1.add()</td><td>向 set1 集合中添加数字、字符串、元组或者布尔类型</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set1.add((1,2))<br> &gt;&gt;&gt; set1<br> {(1, 2), 1, 2, 3}</td></tr><tr><td>clear()</td><td>set1.clear()</td><td>清空 set1 集合中所有元素</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set1.clear()<br> &gt;&gt;&gt; set1<br> set()<br><br> set()才表示空集合，{}表示的是空字典</td></tr><tr><td>copy()</td><td>set2 = set1.copy()</td><td>拷贝 set1 集合给 set2</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set2 = set1.copy()<br> &gt;&gt;&gt; set1.add(4)<br> &gt;&gt;&gt; set1<br> {1, 2, 3, 4}<br> &gt;&gt;&gt; set1<br> {1, 2, 3}</td></tr><tr><td>difference()</td><td> set3 = set1.difference(set2)</td><td>将 set1 中有而 set2 没有的元素给 set3</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set2 = {3,4}<br> &gt;&gt;&gt; set3 = set1.difference(set2)<br> &gt;&gt;&gt; set3<br> {1, 2}</td></tr><tr><td>difference_update()</td><td>set1.difference_update(set2)</td><td>从 set1 中删除与 set2 相同的元素</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set2 = {3,4}<br> &gt;&gt;&gt; set1.difference_update(set2)<br> &gt;&gt;&gt; set1<br> {1, 2}</td></tr><tr><td>discard()</td><td>set1.discard(elem)</td><td>删除 set1 中的 elem 元素</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set1.discard(2)<br> &gt;&gt;&gt; set1<br> {1, 3}<br> &gt;&gt;&gt; set1.discard(4)<br> {1, 3}</td></tr><tr><td>intersection()</td><td>set3 = set1.intersection(set2)</td><td>取 set1 和 set2 的交集给 set3</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set2 = {3,4}<br> &gt;&gt;&gt; set3 = set1.intersection(set2)<br> &gt;&gt;&gt; set3<br> {3}</td></tr><tr><td>intersection_update()</td><td>set1.intersection_update(set2)</td><td>取 set1和 set2 的交集，并更新给 set1</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set2 = {3,4}<br> &gt;&gt;&gt; set1.intersection_update(set2)<br> &gt;&gt;&gt; set1<br> {3}</td></tr><tr><td>isdisjoint()</td><td>set1.isdisjoint(set2)</td><td>判断 set1 和 set2 是否没有交集，有交集返回 False；没有交集返回 True</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set2 = {3,4}<br> &gt;&gt;&gt; set1.isdisjoint(set2)<br> False</td></tr><tr><td>issubset()</td><td>set1.issubset(set2)</td><td>判断 set1 是否是 set2 的子集</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set2 = {1,2}<br> &gt;&gt;&gt; set1.issubset(set2)<br> False</td></tr><tr><td>issuperset()</td><td>set1.issuperset(set2)</td><td>判断 set2 是否是 set1 的子集</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set2 = {1,2}<br> &gt;&gt;&gt; set1.issuperset(set2)<br> True</td></tr><tr><td>pop()</td><td>a = set1.pop()</td><td>取 set1 中一个元素，并赋值给 a</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; a = set1.pop()<br> &gt;&gt;&gt; set1<br> {2,3}<br> &gt;&gt;&gt; a<br> 1</td></tr><tr><td>remove()</td><td>set1.remove(elem)</td><td>移除 set1 中的 elem 元素</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set1.remove(2)<br> &gt;&gt;&gt; set1<br> {1, 3}<br> &gt;&gt;&gt; set1.remove(4)<br> Traceback (most recent call last):<br>   File "&lt;pyshell#90&gt;", line 1, in &lt;module&gt;<br>     set1.remove(4)<br> KeyError: 4</td></tr><tr><td>symmetric_difference()</td><td>set3 = set1.symmetric_difference(set2)</td><td>取 set1 和 set2 中互不相同的元素，给 set3</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set2 = {3,4}<br> &gt;&gt;&gt; set3 = set1.symmetric_difference(set2)<br> &gt;&gt;&gt; set3<br> {1, 2, 4}</td></tr><tr><td>symmetric_difference_update()</td><td>set1.symmetric_difference_update(set2)</td><td>取 set1 和 set2 中互不相同的元素，并更新给 set1</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set2 = {3,4}<br> &gt;&gt;&gt; set1.symmetric_difference_update(set2)<br> &gt;&gt;&gt; set1<br> {1, 2, 4}</td></tr><tr><td>union()</td><td>set3 = set1.union(set2)</td><td>取 set1 和 set2 的并集，赋给 set3</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set2 = {3,4}<br> &gt;&gt;&gt; set3=set1.union(set2)<br> &gt;&gt;&gt; set3<br> {1, 2, 3, 4}</td></tr><tr><td>update()</td><td>set1.update(elem)</td><td>添加列表或集合中的元素到 set1</td><td>&gt;&gt;&gt; set1 = {1,2,3}<br> &gt;&gt;&gt; set1.update([3,4])<br> &gt;&gt;&gt; set1<br> {1,2,3,4}</td></tr></tbody></table> 
<h3>fronzenset集合</h3> 
<p>set 集合是可变序列，程序可以改变序列中的元素；frozenset 集合是不可变序列，程序不能改变序列中的元素。</p> 
<p></p> 
<p>两种情况下可以使用 fronzenset：</p> 
<ul><li>当集合的元素不需要改变时，我们可以使用 fronzenset 替代 set，这样更加安全。</li><li>有时候程序要求必须是不可变对象，这个时候也要使用 fronzenset 替代 set。比如，字典（dict）的键（key）就要求是不可变对象。 </li></ul> 
<p> set 集合本身的元素必须是不可变的， 所以 set 的元素不能是 set，只能是 frozenset。</p> 
<h3><strong>zip() 函数</strong></h3> 
<blockquote> 
 <p>zip(iterable, ...)</p> 
</blockquote> 
<p>其中 iterable,... 表示多个列表、元组、字典、集合、字符串，甚至还可以为 range() 区间。在使用 zip() 函数“压缩”多个序列时，它会分别取各序列中第 1 个元素、第 2 个元素、... 第 n 个元素，各自组成新的元组。需要注意的是，当多个序列中元素个数不一致时，会以最短的序列为准进行压缩。<br>  </p> 
<h3> reversed函数</h3> 
<p>功能是对于给定的序列（包括列表、元组、字符串以及 range(n) 区间），该函数可以返回一个逆序序列的迭代器（用于遍历该逆序序列）。 </p> 
<p>reserved() 函数的语法格式如下：</p> 
<blockquote> 
 <p>reversed(seq)</p> 
</blockquote> 
<p>其中，seq 可以是列表，元素，字符串以及 range() 生成的区间列表。、</p> 
<h3>sorted函数 </h3> 
<p>功能是对序列（列表、元组、字典、集合、还包括字符串）进行排序。 </p> 
<p>sorted() 函数的基本语法格式如下：</p> 
<blockquote> 
 <p>list = sorted(iterable, key=None, reverse=False)  </p> 
</blockquote> 
<p>其中，iterable 表示指定的序列，key 参数可以自定义排序规则；reverse 参数指定以升序（False，默认）还是降序（True）进行排序。sorted() 函数会返回一个排好序的列表。</p> 
<blockquote> 
 <p>注意，key 参数和 reverse 参数是可选参数，即可以使用，也可以忽略。</p> 
</blockquote> 
<p> </p> 
<p><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4711f6d085b294cb12429f9062fb2409/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue-puzzle-vcode与vue-drag-verify纯前端的拼图人机验证、右滑拼图验证</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d0b8462740ebd620f3db8b373ba59820/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win10下在虚拟机中下载安装ubuntu16、下载安装Anaconda以及apt/pip/conda换源等系列操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>