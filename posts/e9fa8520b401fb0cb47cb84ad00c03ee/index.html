<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【OpenCV3学习笔记 】相机标定函数 calibrateCamera( ) 使用详解（附相机标定程序和数据） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【OpenCV3学习笔记 】相机标定函数 calibrateCamera( ) 使用详解（附相机标定程序和数据）" />
<meta property="og:description" content="函数作用： 根据校准模式的几个视图（也就是相机拍的几张不同的图片），求解摄像机的内在参数和外在参数。 在每个视图中，必须指定三维物体点及其相应的二维投影的坐标。这可以通过使用已知几何形状和易于检测特征点的对象来实现。这样的对象称为标定或校准模式，而且OpenCV有对棋盘标定的内置支持（见findchessboardcorners）。目前，固有参数的初始化（当cv_calib_use_intrinsic_guess未设置）只实现平面校准模式（对象点的z坐标，必须全部为零）。 只要提供初始相机内参矩阵cameramatrix，也可以用于三维标定装置。
该算法执行以下步骤： 计算初始的内在参数（只能用于平面校准模式的选项）或从输入参数中读取它们。畸变系数都为零开始，除非有cv_calib_fix_k指定。 估计初始相机的姿态，就像内在参数已经已知一样。这是通过使用solvepnp。 运行的全局Levenberg Marquardt优化算法来最小化投影误差，投影误差等于所提取到的图像上的特征点坐标和三维点根据使用相机的参数和姿态计算得到的图像上的投影坐标的距离的综合。
函数原型：（opencv3帮助文档） double cv::calibrateCamera ( InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, OutputArray stdDeviationsIntrinsics, OutputArray stdDeviationsExtrinsics, OutputArray perViewErrors, int flags = 0, TermCriteria criteria = TermCriteria(TermCriteria::COUNT&#43;TermCriteria::EPS, 30, DBL_EPSILON) ) double cv::calibrateCamera ( InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags = 0, TermCriteria criteria = TermCriteria(TermCriteria::COUNT&#43;TermCriteria::EPS, 30, DBL_EPSILON) ) 参数 objectPoints ：世界坐标系中的点。在使用时，应该输入vector&lt; vector&lt; Point3f &gt; &gt;。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e9fa8520b401fb0cb47cb84ad00c03ee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-06-27T20:47:32+08:00" />
<meta property="article:modified_time" content="2017-06-27T20:47:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【OpenCV3学习笔记 】相机标定函数 calibrateCamera( ) 使用详解（附相机标定程序和数据）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="函数作用">函数作用：</h2> 
<p>根据校准模式的几个视图（也就是相机拍的几张不同的图片），求解摄像机的内在参数和外在参数。 <br> 在每个视图中，必须指定三维物体点及其相应的二维投影的坐标。这可以通过使用已知几何形状和易于检测特征点的对象来实现。这样的对象称为标定或校准模式，而且OpenCV有对棋盘标定的内置支持（见findchessboardcorners）。目前，固有参数的初始化（当cv_calib_use_intrinsic_guess未设置）只实现平面校准模式（对象点的z坐标，必须全部为零）。 <br> 只要提供初始相机内参矩阵cameramatrix，也可以用于三维标定装置。</p> 
<p>该算法执行以下步骤： <br> 计算初始的内在参数（只能用于平面校准模式的选项）或从输入参数中读取它们。畸变系数都为零开始，除非有cv_calib_fix_k指定。 <br> 估计初始相机的姿态，就像内在参数已经已知一样。这是通过使用solvepnp。 <br> 运行的全局Levenberg Marquardt优化算法来最小化投影误差，投影误差等于所提取到的图像上的特征点坐标和三维点根据使用相机的参数和姿态计算得到的图像上的投影坐标的距离的综合。</p> 
<h3 id="函数原型opencv3帮助文档">函数原型：（<a href="http://docs.opencv.org/3.2.0/d9/d0c/group__calib3d.html#ga3207604e4b1a1758aa66acb6ed5aa65d" rel="nofollow noopener noreferrer" target="_blank">opencv3帮助文档</a>）</h3> 
<pre class="prettyprint"><code class=" hljs lasso">double cv<span class="hljs-tag">::calibrateCamera</span>  (   
InputArrayOfArrays  objectPoints,
InputArrayOfArrays  imagePoints,
Size    imageSize,
InputOutputArray    cameraMatrix,
InputOutputArray    distCoeffs,
OutputArrayOfArrays     rvecs,
OutputArrayOfArrays     tvecs,
OutputArray     stdDeviationsIntrinsics,
OutputArray     stdDeviationsExtrinsics,
OutputArray     perViewErrors,
int             flags <span class="hljs-subst">=</span> <span class="hljs-number">0</span>,
TermCriteria    criteria <span class="hljs-subst">=</span> TermCriteria(TermCriteria<span class="hljs-tag">::COUNT</span><span class="hljs-subst">+</span>TermCriteria<span class="hljs-tag">::EPS</span>, <span class="hljs-number">30</span>, DBL_EPSILON) 
)       </code></pre> 
<pre class="prettyprint"><code class=" hljs lasso">double cv<span class="hljs-tag">::calibrateCamera</span>  (   
InputArrayOfArrays  objectPoints,
InputArrayOfArrays  imagePoints,
Size    imageSize,
InputOutputArray    cameraMatrix,
InputOutputArray    distCoeffs,
OutputArrayOfArrays     rvecs,
OutputArrayOfArrays     tvecs,
int     flags <span class="hljs-subst">=</span> <span class="hljs-number">0</span>,
TermCriteria    criteria <span class="hljs-subst">=</span> TermCriteria(TermCriteria<span class="hljs-tag">::COUNT</span><span class="hljs-subst">+</span>TermCriteria<span class="hljs-tag">::EPS</span>, <span class="hljs-number">30</span>, DBL_EPSILON) 
)   </code></pre> 
<h4 id="参数">参数</h4> 
<p>objectPoints ：世界坐标系中的点。在使用时，应该输入vector&lt; vector&lt; Point3f &gt; &gt;。</p> 
<p>imagePoints ：其对应的图像点。和objectPoints一样，应该输入vector&lt; vector&lt; Point2f &gt; &gt;型的变量。</p> 
<p>imageSize ：图像的大小，在计算相机的内参数和畸变矩阵需要用到；</p> 
<p>cameraMatrix ：内参数矩阵。输入一个Mat cameraMatrix即可。</p> 
<p>distCoeffs ：畸变矩阵。输入一个Mat distCoeffs即可。</p> 
<p>rvecs ：旋转向量；应该输入一个Mat的vector，即vector&lt; Mat &gt; rvecs因为每个vector&lt; Point3f &gt;会得到一个rvecs。</p> 
<p>tvecs ：位移向量；和rvecs一样，也应该为vector tvecs。</p> 
<p>stdDeviationsIntrinsics ：内参数的输出向量。输出顺序为: (fx,fy,cx,cy,k1,k2,p1,p2,k3,k4,k5,k6,s1,s2,s3,s4,τx,τy) ，如果不估计其中某一个参数，值等于0</p> 
<p>stdDeviationsExtrinsics ：外参数的输出向量。输出顺序: (R1,T1,…,RM,TM) ，M是标定图片的个数, Ri,Ti 是1x3的向量 。</p> 
<p>perViewErrors 每个标定图片的重投影均方根误差的输出向量。</p> 
<p>criteria： 迭代优化算法的终止准则</p> 
<p>flags ：<font color="#DC143C" size="4" face="黑体">标定函数是所采用的模型（重点）”</font>。 <br> 可输入如下某个或者某几个参数：</p> 
<p><font color="#DC143C" size="4" face="黑体">CV_CALIB_USE_INTRINSIC_GUESS</font>：使用该参数时，将包含有效的fx,fy,cx,cy的估计值的内参矩阵cameraMatrix，作为初始值输入，然后函数对其做进一步优化。如果不使用这个参数，用图像的中心点初始化光轴点坐标(cx, cy)，使用最小二乘估算出fx，fy（这种求法好像和张正友的论文不一样，不知道为何要这样处理）。注意，如果已知内部参数（内参矩阵和畸变系数），就不需要使用这个函数来估计外参，可以使用solvepnp()函数计算外参数矩阵。</p> 
<p><font color="#DC143C" size="4" face="黑体">CV_CALIB_FIX_PRINCIPAL_POINT</font>：在进行优化时会固定光轴点，光轴点将保持为图像的中心点。当CV_CALIB_USE_INTRINSIC_GUESS参数被设置，保持为输入的值。</p> 
<p><font color="#DC143C" size="4" face="黑体">CV_CALIB_FIX_ASPECT_RATIO</font>：固定fx/fy的比值，只将fy作为可变量，进行优化计算。当CV_CALIB_USE_INTRINSIC_GUESS没有被设置，fx和fy的实际输入值将会被忽略，只有fx/fy的比值被计算和使用。</p> 
<p><font color="#DC143C" size="4" face="黑体">CV_CALIB_ZERO_TANGENT_DIST</font>：切向畸变系数（P1，P2）被设置为零并保持为零。</p> 
<p><font color="#DC143C" size="4" face="黑体">CV_CALIB_FIX_K1,…,CV_CALIB_FIX_K6</font>：对应的径向畸变系数在优化中保持不变。如果设置了CV_CALIB_USE_INTRINSIC_GUESS参数，就从提供的畸变系数矩阵中得到。否则，设置为0。</p> 
<p><font color="#DC143C" size="4" face="黑体">CV_CALIB_RATIONAL_MODEL</font>（理想模型）：启用畸变k4，k5，k6三个畸变参数。使标定函数使用有理模型，返回8个系数。如果没有设置，则只计算其它5个畸变参数。</p> 
<p><font color="#DC143C" size="4" face="黑体">CALIB_THIN_PRISM_MODEL</font> （薄棱镜畸变模型）：启用畸变系数S1、S2、S3和S4。使标定函数使用薄棱柱模型并返回12个系数。如果不设置标志，则函数计算并返回只有5个失真系数。</p> 
<p><font color="#DC143C" size="4" face="黑体">CALIB_FIX_S1_S2_S3_S4 </font>：优化过程中不改变薄棱镜畸变系数S1、S2、S3、S4。如果cv_calib_use_intrinsic_guess设置，使用提供的畸变系数矩阵中的值。否则，设置为0。</p> 
<p><font color="#DC143C" size="4" face="黑体">CALIB_TILTED_MODEL</font> （倾斜模型）：启用畸变系数tauX and tauY。标定函数使用倾斜传感器模型并返回14个系数。如果不设置标志，则函数计算并返回只有5个失真系数。</p> 
<p><font color="#DC143C" size="4" face="黑体">CALIB_FIX_TAUX_TAUY </font>：在优化过程中，倾斜传感器模型的系数不被改变。如果cv_calib_use_intrinsic_guess设置，从提供的畸变系数矩阵中得到。否则，设置为0。</p> 
<h4 id="函数返回">函数返回</h4> 
<p>重投影的总的均方根误差。</p> 
<h2 id="完整的程序">完整的程序</h2> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include "opencv.hpp"</span>

<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;fstream&gt; </span>
<span class="hljs-preprocessor">#include &lt;io.h&gt;  </span>
<span class="hljs-preprocessor">#include &lt;string&gt;  </span>
<span class="hljs-preprocessor">#include&lt;vector&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">/* 
@param File_Directory 为文件夹目录
@param FileType 为需要查找的文件类型
@param FilesName 为存放文件名的容器
*/</span>
<span class="hljs-keyword">void</span> getFilesName(<span class="hljs-built_in">string</span> &amp;File_Directory, <span class="hljs-built_in">string</span> &amp;FileType, <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>&amp;FilesName)
{
    <span class="hljs-built_in">string</span> buffer = File_Directory + <span class="hljs-string">"\\*"</span> + FileType;

    _finddata_t c_file;   <span class="hljs-comment">// 存放文件名的结构体</span>

    <span class="hljs-keyword">long</span> hFile;
    hFile = _findfirst(buffer.c_str(), &amp;c_file);   <span class="hljs-comment">//找第一个文件命</span>

    <span class="hljs-keyword">if</span> (hFile == -<span class="hljs-number">1L</span>)   <span class="hljs-comment">// 检查文件夹目录下存在需要查找的文件</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No %s files in current directory!\n"</span>, FileType);
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">string</span> fullFilePath;
        <span class="hljs-keyword">do</span>
        {
            fullFilePath.clear();

            <span class="hljs-comment">//名字</span>
            fullFilePath = File_Directory + <span class="hljs-string">"\\"</span> + c_file.name;

            FilesName.push_back(fullFilePath);

        } <span class="hljs-keyword">while</span> (_findnext(hFile, &amp;c_file) == <span class="hljs-number">0</span>);  <span class="hljs-comment">//如果找到下个文件的名字成功的话就返回0,否则返回-1  </span>
        _findclose(hFile);
    }
}

<span class="hljs-keyword">void</span> m_calibration(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> &amp;FilesName, Size board_size, Size square_size, Mat &amp;cameraMatrix, Mat &amp;distCoeffs, <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Mat&gt;</span> &amp;rvecsMat, <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Mat&gt;</span> &amp;tvecsMat)
{
    ofstream fout(<span class="hljs-string">"caliberation_result.txt"</span>);                       <span class="hljs-comment">// 保存标定结果的文件 </span>

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"开始提取角点………………"</span> &lt;&lt; endl;
    <span class="hljs-keyword">int</span> image_count = <span class="hljs-number">0</span>;                                            <span class="hljs-comment">// 图像数量 </span>
    Size image_size;                                                <span class="hljs-comment">// 图像的尺寸 </span>

    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Point2f&gt;</span> image_points;                                   <span class="hljs-comment">// 缓存每幅图像上检测到的角点</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Point2f&gt;</span>&gt;</span> image_points_seq;                       <span class="hljs-comment">// 保存检测到的所有角点</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; FilesName.size();i++)
    {
        image_count++;

        <span class="hljs-comment">// 用于观察检验输出</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"image_count = "</span> &lt;&lt; image_count &lt;&lt; endl;
        Mat imageInput = imread(FilesName[i]);
        <span class="hljs-keyword">if</span> (image_count == <span class="hljs-number">1</span>)  <span class="hljs-comment">//读入第一张图片时获取图像宽高信息</span>
        {
            image_size.width = imageInput.cols;
            image_size.height = imageInput.rows;
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"image_size.width = "</span> &lt;&lt; image_size.width &lt;&lt; endl;
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"image_size.height = "</span> &lt;&lt; image_size.height &lt;&lt; endl;
        }

        <span class="hljs-comment">/* 提取角点 */</span>
        <span class="hljs-keyword">bool</span> ok = findChessboardCorners(imageInput, board_size, image_points, CV_CALIB_CB_ADAPTIVE_THRESH | CV_CALIB_CB_NORMALIZE_IMAGE);
        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == ok)
        {
            <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"第"</span>&lt;&lt; image_count &lt;&lt;<span class="hljs-string">"张照片提取角点失败，请删除后，重新标定！"</span>&lt;&lt;endl; <span class="hljs-comment">//找不到角点</span>
            imshow(<span class="hljs-string">"失败照片"</span>, imageInput);
            waitKey(<span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">else</span>
        {
            Mat view_gray;
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"imageInput.channels()="</span> &lt;&lt; imageInput.channels() &lt;&lt; endl;
            cvtColor(imageInput, view_gray, CV_RGB2GRAY);

            <span class="hljs-comment">/* 亚像素精确化 */</span>
            <span class="hljs-comment">//find4QuadCornerSubpix(view_gray, image_points, Size(5, 5)); //对粗提取的角点进行精确化</span>
            cv::cornerSubPix(view_gray, image_points, cv::Size(<span class="hljs-number">11</span>, <span class="hljs-number">11</span>), cv::Size(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), cv::TermCriteria(CV_TERMCRIT_ITER + CV_TERMCRIT_EPS, <span class="hljs-number">20</span>, <span class="hljs-number">0.01</span>));

            image_points_seq.push_back(image_points);  <span class="hljs-comment">//保存亚像素角点</span>

            <span class="hljs-comment">/* 在图像上显示角点位置 */</span>
            drawChessboardCorners(view_gray, board_size, image_points, <span class="hljs-keyword">true</span>); 

            <span class="hljs-comment">//imshow("Camera Calibration", view_gray);//显示图片</span>
            <span class="hljs-comment">//waitKey(100);//暂停0.1S     </span>
        }
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"角点提取完成！！！"</span> &lt;&lt; endl;


    <span class="hljs-comment">/*棋盘三维信息*/</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Point3f&gt;</span>&gt;</span> object_points_seq;                     <span class="hljs-comment">// 保存标定板上角点的三维坐标</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;t &lt; image_count;t++)
    {
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Point3f&gt;</span> object_points;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; board_size.height;i++)
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; board_size.width;j++)
            {
                Point3f realPoint;
                <span class="hljs-comment">/* 假设标定板放在世界坐标系中z=0的平面上 */</span>
                realPoint.x = i*square_size.width;
                realPoint.y = j*square_size.height;
                realPoint.z = <span class="hljs-number">0</span>;
                object_points.push_back(realPoint);
            }
        }
        object_points_seq.push_back(object_points);
    }

    <span class="hljs-comment">/* 运行标定函数 */</span>
    <span class="hljs-keyword">double</span> err_first = calibrateCamera(object_points_seq, image_points_seq, image_size, cameraMatrix, distCoeffs, rvecsMat, tvecsMat, CV_CALIB_FIX_K3);
    fout &lt;&lt; <span class="hljs-string">"重投影误差1："</span> &lt;&lt; err_first &lt;&lt; <span class="hljs-string">"像素"</span> &lt;&lt; endl &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"标定完成！！！"</span> &lt;&lt; endl;


    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"开始评价标定结果………………"</span>;
    <span class="hljs-keyword">double</span> total_err = <span class="hljs-number">0.0</span>;            <span class="hljs-comment">// 所有图像的平均误差的总和 </span>
    <span class="hljs-keyword">double</span> err = <span class="hljs-number">0.0</span>;                  <span class="hljs-comment">// 每幅图像的平均误差</span>
    <span class="hljs-keyword">double</span> totalErr = <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">double</span> totalPoints = <span class="hljs-number">0.0</span>;
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Point2f&gt;</span> image_points_pro;     <span class="hljs-comment">// 保存重新计算得到的投影点</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; image_count;i++)
    {

        projectPoints(object_points_seq[i], rvecsMat[i], tvecsMat[i], cameraMatrix, distCoeffs, image_points_pro);   <span class="hljs-comment">//通过得到的摄像机内外参数，对角点的空间三维坐标进行重新投影计算</span>

        err = norm(Mat(image_points_seq[i]), Mat(image_points_pro), NORM_L2);

        totalErr += err*err;
        totalPoints += object_points_seq[i].size();

        err /= object_points_seq[i].size();
        <span class="hljs-comment">//fout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "幅图像的平均误差：" &lt;&lt; err &lt;&lt; "像素" &lt;&lt; endl;</span>
        total_err += err;
    }
    fout &lt;&lt; <span class="hljs-string">"重投影误差2："</span> &lt;&lt; <span class="hljs-built_in">sqrt</span>(totalErr / totalPoints) &lt;&lt; <span class="hljs-string">"像素"</span> &lt;&lt; endl &lt;&lt; endl;
    fout &lt;&lt; <span class="hljs-string">"重投影误差3："</span> &lt;&lt; total_err / image_count &lt;&lt; <span class="hljs-string">"像素"</span> &lt;&lt; endl &lt;&lt; endl;


    <span class="hljs-comment">//保存定标结果    </span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"开始保存定标结果………………"</span> &lt;&lt; endl;
    Mat rotation_matrix = Mat(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, CV_32FC1, Scalar::all(<span class="hljs-number">0</span>)); <span class="hljs-comment">/* 保存每幅图像的旋转矩阵 */</span>
    fout &lt;&lt; <span class="hljs-string">"相机内参数矩阵："</span> &lt;&lt; endl;
    fout &lt;&lt; cameraMatrix &lt;&lt; endl &lt;&lt; endl;
    fout &lt;&lt; <span class="hljs-string">"畸变系数：\n"</span>;
    fout &lt;&lt; distCoeffs &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; image_count; i++)
    {
        fout &lt;&lt; <span class="hljs-string">"第"</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">"幅图像的旋转向量："</span> &lt;&lt; endl;
        fout &lt;&lt; rvecsMat[i] &lt;&lt; endl;

        <span class="hljs-comment">/* 将旋转向量转换为相对应的旋转矩阵 */</span>
        Rodrigues(rvecsMat[i], rotation_matrix);
        fout &lt;&lt; <span class="hljs-string">"第"</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">"幅图像的旋转矩阵："</span> &lt;&lt; endl;
        fout &lt;&lt; rotation_matrix &lt;&lt; endl;
        fout &lt;&lt; <span class="hljs-string">"第"</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">"幅图像的平移向量："</span> &lt;&lt; endl;
        fout &lt;&lt; tvecsMat[i] &lt;&lt; endl &lt;&lt; endl;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"定标结果完成保存！！！"</span> &lt;&lt; endl;
    fout &lt;&lt; endl;
}

<span class="hljs-keyword">void</span> m_undistort(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> &amp;FilesName, Size image_size, Mat &amp;cameraMatrix, Mat &amp;distCoeffs)
{

    Mat mapx = Mat(image_size, CV_32FC1);   <span class="hljs-comment">//X 坐标重映射参数</span>
    Mat mapy = Mat(image_size, CV_32FC1);   <span class="hljs-comment">//Y 坐标重映射参数</span>
    Mat R = Mat::eye(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, CV_32F);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"保存矫正图像"</span> &lt;&lt; endl;
    <span class="hljs-built_in">string</span> imageFileName;                  <span class="hljs-comment">//校正后图像的保存路径</span>
    <span class="hljs-built_in">stringstream</span> StrStm;
    <span class="hljs-built_in">string</span> temp;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; FilesName.size(); i++)
    {
        Mat imageSource = imread(FilesName[i]);

        Mat newimage = imageSource.clone();

        <span class="hljs-comment">//方法一：使用initUndistortRectifyMap和remap两个函数配合实现</span>
        <span class="hljs-comment">//initUndistortRectifyMap(cameraMatrix,distCoeffs,R, Mat(),image_size,CV_32FC1,mapx,mapy);</span>
        <span class="hljs-comment">//  remap(imageSource,newimage,mapx, mapy, INTER_LINEAR);</span>

        <span class="hljs-comment">//方法二：不需要转换矩阵的方式，使用undistort函数实现</span>
        undistort(imageSource, newimage, cameraMatrix, distCoeffs);

        StrStm &lt;&lt; i + <span class="hljs-number">1</span>;
        StrStm &gt;&gt; temp;
        imageFileName = <span class="hljs-string">"矫正后图像//"</span> + temp + <span class="hljs-string">"_d.jpg"</span>;
        imwrite(imageFileName, newimage);

        StrStm.clear();
        imageFileName.clear();
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"保存结束"</span> &lt;&lt; endl;
}

<span class="hljs-keyword">void</span> main()
{
    <span class="hljs-built_in">string</span> File_Directory1 = <span class="hljs-string">"E:\\标定实验\\相机6\\多帧\\03"</span>;   <span class="hljs-comment">//文件夹目录1</span>

    <span class="hljs-built_in">string</span> FileType = <span class="hljs-string">".jpg"</span>;    <span class="hljs-comment">// 需要查找的文件类型</span>

    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>FilesName1;    <span class="hljs-comment">//存放文件名的容器</span>

    getFilesName(File_Directory1, FileType, FilesName1);   <span class="hljs-comment">// 标定所用图像文件的路径</span>


    Size board_size = Size(<span class="hljs-number">11</span>, <span class="hljs-number">8</span>);                         <span class="hljs-comment">// 标定板上每行、列的角点数 </span>
    Size square_size = Size(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>);                       <span class="hljs-comment">// 实际测量得到的标定板上每个棋盘格的物理尺寸，单位mm</span>

    Mat cameraMatrix = Mat(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, CV_32FC1, Scalar::all(<span class="hljs-number">0</span>));        <span class="hljs-comment">// 摄像机内参数矩阵</span>
    Mat distCoeffs = Mat(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, CV_32FC1, Scalar::all(<span class="hljs-number">0</span>));          <span class="hljs-comment">// 摄像机的5个畸变系数：k1,k2,p1,p2,k3</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Mat&gt;</span> rvecsMat;                                          <span class="hljs-comment">// 存放所有图像的旋转向量，每一副图像的旋转向量为一个mat</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Mat&gt;</span> tvecsMat;                                          <span class="hljs-comment">// 存放所有图像的平移向量，每一副图像的平移向量为一个mat</span>

    m_calibration(FilesName1, board_size, square_size, cameraMatrix, distCoeffs, rvecsMat, tvecsMat);

    <span class="hljs-comment">//m_undistort(FilesName1, image_size, cameraMatrix, distCoeffs);</span>

    <span class="hljs-keyword">return</span>;
}</code></pre> 
<p>工程和数据我打包好了，我使用的是VS2015，64位的opencv3.2，下载地址： <br> <a href="http://download.csdn.net/detail/u011574296/9918396" target="_blank" rel="noopener noreferrer">OpenCV张正友相机标定程序，附实验数据</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f85d93fbfbc3189a8e1ae929a48a0ee9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">文本情感分类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7aaec3e5a390aa39e790fd20f1a66f93/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Codeforces#420 C. Okabe and Boxes</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>