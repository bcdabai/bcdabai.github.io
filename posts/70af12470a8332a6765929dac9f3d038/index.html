<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaScript递归理解（一） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JavaScript递归理解（一）" />
<meta property="og:description" content="先举个栗子：求n个数字的和 n=5 -------&gt;5&#43;4&#43;3&#43;2&#43;1
function getSum(x) { if (x==1){ return 1 } return x&#43;getSum(x-1); }; var sum=getSum(5); console.log(sum); console.log(getSum(10)); 执行过程：
代码执行getSum(5)—&gt;进入函数,此时的x是5,执行的是5&#43;getSum(4),此时代码等待（即 5&#43;getSum(4) 代码先不进行计算）；
先执行getSum(4),进入函数,执行的是4&#43;getSum(3),等待；
先执行getSum(3),进入函数,执行3&#43;getSum(2),等待；
先执行getSum(2),进入函数,执行 2&#43;getSum(1);等待,
先执行getSum(1),执行x==1的判断,return 1,此时getSum(1)的结果是1,函数开始 往回执行 。
继续执行:
getSum(2)----&gt;2&#43;getSum(1)此时的结果是2&#43;1
getSum(3)----&gt;3&#43;getSum(2) 此时的结果是3&#43;2&#43;1
getSum(4)----&gt;4&#43;getSum(3) 此时的结果是4&#43;3&#43;2&#43;1
getSum(5)----&gt;5&#43;getSum(4) 此时的结果是5&#43;4&#43;3&#43;2&#43;1
在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。顾名思义，其包含了两个意思：递 和 归。
递归就是有去（递去）有回（归来），如图所示。“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。就像上面例子中的钥匙可以打开后面所有门上的锁一样，“有回”是指 : 这些问题的演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，原路返回 到原点，原问题解决。
递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。特别地，在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况，这也正是递归的定义所在。格外重要的是，这个解决问题的函数必须 有明确的结束条件，否则就会导致无限递归的情况。
递归的数学模型其实就是 数学归纳法。数学归纳法适用于将解决原问题转化为解决它的子问题，而它的子问题又变成子问题的子问题，而且我们发现这些问题其实都是一个模型，也就是说存在 相同的逻辑 归纳处理项。当然有一个是例外的，也就是 归纳结束的那一个处理方法不适用于我们的归纳处理项 ，当然也不能适用，否则我们就无穷归纳了。总的来说，归纳法主要包含以下三个关键要素：
步进表达式：问题蜕变成子问题的表达式
结束条件：什么时候可以不再使用步进表达式（例外的处理）
直接求解表达式：在结束条件下能够直接计算返回值的表达式
事实上，这也正是某些数学中的数列问题在利用编程的方式去解决时可以使用递归的原因，比如著名的斐波那契数列问题。
递归的三要素： 1. 明确递归终止条件：递归就是有去有回，既然这样，那么必然应该有一个明确的临界点，程序一旦到达了这个临界点，就不用继续 往下递去 而是开始实实在在的 归来。换句话说，该临界点就是一种简单情境，可以防止无限递归。
2. 给出递归终止时的处理办法：在递归的临界点存在一种简单情境，在这种简单情境下，应该直接给出问题的解决方案。一般地，问题的解决方案是直观的、容易的。
3. 提取重复的逻辑，缩小问题规模：递归问题必须可以分解为若干个规模较小、与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。从程序实现的角度而言，需要抽象出一个干净利落的重复的逻辑，以便使用相同的方式解决子问题。
递归算法的编程模型： 模型一： 在递去的过程中解决问题" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/70af12470a8332a6765929dac9f3d038/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-30T17:18:48+08:00" />
<meta property="article:modified_time" content="2019-10-30T17:18:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaScript递归理解（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>先举个栗子：求n个数字的和 n=5 -------&gt;5+4+3+2+1</p> 
<pre><code class="prism language-csharp">function <span class="token function">getSum</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
          <span class="token keyword">return</span> <span class="token number">1</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> x<span class="token operator">+</span><span class="token function">getSum</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> sum<span class="token operator">=</span><span class="token function">getSum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getSum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>执行过程：</strong><br> 代码执行getSum(5)—&gt;进入函数,此时的x是5,执行的是5+getSum(4),此时代码等待（即 5+getSum(4) 代码先不进行计算）；<br> 先执行getSum(4),进入函数,执行的是4+getSum(3),等待；<br> 先执行getSum(3),进入函数,执行3+getSum(2),等待；<br> 先执行getSum(2),进入函数,执行 2+getSum(1);等待,<br> 先执行getSum(1),执行x==1的判断,return 1,此时getSum(1)的结果是1,函数开始 <strong>往回执行</strong> 。<br> <strong>继续执行:</strong><br> getSum(2)----&gt;2+getSum(1)此时的结果是2+1<br> getSum(3)----&gt;3+getSum(2) 此时的结果是3+2+1<br> getSum(4)----&gt;4+getSum(3) 此时的结果是4+3+2+1<br> getSum(5)----&gt;5+getSum(4) 此时的结果是5+4+3+2+1</p> 
<p>在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。顾名思义，其包含了两个意思：递 和 归。<br> <img src="https://images2.imgbox.com/37/63/h7BRaBZQ_o.jpg" alt="在这里插入图片描述"><br> 递归就是有去（递去）有回（归来），如图所示。“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。就像上面例子中的钥匙可以打开后面所有门上的锁一样，“有回”是指 : 这些问题的演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，<strong>原路返回</strong> 到原点，原问题解决。</p> 
<p>递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。特别地，在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况，这也正是递归的定义所在。格外重要的是，这个解决问题的函数必须 <strong>有明确的结束条件</strong>，否则就会导致无限递归的情况。</p> 
<p>递归的数学模型其实就是 <strong>数学归纳法</strong>。数学归纳法适用于将解决原问题转化为解决它的子问题，而它的子问题又变成子问题的子问题，而且我们发现这些问题其实都是一个模型，也就是说存在 <strong>相同的逻辑</strong> 归纳处理项。当然有一个是例外的，也就是 <strong>归纳结束的那一个处理方法不适用于我们的归纳处理项</strong> ，当然也不能适用，否则我们就无穷归纳了。总的来说，归纳法主要包含以下三个关键要素：</p> 
<p>步进表达式：问题蜕变成子问题的表达式<br> 结束条件：什么时候可以不再使用步进表达式（例外的处理）<br> 直接求解表达式：在结束条件下能够直接计算返回值的表达式</p> 
<p>事实上，这也正是某些数学中的数列问题在利用编程的方式去解决时可以使用递归的原因，比如著名的斐波那契数列问题。</p> 
<h3><a id="_41"></a>递归的三要素：</h3> 
<p><strong>1. 明确递归终止条件</strong>：递归就是有去有回，既然这样，那么必然应该有一个明确的临界点，程序一旦到达了这个临界点，就不用继续 往下递去 而是开始实实在在的 归来。换句话说，该临界点就是一种简单情境，可以防止无限递归。<br> <strong>2. 给出递归终止时的处理办法</strong>：在递归的临界点存在一种简单情境，在这种简单情境下，应该直接给出问题的解决方案。一般地，问题的解决方案是直观的、容易的。<br> <strong>3. 提取重复的逻辑，缩小问题规模</strong>：递归问题必须可以分解为若干个规模较小、与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。从程序实现的角度而言，需要抽象出一个干净利落的重复的逻辑，以便使用相同的方式解决子问题。</p> 
<h3><a id="_47"></a>递归算法的编程模型：</h3> 
<p><strong>模型一： 在递去的过程中解决问题</strong></p> 
<pre><code class="prism language-csharp">function <span class="token function">recursion</span><span class="token punctuation">(</span>大规模<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>end_condition<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>      <span class="token comment">// 明确的递归终止条件</span>
        end<span class="token punctuation">;</span>   <span class="token comment">// 简单情景</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>            <span class="token comment">// 在将问题转换为子问题的每一步，解决该步中剩余部分的问题</span>
        solve<span class="token punctuation">;</span>                <span class="token comment">// 递去</span>
        <span class="token function">recursion</span><span class="token punctuation">(</span>小规模<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 递到最深处后，不断地归来</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>模型二： 在归来的过程中解决问题</strong></p> 
<pre><code class="prism language-csharp">function <span class="token function">recursion</span><span class="token punctuation">(</span>大规模<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>end_condition<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>      <span class="token comment">// 明确的递归终止条件</span>
        end<span class="token punctuation">;</span>   <span class="token comment">// 简单情景</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>            <span class="token comment">// 先将问题全部描述展开，再由尽头“返回”依次解决每步中剩余部分的问题</span>
        <span class="token function">recursion</span><span class="token punctuation">(</span>小规模<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 递去</span>
        solve<span class="token punctuation">;</span>                <span class="token comment">// 归来</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/475703cff01fe3663523214eaf11e517/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">钉钉实时拍照和上传图片</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2cfc2dffe76602d1cd7be90bc128628e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TCP传输中的“三次握手”建立连接和“四次握手”释放连接过程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>