<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DSP学习 -- cJSON使用教程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="DSP学习 -- cJSON使用教程" />
<meta property="og:description" content="如需转载请注明出处 https://juyou.blog.csdn.net/article/details/107870229
JSON 需要简单的了解一下。谁知道啥时候用上呢~
一、JSON简介 参看：JSON简介
参看：cJSON使用详细教程 | 一个轻量级C语言JSON解析器
参看：千万不要点开,Cjson入门快速使用看这篇就够了(CJSON入门操作以及问题讲解，CJSON对象删除出错)
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C&#43;&#43;, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。
JSON建构于两种结构：
“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。
值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。
这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。
JSON具有以下这些形式：
对象是一个无序的“‘名称/值’对”集合。一个对象以 {左括号 开始， }右括号 结束。每个“名称”后跟一个 :冒号 ；“‘名称/值’ 对”之间使用 ,逗号 分隔。
数组是值（value）的有序集合。一个数组以 [左中括号 开始， ]右中括号 结束。值之间使用 ,逗号 分隔。
值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array）。这些结构可以嵌套。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e4adc9ad6efc56f98054df909b3a1ce7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-07T20:45:03+08:00" />
<meta property="article:modified_time" content="2020-08-07T20:45:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DSP学习 -- cJSON使用教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>如需转载请注明出处 https://juyou.blog.csdn.net/article/details/107870229</strong></p> 
<p>JSON 需要简单的了解一下。谁知道啥时候用上呢~</p> 
<h2><a id="JSON_5"></a>一、JSON简介</h2> 
<p><strong>参看：<a href="http://www.json.org/json-zh.html" rel="nofollow">JSON简介</a></strong><br> <strong>参看：<a href="https://blog.csdn.net/Mculover666/article/details/103796256">cJSON使用详细教程 | 一个轻量级C语言JSON解析器<br> </a></strong><br> <strong>参看：<a href="https://blog.csdn.net/jasper_JA/article/details/103661825?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">千万不要点开,Cjson入门快速使用看这篇就够了(CJSON入门操作以及问题讲解，CJSON对象删除出错)<br> </a></strong></p> 
<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。</p> 
<p>JSON建构于两种结构：</p> 
<p>“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。<br> 值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。<br> 这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。</p> 
<p>JSON具有以下这些形式：</p> 
<p>对象是一个无序的“‘名称/值’对”集合。一个对象以 {左括号 开始， }右括号 结束。每个“名称”后跟一个 :冒号 ；“‘名称/值’ 对”之间使用 ,逗号 分隔。<br> <img src="https://images2.imgbox.com/68/ee/lSwvH8nJ_o.png" alt="在这里插入图片描述"><br> 数组是值（value）的有序集合。一个数组以 [左中括号 开始， ]右中括号 结束。值之间使用 ,逗号 分隔。<br> <img src="https://images2.imgbox.com/81/dc/eG80nVrD_o.png" alt="在这里插入图片描述"><br> 值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array）。这些结构可以嵌套。<br> <img src="https://images2.imgbox.com/b3/2e/lu567vJU_o.png" alt="在这里插入图片描述"><br> 字符串（string）是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。一个字符（character）即一个单独的字符串（character string）。</p> 
<p>字符串（string）与C或者Java的字符串非常相似。<br> <img src="https://images2.imgbox.com/23/9c/ta0ywPYg_o.png" alt="在这里插入图片描述"><br> 数值（number）也与C或者Java的数值非常相似。除去未曾使用的八进制与十六进制格式。除去一些编码细节。<br> <img src="https://images2.imgbox.com/32/63/lZrHZfso_o.png" alt="在这里插入图片描述"><br> 空白可以加入到任何符号之间。 以下描述了完整的语言。<br> <img src="https://images2.imgbox.com/77/9d/g5TtsMeQ_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_36"></a>二、数据结构</h2> 
<p>cJSON使用cJSONstruct数据类型表示JSON数据：</p> 
<pre><code>/ * cJSON结构：* /
 typedef  结构 cJSON
{
    struct cJSON *下一步;
    struct cJSON *上一页;
    struct cJSON * child;
    INT类型;
    char * valuestring;
    / *不建议写入valueint，请改用cJSON_SetNumberValue * /
     int valueint;
    double valuedouble;
    字符 * string;
} cJSON;
</code></pre> 
<p>此类型的项目表示JSON值。类型存储type为位标记（这意味着您不能仅通过比较的值来找到类型type）。</p> 
<p>要检查项目的类型，请使用相应的cJSON_Is…功能。它会先执行NULL检查，然后进行类型检查，如果该项属于此类型，则返回布尔值。</p> 
<p><strong>类型可以是以下之一：</strong></p> 
<ul><li> <p>cJSON_Invalid（选中cJSON_IsInvalid）：表示一个不包含任何值的无效项目。如果将项目设置为全零字节，则将自动具有此类型。</p> </li><li> <p>cJSON_False（选中cJSON_IsFalse）：表示false布尔值。您也可以使用来检查布尔值cJSON_IsBool。</p> </li><li> <p>cJSON_True（选中cJSON_IsTrue）：表示true布尔值。您也可以使用来检查布尔值cJSON_IsBool。</p> </li><li> <p>cJSON_NULL（选中cJSON_IsNull）：表示一个null值。</p> </li><li> <p>cJSON_Number（用选中cJSON_IsNumber）：表示一个数字值。该值存储为double in valuedouble和in valueint。如果数字超出整数范围，INT_MAX或INT_MIN用于valueint。</p> </li><li> <p>cJSON_String（用选中cJSON_IsString）：表示一个字符串值。它以零终止字符串的形式存储在中valuestring。</p> </li><li> <p>cJSON_Array（用选中cJSON_IsArray）：表示一个数组值。这是通过指向表示数组中值child的cJSON项目的链接列表来实现的。使用next和将元素链接在一起prev，其中第一个元素具有prev.next == NULL和最后一个元素next == NULL。</p> </li><li> <p>cJSON_Object（用选中cJSON_IsObject）：表示一个对象值。对象的存储方式与数组相同，唯一的区别是对象中的项将其键存储在中string。</p> </li><li> <p>cJSON_Raw（选中cJSON_IsRaw）：表示以JSON字符存储的零终止形式的任何JSON valuestring。例如，可以使用它来避免一遍又一遍地打印相同的静态JSON以节省性能。解析时，cJSON永远不会创建此类型。另请注意，cJSON不会检查其是否为有效JSON。<br> 此外，还有以下两个标志：</p> </li><li> <p>cJSON_IsReference：指定child指向和/或valuestring不属于该项目的项目，它仅是参考。因此，cJSON_Deleteand其他函数只会取消分配该项目，而不会取消分配child/ valuestring。</p> </li><li> <p>cJSON_StringIsConst：这意味着string指向一个常量字符串。这意味着cJSON_Delete和其他函数将不会尝试解除分配string。</p> </li></ul> 
<h2><a id="_74"></a>三、处理数据结构</h2> 
<p>对于每种值类型，都有一个cJSON_Create…函数可用于创建该类型的项目。所有这些都将分配一个cJSON结构，以后可以使用删除该结构cJSON_Delete。请注意，您必须在某些时候将其删除，否则会发生内存泄漏。<br> 重要提示：如果您已经将项目添加到数组或对象中，则不能使用删除它cJSON_Delete。将其添加到数组或对象将转移其所有权，以便在删除该数组或对象时也将其删除。您还可以使用cJSON_SetValuestring来更改cJSON_String的valuestring，而无需valuestring手动释放前一个。</p> 
<h3><a id="_78"></a>基本类型</h3> 
<ul><li>用创建空值cJSON_CreateNull</li><li>布尔与创建cJSON_CreateTrue，cJSON_CreateFalse或cJSON_CreateBool</li><li>用创建数字cJSON_CreateNumber。这将同时设置valuedouble和valueint。如果数字超出整数范围，INT_MAX或者INT_MIN用于valueint</li><li>字符串是使用cJSON_CreateString（复制字符串）或使用cJSON_CreateStringReference（直接指向字符串。）创建的，valuestring因此不会被删除，cJSON_Delete并且您将对其生命负责，这对常量很有用。</li></ul> 
<h3><a id="_83"></a>数组</h3> 
<p>您可以使用创建空数组cJSON_CreateArray。cJSON_CreateArrayReference可以用于创建不“拥有”其内容的数组，因此不会被删除其内容cJSON_Delete。</p> 
<p>要将项目添加到数组，请使用cJSON_AddItemToArray将项目追加到末尾。cJSON_AddItemReferenceToArray可以将使用元素添加为对另一个项目，数组或字符串的引用。这意味着cJSON_Delete不会删除该项目child或valuestring属性，因此，如果已经在其他地方使用过，则不会发生双重释放。要在中间插入项目，请使用cJSON_InsertItemInArray。它将在基于0的给定索引处插入一个项目，并将所有现有项目向右移动。</p> 
<p>如果要从给定索引的数组中取出项目并继续使用，请使用cJSON_DetachItemFromArray，它将返回分离的项目，因此请确保将其分配给指针，否则会发生内存泄漏。</p> 
<p>用删除项目cJSON_DeleteItemFromArray。它的工作方式类似于cJSON_DetachItemFromArray，但通过删除了分离的项目cJSON_Delete。</p> 
<p>您也可以替换数组中的项目。要么cJSON_ReplaceItemInArray使用索引或与cJSON_ReplaceItemViaPointer给定的一个指针的元素。如果失败cJSON_ReplaceItemViaPointer将返回0。这在内部所做的是分离旧项目，将其删除，然后将新项目插入其位置。</p> 
<p>要获取数组的大小，请使用cJSON_GetArraySize。使用cJSON_GetArrayItem给定的索引处得到的元素。</p> 
<p>由于数组存储为链接列表，因此通过索引对其进行迭代效率不高（O(n²)），因此您可以使用cJSON_ArrayForEach宏在O(n)时间复杂度上对数组进行迭代。</p> 
<h3><a id="_97"></a>对象</h3> 
<p>您可以使用创建一个空对象cJSON_CreateObject。cJSON_CreateObjectReference可用于创建不“拥有”其内容的对象，因此不会通过删除其内容cJSON_Delete。</p> 
<p>要将项目添加到对象，请使用cJSON_AddItemToObject。使用cJSON_AddItemToObjectCS将项目添加到一个物体是一个常量或引用（该项目的密钥，名称string中的cJSON结构），以便它不会被释放cJSON_Delete。cJSON_AddItemReferenceToArray可以将使用元素添加为对另一个对象，数组或字符串的引用。这意味着cJSON_Delete不会删除该项目child或valuestring属性，因此，如果已经在其他地方使用过，则不会发生双重释放。</p> 
<p>如果要从对象中取出一个项目，请使用cJSON_DetachItemFromObjectCaseSensitive，它将返回分离的项目，因此请确保将其分配给指针，否则会发生内存泄漏。</p> 
<p>用删除项目cJSON_DeleteItemFromObjectCaseSensitive。它的工作原理是cJSON_DetachItemFromObjectCaseSensitive其次cJSON_Delete。</p> 
<p>您还可以替换对象中的项目。要么用cJSON_ReplaceItemInObjectCaseSensitive使用密钥或与cJSON_ReplaceItemViaPointer给定的一个指针的元素。如果失败cJSON_ReplaceItemViaPointer将返回0。这在内部所做的是分离旧项目，将其删除，然后将新项目插入其位置。</p> 
<p>要获取对象的大小，可以使用cJSON_GetArraySize，因为内部对象存储为数组，所以可以使用。</p> 
<p>如果要访问对象中的项目，请使用cJSON_GetObjectItemCaseSensitive。</p> 
<p>要遍历对象，可以使用与cJSON_ArrayForEach数组相同的方式使用宏。</p> 
<p>cJSON还提供了便捷的帮助器功能，用于快速创建新项目并将其添加到对象中，例如cJSON_AddNullToObject。他们返回一个指向新项目的指针，或者NULL如果它们失败了。</p> 
<h2><a id="JSON_118"></a>四、解析JSON</h2> 
<p>在以零结尾的字符串中提供一些JSON的情况下，您可以使用进行解析cJSON_Parse。</p> 
<pre><code>cJSON * json = cJSON_Parse（string）;
</code></pre> 
<p>给定字符串中的JSON（无论是否以零终止），您可以使用解析cJSON_ParseWithLength。</p> 
<pre><code>cJSON * json = cJSON_ParseWithLength（string，buffer_length）;
</code></pre> 
<p>它将解析JSON并分配cJSON代表它的项目树。返回后，您将完全负责将其与一起使用后进行分配cJSON_Delete。</p> 
<p>cJSON_Parseis malloc和free默认情况下使用的分配器，但是可以使用进行更改（全局）cJSON_InitHooks。</p> 
<p>如果发生错误，则可以使用来访问输入字符串中错误位置的指针cJSON_GetErrorPtr。不过，请注意这可能会产生竞态条件在多线程的情况，在这种情况下，最好是使用cJSON_ParseWithOpts带有return_parse_end。默认情况下，输入字符串中已解析的JSON后面的字符将不被视为错误。</p> 
<p>如果需要更多选项，请使用cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)。 return_parse_end返回指向输入字符串中JSON末尾或错误发生位置的指针（从而以cJSON_GetErrorPtr线程安全的方式进行替换）。require_null_terminated，如果设置为，则1如果输入字符串包含JSON之后的数据，则会导致错误。</p> 
<p>如果需要更多选项来指定缓冲区长度，请使用cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)。</p> 
<h2><a id="JSON_140"></a>五、打印JSON</h2> 
<p>给定一个cJSON项目树，您可以使用将它们打印为字符串cJSON_Print。</p> 
<p>char * string = cJSON_Print（json）;<br> 它将分配一个字符串并在其中打印树的JSON表示形式。一旦返回，您将完全负责与分配器一起使用后对其进行分配。（通常free，取决于设置的内容cJSON_InitHooks）。</p> 
<p>cJSON_Print将使用空格打印以进行格式化。如果要打印而不格式化，请使用cJSON_PrintUnformatted。</p> 
<p>如果您对结果字符串的大小有大致了解，可以使用cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)。fmt是一个布尔值，用于打开和关闭带有空格的格式化。prebuffer指定用于打印的第一个缓冲区大小。cJSON_Print当前使用的第一个缓冲区大小为256个字节。一旦打印空间不足，将分配一个新的缓冲区，并在继续打印之前复制旧的缓冲区。</p> 
<p>使用可以完全避免这些动态缓冲区分配cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)。它需要一个缓冲区来指向要打印的指针及其长度。如果达到该长度，则打印将失败并返回0。如果成功，1则返回。请注意，您应该提供比实际需要更多的5个字节，因为cJSON在估计提供的内存是否足够时不是100％准确的。</p> 
<h2><a id="_152"></a>六、示例</h2> 
<p>在此示例中，我们要构建并解析以下JSON：</p> 
<pre><code>{
     “ name ”：“ Awesome 4K ”，
     “ resolutions ”：[
        {
            “宽度”： 1280，
             “高度”： 720
        }，
        {
            “宽度”： 1920，
             “高度”： 1080
        }，
        {
            “宽度”： 3840，
             “高度”： 2160
        }
    ]
}
</code></pre> 
<p>列印<br> 让我们构建上面的JSON并将其打印为字符串：</p> 
<pre><code>//创建具有支持的分辨率列表的监视器
// //注意：返回分配给堆的字符串，使用后需要释放它。
char * create_monitor（ void）
{
    const  unsigned  int resolution_numbers [ 3 ] [ 2 ] = {
        { 1280，720 }，
        { 1920，1080 }，
        { 3840，2160 }
    };
    char * string = NULL ;
    cJSON *名称= NULL ;
    cJSON * resolutions = NULL ;
    cJSON * resolution = NULL ;
    cJSON * width = NULL ;
    cJSON * height = NULL ;
    size_t  索引 = 0 ;

    cJSON * monitor = cJSON_CreateObject（）;
    如果（监控== NULL）
    {
        转到结尾
    }

    name = cJSON_CreateString（“ Awesome 4K ”）;
    如果（name == NULL）
    {
        转到结尾
    }
    / *创建成功后，立即将其添加到监视器中，
     从而将指针的所有权转移给它* /
     cJSON_AddItemToObject（监视器， “ name ”，名称）；

    分辨率= cJSON_CreateArray（）;
    如果（分辨率== NULL）
    {
        转到结尾
    }
    cJSON_AddItemToObject（监视器，“ resolutions ”，决议）；

    对于（index = 0 ; index &lt;（sizeof（resolution_numbers）/（2 * sizeof（int）））; ++ index）
    {
        分辨率= cJSON_CreateObject（）;
        如果（解析度== NULL）
        {
            转到结尾
        }
        cJSON_AddItemToArray（分辨率，分辨率）；

        width = cJSON_CreateNumber（resolution_numbers [ index ] [ 0 ]）;
        如果（宽度== NULL）
        {
            转到结尾
        }
        cJSON_AddItemToObject（resolution，“ width ”，width）;

        高度= cJSON_CreateNumber（resolution_numbers [ index ] [ 1 ]）;
        如果（高度== NULL）
        {
            转到结尾
        }
        cJSON_AddItemToObject（resolution，“ height ”，height）;
    }

    字符串= cJSON_Print（监视器）;
    如果（string == NULL）
    {
        fprintf（stderr，“无法打印监视器。\ n ”）；
    }

结束：
    cJSON_Delete（监视器）；
    返回字符串；
}
</code></pre> 
<p>另外，我们可以使用cJSON_Add…ToObject辅助函数使我们的生活更轻松一些：</p> 
<pre><code>//注意：返回堆分配的字符串，使用后需要释放它。
char * create_monitor_with_helpers（ void）
{
    const  unsigned  int resolution_numbers [ 3 ] [ 2 ] = {
        { 1280，720 }，
        { 1920，1080 }，
        { 3840，2160 }
    };
    char * string = NULL ;
    cJSON * resolutions = NULL ;
    size_t  索引 = 0 ;

    cJSON * monitor = cJSON_CreateObject（）;

    if（cJSON_AddStringToObject（监视器，“ name ”，“ Awesome 4K ”）== NULL）
    {
        转到结尾
    }

    分辨率= cJSON_AddArrayToObject（监视器，“分辨率”）；
    如果（分辨率== NULL）
    {
        转到结尾
    }

    对于（index = 0 ; index &lt;（sizeof（resolution_numbers）/（2 * sizeof（int）））; ++ index）
    {
        cJSON * resolution = cJSON_CreateObject（）;

        if（cJSON_AddNumberToObject（resolution，“ width ”，resolution_numbers [ index ] [ 0 ]）== NULL）
        {
            转到结尾
        }

        if（cJSON_AddNumberToObject（resolution，“ height ”，resolution_numbers [ index ] [ 1 ]）== NULL）
        {
            转到结尾
        }

        cJSON_AddItemToArray（分辨率，分辨率）；
    }

    字符串= cJSON_Print（监视器）;
    如果（string == NULL）
    {
        fprintf（stderr，“无法打印监视器。\ n ”）；
    }

结束：
    cJSON_Delete（监视器）；
    返回字符串；
}
</code></pre> 
<p><strong>解析中</strong><br> 在此示例中，我们将解析上述格式的JSON，并在打印某些诊断输出时检查监视器是否支持Full HD分辨率：</p> 
<pre><code>/ *如果监视器支持全高清，则返回1，否则返回0 * /
 int  support_full_hd（ const  char * const monitor）
{
    const cJSON * resolution = NULL ;
    const cJSON * resolutions = NULL ;
    const cJSON * name = NULL ;
    int状态= 0 ;
    cJSON * monitor_json = cJSON_Parse（监视器）;
    如果（monitor_json == NULL）
    {
        const  char * error_ptr = cJSON_GetErrorPtr（）;
        如果（error_ptr！= NULL）
        {
            fprintf（stderr，“之前的错误：％s \ n ”，error_ptr）;
        }
        状态= 0 ;
        转到结尾
    }

    名称= cJSON_GetObjectItemCaseSensitive（monitor_json，“名称”）;
    如果（cJSON_IsString（name）&amp;&amp;（name-&gt; valuestring！= NULL））
    {
        printf（“正在检查监视器\” ％s \“ \ n ”，name-&gt; valuestring）;
    }

    分辨率= cJSON_GetObjectItemCaseSensitive（monitor_json，“分辨率”）;
    cJSON_ArrayForEach（分辨率，分辨率）
    {
        cJSON * width = cJSON_GetObjectItemCaseSensitive（分辨率，“ width ”）；
        cJSON * height = cJSON_GetObjectItemCaseSensitive（分辨率，“ height ”）；

        if（！cJSON_IsNumber（宽度）||！cJSON_IsNumber（高度））
        {
            状态= 0 ;
            转到结尾
        }

        如果（（width- &gt; valuedouble == 1920）&amp;&amp;（height- &gt; valuedouble == 1080））
        {
            状态= 1 ;
            转到结尾
        }
    }

结束：
    cJSON_Delete（monitor_json）;
    返回状态；
}
</code></pre> 
<p>请注意，除了Result以外没有NULL检查，cJSON_Parse因为因为已经cJSON_GetObjectItemCaseSensitive检查了NULL输入，因此NULL仅传播一个值cJSON_IsNumber，如果输入为，则cJSON_IsString返回0 NULL</p> 
<h2><a id="_364"></a>七、注意事项</h2> 
<h3><a id="_365"></a>零字符</h3> 
<p>cJSON不支持包含零字符’\0’或的字符串\u0000。对于当前的API，这是不可能的，因为字符串以零结尾。</p> 
<h3><a id="_368"></a>字符编码</h3> 
<p>cJSON仅支持UTF-8编码的输入。但是在大多数情况下，它不会拒绝无效的UTF-8作为输入，而只是将其原样传播。只要输入不包含无效的UTF-8，输出将始终是有效的UTF-8。</p> 
<h3><a id="C_371"></a>C标准</h3> 
<p>cJSON用ANSI C（或C89，C90）编写。如果您的编译器或C库未遵循此标准，则不能保证正确的行为。</p> 
<p>注意：ANSI C不是C ++，因此不应使用C ++编译器进行编译。您可以使用C编译器进行编译，然后将其与C ++代码链接。尽管可以使用C ++编译器进行编译，但不能保证正确的行为。</p> 
<h3><a id="_376"></a>浮点数字</h3> 
<p>double除IEEE754双精度浮点数外，cJSON不正式支持任何实现。它可能仍然可以与其他实现一起使用，但是这些实现的错误将被视为无效。</p> 
<p>目前，cJSON支持的浮点文字的最大长度为63个字符。</p> 
<h3><a id="_381"></a>数组和对象的深层嵌套</h3> 
<p>cJSON不支持嵌套太深的数组和对象，因为这会导致堆栈溢出。为了防止这种CJSON_NESTING_LIMIT情况，默认情况下，cJSON将深度限制为1000，但可以在编译时进行更改。</p> 
<h3><a id="_384"></a>线程安全</h3> 
<p>通常，cJSON 不是线程安全的。</p> 
<p>但是，在以下情况下它是线程安全的：</p> 
<ul><li>cJSON_GetErrorPtr永远不会使用（可以改用return_parse_end参数cJSON_ParseWithOpts）</li><li>cJSON_InitHooks 仅在任何线程中使用cJSON之前才被调用。</li><li>setlocale 在返回对cJSON函数的所有调用之前，永远不会调用它。</li></ul> 
<h3><a id="_392"></a>区分大小写</h3> 
<p>最初创建cJSON时，它不遵循JSON标准，并且没有区分大写和小写字母。如果您想要正确的，符合标准的行为，则需要使用CaseSensitive可用的功能。</p> 
<h3><a id="_395"></a>复制对象成员</h3> 
<p>cJSON支持解析和打印JSON，该JSON包含具有多个具有相同名称的成员的对象。cJSON_GetObjectItemCaseSensitive但是始终只会返回第一个。</p> 
<h2><a id="_398"></a>二、下载使用</h2> 
<p><strong>下载地址： https://github.com/DaveGamble/cJSON</strong></p> 
<p>因为整个库只有一个C文件和一个头文件，所以您只需复制cJSON.h并复制cJSON.c到项目源并开始使用它。</p> 
<p><strong>示例下载：https://github.com/whik/cJSON_Demo</strong></p> 
<pre><code>/*
  Copyright (c) 2009 Dave Gamble
 
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
 
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
 
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "cJSON.h"

/* Parse text to JSON, then render back to text, and print! */
void doit(char *text)
{
	char *out;cJSON *json;
	
	json=cJSON_Parse(text);
	if (!json) {printf("Error before: [%s]\n",cJSON_GetErrorPtr());}
	else
	{
		out=cJSON_Print(json);
		cJSON_Delete(json);
		printf("%s\n",out);
		free(out);
	}
}

/* Read a file, parse, render back, etc. */
void dofile(char *filename)
{
	FILE *f;long len;char *data;
	
	f=fopen(filename,"rb");fseek(f,0,SEEK_END);len=ftell(f);fseek(f,0,SEEK_SET);
	data=(char*)malloc(len+1);fread(data,1,len,f);fclose(f);
	doit(data);
	free(data);
}

/* Used by some code below as an example datatype. */
struct record {const char *precision;double lat,lon;const char *address,*city,*state,*zip,*country; };

/* Create a bunch of objects as demonstration. */
void create_objects()
{
	cJSON *root,*fmt,*img,*thm,*fld;char *out;int i;	/* declare a few. */
	/* Our "days of the week" array: */
	const char *strings[7]={"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
	/* Our matrix: */
	int numbers[3][3]={<!-- -->{0,-1,0},{1,0,0},{0,0,1}};
	/* Our "gallery" item: */
	int ids[4]={116,943,234,38793};
	/* Our array of "records": */
	struct record fields[2]={
		{"zip",37.7668,-1.223959e+2,"","SAN FRANCISCO","CA","94107","US"},
		{"zip",37.371991,-1.22026e+2,"","SUNNYVALE","CA","94085","US"}};

	/* Here we construct some JSON standards, from the JSON site. */
	
	/* Our "Video" datatype: */
	root=cJSON_CreateObject();	
	cJSON_AddItemToObject(root, "name", cJSON_CreateString("Jack (\"Bee\") Nimble"));
	cJSON_AddItemToObject(root, "format", fmt=cJSON_CreateObject());
	cJSON_AddStringToObject(fmt,"type",		"rect");
	cJSON_AddNumberToObject(fmt,"width",		1920);
	cJSON_AddNumberToObject(fmt,"height",		1080);
	cJSON_AddFalseToObject (fmt,"interlace");
	cJSON_AddNumberToObject(fmt,"frame rate",	24);
	
	out=cJSON_Print(root);	cJSON_Delete(root);	printf("%s\n",out);	free(out);	/* Print to text, Delete the cJSON, print it, release the string. */

	/* Our "days of the week" array: */
	root=cJSON_CreateStringArray(strings,7);

	out=cJSON_Print(root);	cJSON_Delete(root);	printf("%s\n",out);	free(out);

	/* Our matrix: */
	root=cJSON_CreateArray();
	for (i=0;i&lt;3;i++) cJSON_AddItemToArray(root,cJSON_CreateIntArray(numbers[i],3));

/*	cJSON_ReplaceItemInArray(root,1,cJSON_CreateString("Replacement")); */
	
	out=cJSON_Print(root);	cJSON_Delete(root);	printf("%s\n",out);	free(out);


	/* Our "gallery" item: */
	root=cJSON_CreateObject();
	cJSON_AddItemToObject(root, "Image", img=cJSON_CreateObject());
	cJSON_AddNumberToObject(img,"Width",800);
	cJSON_AddNumberToObject(img,"Height",600);
	cJSON_AddStringToObject(img,"Title","View from 15th Floor");
	cJSON_AddItemToObject(img, "Thumbnail", thm=cJSON_CreateObject());
	cJSON_AddStringToObject(thm, "Url", "http:/*www.example.com/image/481989943");
	cJSON_AddNumberToObject(thm,"Height",125);
	cJSON_AddStringToObject(thm,"Width","100");
	cJSON_AddItemToObject(img,"IDs", cJSON_CreateIntArray(ids,4));

	out=cJSON_Print(root);	cJSON_Delete(root);	printf("%s\n",out);	free(out);

	/* Our array of "records": */

	root=cJSON_CreateArray();
	for (i=0;i&lt;2;i++)
	{
		cJSON_AddItemToArray(root,fld=cJSON_CreateObject());
		cJSON_AddStringToObject(fld, "precision", fields[i].precision);
		cJSON_AddNumberToObject(fld, "Latitude", fields[i].lat);
		cJSON_AddNumberToObject(fld, "Longitude", fields[i].lon);
		cJSON_AddStringToObject(fld, "Address", fields[i].address);
		cJSON_AddStringToObject(fld, "City", fields[i].city);
		cJSON_AddStringToObject(fld, "State", fields[i].state);
		cJSON_AddStringToObject(fld, "Zip", fields[i].zip);
		cJSON_AddStringToObject(fld, "Country", fields[i].country);
	}
	
/*	cJSON_ReplaceItemInObject(cJSON_GetArrayItem(root,1),"City",cJSON_CreateIntArray(ids,4)); */
	
	out=cJSON_Print(root);	cJSON_Delete(root);	printf("%s\n",out);	free(out);

}

int main (int argc, const char * argv[]) {
	/* a bunch of json: */
	char text1[]="{\n\"name\": \"Jack (\\\"Bee\\\") Nimble\", \n\"format\": {\"type\":       \"rect\", \n\"width\":      1920, \n\"height\":     1080, \n\"interlace\":  false,\"frame rate\": 24\n}\n}";	
	char text2[]="[\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]";
	char text3[]="[\n    [0, -1, 0],\n    [1, 0, 0],\n    [0, 0, 1]\n	]\n";
	char text4[]="{\n		\"Image\": {\n			\"Width\":  800,\n			\"Height\": 600,\n			\"Title\":  \"View from 15th Floor\",\n			\"Thumbnail\": {\n				\"Url\":    \"http:/*www.example.com/image/481989943\",\n				\"Height\": 125,\n				\"Width\":  \"100\"\n			},\n			\"IDs\": [116, 943, 234, 38793]\n		}\n	}";
	char text5[]="[\n	 {\n	 \"precision\": \"zip\",\n	 \"Latitude\":  37.7668,\n	 \"Longitude\": -122.3959,\n	 \"Address\":   \"\",\n	 \"City\":      \"SAN FRANCISCO\",\n	 \"State\":     \"CA\",\n	 \"Zip\":       \"94107\",\n	 \"Country\":   \"US\"\n	 },\n	 {\n	 \"precision\": \"zip\",\n	 \"Latitude\":  37.371991,\n	 \"Longitude\": -122.026020,\n	 \"Address\":   \"\",\n	 \"City\":      \"SUNNYVALE\",\n	 \"State\":     \"CA\",\n	 \"Zip\":       \"94085\",\n	 \"Country\":   \"US\"\n	 }\n	 ]";

	/* Process each json textblock by parsing, then rebuilding: */
	doit(text1);
	doit(text2);	
	doit(text3);
	doit(text4);
	doit(text5);

	/* Parse standard testfiles: */
/*	dofile("../../tests/test1"); */
/*	dofile("../../tests/test2"); */
/*	dofile("../../tests/test3"); */
/*	dofile("../../tests/test4"); */
/*	dofile("../../tests/test5"); */

	/* Now some samplecode for building objects concisely: */
	create_objects();
	
	return 0;
}
</code></pre> 
<p><strong>如需转载请注明出处 https://juyou.blog.csdn.net/article/details/107870229</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3fc9ec4c38bf5a2913bcb1287d836767/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网络各层网络设备（中继器、集线器、网桥、交换机、路由器、网关）总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3d042f020cdf08449d26ace119174b08/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">bfs,dfs入门题单</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>