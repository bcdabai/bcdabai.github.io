<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第2章：Android的编译环境--build系统 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第2章：Android的编译环境--build系统" />
<meta property="og:description" content="2.0 build简介 Android的build系统基于GNU Make 和shell 构建的一套编译环境。这套系统定义了大量的变量和函数，无论编写一个产品的配置文件还是一个模块的Android.mk文件，都不用直接和GNU Make打交道，只需要理解Android提供的编译变量和函数，就能够方便的将我们开发的模块加入到Android的build体系中。Android系统build分类： 1、build/core 目录下的文件，这是Android Build的系统框架核心； 2、device目录下的文件，存放的是具体的产品配置文件； 3、各个模块的编译文件：Android.mk，位于模块的原文件目录下。 2.1 Android Build系统核心 Android Build系统核心在目录buil/core，这个目录中有mk文件、shell脚本和per脚本，他们构成Android Build系统的基础和架构。 编译Android系统常用命令： $source build/envsetup.sh $lunch $make 2.1.1 编译环境的建立 1. envsetup.sh 文件的作用 执行Android系统的编译，必须先执行envsetup.sh脚本，这个脚本会建立Android的编译环境。其具体执行的是建立shell命令以及调用add_lunch_combo命令，这个命令的将调用该命令的所传递的参数存放到一个全局的数组变量LUNCH_MENU_CHOICES中。执行lunch时打印的正是这个数组的内容。 envsetup.sh脚本中定义的常用shell命令：
命令说明lunch指定当前编译的产品croot快速切换到源码的根目录，方便开始编译m编译整个源码，但不用讲当前的目录切换到源码的根目录mm编译当前目录下的所有模块，但是不编译他们的依赖项cgrep对系统中所有的C/C&#43;&#43;文件执行grep命令sgrep对系统中所有的源文件执行grep命令 2 lunch命令的功能 lunch命令如果没有参数，系统会打印出产品的列表供选择lunch的参数格式如下： “product_name”必须是系统中已经定义的产品名称“build_variant”必须是“eng”、“user”和“userdebug”三者之一 “&lt;product_name&gt;-&lt;build_variant&gt;” lunch命令主要作用是根据用户输入或选择的产品来设置与具体产品相关的环境变量 这些相关的环境变量有： TARGET_PRODUCT：对应“product_name”TARGET_BUILD_VARIANT：对应“build_variant”TARGET_BUILD_TYPE：一般是“release” 2.1.2 build相关的环境变量 执行完lunch之后，系统会打印出当前配置所生成的环境变量，这些环境变量将影响编译过程
环境变量的意义：
PLATFORM_VERSION_CODENAME：平台版本名称，通常是AOSPPLATFORM_VERSION：Android平台的版本号TARGET_PRODUCT：所编译产品的名称TARGET_BUILD_VARIANT：表示编译产品的类型，可能的值有eng、user和userdebugTARGET_BULD_TYPE：表示编译的类型，可选的值是release和debugTARGET_BUILD_APPS：编译Android系统时，这个变量为NULL。使用build系统编译单个模块时为所编译模块的路径TARGET_ARCH：编译目标的CPU架构TARGET_ARCH_VARIANT： 编译目标的CPU架构版本TARGET_CPU_VARIANT：编译目标的CPU代号TARGET_2ND_ARCH：编译目标的第二CPU架构HOST_ARCH：编译平台架构HOST_OS：编译平台使用的操作系统HOST_OS_EXTRA：编译平台操作系统的一些额外信息，可包括内核版本号、产品名称、公司特有的标志等BUILD_ID：BUILD_ID的值会出现在编译的版本信息中，可以利用这个环境变量来定义公司的特有标志OUT_DIR：指定编译结果的输出目录对环境变量的修改可以放到产品的定义文件中，后面讲解
若只是临时改变这些变量的值，可以通过make命令中加入参数的方式完成，如下例子 make BUILD_ID=&#34;Android L&#34; 2.1.3 Build系统的层次关系 设置好环境变量后，make命令就会开始执行编译过程了
编译产品的目的是生成用于“刷机”的各种image文件 这些image文件时由一个个小小的文件组成的 有些是从源码中编译产生的，有些是简单的复制就可以了，此外编译过程中也会产生一些配置文件build系统的主要工作：
生成image文件收集并编译模块、复制二进制文件、产生配置文件管理并执行这些产品配置文件执行make命令会调用build目录下的Makefile文件，其内容如下：
main.mk文件是Android Build系统的主控文件，从main.mk开始，将通过include命令将其余所有需要的.mk文件包含进来，最终在内存中形成一个包括所有编译脚本的集合 include build/core/main.mk Android Build系统的编译文件的包含关系：
Android Build系统会在以下三个文件中引入具体产品的配置文件和各个模块编译文件 AndroidProduct.mk、BoardConfig.mk和Android.mkconfig.mk文件中，会有4出引入combo目录下的select.mk文件，目前通常第二个编译平台未定义，一般只包含3次select.mkclang 目录下的config.mk和seleck.mk文件一样按照同样的规则包含进3个不同的mk文件combo目录下额这些mk文件定义了GCC编译器的版本和参数clang目录下的mk文件则定义了LLVM编译器clang的路径和参数 图 4. 主要的 Make 文件及其包含关系Build系统的主要编译脚本简介" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/304440d090b5b26d37048875277ba3a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-05-14T16:35:41+08:00" />
<meta property="article:modified_time" content="2016-05-14T16:35:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第2章：Android的编译环境--build系统</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="20-build简介">2.0 build简介</h3> 
<ul><li>Android的build系统基于GNU Make 和shell 构建的一套编译环境。这套系统定义了大量的变量和函数，无论编写一个产品的配置文件还是一个模块的Android.mk文件，都不用直接和GNU Make打交道，只需要理解Android提供的编译变量和函数，就能够方便的将我们开发的模块加入到Android的build体系中。</li><li>Android系统build分类： <br> 1、build/core 目录下的文件，这是Android Build的系统框架核心； <br> 2、device目录下的文件，存放的是具体的产品配置文件； <br> 3、各个模块的编译文件：Android.mk，位于模块的原文件目录下。</li></ul> 
<h3 id="21-android-build系统核心">2.1 Android Build系统核心</h3> 
<ul><li>Android Build系统核心在目录buil/core，这个目录中有mk文件、shell脚本和per脚本，他们构成Android Build系统的基础和架构。 <br> 
  <ul><li>编译Android系统常用命令：</li></ul></li></ul> 
<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-variable">$source</span> build/envsetup.sh
<span class="hljs-variable">$lunch</span>
<span class="hljs-variable">$make</span></code></pre> 
<h4 id="211-编译环境的建立">2.1.1 编译环境的建立</h4> 
<h5 id="1-envsetupsh-文件的作用">1. envsetup.sh 文件的作用</h5> 
<p>执行Android系统的编译，必须先执行envsetup.sh脚本，这个脚本会建立Android的编译环境。其具体执行的是建立shell命令以及调用add_lunch_combo命令，这个命令的将调用该命令的所传递的参数存放到一个全局的数组变量LUNCH_MENU_CHOICES中。执行lunch时打印的正是这个数组的内容。 <br> envsetup.sh脚本中定义的常用shell命令：</p> 
<table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>lunch</td><td>指定当前编译的产品</td></tr><tr><td>croot</td><td>快速切换到源码的根目录，方便开始编译</td></tr><tr><td>m</td><td>编译整个源码，但不用讲当前的目录切换到源码的根目录</td></tr><tr><td>mm</td><td>编译当前目录下的所有模块，但是不编译他们的依赖项</td></tr><tr><td>cgrep</td><td>对系统中所有的C/C++文件执行grep命令</td></tr><tr><td>sgrep</td><td>对系统中所有的源文件执行grep命令</td></tr></tbody></table> 
<h5 id="2-lunch命令的功能">2 lunch命令的功能</h5> 
<ul><li>lunch命令如果没有参数，系统会打印出产品的列表供选择</li><li>lunch的参数格式如下： <br> 
  <ul><li>“product_name”必须是系统中已经定义的产品名称</li><li>“build_variant”必须是“eng”、“user”和“userdebug”三者之一</li></ul></li></ul> 
<pre class="prettyprint"><code class=" hljs xml">“<span class="hljs-tag">&lt;<span class="hljs-title">product_name</span>&gt;</span>-<span class="hljs-tag">&lt;<span class="hljs-title">build_variant</span>&gt;</span>”</code></pre> 
<ul><li>lunch命令主要作用是根据用户输入或选择的产品来设置与具体产品相关的环境变量 <br> 
  <ul><li>这些相关的环境变量有： <br> 
    <ul><li>TARGET_PRODUCT：对应“product_name”</li><li>TARGET_BUILD_VARIANT：对应“build_variant”</li><li>TARGET_BUILD_TYPE：一般是“release”</li></ul></li></ul></li></ul> 
<h4 id="212-build相关的环境变量">2.1.2 build相关的环境变量</h4> 
<blockquote> 
 <p>执行完lunch之后，系统会打印出当前配置所生成的环境变量，这些环境变量将影响编译过程</p> 
</blockquote> 
<ul><li><p>环境变量的意义：</p> 
  <ul><li>PLATFORM_VERSION_CODENAME：平台版本名称，通常是AOSP</li><li>PLATFORM_VERSION：Android平台的版本号</li><li>TARGET_PRODUCT：所编译产品的名称</li><li>TARGET_BUILD_VARIANT：表示编译产品的类型，可能的值有eng、user和userdebug</li><li>TARGET_BULD_TYPE：表示编译的类型，可选的值是release和debug</li><li>TARGET_BUILD_APPS：编译Android系统时，这个变量为NULL。使用build系统编译单个模块时为所编译模块的路径</li><li>TARGET_ARCH：编译目标的CPU架构</li><li>TARGET_ARCH_VARIANT： 编译目标的CPU架构版本</li><li>TARGET_CPU_VARIANT：编译目标的CPU代号</li><li>TARGET_2ND_ARCH：编译目标的第二CPU架构</li><li>HOST_ARCH：编译平台架构</li><li>HOST_OS：编译平台使用的操作系统</li><li>HOST_OS_EXTRA：编译平台操作系统的一些额外信息，可包括内核版本号、产品名称、公司特有的标志等</li><li>BUILD_ID：BUILD_ID的值会出现在编译的版本信息中，可以利用这个环境变量来定义公司的特有标志</li><li>OUT_DIR：指定编译结果的输出目录</li></ul></li><li><p>对环境变量的修改可以放到产品的定义文件中，后面讲解</p> 
  <ul><li>若只是临时改变这些变量的值，可以通过make命令中加入参数的方式完成，如下例子</li></ul></li></ul> 
<pre class="prettyprint"><code class=" hljs go"><span class="hljs-built_in">make</span> BUILD_ID=<span class="hljs-string">"Android L"</span></code></pre> 
<h4 id="213-build系统的层次关系">2.1.3 Build系统的层次关系</h4> 
<blockquote> 
 <p>设置好环境变量后，make命令就会开始执行编译过程了</p> 
</blockquote> 
<ul><li>编译产品的目的是生成用于“刷机”的各种image文件 <br> 
  <ul><li>这些image文件时由一个个小小的文件组成的 <br> 
    <ul><li>有些是从源码中编译产生的，有些是简单的复制就可以了，此外编译过程中也会产生一些配置文件</li></ul></li></ul></li><li><p>build系统的主要工作：</p> 
  <ul><li>生成image文件</li><li>收集并编译模块、复制二进制文件、产生配置文件</li><li>管理并执行这些产品配置文件</li></ul></li><li><p>执行make命令会调用build目录下的Makefile文件，其内容如下：</p> 
  <ul><li>main.mk文件是Android Build系统的主控文件，从main.mk开始，将通过include命令将其余所有需要的.mk文件包含进来，最终在内存中形成一个包括所有编译脚本的集合</li></ul></li></ul> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-keyword">include</span> build/core/main.mk</code></pre> 
<ul><li><p>Android Build系统的编译文件的包含关系：</p> 
  <ul><li>Android Build系统会在以下三个文件中引入具体产品的配置文件和各个模块编译文件 <br> 
    <ul><li>AndroidProduct.mk、BoardConfig.mk和Android.mk</li></ul></li><li>config.mk文件中，会有4出引入combo目录下的select.mk文件，目前通常第二个编译平台未定义，一般只包含3次select.mk</li><li>clang 目录下的config.mk和seleck.mk文件一样按照同样的规则包含进3个不同的mk文件</li><li>combo目录下额这些mk文件定义了GCC编译器的版本和参数</li><li>clang目录下的mk文件则定义了LLVM编译器clang的路径和参数 <br> 图 4. 主要的 Make 文件及其包含关系</li></ul></li><li><p>Build系统的主要编译脚本简介</p> 
  <ul><li>产品的配置文件实际上就是对这些编译变量赋值的脚本文件</li></ul></li></ul> 
<table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>main.mk</td><td>Build系统的主控文件，主要作用是包含进其他的.mk文件，以及定义几个最重要的编译目标，如sdk、ndk等，同时检查编译器版本，如make、gcc、javac等</td></tr><tr><td>config.mk</td><td>Build系统的配置文件，主要定义了许多常量来负责不同类型模块的编译，定义编译器参数并引入产品的BoardCongfig.mk文件来配置产品参数，同时定义了一些编译工具的路径，如aapt、mkbootimage等</td></tr><tr><td>pathmap.mk</td><td>给一些头文件所在的目录定义别名，将firmware下的一些源码目录按类别组合在一起并定义了别名，方便引用</td></tr><tr><td>buildspec.mk</td><td>放在build目录下，定义产品的编译参数，一般很少用</td></tr><tr><td>envsetup.mk</td><td>包含进produc_config.mk文件并根据其内容定设置编译产品所需的环境变量，如TARGET_BUILD_VARIANT等，并检查这些环境变量的合法性，同时指定各个编译结果的输出路径</td></tr><tr><td>version_defaults.mk</td><td>定义系统版本的相关变量</td></tr><tr><td>build_id.mk</td><td>定义了 环境变量BUILD_ID</td></tr><tr><td>product_config.mk</td><td>包含进系统所有AndriodProduct.mk文件，并根据当前的产品的配置文件来设置产品编译相关的变量</td></tr><tr><td>product.mk</td><td>定义了product_config文件中使用的各种函数</td></tr><tr><td>combo/select.mk</td><td>根据环境变量的设置，指定对应的系统和架构中所使用的编译工具路径</td></tr><tr><td>clang/config.mk</td><td>定义了LLVM编译器clang在不同架构下的路径和参数</td></tr><tr><td>dumpvar.mk</td><td>打印输出本次编译的配置信息</td></tr><tr><td>cleanbuild.mk</td><td>包含了源码中所有的 CleanSpec.mk，定义了编译目标datclean和installclean</td></tr><tr><td>definitions.mk</td><td>定义了打了Build系统中使用的函数。如果熟悉这些环境，编写产品配置文件将得心应手</td></tr><tr><td>dex_preopt.mk</td><td>定义与dex优化相关的路径和参数</td></tr><tr><td>pdk_config,mk</td><td>编译pdk的配置文件</td></tr><tr><td>post_clean.mk</td><td>比较当前系统的overlay目录与上一次Build时是否有变化，有则重新生成受影响模块的资源定义文件R.java</td></tr><tr><td>legacy_prebuilts.mk</td><td>定义系统prebuild模块列表</td></tr><tr><td>Makefile</td><td>定义系统最终编译完成所需的各种目录和规则</td></tr></tbody></table> 
<h4 id="214-分析mainmk文件">2.1.4 分析main.mk文件</h4> 
<ol><li>检查gun make的版本号是否大于或等于3.81，否则报错并停止编译</li><li>定义缺省的编译目标为“droid”。因此”make” 相当于”make droid“</li><li>引入几个make文件。“-include”和“include”的区别是：前者包含文件如果不存在不会报错，后者将会报错并停止编译</li><li>检查java版本</li><li>将变量VERSIONS_CHECKED和BUILD_EMULATOR写入文件</li><li>再包含进3个mk文件</li><li>如果变量ONE_SHOT_MAKEFILE的值不为空，将它定义的文件包含进来。当编译一个单独的模块时，ONE_SHOT_MAKEFILE的值会设为模块的make文件路径。如果值为空，说明正在编译整个系统，因此，调用findleayes.py脚本搜索系统里所有Android.mk文件并将它们包含进来</li><li>根据编译类型来设置属性ro.secure的值</li><li>包含进post_clean.mk和legacypre_builts.mk脚本。根据legacypre_builts.mk定义的变量GRANDFATHERED_ALL_PREBUILT检查是否有不在这个列表中的prebuilt模块，有则报错</li><li>计算哪些模块应该在本次编译中引入</li><li>包含Makefile文件。至此，所有编译文件都包含进来了</li><li>文件系统的编译目标</li></ol> 
<h4 id="215-build系统的编译目标">2.1.5 Build系统的编译目标</h4> 
<ul><li>Build系统的缺省编译目标是droid，droid目标会依赖其它目标，这些目标组成了最终的产品</li><li>下面是droid目标的定义 <br> 
  <ul><li>droidcore、files和prebuilt是中间目标</li></ul></li></ul> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-symbol">droid:</span> droidcore dist_files
<span class="hljs-symbol">droidcore:</span>      files \
                    systemimage \
                    <span class="hljs-variable">$(</span><span class="hljs-constant">INSTALLED_BOOTIMAGE_TARGET</span>) \
                    <span class="hljs-variable">$(</span><span class="hljs-constant">INSTALLED_RECOVERYIMAGE_TARGET</span>) \
                    <span class="hljs-variable">$(</span><span class="hljs-constant">INSTALLED_USERDATAIMAGE_TARGET</span>) \
                    <span class="hljs-variable">$(</span><span class="hljs-constant">INSTALLED_CACHEIMAGE_TARGET</span>) \
                    <span class="hljs-variable">$(</span><span class="hljs-constant">INSTALLED_VENDORIMAGE_TARGET</span>) \
                    <span class="hljs-variable">$(</span><span class="hljs-constant">INSTALLED_FILES_TARGET</span>) 
<span class="hljs-symbol">files:</span>             prebuilt \
                    <span class="hljs-variable">$(</span>modules_to_install) \
                    <span class="hljs-variable">$(</span><span class="hljs-constant">INSTALLED_ANDROID_INFO_TXT_TARGET</span>)
<span class="hljs-symbol">prebuilt:</span>         <span class="hljs-variable">$(</span><span class="hljs-constant">ALL_PREBUILT</span>)</code></pre> 
<ul><li>Build中和Droid相关的编译目标</li></ul> 
<table><thead><tr><th>目标</th><th>说明</th></tr></thead><tbody><tr><td>dist_file</td><td>复制文件到/out/dist目录</td></tr><tr><td>systemimage</td><td>产生system.img</td></tr><tr><td>$(INSTALLED_XXXIMAGE_TARGET)</td><td>产生XXX.img</td></tr><tr><td>$(INSTALLED_FILES_FILE)</td><td>用来产生名为installed-files.txt文件，该文件放在/out/target/product/下。这些文件的内容是当前产品配置要安装的所有文件列表</td></tr><tr><td>$(modules_to_install)</td><td>modules_to_install变量是当前产品配置下所有将要安装的模块的列表</td></tr><tr><td>$(INSTALLED_ANDROID_INFO_TXT_TARGET)</td><td>用来产生名为android-info.txt文件，该文件将会放在out/target/product/下，文件的内容是当前产品的设备信息</td></tr><tr><td>$(ALL_PREBUILT)</td><td>用来产生所有在变量GARNDFATHERED_ALL_PREBYILT中的文件</td></tr></tbody></table> 
<p>- Build中独立目标</p> 
<table><thead><tr><th>目标</th><th>说明</th></tr></thead><tbody><tr><td>make clean</td><td>清除所有的编译结果</td></tr><tr><td>make snod</td><td>重新生成最终的image，但不重新编译模块</td></tr><tr><td>make sdk</td><td>生成Android SDK</td></tr><tr><td>make libandroid_runtime</td><td>编译出所有framework的JNI库</td></tr><tr><td>make framework</td><td>编译出所有framework的jar包</td></tr><tr><td>make service</td><td>编译出系统服务及相关的模块</td></tr></tbody></table> 
<h4 id="216-分析configmk文件">2.1.6 分析config.mk文件</h4> 
<ol><li>定义表示文档、头文件、系统库的源码目录等的变量，方便其他编译脚本使用</li><li>包含pathmap.mk</li><li>定义模块编译变量名，这里的模块是指编译出的apk文件、静态java库、共享java库等</li><li>定义C/C++代码编译时的参数以及系统常用包的后缀名</li><li>如果源码根目录下有buildspec.mk文件，包含进来</li><li>包含envsetup.mk文件</li><li>包含select.mk文件，共包含4次</li><li>包含javac.mk文件，这个文件定义了java编译工具的路径</li><li>定义Build系统使用的一些工具的路径</li><li>定义host平台和target平台各自编译，链接C/C++使用参数</li><li>包含进clang/config.mk文件</li><li>定义Android SDK的版本</li><li>包含dumpvar.mk文件，打印出本次配置产品的配置信息</li></ol> 
<h4 id="217-分析productconfigmk文件">2.1.7 分析product_config.mk文件</h4> 
<ol><li>解析make命令的参数$(MAKECMDGOALS)，格式是：PRODUCT--，相当于设置了变量TARGET_PRODUCT为，变量TARGET_BUILD_VARIANT为</li><li>如果make命令的参数格式是APP-，则相当于设置变量TARGET_BUILD_APPS为，这将导致系统编译某个APP而不是某个产品</li><li>包含进3个文件：node_fns.mk、product.mk和device.mk</li><li>执行$(get-all-product-makefiles)函数</li><li>对all-product-makefiles和current-product-makefiles两个变量赋值</li><li>如果make跟有参数“product-graph”或者“dump-products”，就会调用<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame"> 
    
    <span class="math" id="MathJax-Span-1" style="width: 12.909em; display: inline-block;"><span style="display: inline-block; position: relative; width: 10.296em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.816em 1000.003em 3.149em -0.371em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="mo" id="MathJax-Span-3" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-5" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-6" style="font-family: MathJax_Math-italic;">l</span><span class="mi" id="MathJax-Span-7" style="font-family: MathJax_Math-italic;">l</span><span class="mi" id="MathJax-Span-8" style="font-family: MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-9" style="font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-10" style="font-family: MathJax_Math-italic;">p</span><span class="mi" id="MathJax-Span-11" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-12" style="font-family: MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math-italic;">t</span><span class="mo" id="MathJax-Span-14" style="font-family: MathJax_Main; padding-left: 0.216em;">−</span><span class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math-italic; padding-left: 0.216em;">p</span><span class="mi" id="MathJax-Span-16" style="font-family: MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-17" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-18" style="font-family: MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-19" style="font-family: MathJax_Math-italic;">u</span><span class="mi" id="MathJax-Span-20" style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-21" style="font-family: MathJax_Math-italic;">t</span><span class="mi" id="MathJax-Span-22" style="font-family: MathJax_Math-italic;">s</span><span class="mo" id="MathJax-Span-23" style="font-family: MathJax_Main;">,</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.397em;"></span></span> 
   </span><script type="math/tex" id="MathJax-Element-1">(call import-products,</script>(all-product-makefiles))，否则只会执行<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-2-Frame"> 
    
    <span class="math" id="MathJax-Span-24" style="width: 12.269em; display: inline-block;"><span style="display: inline-block; position: relative; width: 9.816em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.816em 1000.003em 3.149em -0.371em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-25"><span class="mo" id="MathJax-Span-26" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-27" style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-28" style="font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-29" style="font-family: MathJax_Math-italic;">l</span><span class="mi" id="MathJax-Span-30" style="font-family: MathJax_Math-italic;">l</span><span class="mi" id="MathJax-Span-31" style="font-family: MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-32" style="font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-33" style="font-family: MathJax_Math-italic;">p</span><span class="mi" id="MathJax-Span-34" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-35" style="font-family: MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-36" style="font-family: MathJax_Math-italic;">t</span><span class="mo" id="MathJax-Span-37" style="font-family: MathJax_Main; padding-left: 0.216em;">−</span><span class="mi" id="MathJax-Span-38" style="font-family: MathJax_Math-italic; padding-left: 0.216em;">p</span><span class="mi" id="MathJax-Span-39" style="font-family: MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-40" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-41" style="font-family: MathJax_Math-italic;">d<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-42" style="font-family: MathJax_Math-italic;">u</span><span class="mi" id="MathJax-Span-43" style="font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-44" style="font-family: MathJax_Math-italic;">t</span><span class="mo" id="MathJax-Span-45" style="font-family: MathJax_Main;">,</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.397em;"></span></span> 
   </span><script type="math/tex" id="MathJax-Element-2">(call import-product,</script>(current_product-makefile))</li><li>上一步import的结果是产生形如RODCUT$(TARGET_PRODUCT).xxx的一系列内部变量，然后将它们的值赋予产品的相关变量</li></ol> 
<h3 id="22-android产品的配置文件">2.2 Android产品的配置文件</h3> 
<ul><li><p>产品配置文件的作用：按照Build系统的要求，将生成产品的各种image文件所需要的配置信息（如版本号、各种参数）、资源（图片、字体、铃声等）、二进制文件（apk、jar包、so库等）有机的组织起来，同时进行裁剪，加入或去掉一些模块。</p></li><li><p>配置文件的存放在以下的目录中，这两个目录没有太大的区别，Build系统在搜索产品配置相关的文件时会同时在这两个目录中进行</p> 
  <ul><li>位于源码的的device目录下</li><li>也可以放在vendor目录下 <br> 
    <ul><li>实际使用中，上述两个目录配合使用—-产品的配置文件一般放在device目录下，而vendor目录下则存放一些硬件的HAL库</li></ul></li></ul></li></ul> 
<h4 id="分许hammerhead的配置文件">分许hammerhead的配置文件</h4> 
<ul><li><p>通常device目录下有几个目录：</p> 
  <ul><li>common：存放各个产品的通用配置脚本、文件等</li><li>sample：一个产品的配置的例子，写一个新产品的配置时可以使用sample目录下的文件做为模板</li><li>google：几个简单的模块，用途不详</li><li>lge、intel、samsung：分别代表LG、因特尔、三星等3家公司。各家公司的产品放在对应的目录下 <br> 
    <ul><li>如果需要添加新的产品，可以在device目录下新建新的目录</li></ul></li></ul></li><li><p>hammerhead手机又LG代工的产品，其产品配置文件位于lge目录下，具体内容如下：</p> 
  <ul><li>hammerhead：存放Google nexus5的产品配置文件，也是下面分析的重点</li><li>hammerhead-kernel：存放的时hammerhead kernel的二进制文件</li><li>mako：存放的是Google nexus4的产品配置文件</li><li>mako-kernel：存放的是Google nexus4 kernel的image</li></ul></li></ul> 
<h5 id="几个与产品配置相关的重要文件">几个与产品配置相关的重要文件</h5> 
<blockquote> 
 <p>Build系统会包含产品配置中的几个文件，这些文件和Build系统关系最紧密，也是产品配置的关键文件，整个产品目录的组织就是围绕着这几个文件展开的</p> 
</blockquote> 
<ul><li>vendorsetup.sh <br> 
  <ul><li>该文件会在初始化编译的时候被envsetup.sh文件包含进去</li><li>作用：调用add_lunch_combo命令来添加产品名称串</li><li>eg：hammerhead目录下的vendorsetup.sh文件 <br> 
    <ul><li>产品名称串的格式：-，前半部分是产品名称，后半部分是产品的编译类型</li></ul></li></ul></li></ul> 
<pre class="prettyprint"><code class=" hljs lasso">add_lunch_combo aosp_hammerhead<span class="hljs-attribute">-userdebug</span></code></pre> 
<ul><li>AndroidProduct.mk <br> 
  <ul><li>该文件会在Build系统的ProductConfig.mk文件中被包含进去</li><li>作用：定义了一个变量PRODUCT_MAKEFILES，它定义了本配置目录中所有编译入口文件，但是，每种产品编译时只会使用其中之一</li><li>eg：hammerhead目录下的AndroidProduct.mk文件： <br> 
    <ul><li>vendor文件加入“选择列表”的是aosp_hammerhead，因此，实际能选用的文件只有aosp_hammerhead.mk</li><li>如果希望full_hammerhead.mk也能被选用，可以在vendorsetup.sh文件中再加入一行：add_lunch_combo full_hammerhead-userdebug</li></ul></li></ul></li></ul> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-constant">PRODUCT_MAKEFILES</span> <span class="hljs-symbol">:</span>= \
    <span class="hljs-variable">$(</span><span class="hljs-constant">LOCAL_DIR</span>)/aosp_hammerhead.mk \
    <span class="hljs-variable">$(</span><span class="hljs-constant">LOCAL_DIR</span>)/full_hammerhead.mk \
    <span class="hljs-variable">$(</span><span class="hljs-constant">LOCAL_DIR</span>)/car_hammerhead.mk</code></pre> 
<ul><li>BoardConfig.mk <br> 
  <ul><li>该文件会被Build系统的envsetup.sh文件包含进去</li><li>作用：定义了和设备硬件（包括CPU、WiFi、GPS等）相关的一些参数</li><li>看懂这个文件的关键时理解文件中使用的编译变量： <br> 
    <ul><li>TARGET_CPU_ABI：CPU编程界面，ABI是application binary interface的缩写</li><li>TARGET_CPU_ABI2：CPU的编程界面</li><li>TARGET_CPU_SMP：CPU是否为多核CPU</li><li>TARGET_ARCH：定义CPU的架构</li><li>TARGET_ARCH_VARIANT：定义CPU的架构的版本</li><li>TARGET_CPU_VARIANT：定义CPU的代号</li><li>TARGET_NO_BOOTLOADER：如果该变量为true，表示编译出的image文件中不包含bootloader</li><li>BOARD_KERNEL_BASE：卸载kernel镜像时的基址</li><li>BOARD_KERNEL_PAGE：kernel镜像的分页大小</li><li>BOARD_KERNEL_CMDLINE：卸载kernel时传给kernel的命令行参数</li><li>BOARD_MKBOOTIMG_ARGS：使用mkbootimg工具生成的boot.img时的参数</li><li>BOARD_USES_ALSA_AUDIO：值为true，表示主板的声音系统使用的ALSA架构</li><li>BOARD_HAVE_BLUETOOTH：值为true，表示主板支持蓝牙</li><li>BOARD_HAVE_BOUETOOTH_BMC：值为true，表示主板使用的时broadcom的蓝牙芯片</li><li>WPA_SUPPLICANT_VERSION：定义WIFI WPA的版本</li><li>BOARD_WLAN-DEVICE：定义了WiFi设备的额名称</li><li>BOARD_WPA_SUPPLICANT_DRIVER：指定一种WAP_SUPPLICANT的驱动</li><li>BOARD_HOSTAPD_DIRVER：指定WiFi热点的驱动</li><li>WIFI_DRIVER_FW_PATH_PARAM：指定WiFi驱动的参数路径</li><li>WIFI_DRIVER_FW_PATH_AP：定义WiFi热点firmware文件的路径</li><li>TARGET_NO_RADIOIMAGE：值为true，表示编译的镜像中没有射频部分</li><li>TARGET_BOARD_PALTFORM：表示主板平台的型号</li><li>TARGET_USERIMAGES_USE_EXIT4：值为true，表示目标文件系统采用ext4格式</li></ul></li></ul></li></ul> 
<h5 id="在hammerhead目录下其他几个与build相关的文件">在hammerhead目录下其他几个与Build相关的文件</h5> 
<ul><li>aosp_hammerhead,mk <br> 
  <ul><li>产品配置的编译入口文件，包含了产品的其他配置文件</li></ul></li></ul> 
<pre class="prettyprint"><code class=" hljs avrasm">$(<span class="hljs-keyword">call</span> inherit-product, device/lge/hammerhead/full_hammerhead<span class="hljs-preprocessor">.mk</span>)
PRODUCT_NAME := aosp_hammerhead  <span class="hljs-preprocessor">#修改产品名称为aosp_hammerhead</span>
PRODUCT_PACKAGES += launcher3      <span class="hljs-preprocessor">#增加了一个模块launcher到目标系统中</span></code></pre> 
<ul><li>full_hammerhead.mk <br> 
  <ul><li>产品配置的另一个编译入口文件。包含其他配置文件，也定义了一些和产品相关的编译变量</li></ul></li></ul> 
<pre class="prettyprint"><code class=" hljs r"><span class="hljs-comment"># 复制APN的配置文件到目标系统的/system/etc目录</span>
PRODUCT_COPY_FILES :=device/lge/hammerhead/apns-full-conf.xml:system/etc/apns-conf.xml

$(call inherit-product, $(SRC_TARGET_DIR)/product/aosp_base_telephony.mk)
PRODUCT_NAME := full_hammerhead  <span class="hljs-comment">#修改产品名称为full_hammerhead</span>
PRODUCT_DEVICE := hammerhead     <span class="hljs-comment">#产品设备名称，非常关键</span>
PRODUCT_BRAND := Android             <span class="hljs-comment">#产品品牌，一般为Android</span>
PRODUCT_MODEL := AOSP on Hammerhead   <span class="hljs-comment">#产品型号</span>
PRODUCT_MANUFACTURER := LGE   <span class="hljs-comment">#产品制造商</span>
<span class="hljs-keyword">...</span>
$(call inherit-product, device/lge/hammerhead/device.mk) <span class="hljs-comment">#这里开始包含vendor下的文件，vendor下存放的时从手机中提取的HAL库和驱动</span>
<span class="hljs-keyword">...</span></code></pre> 
<ul><li>device.mk <br> 
  <ul><li>该文件时产品配置中常需要修改的文件。产品定义中需要包含进的模块、文件以及各种环境变量的定义一般都放在这个文件里</li><li>该文件主要的作用： <br> 
    <ul><li>将kernel的镜像复制到目标系统里</li><li>将Linux系统的初识化文件和分区表等复制到目标系统里</li><li>定义系统支持的分辨率</li><li>指定系统overlay的目录</li><li>添加模块进系统</li><li>设置系统属性值</li><li>包含进更多的配置文件</li></ul></li><li>device.mk中一些重要的编译环境变量 <br> 
    <ul><li>PRODUCT_COPY_FILE：一个格式为“原文件路径：目标文件路径”字串的合集，使用该变量能方便的将编译目录下的文件复制到目标文件系统中</li><li>PRODUCT_PACKAGES：用来定义产品的模块列表，所有的模块列表中的模块的定义都会被执行</li><li>PRODUCT_AAPT_CONFIG：指定系统中能够支持的屏幕密度类型（dip）。 <br> 
      <ul><li>所谓支持是指编译时，会将相应的资源添加到framework_res.apk文件中</li></ul></li><li>PRODUCT_AAPT_PREF_CONFIG：指定系统实际的屏幕密度类型</li><li>DEVICE_PACKAGE_OVERLAYS：重要的变量，指定了系统的overlay目录。 <br> 
      <ul><li>编译时会使用overlay目录下存放的资源文件替换系统或模块原有的资源文件</li><li>在不覆盖原生文件的情况下，就能实现产品的个性化</li><li>overlay目录可有多个，按照变量中的先后顺序替换资源，因而可以定义公共的或产品私有的overlay目录，以重用系统资源文件</li></ul></li><li>PRODUCT_PROPERTY_OVERRIDES：定义系统的属性值 <br> 
      <ul><li>如果属性名称以“ro.”开头，该属性为只读属性。一旦设置，属性值将不能改变</li><li>如果属性名为“persist.”开头，它的值将写入文件/data/property</li></ul></li></ul></li></ul></li></ul> 
<h4 id="222-编译类型enguser和userdebug">2.2.2 编译类型eng、user和userdebug</h4> 
<ul><li>eng <br> 
  <ul><li>缺省的编译类型。执行make 相当于“make eng” </li><li>编译时会将一些模块安装进系统 <br> 
    <ul><li>在Android.mk中用LOCAL_MODULE_TAGS变量定义了标签：eng、debug、shell_$(TARGET_SHELL)、user和development的模块</li><li>非apk模块并且不带任何标签的模块</li><li>所有产品配置文件中指定的apk模块</li></ul></li><li>编译的系统带有一些属性： <br> 
    <ul><li>ro.secure=0</li><li>ro.debuggable=1</li><li>ro.kernel.android.checkjni=1</li></ul></li><li>编译系统中缺省情况下adb时可用的</li></ul></li><li>user <br> 
  <ul><li>编译时会将一些模块安装进系统 <br> 
    <ul><li>在Android.mk中用LOCAL_MODULE_TAGS变量定义了标签：shell_$(TARGET_SHELL)和user的模块</li><li>非apk模块并且不带任何标签的模块</li><li>所有产品配置文件中指定的apk模块，同时忽略其标签属性</li></ul></li><li>编译的系统带有一些属性： <br> 
    <ul><li>ro.secure=1</li><li>ro.debuggable=0</li></ul></li><li>编译系统中缺省情况下adb时不可用的，需要在系统设置中手动打开</li></ul></li><li>userdebug <br> 
  <ul><li>编译时会将一些模块安装进系统 <br> 
    <ul><li>在Android.mk中用LOCAL_MODULE_TAGS变量定义了标签：shell_$(TARGET_SHELL)、debug和user的模块</li><li>非apk模块并且不带任何标签的模块</li><li>所有产品配置文件中指定的apk模块，同时忽略其标签属性</li></ul></li><li>编译的系统带有一些属性： <br> 
    <ul><li>ro.secure=1</li><li>ro.debuggable=1</li></ul></li><li>编译系统中缺省情况下adb时不可用的，需要在系统设置中手动打开</li></ul></li></ul> 
<h4 id="223-产品的image文件">2.2.3 产品的image文件</h4> 
<blockquote> 
 <p>Android编译完成之后生成的几个image文件，包含：boot.img、system.img、recovery.img和userdata.img</p> 
</blockquote> 
<h5 id="1-bootimg">1. boot.img</h5> 
<ul><li>boot.img是Android自定义的文件格式，包含一些部分 <br> 
  <ul><li>一个2*1024大小的头文件</li><li>用gzip压缩过的kernel映像</li><li>ramdisk映像</li><li>最后是一个载入器程序，可选</li></ul></li></ul> 
<table><thead><tr><th>组成部分</th><th>大小</th></tr></thead><tbody><tr><td>boot header</td><td>1 page</td></tr><tr><td>kernel</td><td>n page</td></tr><tr><td>ramdisk</td><td>m page</td></tr><tr><td>second stage</td><td>o page</td></tr></tbody></table> 
<blockquote> 
 <p>注意：各个部分大小时page的整数倍，page值在BoardConfig.mk中通过编译变量BOARD_KERNEL_PAGESIZE定义，通常是2048 <br> ramdisk是小型的文件系统，包括初始化Linux系统所需的全部核心文件</p> 
</blockquote> 
<h5 id="2-recoveryimg">2. recovery.img</h5> 
<ul><li>recovery.img相当于一个小型文本界面的Linux系统，他有自己的内核和文件系统 <br> 
  <ul><li>作用：恢复或升级系统，因此在sbin目录下会有一个recovery程序</li><li>组成：adbd和系统配置文件init.rc</li></ul></li></ul> 
<h5 id="3-systemimg">3. system.img</h5> 
<ul><li>system.img就是设备中system目录的镜像，里面包含了Android系统的主要的目录和文件 <br> 
  <ul><li>app目录：存放一般的apk文件</li><li>bin目录：一些Linux的工具，大多是toolbox的链接</li><li>etc目录：系统配置文件</li><li>fonts目录：系统字体文件</li><li>framework目录：系统平台所有jar包和资源文件包</li><li>lib目录：系统共享库</li><li>media目录：多媒体资源，只要是铃声</li><li>priv-app目录：系统核心apk文件</li><li>tts目录：系统语音合成文件</li><li>usr目录：各种键盘布局、时间区域文件</li><li>vendor目录：第三方厂商的配置文件、firmware以及动态库</li><li>xbin目录：系统管理工具，这个文件夹的作用相当于标准Linux系统中的sbin</li><li>buil.prop文件：系统属性定义文件</li></ul></li></ul> 
<h5 id="4-userdataimg">4. userdata.img</h5> 
<p>userdata.img是设备中data目录的镜像，初始时一般不包括任何文件</p> 
<h3 id="23-编译android模块">2.3 编译Android模块</h3> 
<ul><li><p>每个模块的源码目录下，都有一个Android.mk文件，里面包含了模块的代码的位置、模块快的名称、需要链接的动态库等一系列的定义</p></li><li><p>分析package/apps/Settings目录下的Android.mk文件</p></li></ul> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-comment">#设置LOCAL_PATH为当前目录</span>
<span class="hljs-constant">LOCAL_PATH</span><span class="hljs-symbol">:</span>= <span class="hljs-variable">$(</span>call my-dir)
<span class="hljs-comment">#包含进clear_vars.mk文件，该文件里将会清空除LOCAL_PATH外所有“LOCAL_”变量</span>
<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-constant">CLEAR_VARS</span>)
<span class="hljs-comment">#指定依赖的共享库java类库</span>
<span class="hljs-constant">LOCAL_JAVA_LIBRARIES</span> <span class="hljs-symbol">:</span>= bouncycastle conscrypt telephony-common ims-common
<span class="hljs-comment">#指定依赖的静态java类库</span>
<span class="hljs-constant">LOCAL_STATIC_JAVA_LIBRARIES</span> <span class="hljs-symbol">:</span>= android-support-v4 android-support-v13 jsr305
<span class="hljs-comment">#指定模块的标签为optional</span>
<span class="hljs-constant">LOCAL_MODULE_TAGS</span> <span class="hljs-symbol">:</span>= optional
<span class="hljs-comment">#定义源文件列表</span>
<span class="hljs-constant">LOCAL_SRC_FILES</span> <span class="hljs-symbol">:</span>= \
        <span class="hljs-variable">$(</span>call all-java-files-under, src) \
        src/com/android/settings/<span class="hljs-constant">EventLogTags</span>.logtags
<span class="hljs-comment">#可选定义，不推荐定义</span>
<span class="hljs-constant">LOCAL_RESOURCE_DIR</span> <span class="hljs-symbol">:</span>= <span class="hljs-variable">$(</span><span class="hljs-constant">LOCAL_PATH</span>)/res
<span class="hljs-comment">#定义模块的名称</span>
<span class="hljs-constant">LOCAL_PACKAGE_NAME</span> <span class="hljs-symbol">:</span>= <span class="hljs-constant">Settings</span>
<span class="hljs-comment">#指定模块签名使用platform签名</span>
<span class="hljs-constant">LOCAL_CERTIFICATE</span> <span class="hljs-symbol">:</span>= platform
<span class="hljs-comment">#为true表示此apk将安装到priv-app目录</span>
<span class="hljs-constant">LOCAL_PRIVILEGED_MODULE</span> <span class="hljs-symbol">:</span>= <span class="hljs-keyword">true</span>
<span class="hljs-comment">#指定混淆的标志</span>
<span class="hljs-constant">LOCAL_PROGUARD_FLAG_FILES</span> <span class="hljs-symbol">:</span>= proguard.flags
ifneq (<span class="hljs-variable">$(</span><span class="hljs-constant">INCREMENTAL_BUILDS</span>),)
    <span class="hljs-constant">LOCAL_PROGUARD_ENABLED</span> <span class="hljs-symbol">:</span>= disabled
    <span class="hljs-constant">LOCAL_JACK_ENABLED</span> <span class="hljs-symbol">:</span>= incremental
endif
<span class="hljs-comment">#包含几个目录下的common.mk文件</span>
<span class="hljs-keyword">include</span> frameworks/opt/setupwizard/navigationbar/common.mk
<span class="hljs-keyword">include</span> frameworks/opt/setupwizard/library/common.mk
<span class="hljs-keyword">include</span> frameworks/base/packages/<span class="hljs-constant">SettingsLib</span>/common.mk
<span class="hljs-comment">#指定编译模块类型为apk</span>
<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-constant">BUILD_PACKAGE</span>)
<span class="hljs-comment"># Use the following include to make our test apk.</span>
ifeq (,<span class="hljs-variable">$(</span><span class="hljs-constant">ONE_SHOT_MAKEFILE</span>))
<span class="hljs-comment">#将源码目录下其余的Android.mk都包含进来</span>
<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span>call all-makefiles-under,<span class="hljs-variable">$(</span><span class="hljs-constant">LOCAL_PATH</span>))
endif</code></pre> 
<h4 id="231-模块编译变量简介">2.3.1 模块编译变量简介</h4> 
<ul><li>Android,mk文件能编译出不同的模块，是通过包含某个模块编译文件实现的，如上述代码中“include $(BUILD_PACKAGE)”。</li><li>Android的Build系统定义了很多模块编译变量，如下列表： <br> 
  <ul><li>这些模块编译文件规模都很小，注意时定义模块的目标和依赖关系</li></ul></li></ul> 
<table><thead><tr><th>模块编译变量</th><th>说明</th></tr></thead><tbody><tr><td>BUILD_HOST_STATIC_LIBRARY</td><td>对应文件是host_static_library.mk。用来产生编译平台使用的本地静态库</td></tr><tr><td>BUILD_HOST_SHARED_LIBRARY</td><td>用来产生编译平台使用的本地共享库</td></tr><tr><td>BUILD_STATIC_LIBTARAY</td><td>产生目标系统使用的本地静态库</td></tr><tr><td>BUILD_RAW_STATIC_LIBRARY</td><td>暂时未知用途</td></tr><tr><td>BUILD_SHARED_LIBRARY</td><td>产生编译平台使用的本地共享库</td></tr><tr><td>BUILD_EXECUTABLE</td><td>产生目标系统使用的Linux可执行文件</td></tr><tr><td>BUILD_RAW_EXECUTABLE</td><td>暂时未知</td></tr><tr><td>BUILD_HOST_EXECUTABLE</td><td>产生编译平台下使用的可执行文件</td></tr><tr><td>BUILD_PACKAGE</td><td>产生apk文件</td></tr><tr><td>BUILD_PHONY_PACKAGE</td><td>暂时未知</td></tr><tr><td>BUILD_HOST_PROBUILT</td><td>定义编译平台下的预编译模块目标</td></tr><tr><td>BUILD_PREBUILT</td><td>定义预编译的模块目标，作用是将这些预编译的模块引入系统</td></tr><tr><td>BUILD_MULTI_PREBUILT</td><td>定义多个预编译模块目标</td></tr><tr><td>BUILD_JAVA_LIBRARY</td><td>产生java共享库</td></tr><tr><td>BUILD_STATIC_JAVA_LIBRARY</td><td>产生ｊａｖａ静态库</td></tr><tr><td>BUILD_HOST_JAVA_LIBRARY</td><td>产生用于编译平台的java共享库</td></tr><tr><td>BUILD_DROIDDOC</td><td>暂时未知</td></tr><tr><td>BUILD_COPY_HEADERS</td><td>将LOCAL_COPY_HEADERS变量定义的文件复制到LOCAL_COPY_HEADERS_TO变量定义的路径中</td></tr><tr><td>BUILD_NATIVE_TEST</td><td>产生一个目标系统的可执行程序，相比较BUILD_EXECUTABLE只是多了测试相关的库路径和头文件路径</td></tr><tr><td>BUILD_HOST_NATIVE_TEST</td><td>产生一个编译平台下的可执行程序，相比较BUILD_HOST_EXECUTABLE只是多了定义了测试相关库的路径和头文件路径</td></tr></tbody></table> 
<h4 id="232-常用模块定义实例">2.3.2 常用模块定义实例</h4> 
<ol><li>编写一个apk文件</li></ol> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-constant">LOCAL_PATH</span><span class="hljs-symbol">:</span>= <span class="hljs-variable">$(</span>call my-dir)         <span class="hljs-comment">#设置LOCAL_PATH为当前目录</span>
<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-constant">CLEAR_VARS</span>)               <span class="hljs-comment">#包含进clear_vars.mk文件，该文件里将会清空除LOCAL_PATH外所有“LOCAL_”变量</span>

<span class="hljs-constant">LOCAL_JAVA_LIBRARIES</span> <span class="hljs-symbol">:</span>=             <span class="hljs-comment">#指定依赖的共享库java类库</span>
<span class="hljs-constant">LOCAL_STATIC_JAVA_LIBRARIES</span> <span class="hljs-symbol">:</span>=      <span class="hljs-comment">#指定依赖的静态java类库</span>

<span class="hljs-constant">LOCAL_SRC_FILES</span> <span class="hljs-symbol">:</span>= <span class="hljs-variable">$(</span>call all-java-files-under, src)<span class="hljs-comment">#定义源文件列表</span>

<span class="hljs-constant">LOCAL_MODULE_TAGS</span> <span class="hljs-symbol">:</span>= optional       <span class="hljs-comment">#指定模块的标签为optional</span>
<span class="hljs-constant">LOCAL_CERTIFICATE</span> <span class="hljs-symbol">:</span>= shared         <span class="hljs-comment">#指定模块签名方式</span>
<span class="hljs-constant">LOCAL_PACKAGE_NAME</span> <span class="hljs-symbol">:</span>= testapk       <span class="hljs-comment">#定义模块的名称</span>
<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-constant">BUILD_PACKAGE</span>)            </code></pre> 
<ol><li>编写一个java共享库</li></ol> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-constant">LOCAL_PATH</span><span class="hljs-symbol">:</span>= <span class="hljs-variable">$(</span>call my-dir)         <span class="hljs-comment">#设置LOCAL_PATH为当前目录</span>
<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-constant">CLEAR_VARS</span>)               <span class="hljs-comment">#包含进clear_vars.mk文件，该文件里将会清空除LOCAL_PATH外所有“LOCAL_”变量</span>

<span class="hljs-constant">LOCAL_SRC_FILES</span> <span class="hljs-symbol">:</span>= <span class="hljs-variable">$(</span>call all-java-files-under, src)<span class="hljs-comment">#定义源文件列表</span>
<span class="hljs-constant">LOCAL_MODULE_TAGS</span> <span class="hljs-symbol">:</span>= optional       <span class="hljs-comment">#指定模块的标签为optional</span>
<span class="hljs-constant">LOCAL_MODULE</span> <span class="hljs-symbol">:</span>= javadynamiclib      <span class="hljs-comment">#定义模块名称</span>
<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-constant">BUILD_JAVA_LIBRARY</span>)   </code></pre> 
<ol><li>编写一个java静态库</li></ol> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-constant">LOCAL_PATH</span><span class="hljs-symbol">:</span>= <span class="hljs-variable">$(</span>call my-dir)         <span class="hljs-comment">#设置LOCAL_PATH为当前目录</span>
<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-constant">CLEAR_VARS</span>)               <span class="hljs-comment">#包含进clear_vars.mk文件，该文件里将会清空除LOCAL_PATH外所有“LOCAL_”变量</span>

<span class="hljs-constant">LOCAL_SRC_FILES</span> <span class="hljs-symbol">:</span>= <span class="hljs-variable">$(</span>call all-java-files-under, src)<span class="hljs-comment">#定义源文件列表</span>
<span class="hljs-constant">LOCAL_MODULE</span> <span class="hljs-symbol">:</span>= javastaticlib      <span class="hljs-comment">#定义模块名称</span>
<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-constant">BUILD_STATIC_JAVA_LIBRARY</span> )   </code></pre> 
<ol><li>编写一个可执行文件</li></ol> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-constant">LOCAL_PATH</span><span class="hljs-symbol">:</span>= <span class="hljs-variable">$(</span>call my-dir)         <span class="hljs-comment">#设置LOCAL_PATH为当前目录</span>
<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-constant">CLEAR_VARS</span>)               <span class="hljs-comment">#包含进clear_vars.mk文件，该文件里将会清空除LOCAL_PATH外所有“LOCAL_”变量</span>
<span class="hljs-constant">LOCAL_SRC_FILES</span><span class="hljs-symbol">:</span>= service.cpp       
<span class="hljs-constant">LOCAL_SHARED_LIBRARIES</span> <span class="hljs-symbol">:</span>= libbutils libbinder <span class="hljs-comment">#指定模块需要链接的动态库</span>
ifeq (<span class="hljs-variable">$(</span><span class="hljs-constant">TARGET_OS</span>),linux)
            <span class="hljs-constant">LOCAL_CFLAGS</span> += -<span class="hljs-constant">DXP_UNIX</span>
endif
<span class="hljs-constant">LOCAL_MODULE</span> <span class="hljs-symbol">:</span>= service     <span class="hljs-comment">#定义模块名称</span>
<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-constant">BUILD_EXECUTABLE</span>)   </code></pre> 
<h4 id="233-预编译模块的目标定义">2.3.3 预编译模块的目标定义</h4> 
<blockquote> 
 <p>在实际的系统开发中，有很多apk包、jar包都是预编译好的，编译系统时只需要将这些二进制文件复制到image文件中</p> 
</blockquote> 
<ul><li><p>常用的复制方法 </p> 
  <ul><li>通过PRODUCT_COPY_TILES变量 <br> 
    <ul><li>问题1：有些apk包或jar包需要使用系统签名文件才能正常运行，这样复制方式行不通</li><li>问题2：一些动态库可能是源码中有些模块所依赖的，这种方法无法建立依赖关系，导致这些模块编译失败</li></ul></li></ul></li><li><p>解决方法：定义一个预编译模块</p> 
  <ul><li>LOCAL_SRC_FILES变量指定二进制文件的路径，通过LOCAL_MODULE_CLASS来指定模块类型，include的是BUILD_PREBUILT变量定义的编译文件</li></ul></li><li><p>常见模块写法 <br> 定义apk文件目标</p></li></ul> 
<pre class="prettyprint"><code class=" hljs makefile">include $(CLEAR_VARS)
<span class="hljs-constant">LOCAL_MODULE</span> := ThemeManager.apk
<span class="hljs-constant">LOCAL_SRC_FILES</span> := App/<span class="hljs-variable">$(LACAL_MODULE)</span>
<span class="hljs-constant">LOCAL_MODULE_TAGE</span> := optional
<span class="hljs-constant">LOCAL_MODULE_CLASS</span> :=APPS
<span class="hljs-constant">LOCAL_CERTIFICATE</span> := platform
include $(BUILT_PREBUILT)</code></pre> 
<p>定义静态jar包目标</p> 
<pre class="prettyprint"><code class=" hljs makefile">include $(CLEAR_VARS)
<span class="hljs-constant">LOCAL_MODULE</span> := libfirewall.jar
<span class="hljs-constant">LOCAL_SRC_FILES</span> := App/<span class="hljs-variable">$(LACAL_MODULE)</span>
<span class="hljs-constant">LOCAL_MODULE_TAGE</span> := optional
<span class="hljs-constant">LOCAL_MODULE_CLASS</span> :=JAVA_LIBRARIES
<span class="hljs-constant">LOCAL_CERTIFICATE</span> := platform
include $(BUILT_PREBUILT)</code></pre> 
<p>定义可执行文件</p> 
<pre class="prettyprint"><code class=" hljs makefile">include $(CLEAR_VARS)
<span class="hljs-constant">LOCAL_MODULE</span> :=bootanimation
<span class="hljs-constant">LOCAL_SRC_FILES</span> := bin/bootanimation
<span class="hljs-constant">LOCAL_MODULE_TAGE</span> := optional
<span class="hljs-constant">LOCAL_MODULE_CLASS</span> :=EXECUTABLES
<span class="hljs-constant">LOCAL_CERTIFICATE</span> :=<span class="hljs-variable">$(TARGET_OUT)</span>/bin
include $(BUILT_PREBUILT)</code></pre> 
<p>定义host平台下的jar包</p> 
<blockquote> 
 <p>这个例子是将系统编译时用到的sigapk.jar预编译，然后复制到out目录中，这样Build系统将能够使用这个文件夹来给其他的文件签名 <br> 例子中除了使用“BUILD_HOST_PREBUILT”表示目标定义是针对编译平台而不是设备平台的，还给出了定义预编译jar包模块的另外一种定义方式： <br> 使用变量LOCAL_PREBUILT_JAVA_LIBRARIES来定义</p> 
</blockquote> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-constant">CLEAR_VARS</span>)
<span class="hljs-constant">LOCAL_MODULE</span> <span class="hljs-symbol">:</span>=signapk
<span class="hljs-constant">LOCAL_PREBUILT_JAVA_LIBRARIES</span> <span class="hljs-symbol">:</span>= lib/<span class="hljs-variable">$(</span><span class="hljs-constant">LOCAL_MODULE</span>).jar
<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-constant">BUILT_HOST_PREBUILT</span>)</code></pre> 
<h4 id="234-常用local变量">2.3.4 常用”LOCAL_”变量</h4> 
<ul><li>编写模块的编译文件，实际就是定义一系列以“LOCAL_”开头的编译变量</li></ul> 
<table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>LOCAL_ASSET_FILES</td><td>编译apk时用来指定资源列表，通常写成：LOCAL_ASSET_FILES+=$(call find-subdir-assets)</td></tr><tr><td>LOCAL_CC</td><td>自定义C编译器代替缺省的编译器</td></tr><tr><td>LOCAL_CXX</td><td>自定义C++编译器来代替缺省的编译器</td></tr><tr><td>LOCAL_CFLAGS</td><td>定义额外的C/C++编译器的参数</td></tr><tr><td>LOCAL_CPPFLAGE</td><td>仅定义额外C++编译器参数，不用再C编译器中</td></tr><tr><td>LOCAL_CPP_EXTENSION</td><td>自定义C++源文件的后缀。例如：LOCAL_CPP_EXTENSION:=.cc，note：一旦定义，模块中其他的源文件都要使用该后缀，暂不支持混用</td></tr><tr><td>LOCAL_C_INCLUDES</td><td>指定头文件的搜索路径</td></tr><tr><td>LOCAL_FORCE_STATIC_EXECUTABLE</td><td>编译时需要链接的库有共享和静态两者共存的情况，该值设为true=》优先链接静态库。此情况只会在编译/root/sbin时用到</td></tr><tr><td>LOCAL_GENERTED_SOURCES</td><td></td></tr><tr><td>LOCAL_MODULE_TAGS</td><td>定义模块标签，Build系统根据标签来决定哪些模块也将安装</td></tr><tr><td>LOCAL_REQUIRED_MODULED</td><td>指定依赖的模块，一旦本模块被安装，通过此变量指定的模块也将安装</td></tr><tr><td>LOCAL_JAVACFLAGS</td><td>定义额外的javac编译器的参数</td></tr><tr><td>LOCAL_JAVALIBRARIES</td><td>指定模块指定的java库</td></tr><tr><td>LOCAL_LDFLAGS</td><td>定义链接器ld的参数</td></tr><tr><td>LOCAL_LDLIBS</td><td>自定模块链接四依赖的库，如果这些库文件不存在，并不会引起对它们的编译，这是此变量与LOCAL_SHARED_LIBRARIES的主要区别</td></tr><tr><td>LOCAL_NO_MANIFEST</td><td>在一个apk资源中可以指定此变量为true，表示此apk文件没有AndroidManifest.xml文件</td></tr><tr><td>LOCAL_PACKAGE_NAME</td><td>指定APP应用</td></tr><tr><td>LOCAL_PATH</td><td>指定Android.mk文件所在的目录</td></tr><tr><td>LOCAL_POST_PROCESS_COMMAND</td><td>在编译host相关的模块时，可以用此变量定义一天命令在link完成后执行</td></tr><tr><td>LOCAL_PREBUILT_LIB</td><td>指定预编译C/C++动态和静态库列表。用于预编译模块定义中</td></tr><tr><td>LOCAL_PREBUILT_JAVA_LIBRARIES</td><td>指定预编译java库列表。用于预编译模块定义中</td></tr><tr><td>LOCAL_SHARED_LIBRARIES</td><td>指定模块依赖的C/C++共享库列表</td></tr><tr><td>LOCAL_SRC_FILES</td><td>指定源文件列表</td></tr><tr><td>LOCAL_STATIC_LIBRARIES</td><td>指定依赖的C/C++静态库列表</td></tr><tr><td>LOCAL_MODULE</td><td>除应用（apk）以LOCAL_PACKAGE_NAME指定模块名以外，其余的模块都以LOCAL_MODULE指定模块名</td></tr><tr><td>LOCAL_MODULE_PATH</td><td>指定模块在目标系统的按照路径</td></tr><tr><td>LOCAL_UNSTRIPPED_PATH</td><td>指定模块的unstripped版本在out目录下的保存路径</td></tr><tr><td>LOCAL_WHOLE_STATIC_LIBRARIES</td><td>这变量也定义了模块依赖的静态库列表，和LOCAL_STATIC_LIBRARIES类似，但链接器不会将静态库中无人调用的代码去掉</td></tr><tr><td>LOCAL_YACCFLAGS</td><td>指定yacc参数</td></tr><tr><td>LOCAL_ADDITIONAL_DEPENDENCIES</td><td>指定本模块的依赖。用在不方便使用别的方法来指定依赖关系时</td></tr><tr><td>LOCAL_BUILT_MODULE</td><td>指定编译时存放中间文件的目录</td></tr><tr><td>LOCAL_INSTALLED_MODULE</td><td>指定模块的安装路径</td></tr><tr><td>LOCAL_MODULE_CLASS</td><td>定义模块的分类。根据分类，生成的模块会被按照到目标系统相应的目录下，但是如果同时使用了LOCAL_MODULE_PATH定义了路径，则安装到该目录下</td></tr><tr><td>LOCAL_MODULE_NAME</td><td>指定模块名称</td></tr><tr><td>LOCAL_MODULE_SUFFIX</td><td>指定当前模块的后缀。一旦指定，系统会在产生目标文件时，会以模块名加后缀来创建目标文件</td></tr><tr><td>LOCAL_STRIP_MODULE</td><td>指定模块是否需要strip，该模块是可执行文件或动态库时才能使用该变量</td></tr><tr><td>LOCAL_STRIPPABLE_MODULE</td><td>通常由Build系统设置，一般编译可执行文件和动态库时设置true</td></tr><tr><td>LOCAL_SYSTEM_SHARED_LIBRARIES</td><td>此变量在编译系统的基本库，如libc、libm等时，用来定义这些库的依赖库。通常在应用模块定义中不使用该变量</td></tr><tr><td>LOCAL_PRELINK_MODULE</td><td>编译.so模块时，定义是否需要prelink。prelink通过预链接的方式加快程序启动速度</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/92ddd2aa1ef7c82dc6e0fba5ec57a7d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">光衰、功率匹配</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7be0753e170fd877a7d7ff955a9b65a1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么样的数据应该放入缓存</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>