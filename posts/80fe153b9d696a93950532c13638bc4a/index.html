<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>三字棋（N子棋） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="三字棋（N子棋）" />
<meta property="og:description" content="目录
1.游戏介绍
2.程序构成
3.游戏思路和实现
1.创建棋盘并打印 2.玩家和电脑实现下棋步骤
3.判断双方谁先获得胜利或者双方平局
1.游戏介绍 三子棋又名井字棋，相信大家小时候都玩过，在一个3x3的棋盘上下棋，最先实现三字连成一条线的玩家获得胜利。
2.程序构成 game.h
#define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;// rand srand #include &lt;time.h&gt;// time #include &lt;windows.h&gt;//Sleep #define ROW 3 #define COL 3 //初始化棋盘 void init_board(char board[ROW][COL], int row, int col); //打印棋盘 void print_board(char board[ROW][COL], int row, int col); //玩家下棋 void player_input(char board[ROW][COL],int row,int col); //电脑下棋 void computer_input(char board[ROW][COL], int row, int col); //判断结果(输 赢 平局) //玩家赢返回 &#39;* &#39;,电脑赢返回 &#39;# &#39;,返回 &#39;B&#39;(游戏继续),返回 &#39;C&#39;(平局) char is_win(char board[ROW][COL], int row, int col); //判断棋盘是否已满,没满返回0(继续游戏)，满了返回1(平局) int is_full(char board[ROW][COL], int row, int col); game." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/80fe153b9d696a93950532c13638bc4a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-12T10:12:12+08:00" />
<meta property="article:modified_time" content="2022-09-12T10:12:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">三字棋（N子棋）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%B8%B8%E6%88%8F%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#1.%E6%B8%B8%E6%88%8F%E4%BB%8B%E7%BB%8D" rel="nofollow">1.游戏介绍</a></p> 
<p id="2.%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90-toc" style="margin-left:0px;"><a href="#2.%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90" rel="nofollow">2.程序构成</a></p> 
<p id="%C2%A03.%E6%B8%B8%E6%88%8F%E6%80%9D%E8%B7%AF%E5%92%8C%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%C2%A03.%E6%B8%B8%E6%88%8F%E6%80%9D%E8%B7%AF%E5%92%8C%E5%AE%9E%E7%8E%B0" rel="nofollow"> 3.游戏思路和实现</a></p> 
<p id="1.%E5%88%9B%E5%BB%BA%E6%A3%8B%E7%9B%98%E5%B9%B6%E6%89%93%E5%8D%B0%C2%A0-toc" style="margin-left:40px;"><a href="#1.%E5%88%9B%E5%BB%BA%E6%A3%8B%E7%9B%98%E5%B9%B6%E6%89%93%E5%8D%B0%C2%A0" rel="nofollow">1.创建棋盘并打印 </a></p> 
<p id="2.%E7%8E%A9%E5%AE%B6%E5%92%8C%E7%94%B5%E8%84%91%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%A3%8B%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><a href="#2.%E7%8E%A9%E5%AE%B6%E5%92%8C%E7%94%B5%E8%84%91%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%A3%8B%E6%AD%A5%E9%AA%A4" rel="nofollow">2.玩家和电脑实现下棋步骤</a></p> 
<p id="3.%E5%88%A4%E6%96%AD%E5%8F%8C%E6%96%B9%E8%B0%81%E5%85%88%E8%8E%B7%E5%BE%97%E8%83%9C%E5%88%A9%E6%88%96%E8%80%85%E5%8F%8C%E6%96%B9%E5%B9%B3%E5%B1%80-toc" style="margin-left:40px;"><a href="#3.%E5%88%A4%E6%96%AD%E5%8F%8C%E6%96%B9%E8%B0%81%E5%85%88%E8%8E%B7%E5%BE%97%E8%83%9C%E5%88%A9%E6%88%96%E8%80%85%E5%8F%8C%E6%96%B9%E5%B9%B3%E5%B1%80" rel="nofollow">3.判断双方谁先获得胜利或者双方平局</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E6%B8%B8%E6%88%8F%E4%BB%8B%E7%BB%8D">1.游戏介绍</h2> 
<p>三子棋又名井字棋，相信大家小时候都玩过，在一个3x3的棋盘上下棋，最先实现三字连成一条线的玩家获得胜利。</p> 
<h2 id="2.%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90">2.程序构成</h2> 
<p><img alt="" height="310" src="https://images2.imgbox.com/68/2a/te9AHKcc_o.png" width="671"></p> 
<p> <strong>game.h</strong></p> 
<pre><code class="language-cs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;// rand srand
#include &lt;time.h&gt;// time
#include &lt;windows.h&gt;//Sleep

#define ROW 3
#define COL 3

//初始化棋盘
void init_board(char board[ROW][COL], int row, int col);   

//打印棋盘
void print_board(char board[ROW][COL], int row, int col);

//玩家下棋
void player_input(char board[ROW][COL],int row,int col);

//电脑下棋
void computer_input(char board[ROW][COL], int row, int col);

//判断结果(输 赢 平局)
//玩家赢返回 '* ',电脑赢返回 '# ',返回 'B'(游戏继续),返回 'C'(平局)
char is_win(char board[ROW][COL], int row, int col);

//判断棋盘是否已满,没满返回0(继续游戏)，满了返回1(平局)
int is_full(char board[ROW][COL], int row, int col);
</code></pre> 
<p><strong>game.c</strong></p> 
<pre><code class="language-cs">#include "game.h"

void init_board(char board[ROW][COL], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; row; i++)
	{
		for (j = 0; j &lt; col; j++)
		{
			board[i][j] = ' ';
		}
	}
}

void print_board(char board[ROW][COL], int row, int col)
{
	int i = 0;
	for (i = 0; i &lt; row; i++)
	{
		int j = 0;
		// %c | %c | %c ;
		for (j = 0; j &lt; col; j++)
		{
			printf(" %c ",board[i][j]);
			if (j &lt; col - 1)
			{
				printf("|");
			}
		}
		printf("\n");
		//---|---|---
		if (i &lt; row - 1)
		{
			for (j = 0; j &lt; col; j++)
			{
				printf("---");
				if (j &lt; row - 1)
				{	
					printf("|");
				}
			}
		}
		
		printf("\n");
	}
}

void player_input(char board[ROW][COL], int row, int col)
{
	printf("玩家请下棋-&gt;\n");
	int x = 0;
	int y = 0;
	while (1)
	{
		scanf("%d %d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col &amp;&amp; board[x - 1][y - 1] == ' ')
		//x = 1 2 3; y = 1 2 3; 不懂数组的人玩这个游戏，并不知道数组的坐标，例如第一行第一列的坐标是0,0，方便游客游玩我们将每个坐标 + 1
		{
			board[x-1][y-1] = '*';//当我们输入1 ,1 将第一行第一列下棋为 * 时，数组这里 - 1，对应数组坐标 0,0
			break;
		}
		else if(board[x - 1][y - 1] != ' ')//坐标不为空格时表示已经有棋
		{
			printf("此格已经有棋子，请重输入-&gt;\n");
		}
		else//最后一种可能就是坐标输入超出棋盘坐标
			printf("超出棋盘，重新输入-&gt;\n");
	}

}

void computer_input(char board[ROW][COL], int row, int col,int ret)
{
	printf("电脑下棋中-&gt;\n");
	while (1)
	{
		int x = rand() % row;
		int y = rand() % col;
		Sleep(2000);
		if (board[x][y] == ' ')
		{
			board[x][y] = '#';
			break;
		}
	}
}

char is_win(char board[ROW][COL], int row, int col)
{	
	//横排判断
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; row; i++)
	{
		int count1 = 0;
		for (j = 0; j &lt; col-1; j++)
		{
			if (board[i][j] == board[i][j + 1] &amp;&amp; board[i][j] != ' ')
				count1++;
		}
		if (count1 == col - 1)
		{
			return board[i][j];
		}
	}
	//数列判断
	for (j = 0; j &lt; col; j++)
	{
		int count2 = 0;
		for (i = 0; i &lt; row - 1; i++)
		{
			if (board[i][j] == board[i + 1][j] &amp;&amp; board[i][j] != ' ')
				count2++;
		}
		if (count2 == row - 1)
		{
			return board[i][j];
		}
	}
	//右斜线判断,从左上角判断到右下角
	int count3 = 0;
	for (i = 0; i &lt; row-1; i++)
	{
		if (board[i][i] == board[i + 1][i + 1] &amp;&amp; board[i][i] != ' ')
		{
			count3++;
		}
		if (count3 == col - 1)
		{
			return board[i][i];
		}
	}
	//左斜线判断，从右上角判断到左下角
	int count4 = 0;
	for (i = 0; i &lt; row - 1; i++)
	{
		if (board[i][row - 1 - i] == board[i+1][row - 2 - i] &amp;&amp; board[i][row - 1 - i] != ' ')
		{
			count4++;
		}
		if (count4 == row - 1)
		{
			return board[i][row - 1 - i];
		}
		int x =is_full(board, ROW, COL);
		if (x == 0)
		{
			return 'B';
		}
		else
		{
			return 'C';
		}
	}
}

int is_full(char board[ROW][COL], int row, int col)
{
	int i = 0;
	int j = 0;
	while(1)
	{
		int count = 0;
		for (i = 0; i &lt; row; i++)
		{
			for (j = 0; j &lt; col; j++)
			{
				if (board[i][j] == ' ')
				{
					return 0;
					break;
				}
				else
				{
					count++;
				}
			}
			if (count == row * col)//棋盘所有格子数等于 行 X 列
			{
				return 1;
			}
		}
	}
	
}
</code></pre> 
<p><strong>test.c</strong></p> 
<pre><code class="language-cs">#include "game.h"

void menu()
{
	printf("**********1.play**********\n");
	printf("**********0.exit**********\n");
}
void game()
{
	char board[ROW][COL] = { 0 };
	srand((unsigned int)time(NULL));
	init_board(board, ROW, COL);
	print_board(board, ROW, COL);
	//先初始化棋盘再打印棋盘，不能将执行顺序搞反
	while (1)
	{
		player_input(board, ROW, COL);
		print_board(board, ROW, COL);
		char ret = is_win(board,ROW,COL);//is_win返回一个值给ret来判断游戏结果，* 玩家赢 # 电脑赢 C 棋盘满 平局
		if (ret == '*')
		{
			printf("恭喜你赢了！！！\n");
			break;
		}
		else if(ret == '#')
		{
			printf("很遗憾电脑赢了，再接再厉\n");
			break;
		}
		else if (ret == 'C')
		{
			printf("棋盘已满，平局\n");
			break;
		}
		computer_input(board, ROW, COL);
		print_board(board, ROW, COL);
		ret = is_win(board, ROW, COL);
		if (ret == '*')
		{
			printf("恭喜你赢了！！！\n");
			break;
		}
		else if (ret == '#')
		{
			printf("很遗憾电脑赢了，再接再厉\n");
			break;
		}
		else if (ret == 'C')
		{
			printf("棋盘已满，平局\n");
			break;
		}
	}
}  
int main()

{
	int input = 0;
	do 
	{
		menu();
		printf("请选择 --&gt;");
		scanf("%d", &amp;input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("输入错误，请重新输入\n");
			break;
		}
	} while (input);
	return 0;
}</code></pre> 
<h2 id="%C2%A03.%E6%B8%B8%E6%88%8F%E6%80%9D%E8%B7%AF%E5%92%8C%E5%AE%9E%E7%8E%B0"> 3.游戏思路和实现</h2> 
<h3 id="1.%E5%88%9B%E5%BB%BA%E6%A3%8B%E7%9B%98%E5%B9%B6%E6%89%93%E5%8D%B0%C2%A0">1.创建棋盘并打印 </h3> 
<p> 先创建出一个棋盘数组，行为ROW,列为COL</p> 
<p>创建形参row 和 col来接收ROW 和 COL 的值</p> 
<pre><code class="language-cs">char board[ROW][COL] = { 0 };
init_board(board, ROW, COL);
print_board(board, ROW, COL);</code></pre> 
<hr> 
<pre><code class="language-cs">//初始化棋盘
void init_board(char board[ROW][COL], int row, int col);   
</code></pre> 
<p><span style="color:#4da8ee;"><strong>init_board</strong> <strong>程序构成：</strong></span></p> 
<pre><code class="language-cs">void init_board(char board[ROW][COL], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; row; i++)
	{
		for (j = 0; j &lt; col; j++)
		{
			board[i][j] = ' ';
		}
	}
}</code></pre> 
<pre><code class="language-cs">//打印棋盘
void print_board(char board[ROW][COL], int row, int col);
</code></pre> 
<p> <strong><span style="color:#4da8ee;">print_board程序构成：</span></strong></p> 
<pre><code class="language-cs">void print_board(char board[ROW][COL], int row, int col)
{
	int i = 0;
	for (i = 0; i &lt; row; i++)
	{
		int j = 0;
		// %c | %c | %c ;
		for (j = 0; j &lt; col; j++)
		{
			printf(" %c ",board[i][j]);
			if (j &lt; col - 1)
			{
				printf("|");
			}
		}
		printf("\n");
		//---|---|---
		if (i &lt; row - 1)
		{
			for (j = 0; j &lt; col; j++)
			{
				printf("---");
				if (j &lt; row - 1)
				{
					printf("|");
				}
			}
		}
		
		printf("\n");
	}
}</code></pre> 
<p> </p> 
<p>竖排列可以理解为</p> 
<p>需要<strong>三行            ' ' | ' ' | ' ' </strong>        （红色圈的地方）当棋盘是3（ROW）x3（COL）时，<strong>需要row行</strong></p> 
<p>需要<strong>三个        ' '     </strong>   和<strong>二个        | </strong>       (红绿色重叠部分)</p> 
<p>当棋盘是3（ROW）x3（COL）时，需要<strong>col个        ' '    </strong>    和<strong>col-1个        |     </strong>   </p> 
<p><img alt="" height="509" src="https://images2.imgbox.com/d9/e8/CDuULqLi_o.png" width="848"></p> 
<p>横行可以理解为</p> 
<p>需要<strong>俩行</strong>    <strong>---|---|---</strong>      （红色圈的地方）  当棋盘是3（ROW）x3（COL）时，需要<strong>row-1行</strong></p> 
<p>每行需要<strong>三个        --- </strong>       和<strong>二个        |  </strong>     （红绿色重叠部分）</p> 
<p>当棋盘是3（ROW）x3（COL）时，需要<strong>col个</strong>        <strong>---</strong>        和<strong>col-1个 </strong>      <strong> |  </strong>      </p> 
<p><img alt="" height="423" src="https://images2.imgbox.com/07/24/Sv5slW9W_o.png" width="795"></p> 
<h3 id="2.%E7%8E%A9%E5%AE%B6%E5%92%8C%E7%94%B5%E8%84%91%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%A3%8B%E6%AD%A5%E9%AA%A4">2.玩家和电脑实现下棋步骤</h3> 
<pre><code class="language-cs">player_input(board, ROW, COL);
computer_input(board, ROW, COL);    
srand((unsigned int)time(NULL));//</code></pre> 
<p>rand函数可以返回一个整型随机数值，但是起点是一样的，所以每次rand的随机值都是一样的</p> 
<p>例如这次rand是 2 ，15 ，33 ，1，44，下次程序执行还是 2 ，15 ，33 ，1，44，</p> 
<p>srand可以初始化rand的起点，这时候使用time函数给srand随机的值，rand就可以每次返回不同的整型数值了。</p> 
<p>具体请看</p> 
<p><strong>玩家下棋：</strong></p> 
<pre><code class="language-cs">void player_input(char board[ROW][COL], int row, int col)</code></pre> 
<p><strong><span style="color:#4da8ee;">player_input 程序构成</span></strong> ：</p> 
<pre><code class="language-cs">void player_input(char board[ROW][COL], int row, int col)
{
	printf("玩家请下棋-&gt;\n");
	int x = 0;
	int y = 0;
	while (1)
	{
		scanf("%d %d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col &amp;&amp; board[x - 1][y - 1] == ' ')
		//x = 1 2 3; y = 1 2 3; 不懂数组的人玩这个游戏，并不知道数组的坐标，例如第一行第一列的坐标是0,0，方便游客游玩我们将每个坐标 + 1
		{
			board[x-1][y-1] = '*';//当我们输入1 ,1 将第一行第一列下棋为 * 时，数组这里 - 1，对应数组坐标 0,0
			break;
		}
		else if(board[x - 1][y - 1] != ' ')//坐标不为空格时表示已经有棋
		{
			printf("此格已经有棋子，请重输入-&gt;\n");
		}
		else//最后一种可能就是坐标输入超出棋盘坐标
			printf("超出棋盘，重新输入-&gt;\n");
	}

}
</code></pre> 
<p>方便游玩我们将坐标+1 </p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/5c/81/YG4ZkL2n_o.png" width="865"></p> 
<p><strong>电脑下棋：</strong></p> 
<pre><code class="language-cs">void computer_input(char board[ROW][COL], int row, int col,int ret)
</code></pre> 
<p><strong><span style="color:#4da8ee;">computer_input 程序构成：</span></strong></p> 
<pre><code class="language-cs">void computer_input(char board[ROW][COL], int row, int col,int ret)
{
	printf("电脑下棋中-&gt;\n");
	while (1)
	{
		int x = rand() % row;
		int y = rand() % col;
		Sleep(2000);
		if (board[x][y] == ' ')
		{
			board[x][y] = '#';
			break;
		}
	}
}
</code></pre> 
<h3 id="3.%E5%88%A4%E6%96%AD%E5%8F%8C%E6%96%B9%E8%B0%81%E5%85%88%E8%8E%B7%E5%BE%97%E8%83%9C%E5%88%A9%E6%88%96%E8%80%85%E5%8F%8C%E6%96%B9%E5%B9%B3%E5%B1%80">3.判断双方谁先获得胜利或者双方平局</h3> 
<p><strong>胜利条件：横排、竖排、x 交叉斜线（俩条）三个相同棋子连成一条线</strong></p> 
<p><strong>平局条件：棋盘下满，无棋盘位可下</strong></p> 
<pre><code class="language-cs">while (1)
	{
		player_input(board, ROW, COL);
		print_board(board, ROW, COL);
		char ret = is_win(board,ROW,COL);
		if (ret == '*')
		{
			printf("恭喜你赢了！！！\n");
			break;
		}
		else if(ret == '#')
		{
			printf("很遗憾电脑赢了，再接再厉\n");
			break;
		}
		else if (ret == 'C')
		{
			printf("棋盘已满，平局\n");
			break;
		}
		computer_input(board, ROW, COL);
		print_board(board, ROW, COL);
		ret = is_win(board, ROW, COL);
		if (ret == '*')
		{
			printf("恭喜你赢了！！！\n");
			break;
		}
		else if (ret == '#')
		{
			printf("很遗憾电脑赢了，再接再厉\n");
			break;
		}
		else if (ret == 'C')
		{
			printf("棋盘已满，平局\n");
			break;
		}
	}
}  </code></pre> 
<pre><code class="language-cs">char is_win(char board[ROW][COL], int row, int col)
{	
	//横排判断
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; row; i++)
	{
		int count1 = 0;
		for (j = 0; j &lt; col-1; j++)
		{
			if (board[i][j] == board[i][j + 1] &amp;&amp; board[i][j] != ' ')
				count1++;
		}
		if (count1 == col - 1)
		{
			return board[i][j];
		}
	}
	//数列判断
	for (j = 0; j &lt; col; j++)
	{
		int count2 = 0;
		for (i = 0; i &lt; row - 1; i++)
		{
			if (board[i][j] == board[i + 1][j] &amp;&amp; board[i][j] != ' ')
				count2++;
		}
		if (count2 == row - 1)
		{
			return board[i][j];
		}
	}
	//右斜线判断,从左上角判断到右下角
	int count3 = 0;
	for (i = 0; i &lt; row-1; i++)
	{
		if (board[i][i] == board[i + 1][i + 1] &amp;&amp; board[i][i] != ' ')
		{
			count3++;
		}
		if (count3 == col - 1)
		{
			return board[i][i];
		}
	}
	//左斜线判断，从右上角判断到左下角
	int count4 = 0;
	for (i = 0; i &lt; row - 1; i++)
	{
		if (board[i][row - 1 - i] == board[i+1][row - 2 - i] &amp;&amp; board[i][row - 1 - i] != ' ')
		{
			count4++;
		}
		if (count4 == row - 1)
		{
			return board[i][row - 1 - i];
		}
		int x =is_full(board, ROW, COL);
		if (x == 0)
		{
			return 'B';
		}
		else
		{
			return 'C';
		}
	}
}</code></pre> 
<p>棋盘满时判断：</p> 
<pre><code class="language-cs">is_full(board, ROW, COL);</code></pre> 
<pre><code class="language-cs">int is_full(char board[ROW][COL], int row, int col)
{
	int i = 0;
	int j = 0;
	while(1)
	{
		int count = 0;
		for (i = 0; i &lt; row; i++)
		{
			for (j = 0; j &lt; col; j++)
			{
				if (board[i][j] == ' ')
				{
					return 0;
					break;
				}
				else
				{
					count++;
				}
			}
			if (count == row * col)//棋盘所有格子数等于 行 X 列
			{
				return 1;
			}
		}
	}
	
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c88aa6ca104e64e9543f79ed6ff3ad9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TGK-planner编译报错PLUGINLIB_EXPORT_CLASS解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/663cbed67b683f90119edc9cbb4e5b71/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[ Linux ] 第一篇 基础指令 1</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>