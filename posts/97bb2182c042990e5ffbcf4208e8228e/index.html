<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Cocos2d-x 资源加密解密实践总结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Cocos2d-x 资源加密解密实践总结" />
<meta property="og:description" content="本文乃Siliphen原创，转载请注明出处：http://blog.csdn.net/stevenkylelee 本文针对的是cocos2d-x 3.4 版本进行研究。
做加密解密的思路 加密解密算法的简单介绍 首先，加密解密应该是一个单独的话题，一般不会涉及具体使用的引擎、框架和技术。
加密算法有Base64，DES等。
Base64的原理类似于凯撒密码，啥是凯撒密码呢，就是一个字符用另一个字符来代替。
比如：a用i代替，b用k代替，以此类推。加密和解密的过程就是一个互相映射的过程。
DES是一种使用密钥的加密算法。
DES和Base64这种无密钥的算法在使用上的区别是：
DES算法本身是可以不保密的，只要保密密钥即可，密钥才是解密的关键。
Base64如果用于加密的话，算法本身就是密钥。要保密算法。
MD5，SHA等是摘要算法。
Base64，DES都可以把密文还原出明文。
而MD5，SHA则不能对算法作用后的输出还原出原始数据。
摘要算法一般做身份验证。
我们做资源加密是要选择能把密文还原出明文的算法。
设计自己的加密解密算法 这属于密码学的内容了，可深可浅。
可以借鉴凯撒密码的原理自己对每个字节的内容进行映射来加密。
也可以对1字节，2字节，4字节的数据，用某个数进行异或运算来加密。
异或的特性是，用数A对内容B进行异或得到内容C，再用数A对内容C异或可以得到内容B。
这个特性可以被用来加密。同时，数A的作用就是密钥了。
设计的加密算法不同，加密算法的使用的接口也不同。
如果是用上面的2种思路做加密算法的话，加密算法的实现可以“in place”操作，
就是可以直接在密文所在的内存进行解密，不单独分配内存来保存解密后的数据。
如果加密算法很复杂，无法“就地还原”，就需要新申请内存来保存解密数据。
当然，执行速度一般是”就地还原“快。
我觉得，如果可以的话，最好是自己设计加密算法。
使用现成的DES之类的算法，密钥是关键。
如果是自己设计一个用密钥加密的算法，密钥和算法本身都是不公开的。
破解者要获取资源明文要经过如下步骤：
1.在程序中找到密钥的常量。
2.看懂反出来的汇编还原出算法，或者想办法利用加密算法的汇编代码。
其中步骤2会加大解密者解密的难度，这是自己设计加密算法比用现成的DES之类著名算法的好处。
加密解密的运用机制 我见过有一些人加密是对字段内容进行加密。
比如，他用xml保存数据，他只对保存的值进行加密。
内容类似这样 &lt;Entity Hp = &#34;密文&#34; AttackValue = &#34;密文&#34; &gt;
这并不是一种好的运用加密的方式，因为这种方式会：
1.透露程序的配置文件结构。XML、json等。
2.透露了程序可能使用的数据结构。看以上内容可猜想Entity实体类有2个字段，Hp（血量），AttackValue（攻击力）
更彻底的加密方式是，对整个xml、json等文件进行加密。
这样别人就不会知道关于你的数据的一丁点信息。
这种做法不是直接用数据解析库封装的类似LoadFile的函数直接读取文件。
而是，先把加密文件用文件读取方法读入内存，在内存解密后，再把解密数据传给解析库的解析函数。
这种做法要求解析库有对内存进行解析的接口。
比如，若用XML解析库，就会弃用LoadFile，要求有Parse方法。
有一种情况可能无法对整个数据文件进行加密。
就是使用sqlite等数据库的时候，这时候只能对字段进行加密了。
有些人设计加密机制会要求配置程序本身。
比如：程序需要一个配置（一个开关变量或者条件编译）来决定是否对资源进行解密。
发布时，把资源都加密好，开启程序对资源的解密。
开发时，资源不必加密，屏蔽程序对资源的解密。
这种做法需要来回设置解密开关，比较繁琐。
有一种实现思路更有扩展性、更灵活、使用更方便。
那就是自己设计文件头。
熟悉Win32编程的人可能会知道PE文件格式。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/97bb2182c042990e5ffbcf4208e8228e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-04-08T14:48:21+08:00" />
<meta property="article:modified_time" content="2015-04-08T14:48:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Cocos2d-x 资源加密解密实践总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-family:Microsoft YaHei"><span style="font-size:18px">本文乃Siliphen原创，转载请注明出处：</span><a target="_blank" href="http://blog.csdn.net/stevenkylelee" rel="noopener noreferrer"><span style="font-size:18px">http://blog.csdn.net/stevenkylelee </span></a></span></p> 
<p><span style="font-family:Microsoft YaHei"><br> <span style="font-size:18px"></span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">本文针对的是cocos2d-x 3.4 版本进行研究。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><br>  </span></p> 
<h2><span style="font-family:Microsoft YaHei">做加密解密的思路</span></h2> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<h3><span style="font-family:Microsoft YaHei">加密解密算法的简单介绍</span></h3> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">首先，加密解密应该是一个单独的话题，一般不会涉及具体使用的引擎、框架和技术。</span></span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span></span> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">加密算法有Base64，DES等。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">Base64的原理类似于凯撒密码，啥是凯撒密码呢，就是一个字符用另一个字符来代替。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">比如：a用i代替，b用k代替，以此类推。加密和解密的过程就是一个互相映射的过程。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">DES是一种使用密钥的加密算法。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">DES和Base64这种无密钥的算法在使用上的区别是：</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">DES算法本身是可以不保密的，只要保密密钥即可，密钥才是解密的关键。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">Base64如果用于加密的话，算法本身就是密钥。要保密算法。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">MD5，SHA等是摘要算法。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">Base64，DES都可以把密文还原出明文。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">而MD5，SHA则不能对算法作用后的输出还原出原始数据。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">摘要算法一般做身份验证。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">我们做资源加密是要选择能把密文还原出明文的算法。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span></span> 
<h3><span style="font-family:Microsoft YaHei">设计自己的加密解密算法</span></h3> 
<p><span style="font-family:Microsoft YaHei"><strong><span style="font-size:18px"></span></strong> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这属于密码学的内容了，可深可浅。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">可以借鉴凯撒密码的原理自己对每个字节的内容进行映射来加密。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">也可以对1字节，2字节，4字节的数据，用某个数进行异或运算来加密。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">异或的特性是，用数A对内容B进行异或得到内容C，再用数A对内容C异或可以得到内容B。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这个特性可以被用来加密。同时，数A的作用就是密钥了。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">设计的加密算法不同，加密算法的使用的接口也不同。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">如果是用上面的2种思路做加密算法的话，加密算法的实现可以“in place”操作，</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">就是可以直接在密文所在的内存进行解密，不单独分配内存来保存解密后的数据。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">如果加密算法很复杂，无法“就地还原”，就需要新申请内存来保存解密数据。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">当然，执行速度一般是”就地还原“快。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">我觉得，<span style="font-size:18px">如果可以的话，</span>最好是自己设计加密算法。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">使用现成的DES之类的算法，密钥是关键。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">如果是自己设计一个用密钥加密的算法，密钥和算法本身都是不公开的。</span></span></p> 
<p><span style="font-size:18px"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">破解者要获取资源明文要经过如下步骤：</span></span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"><span style="font-size:18px">1.在</span></span><span style="font-size:18px">程序中找到密钥的常量。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">2.看懂反出来的汇编还原出算法，或者想办法利用加密算法的汇编代码。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">其中步骤2会加大解密者解密的难度，这是自己设计加密算法比用现成的DES之类著名算法的好处。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<h3><span style="font-family:Microsoft YaHei">加密解密的运用机制</span></h3> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">我见过有一些人加密是对字段内容进行加密。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">比如，他用xml保存数据，他只对保存的值进行加密。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">内容类似这样 &lt;Entity Hp = "密文" AttackValue = "密文" &gt;</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这并不是一种好的运用加密的方式，因为这种方式会：</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">1.透露程序的配置文件结构。XML、json等。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">2.透露了程序可能使用的数据结构。看以上内容可猜想Entity实体类有2个字段，Hp（血量），AttackValue（攻击力）</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">更彻底的加密方式是，对整个xml、json等文件进行加密。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这样别人就不会知道关于你的数据的一丁点信息。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这种做法不是直接用数据解析库封装的类似LoadFile的函数直接读取文件。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">而是，先把加密文件用文件读取方法读入内存，在内存解密后，再把解密数据传给解析库的解析函数。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这种做法要求解析库有对内存进行解析的接口。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">比如，若用XML解析库，就会弃用LoadFile，要求有Parse方法。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">有一种情况可能无法对整个数据文件进行加密。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">就是使用sqlite等数据库的时候，这时候只能对字段进行加密了。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">有些人设计加密机制会要求配置程序本身。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">比如：程序需要一个配置（一个开关变量或者条件编译）来决定是否对资源进行解密。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">发布时，把资源都加密好，开启程序对资源的解密。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">开发时，资源不必加密，屏蔽程序对资源的解密。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这种做法需要来回设置解密开关，比较繁琐。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">有一种实现思路更有扩展性、更灵活、使用更方便。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">那就是自己设计文件头。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">熟悉Win32编程的人可能会知道PE文件格式。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">Windows运行一个exe之前，会检查PE文件头，</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">取得EXE文件的数据常量、代码区块等信息后，系统才能正确执行一个EXE。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">我们可以设计一个加密文件头，加密文件头有一个字段标识该文件是否是被加密过的。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">解密算法可以通过判断加密头的标识符来决定是否进行解密、采用哪种解密算法等。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这是一种数据驱动式的解密机制，解密信息都保存在加密数据本身中。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">对于没有被加密过的数据，程序判断没有文件加密头标识，就不执行解密。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这样，程序可以同时读取未加密的数据和已经加密的数据，而不需要对程序进行任何修改。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">注意：加密头的标识符应该足够特殊，保证和未加密的数据不会产生冲突。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">若未加密的数据刚好出现了加密头的内容，那么程序就会对未加密的数据进行解密。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<h2><span style="font-family:Microsoft YaHei">在Cocos2d-x 中做加密解密的研究过程</span></h2> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">我的项目配置是用CSV文件。解析器，用的是我自己写的CSV解析器：</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px">《</span><a target="_blank" href="http://blog.csdn.net/stevenkylelee/article/details/38309147" rel="noopener noreferrer"><span style="font-size:18px">CSV文件格式解析器的实现：从字符串Split到FSM</span></a><span style="font-size:18px">》</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">在游戏中这部分的解密，比较容易实现，就是对整个文件加密，</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">游戏启动时把加密文件读入内存进行解密，然后把解密数据传到解析器进行解析。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">一些由游戏产生的需要保存的数据，我用XML进行保存。加解密思路也如上。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">但是，对于图片、动画，粒子、cocostudio1.6导出的UI 等数据，加密就不那么简单了。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">因为，像 Sprite::create 这样的接口，并没有提供一个从内存获取纹理数据来初始化精灵的方式，</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">而是直接从磁盘文件中读。用户在外部是无法干预文件数据的读取载入的。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">游戏资源的加密要怎么做？——只有修改引擎了。- -！</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">我觉得，修改引擎并不是一个好的做法。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">引擎应该由引擎提供商来维护，而不是靠用户自己来动手。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">用户自己动手会造成项目维护升级困难。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">自己把引擎改得乱七八糟，想升级引擎到新的版本会变成很麻烦。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">就算是修改了一点，升级引擎版本一次，就要做一次修改，这样也很麻烦。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">要修改引擎，首先要跟踪调试，</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">以cocos2d-x 3.4 作为试验版本，从Sprite::create入口，一步步跟下去，</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">看看引擎是在哪里载入文件数据的。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">经过调试跟踪，Sprite::create的调用堆栈如下：</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">getData</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">FileUtilsWin32::getDataFromFile</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">Image::initWithImageFile</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">TextureCache::addImage</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">Sprite::initWithFile</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">Sprite::create</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span><br> <span style="font-size:18px">在windows上，精灵载入图片，是调用到了</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">CCFileUtils-win32.cpp 这个文件中的 </span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">static Data getData(const std::string&amp; filename, bool forString) 函数。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这个函数是一个非类成员静态函数。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">再调试下其他的数据载入，cocostudio1.6做的动画的调用堆栈是：</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px">cocos2d::FileUtilsWin32::getFileData<br> </span><span style="font-size:18px">cocostudio::DataReaderHelper::addDataFromFile<br> </span><span style="font-size:18px">cocostudio::ArmatureDataManager::addArmatureFileInfo</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> 经过了多种文件类型载入的跟踪调试后，总结，</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">基本上文件的载入函数有2个，都在CCFileUtils-win32.cpp文件中，</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">1.FileUtilsWin32::getFileData</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">2.getData</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">要做解密的话，就是修改这2个函数了。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">值得注意的一点是：getData函数的签名是：</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">static Data getData(const std::string&amp; filename, bool forString)</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">forString这个参数，用于标识读入的文件是不是一个文本文件。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">如果forString为真的话，buffer就要多分配一个字节，用来放置C语言的字符串结束符 \0 </span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">截图一下引擎的代码：</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p align="center"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><img alt="" src="https://images2.imgbox.com/5d/64/rpd9knMZ_o.png"></span></span></p> 
<div align="left"> 
 <span style="font-family:Microsoft YaHei"> </span> 
</div> 
<p></p> 
<p><span style="font-family:Microsoft YaHei"><br> </span></p> 
<span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span></span> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">要做解密，我们的解密数据内存也要用forString来判断是否多分配一个字节的内存。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">FileUtils单件类，很多函数是虚函数。FileUtils::getInstance，</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">在Windows平台上，返回的是 FileUtilsWin32子类对象。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">在Android平台上，返回FileUtilsAndroid子类对象。</span></span></p> 
<p><span style="font-size:18px"><span style="color:#3366ff"><span style="font-family:Microsoft YaHei">Cocos2d-x 3.4 实现在Windows和Android平台上的解密需要修改2个文件：</span></span></span></p> 
<p><span style="font-size:18px"><span style="color:#3366ff"><span style="font-family:Microsoft YaHei">Windows 平台的：cocos\platform\win32\CCFileUtils-win32.cpp</span></span></span></p> 
<p><span style="font-size:18px"><span style="color:#3366ff"><span style="font-family:Microsoft YaHei">Android 平台的：cocos\platform\android\CCFileUtils-android.cpp</span></span></span></p> 
<p><span style="font-size:18px"><span style="color:#3366ff"><span style="font-family:Microsoft YaHei">这2个文件里面都有 getData 和 getFileData 函数，都需要修改之。</span></span></span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">文件数据的读取在不同平台上有不同的实现，</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">如果要在目标平台上做资源加密，就需要修改目标平台上的读取实现。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">FileUtils是一个文件读取基类，提供有默认的实现，一些平台会提供特定的实现。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">通过多态，FileUtils让我们的游戏客户端代码不需要对特定平台做特定处理，</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">也不需要关心FileUtils子类的类型。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">比较遗憾的是，由于时间关系，目前我没有找到对音频文件解密的方法。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">调试跟踪发现，Cocos2d-x 在Windows上播放音频是直接调用了Win32 API，这些接口API是输入一个文件路径来播放音频的。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">之前有提到，做加密解密需要应用数据的接口从内存中获取数据。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">接口直接读磁盘文件，就没有办法干预文件的载入进行数据解密了。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">我觉得引擎的设计者，可以提供一个接口，利用观察者模式，</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">让引擎用户可以在不修改引擎本身的情况下，干预数据的读取进行数据变换来实现解密。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">毕竟自己改引擎不是一个好的做法。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<h2><span style="font-family:Microsoft YaHei">加密解密支持工具</span></h2> 
<p><span style="font-family:Microsoft YaHei"><span style="font-size:18px"></span> </span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">一般要做资源数据加密，大体会做2件事：</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">1.写一个工具，能对磁盘文件进行加密。这个工具，可能需要遍历文件夹、可批量选择文件等功能。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">2.在软件程序中加入解密功能，对工具加密后的数据进行解密。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">工具能方便操作、提高生产力，很重要。</span></span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这里，我自己做了2个工具。</span></span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">1.对cocos2d-x引擎进行修改和恢复的工具，使其具备解密功能。如下：</span></span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p align="center"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><img alt="" src="https://images2.imgbox.com/01/e6/7z52Mkhx_o.png"></span></span></p> 
<div align="left"> 
 <span style="font-family:Microsoft YaHei"> </span> 
</div> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p><span style="font-size:18px"><span style="font-family:Microsoft YaHei">2.对磁盘文件进行加密解密的工具，方便打包时的批量筛选操作。如下：</span></span></p> 
<p><span style="font-family:Microsoft YaHei"> </span></p> 
<p align="center"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><img alt="" src="https://images2.imgbox.com/85/20/iK523Lhw_o.gif"></span></span></p> 
<p align="center"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这个工具能识别出文件是否已经被加密，<span style="font-size:18px">原理是用了之前说的”加密文件头“设计。</span></span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这样可以防止对已被加密后的文件再次执行加密，防止对未被加密的文件执行解密。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">降低误操作的可能性同时，也直观地显示文件的加密状态。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">如果没有”加密文件头“，工具程序就无法识别一个文件到底是否被加密过。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p align="center"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<h2 style="text-align:left"><span style="font-family:Microsoft YaHei; font-size:24px">加密解密的额外开销</span></h2> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">做了资源加密会降低程序的性能，原因很简单，需要对文件数据进行额外的处理。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">稍微复杂一点的加密算法，可能要申请内存空间来保存解密数据。delete , new 都是耗时操作。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">资源的加密也可能会使得apk包体体积增大。这是为什么呢？</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">原因是，用Cocos2d-x 开发，资源会有很多<span style="font-size:18px">*.plist *.</span><span style="font-size:18px">ExportJson *.tmx 等文件。</span></span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><span style="font-size:18px">plist 可能是配置，也可能是粒子。</span><br> </span></span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">*.ExportJson 等文件是 <span style="font-size:18px">Cocostudio1.6 做出的动画、UI 导出文件。</span></span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><span style="font-size:18px">*</span><span style="font-size:18px">.tmx 是Tilemap输出的地图格式。</span><br> </span></span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">以上说的这些文件，都是用文本存储数据的，可以用Windows记事本打开查看内容。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">apk包实际上是一个压缩包，压缩算法对于有大量冗余数据的文件压缩率是很高的。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-family:Microsoft YaHei"><span style="font-size:18px">我之前写过一篇关于压缩算法的文章《<span style="font-size:20px; line-height:30px"><a target="_blank" href="http://blog.csdn.net/stevenkylelee/article/details/6940844" rel="noopener noreferrer">文件压缩与解压：哈夫曼编码</a></span>》</span><span style="font-size:18px">有兴趣的同学可以看看。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">我做过一个试验，600多KB的 UI *.plist *.<span style="font-size:18px">ExportJson 文件，打成apk包后，实际上只占60多KB。</span></span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">这是因为压缩算法能对这些配置的文本文件有很高的压缩率。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">如果我们的加密算法会降低冗余数据。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">比如：一个文件的内容是“111111...."，10万个1。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">我们的加密算法为了增加安全性，会把这些内容加密成为："sfsadfsa...."。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">解密者很难从无规律的不重复的数据推出原先的”<span style="font-size:18px">111111</span>....“的内容，</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">但同时对这样的数据，压缩率也会很低。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">我之前设计了一个使用密钥加密的算法，会消除冗余数据，</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">对于都是同样的一个字符的<span style="font-size:18px">内容</span>，可以加密成一个看似无规律的乱七八糟的内容，</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">其实还是有规律可言，只是无规律循环节很大而已。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">然后，这些加密后的数据，几乎就不能压缩了。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">加密资源之后输出<span style="font-size:18px">的</span>apk包相比没加密资源的包，体积增加不少。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">对于这种情况，可以仅对图片等关键资源加密，而不对非关键性的文本文件加密。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei">或者降低算法的加密强度，保留数据冗余性。</span></span></p> 
<p align="center" style="text-align:left"><span style="font-size:18px"><span style="font-family:Microsoft YaHei"><br> </span></span></p> 
<p align="center" style="text-align:left"><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6229d632e5752890f4471cb76f31b874/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Design Pattern</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dc4a57106b0027eb95369125d55fb170/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何在 Eclipse 中显示代码的行号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>