<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>zookeeper&#43;kafka分布式消息队列集群的部署 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="zookeeper&#43;kafka分布式消息队列集群的部署" />
<meta property="og:description" content="目录
一、zookeeper
1.Zookeeper 定义
2.Zookeeper 工作机制
3.Zookeeper 特点
4.Zookeeper 数据结构
5.Zookeeper 应用场景
（1）统一命名服务
（2）统一配置管理
（3）统一集群管理
（4）服务器动态上下线
6.Zookeeper 选举机制
（1）第一次启动选举机制
（2）非第一次启动选举机制
7.部署zookeeper群集
二、消息队列概述
1.为什么需要消息队列（MQ）
2.使用消息队列的好处
（1）解耦
（2）可恢复性
（3）缓冲
（4）灵活性和峰值处理能力
（5）异步通信
3.消息队列的两种模式
（1）点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）
（2）发布/订阅模式（一对多，又叫观察者模式，消费者消费数据之后不会清除消息）
三、kafka概述
1.Kafka 定义
2.Kafka 简介
3.Kafka 的特性
（1）高吞吐量、低延迟
（2）可扩展性
（3）持久性、可靠性
（4）容错性
（5）高并发
4.Kafka 系统架构
（1）Broker
（2）Topic
（3）Partition
（4）Replica
（5）Leader
（6）Follower （7）Producer （8）Consumer
（9）Consumer Group（CG）
（10）offset 偏移量
（11）Zookeeper
5.kafka的部署
6.kafka命令的使用
（1）创建topic
（2） 列出所有topic
（3）查看topic信息
（4） 发布消息
（5）消费消息 （6）修改指定topic分区数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9c581380fbb6bcd05a72d2a25e90ed02/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-08T08:49:18+08:00" />
<meta property="article:modified_time" content="2023-08-08T08:49:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">zookeeper&#43;kafka分布式消息队列集群的部署</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81zookeeper-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81zookeeper" rel="nofollow">一、zookeeper</a></p> 
<p id="1.Zookeeper%20%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#1.Zookeeper%20%E5%AE%9A%E4%B9%89" rel="nofollow">1.Zookeeper 定义</a></p> 
<p id="2.Zookeeper%20%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#2.Zookeeper%20%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6" rel="nofollow">2.Zookeeper 工作机制</a></p> 
<p id="3.Zookeeper%20%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#3.Zookeeper%20%E7%89%B9%E7%82%B9" rel="nofollow">3.Zookeeper 特点</a></p> 
<p id="4.Zookeeper%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#4.Zookeeper%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">4.Zookeeper 数据结构</a></p> 
<p id="5.Zookeeper%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#5.Zookeeper%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">5.Zookeeper 应用场景</a></p> 
<p id="%EF%BC%881%EF%BC%89%E7%BB%9F%E4%B8%80%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E7%BB%9F%E4%B8%80%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1" rel="nofollow">（1）统一命名服务</a></p> 
<p id="%EF%BC%882%EF%BC%89%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86" rel="nofollow">（2）统一配置管理</a></p> 
<p id="%EF%BC%883%EF%BC%89%E7%BB%9F%E4%B8%80%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E7%BB%9F%E4%B8%80%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86" rel="nofollow">（3）统一集群管理</a></p> 
<p id="%EF%BC%884%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E6%80%81%E4%B8%8A%E4%B8%8B%E7%BA%BF-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E6%80%81%E4%B8%8A%E4%B8%8B%E7%BA%BF" rel="nofollow">（4）服务器动态上下线</a></p> 
<p id="6.Zookeeper%20%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#6.Zookeeper%20%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6" rel="nofollow">6.Zookeeper 选举机制</a></p> 
<p id="%EF%BC%881%EF%BC%89%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6" rel="nofollow">（1）第一次启动选举机制</a></p> 
<p id="%EF%BC%882%EF%BC%89%E9%9D%9E%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E9%9D%9E%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6" rel="nofollow">（2）非第一次启动选举机制</a></p> 
<p id="7.%E9%83%A8%E7%BD%B2zookeeper%E7%BE%A4%E9%9B%86-toc" style="margin-left:40px;"><a href="#7.%E9%83%A8%E7%BD%B2zookeeper%E7%BE%A4%E9%9B%86" rel="nofollow">7.部署zookeeper群集</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0" rel="nofollow">二、消息队列概述</a></p> 
<p id="1.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MQ%EF%BC%89-toc" style="margin-left:40px;"><a href="#1.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MQ%EF%BC%89" rel="nofollow">1.为什么需要消息队列（MQ）</a></p> 
<p id="2.%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%A5%BD%E5%A4%84-toc" style="margin-left:40px;"><a href="#2.%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%A5%BD%E5%A4%84" rel="nofollow">2.使用消息队列的好处</a></p> 
<p id="%EF%BC%881%EF%BC%89%E8%A7%A3%E8%80%A6-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E8%A7%A3%E8%80%A6" rel="nofollow">（1）解耦</a></p> 
<p id="%EF%BC%882%EF%BC%89%E5%8F%AF%E6%81%A2%E5%A4%8D%E6%80%A7-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E5%8F%AF%E6%81%A2%E5%A4%8D%E6%80%A7" rel="nofollow">（2）可恢复性</a></p> 
<p id="%EF%BC%883%EF%BC%89%E7%BC%93%E5%86%B2-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E7%BC%93%E5%86%B2" rel="nofollow">（3）缓冲</a></p> 
<p id="%EF%BC%884%EF%BC%89%E7%81%B5%E6%B4%BB%E6%80%A7%E5%92%8C%E5%B3%B0%E5%80%BC%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E7%81%B5%E6%B4%BB%E6%80%A7%E5%92%8C%E5%B3%B0%E5%80%BC%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B" rel="nofollow">（4）灵活性和峰值处理能力</a></p> 
<p id="%EF%BC%885%EF%BC%89%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1" rel="nofollow">（5）异步通信</a></p> 
<p id="3.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#3.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F" rel="nofollow">3.消息队列的两种模式</a></p> 
<p id="%EF%BC%881%EF%BC%89%E7%82%B9%E5%AF%B9%E7%82%B9%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%BB%E5%8A%A8%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%B6%88%E6%81%AF%E6%94%B6%E5%88%B0%E5%90%8E%E6%B6%88%E6%81%AF%E6%B8%85%E9%99%A4%EF%BC%89-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E7%82%B9%E5%AF%B9%E7%82%B9%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%BB%E5%8A%A8%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%B6%88%E6%81%AF%E6%94%B6%E5%88%B0%E5%90%8E%E6%B6%88%E6%81%AF%E6%B8%85%E9%99%A4%EF%BC%89" rel="nofollow">（1）点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）</a></p> 
<p id="%EF%BC%882%EF%BC%89%E5%8F%91%E5%B8%83%2F%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%8F%88%E5%8F%AB%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E6%95%B0%E6%8D%AE%E4%B9%8B%E5%90%8E%E4%B8%8D%E4%BC%9A%E6%B8%85%E9%99%A4%E6%B6%88%E6%81%AF%EF%BC%89-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E5%8F%91%E5%B8%83%2F%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%8F%88%E5%8F%AB%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E6%95%B0%E6%8D%AE%E4%B9%8B%E5%90%8E%E4%B8%8D%E4%BC%9A%E6%B8%85%E9%99%A4%E6%B6%88%E6%81%AF%EF%BC%89" rel="nofollow">（2）发布/订阅模式（一对多，又叫观察者模式，消费者消费数据之后不会清除消息）</a></p> 
<p id="%E4%B8%89%E3%80%81kafka%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81kafka%E6%A6%82%E8%BF%B0" rel="nofollow">三、kafka概述</a></p> 
<p id="1.Kafka%20%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#1.Kafka%20%E5%AE%9A%E4%B9%89" rel="nofollow">1.Kafka 定义</a></p> 
<p id="2.Kafka%20%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#2.Kafka%20%E7%AE%80%E4%BB%8B" rel="nofollow">2.Kafka 简介</a></p> 
<p id="3.Kafka%20%E7%9A%84%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#3.Kafka%20%E7%9A%84%E7%89%B9%E6%80%A7" rel="nofollow">3.Kafka 的特性</a></p> 
<p id="%EF%BC%881%EF%BC%89%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F%E3%80%81%E4%BD%8E%E5%BB%B6%E8%BF%9F-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F%E3%80%81%E4%BD%8E%E5%BB%B6%E8%BF%9F" rel="nofollow">（1）高吞吐量、低延迟</a></p> 
<p id="%EF%BC%882%EF%BC%89%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7" rel="nofollow">（2）可扩展性</a></p> 
<p id="%EF%BC%883%EF%BC%89%E6%8C%81%E4%B9%85%E6%80%A7%E3%80%81%E5%8F%AF%E9%9D%A0%E6%80%A7-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E6%8C%81%E4%B9%85%E6%80%A7%E3%80%81%E5%8F%AF%E9%9D%A0%E6%80%A7" rel="nofollow">（3）持久性、可靠性</a></p> 
<p id="%EF%BC%884%EF%BC%89%E5%AE%B9%E9%94%99%E6%80%A7-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E5%AE%B9%E9%94%99%E6%80%A7" rel="nofollow">（4）容错性</a></p> 
<p id="%EF%BC%885%EF%BC%89%E9%AB%98%E5%B9%B6%E5%8F%91-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89%E9%AB%98%E5%B9%B6%E5%8F%91" rel="nofollow">（5）高并发</a></p> 
<p id="4.Kafka%20%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84-toc" style="margin-left:40px;"><a href="#4.Kafka%20%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84" rel="nofollow">4.Kafka 系统架构</a></p> 
<p id="%EF%BC%881%EF%BC%89Broker-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89Broker" rel="nofollow">（1）Broker</a></p> 
<p id="%EF%BC%882%EF%BC%89Topic-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89Topic" rel="nofollow">（2）Topic</a></p> 
<p id="%EF%BC%883%EF%BC%89Partition-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89Partition" rel="nofollow">（3）Partition</a></p> 
<p id="%EF%BC%884%EF%BC%89Replica-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89Replica" rel="nofollow">（4）Replica</a></p> 
<p id="%EF%BC%885%EF%BC%89Leader-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89Leader" rel="nofollow">（5）Leader</a></p> 
<p id="%EF%BC%886%EF%BC%89Follower%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%EF%BC%886%EF%BC%89Follower%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0" rel="nofollow">（6）Follower        </a></p> 
<p id="%EF%BC%887%EF%BC%89Producer%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%EF%BC%887%EF%BC%89Producer%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0" rel="nofollow">（7）Producer        </a></p> 
<p id="%EF%BC%888%EF%BC%89Consumer-toc" style="margin-left:80px;"><a href="#%EF%BC%888%EF%BC%89Consumer" rel="nofollow">（8）Consumer</a></p> 
<p id="%EF%BC%889%EF%BC%89Consumer%20Group%EF%BC%88CG%EF%BC%89-toc" style="margin-left:80px;"><a href="#%EF%BC%889%EF%BC%89Consumer%20Group%EF%BC%88CG%EF%BC%89" rel="nofollow">（9）Consumer Group（CG）</a></p> 
<p id="%EF%BC%8810%EF%BC%89offset%20%E5%81%8F%E7%A7%BB%E9%87%8F-toc" style="margin-left:80px;"><a href="#%EF%BC%8810%EF%BC%89offset%20%E5%81%8F%E7%A7%BB%E9%87%8F" rel="nofollow">（10）offset 偏移量</a></p> 
<p id="%EF%BC%8811%EF%BC%89Zookeeper-toc" style="margin-left:80px;"><a href="#%EF%BC%8811%EF%BC%89Zookeeper" rel="nofollow">（11）Zookeeper</a></p> 
<p id="5.kafka%E7%9A%84%E9%83%A8%E7%BD%B2-toc" style="margin-left:40px;"><a href="#5.kafka%E7%9A%84%E9%83%A8%E7%BD%B2" rel="nofollow">5.kafka的部署</a></p> 
<p id="6.kafka%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#6.kafka%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">6.kafka命令的使用</a></p> 
<p id="%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BAtopic-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BAtopic" rel="nofollow">（1）创建topic</a></p> 
<p id="%EF%BC%882%EF%BC%89%20%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89topic-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%20%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89topic" rel="nofollow">（2） 列出所有topic</a></p> 
<p id="%EF%BC%883%EF%BC%89%E6%9F%A5%E7%9C%8Btopic%E4%BF%A1%E6%81%AF-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E6%9F%A5%E7%9C%8Btopic%E4%BF%A1%E6%81%AF" rel="nofollow">（3）查看topic信息</a></p> 
<p id="%EF%BC%884%EF%BC%89%20%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%20%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF" rel="nofollow">（4） 发布消息</a></p> 
<p id="%EF%BC%885%EF%BC%89%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%C2%A0-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%C2%A0" rel="nofollow">（5）消费消息 </a></p> 
<p id="%EF%BC%886%EF%BC%89%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9Atopic%E5%88%86%E5%8C%BA%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%886%EF%BC%89%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9Atopic%E5%88%86%E5%8C%BA%E6%95%B0" rel="nofollow">（6）修改指定topic分区数</a></p> 
<p id="%EF%BC%887%EF%BC%89%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9Atopic-toc" style="margin-left:80px;"><a href="#%EF%BC%887%EF%BC%89%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9Atopic" rel="nofollow">（7）删除指定topic</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81zookeeper">一、zookeeper</h2> 
<h3 id="1.Zookeeper%20%E5%AE%9A%E4%B9%89">1.Zookeeper 定义</h3> 
<p>        Zookeeper是一个开源的分布式的，为分布式框架提供协调服务的Apache项目。</p> 
<h3 id="2.Zookeeper%20%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6">2.Zookeeper 工作机制</h3> 
<p>        Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。也就是说 Zookeeper = 文件系统 + 通知机制。</p> 
<p><img alt="" height="838" src="https://images2.imgbox.com/20/58/vexKSqGO_o.png" width="1200"></p> 
<h3 id="3.Zookeeper%20%E7%89%B9%E7%82%B9">3.Zookeeper 特点</h3> 
<p>（1）一个领导者（Leader），多个跟随者（Follower）组成的集群。</p> 
<p>（2）Zookeeper集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。<strong>所以Zookeeper适合安装</strong><strong>奇数（&gt;=3）台</strong><strong>服务器</strong>。</p> 
<p>（3）<strong>全局数据一致</strong>：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。<br> （4）<strong>更新请求顺序执行</strong>，来自同一个Client的更新请求按其发送顺序依次执行，即先进先出</p> 
<p>（5）数据更新<strong>原子性</strong>，一次数据更新要么成功，要么失败。</p> 
<p>（6）<strong>实时性</strong>，在一定时间范围内，Client能读到最新数据。</p> 
<p><img alt="" height="519" src="https://images2.imgbox.com/49/0c/ycHDpvh4_o.png" width="1200"></p> 
<h3 id="4.Zookeeper%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">4.Zookeeper 数据结构</h3> 
<p>        ZooKeeper数据模型的结构与Linux文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识.</p> 
<h3 id="5.Zookeeper%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">5.Zookeeper 应用场景</h3> 
<p>        提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p> 
<h4 id="%EF%BC%881%EF%BC%89%E7%BB%9F%E4%B8%80%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1">（1）统一命名服务</h4> 
<p>        在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。例如：IP不容易记住，而域名容易记住。</p> 
<h4 id="%EF%BC%882%EF%BC%89%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86">（2）统一配置管理</h4> 
<p>        分布式环境下，配置文件同步非常常见。一般要求一个集群中，<strong>所有节点的配置信息是一致的</strong>，比如Kafka集群。对配置文件修改后，希望能够快速同步到各个节点上。</p> 
<p>        配置管理可交由ZooKeeper实现。可将配置信息写入ZooKeeper上的一个Znode。各个客户端服务器监听这个Znode。一旦 Znode中的数据被修改，ZooKeeper将通知各个客户端服务器。</p> 
<h4 id="%EF%BC%883%EF%BC%89%E7%BB%9F%E4%B8%80%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86"><strong>（3）统一集群管理</strong></h4> 
<p>        分布式环境中，实时掌握每个节点的状态是必要的。可根据节点实时状态做出一些调整。</p> 
<p>       <strong> ZooKeeper可以实现实时监控节点状态变化</strong>。可将节点信息写入ZooKeeper上的一个ZNode。监听这个ZNode可获取它的实时状态变化。</p> 
<h4 id="%EF%BC%884%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E6%80%81%E4%B8%8A%E4%B8%8B%E7%BA%BF">（4）服务器动态上下线</h4> 
<p>        <strong>客户端能实时洞察到服务器上下线的变化。</strong></p> 
<p><strong>（5）软负载均衡</strong></p> 
<p>        在Zookeeper中记录每台服务器的访问数，<strong>让访问数最少的服务器去处理最新的客户端请求。（类似于调度算法中的最小连接）</strong></p> 
<h3 id="6.Zookeeper%20%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6">6.Zookeeper 选举机制</h3> 
<blockquote> 
 <p><strong>SID：</strong>服务器ID。用来唯一标识一台ZooKeeper集群中的机器，每台机器不能重复，和myid一致。<br><strong>ZXID：</strong>事务ID。ZXID是一个事务ID，用来标识一次服务器状态的变更。在某一时刻，集群中的每台机器的ZXID值不一定完全一致，这和ZooKeeper服务器对于客户端“更新请求”的处理逻辑速度有关。<br><strong>Epoch：</strong>每个Leader任期的代号。没有Leader时同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加</p> 
</blockquote> 
<h4 id="%EF%BC%881%EF%BC%89%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6">（1）第一次启动选举机制</h4> 
<p>        服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成，服务器1状态保持为LOOKING；</p> 
<p>        服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息：此时服务器1发现服务器2的myid比自己目前投票推举的（服务器1）大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上结果，选举无法完成，服务器1，2状态保持LOOKING。</p> 
<p>        服务器3启动，发起一次选举。此时服务器1和2都会更改选票为服务器3。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数，服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；</p> 
<p>        服务器4启动，发起一次选举。此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING；</p> 
<p>        服务器5启动，同4一样做FOLLOWING。</p> 
<p><img alt="" height="445" src="https://images2.imgbox.com/51/35/UKGjdCig_o.png" width="1200"></p> 
<h4 id="%EF%BC%882%EF%BC%89%E9%9D%9E%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6">（2）非第一次启动选举机制</h4> 
<p>        当ZooKeeper 集群中的一台服务器出现以下两种情况之一时，就会开始进入Leader选举：</p> 
<ul><li>服务器初始化启动。</li><li>服务器运行期间无法和Leader保持连接。</li></ul> 
<p>        而当一台机器进入Leader选举流程时，当前集群也可能会处于以下两种状态：</p> 
<ul><li><strong>集群中本来就已经存在一个Leader。</strong></li></ul> 
<p>        对于已经存在Leader的情况，机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该机器来说，仅仅需要和 Leader机器建立连接，并进行状态同步即可。</p> 
<ul><li><strong>集群中确实不存在Leader。</strong></li></ul> 
<p>        假设ZooKeeper由5台服务器组成，SID分别为1、2、3、4、5，ZXID分别为8、8、8、7、7，并且此时SID为3的服务器是Leader。某一时刻，3和5服务器出现故障，因此开始进行Leader选举。</p> 
<p><img alt="" height="410" src="https://images2.imgbox.com/9f/5e/XqLSOuXK_o.png" width="1200"></p> 
<blockquote> 
 <p><strong>选举Leader规则</strong></p> 
 <p><strong>1.Epoch大的直接胜出<br> 2.Epoch相同，事务id大的胜出<br> 3.事务id相同，服务器id大的胜出</strong></p> 
</blockquote> 
<h3 id="7.%E9%83%A8%E7%BD%B2zookeeper%E7%BE%A4%E9%9B%86">7.部署zookeeper群集</h3> 
<blockquote> 
 <p><strong>准备 3 台服务器做 Zookeeper 集群</strong><br> 192.168.116.20<br> 192.168.116.30<br> 192.168.116.40</p> 
</blockquote> 
<p><strong>三台安装jdk环境</strong></p> 
<pre><code>yum install -y java-1.8.0-openjdk java-1.8.0-openjdk-devel
</code></pre> 
<p><img alt="" height="100" src="https://images2.imgbox.com/0f/36/4hJ6KLec_o.png" width="708"></p> 
<p><strong>下载安装包，官方下载地址：</strong><a href="https://archive.apache.org/dist/zookeeper/" rel="nofollow" title="Index of /dist/zookeeper">Index of /dist/zookeeper</a></p> 
<p><strong>将下载好的安装包放在/opt目录，解压到/usr/local/zookeeper/</strong></p> 
<pre><code class="language-bash">cd /opt
tar zxvf apache-zookeeper-3.5.7-bin.tar.gz
mv apache-zookeeper-3.5.7-bin /usr/local/zookeeper/
</code></pre> 
<p><strong>修改配置文件</strong></p> 
<pre><code class="language-bash">cd /usr/local/zookeeper/conf/
cp zoo_sample.cfg zoo.cfg

vim zoo.cfg

tickTime=2000      #通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒
initLimit=10       #Leader和Follower初始连接时能容忍的最多心跳数（tickTime的数量），这里表示为10*2s
syncLimit=5        #Leader和Follower之间同步通信的超时时间，这里表示如果超过5*2s，Leader认为Follwer死掉，并从服务器列表中删除Follwer
dataDir=/usr/local/zookeeper/data      #修改，指定保存Zookeeper中的数据的目录，目录需要单独创建
dataLogDir=/usr/local/zookeeper/logs   #添加，指定存放日志的目录，目录需要单独创建
clientPort=2181    #客户端连接端口

#添加集群信息
server.1=192.168.116.10:3188:3288
server.2=192.168.116.20:3188:3288
server.3=192.168.116.30:3188:3288</code></pre> 
<p><img alt="" height="537" src="https://images2.imgbox.com/9a/8a/QZzPBWRn_o.png" width="1033"></p> 
<blockquote> 
 <p><strong>集群信息字段解释</strong></p> 
 <p>server.A=B:C:D<br>         A是一个数字，表示这个是第几号服务器。集群模式下需要在zoo.cfg中dataDir指定的目录下创建一个文件myid，这个文件里面有一个数据就是A的值，Zookeeper启动时读取此文件，拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server。<br>         B是这个服务器的地址。<br>         C是这个服务器Follower与集群中的Leader服务器交换信息的端口。<br>         D是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</p> 
</blockquote> 
<p><strong>将配置好的文件传到另外两台机器</strong></p> 
<pre><code class="language-bash">scp /usr/local/zookeeper/conf/zoo.cfg 192.168.116.20:/usr/local/zookeeper/conf/
scp /usr/local/zookeeper/conf/zoo.cfg 192.168.116.30:/usr/local/zookeeper/conf/
</code></pre> 
<p><strong>在每个节点上创建数据目录和日志目录</strong></p> 
<pre><code class="language-bash">mkdir /usr/local/zookeeper/data
mkdir /usr/local/zookeeper/logs</code></pre> 
<p><strong>在每个节点的dataDir指定的目录下创建一个 myid 的文件 </strong></p> 
<pre><code class="language-bash">echo 1 &gt; /usr/local/zookeeper/data/myid
echo 2 &gt; /usr/local/zookeeper/data/myid
echo 3 &gt; /usr/local/zookeeper/data/myid</code></pre> 
<p><strong>开启zookeeper</strong></p> 
<p><img alt="" height="124" src="https://images2.imgbox.com/e8/f1/qbjHiaTV_o.png" width="1075"></p> 
<p><img alt="" height="716" src="https://images2.imgbox.com/d7/dc/rXw0JE1x_o.png" width="1130"></p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0">二、消息队列概述</h2> 
<h3 id="1.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MQ%EF%BC%89">1.为什么需要消息队列（MQ）</h3> 
<p>        主要原因是由于在高并发环境下，同步请求来不及处理，请求往往会发生阻塞。比如大量的请求并发访问数据库，导致行锁表锁，最后请求线程会堆积过多，从而触发 too many connection 错误，引发雪崩效应。</p> 
<p>        我们使用消息队列，通过异步处理请求，从而缓解系统的压力。消息队列常应用于异步处理，流量削峰，应用解耦，消息通讯等场景。</p> 
<p><strong>当前比较常见的 MQ 中间件有 ActiveMQ、RabbitMQ、RocketMQ、Kafka 等。</strong></p> 
<p><img alt="" height="773" src="https://images2.imgbox.com/1f/d8/pKuQPPP9_o.png" width="1200"></p> 
<h3 id="2.%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%A5%BD%E5%A4%84">2.使用消息队列的好处</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E8%A7%A3%E8%80%A6">（1）解耦</h4> 
<p>        允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p> 
<h4 id="%EF%BC%882%EF%BC%89%E5%8F%AF%E6%81%A2%E5%A4%8D%E6%80%A7">（2）可恢复性</h4> 
<p>        系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p> 
<h4 id="%EF%BC%883%EF%BC%89%E7%BC%93%E5%86%B2">（3）缓冲</h4> 
<p>        有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。</p> 
<h4 id="%EF%BC%884%EF%BC%89%E7%81%B5%E6%B4%BB%E6%80%A7%E5%92%8C%E5%B3%B0%E5%80%BC%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B">（4）灵活性和峰值处理能力</h4> 
<p>        在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。</p> 
<p>        使用消息队列能够使关键组件顶住突发的访问压力（例如双十一），而不会因为突发的超负荷的请求而完全崩溃。</p> 
<h4 id="%EF%BC%885%EF%BC%89%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1">（5）异步通信</h4> 
<p>        很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p> 
<h3 id="3.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F">3.消息队列的两种模式</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E7%82%B9%E5%AF%B9%E7%82%B9%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%BB%E5%8A%A8%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%B6%88%E6%81%AF%E6%94%B6%E5%88%B0%E5%90%8E%E6%B6%88%E6%81%AF%E6%B8%85%E9%99%A4%EF%BC%89">（1）点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）</h4> 
<p>        消息生产者生产消息发送到消息队列中，然后消息消费者从消息队列中取出并且消费消息。消息被消费以后，消息队列中不再有存储，所以消息消费者不可能消费到已经被消费的消息。消息队列支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p> 
<p><img alt="" height="346" src="https://images2.imgbox.com/22/cc/5Bxnp9TS_o.png" width="1200"></p> 
<h4 id="%EF%BC%882%EF%BC%89%E5%8F%91%E5%B8%83%2F%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%8F%88%E5%8F%AB%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E6%95%B0%E6%8D%AE%E4%B9%8B%E5%90%8E%E4%B8%8D%E4%BC%9A%E6%B8%85%E9%99%A4%E6%B6%88%E6%81%AF%EF%BC%89">（2）发布/订阅模式（一对多，又叫观察者模式，消费者消费数据之后不会清除消息）</h4> 
<p>        消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。</p> 
<p>        发布/订阅模式是定义对象间一种一对多的依赖关系，使得每当一个对象（目标对象）的状态发生改变，则所有依赖于它的对象（观察者对象）都会得到通知并自动更新。</p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/95/96/w7EaSNLl_o.png" width="1200"></p> 
<h2 id="%E4%B8%89%E3%80%81kafka%E6%A6%82%E8%BF%B0">三、kafka概述</h2> 
<h3 id="1.Kafka%20%E5%AE%9A%E4%B9%89">1.Kafka 定义</h3> 
<p>        Kafka 是一个分布式的基于发布/订阅模式的消息队列（MQ，Message Queue），主要应用于大数据实时处理领域。</p> 
<h3 id="2.Kafka%20%E7%AE%80%E4%BB%8B">2.Kafka 简介</h3> 
<p>        Kafka 是最初由 Linkedin 公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于 Zookeeper 协调的分布式消息中间件系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景，比如基于 hadoop 的批处理系统、低延迟的实时系统\Spark/Flink 流式处理引擎，nginx 访问日志，消息服务等等，用 scala 语言编写，Linkedin 于 2010 年贡献给了 Apache 基金会并成为顶级开源项目。</p> 
<h3 id="3.Kafka%20%E7%9A%84%E7%89%B9%E6%80%A7">3.Kafka 的特性</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F%E3%80%81%E4%BD%8E%E5%BB%B6%E8%BF%9F">（1）高吞吐量、低延迟</h4> 
<p>        Kafka 每秒可以处理几十万条消息，它的延迟最低只有几毫秒。每个 topic 可以分多个 Partition，Consumer Group 对 Partition 进行消费操作，提高负载均衡能力和消费能力。</p> 
<h4 id="%EF%BC%882%EF%BC%89%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7">（2）可扩展性</h4> 
<p>        kafka 集群支持热扩展。</p> 
<h4 id="%EF%BC%883%EF%BC%89%E6%8C%81%E4%B9%85%E6%80%A7%E3%80%81%E5%8F%AF%E9%9D%A0%E6%80%A7"><strong>（3）持久性、可靠性</strong></h4> 
<p>        消息被持久化到本地磁盘，并且支持数据备份防止数据丢失。</p> 
<h4 id="%EF%BC%884%EF%BC%89%E5%AE%B9%E9%94%99%E6%80%A7">（4）容错性</h4> 
<p>        允许集群中节点失败（多副本情况下，若副本数量为 n，则允许 n-1 个节点失败）。</p> 
<h4 id="%EF%BC%885%EF%BC%89%E9%AB%98%E5%B9%B6%E5%8F%91">（5）高并发</h4> 
<p>        支持数千个客户端同时读写。</p> 
<h3 id="4.Kafka%20%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84">4.Kafka 系统架构</h3> 
<h4 id="%EF%BC%881%EF%BC%89Broker">（1）Broker</h4> 
<p>        一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。</p> 
<h4 id="%EF%BC%882%EF%BC%89Topic">（2）Topic</h4> 
<p>        可以理解为一个队列，生产者和消费者面向的都是一个 topic。类似于数据库的表名或者 ES 的 index 。物理上不同 topic 的消息分开存储。</p> 
<h4 id="%EF%BC%883%EF%BC%89Partition">（3）Partition</h4> 
<p>        为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分割为一个或多个 partition，每个 partition 是一个有序的队列。Kafka 只保证 partition 内的记录是有序的，而不保证 topic 中不同 partition 的顺序。</p> 
<p>        每个 topic 至少有一个 partition，当生产者产生数据的时候，会根据分配策略选择分区，然后将消息追加到指定的分区的队列末尾。</p> 
<p><strong>Partation 数据路由规则</strong></p> 
<ul><li>指定了 patition，则直接使用；</li><li>未指定 patition 但指定 key（相当于消息中某个属性），通过对 key 的 value 进行 hash 取模，选出一个 patition；</li><li>patition 和 key 都未指定，使用轮询选出一个 patition。</li></ul> 
<p>        每条消息都会有一个自增的编号，用于标识消息的偏移量，标识顺序从 0 开始。</p> 
<p>        每个 partition 中的数据使用多个 segment 文件存储。</p> 
<p>        如果 topic 有多个 partition，消费数据时就不能保证数据的顺序。<strong>严格保证消息的消费顺序的场景下（例如商品秒杀、 抢红包），需要将 partition 数目设为 1。</strong></p> 
<ul><li>broker 存储 topic 的数据。如果某 topic 有 N 个 partition，集群有 N 个 broker，那么每个 broker 存储该 topic 的一个 partition。</li><li>如果某 topic 有 N 个 partition，集群有 (N+M) 个 broker，那么其中有 N 个 broker 存储 topic 的一个 partition， 剩下的 M 个 broker 不存储该 topic 的 partition 数据。</li><li>如果某 topic 有 N 个 partition，集群中 broker 数目少于 N 个，那么一个 broker 存储该 topic 的一个或多个 partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致 Kafka 集群数据不均衡。</li></ul> 
<p><strong>分区的原因</strong></p> 
<ul><li>方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了；</li><li>可以提高并发，因为可以以Partition为单位读写了。</li></ul> 
<p><img alt="" height="700" src="https://images2.imgbox.com/46/cd/SFg93MON_o.png" width="1025"></p> 
<h4 id="%EF%BC%884%EF%BC%89Replica">（4）Replica</h4> 
<p>        副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。</p> 
<h4 id="%EF%BC%885%EF%BC%89Leader">（5）Leader</h4> 
<p>        每个 partition 有多个副本，其中有且仅有一个作为 Leader，Leader 是当前负责数据的读写的 partition。</p> 
<h4 id="%EF%BC%886%EF%BC%89Follower%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0">（6）Follower        </h4> 
<p>        Follower 跟随 Leader，所有写请求都通过 Leader 路由，数据变更会广播给所有 Follower，Follower 与 Leader 保持数据同步。Follower 只负责备份，不负责数据的读写。</p> 
<p>        如果 Leader 故障，则从 Follower 中选举出一个新的 Leader。</p> 
<p>        当 Follower 挂掉、卡住或者同步太慢，Leader 会把这个 Follower 从 ISR（Leader 维护的一个和 Leader 保持同步的 Follower 集合） 列表中删除，重新创建一个 Follower。</p> 
<h4 id="%EF%BC%887%EF%BC%89Producer%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0">（7）Producer        </h4> 
<p>        生产者即数据的发布者，该角色将消息 push 发布到 Kafka 的 topic 中。broker 接收到生产者发送的消息后，broker 将该消息追加到当前用于追加数据的 segment 文件中。</p> 
<p>        生产者发送的消息，存储到一个 partition 中，生产者也可以指定数据存储的 partition。</p> 
<h4 id="%EF%BC%888%EF%BC%89Consumer">（8）Consumer</h4> 
<p>        消费者可以从 broker 中 pull 拉取数据。消费者可以消费多个 topic 中的数据。</p> 
<h4 id="%EF%BC%889%EF%BC%89Consumer%20Group%EF%BC%88CG%EF%BC%89">（9）Consumer Group（CG）</h4> 
<p>        消费者组，由多个 consumer 组成。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。可为每个消费者指定组名，若不指定组名则属于默认的组。</p> 
<p>        将多个消费者集中到一起去处理某一个 Topic 的数据，可以更快的提高数据的消费能力。</p> 
<p>        消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费，防止数据被重复读取。消费者组之间互不影响。</p> 
<h4 id="%EF%BC%8810%EF%BC%89offset%20%E5%81%8F%E7%A7%BB%E9%87%8F">（10）offset 偏移量</h4> 
<p>        可以唯一的标识一条消息。偏移量决定读取数据的位置，不会有线程安全的问题，消费者通过偏移量来决定下次读取的消息（即消费位置）。</p> 
<p>        消息被消费之后，并不被马上删除，这样多个业务就可以重复使用 Kafka 的消息。</p> 
<p>        某一个业务也可以通过修改偏移量达到重新读取消息的目的，偏移量由用户控制。        </p> 
<p>        消息最终还是会被删除的，默认生命周期为 1 周（7*24小时）。</p> 
<h4 id="%EF%BC%8811%EF%BC%89Zookeeper">（11）Zookeeper</h4> 
<p>        Kafka 通过 Zookeeper 来存储集群的 meta 信息。</p> 
<p>        由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢复后继续消费。</p> 
<p>        Kafka 0.9 版本之前，consumer 默认将 offset 保存在 Zookeeper 中；从 0.9 版本开始，consumer 默认将 offset 保存在 Kafka 一个内置的 topic 中，该 topic 为 __consumer_offsets。</p> 
<p>        <strong>也就是说，zookeeper的作用就是，生产者push数据到kafka集群，就必须要找到kafka集群的节点在哪里，这些都是通过zookeeper去寻找的。消费者消费哪一条数据，也需要zookeeper的支持，从zookeeper获得offset，offset记录上一次消费的数据消费到哪里，这样就可以接着下一条数据进行消费。</strong></p> 
<p><img alt="" height="983" src="https://images2.imgbox.com/d6/c3/A821AMy8_o.png" width="1100"></p> 
<h3 id="5.kafka%E7%9A%84%E9%83%A8%E7%BD%B2">5.kafka的部署</h3> 
<p><strong>下载安装包，官方下载地址：</strong><a href="http://kafka.apache.org/downloads.html" rel="nofollow" title="Apache Kafka">Apache Kafka</a></p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/b4/4f/SYoHi3yS_o.png" width="630"></p> 
<p><strong>解压到/usr/local/kafka</strong></p> 
<pre><code class="language-bash">tar xf kafka_2.13-2.7.1.tgz
mv kafka_2.13-2.7.1 /usr/local/kafka/
</code></pre> 
<p><strong>修改服务配置文件server.properties</strong></p> 
<p><img alt="" height="510" src="https://images2.imgbox.com/14/1c/R8lNgCqY_o.png" width="1043"></p> 
<pre><code class="language-bash">vim server.properties
broker.id=0    #21行，broker的全局唯一编号，每个broker不能重复，因此要在其他机器上配置 id=1和2
listeners=PLAINTEXT://192.168.116.10:9092    ●31行，指定监听的IP和端口，如果修改每个broker的IP需区分开来，也可保持默认配置不用修改
num.network.threads=3    #42行，broker 处理网络请求的线程数量，一般情况下不需要去修改
num.io.threads=8         #45行，用来处理磁盘IO的线程数量，数值应该大于硬盘数
socket.send.buffer.bytes=102400       #48行，发送套接字的缓冲区大小
socket.receive.buffer.bytes=102400    #51行，接收套接字的缓冲区大小
socket.request.max.bytes=104857600    #54行，请求套接字的缓冲区大小
log.dirs=/usr/local/kafka/logs        #60行，kafka运行日志存放的路径，也是数据存放的路径
num.partitions=1    #65行，topic在当前broker上的默认分区个数，会被topic创建时的指定参数覆盖
num.recovery.threads.per.data.dir=1    #69行，用来恢复和清理data下数据的线程数量
log.retention.hours=168    #103行，segment文件（数据文件）保留的最长时间，单位为小时，默认为7天，超时将被删除
log.segment.bytes=1073741824    #110行，一个segment文件最大的大小，默认为 1G，超出将新建一个新的segment文件
zookeeper.connect=192.168.116.10:2181,192.168.116.20:2181,192.168.116.30:2181    #123行，配置连接Zookeeper集群地址
</code></pre> 
<p><strong>添加环境变量</strong></p> 
<pre><code class="language-bash">//修改环境变量
vim /etc/profile
export KAFKA_HOME=/usr/local/kafka
export PATH=$PATH:$KAFKA_HOME/bin</code></pre> 
<p><strong>添加kafka到系统服务</strong></p> 
<pre><code class="language-bash">vim /etc/init.d/kafka
#!/bin/bash
#chkconfig:2345 22 88
#description:Kafka Service Control Script
KAFKA_HOME='/usr/local/kafka'
case $1 in
start)
	echo "---------- Kafka 启动 ------------"
	${KAFKA_HOME}/bin/kafka-server-start.sh -daemon ${KAFKA_HOME}/config/server.properties
;;
stop)
	echo "---------- Kafka 停止 ------------"
	${KAFKA_HOME}/bin/kafka-server-stop.sh
;;
restart)
	$0 stop
	$0 start
;;
status)
	echo "---------- Kafka 状态 ------------"
	count=$(ps -ef | grep kafka | egrep -cv "grep|$$")
	if [ "$count" -eq 0 ];then
        echo "kafka is not running"
    else
        echo "kafka is running"
    fi
;;
*)
    echo "Usage: $0 {start|stop|restart|status}"
esac

#设置开机自启
chmod +x /etc/init.d/kafka
chkconfig --add kafka

#分别启动 Kafka
service kafka start</code></pre> 
<h3 id="6.kafka%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8">6.kafka命令的使用</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E5%88%9B%E5%BB%BAtopic">（1）创建topic</h4> 
<blockquote> 
 <p><strong>使用kafka-topics.sh</strong></p> 
 <p><strong>                                --create：</strong>执行创建，topic端口为<strong>2181</strong></p> 
 <p>                               <strong> --zookeeper：</strong>定义 zookeeper 集群服务器地址，如果有多个 IP 地址使用逗号分割，一般使用一个 IP 即可<br>                                <strong> --replication-factor：</strong>定义分区副本数，1 代表单副本，建议为 2 <br>                          <strong>       --partitions：</strong>定义分区数 <br>                         <strong>        --topic：</strong>定义 topic 名称</p> 
</blockquote> 
<p><img alt="" height="80" src="https://images2.imgbox.com/20/ae/6urmzvOa_o.png" width="1200"></p> 
<h4 id="%EF%BC%882%EF%BC%89%20%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89topic">（2） 列出所有topic</h4> 
<blockquote> 
 <p><strong>                                --list：</strong>列出当前所有topic</p> 
</blockquote> 
<p><img alt="" height="54" src="https://images2.imgbox.com/72/52/4nAgnItr_o.png" width="1074"></p> 
<h4 id="%EF%BC%883%EF%BC%89%E6%9F%A5%E7%9C%8Btopic%E4%BF%A1%E6%81%AF">（3）查看topic信息</h4> 
<blockquote> 
 <p><strong>                                --describe：</strong>查看topic的信息</p> 
 <p>                            <strong>    --topic：</strong>指定topic名，不指定显示所有</p> 
</blockquote> 
<p><img alt="" height="123" src="https://images2.imgbox.com/c0/37/HT0ds7K8_o.png" width="1200"></p> 
<h4 id="%EF%BC%884%EF%BC%89%20%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF">（4） 发布消息</h4> 
<blockquote> 
 <p><strong>使用 </strong><strong>kafka-console-producer.sh</strong></p> 
 <p><strong>                                                --broker-list：</strong>指定代理节点，发布端口为<strong>9092</strong></p> 
</blockquote> 
<p><img alt="" height="291" src="https://images2.imgbox.com/52/05/e3ZrtNPz_o.png" width="1139"></p> 
<h4 id="%EF%BC%885%EF%BC%89%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%C2%A0">（5）消费消息 </h4> 
<blockquote> 
 <p><strong>使用 kafka-console-consumer.sh</strong></p> 
 <p>                                              <strong>--bootstrap-server：</strong>指定消费服务器地址，消费端口也是<strong>9092</strong></p> 
 <p>                                              <strong>--from-beginning：</strong>会把主题中以往所有的数据都读取出来</p> 
</blockquote> 
<p><img alt="" height="289" src="https://images2.imgbox.com/98/2a/DLdujqFy_o.png" width="1153"></p> 
<p>但是如果实时发布和读取（即发布一条消费一条），那么顺序就能保证；还有前文提到，严格保证消息的消费顺序的场景下（例如商品秒杀、 抢红包），需要将 partitions 数目设为 1。</p> 
<h4 id="%EF%BC%886%EF%BC%89%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9Atopic%E5%88%86%E5%8C%BA%E6%95%B0">（6）修改指定topic分区数</h4> 
<blockquote> 
 <p><strong>使用kafka-topics.sh</strong></p> 
 <p><strong>                                 --alter：</strong>执行修改</p> 
</blockquote> 
<p><img alt="" height="125" src="https://images2.imgbox.com/8d/2f/KdyurXwP_o.png" width="1200"></p> 
<p><strong>注意：像上一点提到的，修改 partitions 为1，不能使用此方法，只能删除此topic然后重建，是因为修改已存在topic时，partition</strong><strong>s 的数目只允许增。例：</strong></p> 
<p><img alt="" height="219" src="https://images2.imgbox.com/89/82/hFPsFNo5_o.png" width="1200"></p> 
<h4 id="%EF%BC%887%EF%BC%89%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9Atopic">（7）删除指定topic</h4> 
<blockquote> 
 <p>                                <strong>--delete：</strong>执行删除</p> 
</blockquote> 
<p><img alt="" height="98" src="https://images2.imgbox.com/57/af/hBHxdpVr_o.png" width="1200"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e19802c26d11626aa624e47619edb59/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【最近公共祖先】 LCA 详解（倍增，trajan算法）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a9fb6852157c1359fc407bdd1b796167/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">算法题--动态规划（连续子数组的最大和、丑数、n个骰子的点数）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>