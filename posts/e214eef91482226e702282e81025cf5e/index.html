<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>递归和排序算法的应用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="递归和排序算法的应用" />
<meta property="og:description" content="一、递归常见问题和注意事项 1. 堆栈溢出；
2. 警惕重复运算：
可以使用一个数据结构（散列表）将已经计算过的f(k)保存起来，每当调用到f(k)时，先产看下是否已经求结果，从而避免重复计算。
3. 将递归代码修改为非递归代码
二、冒泡、插入、选择排序 时间复杂度都是O(n^2)；
**稳定性：**原序列中相同值得元素，经过排序后前后顺序不变；
**原地排序：**空间复杂度O(1)；
冒泡排序：每次便利剩余的全部找出剩余最小的值；
插入排序：前面是有序的，从后面序列拿出最前面的元素插入到前面有序队列中合适的位置。分为已排序空间和未排序空间；
选择排序：分为已排序空间和未排序空间，从未排序空间找出最小值放入已排序空间的末尾；
插入排序相对于冒泡排序的优势？
冒泡排序中数据的交换操作： if (a[j] &gt; a[j&#43;1]) { // 交换 int tmp = a[j]; a[j] = a[j&#43;1]; a[j&#43;1] = tmp; flag = true; } 插入排序中数据的移动操作： if (a[j] &gt; value) { a[j&#43;1] = a[j]; // 数据移动 } else { break; } 使用冒泡排序需要K次交换操作，每次交换需要3次赋值语句，所需时间为3*k，而插入排序只需要K个时间。
三、归并排序和快速排序 归并排序：先分解，再合并。将数组采用递归的思想从中间分解拆分，知道不能拆分，然后再将拆分的进行排序后合并，使用分治思想。
归并排序可以使稳定排序
// 归并排序算法, A是数组，n表示数组大小 merge_sort(A, n) { merge_sort_c(A, 0, n-1) } // 递归调用函数 merge_sort_c(A, p, r) { // 递归终止条件 if p &gt;= r then return // 取p到r之间的中间位置q q = (p&#43;r) / 2 // 分治递归 merge_sort_c(A, p, q) merge_sort_c(A, q&#43;1, r) // 将A[p." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e214eef91482226e702282e81025cf5e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-27T13:43:13+08:00" />
<meta property="article:modified_time" content="2022-11-27T13:43:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">递归和排序算法的应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一、递归常见问题和注意事项</h3> 
<p><strong>1. 堆栈溢出；</strong><br> <strong>2. 警惕重复运算：</strong><br> 可以使用一个数据结构（散列表）将已经计算过的f(k)保存起来，每当调用到f(k)时，先产看下是否已经求结果，从而避免重复计算。<br> <strong>3. 将递归代码修改为非递归代码</strong></p> 
<h3><a id="_7"></a>二、冒泡、插入、选择排序</h3> 
<p>时间复杂度都是O(n^2)；<br> **稳定性：**原序列中相同值得元素，经过排序后前后顺序不变；<br> **原地排序：**空间复杂度O(1)；</p> 
<p>冒泡排序：每次便利剩余的全部找出剩余最小的值；<br> 插入排序：前面是有序的，从后面序列拿出最前面的元素插入到前面有序队列中合适的位置。分为<strong>已排序空间</strong>和<strong>未排序空间</strong>；<br> 选择排序：分为<strong>已排序空间</strong>和<strong>未排序空间</strong>，从未排序空间找出最小值放入已排序空间的末尾；</p> 
<p><strong>插入排序相对于冒泡排序的优势？</strong></p> 
<pre><code class="prism language-c">
冒泡排序中数据的交换操作：
<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 交换</span>
   <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
   a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
   flag <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

插入排序中数据的移动操作：
<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 数据移动</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用冒泡排序需要K次交换操作，每次交换需要3次赋值语句，所需时间为3*k，而插入排序只需要K个时间。</p> 
<h3><a id="_38"></a>三、归并排序和快速排序</h3> 
<p><strong>归并排序：<strong>先分解，再合并。将数组采用递归的思想从中间分解拆分，知道不能拆分，然后再将拆分的进行排序后合并，使用</strong>分治思想</strong>。<br> 归并排序可以使<strong>稳定排序</strong><br> <img src="https://images2.imgbox.com/72/08/1lX8Klea_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c">
<span class="token comment">// 归并排序算法, A是数组，n表示数组大小</span>
<span class="token function">merge_sort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">merge_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 递归调用函数</span>
<span class="token function">merge_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 递归终止条件</span>
  <span class="token keyword">if</span> p <span class="token operator">&gt;=</span> r  then <span class="token keyword">return</span>

  <span class="token comment">// 取p到r之间的中间位置q</span>
  q <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token operator">+</span>r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
  <span class="token comment">// 分治递归</span>
  <span class="token function">merge_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
  <span class="token function">merge_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>
  <span class="token comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span>
  <span class="token function">merge</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>q<span class="token operator">+</span><span class="token number">1.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>merge()函数伪代码，merge()函数可以借用<strong>哨兵</strong>编程简化。</p> 
<pre><code class="prism language-c">
<span class="token function">merge</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>q<span class="token operator">+</span><span class="token number">1.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  var i <span class="token operator">:</span><span class="token operator">=</span> p，j <span class="token operator">:</span><span class="token operator">=</span> q<span class="token operator">+</span><span class="token number">1</span>，k <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 初始化变量i, j, k</span>
  var tmp <span class="token operator">:</span><span class="token operator">=</span> new array<span class="token punctuation">[</span><span class="token number">0.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token operator">-</span>p<span class="token punctuation">]</span> <span class="token comment">// 申请一个大小跟A[p...r]一样的临时数组</span>
  <span class="token keyword">while</span> i<span class="token operator">&lt;=</span>q AND j<span class="token operator">&lt;=</span>r <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span>
      tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token comment">// i++等于i:=i+1</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 判断哪个子数组中有剩余的数据</span>
  var start <span class="token operator">:</span><span class="token operator">=</span> i，end <span class="token operator">:</span><span class="token operator">=</span> q
  <span class="token keyword">if</span> j<span class="token operator">&lt;=</span>r then start <span class="token operator">:</span><span class="token operator">=</span> j<span class="token punctuation">,</span> end<span class="token operator">:</span><span class="token operator">=</span>r
  
  <span class="token comment">// 将剩余的数据拷贝到临时数组tmp</span>
  <span class="token keyword">while</span> start <span class="token operator">&lt;=</span> end <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
    tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>start<span class="token operator">++</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 将tmp中的数组拷贝回A[p...r]</span>
  <span class="token keyword">for</span> i<span class="token operator">:</span><span class="token operator">=</span><span class="token number">0</span> to r<span class="token operator">-</span>p <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
    A<span class="token punctuation">[</span>p<span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在merge()合并函数需要临时空间，所以空间复杂度为O(n)。</p> 
<p><strong>快速排序：</strong><br> 快速排序是由上到下处理问题，利用原地分区，所以空间复杂度是O(1)，不是稳定的排序算法。快速排序重点是选择合适的pivot，否可有可能导致时间复杂度退化到O(n^2)<br> <img src="https://images2.imgbox.com/54/9c/1AorXiCk_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c">
<span class="token comment">// 快速排序，A是数组，n表示数组的大小</span>
<span class="token function">quick_sort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">quick_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 快速排序递归函数，p,r为下标</span>
<span class="token function">quick_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> p <span class="token operator">&gt;=</span> r then <span class="token keyword">return</span>
  
  q <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token comment">// 获取分区点</span>
  <span class="token function">quick_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token function">quick_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>partition()分区函数函数</p> 
<pre><code class="prism language-c">
<span class="token function">partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  pivot <span class="token operator">:</span><span class="token operator">=</span> A<span class="token punctuation">[</span>r<span class="token punctuation">]</span>
  i <span class="token operator">:</span><span class="token operator">=</span> p
  <span class="token keyword">for</span> j <span class="token operator">:</span><span class="token operator">=</span> p to r<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot <span class="token punctuation">{<!-- --></span>
      swap A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> with A<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
      i <span class="token operator">:</span><span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  swap A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> with A<span class="token punctuation">[</span>r<span class="token punctuation">]</span>
  <span class="token keyword">return</span> i

</code></pre> 
<h3><a id="_133"></a>四、排序的思考问题</h3> 
<p><strong>1、现在有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？</strong></p> 
<p>最大时间戳的最小值这一点很关键 保证了当前取出来的数据是未排序种全局最小的。<br> 批量读取文件。<br> 分阶段的快速排序。</p> 
<p>先取得十个文件时间戳的最小值数组的最小值a，和最大值数组的最大值b。然后取mid=(a+b)/2，然后把每个文件按照mid分割，取所有前面部分之和，如果小于1g就可以读入内存快排生成中间文件，否则继续取时间戳的中间值分割文件，直到区间内文件之和小于1g。同理对所有区间都做同样处理。最终把生成的中间文件按照分割的时间区间的次序直接连起来即可。类似桶排序。</p> 
<p><strong>2、如何在O(n)时间复杂内查找无序数组第K大的元素？</strong><br> 利用快速排序的思想，数组下标和K进行比较。</p> 
<p><strong>3、如何根据年龄对100万用户进行排序？</strong><br> 利用桶排序。</p> 
<h3><a id="On_148"></a>五、空间复杂度为O(n)排序，桶排序、计数排序、基数排序</h3> 
<p><strong>1、桶排序（Bucket sort）</strong><br> <img src="https://images2.imgbox.com/b3/b7/IhVWRor4_o.png" alt="在这里插入图片描述"><br> 适用于在外部排序，数据存储在磁盘中，数据量比较大，内存有限，无法将全部数据加载到内存进行排序。<br> 重点是如何将数据均匀的划分到每个桶里面。</p> 
<p><strong>2、计数排序（Counting sort）</strong><br> 桶排序的特殊情况，当数据的范围较小时，例如高考成绩排序，有一组数据2，5，3，0，2，3，0，3，使用大小为6的桶C[6]：<br> <img src="https://images2.imgbox.com/f3/d3/iyzeUnCg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a0/03/pH5CwEIV_o.png" alt="在这里插入图片描述"><br> <strong>3、基数排序（radix sort）</strong><br> 例如对十万个电话号码进行排序，借助与稳定的排序，从高位向低位开始进行排序，排序11次即可。但是有时候要排序的数据长度不是等长的，可以对位数不够的在后面补0。<br> 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，且位之间有递进的关系，如果数据a的高位比数据b高位大，那剩下的就不用比较了。</p> 
<h3><a id="_162"></a>六、如何实现一个通用、高效的排序算法？</h3> 
<p>快速排序如何优化：主要是找到合适的分区点，为了避免极端情况，可以采用<strong>三数取中，随机法</strong></p> 
<h3><a id="_165"></a>七、二分法</h3> 
<p><strong>如何快速的定位出IP对应的省份地址？</strong><br> 如果IP和归属地的关系不经常更新，可以先按照IP大小关系进行排序，查找时根据二分法进行查找。</p> 
<p><strong>有重复值的有序序列中查找一地个大于某值的元素？</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94bbd7ba431903cbf96cf03e82a61c22/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">socket学习一、socket、bind/connect、listen函数详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5693546ed7e321b0d8cf7fccbcdbf4b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">排序算法简述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>