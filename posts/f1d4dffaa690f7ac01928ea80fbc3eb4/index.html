<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>记录--npm, npx, cnpm, yarn, pnpm梭哈 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="记录--npm, npx, cnpm, yarn, pnpm梭哈" />
<meta property="og:description" content="这里给大家分享我在网上总结出来的一些知识，希望对大家有所帮助 依赖管理解决了在软件开发过程中管理和协调各种依赖项的问题，简化了开发流程，提高了项目的可靠性、可维护性和可重复性。它们帮助开发人员更高效地管理项目的依赖关系，减少了潜在的错误和冲突，并提供了更好的开发体验。
常用的依赖管理 在 JavaScript 生态系统中，有多种工具可用于管理项目的依赖项。
npm(Node Package Manager)：npm 是 Node.js 官方提供的包管理器，用于安装、管理和发布 JavaScript 包。它是 Node.js 安装时默认包含的工具。通过 npm install 命令可以安装项目依赖。 npm install package-name pnpm：pnpm 是一个快速、磁盘空间效率高的包管理器。与 npm 不同，pnpm 采用了符号链接的方式共享依赖项，因此在项目之间共享依赖时可以节省磁盘空间。pnpm 的命令与 npm 类似。 pnpm install package-name yarn：yarn 是由 Facebook 开发的另一个包管理器，旨在提供更快、更可靠的依赖管理。它具有与 npm 类似的功能，但执行速度更快，并且具有一些额外的功能，例如离线模式和锁定文件。与 npm 不同，yarn 使用 yarn add 命令来安装依赖。 yarn add package-name npx：npx 是 npm 5.2.0 版本及以上内置的命令行工具，用于执行项目安装的依赖项中的可执行文件。它可以临时安装依赖项并运行其中的命令，而无需全局安装。 npx command-name cnpm：cnpm 是淘宝镜像提供的 npm 的镜像版本，用于加速国内用户对 npm 包的安装和下载速度。它是通过将 npm 的源地址配置为淘宝的源地址来实现的。与 npm 相比，使用 cnpm 可以更快地安装依赖项。 常用依赖管理的对比 准确地说，npx 并不是一个专门的依赖管理工具，而是 npm 附带的一个命令行工具，用于临时执行项目依赖中的可执行文件，而无需全局安装。以下对其它常用依赖管理工具的对比，npx在后续小节会提到期妙用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f1d4dffaa690f7ac01928ea80fbc3eb4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T17:57:00+08:00" />
<meta property="article:modified_time" content="2024-01-22T17:57:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">记录--npm, npx, cnpm, yarn, pnpm梭哈</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html" style="font-size: 16px;"> 
 <h4><span class="ne-text" style="font-weight: bold;">这里给大家分享我在网上总结出来的一些知识，希望对大家有所帮助</span></h4> 
 <h4><span class="ne-text" style="font-weight: bold;"><a href="https://img2020.cnblogs.com/blog/2149129/202107/2149129-20210719135854680-672185839.jpg" rel="noopener"> 
    <div style="text-align: center;"> 
     <img src="https://images2.imgbox.com/20/d7/YXFVsXvJ_o.jpg" width="135" height="252" style="outline: none;"> 
    </div></a></span></h4> 
 <div> 
  <div> 
   <p>依赖管理解决了在软件开发过程中管理和协调各种依赖项的问题，简化了开发流程，提高了项目的可靠性、可维护性和可重复性。它们帮助开发人员更高效地管理项目的依赖关系，减少了潜在的错误和冲突，并提供了更好的开发体验。</p> 
   <hr> 
   <h4>常用的依赖管理</h4> 
   <p>在 JavaScript 生态系统中，有多种工具可用于管理项目的依赖项。</p> 
   <ol><li><strong>npm</strong>(Node Package Manager)：npm 是 Node.js 官方提供的包管理器，用于安装、管理和发布 JavaScript 包。它是 Node.js 安装时默认包含的工具。通过 <code>npm install</code> 命令可以安装项目依赖。</li></ol> 
  </div> 
  <div class="cnblogs_Highlighter"> 
   <pre><code class="has">npm install package-name</code>
</pre> 
  </div> 
  <ol start="2"><li><strong>pnpm</strong>：pnpm 是一个快速、磁盘空间效率高的包管理器。与 npm 不同，pnpm 采用了符号链接的方式共享依赖项，因此在项目之间共享依赖时可以节省磁盘空间。pnpm 的命令与 npm 类似。</li></ol> 
  <div class="cnblogs_Highlighter"> 
   <pre><code class="has">pnpm install package-name</code>
</pre> 
  </div> 
  <div> 
   <ol start="3"><li><strong>yarn</strong>：yarn 是由 Facebook 开发的另一个包管理器，旨在提供更快、更可靠的依赖管理。它具有与 npm 类似的功能，但执行速度更快，并且具有一些额外的功能，例如离线模式和锁定文件。与 npm 不同，yarn 使用 <code>yarn add</code> 命令来安装依赖。</li></ol> 
   <div class="cnblogs_Highlighter"> 
    <pre><code class="has">yarn add package-name</code>
</pre> 
   </div> 
  </div> 
  <ol start="4"><li>npx：npx 是 npm 5.2.0 版本及以上内置的命令行工具，用于执行项目安装的依赖项中的可执行文件。它可以临时安装依赖项并运行其中的命令，而无需全局安装。</li></ol> 
  <div class="cnblogs_Highlighter"> 
   <pre><code class="has">npx command-name</code>
</pre> 
  </div> 
  <ol start="5"><li>cnpm：cnpm 是淘宝镜像提供的 npm 的镜像版本，用于加速国内用户对 npm 包的安装和下载速度。它是通过将 npm 的源地址配置为淘宝的源地址来实现的。与 npm 相比，使用 cnpm 可以更快地安装依赖项。</li></ol> 
  <div> 
   <div> 
    <h4>常用依赖管理的对比</h4> 
    <p>准确地说，npx 并不是一个专门的依赖管理工具，而是 npm 附带的一个命令行工具，用于临时执行项目依赖中的可执行文件，而无需全局安装。以下对其它常用依赖管理工具的对比，npx在后续小节会提到期妙用。</p> 
    <table><thead><tr><th>优势</th><th>pnpm</th><th>npm</th><th>cnpm</th><th>Yarn</th></tr></thead><tbody><tr><td>性能</td><td>- 采用硬链接来共享依赖项，减少磁盘空间占用和安装时间</td><td>- 单线程安装和构建依赖项</td><td>- 采用并行安装模式，速度较快</td><td>- 并行安装和构建依赖项，速度较快</td></tr><tr><td> </td><td>- 并行安装和构建依赖项，提高安装速度</td><td> </td><td> </td><td> </td></tr><tr><td> </td><td>- 增量安装依赖项，只安装更新的部分</td><td> </td><td> </td><td> </td></tr><tr><td> </td><td>- 本地缓存和离线安装支持</td><td> </td><td> </td><td> </td></tr><tr><td>效率</td><td>- 快速的重复安装速度</td><td>- 较慢的重复安装速度</td><td>- 较快的重复安装速度</td><td>- 快速的重复安装速度</td></tr><tr><td> </td><td>- 较小的网络传输量</td><td> </td><td> </td><td> </td></tr><tr><td>依赖大小</td><td>- 仅保存每个包的单个实例</td><td>- 需要保存每个包的多个实例，占用较大的磁盘空间</td><td>- 仅保存每个包的单个实例，占用较小的磁盘空间</td><td>- 仅保存每个包的单个实例，占用较小的磁盘空间</td></tr><tr><td>锁定文件机制</td><td>使用 pnpm-lock.yaml</td><td>使用 package-lock.json</td><td>使用 package-lock.json</td><td>使用 yarn.lock</td></tr><tr><td>生态系统支持</td><td>- 生态系统相对较小，但兼容 npm 生态系统</td><td>- 庞大的生态系统和广泛的社区支持</td><td>- 生态系统相对较小，可能有一些包不完全支持</td><td>- 庞大的生态系统和广泛的社区支持</td></tr><tr><td> </td><td> </td><td> </td><td> </td><td> </td></tr><tr><td>社区支持与更新频率</td><td>- 社区相对较小，更新频率较低</td><td>- 庞大的社区支持和活跃的更新频率</td><td>- 社区相对较小，更新频率较低</td><td>- 庞大的社区支持和活跃的更新频率</td></tr></tbody></table> 
    <h5>软链接与硬链接</h5> 
    <p>在依赖管理工具中，常见的使用软链接和硬链接的方式有以下情况：</p> 
    <ol><li> <p>符号链接(Symbolic Link)或软链接(Soft Link)：</p> 
      <ul><li>npm：npm使用符号链接来创建软链接。当使用<code>npm link</code>命令时，它会创建一个全局软链接，将全局安装的模块链接到当前项目中，从而实现模块的共享和开发环境的快速调试。</li><li>Yarn：Yarn也使用符号链接来创建软链接。类似于<code>npm link</code>，Yarn通过<code>yarn link</code>命令创建一个全局软链接，将全局安装的模块链接到当前项目中。</li></ul> </li><li> <p>硬链接(Hard Link)：</p> 
      <ul><li>pnpm：pnpm使用硬链接来共享已安装的依赖项。当安装依赖项时，pnpm会在项目之间创建硬链接，这样相同的依赖项可以被多个项目共享，减少了磁盘空间占用和安装时间。</li></ul> </li></ol> 
    <p>需要注意的是，符号链接(Symbolic Link)是一种创建链接的方式，它创建了一个文件或目录的指向目标的链接。而软链接(Soft Link)是符号链接的一种特殊类型，用于指向文件或目录。硬链接(Hard Link)创建了一个新的文件名，直接在文件系统中指向同一个索引节点和数据。</p> 
    <h5>软硬链接的适用场景</h5> 
    <p>软链接和硬链接各有其适用的情况，没有绝对的好与坏。它们的选择取决于具体的使用场景和需求。</p> 
    <h6>软链接的优点</h6> 
    <ol><li>跨文件系统：软链接可以跨越不同的文件系统，可以指向其他分区或磁盘上的文件或目录。</li><li>可读性：软链接是可读的，可以通过查看链接文件获取目标文件或目录的路径信息。</li><li>灵活性：软链接可以指向文件和目录，可以创建循环链接(即链接的链条形成闭环)，可以链接到不存在的目标，可以链接到目录的特定子目录。</li></ol> 
    <h6>硬链接的优点</h6> 
    <ol><li>空间效率：硬链接不会额外占用磁盘空间，多个链接共享相同的数据和索引节点，节省存储空间。</li><li>性能：由于硬链接直接指向同一索引节点，访问硬链接文件的速度与访问目标文件相同，不需要额外的解析步骤。</li><li>指向目录：硬链接可以指向目录，而软链接无法直接指向目录。</li></ol> 
    <p><strong>根据具体的使用情况，可以选择合适的链接类型。一般来说：</strong></p> 
    <ul><li>如果需要跨越文件系统或者需要链接到目录，可以选择软链接。</li><li>如果注重空间效率和性能，并且在同一文件系统内进行链接，可以选择硬链接。</li></ul> 
    <p>对于pnpm来说，当一个项目使用pnpm安装依赖项时，pnpm会将这些依赖项安装到一个称为<code>node_modules/.pnpm</code>的目录中。其他项目可以通过创建硬链接来使用这个已安装的依赖项，而无需在各自项目的<code>node_modules</code>目录中重复安装。</p> 
    <p>这种共享依赖项的机制使得多个项目可以共享相同的依赖项，但每个项目仍然需要维护自己的<code>package.json</code>文件和项目特定的配置。这样，每个项目可以独立地管理自己的开发和构建过程，而共享的依赖项保持一致，减少了重复的依赖项下载和存储消耗。这是pnpm的一项优势，可以提高项目的构建速度和整体效率。</p> 
    <h4>npx的妙用</h4> 
    <p>npx 是一个非常有用的命令行工具，特别适用于以下几种场景：</p> 
    <ol><li><strong>临时执行项目依赖的可执行文件：</strong> 有时候你可能需要在命令行中临时执行某个项目依赖的可执行文件，而不想全局安装这个工具。npx 可以帮助你在不污染全局环境的情况下直接运行这些可执行文件。</li></ol> 
   </div> 
   <div class="cnblogs_Highlighter"> 
    <pre><code class="has">npx eslint index.js</code>
</pre> 
   </div> 
   <div> 
    <p>上述示例中，我们使用 npx 来运行项目依赖中的 eslint 工具，对 <code>index.js</code> 文件进行代码检查，而无需事先全局安装 eslint。</p> 
    <ol start="2"><li><strong>执行最新版本的工具：</strong> npx 可以确保你运行的是最新版本的工具。当你使用全局安装的工具时，可能会受限于旧版本，而 npx 可以自动下载和使用最新版本。</li></ol> 
    <div class="cnblogs_Highlighter"> 
     <pre><code class="has">npx create-react-app my-app</code>
</pre> 
    </div> 
   </div> 
   <div> 
    <div> 
     <p>在上述示例中，我们使用 npx 创建一个新的 React 应用程序，npx 会自动下载最新版本的 create-react-app 工具并使用它来初始化项目。</p> 
     <ol start="3"><li><strong>尝试新的工具和库：</strong> 当你想尝试一个新的工具或库时，不必将其全局安装，只需使用 npx 运行它。这样可以节省磁盘空间，并且你可以快速尝试新工具而无需担心与现有环境冲突。</li></ol> 
    </div> 
    <div class="cnblogs_Highlighter"> 
     <pre><code class="has">npx next init my-app</code>
</pre> 
    </div> 
    <p>在上述示例中，我们使用 npx 初始化一个新的 Next.js 应用程序，而不必预先全局安装 Next.js。</p> 
    <ol start="4"><li>运行一次性命令： 当你只需要运行一次性的命令时，npx 是一个很好的选择。你可以直接在命令行中指定要运行的命令，而无需创建额外的脚本文件。</li></ol> 
    <div class="cnblogs_Highlighter"> 
     <pre><code class="has">npx http-server</code>
</pre> 
    </div> 
    <div> 
     <div> 
      <p>在上述示例中，我们使用 npx 启动一个简单的 HTTP 服务器，而不必事先编写启动脚本。</p> 
      <p>总之，npx 是一个非常方便的工具，适用于在命令行中临时执行项目依赖的可执行文件、运行最新版本的工具、尝试新的工具和库，以及运行一次性命令等场景。</p> 
      <h5>npx的执行机制</h5> 
      <p>当你使用 npx 执行可执行文件时，npx 会首先检查本地是否已经存在该可执行文件。如果本地已经安装了这个可执行文件(位于项目的 <code>node_modules/.bin</code> 目录中)，npx 会直接运行它，而无需下载。</p> 
      <p>如果本地不存在该可执行文件，npx 会自动下载对应的包，并将其安装在一个临时目录中，然后执行该可执行文件。这意味着 npx 会在需要时临时下载所需的包，而不会将其全局安装或污染项目的依赖。</p> 
      <p>临时下载的包会被存储在一个缓存目录中，以便下次使用相同的包时可以快速加载。默认情况下，npx 使用 npm 的缓存目录作为临时下载的包的存储位置。</p> 
      <p>在执行完可执行文件后，npx 会自动删除临时下载的包，以节省磁盘空间。这意味着每次使用 npx 执行可执行文件时，它都会检查本地是否存在该包，如果不存在则临时下载，执行完后再删除。</p> 
      <p>总之，npx 会检查本地是否已经安装了要执行的可执行文件，如果没有，则会临时下载并执行它，执行完毕后再删除临时下载的包。这样可以确保你在运行命令时使用的是最新版本的工具，同时避免全局安装或污染项目的依赖。</p> 
     </div> 
     <h4 id="tid-A8dYk6"><span class="ne-text" style="font-weight: bold;">本文转载于:</span></h4> 
     <h4 id="tid-SwZPdd">https://juejin.cn/post/7326268908984352777</h4> 
     <h4 id="tid-D8HBxE">如果对您有所帮助，欢迎您点个关注，我会定时更新技术文档，大家一起讨论学习，一起进步。</h4> 
     <p> <a href="https://img2020.cnblogs.com/blog/2149129/202107/2149129-20210719144042684-15122820.jpg" rel="noopener"></a></p> 
     <div style="text-align: center;"> 
      <a href="https://img2020.cnblogs.com/blog/2149129/202107/2149129-20210719144042684-15122820.jpg" rel="noopener"><img src="https://images2.imgbox.com/bf/4e/7darEYPh_o.jpg" width="212" height="209" style="outline: none;"></a> 
     </div> 
     <p></p> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a642a89b2bd78180ff5ae88a77367175/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL 索引优化：深入探索自适应哈希索引的奥秘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/238f68b2964927775d6d2c95a400be0d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度学习技术栈 —— 用Pytorch搭建神经网络识别数字(Kaggle实战)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>