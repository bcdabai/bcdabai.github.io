<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Node(Next.js)&#43;node-xlsx开发导出excel功能 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Node(Next.js)&#43;node-xlsx开发导出excel功能" />
<meta property="og:description" content="项目中的功能：通过点击【导出】按钮，将列表的数据转成excel文件导出。这个功能有多种处理方法，我这边分为Node(后端)&#43;前端联合处理、纯Node(后端)处理
一、Node&#43;前端
在Node层直接将数据处理成前端生成excel文件时需要的数据格式，然后将生成excel文件的方法封装（exportXlsx）之后，调用node层的接口获取数据之后直接传给exportXlsx
const xlsx = require(&#39;node-xlsx&#39;); //exportXlsx方法 function exportXlsx(worksheets, fileName = &#39;测试&#39;) { const result = xlsx.build(worksheets); const ab = Buffer.from(result, &#39;binary&#39;); const blob = new Blob([ab]); const blobUrl = URL.createObjectURL(blob); const a = document.createElement(&#39;a&#39;); a.href = blobUrl; a.download = fileName; a.click(); window.URL.revokeObjectURL(blobUrl); } 注意：worksheets的数据格式：[{ name: &#39;Sheet1&#39;, data:[[&#39;表头1&#39;，&#39;表头2&#39;，&#39;表头3&#39;],[&#39;第1行第1列内容&#39;，&#39;第1行第2列内容&#39;,&#39;第1行第3列内容&#39;]] }] 二、纯Node端
直接在node层将文件流传输给客户端，这种处理方式也有两种方法
1、一种是使用node-xlsx创建了一个excel文件，然后将其保存到本地，最后将其发送给前端。
这种方法因为使用fs.createReadStream()是读取本地文件流的，因此需要将excel文件保存到本地，并将其作为流传输到客户端，会造成磁盘空间的浪费和读写磁盘的开销，因此不推荐，了解即可。
import fs from &#39;fs&#39;; import path from &#39;path&#39;; import xlsx from &#39;node-xlsx&#39;; export default (req, res) =&gt; { // 创建一个excel文件 const data = [ [&#39;姓名&#39;, &#39;年龄&#39;, &#39;性别&#39;], [&#39;张三&#39;, 18, &#39;男&#39;], [&#39;李四&#39;, 20, &#39;女&#39;], [&#39;王五&#39;, 22, &#39;男&#39;], ]; const buffer = xlsx." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2dd6dd973776bb8d9e0e9371107a0d8b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-05T22:40:17+08:00" />
<meta property="article:modified_time" content="2023-03-05T22:40:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Node(Next.js)&#43;node-xlsx开发导出excel功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>项目中的功能：通过点击【导出】按钮，将列表的数据转成excel文件导出。这个功能有多种处理方法，我这边分为Node(后端)+前端联合处理、纯Node(后端)处理</p> 
<p>一、Node+前端</p> 
<p>在Node层直接将数据处理成前端生成excel文件时需要的数据格式，然后将生成excel文件的方法封装（exportXlsx）之后，调用node层的接口获取数据之后直接传给exportXlsx</p> 
<pre><code class="language-javascript">const xlsx = require('node-xlsx');

//exportXlsx方法
function exportXlsx(worksheets, fileName = '测试') {
  const result = xlsx.build(worksheets);
  const ab = Buffer.from(result, 'binary');
  const blob = new Blob([ab]);
  const blobUrl = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = blobUrl;
  a.download = fileName;
  a.click();
  window.URL.revokeObjectURL(blobUrl);
}

注意：worksheets的数据格式：[{ name: 'Sheet1', data:[['表头1'，'表头2'，'表头3'],['第1行第1列内容'，'第1行第2列内容','第1行第3列内容']] }]
</code></pre> 
<p>二、纯Node端</p> 
<p>直接在node层将文件流传输给客户端，这种处理方式也有两种方法</p> 
<p>1、一种是使用<code>node-xlsx</code>创建了一个excel文件，然后将其保存到本地，最后将其发送给前端。</p> 
<p>这种方法因为使用<code>fs.createReadStream()是读取本地文件流的，因此</code>需要将excel文件保存到本地，并将其作为流传输到客户端，会造成磁盘空间的浪费和读写磁盘的开销，因此不推荐，了解即可。</p> 
<pre><code class="language-javascript">import fs from 'fs';
import path from 'path';
import xlsx from 'node-xlsx';

export default (req, res) =&gt; {
  // 创建一个excel文件
  const data = [
    ['姓名', '年龄', '性别'],
    ['张三', 18, '男'],
    ['李四', 20, '女'],
    ['王五', 22, '男'],
  ];
  const buffer = xlsx.build([{ name: 'Sheet1', data: data }]);

  // 将excel文件保存到本地
  const filePath = path.join(__dirname, 'example.xlsx');
  fs.writeFile(filePath, buffer, (err) =&gt; {
    if (err) {
      console.log(err);
      return res.status(500).send('导出失败');
    }
    // 将excel文件发送给前端
    res.setHeader('Content-disposition', 'attachment; filename=example.xlsx');
    res.setHeader('Content-type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    const filestream = fs.createReadStream(filePath);
    filestream.pipe(res);
  });
};
</code></pre> 
<p>2、另一种是使用stream.PassThrough用来创建一个简单的流传递器，即把输入数据原封不动地传递到输出中，不做任何处理。这个方法使用<code>new stream.PassThrough()</code> 是创建一个 <code>PassThrough</code> 流对象，然后将该对象作为参数传递给 <code>xlsx.build()</code> 方法，将 Excel 数据写入这个可写流中，以生成二进制数据。该方法不需要将文件写入磁盘，而是直接将二进制流数据通过内存中的流来传输，因此可以避免磁盘空间的浪费和读写磁盘的开销。一般推荐。</p> 
<pre><code class="language-javascript">//  /api/exportExcel.ts

import xlsx from 'node-xlsx';
import stream from 'stream'

export default (req, res) =&gt; {
  // 创建一个excel文件
  const data = [
    ['姓名', '年龄', '性别'],
    ['张三', 18, '男'],
    ['李四', 20, '女'],
    ['王五', 22, '男'],
  ];
  const buffer = xlsx.build([{ name: 'Sheet1', data: data }]);

  // 将excel文件发送给前端
  res.setHeader('Content-disposition', 'attachment; filename=example.xlsx');
  res.setHeader('Content-type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
  const filestream = new stream.PassThrough();
  filestream.end(buffer);
  filestream.pipe(res);
};
</code></pre> 
<p>3、还有一种更简单的方法是直接使用 <code>node-xlsx</code> 提供的 <code>build</code> 方法生成 Excel 文件的二进制流数据，然后通过 <code>res.end()</code> 方法将该二进制流数据返回给客户端（推荐）</p> 
<pre><code class="language-javascript">import { build } from 'node-xlsx';

export default function handler(req, res) {
  // 创建 Excel 数据
  const data = [
    ['姓名', '年龄', '性别'],
    ['张三', 18, '男'],
    ['李四', 20, '女'],
    ['王五', 22, '男'],
  ];

  // 构造一个 Excel 文件对象
  const excelFile = [
    {
      name: 'sheet1',
      data: data,
    },
  ];

  // 生成 Excel 文件的二进制流数据
  const buffer = build(excelFile);

  // 设置响应头
  res.setHeader(
    'Content-Type',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
  );
  res.setHeader('Content-Disposition', 'attachment; filename=test.xlsx');

  // 将 Excel 文件的二进制流数据返回给客户端
  res.end(buffer, 'binary');
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae4bd40b7129e47a33235d5a75524487/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VS&#43;Qt — Vistual Studio 2022&#43;Qt6安装教程以及解决Qt Vistual Studio Tools下载慢和VS无法打开.ui进行设计的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d1e054e8b04634365ebbba8316e6bb04/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【机器学习】二分类&#43;多分类LDA线性判别分析降维算法的原理与推导</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>