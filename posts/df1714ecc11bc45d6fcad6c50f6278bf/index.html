<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity&amp;&amp;C#学习笔记-拆装箱,List,浅深拷贝,equals和== - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity&amp;&amp;C#学习笔记-拆装箱,List,浅深拷贝,equals和==" />
<meta property="og:description" content="拆箱和装箱 例:Integer是一个封装类，用于表示整数。它是int的封装类，可以将int类型的数据转换为Integer类型的数据。Integer类提供了许多操作整数的方法，使得整数的操作更加方便和灵活。
int是基本数据类型，而Integer是int的封装类。
int类型的数据直接存储在内存中的栈中，而Integer类型的数据则存储在堆中的对象中。
装箱：
对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。按三步进行。
1：首先从托管堆中为新生成的引用对象分配内存(大小为值类型实例大小加上一个方法表指针和一个SyncBlockIndex)。
2：然后将值类型的数据拷贝到刚刚分配的内存中。
3：返回托管堆中新分配对象的地址。这个地址就是一个指向对象的引用了。
可以看出，进行一次装箱要进行分配内存和拷贝数据这两项比较影响性能的操作。
拆箱：
1、首先获取托管堆中属于值类型那部分字段的地址，这一步是严格意义上的拆箱。
2、将地址的值拷贝到位于线程堆栈上的值类型实例中。
装箱比较耗费性能
ArrayList和List之间的区别以及相互转换方法 ArrayList:需要先将类型转变为Object,再将Object转换为其所对应的类型。有个先装箱，再拆箱的过程。
List:泛型中指定了类型，其不需要进行装箱拆箱，效率也就相对提升。
List和ArrayList的区别 1.list性能较高,ArrayList性能较低
2.list一次存储中只能存储泛型中的类型,ArrayList在一次存储中任何类型的数据
3.List中获取值取出的是泛型中发的类型,因为ArrayList对元素没有限制,系统会将中获取的值当object类型的数据
4.List属于泛型集合 ArrayList属于非泛型集合
如果想获取到其中的内容需要进行
List在使用时候需要导入的using指令为using System.Collections.Generic;
ArrayList在使用的时候需要导入的using指令为using System.Collections;
浅拷贝和深拷贝 浅拷贝： 仅仅把对象的引用进行拷贝，但是拷贝对象和源对象还是引用同一份实体。此时，其中一个的成员对象的改变都会影响到另一个的成员对象。
深拷贝：指的是拷贝一个对象时，不仅仅把对象的引用进行拷贝，还把该对象引用的值也一起拷贝。这样进行深拷贝后的副本对象就和源对象互相独立，其中任何一个的成员对象改动都不会对另外一个成员对象造成影响。
都发生了改变,浅拷贝
//a.CopyTo(b, 1);//就是把b中的值拷贝给aArray，实现深拷贝。
b长度要大于a//index含义是b开始存储拷贝数据的下标
深拷贝
equals和== 对于值类型
在C#中对于值类型的比较不管是用【==】还是【equals】都是对于其内容的比较，也就是说对于其值的比较，相等则返回true 不相等则返回false；
对于引用类型
对于除string类型以外的引用类型
【==】比较的是在对象在栈上的引用是否相同而【equals】则比较的是对象在堆上的内容是否相同
对于字符串类型
//常量字符串
string x = &#34;should it matter&#34;; //指向同一个地址，即所谓的常量池
string y = &#34;should it matter&#34;;
object c = x;
object d = y;
Console.WriteLine(c == d);//输出True" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/df1714ecc11bc45d6fcad6c50f6278bf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-23T10:39:50+08:00" />
<meta property="article:modified_time" content="2023-11-23T10:39:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity&amp;&amp;C#学习笔记-拆装箱,List,浅深拷贝,equals和==</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>拆箱和装箱</h2> 
<p><strong>例:</strong>Integer是一个封装类，用于表示整数。它是int的封装类，可以将int类型的数据转换为Integer类型的数据。Integer类提供了许多操作整数的方法，使得整数的操作更加方便和灵活。<br> int是基本数据类型，而Integer是int的封装类。</p> 
<p><span style="color:#fe2c24;">int类型的数据直接存储在内存中的栈中，而Integer类型的数据则存储在堆中的对象中。</span><br><strong>装箱：</strong><br> 对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。按三步进行。<br> 1：首先从托管堆中为新生成的引用对象分配内存(大小为值类型实例大小加上一个方法表指针和一个SyncBlockIndex)。<br> 2：然后将值类型的数据拷贝到刚刚分配的内存中。<br> 3：返回托管堆中新分配对象的地址。这个地址就是一个指向对象的引用了。<br><strong>可以看出，进行一次装箱要进行分配内存和拷贝数据这两项比较影响性能的操作。</strong><br><strong>拆箱：</strong><br> 1、首先获取托管堆中属于值类型那部分字段的地址，这一步是严格意义上的拆箱。<br> 2、将地址的值拷贝到位于线程堆栈上的值类型实例中。</p> 
<p>装箱比较耗费性能</p> 
<h2><strong>ArrayList和List之间的区别以及相互转换方法</strong></h2> 
<p></p> 
<p>ArrayList:需要先将类型转变为Object,再将Object转换为其所对应的类型。有个先装箱，再拆箱的过程。</p> 
<p>List:<a href="https://so.csdn.net/so/search?q=%E6%B3%9B%E5%9E%8B&amp;spm=1001.2101.3001.7020" title="泛型">泛型</a>中指定了类型，其不需要进行装箱拆箱，效率也就相对提升。</p> 
<h5>List和<a href="https://so.csdn.net/so/search?q=ArrayList&amp;spm=1001.2101.3001.7020" title="ArrayList">ArrayList</a>的区别</h5> 
<p><br> 1.list性能较高,ArrayList性能较低<br> 2.list一次存储中只能存储泛型中的类型,ArrayList在一次存储中任何类型的数据<br> 3.List中获取值取出的是泛型中发的类型,因为ArrayList对元素没有限制,系统会将中获取的值当object类型的数据</p> 
<p>4.List属于泛型集合 ArrayList属于非泛型集合<br> 如果想获取到其中的内容需要进行<br><span style="color:#fe2c24;"> List在使用时候需要导入的using指令为using System.Collections.Generic;<br>  ArrayList在使用的时候需要导入的using指令为using System.Collections;</span></p> 
<h2><span style="color:#333333;"><strong>浅拷贝和深拷贝</strong></span></h2> 
<p></p> 
<p>浅拷贝： 仅仅<strong>把对象的引用进行拷贝，但是拷贝对象和源对象还是引用同一份实体</strong>。此时，其中一个的成员对象的改变都会影响到另一个的成员对象。</p> 
<p><a href="https://so.csdn.net/so/search?q=%E6%B7%B1%E6%8B%B7%E8%B4%9D&amp;spm=1001.2101.3001.7020" title="深拷贝">深拷贝</a>：指的是拷贝一个对象时，<strong>不仅仅把对象的引用进行拷贝，还把该对象引用的值也一起拷贝。这样进行深拷贝后的副本对象就和源对象互相独立</strong>，其中任何一个的成员对象改动都不会对另外一个成员对象造成影响。</p> 
<p><img alt="" height="353" src="https://images2.imgbox.com/0a/6c/o8vHOdYx_o.png" width="805"></p> 
<p>都发生了改变,浅拷贝</p> 
<p>//a.CopyTo(b, 1);//就是把b中的值拷贝给aArray，实现深拷贝。</p> 
<p><span style="color:#fe2c24;">b长度要大于a//index含义是b开始存储拷贝数据的下标</span></p> 
<p><img alt="" height="288" src="https://images2.imgbox.com/33/22/2cU3WaSu_o.png" width="921"></p> 
<p>深拷贝</p> 
<h2>equals和==</h2> 
<p><strong>对于值类型</strong></p> 
<p>在C#中对于值类型的比较不管是用【==】还是【equals】都是对于其内容的比较，也就是说对于其值的比较，相等则返回true 不相等则返回false；</p> 
<p><strong>对于引用类型</strong><br><strong> 对于除string类型以外的引用类型</strong></p> 
<p>【==】比较的是在对象在栈上的<strong>引用</strong>是否相同而【equals】则比较的是对象在堆上的<strong>内容</strong>是否相同</p> 
<p><strong>对于字符串类型</strong></p> 
<ol><li> <p>//常量字符串</p> </li><li> <p>string x = "should it matter"; //指向同一个地址，即所谓的常量池</p> </li><li> <p>string y = "should it matter";</p> </li><li> <p>object c = x;</p> </li><li> <p>object d = y;</p> </li><li> <p>Console.WriteLine(c == d);//输出True</p> </li><li> <p>Console.WriteLine(c.Equals(d));//输出True</p> </li><li> <p>//字符串变量</p> </li><li> <p>String str1=newString("aa");;//指向的地址不一样，是动态分配的</p> </li><li> <p>String str1=newString("aa");</p> </li><li> <p>object g = a;</p> </li><li> <p>object h = b;</p> </li><li> <p>Console.WriteLine(g == h);//输出False<strong><span style="color:#fe2c24;">地址不同</span></strong></p> </li><li> <p>Console.WriteLine(g.Equals(h));//输出True<span style="color:#fe2c24;"><strong>内容相同</strong></span></p> </li><li> <p></p> <p><span style="color:#0d0016;">string类型的内存分配<br> string sutdent1="刘德华";//"刘德华"在堆上  </span></p> <p><span style="color:#0d0016;">string student2=sutdent1;//stu2=1的地址也指向2</span></p> <p><span style="color:#0d0016;">当修改stu2的值stu1的值不会改变</span></p> <p><span style="color:#0d0016;">这是因为string字符串的不可变性造成的。一个string变量一旦声明并初始化以后，其在堆上面分配的值就不会改变了。这时修改student2的值，并不会去修改堆上面分配的值，而是重新在堆上面开辟一块内存来存放student2修改后的值。</span><br>  </p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04da3da08268cacbfcb6d679518d7997/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">湖北师范大学操作系统实验（java版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/87290fa898cd36ae8ce08e57a87502e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vite配置proxy代理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>