<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>查找算法2——折半查找 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="查找算法2——折半查找" />
<meta property="og:description" content="从小到大排列的有序序列。折半查找的算法描述如下：
将待查找元素与表中间的元素进行比较，如果两者相等，则说明查找成功；否则利用中间位置将表分成两部分，如果待查找元素小于中间位置的元素值，则继续与前一个子表的中间位置元素记性比较；否则与后一个子表的中间位置元素进行比较。不断重复上述操作，直到找到与待查找元素相等的元素，表明查找成功。如果子表为空表，表明查找失败。
【示例】
一个有序顺序表为7，15，22，29，41，55，67，78，81，99，如果要查找的元素为67。利用折半查找算法思想，过程如下。
其中low，high，表示两个指针，分别指向待查找元素的下界和上界，指针mid指向low和high的中间位置，即mid=(low&#43;high)/2。
初始时，low=0,high=9,mig=(0&#43;9)/2=4,因为list[mid]&lt;x，座椅需要在右半区继续寻找。此时low=5,high=9,mid=(5&#43;9)/2=7,因为list[mid]&gt;x，所以需要在左半区继续查找x。此时有low=5,high=6,mid=5，因为list[mid]&lt;x，所以需要在右半区继续找，此时有low=6,high=6,mid=6，list[mid]=x，查找成功。
#include&lt;stdio.h&gt; #include&lt;iostream&gt; #define MaxSize 100 using namespace std; typedef struct { int list[MaxSize]; int length; }Table; int BinarySearch(Table S, int x); void main() { Table T = { { 12,24,36,48,60,72,84,96 },8 }; int i, find, x; printf(&#34;有序顺序表中的元素:\n&#34;); for (i = 0; i&lt;T.length; i&#43;&#43;) printf(&#34;%4d&#34;, T.list[i]); printf(&#34;\n请输入要查找的元素:&#34;); scanf(&#34;%d&#34;, &amp;x); find = BinarySearch(T, x); if (find) printf(&#34;元素%d是顺序表中的第%d个元素.\n&#34;, x, find); else printf(&#34;没有找到该元素.\n&#34;); system(&#34;pause&#34;); } int BinarySearch(Table S, int x) /*在有序顺序表中折半查找元素x*/ { int low, high, mid; low = 0, high = S." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/706d568c8f999f39f77373b6886adcb0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-06T10:17:00+08:00" />
<meta property="article:modified_time" content="2019-12-06T10:17:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">查找算法2——折半查找</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>从小到大排列的有序序列。折半查找的算法描述如下：</p> 
<p>将待查找元素与表中间的元素进行比较，如果两者相等，则说明查找成功；否则利用中间位置将表分成两部分，如果待查找元素小于中间位置的元素值，则继续与前一个子表的中间位置元素记性比较；否则与后一个子表的中间位置元素进行比较。不断重复上述操作，直到找到与待查找元素相等的元素，表明查找成功。如果子表为空表，表明查找失败。</p> 
<p>【示例】</p> 
<p>一个有序顺序表为7，15，22，29，41，55，67，78，81，99，如果要查找的元素为67。利用折半查找算法思想，过程如下。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/b6/1d/gOdeeNtw_o.png"></p> 
<p>其中low，high，表示两个指针，分别指向待查找元素的下界和上界，指针mid指向low和high的中间位置，即mid=(low+high)/2。</p> 
<p>初始时，low=0,high=9,mig=(0+9)/2=4,因为list[mid]&lt;x，座椅需要在右半区继续寻找。此时low=5,high=9,mid=(5+9)/2=7,因为list[mid]&gt;x，所以需要在左半区继续查找x。此时有low=5,high=6,mid=5，因为list[mid]&lt;x，所以需要在右半区继续找，此时有low=6,high=6,mid=6，list[mid]=x，查找成功。</p> 
<pre class="has"><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;iostream&gt;

#define MaxSize 100
using namespace std;
typedef struct
{
	int list[MaxSize];
	int length;
}Table;
int BinarySearch(Table S, int x);
void main()
{
	Table T = { { 12,24,36,48,60,72,84,96 },8 };
	int i, find, x;
	printf("有序顺序表中的元素:\n");
	for (i = 0; i&lt;T.length; i++)
		printf("%4d", T.list[i]);
	printf("\n请输入要查找的元素:");
	scanf("%d", &amp;x);
	find = BinarySearch(T, x);
	if (find)
		printf("元素%d是顺序表中的第%d个元素.\n", x, find);
	else
		printf("没有找到该元素.\n");

	system("pause");
}
int BinarySearch(Table S, int x)
/*在有序顺序表中折半查找元素x*/
{
	int low, high, mid;
	low = 0, high = S.length - 1;			/*设置待查找元素范围的下界和上界*/
	while (low &lt;= high)
	{
		mid = (low + high) / 2;
		if (S.list[mid] == x)		/*如果找到元素，则返回该元素所在的位置*/
			return mid + 1;
		else if (S.list[mid]&lt;x)	/*如果mid所指示的元素小于x，则修改low指针*/
			low = mid + 1;
		else if (S.list[mid]&gt;x)	/*如果mid所指示的元素大于x，则修改high指针*/
			high = mid - 1;
	}
	return 0;
}
</code></pre> 
<p> </p> 
<p>结果：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/77/03/C4XEFLzy_o.png"></p> 
<p>【特点】<br> *折半查找算法要求待排序的元素必须是一个有序的序列。<br> *折半搜索查找的算法效率优于顺序查找算法的效率。</p> 
<p>【效率分析】</p> 
<p>折半查找算法过程可以用一个判定树去描述。例如用折半查找值为56的元素时，需要比较4次。从图中可以看出查找值为41的元素时，需要比较1次。查找值为78的元素时，需要比较2次。查找值为55的元素时，需要比较3次。查找值为67的元素时，需要比较4次。整个查找过程可以用二叉判定树来表示。</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/70/73/kzBW50YQ_o.png"></p> 
<p><br> 其中结点旁边的序号为该元素在序列中的下标。从图中的判定树不难看出，查找元素67的过程正好是从根结点到元素值为67的结点路径。查找元素67的比较次数正好是该元素在判定树种所在层次。因此，如果表中有n个元素，折半查找成功时，最多需要比较的次数为<img alt="\left \lfloor log_2n \right \rfloor+1" class="mathcode" src="https://images2.imgbox.com/3d/45/R7r5V0Lw_o.gif">。</p> 
<p>对于具有n个结点的有序表（恰好构成一个深度为h的满二叉树）来说，有<img alt="h=\left \lfloor log_2(n+1) \right \rfloor" class="mathcode" src="https://images2.imgbox.com/0a/56/u6UIfKqQ_o.gif">，二叉树中第i层的结点个数是<img alt="2^{i-1}" class="mathcode" src="https://images2.imgbox.com/4d/c1/FNDtCyjU_o.gif">。假设表中每个元素的查找概率相等，即<img alt="P_i=\frac{1}{n}" class="mathcode" src="https://images2.imgbox.com/47/d7/6B7d6K8h_o.gif">，则有序表在折半查找成功时的平均查找长度为：</p> 
<p><img alt="ASL_{success}=\sum_{i=1}^{n}P_iC_i=\sum_{i=1}^{h}\frac{1}{n}*i*2^i=\frac{n+1}{n}log_2(n+1)+1" class="mathcode" src="https://images2.imgbox.com/ab/31/u9WrWiAI_o.gif"></p> 
<p>查找失败时，有序表的折半查找失败平均查找长度为</p> 
<p><img alt="ASL_{failure}=\sum_{i=1}^{n}P_iC_i=\sum_{i=1}^{h}\frac{1}{n}*log_2(n+1)=log_2(n+1)" class="mathcode" src="https://images2.imgbox.com/e2/bc/kQkLM3vh_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a5ddfc674af13cd563b4cda656300f8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">No mapping found for HTTP request with URI [/swagger-ui.html]</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/37275d1e0aa97ec73c8a9b823d107204/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">1154. Day of the Year</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>