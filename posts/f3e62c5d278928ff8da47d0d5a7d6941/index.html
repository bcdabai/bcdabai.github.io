<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023 蓝桥杯 A组 蒟蒻代码 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2023 蓝桥杯 A组 蒟蒻代码" />
<meta property="og:description" content="AC了 总的来说，比上次友善多了，这才是我熟悉的暴力杯。
就做了3个满的，7道全骗（年轻人，来骗，来，偷袭！
1 幸运数 话不多说，马上开爆 机房电脑跑了几十秒才出答案
就问你出没出答案吧
#include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; bool check(int x) { vector&lt;int&gt; vec; while(x) { vec.push_back(x%10); x/=10; } int sz=vec.size(); if(sz%2!=0)return false; int a=0,b=0; for(int i=0;i&lt;sz/2;i&#43;&#43;)a&#43;=vec[i]; for(int i=sz/2;i&lt;sz;i&#43;&#43;)b&#43;=vec[i]; return a==b; } //4430091 int main() { int ans=0; cout&lt;&lt;&#34;test:&#34;&lt;&lt;check(22)&lt;&lt;&#34; &#34;&lt;&lt;check(22)&lt;&lt;&#39;\n&#39;; for(int i=1;i&lt;=100000000;i&#43;&#43;) { if(check(i))ans&#43;&#43;; } cout&lt;&lt;ans; return 0; } 2 胜利的方案数。现在想想好像做错了 ，， 寄，因为必须保证开始连续7次胜利的前一场输掉，应该是枚举到23-1=22 #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; ll C(ll n,ll m) { ll res=1; //for(ll i=n;i&gt;=n-m&#43;1;i--)res*=i; for(ll i=n;i&gt;=n-m&#43;1;i--)res*=i; for(ll i=1;i&lt;=m;i&#43;&#43;)res/=i; return res; } ll ksm(ll x,ll a) { ll res=1; while(a) { if(a&amp;1)res*=x; x*=x; a&gt;&gt;=1; } return res; } //4540385 int main() { ll res=0; //	cout&lt;&lt;C(0,0)&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f3e62c5d278928ff8da47d0d5a7d6941/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-23T13:48:26+08:00" />
<meta property="article:modified_time" content="2023-04-23T13:48:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023 蓝桥杯 A组 蒟蒻代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>       <s> AC了 </s></p> 
<p>        总的来说，比上次友善多了，这才是我熟悉的暴力杯。</p> 
<p>        就做了3个满的，7道全骗（年轻人，来骗，来，偷袭！</p> 
<p></p> 
<p>1     幸运数    话不多说，马上开爆   机房电脑跑了几十秒才出答案</p> 
<p>      就问你出没出答案吧</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
typedef long long ll;
bool check(int x)
{
	vector&lt;int&gt; vec;
	while(x)
	{
		vec.push_back(x%10);
		x/=10;
	}
	int sz=vec.size();
	if(sz%2!=0)return false;
	int a=0,b=0;
	for(int i=0;i&lt;sz/2;i++)a+=vec[i];
	for(int i=sz/2;i&lt;sz;i++)b+=vec[i];
	return a==b;
}
//4430091
int main()
{
	int ans=0;
	cout&lt;&lt;"test:"&lt;&lt;check(22)&lt;&lt;" "&lt;&lt;check(22)&lt;&lt;'\n';
	for(int i=1;i&lt;=100000000;i++)
	{
		if(check(i))ans++;
	}
	cout&lt;&lt;ans;
	return 0; 
}</code></pre> 
<p></p> 
<p>2     胜利的方案数。现在想想好像做错了 ，，  寄，因为必须保证开始连续7次胜利的前一场输掉，应该是枚举到23-1=22 </p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
ll C(ll n,ll m)
{
	ll res=1;
	//for(ll i=n;i&gt;=n-m+1;i--)res*=i;
	for(ll i=n;i&gt;=n-m+1;i--)res*=i;
	for(ll i=1;i&lt;=m;i++)res/=i;
	return res;
}
ll ksm(ll x,ll a)
{
	ll res=1;
	while(a)
	{
		if(a&amp;1)res*=x;
		x*=x;
		a&gt;&gt;=1;
	}
	return res;
}
//4540385
int main()
{
	ll res=0;
//	cout&lt;&lt;C(0,0)&lt;&lt;" "&lt;&lt;C(1,0)&lt;&lt;'\n';
	for(ll i=0;i&lt;=23;i++)
	{
		for(ll j=0;j&lt;=min(9ll,i);j++)
		{
			res+=C(i,j);
		}
	}
	cout&lt;&lt;res;
	return 0; 
}</code></pre> 
<p>3     平方差     不知道满分做法， x=a^2-b^2=（a+b）（a-b）,这启发我们因式分解x，若x能分为a0，a1。a0+a1 为偶数 则可以把 a0*a1表示为 上面平方差形式，因此可以算作一个贡献。时间复杂度 O(n^1.5)</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
int l,r;
int ans;
int main()
{	
	scanf("%d%d",&amp;l,&amp;r);
	for(int i=l;i&lt;=r;i++)
	{
		int x=i;
		bool flag=false;
		for(int j=1;j&lt;=x/j;j++)
		{
			if(x%j==0)
			{
				int t=x/j;
				if((j+t)%2==0)
				{
					flag=true;
					break;
				}
			}
		}
		if(flag)ans++;
	}
	printf("%d",ans);
	return 0; 
}</code></pre> 
<p>4       反转字符串 ， dp【i】【j】，表示   下标 i到 j  的子字符串 反转后 比原来大还是小还是相等。若i&gt;j 则 表示空字符串 ，也即相等 。因此dp【i】【j】（i&lt;j） 等于0</p> 
<p>我们观察 dp[i][j]与dp【i+1】【j-1】的关系，不难发现可以O（1）完成转移，因此DP </p> 
<p>O（n方） 切了。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int N=5e3+10;
char s[N];
int n;
int dp[N][N];//0 equal  1 elss than after reverse  -1 less than after reverse
ll ans;
int main()
{
	scanf("%s",s+1);
	n=strlen(s+1);
	dp[n][n]=0;
	for(int i=n-1;i&gt;=1;i--)
	{
		for(int j=i;j&lt;=n;j++)
		{
			int a=s[i]-'0',b=s[j]-'0';
			if(a&gt;b)dp[i][j]=1;
			else if(b==a)
			{
				dp[i][j]=dp[i+1][j-1];
			}
			else dp[i][j]=-1;			
		}
	}
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=i+1;j&lt;=n;j++)
		{
			if(dp[i][j]==1)ans++;
		}
	}
	printf("%lld",ans);
	return 0; 
}</code></pre> 
<p>5   颜色平衡树       不会，对每个节点dfs一遍， O（n方）偏分</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
using namespace std;
typedef long long ll;
const int N=2e5+10;
int head[N];
int color[N];
int n;
struct node{
	int to,nxt;
}edge[N];
int idx;
map&lt;int,int&gt; mp;
int ans;
void add(int from,int to)
{
	edge[idx].to=to;
	edge[idx].nxt=head[from];
	head[from]=idx++;
}
void dfs(int u)
{
	mp[color[u]]++;
	for(int i=head[u];~i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		dfs(v);
	}
}
int main()
{
	memset(head,-1,sizeof head);
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
	{
		int fa;
		scanf("%d%d",&amp;color[i],&amp;fa);
		if(fa!=0)add(fa,i);	
	}
	for(int i=1;i&lt;=n;i++)
	{
		mp.clear();
		dfs(i);
		int cm=(*mp.begin()).second;
		bool flag=true;
		for(map&lt;int,int&gt;::iterator i=mp.begin();i!=mp.end();i++)
		{
			if((*i).second!=cm)
			{
				flag=false;
				break;
			}
		}
		if(flag)ans++;
	}
	printf("%d",ans);		
	return 0; 
}</code></pre> 
<p>6    </p> 
<p>        两层二进制枚举 很蠢 的骗了30%分  明明 可以写3^n 的  太蠢了</p> 
<p>7     数字电路好像叫这名r</p> 
<p>     Floyd  骗 30%</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
using namespace std;
typedef long long ll;
const int N=5e3+10;
const int INF=0x3f3f3f3f;
int n,m,q;
int dist[N][N];
int main()
{
	scanf("%d%d%d",&amp;n,&amp;m,&amp;q);
	memset(dist,0x3f,sizeof dist);
//	for(int i=0;i&lt;=n;i++)dist[i][i]=0;
	for(int i=1;i&lt;=m;i++)
	{
		int a,b,c;
		scanf("%d%d%d",&amp;a,&amp;b,&amp;c);
		int temp=dist[a][b];
		if(temp!=INF)dist[a][b]=dist[b][a]=max(c,temp);
		else dist[a][b]=dist[b][a]=c;
	}
	for(int k=1;k&lt;=n;k++)
	{
		for(int i=1;i&lt;=n;i++)
		{
			for(int j=1;j&lt;=n;j++)
			{
				//dist[a][b]=max(dist[a][b],min(dist[a][k],dist[k][b]));
				int temp=min(dist[i][k],dist[k][j]);
				if(dist[i][k]==INF||dist[k][j]==INF)temp=INF;
				if(dist[i][j]==INF)dist[i][j]=temp;
				else {
					if(temp!=INF)dist[i][j]=max(dist[i][j],temp);
				}
			}
		}
	}
//	for(int i=1;i&lt;=n;i++)
//	{
//		for(int j=1;j&lt;=n;j++)cout&lt;&lt;dist[i][j]&lt;&lt;" ";
//		cout&lt;&lt;'\n';
//	}
	while(q--)
	{
		int a,b;
		scanf("%d%d",&amp;a,&amp;b);
		if(dist[a][b]!=INF)printf("%d\n",dist[a][b]);
		else puts("-1");
	}
	return 0; 
}</code></pre> 
<p>8    异或和      前缀和 O（n方） 骗60%        正解 舍友说用二进制拆分  O（30n）</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int N=1e5+10;
ll a[N];
ll d[N];
int n;
ll ans;
int main()
{	
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
	for(int i=1;i&lt;=n;i++)
	{
		d[i]=a[i];
		d[i]^=d[i-1];
	}
	for(int i=1;i&lt;=n;i++)
	{
		for(int j=i;j&lt;=n;j++)
		{
			ans+=(d[j]^d[i-1]);
		}
	}
	printf("%lld",ans);
	return 0; 
}</code></pre> 
<p>9      很想数独的一道题        O（2^nm）暴力dfs开骗 </p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
using namespace std;
typedef long long ll;
const int N=15;
int n,m;
char g[N][N];
bool flag=false;
int dx[]={-1,-1,-1,0,0,1,1,1,0};
int dy[]={1,0,-1,1,-1,1,0,-1,0};
int nums[N][N];
inline bool check()
{
	for(int i=0;i&lt;n;i++)
	{
		for(int j=0;j&lt;m;j++)
		{
			if(g[i][j]=='_')continue;
			else
			{
				int target=g[i][j]-'0';
				int tot=0;
				for(int k=0;k&lt;9;k++)
				{
					int a=i+dx[k],b=j+dy[k];
					if(a&lt;0||a&gt;=n||b&lt;0||b&gt;=m)continue;
					if(nums[a][b]==1)tot++;
				}
				if(tot!=target)return false;
			}
		}
	}
	return true;
}
void dfs(int a,int b)
{
	if(flag)return ;
	if(a==n)
	{
		if(check())
		{
			for(int i=0;i&lt;n;i++)
			{
				for(int j=0;j&lt;m;j++)printf("%d",nums[i][j]);
				puts("");
			}
			flag=true;
		}
		return ;
	}
	if(b==n){
		dfs(a+1,0);
		return ;
	}
	nums[a][b]=1;
	dfs(a,b+1);
	nums[a][b]=0;
	dfs(a,b+1);
	return ;
}
int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=0;i&lt;n;i++)scanf("%s",g[i]);
	dfs(0,0);
	return 0; 
}</code></pre> 
<p>10           抛硬币        O（nlogn）   。 假设每个银币被翻转了 n次，因此  除了第一枚硬币，其他硬币的翻转次数应该为偶数。 我们从前考虑每一个硬币 ，第一个硬币一定要翻转一次，因此后面每个硬币 都会被翻转一次，我们从前往后考虑每个硬币 ，类似埃氏筛法的就能 暴力骗30%分 （前提代码没错  QAQ</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int N=5e6+10;
int n;
int cnt[N];
ll ans;
// o(nlogn)
int main()
{
	scanf("%d",&amp;n);
	ans=1;
	for(int i=2;i&lt;=n;i++)
	{
		if(cnt[i]%2==0){
			ans++;
			for(int j=i*2;j&lt;=n;j+=i)cnt[j]++;
		}
	}
	printf("%lld",ans);
	return 0; 
}</code></pre> 
<p></p> 
<p></p> 
<p>没进过决赛  希望满足一次 TNT</p> 
<p></p> 
<p></p> 
<p>-------------------更新----------------</p> 
<p>省一          舒服了</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03f1461cbd7104b51103680005fe8a8f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于openssl SHA256WithRSA签名和验签过程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc2dc7a319c7de827dc3675e8d51e15c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">比ChatGPT更好用的Claude来了</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>