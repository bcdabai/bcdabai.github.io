<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux】——多线程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Linux】——多线程" />
<meta property="og:description" content="目录
Linux线程概念
二级页表 线程的优点 线程的缺点 线程异常 线程的用途 Linux中的线程和进程 进程和线程
进程的多个线程共享
进程和线程的关系 Linux线程控制
POSIX线程库 线程创建 线程ID及地址空间布局 线程等待 线程终止 Linux线程概念 什么是线程 在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”。一切进程至少都有一个执行线程。线程在进程内部运行，本质是在进程地址空间内运行。在Linux系统中，在CPU眼中，看到的PCB都要比传统的进程更加轻量化。透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流。 需要明确的是，一个进程的创建实际上伴随着其进程控制块（task_struct）、进程地址空间（mm_struct）以及页表的创建，虚拟地址和物理地址就是通过页表建立映射的。 每个进程都有自己独立的进程地址空间和独立的页表，也就意味着所有进程在运行时本身就具有独立性。
但如果我们在创建“进程”时，只创建task_struct，并要求创建出来的task_struct和父task_struct共享进程地址空间和页表，那么创建的结果就是下面这样的：
此时我们创建的实际上就是四个线程：
其中每一个线程都是当前进程里面的一个执行流，也就是我们常说的“线程是进程内部的一个执行分支”。同时我们也可以看出，线程在进程内部运行，本质就是线程在进程地址空间内运行，也就是说曾经这个进程申请的所有资源，几乎都是被所有线程共享的。 如何理解进程与线程的关系？
教材观点：线程是一个执行分支，执行粒度比进程更细，调度成本更低。线程是进程内部的一个执行流。
内核观点：线程是CPU调度的基本单位，进程是承担分配系统资源的基本实体。
上面用方框框起来的内容，我们将这个整体叫做进程。因此，所谓的进程并不是通过task_struct来衡量的，除了task_struct之外，一个进程还要有进程地址空间、文件、信号等等，合起来称之为一个进程。
所以我们站在内核角度来理解进程：进程就是承担分配系统资源的基本实体。
换言之，当我们创建进程时是创建一个task_struct、创建地址空间、维护页表，然后在物理内存当中开辟空间、构建映射，打开进程默认打开的相关文件、注册信号对应的处理方案等等。而我们之前接触到的进程都只有一个task_struct，也就是该进程内部只有一个执行流，即单执行流进程，接下来我们将要接触到的，内部有多个执行流的进程叫做多执行流进程。
在Linux中，站在CPU的角度，能否识别当前调度的task_struct是进程还是线程？
答案是不能，也不需要了，因为CPU只关心一个一个的独立执行流。无论进程内部只有一个执行流还是有多个执行流，CPU都是以task_struct为单位进行调度的。因此，CPU看到的虽说还是task_struct，但已经比传统的进程要更轻量化了。
Linux下使用轻量级进程LWP模拟多线程！
为了管理好线程，有些操作系统会像进程一样单独为线程设计一套数据结构用于统筹管理线程的正常运作，比如windows就设计了线程控制块TCB隶属于PCB中，也就是说windows操作系统内核中有正线程。
而Linux内核的设计者认为，线程可以复用进程的结构体，用PCB足以模拟实现TCB的功能，所以在Linux当中没有真正的线程，而是复用了PCB的代码和结果，用轻量化进程的方案模拟实现的线程。
事实上Linux系统采取的方案更加简单，容易维护，效率更高也更安全。对于一款操作系统来说，使用最频繁的功能，除了OS本身，就是线程了。Linux正是因为采用轻量化进程LWP模拟实现多线程的方式，才能够长时间不间断的运行。
原生线程库pthread 在Linux中，站在内核角度没有真正意义上线程相关的接口，但是站在用户角度，当用户想创建一个线程时更期望使用thread_create这样类似的接口，因此系统为用户层提供了原生线程库pthread。
原生线程库实际就是对轻量级进程的系统调用进行了封装，在用户层模拟实现了一套线程相关的接口。
因此对于我们来讲，在Linux下学习线程实际上就是学习在用户层模拟实现的这一套接口，而并非操作系统的接口。
二级页表 以32位平台为例，在32位平台下一共有232个地址，也就意味着有232个地址需要被映射。
如果我们所谓的页表就只是单纯的一张表，那么这张表就需要建立232个虚拟地址和物理地址之间的映射关系，即这张表一共有232个映射表项。
每一个表项中除了要有虚拟地址和与其映射的物理地址以外，实际还需要有一些权限相关的信息，比如我们所说的用户级页表和内核级页表，实际就是通过权限进行区分的。每个应表项中存储一个物理地址和一个虚拟地址就需要8个字节，考虑到还需要包含权限相关的各种信息，这里每一个表项就按10个字节计算。
这里一共有232个表项，也就意味着存储这张页表我们需要用232 * 10个字节，也就是40GB。而在32位平台下我们的内存可能一共就只有4GB，也就是说我们根本无法存储这样的一张页表。 因此所谓的页表并不是单纯的一张表。 以32位平台为例，其页表的映射过程如下：
选择虚拟地址的前10个比特位在页目录当中进行查找，找到对应的页表。再选择虚拟地址的10个比特位在对应的页表当中进行查找，找到物理内存中对应页框的起始地址。最后将虚拟地址中剩下的12个比特位作为偏移量从对应页框的起始地址处向后进行偏移，找到物理内存中某一个对应的字节数据。 物理内存实际是被划分成一个个4KB大小的页框的，而磁盘上的程序也是被划分成一个个4KB大小的页帧的，当内存和磁盘进行数据交换时也就是以4KB大小为单位进行加载和保存的。
4KB实际上就是2的12次方个字节，也就是说一个页框中有2的12次方个字节，而访问内存的基本大小是1字节，因此一个页框中就有2的12次方个地址，于是我们就可以将剩下的12个比特位作为偏移量，从页框的起始地址处开始向后进行偏移，从而找到物理内存中某一个对应字节数据。
使用页表定位任意一个内存字节位置：页框&#43;页内偏移，也可以说是基地址&#43;偏移量！
这实际上就是我们所谓的二级页表，其中页目录项是一级页表，页表项是二级页表。
每一个表项还是按10字节计算，页目录和页表的表项都是2的10次方个，因此一个表的大小就是2的10次方 * 10个字节，也就是10KB。而页目录有2的10次方个表项也就意味着页表有2的10次方个，也就是说一级页表有1张，二级页表有210张，总共算下来大概就是10MB，内存消耗并不高，因此Linux中实际就是这样映射的。 上面所说的所有映射过程，都是由MMU（MemoryManagementUnit）这个硬件完成的，该硬件是集成在CPU内的。页表是一种软件映射，MMU是一种硬件映射，所以计算机进行虚拟地址到物理地址的转化采用的是软硬件结合的方式。
修改常量字符串触发段错误的原因 当我们要修改一个字符串常量时，虚拟地址必须经过页表映射找到对应的物理内存，而在查表过程中发现其权限是只读的，此时你要对其进行修改就会在MMU内部触发硬件错误，操作系统在识别到是哪一个进程导致的之后，就会给该进程发送信号对其进行终止。
线程的优点 创建一个新线程的代价要比创建一个新进程小得多与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多线程占用的资源要比进程少很多能充分利用多处理器的可并行数量在等待慢速I/O操作结束的同时，程序可执行其他的计算任务计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现I/O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作 【说明】
计算密集型：主要消耗CPU资源，比如文件压缩和解压、加密或者解密过程等等与算法相关的操作
IO密集型：执行流的大部分任务，主要以IO为主。比如刷磁盘、访问数据库、访问网络等。
线程不是越多越好，一定要根据CPU的个数/核心数，选择合适的线程数。
线程的缺点 性能损失：一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。健壮性降低：编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。缺乏访问控制：进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。编程难度提高：编写与调试一个多线程程序比单线程程序困难得多 线程异常 单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出 线程的用途 合理的使用多线程，能提高CPU密集型程序的执行效率合理的使用多线程，能提高IO密集型程序的用户体验（如生活中我们一边写代码一边下载开发工具，就是多线程运行的一种表现） Linux中的线程和进程 进程和线程 上文已提到过：进程是承担分配系统资源的基本实体，线程是调度的基本单位。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5148e40a28a8b63cb4b8c4192c680696/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-03T21:19:27+08:00" />
<meta property="article:modified_time" content="2023-06-03T21:19:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux】——多线程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="488" src="https://images2.imgbox.com/75/9f/aU4F2mpq_o.png" width="1200"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="Linux%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#Linux%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5" rel="nofollow">Linux线程概念</a></p> 
<p id="%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%C2%A0" rel="nofollow">二级页表 </a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%C2%A0" rel="nofollow">线程的优点 </a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9%C2%A0" rel="nofollow">线程的缺点 </a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%C2%A0" rel="nofollow">线程异常 </a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%A8%E9%80%94%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%A8%E9%80%94%C2%A0" rel="nofollow">线程的用途 </a></p> 
<p id="Linux%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%C2%A0-toc" style="margin-left:0px;"><a href="#Linux%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%C2%A0" rel="nofollow">Linux中的线程和进程 </a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B" rel="nofollow">进程和线程</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB-toc" style="margin-left:40px;"><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB" rel="nofollow">进程的多个线程共享</a></p> 
<p id="%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%C2%A0" rel="nofollow">进程和线程的关系 </a></p> 
<p id="Linux%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6-toc" style="margin-left:0px;"><a href="#Linux%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6" rel="nofollow">Linux线程控制</a></p> 
<p id="POSIX%E7%BA%BF%E7%A8%8B%E5%BA%93%C2%A0-toc" style="margin-left:40px;"><a href="#POSIX%E7%BA%BF%E7%A8%8B%E5%BA%93%C2%A0" rel="nofollow">POSIX线程库 </a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%C2%A0" rel="nofollow">线程创建 </a></p> 
<p id="%E7%BA%BF%E7%A8%8BID%E5%8F%8A%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%BA%BF%E7%A8%8BID%E5%8F%8A%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%C2%A0" rel="nofollow">线程ID及地址空间布局 </a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%C2%A0%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%C2%A0%C2%A0" rel="nofollow">线程等待  </a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%C2%A0" rel="nofollow">线程终止 </a></p> 
<hr> 
<h2 id="Linux%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5">Linux线程概念</h2> 
<p><strong>什么是线程 </strong></p> 
<ul><li>在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”。</li><li>一切进程至少都有一个执行线程。</li><li>线程在进程内部运行，本质是在进程地址空间内运行。</li><li>在Linux系统中，在CPU眼中，看到的PCB都要比传统的进程更加轻量化。</li><li>透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流。</li></ul> 
<p>需要明确的是，一个进程的创建实际上伴随着其进程控制块（task_struct）、进程地址空间（mm_struct）以及页表的创建，虚拟地址和物理地址就是通过页表建立映射的。 </p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/66/a6/wzSUbcnj_o.png" width="1020"></p> 
<p>每个进程都有自己独立的进程地址空间和独立的页表，也就意味着所有进程在运行时本身就具有独立性。</p> 
<p>但如果我们在创建“进程”时，只创建task_struct，并要求创建出来的task_struct和父task_struct共享进程地址空间和页表，那么创建的结果就是下面这样的：</p> 
<p><img alt="" height="623" src="https://images2.imgbox.com/9e/7c/qWW2EuHN_o.png" width="1027"></p> 
<p>此时我们创建的实际上就是四个线程：</p> 
<ul><li>其中每一个线程都是当前进程里面的一个执行流，也就是我们常说的“线程是进程内部的一个执行分支”。</li><li>同时我们也可以看出，线程在进程内部运行，本质就是线程在进程地址空间内运行，也就是说曾经这个进程申请的所有资源，几乎都是被所有线程共享的。</li></ul> 
<blockquote> 
 <p><strong>如何理解进程与线程的关系？</strong></p> 
</blockquote> 
<p>教材观点：线程是一个执行分支，执行粒度比进程更细，调度成本更低。线程是进程内部的一个执行流。</p> 
<p>内核观点：线程是CPU调度的基本单位，进程是承担分配系统资源的基本实体。</p> 
<p><img alt="" height="1084" src="https://images2.imgbox.com/c6/40/t8tGIFpp_o.png" width="1200"></p> 
<p> 上面用方框框起来的内容，我们将这个整体叫做进程。因此，所谓的进程并不是通过task_struct来衡量的，除了task_struct之外，一个进程还要有进程地址空间、文件、信号等等，合起来称之为一个进程。</p> 
<p>所以我们站在内核角度来理解进程：<strong><span style="color:#fe2c24;">进程就是承担分配系统资源的基本实体</span></strong>。</p> 
<p>换言之，当我们创建进程时是创建一个task_struct、创建地址空间、维护页表，然后在物理内存当中开辟空间、构建映射，打开进程默认打开的相关文件、注册信号对应的处理方案等等。而我们之前接触到的进程都只有一个task_struct，也就是<span style="color:#fe2c24;"><strong>该进程内部只有一个执行流，即单执行流进程</strong></span>，接下来我们将要接触到的，<strong><span style="color:#fe2c24;">内部有多个执行流的进程叫做多执行流进程</span></strong>。</p> 
<blockquote> 
 <p>在Linux中，站在CPU的角度，能否识别当前调度的task_struct是进程还是线程？</p> 
</blockquote> 
<p>答案是不能，也不需要了，因为CPU只关心一个一个的独立执行流。无论进程内部只有一个执行流还是有多个执行流，CPU都是以task_struct为单位进行调度的。因此，CPU看到的虽说还是task_struct，但已经比传统的进程要更轻量化了。</p> 
<blockquote> 
 <p><strong>Linux下使用轻量级进程LWP模拟多线程！</strong></p> 
</blockquote> 
<p>为了管理好线程，有些操作系统会像进程一样单独为线程设计一套数据结构用于统筹管理线程的正常运作，比如windows就设计了线程控制块TCB隶属于PCB中，也就是说windows操作系统内核中有正线程。</p> 
<p>而Linux内核的设计者认为，线程可以复用进程的结构体，用PCB足以模拟实现TCB的功能，所以在Linux当中没有真正的线程，而是复用了PCB的代码和结果，用轻量化进程的方案模拟实现的线程。</p> 
<p>事实上Linux系统采取的方案更加简单，容易维护，效率更高也更安全。对于一款操作系统来说，使用最频繁的功能，除了OS本身，就是线程了。Linux正是因为采用轻量化进程LWP模拟实现多线程的方式，才能够长时间不间断的运行。</p> 
<blockquote> 
 <p>原生线程库pthread </p> 
</blockquote> 
<p>在Linux中，站在内核角度没有真正意义上线程相关的接口，但是站在用户角度，当用户想创建一个线程时更期望使用thread_create这样类似的接口，因此系统为用户层提供了原生线程库pthread。</p> 
<p>原生线程库实际就是对轻量级进程的系统调用进行了封装，在用户层模拟实现了一套线程相关的接口。</p> 
<p>因此对于我们来讲，在Linux下学习线程实际上就是学习在用户层模拟实现的这一套接口，而并非操作系统的接口。</p> 
<hr> 
<h2 id="%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%C2%A0">二级页表 </h2> 
<p>以32位平台为例，在32位平台下一共有232个地址，也就意味着有232个地址需要被映射。</p> 
<p>如果我们所谓的页表就只是单纯的一张表，那么这张表就需要建立232个虚拟地址和物理地址之间的映射关系，即这张表一共有232个映射表项。</p> 
<p><img alt="" height="651" src="https://images2.imgbox.com/ce/b7/XsNecnRZ_o.png" width="1027"> 每一个表项中除了要有虚拟地址和与其映射的物理地址以外，实际还需要有一些权限相关的信息，比如我们所说的用户级页表和内核级页表，实际就是通过权限进行区分的。每个应表项中存储一个物理地址和一个虚拟地址就需要8个字节，考虑到还需要包含权限相关的各种信息，这里每一个表项就按10个字节计算。</p> 
<p>这里一共有232个表项，也就意味着存储这张页表我们需要用232 * 10个字节，也就是40GB。而在32位平台下我们的内存可能一共就只有4GB，也就是说我们根本无法存储这样的一张页表。 </p> 
<p><strong><span style="color:#fe2c24;">因此所谓的页表并不是单纯的一张表。 </span></strong></p> 
<p>以32位平台为例，其页表的映射过程如下：</p> 
<ol><li>选择虚拟地址的前10个比特位在页目录当中进行查找，找到对应的页表。</li><li>再选择虚拟地址的10个比特位在对应的页表当中进行查找，找到物理内存中对应页框的起始地址。</li><li>最后将虚拟地址中剩下的12个比特位作为偏移量从对应页框的起始地址处向后进行偏移，找到物理内存中某一个对应的字节数据。</li></ol> 
<p><img alt="" height="678" src="https://images2.imgbox.com/e9/b5/3FRBsdyH_o.png" width="1200"></p> 
<p>物理内存实际是被划分成一个个4KB大小的页框的，而磁盘上的程序也是被划分成一个个4KB大小的页帧的，当内存和磁盘进行数据交换时也就是以4KB大小为单位进行加载和保存的。</p> 
<p>4KB实际上就是2的12次方个字节，也就是说一个页框中有2的12次方个字节，而访问内存的基本大小是1字节，因此一个页框中就有2的12次方个地址，于是我们就可以将剩下的12个比特位作为偏移量，从页框的起始地址处开始向后进行偏移，从而找到物理内存中某一个对应字节数据。</p> 
<p><strong><span style="color:#fe2c24;">使用页表定位任意一个内存字节位置：页框+页内偏移，也可以说是基地址+偏移量！</span></strong></p> 
<p><strong><span style="color:#fe2c24;">这实际上就是我们所谓的二级页表，其中页目录项是一级页表，页表项是二级页表。</span></strong></p> 
<p>每一个表项还是按10字节计算，页目录和页表的表项都是2的10次方个，因此一个表的大小就是2的10次方 * 10个字节，也就是10KB。而页目录有2的10次方个表项也就意味着页表有2的10次方个，也就是说一级页表有1张，二级页表有210张，总共算下来大概就是10MB，内存消耗并不高，因此Linux中实际就是这样映射的。 </p> 
<p>上面所说的所有映射过程，都是由MMU（MemoryManagementUnit）这个硬件完成的，该硬件是集成在CPU内的。页表是一种软件映射，MMU是一种硬件映射，所以计算机进行虚拟地址到物理地址的转化采用的是软硬件结合的方式。</p> 
<blockquote> 
 <p>修改常量字符串触发段错误的原因 </p> 
</blockquote> 
<p> 当我们要修改一个字符串常量时，虚拟地址必须经过页表映射找到对应的物理内存，而在查表过程中发现其权限是只读的，此时你要对其进行修改就会在MMU内部触发硬件错误，操作系统在识别到是哪一个进程导致的之后，就会给该进程发送信号对其进行终止。</p> 
<hr> 
<h2 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%C2%A0">线程的优点 </h2> 
<ul><li>创建一个新线程的代价要比创建一个新进程小得多</li><li>与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多</li><li>线程占用的资源要比进程少很多</li><li>能充分利用多处理器的可并行数量</li><li>在等待慢速I/O操作结束的同时，程序可执行其他的计算任务</li><li>计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现</li><li>I/O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作</li></ul> 
<p>【说明】</p> 
<p>计算密集型：主要消耗CPU资源，比如文件压缩和解压、加密或者解密过程等等与算法相关的操作</p> 
<p>IO密集型：执行流的大部分任务，主要以IO为主。比如刷磁盘、访问数据库、访问网络等。</p> 
<p>线程不是越多越好，一定要根据CPU的个数/核心数，选择合适的线程数。</p> 
<h2 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9%C2%A0">线程的缺点 </h2> 
<ul><li><span style="color:#fe2c24;"><strong>性能损失</strong></span>：一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。</li><li><span style="color:#fe2c24;"><strong>健壮性降低</strong></span>：编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。</li><li><span style="color:#fe2c24;"><strong>缺乏访问控制</strong></span>：进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。</li><li><span style="color:#fe2c24;"><strong>编程难度提高</strong></span>：编写与调试一个多线程程序比单线程程序困难得多</li></ul> 
<h2 id="%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%C2%A0">线程异常 </h2> 
<ul><li>单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃</li><li>线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出</li></ul> 
<h2 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%A8%E9%80%94%C2%A0">线程的用途 </h2> 
<ul><li>合理的使用多线程，能提高CPU密集型程序的执行效率</li><li>合理的使用多线程，能提高IO密集型程序的用户体验（如生活中我们一边写代码一边下载开发工具，就是多线程运行的一种表现）</li></ul> 
<hr> 
<h2 id="Linux%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%C2%A0">Linux中的线程和进程 </h2> 
<h3 id="%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><strong>进程和线程</strong></h3> 
<blockquote> 
 <p>上文已提到过：<strong>进程是承担分配系统资源的基本实体，线程是调度的基本单位</strong>。</p> 
</blockquote> 
<p>线程共享进程数据，但也拥有自己的一部分数据：</p> 
<ul><li>线程ID。</li><li>一组寄存器。（存储每个线程的上下文信息）</li><li>栈。（每个线程都有临时的数据，需要压栈出栈，<strong><span style="color:#fe2c24;">各线程间的栈不共享</span></strong>）</li><li>errno。（C语言提供的全局变量，每个线程都有自己的）</li><li>信号屏蔽字。</li><li>调度优先级。</li></ul> 
<h3 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB">进程的多个线程共享</h3> 
<p>因为是在同一个地址空间，因此所谓的代码段（Text Segment）、数据段（Data Segment）都是共享的：</p> 
<ul><li>如果定义一个函数，在各线程中都可以调用。</li><li>如果定义一个全局变量，在各线程中都可以访问到。</li></ul> 
<p>除此之外，各线程还共享以下进程资源和环境：</p> 
<ul><li>文件描述符表。（进程打开一个文件后，其他线程也能够看到）</li><li>每种信号的处理方式。（SIG_IGN、SIG_DFL或者自定义的信号处理函数）</li><li>当前工作目录。（cwd）</li><li>用户ID和组ID。</li></ul> 
<h3 id="%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%C2%A0">进程和线程的关系 </h3> 
<p>在此之前我们接触到的都是具有一个线程执行流的进程，即单线程进程。 </p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/19/ae/BkaMG6tB_o.png" width="944"></p> 
<hr> 
<h2 id="Linux%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6">Linux线程控制</h2> 
<h3 id="POSIX%E7%BA%BF%E7%A8%8B%E5%BA%93%C2%A0">POSIX线程库 </h3> 
<p>pthread线程库是应用层的原生线程库： </p> 
<ul><li>与线程有关的函数构成了一个完整的系列，绝大多数函数的名字都是以“pthread_”打头的</li><li>要使用这些函数库，要通过引入头文&lt;pthread.h&gt;</li><li>链接这些线程函数库时要使用编译器命令的“-lpthread”选项</li></ul> 
<p>错误检查： </p> 
<ul><li>传统的一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误。</li><li>pthreads函数出错时不会设置全局变量errno（而大部分其他POSIX函数会这样做。而是将错误代码通过返回值返回。</li><li>pthreads同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthreads函数的错误，建议通过返回值判定，因为读取返回值要比读取线程内的errno变量的开销更小</li></ul> 
<h3 id="%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%C2%A0">线程创建 </h3> 
<pre><code class="language-cpp">//创建线程的函数叫做pthread_create
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
</code></pre> 
<p><strong>参数说明</strong>：</p> 
<ul><li>thread：获取创建成功的线程ID，该参数是一个输出型参数。</li><li>attr：用于设置创建线程的属性，传入NULL表示使用默认属性。</li><li>start_routine：该参数是一个函数地址，线程例程，表示线程启动后要执行的函数。</li><li>arg：传给线程例程的参数。</li></ul> 
<p><strong>返回值说明</strong>：</p> 
<ul><li>线程创建成功返回0，失败返回错误码。</li></ul> 
<blockquote> 
 <p>让主线程创建一个新线程 </p> 
</blockquote> 
<p>当一个程序启动时，就有一个进程被操作系统创建，与此同时一个线程也立刻运行，这个线程就叫做主线程。</p> 
<ul><li>主线程是产生其他子线程的线程。</li><li>通常主线程必须最后完成某些执行操作，比如各种关闭动作。</li></ul> 
<p>下面我们让主线程调用pthread_create函数创建一个新线程，此后新线程就会跑去执行自己的新例程，而主线程则继续执行后续代码。 </p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;pthread.h&gt;
#include&lt;unistd.h&gt;

using namespace std;


void* run(void* args)
{
    char* msg = static_cast&lt;char *&gt;(args);
    while(true)
    {
        sleep(1);
        cout&lt;&lt;msg&lt;&lt;"running..."&lt;&lt;endl;
    }
}

int main()
{
    pthread_t tid;
    pthread_create(&amp;tid,NULL,run,(void*)"thread1");
    while(true)
    {
        cout&lt;&lt;"main thread running..."&lt;&lt;endl;
        sleep(3);
    }
    return 0;
}</code></pre> 
<p> 可以看到主线程与创建出的新线程在同时运行。</p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/72/b2/QEwZfkhH_o.png" width="783"></p> 
<p>使用ps-aL命令，可以现实当前的轻量级进程。</p> 
<ul><li>默认情况下，不带-L，看到的就是一个个的进程。</li><li>带-L可以查看到每个进程内的多个轻量级进程。</li></ul> 
<p><img alt="" height="429" src="https://images2.imgbox.com/4b/61/ro3HJl4M_o.png" width="1200"> </p> 
<blockquote> 
 <p>获取线程ID </p> 
</blockquote> 
<p>常见获取线程ID的方式有两种：</p> 
<ul><li>创建线程时通过输出型参数获得。</li><li>通过调用pthread_self函数获得。</li></ul> 
<p>pthread_self函数的函数原型如下：</p> 
<pre><code class="language-cpp">pthread_t pthread_self(void);
</code></pre> 
<p>调用pthread_self函数即可获得当前线程的ID，类似于调用getpid函数获取当前进程的ID。</p> 
<p>例如，下面代码中在新线程被创建后，主线程都将通过输出型参数获取到的线程ID进行打印，此后主线程和新线程又通过调用pthread_self函数获取到自身的线程ID进行打印。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;pthread.h&gt;
#include&lt;unistd.h&gt;

using namespace std;


void* run(void* args)
{
    char* msg = static_cast&lt;char *&gt;(args);
    while(true)
    {
        sleep(1);
        cout&lt;&lt;msg&lt;&lt;" running..."&lt;&lt;" pid: "&lt;&lt;getpid()&lt;&lt;" ppid: "&lt;&lt;getppid()&lt;&lt;" tid: "&lt;&lt;pthread_self()&lt;&lt;endl;
    }
}

int main()
{
    pthread_t tid;
    pthread_create(&amp;tid,NULL,run,(void*)"thread1");
    cout&lt;&lt;"thread1 tid is "&lt;&lt;tid&lt;&lt;endl;
    while(true)
    {
        cout&lt;&lt;"main thread running..."&lt;&lt;" pid: "&lt;&lt;getpid()&lt;&lt;" ppid: "&lt;&lt;getppid()&lt;&lt;" tid: "&lt;&lt;pthread_self()&lt;&lt;endl;
        sleep(3);
    }
    return 0;
}</code></pre> 
<p> 可以看出两种方式获取到的线程ID是相同的</p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/ab/f8/H0q9wk2S_o.png" width="935"></p> 
<p><strong>注意：</strong> 用pthread_self函数获得的线程ID与内核的LWP的值是不相等的，pthread_self函数获得的是用户级原生线程库的线程ID，而LWP是内核的轻量级进程ID，它们之间是一对一的关系。应该明白，<span style="color:#fe2c24;"><strong>线程ID和LWP的值不是一回事</strong></span>。</p> 
<h3 id="%E7%BA%BF%E7%A8%8BID%E5%8F%8A%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%C2%A0">线程ID及地址空间布局 </h3> 
<ul><li>pthread_ create函数会产生一个线程ID，存放在第一个参数指向的地址中。该线程ID和前面说的线程ID不是一回事。</li><li>前面讲的线程ID属于进程调度的范畴。因为线程是轻量级进程，是操作系统调度器的最小单位，所以需要一个数值来唯一表示该线程。</li><li>pthread_ create函数第一个参数指向一个虚拟内存单元，该内存单元的地址即为新创建线程的线程ID，属于NPTL线程库的范畴。线程库的后续操作，就是根据该线程ID来操作线程的。</li><li>线程库NPTL提供了pthread_ self函数，可以获得线程自身的ID</li></ul> 
<blockquote> 
 <p>pthread_t 到底是什么类型呢？取决于实现。对于Linux目前实现的NPTL实现而言，pthread_t类型的线程ID，<strong>本质就是一个进程地址空间上的一个地址</strong>。</p> 
</blockquote> 
<p><img alt="" height="750" src="https://images2.imgbox.com/9a/af/l4SHvKEh_o.png" width="1110">首先，Linux不提供真正的线程，只提供LWP，也就意味着操作系统只需要对内核执行流LWP进行管理，而供用户使用的线程接口等其他数据，应该由线程库自己来管理，因此管理线程时的“先描述，再组织”就应该在线程库里进行。</p> 
<p>前面说明我们采用的线程库实际上是一个动态库。进程运行时动态库被加载到内存，然后通过页表映射到进程地址空间中的共享区，此时该进程内的所有线程都是能看到这个动态库的。</p> 
<p>我们说每个线程都有自己私有的栈，其中主线程采用的栈是进程地址空间中原生的栈，而其余线程采用的栈就是在共享区中开辟的。<strong><span style="color:#fe2c24;">除此之外，每个线程都有自己的struct pthread，当中包含了对应线程的各种属性</span></strong>；每个线程还有自己的线程局部存储，当中包含了对应线程被切换时的上下文数据。</p> 
<p>pthread_t到底是什么类型取决于实现，但是对于Linux目前实现的NPTL线程库来说，<span style="color:#fe2c24;"><strong>线程ID本质就是进程地址空间共享区上的一个虚拟地址</strong></span>，同一个进程中所有的虚拟地址都是不同的，因此可以用它来唯一区分每一个线程。</p> 
<h3 id="%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%C2%A0%C2%A0">线程等待  </h3> 
<p>首先需要明确的是，一个线程被创建出来，这个线程就如同进程一般，也是需要被等待的。如果主线程不对新线程进行等待，那么这个新线程的资源也是不会被回收的。所以线程需要被等待，如果不等待会产生类似于“僵尸进程”的问题，也就是内存v泄漏。 </p> 
<p>pthread_join函数的函数原型如下：</p> 
<pre><code class="language-cpp">int pthread_join(pthread_t thread, void **retval);
</code></pre> 
<p>参数说明：</p> 
<ul><li>thread：被等待线程的ID。</li><li>retval：线程退出时的退出码信息。</li></ul> 
<p>返回值说明：</p> 
<ul><li>线程等待成功返回0，失败返回错误码。</li></ul> 
<p>调用该函数的线程将挂起等待，直到ID为thread的线程终止，thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的。</p> 
<p> </p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;pthread.h&gt;
#include&lt;unistd.h&gt;

using namespace std;

void* Routine(void* arg)
{
	char* msg = static_cast&lt;char *&gt;(arg);
	int count = 0;
	while (count &lt; 5){
		printf("I am %s...pid: %d, ppid: %d, tid: %lu\n", msg, getpid(), getppid(), pthread_self());
		sleep(1);
		count++;
	}
	return NULL;
}
int main()
{
	pthread_t tid[5];
	for (int i = 0; i &lt; 5; i++){
		char* buffer = (char*)malloc(64);
		sprintf(buffer, "thread %d", i);
		pthread_create(&amp;tid[i], NULL, Routine, buffer);
		//printf("%s tid is %lu\n", buffer, tid[i]);
	}
	printf("I am main thread...pid: %d, ppid: %d, tid: %lu\n", getpid(), getppid(), pthread_self());
	for (int i = 0; i &lt; 5; i++){
		pthread_join(tid[i], NULL);
		printf("thread %d[%lu]...quit\n", i, tid[i]);
	}
	return 0;
}</code></pre> 
<p><strong>注意：</strong> pthread_join函数默认是以阻塞的方式进行线程等待的。 </p> 
<p><img alt="" height="711" src="https://images2.imgbox.com/83/22/lqfEZ8si_o.png" width="941"></p> 
<blockquote> 
 <p> 为什么线程退出时只能拿到线程的退出码？</p> 
</blockquote> 
<p> 如果我们等待的是一个进程，那么当这个进程退出时，我们可以通过wait函数或是waitpid函数的输出型参数status，获取到退出进程的退出码、退出信号以及core dump标志。</p> 
<p>但是pthread_join函数无法获取到线程异常退出时的信息。<strong><span style="color:#fe2c24;">因为线程是进程内的一个执行分支，如果进程中的某个线程崩溃了，那么整个进程也会因此而崩溃</span></strong>，此时我们根本没办法执行pthread_join函数，因为整个进程已经退出了。 </p> 
<h3 id="%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%C2%A0">线程终止 </h3> 
<p>如果需要只终止某个线程而不是终止整个进程，可以有三种方法：</p> 
<ol><li>从线程函数return。</li><li>线程可以自己调用pthread_exit函数终止自己。</li><li>一个线程可以调用pthread_cancel函数终止同一进程中的另一个线程。</li></ol> 
<blockquote> 
 <p>return退出 </p> 
</blockquote> 
<p> 在线程中使用return代表当前线程退出，但是在main函数中使用return代表整个进程退出，也就是说只要主线程退出了那么整个进程就退出了，此时该进程曾经申请的资源就会被释放，而其他线程会因为没有了资源，自然而然的也退出了。</p> 
<blockquote> 
 <p> pthread_exit函数</p> 
</blockquote> 
<p>pthread_exit函数的功能就是终止线程，原型如下：</p> 
<pre><code class="language-cpp">void pthread_exit(void *retval);</code></pre> 
<p>参数说明：</p> 
<ul><li>retval：线程退出时的退出码信息。</li></ul> 
<p><strong>注意：</strong> exit函数的作用是终止进程，任何一个线程调用exit函数也代表的是整个进程终止。 </p> 
<blockquote> 
 <p>pthread_cancel函数 </p> 
</blockquote> 
<p> 线程是可以被取消的，我们可以使用pthread_cancel函数取消某一个线程，pthread_cancel函数的函数原型如下：         </p> 
<pre><code class="language-cpp">int pthread_cancel(pthread_t thread);
</code></pre> 
<p>参数说明：</p> 
<ul><li>thread：被取消线程的ID。</li></ul> 
<p>返回值说明：</p> 
<ul><li>线程取消成功返回0，失败返回错误码。</li></ul> 
<p>线程是可以取消自己的，取消成功的线程的退出码一般是-1。虽然线程可以自己取消自己，但一般不这样做，我们往往是用于一个线程取消另一个线程，比如主线程取消新线程。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;pthread.h&gt;
#include&lt;unistd.h&gt;

using namespace std;

void* Routine(void* arg)
{
	char* msg = (char*)arg;
	int count = 0;
	while (count &lt; 5){
		printf("I am %s...pid: %d, ppid: %d, tid: %lu\n", msg, getpid(), getppid(), pthread_self());
		sleep(1);
		count++;
	}
	pthread_exit((void*)6666);
}
int main()
{
	pthread_t tid[5];
	for (int i = 0; i &lt; 5; i++){
		char* buffer = (char*)malloc(64);
		sprintf(buffer, "thread %d", i);
		pthread_create(&amp;tid[i], NULL, Routine, buffer);
		printf("%s tid is %lu\n", buffer, tid[i]);
	}
	pthread_cancel(tid[0]);
	pthread_cancel(tid[1]);
	pthread_cancel(tid[2]);
	pthread_cancel(tid[3]);
	printf("I am main thread...pid: %d, ppid: %d, tid: %lu\n", getpid(), getppid(), pthread_self());
	for (int i = 0; i &lt; 5; i++){
		void* ret = NULL;
		pthread_join(tid[i], &amp;ret);
		printf("thread %d[%lu]...quit, exitcode: %d\n", i, tid[i], ret);
	}
	return 0;
}</code></pre> 
<p>此时可以发现，0、1、2、3号线程退出时的退出码不是我们设置的6666，而只有未被取消的4号线程的退出码是6666，因为只有4号进程未被取消。 此外，<strong>新线程也是可以取消主线程的</strong>。</p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/17/8c/ACVFpcaN_o.png" width="881"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e12a1540c932017b6817cac291e22b99/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mac 配置Java 环境变量</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/593ea3736531075039917996215f9c00/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CVE-2022-28060 Victor CMS v1.0 /includes/login.php 存在sql注入</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>