<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言之内存动态管理(边界标识法)源码 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言之内存动态管理(边界标识法)源码" />
<meta property="og:description" content="1 概述.... 3
2 背景.... 3
3 工作机制.... 3
4 分配机制特点.... 3
5 应用场景.... 3
6 源码文件.... 4
6.1 MemAlloc.h. 4
6.2 MemAlloc.cpp. 4
7 数组接口函数使用说明.... 16
7.1 CreateHeap(). 16
7.2 DestroyHeap (). 17
7.3 AllocMem(). 17
7.4 FreeMem(). 18
8 demo.. 19
概述 本文讲述一种的内存动态管理机制：边界标识法。关于边界标识法大家有兴趣的话可以阅读清华计算机教材《数据结构》(作者：严蔚敏、吴伟民)第八章(动态存储管理)中第3节(边界标识法)。本文主要是针对从事后台服务器程序领域讲述这种内存分配机制的应用场景和优缺点。
2.背景
本文提出的内存分配管理策略是对清华计算机教材《数据结构》(作者：严蔚敏、吴伟民)第八章(动态存储管理)中第3节(边界标识法)示例代码的整理和封装。
3. 工作机制
应用程序首先调用mallo()函数预先分配出一块内存空间，然后在这个内存空间中使用边界标识法分配出应用程序需要的内存，内存释放时，会自动合并前后紧邻的空闲块，形成更大的空闲块。
4. 分配机制特点
该机制优点是：
可以根据需要分配任意大小的空间，不需要取整。释放内存操作极快。 该机制缺点是：
1、长时间运行可能会产生大量碎片，导致内存分配的效率降低和内存的浪费。
应用场景 针对服务器程序应用场景：
1、需要连续内存空间。
2、分配内存大小范围大，从1个字节到上兆、几十兆。
3、分配的空间只是临时使用，用完就释放，不至于产生大量碎片。
另外：如果设计的软件对性能要求不高，也可以考虑使用此种内存分配机制。
5. 源码文件
5.1 MemAlloc.h
#ifndef MEMALLOC_H #define MEMALLOC_H typedef void* HANDLE; HANDLE CreateHeap(int nHeapSize); void DestroyHeap(HANDLE hHeap); void* AllocMem(HANDLE hHeap, int nSize); void FreeMem(HANDLE hHeap, void* pAddr); int GetAddrSize(void* pAddr); void FreeAllMem(HANDLE hHeap); #endif 5." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/802a1af110ad23999e5d49ea146953ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-12T18:19:03+08:00" />
<meta property="article:modified_time" content="2020-07-12T18:19:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言之内存动态管理(边界标识法)源码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong><span style="color:#0000FF;"><u><a href="#_Toc45468081" rel="nofollow">1       概述.... 3</a></u></span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#0000FF;"><u><a href="#_Toc45468082" rel="nofollow">2       背景.... 3</a></u></span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#0000FF;"><u><a href="#_Toc45468083" rel="nofollow">3       工作机制.... 3</a></u></span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#0000FF;"><u><a href="#_Toc45468084" rel="nofollow">4       分配机制特点.... 3</a></u></span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#0000FF;"><u><a href="#_Toc45468085" rel="nofollow">5       应用场景.... 3</a></u></span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#0000FF;"><u><a href="#_Toc45468086" rel="nofollow">6       源码文件.... 4</a></u></span></strong></p> 
<p style="margin-left:10.5pt;"><span style="color:#0000FF;"><u><a href="#_Toc45468087" rel="nofollow">6.1       MemAlloc.h. 4</a></u></span></p> 
<p style="margin-left:10.5pt;"><span style="color:#0000FF;"><u><a href="#_Toc45468088" rel="nofollow">6.2       MemAlloc.cpp. 4</a></u></span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#0000FF;"><u><a href="#_Toc45468089" rel="nofollow">7       数组接口函数使用说明.... 16</a></u></span></strong></p> 
<p style="margin-left:10.5pt;"><span style="color:#0000FF;"><u><a href="#_Toc45468090" rel="nofollow">7.1       CreateHeap(). 16</a></u></span></p> 
<p style="margin-left:10.5pt;"><span style="color:#0000FF;"><u><a href="#_Toc45468091" rel="nofollow">7.2       DestroyHeap (). 17</a></u></span></p> 
<p style="margin-left:10.5pt;"><span style="color:#0000FF;"><u><a href="#_Toc45468092" rel="nofollow">7.3       AllocMem(). 17</a></u></span></p> 
<p style="margin-left:10.5pt;"><span style="color:#0000FF;"><u><a href="#_Toc45468093" rel="nofollow">7.4       FreeMem(). 18</a></u></span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#0000FF;"><u><a href="#_Toc45468094" rel="nofollow">8       demo.. 19</a></u></span></strong></p> 
<p style="margin-left:0cm;"> </p> 
<ol><li> <a name="_Toc45468081"></a><a name="_Toc514845335"></a><a name="_Toc514845020"></a><a name="_Toc225732005"></a><a name="_Toc223840052"></a><a name="_Toc223839915">概述</a></li></ol> 
<p style="margin-left:0cm;">本文讲述一种的内存动态管理机制：边界标识法。关于边界标识法大家有兴趣的话可以阅读清华计算机教材《数据结构》(作者：严蔚敏、吴伟民)第八章(<strong>动态存储管理</strong>)中第3节(边界标识法)。本文主要是针对从事后台服务器程序领域讲述这种内存分配机制的应用场景和优缺点。</p> 
<p style="margin-left:0cm;"> </p> 
<p><a name="_Toc45468082">2.背景</a></p> 
<p style="margin-left:0cm;">本文提出的内存分配管理策略是对清华计算机教材《数据结构》(作者：严蔚敏、吴伟民)第八章(<strong>动态存储管理</strong>)中第3节(边界标识法)示例代码的整理和封装。</p> 
<p style="margin-left:0cm;"> </p> 
<p>3. <a name="_Toc45468083">工作机制</a></p> 
<p style="margin-left:0cm;">应用程序首先调用mallo()函数预先分配出一块内存空间，然后在这个内存空间中使用<strong>边界标识法</strong>分配出应用程序需要的内存，内存释放时，会自动合并前后紧邻的空闲块，形成更大的空闲块。</p> 
<p style="margin-left:0cm;"> </p> 
<p>4. <a name="_Toc45468084">分配机制特点</a></p> 
<p style="margin-left:0cm;">该机制优点是：</p> 
<ol><li>可以根据需要分配任意大小的空间，不需要取整。</li><li>释放内存操作极快。</li></ol> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">该机制缺点是：</p> 
<p style="margin-left:0cm;">1、长时间运行可能会产生大量碎片，导致内存分配的效率降低和内存的浪费。</p> 
<p style="margin-left:0cm;"> </p> 
<ol><li> <a name="_Toc45468085">应用场景</a></li></ol> 
<p style="margin-left:0cm;">针对服务器程序应用场景：</p> 
<p style="margin-left:0cm;">1、需要连续内存空间。</p> 
<p style="margin-left:0cm;">2、分配内存大小范围大，从1个字节到上兆、几十兆。</p> 
<p style="margin-left:0cm;">3、分配的空间只是临时使用，用完就释放，不至于产生大量碎片。</p> 
<p style="margin-left:0cm;">另外：如果设计的软件对性能要求不高，也可以考虑使用此种内存分配机制。</p> 
<p style="margin-left:0cm;"> </p> 
<p>5. <a name="_Toc45468086">源码文件</a></p> 
<p style="margin-left:0cm;"> </p> 
<p>5.1 <a name="_Toc45468087">MemAlloc.h</a></p> 
<p> </p> 
<pre><code class="language-cpp">
#ifndef MEMALLOC_H
#define MEMALLOC_H

typedef void* HANDLE;

HANDLE CreateHeap(int nHeapSize);
void DestroyHeap(HANDLE hHeap);
void* AllocMem(HANDLE hHeap, int nSize);
void FreeMem(HANDLE hHeap, void* pAddr);
int GetAddrSize(void* pAddr);
void FreeAllMem(HANDLE hHeap);

#endif

</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p>5.2  <a name="_Toc45468088">MemAlloc.cpp</a></p> 
<p> </p> 
<pre><code class="language-cpp">#include "MemAlloc.h"
#include "TagShare.h"
#include &lt;stdio.h&gt;

static AllocTail* FootLoc(AllocNode* pHead)
{	
	return (AllocTail *)((char *)pHead + pHead-&gt;nSize - sizeof(AllocTail));
}

int GetSelfUplink(AllocNode* p)
{
	return ((AllocTail *)((char *)p + p-&gt;nSize - sizeof(AllocTail)))-&gt;nUpLink;
}

static AllocNode* GetLeftNode(HeapInfo* pHeapInfo, AllocNode* p)
{
	return (AllocNode*)(pHeapInfo-&gt;pBuf + ((AllocTail *)((char *)p - sizeof(AllocTail)))-&gt;nUpLink);
}

HANDLE CreateHeap(int nHeapSize)
{	
	HeapInfo* pHeapInfo;
	pHeapInfo = (HeapInfo*)(new char[sizeof(HeapInfo) + nHeapSize + SHELL_SIZE]);	
	if(pHeapInfo == NULL)
	{
		return NULL;
	}
	pHeapInfo-&gt;nHeapSize = nHeapSize + SHELL_SIZE;	
	
	pHeapInfo-&gt;nCount = 1;
	pHeapInfo-&gt;pHead = (AllocNode *)pHeapInfo-&gt;pBuf;
	pHeapInfo-&gt;pTail = (AllocNode *)pHeapInfo-&gt;pBuf;		

	AllocNode* pNode;
	pNode = pHeapInfo-&gt;pHead;	
	
	pNode-&gt;nLeftLink = -1;
	pNode-&gt;nTag = 0;
	pNode-&gt;nSize = pHeapInfo-&gt;nHeapSize;
	pNode-&gt;nRightLink = -1;

	AllocTail* pTail;
	pTail = FootLoc(pNode);	
	pTail-&gt;nUpLink = 0;
	pTail-&gt;nTag = 0;

	return pHeapInfo;
}

void DestroyHeap(HANDLE hHeap)
{
	HeapInfo* pHeapInfo;
	pHeapInfo = (HeapInfo *)hHeap;		

	if(pHeapInfo != NULL)
	{
		delete[] (char *)pHeapInfo;
		pHeapInfo = NULL;
	}	
	
	return;
}

static void RemoveHead(HeapInfo* pHeapInfo)
{	
	pHeapInfo-&gt;nCount--;		
	
	if(pHeapInfo-&gt;pHead-&gt;nRightLink == -1)
	{
		pHeapInfo-&gt;pHead = NULL;
	}
	else
	{
		pHeapInfo-&gt;pHead = (AllocNode *)(pHeapInfo-&gt;pBuf + pHeapInfo-&gt;pHead-&gt;nRightLink);
	}	

	if(pHeapInfo-&gt;pHead != NULL)
	{	
		pHeapInfo-&gt;pHead-&gt;nLeftLink = -1;
		if(pHeapInfo-&gt;nCount == 1)
		{
			pHeapInfo-&gt;pHead-&gt;nRightLink = -1;	
		}
	}
	else
	{			
		pHeapInfo-&gt;pTail = NULL;
	}		
	
	return;
}

static void RemoveTail(HeapInfo* pHeapInfo)
{					
	pHeapInfo-&gt;nCount--;
	
	if(pHeapInfo-&gt;pTail-&gt;nLeftLink == -1)
	{
		pHeapInfo-&gt;pTail = NULL;
	}
	else
	{
		pHeapInfo-&gt;pTail = (AllocNode *)(pHeapInfo-&gt;pBuf + pHeapInfo-&gt;pTail-&gt;nLeftLink);
	}
	
	if(pHeapInfo-&gt;pTail != NULL)
	{	
		pHeapInfo-&gt;pTail-&gt;nRightLink = -1;
		if(pHeapInfo-&gt;nCount == 1)
		{
			pHeapInfo-&gt;pHead-&gt;nLeftLink = -1;
		}
	}
	else
	{			
		pHeapInfo-&gt;pHead = NULL;
	}		
	
	return;
}

static void RemoveAt(HeapInfo* pHeapInfo, AllocNode* pNode)
{	
	if(pNode == pHeapInfo-&gt;pHead)
	{
		RemoveHead(pHeapInfo);
		return;
	}
	
	if(pNode == pHeapInfo-&gt;pTail)
	{
		RemoveTail(pHeapInfo);
		return;
	}	
	
	AllocNode* pPrev;
	AllocNode* pNext;	
	
	if(pNode-&gt;nLeftLink == -1)
	{
		pPrev = NULL;
	}
	else
	{
		pPrev = (AllocNode *)(pHeapInfo-&gt;pBuf + pNode-&gt;nLeftLink);
	}
	
	if(pNode-&gt;nRightLink == -1)
	{
		pNext = NULL;
	}
	else
	{
		pNext = (AllocNode *)(pHeapInfo-&gt;pBuf + pNode-&gt;nRightLink);		
	}	
	
	if(pNext == NULL)
	{
		pPrev-&gt;nRightLink = -1;
	}
	else
	{
		if(pPrev != NULL)
		{
			pPrev-&gt;nRightLink = GetSelfUplink(pNext);
		}		
	}
	
	if(pPrev == NULL)
	{
		pNext-&gt;nLeftLink = -1;
	}
	else
	{
		if(pNext != NULL)
		{
			pNext-&gt;nLeftLink = GetSelfUplink(pPrev);
		}		
	}	
	
	pHeapInfo-&gt;nCount--;
	
	return;
}

void* AllocMem(HANDLE hHeap, int nSize)
{
	HeapInfo* pHeapInfo;
	pHeapInfo = (HeapInfo *)hHeap;

	if(pHeapInfo-&gt;nCount == 0)
	{
		return NULL;
	}

	nSize += SHELL_SIZE;

	AllocNode* p;	
	p = pHeapInfo-&gt;pHead;
	while(true)
	{
		if(p-&gt;nSize &lt; nSize)
		{	// 不符合条件
			if(p-&gt;nRightLink &lt; 0)
			{	// 循环链表构成循环
				return NULL;
			}		
			p = (AllocNode *)(pHeapInfo-&gt;pBuf + p-&gt;nRightLink);						
		}	
		else
		{	// 满足条件				
			if(p-&gt;nSize - nSize &lt;= MINI)
			{	// 把整个空闲块进行整体分配
				AllocTail* pFoot;
				pFoot = FootLoc(p);		// 取尾巴结构
				
				p-&gt;nExtraSize = p-&gt;nSize - nSize;
				p-&gt;nTag = 1;					// 设置头占用标志
				pFoot-&gt;nTag = 1;		// 设置尾占用标志					
				
				RemoveAt(pHeapInfo, p);
				return p+1;			
			}
			else
			{
				AllocTail* pOldFreeFoot;
				pOldFreeFoot = FootLoc(p);		// 取尾巴结构

				pOldFreeFoot-&gt;nTag = 1;		// 设置占用块尾巴标记（tag）：1(占用)				
				p-&gt;nSize -= nSize;	// 设置新空闲块头size: 
			
				AllocTail* pNewFreeFoot;
				pNewFreeFoot = FootLoc(p); // 获取新空闲块的foot
				pNewFreeFoot-&gt;nTag = 0;		// 设置新空闲块尾巴标记（tag）：0(空闲)
				pNewFreeFoot-&gt;nUpLink = pOldFreeFoot-&gt;nUpLink;	// 设置新空闲块的uplink				

				pOldFreeFoot-&gt;nUpLink = pNewFreeFoot-&gt;nUpLink + p-&gt;nSize;

				AllocNode* pBusyHead;
				pBusyHead = (AllocNode*)((char *)pNewFreeFoot + sizeof(AllocTail));	
				pBusyHead-&gt;nExtraSize = 0;
				pBusyHead-&gt;nTag = 1;		// p为占用块的头的标记
				pBusyHead-&gt;nSize = nSize;	// 	p为占用块的头的的size
				pBusyHead++;
				return pBusyHead;
			}			
		}
	}
}

// 左：忙 右：忙
static void FreeMem1(HeapInfo* pHeapInfo, AllocNode* p)
{
	p-&gt;nTag = 0;

	AllocTail* pFoot;
	pFoot = FootLoc(p);	
	pFoot-&gt;nTag = 0;

	if(pHeapInfo-&gt;nCount == 0)
	{		
		p-&gt;nRightLink = -1;
		p-&gt;nLeftLink = -1;
		pHeapInfo-&gt;pHead = p;
		pHeapInfo-&gt;pTail = p;
		pHeapInfo-&gt;nCount = 1;
	}
	else
	{			
		pHeapInfo-&gt;pTail-&gt;nRightLink = GetSelfUplink(p);
		p-&gt;nLeftLink = GetSelfUplink(pHeapInfo-&gt;pTail);
		p-&gt;nRightLink = -1;
		pHeapInfo-&gt;pTail = p;
		pHeapInfo-&gt;nCount++;			
	}
}

// 左：闲 右：忙
static void FreeMem2(HeapInfo* pHeapInfo, AllocNode* p)
{
	int n;
	n = p-&gt;nSize;
	
	AllocNode* pLeftNode;
	pLeftNode = GetLeftNode(pHeapInfo, p);

	int nUplink;
	nUplink = GetSelfUplink(pLeftNode);

	pLeftNode-&gt;nSize += n;

	AllocTail* pFoot;
	pFoot = FootLoc(p);
	pFoot-&gt;nUpLink = nUplink;
	pFoot-&gt;nTag = 0;	

	return;
}

// 左：忙 右：闲
static void FreeMem3(HeapInfo* pHeapInfo, AllocNode* p)
{
	AllocNode* pRightNode;		// 右邻空闲区的头
	pRightNode = (AllocNode *)((char *)p + p-&gt;nSize);	// 获取右邻空闲区的头
	p-&gt;nTag = 0;			// p为合并后的节点头部

	int nUpLink;
	nUpLink = GetSelfUplink(p);

	int nRightFreeSize;
	nRightFreeSize = pRightNode-&gt;nSize;

	RemoveAt(pHeapInfo, pRightNode);	

	p-&gt;nSize += nRightFreeSize;	
	FootLoc(p)-&gt;nUpLink = nUpLink;
	///增加一个空闲块//
	if(pHeapInfo-&gt;nCount == 0)
	{		
		p-&gt;nRightLink = -1;
		p-&gt;nLeftLink = -1;
		pHeapInfo-&gt;pHead = p;
		pHeapInfo-&gt;pTail = p;
		pHeapInfo-&gt;nCount = 1;
	}
	else
	{	
		pHeapInfo-&gt;pTail-&gt;nRightLink = GetSelfUplink(p);
		p-&gt;nLeftLink = GetSelfUplink(pHeapInfo-&gt;pTail);
		p-&gt;nRightLink = -1;
		pHeapInfo-&gt;pTail = p;
		pHeapInfo-&gt;nCount++;		
	}
	//
	return;
}

// 左：闲 右：闲
static void FreeMem4(HeapInfo* pHeapInfo, AllocNode* p)
{
	int n;
	n = p-&gt;nSize;
	
	AllocNode* pLeftNode;			// 左空闲节点
	pLeftNode = GetLeftNode(pHeapInfo, p);	

	int nUpLink;
	nUpLink = GetSelfUplink(pLeftNode);

	AllocNode* pRightNode;			// 右空闲节点
	pRightNode = (AllocNode *)((char *)p + p-&gt;nSize);

	RemoveAt(pHeapInfo, pRightNode);

	pLeftNode-&gt;nSize += n + pRightNode-&gt;nSize;	
	
	FootLoc(pLeftNode)-&gt;nUpLink = nUpLink;	

	return;
}

void FreeMem(HANDLE hHeap, void* pAddr)
{
	HeapInfo* pHeapInfo;
	pHeapInfo = (HeapInfo*)hHeap;

	AllocNode* p;
	p = (AllocNode *)pAddr;
	p--;

	if((char *)p == pHeapInfo-&gt;pBuf)
	{	// 释放地址为堆的头		
		if(pHeapInfo-&gt;nCount == 0)
		{	// 没有空闲
			FreeMem1(pHeapInfo, p);
			return ;
		}		

		AllocNode* pRightHead;		// 右邻空闲区的头
		pRightHead = (AllocNode *)((char *)p + p-&gt;nSize);	// 获取右邻空闲区的头

		int nRightTag;	
		nRightTag = pRightHead-&gt;nTag;

		int nLeftTag;	
		nLeftTag = 1;

		if(nRightTag == 1)
		{	// 右忙
			FreeMem1(pHeapInfo, p);
			return ;
		}
		else
		{	// 右闲
			FreeMem3(pHeapInfo, p);
			return ;
		}
	}

	char* pTail;
	pTail = (char *)p + p-&gt;nSize;
	if(pTail == pHeapInfo-&gt;pBuf + pHeapInfo-&gt;nHeapSize)
	{		
		if(pHeapInfo-&gt;nCount == 0)
		{	// 没有空闲
			FreeMem1(pHeapInfo, p);
			return ;
		}		

		int nLeftTag;	
		nLeftTag = ((AllocTail *)((char*)p-sizeof(AllocTail)))-&gt;nTag;

		int nRightTag;	
		nRightTag = 1;
		if(nLeftTag == 1)
		{	// 左忙
			FreeMem1(pHeapInfo, p);
			return ;
		}
		else
		{	// 左闲
			FreeMem2(pHeapInfo, p);
			return ;
		}		
	}

	int nLeftTag;	
	nLeftTag = ((AllocTail *)((char*)p-sizeof(AllocTail)))-&gt;nTag;

	AllocNode* pRightHead;		// 右邻空闲区的头
	pRightHead = (AllocNode *)((char *)p + p-&gt;nSize);	// 获取右邻空闲区的头

	int nRightTag;	
	nRightTag = pRightHead-&gt;nTag;

	if (nLeftTag == 1 &amp;&amp; nRightTag == 1)
	{
		FreeMem1(pHeapInfo, p);
		return ;
	}

	if (nLeftTag == 0 &amp;&amp; nRightTag == 1)
	{
		FreeMem2(pHeapInfo, p);
		return ;
	}

	if (nLeftTag == 1 &amp;&amp; nRightTag == 0)
	{
		FreeMem3(pHeapInfo, p);
		return ;
	}

	if (nLeftTag == 0 &amp;&amp; nRightTag == 0)
	{
		FreeMem4(pHeapInfo, p);
		return ;
	}

	printf("error");

	return ;
}


int GetAddrSize(void* pAddr)
{
	AllocNode* p;
	p = (AllocNode *)pAddr;
	p--;
	return (p-&gt;nSize - sizeof(AllocNode) - sizeof(AllocTail) - p-&gt;nExtraSize);
}

void FreeAllMem(HANDLE hHeap)
{
	HeapInfo* pHeapInfo;
	pHeapInfo = (HeapInfo *)hHeap;	
	
	pHeapInfo-&gt;nCount = 1;
	pHeapInfo-&gt;pHead = (AllocNode *)pHeapInfo-&gt;pBuf;
	pHeapInfo-&gt;pTail = (AllocNode *)pHeapInfo-&gt;pBuf;		
	
	AllocNode* pNode;
	pNode = pHeapInfo-&gt;pHead;	
	
	pNode-&gt;nLeftLink = -1;
	pNode-&gt;nTag = 0;
	pNode-&gt;nSize = pHeapInfo-&gt;nHeapSize;
	pNode-&gt;nRightLink = -1;
	
	AllocTail* pTail;
	pTail = FootLoc(pNode);	
	pTail-&gt;nUpLink = 0;
	pTail-&gt;nTag = 0;
	return;
}
</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p>6.  <a name="_Toc45468089"></a><a name="_Toc45458513">数组接口函数使用说明</a></p> 
<p>6.1 <a name="_Toc45468090"></a><a name="_Toc45458514"></a><a name="_Toc465588761"></a><a name="_Toc366661722"></a><a name="_Toc332375977"></a><a name="_Toc249088907"></a><a name="_Toc248739020"></a><a name="_Toc248292032"></a><a name="_Toc241701238">CreateHeap()</a></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>1</strong><strong>、功能说明</strong></p> 
<p style="margin-left:0cm;">此函数用来生成一个内存堆数据结构，执行成功后返回一个句柄，之后分配和释放内存的操作都引用此句柄。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>2</strong><strong>、函数原型</strong></p> 
<p style="margin-left:0cm;">HANDLE CreateHeap(int nHeapSize);</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>3</strong><strong>、参数说明</strong></p> 
<ol><li>int nHeapSize</li></ol> 
<p style="margin-left:0cm;">    输入参数。堆空间的大小, 单位字节, nHeapSize必须大于0。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>4</strong><strong>、返回值</strong></p> 
<p style="margin-left:0cm;">执行成功返回非NULL的句柄，执行失败时返回NULL。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>5</strong><strong>、相关函数</strong></p> 
<p style="margin-left:0cm;">   DestroyHeap(HANDLE hHeap)</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p>6.2 <a name="_Toc45468091"></a><a name="_Toc45458515"></a><a name="_Toc465588762"></a><a name="_Toc366661723"></a><a name="_Toc332375978">DestroyHeap ()</a></p> 
<p style="margin-left:0cm;"><strong>1</strong><strong>、功能说明</strong></p> 
<p style="margin-left:0cm;">此函数用来释放指定的堆数据结构以及占用的内存。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>2</strong><strong>、函数原型</strong></p> 
<p style="margin-left:0cm;">void DestroyHeap(HANDLE hHeap);</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>3</strong><strong>、参数说明</strong></p> 
<p style="margin-left:0cm;">   1）HANDLE hHeap</p> 
<p style="margin-left:0cm;">      输入参数，hHeap是执行CreateHeap函数返回的句柄。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>4</strong><strong>、返回值</strong></p> 
<p style="margin-left:0cm;">    无。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>5</strong><strong>、相关函数</strong></p> 
<p style="margin-left:0cm;">   CreateHugeArray()</p> 
<p style="margin-left:0cm;"> </p> 
<p><a name="_Toc241701239">6.3 </a><a name="_Toc45468092"></a><a name="_Toc45458516"></a><a name="_Toc465588763"></a><a name="_Toc366661724"></a><a name="_Toc332375979"></a>AllocMem()</p> 
<p style="margin-left:0cm;"><strong>1</strong><strong>、功能说明</strong></p> 
<p style="margin-left:0cm;">此函数用来根据数组索引下标获指定取数组元素地址。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>2</strong><strong>、函数原型</strong></p> 
<p style="margin-left:0cm;">Void* AllocHeap(HANDLE hHeap, int nSize);</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>3</strong><strong>、参数说明</strong></p> 
<p style="margin-left:0cm;">   1）HANDLE hHeap</p> 
<p style="margin-left:0cm;">      输入参数，hHeap是执行CreateHeap函数返回的句柄。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">2）int nSize</p> 
<p style="margin-left:0cm;">      输入参数，申请内存的大小，单位：字节。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>4</strong><strong>、返回值</strong></p> 
<p style="margin-left:0cm;">    地址指针</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>5</strong><strong>、相关函数</strong></p> 
<p style="margin-left:0cm;">   FreeMem()</p> 
<p style="margin-left:0cm;"> </p> 
<p>6.4 <a name="_Toc45468093">FreeMem()</a></p> 
<p style="margin-left:0cm;"><strong>1</strong><strong>、功能说明</strong></p> 
<p style="margin-left:0cm;">此函数用来根据数组索引下标获指定取数组元素地址。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>2</strong><strong>、函数原型</strong></p> 
<p style="margin-left:0cm;">Void FreeMem(HANDLE hHeap,void* pAddr);</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>3</strong><strong>、参数说明</strong></p> 
<p style="margin-left:0cm;">   1）HANDLE hHeap</p> 
<p style="margin-left:0cm;">      输入参数，hHeap是执行CreateHeap函数返回的句柄。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">2）void* pAddr</p> 
<p style="margin-left:0cm;">      输入参数，要释放内存的地址，这个地址必须是之前通过AllocMem函数返回的</p> 
<p style="margin-left:0cm;">     地址。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>4</strong><strong>、返回值</strong></p> 
<p style="margin-left:0cm;">    无</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>5</strong><strong>、相关函数</strong></p> 
<p style="margin-left:0cm;">   AllocMem()</p> 
<p style="margin-left:0cm;"> </p> 
<p><a name="_Toc45468094">7. demo</a></p> 
<p> </p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "MemAlloc.h"

int main(int argc, char* argv[])
{
	HANDLE hHeap;
	hHeap = CreateHeap(10*1024*1024);
	
	void* pAddrArray[1024];

	int i;
	for (i = 0; i &lt; 1024; i++)
	{
		pAddrArray[i] = AllocMem(hHeap, 256);
	}

	for (i = 0; i &lt; 1024; i++)
	{
		strcpy(pAddrArray[i], "1234567890");
	}

	for (i = 0; i &lt; 1024; i++)
	{
		printf("%s\r\n", pAddrArray[i]);
	}

	for (i = 0; i &lt; 1024; i++)
	{
		FreeMem(hHeap, pAddrArray[i]);
	}

	DestroyHeap(hHeap);

	return 0;
}

</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2cbeedcd8339bced5f1cf532a001bd0e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">虚幻4敌人受伤并被击退的逻辑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e2592884025ec703a6fe665e874186e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PyTorch 使用 TensorBoard 中的 writer.add_scalar 与 writer.add_scalars 的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>