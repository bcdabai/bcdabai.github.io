<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二叉排序树之红黑树 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二叉排序树之红黑树" />
<meta property="og:description" content="﻿﻿ 红黑树的介绍
先来看下算法导论对R-BTree的介绍：
红黑树，一种二叉搜索树（BinarySearch Tree，BST），但在每个结点上增加一个存储位表示结点的颜色，可以是RED或BLACK。既然它是一种BST，它就具有BST的一般性质。
通过对任何一条从根结点到叶子结点的路径上结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。这里，必须要注意，红黑树不像AVL，是高度平衡的BST，红黑树不是绝对平衡的，它存在某结点的左右子树高度差大于二的情况。
红黑树上每个结点内一般含五个域：[parent，left，right，color，key]，分别是指向父结点指针、指向左孩子结点指针、指向右孩子结点指针、结点颜色和结点键值。如果相应的指针域没有，则设为NIL。
红黑树的NIL结点，并非NULL指针，也不同于普通的树结点，它的颜色固定为BLACK，指针域中左右孩子通常固定指向NULL，可以不存在键值项和数据项。由于红黑树中的所有叶子结点的左右孩子和根结点的父结点指针都要指向NIL结点，如果为每个指针分配不同的NIL结点，必然造成内存浪费。因此，在红黑树的具体实现中，我们仅构造一个NIL结点，然后让所有叶子结点指向左右孩子的指针和根结点指向父结点的指针都来指向这个唯一的NIL结点。
注：此处叙述的叶子结点，不同于下文陈述红黑树性质的叶子结点即NIL结点，是具有实际意义的树内数据结点。
红黑树的性质
玩游戏，就得遵守游戏规则；人类社会的发展也伴随着制度法规的发展；就连咱们技术积累的撰写和评审也不例外，也有一定的标准或要求。要想参与进来，就得了解并接受规则！
红黑树也不例外，它有一套自己的规则，只是相对小众了些。接下来，让我们先了解一下。
一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：
1）每个结点要么是红的，要么是黑的；
2）根结点是黑的；
3）每个叶结点，即空结点（NIL）是黑的；
4）如果一个结点是红的，那么它的两个孩子都是黑的；
5）对每个结点，从该结点到其子孙结点的所有路径上都包含相同数目的黑结点。
下图所示，即是一颗红黑树。此图忽略了NIL结点。
当我们在对红黑树进行插入和删除等操作时，由于树发生了变化，那么就可能会违背红黑树的基本性质。为了保持红黑树的性质，我们可以通过对树进行旋转，即修改树中某些结点的颜色及指针指向，以达到插入、删除操作后，红黑树依然保持它特有的性质（即上文所述的五点性质）。
旋转
对树进行旋转，能保持不变的只有原树的有序搜索特性，而原树的红黑性质则不能保持，所以在红黑树的结点插入或删除后，需要采用旋转和颜色重涂来恢复树的红黑性质。红黑树的旋转，仅需要使用两种单旋，即左旋和右旋。具体详见上一篇技术积累《二叉搜索树之AVL树》，这里仅给出算法导论里左旋操作的伪码，不再重述。
LEFT-ROTATE(T, x) //T指代树的管理根结构，x为旋转根结点
1 y ← right[x] //Set y
2 right[x] ← left[y] //Turn y&#39;s left subtreeinto x&#39;s right subtree.
3 p[left[y]] ← x
4 p[y] ← p[x] //Link x&#39;s parent to y.
5 if p[x] = nil[T]
6 then root[T] ← y
7 elseif x = left[p[x]]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/855fbb160a73c746e7c39ae5a2656ccf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-16T19:32:55+08:00" />
<meta property="article:modified_time" content="2020-08-16T19:32:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二叉排序树之红黑树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div>
  ﻿﻿ 
</div> 
<p style="margin-left:0cm;"><strong>红黑树的介绍</strong></p> 
<p style="margin-left:0cm;">先来看下算法导论对R-BTree的介绍：</p> 
<p style="margin-left:0cm;">红黑树，一种二叉搜索树（BinarySearch Tree，BST），但在每个结点上增加一个存储位表示结点的颜色，可以是RED或BLACK。既然它是一种BST，它就具有BST的一般性质。</p> 
<p style="margin-left:0cm;">通过对任何一条从根结点到叶子结点的路径上结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。这里，必须要注意，红黑树不像AVL，是高度平衡的BST，红黑树不是绝对平衡的，它存在某结点的左右子树高度差大于二的情况。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">红黑树上每个结点内一般含五个域：[parent，left，right，color，key]，分别是指向父结点指针、指向左孩子结点指针、指向右孩子结点指针、结点颜色和结点键值。如果相应的指针域没有，则设为NIL。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">红黑树的NIL结点，并非NULL指针，也不同于普通的树结点，它的颜色固定为BLACK，指针域中左右孩子通常固定指向NULL，可以不存在键值项和数据项。由于红黑树中的所有叶子结点的左右孩子和根结点的父结点指针都要指向NIL结点，如果为每个指针分配不同的NIL结点，必然造成内存浪费。因此，在红黑树的具体实现中，我们仅构造一个NIL结点，然后让所有叶子结点指向左右孩子的指针和根结点指向父结点的指针都来指向这个唯一的NIL结点。</p> 
<p style="margin-left:0cm;"><em>注：此处叙述的叶子结点，不同于下文陈述红黑树性质的叶子结点即NIL结点，是具有实际意义的树内数据结点。</em></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>红黑树的性质</strong></p> 
<p style="margin-left:0cm;">玩游戏，就得遵守游戏规则；人类社会的发展也伴随着制度法规的发展；就连咱们技术积累的撰写和评审也不例外，也有一定的标准或要求。要想参与进来，就得了解并接受规则！</p> 
<p style="margin-left:0cm;">红黑树也不例外，它有一套自己的规则，只是相对小众了些。接下来，让我们先了解一下。</p> 
<p style="margin-left:0cm;">一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：</p> 
<p style="margin-left:0cm;">1）每个结点要么是红的，要么是黑的；</p> 
<p style="margin-left:0cm;">2）根结点是黑的；</p> 
<p style="margin-left:0cm;">3）每个叶结点，即空结点（NIL）是黑的；</p> 
<p style="margin-left:0cm;">4）如果一个结点是红的，那么它的两个孩子都是黑的；</p> 
<p style="margin-left:0cm;">5）对每个结点，从该结点到其子孙结点的所有路径上都包含相同数目的黑结点。</p> 
<p style="margin-left:0cm;">下图所示，即是一颗红黑树。此图忽略了NIL结点。</p> 
<p style="margin-left:0cm;"><img alt="" height="194" src="https://images2.imgbox.com/28/d2/VxfcsFgn_o.png" width="552"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">当我们在对红黑树进行插入和删除等操作时，由于树发生了变化，那么就可能会违背红黑树的基本性质。为了保持红黑树的性质，我们可以通过对树进行旋转，即修改树中某些结点的颜色及指针指向，以达到插入、删除操作后，红黑树依然保持它特有的性质（即上文所述的五点性质）。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>旋转</strong></p> 
<p style="margin-left:0cm;">对树进行旋转，能保持不变的只有原树的有序搜索特性，而原树的红黑性质则不能保持，所以在红黑树的结点插入或删除后，需要采用旋转和颜色重涂来恢复树的红黑性质。红黑树的旋转，仅需要使用两种单旋，即左旋和右旋。具体详见上一篇技术积累《二叉搜索树之AVL树》，这里仅给出算法导论里左旋操作的伪码，不再重述。</p> 
<p style="margin-left:0cm;">LEFT-ROTATE(T, x)          //T指代树的管理根结构，x为旋转根结点<br> 1  y ← right[x]                //Set y</p> 
<p style="margin-left:0cm;">2  right[x] ← left[y]           //Turn y's left subtreeinto x's right subtree.</p> 
<p style="margin-left:0cm;">3  p[left[y]] ← x</p> 
<p style="margin-left:0cm;">4  p[y] ← p[x]                //Link x's parent to y.</p> 
<p style="margin-left:0cm;">5  if p[x] = nil[T]</p> 
<p style="margin-left:0cm;">6     then root[T] ← y</p> 
<p style="margin-left:0cm;">7     elseif x = left[p[x]]</p> 
<p style="margin-left:0cm;">8             then left[p[x]] ← y</p> 
<p style="margin-left:0cm;">9             else right[p[x]] ← y</p> 
<p style="margin-left:0cm;">10  left[y] ← x                //Put x on y'sleft.</p> 
<p style="margin-left:0cm;">11  p[x] ← y</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">红黑树的结点插入</p> 
<p style="margin-left:0cm;">算法导论给出的伪码如下：</p> 
<p style="margin-left:0cm;">RB-INSERT(T, z)</p> 
<p style="margin-left:0cm;"> 1  y ← nil[T]</p> 
<p style="margin-left:0cm;"> 2  x ← root[T]</p> 
<p style="margin-left:0cm;"> 3  while x ≠ nil[T]           //注意是和指向NIL的指针比较</p> 
<p style="margin-left:0cm;"> 4      do y← x</p> 
<p style="margin-left:0cm;"> 5        if key[z] &lt; key[x]</p> 
<p style="margin-left:0cm;"> 6           then x ← left[x]</p> 
<p style="margin-left:0cm;"> 7           else x ← right[x]</p> 
<p style="margin-left:0cm;"> 8  p[z] ← y                //p[z]为查找到的新插入结点的父结点</p> 
<p style="margin-left:0cm;"> 9  if y = nil[T]</p> 
<p style="margin-left:0cm;">10     then root[T] ← z</p> 
<p style="margin-left:0cm;">11     else if key[z]&lt; key[y]</p> 
<p style="margin-left:0cm;">12            then left[y] ← z</p> 
<p style="margin-left:0cm;">13            else right[y] ← z</p> 
<p style="margin-left:0cm;">14  left[z] ← nil[T]</p> 
<p style="margin-left:0cm;">15  right[z] ← nil[T]</p> 
<p style="margin-left:0cm;">16  color[z] ← RED          //新插入结点颜色初始化为RED</p> 
<p style="margin-left:0cm;">17  RB-INSERT-FIXUP(T, z)</p> 
<p style="margin-left:0cm;">伪码1-13行与一般的BST结点插入算法过程无异：第1-8行是查找新插入结点的父结点，当然在第5-7行，我们可以考虑过滤键值相等的结点；伪码9-13是对新插入结点进行合理链接。伪码14-16是新插入结点的初始化。下面我们重点分析第17行，也就是红黑树的插入操作的平衡处理过程。</p> 
<p style="margin-left:0cm;">RB-INSERT-FIXUP(T, z)，伪码如下所示：</p> 
<p style="margin-left:0cm;"> 1 while color[p[z]] = RED</p> 
<p style="margin-left:0cm;"> 2     do if p[z]= left[p[p[z]]]</p> 
<p style="margin-left:0cm;"> 3          then y ← right[p[p[z]]]</p> 
<p style="margin-left:0cm;"> 4               if color[y] = RED</p> 
<p style="margin-left:0cm;"> 5                  then color[p[z]] ←BLACK              ▹ Case 1</p> 
<p style="margin-left:0cm;"> 6                       color[y] ←BLACK                      ▹ Case 1</p> 
<p style="margin-left:0cm;"> 7                       color[p[p[z]]] ←RED                  ▹ Case 1</p> 
<p style="margin-left:0cm;"> 8                       z ←p[p[z]]                               ▹Case 1</p> 
<p style="margin-left:0cm;"> 9                  else if z = right[p[z]]</p> 
<p style="margin-left:0cm;">10                          then z ←p[z]                          ▹Case 2</p> 
<p style="margin-left:0cm;">11                               LEFT-ROTATE(T,z)             ▹ Case 2</p> 
<p style="margin-left:0cm;">12                          color[p[z]] ←BLACK                ▹ Case 3</p> 
<p style="margin-left:0cm;">13                          color[p[p[z]]] ←RED                ▹ Case 3</p> 
<p style="margin-left:0cm;">14                          RIGHT-ROTATE(T, p[p[z]])        ▹ Case 3</p> 
<p style="margin-left:0cm;">15          else (same as then clause</p> 
<p style="margin-left:0cm;">                        with "right" and "left" exchanged)</p> 
<p style="margin-left:0cm;">16 color[root[T]] ← BLACK</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">上面已经指出，新插入结点颜色为RED。因此，如果插入结点是根结点，红黑树的性质2会被破坏；如果插入结点的父结点是红色，则会破坏性质4。总而言之，插入一个新结点只会破坏性质2或性质4。</p> 
<p style="margin-left:0cm;">可采用的基本恢复策略为：其一，把违背红黑树性质的结点向上移，如果能移到根结点，那么就可以直接修改根结点来恢复红黑树的性质；其二，穷举所有违背红黑树性质的可能情况，进行归类处理。</p> 
<p style="margin-left:0cm;">1）插入的是根结点。</p> 
<p style="margin-left:0cm;">原树是空树，此情况只会违反性质2，直接把结点涂为黑色。</p> 
<p style="margin-left:0cm;">2）插入的结点的父结点是黑色。</p> 
<p style="margin-left:0cm;">红黑树性质保持，不做任何处理。</p> 
<p style="margin-left:0cm;">3）当前结点的父结点是红色，且祖父结点的另一个子结点（叔叔结点）是红色。</p> 
<p style="margin-left:0cm;">此时祖父一定存在且为黑色，否则插入前就已不是红黑树。此处，分为父结点是祖父结点的左孩子还是右孩子两种情况，由于对称性，我们只考虑父结点为祖父结点左孩子的情况，而当前结点是其父结点的左孩子还是右孩子这两种情况的处理方式相同。</p> 
<p style="margin-left:0cm;">对策如上述伪码5-8行的Case 1，即将当前结点的父结点和叔叔结点涂黑，祖父结点涂红，把当前结点指向祖父结点，从新的当前结点重新开始算法。</p> 
<p style="margin-left:0cm;"><span style="color:#000000;"><span style="color:#000000;"><img alt="" height="176" src="https://images2.imgbox.com/0e/60/XdK0kHTS_o.png" width="504"></span></span></p> 
<p style="margin-left:0cm;">4）当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的右孩子。</p> 
<p style="margin-left:0cm;">对策如Case 2：当前节点的父结点做为新的当前结点，以新当前结点为旋转根结点进行左旋操作。则Case 2转化为Case 3。</p> 
<p style="margin-left:0cm;">5）当前结点的父结点是红色，叔叔结点是黑色，当前节点是其父结点的左孩子。</p> 
<p style="margin-left:0cm;">对策如Case 3：父结点变为黑色，祖父结点变为红色，再以祖父结点为旋转根结点进行右旋操作。Case 3处理后，由于color[p[z]]为BLACK，就会跳出整个while循环，平衡处理结束。</p> 
<p style="margin-left:0cm;"><span style="color:#0000FF;"><span style="color:#0000FF;"><img alt="" height="135" src="https://images2.imgbox.com/35/72/DfLivRHg_o.png" width="528"></span></span></p> 
<p style="margin-left:0cm;">最后，将根结点涂成黑色，此即红黑树的平衡处理过程。可以看出，唯一需要循环下去的就是Case 1，故对于一个深度为N的红黑树，RB-INSERT-FIXUP(T, z)的算法复杂度为O（lgN），并且整个调整过程最多执行两次旋转，即执行了Case 2和Case 3。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">红黑树的结点删除</p> 
<p style="margin-left:0cm;">算法导论给出的伪码如下：</p> 
<p style="margin-left:0cm;">RB-DELETE(T, z)</p> 
<p style="margin-left:0cm;"> 1 if left[z] = nil[T] or right[z] =nil[T]</p> 
<p style="margin-left:0cm;"> 2    then y ← z</p> 
<p style="margin-left:0cm;"> 3    else y ←TREE-SUCCESSOR(z)</p> 
<p style="margin-left:0cm;"> 4 if left[y] ≠ nil[T]</p> 
<p style="margin-left:0cm;"> 5    then x ← left[y]</p> 
<p style="margin-left:0cm;"> 6    else x ← right[y]</p> 
<p style="margin-left:0cm;"> 7 p[x] ← p[y]</p> 
<p style="margin-left:0cm;"> 8 if p[y] = nil[T]</p> 
<p style="margin-left:0cm;"> 9    then root[T] ← x</p> 
<p style="margin-left:0cm;">10    else if y = left[p[y]]</p> 
<p style="margin-left:0cm;">11           then left[p[y]] ← x</p> 
<p style="margin-left:0cm;">12           else right[p[y]] ← x</p> 
<p style="margin-left:0cm;">13 if y ≠ z</p> 
<p style="margin-left:0cm;">14    then key[z] ← key[y]</p> 
<p style="margin-left:0cm;">15        copy y's satellite data into z</p> 
<p style="margin-left:0cm;">16 if color[y] = BLACK</p> 
<p style="margin-left:0cm;">17    thenRB-DELETE-FIXUP(T, x) </p> 
<p style="margin-left:0cm;">18 return y</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">伪码1-15行即通常BST结点删除算法过程：第1-3行是根据删除结点的左右孩子情况，决定实际删除的结点y是待删结点本身还是其后继（或前驱）结点；第4-12分离y结点，并重新处理树结点的链接关系；第13-15行，若实际删除的是后继结点，把数据拷贝给待删结点，这是一个补丁，实际上可以紧接在第3行之后处理；第16-17行，即红黑树的删除操作的平衡处理过程，只有当实际删除结点的颜色为黑时，才调用RB-DELETE-FIXUP(T, x) 处理，因为若y非黑色，即为红色，则当y被删除时，红黑性质仍然保持：1）树中各结点的黑高度都没有变化，满足第5条性质；2）不存在两个相邻的红色结点，满足第4条性质；3）若y是红色的，就不可能是树的根结点，根结点继续保持原来的黑色，满足第2条性质；其他两条性质只是满足，不用说了。</p> 
<p style="margin-left:0cm;">在重点讨论红黑树删除操作的平衡处理过程之前，我先简述一下删除一个黑色结点对红黑树性质的影响，以便读者更好地理解后续的平衡处理过程。</p> 
<p style="margin-left:0cm;">当实际删除的结点y为黑色，会引起三点问题：</p> 
<ol><li> <p>若y是树根结点，可能它的一个红色孩子结点变为新的根结点，这违背性质2；</p> </li><li> <p>若x和p[y]（也即p[x]）都为红色，则违背性质4；</p> </li><li> <p>结点y的删除，将使得任何原本经过y的路径比其它路径缺少一个黑色结点，即违背了性质5。可通过认定x有一重额外的黑色来解决该问题，则x成为二重黑结点或红黑复合结点，这个满足了性质5，却违背了性质1。x的颜色属性依然要么为红（若x为红黑复合结点），要么为黑（若x为二重黑结点），额外的一重黑色反映在程序算法中x的指向上。</p> <p>因此，红黑树删除黑色结点归结为违背性质1，2和4。</p> <p>算法导论给出的伪码如下：</p> <p>RB-DELETE-FIXUP(T, x)<br>  1 while x ≠ root[T] and color[x] = BLACK<br>  2     do if x = left[p[x]]<br>  3           then w ←right[p[x]]<br>  4               if color[w] = RED<br>  5                  then color[w] ←BLACK                       ▹  Case 1<br>  6                       color[p[x]] ←RED                          ▹  Case 1<br>  7                       LEFT-ROTATE(T,p[x])                    ▹  Case 1<br>  8                       w ←right[p[x]]                             ▹  Case 1<br>  9               if color[left[w]] = BLACK and color[right[w]] = BLACK<br> 10                  then color[w] ←RED                         ▹  Case 2<br> 11                       x ←p[x]                                     ▹  Case 2<br> 12                  else if color[right[w]] = BLACK<br> 13                          then color[left[w]] ←BLACK          ▹  Case 3<br> 14                               color[w] ← RED                      ▹ Case 3<br> 15                               RIGHT-ROTATE(T, w)              ▹  Case 3<br> 16                               w ← right[p[x]]                      ▹  Case 3<br> 17                        color[w] ←color[p[x]]                 ▹  Case 4<br> 18                        color[p[x]] ←BLACK                   ▹  Case 4<br> 19                        color[right[w]] ←BLACK             ▹  Case 4<br> 20                        LEFT-ROTATE(T,p[x])                 ▹  Case 4<br> 21                        x ← root[T]                                ▹  Case 4<br> 22        else (same as then clause with"right" and "left" exchanged)<br> 23 color[x] ← BLACK </p> <p>显然地，上述平衡处理过程可分为四种情况（以x为父结点的左孩子为例）：</p> <p>Case1：x的兄弟w是红色的。</p> <p><img alt="" height="139" src="https://images2.imgbox.com/c2/41/IlJUq5wN_o.png" width="552"></p> <p> 5                  then color[w] ←BLACK                    ▹  Case 1<br>  6                       color[p[x]] ←RED                         ▹  Case 1<br>  7                       LEFT-ROTATE(T,p[x])                  ▹  Case 1<br>  8                       w ←right[p[x]]                             ▹  Case 1</p> <p>对策：改变结点w和父结点p[x]的颜色，再以p[x]为旋转根结点做一次左旋，红黑性质得以继续保持。x的新兄弟new w是旋转之前w的左孩子，必定为黑色。</p> <p>所以，Case1转化成Case2或3、4。</p> <p>Case2：x的兄弟w是黑色的，且w的俩个孩子都是黑色的。</p> <p><img alt="" height="148" src="https://images2.imgbox.com/5c/85/KjbMopjU_o.png" width="552"></p> <p>10                  then color[w] ←RED                  ▹  Case 2<br> 11                       x&lt;-p[x]                                   ▹  Case 2<br> 对策：因为w也是黑色的，所以x和w都抽取一重黑色，上移给p[x]，则w变为红。</p> <p>设置p[x]为新的x结点。</p> <p>Case3：x的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。</p> <p><img alt="" height="155" src="https://images2.imgbox.com/12/1c/v3WtDljg_o.png" width="552"></p> <p>13                          then color[left[w]] ←BLACK          ▹  Case 3<br> 14                               color[w] ←RED                     ▹  Case 3<br> 15                               RIGHT-ROTATE(T, w)              ▹  Case 3<br> 16                               w ← right[p[x]]                      ▹  Case 3<br> 对策：改变结点w和其左孩子left[w]的颜色，并以w为旋转根结点右旋，而红黑性质仍然得以保持。现在x的新兄弟w是一个有红色右孩子的黑结点，则Case3转化为Case4。</p> <p>Case4：x的兄弟w是黑色的，且w的右孩子为红色。</p> <p><img alt="" height="143" src="https://images2.imgbox.com/93/24/VBJ7tmiD_o.png" width="552"></p> <p>17                        color[w] ←color[p[x]]                ▹  Case 4<br> 18                        color[p[x]] ←BLACK                   ▹ Case 4<br> 19                        color[right[w]] ←BLACK            ▹ Case 4<br> 20                        LEFT-ROTATE(T,p[x])               ▹  Case 4<br> 21                        x ←root[T]                               ▹  Case 4<br> 对策：把p[x]的颜色赋给w，p[x]颜色涂为黑色，并以p[x]为旋转根结点进行左旋，则可去掉x的额外一重黑色，此举不破坏红黑性质。将x置为根后，循环结束。</p> <p>最后，将x涂成黑色，删除过程的平衡处理过程结束。可以看出，唯一需要循环下去的就是Case2，只需修改一个结点颜色和指针上移；而若进入Case1，3和4，经过固定几次颜色调整和至多3次旋转后，算法终止，故对于一个深度为N的红黑树，RB-DELETE-FIXUP(T,x)的算法复杂度依然为O（lgN）。</p> <p> </p> <p><strong>结束语</strong></p> <p>本文主要阐述了红黑树的插入删除操作，重点讨论了插入和删除操作对红黑树性质破坏后的恢复算法过程。文章最后给出具体的代码实现。</p> <p> </p> <p>///</p> </li></ol> 
<p>以下源码已在VC6.0上验证通过。</p> 
<p style="margin-left:0cm;"> /*****************************************************************<br>  * 文件名：RBTree.c<br>  * 需求：  实现RBTree的插入、删除、查找、遍历等基本功能<br>  * 作者：  韩立忠  2012.04.28<br>  ****************************************************************/</p> 
<p>/************************* 引入的头文件 *************************/</p> 
<p>#include &lt;stdio.h&gt;<br> #include &lt;stdlib.h&gt;<br> #include &lt;memory.h&gt;<br> #include &lt;assert.h&gt;</p> 
<p>/**************************** 宏定义 ****************************/</p> 
<p>#define DEBUG_VERSION</p> 
<p>#if defined DEBUG_VERSION<br> #define ASSERT(x) assert(x)<br> #else<br> #define ASSERT(x) NULL<br> #endif</p> 
<p> </p> 
<p>/* 宏定义 */<br> #define INVAILD_VALUE (0xcccccccc)<br> #define STACK_SIZE    (40)</p> 
<p>/************************* 定义数据结构 *************************/</p> 
<p>/* 函数返回值的枚举 */<br> enum<br> {<!-- --><br>  FALSE = 0,<br>  TRUE  = 1,<br>  ERROR = INVAILD_VALUE<br> };</p> 
<p>/* typedefs */<br> typedef int status_t;<br> typedef int key_t;<br> //typedef int data_t;</p> 
<p>/* 定义RBTree结点颜色枚举类型 */<br> typedef enum COLOR_E<br> {<!-- --><br>  RED = 0,   /* 红色 */<br>  BLACK = 1  /* 黑色 */<br> }color_e;</p> 
<p> </p> 
<p>/* 定义RBTree结点相对于父结点位置关系的枚举类型 */<br> typedef enum POS_E<br> {<!-- --><br>  NONE = INVAILD_VALUE,<br>  LCHILD = 0, /* 标识本结点为父结点的左孩子 */<br>  RCHILD = 1, /* 标识本结点为父结点的右孩子 */<br>  DEGREE      /* 标识树结点的度 */<br> }pos_e;</p> 
<p> </p> 
<p>/* 定义RBTree的数据结点 */<br> typedef struct rbNode_s<br> {<!-- --><br>  struct rbNode_s *parent;        /* 指向双亲的指针 */<br>  struct rbNode_s *child[DEGREE]; /* 指向孩子的指针 */<br>  color_e color;                  /* 结点颜色 */<br> }rbNode_t;</p> 
<p> </p> 
<p>/* 用户定义的RBTree树数据结点 */<br> typedef struct myRbNode_s<br> {<!-- --><br>  void *parent;         /* 指向双亲的指针 */<br>  void *child[DEGREE];  /* 指向孩子的指针 */<br>  color_e color;        /* 结点颜色 */<br>  key_t key;            /* 键值项 */<br>  //data_t data;          /* 数据项 */<br> }myRbNode_t;</p> 
<p>/************************* 定义回调函数 *************************/</p> 
<p>typedef int (*nodeCmp_f)(void *, void *);<br> typedef void (*nodeCpy_f)(void *, void *);<br> typedef void (*nodeFree_f)(void *);<br> typedef void (*nodePrint_f)(void *);</p> 
<p> </p> 
<p>/* 定义RBTree树指向根结点的Root结点 */<br> typedef struct rbTreeRoot_s<br> {<!-- --><br>  rbNode_t *root;           /* 指向RBTree根结点的指针 */<br>  rbNode_t *nil;            /* RBTree的NIL结点 */<br>  unsigned int cnt;         /* RBTree结点总数 */<br>  //unsigned char height;     /* RBTree高度 */<br>  nodeCmp_f nodeCmp;        /* 结点键值比较函数 */<br>  nodeCpy_f nodeCpy;        /* 结点数据复制函数 */<br>  nodeFree_f nodeFree;      /* 结点内存释放函数 */<br>  nodePrint_f nodePrint;    /* 结点数据打印函数 */<br> }rbRoot_t;</p> 
<p> </p> 
<p>/************************* 全局函数声明 *************************/</p> 
<p>/* RBTree结点插入操作 */<br> status_t RBTree_insert(rbRoot_t *pRoot, rbNode_t *pNode);<br> /* RBTree结点删除操作 */<br> status_t RBTree_delete(rbRoot_t *pRoot, rbNode_t *pNode);<br> /* RBTree查找函数 */<br> rbNode_t *RBTree_search(rbRoot_t *pRoot, rbNode_t *pNode);<br> /* RBTree中序遍历函数 */<br> void RBTree_traverseInOrder(rbRoot_t *pRoot);<br> /* RBTree结点内存释放函数 */<br> void RBTree_free(rbRoot_t *pRoot);</p> 
<p> </p> 
<p>/*-------------------------- 内部函数 --------------------------*/</p> 
<p>/* 左旋/右旋函数 */<br> static void leftRotate(rbRoot_t *T, rbNode_t *x);<br> static void rightRotate(rbRoot_t *T, rbNode_t *y);<br> /* 查找指定树结点的直接前驱或后继结点函数 */<br> rbNode_t *findSuccessor(rbRoot_t *pRoot, rbNode_t *pNode);<br> /* 辅助查找函数 */<br> static rbNode_t *rbSearchAuxiliary(rbRoot_t *pRoot, rbNode_t *pNode, rbNode_t **ppSave);<br> /* RBTree管理根结点的初始化函数 */<br> static void RBTree_rootInit(rbRoot_t **ppRoot);<br> /* RBTree插入、删除操作的平衡处理函数 */<br> static void RBTree_insert_fixup(rbRoot_t *pRoot, rbNode_t *pNode);<br> static void RBTree_delete_fixup(rbRoot_t *pRoot, rbNode_t *pNode);</p> 
<p> </p> 
<p>/*------------------------ 用户定义函数 ------------------------*/</p> 
<p>rbNode_t *fillBuff(rbNode_t *pBuff, key_t *key);  /* 数据填充函数 */<br> rbNode_t *encapNode(rbRoot_t *pRoot, key_t *key); /* 结点封装函数 */<br> int nodeCmp(void *pNode1, void *pNode2);          /* 结点键值比较函数 */<br> void nodeCpy(void *pSNode, void *pDNode);         /* 结点数据复制函数 */<br> void nodeFree(void *pNode);                       /* 结点内存释放函数 */<br> void nodePrint(void *pNode);                      /* 结点数据打印函数 */</p> 
<p> </p> 
<p>/************************* 定义全局变量 *************************/</p> 
<p>#define N 10000<br> //key_t a[10] = {3, 2, 1, 4, 5, 6, 7, 10, 9, 8};<br> key_t a[N] = {0};</p> 
<p> </p> 
<p>/****************************************************************/</p> 
<p> </p> 
<p>/**************************** 主函数 ****************************/</p> 
<p> </p> 
<p>void test(void)<br> {<!-- --><br>  int i = 0;<br>  rbRoot_t *pRoot = NULL;<br>  myRbNode_t buff;</p> 
<p> </p> 
<p>RBTree_rootInit(&amp;pRoot);<br>  for (i = 0; i &lt; N; i++)<br>  {<!-- --><br>   a[i] = i + 1;<br>  }</p> 
<p> </p> 
<p>for (i = 0; i &lt; N; i++)<br>  {<!-- --><br>   RBTree_insert(pRoot, encapNode(pRoot, &amp;a[i]));<br>  }<br>  RBTree_traverseInOrder(pRoot);</p> 
<p> </p> 
<p> for (i = N/20; i &lt; N*3/4; i++)<br>  {<!-- --><br>   RBTree_delete(pRoot, fillBuff((rbNode_t *)&amp;buff, &amp;a[i]));<br>  }<br>  RBTree_traverseInOrder(pRoot);</p> 
<p> </p> 
<p> RBTree_free(pRoot);</p> 
<p> </p> 
<p>return;<br> }</p> 
<p> </p> 
<p>void main(void)<br> {<!-- --><br>  test();<br>  return;<br> }</p> 
<p> </p> 
<p>/****************************************************************/<br> /****************************************************************/</p> 
<p> </p> 
<p>/* RBTree树的左旋处理函数 */<br> /*----------------------------------------<br>          |                       |<br>         (x)                     (y)<br>        /   \                   /   \<br>       a    (y)      ==&gt;       (x)   c<br>           /   \              /   \<br>          b     c            a     b<br> ----------------------------------------*/<br> static void leftRotate(rbRoot_t *T, rbNode_t *x)<br> {<!-- --><br>  rbNode_t *y = NULL;<br>  pos_e pos = NONE;<br>  if ((NULL == T) || (NULL == x))<br>  {<!-- --><br>   ASSERT(0);<br>   return;<br>  }</p> 
<p> </p> 
<p>y = x-&gt;child[RCHILD];<br>  x-&gt;child[RCHILD] = y-&gt;child[LCHILD];<br>  y-&gt;child[LCHILD]-&gt;parent = x;<br>  y-&gt;parent = x-&gt;parent;</p> 
<p> </p> 
<p> /* x为RBTree的根结点 */<br>  if (x-&gt;parent == T-&gt;nil)<br>  {<!-- --><br>   T-&gt;root = y;<br>  }<br>  /* x非RBTree的根结点 */<br>  else<br>  {<!-- --><br>   pos = (x == x-&gt;parent-&gt;child[LCHILD] ? LCHILD : RCHILD);<br>   x-&gt;parent-&gt;child[pos] = y;<br>  }<br>  y-&gt;child[LCHILD] = x;<br>  x-&gt;parent = y;<br>  <br>  return;<br> }</p> 
<p> </p> 
<p>/* RBTree树的右旋处理函数 */<br> /*------------------------------------------<br>            |                   |<br>           (y)                 (x)<br>          /   \               /   \<br>        (x)    c    ==&gt;      a    (y)   <br>       /   \                     /   \<br>      a     b                   b     c<br> -------------------------------------------*/<br> static void rightRotate(rbRoot_t *T, rbNode_t *y)<br> {<!-- --><br>  rbNode_t *x = NULL;<br>  pos_e pos = NONE;<br>  if ((NULL == T) || (NULL == y))<br>  {<!-- --><br>   ASSERT(0);<br>   return;<br>  }</p> 
<p> </p> 
<p>x= y-&gt;child[LCHILD];<br>  y-&gt;child[LCHILD] = x-&gt;child[RCHILD];<br>  x-&gt;child[RCHILD]-&gt;parent = y;<br>  x-&gt;parent = y-&gt;parent;</p> 
<p> </p> 
<p>/* y为RBTree的根结点 */<br>  if (y-&gt;parent == T-&gt;nil)<br>  {<!-- --><br>   T-&gt;root = x;<br>  }<br>  /* y非RBTree的根结点 */<br>  else<br>  {<!-- --><br>   pos = (y== y-&gt;parent-&gt;child[LCHILD] ? LCHILD : RCHILD);<br>   y-&gt;parent-&gt;child[pos] = x;<br>  }<br>  x-&gt;child[RCHILD] = y;<br>  y-&gt;parent = x;<br>  <br>  return;<br> }</p> 
<p> </p> 
<p>/* 获取指定树结点的直接前驱或后继结点函数 */<br> rbNode_t *findSuccessor(rbRoot_t *pRoot, rbNode_t *pNode)<br> {<!-- --><br>  rbNode_t *pTmpNode = NULL;<br>  rbNode_t *pNil = NULL;<br>  if ((NULL == pRoot) || (NULL == pNode))<br>  {<!-- --><br>   ASSERT(0);<br>   return NULL;<br>  }</p> 
<p> </p> 
<p>pNil = pRoot-&gt;nil;<br>  pTmpNode = pNode;<br>  if (pTmpNode-&gt;child[LCHILD] != pNil)  /* 优先找直接前驱结点 */<br>  {<!-- --><br>   pTmpNode = pTmpNode-&gt;child[LCHILD];<br>   while (pTmpNode-&gt;child[RCHILD] != pNil)<br>   {<!-- --><br>    pTmpNode = pTmpNode-&gt;child[RCHILD];<br>   }<br>  }<br>  else<br>  {<!-- --><br>   if (pTmpNode-&gt;child[RCHILD] == pNil)<br>   {<!-- --><br>    /* 出现错误调用，直接返回原结点 */<br>    return pTmpNode;<br>   }<br>   <br>   pTmpNode = pTmpNode-&gt;child[RCHILD];<br>   while (pTmpNode-&gt;child[LCHILD] != pNil)<br>   {<!-- --><br>    pTmpNode = pTmpNode-&gt;child[LCHILD];<br>   }<br>  }</p> 
<p> </p> 
<p>return pTmpNode;<br> }</p> 
<p> </p> 
<p>/* RBTree查找结点函数 */<br> static rbNode_t *rbSearchAuxiliary(rbRoot_t *pRoot, rbNode_t *pNode, rbNode_t **ppSave)<br> {<!-- --><br>  rbNode_t *pTmpNode = NULL;<br>  rbNode_t *pParent = NULL;<br>  rbNode_t *pNil = NULL;<br>  pos_e pos = NONE;<br>  int rtnVal = 0;<br>  if ((NULL == pRoot) || (NULL == pNode))<br>  {<!-- --><br>   ASSERT(0);<br>   return NULL;<br>  }</p> 
<p> </p> 
<p>pNil = pRoot-&gt;nil;<br>  pTmpNode = pRoot-&gt;root;<br>  pParent = pNil;  /* 注意 */<br>  while (pTmpNode != pNil)<br>  {<!-- --><br>   pParent = pTmpNode;  <br>   rtnVal = pRoot-&gt;nodeCmp(pNode, pTmpNode);<br>   if (0 == rtnVal)<br>   {<!-- --><br>    /* 若树中存在相应结点，返回该结点 */<br>    return pTmpNode;<br>   }<br>   <br>   pos = (rtnVal &lt; 0 ? LCHILD : RCHILD);<br>   pTmpNode = pTmpNode-&gt;child[pos];<br>  }</p> 
<p> </p> 
<p>if (ppSave != NULL)<br>  {<!-- --><br>   *ppSave = pParent;<br>  }</p> 
<p> </p> 
<p>return NULL; <br> } </p> 
<p> </p> 
<p>/* RBTree插入操作的平衡处理函数 */<br> static void RBTree_insert_fixup(rbRoot_t *pRoot, rbNode_t *pNode)<br> {<!-- --><br>  rbNode_t *pTmpNode = NULL;<br>  rbNode_t *pParent = NULL;<br>  rbNode_t *pUncle = NULL;<br>  rbNode_t *pGrantpa = NULL;<br>  if ((NULL == pRoot) || (NULL == pNode))<br>  {<!-- --><br>   ASSERT(0);<br>   return;<br>  }</p> 
<p> </p> 
<p>pTmpNode = pNode;<br>  pParent = pTmpNode-&gt;parent;<br>  while (RED == pParent-&gt;color)<br>  {<!-- --><br>   pGrantpa = pParent-&gt;parent;<br>   if (pParent == pGrantpa-&gt;child[LCHILD])<br>   {<!-- --><br>    pUncle = pGrantpa-&gt;child[RCHILD];<br>    /* Case1: 父节点P、叔叔节点U都为RED */<br>    if (RED == pUncle-&gt;color)<br>    {<!-- --><br>     pParent-&gt;color = BLACK;<br>     pUncle-&gt;color = BLACK;<br>     pGrantpa-&gt;color = RED;<br>     pTmpNode = pGrantpa;<br>    }<br>    else<br>    {<!-- --><br>     /* Case2: 父节点P是RED，叔叔节点U是黑色或NIL；<br>     插入节点是P的RCHILD，而P又是其父节点G的LCHILD */<br>     if (pTmpNode == pParent-&gt;child[RCHILD])<br>     {<!-- --><br>      pTmpNode = pParent;<br>      leftRotate(pRoot, pTmpNode);<br>     }<br>     <br>     /* Case3: 父节点P是RED，叔叔节点U是黑色或NIL；<br>     插入节点是P的LCHILD，而P又是其父节点G的LCHILD */<br>     pParent-&gt;color = BLACK;<br>     pGrantpa-&gt;color = RED;<br>     rightRotate(pRoot, pGrantpa);<br>    }<br>   }<br>   else<br>   {<!-- --><br>    pUncle = pGrantpa-&gt;child[LCHILD];<br>    /* Case1: 父节点P、叔叔节点U都为RED */<br>    if (RED == pUncle-&gt;color)<br>    {<!-- --><br>     pParent-&gt;color = BLACK;<br>     pUncle-&gt;color = BLACK;<br>     pGrantpa-&gt;color = RED;<br>     pTmpNode = pGrantpa;<br>    }<br>    else<br>    {<!-- --><br>     /* Case2: 父节点P是RED，叔叔节点U是黑色或NIL；<br>     插入节点是P的LCHILD，而P又是其父节点G的RCHILD */<br>     if (pTmpNode == pParent-&gt;child[LCHILD])<br>     {<!-- --><br>      pTmpNode = pParent;<br>      rightRotate(pRoot, pTmpNode);<br>     }<br>     <br>     /* Case3: 父节点P是RED，叔叔节点U是黑色或NIL；<br>     插入节点是P的RCHILD，而P又是其父节点G的RCHILD */<br>     pParent-&gt;color = BLACK;<br>     pGrantpa-&gt;color = RED;<br>     leftRotate(pRoot, pGrantpa);<br>    }<br>   }<br>   <br>   pParent = pTmpNode-&gt;parent;<br>  }</p> 
<p> </p> 
<p>ASSERT(pRoot-&gt;root != pRoot-&gt;nil);<br>  pRoot-&gt;root-&gt;color = BLACK;</p> 
<p> </p> 
<p>return;<br> }</p> 
<p> </p> 
<p>/* RBTree删除操作的平衡处理函数 */<br> static void RBTree_delete_fixup(rbRoot_t *pRoot, rbNode_t *pNode)<br> {<!-- --><br>  rbNode_t *pTmpNode = NULL;<br>  rbNode_t *pSibling = NULL;  /* 兄弟结点 */<br>  rbNode_t *pParent = NULL;<br>  if ((NULL == pRoot) || (NULL == pNode))<br>  {<!-- --><br>   ASSERT(0);<br>   return;<br>  }</p> 
<p> </p> 
<p>pTmpNode = pNode;  /* pTmpNode指向二重色结点 */<br>  while ((pTmpNode != pRoot-&gt;root) &amp;&amp; (BLACK == pTmpNode-&gt;color))<br>  {<!-- --><br>   pParent = pTmpNode-&gt;parent;<br>   if (pTmpNode == pParent-&gt;child[LCHILD])<br>   {<!-- --><br>    pSibling = pParent-&gt;child[RCHILD];<br>    /* Case1: 兄弟结点S是RED */<br>    if (RED == pSibling-&gt;color)<br>    {<!-- --><br>     pSibling-&gt;color = BLACK;<br>     pParent-&gt;color = RED;<br>     leftRotate(pRoot, pParent);<br>     pSibling = pParent-&gt;child[RCHILD];<br>    }<br>    /* Case2: 兄弟结点S是BLACK，且S的俩孩子都是BLACK */<br>    if ((BLACK == pSibling-&gt;child[LCHILD]-&gt;color)<br>     &amp;&amp; (BLACK == pSibling-&gt;child[RCHILD]-&gt;color))<br>    {<!-- --><br>     pSibling-&gt;color = RED;<br>     pTmpNode = pParent;<br>     continue;<br>    }<br>    /* Case3: 兄弟结点S是BLACK，且S的左孩子是RED，右孩子是BLACK */<br>    else if (BLACK == pSibling-&gt;child[RCHILD]-&gt;color)<br>    {<!-- --><br>     pSibling-&gt;child[LCHILD]-&gt;color = BLACK;<br>     pSibling-&gt;color = RED;<br>     rightRotate(pRoot, pSibling);<br>     pSibling = pParent-&gt;child[RCHILD];<br>    }<br>    /* Case4: 兄弟结点S是BLACK，且S的右孩子是RED */<br>    pSibling-&gt;color = pParent-&gt;color;<br>    pParent-&gt;color = BLACK;<br>    pSibling-&gt;child[RCHILD]-&gt;color = BLACK;<br>    leftRotate(pRoot, pParent);<br>    pTmpNode = pRoot-&gt;root;<br>   }<br>   else<br>   {<!-- --><br>    pSibling = pParent-&gt;child[LCHILD];<br>    /* Case1: 兄弟结点S是RED */<br>    if (RED == pSibling-&gt;color)<br>    {<!-- --><br>     pSibling-&gt;color = BLACK;<br>     pParent-&gt;color = RED;<br>     rightRotate(pRoot, pParent);<br>     pSibling = pParent-&gt;child[LCHILD];<br>    }<br>    /* Case2: 兄弟结点S是BLACK，且S的俩孩子都是BLACK */<br>    if ((BLACK == pSibling-&gt;child[LCHILD]-&gt;color)<br>     &amp;&amp; (BLACK == pSibling-&gt;child[RCHILD]-&gt;color))<br>    {<!-- --><br>     pSibling-&gt;color = RED;<br>     pTmpNode = pParent;<br>     continue;<br>    }<br>    /* Case3: 兄弟结点S是BLACK，且S的左孩子是BLACK，右孩子是RED */<br>    else if (BLACK == pSibling-&gt;child[LCHILD]-&gt;color)<br>    {<!-- --><br>     pSibling-&gt;child[RCHILD]-&gt;color = BLACK;<br>     pSibling-&gt;color = RED;<br>     leftRotate(pRoot, pSibling);<br>     pSibling = pParent-&gt;child[LCHILD];<br>    }<br>    /* Case4: 兄弟结点S是BLACK，且S的左孩子是RED */<br>    pSibling-&gt;color = pParent-&gt;color;<br>    pParent-&gt;color = BLACK;<br>    pSibling-&gt;child[LCHILD]-&gt;color = BLACK;<br>    rightRotate(pRoot, pParent);<br>    pTmpNode = pRoot-&gt;root;<br>   }<br>  }</p> 
<p> </p> 
<p>pTmpNode-&gt;color = BLACK;</p> 
<p> </p> 
<p>return;<br> }</p> 
<p> </p> 
<p>/* RBTree根节点初始化函数 */<br> void RBTree_rootInit(rbRoot_t **ppRoot)<br> {<!-- --><br>  if (NULL == ppRoot)<br>  {<!-- --><br>   ASSERT(0);<br>   return;<br>  }</p> 
<p> </p> 
<p>*ppRoot = (rbRoot_t *)malloc(sizeof(rbRoot_t));<br>  if (NULL == *ppRoot)<br>  {<!-- --><br>   ASSERT(0);<br>   return;<br>  }<br>  memset(*ppRoot, 0, sizeof(rbRoot_t));<br>  <br>  /* 为NIL结点分配内存并置BLACK */<br>  (*ppRoot)-&gt;nil = (rbNode_t *)malloc(sizeof(rbNode_t));<br>  if (NULL == (*ppRoot)-&gt;nil)<br>  {<!-- --><br>   ASSERT(0);<br>   free(*ppRoot);<br>   return;<br>  }<br>  memset((*ppRoot)-&gt;nil, 0, sizeof(rbNode_t)); <br>  (*ppRoot)-&gt;nil-&gt;color = BLACK;<br>  <br>  (*ppRoot)-&gt;root = (*ppRoot)-&gt;nil; /* 注意 */<br>  (*ppRoot)-&gt;nodeCmp = nodeCmp;<br>  (*ppRoot)-&gt;nodeCpy = nodeCpy;<br>  (*ppRoot)-&gt;nodeFree = nodeFree;<br>  (*ppRoot)-&gt;nodePrint = nodePrint;<br>  <br>  return;<br> }</p> 
<p> </p> 
<p>/* RBTree插入结点函数 */<br> status_t RBTree_insert(rbRoot_t *pRoot, rbNode_t *pNode)<br> {<!-- --><br>  rbNode_t *pTmpNode = NULL;<br>  rbNode_t *pParent = NULL;  /* 插入结点的父结点 */<br>  pos_e pos = NONE;<br>  int rtnValue = INVAILD_VALUE;<br>  if ((NULL == pRoot) || (NULL == pNode))<br>  {<!-- --><br>   ASSERT(0);<br>   return ERROR;<br>  }</p> 
<p> </p> 
<p>/* [1]查找结点插入位置 */<br>  if (rbSearchAuxiliary(pRoot, pNode, &amp;pParent) != NULL)<br>  {<!-- --><br>   /* RBTree中已存在相应结点，则不再插入 */<br>   pRoot-&gt;nodeFree(pNode);<br>   return FALSE;<br>  }</p> 
<p> </p> 
<p>/* [2]插入结点 */<br>  pNode-&gt;parent = pParent;<br>  if (pParent == pRoot-&gt;nil)  /* 插入结点为根结点 */<br>  {<!-- --><br>   pRoot-&gt;root = pNode;<br>  }<br>  else                                    /* 插入结点为非根结点 */<br>  {<!-- --><br>   rtnValue = pRoot-&gt;nodeCmp(pNode, pParent);<br>   ASSERT(rtnValue != 0);<br>   pos = (rtnValue &lt; 0 ? LCHILD : RCHILD);<br>   pParent-&gt;child[pos] = pNode;<br>  }<br>  pRoot-&gt;cnt++;</p> 
<p> </p> 
<p>/* [3]平衡处理 */<br>  RBTree_insert_fixup(pRoot, pNode);</p> 
<p> </p> 
<p>return TRUE;<br> }</p> 
<p> </p> 
<p>/* RBTree删除结点函数 */<br> status_t RBTree_delete(rbRoot_t *pRoot, rbNode_t *pNode)<br> {<!-- --><br>  rbNode_t *pTmpNode = NULL; /* 指代二重色(RB/BB)结点 */<br>  rbNode_t *pDelNode = NULL;   /* 待删结点 */<br>  rbNode_t *pNearNode = NULL;   /* 邻近结点 */<br>  rbNode_t *pNearParent = NULL;   /* 邻近结点的父结点 */<br>  rbNode_t *pNil = NULL;<br>  pos_e pos = NONE;<br>  if ((NULL == pRoot) || (NULL == pNode))<br>  {<!-- --><br>   ASSERT(0);<br>   return ERROR;<br>  }<br>  <br>  /* [1]查找待删结点位置 */<br>  pDelNode = rbSearchAuxiliary(pRoot, pNode, NULL);<br>  if (NULL == pDelNode)<br>  {<!-- --><br>   /* 不存在相应结点，则直接返回 */<br>   return FALSE;<br>  }</p> 
<p> </p> 
<p>/* [2]删除结点过程 */<br>  /* [2]-1查找待删结点的直接前驱或后继结点(即邻近结点) */<br>  pNil = pRoot-&gt;nil;<br>  if ((pDelNode-&gt;child[LCHILD] == pNil) || (pDelNode-&gt;child[RCHILD] == pNil))<br>  {<!-- --><br>   pNearNode = pDelNode;<br>  }<br>  else<br>  {<!-- --><br>   pNearNode = findSuccessor(pRoot, pDelNode);<br>   if (NULL == pNearNode)<br>   {<!-- --><br>    ASSERT(0);<br>    return ERROR;<br>   }<br>  }</p> 
<p> </p> 
<p>/* [2]-2获取二重色结点 */<br>  pos = (pNearNode-&gt;child[LCHILD] != pNil) ? LCHILD : RCHILD;<br>  pTmpNode = pNearNode-&gt;child[pos];</p> 
<p> </p> 
<p>/* [2]-3分离邻近结点或待删结点 */<br>  pNearParent = pNearNode-&gt;parent;<br>  pTmpNode-&gt;parent = pNearParent;///???///<br>  if (pNearParent == pNil) /* 删除结点为根结点 */<br>  {<!-- --><br>   pRoot-&gt;root = pTmpNode;<br>  }<br>  else<br>  {<!-- --><br>   pos = (pNearNode == pNearParent-&gt;child[LCHILD] ? LCHILD : RCHILD);<br>   pNearParent-&gt;child[pos] = pTmpNode;<br>  }</p> 
<p> </p> 
<p>if (pNearNode != pDelNode)<br>  {<!-- --><br>   pRoot-&gt;nodeCpy(pNearNode, pDelNode);<br>  }<br>  pRoot-&gt;cnt--;</p> 
<p> </p> 
<p>/* [3]平衡处理 */<br>  if (BLACK == pNearNode-&gt;color)<br>  {<!-- --><br>   RBTree_delete_fixup(pRoot, pTmpNode);<br>  }<br>  pRoot-&gt;nodeFree(pNearNode);</p> 
<p> </p> 
<p>return TRUE;<br> }</p> 
<p> </p> 
<p>/* RBTree查找函数（非递归方法） */<br> rbNode_t *RBTree_search(rbRoot_t *pRoot, rbNode_t *pNode)<br> {<!-- --><br>  return rbSearchAuxiliary(pRoot, pNode, NULL);<br> }</p> 
<p> </p> 
<p>/* RBTree中序遍历函数 */<br> void RBTree_traverseInOrder(rbRoot_t *pRoot)<br> {<!-- --><br>  rbNode_t *stack[STACK_SIZE] = {0};<br>  unsigned int top = 0;<br>  rbNode_t *pNode = NULL;<br>  rbNode_t *pNil = NULL;<br>  if (NULL == pRoot)<br>  {<!-- --><br>   ASSERT(0);<br>   return;<br>  }</p> 
<p> </p> 
<p>pNode = pRoot-&gt;root;<br>  pNil = pRoot-&gt;nil;<br>  printf("Count:%10d\n", pRoot-&gt;cnt);<br>  while ((pNode != pNil) || (top != 0))<br>  {<!-- --><br>   while (pNode != pNil)<br>   {<!-- --><br>    stack[top++] = pNode;<br>    pNode = pNode-&gt;child[LCHILD];<br>   }<br>   pNode = stack[--top];<br>   pRoot-&gt;nodePrint(pNode);<br>   pNode = pNode-&gt;child[RCHILD];<br>  }<br>  printf("\n");</p> 
<p> </p> 
<p>return;<br> }</p> 
<p> </p> 
<p>/* 释放RBTree函数，包括根结点和数据结点，从左侧底开始释放 */<br> void RBTree_free(rbRoot_t *pRoot)<br> {<!-- --><br>  rbNode_t *stack[STACK_SIZE] = {0};<br>  unsigned int top = 0;<br>  pos_e pos = NONE;<br>  rbNode_t *pNil = NULL;<br>  rbNode_t *pNode = NULL;<br>  rbNode_t *pParNode = NULL;<br>  if (NULL == pRoot)<br>  {<!-- --><br>   ASSERT(0);<br>   return;<br>  }</p> 
<p> </p> 
<p>pNil = pRoot-&gt;nil;<br>  pNode = pRoot-&gt;root;<br>  while ((pNode != pNil) || (top != 0))<br>  {<!-- --><br>   while (pNode != pNil)<br>   {<!-- --><br>    stack[top++] = pNode;<br>    pNode = pNode-&gt;child[LCHILD];<br>   }<br>   pNode = stack[--top];<br>   ASSERT(pNode != pNil);  <br>   if (pNode-&gt;child[RCHILD] != pNil)<br>   {<!-- --><br>    stack[top++] = pNode;<br>    pNode = pNode-&gt;child[RCHILD];<br>    continue;<br>   }<br>   <br>   /* 树结点的左右孩子都空，释放之 */<br>   if (top != 0)  /* 树的非根结点释放 */<br>   {<!-- --><br>    pParNode = stack[--top];<br>    pos = (pParNode-&gt;child[LCHILD] == pNode ? LCHILD : RCHILD);<br>    pParNode-&gt;child[pos] = pNil;<br>    pRoot-&gt;nodeFree(pNode);<br>    pNode = pParNode;<br>   }<br>   else             /* 树的根结点释放 */<br>   {<!-- --><br>    ASSERT(pRoot-&gt;root == pNode);<br>    pRoot-&gt;nodeFree(pNode);<br>    pNode = pNil;<br>   }<br>  }<br>  /* 最后释放树的管理根结点 */<br>  free(pRoot-&gt;nil);<br>  free(pRoot);<br>  <br>  return;<br> }</p> 
<p> </p> 
<p>/* 结点缓存填充数据函数(暂时仅填充key值) */<br> rbNode_t *fillBuff(rbNode_t *pBuff, key_t *key)<br> {<!-- --><br>  myRbNode_t *pNode = (myRbNode_t *)pBuff;<br>  if ((NULL == pBuff) || (NULL == key))<br>  {<!-- --><br>   ASSERT(0);<br>   return NULL;<br>  }</p> 
<p> </p> 
<p>memset(pNode, 0, sizeof(myRbNode_t));<br>  memcpy(&amp;(pNode-&gt;key), key, sizeof(key_t));<br>  //fill data</p> 
<p> </p> 
<p> return (rbNode_t *)pNode;<br> }</p> 
<p> </p> 
<p>/* 封装RBTree树结点，并初始化结点数据(暂不考虑data) */<br> rbNode_t *encapNode(rbRoot_t *pRoot, key_t *key)<br> {<!-- --><br>  myRbNode_t *pNode = NULL;<br>  myRbNode_t *pNil = NULL;<br>  if ((NULL == pRoot) || (NULL == key))<br>  {<!-- --><br>   ASSERT(0);<br>   return NULL;<br>  }</p> 
<p> </p> 
<p> pNode = (myRbNode_t *)malloc(sizeof(myRbNode_t));<br>  if (NULL == pNode)<br>  {<!-- --><br>   ASSERT(0);<br>   return NULL;<br>  }<br>  memset(pNode, 0, sizeof(myRbNode_t));<br>  <br>  pNil = (void *)pRoot-&gt;nil;<br>  pNode-&gt;parent = pNil;    /* 注意 */<br>  pNode-&gt;child[LCHILD] = pNil;<br>  pNode-&gt;child[RCHILD] = pNil;<br>  pNode-&gt;color = RED;<br>  memcpy(&amp;(pNode-&gt;key), key, sizeof(key_t));<br>  //data encap</p> 
<p> </p> 
<p> return (rbNode_t *)pNode;<br> }</p> 
<p> </p> 
<p>/* RBTree树结点键值比较函数 */<br> int nodeCmp(void *pNode1, void *pNode2)<br> {<!-- --><br>  myRbNode_t *pMyNode1 = (myRbNode_t *)pNode1;<br>  myRbNode_t *pMyNode2 = (myRbNode_t *)pNode2;<br>  int rtn = 0; <br>  if ((NULL == pNode1) || (NULL == pNode2))<br>  {<!-- --><br>   ASSERT(0);<br>   return ERROR;<br>  }</p> 
<p> </p> 
<p> rtn = (pMyNode1-&gt;key &lt; pMyNode2-&gt;key) ? \<br>   (-1) : ((pMyNode1-&gt;key &gt; pMyNode2-&gt;key) ? 1 : 0);</p> 
<p> </p> 
<p> return rtn;<br> }</p> 
<p> </p> 
<p>/* RBTree树结点数据复制函数 */<br> void nodeCpy(void *pSNode, void *pDNode)<br> {<!-- --><br>  myRbNode_t *pSMyNode = (myRbNode_t *)pSNode; <br>  myRbNode_t *pDMyNode = (myRbNode_t *)pDNode;<br>  if ((NULL == pSNode) || (NULL == pDNode))<br>  {<!-- --><br>   ASSERT(0);<br>   return;<br>  }</p> 
<p> </p> 
<p> memcpy(&amp;(pDMyNode-&gt;key), &amp;(pSMyNode-&gt;key), sizeof(key_t));<br>  //memcpy(&amp;(pDMyNode-&gt;data), &amp;(pSMyNode-&gt;data), sizeof(data_t));</p> 
<p> </p> 
<p> return;<br> }</p> 
<p> </p> 
<p>/* RBTree树结点内存释放函数 */<br> void nodeFree(void *pNode)<br> {<!-- --><br>  myRbNode_t *pMyNode = (myRbNode_t *)pNode;<br>  if (NULL == pNode)<br>  {<!-- --><br>   ASSERT(0);<br>   return;<br>  }</p> 
<p> </p> 
<p> free(pMyNode);</p> 
<p> </p> 
<p> return;<br> }</p> 
<p> </p> 
<p>/* RBTree树结点数据打印函数 */<br> void nodePrint(void *pNode)<br> {<!-- --><br>  myRbNode_t *pMyNode = (myRbNode_t *)pNode;<br>  if (NULL == pNode)<br>  {<!-- --><br>   ASSERT(0);<br>   return;<br>  }</p> 
<p> </p> 
<p> printf("%d\t", pMyNode-&gt;key);</p> 
<p> </p> 
<p> return;<br> }</p> 
<p> </p> 
<p>/****************************************************************/<br> /* ************************* The End ************************** */</p> 
<p> </p> 
<p style="margin-left:0cm;"> </p> 
<p> </p> 
<p> </p> 
<div>
  ﻿﻿ 
</div> 
<div>
  ﻿﻿ 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4cf70be2fd6654804caca23d65cd582b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">亲身体验Intellij Idea从卡顿到顺畅</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5aa27377958ad289235c2e29b2a53c69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TensorFlow 2.0教程04：Early Stopping</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>