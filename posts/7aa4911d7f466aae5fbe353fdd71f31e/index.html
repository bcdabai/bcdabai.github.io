<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数学建模之粒子群算法详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数学建模之粒子群算法详解" />
<meta property="og:description" content="粒子群（鸟群算法）算法是典型的寻优算法。分为全局最优和局部最优。 基本思想：主要模拟自然界生物捕食的策略，群体迭代，粒子在解空间追随最优的例子进行搜索。是智能算法的一种。
算法特点：
简单易行。收敛速度快。设置参数少。
一般的限制条件是当达到限制步数或者达到相应的准确度的时，粒子就会停止移动。
设想一个场景：一群鸟在随机搜索食物。
已知（假设）：1.在这块区域里只有一块食物。2.所有的鸟都不知道食物在哪。3.但他们能感受到当前的位置离食物还有多远。
问题是：找到食物的最优策略是什么。
搜索目前离食物最近的鸟的周围区域，根据自己飞行经验判断食物的所在。
PSO的基础:信息的社会共享 算法介绍 每个寻优的问题解都被想象成一只鸟，称为粒子。所有粒子都在一个D维空间进行搜索。所有粒子都由一个fitness function 确定适应值以判断目前的位置好坏。每一个粒子必须赋予记忆功能，能记住所搜寻到的最佳位置。每一个粒子还有一个速度以决定飞行的距离和方向。这个速度根据它本身的飞行经验以及同伴的飞行经验进行动态的调整。
D维空间中，有N个粒子；
粒子i位置：xi=(xi1,xi2,…xiD)，将xi代入适应函数f(xi)求适应值；
粒子i速度：vi=(vi1,vi2,…viD)
粒子i个体经历过的最好位置：pbesti=(pi1,pi2,…piD)
以上规定位置变化的界限和速度变化的界限。速度过快或者过慢都会对粒子寻优产生影响。粒子i的第d维速度更新公式：
粒子i的第d维位置更新公式：
变量含义：
vid ^k —第k次迭代粒子i飞行速度矢量的第d维分量
xid^k —第k次迭代粒子i位置矢量的第d维分量
c1,c2—加速度常数，调节学习最大步长
r1,r2—两个随机函数，取值范围[0，1]，以增加搜索随机性
w —惯性权重，非负数，调节对解空间的搜索范围
粒子速度更新公式包含三部分：
第一部分：粒子先前的速度。
第二部分：认知部分，表示粒子本身的思考，可以理解为粒子i当前位置与自己最好位置之间的距离。
第三部分：社会部分，表示粒子间的信息共享与合作，可以理解为粒子i当前位置与群体最好
算法基本流程： 1.初始化粒子群体（群体规模为n），包括随机位置和速度。2.根据fitness function ，评价每个粒子的适应度。3.对每个粒子，将其当前适应值与其个体历史最佳位置（pbest）对应的适应值做
比较，如果当前的适应值更高，则将用当前位置更新历史最佳位置pbest。4.对每个粒子，将其当前适应值与全局最佳位置（gbest）对应的适应值做比较，5.根据公式更新每个粒子的速度与位置。6.如未满足结束条件，则返回步骤2,通常算法达到最大迭代次数 或者最佳适应度值的增量小于某个给定的阈值时算法停止。 粒子群算法的构成要素：
群体大小m:m是一个整数。
如果m很小，陷入局部最优解的可能性很大。
如果m很大，PSO的优化能力很好，当群体数目增长到一定水平时候，再整长就不再有显著的作用。权重因子：惯性因子 W 学习因子 c1、c2粒子速度的更新主要由以下三部分组成。
如果惯性因子w=1 则是基本粒子群算法 如果w=0的话，失去对粒子本身的速度的记忆。
如果c1=0,就是无私型粒子群算法,缺点是：只有社会，没有自我，迅速丧失群体多样性，容易陷入局部最优解而无法跳出。太依赖群体了。
如果学习因子c2=0,那么是自我认知型粒子群算法。不管社会群体。 完全没有信息的社会共享，导致算法收敛速度缓慢。
如果c1、c2都不为0，称为完全型粒子群算法。完全型粒子群算法更容易保持收敛速度和搜索效果的均衡，是较好的选择。 粒子群算法的构成要素-最大速度 作用：
在于维护算法的探索能力和开发能力的平衡。Vm较大时，探索能力增强，但是容易飞过最优解。Vm较小的时候，开发能力增强，但是容易陷入局部最优解。Vm一般设为每维变化范围的10%-20%。
粒子群邻域算法的构成要素-邻域的拓扑结构 粒子群算法的邻域拓扑结构包括两种：
一种是将群体内的所有个体都作为粒子的邻域，另一种是只将群体中的部分个体作为粒子的邻域。
邻域拓扑结构决定了群体历史的最优位置。由此，将粒子群算法分为全局粒子群算法和局部粒子群算法。
全局粒子群算法包括：
1粒子自己历史最优值。2粒子群体的全局最优值（最优值由全部粒子决定）
局部粒子群算法包括1.粒子自己历史最优值2.粒子邻域内粒子的最优值（部分个体粒子来决定）。
邻域随迭代次数的增加线性变大，最后邻域扩展到整个粒子群。
经过实践证明： 全局版本的粒子群算法收敛速度快，但是容易陷入局部最优。局部版本的粒子群算法收敛速度慢，但是很难陷入局部最优。现在的粒子群算法大都在收敛速度与摆脱局部最优这两个方面下功夫。但是这两个方面存在着矛盾。只能是看如何更好折中。 粒子群算法的构成要素-停止准则 停止准则一般有以下两种：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7aa4911d7f466aae5fbe353fdd71f31e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-31T19:24:03+08:00" />
<meta property="article:modified_time" content="2019-08-31T19:24:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数学建模之粒子群算法详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>粒子群（鸟群算法）算法是典型的寻优算法。分为<strong>全局最优和局部最优。 基本思想</strong>：主要模拟自然界生物捕食的策略，群体迭代，粒子在解空间追随最优的例子进行搜索。是智能算法的一种。<br> 算法特点：</p> 
<ol><li>简单易行。</li><li>收敛速度快。</li><li>设置参数少。<br> 一般的限制条件是当达到限制步数或者达到相应的准确度的时，粒子就会停止移动。<br> 设想一个场景：一群鸟在随机搜索食物。<br> 已知（假设）：</li><li>1.在这块区域里只有一块食物。</li><li>2.所有的鸟都不知道食物在哪。</li><li>3.但他们能感受到当前的位置离食物还有多远。<br> 问题是：找到食物的最优策略是什么。<br> 搜索目前离食物最近的鸟的周围区域，根据自己飞行经验判断食物的所在。<br> <strong>PSO的基础:信息的社会共享</strong></li></ol> 
<h5><a id="_14"></a>算法介绍</h5> 
<ol start="7"><li>每个寻优的问题解都被想象成一只鸟，称为粒子。所有粒子都在一个D维空间进行搜索。</li><li>所有粒子都由一个fitness function 确定适应值以判断目前的位置好坏。</li><li>每一个粒子必须赋予记忆功能，能记住所搜寻到的最佳位置。</li><li>每一个粒子还有一个速度以决定飞行的距离和方向。这个速度根据它本身的飞行经验以及同伴的飞行经验进行动态的调整。<br> D维空间中，有N个粒子；<br> 粒子i位置：xi=(xi1,xi2,…xiD)，将xi代入适应函数f(xi)求适应值；<br> 粒子i速度：vi=(vi1,vi2,…viD)<br> 粒子i个体经历过的最好位置：pbesti=(pi1,pi2,…piD)<br> <img src="https://images2.imgbox.com/b0/d0/N2UbFbFm_o.png" alt="在这里插入图片描述"><br> 以上规定位置变化的界限和速度变化的界限。速度过快或者过慢都会对粒子寻优产生影响。</li><li>粒子i的第d维速度更新公式：<br> <img src="https://images2.imgbox.com/57/ee/YJ35aE5W_o.png" alt="在这里插入图片描述"></li><li>粒子i的第d维位置更新公式：<br> <img src="https://images2.imgbox.com/b2/5c/lL8wyPNF_o.png" alt="在这里插入图片描述"><br> 变量含义：<br> vid ^k —第k次迭代粒子i飞行速度矢量的第d维分量<br> xid^k —第k次迭代粒子i位置矢量的第d维分量<br> c1,c2—加速度常数，调节学习最大步长<br> r1,r2—两个随机函数，取值范围[0，1]，以增加搜索随机性<br> w —惯性权重，非负数，调节对解空间的搜索范围<br> <img src="https://images2.imgbox.com/8e/6a/pI7EftbC_o.png" alt="在这里插入图片描述"><br> 粒子速度更新公式包含三部分：<br> 第一部分：粒子先前的速度。<br> 第二部分：认知部分，表示粒子本身的思考，可以理解为粒子i当前位置与自己最好位置之间的距离。<br> 第三部分：社会部分，表示粒子间的信息共享与合作，可以理解为粒子i当前位置与群体最好<br> 算法基本流程：</li></ol> 
<ul><li>1.初始化粒子群体（群体规模为n），包括随机位置和速度。</li><li>2.根据fitness function ，评价每个粒子的适应度。</li><li>3.对每个粒子，将其当前适应值与其个体历史最佳位置（pbest）对应的适应值做<br> 比较，如果当前的适应值更高，则将用当前位置更新历史最佳位置pbest。</li><li>4.对每个粒子，将其当前适应值与全局最佳位置（gbest）对应的适应值做比较，</li><li>5.根据公式更新每个粒子的速度与位置。</li><li>6.如未满足结束条件，则返回步骤2,通常算法达到最大迭代次数 或者最佳适应度值的增量小于某个给定的阈值时算法停止。</li></ul> 
<p><img src="https://images2.imgbox.com/57/17/x8O1VJiW_o.png" alt="在这里插入图片描述"><br> 粒子群算法的构成要素：</p> 
<ul><li>群体大小m:m是一个整数。<br> 如果m很小，陷入局部最优解的可能性很大。<br> 如果m很大，PSO的优化能力很好，当群体数目增长到一定水平时候，再整长就不再有显著的作用。</li><li>权重因子：惯性因子 W 学习因子 c1、c2</li><li><img src="https://images2.imgbox.com/09/fc/JVrK1r7q_o.png" alt="在这里插入图片描述"></li><li>粒子速度的更新主要由以下三部分组成。<br> <img src="https://images2.imgbox.com/c0/d6/E5YfSxse_o.png" alt="在这里插入图片描述"><br> 如果惯性因子w=1 则是基本粒子群算法 如果w=0的话，失去对粒子本身的速度的记忆。<br> 如果c1=0,就是无私型粒子群算法,缺点是：只有社会，没有自我，迅速丧失群体多样性，容易陷入局部最优解而无法跳出。太依赖群体了。<br> 如果学习因子c2=0,那么是自我认知型粒子群算法。不管社会群体。 完全没有信息的社会共享，导致算法收敛速度缓慢。<br> 如果c1、c2都不为0，称为完全型粒子群算法。完全型粒子群算法更容易保持收敛速度和搜索效果的均衡，是较好的选择。</li></ul> 
<h5><a id="_63"></a>粒子群算法的构成要素-最大速度</h5> 
<p>作用：<br> 在于维护算法的探索能力和开发能力的平衡。Vm较大时，探索能力增强，但是容易飞过最优解。Vm较小的时候，开发能力增强，但是容易陷入局部最优解。Vm一般设为每维变化范围的10%-20%。</p> 
<h5><a id="_66"></a>粒子群邻域算法的构成要素-邻域的拓扑结构</h5> 
<p>粒子群算法的邻域拓扑结构包括两种：<br> 一种是将群体内的所有个体都作为粒子的邻域，另一种是只将群体中的部分个体作为粒子的邻域。<br> 邻域拓扑结构决定了群体历史的最优位置。由此，将粒子群算法分为<strong>全局粒子群算法和局部粒子群算法。</strong><br> 全局粒子群算法包括：</p> 
<ul><li>1粒子自己历史最优值。</li><li>2粒子群体的全局最优值（最优值由全部粒子决定）<br> 局部粒子群算法包括</li><li>1.粒子自己历史最优值</li><li>2.粒子邻域内粒子的最优值（部分个体粒子来决定）。<br> 邻域随迭代次数的增加线性变大，最后邻域扩展到整个粒子群。<br> 经过实践证明： <strong>全局版本的粒子群算法收敛速度快，但是容易陷入局部最优。局部版本的粒子群算法收敛速度慢，但是很难陷入局部最优。现在的粒子群算法大都在收敛速度与摆脱局部最优这两个方面下功夫。但是这两个方面存在着矛盾。只能是看如何更好折中。</strong></li></ul> 
<h5><a id="_78"></a>粒子群算法的构成要素-停止准则</h5> 
<p>停止准则一般有以下两种：<br> 最大迭代步数<br> 可接受的满意解</p> 
<h5><a id="_82"></a>粒子群算法的构成要素-粒子空间的初始化。</h5> 
<p>较好地选择粒子的初始化空间，将大大缩短收敛时间。初始化空间根据具体问题的不同而不同。也就是说，这是问题依赖的。<br> 总结：从上面的介绍可以看出，粒子群算法与其他现代优化方法相比的一个明显特色就是<strong>需要修改的参数很少</strong>。相对来说，<strong>惯性因子和邻域定义</strong>较为重要。这些关键参数的设置对算法的精度和效率有显著影响。<br> 例题：<br> <img src="https://images2.imgbox.com/91/60/xD6ciaYG_o.png" alt="在这里插入图片描述"><br> 题目来看主要是找最小值，即最优解的问题。<br> 种群大小：即算法中粒子的数量，取m=5<br> 编码：因为问题的维数是4，所以每个粒子的位置和速度均为4维的实数向量。<br> 速度设定为Vmax=60，因为x属于-30-30之间。一共是60个空间。所以设置速度为60.<br> <img src="https://images2.imgbox.com/7d/47/Bn7Ab6Wt_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fe/21/jdxaI9QA_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/28/45/CsdQ5u5e_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d9/13/E9scOpdE_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/d9/15/dhWG9OAM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/88/bd/qDMxlPcT_o.png" alt="在这里插入图片描述"><br> 粒子群算法流程：<br> 第一步：在初始化范围内，对粒子群进行随机初始化，包括随机位置和速度。<br> 第二步：计算每个粒子的适应值。<br> 第三步：更新粒子个体的历史最优位置。<br> 第四步：更新粒子群体的历史最优位置。<br> 第五步：更新粒子的速度和位置，<br> <img src="https://images2.imgbox.com/c3/5a/rpIMZk1k_o.png" alt="在这里插入图片描述"><br> 第六步：如果没有达到终止条件，转第二步。</p> 
<h5><a id="_104"></a>惯性权重</h5> 
<p>用动态调整惯性权重来平衡收敛的全局性和收敛速度，该算法被称为标准PSO算法。<br> 惯性权重w描述粒子上一代速度对当前代速度的影响。w值较大，全局寻优能力强，局部寻优能力弱。反之，则局部寻优能力强。当问题空间较大时，为了在搜索速度和搜索精度之间达到平衡，通常的做法是使算法在前期有较高的全局搜索能力以得到合适的种子，而在后期有较高的局部搜索能力以提高收敛精度，所以w不宜为一个固定的常数。<br> 线性递减权重：<br> <img src="https://images2.imgbox.com/90/d5/2JSJvMTO_o.png" alt="在这里插入图片描述"><br> 较大的w有较好的全局收敛能力，较小的w则有较强的局部收敛能力。因此，随着迭代次数的增加，惯性权重w应该不断减小，从而使得粒子群算法在初期具有较强的全局收敛能力，而晚期具有较强的局部收敛能力。<br> 收缩因子法改进粒子群算法：<br> 引入收缩因子来保证算法的收敛性。<br> 速度更新公式为：<br> <img src="https://images2.imgbox.com/ff/79/OYQ1ZbOf_o.png" alt="在这里插入图片描述"><br> 其中，收缩因子K为受φ1 φ2 限制的w。φ1 φ2是需要预先设定的模型<br> 参数<br> <img src="https://images2.imgbox.com/b8/90/wsId9Y3t_o.png" alt="在这里插入图片描述"><br> 收缩因子法控制系统行为最终收敛，且可以有效搜索不同区域，该法能得到较高质量的解。<br> PSO应用面：<br> PSO应用包括系统设计，多目标优化，分类 （分类精度达到最大值），模式识别，调度（调度时间最少），信号处理，决策。具体应用为：模糊控制器设计，车间作业调度，机器人实时路径规划，自动目标检测，时频分析。<br> 他的中心的思想为求解函数的最大值最小值。就是转化成结果的最大值最小值。<br> PSO存在的问题：</p> 
<ul><li>一种新兴的优化算法，其数学基础薄弱，在收敛性理论、计算性能、实现技术和参数的设置等方面缺乏严密的数学基础，其应用大多数仍然依靠经验和实验。</li><li>PSO算法的理论研究：纵观PSO的研究成果，大部分研究都集中在算法的设计上，对<br> 算法的性能、收敛性、收敛速度、参数选取及参数的鲁棒性等理论性的研究则很少，偶有一些理论研究，但仅仅局限在对算法的参数、状态及概念等方面，且理论分析的内容和深度都很浅，因此理论研究大大滞后于PSO在工程中的应用。</li><li>利用不同问题的特点设计出相应的有效算法，应注重高效的算法开发，提出合理的核心更新公式以及有效的均衡全局搜索和局部改进的策略。尤其要注重把PSO与其他算法，如进化算法、模糊逻辑、生物智能以及混沌等方法或策略相结合，来解决<strong>PSO易陷入局部最优的问题</strong></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6cc14fbf4dc8e41519fd01e335263ce4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu16.04&#43;anaconda3&#43;python3.6安装OpenCV3</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/effb14f2cfebef78f206391e6e9ebe07/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue异步发送请求，渲染数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>