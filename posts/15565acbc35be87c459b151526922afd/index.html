<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Postgresql时间处理技巧，每半天，每周，每月和每5分钟统计 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Postgresql时间处理技巧，每半天，每周，每月和每5分钟统计" />
<meta property="og:description" content="一、每半天
如果有张表log_bus_runinfo里有一个created_date是timestamp类型，如何统计12点前的数据？
在 PostgreSQL 中，您可以使用 DATE_TRUNC 函数和 WHERE 子句来统计特定时间范围内的数据。以下是一个查询例子，用于统计 log_bus_runinfo 表中创建日期 created_date 早于当天中午 12 点的记录数：
SELECT COUNT(*) FROM log_bus_runinfo WHERE DATE_TRUNC(&#39;day&#39;, created_date) = current_date AND created_date &lt; current_date &#43; interval &#39;12 hours&#39; 上述查询会使用 DATE_TRUNC 函数将 created_date 字段截断为该天（时间部分被删除），之后使用 WHERE 子句选择操作当天（而不是整个历史）的记录，并且创建日期小于这一天中午 12 点（即 current_date &#43; interval &#39;12 hours&#39;）。
同样，如果处理后半天的SQL：
SELECT COUNT(*) FROM log_bus_runinfo WHERE DATE_TRUNC(&#39;day&#39;, created_date) = current_date AND created_date &gt;= current_date &#43; interval &#39;12 hours&#39; 二、每周
如果有张里程表count_mileage，字段count_mileage表示每天的里程数,如何统计上一周的公里数？
SELECT created_date::DATE-(extract(isodow from created_date::TIMESTAMP)-1||&#39;day&#39;)::interval countWeek, sum(mileage_count) mileage from count_mileage GROUP BY created_date::DATE-(extract(isodow from created_date::TIMESTAMP)-1||&#39;day&#39;)::&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/15565acbc35be87c459b151526922afd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-20T11:03:34+08:00" />
<meta property="article:modified_time" content="2023-04-20T11:03:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Postgresql时间处理技巧，每半天，每周，每月和每5分钟统计</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>一、每半天</p> 
<p>如果有张表log_bus_runinfo里有一个created_date是timestamp类型，如何统计12点前的数据？</p> 
<p>在 PostgreSQL 中，您可以使用 <code>DATE_TRUNC</code> 函数和 <code>WHERE</code> 子句来统计特定时间范围内的数据。以下是一个查询例子，用于统计 <code>log_bus_runinfo</code> 表中创建日期 <code>created_date</code> 早于当天中午 12 点的记录数：</p> 
<pre><code class="language-sql">SELECT COUNT(*) 
FROM log_bus_runinfo 
WHERE DATE_TRUNC('day', created_date) = current_date AND created_date &lt; current_date + interval '12 hours'</code></pre> 
<p>上述查询会使用 <code>DATE_TRUNC</code> 函数将 <code>created_date</code> 字段截断为该天（时间部分被删除），之后使用 <code>WHERE</code> 子句选择操作当天（而不是整个历史）的记录，并且创建日期小于这一天中午 12 点（即 <code>current_date + interval '12 hours'</code>）。</p> 
<p>同样，如果处理后半天的SQL：</p> 
<pre><code class="language-sql">SELECT COUNT(*) 
FROM log_bus_runinfo 
WHERE DATE_TRUNC('day', created_date) = current_date 
AND created_date &gt;= current_date + interval '12 hours'</code></pre> 
<p>二、每周</p> 
<p>如果有张里程表count_mileage，字段count_mileage表示每天的里程数,如何统计上一周的公里数？</p> 
<pre><code class="language-sql">SELECT
        created_date::DATE-(extract(isodow from created_date::TIMESTAMP)-1||'day')::interval countWeek,
        sum(mileage_count) mileage
        from count_mileage
        GROUP BY created_date::DATE-(extract(isodow from created_date::TIMESTAMP)-1||'day')::"interval"
        order by countWeek
        limit 1</code></pre> 
<p>它用于从count_mileage表中检索日期创建和总路程，并根据学院id和每周计数对其进行分组。以下是逐行的语法分析：</p> 
<ul><li><code>select created_date::date-(extract(isodow from created_date::timestamp)-1||'day')::interval countweek,</code>: 选择created_date列按照给定的方式格式化，从这个处减去星期中第一天前面的日期（例如，今天如果是星期四，则减去3天的时间），并将结果设置为名为countweek的新列。</li><li><code>sum(mileage_count) mileage</code>: 计算mileage_count的总值，并将结果命名为mileage。</li><li><code>from count_mileage</code>: 从count_mileage表中选择数据。</li><li><code>where 1=1</code>: 这个条件没有实际效果，只是作为一个占位符。</li><li><code>group by created_date::date-(extract(isodow from created_date::timestamp)-1||'day')::"interval"</code>: 根据日期进行分组，与上面的created_date列的操作一样。</li><li><code>order by countweek</code>: 按名称为countweek列的升序排序。</li><li><code>limit 1</code>: 结果最多返回1周。</li></ul> 
<p>总之，这个sql查询检索了给定条件下每周的总里程数，并按日期和计数排序。</p> 
<p>如果统计近8周的里程数？SQL是：</p> 
<pre><code class="language-sql">select
        created_date::DATE-(extract(isodow from created_date::TIMESTAMP)-1||'day')::interval countWeek,
        sum(mileage_count) mileage
        from count_mileage
        GROUP BY created_date::DATE-(extract(isodow from created_date::TIMESTAMP)-1||'day')::"interval"
        order by countWeek
        limit 8</code></pre> 
<p>三、每月</p> 
<p>如果有张里程表count_mileage，字段count_mileage表示每天的里程数,如何统计每月的公里数？</p> 
<p>SQL:</p> 
<pre><code class="language-sql">select distinct to_char(created_date,'yyyy-mm') countMonth ,sum(mileage_count) mileage
        from count_mileage
        where 1=1
        and to_char(created_date,'yyyymm')&gt;to_char((select now() as timestamp)-'6 month'::"interval",'yyyymm')
        group by to_char(created_date,'yyyy-mm')
        order by countMonth</code></pre> 
<p>它从count_mileage表中检索日期创建和总里程，并根据每月计数进行分组。以下是逐行的语法分析：</p> 
<ul><li><code>select distinct to_char(created_date,'yyyy-mm') countmonth</code>: 选择created_date列并将其格式化为年月格式。该distinct关键字用来去掉重复行，如果有多个日期值对应同一个年月，则只返回一个。</li><li><code>,sum(mileage_count) mileage</code>: 计算mileage_count的总值，并将结果命名为mileage。</li><li><code>from count_mileage</code>: 从count_mileage表中选择数据。</li><li><code>where 1=1</code>: 这个条件没有实际效果，只是作为一个占位符。</li><li><code>and to_char(created_date,'yyyymm')&gt;to_char((select now() as timestamp)-'6 month'::"interval",'yyyymm')</code>: 仅选择最近六个月内的行，在查询时将当前时间减去6个月的时间来获得区别日期，并按照同样的格式转换成字符串后和表中的字段比较，筛选出符合条件的记录。</li><li><code>group by to_char(created_date,'yyyy-mm')</code>: 根据年月格式对数据进行分组。</li><li><code>order by countmonth</code>: 按名称为countmonth列的升序排序。</li></ul> 
<p>因此，这个sql查询检索了过去6个月的每月总里程数，并按时间顺序排序。</p> 
<p>四、每5分钟数据</p> 
<p>如果有张表是GPS信息，log_bus_driver，其中有经度、纬度字段bus_longitute,bus_latitute，时间是created_date，想按照每5分钟进行分段取信息进行分析，如何做？</p> 
<pre><code class="language-sql"> SELECT distinct on (CAST (extract(epoch from date_trunc('second', created_date)) AS integer) / 300) created_date
            ts, CAST (extract(epoch from date_trunc('second', created_date)) AS integer) % 300 as sec,
            bus_longitude, bus_latitude
        from log_bus_drive
        where to_char( created_date, 'yyyyMMdd' ) = '20230428'
        order by CAST (extract(epoch from date_trunc('second', created_date)) AS integer) / 300 asc, created_date asc</code></pre> 
<p>这条SQL语句主要功能是从" log_bus_drive" 表中选出所有"created_date"为'20230428' 的记录，并且按照时间间隔5分钟(group by 300 seconds)聚合数据。这里需要对查询语句进行分解来更好地理解它的作用：</p> 
<p>以下是每个元素的工作方式:</p> 
<ul><li> <p><code>distinct on (CAST (extract(epoch from date_trunc('second', created_date)) AS integer) / 300)</code>：以5分钟为单位分组并选择每个分组的唯一结果。</p> </li><li> <p><code>created_date ts</code>：该列表示原始的created_date字段值。</p> </li><li> <p><code>CAST(extract(epoch from date_trunc('second', created_date)) AS integer) % 300 as sec</code>：此列显示created_date到该5分钟周期的秒数，range在0-299之间。</p> </li><li> <p><code>bus_longitude</code> and <code>bus_latitude</code>：这些字段包含公交车的经度和纬度坐标。</p> </li><li> <p><code>log_bus_drive</code>: 数据源表。</p> </li><li> <p><code>where to_char( created_date, 'yyyyMMdd' ) = '20230428'</code>: 筛选出符合条件的生成日期（created_date）。这里是2023年4月28日。</p> </li><li> <p><code>ORDER BY CAST (extract(epoch from date_trunc('second', created_date)) AS integer) / 300 asc, created_date asc;</code>: 根据时间戳(秒整数)和创建日期进行升序排序。</p> </li></ul> 
<p>五、近七日数据统计</p> 
<p>如果有张表count_driver_warn,想统计近七日的警告数据，如何做？</p> 
<pre><code class="language-sql">select sum(warn_count) warnCount,driver_name driverName
        from count_driver_warn
        where created_date &gt;=CURRENT_DATE- INTERVAL '7 day'
               and driver_name is not null
        group by driver_name
        order by warnCount desc</code></pre> 
<p>这个SQL语句的主要功能是从" count_driver_warn" 表中选出所有created_date在7天内的记录，并按照驾驶员名字分组计算每个驾驶员的警告次数数量和警告类型，然后按警告次数从高到低排序。这里需要对查询语句进行分解来更好地理解它的作用：</p> 
<p>以下是每个元素的工作方式:</p> 
<ul><li> <p><code>sum(warn_count) warnCount</code>： 计算每个驾驶员的总警告次数。</p> </li><li> <p><code>driver_name driverName</code>： 数据中包含的驾驶员姓名以及生成搜集日期。</p> </li><li> <p><code>count_driver_warn</code>: 数据源表。</p> </li><li> <p><code>WHERE created_date &gt;= CURRENT_DATE - INTERVAL '7 day' AND driver_name IS NOT NULL</code>：筛选出创建日期在7天内且不为空的驾驶员记录。其中<code>CURRENT_DATE</code> 函数获取当前系统时间， <code>INTERVAL '7 day'</code> 是时间间隔，用来表示最近的7天（从当前日期往前）。</p> </li><li> <p><code>GROUP BY driver_name</code>：将所有驾驶员的记录进行分组，聚合统计每个驾驶员的总警告次数。</p> </li><li> <p><code>ORDER BY warnCount DESC</code>：根据警告次数排序，从高到低按最大警告数排序。</p> <p></p> </li></ul> 
<p>六，前几分钟的数据抓取          </p> 
<pre><code class="language-vbscript">SELECT &lt;include refid="Base_Column_List" /&gt;
    FROM log_bus_runinfo
    WHERE bus_id = #{busId}
    &lt;if test="beforeMinute !=null"&gt;
      and created_date&gt;(now() + ('-'||#{beforeMinute}||' min')::interval)
    &lt;/if&gt;
    order by created_date desc
    limit 1</code></pre> 
<p>其各部分含义如下：</p> 
<ul><li><code>select &lt;include refid="base_column_list" /&gt;</code>：选择出表 log_bus_runinfo 中所有字段。</li><li><code>from log_bus_runinfo</code>：从表 log_bus_runinfo 中进行查询。</li><li><code>where bus_id = #{busid}</code>：限制查询结果中 bus_id 等于传入参数 busid 的那些行。</li><li><code>&lt;if test="beforeminute !=null"&gt;...&lt;/if&gt;</code>：判断是否需要筛选时间。如果传入参数 beforeminute 不为 null，则进行筛选；否则不进行筛选。</li><li><code>and created_date&gt;(now() + ('-'||#{beforeminute}||' min')::interval)</code>：如果进行了时间筛选，则只选择 created_date 大于当前时间减去参数 beforeminute 所代表分钟数之后的那些记录。</li><li><code>order by created_date desc</code>：按照 created_date 字段逆序排列（即最新的记录排在前面）。</li><li><code>limit 1</code>：仅返回第一条记录作为查询结果。</li></ul> 
<p>总体来看，该 sql 语句是基于某个 bus_id 查找其最近的行驶记录，并且可以通过参数 beforeminute 控制所要查找的记录的时间范围。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f755917fdfe29dfc53ee74e0b7e26ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">word双栏排版，删除分节符双栏就变成了单栏，删除最后空白页方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d0692448f03bc9dd06a7fed1061862b3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LINUX操作系统开放指定端口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>