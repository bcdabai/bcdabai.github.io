<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>车载娱乐系统之Android系统CarFramework流程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="车载娱乐系统之Android系统CarFramework流程" />
<meta property="og:description" content="目录
一，背景介绍
1.1 Android Automotive与整个Android生态系统的关系
1.2 Android Automotive架构
二，CarService启动流程
三，CarService源码分析
四. Car API 使用方式
4.1 编译 Car API
4.2 使用 Car API
一，背景介绍 Android Automotive OS 定义了标准的硬件抽象层HAL(Hardware Abstraction Layer)来规范各个子系统与Framework的调用接口, 并且通过CarService以及相关的Car API对上层应用提供标准编程接口。
1.1 Android Automotive与整个Android生态系统的关系 Android Automotive是Android的一部分。 Android Automotive不是Android的分支或并行开发，它与手机，平板电脑等安卓设备上的Android具有相同的代码库，并且位于相同的存储库中。它基于经过10多年开发的强大平台和功能集，可利用现有的安全模型，兼容性程序，开发人员工具和基础架构，同时继续具有高度可定制性和可移植性，完全免费和开源的特点。
Android Automotive扩展了Android 。在将Android打造为功能齐全的信息娱乐平台的过程中，我们添加了对汽车特定要求，功能和技术的支持。就像今天用于移动设备的Android一样，Android Automotive将是一个完整的汽车信息娱乐平台。
1.2 Android Automotive架构 Android Automative是在原先Android的系统架构上增加了一些与车相关的（图中虚线框中绿色背景的）模块。
Car App ：包括OEM和第三方开发的AppCar API ：提供给汽车App特有的接口Car Service ：系统中与车相关的服务，主要是基于CarProperty实现Vechile相关的一些策略Vehicle Network Service ：汽车的网络服务Vehicle HAL ：汽车的硬件抽象层描述，定义 OEM 可以实现的车辆属性的接口 二，CarService启动流程 细节代码如下:
路径：/frameworks/base/services/java/com/android/server/SystemServer.java
if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) { t.traceBegin(&#34;StartCarServiceHelperService&#34;); mSystemServiceManager.startService(CAR_SERVICE_HELPER_SERVICE_CLASS); t." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a1ffe2064c8bd7487638bc59102cc201/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-25T10:39:04+08:00" />
<meta property="article:modified_time" content="2023-09-25T10:39:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">车载娱乐系统之Android系统CarFramework流程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%EF%BC%8C%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E4%B8%80%EF%BC%8C%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D" rel="nofollow">一，背景介绍</a></p> 
<p id="1.1%C2%A0%20Android%20Automotive%E4%B8%8E%E6%95%B4%E4%B8%AAAndroid%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#1.1%C2%A0%20Android%20Automotive%E4%B8%8E%E6%95%B4%E4%B8%AAAndroid%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow">1.1  Android Automotive与整个Android生态系统的关系</a></p> 
<p id="1.2%C2%A0%C2%A0Android%20Automotive%E6%9E%B6%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.2%C2%A0%C2%A0Android%20Automotive%E6%9E%B6%E6%9E%84" rel="nofollow">1.2  Android Automotive架构</a></p> 
<p id="%E4%BA%8C%EF%BC%8CCarService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%EF%BC%8CCarService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B" rel="nofollow">二，CarService启动流程</a></p> 
<p id="%E4%B8%89%EF%BC%8CCarService%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E4%B8%89%EF%BC%8CCarService%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">三，CarService源码分析</a></p> 
<p id="%E5%9B%9B.%20Car%20API%20%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%20Car%20API%20%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" rel="nofollow">四. Car API 使用方式</a></p> 
<p id="%C2%A04.1%C2%A0%20%E7%BC%96%E8%AF%91%20Car%20API-toc" style="margin-left:40px;"><a href="#%C2%A04.1%C2%A0%20%E7%BC%96%E8%AF%91%20Car%20API" rel="nofollow"> 4.1  编译 Car API</a></p> 
<p id="4.2%C2%A0%20%E4%BD%BF%E7%94%A8%20Car%20API-toc" style="margin-left:40px;"><a href="#4.2%C2%A0%20%E4%BD%BF%E7%94%A8%20Car%20API" rel="nofollow">4.2  使用 Car API</a></p> 
<hr id="hr-toc"> 
<h2 id="%E4%B8%80%EF%BC%8C%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D">一，背景介绍</h2> 
<p>        Android Automotive OS 定义了标准的硬件抽象层HAL(Hardware Abstraction Layer)来规范各个子系统与Framework的调用接口, 并且通过CarService以及相关的Car API对上层应用提供标准编程接口。</p> 
<h3 id="1.1%C2%A0%20Android%20Automotive%E4%B8%8E%E6%95%B4%E4%B8%AAAndroid%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E7%B3%BB">1.1  Android Automotive与整个Android生态系统的关系</h3> 
<ul><li> <p>Android Automotive是Android的一部分。 Android Automotive不是Android的分支或并行开发，它与手机，平板电脑等安卓设备上的Android具有相同的代码库，并且位于相同的存储库中。它基于经过10多年开发的强大平台和功能集，可利用现有的安全模型，兼容性程序，开发人员工具和基础架构，同时继续具有高度可定制性和可移植性，完全免费和开源的特点。</p> </li><li> <p>Android Automotive扩展了Android 。在将Android打造为功能齐全的信息娱乐平台的过程中，我们添加了对汽车特定要求，功能和技术的支持。就像今天用于移动设备的Android一样，Android Automotive将是一个完整的汽车信息娱乐平台。</p> </li></ul> 
<h3 id="1.2%C2%A0%C2%A0Android%20Automotive%E6%9E%B6%E6%9E%84">1.2  Android Automotive架构</h3> 
<p><img alt="" height="609" src="https://images2.imgbox.com/59/d1/iaVYIdUS_o.png" width="1061"></p> 
<p>Android Automative是在原先Android的系统架构上增加了一些与车相关的（图中虚线框中绿色背景的）模块。</p> 
<ul><li>Car App ：包括OEM和第三方开发的App</li><li>Car API ：提供给汽车App特有的接口</li><li>Car Service ：系统中与车相关的服务，主要是基于CarProperty实现Vechile相关的一些策略</li><li>Vehicle Network Service ：汽车的网络服务</li><li>Vehicle HAL ：汽车的硬件抽象层描述，定义 OEM 可以实现的车辆属性的接口</li></ul> 
<h2 id="%E4%BA%8C%EF%BC%8CCarService%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><br> 二，CarService启动流程</h2> 
<p><img alt="" height="577" src="https://images2.imgbox.com/3f/fa/xEVdYxLP_o.png" width="877"></p> 
<p></p> 
<p>细节代码如下:</p> 
<p>路径：/frameworks/base/services/java/com/android/server/SystemServer.java</p> 
<pre><code class="hljs"> if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
                t.traceBegin("StartCarServiceHelperService");
                mSystemServiceManager.startService(CAR_SERVICE_HELPER_SERVICE_CLASS);
                t.traceEnd();
            }</code></pre> 
<p>后跳转到SystemServiceManager.java文件中的startService方法</p> 
<p>frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</p> 
<pre><code class="hljs">public SystemService startService(String className) {
        final Class&lt;SystemService&gt; serviceClass;
        try {
            serviceClass = (Class&lt;SystemService&gt;)Class.forName(className);
        } catch (ClassNotFoundException ex) {
            Slog.i(TAG, "Starting " + className);
            throw new RuntimeException("Failed to create service " + className
                    + ": service class not found, usually indicates that the caller should "
                    + "have called PackageManager.hasSystemFeature() to check whether the "
                    + "feature is available on this device before trying to start the "
                    + "services that implement it", ex);
        }
        return startService(serviceClass);
    }
 
 public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) {
 
     final String name = serviceClass.getName();
     ....
      try {     //注释1
                Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);
                service = constructor.newInstance(mContext);
     ....
     startService(service);
     return service;
...
}
 
public void startService(@NonNull final SystemService service) {
        // Register it.
        mServices.add(service);
        // Start it.
        long time = SystemClock.elapsedRealtime();
        try {
            //注释2 启动CarService
            service.onStart();
.....
}</code></pre> 
<p>注释1处,  通过SystemServiceManager封装的方法来创建服务, 此处SystemServiceManager通过反射创建了CarServiceHelperService对象, 并调用其onStart方法, 进入到CarServiceHelperService.java文件中<br>  </p> 
<pre><code class="hljs">public void onStart() {
        Intent intent = new Intent();
        intent.setPackage("com.android.car");
        intent.setAction(CAR_SERVICE_INTERFACE);
        if (!getContext().bindServiceAsUser(intent, mCarServiceConnection, Context.BIND_AUTO_CREATE,
                UserHandle.SYSTEM)) {
            Slog.wtf(TAG, "cannot start car service");
        }
        System.loadLibrary("car-framework-service-jni");
    }</code></pre> 
<p>注释二处   在onStart方法中, 创建了一个Intent    设置包名 和 Action  并调用bindServiceAsUser创建和绑定关联CarService,  同时加载了相关的JNI库(car-framework-service-jni).</p> 
<p>通过以上的源码片段, 我们知道Intent的目标包名为"com.android.car", action为"android.car.ICar",  源码全局搜索与之相匹配的Service   </p> 
<p>packages/services/Car/service/src/com/android/car/CarService.java</p> 
<pre><code class="hljs">&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:androidprv="http://schemas.android.com/apk/prv/res/android"
        package="com.android.car"
        coreApp="true"
        android:sharedUserId="android.uid.system"&gt;
 
 
 
 &lt;service android:name=".CarService"
                android:singleUser="true"&gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.car.ICar" /&gt;
            &lt;/intent-filter&gt;
        &lt;/service&gt;
 </code></pre> 
<p></p> 
<h2 id="%E4%B8%89%EF%BC%8CCarService%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">三，CarService源码分析</h2> 
<p>当服务启动之后, 首先调用其onCreate方法.  CarService的onCreate方法实现如下:</p> 
<pre><code class="hljs"> @Override
    public void onCreate() {
        Log.i(CarLog.TAG_SERVICE, "Service onCreate");
        //获取通知管理NotificationManager对象
        mCanBusErrorNotifier = new CanBusErrorNotifier(this /* context */);
        mVehicle = getVehicle();
 
        if (mVehicle == null) {
            throw new IllegalStateException("Vehicle HAL service is not available.");
        }
        try {
            mVehicleInterfaceName = mVehicle.interfaceDescriptor();
        } catch (RemoteException e) {
            throw new IllegalStateException("Unable to get Vehicle HAL interface descriptor", e);
        }
 
        Log.i(CarLog.TAG_SERVICE, "Connected to " + mVehicleInterfaceName);
 
        mICarImpl = new ICarImpl(this,
                mVehicle,
                SystemInterface.Builder.defaultSystemInterface(this).build(),
                mCanBusErrorNotifier,
                mVehicleInterfaceName);
        mICarImpl.init();
 
        linkToDeath(mVehicle, mVehicleDeathRecipient);
 
        ServiceManager.addService("car_service", mICarImpl);
        //设置SystemProperty属性  carService已创建
        SystemProperties.set("boot.car_service_created", "1");
        super.onCreate();
    }</code></pre> 
<p>主要做了两件事情:</p> 
<p>1.  获取mVehicle 车辆相关的HIDL Binder远程对象;</p> 
<p>2. 创建了mICarImpl对象, 并将其添加到ServiceManager管理的服务列表中.</p> 
<p>这里的 ICarImpl起着创建并管理各个服务的作用. 在它的构造函数中,创建了各个服务的实例,并添加到服务列表中,源码如下:</p> 
<p>packages/services/Car/service/src/com/android/car/ICarImpl.java</p> 
<pre><code class="hljs">public ICarImpl(Context serviceContext, IVehicle vehicle, SystemInterface systemInterface,
            CanBusErrorNotifier errorNotifier, String vehicleInterfaceName) {
        mContext = serviceContext;
        mSystemInterface = systemInterface;
        mHal = new VehicleHal(vehicle);
        mVehicleInterfaceName = vehicleInterfaceName;
        //创建各种重要的服务
        mUserManagerHelper = new CarUserManagerHelper(serviceContext);
        final Resources res = mContext.getResources();
        final int maxRunningUsers = res.getInteger(
                com.android.internal.R.integer.config_multiuserMaxRunningUsers);
        mCarUserService = new CarUserService(serviceContext, mUserManagerHelper,
                ActivityManager.getService(), maxRunningUsers);
        mSystemActivityMonitoringService = new SystemActivityMonitoringService(serviceContext);
        mCarPowerManagementService = new CarPowerManagementService(mContext, mHal.getPowerHal(),
                systemInterface, mUserManagerHelper);
        mCarPropertyService = new CarPropertyService(serviceContext, mHal.getPropertyHal());
        ....
        
        //将重要的服务缓存到 CarLocalServices
        CarLocalServices.addService(CarPowerManagementService.class, mCarPowerManagementService);
        CarLocalServices.addService(CarUserService.class, mCarUserService);
        CarLocalServices.addService(CarTrustedDeviceService.class, mCarTrustedDeviceService);
 
 
         // 将创建的服务对象依次添加到一个list中保存起来
         List&lt;CarServiceBase&gt; allServices = new ArrayList&lt;&gt;();
         allServices.add(mFeatureController);
         allServices.add(mCarUserService);
 
.....
}</code></pre> 
<p>这些创建的服务就是上文介绍的汽车服务.</p> 
<h2 id="%E5%9B%9B.%20Car%20API%20%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">四. Car API 使用方式</h2> 
<p>        在上面的介绍中，我们提到CarService中各个服务本质上是AIDL接口的实现类，属于Server端，而对应的Client端就需要一个IBinder对象来访问Server端的方法，这些IBinder对象在Car API中被封装在一个个XXXManager类中。</p> 
<h3 id="%C2%A04.1%C2%A0%20%E7%BC%96%E8%AF%91%20Car%20API"><br>  4.1  编译 Car API</h3> 
<p>        在使用Car API之前，我们需要先将Car API编译成jar也就是CarLib，这样才能让其它的系统应用使用, 命令如下<br>  </p> 
<pre><code class="hljs">make android.car android.car-system-stubs android.car-stubs</code></pre> 
<p>编译成功后的 android.car.jar  的输出路径为:</p> 
<p>/out/soong/.intermediates/packages/services/Car/car-lib/android.car/android_common/javac/android.car.jar</p> 
<h3 id="4.2%C2%A0%20%E4%BD%BF%E7%94%A8%20Car%20API">4.2  使用 Car API</h3> 
<p>获取Car对象的方法:</p> 
<pre><code class="hljs">if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
    Car carClient = Car.createCar(context);
    CarHvacManager manager = (CarHvacManager) carClient.getCarManager(Car.HVAC_SERVICE);
}</code></pre> 
<p>        如果要获取车辆的相关信息,如车速, 车内空调温度,诊断信息, 或对车辆进行相关的控制,如升高和降低空调温度,控制座椅和车窗, 调节音量等,就要通过具体的Manager中的API和对应的服务来实现了.</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/221d6dbf7b4481a5067714d2c0b0feb9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux系统anaconda常用命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/742a126ffbed9a783408e1fc130de422/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32 USB CDC 虚拟串口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>