<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>canny算子_紫光同创PGL22G开发平台试用连载（3）——驱动OV5640 摄像头实现sobel算子边缘检测算法... - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="canny算子_紫光同创PGL22G开发平台试用连载（3）——驱动OV5640 摄像头实现sobel算子边缘检测算法..." />
<meta property="og:description" content="通过近一个月的学习，紫光同创PGL22Gfpga已经和spartan6和kintex7不相上下了，紫光EDA生态也趋于完善。EDA是FPGA皇冠上的明珠。FPGA更大的逻辑规模和更高的性能，意味着指数级增长的软件算法复杂度。Pango Design Suite是紫光同创基于多年FPGA开发软件技术攻关与工程实践经验而研发的一款拥有国产自主知识产权的大规模FPGA开发软件，已经可以支持数千万门级FPGA器件的设计，并可实现从RTL综合到配置数据流生成下载的全套操作，形成了完全自主知识产权的FPGA开发工具套件，更适合国内研发需要，某些方面比Altera 和Xilinx公司Quartus II Vivado和ISE更加人性化。
边缘检测算法是图像处理中最为基本的问题。其目的是标志图像出亮度变化明显的点，从而反映出图像中重要变化。边缘是图像最基本的特征，其在计算机视觉、图像分析等应用中起着重要的作用，这是因为图像的边缘包含了用于识别的有用信息，是图像分析和模式识别的主要特征提取手段。在图像中，“边缘”指的是临界的意思。一幅图像的“临界”表示为图像上亮度显著变化的地方，边缘指的是一个区域的结束，也是另一个区域的开始。“边缘点”指的是图像中具有坐标[x,y]，且处在强度显著变化的位置上的点。常用的边缘检测算法大多是以原始图像灰度值为基础,通过考察图像的每个像素的某个邻域内灰度的变化,利用边缘一阶或二阶导数的规律来检测边缘。
实现边缘检测有很多不同的方法，也一直是图像处理中的研究热点，人们期望找到一种抗噪强、定位准、不漏检、不误检的检测算法。边缘检测算子，一阶：Roberts Cross算子，Prewitt算子，Sobel算子， Kirsch算子，罗盘算子；二阶：Marr-Hildreth，在梯度方向的二阶导数过零点，Canny算子，Laplacian算子。其中 Sobel 算子效果较好，边缘检测算法比较简单，实际应用中效率比 canny 边缘检测效率要高，但是边缘不如 Canny 检测的准确，但是很多实际应用的场合， sobel 边缘却是首选，尤其是对效率要求较高，而对细纹理不太关心的时候。采用 Sobel 的算法来实现视频图像的边缘检测。Sobel 算子是像素图像边缘检测中最重要的算子之一，该算子包含两组3x3的矩阵，分别为横向及纵向，将之与图像作平面卷积，即可分别得出横向及纵向的亮度差分近似值。如下图，Gx和Gy分别是在横向及纵向的灰度偏导的近似值。 为了在一副图像f的(x,y)位置处寻找边缘的强度和方向，所选择的工具就是梯度，向量定义为：
公式
Sobel算法：
1、把图像每三行三列的数据分别乘上算子中对应位置的值再相加。然后进行如下运算，得到相应方向(x和y)的Dx和Dy。
Dx=(a3-a1)&#43;(b3-b1)*2&#43;c3-c1;
Dy=(a1-c1)&#43;(a2-c2)*2&#43;a3-c3;
2、对上面求得的Dx和Dy做平方和的平方根，再取近似值Dx和Dy的绝对值的和得到Dxy：
Dxy=Dx2&#43;Dy2=(∣Dx∣&#43;∣Dy∣)Dxy = \sqrt{Dx^2&#43;Dy^2} =(\left|Dx\right|&#43;\left|Dy\right|)Dxy=Dx2&#43;Dy2=(∣Dx∣&#43;∣Dy∣)
3、如果Dxy的值大于一个阈值，表示该点为边界点，就让VGA显示一个白点，否则显示黑点。
4、把计算的结果通过vga显示，显示器会把是边界点的以白色像素显示，不是边界点的以黑色像素点显示，于是得到了一幅图像的轮廓。
sobel 算法的实现，首先需要一个 3x3 的像素窗口，本实验利用 xilinx 提供的VHDL 程序，做了一个 3 行的图像缓存，这样就可以轻松实现 3x3 的窗口。
然后按照简化公式，采用绝对值的方式计算 sobel。
架构
module sobel (
input rst,
input pclk,
input[7:0] threshold,
input de,
input[7:0] data_in,
output reg[7:0] data_out
);
reg[7:0] p11,p12,p13;
reg[7:0] p21,p22,p23;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/54b35119f0d0309ddf2535238e56d403/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-28T14:18:00+08:00" />
<meta property="article:modified_time" content="2020-11-28T14:18:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">canny算子_紫光同创PGL22G开发平台试用连载（3）——驱动OV5640 摄像头实现sobel算子边缘检测算法...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="._5ce-wx-style" style="font-size:16px;"> 
 <div class="rich_media_content" id="js_content"> 
  <p>通过近一个月的学习，紫光同创PGL22Gfpga已经和spartan6和kintex7不相上下了，紫光EDA生态也趋于完善。EDA是FPGA皇冠上的明珠。FPGA更大的逻辑规模和更高的性能，意味着指数级增长的软件算法复杂度。Pango Design Suite是紫光同创基于多年FPGA开发软件技术攻关与工程实践经验而研发的一款拥有国产自主知识产权的大规模FPGA开发软件，已经可以支持数千万门级FPGA器件的设计，并可实现从RTL综合到配置数据流生成下载的全套操作，形成了完全自主知识产权的FPGA开发工具套件，更适合国内研发需要，某些方面比Altera 和Xilinx公司Quartus II Vivado和ISE更加人性化。</p> 
  <p><strong>边缘检测算法</strong>是图像处理中最为基本的问题。其目的是标志图像出亮度变化明显的点，从而反映出图像中重要变化。边缘是图像最基本的特征，其在计算机视觉、图像分析等应用中起着重要的作用，这是因为图像的边缘包含了用于识别的有用信息，是图像分析和模式识别的主要特征提取手段。在图像中，“边缘”指的是临界的意思。一幅图像的“临界”表示为图像上亮度显著变化的地方，边缘指的是一个区域的结束，也是另一个区域的开始。“边缘点”指的是图像中具有坐标[x,y]，且处在强度显著变化的位置上的点。常用的边缘检测算法大多是以原始图像灰度值为基础,通过考察图像的每个像素的某个邻域内灰度的变化,利用边缘一阶或二阶导数的规律来检测边缘。<br>实现边缘检测有很多不同的方法，也一直是图像处理中的研究热点，人们期望找到一种抗噪强、定位准、不漏检、不误检的检测算法。边缘检测算子，一阶：Roberts Cross算子，Prewitt算子，Sobel算子， Kirsch算子，罗盘算子；二阶：Marr-Hildreth，在梯度方向的二阶导数过零点，Canny算子，Laplacian算子。其中 Sobel 算子效果较好，边缘检测算法比较简单，实际应用中效率比 canny 边缘检测效率要高，但是边缘不如 Canny 检测的准确，但是很多实际应用的场合， sobel 边缘却是首选，尤其是对效率要求较高，而对细纹理不太关心的时候。采用 Sobel 的算法来实现视频图像的边缘检测。Sobel 算子是像素图像边缘检测中最重要的算子之一，该算子包含两组3x3的矩阵，分别为横向及纵向，将之与图像作平面卷积，即可分别得出横向及纵向的亮度差分近似值。如下图，Gx和Gy分别是在横向及纵向的灰度偏导的近似值。 为了在一副图像f的(x,y)位置处寻找边缘的强度和方向，所选择的工具就是梯度，向量定义为：</p> 
  <p>公式</p> 
  <p><img src="https://images2.imgbox.com/2b/42/1Fv6U6I9_o.png" alt="dc03c81d789cc6bd91c57c33d40deeeb.png"></p> 
  <p>Sobel算法：</p> 
  <p>1、把图像每三行三列的数据分别乘上算子中对应位置的值再相加。然后进行如下运算，得到相应方向(x和y)的Dx和Dy。<br>Dx=(a3-a1)+(b3-b1)*2+c3-c1;<br>Dy=(a1-c1)+(a2-c2)*2+a3-c3;</p> 
  <p>2、对上面求得的Dx和Dy做平方和的平方根，再取近似值Dx和Dy的绝对值的和得到Dxy：<br>Dxy=Dx2+Dy2=(∣Dx∣+∣Dy∣)Dxy = \sqrt{Dx^2+Dy^2} =(\left|Dx\right|+\left|Dy\right|)Dxy=Dx2+Dy2=(∣Dx∣+∣Dy∣)</p> 
  <p>3、如果Dxy的值大于一个阈值，表示该点为边界点，就让VGA显示一个白点，否则显示黑点。</p> 
  <p>4、把计算的结果通过vga显示，显示器会把是边界点的以白色像素显示，不是边界点的以黑色像素点显示，于是得到了一幅图像的轮廓。</p> 
  <p>sobel 算法的实现，首先需要一个 3x3 的像素窗口，本实验利用 xilinx 提供的VHDL 程序，做了一个 3 行的图像缓存，这样就可以轻松实现 3x3 的窗口。<br>然后按照简化公式，采用绝对值的方式计算 sobel。</p> 
  <p>架构</p> 
  <p><img src="https://images2.imgbox.com/69/03/LzL0QzU2_o.png" alt="2471fbe16f1ced33c06cac10c951de5e.png"></p> 
  <p>module sobel (</p> 
  <p>input rst,</p> 
  <p>input pclk,</p> 
  <p>input[7:0] threshold,</p> 
  <p>input de,</p> 
  <p>input[7:0] data_in,</p> 
  <p>output reg[7:0] data_out</p> 
  <p>);</p> 
  <p>reg[7:0] p11,p12,p13;</p> 
  <p>reg[7:0] p21,p22,p23;</p> 
  <p>reg[7:0] p31,p32,p33;</p> 
  <p>wire[7:0] p1,p2,p3;</p> 
  <p>reg[9:0] x1,x3;</p> 
  <p>reg[9:0] y1,y3;</p> 
  <p>reg[9:0] abs_x,abs_y;</p> 
  <p>reg[10:0] abs_g;</p> 
  <p>linebuffer_Wapper#</p> 
  <p>(</p> 
  <p>.no_of_lines(3),</p> 
  <p>.samples_per_line(1024),</p> 
  <p>.data_width(8)</p> 
  <p>)</p> 
  <p>linebuffer_Wapper_m0(</p> 
  <p>.ce (1'b1 ),</p> 
  <p>.wr_clk (pclk ),</p> 
  <p>.wr_en (de ),</p> 
  <p>.wr_rst (rst ),</p> 
  <p>.data_in (data_in),</p> 
  <p>.rd_en (de ),</p> 
  <p>.rd_clk (pclk ),</p> 
  <p>.rd_rst (rst ),</p> 
  <p>.data_out ({p3,p2,p1} )</p> 
  <p>);</p> 
  <p>always@(posedge pclk)</p> 
  <p>begin</p> 
  <p>p11 &lt;= p1;</p> 
  <p>p21 &lt;= p2;</p> 
  <p>p31 &lt;= p3;</p> 
  <p>p12 &lt;= p11;</p> 
  <p>p22 &lt;= p21;</p> 
  <p>p32 &lt;= p31;</p> 
  <p>p13 &lt;= p12;</p> 
  <p>p23 &lt;= p22;</p> 
  <p>p33 &lt;= p32;</p> 
  <p>end</p> 
  <p>always@(posedge pclk)</p> 
  <p>begin</p> 
  <p>x1 &lt;= {2'b00,p11} + {2'b00,p31} + {1'b0,p21,1'b0};</p> 
  <p>x3 &lt;= {2'b00,p13} + {2'b00,p33} + {1'b0,p23,1'b0};</p> 
  <p>y1 &lt;= {2'b00,p11} + {2'b00,p13} + {1'b0,p12,1'b0};</p> 
  <p>y3 &lt;= {2'b00,p31} + {2'b00,p33} + {1'b0,p32,1'b0};</p> 
  <p>end</p> 
  <p>always@(posedge pclk)</p> 
  <p>begin</p> 
  <p>abs_x &lt;= (x1 &gt; x3) ? x1 - x3 : x3 - x1;</p> 
  <p>abs_y &lt;= (y1 &gt; y3) ? y1 - y3 : y3 - y1;</p> 
  <p>abs_g &lt;= abs_x + abs_y;</p> 
  <p>end</p> 
  <p>always@(posedge pclk)</p> 
  <p>begin</p> 
  <p>data_out &lt;= (abs_g &gt; threshold) ? 8'h00 : 8'hff;</p> 
  <p>end</p> 
  <p>endmodule</p> 
  <p>module top(</p> 
  <p>input sys_clk,</p> 
  <p>input rst_n,</p> 
  <p>inout cmos_scl,</p> 
  <p>inout cmos_sda,</p> 
  <p>input cmos_vsync,</p> 
  <p>input cmos_href,</p> 
  <p>input cmos_pclk,</p> 
  <p>output cmos_xclk,</p> 
  <p>input [7:0] cmos_db,</p> 
  <p>//ddr</p> 
  <p>input pad_loop_in ,</p> 
  <p>input pad_loop_in_h ,</p> 
  <p>output pad_rstn_ch0 ,</p> 
  <p>output pad_ddr_clk_w ,</p> 
  <p>output pad_ddr_clkn_w ,</p> 
  <p>output pad_csn_ch0 ,</p> 
  <p>output [15:0] pad_addr_ch0 ,</p> 
  <p>inout [16-1:0] pad_dq_ch0 ,</p> 
  <p>inout [16/8-1:0] pad_dqs_ch0 ,</p> 
  <p>inout [16/8-1:0] pad_dqsn_ch0 ,</p> 
  <p>output [16/8-1:0] pad_dm_rdqs_ch0 ,</p> 
  <p>output pad_cke_ch0 ,</p> 
  <p>output pad_odt_ch0 ,</p> 
  <p>output pad_rasn_ch0 ,</p> 
  <p>output pad_casn_ch0 ,</p> 
  <p>output pad_wen_ch0 ,</p> 
  <p>output [2:0] pad_ba_ch0 ,</p> 
  <p>output pad_loop_out ,</p> 
  <p>output pad_loop_out_h ,</p> 
  <p>//hdmi output</p> 
  <p>output tmds_clk_p,</p> 
  <p>output tmds_clk_n,</p> 
  <p>output [2:0] tmds_data_p,</p> 
  <p>output [2:0] tmds_data_n</p> 
  <p>);</p> 
  <p>parameter MEM_DATA_BITS = 64; //external memory user interface data width</p> 
  <p>parameter ADDR_BITS = 25; //external memory user interface address width</p> 
  <p>parameter BUSRT_BITS = 10; //external memory user interface burst width</p> 
  <p>wire wr_burst_data_req;</p> 
  <p>wire wr_burst_finish;</p> 
  <p>wire rd_burst_finish;</p> 
  <p>wire rd_burst_req;</p> 
  <p>wire wr_burst_req;</p> 
  <p>wire[BUSRT_BITS - 1:0] rd_burst_len;</p> 
  <p>wire[BUSRT_BITS - 1:0] wr_burst_len;</p> 
  <p>wire[ADDR_BITS - 1:0] rd_burst_addr;</p> 
  <p>wire[ADDR_BITS - 1:0] wr_burst_addr;</p> 
  <p>wire rd_burst_data_valid;</p> 
  <p>wire[MEM_DATA_BITS - 1 : 0] rd_burst_data;</p> 
  <p>wire[MEM_DATA_BITS - 1 : 0] wr_burst_data;</p> 
  <p>wire read_req;</p> 
  <p>wire read_req_ack;</p> 
  <p>wire read_en;</p> 
  <p>wire[15:0] read_data;</p> 
  <p>wire write_en;</p> 
  <p>wire[15:0] write_data;</p> 
  <p>wire write_req;</p> 
  <p>wire write_req_ack;</p> 
  <p>wire video_clk; //video pixel clock</p> 
  <p>wire video_clk5x;</p> 
  <p>wire hs;</p> 
  <p>wire vs;</p> 
  <p>wire de;</p> 
  <p>wire[15:0] vout_data;</p> 
  <p>wire[15:0] cmos_16bit_data;</p> 
  <p>wire cmos_16bit_wr;</p> 
  <p>wire[1:0] write_addr_index;</p> 
  <p>wire[1:0] read_addr_index;</p> 
  <p>wire[9:0] lut_index;</p> 
  <p>wire[31:0] lut_data;</p> 
  <p>wire ui_clk;</p> 
  <p>wire ui_clk_sync_rst;</p> 
  <p>wire init_calib_complete;</p> 
  <p>// Master Write Address</p> 
  <p>wire [3:0] s00_axi_awid;</p> 
  <p>wire [63:0] s00_axi_awaddr;</p> 
  <p>wire [7:0] s00_axi_awlen; // burst length: 0-255</p> 
  <p>wire [2:0] s00_axi_awsize; // burst size: fixed 2'b011</p> 
  <p>wire [1:0] s00_axi_awburst; // burst type: fixed 2'b01(incremental burst)</p> 
  <p>wire s00_axi_awlock; // lock: fixed 2'b00</p> 
  <p>wire [3:0] s00_axi_awcache; // cache: fiex 2'b0011</p> 
  <p>wire [2:0] s00_axi_awprot; // protect: fixed 2'b000</p> 
  <p>wire [3:0] s00_axi_awqos; // qos: fixed 2'b0000</p> 
  <p>wire [0:0] s00_axi_awuser; // user: fixed 32'd0</p> 
  <p>wire s00_axi_awvalid;</p> 
  <p>wire s00_axi_awready;</p> 
  <p>// master write data</p> 
  <p>wire [63:0] s00_axi_wdata;</p> 
  <p>wire [7:0] s00_axi_wstrb;</p> 
  <p>wire s00_axi_wlast;</p> 
  <p>wire [0:0] s00_axi_wuser;</p> 
  <p>wire s00_axi_wvalid;</p> 
  <p>wire s00_axi_wready;</p> 
  <p>// master write response</p> 
  <p>wire [3:0] s00_axi_bid;</p> 
  <p>wire [1:0] s00_axi_bresp;</p> 
  <p>wire [0:0] s00_axi_buser;</p> 
  <p>wire s00_axi_bvalid;</p> 
  <p>wire s00_axi_bready;</p> 
  <p>// master read address</p> 
  <p>wire [3:0] s00_axi_arid;</p> 
  <p>wire [63:0] s00_axi_araddr;</p> 
  <p>wire [7:0] s00_axi_arlen;</p> 
  <p>wire [2:0] s00_axi_arsize;</p> 
  <p>wire [1:0] s00_axi_arburst;</p> 
  <p>wire [1:0] s00_axi_arlock;</p> 
  <p>wire [3:0] s00_axi_arcache;</p> 
  <p>wire [2:0] s00_axi_arprot;</p> 
  <p>wire [3:0] s00_axi_arqos;</p> 
  <p>wire [0:0] s00_axi_aruser;</p> 
  <p>wire s00_axi_arvalid;</p> 
  <p>wire s00_axi_arready;</p> 
  <p>// master read data</p> 
  <p>wire [3:0] s00_axi_rid;</p> 
  <p>wire [63:0] s00_axi_rdata;</p> 
  <p>wire [1:0] s00_axi_rresp;</p> 
  <p>wire s00_axi_rlast;</p> 
  <p>wire [0:0] s00_axi_ruser;</p> 
  <p>wire s00_axi_rvalid;</p> 
  <p>wire s00_axi_rready;</p> 
  <p>wire hdmi_hs;</p> 
  <p>wire hdmi_vs;</p> 
  <p>wire hdmi_de;</p> 
  <p>wire[7:0] hdmi_r;</p> 
  <p>wire[7:0] hdmi_g;</p> 
  <p>wire[7:0] hdmi_b;</p> 
  <p>wire[7:0] sobel_out;</p> 
  <p>wire[7:0] ycbcr_y;</p> 
  <p>wire ycbcr_hs;</p> 
  <p>wire ycbcr_vs;</p> 
  <p>wire ycbcr_de;</p> 
  <p>assign hdmi_hs = ycbcr_hs;</p> 
  <p>assign hdmi_vs = ycbcr_vs;</p> 
  <p>assign hdmi_de = ycbcr_de;</p> 
  <p>assign hdmi_r = sobel_out[7:0];</p> 
  <p>assign hdmi_g = sobel_out[7:0];</p> 
  <p>assign hdmi_b = sobel_out[7:0];</p> 
  <p>assign write_en = cmos_16bit_wr;</p> 
  <p>assign write_data = {cmos_16bit_data[4:0],cmos_16bit_data[10:5],cmos_16bit_data[15:11]};</p> 
  <p>video_pll video_pll_m0</p> 
  <p>(</p> 
  <p>.clkin1 (sys_clk ),</p> 
  <p>.clkout0 (video_clk ),</p> 
  <p>.clkout1 (video_clk5x ),</p> 
  <p>.clkout2 (cmos_xclk ),</p> 
  <p>.pll_rst (1'b0 ),</p> 
  <p>.pll_lock ( )</p> 
  <p>);</p> 
  <p>wire done_init;</p> 
  <p>dvi_encoder dvi_encoder_m0</p> 
  <p>(</p> 
  <p>.pixelclk (video_clk ),// system clock</p> 
  <p>.pixelclk5x (video_clk5x ),// system clock x5</p> 
  <p>.rstin (~done_init ),// reset</p> 
  <p>.blue_din (hdmi_b ),// Blue data in</p> 
  <p>.green_din (hdmi_g ),// Green data in</p> 
  <p>.red_din (hdmi_r ),// Red data in</p> 
  <p>.hsync (hdmi_hs ),// hsync data</p> 
  <p>.vsync (hdmi_vs ),// vsync data</p> 
  <p>.de (hdmi_de ),// data enable</p> 
  <p>.tmds_clk_p (tmds_clk_p ),</p> 
  <p>.tmds_clk_n (tmds_clk_n ),</p> 
  <p>.tmds_data_p (tmds_data_p ),//rgb</p> 
  <p>.tmds_data_n (tmds_data_n ) //rgb</p> 
  <p>);</p> 
  <p>//I2C master controller</p> 
  <p>i2c_config i2c_config_m0(</p> 
  <p>.rst (~rst_n ),</p> 
  <p>.clk (sys_clk ),</p> 
  <p>.clk_div_cnt (16'd499 ),</p> 
  <p>.i2c_addr_2byte (1'b1 ),</p> 
  <p>.lut_index (lut_index ),</p> 
  <p>.lut_dev_addr (lut_data[31:24] ),</p> 
  <p>.lut_reg_addr (lut_data[23:8] ),</p> 
  <p>.lut_reg_data (lut_data[7:0] ),</p> 
  <p>.error ( ),</p> 
  <p>.done (done_init ),</p> 
  <p>.i2c_scl (cmos_scl ),</p> 
  <p>.i2c_sda (cmos_sda )</p> 
  <p>);</p> 
  <p>//configure look-up table</p> 
  <p>lut_ov5640_rgb565_1024_768 lut_ov5640_rgb565_1024_768_m0(</p> 
  <p>.lut_index (lut_index ),</p> 
  <p>.lut_data (lut_data )</p> 
  <p>);</p> 
  <p>//CMOS sensor 8bit data is converted to 16bit data</p> 
  <p>cmos_8_16bit cmos_8_16bit_m0(</p> 
  <p>.rst (~done_init ),</p> 
  <p>.pclk (cmos_pclk ),</p> 
  <p>.pdata_i (cmos_db ),</p> 
  <p>.de_i (cmos_href ),</p> 
  <p>.pdata_o (cmos_16bit_data ),</p> 
  <p>.hblank ( ),</p> 
  <p>.de_o (cmos_16bit_wr )</p> 
  <p>);</p> 
  <p>//CMOS sensor writes the request and generates the read and write address index</p> 
  <p>cmos_write_req_gen cmos_write_req_gen_m0(</p> 
  <p>.rst (~done_init ),</p> 
  <p>.pclk (cmos_pclk ),</p> 
  <p>.cmos_vsync (cmos_vsync ),</p> 
  <p>.write_req (write_req ),</p> 
  <p>.write_addr_index (write_addr_index ),</p> 
  <p>.read_addr_index (read_addr_index ),</p> 
  <p>.write_req_ack (write_req_ack )</p> 
  <p>);</p> 
  <p>//The video output timing generator and generate a frame read data request</p> 
  <p>video_timing_data video_timing_data_m0</p> 
  <p>(</p> 
  <p>.video_clk (video_clk ),</p> 
  <p>.rst (~done_init ),</p> 
  <p>.read_req (read_req ),</p> 
  <p>.read_req_ack (read_req_ack ),</p> 
  <p>.read_en (read_en ),</p> 
  <p>.read_data (read_data ),</p> 
  <p>.hs (hs ),</p> 
  <p>.vs (vs ),</p> 
  <p>.de (de ),</p> 
  <p>.vout_data (vout_data )</p> 
  <p>);</p> 
  <p>rgb_to_ycbcr rgb_to_ycbcr_m0(</p> 
  <p>.clk (video_clk ),</p> 
  <p>.rst (~done_init ),</p> 
  <p>.rgb_r ({vout_data[15:11],3'd0} ),</p> 
  <p>.rgb_g ({vout_data[10:5],2'd0} ),</p> 
  <p>.rgb_b ({vout_data[4:0],3'd0} ),</p> 
  <p>.rgb_hs (hs ),</p> 
  <p>.rgb_vs (vs ),</p> 
  <p>.rgb_de (de ),</p> 
  <p>.ycbcr_y (ycbcr_y ),</p> 
  <p>.ycbcr_cb ( ),</p> 
  <p>.ycbcr_cr ( ),</p> 
  <p>.ycbcr_hs (ycbcr_hs ),</p> 
  <p>.ycbcr_vs (ycbcr_vs ),</p> 
  <p>.ycbcr_de (ycbcr_de )</p> 
  <p>);</p> 
  <p>sobel sobel_m0(</p> 
  <p>.rst (~done_init ),</p> 
  <p>.pclk (video_clk ),</p> 
  <p>.threshold (8'd40 ),</p> 
  <p>.de (ycbcr_de ),</p> 
  <p>.data_in (ycbcr_y ),</p> 
  <p>.data_out (sobel_out )</p> 
  <p>);</p> 
  <p>//video frame data read-write control</p> 
  <p>frame_read_write frame_read_write_m0</p> 
  <p>(</p> 
  <p>.rst (~done_init ),</p> 
  <p>.mem_clk (ui_clk ),</p> 
  <p>.rd_burst_req (rd_burst_req ),</p> 
  <p>.rd_burst_len (rd_burst_len ),</p> 
  <p>.rd_burst_addr (rd_burst_addr ),</p> 
  <p>.rd_burst_data_valid (rd_burst_data_valid ),</p> 
  <p>.rd_burst_data (rd_burst_data ),</p> 
  <p>.rd_burst_finish (rd_burst_finish ),</p> 
  <p>.read_clk (video_clk ),</p> 
  <p>.read_req (read_req ),</p> 
  <p>.read_req_ack (read_req_ack ),</p> 
  <p>.read_finish ( ),</p> 
  <p>.read_addr_0 (24'd0 ), //The first frame address is 0</p> 
  <p>.read_addr_1 (24'd2073600 ), //The second frame address is 24'd2073600 ,large enough address space for one frame of video</p> 
  <p>.read_addr_2 (24'd4147200 ),</p> 
  <p>.read_addr_3 (24'd6220800 ),</p> 
  <p>.read_addr_index (read_addr_index ),</p> 
  <p>.read_len (24'd196608 ),//frame size</p> 
  <p>.read_en (read_en ),</p> 
  <p>.read_data (read_data ),</p> 
  <p>.wr_burst_req (wr_burst_req ),</p> 
  <p>.wr_burst_len (wr_burst_len ),</p> 
  <p>.wr_burst_addr (wr_burst_addr ),</p> 
  <p>.wr_burst_data_req (wr_burst_data_req ),</p> 
  <p>.wr_burst_data (wr_burst_data ),</p> 
  <p>.wr_burst_finish (wr_burst_finish ),</p> 
  <p>.write_clk (cmos_pclk ),</p> 
  <p>.write_req (write_req ),</p> 
  <p>.write_req_ack (write_req_ack ),</p> 
  <p>.write_finish ( ),</p> 
  <p>.write_addr_0 (24'd0 ),</p> 
  <p>.write_addr_1 (24'd2073600 ),</p> 
  <p>.write_addr_2 (24'd4147200 ),</p> 
  <p>.write_addr_3 (24'd6220800 ),</p> 
  <p>.write_addr_index (write_addr_index ),</p> 
  <p>.write_len (24'd196608 ), //frame size</p> 
  <p>.write_en (write_en ),</p> 
  <p>.write_data (write_data )</p> 
  <p>);</p> 
  <p>ddr3 u_ipsl_hmemc_top (</p> 
  <p>.pll_refclk_in (sys_clk ),</p> 
  <p>.ddr_rstn_key (done_init ),</p> 
  <p>.pll_aclk_0 ( ),</p> 
  <p>.pll_aclk_1 (ui_clk ),</p> 
  <p>.pll_aclk_2 ( ),</p> 
  <p>.pll_lock ( ),</p> 
  <p>.ddrphy_rst_done ( ),</p> 
  <p>.ddrc_init_done (ui_clk_sync_rst),</p> 
  <p>.ddrc_rst (0),</p> 
  <p>.areset_1 (0),</p> 
  <p>.aclk_1 (ui_clk),</p> 
  <p>.awid_1 (s00_axi_awid),</p> 
  <p>.awaddr_1 (s00_axi_awaddr),</p> 
  <p>.awlen_1 (s00_axi_awlen),</p> 
  <p>.awsize_1 (s00_axi_awsize),</p> 
  <p>.awburst_1 (s00_axi_awburst),</p> 
  <p>.awlock_1 (s00_axi_awlock),</p> 
  <p>.awvalid_1 (s00_axi_awvalid),</p> 
  <p>.awready_1 (s00_axi_awready),</p> 
  <p>.awurgent_1 (1'b0), //?</p> 
  <p>.awpoison_1 (1'b0), //?</p> 
  <p>.wdata_1 (s00_axi_wdata),</p> 
  <p>.wstrb_1 (s00_axi_wstrb),</p> 
  <p>.wlast_1 (s00_axi_wlast),</p> 
  <p>.wvalid_1 (s00_axi_wvalid),</p> 
  <p>.wready_1 (s00_axi_wready),</p> 
  <p>.bid_1 (s00_axi_bid),</p> 
  <p>.bresp_1 (s00_axi_bresp),</p> 
  <p>.bvalid_1 (s00_axi_bvalid),</p> 
  <p>.bready_1 (s00_axi_bready),</p> 
  <p>.arid_1 (s00_axi_arid ),</p> 
  <p>.araddr_1 (s00_axi_araddr ),</p> 
  <p>.arlen_1 (s00_axi_arlen ),</p> 
  <p>.arsize_1 (s00_axi_arsize ),</p> 
  <p>.arburst_1 (s00_axi_arburst ),</p> 
  <p>.arlock_1 (s00_axi_arlock ),</p> 
  <p>.arvalid_1 (s00_axi_arvalid ),</p> 
  <p>.arready_1 (s00_axi_arready ),</p> 
  <p>.arpoison_1 (1'b0 ), //?</p> 
  <p>.rid_1 (s00_axi_rid ),</p> 
  <p>.rdata_1 (s00_axi_rdata ),</p> 
  <p>.rresp_1 (s00_axi_rresp ),</p> 
  <p>.rlast_1 (s00_axi_rlast ),</p> 
  <p>.rvalid_1 (s00_axi_rvalid ),</p> 
  <p>.rready_1 (s00_axi_rready ),</p> 
  <p>.arurgent_1 (1'b0), //?</p> 
  <p>.csysreq_1 (1'b1),</p> 
  <p>.csysack_1 (),</p> 
  <p>.cactive_1 (),</p> 
  <p>.csysreq_ddrc (1'b1),</p> 
  <p>.csysack_ddrc (),</p> 
  <p>.cactive_ddrc (),</p> 
  <p>.pad_loop_in (pad_loop_in),</p> 
  <p>.pad_loop_in_h (pad_loop_in_h),</p> 
  <p>.pad_rstn_ch0 (pad_rstn_ch0),</p> 
  <p>.pad_ddr_clk_w (pad_ddr_clk_w),</p> 
  <p>.pad_ddr_clkn_w (pad_ddr_clkn_w),</p> 
  <p>.pad_csn_ch0 (pad_csn_ch0),</p> 
  <p>.pad_addr_ch0 (pad_addr_ch0),</p> 
  <p>.pad_dq_ch0 (pad_dq_ch0),</p> 
  <p>.pad_dqs_ch0 (pad_dqs_ch0),</p> 
  <p>.pad_dqsn_ch0 (pad_dqsn_ch0),</p> 
  <p>.pad_dm_rdqs_ch0 (pad_dm_rdqs_ch0),</p> 
  <p>.pad_cke_ch0 (pad_cke_ch0),</p> 
  <p>.pad_odt_ch0 (pad_odt_ch0),</p> 
  <p>.pad_rasn_ch0 (pad_rasn_ch0),</p> 
  <p>.pad_casn_ch0 (pad_casn_ch0),</p> 
  <p>.pad_wen_ch0 (pad_wen_ch0),</p> 
  <p>.pad_ba_ch0 (pad_ba_ch0),</p> 
  <p>.pad_loop_out (pad_loop_out),</p> 
  <p>.pad_loop_out_h (pad_loop_out_h)</p> 
  <p>);</p> 
  <p>aq_axi_master u_aq_axi_master</p> 
  <p>(</p> 
  <p>.ARESETN (ui_clk_sync_rst ),</p> 
  <p>.ACLK (ui_clk ),</p> 
  <p>.M_AXI_AWID (s00_axi_awid ),</p> 
  <p>.M_AXI_AWADDR (s00_axi_awaddr ),</p> 
  <p>.M_AXI_AWLEN (s00_axi_awlen ),</p> 
  <p>.M_AXI_AWSIZE (s00_axi_awsize ),</p> 
  <p>.M_AXI_AWBURST (s00_axi_awburst ),</p> 
  <p>.M_AXI_AWLOCK (s00_axi_awlock ),</p> 
  <p>.M_AXI_AWCACHE (s00_axi_awcache ),</p> 
  <p>.M_AXI_AWPROT (s00_axi_awprot ),</p> 
  <p>.M_AXI_AWQOS (s00_axi_awqos ),</p> 
  <p>.M_AXI_AWUSER (s00_axi_awuser ),</p> 
  <p>.M_AXI_AWVALID (s00_axi_awvalid ),</p> 
  <p>.M_AXI_AWREADY (s00_axi_awready ),</p> 
  <p>.M_AXI_WDATA (s00_axi_wdata ),</p> 
  <p>.M_AXI_WSTRB (s00_axi_wstrb ),</p> 
  <p>.M_AXI_WLAST (s00_axi_wlast ),</p> 
  <p>.M_AXI_WUSER (s00_axi_wuser ),</p> 
  <p>.M_AXI_WVALID (s00_axi_wvalid ),</p> 
  <p>.M_AXI_WREADY (s00_axi_wready ),</p> 
  <p>.M_AXI_BID (s00_axi_bid ),</p> 
  <p>.M_AXI_BRESP (s00_axi_bresp ),</p> 
  <p>.M_AXI_BUSER (s00_axi_buser ),</p> 
  <p>.M_AXI_BVALID (s00_axi_bvalid ),</p> 
  <p>.M_AXI_BREADY (s00_axi_bready ),</p> 
  <p>.M_AXI_ARID (s00_axi_arid ),</p> 
  <p>.M_AXI_ARADDR (s00_axi_araddr ),</p> 
  <p>.M_AXI_ARLEN (s00_axi_arlen ),</p> 
  <p>.M_AXI_ARSIZE (s00_axi_arsize ),</p> 
  <p>.M_AXI_ARBURST (s00_axi_arburst ),</p> 
  <p>.M_AXI_ARLOCK (s00_axi_arlock ),</p> 
  <p>.M_AXI_ARCACHE (s00_axi_arcache ),</p> 
  <p>.M_AXI_ARPROT (s00_axi_arprot ),</p> 
  <p>.M_AXI_ARQOS (s00_axi_arqos ),</p> 
  <p>.M_AXI_ARUSER (s00_axi_aruser ),</p> 
  <p>.M_AXI_ARVALID (s00_axi_arvalid ),</p> 
  <p>.M_AXI_ARREADY (s00_axi_arready ),</p> 
  <p>.M_AXI_RID (s00_axi_rid ),</p> 
  <p>.M_AXI_RDATA (s00_axi_rdata ),</p> 
  <p>.M_AXI_RRESP (s00_axi_rresp ),</p> 
  <p>.M_AXI_RLAST (s00_axi_rlast ),</p> 
  <p>.M_AXI_RUSER (s00_axi_ruser ),</p> 
  <p>.M_AXI_RVALID (s00_axi_rvalid ),</p> 
  <p>.M_AXI_RREADY (s00_axi_rready ),</p> 
  <p>.MASTER_RST (1'b0 ),</p> 
  <p>.WR_START (wr_burst_req ),</p> 
  <p>.WR_ADRS ({wr_burst_addr,3'd0} ),</p> 
  <p>.WR_LEN ({wr_burst_len,3'd0} ),</p> 
  <p>.WR_READY ( ),</p> 
  <p>.WR_FIFO_RE (wr_burst_data_req ),</p> 
  <p>.WR_FIFO_EMPTY (1'b0 ),</p> 
  <p>.WR_FIFO_AEMPTY (1'b0 ),</p> 
  <p>.WR_FIFO_DATA (wr_burst_data ),</p> 
  <p>.WR_DONE (wr_burst_finish ),</p> 
  <p>.RD_START (rd_burst_req ),</p> 
  <p>.RD_ADRS ({rd_burst_addr,3'd0} ),</p> 
  <p>.RD_LEN ({rd_burst_len,3'd0} ),</p> 
  <p>.RD_READY ( ),</p> 
  <p>.RD_FIFO_WE (rd_burst_data_valid ),</p> 
  <p>.RD_FIFO_FULL (1'b0 ),</p> 
  <p>.RD_FIFO_AFULL (1'b0 ),</p> 
  <p>.RD_FIFO_DATA (rd_burst_data ),</p> 
  <p>.RD_DONE (rd_burst_finish ),</p> 
  <p>.DEBUG ( )</p> 
  <p>);</p> 
  <p>endmodule</p> 
  <p>软件界面</p> 
  <p><img src="https://images2.imgbox.com/18/d8/apcaBHGB_o.png" alt="f92e55b9c03f9db8275d954c698fe514.png"></p> 
  <img src="https://images2.imgbox.com/3c/bd/ICkMX6xZ_o.png" alt="c8cebf2196313aa1db22ba29ac0fb3a6.png"> 
  <p><strong>扫码<strong>免费</strong>申请试用</strong></p> 
  <p><img src="https://images2.imgbox.com/4a/bf/9ytGk73v_o.png" alt="77efbf9783c56ca942936a3643248c43.png"></p>▼ 
  <strong>推荐阅读</strong>▼ 
  <p>紫光同创PGL22G开发平台试用连载-(2)以太网测试工程一</p> 
  <p>紫光同创PGL22G开发平台试用连载-(1)软硬件初步体验</p> 
  <p>紫光同创PGL22G开发平台试用连载(8)---程序密码之程序篇</p> 
  <p>紫光同创PGL22G开发平台试用连载(7)---程序密码之理论篇</p> 
  <p>紫光同创PGL22G开发平台试用连载(6)---边缘检测之综合篇</p> 
  <p>紫光同创PGL22G开发平台试用连载(5)---边缘检测之算法篇</p> 
  <p>紫光同创PGL22G开发平台试用连载(4)---边缘检测之串口通信篇</p> 
  <p>紫光同创PGL22G开发平台试用连载(3)---重点功能初探</p> 
  <p>紫光同创PGL22G开发平台试用连载(2)---基本流程dome</p> 
  <p>紫光同创PGL22G开发平台试用连载(1)---软件和器件</p> 
  <p>紫光同创PGL22G开发平台试用连载(1)-FPGA参数分析和对比</p> 
  <p>紫光同创PGL22G开发平台试用连载(2)---PDS软件试用</p> 
  <p>紫光同创PGL22G开发平台试用连载(3)---在FPGA上实现DW8051 MCU</p> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7a32a8e73675af89efdb650bd12e0db7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">香港攻略 之 首次初次第一次去香港需要注意什么准备什么（仅供参考）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/635de5bb535988dbc40a8415b3ad7472/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">centos7 访问php页面显示源码_7、Linux云计算系列CentOS7网络服务—LNMP</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>