<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>机器学习3 逻辑斯提回归和梯度下降算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="机器学习3 逻辑斯提回归和梯度下降算法" />
<meta property="og:description" content="引言 上节我们介绍了很多线性回归模型，如何用线性模型做分类任务呢？是不是可以将线性回归模型的预测值和到分类任务的标记联系起来呢？
逻辑斯提回归 对于一个二分类任务，输出标记y为{0,1}，而线性回归模型产生的预测值z为全体实数，我们想把z转换成0/1值。我们首先想到是“单位阶跃函数”。
利用线性回归模型产生预测值z，经过单位阶跃函数做变换，如果z&lt;=0，就归为负类，若z&gt;0就归为正类。但单位阶跃函数性质不好，不连续。我们用对数几率函数（也叫sigmoid函数）进行替代：
函数图像为：
这样就将预测值z映射到（0,1）之前，那么怎么进行分类呢？同样是：如果z&lt;=0，就归为负类，若z&gt;0就归为正类。映射到（0,1）还有一个好处是，可以看成近似的概率。例如y=0.8，就说它归为正类的概率为0.8。
上一节讲到我们的线性模型为;
将偏置项和权重系数合并：
其中：
代入到对数几率函数中：
下标sigmoid，表示映射函数为sigmoid函数。这就是逻辑斯提回归模型。
那么我们如何求解参数W呢？
由对数函数的性质可知：
上式即为在已知样本x和参数θ的情况下，样本x属性正样本(y=1)和负样本(y=0)的条件概率。理想状态下，根据上述公式，求出各个点的概率均为1，也就是完全分类都正确。但是考虑到实际情况，样本点的概率越接近于1，其分类效果越好。比如一个样本属于正样本的概率为0.51，那么我们就可以说明这个样本属于正样本。另一个样本属于正样本的概率为0.99，那么我们也可以说明这个样本属于正样本。但是显然，第二个样本概率更高，更具说服力。我们可以把上述两个概率公式合二为一：
合并出来的Cost，我们称之为代价函数(Cost Function)。当y等于1时，(1-y)项(第二项)为0；当y等于0时，y项(第一项)为0。为了简化问题，我们对整个表达式求对数，(将指数问题对数化是处理数学问题常见的方法)：
这个代价函数，是对于一个样本而言的。给定一个样本，我们就可以通过这个代价函数求出，样本所属类别的概率，而这个概率越大越好，所以也就是求解这个代价函数的最大值。既然概率出来了，那么最大似然估计也该出场了。假定样本与样本之间相互独立，那么整个样本集生成的概率即为所有样本生成概率的乘积，再将公式对数化，便可得到如下公式：
其中，m为样本的总数，y(i)表示第i个样本的类别，x(i)表示第i个样本，需要注意的是W是多维向量，x(i)也是多维向量。
接下来的问题是求解W使得上式最小、
通过一连串的分析，可以看出一个机器学习算法其实只有两部分
模型从输入特征x预测输入y的那个函数h(x)目标函数 目标函数取最小(最大)值时所对应的参数值，就是模型的参数的最优值。很多时候我们只能获得目标函数的局部最小(最大)值，因此也只能得到模型参数的局部最优值。 梯度下降算法 上节介绍的线性回归模型，能够通过闭式方程直接算出最适合训练集的模型参数。这里我们介绍另一种方法：梯度下降，通过迭代优化，逐渐调整模型参数直至到达理想的情况。这里介绍梯度下降和变体随机梯度下降。
我们先看个简单的求极小值的例子。
来吧，做到送分题。这个函数的极值怎么求？它的函数图像为：
求导数，令其为0，解出x即可。
但是实际任务的函数不会像上面这么简单，就算求出了函数的导数，也很难精确计算出函数的极值。此时我们就可以用迭代的方法来做。就像爬坡一样，一点一点逼近极值。这种寻找最佳拟合参数的方法，就是最优化算法。爬坡这个动作用数学公式表达即为：
对我们的函数而言就是：
迭代公式为：
其中n为学习率，学习率越高，迈的步子越大。
当梯度为0或到达一定迭代次数后，算法就会停止。
梯度下降算法有个问题，可能只会到达局部最优，而不是全局最优。
算法到达B点就会停止，不会找到最优解C 。
随机梯度下降 梯度下降算法每次更新权重时都需要遍历整个数据集，这样在数据集很大时使得计算复杂度太高，改进方法是一次仅用一个样本点更新权重系数，这就叫随机梯度下降算法。因此每次采用一个样本，它比梯度下降不稳定，不断的上上下下，但整体看，还是慢慢下降，最终接近最小值。因为它不稳定也带来了一个优点：能跳出局部最优。
在sklearn中，可以使用SGDRegressor来实现回归任务的随机梯度下降。
以上节线性回归为例，使用随机梯度下降：
参数：
loss：损失函数，默认为平方误差，可选项：‘squared_loss’, ‘huber’, ‘epsilon_insensitive’, or ‘squared_epsilon_insensitive’
‘squared_loss’：平方误差
“huber”：修正了“squared_loss”，通过从平方转换到基于epsilon距离的线性损失，减少了对异常值的校正。
epsilon_insensitive：epsilon_insensitive’ 忽略小于 epsilon的误差。使用的是SVR的损失函数。
&#39;squared_epsilon_insensitive：上面的平方损失
penalty:惩罚项，可选项：‘none’, ‘l2’, ‘l1’, or ‘elasticnet’
alpha：常数乘以正则化项。默认值为0.0001，当设置为“最优”时，也用于计算learning_rate。不常用。
l1_ratio：elasticnet弹性网络中l1正则项的程度
fit_intercept：偏置项
max_iter：最大迭代次数
tol：容忍误差
shuffle：训练数据是否应该在每个epochs之后重新洗牌。默认值为True。
verbose：不常用
epsilon：只有当huber’, ‘epsilon_insensitive’, or ‘squared_epsilon_insensitive’时可用，对于“huber”来说，它决定了一个阈值，在这个阈值内，不必准确预测。对于epsilon_insensitive’，如果当前的预测与正确的标记之间的差异小于这个阈值，则忽略它们。
random_state:种子生成器" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/37863d954689b51c9305702a031e27cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-02T11:44:53+08:00" />
<meta property="article:modified_time" content="2019-01-02T11:44:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">机器学习3 逻辑斯提回归和梯度下降算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>引言</h4> 
<p>上节我们介绍了很多线性回归模型，如何用线性模型做分类任务呢？是不是可以将线性回归模型的预测值和到分类任务的标记联系起来呢？</p> 
<h4>逻辑斯提回归</h4> 
<p>对于一个二分类任务，输出标记y为{0,1}，而线性回归模型产生的预测值z为全体实数，我们想把z转换成0/1值。我们首先想到是“单位阶跃函数”。</p> 
<p><img alt="" class="has" height="60" src="https://images2.imgbox.com/3a/e0/Md8tsfcW_o.png" width="156"></p> 
<p> 利用线性回归模型产生预测值z，经过单位阶跃函数做变换，如果z&lt;=0，就归为负类，若z&gt;0就归为正类。但单位阶跃函数性质不好，不连续。我们用对数几率函数（也叫sigmoid函数）进行替代：</p> 
<p><img alt="" class="has" height="64" src="https://images2.imgbox.com/29/fa/GCaqwc6H_o.png" width="94"></p> 
<p>函数图像为：</p> 
<p><img alt="" class="has" height="128" src="https://images2.imgbox.com/8d/cc/LI7H0oA3_o.png" width="826"></p> 
<p>这样就将预测值z映射到（0,1）之前，那么怎么进行分类呢？同样是：如果z&lt;=0，就归为负类，若z&gt;0就归为正类。映射到（0,1）还有一个好处是，可以看成近似的概率。例如y=0.8，就说它归为正类的概率为0.8。</p> 
<p>上一节讲到我们的线性模型为;</p> 
<p><img alt="" class="has" height="40" src="https://images2.imgbox.com/a3/04/2fKGJ8YG_o.png" width="107"></p> 
<p>将偏置项和权重系数合并：</p> 
<p><img alt="" class="has" height="32" src="https://images2.imgbox.com/18/40/gxKRjd4p_o.png" width="80"></p> 
<p>其中：<img alt="" class="has" height="49" src="https://images2.imgbox.com/87/2f/HYEo1oou_o.png" width="154"></p> 
<p>代入到对数几率函数中：</p> 
<p><img alt="" class="has" height="53" src="https://images2.imgbox.com/5a/f9/2ZD7gJqa_o.png" width="133"></p> 
<p>下标sigmoid，表示映射函数为sigmoid函数。这就是逻辑斯提回归模型。</p> 
<p>那么我们如何求解参数W呢？</p> 
<p>由对数函数的性质可知：</p> 
<p><img alt="" class="has" height="93" src="https://images2.imgbox.com/ea/6b/39qfJEHJ_o.png" width="322"></p> 
<p>上式即为在已知样本x和参数θ的情况下，样本x属性正样本(y=1)和负样本(y=0)的条件概率。理想状态下，根据上述公式，求出各个点的概率均为1，也就是完全分类都正确。但是考虑到实际情况，样本点的概率越接近于1，其分类效果越好。比如一个样本属于正样本的概率为0.51，那么我们就可以说明这个样本属于正样本。另一个样本属于正样本的概率为0.99，那么我们也可以说明这个样本属于正样本。但是显然，第二个样本概率更高，更具说服力。我们可以把上述两个概率公式合二为一：</p> 
<p><a href="https://cuijiahua.com/wp-content/uploads/2017/11/ml_6_8.png" rel="nofollow"><img alt="机器学习实战教程（六）：Logistic回归基础篇之梯度上升算法" class="has" height="42" src="https://images2.imgbox.com/24/f1/zpvZSm7w_o.png" width="510"></a></p> 
<p>合并出来的Cost，我们称之为代价函数(Cost Function)。当y等于1时，(1-y)项(第二项)为0；当y等于0时，y项(第一项)为0。为了简化问题，我们对整个表达式求对数，(将指数问题对数化是处理数学问题常见的方法)：</p> 
<p><a href="https://cuijiahua.com/wp-content/uploads/2017/11/ml_6_9.png" rel="nofollow"><img alt="机器学习实战教程（六）：Logistic回归基础篇之梯度上升算法" class="has" height="42" src="https://images2.imgbox.com/dd/f7/ovPPln4q_o.png" width="545"></a></p> 
<p>这个代价函数，是对于一个样本而言的。给定一个样本，我们就可以通过这个代价函数求出，样本所属类别的概率，而这个概率越大越好，所以也就是求解这个代价函数的最大值。既然概率出来了，那么最大似然估计也该出场了。假定样本与样本之间相互独立，那么整个样本集生成的概率即为所有样本生成概率的乘积，再将公式对数化，便可得到如下公式：</p> 
<p><img alt="" class="has" height="53" src="https://images2.imgbox.com/cc/83/HHMgFAK4_o.png" width="413"></p> 
<p>其中，m为样本的总数，y(i)表示第i个样本的类别，x(i)表示第i个样本，需要注意的是W是多维向量，x(i)也是多维向量。</p> 
<p>接下来的问题是求解W使得上式最小、</p> 
<p>通过一连串的分析，可以看出一个机器学习算法其实只有两部分</p> 
<ul><li>模型从输入特征x预测输入y的那个函数h(x)</li><li><em>目标函数</em> 目标函数取最小(最大)值时所对应的参数值，就是模型的参数的<strong>最优值</strong>。很多时候我们只能获得目标函数的<strong>局部最小(最大)值</strong>，因此也只能得到模型参数的<strong>局部最优值</strong>。</li></ul> 
<h4>梯度下降算法</h4> 
<p>上节介绍的线性回归模型，能够通过闭式方程直接算出最适合训练集的模型参数。这里我们介绍另一种方法：梯度下降，通过迭代优化，逐渐调整模型参数直至到达理想的情况。这里介绍梯度下降和变体随机梯度下降。</p> 
<p>我们先看个简单的求极小值的例子。</p> 
<p><img alt="" class="has" height="42" src="https://images2.imgbox.com/6c/90/kXAvMZgb_o.png" width="125"></p> 
<p>来吧，做到送分题。这个函数的极值怎么求？它的函数图像为：</p> 
<p><img alt="" class="has" height="414" src="https://images2.imgbox.com/4b/fb/8jI7kI0f_o.png" width="560"></p> 
<p>求导数，令其为0，解出x即可。</p> 
<p>但是实际任务的函数不会像上面这么简单，就算求出了函数的导数，也很难精确计算出函数的极值。此时我们就可以用迭代的方法来做。就像爬坡一样，一点一点逼近极值。这种寻找最佳拟合参数的方法，就是最优化算法。爬坡这个动作用数学公式表达即为：</p> 
<p><img alt="" class="has" height="50" src="https://images2.imgbox.com/7d/fc/nKd5KMPF_o.png" width="152"></p> 
<p>对我们的函数而言就是：</p> 
<p><img alt="" class="has" height="154" src="https://images2.imgbox.com/b0/3c/ZVFZpRLh_o.png" width="544"></p> 
<p>迭代公式为：</p> 
<p><img alt="" class="has" height="48" src="https://images2.imgbox.com/54/f4/MYj4uw7u_o.png" width="325"></p> 
<p>其中n为学习率，学习率越高，迈的步子越大。</p> 
<p>当梯度为0或到达一定迭代次数后，算法就会停止。</p> 
<p>梯度下降算法有个问题，可能只会到达局部最优，而不是全局最优。</p> 
<p><img alt="" class="has" height="336" src="https://images2.imgbox.com/c6/2a/7eXw2DBw_o.png" width="500"></p> 
<p>算法到达B点就会停止，不会找到最优解C 。</p> 
<h4>随机梯度下降</h4> 
<p>梯度下降算法每次更新权重时都需要遍历整个数据集，这样在数据集很大时使得计算复杂度太高，改进方法是一次仅用一个样本点更新权重系数，这就叫随机梯度下降算法。因此每次采用一个样本，它比梯度下降不稳定，不断的上上下下，但整体看，还是慢慢下降，最终接近最小值。因为它不稳定也带来了一个优点：能跳出局部最优。</p> 
<p>在sklearn中，可以使用SGDRegressor来实现回归任务的随机梯度下降。</p> 
<p>以上节线性回归为例，使用随机梯度下降：</p> 
<p><img alt="" class="has" height="95" src="https://images2.imgbox.com/a0/ea/w1ZDjC3l_o.png" width="777"></p> 
<p>参数：</p> 
<p>loss：损失函数，默认为平方误差，可选项：‘squared_loss’, ‘huber’, ‘epsilon_insensitive’, or ‘squared_epsilon_insensitive’</p> 
<p>‘squared_loss’：平方误差</p> 
<p>“huber”：修正了“squared_loss”，通过从平方转换到基于epsilon距离的线性损失，减少了对异常值的校正。</p> 
<p>epsilon_insensitive：epsilon_insensitive’ 忽略小于 epsilon的误差。使用的是SVR的损失函数。</p> 
<p>'squared_epsilon_insensitive：上面的平方损失</p> 
<p>penalty:惩罚项，可选项：‘none’, ‘l2’, ‘l1’, or ‘elasticnet’</p> 
<p><strong>alpha：</strong>常数乘以正则化项。默认值为0.0001，当设置为“最优”时，也用于计算learning_rate。不常用。</p> 
<p><strong>l1_ratio：</strong>elasticnet弹性网络中l1正则项的程度</p> 
<p><strong>fit_intercept：偏置项</strong></p> 
<p><strong>max_iter：最大迭代次数</strong></p> 
<p><strong>tol：容忍误差</strong></p> 
<p><strong>shuffle：</strong>训练数据是否应该在每个epochs之后重新洗牌。默认值为True。</p> 
<p><strong>verbose：不常用</strong></p> 
<p><strong>epsilon：只有当</strong>huber’, ‘epsilon_insensitive’, or ‘squared_epsilon_insensitive’时可用，对于“huber”来说，它决定了一个阈值，在这个阈值内，不必准确预测。对于epsilon_insensitive’，如果当前的预测与正确的标记之间的差异小于这个阈值，则忽略它们。</p> 
<p><strong>random_state:种子生成器</strong></p> 
<p><strong>learning_rate;学习率，可选</strong>‘constant’，‘optimal’:invscaling’，‘adaptive’</p> 
<p>constant:eta = eta0</p> 
<p>‘optimal’:1.0 / (alpha * (t + t0))其中t0由Leon Bottou提出的启发式算法选择。</p> 
<p>invscaling:eta0 / pow(t, power_t)</p> 
<p>adaptive:自适应改变eta</p> 
<p><strong>eta0:学习率，在</strong>‘constant’，‘’invscaling’，‘adaptive’下可用</p> 
<p><strong>power_t:</strong>逆标度学习速率的指数</p> 
<p><strong>early_stopping:</strong>当验证分数没有提高时，是否使用早期停止终止训练</p> 
<p><strong>validation_fraction：训练集留给验证集的部分，（0,1）直接，且early_stopping设为True</strong></p> 
<p><strong>n_iter_no_change；在early stopping前没有提高性能的迭代次数</strong></p> 
<p><strong>warm_start：是否重新开始</strong></p> 
<p><strong>average：</strong>当设置为True时，计算SGD的平均权重，并将结果存储在coef_属性中</p> 
<p><strong>n_iter：迭代次数，将要移除在0.21</strong></p> 
<p><strong>可算写完了，参数较多，很多也不常用。</strong></p> 
<p><strong>属性：</strong></p> 
<p><img alt="" class="has" height="274" src="https://images2.imgbox.com/65/e3/nP1YlvXS_o.png" width="554"></p> 
<p>用上节的线性数据为例：</p> 
<pre class="has"><code>import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import SGDRegressor
'''
创建数据集
'''
#rand(100,1)产生100*1的矩阵，数为0到1的随机数
X = 2 * np.random.rand(100,1)
#randn(100，1)产生100*1的矩阵，数为正态分布随机数
y = 4 + 3*X + np.random.randn(100,1)

lin_reg = LinearRegression()
lin_reg.fit(X,y)
print('线性回归',lin_reg.coef_,lin_reg.intercept_)

sgd_reg = SGDRegressor(eta0=0.1,max_iter=500)
sgd_reg.fit(X,y)
print('随机梯度回归',sgd_reg.coef_,sgd_reg.intercept_)</code></pre> 
<p>结果：</p> 
<p><img alt="" class="has" height="49" src="https://images2.imgbox.com/45/77/pEW0fuGT_o.png" width="342"></p> 
<h4> 逻辑斯提回归实战</h4> 
<p>前面我们介绍了逻辑斯提回归算法的原理和解法，接下来进行运用。首先还是先介绍超参数：</p> 
<p><img alt="" class="has" height="80" src="https://images2.imgbox.com/30/46/sMMm2cUA_o.png" width="826"></p> 
<p><strong>penalty：惩罚项，可选L1,L1,</strong> ‘newton-cg’, ‘sag’ and ‘lbfgs’ solvers 只支持 l2</p> 
<p>dual:对偶仅适用于用''liblinear''solvers 的L2。当样本数大于特征数默认False</p> 
<p><strong>tol:容忍误差</strong></p> 
<p><strong>C：正则化程度,C越小，正则化程度越大</strong></p> 
<ul><li><strong>fit_intercept：</strong>是否存在截距或偏差，bool类型，默认为True。</li><li><strong>intercept_scaling：</strong>仅在solver为"liblinear"，且fit_intercept设置为True时有用。float类型，默认为1。</li><li><strong>class_weight：</strong>用于标示分类模型中各种类型的权重，可以是一个字典或者'balanced'字符串，默认为不输入，也就是不考虑权重，即为None。如果选择输入的话，可以选择balanced让类库自己计算类型权重，或者自己输入各个类型的权重。举个例子，比如对于0,1的二元模型，我们可以定义class_weight={0:0.9,1:0.1}，这样类型0的权重为90%，而类型1的权重为10%。如果class_weight选择balanced，那么类库会根据训练样本量来计算权重。某种类型样本量越多，则权重越低，样本量越少，则权重越高。当class_weight为balanced时，类权重计算方法如下：n_samples / (n_classes * np.bincount(y))。n_samples为样本数，n_classes为类别数量，np.bincount(y)会输出每个类的样本数，例如y=[1,0,0,1,1],则np.bincount(y)=[2,3]。 
  <ul><li><strong>那么class_weight有什么作用呢？</strong> 
    <ul><li>在分类模型中，我们经常会遇到两类问题：</li><li>1.第一种是误分类的代价很高。比如对合法用户和非法用户进行分类，将非法用户分类为合法用户的代价很高，我们宁愿将合法用户分类为非法用户，这时可以人工再甄别，但是却不愿将非法用户分类为合法用户。这时，我们可以适当提高非法用户的权重。</li><li>2. 第二种是样本是高度失衡的，比如我们有合法用户和非法用户的二元样本数据10000条，里面合法用户有9995条，非法用户只有5条，如果我们不考虑权重，则我们可以将所有的测试集都预测为合法用户，这样预测准确率理论上有99.95%，但是却没有任何意义。这时，我们可以选择balanced，让类库自动提高非法用户样本的权重。提高了某种分类的权重，相比不考虑权重，会有更多的样本分类划分到高权重的类别，从而可以解决上面两类问题。</li></ul></li></ul></li><li><strong>random_state：</strong>随机数种子，仅solver为sag,liblinear时有用。</li><li><strong>solver：</strong>优化算法选择参数，只有五个可选参数，即newton-cg,lbfgs,liblinear,sag,saga。默认为liblinear。solver参数决定了我们对逻辑回归损失函数的优化方法，有四种算法可以选择，分别是： 
  <ul><li><strong>liblinear：</strong>使用了开源的liblinear库实现，内部使用了坐标轴下降法来迭代优化损失函数。</li><li><strong>lbfgs：</strong>拟牛顿法的一种，利用损失函数二阶导数矩阵即海森矩阵来迭代优化损失函数。</li><li><strong>newton-cg：</strong>也是牛顿法家族的一种，利用损失函数二阶导数矩阵即海森矩阵来迭代优化损失函数。</li><li><strong>sag：</strong>随机平均梯度下降。</li><li><strong>saga：</strong>线性收敛的随机优化算法的的变种。</li><li><strong>总结：</strong> 
    <ul><li>liblinear适用于小数据集，而sag和saga适用于大数据集因为速度更快。</li><li>对于多分类问题，只有newton-cg,sag,saga和lbfgs能够处理多项损失，而liblinear受限于一对剩余(OvR)。啥意思，就是用liblinear的时候，如果是多分类问题，得先把一种类别作为一个类别，剩余的所有类别作为另外一个类别。一次类推，遍历所有类别，进行分类。</li><li>newton-cg,sag和lbfgs这三种优化算法时都需要损失函数的一阶或者二阶连续导数，因此不能用于没有连续导数的L1正则化，只能用于L2正则化。而liblinear和saga通吃L1正则化和L2正则化。</li><li>同时，sag每次仅仅使用了部分样本进行梯度迭代，所以当样本量少的时候不要选择它，而如果样本量非常大，比如大于10万，sag是第一选择。但是sag不能用于L1正则化，所以当你有大量的样本，又需要L1正则化的话就要自己做取舍了。要么通过对样本采样来降低样本量，要么回到L2正则化。</li><li>从上面的描述，大家可能觉得，既然newton-cg, lbfgs和sag这么多限制，如果不是大样本，我们选择liblinear不就行了嘛！错，因为liblinear也有自己的弱点！我们知道，逻辑回归有二元逻辑回归和多元逻辑回归。对于多元逻辑回归常见的有one-vs-rest(OvR)和one-vs-one(OvO)两种。什么是OvO，举例，对标记{0,1,2}做分类。OvO的策略为：为每对数字训练一个二元分类器：一个区分0,1，一个区分0,2，一个区分1,2。这样每个分类器只需用到所需要的训练集，更稳定，但训练时间长。</li><li>OvO一般比OvR分类相对准确一些。郁闷的是liblinear只支持OvR，不支持OvO，这样如果我们需要相对精确的多元逻辑回归时，就不能选择liblinear了.</li></ul></li></ul></li><li><strong>max_iter：</strong>算法收敛最大迭代次数，默认为100。仅在正则化优化算法为newton-cg, sag和lbfgs才有用</li><li><strong>multi_class：</strong>分类方式选择参数，str类型，可选参数为ovr和multinomial，默认为ovr。ovr即前面提到的one-vs-rest(OvR)，而multinomial即前面提到的one-vs-one(OvO)。如果是二元逻辑回归，ovr和multinomial并没有任何区别，区别主要在多元逻辑回归上</li><li>OvR相对简单，但分类效果相对略差（这里指大多数样本分布情况，某些样本分布下OvR可能更好）。而OvO分类相对精确，但是分类速度没有OvR快。如果选择了ovr，则4种损失函数的优化方法liblinear，newton-cg,lbfgs和sag都可以选择。但是如果选择了multinomial,则只能选择newton-cg, lbfgs和sag了。</li><li><strong>verbose：</strong>日志冗长度，默认为0。就是不输出训练过程，1的时候偶尔输出结果，大于1，对于每个子模型都输出。</li><li><strong>warm_start：</strong>热启动参数，bool类型。默认为False。如果为True，则下一次训练是以追加树的形式进行（重新使用上一次的调用作为初始化）。</li><li><strong>n_jobs：</strong>并行数。</li></ul> 
<p>先利用逻辑斯提回归进行二元分类，以鸢尾花数据集为例：</p> 
<pre class="has"><code>from sklearn import datasets
'''
创建数据集
'''
iris = datasets.load_iris()
print(list(iris.keys()))
print(iris.target_names,iris.feature_names)</code></pre> 
<p>结果：</p> 
<p><img alt="" class="has" height="102" src="https://images2.imgbox.com/a6/7b/v3Z3rw8W_o.png" width="523"></p> 
<p>可见我们有三种标记：setosa,versicolor,virginica.。每个样本有四个特征['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)']</p> 
<p>我们以setosa和versicolor进行二分类。</p> 
<pre class="has"><code>import numpy as np
import matplotlib.pyplot as plt
from sklearn import datasets
'''
创建数据集
'''
iris = datasets.load_iris()
#采用前两个特征
X = iris['data'][:,:2]
y = iris['target']
setosa = []
versicolor = []
for i in range(len(y)):
    if y[i] == 0:
        setosa.append(X[i])
    elif y[i] == 1:
        versicolor.append(X[i])
setosa = np.array(setosa)
versicolor = np.array(versicolor)
plt.figure()
plt.scatter(setosa[:,0],setosa[:,1],marker='^',label='setosa')
plt.scatter(versicolor[:,0],versicolor[:,1],label='versicolor')
plt.xlabel('sepal length')
plt.ylabel('sepal width')
plt.legend(loc='best')
plt.show()</code></pre> 
<p>结果：</p> 
<p><img alt="" class="has" height="434" src="https://images2.imgbox.com/77/d8/iRuaXoo8_o.png" width="586"></p> 
<p> </p> 
<pre class="has"><code>
'''
二分类
创建数据集
'''
iris = datasets.load_iris()
#采用前两个特征
x = iris['data'][:,:2]
y = iris['target']
X = []
Y = []
for i in range(len(y)):
    if y[i] == 0 or y[i] == 1:
        Y.append(y[i])
        X.append(x[i])  
#训练
log_reg = LogisticRegression(solver='liblinear')
log_reg.fit(np.array(X),np.array(Y))
print(log_reg.predict([[4.5,3]]))</code></pre> 
<p>结果：</p> 
<p><img alt="" class="has" height="28" src="https://images2.imgbox.com/fc/c4/bVqEaIOF_o.png" width="58"></p> 
<p>sepal length=4.5，sepal width=3预测为setosa。</p> 
<p>利用逻辑斯提回归进行多元分类：</p> 
<pre class="has"><code>'''
创建数据集
'''
iris = datasets.load_iris()

x = iris['data']
y = iris['target']

#训练
log_reg = LogisticRegression(solver='lbfgs',multi_class='multinomial')
log_reg.fit(x,y)
print(log_reg.predict([[4.5,3,4,3]]))</code></pre> 
<p>结果：</p> 
<p><img alt="" class="has" height="26" src="https://images2.imgbox.com/fc/e8/7Bs1Pb4k_o.png" width="50"></p> 
<h4>小结</h4> 
<p>本节介绍了逻辑斯提回归及其解法梯度下降算法，还引申到多分类问题。下节我们介绍在非线性数据集上如何训练。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dbaa83c96033fa5817f47fe017dfbc34/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">饭卡问题题解（对01背包更深入的应用）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ef2a925ebc8fdeddf81a57f5e1d47b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在spring web项目中获取WEB-INF/classes目录与WEB-INF/目录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>