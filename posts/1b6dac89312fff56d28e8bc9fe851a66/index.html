<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot &#43; shiro 配置 ehcache 缓存 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot &#43; shiro 配置 ehcache 缓存" />
<meta property="og:description" content="背景： shiro 是支持缓存功能的，它可以对用户的授权数据和认证数据进行缓存，使得用户不必每次认证或授权时都去查询数据库，今天讲下如何将 ehcache 缓存整合到 shiro 中，后续再讲下如何将 redis 整合到 shiro 中。
添加依赖： &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.6.0&lt;/version&gt; &lt;/dependency&gt; 配置ShiroConfig： 首先在 ShiroConfig 中添加 shiro 的缓存管理器 EhCacheManager ，并将缓存管理器添加到 SecurityManager 中，最后在 CustomRealm 中配置开启缓存，如下所示：
/** * shiro缓存管理器; * 需要添加到securityManager中 * @return */ @Bean public EhCacheManager ehCacheManager(){ EhCacheManager cacheManager = new EhCacheManager(); cacheManager.setCacheManagerConfigFile(&#34;classpath:ehcache-shiro.xml&#34;); return cacheManager; } @Bean public SecurityManager securityManager() { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(myShiroRealm()); // 将 CookieRememberMeManager 注入到 SecurityManager 中，否则不会生效 securityManager.setRememberMeManager(rememberMeManager()); // 将 sessionManager 注入到 SecurityManager 中，否则不会生效 securityManager." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1b6dac89312fff56d28e8bc9fe851a66/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-10T09:32:36+08:00" />
<meta property="article:modified_time" content="2023-10-10T09:32:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot &#43; shiro 配置 ehcache 缓存</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>背景：</h4> 
<p>       <strong>shiro </strong>是支持缓存功能的，它可以对用户的<strong>授权数据</strong>和<strong>认证数据</strong>进行缓存，使得用户不必每次认证或授权时都去查询数据库，今天讲下如何将 <strong>ehcache </strong>缓存整合到 <strong>shiro </strong>中，后续再讲下如何将 <strong>redis</strong> 整合到 <strong>shiro </strong>中。</p> 
<h4>添加依赖：</h4> 
<pre><code class="language-bash">    &lt;dependency&gt;
		&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
		&lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;
		&lt;version&gt;1.6.0&lt;/version&gt;
	&lt;/dependency&gt;</code></pre> 
<h4>配置ShiroConfig：</h4> 
<p>       首先在 <strong>ShiroConfig </strong>中添加 <strong>shiro </strong>的缓存管理器 <strong>EhCacheManager </strong>，并将缓存管理器添加到 <strong>SecurityManager </strong>中，最后在 <strong>CustomRealm</strong> 中配置开启缓存，如下所示：</p> 
<pre><code class="language-java">    /**
	 * shiro缓存管理器;
	 * 需要添加到securityManager中
	 * @return
	 */
	@Bean
	public EhCacheManager ehCacheManager(){
	    EhCacheManager cacheManager = new EhCacheManager();
	    cacheManager.setCacheManagerConfigFile("classpath:ehcache-shiro.xml");
	    return cacheManager;
	}
    @Bean
	public SecurityManager securityManager() {
		DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
		securityManager.setRealm(myShiroRealm());
		// 将 CookieRememberMeManager 注入到 SecurityManager 中，否则不会生效
		securityManager.setRememberMeManager(rememberMeManager());
		// 将 sessionManager 注入到 SecurityManager 中，否则不会生效
		securityManager.setSessionManager(sessionManager());
		// 将 EhCacheManager 注入到 SecurityManager 中，否则不会生效
		securityManager.setCacheManager(ehCacheManager());
		return securityManager;
	}
    @Bean
	public CustomRealm myShiroRealm() {
		CustomRealm customRealm = new CustomRealm();
		// 告诉realm,使用credentialsMatcher加密算法类来验证密文
		customRealm.setCredentialsMatcher(hashedCredentialsMatcher());
		/* 开启支持缓存，需要配置如下几个参数 */
		customRealm.setCachingEnabled(true);
	    // 启用身份验证缓存，即缓存AuthenticationInfo信息，默认false
		customRealm.setAuthenticationCachingEnabled(true);
	    // 缓存AuthenticationInfo信息的缓存名称 在 ehcache-shiro.xml 中有对应缓存的配置
		customRealm.setAuthenticationCacheName("authenticationCache");
	    // 启用授权缓存，即缓存AuthorizationInfo信息，默认false
		customRealm.setAuthorizationCachingEnabled(true);
	    // 缓存AuthorizationInfo 信息的缓存名称  在 ehcache-shiro.xml 中有对应缓存的配置
		customRealm.setAuthorizationCacheName("authorizationCache");
		return customRealm;
	}</code></pre> 
<h4>添加配置文件：</h4> 
<p>       需要在 <strong>resources </strong>文件夹下添加 <strong>ehcache-shiro.xml </strong>的配置文件，内容如下所示：</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ehcache name="es"&gt;

    &lt;!--
        缓存对象存放路径
        java.io.tmpdir：默认的临时文件存放路径。
        user.home：用户的主目录。
        user.dir：用户的当前工作目录，即当前程序所对应的工作路径。
        其它通过命令行指定的系统属性，如“java –DdiskStore.path=D:\\abc ……”。
    --&gt;
    &lt;diskStore path="java.io.tmpdir"/&gt;

    &lt;!--

       name:缓存名称。
       maxElementsOnDisk：硬盘最大缓存个数。0表示不限制
       maxEntriesLocalHeap：指定允许在内存中存放元素的最大数量，0表示不限制。
       maxBytesLocalDisk：指定当前缓存能够使用的硬盘的最大字节数，其值可以是数字加单位，单位可以是K、M或者G，不区分大小写，
                          如：30G。当在CacheManager级别指定了该属性后，Cache级别也可以用百分比来表示，
                          如：60%，表示最多使用CacheManager级别指定硬盘容量的60%。该属性也可以在运行期指定。当指定了该属性后会隐式的使当前Cache的overflowToDisk为true。
       maxEntriesInCache：指定缓存中允许存放元素的最大数量。这个属性也可以在运行期动态修改。但是这个属性只对Terracotta分布式缓存有用。
       maxBytesLocalHeap：指定当前缓存能够使用的堆内存的最大字节数，其值的设置规则跟maxBytesLocalDisk是一样的。
       maxBytesLocalOffHeap：指定当前Cache允许使用的非堆内存的最大字节数。当指定了该属性后，会使当前Cache的overflowToOffHeap的值变为true，
                             如果我们需要关闭overflowToOffHeap，那么我们需要显示的指定overflowToOffHeap的值为false。
       overflowToDisk:boolean类型，默认为false。当内存里面的缓存已经达到预设的上限时是否允许将按驱除策略驱除的元素保存在硬盘上，默认是LRU（最近最少使用）。
                      当指定为false的时候表示缓存信息不会保存到磁盘上，只会保存在内存中。
                      该属性现在已经废弃，推荐使用cache元素的子元素persistence来代替，如：&lt;persistence strategy=”localTempSwap”/&gt;。
       diskSpoolBufferSizeMB：当往磁盘上写入缓存信息时缓冲区的大小，单位是MB，默认是30。
       overflowToOffHeap：boolean类型，默认为false。表示是否允许Cache使用非堆内存进行存储，非堆内存是不受Java GC影响的。该属性只对企业版Ehcache有用。
       copyOnRead：当指定该属性为true时，我们在从Cache中读数据时取到的是Cache中对应元素的一个copy副本，而不是对应的一个引用。默认为false。
       copyOnWrite：当指定该属性为true时，我们在往Cache中写入数据时用的是原对象的一个copy副本，而不是对应的一个引用。默认为false。
       timeToIdleSeconds：单位是秒，表示一个元素所允许闲置的最大时间，也就是说一个元素在不被请求的情况下允许在缓存中待的最大时间。默认是0，表示不限制。
       timeToLiveSeconds：单位是秒，表示无论一个元素闲置与否，其允许在Cache中存在的最大时间。默认是0，表示不限制。
       eternal：boolean类型，表示是否永恒，默认为false。如果设为true，将忽略timeToIdleSeconds和timeToLiveSeconds，Cache内的元素永远都不会过期，也就不会因为元素的过期而被清除了。
       diskExpiryThreadIntervalSeconds ：单位是秒，表示多久检查元素是否过期的线程多久运行一次，默认是120秒。
       clearOnFlush：boolean类型。表示在调用Cache的flush方法时是否要清空MemoryStore。默认为true。
       diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.
       maxElementsInMemory:缓存最大数目
       memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
            memoryStoreEvictionPolicy:
               Ehcache的三种清空策略;
               FIFO，first in first out，这个是大家最熟的，先进先出。
               LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
               LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
    --&gt;
    &lt;defaultCache
            maxElementsInMemory="10000"
            eternal="false"
            timeToIdleSeconds="0"
            timeToLiveSeconds="0"
            overflowToDisk="false"
            diskPersistent="false"
            diskExpiryThreadIntervalSeconds="120"
    /&gt;

    &lt;!-- 授权缓存 --&gt;
    &lt;cache name="authorizationCache"
           maxEntriesLocalHeap="2000"
           eternal="false"
           timeToIdleSeconds="0"
           timeToLiveSeconds="0"
           overflowToDisk="false"
           statistics="true"&gt;
    &lt;/cache&gt;

    &lt;!-- 认证缓存 --&gt;
    &lt;cache name="authenticationCache"
           maxEntriesLocalHeap="2000"
           eternal="false"
           timeToIdleSeconds="0"
           timeToLiveSeconds="0"
           overflowToDisk="false"
           statistics="true"&gt;
    &lt;/cache&gt;

&lt;/ehcache&gt;</code></pre> 
<h4>配置日志输出验证：      </h4> 
<p>       在 <strong>CustomRealm </strong>类的 <strong>doGetAuthorizationInfo() </strong>方法中添加打印，或者直接看控制台 <strong>sql </strong>打印也行，如下所示：</p> 
<pre><code class="language-java">protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
		System.out.println("开始查询数据库");
		// 获取登录用户名
		String name = (String)principalCollection.getPrimaryPrincipal();
		// 查询用户名称
		User user = userService.selectByUserName(name);
		// 添加角色和权限
		SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();
		List&lt;String&gt; roleNameList = new ArrayList&lt;&gt;();
		List&lt;String&gt; permissionNameList = new ArrayList&lt;&gt;();

		for (Role role : user.getRoles()) {
			roleNameList.add(role.getRoleName());
			for (Permission permission : role.getPermissions()) {
				permissionNameList.add(role.getRoleName()+":"+permission.getPermissionName());
			}
		}
		// 添加角色
		simpleAuthorizationInfo.addRoles(roleNameList);
		// 添加权限
		simpleAuthorizationInfo.addStringPermissions(permissionNameList);
		System.out.println("查询数据库结束");
		return simpleAuthorizationInfo;
	}</code></pre> 
<p>       启动项目，使用 <strong>zhangsan </strong>账号登录，第一次访问，查看控制台，有日志输出，如下所示，下面只截取了一部分的日志输出，再次访问将不再打印输出，证明缓存生效了。上面的缓存配置时间配置为永久，请根据需求自己更改值来进行测试。 在 <strong>CustomRealm </strong>中对<strong>用户信息</strong>、<strong>角色信息</strong>和<strong>权限信息</strong>的查询，如果需要添加缓存请自行处理。</p> 
<p style="text-align:center;"><img alt="" height="307" src="https://images2.imgbox.com/90/fc/wRWi7WQ4_o.png" width="922"></p> 
<h4>更改权限：</h4> 
<p>       当用户的权限发生改变时我们该如何处理？上面的代码中已经启用了<strong>缓存</strong>，第一次请求走数据库查询，后续请求将直接查询 <strong>ehcache </strong>缓存，假如这个时候在权限控制台分配了某个权限给某个角色，那么拥有这个角色的所有用户在下次请求之前都需要从数据库查询最新的权限信息。所以我们需要清理缓存。</p> 
<p>       首先在 <strong>CustomRealm</strong> 中添加下面的方法用于清理缓存，如下所示：</p> 
<pre><code class="language-java">/**
	 * 重写方法,清除当前用户的的 授权缓存
	 * @param principals
	 */
	@Override
	public void clearCachedAuthorizationInfo(PrincipalCollection principal) {
		 super.clearCachedAuthorizationInfo(principal);
	}
	/**
	 * 重写方法，清除当前用户的 认证缓存
	 * @param principals
	 */
	@Override
	public void clearCachedAuthenticationInfo(PrincipalCollection principal) {
		super.clearCachedAuthenticationInfo(principal);
	}

	/**
	 *  重写方法，清除当前用户的 认证缓存和授权缓存
	 * */
	@Override
	public void clearCache(PrincipalCollection principals) {
		super.clearCache(principals);
	}

	/**
	 * 自定义方法：清除所有用户的 授权缓存
	 */
	public void clearAllCachedAuthorizationInfo() {
		getAuthorizationCache().clear();
	}

	/**
	 * 自定义方法：清除所有用户的 认证缓存
	 */
	public void clearAllCachedAuthenticationInfo() {
		getAuthenticationCache().clear();
	}

	/**
	 * 自定义方法：清除所有用户的  认证缓存  和 授权缓存
	 */
	public void clearAllCache() {
		clearAllCachedAuthenticationInfo();
		clearAllCachedAuthorizationInfo();
	}</code></pre> 
<p>        然后在 <strong>ShiroConfig </strong>中添加 <strong>MethodInvokingFactoryBean</strong> ，代码如下所示：</p> 
<pre><code class="language-java">    /**
	 * 让某个实例的某个方法的返回值注入为Bean的实例
	 * Spring静态注入
	 * @return
	 */
	@Bean
	public MethodInvokingFactoryBean getMethodInvokingFactoryBean(){
	    MethodInvokingFactoryBean factoryBean = new MethodInvokingFactoryBean();
	    factoryBean.setStaticMethod("org.apache.shiro.SecurityUtils.setSecurityManager");
	    factoryBean.setArguments(new Object[]{securityManager()});
	    return factoryBean;
	}</code></pre> 
<h4>测试：</h4> 
<p>       在 <strong>LoginController </strong>中添加如下方法用于清除缓存，在添加或者删除权限的时候，都需要清除缓存。</p> 
<pre><code class="language-java">/**
     * 给admin用户添加 userInfo:del 权限
     * @param model
     * @return
     */
    @RequestMapping(value = "/addRoleIds",method = RequestMethod.GET)
    @ResponseBody
    public String addPermission(String userName) {
        //在sys_role_permission 表中  将 删除的权限 关联到admin用户所在的角色
    	User user = new User();
    	user.setUserName(userName);
    	user.setRoleIds("1,2");
    	userService.updateRoleIds(user);

        //添加成功之后 清除缓存
        DefaultWebSecurityManager securityManager = (DefaultWebSecurityManager)SecurityUtils.getSecurityManager();
        CustomRealm shiroRealm = (CustomRealm) securityManager.getRealms().iterator().next();
        // 清除所有用户权限相关的缓存
        // shiroRealm.clearAllCache();
        // 清除当前登录用户的缓存
        shiroRealm.clearCachedAuthorizationInfo(SecurityUtils.getSubject().getPrincipals());
        return "给admin用户添加 userInfo:del 权限成功";
    }
    /**
     * 删除admin用户 userInfo:del 权限
     * @param model
     * @return
     */
    @RequestMapping(value = "/delRoleIds",method = RequestMethod.GET)
    @ResponseBody
    public String delPermission(String userName) {
        //在sys_role_permission 表中  将 删除的权限 关联到admin用户所在的角色
    	User user = new User();
    	user.setUserName(userName);
    	user.setRoleIds("1");
    	userService.updateRoleIds(user);
    	
        //添加成功之后 清除缓存
        DefaultWebSecurityManager securityManager = (DefaultWebSecurityManager)SecurityUtils.getSecurityManager();
        CustomRealm shiroRealm = (CustomRealm) securityManager.getRealms().iterator().next();
        // 清除所有用户权限相关的缓存
        // shiroRealm.clearAllCache();
        // 清除当前登录用户的缓存
        shiroRealm.clearCachedAuthorizationInfo(SecurityUtils.getSubject().getPrincipals());
        return "删除admin用户userInfo:del 权限成功";

    }</code></pre> 
<p>       1、用两个浏览器分别用不同的用户登录到系统中，然后刷新界面，我们发现，无论怎么刷新，都不用有日志输出，因为此时查询的时缓存。</p> 
<p>       2、点击界面的新增按钮，触发后台的 <strong>addRoleIds </strong>方法，然后再刷新界面，我们发现此时后台有日志输出，即查询的数据是数据库里面的数据。</p> 
<p>       3、点击界面的删除按钮，触发后台的 <strong>delRoleIds </strong>方法，然后再刷新界面，我们发现此时后台有日志输出，即查询的数据是数据库里面的数据。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ac978ddb6ccd769aabb9e845a0bf81a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LONGLORA: EFFICIENT FINE-TUNING OF LONGCONTEXT LARGE LANGUAGE MODELS</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e5ff9f728cc33bb08f69990e3313254c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenCV中initUndistortRectifyMap ()函数与十四讲中去畸变公式的区别探究</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>