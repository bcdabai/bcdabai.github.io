<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java并发之MarkWord、Monitor重量级锁，轻量级锁，偏向锁 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java并发之MarkWord、Monitor重量级锁，轻量级锁，偏向锁" />
<meta property="og:description" content="java并发之重量级锁，轻量级锁，偏向锁 一、Java对象头Mark Word结构： 二、Monitor三、重量级锁自适应自旋锁 四、轻量级锁锁膨胀 五、偏向锁 一、Java对象头 由于Java面向对象的思想，在JVM中需要大量存储对象，存储时为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能，这些标记字段组成了对象头
对象头包含两部分：运行时元数据（Mark Word）和类型指针（Klass Word）
Mark Word结构： 32位
64位
二、Monitor Monitor 被翻译为监视器或管程
每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针
内存结构
三、重量级锁 图解：
如下图所示，我们有一个临界区代码，当Thread2执行到synchronized(obj)，访问共享资源的时候：
首先会将synchronized中的锁对象中对象头的MarkWord去尝试指向操作系统提供的Monitor对象，让锁对象中的MarkWord和Monitor对象相关联.
如果关联成功, 将obj对象头中的MarkWord的对象状态从01改为10。因为该Monitor没有和其他的obj的MarkWord相关联，所以Thread2就成为了该Monitor的Owner(所有者)。
然后，又来了一个Thread1执行synchronized(obj)代码，它首先会检查是否能执行临界区代码，即检查obj是否关联了Montior，此时已经有关联了,它就会去看看该Montior有没有所有者(Owner), 发现有所有者了(Thread2)；Thread1也会和该Monitor关联,
该线程就会进入到它的EntryList(阻塞队列)，EntryList是一个列表，若此时Thread3也执行到synchronized(obj)代码，也会进入阻塞队列。
-当Thread2执行完临界区代码后, Monitor的Owner(所有者)就空出来了.
此时就会通知Monitor中的EntryList阻塞队列中的线程, 这些线程通过竞争, 成为新的所有者。 刚开始 Monitor 中 Owner 为 null
当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKEDThread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/55137a3c6052685ab43b5a6716616409/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-10T15:55:01+08:00" />
<meta property="article:modified_time" content="2023-04-10T15:55:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java并发之MarkWord、Monitor重量级锁，轻量级锁，偏向锁</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>java并发之重量级锁，轻量级锁，偏向锁</h4> 
 <ul><li><a href="#Java_2" rel="nofollow">一、Java对象头</a></li><li><ul><li><a href="#Mark_Word_6" rel="nofollow">Mark Word结构：</a></li></ul> 
  </li><li><a href="#Monitor_11" rel="nofollow">二、Monitor</a></li><li><a href="#_16" rel="nofollow">三、重量级锁</a></li><li><ul><li><a href="#_40" rel="nofollow">自适应自旋锁</a></li></ul> 
  </li><li><a href="#_46" rel="nofollow">四、轻量级锁</a></li><li><ul><li><a href="#_61" rel="nofollow">锁膨胀</a></li></ul> 
  </li><li><a href="#_71" rel="nofollow">五、偏向锁</a></li></ul> 
</div> 
<p></p> 
<h2><a id="Java_2"></a>一、Java对象头</h2> 
<p>由于Java面向对象的思想，在JVM中需要大量存储对象，存储时为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能，这些标记字段组成了对象头<br> 对象头包含两部分：运行时元数据（Mark Word）和类型指针（Klass Word）</p> 
<h3><a id="Mark_Word_6"></a>Mark Word结构：</h3> 
<p>32位<br> <img src="https://images2.imgbox.com/d5/f0/QMzno80l_o.png" alt="在这里插入图片描述"><br> 64位<br> <img src="https://images2.imgbox.com/0f/8c/GBvwbfH0_o.png" alt=""></p> 
<h2><a id="Monitor_11"></a>二、Monitor</h2> 
<p>  Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>   每个 Java 对象都可以关联一个 <strong>Monitor</strong> 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针<br> <strong>内存结构</strong><br> <img src="https://images2.imgbox.com/73/0d/sxiredTr_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_16"></a>三、重量级锁</h2> 
<p>图解：<br> 如下图所示，我们有一个临界区代码，当Thread2执行到synchronized(obj)，访问共享资源的时候：</p> 
<ul><li>首先会将synchronized中的锁对象中对象头的MarkWord去尝试指向操作系统提供的Monitor对象，让锁对象中的MarkWord和Monitor对象相关联.<br> 如果关联成功, 将obj对象头中的MarkWord的对象状态从01改为10。</li><li>因为该Monitor没有和其他的obj的MarkWord相关联，所以Thread2就成为了该Monitor的Owner(所有者)。<br> 然后，又来了一个Thread1执行synchronized(obj)代码，它首先会检查是否能执行临界区代码，即检查obj是否关联了Montior，此时已经有关联了,</li><li>它就会去看看该Montior有没有所有者(Owner), 发现有所有者了(Thread2)；Thread1也会和该Monitor关联,<br> 该线程就会进入到它的EntryList(阻塞队列)，EntryList是一个列表，若此时Thread3也执行到synchronized(obj)代码，也会进入阻塞队列。<br> -当Thread2执行完临界区代码后, Monitor的Owner(所有者)就空出来了.<br> 此时就会通知Monitor中的EntryList阻塞队列中的线程, 这些线程通过竞争, 成为新的所有者。</li></ul> 
<p><img src="https://images2.imgbox.com/c3/da/ddQiu9IG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8e/54/xv3wthK2_o.png" alt="在这里插入图片描述"><br> 刚开始 Monitor 中 Owner 为 null</p> 
<ul><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner</li><li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKED</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程<br> <strong>注意：</strong><br>   synchronized必须是进入同一对象的monitor才有上述效果<br>   不加 synchronized 的对象不会关联监视器，不遵从以上规则<br> <img src="https://images2.imgbox.com/11/17/kgXczRTY_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="_40"></a>自适应自旋锁</h3> 
<p>  jdk1.6之后，引入了自适应自旋锁，在重量级锁当中，也进行了一些优化。<br>   没持有锁的线程会进入Monitor的EntryList当中进行阻塞，实际情况是，会通过自适应自旋锁进行一定次数的自旋，如果获取到锁了，就避免进入阻塞状态（会进行上下文切换）。如果没获取到锁，此时在进入阻塞状态。<br>   自旋是占用CPU的，只有在多核CPU中才能发挥优势。<br>   自适应自旋锁会动态调整自旋次数，获取锁成功的次数多，就会多自旋几次；如果一次都没有成功，则会可能会直接进行阻塞。<br>   java7后不能控制是否开启自旋锁。</p> 
<h2><a id="_46"></a>四、轻量级锁</h2> 
<ul><li>当线程尝试获取这把锁的时候，会创建锁记录（Lock Record），每个线程的栈帧（线程执行到的方法，都会生成对应的栈帧），都会包含一个锁记录的结构，可以用来存储对象的Mark Word，如下所示：<br> <img src="https://images2.imgbox.com/83/2a/rRuXLZ9I_o.png" alt="在这里插入图片描述"></li><li>让锁记录中 Object Reference 指向锁对象，并尝试用 CAS（这里可以理解成一个原子操作） 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录（如图上的1），并将锁记录的地址存入Object的Mark Word如下所示：<br> <img src="https://images2.imgbox.com/85/83/PVylINJS_o.png" alt="在这里插入图片描述"></li><li>如果CAS成功，对象的Mark Word将会存储Lock Record 地址 和 锁状态 00，如下图所示：<br> <img src="https://images2.imgbox.com/da/1a/zJ0CB0w8_o.png" alt="在这里插入图片描述"></li><li>如果CAS失败，此时会有两种情况：<br>   如果是其他线程已经持有了该轻量级锁，则表示发生竞争，此时进入锁膨胀。<br>   如果是自己执行了 synchronized 锁重入（同一个线程给相同对象加了相同的锁），那么再添加一条 Lock Record 作为重入的计数，只不过新添加的Lock Record中没有Object的Mark word内容，为null。如下所示：<br> <img src="https://images2.imgbox.com/12/de/NRmjkxKJ_o.png" alt="在这里插入图片描述"></li><li>  当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一，将null的Lock Record删除。<br>   当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 CAS 将 Mark Word 的值恢复给对象头。<br>   成功，则解锁成功。<br>   失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程。</li></ul> 
<h3><a id="_61"></a>锁膨胀</h3> 
<p>  假设当前Object对象，已经被Thread1所持有，当Thread2前来竞争这把锁，满足上述条件后，会发生锁膨胀，如下图所示：<br> <img src="https://images2.imgbox.com/e8/bd/Q8m2tMev_o.png" alt="在这里插入图片描述"><br>   如上所示，此时Thread2来获取轻量级锁肯定失败的，所以会进入锁膨胀的流程：<br>   1）为Object对象申请Monitor锁，Object的Mark Word指向Monitor地址；Monitor的Owner指向Thread1的锁记录。<br>   2）Thread2进入Monitor的EntryList当中，状态变成BLOCKED。<br> <img src="https://images2.imgbox.com/6d/2d/5XcZZNuA_o.png" alt="在这里插入图片描述"><br>   当Thread1执行完代码块的内容后，开始释放锁，使用CAS去重置Object的Mark Word，此时会失败。因为当前对象头存储的是Monitor的地址。<br>   所示此时会进入重量级锁的解锁过程。将Monitor的Owner设置为null，同时唤醒EntryList中的Thread-2。</p> 
<h2><a id="_71"></a>五、偏向锁</h2> 
<p><strong>原理</strong></p> 
<ul><li>首先获取锁 对象的 Markword，判断是否处于可偏向状态。（biased_lock=1、且 ThreadId 为空）</li><li>如果是可偏向状态，则通过 CAS 操作，把当前线程的 ID 写入到 MarkWord<br>   a) 如果 cas 成功，那么 markword 就会变成这样。 表示已经获得了锁对象的偏向锁，接着执行同步代码块<br>   b) 如果 cas 失败，说明有其他线程已经获得了偏向锁，这种情况说明当前锁存在竞争，需要撤销已获得偏向锁的线程，并且把它持有的锁升级为轻量级锁（这个操作需要等到全局安全点，也就是没有线程在执行字节码）才能执行</li><li>如果是已偏向状态，需要检查 markword 中存储的ThreadID 是否等于当前线程的 ThreadID<br>   a) 如果相等，不需要再次获得锁，可直接执行同步代码块<br>   b) 如果不相等，说明当前锁偏向于其他线程，需要撤销偏向锁并升级到轻量级锁</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/588eb38d8af6110c1b65feb4882da065/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GreenDao进阶篇 GreenDao分页查询</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d22ed658799b494ef58f155d994f2b81/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">软考初级-信息处理技术员笔记-基础知识&#43;操作系统 篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>