<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构与算法--线索化二叉树 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构与算法--线索化二叉树" />
<meta property="og:description" content="数据结构与算法--线索化二叉树 前言1. 线索化二叉树初探2. 线索化二叉树实现 前言 前一篇简单的对二叉树进行初探，简单的了解了一下二叉树的一些概念，和二叉树的 顺序存储 和 链式存储 以及二叉树的一些简单操作，和二叉树的几种遍历方式。这一篇，我们在对二叉树进行了解，假如这个二叉树有很多的叶子节点，那么叶子节点的左孩子和右孩子的指针空间是否会浪费呢？
1. 线索化二叉树初探 如开篇提到的，假如，一个二叉树有很多的叶子节点，如下图
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-o6VpMNw2-1588153397713)(https://user-gold-cdn.xitu.io/2020/4/29/171c512d6d915000?w=1038&amp;h=375&amp;f=png&amp;s=43818)]
那么，上图中，标记 &#39;^&#39;的左孩子指针域和右孩子指针域中则为NULL，那么对于这些空间来说就是空间浪费。
那么，当节点的左孩子的指针域为空的时候，可以将这个指向遍历（以中序遍历为例）时的前一个节点，称之为前驱；
当节点的右孩子的指针域为空的时候，可以将这个指向遍历（以中序遍历为例）时的后一个节点，称之为后继，如下图（以中序遍历为例）：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5RqP6vVK-1588153397731)(https://user-gold-cdn.xitu.io/2020/4/29/171c51c37ef17ef4?w=1059&amp;h=349&amp;f=png&amp;s=54901)]
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-L7NJMRfO-1588153397741)(https://user-gold-cdn.xitu.io/2020/4/29/171c52b460797d51?w=1069&amp;h=350&amp;f=png&amp;s=63529)]
我们称这种二叉树为线索化二叉树，
优点：
节省空间，遍历的时候查找方便 那么怎么区分节点的左孩子指针指向的是左子树还是前驱呢？
那么我们可以对二叉树节点的结构进行优化，增加两个标识，来指示具体指向的是左右子树还是前驱后继，如下示意图：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Rvo1eRxL-1588153397751)(https://user-gold-cdn.xitu.io/2020/4/29/171c52b7f414fb7f?w=840&amp;h=88&amp;f=png&amp;s=8092)]
// Link==0表示指向左右孩子指针 // Thread==1表示指向前驱或后继的线索 typedef enum {Link, Thread} PointerTag; // 线索二叉树节点 typedef struct BiThrNode{ //数据 CElemType data; //左右孩子指针 struct BiThrNode *lchild,*rchild; //左右标记 PointerTag LTag; PointerTag RTag; }BiThrNode,*BiThrTree; 2. 线索化二叉树实现 下面以中序遍历为例，线索二叉树的线索化和遍历
线索二叉树的线索化
首先，声明定义一些变量，并定义一个方法，
#define OK 1 #define ERROR 0 #define TRUE 1 #define FALSW 0 #define MAXSIZE 100 // 存储空间初始分配量 typedef int Status; // 函数类型 typedef char CElemType; CElemType Nill = &#39;#&#39;; // 字符型以空格标识空 #pragma mark -二叉树的构造 int indexs = 1; typedef char String[24]; /* 0号单元存放串的长度 */ String str; // 字符传构造字符数组 Status StrAssign(String T, char *chars) { int i; if (strlen(chars) &gt; MAXSIZE) { return ERROR; }else { T[0] = strlen(chars); for (i = 1; i &lt;= T[0]; i&#43;&#43;) { T[i] = *(chars&#43;i-1); } return OK; } } // 打印值 Status visit(CElemType e) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/47131dc61ce2eb3cbbe9ecea0b670caf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-29T17:43:47+08:00" />
<meta property="article:modified_time" content="2020-04-29T17:43:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构与算法--线索化二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>数据结构与算法--线索化二叉树</h4> 
 <ul><li><ul><li><ul><li><a href="#_2" rel="nofollow">前言</a></li><li><a href="#1__7" rel="nofollow">1. 线索化二叉树初探</a></li><li><a href="#2__54" rel="nofollow">2. 线索化二叉树实现</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="_2"></a>前言</h4> 
<p>  前一篇简单的对二叉树进行初探，简单的了解了一下二叉树的一些概念，和二叉树的 <strong>顺序存储</strong> 和 <strong>链式存储</strong> 以及二叉树的一些简单操作，和二叉树的几种遍历方式。这一篇，我们在对二叉树进行了解，假如这个<code>二叉树</code>有很多的<code>叶子节点</code>，那么<code>叶子节点</code>的<code>左孩子</code>和<code>右孩子</code>的指针空间是否会浪费呢？</p> 
<h4><a id="1__7"></a>1. 线索化二叉树初探</h4> 
<p>如开篇提到的，假如，一个二叉树有很多的叶子节点，如下图<br> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-o6VpMNw2-1588153397713)(https://user-gold-cdn.xitu.io/2020/4/29/171c512d6d915000?w=1038&amp;h=375&amp;f=png&amp;s=43818)]<br> 那么，上图中，标记 '^'的<code>左孩子</code>指针域和<code>右孩子</code>指针域中则为<code>NULL</code>，那么对于这些空间来说就是<code>空间浪费</code>。</p> 
<blockquote> 
 <p>那么，当<code>节点</code>的<code>左孩子</code>的指针域为空的时候，可以将这个指向遍历（以中序遍历为例）时的前一个节点，称之为<code>前驱</code>；</p> 
 <p>当<code>节点</code>的<code>右孩子</code>的指针域为空的时候，可以将这个指向遍历（以中序遍历为例）时的后一个节点，称之为<code>后继</code>，如下图（以中序遍历为例）：</p> 
</blockquote> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5RqP6vVK-1588153397731)(https://user-gold-cdn.xitu.io/2020/4/29/171c51c37ef17ef4?w=1059&amp;h=349&amp;f=png&amp;s=54901)]</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-L7NJMRfO-1588153397741)(https://user-gold-cdn.xitu.io/2020/4/29/171c52b460797d51?w=1069&amp;h=350&amp;f=png&amp;s=63529)]<br> 我们称这种<code>二叉树</code>为<code>线索化二叉树</code>，</p> 
<p>优点：</p> 
<ul><li><strong>节省空间</strong>，</li><li><strong>遍历的时候查找方便</strong></li></ul> 
<p>那么怎么区分<code>节点</code>的<code>左孩子</code>指针指向的是<code>左子树</code>还是<code>前驱</code>呢？</p> 
<p>那么我们可以对<code>二叉树节点</code>的结构进行优化，增加两个<code>标识</code>，来指示具体指向的是<code>左右子树</code>还是<code>前驱后继</code>，如下示意图：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Rvo1eRxL-1588153397751)(https://user-gold-cdn.xitu.io/2020/4/29/171c52b7f414fb7f?w=840&amp;h=88&amp;f=png&amp;s=8092)]</p> 
<pre><code>// Link==0表示指向左右孩子指针
// Thread==1表示指向前驱或后继的线索
typedef enum {Link, Thread} PointerTag;

// 线索二叉树节点
typedef struct BiThrNode{

    //数据
    CElemType data;

    //左右孩子指针
    struct BiThrNode *lchild,*rchild;

    //左右标记
    PointerTag LTag;
    PointerTag RTag;

}BiThrNode,*BiThrTree;
</code></pre> 
<h4><a id="2__54"></a>2. 线索化二叉树实现</h4> 
<p>下面以中序遍历为例，线索二叉树的线索化和遍历</p> 
<ul><li> <p>线索二叉树的线索化</p> <p>首先，声明定义一些变量，并定义一个方法，</p> </li></ul> 
<pre><code>#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSW 0
#define MAXSIZE 100  // 存储空间初始分配量

typedef int Status; // 函数类型
typedef char CElemType;

CElemType Nill = '#'; // 字符型以空格标识空

#pragma mark  -二叉树的构造
int indexs = 1;
typedef char String[24]; /*  0号单元存放串的长度 */
String str;
// 字符传构造字符数组
Status StrAssign(String T, char *chars) {
    int i;
    if (strlen(chars) &gt; MAXSIZE) {
        return ERROR;
    }else {
        T[0] = strlen(chars);
        for (i = 1; i &lt;= T[0]; i++) {
            T[i] = *(chars+i-1);
        }
        return OK;
    }
}

// 打印值
Status visit(CElemType e) {
    printf("%c  ", e);
    return OK;
}

</code></pre> 
<p>按照中序遍历的方式，创建<code>线索化二叉树</code>，先创建，再线索化</p> 
<pre><code>// 中序二叉树线索化
// 定义全局变量，始终指向上一个访问的节点
BiThrTree pre;

void InThreading(BiThrTree p) {
    
    if (p) {
        // ✅ 递归左子树线索化
        InThreading(p-&gt;lchild);
        if (!p-&gt;lchild) { // ✅  没有左孩子，其前驱节点刚放访问过，赋值给 pre
            // 修改左标识
            p-&gt;LTag = Thread;
            // 左孩子的指针指向前驱
            p-&gt;lchild = pre;
        } else { // 有左孩子，修改左标识
            // 修改左标识
            p-&gt;LTag = Link;
        }
        
        // ✅ 判断前驱的右孩子
        if (!pre-&gt;rchild) { // 没有右孩子，p 就是 pre 的后继
            // 修改右标识
            pre-&gt;RTag = Thread;
            // 前驱右孩子指针指向后继（当前节点p）
            pre-&gt;rchild = p;
        } else {
            // 修改右标识
            pre-&gt;RTag = Link;
        }
        
        // ✅ 修改pre 指向 p的前驱
        pre = p;
        
        // ✅ 递归右子树线索化
        InThreading(p-&gt;rchild);
    }
}

</code></pre> 
<p>在对二叉树进行线索化的时候，我们可以增加一个<code>头节点</code></p> 
<pre><code>* 左孩子指向根节点
* 右孩子指向中序遍历的最后一个节点
* 中序遍历的第一个节点的左孩子指针（原来为null）和最后一个节点的右孩子指针(原来为null)都指向头结点
</code></pre> 
<p>好处：可以从第一个节点起，顺着前驱遍历，也可以顺着后继遍历，不用开始就递归找左孩子，如下图：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LpPWVjzV-1588153397755)(https://user-gold-cdn.xitu.io/2020/4/29/171c53fb6a932ab3?w=756&amp;h=351&amp;f=png&amp;s=52712)]</p> 
<p>代码：</p> 
<pre><code>Status InOrderThreading(BiThrTree *Thrt , BiThrTree T){
    *Thrt = (BiThrTree)malloc(sizeof(BiThrNode));
    if (!*Thrt) {
        exit(OVERFLOW);
    }
    
    // 建立头结点
    (*Thrt)-&gt;LTag = Link;
    (*Thrt)-&gt;RTag = Thread;
    // 右指针回指向，暂时指向自己（还不知道最后一个节点）
    (*Thrt)-&gt;rchild = (*Thrt);
    
    if (!T) { // 首节点为空，左孩子指针指向头结点
        (*Thrt)-&gt;lchild = *Thrt;
    } else {
        // ✅ 图中1
        (*Thrt)-&gt;lchild = T;
        // 修改pre，指向上一个操作的节点
        pre = (*Thrt);
        
        //中序遍历进行中序线索化
        InThreading(T);
        
        //✅ 图中4，最后一个结点rchil 孩子指向头结点
        pre-&gt;rchild = *Thrt;
        
        //✅ 最后一个结点线索化
        pre-&gt;RTag = Thread;
        //✅ 图中2
        (*Thrt)-&gt;rchild = pre;
    }

    return OK;
}

</code></pre> 
<ul><li>线索二叉树的遍历(中序遍历)</li></ul> 
<pre><code>// 中序遍历
Status InOrderTraverse_Thr(BiThrTree T){
    
    BiThrTree p = T-&gt;lchild;
    // p = T时，说明根节点（首节点）为空或者遍历结束
    while (p != T) {
        // 遍历，找到开始的叶子节点，即找到左子树为空的节点
        while (p-&gt;LTag == Link) {
            p = p-&gt;lchild;
        }
        // 访问
        if(!visit(p-&gt;data)) /* 访问其左子树为空的结点 */
        return ERROR;
        while (p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild!=T) {
            p=p-&gt;rchild;
            visit(p-&gt;data); /* 访问后继结点 */
        }
        p = p-&gt;rchild;
    }
    return OK;
}

// 调用
BiThrTree H,T;
 
//StrAssign(str,"ABDH#K###E##CFI###G#J##");
StrAssign(str,"ABDH##I##EJ###CF##G##");
CreatBiThrTree(&amp;T); /* 按前序产生二叉树 */
InOrderThreading(&amp;H,T); /* 中序遍历,并中序线索化二叉树 */
InOrderTraverse_Thr(H);

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e86d738702cb4724be91f1c626c1a236/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ResNet——CNN经典网络模型详解(pytorch实现)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ed69ee9e242ff99363839cdf4fe379fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Batch Normalization（BN）超详细解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>