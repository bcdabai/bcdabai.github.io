<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;实现冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序、快速排序 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;实现冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序、快速排序" />
<meta property="og:description" content="总结记录一下，C&#43;&#43;实现各种排序算法，加深理解。参考《大话数据结构》
排序 冒泡排序选择排序插入排序希尔排序堆排序归并排序快速排序 冒泡排序 冒泡排序(Bubble Sort)是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直达没有反序的记录位置。
void BubbleSort(vector&lt;int&gt; &amp;nums) { for (int i = 0; i&lt;nums.size() - 1; i&#43;&#43;) { for (int j = nums.size() -1; j&gt;i; j--) { if (nums[j]&lt;nums[j - 1]) { int t = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = t; } } } } 冒泡排序优化
当一轮比较中，没有任何数据交换，这就说明此序列已经有序，不需要再继续后面的循环判断工作了。为了实现这个想法，改进一下代码，增加标记变量flag.
void BubbleSort1(vector&lt;int&gt; &amp;nums) { for (int i = 0, flag = 1; i &lt; nums.size() - 1 &amp;&amp; flag == 1; i&#43;&#43;) { flag = 0; for (int j = nums." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5414e19e5f1f8359e073f88cdaa89e96/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-07T19:31:50+08:00" />
<meta property="article:modified_time" content="2019-07-07T19:31:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;实现冒泡排序、选择排序、插入排序、希尔排序、堆排序、归并排序、快速排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>总结记录一下，C++实现各种排序算法，加深理解。参考《大话数据结构》<br> </p> 
<div class="toc"> 
 <h4>排序</h4> 
 <ul><li><a href="#_2" rel="nofollow">冒泡排序</a></li><li><a href="#_38" rel="nofollow">选择排序</a></li><li><a href="#_59" rel="nofollow">插入排序</a></li><li><a href="#_75" rel="nofollow">希尔排序</a></li><li><a href="#_98" rel="nofollow">堆排序</a></li><li><a href="#_132" rel="nofollow">归并排序</a></li><li><a href="#_183" rel="nofollow">快速排序</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>冒泡排序</h2> 
<blockquote> 
 <p>冒泡排序(Bubble Sort)是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直达没有反序的记录位置。</p> 
</blockquote> 
<pre><code>void BubbleSort(vector&lt;int&gt; &amp;nums) {
	for (int i = 0; i&lt;nums.size() - 1; i++) {
		for (int j = nums.size() -1; j&gt;i; j--) {
			if (nums[j]&lt;nums[j - 1]) {
				int t = nums[j];
				nums[j] = nums[j - 1];
				nums[j - 1] = t;
			}
		}
	}
}
</code></pre> 
<p><strong>冒泡排序优化</strong></p> 
<blockquote> 
 <p>当一轮比较中，没有任何数据交换，这就说明此序列已经有序，不需要再继续后面的循环判断工作了。为了实现这个想法，改进一下代码，增加标记变量flag.</p> 
</blockquote> 
<pre><code>void BubbleSort1(vector&lt;int&gt; &amp;nums) {
	for (int i = 0, flag = 1; i &lt; nums.size() - 1 &amp;&amp; flag == 1; i++) {
		flag = 0;
		for (int j = nums.size() - 1; j&gt;i; j--) {
			if (nums[j]&lt;nums[j - 1]) {
				flag = 1;
				int t = nums[j];
				nums[j] = nums[j - 1];
				nums[j - 1] = t;
			}
		}
	}
}
</code></pre> 
<p>优化以后的冒泡排序算法当数组已经排好序时，仅需要n-1此比较。<br> 该排序算法的时间复杂度为O(n^2)。</p> 
<h2><a id="_38"></a>选择排序</h2> 
<blockquote> 
 <p>简单选择排序(Simple Selection Sort)通过n-i-1次关键字的比较，从n-i个记录中选出关键字最小的记录，并和第i(0&lt;=i&lt;=n)个记录交换之。</p> 
</blockquote> 
<pre><code>void SelectSort(vector&lt;int&gt; &amp;nums) {
	int i, j, index, t;
	for (i = 0; i &lt; nums.size(); i++) {
		index = i;
		for (j = i + 1; j &lt; nums.size(); j++) {
			if (nums[j] &lt; nums[index]) {
				index = j;
			}
		}
		t = nums[i];
		nums[i] = nums[index];
		nums[index] = t;
	}
}
</code></pre> 
<p>选择排序的优点是交换移动数据的次数相当少。<br> 该排序算法的时间复杂度为O(n^2)。</p> 
<h2><a id="_59"></a>插入排序</h2> 
<blockquote> 
 <p>直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p> 
</blockquote> 
<pre><code>void InsertSort(vector&lt;int&gt; &amp;nums) {
	int i, j, flag;
	for (i = 0; i &lt; nums.size()-1; i++) {
		flag = nums[i + 1];
		for (j = i;j&gt;=0&amp;&amp; flag &lt; nums[j];j--)
			nums[j + 1] = nums[j];			//记录后移
		nums[j+1] = flag;					//插入到正确的位置
	}
}
</code></pre> 
<p>最好的情况下，只需要比较n-1次，不需要移动元素。<br> 该排序算法的时间复杂度为O(n^2)。</p> 
<h2><a id="_75"></a>希尔排序</h2> 
<blockquote> 
 <p>基本有序:小的关键字在前面，大的关键字在后面，不大不小的关键字在中间。<br> 将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序的。</p> 
</blockquote> 
<p>因此，希尔排序就是按照一个增量，从原序列中取出子序列，对子序列使用插入排序。再缩小增量，重复操作，直到增量变为1，此时的子数组就是原数组，再使用一次插入排序即可。</p> 
<pre><code>void ShellSort(vector&lt;int&gt; &amp;nums) {
	int i, j, k, t;
	int inc = nums.size();
	while (1) {
		inc = inc / 3 + 1;
		for (int i = inc; i &lt; nums.size(); i++) {
			t = nums[i];	//存需要插入的元素
			for (j = i-inc; j &gt;= 0&amp;&amp;t&lt;nums[j]; j = j - inc)
				nums[j + inc] = nums[j];	//记录后移
			nums[j + inc] = t;		//插入
		}
		if (inc == 1)
			break;
	}
}
</code></pre> 
<p>希尔排序的复杂度是O(n^(3/2))</p> 
<h2><a id="_98"></a>堆排序</h2> 
<blockquote> 
 <p>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。<br> 堆排序算法就是利用堆进行排序的方法。它的基本思想是将待排序的序列构成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构成一个堆，这样就会得到n个元素中的次大值。如此反复执行，便能得到一个有序序列了。</p> 
</blockquote> 
<pre><code>void HeapAdjust(vector&lt;int&gt; &amp;nums, int s, int m) {//调整s结点，使得该位置的结点满足大顶堆的条件
	int i, temp;
	temp = nums[s];
	for (int i = 2 * s; i &lt;= m; i = i * 2) {
		if (i &lt; m&amp;&amp;nums[i] &lt; nums[i + 1])
			i++;
		if (temp &gt;= nums[i])
			break;
		nums[s] = nums[i];
		s = i;
	}
	nums[s] = temp;

}

void HeapSort(vector&lt;int&gt; &amp;nums) {
	int i;
	for (i = nums.size() / 2; i &gt;= 0; i--) {	//从最后一个有叶子结点的结点开始，一直到根。
		HeapAdjust(nums, i, nums.size() - 1);
	}
	int t;
	for (i = nums.size() - 1; i &gt; 0; i--) {
		t = nums[i];
		nums[i] = nums[0];
		nums[0] = t;
		HeapAdjust(nums, 0, i-1);
	}
}
</code></pre> 
<p>该算法每一轮包括构建堆（logn），取堆顶记录(n)操作，时间复杂度为O(nlogn)。</p> 
<h2><a id="_132"></a>归并排序</h2> 
<blockquote> 
 <p>归并排序（Merging Sort）就是利用归并的思想实现的排序方法。原理是：假定初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]（上取整）个长度为2或1的有序子序列；再两两归并，……，如此重复，直到得到一个长度为n的有序序列为止，这种排序方法称为2路归并排序。</p> 
</blockquote> 
<p><strong>递归实现归并排序</strong></p> 
<pre><code>void Merge(vector&lt;int&gt; &amp;nums, int s, int m, int t) {
	vector&lt;int&gt; copy_nums=nums;	//把数组的[s,m]和[m+1,t]段进行合并
	int i = s, j = m + 1, now = s;
	while (i &lt;= m &amp;&amp; j &lt;= t) {
		if (copy_nums[i] &lt;= copy_nums[j]) {
			nums[now] = copy_nums[i];
			i++;
		}
		else {
			nums[now] = copy_nums[j];
			j++;
		}
		now++;
	}
	if (i &lt;= m) {
		for (; i &lt;= m; i++) {
			nums[now] = copy_nums[i];
			now++;
		}

	}
	else if (j &lt;= t) {
		for (; j &lt;= t; j++) {
			nums[now] = copy_nums[j];
			now++;
		}
	}
}

void MSort(vector&lt;int&gt; &amp;nums, int s, int t) { //对数组的[s,t]段进行二路归并
	if (s == t)
		return;
	else {
		int m = (s + t) / 2;
		MSort(nums, s, m);	//分
		MSort(nums, m + 1, t);	//分
		Merge(nums,s,m,t);	//并
	}
}

void MergeSort(vector&lt;int&gt; &amp;nums) {	//调用该函数进行排序
	MSort(nums, 0, nums.size() - 1);	
}
</code></pre> 
<p>算法的复杂度为O(nlogn)<br> 应用例题:<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" rel="nofollow">数组中的逆序对</a></p> 
<h2><a id="_183"></a>快速排序</h2> 
<blockquote> 
 <p>快速排序(Quick Sort)的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序的目的。</p> 
</blockquote> 
<pre><code>void QSort(vector&lt;int&gt; &amp;nums,int low,int high) {
	if (low &gt;= high)
		return;
	int pivot = nums[low];
	int left = low, right = high;
	while (left &lt; right) {//将数组重排，使得pivot的左边的数都比pivot小，右边的数都比pivot大
		while (left &lt; right&amp;&amp;nums[high] &gt;= pivot)
			right--;
		int t = nums[right];
		nums[right] = nums[left];
		nums[left] = t;
		while (left &lt; right&amp;&amp;nums[left] &lt;= pivot)
			left++;
		t = nums[left];
		nums[left] = nums[right];
		nums[right] = t;
	}
	QSort(nums, low, left-1);	//此时low和high都为pivot的索引值（下标）
	QSort(nums, left + 1, high);
}

void QuickSort(vector&lt;int&gt; &amp;nums) {
	QSort(nums, 0, nums.size()-1);	//返回排序好以后的结果
}
</code></pre> 
<p>在最好的情况下，(借助于递归树来理解)算法的时间复杂度是O(nlogn),最坏的情况下，时间复杂度为O(n^2)。同时，快速排序也是一种不稳定的算法。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/44e40c54202101318df56e75434d8e8e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">idea 如何导入和导出自己设置好的主题背景</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5a7e871c0c552669a6ea360baa990c09/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Jenkins部署.Net Core遇到的几个坑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>