<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker安装与使用（Centos7.5） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker安装与使用（Centos7.5）" />
<meta property="og:description" content="Docker的安装 说明：本篇文章为学习 docker 使用时记录的笔记，方便查询。
Docker 官方建议在 Ubuntu 中安装，因为 Docker 是基于 Ubuntu 发布的，而且一般 Docker 出现的问题，Ubuntu 是最先更新或者打补丁的。在很多版本的 CentOS 中是不支持更新最新的一些补丁包的。
由于部署 CentOS 环境，因此这里建议安装在 CentOS 7.0 及以上的版本，在 CentOS 6.x 的版本中，安装前需要安装其他很多的环境而且 Docker 很多补丁不支持更新。
因此请移步到 CentOS7 或 Ubuntu 系统。
（1）yum 源更新到最新 (可暂缓)
sudo yum update （2）安装需要的软件包，yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的。
sudo yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置 yum 源为阿里云（加速镜像下载）
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）安装docker
## 安装当前符合的最新版 sudo yum -y install docker-ce ## 指定版本安装 # 查阅已知的版本 yum list docker-ce --showduplicates | sort -r # 例如：指定安装 18." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5c4f8bbe436118acf627d7b6e2f6c41c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-31T09:30:36+08:00" />
<meta property="article:modified_time" content="2023-03-31T09:30:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker安装与使用（Centos7.5）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Docker_0"></a>Docker的安装</h3> 
<p>说明：本篇文章为学习 docker 使用时记录的笔记，方便查询。</p> 
<p>Docker 官方建议在 Ubuntu 中安装，因为 Docker 是基于 Ubuntu 发布的，而且一般 Docker 出现的问题，Ubuntu 是最先更新或者打补丁的。在很多版本的 CentOS 中是不支持更新最新的一些补丁包的。</p> 
<p>由于部署 CentOS 环境，因此这里建议安装在 CentOS 7.0 及以上的版本，在 CentOS 6.x 的版本中，安装前需要安装其他很多的环境而且 Docker 很多补丁不支持更新。</p> 
<p>因此请移步到 CentOS7 或 Ubuntu 系统。</p> 
<p>（1）yum 源更新到最新 (可暂缓)</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> yum update
</code></pre> 
<p>（2）安装需要的软件包，yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的。</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> yum <span class="token function">install</span> -y yum-utils device-mapper-persistent-data lvm2
</code></pre> 
<p>（3）设置 yum 源为阿里云（加速镜像下载）</p> 
<pre><code class="prism language-bash">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre> 
<p>（4）安装docker</p> 
<pre><code class="prism language-bash"><span class="token comment">## 安装当前符合的最新版</span>
<span class="token function">sudo</span> yum -y <span class="token function">install</span> docker-ce

<span class="token comment">## 指定版本安装</span>
<span class="token comment"># 查阅已知的版本</span>
yum list docker-ce --showduplicates <span class="token operator">|</span> <span class="token function">sort</span> -r
<span class="token comment"># 例如：指定安装 18.06.3.ce-3.el7 版本</span>
yum <span class="token function">install</span> docker-ce-18.06.3.ce-3.el7 -y
</code></pre> 
<p>（5）查看安装的docker版本 (验证安装结果)</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> -v
</code></pre> 
<h4><a id="22ustc_46"></a>2.2.设置ustc的镜像</h4> 
<p>ustc 是老牌的 linux 镜像服务提供者了，还在遥远的 ubuntu 5.04 版本的时候就在用。ustc 的 docker 镜像加速器速度很快。ustc docker mirror 的优势之一就是不需要注册，是真正的公共服务。</p> 
<p>https://lug.ustc.edu.cn/wiki/mirrors/help/docker</p> 
<p>编辑该文件：</p> 
<pre><code class="prism language-bash"><span class="token function">vi</span> /etc/docker/daemin.json
</code></pre> 
<p>在该文件中输入如下内容：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"https://docker.mirrors.ustc.edu.cn"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其他选择：阿里云镜像加速器。方法：在阿里云的容器镜像服务，地址：https://cr.console.aliyun.com/cn-qingdao/instances，配置一个镜像加速器地址，例如：https://7ukb8w3w.mirror.aliyuncs.com，然后在服务器或虚拟机上配置。</p> 
<h4><a id="23Docker_68"></a>2.3.Docker的启动与停止</h4> 
<p><strong>systemctl</strong> 命令是系统服务管理器指令。</p> 
<pre><code class="prism language-bash"><span class="token comment"># 启动docker</span>
systemctl start <span class="token function">docker</span>

<span class="token comment"># 停止docker</span>
systemctl stop <span class="token function">docker</span>

<span class="token comment"># 重启docker</span>
systemctl restart <span class="token function">docker</span>

<span class="token comment"># 查看docker运行状态</span>
systemctl status <span class="token function">docker</span>

<span class="token comment"># 设置开机启动</span>
systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>

<span class="token comment"># 取消开机启动</span>
systemctl disable <span class="token function">docker</span>

<span class="token comment"># 查看docker概要信息</span>
<span class="token function">docker</span> info

<span class="token comment"># 查看docker帮助文档</span>
<span class="token function">docker</span> --help
</code></pre> 
<h3><a id="3_98"></a>3.常用命令</h3> 
<h4><a id="31_100"></a>3.1.镜像相关命令</h4> 
<h5><a id="311_102"></a>3.1.1.查看镜像</h5> 
<pre><code class="prism language-bash"><span class="token function">docker</span> images
</code></pre> 
<p>显示结果参数说明：</p> 
<p>REPOSITORY：镜像名称<br> TAG：镜像标签<br> IMAGE ID：镜像ID<br> CREATED：镜像的创建日期 (不是获取该镜像的日期)<br> SIZE：镜像大小</p> 
<p>注意：这些镜像都是存储在 Docker 宿主机的 /var/lib/docker 目录中。</p> 
<h5><a id="312_118"></a>3.1.2.搜索镜像</h5> 
<p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> search <span class="token punctuation">[</span>镜像名称<span class="token punctuation">]</span>
</code></pre> 
<p>显示结果参数说明：</p> 
<p>NAME：镜像名称<br> DESCRIPTION：镜像描述<br> STARS：用户评价，反映一个镜像的受欢迎程度（数值）<br> OFFICIAL：是否官方<br> AUTOMATED：自动构建，表示该镜像由 Docker Hub 自动构建流程创建的</p> 
<h5><a id="313_134"></a>3.1.3.拉取镜像</h5> 
<pre><code class="prism language-bash"><span class="token function">docker</span> pull <span class="token punctuation">[</span>镜像名称<span class="token punctuation">]</span>:<span class="token punctuation">[</span>版本号--不填表示拉取最新<span class="token punctuation">]</span>
</code></pre> 
<p>示例：下载 centos7镜像</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> pull centos:7
</code></pre> 
<h5><a id="314_146"></a>3.1.4.删除镜像</h5> 
<p>按镜像ID删除镜像：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> rmi <span class="token punctuation">[</span>镜像ID<span class="token punctuation">]</span>
</code></pre> 
<p>删除所有镜像</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> rmi <span class="token variable"><span class="token variable">`</span><span class="token function">docker</span> images -q<span class="token variable">`</span></span>
</code></pre> 
<h4><a id="32_160"></a>3.2.容器相关命令</h4> 
<h5><a id="321_162"></a>3.2.1.查看容器</h5> 
<p>查看正在运行的容器：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token function">ps</span>
</code></pre> 
<p>查看所有容器 (含已经退出的容器)</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token function">ps</span> -a
</code></pre> 
<p>查看最后一次运行的容器</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token function">ps</span> -l
</code></pre> 
<p>查看停止的容器</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token function">ps</span> -f <span class="token assign-left variable">status</span><span class="token operator">=</span>exited
</code></pre> 
<h5><a id="322_188"></a>3.2.2.创建与启动容器</h5> 
<p>创建容器常用的参数说明：</p> 
<p>创建容器命令：<code>docker run</code></p> 
<p>-i：表示运行容器<br> -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。<br> –name：为创建的容器命名。<br> -v：表示目录映射关系 (前者是宿主机目录，后者是映射到宿主机上的目录)，可以使用多个 -v 做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。<br> -d：在 run 后面加上 -d 参数则会创建一个守护式容器在后台运行 (这样创建容器后不会自动登录容器，如果只加 -i -t 两个参数，创建后就会自动进去容器)。<br> -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个 -p 做多个端口映射</p> 
<p>(1) <strong>交互式方式创建容器</strong></p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run -it --name<span class="token operator">=</span><span class="token punctuation">[</span>容器名称<span class="token punctuation">]</span> <span class="token punctuation">[</span>镜像名称<span class="token punctuation">]</span>:<span class="token punctuation">[</span>标签<span class="token punctuation">]</span> /bin/bash
</code></pre> 
<p>这时我们通过 ps 命令查看，发现可以看到启动的容器，状态为启动状态</p> 
<p>退出当前容器使用 <code>exit</code> 命令。</p> 
<p>(2) <strong>守护式方式创建容器</strong></p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run -di --name<span class="token operator">=</span><span class="token punctuation">[</span>容器名称<span class="token punctuation">]</span> <span class="token punctuation">[</span>镜像名称<span class="token punctuation">]</span>:<span class="token punctuation">[</span>标签<span class="token punctuation">]</span>
</code></pre> 
<p>登录守护式容器方式：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it <span class="token punctuation">[</span>容器名称<span class="token punctuation">]</span><span class="token punctuation">(</span>或者容器ID<span class="token punctuation">)</span> /bin/bash
</code></pre> 
<h5><a id="323_223"></a>3.2.3.停止与启动容器</h5> 
<p>停止容器：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> stop <span class="token punctuation">[</span>容器名称<span class="token punctuation">]</span><span class="token punctuation">(</span>或者容器ID<span class="token punctuation">)</span>
</code></pre> 
<p>启动容器：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> start <span class="token punctuation">[</span>容器名称<span class="token punctuation">]</span><span class="token punctuation">(</span>或者容器ID<span class="token punctuation">)</span>
</code></pre> 
<h5><a id="324_237"></a>3.2.4.文件拷贝</h5> 
<p>如果我们需要将文件拷贝到容器内可以使用 cp 命令：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token function">cp</span> 需要拷贝的文件或目录 <span class="token punctuation">[</span>容器名称<span class="token punctuation">]</span>:<span class="token punctuation">[</span>容器目录<span class="token punctuation">]</span>

<span class="token comment"># 示例</span>
<span class="token function">docker</span> <span class="token function">cp</span> anaconda-ks.cfg mycentos1:/usr/local
</code></pre> 
<p>也可以将文件从容器内拷贝出来：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token function">cp</span> <span class="token punctuation">[</span>容器名称<span class="token punctuation">]</span>:<span class="token punctuation">[</span>容器目录<span class="token punctuation">]</span> 需要拷贝的文件或目录

<span class="token comment"># 示例</span>
<span class="token function">docker</span> <span class="token function">cp</span> mycentos1:/usr/local/anaconda-ks.cfg anaconda-ks.cfg
</code></pre> 
<h5><a id="325_257"></a>3.2.5.目录挂载</h5> 
<p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。</p> 
<p>创建容器添加 -v 参数 后边为 [宿主机目录]:[容器目录]，例如：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run -di -v /usr/local/myhtml:/usr/local/myhtml --name<span class="token operator">=</span>mycentos2 centos:7
</code></pre> 
<p>如果你共享的是多级的目录，可能会出现权限不足的提示。</p> 
<p>这是因为 CentOS7 中的安全模块 selinux 把权限禁掉了，我们需要添加参数 -prvileged=true 来解决挂载的目录没有权限的问题。</p> 
<h5><a id="326ip_271"></a>3.2.6.查看容器ip地址</h5> 
<p>我们可以通过以下命令查看容器运行的各种数据：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> inspect <span class="token punctuation">[</span>容器名称<span class="token punctuation">]</span><span class="token punctuation">(</span>或容器ID<span class="token punctuation">)</span>
</code></pre> 
<p>也可以直接执行下面的命令直接输出 IP 地址：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> inspect --format<span class="token operator">=</span><span class="token string">'{<!-- -->{.NetworkSettings.IPAddress}}'</span> <span class="token punctuation">[</span>容器名称<span class="token punctuation">]</span><span class="token punctuation">(</span>或容器ID<span class="token punctuation">)</span>
</code></pre> 
<h5><a id="327_285"></a>3.2.7.删除容器</h5> 
<p>删除指定容器：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token function">rm</span> <span class="token punctuation">[</span>容器名称<span class="token punctuation">]</span><span class="token punctuation">(</span>或容器ID<span class="token punctuation">)</span>
</code></pre> 
<h5><a id="328_292"></a>3.2.8.容器开机自启</h5> 
<p>前置条件，启用了 docker 开机自启设置：<code>systemctl enable docker</code></p> 
<ul><li>创建容器时设置开机自启</li></ul> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run -d --restart<span class="token operator">=</span>always --name 设置容器名 使用的镜像（--name后面两个参数根据实际情况自行修改）
 
<span class="token comment"># Docker 容器的重启策略如下：</span>
 --restart具体参数值详细信息：
       no　　　　　　　 // 默认策略,容器退出时不重启容器；
       on-failure　　  // 在容器非正常退出时（退出状态非0）才重新启动容器；
       on-failure:3    // 在容器非正常退出时重启容器，最多重启3次；
       always　　　　  // 无论退出状态是如何，都重启容器；
       unless-stopped  // 在容器退出时总是重启容器，但是不考虑在 Docker 守护进程启动时就已经停止了的容器。
</code></pre> 
<ul><li>修改已有容器，使用update</li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># 如果创建时未指定 --restart=always，可通过update 命令设置</span>
<span class="token function">docker</span> update --restart<span class="token operator">=</span>always 容器ID<span class="token punctuation">(</span>或者容器名<span class="token punctuation">)</span> （容器ID或者容器名根据实际情况修改）
</code></pre> 
<h3><a id="4_317"></a>4.应用部署</h3> 
<h4><a id="41Mysql_319"></a>4.1.Mysql部署</h4> 
<p>（1）拉取 mysql 镜像 (此处演示为 mysql5.7)</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> pull centos/mysql-57-centos7
</code></pre> 
<p>（2）创建容器</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run -di --name<span class="token operator">=</span>yufeng_mysql -p <span class="token number">3306</span>:3306 -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>root centos/mysql-57-centos7
</code></pre> 
<p>-p：代表端口映射，格式为：[宿主机映射端口]:[容器运行端口]</p> 
<p>-e：代表添加环境变量 MYSQL_ROOT_PASSWORD 是 root 用户的登录密码</p> 
<p>（3）进入 mysql 容器</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it yufeng_mysql /bin/bash
</code></pre> 
<p>（4）登录 mysql（容器内操作）</p> 
<pre><code class="prism language-bash">mysql -u root -p <span class="token comment"># 回车后输入密码</span>
</code></pre> 
<p>（5）远程登录 mysql（注意开放宿主机映射端口，例如 3306）</p> 
<h4><a id="42Tomcat_351"></a>4.2.Tomcat部署</h4> 
<p>（1）拉取镜像</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> pull tomcat:7-jre7
</code></pre> 
<p>（2）创建容器 (使用 -p 参数设置映射，使用 -v 参数设置挂载宿主机目录)</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run -di --name<span class="token operator">=</span>my_tomcat -p <span class="token number">8080</span>:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7
</code></pre> 
<h4><a id="43Nginx_365"></a>4.3.Nginx部署</h4> 
<p>（1）拉取镜像：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> pull nginx
</code></pre> 
<p>（2）创建 Nginx 容器：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 简单方式使用</span>
<span class="token function">docker</span> run -di -name<span class="token operator">=</span>my_nginx -p <span class="token number">80</span>:80 nginx

<span class="token comment"># 实际应用</span>
<span class="token comment">## 1.创建Nginx宿主机挂载目录（放置配置文件等内容）</span>
<span class="token function">mkdir</span> -p /home/nginx/conf
<span class="token function">mkdir</span> -p /home/nginx/log
<span class="token function">mkdir</span> -p /home/nginx/html

<span class="token comment">## 2.容器中的nginx.conf文件、conf.d文件夹和html文件夹复制到宿主机</span>
<span class="token function">docker</span> <span class="token function">cp</span> my_nginx:/etc/nginx/nginx.conf /home/nginx/conf/nginx.conf
<span class="token comment"># 将容器conf.d文件夹下内容复制到宿主机</span>
<span class="token function">docker</span> <span class="token function">cp</span> my_nginx:/etc/nginx/conf.d /home/nginx/conf/conf.d
<span class="token comment"># 将容器中的html文件夹复制到宿主机</span>
<span class="token function">docker</span> <span class="token function">cp</span> my_nginx:/usr/share/nginx/html /home/nginx/

<span class="token comment">## 3.关闭前面测试容器，重新创建指定了挂载内容的容器</span>
<span class="token comment"># 关闭该容器</span>
<span class="token function">docker</span> stop my_nginx
<span class="token comment"># 删除该容器</span>
<span class="token function">docker</span> <span class="token function">rm</span> my_nginx

<span class="token function">docker</span> run -p <span class="token number">80</span>:80 --name nginx <span class="token punctuation">\</span>
-v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf <span class="token punctuation">\</span>
-v /home/nginx/conf/conf.d:/etc/nginx/conf.d <span class="token punctuation">\</span>
-v /home/nginx/log:/var/log/nginx <span class="token punctuation">\</span>
-v /home/nginx/html:/usr/share/nginx/html <span class="token punctuation">\</span>
-d nginx
</code></pre> 
<p>实际应用参考博文：</p> 
<blockquote> 
 <p>https://blog.csdn.net/weixin_46244732/article/details/114315708<br> https://blog.csdn.net/BThinker/article/details/123507820</p> 
</blockquote> 
<h4><a id="44Redis_411"></a>4.4.Redis部署</h4> 
<p>（1）拉取镜像：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> pull redis
</code></pre> 
<p>（2）创建 Redis 容器：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run -di -name<span class="token operator">=</span>my_redis -p <span class="token number">6380</span>:6379 redis
</code></pre> 
<h3><a id="5_425"></a>5.迁移与备份</h3> 
<h4><a id="51_427"></a>5.1.容器保存为镜像</h4> 
<p>将容器保存为镜像命令：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> commit my_nginx my_nginx_i
</code></pre> 
<h4><a id="52_435"></a>5.2.镜像备份</h4> 
<p>将镜像保存为 tar 文件：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> save -o my_nginx.tar my_nginx_i
</code></pre> 
<h4><a id="53_443"></a>5.3.镜像恢复与迁移</h4> 
<p>首先我们先删除掉 my_nginx_i 镜像，然后执行此命令进行恢复：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> load -i my_nginx.tar
</code></pre> 
<p>参数含义：-i：输入文件</p> 
<p>执行后再次查看镜像，可以看到镜像已经恢复。</p> 
<h3><a id="6Dockerfile_455"></a>6.Dockerfile</h3> 
<h4><a id="61Dockerfile_457"></a>6.1.什么是Dockerfile</h4> 
<p>Dockerfile 是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p> 
<p>1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；<br> 2、对于测试人员：可以直接拿开发时所构建的镜像或者通过 Dockerfile 文件构建一个新的镜像开始工作；<br> 3、对于运维人员：在部署时，可以实现应用的无缝移植。</p> 
<h4><a id="62Dockerfile_465"></a>6.2.Dockerfile常用命令</h4> 
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>FROM [image_name]:[tag]</td><td>定义使用那个基础镜像启动构建流程</td></tr><tr><td>MAINTAINER [user_name]</td><td>声明镜像的创建者</td></tr><tr><td>ENV [key] [value]</td><td>设置环境变量 (可以写多条)</td></tr><tr><td>RUN command</td><td>Dockerfile的核心部分 (可以写多条)</td></tr><tr><td>ADD source_dir/file dest_dir/file</td><td>将宿主机的文件复制到容器内，如果是一个压缩文件， 将会在复制后自动解压</td></tr><tr><td>COPY source_dir/file dest_dir/file</td><td>作用和 ADD 相似，但如果有压缩文件并不能解压</td></tr><tr><td>WORKDIR path_dir</td><td>设置工作目录</td></tr></tbody></table> 
<h4><a id="63_477"></a>6.3.使用脚本创建镜像</h4> 
<p>创建 java 环境镜像步骤：</p> 
<p>（1）创建目录：</p> 
<pre><code class="prism language-bash"><span class="token function">mkdir</span> -p /usr/apps/docker-jdk8 <span class="token comment"># -p:表示路径不存在时循环创建</span>
</code></pre> 
<p>（2）下载 java8 的安装包并上传服务器 (或虚拟机) 的 /usr/apps/docker-jdk8 目录中，这里使用的 java8 版本是：jdk-8u171-linux-x64.tar.gz。</p> 
<p>（3）在 /usr/apps/docker-jdk8 目录中创建 Dockerfile 文件，命令：<code>vi Dockerfile</code>，然后编写如下内容：</p> 
<pre><code class="prism language-bash"><span class="token comment">#依赖镜像名称和版本</span>
FROM centos:7
<span class="token comment">#指定镜像创建者信息</span>
MAINTAINER yufeng16
<span class="token comment">#切换工作目录</span>
WORKDIR /usr
RUN <span class="token function">mkdir</span> /usr/local/java
<span class="token comment">#ADD添加相对路径下jar，吧java添加到容器中</span>
ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/

<span class="token comment">#设置java环境变量</span>
ENV JAVA_HOME /usr/local/java/jdk1.8.0_171
ENV JRE_HOME <span class="token variable">$JAVA_HOME</span>/jre
ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/bin/dt.jar:<span class="token variable">$JAVA_HOME</span>/1ib/tools.jar:<span class="token variable">$JRE_HOME</span>/lib:<span class="token variable">$CLASSPATH</span>
ENV <span class="token environment constant">PATH</span> <span class="token variable">$JAVA_HOME</span>/bin:<span class="token environment constant">$PATH</span>
</code></pre> 
<p>（4）执行构建命令创建镜像：</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> build -t<span class="token operator">=</span><span class="token string">'jdk1.8'</span> <span class="token builtin class-name">.</span>
</code></pre> 
<p>以上就是使用 Dockerfile 创建镜像的示例过程。</p> 
<h3><a id="7Docker_517"></a>7.Docker私有仓库</h3> 
<h4><a id="71_519"></a>7.1.私有仓库搭建与配置</h4> 
<p>（1）拉取私有仓库镜像</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> pull registry
</code></pre> 
<p>（2）启动私有仓库容器</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run -di --name<span class="token operator">=</span>docker-registry -p <span class="token number">5000</span>:5000 registry
</code></pre> 
<p>（3）打开浏览器输入地址，例如：http://192.168.235.101:5000/v2/_catalog 看到 {“repositories”: []} 表示私有仓库搭建成功并且内容为空。</p> 
<p>注意：开放防火墙端口：</p> 
<pre><code class="prism language-bash">firewall-cmd --permanent --add-port<span class="token operator">=</span><span class="token number">5000</span>/tcp <span class="token comment"># 开放端口</span>
firewall-cmd --reload <span class="token comment"># 重新加载</span>
</code></pre> 
<p>centos7 防火墙操作见博文：<a href="https://blog.csdn.net/rao991207823/article/details/109431627">firewall防火墙</a></p> 
<p>（4）修改daemon.json：</p> 
<pre><code class="prism language-json">vi <span class="token operator">/</span>etc<span class="token operator">/</span>docker<span class="token operator">/</span>daemon<span class="token punctuation">.</span>json
</code></pre> 
<p>添加以下内容并保存退出：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span><span class="token string">"insecure-registries"</span>:<span class="token punctuation">[</span><span class="token string">"192.168.235.101:5000"</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
</code></pre> 
<p>如果原先配置了镜像加速则语句为：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"registry-mirrors"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"https://docker.mirrors.ustc.edu.cn"</span><span class="token punctuation">]</span>,
  <span class="token string">"insecure-registries"</span>:<span class="token punctuation">[</span><span class="token string">"192.168.235.101:5000"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>（5）重启 docker 服务：<code>systemctl restart docker</code></p> 
<h4><a id="72_567"></a>7.2.镜像上传至私有仓库</h4> 
<p>（1）标记需要上传的镜像为私有仓库镜像</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> tag jdk1.8 <span class="token number">192.168</span>.235.101:5000/jdk1.8
</code></pre> 
<p>（2）上传标记镜像</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> push <span class="token number">192.168</span>.235.101:5000/jdk1.8
</code></pre> 
<p>完成后可在 http://192.168.235.101:5000/v2/_catalog 中看到 jdk1.8 字样。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a4372c05dba7a5d77aa67c036119a9b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Alkaitu:STM32串口定时器延时接收不定数组和串口发送</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e0b76905d7d1c874e6340315cb90749/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">单片机编程语言——C语言（1）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>