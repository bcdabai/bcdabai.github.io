<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java中的浅拷贝 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java中的浅拷贝" />
<meta property="og:description" content="Java中对象拷贝(Object Copy)指的是将一个对象的所有属性（成员变量）拷贝到另一个有着相同类类型的对象中去。
例如：对象A和对象B都属于类S，具有属性a和b。那么对对象A进行拷贝操作赋值给对象B
就是： B.b = A.a;
B.b = A.a;
Java中的对象拷贝主要分为：浅拷贝(Shallow Copy)、深拷贝(Deep Copy)
浅拷贝：
对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性复制一份给新的对象。因为是两份不同的数据，所以对其中一的对象的成员变量值进行修改，不会影响另一个对象拷贝得到的数据。对于数据类型是引用类型的成员变量，比如说成员变量是某个数组，某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用指（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。 实现浅拷贝主要有以下方式：
通过拷贝构造方法 public class CopyConstructor { public static void main(String[] args) { Age a = new Age(20); Person p1 = new Person(a,&#34;宁采臣&#34;); Person p2 = new Person(p1); System.out.println(&#34;p1是&#34;&#43;p1); System.out.println(&#34;p2是&#34;&#43;p2); //修改p1的各属性值，观察p2得到各属性值是否跟随变化 p1.setName(&#34;聂小倩&#34;); a.setAge(18); System.out.println(&#34;修改后的p1是&#34;&#43;p1); System.out.println(&#34;修改后的p2是&#34;&#43;p2); } } class Person{ private Age age; private String name; public Person(Age age,String name){ this.age = age; this.name = name; } //拷贝构造方法 public Person(Person p){ this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7d82b1b1419cef812779635b82f78233/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-19T17:55:41+08:00" />
<meta property="article:modified_time" content="2022-03-19T17:55:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java中的浅拷贝</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:justify;">Java中对象拷贝(Object Copy)指的是将一个对象的所有属性（成员变量）拷贝到另一个有着相同类类型的对象中去。</p> 
<p style="text-align:justify;">例如：对象A和对象B都属于类S，具有属性a和b。那么对对象A进行拷贝操作赋值给对象B</p> 
<p style="text-align:justify;">就是： B.b = A.a;</p> 
<p style="margin-left:42pt;text-align:justify;">B.b = A.a;</p> 
<p style="margin-left:42pt;text-align:justify;"></p> 
<p style="text-align:left;">Java中的对象拷贝主要分为：浅拷贝(Shallow Copy)、深拷贝(Deep Copy)</p> 
<p style="text-align:left;">浅拷贝：</p> 
<ol><li style="text-align:left;">对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性复制一份给新的对象。因为是两份不同的数据，所以对其中一的对象的成员变量值进行修改，不会影响另一个对象拷贝得到的数据。</li><li style="text-align:left;">对于数据类型是引用类型的成员变量，比如说成员变量是某个数组，某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用指（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li></ol> 
<p></p> 
<p style="text-align:left;">实现浅拷贝主要有以下方式：</p> 
<ul><li style="text-align:left;">通过拷贝构造方法</li></ul> 
<p style="margin-left:21pt;text-align:left;"></p> 
<p style="margin-left:21pt;text-align:left;"></p> 
<pre><code class="language-java">
public class CopyConstructor {
    public static void main(String[] args) {
        Age a = new Age(20);
        Person p1 = new Person(a,"宁采臣");
        Person p2 = new Person(p1);
        System.out.println("p1是"+p1);
        System.out.println("p2是"+p2);
        //修改p1的各属性值，观察p2得到各属性值是否跟随变化
        p1.setName("聂小倩");
        a.setAge(18);
        System.out.println("修改后的p1是"+p1);
        System.out.println("修改后的p2是"+p2);
    }
}

class   Person{
    private Age age;
    private String name;
    public Person(Age age,String name){
        this.age = age;
        this.name = name;
    }

    //拷贝构造方法
    public Person(Person p){
        this.name = p.name;
        this.age = p.age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String toString(){
        return this.name + " " + this.age;
    }
}


class Age{
    private int age;
    public Age(int age){
        this.age = age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return this.age;
    }

    public String toString(){
        return getAge()+"";
    }

}
</code></pre> 
<p> <img alt="" height="288" src="https://images2.imgbox.com/b4/05/8vn7aYHX_o.png" width="423"></p> 
<p> <img alt="" height="86" src="https://images2.imgbox.com/2b/ef/kyMgOF3g_o.png" width="186"></p> 
<p>结果分析：这里对Person类选择了两个具有代表性的属性值：一个是引用传递类型；另一个是字符串类型（属于常量）。</p> 
<p>通过拷贝构造方法进行了浅拷贝，各属性值成功复制。其中，p1值传递部分的属性值发生变化时，p2不会随之改变；而引用传递部分属性值发生变化时，p2也随之改变。</p> 
<p>要注意：如果在拷贝构造方法中，对引用数据类型变量逐一开辟新的内存空间，创建新的对象，也可以实现深拷贝。而对于一般的拷贝构造，则一定是浅拷贝。</p> 
<p> </p> 
<ul><li style="text-align:left;">通过重写clone()方法进行浅拷贝</li></ul> 
<p style="margin-left:21pt;text-align:left;">Object类是类结构的根类，其中有一个方法为protected Object clone() throw CloneNotSupportedException,这个方法就是进行的浅拷贝。有了这个浅拷贝的模板，就可以通过调用clone()方法来实现对象的浅拷贝，但是需要注意：</p> 
<ol><li style="text-align:left;">Object类虽然有这个方法，但是这个方法是受保护的(被projected修饰)，所以是无法直接使用。</li><li style="text-align:left;">使用clone方法的类必须实现Cloneable接口，否则会抛出异常CloneNotSupportedException。</li><li style="text-align:left;">对于以上两点，解决方法是，在使用clone方法的类中重写了clone()方法，通过super.clone()调用Object类中的原clone方法</li></ol> 
<p style="margin-left:42pt;text-align:left;">参考代码如下：对Student类的对象进行拷贝，直接重写clone()方法，通过调用clone方法完成浅复制。</p> 
<p style="margin-left:42pt;text-align:left;"></p> 
<p> </p> 
<pre><code class="language-java">public class ShallowCopy {
    public static void main(String[] args) {
        Age a = new Age(18);
        Student stu1 = new Student("宁采臣",a,174);

        //通过调用重写后的clone方法进行浅拷贝
        Student stu2 =(Student)stu1.clone();
        System.out.println(stu1.toString());
        System.out.println(stu2.toString());

        //尝试修改stu1中的各属性，观察stu2的属性有没有变化
        stu1.setName("聂小倩");
        //修改age这个引用类型的成员变量的值
        a.setAge(20);
        //stu1.setaAge（new Age（20））;使用这种方式修改age属性值的话，stu2是不会跟着改变的。因为创建了一个新的Age类对象而不是改变原对象的实例值
        stu1.setLength(158);
        System.out.println(stu1.toString());
        System.out.println(stu2.toString());
    }
}

/*
*创建年龄类
*/
class Age{
    //年龄类的成员变量（属性）
    private int age;
    //构造方法
    public Age(int age){
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return this.age+"";
    }
}

/*
*创建学生类
*/
class Student implements Cloneable{
    //学生类的成员变量（属性），其中一个属性为类的对象
    private String name;
    private Age aage;
    private int length;
    //构造方法，其中一个参数为另一个类的对象
    public Student(String name,Age a,int length){
        this.name = name;
        this.aage = a;
        this.length = length;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Age getAge() {
        return aage;
    }

    public void setAge(Age age) {
        this.aage = age;
    }

    public int getLength() {
        return length;
    }

    public void setLength(int length) {
        this.length = length;
    }

    //设置输出的字符串形式

    @Override
    public String toString() {
        return "姓名是:"+this.getName()+",年龄为:"+this.getAge().toString()+",长度是："+this.getLength();
    }

    //重写Object类的clone方法
    public Object clone(){
        Object obj = null;
        try {
            obj = super.clone();
        } catch (CloneNotSupportedException e){
            e.printStackTrace();
        }
        return obj;
    }
}
</code></pre> 
<p> <img alt="" height="244" src="https://images2.imgbox.com/77/a5/USZu9eQh_o.png" width="554"></p> 
<p> <img alt="" height="203" src="https://images2.imgbox.com/21/74/dcxOY28d_o.png" width="374"></p> 
<p> <img alt="" height="91" src="https://images2.imgbox.com/44/68/wxIjSYxz_o.png" width="273"></p> 
<p> 分析结果可以验证：</p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#333333;">        基本数据类型是值传递，所以修改值后不会影响另一个对象的该属性值；</span></span></span><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#333333;">引用数据类型是地址传递（引用传递），所以修改值后另一个对象的该属性值会同步被修改。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#333333;">        String类型非常特殊，所以额外设置了一个字符串类型的成员变量来进行说明。首先，String类型属于引用数据类型，不属于基本数据类型，但是String类型的数据是存放在常量池中的，也就是无法修改的！也就是说，当将name属性从“宁采臣</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">”改为“</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">聂小倩</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">"后，并不是修改了这个数据的值，而是把这个数据的引用从指向”</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">宁采臣</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">“这个常量改为了指向”</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">聂小倩</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">“这个常量。在这种情况下，另一个对象的name属性值仍然指向”</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">宁采臣</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">“不会受到影响。</span></span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#333333;">参考链接：</span></span></span><a href="https://www.cnblogs.com/shakinghead/p/7651502.html" rel="nofollow" title="Java 浅拷贝和深拷贝的理解和实现方式 - 摇头耶稣 - 博客园 (cnblogs.com)">Java 浅拷贝和深拷贝的理解和实现方式 - 摇头耶稣 - 博客园 (cnblogs.com)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/428f7c6a553e95fb2e97167e63a42fb1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CCF小明放学（满分代码 &#43; 解题思路 &#43; 技巧总结） 201812-2</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f948418099d3e2dfcf8f3c11d055b5a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux学习笔记-6.5和CentOS7和CentOs8</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>