<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式之单例模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式之单例模式" />
<meta property="og:description" content="单例模式 独生子女饿汉模式懒汉模式懒汉模式类的定义线程安全问题双重检查锁定的问题静态局部对象 创建一个任务队列 在一个项目中，全局范围内，某个类的实例有且仅有一个，通过这个唯一实例向其他模块提供数据的全局访问，这种模式就叫单例模式。单例模式的典型应用就是任务队列。 独生子女 如果使用单例模式，首先要保证这个类的实例有且仅有一个，也就是说这个对象是独生子女，如果我们实施计划生育只生一个孩子，不需要也不能给再他增加兄弟姐妹。因此，就必须采取一系列的防护措施。对于类来说以上描述同样适用。涉及一个类多对象操作的函数有以下几个：
构造函数：创建一个新的对象拷贝构造函数：根据已有对象拷贝出一个新的对象拷贝赋值操作符重载函数：两个对象之间的赋值 为了把一个类可以实例化多个对象的路堵死，可以做如下处理：
构造函数私有化，在类内部只调用一次，这个是可控的。
由于使用者在类外部不能使用构造函数，所以在类内部创建的这个唯一的对象必须是静态的，这样就可以通过类名来访问了，为了不破坏类的封装，我们都会把这个静态对象的访问权限设置为私有的。
在类中只有它的静态成员函数才能访问其静态成员变量，所以可以给这个单例类提供一个静态函数用于得到这个静态的单例对象。
拷贝构造函数私有化或者禁用（使用 = delete）
拷贝赋值操作符重载函数私有化或者禁用（从单例的语义上讲这个函数已经毫无意义，所以在类中不再提供这样一个函数，故将它也一并处理一下。）
由于单例模式就是给类创建一个唯一的实例对象，所以它的UML类图是很简单的：
因此，定义一个单例模式的类的示例代码如下：
// 定义一个单例模式的类 class Singleton { public: // = delete 代表函数禁用, 也可以将其访问权限设置为私有 Singleton(const Singleton&amp; obj) = delete; Singleton&amp; operator=(const Singleton&amp; obj) = delete; static Singleton* getInstance(); private: Singleton() = default; static Singleton* m_obj; }; 在实现一个单例模式的类的时候，有两种处理模式：
饿汉模式懒汉模式 饿汉模式 饿汉模式就是在类加载的时候立刻进行实例化，这样就得到了一个唯一的可用对象。关于这个饿汉模式的类的定义如下:
// 饿汉模式 class TaskQueue { public: // = delete 代表函数禁用, 也可以将其访问权限设置为私有 TaskQueue(const TaskQueue&amp; obj) = delete; TaskQueue&amp; operator=(const TaskQueue&amp; obj) = delete; static TaskQueue* getInstance() { return m_taskQ; } private: TaskQueue() = default; static TaskQueue* m_taskQ; }; // 静态成员初始化放到类外部处理 TaskQueue* TaskQueue::m_taskQ = new TaskQueue; int main() { TaskQueue* obj = TaskQueue::getInstance(); } 在第17行，定义这个单例类的时候，就把这个静态的单例对象创建出来了。当使用者通过getInstance()获取这个单例对象的时候，它已经被准备好了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/92bfa66d456973e39709047c99758588/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-30T14:55:50+08:00" />
<meta property="article:modified_time" content="2023-10-30T14:55:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式之单例模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>单例模式</h4> 
 <ul><li><a href="#_2" rel="nofollow">独生子女</a></li><li><a href="#_44" rel="nofollow">饿汉模式</a></li><li><a href="#_76" rel="nofollow">懒汉模式</a></li><li><ul><li><a href="#_78" rel="nofollow">懒汉模式类的定义</a></li><li><a href="#_107" rel="nofollow">线程安全问题</a></li><li><a href="#_171" rel="nofollow">双重检查锁定的问题</a></li><li><a href="#_258" rel="nofollow">静态局部对象</a></li></ul> 
  </li><li><a href="#_297" rel="nofollow">创建一个任务队列</a></li></ul> 
</div> 
<br> 在一个项目中，全局范围内，某个类的实例有且仅有一个，通过这个唯一实例向其他模块提供数据的全局访问，这种模式就叫单例模式。单例模式的典型应用就是任务队列。 
<p></p> 
<h2><a id="_2"></a>独生子女</h2> 
<p>如果使用单例模式，首先要保证这个类的实例有且仅有一个，也就是说这个对象是独生子女，如果我们实施计划生育只生一个孩子，不需要也不能给再他增加兄弟姐妹。因此，就必须采取一系列的防护措施。对于类来说以上描述同样适用。涉及一个类多对象操作的函数有以下几个：</p> 
<ul><li>构造函数：创建一个新的对象</li><li>拷贝构造函数：根据已有对象拷贝出一个新的对象</li><li>拷贝赋值操作符重载函数：两个对象之间的赋值</li></ul> 
<p>为了把一个类可以实例化多个对象的路堵死，可以做如下处理：</p> 
<p>构造函数私有化，在类内部只调用一次，这个是可控的。</p> 
<p>由于使用者在类外部不能使用构造函数，所以在类内部创建的这个唯一的对象必须是<mark>静态的</mark>，这样就可以通过类名来访问了，为了不破坏类的封装，我们都会把这个静态对象的访问权限设置为<mark>私有的</mark>。<br> <strong>在类中只有它的静态成员函数才能访问其静态成员变量，所以可以给这个单例类提供一个静态函数用于得到这个静态的单例对象。</strong><br> 拷贝构造函数私有化或者禁用（使用 = delete）</p> 
<p>拷贝赋值操作符重载函数私有化或者禁用（从单例的语义上讲这个函数已经毫无意义，所以在类中不再提供这样一个函数，故将它也一并处理一下。）</p> 
<p>由于单例模式就是给类创建一个唯一的实例对象，所以它的UML类图是很简单的：<br> <img src="https://images2.imgbox.com/cf/c5/PsHYvrBk_o.png" alt="在这里插入图片描述"><br> 因此，定义一个单例模式的类的示例代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 定义一个单例模式的类</span>
<span class="token keyword">class</span> <span class="token class-name">Singleton</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    Singleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> m_obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> 
<p>在实现一个单例模式的类的时候，有两种处理模式：</p> 
<ul><li>饿汉模式</li><li>懒汉模式</li></ul> 
<h2><a id="_44"></a>饿汉模式</h2> 
<p>饿汉模式就是在类加载的时候立刻进行实例化，这样就得到了一个唯一的可用对象。关于这个饿汉模式的类的定义如下:</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 饿汉模式</span>
<span class="token keyword">class</span> <span class="token class-name">TaskQueue</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    TaskQueue<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> TaskQueue<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> m_taskQ<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> TaskQueue<span class="token operator">*</span> m_taskQ<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 静态成员初始化放到类外部处理</span>
TaskQueue<span class="token operator">*</span> TaskQueue<span class="token double-colon punctuation">::</span>m_taskQ <span class="token operator">=</span> <span class="token keyword">new</span> TaskQueue<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    TaskQueue<span class="token operator">*</span> obj <span class="token operator">=</span> <span class="token class-name">TaskQueue</span><span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>在第17行，定义这个单例类的时候，就把这个静态的单例对象创建出来了。当使用者通过getInstance()获取这个单例对象的时候，它已经被准备好了。</p> 
<p><strong>注意事项：类的静态成员变量在使用之前必须在类的外部进行初始化才能使用。</strong></p> 
<h2><a id="_76"></a>懒汉模式</h2> 
<p>懒汉模式是在类加载的时候不去创建这个唯一的实例，而是在需要使用的时候再进行实例化。</p> 
<h3><a id="_78"></a>懒汉模式类的定义</h3> 
<pre><code class="prism language-cpp"><span class="token comment">// 懒汉模式</span>
<span class="token keyword">class</span> <span class="token class-name">TaskQueue</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    TaskQueue<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> TaskQueue<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>m_taskQ <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            m_taskQ <span class="token operator">=</span> <span class="token keyword">new</span> TaskQueue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> m_taskQ<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> TaskQueue<span class="token operator">*</span> m_taskQ<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
TaskQueue<span class="token operator">*</span> TaskQueue<span class="token double-colon punctuation">::</span>m_taskQ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

</code></pre> 
<p>在调用getInstance()函数获取单例对象的时候，如果在单线程情况下是没有什么问题的，如果是多个线程，调用这个函数去访问单例对象就有问题了。假设有三个线程同时执行了getInstance()函数，在这个函数内部每个线程都会new出一个实例对象。此时，这个任务队列类的实例对象不是一个而是3个，很显然这与单例模式的定义是相悖的。</p> 
<h3><a id="_107"></a>线程安全问题</h3> 
<p>双重检查锁定<br> 对于饿汉模式是没有线程安全问题的，在这种模式下访问单例对象的时候，这个对象已经被创建出来了。要解决懒汉模式的线程安全问题，最常用的解决方案就是使用互斥锁。可以将创建单例对象的代码使用互斥锁锁住，处理代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">TaskQueue</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    TaskQueue<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> TaskQueue<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        m_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_taskQ <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            m_taskQ <span class="token operator">=</span> <span class="token keyword">new</span> TaskQueue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        m_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> m_taskQ<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> TaskQueue<span class="token operator">*</span> m_taskQ<span class="token punctuation">;</span>
    <span class="token keyword">static</span> mutex m_mutex<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
TaskQueue<span class="token operator">*</span> TaskQueue<span class="token double-colon punctuation">::</span>m_taskQ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
mutex TaskQueue<span class="token double-colon punctuation">::</span>m_mutex<span class="token punctuation">;</span>

</code></pre> 
<p>在上面代码的10~13 行这个代码块被互斥锁锁住了，也就意味着不论有多少个线程，同时执行这个代码块的线程只能是一个（相当于是严重限行了，在重负载情况下，可能导致响应缓慢）。我们可以将代码再优化一下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">TaskQueue</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    TaskQueue<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> TaskQueue<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_taskQ <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            m_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>m_taskQ <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                m_taskQ <span class="token operator">=</span> <span class="token keyword">new</span> TaskQueue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            m_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> m_taskQ<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> TaskQueue<span class="token operator">*</span> m_taskQ<span class="token punctuation">;</span>
    <span class="token keyword">static</span> mutex m_mutex<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
TaskQueue<span class="token operator">*</span> TaskQueue<span class="token double-colon punctuation">::</span>m_taskQ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
mutex TaskQueue<span class="token double-colon punctuation">::</span>m_mutex<span class="token punctuation">;</span>

</code></pre> 
<p>改进的思路就是在加锁、解锁的代码块外层有添加了一个if判断（第9行），这样当任务队列的实例被创建出来之后，访问这个对象的线程就不会再执行加锁和解锁操作了（只要有了单例类的实例对象，限行就解除了），对于第一次创建单例对象的时候线程之间还是具有竞争关系，被互斥锁阻塞。上面这种通过两个嵌套的 if 来判断单例对象是否为空的操作就叫做双重检查锁定。</p> 
<h3><a id="_171"></a>双重检查锁定的问题</h3> 
<p>假设有两个线程A、B，当线程A 执行到第 8 行时在线程A中 TaskQueue 实例对象 被创建，并赋值给 m_taskQ。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">static</span> TaskQueue<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>m_taskQ <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        m_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_taskQ <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            m_taskQ <span class="token operator">=</span> <span class="token keyword">new</span> TaskQueue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        m_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> m_taskQ<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>但是实际上 m_taskQ = new TaskQueue; 在执行过程中对应的机器指令可能会被重新排序。正常过程如下：</p> 
<p>第一步：分配内存用于保存 TaskQueue 对象。</p> 
<p>第二步：在分配的内存中构造一个 TaskQueue 对象（初始化内存）。</p> 
<p>第三步：使用 m_taskQ 指针指向分配的内存。</p> 
<p>但是被重新排序以后执行顺序可能会变成这样：</p> 
<p>第一步：分配内存用于保存 TaskQueue 对象。</p> 
<p>第二步：使用 m_taskQ 指针指向分配的内存。</p> 
<p>第三步：在分配的内存中构造一个 TaskQueue 对象（初始化内存）。</p> 
<p>这样重排序并不影响单线程的执行结果，但是在多线程中就会出问题。如果线程A按照第二种顺序执行机器指令，执行完前两步之后失去CPU时间片被挂起了，此时线程B在第3行处进行指针判断的时候m_taskQ 指针是不为空的，但这个指针指向的内存却没有被初始化，最后线程 B 使用了一个没有被初始化的队列对象就出问题了（出现这种情况是概率问题，需要反复的大量测试问题才可能会出现）。</p> 
<p>在C++11中引入了原子变量atomic，通过原子变量可以实现一种更安全的懒汉模式的单例，代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">TaskQueue</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    TaskQueue<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> TaskQueue<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        TaskQueue<span class="token operator">*</span> queue <span class="token operator">=</span> m_taskQ<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// m_mutex.lock();  // 加锁: 方式1</span>
            lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 加锁: 方式2</span>
            queue <span class="token operator">=</span> m_taskQ<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                queue <span class="token operator">=</span> <span class="token keyword">new</span> TaskQueue<span class="token punctuation">;</span>
                m_taskQ<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// m_mutex.unlock();</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> queue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello, world!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> atomic<span class="token operator">&lt;</span>TaskQueue<span class="token operator">*</span><span class="token operator">&gt;</span> m_taskQ<span class="token punctuation">;</span>
    <span class="token keyword">static</span> mutex m_mutex<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
atomic<span class="token operator">&lt;</span>TaskQueue<span class="token operator">*</span><span class="token operator">&gt;</span> TaskQueue<span class="token double-colon punctuation">::</span>m_taskQ<span class="token punctuation">;</span>
mutex TaskQueue<span class="token double-colon punctuation">::</span>m_mutex<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    TaskQueue<span class="token operator">*</span> queue <span class="token operator">=</span> <span class="token class-name">TaskQueue</span><span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token operator">-&gt;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>上面代码中使用原子变量atomic的store() 方法来存储单例对象，使用load() 方法来加载单例对象。在原子变量中这两个函数在处理指令的时候默认的原子顺序是memory_order_seq_cst（顺序原子操作 - sequentially consistent），使用顺序约束原子操作库，整个函数执行都将保证顺序执行，并且不会出现数据竞态（data races），不足之处就是使用这种方法实现的懒汉模式的单例执行效率更低一些。</p> 
<h3><a id="_258"></a>静态局部对象</h3> 
<p>在实现懒汉模式的单例的时候，相较于双重检查锁定模式有一种更简单的实现方法并且不会出现线程安全问题，那就是使用静态局部局部对象，对应的代码实现如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">TaskQueue</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    TaskQueue<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> TaskQueue<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> TaskQueue taskQ<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>taskQ<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello, world!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    TaskQueue<span class="token operator">*</span> queue <span class="token operator">=</span> <span class="token class-name">TaskQueue</span><span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token operator">-&gt;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在程序的第 9、10 行定义了一个静态局部队列对象，并且将这个对象作为了唯一的单例实例。使用这种方式之所以是线程安全的，是因为在C++11标准中有如下规定，并且这个操作是在编译时由编译器保证的：</p> 
<p>如果指令逻辑进入一个未被初始化的声明变量，所有并发执行应当等待该变量完成初始化。</p> 
<p><strong>最后总结一下懒汉模式和饿汉模式的区别：</strong></p> 
<p><strong>懒汉模式的缺点是在创建实例对象的时候有安全问题，但这样可以减少内存的浪费（如果用不到就不去申请内存了）。饿汉模式则相反，在我们不需要这个实例对象的时候，它已经被创建出来，占用了一块内存。对于现在的计算机而言，内存容量都是足够大的，这个缺陷可以被无视。</strong></p> 
<h2><a id="_297"></a>创建一个任务队列</h2> 
<p>作为程序猿的我们，设计一个单例模式的任务队列，那么就需要赋予这个类一些属性和方法：</p> 
<p>属性：<br> 存储任务的容器，这个容器可以选择使用STL中的队列（queue)<br> 互斥锁，多线程访问的时候用于保护任务队列中的数据<br> 方法：主要是对任务队列中的任务进行操作</p> 
<ul><li>任务队列中任务是否为空</li><li>往任务队列中添加一个任务</li><li>从任务队列中取出一个任务</li><li>从任务队列中删除一个任务</li></ul> 
<p>根据分析，就可以把这个饿汉模式的任务队列的单例类定义出来了：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TaskQueue</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    TaskQueue<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> TaskQueue<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> TaskQueue<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>m_obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 任务队列是否为空</span>
    <span class="token keyword">bool</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">bool</span> flag <span class="token operator">=</span> m_taskQ<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> flag<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 添加任务</span>
    <span class="token keyword">void</span> <span class="token function">addTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        m_taskQ<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 取出一个任务</span>
    <span class="token keyword">int</span> <span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_taskQ<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> m_taskQ<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 删除一个任务</span>
    <span class="token keyword">bool</span> <span class="token function">popTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_taskQ<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            m_taskQ<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">TaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> TaskQueue m_obj<span class="token punctuation">;</span>
    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> m_taskQ<span class="token punctuation">;</span>
    mutex m_mutex<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
TaskQueue TaskQueue<span class="token double-colon punctuation">::</span>m_obj<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        TaskQueue<span class="token operator">*</span> taskQ <span class="token operator">=</span> <span class="token class-name">TaskQueue</span><span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            taskQ<span class="token operator">-&gt;</span><span class="token function">addTask</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"+++push task: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">+</span> <span class="token number">100</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", threadID: "</span> 
                <span class="token operator">&lt;&lt;</span> this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread <span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        TaskQueue<span class="token operator">*</span> taskQ <span class="token operator">=</span> <span class="token class-name">TaskQueue</span><span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>taskQ<span class="token operator">-&gt;</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> data <span class="token operator">=</span> taskQ<span class="token operator">-&gt;</span><span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---take task: "</span> <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> <span class="token string">", threadID: "</span> 
                <span class="token operator">&lt;&lt;</span> this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            taskQ<span class="token operator">-&gt;</span><span class="token function">popTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>在上面的程序中有以下几点需要说明一下：</p> 
<p>正常情况下，任务队列中的任务应该是一个函数指针（这个指针指向的函数中有需要执行的任务动作），此处进行了简化，用一个整形数代替了任务队列中的任务。</p> 
<p>任务队列中的互斥锁保护的是单例对象的中的数据也就是任务队列中的数据，上面所说的线程安全指的是在创建单例对象的时候要保证这个对象只被创建一次，和此处完全是两码事儿，需要区别看待。</p> 
<p>在main()函数中创建了两个子线程</p> 
<p>t1线程的处理动作是往任务队列中添加任务，t2线程的处理动作是从任务队列中取任务，为了保证能够取出所有的任务，此处需要让t2线程的执行晚并且慢一些。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/633344bed4c9e672d8e19e987726edcb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【计算机网络】IP地址和子网掩码的关系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2bc3952433103236c5b1bcbf0aa94479/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python123：高空坠球、换硬币、猜数字游戏（C语言）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>