<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Lombok--使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Lombok--使用" />
<meta property="og:description" content="原文网址：Lombok--使用_IT利刃出鞘的博客-CSDN博客
简介 说明
本文介绍Lombok。
官网
Project Lombok
https://github.com/rzwitserloot/lombok
Lombok简介 Automatic Resource Management, automatic generation of getters, setters, equals, hashCode and toString, and more!
在项目使用了Lombok的情况下，安装lombok插件可以保证开发时的代码提示和代码检查的正常。
Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。Lombok能通过注解的方式，在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法。在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。
当修改/增加属性时，往往需要修改toString()，getter/setter等，容易遗漏。Lombok可以自动生成。
Lombok实现原理
自从Java 6起，javac就支持“JSR 269 Pluggable Annotation Processing API”规范，只要程序实现了该API，就能在javac运行的时候得到调用。
Lombok就是一个实现了&#34;JSR 269 API&#34;的程序。在使用javac的过程中，它产生作用的具体流程如下：
1. javac对源代码进行分析，生成一棵抽象语法树(AST)
2. javac编译过程中调用实现了JSR 269的Lombok程序
3. 此时Lombok就对第一步骤得到的AST进行处理，找到Lombok注解所在类对应的语法树 (AST)，然后修改该语法树(AST)，增加Lombok注解定义的相应树节点
4. javac使用修改后的抽象语法树(AST)生成字节码文件
插件安装 1.引入依赖
maven：
&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; grable：
其他网址：lombok官网（gradle部分）
法1：非插件法
dependencies { compileOnly &#39;org.projectlombok:lombok:1.18.12&#39; annotationProcessor &#39;org.projectlombok:lombok:1.18.12&#39; testCompileOnly &#39;org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cdace39cada60dc034814e5fc5cacf8f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-25T10:48:14+08:00" />
<meta property="article:modified_time" content="2023-02-25T10:48:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Lombok--使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>原文网址：<a href="https://knife.blog.csdn.net/article/details/106725810" rel="nofollow" title="Lombok--使用_IT利刃出鞘的博客-CSDN博客">Lombok--使用_IT利刃出鞘的博客-CSDN博客</a></p> 
<h2><strong>简介</strong></h2> 
<p><strong>说明</strong></p> 
<p>本文介绍Lombok。</p> 
<p><strong>官网</strong></p> 
<p><a href="https://www.projectlombok.org/features/all" rel="nofollow" title="Project Lombok">Project Lombok</a><br><a href="https://github.com/rzwitserloot/lombok" title="https://github.com/rzwitserloot/lombok">https://github.com/rzwitserloot/lombok</a></p> 
<h2><strong>Lombok简介</strong></h2> 
<p>        Automatic Resource Management, automatic generation of getters, setters, equals, hashCode and toString, and more!</p> 
<p>        在项目使用了Lombok的情况下，安装lombok插件可以保证开发时的代码提示和代码检查的正常。</p> 
<p>        Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。Lombok能通过注解的方式，在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法。在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。</p> 
<p>        当修改/增加属性时，往往需要修改toString()，getter/setter等，容易遗漏。Lombok可以自动生成。</p> 
<p><strong>Lombok实现原理</strong></p> 
<p>        自从Java 6起，javac就支持“JSR 269 Pluggable Annotation Processing API”规范，只要程序实现了该API，就能在javac运行的时候得到调用。</p> 
<p>Lombok就是一个实现了"JSR 269 API"的程序。在使用javac的过程中，它产生作用的具体流程如下：</p> 
<p>1. javac对源代码进行分析，生成一棵抽象语法树(AST)</p> 
<p>2. javac编译过程中调用实现了JSR 269的Lombok程序</p> 
<p>3. 此时Lombok就对第一步骤得到的AST进行处理，找到Lombok注解所在类对应的语法树       (AST)，然后修改该语法树(AST)，增加Lombok注解定义的相应树节点</p> 
<p>4. javac使用修改后的抽象语法树(AST)生成字节码文件</p> 
<h2>插件安装</h2> 
<p><strong>1.引入依赖</strong></p> 
<p>maven：</p> 
<pre><code class="language-html">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.2&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</code></pre> 
<p>grable：</p> 
<p>其他网址：<a href="https://projectlombok.org/setup/gradle" rel="nofollow" title="lombok官网（gradle部分）">lombok官网（gradle部分）</a></p> 
<p>法1：非插件法</p> 
<pre><code class="language-java">dependencies {
	compileOnly 'org.projectlombok:lombok:1.18.12'
	annotationProcessor 'org.projectlombok:lombok:1.18.12'
	
	testCompileOnly 'org.projectlombok:lombok:1.18.12'
	testAnnotationProcessor 'org.projectlombok:lombok:1.18.12'
}</code></pre> 
<p>法2：插件法</p> 
<pre><code class="language-java">plugins {
  id("io.freefair.lombok") version "3.1.4"
}
</code></pre> 
<p><strong>2.IDE支持（本处以Idea为例）</strong></p> 
<p>File=&gt;Settings=&gt; Plugins=&gt; 搜索“Lombok”并安装</p> 
<p>File=&gt;Settings=&gt; Build,Execution,Deployment=&gt; Compiler=&gt; AnnocationProcessors=&gt; 选中模块<br>         =&gt; Enable annocation processor</p> 
<h2>用法简介</h2> 
<p>使用Lombok的注解，可以添加相应方法，自己有自定义的方法时同样有效。例如：</p> 
<pre><code class="language-java">package com.example;

@Data
public class User{
    private Long id;
    private String name;
    private Integer age;

    public User name(String name) {
        this.name = name;
        return this;
    }
}</code></pre> 
<p> 编译之后生成的文件</p> 
<pre><code class="language-java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package com.example;

public class User {
    private Long id;
    private String name;
    private Integer age;

    public User name(String name) {
        this.name = name;
        return this;
    }

    public User() {
    }

    public Long getId() {
        return this.id;
    }

    public String getName() {
        return this.name;
    }

    public Integer getAge() {
        return this.age;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public boolean equals(Object o) {
        if (o == this) {
            return true;
        } else if (!(o instanceof User)) {
            return false;
        } else {
            User other = (User)o;
            if (!other.canEqual(this)) {
                return false;
            } else {
                label47: {
                    Object this$id = this.getId();
                    Object other$id = other.getId();
                    if (this$id == null) {
                        if (other$id == null) {
                            break label47;
                        }
                    } else if (this$id.equals(other$id)) {
                        break label47;
                    }

                    return false;
                }

                Object this$name = this.getName();
                Object other$name = other.getName();
                if (this$name == null) {
                    if (other$name != null) {
                        return false;
                    }
                } else if (!this$name.equals(other$name)) {
                    return false;
                }

                Object this$age = this.getAge();
                Object other$age = other.getAge();
                if (this$age == null) {
                    if (other$age != null) {
                        return false;
                    }
                } else if (!this$age.equals(other$age)) {
                    return false;
                }

                return true;
            }
        }
    }

    protected boolean canEqual(Object other) {
        return other instanceof User;
    }

    public int hashCode() {
        int PRIME = true;
        int result = 1;
        Object $id = this.getId();
        int result = result * 59 + ($id == null ? 43 : $id.hashCode());
        Object $name = this.getName();
        result = result * 59 + ($name == null ? 43 : $name.hashCode());
        Object $age = this.getAge();
        result = result * 59 + ($age == null ? 43 : $age.hashCode());
        return result;
    }

    public String toString() {
        return "User(id=" + this.getId() + ", name=" + this.getName() + ", age=" + this.getAge() + ")";
    }
}
</code></pre> 
<p><strong>@Getter/@Setter</strong></p> 
<p>作用类上，生成所有成员变量的getter/setter方法；作用于成员变量上，生成该成员变量的getter/setter方法。可以设定访问权限及是否懒加载等。例：@Getter(AccessLevel.PROTECTED)也可写为@Getter(value=AccessLevel.PROTECTED)</p> 
<p><strong>@ToString</strong></p> 
<p>作用于类，覆盖默认的toString()方法，可以通过of属性限定显示某些字段，通过exclude属性排除某些字段。</p> 
<p><strong>@EqualsAndHashCode</strong></p> 
<p>作用于类，覆盖默认的equals和hashCode</p> 
<p><strong>@NonNull</strong></p> 
<p>主要作用于成员变量和参数中，标识不能为空，否则抛出空指针异常。</p> 
<p><strong>@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor</strong></p> 
<p>作用于类上，用于生成构造函数。</p> 
<p>有staticName、access等属性。staticName属性一旦设定，将采用静态方法的方式生成实例，access属性可以限定访问权限。用到单例模式，这时需要将构造器私有化，例如：@NoArgsConstructor(access = AccessLevel.PRIVATE)</p> 
<p>@NoArgsConstructor：生成无参构造器；</p> 
<p>@RequiredArgsConstructor：生成包含final和@NonNull注解的成员变量的构造器；</p> 
<p>@AllArgsConstructor：生成全参构造器</p> 
<p><strong>@Data</strong></p> 
<p>作用于类上，是以下注解的集合：@ToString @EqualsAndHashCode @Getter @Setter @RequiredArgsConstructor</p> 
<p><strong>@Builder</strong></p> 
<p>作用于类上，将类转变为建造者模式</p> 
<p><strong>@Log</strong></p> 
<p>作用于类上，生成日志变量。针对不同的日志实现产品，有不同的注解</p> 
<p><strong>@Cleanup</strong></p> 
<p>自动关闭资源，针对实现了java.io.Closeable接口的对象有效</p> 
<p><strong>@SneakyThrows</strong></p> 
<p>可以对受检异常进行捕捉并抛出</p> 
<h2>基础</h2> 
<h3>@Getter/@Setter</h3> 
<p>为字段生成Getter和Setter方法，可以注解到字段或者类上(注解在类上会为类中的所有字段生成Getter和Setter方法)，默认是public类型的，如果需要的话可以修改方法的访问级别。</p> 
<pre><code class="language-java">public class User {
    @Getter @Setter
    private Long id;

    @Getter(AccessLevel.PROTECTED)
    private String phone;

    private String password;
}
</code></pre> 
<p>编译后的代码：</p> 
<pre><code class="language-java">public class User {
    private Long id;
    private String phone;
    private String password;

    public User() {
    }

    public Long getId() {
        return this.id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    protected String getPhone() {
        return this.phone;
    }
}
</code></pre> 
<p>结果解释：</p> 
<p>id字段生成了Getter&amp;Setter,访问修饰符是<strong>public</strong>（默认的）<br> phone只生成了Getter方法，因为只使用了@Getter而没有使用@Setter, 并且访问修饰符是protected<br> password 上并没有注解，所以什么都不生成</p> 
<p>注意：Lombok中的注解一般都会包含一个无参构造函数注解@NoArgsConstructor(用于生成无参构造函数的) ，所以还会额外生成一个无参构造函数</p> 
<p>@Getter @Setter 注解在类上，表示为类中的所有字段生成Getter&amp;Setter方法。</p> 
<pre><code class="language-java">@Getter @Setter
public class User {
    private Long id;
    private String phone;
    private String password;
}
</code></pre> 
<pre><code class="language-java">public class User {
    private Long id;
    private String phone;
    private String password;

    public User() {
    }

    public Long getId() {
        return this.id;
    }

    public String getPhone() {
        return this.phone;
    }

    public String getPassword() {
        return this.password;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
</code></pre> 
<h3>@Data</h3> 
<p>@Data 包含了 @ToString、@EqualsAndHashCode、@Getter / @Setter和@RequiredArgsConstructor的功能。</p> 
<pre><code class="language-java">@Data
public class User {
    private Long id;
    private String phone;
    private Integer status;
}
</code></pre> 
<pre><code class="language-java">public class User {
    private Long id;
    private String phone;
    private Integer status;

    public User() {
    }

    public Long getId() {
        return this.id;
    }

    public String getPhone() {
        return this.phone;
    }

    public Integer getStatus() {
        return this.status;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public void setStatus(Integer status) {
        this.status = status;
    }

    public boolean equals(Object o) {
        if(o == this) {
            return true;
        } else if(!(o instanceof User)) {
            return false;
        } else {
            User other = (User)o;
            if(!other.canEqual(this)) {
                return false;
            } else {
                label47: {
                    Long this$id = this.getId();
                    Long other$id = other.getId();
                    if(this$id == null) {
                        if(other$id == null) {
                            break label47;
                        }
                    } else if(this$id.equals(other$id)) {
                        break label47;
                    }

                    return false;
                }

                String this$phone = this.getPhone();
                String other$phone = other.getPhone();
                if(this$phone == null) {
                    if(other$phone != null) {
                        return false;
                    }
                } else if(!this$phone.equals(other$phone)) {
                    return false;
                }

                Integer this$status = this.getStatus();
                Integer other$status = other.getStatus();
                if(this$status == null) {
                    if(other$status != null) {
                        return false;
                    }
                } else if(!this$status.equals(other$status)) {
                    return false;
                }

                return true;
            }
        }
    }

    protected boolean canEqual(Object other) {
        return other instanceof User;
    }

    public int hashCode() {
        boolean PRIME = true;
        byte result = 1;
        Long $id = this.getId();
        int result1 = result * 59 + ($id == null?43:$id.hashCode());
        String $phone = this.getPhone();
        result1 = result1 * 59 + ($phone == null?43:$phone.hashCode());
        Integer $status = this.getStatus();
        result1 = result1 * 59 + ($status == null?43:$status.hashCode());
        return result1;
    }

    public String toString() {
        return "User(id=" + this.getId() + ", phone=" + this.getPhone() + ", status=" + this.getStatus() + ")";
    }
}</code></pre> 
<h3>@Getter(lazy = true)</h3> 
<p>@Getter(lazy = true)<br> 标注字段为懒加载字段，懒加载字段在创建对象时不会进行初始化，而是在第一次访问的时候才会初始化，后面再次访问也不会重复初始化。</p> 
<pre><code class="language-java">public class User {

    private final List&lt;String&gt; cityList = getCityFromCache();

    private List&lt;String&gt; getCityFromCache() {
        System.out.println("get city from cache ...");
        return new ArrayList&lt;&gt;();
    }
}


public static void main(String[] args) {
     User user = new User();  // 初始化对象时会执行getCityFromCache()方法
}
</code></pre> 
<pre><code class="language-java">public class User {
    @Getter(lazy = true)
    private final List&lt;String&gt; cityList = getCityFromCache();

    private List&lt;String&gt; getCityFromCache() {
        System.out.println("get city from cache ...");
        return new ArrayList&lt;&gt;();
    }
}</code></pre> 
<pre><code class="language-java">public class User {
    private final AtomicReference&lt;Object&gt; cityList = new AtomicReference();

    public User() {
    }

    private List&lt;String&gt; getCityFromCache() {
        System.out.println("get city from cache ...");
        return new ArrayList();
    }

    public List&lt;String&gt; getCityList() {
        Object value = this.cityList.get();
        if(value == null) {
            AtomicReference var2 = this.cityList;
            synchronized(this.cityList) {
                value = this.cityList.get();
                if(value == null) {
                    List actualValue = this.getCityFromCache();
                    value = actualValue == null?this.cityList:actualValue;
                    this.cityList.set(value);
                }
            }
        }

        return (List)((List)(value == this.cityList?null:value));
    }
}
</code></pre> 
<p> @Getter(lazy = true)：为懒加载字段生成一个Getter方法</p> 
<pre><code class="language-java">public static void main(String[] args) {
    User user = new User();		// 创建对象时不会初始化懒加载的字段
    List&lt;String&gt; cityList = user.getCityList();  // 只有第一次访问属性时才会去初始化

    cityList = user.getCityList();	// 第二次就不会再次初始化了
}
</code></pre> 
<h3>@Value</h3> 
<p>@Value 将字段都变成不可变类型：使用final修饰， 同时还包含@ToString、@EqualsAndHashCode、@AllArgsConstructor 、@Getter(注意只有Getter没有Setter)</p> 
<pre><code class="language-java">@Value
public class User {
    private Long id;
    private String username;
}</code></pre> 
<pre><code class="language-java">public final class User {
    private final Long id;
    private final String username;

    public User(Long id, String username) {
        this.id = id;
        this.username = username;
    }

    public Long getId() {
        return this.id;
    }

    public String getUsername() {
        return this.username;
    }

    public boolean equals(Object o) {
        if(o == this) {
            return true;
        } else if(!(o instanceof User)) {
            return false;
        } else {
            User other = (User)o;
            Long this$id = this.getId();
            Long other$id = other.getId();
            if(this$id == null) {
                if(other$id != null) {
                    return false;
                }
            } else if(!this$id.equals(other$id)) {
                return false;
            }

            String this$username = this.getUsername();
            String other$username = other.getUsername();
            if(this$username == null) {
                if(other$username != null) {
                    return false;
                }
            } else if(!this$username.equals(other$username)) {
                return false;
            }

            return true;
        }
    }

    public int hashCode() {
        boolean PRIME = true;
        byte result = 1;
        Long $id = this.getId();
        int result1 = result * 59 + ($id == null?43:$id.hashCode());
        String $username = this.getUsername();
        result1 = result1 * 59 + ($username == null?43:$username.hashCode());
        return result1;
    }

    public String toString() {
        return "User(id=" + this.getId() + ", username=" + this.getUsername() + ")";
    }
}

</code></pre> 
<h3>@NonNull</h3> 
<p>lombok将为你生成一个null检查语句，可以用于字段、方法、方法参数。生成的检查是这样的：</p> 
<pre><code class="language-java">if (param == null) {
    throw new NullPointerException("param is marked @NonNull but is null"); 
}</code></pre> 
<ul><li>字段：生成整个方法或构造函数时生成null检查，例如通过@Data。</li><li>方法的参数：在该方法的顶部插入null检查。</li><li>构造函数：null检查将被插入到任何明确的this()或super()调用之后。</li></ul> 
<p>如果顶部已经有一个null检查，则不会产生额外的null检查。</p> 
<p>lombok写法</p> 
<pre><code class="language-java">import lombok.NonNull;

public class NonNullExample extends Something {
  private String name;
  
  public NonNullExample(@NonNull Person person) {
    super("Hello");
    this.name = person.getName();
  }
}</code></pre> 
<p>生成的代码</p> 
<pre><code class="language-java">import lombok.NonNull;

public class NonNullExample extends Something {
  private String name;
  
  public NonNullExample(@NonNull Person person) {
    super("Hello");
    if (person == null) {
      throw new NullPointerException("person is marked non-null but is null");
    }
    this.name = person.getName();
  }
}</code></pre> 
<h2>构造方法</h2> 
<h3>@NoArgsConstructor</h3> 
<p>        生成一个无参构造方法。 对于具有约束的字段（例如@NonNull字段），不会生成检查或分配，因此，正确初始化这些字段之前，这些约束无效。</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:240px;"><strong>注解</strong></td><td style="width:489px;"><strong>说明</strong></td></tr><tr><td style="width:240px;">@NoArgsConstructor(force = true)</td><td style="width:489px;">强制生成。当类中有final字段没有被初始化时，编译器会报错，此时可用force = true属性，会为没有初始化的final字段设置默认值 0 / false / null, 这样编译器就不会报错。</td></tr><tr><td style="width:240px;">@NoArgsConstructor(access = AccessLevel.PRIVATE)</td><td style="width:489px;">将构造器权限设为private。有时使用单例模式，需要将构造器私有化。</td></tr><tr><td style="width:240px;">@NoArgsConstructor(staticName = "xxx")</td><td style="width:489px;">生成静态的构造方法，原来的实例构造方法将会被私有（<code>private</code>），然后创建一个你指定名称的静态构造方法，并且是<code>public</code>的</td></tr></tbody></table> 
<p>@NoArgsConstructor</p> 
<pre><code class="language-java">@NoArgsConstructor
public class User {
    private String username;
    private String password;
}
// 编译后：
public class User {
    private String username;
    private String password;

    public User() { }
}
</code></pre> 
<p>@NoArgsConstructor(access = AccessLevel.PRIVATE) </p> 
<pre><code class="language-java">@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class User {
    private String username;
    private String password;
}
// 编译后：
public class User {
    private String username;
    private String password;

    private User() {
    }
}
</code></pre> 
<p>@NoArgsConstructor(force = true)</p> 
<pre><code class="language-java">@NoArgsConstructor(force = true)
public class User {
    private Long id;

    @NonNull
    private String phone;

    private final Integer age;
}
</code></pre> 
<pre><code class="language-java">public class User {
    private Long id;
    @NonNull
    private String phone;
    private final Integer age = null;

    public User() {
    }
}
</code></pre> 
<p> @NoArgsConstructor(staticName = "UserHa")</p> 
<pre><code class="language-java">@NoArgsConstructor(staticName = "UserHa")
public class User {
    private String username;
    private String password;
}
// 编译后：
public class User {
    private String username;
    private String password;

    private User() { }

    public static User UserHa() {
        return new User();
    }
}
</code></pre> 
<h3>@RequiredArgsConstructor</h3> 
<table align="center"><tbody><tr><td style="width:180pt;"> <p style="margin-left:.0001pt;text-align:left;"><strong><strong>注解</strong></strong></p> </td><td style="width:366.75pt;"> <p style="margin-left:.0001pt;text-align:left;"><strong><strong>说明</strong></strong></p> </td></tr><tr><td style="width:180pt;"> <p style="margin-left:.0001pt;text-align:left;">@RequiredArgsConstructor</p> </td><td style="width:366.75pt;"> <p style="margin-left:.0001pt;text-align:left;">生成静态的构造方法（public类型）</p> </td></tr><tr><td style="width:180pt;"> <p style="margin-left:.0001pt;text-align:left;">@RequiredArgsConstructor(staticName = "xxx")</p> </td><td style="width:366.75pt;"> <p style="margin-left:.0001pt;text-align:left;">生成静态的构造方法，原来的实例构造方法将会被私有（private），然后创建一个你指定名称的静态构造方法，并且是public的</p> </td></tr></tbody></table> 
<p>        为需要的字段生成构造方法（可能带参数也可能不带参数）。需要的字段包括：以final修饰的未经初始化的字段、以@NonNull注解的未经初始化的字段。</p> 
<pre><code class="language-java">@RequiredArgsConstructor
public class User {
    private Long id;

    @NonNull
    private String phone;

    @NotNull
    private Integer status = 0;

    private final Integer age;
    private final String country = "china";
}
</code></pre> 
<pre><code class="language-java">public class User {
    private Long id;
    @NonNull
    private String phone;
    @NotNull
    private Integer status = Integer.valueOf(0);
    private final Integer age;
    private final String country = "china";

    public User(@NonNull String phone, Integer age) {
        if(phone == null) {
            throw new NullPointerException("phone");
        } else {
            this.phone = phone;
            this.age = age;
        }
    }
}</code></pre> 
<h3>@AllArgsConstructor</h3> 
<table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:240px;"><strong>注解</strong></td><td style="width:489px;"><strong>说明</strong></td></tr><tr><td style="width:240px;">@AllArgsConstructor(access = AccessLevel.PRIVATE)</td><td style="width:489px;">将构造器权限设为private。</td></tr><tr><td style="width:240px;">@AllArgsConstructor(staticName = "xxx")</td><td style="width:489px;">生成静态的构造方法，原来的实例构造方法将会被私有（<code>private</code>），然后创建一个你指定名称的静态构造方法，并且是<code>public</code>的</td></tr></tbody></table> 
<p>生成一个全参数的构造方法，默认不提供无参构造。这里的全参不包括已初始化的final字段</p> 
<pre><code class="language-java">@AllArgsConstructor
public class User {
    private Long id;

    @NonNull
    private String phone;

    @NotNull
    private Integer status = 0;

    private final Integer age;
    private final String country = "china";
}
</code></pre> 
<pre><code class="language-java">public class User {
    private Long id;
    @NonNull
    private String phone;
    @NotNull
    private Integer status = Integer.valueOf(0);
    private final Integer age;
    private final String country = "china";

    public User(Long id, @NonNull String phone, Integer status, Integer age) {
        if(phone == null) {
            throw new NullPointerException("phone");
        } else {
            this.id = id;
            this.phone = phone;
            this.status = status;
            this.age = age;
        }
    }
}</code></pre> 
<h3><strong>@Builder</strong></h3> 
<p>@Builder：生成内部类和全字段的构造器。</p> 
<pre><code class="language-java">@Builder
public class User {
    private Long id;
    private String phone;

}
</code></pre> 
<pre><code class="language-java">public class User {
    private Long id;
    private String phone;

    User(Long id, String phone) {
        this.id = id;
        this.phone = phone;
    }

    public static User.UserBuilder builder() {
        return new User.UserBuilder();
    }

    public static class UserBuilder {
        private Long id;
        private String phone;

        UserBuilder() {
        }

        public User.UserBuilder id(Long id) {
            this.id = id;
            return this;
        }

        public User.UserBuilder phone(String phone) {
            this.phone = phone;
            return this;
        }

        public User build() {
            return new User(this.id, this.phone);
        }

        public String toString() {
            return "User.UserBuilder(id=" + this.id + ", phone=" + this.phone + ")";
        }
    }
}</code></pre> 
<h2>覆写Object类的方法</h2> 
<h3>@ToString</h3> 
<p>        生成toString()方法，默认情况下它会按顺序（以逗号分隔）打印你的类名称以及每个字段。可以这样设置不包含哪些字段,可以指定一个也可以指定多个@ToString(exclude = “id”) / @ToString(exclude = {“id”,“name”})<br> 如果继承的有父类的话，可以设置callSuper 让其调用父类的toString()方法，例如：@ToString(callSuper = true)</p> 
<pre><code class="language-java">@ToString(exclude = {"password", "salt"})
public class User {

    private Long id;

    private String phone;

    private String password;

    private String salt;
}</code></pre> 
<pre><code class="language-java">public class User {
    private Long id;
    private String phone;
    private String password;
    private String salt;

    public User() {
    }

    public String toString() {
        return "User(id=" + this.id + ", phone=" + this.phone + ")";
    }
}
</code></pre> 
<p></p> 
<pre><code class="language-java">@ToString(exclude = {"password", "salt"}, callSuper = true)
public class User {

    private Long id;

    private String phone;

    private String password;

    private String salt;
}
</code></pre> 
<pre><code class="language-java">public class User {
    private Long id;
    private String phone;
    private String password;
    private String salt;

    public User() {
    }

    public String toString() {
        return "User(super=" + super.toString() + ", id=" + this.id + ", phone=" + this.phone + ")";
    }
}</code></pre> 
<h3>@EqualsAndHashCode</h3> 
<p>生成hashCode()和equals()方法，默认情况下，它将使用所有非静态，非transient字段。但可以通过在可选的exclude参数中来排除更多字段。或者，通过在of参数中命名它们来准确指定希望使用哪些字段。</p> 
<p>// exclude 排除字段<br> @EqualsAndHashCode(exclude = {“password”, “salt”})</p> 
<p>// of 指定要包含的字段<br> @EqualsAndHashCode(of = {“id”, “phone”, “password”})</p> 
<pre><code class="language-java">@EqualsAndHashCode
public class User implements Serializable{

    private static final long serialVersionUID = 6569081236403751407L;

    private Long id;

    private String phone;

    private transient int status;
}
</code></pre> 
<pre><code class="language-java">public class User implements Serializable {
    private static final long serialVersionUID = 6569081236403751407L;
    private Long id;
    private String phone;
    private transient int status;

    public User() {
    }

    public boolean equals(Object o) {
        if(o == this) {
            return true;
        } else if(!(o instanceof User)) {
            return false;
        } else {
            User other = (User)o;
            if(!other.canEqual(this)) {
                return false;
            } else {
                Long this$id = this.id;
                Long other$id = other.id;
                if(this$id == null) {
                    if(other$id != null) {
                        return false;
                    }
                } else if(!this$id.equals(other$id)) {
                    return false;
                }

                String this$phone = this.phone;
                String other$phone = other.phone;
                if(this$phone == null) {
                    if(other$phone != null) {
                        return false;
                    }
                } else if(!this$phone.equals(other$phone)) {
                    return false;
                }

                return true;
            }
        }
    }

    protected boolean canEqual(Object other) {
        return other instanceof User;
    }

    public int hashCode() {
        boolean PRIME = true;
        byte result = 1;
        Long $id = this.id;
        int result1 = result * 59 + ($id == null?43:$id.hashCode());
        String $phone = this.phone;
        result1 = result1 * 59 + ($phone == null?43:$phone.hashCode());
        return result1;
    }
}</code></pre> 
<p>生成了 equals 、hashCode 和 canEqual 无参构造函数 四个方法。</p> 
<h2>常用</h2> 
<h3>日志</h3> 
<p>        生成log对象，用于记录日志，可以通过topic属性来设置getLogger(String name)方法的参数 例如 @Log4j(topic = “com.xxx.entity.User”)，默认是类的全限定名，即 类名.class，log支持以下几种：</p> 
<table align="center" style="width:375pt;"><tbody><tr><td> <p style="margin-left:.0001pt;text-align:left;"><strong>注解</strong></p> </td><td> <p style="margin-left:.0001pt;text-align:left;"><strong>对应包</strong></p> </td></tr><tr><td> <p style="margin-left:.0001pt;text-align:left;">@Log</p> </td><td> <p style="margin-left:.0001pt;text-align:left;">java.util.logging.Logger</p> </td></tr><tr><td> <p style="margin-left:.0001pt;text-align:left;">@Log4j</p> </td><td> <p style="margin-left:.0001pt;text-align:left;">org.apache.log4j.Logger</p> </td></tr><tr><td> <p style="margin-left:.0001pt;text-align:left;">@Log4j2</p> </td><td> <p style="margin-left:.0001pt;text-align:left;">org.apache.logging.log4j.Logger</p> </td></tr><tr><td> <p style="margin-left:.0001pt;text-align:left;">@Slf4j</p> </td><td> <p style="margin-left:.0001pt;text-align:left;">org.slf4j.Logger</p> </td></tr><tr><td> <p style="margin-left:.0001pt;text-align:left;">@XSlf4j</p> </td><td> <p style="margin-left:.0001pt;text-align:left;">org.slf4j.ext.XLogger</p> </td></tr><tr><td> <p style="margin-left:.0001pt;text-align:left;">@CommonsLog</p> </td><td> <p style="margin-left:.0001pt;text-align:left;">org.apache.commons.logging.Log</p> </td></tr><tr><td> <p style="margin-left:.0001pt;text-align:left;">@JBossLog</p> </td><td> <p style="margin-left:.0001pt;text-align:left;">org.jboss.logging.Logger</p> </td></tr></tbody></table> 
<pre><code class="language-java">@Log
 	private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());
@Log4j
	private static final Logger log = org.apache.log4j.Logger.Logger.getLogger(UserService.class);
@Log4j2
 	private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);
@Slf4j
 	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);
@XSlf4j
 	private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);
 @CommonsLog
	private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);
@JBossLog
 	private static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);
</code></pre> 
<pre><code class="language-java">@Log
public class UserService {

    public void addUser(){
        log.info("add user");
    }
}


import java.util.logging.Logger;

public class UserService {
    private static final Logger log = Logger.getLogger(UserService.class.getName());

    public UserService() {
    }
}
</code></pre> 
<h3>@Accessors</h3> 
<p>@Accessors：用于配置getter和setter方法的生成结果</p> 
<p><strong>chain</strong></p> 
<p>设置为true，则setter方法返回当前对象。</p> 
<pre><code class="language-java">@Data
@Accessors(chain = true)
public class User {
  private Long id;
  private String name;

  // 生成的setter方法如下，方法体略
  public User setId(Long id) {}
  public User setName(String name) {}
}</code></pre> 
<p><strong>fluent</strong></p> 
<p>fluent的中文含义是流畅的，设置为true，则getter和setter方法的方法名都是基础属性名，且setter方法返回当前对象。</p> 
<pre><code class="language-java">@Data
@Accessors(fluent = true)
public class User {
  private Long id;
  private String name;

  // 生成的getter和setter方法如下，方法体略
  public Long id() {}
  public User id(Long id) {}
  public String name() {}
  public User name(String name) {}
}</code></pre> 
<p><strong>prefix</strong></p> 
<p>用于生成getter和setter方法的字段名会忽视指定前缀（遵守驼峰命名）。</p> 
<pre><code class="language-java">@Data
@Accessors(prefix = "p")
class User {
  private Long pId;
  private String pName;

  // 生成的getter和setter方法如下，方法体略
  public Long getId() {}
  public void setId(Long id) {}
  public String getName() {}
  public void setName(String name) {}
}</code></pre> 
<h2>其他</h2> 
<h3>@SneakyThrows</h3> 
<p>使用try catch 来捕获异常, 默认捕获的是Throwable异常，也可以设置要捕获的异常</p> 
<pre><code class="language-java">public class User {

    @SneakyThrows
    public void sleep(){
        Thread.sleep(1000);
    }

    @SneakyThrows(InterruptedException.class)
    public void sleep2()  {
        Thread.sleep(1000);
    }
}

</code></pre> 
<pre><code class="language-java">public class User {
    public User() {
    }

    public void sleep() {
        try {
            Thread.sleep(1000L);
        } catch (Throwable var2) {
            throw var2;
        }
    }

    public void sleep2() {
        try {
            Thread.sleep(1000L);
        } catch (InterruptedException var2) {
            throw var2;
        }
    }

    public static void main(String[] args) {
    }
}</code></pre> 
<h3>@Synchronized</h3> 
<p>给方法加上同步锁</p> 
<pre><code class="language-java">public class User {
    private final Object readLock = new Object();

    @Synchronized
    public static void foo(){
        System.out.println();
    }

    @Synchronized
    public void bar(){
        System.out.println();
    }

    @Synchronized("readLock")
    public void test() {
        System.out.println();
    }
}
</code></pre> 
<pre><code class="language-java">public class User {
    private static final Object $LOCK = new Object[0];
    private final Object $lock = new Object[0];
    private final Object readLock = new Object();

    public User() {
    }

    public static void foo() {
        Object var0 = $LOCK;
        synchronized($LOCK) {
            System.out.println();
        }
    }

    public void bar() {
        Object var1 = this.$lock;
        synchronized(this.$lock) {
            System.out.println();
        }
    }

    public void test() {
        Object var1 = this.readLock;
        synchronized(this.readLock) {
            System.out.println();
        }
    }
}</code></pre> 
<h3>@Cleanup</h3> 
<p>主要用来修饰 IO 流相关类, 会在 finally 代码块中对该资源进行 close();</p> 
<pre><code class="language-java">public class CleanupExample {
  public static void main(String[] args) throws IOException {
    @Cleanup InputStream in = new FileInputStream(args[0]);
    @Cleanup OutputStream out = new FileOutputStream(args[1]);
    byte[] b = new byte[10000];
    while (true) {
      int r = in.read(b);
      if (r == -1) break;
      out.write(b, 0, r);
    }
  }
}
</code></pre> 
<pre><code class="language-java">public class CleanupExample {
  public static void main(String[] args) throws IOException {
    InputStream in = new FileInputStream(args[0]);
    try {
      OutputStream out = new FileOutputStream(args[1]);
      try {
        byte[] b = new byte[10000];
        while (true) {
          int r = in.read(b);
          if (r == -1) break;
          out.write(b, 0, r);
        }
      } finally {
        if (out != null) {
          out.close();
        }
      }
    } finally {
      if (in != null) {
        in.close();
      }
    }
  }
}</code></pre> 
<h3>@Wither</h3> 
<p>提供了给final字段赋值的一种方法</p> 
<pre><code class="language-java">public class User {
    @Wither
    private final String country;

    public User(String country) {
        this.country = country;
    }
}
</code></pre> 
<pre><code class="language-java">public class User {
    private final String country;

    public User(String country) {
        this.country = country;
    }

    public User withCountry(String country) {
        return this.country == country?this:new User(country);
    }
}</code></pre> 
<h3>@Delegate</h3> 
<p>为List类型的字段生成一大堆常用的方法，其实这些方法都是List中的方法<br> 注意：一个类中只能使用一个@Delegate注解，因为使用多个会生成多个size()方法，从而会编译报错。</p> 
<pre><code class="language-java">public class User {
    @Delegate
    private List&lt;String&gt; address;
}
</code></pre> 
<pre><code class="language-java">public class User {
    private List&lt;String&gt; address;

    public User() {
    }

    public int size() {
        return this.address.size();
    }

    public boolean isEmpty() {
        return this.address.isEmpty();
    }

    public boolean contains(Object arg0) {
        return this.address.contains(arg0);
    }

    public Iterator&lt;String&gt; iterator() {
        return this.address.iterator();
    }

    public Object[] toArray() {
        return this.address.toArray();
    }

    public &lt;T&gt; T[] toArray(T[] arg0) {
        return this.address.toArray(arg0);
    }

    public boolean add(String arg0) {
        return this.address.add(arg0);
    }

    public boolean remove(Object arg0) {
        return this.address.remove(arg0);
    }

    public boolean containsAll(Collection&lt;?&gt; arg0) {
        return this.address.containsAll(arg0);
    }

    public boolean addAll(Collection&lt;? extends String&gt; arg0) {
        return this.address.addAll(arg0);
    }

    public boolean addAll(int arg0, Collection&lt;? extends String&gt; arg1) {
        return this.address.addAll(arg0, arg1);
    }

    public boolean removeAll(Collection&lt;?&gt; arg0) {
        return this.address.removeAll(arg0);
    }

    public boolean retainAll(Collection&lt;?&gt; arg0) {
        return this.address.retainAll(arg0);
    }

    public void replaceAll(UnaryOperator&lt;String&gt; arg0) {
        this.address.replaceAll(arg0);
    }

    public void sort(Comparator&lt;? super String&gt; arg0) {
        this.address.sort(arg0);
    }

    public void clear() {
        this.address.clear();
    }

    public String get(int arg0) {
        return (String)this.address.get(arg0);
    }

    public String set(int arg0, String arg1) {
        return (String)this.address.set(arg0, arg1);
    }

    public void add(int arg0, String arg1) {
        this.address.add(arg0, arg1);
    }

    public String remove(int arg0) {
        return (String)this.address.remove(arg0);
    }

    public int indexOf(Object arg0) {
        return this.address.indexOf(arg0);
    }

    public int lastIndexOf(Object arg0) {
        return this.address.lastIndexOf(arg0);
    }

    public ListIterator&lt;String&gt; listIterator() {
        return this.address.listIterator();
    }

    public ListIterator&lt;String&gt; listIterator(int arg0) {
        return this.address.listIterator(arg0);
    }

    public List&lt;String&gt; subList(int arg0, int arg1) {
        return this.address.subList(arg0, arg1);
    }

    public Spliterator&lt;String&gt; spliterator() {
        return this.address.spliterator();
    }
}
</code></pre> 
<h2>lombok.config</h2> 
<p>lombok.config配置文件是通过一些设置来控制代码生成的规则或者称之为习惯，配置文件的位置应放在src/mian/java，不要放置在src/main/resources。</p> 
<p>注意配置文件和要使用注解的类要在同一套代码中，要么同时在src/main/java 要么同时在 src/test/java中</p> 
<p>lombok.config</p> 
<pre><code class="language-bash">#lombok 默认对boolean类型字段生成的get方法使用is前缀, 通过此配置则使用get前缀，默认: false
lombok.getter.noIsPrefix=true

#默认的set方法返回void设置为true返回调用对象本身，这样方便使用链式来继续调用方法，默认: false
lombok.accessors.chain=true

#如果设置为true  get和set方法将不带get,set前缀, 直接以字段名为方法名， 默认: false
lombok.accessors.fluent=true

#设置log类注解返回的字段名称，默认: log
lombok.log.fieldName=logger
</code></pre> 
<pre><code class="language-java">@Log4j
@Getter @Setter
public class User {
    private String username;
    private boolean vip;
    private boolean isOldUser;
}
</code></pre> 
<pre><code class="language-java">public class User {
    private static final Logger logger = Logger.getLogger(User.class);
    private String username;
    private boolean vip;
    private boolean isOldUser;

    public User() {
    }

    public String username() {
        return this.username;
    }

    public boolean vip() {
        return this.vip;
    }

    public boolean isOldUser() {
        return this.isOldUser;
    }

    public User username(String username) {
        this.username = username;
        return this;
    }

    public User vip(boolean vip) {
        this.vip = vip;
        return this;
    }

    public User isOldUser(boolean isOldUser) {
        this.isOldUser = isOldUser;
        return this;
    }
}

</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a376a18b17320f7b949055aad957cee7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言 格式化占位符的语法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f393aebce8c0664ad1fe4da555c5958/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言常见函数返回值类型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>