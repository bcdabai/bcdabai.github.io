<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Three.js typescript definitely typed 文件 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Three.js typescript definitely typed 文件" />
<meta property="og:description" content="最近学习three.js,想用typescript编写代码,去http://definitelytyped.org/找了一圈没有发现three.js的definitely typed文件.
好吧,花了2天时间自己简单写了一份:
declare module THREE { export class BoxHelper extends Line { constructor(object: Object3D); public update(object: Object3D); } export class DrawTextResult { public paths: any[]; public offset: number; } export class FontUtils { public static divisions: number; public static style: string; public static weight: string; public static face: string; public static faces: any; public static size: number; public static drawText(text: string): DrawTextResult; public static Triangulate(contour: Vector2[], indices: boolean): any[]; public static extractGlyphPoints(c: string, face: string, scale: number, offset: number, path: Path); } export class Curve { constructor(); public getPoint(t: number): any; public getPointAt(u: number): any; public getPoints(divisions: number[]): any[]; public getSpacedPoints(divisions: number): any[]; public getLength(): number; public getLengths(divisions: number): number[]; public updateArcLengths(): void; public getTangent(t: number): any; public getTangentAt(u: number): any; } export class CurvePath extends Curve { constructor(); public curves: Curve[]; public bends: Curve[]; public autoClose: boolean; public getWrapPoints(vertices: Vector2[], curve: Curve[]):Vector2[]; public addWrapPath(curve: Curve): void; public createGeometry(points: Vector3[]): Geometry; public createPointsGeometry(divisions: number): Geometry; public createSpacedPointsGeometry(divisions: number): Geometry; public add(curve: Curve): void; public closePath(): void; public getBoundingBox(): any; public getCurveLengths(): number; public getTransformedPoints(segments: number, bends?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3e3ec4b6e13723146dcdc9e40b486655/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-01-27T23:30:00+08:00" />
<meta property="article:modified_time" content="2016-01-27T23:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Three.js typescript definitely typed 文件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>最近学习three.js,想用typescript编写代码,去http://definitelytyped.org/找了一圈没有发现three.js的definitely typed文件.</p> 
 <p>好吧,花了2天时间自己简单写了一份:</p> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="language-javascript">declare module THREE {
    export class BoxHelper extends Line {
        constructor(object: Object3D);
        public update(object: Object3D);
    }
    export class DrawTextResult {
        public paths: any[];
        public offset: number;
    }
    export class FontUtils {
        public static divisions: number;
        public static style: string;
        public static weight: string;
        public static face: string;
        public static faces: any;
        public static size: number;
        public static drawText(text: string): DrawTextResult;
        public static Triangulate(contour: Vector2[], indices: boolean): any[];
        public static extractGlyphPoints(c: string, face: string, scale: number, offset: number, path: Path);
    }
    export class Curve {
        constructor();
        public getPoint(t: number): any;
        public getPointAt(u: number): any;
        public getPoints(divisions: number[]): any[];
        public getSpacedPoints(divisions: number): any[];
        public getLength(): number;
        public getLengths(divisions: number): number[];
        public updateArcLengths(): void;
        public getTangent(t: number): any;
        public getTangentAt(u: number): any;
    }
    export class CurvePath extends Curve {
        constructor();
        public curves: Curve[];
        public bends: Curve[];
        public autoClose: boolean;
        public getWrapPoints(vertices: Vector2[], curve: Curve[]):Vector2[];
        public addWrapPath(curve: Curve): void;
        public createGeometry(points: Vector3[]): Geometry;
        public createPointsGeometry(divisions: number): Geometry;
        public createSpacedPointsGeometry(divisions: number): Geometry;
        public add(curve: Curve): void;
        public closePath(): void;
        public getBoundingBox(): any;
        public getCurveLengths(): number;
        public getTransformedPoints(segments: number, bends?: Curve[]): Vector2[];

    }
    export class GeometryUtils {
        public static merge(geometry1: Geometry, geometry2: Geometry, materialIndexOffset: number);
        public static randomPointInTriangle(vectorA: Vector3, vectorB: Vector3, vectorC: Vector3): Vector3;
    }
    export class ImageUtils {
        public static crossOrigin: string;
        public static generateDataTexture(width: number, height: number, color: number): DataTexture;
        public static parseDDS(buffer: string, loadMipmpas: boolean): CompressedTexture;
        public static loadTexture(url: string, mapping?: number, onLoad?: (any) =&gt; any, onError?: (any) =&gt; any): Texture;
        public static getNormalMap(image: HTMLImageElement, depth: number): HTMLCanvasElement;
        public static loadTextureCube(array: any[], mapping: number, onLoad: (any) =&gt; any, onError: (any) =&gt; any): CubeTexture;

    }
    export class SceneUtils {
        public static createMultiMaterialObject(geometry: Geometry, materials: Material[]): Object3D;
        public static attach(child: Object3D, scene: Scene, parent: Object3D): void;
        public static detach(child: Object3D, scene: Scene,parent:Object3D): void;

    }
    export class Gyroscope extends Object3D {
        constructor();
    }
    export class Path extends CurvePath {
        constructor(points?: Vector2[]);
        public actions: any[];
        public fromPoints(vector2s: Vector2[]): void;
        public moveTo(x: number, y: number): void;
        public lineTo(x: number, y: number): void;
        public quadratiCurveTo(cpX: number, cpY: number, x: number, y: number): void;
        public bezierCurveTo(cp1X: number, cp1Y: number, cp2X: number, cp2Y: number, x: number,y: number): void;
        public splineThru(points: Vector2[]): void;
        public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, clockwise: boolean): void;
        public absarc(x: number, y: number, radius: number, startAngle: number, endAngle: number, clockwise: boolean): void;
        public ellipse(x: number, y: number, xRadius: number, yRadius: number, startAngle: number, endAngle: number, clockwise: boolean, rotation: number): void;
        public absellipse(x: number, y: number, xRadius: number, yRadius: number, startAngle: number, endAngle: number, clockwise: boolean, rotation: number): void;
        public toShapes(isCCW: boolean, noHoles: boolean): Shape[];
    }
    export class Shape extends Path {
        constructor();
        public holes: Path[];
        public makeGeometry(options: any): ShapeGeometry;
        public extractAllPoints(divisions: number): Vector3[];
        public extrude(options: any): ExtrudeGeometry;
        public extractPoints(divisions: number): any;
        public getPointsHoles(divisions: number): Vector2[] | Vector3[];
        public getSpacedPointsHoles(divisions: number): Vector2[] | Vector3[];
    }
    export class ShapeGeometry extends Geometry {
        constructor(shapes: Shape[], options?: any);
        public addShapeList(shapes: Shape[], options?: any): this;
        public addShape(shape: Shape, options?: any): void;
    }
    export class ExtrudeGeometry extends Geometry {
        constructor(shapes: Shape[]|Shape, options?: any);
        public addShapList(shapes: Shape[], options?: any): void;
        public addShape(shape: Shape, options?: any): void;
    }
    export class TextGeometry extends ExtrudeGeometry {
        constructor(text: string, parameters: any);
    }
    export class TorusGeometry extends Geometry {
        constructor(radius: number, tube: number, radialSegments: number, tubularSegments: number, arc: number);
    }
    export class TorusKnotGeometry extends Geometry {
        constructor(
            radius: number,
            tube: number,
            radialSegments: number,
            tubularSegments: number,
            p: number,
            q: number,
            heightScale: number
        );
    }
    export class TubeGeometry extends Geometry {
        constructor(path: Curve, segments: number, radius: number, radiusSegments: number, closed: boolean);
        public parameters: any;
        public tangents: Vector3[];
        public normals: Vector3[];
        public binormals: Vector3[];
        public static FrenetFrames(path: Curve, segments: number, closed: boolean): void;
    }
    export class Vector2 {
        constructor(x: number, y: number);
        public x: number;
        public y: number;
        public set(x: number, y: number): this;
        public copy(v: this): this;
        public add(v: this): this;
        public addVectors(a: this, b: this): this;
        public addScaledVector(v: this, s: number): this;
        public sub(v: this): this;
        public subVectors(a: this, b: this): this;
        public multiplyScalar(s: number): this;
        public divideScalar(s: number): this;
        public negate(): this;
        public dot(v: this): number;
        public lengthSq(): number;
        public length(): number;
        public lengthManhattan(): number;
        public normalize(): this;
        public distanceTo(v: this): number;
        public distanceToSquared(v: this): number;
        public setLength(l: number): this;
        public eqauls(v: this): boolean;
        public clone(): this;
        public clamp(min: this, max: this): this;
        public clampScalar(min: number, max: number): this;
        public floor(): this;
        public ceil(): this;
        public round(): this;
        public roundToZero(): this;
        public lerp(v: this, alpha: number): this;
        public lerpVectors(v1: this, v2: this, alpha: number): this;
        public setComponent(index: number, value: number);
        public addScalar(s: number): this;
        public getComponent(index: number): number;
        public fromArray(array: number[]): this;
        public toArray(array: number[]): number[];
        public min(v: this): this;
        public max(v: this): this;
        public setX(x: number): this;
        public setY(y: number): this;
    }
    export class Vector3 {
        constructor(x: number, y: number,z:number)
        public x: number
        public y: number
        public z:number
        public set(x: number, y: number,z:number): this
        public copy(v: this): this
        public add(v: this): this
        public addVectors(a: this, b: this): this
        public addScaledVector(v: this, s: number): this
        public sub(v: this): this
        public subVectors(a: this, b: this): this
        public multiplyScalar(s: number): this;
        public divideScalar(s: number): this;
        public negate(): this;
        public dot(v: this): number;
        public lengthSq(): number;
        public length(): number;
        public lengthManhattan(): number;
        public normalize(): this;
        public distanceTo(v: this): number;
        public distanceToSquared(v: this): number;
        public setLength(l: number): this;
        public cross(v: this): this;
        public crossVectors(a: Vector3, b: Vector3): this;
        public setFromMatrixPosition(m: Matrix4): this;
        public setFromMatrixScale(m: Matrix4): this;
        public equals(v: this): boolean;
        public clone(): this;
        public clamp(min: Vector3, max: Vector3): this;
        public clampScalar(min: number, max: number): this;
        public floor(): this;
        public ceil(): this;
        public round(): this;
        public roundToZero(): this;
        public applyMatrix3(m: Matrix3): this;
        public applyMatrix4(m: Matrix4): this;
        public projectOnPlane(planeNormal: this): this;
        public projectOnVector(vector: this): this;
        public addScalar(s: number): this;
        public divide(v: this): this;
        public min(v: this): this;
        public max(v: this): this;
        public setComponent(index: number, value: number): this;
        public transformDirection(m: Matrix4): this;
        public multiplyVectors(a: this, b: this): this;
        public getComponent(index: number): number;
        public applyAxisAngle(axis: this, angle: number): this;
        public lerp(v: Vector3, alpha: number): this;
        public lerpVectors(v1: this, v2: this, alpha: number): this;
        public angleTo(v: Vector3): number;
        public setFromMatrixColumn(index: number, matrix: Matrix4): this;
        public reflect(normal: this): this;
        public fromArray(array: number[]): this;
        public multiply(v: this): this;
        public applyProjection(m: Matrix4): this;
        public toArray(array?: number[]): number[];
        public applyEuler(euler: Euler): this;
        public applyQuaternion(quaterion: Quaternion): this;
        public project(camera: Camera): this;
        public unproject(camear: Camera): this;
    }

    export class Camera extends Object3D {
        constructor();
        public matrixWorldInverse: Matrix4;
        public projectionMatrix: Matrix4;
        public getWorldDirection(vector?: Vector3): Vector3;
        public lookAt(vector: Vector3);
        public clone(camera: this): this;
    }


    export class Color {
        constructor(r: number | string, g?: number, b?: number)
        public r: number
        public g: number
        public b: number

        public copy(color: this): this;
        public copyGammaToLinear(color: this): this;
        public copyLinearToGamma(color: this): this;
        public convertGammaToLinear(): this;
        public convertLinearToGamma(): this;
        public setRGB(r: number, g: number, b: number): this;
        public getHex(): number;
        public getHexString(): string;
        public setHex(hex: number): this;
        public setStyle(style: string): this;
        public getStyle(): string;
        public setHSL(h: number, s: number, l: number): this;
        public offsetHSL(h: number, s: number, l: number): this;
        public add(color: this): this;
        public addColors(color1: this, color2: this): this;
        public addScalar(s: number): this;
        public multiply(color: this): this;
        public lerp(color: this, alpha: number): this;
        public toArray(array: number[]): number[];
        public equals(c: this): boolean;
        public clone(): this;
        public set(value: number|this|string): this;
    }


    export class Frustum {
        constructor(p0: Plane, p1: Plane, p2: Plane, p3: Plane, p4: Plane, p5: Plane);
        public planes: Plane[];
        public setFromaMatrix(matrix: Matrix4);
        public intersectsObject(object: Object3D): boolean;
        public clone(): this;
        public set(p0: Plane, p1: Plane, p2: Plane, p3: Plane, p4: Plane, p5: Plane):this;
        public copy(frustum: this): this;
        public containsPoint(point: Vector3): boolean;
        public intersectsSphere(sphere: Sphere): boolean;
    }

    export class Face3 {
        constructor(a: number, b: number, c: number, normal: Vector3, color: Color, materialIndex: number)
        public a: number
        public b: number
        public c: number
        public normal: Vector3
        public color: Color
        public vertexNormals: Vector3[];
        public materialIndex: number;
        public vertexColors: Color[];
        public clone(): Face3;
    }

    export class Quaternion {
        constructor(x?: number, y?: number, z?: number, w?: number);
        public x: number;
        public y: number;
        public z: number;
        public w: number;
        public set(x: number, y: number, z: number, w: number);
        public copy(q: this);
        public setFromEuler(euler: Euler);
        public setFromAxisAngle(axis: Vector3, angle: number);
        public setFromRotationMatrix(m: Matrix4);
        public setFromUnitVectors(vFrom: Vector3, vTo: Vector3);
        public inverse();
        public length();
        public normalize();
        public multiply(b: any);
        public multiplyQuaternions(a: any, b: any);
        public multiplyVector3(vector: Vector3, dest?: Vector3);
        public clone(): this;
        public toArray(array: number[]);
        public equals(v: this): boolean;
        public lengthSq(): number;
        public fromArray(array: number[]);
        public conjugate(): this;
        public slerp(quaternionB: this, t: number);
        public static slerp(qStart: Quaternion, qEnd: Quaternion, qTarget: Quaternion, t: number);
    }

    export class Euler {
        constructor(x: number, y: number, z: number, order?: string);
        public x: number;
        public y: number;
        public z: number;
        public order: string;
        public set(x: number, y: number, z: number, order?: string): this;
        public copy(euler: this): this;
        public setFromRotationMatrix(m: Matrix4, order?: string): this;
        public setFromQuaternion(q: Quaternion, order?: string): this;
        public reorder(newOrder: string): this;
        public setFromVector3(vector: Vector3, order?: string): this;
        public toVector3(): Vector3;
        public fromArray(array: any[]): this;
        public toArray(array: any[]): any[];
        public equals(euler: this): boolean;
        public clone(): this;
    }

    export class Matrix4 {
        public elements: number[];
        constructor();
        public set(n11: number, n12: number, n13: number, n14: number,
            n21: number, n22: number, n23: number, n24: number,
            n31: number, n32: number, n33: number, n34: number,
            n41: number, n42: number, n43: number, n44: number): this;
        public identity(): this;
        public copy(m: this): this;
        public copyPosition(m: this): this;
        public makeBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): this;
        public extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): this;
        public extractRotation(m: this): this;
        public lookAt(eye: Vector3, center: Vector3, up: Vector3): this;
        public multiply(m: this): this;
        public multiplyMatrices(a: this, b: this): this;
        public multiplyToArray(a: this, b: this, r: number[]): this;
        public multiplyScalar(s: number): this;
        public determinant();
        public transpose(): this;
        public flatternToArrayOffset(flat: number[], offset: Vector3);
        public setPosition(v: Vector3): this;
        public getInverse(m: this): this;
        public makeRotationFromEuler(euler: Euler): this;
        public makeRotationFromQuaternion(q: Quaternion): this;
        public scale(v: Vector3): this;
        public compose(translation: Matrix4, quaternion: Quaternion, scale: Vector3): this;
        public decompose(translation: Matrix4, quaternion: Quaternion, scale: Vector3);
        public makeTranslation(x: number, y: number, z: number): this;
        public makeRotationX(theta: number): this;
        public makeRotationY(theta: number): this;
        public makeRotationZ(theta: number): this;
        public makeRotationAxis(axis: Vector3, theta: number): this;
        public makeScale(x: number, y: number, z: number): this;
        public makeFrustum(left: number, right: number, bottom: number, top: number, near: number, far: number): this;
        public makePerspective(fov: number, aspect: number, near: number, far: number): this;
        public makeOrthographic(left: number, right: number, top: number, bottom: number, near: number, far: number): this;
        public clone(): this;
        public applyToVector3Array(a: Vector3);
        public getMaxScaleOnAxis(): number;
    }

    export class Object3D {
        public id: number;
        public uuid: number;
        public name: string;
        public parent: Object3D;
        public children: Object3D[];
        public position: Vector3;
        public rotation: Vector3;
        public scale: number;
        public up: Vector3;
        public matrix: Matrix4;
        public quaternion: Quaternion;
        public visible: boolean;
        public castShadow: boolean;
        public receiveShadow: boolean;
        public frustumCulled: boolean;
        public matrixAutoUpdate: boolean;
        public matrixWorldNeedsUpdate: boolean;
        public rotationAutoUpdate: boolean;
        public userData: any;
        public matrixWorld: Matrix4;

        public applyMatrix(matrix: Matrix4);
        public translateX(distance: number);
        public translateY(distance: number);
        public translateZ(distance: number);
        public localToWorld(vector: Vector3):Vector3;
        public worldToLocal(vector: Vector3): Vector3;
        public lookAt(vector: Vector3);
        public add(object?: any,p1?:any,p2?:any,p3?:any,p4?:any);
        public remove(object: Object3D);
        public traverse(callback: (Object3D) =&gt; void);
        public traverseVisible(callback: (Object3D) =&gt; void);
        public traverseAncestors(callback: (Object3D) =&gt; void);
        public updateMatrix();
        public updateMatrixWorld(force: boolean);
        public clone(object?:any): this;
        public getObjectByName(name: string): this;
        public getObjectById(id: number): this;
        public translateOnAxis(axis: Vector3, distance: number);
        public rotateOnAxis(axis: Vector3, angle: number);
        public raycast(raycaster, intersects);
    }
    
  

    export class raycasterIntersectObjectResult {
        public distance: number;
        public point: Vector3;
        public face: Face3;
        public faceIndex: number;
        public indice: Vector3[];
        public object: Object3D;
    }
    export class Raycaster {
        constructor(origin: Vector3, direction: Vector3, near: number, far: number);
        public ray: Ray;
        public near: number;
        public far: number;
        public linePrecision: number;
        public set(origin: Vector3, direction: Vector3);
        public setFromCamera(coords: Vector2, camera: Camera);
        public intersectObject(object: Object3D, recursive: boolean): raycasterIntersectObjectResult[];
        public intersectObjects(objects: Object3D[], recursive: boolean): raycasterIntersectObjectResult[];
    }
    export class Ray {
        constructor(origin: Vector3, direction: Vector3);
        public origin: Vector3;
        public direction: Vector3;
        public applyMatrix4(matrix4: Matrix4);
        public at(t: number, optionalTarget?: Vector3): Vector3;
        public clone(): this;
        public copy(ray: this): this;
        public distanceSqToSegment(v0: Vector3, v1: Vector3, optionalPointOnRay?: Vector3, optionalPointOnSegment?: Vector3): number;
        public distanceToPlane(plane:Plane): number;
        public distanceToPoint(point: Vector3): number;
        public distanceSqToPoint(point: Vector3): number;
        public equals(ray: this): boolean;
        public intersectBox(box: Box3, optionalTarget?: Vector3): Vector3;
        public intersectPlane(plane: Plane, optionalTarget?: Vector3): Vector3;
        public intersectTriangle(a: Vector3, b: Vector3, c: Vector3, backfaceCulling: boolean, optionalTarget?: Vector3): Vector3;
        public isIntersectionBox(box: Box3): boolean;
        public isIntersectionPlane(plane: Plane): boolean;
        public isIntersectionSphere(sphere: Sphere): boolean;
        public recast(t: number): this;
        public set(origin: Vector3, direction: Vector3): this;

    }
    export class Plane {
        constructor(normal: Vector3, constant: number);
        public normal: Vector3;
        public constant: number;
        public normalize(): this;
        public set(normal: Vector3, constant: number): this;
        public copy(plane: this): this;
        public applyMatrix4(matrix: Matrix4, optionalNormalMatrix?: Matrix3): this;
        public orthoPoint(point: Vector3, optionalTarget?: Vector3): Vector3;
        public isIntersectionLine(line: Line3): boolean;
        public intersectLine(line: Line3, optionalTarget?: Vector3): Vector3;
        public setFromNormalAndCoplanarPoint(normal: Vector3, point: Vector3): this;
        public clone(): this;
        public distanceToPoint(point: Vector3): number;
        public equals(plane: this): boolean;
        public setComponents(x: number, y: number, z: number, w: number): this;
        public distanceToSphere(sphere: Sphere): number;
        public setFromCoplanarPoints(a: Vector3, b: Vector3, c: Vector3): this;
        public projectPoint(point: Vector3, optionalTarget?: Vector3): Vector3;
        public negate(): this;
        public translate(offset: Vector3): this;
        public coplanarPoint(optionalTarget?: Vector3): Vector3;

    }

    export class Sphere extends Object3D {
        constructor(center: Vector3, radius: number);
        public center: Vector3;
        public radius: number;
        public set(center: Vector3, radius: number);
        public applyMatrix4(matrix: Matrix4): this;
        public clampPoint(point: Vector3, optionalTarget?: Vector3): Vector3;
        public translate(offset: Vector3): this;
        public clone(): this;
        public equals(sphere: this): boolean;
        public setFromPoints(points: Vector3[], optionalCenter?: Vector3): this;
        public distanceToPoint(point: Vector3): number;
        public getBoundingBox(optionalTarget: Box3): Box3;
        public containsPoint(point: Vector3): boolean;
        public copy(sphere: this): this;
        public intersectsSphere(sphere: this): boolean;
        public empty(): boolean;

    }
    export class Box2 {
        constructor(min: Vector2, max: Vector3);
        public min: Vector2;
        public max: Vector2;
        public set(min: Vector3, max: Vector2): this;
        public expandByPoint(point: Vector2): this;
        public clampPoint(point: Vector2, optionalTarget?: Vector2): Vector2;
        public isIntersectionBox(box: this): boolean;
        public setFromPoints(points: Vector2[]): this;
        public size(optionalTarget?: Vector2): Vector2;
        public union(box: this): this;
        public getParameter(point: Vector2, optionalTarget?: Vector2): Vector2;
        public expandByScalar(scalar: number): this;
        public intersect(box: this): this;
        public containsBox(box: this): boolean;
        public translate(offset: Vector2): this;
        public empty(): boolean;
        public clone(): this;
        public equals(box: this): boolean;
        public expandByVector(vector: Vector2): this;
        public copy(box: this): this;
        public makeEmpty(): this;
        public center(optionalTarget?: Vector2): Vector2;
        public distanceToPoint(point: Vector2): number;
        public containsPoint(point: Vector2): boolean;
        public setFromCenterAndSize(center: Vector2, size: Vector2): this;
    }
    export class Box3 {
        constructor(min: Vector3, max: Vector3);
        public min: Vector3;
        public max: Vector3;
        public set(min: Vector3, max: Vector3): this;
        public applyMatrix4(matrix: Matrix4): this;
        public clampPoint(point: Vector3, optionalTarget?: Vector3): Vector3;
        public isIntersectionBox(box: this): boolean;
        public setFromPoints(points: Vector3[]): this;
        public setFromObject(object: Object3D): this;
        public size(optionalTarget?:Vector3): Vector3;
        public union(box: this): this;
        public getParameter(point: Vector3, optionalTarget?: Vector3): Vector3;
        public intersect(box: this): this;
        public containsBox(box: this): boolean;
        public containsPoint(point: Vector3): boolean;
        public translate(offset: Vector3): this;
        public empty(): boolean;
        public clone(): this;
        public equals(box: this): boolean;
        public expandByPoint(point: Vector3): this;
        public expandByScalar(scalar: number): this;
        public expandByVector(vector: Vector3): this;
        public copy(box: this): this;
        public makeEmpty(): this;
        public center(optionalTarget?: Vector3): Vector3;
        public getBoundingSphere(optionalTarget?: Vector3): Sphere;
        public distanceToPoint(point: Vector3): number;
        public setFromCenterAndSize(center: Vector3, size: Vector3): this;

    }

    export class Math {
        public static clamp(value: number, min: number, max: number): number;
        public static mapLinear(x: number, a1: number, a2: number, b1: number, b2: number);
        public static random16(): number;
        public static randInt(low: number, high: number): number;
        public static raindFloat(low: number, high: number): number;
        public static randFloatSpread(range: number): number;
        public static sign(x: number): number;
        public static degToRad(degress: number): number;
        public static radToDeg(radians: number): number;
        public static smoothstep(x: number, min: number, max: number): number;
        public static smoothersttep(x: number, min: number, max: number): number;
    }
    export class Spline {
        constructor(points: Vector3[]);
        public points: Vector3[];
        public initFromArray(a: number[][]): void;
        public getPoint(k: number): Vector3;
        public getControlPointsArray(): number[];
        public getLength(nSubDivisions: number): any;
        public reparametrizeByArcLength(samplingCoef: number): void;
    }
    export class Triangle {
        constructor(a: Vector3, b: Vector3, c: Vector3);
        public a: Vector3;
        public b: Vector3;
        public c: Vector3;
        public setFromPointsAndIndices(points: Vector3[], i0: number, i1: number, i2: number): this;
        public set(a: Vector3, b: Vector3, c: Vector3): this;
        public normal(optionalTarget?: Vector3): Vector3;
        public barycoordFromPoint(point: Vector3, optionalTarget?: Vector3): Vector3;
        public clone(): this;
        public area(): number;
        public midpoint(optionalTarget?: Vector3): Vector3;
        public equals(triangle: this): boolean;
        public plane(optionalTarget?: Vector3): Plane;
        public containsPoint(point: Vector3): boolean;
        public copy(triangle: this): this;
    }

    export class Bone extends Object3D {
        constructor(skin?: SkinnedMesh);
        public skin: SkinnedMesh;
        public clone(object: this): this;
    }
    export class LensFlare extends Object3D {
        constructor(texture: Texture, size: number, distance: number, blending: number, color: Color);
        public lensFlare: any[];
        public positionScreen: Vector3;
        public customUpdateCallback: (any) =&gt; any;
        public add(texture: Texture, size: number, distance: number, blending: number, color: Color);
        public updateLensFlares(): void;
        public clone(object: this): this;
    }

    export class Line3 {
        constructor(start: Vector3, end: Vector3);
        public start: Vector3;
        public end: Vector3;
        public set(start: Vector3, end: Vector3);
        public copy(line: this);
        public clone(): this;
        public eqauls(line: this): boolean;
        public distance(): number;
        public distanceSq(): number;
        public applyMatrix4(matrix: Matrix4): this;
        public at(t: number, optionalTarget?: Vector3): Vector3;
        public center(optionalTarget?: Vector3): Vector3;
        public delta(optionalTarget?: Vector3): Vector3;
        public closestPointToPoint(point: Vector3, clmapToLine: boolean, optionalTarget?: Vector3): Vector3;
        public closestPointToPointParameter(point: Vector3, clampToLine: boolean): Vector3;
    }
    export class Line extends Object3D {
        constructor(geometry: Geometry, material: Material);
        public geometry: Geometry;
        public material: Material;
        public raycast(raycaster: Raycaster, intersects: Object3D[]): raycasterIntersectObjectResult[];
        public clone(object: this): this;
    }
    export class LOD extends Object3D {
        constructor();
        public objects: Object3D[];
        public addLevel(mesh: Mesh, distance: number): void;
        public getObjectForDistance(distance: number): Object3D;
        public update(camera: Camera): void;
        public clone(object?: Object3D): this;
    }
    export class LineSegments extends Line {
        constructor(geometry: Geometry, material: Material);
        public geometry: Geometry;
        public material: Material;
        public raycast(raycaster: Raycaster, intersects: Object3D[]): raycasterIntersectObjectResult[];
        public clone(object: this): this;

    }
    export class Matrix3 {
        constructor();
        public elements: number[];
        public transpose();
        public transposeIntoArray(array: number[]): this;
        public determinant(): number;
        public set(n11: number, n12: number, n13: number,
            n21: number, n22: number, n23: number,
            n31: number, n32: number, n33: number): this;
        public multiplyScalar(s: number): this;
        public applyToVector3Array(array: number[]);
        public getNormalMatrix(m: Matrix4): this;
        public getInverse(m: Matrix4, throwOnInertible: boolean): this;
        public copy(m: Matrix4): this;
        public clone(): this;
        public identity(): this;

    }

    export class MorphTarget {
        public name: string;
        public vertices: Vector3[];
    }
    export class BoundingBox {
        public min: Vector3;
        public max: Vector3;
    }
    export class BoundingSphere {
        public radius: number;
    }
    export class Geometry {
        public id: number
        public name: string
        public vertices: Vector3[]
        public colors: Color[]
        public faces: Face3[];
        public faceVertexUvs: any[];
        public morphTargets: MorphTarget[];
        public morphNormals: MorphTarget[];
        public skinWeights: Vector4[];
        public skinIndices: Vector4[];
        public boundingBox: BoundingBox;
        public boundingSphere: BoundingSphere;
        public dynamic: boolean;
        public verticesNeedUpdate: boolean;
        public elementsNeedUpdate: boolean;
        public uvsNeedUpdate: boolean;
        public normalsNeedUpdate: boolean;
        public colorsNeedUpdate: boolean;
        public lineDistancesNeedUpdate: boolean;
        public lineDistances: number[];
        public applyMatrix(matrix: Matrix4):void;
        public center():void;
        public rotateX(radians: number): this;
        public rotateY(radians: number): this;
        public rotateZ(radians: number): this;
        public translate(x: number, y: number, z: number): this;
        public scale(x: number, y: number, z: number): this;
        public lookAt(vector: Vector3): this;
        public computeFaceNormals(): void;
        public computeVertexNormals(): void;
        public computeBoundingBox(): void;
        public computeBoundingSphere(): void;
        public merge(geometry: this, matrix: Matrix4, materialINdexOffset: number): void;
        public mergeVertices(): void;
        public normalize();
        public clone(): this;
        public dispose(): void;
        public computeLineDistances(): void;
    }
    export class BoxGeometry extends Geometry {
        constructor(width: number, height: number, depth: number,
            widthSegments?: number, heightSegments?: number, depthSegments?: number);
        public parameters: any;
    }
    export class CircleGeometry extends Geometry {
        constructor(radius: number, segments: number, thetaStart: number, thetaLength: number);
    }
    export class AxisHelper extends Line {
        constructor(size: number);
    }
    export class CylinderGeometry extends Geometry {
        constructor(
            radiusTop: number,
            radiusBottom: number,
            height: number,
            radiusSegments?: number,
            heightSegments?: number,
            openEnded?: boolean,
            thetaStart?: number,
            thetaLength?: number);
        public radiusTop: number;
        public radiusBottom: number;
        public height: number;
        public radiusSegments: number;
        public heightSegments: number;
        public openEnded: boolean;
        public thetaStart: number;
        public thetaLength: number;
    }

    export class PolyhedronGeometry extends Geometry{
        constructor(vertices: number[], faces: number[], radius: number, detail: number);
        public parameters: any;
    }
    export class DodecahedronGeometry extends PolyhedronGeometry {
        constructor(radius: number, detail: number);
    }
    export class IcosahedronGeometry extends PolyhedronGeometry {
        constructor(radius: number, detail: number);
    }
    export class OctahedronGeometry extends PolyhedronGeometry {
        constructor(radius: number, detail: number);
    }
    export class LatheGeometry extends Geometry {
        constructor(points: Vector3[], segments: number, phiStart: number, phiLength: number);
    }
    export class ParametricGeometry extends Geometry {
        constructor(func: (u: number, v: number) =&gt; Vector3, slices: number, stacks: number);
    }
    export class PlaneGeometry extends Geometry {
        constructor(width: number, height: number, widthSegments: number, heightSegments: number);
        public width: number;
        public height: number;
        public widthSegments: number;
        public heightSegments: number;
    }
    export class RingGeometry extends Geometry {
        constructor(innerRaidus: number, outerRadius: number,
            thetaSegments: number, phiSegments: number, thetaStart: number, thetaLength: number);
    }
    export class TetrahedronGeometry extends PolyhedronGeometry {
        constructor(radius: number, detail: number);
    }

    export class SphereGeometry extends Geometry {
        constructor(
            radius?: number,
            widthSegments?: number,
            heightSegments?: number,
            phiStart?: number,
            phiLength?: number,
            thetaStart?: number,
            thetaLength?: number);
        public radius: number;
        public widthSegments: number;
        public heightSegments: number;
        public phiStart: number;
        public phiLength: number;
        public thetaStart: number;
        public thetaLength: number;
    }

    export class Vector4 {
        constructor(x: number, y: number, z: number, w: number);
        public x: number;
        public y: number;
        public z: number;
        public w: number;
        public copy(v: this): this;
        public add(v: this): this;
        public addVectors(a: this, b: this): this;
        public addScaledVector(v: this, s: number): this;
        public sub(v: this): this;
        public subVectors(a: this, b: this): this;
        public multiplyScalar(s: number): this;
        public divideScalar(s: number): this;
        public negate(): this;
        public lengthSq(): number;
        public length(): number;
        public normalize(): this;
        public setLength(l: number): this;
        public lerp(v: this, alpha: number): this;
        public lerpVectors(v1: this, v2: this, alpha): this;
        public clone(): this;
        public clamp(min: this, max: this): this;
        public clampScalar(min: number, max: number): this;
        public floor(): this;
        public ceil(): this;
        public round(): this;
        public roundToZero(): this;
        public applyMatrix4(m: Matrix4): this;
        public min(v: this): this;
        public max(v: this): this;
        public addScalar(s: number): this;
        public equals(v: this): boolean;
        public setAxisAngleFromRotationMatrix(m: Matrix4): this;
        public setAxisAngleFromQuaterion(q: Quaternion): this;
        public getComponent(index: number): number;
        public setComponent(index: number, value: number);
        public fromArray(array: number[]): this;
        public toArray(array: number[]): number[];
        public lengthManhattan(): number;
        public setX(x: number): this;
        public setY(y: number): this;
        public setZ(z: number): this;
        public setW(w: number): this;

    }

    export enum Side {
        FrontSide = 0,
        BackSide = 1,
        DoubleSide = 2
    }
    export enum Blending {
        NoBlending = 0,
        NormalBlending = 1,
        AdditiveBlending = 2,
        SubtractiveBlending = 3,
        MultiplyBlending = 4,
        CustomBlending = 5
    }
    export class Material {
        constructor();
        public id: number;
        public name: string;
        public opacity: number;
        public transparent: boolean;
        public blending: Blending;
        public blendSrc: number;
        public blendDst: number;
        public blendEquation: number;
        public depthTest: boolean;
        public depthWrite: boolean;
        public polygonOffset: boolean;
        public polygonOffsetFactor: number;
        public polygonOffsetUnits: number;
        public alphaTest: number;
        public overdraw: number;
        public visible: boolean;
        public side: Side;
        public needUpdate: boolean;

        public clone(material: this): this;
        public dispose();
        public setValues(values: any);

    }

    export class MeshPhongMaterialParameters {
        public color: number;
        public map: Texture;
        public lightMap: Texture;
        public aoMap: Texture;
        public emissiveMap: Texture;
        public specularMap: Texture;
        public alphaMap: Texture;
        public envMap: Texture;
        public fog: boolean;
        public shading: any;
        public wireframe: boolean;
        public wireframeLinewidth: number;
        public wireframeLinecap: string;
        public wireframeLinejoin: string;
        public vertexColors: any;
        public skining: boolean;
        public morphTargets: boolean;
    }
    export class LineBasicMaterial extends Material {
        constructor(parameters: any);
        public color: number;
        public linewidth: number;
        public linecap: string;
        public linejoin: string;
        public vertexColors: VertexColor;
        public fog: boolean;
    }
    export class LineDashedMaterial extends Material {
        constructor(parameters: any);
        public color: number;
        public linewidth: number;
        public scale: number;
        public dashSize: number;
        public gapSize: number;
        public vertexColors: VertexColor;
        public fog: boolean;
    }
    export class MeshBasicMaterial extends Material {
        constructor(parameters: any);
        public color: number;
        public map: Texture;
        public aoMap: Texture;
        public specularMap: Texture;
        public alphaMap: Texture;
        public envMap: Texture;
        public fog: boolean;
        public shading: Shading;
        public wireframe: boolean;
        public wireframeLinewidth: number;
        public wireframeLinecap: string;
        public wireframeLinejoin: string;
        public vertexColors: VertexColor;
        public skinning: boolean;
        public morphTargets: boolean;
        public combine: number;
        public reflectivity: number;
        public refractionRatio: number;
    }
    export class MeshDepthMaterial extends Material {
        constructor(parameters: any);
        public morthTargets: boolean;
        public wireframe: boolean;
        public wireframeLinewidth: number;
    }
    export class MeshFaceMaterial {
        constructor(materials: Material[]);
        public materials: Material[];
    }
    export class MeshLambertMaterial extends Material {
        constructor(parameters: any);
    }
    export class MeshNormalMaterial extends Material {
        constructor(parameters: any);
    }
    export class PointsMaterial extends Material {
        constructor(parameters: any);
    }
    export class SpriteCanvasMaterial extends Material {
        constructor(parameters: any);
    }
    export class SpriteMaterial extends Material {
        constructor(parameters: any);
    }
    export class MeshPhongMaterial extends Material {
        constructor(parameters?: any);
        public color: Color;
        public emissive: Color;
        public specular: Color;
        public skininess: number;
        public metal: boolean;
        public map: Texture;
        public lightMap: Texture;
        public aoMap: Texture;
        public emissiveMap: Texture;
        public bumpMap: Texture;
        public bumpScale: number;
        public normalMap: Texture;
        public normalScale: number;
        public specularMap: Texture;
        public alphaMap: Texture;
        public envMap: Texture;
        public combine: Operation;
        public reflectivity: number;
        public refractionRatio: number;
        public fog: boolean;
        public shading: Shading;
        public wireframe: boolean;
        public wireframeLineWidth: number;
        public wireframeLinecap: string;
        public wireframeLinejoin: string;
        public vertexColors: VertexColor;
        public skining: boolean;
        public morphTargets: boolean;
        public morphNormals: boolean;

    }


    
    export class DataTexture extends Texture {
        constructor(
            data: number[],
            width: number,
            height: number,
            format: Format,
            type: Type,
            mapping: Mapping,
            wrapS: Wrapping,
            wrapT: Wrapping,
            magFilter: Filter,
            minFilter: Filter,
            anisotropy: number);
        public image: HTMLImageElement;

    }
    export class CompressedTexture extends Texture {
        constructor(
            mipmaps: any[],
            width: number,
            height: number,
            format: Format,
            type: Type,
            mapping: Mapping,
            wrapS: Wrapping,
            wrapT: Wrapping,
            magFilter: Filter,
            minFilter: Filter,
            anisotropy: number);
        public flipY: boolean;
        public generateMipmaps: boolean;
    }
    export class CubeTexture extends Texture {
        constructor(
            image: HTMLImageElement[] | HTMLVideoElement[] | HTMLCanvasElement[],
            mapping: Mapping,
            wrapS: Wrapping,
            wrapT: Wrapping,
            magFilter: Filter,
            minFilter: Filter,
            formate: Format,
            type: Type,
            anisotropy: number);
    }
    export class Texture {
        constructor(
            image: HTMLImageElement | HTMLVideoElement|HTMLCanvasElement,
            mapping: Mapping,
            wrapS: Wrapping,
            wrapT: Wrapping,
            magFilter: Filter,
            minFilter: Filter,
            formate: Format,
            type: Type,
            anisotropy: number);
        public id: number;
        public image: HTMLImageElement | HTMLVideoElement|HTMLCanvasElement;
        public mapping: Mapping;
        public wrapS: number;
        public wrapT: number;
        public magFilter: Filter;
        public format: Format;
        public type: Type;
        public anisotropy: number;
        public needsUpdate: boolean;
        public repeat: number;
        public offset: number;
        public name: string;
        public generateMipmaps: boolean;
        public flipY: boolean;
        public mipmaps: any[];
        public unpackAlignment: number;
        public premultiplyAlpha: boolean;
        public onUpdate: (any) =&gt; any;
        public clone(texture: this): this;
        public dispose(): void;
    }

    export class Intersection {
        public distance: number;
        public point: Vector3;
        public object: Object3D;
    }
    export class Mesh extends Object3D {
        constructor(geometry: Geometry, material: Material);
        public geometry: Geometry;
        public material: Material;
        public morphTargetInfluences: number[];
        public morphTargetDictionary: any[];
        public morphTargetBase: number;
        public getMorphTargetIndexByName(name: string): number;
        public updateMorphTargets();
        public raycast(raycaster: Raycaster, intersects: Intersection[]): raycasterIntersectObjectResult[];
        public clone(object?: any): this;
    }
    export enum Direction {
        Forward = 1,
        Backwards = -1
    }
    export class MorphAnimMesh extends Object3D {
        constructor(geometry: Geometry, material: Material);
        public directionBackwards: boolean;
        public direction: Direction;
        public startKeyframe: number;
        public endKeyframe: number;
        public mirroredLoop: boolean;
        public lastKeyframe: number;
        public currentKeyframe: number;
        public length: number;
        public time: number;
        public duration: number;
        public setDirectionForward();
        public setDirectionBackward();
        public playAnimation(label: string, fps: number);
        public setFrameRange(start: number, end: number);
        public parseAnimations();
        public updateAnimation(delta: number);
        public setAnimationLabel(label: string, start: number, end: number);
        public clone(object?: Object3D);
    }
    export class Points extends Object3D {
        constructor(geometry: Geometry, material: Material);
        public geometry: Geometry;
        public material: Material;
        public clone(): this;
        public raycast(raycaster:Raycaster, intersects:Object3D[]):raycasterIntersectObjectResult[];
        public clone(object?: any): this;
    }
    export class Skeleton {
        constructor(bones: Bone[], boneInverses?: Matrix4[], useVertexTexture?: boolean);
        public bones: Bone[];
        public useVertexTexture: boolean;
        public boneInverses: Matrix4[];
        public boneTextureWidth: number;
        public boneTextureHeight: number;
        public boneTexture: DataTexture;
        public calculateInverse(): void;
        public pose(): void;
        public update(): void;
        public clone(): this;
    }
    export class Sprite extends Object3D {
        constructor(material?: Material);
        public material: Material;
        public clone(): this;
        public clone(object?: Object3D): this;
        
    }
    

    export class SkinnedMesh extends Object3D {
        constructor(geometry: Geometry, material: Material, useVertexTexture?: boolean);
        public bones: any[];

    }

    export class Scene extends Object3D {
        constructor();
        public fog: Fog;
        //全局材质,如果不为空,所有的物体将强制使用此材质
        public overrideMaterial: Material;
        public autoUpdate: boolean;
    }
    export class TrackballControls {
        constructor(camera: Camera);
        public update(): void;
    }
    export class PerspectiveCamera extends Camera {
        constructor(fov: number, aspect: number, near: number, far: number);
        public zoom: number;
        public fov: number;
        public aspect: number;
        public near: number;
        public far: number;
        public setLens(focalLength: number, frameSize: number);
        public setViewOffset(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number);
        public updateProjectionMatrix();
        public clone(): this;
        public toJSON(): any;
    }
    export class Fog {
        constructor(color: number, near: number, far: number);
        public name: string;
        public color: number;
        public near: number;
        public far: number;
        public clone(): this;

    }
    export class FogExp2 {
        constructor(hex: Color | string, density: number);
        public name: string;
        public color: Color;
        //Default is 0.00025
        public density: number;
        public clone(): this;
    }
    
    

    export class WebGLRenderer {
        constructor(parameters: any);

    }
    export class Group extends Object3D {
        constructor();
    }
    export class Light extends Object3D {
        constructor(hex: number);
        public color: Color;
        public clone(): this;
    }

    export class AmbientLight extends Light {
        constructor(hex: number)
        public clone(): this
        toJSON(): any
    }
    
    export class DirectionalLight extends Light {
        public intensity: number
        public onlyShadow: boolean;
        public castShadow: boolean;
        public shadowCameraNear: number;
        public shadowCameraFar: number;
        public shadowCameraLeft: number;
        public shadowCamearRight: number;
        public shadowCameraTop: number;
        public shadowCameraBottom: number;
        public shadowCameraVisible: boolean;
        public shadowBias: number;
        public shadowMapWidth: number;
        public shadowMapHeight: number;
        public shadowMapSize: number;
        public shadowCamera: number;
        public position: Vector3;
        constructor(color: number, intensity?: number)
    }
    export class PointLight extends Light {
        constructor(hex: number, intensity: number, distance: number, decay: number);
        public intensity: number;
        public distance: number;
        public decay: number;
        public clone(): this;
        public toJSON():any;

    }
    export class SpotLight extends Light {
        constructor(hex: number, intensity: number, distance: number, angle: number, exponent: number, decay: number);
        public target: Object3D;
        public intensity: number;
        public distance: number;
        public angle: number;
        public exponent: number;
        public decay: number;
        public onlyShadow: number;
        public shadowCameraNear: number;
        public shadowCameraFar: number;
        public shadowCameraFov: number;
        public shadowCameraVisible: number;
        public shadowBias: number;
        public shadowMapWidth: number;
        public shadowMapSize: Vector2;
        public shadowCamera: PerspectiveCamera;
        public shadowMatrix: Matrix4;
        public shadowMap: any;
        public clone(): this;
    }
    export class HemisphereLight extends Light {
        constructor(skyColorHex: number, groundColorHex: number, intensity: number);
        public groundColor: number;
        public intensity: number;
        public clone(): this;
        public toJSON(): any;
    }
} 
</code></pre> 
 </div> 
 <p>　　一些three.js中的常量,本来想用enum表达的,代码编译成js,不会自动替换成对应的数值,这个算不算ts的bug?</p> 
 <p>     看了遍ts手册,也没有发现好的办法,留待以后再说吧</p> 
</div> 
<p>转载于:https://www.cnblogs.com/skytouchzyt/p/5164919.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/82c933392d7a1fe3153e43c8adde7fa3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">友盟第三方分享时的注意事项（报40002错误）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6396b921442915577c4bf53ff4167da4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用pabot并发执行robotframework的testSuite</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>