<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>北方大学 ACM 多校训练赛 第四场 题解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="北方大学 ACM 多校训练赛 第四场 题解" />
<meta property="og:description" content="A. 恶魔包毁灭世界 已知一张二分图，问哪些边是二分图的可行边？ 先跑最小流，再把残余网络建图，几个重要结论是： ·最小割的可行边（满流&amp;&amp;2点不在一个SCC中） ·最小割的必行边（可行边&amp;&amp;2点分别与源点和汇点在同一SCC中） ·二分图的可行边（两点在一个SCC中）
#include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;functional&gt; #include &lt;cstdlib&gt; #include &lt;queue&gt; #include &lt;stack&gt; using namespace std; #define For(i,n) for(int i=1;i&lt;=n;i&#43;&#43;) #define Fork(i,k,n) for(int i=k;i&lt;=n;i&#43;&#43;) #define Rep(i,n) for(int i=0;i&lt;n;i&#43;&#43;) #define ForD(i,n) for(int i=n;i;i--) #define ForkD(i,k,n) for(int i=n;i&gt;=k;i--) #define RepD(i,n) for(int i=n;i&gt;=0;i--) #define Forp(x) for(int p=Pre[x];p;p=Next[p]) #define Forpiter(x) for(int &amp;p=iter[x];p;p=Next[p]) #define Lson (o&lt;&lt;1) #define Rson ((o&lt;&lt;1)&#43;1) #define MEM(a) memset(a,0,sizeof(a)); #define MEMI(a) memset(a,127,sizeof(a)); #define MEMi(a) memset(a,128,sizeof(a)); #define INF (2139062143) #define F (100000007) #define pb push_back #define mp make_pair #define fi first #define se second #define vi vector&lt;int&gt; #define pi pair&lt;int,int&gt; #define SI(a) ((a)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ffefc4addc79afd7af0593c26d521de7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-03-27T10:12:09+08:00" />
<meta property="article:modified_time" content="2017-03-27T10:12:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">北方大学 ACM 多校训练赛 第四场 题解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="a-恶魔包毁灭世界">A. 恶魔包毁灭世界</h2> 
<p>已知一张二分图，问哪些边是二分图的可行边？ <br> 先跑最小流，再把残余网络建图，几个重要结论是： <br> ·最小割的可行边（满流&amp;&amp;2点不在一个SCC中） <br> ·最小割的必行边（可行边&amp;&amp;2点分别与源点和汇点在同一SCC中） <br> ·二分图的可行边（两点在一个SCC中）</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;cmath&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstdio&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstring&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;map&gt;</span>
<span class="hljs-preprocessor">#include &lt;functional&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstdlib&gt;</span>
<span class="hljs-preprocessor">#include &lt;queue&gt;</span>
<span class="hljs-preprocessor">#include &lt;stack&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-preprocessor">#define For(i,n) for(int i=1;i&lt;=n;i++)</span>
<span class="hljs-preprocessor">#define Fork(i,k,n) for(int i=k;i&lt;=n;i++)</span>
<span class="hljs-preprocessor">#define Rep(i,n) for(int i=0;i&lt;n;i++)</span>
<span class="hljs-preprocessor">#define ForD(i,n) for(int i=n;i;i--)</span>
<span class="hljs-preprocessor">#define ForkD(i,k,n) for(int i=n;i&gt;=k;i--)</span>
<span class="hljs-preprocessor">#define RepD(i,n) for(int i=n;i&gt;=0;i--)</span>
<span class="hljs-preprocessor">#define Forp(x) for(int p=Pre[x];p;p=Next[p])</span>
<span class="hljs-preprocessor">#define Forpiter(x) for(int &amp;p=iter[x];p;p=Next[p])  </span>
<span class="hljs-preprocessor">#define Lson (o&lt;&lt;1)</span>
<span class="hljs-preprocessor">#define Rson ((o&lt;&lt;1)+1)</span>
<span class="hljs-preprocessor">#define MEM(a) memset(a,0,sizeof(a));</span>
<span class="hljs-preprocessor">#define MEMI(a) memset(a,127,sizeof(a));</span>
<span class="hljs-preprocessor">#define MEMi(a) memset(a,128,sizeof(a));</span>
<span class="hljs-preprocessor">#define INF (2139062143)</span>
<span class="hljs-preprocessor">#define F (100000007)</span>
<span class="hljs-preprocessor">#define pb push_back</span>
<span class="hljs-preprocessor">#define mp make_pair </span>
<span class="hljs-preprocessor">#define fi first</span>
<span class="hljs-preprocessor">#define se second</span>
<span class="hljs-preprocessor">#define vi vector&lt;int&gt; </span>
<span class="hljs-preprocessor">#define pi pair&lt;int,int&gt;</span>
<span class="hljs-preprocessor">#define SI(a) ((a).size())</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;
ll mul(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a*b)%F;}
ll add(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a+b)%F;}
ll sub(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a-b+llabs(a-b)/F*F+F)%F;}
<span class="hljs-keyword">void</span> upd(ll &amp;a,ll b){a=(a%F+b%F)%F;}
<span class="hljs-keyword">int</span> read()
{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch=getchar();
    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) {<!-- --><span class="hljs-keyword">if</span> (ch==<span class="hljs-string">'-'</span>) f=-<span class="hljs-number">1</span>; ch=getchar();}
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch)) { x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>; ch=getchar();}
    <span class="hljs-keyword">return</span> x*f;
} 
<span class="hljs-preprocessor">#define MAXN (3000*2+100)</span>
<span class="hljs-preprocessor">#define MAXM (18000000+12000+10)</span>
<span class="hljs-keyword">int</span> n,k;
<span class="hljs-keyword">bool</span> b[<span class="hljs-number">3010</span>][<span class="hljs-number">3010</span>]={};
<span class="hljs-keyword">class</span> tar{
<span class="hljs-keyword">public</span>:
    vi G[MAXN];
    <span class="hljs-keyword">int</span> pre[MAXN],lowlink[MAXN],sccno[MAXN],dfs_clock,scc_cnt;
    <span class="hljs-stl_container"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> S; 
    <span class="hljs-keyword">void</span> dfs(<span class="hljs-keyword">int</span> u) {
        pre[u] = lowlink[u] = ++dfs_clock;
        S.push(u);
        <span class="hljs-keyword">int</span> sz=SI(G[u]);
        Rep(i,sz) {
            <span class="hljs-keyword">int</span> v=G[u][i];
            <span class="hljs-keyword">if</span> (!pre[v]) {
                dfs(v);
                lowlink[u]=min(lowlink[u],lowlink[v]);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!sccno[v]) {
                lowlink[u]=min(lowlink[u],pre[v]);
            } 
        } 
        <span class="hljs-keyword">if</span> (lowlink[u]==pre[u]) {
            scc_cnt++;  
            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {
                <span class="hljs-keyword">int</span> x=S.top();S.pop();
                sccno[x]=scc_cnt;
                <span class="hljs-keyword">if</span> (x==u) <span class="hljs-keyword">break</span>;  
            } 
        }       
    } 
    <span class="hljs-keyword">void</span> find_scc(<span class="hljs-keyword">int</span> n) {
        dfs_clock = scc_cnt = <span class="hljs-number">0</span>;
        MEM(sccno) 
        MEM(pre)
        Rep(i,n) <span class="hljs-keyword">if</span> (!pre[i]) dfs(i);
    }
    <span class="hljs-keyword">void</span> print(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> n1,<span class="hljs-keyword">int</span> m1) {
        <span class="hljs-comment">// Rep(i,n) cout&lt;&lt;sccno[i]&lt;&lt;' ';cout&lt;&lt;endl;</span>
        Rep(i,n1) {
            <span class="hljs-keyword">int</span> sz=SI(G[i]);
            Rep(j,sz) {
                <span class="hljs-keyword">int</span> v=G[i][j];
                <span class="hljs-keyword">if</span> (sccno[i]==sccno[v]&amp;&amp;n1&lt;=v&amp;&amp;v&lt;n1+m1) {
                    b[i+<span class="hljs-number">1</span>][v-n1+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;
                }
            }
        }
    }
    <span class="hljs-keyword">void</span> mem(<span class="hljs-keyword">int</span> n) {
        Rep(i,n) G[i].clear();
    }
}S2;
<span class="hljs-keyword">class</span> Max_flow  <span class="hljs-comment">//dinic+当前弧优化   </span>
{    
<span class="hljs-keyword">public</span>:    
    <span class="hljs-keyword">int</span> n,t;    
    <span class="hljs-keyword">int</span> q[MAXN];    
    <span class="hljs-keyword">int</span> edge[MAXM],Next[MAXM],Pre[MAXN],weight[MAXM],size;    
    <span class="hljs-keyword">void</span> addedge(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w)      
    {      
        edge[++size]=v;      
        weight[size]=w;      
        Next[size]=Pre[u];      
        Pre[u]=size;      
    }      
    <span class="hljs-keyword">void</span> addedge2(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w){addedge(u,v,w),addedge(v,u,<span class="hljs-number">0</span>);}     
    <span class="hljs-keyword">bool</span> b[MAXN];    
    <span class="hljs-keyword">int</span> d[MAXN];    
    <span class="hljs-keyword">bool</span> SPFA(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t)      
    {      
        For(i,n) d[i]=INF;    
        MEM(b)    
        d[q[<span class="hljs-number">1</span>]=s]=<span class="hljs-number">0</span>;b[s]=<span class="hljs-number">1</span>;      
        <span class="hljs-keyword">int</span> head=<span class="hljs-number">1</span>,tail=<span class="hljs-number">1</span>;      
        <span class="hljs-keyword">while</span> (head&lt;=tail)      
        {      
            <span class="hljs-keyword">int</span> now=q[head++];      
            Forp(now)      
            {      
                <span class="hljs-keyword">int</span> &amp;v=edge[p];      
                <span class="hljs-keyword">if</span> (weight[p]&amp;&amp;!b[v])      
                {      
                    d[v]=d[now]+<span class="hljs-number">1</span>;      
                    b[v]=<span class="hljs-number">1</span>,q[++tail]=v;      
                }      
            }          
        }      
        <span class="hljs-keyword">return</span> b[t];      
    }     
    <span class="hljs-keyword">int</span> iter[MAXN];  
    <span class="hljs-keyword">int</span> dfs(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> f)  
    {  
        <span class="hljs-keyword">if</span> (x==t) <span class="hljs-keyword">return</span> f;  
        Forpiter(x)  
        {  
            <span class="hljs-keyword">int</span> v=edge[p];  
            <span class="hljs-keyword">if</span> (weight[p]&amp;&amp;d[x]&lt;d[v])  
            {  
                  <span class="hljs-keyword">int</span> nowflow=dfs(v,min(weight[p],f));  
                  <span class="hljs-keyword">if</span> (nowflow)  
                  {  
                    weight[p]-=nowflow;  
                    weight[p^<span class="hljs-number">1</span>]+=nowflow;  
                    <span class="hljs-keyword">return</span> nowflow;  
                  }  
            }  
        }  
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
    }  
    <span class="hljs-keyword">int</span> max_flow(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t)  
    {  
        (*<span class="hljs-keyword">this</span>).t=t;
        <span class="hljs-keyword">int</span> flow=<span class="hljs-number">0</span>;  
        <span class="hljs-keyword">while</span>(SPFA(s,t))  
        {  
            For(i,n) iter[i]=Pre[i];  
            <span class="hljs-keyword">int</span> f;  
            <span class="hljs-keyword">while</span> (f=dfs(s,INF))  
                flow+=f;   
        }  
        <span class="hljs-keyword">return</span> flow;  
    }   
    <span class="hljs-keyword">void</span> mem(<span class="hljs-keyword">int</span> n)    
    {    
        (*<span class="hljs-keyword">this</span>).n=n;  
        size=<span class="hljs-number">1</span>;    
        MEM(Pre)   
    }
    <span class="hljs-keyword">void</span> init(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> n1,<span class="hljs-keyword">int</span> m1) {
        For(i,n) {
            Forp(i) {
                <span class="hljs-keyword">int</span> v=edge[p];  
                <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;' '&lt;&lt;v&lt;&lt;' '&lt;&lt;weight[p]&lt;&lt;endl;</span>
                <span class="hljs-keyword">if</span> (!weight[p]) {
                    <span class="hljs-keyword">if</span> (i&lt;=n1&amp;&amp;v&gt;n1&amp;&amp;v&lt;=n1+m1) {
                        ::b[i][v-n1]=<span class="hljs-number">1</span>;
                        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;' '&lt;&lt;v-n1&lt;&lt;endl;</span>
                    }
                }
                <span class="hljs-keyword">else</span> S2.G[i-<span class="hljs-number">1</span>].pb(v-<span class="hljs-number">1</span>);

            }
        }
    }


}S;  
<span class="hljs-keyword">int</span> main() {
    <span class="hljs-comment">// freopen("A.in","r",stdin);</span>
    <span class="hljs-keyword">int</span> T=read();
    <span class="hljs-keyword">while</span>(T--) {
        <span class="hljs-keyword">int</span> n,m;
        <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;

        <span class="hljs-keyword">int</span> s=n+m+<span class="hljs-number">1</span>,t=s+<span class="hljs-number">1</span>;
        S.mem(t);
        For(i,n) {
            <span class="hljs-keyword">int</span> k=read();
            <span class="hljs-keyword">while</span>(k--) {
                S.addedge2(i,n+read(),<span class="hljs-number">1</span>);
            }
        }
        For(i,n) S.addedge2(s,i,<span class="hljs-number">1</span>);
        For(i,m) S.addedge2(n+i,t,<span class="hljs-number">1</span>);
        MEM(b)
        <span class="hljs-keyword">int</span> p=S.max_flow(s,t);
        <span class="hljs-built_in">cout</span>&lt;&lt;p&lt;&lt;endl;
        S.init(t,n,m);

        S2.find_scc(t);
        S2.print(t,n,m);
        For(i,n) {
            vi v;
            For(j,m) 
                <span class="hljs-keyword">if</span> (b[i][j]) v.pb(j);
            <span class="hljs-keyword">int</span> sz=SI(v);
            <span class="hljs-built_in">cout</span>&lt;&lt;sz;
            Rep(i,sz) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">' '</span>&lt;&lt;v[i];<span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);
        }
        S2.mem(t);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h2 id="b-翻硬币">B. 翻硬币</h2> 
<p>用硬币玩游戏。他在n*m的矩阵中的每个小格中放一枚硬币，他想将所有的硬币都变成正面向上，但是，他给自己增加一些难度，他只能将整行或者整列的硬币都翻面。当然，他一点也不想做无用功，所以，他想知道当前的状态是否能通过一系列操作后使得所有硬币正面朝上。</p> 
<p>先翻第一列，然后看每行是否都一样</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;cmath&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstdio&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstring&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;map&gt;</span>
<span class="hljs-preprocessor">#include &lt;functional&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstdlib&gt;</span>
<span class="hljs-preprocessor">#include &lt;queue&gt;</span>
<span class="hljs-preprocessor">#include &lt;stack&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-preprocessor">#define For(i,n) for(int i=1;i&lt;=n;i++)</span>
<span class="hljs-preprocessor">#define Fork(i,k,n) for(int i=k;i&lt;=n;i++)</span>
<span class="hljs-preprocessor">#define Rep(i,n) for(int i=0;i&lt;n;i++)</span>
<span class="hljs-preprocessor">#define ForD(i,n) for(int i=n;i;i--)</span>
<span class="hljs-preprocessor">#define ForkD(i,k,n) for(int i=n;i&gt;=k;i--)</span>
<span class="hljs-preprocessor">#define RepD(i,n) for(int i=n;i&gt;=0;i--)</span>
<span class="hljs-preprocessor">#define Forp(x) for(int p=Pre[x];p;p=Next[p])</span>
<span class="hljs-preprocessor">#define Forpiter(x) for(int &amp;p=iter[x];p;p=Next[p])  </span>
<span class="hljs-preprocessor">#define Lson (o&lt;&lt;1)</span>
<span class="hljs-preprocessor">#define Rson ((o&lt;&lt;1)+1)</span>
<span class="hljs-preprocessor">#define MEM(a) memset(a,0,sizeof(a));</span>
<span class="hljs-preprocessor">#define MEMI(a) memset(a,127,sizeof(a));</span>
<span class="hljs-preprocessor">#define MEMi(a) memset(a,128,sizeof(a));</span>
<span class="hljs-preprocessor">#define INF (2139062143)</span>
<span class="hljs-preprocessor">#define F (100000007)</span>
<span class="hljs-preprocessor">#define pb push_back</span>
<span class="hljs-preprocessor">#define mp make_pair </span>
<span class="hljs-preprocessor">#define fi first</span>
<span class="hljs-preprocessor">#define se second</span>
<span class="hljs-preprocessor">#define vi vector&lt;int&gt; </span>
<span class="hljs-preprocessor">#define pi pair&lt;int,int&gt;</span>
<span class="hljs-preprocessor">#define SI(a) ((a).size())</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;
ll mul(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a*b)%F;}
ll add(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a+b)%F;}
ll sub(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a-b+llabs(a-b)/F*F+F)%F;}
<span class="hljs-keyword">void</span> upd(ll &amp;a,ll b){a=(a%F+b%F)%F;}
<span class="hljs-keyword">int</span> read()
{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch=getchar();
    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) {<!-- --><span class="hljs-keyword">if</span> (ch==<span class="hljs-string">'-'</span>) f=-<span class="hljs-number">1</span>; ch=getchar();}
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch)) { x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>; ch=getchar();}
    <span class="hljs-keyword">return</span> x*f;
} 
<span class="hljs-preprocessor">#define MAXN (1000000+10)</span>
<span class="hljs-keyword">int</span> main() {
    <span class="hljs-comment">// freopen("B.in","r",stdin);</span>
    <span class="hljs-keyword">int</span> T=read();
    <span class="hljs-keyword">while</span>(T--) {
        <span class="hljs-keyword">int</span> n=read(),m=read();
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;vi &gt;</span> v;
        Rep(i,n) {
            v.pb(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>(m) );
            Rep(j,m) <span class="hljs-built_in">cin</span>&gt;&gt;v[i][j];
        }
        Rep(j,m) <span class="hljs-keyword">if</span> (v[<span class="hljs-number">0</span>][j]) {
            Rep(i,n) v[i][j]^=<span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">bool</span> fl=<span class="hljs-number">0</span>;
        Rep(i,n) {
            For(j,m-<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (v[i][j]!=v[i][j-<span class="hljs-number">1</span>]) fl=<span class="hljs-number">1</span>;
        }
        <span class="hljs-built_in">puts</span>(fl?<span class="hljs-string">"NO"</span>:<span class="hljs-string">"YES"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h2 id="c-海豹的队列">C. 海豹的队列</h2> 
<p><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame"> 
   
   <span class="math" id="MathJax-Span-1" style="width: 1.683em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.358em; height: 0px; font-size: 123%;"><span style="position: absolute; clip: rect(1.412em 1000em 2.821em -0.431em); top: -2.274em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="msubsup" id="MathJax-Span-3"><span style="display: inline-block; position: relative; width: 1.304em; height: 0px;"><span style="position: absolute; clip: rect(1.412em 1000em 2.659em -0.431em); top: -2.274em; left: 0.003em;"><span class="mi" id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.057em;"></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span><span style="position: absolute; top: -2.057em; left: 0.545em;"><span class="texatom" id="MathJax-Span-5"><span class="mrow" id="MathJax-Span-6"><span class="mi" id="MathJax-Span-7" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span><span class="mo" id="MathJax-Span-8" style="font-size: 70.7%; font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-9" style="font-size: 70.7%; font-family: MathJax_Math-italic;">j</span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.279em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.47em; vertical-align: -0.53em;"></span></span> 
  </span><script type="math/tex" id="MathJax-Element-1">f_{i,j}</script>表示前i个换了j个数（且最后一个不换）的最优值，注意考虑开头，结尾的处理</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;cmath&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstdio&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstring&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;map&gt;</span>
<span class="hljs-preprocessor">#include &lt;functional&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstdlib&gt;</span>
<span class="hljs-preprocessor">#include &lt;queue&gt;</span>
<span class="hljs-preprocessor">#include &lt;stack&gt;</span>
<span class="hljs-keyword">using</span> namespace std;
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> For(i,n) for(int i=1;i&lt;=n;i++)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Fork(i,k,n) for(int i=k;i&lt;=n;i++)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Rep(i,n) for(int i=0;i&lt;n;i++)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ForD(i,n) for(int i=n;i;i--)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ForkD(i,k,n) for(int i=n;i&gt;=k;i--)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> RepD(i,n) for(int i=n;i&gt;=0;i--)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Forp(x) for(int p=Pre[x];p;p=Next[p])</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Forpiter(x) for(int &amp;p=iter[x];p;p=Next[p])  </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Lson (o&lt;&lt;1)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Rson ((o&lt;&lt;1)+1)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEM(a) memset(a,0,sizeof(a));</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEMI(a) memset(a,127,sizeof(a));</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEMi(a) memset(a,128,sizeof(a));</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> INF (2139062143)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> F (100000007)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> pb push_back</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> mp make_pair </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> fi first</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> se second</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> vi vector&lt;int&gt; </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> pi pair&lt;int,int&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> SI(a) ((a).size())</span>
typedef <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
typedef unsigned <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;
ll mul(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a*b)%F;}
ll add(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a+b)%F;}
ll sub(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a-b+llabs(a-b)/F*F+F)%F;}
<span class="hljs-keyword">void</span> upd(ll &amp;a,ll b){a=(a%F+b%F)%F;}
<span class="hljs-keyword">int</span> read()
{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch=getchar();
    <span class="hljs-keyword">while</span>(!isdigit(ch)) {<!-- --><span class="hljs-keyword">if</span> (ch==<span class="hljs-string">'-'</span>) f=-<span class="hljs-number">1</span>; ch=getchar();}
    <span class="hljs-keyword">while</span>(isdigit(ch)) { x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>; ch=getchar();}
    <span class="hljs-keyword">return</span> x*f;
} 
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAXN (510)</span>
<span class="hljs-keyword">int</span> n,k;
ll f[MAXN][MAXN];
ll a[MAXN];
ll Abs(ll x) {
    <span class="hljs-keyword">return</span> max(x,-x);
}
<span class="hljs-keyword">int</span> main() {
    <span class="hljs-comment">// freopen("C.in","r",stdin);</span>
    <span class="hljs-keyword">int</span> T=read();
    <span class="hljs-keyword">while</span>(T--) {
        n=read();k=read();k=min(k,n);
        MEMI(f)
        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
        <span class="hljs-comment">// For(i,k) f[i][i]=0;</span>

        For(i,n) a[i]=read();
        For(i,n) {
            Rep(j,min(i,k)+<span class="hljs-number">1</span>) {
                Fork(l,max(i-j-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),i-<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (j-(i-l-<span class="hljs-number">1</span>)&gt;=<span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">if</span> (!l) f[i][j]=<span class="hljs-number">0</span>;
                    ll p=Abs(a[l]-a[i]);
                    p=ceil((<span class="hljs-keyword">double</span>)p/(i-l-<span class="hljs-number">1</span>+<span class="hljs-number">1</span>));
                    f[i][j]=min(f[i][j],max(f[l][j-(i-l-<span class="hljs-number">1</span>)],p));
                }
            }
        }
        ll ans=f[n][k];
        <span class="hljs-keyword">while</span>(k&gt;=<span class="hljs-number">0</span>) {
            k--,n--;ans=min(ans,f[n][k]);
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }


    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h2 id="d-积性函数">D. 积性函数</h2> 
<p>定义函数f(n,0)=1;</p> 
<p>f(n,m)=sigma(d|n) f(d,m-1)*f(n/d,m-1)(m&gt;0)</p> 
<p>因子个数在2000左右，所以暴力。</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;cmath&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstdio&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstring&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;map&gt;</span>
<span class="hljs-preprocessor">#include &lt;functional&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstdlib&gt;</span>
<span class="hljs-preprocessor">#include &lt;queue&gt;</span>
<span class="hljs-preprocessor">#include &lt;stack&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-preprocessor">#define For(i,n) for(int i=1;i&lt;=n;i++)</span>
<span class="hljs-preprocessor">#define Fork(i,k,n) for(int i=k;i&lt;=n;i++)</span>
<span class="hljs-preprocessor">#define Rep(i,n) for(int i=0;i&lt;n;i++)</span>
<span class="hljs-preprocessor">#define ForD(i,n) for(int i=n;i;i--)</span>
<span class="hljs-preprocessor">#define ForkD(i,k,n) for(int i=n;i&gt;=k;i--)</span>
<span class="hljs-preprocessor">#define RepD(i,n) for(int i=n;i&gt;=0;i--)</span>
<span class="hljs-preprocessor">#define Forp(x) for(int p=Pre[x];p;p=Next[p])</span>
<span class="hljs-preprocessor">#define Forpiter(x) for(int &amp;p=iter[x];p;p=Next[p])  </span>
<span class="hljs-preprocessor">#define Lson (o&lt;&lt;1)</span>
<span class="hljs-preprocessor">#define Rson ((o&lt;&lt;1)+1)</span>
<span class="hljs-preprocessor">#define MEM(a) memset(a,0,sizeof(a));</span>
<span class="hljs-preprocessor">#define MEMI(a) memset(a,127,sizeof(a));</span>
<span class="hljs-preprocessor">#define MEMi(a) memset(a,128,sizeof(a));</span>
<span class="hljs-preprocessor">#define INF (2139062143)</span>
<span class="hljs-preprocessor">#define F (100000007)</span>
<span class="hljs-preprocessor">#define pb push_back</span>
<span class="hljs-preprocessor">#define mp make_pair </span>
<span class="hljs-preprocessor">#define fi first</span>
<span class="hljs-preprocessor">#define se second</span>
<span class="hljs-preprocessor">#define vi vector&lt;int&gt; </span>
<span class="hljs-preprocessor">#define ALL(x) (x).begin(),(x).end()</span>
<span class="hljs-preprocessor">#define pi pair&lt;int,int&gt;</span>
<span class="hljs-preprocessor">#define SI(a) ((a).size())</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;
ll mul(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a*b)%F;}
ll add(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a+b)%F;}
ll sub(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a-b+llabs(a-b)/F*F+F)%F;}
<span class="hljs-keyword">void</span> upd(ll &amp;a,ll b){a=(a%F+b%F)%F;}
<span class="hljs-keyword">int</span> read()
{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch=getchar();
    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) {<!-- --><span class="hljs-keyword">if</span> (ch==<span class="hljs-string">'-'</span>) f=-<span class="hljs-number">1</span>; ch=getchar();}
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch)) { x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>; ch=getchar();}
    <span class="hljs-keyword">return</span> x*f;
} 
<span class="hljs-preprocessor">#define MAXN (510)</span>
<span class="hljs-keyword">int</span> n,k;
ll f[<span class="hljs-number">30000</span>][<span class="hljs-number">60</span>];
ll a[MAXN];
ll Abs(ll x) {
    <span class="hljs-keyword">return</span> max(x,-x);
}
<span class="hljs-keyword">int</span> main() {
    <span class="hljs-comment">// freopen("D.in","r",stdin);</span>
    <span class="hljs-keyword">int</span> T=read();
    <span class="hljs-keyword">while</span>(T--) {
        ll n; <span class="hljs-keyword">int</span> m;
        <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;ll&gt;</span> v;
        <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i*i&lt;=n;i++) {
            <span class="hljs-keyword">if</span> (n%i==<span class="hljs-number">0</span>) {
                v.pb(i);
                <span class="hljs-keyword">if</span> (i*i!=n) v.pb(n/i);
            }
        }

        sort(ALL(v));
        <span class="hljs-keyword">int</span> l=SI(v);
        MEM(f)
        Rep(j,l) f[j][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;
        For(k,m)
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++)
            {
                <span class="hljs-keyword">int</span> t=i;
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++) <span class="hljs-keyword">if</span> (v[i]%v[j]==<span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">while</span>(v[i]/v[j]!=v[t]) --t;
                    f[i][k]+=f[j][k-<span class="hljs-number">1</span>]*f[t][k-<span class="hljs-number">1</span>]%<span class="hljs-number">10007</span>;
                    f[i][k]%=<span class="hljs-number">10007</span>;
                }
            }
        <span class="hljs-built_in">cout</span>&lt;&lt;f[l-<span class="hljs-number">1</span>][m]&lt;&lt;endl;        
    }


    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h2 id="e-金角大王的葫芦">E. 金角大王的葫芦</h2> 
<p>金角大王的水杯是紫金红葫芦。金角大王无聊的时候想到，如何求葫芦表面上两点间的最短路径呢？为了简化这个问题，我们把葫芦看做两个球体相交。最短路径指的是一个点移动达到另一个点的最短路径，可以在球体表面移动<strong>包括在其他球体内部的球面</strong>。虽然金角大王想知道答案，但是他太菜了不会做，你能帮帮他吗？</p> 
<p>没啥难度，可是就是过不了。 <br> 后来假定2个点不在一个球上就过了 <br> 不知道什么情况……先放着</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;cmath&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstdio&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstring&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;map&gt;</span>
<span class="hljs-preprocessor">#include &lt;functional&gt;</span>
<span class="hljs-preprocessor">#include &lt;cstdlib&gt;</span>
<span class="hljs-preprocessor">#include &lt;queue&gt;</span>
<span class="hljs-preprocessor">#include &lt;stack&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-preprocessor">#define For(i,n) for(int i=1;i&lt;=n;i++)</span>
<span class="hljs-preprocessor">#define Fork(i,k,n) for(int i=k;i&lt;=n;i++)</span>
<span class="hljs-preprocessor">#define Rep(i,n) for(int i=0;i&lt;n;i++)</span>
<span class="hljs-preprocessor">#define ForD(i,n) for(int i=n;i;i--)</span>
<span class="hljs-preprocessor">#define ForkD(i,k,n) for(int i=n;i&gt;=k;i--)</span>
<span class="hljs-preprocessor">#define RepD(i,n) for(int i=n;i&gt;=0;i--)</span>
<span class="hljs-preprocessor">#define Forp(x) for(int p=Pre[x];p;p=Next[p])</span>
<span class="hljs-preprocessor">#define Forpiter(x) for(int &amp;p=iter[x];p;p=Next[p])  </span>
<span class="hljs-preprocessor">#define Lson (o&lt;&lt;1)</span>
<span class="hljs-preprocessor">#define Rson ((o&lt;&lt;1)+1)</span>
<span class="hljs-preprocessor">#define MEM(a) memset(a,0,sizeof(a));</span>
<span class="hljs-preprocessor">#define MEMI(a) memset(a,127,sizeof(a));</span>
<span class="hljs-preprocessor">#define MEMi(a) memset(a,128,sizeof(a));</span>
<span class="hljs-preprocessor">#define INF (2139062143)</span>
<span class="hljs-preprocessor">#define F (100000007)</span>
<span class="hljs-preprocessor">#define pb push_back</span>
<span class="hljs-preprocessor">#define mp make_pair </span>
<span class="hljs-preprocessor">#define fi first</span>
<span class="hljs-preprocessor">#define se second</span>
<span class="hljs-preprocessor">#define vi vector&lt;int&gt; </span>
<span class="hljs-preprocessor">#define SI(a) ((a).size())</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;
ll mul(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a*b)%F;}
ll add(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a+b)%F;}
ll sub(ll a,ll b){<!-- --><span class="hljs-keyword">return</span> (a-b+llabs(a-b)/F*F+F)%F;}
<span class="hljs-keyword">void</span> upd(ll &amp;a,ll b){a=(a%F+b%F)%F;}
<span class="hljs-keyword">int</span> read()
{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch=getchar();
    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)) {<!-- --><span class="hljs-keyword">if</span> (ch==<span class="hljs-string">'-'</span>) f=-<span class="hljs-number">1</span>; ch=getchar();}
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch)) { x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>; ch=getchar();}
    <span class="hljs-keyword">return</span> x*f;
} 
<span class="hljs-keyword">class</span> node{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">double</span> x,y,z;
    node(<span class="hljs-keyword">double</span> _x,<span class="hljs-keyword">double</span> _y,<span class="hljs-keyword">double</span> _z):x(_x),y(_y),z(_z){}
};
<span class="hljs-keyword">double</span> pf(<span class="hljs-keyword">double</span> x)
{
    <span class="hljs-keyword">return</span> x*x;
}

<span class="hljs-keyword">double</span> d,r;
<span class="hljs-keyword">double</span> caldis(node o,node a,node b)
{
    <span class="hljs-keyword">double</span> l=<span class="hljs-built_in">sqrt</span>(pf(a.x-b.x)+pf(a.y-b.y)+pf(a.z-b.z));
    l/=<span class="hljs-number">2.0</span>;
    <span class="hljs-comment">// cout&lt;&lt;a.x&lt;&lt;' '&lt;&lt;a.y&lt;&lt;' '&lt;&lt;a.z&lt;&lt;endl;</span>
    <span class="hljs-comment">// cout&lt;&lt;b.x&lt;&lt;' '&lt;&lt;b.y&lt;&lt;' '&lt;&lt;b.z&lt;&lt;endl;</span>

    <span class="hljs-comment">// cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;endl;</span>
    <span class="hljs-keyword">double</span> ang=<span class="hljs-built_in">asin</span>(l/r)*<span class="hljs-number">2.0</span>;
    <span class="hljs-comment">// cout&lt;&lt;ang*r&lt;&lt;endl;</span>
    <span class="hljs-keyword">return</span> ang*r;
}

<span class="hljs-preprocessor">#define MAXN (1000000+10)</span>
<span class="hljs-keyword">double</span> pi=<span class="hljs-built_in">acos</span>(-<span class="hljs-number">1.0</span>);
<span class="hljs-keyword">double</span> get(<span class="hljs-keyword">double</span> &amp;x,<span class="hljs-keyword">double</span> &amp;y,<span class="hljs-keyword">double</span> &amp;z,<span class="hljs-keyword">double</span> t) {
    x=<span class="hljs-built_in">cos</span>(t),y=<span class="hljs-built_in">sin</span>(t),z=d/<span class="hljs-number">2</span>;
}
<span class="hljs-keyword">double</span> x0,Y0,z0,x3,y3,z3;
<span class="hljs-keyword">double</span> x1,Y1,z1;
<span class="hljs-keyword">double</span> x2,y2,z2;

<span class="hljs-keyword">double</span> f(<span class="hljs-keyword">double</span> t) {
    <span class="hljs-keyword">double</span> x,y,z;
    <span class="hljs-keyword">double</span> len=<span class="hljs-built_in">sqrt</span>(r*r-(d/<span class="hljs-number">2</span>)*(d/<span class="hljs-number">2</span>));
    get(x,y,z,t); x*=len,y*=len;
    node a(x,y,z),b(x1,Y1,z1),c(x2,y2,z2),o1(x0,Y0,z0),o2(x3,y3,z3);
    <span class="hljs-keyword">return</span> caldis(o1,a,b)+caldis(o2,c,a);
}

<span class="hljs-keyword">double</span> ans;
<span class="hljs-keyword">void</span> calc(<span class="hljs-keyword">double</span> l,<span class="hljs-keyword">double</span> r) {
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {
        <span class="hljs-keyword">double</span> m1=l+(r-l)/<span class="hljs-number">3</span>;
        <span class="hljs-keyword">double</span> m2=r-(r-l)/<span class="hljs-number">3</span>;
        <span class="hljs-keyword">double</span> p1=f(m1),p2=f(m2);
        <span class="hljs-keyword">if</span> (p1&lt;p2) r=m2;<span class="hljs-keyword">else</span> l=m1;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(r-l)&lt;<span class="hljs-number">1e-10</span>&amp;&amp;<span class="hljs-built_in">fabs</span>(p1-p2)&lt;<span class="hljs-number">1e-10</span>) <span class="hljs-keyword">return</span>;
        ans=min(ans,p1);
        ans=min(ans,p2);
    }
    <span class="hljs-keyword">return</span> ;
}
<span class="hljs-keyword">int</span> main() {
<span class="hljs-comment">//     freopen("jsk14900.in","r",stdin);</span>
    <span class="hljs-keyword">int</span> T=read();
    <span class="hljs-keyword">while</span>(T--) {
        <span class="hljs-built_in">cin</span>&gt;&gt;r&gt;&gt;d;
        <span class="hljs-built_in">cin</span>&gt;&gt;x1&gt;&gt;Y1&gt;&gt;z1&gt;&gt;x2&gt;&gt;y2&gt;&gt;z2;
        <span class="hljs-keyword">if</span> (z1&gt;z2) {
            swap(z1,z2);
            swap(x1,x2);
            swap(Y1,y2);
        }
        x0=<span class="hljs-number">0</span>,Y0=<span class="hljs-number">0</span>,z0=<span class="hljs-number">0</span>;
        x3=<span class="hljs-number">0</span>,y3=<span class="hljs-number">0</span>,z3=d;

        <span class="hljs-keyword">double</span> plc=d/<span class="hljs-number">2</span>;
        ans=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> ) { <span class="hljs-comment">//</span>
            ans=INF;
            <span class="hljs-keyword">double</span> l=-pi,r=pi,delta=<span class="hljs-number">2</span>*pi/<span class="hljs-number">30</span>;
            Rep(i,<span class="hljs-number">30</span>) {
                <span class="hljs-keyword">double</span> l1=l+i*delta,l2=l1+delta;
                calc(l1,l2);
            }
        } 
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (z1&lt;plc){
            ans=caldis(node(x0,Y0,z0),node(x1,Y1,z1),node(x2,y2,z2));
        } <span class="hljs-keyword">else</span> {
            ans=caldis(node(x3,y3,z3),node(x1,Y1,z1),node(x2,y2,z2));
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.8lf\n"</span>,ans);


    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h2 id="f-这个游戏很休闲么">F. 这个游戏很休闲么</h2> 
<p>left-right先生和up-down先生很喜欢玩游戏。但是由于他们智商不是很高，别的游戏对于他们来说都太耗脑力了，于是他们便找到一款非常休闲的游戏。这个游戏需要用到一个N行M列的表格，每个格子上写着 ’*’,‘.’ 这两个字符的其中一种。</p> 
<p>对于left-right先生来说，他要找到相邻的、在同一行上的一对 ’*’，将它们都变为 ’.’ ；</p> 
<p>对于up-down先生来说，他要找到相邻的、在同一列上的一对 ’*’，将它们都变为 ’.’ 。</p> 
<p>双方交替进行操作，当一方无法操作时，那一方便输了，对方获胜。</p> 
<p>这个游戏虽然很休闲，以至于双方在每一步上都能采取最佳策略进行游戏，然而由于他们堪忧的智商，他们无法对一个给定的表格判断谁胜谁负。现在他们找到了你，请你帮忙告诉他们这个游戏的最终结果。</p> 
<p>“毕竟，这个游戏很休闲的。”二位先生异口同声地说道。</p> 
<p>输入：</p> 
<p>第一行一个正整数T，表示一共有T组数据。</p> 
<p>每组数据的第一行为两个正整数N, M，分别表示表格的行数和列数。</p> 
<p>接下来N行，每行是一个长度为M的字符串，且仅由 ‘*’, ‘.’ 构成，这N行表示一个N行M列的表格。</p> 
<p>对于所有的数据，保证对于每一个 ’<em>’ 所在的联通块（两个格子之间有公共边，且两个格子均为 ’</em>’ ，即这两格联通），’*’ 的个数不会多于5个。</p> 
<p>数据范围：</p> 
<p>T &lt;= 100</p> 
<p>对于不超过10组数据，有 N, M &lt;= 1000；</p> 
<p>其他组的数据均满足N, M &lt;= 20 .</p> 
<p>输出：</p> 
<p>对于每一组数据，输出一行字符串（均不含引号）。</p> 
<p>如果是先手必胜，输出 “offensive” ;</p> 
<p>如果是后手必胜，输出 “defensive” ;</p> 
<p>如果无论先后手，均是left-right先生必胜，输出 “left-right” ;</p> 
<p>如果无论先后手，均是up-down先生必胜，输出 “up-down” . <br> 样例输入</p> 
<p>2 <br> 1 2 <br> ** <br> 5 5 <br> <em>*.</em>. <br> .<em>*.</em> <br> ….* <br> **… <br> .<em>*.</em></p> 
<p>样例输出</p> 
<p>left-right <br> defensive</p> 
<p>(⊙o⊙)…</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41a544016bf96fdc828891b5754ba12c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Zookeeper（十一）服务端处理，客户端回调</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bee2a7f069748cc4ebc1ea76d7c93da2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">lambda实体属性去重，对实体的某个属性进行去重</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>