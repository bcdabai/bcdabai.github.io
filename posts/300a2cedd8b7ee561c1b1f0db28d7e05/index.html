<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>五大常用算法—动态规划详解和经典题目(python) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="五大常用算法—动态规划详解和经典题目(python)" />
<meta property="og:description" content="一、基本概念 把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。
动态规划过程：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。
假设问题是由交叠的子问题所构成，我们就能够用动态规划技术来解决它。一般来说，这种子问题出自对给定问题求解的递推关系中，这个递推关系包括了同样问题的更小子问题的解。动态规划法建议，与其对交叠子问题一次重新的求解，不如把每一个较小子问题仅仅求解一次并把结果记录在表中（动态规划也是空间换时间的）。这样就能够从表中得到原始问题的解。
二、基本思想与策略 基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了实用的信息。
在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其它局部解。依次解决各子问题，最后一个子问题就是初始问题的解。
因为动态规划解决的问题多数有重叠子问题这个特点。为降低反复计算。对每个子问题仅仅解一次，将其不同阶段的不同状态保存在一个二维数组中。
与分治法最大的区别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。
三、适用的情况 能采用动态规划求解的问题的一般要具有3个性质：
（1）最优化原理：假设问题的最优解所包括的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
（2）无后效性：即某阶段状态一旦确定。就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响曾经的状态。仅仅与当前状态有关；
（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到（该性质并非动态规划适用的必要条件，可是假设没有这条性质，动态规划算法同其它算法相比就不具备优势）。
四、求解的基本步骤 动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。
初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解
(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
(3)确定决策并写出状态转移方程：状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。
只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。
确定状态：最后一步和转化子问题确定转移方程确定边界情况和初始条件确定好计算顺序 五、常见动态规划问题 1、找零钱问题（求最值动态规划）
有面值为1元、2元和7元的硬币若干枚，如何用最少的硬币凑够27元？
1.确定状态 最后一步：（最优策略中使用的最后一枚硬币ak）转化子问题：最少的硬币拼出更小的面值27-ak 2.转移方程
f[X] = min{f[X-2]&#43;1 , f[X-5]&#43;1 , f[x-7]&#43;1}3.初始条件和边界情况
f[0] = 0,如果不能拼出Y,f[Y] = 正无穷4.计算顺序
f[0],f[1],f[2], …代码实现 class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: # 开数组 27 个位置的数组 f = [float(&#34;inf&#34;)] * (amount&#43;1) # 初始条件：0元0种方法 f[0] = 0 n = len(coins) #f[1],f[2]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/300a2cedd8b7ee561c1b1f0db28d7e05/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-13T16:25:39+08:00" />
<meta property="article:modified_time" content="2020-03-13T16:25:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">五大常用算法—动态规划详解和经典题目(python)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h5><a id="_0"></a>一、基本概念</h5> 
<p>   把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。</p> 
<p>    <strong>动态规划过程</strong>：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。<br>     假设问题是由交叠的子问题所构成，我们就能够用动态规划技术来解决它。一般来说，这种子问题出自对给定问题求解的递推关系中，这个递推关系包括了同样问题的更小子问题的解。动态规划法建议，与其对交叠子问题一次重新的求解，不如把<strong>每一个较小子问题仅仅求解一次并把结果记录在表中</strong>（动态规划也是空间换时间的）。这样就能够从表中得到原始问题的解。</p> 
<h5><a id="_6"></a>二、基本思想与策略</h5> 
<p>    基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了实用的信息。</p> 
<p>   在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其它局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p> 
<p>   因为动态规划解决的问题多数有重叠子问题这个特点。为降低反复计算。对每个子问题仅仅解一次，将其不同阶段的不同状态保存在一个二维数组中。</p> 
<p>   与分治法最大的区别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p> 
<h5><a id="_15"></a>三、适用的情况</h5> 
<p>能采用动态规划求解的问题的一般要具有3个性质：</p> 
<p>（1）<strong>最优化原理</strong>：假设问题的最优解所包括的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p> 
<p>（2）<strong>无后效性</strong>：即某阶段状态一旦确定。就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响曾经的状态。仅仅与当前状态有关；</p> 
<p>（3）<strong>有重叠子问题</strong>：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到（该性质并非动态规划适用的必要条件，可是<strong>假设没有这条性质，动态规划算法同其它算法相比就不具备优势</strong>）。</p> 
<h5><a id="_25"></a>四、求解的基本步骤</h5> 
<p>    动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。</p> 
<ul><li>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</li></ul> 
<p>(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意<strong>划分后的阶段一定要是有序的或者是可排序的</strong>，否则问题就无法求解</p> 
<p>(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p> 
<p>(3)确定决策并写出状态转移方程：状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，<strong>根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</strong></p> 
<p>(4)寻找边界条件：给出的状态转移方程是一个递推式，<strong>需要一个递推的终止条件或边界条件。</strong></p> 
<p>只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p> 
<ul><li>确定状态：最后一步和转化子问题</li><li>确定转移方程</li><li>确定边界情况和初始条件</li><li>确定好计算顺序</li></ul> 
<h5><a id="_43"></a>五、常见动态规划问题</h5> 
<p><em><strong>1、找零钱问题（求最值动态规划）</strong></em></p> 
<p>有面值为1元、2元和7元的硬币若干枚，如何用最少的硬币凑够27元？</p> 
<ul><li>1.确定状态 
  <ul><li>最后一步：（最优策略中使用的最后一枚硬币ak）</li><li>转化子问题：最少的硬币拼出更小的面值27-ak</li></ul> </li><li>2.转移方程<br> f[X] = min{f[X-2]+1 , f[X-5]+1 , f[x-7]+1}</li><li>3.初始条件和边界情况<br> f[0] = 0,如果不能拼出Y,f[Y] = 正无穷</li><li>4.计算顺序<br> f[0],f[1],f[2], …</li><li>代码实现</li></ul> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> coins<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> amount<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
    	<span class="token comment"># 开数组 27 个位置的数组</span>
        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> 
        <span class="token comment"># 初始条件：0元0种方法</span>
        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>coins<span class="token punctuation">)</span>
        <span class="token comment">#f[1],f[2]....f[27]</span>
        <span class="token comment">#每个数组空间装当前零钱最优的拼凑结果</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        	<span class="token comment">#对每种零钱进行遍历</span>
        	<span class="token comment">#转移方程f[X] = min{f[X-2]+1 , f[X-5]+1 , f[x-7]+1}</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&gt;=</span>coins<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span>coins<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token comment">#如果凑不出目标数，返回-1</span>
        <span class="token keyword">if</span> f<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token comment">#返回次数</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token keyword">return</span> f<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre> 
<p><em><strong>2、走方格问题（计数型动态规划）</strong></em></p> 
<p>给定m行和n列网格，有一个机器人从左上角(0,0)出发，每一步可以向下或向右走一步，问多少种不同的方式走到右下角</p> 
<p>1.确定状态</p> 
<ul><li>最后一步：<br> 无论机器人用何种方式到达右下角，总有最后挪动的一步-向右或者向下<br> 右下角设为（m-1,n-1）,机器人在前一步一定是（m-2,n-2）</li><li>子问题：<br> 机器人有X种方式从左上角走到（m-2,n-1），Y种方式从左上角走到（m-1,n-2），则一共有X+Y种方式走到（m-1,n-1），一次类推<br> 两个变量，二维数组：设f[i][j]为机器人有多少种方式从左上角走到(i , j)</li></ul> 
<p>2.转移方程：对任意一个格子：f[i][j] = f[i-1][j]+f[i][j-1]</p> 
<p>3.初始条件和边界情况：</p> 
<ul><li>初始条件：f[0][0] = 1，只有一种方法到左上角</li><li>边界情况：i = 0,j=0的时候，则前一步只有一个方向过来f[i][]j] = 1</li></ul> 
<p>4.计算顺序<br> <img src="https://images2.imgbox.com/24/0f/ZhD6EbU6_o.png" alt="在这里插入图片描述"><br> 求f[m-1][n-1]（时间复杂度：O(MN) 空间复杂度(数组大小)：O(MN)）</p> 
<p>5.代码实现</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">def</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#m:行 ,n:列 5 4</span>
	<span class="token comment">#如果用([0]*m)*n会涉及到拷贝问题</span>
    f <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span>dtype<span class="token operator">=</span>np<span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
        	<span class="token comment">#边界为0的情况下均为1步</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">or</span> j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
            <span class="token comment">#转移方程</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
uniquePaths<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
</code></pre> 
<p><em><strong>3、青蛙过桥（存在型动态规划）</strong></em></p> 
<p>有n块石头分别在x轴的0,1，2，… ，n-1位置，一只青蛙在石头0处，如果青蛙在第i块石头上，它最多往右跳ai个石头。<br> 问青蛙是否能够调到石头n-1处</p> 
<p>1.确定状态</p> 
<ul><li>最后一步：青蛙能到达石头i；石头i到石头n-1的距离(即最后一步的距离)不能超过可跳跃的最大距离即：n-1-i&lt;=a[i]</li><li>子问题：这样原问题青蛙能否跳到石头n-1转化为规模更小(i&lt;n-1)的子问题青蛙能不能跳到石头i。<br> 状态：dp[j] = 青蛙能不能跳到石头j</li></ul> 
<p>2.转移方程：<br> 设状态为dp[j] = 青蛙能不能跳到石头j，有：<br> <img src="https://images2.imgbox.com/61/3b/BEcGca8c_o.png" alt="在这里插入图片描述"><br> 3.初始条件和边界情况<br> 初始条件：dp[0] = True，青蛙一开始就在石头0，无边界情况。</p> 
<p>4.计算顺序<br> 由初始条件dp[0] = True，<br> 计算dp[1],dp[2],…,dp[n-1]，结果：dp[n-1]<br> 时间复杂度：O(n^2)（用贪心算法复杂度为O(n)），空间复杂度：O(n)</p> 
<p>5.代码实现</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/451a04fa7883a4f8e6d853eacba95f06/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle对于误删误操作的数据进行恢复（flashback query、flashback drop、flashback table、flashback database）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/971c34c08d3cbf5072238c64de152e62/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小波分析、小波降噪matlab代码实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>