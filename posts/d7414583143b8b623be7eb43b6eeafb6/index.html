<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>02 文件和文件夹的操作 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="02 文件和文件夹的操作" />
<meta property="og:description" content="本来是想在bypy基础上搞个自动传输系统，都准备最后收拢了，突然bypy就不能使用了。
还是果断放弃靠不住的这个软件了。因为将来终究这个软件是不能适应网络变化的。直接使用云盘同步功能，虽然百度会去掉文件最后修改时间的信息，但是可以先将信息放在文件名字上，下载后再写回来就可以了。这样也大大简化了系统，只要完成自动存档功能和及时运送文件到云同步区就可以了。
不过通过这个练习还是对python有了较扎实的认识。对程序设计也有了更透彻的理解认识。能够操控多个程序同时运行，用txt文件联系不同 的程序。认识到程序设计应先将大思路理清，将目标制定后，就深入研究各个环节所需要的概念和对应的实体，并根据不同的特性设计各个环节，例如为了对抗网络失败，让一个子程序不断去循环，就算子程序死掉还可以再激活，只要网络一通就会去完成任务。根据云文件难以把控的实际情况设计了镜像映射的方案，将复杂的文件树映射成序列以列表和txt文本进行传输。为了确保传递的安全性，建立了各种日志，以便查阅分析。总而言之，为了完成这个ZDCS系统，还是展开了很广泛深入的研究。对程序和人的对话沟通也有了认识。虽然最终将只保留一个简化版本，但是积累了相当多有价值的知识。
文件操作是其中的核心任务之一。之前没注意到正则表达式，对字符串的处理多走了点弯路。文件及文件夹的处理非常繁琐无聊，不过再回首也权当做了一次很深入的练习吧。
# -*- coding:utf-8 -*-
import os
import time
import shutil
# 01 判断是否为汉字，copy网友的
def ischin(uchar):
&#34;&#34;&#34;判断一个unicode是否是汉字&#34;&#34;&#34;
if uchar &gt;= u&#39;\u4e00&#39; and uchar&lt;=u&#39;\u9fa5&#39;:
return True
else:
return False
##str.isalnum() #所有字符都是数字或者字母
##str.isalpha() #所有字符都是字母
##str.isdigit() #所有字符都是数字
##str.islower() #所有字符都是小写
##str.isupper() #所有字符都是大写
##str.istitle() #所有单词都是首字母大写
##str.isspace() #所有字符都是空白字符、\t、\n、\r
# 02 获取一个文件夹里的所有第一级子文件夹和文件
def DFfl(PATH):
XL = os.listdir(PATH )
XL.sort()
DLb = []
FLb = []
for patha in XL:
if os.path.splitext(patha)[1]==&#39;&#39;:
DLb.append(patha)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d7414583143b8b623be7eb43b6eeafb6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-25T20:13:03+08:00" />
<meta property="article:modified_time" content="2021-11-25T20:13:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">02 文件和文件夹的操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本来是想在bypy基础上搞个自动传输系统，都准备最后收拢了，突然bypy就不能使用了。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0b/74/QPTlX1jj_o.png"></p> 
<p>还是果断放弃靠不住的这个软件了。因为将来终究这个软件是不能适应网络变化的。直接使用云盘同步功能，虽然百度会去掉文件最后修改时间的信息，但是可以先将信息放在文件名字上，下载后再写回来就可以了。这样也大大简化了系统，只要完成自动存档功能和及时运送文件到云同步区就可以了。</p> 
<p>不过通过这个练习还是对python有了较扎实的认识。对程序设计也有了更透彻的理解认识。能够操控多个程序同时运行，用txt文件联系不同 的程序。认识到程序设计应先将大思路理清，将目标制定后，就深入研究各个环节所需要的概念和对应的实体，并根据不同的特性设计各个环节，例如为了对抗网络失败，让一个子程序不断去循环，就算子程序死掉还可以再激活，只要网络一通就会去完成任务。根据云文件难以把控的实际情况设计了镜像映射的方案，将复杂的文件树映射成序列以列表和txt文本进行传输。为了确保传递的安全性，建立了各种日志，以便查阅分析。总而言之，为了完成这个ZDCS系统，还是展开了很广泛深入的研究。对程序和人的对话沟通也有了认识。虽然最终将只保留一个简化版本，但是积累了相当多有价值的知识。</p> 
<p>文件操作是其中的核心任务之一。之前没注意到正则表达式，对字符串的处理多走了点弯路。文件及文件夹的处理非常繁琐无聊，不过再回首也权当做了一次很深入的练习吧。</p> 
<p># -*- coding:utf-8 -*-</p> 
<p>import os</p> 
<p>import time</p> 
<p>import shutil</p> 
<p></p> 
<p># 01 判断是否为汉字，copy网友的<br> def ischin(uchar):<br>         """判断一个unicode是否是汉字"""<br>         if uchar &gt;= u'\u4e00' and uchar&lt;=u'\u9fa5':<br>                 return True<br>         else:<br>                 return False</p> 
<p><br> ##str.isalnum() #所有字符都是数字或者字母<br> ##str.isalpha() #所有字符都是字母<br> ##str.isdigit() #所有字符都是数字<br> ##str.islower() #所有字符都是小写<br> ##str.isupper() #所有字符都是大写<br> ##str.istitle() #所有单词都是首字母大写<br> ##str.isspace() #所有字符都是空白字符、\t、\n、\r</p> 
<p></p> 
<p># 02 获取一个文件夹里的所有第一级子文件夹和文件</p> 
<p><br> def DFfl(PATH):</p> 
<p>    XL = os.listdir(PATH )</p> 
<p>    XL.sort()</p> 
<p>    DLb = []</p> 
<p>    FLb = []</p> 
<p><br>     for patha in XL:</p> 
<p>        if os.path.splitext(patha)[1]=='':</p> 
<p>            DLb.append(patha)<br>             <br>         else:</p> 
<p>            FLb.append(patha)</p> 
<p>##    print(XL)<br> ##    <br> ##    print(DLb)<br> ##<br> ##    print(FLb)<br>             <br>     return  DLb ,FLb</p> 
<p></p> 
<p><br> # 03  建立一个文件夹 的镜像，并写入其最后一次修改时间和文件大小。</p> 
<p></p> 
<p></p> 
<p>def JLjx(PAPH):</p> 
<p>    tuples =  os.walk(PAPH)</p> 
<p>    <br>     for tuple1 in tuples:</p> 
<p>##    print(tuple1,'\n')<br> ##        print(tuple1[0],'\n')</p> 
<p>##        print(tuple1[1],'\n')<br> ##        print(tuple1[2],'\n')</p> 
<p>        patha = str(tuple1[0])<br>     <br>         for name in tuple1[2]:</p> 
<p>            xx = os.stat(patha+'\\'+str(name))</p> 
<p>            wxx = xx.st_mtime</p> 
<p>            wxy = xx.st_size</p> 
<p>##            print(str(wxx))<br>     <br>             filea = open(patha+'\\'+str(name)+'.txt','w',encoding="utf-8")<br>         <br>             filea.write(str(wxx)+'\n'+str(wxy))<br>             <br>             filea.close()<br>         <br> ##        print(tuple1[0],'\n')</p> 
<p>##        print(tuple1[1],'\n')<br>     <br> ##        print(tuple1[2],'\n')    <br>         <br>         for name in tuple1[2]:</p> 
<p>            os.remove(patha+'\\'+str(name))</p> 
<p></p> 
<p># 04 输出一个文件夹所有各级文件夹和文件列表的 名字，虽不绝对，用于一般情况下的判定相等足矣          </p> 
<p><br> def MDFfl(PAPH):<br>     '''<br>     输出所有文件夹的名字列表和所有名字的列表</p> 
<p><br>     '''<br>     <br>     tuples =  os.walk(PAPH)<br>     <br>     RQ = []</p> 
<p>    SQ = []    </p> 
<p>    for tuple1 in tuples:</p> 
<p>##        print(tuple1[0],'\n')<br> ##<br> ##        print(tuple1[1],'\n')<br>         <br>         for iname in range(len(tuple1[1])):<br>             <br>             RQ.append(tuple1[1][iname])<br>         <br> ##        print(tuple1[2],'\n')<br>             <br>         for jname in range(len(tuple1[2])):<br>             </p> 
<p>           SQ.append(tuple1[2][jname])<br>         <br> ##    print(RQ)    <br>     </p> 
<p>##    print(SQ)<br>     <br>     return  RQ, SQ<br>  </p> 
<p># 05 将一个文件夹里所有文件的后缀去掉    </p> 
<p>def SChz(PAPH):</p> 
<p>    tuples =  os.walk(PAPH)</p> 
<p>    <br>     for tuple1 in tuples:</p> 
<p>##    print(tuple1,'\n')<br> ##        print(tuple1[0],'\n')</p> 
<p>##        print(tuple1[1],'\n')<br> ##        print(tuple1[2],'\n')</p> 
<p>        patha = str(tuple1[0])<br>                 <br>         <br>         for name in tuple1[2]:</p> 
<p>            sx=os.path.splitext(patha+'\\'+str(name))[0]#分离后缀<br>             <br>             os.chdir(patha)</p> 
<p>            os.rename(str(name),str(sx))</p> 
<p># 06 输出一个文件夹所有的路径列表<br>             <br> def LJlb(PAPH):</p> 
<p>    tuples = os.walk(PAPH)</p> 
<p>    LJlb = []<br>     <br>     for tuple1 in tuples:</p> 
<p>##        print(tuple1,'\n')<br> ##        <br> ##        print(tuple1[0],'\n')<br>         <br>         LJlb.append(tuple1[0])<br>         <br> ##<br> ##        print(tuple1[1],'\n')<br> ##        <br> ##        print(tuple1[2],'\n')</p> 
<p>##        print('*****************')<br> ##        <br> ##    print(LJlb)</p> 
<p>    return LJlb</p> 
<p><br> # 07 由指定文件夹path获得最后名字为Y的所有路径</p> 
<p>def LJmz(Y,PATH):</p> 
<p>    LBx = LJlb(PATH)</p> 
<p>    LBzf = []</p> 
<p>    xox = Y</p> 
<p>    for inchx in LBx:</p> 
<p>        if inchx.count(str(xox)) &gt; 0 and inchx[(-len(str(xox))):-1]+inchx[-1] == str(xox) :<br>        <br>         <br>             LBzf.append(inchx)<br>             <br> ##            print(LBzf)<br> ##<br> ##            print(inchx)    </p> 
<p>            <br>        <br>         else:</p> 
<p>            pass</p> 
<p>    #对LBzf按尖到根的顺序排列</p> 
<p>    Jhcn = set()</p> 
<p>    for kk in range(len(LBzf)):</p> 
<p>        ls = LBzf[kk].count(xox)</p> 
<p>        Jhcn.add(ls)</p> 
<p>##    print(Jhcn)</p> 
<p>    # 1) 获得最后名字为Y的路径含有Y的不同个数的指标集</p> 
<p>    Jhcn = list( Jhcn)</p> 
<p>    Jhcn.sort(reverse = True)</p> 
<p>##    print(Jhcn)</p> 
<p>    SLBzf = []</p> 
<p>    # 2) 把指标从最大到最小逐渐从原列表中抽出生成新的列表</p> 
<p>    for i in range(len(Jhcn)):</p> 
<p>        for xx in LBzf:</p> 
<p>            if xx.count(xox)== Jhcn[i] :</p> 
<p>                SLBzf.append(xx)<br>     <br>         <br> ##    print(SLBzf)<br>     <br>     return  SLBzf</p> 
<p>##LJmz('新建文件夹','D:/ZDCS系统/短期备份区/测试')</p> 
<p><br> # 08 将一个文件夹的全部文件的路径，最后修改时间，大小信息存储在文件和列表中</p> 
<p></p> 
<p>def  WBwj(PAPH,TXTPATH):</p> 
<p>    tuples =  os.walk(PAPH)<br>     <br>     LJlb = []<br>     <br>     for tuple1 in tuples:<br>         <br>       <br> ##        print(tuple1[2])</p> 
<p>##        print('xxxxxxxxxxxxxxxxxxxxxxxx')</p> 
<p>        patha = str(tuple1[0])</p> 
<p>      <br>         <br>         for name in tuple1[2]:</p> 
<p>            xx = os.stat(patha+'\\'+str(name))</p> 
<p>##            print(xx)     <br>             wxx = xx.st_mtime<br> ##            print(wxx)<br>             wxy = xx.st_size         <br> ##            print(wxy)<br> ##            LJlb.append(patha)<br>             <br>             LJlb.append(patha+'\\'+str(name)+'$'+str(wxx)+'$'+str(wxy))#作为路径符号标准的是\\</p> 
<p>##            print(LJlb)<br> ##<br> ##            print('0000000000')<br>                         <br>     LJlb.sort()</p> 
<p>    file = open(str(TXTPATH),'a+',encoding="utf-8")<br>     <br>     for i in range(len(LJlb)):  </p> 
<p>        file.write(str(LJlb[i])+'\n')</p> 
<p>    #记录文件的最后写入时间</p> 
<p>    aa = time.time()</p> 
<p>    file.write(str(aa))</p> 
<p>    file.close()    </p> 
<p>    return LJlb</p> 
<p><br> # 09 获得一个文件夹的全部文件及其路径<br> def  WFwj(PAPH):</p> 
<p>    tuples =  os.walk(PAPH)<br>     <br>     LJa = []</p> 
<p>    LJb = []</p> 
<p>    LJc = []    <br>     <br>     for tuple1 in tuples:</p> 
<p>        patha = str(tuple1[0])      <br>         <br>         for name in tuple1[2]:</p> 
<p>            LJa.append(patha)#路径索引号与文件名的索引号一致     <br>             <br>             LJb.append(str(name))</p> 
<p>            LJc.append(patha+'\\'+str(name))</p> 
<p>            <br>     <br>      </p> 
<p>    return LJa,LJb,LJc</p> 
<p></p> 
<p># 10 由指定文件夹path获得文件名为Y的所有文件名及路径</p> 
<p>def WFljm(Y,PATH):</p> 
<p>    LB = WFwj(PATH)</p> 
<p>    LBx =LB[1]#名字</p> 
<p>    LBy =LB[0]#路径<br>       </p> 
<p>    LBzf1 = []</p> 
<p>    LBzf2 = []</p> 
<p>    xox = Y</p> 
<p>    for i in range(len(LBx)):</p> 
<p>        ss = LBx[i]</p> 
<p>        if ss == str(xox) :<br>        <br>         <br>             LBzf1.append(LBx[i])</p> 
<p>            LBzf2.append(LBy[i])<br>             <br> ##            print(LBzf)<br> ##<br> ##            print(inchx)             <br>        <br>         else:</p> 
<p>            pass   <br>     <br>     <br>     return  LBzf1,LBzf2#第一个是文件名，第二个是路径</p> 
<p>##LJfz('AFFF图_t6.dwg','D:/ZDCS系统/短期备份区/测试/')</p> 
<p></p> 
<p><br> # 11 将文件夹里全部重名的文件夹和文件加上序号使之不重名且不改义</p> 
<p><br> def CLcm(PATH):</p> 
<p># 1)  先获取重名的文件夹名字</p> 
<p>    PAPHb = PATH</p> 
<p>    AL = MDFfl(PAPHb)</p> 
<p>    <br>  <br>     </p> 
<p>##    print(AL[0])</p> 
<p>    ChongD = set()</p> 
<p>    for xx in AL[0]:</p> 
<p>            if AL[0].count(xx)&gt;1:</p> 
<p>                    ChongD.add(xx)</p> 
<p>   <br>     ChongD = list(ChongD)</p> 
<p>    ChongD.sort()</p> 
<p>##    print(ChongD)</p> 
<p>    ChongDindex = []</p> 
<p>    for xx in ChongD:</p> 
<p>##        print(AL[0].count(xx))</p> 
<p>##        print(xx)</p> 
<p>        ChongDindex.append(AL[0].count(xx))<br>         </p> 
<p>        <br> ##    print(ChongDindex)</p> 
<p>#以上获取重名的文件夹名字和数量    </p> 
<p># 2) 先要将CHongD中的路径进行排序，不能从根部改名字，不然上面的同名文件夹修改时就找不到路径了</p> 
<p>#修改LJmz(y,PATH)函数，使它输出的路径按树尖到树根的顺序排列,先重命名树尖上的名字，就不会出现找不到路径的错误了</p> 
<p><br>     </p> 
<p># 3） 对文件夹名字进行修改</p> 
<p>    for ix in range(len(ChongD)):           <br>                     </p> 
<p>        LBx = LJmz(ChongD[ix],PATH)   </p> 
<p>        for jx in range(len(LBx)):<br>                 <br>            <br> ##            print(LBx[jx])</p> 
<p>##            print(jx)<br> ##            os.getcwd()</p> 
<p>##            print(os.getcwd())</p> 
<p>            ts = str(LBx[jx])</p> 
<p>            CHf = ts.split("/")#用"/"能将'测试'前面的裂开，但后面的不能。用"\\"能裂开'测试'后面的。                     <br>              #‘测试 ’就是我们操作对象所在的文件夹       </p> 
<p>           <br>             ALb = CHf[-1].split("\\")</p> 
<p>            del CHf[-1]<br>             <br>             CHf.extend(ALb)</p> 
<p>            del CHf[-1]            </p> 
<p>##            print(LBx[jx])</p> 
<p>            CHg = ('/').join(CHf)</p> 
<p>            os.chdir(str(CHg))</p> 
<p>##            print(os.getcwd())</p> 
<p>##            print(ts)</p> 
<p>            os.rename(str(LBx[jx]),str(LBx[jx])+'('+str(jx)+')')</p> 
<p><br>             </p> 
<p>#4)对文件的操作是相当的<br>             <br>     PAPHb = PATH</p> 
<p>    AL = MDFfl(PAPHb)            </p> 
<p>    ChongD = set()</p> 
<p>    for xx in AL[1]:</p> 
<p>            if AL[1].count(xx)&gt;1:</p> 
<p>                    ChongD.add(xx)</p> 
<p>   <br>     ChongD = list(ChongD)</p> 
<p>    ChongD.sort()   </p> 
<p>    ChongDindex = []</p> 
<p>    for xx in ChongD:</p> 
<p>##        print(AL[1].count(xx))</p> 
<p>##        print(xx)</p> 
<p>        ChongDindex.append(AL[1].count(xx))<br>         <br> ##    print('--------------------')   <br>         <br>     print(ChongD)<br>         <br>     print(ChongDindex)</p> 
<p>#以上获取重名的文件名字和数量    </p> 
<p># 2) 文件不用考虑排序改名</p> 
<p>    </p> 
<p># 3） 对重名文件名字进行修改</p> 
<p>    cmj = len(ChongD)</p> 
<p>    for ix in range(cmj):#不要为图方便将一些命令直接作用的函数表达放在循环结构中           <br>                     </p> 
<p>        LB = WFljm(ChongD[ix],PATH)<br> ##        print('2222222222222')<br>         print(LB)</p> 
<p>        <br>         for jx in range(len(LB[0])):<br>                 <br>            <br> ##            print(LB[0][jx])</p> 
<p>##            print(jx)<br> ##           <br>             os.chdir(str(LB[1][jx]))</p> 
<p>##            print(os.getcwd())</p> 
<p>           </p> 
<p>            os.rename(str(ChongD[ix]),'('+str(jx)+')'+str(ChongD[ix]))</p> 
<p>            </p> 
<p>            <br> ##<br> ##CLcm(PATHa)</p> 
<p># 12 获得一个文件夹的总字节数</p> 
<p>def WJdx(PAPH):</p> 
<p>    tuples = os.walk(PAPH)</p> 
<p>    LJb = []<br>     <br>     for tuple1 in tuples:</p> 
<p>##        print(tuple1,'\n')<br>         <br> ##        print(tuple1[0],'\n')<br>         <br>         for xch in tuple1[2]:</p> 
<p>            fileinfo = os.stat(str(tuple1[0])+'/'+str(xch))</p> 
<p>            xcc = fileinfo.st_size</p> 
<p>            LJb.append(xcc)<br>     num = 0<br>     <br>     for xi in LJb:</p> 
<p>        num = xi+num</p> 
<p>##    print(num)<br> ##<br> ##        print(tuple1[1],'\n')<br> ##        <br> ##        print(tuple1[2],'\n')</p> 
<p>##        print('*****************')<br> ##        <br>     <br>     return num</p> 
<p></p> 
<p><br> # 13 将一个文件夹的内容移动到另一个文件夹</p> 
<p></p> 
<p><br> def ZJmv(pathx,pathy):<br>     '''<br>         直接将一个文件夹里面的内容移动到另一个文件夹<br>     <br>         shutil.move主要是针对新建文件夹的，把一个文件夹里的内容复制到新建的文件夹<br>         <br>     '''<br>     Lb1 = DFfl(pathx)[0]      <br>     <br>     Lb2 = DFfl(pathx)[1]</p> 
<p>    for xi in Lb1:</p> 
<p>        shutil.move(pathx+'/'+str(xi),pathy+'/'+str(xi))</p> 
<p>    for xi in Lb2:</p> 
<p>        shutil.move(pathx+'/'+str(xi),pathy+'/'+str(xi))  <br>      <br>         </p> 
<p>##ZJmv('D:/ZDCS系统/工作区/测试','D:/ZDCS系统/人机对话区/新建文件夹')</p> 
<p># 14 将一个文件夹的内容复制到另一个文件夹</p> 
<p><br> def ZJcp(pathx,pathy):<br>     '''<br>         直接将一个文件夹里面的内容复制到另一个文件夹<br>     <br>         shutil.copy主要是针对新建文件夹的，把一个文件夹里的内容复制到新建的文件夹<br>         <br>     '''<br>     Lb1 = DFfl(pathx)[0]      <br>     <br>     Lb2 = DFfl(pathx)[1]</p> 
<p>    for xi in Lb1:</p> 
<p>        shutil.copytree(pathx+'/'+str(xi),pathy+'/'+str(xi))</p> 
<p>    for xi in Lb2:</p> 
<p>        shutil.copyfile(pathx+'/'+str(xi),pathy+'/'+str(xi))  <br>      <br> ##ZJcp('D:/ZDCS系统/工作区/测试','D:/ZDCS系统/人机对话区/新建文件夹')</p> 
<p>#15 对一个文件夹中的文件按超过10天无修改进行存档</p> 
<p>def CDwj(X):</p> 
<p>    pathm = X<br>     <br>     # 1）找出需要存档的文件夹</p> 
<p>    CWJL = []</p> 
<p>    for wjj in MKwjcz.DFfl(X)[0]:   </p> 
<p>    <br>         tuples = os.walk(str(X)+'/'+str(wjj))</p> 
<p>        LJb = []</p> 
<p>        ytime = time.time()</p> 
<p>        atime = time.localtime()<br>     <br>         for tuple1 in tuples:</p> 
<p>       <br>             for xch in tuple1[2]:</p> 
<p>                fileinfo = os.stat(str(tuple1[0])+'/'+str(xch))</p> 
<p>                xcc = fileinfo.st_mtime</p> 
<p>                LJb.append(xcc)<br>             <br>         LJb.sort()</p> 
<p>        <br>     <br>         if ytime - LJb[-1]  &gt; 10*24*3600:</p> 
<p>            CWJL.append(wjj)</p> 
<p>    print(CWJL) #查看所找到的文件夹是否正确<br>     <br>     # 2）对找出的文件夹存档<br>         </p> 
<p>    for cwjj in CWJL:</p> 
<p>        none = False              </p> 
<p>        for wjd in  MKwjcz.DFfl('D:/ZDCS系统/存档区')[0]:</p> 
<p>            if wjd == cwjj:#找到与要存档文件夹名字同名的文件夹名字</p> 
<p>                none = True<br>                 <br>             else :</p> 
<p>                pass</p> 
<p>            </p> 
<p>        if none:<br>             print('同名')<br>             <br>         <br> #================================       <br>             <br>             nonea = False</p> 
<p>            <br>                 #对这个同名文件夹的子文件夹序列(年度)进行分析</p> 
<p>            print(MKwjcz.DFfl('D:/ZDCS系统/存档区'+'/'+str(cwjj))[0])#如用wjd怎么会是2021？#因为wjd在改逻辑结构后并不在上面的for循环中顺序定义所以该wjd实际上变成别的值而非'同名a'</p> 
<p>            for wjjnian in MKwjcz.DFfl('D:/ZDCS系统/存档区'+'/'+str(cwjj))[0]:</p> 
<p>                print('wjjnian',wjjnian)</p> 
<p>                print('atime[0]',atime[0])</p> 
<p>                if str(atime[0]) == wjjnian :#要存档的文件夹所在的年与已有项目的年文件夹同</p> 
<p>                    print(MKwjcz.DFfl('D:/ZDCS系统/存档区'+'/'+str(cwjj))[0])</p> 
<p>                    nonea = True</p> 
<p>                    print(wjjnian)</p> 
<p>                    print(nonea)</p> 
<p>            if nonea:#'如果同年'</p> 
<p>                pass<br>             #-----------------------------------------</p> 
<p>                print('同年')</p> 
<p>                noneb = False</p> 
<p>                </p> 
<p>                #对这个同名的年文件夹的子文件夹（月度）进行分析</p> 
<p>                for wjjyue in MKwjcz.DFfl('D:/ZDCS系统/存档区'+'/'+str(cwjj)+'/'+str(wjjnian))[0]:</p> 
<p>                    if wjjyue == str(atime[1]):#要存档的文件夹已有当月的文件夹</p> 
<p>                        print('vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv')</p> 
<p>                        print('同月项目的名称和月份')<br>                         <br>                         print(str(cwjj))</p> 
<p>                        print(str(wjjnian))</p> 
<p>                        print(wjjyue)#虽然用过的名字wjjyue可以再使用并弃掉前者但在循环嵌套时会带来非常麻烦的错误难以查清</p> 
<p>                        noneb = True<br>                             <br>                 if noneb:                                <br>                 <br>                     #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p> 
<p>                    print('同月')<br>                                                    </p> 
<p>                    #要存档的工作区的这个文件夹是以项目名字命名的，存档要把它里面的子文件夹和文件放入该项目月文件夹<br>                     #但此时可能面临重名冲突，所以要先对该要存档文件夹进行不重名处理</p> 
<p>                    print('D:/ZDCS系统/存档区'+'/'+str(cwjj)+'/'+str(wjjnian)+'/'+str(wjjyue))</p> 
<p>                    print('D:/ZDCS系统/工作区/'+'xxx')<br>                     <br>                     shutil.copytree('D:/ZDCS系统/存档区'+'/'+str(cwjj)+'/'+str(atime[0])+'/'+str(atime[1]),'D:/ZDCS系统/工作区/'+'xxx')#存档区该项目当月文件复制到这里                            </p> 
<p>                    MKwjcz.CLcm('D:/ZDCS系统/工作区/')</p> 
<p>                    shutil.rmtree('D:/ZDCS系统/工作区/'+'xxx')#删除辅助文件                  </p> 
<p>                  <br>                     #将含有str(cwjj)的那个文件夹的全部内容移动到存档区的该月文件夹</p> 
<p>                    print('已运行到这里')<br>                     </p> 
<p>                    MKwjcz.ZJmv('D:/ZDCS系统/工作区/'+str(cwjj),'D:/ZDCS系统/存档区'+'/'+str(cwjj)+'/'+str(atime[0])+'/'+str(atime[1]))</p> 
<p>                    <br>                     <br>                     os.chdir('D:/ZDCS系统/工作区')</p> 
<p><br>                     os.rmdir(str(cwjj)) #直接删除就报错，使用了os.chdir('D:/ZDCS系统/工作区')就正常了<br>                     <br>                 #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    <br>                                                  <br>                 else:#新建月文件夹                    <br>                 <br>                     shutil.move(str(pathm)+'/'+str(cwjj),'D:/ZDCS系统/存档区'+'/'+str(cwjj)+'/'+str(wjjnian)+'/'+str(atime[1]))            <br>             #-----------------------------------------------------------------------------<br>             else:#新建年文件夹存档<br>             <br>                 shutil.move(str(pathm)+'/'+str(cwjj),'D:/ZDCS系统/存档区'+'/'+str(cwjj)+'/'+str(atime[0])+'/'+str(atime[1]))</p> 
<p>#==============================================<br>            </p> 
<p>        else:#新建项目文件夹存档            <br>             <br>             shutil.move(str(pathm)+'/'+str(cwjj),'D:/ZDCS系统/存档区'+'/'+str(cwjj)+'/'+str(atime[0])+'/'+str(atime[1]))<br>        <br>     print(CWJL)            <br>         <br>     return CWJL<br>     <br> # 16 将一个文件夹里的dwg文件按超过10天无修改转移到项目文件夹里</p> 
<p>def WJJwj(X):</p> 
<p>    pathm = X</p> 
<p><br>     # 0) 只对工作区dwg格式的文件存档</p> 
<p>    DWG = []</p> 
<p>    for si in MKwjcz.DFfl(X)[1]:</p> 
<p>        if os.path.splitext(si)[-1] == '.dwg':#只对dwg格式的文件存档</p> 
<p>            DWG.append(si)</p> 
<p>    # 1)把文件的操作转换为文件夹的操作<br>             <br>     CWJLy = [] #尽量不要共名</p> 
<p>    for wj in DWG:          <br>         </p> 
<p>        ytime = time.time()      <br>         <br>         atime = time.localtime()            <br>            </p> 
<p>        fileinfo = os.stat(str(pathm)+'/'+str(wj))</p> 
<p>        xcc = fileinfo.st_mtime<br>        <br>             <br>         if ytime - xcc &gt; 10*24*3600:</p> 
<p>            CWJLy.append(wj)</p> 
<p>            <br>     print('要存档的文件如下')<br>     <br>     print(CWJLy) #查看所找到的文件是否正确</p> 
<p>    # 2）从文件名中获得项目名称,为文件创立相应的文件夹</p> 
<p>    pattern = r'[\s*]'<br>     <br>     for xwj in CWJLy:<br>         <br>     </p> 
<p>        MingL = re.split(pattern,xwj)</p> 
<p>        XMing = MingL[0]</p> 
<p>        if os.path.splitext(XMing)[-1] == '':</p> 
<p>            print(XMing)</p> 
<p>            if os.path.exists(pathm+'/'+str(XMing)):</p> 
<p>                shutil.move(pathm+'/'+str(xwj),pathm+'/'+str(XMing)+'/'+str(xwj))</p> 
<p>                pass</p> 
<p>            else:</p> 
<p>                os.mkdir(pathm+'/'+str(XMing))</p> 
<p>                shutil.move(pathm+'/'+str(xwj),pathm+'/'+str(XMing)+'/'+str(xwj))</p> 
<p>        else:<br>             <br>             os.mkdir(pathm+'/'+str(os.path.splitext(XMing)[0]))<br>             <br>             shutil.move(pathm+'/'+str(xwj),pathm+'/'+str(os.path.splitext(XMing)[0]))</p> 
<p>            <br> ##patha = 'D:/ZDCS系统/工作区'<br> ##<br> ##WJJwj(patha)</p> 
<p>##patha = 'D:/ZDCS系统/工作区'<br> ##<br> ##CDwj(patha)</p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/76d86df4c335ae0245a9ea300348394e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TypeScript中枚举报错 ‘xx‘ is defined but never used</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c68b369aa24bd89d0be5606c799b6928/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">对‘pcl::KdTreeFLANN＜pcl::PointXYZ, flann::L2_Simple＜float＞ ＞::KdTreeFLANN(bool)’未定义的引用的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>