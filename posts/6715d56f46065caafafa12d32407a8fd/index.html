<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>实战：通讯录的实现(附带源码） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="实战：通讯录的实现(附带源码）" />
<meta property="og:description" content="前言： 今天我们的目标是，写出我们自己满意的通讯录。实现通讯录的五个功能：增，删，查，改，示，也就是增加联系人，删除联系人，查找联系人，修改联系人信息，展示联系人。那就让我们进入主题吧。
文件建立： 我们分别建立3个文件：一个头文件和两个源文件。
①.头文件Contact.h： 该文件是用于包含其它头文件，并且存放功能实现函数的函数声明。好处就是可以整合整个程序中所用到的全部头文件和函数声明，一目了然。并在引用时只需引用Contact.h头文件。
②.函数定义文件Contact.c： 这个文件主要是用于书写所有的程序功能实现的函数定义。一、将所有定义书写在一起方便我们进行阅读，修改；二来大大提升了程序的可移植性，当他人想要使用我们定义的函数时，只需将整个Contact.c文件发送给对方即可；最后也可以将其设置为静态库从而实现我们函数代码的隐藏。
③.工程测试文件test.c： 这文件里所书写的是我们程序主体部分，并对程序进行执行逻辑的编辑和检查。结合前面两个文件的使用，可以使得我们的程序逻辑变得清晰，既有利于我们进行程序的运行逻辑检查。
通讯录整体实现思路： 首先我们定义两个函数，menu为菜单函数，负责向玩家打印游戏菜单，Contact为通讯录功能函数，负责实现整个通讯录功能的实现。当程序开始编译运行后，首先执行菜单函数供玩家选择功能，接着执行Contact函数实现玩家选择的功能。
//菜单 void menu() { printf(&#34;*************************************\n&#34;); printf(&#34;*************************************\n&#34;); printf(&#34;*************************************\n&#34;); printf(&#34;*************************************\n&#34;); printf(&#34;*************************************\n&#34;); printf(&#34;*************************************\n&#34;); printf(&#34;*************************************\n&#34;); printf(&#34;*************************************\n&#34;); } //实现通讯录功能函数 void Contact() { } int main() { menu(); Contact(); return 0; } 同时，我们在使用通讯录时，往往会出现一次性添加、删除或修改多个联系人信息的场景，于是我们就需要让我们的程序多次循环执行：
void Contact() { int input = 0; do { menu(); printf(&#34;请您进行选择：&#34;); scanf(&#34;%d&#34;, &amp;input); switch (input) { case 1: break; case 2: break; case 3: break; case 4: break; case 5: break; case 0: printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6715d56f46065caafafa12d32407a8fd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-28T22:43:10+08:00" />
<meta property="article:modified_time" content="2023-02-28T22:43:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">实战：通讯录的实现(附带源码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style=""></p> 
 <h2 style="">前言：</h2> 
 <p style="text-indent:1.4em;">今天我们的目标是，写出我们自己满意的通讯录。实现通讯录的五个功能：增，删，查，改，示，也就是增加联系人，删除联系人，查找联系人，修改联系人信息，展示联系人。那就让我们进入主题吧。</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h2>文件建立：</h2></li></ol> 
 <p style="text-indent:1.4em;">我们分别建立3个文件：一个头文件和两个源文件。</p> 
 <h3 style="">①.头文件Contact.h：</h3> 
 <p style="text-indent:1.4em;">该文件是用于<span class="kdocs-bold" style="font-weight:bold;">包含其它头文件</span>，并且<span class="kdocs-bold" style="font-weight:bold;">存放功能实现函数的函数声明</span>。好处就是<span class="kdocs-color" style="color:#C21C13;">可以整合整个程序中所用到的全部头文件和函数声明，一目了然。并在引用时只需引用Contact.h头文件。</span></p> 
 <h3 style="">②.函数定义文件Contact.c：</h3> 
 <p style="text-indent:1.4em;">这个文件主要是用于<span class="kdocs-bold" style="font-weight:bold;">书写所有的程序功能实现的函数定义</span>。一、将所有定义书写在一起<span class="kdocs-color" style="color:#C21C13;">方便我们进行阅读</span>，修改；二来大大<span class="kdocs-color" style="color:#C21C13;">提升了程序的可移植性</span>，当他人想要使用我们定义的函数时，只需将整个Contact.c文件发送给对方即可；最后也可以将其设置为静态库<span class="kdocs-color" style="color:#C21C13;">从而实现我们函数代码的隐藏</span>。</p> 
 <h3 style="">③.工程测试文件test.c：</h3> 
 <p style="text-indent:1.4em;">这文件里所书写的是我们程序主体部分，并对程序进行执行逻辑的编辑和检查。结合前面两个文件的使用，可以使得我们的程序逻辑变得清晰，既有利于我们进行程序的运行逻辑检查。</p> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h2>通讯录整体实现思路：</h2></li></ol> 
 <p style="text-indent:1.4em;">首先我们定义两个函数，menu为<span class="kdocs-bold" style="font-weight:bold;">菜单函数</span>，负责<span class="kdocs-color" style="color:#C21C13;">向玩家打印游戏菜单</span>，Contact为<span class="kdocs-bold" style="font-weight:bold;">通讯录功能函数，</span>负责<span class="kdocs-color" style="color:#C21C13;">实现整个通讯录功能的实现</span>。当程序开始编译运行后，首先<span class="kdocs-bold" style="font-weight:bold;">执行菜单函数供玩家选择功能</span>，接着<span class="kdocs-bold" style="font-weight:bold;">执行Contact函数实现玩家选择的功能。</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">//菜单
void menu()
{
    printf("*************************************\n");
    printf("*************************************\n");
    printf("*************************************\n");
    printf("*************************************\n");
    printf("*************************************\n");
    printf("*************************************\n");
    printf("*************************************\n");
    printf("*************************************\n");


}

//实现通讯录功能函数
void Contact()
{

}
int main()
{
    menu();

    Contact();

    return 0;
}</code></pre> 
 <p style=""></p> 
 <p style="text-indent:1.4em;">同时，我们在使用通讯录时，往往会出现一次性添加、删除或修改多个联系人信息的场景，于是我们就需要让我们的程序多次循环执行：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void Contact()
{
    int input = 0;
    do
    {
        menu();
        printf("请您进行选择：");
        scanf("%d", &amp;input);
        switch (input)
        {
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        case 4:
            break;
        case 5:
            break;
        case 0:
            printf("正在退出程序\n")
            break;
        default：
            printf("您的选择有误，请重新选择\n"）;
        }
    } while (input);
}</code></pre> 
 <p style="text-indent:1.4em;">我们通过使用do...while循环语句，<span class="kdocs-bold" style="font-weight:bold;">保证了我们程序多次执行。</span>并且我们通过输入<span class="kdocs-bold" style="font-weight:bold;">值input作为循环判断条件，减少了变量创建从而节省了空间</span>，也避免了<span class="kdocs-bold" style="font-weight:bold;">因为输入错误导致直接跳出执行。</span>同时，通过借助switch分支语句，我们也<span class="kdocs-bold" style="font-weight:bold;">实现了对通讯录不同功能的调用和对输入选择的合法性检测。</span>(这里也可以用if语句实现，看个人喜好）</p> 
 <p style="">现在通过编译让我们来看看效果：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1470px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.176872%;height:0;"> 
    <img src="https://images2.imgbox.com/8f/65/zK31zI4S_o.png" style="margin-left:;display:block;width:1470px;margin-top:-52.176872%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><h2>menu菜单函数的实现：</h2></li></ol> 
 <p style="text-indent:1.4em;">在上面我们已经确定好了函数的主题主题实现逻辑，接下来就是实现各个功能模块。当然在实现功能模块之前我们先来实现向用户反馈通讯录功能的函数menu。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void menu()
{
    printf("*************************************\n");
    printf("************通讯录功能如下***********\n");
    printf("*************   1.Add   *************\n");
    printf("*************   2.Del   *************\n");
    printf("*************  3.Search *************\n");
    printf("*************  4.Modify *************\n");
    printf("*************   0.Exit  *************\n");
    printf("*************************************\n");


}</code></pre> 
 <p style="">我们来看看执行效果：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1470px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.176872%;height:0;"> 
    <img src="https://images2.imgbox.com/56/e8/hg8nQhFs_o.png" style="margin-left:;display:block;width:1470px;margin-top:-52.176872%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h2 style="">4.Contact函数逻辑：</h2> 
 <p style="text-indent:1.4em;">菜单打印好后，成勋的主题实现逻辑也就确定好了，接下来便是对我们通讯录的功能实现方式进行设计与编写了。</p> 
 <p style="text-indent:1.4em;">首先我们要<span class="kdocs-bold" style="font-weight:bold;">能清楚我们的操作对象</span>究竟是谁，我们可以想一想，我们平时在使用通讯录时，我们的操作对象应当是一个个<span class="kdocs-bold" style="font-weight:bold;">联系人，已经每一个联系人的相关信息</span>，于是我们可以想到，我们<span class="kdocs-bold" style="font-weight:bold;">需要一种类似数组一样可以存储相同类别的东西</span>，于是在这里，我们就使用结构体来进行实现：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">typedef struct PeoInfo
{
    char name[max_name];
    char sex[10];
    int age;
    char tele[20];
    char addr[max_addr];

}PeonInfo;</code></pre> 
 <p style="text-indent:1.4em;">我们在头文件Contact.h中定义一个名PeoInfo（people information）的结构体类型struct PeoInfo,并使用typedef关键字将该类型命名为PeoInfo，接着我们在结构体内部创建了<span class="kdocs-bold" style="font-weight:bold;">姓名，性别，年龄，联系方式和住址五个结构体成员，</span>以用于存储结构体变量的信息。</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;">于是在我们想要<span class="kdocs-bold" style="font-weight:bold;">执行功能之前，应当首先创建出一个用于储存联系人信息的结构体数组，并创建变量sz记录已经存入的联系人数量：</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void Contact()
{
    int input = 0;
    
    //创建能够容纳1000个联系人相关信息的结构体数组：
    PeoInfo data[1000];
    int sz = 0;
    do
    {
        menu();
        printf("请您进行选择：");
        scanf("%d", &amp;input);
        switch (input)
        {
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        case 4:
            break;
        case 5:
            break;
        case 0:
            printf("正在退出程序");
                break;
        default:
            printf("您的选择有误，请重新选择\n");
        }
    </code></pre> 
 <p style="text-indent:1.4em;">但是这样的方式在进行传参时，既要<span class="kdocs-bold" style="font-weight:bold;">传递数组又要传递变量的地址，还是有些繁琐</span>，所以我们就用一个结构体把他包装起来：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">typedef struct contact
{
    //创建能够容纳1000个联系人相关信息的结构体数组：
    PeoInfo data[Max];
    int sz;
}contact;</code></pre> 
 <p style="">并且为了便于之后对通讯录的修改我这边使用宏定义了几个值得最大值：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#define max_name 20
#define max_addr 30
#define Max 1000
#define max_tele 20</code></pre> 
 <p style="">并且我们还知道，枚举类型中各成员得为0开始依次递增，所以我们在使用一个枚举类型来是我们得选项对应用户得选择：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">enum Option
{
    Exit,
    Add,
    Del,
    Search,
    Modify,
    print
};</code></pre> 
 <p style="">有了这个枚举我们就可以把刚刚得代码改为：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">do
    {
        menu();
        printf("请您进行选择：");
        scanf("%d", &amp;input);
        switch (input)
        {
        case Add:
            break;
        case Del:
            break;
        case Search:
            break;
        case Modify:
            break;
        case Print:
            break;
        case Exit:
            printf("正在退出程序");
                break;
        default:
            printf("您的选择有误，请重新选择\n");
        }
    } while (input);</code></pre> 
 <p style="text-indent:1.4em;">这样通讯录得大致逻辑我们就搞定了，接下来就是各大功能的实现了。</p> 
 <h2 style="">5.Contact函数中得各个功能的实现：</h2> 
 <h3 style="">①.初始化通讯录：</h3> 
 <p style="text-indent:1.4em;">我们在创建好通讯录之后，<span class="kdocs-bold" style="font-weight:bold;">需要对创建好的通讯录进行初始化，否则内部得数据将为随机值而无法预测，导致程序得不合法：</span></p> 
 <p style="text-indent:1.4em;">在头文件声明初始化函数：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">//初始化函数
void InitContact(contact* p);</code></pre> 
 <p style="">创建通讯录和初始化：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">    //创建通讯录
    contact con;
    //初始化通讯录
    InitContact(&amp;con);</code></pre> 
 <p style="text-indent:1.4em;">我们<span class="kdocs-bold" style="font-weight:bold;">对通讯录得初始化是通过函数调用实现的，</span>所以在对通讯录结构体成员进行修改时是需要<span class="kdocs-bold" style="font-weight:bold;">通过结构体指针进行访问的</span>。</p> 
 <p style="text-indent:1.4em;">首先我们将统计数量的变量sz初始化为0；即表示最初的通讯录中的联系人信息为0还有既然没有联系人信息，为了避免随机值对程序造成影响，我们就通过使用之前讲过的menset函数将联系人信息data的数据全部初始化为0:</p> 
 <h3 style="">②.打印联系人信息函数：</h3> 
 <p style="text-indent:1.4em;">打印单个联系人信息很好处理，直接打印即可，因这里我们不需要对传入地址内的数据进行修改，所以在数组传参时，我们可以使用const对其进行修饰，并实现打印：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void PrintContact(const contact * p, int x)
{
    assert(p);
    printf(" 联系人 ：%4d\n", x + 1);
    printf(" 姓  名 ：&amp;s\n", p-&gt;data[x].name);
    printf(" 性  别 ：%s\n",p-&gt;data[x].sex);
    printf(" 年  龄 ：%d\n", p-&gt;data[x].name);
    printf("联系方式：%s\n", p-&gt;data[x].tele);
    printf("当前住址：%s\n", p-&gt;data[x].addr);

}</code></pre> 
 <h3 style="">③打印全部联系人信息函数：</h3> 
 <p style="text-indent:1.4em;">首先这个函数可以<span class="kdocs-bold" style="font-weight:bold;">作为单个功能，用于方便我们查看当前通讯录内的联系人存储信息，</span>再者我们在删除联系认识，需要<span class="kdocs-bold" style="font-weight:bold;">了解联系人的储存情况，进而准确的删除我们想要删除的特定联系人信息。</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void PrintAllContact(const contact* p)
{
    assert(p);
    printf("联系人 姓名                性别  年龄   联系方式      住址\n");
    int i = 0;
    for (i = 0; i &lt; p-&gt;sz; i++)
    {
        printf(" %04d  %-20s %-5s %-4d %-12s %-30s\n", i + 1, 
                p-&gt;data[i].name, p-&gt;data[i].sex, p-&gt;data[i].age,
                p-&gt;data[i].tele, p-&gt;data[i].addr);
    }
}
</code></pre> 
 <h3 style="">④增加联系信息函数：</h3> 
 <p style="text-indent:1.4em;">首先我们在函数调用时，因为我们要对内存中的数据进行实际的修改，所以使用传址调用，应当向函数传入存放结构体数组的地址（数组名为首元素地址）与计数变量数组的contact类型结构体变量con的地址：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">AddContact(&amp;Con);</code></pre> 
 <p style="text-indent:1.4em;">接着我们便对Addcontact函数功能实现进行设计。函数功能部分实现也很简单，<span class="kdocs-bold" style="font-weight:bold;">每次询问一项联系人信息，然后有用户输入该项信息，并向该联系人保存地址处存入信息。</span>但是宰割汽检仍有很多细节需要我们注意。要注意的第一个点就是信息<span class="kdocs-bold" style="font-weight:bold;">存入的地址</span>，我们<span class="kdocs-bold" style="font-weight:bold;">对于通讯录的访问是通过指针进行的，所以信息的存入地址一定是对应的存入地址，数组应当使用指针进行访问，变量则应该使用指针进行访问，：</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void AddContact(contact* p)
{
    printf("请输入联系人姓名：");
    scanf("%s", p-&gt;data[p-&gt;sz].name);
    printf("请输入联系人性别：");
    scanf("%s", p-&gt;data[p-&gt;sz].sex);
    printf("请输入联系人年龄：");
    scanf("%d", &amp;(p-&gt;data[p-&gt;sz].age));
    printf("请输入联系人联系方式：");
    scanf("%s", p-&gt;data[p-&gt;sz].tele);
    printf("请输入联系人的地址：");
    scanf("%s", p-&gt;data[p-&gt;sz].addr);
    PrintContact(p, p-&gt;sz);
    printf("联系人添加成功\n");
    p-&gt;sz++;

}</code></pre> 
 <p style="text-indent:1.4em;">并且我们还注意到<span class="kdocs-bold" style="font-weight:bold;">这里有一个很巧妙的设计，</span>那就是我们在进行访问时，数组的下标恰好与我们初始化时统计的变量sz相同，并且每一次添加完联系人我们都让sz++；这时候他又变成我们下一次需要访问的结构体数组的下标了。</p> 
 <p style="text-indent:1.4em;">而且我们进行存储前还应当进行一次判断，即判断容量是否满了，<span class="kdocs-bold" style="font-weight:bold;">如果已经满了，则应当提示用户没有足够的容量存储联系人，若没有则将用户存入的信息存入到对应位置并且反馈存入联系人的信息：</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void AddContact(contact* p)
{
    if (p-&gt;sz == Max)
    {
        printf("容量不足，无法存储");
    }
    else
    {
        printf("请输入联系人姓名：");
        scanf("%s", p-&gt;data[p-&gt;sz].name);
        printf("请输入联系人性别：");
        scanf("%s", p-&gt;data[p-&gt;sz].sex);
        printf("请输入联系人年龄：");
        scanf("%d", &amp;(p-&gt;data[p-&gt;sz].age));
        printf("请输入联系人联系方式：");
        scanf("%s", p-&gt;data[p-&gt;sz].tele);
        printf("请输入联系人的地址：");
        scanf("%s", p-&gt;data[p-&gt;sz].addr);
        PrintContact(p, p-&gt;sz);
        printf("联系人添加成功\n");
        p-&gt;sz++;
    }

}</code></pre> 
 <h3 style="">⑤删除联系人信息：</h3> 
 <p style="text-indent:1.4em;">在想要删除联系人信息时候，我们<span class="kdocs-bold" style="font-weight:bold;">首先应当对通讯录内容进行判断，如此时的通讯录中没有存储任何联系人的信息，则应当提示用户没有联系人信息,当通讯录保存有联系人信息时，则首先应将当前通讯录中所有联系人信息进行打印供用户确认，</span>当用户确认删除某一联系人信息时，允许用户通过输入联系人的编号来删除该联系人。</p> 
 <p style="padding-left:1.4em;">删除时，我们的实现方式是<span class="kdocs-bold" style="font-weight:bold;">让选中联系人的后一个联系人直接将其覆盖并以此类推，最后sz减一就可以了:</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void DelContact(contact* p)
{
    assert(p);
    int num = 0;
    if (p-&gt;sz == 0)
    {
        printf("当前通讯录没有联系人");
    }
    else
    {
        PrintAllContact(p);
        printf("请输入您想删除的联系人编号：");
        scanf("%d", &amp;num);
        int x = num - 1;
        if (0 &lt;= x &amp;&amp; x &lt; p-&gt;sz)
        {
            for (int j = x; j &lt; p-&gt;sz; j++)
            {
                p-&gt;data[j] = p-&gt;data[j + 1];
            }
            p-&gt;sz--;
            PrintAllContact(p);
        }
    }
}</code></pre> 
 <h3 style="">⑥查找联系人：</h3> 
 <p style="text-indent:1.4em;">查找联系人的逻辑很简单，我们只需要定义一个字符串，然后让用户输入想要查找的联系人的姓名，接着我们就可以将通讯录中的联系人姓名与用户输入姓名，进行比较，若相同就将下标传递给打印函数，若没有找到就提示不存在联系人：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void SearchContact(const contact* p)
{
    assert(p);
    char name[20] = { 0 };
    printf("请输入您想要查询的联系人姓名：");
    scanf("%s", name);
    int i = 0;
    int ret = 1;
    for (i = 0; i &lt; p-&gt;sz; i++)
    {
        int count = strcmp(p-&gt;data[i].name, name);
        if (count==0)
        {
            PrintContact(p, i);
            ret = 0;
            break;
        }

    }
    if (ret)
    {
        printf("未找到联系人\n");
    }
}</code></pre> 
 <h3 style="">⑦修改联系人信息：</h3> 
 <p style="text-indent:1.4em;">修改也很简单，首先我们同样<span class="kdocs-bold" style="font-weight:bold;">对通讯录中的内容进行判断，内容为空则提示通讯录中没有联系人信息，否则提示进行修改。</span></p> 
 <p style="text-indent:1.4em;">在修改时，首先打印当前通讯录全部信息供用户进行选择，用户可以通过联系人人编号选择修改目标（获取下标），并选择想要修改的内容，在通过switch语句或者if语句实现对目标内容修改，最后将修改后的信息反馈给用户：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">void ModifyContact(contact* p)
{
    assert(p);
    int x = 0;
    int input = 0;
    if (p-&gt;sz == 0)
    {
        printf("对不起，当前通讯录中没有联系人信息！\n");
    }
    else
    {
        PrintAllContact(p);
        printf("请输入您想要修改的联系人编号：&gt;");
        scanf("%d", &amp;x);
        PrintContact(p, x - 1);
        printf("当前支持修改的信息:\n");
        printf("1.Name\n");
        printf("2.Sex\n");
        printf("3.Age\n");
        printf("4.Tele\n");
        printf("5.Addr\n");
        printf("请选择您想要修改的信息：&gt;");
        scanf("%d", &amp;input);
        while (input)
        {
            switch (input)
            {
            case 1:
                printf("请输入联系人姓名：");
                scanf("%s", p-&gt;data[x - 1].name);
                printf("修改成功！\n");
                PrintContact(p, x - 1);
                input = 0;
                break;
            case 2:
                printf("请输入联系人性别：");
                scanf("%s", p-&gt;data[x - 1].sex);
                printf("修改成功！\n");
                PrintContact(p, x - 1);
                input = 0;
                break;
            case 3:
                printf("请输入联系人年龄：");
                scanf("%d", &amp;(p-&gt;data[x - 1].age));
                printf("修改成功！\n");
                PrintContact(p, x - 1);
                input = 0;
                break;
            case 4:
                printf("请输入联系人联系方式：");
                scanf("%s", p-&gt;data[x - 1].tele);
                printf("修改成功！\n");
                PrintContact(p, x - 1);
                input = 0;
                break;
            case 5:
                printf("请输入联系人住址：");
                scanf("%s", p-&gt;data[x - 1].addr);
                printf("修改成功！\n");
                PrintContact(p, x - 1);
                input = 0;
                break;
            default:
                printf("您的选择有误，请重新选择！\n");
                break;
            }
        }
    }
}</code></pre> 
 <h2 style="">总结：</h2> 
 <p style="text-indent:1.4em;">到这里，我们基础版通讯就算完成了，这基础版存在很多瑕疵，但随着我们深入学习就可以将这些瑕疵去除。本文仍有很多不足之处，欢迎各位随时批评指正。</p> 
 <p style="">全部代码：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">//Contact.h
#pragma once
#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;string.h&gt;

#define max_name 20
#define max_addr 30
#define Max 1000
#define max_tele 20

enum Option
{
    Exit,
    Add,
    Del,
    Search,
    Modify,
    Print
};
typedef struct PeoInfo
{
    char name[max_name];
    char sex[10];
    int age;
    char tele[max_tele];
    char addr[max_addr];

}PeoInfo;
typedef struct contact
{
    //创建能够容纳1000个联系人相关信息的结构体数组：
    PeoInfo data[Max];
    int sz;
}contact;

//初始化函数
void InitContact(contact* p);
//打印单个联系人函数：
void PrintContact(const contact* p, int x);
打印所有联系人函数
void PrintAllContact(const contact* p);
//增加联系人信息
void AddContact(contact* p);
//删除联系人
void DelContact(contact* p);
//修改联系人信息
void ModifyContact(contact* p);
//查找联系人：
void SearchContact(const contact* p);</code></pre> 
 <pre class="kdocs-cpp"><code class="language-cpp">//Contact.c
#define _CRT_SECURE_NO_WARNINGS 1
#include"Contact.h"
void InitContact(contact* p)
{
    p-&gt;sz = 0;
    memset(p-&gt;data, 0, sizeof(p-&gt;data));
}
void PrintContact(const contact * p, int x)
{
    assert(p);
    printf(" 联系人 ：%4d\n", x + 1);
    printf(" 姓  名 ：%s\n", p-&gt;data[x].name);
    printf(" 性  别 ：%s\n",p-&gt;data[x].sex);
    printf(" 年  龄 ：%d\n", p-&gt;data[x].age);
    printf("联系方式：%s\n", p-&gt;data[x].tele);
    printf("当前住址：%s\n", p-&gt;data[x].addr);

}
void PrintAllContact(const contact* p)
{
    assert(p);
    printf("联系人 姓名                性别  年龄   联系方式      住址\n");
    int i = 0;
    for (i = 0; i &lt; p-&gt;sz; i++)
    {
        printf(" %04d  %-20s %-5s %-4d %-12s %-30s\n", i + 1, p-&gt;data[i].name, p-&gt;data[i].sex, p-&gt;data[i].age, p-&gt;data[i].tele, p-&gt;data[i].addr);
    }
}
void AddContact(contact* p)
{
    if (p-&gt;sz == Max)
    {
        printf("容量不足，无法存储");
    }
    else
    {
        printf("请输入联系人姓名：");
        scanf("%s", p-&gt;data[p-&gt;sz].name);
        printf("请输入联系人性别：");
        scanf("%s", p-&gt;data[p-&gt;sz].sex);
        printf("请输入联系人年龄：");
        scanf("%d", &amp;(p-&gt;data[p-&gt;sz].age));
        printf("请输入联系人联系方式：");
        scanf("%s", p-&gt;data[p-&gt;sz].tele);
        printf("请输入联系人的地址：");
        scanf("%s", p-&gt;data[p-&gt;sz].addr);
        PrintContact(p, p-&gt;sz);
        printf("联系人添加成功\n");
        p-&gt;sz++;
    }

}
void DelContact(contact* p)
{
    assert(p);
    int num = 0;
    if (p-&gt;sz == 0)
    {
        printf("当前通讯录没有联系人");
    }
    else
    {
        PrintAllContact(p);
        printf("请输入您想删除的联系人编号：");
        scanf("%d", &amp;num);
        int x = num - 1;
        if (0 &lt;= x &amp;&amp; x &lt; p-&gt;sz)
        {
            for (int j = x; j &lt; p-&gt;sz; j++)
            {
                p-&gt;data[j] = p-&gt;data[j + 1];
            }
            p-&gt;sz--;
            PrintAllContact(p);
        }
    }
}

void SearchContact(const contact* p)
{
    assert(p);
    char name[20] = { 0 };
    printf("请输入您想要查询的联系人姓名：");
    scanf("%s", name);
    int i = 0;
    int ret = 1;
    for (i = 0; i &lt; p-&gt;sz; i++)
    {
        int count = strcmp(p-&gt;data[i].name, name);
        if (count==0)
        {
            PrintContact(p, i);
            ret = 0;
            break;
        }

    }
    if (ret)
    {
        printf("未找到联系人\n");
    }
}
void ModifyContact(contact* p)
{
    assert(p);
    int x = 0;
    int input = 0;
    if (p-&gt;sz == 0)
    {
        printf("对不起，当前通讯录中没有联系人信息！\n");
    }
    else
    {
        PrintAllContact(p);
        printf("请输入您想要修改的联系人编号：&gt;");
        scanf("%d", &amp;x);
        PrintContact(p, x - 1);
        printf("当前支持修改的信息:\n");
        printf("1.Name\n");
        printf("2.Sex\n");
        printf("3.Age\n");
        printf("4.Tele\n");
        printf("5.Addr\n");
        printf("请选择您想要修改的信息：&gt;");
        scanf("%d", &amp;input);
        while (input)
        {
            switch (input)
            {
            case 1:
                printf("请输入联系人姓名：");
                scanf("%s", p-&gt;data[x - 1].name);
                printf("修改成功！\n");
                PrintContact(p, x - 1);
                input = 0;
                break;
            case 2:
                printf("请输入联系人性别：");
                scanf("%s", p-&gt;data[x - 1].sex);
                printf("修改成功！\n");
                PrintContact(p, x - 1);
                input = 0;
                break;
            case 3:
                printf("请输入联系人年龄：");
                scanf("%d", &amp;(p-&gt;data[x - 1].age));
                printf("修改成功！\n");
                PrintContact(p, x - 1);
                input = 0;
                break;
            case 4:
                printf("请输入联系人联系方式：");
                scanf("%s", p-&gt;data[x - 1].tele);
                printf("修改成功！\n");
                PrintContact(p, x - 1);
                input = 0;
                break;
            case 5:
                printf("请输入联系人住址：");
                scanf("%s", p-&gt;data[x - 1].addr);
                printf("修改成功！\n");
                PrintContact(p, x - 1);
                input = 0;
                break;
            default:
                printf("您的选择有误，请重新选择！\n");
                break;
            }
        }
    }
}

</code></pre> 
 <pre class="kdocs-cpp"><code class="language-cpp">//text.c
#define _CRT_SECURE_NO_WARNINGS 1
#include"Contact.h"

//菜单
void menu()
{
    printf("*************************************\n");
    printf("************通讯录功能如下***********\n");
    printf("*************   1.Add   *************\n");
    printf("*************   2.Del   *************\n");
    printf("*************  3.Search *************\n");
    printf("*************  4.Modify *************\n");
    printf("*************   0.Exit  *************\n");
    printf("*************************************\n");


}

//实现通讯录功能函数
void Contact()
{
    int input = 0;
    //创建通讯录
    contact con;
    //初始化通讯录
    InitContact(&amp;con);
    do
    {
        menu();
        printf("请您进行选择：");
        scanf("%d", &amp;input);
        switch (input)
        {
        case Add:
            AddContact(&amp;con);
            break;
        case Del:
            DelContact(&amp;con);
            break;
        case Search:
            SearchContact(&amp;con);
            break;
        case Modify:
            ModifyContact(&amp;con);
            break;
        case Print:
            PrintAllContact(&amp;con);
            break;
        case Exit:
            printf("正在退出程序");
                break;
        default:
            printf("您的选择有误，请重新选择\n");
        }
    } while (input);

}
int main()
{

    Contact();

    return 0;
}</code></pre> 
 <blockquote class="kdocs-blockquote" style=""></blockquote> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4cd593f187e641d72fd86df005eda837/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python实现Dijkstra算法求解最短路径问题（Shortest Path Problem）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5d6d7978eeb435c3c9cbe6876d612d65/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决ubuntu 22.04上teamViewer/toDesk闪退等问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>