<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WPF入门0：WPF的基础知识 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WPF入门0：WPF的基础知识" />
<meta property="og:description" content="WPF入门0：WPF的基础知识 WPF 可创建动态的数据驱动的呈现系统。 系统的每一部分均可通过驱动行为的属性集来创建对象。 数据绑定是系统的基础部分，在每一层中均进行了集成。
传统的应用程序创建一个显示内容，然后绑定到某些数据。 在 WPF 中，控件的所有内容、显示内容的所有方面都是由某种类型的数据绑定生成的。 通过在按钮内部创建复合控件并将其显示内容绑定到按钮的内容属性，会显示按钮中的文本。
WPF体系结构图： PersentationFramework.dll包含WPF顶层的类型，包括哪些表示窗口、面板以及其他类型控件的类型。他还实现了高层编程抽象，如样式。开发人员直接使用的大部分类都来自这个程序集PresentationCore.dll包含了基础类型，如UIElement类和Visual类，所有形状类和控件类都继承自这两个类。如果不需要窗口和控件抽象层的全部特征，可以使用这一层，并且仍能用WPF的渲染引擎。WindowsBase.dll包含了更多基本要素，这些要素具有在WPF之外重用的潜能。milcore.dll是WPF渲染系统的核心，也是媒体集成层的基础。WindowsCodes.dll是一套提供图像支持的低级API(例如，处理、显示以及缩放位图与JPEG图像)Direct3D是一套地基API，WPF应用程序中的所有图形都是由它渲染User32用于决定哪些程序实际占有桌面的哪一部分。 WPF类层次结构图： 1.System.Threading.DispatcherObject类,通过继承此类，用户界面中的每个元素都可以检查代码是否在正确的线程上运行。
2.System.Windows.DependencyObject类，提供对依赖属性的支持。
在WPF中，主要通过属性与屏幕上的元素进行交往。在早期设计极阶段，wpf的设计者决定设计强大的属性模型，该模型支持许多特性，例如更改通知、默认值继承以及减少属性存储空间。最终结果就是依赖属性特性。
生成 WPF 时使用的主要体系结构原理之一是首选属性而不是方法或事件。 属性具有声明性，可更方便地指定用途而不是操作。 它还支持模型驱动或数据驱动的系统，以显示用户界面内容。 这种理念的预期效果是创建更多可以绑定到的属性，从而更好地控制应用程序的行为。
为了更加充分地利用由属性驱动的系统，需要一个比 CLR 提供的功能更丰富的属性系统。 这种丰富性的一个简单示例是更改通知。
若要实现双向绑定，需要绑定的双方支持更改通知。 若要使行为与属性值相关联，需要在属性值更改时收到通知。 Microsoft .NET Framework 具有一个 INotifyPropertyChange 接口，对象通过该接口可以发布更改通知，但该接口是可选的。
WPF 提供一个更丰富的属性系统，该属性系统从 DependencyObject 类型派生。
该属性系统实际是一个“依赖”属性系统，因为它会跟踪属性表达式之间的依赖关系，并在依赖关系更改时自动重新验证属性值。
例如，如果具有一个可继承的属性（如 FontSize），当继承该值的元素的父级发生属性更改时，系统会自动更新。
WPF 属性系统的基础是属性表达式的概念。 在 WPF 的第一个版本中，属性表达式系统是关闭的，表达式均作为框架的一部分提供。
表达式致使属性系统不具有数据绑定、样式调整或继承硬编码，而是由框架内后面的层来提供这些功能。
属性系统还提供属性值的稀疏存储。
因为对象可能有数十个（如果达不到上百个）属性，并且大部分值处于其默认状态（被继承、由样式设置等），所以并非对象的每个实例都需要具有在其上定义的每个属性的完全权重。
属性系统的最后一个新功能是附加属性的概念。 WPF 元素是基于组合和组件重用的原则生成的。 某些包含元素（如 Grid 布局元素）通常需要子元素上的其他数据才能控制其行为（如行/列信息）。
任何对象都可以为任何其他对象提供属性定义，而不是将所有这些属性与每个元素相关联。 这与 JavaScript 中的“expando”功能相似。
3.System.Windows.Media.Visual类，每个元素本质都是一个Visual对象，封闭绘图指令、绘画额外细节。
4.System.Windows.UIElement类，提供WPF本质特征的支持，如布局、输入、焦点、及事件。
UIElement 定义核心子系统，包括布局、输入和事件。
布局是 WPF 中的核心概念。 在许多系统中，可能有一组固定的布局模型（HTML 支持三种布局模型：流、绝对和表），也可能没有布局模型（User32 实际仅支持绝对定位）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6ead1f69787b1ef2f6775e36b509d8fb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-09T11:46:11+08:00" />
<meta property="article:modified_time" content="2022-10-09T11:46:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WPF入门0：WPF的基础知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="WPF0WPF_0"></a>WPF入门0：WPF的基础知识</h3> 
<p>WPF 可创建动态的数据驱动的呈现系统。 系统的每一部分均可通过驱动行为的属性集来创建对象。 数据绑定是系统的基础部分，在每一层中均进行了集成。</p> 
<p>传统的应用程序创建一个显示内容，然后绑定到某些数据。 在 WPF 中，控件的所有内容、显示内容的所有方面都是由某种类型的数据绑定生成的。 通过在按钮内部创建复合控件并将其显示内容绑定到按钮的内容属性，会显示按钮中的文本。</p> 
<h5><a id="WPF_4"></a>WPF体系结构图：</h5> 
<p><img src="https://images2.imgbox.com/3c/59/ssBKEDYc_o.png" alt="在这里插入图片描述"></p> 
<ul><li>PersentationFramework.dll包含WPF顶层的类型，包括哪些表示窗口、面板以及其他类型控件的类型。他还实现了高层编程抽象，如样式。开发人员直接使用的大部分类都来自这个程序集</li><li>PresentationCore.dll包含了基础类型，如UIElement类和Visual类，所有形状类和控件类都继承自这两个类。如果不需要窗口和控件抽象层的全部特征，可以使用这一层，并且仍能用WPF的渲染引擎。</li><li>WindowsBase.dll包含了更多基本要素，这些要素具有在WPF之外重用的潜能。</li><li>milcore.dll是WPF渲染系统的核心，也是媒体集成层的基础。</li><li>WindowsCodes.dll是一套提供图像支持的低级API(例如，处理、显示以及缩放位图与JPEG图像)</li><li>Direct3D是一套地基API，WPF应用程序中的所有图形都是由它渲染</li><li>User32用于决定哪些程序实际占有桌面的哪一部分。</li></ul> 
<h5><a id="WPF_15"></a>WPF类层次结构图：</h5> 
<p><img src="https://images2.imgbox.com/68/6b/ELErC4Kf_o.png" alt="在这里插入图片描述"><br> 1.System.Threading.DispatcherObject类,通过继承此类，用户界面中的每个元素都可以检查代码是否在正确的线程上运行。</p> 
<p>2.System.Windows.DependencyObject类，提供对依赖属性的支持。</p> 
<blockquote> 
 <p>在WPF中，主要通过属性与屏幕上的元素进行交往。在早期设计极阶段，wpf的设计者决定设计强大的属性模型，该模型支持许多特性，例如更改通知、默认值继承以及减少属性存储空间。最终结果就是依赖属性特性。<br> 生成 WPF 时使用的主要体系结构原理之一是首选属性而不是方法或事件。 属性具有声明性，可更方便地指定用途而不是操作。 它还支持模型驱动或数据驱动的系统，以显示用户界面内容。 这种理念的预期效果是创建更多可以绑定到的属性，从而更好地控制应用程序的行为。</p> 
</blockquote> 
<blockquote> 
 <p>为了更加充分地利用由属性驱动的系统，需要一个比 CLR 提供的功能更丰富的属性系统。 这种丰富性的一个简单示例是更改通知。<br> 若要实现双向绑定，需要绑定的双方支持更改通知。 若要使行为与属性值相关联，需要在属性值更改时收到通知。 Microsoft .NET Framework 具有一个 INotifyPropertyChange 接口，对象通过该接口可以发布更改通知，但该接口是可选的。</p> 
</blockquote> 
<blockquote> 
 <p>WPF 提供一个更丰富的属性系统，该属性系统从 DependencyObject 类型派生。<br> 该属性系统实际是一个“依赖”属性系统，因为它会跟踪属性表达式之间的依赖关系，并在依赖关系更改时自动重新验证属性值。<br> 例如，如果具有一个可继承的属性（如 FontSize），当继承该值的元素的父级发生属性更改时，系统会自动更新。</p> 
</blockquote> 
<blockquote> 
 <p>WPF 属性系统的基础是属性表达式的概念。 在 WPF 的第一个版本中，属性表达式系统是关闭的，表达式均作为框架的一部分提供。<br> 表达式致使属性系统不具有数据绑定、样式调整或继承硬编码，而是由框架内后面的层来提供这些功能。</p> 
</blockquote> 
<blockquote> 
 <p>属性系统还提供属性值的稀疏存储。<br> 因为对象可能有数十个（如果达不到上百个）属性，并且大部分值处于其默认状态（被继承、由样式设置等），所以并非对象的每个实例都需要具有在其上定义的每个属性的完全权重。</p> 
</blockquote> 
<blockquote> 
 <p>属性系统的最后一个新功能是附加属性的概念。 WPF 元素是基于组合和组件重用的原则生成的。 某些包含元素（如 Grid 布局元素）通常需要子元素上的其他数据才能控制其行为（如行/列信息）。<br> 任何对象都可以为任何其他对象提供属性定义，而不是将所有这些属性与每个元素相关联。 这与 JavaScript 中的“expando”功能相似。</p> 
</blockquote> 
<p>3.System.Windows.Media.Visual类，每个元素本质都是一个Visual对象，封闭绘图指令、绘画额外细节。</p> 
<p>4.System.Windows.UIElement类，提供WPF本质特征的支持，如布局、输入、焦点、及事件。</p> 
<blockquote> 
 <p>UIElement 定义核心子系统，包括布局、输入和事件。</p> 
</blockquote> 
<blockquote> 
 <p>布局是 WPF 中的核心概念。 在许多系统中，可能有一组固定的布局模型（HTML 支持三种布局模型：流、绝对和表），也可能没有布局模型（User32 实际仅支持绝对定位）。<br> WPF 先假设开发人员和设计人员需要灵活的可扩展布局模型，该模型可能是由属性值而不是命令性逻辑驱动的。 在 UIElement 级别，会引入布局的基本协定 - 具有 Measure 和 Arrange 阶段的两阶段模型。</p> 
</blockquote> 
<p>5.System.Windows.FrameworkElement类，是 WPF 框架级元素类，提供数据绑定、动画及样式的支持。</p> 
<ul><li>6.System.Windows.Controls.Control类，为字体、前背景色及模板提供支持。</li></ul> 
<blockquote> 
 <p>控件（Control）是可与用户进行交互的元素。如BUtton，texbox等，这些可与设置前景色、背景色提供了属性。也可以通过模板进行设置。<br> 控件的最重要功能是模板化。 如果将 WPF 的组合系统视为一个保留模式绘制系统，则控件可通过模板化以一种参数化的声明性方式描述其绘制。 ControlTemplate 实际上只是用于创建一组子元素的脚本，绑定到由控件提供的属性。</p> 
 <p>Control 提供一组常用属性，例如 Foreground、Background、Padding，模板作者可以使用这些常用属性来自定义控件的显示。<br> 控件的实现提供了数据模型和交互模型。 交互模型定义了一组命令（如窗口的“关闭”），以及到输入笔势的绑定（如单击窗口右上角的红叉）。<br> 数据模型提供了一组属性，用于自定义交互模型或自定义显示内容（由模板确定）。<br> 数据模型（属性）、交互模型（命令和事件）及显示模型（模板）之间的划分，可实现对控件的外观和行为的完全自定义。<br> 最常见的控件数据模型是内容模型。 如果查看 Button 之类的控件，会看到它具有一个 Object 类型的名为“Content”的属性。 在 Windows 窗体和 ASP.NET 中，此属性通常是一个字符串 - 不过，这会限制可以在按钮中添加的内容类型。 按钮的内容可以是简单的字符串、复杂的数据对象或整个元素树。 如果是数据对象，可以使用数据模板构造显示内容。</p> 
</blockquote> 
<ul><li>7.System.Windows.Controls.ContentControl类，所有具有单一内容类控件的基类。</li></ul> 
<blockquote> 
 <p>-ContentControl 类是所有具有单一内容控件的基类。</p> 
</blockquote> 
<ul><li>8.System.Windows.Controls.ItemsControl类，所有显示选项集合控件的基类。</li></ul> 
<blockquote> 
 <p>所有选项集合的基类，如ListBox、TreeView控件。</p> 
</blockquote> 
<p>9.System.Windows.Shapes.Shape类，基本形状类继承于此类。</p> 
<ul><li>10.System.Windows.Controls.Panel类，所有布局窗口的基类。</li></ul> 
<blockquote> 
 <ul><li>Panle类是所有的布局的基类，布局容器是可包含一个或者多个子元素、并按特定的规则对子元素进行排列的元素。</li></ul> 
</blockquote> 
<blockquote> 
 <p>Windows窗体编程中，窗体的每个可视化项都称为控件，在WPF中，情况不在如此，可视化内容被称为元素（element），只有部分元素是控件（控件是那些能够接收焦点并能与用户进行交互的元素）。更令人费解之处在于，许多元素是在System.Windows.Contrrols命名空间中定义的， 但是他们不是继承自System.Windows.Controls.Control类，并且不被认为是控件。Panle便是其中一个。</p> 
</blockquote> 
<h5><a id="XMAL_78"></a>XMAL的命名空间</h5> 
<pre><code class="prism language-css">  xmlns=<span class="token string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
    <span class="token property">xmlns</span><span class="token punctuation">:</span>x=<span class="token string">"http://schemas.microsoft.com/winfx/2006/xaml"</span>  
</code></pre> 
<p>所有元素的生命周期：<br> <img src="https://images2.imgbox.com/11/9e/IAGZjsWg_o.png" alt="在这里插入图片描述"></p> 
<p>//实例化：元素实例化，InitializeComponent()；</p> 
<p>1.Initialized：设置元素属性，应用样式及数据绑定后；</p> 
<p>2.Loaded：准备呈现后；</p> 
<p>3.Unloaded：释放元素后<br> 表1-2 Windows类的生命周期事件<br> <img src="https://images2.imgbox.com/70/8b/moD8AlJk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cc/ba/dsaRRZIA_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/92/31/TOOxoEin_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b156f02fe7702d5d3d4ade70c71f8e1b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java经典面试题整理及答案详解（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3c7a87a4aa58ddc3b80cc706cb3bc4a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">模型预测控制算法（MPC算法）底层逻辑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>