<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>史上最全的LED点灯程序，你都掌握了吗？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="史上最全的LED点灯程序，你都掌握了吗？" />
<meta property="og:description" content="摘要：你点亮过多少板子的LED灯呢？有很多小伙伴留言说讲一下STM32、FPGA、Liunx他们之间有什么不同。不同点很多，口说无凭，今天就来点亮一下STM32、FPGA和Liunx板子的LED灯，大家大致看一下点灯流程和点灯环境以及点灯流程，就能大概的了解一下三者的区别，可以有选择的去学习！
一、使用STM32点亮LED灯 STM32从字面上来理解ST是意法半导体，M是Microelectronics的缩写，32 表示32位，合起来理解，STM32就是指ST公司开发的32位微控制器。在如今的32 位控制器当中，STM32可以说是最璀璨的新星，它受宠若娇，大受工程师和市场的青睐，无芯能出其右。首先使用STM32电亮一个led灯，大家现在回过头来看是不是非常的简单。
STM32初始化流程
1、使能指定GPIO的时钟。
2、初始化GPIO，比如输出功能、上拉、速度等等。
3、STM32有的IO可以作为其它外设引脚，也就是IO复用，如果要将IO作为其它外设引脚使用的话就需要设置 IO 的复用功能。
4、最后设置GPIO输出高电平或者低电平。
1、新建工程 2、代码编写 //LED IO初始化 void LED_Init(void) { GPIO_InitTypeDef GPIO_InitStructure; RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);//使能GPIOF时钟 //GPIOF9,F10初始化设置 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10;//LED0和LED1对应IO口 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;//普通输出模式 GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉 GPIO_Init(GPIOF, &amp;GPIO_InitStructure);//初始化GPIO GPIO_SetBits(GPIOF,GPIO_Pin_9 | GPIO_Pin_10);//GPIOF9,F10设置高，灯灭 } 3、编译代码 4、配置下载器 烧录代码 二、使用FPGA点亮LED灯 FPGA(Field Programmable Gate Array，简称 FPGA)，译文：现场可编程门阵列，一种主要以数字电路为主的集成芯片，于1985年由Xilinx创始人之一 Ross Freeman发明，属于可编程逻辑器件PLD(Programmable Logic Device)的一种。真正意义上的第一颗FPGA芯片XC2064为Xilinx所发明，这个时间差不多比著名的摩尔定律晚20年左右，但是FPGA一经发明，后续的发展速度之快，超出大多数人的想象。
计数器是在FPGA设计中最常用的一种时序逻辑电路，根据计数器的计数值我们可以精确的计算出FPGA内部各种信号之间的时间关系，每个信号何时拉高、何时拉低、拉高多久、拉低多久都可以由计数器实现精确的控制。而让计数器计数的是由外部晶振产生的时钟，所以可以比较精准的控制具体需要计数的时间。计数器一般都是从0开始计数，计数到我们需要的值或者计数满溢出后清零，并可以进行不断的循环。
本例我们让计数器计数1s时间间隔，来实现led灯每隔1s闪烁一次的效果。
LED灯硬件原理图流水灯实验管脚分配 1、模块框图 模块框图输入输出信号描述 2、RTL代码的编写 开始RTL代码的编写，RTL代码编写出的模块叫RTL模块(后文中也称功能模块、可综合模块)。之所以叫RTL代码是因为用Verilog HDL在Resistances Transistors Logic（寄存器传输级逻辑）来描述硬件电路，RTL代码能够综合出真实的电路以实现我们设计的功能，区别于不可综合的仿真代码。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ef43dd03f695c44cb651f041a66b53fe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-12T07:50:00+08:00" />
<meta property="article:modified_time" content="2021-07-12T07:50:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">史上最全的LED点灯程序，你都掌握了吗？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align: justify"><strong>摘要</strong>：你点亮过多少板子的LED灯呢？有很多小伙伴留言说讲一下STM32、FPGA、Liunx他们之间有什么不同。不同点很多，口说无凭，今天就来点亮一下STM32、FPGA和Liunx板子的LED灯，大家大致看一下<strong>点灯流程</strong>和<strong>点灯环境</strong>以及<strong>点灯流程</strong>，就能大概的了解一下三者的区别，可以有选择的去学习！<img src="https://images2.imgbox.com/fe/5c/itWStKOI_o.png"><br></p> 
 <p style="text-align: left"><img src="https://images2.imgbox.com/8c/e4/Oe88ZH5k_o.gif"></p> 
 <h2>一、使用STM32点亮LED灯</h2> 
 <p style="text-align: justify">STM32从字面上来理解ST是意法半导体，M是Microelectronics的缩写，32 表示32位，合起来理解，STM32就是指ST公司开发的32位微控制器。在如今的32 位控制器当中，<strong>STM32可以说是最璀璨的新星，它受宠若娇，大受工程师和市场的青睐，无芯能出其右</strong>。首先使用STM32电亮一个led灯，大家现在回过头来看是不是非常的简单。</p> 
 <p style="text-align: justify"><strong>STM32初始化流程</strong></p> 
 <p style="text-align: justify">1、使能指定GPIO的时钟。</p> 
 <p style="text-align: justify">2、初始化GPIO，比如输出功能、上拉、速度等等。</p> 
 <p style="text-align: justify">3、STM32有的IO可以作为其它外设引脚，也就是IO复用，如果要将IO作为其它外设引脚使用的话就需要设置 IO 的复用功能。</p> 
 <p style="text-align: justify">4、最后设置GPIO输出高电平或者低电平。</p> 
 <h3>1、新建工程</h3> 
 <img src="https://images2.imgbox.com/3a/85/LjtmQNAX_o.png"> 
 <h3>2、代码编写</h3> 
 <pre class="has"><code class="language-go">//LED IO初始化
void LED_Init(void)
{      
  GPIO_InitTypeDef  GPIO_InitStructure;
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);//使能GPIOF时钟
  //GPIOF9,F10初始化设置
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10;//LED0和LED1对应IO口
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;//普通输出模式
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
  GPIO_Init(GPIOF, &amp;GPIO_InitStructure);//初始化GPIO 
  GPIO_SetBits(GPIOF,GPIO_Pin_9 | GPIO_Pin_10);//GPIOF9,F10设置高，灯灭
}
</code></pre> 
 <h3>3、编译代码</h3> 
 <img src="https://images2.imgbox.com/32/bd/dSgqKPeR_o.png"> 
 <h3>4、配置下载器</h3> 
 <img src="https://images2.imgbox.com/58/a2/dHphKRIi_o.png"> 
 <h3>烧录代码</h3> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/84/89/vtY9RT4z_o.png"></p> 
 <h2>二、使用FPGA点亮LED灯</h2> 
 <p style="text-align: justify">FPGA(Field Programmable Gate Array，简称 FPGA)，译文：现场可编程门阵列，一种主要以数字电路为主的集成芯片，于1985年由Xilinx创始人之一 Ross Freeman发明，属于可编程逻辑器件PLD(Programmable Logic Device)的一种。真正意义上的第一颗FPGA芯片XC2064为Xilinx所发明，这个时间差不多比著名的摩尔定律晚20年左右，但是FPGA一经发明，后续的发展速度之快，超出大多数人的想象。</p> 
 <p style="text-align: justify">计数器是在FPGA设计中最常用的一种<strong>时序逻</strong>辑电路，根据计数器的计数值我们可以精确的计算出FPGA内部各种信号之间的时间关系，每个信号何时拉高、何时拉低、拉高多久、拉低多久都可以由计数器实现精确的控制。而让<strong>计数器计数的是由外部晶振产生的时钟</strong>，所以可以比较精准的控制具体需要计数的时间。计数器一般都是从0开始计数，计数到我们需要的值或者计数满溢出后清零，并可以进行不断的循环。</p> 
 <p style="text-align: justify">本例我们让计数器计数1s时间间隔，来实现led灯每隔1s闪烁一次的效果。</p> 
 <table><tbody><tr><td><img src="https://images2.imgbox.com/fc/15/PLOnIN7o_o.png">LED灯硬件原理图</td><td><img src="https://images2.imgbox.com/06/22/AricYK8Y_o.png">流水灯实验管脚分配</td></tr></tbody></table> 
 <h3>1、模块框图</h3> 
 <table><tbody><tr><td><img src="https://images2.imgbox.com/78/a4/abYBpdF0_o.png"> 模块框图</td><td><img src="https://images2.imgbox.com/8c/99/BQppMkwc_o.png">输入输出信号描述</td></tr></tbody></table> 
 <h3>2、RTL代码的编写</h3> 
 <p>开始RTL代码的编写，RTL代码编写出的模块叫RTL模块(后文中也称<strong>功能模块</strong>、可综合模块)。之所以叫RTL代码是因为用Verilog HDL在Resistances Transistors Logic（寄存器传输级逻辑）来描述硬件电路，<strong>RTL代码能够综合出真实的电路以实现我们设计的功能</strong>，区别于不可综合的仿真代码。</p> 
 <pre class="has"><code class="language-go">`timescale  1ns/1ns
//带标志信号的计数器
module  counter
#(
    parameter   CNT_MAX = 25'd24_999_999
)
(
    input   wire    sys_clk     ,   //系统时钟50Mhz
    input   wire    sys_rst_n   ,   //全局复位
    output  reg     led_out         //输出控制led灯
);

reg     [24:0]  cnt;       //经计算得需要25位宽的寄存器才够500ms
reg             cnt_flag;

//cnt:计数器计数,当计数到CNT_MAX的值时清零
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1'b0)
        cnt &lt;= 25'b0;
    else    if(cnt &lt; CNT_MAX)
         cnt &lt;= cnt + 1'b1;
    else
       cnt &lt;= 25'b0;
//cnt_flag:计数到最大值产生的标志信号
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1'b0)
        cnt_flag &lt;= 1'b0;
    else    if(cnt == CNT_MAX - 1'b1)
        cnt_flag &lt;= 1'b1;
    else
        cnt_flag &lt;= 1'b0;
//led_out:输出控制一个LED灯,每当计数满标志信号有效时取反
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1'b0)
        led_out &lt;= 1'b0;
    else    if(cnt_flag == 1'b1)
        led_out &lt;= ~led_out;
endmodule
</code></pre> 
 <h3>3、代码的分析和综合</h3> 
 <img src="https://images2.imgbox.com/1b/3a/fkZahP8H_o.png"> 
 <h3>4、 查看RTL视图</h3> 
 <img src="https://images2.imgbox.com/96/cd/ijmHdMoy_o.png"> 
 <h3>5、Testbench代码的编写</h3> 
 <pre class="has"><code class="language-go">`timescale  1ns/1ns
module  tb_counter();


//wire  define
wire            led_out     ;

//reg   define
reg             sys_clk     ;
reg             sys_rst_n   ;

//初始化系统时钟、全局复位
initial begin
    sys_clk    = 1'b1;
    sys_rst_n &lt;= 1'b0;
    #20
    sys_rst_n &lt;= 1'b1;
end

//sys_clk:模拟系统时钟，每10ns电平翻转一次，周期为20ns，频率为50Mhz
always #10 sys_clk = ~sys_clk;

initial begin
    $timeformat(-9, 0, "ns", 6);
    $monitor("@time %t: led_out=%b", $time, led_out);
end

//------------- counter_inst --------------
counter
#(
    .CNT_MAX    (25'd24     ) 
)
counter_inst
(
    .sys_clk    (sys_clk    ),  //input     sys_clk
    .sys_rst_n  (sys_rst_n  ),  //input     sys_rst_n

    .led_out    (led_out    )   //output    led_out
);
endmodule

</code></pre> 
 <h3>6、ModelSim仿真波形</h3> 
 <img src="https://images2.imgbox.com/6b/86/r6VY26Je_o.png"> 
 <img src="https://images2.imgbox.com/ed/9e/DEBEj0DC_o.png"> 
 <h3>7、上板验证</h3> 
 <img src="https://images2.imgbox.com/f0/a4/ChFLoFYS_o.png"> 
 <img src="https://images2.imgbox.com/1a/2d/nloaDdNG_o.png"> 
 <p>程序下载完毕后，会看到板卡LED0不断闪烁，时间间隔为1秒。</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/3a/cd/KrFaV2TU_o.png"></p> 
 <br> 
 <h2>三、使用I.MX6ULL IO点亮LED</h2> 
 <p>嵌入式linux学习者大体可以分为两类，一类是进阶用户，主要指已经有大量mcu工作经验的开发者， 他们希望进阶到更有难度，薪资更高的mpu开发中去。另一类则是学生用户，主要是刚开始接触嵌入式开发的大学生群体。</p> 
 <p>I.MX应用处理器包括I.MX8、I.MX7、I.MX6及I.MX28系列，被广泛应用于工业控制、汽车电子领域，久经市场考验。而且它的产品线非常丰富，用户熟悉其中一款产品后就能非常方便地迁移至不同的平台。</p> 
 <p>一般拿到一款全新的芯片，第一个要做的事情的就是驱动其GPIO，控制其GPIO输出高低电平，我们学习I.MX6U也一样的，先来学习一下I.MX6U的GPIO。在学习I.MX6U的GPIO之前，我们可以对比一下STM32的GPIO初始化(如果没有学过 STM32 就不用回顾了)，我们以最常见的STM32F103为例来看一下STM32的GPIO初始化，示例代码如下：</p> 
 <pre class="has"><code class="language-go">void LED_Init(void)
{
 GPIO_InitTypeDef GPIO_InitStructure;
 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);//使能 PB 端口时钟
 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //PB5 端口配置
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出
 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO 口速度
 GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //根据设定参数初始化 GPIOB.5
 GPIO_SetBits(GPIOB,GPIO_Pin_5); //PB.5 输出高
}
</code></pre> 
 <p><strong>STM32初始化流程</strong></p> 
 <p>1、使能指定GPIO的时钟。</p> 
 <p>2、初始化 GPIO，比如输出功能、上拉、速度等等。</p> 
 <p>3、STM32 有的 IO 可以作为其它外设引脚，也就是 IO 复用，如果要将 IO 作为其它外设引脚使用的话就需要设置 IO 的复用功能。</p> 
 <p>4、最后设置GPIO输出高电平或者低电平。</p> 
 <p>I.MX6U的GPIO一共有5组：<code>GPIO1、GPIO2、GPIO3、GPIO4和GPIO5</code>，其中GPIO1有32个IO，GPIO2有22个IO，GPIO3有29个IO、GPIO4有29个IO，GPIO5最少，只有12个IO，这样一共有<code>124个GPIO</code>。</p> 
 <p><strong>I.MX6ULL IO初始化流程</strong></p> 
 <p>1、使能时钟，<code>CCGR0—CCGR6</code>这7个寄存器控制着6ULL所有外设时钟的使能。为了简单，设置<code>CCGR0~CCGR6这7</code>个寄存器全部为<code>0XFFFFFFFF</code>，相当于使能所有外设时钟。</p> 
 <p>2、IO复用，将寄存器<code>IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</code>的<code>bit3~0</code>设置为<code>0101=5</code>，这样<code>GPIO1_IO03</code>就复用为<code>GPIO</code>。</p> 
 <p>3、寄存器<code>IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03</code>是设置<code>GPIO1_IO03</code>的电气属性。包括压摆率、速度、驱动能力、开漏、上下拉等。</p> 
 <p>4、配置<code>GPIO功</code>能，设置输入输出。设置<code>GPIO1_DR</code>寄存器bit3为1，也就是设置为输出模式。设置<code>GPIO1_DR</code>寄存器的<code>bit3</code>，为1表示输出高电平，为0表示输出低电平。</p> 
 <p>汇编由一条一条指令构成，指令就涉及到汇编指令。</p> 
 <pre class="has"><code class="language-go">Int a，b;
a=b;
</code></pre> 
 <p>假设a地址为0X20，b地址为0x30</p> 
 <pre class="has"><code class="language-go">LDR R0, =0X30
LDR R1, [R0]
LDR R0, =0X20
STR R1, [R0]
</code></pre> 
 <p>我们在使用汇编编写驱动的时候最常用的就是<code>LDR</code>和<code>STR</code>这两个指令。</p> 
 <h3>1、新建工程</h3> 
 <p>新建工程文件夹</p> 
 <img src="https://images2.imgbox.com/24/6d/896AI2tR_o.png"> 
 <figcaption>
   新建裸机驱动文件夹 
 </figcaption> 
 <img src="https://images2.imgbox.com/6a/af/Xf393QOE_o.png"> 
 <figcaption>
   新建LED灯文件夹 
 </figcaption> 
 <h3>2、在VSCode中编写代码</h3> 
 <p>ubuntu中我们使用的是VScode编辑器来写代码，跟在windows中新建项目一样，新建项目、保存工作区，然后编写代码。</p> 
 <img src="https://images2.imgbox.com/91/1e/d9haEn2L_o.png"> 
 <h3>3、编写代码</h3> 
 <pre class="has"><code class="language-go">.global _start  /* 全局标号 */

_start:

 /* 1、使能所有时钟 ldf如果用大写就全部用大写,如果小写就全部用小写*/
 ldr r0, =0X020C4068 //将寄存器CCGR0地址0X020C4068 存放到 寄存器R0 中
 ldr r1, =0XFFFFFFFF //把寄存器x地址0Xffffffff存放到 寄存器r1 中
 str r1, [r0]//把寄存器r1中的值(0XFFFFFFFF) 写入到寄存器r0里面的值作为地址的内存里面
 
 ldr r0, =0X020C406C/*将寄存器CCGR1地址(0X020C4068) 存放到 寄存器R0 中*/
 str r1, [r0]

 ldr r0, =0X020C4070   /* CCGR2 */
 str r1, [r0]
 
 ldr r0, =0X020C4074   /* CCGR3 */
 str r1, [r0]
 
 ldr r0, =0X020C4078   /* CCGR4 */
 str r1, [r0]
 
 ldr r0, =0X020C407C   /* CCGR5 */
 str r1, [r0]
 
 ldr r0, =0X020C4080   /* CCGR6 */
 str r1, [r0]

 /* 2、设置GPIO1_IO03复用为GPIO1_IO03 */
 ldr r0, =0X020E0068 /* 将寄存器SW_MUX_GPIO1_IO03_BASE加载到r0中 */
 ldr r1, =0X5  /* 设置寄存器SW_MUX_GPIO1_IO03_BASE的MUX_MODE为5 */
 str r1,[r0]

 /* 3、配置GPIO1_IO03的IO属性 
  *bit 16:0 HYS关闭
  *bit [15:14]: 00 默认下拉
     *bit [13]: 0 kepper功能
     *bit [12]: 1 pull/keeper使能
     *bit [11]: 0 关闭开路输出
     *bit [7:6]: 10 速度100Mhz
     *bit [5:3]: 110 R0/6驱动能力
     *bit [0]: 0 低转换率
     */
    ldr r0, =0X020E02F4 /*寄存器SW_PAD_GPIO1_IO03_BASE */
    ldr r1, =0X10B0
    str r1,[r0]

 /* 4、设置GPIO1_IO03为输出 */
    ldr r0, =0X0209C004 /*寄存器GPIO1_GDIR */
    ldr r1, =0X0000008  
    str r1,[r0]

 /* 5、打开LED0
  * 设置GPIO1_IO03输出低电平
  */
 ldr r0, =0X0209C000 /*寄存器GPIO1_DR */
   ldr r1, =0  
   str r1,[r0]

/*
 * 描述：loop死循环
 */
loop:
 b loop     
.global _start @全局标号
/**/
</code></pre> 
 <h3>4、编译代码</h3> 
 <p>使用如下三条命令来编译代码</p> 
 <pre class="has"><code class="language-go">arm-linux-gnueabihf-gcc -g -c leds.s -o led.o
arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf
arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin
</code></pre> 
 <img src="https://images2.imgbox.com/fb/65/SLe9xXLd_o.png"> 
 <figcaption>
   编译、链接、格式转换 
 </figcaption> 
 <p>最终生成了<code>led.o</code> <code>led.elf</code> <code>led.bin</code>三个文件</p> 
 <h3>5、烧写代码</h3> 
 <p>STM32中代码烧写到内部FLASH。IMX6ULL支持SD卡、EMMC、NAND、nor、SPI flash等启动。裸机例程选择烧写到SD卡里面。在ubuntu下向SD卡烧写裸机bin文件。烧写不是将bin文件拷贝到SD卡中，而是将bin文件烧写到SD卡绝对地址上。而且对于I.MX而言，不能直接烧写bin文件，比如先在bin文件前面添加头部。完成这个工作，需要使用正点原子提供的imxdownload软件。</p> 
 <img src="https://images2.imgbox.com/15/98/rQT0byp2_o.png"> 
 <figcaption>
   利用FileZilla Client软件将imxdownload软件发送到工程目录下 
 </figcaption> 
 <p>烧写的三个命令</p> 
 <pre class="has"><code class="language-go">ls /dev/sd* -l
chmod 777 imxdownload 
./imxdownload led.bin /dev/sdb
</code></pre> 
 <p>Imxdownload使用方法，确定要烧写的SD卡文件，需要使用<code>ls /dev/sd* -l</code>命令来检测SD是哪一个文件，我的是<code>/dev/sdb</code>。</p> 
 <img src="https://images2.imgbox.com/0f/6e/6yFUEs59_o.png"> 
 <img src="https://images2.imgbox.com/7d/f4/50fNYEDh_o.png"> 
 <figcaption>
   插拔SD卡可以看到两个的区别 
 </figcaption> 
 <p>给予imxdownload可执行权限：<code>Chmod 777 imxdownload</code></p> 
 <p>烧写：<code>./imxdownload led.bin /dev/sdb</code></p> 
 <img src="https://images2.imgbox.com/84/04/4hbOmvsm_o.png"> 
 <figcaption>
   向SD卡烧写完成 
 </figcaption> 
 <p><code>Imxdownlaod</code>会向<code>led.bin</code>添加一个头部，生成新的<code>load.imx</code>文件，这个<code>load.imx</code>文件就是最终烧写到SD卡里面去的。</p> 
 <img src="https://images2.imgbox.com/1d/bc/ObhTT4uJ_o.png"> 
 <p>这里要注意的是如果烧写的速度在几十MB/S左右的话，那么可能意味着烧写失败了。而且是因为SD卡没找到而导致烧写失败，这个问题只能重启 ubuntu解决。</p> 
 <img src="https://images2.imgbox.com/a6/a8/xqBYXWmw_o.png"> 
 <p>之后就可以从读卡器中把SD拔下来，然后插入到开发板中，将拨码开关拔止SD卡模式，供电之后，蓝色LED亮，红色LED灭，两秒钟之后红色LED亮。</p> 
 <img src="https://images2.imgbox.com/2e/88/cdj6L9g9_o.png"> 
 <p style="text-align: left">最后你觉得哪个板子点灯最简单呢？</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/ff/52/tF5XS1zo_o.png"></p> 
 <p><img src="https://images2.imgbox.com/5f/83/WNrWHdFU_o.png"></p> 
 <p>End</p> 
 <hr> 
 <p><strong>推荐阅读：</strong></p> 
 <p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5NTM3MjIxMw%3D%3D&amp;action=getalbum&amp;album_id=1319528681890709506#wechat_redirect" rel="nofollow">专辑|Linux文章汇总</a></p> 
 <p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5NTM3MjIxMw%3D%3D&amp;action=getalbum&amp;album_id=1351786687592202240#wechat_redirect" rel="nofollow">专辑|程序人生</a></p> 
 <p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5NTM3MjIxMw%3D%3D&amp;action=getalbum&amp;album_id=1377857816341577728#wechat_redirect" rel="nofollow">专辑|C语言</a></p> 
 <p><a href="http://mp.weixin.qq.com/s?__biz=MzA5NTM3MjIxMw%3D%3D&amp;chksm=9042f716a7357e003fc6c87cfacb76508df6c06e14fb9f01c54aca3801f456b9ff5b6ce71ef3&amp;idx=2&amp;mid=2247492044&amp;scene=21&amp;sn=695b9297a39bf2d5a4548a161892d182#wechat_redirect" rel="nofollow">我的知识小密圈</a></p> 
 <p>关注公众号，后台回复「<strong>1024</strong>」获取学习资料网盘链接。</p> 
 <p><strong>欢迎点赞，关注，转发，在看，您的每一次鼓励，我都将铭记于心~</strong></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/3b/0d/tPACCrL8_o.png"></p> 
 <p style="text-align: center">嵌入式Linux</p> 
 <p style="text-align: center">微信扫描二维码，关注我的公众号</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d079d748c229b6455e1bc6381b048e15/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计组——关于二进制除法的一些思考</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a9b662abbbfda469bebda9bead8249a0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DJI ManiFold-2G(Nvidia Jetson TX2)源码安装Tensorflow-1.12.0</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>