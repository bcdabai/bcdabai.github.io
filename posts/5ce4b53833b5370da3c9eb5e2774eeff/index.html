<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java中cloneable的使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java中cloneable的使用" />
<meta property="og:description" content="什么是java中的浅克隆和深克隆? 浅克隆:克隆对象中的变量与之前对象的值相同,并且对象中的引用类型变量仍然指向原来对象引用类型变量的地址.深克隆:克隆对象中的变量与之前对象的值相同，并且对象中的引用类型变量指向了新的对象的引用变量的地址.要想实现克隆，只需定义的类声明下cloneable这个标记性接口,并且衍生重写Object类中就有的clone()方法即可. 为什么类要首先声明cloneable标记接口，然后重写clone()方法？因为不声明cloneable调用clone()方法会抛出CloneNotSupportedException异常,源码如下:
protected Object clone() throws CloneNotSupportedException { if (!(this instanceof Cloneable)) { throw new CloneNotSupportedException(&#34;Class &#34; &#43; getClass().getName() &#43; &#34; doesn&#39;t implement Cloneable&#34;); } return internalClone(); } /* * Native helper method for cloning. */ private native Object internalClone(); 在上一节中讲了java中Serializable与Parcelable的使用序列化与反序列化的问题。事实上利用对象输出流对对象进行序列化,利用对象的输入流对对象进行反序列化也可以实现克隆,如果对象中依赖的其他对象的引用也实现了序列化(即引用类实现了serializable标记接口)就实现了深度克隆,否则实现了浅克隆. 实现了Serializable接口的Company
public class Company implements Serializable {//Serializable接口是空的,没有声明的方法及常量 private static final long serialVersionUID = 1L; //序列化标识 private String name; private String address; public String getName() { return name; } public void setName(String name) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5ce4b53833b5370da3c9eb5e2774eeff/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-09-12T15:33:40+08:00" />
<meta property="article:modified_time" content="2017-09-12T15:33:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java中cloneable的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h6 id="什么是java中的浅克隆和深克隆">什么是java中的浅克隆和深克隆?</h6> 
<ul><li>浅克隆:克隆对象中的变量与之前对象的值相同,并且对象中的引用类型变量仍然指向原来对象引用类型变量的地址.</li><li>深克隆:克隆对象中的变量与之前对象的值相同，并且对象中的引用类型变量指向了新的对象的引用变量的地址.</li><li>要想实现克隆，只需定义的类声明下cloneable这个标记性接口,并且衍生重写Object类中就有的clone()方法即可.</li></ul> 
<p>为什么类要首先声明cloneable标记接口，然后重写clone()方法？因为不声明cloneable调用clone()方法会抛出CloneNotSupportedException异常,源码如下:</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span>() <span class="hljs-keyword">throws</span> CloneNotSupportedException {
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Cloneable)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CloneNotSupportedException(<span class="hljs-string">"Class "</span> + getClass().getName() +
                                                 <span class="hljs-string">" doesn't implement Cloneable"</span>);
        }

        <span class="hljs-keyword">return</span> internalClone();
    }

    <span class="hljs-comment">/*
     * Native helper method for cloning.
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">internalClone</span>();
</code></pre> 
<hr> 
<h6 id="在上一节中讲了java中serializable与parcelable的使用序列化与反序列化的问题事实上利用对象输出流对对象进行序列化利用对象的输入流对对象进行反序列化也可以实现克隆如果对象中依赖的其他对象的引用也实现了序列化即引用类实现了serializable标记接口就实现了深度克隆否则实现了浅克隆">在上一节中讲了<a href="http://blog.csdn.net/u012233285/article/details/77895822">java中Serializable与Parcelable的使用</a>序列化与反序列化的问题。事实上利用对象输出流对对象进行序列化,利用对象的输入流对对象进行反序列化也可以实现克隆,如果对象中依赖的其他对象的引用也实现了序列化(即引用类实现了serializable标记接口)就实现了深度克隆,否则实现了浅克隆.</h6> 
<p>实现了Serializable接口的Company</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Company</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> {<!-- --></span><span class="hljs-comment">//Serializable接口是空的,没有声明的方法及常量</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1</span>L; <span class="hljs-comment">//序列化标识</span>

    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-keyword">private</span> String address;

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span>() {
        <span class="hljs-keyword">return</span> address;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span>(String address) {
        <span class="hljs-keyword">this</span>.address = address;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">Company</span>(String name, String address) {
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.address = address;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"company name is:"</span>+name+<span class="hljs-string">",address is:"</span>+address;
    }
}
</code></pre> 
<p>获得实现了Serializable接口的克隆实例调用方法。</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> &lt;T&gt; T <span class="hljs-title">getCopyObj</span>(T t) {

        ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">null</span>;
        ObjectOutputStream objectOutputStream = <span class="hljs-keyword">null</span>;

        ByteArrayInputStream byteArrayInputStream = <span class="hljs-keyword">null</span>;
        ObjectInputStream objectInputStream = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> {
            byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();

            objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(byteArrayOutputStream);
            objectOutputStream.writeObject(t);<span class="hljs-comment">//序列化对象</span>
            objectOutputStream.flush();

            byteArrayInputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(byteArrayOutputStream.toByteArray());
            objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(byteArrayInputStream);
            T t1 = (T) objectInputStream.readObject();
            <span class="hljs-keyword">return</span> t1;

        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (byteArrayOutputStream != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">try</span> {
                    byteArrayOutputStream.close();
                    byteArrayOutputStream = <span class="hljs-keyword">null</span>;

                } <span class="hljs-keyword">catch</span> (IOException e) {
                    e.printStackTrace();
                }
            }

            <span class="hljs-keyword">if</span> (objectOutputStream != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">try</span> {
                    objectOutputStream.close();
                    objectOutputStream = <span class="hljs-keyword">null</span>;

                } <span class="hljs-keyword">catch</span> (IOException e) {
                    e.printStackTrace();
                }
            }

            <span class="hljs-keyword">if</span> (byteArrayInputStream != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">try</span> {
                    byteArrayInputStream.close();
                    byteArrayInputStream = <span class="hljs-keyword">null</span>;

                } <span class="hljs-keyword">catch</span> (IOException e) {
                    e.printStackTrace();
                }
            }

            <span class="hljs-keyword">if</span> (objectInputStream != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">try</span> {
                    objectInputStream.close();
                    objectInputStream = <span class="hljs-keyword">null</span>;

                } <span class="hljs-keyword">catch</span> (IOException e) {
                    e.printStackTrace();
                }
            }

        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

    }
}
</code></pre> 
<p><font color="#ff00">测试通过的testCase，说明通过Serializable的反序列化创建的是一个新的对象,不再是之前的对象了。</font></p> 
<pre class="prettyprint"><code class=" hljs java">    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>() <span class="hljs-keyword">throws</span> CloneNotSupportedException {
        Company company=<span class="hljs-keyword">new</span> Company(<span class="hljs-string">"百度"</span>,<span class="hljs-string">"上地十街"</span>);
        Company copyCompany=getCopyObj(company);
        copyCompany.setName(<span class="hljs-string">"腾讯"</span>);
        Assert.assertEquals(<span class="hljs-keyword">false</span>,company==copyCompany);
        Assert.assertEquals(<span class="hljs-keyword">true</span>,company.getName().equals(<span class="hljs-string">"百度"</span>));
        Assert.assertEquals(<span class="hljs-keyword">true</span>,copyCompany.getName().equals(<span class="hljs-string">"腾讯"</span>));

    }
</code></pre> 
<hr> 
<h6 id="实现了clonable克隆的例子">实现了Clonable克隆的例子</h6> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> {<!-- --></span>

    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-keyword">public</span> <span class="hljs-title">People</span>(String name, <span class="hljs-keyword">int</span> age) {
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span>() <span class="hljs-keyword">throws</span> CloneNotSupportedException {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span>() {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age) {
        <span class="hljs-keyword">this</span>.age = age;
    }
}
</code></pre> 
<p><font color="#ff00">验证通过的case,表明了克隆出来的对象与原来的对象地址不一样,是一个新的对象,所以克隆对象中的name和age是新的.</font></p> 
<pre class="prettyprint"><code class=" hljs avrasm">    @Test
    public void test() throws CloneNotSupportedException {

        People people = new People(<span class="hljs-string">"storm"</span>, <span class="hljs-number">30</span>)<span class="hljs-comment">;</span>
        People clonePeople = (People) people<span class="hljs-preprocessor">.clone</span>()<span class="hljs-comment">;</span>

        clonePeople<span class="hljs-preprocessor">.setName</span>(<span class="hljs-string">"stormClone"</span>)<span class="hljs-comment">;</span>
        clonePeople<span class="hljs-preprocessor">.setAge</span>(<span class="hljs-number">29</span>)<span class="hljs-comment">;</span>

        Assert<span class="hljs-preprocessor">.assertFalse</span>(people == clonePeople)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"people name="</span> + people<span class="hljs-preprocessor">.getName</span>())<span class="hljs-comment">;//people name=storm</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"people age="</span> + people<span class="hljs-preprocessor">.getAge</span>())<span class="hljs-comment">;//people age=30</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"clonePeople name="</span> + clonePeople<span class="hljs-preprocessor">.getName</span>())<span class="hljs-comment">;//clonePeople name=stormClone</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"clonePeople age="</span> + clonePeople<span class="hljs-preprocessor">.getAge</span>())<span class="hljs-comment">;//clonePeople age=29</span>

    }</code></pre> 
<hr> 
<p>使用cloneable实现浅克隆</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Animal {

    <span class="hljs-keyword">private</span> String animalName;

    <span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(String animalName) {
        <span class="hljs-keyword">this</span>.animalName = animalName;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getAnimalName</span>() {
        <span class="hljs-keyword">return</span> animalName;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAnimalName</span>(String animalName) {
        <span class="hljs-keyword">this</span>.animalName = animalName;
    }
}
</code></pre> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> {<!-- --></span>

    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-keyword">private</span> Animal animal;<span class="hljs-comment">//克隆对象中的引用型变量</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title">People</span>(String name, <span class="hljs-keyword">int</span> age,Animal animal) {
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
        <span class="hljs-keyword">this</span>.animal=animal;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span>() <span class="hljs-keyword">throws</span> CloneNotSupportedException {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span>() {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age) {
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> Animal <span class="hljs-title">getAnimal</span>() {
        <span class="hljs-keyword">return</span> animal;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAnimal</span>(Animal animal) {
        <span class="hljs-keyword">this</span>.animal = animal;
    }
}
</code></pre> 
<p><font color="#ff00">验证通过的case，表明了克隆对象的引用型变量animal并未发生改变,也即使内存中的地址并未发生改变,所以对其name的更改会影响原对象与克隆对象的值.</font></p> 
<pre class="prettyprint"><code class=" hljs avrasm">    @Test
    public void test() throws CloneNotSupportedException {

        Animal animal=new Animal(<span class="hljs-string">"cat"</span>)<span class="hljs-comment">;</span>
        People people = new People(<span class="hljs-string">"storm"</span>, <span class="hljs-number">30</span>,animal)<span class="hljs-comment">;</span>

        People clonePeople = (People) people<span class="hljs-preprocessor">.clone</span>()<span class="hljs-comment">;</span>
        animal<span class="hljs-preprocessor">.setAnimalName</span>(<span class="hljs-string">"dog"</span>)<span class="hljs-comment">;</span>

        Assert<span class="hljs-preprocessor">.assertFalse</span>(people == clonePeople)<span class="hljs-comment">;</span>
        Assert<span class="hljs-preprocessor">.assertTrue</span>(people<span class="hljs-preprocessor">.getAnimal</span>()==clonePeople<span class="hljs-preprocessor">.getAnimal</span>())<span class="hljs-comment">;</span>
        Assert<span class="hljs-preprocessor">.assertTrue</span>(people<span class="hljs-preprocessor">.getAnimal</span>()<span class="hljs-preprocessor">.getAnimalName</span>()<span class="hljs-preprocessor">.equals</span>(<span class="hljs-string">"dog"</span>))<span class="hljs-comment">;</span>
        Assert<span class="hljs-preprocessor">.assertTrue</span>(clonePeople<span class="hljs-preprocessor">.getAnimal</span>()<span class="hljs-preprocessor">.getAnimalName</span>()<span class="hljs-preprocessor">.equals</span>(<span class="hljs-string">"dog"</span>))<span class="hljs-comment">;</span>

 }
</code></pre> 
<hr> 
<p>使用cloneable实现深克隆(实现很简单只需要引用类型变量实现cloneable接口即可)，相比浅克隆,只需做如下修改.</p> 
<pre class="prettyprint"><code class=" hljs java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>{<!-- --></span>

    <span class="hljs-keyword">private</span> String animalName;

    <span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(String animalName) {
        <span class="hljs-keyword">this</span>.animalName = animalName;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getAnimalName</span>() {
        <span class="hljs-keyword">return</span> animalName;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAnimalName</span>(String animalName) {
        <span class="hljs-keyword">this</span>.animalName = animalName;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span>() <span class="hljs-keyword">throws</span> CloneNotSupportedException {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();
    }
}

</code></pre> 
<p><font color="#ff00">验证通过的case，表明了克隆对象的引用型变量animal发生改变,也即内存中的地址发生改变,所以对其name的更改不会影响克隆对象的值.同时说明了进行深克隆会把所有的引用类型都实现cloneable接口,如果克隆对象中的引用类型变量比较多的话,这牵涉的工作量就会比较大了,这时我们考虑使用上面实现Serializable实现克隆的方式,缺点是反复进行IO操作，内存开销大.</font></p> 
<pre class="prettyprint"><code class=" hljs avrasm">@Test
    public void test() throws CloneNotSupportedException {

        Animal animal=new Animal(<span class="hljs-string">"cat"</span>)<span class="hljs-comment">;</span>
        People people = new People(<span class="hljs-string">"storm"</span>, <span class="hljs-number">30</span>,animal)<span class="hljs-comment">;</span>

        People clonePeople = (People) people<span class="hljs-preprocessor">.clone</span>()<span class="hljs-comment">;</span>
        Animal cloneAnimal=(Animal) animal<span class="hljs-preprocessor">.clone</span>()<span class="hljs-comment">;</span>
        clonePeople<span class="hljs-preprocessor">.setAnimal</span>(cloneAnimal)<span class="hljs-comment">;</span>
        animal<span class="hljs-preprocessor">.setAnimalName</span>(<span class="hljs-string">"dog"</span>)<span class="hljs-comment">;</span>

        Assert<span class="hljs-preprocessor">.assertFalse</span>(people == clonePeople)<span class="hljs-comment">;</span>
        Assert<span class="hljs-preprocessor">.assertFalse</span>(people<span class="hljs-preprocessor">.getAnimal</span>()==clonePeople<span class="hljs-preprocessor">.getAnimal</span>())<span class="hljs-comment">;</span>
        Assert<span class="hljs-preprocessor">.assertTrue</span>(people<span class="hljs-preprocessor">.getAnimal</span>()<span class="hljs-preprocessor">.getAnimalName</span>()<span class="hljs-preprocessor">.equals</span>(<span class="hljs-string">"dog"</span>))<span class="hljs-comment">;</span>
        Assert<span class="hljs-preprocessor">.assertTrue</span>(clonePeople<span class="hljs-preprocessor">.getAnimal</span>()<span class="hljs-preprocessor">.getAnimalName</span>()<span class="hljs-preprocessor">.equals</span>(<span class="hljs-string">"cat"</span>))<span class="hljs-comment">;</span>

    }</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/380116abfae0f64b4fa57b495e36847f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">iOS UIView的圆角加阴影效果的实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d545d4bf5512ce0b3cb2fc223a35411/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构 第3讲 顺序表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>