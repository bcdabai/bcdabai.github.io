<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>条件变量(Condition Variable)详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="条件变量(Condition Variable)详解" />
<meta property="og:description" content="http://www.wuzesheng.com/?p=1668
条件变量(Condtion Variable)是在多线程程序中用来实现“等待-&gt;唤醒”逻辑常用的方法。举个简单的例子，应用程序A中包含两个线程t1和t2。t1需要在 bool变量test_cond为true时才能继续执行，而test_cond的值是由t2来改变的，这种情况下，如何来写程序呢？可供选择的方案有两 种：
第一种是t1定时的去轮询变量test_cond，如果test_cond为false，则继续休眠；如果test_cond为true，则开始执行。第二种就是上面提到的条件变量，t1在test_cond为false时调用cond_wait进行等待，t2在改变test_cond的值后，调用cond_signal，唤醒在等待中的t1，告诉t1 test_cond的值变了，这样t1便可继续往下执行。 很明显，上面两种方案中，第二种方案是比较优的。在第一种方案中，在每次轮询时，如果t1休眠的时间比较短，会导致cpu浪费很厉害；如果t1休眠的时间 比较长，又会导致应用逻辑处理不够及时，致使应用程序性能下降。第二种方案就是为了解决轮询的弊端而生的。然而条件变量在使用的过程中，比较容易出错，如 何用得不正确的话，会适得其反的，接下来，我将详细分析如何来使用条件变量，希望能够给在使用条件变量过程中遇到问题的朋友有所帮助。在开始介绍之前，需要说明一下，在接下来的介绍中，需要用到互斥锁和条件变量相关的内容，在这里我以linux下的pthread_mutex_t为互斥 锁类型，pthread_cond_t为条件变量类型来进行介绍，对pthread不熟的朋友，可以参考一下linux下的manual。1. 下面是把刚开始举的例子翻译后的程序：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 pthread_mutex_t mutex; ///&lt; 互斥锁 pthread_cond_t cond; ///&lt; 条件变量 bool test_cond = false; /// TODO 初始化mutex和cond /// thread 1: pthread_mutex_lock(&amp;mutex); ///&lt; 1 while (!test_cond) { pthread_cond_wait(&amp;cond, &amp;mutex); ///&lt; 2,3 } pthread_mutex_unlock(&amp;mutex); ///&lt; 4 RunThread1Func(); /// thread 2: pthread_mutex_lock(&amp;mutex); ///&lt; 5 test_cond = true; pthread_cond_signal(&amp;cond); pthread_mutex_unlock(&amp;mutex); ///&lt; 6 /// TODO 销毁mutex和cond 通过上面的例子，下面我来介绍一下条件变量在使用过程中需要注意的几点（也是比较容易出错的）：（1）条件变量的使用过程中，最为关键的一点是互斥锁的使用。细心的朋友应该发现了，我在上面的例子中标了1、2、3、4、5、6个标号。在这里1、4、 5、6都是正常的lock/unlock，2、3是需要特别说明的。2是进入pthread_cond_wait后 的，pthread_cond_wait调的pthread_mutex_unlock，这样做的目的是为了保证在thread1阻塞wait 后，thread2获取同一把锁mutex的时候，能够正常获取（即5，6）。3是thread1被唤醒后，要退出pthead_cond_wait之 前，pthread_cond_wait调的pthread_mutex_lock，这样做的目的是为了把mutex的控制权还给调用 pthread_cond_wait的线程（即thread1）。整理一下基本的时序为：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/01d8b009665f22102cbca861475abcc4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-03T16:53:10+08:00" />
<meta property="article:modified_time" content="2018-05-03T16:53:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">条件变量(Condition Variable)详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin:10px auto;color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:12px;text-align:left;background-color:rgb(255,255,255);">http://www.wuzesheng.com/?p=1668</p> 
<p style="margin:10px auto;color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:12px;text-align:left;background-color:rgb(255,255,255);">条件变量(Condtion Variable)是在多线程程序中用来实现“等待-&gt;唤醒”逻辑常用的方法。举个简单的例子，应用程序A中包含两个线程t1和t2。t1需要在 bool变量test_cond为true时才能继续执行，而test_cond的值是由t2来改变的，这种情况下，如何来写程序呢？可供选择的方案有两 种：</p> 
<div class="content" style="margin:0px;padding:0px;color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:12px;text-align:left;background-color:rgb(255,255,255);"> 
 <ul style="margin-bottom:0px;margin-left:30px;"><li style="margin-top:0px;margin-bottom:1em;margin-left:0px;padding:0px;">第一种是t1定时的去轮询变量test_cond，如果test_cond为false，则继续休眠；如果test_cond为true，则开始执行。</li><li style="margin-top:0px;margin-bottom:1em;margin-left:0px;padding:0px;">第二种就是上面提到的条件变量，t1在test_cond为false时调用cond_wait进行等待，t2在改变test_cond的值后，调用cond_signal，唤醒在等待中的t1，告诉t1 test_cond的值变了，这样t1便可继续往下执行。</li></ul> 
 <p style="margin:10px auto;">很明显，上面两种方案中，第二种方案是比较优的。在第一种方案中，在每次轮询时，如果t1休眠的时间比较短，会导致cpu浪费很厉害；如果t1休眠的时间 比较长，又会导致应用逻辑处理不够及时，致使应用程序性能下降。第二种方案就是为了解决轮询的弊端而生的。然而条件变量在使用的过程中，比较容易出错，如 何用得不正确的话，会适得其反的，接下来，我将详细分析如何来使用条件变量，希望能够给在使用条件变量过程中遇到问题的朋友有所帮助。<span style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;">在开始介绍之前，需要说明一下，在接下来的介绍中，需要用到互斥锁和条件变量相关的内容，在这里我以linux下的pthread_mutex_t为互斥 锁类型，pthread_cond_t为条件变量类型来进行介绍，对pthread不熟的朋友，可以参考一下linux下的manual。<br style="margin:0px;padding:0px;">1. 下面是把刚开始举的例子翻译后的程序：</span></p> 
 <div class="wp_syntax" style="margin:0px;padding:0px;"> 
  <table style="margin:0px;padding:0px;border-spacing:0px;border:1px solid #C0C0C0;"><tbody style="margin:0px;padding:0px;"><tr style="margin:0px;padding:0px;"><td class="line_numbers" style="margin:0px;padding:3px;border-color:#C0C0C0;border-collapse:collapse;"><pre style="margin-bottom:0px;padding-right:0px;padding-left:0px;white-space:pre-wrap;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code" style="margin:0px;padding:3px;border-color:#C0C0C0;border-collapse:collapse;"><pre><code class="language-cpp">pthread_mutex_t mutex<span style="margin:0px;padding:0px;color:rgb(0,128,128);">;  <span style="margin:0px;padding:0px;color:rgb(102,102,102);">///&lt; 互斥锁
pthread_cond_t  cond<span style="margin:0px;padding:0px;color:rgb(0,128,128);">;   <span style="margin:0px;padding:0px;color:rgb(102,102,102);">///&lt; 条件变量
<span style="margin:0px;padding:0px;color:rgb(0,0,255);">bool test_cond <span style="margin:0px;padding:0px;color:rgb(0,0,128);">= <span style="margin:0px;padding:0px;color:rgb(0,0,255);">false<span style="margin:0px;padding:0px;color:rgb(0,128,128);">; <span style="margin:0px;padding:0px;color:rgb(102,102,102);">/// TODO 初始化mutex和cond   <span style="margin:0px;padding:0px;">/// thread 1: pthread_mutex_lock<span style="margin:0px;padding:0px;color:rgb(0,128,0);">(<span style="margin:0px;padding:0px;color:rgb(0,0,64);">&amp;mutex<span style="margin:0px;padding:0px;color:rgb(0,128,0);">)<span style="margin:0px;padding:0px;color:rgb(0,128,128);">; <span style="margin:0px;padding:0px;color:rgb(102,102,102);">///&lt; 1 <span style="margin:0px;padding:0px;color:rgb(0,0,255);">while <span style="margin:0px;padding:0px;color:rgb(0,128,0);">(<span style="margin:0px;padding:0px;color:rgb(0,0,64);">!test_cond<span style="margin:0px;padding:0px;color:rgb(0,128,0);">) <span style="margin:0px;padding:0px;">{ pthread_cond_wait<span style="margin:0px;padding:0px;">(<span style="margin:0px;padding:0px;color:rgb(0,0,64);">&amp;cond, <span style="margin:0px;padding:0px;">&amp;mutex<span style="margin:0px;padding:0px;color:rgb(0,128,0);">)<span style="margin:0px;padding:0px;color:rgb(0,128,128);">; <span style="margin:0px;padding:0px;color:rgb(102,102,102);">///&lt; 2,3 <span style="margin:0px;padding:0px;color:rgb(0,128,0);">} pthread_mutex_unlock<span style="margin:0px;padding:0px;">(<span style="margin:0px;padding:0px;color:rgb(0,0,64);">&amp;mutex<span style="margin:0px;padding:0px;color:rgb(0,128,0);">)<span style="margin:0px;padding:0px;color:rgb(0,128,128);">; <span style="margin:0px;padding:0px;color:rgb(102,102,102);">///&lt; 4 RunThread1Func<span style="margin:0px;padding:0px;color:rgb(0,128,0);">(<span style="margin:0px;padding:0px;">)<span style="margin:0px;padding:0px;color:rgb(0,128,128);">;   <span style="margin:0px;padding:0px;color:rgb(102,102,102);">/// thread 2: pthread_mutex_lock<span style="margin:0px;padding:0px;color:rgb(0,128,0);">(<span style="margin:0px;padding:0px;color:rgb(0,0,64);">&amp;mutex<span style="margin:0px;padding:0px;color:rgb(0,128,0);">)<span style="margin:0px;padding:0px;color:rgb(0,128,128);">; <span style="margin:0px;padding:0px;color:rgb(102,102,102);">///&lt; 5 test_cond <span style="margin:0px;padding:0px;color:rgb(0,0,128);">= <span style="margin:0px;padding:0px;color:rgb(0,0,255);">true<span style="margin:0px;padding:0px;color:rgb(0,128,128);">; pthread_cond_signal<span style="margin:0px;padding:0px;color:rgb(0,128,0);">(<span style="margin:0px;padding:0px;color:rgb(0,0,64);">&amp;cond<span style="margin:0px;padding:0px;color:rgb(0,128,0);">)<span style="margin:0px;padding:0px;color:rgb(0,128,128);">; pthread_mutex_unlock<span style="margin:0px;padding:0px;color:rgb(0,128,0);">(<span style="margin:0px;padding:0px;color:rgb(0,0,64);">&amp;mutex<span style="margin:0px;padding:0px;color:rgb(0,128,0);">)<span style="margin:0px;padding:0px;color:rgb(0,128,128);">; <span style="margin:0px;padding:0px;color:rgb(102,102,102);">///&lt; 6   <span style="margin:0px;padding:0px;">/// TODO 销毁mutex和cond</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></td></tr></tbody></table> 
 </div> 
 <p style="margin:10px auto;">通过上面的例子，下面我来介绍一下条件变量在使用过程中需要注意的几点（也是比较容易出错的）：<br style="margin:0px;padding:0px;">（1）条件变量的使用过程中，最为关键的一点是互斥锁的使用。细心的朋友应该发现了，我在上面的例子中标了1、2、3、4、5、6个标号。在这里1、4、 5、6都是正常的lock/unlock，2、3是需要特别说明的。2是进入pthread_cond_wait后 的，pthread_cond_wait调的pthread_mutex_unlock，这样做的目的是为了保证在thread1阻塞wait 后，thread2获取同一把锁mutex的时候，能够正常获取（即5，6）。3是thread1被唤醒后，要退出pthead_cond_wait之 前，pthread_cond_wait调的pthread_mutex_lock，这样做的目的是为了把mutex的控制权还给调用 pthread_cond_wait的线程（即thread1）。整理一下基本的时序为：</p> 
 <div class="wp_syntax" style="margin:0px;padding:0px;"> 
  <table style="margin:0px;padding:0px;border-spacing:0px;border:1px solid #C0C0C0;"><tbody style="margin:0px;padding:0px;"><tr style="margin:0px;padding:0px;"><td class="line_numbers" style="margin:0px;padding:3px;border-color:#C0C0C0;border-collapse:collapse;"><pre style="margin-bottom:0px;padding-right:0px;padding-left:0px;white-space:pre-wrap;">1
2
3
</pre></td><td class="code" style="margin:0px;padding:3px;border-color:#C0C0C0;border-collapse:collapse;"><pre><code class="language-cpp">thread <span style="margin:0px;padding:0px;color:rgb(0,0,221);">1 lock<span style="margin:0px;padding:0px;color:rgb(0,0,64);">-<span style="margin:0px;padding:0px;color:rgb(0,0,128);">&gt;thread <span style="margin:0px;padding:0px;color:rgb(0,0,221);">1 wait<span style="margin:0px;padding:0px;color:rgb(0,0,64);">-<span style="margin:0px;padding:0px;color:rgb(0,0,128);">&gt; thread <span style="margin:0px;padding:0px;color:rgb(0,0,221);">1 unlock<span style="margin:0px;padding:0px;color:rgb(0,128,0);">(in wait<span style="margin:0px;padding:0px;">) <span style="margin:0px;padding:0px;color:rgb(0,0,64);">-<span style="margin:0px;padding:0px;color:rgb(0,0,128);">&gt;thread <span style="margin:0px;padding:0px;color:rgb(0,0,221);">2 lock<span style="margin:0px;padding:0px;color:rgb(0,0,64);">-<span style="margin:0px;padding:0px;color:rgb(0,0,128);">&gt;thread <span style="margin:0px;padding:0px;color:rgb(0,0,221);">2 signal<span style="margin:0px;padding:0px;color:rgb(0,0,64);">-<span style="margin:0px;padding:0px;color:rgb(0,0,128);">&gt;thread <span style="margin:0px;padding:0px;color:rgb(0,0,221);">2 unlock <span style="margin:0px;padding:0px;color:rgb(0,0,64);">-<span style="margin:0px;padding:0px;color:rgb(0,0,128);">&gt;thread <span style="margin:0px;padding:0px;color:rgb(0,0,221);">1 lock<span style="margin:0px;padding:0px;color:rgb(0,128,0);">(in wait<span style="margin:0px;padding:0px;">)<span style="margin:0px;padding:0px;color:rgb(0,0,64);">-<span style="margin:0px;padding:0px;color:rgb(0,0,128);">&gt;thread <span style="margin:0px;padding:0px;color:rgb(0,0,221);">1 unlock</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></td></tr></tbody></table> 
 </div> 
 <p style="margin:10px auto;">（2）条件变量使用的过程中，通常会加一个bool或者int的值test_cond来配合使用。这里需要注意的一点是一定要在signal之前来 改变test_cond，这样才能保证wait的线程被唤醒后，能够取到正确的test_cond的值，否则后果是不可预测的。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/029ea03a1ab019f3cf644012a0d92119/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springboot项目启动时报A child container failed during start</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c593f0da46b8de9813986474d9ea45c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图的MST（最小生成树算法）Kruskral&#43;Prim</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>