<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序（插入排序） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排序（插入排序）" />
<meta property="og:description" content="现在，我们学习了之前数据结构的部分内容，即将进入一个重要的领域：排序，这是一个看起来简单，但是想要理清其中逻辑并不简单的内容，让我们一起加油把！
排序的概念及其运用 排序的概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
排序运用 商品排序
院校排名
除了这些还有其他的一些地方也会用到排序，总之，我们的生活中处处都存在着排序，所以，学习好排序的使用，对于我们后续学习是十分重要的
常见排序算法 而我们今天讲的重点就是插入排序：其中包含着的就是直接插入排序和希尔排序，而希尔排序事实上就是直接插入排序的升级版
插入排序 基本思想：
直接插入排序是一种简单的插入排序法，其基本思想是：
把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。
直接插入排序 当插入第i(i&gt;=1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移
直接插入排序的特性总结：
元素集合越接近有序，直接插入排序算法的时间效率越高时间复杂度：O(N^2)空间复杂度：O(1)，它是一种稳定的排序算法稳定性：稳定 我们首先给一个例子为大家讲解一下其中的原理：
int a[ ]={6 9 1 2 5};
假设此时我们要排序的是1，那么我们用end&#43;1作为插入排序元素的下标，end则是前面已经排好顺序的一段，范围为[0,end]。此时我们用一个变量记录住1的值，然后往前比对。我们发现，1比9小，所以end&#43;1下标的位置变为9，然后end–；1比6小，6又被赋值到了原本9的位置上；最后再把1赋值到下标0的位置上，一次排序就成功了。
写成代码是这个样子的：
int end; int tmp=a[end&#43;1]; while(end&gt;=0){ if(tmp&lt;a[end]){ a[end&#43;1]=a[end]; end--; } else{ break; } } a[end&#43;1]=tmp; 为什么while循环的结束条件是end&gt;=0呢，拿上面的举例，一开始end&#43;1的下标为2，也就是end为1，end- -之后变成了0，而第二次end- -之后直接变成了-1，退出循环。此时end&#43;1=0，也就是数组的第一个元素，最小的元素，刚好就是1
但很明显，这样的话这个函数只能比较一次，怎么样才可以实现多次比较呢，这个时候就需要在外面嵌套一个for循环，然后从0开始一个一个比对，直到n-2（如果是n-1，end&#43;1就是n，就超过数组的下标了，会越界）
所以最终的直接插入排序是这样写的：
//插入排序：前一段有序，在后方插入一个并再次排序 //[0,end] end&#43;1大概就这个意思 //时间复杂度：O(N^2) //最好的情况：O(N)，就算有序也得遍历一遍 void InsertSort(int* a,int n) { for (int i = 0; i &lt; n - 1; i&#43;&#43;) { int end = i; int tmp = a[end &#43; 1]; while (end &gt;= 0) { if (tmp &lt; a[end]) { a[end &#43; 1] = a[end]; end--; } else { break;//终止循环 } } a[end &#43; 1] = tmp; } } 希尔排序（缩小增量排序） 希尔排序（Shell’s Sort）是插入排序的一种更高效的改进版本，也称为缩小增量排序。它的基本思想是：先将整个待排序的记录序列分割成为若干子序列（由相隔某个“增量”的记录组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/eda268871c9f8d93123794dc351a9c81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-23T16:09:22+08:00" />
<meta property="article:modified_time" content="2024-01-23T16:09:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序（插入排序）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>现在，我们学习了之前数据结构的部分内容，即将进入一个重要的领域：排序，这是一个看起来简单，但是想要理清其中逻辑并不简单的内容，让我们一起加油把！</strong></p> 
<h2><a id="_2"></a>排序的概念及其运用</h2> 
<h3><a id="_3"></a>排序的概念</h3> 
<blockquote> 
 <p><strong>排序</strong>：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。<br> <strong>稳定性</strong>：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。<br> <strong>内部排序</strong>：数据元素全部放在内存中的排序。<br> <strong>外部排序</strong>：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。</p> 
</blockquote> 
<h3><a id="_8"></a>排序运用</h3> 
<ol><li> <p>商品排序<img src="https://images2.imgbox.com/91/0c/WLiAhvTO_o.png" alt="在这里插入图片描述"></p> </li><li> <p>院校排名<img src="https://images2.imgbox.com/a9/7e/99Ny81Wa_o.png" alt="在这里插入图片描述"><br> <strong>除了这些还有其他的一些地方也会用到排序，总之，我们的生活中处处都存在着排序，所以，学习好排序的使用，对于我们后续学习是十分重要的</strong></p> </li></ol> 
<h2><a id="_13"></a>常见排序算法</h2> 
<p><img src="https://images2.imgbox.com/90/6a/JhmhLXvQ_o.png" alt="在这里插入图片描述"><br> <strong>而我们今天讲的重点就是插入排序：其中包含着的就是直接插入排序和希尔排序，而希尔排序事实上就是直接插入排序的升级版</strong></p> 
<h3><a id="_17"></a>插入排序</h3> 
<blockquote> 
 <p>基本思想：<br> 直接插入排序是一种简单的插入排序法，其基本思想是：<br> 把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。</p> 
</blockquote> 
<h4><a id="_22"></a>直接插入排序</h4> 
<blockquote> 
 <p>当插入第i(i&gt;=1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移<br> 直接插入排序的特性总结：</p> 
 <ol><li>元素集合越接近有序，直接插入排序算法的时间效率越高</li><li>时间复杂度：O(N^2)</li><li>空间复杂度：O(1)，它是一种稳定的排序算法</li><li>稳定性：稳定</li></ol> 
</blockquote> 
<p><strong>我们首先给一个例子为大家讲解一下其中的原理：</strong></p> 
<blockquote> 
 <p>int a[ ]={6 9 1 2 5};<br> 假设此时我们要排序的是1，那么我们用end+1作为插入排序元素的下标，end则是前面已经排好顺序的一段，范围为[0,end]。此时我们用一个变量记录住1的值，然后往前比对。我们发现，1比9小，所以end+1下标的位置变为9，然后end–；1比6小，6又被赋值到了原本9的位置上；最后再把1赋值到下标0的位置上，一次排序就成功了。<br> 写成代码是这个样子的：</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">int</span> end<span class="token punctuation">;</span>
<span class="token keyword">int</span> tmp<span class="token operator">=</span>a<span class="token punctuation">[</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>end<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token operator">&lt;</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		a<span class="token punctuation">[</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
		end<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
	a<span class="token punctuation">[</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>为什么while循环的结束条件是end&gt;=0呢，拿上面的举例，一开始end+1的下标为2，也就是end为1，end- -之后变成了0，而第二次end- -之后直接变成了-1，退出循环。此时end+1=0，也就是数组的第一个元素，最小的元素，刚好就是1</p> 
</blockquote> 
<p><strong>但很明显，这样的话这个函数只能比较一次，怎么样才可以实现多次比较呢，这个时候就需要在外面嵌套一个for循环，然后从0开始一个一个比对，直到n-2（如果是n-1，end+1就是n，就超过数组的下标了，会越界）</strong><br> <strong>所以最终的直接插入排序是这样写的：</strong></p> 
<pre><code class="prism language-c"><span class="token comment">//插入排序：前一段有序，在后方插入一个并再次排序</span>
<span class="token comment">//[0,end] end+1大概就这个意思</span>
<span class="token comment">//时间复杂度：O(N^2)</span>
<span class="token comment">//最好的情况：O(N)，就算有序也得遍历一遍</span>
<span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
				end<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//终止循环</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_77"></a>希尔排序（缩小增量排序）</h4> 
<blockquote> 
 <p>希尔排序（Shell’s Sort）是插入排序的一种更高效的改进版本，也称为缩小增量排序。它的基本思想是：先将整个待排序的记录序列分割成为若干子序列（由相隔某个“增量”的记录组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。</p> 
</blockquote> 
<blockquote> 
 <p>希尔排序的增量序列的选择是一个数学难题，通常选取这个常用的增量序列：t1=n/2，ti=ti-1/2，直到ti=1为止。其中，n为待排序序列的长度。按照增量序列的个数k，对序列进行k趟排序。每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p> 
</blockquote> 
<p><strong>只看概念会觉得晦涩难懂，还是先给大家举一个例子看看：</strong><br> <img src="https://images2.imgbox.com/6c/20/zMjIzU8s_o.png" alt="在这里插入图片描述"><br> <strong>假设有这么一个数组，我们要对其进行希尔排序，通常会分成两个步骤：</strong><br> <strong>1.预排序：首先将其分为几个组，然后针对每个分组进行插入排序</strong><br> <strong>2.预排序之后，此时数据已经趋于有序，我们再对其整体进行直接插入排序</strong></p> 
<p><strong>在这里的话，我们假设间隔3个为一组，那么9，6，3，0就是一组，8，5，2是一组，7，4，1是一组，而我们对每个组进行插入排序之后，顺序就分别变成：0，3，6，9；2，5，8；1，4，7；而放在整体中的话，就是0 2 1 3 5 4 6 8 7 9，可以看出，次序比起一开始的逆序已经好了很多，如果将这一次排序写成代码，就是这个样子的：</strong></p> 
<pre><code class="prism language-c">	<span class="token keyword">int</span> gap<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">//j&lt;n-gap是因为防止越界</span>
	<span class="token comment">//内层的for循环只可以提供一组的排序，而外部for循环使每一个组都排序</span>
	<span class="token comment">//i=0,i=1,i=2，三个组都可以排序</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>gap<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token operator">-</span>gap<span class="token punctuation">;</span>j<span class="token operator">+=</span>gap<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> end<span class="token operator">=</span>j<span class="token punctuation">;</span>
			<span class="token keyword">int</span> tmp<span class="token operator">=</span>a<span class="token punctuation">[</span>end<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span><span class="token punctuation">(</span>end<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token operator">&lt;</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
					a<span class="token punctuation">[</span>end<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
					end<span class="token operator">-=</span>gap<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				
				<span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span> 
			a<span class="token punctuation">[</span>end<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p><strong>但是很明显，这样子的话，只比较排序了一次，但我们需要的是在保证最后一次比较是gap==1的情况下，前面的预排序也要到位。但首先我们先把预排序的函数再修改一下，让它不用分组排序，而是多组并排。</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> gap<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span>gap<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> end<span class="token operator">=</span>i<span class="token punctuation">;</span>
	<span class="token keyword">int</span> tmp<span class="token operator">=</span>a<span class="token punctuation">[</span>end<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>end<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token operator">&lt;</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			a<span class="token punctuation">[</span>end<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
			end<span class="token operator">-=</span>gap<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	a<span class="token punctuation">[</span>end<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>	
</code></pre> 
<p><strong>这样子的话，就不是一个一个组的排，而是从第一个元素开始，按照其组别来排顺序，相对于分组比较，多组并排明显更简洁</strong></p> 
<p><strong>完成这些之后，我们就可以着手开始实现真正的希尔排序了！</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> gap<span class="token operator">=</span>n<span class="token punctuation">;</span>
	<span class="token comment">//gap&gt;1时是预排序，目的：接近有序</span>
	<span class="token comment">//gap==1时就是直接插入排序，目的：有序</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>gap<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		gap<span class="token operator">=</span>gap<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//让其预排序之后最终gap==1，进行最终的直接插入排序</span>
		<span class="token comment">//gap越大，大的值更快调到后面，小的值可以更快的调到前面，越不接近有序；gap越小，跳得越慢，但是越接近有序。</span>
		<span class="token comment">//gap=gap/3+1;也可以，效率更高，时间复杂度更低，一个是log2N，一个是log3N</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span>gap<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> end<span class="token operator">=</span>i<span class="token punctuation">;</span>
			<span class="token keyword">int</span> tmp<span class="token operator">=</span>a<span class="token punctuation">[</span>end<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span><span class="token punctuation">(</span>end<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token operator">&lt;</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
					a<span class="token punctuation">[</span>end<span class="token operator">+</span>tmp<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
					end<span class="token operator">-=</span>gap<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				
				<span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			a<span class="token punctuation">[</span>end<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p><strong>那么大家一定很好奇，这么复杂的希尔排序，它的时间复杂度相较直接插入排序相比是否有进步，它的使用效率是否高于直接插入排序，接下来我就为大家来展示一下它们的差别。</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 使用时间种子初始化伪随机数生成器</span>
    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 填充数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000</span><span class="token punctuation">;</span>  <span class="token comment">// 生成0到999之间的随机数</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">clock_t</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>
    <span class="token keyword">double</span> cpu_time_used<span class="token punctuation">;</span>

    <span class="token comment">// 测试插入排序的执行时间</span>
    start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">InsertSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    end <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cpu_time_used <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"InsertSort took %f seconds to execute \n"</span><span class="token punctuation">,</span> cpu_time_used<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试希尔排序的执行时间</span>
    start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ShellSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    end <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cpu_time_used <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ShellSort took %f seconds to execute \n"</span><span class="token punctuation">,</span> cpu_time_used<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/66/2d/PLTfj130_o.png" alt="在这里插入图片描述"><br> <strong>可以看出，在初始化10000个随机数的数组中，直接插入排序和希尔排序之间的效率差了几十倍，而如果数据更多，可能差的还会更多。</strong></p> 
<p><strong>在最坏情况下(完全逆序），希尔排序的时间复杂度是O(n^2)，这与直接插入排序的时间复杂度相同，但是在一般情况下其平均时间复杂度要优于O(n ^2)。希尔排序时间复杂度的优劣程度取决于间隔序列的选取，不同的间隔序列的希尔排序的时间复杂度也会有所不同。</strong></p> 
<p><strong>在实际使用中，通常使用增量序列为n/2,k=k/2,…1的希尔排序，在平均情况下，其时间复杂度大约介于O(n^1.3)和O(n ^2)之间，这使得希尔排序在中等规模数据时具有较好的性能。</strong></p> 
<p><strong>其实我们自己也可以简单分析一下，以最坏情况来看：</strong><br> <strong>gap很大时，gap==n/3+1，此时我们忽略+1 。这一趟每组3个，移动次数：第二个最多移动1次，第三个最多移动2次，合计为3；而总计有3/n组，累计移动的次数是（1+2) * 3/n=n</strong><br> <strong>而下一轮预排序，gap==n/9，每组9个，移动次数：1+2+3…+8=36；总计n/9组，累计移动次数4n，但这是最坏的情况下做出的判断，在经历过第一次排序之后，已经比刚才更接近有序，不会所有的元素都要排序，所以次数必定是小于4n的，而后面的预排序也是与这个一样的，所以我们并不确定其时间复杂度，只能算出一个大概的区间，具体情况只能跟当前排序的数据元素相关，需要经过大量分析才能得出结论。</strong></p> 
<p><strong>以上就是排序的第一讲：插入排序！下一节我们将会讲解选择排序，欢迎大家关注后续文章！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b34181815e31e6876e403718f4772d7e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度了解TCP/IP模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3c1ec2dba1c074fa3f0ca96cdf6221d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot 整合 ElasticSearch 方法 (二)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>