<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>社区发现系列02-算法介绍 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="社区发现系列02-算法介绍" />
<meta property="og:description" content="hello, 大家好，欢迎来到阿君聊风控，我是阿君（一名有7年互金和电商风控经验的算法工程师）。 在上篇文章https://blog.csdn.net/u010569893/article/details/128565829?spm=1001.2014.3001.5502 中我们了解到可以用社区发现技术来对图进行划分，进而挖掘到作弊团伙。那么常用的社区发现算法有哪些呢？今天我们就来聊一聊常用的社区发现算法和原理，以及通过实验来来对比不同社区发现算法划分的效果 一、社区发现算法 网络图内部连接比较紧密的节点子集合对应的子图叫做社区（community），各社区节点集合彼此没有交集的称为非重叠型（disjoint）社区，有交集的称为重叠型（overlapping）社区。对给定的网络图寻找其社区结构的过程称为“社区发现”。大体上看，社区发现的过程就是一种聚类的过程。 1.1 LPA标签传播算法 1、基本思想：
标签传播算法是不重叠社区发现的经典算法，其基本思想是：将一个节点的邻居节点的标签中数量最多的标签作为该节点自身的标签。给每个节点添加标签（label）以代表它所属的社区，并通过标签的“传播”形成同一标签的“社区”结构。
给每个节点添加标签（label）以代表它所属的社区，并通过标签的“传播”形成同一标签的“社区”结构。一个节点的标签取决于它邻居节点的标签：假设节点z的邻居节点有z1至zk，那么哪个社区包含z的邻居节点最多z就属于那个社区（或者说z的邻居中包含哪个社区的标签最多，z就属于哪个社区）。优点是收敛周期短，无需任何先验参数(不需事先指定社区个数和大小)，算法执行过程中不需要计算任何社区指标。
时间复杂度接近线性：对顶点分配标签的复杂度为O(n)，每次迭代时间为O( m)，找出所有社区的复杂度为O (n &#43;m)，但迭代次数难以估计
2、传播过程： 1)初始时，给每个节点一个唯一的标签； 2)每个节点使用其邻居节点的标签中最多的标签来更新自身的标签。 3)反复执行步骤2)，直到每个节点的标签都不再发生变化为止。 一次迭代过程中一个节点标签的更新可以分为同步和异步两种。所谓同步更新，即节点z在第t次迭代的label依据于它的邻居节点在第t-1次迭代时所得的label；异步更新，即节点z在第t次迭代的label依据于第t次迭代已经更新过label的节点和第t次迭代未更新过label的节点在第t-1次迭代时的label。
注： 1、迭代次数设定一个阈值，可以防止过度运算； 2、对于二分图等网络结构，同步更新会引起震荡； //3、类似（“强”社区&gt;）定义的结构（该社区&gt;=）； 4、每个顶点在初始的时候赋予唯一的标签，即“重要性”相同，而迭代过程又采用随机序列，会导致同一初始状态不同结果甚至巨型社区的出现； 5、如果能预测“社区中心”点，能有效提高社区发现的准确度，大幅提高效率； 6、同一节点的邻居节点的标签可能存在多种社区最大数目相同的情况，取“随机”一个作为其标签
3、算法改进思路：初始化或传播改进 1)给节点或边添加权重（势函数、模块密度优化、LeaderRank值、局部拓扑信息的相似度、标签从属系数等），信息熵等描述节点的传播优先度，进而初步确定社区中心点以提高社区划分的精度； 2）标签初始化改进，如提取一些较为紧密的子结构来作为标签传播的初始标签（非重叠最小极大团提取算法 orz。。。）或通过初始社区划分算法先确定社区的雏形再进行传播。 3）标签随机选择改进，将1）中的权值和节点邻接点的度数等作为参考因素，对标签更新过程进行修正。
1)在社区中寻找不重叠三角形作为起始簇的雏形，以提高算法结果的稳定性和运行效率； 2)添加标签熵属性，在迭代过程中不采用随机序列，而是根据每个节点的标签熵来排序序列； 3)在2）的基础上，为了不完全消除标签传播算法的随机性，将排序好的队列平均分成三个部分，在每个部分内，节点进行随机排列。 4)对于同一节点的邻居节点的标签可能存在多种社区最大数目相同的情况，不使用随机方法，而是分析该节点的邻节点的邻节点集标签分布情况来决定该节点的标签
5)在社区中寻找以度最大的若干节点为中心的“雪花型”结构作为起始簇的雏形 1.2 Louvain算法（基于模块度的层次型社区发现算法） 1、 算法的思想： 1）初始时，将图中的每个节点看作是一个独立的社区，社区的数量跟节点的数量相同 2）对每个节点i， 分别尝试将该节点划分到其邻居节点所在的社区，根据下面的公式（3）计算划分前和划分后模块度的变化delta(Q) ，也就是模块度增益, 并记录模块度增益最大的那个邻居节点，如果最大模块度增益&gt;0, 则将即节点i分配到那个邻居节点中，否则保持不变 3）重复2），直到所有节点的所属社区不再变化 4）对图进行压缩，将所有的子图压缩成一个超节点，社区内节点之间的边的权重转化为超节点的权重，社区间边的权重转化为超节点的权重 5）重复1）直到整个图的模块度不再发生变化 从流程看，该算法可以产生层次性的社区结构，这样分层的结构是每个网络的自然属性，使研究员得意深入了解某个社区的内部结构和形成机制。 其中计算最耗时的是最底层的社区划分，节点按社区压缩后，将大大缩减节点和边的数量，并且计算节点i的分配只跟节点i的邻居节点有关，因此计算很快，是一种高效的层次社区发现算法，是一种迭代的2层社区发现算法 该算法目前被认为是快速、准确，被认为是效果和性能最优的社区发现算法之一；该算法对图的大小几乎没有上限要求，并且能够在迭代几轮后快速收敛，这为处理拥有百万节点以上的大型社交网络的社区发现提供了可能 2、 模块度和模块度的增益 参考：http://www.yalewoo.com/modularity_community_detection.html 1）模块度的定义： 可以理解为：社区内部变得权重减去所有与社区节点相连边的权重和的平方，对无向图更好理解，即社区内部边的度数减去社区内节点的总度数。 2）模块度的增益 模块度增益 上式可以理解为： 括号内第一项ki,in表示实际节点i（或社区A）与要移入社区B之间的连接边的权重之和, tot ki/m 则为随机情况下节点i（或社区A）在总的加权度为 tot ki的情况下与当前graph上任意 的节点或社区连接的边的权重的期望. 第一项若比第二项大则说明节点i（或社区A）与该社 区B的连接程度是具有显著的意义的, 那么便加入到该社区, 反之则不加入。 模块度是评估一个社区网络划分好坏的度量方法，可以看出，它是一种相对性的指标。 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ad4fbee9722ffd1e2d33cf3de4ac17e2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-06T18:11:04+08:00" />
<meta property="article:modified_time" content="2023-01-06T18:11:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">社区发现系列02-算法介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="margin-left:0;"> 
 <span style="color:#000000;"><em>hello, 大家好，欢迎来到阿君聊风控，我是阿君（一名有7年互金和电商风控经验的算法工程师）。</em></span> 
 <br>   
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#4d4d4d;">在上篇文章https://blog.csdn.net/u010569893/article/details/128565829?spm=1001.2014.3001.5502 </span><span style="color:#4d4d4d;">中我们了解到可以用社区发现技术来对图进行划分，进而挖掘到作弊团伙。那么常用的社区发现算法有哪些呢？今天我们就来聊一聊常用的社区发现算法和原理，以及通过实验来来对比不同社区发现算法划分的效果</span></span> 
</div> 
<div style="margin-left:0;"></div> 
<h2><strong><span style="color:#000000;"><span style="color:#4d4d4d;">一、社区发现算法</span></span></strong></h2> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#4d4d4d;"><span style="color:#333333;">网络图</span><span style="color:#0000ff;">内部连接比较紧密的节点子集</span><span style="color:#333333;">合对应的子图叫做社区（community），各社区节点集合彼此没有交集的称为非重叠型（disjoint）社区，有交集的称为重叠型（overlapping）社区。对给定的网络图寻找其社区结构的过程称为“社区发现”。大体上看，社区发现的过程就是一种聚类的过程。</span></span></span> 
</div> 
<div style="margin-left:0;"></div> 
<h3><strong><span style="color:#000000;"><span style="color:#4d4d4d;">1.1 LPA标签传播算法</span></span></strong></h3> 
<div style="margin-left:0;"> 
 <p style="margin-left:0;"><span style="color:#000000;"><span style="color:#333333;"><strong>1、基本思想：</strong></span></span></p> 
 <p style="margin-left:0;"><span style="color:#000000;"><span style="color:#333333;"><strong>标签传播算法是<span style="color:#0000ff;">不重叠</span>社区发现的经典算法，其基本思想是：将一个节点的邻居节点的标签中数量最多的标签作为该节点自身的标签。给每个节点添加标签（label）以代表它所属的社区，并通过标签的“传播”形成同一标签的“社区”结构。</strong></span></span></p> 
 <p style="margin-left:0;"><span style="color:#000000;"><span style="color:#333333;">给每个节点添加标签（label）以代表它所属的社区，并通过标签的“传播”形成同一标签的“社区”结构。一个节点的标签取决于它邻居节点的标签：假设节点z的邻居节点有z1至zk，那么哪个社区包含z的邻居节点最多z就属于那个社区（或者说z的邻居中包含哪个社区的标签最多，z就属于哪个社区）。优点是收敛周期短，无需任何先验参数(不需事先指定社区个数和大小)，算法执行过程中不需要计算任何社区指标。</span></span></p> 
 <p style="margin-left:0;"><span style="color:#000000;"><span style="color:#333333;">时间复杂度接近线性：对顶点分配标签的复杂度为O(n)，每次迭代时间为O( m)，找出所有社区的复杂度为O (n +m)，但迭代次数难以估计</span></span></p> 
 <p style="margin-left:0;"><span style="color:#000000;"><span style="color:#4d4d4d;"><strong>2、传播过程</strong>： <br> 1)初始时，<span style="color:#0000ff;">给每个节点一个唯一的标签</span>； <br> 2)每个节点使用其邻居节点的标签中最多的标签来更新自身的标签。 <br> 3)反复执行步骤2)，直到每个节点的标签都不再发生变化为止。 <br> 一次迭代过程中一个节点标签的更新可以分为同步和异步两种。所谓同步更新，即节点z在第t次迭代的label依据于它的邻居节点在第t-1次迭代时所得的label；异步更新，即节点z在第t次迭代的label依据于第t次迭代已经更新过label的节点和第t次迭代未更新过label的节点在第t-1次迭代时的label。</span></span></p> 
 <p style="margin-left:0;"><span style="color:#000000;"><strong>注：</strong><span style="color:#4d4d4d;"> </span><br><span style="color:#4d4d4d;">1、</span><span style="color:#0000ff;">迭代次数设定一个阈值，可以防止过度运算</span><span style="color:#4d4d4d;">； </span><br><span style="color:#4d4d4d;">2、对于二分图等网络结构，同步更新会引起震荡； </span><br><span style="color:#4d4d4d;">//3、类似（“强”社区&gt;）定义的结构（该社区&gt;=）； </span><br><span style="color:#4d4d4d;">4、每个顶点在初始的时候赋予唯一的标签，即“重要性”相同，而迭代过程又采用随机序列，会导致同一初始状态不同结果甚至巨型社区的出现； </span><br><span style="color:#4d4d4d;">5、</span><span style="color:#0000ff;">如果能预测“社区中心”点，能有效提高社区发</span><span style="color:#0000ff;">现的准确度，大幅提高效</span><span style="color:#0000ff;">率</span><span style="color:#4d4d4d;">； </span><br><span style="color:#4d4d4d;">6、</span><strong>同一节点的邻居节点的标签可能存在多种社区最大数目相同的情况，取“随机”一个作为其标签</strong></span></p>   
 <p style="margin-left:0;"></p> 
 <p style="margin-left:0;"><span style="color:#000000;"><span style="color:#333333;"><strong>3、算法改进思路</strong>：初始化或传播改进 <br> 1)<span style="color:#0000ff;">给节点或边添加权重</span>（势函数、模块密度优化、LeaderRank值、局部拓扑信息的相似度、标签从属系数等），信息熵等描述节点的传播优先度，进而初步确定社区中心点<span style="color:#0000ff;">以提高社区划分的精度</span>； <br> 2）<span style="color:#0000ff;">标签初始化改进，如提取一些较为紧密的子结构来作为标签传播的初始标签</span>（非重叠最小极大团提取算法 orz。。。）或通过初始社区划分算法先确定社区的雏形再进行传播。 <br> 3）<span style="color:#0000ff;">标签随机选择改进，将1）中的权值和节点邻接点的度数等作为参考因素，对标签更新过程进行修正</span>。</span></span></p> 
 <p style="margin-left:0;"><span style="color:#000000;"><span style="color:#333333;">1)<span style="color:#0000ff;">在社区中寻找不重叠三角形作为起始簇的雏形，以提高算法结果的稳定性和运行效率</span>； <br> 2)添加标签熵属性，在迭代过程中不采用随机序列，而是根据每个节点的标签熵来排序序列； <br> 3)在2）的基础上，为了不完全消除标签传播算法的随机性，将排序好的队列平均分成三个部分，在每个部分内，节点进行随机排列。 <br> 4)对于同一节点的邻居节点的标签可能存在多种社区最大数目相同的情况，不使用随机方法，而是分析该节点的邻节点的邻节点集标签分布情况来决定该节点的标签</span></span></p> 
 <p style="margin-left:0;"><span style="color:#000000;"><span style="color:#333333;">5)<span style="color:#0000ff;">在社区中寻找以度最大的若干节点为中心的“雪花型”结构作为起始簇的雏形 </span></span></span></p> 
 <br>   
</div> 
<h3><strong><span style="color:#000000;"><span style="color:#4d4d4d;">1.2 Louvain算法（基于模块度的层次型社区发现算法）</span></span></strong></h3> 
<h4><strong><span style="color:#000000;">1、 算法的思想：</span></strong></h4> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#4d4d4d;">1）初始时，将图中的每个节点看作是一个独立的社区，社区的数量跟节点的数量相同</span></span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#4d4d4d;">2）对每个节点i， 分别尝试将该节点划分到其邻居节点所在的社区，根据下面的公式（3）</span><span style="color:#0000ff;">计算划分前和划分后模块度的变化delta(Q)</span><span style="color:#0000ff;"> </span><span style="color:#4d4d4d;">，也就是模块度增益, 并记录模块度增益最大的那个邻居节点，</span><span style="color:#0000ff;">如果最大模块度增益&gt;0, 则将即节点i分配到那个邻居节点中</span><span style="color:#4d4d4d;">，否则保持不变</span></span> 
</div> 
<div style="margin-left:0;"> 
 <img alt="" height="250" src="https://images2.imgbox.com/9d/4b/DuwFuYBh_o.png" width="1200"> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#4d4d4d;">3）重复2），直到所有节点的所属社区不再变化</span></span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#4d4d4d;">4）对图进行压缩，将所有的</span><span style="color:#0000ff;">子图压缩成一个超节点</span><span style="color:#4d4d4d;">，社区内节点之间的边的权重转化为超节点的权重，社区间边的权重转化为超节点的权重</span></span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#4d4d4d;">5）重复1）直到整个图的模块度不再发生变化</span></span> 
</div> 
<div style="margin-left:0;"> 
 <div style="margin-left:0;"> 
  <img alt="" height="469" src="https://images2.imgbox.com/c4/a7/NQsmzcgz_o.png" width="919"> 
 </div> 
 <p></p> 
 <div style="margin-left:0;"> 
  <span style="color:#000000;"><span style="color:#4d4d4d;">从流程看，该算法可以产生</span><span style="color:#0000ff;">层次性的社区结构</span><span style="color:#4d4d4d;">，这样分层的结构是每个网络的自然属性，使研究员得意深入了解某个社区的内部结构和形成机制。</span></span> 
 </div> 
 <div style="margin-left:0;"> 
  <span style="color:#000000;"><span style="color:#4d4d4d;">其中计算</span><span style="color:#0000ff;">最耗时的是最底层的社区划分</span><span style="color:#4d4d4d;">，节点按社区压缩后，将大大缩减节点和边的数量，并且计算节点i的分配只跟节点i的邻居节点有关，因此计算很快，是一种高效的层次社区发现算法，是一种迭代的2层社区发现算法</span></span> 
 </div> 
 <div style="margin-left:0;"> 
  <span style="color:#000000;"><span style="color:#4d4d4d;">该算法目前被认为是快速、准确，被认为是效果和性能最优的社区发现算法之一；该算法对图的大小几乎没有上限要求，并且能够在迭代几轮后快速收敛，这为处理拥有百万节点以上的大型社交网络的社区发现提供了可能</span></span> 
 </div> 
 <h4><span style="color:#000000;"><strong><span style="color:#4d4d4d;">2、 模块度和模块度的增益</span></strong></span></h4> 
 <div style="margin-left:0;"> 
  <span style="color:#000000;">参考：http://www.yalewoo.com/modularity_community_detection.html</span> 
 </div> 
 <div style="margin-left:0;"></div> 
 <div style="margin-left:0;"> 
  <span style="color:#000000;"><span style="color:#0000ff;">1）模块度的定义：</span></span> 
 </div> 
 <div style="margin-left:0;"> 
  <span style="color:#000000;"><span style="color:#0000ff;">可以理解为：社区内部变得权重减去所有与社区节点相连边的权重和的平方，对无向图更好理解，即社区内部边的度数减去社区内节点的总度数。</span></span> 
 </div> 
 <div style="margin-left:0;"> 
  <div style="margin-left:0;"> 
   <img alt="" height="416" src="https://images2.imgbox.com/16/35/gvKc0eJC_o.png" width="836"> 
  </div> 
  <p></p> 
 </div> 
 <div style="margin-left:0;"> 
  <span style="color:#000000;"><span style="color:#ff0000;">2）模块度的增益</span></span> 
 </div> 
 <div style="margin-left:0;"> 
  <span style="color:#000000;"><span style="color:#4d4d4d;">模块度增益</span></span> 
 </div> 
 <div style="margin-left:0;"> 
  <div style="margin-left:0;"> 
   <img alt="" height="125" src="https://images2.imgbox.com/7a/88/NZUxWgbP_o.png" width="705"> 
  </div> 
  <p></p> 
 </div> 
 <div style="margin-left:0;"> 
  <span style="color:#000000;"><span style="color:#4d4d4d;">上式可以理解为： 括号内第一项ki,in表示实际节点i（或社区A）与要移入社区B之间的连接边的权重之和, tot ki/m 则为随机情况下节点i（或社区A）在总的加权度为 tot ki的情况下与当前graph上任意 的节点或社区连接的边的权重的期望. 第一项若比第二项大则说明节点i（或社区A）与该社 区B的连接程度是具有显著的意义的, 那么便加入到该社区, 反之则不加入。 模块度是评估一个社区网络划分好坏的度量方法，可以看出，它是一种相对性的指标。</span></span> 
 </div> 
 <div style="margin-left:0;"></div> 
 <div style="margin-left:0;"></div> 
 <div style="margin-left:0;"></div> 
</div> 
<div style="margin-left:0;"></div> 
<h3><strong><span style="color:#000000;"><span style="color:#4d4d4d;">1.3、CPM算法</span></span></strong></h3> 
<div style="margin-left:0;"> 
 <p style="margin-left:0;"><span style="color:#000000;"><span style="color:#2f2f2f;">k-团渗透算法(CPM)[1]是第一个能够发现</span><span style="color:#0000ff;">重叠社区</span><span style="color:#2f2f2f;">的算法，重叠社区指的是</span><span style="color:#0000ff;">结点可以同时属于多个社区</span><span style="color:#2f2f2f;">。重叠社区在社交网络中是十分常见的，因为每个人都有着多种多样的社交关系。</span></span></p> 
 <div style="margin-left:0;"> 
  <img alt="" height="270" src="https://images2.imgbox.com/eb/7d/rrFCabNK_o.png" width="303"> 
 </div> 
 <p></p> 
 <div style="margin-left:0;"> 
  <p style="margin-left:0;"><span style="color:#000000;"><span style="color:#0000ff;">网络中的最大团指的是，团中任意两个结点之间都有边连接，并且它不被其他的团所包含。</span></span></p> 
  <p style="margin-left:0;"><span style="color:#000000;"><span style="color:#2f2f2f;">CPM算法的想法非常简单，首先它找出网络中所有大小至少为k的最大团。然后构建一个团图，每个最大团都是团图中的一个结点，如果两个团c1与c2共享min(c1,c2)-1个邻居的话，它们在新图中的结点之间就存在边。最后团图中的每个连通单元就是一个结点的社区，而它可能是重叠的。</span></span></p> 
  <span style="color:#000000;"><span style="color:#4d4d4d;">代码参见：https://github.com/zzz24512653/CommunityDetection/blob/master/algorithm/CPM.py</span></span> 
 </div> 
 <div style="margin-left:0;"></div> 
 <h3><span style="color:#000000;"><strong><span style="color:#4d4d4d;">1.4、</span>GN算法（分裂性社区发现算法）</strong></span></h3> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;">http://blog.csdn.net/aspirinvagrant/article/details/45599071</span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;">    <span style="color:#0000ff;">GN算法[1]是社区发现中的第一个算法</span>，也就是它开启了这个研究领域。它的基本思想是删除掉那些社区之间的连接，那么剩下的每个连通部分就是一个社区。</span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;">那么问题来了，就是那些是社区之间的边呢？作者巧妙地借助最短路径解决了这个问题，</span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;">他们定义一条边的<span style="color:#0000ff;">介数(betweeness)为网络中所有结点之间的最短路径中通过这条边的数量</span>，而介数高的边要比介数低的边更可能是社区之间的边。其实，这也比较好理解，因为两个社区中的结点之间的最短路径都要经过那些<span style="color:#0000ff;">社区之间的边，所以它们的介数会很高</span>。</span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;">    GN算法每次都删除网络中介数最大的边，直至网络中的所有边都被删除。这样GN的过程对应着一颗自顶向下构建的层次树。在层次树中选择一个合适的层次分割即可。</span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="background-color:#fefefe;"><span style="color:#555555;">GN算法的步骤如下： </span></span><br><span style="background-color:#fefefe;"><span style="color:#555555;">（1）计算每一条边的边介数； </span></span><br><span style="background-color:#fefefe;"><span style="color:#555555;">（2）删除边界数最大的边； </span></span><br><span style="background-color:#fefefe;"><span style="color:#555555;">（3）重新计算网络中剩下的边的边阶数；</span></span><br><span style="background-color:#fefefe;"><span style="color:#555555;">（4）重复(3)和(4)步骤，直到网络中的任一顶点作为一个社区为止。</span></span></span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#ff0000;"><span style="background-color:#fefefe;">GN算法的缺陷：</span></span></span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#555555;"><span style="background-color:#fefefe;">（1）不知道最后会有多少个社区；</span></span><br><span style="color:#555555;"><span style="background-color:#fefefe;">（2）在计算边介数的时候可能会有很对重复计算最短路径的情况，时间复杂度太高；</span></span><br><span style="color:#555555;"><span style="background-color:#fefefe;">（3）GN算法不能判断算法终止位置。</span></span></span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#333333;"><span style="background-color:#fefefe;">（4）但是其计算</span></span><span style="background-color:#fefefe;"><span style="color:#0000ff;">时间复杂度较高</span></span><span style="color:#333333;"><span style="background-color:#fefefe;">，对于一个拥有n个节点和m条边的网络，其时间复杂度为O(m2n)，因此往往不能直接应用在大图的社区发现问题中。</span></span></span> 
</div> 
<div style="margin-left:0;"></div> 
<div style="margin-left:0;"></div> 
<h2><strong><span style="color:#000000;"><span style="background-color:#fefefe;"><span style="color:#333333;">二、不同算法的社区划分效果：</span></span></span></strong></h2> 
<h4><strong><span style="color:#000000;"><span style="background-color:#fefefe;"><span style="color:#333333;">1、样本：</span></span></span></strong></h4> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="background-color:#fefefe;"><span style="color:#333333;">1500个节点的互联网小额贷款首次逾期账号形成的大图</span></span></span> 
</div> 
<h4><strong><span style="color:#000000;"><span style="background-color:#fefefe;"><span style="color:#333333;">2、社区划分软件：</span><span style="color:#0000ff;">pajek、networkx</span></span></span></strong></h4> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#0000ff;"><span style="background-color:#fefefe;">pajek的使用：</span></span></span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#0000ff;"><span style="background-color:#fefefe;">参考：<a href="http://blog.csdn.net/qysh123/article/details/22751523" title="复杂网络分析软件NetworkX和Pajek的关联及后者使用方法小结_蛐蛐蛐的博客-CSDN博客">复杂网络分析软件NetworkX和Pajek的关联及后者使用方法小结_蛐蛐蛐的博客-CSDN博客</a></span></span></span> 
</div> 
<div style="margin-left:0;"> 
 <ol style="margin-left:0;"><li><span style="color:#000000;"><span style="background-color:#fefefe;"><span style="color:#333333;"><span style="color:#333333;"><span style="background-color:#fefefe;">networkx是python的一个第三方包，可以方便地调用各种图算法的计算。</span></span></span></span></span></li><li><span style="color:#000000;"><span style="color:#333333;"><span style="color:#373737;">将NetworkX中的网络转成Pajek可以读取的网络，实际上只需要一条语句：</span> nx.write_pajek(G,<span style="color:#0000ff;">'Pajek.net'</span>) </span></span></li><li><span style="color:#000000;"><span style="color:#333333;"><span style="color:#373737;">然后就可以用Pajek打开这个文件，具体而言，启动Pajek界面后，选择“Network”下的第一个图标，然后打开。这里再简单总结一下这个软件的使用。例如，对于刚才打开的网络，可以进行社团发现，操作如下：</span></span></span></li><li><span style="color:#000000;"><span style="color:#333333;"><span style="color:#373737;">在菜单栏中点Network——Create Partition——Communities——Louvain Method，选择任一种</span><a class="replace_word" href="http://lib.csdn.net/base/datastructure" rel="nofollow" title="算法">算法</a><span style="color:#373737;">，运行后就可以在Partitions这一栏生成结果。</span></span></span></li><li><span style="color:#000000;"><span style="color:#333333;"><span style="color:#373737;">对于这样的社团划分结果，我们希望能把结果可视化出来，那么只需要选择Draw——Network + First Partition即可。就简单总结这么多，希望能帮助大家在熟悉NetworkX的前提下迅速掌握Pajek的使用方法。</span></span></span></li></ol> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#0000ff;"><span style="background-color:#ffff00;">3、实验结论：</span></span></span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="color:#0000ff;"><span style="background-color:#fefefe;">1）Louvain算法和GN算法的划分效果是比较符合预期的，但是由于GN算法的时间复杂度太高，所有Louvian算法是最优的选择</span></span></span> 
</div> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="background-color:#fefefe;"><span style="background-color:#ffffff;"><span style="color:#0000ff;">2）Louvain算法可用于风控、个性化推荐等领域，虽然效果比不上GNN，但是计算成本非常低且无需标注数据，适用于规模较大的网络。在计算成本和计算时间上有着明显的优势。</span></span></span></span> 
</div> 
<div style="margin-left:0;"></div> 
<h4><strong><span style="color:#000000;"><span style="background-color:#fefefe;"><span style="color:#333333;">4、不同社区划分算法的实验结果</span></span></span></strong></h4> 
<p><strong><span style="color:#000000;"><span style="background-color:#fefefe;"><span style="color:#333333;">实验1 Louvain算法：</span></span></span></strong></p> 
<div style="margin-left:0;"> 
 <span style="color:#000000;"><span style="background-color:#fefefe;"><span style="color:#333333;"><span style="color:#000000;"><span style="background-color:#ffffff;">结果：有32个社区，Q=0.8678</span></span></span></span></span> 
</div> 
<div style="margin-left:0;"> 
 <div style="margin-left:0;"> 
  <img alt="" height="523" src="https://images2.imgbox.com/9b/55/Doln7IYM_o.png" width="933"> 
 </div> 
 <p></p> 
 <div style="margin-left:0;"></div> 
</div> 
<div style="margin-left:0;"></div> 
<p><strong><span style="color:#000000;"><span style="background-color:#fefefe;"><span style="color:#333333;">实验2:</span></span><span style="background-color:#fefefe;">GN算法</span></span></strong></p> 
<div style="margin-left:0;"> 
 <div style="margin-left:0;"> 
  <span style="color:#000000;"><span style="color:#000000;"><span style="background-color:#fefefe;"><span style="color:#333333;">结果：35个社区  Q=0.854</span></span></span></span> 
 </div> 
 <div style="margin-left:0;"> 
  <div style="margin-left:0;"> 
   <img alt="" height="602" src="https://images2.imgbox.com/8a/04/yytP6RMb_o.png" width="1096"> 
  </div> 
  <p></p> 
  <p><span style="color:#000000;"><span style="color:#000000;"><strong><span style="color:#333333;">实验3:<span style="background-color:#ffffff;">谱聚类算法（基于谱图划分的聚类算法）</span></span></strong></span></span></p> 
  <div style="margin-left:0;"> 
   <span style="color:#000000;"><span style="color:#000000;"><span style="color:#333333;"><span style="background-color:#ffffff;">结果：n=40 （缺点：划分出较多的孤立点，社区划分不均匀）</span></span></span></span> 
  </div> 
  <div style="margin-left:0;"> 
   <img alt="" height="557" src="https://images2.imgbox.com/a0/c6/gG8d9Pa5_o.png" width="1092"> 
  </div> 
  <p></p> 
  <div style="margin-left:0;"> 
   <div style="margin-left:0;"></div> 
  </div> 
 </div> 
 <p><span style="color:#000000;"><strong><span style="background-color:#fefefe;"><span style="color:#333333;">实验4: </span></span><span style="background-color:#fefefe;">LPA算法</span></strong></span></p> 
 <h3></h3> 
 <div style="margin-left:0;"> 
  <span style="color:#000000;"><span style="color:#000000;"><span style="color:#333333;">结果：n=390（划分出的孤立点较多，社区划分不均匀）</span></span></span> 
 </div> 
 <h3><img alt="" height="574" src="https://images2.imgbox.com/e6/4a/uIyLaeXn_o.png" width="1101"></h3> 
 <p></p> 
 <h3></h3> 
</div> 
<div style="margin-left:0;">
    
 <p><span style="color:#000000;"><strong><span style="background-color:#fefefe;"><span style="color:#333333;">实验5: EM算法：</span></span></strong></span></p> 
 <div style="margin-left:0;"> 
  <span style="color:#000000;"><span style="color:#333333;">结果：n=40</span></span> 
 </div> 
 <div style="margin-left:0;"> 
  <div style="margin-left:0;"> 
   <img alt="" height="620" src="https://images2.imgbox.com/a4/54/W23b5jRc_o.png" width="915"> 
  </div> 
  <p></p> 
 </div> 
</div> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0665ca5c79f956172ff2832066a978f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c&#43;&#43; std::funciona代替函数指针——结合std::bind</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/714535645b75a962245a1bbb00f28375/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;高阶数据结构】B树、B&#43;树、B*树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>