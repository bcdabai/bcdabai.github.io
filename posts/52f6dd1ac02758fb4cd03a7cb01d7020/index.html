<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>秒懂设计模式之原型模式（Prototype Pattern） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="秒懂设计模式之原型模式（Prototype Pattern）" />
<meta property="og:description" content="[版权申明] 非商业目的注明出处可自由转载
博文地址：https://blog.csdn.net/ShuSheng0007/article/details/116463979
出自：shusheng007
设计模式汇总篇，一定要点赞收藏：
永不磨灭的设计模式（有这一篇真够了，拒绝标题党）
文章目录 概述类型难度 定义使用场景UML类图实例第一步，原型接口第二步，原型类第三，客户端使用技术要点总结优缺点优点缺点 总结 概述 原型模式属于创建型模式，所以它是描述如何创建对象的模式。顾名思义，先搞一个原型对象出来，然后在这个原型对象的基础上修修补补再弄出一个新对象来。
我们一定要牢记设计模式是前人总结的一套可以有效解决问题的经验，不要一写代码就在考虑该使用什么设计模式，这是极其不可取的。正确的做法应该是在实现业务需求的同时，尽量遵守面向对象设计的六大设计原则即可。后期随着业务的扩展，你的代码会不断的演化和重构，在此过程中设计模式绝逼会大放异彩的。
类型 创建型（creational）
难度 2颗星
定义 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。
你看看这定义，就是不说人话！不管它，一会通过实例意会一下，再通过使用场景知道解决什么问题就可以了
使用场景 当一个对象的构建代价过高时。例如某个对象里面的数据需要访问数据库才能拿到，而我们却要多次构建这样的对象。当构建的多个对象，均需要处于某种原始状态时，就可以先构建一个拥有此状态的原型对象，其他对象基于原型对象来修改。 UML类图 照例上一张手撕UML类图
UML 类图也比较简单，只有两个部分
Prototype 这个是一个接口，里面必须含有一个可以克隆自己的方法。在Java中，我们可以使用JDK自带的java.lang.Cloneable接口来替代此接口
ConcretePrototype 实现了Prototype接口的原型对象，这个对象有个能力就是可以克隆自己。
实例 上回我们说到王二狗公司的大老板要看商城项目的周报表，二狗他们在开发中发现，批量导出报表时特别慢。经过调查发现是报表的主体部分特别耗时，那些头部，作者什么的都不怎么耗时。那二狗他们就在想，能不能将那些耗时的操作作为原型对象，然后在这个原型对象上添加上其他部分，对头，用原型模式可解。
假设一篇报表由报表头与报表体组成，报表体获取特别耗时，报表头不耗时，我们如何大量导出报表呢？
第一步，原型接口 原型接口必须有一个可以克隆自己的方法，反回类型为Prototype
public interface Prototype { Prototype copy(); } 第二步，原型类 这个类就是我们的原型类，准备被其他人克隆使用的，所以其实现Prototype接口，具备克隆的能力。根据业务需求，克隆可以是浅克隆，也可以是深克隆。
我们假设此类含有一个存放内容的List，这些数据都是从数据库读取的相对比较耗时。假设我们要生成多篇不同报表，内容基本不变（这是要点，只有你需要的对象是可以基于原型对象的才有意义），头部要不同。
public class Report implements Prototype { private List&lt;String&gt; parts; public Report() { this.parts = new ArrayList&lt;&gt;(); } public Report(List&lt;String&gt; parts) { this.parts = parts; } //耗时的数据加载操作 public void loadData() { pats." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/52f6dd1ac02758fb4cd03a7cb01d7020/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-13T23:03:45+08:00" />
<meta property="article:modified_time" content="2021-05-13T23:03:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">秒懂设计模式之原型模式（Prototype Pattern）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>[版权申明] 非商业目的注明出处可自由转载<br> 博文地址：https://blog.csdn.net/ShuSheng0007/article/details/116463979<br> 出自：shusheng007</p> 
</blockquote> 
<p>设计模式汇总篇，一定要点赞收藏：</p> 
<p><a href="https://blog.csdn.net/ShuSheng0007/article/details/115980889">永不磨灭的设计模式（有这一篇真够了，拒绝标题党）</a></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_11" rel="nofollow">概述</a></li><li><ul><li><a href="#_16" rel="nofollow">类型</a></li><li><a href="#_19" rel="nofollow">难度</a></li></ul> 
  </li><li><a href="#_22" rel="nofollow">定义</a></li><li><a href="#_28" rel="nofollow">使用场景</a></li><li><a href="#UML_32" rel="nofollow">UML类图</a></li><li><a href="#_46" rel="nofollow">实例</a></li><li><a href="#_52" rel="nofollow">第一步，原型接口</a></li><li><a href="#_60" rel="nofollow">第二步，原型类</a></li><li><a href="#_97" rel="nofollow">第三，客户端使用</a></li><li><a href="#_130" rel="nofollow">技术要点总结</a></li><li><a href="#_135" rel="nofollow">优缺点</a></li><li><ul><li><a href="#_136" rel="nofollow">优点</a></li><li><a href="#_139" rel="nofollow">缺点</a></li></ul> 
  </li><li><a href="#_142" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_11"></a>概述</h2> 
<p>原型模式属于创建型模式，所以它是描述如何创建对象的模式。顾名思义，先搞一个原型对象出来，然后在这个原型对象的基础上修修补补再弄出一个新对象来。</p> 
<p>我们一定要牢记设计模式是前人总结的一套可以有效解决问题的经验，不要一写代码就在考虑该使用什么设计模式，这是极其不可取的。正确的做法应该是在实现业务需求的同时，尽量遵守面向对象设计的六大设计原则即可。后期随着业务的扩展，你的代码会不断的演化和重构，在此过程中设计模式绝逼会大放异彩的。</p> 
<h3><a id="_16"></a>类型</h3> 
<p>创建型（creational）</p> 
<h3><a id="_19"></a>难度</h3> 
<p>2颗星</p> 
<h2><a id="_22"></a>定义</h2> 
<blockquote> 
 <p>使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。</p> 
</blockquote> 
<p>你看看这定义，就是不说人话！不管它，一会通过实例意会一下，再通过使用场景知道解决什么问题就可以了</p> 
<h2><a id="_28"></a>使用场景</h2> 
<ul><li>当一个对象的构建代价过高时。例如某个对象里面的数据需要访问数据库才能拿到，而我们却要多次构建这样的对象。</li><li>当构建的多个对象，均需要处于某种原始状态时，就可以先构建一个拥有此状态的原型对象，其他对象基于原型对象来修改。</li></ul> 
<h2><a id="UML_32"></a>UML类图</h2> 
<p>照例上一张手撕UML类图<br> <img src="https://images2.imgbox.com/e7/c8/wd3VoimU_o.jpg" alt="在这里插入图片描述"><br> UML 类图也比较简单，只有两个部分</p> 
<ul><li>Prototype</li></ul> 
<p>这个是一个接口，里面必须含有一个可以克隆自己的方法。在Java中，我们可以使用JDK自带的<code>java.lang.Cloneable</code>接口来替代此接口</p> 
<ul><li>ConcretePrototype</li></ul> 
<p>实现了<code>Prototype</code>接口的原型对象，这个对象有个能力就是可以克隆自己。</p> 
<h2><a id="_46"></a>实例</h2> 
<p>上回我们说到王二狗公司的大老板要看商城项目的周报表，二狗他们在开发中发现，批量导出报表时特别慢。经过调查发现是报表的主体部分特别耗时，那些头部，作者什么的都不怎么耗时。那二狗他们就在想，能不能将那些耗时的操作作为原型对象，然后在这个原型对象上添加上其他部分，对头，用原型模式可解。</p> 
<p>假设一篇报表由报表头与报表体组成，报表体获取特别耗时，报表头不耗时，我们如何大量导出报表呢？</p> 
<h2><a id="_52"></a>第一步，原型接口</h2> 
<p>原型接口必须有一个可以克隆自己的方法，反回类型为<code>Prototype</code></p> 
<pre><code>public interface Prototype {
    Prototype copy();
}
</code></pre> 
<h2><a id="_60"></a>第二步，原型类</h2> 
<p>这个类就是我们的原型类，准备被其他人克隆使用的，所以其实现<code>Prototype</code>接口，具备克隆的能力。根据业务需求，克隆可以是浅克隆，也可以是深克隆。</p> 
<p>我们假设此类含有一个存放内容的<code>List</code>，这些数据都是从数据库读取的相对比较耗时。假设我们要生成多篇不同报表，内容基本不变（这是要点，只有你需要的对象是可以基于原型对象的才有意义），头部要不同。</p> 
<pre><code>public class Report implements Prototype {
    private List&lt;String&gt; parts;

    public Report() {
        this.parts = new ArrayList&lt;&gt;();
    }

    public Report(List&lt;String&gt; parts) {
        this.parts = parts;
    }
	//耗时的数据加载操作
    public void loadData() {
        pats.clear();
        parts.add("老夫聊发少年狂，左牵黄，右擎苍，锦帽貂裘，千骑卷平冈。");
        parts.add("为报倾城随太守，亲射虎，看孙郎。");
        parts.add("酒酣胸胆尚开张，鬓微霜，又何妨！持节云中，何日遣冯唐？");
        parts.add("会挽雕弓如满月，西北望，射天狼。");
    }

    public List&lt;String&gt; getContents() {
        return parts;
    }

    @Override
    public Prototype copy() {
        List&lt;String&gt; cloneList = new ArrayList&lt;&gt;(parts);
        return new Report(cloneList);
    }
}
</code></pre> 
<h2><a id="_97"></a>第三，客户端使用</h2> 
<pre><code>public class PrototypeClient {
    public void getReport(){
        //创建原型
        Report reportPrototype = new Report();
        //耗费资源的操作
        reportPrototype.loadData();

        //使用原型对象构建新的对象
        Report reportWithTitle = (Report) reportPrototype.copy();
        List&lt;String&gt; reportContent= reportWithTitle.getContents();
        reportContent.add(0,"《江城子·密州出猎》");
        reportContent.add(1,"----------------------------------------------------------");

        for (String s : reportContent) {
            System.out.println(s);
        }
    }
}
</code></pre> 
<p>输出</p> 
<pre><code>《江城子·密州出猎》
--------------------------------------------------------------------------------
老夫聊发少年狂，左牵黄，右擎苍，锦帽貂裘，千骑卷平冈。
为报倾城随太守，亲射虎，看孙郎。
酒酣胸胆尚开张，鬓微霜，又何妨！持节云中，何日遣冯唐？
会挽雕弓如满月，西北望，射天狼。
</code></pre> 
<h2><a id="_130"></a>技术要点总结</h2> 
<ul><li>首先要有一个可以克隆自己的接口，例如此处的<code>Prototype</code></li><li>其他对象都是可以基于已经构建出来的原型对象扩展的。</li></ul> 
<h2><a id="_135"></a>优缺点</h2> 
<h3><a id="_136"></a>优点</h3> 
<p>有时会极大的提升程序的性能。</p> 
<h3><a id="_139"></a>缺点</h3> 
<p>相对增加了系统的复杂性。</p> 
<h2><a id="_142"></a>总结</h2> 
<p>设计模式值得你可以练习！</p> 
<p>最后，如果你从本文中有所收获，可否点赞转发支持一下博主，你小小的鼓励，是激发博主持续写作的动力…</p> 
<p><strong>GitHub源码地址</strong>：<a href="https://github.com/shusheng007/design-patterns">design-patterns</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8bb009a1a3b73fca14c1ef9c31c17946/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue事件总线实例（全局事件）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f764bd31058a1c5be727bc26e7a915c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux 搜狗输入法显示繁体字,搜狗输入法繁体字切换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>