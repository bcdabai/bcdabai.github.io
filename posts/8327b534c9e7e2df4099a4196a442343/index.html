<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>postman｜接口测试 ｜ pre-request script 场景应用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="postman｜接口测试 ｜ pre-request script 场景应用" />
<meta property="og:description" content="pre-request script 介绍 在过往的工作中，遇到很多测试小伙伴使用 postman 的时候都是直接通过 api 文档的描述请求，检查返回的数据是否正常，很少会用到 pre-request Script 这个功能，甚至也有不少开发的小伙伴也是很少用到这个功能。这个功能类似于 python unittest 里面的 setup 或者是 pytest 里面的 conftest 文件，在执行测试前先执行的函数。
pre-request script 应用 pre-request script 是 postman 执行前的前置条件功能。它能够做到 request 请求前的工作。包括：
对登录验证进行加密或解密
切换环境变量
获取上一个接口的响应值并进行更新
以上都是可以在 pre-request script 功能做的。
postman 执行顺序 首先来讲一下，postman 的执行顺序，其实这个只看一张图就够了。
从 postman 的介绍中，可以知道 postman 执行的顺序会先去到 pre-request script 检查是否有需要执行的前置条件。
pre-request script 场景实践 场景一 : 登录验证加密 现在有一个我们项目中，登录接口是通过 user token 登录的。前端页面需要填写 username 以及 password，再通过 js 进行 MD5 加密处理，最后请求接口验证返回登录状态。
api : /api/login method : post headers : token: user_token Content-Type: application/json 生成 user_token 方式： username&amp;psaaword 大写" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8327b534c9e7e2df4099a4196a442343/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-20T19:08:30+08:00" />
<meta property="article:modified_time" content="2023-06-20T19:08:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">postman｜接口测试 ｜ pre-request script 场景应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="427" src="https://images2.imgbox.com/af/d2/dzUp7PWv_o.png" width="857"></p> 
<h5></h5> 
<h5>pre-request script 介绍</h5> 
<p>在过往的工作中，遇到很多测试小伙伴使用 postman 的时候都是直接通过 api 文档的描述请求，检查返回的数据是否正常，很少会用到 pre-request Script 这个功能，甚至也有不少开发的小伙伴也是很少用到这个功能。这个功能类似于 python unittest 里面的 setup 或者是 pytest 里面的 conftest 文件，在执行测试前先执行的函数。</p> 
<h6>pre-request script 应用</h6> 
<p>pre-request script 是 postman 执行前的前置条件功能。它能够做到 request 请求前的工作。包括：</p> 
<p>对登录验证进行加密或解密<br> 切换环境变量<br> 获取上一个接口的响应值并进行更新</p> 
<p>以上都是可以在 pre-request script 功能做的。</p> 
<h6>postman 执行顺序</h6> 
<p>首先来讲一下，postman 的执行顺序，其实这个只看一张图就够了。<br>  </p> 
<p><img alt="" height="165" src="https://images2.imgbox.com/3a/c0/ZqrWNHiL_o.png" width="847"></p> 
<p> </p> 
<p>从 postman 的介绍中，可以知道 postman 执行的顺序会先去到 pre-request script 检查是否有需要执行的前置条件。</p> 
<h4>pre-request script 场景实践</h4> 
<h3><br> 场景一 : 登录验证加密</h3> 
<p>现在有一个我们项目中，登录接口是通过 user token 登录的。前端页面需要填写 username 以及 password，再通过 js 进行 MD5 加密处理，最后请求接口验证返回登录状态。</p> 
<pre><code class="hljs">api : /api/login
method : post
headers : 
    token: user_token
    Content-Type: application/json
</code></pre> 
<p>生成 user_token 方式： username&amp;psaaword 大写</p> 
<p>上面就是接口文档说明的，要通过 md5 方式对 username&amp;password 进行加密。那么在 pre-request script 里面，我们可以这样做。</p> 
<p><img alt="" height="119" src="https://images2.imgbox.com/03/27/6v1pY4Rr_o.png" width="828"></p> 
<p> <img alt="" height="230" src="https://images2.imgbox.com/32/89/C0u4tGq1_o.png" width="855"></p> 
<p> </p> 
<p>点开环境变量会看到已经生成了 user_token 对应的加密 token 了。</p> 
<h3></h3> 
<h3>场景二 : 切换环境变量</h3> 
<p>可能对应这个场景比较少人会用上，但是不得不说，这个场景确实有用。</p> 
<p>平时我们切换测试或者产线环境的时候，都是命名不同的环境名称，然后将对应环境的 HOST 填写到环境变量里面去。经常我们会命名这样的：TEST_HOST,PROD_HOST 这样的方式，当我们切换环境的时候，在 request 中改 HOST 即可。</p> 
<p>如果我们可以在请求前，可以自动切换不同的 HOST 就更好。</p> 
<p>我们可以这样做，首先在 collection 中定义不同环境的 HOST。<br><img alt="" height="296" src="https://images2.imgbox.com/91/3f/byYVKrXV_o.png" width="869"></p> 
<p> 其次，我们在 pre-request script 中定义我们的函数</p> 
<pre><code class="hljs">let varbs = new Set()
pm.collectionVariables.values.each(v =&gt; {
    varbs.add(v.key.toUpperCase())
})

pm.collectionVariables.values.each(v =&gt; {
    let envVarbKey = [pm.environment.name, v.key].join("_").toUpperCase()
    if (varbs.has(envVarbKey)) {
        pm.collectionVariables.set(v.key, pm.collectionVariables.get(envVarbKey))
    }
});
</code></pre> 
<p></p> 
<p>这里面的意思，就是根据环境名去 variables 中寻找我们对应的 HOST</p> 
<p>最终，我们只需要在不同环境中维护 api-key 等参数即可。</p> 
<h3></h3> 
<h3>场景三 : 获取另外接口的响应值并进行更新</h3> 
<p>在请求的时候，需要获取到另外一个接口的响应值，并将响应值作为当前 request 的参数。</p> 
<p>在这里，pre-request script 不仅仅能写函数，还能写请求函数。<br>  </p> 
<pre><code class="hljs">// Refresh the OAuth token if necessary
var tokenDate = new Date(2022,9,3);
var tokenTimestamp = pm.environment.get("OAuth_Timestamp");
if(tokenTimestamp){
  tokenDate = Date.parse(tokenTimestamp);
}
var expiresInTime = pm.environment.get("ExpiresInTime");
if(!expiresInTime){
    expiresInTime = 300000; // Set default expiration time to 5 minutes
}

if((new Date() - tokenDate) &gt;= expiresInTime)
{
   pm.sendRequest({
      url:  pm.variables.get("Auth_Url"),
      method: 'POST',
      header: {
        'Accept': 'application/json',
        'Content-Type': 'application/x-www-form-urlencoded',
        'Authorization': pm.variables.get("Basic_Auth")
      }
  }, function (err, res) {
      try{
        pm.environment.set("OAuth_Token", res.json().access_token);
        pm.environment.set("OAuth_Timestamp", new Date());

        // Set the ExpiresInTime variable to the time given in the response if it exists
        if(res.json().expires_in){
            expiresInTime = res.json().expires_in * 1000;
        }
        pm.environment.set("ExpiresInTime", expiresInTime);
      }
      catch(e) {
        console.log('Unable to load access token from response);
      }
  });
}
</code></pre> 
<p>这里面的函数，主要是通过检索 token 是否过期，重新生成 token 的请求方法。比较简单理解。</p> 
<p>1、检查 token 是否过期</p> 
<p>2、如果过期，就生成新的 token</p> 
<p>3、将新的 token 设置到环境变量，然后记录设置的时间</p> 
<h3>总结</h3> 
<p>以上就是这篇文章主要讲的内容，主要是讲解 pre-request script 在工作中的应用场景，希望可以帮助到大家。</p> 
<h3>扩展</h3> 
<p>前面说到的加密方式，有很多种，不仅仅是 MD5 加密，同时还有 RSA，AES，bash64 SHA1 等等。<br> 这几种加密方式有什么不同，在这里简单讲一下：</p> 
<p>Base64 是一种用64个字符来表示任意二进制数据的方法,这种编码规则是公开的，基本只要有程序能力都能解开，所以请勿用作加密用途，它的作用不在于安全性，而在于让内容能在网络间无错的传输。(常用语编码特殊字符，编码小型二进制文件等)</p> 
<p>AES 是对称加密算法，也就是说加密和解密都是采用同一个的密钥。当前最为流行的对称加密算法，这个没有之一。它是如此的常用，以至于很多 CPU 在硬件层面上支持 AES 的加密和解密。AES 是美国政府使用的加密标准，这意味着政府的机密文件大都是用 AES 进行加密的。https 就是使用 AES 来进行数据的加密的，因为 AES 是 TLS 和 SSL 标准的一部分。</p> 
<p>RSA 公开密钥加密（public-keycryptography），也称为非对称加密（asymmetriccryptography），一种密码学算法类型，在这种密码学方法中，需要一对密钥，一个是私人密钥，另一个则是公开密钥。这两个密钥是数学相关，用某用户公钥加密后所得的信息，只能用该用户的解密的私钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。这种通常我们在 github 上会用到。</p> 
<p>MD5、SHA1 都是不可逆的，防篡改的，用来校验数据真伪的，不是用来加密数据的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/02b6c0e7d9a2db9db55848fe281a1890/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">02、自动化运维工具有很多种，下面介绍几种比较流行的、并且有代表性的工具，和它们之间的对比</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a68ada8a7021619b2c08d1d2cb3a312b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">文本匹配模型实验报告-text2vec</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>