<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;面试问题---Const - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;面试问题---Const" />
<meta property="og:description" content="1.const 1.1 作用 修饰变量，说明该变量不可以被改变；修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；修饰成员函数，说明该成员函数内不能修改成员变量。 1.2 const 的指针与引用 指针指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer）引用指向常量的引用（reference to const） 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰 1.3使用 // 类 class A { private: const int a; // 常对象成员，可以使用初始化列表或者类内初始化 public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象 A b; // 普通对象，可以调用全部成员函数 const A a; // 常对象，只能调用常成员函数 const A *p = &amp;a; // 指针变量，指向常对象 const A &amp;q = a; // 指向常对象的引用 // 指针 char greeting[] = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f4e051653ea26a209c74a367c5fb9852/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T11:38:53+08:00" />
<meta property="article:modified_time" content="2024-01-12T11:38:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;面试问题---Const</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div></div> 
<div> 
 <div> 
  <h3 style="margin-left:0pt;text-align:left;"><strong><span style="color:#1a1a1a;">1.</span></strong><strong><span style="color:#1a1a1a;">const</span></strong></h3> 
  <h4 style="margin-left:0pt;text-align:left;"><strong><span style="color:#1a1a1a;">1.1 作用</span></strong></h4> 
  <ul><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#24292f;">修饰变量，说明该变量不可以被改变；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#24292f;">修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#24292f;">修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#24292f;">修饰成员函数，说明该成员函数内不能修改成员变量。</span></span></li></ul> 
  <h4 style="margin-left:0pt;text-align:left;"><strong><span style="color:#1a1a1a;">1.2 const 的指针与引用</span></strong></h4> 
  <ul><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#24292f;">指针指向常量的指针（pointer to const）</span></span> 
    <ul><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#24292f;">自身是常量的指针（常量指针，const pointer）</span></span></li></ul></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#24292f;">引用指向常量的引用（reference to const）</span></span> 
    <ul><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#24292f;">没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</span></span></li></ul></li></ul> 
 </div> 
</div> 
<h4>1.3使用</h4> 
<pre><code class="hljs">// 类
class A
{
private:
    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化

public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function()
{
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &amp;a;            // 指针变量，指向常对象
    const A &amp;q = a;             // 指向常对象的引用
    
    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常量
void function4(const int&amp; Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
</code></pre> 
<div></div> 
<div> 
 <div> 
  <h4 style="margin-left:0pt;text-align:left;"><strong><span style="color:#1a1a1a;">1.4 宏定义 #define 和 const 常量</span></strong></h4> 
  <div> 
   <div> 
    <table border="1" cellspacing="0"><tbody><tr><td colspan="1" rowspan="1" style="background-color:#99ddff;vertical-align:middle;width:308px;"> <p style="margin-left:0;text-align:center;"><strong><span style="color:#24292f;">宏定义 #define</span></strong></p> </td><td colspan="1" rowspan="1" style="background-color:#99ddff;vertical-align:middle;width:289px;"> <p style="margin-left:0;text-align:center;"><strong><span style="color:#24292f;">const 常量</span></strong></p> </td></tr><tr><td colspan="1" rowspan="1" style="background-color:#ffffff;vertical-align:middle;width:308px;"> <p style="margin-left:0;text-align:center;"><span style="color:#24292f;">宏定义，相当于字符替换</span></p> </td><td colspan="1" rowspan="1" style="background-color:#ffffff;vertical-align:middle;width:289px;"> <p style="margin-left:0;text-align:center;"><span style="color:#24292f;">常量声明</span></p> </td></tr><tr><td colspan="1" rowspan="1" style="background-color:#d8d8d8;vertical-align:middle;width:308px;"> <p style="margin-left:0;text-align:center;"><span style="color:#24292f;">预处理器处理</span></p> </td><td colspan="1" rowspan="1" style="background-color:#d8d8d8;vertical-align:middle;width:289px;"> <p style="margin-left:0;text-align:center;"><span style="color:#24292f;">编译器处理</span></p> </td></tr><tr><td colspan="1" rowspan="1" style="background-color:#ffffff;vertical-align:middle;width:308px;"> <p style="margin-left:0;text-align:center;"><span style="color:#24292f;">无类型安全检查</span></p> </td><td colspan="1" rowspan="1" style="background-color:#ffffff;vertical-align:middle;width:289px;"> <p style="margin-left:0;text-align:center;"><span style="color:#24292f;">有类型安全检查</span></p> </td></tr><tr><td colspan="1" rowspan="1" style="background-color:#d8d8d8;vertical-align:middle;width:308px;"> <p style="margin-left:0;text-align:center;"><span style="color:#24292f;">不分配内存</span></p> </td><td colspan="1" rowspan="1" style="background-color:#d8d8d8;vertical-align:middle;width:289px;"> <p style="margin-left:0;text-align:center;"><span style="color:#24292f;">要分配内存</span></p> </td></tr><tr><td colspan="1" rowspan="1" style="background-color:#ffffff;vertical-align:middle;width:308px;"> <p style="margin-left:0;text-align:center;"><span style="color:#24292f;">存储在代码段</span></p> </td><td colspan="1" rowspan="1" style="background-color:#ffffff;vertical-align:middle;width:289px;"> <p style="margin-left:0;text-align:center;"><span style="color:#24292f;">存储在数据段</span></p> </td></tr><tr><td colspan="1" rowspan="1" style="background-color:#d8d8d8;vertical-align:middle;width:308px;"> <p style="margin-left:0;text-align:center;"><span style="color:#24292f;">可通过 </span><span style="color:#24292f;">#undef</span><span style="color:#24292f;"> 取消</span></p> </td><td colspan="1" rowspan="1" style="background-color:#d8d8d8;vertical-align:middle;width:289px;"> <p style="margin-left:0;text-align:center;"><span style="color:#24292f;">不可取消</span></p> </td></tr></tbody></table> 
   </div> 
  </div> 
 </div> 
</div> 
<p> </p> 
<h4> </h4>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d482ff99cbacc40f22714c84337f07f2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">error LNK2001: unresolved external symbol memset</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/76684760aa1074ab054bbbdc85ab0692/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux系统操作——禁ping</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>