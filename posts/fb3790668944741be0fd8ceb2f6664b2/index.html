<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Rabbitmq消息的有序性、消息不丢失、不被重复消费 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Rabbitmq消息的有序性、消息不丢失、不被重复消费" />
<meta property="og:description" content="如何保证消息的顺序性 如图所示，RabbitMQ保证消息的顺序性，就是拆分多个 queue，每个 queue 对应一个 consumer（消费者），就是多一些 queue 而已，确实是麻烦点；
或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。
如何保证消息不丢失？ 1，生产者发送消息至MQ的数据丢失 解决方法:在生产者端开启comfirm 确认模式，你每次写的消息都会分配一个唯一的 id，
然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 ack 消息，告诉你说这个消息 ok 了
Channel channel = connection.createChannel(); channel.confirmSelect(); // 开启confirm模式 2，MQ收到消息，暂存内存中，还没消费，自己挂掉，数据会都丢失 解决方式：MQ设置为持久化。将内存数据持久化到磁盘中。
rabbitmq的持久化分为队列持久化、消息持久化和交换器持久化。一般三个都要设置持久化
3，消费者刚拿到消息，还没处理，挂掉了，MQ又以为消费者处理完 解决方式：用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以手动ack,可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。
如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。
如何保证消息不被重复消费? （幂等性） 方式1: 消息全局 ID 或者写个唯一标识(如时间戳、UUID 等) ：每次消费消息之前根据消息 id 去判断该消息是否已消费过，如果已经消费过，则不处理这条消息，否则正常消费消息，并且进行入库操作。(消息全局 ID 作为数据库表的主键，防止重复)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fb3790668944741be0fd8ceb2f6664b2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-13T18:35:59+08:00" />
<meta property="article:modified_time" content="2023-02-13T18:35:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Rabbitmq消息的有序性、消息不丢失、不被重复消费</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="">如何保证消息的顺序性</h2> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:923px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:26.977247%;height:0;"> 
    <img src="https://images2.imgbox.com/61/3f/0HeUlYYU_o.png" style="margin-left:;display:block;width:923px;margin-top:-26.977247%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1006px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:23.260437%;height:0;"> 
    <img src="https://images2.imgbox.com/29/2d/LwhCpsuy_o.png" style="margin-left:;display:block;width:1006px;margin-top:-23.260437%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">如图所示，RabbitMQ保证消息的顺序性，就是拆分多个 queue，每个 queue 对应一个 consumer（消费者），就是多一些 queue 而已，确实是麻烦点；</p> 
 <p style="">或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:963px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:34.787125%;height:0;"> 
    <img src="https://images2.imgbox.com/85/8d/kJO3nxpP_o.png" style="margin-left:;display:block;width:963px;margin-top:-34.787125%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:855px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:29.122807%;height:0;"> 
    <img src="https://images2.imgbox.com/74/a4/uRKniQEv_o.png" style="margin-left:;display:block;width:855px;margin-top:-29.122807%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:975px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.102562%;height:0;"> 
    <img src="https://images2.imgbox.com/e1/3d/yZjOW8w6_o.png" style="margin-left:;display:block;width:975px;margin-top:-52.102562%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:962px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:39.812893%;height:0;"> 
    <img src="https://images2.imgbox.com/fe/64/MlSlMJCE_o.png" style="margin-left:;display:block;width:962px;margin-top:-39.812893%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h2 style="">如何保证消息不丢失？</h2> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:609px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:44.49918%;height:0;"> 
    <img src="https://images2.imgbox.com/de/b9/CUcVlKPU_o.png" style="margin-left:;display:block;width:609px;margin-top:-44.49918%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h6 style="">1，生产者发送消息至MQ的数据丢失</h6> 
 <p style="">解决方法:在生产者端开启comfirm 确认模式，你每次写的消息都会分配一个唯一的 id，</p> 
 <p style="">然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 ack 消息，告诉你说这个消息 ok 了</p> 
 <pre class="kdocs-java"><code class="language-java">Channel channel = connection.createChannel();
channel.confirmSelect();      // 开启confirm模式</code></pre> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:749px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:21.76235%;height:0;"> 
    <img src="https://images2.imgbox.com/34/9d/RASlHvX1_o.png" style="margin-left:;display:block;width:749px;margin-top:-21.76235%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h6 style="">2，MQ收到消息，暂存内存中，还没消费，自己挂掉，数据会都丢失</h6> 
 <p style="">解决方式：MQ设置为持久化。将内存数据持久化到磁盘中。</p> 
 <p style="">rabbitmq的持久化分为<a class="kdocs-link" style="color:#0A6CFF;" href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">队列</a>持久化、消息持久化和交换器持久化。一般三个都要设置持久化</p> 
 <p style=""></p> 
 <h6 style="">3，消费者刚拿到消息，还没处理，挂掉了，MQ又以为消费者处理完</h6> 
 <p style="">解决方式：用 RabbitMQ 提供的 ack 机制，简单来说，就是你<span class="kdocs-color" style="background-color:#FBF5B3;">必须关闭</span> RabbitMQ 的自动 ack，<span class="kdocs-bold" style="font-weight:bold;">可以手动ack</span>,可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p> 
 <p style="">如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p> 
 <p style=""></p> 
 <h2 style="">如何保证消息不被重复消费? （幂等性）</h2> 
 <p style="">方式1: 消息全局 ID 或者写个唯一标识(如时间戳、UUID 等) ：每次消费消息之前根据消息 id 去判断该消息是否已消费过，如果已经消费过，则不处理这条消息，否则正常消费消息，并且进行入库操作。(消息全局 ID 作为数据库表的主键，防止重复)</p> 
 <p style="">方式2: 利用 Redis 的 setnx 命令：给消息分配一个全局 ID，消费该消息时，先去 Redis 中查询有没消费记录，无则以键值对形式写入 Redis ，有则不消费该消息。</p> 
 <p style=""></p> 
 <h2 style="">死信队列</h2> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:949px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:49.84194%;height:0;"> 
    <img src="https://images2.imgbox.com/ac/9d/ZL1jkSB6_o.png" style="margin-left:;display:block;width:949px;margin-top:-49.84194%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">生产者生产一条1分钟后超时的订单信息到正常交换机exchange-a中，消息匹配到队列queue-a，但一分钟后仍未消费。</p> 
 <p style="">消息会被投递到死信交换机dlx-exchange中，并发送到私信队列中。</p> 
 <p style="">死信队列dlx-queue的消费者拿到信息后，根据消息去查询订单的状态，如果仍然是未支付状态，将订单状态更新为超时状态。</p> 
 <p style=""></p> 
 <h2 style="">如何处理消息堆积情况?</h2> 
 <p style="">场景题：几千万条数据在MQ里积压了七八个小时。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">1、出现该问题的原因：</span></p> 
 <p style="">消息堆积往往是生产者的生产速度与消费者的消费速度不匹配导致的。有可能就是消费者消费能力弱，渐渐地消息就积压了，也有可能是因为消息消费失败反复复重试造成的，也有可能是消费端出了问题，导致不消费了或者消费极其慢。比如，消费端每次消费之后要写mysql，结果mysql挂了，消费端hang住了不动了，或者消费者本地依赖的一个东西挂了，导致消费者挂了。</p> 
 <p style="">所以如果是 bug 则处理 bug；如果是因为本身消费能力较弱，则优化消费逻辑，比如优化前是一条一条消息消费处理的，那么就可以批量处理进行优化。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">2、临时扩容，快速处理积压的消息：</span></p> 
 <p style="">（1）先修复 consumer 的问题，确保其恢复消费速度，然后将现有的 consumer 都停掉；</p> 
 <p style="">（2）临时创建原先 N 倍数量的 queue ，然后写一个临时分发数据的消费者程序，将该程序部署上去消费队列中积压的数据，消费之后不做任何耗时处理，直接均匀轮询写入临时建立好的 N 倍数量的 queue 中；</p> 
 <p style="">（3）接着，临时征用 N 倍的机器来部署 consumer，每个 consumer 消费一个临时 queue 的数据</p> 
 <p style="">（4）等快速消费完积压数据之后，恢复原先部署架构 ，重新用原先的 consumer 机器消费消息。</p> 
 <p style="">这种做法相当于临时将 queue 资源和 consumer 资源扩大 N 倍，以正常 N 倍速度消费。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">4、MQ长时间未处理导致MQ写满的情况如何处理：</span></p> 
 <p style="">如果消息积压在MQ里，并且长时间都没处理掉，导致MQ都快写满了，这种情况肯定是临时扩容方案执行太慢，这种时候只好采用 “丢弃+批量重导” 的方式来解决了。首先，临时写个程序，连接到mq里面消费数据，消费一个丢弃一个，快速消费掉积压的消息，降低MQ的压力，然后在流量低峰期时去手动查询重导丢失的这部分数据</p> 
 <p style="">5 短时间内无法扩容或者扩容无法完全解决问题的话：</p> 
 <p style="">可以尝试降低一些非核心业务的消息处理,其次可以通过监控排查,优化消费者端的业务代码或者查看是否存在一些消息被重复消息的情况。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58a3131651b4c6da4f3db4094731b09f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue原理解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e2f75027259043dacbefc8c1a312cfa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用C语言编写程序：已知a，b，c都是1位整数，求当三位整数abc、cba的和为1333时a、b、c的值。给出代码并给出解释且针对代码作出注释...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>