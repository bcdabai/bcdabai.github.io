<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android build.gradle文件 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android build.gradle文件" />
<meta property="og:description" content="一、ABI（Application Binary Interface）应用程序二进制接口 其实ABI可以不设置，这样编译时，就会将项目里所有依赖资源包里的so库都打到最终的apk里。 但是，ABI支持多的话，apk也会大，所以一般只支持一种即可。 目前Android 版本，ABI一般配置armeabi-v7a.
注意：
新增so库 新增so库的话，需要在每个在用的文件夹内（armeabi、armeabi-v7a、arm64-v8a ==）放置，否则so库找不到。多个目录，目录下的so库文件数需要相同。 armeabi-v7a 和 armeabi 如果设置支持armeabi-v7a 和 armeabi：如若第三方提供的so只有armeabi，那么armeabi-v7a 内也需要拷贝一份，原因是armeabi-v7a 和 armeabi必须so数一致，且armeabi-v7a支持armeabi hardware does not support ABI设置错误，可能出现硬件不支持的问题，提示：hardware does not support
二、splits 的属性 1、abi 类型：AbiSplitOptions描述：对 abi 进行分包处理，具体我们看下面 AbiSplitOptions 讲解。 2、AbiSplitOptions 类型 2.1 enable 描述：是否开启 abi 分包，默认不开启使用： splits {
abi {
enable true
}
}
效果图如下：
2.2 exclude
描述：排除不需要的架构。
使用： abi {
// 是否开启
enable true
// 排除不必要的架构
exclude &#39;x86&#39;,&#39;arm64-v8a&#39;
}
效果图：
2.3 reset" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6107e641ef6284ff5528ff2a4c1bc6b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-21T17:51:29+08:00" />
<meta property="article:modified_time" content="2023-06-21T17:51:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android build.gradle文件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong><span style="color:#0d0016;">一、ABI（Application Binary Interface）应用程序二进制接口</span></strong></h3> 
<p><span style="color:#0d0016;">     其实ABI可以不设置，这样编译时，就会将项目里所有依赖资源包里的so库都打到最终的apk里。 但是，ABI支持多的话，apk也会大，所以一般只支持一种即可。 目前Android 版本，ABI一般配置<code>armeabi-v7a.</code></span></p> 
<p><span style="color:#0d0016;"><code>注意：</code></span></p> 
<p><span style="color:#0d0016;"><code><strong>新增so库</strong> </code></span></p> 
<p><span style="color:#0d0016;"><code>新增so库的话，需要在每个在用的文件夹内（armeabi、armeabi-v7a、arm64-v8a ==）放置，否则so库找不到。多个目录，目录下的so库文件数需要相同。 </code></span></p> 
<p><span style="color:#0d0016;"><code><strong>armeabi-v7a 和 armeabi</strong> </code></span></p> 
<p><span style="color:#0d0016;"><code>如果设置支持armeabi-v7a 和 armeabi：如若第三方提供的so只有armeabi，那么armeabi-v7a 内也需要拷贝一份，原因是armeabi-v7a 和 armeabi必须so数一致，且armeabi-v7a支持armeabi <strong>hardware does not support</strong> </code></span></p> 
<p><span style="color:#0d0016;"><code>ABI设置错误，可能出现硬件不支持的问题，提示：hardware does not support</code></span></p> 
<h3><strong>二、splits 的属性</strong></h3> 
<h4>1、abi</h4> 
<ul><li>类型：AbiSplitOptions</li><li>描述：对 abi 进行分包处理，具体我们看下面 AbiSplitOptions 讲解。</li></ul> 
<h4><a name="t6"></a><a id="2AbiSplitOptions__22"></a>2、AbiSplitOptions 类型</h4> 
<h5><a name="t7"></a><a id="21_enable_23"></a>2.1 enable</h5> 
<ul><li>描述：是否开启 abi 分包，默认不开启</li><li>使用：</li></ul> 
<p>splits {<!-- --><br>     abi {<!-- --><br>         enable true<br>     }<br> }<br> 效果图如下：</p> 
<p><img alt="在这里插入图片描述" height="208" src="https://images2.imgbox.com/aa/a3/r0fO9Ylj_o.png" width="310"></p> 
<h5><strong>2.2 exclude</strong><br> 描述：排除不需要的架构。<br> 使用：</h5> 
<p>abi {<!-- --><br>     // 是否开启<br>     enable true</p> 
<p>    // 排除不必要的架构<br>     exclude 'x86','arm64-v8a'<br> }<br><br> 效果图：</p> 
<p><img alt="在这里插入图片描述" height="174" src="https://images2.imgbox.com/8b/3c/Snq9vN1V_o.png" width="293"><br><strong>2.3 reset</strong><br> 描述：清除默认架构列表。当我们开启abi 分包时，gradle会帮我们初始化一个架构列表，例如 enable 小节中，我们并没有设置任何架构，而gradle会帮我们分出 “arm64-v8a”、“armeabi-v7a”、“x86”、“x86_64”。<br> 初始化列表会因为gradle的版本不同有所改变</p> 
<p>使用：</p> 
<p>abi {<!-- --><br>     // 是否开启<br>     enable true</p> 
<h5>    // 重置包含的目录<br>     reset()<br> }<br> 2.4 include<br> 描述：设置我们需要的架构。注意的是，我们需要先使用reset方法将默认列表清空，然后再设置。</h5> 
<p>使用：</p> 
<p>abi {<!-- --><br>     // 是否开启<br>     enable true</p> 
<p>    // 重置包含的目录，因为已经是包含全部<br>     reset()<br>     // 设置包含，调用前需要先用 reset 将默认清除<br>     include 'armeabi-v7a', 'x86'<br> }<br> 效果图：</p> 
<h5><img alt="在这里插入图片描述" height="150" src="https://images2.imgbox.com/57/ea/iIShhUTO_o.png" width="256"><br><strong>2.5 universalApk</strong><br> 描述：是否编译一个包含全部架构的apk。<br> 使用：</h5> 
<p>abi {<!-- --><br>     // 是否开启<br>     enable true</p> 
<p>    // 是否打出包含全部的apk<br>     universalApk true<br> }<br> 效果图：</p> 
<h4><img alt="在这里插入图片描述" height="210" src="https://images2.imgbox.com/6b/85/D4bCaJn2_o.png" width="540"></h4> 
<h3>三、sourceSets属性——文件路径配置</h3> 
<p> sourceSets {<!-- --><br>       main {<!-- --><br>            manifest.srcFile 'AndroidManifest.xml' // 指定清单文件<br>            <strong>res.srcDirs = ['res'] // 指定res资源目录</strong><br>            assets.srcDirs = ['assets']    // asset资源目录<br>            jni.srcDirs 'src/main/jni'     // jni代码目录<br>           <strong> jniLibs.srcDir 'src/main/jniLibs' // jni库目录</strong><br>          <strong>  java.srcDirs = ['src'] // 指定java源代码目录</strong><br>            resources.srcDirs = ['src'] // 指定resource目录<br>            aidl.srcDirs = ['src'] // 指定aidl目录<br>            renderscript.srcDirs = ['src'] // 指定source目录<br>         }<br>      debug.setRoot('build-types/debug') // 指定debug模式的路径<br>      release.setRoot('build-types/release') // 指定release模式的路径</p> 
<p>}</p> 
<p><strong>四、packagingOptions属性——打包配置</strong></p> 
<p>    打包配置：<br>     1、pickFirsts:当出现重复文件，会使用第一个匹配的文件打包进入apk<br>     2、merges:当出现重复文件，合并重复的文件打入apk<br>     3、excludes:打包的时候排除匹配的文件<br>     packagingOptions {<!-- --><br>             pickFirsts = ['META-INF/LICENSE']<br>             //这里不要直接=赋值，避免覆盖掉默认值<br>             merge 'META-INF/LICENSE'<br>             //这里不要直接=赋值，避免覆盖掉默认值<br>             exclude 'META-INF/LICENSE'<br>         }</p> 
<h3>五、compileOptions属性——Java 的版本配置</h3> 
<p>compileOptions {<!-- --></p> 
<p>// 在这里你可以进行 Java 的版本配置，</p> 
<p>// 以便使用对应版本的一些新特性</p> 
<p> }</p> 
<h3>六、flavorDimensions属性—— 多维度理解(版本差异化打包)</h3> 
<p>flavorDimensions 从单词字面理解知道是 “风味维度”</p> 
<p>是需要结合 “产品风味（即productFlavors）” 来一起使用的。</p> 
<p>android {<!-- --><br>     // 省略其他参数<br>     flavorDimensions 'ENV', "DEVICE_TYPE"<br> }</p> 
<p>定义出两个维度：env和 device_type。<strong>一个参数一个维度</strong></p> 
<p><img alt="" height="188" src="https://images2.imgbox.com/3a/86/hDfcbeec_o.png" width="220"></p> 
<p><strong>多维度理解</strong><br> 其实这涉及到了版本差异化打包的内容，如果说3.0以前的版本差异化打包更多的是为了厂商定制的，那么3.0以后的版本差异化打包就是在厂商的基础之上加入了机型，渠道等一些参数，变成了多个维度的产品。</p> 
<p>也就是说之前的一个产品只有一个参数进行描述的话，现在就可以为其增加多个参数进行配置，比如A厂商的A渠道的A机型、A厂商的B渠道的C机型等，维度越多，产品的样式越发丰富。</p> 
<p> </p> 
<p>好了，理论说完，接下来就是进行通俗易懂的一些示例了，只有实践才能让自己检验到真理。</p> 
<p>新建项目，然后在app/build.gradle文件里配置两个风味维度（“company”，“channel”），如下：</p> 
<p>defaultConfig {<!-- --><br>         applicationId "com.voctex.flavorsapp"<br>         minSdkVersion 18<br>         targetSdkVersion 27<br>         versionCode 1<br>         versionName "1.0"<br>         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"<br>  <br>         flavorDimensions "company","channel"<br>     }</p> 
<p>然后进行产品的多维度配置：</p> 
<p>productFlavors{<!-- --><br>         //随便命名，建议根据该维度的具体信息进行命名<br>         companyA{<!-- --><br>             dimension "company"<br>         }<br>         companyB{<!-- --><br>             dimension "company"<br>         }<br>         channelA{<!-- --><br>             dimension "channel"<br>         }<br>         channelB{<!-- --><br>             dimension "channel"<br>         }<br>     }</p> 
<p>配置完之后,sync构建一下项目。</p> 
<p>打包构建之后就会出现多个维度的产品，对应如下，如图： </p> 
<p><img alt="" height="352" src="https://images2.imgbox.com/80/37/gK9oN7jw_o.png" width="383"></p> 
<p>可以理解为总共有两个维度，公司（company）和渠道（channel），这里公司的维度排前面（排序先后有要求，下面会讲到），所以所有的产品就是，A公司的A渠道产品，A公司的B渠道产品，B公司的A渠道产品，B公司的B渠道产品。<br> 可见，增加维度之后，版本差异化的内容就更为丰富了。</p> 
<p>上面说了，维度的定义先后是有要求的，不可随便，下面为了验证这个说法进行了一项测试，我们在productFlavors里给每一个特点产品定义一个常量，常量的值就是该特点产品的名字。如下：</p> 
<p> productFlavors{<!-- --><br>         companyA{<!-- --><br>             dimension "company"<br>             buildConfigField "String","FLAVOR_NAME","\"companyA\""<br>         }<br>         companyB{<!-- --><br>             dimension "company"<br>             buildConfigField "String","FLAVOR_NAME","\"companyB\""<br>         }<br>         channelA{<!-- --><br>             dimension "channel"<br>             buildConfigField "String","FLAVOR_NAME","\"channelA\""<br>         }<br>         channelB{<!-- --><br>             dimension "channel"<br>             buildConfigField "String","FLAVOR_NAME","\"channelB\""<br>         }<br>     }</p> 
<p>这里有个要注意的点就是在BuildConfig定义String的常量时，需要把双引号也加进去。</p> 
<p>然后进行跟刚才一样的构建，对比几个风味维度的BuildConfig文件里的这个FLAVOR_NAME常量，会发现总是显示第一维度company的值，而第二维度channel的值并不存在，所以当产生多维度的产品时，定义的一些常量总是以第一维度的配置为准。结果如下：</p> 
<p>BuildConfig.java　文件生成后会在app/build/generated/source/buildConfig/companyAChannelA/release/com/voctex/flavorsapp/BuildConfig.java</p> 
<p><img alt="" height="195" src="https://images2.imgbox.com/70/5f/4Jwssqxa_o.png" width="493"></p> 
<p><img alt="" height="201" src="https://images2.imgbox.com/de/3b/x90rAN4A_o.png" width="494"></p> 
<p> <img alt="" height="203" src="https://images2.imgbox.com/61/94/ZLNOAbw9_o.png" width="490"></p> 
<p> <img alt="" height="199" src="https://images2.imgbox.com/6b/c6/dncl3Qyj_o.png" width="489"></p> 
<p> 实验证明，当你在各个维度各自定义了同一个常量的值，总是以第一维度的为准，只有第一维度的定义或者说是修改才是有效的。</p> 
<p> </p> 
<h3>七、productFlavors属性——不同渠道发布配置</h3> 
<p>productFlavors 从字面了解是“产品风味”。他需要和一个风味维度对接，否则会报错。</p> 
<p>接着我们上面的例子，使用 productFlavors 定义维度上的风味，使用 <code>dimension</code> 关联。</p> 
<p>productFlavors {<!-- --><br>          // 在这里你可以设置你的产品发布的一些东西，<br>          // 比如你现在一共软件需要发布到不同渠道，<br>          // 且不同渠道中的包名不同，那么可以在此进行配置；<br>          // 甚至可以设置不同的 AndroidManifest.xml 文件。<br>          hebbe {<!-- --><br>          }<br>          googlePlay {<!-- --><br>          }<br>          solo {<!-- --></p> 
<p>            // applicationId 应用的包名，会覆盖 defaultConfig 中的 applicationId<br>             // applicationId 会替换 AndroidManifest.xml 中的 manifest 标签下 package 的 value<br>             applicationId "com.zinc.power"<br>             // 会追加在 applicationId 字符串的后面，形成最终的包名。<br>             applicationIdSuffix '.debug'<br>             // 风味的维度，指定我们当前风味所所属的维度<br>             dimension 'version'<br>             配置差异化的 logo 和 app名字<br>             manifestPlaceholders = [<br>                     logo    : "@drawable/logo_bear",<br>                     appName : "bear",<br>             ]<br>             // 配置签名<br>             signingConfig signingConfigs.xiaopenyou</p> 
<p>         }<br>     }</p> 
<p><br><strong>七、dependencies属性——项目依赖关系配置</strong></p> 
<p><br>  // 指定当前项目的所有依赖关系：本地依赖、库依赖、远程依赖<br>  // 本地依赖：可以对本地 Jar 包或目录添加依赖关系<br>  // 库依赖：可以对项目中的库模块添加依赖关系<br>  // 远程依赖：可以对 jcenter 库上的开源项目添加依赖<br>  // 标准的远程依赖格式是 域名:组织名:版本号<br>  dependencies {<!-- --><br>      implementation fileTree(dir: 'libs', include: ['*.jar']) // 本地依赖<br>      // 远程依赖，com.android.support是域名部分，appcompat-v7是组名称，26.1.0是版本号<br>      implementation 'com.android.support:appcompat-v7:26.1.0'<br>      implementation 'com.android.support.constraint:constraint-layout:1.0.2'<br>      implementation project(':hello') // 库依赖<br>      testImplementation 'junit:junit:4.12' // 声明测试用列库<br>      androidTestImplementation 'com.android.support.test:runner:1.0.1'<br>      androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'<br>  }<br>  </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p><span style="color:#0d0016;"><code>参考文章：</code></span><a href="https://blog.csdn.net/weixin_35691921/article/details/117442837" title="Android ABI_android_abi_清风徐来辽的博客-CSDN博客">Android ABI_android_abi_清风徐来辽的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/weixin_35691921/article/details/117442837" title="Android ABI_android_abi_清风徐来辽的博客-CSDN博客">Android ABI_android_abi_清风徐来辽的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/LoveFHM/article/details/108373849" title="Android 基础知识总结（一） build.gradle文件_build.gradle sourcesets_&amp;岁月不待人&amp;的博客-CSDN博客">Android 基础知识总结（一） build.gradle文件_build.gradle sourcesets_&amp;岁月不待人&amp;的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/weixin_50386489/article/details/127105419" title="Android 打包 flavorDimensions和productFlavors_flavordimensions打包_weixin_50386489的博客-CSDN博客">Android 打包 flavorDimensions和productFlavors_flavordimensions打包_weixin_50386489的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/chuyouyinghe/article/details/124761614?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124761614-blog-127105419.235%5Ev38%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124761614-blog-127105419.235%5Ev38%5Epc_relevant_default_base&amp;utm_relevant_index=2" title="Android Studio3.0 flavorDimensions多维度理解(版本差异化打包)_安卓为什么要多维度打包_锐湃的博客-CSDN博客">Android Studio3.0 flavorDimensions多维度理解(版本差异化打包)_安卓为什么要多维度打包_锐湃的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f34f26133f3774e8949198ecf0cc9c58/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Docker】进入docker下的mysql</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c69a3187822a1aa049abc547908a86da/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">血流动力学与血压(一)--平均动脉压</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>