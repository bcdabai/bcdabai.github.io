<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2——GPIO子系统重要概念 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2——GPIO子系统重要概念" />
<meta property="og:description" content="资料下载 coding无法使用浏览器打开，必须用git工具下载：
git clone https://e.coding.net/weidongshan/linux/doc_and_source_for_drivers.git 视频观看 百问网驱动大全
16.2 GPIO子系统重要概念 16.2.1 引入 要操作GPIO引脚，先把所用引脚配置为GPIO功能，这通过Pinctrl子系统来实现。
然后就可以根据设置引脚方向(输入还是输出)、读值──获得电平状态，写值──输出高低电平。
以前我们通过寄存器来操作GPIO引脚，即使LED驱动程序，对于不同的板子它的代码也完全不同。
当BSP工程师实现了GPIO子系统后，我们就可以：
a. 在设备树里指定GPIO引脚
b. 在驱动代码中：
使用GPIO子系统的标准函数获得GPIO、设置GPIO方向、读取/设置GPIO值。
这样的驱动代码，将是单板无关的。
16.2.2 在设备树中指定引脚 在几乎所有ARM芯片中，GPIO都分为几组，每组中有若干个引脚。所以在使用GPIO子系统之前，就要先确定：它是哪组的？组里的哪一个？
在设备树中，“GPIO组”就是一个GPIO Controller，这通常都由芯片厂家设置好。我们要做的是找到它名字，比如“gpio1”，然后指定要用它里面的哪个引脚，比如&lt;&amp;gpio1 0&gt;。
有代码更直观，下图是一些芯片的GPIO控制器节点，它们一般都是厂家定义好，在xxx.dtsi文件中：
我们暂时只需要关心里面的这2个属性：
gpio-controller; #gpio-cells = &lt;2&gt;; “gpio-controller”表示这个节点是一个GPIO Controller，它下面有很多引脚。
“#gpio-cells = &lt;2&gt;”表示这个控制器下每一个引脚要用2个32位的数(cell)来描述。
为什么要用2个数？其实使用多个cell来描述一个引脚，这是GPIO Controller自己决定的。比如可以用其中一个cell来表示那是哪一个引脚，用另一个cell来表示它是高电平有效还是低电平有效，甚至还可以用更多的cell来示其他特性。
普遍的用法是，用第1个cell来表示哪一个引脚，用第2个cell来表示有效电平：
GPIO_ACTIVE_HIGH ： 高电平有效 GPIO_ACTIVE_LOW : 低电平有效 定义GPIO Controller是芯片厂家的事，我们怎么引用某个引脚呢？在自己的设备节点中使用属性&#34;[-]gpios&#34;，示例如下：
上图中，可以使用gpios属性，也可以使用name-gpios属性。
16.2.3 在驱动代码中调用GPIO子系统 在设备树中指定了GPIO引脚，在驱动代码中如何使用？
也就是GPIO子系统的接口函数是什么？
GPIO子系统有两套接口：基于描述符的(descriptor-based)、老的(legacy)。前者的函数都有前缀“gpiod_”，它使用gpio_desc结构体来表示一个引脚；后者的函数都有前缀“gpio_”，它使用一个整数来表示一个引脚。
要操作一个引脚，首先要get引脚，然后设置方向，读值、写值。
驱动程序中要包含头文件，
#include &lt;linux/gpio/consumer.h&gt; // descriptor-based 或
#include &lt;linux/gpio.h&gt; // legacy 下表列出常用的函数：
descriptor-basedlegacy说明获得GPIOgpiod_getgpio_requestgpiod_get_indexgpiod_get_arraygpio_request_arraydevm_gpiod_getdevm_gpiod_get_indexdevm_gpiod_get_array设置方向gpiod_direction_inputgpio_direction_inputgpiod_direction_outputgpio_direction_output读值、写值gpiod_get_valuegpio_get_valuegpiod_set_valuegpio_set_value释放GPIOgpio_freegpio_freegpiod_putgpio_free_arraygpiod_put_arraydevm_gpiod_putdevm_gpiod_put_array 有前缀“devm_”的含义是“设备资源管理”(Managed Device Resource)，这是一种自动释放资源的机制。它的思想是“资源是属于设备的，设备不存在时资源就可以自动释放”。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/900cac846d47dcc7eddb91c055f2d41a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-26T10:15:45+08:00" />
<meta property="article:modified_time" content="2021-08-26T10:15:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2——GPIO子系统重要概念</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_1"></a>资料下载</h3> 
<p>coding无法使用浏览器打开，必须用git工具下载：</p> 
<pre><code class="prism language-c">git clone https<span class="token operator">:</span><span class="token comment">//e.coding.net/weidongshan/linux/doc_and_source_for_drivers.git</span>
</code></pre> 
<h3><a id="_7"></a>视频观看</h3> 
<p><a href="http://www.100ask.net" rel="nofollow">百问网驱动大全</a></p> 
<h2><a id="162_GPIO_10"></a>16.2 GPIO子系统重要概念</h2> 
<h3><a id="1621%09_11"></a>16.2.1 引入</h3> 
<p>要操作GPIO引脚，先把所用引脚配置为GPIO功能，这通过Pinctrl子系统来实现。<br> 然后就可以根据设置引脚方向(输入还是输出)、读值──获得电平状态，写值──输出高低电平。<br> 以前我们通过寄存器来操作GPIO引脚，即使LED驱动程序，对于不同的板子它的代码也完全不同。<br> 当BSP工程师实现了GPIO子系统后，我们就可以：<br> a. 在设备树里指定GPIO引脚<br> b. 在驱动代码中：<br> 使用GPIO子系统的标准函数获得GPIO、设置GPIO方向、读取/设置GPIO值。<br> 这样的驱动代码，将是单板无关的。</p> 
<h3><a id="1622%09_21"></a>16.2.2 在设备树中指定引脚</h3> 
<p>在几乎所有ARM芯片中，GPIO都分为几组，每组中有若干个引脚。所以在使用GPIO子系统之前，就要先确定：它是哪组的？组里的哪一个？<br> 在设备树中，“GPIO组”就是一个GPIO Controller，这通常都由芯片厂家设置好。我们要做的是找到它名字，比如“gpio1”，然后指定要用它里面的哪个引脚，比如&lt;&amp;gpio1 0&gt;。<br> 有代码更直观，下图是一些芯片的GPIO控制器节点，它们一般都是厂家定义好，在xxx.dtsi文件中：<br> <img src="https://images2.imgbox.com/96/d1/oI0GHNYR_o.png" alt="在这里插入图片描述"><br> 我们暂时只需要关心里面的这2个属性：</p> 
<pre><code>gpio-controller;
#gpio-cells = &lt;2&gt;;
</code></pre> 
<p>“gpio-controller”表示这个节点是一个GPIO Controller，它下面有很多引脚。<br> “#gpio-cells = &lt;2&gt;”表示这个控制器下每一个引脚要用2个32位的数(cell)来描述。<br> 为什么要用2个数？其实使用多个cell来描述一个引脚，这是GPIO Controller自己决定的。比如可以用其中一个cell来表示那是哪一个引脚，用另一个cell来表示它是高电平有效还是低电平有效，甚至还可以用更多的cell来示其他特性。<br> 普遍的用法是，用第1个cell来表示哪一个引脚，用第2个cell来表示有效电平：</p> 
<pre><code>GPIO_ACTIVE_HIGH ： 高电平有效
GPIO_ACTIVE_LOW  :  低电平有效
</code></pre> 
<p>定义GPIO Controller是芯片厂家的事，我们怎么引用某个引脚呢？在自己的设备节点中使用属性"[-]gpios"，示例如下：<br> <img src="https://images2.imgbox.com/4c/3d/62lfP1Cj_o.png" alt="在这里插入图片描述"><br> 上图中，可以使用gpios属性，也可以使用name-gpios属性。</p> 
<h3><a id="1623%09GPIO_43"></a>16.2.3 在驱动代码中调用GPIO子系统</h3> 
<p>在设备树中指定了GPIO引脚，在驱动代码中如何使用？<br> 也就是GPIO子系统的接口函数是什么？<br> GPIO子系统有两套接口：基于描述符的(descriptor-based)、老的(legacy)。前者的函数都有前缀“gpiod_”，它使用gpio_desc结构体来表示一个引脚；后者的函数都有前缀“gpio_”，它使用一个整数来表示一个引脚。</p> 
<p>要操作一个引脚，首先要get引脚，然后设置方向，读值、写值。</p> 
<p>驱动程序中要包含头文件，</p> 
<pre><code>#include &lt;linux/gpio/consumer.h&gt;   // descriptor-based
</code></pre> 
<p>或</p> 
<pre><code>#include &lt;linux/gpio.h&gt;            // legacy
</code></pre> 
<p>下表列出常用的函数：</p> 
<table><thead><tr><th>descriptor-based</th><th>legacy</th><th>说明</th></tr></thead><tbody><tr><td>获得GPIO</td><td></td><td></td></tr><tr><td>gpiod_get</td><td>gpio_request</td><td></td></tr><tr><td>gpiod_get_index</td><td></td><td></td></tr><tr><td>gpiod_get_array</td><td>gpio_request_array</td><td></td></tr><tr><td>devm_gpiod_get</td><td></td><td></td></tr><tr><td>devm_gpiod_get_index</td><td></td><td></td></tr><tr><td>devm_gpiod_get_array</td><td></td><td></td></tr><tr><td>设置方向</td><td></td><td></td></tr><tr><td>gpiod_direction_input</td><td>gpio_direction_input</td><td></td></tr><tr><td>gpiod_direction_output</td><td>gpio_direction_output</td><td></td></tr><tr><td>读值、写值</td><td></td><td></td></tr><tr><td>gpiod_get_value</td><td>gpio_get_value</td><td></td></tr><tr><td>gpiod_set_value</td><td>gpio_set_value</td><td></td></tr><tr><td>释放GPIO</td><td></td><td></td></tr><tr><td>gpio_free</td><td>gpio_free</td><td></td></tr><tr><td>gpiod_put</td><td>gpio_free_array</td><td></td></tr><tr><td>gpiod_put_array</td><td></td><td></td></tr><tr><td>devm_gpiod_put</td><td></td><td></td></tr><tr><td>devm_gpiod_put_array</td><td></td><td></td></tr></tbody></table> 
<p>有前缀“devm_”的含义是“设备资源管理”(Managed Device Resource)，这是一种自动释放资源的机制。它的思想是“资源是属于设备的，设备不存在时资源就可以自动释放”。<br> 比如在Linux开发过程中，先申请了GPIO，再申请内存；如果内存申请失败，那么在返回之前就需要先释放GPIO资源。如果使用devm的相关函数，在内存申请失败时可以直接返回：设备的销毁函数会自动地释放已经申请了的GPIO资源。<br> 建议使用“devm_”版本的相关函数。</p> 
<p>举例，假设备在设备树中有如下节点：</p> 
<pre><code>	foo_device {
		compatible = "acme,foo";
		...
		led-gpios = &lt;&amp;gpio 15 GPIO_ACTIVE_HIGH&gt;, /* red */
			    &lt;&amp;gpio 16 GPIO_ACTIVE_HIGH&gt;, /* green */
			    &lt;&amp;gpio 17 GPIO_ACTIVE_HIGH&gt;; /* blue */

		power-gpios = &lt;&amp;gpio 1 GPIO_ACTIVE_LOW&gt;;
	};
</code></pre> 
<p>那么可以使用下面的函数获得引脚：</p> 
<pre><code>struct gpio_desc *red, *green, *blue, *power;

red = gpiod_get_index(dev, "led", 0, GPIOD_OUT_HIGH);
green = gpiod_get_index(dev, "led", 1, GPIOD_OUT_HIGH);
blue = gpiod_get_index(dev, "led", 2, GPIOD_OUT_HIGH);
power = gpiod_get(dev, "power", GPIOD_OUT_HIGH);
</code></pre> 
<p>要注意的是，gpiod_set_value设置的值是“逻辑值”，不一定等于物理值。<br> 什么意思？<br> <img src="https://images2.imgbox.com/94/fb/ixil2B48_o.png" alt="在这里插入图片描述"></p> 
<p>旧的“gpio_”函数没办法根据设备树信息获得引脚，它需要先知道引脚号。<br> 引脚号怎么确定？<br> 在GPIO子系统中，每注册一个GPIO Controller时会确定它的“base number”，那么这个控制器里的第n号引脚的号码就是：base number + n。<br> 但是如果硬件有变化、设备树有变化，这个base number并不能保证是固定的，应该查看sysfs来确定base number。</p> 
<h3><a id="1624%09sysfs_IMX6ULL_116"></a>16.2.4 sysfs中的访问方法_IMX6ULL</h3> 
<p>在sysfs中访问GPIO，实际上用的就是引脚号，老的方法。<br> a. 先确定某个GPIO Controller的基准引脚号(base number)，再计算出某个引脚的号码。<br> 方法如下：<br> ① 先在开发板的/sys/class/gpio目录下，找到各个gpiochipXXX目录：<br> <img src="https://images2.imgbox.com/11/a1/ZpGJWtuf_o.png" alt="在这里插入图片描述"><br> ② 然后进入某个gpiochip目录，查看文件label的内容<br> ③ 根据label的内容对比设备树<br> label内容来自设备树，比如它的寄存器基地址。用来跟设备树(dtsi文件)比较，就可以知道这对应哪一个GPIO Controller。<br> 下图是在100asK_imx6ull上运行的结果，通过对比设备树可知gpiochip96对应gpio4：<br> <img src="https://images2.imgbox.com/f1/fc/K8oLgcQb_o.png" alt="在这里插入图片描述"><br> 所以gpio4这组引脚的基准引脚号就是96，这也可以“cat base”来再次确认。</p> 
<p>b. 基于sysfs操作引脚：<br> 以100ask_imx6ull为例，它有一个按键，原理图如下：<br> <img src="https://images2.imgbox.com/4b/69/E3lKPje7_o.png" alt="在这里插入图片描述"><br> 那么GPIO4_14的号码是96+14=110，可以如下操作读取按键值：</p> 
<pre><code>echo  110 &gt; /sys/class/gpio/export
echo in &gt; /sys/class/gpio/gpio110/direction
cat /sys/class/gpio/gpio110/value
echo  110 &gt; /sys/class/gpio/unexport
</code></pre> 
<p>注意：如果驱动程序已经使用了该引脚，那么将会export失败，会提示下面的错误：<br> <img src="https://images2.imgbox.com/47/80/h4XU8e9Z_o.png" alt="在这里插入图片描述"><br> 对于输出引脚，假设引脚号为N，可以用下面的方法设置它的值为1：</p> 
<pre><code>echo  N &gt; /sys/class/gpio/export
echo out &gt; /sys/class/gpio/gpioN/direction
echo 1 &gt; /sys/class/gpio/gpioN/value
echo  N &gt; /sys/class/gpio/unexport
</code></pre> 
<h3><a id="1625%09sysfs_STM32MP157_148"></a>16.2.5 sysfs中的访问方法_STM32MP157</h3> 
<p>在sysfs中访问GPIO，实际上用的就是引脚号，老的方法。<br> a. 先确定某个GPIO Controller的基准引脚号(base number)，再计算出某个引脚的号码。<br> 方法如下：<br> ① 先在开发板的/sys/class/gpio目录下，找到各个gpiochipXXX目录：<br> <img src="https://images2.imgbox.com/eb/b3/AIoWRtYC_o.png" alt="在这里插入图片描述"><br> ② 然后进入某个gpiochip目录，查看文件label的内容<br> ③ 根据label的内容就知道它是哪组引脚<br> 下图是在100ask_stm32mp157上运行的结果，可知gpiochip96对应GPIOG：<br> <img src="https://images2.imgbox.com/d5/eb/tWdCQ6O2_o.png" alt="在这里插入图片描述"><br> 所以GPIOG这组引脚的基准引脚号就是96，这也可以“cat base”来再次确认。</p> 
<p>b. 基于sysfs操作引脚：<br> 以100ask_stm32mp157为例，它有一个按键，原理图如下：<br> <img src="https://images2.imgbox.com/f0/de/5klum5cA_o.png" alt="在这里插入图片描述"><br> 那么PG2的号码是96+2=98，可以如下操作读取按键值：</p> 
<pre><code>echo 98 &gt; /sys/class/gpio/export
echo in &gt; /sys/class/gpio/gpio98/direction
cat /sys/class/gpio/gpio98/value
echo  98 &gt; /sys/class/gpio/unexport
</code></pre> 
<p>注意：如果驱动程序已经使用了该引脚，那么将会export失败，会提示下面的错误：<br> <img src="https://images2.imgbox.com/fb/81/EttaOQQ3_o.png" alt="在这里插入图片描述"><br> 对于输出引脚，假设引脚号为N，可以用下面的方法设置它的值为1：</p> 
<pre><code>echo  N &gt; /sys/class/gpio/export
echo out &gt; /sys/class/gpio/gpioN/direction
echo 1 &gt; /sys/class/gpio/gpioN/value
echo  N &gt; /sys/class/gpio/unexport
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f0f439e2cc5a9709b0c78df2026c523/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Day-02</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c5813eeb9cfe02284dc434ccda0e6fb3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue3---vue组件库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>