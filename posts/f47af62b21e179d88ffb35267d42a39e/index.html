<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>synchronized底层原理—Monitor监视器 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="synchronized底层原理—Monitor监视器" />
<meta property="og:description" content="深入了解synchronized 文章目录 深入了解synchronized1. 作用2. 底层实现原理1. Monitor类2. 管程3. ObjectMonitor4. _WaitSet5. _EntryList6. ObjectWaiter 3. 对象头1. 轻量级锁2. 重量级锁 4. 总结参考 synchronized——java多线程锁的关键字 1. 作用 多线程情况下，同步代码的互斥访问有效的解决了共享变量的可见性问题解决了指令重排序的问题 2. 底层实现原理 小插曲：用idea插件jclasslib查看指令字节码
写一段代码，然后查看其指令字节码
public static void soDemo2(){ System.out.println(&#34;进入sDemo2&#34;); synchronized (ThreadDemo.class){ try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&#34;执行 static synchronized(Thread.class) sDemo2&#34;); } } 0 getstatic #8 &lt;java/lang/System.out&gt; 3 ldc #15 &lt;进入sDemo2&gt; 5 invokevirtual #10 &lt;java/io/PrintStream.println&gt; 8 ldc #13 &lt;Thread/synchronizeddemo/ThreadDemo&gt; 10 dup 11 astore_0 12 monitorenter 13 ldc2_w #3 &lt;2000&gt; 16 invokestatic #5 &lt;java/lang/Thread." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f47af62b21e179d88ffb35267d42a39e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-31T07:52:31+08:00" />
<meta property="article:modified_time" content="2020-05-31T07:52:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">synchronized底层原理—Monitor监视器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="synchronized_0"></a>深入了解synchronized</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#synchronized_0" rel="nofollow">深入了解synchronized</a></li><li><ul><li><a href="#1__5" rel="nofollow">1. 作用</a></li><li><a href="#2__11" rel="nofollow">2. 底层实现原理</a></li><li><ul><li><a href="#1_Monitor_66" rel="nofollow">1. Monitor类</a></li><li><a href="#2__82" rel="nofollow">2. 管程</a></li><li><a href="#3_ObjectMonitor_98" rel="nofollow">3. ObjectMonitor</a></li><li><a href="#4__WaitSet_139" rel="nofollow">4. _WaitSet</a></li><li><a href="#5__EntryList_146" rel="nofollow">5. _EntryList</a></li><li><a href="#6_ObjectWaiter_153" rel="nofollow">6. ObjectWaiter</a></li></ul> 
   </li><li><a href="#3__179" rel="nofollow">3. 对象头</a></li><li><ul><li><a href="#1__195" rel="nofollow">1. 轻量级锁</a></li><li><a href="#2__219" rel="nofollow">2. 重量级锁</a></li></ul> 
   </li><li><a href="#4__225" rel="nofollow">4. 总结</a></li><li><a href="#_232" rel="nofollow">参考</a></li></ul> 
 </li></ul> 
</div> 
<br> synchronized——java多线程锁的关键字 
<p></p> 
<h3><a id="1__5"></a>1. 作用</h3> 
<ol><li>多线程情况下，同步代码的互斥访问</li><li>有效的解决了共享变量的可见性问题</li><li>解决了指令重排序的问题</li></ol> 
<h3><a id="2__11"></a>2. 底层实现原理</h3> 
<p><strong>小插曲：用idea插件jclasslib查看指令字节码</strong></p> 
<p>写一段代码，然后查看其指令字节码</p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">soDemo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"进入sDemo2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>ThreadDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行 static synchronized(Thread.class) sDemo2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"> <span class="token number">0</span> getstatic #<span class="token number">8</span> <span class="token operator">&lt;</span>java<span class="token operator">/</span>lang<span class="token operator">/</span>System<span class="token punctuation">.</span>out<span class="token operator">&gt;</span>
 <span class="token number">3</span> ldc #<span class="token number">15</span> <span class="token operator">&lt;</span>进入sDemo2<span class="token operator">&gt;</span>
 <span class="token number">5</span> invokevirtual #<span class="token number">10</span> <span class="token operator">&lt;</span>java<span class="token operator">/</span>io<span class="token operator">/</span>PrintStream<span class="token punctuation">.</span>println<span class="token operator">&gt;</span>
 <span class="token number">8</span> ldc #<span class="token number">13</span> <span class="token operator">&lt;</span>Thread<span class="token operator">/</span>synchronizeddemo<span class="token operator">/</span>ThreadDemo<span class="token operator">&gt;</span>
<span class="token number">10</span> dup
<span class="token number">11</span> astore_0
<span class="token number">12</span> monitorenter
<span class="token number">13</span> ldc2_w #<span class="token number">3</span> <span class="token generics function"><span class="token punctuation">&lt;</span>2000<span class="token punctuation">&gt;</span></span>
<span class="token number">16</span> invokestatic #<span class="token number">5</span> <span class="token operator">&lt;</span>java<span class="token operator">/</span>lang<span class="token operator">/</span>Thread<span class="token punctuation">.</span>sleep<span class="token operator">&gt;</span>
<span class="token number">19</span> <span class="token keyword">goto</span> <span class="token number">27</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span>
<span class="token number">22</span> astore_1
<span class="token number">23</span> aload_1
<span class="token number">24</span> invokevirtual #<span class="token number">7</span> <span class="token operator">&lt;</span>java<span class="token operator">/</span>lang<span class="token operator">/</span>InterruptedException<span class="token punctuation">.</span>printStackTrace<span class="token operator">&gt;</span>
<span class="token number">27</span> getstatic #<span class="token number">8</span> <span class="token operator">&lt;</span>java<span class="token operator">/</span>lang<span class="token operator">/</span>System<span class="token punctuation">.</span>out<span class="token operator">&gt;</span>
<span class="token number">30</span> ldc #<span class="token number">16</span> <span class="token operator">&lt;</span>执行 <span class="token keyword">static</span> <span class="token keyword">synchronized</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> sDemo2<span class="token operator">&gt;</span>
<span class="token number">32</span> invokevirtual #<span class="token number">10</span> <span class="token operator">&lt;</span>java<span class="token operator">/</span>io<span class="token operator">/</span>PrintStream<span class="token punctuation">.</span>println<span class="token operator">&gt;</span>
<span class="token number">35</span> aload_0
<span class="token number">36</span> monitorexit
<span class="token number">37</span> <span class="token keyword">goto</span> <span class="token number">45</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span>
<span class="token number">40</span> astore_2
<span class="token number">41</span> aload_0
<span class="token number">42</span> monitorexit
<span class="token number">43</span> aload_2
<span class="token number">44</span> athrow
<span class="token number">45</span> <span class="token keyword">return</span>
</code></pre> 
<p>基本上发现，<code>synchronized</code>修饰代码块时，是基于<code>monitorenter</code>和<code>monitorexit</code> 指令来实现的，并且进入同步代码是<code>monitorenter</code>，退出同步代码是<code>monitorexit</code> 。但是通过查阅可以知道，如果<code>synchronized</code> 修饰方法名的话，编译后会在方法名上生成一个<code>ACC_SYNCHRONIZED</code> 标识来实现同步。</p> 
<p>但是在Java中万物皆是对象，所以这些指令会不会和某些对象有关系呢？ 果然可以和一个叫<code>Monitor</code>类联系到一块。</p> 
<p>所以看一下<code>Monitor</code> 类是否可以发现新的东西。</p> 
<h4><a id="1_Monitor_66"></a>1. Monitor类</h4> 
<p><code>Monitor</code>类是在<code>javax.management.monitor</code>包下的抽象类。</p> 
<p><img src="https://images2.imgbox.com/ca/27/6aBUa1gs_o.png" alt="在这里插入图片描述"></p> 
<p>官方的介绍总是那么的晦涩难懂，所以要去google一下。</p> 
<blockquote> 
 <p>Synchronizationis built around an internal entity known as the intrinsic lock ormonitor lock. (The API specification often refers to this entity simplyas a “monitor.”)，Every object has an intrinsic lock associated with it.By convention, a thread that needs exclusive and consistent access toan object’s fields has to acquire the object’s intrinsic lock beforeaccessing them, and then release the intrinsic lock when it’s done withthem.</p> 
 <p>大致意思就是synchronized同步基于的是Monitor监视锁来实现的。</p> 
</blockquote> 
<p>monitor相当于一个对象的钥匙，只有拿到此对象的monitor，才能访问该对象的同步代码。相反未获得monitor的只能阻塞来等待持有monitor的线程释放monitor。可以这样比喻吧，<code>monitorenter</code> 和<code>monitorexit</code> 对应的就是拿钥匙和还钥匙。</p> 
<p>关于<code>Monitor</code> ，它从两个方面来支撑Java线程间的同步，<strong>互斥和协作</strong> 。<code>synchronized</code> 获取对象锁来保证同步代码的互斥执行；通过<code>notify</code>、<code>notifyAll</code>、<code>wait</code>进行线程之间的协同工作。所以<code>Object</code> 就是一个监视者。这可能就是Java在多线程方面的设计吧。</p> 
<h4><a id="2__82"></a>2. 管程</h4> 
<p><code>monitor</code>另一个名字叫做管程。可惜自己的操作系统学的并不好，只能通过google来进行恶补了。</p> 
<p><img src="https://images2.imgbox.com/97/f6/L80AAHbj_o.png" alt="在这里插入图片描述"></p> 
<p>所以怎么能够更好的理解Java中的监视锁（管程）就是一个问题了，是否采用Java的面向对象思想能更好的理解一些。</p> 
<p><strong>类比</strong>：</p> 
<blockquote> 
 <p>首先，每一个对象都有一个属于自己的<code>monitor</code>，其次如果线程未获取到<code>singal</code> （许可），则线程阻塞。<code>object</code>可以比作医院的诊室，<code>monitor</code> 就是负责喊病人的护士，线程则是就诊的病人。</p> 
 <p>通过护士（监视器）的调度，诊室（synchronized锁住的对象）内只允许进入一个病人（线程），此病人（线程）在当前时间就拥有此诊室（对象）的使用权，也就是获取了许可。病人就诊完毕，则表明归还了诊室的使用权。然后护士再调度下一个等待的病人进入诊室（被阻塞的线程）。</p> 
 <p>走廊当中等待的病人们 == Wait Set</p> 
</blockquote> 
<h4><a id="3_ObjectMonitor_98"></a>3. ObjectMonitor</h4> 
<p>Java（HotSpot）中的Monitor是基于C++实现的，由ObjectMonitor实现的。</p> 
<pre><code class="prism language-c++">// 初始化monitor，除了semaphore，其他字段都是简单的int或者指针类型
ObjectMonitor() {
    _header       = NULL;
    _count        = 0;
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;
    _WaitSet      = NULL;
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ;
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
    _previous_owner_tid = 0;
  }
</code></pre> 
<p><code>ObjectMonitor</code> 的主要参数都在里面，从名字上慢慢分析。</p> 
<ol><li>_owner：指向持有ObjectMonitor对象的线程</li><li>_WaitSet：存放处于wait状态的队列</li><li>_EntryList：存放处于等待锁block状态的队列</li><li>_recursions：锁的重入次数</li><li>_count：用来记录该线程获取锁的次数</li></ol> 
<p><strong>_WaitSet和 _EntryList有什么区别呢？</strong></p> 
<blockquote> 
 <p>​ 当多个线程同时访问同步代码时，首先进入的就是<code>_EntryList</code> 。当获得对象的<code>monitor</code>时，<code>_owner</code> 指向当前线程，<code>_count</code>进行加1。<br> ​ 若持有<code>monitor</code>的线程调用<code>wait()</code> ，则释放持有的<code>monitor</code> ，<code>_owner</code> 变为<code>null</code> ，<code>_count</code> 减1。<br> ​ 同时该线程进入<code>_WaitSet</code> 等待被唤醒。如果执行完毕，也释放<code>monitor</code>。</p> 
</blockquote> 
<h4><a id="4__WaitSet_139"></a>4. _WaitSet</h4> 
<pre><code class="prism language-c++">protected:
  ObjectWaiter * volatile _WaitSet; // LL of threads wait()ing on the monitor
</code></pre> 
<h4><a id="5__EntryList_146"></a>5. _EntryList</h4> 
<pre><code class="prism language-c++">protected:
  ObjectWaiter * volatile _EntryList ;     // Threads blocked on entry or reentry.
</code></pre> 
<h4><a id="6_ObjectWaiter_153"></a>6. ObjectWaiter</h4> 
<pre><code class="prism language-c++">class ObjectWaiter : public StackObj {
 public:
  enum TStates { TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ } ;
  enum Sorted  { PREPEND, APPEND, SORTED } ;
  ObjectWaiter * volatile _next;
  ObjectWaiter * volatile _prev;
  Thread*       _thread;
  jlong         _notifier_tid;
  ParkEvent *   _event;
  volatile int  _notified ;
  volatile TStates TState ;
  Sorted        _Sorted ;           // List placement disposition
  bool          _active ;           // Contention monitoring is enabled
 public:
  ObjectWaiter(Thread* thread);

  void wait_reenter_begin(ObjectMonitor *mon);
  void wait_reenter_end(ObjectMonitor *mon);
};
</code></pre> 
<p>可以看出来<code>_EntryList</code>和<code>_WaitSet</code> 都是<code>ObjectWaiter</code>类型。可以看出是一个双向链表的集合（ _next，_prev）。</p> 
<h3><a id="3__179"></a>3. 对象头</h3> 
<p>知道了<code>Monitor</code> 的一些底层，那么<code>Monitor</code> 是在堆内存中实例对象如何实现的？锁信息是存储在Mark Work当中的。</p> 
<p><img src="https://images2.imgbox.com/ad/21/lsPWWAdJ_o.png" alt="在这里插入图片描述"></p> 
<p>（网图）</p> 
<p>偏向锁和轻量级锁是Java1.6对synchronized的优化，设计目的就是为了减少性能开销。</p> 
<blockquote> 
 <p>​ 偏向锁是解决的问题是：大多数时候不需要锁的线程或者一个锁多次由一个线程获取，为了减少获取锁的代价，设置了偏向锁，因此偏向锁不用被释放，下次该线程继续访问的时候无需再获取偏向所了，更像一个初级通行证。</p> 
 <p>​ 轻量级锁解决的问题是：少量线程竞争同一个资源并且他们的操作时间比较短，因此不需要将线程阻塞（因为阻塞的代价比较大），没有竞争到锁的线程会轮询固定的次数来获取轻量级锁。</p> 
</blockquote> 
<h4><a id="1__195"></a>1. 轻量级锁</h4> 
<p>轻量级锁也是自旋锁，是通过CAS操作。</p> 
<p>自旋锁与自适应自旋</p> 
<blockquote> 
 <p>Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间，对于代码简单的同步块（如被synchronized修饰的getter()和setter()方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。</p> 
 <p>虚拟机的开发团队注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下“，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p> 
 <p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK1.6中已经变为默认开。自旋等待不能代替阻塞。**自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会浪费处理器资源。**因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（<strong>默认是10次</strong>，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当使用传统的方式去挂起线程了。</p> 
 <p>JDK1.6中引入自适应的自旋锁，自适应意味着自旋的时间不在固定。而是有虚拟机对程序锁的监控与预测来设置自旋的次数。</p> 
 <p>自旋是在轻量级锁中使用的</p> 
 <p>来自于https://www.cnblogs.com/deltadeblog/p/9559035.html</p> 
</blockquote> 
<p>补一张自旋锁的流程图</p> 
<p><img src="https://images2.imgbox.com/96/17/4xztJLGK_o.png" alt="在这里插入图片描述"></p> 
<p>_cxq是阻塞在entry上最近可达的线程的列表。</p> 
<h4><a id="2__219"></a>2. 重量级锁</h4> 
<p>重量级锁也就是同步锁或者互斥锁，它依赖于<code>Monitor</code>，而<code>Monitor</code>则依赖于底层操作系统的实现，所以就出现了用户和内核的切换带来的性能开销。通过对象互斥锁的概念来保证共享数据操作的完整性。每个对象都对应于一个可称为“互斥锁”的标记，这个标记用于保证在任何时刻，只能有一个线程访问该对象。</p> 
<h3><a id="4__225"></a>4. 总结</h3> 
<p>​ Java从出生开始就是基于多线程来设计的，万物皆对象，每个对象又都是一个Monitor。Monitor是线程私有的数据结构，每一个线程都有一个Monitor Record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。<br> ​ 为了优化synchronized互斥锁，在其前面增加了偏向锁和轻量级锁来减少用户态和内核态切换所带来的性能开销。</p> 
<p>根据<code>Monitor</code>的设计，我们可以知道synchronized是一个可重入锁，因为ObjectMonitor中_recursions属性。再通过思考轻量级锁和重量级锁，发现synchronized是非公平锁，当一个线程想获取锁时，先试图插队，如果占用锁的线程释放了锁，下一个线程还没来得及拿锁，那么当前线程就可以直接获得锁；如果锁正在被其它线程占用，则排队，排队的时候就不能再试图获得锁了，只能等到前面所有线程都执行完才能获得锁。</p> 
<h3><a id="_232"></a>参考</h3> 
<p>https://www.cnblogs.com/mingyao123/p/7424911.html</p> 
<p>https://blog.csdn.net/qq_33173608/article/details/88202365</p> 
<p>https://www.cnblogs.com/webor2006/p/11442551.html</p> 
<p>http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9cbafea410f5/src/share/vm/runtime/objectMonitor.hpp</p> 
<p>123/p/7424911.html</p> 
<p>https://blog.csdn.net/qq_33173608/article/details/88202365</p> 
<p>https://www.cnblogs.com/webor2006/p/11442551.html</p> 
<p>http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/9cbafea410f5/src/share/vm/runtime/objectMonitor.hpp</p> 
<p>https://www.cnblogs.com/webor2006/p/11441679.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e4f453ac69ea761839f8346a422862d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习中数据集处理（视频转图片）-图像篇</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1eeb668ee9750610e8438cba10ca0e78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">百钱买百鸡问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>