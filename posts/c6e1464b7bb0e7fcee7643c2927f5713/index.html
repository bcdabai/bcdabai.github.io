<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅尝 FreeRTOS - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅尝 FreeRTOS" />
<meta property="og:description" content="目录
RTOS通识
什么是RTOS
如何下载：以下官网下载链接
nullhttps://freertos.org/zh-cn-cmn-s/
FreeRTOS 实现多任务的原理
移植 FreeRTOS 到上官二号平台 ​编辑 freertos选项卡​编辑
任务的创建与删除
任务创建与删除相关函数 任务动态创建与静态创建的区别：
任务调度
FreeRTOS的任务调度规则是怎样的？
任务的状态 创建四个线程（任务）---- 代码段及API
消息队列
写队列​编辑
读队列 消息队列发送接收 ---- 代码段
信号量
二值信号量 ---- 代码段
计数型信号量 ---- 相比二值信号量可以存放更多，更多锁
互斥量 使用Mutex互斥量替换二值信号量
事件标志组
任务通知
任务通知 ---- 信号量
任务通知 ---- 代码段二值信号量
任务通知 ---- 代码段计数型信号量
任务通知 ---- 代码段事件组标志位组​编辑
软件定时器
软件定时器相关配置
相关API​编辑
中断管理
RTOS通识 什么是RTOS Free 即免费的， RTOS 的全称是 Real time operating system ，中文就是实时操作系统。 注意： RTOS不是指某一个确定的系统，而是指一类操作系统 。比如： uc/OS ， FreeRTOS ， RTX ， RT-Thread等这些都是 RTOS 类操作系统。 FreeRTOS 是一个迷你的实时操作系统内核。作为一个轻量级的操作系统，功能包括：任务管 理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等，可基本满 足较小系统的需要。 由于RTOS 需占用一定的系统资源 ( 尤其是 RAM 资源 ) ，只有 μC/OS-II 、 embOS、 salvo 、 FreeRTOS 等少数实时操作系统能在小 RAM 单片机上运行。相 μC/OS-II 、 embOS等商业操作系统， FreeRTOS 操作系统是完全免费的操作系统，具有源码公开、可移 植、可裁减、调度策略灵活的特点，可以方便地移植到各种单片机上运行，其最新版本为 如何下载：以下官网下载链接 nullhttps://freertos." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c6e1464b7bb0e7fcee7643c2927f5713/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-20T20:55:40+08:00" />
<meta property="article:modified_time" content="2023-11-20T20:55:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅尝 FreeRTOS</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="RTOS%E9%80%9A%E8%AF%86-toc" style="margin-left:80px;"><a href="#RTOS%E9%80%9A%E8%AF%86" rel="nofollow">RTOS通识</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AFRTOS-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AFRTOS" rel="nofollow">什么是RTOS</a></p> 
<p id="%C2%A0%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%EF%BC%9A%E4%BB%A5%E4%B8%8B%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%EF%BC%9A%E4%BB%A5%E4%B8%8B%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5" rel="nofollow"> 如何下载：以下官网下载链接</a></p> 
<p id="nullhttps%3A%2F%2Ffreertos.org%2Fzh-cn-cmn-s%2F-toc" style="margin-left:80px;"><a href="#nullhttps%3A%2F%2Ffreertos.org%2Fzh-cn-cmn-s%2F" rel="nofollow">nullhttps://freertos.org/zh-cn-cmn-s/</a></p> 
<p id="FreeRTOS%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#FreeRTOS%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">FreeRTOS 实现多任务的原理</a></p> 
<p id="%E7%A7%BB%E6%A4%8D%20FreeRTOS%20%E5%88%B0%E4%B8%8A%E5%AE%98%E4%BA%8C%E5%8F%B7%E5%B9%B3%E5%8F%B0%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%A7%BB%E6%A4%8D%20FreeRTOS%20%E5%88%B0%E4%B8%8A%E5%AE%98%E4%BA%8C%E5%8F%B7%E5%B9%B3%E5%8F%B0%C2%A0" rel="nofollow">移植 FreeRTOS 到上官二号平台 </a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0freertos%E9%80%89%E9%A1%B9%E5%8D%A1%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0freertos%E9%80%89%E9%A1%B9%E5%8D%A1%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​编辑 freertos选项卡​编辑</a></p> 
<p id="%C2%A0%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4" rel="nofollow"> 任务的创建与删除</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%20%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%20%C2%A0" rel="nofollow">任务创建与删除相关函数  </a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%9D%99%E6%80%81%E5%88%9B%E5%BB%BA%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%9D%99%E6%80%81%E5%88%9B%E5%BB%BA%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A" rel="nofollow">任务动态创建与静态创建的区别：</a></p> 
<p id="%C2%A0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6" rel="nofollow"> 任务调度</a></p> 
<p id="FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E8%A7%84%E5%88%99%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F-toc" style="margin-left:80px;"><a href="#FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E8%A7%84%E5%88%99%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F" rel="nofollow">FreeRTOS的任务调度规则是怎样的？</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%C2%A0" rel="nofollow">任务的状态 </a></p> 
<p id="%E5%88%9B%E5%BB%BA%E5%9B%9B%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BB%BB%E5%8A%A1%EF%BC%89----%20%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%8F%8AAPI-toc" style="margin-left:40px;"><a href="#%E5%88%9B%E5%BB%BA%E5%9B%9B%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BB%BB%E5%8A%A1%EF%BC%89----%20%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%8F%8AAPI" rel="nofollow">创建四个线程（任务）---- 代码段及API</a></p> 
<p id="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" rel="nofollow">消息队列</a></p> 
<p id="%C2%A0%E5%86%99%E9%98%9F%E5%88%97%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%86%99%E9%98%9F%E5%88%97%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow"> 写队列​编辑</a></p> 
<p id="%E8%AF%BB%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:80px;"><a href="#%E8%AF%BB%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">读队列 </a></p> 
<p id="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5-toc" style="margin-left:80px;"><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5" rel="nofollow">消息队列发送接收 ---- 代码段</a></p> 
<p id="%C2%A0%E4%BF%A1%E5%8F%B7%E9%87%8F-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BF%A1%E5%8F%B7%E9%87%8F" rel="nofollow"> 信号量</a></p> 
<p id="%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5" rel="nofollow">二值信号量 ---- 代码段</a></p> 
<p id="%C2%A0%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%20----%20%E7%9B%B8%E6%AF%94%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E6%9B%B4%E5%A4%9A%EF%BC%8C%E6%9B%B4%E5%A4%9A%E9%94%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%20----%20%E7%9B%B8%E6%AF%94%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E6%9B%B4%E5%A4%9A%EF%BC%8C%E6%9B%B4%E5%A4%9A%E9%94%81" rel="nofollow"> 计数型信号量 ---- 相比二值信号量可以存放更多，更多锁</a></p> 
<p id="%E4%BA%92%E6%96%A5%E9%87%8F%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BA%92%E6%96%A5%E9%87%8F%C2%A0" rel="nofollow">互斥量 </a></p> 
<p id="%C2%A0%E4%BD%BF%E7%94%A8Mutex%E4%BA%92%E6%96%A5%E9%87%8F%E6%9B%BF%E6%8D%A2%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BD%BF%E7%94%A8Mutex%E4%BA%92%E6%96%A5%E9%87%8F%E6%9B%BF%E6%8D%A2%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F" rel="nofollow"> 使用Mutex互斥量替换二值信号量</a></p> 
<p id="%C2%A0%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84" rel="nofollow"> 事件标志组</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5-toc" style="margin-left:40px;"><a href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5" rel="nofollow">任务通知</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%20----%20%E4%BF%A1%E5%8F%B7%E9%87%8F-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%20----%20%E4%BF%A1%E5%8F%B7%E9%87%8F" rel="nofollow">任务通知 ---- 信号量</a></p> 
<p id="%C2%A0%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F" rel="nofollow"> 任务通知 ---- 代码段二值信号量</a></p> 
<p id="%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F-toc" style="margin-left:80px;"><a href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F" rel="nofollow">任务通知 ---- 代码段计数型信号量</a></p> 
<p id="%C2%A0%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%BA%8B%E4%BB%B6%E7%BB%84%E6%A0%87%E5%BF%97%E4%BD%8D%E7%BB%84%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%BA%8B%E4%BB%B6%E7%BB%84%E6%A0%87%E5%BF%97%E4%BD%8D%E7%BB%84%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow"> 任务通知 ---- 代码段事件组标志位组​编辑</a></p> 
<p id="%C2%A0%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8" rel="nofollow"> 软件定时器</a></p> 
<p id="%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE" rel="nofollow">软件定时器相关配置</a></p> 
<p id="%C2%A0%E7%9B%B8%E5%85%B3API%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%C2%A0%E7%9B%B8%E5%85%B3API%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow"> 相关API​编辑</a></p> 
<p id="%C2%A0%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86" rel="nofollow"> 中断管理</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="RTOS%E9%80%9A%E8%AF%86">RTOS通识</h4> 
<h4 id="%E4%BB%80%E4%B9%88%E6%98%AFRTOS">什么是RTOS</h4> 
<blockquote> 
 <div> 
  <span style="color:#24292e;">Free</span> 
  <span style="color:#24292e;">即免费的，</span> 
  <span style="color:#24292e;">RTOS</span> 
  <span style="color:#24292e;">的全称是</span> 
  <span style="color:#24292e;">Real time operating system</span> 
  <span style="color:#24292e;">，中文就是实时操作系统。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">注意：</span> 
  <span style="color:#fe2c24;">RTOS不是指某一个确定的系统，而是指一类操作系统</span> 
  <span style="color:#24292e;">。比如：</span> 
  <span style="color:#24292e;">uc/OS</span> 
  <span style="color:#24292e;">，</span> 
  <span style="color:#24292e;">FreeRTOS</span> 
  <span style="color:#24292e;">，</span> 
  <span style="color:#24292e;">RTX</span> 
  <span style="color:#24292e;">， RT-Thread等这些都是</span> 
  <span style="color:#24292e;">RTOS</span> 
  <span style="color:#24292e;">类操作系统。 </span> 
 </div> 
 <div> 
  <span style="color:#6a737d;">FreeRTOS</span> 
  <span style="color:#6a737d;">是一个迷你的实时操作系统内核。作为一个轻量级的操作系统，功能包括：任务管 理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等，可基本满 足较小系统的需要。 由于RTOS</span> 
  <span style="color:#6a737d;">需占用一定的系统资源</span> 
  <span style="color:#6a737d;">(</span> 
  <span style="color:#6a737d;">尤其是</span> 
  <span style="color:#6a737d;">RAM</span> 
  <span style="color:#6a737d;">资源</span> 
  <span style="color:#6a737d;">)</span> 
  <span style="color:#6a737d;">，只有</span> 
  <span style="color:#6a737d;">μC/OS-II</span> 
  <span style="color:#6a737d;">、 embOS、</span> 
  <span style="color:#6a737d;">salvo</span> 
  <span style="color:#6a737d;">、</span> 
  <span style="color:#6a737d;">FreeRTOS</span> 
  <span style="color:#6a737d;">等少数实时操作系统能在小</span> 
  <span style="color:#6a737d;">RAM</span> 
  <span style="color:#6a737d;">单片机上运行。相</span> 
  <span style="color:#6a737d;">μC/OS-II</span> 
  <span style="color:#6a737d;">、 embOS等商业操作系统，</span> 
  <span style="color:#6a737d;">FreeRTOS</span> 
  <span style="color:#6a737d;">操作系统是完全免费的操作系统，具有源码公开、可移 植、可裁减、调度策略灵活的特点，可以方便地移植到各种单片机上运行，其最新版本为 </span> 
 </div> 
</blockquote> 
<h4 id="%C2%A0%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%EF%BC%9A%E4%BB%A5%E4%B8%8B%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5"> 如何下载：以下官网下载链接</h4> 
<h4 id="nullhttps%3A%2F%2Ffreertos.org%2Fzh-cn-cmn-s%2F"><a class="has-card" href="https://freertos.org/zh-cn-cmn-s/" rel="nofollow" title="FreeRTOS - Market leading RTOS (Real Time Operating System) for embedded systems with Internet of Things extensions"><span class="link-card-box"><span class="link-title">null</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/7a/70/gHcvO7yv_o.png" alt="icon-default.png?t=N7T8">https://freertos.org/zh-cn-cmn-s/</span></span></a></h4> 
<h4 id="FreeRTOS%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86"><span style="color:#24292e;"><strong>FreeRTOS </strong></span><span style="color:#24292e;"><strong>实现多任务的原理 </strong></span></h4> 
<p><span style="color:#24292e;">严格来说 FreeRTOS </span><span style="color:#24292e;">并不是实时操作系统，因为它是</span><span style="color:#24292e;"><strong>分时复用</strong></span><span style="color:#24292e;">的。 系统将时间分割成很多时间片，然后轮流执行各个任务。 每个任务都是独立运行的，互不影响，由于切换的频率很快，就感觉像是同时运行的一样。</span></p> 
<p><img alt="" height="397" src="https://images2.imgbox.com/04/de/OaCVbZGw_o.png" width="811"></p> 
<h3 id="%E7%A7%BB%E6%A4%8D%20FreeRTOS%20%E5%88%B0%E4%B8%8A%E5%AE%98%E4%BA%8C%E5%8F%B7%E5%B9%B3%E5%8F%B0%C2%A0"><span style="color:#24292e;"><strong>移植</strong></span><span style="color:#24292e;"><strong> FreeRTOS </strong></span><span style="color:#24292e;"><strong>到上官二号平台</strong></span> </h3> 
<div> 
 <span style="color:#24292e;"><strong>手动移植</strong></span> 
</div> 
<blockquote> 
 <div> 
  <span style="color:#24292e;">过程复杂且繁琐，对新手不友好。如有需要手动移植，可参照以下文章： </span> 
 </div> 
 <div> 
  <a href="https://blog.csdn.net/qq_61672347/article/details/125529482" title="FreeRTOS移植到STM32_不秃也很强的博客-CSDN博客">FreeRTOS移植到STM32_不秃也很强的博客-CSDN博客</a> 
 </div> 
</blockquote> 
<div></div> 
<div></div> 
<p> <span style="color:#24292e;"><strong>使用</strong></span><span style="color:#24292e;"><strong>CubeMX</strong></span><span style="color:#24292e;"><strong>快速移植 </strong></span><br><img alt="" height="848" src="https://images2.imgbox.com/f3/15/ZKjo25tF_o.png" width="1200"></p> 
<p><img alt="" height="866" src="https://images2.imgbox.com/fd/b6/VT09I0lU_o.png" width="1200"> <img alt="" height="866" src="https://images2.imgbox.com/19/92/HkNx13nd_o.png" width="1200"></p> 
<p><img alt="" height="866" src="https://images2.imgbox.com/55/f8/DfcAy9BW_o.png" width="1200"> <img alt="" height="866" src="https://images2.imgbox.com/65/12/RSluUfhK_o.png" width="1200"></p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0freertos%E9%80%89%E9%A1%B9%E5%8D%A1%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="963" src="https://images2.imgbox.com/54/12/bfTCDMXN_o.png" width="1200"> freertos选项卡<img alt="" height="1030" src="https://images2.imgbox.com/c0/e2/0n7KCe4S_o.png" width="1200"></h4> 
<h3 id="%C2%A0%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4"> <span style="color:#24292e;"><strong>任务的创建与删除</strong></span></h3> 
<blockquote> 
 <div> 
  <span style="color:#24292e;">任务可以理解为进程</span> 
  <span style="color:#24292e;">/</span> 
  <span style="color:#24292e;">线程，创建一个任务，就会在内存开辟一个空间。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">比如： </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">玩游戏、陪女朋友，都可以视为任务 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">Windows </span> 
  <span style="color:#24292e;">系统中的</span> 
  <span style="color:#24292e;"> MarkText </span> 
  <span style="color:#24292e;">、谷歌浏览器、记事本，都是任务。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">任务通常都含有 </span> 
  <span style="color:#24292e;">while(1) </span> 
  <span style="color:#24292e;">死循环。</span> 
 </div> 
</blockquote> 
<h4 id="%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%20%C2%A0"><span style="color:#24292e;"><strong>任务创建与删除相关函数 </strong></span> </h4> 
<p><img alt="" height="247" src="https://images2.imgbox.com/7b/d0/Y6Taqmrt_o.png" width="877"></p> 
<h4 id="%E4%BB%BB%E5%8A%A1%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%9D%99%E6%80%81%E5%88%9B%E5%BB%BA%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span style="color:#24292e;"><strong>任务动态创建与静态创建的区别： </strong></span></h4> 
<div> 
 <span style="color:#24292e;">动态创建任务的堆栈由系统分配，而静态创建任务的堆栈由用户自己传递。 </span> 
</div> 
<div> 
 <span style="color:#24292e;">通常情况下使用动态方式创建任务。 </span> 
</div> 
<p> <img alt="" height="294" src="https://images2.imgbox.com/1f/3e/f7PKuwfq_o.png" width="940"></p> 
<blockquote> 
 <div> 
  <span style="color:#24292e;">1. pvTaskCode</span> 
  <span style="color:#24292e;">：指向任务函数的指针，任务必须实现为永不返回（即连续循环）； </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">2. pcName</span> 
  <span style="color:#24292e;">：任务的名字，主要是用来调试，默认情况下最大长度是</span> 
  <span style="color:#24292e;">16</span> 
  <span style="color:#24292e;">； </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">3. pvParameters</span> 
  <span style="color:#24292e;">：指定的任务栈的参数； </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">4. uxPriority</span> 
  <span style="color:#24292e;">：任务优先级，</span> 
  <span style="color:#24292e;"><strong>数值越大，优先级越大</strong></span> 
  <span style="color:#24292e;">；</span> 
  <span style="color:#24292e;">5. pxCreatedTask</span> 
  <span style="color:#24292e;">：用于返回已创建任务的句柄可以被引用。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">5. usStackDepth 指定任务栈的大小</span> 
 </div> 
 <div> 
  <span style="color:#24292e;">6.pxCreatedTask 任务句柄</span> 
 </div> 
</blockquote> 
<blockquote> 
 <p><img alt="" height="137" src="https://images2.imgbox.com/aa/f0/ZqPmRKbI_o.png" width="901"> </p> 
</blockquote> 
<p> <img alt="" height="681" src="https://images2.imgbox.com/bf/2c/oMCh1rS2_o.png" width="769"></p> 
<hr> 
<blockquote> 
 <div> 
  <span style="color:#24292e;"><strong>vTaskDelete </strong></span> 
  <span style="color:#24292e;"><strong>函数原型</strong></span> 
  <span style="color:#0077aa;">void </span> 
  <span style="color:#dd4a68;">vTaskDelete</span> 
  <span style="color:#999999;">(</span> 
  <span style="color:#000000;">TaskHandle_t xTaskToDelete</span> 
  <span style="color:#999999;">); </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">只需将待删除的任务句柄传入该函数，即可将该任务删除。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">当传入的参数为</span> 
  <span style="color:#24292e;">NULL</span> 
  <span style="color:#24292e;">，则代表删除任务自身（当前正在运行的任务）。 </span> 
 </div> 
</blockquote> 
<h3 id="%C2%A0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"> <span style="color:#24292e;"><strong>任务调度 </strong></span></h3> 
<div> 
 <span style="color:#24292e;">调度器就是使用相关的调度算法来决定当前需要执行的哪个任务。 </span> 
</div> 
<div> 
 <span style="color:#24292e;">FreeRTOS</span> 
 <span style="color:#24292e;">中开启任务调度的函数是 </span> 
 <span style="color:#24292e;">vTaskStartScheduler() </span> 
 <span style="color:#24292e;">，但在</span> 
 <span style="color:#24292e;"> CubeMX </span> 
 <span style="color:#24292e;">中被封装为 </span> 
</div> 
<div> 
 <span style="color:#24292e;">osKernelStart() </span> 
 <span style="color:#24292e;">。 </span> 
</div> 
<div></div> 
<h4 id="FreeRTOS%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E8%A7%84%E5%88%99%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span style="color:#24292e;"><strong>FreeRTOS</strong></span><span style="color:#24292e;"><strong>的任务调度规则是怎样的？ </strong></span></h4> 
<div> 
 <span style="color:#24292e;">FreeRTOS </span> 
 <span style="color:#24292e;">是一个实时操作系统，它所奉行的调度规则： </span> 
</div> 
<div> 
 <span style="color:#fe2c24;">1. 高优先级抢占低优先级任务，系统永远执行最高优先级的任务（即<strong>抢占式调度</strong>） </span> 
</div> 
<div> 
 <span style="color:#fe2c24;">2. 同等优先级的任务轮转调度（即<strong>时间片调度</strong>） </span> 
</div> 
<div> 
 <span style="color:#24292e;">还有一种调度规则是协程式调度，但官方已明确表示不更新，主要是用在小容量的芯片上，用得 </span> 
</div> 
<div> 
 <span style="color:#24292e;">也不多。 </span> 
</div> 
<blockquote> 
 <p><strong> 抢占式调度</strong></p> 
 <div> 
  <span style="color:#24292e;">总结： </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">1. </span> 
  <span style="color:#24292e;">高优先级任务，优先执行； </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">2. </span> 
  <span style="color:#24292e;">高优先级任务不停止，低优先级任务无法执行； </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">3. </span> 
  <span style="color:#24292e;">被抢占的任务将会进入就绪态 </span> 
 </div> 
 <div> 
  <strong><span style="color:#24292e;">时分时调度</span></strong> 
 </div> 
 <div> 
  <div> 
   <span style="color:#24292e;">总结： </span> 
  </div> 
  <div> 
   <span style="color:#24292e;">1. </span> 
   <span style="color:#24292e;">同等优先级任务，轮流执行，时间片流转； </span> 
  </div> 
  <div> 
   <span style="color:#24292e;">2. </span> 
   <span style="color:#24292e;">一个时间片大小，取决为滴答定时器中断周期； </span> 
  </div> 
  <div> 
   <span style="color:#24292e;">3. </span> 
   <span style="color:#24292e;">注意没有用完的时间片不会再使用，下次任务</span> 
   <span style="color:#24292e;"> Task3 </span> 
   <span style="color:#24292e;">得到执行，还是按照一个时间片的时钟 </span> 
  </div> 
  <div> 
   <span style="color:#24292e;">节拍运行</span> 
  </div> 
 </div> 
</blockquote> 
<h3 id="%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%C2%A0"><span style="color:#24292e;"><strong>任务的状态</strong></span> </h3> 
<blockquote> 
 <div> 
  <span style="color:#24292e;">FreeRTOS</span> 
  <span style="color:#24292e;">中任务共存在</span> 
  <span style="color:#24292e;">4</span> 
  <span style="color:#24292e;">种状态： </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>Running </strong></span> 
  <span style="color:#24292e;"><strong>运行态 </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">当任务处于实际运行状态称之为运行态，即</span> 
  <span style="color:#24292e;">CPU</span> 
  <span style="color:#24292e;">的使用权被这个任务占用（同一时间仅一个任务 处于运行态）。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>Ready </strong></span> 
  <span style="color:#24292e;"><strong>就绪态 </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">处于就绪态的任务是指那些能够运行（没有被阻塞和挂起），但是当前没有运行的任务，因为同 优先级或更高优先级的任务正在运行。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>Blocked </strong></span> 
  <span style="color:#24292e;"><strong>阻塞态 </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">如果一个任务因延时，或等待信号量、消息队列、事件标志组等而处于的状态被称之为阻塞态。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>Suspended </strong></span> 
  <span style="color:#24292e;"><strong>挂起态 </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">类似暂停，通过调用函数 </span> 
  <span style="color:#24292e;">vTaskSuspend() </span> 
  <span style="color:#24292e;">对指定任务进行挂起，挂起后这个任务将不被执行， 只有调用函数 xTaskResume() </span> 
  <span style="color:#24292e;">才可以将这个任务从挂起态恢复。 </span> 
 </div> 
 <div></div> 
 <div> 
  <div> 
   <span style="color:#24292e;">总结： </span> 
  </div> 
  <div> 
   <span style="color:#24292e;">1. </span> 
   <span style="color:#24292e;">仅就绪态可转变成运行态 </span> 
  </div> 
  <div> 
   <span style="color:#24292e;">2. </span> 
   <span style="color:#24292e;">其他状态的任务想运行，必须先转变成就绪态</span> 
  </div> 
 </div> 
</blockquote> 
<div></div> 
<h3 id="%E5%88%9B%E5%BB%BA%E5%9B%9B%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BB%BB%E5%8A%A1%EF%BC%89----%20%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%8F%8AAPI" style="background-color:transparent;">创建四个线程（任务）---- 代码段及API</h3> 
<blockquote> 
 <p>相关函数API</p> 
 <div> 
  <span style="color:#24292e;">xTaskCreate() 动态方式创建任务 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">xTaskCreateStatic() 静态方式创建任务 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">vTaskDelete() 删除任务 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#24292e;">/填充这个线程属性参数：线程名字，函数名字--起始地址，优先级、线程最大实例函数、堆栈大小</span> 
 </div> 
 <div> 
  <span style="color:#24292e;"> <strong>osThreadDef</strong>(myTaskLED1,StartTaskLED1,osPriorityNormal,0,128);//osThreadCreate类似xTaskCreate<strong> 创建线程</strong>，传入参数为NULL,  最后返回线程ID（指针指向的ID）<br>  <strong>myTaskLED1Handle</strong> = <strong>osThreadCreate</strong>(osThread(myTaskLED1),NULL);</span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>osThreadTerminate</strong>(myTaskLED1Handle);    //根据线程指针<strong> 销毁</strong>任务一<br> myTaskLED1Handle = NULL;                //线程一指针指向NULL 不加指向会段错误</span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>osThreadSuspend</strong>(myTaskLED2Handle);            //osThreadSuspend把线程指针的ID传入把该线程<strong>挂起</strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>osThreadResume</strong>(myTaskLED2Handle);            //再次按下时<strong>恢复线程</strong>2工作</span> 
 </div> 
</blockquote> 
<div></div> 
<div></div> 
<blockquote> 
 <ol><li>包含了FreeRTOS相关的头文件，以及stdio.h库。</li><li>定义了四个任务句柄，分别是myTaskKey2Handle、myTaskLED1Handle、myTaskLED2Handle和myTaskKey1Handle，分别对应四个不同的任务。</li><li>在MX_FREERTOS_Init函数中，定义并创建了这四个任务。每个任务都对应一个回调函数，如StartTaskLED1、StartTaskLED2等，这些函数包含了各自的任务执行逻辑。</li><li>这四个任务均具有相同的优先级，并分配了128字节的栈空间。然后调用osThreadCreate函数创建并启动这四个任务。这些任务会按照优先级和抢占式的调度方式进行执行。</li></ol> 
</blockquote> 
<div> 
 <pre><code class="hljs">/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stdio.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */
osThreadId myTaskKey2Handle;//指向线程的指针osThreadId   指向myTaskKey2Handle
osThreadId myTaskLED1Handle;
osThreadId myTaskLED2Handle;
osThreadId myTaskKey1Handle;

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */

/* USER CODE END FunctionPrototypes */

void StartTaskLED1(void const * argument);
void StartTaskLED2(void const * argument);
void StartTaskKey1(void const * argument);
void StartTaskKey2(void const * argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* GetIdleTaskMemory prototype (linked to static allocation support) */
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );

/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &amp;xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  /* place for user code */
}
/* USER CODE END GET_IDLE_TASK_MEMORY */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of myTaskKey2 */
  //填入线程参数、用osThreadCreate创建这个线程（类似xTaskCreate），并返回这个线程的ID
  osThreadDef(myTaskKey2, StartTaskKey2, osPriorityNormal, 0, 128);
  myTaskKey2Handle = osThreadCreate(osThread(myTaskKey2), NULL);

  /* definition and creation of myTaskLED1 */
  osThreadDef(myTaskLED1, StartTaskLED1, osPriorityNormal, 0, 128);
  myTaskLED1Handle = osThreadCreate(osThread(myTaskLED1), NULL);

  /* definition and creation of myTaskLED2 */
  osThreadDef(myTaskLED2, StartTaskLED2, osPriorityNormal, 0, 128);
  myTaskLED2Handle = osThreadCreate(osThread(myTaskLED2), NULL);

  /* definition and creation of myTaskKey1 */
  osThreadDef(myTaskKey1, StartTaskKey1, osPriorityNormal, 0, 128);
  myTaskKey1Handle = osThreadCreate(osThread(myTaskKey1), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_StartTaskKey2 */
/**
  * @brief  Function implementing the myTaskKey2 thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartTaskKey2 */
void StartTaskKey2(void const * argument)
{
  /* USER CODE BEGIN StartTaskKey2 */
  /* Infinite loop */
	uint8_t Flog = 0;
	
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET)
	{
		osDelay(20);
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET);//如果按键还是按下状态则循环等待，松开跳出循环
		printf("KEY2 ON\r\n");
		if(Flog == 0){									//第一次按键按下把任务二挂起
			osThreadSuspend(myTaskLED2Handle);			//osThreadSuspend把线程指针的ID传入把该线程挂起
			printf("任务二停止挂起\r\n");
			Flog = 1;									//标志位为1
		}else{
			osThreadResume(myTaskLED2Handle);			//再次按下时恢复线程2工作
			printf("任务二恢复工作");
			Flog = 0;
		}
		
	}
  }
  /* USER CODE END StartTaskKey2 */
}

/* USER CODE BEGIN Header_StartTaskLED1 */
/**
* @brief Function implementing the myTaskLED1 thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskLED1 */
void StartTaskLED1(void const * argument)
{
  /* USER CODE BEGIN StartTaskLED1 */
  /* Infinite loop */
  for(;;)
  {
    HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_8);
    osDelay(500);
  }
  /* USER CODE END StartTaskLED1 */
}

/* USER CODE BEGIN Header_StartTaskLED2 */
/**
* @brief Function implementing the myTaskLED2 thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskLED2 */
void StartTaskLED2(void const * argument)
{
  /* USER CODE BEGIN StartTaskLED2 */
  /* Infinite loop */
  for(;;)
  {
    HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_9);
    osDelay(1000);
  }
  /* USER CODE END StartTaskLED2 */
}

/* USER CODE BEGIN Header_StartTaskKey1 */
/**
* @brief Function implementing the myTaskKey1 thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskKey1 */
void StartTaskKey1(void const * argument)
{
  /* USER CODE BEGIN StartTaskKey1 */
  /* Infinite loop */
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET)
	{
		osDelay(20);
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET);//如果按键还是按下状态则循环等待，松开跳出循环
		printf("KEY1 ON\r\n");
		if(myTaskLED1Handle == NULL){				//如果任务一的指针 指向为NULL
			printf("任务一不存在，开始创建任务一\r\n");
			//填充这个线程属性参数：线程名字，函数名字--起始地址，优先级、线程最大实例函数、堆栈大小
			osThreadDef(myTaskLED1,StartTaskLED1,osPriorityNormal,0,128);
			//osThreadCreate类似xTaskCreate 创建线程，传入参数为NULL,  最后返回线程ID（指针指向的ID）
			myTaskLED1Handle = osThreadCreate(osThread(myTaskLED1),NULL);
		}else{
			printf("任务一存在，开始销毁任务一\r\n");
			osThreadTerminate(myTaskLED1Handle);	//根据线程指针 销毁任务一
			myTaskLED1Handle = NULL;				//线程一指针指向NULL 不加指向会段错误
		}
		
	}

  }
  /* USER CODE END StartTaskKey1 */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */

</code></pre> 
 <h3 id="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" style="background-color:transparent;"><span style="color:#24292e;"><strong>消息队列</strong></span></h3> 
 <blockquote> 
  <p></p> 
  <div> 
   <span style="color:#24292e;">队列又称消息队列，是一种常用于任务间通信的数据结构，队列可以在任务与任务间、中断和任 </span> 
  </div> 
  <div> 
   <span style="color:#24292e;">务间传递信息。 </span> 
  </div> 
  <div> 
   <div> 
    <span style="color:#24292e;"><strong>队列项目</strong></span> 
    <span style="color:#24292e;">：队列中的每一个数据； </span> 
   </div> 
   <div> 
    <span style="color:#24292e;"><strong>队列长度</strong></span> 
    <span style="color:#24292e;">：队列能够存储队列项目的最大数量； </span> 
   </div> 
   <div> 
    <span style="color:#24292e;">创建队列时，需要指定队列长度及队列项目大小</span> 
   </div> 
   <div> 
    <div> 
     <span style="color:#24292e;"><strong>队列特点 </strong></span> 
    </div> 
    <div> 
     <span style="color:#24292e;"><strong>1. </strong></span> 
     <span style="color:#24292e;"><strong>数据入队出队方式 </strong></span> 
    </div> 
    <div> 
     <span style="color:#24292e;">通常采用</span> 
     <span style="color:#24292e;"><strong>先进先出</strong></span> 
     <span style="color:#24292e;">（</span> 
     <span style="color:#24292e;">FIFO</span> 
     <span style="color:#24292e;">）的数据存储缓冲机制，即先入队的数据会先从队列中被读取。 </span> 
    </div> 
    <div> 
     <span style="color:#24292e;">也可以配置为后进先出（</span> 
     <span style="color:#24292e;">LIFO</span> 
     <span style="color:#24292e;">）方式，但用得比较少。 </span> 
    </div> 
    <div> 
     <span style="color:#24292e;"><strong>2. </strong></span> 
     <span style="color:#24292e;"><strong>数据传递方式 </strong></span> 
    </div> 
    <div> 
     <span style="color:#24292e;">采用实际值传递，即将数据拷贝到队列中进行传递，也可以传递指针，在传递较大的数据的时候 </span> 
    </div> 
    <div> 
     <span style="color:#24292e;">采用指针传递。 </span> 
    </div> 
    <div> 
     <span style="color:#24292e;"><strong>3. </strong></span> 
     <span style="color:#24292e;"><strong>多任务访问 </strong></span> 
    </div> 
    <div> 
     <span style="color:#24292e;">队列不属于某个任务，任何任务和中断都可以向队列发送</span> 
     <span style="color:#24292e;">/</span> 
     <span style="color:#24292e;">读取消息 </span> 
    </div> 
    <div> 
     <span style="color:#24292e;"><strong>4. </strong></span> 
     <span style="color:#24292e;"><strong>出队、入队阻塞</strong></span> 
     <span style="color:#24292e;">当任务向一个队列发送消息时，可以指定一个阻塞时间，假设此时当队列已满无法入队。 </span> 
    </div> 
    <div> 
     <span style="color:#24292e;">阻塞时间如果设置为： </span> 
    </div> 
    <div> 
     <span style="color:#24292e;">0</span> 
     <span style="color:#24292e;">：直接返回不会等待； </span> 
    </div> 
    <div> 
     <span style="color:#24292e;">0~port_MAX_DELAY</span> 
     <span style="color:#24292e;">：等待设定的阻塞时间，若在该时间内还无法入队，超时后直接返回不 </span> 
    </div> 
    <div> 
     <span style="color:#24292e;">再等待； </span> 
    </div> 
    <div> 
     <span style="color:#24292e;">port_MAX_DELAY</span> 
     <span style="color:#24292e;">：死等，一直等到可以入队为止。出队阻塞与入队阻塞类似；</span> 
    </div> 
   </div> 
  </div> 
 </blockquote> 
 <div> 
  <div> 
   <div></div> 
  </div> 
 </div> 
</div> 
<p><img alt="" height="1030" src="https://images2.imgbox.com/52/f5/J6whBkla_o.png" width="1200"> </p> 
<h4 id="%C2%A0%E5%86%99%E9%98%9F%E5%88%97%E2%80%8B%E7%BC%96%E8%BE%91"> 写队列<img alt="" height="554" src="https://images2.imgbox.com/d3/33/yKSq0JB8_o.png" width="1146"></h4> 
<blockquote> 
 <div> 
  <span style="color:#000000;">BaseType_t xQueueSend(<br>   QueueHandle_t xQueue, // 队列句柄，指定要发送数据的队列<br>   const void * pvItemToQueue, // 指向要发送的数据项的指针<br>   TickType_t xTicksToWait // 等待时间，以滴答为单位<br> );</span> 
 </div> 
 <div></div> 
 <div>
   注意返回值 用这个类型来接收 pdTURE返回值为真 pdFALSE返回失败 
 </div> 
 <div> 
  <div> 
   <span style="color:#24292e;"><strong>返回值： </strong></span> 
  </div> 
  <div> 
   <span style="color:#24292e;">如果成功写入数据，返回</span> 
   <span style="color:#24292e;"> pdTRUE</span> 
   <span style="color:#24292e;">，否则返回</span> 
   <span style="color:#24292e;"> errQUEUE_FULL</span> 
   <span style="color:#24292e;">。</span> 
  </div> 
 </div> 
</blockquote> 
<h4 id="%E8%AF%BB%E9%98%9F%E5%88%97%C2%A0">读队列 </h4> 
<p> <img alt="" height="323" src="https://images2.imgbox.com/f8/55/UBYCG2ih_o.png" width="1190"></p> 
<blockquote> 
 <div> 
  <span style="color:#000000;">BaseType_t </span> 
  <span style="color:#dd4a68;">xQueueReceive</span> 
  <span style="color:#999999;">( </span> 
 </div> 
 <div> 
  <span style="color:#000000;">QueueHandle_t xQueue</span> 
  <span style="color:#999999;">,//</span> 
  <span style="color:#000000;">队列句柄，指定要接收数据的队列</span> 
 </div> 
 <div> 
  <span style="color:#0077aa;">void </span> 
  <span style="color:#9a6e3a;">*</span> 
  <span style="color:#000000;">pvBuffer</span> 
  <span style="color:#999999;">,</span> 
  <span style="color:#000000;">/ 指向要接收的数据项的指针</span> 
 </div> 
 <div> 
  <span style="color:#000000;">TickType_t xTicksToWait//等待时间，以滴答为单位</span> 
 </div> 
 <div> 
  <span style="color:#999999;">);</span> 
 </div> 
 <p> </p> 
 <div> 
  <span style="color:#24292e;"><strong>返回值： </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">成功返回</span> 
  <span style="color:#24292e;"> pdTRUE</span> 
  <span style="color:#24292e;">，否则返回</span> 
  <span style="color:#24292e;"> pdFALSE</span> 
  <span style="color:#24292e;">。</span> 
 </div> 
</blockquote> 
<h4 id="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5">消息队列发送接收 ---- 代码段</h4> 
<p> QueueStatus =<strong> xQueueSend</strong>(myQueue01Handle,&amp;SendData,0);         //发送这个队列，参数：句柄、内容地址、等待时间</p> 
<p>   BaseType_t     QueueStatus = xQueueReceive(myQueue01Handle,&amp;ReceiveData,0);//接收这个消息队列 存在放ReceiveData中 等待  返回值为这个类型</p> 
<pre><code class="hljs">/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stdio.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */
osThreadId TaskKey1Handle;
osThreadId TaskKey2Handle;
osMessageQId myQueue01Handle;

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */

/* USER CODE END FunctionPrototypes */

void StartTaskKey1(void const * argument);
void StartTaskKey2(void const * argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* GetIdleTaskMemory prototype (linked to static allocation support) */
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );

/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &amp;xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  /* place for user code */
}
/* USER CODE END GET_IDLE_TASK_MEMORY */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* Create the queue(s) */
  /* definition and creation of myQueue01 */
  osMessageQDef(myQueue01, 16, uint16_t);
  myQueue01Handle = osMessageCreate(osMessageQ(myQueue01), NULL);

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of TaskKey1 */
  osThreadDef(TaskKey1, StartTaskKey1, osPriorityNormal, 0, 128);
  TaskKey1Handle = osThreadCreate(osThread(TaskKey1), NULL);

  /* definition and creation of TaskKey2 */
  osThreadDef(TaskKey2, StartTaskKey2, osPriorityNormal, 0, 128);
  TaskKey2Handle = osThreadCreate(osThread(TaskKey2), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_StartTaskKey1 */
/**
  * @brief  Function implementing the TaskKey1 thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartTaskKey1 */
void StartTaskKey1(void const * argument)
{
  /* USER CODE BEGIN StartTaskKey1 */
  /* Infinite loop */
  uint16_t SendData = 100;
  BaseType_t QueueStatus;//队列状态
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
		osDelay(20);
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET);//延时消抖
		printf("KEY1 ON!\r\n");
		//相当于替换这个宏函数BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
		QueueStatus = xQueueSend(myQueue01Handle,&amp;SendData,0);		 //发送这个队列，参数：句柄、内容地址、等待时间
		if(QueueStatus == pdTRUE){									//返回状态pdPASS发送成功 pdLALSE失败
			printf("队列发送成功！,%d\r\n",SendData);
		}else{
			printf("队列发送失败！\r\n");		
		}		
	}

  }
  /* USER CODE END StartTaskKey1 */
}
	
/* USER CODE BEGIN Header_StartTaskKey2 */
/**
* @brief Function implementing the TaskKey2 thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskKey2 */
void StartTaskKey2(void const * argument)
{
  /* USER CODE BEGIN StartTaskKey2 */
  /* Infinite loop */
  uint16_t ReceiveData;
  BaseType_t QueueStatus;//队列状态
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){
		osDelay(20);
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET);//延时消抖
		printf("KEY2 ON!\r\n");
		QueueStatus = xQueueReceive(myQueue01Handle,&amp;ReceiveData,0);//接收这个消息队列 存在放ReceiveData中 等待0
		if(QueueStatus == pdTRUE){
			printf("队列收到消息，%d\r\n",ReceiveData);
		}else{
			printf("队列收到失败!\r\n");
		}		
	}

  }
  /* USER CODE END StartTaskKey2 */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */

</code></pre> 
<p>也可以通过消息队列发送结构体</p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/0c/57/bmCIvPdC_o.png" width="1200"></p> 
<pre><code class="hljs">void StartTaskKey1(void const * argument)
{
  /* USER CODE BEGIN StartTaskKey1 */
  /* Infinite loop */
	struct demo{
		int a;
		char b;
		char* str;
	};
		struct demo SendData = {5,'A',"HELLO"};
//  uint16_t SendData = 100;
  BaseType_t QueueStatus;//队列状态
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
		osDelay(20);
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET);//延时消抖
		printf("KEY1 ON!\r\n");
		//相当于替换这个宏函数BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
		QueueStatus = xQueueSend(myQueue01Handle,&amp;SendData,0);		 //发送这个队列，参数：句柄、内容地址、等待时间
		if(QueueStatus == pdTRUE){									//返回状态pdPASS发送成功 pdLALSE失败
			printf("队列发送成功！%d,%c,%s\r\n",SendData.a,SendData.b,SendData.str);
		}else{
			printf("队列发送失败！\r\n");		
		}		
	}

  }
  /* USER CODE END StartTaskKey1 */
}
	
/* USER CODE BEGIN Header_StartTaskKey2 */
/**
* @brief Function implementing the TaskKey2 thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskKey2 */
void StartTaskKey2(void const * argument)
{
  /* USER CODE BEGIN StartTaskKey2 */
  /* Infinite loop */
	struct demo{
		int a;
		char b;
		char* str;
	};
	struct demo ReceiveData = {5,'A',"HELLO"};
//  uint16_t ReceiveData;
  BaseType_t QueueStatus;//队列状态
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){
		osDelay(20);
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET);//延时消抖
		printf("KEY2 ON!\r\n");
		QueueStatus = xQueueReceive(myQueue01Handle,&amp;ReceiveData,0);//接收这个消息队列 存在放ReceiveData中 等待0
		if(QueueStatus == pdTRUE){
			printf("队列收到消息，%d,%c,%s\r\n",ReceiveData.a,ReceiveData.b,ReceiveData.str);
		}else{
			printf("队列收到失败!\r\n");
		}		
	}

  }
  /* USER CODE END StartTaskKey2 */
}
</code></pre> 
<h3 id="%C2%A0%E4%BF%A1%E5%8F%B7%E9%87%8F" style="background-color:transparent;"> 信号量</h3> 
<blockquote> 
 <p> </p> 
 <div> 
  <span style="color:#24292e;"><strong>什么是信号量？ </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">信号量（</span> 
  <span style="color:#24292e;">Semaphore</span> 
  <span style="color:#24292e;">），是在<strong>多任务环境下使用的一种机制，是可以用来保证两个或多个关键代码段不被并发调用。</strong> </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">信号量这个名字，我们可以把它拆分来看，信号可以起到通知信号的作用，然后我们的量还可以 用来表示资源的数量，当我们的量只有0</span> 
  <span style="color:#24292e;">和</span> 
  <span style="color:#24292e;">1</span> 
  <span style="color:#24292e;">的时候，它就可以被称作<strong>二值信号量</strong>，只有两个状 态，当我们的那个量没有限制的时候，它就可以被称作<strong>为计数型信号量。 </strong>信号量也是队列的一种。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>什么是二值信号量？ </strong></span> 
 </div> 
 <div> 
  <strong><span style="color:#24292e;">二值信号量其实就是一个长度为</span><span style="color:#24292e;">1</span><span style="color:#24292e;">，大小为零的队列，只有</span><span style="color:#24292e;">0</span><span style="color:#24292e;">和</span><span style="color:#24292e;">1</span></strong> 
  <span style="color:#24292e;"><strong>两种状态，</strong>通常情况下，我们用 它来进行互斥访问或任务同步。 互斥访问：比如门钥匙，只有获取到钥匙才可以开门 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">任务同步：</span> 
 </div> 
</blockquote> 
<blockquote> 
 <p><img alt="" height="552" src="https://images2.imgbox.com/c9/8c/39SeIMlr_o.png" width="1151"> </p> 
 <div> 
  <span style="color:#24292e;"><strong>1. </strong></span> 
  <span style="color:#24292e;"><strong>创建二值信号量 </strong></span> 
 </div> 
 <div> 
  <span style="color:#000000;">    BinarySem01Handle = xSemaphoreCreateBinary();//创建二值信号量    </span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#24292e;"><strong>参数：</strong>无 <strong>返</strong></span> 
   <span style="color:#24292e;"><strong><strong>回</strong>值： </strong>成功，返回对应二值信号量的句柄； 失败，返回 NULL </span> 
   <span style="color:#24292e;">。 </span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#24292e;"><strong>2. </strong></span> 
   <span style="color:#24292e;"><strong>释放二值信号量 </strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">BaseType_t </span> 
   <span style="color:#dd4a68;">xSemaphoreGive</span> 
   <span style="color:#999999;">( </span> 
   <span style="color:#000000;">SemaphoreHandle_t xSemaphore </span> 
   <span style="color:#999999;">) </span> 
  </div> 
  <div> 
   <span style="color:#24292e;"><strong>参数： </strong>xSemaphore：要释放的信号量句柄 </span> 
  </div> 
  <div> 
   <span style="color:#24292e;"><strong>返回值： </strong>成功，返回 pdPASS </span> 
   <span style="color:#24292e;">； 失败，返回 errQUEUE_FULL </span> 
   <span style="color:#24292e;">。 </span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#24292e;"><strong>3. </strong></span> 
   <span style="color:#24292e;"><strong>获取二值信号量 </strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">BaseType_t </span> 
   <span style="color:#dd4a68;">xSemaphoreTake</span> 
   <span style="color:#999999;">( </span> 
   <span style="color:#000000;">SemaphoreHandle_t xSemaphore</span> 
   <span style="color:#999999;">, </span> 
  </div> 
  <div> 
   <span style="color:#000000;">TickType_t xTicksToWait </span> 
   <span style="color:#999999;">); </span> 
  </div> 
  <div> 
   <span style="color:#24292e;"><strong>参数： </strong>xSemaphore：要获取的信号量句柄 xTicksToWait：超时时间，</span> 
   <span style="color:#24292e;">0 </span> 
   <span style="color:#24292e;">表示不超时，</span> 
   <span style="color:#24292e;">portMAX_DELAY</span> 
   <span style="color:#24292e;">表示卡死等待； </span> 
  </div> 
  <div> 
   <span style="color:#24292e;"><strong>返回值： </strong>成功pdTURE，返回 pdPASS </span> 
   <span style="color:#24292e;">；</span> 
  </div> 
 </div> 
</blockquote> 
<h4 id="%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5" style="background-color:transparent;">二值信号量 ---- 代码段</h4> 
<p> </p> 
<pre><code class="hljs">/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stdio.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */
//以下私人函数  typedef void * osThreadId 这样的指针指向这个函数
/* USER CODE END Variables */
osThreadId TaskKey1GiveHandle;
osThreadId TaskKey2TakeHandle;
osSemaphoreId BinarySem01Handle;

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */
// 以下私人函数声明
/* USER CODE END FunctionPrototypes */

void StartTaskKey1Give(void const * argument);
void StartTaskKey2Take(void const * argument);
void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* GetIdleTaskMemory prototype (linked to static allocation support) */

void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );

/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
//以上这是一个静态函数，用于获取空闲任务的内存信息。它接受三个参数
//xIdleTaskTCBBuffer是一个StaticTask_t类型的变量，用于存储空闲任务的TCB缓冲区这是一个StackType_t类型的数组，用于存储空闲任务的栈缓冲区。
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

//过调用这个函数，可以获取到空闲任务的相关信息，例如任务的堆栈地址和大小等
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &amp;xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  /* place for user code */
}
/* USER CODE END GET_IDLE_TASK_MEMORY */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */
//RTOS初始化
  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* Create the semaphores(s) */
  /* definition and creation of BinarySem01 */
	
//  osSemaphoreDef(BinarySem01);
//  BinarySem01Handle = osSemaphoreCreate(osSemaphore(BinarySem01), 1);

  /* USER CODE BEGIN RTOS_SEMAPHORES */
	BinarySem01Handle = xSemaphoreCreateBinary();//创建二值信号量	
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of TaskKey1Give */
  osThreadDef(TaskKey1Give, StartTaskKey1Give, osPriorityNormal, 0, 128);//句柄属性填充：线程名字、函数名地址、优先级、几个任务，大小
  TaskKey1GiveHandle = osThreadCreate(osThread(TaskKey1Give), NULL);

  /* definition and creation of TaskKey2Take */
  osThreadDef(TaskKey2Take, StartTaskKey2Take, osPriorityNormal, 0, 128);
  TaskKey2TakeHandle = osThreadCreate(osThread(TaskKey2Take), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_StartTaskKey1Give */
/**
  * @brief  Function implementing the TaskKey1Give thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartTaskKey1Give */
void StartTaskKey1Give(void const * argument)
{
  /* USER CODE BEGIN StartTaskKey1Give */
  /* Infinite loop */
	BaseType_t SemaphoreStart;
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
		osDelay(20);
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET);
		printf("KEY1 ON!\r\n");
		//osSemaphoreCreate
		SemaphoreStart = xSemaphoreGive(BinarySem01Handle);//释放这个锁并返回状态
		if(SemaphoreStart == pdTRUE){
			printf("Semaphore 释放锁成功!\r\n");
		}else{
			printf("Semaphore 释放锁失败!\r\n");			
		}
	}
  }
  /* USER CODE END StartTaskKey1Give */
}

/* USER CODE BEGIN Header_StartTaskKey2Take */
/**
* @brief Function implementing the TaskKey2Take thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskKey2Take */
void StartTaskKey2Take(void const * argument)
{
  /* USER CODE BEGIN StartTaskKey2Take */
  /* Infinite loop */
	BaseType_t SemaphoreStart;
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){
		osDelay(20);
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET);
		printf("KEY2 ON!\r\n");
		//释放这个信号量的锁并返回状态 0表示不超时 portMAX_DELAY表示死等不往后执行
//		SemaphoreStart = xSemaphoreTake(BinarySem01Handle,0);
		SemaphoreStart = xSemaphoreTake(BinarySem01Handle,portMAX_DELAY);
		if(SemaphoreStart == pdTRUE){
			printf("Semaphore 拿锁成功!\r\n");
		}else{
			printf("Semaphore 拿锁失败!\r\n");			
		}
	}
  }
  /* USER CODE END StartTaskKey2Take */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */

</code></pre> 
<h4 id="%C2%A0%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%20----%20%E7%9B%B8%E6%AF%94%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E6%9B%B4%E5%A4%9A%EF%BC%8C%E6%9B%B4%E5%A4%9A%E9%94%81"> 计数型信号量 ---- 相比二值信号量可以存放更多，更多锁</h4> 
<p></p> 
<p><img alt="" height="1030" src="https://images2.imgbox.com/fc/a1/jRO2cN8O_o.png" width="1200"></p> 
<p><img alt="" height="1030" src="https://images2.imgbox.com/77/0c/EUSVc1jp_o.png" width="1200"> </p> 
<div> 
 <blockquote> 
  <p></p> 
 </blockquote> 
 <blockquote> 
  <p>​</p> 
  <div> 
   <span style="color:#24292e;"><strong>什么是计数型信号量？ </strong></span> 
  </div> 
  <div> 
   <span style="color:#24292e;">计数型信号量相当于队列长度大于</span> 
   <span style="color:#24292e;">1 </span> 
   <span style="color:#24292e;">的队列，因此计数型信号量能够容纳多个资源，这在计数型 </span> 
  </div> 
  <div> 
   <span style="color:#24292e;">信号量被创建的时候确定的。</span> 
   <div> 
    <span style="color:#24292e;"><strong>参数： </strong></span> 
   </div> 
   <div> 
    <span style="color:#24292e;">uxMaxCount</span> 
    <span style="color:#24292e;">：可以达到的最大计数值 </span> 
    <span style="color:#24292e;">uxInitialCount</span> 
    <span style="color:#24292e;">：创建信号量时分配给信号量的计数值 </span> 
   </div> 
   <div> 
    <span style="color:#24292e;"><strong>返回值： </strong></span> 
   </div> 
   <div> 
    <span style="color:#24292e;">成功，返回对应计数型信号量的句柄； </span> 
   </div> 
   <div> 
    <span style="color:#24292e;">失败，返回</span> 
    <span style="color:#24292e;"> NULL </span> 
    <span style="color:#24292e;">。 </span> 
   </div> 
  </div> 
  <p>​​​​​​</p> 
 </blockquote> 
 <div></div> 
</div> 
<div> 
 <img alt="" height="559" src="https://images2.imgbox.com/43/11/Bl0X1cMp_o.png" width="1200"> 
</div> 
<p> </p> 
<pre><code class="hljs">/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stdio.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */
//以下私人函数  typedef void * osThreadId 这样的指针指向这个函数
/* USER CODE END Variables */
osThreadId TaskKey1GiveHandle;
osThreadId TaskKey2TakeHandle;
osSemaphoreId myCountingSemHandle;

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */
// 以下私人函数声明
/* USER CODE END FunctionPrototypes */

void StartTaskKey1Give(void const * argument);
void StartTaskKey2Take(void const * argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* GetIdleTaskMemory prototype (linked to static allocation support) */
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );

/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
//以上这是一个静态函数，用于获取空闲任务的内存信息。它接受三个参数
//xIdleTaskTCBBuffer是一个StaticTask_t类型的变量，用于存储空闲任务的TCB缓冲区这是一个StackType_t类型的数组，用于存储空闲任务的栈缓冲区。
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

//过调用这个函数，可以获取到空闲任务的相关信息，例如任务的堆栈地址和大小等
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &amp;xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  /* place for user code */
}
/* USER CODE END GET_IDLE_TASK_MEMORY */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */
//RTOS初始化
  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* Create the semaphores(s) */
  /* definition and creation of myCountingSem */
//  osSemaphoreDef(myCountingSem);
//  myCountingSemHandle = osSemaphoreCreate(osSemaphore(myCountingSem), 5);
	myCountingSemHandle = xSemaphoreCreateCounting(5,0);//创建计数值信号量 参数：最大个数已经配置，初始值多少
	
  /* USER CODE BEGIN RTOS_SEMAPHORES */

  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of TaskKey1Give */
  osThreadDef(TaskKey1Give, StartTaskKey1Give, osPriorityNormal, 0, 128);
  TaskKey1GiveHandle = osThreadCreate(osThread(TaskKey1Give), NULL);

  /* definition and creation of TaskKey2Take */
  osThreadDef(TaskKey2Take, StartTaskKey2Take, osPriorityNormal, 0, 128);
  TaskKey2TakeHandle = osThreadCreate(osThread(TaskKey2Take), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_StartTaskKey1Give */
/**
  * @brief  Function implementing the TaskKey1Give thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartTaskKey1Give */
void StartTaskKey1Give(void const * argument)
{
  /* USER CODE BEGIN StartTaskKey1Give */
  /* Infinite loop */
	BaseType_t SemaphoreStart;
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
		osDelay(20);
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET);
		printf("KEY1 ON!\r\n");
		//osSemaphoreCreate
		SemaphoreStart = xSemaphoreGive(myCountingSemHandle);//释放这个锁并返回状态
		if(SemaphoreStart == pdTRUE){
			printf("SemaphoreCount 释放计数信号量成功!\r\n");
		}else{
			printf("SemaphoreCount 释放计数信号量失败！\r\n");			
		}
	}
  }
  /* USER CODE END StartTaskKey1Give */
}

/* USER CODE BEGIN Header_StartTaskKey2Take */
/**
* @brief Function implementing the TaskKey2Take thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskKey2Take */
void StartTaskKey2Take(void const * argument)
{
  /* USER CODE BEGIN StartTaskKey2Take */
  /* Infinite loop */
	BaseType_t SemaphoreStart;
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){
		osDelay(20);
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET);
		printf("KEY2 ON!\r\n");
		//释放这个信号量的锁并返回状态 0表示不超时 portMAX_DELAY表示死等不往后执行
//		SemaphoreStart = xSemaphoreTake(BinarySem01Handle,0);//二值信号量
		SemaphoreStart = xSemaphoreTake(myCountingSemHandle,0);//计数型信号量
		if(SemaphoreStart == pdTRUE){
			printf("SemaphoreCount 计数信号量拿锁成功!\r\n");
		}else{
			printf("SemaphoreCount 计数信号量拿锁失败!\r\n");			
		}
	}
  }
  /* USER CODE END StartTaskKey2Take */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */

</code></pre> 
<h4 id="%E4%BA%92%E6%96%A5%E9%87%8F%C2%A0" style="background-color:transparent;">互斥量 </h4> 
<p><img alt="" height="609" src="https://images2.imgbox.com/78/93/E9tJue2b_o.png" width="1000"></p> 
<blockquote> 
 <p> </p> 
 <ol><li> <p><strong>互斥量（Mutex）</strong>:</p> 
   <ul><li>互斥量是二进制信号量的一个变种。</li><li><span style="color:#fe2c24;">主要用于保护共享资源，防止多个任务同时访问同一个资源。</span></li><li>任意时刻互斥量的状态只有两种，<span style="color:#fe2c24;">开锁或闭锁。</span></li><li>开启互斥量需要在头文件FreeRTOSConfig.h中设置configUSE_MUTEXES为1。</li><li>互斥量支持互斥量所有权、递归访问以及防止优先级翻转的特性。</li></ul></li><li> <p><strong>信号量</strong>:</p> 
   <ul><li>信号量分为四种：二值信号量、互斥信号量、计数信号量和递归互斥信号量。</li><li>二值信号量是一种特殊的信号量，用于实现任务之间的同步和通信。</li><li>计数信号量用于管理系统多个共享资源，用计数值表示可用资源数目。</li><li>互斥信号量与二值信号量类似，但不支持计数和具有优先级继承的功能。</li><li>递归互斥信号量允许任务多次请求同一资源，而不会导致死锁。</li></ul></li></ol> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;">当两个任务使用同一个锁（互斥量）时，他们实际上是在竞争CPU资源。互斥量是一种同步机制，用于保护共享资源，防止多个任务同时访问该资源，从而避免数据竞争和不一致性。</span></p> 
 <p>当一个任务需要访问共享资源时，它会尝试获取互斥量。如果互斥量的标志位为0，表示该资源未被锁定，该任务就可以获取互斥量，并将标志位设置为1，表示该资源已被锁定。<span style="color:#fe2c24;">如果互斥量的标志位为1，表示该资源已被锁定，该任务就会被阻塞，加入等待队列中，直到互斥量被解锁。</span></p> 
 <p>关于互斥量如何解决优先级倒置的问题<span style="color:#fe2c24;">，FreeRTOS为互斥量赋予了优先级继承的特性</span>。这样，即使一个高优先级的任务等待低优先级任务释放互斥量，它也会被阻塞，以防止优先级翻转。</p> 
 <p> </p> 
</blockquote> 
<p> 且三个任务、线程之间争相抢夺cpu资源<img alt="" height="579" src="https://images2.imgbox.com/cc/c5/SjXXQ5Ml_o.png" width="1200"></p> 
<p>互斥量也是信号量的一种</p> 
<pre><code class="hljs">/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stdio.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */
osThreadId TaskHHandle;
osThreadId TaskMHandle;
osThreadId TaskLHandle;
osSemaphoreId myBinarySemHandle;

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */

/* USER CODE END FunctionPrototypes */

void StartTaskH(void const * argument);
void StartTaskM(void const * argument);
void StartTaskL(void const * argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* GetIdleTaskMemory prototype (linked to static allocation support) */
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );

/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &amp;xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  /* place for user code */
}
/* USER CODE END GET_IDLE_TASK_MEMORY */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* Create the semaphores(s) */
  /* definition and creation of myBinarySem */
  osSemaphoreDef(myBinarySem);
	//通过dudemx创建二值信号量之后里面就有锁， 自己的函数创建里面则无锁
  myBinarySemHandle = osSemaphoreCreate(osSemaphore(myBinarySem), 1);

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of TaskH */
  osThreadDef(TaskH, StartTaskH, osPriorityAboveNormal, 0, 128);
  TaskHHandle = osThreadCreate(osThread(TaskH), NULL);

  /* definition and creation of TaskM */
  osThreadDef(TaskM, StartTaskM, osPriorityNormal, 0, 128);
  TaskMHandle = osThreadCreate(osThread(TaskM), NULL);

  /* definition and creation of TaskL */
  osThreadDef(TaskL, StartTaskL, osPriorityBelowNormal, 0, 128);
  TaskLHandle = osThreadCreate(osThread(TaskL), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_StartTaskH */
/**
  * @brief  Function implementing the TaskH thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartTaskH */
void StartTaskH(void const * argument)
{
  /* USER CODE BEGIN StartTaskH */
  /* Infinite loop */
  for(;;)
  {
	  xSemaphoreTake(myBinarySemHandle,portMAX_DELAY);//拿锁，阻塞等待，并提升优先级，不让高优先级拿锁进屋 。系统创建的二值信号量里面有锁，
	  printf("TaskH:成功拿锁，期间TaskL进不来。\r\n");
	  HAL_Delay(3000);//拿锁后延时2s
	  printf("TaskH:成功还锁，TaskL准备进来。\r\n");	  
	  xSemaphoreGive(myBinarySemHandle);//放回锁 让高优先级TaskH进来
	  osDelay(1000);
  }
  /* USER CODE END StartTaskH */
}

/* USER CODE BEGIN Header_StartTaskM */
/**
* @brief Function implementing the TaskM thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskM */
void StartTaskM(void const * argument)
{
  /* USER CODE BEGIN StartTaskM */
  /* Infinite loop */
  for(;;)
  {
	printf("TaskM:你们争吧，我不进去。。。\r\n");
    osDelay(1000);
  }
  /* USER CODE END StartTaskM */
}

/* USER CODE BEGIN Header_StartTaskL */
/**
* @brief Function implementing the TaskL thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskL */
void StartTaskL(void const * argument)//优先级最低 cudemx里面配置的
{
  /* USER CODE BEGIN StartTaskL */
  /* Infinite loop */
  for(;;)
  {
	  xSemaphoreTake(myBinarySemHandle,portMAX_DELAY);//拿锁，阻塞等待，并提升优先级，不让高优先级拿锁进屋 。系统创建的二值信号量里面有锁，
	  printf("TaskL:成功拿锁，期间TaskH进不来。\r\n");
	  HAL_Delay(3000);//拿锁后延时5s
	  printf("TaskL:成功还锁，TaskH准备进来。\r\n");	  
	  xSemaphoreGive(myBinarySemHandle);//放回锁 让高优先级TaskH进来
	  osDelay(1000);
  }
  /* USER CODE END StartTaskL */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */

</code></pre> 
<h4 id="%C2%A0%E4%BD%BF%E7%94%A8Mutex%E4%BA%92%E6%96%A5%E9%87%8F%E6%9B%BF%E6%8D%A2%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F"> 使用Mutex互斥量替换二值信号量</h4> 
<p><img alt="" height="599" src="https://images2.imgbox.com/6e/79/D5HvBJlx_o.png" width="1081"></p> 
<pre><code class="hljs">void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */
  /* Create the mutex(es) */
  /* definition and creation of myMutex */
  osMutexDef(myMutex);//系统创建的Mutex互斥量锁
  myMutexHandle = osMutexCreate(osMutex(myMutex));

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of TaskH */
  osThreadDef(TaskH, StartTaskH, osPriorityAboveNormal, 0, 128);
  TaskHHandle = osThreadCreate(osThread(TaskH), NULL);

  /* definition and creation of TaskM */
  osThreadDef(TaskM, StartTaskM, osPriorityNormal, 0, 128);
  TaskMHandle = osThreadCreate(osThread(TaskM), NULL);

  /* definition and creation of TaskL */
  osThreadDef(TaskL, StartTaskL, osPriorityBelowNormal, 0, 128);
  TaskLHandle = osThreadCreate(osThread(TaskL), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_StartTaskH */
/**
  * @brief  Function implementing the TaskH thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartTaskH */
void StartTaskH(void const * argument)
{
  /* USER CODE BEGIN StartTaskH */
  /* Infinite loop */
  for(;;)
  {
	  xSemaphoreTake(myMutexHandle,portMAX_DELAY);//拿锁，阻塞等待，并提升优先级，不让高优先级拿锁进屋 。系统创建的二值信号量里面有锁，
	  printf("TaskH:成功拿锁，期间TaskL进不来。\r\n");
	  HAL_Delay(3000);//拿锁后延时2s
	  printf("TaskH:成功还锁，TaskL准备进来。\r\n");	  
	  xSemaphoreGive(myMutexHandle);//放回锁 让高优先级TaskH进来
	  osDelay(1000);
  }
  /* USER CODE END StartTaskH */
}

/* USER CODE BEGIN Header_StartTaskM */
/**
* @brief Function implementing the TaskM thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskM */
void StartTaskM(void const * argument)
{
  /* USER CODE BEGIN StartTaskM */
  /* Infinite loop */
  for(;;)
  {
	printf("TaskM:你们争吧，我不进去。。。\r\n");
    osDelay(1000);
  }
  /* USER CODE END StartTaskM */
}

/* USER CODE BEGIN Header_StartTaskL */
/**
* @brief Function implementing the TaskL thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskL */
void StartTaskL(void const * argument)
{
  /* USER CODE BEGIN StartTaskL */
  /* Infinite loop */
  for(;;)
  {
	  xSemaphoreTake(myMutexHandle,portMAX_DELAY);//拿锁，阻塞等待，并提升优先级，不让高优先级拿锁进屋 。系统创建的二值信号量里面有锁，
	  printf("TaskL:成功拿锁，期间TaskH进不来。\r\n");
	  HAL_Delay(3000);//拿锁后延时5s
	  printf("TaskL:成功还锁，TaskH准备进来。\r\n");	  
	  xSemaphoreGive(myMutexHandle);//放回锁 让高优先级TaskH进来
	  osDelay(1000);
  }
  /* USER CODE END StartTaskL */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */

</code></pre> 
<h3 id="%C2%A0%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84"> <span style="color:#24292e;"><strong>事件标志组</strong></span></h3> 
<blockquote> 
 <p> </p> 
 <div> 
  <span style="color:#24292e;"><strong>什么是事件标志组？ </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>事件标志位</strong></span> 
  <span style="color:#24292e;">：表明某个事件是否发生，联想：全局变量</span> 
  <span style="color:#24292e;"> flag</span> 
  <span style="color:#24292e;">。通常按位表示，每一个位表示一个 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">事件（高</span> 
  <span style="color:#24292e;">8</span> 
  <span style="color:#24292e;">位不算） </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>事件标志组</strong></span> 
  <span style="color:#24292e;">是一组事件标志位的集合， 可以简单的理解事件标志组，就是一个整数。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">事件标志组本质是一个</span> 
  <span style="color:#24292e;"> 16 </span> 
  <span style="color:#24292e;">位或</span> 
  <span style="color:#24292e;"> 32 </span> 
  <span style="color:#24292e;">位无符号的数据类型</span> 
  <span style="color:#24292e;"> EventBits_t </span> 
  <span style="color:#24292e;">，由</span> 
  <span style="color:#24292e;"> configUSE_16_BIT_TICKS </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">决定。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">虽然使用了</span> 
  <span style="color:#24292e;"> 32 </span> 
  <span style="color:#24292e;">位无符号的数据类型变量来存储事件标志， 但其中的高</span> 
  <span style="color:#24292e;">8</span> 
  <span style="color:#24292e;">位用作存储事件标志组的 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">控制信息，低</span> 
  <span style="color:#24292e;"> 24 </span> 
  <span style="color:#24292e;">位用作存储事件标志 ，所以说一个事件组最多可以存储</span> 
  <span style="color:#24292e;"> 24 </span> 
  <span style="color:#24292e;">个事件标志！</span> 
 </div> 
</blockquote> 
<p> <img alt="" height="593" src="https://images2.imgbox.com/bb/f6/PpXwxgo1_o.png" width="1200"></p> 
<blockquote> 
 <div> 
  <span style="color:#24292e;"><strong>1.创建事件标志组 </strong></span> 
 </div> 
 <div> 
  <span style="color:#000000;">EventGroupHandle_t </span> 
  <span style="color:#dd4a68;">xEventGroupCreate</span> 
  <span style="color:#999999;">( </span> 
  <span style="color:#0077aa;">void </span> 
  <span style="color:#999999;">); </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>参数： </strong>无 </span> 
  <span style="color:#24292e;"><strong>返回值： </strong>成功，返回对应事件标志组的句柄；失败，返回</span> 
  <span style="color:#24292e;"> NULL </span> 
  <span style="color:#24292e;">。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#24292e;"><strong>2. </strong></span> 
  <span style="color:#24292e;"><strong>设置事件标志位 </strong></span> 
 </div> 
 <div> 
  <span style="color:#000000;">EventBits_t </span> 
  <span style="color:#dd4a68;">xEventGroupSetBits</span> 
  <span style="color:#999999;">( </span> 
  <span style="color:#000000;">EventGroupHandle_t xEventGroup</span> 
  <span style="color:#999999;">, </span> 
 </div> 
 <div> 
  <span style="color:#0077aa;">const </span> 
  <span style="color:#000000;">EventBits_t uxBitsToSet </span> 
  <span style="color:#999999;">); </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>参数： </strong>xEventGroup：对应事件组句柄。 </span> 
  <span style="color:#24292e;">uxBitsToSet</span> 
  <span style="color:#24292e;">：指定要在事件组中设置的一个或多个位的按位 值。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>返回值： </strong>设置之后事件组中的事件标志位值。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#24292e;"><strong>3. </strong></span> 
  <span style="color:#24292e;"><strong>清除事件标志位 </strong></span> 
 </div> 
 <div> 
  <span style="color:#000000;">EventBits_t </span> 
  <span style="color:#dd4a68;">xEventGroupClearBits</span> 
  <span style="color:#999999;">(</span> 
  <span style="color:#000000;">EventGroupHandle_t xEventGroup</span> 
  <span style="color:#999999;">, </span> 
 </div> 
 <div> 
  <span style="color:#0077aa;">const </span> 
  <span style="color:#000000;">EventBits_t uxBitsToClear </span> 
  <span style="color:#999999;">); </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>参数： </strong>xEventGroup：对应事件组句柄。 </span> 
  <span style="color:#24292e;">uxBitsToClear</span> 
  <span style="color:#24292e;">：指定要在事件组中清除的一个或多个位的按位 值。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>返回值： </strong>清零之前事件组中事件标志位的值。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#24292e;"><strong>4. </strong></span> 
  <span style="color:#24292e;"><strong>等待事件标志位 </strong></span> 
 </div> 
 <div> 
  <span style="color:#000000;">EventBits_t </span> 
  <span style="color:#dd4a68;">xEventGroupWaitBits</span> 
  <span style="color:#999999;">( </span> 
 </div> 
 <div> 
  <span style="color:#0077aa;">const </span> 
  <span style="color:#000000;">EventGroupHandle_t xEventGroup</span> 
  <span style="color:#999999;">, </span> 
 </div> 
 <div> 
  <span style="color:#0077aa;">const </span> 
  <span style="color:#000000;">EventBits_t uxBitsToWaitFor</span> 
  <span style="color:#999999;">, </span> 
 </div> 
 <div> 
  <span style="color:#0077aa;">const </span> 
  <span style="color:#000000;">BaseType_t xClearOnExit</span> 
  <span style="color:#999999;">, </span> 
 </div> 
 <div> 
  <span style="color:#0077aa;">const </span> 
  <span style="color:#000000;">BaseType_t xWaitForAllBits</span> 
  <span style="color:#999999;">, </span> 
 </div> 
 <div> 
  <span style="color:#000000;">TickType_t xTicksToWait </span> 
  <span style="color:#999999;">); </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>参数：</strong></span> 
  <span style="color:#24292e;">xEventGroup</span> 
  <span style="color:#24292e;">：对应的事件标志组句柄 </span> 
  <span style="color:#24292e;">uxBitsToWaitFor</span> 
  <span style="color:#24292e;">：指定事件组中要等待的一个或多个事件 位的按位值 xClearOnExit</span> 
  <span style="color:#24292e;">：</span> 
  <span style="color:#24292e;">pdTRUE——</span> 
  <span style="color:#24292e;">清除对应事件位，</span> 
  <span style="color:#24292e;">pdFALSE——</span> 
  <span style="color:#24292e;">不清除 </span> 
  <span style="color:#24292e;">xWaitForAllBits</span> 
  <span style="color:#24292e;">： pdTRUE——所有等待事件位全为</span> 
  <span style="color:#24292e;">1</span> 
  <span style="color:#24292e;">（逻辑与），</span> 
  <span style="color:#24292e;">pdFALSE——</span> 
  <span style="color:#24292e;">等待的事件位有一个为</span> 
  <span style="color:#24292e;">1</span> 
  <span style="color:#24292e;">（逻辑或） xTicksToWait：超时 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>返回值： </strong>等待的事件标志位值：等待事件标志位成功，返回等待到的事件标志位 其他值：等待事件标志位 失败，返回事件组中的事件标志位</span> 
 </div> 
 <p><span style="color:#fe2c24;"> xEventGroupWaitBits():等待标志位函数<br> xEventGroup：事件组句柄，用于标识要等待的事件组。<br> uxBitsToWaitFor：标志位的值 最低位和次低位可以表示为0x0001 | 0x0002 = 0x0003<br> xClearOnExit：是否清除指定标志位，清除pdTURE 不清除pdFALSE<br> xWairForAllBit:标志位一二都发生 pdTURE 只要一个就触发则按位或pdFALSE<br> xTicksToWait：最大等待时间一般 portMAX_DELAY，</span></p> 
</blockquote> 
<pre><code class="hljs">/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stdio.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */
EventGroupHandle_t EventHandle;//创建这样一个指针 
/* USER CODE END Variables */
osThreadId Task02Handle;
osThreadId Task01Handle;

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */

/* USER CODE END FunctionPrototypes */

void StartTask02(void const * argument);
void StartTask01(void const * argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* GetIdleTaskMemory prototype (linked to static allocation support) */
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );

/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &amp;xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  /* place for user code */
}
/* USER CODE END GET_IDLE_TASK_MEMORY */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of Task02 */
  osThreadDef(Task02, StartTask02, osPriorityNormal, 0, 128);
  Task02Handle = osThreadCreate(osThread(Task02), NULL);

  /* definition and creation of Task01 */
  osThreadDef(Task01, StartTask01, osPriorityNormal, 0, 128);
  Task01Handle = osThreadCreate(osThread(Task01), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  EventHandle = xEventGroupCreate();//创建这样一个事件 指针指向这个事件
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_StartTask02 */
/**
  * @brief  Function implementing the Task02 thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartTask02 */
void StartTask02(void const * argument)
{
  /* USER CODE BEGIN StartTask02 */
  /* Infinite loop */

	//两个按下时 及之后都是0x0003；
  for(;;)
  { 
	  //检测按键1按下，至标志位最低位为1 0x0001；
	  if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
		  osDelay(20);
		  if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
			xEventGroupSetBits(EventHandle,0x01);	//设置事件组标志位		  
		  }
		  while( HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET);
	  }	  
	  //按键2 按下，至标志位0x0002;但是
	  if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){
		  osDelay(20);
		  if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){ 
			xEventGroupSetBits(EventHandle,0x02);	//设置事件组标志位			  
		  }
		  while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET);
	  }
      osDelay(2);
	   
  }
  /* USER CODE END StartTask02 */
}

/* USER CODE BEGIN Header_StartTask01 */
/**
* @brief Function implementing the Task01 thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTask01 */
void StartTask01(void const * argument)
{
  /* USER CODE BEGIN StartTask01 */
  /* Infinite loop */
/*
xEventGroupWaitBits():等待标志位函数
	
xEventGroup：事件组句柄，用于标识要等待的事件组。
uxBitsToWaitFor：标志位的值 最低位和次低位可以表示为0x0001 | 0x0002 = 0x0003
xClearOnExit：是否清除指定标志位，清除pdTURE 不清除pdFALSE 如果不清楚标志位则一直成立 会不断打印输出
xWairForAllBit:标志位一二都发生时 pdTURE    只要一个就触发则按位或pdFALSE
xTicksToWait：最大等待时间一般 portMAX_DELAY，
*/
  EventBits_t EventReturnStatus = 0;
  for(;;)
  {
	  EventReturnStatus = xEventGroupWaitBits(EventHandle,0x01|0x02,pdTRUE,pdTRUE,portMAX_DELAY);//这个事件，其中标志位或上，每次清除标志位，两个标志位都发是，等待
	  printf("EventReturnStatus = %#x\r\n",EventReturnStatus);
      osDelay(1);
  }

  /* USER CODE END StartTask01 */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */

</code></pre> 
<h3 id="%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5" style="background-color:transparent;"><span style="color:#24292e;"><strong>任务通知</strong></span></h3> 
<blockquote> 
 <div></div> 
 <div> 
  <span style="color:#24292e;"><strong>什么是任务通知？及优势、作用。</strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">每个任</span> 
  <span style="color:#fe2c24;">务都有一个 32 位的通知值</span> 
  <span style="color:#24292e;">。按照 FreeRTOS 官方的说法，使用消息通知比</span> 
  <span style="color:#fe2c24;">通过二进制信号量方式解除阻塞任务快 45%</span> 
  <span style="color:#24292e;">， 并且</span> 
  <span style="color:#fe2c24;">更加 省内存（无需创建队列</span> 
  <span style="color:#24292e;">）。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#24292e;">在大多数情况下，任务通知可以替代二值信号量、计数信号量、事件标志组，可以替代长度为 1 的队列（可以保存一个 32 </span> 
  <span style="color:#24292e;">位整数或指针值），并且任务通知速度更快、使用的</span> 
  <span style="color:#24292e;">RAM</span> 
  <span style="color:#24292e;">更少！ </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#24292e;"><strong>任务通知值的更新方式 </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">FreeRTOS </span> 
  <span style="color:#24292e;">提供以下几种方式发送通知给任务 ： </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">发送消息给任务，如果有通知未读， 不覆盖通知值 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">发送消息给任务，直接覆盖通知值 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">发送消息给任务，设置通知值的一个或者多个位 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">发送消息给任务，递增通知值 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">通过对以上方式的合理使用，可以在一定场合下替代原本的队列、信号量、事件标志组等。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#24292e;"><strong>任务通知的优势和劣势 </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>任务通知的优势 </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">1. </span> 
  <span style="color:#24292e;">使用任务通知向任务发送事件或数据，比使用队列、事件标志组或信号量快得多。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">2. </span> 
  <span style="color:#24292e;">使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#24292e;"><strong>任务通知的劣势 </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">1. </span> 
  <span style="color:#24292e;">只有任务可以等待通知，中断服务函数中不可以，因为中断没有</span> 
  <span style="color:#24292e;"> TCB </span> 
  <span style="color:#24292e;">。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">2. </span> 
  <span style="color:#24292e;">通知只能一对一，因为通知必须指定任务。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">3. </span> 
  <span style="color:#24292e;">等待通知的任务可以被阻塞， 但是发送消息的任务，任何情况下都不会被阻塞等待。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">4. </span> 
  <span style="color:#24292e;">任务通知是通过更新任务通知值来发送数据的，任务结构体中只有一个任务通知值，只能保 持一个数据。<strong>任务通知相关</strong></span> 
  <span style="color:#24292e;"><strong> API </strong></span> 
  <span style="color:#24292e;"><strong>函数</strong></span> 
 </div> 
 <p> </p> 
</blockquote> 
<p> <img alt="" height="483" src="https://images2.imgbox.com/e1/5e/LPT2H5oD_o.png" width="1057"><img alt="" height="745" src="https://images2.imgbox.com/f7/ee/LdAy4gBN_o.png" width="955"></p> 
<blockquote> 
 <p><img alt="" height="561" src="https://images2.imgbox.com/41/73/QPvPS1wr_o.png" width="934"> </p> 
 <div> 
  <span style="color:#24292e;">xTaskToNotify<strong>返回值： </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">如果被通知任务还没取走上一个通知，又接收了一个通知，则这次通知值未能更新并返回 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">pdFALSE</span> 
  <span style="color:#24292e;">， 而其他情况均返回</span> 
  <span style="color:#24292e;">pdPASS</span> 
  <span style="color:#24292e;">。 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">BaseType_t </span> 
  <span style="color:#dd4a68;">xTaskNotifyAndQuery</span> 
  <span style="color:#999999;">( </span> 
  <span style="color:#000000;">TaskHandle_t xTaskToNotify</span> 
  <span style="color:#999999;">, </span> 
 </div> 
 <div> 
  <span style="color:#dd4a68;">uint32_t </span> 
  <span style="color:#000000;">ulValue</span> 
  <span style="color:#999999;">, </span> 
 </div> 
 <div> 
  <span style="color:#000000;">eNotifyAction eAction</span> 
  <span style="color:#999999;">, </span> 
 </div> 
 <div> 
  <span style="color:#dd4a68;">uint32_t </span> 
  <span style="color:#9a6e3a;">*</span> 
  <span style="color:#000000;">pulPreviousNotifyValue </span> 
  <span style="color:#999999;">); </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>参数： </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">xTaskToNotify</span> 
  <span style="color:#24292e;">：需要接收通知的任务句柄； </span> 
  <span style="color:#24292e;">ulValue</span> 
  <span style="color:#24292e;">：用于更新接收任务通知值， 具体如何更新 由形参 eAction </span> 
  <span style="color:#24292e;">决定； </span> 
  <span style="color:#24292e;">eAction</span> 
  <span style="color:#24292e;">：一个枚举，代表如何使用任务通知的值； </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">pulPreviousNotifyValue</span> 
  <span style="color:#24292e;">：对象任务的上一个任务通知值，如果为</span> 
  <span style="color:#24292e;"> NULL</span> 
  <span style="color:#24292e;">， 则不需要回传， 这个时 候就等价于函数 xTaskNotify()</span> 
  <span style="color:#24292e;">。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>返回值： </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">如果被通知任务还没取走上一个通知，又接收了一个通知，则这次通知值未能更新并返回 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;">pdFALSE</span> 
  <span style="color:#24292e;">， 而其他情况均返回</span> 
  <span style="color:#24292e;">pdPASS</span> 
  <span style="color:#24292e;">。 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">BaseType_t </span> 
  <span style="color:#dd4a68;">xTaskNotifyGive</span> 
  <span style="color:#999999;">( </span> 
  <span style="color:#000000;">TaskHandle_t xTaskToNotify </span> 
  <span style="color:#999999;">);</span> 
  <span style="color:#24292e;"><strong>参数： </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">xTaskToNotify</span> 
  <span style="color:#24292e;">：接收通知的任务句柄， 并让其自身的任务通知值加</span> 
  <span style="color:#24292e;"> 1</span> 
  <span style="color:#24292e;">。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>返回值： </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">总是返回</span> 
  <span style="color:#24292e;"> pdPASS</span> 
  <span style="color:#24292e;">。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>2. </strong></span> 
  <span style="color:#24292e;"><strong>等待通知 </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">等待通知</span> 
  <span style="color:#24292e;">API</span> 
  <span style="color:#24292e;">函数只能用在任务，不可应用于中断中！ </span> 
 </div> 
</blockquote> 
<h4></h4> 
<h4 id="%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%20----%20%E4%BF%A1%E5%8F%B7%E9%87%8F">任务通知 ---- 信号量</h4> 
<blockquote> 
 <div> 
  <span style="color:#000000;">BaseType_t </span> 
  <span style="color:#dd4a68;">xTaskNotifyGive</span> 
  <span style="color:#999999;">( </span> 
  <span style="color:#000000;">TaskHandle_t xTaskToNotify </span> 
  <span style="color:#999999;">);</span> 
  <span style="color:#24292e;"><strong>参数： </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">xTaskToNotify</span> 
  <span style="color:#24292e;">：接收通知的任务句柄， 并让其自身的任务通知值加</span> 
  <span style="color:#24292e;"> 1</span> 
  <span style="color:#24292e;">。 </span> 
 </div> 
 <div> 
  <span style="color:#24292e;"><strong>返回值： </strong></span> 
 </div> 
 <div> 
  <span style="color:#24292e;">总是返回</span> 
  <span style="color:#24292e;"> pdPASS</span> 
  <span style="color:#24292e;">。 </span> 
 </div> 
</blockquote> 
<p><img alt="" height="450" src="https://images2.imgbox.com/ab/a6/UjXZFVmv_o.png" width="911"> <img alt="" height="587" src="https://images2.imgbox.com/7f/4e/TZOMn6ro_o.png" width="940"></p> 
<h4 id="%C2%A0%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F"> 任务通知 ---- 代码段二值信号量</h4> 
<p></p> 
<p>发送端不会阻塞 接收端会阻塞<img alt="" height="449" src="https://images2.imgbox.com/96/26/NFY1nKML_o.png" width="786"></p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/f4/8c/fflQ864W_o.png" width="912"> </p> 
<pre><code class="hljs">//通过两个任务通知传递 信号量 。发送端不会阻塞，接收端会阻塞
void StartTaskSend(void const * argument)
{
  /* USER CODE BEGIN StartTaskSend */
  /* Infinite loop */
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
		osDelay(20);
		if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
			printf("KEY1:任务通知 发送二值信号量\r\n");
			xTaskNotifyGive(TaskReceiveHandle);//任务通知 发送信号量--发送到接收任务 发送端且不会阻塞，但是接收端会阻塞
		}
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET);
	}
    osDelay(1);
  }
  /* USER CODE END StartTaskSend */
}

/* USER CODE BEGIN Header_StartTaskReceive */
/**
* @brief Function implementing the TaskReceive thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskReceive */
void StartTaskReceive(void const * argument)
{
  /* USER CODE BEGIN StartTaskReceive */
	uint32_t Status = 0;
  /* Infinite loop */
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){
		osDelay(20);
		if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){

			Status = ulTaskNotifyTake(pdTRUE,portMAX_DELAY);//任务通知 接收信号量 参数：TURE二值信号量| FALSE计数型信号量、超时时间
			if(Status != 0){
				printf("KEY2:任务通知 接收二值信号量 %d\r\n",Status);				
			}
		}
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET);
	}
    osDelay(1);
  }
  /* USER CODE END StartTaskReceive */
}
</code></pre> 
<h4 id="%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5%E8%AE%A1%E6%95%B0%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F" style="background-color:transparent;">任务通知 ---- 代码段计数型信号量</h4> 
<pre><code class="hljs">void StartTaskSend(void const * argument)
{
  /* USER CODE BEGIN StartTaskSend */
  /* Infinite loop */
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
		osDelay(20);
		if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
			printf("KEY1:任务通知 发送二值信号量\r\n");
			xTaskNotifyGive(TaskReceiveHandle);//任务通知 发送信号量--发送到接收任务 发送端且不会阻塞，但是接收端会阻塞
		}
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET);
	}
    osDelay(1);
  }
  /* USER CODE END StartTaskSend */
}

/* USER CODE BEGIN Header_StartTaskReceive */
/**
* @brief Function implementing the TaskReceive thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskReceive */
void StartTaskReceive(void const * argument)
{
  /* USER CODE BEGIN StartTaskReceive */
	uint32_t Status = 0;
  /* Infinite loop */
  for(;;)
  {
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){
		osDelay(20);
		if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){

			Status = ulTaskNotifyTake(pdFALSE,portMAX_DELAY);//任务通知 接收信号量 参数：TURE二值信号量| FALSE计数型信号量、超时时间
			if(Status != 0){
				printf("KEY2:任务通知 接收计数型信号量 %d\r\n",Status);	//会阻塞读取 发送任务发送便可立即读取			
			}
		}
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET);
	}
    osDelay(1);
  }
  /* USER CODE END StartTaskReceive */
}</code></pre> 
<h4 id="%C2%A0%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%20----%20%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%BA%8B%E4%BB%B6%E7%BB%84%E6%A0%87%E5%BF%97%E4%BD%8D%E7%BB%84%E2%80%8B%E7%BC%96%E8%BE%91"><strong> 任务通知 ---- 代码段事件组标志位组</strong><img alt="" height="483" src="https://images2.imgbox.com/ab/e6/6yUDqs2B_o.png" width="1057"></h4> 
<p><img alt="" height="419" src="https://images2.imgbox.com/f3/c5/ty3wJ2WV_o.png" width="891"> </p> 
<p><img alt="" height="684" src="https://images2.imgbox.com/68/57/g93b5mnD_o.png" width="633"> </p> 
<p> <img alt="" height="822" src="https://images2.imgbox.com/a7/55/FmVcoBQt_o.png" width="743"></p> 
<blockquote> 
 <p>            xTaskNotify(TaskReceiveHandle,0x0001,eSetBits);//向哪个任务发送，发送什么，发送方式</p> 
 <p></p> 
 <p></p> 
 <p>* @brief <span style="color:#fe2c24;">xTaskNotifyWait</span>根据用户指定的参数的不同，"可以灵活的用于实现轻量级的消息队列队列、三值信号量、讦数信号量和事件组功能，<br> * @param 当事件发生时，对应的事件位将被设置为1；当事件未发生时，对应的事件位保持为0<br> * @param 0xFFFFFFFF(ULONG_MAX)，那么在退出函数前接收到的任务通知值的所有位都会被清 0<br> * @param 用于保存接收到的任务通知值。<br> * @param 等待超时时间，单位为系统节拍周期。<br> * @retval 成功返回pdTRUE 失败返回pdFALSE </p> 
</blockquote> 
<pre><code class="hljs">void StartTaskSend(void const * argument)
{
  /* USER CODE BEGIN StartTaskSend */
  /* Infinite loop */
  for(;;)
  {
	//按键KEY1按下 任务通知向接收任务发送一个事件组eSetBits
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
		osDelay(20);
		if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
			
			printf("KEY1:发送0x0001\r\n");
			xTaskNotify(TaskReceiveHandle,0x0001,eSetBits);//向哪个任务发送，发送什么，发送方式
		}
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET);
	}
	//按键KEY2按下 任务通知向接收任务发送一个事件组eSetBits	
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){
		osDelay(20);
		if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){
			
			printf("KEY2:发送0x0002\r\n");
			xTaskNotify(TaskReceiveHandle,0x0002,eSetBits);
		}
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET);
	}
    osDelay(1);
  }
  /* USER CODE END StartTaskSend */
}

/* USER CODE BEGIN Header_StartTaskReceive */
/**
* @brief Function implementing the TaskReceive thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTaskReceive */
void StartTaskReceive(void const * argument)
{
  /* USER CODE BEGIN StartTaskReceive */
	uint32_t RcvData = 0,RcvBit = 0;
/*
	
参数1：当事件发生时，对应的事件位将被设置为1；当事件未发生时，对应的事件位保持为0
参数1：	
	*/
/**
* @brief xTaskNotifyWait根据用户指定的参数的不同，"可以灵活的用于实现轻量级的消息队列队列、三值信号量、讦数信号量和事件组功能，
* @param 当事件发生时，对应的事件位将被设置为1；当事件未发生时，对应的事件位保持为0
* @param 0xFFFFFFFF(ULONG_MAX)，那么在退出函数前接收到的任务通知值的所有位都会被清 0
* @param 用于保存接收到的任务通知值。
* @param 等待超时时间，单位为系统节拍周期。
* @retval 成功返回pdTRUE 失败返回pdFALSE
*/
  /* Infinite loop */
  for(;;)
  {
	if(xTaskNotifyWait(0,0xFFFFFFFF,&amp;RcvBit,portMAX_DELAY) == pdTRUE){
		printf("成功收到\r\n");
	}
	
	if(RcvBit &amp; 0x0001){
		RcvData |= 0x0001;
	}
	if(RcvBit &amp; 0x0002){
		RcvData |= 0x0002;
	}	
	if(RcvData == 0x0003){
		printf("bit2 RcvData = %x\r\n",RcvData);
		printf("任务通知模拟事件标志组接收成功！\r\n");		
		RcvData = 0;
	}
	

    osDelay(1);
  }
  /* USER CODE END StartTaskReceive */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */

</code></pre> 
<p> <img alt="" height="703" src="https://images2.imgbox.com/70/56/e382aF4z_o.png" width="597"></p> 
<p> 任务通知 ---- 代码段消息队列</p> 
<pre><code class="hljs">void StartTaskSend(void const * argument)
{
  /* USER CODE BEGIN StartTaskSend */
  /* Infinite loop */
  for(;;)
  {
	//按键KEY1按下 任务通知向接收任务发送一个事件组eSetBits
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
		osDelay(20);
		if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET){
			
			printf("KEY1:按下\r\n");
			xTaskNotify(TaskReceiveHandle,1,eSetValueWithOverwrite);//向哪个任务发送，发送什么，发送方式(消息队列覆盖写入)
		}
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == GPIO_PIN_RESET);
	}
	//按键KEY2按下 任务通知向接收任务发送一个事件组eSetBits	
	if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){
		osDelay(20);
		if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET){
			
			printf("KEY2:按下\r\n");
			xTaskNotify(TaskReceiveHandle,2,eSetValueWithOverwrite);
		}
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == GPIO_PIN_RESET);
	}
    osDelay(1);
  }
  /* USER CODE END StartTaskSend */
}


void StartTaskReceive(void const * argument)
{
  /* USER CODE BEGIN StartTaskReceive */
	uint32_t RcvData;
/*
	
参数1：当事件发生时，对应的事件位将被设置为1；当事件未发生时，对应的事件位保持为0
参数1：	
	*/
/**
* @brief xTaskNotifyWait根据用户指定的参数的不同，"可以灵活的用于实现轻量级的消息队列队列、三值信号量、讦数信号量和事件组功能，
* @param 当事件发生时，对应的事件位将被设置为1；当事件未发生时，对应的事件位保持为0
* @param 0xFFFFFFFF(ULONG_MAX)，那么在退出函数前接收到的任务通知值的所有位都会被清 0
* @param 用于保存接收到的任务通知值。
* @param 等待超时时间，单位为系统节拍周期。
* @retval 成功返回pdTRUE 失败返回pdFALSE
*/
  /* Infinite loop */
  for(;;)
  {
	if(xTaskNotifyWait(0,0xFFFFFFFF,&amp;RcvData,portMAX_DELAY) == pdTRUE){
		printf("成功收到 RcvData = %d\r\n",RcvData);
	}
	

    osDelay(1);
  }
  /* USER CODE END StartTaskReceive */
}</code></pre> 
<h3 id="%C2%A0%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"> <span style="color:#333333;"><strong>软件定时器</strong></span></h3> 
<blockquote> 
 <div> 
  <span style="color:#333333;"><strong>什么是定时器？ </strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;">简单可以理解为闹钟，到达指定一段时间后，就会响铃。 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">STM32 </span> 
  <span style="color:#333333;">芯片自带硬件定时器，精度较高，达到定时时间后会触发中断，也可以生成</span> 
  <span style="color:#333333;"> PWM </span> 
  <span style="color:#333333;">、输入捕获、输出 比较，等等，功能强大，但是由于硬件的限制，个数有限。 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">软件定时器也可以实现定时功能，达到定时时间后可调用回调函数，可以在回调函数里处理信息。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;"><strong>软件定时器优缺点 </strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>优点： </strong>1. 简单、成本低； 2. 只要内存足够，可创建多个； </span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>缺点： </strong>精度较低，容易受中断影响。在大多数情况下够用，但对于精度要求比较高的场合不建议使用。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;"><strong>软件定时器原理 </strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;">定时器是一个可选的、不属于</span> 
  <span style="color:#333333;"> FreeRTOS </span> 
  <span style="color:#333333;">内核的功能，它是由定时器服务任务来提供的。 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">在调用函数</span> 
  <span style="color:#333333;"> </span> 
  <span style="color:#fe2c24;">vTaskStartScheduler() 开启任务调度器的时候，会创建一个用于管理软件定时器的任务</span> 
  <span style="color:#333333;">，这个 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">任务就叫做软件定时器服务任务。 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;">负责</span> 
  <span style="color:#fe2c24;">软件定时器超时的逻辑判断 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">2. </span> 
  <span style="color:#fe2c24;">调用超时软件定时器的超时回调函数 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">3. </span> 
  <span style="color:#fe2c24;">处理软件定时器命令队列 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">FreeRTOS</span> 
  <span style="color:#333333;">提供了很多定时器有关的</span> 
  <span style="color:#333333;">API</span> 
  <span style="color:#333333;">函数，这些</span> 
  <span style="color:#333333;">API</span> 
  <span style="color:#333333;">函数大多都使用</span> 
  <span style="color:#333333;">FreeRTOS</span> 
  <span style="color:#333333;">的队列发送命令给定时器服 务任务。<strong>这个队列叫做定时器命令队列</strong></span> 
  <span style="color:#333333;">。定时器命令队列是提供给</span> 
  <span style="color:#333333;">FreeRTOS</span> 
  <span style="color:#333333;">的软件定时器使用的，</span> 
  <span style="color:#333333;"><strong>用户不 </strong></span> 
  <span style="color:#333333;"><strong>能直接访问</strong></span> 
 </div> 
 <p> </p> 
</blockquote> 
<p><img alt="" height="364" src="https://images2.imgbox.com/c9/69/byLZYlE4_o.png" width="808"> </p> 
<p></p> 
<blockquote> 
 <h4 id="%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span style="color:#333333;"><strong>软件定时器相关配置 </strong></span></h4> 
 <div> 
  <span style="color:#333333;">软件定时器有一个定时器服务任务和定时器命令队列，这两个东西肯定是要配置的，相关的配置也是放到文 件FreeRTOSConfig.h</span> 
  <span style="color:#333333;">中的，涉及到的配置如下： </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">1、</span> 
  <span style="color:#333333;">configUSE_TIMERS </span> 
 </div> 
 <div> 
  <span style="color:#333333;">如果要使用软件定时器的话宏</span> 
  <span style="color:#fe2c24;">configUSE_TIMERS一定要设置为1</span> 
  <span style="color:#333333;">，当设置为</span> 
  <span style="color:#333333;">1</span> 
  <span style="color:#333333;">的话定时器服务任务就会在启 动FreeRTOS</span> 
  <span style="color:#333333;">调度器的时候自动创建。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">2</span> 
  <span style="color:#333333;">、</span> 
  <span style="color:#333333;">configTIMER_TASK_PRIORITY </span> 
 </div> 
 <div> 
  <span style="color:#333333;">设置软件定时器服务</span> 
  <span style="color:#fe2c24;">任务的任务优先级</span> 
  <span style="color:#333333;">，可以为</span> 
  <span style="color:#333333;">0~(configMAX_PRIORITIES-1)</span> 
  <span style="color:#333333;">。优先级一定要根据实际的应 用要求来设置。如果定时器服务任务的优先级设置的高的话，定时器命令队列中的命令和定时器回调函数就 会及时的得到处理。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">3</span> 
  <span style="color:#333333;">、</span> 
  <span style="color:#333333;">configTIMER_QUEUE_LENGTH </span> 
 </div> 
 <div> 
  <span style="color:#333333;">此宏用来设置定时器命令队列的队列长度。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">4</span> 
  <span style="color:#333333;">、</span> 
  <span style="color:#333333;">configTIMER_TASK_STACK_DEPTH </span> 
 </div> 
 <div> 
  <span style="color:#333333;">此宏用来设置定时器服务任务的任务堆栈大小。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;"><strong>单次定时器和周期定时器 </strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>单次定时器： </strong></span> 
  <span style="color:#333333;">只超时一次，调用一次回调函数。可手动再开启定时器； </span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>周期定时器： </strong></span> 
  <span style="color:#333333;">多次超时，多次调用回调函数。 </span> 
 </div> 
</blockquote> 
<h4 id="%C2%A0%E7%9B%B8%E5%85%B3API%E2%80%8B%E7%BC%96%E8%BE%91" style="background-color:transparent;"> 相关API<img alt="" height="560" src="https://images2.imgbox.com/53/c5/m4r6J4wA_o.png" width="853"></h4> 
<p><img alt="" height="602" src="https://images2.imgbox.com/d5/41/DHXpDRV4_o.png" width="996"> </p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/3f/b4/8TQPrTGI_o.png" width="710"></p> 
<p><img alt="" height="677" src="https://images2.imgbox.com/9c/20/G32HGGwK_o.png" width="898"></p> 
<p><img alt="" height="256" src="https://images2.imgbox.com/39/c0/VfhGssjP_o.png" width="839"></p> 
<p><img alt="" height="605" src="https://images2.imgbox.com/d1/99/wbYtoy7q_o.png" width="942"></p> 
<p><img alt="" height="292" src="https://images2.imgbox.com/8e/f4/Tf1oymPA_o.png" width="963"> <img alt="" height="404" src="https://images2.imgbox.com/45/4e/nyTlJEuw_o.png" width="1090"></p> 
<p><img alt="" height="823" src="https://images2.imgbox.com/89/23/wkUCquFI_o.png" width="1041"> </p> 
<p> 工程创建</p> 
<p><img alt="" height="1030" src="https://images2.imgbox.com/93/84/hOgUAyQL_o.png" width="1200"></p> 
<p><img alt="" height="1030" src="https://images2.imgbox.com/ec/75/JAgIc2PJ_o.png" width="1200"> </p> 
<p><img alt="" height="376" src="https://images2.imgbox.com/5e/51/OC6caDme_o.png" width="920"> </p> 
<pre><code class="hljs">//在任务中开启两个定时器，并设置定时时间，必须是时基整数倍
//cubeMX配置好了单次定时器和周期定时器，
//在回调函数中实现功能，不易时间过长

void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* Create the timer(s) */
  /* definition and creation of myTimerPeriodicity */
	//xTimerCreate 创建定时器函数，参数：定时器周期（1s）、类型（周期）、ID	
  osTimerDef(myTimerPeriodicity, CallbackTimerPeriodicity);
  myTimerPeriodicityHandle = osTimerCreate(osTimer(myTimerPeriodicity), osTimerPeriodic, NULL);

  /* definition and creation of myTimerOnce */
	//xTimerCreate 创建定时器函数，参数：定时器周期（1s）、类型（单次）、ID	
  osTimerDef(myTimerOnce, CallbackTimerOnce);
  myTimerOnceHandle = osTimerCreate(osTimer(myTimerOnce), osTimerOnce, NULL);

    //是用于更改 X 窗口系统中的定时器的回调函数 参数：哪个定时器、定时周期、等待时间
//	xTimerChangePeriod(myTimerOnceHandle,pdMS_TO_TICKS(1000),0);
	
  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of TaskTimer */
  osThreadDef(TaskTimer, StartTaskTimer, osPriorityNormal, 0, 128);
  TaskTimerHandle = osThreadCreate(osThread(TaskTimer), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_StartTaskTimer */
/**
  * @brief  Function implementing the TaskTimer thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartTaskTimer */
void StartTaskTimer(void const * argument)
{
  /* USER CODE BEGIN StartTaskTimer */
	//osTimerStart 底层调用xTimerStart
	osTimerStart(myTimerPeriodicityHandle,1000);//在这个任务中启动这个定时器，等待时间2s	
	osTimerStart(myTimerOnceHandle,2000);//在这个任务中启动这个定时器，等待时间1s
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
  }
  /* USER CODE END StartTaskTimer */
}

/* CallbackTimerPeriodicity function */
void CallbackTimerPeriodicity(void const * argument)
{
  /* USER CODE BEGIN CallbackTimerPeriodicity */
	printf("周期模式\r\n");
  /* USER CODE END CallbackTimerPeriodicity */
}

/* CallbackTimerOnce function */
void CallbackTimerOnce(void const * argument)
{
  /* USER CODE BEGIN CallbackTimerOnce */
	printf("单次模式\r\n");
  /* USER CODE END CallbackTimerOnce */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */

</code></pre> 
<h3 id="%C2%A0%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"> 中断管理</h3> 
<p><img alt="" height="862" src="https://images2.imgbox.com/e9/d4/9uQsldnb_o.png" width="1200"></p> 
<p><img alt="" height="757" src="https://images2.imgbox.com/3d/5c/Mz9283fI_o.png" width="1200"> <img alt="" height="327" src="https://images2.imgbox.com/24/5c/x7po0CrQ_o.png" width="862"></p> 
<p><img alt="" height="593" src="https://images2.imgbox.com/aa/ff/UdaSmsXy_o.png" width="1200"> 重写回调函数 </p> 
<p><img alt="" height="851" src="https://images2.imgbox.com/8a/0a/CBt0CnSh_o.png" width="1200"></p> 
<p> </p> 
<pre><code class="hljs">在it.c中通过extern传过来队列指针#include "cmsis_os.h"和extern osMessageQId myQueue01Handle;
按键按下时通过中断函数 中队列发送数据

在rtos任务中通过消息队列来接收数据


#include "cmsis_os.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN TD */

/* USER CODE END TD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */
extern osMessageQId myQueue01Handle;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/* External variables --------------------------------------------------------*/
extern TIM_HandleTypeDef htim2;

/* USER CODE BEGIN EV */

/* USER CODE END EV */

/******************************************************************************/
/*           Cortex-M3 Processor Interruption and Exception Handlers          */
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
  {
  }
  /* USER CODE END NonMaskableInt_IRQn 1 */
}

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_HardFault_IRQn 0 */
    /* USER CODE END W1_HardFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */
    /* USER CODE END W1_MemoryManagement_IRQn 0 */
  }
}

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_BusFault_IRQn 0 */
    /* USER CODE END W1_BusFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_UsageFault_IRQn 0 */
    /* USER CODE END W1_UsageFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
  /* USER CODE BEGIN DebugMonitor_IRQn 0 */

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}

/******************************************************************************/
/* STM32F1xx Peripheral Interrupt Handlers                                    */
/* Add here the Interrupt Handlers for the used peripherals.                  */
/* For the available peripheral interrupt handler names,                      */
/* please refer to the startup file (startup_stm32f1xx.s).                    */
/******************************************************************************/

/**
  * @brief This function handles EXTI line0 interrupt.
  */
void EXTI0_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI0_IRQn 0 */

  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
  /* USER CODE BEGIN EXTI0_IRQn 1 */

  /* USER CODE END EXTI0_IRQn 1 */
}

/**
  * @brief This function handles TIM2 global interrupt.
  */
void TIM2_IRQHandler(void)
{
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&amp;htim2);
  /* USER CODE BEGIN TIM2_IRQn 1 */

  /* USER CODE END TIM2_IRQn 1 */
}

/* USER CODE BEGIN 1 */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	uint8_t QueueSendData = 0x06;
	//按键按下产生按键中断，通过extern传过来队列地址，往这个队列地址中写入数据，
	xQueueSendFromISR(myQueue01Handle,&amp;QueueSendData,NULL);
	
}
/* USER CODE END 1 */
</code></pre> 
<pre><code class="hljs">//rtos
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stdio.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */
osThreadId defaultTaskHandle;
osMessageQId myQueue01Handle;

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */

/* USER CODE END FunctionPrototypes */

void StartDefaultTask(void const * argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* GetIdleTaskMemory prototype (linked to static allocation support) */
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );

/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &amp;xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  /* place for user code */
}
/* USER CODE END GET_IDLE_TASK_MEMORY */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* Create the queue(s) */
  /* definition and creation of myQueue01 */
  osMessageQDef(myQueue01, 16, uint16_t);
  myQueue01Handle = osMessageCreate(osMessageQ(myQueue01), NULL);

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_StartDefaultTask */
/**
  * @brief  Function implementing the defaultTask thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void const * argument)
{
  /* USER CODE BEGIN StartDefaultTask */
	uint8_t Receive;
  /* Infinite loop */
  for(;;)
  {
	  //如果在该任务中接收到这个队列传过来的数据则打印
	  if(xQueueReceiveFromISR(myQueue01Handle,&amp;Receive,NULL) == pdTRUE){
		  printf("RECEIVE:%d\r\n",Receive);
	  }
	  
    osDelay(1);
  }
  /* USER CODE END StartDefaultTask */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */

</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2afdd5283871e935e0448a0dcfa95e91/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【深度学习】使用GPU（CUDA）跑通YOLOv5源码，包含搭建环境&#43;训练数据集&#43;预测（整套流程）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c627e77ffafcf7979091cc3afa70c5a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">彩虹DS6.6免授权版本带后台</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>