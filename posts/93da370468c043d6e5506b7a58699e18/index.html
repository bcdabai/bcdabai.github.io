<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MoM矩量法（三）：激励矩阵以及方程求解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MoM矩量法（三）：激励矩阵以及方程求解" />
<meta property="og:description" content="MoM矩量法（三）：激励矩阵以及方程求解 填充完阻抗矩阵之后就是激励矩阵的填充以及方程的求解了。激励矩阵比较简单，后面矩阵方程的求解也可以采用库函数来完成。
这里采用的公式来自于聂在平主编的《目标与环境 电磁散射特性建模——理论、方法与实现（应用篇）》，所有数据均采用国际标准单位。
完整代码已贴在文章最后。文章和代码思路借鉴了https://blog.csdn.net/u014411646/article/details/99689460，谢谢原作者！ 一、激励矩阵 上式中各符号的含义： E θ θ E_\theta\theta Eθ​θ和 E ϕ ϕ E_\phi\phi Eϕ​ϕ代表 θ \theta θ方向极化电场和 ϕ \phi ϕ方向极化电场，在这里我们只考虑二者其一，而不考虑其他极化方向的入射波。所以，当确定了极化方向时，上式中的 E θ θ &#43; E ϕ ϕ E_\theta\theta&#43;E_\phi\phi Eθ​θ&#43;Eϕ​ϕ只需要保留一个即可； k i k_i ki​为入射方向单位向量；其他变量与MoM矩量法（二）：阻抗矩阵的填充定义的变量一致。 核心代码： cx_vec setVm(rowvec ei) { cx_vec vm(EdgeTotal); for (int i = 0;i &lt; EdgeTotal;i&#43;&#43;) { Complex temp = 0; for (int k = 0;k &lt; 4;k&#43;&#43;) { rowvec rlmk(3); rlmk(0) = xx[k] * pdata(Edge_list(i, 2), 0) &#43; yy[k] * pdata(Edge_list(i, 0), 0) &#43; zz[k] * pdata(Edge_list(i, 1), 0); rlmk(1) = xx[k] * pdata(Edge_list(i, 2), 1) &#43; yy[k] * pdata(Edge_list(i, 0), 1) &#43; zz[k] * pdata(Edge_list(i, 1), 1); rlmk(2) = xx[k] * pdata(Edge_list(i, 2), 2) &#43; yy[k] * pdata(Edge_list(i, 0), 2) &#43; zz[k] * pdata(Edge_list(i, 1), 2); rowvec rrmk(3); rrmk(0) = xx[k] * pdata(Edge_list(i, 3), 0) &#43; yy[k] * pdata(Edge_list(i, 1), 0) &#43; zz[k] * pdata(Edge_list(i, 0), 0); rrmk(1) = xx[k] * pdata(Edge_list(i, 3), 1) &#43; yy[k] * pdata(Edge_list(i, 1), 1) &#43; zz[k] * pdata(Edge_list(i, 0), 1); rrmk(2) = xx[k] * pdata(Edge_list(i, 3), 2) &#43; yy[k] * pdata(Edge_list(i, 1), 2) &#43; zz[k] * pdata(Edge_list(i, 0), 2); temp &#43;= ww[k] * (exp(-J * k0 * getDot(ki, rlmk)) * getDot(ei, rlmk - pdata." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/93da370468c043d6e5506b7a58699e18/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-27T18:00:36+08:00" />
<meta property="article:modified_time" content="2020-07-27T18:00:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MoM矩量法（三）：激励矩阵以及方程求解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="MoM_1"></a>MoM矩量法（三）：激励矩阵以及方程求解</h2> 
<p>填充完阻抗矩阵之后就是激励矩阵的填充以及方程的求解了。激励矩阵比较简单，后面矩阵方程的求解也可以采用库函数来完成。<br> 这里采用的公式来自于聂在平主编的《目标与环境 电磁散射特性建模——理论、方法与实现（应用篇）》，所有数据均采用国际标准单位。</p> 
<h6><a id="httpsblogcsdnnetu014411646articledetails99689460_4"></a>完整代码已贴在文章最后。文章和代码思路借鉴了https://blog.csdn.net/u014411646/article/details/99689460，谢谢原作者！</h6> 
<h3><a id="_5"></a>一、激励矩阵</h3> 
<p><img src="https://images2.imgbox.com/77/de/09xk6h83_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="_8"></a>上式中各符号的含义：</h6> 
<ol><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           E 
          
         
           θ 
          
         
        
          θ 
         
        
       
         E_\theta\theta 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.05764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.02778em;">θ</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           E 
          
         
           ϕ 
          
         
        
          ϕ 
         
        
       
         E_\phi\phi 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.980548em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.05764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϕ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">ϕ</span></span></span></span></span>代表<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          θ 
         
        
       
         \theta 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">θ</span></span></span></span></span>方向极化电场和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ϕ 
         
        
       
         \phi 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span></span>方向极化电场，在这里我们只考虑二者其一，而不考虑其他极化方向的入射波。所以，当确定了极化方向时，上式中的<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           E 
          
         
           θ 
          
         
        
          θ 
         
        
          + 
         
         
         
           E 
          
         
           ϕ 
          
         
        
          ϕ 
         
        
       
         E_\theta\theta+E_\phi\phi 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.05764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.02778em;">θ</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.980548em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.05764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϕ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">ϕ</span></span></span></span></span>只需要保留一个即可；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           k 
          
         
           i 
          
         
        
       
         k_i 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>为入射方向单位向量；</li><li>其他变量与<a href="https://blog.csdn.net/luckytsw/article/details/107553171">MoM矩量法（二）：阻抗矩阵的填充</a>定义的变量一致。</li></ol> 
<h6><a id="_12"></a>核心代码：</h6> 
<pre><code>cx_vec setVm(rowvec ei) {
	cx_vec vm(EdgeTotal);
	for (int i = 0;i &lt; EdgeTotal;i++) {
		Complex temp = 0;
		for (int k = 0;k &lt; 4;k++) {
			rowvec rlmk(3);
			rlmk(0) = xx[k] * pdata(Edge_list(i, 2), 0) + yy[k] * pdata(Edge_list(i, 0), 0) + zz[k] * pdata(Edge_list(i, 1), 0);
			rlmk(1) = xx[k] * pdata(Edge_list(i, 2), 1) + yy[k] * pdata(Edge_list(i, 0), 1) + zz[k] * pdata(Edge_list(i, 1), 1);
			rlmk(2) = xx[k] * pdata(Edge_list(i, 2), 2) + yy[k] * pdata(Edge_list(i, 0), 2) + zz[k] * pdata(Edge_list(i, 1), 2);
			rowvec rrmk(3);
			rrmk(0) = xx[k] * pdata(Edge_list(i, 3), 0) + yy[k] * pdata(Edge_list(i, 1), 0) + zz[k] * pdata(Edge_list(i, 0), 0);
			rrmk(1) = xx[k] * pdata(Edge_list(i, 3), 1) + yy[k] * pdata(Edge_list(i, 1), 1) + zz[k] * pdata(Edge_list(i, 0), 1);
			rrmk(2) = xx[k] * pdata(Edge_list(i, 3), 2) + yy[k] * pdata(Edge_list(i, 1), 2) + zz[k] * pdata(Edge_list(i, 0), 2);
			temp += ww[k] * (exp(-J * k0 * getDot(ki, rlmk)) * getDot(ei, rlmk - pdata.row(Edge_list(i, 2))) -
				exp(-J * k0 * getDot(ki, rrmk)) * getDot(ei, rrmk - pdata.row(Edge_list(i, 3))));
		}
		vm(i) = EdgeLength(i) * temp;
	}
	return vm;
}
</code></pre> 
<p>与前一节描述的阻抗矩阵类似，通过对数据运算将其填充进激励矩阵。之后就是对矩阵方程的求解，从而得到表面电流。</p> 
<h6><a id="_39"></a>核心代码：</h6> 
<pre><code>cx_vec solveMatrix(cx_mat zmn, cx_vec v) {
	int i, j;
	int ii = -1;
	Complex sum;
	for (i = 0;i &lt; EdgeTotal;i++) {
		sum = v(i);
		if (ii &gt; -1) {
			for (j = ii;j &lt;= i - 1;j++) {
				sum -= zmn(i, j) * v(j);
			}
		}
		else if (sum != 0.) {
			ii = i;
		}
		v(i) = sum;
	}
	for (i = EdgeTotal - 1; i &gt;= 0;i--) {
		sum = v(i);
		for (j = i + 1;j &lt; EdgeTotal;j++) {
			sum -= zmn(i, j) * v(j);
		}
		v(i) = sum / zmn(i, i);
	}
	return v;
}
</code></pre> 
<p>需要注意的是，在上述解矩阵方程的函数中，参数<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Z 
        
       
         m 
        
       
         n 
        
       
      
        Zmn 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07153em;">Z</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span></span></span></span></span>需要是上一节经过LU分解的矩阵。</p> 
<h6><a id="_69"></a>下面贴上所有代码：</h6> 
<pre><code>/***********************************************************/
/*              该函数对激励矩阵进行填充                    */
/*                   并求解方程组                          */
/***********************************************************/
/*                                                         */
/*              Author：Tianshaowenwe                      */
/*                                                         */
/***********************************************************/
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;complex&gt;
#include &lt;math.h&gt;
#include &lt;time.h&gt;
#include &lt;windows.h&gt;
#include &lt;cmath&gt;
#include "rwg3.h"
#include "armadillo"

using namespace arma;
using namespace std;

const Complex J = Complex(0, 1);
extern mat Edge_list;//[端点1， 端点2， 对点1， 对点2， 左三角单元， 右三角单元]
extern mat TriCenter;
extern vec EdgeLength;
extern vec TriArea;
extern int TriTotal, EdgeTotal;
extern mat pdata, tdata;
extern double k0;
extern double thi, phi;
extern cx_mat Zmn;
extern int pol;
extern double xx[4];
extern double yy[4];
extern double zz[4];
extern double ww[4];
extern double xxx[7];
extern double yyy[7];
extern double zzz[7];
extern double www[7];

cx_vec I, V;
rowvec ei(3), ki(3);
void rwg3_main() {
	rwg2_main();
	ki(0) = -1. * sin(thi) * cos(phi);
	ki(1) = -1. * sin(thi) * sin(phi);
	ki(2) = -1. * cos(phi);
	if (pol == 0) {
		ei(0) = cos(thi) * cos(phi);
		ei(1) = cos(thi) * sin(phi);
		ei(2) = -1. * sin(thi);
	}
	else {
		ei(0) = -1. * sin(phi);
		ei(1) = cos(phi);
		ei(2) = 0;
	}
	cout &lt;&lt; "\n" &lt;&lt; "填充激励矩阵..." &lt;&lt; endl;
	clock_t start = clock();
	V = setVm(ei);
	clock_t end = clock();
	cout &lt;&lt; "\n" &lt;&lt; "激励矩阵填充时间： " &lt;&lt; (end - start) / 1000.0 &lt;&lt; "s" &lt;&lt; endl;
	/*
	V.save("Vph.txt", raw_ascii);
	*/
	cout &lt;&lt; "\n" &lt;&lt; "求解矩阵方程..." &lt;&lt; endl;
	start = clock();
	I = solveMatrix(Zmn, V);
	end = clock();
	cout &lt;&lt; "\n" &lt;&lt; "矩阵方程求解时间： " &lt;&lt; (end - start) / 1000.0 &lt;&lt; "s" &lt;&lt; endl;
	/*
	I.save("Ith.txt", raw_ascii);
	*/
}
/***********************************************************/
/*            Function：cx_vec setVm()                     */
/***********************************************************/
/* 1.填充激励矩阵                                           */
/***********************************************************/
cx_vec setVm(rowvec ei) {
	cx_vec vm(EdgeTotal);
	for (int i = 0;i &lt; EdgeTotal;i++) {
		Complex temp = 0;
		for (int k = 0;k &lt; 4;k++) {
			rowvec rlmk(3);
			rlmk(0) = xx[k] * pdata(Edge_list(i, 2), 0) + yy[k] * pdata(Edge_list(i, 0), 0) + zz[k] * pdata(Edge_list(i, 1), 0);
			rlmk(1) = xx[k] * pdata(Edge_list(i, 2), 1) + yy[k] * pdata(Edge_list(i, 0), 1) + zz[k] * pdata(Edge_list(i, 1), 1);
			rlmk(2) = xx[k] * pdata(Edge_list(i, 2), 2) + yy[k] * pdata(Edge_list(i, 0), 2) + zz[k] * pdata(Edge_list(i, 1), 2);
			rowvec rrmk(3);
			rrmk(0) = xx[k] * pdata(Edge_list(i, 3), 0) + yy[k] * pdata(Edge_list(i, 1), 0) + zz[k] * pdata(Edge_list(i, 0), 0);
			rrmk(1) = xx[k] * pdata(Edge_list(i, 3), 1) + yy[k] * pdata(Edge_list(i, 1), 1) + zz[k] * pdata(Edge_list(i, 0), 1);
			rrmk(2) = xx[k] * pdata(Edge_list(i, 3), 2) + yy[k] * pdata(Edge_list(i, 1), 2) + zz[k] * pdata(Edge_list(i, 0), 2);
			temp += ww[k] * (exp(-J * k0 * getDot(ki, rlmk)) * getDot(ei, rlmk - pdata.row(Edge_list(i, 2))) -
				exp(-J * k0 * getDot(ki, rrmk)) * getDot(ei, rrmk - pdata.row(Edge_list(i, 3))));
		}
		vm(i) = EdgeLength(i) * temp;
	}
	return vm;
}
/***********************************************************/
/*   Function：cx_vec solveMatrix(cx_mat zmn, cx_vec v)    */
/***********************************************************/
/* 1.求解矩阵方程                                          */
/***********************************************************/
cx_vec solveMatrix(cx_mat zmn, cx_vec v) {
	int i, j;
	int ii = -1;
	Complex sum;
	for (i = 0;i &lt; EdgeTotal;i++) {
		sum = v(i);
		if (ii &gt; -1) {
			for (j = ii;j &lt;= i - 1;j++) {
				sum -= zmn(i, j) * v(j);
			}
		}
		else if (sum != 0.) {
			ii = i;
		}
		v(i) = sum;
	}
	for (i = EdgeTotal - 1; i &gt;= 0;i--) {
		sum = v(i);
		for (j = i + 1;j &lt; EdgeTotal;j++) {
			sum -= zmn(i, j) * v(j);
		}
		v(i) = sum / zmn(i, i);
	}
	return v;
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eec1e39074eea62da23a2f300d8ab131/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTTPS工作原理及报文讲解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b0c67d9a358370c708186b6309485c53/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ssm整合“保姆级”教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>