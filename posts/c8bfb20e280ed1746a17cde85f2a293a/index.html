<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP的三次握手和四次挥手 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TCP的三次握手和四次挥手" />
<meta property="og:description" content="首先，客户端与服务器均处于未连接状态，并且是客户端主动向服务器请求建立连接：
客户端将报文段中的SYN=1，并选择一个seq=x，(即该请求报文的序号为x) 将这个报文发送到服务器。此时，客户端进入同步已发送状态（SYN-SEND）.SYN报文段不能携带数据，但是要消耗掉一个序号。
服务器收到请求报文后，若同意建立连接，则回复报文中，SYN=1,ACK=1，并选择一个seq = y,且报文中确认号为x&#43;1，序号为y .此时服务器进入同步已接收状态（SYN-RCVD）
客户端收到服务器的同步确认后，对服务器发送确认的确认。将ACK=1,确认号为y&#43;1,而报文首部的序号为x&#43;1，将该报文发出后，客户端进入已连接状态（ESTABLISHED）。
服务器收到客户端的确认后，也进入已连接状态。
以上即三次握手
为何使用三次握手机制：
假设如下异常情况：
客户端向服务器发送了第一条请求报文，但是该报文并未在网络中被丢弃，而是长时间阻滞在某处，而客户端收不到服务器确认，以为该报文丢失，于是重新发送该报文，这次的报文成功到达服务器，如果不使用三次握手，则服务器只需对该报文发出确认，就建立了一个连接。而在这个连接建立，并释放后，第一次发送的，阻滞在网络中的报文到达了服务器，服务器以为是客户端又重新发送了一个连接请求（实际上在客户端那里，该连接早已失效），就又向客户端发送一个确认，但客户端认为他没有发送该请求报文，因此不理睬服务器发送的确认，而服务器以为又建立了一个新的连接，于是一直等待A发来数据，造成了服务器资源的浪费，并且会产生安全隐患。因此，若使用三次握手机制，服务器发送了该确认后，收不到客户端的确认，也就知道并没有建立连接，因此不会将资源浪费在这种没有意义的等待上。
TCP连接的释放（四次挥手）
连接的释放较连接的建立复杂。
现假设客户端与服务器均处于连接建立状态，客户端主动断开连接：
1.客户端向服务器发送FIN报文：FIN=1,序号seq=上一个最后传输的字节序号&#43;1=u，发送后，客户端进入FIN-WAIT-1状态。
2.服务器接收到该报文后，发送一个确认报文：令ACK=1，确认序号ack = u&#43;1,自己的报文序号seq=v，发送后，服务器进入CLOSE-WAIT状态。
3.此时TCP连接进入连接半关闭状态，服务器可能还会向客户端发送一些数据。
4.客户端收到来自服务器的确认之后，进入FIN-WAIT-2状态。等待服务器发送连接释放报文。
5.如果服务器已经没有要发送的数据，则释放TCP连接，向客户端发送报文：令FIN=1，ACK=1,确认号ack =u&#43;1，自己的序号seq = w（w可能等于v也可能大于v），服务器进入LAST-ACK状态。
6.客户端收到服务器的连接释放报文后，对该报文发出确认，令ACK=1,确认号ack=w&#43;1，自己的序号seq=u&#43;1，发送此报文后，等待2个msl时间后，进入CLOSED状态。
7.服务器收到客户端的确认后，也进入CLOSED状态并撤销传输控制块。
客户端状态变化：未连接-----&gt;SYN-SEND-----&gt;ESTABLISHED-----&gt;FIN-WAIT-1-----&gt;FIN-WAIT-2-----&gt;TIME-WAIT-----&gt;CLOSED
服务器状态变化：未连接-----&gt;SYN-RCVD-----&gt;ESTABLISHED-----&gt;CLOSE-WAIT-----&gt;LAST-ACK-----&gt;CLOSED
通俗描述3次握手就是
A对B说：我的序号是x，我要向你请求连接；（第一次握手，发送SYN包，然后进入SYN-SEND状态）
B听到之后对A说：我的序号是y，期待你下一句序号是x&#43;1的话（意思就是收到了序号为x的话，即ack=x&#43;1），同意建立连接。（第二次握手，发送ACK-SYN包，然后进入SYN-RCVD状态）
A听到B说同意建立连接之后，对A说：与确认你同意与我连接（ack=y&#43;1,ACK=1,seq=x&#43;1）。（第三次握手，A已进入ESTABLISHED状态）
B听到A的确认之后，也进入ESTABLISHED状态。
描述四次挥手就是：
1.A与B交谈结束之后，A要结束此次会话，对B说：我要关闭连接了（seq=u,FIN=1）。（第一次挥手，A进入FIN-WAIT-1）
2.B收到A的消息后说：确认，你要关闭连接了。（seq=v,ack=u&#43;1,ACK=1）（第二次挥手，B进入CLOSE-WAIT）
3.A收到B的确认后,等了一段时间，因为B可能还有话要对他说。（此时A进入FIN-WAIT-2）
4.B说完了他要说的话（只是可能还有话说）之后，对A说，我要关闭连接了。（seq=w, ack=u&#43;1,FIN=1，ACK=1）(第三次挥手)
5.A收到B要结束连接的消息后说：已收到你要关闭连接的消息。（seq=u&#43;1,ack=w&#43;1,ACK=1）(第四次挥手，然后A进入CLOSED)
6.B收到A的确认后，也进入CLOSED。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c8bfb20e280ed1746a17cde85f2a293a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-14T15:01:39+08:00" />
<meta property="article:modified_time" content="2019-05-14T15:01:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP的三次握手和四次挥手</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>首先，客户端与服务器均处于未连接状态，并且是客户端主动向服务器请求建立连接：</p> 
<p>客户端将报文段中的SYN=1，并选择一个seq=x，(即该请求报文的序号为x)  将这个报文发送到服务器。此时，客户端进入同步已发送状态（SYN-SEND）.SYN报文段不能携带数据，但是要消耗掉一个序号。<br> 服务器收到请求报文后，若同意建立连接，则回复报文中，SYN=1,ACK=1，并选择一个seq = y,且报文中确认号为x+1，序号为y   .此时服务器进入同步已接收状态（SYN-RCVD）</p> 
<p>客户端收到服务器的同步确认后，对服务器发送确认的确认。将ACK=1,确认号为y+1,而报文首部的序号为x+1，将该报文发出后，客户端进入已连接状态（ESTABLISHED）。</p> 
<p>服务器收到客户端的确认后，也进入已连接状态。<br> 以上即三次握手</p> 
<p>为何使用三次握手机制：<br> 假设如下异常情况：<br> 客户端向服务器发送了第一条请求报文，但是该报文并未在网络中被丢弃，而是长时间阻滞在某处，而客户端收不到服务器确认，以为该报文丢失，于是重新发送该报文，这次的报文成功到达服务器，如果不使用三次握手，则服务器只需对该报文发出确认，就建立了一个连接。而在这个连接建立，并释放后，第一次发送的，阻滞在网络中的报文到达了服务器，服务器以为是客户端又重新发送了一个连接请求（实际上在客户端那里，该连接早已失效），就又向客户端发送一个确认，但客户端认为他没有发送该请求报文，因此不理睬服务器发送的确认，而服务器以为又建立了一个新的连接，于是一直等待A发来数据，造成了服务器资源的浪费，并且会产生安全隐患。因此，若使用三次握手机制，服务器发送了该确认后，收不到客户端的确认，也就知道并没有建立连接，因此不会将资源浪费在这种没有意义的等待上。</p> 
<p>TCP连接的释放（四次挥手）</p> 
<p>连接的释放较连接的建立复杂。</p> 
<p>现假设客户端与服务器均处于连接建立状态，客户端主动断开连接：</p> 
<p>1.客户端向服务器发送FIN报文：FIN=1,序号seq=上一个最后传输的字节序号+1=u，发送后，客户端进入FIN-WAIT-1状态。</p> 
<p>2.服务器接收到该报文后，发送一个确认报文：令ACK=1，确认序号ack = u+1,自己的报文序号seq=v，发送后，服务器进入CLOSE-WAIT状态。</p> 
<p>3.此时TCP连接进入连接半关闭状态，服务器可能还会向客户端发送一些数据。</p> 
<p>4.客户端收到来自服务器的确认之后，进入FIN-WAIT-2状态。等待服务器发送连接释放报文。</p> 
<p>5.如果服务器已经没有要发送的数据，则释放TCP连接，向客户端发送报文：令FIN=1，ACK=1,确认号ack =u+1，自己的序号seq = w（w可能等于v也可能大于v），服务器进入LAST-ACK状态。</p> 
<p>6.客户端收到服务器的连接释放报文后，对该报文发出确认，令ACK=1,确认号ack=w+1，自己的序号seq=u+1，发送此报文后，等待2个msl时间后，进入CLOSED状态。</p> 
<p>7.服务器收到客户端的确认后，也进入CLOSED状态并撤销传输控制块。</p> 
<p>客户端状态变化：未连接-----&gt;SYN-SEND-----&gt;ESTABLISHED-----&gt;FIN-WAIT-1-----&gt;FIN-WAIT-2-----&gt;TIME-WAIT-----&gt;CLOSED</p> 
<p>服务器状态变化：未连接-----&gt;SYN-RCVD-----&gt;ESTABLISHED-----&gt;CLOSE-WAIT-----&gt;LAST-ACK-----&gt;CLOSED</p> 
<p>通俗描述3次握手就是</p> 
<p>A对B说：我的序号是x，我要向你请求连接；（第一次握手，发送SYN包，然后进入SYN-SEND状态）</p> 
<p>B听到之后对A说：我的序号是y，期待你下一句序号是x+1的话（意思就是收到了序号为x的话，即ack=x+1），同意建立连接。（第二次握手，发送ACK-SYN包，然后进入SYN-RCVD状态）</p> 
<p>A听到B说同意建立连接之后，对A说：与确认你同意与我连接（ack=y+1,ACK=1,seq=x+1）。（第三次握手，A已进入ESTABLISHED状态）</p> 
<p>B听到A的确认之后，也进入ESTABLISHED状态。</p> 
<p>描述四次挥手就是：</p> 
<p>1.A与B交谈结束之后，A要结束此次会话，对B说：我要关闭连接了（seq=u,FIN=1）。（第一次挥手，A进入FIN-WAIT-1）</p> 
<p>2.B收到A的消息后说：确认，你要关闭连接了。（seq=v,ack=u+1,ACK=1）（第二次挥手，B进入CLOSE-WAIT）</p> 
<p>3.A收到B的确认后,等了一段时间，因为B可能还有话要对他说。（此时A进入FIN-WAIT-2）</p> 
<p>4.B说完了他要说的话（只是可能还有话说）之后，对A说，我要关闭连接了。（seq=w, ack=u+1,FIN=1，ACK=1）(第三次挥手)<br> 5.A收到B要结束连接的消息后说：已收到你要关闭连接的消息。（seq=u+1,ack=w+1,ACK=1）(第四次挥手，然后A进入CLOSED)<br> 6.B收到A的确认后，也进入CLOSED。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3633862556d8fe9843b377dc80e839ce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mac使用Charles进行HTTPS抓包</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b56afe117448bd538a6f47e7b4b70d12/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">影响linux服务器性能的因素</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>