<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JTS-Java图形拓扑学习笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JTS-Java图形拓扑学习笔记" />
<meta property="og:description" content="简介
JTS由加拿大的VividSolutions公司开发，是一个用Java语言描述的几何拓扑套件，遵循OpenGIS的Simple Feature Specification，封装了2D几何类型和非常多的空间分析操作，而且包含了不少常见的计算几何算法实现。
JTS被广泛地应用在开源GIS软件中，作为GeoTools和基于GeoTools的GeoServer和uDig的底层库。
JTS官方文档
WKT 在线查看工具
Maven 依赖
&lt;dependency&gt;
&lt;groupId&gt;com.vividsolutions&lt;/groupId&gt;
&lt;artifactId&gt;jts&lt;/artifactId&gt;
&lt;version&gt;1.13&lt;/version&gt;
&lt;/dependency&gt;
1
2
3
4
5
几何模型
Point 点
Coordinate coord = new Coordinate(102.6806945800781 24.999259605696068);
Point point = new GeometryFactory().createPoint( coord );
1
2
或
WKTReader reader = new WKTReader(new GeometryFactory());
Point point = (Point)reader.read(&#34;POINT(102.6806945800781 24.999259605696068)&#34;);
1
2
MultiPoint 多点
WKTReader reader = new WKTReader(new GeometryFactory());
MultiPoint mpoint = (MultiPoint)reader.read(&#34;MULTIPOINT((102.6806945800781 24.999259605696068),(102.6811065673828 24.99851282550918))&#34;);
1
2
LineString 线" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f93e3ab4761998657dce34af1817ed02/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-07T11:10:54+08:00" />
<meta property="article:modified_time" content="2023-07-07T11:10:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JTS-Java图形拓扑学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>简介<br> JTS由加拿大的VividSolutions公司开发，是一个用Java语言描述的几何拓扑套件，遵循OpenGIS的Simple Feature Specification，封装了2D几何类型和非常多的空间分析操作，而且包含了不少常见的计算几何算法实现。<br> JTS被广泛地应用在开源GIS软件中，作为GeoTools和基于GeoTools的GeoServer和uDig的底层库。</p> 
<p>JTS官方文档<br> WKT 在线查看工具</p> 
<p>Maven 依赖</p> 
<p>&lt;dependency&gt;<br>    &lt;groupId&gt;com.vividsolutions&lt;/groupId&gt;<br>    &lt;artifactId&gt;jts&lt;/artifactId&gt;<br>    &lt;version&gt;1.13&lt;/version&gt;<br> &lt;/dependency&gt;<br> 1<br> 2<br> 3<br> 4<br> 5<br> 几何模型<br> Point 点</p> 
<p><br> Coordinate coord = new Coordinate(102.6806945800781 24.999259605696068);<br> Point point = new GeometryFactory().createPoint( coord );<br> 1<br> 2<br> 或</p> 
<p>WKTReader reader = new WKTReader(new GeometryFactory());<br> Point point = (Point)reader.read("POINT(102.6806945800781 24.999259605696068)");<br> 1<br> 2<br> MultiPoint 多点</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> MultiPoint mpoint = (MultiPoint)reader.read("MULTIPOINT((102.6806945800781 24.999259605696068),(102.6811065673828 24.99851282550918))");<br> 1<br> 2<br> LineString 线</p> 
<p><br> Coordinate[] coords  = new Coordinate[]{new Coordinate(102.67990493826801, 24.999349063221004), new Coordinate(102.68184471235142, 24.9966108454865)};<br> LineString line = new GeometryFactory().createLineString(coords);<br> 1<br> 2<br> 或</p> 
<p>WKTReader reader = new WKTReader(new GeometryFactory());<br> LineString line = (LineString)reader.read("LINESTRING(102.67990493826801 24.999349063221004,102.68184471235142 24.9966108454865)");<br> 1<br> 2<br> MultiLineString 多线</p> 
<p><br> GeometryFactory geometryFactory = new GeometryFactory();<br> Coordinate[] coords1  = new Coordinate[] {new Coordinate(102.67990493826801, 24.999349063221004), new Coordinate(102.68184471235142, 24.9966108454865)};<br> LineString line1 = geometryFactory.createLineString(coords1);<br> Coordinate[] coords2  = new Coordinate[] {new Coordinate(102.68017959647113, 24.999504642938945), new Coordinate(102.68335533194477,24.997575452644412)};<br> LineString line2 = geometryFactory.createLineString(coords2);<br> LineString[] lineStrings = new LineString[2];<br> lineStrings[0]= line1;<br> lineStrings[1] = line2;<br> MultiLineString ms = geometryFactory.createMultiLineString(lineStrings);<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 或</p> 
<p>WKTReader reader = new WKTReader(new GeometryFactory());<br> MultiLineString line = (MultiLineString)reader.read("MULTILINESTRING((102.67990493826801 24.999349063221004,102.68184471235142 24.9966108454865),(102.68017959647113 24.999504642938945,102.68335533194477 24.997575452644412))");<br> 1<br> 2<br> Polygon 面</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon = (Polygon)reader.read("POLYGON((102.68002510070801 24.99920904358541,102.68057441790008 24.99844670247988,102.68141555759941 24.99892900051202,102.68071174621583 24.999675779831406,102.68002510070801 24.99920904358541))");<br> 1<br> 2<br> MultiPolygon 多面</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> MultiPolygon mpolygon = (MultiPolygon) reader.read("MULTIPOLYGON(((40 10, 30 0, 40 10, 30 20, 40 10),(30 10, 30 0, 40 10, 30 20, 30 10)))");<br> 1<br> 2<br> GeometryCollection 几何集合</p> 
<p><br> GeometryFactory geometryFactory = new GeometryFactory();<br> LineString line = (LineString)reader.read("LINESTRING(102.67990493826801 24.999349063221004,102.68184471235142 24.9966108454865)");<br> Polygon polygon = (Polygon)reader.read("POLYGON((102.68002510070801 24.99920904358541,102.68057441790008 24.99844670247988,102.68141555759941 24.99892900051202,102.68071174621583 24.999675779831406,102.68002510070801 24.99920904358541))");<br> Geometry g1 = geometryFactory.createGeometry(line);<br> Geometry g2 = geometryFactory.createGeometry(polygon);<br> GeometryCollection gc = geometryFactory.createGeometryCollection(new Geometry[]{g1,g2});<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> Circle 圆</p> 
<p><br>     /**<br>      * create a Circle  创建一个圆，圆心(x,y) 半径RADIUS<br>      * @param x<br>      * @param y<br>      * @param RADIUS<br>      * @return<br>      */<br>     public Polygon createCircle(double x, double y, final double RADIUS){<!-- --><br>         GeometryFactory geometryFactory = new GeometryFactory();<br>         final int SIDES = 32;//圆上面的点个数<br>         Coordinate coords[] = new Coordinate[SIDES+1];<br>         for( int i = 0; i &lt; SIDES; i++){<!-- --><br>             double angle = ((double) i / (double) SIDES) * Math.PI * 2.0;<br>             double dx = Math.cos( angle ) * RADIUS;<br>             double dy = Math.sin( angle ) * RADIUS;<br>             coords[i] = new Coordinate( (double) x + dx, (double) y + dy );<br>         }<br>         coords[SIDES] = coords[0];<br>         LinearRing ring = geometryFactory.createLinearRing( coords );<br>         Polygon polygon = geometryFactory.createPolygon( ring, null );<br>         return polygon;<br>     }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 几何操作<br> 拓扑有效性检查<br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon = (Polygon)reader.read("POLYGON((102.68002510070801 24.99920904358541,102.68057441790008 24.99844670247988,102.68141555759941 24.99892900051202,102.68071174621583 24.999675779831406,102.68002510070801 24.99920904358541))");<br> boolean valid = polygon.isValid();<br> System.out.println("valid: " + valid);<br> 1<br> 2<br> 3<br> 4<br> 面积计算<br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon = (Polygon)reader.read("POLYGON((102.68002510070801 24.99920904358541,102.68057441790008 24.99844670247988,102.68141555759941 24.99892900051202,102.68071174621583 24.999675779831406,102.68002510070801 24.99920904358541))");<br> double area = polygon.getArea();<br> 1<br> 2<br> 3<br> 长度/周长计算<br> WKTReader reader = new WKTReader(new GeometryFactory());<br> LineString line = (LineString)reader.read("LINESTRING(102.67990493826801 24.999349063221004,102.68184471235142 24.9966108454865)");<br> double length = line.getLength();<br> 1<br> 2<br> 3<br> 或</p> 
<p>WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon = (Polygon)reader.read("POLYGON((102.68002510070801 24.99920904358541,102.68057441790008 24.99844670247988,102.68141555759941 24.99892900051202,102.68071174621583 24.999675779831406,102.68002510070801 24.99920904358541))");<br> double length = polygon.getLength();<br> 1<br> 2<br> 3<br> 距离计算</p> 
<p><br> 几何之间的距离<br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.6797633172391 24.999400600015505,102.68005084991454 24.99904665764305,102.68069887187445 24.99930336322602,102.68021821982254 24.999626189041066,102.6797633172391 24.999400600015505))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.68460845934166 24.99876272521388,102.68482732785922 24.998509908088764,102.68520498301947 24.998778283233165,102.68496894862618 24.998968867993526,102.68460845934166 24.99876272521388))");<br> double distance = polygon1.distance(polygon2); // 0.003946791560736727<br> 1<br> 2<br> 3<br> 4<br> 几何之间的距离是否在指定范围内<br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.6797633172391 24.999400600015505,102.68005084991454 24.99904665764305,102.68069887187445 24.99930336322602,102.68021821982254 24.999626189041066,102.6797633172391 24.999400600015505))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.68460845934166 24.99876272521388,102.68482732785922 24.998509908088764,102.68520498301947 24.998778283233165,102.68496894862618 24.998968867993526,102.68460845934166 24.99876272521388))");<br> double distance = polygon1.distance(polygon2); // 0.003946791560736727<br> boolean withinDistance = polygon1.isWithinDistance(polygon2, 0.00395); // true<br> 1<br> 2<br> 3<br> 4<br> 5<br> 空间关系<br> contains 包含</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.6804885866877 24.999426853935475,102.68218803458147 24.996984242282693,102.6862392441253 24.999426853935475,102.68407630972796 25.0016204947501,102.6804885866877 24.999426853935475))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.68181037876637 24.999302390976425,102.68265151977538 24.998088869480398,102.68426513829034 24.998866769330263,102.68316650390624 25.00009583951264,102.68181037876637 24.999302390976425))");<br> boolean contains = polygon1.contains(polygon2); // true<br> 1<br> 2<br> 3<br> 4<br> within 内含</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.6804885866877 24.999426853935475,102.68218803458147 24.996984242282693,102.6862392441253 24.999426853935475,102.68407630972796 25.0016204947501,102.6804885866877 24.999426853935475))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.68181037876637 24.999302390976425,102.68265151977538 24.998088869480398,102.68426513829034 24.998866769330263,102.68316650390624 25.00009583951264,102.68181037876637 24.999302390976425))");<br> boolean within = polygon2.within(polygon1); // true<br> 1<br> 2<br> 3<br> 4<br> covers 覆盖</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.6804885866877 24.999426853935475,102.68218803458147 24.996984242282693,102.6862392441253 24.999426853935475,102.68407630972796 25.0016204947501,102.6804885866877 24.999426853935475))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.68181037876637 24.999302390976425,102.68265151977538 24.998088869480398,102.68426513829034 24.998866769330263,102.68316650390624 25.00009583951264,102.68181037876637 24.999302390976425))");<br> boolean contains = polygon1.contains(polygon2); // true<br> 1<br> 2<br> 3<br> 4<br> coveredBy 被掩盖</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.6804885866877 24.999426853935475,102.68218803458147 24.996984242282693,102.6862392441253 24.999426853935475,102.68407630972796 25.0016204947501,102.6804885866877 24.999426853935475))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.68181037876637 24.999302390976425,102.68265151977538 24.998088869480398,102.68426513829034 24.998866769330263,102.68316650390624 25.00009583951264,102.68181037876637 24.999302390976425))");<br> boolean coveredBy = polygon2.coveredBy(polygon1); // true<br> 1<br> 2<br> 3<br> 4<br> intersects 相交</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.6800594337692 24.999333506401584,102.68167304966484 24.9970931497745,102.6822910316696 24.99741987072126,102.68047142002617 24.999582432724026,102.6800594337692 24.999333506401584))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.67961311314139 24.998508934467893,102.6800594337692 24.997871055927746,102.68199920654297 24.998897883678765,102.68134689409635 24.999566874509824,102.67961311314139 24.998508934467893))");<br> boolean intersects = polygon1.intersects(polygon2); // true<br> 1<br> 2<br> 3<br> 4<br> disjoint 脱节（不相交）</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.68004226658377 24.999489085070962,102.68153572134909 24.99757545240702,102.68210220310722 24.997995519624396,102.68066024858854 24.999738011078236,102.68004226658377 24.999489085070962))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.68148422241212 25.00015807208976,102.68198204066721 24.999489085070962,102.68464279331965 25.00098263176963,102.68387031712336 25.001573822062696,102.68148422241212 25.00015807208976))");<br> boolean disjoint = polygon1.disjoint(polygon2); // true<br> 1<br> 2<br> 3<br> 4<br> crosses 交叉</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> LineString line1 = (LineString)reader.read("LINESTRING(102.68007659964496 24.999442411573924,102.68392181344099 24.9978243822909)");<br> LineString line2 = (LineString)reader.read("LINESTRING(102.68076324515278 25.00000249414873,102.68273735098774 24.997310964706003)");<br> boolean crosses = line1.crosses(line2); // true<br> 1<br> 2<br> 3<br> 4<br> overlaps 重叠</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.67993927001955 24.99931794744367,102.6806774144643 24.99833779773074,102.68199920654297 24.999022348115815,102.6811065679067 24.99995582025325,102.67993927001955 24.99931794744367))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.68047142002615 24.998384470460365,102.68235969517264 24.99933350628288,102.68282318167621 24.998648957631303,102.68095207240549 24.9978088238541,102.68047142002615 24.998384470460365))");<br> boolean overlaps = polygon1.overlaps(polygon2); // true<br> 1<br> 2<br> 3<br> 4<br> touches 接触</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((1 0,6 0,6 5,1 5,1 0))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((6 0,6 1,7 1,7 0,6 0))");<br> boolean touches = polygon1.touches(polygon2); // true<br> 1<br> 2<br> 3<br> 4<br> equals 等于</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.68002510070801 24.99920904358541,102.68057441790008 24.99844670247988,102.68141555759941 24.99892900051202,102.68071174621583 24.999675779831406,102.68002510070801 24.99920904358541))");<br> boolean equals = polygon1.equals(polygon1); // true<br> 1<br> 2<br> 3<br> relate 关系<br> 测试两个几何体是否与 DE-9IM表达式（官方文档） 中的关系一致。</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.6800594337692 24.999333506401584,102.68167304966484 24.9970931497745,102.6822910316696 24.99741987072126,102.68047142002617 24.999582432724026,102.6800594337692 24.999333506401584))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.67961311314139 24.998508934467893,102.6800594337692 24.997871055927746,102.68199920654297 24.998897883678765,102.68134689409635 24.999566874509824,102.67961311314139 24.998508934467893))");<br> boolean relate = polygon1.relate(polygon2, "T*T***T**"); // true<br> 1<br> 2<br> 3<br> 4<br> 空间分析<br> intersection 交叉分析</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.67981910705566 24.999370456440957,102.68139839250942 24.99718455412153,102.68242836077113 24.997830216333284,102.68060016684466 24.999860529046316,102.67981910705566 24.999370456440957))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.67986202239989 24.999043740680463,102.68028259355924 24.99845253791706,102.68199920732876 24.999292666996425,102.6815443044179 25.00003166473097,102.67986202239989 24.999043740680463))");<br> Geometry intersection = polygon1.intersection(polygon2);<br> 1<br> 2<br> 3<br> 4</p> 
<p><br> difference 差异分析<br> ,</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.67981910705566 24.999370456440957,102.68139839250942 24.99718455412153,102.68242836077113 24.997830216333284,102.68060016684466 24.999860529046316,102.67981910705566 24.999370456440957))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.67986202239989 24.999043740680463,102.68028259355924 24.99845253791706,102.68199920732876 24.999292666996425,102.6815443044179 25.00003166473097,102.67986202239989 24.999043740680463))");<br> Geometry difference = polygon1.difference(polygon2);<br> 1<br> 2<br> 3<br> 4</p> 
<p><br> union 联合分析</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.67981910705566 24.999370456440957,102.68139839250942 24.99718455412153,102.68242836077113 24.997830216333284,102.68060016684466 24.999860529046316,102.67981910705566 24.999370456440957))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.67986202239989 24.999043740680463,102.68028259355924 24.99845253791706,102.68199920732876 24.999292666996425,102.6815443044179 25.00003166473097,102.67986202239989 24.999043740680463))");<br> Geometry union = polygon1.union(polygon2);<br> 1<br> 2<br> 3<br> 4</p> 
<p><br> symmetric difference 对称差异分析</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.67981910705566 24.999370456440957,102.68139839250942 24.99718455412153,102.68242836077113 24.997830216333284,102.68060016684466 24.999860529046316,102.67981910705566 24.999370456440957))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.67986202239989 24.999043740680463,102.68028259355924 24.99845253791706,102.68199920732876 24.999292666996425,102.6815443044179 25.00003166473097,102.67986202239989 24.999043740680463))");<br> Geometry symDifference = polygon1.symDifference(polygon2);<br> 1<br> 2<br> 3<br> 4</p> 
<p><br> Buffer 缓冲区分析</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.67981910705566 24.999370456440957,102.68139839250942 24.99718455412153,102.68242836077113 24.997830216333284,102.68060016684466 24.999860529046316,102.67981910705566 24.999370456440957))");<br> Geometry buffer = polygon1.buffer(0.0005);</p> 
<p>1<br> 2<br> 3<br> 4</p> 
<p><br> Convex hull 凸包分析</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> MultiPoint multiPoint = (MultiPoint)reader.read("MULTIPOINT((102.6818618774414 24.999333506639005),(102.68241119463345 24.998571167492628),(102.68380165152485 24.998446703666872),(102.68666839599608 25.00062480449344),(102.68536377110284 25.00120043909439),(102.68320083670551 25.000095840462194))");<br> Geometry convexHull = multiPoint.convexHull();<br> 1<br> 2<br> 3</p> 
<p><br> 精度操作<br> 精度模型<br> 精度模型是数值计算的核心，JTS适用于默认的双精度模型。当使用较大的值时，Java中内置的数学并不是非常精确，可以通过配置 GeometryFactory 的 PrecisionModel 使用不同的精度。<br> 通过显式捕获PrecisionModel JTS中的”round-off”过程，JTS允许管理这类错误，并对工作的速度和准确性进行适当的权衡。Round-off(例如 ：6.0000001)经常发生即使是双精度模型。尤其是你的工作坐标系数字很大并且离着原点很远。这里面其实也是根据需要，如果你的使用精度要求不那么高那么可以减小精度模型。</p> 
<p>精度操作（降低精度）<br> 精度模型常量：</p> 
<p>FIXED 固定精度表示坐标有固定的小数位数，小数点的位数由比例因子的对数10决定；<br> FLOATING 浮动精度对应于标准的Java双精度浮点表示，它是基于IEEE-754标准的；<br> FLOATING_SINGLE 浮动单精度对应于标准的Java单精度浮点表示，它是基于IEEE-754标准的。<br> PrecisionModel precisionModel = new PrecisionModel(PrecisionModel.FLOATING_SINGLE);<br> WKTReader reader = new WKTReader(new GeometryFactory(precisionModel));<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.67981910705566 24.999370456440957,102.68139839250942 24.99718455412153,102.68242836077113 24.997830216333284,102.68060016684466 24.999860529046316,102.67981910705566 24.999370456440957))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.67986202239989 24.999043740680463,102.68028259355924 24.99845253791706,102.68199920732876 24.999292666996425,102.6815443044179 25.00003166473097,102.67986202239989 24.999043740680463))");<br> Geometry intersection = polygon1.intersection(polygon2);<br> System.out.println(intersection.toText());</p> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 使用 precisionModel 前:</p> 
<p>POLYGON ((102.6804301249854 24.998524741369838, 102.67999762227275 24.99912337202302, 102.68082593508016 24.999609800656877, 102.68138303750645 24.99899110691649, 102.6804301249854 24.998524741369838))<br> 1<br> 使用 precisionModel 后:</p> 
<p>POLYGON ((102.680428 24.998524, 102.679993 24.999123, 102.680824 24.999611, 102.681381 24.998991, 102.680428 24.998524))<br> 1<br> 几何结构<br> Delaunay三角剖分<br> 从点的集合中创建三角剖分，并提取产生的三角形边缘 / 三角形作为几何图形。</p> 
<p><br> GeometryFactory geometryFactory = new GeometryFactory();<br> WKTReader reader = new WKTReader(geometryFactory);<br> MultiPoint multiPoint = (MultiPoint)reader.read("MULTIPOINT((102.68194556236264 24.99925377243376), (102.6823854446411 24.998563388737196), (102.68381237983702 24.998495322528882), (102.68659114837645 25.000615081033544), (102.68534660339354 25.00118877085464))");</p> 
<p>DelaunayTriangulationBuilder builder = new DelaunayTriangulationBuilder();<br> builder.setSites(multiPoint);</p> 
<p>// 实际为GeometryCollection（组成的geometry紧密相连）<br> Geometry geometry = builder.getTriangles(geometryFactory);<br> System.out.println(geometry.toText());</p> 
<p>// 以0的距离进行缓冲（因为各多边形两两共边），生成一个多边形<br> // 此时则将点云构造成了多边形<br> Geometry buffer = geometry.buffer(0);<br> System.out.println(buffer.toText());<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15</p> 
<p>限定Delaunay三角剖分<br> 从点的集合和线性约束中创建限定三角剖分，并提取产生的三角形边缘 / 三角形作为几何图形。</p> 
<p><br> GeometryFactory geometryFactory = new GeometryFactory();<br> WKTReader reader = new WKTReader(geometryFactory);<br> MultiPoint multiPoint = (MultiPoint)reader.read("MULTIPOINT((102.68194556236264 24.99925377243376), (102.6823854446411 24.998563388737196), (102.68381237983702 24.998495322528882), (102.68659114837645 25.000615081033544), (102.68534660339354 25.00118877085464))");</p> 
<p>ConformingDelaunayTriangulationBuilder builder = new ConformingDelaunayTriangulationBuilder();<br> builder.setSites(multiPoint);</p> 
<p>// 实际为GeometryCollection（组成的geometry紧密相连）<br> Geometry geometry = builder.getTriangles(geometryFactory);<br> System.out.println(geometry.toText());</p> 
<p>// 以0的距离进行缓冲（因为各多边形两两共边），生成一个多边形<br> // 此时则将点云构造成了多边形<br> Geometry buffer = geometry.buffer(0);<br> System.out.println(buffer.toText());</p> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16</p> 
<p>泰森多边形图<br> 泰森多边形（Voronoi diagram），是由荷兰气候学家A?H?Thiessen提出了一种根据离散分布的气象站的降雨量来计算平均降雨量的方法，即将所有相邻气象站连成三角形，作这些三角形各边的垂直平分线，于是每个气象站周围的若干垂直平分线便围成一个多边形。用这个多边形内所包含的一个唯一气象站的降雨强度来表示这个多边形区域内的降雨强度，并称这个多边形为泰森多边形。</p> 
<p>从几何角度来看，两基站的分界线是两点之间连线的铅直等分线，将全平面分为两个半平面，各半平面中任何一点与本半平面内基站的间隔都要比到另一基站间隔小。当基站数量在二个以上时，全平面会划分为多个包罗一个基站的区域，区域中任何一点都与本区域内基站间隔最近，是以这些个区域可以看作是基站的覆盖区域，我们将这种由多个点将平面划分成的图称为泰森多边形，又称为Voronoi 图。</p> 
<p>泰森多边形的特性是：</p> 
<p>每个泰森多边形内仅含有一个基站；<br> 泰森多边形区域内的点到相应基站的距离最近；<br> 位于泰森多边形边上的点到其两边的基站的距离相等。</p> 
<p>GeometryFactory geometryFactory = new GeometryFactory();<br> WKTReader reader = new WKTReader(geometryFactory);<br> MultiPoint multiPoint = (MultiPoint)reader.read("MULTIPOINT((102.68194556236264 24.99925377243376), (102.6823854446411 24.998563388737196), (102.68381237983702 24.998495322528882), (102.68659114837645 25.000615081033544), (102.68534660339354 25.00118877085464))");</p> 
<p>VoronoiDiagramBuilder builder = new VoronoiDiagramBuilder();<br> builder.setSites(multiPoint);</p> 
<p>Geometry geometry = builder.getDiagram(geometryFactory);<br> System.out.println(geometry.toText());</p> 
<p>Geometry buffer = geometry.buffer(0);<br> System.out.println(buffer.toText());<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12</p> 
<p>最小可穿过圆的直径<br> 最小直径</p> 
<p>最小封闭矩形</p> 
<p><br> GeometryFactory geometryFactory = new GeometryFactory();<br> WKTReader reader = new WKTReader(geometryFactory);<br> Polygon multiPoint = (Polygon)reader.read("POLYGON((102.68198847770691 24.99927321980566,102.68244981765747 24.99862173117144,102.68380165100098 24.99857311247817,102.68649458885193 25.000624804612144,102.68589377403259 25.000935958721215,102.68534660339357 25.001091535480285,102.68315792083742 25.000012217657115,102.68198847770691 24.99927321980566))");</p> 
<p>MinimumDiameter diameter = new MinimumDiameter(multiPoint);<br> System.out.println(diameter.getLength());</p> 
<p>Geometry geometry = diameter.getMinimumRectangle();<br> System.out.println(geometry.toText());<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9</p> 
<p><br> 最小边界圆</p> 
<p><br> GeometryFactory geometryFactory = new GeometryFactory();<br> WKTReader reader = new WKTReader(geometryFactory);<br> Polygon multiPoint = (Polygon)reader.read("POLYGON((102.68198847770691 24.99927321980566,102.68244981765747 24.99862173117144,102.68380165100098 24.99857311247817,102.68649458885193 25.000624804612144,102.68589377403259 25.000935958721215,102.68534660339357 25.001091535480285,102.68315792083742 25.000012217657115,102.68198847770691 24.99927321980566))");</p> 
<p>MinimumBoundingCircle diameter = new MinimumBoundingCircle(multiPoint);<br> System.out.println(diameter.getRadius());</p> 
<p>Geometry geometry = diameter.getCircle();<br> System.out.println(geometry.toText());</p> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10</p> 
<p><br> 度量函数<br> 距离</p> 
<p><br> GeometryFactory geometryFactory = new GeometryFactory();<br> WKTReader reader = new WKTReader(geometryFactory);</p> 
<p>Polygon multiPoint1 = (Polygon)reader.read("POLYGON((102.68017530441283 24.999487140693418,102.68065810203551 24.99887454806651,102.68160223960875 24.999312114540217,102.68085122108458 24.999924704985673,102.68017530441283 24.999487140693418))");<br> Polygon multiPoint2 = (Polygon)reader.read("POLYGON((102.68351197242735 25.001859692840426,102.68454194068907 25.00097485292946,102.68358707427979 25.0004692272621,102.68273949623106 25.00131517672628,102.68351197242735 25.001859692840426))");</p> 
<p>DistanceOp distance = new DistanceOp(multiPoint1, multiPoint2);<br> System.out.println(distance.distance());// 0.002221128437310254</p> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 豪斯多夫距离<br> 豪斯多夫距离量度度量空间中真子集之间的距离。Hausdorff距离是另一种可以应用在边缘匹配算法的距离，它能够解决SED方法不能解决遮挡的问题。</p> 
<p><br> GeometryFactory geometryFactory = new GeometryFactory();<br> WKTReader reader = new WKTReader(geometryFactory);</p> 
<p>Polygon multiPoint1 = (Polygon)reader.read("POLYGON((102.68017530441283 24.999487140693418,102.68065810203551 24.99887454806651,102.68160223960875 24.999312114540217,102.68085122108458 24.999924704985673,102.68017530441283 24.999487140693418))");<br> Polygon multiPoint2 = (Polygon)reader.read("POLYGON((102.68351197242735 25.001859692840426,102.68454194068907 25.00097485292946,102.68358707427979 25.0004692272621,102.68273949623106 25.00131517672628,102.68351197242735 25.001859692840426))");</p> 
<p>DiscreteHausdorffDistance distance = new DiscreteHausdorffDistance(multiPoint1, multiPoint2);<br> System.out.println(distance.distance());// 0.0033773571609631804<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 面积</p> 
<p><br> GeometryFactory geometryFactory = new GeometryFactory();<br> WKTReader reader = new WKTReader(geometryFactory);</p> 
<p>Polygon multiPoint1 = (Polygon)reader.read("POLYGON((102.680025100708 24.999380180296086,102.68137693405153 24.99751322018369,102.68296480178833 24.998291123677703,102.6812481880188 25.000294202507845,102.680025100708 24.999380180296086))");<br> Polygon multiPoint2 = (Polygon)reader.read("POLYGON((102.68111944198608 24.99922460137013,102.68191337585448 24.99825222861996,102.68373727798462 24.998582836218347,102.68266439437866 24.999885810445036,102.68111944198608 24.99922460137013))");</p> 
<p>SimilarityMeasure similarityMeasure = new AreaSimilarityMeasure();<br> System.out.println(similarityMeasure.measure(multiPoint1, multiPoint2));// 0.210975468769302<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 豪斯多夫测度<br> 豪斯多夫测度(Hausdorff measure)是由豪斯多夫(F.Hausdorff)提出和命名的一种测度。为了定量地描述非整数维，豪斯多夫于1919年从测量的角度引进了豪斯多夫测度。该测度是对长度、面积和体积等的推广，也是勒贝格测度的推广。</p> 
<p><br> GeometryFactory geometryFactory = new GeometryFactory();<br> WKTReader reader = new WKTReader(geometryFactory);</p> 
<p>Polygon multiPoint1 = (Polygon)reader.read("POLYGON((102.68017530441283 24.999487140693418,102.68065810203551 24.99887454806651,102.68160223960875 24.999312114540217,102.68085122108458 24.999924704985673,102.68017530441283 24.999487140693418))");<br> Polygon multiPoint2 = (Polygon)reader.read("POLYGON((102.68351197242735 25.001859692840426,102.68454194068907 25.00097485292946,102.68358707427979 25.0004692272621,102.68273949623106 25.00131517672628,102.68351197242735 25.001859692840426))");</p> 
<p>SimilarityMeasure similarityMeasure = new HausdorffSimilarityMeasure();<br> System.out.println(similarityMeasure.measure(multiPoint1, multiPoint2));// 0.36149546293844836</p> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 空间算法<br> 线段相交算法</p> 
<p><br> Coordinate p1 = new Coordinate(102.68048644065857, 24.999477417024806);<br> Coordinate p2 = new Coordinate(102.68146276473998, 24.998388361268198);<br> Coordinate q1 = new Coordinate(102.68021821975707, 24.999030127435674);<br> Coordinate q2 = new Coordinate(102.68193483352661, 24.998757863410333);</p> 
<p>RobustLineIntersector intersector = new RobustLineIntersector();<br> intersector.computeIntersection(p1, p2, q1, q2);<br> System.out.println(intersector.isInteriorIntersection()); // true</p> 
<p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 计算线段排列和线段序列结点<br> java doc</p> 
<p>实现线绳编码的Snap Rounding算法<br> java doc</p> 
<p>确定几何体中点的拓扑位置<br> java doc</p> 
<p>数学函数<br> 角度分析</p> 
<p><br> Angle angle = new Angle();</p> 
<p>Coordinate c1 = new Coordinate(102.68048644065857, 24.999477417024806);<br> Coordinate c2 = new Coordinate(102.68021821975707, 24.999030127435674);<br> Coordinate c3 = new Coordinate(102.68193483352661, 24.998757863410333);</p> 
<p>// 返回两个无向最小差异角度,范围 [0, 180]<br> double radia1 = angle.angle(c1, c2);<br> double radia2 = angle.angle(c2, c3);<br> System.out.println(angle.toDegrees(angle.diff(radia1, radia2))); // 111.93701386769487</p> 
<p>// 返回两个向量之间的最小夹角,范围[0,180]<br> double ang1 = angle.angleBetween(c1, c2, c3);<br> System.out.println(angle.toDegrees(ang1)); //68.06298613230513</p> 
<p>// 从angle到angle按什么方向旋转<br> // 顺时针: -1<br> // 逆时针: 1<br> System.out.println(angle.getTurn(radia1, radia2)); // 1</p> 
<p>// 判断是否是锐角<br> System.out.println(angle.isAcute(c1, c2, c3)); // true</p> 
<p>// 判断是否是钝角<br> System.out.println(angle.isObtuse(c1, c2, c3)); // false</p> 
<p>// 角度 -&gt; 弧度的转换<br> System.out.println(angle.toDegrees(Math.PI)); // 180.0</p> 
<p>// 弧度 -&gt; 角度的转换<br> System.out.println(angle.toRadians(180)); // 3.141592653589793<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> Spatial structures 空间结构<br> 空间索引<br> 原图形：</p> 
<p>待压占测试图形：</p> 
<p><br> 四叉树<br> 四叉树是一种空间索引结构，用于对以二维矩形为界限的项目进行有效的范围查询。几何体可以通过使用它们的包络来进行索引。任何类型的对象也可以被索引，只要它的范围可以用一个包络来表示。<br> 这个四叉树索引为范围矩形查询提供了一个主要过滤器。各种查询方法会返回一个可能与查询矩形相交的所有项目的列表。</p> 
<p>注意，它可能会返回事实上没有与查询矩形相交的项目。需要一个二级过滤器来测试查询矩形和每个候选项目的包络之间的实际相交。二级过滤器可以显式执行，也可以由项目的后续操作隐式提供（例如，如果索引查询之后计算了查询几何体和树形项目之间的空间谓词，则自动执行包络线交叉检查。</p> 
<p>这个实现不需要事先指定插入的项目的范围。它将自动扩展以适应数据集的任何范围。</p> 
<p>WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.67994999885558 24.999389903972443,102.68048644065857 24.99870924477092,102.68125891685486 24.999088469648342,102.68058300018309 24.99976912674917,102.67994999885558 24.999389903972443))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.6807117462158 24.998971785195337,102.68134474754332 24.99820360978046,102.68229961395264 24.998650902378202,102.6815378665924 24.999496864361305,102.6807117462158 24.998971785195337))");<br> Polygon polygon3 = (Polygon)reader.read("POLYGON((102.68196702003478 24.998670349845497,102.68261075019836 24.997950791505005,102.68352270126343 24.99851477002082,102.68287897109984 24.999321838221945,102.68196702003478 24.998670349845497))");<br> Polygon polygon4 = (Polygon)reader.read("POLYGON((102.6810336112976 25.000371991318303,102.6815915107727 24.999827468610945,102.68239617347716 25.000274755297553,102.68178462982178 25.000877617385797,102.6810336112976 25.000371991318303))");<br> Polygon polygon5 = (Polygon)reader.read("POLYGON((102.68110871315001 24.9999927704022,102.6815915107727 24.99924404874666,102.68223524093628 24.99953575902505,102.68160223960876 25.000216413648175,102.68110871315001 24.9999927704022))");<br> Polygon polygon6 = (Polygon)reader.read("POLYGON((102.68248200416564 25.000760934631828,102.68208503723145 24.999856639531444,102.682728767395 24.99973995580791,102.68312573432921 25.000605357454162,102.68248200416564 25.000760934631828))");<br> Polygon polygon7 = (Polygon)reader.read("POLYGON((102.68091559410094 24.998398085023027,102.683265209198 24.998116095820905,102.68280386924742 24.997289572017735,102.68087267875671 24.997717420327533,102.68091559410094 24.998398085023027))");</p> 
<p>Quadtree quadtree = new Quadtree();<br> quadtree.insert(polygon1.getEnvelopeInternal(), polygon1);<br> quadtree.insert(polygon2.getEnvelopeInternal(), polygon2);<br> quadtree.insert(polygon3.getEnvelopeInternal(), polygon3);<br> quadtree.insert(polygon4.getEnvelopeInternal(), polygon4);<br> quadtree.insert(polygon5.getEnvelopeInternal(), polygon5);<br> quadtree.insert(polygon6.getEnvelopeInternal(), polygon6);<br> quadtree.insert(polygon7.getEnvelopeInternal(), polygon7);</p> 
<p>// 点<br> Point q1 = (Point)reader.read("POINT(102.68122673034668 24.998563388737182)");<br> for (Object o : quadtree.query(q1.getEnvelopeInternal())) {<!-- --><br>     Polygon polygon = (Polygon) o;<br>     if (q1.intersects(polygon)) {<!-- --><br>         System.out.println(polygon.toText());<br>     }<br> }</p> 
<p>System.out.println("--- --- --- ---");</p> 
<p>// 线<br> LineString q2 = (LineString)reader.read("LINESTRING(102.68004655838013 24.999321838221945,102.68317937850951 24.997804934571022)");<br> for (Object o : quadtree.query(q2.getEnvelopeInternal())) {<!-- --><br>     Polygon polygon = (Polygon) o;<br>     if (q2.intersects(polygon)) {<!-- --><br>         System.out.println(polygon.toText());<br>     }<br> }</p> 
<p>System.out.println("--- --- --- ---");</p> 
<p>// 面<br> Polygon q3 = (Polygon)reader.read("POLYGON((102.68004655838013 24.999380180296086,102.68182754516602 24.99687144609392,102.68300771713257 24.997610458389715,102.68107652664185 24.99990525771689,102.68004655838013 24.999380180296086))");<br> for (Object o : quadtree.query(q3.getEnvelopeInternal())) {<!-- --><br>     Polygon polygon = (Polygon) o;<br>     if (q3.intersects(polygon)) {<!-- --><br>         System.out.println(polygon.toText());<br>     }<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 35<br> 36<br> 37<br> 38<br> 39<br> 40<br> 41<br> 42<br> 43<br> 44<br> 45<br> 46<br> 47<br> 48</p> 
<p><br> STR树<br> 使用Sort-Tile-Recursive（STR）算法创建的纯查询R树。用于二维空间数据。<br> STR打包的R树实现起来很简单，并能最大限度地利用空间；也就是说，尽可能多的叶子被填充到容量。节点之间的重叠要比基本的R树少得多。然而，一旦树被建立起来（明确地或在第一次调用#query时），项目就不能被添加或删除。</p> 
<p>请注意：</p> 
<p>向树中插入项目不是线程安全的。在一个以上的线程上进行的插入必须在外部进行同步。<br> 查询一棵树是线程安全的。<br> 构建阶段是同步进行的，而查询是无状态的。</p> 
<p>待压占测试图形：</p> 
<p><br> WKTReader reader = new WKTReader(new GeometryFactory());<br> Polygon polygon1 = (Polygon)reader.read("POLYGON((102.67994999885558 24.999389903972443,102.68048644065857 24.99870924477092,102.68125891685486 24.999088469648342,102.68058300018309 24.99976912674917,102.67994999885558 24.999389903972443))");<br> Polygon polygon2 = (Polygon)reader.read("POLYGON((102.6807117462158 24.998971785195337,102.68134474754332 24.99820360978046,102.68229961395264 24.998650902378202,102.6815378665924 24.999496864361305,102.6807117462158 24.998971785195337))");<br> Polygon polygon3 = (Polygon)reader.read("POLYGON((102.68196702003478 24.998670349845497,102.68261075019836 24.997950791505005,102.68352270126343 24.99851477002082,102.68287897109984 24.999321838221945,102.68196702003478 24.998670349845497))");<br> Polygon polygon4 = (Polygon)reader.read("POLYGON((102.6810336112976 25.000371991318303,102.6815915107727 24.999827468610945,102.68239617347716 25.000274755297553,102.68178462982178 25.000877617385797,102.6810336112976 25.000371991318303))");<br> Polygon polygon5 = (Polygon)reader.read("POLYGON((102.68110871315001 24.9999927704022,102.6815915107727 24.99924404874666,102.68223524093628 24.99953575902505,102.68160223960876 25.000216413648175,102.68110871315001 24.9999927704022))");<br> Polygon polygon6 = (Polygon)reader.read("POLYGON((102.68248200416564 25.000760934631828,102.68208503723145 24.999856639531444,102.682728767395 24.99973995580791,102.68312573432921 25.000605357454162,102.68248200416564 25.000760934631828))");<br> Polygon polygon7 = (Polygon)reader.read("POLYGON((102.68091559410094 24.998398085023027,102.683265209198 24.998116095820905,102.68280386924742 24.997289572017735,102.68087267875671 24.997717420327533,102.68091559410094 24.998398085023027))");</p> 
<p>STRtree strTree = new STRtree();<br> strTree.insert(polygon1.getEnvelopeInternal(), polygon1);<br> strTree.insert(polygon2.getEnvelopeInternal(), polygon2);<br> strTree.insert(polygon3.getEnvelopeInternal(), polygon3);<br> strTree.insert(polygon4.getEnvelopeInternal(), polygon4);<br> strTree.insert(polygon5.getEnvelopeInternal(), polygon5);<br> strTree.insert(polygon6.getEnvelopeInternal(), polygon6);<br> strTree.insert(polygon7.getEnvelopeInternal(), polygon7);</p> 
<p>// 点<br> Point q1 = (Point)reader.read("POINT(102.68122673034668 24.998563388737182)");<br> for (Object o : strTree.query(q1.getEnvelopeInternal())) {<!-- --><br>     Polygon polygon = (Polygon) o;<br>     if (q1.intersects(polygon)) {<!-- --><br>         System.out.println(polygon.toText());<br>     }<br> }</p> 
<p>System.out.println("--- --- --- ---");</p> 
<p>// 线<br> LineString q2 = (LineString)reader.read("LINESTRING(102.68004655838013 24.999321838221945,102.68317937850951 24.997804934571022)");<br> for (Object o : strTree.query(q2.getEnvelopeInternal())) {<!-- --><br>     Polygon polygon = (Polygon) o;<br>     if (q2.intersects(polygon)) {<!-- --><br>         System.out.println(polygon.toText());<br>     }<br> }</p> 
<p>System.out.println("--- --- --- ---");</p> 
<p>// 面<br> Polygon q3 = (Polygon)reader.read("POLYGON((102.68004655838013 24.999380180296086,102.68182754516602 24.99687144609392,102.68300771713257 24.997610458389715,102.68107652664185 24.99990525771689,102.68004655838013 24.999380180296086))");<br> for (Object o : strTree.query(q3.getEnvelopeInternal())) {<!-- --><br>     Polygon polygon = (Polygon) o;<br>     if (q3.intersects(polygon)) {<!-- --><br>         System.out.println(polygon.toText());<br>     }<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 35<br> 36<br> 37<br> 38<br> 39<br> 40<br> 41<br> 42<br> 43<br> 44<br> 45<br> 46<br> 47<br> 48<br> 压覆图形同上！</p> 
<p>KD树<br> 一个2-D KD树的实现。KD树为点数据提供快速的范围搜索和快速查找。<br> 这个实现支持检测和捕捉那些比给定距离公差更近的点。如果同一个点（在容差范围内）被插入超过一次，它就会被抢占到现有节点上。换句话说，如果一个点被插入，并且位于索引中已经存在的节点的公差范围内，那么它就会被捕捉到该节点。当一个点被卡在一个节点上时，一个新的节点不会被创建，但现有节点的计数会被增加。如果树中有多个节点在插入点的容差范围内，则会将最近的、然后是最低的节点套入。</p> 
<p>请注意，KD树的结构取决于插入点的顺序。如果插入的点是连贯的（例如，在一个或两个维度上是单调的），那么一棵树可能会变得不平衡。一个完全平衡的树的深度只有log2(N)，但一个不平衡的树可能会更深。这对查询效率有严重影响。更糟糕的是，由于递归被用于查询树，一个极深的树可能会导致StackOverflowException。解决这个问题的方法之一是在插入前随机化点的顺序（例如，通过使用Fisher-Yates洗牌）。</p> 
<p>原图形：</p> 
<p>待压占测试图形：</p> 
<p><br> KdTree kdTree = new KdTree();<br> kdTree.insert(new Coordinate(102.68006801605225, 24.999321838221945));<br> kdTree.insert(new Coordinate(102.6806688308716, 24.998446703785575));<br> kdTree.insert(new Coordinate(102.68129110336305, 24.99778548696672));<br> kdTree.insert(new Coordinate(102.681999206543, 24.99702702799921));<br> kdTree.insert(new Coordinate(102.6829218864441, 24.997474324879704));<br> kdTree.insert(new Coordinate(102.68229961395265, 24.998291123677703));<br> kdTree.insert(new Coordinate(102.68161296844484, 24.99895233777569));<br> kdTree.insert(new Coordinate(102.68101215362549, 24.999944152251373));<br> kdTree.insert(new Coordinate(102.68195629119874, 25.000683146067615));<br> kdTree.insert(new Coordinate(102.68285751342775, 24.999827468610945));<br> kdTree.insert(new Coordinate(102.68347978591919, 24.998991232611843));<br> kdTree.insert(new Coordinate(102.68408060073854, 24.99807720070774));</p> 
<p>GeometryFactory geometryFactory = new GeometryFactory();<br> WKTReader reader = new WKTReader(geometryFactory);</p> 
<p>// 点 无重叠<br> Point q1 = (Point)reader.read("POINT(102.68122673034668 24.998563388737182)");<br> for (Object o : kdTree.query(q1.getEnvelopeInternal())) {<!-- --><br>     KdNode node = (KdNode)o;<br>     Point point = (Point)reader.read("POINT(" + node.getX() + " " + node.getY() + ")");<br>     System.out.println(point.toText());<br> }</p> 
<p>System.out.println("--- --- --- ---");</p> 
<p>// 线<br> LineString q2 = (LineString)reader.read("LINESTRING(102.68004655838013 24.999321838221945,102.68317937850951 24.997804934571022)");<br> for (Object o : kdTree.query(q2.getEnvelopeInternal())) {<!-- --><br>     KdNode node = (KdNode)o;<br>     Point point = (Point)reader.read("POINT(" + node.getX() + " " + node.getY() + ")");<br>     System.out.println(point.toText());<br> }</p> 
<p>System.out.println("--- --- --- ---");</p> 
<p>// 面<br> Polygon q3 = (Polygon)reader.read("POLYGON((102.68004655838013 24.999380180296086,102.68182754516602 24.99687144609392,102.68300771713257 24.997610458389715,102.68107652664185 24.99990525771689,102.68004655838013 24.999380180296086))");<br> for (Object o : kdTree.query(q3.getEnvelopeInternal())) {<!-- --><br>     KdNode node = (KdNode)o;<br>     Point point = (Point)reader.read("POINT(" + node.getX() + " " + node.getY() + ")");<br>     System.out.println(point.toText());<br> }<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 35<br> 36<br> 37<br> 38<br> 39<br> 40<br> 41<br> 42<br> 43<br> 44</p> 
<p>Interval R树<br> 包含用于实现一维区间的R树索引的包。</p> 
<p>单调链<br> 包含实现单调链的包。</p> 
<p>可平面图<br> 能在平面上画出没有相交的边的图，称为平面图(planar)。<br> 这个类和这个包中的其他类作为一个框架，为特定的算法构建平面图。这个类必须被子类化以暴露适当的方法来构建图形。这允许控制可以被添加到图形中的图形组件（DirectedEdges、Edges和Nodes）的类型。一个使用图形框架的应用程序几乎总是为一个或多个图形组件提供子类，这些组件持有应用程序特定的数据和图形算法。</p> 
<p>可平面图算法<br> 在平面图上实现图算法的包。</p> 
<p>输入/输出<br> WKT 导入 / 导出<br> GeometryFactory factory = new GeometryFactory();<br> // 导入<br> String wkt = "POLYGON((102.68004655838013 24.999380180296086,102.68182754516602 24.99687144609392,102.68300771713257 24.997610458389715,102.68107652664185 24.99990525771689,102.68004655838013 24.999380180296086))";<br> WKTReader reader = new WKTReader(factory);<br> Geometry geometry = reader.read(wkt);<br> System.out.println(geometry);<br> // 导出<br> WKTWriter writer = new WKTWriter(2);<br> String wkt2 = writer.write(geometry);<br> System.out.println(wkt2);<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> WKB 导入 / 导出<br> GeometryFactory factory = new GeometryFactory();<br> // 导入<br> byte[] wkb = {0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 5, 64, 89, -85, -123, -30, 0, 0, 0, 64, 56, -1, -41, 97, 38, -92, 108, 64, 89, -85, -93, 16, 0, 0, 0, 64, 56, -1, 50, -9, -109, 74, 36, 64, 89, -85, -74, 102, 0, 0, 0, 64, 56, -1, 99, 102, 36, -18, 112, 64, 89, -85, -106, -62, 0, 0, 0, 64, 56, -1, -7, -54, 124, -2, 20, 64, 89, -85, -123, -30, 0, 0, 0, 64, 56, -1, -41, 97, 38, -92, 108};<br> WKBReader reader = new WKBReader(factory);<br> Geometry geometry = reader.read(wkb);<br> System.out.println(geometry);<br> // 导出<br> WKBWriter writer = new WKBWriter(2);<br> byte[] bytes = writer.write(geometry);<br> System.out.println(new String(bytes, StandardCharsets.UTF_8));<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> GML（V2） 导入 / 导出<br> GeometryFactory factory = new GeometryFactory();<br> // 导入<br> String gml = "&lt;gml:Polygon&gt;&lt;gml:outerBoundaryIs&gt;&lt;gml:LinearRing&gt;&lt;gml:coordinates&gt;102.68004655838013,24.999380180296086 102.68182754516602,24.99687144609392 102.68300771713257,24.997610458389715 102.68107652664185,24.99990525771689 102.68004655838013,24.999380180296086&lt;/gml:coordinates&gt;&lt;/gml:LinearRing&gt;&lt;/gml:outerBoundaryIs&gt;&lt;/gml:Polygon&gt;";<br> GMLReader reader = new GMLReader();<br> Geometry geometry = reader.read(gml, factory);<br> System.out.println(geometry);<br> // 导出<br> GMLWriter writer = new GMLWriter();<br> String write = writer.write(geometry);<br> System.out.println(write);<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 高精度算法<br> 2x2双精度行列式的鲁棒性评估<br> 执行一种算法，以稳健地计算双精度值的2x2行列式的符号。</p> 
<p>DoubleDouble扩展精度算术<br> 实施扩展精度的浮点数，保持106位（约30位小数）的精度<br> ————————————————<br> 版权声明：本文为CSDN博主「Archie_java」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/qq_43842093/article/details/124853985</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cfba3b6cd116430ffe9ee1f9c41123aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot项目打成jar后加载外部配置文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f257fe90564eac7234e25b23e3c495a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【导出Excel】Excel表格单元格最多放多少个字</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>