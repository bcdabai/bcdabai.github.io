<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Servlet超详解&#43;流程图 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Servlet超详解&#43;流程图" />
<meta property="og:description" content="1.servlet处理用户请求的完整流程 针对Servlet的每次请求，Web 服务器在调用 service() 方法之前，都会创建 HttpServletRequest 和 HttpServletResponse 对象。其中，HttpServletRequest 对象用于封装 HTTP 请求消息，简称 request 对象。HttpServletResponse 对象用于封装 HTTP 响应消息，简称 response 对象。浏览器访问 Servlet 的交互过程如图 1 所示。
图 1 浏览器访问Servlet过程
在图 1 中，首先浏览器向 Web 服务器发送了一个 HTTP 请求，Web 服务器根据收到的请求，会先 创建一个 HttpServletRequest 和 HttpServletResponse 对象，然后再调用相应的 Servlet 程序。
在 Servlet 程序运行时，它首先会从 HttpServletRequest 对象中读取数据信息，然后通过 service() 方法处理请求消息，并将处理后的响应数据写入到 HttpServletResponse 对象中。最后，Web 服务器会从 HttpServletResponse 对象中读取到响应数据，并发送给浏览器。
需要注意的是，在 Web 服务器运行阶段，每个 Servlet 都只会创建一个实例对象，针对每次 HTTP 请求，Web 服务器都会调用所请求 Servlet 实例的 service（HttpServletRequest request，HttpServletResponse response）方法，并重新创建一个 request 对象和一个 response 对象。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/48542b696f4b0c0616c3bc4568585b45/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-13T08:53:28+08:00" />
<meta property="article:modified_time" content="2021-08-13T08:53:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Servlet超详解&#43;流程图</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0cm;"><span style="color:#fe2c24;"><strong>1.servlet处理用户请求的完整流程</strong></span></h2> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">针对Servlet</span><span style="color:#444444;">的每次请求，Web 服务器在调用 service() 方法之前，都会创建 HttpServletRequest 和 HttpServletResponse 对象。其中，HttpServletRequest 对象用于封装 HTTP 请求消息，简称 request 对象。HttpServletResponse 对象用于封装 HTTP 响应消息，简称 response 对象。浏览器访问 Servlet 的交互过程如图 1 所示。</span></span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="259" src="https://images2.imgbox.com/8d/5f/S9cqAZr3_o.png" width="554"><br><span style="background-color:#ffffff;"><span style="color:#444444;">图 1  浏览器访问Servlet过程</span></span></p> 
<p style="text-align:center;"></p> 
<p style="margin-left:0px;text-align:center;"></p> 
<p style="margin-left:0px;"><span style="background-color:#ffffff;"><span style="color:#444444;">在图 1 中，首先浏览器向 Web 服务器发送了一个 HTTP 请求，Web 服务器根据收到的请求，会先 创建一个 HttpServletRequest 和 HttpServletResponse 对象，然后再调用相应的 Servlet 程序。</span></span></p> 
<p style="margin-left:0px;"></p> 
<p style="margin-left:0px;"><span style="background-color:#ffffff;"><span style="color:#444444;">在 Servlet 程序运行时，它首先会从 HttpServletRequest 对象中读取数据信息，然后通过 service() 方法处理请求消息，并将处理后的响应数据写入到 HttpServletResponse 对象中。最后，Web 服务器会从 HttpServletResponse 对象中读取到响应数据，并发送给浏览器。</span></span></p> 
<p style="margin-left:0px;"></p> 
<p style="margin-left:0px;"><span style="background-color:#ffffff;"><span style="color:#444444;">需要注意的是，在 Web 服务器运行阶段，每个 Servlet 都只会创建一个实例对象，针对每次 HTTP 请求，Web 服务器都会调用所请求 Servlet 实例的 service（HttpServletRequest request，HttpServletResponse response）方法，并重新创建一个 request 对象和一个 response 对象。</span></span></p> 
<p></p> 
<p style="margin-left:0;text-align:left;"></p> 
<h2 style="margin-left:0cm;"><span style="color:#fe2c24;"><strong>2.什么是 Servlet 容器？</strong></span></h2> 
<h3 style="margin-left:0px;text-align:left;"><a name="t0"></a><strong><span style="color:#4f4f4f;">1</span></strong><strong><span style="color:#4f4f4f;">、什么是 Web 服务器？</span></strong></h3> 
<p style="margin-left:0;text-align:left;"><span style="color:#4d4d4d;">想要了解什么是</span><span style="color:#4d4d4d;"> Servlet </span><span style="color:#4d4d4d;">容器，首先需要知道什么是</span><span style="color:#4d4d4d;"> Web </span><span style="color:#4d4d4d;">服务器。</span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="505" src="https://images2.imgbox.com/41/f3/6cZz7SmY_o.png" width="529"></p> 
<p> </p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4d4d4d;">Web </span><span style="color:#4d4d4d;">服务器使用</span><span style="color:#4d4d4d;"> HTTP </span><span style="color:#4d4d4d;">协议传输数据。在一般情况下，用户在浏览器（客户端）中键入</span><span style="color:#4d4d4d;"> URL</span><span style="color:#4d4d4d;">（例如</span><span style="color:#4d4d4d;">www.baidu.com/static.html</span><span style="color:#4d4d4d;">），并获取要读取的网页。所以服务器所做的就是向客户机发送一个网页。信息的交换采用指定请求和响应消息的格式的</span><span style="color:#4d4d4d;"> HTTP </span><span style="color:#4d4d4d;">协议。</span></p> 
<h4 style="margin-left:0px;text-align:left;"></h4> 
<h3 style="margin-left:0px;text-align:left;"><a name="t1"></a><strong><span style="color:#4f4f4f;">2</span></strong><strong><span style="color:#4f4f4f;">、什么是 Servlet 容器？</span></strong></h3> 
<p style="margin-left:0;text-align:left;"><span style="color:#4d4d4d;">正如我们看到的，用户</span><span style="color:#4d4d4d;">/</span><span style="color:#4d4d4d;">客户端只能从服务器请求静态网页。如果用户希望根据自己的输入阅读网页，那么这还不够好。</span><span style="color:#4d4d4d;">Servlet </span><span style="color:#4d4d4d;">容器的基本思想是使用</span><span style="color:#4d4d4d;"> Java </span><span style="color:#4d4d4d;">动态生成服务器端的网页。所以</span><span style="color:#4d4d4d;"> Servlet </span><span style="color:#4d4d4d;">容器本质上是与</span><span style="color:#4d4d4d;"> Servlet </span><span style="color:#4d4d4d;">交互的</span><span style="color:#4d4d4d;"> Web </span><span style="color:#4d4d4d;">服务器的一部分。</span></p> 
<p style="margin-left:0;text-align:left;"><img alt="" height="268" src="https://images2.imgbox.com/f4/71/b6QHxjH3_o.png" width="490"></p> 
<p> </p> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#4d4d4d;">“Servlet </span></strong><strong><span style="color:#4d4d4d;">容器</span></strong><strong><span style="color:#4d4d4d;">”</span></strong><strong><span style="color:#4d4d4d;">是一个装载一堆</span></strong><strong><span style="color:#4d4d4d;"> Servlet </span></strong><strong><span style="color:#4d4d4d;">对象的</span></strong><strong><span style="color:#4d4d4d;">“</span></strong><strong><span style="color:#4d4d4d;">器具</span></strong><strong><span style="color:#4d4d4d;">”</span></strong><strong><span style="color:#4d4d4d;">（容器），并且具备管理这些对象的功能。</span></strong></p> 
<p style="margin-left:0;text-align:left;"></p> 
<h3 style="margin-left:0px;text-align:left;"><a name="t2"></a><strong><span style="color:#4f4f4f;">3</span></strong><strong><span style="color:#4f4f4f;">、什么是 Servlet？</span></strong></h3> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#4d4d4d;">Servlet </span></strong><strong><span style="color:#4d4d4d;">是</span></strong><strong><span style="color:#4d4d4d;"> javax.servlet </span></strong><strong><span style="color:#4d4d4d;">包中定义的接口。</span></strong><span style="color:#4d4d4d;">它声明了</span><span style="color:#4d4d4d;"> Servlet </span><span style="color:#4d4d4d;">生命周期的三个基本方法：</span><span style="color:#4d4d4d;">init()</span><span style="color:#4d4d4d;">、</span><span style="color:#4d4d4d;">service() </span><span style="color:#4d4d4d;">和</span><span style="color:#4d4d4d;"> destroy()</span><span style="color:#4d4d4d;">。它们由每个</span><span style="color:#4d4d4d;"> Servlet Class</span><span style="color:#4d4d4d;">（在</span><span style="color:#4d4d4d;"> SDK </span><span style="color:#4d4d4d;">中定义或自定义）实现，并由服务器在特定时机调用。</span></p> 
<ul><li style="text-align:left;"><strong>init() </strong>方法在 Servlet 生命周期的初始化阶段调用。它被传递一个实现 javax.servlet.ServletConfig 接口的对象，该接口允许 Servlet 从 Web 应用程序访问初始化参数。</li><li style="text-align:left;"><strong>service() </strong>方法在初始化后对每个请求进行调用。每个请求都在自己的独立线程中提供服务。Web容器为每个请求调用 Servlet 的 service() 方法。service() 方法确认请求的类型，并将其分派给适当的方法来处理该请求。</li><li style="text-align:left;"><strong>destroy()</strong> 方法在销毁 Servlet 对象时调用，用来释放所持有的资源。</li></ul> 
<p style="margin-left:0;text-align:left;"><span style="color:#4d4d4d;">从</span><span style="color:#4d4d4d;"> Servlet </span><span style="color:#4d4d4d;">对象的生命周期中，我们可以看到</span><span style="color:#4d4d4d;"> <strong>Servlet </strong></span><strong><span style="color:#4d4d4d;">类是由类加载器动态加载到容器中的</span></strong><span style="color:#4d4d4d;">。每个请求都在自己的线程中，</span><span style="color:#4d4d4d;">Servlet </span><span style="color:#4d4d4d;">对象可以同时服务多个线程（线程不安全的）。当它不再被使用时，会被</span><span style="color:#4d4d4d;"> JVM </span><span style="color:#4d4d4d;">垃圾收集。</span><br><span style="color:#4d4d4d;">像任何</span><span style="color:#4d4d4d;">Java</span><span style="color:#4d4d4d;">程序一样，</span><span style="color:#4d4d4d;">Servlet </span><span style="color:#4d4d4d;">在</span><span style="color:#4d4d4d;"> JVM </span><span style="color:#4d4d4d;">中运行。为了处理复杂的</span><span style="color:#4d4d4d;"> HTTP </span><span style="color:#4d4d4d;">请求，</span><span style="color:#4d4d4d;">Servlet </span><span style="color:#4d4d4d;">容器出现了。</span><span style="color:#4d4d4d;">Servlet </span><span style="color:#4d4d4d;">容器负责</span><span style="color:#4d4d4d;"> Servlet </span><span style="color:#4d4d4d;">的创建、执行和销毁。</span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<h3 style="margin-left:0px;text-align:left;"><a name="t3"></a><strong><span style="color:#4f4f4f;">4</span></strong><strong><span style="color:#4f4f4f;">、Servlet 容器和 Web 服务器如何处理一个请求的？</span></strong></h3> 
<ol><li style="text-align:left;">Web 服务器接收 HTTP 请求。</li><li style="text-align:left;">Web 服务器将请求转发到 Servlet 容器。</li><li style="text-align:left;">如果对应的 Servlet 不在容器中，那么将被动态检索并加载到容器的地址空间中。</li><li style="text-align:left;">容器调用 init() 方法进行初始化（仅在第一次加载 Servlet 时调用一次）。</li><li style="text-align:left;">容器调用 Servlet 的 service() 方法来处理 HTTP 请求，即读取请求中的数据并构建响应。Servlet 将暂时保留在容器的地址空间中，可以继续处理其它 HTTP 请求。</li><li style="text-align:left;">Web 服务器将动态生成的结果返回到浏览器/客户端。</li></ol> 
<p style="margin-left:0;text-align:left;"><img alt="" height="392" src="https://images2.imgbox.com/ee/7e/XmegPI6Q_o.png" width="554"></p> 
<p> </p> 
<h3 style="margin-left:0px;text-align:left;"><a name="t4"></a><strong><span style="color:#4f4f4f;">5</span></strong><strong><span style="color:#4f4f4f;">、JVM 的作用</span></strong></h3> 
<p style="margin-left:0;text-align:left;"><span style="color:#4d4d4d;">Servlet </span><span style="color:#4d4d4d;">允许</span><span style="color:#4d4d4d;"> JVM </span><span style="color:#4d4d4d;">在处理每个请求时使用单独的</span><span style="color:#4d4d4d;"> Java </span><span style="color:#4d4d4d;">线程，这是</span><span style="color:#4d4d4d;"> Servlet </span><span style="color:#4d4d4d;">容器的一个主要优点。每个</span><span style="color:#4d4d4d;"> Servlet </span><span style="color:#4d4d4d;">是一个</span><span style="color:#4d4d4d;"> Java </span><span style="color:#4d4d4d;">类，具有响应</span><span style="color:#4d4d4d;"> HTTP </span><span style="color:#4d4d4d;">请求的特殊元素。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4d4d4d;">Servlet </span><span style="color:#4d4d4d;">容器的主要功能是<strong>将请求转发到正确的</strong></span><strong><span style="color:#4d4d4d;"> Servlet </span></strong><strong><span style="color:#4d4d4d;">进行处理，并在</span></strong><strong><span style="color:#4d4d4d;"> JVM </span></strong><strong><span style="color:#4d4d4d;">处理完后将动态生成的结果返回到</span></strong><span style="color:#4d4d4d;">正确的位置。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4d4d4d;">在大多数情况下，</span><span style="color:#4d4d4d;"> Servlet </span><span style="color:#4d4d4d;">容器在单个</span><span style="color:#4d4d4d;"> JVM </span><span style="color:#4d4d4d;">中运行，但是当容器需要多个</span><span style="color:#4d4d4d;"> JVM </span><span style="color:#4d4d4d;">时，会有一些其它的解决方案。</span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<h2 style="margin-left:0cm;"><strong><span style="color:#fe2c24;">3.</span><a href="https://www.cnblogs.com/alice-cj/p/11618025.html" rel="nofollow"><span style="color:#fe2c24;">JavaWeb工程中web.xml基本配置</span></a></strong></h2> 
<h3 style="margin-left:0px;text-align:left;"><span style="color:#4b4b4b;">1..理论准备</span></h3> 
<h4 style="margin-left:0px;text-align:left;"></h4> 
<p style="margin-left:0px;text-align:left;"><span style="color:#4b4b4b;">xml规则，必须有且只有一个根节点，大小写敏感，标签不嵌套，必须配对。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">web.xml</span><span style="color:#4b4b4b;">是不是必须的呢？</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">不是的，只要你不用到里面的配置信息就好了，不过在大型web工程下使用该文件是很方便的，若是没有也会很复杂。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">那么web.xml能做的所有事情都有那些？</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">其实，web.xml的模式(Schema)文件中定义了多少种标签元素，web.xml中就可以出现它的模式文件所定义的标签元素，它就能拥有定义出来的那些功能。web.xml的模式文件是由Sun公司定义的，每个web.xml文件的根元素&lt;web-app&gt;中，都必须标明这个web.xml使用的是哪个模式文件。 </span></p> 
<p style="margin-left:0;text-align:left;"><br><span style="color:#4b4b4b;"> 来看个例子：</span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<pre><code class="language-java"> 1 &lt;?xml version="1.0" encoding="UTF-8"?&gt;

 2 &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt;

  &lt;display-name&gt;db&lt;/display-name&gt;

  &lt;welcome-file-list&gt;

&lt;welcome-file&gt;index.html&lt;/welcome-file&gt;

   &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;

  &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;

&lt;welcome-file&gt;default.html&lt;/welcome-file&gt;

&lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;

&lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;

&lt;/welcome-file-list&gt;

 &lt;/web-app&gt;</code></pre> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">二.标签元素</span></p> 
<ul><li style="text-align:left;"><span style="color:#4b4b4b;">指定欢迎页面</span></li></ul> 
<pre><code class="language-java">&lt;welcome-file-list&gt;

 &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;

&lt;welcome-file&gt;index1.jsp&lt;/welcome-file&gt;

&lt;/welcome-file-list&gt;</code></pre> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">上面的例子指定了2个欢迎页面，显示时按顺序从第一个找起，如果第一个存在，就显示第一个，后面的不起作用。如果第一个不存在，就找第二个，以此类推。 </span><br>  </p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">关于欢迎页面：访问一个网站时，默认看到的第一个页面就叫欢迎页，一般情况下是由首页来充当欢迎页的。一般情况下，我们会在web.xml中指定欢迎页。但web.xml并不是一个Web的必要文件，没有web.xml，网站仍然是可以正常工作的。只不过网站的功能复杂起来后，web.xml的确有非常大用处，所以，默认创建的动态web工程在WEB-INF文件夹下面都有一个web.xml文件。 </span><br>  </p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">对于tomcat来说，当你只指定一个web的根名，没有指定具体页面，去访问时一个web时，如果web.xml文件中配置了欢迎页，那么就返回指定的那个页面作为欢迎页，而在文中没有web.xml文件，或虽然有web.xml，但web.xml也没指定欢迎页的情况下，它默认先查找index.html文件，如果找到了，就把index.html作为欢迎页还回给浏览器。如果没找到index.html，tomcat就去找index.jsp。找到index.jsp就把它作为欢迎页面返回。而如果index.html和index.jsp都没找到，又没有用web.xml文件指定欢迎页面，那此时tomcat就不知道该返回哪个文件了，它就显示The requested resource (/XXX) is not available(我就出现过这个问题)的页面。其中XXX表示web的根名。但如果你指定了具体页面，是可以正常访问的。</span></p> 
<ul><li style="text-align:left;"><span style="color:#4b4b4b;">命名与定制URL</span></li></ul> 
<p style="margin-left:0;text-align:left;"></p> 
<pre><code class="language-java"> &lt;servlet&gt;

&lt;servlet-name&gt;servlet1&lt;/servlet-name&gt;

 &lt;servlet-class&gt;net.test.TestServlet&lt;/servlet-class&gt;

 &lt;/servlet&gt;



 &lt;servlet-mapping&gt;

     &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt;

     &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;

&lt;/servlet-mapping&gt;</code></pre> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">        url-pattern</span><span style="color:#4b4b4b;">的意思是所有的.do文件都会经过TestServlet处理。</span></p> 
<ul><li style="text-align:left;"><span style="color:#4b4b4b;">定制初始化参数</span></li></ul> 
<p style="margin-left:0;text-align:left;"></p> 
<pre><code class="language-java">  &lt;servlet&gt;

      &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt;

      &lt;servlet-class&gt;net.test.TestServlet&lt;/servlet-class&gt;

      &lt;init-param&gt;

            &lt;param-name&gt;userName&lt;/param-name&gt;

            &lt;param-value&gt;Tommy&lt;/param-value&gt;

     &lt;/init-param&gt;

      &lt;init-param&gt;

            &lt;param-name&gt;E-mail&lt;/param-name&gt;

           &lt;param-value&gt;Tommy@163.com&lt;/param-value&gt;

     &lt;/init-param&gt;

 &lt;/servlet&gt;</code></pre> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;">        <span style="color:#4b4b4b;">经过上面的配置，在servlet中能够调用getServletConfig().getInitParameter("param1")获得参数名对应的值。</span></p> 
<p style="margin-left:0;text-align:left;"></p> 
<pre><code class="language-java">//上下文参数：声明应用范围内的初始化参数。 

 &lt;context-param&gt;      

&lt;param-name&gt;ContextParameter&lt;/para-name&gt; 

 

  &lt;param-value&gt;test&lt;/param-value&gt; 

     &lt;description&gt;It is a test parameter.&lt;/description&gt; 

 &lt;/context-param&gt; 

 //在servlet里面可以通过getServletContext().getInitParameter("context/param")</code></pre> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">得到  </span></p> 
<ul><li style="text-align:left;"><span style="color:#4b4b4b;">指定错误处理页面，可以通过“异常类型”或“错误码”来指定错误处理页面。</span></li></ul> 
<p style="margin-left:0;text-align:left;"></p> 
<pre><code class="language-java"> &lt;error-page&gt;

     &lt;error-code&gt;404&lt;/error-code&gt;

     &lt;location&gt;/error404.jsp&lt;/location&gt;

 &lt;/error-page&gt;

 &lt;error-page&gt;

    &lt;exception-type&gt;java.lang.Exception&lt;exception-type&gt;

   &lt;location&gt;/exception.jsp&lt;location&gt;

 &lt;/error-page&gt;

 &lt;error-page&gt; 

      &lt;exception-type&gt;java.lang.NullException&lt;/exception-type&gt; 

       &lt;location&gt;/error.jsp&lt;/location&gt; 

 &lt;/error-page&gt;</code></pre> 
<p style="margin-left:0;text-align:left;"></p> 
<ul><li style="text-align:left;"><span style="color:#4b4b4b;">设置过滤器：比如设置一个编码过滤器，过滤所有资源</span></li></ul> 
<p style="margin-left:0;text-align:left;"></p> 
<pre><code class="language-java"> &lt;filter&gt;

     &lt;filter-name&gt;XXXCharaSetFilter&lt;/filter-name&gt;

   &lt;filter-class&gt;net.test.CharSetFilter&lt;/filter-class&gt;

 &lt;/filter&gt;

 &lt;filter-mapping&gt;

     &lt;filter-name&gt;XXXCharaSetFilter&lt;/filter-name&gt;

     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;

 &lt;/filter-mapping&gt;</code></pre> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">6.</span><span style="color:#4b4b4b;">设置监听器</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">        web.xml</span><span style="color:#4b4b4b;">中的&lt;listener&gt;&lt;/listener&gt;有什么用? 没别的用处!就是配置监听类的~，它能捕捉到服务器的启动和停止! 在启动和停止触发里面的方法做相应的操作! 它必须在web.xml 中配置才能使用! web.xml 中listener元素不是只能有一个，有多个时按顺序执行。</span></p> 
<p style="margin-left:0;text-align:left;">        <span style="color:#4b4b4b;">如何在web.xml向listener中传参数 ？</span></p> 
<pre><code class="language-java"> &lt;listener&gt;

      &lt;listener-class&gt;监听器类的完整路径&lt;/listener-class&gt;

&lt;/listener&gt;</code></pre> 
<p style="margin-left:0;text-align:left;">         <span style="color:#4b4b4b;">监听器中不能够写初始化参数; 可通过另个的途径达到初始化参数的效果: 1.写一个properties文件,在文件里写好初始化参数值, 2.在监听器中可以通得到properties文件中的值(写在静态块中)。</span></p> 
<ul><li style="text-align:left;"><span style="color:#4b4b4b;">设置会话(Session)过期时间，其中时间以分钟为单位</span></li></ul> 
<p></p> 
<pre><code class="language-java">&lt;session-config&gt;

    &lt;session-timeout&gt;60&lt;/session-timeout&gt;

 &lt;/session-config&gt;</code></pre> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">除了这些标签元素之外，还可以往web.xml中添加那些标签元素呢，那些标签元素都能起什么作用呢？我们只要去查看web.xml的模式文件就能知道。直接看模式文件看不懂，可以找一些中文教程来看看。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#4b4b4b;">三.遗留问题</span></p> 
<ol><li style="text-align:left;"><span style="color:#4b4b4b;">在项目中总会遇到一些关于加载的优先级问题，近期也同样遇到过类似的，所以自己查找资 料总结了下，下面有些是转载其他人的，毕竟人家写的不错，自己也就不重复造轮子了，只 是略加点了自己的修饰。 首先可以肯定的是，加载顺序与它们在 web.xml 文件中的先后顺序无关。即不会 因为 filter 写在 listener 的前面而会先加载 filter。最终得出的结论是：listener -&gt; filter -&gt; servlet  。&lt;session-config&gt;&lt;/session-config&gt; 如果某个会话在一定时间内未被访问，服务器可 以抛弃它以节省内存。可通过使用HttpSession的setMaxInactiveInterval方法明确设置单个会话对 象的超时值，或者可利用session-config元素制定缺省超时值。</span></li><li style="text-align:left;"><span style="color:#4b4b4b;">&lt;welcome-file-list&gt;&lt;/welcome-file-list&gt; </span><span style="color:#4b4b4b;">指示服务器在收到引用一个目录名而不是 文件名的URL时，使用哪个文件。</span></li><li style="text-align:left;"><span style="color:#4b4b4b;">web.xml中怎么配置url-pattern？ 首先要知道 web.xml 中url-pattern的作用，他是给外部提供的一个访问DoGetDemo类的接口，你可以自己随意定义，然后在IE里面写入这个配置内容。 可以看我给你写的一个例子图片，应该一下就看懂的，用 SimpleHello.java 为例，看图片，访问的时候，可以输入下面的网址 <a href="http://192.168.0.67:8888/book/hello" rel="nofollow"><span style="color:#6fbc4c;">http://192.168.0.67:8888/book/hello</span></a> 这样，服务器就可以通过 &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; 找到ch06.SimpleHello类，因此你的&lt;url-pattern&gt;&lt;/url-pattern&gt; 里面的内容可以自己定义。然后在应用目录下访问这个servlet 。  </span><img alt="" height="171" src="https://images2.imgbox.com/0c/d5/AOwB1CGd_o.png" width="554"><span style="color:#4b4b4b;">     </span></li><li style="text-align:left;"><span style="color:#4b4b4b;">web.xml</span><span style="color:#4b4b4b;">中既然有url-pattern为什么还需要servlet-class呢？url-pattern是表明什么格式的的url进入这个servlet ，servlet-class  是表明哪个java类来处理这个请求 ，一个请求过来，先到servlet-mapping中去根据请求的url寻找这个url所对应的url-pattern，找到url-pattern后找到了servlet-name， 然后根据servlet-name和servlet中的servlet-name对应找到其所对应的servlet-class，具体的业务逻辑就写在来servlet-class对应的java类中了！</span></li></ol> 
<p> </p> 
<p style="text-align:left;"></p> 
<h2 style="margin-left:0px;text-align:left;"><span style="color:#fe2c24;"><strong>4.Servlet</strong><strong>虚拟路径映射配置详解</strong></span></h2> 
<p></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#ff0000;">Servlet</span></strong><strong><span style="color:#ff0000;">虚拟路径映射</span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">在</span><span style="color:#222222;">web.xml</span><span style="color:#222222;">文件中，一个</span><span style="color:#222222;">&lt;servlet-mapping&gt;</span><span style="color:#222222;">元素用于映射一个</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">的对外访问路径，该路径也称为虚拟路径。例如</span><span style="color:#222222;">&lt;url-pattern&gt;/TestServlet&lt;/url-pattern&gt;</span><span style="color:#222222;">，其中</span><span style="color:#222222;">“/TestServlet”</span><span style="color:#222222;">就是一个虚拟路径。</span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#ff0000;">1.</span></strong><strong><span style="color:#ff0000;">配置多个映射路径</span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">在上一文中，我们说到</span><span style="color:#222222;">@WebServlet</span><span style="color:#222222;">中的</span><span style="color:#222222;">urlPatterns</span><span style="color:#222222;">属性，其可以是一组匹配规则，也就是说一个</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">是可以配置多个虚拟路径的，也就是</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">和虚拟路径可以是一对多的一个关系（并不是多对多，一个虚拟路径只能映射一个</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">），其具体实现如下，并修改</span><span style="color:#222222;">doPost</span><span style="color:#222222;">处的代码：</span></p> 
<pre><code class="language-java">@WebServlet(

        description = "My First Servlet",

        urlPatterns = { "/HelloServlet", "/StillMe" },

        initParams = {

                @WebInitParam(name = "name", value = "lizishu")

        })

public class HelloServlet extends HttpServlet {

 //具体逻辑参看上篇文章

 //...

  

 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        //设置返回客户端的contentType

        //text/plain ：纯文本格式 设置为text/html println的换行会失效

        response.setContentType("text/plain;charset=utf-8");

        //response.setCharacterEncoding("utf-8");

        PrintWriter out = response.getWriter();

        out.println("Served at: " + request.getContextPath());

        String name = this.getInitParameter("name");

        out.println("name: " + name);

        out.println("访问的Servle名为：" + HelloServlet.class);

    }

}</code></pre> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">可以看到，增加一个虚拟路径映射非常方便，只需在</span><span style="color:#222222;">urlPatterns</span><span style="color:#222222;">中新增一项即可（注意</span><span style="color:#222222;">'/'</span><span style="color:#222222;">不可省略），启动项目，在浏览器上输入</span><span style="color:#222222;">url</span><span style="color:#222222;">，可以看到，无论是输入</span><span style="color:#222222;">http://localhost:8080/FirstProject/HelloServlet</span><span style="color:#222222;">、还是</span><span style="color:#222222;">http://localhost:8080/FirstProject/StillMe</span><span style="color:#222222;">页面上得到的输出内容均一致。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​urlPatterns</span><span style="color:#222222;">在</span><span style="color:#222222;">Servlet 3.0</span><span style="color:#222222;">版本之前，都是配置在</span><span style="color:#222222;">web.xml</span><span style="color:#222222;">中的，每个</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">会有一个对应的</span><span style="background-color:#ebf5fd;"><span style="color:#333333;">&lt;servlet-mapping&gt;</span></span><span style="color:#222222;">标签，其中可以配置多个</span><span style="background-color:#ebf5fd;"><span style="color:#333333;">&lt;url-pattern&gt;</span></span><span style="color:#222222;">。</span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#ff0000;">2.urlPatterns</span></strong><strong><span style="color:#ff0000;">匹配规则</span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">说到</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">虚拟路劲的匹配规则，还需要说到</span><span style="color:#222222;">urlPatterns</span><span style="color:#222222;">的几种匹配规则，主要有以下四种：</span></p> 
<ol><li style="text-align:left;"><span style="color:#222222;">精确匹配：也就是我们在上面配置的匹配规则，需要完全相等才能匹配成功，这也是我们经常发生错误的地方，请求Servlet时的大小写拼写错误导致404；</span></li><li style="text-align:left;"><span style="color:#222222;">路径匹配：比如想匹配以</span><span style="color:#222222;">rest</span><span style="color:#222222;">开头的所有请求，可以写成</span><span style="color:#222222;">"/rest/*"</span><span style="color:#222222;">，其格式为以</span><span style="color:#222222;">'/‘</span><span style="color:#222222;">字符开头，并以</span><span style="color:#222222;">'/*'</span><span style="color:#222222;">结尾；</span></li><li style="text-align:left;"><span style="color:#222222;">扩展名匹配：比如想匹配所有以</span><span style="color:#222222;">.do</span><span style="color:#222222;">结尾的请求，可以写成</span><span style="color:#222222;">"*.do"</span><span style="color:#222222;">，其格式为以</span><span style="color:#222222;">'*.'</span><span style="color:#222222;">，后面跟上扩展名；</span></li><li style="text-align:left;"><span style="color:#222222;">缺省匹配：映射路径为</span><span style="color:#222222;">"/"</span><span style="color:#222222;">，那么这个</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">就是当前应用的缺省</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">，默认处理无法匹配到虚拟路径的请求。</span></li></ol> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">需要注意的是，路径匹配和扩展匹配无法混合使用，即</span><span style="color:#222222;">urlPattern</span><span style="color:#222222;">无法写成</span><span style="color:#222222;">"/rest/*.do"</span><span style="color:#222222;">；这也是让部分同学感到困惑的地方，</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">的虚拟路径匹配并不是完全的按照正则来匹配的，虽然路径匹配和扩展匹配是按照正则中的通配符</span><span style="color:#222222;">(*)</span><span style="color:#222222;">来匹配的，这也是部分同学可以会写出特定的正则，但是却不是一个合法的虚拟路径；</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">容器收到请求后，会将请求从上下文路径（通过</span><span style="color:#222222;">request.getContextPath()</span><span style="color:#222222;">获取的）处截断，使用剩余的部分来进行路径匹配，比如请求</span><span style="color:#222222;">url</span><span style="color:#222222;">为</span><span style="color:#222222;">http://localhost:8080/FirstProject/HelloServlet</span><span style="color:#222222;">，那么</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">容器就会使用</span><span style="color:#222222;">"/HelloServlet"</span><span style="color:#222222;">来匹配</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">最后需要注意的是，我们说了上面四种匹配规则，尤其是缺省匹配，可以匹配到任意请求，那么一个请求如果可以匹配多个</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">的虚拟路径，那么该执行哪个</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">？其实啊，这些匹配规则是有优先级的，具体的优先级为：精确匹配</span><span style="color:#222222;">&gt;</span><span style="color:#222222;">路径匹配</span><span style="color:#222222;">&gt;</span><span style="color:#222222;">扩展名匹配</span><span style="color:#222222;">&gt;</span><span style="color:#222222;">缺省匹配，</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">容器会从优先级高的虚拟路径开始匹配，匹配到后就会立刻将请求交给对应的</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">来处理，不会再关心其他</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">的虚拟路径是否会匹配成功。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">下面我们来一组</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">及其对应的虚拟路径：</span></p> 
<table border="1" cellspacing="0"><thead><tr><td style="background-color:#cae8ea;border-color:#c1dad7;"> <p style="margin-left:0;text-align:left;"><strong>urlPatterns</strong></p> </td><td style="background-color:#cae8ea;border-color:#c1dad7;"> <p style="margin-left:0;text-align:left;"><strong><span style="color:#000000;">Servlet Name</span></strong></p> </td></tr></thead><tbody><tr><td style="border-color:#c1dad7;"> <p style="margin-left:0;text-align:left;">/abc/*</p> </td><td> <p style="margin-left:0;text-align:left;">Servlet1</p> </td></tr><tr><td style="background-color:#f5fafa;border-color:#c1dad7;"> <p style="margin-left:0;text-align:left;"><span style="color:#000000;">/</span></p> </td><td style="background-color:#f5fafa;"> <p style="margin-left:0;text-align:left;"><span style="color:#000000;">Servlet2</span></p> </td></tr><tr><td style="border-color:#c1dad7;"> <p style="margin-left:0;text-align:left;">/abc</p> </td><td> <p style="margin-left:0;text-align:left;">Servlet3</p> </td></tr><tr><td style="background-color:#f5fafa;border-color:#c1dad7;"> <p style="margin-left:0;text-align:left;"><span style="color:#000000;">*.do</span></p> </td><td style="background-color:#f5fafa;"> <p style="margin-left:0;text-align:left;"><span style="color:#000000;">Servlet4</span></p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">当请求去除上下文路径后路径为：</span><span style="color:#222222;">"/abc/a.html"</span><span style="color:#222222;">时，根据上述规则，会调用</span><span style="color:#222222;">Servlet1</span><span style="color:#222222;">；</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">请求为：</span><span style="color:#222222;">"/abc"</span><span style="color:#222222;">，根据匹配优先级，会调用</span><span style="color:#222222;">Servlet3</span><span style="color:#222222;">；</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">请求为：</span><span style="color:#222222;">"/abc/a.do"</span><span style="color:#222222;">，会匹配到</span><span style="color:#222222;">'/abc/*'</span><span style="color:#222222;">、</span><span style="color:#222222;">'*.do'</span><span style="color:#222222;">，但根据匹配优先级，会调用</span><span style="color:#222222;">Servlet1</span><span style="color:#222222;">；</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">请求为：</span><span style="color:#222222;">"/a.do"</span><span style="color:#222222;">，会匹配到</span><span style="color:#222222;">'/'</span><span style="color:#222222;">、</span><span style="color:#222222;">'*.do'</span><span style="color:#222222;">，但根据匹配优先级，会调用</span><span style="color:#222222;">Servlet4</span><span style="color:#222222;">；</span></p> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#ff0000;">3.Tomcat</span></strong><strong><span style="color:#ff0000;">提供的缺省</span></strong><strong><span style="color:#ff0000;">Servlet</span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">为了测试缺省</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">，我们来进行一个测试。我们新建个</span><span style="color:#222222;">SelfDefaultServlet</span><span style="color:#222222;">，其</span><span style="color:#222222;">urlPatterns</span><span style="color:#222222;">我们配置为</span><span style="color:#222222;">"/"</span><span style="color:#222222;">，其中的方法我们不做任何修改。</span></p> 
<pre><code class="language-java">@WebServlet(

        description = "Self create default Servlet",

        urlPatterns = { "/" }

        )

public class SelfDefaultServlet extends HttpServlet {

 //...

}</code></pre> 
<p style="margin-left:0;text-align:center;"><span style="color:#222222;">我们启动项目后，在浏览器上输入http://localhost:8080/FirstProject/hahaha</span><span style="color:#222222;">或者其他任意无法匹配到</span><span style="color:#222222;">HelloServlet</span><span style="color:#222222;">虚拟路径的请求，发现页面上的结果都如下所示，是不是这样也不错，不会报404错误了。</span><img alt="" height="120" src="https://images2.imgbox.com/e2/5d/sy9PgUpO_o.png" width="554"></p> 
<p> </p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">但是，此时我们想访问</span><span style="color:#222222;">WebContent</span><span style="color:#222222;">目录下的静态页面（新建的一个</span><span style="color:#222222;">welcome.html</span><span style="color:#222222;">文件），浏览器上输入</span><span style="color:#222222;">http://localhost:8080/FirstProject/welcome.html</span><span style="color:#222222;">，猜猜会发生什么？我们来一起看下结果，如图所示，请求结果并没有按照我们的想法，根据请求路径找到</span><span style="color:#222222;">welcome.htm</span><span style="color:#222222;">页面，而是调用了SelfDefaultServlet，是不是很懵？</span><img alt="" height="101" src="https://images2.imgbox.com/a1/84/AzCQxdra_o.png" width="554"></p> 
<p> </p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">其实，客户端的每个请求，都是由</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">容器根据虚拟路径的匹配规则来进行处理的，包括静态资源。并且，如果路径输入错误（去除了自己配置的缺省</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">后），我们常见的下面的错误，也是Servlet返回给我们，哈哈，还是很意外？</span><img alt="" height="251" src="https://images2.imgbox.com/40/6d/CbbtWHbB_o.png" width="554"></p> 
<p> </p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">我们能通过</span><span style="color:#222222;">servlet</span><span style="color:#222222;">方便简单的开发网站，是因为我们站在了巨人的肩膀上，下面我们一起来看下</span><span style="color:#222222;">Sun</span><span style="color:#222222;">公司都为我们开发者提前做了些什么工作。</span><span style="color:#222222;">Tomcat</span><span style="color:#222222;">会为项目配置一个缺省的</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">（如果项目中自行配置，则不会生效），配置文件在</span><span style="color:#222222;">tomcat</span><span style="color:#222222;">安装目录下</span><span style="color:#222222;">conf</span><span style="color:#222222;">目录中的</span><span style="color:#222222;">web.xml</span><span style="color:#222222;">文件中，具体内容如下，缺省的</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">名为</span><span style="color:#222222;">DefaultServlet</span><span style="color:#222222;">。</span></p> 
<pre><code class="language-java">&lt;servlet&gt;

 &lt;servlet-name&gt;default&lt;/servlet-name&gt;

 &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;

 &lt;init-param&gt;

  &lt;param-name&gt;debug&lt;/param-name&gt;

  &lt;param-value&gt;0&lt;/param-value&gt;

 &lt;/init-param&gt;

 &lt;init-param&gt;

  &lt;param-name&gt;listings&lt;/param-name&gt;

  &lt;param-value&gt;false&lt;/param-value&gt;

 &lt;/init-param&gt;

 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;

&lt;/servlet&gt;

&lt;servlet-mapping&gt;

 &lt;servlet-name&gt;default&lt;/servlet-name&gt;

 &lt;url-pattern&gt;/&lt;/url-pattern&gt;

&lt;/servlet-mapping&gt;</code></pre> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">客户端请求静态资源文件时，也是由缺省的</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">处理的（自己单独配置</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">除外），如果请求文件能找到，就会将页面通过</span><span style="color:#222222;">HttpServletResponse</span><span style="color:#222222;">对象以流的方式返回给客户端，否则报</span><span style="color:#222222;">404</span><span style="color:#222222;">错误。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">不过讲到这里，大家可以自己试一试配置了缺省</span><span style="color:#222222;">Servelt</span><span style="color:#222222;">时，访问</span><span style="color:#222222;">welcome.html</span><span style="color:#222222;">的情况（会调用</span><span style="color:#222222;">SelfDefaultServlet</span><span style="color:#222222;">），但是，如果我们在浏览器中输入</span><span style="color:#222222;">http://localhost:8080/FirstProject/index.jsp</span><span style="color:#222222;">（</span><span style="color:#222222;">index.jsp</span><span style="color:#222222;">是创建的第一个</span><span style="color:#222222;">jsp</span><span style="color:#222222;">页面）呢？会是什么样一个结果？也是调用缺省的</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">么？真是的运行结果如下：</span></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="171" src="https://images2.imgbox.com/0f/32/rJvgEo2x_o.png" width="554"></p> 
<p> </p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">这是什么原因？为什么不是调用缺省的</span><span style="color:#222222;">servlet</span><span style="color:#222222;">了？这是因为</span><span style="color:#222222;">tomcat</span><span style="color:#222222;">除了缺省</span><span style="color:#222222;">Serlvet</span><span style="color:#222222;">外，还给我们提供一个处理</span><span style="color:#222222;">jsp</span><span style="color:#222222;">文件的</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">，配置如下，因为后缀匹配的优先级高于缺省的</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">，所以访问</span><span style="color:#222222;">JSP</span><span style="color:#222222;">的时候需要交由</span><span style="color:#222222;">JspServlet</span><span style="color:#222222;">来处理（</span><span style="color:#222222;">JSP</span><span style="color:#222222;">因为可能包含</span><span style="color:#222222;">Java</span><span style="color:#222222;">代码，所以第一次执行的时候需要先编译，这个工作由</span><span style="color:#222222;">JspServlet</span><span style="color:#222222;">完成）</span></p> 
<pre><code class="language-java">&lt;servlet&gt;  
&lt;servlet-name&gt;jsp&lt;/servlet-name&gt; 
&lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; 
&lt;init-param&gt;  &lt;param-name&gt;fork&lt;/param-name&gt;  
&lt;param-value&gt;false&lt;/param-value&gt; 
&lt;/init-param&gt; 
&lt;init-param&gt;  
&lt;param-name&gt;xpoweredBy&lt;/param-name&gt; 
 &lt;param-value&gt;false&lt;/param-value&gt; 
&lt;/init-param&gt; 
&lt;load-on-startup&gt;3&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt; 
&lt;servlet-name&gt;jsp&lt;/servlet-name&gt; 
&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; 
&lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre> 
<p style="margin-left:0;text-align:left;"><strong><span style="color:#ff0000;">4.</span></strong><strong><span style="color:#ff0000;">总结</span></strong></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">​</span><span style="color:#222222;">本文具体讨论了</span><span style="color:#222222;">urlPatterns</span><span style="color:#222222;">属性的匹配规则，主要为四种，其优先级也各不相同，我们在使用时，也需要根据自己的需求自己设定</span><span style="color:#222222;">urlPatterns</span><span style="color:#222222;">，不过知道了匹配规则，使用起来也会方便很多，也能帮我们快速的定位错误。</span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#222222;">到此这篇关于</span><span style="color:#222222;">Servlet</span><span style="color:#222222;">虚拟路径映射配置详解的文章就介绍到这了</span><span style="color:#222222;">,</span><span style="color:#222222;">更多相关</span><span style="color:#222222;">Servlet </span><span style="color:#222222;">虚拟路径映射内容请搜索脚本之家以前的文章或继续浏览下面的相关文章希望大家以后多多支持脚本之家！</span></p> 
<h2 style="margin-left:0;"><span style="background-color:#ffffff;"><strong><span style="color:#444444;">5.ServletConfig</span><span style="color:#444444;">和ServletContext）</span></strong></span></h2> 
<h3 style="margin-left:0cm;"><span style="background-color:#ffffff;"><strong><span style="color:#444444;">ServletConfig</span><span style="color:#444444;">接口</span></strong></span></h3> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">在运行 Servlet 程序时，可能需要一些辅助信息，例如，文件使用的编码、使用 Servlet 程序的共享信息等，这些信息可以在 web.xml 文件中使用一个或多个 &lt;init-param&gt; 元素进行配置。当 Tomcat 初始化一个 Servlet 时，会将该 Servlet 的配置信息封装到 ServletConfig 对象中，此时可以通过调用 init（ServletConfig config）方法将 ServletConfig 对象传递给 Servlet。<br><br> ServletConfig 接口中定义了一系列获取配置信息的方法，如表 1 所示。</span></span></p> 
<table border="1" cellspacing="0"><thead><tr><td colspan="2" style="background-color:#ededed;"> <p style="margin-left:0;text-align:center;">表<span style="color:#000000;"> 1 ServletConfig</span><span style="color:#000000;">接口的常用方法</span></p> </td></tr><tr><td style="background-color:#ededed;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><strong><span style="color:#444444;">方法说明</span></strong></p> </td><td style="background-color:#ededed;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><strong><span style="color:#444444;">功能描述</span></strong></p> </td></tr></thead><tbody><tr><td style="border-color:#cccccc;"> <p style="margin-left:0;text-align:left;">String getInitParameter(String name)</p> </td><td> <p style="margin-left:0;text-align:justify;">根据初始化参数名返回对应的初始化参数值</p> </td></tr><tr><td style="border-color:#cccccc;"> <p style="margin-left:0;text-align:justify;">Enumeration getInitParameterNames()</p> </td><td> <p style="margin-left:0;text-align:justify;">返回一个 Enumeration 对象，其中包含了所有的初始化参数名</p> </td></tr><tr><td style="border-color:#cccccc;"> <p style="margin-left:0;text-align:justify;">ServletContext getServletContext()</p> </td><td> <p style="margin-left:0;text-align:justify;">返回一个代表当前 Web 应用的 ServletContext 对象</p> </td></tr><tr><td style="border-color:#cccccc;"> <p style="margin-left:0;text-align:justify;">String getServletName()</p> </td><td> <p style="margin-left:0;text-align:justify;">返回 Servlet 的名字，即 web.xml 中 &lt;servlet-name&gt;元素的值</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;"></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#444444;">2</span><span style="color:#444444;">）配置参数信息</span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">在 web.xml 文件中为 Servlet 配置一些参数信息，具体的配置代码如下所示：</span></span></p> 
<pre><code class="language-java">&lt;servlet&gt;

  &lt;servlet-name&gt;TestServlet02&lt;/servlet-name&gt;

 &lt;servlet-class&gt;com.mengma.servlet.TestServlet02&lt;/servlet-class&gt;

 &lt;init-param&gt;

      &lt;param-name&gt;encoding&lt;/param-name&gt;

      &lt;param-value&gt;UTF-8&lt;/param-value&gt;

  &lt;/init-param&gt;

&lt;/servlet&gt;

&lt;servlet-mapping&gt;

  &lt;servlet-name&gt;TestServlet02&lt;/servlet-name&gt;  &lt;url-pattern&gt;/TestServlet02&lt;/url-pattern&gt;

&lt;/servlet-mapping&gt;</code></pre> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">在上面的参数信息中，&lt;init-param&gt; 节点表示要设置的参数，该节点中的 &lt;param-name&gt; 表示参数的名称，&lt;param-value&gt; 表示参数的值，在 &lt;init-param&gt; 节点中为 TestServlet02 配置了一个名为 encoding 的参数，并设置其参数的值为 UTF-8。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#444444;">3</span><span style="color:#444444;">）运行项目并查看结果</span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">启动 Tomcat 服务器，在浏览器的地址栏中输入地址 http://localhost:8080/servletDemo01/TestServlet02 访问 TestServlet02，结果如图 1 所示。</span></span></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="129" src="https://images2.imgbox.com/df/4e/hgcCuH52_o.png" width="554"><br><span style="background-color:#ffffff;"><span style="color:#444444;">图 1  运行结果</span></span></p> 
<p> </p> 
<p style="margin-left:0;text-align:left;"><br><span style="background-color:#ffffff;"><span style="color:#444444;">从图 1 中可以看出，web.xml 文件中为 TestServlet02 配置的编码信息被读取了出来。由此可见，通过 ServletConfig 对象可以获得 web.xml 文件中的参数信息。</span></span></p> 
<h3 style="margin-left:0cm;"><span style="background-color:#ffffff;"><strong><span style="color:#444444;">ServletContext</span><span style="color:#444444;">接口</span></strong></span></h3> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">当 Tomcat 启动时，Tomcat 会为每个 Web 应用创建一个唯一的 ServletContext 对象代表当前的 Web 应用，该对象封装了当前 Web 应用的所有信息。可以利用该对象获取 Web 应用程序的初始化信息、读取资源文件等。下面对 ServletContext 接口的不同作用分别进行讲解。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#444444;">1. </span><span style="color:#444444;">获取 Web 应用程序的初始化参数</span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">在 web.xml 文件中，不仅可以配置 Servlet 的映射信息，还可以配置整个 Web 应用的初始化信息。Web 应用初始化参数的配置方式具体如下所示：</span></span></p> 
<pre><code class="language-java">&lt;context-param&gt;

 &lt;param-name&gt;XXX&lt;/param-name&gt;

    &lt;param-value&gt;xxx&lt;/param-value&gt;

&lt;/context-param&gt;

&lt;context-param&gt;

    &lt;param-name&gt;AAA&lt;/param-name&gt;

   &lt;param-value&gt;aaa&lt;/param-value&gt;

&lt;/context-param&gt;</code></pre> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">在上面的示例中，&lt;context-param&gt; 元素位于根元素 &lt;web-app&gt; 中，它的子元素 &lt;param-name&gt; 和 &lt;param-value&gt; 分别用于指定参数的名字和参数值。要想获取这些参数名和参数值的信息，可以使用 ServletContext 接口中定义的 getInitParameterNames() 和 getInitParameter（String name）方法分别获取。<br><br> 下面通过案例演示如何使用 ServletContext 接口获取 Web 应用程序的初始化参数。<br><br> 1）在 servletDemo01 项目的 web.xml 文件中配置初始化参数信息和 Servlet 信息，其代码如下所示：</span></span></p> 
<pre><code class="language-java">&lt;context-param&gt;

    &lt;param-name&gt;username&lt;/param-name&gt;

    &lt;param-value&gt;admin&lt;/param-value&gt;

&lt;/context-param&gt;

&lt;context-param&gt;

    &lt;param-name&gt;password&lt;/param-name&gt;

    &lt;param-value&gt;1234&lt;/param-value&gt;

&lt;/context-param&gt;

&lt;servlet&gt;

   &lt;servlet-name&gt;TestServlet03&lt;/servlet-name&gt;

    &lt;servlet-class&gt;com.mengma.servlet.TestServlet03&lt;/servlet-class&gt;

&lt;/servlet&gt;

&lt;servlet-mapping&gt;

   &lt;servlet-name&gt;TestServlet03&lt;/servlet-name&gt;

    &lt;url-pattern&gt;/TestServlet03&lt;/url-pattern&gt;

&lt;/servlet-mapping&gt;</code></pre> 
<p style="margin-left:0;text-align:justify;"><br><span style="background-color:#ffffff;"><span style="color:#444444;">2</span><span style="color:#444444;">）在项目的 com.mengma.servlet 包中创建一个名称为 TestServlet03 的类，该类中使用 ServletContext 接口获取 web.xml 中的配置信息，如下所示。</span></span></p> 
<pre><code class="language-java">package com.mengma.servlet;



import java.io.IOException;

import java.io.PrintWriter;

import java.util.Enumeration;



import javax.servlet.ServletContext;

import javax.servlet.ServletException;

import javax.servlet.http.HttpServlet;

import javax.servlet.http.HttpServletRequest;

import javax.servlet.http.HttpServletResponse;



public class TestServlet03 extends HttpServlet {
   public void doGet(HttpServletRequest request, HttpServletResponse response)

      throws ServletException, IOException {



        response.setContentType("text/html;charset=utf-8");

        PrintWriter out = response.getWriter();

        // 得到ServletContext对象

      ServletContext context = this.getServletContext();       // 得到包含所有初始化参数名的Enumeration对象

        Enumeration&lt;String&gt; paramNames = context.getInitParameterNames();

        // 遍历所有的初始化参数名，得到相应的参数值并打印

        while (paramNames.hasMoreElements()) {

          String name = paramNames.nextElement();

          String value = context.getInitParameter(name);

          out.println(name + ":" + value);

          out.println("&lt;br/&gt;");

    }

}



    public void doPost(HttpServletRequest request, HttpServletResponse response)

     throws ServletException, IOException {

        this.doGet(request, response);

    }

}</code></pre> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">上述代码中，当通过 this.getServletContext() 方法获取到 ServletContext 对象后，首先调用 getInitParameterNames() 方法，获取到包含所有初始化参数名的 Enumeration 对象，然后遍历 Enumeration 对象，根据获取到的参数名，通过 getInitParamter（String name）方法得到对应的参数值。<br><br> 3）启动 Tomcat 服务器，在浏览器的地址栏中输入地址 http://localhost:8080/servletDemo01/TestServlet03 访问 TestServlet03，浏览器的显示结果如图 2 所示。</span></span></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="163" src="https://images2.imgbox.com/f4/63/ELpyK9bo_o.png" width="554"><br><span style="background-color:#ffffff;"><span style="color:#444444;">图 2  运行结果</span></span></p> 
<p> </p> 
<p style="margin-left:0;text-align:left;"><br><span style="background-color:#ffffff;"><span style="color:#444444;">从图 2 中可以看出，web.xml 文件中配置的信息被读取了出来。由此可见，通过 ServletContext 对象可以获取 Web 应用的初始化参数。</span></span></p> 
<p><span style="background-color:#ffffff;"><strong><span style="color:#444444;">2. </span><span style="color:#444444;">读取 Web 应用下的资源文件</span></strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">在实际开发中，有时会需要读取 Web 应用中的一些资源文件，如配置文件和日志文件等。为此，在 ServletContext 接口中定义了一些读取 Web 资源的方法，这些方法是依靠 Servlet 容器实现的。Servlet 容器根据资源文件相对于 Web 应用的路径，返回关联资源文件的 I/O 流或资源文件在系统的绝对路径等。<br><br> 表 2 中列举了 ServletContext 接口中用于获取资源路径的相关方法。</span></span></p> 
<table border="1" cellspacing="0"><thead><tr><td colspan="2" style="background-color:#ededed;"> <p style="margin-left:0;text-align:center;">表<span style="color:#000000;"> 2 ServletContext</span><span style="color:#000000;">接口的常用方法</span></p> </td></tr><tr><td style="background-color:#ededed;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><strong><span style="color:#444444;">方法说明</span></strong></p> </td><td style="background-color:#ededed;border-color:#cccccc;"> <p style="margin-left:0;text-align:center;"><strong><span style="color:#444444;">功能描述</span></strong></p> </td></tr></thead><tbody><tr><td style="border-color:#cccccc;"> <p style="margin-left:0;text-align:left;">Set getResourcePaths(String path)</p> </td><td> <p style="margin-left:0;text-align:justify;"><br> 返回一个 Set 集合，集合中包含资源目录中子目录和文件的路径名 称。参数 path 必须以正斜线（/）开始，指定匹配资源的部分路径</p> </td></tr><tr><td style="border-color:#cccccc;"> <p style="margin-left:0;text-align:justify;">String getRealPath(String path) </p> </td><td> <p style="margin-left:0;text-align:justify;">返回资源文件在服务器文件系统上的真实路径（文件的绝对路径）。参数 path 代表资源文件的虚拟路径，它应该以正斜线（/）开始，/ 表示当前 Web 应用的根目录，如果 Servlet 容器不能将虚拟路径转换为文 件系统的真实路径，则返回 null</p> </td></tr><tr><td style="border-color:#cccccc;"> <p style="margin-left:0;text-align:justify;"><br> URL getResource(String path)</p> </td><td> <p style="margin-left:0;text-align:justify;">返回映射到某个资源文件的 URL 对象。参数 path 必须以正斜线（/）开始，/ 表示当前 Web 应用的根目录</p> </td></tr><tr><td style="border-color:#cccccc;"> <p style="margin-left:0;text-align:justify;">InputStream getResourceAsStream(String path)</p> </td><td> <p style="margin-left:0;text-align:justify;">返回映射到某个资源文件的 InputStream 输入流对象。参数 path 的传递规则和 getResource() 方法完全一致</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">了解了 ServletContext 接口中用于获得 Web 资源路径的方法后，下面通过案例分步骤演示如何使用 ServletContext 对象读取资源文件。<br><br> 案例分步骤演示如何使用 ServletContext 对象读取资源文件。<br><br> 1）在 servletDemo01 项目的 src 目录中创建一个名称为 itcast.properties 的文件，在创建好的文件中输入如下所示的配置信息：</span></span></p> 
<div> 
 <p style="margin-left:0cm;"><span style="background-color:#f8f8f8;"><span style="background-color:#f8f8f8;"><span style="color:#444444;">username=admin<br> password=1234</span></span></span></p> 
</div> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">2</span><span style="color:#444444;">）在 com.mengma.servlet 包中创建一个名称为 TestServlet04 的 Servlet 类，使用该类读取 itcast.properties 资源文件的内容，其实现代码如下所示。</span></span></p> 
<pre><code class="language-java">package com.mengma.servlet;



import java.io.IOException;

import java.io.InputStream;

import java.io.PrintWriter;

import java.util.Properties;



import javax.servlet.ServletContext;

import javax.servlet.ServletException;

import javax.servlet.http.HttpServlet;

import javax.servlet.http.HttpServletRequest;

import javax.servlet.http.HttpServletResponse;



public class TestServlet04 extends HttpServlet {

​​​​​​​    public void doGet(HttpServletRequest request, HttpServletResponse response)

        throws ServletException, IOException {



       response.setContentType("text/html;charset=utf-8");

        ServletContext context = this.getServletContext();

        PrintWriter out = response.getWriter();      // 获取相对路径中的输入流对象

        InputStream in = context           .getResourceAsStream("/WEB-INF/classes/itcast.properties");

        Properties pros = new Properties();

        pros.load(in);

       out.println("username=" + pros.getProperty("username") + "&lt;br/&gt;");

        out.println("password=" + pros.getProperty("password") + "&lt;br/&gt;");

    }



    public void doPost(HttpServletRequest request, HttpServletResponse response)

      throws ServletException, IOException {



      this.doGet(request, response);   }

}</code></pre> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#444444;">在上述代码中，使用 ServletContext 的 getResourceAsStream（String path）方法获得了关联 itcast.properties 资源文件的输入流对象，其中的 path 参数必须以正斜线（/）开始，表示 itcast.properties 文件相对于 Web 应用的相对路径。<br><br> 3）启动 Tomcat 服务器，在浏览器的地址栏中输入地址 http://localhost:8080/servletDemo01/TestServlet04 访问 TestServlet04，浏览器的显示结果如图 3 所示。</span></span></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="163" src="https://images2.imgbox.com/60/3e/5d9uqF7B_o.png" width="554"><br><span style="background-color:#ffffff;"><span style="color:#444444;">图 3  运行结果</span></span></p> 
<p> </p> 
<p style="margin-left:0;text-align:left;"><br><span style="background-color:#ffffff;"><span style="color:#444444;">从图 3 中可以看出，itcast.properties 资源文件中的内容已经被读取了出来。由此可见，使用 ServletContext 可以读取 Web 应用中的资源文件。</span></span></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71695cc2dd694d64b988ea09b521d8da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win7系统开启打印机共享服务器,win7中打印机共享 服务器设置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/496ea849cdda3fecc21aaae165805110/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">两台服务器设置免密协议,【Linux】两台服务器ssh免密登录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>