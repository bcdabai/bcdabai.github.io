<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot 3.0最低版本要求的JDK 17，这几个新特性不能不知道 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot 3.0最低版本要求的JDK 17，这几个新特性不能不知道" />
<meta property="og:description" content="最近，有很多人在传说 SpringBoot要出3.0的版本了，并且宣布不再支持 Java 8，最低要求是 Java 17了。
其实，早在2021年9月份，关于 Spring Framework 6.0的消息出来的时候，Spring 官方就已经明确了不会向下兼容，最低的 JDK 版本是 JDK 17。
2022年，Spring Framework 6.0和 SpringBoot 3.0都会推出，在此之前，Java社区很坚挺，一直是&#34;新版任你发，我用Java 8&#34;，不管新版本怎么出，很少有人愿意升级。
这一次，Spring 直接来了个大招，跨过 JDK 8-16，直接升级到 JDK 17 ，不知道会对 Java生态产生怎样的影响。
为什么是 Java 17
这么多新版本的 JDK，而且2022年还会推出 JDK 18 和 JDK 19，为什么 Spring 选择了 JDK 17呢。
主要是因为他是一个 LTS版本，所谓 LTS，是 Long Term Support，也就是官方保证会长期支持的版本。
从 JDK 诞生到现在，还在长期支持的版本主要有 JDK 7、JDK 8 、JDK 11以及 JDK 17
这一次 Spring直接跨越了 JDK 11，升级到 JDK 17，主要的考虑应该是因为JDK 17有更多的新特性支持。
接下来我们介绍几个新特性，这些新特性都是我们开发者息息相关的，或者说是会影响我们写代码的。
JDK 17 支持的新特性" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6eda19d0b8af611465d35a7edaba2cdb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-28T15:20:07+08:00" />
<meta property="article:modified_time" content="2022-02-28T15:20:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot 3.0最低版本要求的JDK 17，这几个新特性不能不知道</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>最近，有很多人在传说 SpringBoot要出3.0的版本了，并且宣布不再支持 Java 8，最低要求是 Java 17了。</p> 
<p>其实，早在2021年9月份，关于 Spring Framework 6.0的消息出来的时候，Spring 官方就已经明确了不会向下兼容，最低的 JDK 版本是 JDK 17。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/43/ab/NNfa03BY_o.png"></p> 
<p>2022年，Spring Framework 6.0和 SpringBoot 3.0都会推出，在此之前，Java社区很坚挺，一直是"新版任你发，我用Java 8"，不管新版本怎么出，很少有人愿意升级。</p> 
<p>这一次，Spring 直接来了个大招，跨过 JDK 8-16，直接升级到 JDK 17 ，不知道会对 Java生态产生怎样的影响。</p> 
<p>为什么是 Java 17</p> 
<p>这么多新版本的 JDK，而且2022年还会推出 JDK 18 和 JDK 19，为什么 Spring 选择了 JDK 17呢。</p> 
<p>主要是因为他是一个 LTS版本，所谓 LTS，是 Long Term Support，也就是官方保证会长期支持的版本。</p> 
<p>从 JDK 诞生到现在，还在长期支持的版本主要有 JDK 7、JDK 8 、JDK 11以及 JDK 17</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e2/af/52WxnbVE_o.png"></p> 
<p>这一次 Spring直接跨越了 JDK 11，升级到 JDK 17，主要的考虑应该是因为JDK 17有更多的新特性支持。</p> 
<p>接下来我们介绍几个新特性，这些新特性都是我们开发者息息相关的，或者说是会影响我们写代码的。</p> 
<p>JDK 17 支持的新特性</p> 
<p>这里所谓的新特性，不只是 JDK 17中新增的，而是 JDK 17和 JDK 8相比，新增的特性。</p> 
<p><strong>本地变量类型推断</strong></p> 
<p>在Java 10之前版本中，我们想定义定义局部变量时。我们需要在赋值的左侧提供显式类型，并在赋值的右边提供实现类型：</p> 
<pre>    MyObject value = new MyObject();</pre> 
<p>在Java 10中，提供了本地变量类型推断的功能，可以通过var声明变量：</p> 
<pre>    var value = new MyObject();</pre> 
<p>本地变量类型推断将引入“var”关键字，而不需要显式的规范变量的类型。</p> 
<p>其实，所谓的本地变量类型推断，也是Java 10提供给开发者的语法糖。</p> 
<p>虽然我们在代码中使用var进行了定义，但是对于虚拟机来说他是不认识这个var的，在java文件编译成class文件的过程中，会进行解糖，使用变量真正的类型来替代var（详细信息可以参考： <a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650120932&amp;idx=1&amp;sn=0bb6261ea9f4441ee769e605a84ceab2&amp;chksm=f36bbfc5c41c36d3ff1d8cdd25ea7e49f10c68eba5c8672689f4aff17c42f1f6cd305a841303&amp;scene=21#wechat_redirect" rel="nofollow" title="我反编译了Java 10的本地变量类型推断 ">我反编译了Java 10的本地变量类型推断 </a>）</p> 
<p><strong>Switch 表达式</strong></p> 
<p>在JDK 12中引入了Switch表达式作为预览特性。并在Java 13中修改了这个特性，引入了yield语句，用于返回值。</p> 
<p>而在之后的Java 14中，这一功能正式作为标准功能提供出来。</p> 
<p>在以前，我们想要在switch中返回内容，还是比较麻烦的，一般语法如下：</p> 
<pre>    int i;     switch (x) {         case "1":             i=1;             break;         case "2":             i=2;             break;         default:             i = x.length();             break;     }</pre> 
<p>在JDK13中使用以下语法：</p> 
<pre>    int i = switch (x) {         case "1" -&gt; 1;         case "2" -&gt; 2;         default -&gt; {             int len = args[1].length();             yield len;         }     };</pre> 
<p>或者</p> 
<pre>    int i = switch (x) {         case "1": yield 1;         case "2": yield 2;         default: {             int len = args[1].length();             yield len;         }     };</pre> 
<p>在这之后，switch中就多了一个关键字用于跳出switch块了，那就是yield，他用于返回一个值。</p> 
<p>和return的区别在于：return会直接跳出当前循环或者方法，而yield只会跳出当前switch块。</p> 
<p><strong>Text Blocks</strong></p> 
<p>Java 13中提供了一个Text Blocks的预览特性，并且在Java 14中提供了第二个版本的预览。</p> 
<p>text block，文本块，是一个多行字符串文字，它避免了对大多数转义序列的需要，以可预测的方式自动格式化字符串，并在需要时让开发人员控制格式。</p> 
<p>我们以前从外部copy一段文本串到Java中，会被自动转义，如有一段以下字符串：</p> 
<pre>     &lt;html&gt;       &lt;body&gt;           &lt;p&gt;Hello, world&lt;/p&gt;       &lt;/body&gt;     &lt;/html&gt;</pre> 
<p>将其复制到Java的字符串中，会展示成以下内容：</p> 
<pre>    "&lt;html&gt;\n" +     "    &lt;body&gt;\n" +     "        &lt;p&gt;Hello, world&lt;/p&gt;\n" +     "    &lt;/body&gt;\n" +     "&lt;/html&gt;\n";</pre> 
<p>即被自动进行了转义，这样的字符串看起来不是很直观，在JDK 13中，就可以使用以下语法了：</p> 
<pre>    """     &lt;html&gt;       &lt;body&gt;           &lt;p&gt;Hello, world&lt;/p&gt;       &lt;/body&gt;     &lt;/html&gt;     """;</pre> 
<p>使用“”“作为文本块的开始符和结束符，在其中就可以放置多行的字符串，不需要进行任何转义。看起来就十分清爽了。</p> 
<p>如常见的SQL语句：</p> 
<pre>    String query = """         SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`         WHERE `CITY` = 'INDIANAPOLIS'         ORDER BY `EMP_ID`, `LAST_NAME`;     """;</pre> 
<p>看起来就比较直观，清爽了。</p> 
<p><strong>Records</strong></p> 
<p>Java 14 中便包含了一个新特性：EP 359: Records，</p> 
<p>Records的目标是扩展Java语言语法，Records为声明类提供了一种紧凑的语法，用于创建一种类中是“字段，只是字段，除了字段什么都没有”的类。</p> 
<p>通过对类做这样的声明，编译器可以通过自动创建所有方法并让所有字段参与hashCode()等方法。这是JDK 14中的一个预览特性。</p> 
<p>使用record关键字可以定义一个记录：</p> 
<pre>    record Person (String firstName, String lastName) {}</pre> 
<p>record 解决了使用类作为数据包装器的一个常见问题。纯数据类从几行代码显著地简化为一行代码。（详见： <a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650126853&amp;idx=1&amp;sn=afb1a14bca5ab3abc27d54e310854535&amp;chksm=f36ba724c41c2e3267bff4d0d4ed6b3ed6ea4563521d706943d8f887d4fc6e879fd4fd7937e8&amp;scene=21#wechat_redirect" rel="nofollow" title="Java 14 发布了，不使用”class”也能定义类了？还顺手要干掉Lombok！ ">Java 14 发布了，不使用”class”也能定义类了？还顺手要干掉Lombok！ </a>）</p> 
<p><strong>封闭类</strong></p> 
<p>在Java 15之前，Java认为"代码重用"始终是一个终极目标，所以，一个类和接口都可以被任意的类实现或继承。</p> 
<p>但是，在很多场景中，这样做是容易造成错误的，而且也不符合物理世界的真实规律。</p> 
<p>例如，假设一个业务领域只适用于汽车和卡车，而不适用于摩托车。</p> 
<p>在Java中创建Vehicle抽象类时，应该只允许Car和Truck类扩展它。</p> 
<p>通过这种方式，我们希望确保在域内不会出现误用Vehicle抽象类的情况。</p> 
<p>为了解决类似的问题，在Java 15中引入了一个新的特性——密闭。</p> 
<p>想要定义一个密闭接口，可以将sealed修饰符应用到接口的声明中。然后，permit子句指定允许实现密闭接口的类：</p> 
<pre>    public sealed interface Service permits Car, Truck {     }</pre> 
<p>以上代码定义了一个密闭接口Service，它规定只能被Car和Truck两个类实现。</p> 
<p>与接口类似，我们可以通过使用相同的sealed修饰符来定义密闭类：</p> 
<pre>    public abstract sealed class Vehicle permits Car, Truck {     }</pre> 
<p>通过密闭特性，我们定义出来的Vehicle类只能被Car和Truck继承。</p> 
<p><strong>instanceof 模式匹配</strong></p> 
<p>instanceof是Java中的一个关键字，我们在对类型做强制转换之前，会使用instanceof做一次判断，例如：</p> 
<pre>    if (animal instanceof Cat) {         Cat cat = (Cat) animal;         cat.miaow();     } else if (animal instanceof Dog) {         Dog dog = (Dog) animal;         dog.bark();     }</pre> 
<p>Java 14带来了改进版的instanceof操作符，这意味着我们可以用更简洁的方式写出之前的代码例子：</p> 
<pre>    if (animal instanceof Cat cat) {         cat.miaow();     } else if(animal instanceof Dog dog) {         dog.bark();     }</pre> 
<p>我们都不难发现这种写法大大简化了代码，省略了显式强制类型转换的过程，可读性也大大提高了。</p> 
<p><strong>switch 模式匹配</strong></p> 
<p>基于instanceof模式匹配这个特性，我们可以使用如下方式来对对象o进行处理：</p> 
<pre>    static String formatter(Object o) {         String formatted = "unknown";         if (o instanceof Integer i) {             formatted = String.format("int %d", i);         } else if (o instanceof Long l) {             formatted = String.format("long %d", l);         } else if (o instanceof Double d) {             formatted = String.format("double %f", d);         } else if (o instanceof String s) {             formatted = String.format("String %s", s);         }         return formatted;     }</pre> 
<p>可以看到，这里使用了很多if-else，其实，Java中给我们提供了一个多路比较的工具，那就是switch，而且从Java 14开始支持switch表达式，但switch的功能一直都是非常有限的。</p> 
<p>在Java 17中，Java的工程师们扩展了switch语句和表达式，使其可以适用于任何类型，并允许case标签中不仅带有变量，还能带有模式匹配。我们就可以更清楚、更可靠地重写上述代码，例如：</p> 
<pre>    static String formatterPatternSwitch(Object o) {         return switch (o) {             case Integer i -&gt; String.format("int %d", i);             case Long l    -&gt; String.format("long %d", l);             case Double d  -&gt; String.format("double %f", d);             case String s  -&gt; String.format("String %s", s);             default        -&gt; o.toString();         };     }</pre> 
<p>可以看到，以上的switch处理的是一个Object类型，而且case中也不再是精确的值匹配，而是模式匹配了。</p> 
<p>总结</p> 
<p>以上，我们介绍了几个从 JDK 9开始，一直到 JDK 17中的几个能够改变我们写代码的方式的新特性。其实，众多的版本中，还有一些其他的特性及优化，我们没有在这里一一展开。</p> 
<p>大家感兴趣的可以到 JDK 官网查看各个版本的新功能介绍。</p> 
<p>随着 Spring Framework 6 和 SpringBoot 3.0的推出，相信会有一些公司在新项目中采用新版本，那么 JDK 17势必要被应用到生产环境中。</p> 
<p>以上这些特性，大多数都是对开发比较友好的，有机会的话可以应用起来。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8805012cfbb679ab47953d22bccdd211/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端面试知识点整理——项目整理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90bafc31da32ec7d101807a8c3da560f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">了解 DevOps，必读这十本书</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>