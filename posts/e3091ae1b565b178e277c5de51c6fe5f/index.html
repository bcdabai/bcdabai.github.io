<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mybatis进阶分页(一对多) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mybatis进阶分页(一对多)" />
<meta property="og:description" content="一对多的分页问题
当查询为一对多的时候,进行分页,如果全部查询分页,会以总条数进行分页,而不是以主表条数分页,当分页后,在进行一对多的封装,会导致分页不准
例如: user 表 adress表 一个用户多个收货地址
采用一对多封装
select * from user u left join adress a on a.id = u.adress_id
limit 0,10
当第一个用户有十条地址数据,那么上面的查询0,10,刚好是第一个用户的分页完成,此时再进行一对多封装,将会导致封装之后,仅有一个用户数据,分页不准确
解决办法
1 采用用户主表先查询,然后根据结果,在程序中再次进行查询地址表(不建议)
2 一次性查询,采用一堆多封装(嵌套语句查询)
其实一对多封装有两种,一种是如上的嵌套语句查询,与嵌套结果查询,而如上方式,主表分页则是准确的,第二种嵌套结果查询,主表分页不准确,但是更简洁,更快,我之前的文章有说过嵌套结果查询的例子;
3 采用嵌套结果查询,先不进行分页,根据查询后的结果,进行手动分页(假分页),强制截取结果,其实每次查询的都是全量的,然后截取想要的结果集返回
说明
两种方式都是采用关键字 结果集也都是一对多,不同点在于嵌套语句查询,需要单独执行sql,并指定sql 的入参(关联关键条件)
例子
如下是我自己的一个xml 嵌套语句查询
&lt;resultMap id=&#34;deviceChannelMap&#34; type=&#34;com.jovision.vse.console.basic.vo.device.DeviceChannelVo&#34;&gt; &lt;id column=&#34;id&#34; jdbcType=&#34;VARCHAR&#34; property=&#34;id&#34;/&gt; &lt;result column=&#34;area_id&#34; jdbcType=&#34;VARCHAR&#34; property=&#34;areaId&#34;/&gt; &lt;result property=&#34;realName&#34; column=&#34;real_name&#34;/&gt; &lt;result property=&#34;name&#34; column=&#34;name&#34;/&gt; &lt;result property=&#34;tenantId&#34; column=&#34;tenant_id&#34;/&gt; &lt;result property=&#34;addingMethod&#34; column=&#34;adding_method&#34;/&gt; &lt;result property=&#34;type&#34; column=&#34;type&#34;/&gt; &lt;result property=&#34;areaId&#34; column=&#34;area_id&#34;/&gt; &lt;result property=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e3091ae1b565b178e277c5de51c6fe5f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-22T10:35:59+08:00" />
<meta property="article:modified_time" content="2023-02-22T10:35:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mybatis进阶分页(一对多)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>一对多的分页问题</strong><br> 当查询为一对多的时候,进行分页,如果全部查询分页,会以总条数进行分页,而不是以主表条数分页,当分页后,在进行一对多的封装,会导致分页不准</p> 
<p>例如: user 表 adress表 一个用户多个收货地址<br> 采用一对多封装<br> select * from user u left join adress a on a.id = u.adress_id<br> limit 0,10</p> 
<p>当第一个用户有十条地址数据,那么上面的查询0,10,刚好是第一个用户的分页完成,此时再进行一对多封装,将会导致封装之后,仅有一个用户数据,分页不准确</p> 
<p><strong>解决办法</strong><br> 1 采用用户主表先查询,然后根据结果,在程序中再次进行查询地址表(不建议)<br> 2 一次性查询,采用一堆多封装(嵌套语句查询)</p> 
<p>其实一对多封装有两种,一种是如上的嵌套语句查询,与嵌套结果查询,而如上方式,主表分页则是准确的,第二种嵌套结果查询,主表分页不准确,但是更简洁,更快,我之前的文章有说过嵌套结果查询的例子;</p> 
<p>3 采用嵌套结果查询,先不进行分页,根据查询后的结果,进行手动分页(假分页),强制截取结果,其实每次查询的都是全量的,然后截取想要的结果集返回</p> 
<p><strong>说明</strong><br> 两种方式都是采用关键字 结果集也都是一对多,不同点在于嵌套语句查询,需要单独执行sql,并指定sql 的入参(关联关键条件)</p> 
<p><strong>例子</strong><br> 如下是我自己的一个xml 嵌套语句查询</p> 
<pre><code>    &lt;resultMap id="deviceChannelMap" type="com.jovision.vse.console.basic.vo.device.DeviceChannelVo"&gt;
        &lt;id column="id" jdbcType="VARCHAR" property="id"/&gt;
        &lt;result column="area_id" jdbcType="VARCHAR" property="areaId"/&gt;
        &lt;result property="realName" column="real_name"/&gt;
        &lt;result property="name" column="name"/&gt;
        &lt;result property="tenantId" column="tenant_id"/&gt;
        &lt;result property="addingMethod" column="adding_method"/&gt;
        &lt;result property="type" column="type"/&gt;
        &lt;result property="areaId" column="area_id"/&gt;
        &lt;result property="sn" column="sn"/&gt;
        &lt;result property="ip" column="ip"/&gt;
        &lt;result property="port" column="port"/&gt;
        &lt;result property="loginName" column="login_name"/&gt;
        &lt;result property="loginPassword" column="login_password"/&gt;
        &lt;result property="remark" column="remark"/&gt;
        &lt;result property="status" column="status"/&gt;
        &lt;result property="extend" column="extend"/&gt;
        &lt;result property="areaName" column="area_name"/&gt;
        &lt;result column="create_user" jdbcType="VARCHAR" property="createUser"/&gt;
        &lt;result column="create_time" jdbcType="TIMESTAMP" property="createTime"/&gt;
        &lt;result column="update_user" jdbcType="VARCHAR" property="updateUser"/&gt;
        &lt;result column="update_time" jdbcType="TIMESTAMP" property="updateTime"/&gt;
        &lt;collection property="channelList"  ofType="com.jovision.vse.console.basic.model.BasicDeviceVideoChannel"
                    select="com.jovision.vse.console.basic.mapper.BasicDeviceMapper.selectChannelList" column="{device_id=id}" /&gt;
    &lt;/resultMap&gt;


    &lt;select id="selectPage" resultMap="deviceChannelMap"&gt;
        SELECT bd.*,ba.name AS area_name
        FROM basic_device bd LEFT JOIN basic_area ba ON ba.id=bd.area_id
        WHERE bd.tenant_id = #{devicePageDto.tenantId}
        &lt;if test="devicePageDto.sn != null and devicePageDto.sn != ''"&gt;
            and (bd.sn like concat('%',#{devicePageDto.sn},'%') or bd.name like concat('%',#{devicePageDto.sn},'%'))
        &lt;/if&gt;
        &lt;if test="devicePageDto.addingMethod != null and devicePageDto.addingMethod != ''"&gt;
            and bd.adding_method = #{devicePageDto.addingMethod}
        &lt;/if&gt;
        &lt;if test="devicePageDto.areaIdList != null and devicePageDto.areaIdList.size() != 0"&gt;
            and bd.area_id in
            &lt;foreach collection="devicePageDto.areaIdList" item="id" open="(" close=")" separator=","&gt;
                #{id}
            &lt;/foreach&gt;
        &lt;/if&gt;
        &lt;if test="devicePageDto.status != null and devicePageDto.status != ''"&gt;
            and bd.status=#{devicePageDto.status}
        &lt;/if&gt;
        ORDER BY bd.update_time DESC
        limit 0,10
    &lt;/select&gt;

    &lt;select id="selectChannelList" resultType="com.jovision.vse.console.basic.model.BasicDeviceVideoChannel"&gt;
        SELECT
        channel.id ,channel.`channel_enabled`,channel.`channel_status`,channel.`create_time`,
        channel.`create_user`,channel.`update_time`,channel.`update_user`
        ,channel.`device_ability`,channel.`device_id`,channel.`gb_channel_id`,channel.`serial_number`,channel.`name`
        ,channel.`real_name` ,channel.`support_ability`
        FROM  `basic_device_video_channel` channel
        WHERE channel.`device_id` = #{device_id}
    &lt;/select&gt;

</code></pre> 
<p>其中关键点有两个</p> 
<p>1.select=“com.jovision.vse.console.basic.mapper.BasicDeviceMapper.selectChannelList”<br> 指定嵌套语句的具体执行语句id<br> 2. column=“{device_id=id}” 指定嵌套语句的关联条件,我将主表的字段id,起了一个别名叫做device_id</p> 
<p>这样主表的分页数据就是准确的</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ba846a5932694d6a3b6c65c4f0b2e4a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VS 出现错误“MSB3644 找不到 .NETFramework,Version=v4.6.X 的引用程序集。”的解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e653ae526172b13e170817df60a1eb7a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ffmpeg 学习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>