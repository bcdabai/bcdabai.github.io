<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构：顺序表，链表，双向链表 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构：顺序表，链表，双向链表" />
<meta property="og:description" content="顺序表，链表以及双向链表都属于线性表，线性顾名思义，就像一根绳子一样按照一定的顺序将数据连接起来，线性表是我们日常存储数据常用的结构，在不同的场景下有着不同的应用。事实上，线性表还包括栈和队列，不过篇幅原因，这篇文章将只详细讲述顺序表，单向链表，双向链表这三种线性表，主要有存储形式，实现步骤，及它们之间的区别。
目录
顺序表
顺序表的存储形式
顺序表的动态实现
顺序表的数据插入
顺序表数据的删除
顺序表的查改
单向链表
单向链表的存储形式
单向链表数据的插入
单向链表数据的删除
双向链表
双向链表的存储形式
带头双向循环链表数据的插入和删除
顺序表与链表的区别
顺序表与链表的优缺点
何为cpu高速缓存命中率
顺序表 顺序表的存储形式 顺序表是在内存中按照顺序存放的数据形式，要求内存地址的连续，因此顺序表要靠数组来实现，但实现方法又分为静态实现和动态实现。静态实现是给定了数组的大小，数据的增删查改只能在这么大的空间里进行，多应用在明确给定了空间的大小对数据进行维护。而动态实现则可以根据需要扩大数据的容量，实现对数据的维护，静态的实现是比较容易的，设立指定大小的数据类型的数组即可，我们重点探讨动态实现。
顺序表的动态实现 实现数据容量的动态扩增，要了解动态内存开辟函数，在C语言中分别是malloc，calloc，realloc具体的功能大家自行查询，这里我们要用到realloc。要实现对已开辟空间的管理，以及当空间满了自动开辟更大的空间的功能，我们需要至少三个变量。第一个是数据类型的指针变量，设为DataType * p，用来维护已经开辟好的空间，第二个变量用来指明当前已存放了多少个数据，设为int size，第三个变量用来指明总共能存放多少个数据，将其设立为 int capacity，当size == capacity时，说明容量满了，需要扩大容量，然后利用realloc函数开辟一块更大的空间再把指针交给DataType * p来维护，为了方便传值使用，我们将这三个变量全部封装到一个结构体里。
代码实现
typedef int DateType; typedef struct SeqList { SLDateType * a; //用来维护已开辟的空间 int size; //表中存放了多少个数据 int capacity; //表中实际能存放的数据 }SL; void SeqListInit(SL* ps) //将封装后的结构体的值进行初始化 { ps-&gt;a = NULL; ps-&gt;size = 0; ps-&gt;capacity = 0; } void SeqListAddCapacity(SL* ps) //实现顺序表的容量的动态开辟 { if (ps-&gt;capacity == ps-&gt;size) { int newcapacity = ps-&gt;capacity == 0 ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5f110d9718390d89d9852b82f8030e70/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-15T18:35:55+08:00" />
<meta property="article:modified_time" content="2023-08-15T18:35:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构：顺序表，链表，双向链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>顺序表，链表以及双向链表都属于线性表，线性顾名思义，就像一根绳子一样按照一定的顺序将数据连接起来，线性表是我们日常存储数据常用的结构，在不同的场景下有着不同的应用。事实上，线性表还包括栈和队列，不过篇幅原因，这篇文章将只详细讲述顺序表，单向链表，双向链表这三种线性表，主要有存储形式，实现步骤，及它们之间的区别。</strong></p> 
<p> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">顺序表</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F" rel="nofollow">顺序表的存储形式</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%8A%A8%E6%80%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%8A%A8%E6%80%81%E5%AE%9E%E7%8E%B0" rel="nofollow">顺序表的动态实现</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5" rel="nofollow">顺序表的数据插入</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">顺序表数据的删除</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%94%B9-toc" style="margin-left:80px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%94%B9" rel="nofollow">顺序表的查改</a></p> 
<p id="%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8" rel="nofollow">单向链表</a></p> 
<p id="%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F" rel="nofollow">单向链表的存储形式</a></p> 
<p id="%C2%A0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow"> 单向链表数据的插入</a></p> 
<p id="%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">单向链表数据的删除</a></p> 
<p id="%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8" rel="nofollow">双向链表</a></p> 
<p id="%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F" rel="nofollow">双向链表的存储形式</a></p> 
<p id="%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0" rel="nofollow"> </a></p> 
<p id="%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4" rel="nofollow">带头双向循环链表数据的插入和删除</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">顺序表与链表的区别</a></p> 
<p id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">顺序表与链表的优缺点</a></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E4%BD%95%E4%B8%BAcpu%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87-toc" style="margin-left:80px;"><a href="#%E4%BD%95%E4%B8%BAcpu%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87" rel="nofollow">何为cpu高速缓存命中率</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8"><strong>顺序表</strong></h2> 
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F"><strong>顺序表的存储形式</strong></h4> 
<blockquote> 
 <p><strong>顺序表是在内存中按照顺序存放的数据形式，要求内存地址的连续，因此顺序表要靠数组来实现，但实现方法又分为静态实现和动态实现。静态实现是给定了数组的大小，数据的增删查改只能在这么大的空间里进行，多应用在明确给定了空间的大小对数据进行维护。而动态实现则可以根据需要扩大数据的容量，实现对数据的维护，静态的实现是比较容易的，设立指定大小的数据类型的数组即可，我们重点探讨动态实现。</strong></p> 
</blockquote> 
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%8A%A8%E6%80%81%E5%AE%9E%E7%8E%B0"><strong>顺序表的动态实现</strong></h4> 
<blockquote> 
 <p><strong>实现数据容量的动态扩增，要了解动态内存开辟函数，在C语言中分别是malloc，calloc，realloc具体的功能大家自行查询，这里我们要用到realloc。要实现对已开辟空间的管理，以及当空间满了自动开辟更大的空间的功能，我们需要至少三个变量。第一个是数据类型的指针变量，设为DataType * p，用来维护已经开辟好的空间，第二个变量用来指明当前已存放了多少个数据，设为int size，第三个变量用来指明总共能存放多少个数据，将其设立为         int capacity，当size == capacity时，说明容量满了，需要扩大容量，然后利用realloc函数开辟一块更大的空间再把指针交给DataType * p来维护，为了方便传值使用，我们将这三个变量全部封装到一个结构体里。</strong></p> 
</blockquote> 
<p><strong>代码实现</strong></p> 
<pre><code class="language-cpp">typedef  int  DateType;


typedef struct SeqList
{
	SLDateType * a; //用来维护已开辟的空间
	int size; //表中存放了多少个数据
	int capacity; //表中实际能存放的数据
}SL;


void SeqListInit(SL* ps)  //将封装后的结构体的值进行初始化
{
	ps-&gt;a = NULL;
	ps-&gt;size = 0;
	ps-&gt;capacity = 0;
} 



void SeqListAddCapacity(SL* ps)  //实现顺序表的容量的动态开辟
{
	if (ps-&gt;capacity == ps-&gt;size)
	{
		int newcapacity = ps-&gt;capacity == 0 ? 4 : 2 * ps-&gt;capacity;
		SLDateType* tmp = (SLDateType*)realloc(ps-&gt;a, newcapacity * sizeof(SLDateType));
		if (tmp == NULL)
		{
			printf("realloc fail\n");
			exit(-1);
		}
		ps-&gt;a = tmp;
		ps-&gt;capacity = newcapacity;
		tmp = NULL;
	}
}

</code></pre> 
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5">顺序表的数据插入</h4> 
<blockquote> 
 <p><strong>顺序表数据的插入有三种形式，第一种是头插，也就是在数组首元素位置处插入数据，这就要求之前已存储的所有的数据都要向后移动一位，给新插入的数据腾个位置，第二种是尾插，在顺序表的末尾进行数据的插入，第三种是指定位置的插入，那就要求要插入的这个位置及其后面的元素都要向后移动一位，腾出一个位置。由此可见，头插数据是牵一发而动全身，这样插入数据的效率是很低的，想要插入一个数据还要遍历整个数组，而指定位置的插入也没有好到哪去，按照最坏的情况是和头插一样的，时间复杂度都是O(n)，只有尾插的效率是最高的，时间复杂度为O(1)</strong></p> 
</blockquote> 
<p><strong>三种插入方式的代码实现</strong></p> 
<pre><code class="language-cpp">//前插
void SeqLIstPushFront(SL* ps, SLDateType x)
{
	SeqListAddCapacity(ps);
	for (int i = ps-&gt;size; i &gt;0; i--)
	{
		ps-&gt;a[i] = ps-&gt;a[i-1];
	}
	ps-&gt;a[0] = x;
	ps-&gt;size++;
}


//任意位置插入
void SeqListInsert(SL* ps, SLDateType x, SLDateType y)
{
	SeqListAddCapacity(ps);
	for (int i = ps-&gt;size; i &gt;= x; i--)
	{
		ps-&gt;a[i] = ps-&gt;a[i - 1];
	}
	ps-&gt;a[x - 1] = y;
	ps-&gt;size++;
}


//尾插
void SeqListPushBack(SL* ps, SLDateType x)
{
	SeqListAddCapacity(ps);
	ps-&gt;a[ps-&gt;size] = x;
	ps-&gt;size++;
}</code></pre> 
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4">顺序表数据的删除</h4> 
<blockquote> 
 <p><strong>顺序表的删除可以通过直接覆盖要删除的元素来实现删除，同样也分为三种删除方式，前删，指定位置删，尾删。前删就是把首元素后面的元素都往前走一步，把首元素覆盖掉，然后size--，就完成了删除，指定位置的删除和前删比较类似，都是后面的元素把要删除的元素覆盖掉，尾删就是比较简单的，只需要将size--，就表示该元素已经删掉了</strong></p> 
</blockquote> 
<p><strong>三种删除方式的代码实现</strong></p> 
<pre><code class="language-cpp">//前删
void SeqListPopFront(SL* ps)
{
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		ps-&gt;a[i] = ps-&gt;a[i + 1];
	}

	if (ps-&gt;size &gt; 0)
	{
		ps-&gt;size--;
	}
}


//任意位置删除
void SeqListPop(SL* ps, SLDateType x)
{
	for (int i = x; i &lt; ps-&gt;size; i++)
	{
		ps-&gt;a[i-1] = ps-&gt;a[i];
	}
	ps-&gt;size--;
}


//尾删
void SeqListPopBack(SL* ps)
{
	if (ps-&gt;size &gt; 0)     //这里防止空表要删除会使size变为负数
	{
		ps-&gt;size--;
	}
}</code></pre> 
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%94%B9">顺序表的查改</h4> 
<blockquote> 
 <p><strong>顺序表的查看是比较简单的，通过size控制循环，对比要查看的元素是否存在</strong></p> 
</blockquote> 
<p><strong>代码实现</strong></p> 
<pre><code class="language-cpp">void SeqListCheck(SL* ps, SLDateType x)
{
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		if (ps-&gt;a[i] == x)
		{
			putchar('\n');
			printf("got it, the subscript is %d", i);
			return 0;
		}
	}
	printf("not found\n");
}

//通过这个查看和修改都能实现</code></pre> 
<p></p> 
<h2 id="%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">单向链表</h2> 
<h4 id="%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F">单向链表的存储形式</h4> 
<blockquote> 
 <p><strong>单向链表可以解决顺序表存在的一些问题，我们分析一下刚才顺序表存在的一些问题</strong></p> 
 <p><strong>1.头部\任意位置插入删除数据时，时间复杂度是O(n)</strong></p> 
 <p><strong>2.增容需要申请新的空间， 拷贝数据，释放旧空间，会有不小的消耗</strong></p> 
 <p><strong>3.每次增容扩展地空间会造成很大地浪费</strong></p> 
 <p><strong>单向链表分为很多种，循环的，有指向头和尾的两个指针的等等，这里只叙述最为经典和基础的单向链表，基础的掌握，其他的看看就了解了</strong></p> 
 <p><strong>单链表的存储形式通常包含要存的数据类型DataType，指向下一个节点的指针变量Linck*next</strong></p> 
</blockquote> 
<pre><code class="language-cpp">struct ListNode
{
	DataStyle val;
	struct ListNode* next;
}Linck;</code></pre> 
<p><img alt="" height="361" src="https://images2.imgbox.com/e5/b7/YMexGqhU_o.png" width="933"></p> 
<h4 id="%C2%A0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5"> 单向链表数据的插入</h4> 
<blockquote> 
 <p><strong>在使用单向链表时，我们需要一个指针变量始终指向链表的第一个节点，这个指针用来维护这串链表，通过解引用这个指针能找到链表的第一个节点，然后就能找到其他节点，数据的插入同样有三种形式，头插，指定位置插入，尾插。</strong></p> 
 <p></p> 
 <p><strong>尾插是最为简便的，只需要将链表最后节点指向下一个节点的指针指向新创建的节点，简单归简单但是想要找到最后一个节点的位置是不轻松的，链表的存储形式在内存地址上是不连续的，无法做到数组那样任意访问，可不是得从头节点开始，遍历一遍链表，这样时间复杂度就上来了。</strong></p> 
 <p></p> 
 <p><strong>头插较为麻烦，主要是因为头插一个新元素，就要挪动指向头节点的指针phead，而要改变指针变量phead的值，那就得靠传二级指针来实现，比如变量 int a; 想要在另一个函数里改变a的值，那就要传a的指针过去，同理，想要改变指针变量指向的地址，那就得用二级指针才能达到修改的目的，很多初学者可能会在这里犯迷糊，二级指针可能会有点绕，在以后的文章里，我将列举三个可以回避使用二级指针的方法</strong></p> 
 <p></p> 
 <p><strong>指定位置插入需要考虑的情况比较多，因为头插和尾插也可是指定位置，要同时兼顾这两种情况，在中间某个位置前插入，就需要记住该位置的前一个节点的next指针的值，其实是一个很简单的过程，但要叙述起来就比较难理解，简单来说就是为了保持链表的连贯，不能直接将前一个节点的next指针指向新节点就完事了，还要将新节点的next指针将后面的链表连贯起来</strong></p> 
</blockquote> 
<p><img alt="" height="394" src="https://images2.imgbox.com/e4/c9/E5nF34Ip_o.png" width="908"></p> 
<p><strong> 代码实现</strong></p> 
<pre><code class="language-cpp">//创建一个新节点的函数实现，后面创建直接调用
struct ListNode* Buynewnode(DataStyle Data)
{
	struct ListNode* newnode = (struct ListNode*)malloc(sizeof(struct ListNode));
	if (NULL == newnode)
	{
		printf("malloc fail\n");
		return NULL;
	}
	newnode-&gt;val = Data;
	newnode-&gt;next = NULL;
	return newnode;
}


//头插的实现，注意，这里传二级指针是为了改变phead的值
void Linckpushfront(struct ListNode** pphead, DataStyle Data)
{
	     assert(pphead);
		 struct ListNode* newnode = Buynewnode(Data);
		  newnode-&gt;next = *pphead;
		*pphead = newnode;
}


//尾插的实现
void Linckpushback(struct ListNode** pphead, DataStyle Data)
{
	assert(pphead);
	struct ListNode* tmp = *pphead;
	if (*pphead == NULL)
	{
		tmp = Buynewnode(Data);
		*pphead = tmp;
	}
	else
	{
		while (tmp-&gt;next != NULL)
		{
			tmp = tmp-&gt;next;
		}
		tmp-&gt;next = Buynewnode(Data);
	}
}


//指定位置插入的实现
//pos是指定节点的指针
void LinckpushInsert(Linck** pphead, Linck * pos, DataStyle Data)
{
	assert(pphead);
	assert(*pphead);
	assert(pos);
	Linck* tmp = *pphead;
	while (tmp-&gt;next != pos)
	{
		tmp = tmp-&gt;next;
	}
	Linck* newnode = Buynewnode(Data);
	if ((*pphead)-&gt;next == NULL)
	{
		newnode-&gt;next = *pphead;
		*pphead = newnode;
	}
	else
	{
		tmp-&gt;next = newnode;
		newnode-&gt;next = pos;
	}
}</code></pre> 
<h4 id="%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4">单向链表数据的删除</h4> 
<blockquote> 
 <p><strong>单向链表的数据删除同样也分为头删，尾删，指定位置删，道理大家都懂，不过多重复，接下来直接上代码</strong></p> 
</blockquote> 
<pre><code class="language-cpp">//头删
void Linckpopfront(Linck** pphead)
{
	if (*pphead == NULL)
	{
		assert(*pphead != NULL);
	}
	Linck* tmp = *pphead;
	*pphead = (*pphead)-&gt;next;
	free(tmp);
}


//尾删
void Linckpopback(Linck** pphead)
{
	assert(pphead);
	assert(*pphead != NULL);
	if ((*pphead)-&gt;next == NULL)
	{
		free(*pphead);
		*pphead = NULL;
		 return;
	}
	Linck* tmp = *pphead;
	while (tmp-&gt;next-&gt;next != NULL)
	{
		tmp = tmp-&gt;next;
	}
	free(tmp-&gt;next);
	tmp-&gt;next = NULL;
}



//指定位置删
void LinckpopErase(Linck** pphead, Linck* pos)
{
	assert(pphead);
	assert(*pphead);
	Linck* tmp = *pphead;
	if (*pphead == pos)
	{
		Linckpopfront(pphead);
	}
	else
	{
		while (tmp-&gt;next != pos)
		{
			tmp = tmp-&gt;next;
			assert(pos);//检测pos是否传错了
		}
		tmp-&gt;next = pos-&gt;next;
		free(pos);
	}
}</code></pre> 
<h2 id="%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">双向链表</h2> 
<h4 id="%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F">双向链表的存储形式</h4> 
<blockquote> 
 <p><strong>我们在引入单向链表时，很好的解决了顺序表的占用空间浪费，头插/指定位置插入数据效率低的问题，但这又带来了一个新的问题，单向链表在尾插数据时，要遍历一遍链表，时间复杂度是O(n)，而带头双向循环链表的出现就更好的解决了顺序表的问题，且没造成其他问题。带头双向循环链表是链表结构中最复杂的，但易于理解和使用，带头指的是下图中的哨兵卫节点head，这个节点不存储数据，只作为引导头使用</strong></p> 
</blockquote> 
<p><img alt="" height="449" src="https://images2.imgbox.com/b6/77/jaxfyWoP_o.png" width="834"></p> 
<blockquote> 
 <p> <strong>为何说带头双向循环链表能很好的解决问题，拿单向链表尾插遍历来说，带头双向循环链表就不存在这种问题，头节点head不存放任何数据，但指向了尾节点的位置，也就是说想要尾插可直接通过head找到尾节点完成插入，不需要遍历了，效率就提高了，但因为每个节点存了前后两个节点的指针，消耗的空间更多，也就是拿空间换取时间</strong></p> 
</blockquote> 
<p></p> 
<pre><code class="language-cpp">typedef int DLinckDataType;

typedef struct DLincked
{
	struct DLincked*  previous;  //指向前一个节点
	struct DLincked*  next;      //指向后一个节点
	DLinckDataType Data;         //存放数据
} DLinck;</code></pre> 
<p> <img alt="" height="286" src="https://images2.imgbox.com/de/df/dYo9my1W_o.png" width="568"></p> 
<blockquote> 
 <p><strong>上面代码是带头双向循环链表节点的定义</strong></p> 
 <p><strong>上图带头双向循环链表为空时，前后指针都分别指向自己</strong></p> 
</blockquote> 
<h4 id="%C2%A0"></h4> 
<h4 id="%E5%B8%A6%E5%A4%B4%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">带头双向循环链表数据的插入和删除</h4> 
<blockquote> 
 <p><strong>带头双向循环链表的插入和删除，本质上和单向链表的思想是一样的，这里不过多赘述，直接上代码吧</strong></p> 
</blockquote> 
<pre><code class="language-cpp">//创建新节点
DLinck* Buynewnode(DLinckDataType Data)
{
	DLinck* newnode = (DLinck*)malloc(sizeof(DLinck));
	if (newnode == NULL)
	{
		assert(newnode);
		return -1;
	}
	newnode-&gt;previous = NULL;
	newnode-&gt;next = NULL;
	newnode-&gt;Data = Data;
	return newnode;
}


//尾插
void DLinckpushback(DLinck* phead, DLinckDataType Data)
{
	DLinck* newnode = Buynewnode(Data);
	newnode-&gt;previous = phead-&gt;previous;
	phead-&gt;previous-&gt;next = newnode;
	phead-&gt;previous = newnode;
	newnode-&gt;next = phead;
}





//首插
void DLinckpushfront(DLinck* phead, DLinckDataType Data)
{
	DLinck* newnode = Buynewnode(Data);
	newnode-&gt;next = phead-&gt;next;
	newnode-&gt;previous = phead;
	phead-&gt;next-&gt;previous = newnode;
	phead-&gt;next = newnode;
}


//指定位置插
void DLinckpush(DLinck* phead, DLinck* pos, DLinckDataType Data)
{
	assert(pos);
	DLinck* newnode = Buynewnode(Data);
	newnode-&gt;next = pos;
	newnode-&gt;previous = pos-&gt;previous;
	pos-&gt;previous-&gt;next = newnode;
	pos-&gt;previous = newnode;
}


//指定位置删
void DLinckpop(DLinck* phead, DLinck* pos)
{
	assert(phead-&gt;next != phead);
	assert(pos);
	DLinck* posprevious = pos-&gt;previous;
	DLinck* posnext = pos-&gt;next;
	posprevious-&gt;next = pos-&gt;next;
	posnext-&gt;previous = pos-&gt;previous;
	free(pos);
}



//头删
void DLinckpopfront(DLinck* phead)
{
	assert(phead-&gt;next != phead);
	DLinck* tmp = phead-&gt;next;
	phead-&gt;next = tmp-&gt;next;
	tmp-&gt;next-&gt;previous = phead;
	free(tmp);
}



//尾删
void DLinckpopback(DLinck* phead)
{
	assert(phead-&gt;next != phead );
	DLinck* tmp = phead-&gt;previous;
	phead-&gt;previous = tmp-&gt;previous;
	tmp-&gt;previous-&gt;next = phead;
	free(tmp);
}</code></pre> 
<h2></h2> 
<h2 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB">顺序表与链表的区别</h2> 
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">顺序表与链表的优缺点</h4> 
<p><img alt="" height="359" src="https://images2.imgbox.com/ed/57/LcVytvoQ_o.png" width="1007"></p> 
<blockquote> 
 <p><strong>顺序表的优点：</strong></p> 
 <p><strong>1.尾插尾删效率高</strong></p> 
 <p><strong>2.靠数组随机访问</strong></p> 
 <p><strong>3.cpu高速缓存命中率更高（相比于链表）</strong></p> 
 <p><strong>缺点：</strong></p> 
 <p><strong>头部和中间的插入效率低</strong></p> 
 <p><strong>空间浪费情况较为严重</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>链表的优点：</strong></p> 
 <p><strong>1.指定位置插入数据效率高</strong></p> 
 <p><strong>2.按需申请内存</strong></p> 
 <p><strong>3.能解决顺序表的一些问题</strong></p> 
 <p><strong>缺点：</strong></p> 
 <p><strong>不支持随机访问</strong></p> 
</blockquote> 
<h4></h4> 
<h4 id="%E4%BD%95%E4%B8%BAcpu%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87">何为cpu高速缓存命中率</h4> 
<p><img alt="" height="717" src="https://images2.imgbox.com/58/d7/8Urqn4yq_o.png" width="1167"></p> 
<p><span style="color:#fe2c24;"> <strong> 接下来的内容要参考上面这张图</strong></span></p> 
<blockquote> 
 <p><strong>CPU处理速度与内存不是一个量级的，CPU执行指令，不会直接访问内存，而是先看数据在不在L1，L2，L3高速缓存里，如果在的话（即命中），那就直接访问</strong><strong>，如果不在的话（即未命中），那就将内存中的数据加载到高速缓存里，然后再访问</strong></p> 
 <p></p> 
 <p><strong>为了提高访问效率，内存加载信息到高速缓存中时，并不是一个一个加载的，而是会多加载其周边的一些数据，加载多少取决于硬件，数组的数据存储是连续的</strong>，<strong>如果加载的数据是数组，那么会将数组周边的元素都加载进去，这样再访问数组里其他数据时，直接就能在高速缓存里找到，命中率很高。</strong></p> 
 <p><strong>而链表呢，每个节点在内存中的存放地址是随机的，基本不会是连续的，这就导致访问链表某个节点时，从内存加载到高速缓存，其多加载的周边数据并不会包含该链表的其他节点，再想访问链表其他元素时就要从内存中重新导入到高速缓存，命中率明显没有顺序表的高</strong></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f038bbd1d17410d172ef7fee2a542e6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决参数过多问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4300100f45aa672d3733862730fc7f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Bug日记-webstorm运行yarn 命令报错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>