<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;标准库中正则表达式简介 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;标准库中正则表达式简介" />
<meta property="og:description" content="C&#43;&#43;标准库中正则表达式的使用 qianghaohao #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;fstream&gt; #include &lt;string&gt; #include &lt;regex&gt; using namespace std; /// /// C&#43;&#43;标准库中正则表达式的使用简介: /// C&#43;&#43;标准库中提供了对正表达式的支持,以下是常用的使用方法. /// /// regex类:定义包含正则表达式的对象,如:regex rx(&#34;a(b?)c&#34;); /// /// cmatch类:Type definition for char match_results.用来 /// 定义保存匹配结果的对象--&gt;typedef match_results&lt;const char*&gt; cmatch; /// 当待搜索的字符串是char类型是,使用此类对象 /// /// smatch类:Type definition for string match_results.用来 /// 定义保存匹配结果的对象--&gt;typedef match_results&lt;string::const_iterator&gt; smatch; /// 当待搜索的字符串是string类型是,使用此类对象 /// /// ==========================以下是三个常用的正则匹配函数================================== /// *bool regex_match(...)函数:Exactly matches a regular expression，判断是否准确匹配 * /// *Tests whether a regular expression matches the entire target string * /// *是否准确匹配整个目标字符串 * /// *注意:regex_match是目标字符串和正则表达式要完全匹配时才返回true." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b4db6e5ee42f9a520599b4c78c0c7c81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-02-24T03:22:00+08:00" />
<meta property="article:modified_time" content="2016-02-24T03:22:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;标准库中正则表达式简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <h3>                             </h3> 
 <h3>                                C++标准库中正则表达式的使用</h3> 
 <h5>                                                                                                  qianghaohao</h5> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;
using namespace std;

///
///               C++标准库中正则表达式的使用简介:
///   C++标准库中提供了对正表达式的支持,以下是常用的使用方法.
///
///   regex类:定义包含正则表达式的对象,如:regex rx("a(b?)c");
///
///   cmatch类:Type definition for char match_results.用来
///   定义保存匹配结果的对象--&gt;typedef match_results&lt;const char*&gt; cmatch;
///   当待搜索的字符串是char类型是,使用此类对象
///
///   smatch类:Type definition for string match_results.用来
///   定义保存匹配结果的对象--&gt;typedef match_results&lt;string::const_iterator&gt; smatch;
///   当待搜索的字符串是string类型是,使用此类对象
///   
///   ==========================以下是三个常用的正则匹配函数==================================
///   *bool regex_match(...)函数:Exactly matches a regular expression，判断是否准确匹配      *
///   *Tests whether a regular expression matches the entire target string                   *
///   *是否准确匹配整个目标字符串                                                            *
///   *注意:regex_match是目标字符串和正则表达式要完全匹配时才返回true.                       *
///   *如"abc"和"ab*c" 完全匹配,但是如果是"abcd"和"ab*c",虽然只有部分匹配(abc)但是返回是false*
///   *                                                                                      *
///   *bool regex_search(...)函数:Searches for a regular expression match.                   *
///   *在目标字符串中搜索一个匹配正则的字符串,如果搜索到了则返回true,否则返回false           *
///   *                                                                                      *
///   *regex_replace(...)函数:Replaces matched regular expressions.用指定的字符串替换匹      *
///   *配到的字符串,默认是替换所有目标字符串中匹配到的字符串,加了format_first_only标志       *
///   *表示只替换第一次匹配到的字符串                                                        *
///   ========================================================================================
///
///   ----&gt;Regex Match Tracer 2.1:正则表达式匹配测试工具.
///
///

//#####----------&gt;示例是对相关函数的多个重载形式的演示
///1.regex_match(...)使用示例:
#if 1
int main(int argc, char* argv[])
{

	// (1) with char*
	// Note how const char* requires cmatch and regex
	const char *first = "abc";  //待匹配字符串
	const char *last = first + strlen(first);
	cmatch narrowMatch;  //char *类型的对象来匹配保存结果
	regex rx("ab*c");  //定义包含正则表达式的对象

	//注意:regex_match是目标字符串和正则表达式要完全匹配时才返回true.
	// 如"abc"和"ab*c"完全匹配返回true,但是如果是"abcd"和"ab*c",虽然只有
	// 部分匹配(abc)但是返回是false
	//  regex_match有多个重载函数,可以只有三个参数,不保存结果.
	//  也可以有四个参数,第三个参数用来保存结果,一般情况下使用三个参数的就可以了
	bool found = regex_match(
		                      first,   //待匹配的开始位置
		                      last,  //待匹配的结束位置
		                      narrowMatch,  //保存结果
		                      rx    //正则表达式
		                    );  
	cout &lt;&lt; found &lt;&lt; endl;
	
	// (2) with std::string
	string target2("Drizzle");
	regex rx2("(D\\w+e)"); // no double backslashes with raw string literal
	found = regex_match(
		                 target2.cbegin(),  //匹配开始 --&gt;迭代器区间开始开始位置
		                 target2.cend(),   //匹配结束 --&gt;迭代器区间结束位置
		                 rx2   //正则表达式
		               );
	cout &lt;&lt; found &lt;&lt; endl;
	return 0;
}
#endif

///2.regex_search(...)使用示例/
///   示例是对regex_search(...)的多个重载形式的函数的使用
//
#if 1
int main()
{
	const char *first = "abcd";  //待搜索字符串
	const char *last = first + strlen(first);
	std::cmatch mr;  //保存匹配结果
	std::regex rx("abc");
	std::regex_constants::match_flag_type fl =  //regex_constants:一个名字空间
		std::regex_constants::match_default;

	std::cout &lt;&lt; "search(f, f+1, \"abc\") == " &lt;&lt; std::boolalpha  //bool类型以true或者false输出
		&lt;&lt; regex_search( first,  //目标字符串开始
			             first + 1,  //目标字符串结束
			             rx,  //正则表达式
			             fl  //匹配标志
			           ) &lt;&lt; std::endl;

	
	std::cout &lt;&lt; "search(f, l, \"abc\") == " &lt;&lt; std::boolalpha
		&lt;&lt; regex_search( first,  //目标字符串开始
			             last,  //目标字符串结束
			             mr,  //将搜索结果存入mr
			             rx  //正则表达式
			           ) &lt;&lt; std::endl;
	std::cout &lt;&lt; "  matched: \"" &lt;&lt; mr.str() &lt;&lt; "\"" &lt;&lt; std::endl;

	std::cout &lt;&lt; "search(\"a\", \"abc\") == " &lt;&lt; std::boolalpha
		&lt;&lt; regex_search( "a",  //待搜索字符串
			             rx   //正则表达式
			           ) &lt;&lt; std::endl;

	std::cout &lt;&lt; "search(\"xabcd\", \"abc\") == " &lt;&lt; std::boolalpha
		&lt;&lt; regex_search( "xabcd",  //待搜索字符串
			             mr,  //将搜索结果存入mr
			             rx  //正则表达式
			           ) &lt;&lt; std::endl;
	std::cout &lt;&lt; "  matched: \"" &lt;&lt; mr.str() &lt;&lt; "\"" &lt;&lt; std::endl;

	std::cout &lt;&lt; "search(string, \"abc\") == " &lt;&lt; std::boolalpha
		&lt;&lt; regex_search( std::string("a"),  //待搜索字符串,此参数为string类型
			             rx  //正则表达式
			           ) &lt;&lt; std::endl;

	std::string str("abcabc");
	//std::match_results&lt;std::string::const_iterator&gt; mr2;
	smatch mr2;  //和上面等价 typedef定义的match_results&lt;std::string::const_iterator&gt;别名
	std::cout &lt;&lt; "search(string, \"abc\") == " &lt;&lt; std::boolalpha
		&lt;&lt; regex_search( str,  //待搜索字符串,此参数为string类型
			             mr2, //将搜索结果存入mr2
			             rx  //正则表达式
			           ) &lt;&lt; std::endl;
	std::cout &lt;&lt; "  matched: \"" &lt;&lt; mr2.str() &lt;&lt; "\"" &lt;&lt; std::endl;

	return (0);
}
#endif

///3.regex_replace(...)使用示例/
#if 1
int main()
{
	char buf[20];
	const char *first = "axayaz";  //待匹配字符串
	const char *last = first + strlen(first);
	std::regex rx("a");  //正则表达式
	std::string fmt("A");
	std::regex_constants::match_flag_type fonly =
		std::regex_constants::format_first_only;

	//默认是替换所有目标字符串总匹配到的字符串,加了format_first_only标志
	//表示只替换第一次匹配到的字符串
	*std::regex_replace( &amp;buf[0],  //被更改字符串的迭代器
		                 first,  //目标字符串开始位置
		                 last,  //目标字符串结束位置
		                 rx,  //正则表达式
		                 fmt  //要替换的字符串
		               ) = '\0';
	std::cout &lt;&lt; "replacement == " &lt;&lt; &amp;buf[0] &lt;&lt; std::endl;
	
	*std::regex_replace(&amp;buf[0],  //被更改字符串的迭代器
		                first,  //目标字符串开始位置
		                last,  //目标字符串结束位置
		                rx,  //正则表达式
		                fmt,  //要替换的字符串
		                fonly  //替换标志,在此表示只替换第一次匹配到的字符串
		                ) = '\0';
	std::cout &lt;&lt; "replacement == " &lt;&lt; &amp;buf[0] &lt;&lt; std::endl;

	std::string str("adaeaf");
	std::cout &lt;&lt; "replacement == "
		&lt;&lt; std::regex_replace( str,  //目标字符串
			                   rx,   //正则表达式
			                   fmt   //要替换的字符串
			                 ) &lt;&lt; std::endl;

	std::cout &lt;&lt; "replacement == "
		&lt;&lt; std::regex_replace(str,  //目标字符串
			                  rx,  //正则表达式
			                  fmt,  //要替换的字符串
			                  fonly  //替换标志,在此表示只替换第一次匹配到的字符串
			                 ) &lt;&lt; std::endl;

	return (0);
}
#endif

///4.regex_search(...)循环遍历字符串示例/
///       ---------&gt;找到目标字符串中所有匹配的子串
///       ####-----&gt;此示例中找到s串中所有以subj开头的单词,并打印出来
/
#if 1
int main()
{
	std::string s("this subject has a subjmarine as a subjsequence subjmite");
	std::smatch m;
	std::regex e("\\b(subj)([^ ]*)");    // matches words beginning by "sub"  //GCC未支持

	std::cout &lt;&lt; "目标序列: " &lt;&lt; s &lt;&lt; std::endl;
	std::cout &lt;&lt; "正则公式: /\\b(sub)([^ ]*)/" &lt;&lt; std::endl;
	std::cout &lt;&lt; "The following matches and submatches were found:" &lt;&lt; std::endl;

	while (std::regex_search(s, m, e)) {
		std::cout &lt;&lt; m.str() &lt;&lt; std::endl;  //输出匹配结果
		//std::cout &lt;&lt; m[0] &lt;&lt; std::endl;  //输出匹配结果,等价于上面那种用法
		s = m.suffix().str();  // 返回末端,作为新的搜索的开始
	}
	return 0;
}
#endif</code></pre> 
 <p><br>  </p> 
</div> 
<p>转载于:https://www.cnblogs.com/codingnutter/p/5634486.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9c75c945dac913770ecf34b8f4b6b2a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">给eclipse装一些插件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb0646d98ab073ee4a9112e3213066d0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">centos-系统语言检查设置安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>