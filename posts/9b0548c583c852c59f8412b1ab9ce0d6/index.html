<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>clickhouse php,OrzClick: 国庆写个 ClickHouse 客户端 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="clickhouse php,OrzClick: 国庆写个 ClickHouse 客户端" />
<meta property="og:description" content="起因
我看 ClickHouse 有 C&#43;&#43; 客户端(clickhouse-cpp)，我又用过 PHP-CPP 写扩展，于是就在国庆写了 OrzClick ，一个 PHP 用的 ClickHouse 客户端。
比较尴尬的是，我写到一半才发现 SeasClick，它也是 clickhouse-cpp 的绑定， 而且是 C 写的，感觉用 PHP-CPP 我就已经输了一半呀，所以我的小目标就是性能超越 SeasClick
。
性能测试
Select 结果：
使用 PDO 访问 ClickHouse 的 MySQL 接口，查询小量数据性能更好
小量数据时，OrzClick 和 SeasClick 性能相近，数据大时 OrzClick &gt; SeasClick &gt; MySQL 接口
Insert 结果：
OrzClick-Indexed 对标的是 SeasClick，API 最相近(可看代码：1 2)，算是达到了小目标
SeasClick 和 OrzClick 都有提高插入性能的 API，SeasClick 的 startWrite-write-endWrite 性能非常好(图上的 SeasClick-Block)，OrzClick 的 InsertColumnar 只有数据量大于 5 千时才能超过它(图上的 OrzClick-Columnar)
哪个 clickhouse-cpp ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9b0548c583c852c59f8412b1ab9ce0d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-11T01:42:27+08:00" />
<meta property="article:modified_time" content="2021-03-11T01:42:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">clickhouse php,OrzClick: 国庆写个 ClickHouse 客户端</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>起因</p> 
 <p>我看 ClickHouse 有 C++ 客户端(clickhouse-cpp)，我又用过 PHP-CPP 写扩展，于是就在国庆写了 OrzClick ，一个 PHP 用的 ClickHouse 客户端。</p> 
 <p>比较尴尬的是，我写到一半才发现 SeasClick，它也是 clickhouse-cpp 的绑定， 而且是 C 写的，感觉用 PHP-CPP 我就已经输了一半呀，所以我的小目标就是性能超越 SeasClick</p> 
 <p align="center"><img src="https://images2.imgbox.com/e8/05/gMLHgmCT_o.png" alt="a32afb3e7f54d7080d99660cbe8b29d4.png">。</p> 
 <p>性能测试</p> 
 <p>Select 结果：</p> 
 <p align="center"><img src="https://images2.imgbox.com/2a/12/7gJndScB_o.png" alt="215bbf3db013528a84b10ce98e9fa045.png"></p> 
 <p>使用 PDO 访问 ClickHouse 的 MySQL 接口，查询小量数据性能更好</p> 
 <p align="center"><img src="https://images2.imgbox.com/57/0b/VViH84Xn_o.png" alt="bcebb15fc875b5de689d955631eb4fa5.png"></p> 
 <p>小量数据时，OrzClick 和 SeasClick 性能相近，数据大时 OrzClick &gt; SeasClick &gt; MySQL 接口</p> 
 <p align="center"><img src="https://images2.imgbox.com/49/f8/UuTg2hRu_o.png" alt="a32afb3e7f54d7080d99660cbe8b29d4.png"></p> 
 <p>Insert 结果：</p> 
 <p align="center"><img src="https://images2.imgbox.com/b2/39/40rZCKCx_o.png" alt="64c6370cb0380444281c6f83ec3b6c4b.png"></p> 
 <p>OrzClick-Indexed 对标的是 SeasClick，API 最相近(可看代码：1 2)，算是达到了小目标</p> 
 <p align="center"><img src="https://images2.imgbox.com/e2/a7/Wncr4a2h_o.png" alt="a32afb3e7f54d7080d99660cbe8b29d4.png"></p> 
 <p>SeasClick 和 OrzClick 都有提高插入性能的 API，SeasClick 的 startWrite-write-endWrite 性能非常好(图上的 SeasClick-Block)，OrzClick 的 InsertColumnar 只有数据量大于 5 千时才能超过它(图上的 OrzClick-Columnar)</p> 
 <p align="center"><img src="https://images2.imgbox.com/2f/8d/k4pe6hst_o.png" alt="897e23b23f98c3c426f99da689c17b29.png"></p> 
 <p>哪个 clickhouse-cpp ?</p> 
 <p>在 Github 搜索 clickhouse-cpp, 你会发现有两个相似的库：</p> 
 <p>看 LICENSE 和开发人员的评论，可以得知 ClickHouse 官方的才是 fork。简单对比了一下代码，两者底层还是一样的，只是功能特性有一点小小区别。</p> 
 <p>OrzClick 使用的是 ClickHouse/clickhouse-cpp 的 fork，而 SeasClick 是 artpaul/clickhouse-cpp 的 fork，所以大家还是同源的，性能差异就体现在使用方式和补丁了。</p> 
 <p>SeasClick 的优化</p> 
 <p>clickhouse-cpp 的数据插入接口非常简单，就一个入口方法：</p> 
 <p>void Insert(const std::string&amp; table_name, const Block&amp; block);</p> 
 <p>而 SeasClick 把它拆分成:</p> 
 <p>void InsertQuery(const std::string&amp; query, SelectCallback cb);</p> 
 <p>void InsertData(const Block&amp; block);</p> 
 <p>void InsertDataEnd();</p> 
 <p>这个拆分对性能提升、扩展实现有很大帮助：</p> 
 <p>InsertQuery 可以拿到字段的类型信息，可以简化 PHP 接口的使用，不像 OrzClick 一样需要用户指定字段类型</p> 
 <p>InsertQuery + 多次 InsertData + InsertDataEnd 可以实现连续插入，性能提升巨大(见图上的 SeasClick-Block)</p> 
 <p>OrzClick 的优化</p> 
 <p>数据访问模式</p> 
 <p>ClickHouse 是个列式存储的数据库，而它的接口也使用了同样的设计，一次 select 会返回多个 Block，Block 里有多个 Column，一个 Column 里的数据是连续存放的，Column 间是相互独立的。</p> 
 <p>应用层使用数据还是按行为主，所以这里要重新组织一下数据，把列式数据转成行式数据。 SeasClick 是按行处理，而 OrzClick 是按列处理，这是两者的主要区别之一。</p> 
 <p>SeasClick 遍历模式</p> 
 <p>Block</p> 
 <p>┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓</p> 
 <p>┃ Column A Column B Column C ┃</p> 
 <p>┃ ┃</p> 
 <p>┃ ┏━━━━━━━━━┓ ┏━━━━━━━━━┓ ┏━━━━━━━━━┓ ┃</p> 
 <p>Seas─╮──┃───&gt;┃ 1 ┃──&gt;┃ X ┃──&gt;┃ 1.2 ┃ ┃</p> 
 <p>│ ┃ ┣━━━━━━━━━┫ ┣━━━━━━━━━┫ ┣━━━━━━━━━┫ ┃</p> 
 <p>╰──┃───&gt;┃ 2 ┃──&gt;┃ Y ┃──&gt;┃ 2.3 ┃ ┃</p> 
 <p>┃ ┣━━━━━━━━━┫ ┣━━━━━━━━━┫ ┣━━━━━━━━━┫ ┃</p> 
 <p>┃ ┃ 3 ┃ ┃ Z ┃ ┃ 3.4 ┃ ┃</p> 
 <p>┃ ╏ ╏ ╏ ╏ ╏ ╏ ┃</p> 
 <p>┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛</p> 
 <p>OrzClick 遍历模式</p> 
 <p>Block</p> 
 <p>┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓</p> 
 <p>┃ Column A Column B Column C ┃</p> 
 <p>╭───────────────────╮─────────────╮ ┃</p> 
 <p>Orz ─╯──┃─╮ ┏━━━━━━━━━┓ │ ┏━━━━━━━━━┓ │ ┏━━━━━━━━━┓ ┃</p> 
 <p>┃ │ ┃ 1 ┃ │ ┃ X ┃ │ ┃ 1.2 ┃ ┃</p> 
 <p>┃ │ ┣━━━━━━━━━┫ │ ┣━━━━━━━━━┫ │ ┣━━━━━━━━━┫ ┃</p> 
 <p>┃ │ ┃ 2 ┃ │ ┃ Y ┃ │ ┃ 2.3 ┃ ┃</p> 
 <p>┃ │ ┣━━━━━━━━━┫ │ ┣━━━━━━━━━┫ │ ┣━━━━━━━━━┫ ┃</p> 
 <p>┃ V ┃ 3 ┃ V ┃ Z ┃ V ┃ 3.4 ┃ ┃</p> 
 <p>┃ ╏ ╏ ╏ ╏ ╏ ╏ ┃</p> 
 <p>┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛</p> 
 <p>SeasClick 的实现类似这样：</p> 
 <p>for (auto i = 0; i &lt; block.GetRowCount(); i++) { // 外层按行遍历</p> 
 <p>for (auto j = 0; j &lt; block.GetColumnCount(); j++) { // 行内再按列遍历</p> 
 <p>switch (block[i]-&gt;GetType().GetCode()) { // 每一列类型都不同，要相应处理</p> 
 <p>case clickhouse::Type::Int8:</p> 
 <p>add_assoc_long_ex(result, key, len, block[i]-&gt;As&lt;:columnint8&gt;()-&gt;At(j));</p> 
 <p>break;</p> 
 <p>case ...// 其他类型类似</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>OrzClick 的实现类似这样：</p> 
 <p>for (auto i = 0; i &lt; block.GetColumnCount(); i++) { // 外层按列遍历</p> 
 <p>switch (block[i]-&gt;GetType().GetCode()) { // 每一列类型都不同，要相应处理</p> 
 <p>case clickhouse::Type::Int8:</p> 
 <p>auto col = block[i]-&gt;As&lt;:columnint8&gt;();</p> 
 <p>for (auto j = 0; j &lt; block.GetRowCount(); j++) { // 列内再按行遍历</p> 
 <p>add_assoc_long_ex(result, key, col-&gt;At(j));</p> 
 <p>}</p> 
 <p>break;</p> 
 <p>case ...// 其他类型类似</p> 
 <p>}</p> 
 <p>}</p> 
 <p>对比一下可以看到 SeasClick 的内层循环会有大量的 switch 分支跳转，而 OrzClick</p> 
 <p>在外层判断了类型，内层循环非常紧湊，没有多余的分支。</p> 
 <p>用 perf stat 分析一下，SeasClick 分支数(branches)、分支预测错误数(branch-misses)都在 OrzClick 的 2 倍以上：</p> 
 <p># perf stat php select-orzclick.php 1000 1000</p> 
 <p>Performance counter stats for 'php select-orzclick.php 1000 1000':</p> 
 <p>496.85 msec task-clock:u # 0.340 CPUs utilized</p> 
 <p>0 context-switches:u # 0.000 K/sec</p> 
 <p>0 cpu-migrations:u # 0.000 K/sec</p> 
 <p>1,977 page-faults:u # 0.004 M/sec</p> 
 <p>1,761,248,425 cycles:u # 3.545 GHz</p> 
 <p>2,601,973,475 instructions:u # 1.48 insn per cycle</p> 
 <p>487,402,260 branches:u # 980.986 M/sec</p> 
 <p>2,879,008 branch-misses:u # 0.59% of all branches</p> 
 <p># perf stat php select-seasclick.php 1000 1000</p> 
 <p>Performance counter stats for 'php select-seasclick.php 1000 1000':</p> 
 <p>896.48 msec task-clock:u # 0.482 CPUs utilized</p> 
 <p>0 context-switches:u # 0.000 K/sec</p> 
 <p>0 cpu-migrations:u # 0.000 K/sec</p> 
 <p>1,962 page-faults:u # 0.002 M/sec</p> 
 <p>3,316,728,038 cycles:u # 3.700 GHz</p> 
 <p>6,019,365,862 instructions:u # 1.81 insn per cycle</p> 
 <p>1,316,036,409 branches:u # 1468.000 M/sec (2.7x)</p> 
 <p>10,073,424 branch-misses:u # 0.77% of all branches (3.4x)</p> 
 <p>所以在 select 测试中，数据量少的时候 OrzClick 只比 SeasClick 略好，但数据量大了性能差距就拉开了。</p> 
 <p>当然也有退化到 OrzClick 不利的情况，就是 ClickHouse 返回多个Block，但每个 Block 都只有一行，目前只发现 Memory 引擎有这种情况。</p> 
 <p>TCP_NODELAY</p> 
 <p>在测试的时候，发现少量数据反而更慢，就是一字节的区别：</p> 
 <p>$ time php insert-orzclick.php 8170 100</p> 
 <p>real 0m3.894s</p> 
 <p>user 0m0.030s</p> 
 <p>sys 0m0.061s</p> 
 <p>$ time php insert-orzclick.php 8171 100</p> 
 <p>real 0m0.422s</p> 
 <p>user 0m0.050s</p> 
 <p>sys 0m0.022s</p> 
 <p>看 ClickHouse 日志，处理少量数据反而时多用了 40ms 左右的时间(大佬们看到 40 ms 就大概猜到了吧)。</p> 
 <p>对比两者的火焰图，虽然执行的总时间不同，但是各种函数的比例是接近的， 大头都是 _zend_hash_find_known_hash:</p> 
 <p align="center"><img src="https://images2.imgbox.com/51/cf/aqnNvkPB_o.png" alt="dbdcbc8a53ff0949307f6376606420ec.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/43/13/fbfHcqIP_o.png" alt="d4fd14eabdadb7cbadc328cfd9bc64f2.png"></p> 
 <p>难道问题真在 PHP？我移除掉 clickhouse-cpp 的调用，发现两种情况执行时间基本相同，这也就排除掉 PHP 的可能性，问题应该出在 clickhouse-cpp。</p> 
 <p>再用 strace 跟踪，发现数据少的时候是只有一个 send 系统调用，多的时候会分成两个：</p> 
 <p># 8170</p> 
 <p>sendto(3, "\2\0\1\0\2\377\377\377\377\0\1\352?\2u8"..., 8192, MSG_NOSIGNAL, NULL, 0) = 8192</p> 
 <p># 8171</p> 
 <p>sendto(3, "\2\0\1\0\2\377\377\377\377\0\1\353?\2u8"..., 22, MSG_NOSIGNAL, NULL, 0) = 22</p> 
 <p>sendto(3, "\1\2\3\4\5\6\7\10\t\n\v\f\r\16\17\20"..., 8171, MSG_NOSIGNAL, NULL, 0) = 8171</p> 
 <p>8170 和 8171 这个临界点，发现和 clickhouse-cpp 的缓冲区大小 8192 很接近。于是我试着调整 clickhouse-cpp 缓冲区大小，的确会影响 send 的次数，但只是临界点有点变化，不能解决问题。</p> 
 <p>至此基本可以确定是内核和协议栈的影响，于是想有那些配置可能影响发送、 接收延迟，然后就想到了 TCP_NODELAY，于是我提了个 PR，给 clickhouse-cpp 加上了 TCP_NODELAY 选项(PR在2020-01-10合并)，测试性能终于稳定了。</p> 
 <p>后来我又尝试用 Off-CPU 火焰图，只能看到在 recv 时有等待，还不能直接看出原因，这种问题没经验真不易处理(虽然搜索 TCP 40ms 就有结果)。</p> 
 <p align="center"><img src="https://images2.imgbox.com/9a/80/aLDQQNio_o.png" alt="2fe104de2608672d8926bbf4794cf9a0.png"></p> 
 <p>PHP-CPP 损耗</p> 
 <p>PHP-CPP 封装了 Zend API，开发扩展基本可以不考虑 Zend 引擎低层(zval、HashTable 等等)，非常方便，代价就是更多额外操作和性能损耗。</p> 
 <p>优化方式非常暴力，直接修改 PHP-CPP，暴露出被封装的 zval，然后直接用 Zend API 操作。过程就是先用 PHP-CPP 写，然后用火焰图发现热点，然后替换成 Zend API。</p> 
 <p>例如在 nestedForeach 方法里，需要获取数组的值，如果用 PHP-CPP 的 Value::get() 最后会复制一次：</p> 
 <p>Value::Value(struct _zval_struct *val, bool ref)</p> 
 <p>{<!-- --></p> 
 <p>// do we have to force a reference?</p> 
 <p>if (!ref)</p> 
 <p>{<!-- --></p> 
 <p>// we don't, simply duplicate the value</p> 
 <p>ZVAL_DUP(_val, val);</p> 
 <p>}</p> 
 <p>批量插入的时候，就会有不必要的数组复制。所以这里改成 zend_hash_find 拿到 *zval，然后直接遍历：</p> 
 <p>zval *item;</p> 
 <p>auto column = zend_hash_find(Z_ARRVAL_P(data._val), key);</p> 
 <p>auto ht = Z_ARRVAL_P(column);</p> 
 <p>ZEND_HASH_FOREACH_VAL(ht, item) {<!-- --></p> 
 <p>callback(item);</p> 
 <p>}</p> 
 <p>ZEND_HASH_FOREACH_END();</p> 
 <p>结束语</p> 
 <p>国庆假期通过这个项目，每样学到了一点点：</p> 
 <p>ClickHouse</p> 
 <p>PHP 扩展开发</p> 
 <p>C++</p> 
 <p>CMake</p> 
 <p>性能优化</p> 
 <p>也有没做好的：</p> 
 <p>单元测试，本来想用 phpt，但没写，目前在 tests 目录有几个我开发时用的用例子</p> 
 <p>CI，准备试试 GitHub Action</p> 
 <p>最后，从 OrzClick 这名字你就应该知道，这是出于玩和学习的目的写的，生产环境还是建议用 SeasClick。</p> 
 <p>本作品采用《CC 协议》，转载必须注明作者和本文链接</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f0d7edb2501d72e71617ef1c812ab72/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手机拍摄界面的各种符合如何使用-以小米10为例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6de33a1de7e8258ba49af9ee670abf9a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">clickhouse php,php 链接 clickhouse</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>