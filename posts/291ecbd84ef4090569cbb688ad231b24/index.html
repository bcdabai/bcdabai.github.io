<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;QT入门 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;QT入门" />
<meta property="og:description" content="C&#43;&#43;QT 文章目录 C&#43;&#43;QT1. QT概述1.1 什么是QT1.2 QT的发展史1.3 支持的平台1.4 QT版本1.5 Qt 的下载与安装1.6 QT的优点1.7 成功案例 2. 创建QT项目2.1 使用向导创建2.2 手动创建2.3 .pro 文件2.4 设置父对象2.5 按钮设置属性2.5.1 按钮设置文本2.5.2 设置移动2.5.3 设置固定大小 2.6 另外一种创建按钮方式2.6.1 构造时创建2.6.2 初始化后设置与构造函数设置的区别 2.7 对象模型（对象树）2.8 Qt窗口坐标体系 3 信号与槽机制3.1 信号与槽3.2 系统自带的信号与槽3.3 常用的信号3.4 自定义槽函数3.5 自定义信号3.6 信号槽拓展3.6 Qt4版本的信号槽写法3.7 Lambda 表达式3.7.1 lambda传参（无参数）3.7.2 lambda 传参（有参数）3.7.3 传值和传址 4. QMainWindow4.1 介绍4.2 工具栏4.3 状态栏4.4 铆接部件4.5 中心部件4.6 资源文件4.7 增加背景图 5. 对话框5.1 基本概念5.2 标准对话框5.2.1 模态对话框5.2.2 非模态对话框 5.3 消息对话框 6.布局管理器6.1 系统布局6.2 利用widget 做布局 7.常用控件7.1 QLabel7.1.1 显示文字（普通文本、html）7.1.2 显示图片7." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/291ecbd84ef4090569cbb688ad231b24/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-21T23:44:21+08:00" />
<meta property="article:modified_time" content="2023-06-21T23:44:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;QT入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="CQT_0"></a>C++QT</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#CQT_0" rel="nofollow">C++QT</a></li><li><ul><li><a href="#1_QT_3" rel="nofollow">1. QT概述</a></li><li><ul><li><a href="#11_QT_5" rel="nofollow">1.1 什么是QT</a></li><li><a href="#12_QT_16" rel="nofollow">1.2 QT的发展史</a></li><li><a href="#13__26" rel="nofollow">1.3 支持的平台</a></li><li><a href="#14_QT_34" rel="nofollow">1.4 QT版本</a></li><li><a href="#15_Qt__41" rel="nofollow">1.5 Qt 的下载与安装</a></li><li><a href="#16_QT_54" rel="nofollow">1.6 QT的优点</a></li><li><a href="#17__64" rel="nofollow">1.7 成功案例</a></li></ul> 
   </li><li><a href="#2_QT_75" rel="nofollow">2. 创建QT项目</a></li><li><ul><li><a href="#21__77" rel="nofollow">2.1 使用向导创建</a></li><li><a href="#22__89" rel="nofollow">2.2 手动创建</a></li><li><a href="#23_pro__103" rel="nofollow">2.3 .pro 文件</a></li><li><a href="#24__172" rel="nofollow">2.4 设置父对象</a></li><li><a href="#25__206" rel="nofollow">2.5 按钮设置属性</a></li><li><ul><li><a href="#251__208" rel="nofollow">2.5.1 按钮设置文本</a></li><li><a href="#252__214" rel="nofollow">2.5.2 设置移动</a></li><li><a href="#253__220" rel="nofollow">2.5.3 设置固定大小</a></li></ul> 
    </li><li><a href="#26__226" rel="nofollow">2.6 另外一种创建按钮方式</a></li><li><ul><li><a href="#261__228" rel="nofollow">2.6.1 构造时创建</a></li><li><a href="#262__234" rel="nofollow">2.6.2 初始化后设置与构造函数设置的区别</a></li></ul> 
    </li><li><a href="#27__239" rel="nofollow">2.7 对象模型（对象树）</a></li><li><a href="#28__Qt_264" rel="nofollow">2.8 Qt窗口坐标体系</a></li></ul> 
   </li><li><a href="#3__271" rel="nofollow">3 信号与槽机制</a></li><li><ul><li><a href="#31__273" rel="nofollow">3.1 信号与槽</a></li><li><a href="#32__279" rel="nofollow">3.2 系统自带的信号与槽</a></li><li><ul><li><a href="#33__289" rel="nofollow">3.3 常用的信号</a></li><li><a href="#34__295" rel="nofollow">3.4 自定义槽函数</a></li><li><a href="#35__369" rel="nofollow">3.5 自定义信号</a></li><li><a href="#36__391" rel="nofollow">3.6 信号槽拓展</a></li><li><a href="#36_Qt4_417" rel="nofollow">3.6 Qt4版本的信号槽写法</a></li><li><a href="#37_Lambda__429" rel="nofollow">3.7 Lambda 表达式</a></li><li><ul><li><a href="#371_lambda_481" rel="nofollow">3.7.1 lambda传参（无参数）</a></li><li><a href="#372_lambda__494" rel="nofollow">3.7.2 lambda 传参（有参数）</a></li><li><a href="#373__505" rel="nofollow">3.7.3 传值和传址</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#4_QMainWindow_523" rel="nofollow">4. QMainWindow</a></li><li><ul><li><a href="#41__525" rel="nofollow">4.1 介绍</a></li><li><a href="#42__623" rel="nofollow">4.2 工具栏</a></li><li><a href="#43__676" rel="nofollow">4.3 状态栏</a></li><li><a href="#44__703" rel="nofollow">4.4 铆接部件</a></li><li><a href="#45__722" rel="nofollow">4.5 中心部件</a></li><li><a href="#46__733" rel="nofollow">4.6 资源文件</a></li><li><a href="#47__739" rel="nofollow">4.7 增加背景图</a></li></ul> 
   </li><li><a href="#5__758" rel="nofollow">5. 对话框</a></li><li><ul><li><a href="#51__760" rel="nofollow">5.1 基本概念</a></li><li><a href="#52__773" rel="nofollow">5.2 标准对话框</a></li><li><ul><li><a href="#521__787" rel="nofollow">5.2.1 模态对话框</a></li><li><a href="#522__795" rel="nofollow">5.2.2 非模态对话框</a></li></ul> 
    </li><li><a href="#53__824" rel="nofollow">5.3 消息对话框</a></li></ul> 
   </li><li><a href="#6_919" rel="nofollow">6.布局管理器</a></li><li><ul><li><a href="#61__935" rel="nofollow">6.1 系统布局</a></li><li><a href="#62_widget__941" rel="nofollow">6.2 利用widget 做布局</a></li></ul> 
   </li><li><a href="#7_951" rel="nofollow">7.常用控件</a></li><li><ul><li><a href="#71_QLabel_955" rel="nofollow">7.1 QLabel</a></li><li><ul><li><a href="#711_html_959" rel="nofollow">7.1.1 显示文字（普通文本、html）</a></li><li><a href="#712__986" rel="nofollow">7.1.2 显示图片</a></li><li><a href="#713__1003" rel="nofollow">7.1.3 显示动画</a></li></ul> 
    </li><li><a href="#72_QLineEdit_1025" rel="nofollow">7.2 QLineEdit</a></li><li><ul><li><a href="#721__1029" rel="nofollow">7.2.1 设置/获取内容</a></li><li><a href="#722__1043" rel="nofollow">7.2.2 设置显示模式</a></li></ul> 
   </li></ul> 
   </li><li><a href="#8_Qt__1105" rel="nofollow">8. Qt 消息机制和事件</a></li><li><ul><li><a href="#81__1107" rel="nofollow">8.1 事件处理过程</a></li><li><a href="#82__1119" rel="nofollow">8.2 常用事件处理</a></li><li><ul><li><a href="#821__1123" rel="nofollow">8.2.1 鼠标事件</a></li><li><a href="#822_QWheelEvent_1134" rel="nofollow">8.2.2 滚轮事件(QWheelEvent)</a></li><li><a href="#823_QKeyEvent_1153" rel="nofollow">8.2.3 键盘事件(QKeyEvent)</a></li><li><a href="#824_QResizeEvent_1193" rel="nofollow">8.2.4 大小改变事件(QResizeEvent)</a></li><li><a href="#825_enterEventleaveEvent_1208" rel="nofollow">8.2.5 进入离开区域事件(enterEvent、leaveEvent)</a></li></ul> 
   </li></ul> 
   </li><li><a href="#9__1224" rel="nofollow">9 绘图</a></li><li><ul><li><a href="#91_Qt_1226" rel="nofollow">9.1 Qt绘图机制</a></li><li><a href="#92__1237" rel="nofollow">9.2 绘图事件</a></li><li><a href="#93__1268" rel="nofollow">9.3 刷新绘图区域</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1_QT_3"></a>1. QT概述</h3> 
<h4><a id="11_QT_5"></a>1.1 什么是QT</h4> 
<p>​ Qt 是一个<strong>跨平台的C++图形用户界面应用程序框架</strong>。它为应用程序开发者提供建立艺术级图形界面<br> 所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。</p> 
<p>常见GUI：</p> 
<p>QT：支持多平台开发；支持css；面向对象特性体现突出；发展趋势良好。</p> 
<p>MFC：只能在windows开发；运行程序效率高；库的安全性好；</p> 
<h4><a id="12_QT_16"></a>1.2 QT的发展史</h4> 
<ul><li>1991 年Qt 最早由奇趣科技开发</li><li>1996 年进入商业领域，它也是目前流行的Linux 桌面环境KDE 的基础</li><li>2008 年奇趣科技被诺基亚公司收购，Qt 称为诺基亚旗下的编程语言</li><li>2012 年Qt 又被Digia 公司收购</li><li>2014 年4 月跨平台的集成开发环境Qt Creator3.1.0 发布，同年5 月20 日配发了Qt5.3 正式版，</li><li>至此Qt 实现了对iOS、Android、WP 等各平台的全面支持。</li><li>当前Qt 最新版本为5.13.2（2019.12 之前）</li></ul> 
<h4><a id="13__26"></a>1.3 支持的平台</h4> 
<ul><li>Windows – XP、Vista、Win7、Win8、Win2008、Win10</li><li>Uinux/X11 – Linux、Sun Solaris、HP-UX、Compaq Tru64 UNIX、IBM AIX、SGI IRIX、FreeBSD、<br> BSD/OS、和其他很多X11 平台</li><li>Macintosh – Mac OS X</li><li>Embedded – 有帧缓冲支持的嵌入式Linux 平台，Windows CE</li></ul> 
<h4><a id="14_QT_34"></a>1.4 QT版本</h4> 
<p>Qt 按照不同的版本发行，分为商业版和开源版</p> 
<ul><li>商业版：商业软件提供开发，他们提供传统商业软件发行版，并且提供在商业有效期内的免费升级和技术支持服务。</li><li>开源版（LGPL）：开源的LGPL 版本，为了开发自有而设计的开放源码软件，它提供了和商业版本同样的功能，在GNU 通用公共许可下，它是免费的。</li></ul> 
<h4><a id="15_Qt__41"></a>1.5 Qt 的下载与安装</h4> 
<ul><li>http://www.qt.io/download-open-source/</li><li>http://download.qt.io/archive/qt/</li></ul> 
<p><img src="https://images2.imgbox.com/9e/69/H3RQGTGP_o.png" alt="image-20230617192318611"></p> 
<p><img src="https://images2.imgbox.com/07/dd/a7yCf18M_o.png" alt="image-20230617192628524"></p> 
<p>按照默认安装即可<br> Qt 对不同的平台提供了不同版本的安装包，可根据实际情况自行下载安装，本文档使用<br> qt-opensource-windows-x86-mingw530-5.13.0 版本进行讲解（32 位和64 位均可安装）</p> 
<h4><a id="16_QT_54"></a>1.6 QT的优点</h4> 
<ul><li> <p>跨平台，几乎支持所有的平台</p> </li><li> <p>接口简单，容易上手，学习QT 框架对学习其他框架有参考意义。</p> </li><li> <p>一定程度上简化了内存回收机制</p> </li><li> <p>开发效率高，能够快速的构建应用程序。</p> </li><li> <p>有很好的社区氛围，市场份额在缓慢上升。</p> </li><li> <p>可以进行嵌入式开发。</p> </li></ul> 
<h4><a id="17__64"></a>1.7 成功案例</h4> 
<ul><li>Linux 桌面环境KDE</li><li>Skype 网络电话</li><li>Google Earth 谷歌地图</li><li>VLC 多媒体播放器</li><li>VirtualBox 虚拟机软件</li><li>咪咕音乐</li><li>WPS Office</li><li>极品飞车</li></ul> 
<h3><a id="2_QT_75"></a>2. 创建QT项目</h3> 
<h4><a id="21__77"></a>2.1 使用向导创建</h4> 
<ul><li>打开<strong>Qt Creator</strong> 界面选择</li><li>New Project 或者选择菜单栏【文件】-【新建文件或项目】菜单项</li><li>弹出New Project 对话框，选择Qt Widgets Application</li></ul> 
<p><img src="https://images2.imgbox.com/81/bb/HnKGcrFP_o.png" alt="image-20230617205216497"></p> 
<p><img src="https://images2.imgbox.com/b7/99/8Ud6J97b_o.png" alt="image-20230617205254631"></p> 
<p><img src="https://images2.imgbox.com/a6/0c/UzFvKjuw_o.png" alt="image-20230617215755059"></p> 
<h4><a id="22__89"></a>2.2 手动创建</h4> 
<ul><li>添加一个空项目</li></ul> 
<p><img src="https://images2.imgbox.com/67/c7/sXesHjaa_o.png" alt="image-20230617220114633"></p> 
<ul><li>选择【choose】进行下一步。设置项目名称和路径—&gt; 选择编译套件–&gt; 修改类信息–&gt; 完成（步骤同上），生成一个空项目。在空项目中添加文件：在项目名称上单击鼠标右键弹出右键菜单，选择【添加新文件】</li></ul> 
<p><img src="https://images2.imgbox.com/1f/c4/miD2LT7l_o.png" alt="image-20230617220131998"></p> 
<ul><li>弹出新建文件对话框</li></ul> 
<p><img src="https://images2.imgbox.com/69/55/PRIPxoAC_o.png" alt="image-20230617220150476"></p> 
<h4><a id="23_pro__103"></a>2.3 .pro 文件</h4> 
<p>在使用Qt 向导生成的应用程序.pro 文件格式如下：</p> 
<pre><code class="prism language-c++">QT += core gui //包含的模块
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets //大于Qt4 版本才包含widget 模块
TARGET = QtFirst //应用程序名生成的.exe 程序名称
TEMPLATE = app //模板类型应用程序模板
SOURCES += main.cpp //源文件
mywidget.cpp
HEADERS += mywidget.h //头文件
</code></pre> 
<p>.pro 就是工程文件(project)，它是qmake 自动生成的用于生产makefile 的配置文件。.pro 文件的<br> 写法如下：</p> 
<ul><li>注释<br> 从“#”开始，到这一行结束。</li><li>模板变量告诉qmake 为这个应用程序生成哪种makefile。下面是可供使用的选择：TEMPLATE = app,app -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。</li><li>lib - 建立一个库的makefile。</li><li>vcapp - 建立一个应用程序的VisualStudio 项目文件。</li><li>vclib - 建立一个库的VisualStudio 项目文件。</li><li>subdirs -这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile 并且为它调用make 的makefile。</li></ul> 
<pre><code>#指定生成的应用程序名：
TARGET = QtDemo
#工程中包含的头文件
HEADERS += include/painter.h
#工程中包含的.ui 设计文件
FORMS += forms/painter.ui
#工程中包含的源文件
SOURCES += sources/main.cpp sources
#工程中包含的资源文件
RESOURCES += qrc/painter.qrc
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
这条语句的含义是，如果QT_MAJOR_VERSION 大于4（也就是当前使用的Qt5 及更高版本）需要
增加widgets 模块。如果项目仅需支持Qt5，也可以直接添加“QT += widgets”一句。不过为
了保持代码兼容，最好还是按照QtCreator 生成的语句编写。
#配置信息
CONFIG 用来告诉qmake 关于应用程序的配置信息。
CONFIG += c++11 //使用c++11 的特性
在这里使用“+=”，是因为我们添加我们的配置选项到任何一个已经存在中。这样做比使用“=”那
样替换已经指定的所有选项更安全。
</code></pre> 
<pre><code class="prism language-c++">#include "widget.h"
#include "ui_widget.h"

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui-&gt;setupUi(this);
    // 重新更新
    this-&gt;setWindowTitle("hello world"); // 更改UI内容
    this-&gt;resize(600,400);
}

Widget::~Widget()
{
    delete ui;
}


</code></pre> 
<h4><a id="24__172"></a>2.4 设置父对象</h4> 
<pre><code class="prism language-c++">#include "widget.h"
#include "ui_widget.h"
#include &lt;QPushButton&gt;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui-&gt;setupUi(this);
    // 重新更新
    this-&gt;setWindowTitle("hello world");
    // 设置 完成之后可以拉伸
    this-&gt;resize(600,400);
    // 设置固定大小
    this-&gt;setFixedSize(QSize(200,200));

    QPushButton *button =  new QPushButton;
    // 设置父亲对象
    button-&gt;setParent(this);
}

Widget::~Widget()
{
    delete ui;
}


</code></pre> 
<p><img src="https://images2.imgbox.com/86/62/1K9NYsld_o.png" alt="image-20230618001225199"></p> 
<h4><a id="25__206"></a>2.5 按钮设置属性</h4> 
<h5><a id="251__208"></a>2.5.1 按钮设置文本</h5> 
<pre><code class="prism language-c++">button-&gt;setText("红红红！");
</code></pre> 
<h5><a id="252__214"></a>2.5.2 设置移动</h5> 
<pre><code class="prism language-c++">button-&gt;move(50,50);
</code></pre> 
<h5><a id="253__220"></a>2.5.3 设置固定大小</h5> 
<pre><code class="prism language-c++">button-&gt;setFixedSize(QSize(400,400));
</code></pre> 
<h4><a id="26__226"></a>2.6 另外一种创建按钮方式</h4> 
<h5><a id="261__228"></a>2.6.1 构造时创建</h5> 
<pre><code class="prism language-c++">      QPushButton *button2 = new QPushButton("第二个按钮",this); // 包括设置文本和父对象
</code></pre> 
<h5><a id="262__234"></a>2.6.2 初始化后设置与构造函数设置的区别</h5> 
<ul><li>初始化后设置，显示为窗口的默认大小</li><li>构造函数设置会导致窗口大小为按钮大小，需要重新设置大小。</li></ul> 
<h4><a id="27__239"></a>2.7 对象模型（对象树）</h4> 
<p>在Qt中创建对象的时候会提供一个Parent对象指针，下面来解释这个parent到底<br> 是干什么的。</p> 
<ul><li>QObject是以对象树的形式组织起来的。</li></ul> 
<p>当你创建一个QObject对象时，会看到QObject的构造函数接收一个QObject指针作为参数，这个参数就是 parent，也就是父对象指针。<br> 这相当于，在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。<br> n 当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！）</p> 
<ul><li>QWidget是能够在屏幕上显示的一切组件的父类。</li></ul> 
<p>QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。</p> 
<ul><li>当然，我们也可以自己删除子对象，它们会自动从其父对象列表中删除。比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。</li></ul> 
<p><img src="https://images2.imgbox.com/bb/f6/BJugVVeh_o.png" alt="image-20230619095633992"></p> 
<ul><li>Qt 引入对象树的概念，在一定程度上解决了内存问题。 
  <ul><li>当一个QObject对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。</li><li>任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete 两次，这是由析构顺序决定的。如果QObject在栈上创建，Qt 保持同样的行为。正常情况下，这也不会发生什么问题。</li><li>作为父组件的 window 和作为子组件的 quit 都是QObject的子类（事实上，它们都是QWidget的子类，而QWidget是QObject的子类）。这段代码是正确的，quit 的析构函数不会被调用两次，因为标准 C++要求，局部对象的析构顺序应该按照其创建顺序的相反过程。因此，这段代码在超出作用域时，会先调用quit 的析构函数，将其从父对象 window 的子对象列表中删除，然后才会再调用 window 的析构函数。</li><li>在 Qt 中，尽量在构造的时候就指定 parent 对象，并且大胆在堆上创建。</li></ul> </li></ul> 
<h4><a id="28__Qt_264"></a>2.8 Qt窗口坐标体系</h4> 
<p>坐标体系：<br> 以左上角为原点（0,0），X向右增加，Y向下增加。</p> 
<p><img src="https://images2.imgbox.com/5e/a0/ADJ8ZmU8_o.png" alt="image-20230619095748503"></p> 
<h3><a id="3__271"></a>3 信号与槽机制</h3> 
<h4><a id="31__273"></a>3.1 信号与槽</h4> 
<p>信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。</p> 
<p><img src="https://images2.imgbox.com/3e/b2/IxHTEeFn_o.png" alt="image-20230619100459070"></p> 
<h4><a id="32__279"></a>3.2 系统自带的信号与槽</h4> 
<p>connect()函数最常用的一般形式：connect(sender, signal, receiver, slot);<br> 参数解释：</p> 
<p>sender：发出信号的对象<br> signal：发送对象发出的信号<br> receiver：接收信号的对象<br> slot：接收对象在接收到信号之后所需要调用的函数（槽函数）</p> 
<h5><a id="33__289"></a>3.3 常用的信号</h5> 
<p>那么系统自带的信号和槽通常如何查找呢，这个就需要利用帮助文档了，在帮助文档中比如我们上面的按钮的点击信号，在帮助文档中输入QPushButton，首先我们可以在Contents中寻找关键字 signals，信号的意思，但是我们发现并没有找到，这时候我们应该想到也许这个信号的被父类继承下来的，因此我们去他的父类QAbstractButton中就可以找到该关键字，点击signals索引到系统自带的信号有如下几个</p> 
<p><img src="https://images2.imgbox.com/79/19/MugudPYL_o.png" alt="image-20230619101434174"></p> 
<h5><a id="34__295"></a>3.4 自定义槽函数</h5> 
<pre><code class="prism language-c++">#ifndef WIDGET_H
#define WIDGET_H
#include &lt;QDebug&gt;
#include &lt;QWidget&gt;

QT_BEGIN_NAMESPACE
namespace Ui { class Widget; }
QT_END_NAMESPACE

class Widget : public QWidget
{
    Q_OBJECT

public:
    Widget(QWidget *parent = nullptr);
    ~Widget();
public slots: // 添加槽函数
    void print();

private:
    Ui::Widget *ui;
};
#endif // WIDGET_H

</code></pre> 
<pre><code class="prism language-c++">#include "widget.h"
#include "ui_widget.h"
#include &lt;QPushButton&gt;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui-&gt;setupUi(this);
    // 重新更新
    this-&gt;setWindowTitle("hello world");
    // 设置 完成之后可以拉伸
    this-&gt;resize(600,400);
    // 设置固定大小
    this-&gt;setFixedSize(QSize(600,400));

//    QPushButton *button =  new QPushButton;
    // 设置父亲对象
//    button-&gt;setParent(this);
//    button-&gt;setText("中国红！");
//    // 按钮移动
//    button-&gt;move(50,50);
//    // 设置按钮大小
//    button-&gt;setFixedSize(QSize(400,400));
      QPushButton *button2 = new QPushButton("第二个按钮（关闭）",this);
      # 定义信号函数
      connect(button2,&amp;QPushButton::clicked,this,&amp;Widget::print);


}

Widget::~Widget()
{
    delete ui;
}

void Widget::print(){
    qDebug()&lt;&lt;"hello world!"; // 槽函数实现
}

</code></pre> 
<p><img src="https://images2.imgbox.com/6a/c3/o9tCooz8_o.png" alt="image-20230619110112323"></p> 
<h5><a id="35__369"></a>3.5 自定义信号</h5> 
<p><img src="https://images2.imgbox.com/a9/57/1Kc0b8cC_o.png" alt="image-20230619164419572"></p> 
<p>自定义信号槽需要注意的事项:</p> 
<ul><li>发送者和接收者都需要是QObject 的子类（当然，槽函数是全局函数、Lambda 表达式等无需接<br> 收者的时候除外）；</li><li>信号和槽函数返回值是void</li><li>信号只需要声明，不需要实现</li><li>槽函数需要声明也需要实现</li><li>槽函数是普通的成员函数，作为成员函数，会受到public、private、protected 的影响；</li><li>使用emit 在恰当的位置发送信号；</li><li>使用connect()函数连接信号和槽。</li><li>任何成员函数、static 函数、全局函数和Lambda 表达式都可以作为槽函数</li><li>信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。</li><li>如果信号和槽的参数不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函<br> 数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选<br> 择忽略信号传来的数据（也就是槽函数的参数比信号的少）。</li></ul> 
<p><img src="https://images2.imgbox.com/13/86/HqSASUmi_o.png" alt="image-20230619221022227"></p> 
<h5><a id="36__391"></a>3.6 信号槽拓展</h5> 
<ul><li> <p>一个信号可以和多个槽相连<br> 如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。</p> </li><li> <p>多个信号可以连接到一个槽<br> 只要任意一个信号发出，这个槽就会被调用</p> </li><li> <p>一个信号可以连接到另外的一个信号<br> 当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式<br> 没有什么区别。</p> </li><li> <p>槽可以被取消链接<br> 这种情况并不经常出现，因为当一个对象delete 之后，Qt 自动取消所有连接到这个对象上面的<br> 槽。</p> </li><li> <p>信号槽可以断开<br> 利用disconnect 关键字是可以断开信号槽的</p> </li><li> <p>使用Lambda 表达式<br> 在使用Qt5 的时候，能够支持Qt 5 的编译器都是支持Lambda 表达式的。<br> 在连接信号和槽的时候，槽函数可以使用Lambda 表达式的方式进行处理。</p> </li></ul> 
<p>重载信号时需要利用函数指针来确定执行的槽函数与信号函数</p> 
<pre><code class="prism language-c++"> void (Teacher:: *teacherSignal)(QString) = &amp;Teacher::hungry;
 void (Student:: *studentSignal)(QString) = &amp;Student::treat;
</code></pre> 
<h5><a id="36_Qt4_417"></a>3.6 Qt4版本的信号槽写法</h5> 
<pre><code class="prism language-c++">connect(zt,SIGNAL(hungry(QString)),st,SLOT(treat(QString)));
</code></pre> 
<p>这里使用了SIGNAL 和SLOT 这两个宏，将两个函数名转换成了字符串。注意到connect()函数的<br> signal 和slot 都是接受字符串，一旦出现连接不成功的情况，Qt4 是没有编译错误的（因为一切<br> 都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不<br> 稳定性。<br> <strong>Qt5 在语法上完全兼容Qt4，而反之是不可以的。</strong></p> 
<h5><a id="37_Lambda__429"></a>3.7 Lambda 表达式</h5> 
<p>C++11 中的Lambda 表达式用于定义并创建匿名的函数对象，以简化编程工作。</p> 
<p>Lambda表达式的基本构成：</p> 
<pre><code class="prism language-c++">[capture](parameters) mutable -&gt;return-type
{
statement
}
</code></pre> 
<ul><li>函数对象参数；<br> []，标识一个Lambda 的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动<br> 生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda 为止时Lambda 所<br> 在作用范围内可见的局部变量（包括Lambda 所在类的this）。函数对象参数有以下形式： 
  <ul><li>空。没有使用任何函数对象参数。</li><li>=。函数体内可以使用Lambda 所在作用范围内所有可见的局部变量（包括Lambda 所在类的<br> this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li><li>&amp;。函数体内可以使用Lambda 所在作用范围内所有可见的局部变量（包括Lambda 所在类的<br> this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。</li><li>this。函数体内可以使用Lambda 所在类中的成员变量。</li><li>a。将a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的a 的拷贝，因为默<br> 认情况下函数是const 的。要修改传递进来的a 的拷贝，可以添加mutable 修饰符。</li><li>&amp;a。将a 按引用进行传递。</li><li>a, &amp;b。将a 按值进行传递，b 按引用进行传递。</li><li>=，&amp;a, &amp;b。除a 和b 按引用进行传递外，其他参数都按值进行传递。</li><li>&amp;, a, b。除a 和b 按值进行传递外，其他参数都按引用进行传递。</li></ul> </li><li>② 操作符重载函数参数；<br> 标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）<br> 和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。</li><li>可修改标示符；<br> mutable 声明，这部分可以省略。按值传递函数对象参数时，加上mutable 修饰符后，可以修改<br> 按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</li></ul> 
<pre><code class="prism language-c++">QPushButton * myBtn = new QPushButton (this);
QPushButton * myBtn2 = new QPushButton (this);
myBtn2-&gt;move(100,100);
int m = 10;
connect(myBtn,&amp;QPushButton::clicked,this,[m] ()mutable { m = 100 + 10; qDebug() &lt;&lt; m; });
connect(myBtn2,&amp;QPushButton::clicked,this,[=] () { qDebug() &lt;&lt; m; });
qDebug() &lt;&lt; m;
</code></pre> 
<ul><li>函数返回值；<br> -&gt;返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return 的地<br> 方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</li><li>是函数体；<br> {}，标识函数的实现，这部分不能省略，但函数体可以为空。</li></ul> 
<h6><a id="371_lambda_481"></a>3.7.1 lambda传参（无参数）</h6> 
<pre><code class="prism language-c++">    auto fun=[](){
       qDebug()&lt;&lt;"hello world!222";
    };
    fun();
</code></pre> 
<p><img src="https://images2.imgbox.com/7b/15/U9E5wUpb_o.png" alt="image-20230620113414659"></p> 
<h6><a id="372_lambda__494"></a>3.7.2 lambda 传参（有参数）</h6> 
<pre><code class="prism language-c++">    auto fun2=[](int a,int b){
       qDebug()&lt;&lt;"hello world!333";
       return a+b;
    };
    ClassIsOver();
    qDebug()&lt;&lt;fun2(2,3);
</code></pre> 
<h6><a id="373__505"></a>3.7.3 传值和传址</h6> 
<pre><code class="prism language-c++">    int a = 10;
    auto fun3= [](int &amp;a,int b){
       qDebug()&lt;&lt;"hello world!333";
       qDebug()&lt;&lt;"a==="&lt;&lt;a;
       a = 20;
       return a+b;
    };

    ClassIsOver();
    qDebug()&lt;&lt;fun3(a,3);

</code></pre> 
<p><img src="https://images2.imgbox.com/22/b5/GyhHLvPf_o.png" alt="image-20230620113312085"></p> 
<h3><a id="4_QMainWindow_523"></a>4. QMainWindow</h3> 
<h4><a id="41__525"></a>4.1 介绍</h4> 
<p>QMainWindow 是一个为用户提供主窗口程序的类，包含一个菜单栏（menu bar）、多个工具栏(toolbars)、多个铆接部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础，如文本编辑器，图片编辑器等。</p> 
<p><img src="https://images2.imgbox.com/0d/d4/FGpRB06T_o.png" alt="image-20230621000022651"></p> 
<p>分别对应菜单栏，菜单，菜单项</p> 
<ul><li>创建菜单栏，通过QMainWindow 类的menubar（）函数获取主窗口菜单栏指针</li></ul> 
<pre><code class="prism language-c++">//创建菜单栏：
#include &lt;QMenuBar&gt;
QMenuBar --&gt; QMenuBar(QWidget *parent = Q_NULLPTR)
//添加菜单栏：
QMainWindow --&gt; void setMenuBar(QMenuBar *menuBar)
</code></pre> 
<ul><li>创建菜单，调用QMenu 的成员函数addMenu 来添加菜单</li></ul> 
<pre><code class="prism language-c++">//创建菜单：
#include &lt;QMenu&gt;
QMenu --&gt; QMenu(const QString &amp;title, QWidget *parent = Q_NULLPTR)
//添加菜单：
MenuBar --&gt; QAction *addMenu(QMenu *menu)
</code></pre> 
<ul><li>创建菜单项，调用QMenu 的成员函数addAction 来添加菜单项</li></ul> 
<pre><code class="prism language-c++">//创建菜单项：
#include &lt;QAction&gt;
QAction --&gt; QAction(const QString &amp;text, QObject *parent = nullptr)
//添加菜单项：
QMenu --&gt; addAction(const QAction *action)
</code></pre> 
<p>Qt 并没有专门的菜单项类，只是使用一个QAction 类，抽象出公共的动作。当我们把QAction 对象添加到菜单，就显示成一个菜单项，添加到工具栏，就显示成一个工具按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激活这个动作。</p> 
<pre><code class="prism language-c++">#include "mainwindow.h"
#include &lt;QMenuBar&gt; //菜单栏
#include &lt;QMenu&gt; //菜单
#include &lt;QAction&gt; //菜单项
#include &lt;QDebug&gt;
MainWindow::MainWindow(QWidget *parent)
: QMainWindow(parent)
{
//**********窗口属性设置*****************
this-&gt;setWindowTitle("主窗口");
this-&gt;setFixedSize(800, 600);
//***********创建菜单栏******************
//创建菜单栏
//注意：如果只有菜单栏，则在窗口处没有现象
QMenuBar *menu_bar = new QMenuBar(this);
this-&gt;setMenuBar(menu_bar);
    千锋智能物联网学院
//创建菜单
QMenu *menu1 = new QMenu("文件", this);
menu_bar-&gt;addMenu(menu1);
QMenu *menu2 = new QMenu("编辑", this);
menu_bar-&gt;addMenu(menu2);
QMenu *menu3 = new QMenu("构建", this);
menu_bar-&gt;addMenu(menu3);
//创建菜单项
QAction *act1 = new QAction("新建文件或项目", this);
menu1-&gt;addAction(act1);
QAction *act2 = new QAction("打开文件或项目", this);
menu1-&gt;addAction(act2);
//添加分割线
menu1-&gt;addSeparator();
QAction *act3 = new QAction("保存", this);
menu1-&gt;addAction(act3);
QAction *act4 = new QAction("另存为", this);
menu1-&gt;addAction(act4);
QAction *act5 = new QAction("复制", this);
act5-&gt;setShortcut(QKeySequence(Qt::CTRL + Qt::Key_C));
menu2-&gt;addAction(act5);
QAction *act6 = new QAction("粘贴", this);
act6-&gt;setShortcut(QKeySequence(tr("Ctrl+V")));
menu2-&gt;addAction(act6);
QAction *act7 = new QAction("剪切", this);
menu2-&gt;addAction(act7);
//当单击菜单项时，做出相应的处理
connect(act5, &amp;QAction::triggered, [=]{
qDebug()&lt;&lt;"复制正在执行";
});
connect(act6, &amp;QAction::triggered, [=]{qDebug()&lt;&lt;"粘贴正在执行";
});
}
MainWindow::~MainWindow()
{
}
</code></pre> 
<p><img src="https://images2.imgbox.com/b6/3a/PStl9067_o.png" alt="image-20230621001246177"></p> 
<h4><a id="42__623"></a>4.2 工具栏</h4> 
<p>主窗口的工具栏上可以有多个工具条，通常采用一个菜单对应一个工具条的的方式，也可根据需要进行工具条的划分。</p> 
<pre><code class="prism language-c++">//创建工具栏：
#include &lt;QToolBar&gt;
QToolBar --&gt; QToolBar(QWidget *parent = Q_NULLPTR)
//添加工具栏：
QMainWindow --&gt;
void addToolBar(QToolBar *toolbar)
void addToolBar(Qt::ToolBarArea area, QToolBar *toolbar)
Qt::LeftToolBarArea 左边显示
Qt::RightToolBarArea 右边显示
Qt::TopToolBarArea 上边显示
Qt::BottomToolBarArea 下边显示
</code></pre> 
<p>直接调用QMainWindow 类的addToolBar（）函数获取主窗口的工具条对象，每增加一个工具条<br> 都需要调用一次该函数。</p> 
<ul><li>插入属于工具条的动作，即在工具条上添加操作。<br> 通过QToolBar 类的addAction 函数添加。</li><li>工具条是一个可移动的窗口，它的停靠区域由QToolBar 的allowAreas 决定，包括：</li><li>Qt::LeftToolBarArea 停靠在左侧</li><li>Qt::RightToolBarArea 停靠在右侧</li><li>Qt::TopToolBarArea 停靠在顶部</li><li>Qt::BottomToolBarArea 停靠在底部</li><li>Qt::AllToolBarAreas 以上四个位置都可停靠</li><li>使用setAllowedAreas（）函数指定停靠区域：<br> setAllowedAreas（Qt::LeftToolBarArea | Qt::RightToolBarArea）</li><li>使用setMoveable（）函数设定工具栏的可移动性：<br> setMoveable（false）//工具条不可移动, 只能停靠在初始化的位置上</li></ul> 
<pre><code class="prism language-c++">//创建工具栏
//注意：工具栏可以添加多个
QToolBar *toolbar = new QToolBar(this);
//将工具栏添加到窗口
//this-&gt;addToolBar(toolbar);//默认在最上面显示
this-&gt;addToolBar(Qt::LeftToolBarArea, toolbar); //设置默认在左边显示
//工具栏添加菜单项和分割线
QAction *act_tool1 = new QAction("欢迎", this);
QAction *act_tool2 = new QAction("编辑", this);
toolbar-&gt;addAction(act_tool1);
toolbar-&gt;addSeparator();
toolbar-&gt;addAction(act_tool2);
//设置工具栏的浮动状态，true：可以悬浮在窗口false：不可以
toolbar-&gt;setFloatable(false);
//设置运行工具栏的位置，设置为左边或者右边
toolbar-&gt;setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea);
</code></pre> 
<h4><a id="43__676"></a>4.3 状态栏</h4> 
<ul><li>派生自QWidget 类，使用方法与QWidget 类似，QStatusBar 类常用成员函数：状态栏也只能最多有一个</li></ul> 
<pre><code class="prism language-c++">创建状态栏：
QStatusBar --&gt;
将控件添加到左边栏
void addWidget(QWidget *widget, int stretch = 0)
将控件添加到右边栏
void addPermanentWidget(QWidget *widget, int stretch = 0)
添加状态栏：
QMainWindow --&gt; void setStatusBar(QStatusBar *statusbar)
//创建状态栏
//状态栏只能有一个
QStatusBar *statusbar = new QStatusBar(this);
//添加状态栏
this-&gt;setStatusBar(statusbar);
//给状态栏中添加文字信息或者按钮=
QLabel *label1 = new QLabel("左边信息", this);
statusbar-&gt;addWidget(label1);
QLabel *label2 = new QLabel("右边信息", this);
statusbar-&gt;addPermanentWidget(label2);
QPushButton *button = new QPushButton("设置", this);
statusbar-&gt;addWidget(button);
</code></pre> 
<h4><a id="44__703"></a>4.4 铆接部件</h4> 
<pre><code class="prism language-c++">创建铆接部件：
QDockWidget --&gt;
QDockWidget(const QString &amp;title, QWidget *parent = Q_NULLPTR)
添加铆接部件：
QMainWindow --&gt;
void addDockWidget(Qt::DockWidgetArea area, QDockWidget
*dockwidget)
Qt::LeftDockWidgetArea 左边
Qt::RightDockWidgetArea 右边
Qt::TopDockWidgetArea 上边
Qt::BottomDockWidgetArea 下边
//创建铆接部件
QDockWidget *dockwidget = new QDockWidget("这是一个铆接部件", this);
this-&gt;addDockWidget(Qt::TopDockWidgetArea, dockwidget);
</code></pre> 
<h4><a id="45__722"></a>4.5 中心部件</h4> 
<p>除了以上几个部件，中心显示的部件都可以作为核心部件，例如一个记事本文件，可以利用QTextEdit 做核心部件</p> 
<pre><code class="prism language-c++">添加中心部件：
QMainWindow --&gt; void setCentralWidget(QWidget *widget)
QTextEdit *edit = new QTextEdit("文本编辑器", this);
this-&gt;setCentralWidget(edit);
</code></pre> 
<h4><a id="46__733"></a>4.6 资源文件</h4> 
<p>Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。使用Qt Creator 可以很方便地创建资源文件。我们可以在工程上点右键，选择“添加新文件…”，可以在Qt 分类下找到“Qt 资源文件”：</p> 
<p><img src="https://images2.imgbox.com/54/92/39Kib1ni_o.png" alt="image-20230621005359980"></p> 
<h4><a id="47__739"></a>4.7 增加背景图</h4> 
<pre><code class="prism language-c++">this-&gt;setAutoFillBackground(true);
//创建图片控件
QPixmap pix $=$ QPixmap(":/image/butterfly.png"). scaled(this-&gt;size());
// pix.load("://image/butterfly.png");
QPalette palette;
palette.setBrush(QPalette:: Background,QBrush(pix));
this-&gt;setPalette(palette);
this-&gt;setAutoFillBackground(true);
//创建图片控件
QPixmap pix = QPixmap(":/image/butterfly.png"). scaled(this-&gt;size());
// pix.load (":/image/butterfly.png");
QPalette palette;
palette.setBrush(QPalette:: Background, QBrush(pix));
this-&gt;setPalette(palette);
</code></pre> 
<h3><a id="5__758"></a>5. 对话框</h3> 
<h4><a id="51__760"></a>5.1 基本概念</h4> 
<p>对话框是GUI 程序中不可或缺的组成部分。很多不能或者不适合放入主窗口的功能组件都必须放在对话框中设置。对话框通常会是一个顶层窗口，出现在程序最上层，用于实现短期任务或者简洁的用户交互。</p> 
<p>Qt 中使用QDialog 类实现对话框。就像主窗口一样，我们通常会设计一个类继承QDialog。QDialog（及其子类，以及所有Qt::Dialog 类型的类）的对于其parent 指针都有额外的解释：如果parent<br> 为NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是parent 的中心）。顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。对话框分为模态对话框和非模态对话框。</p> 
<ul><li>模态对话框，就是会阻塞同一应用程序中其它窗口的输入。<br> 模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件<br> 对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。</li><li>与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对<br> 记事本的内容进行编辑。</li></ul> 
<h4><a id="52__773"></a>5.2 标准对话框</h4> 
<p>所谓标准对话框，是Qt内置的一系列对话框，用于简化开发。事实上，有很多对话框都是通用的，比如打开文件、设置颜色、打印设置等。这些对话框在所有程序中几乎相同，因此没有必要在每一个程序中都自己实现这么一个对话框。Qt 的内置对话框大致分为以下几类：</p> 
<ul><li>QColorDialog： 选择颜色；</li><li>QFileDialog： 选择文件或者目录；</li><li>QFontDialog： 选择字体；</li><li>QInputDialog： 允许用户输入一个值，并将其值返回；</li><li>QMessageBox： 模态对话框，用于显示信息、询问问题等；</li><li>QPageSetupDialog： 为打印机提供纸张相关的选项；</li><li>QPrintDialog： 打印机配置；</li><li>QPrintPreviewDialog：打印预览；</li><li>QProgressDialog： 显示操作过程。</li></ul> 
<h5><a id="521__787"></a>5.2.1 模态对话框</h5> 
<pre><code class="prism language-c++">QDialog dialog;
dialog.setWindowTitle(tr("Hello, dialog!"));
dialog.exec();
</code></pre> 
<h5><a id="522__795"></a>5.2.2 非模态对话框</h5> 
<pre><code class="prism language-c++">QDialog dialog(this);
dialog.setWindowTitle(tr("Hello, dialog!"));
dialog.show();
</code></pre> 
<p>是不是事与愿违？对话框竟然一闪而过！这是因为，show()函数不会阻塞当前线程，对话框会显示出来，然后函数立即返回，代码继续执行。注意，dialog 是建立在栈上的，show()函数返回，MainWindow::open()函数结束，dialog 超出作用域被析构，因此对话框消失了。知道了原因就好改了，我们将dialog 改成<strong>堆上建立</strong>，当然就没有这个问题了：</p> 
<pre><code class="prism language-c++">QDialog *dialog = new QDialog;
dialog-&gt;setWindowTitle(tr("Hello, dialog!"));
dialog-&gt;show();
</code></pre> 
<p>上面的代码是有问题的：dialog 存在内存泄露！dialog 使用new 在堆上分配空间，却一直没有delete。</p> 
<p>解决方案也很简单：将MainWindow 的指针赋给dialog 即可。还记得我们前面说过的Qt 的对象系统吗？不过，这样做有一个问题：如果我们的对话框不是在一个界面类中出现呢？由于QWidget 的parent必须是QWidget 指针，那就限制了我们不能将一个普通的C++ 类指针传给Qt 对话框。另外，如果对内存占用有严格限制的话，当我们将主窗口作为parent 时，主窗口不关闭，对话框就不会被销毁，所以会一直占用内存。在这种情景下，我们可以设置dialog 的WindowAttribute：</p> 
<pre><code class="prism language-c++">QDialog *dialog = new QDialog;
dialog-&gt;setAttribute(Qt::WA_DeleteOnClose); // 在这里
dialog-&gt;setWindowTitle(tr("Hello, dialog!"));
dialog-&gt;show();
</code></pre> 
<p>setAttribute()函数设置对话框关闭时，自动销毁对话框。</p> 
<h4><a id="53__824"></a>5.3 消息对话框</h4> 
<p>QMessageBox 用于显示消息提示。我们一般会使用其提供的几个static 函数：</p> 
<ul><li>显示关于对话框</li></ul> 
<pre><code class="prism language-c++">void about(QWidget * parent, const QString &amp; title, const QString &amp; text)
</code></pre> 
<p>这是一个最简单的对话框，其标题是title，内容是text，父窗口是parent。对话框只有一个OK 按钮。</p> 
<ul><li>显示关于Qt 对话框。该对话框用于显示有关Qt 的信息。</li></ul> 
<pre><code class="prism language-c++">void aboutQt(QWidget * parent, const QString &amp; title = QString())：
</code></pre> 
<ul><li>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个普通信息图标。</li></ul> 
<pre><code class="prism language-c++">StandardButton information(QWidget * parent,
const QString &amp; title,
const QString &amp; text,
StandardButtons buttons = Ok,
StandardButton defaultButton
</code></pre> 
<ul><li>与QMessageBox::critical ()类似，不同之处在于这个对话框提供一个问号图标，并且其显示的按钮是“是”和“否”。</li></ul> 
<pre><code class="prism language-c++">StandardButton question(QWidget * parent,const QString &amp; title,
const QString &amp; text,
StandardButtons buttons = StandardButtons( Yes | No ),
StandardButton defaultButton = NoButton)
</code></pre> 
<ul><li>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个黄色叹号图标。</li></ul> 
<pre><code class="prism language-c++">StandardButton warning(QWidget * parent,
const QString &amp; title,
const QString &amp; text,
StandardButtons buttons = Ok,
StandardButton defaultButton = NoButton)
</code></pre> 
<p>QMessageBox演示</p> 
<pre><code class="prism language-c++">if (QMessageBox::Yes == QMessageBox::question(this,
tr("Question"), tr("Are you OK?"),
QMessageBox::Yes | QMessageBox::No,
QMessageBox::Yes))
{
QMessageBox::information(this, tr("Hmmm..."),
tr("I'm glad to hear that!"));
}
else
{
QMessageBox::information(this, tr("Hmmm..."),
tr("I'm sorry!"));
}
</code></pre> 
<p>这个对话框的父窗口是this。QMessageBox 是QDialog 的子类，这意味着它的初始显示位置将会是在parent 窗口的中央。 第二个参数是对话框的标题。第三个参数是我们想要显示的内容。 第四个参数是关联的按键类型，我们可以使用或运算符（|）指定对话框应该出现的按钮。比如我们希望是一个Yes 和一个No。 最后一个参数指定默认选择的按钮。这个函数有一个返回值，用于确定用户点击的是哪一个按钮。按照我们的写法，应该很容易的看出，这是一个模态对话框，因此我们可以直接获取其返回值。QMessageBox 类的static 函数优点是方便使用，缺点也很明显：非常不灵活。</p> 
<p>我们只能使用简单的几种形式。为了能够定制QMessageBox 细节，我们必须使用QMessageBox 的属性设置API。如果我们希望制作一个询问是否保存的对话框，我们可以使用如下的代码：</p> 
<pre><code class="prism language-c++">QMessageBox msgBox;
msgBox.setText(tr("The document has been modified."));
msgBox.setInformativeText(tr("Do you want to save your changes?"));
msgBox.setDetailedText(tr("Differences here..."));
msgBox.setStandardButtons(QMessageBox::Save
| QMessageBox::Discard
| QMessageBox::Cancel);
msgBox.setDefaultButton(QMessageBox::Save);
int ret = msgBox.exec();
switch (ret)
{
case QMessageBox::Save:
qDebug() &lt;&lt; "Save document!";
break;
case QMessageBox::Discard:
qDebug() &lt;&lt; "Discard changes!";
break;
case QMessageBox::Cancel:
qDebug() &lt;&lt; "Close document!";
break;
}
</code></pre> 
<p>msgBox 是一个建立在栈上的QMessageBox 实例。我们设置其主要文本信息为“The document has beenmodified.”，informativeText 则是会在对话框中显示的简单说明文字。下面我们使用了一个detailedText，也就是详细信息，当我们点击了详细信息按钮时，对话框可以自动显示更多信息。我们自己定义的对话框的按钮有三个：保存、丢弃和取消。然后我们使用了exec()是其成为一个模态对话框，根据其返回值进行相应的操作。</p> 
<h3><a id="6_919"></a>6.布局管理器</h3> 
<p>GUI 界面，归根结底，就是一堆组件的叠加。我们创建一个窗口，把按钮放上面，把图标放上面，这样就成了一个界面。在放置时，组件的位置尤其重要。我们必须要指定组件放在哪里，以便窗口能够按照我们需要的方式进行渲染。这就涉及到组件定位的机制。</p> 
<p>Qt 提供了两种组件定位机制：<strong>绝对定位</strong>和<strong>布局定位</strong>。</p> 
<ul><li>绝对定位就是一种最原始的定位方法：给出这个组件的坐标和长宽值。</li><li>这样，Qt 就知道该把组件放在哪里以及如何设置组件的大小。但是这样做带来的一个问题是，如果用户改变了窗口大小，比如点击最大化按钮或者使用鼠标拖动窗口边缘，采用绝对定位的组件是不会有任何响应的。这也很自然，因为你并没有告诉Qt，在窗口变化时，组件是否要更新自己以及如何更新。或者，还有更简单的方法：禁止用户改变窗口大小。但这总不是长远之计。</li><li>布局定位：你只要把组件放入某一种布局，布局由专门的布局管理器进行管理。当需要调整大小或者位置的时候，Qt 使用对应的布局管理器进行调整。布局定位完美的解决了使用绝对定位的缺陷。</li></ul> 
<p>Qt 提供的布局中以下三种是我们最常用的：</p> 
<ul><li>QHBoxLayout：按照水平方向从左到右布局；</li><li>QVBoxLayout：按照竖直方向从上到下布局；</li><li>QGridLayout：在一个网格中进行布局，类似于HTML 的table；</li></ul> 
<h4><a id="61__935"></a>6.1 系统布局</h4> 
<p>系统给我们提供的布局的控件</p> 
<p><img src="https://images2.imgbox.com/56/a0/JDSgdk1F_o.png" alt="image-20230621211019387"></p> 
<h4><a id="62_widget__941"></a>6.2 利用widget 做布局</h4> 
<p>第二种布局方式是利用控件里的widget 来做布局，在Containers 中</p> 
<p><img src="https://images2.imgbox.com/f7/3c/YK0qWEkn_o.png" alt="image-20230621211211302"></p> 
<p>在widget 中的控件可以进行水平、垂直、栅格布局等操作，比较灵活。再布局的同时我们需要灵活运用弹簧的特性让我们的布局更加的美观，下面是一个登陆窗口，利用widget 可以搭建出如下登陆界面：</p> 
<p><img src="https://images2.imgbox.com/ca/44/sNjcuvPv_o.png" alt="image-20230621211307819"></p> 
<h3><a id="7_951"></a>7.常用控件</h3> 
<p>Qt 为我们应用程序界面开发提供的一系列的控件，下面我们介绍两种最常用一些控件，所有控件的使用方法我们都可以通过帮助文档获取。</p> 
<h4><a id="71_QLabel_955"></a>7.1 QLabel</h4> 
<p>QLabel 是我们最常用的控件之一，其功能很强大，我们可以用来显示文本，图片和动画等。</p> 
<h5><a id="711_html_959"></a>7.1.1 显示文字（普通文本、html）</h5> 
<p>通过QLabel 类的setText 函数设置显示的内容:</p> 
<pre><code class="prism language-c++">void setText(const QString &amp;)
</code></pre> 
<ul><li>可以显示普通文本字符串</li></ul> 
<pre><code class="prism language-c++">QLable *label = new QLable;
label-&gt;setText(“Hello, World!”);
</code></pre> 
<ul><li>可以显示HTML 格式的字符串<br> 比如显示一个链接:</li></ul> 
<pre><code class="prism language-c++">QLabel * label = new QLabel(this);
label -&gt;setText("Hello, World");
label -&gt;setText("&lt;h1&gt;&lt;a href=\"https://www.baidu.com\"&gt;百度一下&lt;/a&gt;&lt;/h1&gt;");
label -&gt;setOpenExternalLinks(true);
</code></pre> 
<p>其中setOpenExternalLinks()函数是用来设置用户点击链接之后是否自动打开链接，如果参数指定为true 则会自动打开。</p> 
<h5><a id="712__986"></a>7.1.2 显示图片</h5> 
<p>可以使用QLabel 的成员函数setPixmap 设置图片</p> 
<pre><code class="prism language-c++">void setPixmap(const QPixmap &amp;)
</code></pre> 
<p>首先定义QPixmap 对象,加载图片，设置到QLabel</p> 
<pre><code class="prism language-c++">QPixmap pixmap;
pixmap.load(":/Image/boat.jpg");
QLabel *label = new QLabel;
label.setPixmap(pixmap);
</code></pre> 
<h5><a id="713__1003"></a>7.1.3 显示动画</h5> 
<p>可以使用QLabel 的成员函数setMovie 加载动画，可以播放gif 格式的文件</p> 
<pre><code class="prism language-c++">void setMovie(QMovie * movie)
</code></pre> 
<p>首先定义QMovied 对象，并初始化:</p> 
<pre><code class="prism language-c++">QMovie *movie = new QMovie(":/Mario.gif");
</code></pre> 
<pre><code class="prism language-c++">//播放加载的动画：
movie-&gt;start();
//将动画设置到QLabel 中：
QLabel *label = new QLabel；
label-&gt;setMovie(movie);
</code></pre> 
<h4><a id="72_QLineEdit_1025"></a>7.2 QLineEdit</h4> 
<p>Qt 提供的单行文本编辑框。</p> 
<h5><a id="721__1029"></a>7.2.1 设置/获取内容</h5> 
<p>获取编辑框内容使用text（），函数声明如下：</p> 
<pre><code class="prism language-c++">QString text() const
</code></pre> 
<ul><li>设置编辑框内容</li></ul> 
<pre><code class="prism language-c++">void setText(const QString &amp;)
</code></pre> 
<h5><a id="722__1043"></a>7.2.2 设置显示模式</h5> 
<p>使用QLineEdit 类的setEchoMode () 函数设置文本的显示模式,函数声明:</p> 
<pre><code class="prism language-c++">void setEchoMode(EchoMode mode)
</code></pre> 
<p>EchoMode 是一个枚举类型,一共定义了四种显示模式:</p> 
<ul><li> <p>QLineEdit::Normal 模式显示方式，按照输入的内容显示。</p> </li><li> <p>QLineEdit::NoEcho 不显示任何 内容，此模式下无法看到用户的输入。</p> </li><li> <p>QLineEdit::Password 密码模式，输入的字符会根据平台转换为特殊字符。</p> </li><li> <p>QLineEdit::PasswordEchoOnEdit 编辑时显示字符否则显示字符作为密码。<br> 另外，我们再使用QLineEdit 显示文本的时候，希望在左侧留出一段空白的区域，那么，就可以使<br> 用QLineEdit 给我们提供的setTextMargins 函数：</p> <pre><code class="prism language-c++">void setTextMargins(int left, int top, int right, int bottom)
</code></pre> <p>用此函数可以指定显示的文本与输入框上下左右边界的间隔的像素数。</p> </li></ul> 
<pre><code class="prism language-c++">// smallwidget.h
class SmallWidget : public QWidget
{
Q_OBJECT
public:
explicit SmallWidget(QWidget *parent = 0);
signals:
public slots:
private:
QSpinBox* spin;
QSlider* slider;
};
// smallwidget.cpp
SmallWidget::SmallWidget(QWidget *parent) : QWidget(parent)
{
spin = new QSpinBox(this);
slider = new QSlider(Qt::Horizontal, this);
// 创建布局对象
QHBoxLayout* layout = new QHBoxLayout;
// 将控件添加到布局中
layout-&gt;addWidget(spin);
layout-&gt;addWidget(slider);
// 将布局设置到窗口中
setLayout(layout);
// 添加消息响应
connect(spin,
static_cast&lt;void (QSpinBox::*)(int)&gt;(&amp;QSpinBox::valueChanged),slider, &amp;QSlider::setValue);
connect(slider, &amp;QSlider::valueChanged,
spin, &amp;QSpinBox::setValue);
}
</code></pre> 
<p><img src="https://images2.imgbox.com/2c/ca/HpW9yrqH_o.png" alt="image-20230621225927166"></p> 
<h3><a id="8_Qt__1105"></a>8. Qt 消息机制和事件</h3> 
<h4><a id="81__1107"></a>8.1 事件处理过程</h4> 
<p>事件（event）是由系统或者Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。</p> 
<p>一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。事件处理过程：</p> 
<ol><li>在Qt 内部，Qt 通过QApplication::exec()启动的主事件循环不停的抓取事件队列中的事件。</li><li>当事件发生时，Qt 将创建一个事件对象。Qt 中所有事件类都继承于QEvent。</li><li>在事件对象创建完毕后，Qt 将这个事件对象传递给QObject 的event()函数。event()函数并不直接处理事件，<br> 而是按照事件对象的类型分派给特定的事件处理函数（event handler）。<br> event()函数主要用于事件的分发：</li></ol> 
<h4><a id="82__1119"></a>8.2 常用事件处理</h4> 
<p>在所有控件的父类QWidget 中，定义了很多事件处理的回调函数。这些函数都是protected virtual 的，也就是说，我们可以在子类中重新实现这些函数。实现函数的要遵循虚函数的语法规则，自定义的类中保证函数名、参数的一致性。</p> 
<h5><a id="821__1123"></a>8.2.1 鼠标事件</h5> 
<pre><code class="prism language-c++">//重写父类的虚函数
protected:
virtual void mousePressEvent(QMouseEvent *); //鼠标点击事件
virtual void mouseReleaseEvent(QMouseEvent *); //鼠标抬起事件
virtual void mouseDoubleClickEvent(QMouseEvent *); //鼠标双击事件
virtual void mouseMoveEvent(QMouseEvent *); //鼠标移动事件
</code></pre> 
<h5><a id="822_QWheelEvent_1134"></a>8.2.2 滚轮事件(QWheelEvent)</h5> 
<pre><code class="prism language-c++">//virtual void wheelEvent(QWheelEvent *); //鼠标滚轮滑动
//鼠标滚轮滑动
void Widget::wheelEvent(QWheelEvent *e)
{
if(e-&gt;orientation()== Qt::Vertical) //如果方向是垂直
{
QPoint point = e-&gt;angleDelta();
QString str = QString("滚轮垂直滑动(%1, %2)")
.arg( point.x() ).arg(point.y());
ui-&gt;label-&gt;setText(str);
}
}
</code></pre> 
<h5><a id="823_QKeyEvent_1153"></a>8.2.3 键盘事件(QKeyEvent)</h5> 
<pre><code class="prism language-c++">//virtual void keyPressEvent(QKeyEvent *); //键盘按下事件
//virtual void keyReleaseEvent(QKeyEvent *); //键盘抬起事件
//键盘按下事件
void Widget::keyPressEvent(QKeyEvent *e)
{
QString str;
    switch(e-&gt;modifiers()) //修饰键盘
{
case Qt::ControlModifier:
str = "Ctrl+";
break;
case Qt::AltModifier:
str = "Alt+";
break;
}
switch(e-&gt;key()) //普通键
{
case Qt::Key_Left:
str += "Left_Key Press";
break;
case Qt::Key_Right:
str += "Rigth_Key Press";
break;
case Qt::Key_Up:
str += "Up_Key Press";
break;
case Qt::Key_Down:
str += "Down_Key Press";
break;
case Qt::Key_Z:
        str += "Z_Key Press";
break;
}
ui-&gt;label-&gt;setText(str);
}
</code></pre> 
<h5><a id="824_QResizeEvent_1193"></a>8.2.4 大小改变事件(QResizeEvent)</h5> 
<pre><code class="prism language-c++">当窗口大小发生变化时被调用，参考代码：
//virtual void resizeEvent(QResizeEvent *); //大小改变事件
//大小改变事件
void Widget::resizeEvent(QResizeEvent *e)
{
//变化前的窗口大小
qDebug() &lt;&lt; "e-&gt;oldSize() = " &lt;&lt; e-&gt;oldSize();
//变化后的窗口大小
qDebug() &lt;&lt; "e-&gt;size() = " &lt;&lt; e-&gt;size();
}
</code></pre> 
<h5><a id="825_enterEventleaveEvent_1208"></a>8.2.5 进入离开区域事件(enterEvent、leaveEvent)</h5> 
<pre><code class="prism language-c++">//virtual void enterEvent(QEvent *); //进入事件
//virtual void leaveEvent(QEvent *); //离开事件
//进入事件
void Widget::enterEvent(QEvent *)
{qDebug() &lt;&lt; "enterEvent";
}
//离开事件
void Widget::leaveEvent(QEvent *)
{
qDebug() &lt;&lt; "leaveEvent";
}
</code></pre> 
<h3><a id="9__1224"></a>9 绘图</h3> 
<h4><a id="91_Qt_1226"></a>9.1 Qt绘图机制</h4> 
<p>Qt 的绘图机制为屏幕显示和打印显示提供了统一的API 接口，主要有三部分组成：QPainter 类、QPaintDevice<br> 类和QPaintEngine 类<br> l QPainter 类提供了画图操作的各种接口，可方便地绘制各种各样的图形。<br> l QPaintDevice 类提供可用于画图的空间，及画图容器。<br> lPaintEngine 类是抽象类，提供了QPainter 如何在指定的平台上给指定的设备绘画的抽象接口，对开发者而言，<br> 一般不会用到。</p> 
<p><img src="https://images2.imgbox.com/86/d2/JWCujdUF_o.png" alt="image-20230621233533906"></p> 
<h4><a id="92__1237"></a>9.2 绘图事件</h4> 
<pre><code class="prism language-c++">void Widget::paintEvent(QPaintEvent *e)
{
qDebug()&lt;&lt;"in paintEvent"&lt;&lt;"recet"&lt;&lt;e-&gt;rect(); //得到需要重新绘制的区域
QPainter paint(this); //定义画家（请了一个画家来画画），画在主窗口上
//画家画图片，作为背景图片
paint.drawPixmap(0,0,this-&gt;width(),this-&gt;height(),
QPixmap("../Image/bk.jpg"));
QPen pen; //定义一只画笔
pen.setColor(QColor(255,0,255)); //设置画笔的颜色
pen.setWidth(5); //设置画笔的宽度
pen.setStyle(Qt::DashDotLine); //设置画笔线条的风格
paint.setPen(pen); //画家使用这只画笔
paint.drawLine(30,30,500,30);//画家画水平的线条
paint.drawLine(30,30,30,500);//画家画垂直的线条
pen.setColor(Qt::yellow);//设置画笔的颜色
pen.setStyle(Qt::SolidLine);//设置画笔线条的风格
pen.setWidth(3);//设置线条的宽度
paint.setPen(pen);//画家使用这只画笔
QBrush brush(Qt::blue);//定义一把蓝色的画刷
brush.setStyle(Qt::DiagCrossPattern);//设置画刷的风格
paint.setBrush(brush);//画家使用这把画刷
paint.drawRect(50,50,150,200);//画家画矩形
paint.setPen(QPen());
paint.setBrush(QBrush(QColor(255,187,255),Qt::Dense3Pattern));
paint.drawEllipse(280,60,180,250);//画家画椭圆
}
</code></pre> 
<h4><a id="93__1268"></a>9.3 刷新绘图区域</h4> 
<pre><code class="prism language-c++">//绘图事件
void Widget::*paintEvent*(QPaintEvent *)
 {
QPainter p(this); //在窗口上绘图
 p.drawPixmap(x,200,100,100,QPixmap("../Image/face.png"));
 p.drawPixmap(i,j,100,100,QPixmap("../Image/face.png"));
}
void Widget::on_pushButton_clicked()
{
 x += 20;
 if(x &gt; this-&gt;width())
 {
 x = 0;
 }
 this-&gt;update(); //刷新绘图区
}
void Widget::*mousePressEvent*(QMouseEvent *e)
{i = e-&gt;pos().x();
j = e-&gt;pos().y();
this-&gt;update(); //刷新绘图区域
}
</code></pre> 
<p><a rel="nofollow">参考学习视频</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7bd50957820ba9ad00047ba0cbe2c16e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">体验PicGo&#43;GitHub&#43;jsDeliver搭建免费图床</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c9035b1c19cc127a02360af660ec5177/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">百度搜索打击违规落地页体验公告说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>