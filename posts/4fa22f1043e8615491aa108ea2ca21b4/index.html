<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux基本bash命令（持续更新） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux基本bash命令（持续更新）" />
<meta property="og:description" content="首先了解下shell Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。
以下是几种shell版本，bash是默认的： sh(全称 Bourne Shell): 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。
Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。
bash（全称 Bourne Again Shell）: LinuxOS 默认的，它是 Bourne Shell 的扩展。
与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。 csh(全称 C Shell): 是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似。 Tcsh: 是 Linux 提供的 C Shell 的一个扩展版本。
Tcsh 包括命令行编辑，可编程单词补全，拼写校正，历史命令替换，作业控制和类似 C 语言的语法，他不仅和 Bash Shell 提示符兼容，而且还提供比 Bash Shell 更多的提示符参数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4fa22f1043e8615491aa108ea2ca21b4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-06-24T15:47:26+08:00" />
<meta property="article:modified_time" content="2017-06-24T15:47:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux基本bash命令（持续更新）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:2em; color:rgb(51,51,51)"> <span style="border:0px; margin:0px; padding:0px"><strong><span style="font-family:Arial; font-size:32px">首先了解下shell</span></strong></span></h2> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="border:0px; margin:0px; padding:0px"><span style="font-family:Arial; font-size:18px">Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</span></span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="border:0px; margin:0px; padding:0px"><span style="font-family:Arial; font-size:18px"></span></span></p> 
<ul style="border:0px; margin:0px; padding:0px; list-style:none"><li><span style="font-family:Arial; font-size:18px">以下是几种shell版本，bash是默认的：</span></li><li style="border:0px; margin:4px 0px 0px; padding:0px"> 
  <div> 
   <blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote> 
   <span style="font-family:Arial; font-size:18px"><span style="border:0px; margin:0px; padding:0px">sh(全称 Bourne Shell)</span>: 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。<br> </span> 
   <blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote> 
   <span style="font-family:Arial; font-size:18px">Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。<br> </span> 
   <blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote> 
   <span style="font-family:Arial; font-size:18px"><strong><span style="border:0px; margin:0px; padding:0px">bash（全称 Bourne Again Shell）</span>: LinuxOS 默认的，它是 Bourne Shell 的扩展。</strong><br> <span style="white-space:pre"></span>与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。</span> 
  </div> </li><li><span style="font-family:Arial; font-size:18px"><span style="border:0px; margin:0px; padding:0px">csh(全称 C Shell)</span>: 是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似。</span></li><li style="border:0px; margin:4px 0px 0px; padding:0px"> 
  <blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote> <span style="font-family:Arial; font-size:18px"><span style="border:0px; margin:0px; padding:0px">Tcsh</span>: 是 Linux 提供的 C Shell 的一个扩展版本。<br> </span> 
  <blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote> <span style="font-family:Arial; font-size:18px"><span style="white-space:pre"></span>Tcsh 包括命令行编辑，可编程单词补全，拼写校正，历史命令替换，作业控制和类似 C 语言的语法，他不仅和 Bash Shell 提示符兼容，而且还提供比 Bash Shell 更多的提示符参数。<br> </span> 
  <blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote> <span style="font-family:Arial; font-size:18px"><span style="border:0px; margin:0px; padding:0px">ksh (全称 Korn Shell)</span>: 集合了 C Shell 和 Bourne Shell 的优点并且和 Bourne Shell 完全兼容。<br> </span> 
  <blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote> <span style="font-family:Arial; font-size:18px"><span style="border:0px; margin:0px; padding:0px">pdksh</span>: 是 Linux 系统提供的 ksh 的扩展。<br> </span> 
  <blockquote style="margin:0 0 0 40px; border:none; padding:0px"></blockquote> <span style="font-family:Arial"><span style="font-size:18px"><span style="white-space:pre"></span>pdksh 支持人物控制，可以在命令行上挂起，后台执行，唤醒或终止程序。</span><br> <span style="font-size:24px"><br> <strong>主要学习bash，第一个bash脚本：</strong></span></span></li><li style="border:0px; margin:4px 0px 0px; padding:0px"><span style="font-family:Arial"><span style="font-size:24px"><strong><br> </strong></span></span></li><li style="border:0px; margin:4px 0px 0px; padding:0px"><span style="font-family:Arial"></span><pre><code class="language-plain">#!/bin/bash
echo "Hello World !"</code></pre><span style="font-family:Arial"><span style="font-size:18px"><span style="border:0px; margin:0px; padding:0px">#!/bin/bash</span>。<br> </span></span> <p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="font-family:Arial"><span style="font-size:18px">#!  告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</span></span></p> </li></ul> 
<p></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="font-family:Arial"><br> </span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> </p> 
<h3 style="border:0px; margin:8px 0px; padding:0px; color:rgb(51,51,51)"><span style="font-family:Arial; font-size:24px">运行 Shell 脚本有两种方法：</span></h3> 
<p></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:2em; color:rgb(51,51,51)"> <span style="border:0px; margin:0px; padding:0px"><span style="font-family:Arial"><span style="font-size:13px">1</span><span style="font-size:18px">、作为可执行程序</span></span></span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:2em; color:rgb(51,51,51)"> <span style="font-family:Arial; font-size:18px">将上面的代码保存为 test.sh，并 cd 到相应目录：</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:2em; color:rgb(51,51,51)"> <span style="font-family:Arial; font-size:18px"></span></p> 
<pre><code class="language-plain">chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #执行脚本</code></pre> 
<p></p> 
<p></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:2em; color:rgb(51,51,51)"> <span style="font-family:Arial; font-size:18px">注意，一定要写成 <span class="marked" style="border:0px; margin:0px; padding:0.2em; font-weight:bold; background-color:rgb(236,234,230)">./test.sh</span>，而不是 <strong>test.sh</strong>，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:2em; color:rgb(51,51,51)"> <span style="font-family:Arial; font-size:18px"><br> </span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:2em; color:rgb(51,51,51)"> <span style="border:0px; margin:0px; padding:0px"><span style="font-family:Arial; font-size:18px">2、作为解释器参数</span></span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:2em; color:rgb(51,51,51)"> <span style="font-family:Arial; font-size:18px">这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:2em; color:rgb(51,51,51)"> <span style="font-family:Arial; font-size:18px"></span></p> 
<pre><code class="language-plain">/bin/sh test.sh
/bin/php test.php</code></pre> 
<p></p> 
<p></p> 
<h2 style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> </h2> 
<h3><span style="font-family:Arial"><span style="font-size:24px">常用bash命令</span></span></h3> 
<h4><span style="font-family:Arial; font-size:18px">a)查看文件大小，内存大小，cpu信息，硬盘空间等等。</span></h4> 
<div> 
 <span style="font-family:Arial; font-size:18px"></span> 
 <pre><code class="language-plain">du -sh *     #查看当前文件夹大小
du -sh * | sort -n 统计当前文件夹(目录)大小，并按文件大小排序
#附送:
du -sk filename 查看指定文件大小</code></pre> 
 <div> 
  <br> 
 </div> 
 <br> 
 <pre><code class="language-plain">1、cpu查看
    1）cpu个数：#cat /proc/cpuinfo | grep "physical id" | uniq | wc -l

    2）cpu核数：#cat /proc/cpuinfo | grep "cpu cores" | uniq

    3）cpu型号：#cat /proc/cpuinfo | grep 'model name' |uniq

2、内存查看：#cat /proc/meminfo | grep MemTotal

3、硬盘查看： #fdisk -l | grep Disk</code></pre> 
 <div> 
  <br> 
 </div> PS: 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <pre><code class="language-plain">uname -a # 查看内核/操作系统/CPU信息的linux系统信息
head -n l /etc/issue # 查看操作系统版本
cat /proc/cpuinfo # 查看CPU信息
hostname # 查看计算机名的linux系统信息命令
lspci -tv # 列出所有PCI设备 
lsusb -tv # 列出所有USB设备的linux系统信息命令
lsmod # 列出加载的内核模块 
env # 查看环境变量资源
free -m # 查看内存使用量和交换区使用量 
df -h # 查看各分区使用情况
du -sh # 查看指定目录的大小 
grep MemTotal /proc/meminfo # 查看内存总量
grep MemFree /proc/meminfo # 查看空闲内存量 
uptime # 查看系统运行时间、用户数、负载
cat /proc/loadavg # 查看系统负载磁盘和分区 
mount | column -t # 查看挂接的分区状态
fdisk -l # 查看所有分区 
swapon -s # 查看所有交换分区
hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) 
dmesg | grep IDE # 查看启动时IDE设备检测状况网络
ifconfig # 查看所有网络接口的属性 
iptables -L # 查看防火墙设置
route -n # 查看路由表 
netstat -lntp # 查看所有监听端口
netstat -antp # 查看所有已经建立的连接 
netstat -s # 查看网络统计信息进程
ps -ef # 查看所有进程 
top # 实时显示进程状态用户
w # 查看活动用户 
id # 查看指定用户信息
last # 查看用户登录日志 
cut -d: -f1 /etc/passwd # 查看系统所有用户
cut -d: -f1 /etc/group # 查看系统所有组 
crontab -l # 查看当前用户的计划任务服务
chkconfig –list # 列出所有系统服务 
chkconfig –list | grep on # 列出所有启动的系统服务程序
rpm -qa # 查看所有安装的软件包 
cat /proc/cpuinfo ：查看CPU相关参数的linux系统命令
cat /proc/partitions ：查看linux硬盘和分区信息的系统信息命令 
cat /proc/meminfo ：查看linux系统内存信息的linux系统命令
cat /proc/version ：查看版本，类似uname -r 
cat /proc/ioports ：查看设备io端口
cat /proc/interrupts ：查看中断 
cat /proc/pci ：查看pci设备的信息
cat /proc/swaps ：查看所有swap分区的信息</code></pre> 
 <br> 
 <br> 
 <span style="font-size:18px">但是我们的主要目的是在运行程序是动态的观察cpu，进程的状态，所以需要使用</span> 
 <strong><span style="font-size:24px">top</span></strong> 
 <span style="font-size:18px">命令</span> 
</div> 
<div> 
 <span style="font-size:18px"><br> </span> 
</div> 
<div> 
 <span style="font-size:18px">TOP是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.</span> 
 <p>top - 12:38:33 up 50 days, 23:15,  7 users,  load average: 60.58, 61.14, 61.22</p> 
 <p>Tasks: 203 total,  60 running, 139 sleeping,   4 stopped,   0 zombie</p> 
 <p>Cpu(s)  : 27.0%us, 73.0%sy,  0.0%ni,  0.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</p> 
 <p>Mem:   1939780k total,  1375280k used,   564500k free,   109680k buffers</p> 
 <p>Swap:  4401800k total,   497456k used,  3904344k free,   848712k cached</p> 
 <p>PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                </p> 
 <p> 4338 oracle    25   0  627m 209m 207m R    0 11.0 297:14.76 oracle                                </p> 
 <p> 4267 oracle    25   0  626m 144m 143m R    6  7.6  89:16.62 oracle                                </p> 
 <p> 3458 oracle    25   0  672m 133m 124m R    0  7.1   1283:08 oracle                                </p> 
 <p> 3478 oracle    25   0  672m 124m 115m R    0  6.6   1272:30 oracle                                </p> 
 <p> 3395 oracle    25   0  672m 122m 113m R    0  6.5   1270:03 oracle                                 </p> 
 <p> 3480 oracle    25   0  672m 122m 109m R    8  6.4   1274:13 oracle                                </p> 
 <p> 3399 oracle    25   0  672m 121m 110m R    0  6.4   1279:37 oracle                                </p> 
 <p> 4261 oracle    25   0  634m 100m  99m R    0  5.3  86:13.90 oracle                                </p> 
 <p>25737 oracle    25   0  632m  81m  74m R    0  4.3 272:35.42 oracle                                </p> 
 <p> 7072 oracle    25   0  626m  72m  71m R    0  3.8   6:35.68 oracle                                </p> 
 <p>16073 oracle    25   0  630m  68m  63m R    8  3.6 175:20.36 oracle                                </p> 
 <p>16140 oracle    25   0  630m  66m  60m R    0  3.5 175:13.42 oracle                                </p> 
 <p>16122 oracle    25   0  630m  66m  60m R    0  3.5 176:47.73 oracle                                </p> 
 <p>  786 oracle    25   0  627m  63m  63m R    0  3.4   1:54.93 oracle                                </p> 
 <p> 4271 oracle    25   0  627m  59m  58m R    8  3.1  86:09.64 oracle                                </p> 
 <p> 4273 oracle    25   0  627m  57m  56m R    8  3.0  84:38.20 oracle                                </p> 
 <p>22670 oracle    25   0  626m  50m  49m R    0  2.7  84:55.82 oracle     </p> 
 <p>一.  TOP前五行统计信息</p> 
 <p>统计信息区前五行是系统整体的统计信息。</p> 
 <p>1. 第一行是任务队列信息</p> 
 <p>同 uptime  命令的执行结果:</p> 
 <p>[root@localhost ~]# uptime</p> 
 <p> 13:22:30 up 8 min,  4 users,  load average: 0.14, 0.38, 0.25</p> 
 <p>其内容如下：</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="208"> <p align="left">12:38:33</p> </td><td width="346"> <p align="left">当前时间</p> </td></tr><tr><td width="208"> <p align="left">up 50days</p> </td><td width="346"> <p align="left">系统运行时间，格式为时:分</p> </td></tr><tr><td width="208"> <p align="left">1 user</p> </td><td width="346"> <p align="left">当前登录用户数</p> </td></tr><tr><td width="208"> <p align="left">load average: 0.06, 0.60, 0.48</p> </td><td width="346"> <p align="left">系统负载，即任务队列的平均长度。 三个数值分别为  1分钟、5分钟、15分钟前到现在的平均值。</p> </td></tr></tbody></table> 
 <p>2. 第二、三行为进程和CPU的信息</p> 
 <p>当有多个CPU时，这些内容可能会超过两行。内容如下：</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="113"> <p align="left">Tasks: 29 total</p> </td><td width="387"> <p align="left">进程总数</p> </td></tr><tr><td width="113"> <p align="left">1 running</p> </td><td width="387"> <p align="left">正在运行的进程数</p> </td></tr><tr><td width="113"> <p align="left">28 sleeping</p> </td><td width="387"> <p align="left">睡眠的进程数</p> </td></tr><tr><td width="113"> <p align="left">0 stopped</p> </td><td width="387"> <p align="left">停止的进程数</p> </td></tr><tr><td width="113"> <p align="left">0 zombie</p> </td><td width="387"> <p align="left">僵尸进程数</p> </td></tr><tr><td width="113"> <p align="left">Cpu(s): 0.3% us</p> </td><td width="387"> <p align="left">用户空间占用CPU百分比</p> </td></tr><tr><td width="113"> <p align="left">1.0% sy</p> </td><td width="387"> <p align="left">内核空间占用CPU百分比</p> </td></tr><tr><td width="113"> <p align="left">0.0% ni</p> </td><td width="387"> <p align="left">用户进程空间内改变过优先级的进程占用CPU百分比</p> </td></tr><tr><td width="113"> <p align="left">98.7% id</p> </td><td width="387"> <p align="left">空闲CPU百分比</p> </td></tr><tr><td width="113"> <p align="left">0.0% wa</p> </td><td width="387"> <p align="left">等待输入输出的CPU时间百分比</p> </td></tr><tr><td width="113"> <p align="left">0.0% hi</p> </td><td width="387"> </td></tr><tr><td width="113"> <p align="left">0.0% si</p> </td><td width="387"> </td></tr></tbody></table> 
 <p>3. 第四五行为内存信息。</p> 
 <p>内容如下：</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="142"> <p align="left">Mem: 191272k total</p> </td><td width="436"> <p align="left">物理内存总量</p> </td></tr><tr><td width="142"> <p align="left">173656k used</p> </td><td width="436"> <p align="left">使用的物理内存总量</p> </td></tr><tr><td width="142"> <p align="left">17616k free</p> </td><td width="436"> <p align="left">空闲内存总量</p> </td></tr><tr><td width="142"> <p align="left">22052k buffers</p> </td><td width="436"> <p align="left">用作内核缓存的内存量</p> </td></tr><tr><td width="142"> <p align="left">Swap: 192772k total</p> </td><td width="436"> <p align="left">交换区总量</p> </td></tr><tr><td width="142"> <p align="left">0k used</p> </td><td width="436"> <p align="left">使用的交换区总量</p> </td></tr><tr><td width="142"> <p align="left">192772k free</p> </td><td width="436"> <p align="left">空闲交换区总量</p> </td></tr><tr><td width="142"> <p align="left">123988k cached</p> </td><td width="436"> <p align="left">缓冲的交换区总量。 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖， 该数值即为这些<strong>内容已存在于内存中</strong>的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。</p> </td></tr></tbody></table> 
 <p>二.  进程信息</p> 
 <table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="95"> <p>列名</p> </td><td width="423"> <p>含义</p> </td></tr><tr><td width="95"> <p>PID</p> </td><td width="423"> <p>进程id</p> </td></tr><tr><td width="95"> <p>PPID</p> </td><td width="423"> <p>父进程id</p> </td></tr><tr><td width="95"> <p>RUSER</p> </td><td width="423"> <p>Real user name</p> </td></tr><tr><td width="95"> <p>UID</p> </td><td width="423"> <p>进程所有者的用户id</p> </td></tr><tr><td width="95"> <p>USER</p> </td><td width="423"> <p>进程所有者的用户名</p> </td></tr><tr><td width="95"> <p>GROUP</p> </td><td width="423"> <p>进程所有者的组名</p> </td></tr><tr><td width="95"> <p>TTY</p> </td><td width="423"> <p>启动进程的终端名。不是从终端启动的进程则显示为 ?</p> </td></tr><tr><td width="95"> <p>PR</p> </td><td width="423"> <p>优先级</p> </td></tr><tr><td width="95"> <p>NI</p> </td><td width="423"> <p>nice值。负值表示高优先级，正值表示低优先级</p> </td></tr><tr><td width="95"> <p>P</p> </td><td width="423"> <p>最后使用的CPU，仅在多CPU环境下有意义</p> </td></tr><tr><td width="95"> <p>%CPU</p> </td><td width="423"> <p>上次更新到现在的CPU时间占用百分比</p> </td></tr><tr><td width="95"> <p>TIME</p> </td><td width="423"> <p>进程使用的CPU时间总计，单位秒</p> </td></tr><tr><td width="95"> <p>TIME+</p> </td><td width="423"> <p>进程使用的CPU时间总计，单位1/100秒</p> </td></tr><tr><td width="95"> <p>%MEM</p> </td><td width="423"> <p>进程使用的物理内存百分比</p> </td></tr><tr><td width="95"> <p>VIRT</p> </td><td width="423"> <p>进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</p> </td></tr><tr><td width="95"> <p>SWAP</p> </td><td width="423"> <p>进程使用的虚拟内存中，被换出的大小，单位kb。</p> </td></tr><tr><td width="95"> <p>RES</p> </td><td width="423"> <p>进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</p> </td></tr><tr><td width="95"> <p>CODE</p> </td><td width="423"> <p>可执行代码占用的物理内存大小，单位kb</p> </td></tr><tr><td width="95"> <p>DATA</p> </td><td width="423"> <p>可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</p> </td></tr><tr><td width="95"> <p>SHR</p> </td><td width="423"> <p>共享内存大小，单位kb</p> </td></tr><tr><td width="95"> <p>nFLT</p> </td><td width="423"> <p>页面错误次数</p> </td></tr><tr><td width="95"> <p>nDRT</p> </td><td width="423"> <p>最后一次写入到现在，被修改过的页面数。</p> </td></tr><tr><td width="95"> <p>S</p> </td><td width="423"> <p>进程状态。<br>             D=不可中断的睡眠状态<br>             R=运行<br>             S=睡眠<br>             T=跟踪/停止<br>             Z=僵尸进程</p> </td></tr><tr><td width="95"> <p>COMMAND</p> </td><td width="423"> <p>命令名/命令行</p> </td></tr><tr><td width="95"> <p>WCHAN</p> </td><td width="423"> <p>若该进程在睡眠，则显示睡眠中的系统函数名</p> </td></tr><tr><td width="95"> <p>Flags</p> </td><td width="423"> <p>任务标志，参考 sched.h</p> </td></tr></tbody></table> 
 <br> 
 <br> 
</div> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="font-family:Arial">HTOP应该已经完全替代了top功能。</span><a target="_blank" href="https://linux.cn/article-3141-1.html" rel="nofollow noopener noreferrer" style="font-family:Arial">htop</a></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <span style="font-family:Arial"><br> </span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> <br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/37a01bd2947ec406b8d30888e5048b48/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【立体视觉】世界坐标系、相机坐标系、图像坐标系、像素坐标系之间的关系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46e9096a623e170799456b9114e68a11/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">http响应码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>