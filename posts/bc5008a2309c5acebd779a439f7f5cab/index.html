<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>死锁（JAVA） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="死锁（JAVA）" />
<meta property="og:description" content="死锁在多线程代码中是非常严重的BUG，一旦代码中出现死锁就会导致线程卡死。
当单个线程连续两次对同一个对象进行加锁操作时，如果该锁是不可重入锁就会发生死锁（线程卡死）
两个线程两把锁，如果出现这种情况也是会发生死锁：线程t1已经获取了锁A，线程t2已经获取了锁B，此时t1想要获取锁B，t2想要获取锁A。
Object lock1 = new Object(); Object lock2 = new Object(); Thread t1 = new Thread(()-&gt;{ synchronized(lock1) { try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } synchronized(lock2) { } } }); Thread t2 = new Thread(()-&gt;{ synchronized(lock2) { try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } synchronized(lock1) { } } }); t1.start(); t2.start(); //让主线程等待 2 秒 Thread.sleep(2000); //此时t1和t2两个线程会因为互相争对方的锁，而导致死锁 System.out.println(t1.getState()); System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bc5008a2309c5acebd779a439f7f5cab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-13T22:40:45+08:00" />
<meta property="article:modified_time" content="2023-11-13T22:40:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">死锁（JAVA）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><font color="red"><strong>死锁在多线程代码中是非常严重的BUG</strong></font>，一旦代码中出现死锁就会导致线程卡死。<br> 当<strong>单个线程连续两次</strong>对<strong>同一个对象进行加锁</strong>操作时，如果该锁是<strong>不可重入锁</strong>就会发生死锁（线程卡死）</p> 
<p>两个线程两把锁，如果出现这种情况也是会发生死锁：线程t1已经获取了锁A，线程t2已经获取了锁B，此时t1想要获取锁B，t2想要获取锁A。</p> 
<pre><code class="prism language-java"><span class="token class-name">Object</span> lock1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> lock2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//让主线程等待 2 秒</span>
<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//此时t1和t2两个线程会因为互相争对方的锁，而导致死锁</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a2/34/Xk3KPdpu_o.png" alt="在这里插入图片描述"></p> 
<p>如果此时有N个线程M把锁(N,M&gt;&gt;2)，就更加容易发生死锁的情况了。</p> 
<p>一个非常经典的N个线程M把锁的问题：哲学家就餐问题。</p> 
<p>假设有5名哲学家围在一张桌子上吃面，现在桌子上有5根筷子。（哲学家会做两件事：思考和吃面(吃面必须要拿到两根筷子，吃完后会将筷子放回原处)。且做这两件事的时间是完全随机的，同一时间只能做一件事）<br> <img src="https://images2.imgbox.com/17/8b/Ek27Cbhh_o.png" alt="在这里插入图片描述"><br> 大多数情况下是不会出现问题的但也会出现一些极端情况：现在所有的哲学家都想吃面，他们同时拿起了自己左手边的筷子，此时每位哲学家手里都有且仅有一只筷子，此时每位哲学家都在等待另一支筷子就会发生死锁。<br> 那么该如何解决死锁问题呢？首先我们先要了解死锁的必要条件，然后根据这些条件来修改。</p> 
<h2><a id="_52"></a>引发死锁的必要条件</h2> 
<ol><li>互斥(锁的基本特性)；当一个线程获取到锁后，如果另一个线程也想获取该锁就会阻塞等待。</li><li>不可抢占(锁的基本特性)；当线程A获取到锁后，如果线程B也想获取该锁只能等待A将该锁释放后再获取，不能直接抢。</li><li>请求保持(代码结构)；一个线程获取了A锁后继续获取B锁……且前面获取的锁不进行释放。</li><li>循环等待/环路等待(代码结构)；等待的依赖关系形成了环。</li></ol> 
<p>一个死锁代码一定会满足上述四种情况，任意一个不满足都不会形成死锁。</p> 
<h2><a id="_60"></a>死锁的解决方法</h2> 
<p>解决死锁的情况只要破坏上述条件中的任意一个就行了。<br> 上述四条中1和2都是锁的基本特性，所以无法改变。<br> 对于3，在代码中尽量避免出现锁嵌套的情况，但是这种情况很难避免，因为实际代码中的嵌套往往都是这样的，很难发现和避免：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">fun4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>所以解决4就显得非常重要了，那么4这种情况该如何避免呢？<br> 有一个非常简单的方法那就是约定加锁的顺序。<br> 例如对于上文中的哲学家就餐的问题：<br> 现在给每支筷子进行编号，约定每位哲学家拿筷子的顺序都是必须先拿面前编号较小的然后再拿编号较大的。<br> <img src="https://images2.imgbox.com/b6/6a/EHxtXIyf_o.png" alt="在这里插入图片描述"><br> B拿1号筷子-&gt;C拿2号筷子-&gt;D拿3号筷子-&gt;E拿4号筷子-&gt;A拿1号筷子但是1号筷子此时在B手中所以A会阻塞等待，此时E拿到5号筷子吃完后放下筷子-&gt;D拿到4号筷子吃完后放下筷子-&gt;C拿到3号筷子吃完后放下筷子-&gt;B拿到2号筷子吃完后放下筷子。<br> 此时就完美避免了死锁问题的发生。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d4b705b7113c779b7fed6dc33575544a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vulfocus靶场轻松搭建（centos7&#43;docker环境）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d3980c46a5bb7c003e73b5c937ee19d0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">教职工信息管理系统设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>