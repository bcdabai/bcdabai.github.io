<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM内存结构&amp;Java内存模型&amp;Java对象模型 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM内存结构&amp;Java内存模型&amp;Java对象模型" />
<meta property="og:description" content="悟空老师思维导图：
https://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9https://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9
1.JVM内存结构&amp;&amp;Java内存模型&amp;&amp;Java对象模型 1.1.JVM内存结构 1.2.Java对象模型 Java对象模型表示的是这个对象本身的存储模型,JVM会给这个类创建一个instanceKlass保存在方法区,用来在JVM层表示该Java类,当在Java代码中使用new创建一个对象时JVM会创建一个instanceOopDesc对象,这个对象中包含了对象头以及实例数据;
1.3.Java内存模型(JMM) 1.3.1.为什么需要JMM? 1.C语言不存在内存模型概念;
2.Java程序依赖处理器，不同处理器结果不一样;
3.无法保证并发安全;
1.3.2.什么是JMM? JMM是一组规范,需要各个JVM的实现来遵循JMM规范,以便开发者可以利用这些规范更方便的开发多线程程序;如果没有这样一个JMM内存模型来规范,那么很可能经过了不同JVM的不同规则的重排序后,导致不同虚拟机上运行的结果不一样;JMM不仅仅作为一组规范它同时还是“工具类”、“synchronized”、“Lock”等的原理;
1.3.3.JMM核心内容 1.重排序
2.可见性
3.原子性
并发编程线程安全问题的根源在于：重排序、可见性;
1.3.3.1.重排序 1.3.3.1.1.什么是重排序 代码在JVM中的执行顺序和在Java代码中的顺序不一致;(代码指令执行顺序并不是严格按照语句顺序执行的,这就是重排序);
1.3.3.1.2.重排序代码案例 import java.util.concurrent.CountDownLatch; /** * 演示代码执行时被JVM重排序 */ public class OutOfOrderExecution{ private static int x = 0,y = 0; private static int a = 0,b = 0; public static void main(String[] args) throws InterruptedException { // 计数器 int i = 0; for(;;){ i&#43;&#43;; // 重置 a = 0; b = 0; x = 0; y = 0; // 闸门 CountDownLatch countDownLatch = new CountDownLatch(1); // 线程一 Thread one = new Thread(new Runnable() { @Override public void run() { try { countDownLatch." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/188b5d51fd2aa9c2e378514d3e4dabc2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T09:47:45+08:00" />
<meta property="article:modified_time" content="2023-12-25T09:47:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM内存结构&amp;Java内存模型&amp;Java对象模型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>悟空老师思维导图：</strong><br><a class="has-card" href="https://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9" rel="nofollow" title="https://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9"><span class="link-card-box"><span class="link-title">https://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/8d/97/ANHPF0Hh_o.png" alt="icon-default.png?t=N7T8">https://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9</span></span></a></p> 
<h2>1.JVM内存结构&amp;&amp;Java内存模型&amp;&amp;Java对象模型</h2> 
<h3>1.1.JVM内存结构</h3> 
<p><img alt="" height="526" src="https://images2.imgbox.com/ca/85/cAyHSLEn_o.png" width="889"></p> 
<p></p> 
<h3>1.2.Java对象模型</h3> 
<p><img alt="" height="445" src="https://images2.imgbox.com/b6/ad/QcPIwQD8_o.png" width="852"></p> 
<p>        Java对象模型表示的是这个对象本身的存储模型,JVM会给这个类创建一个instanceKlass保存在方法区,用来在JVM层表示该Java类,当在Java代码中使用new创建一个对象时JVM会创建一个instanceOopDesc对象,这个对象中包含了对象头以及实例数据;</p> 
<h3>1.3.Java内存模型(JMM)</h3> 
<h4>1.3.1.为什么需要JMM?</h4> 
<p>        1.C语言不存在内存模型概念;</p> 
<p>        2.Java程序依赖处理器，不同处理器结果不一样;</p> 
<p>        3.无法保证并发安全;</p> 
<h4>1.3.2.什么是JMM?</h4> 
<p>        JMM是一组规范,需要各个JVM的实现来遵循JMM规范,以便开发者可以利用这些规范更方便的开发多线程程序;如果没有这样一个JMM内存模型来规范,那么很可能经过了不同JVM的不同规则的重排序后,导致不同虚拟机上运行的结果不一样;JMM不仅仅作为一组规范它同时还是“工具类”、“synchronized”、“Lock”等的原理;</p> 
<h4>1.3.3.JMM核心内容</h4> 
<p>        1.重排序</p> 
<p>        2.可见性</p> 
<p>        3.原子性</p> 
<p><strong>        </strong><span style="color:#fe2c24;"><strong>并发编程线程安全问题的根源在于：</strong>重排序、可见性;</span></p> 
<h5><span style="color:#fe2c24;">1.3.3.1.重排序</span></h5> 
<h6>1.3.3.1.1.什么是重排序</h6> 
<p>        代码在JVM中的执行顺序和在Java代码中的顺序不一致;(代码指令执行顺序并不是严格按照语句顺序执行的,这就是重排序);</p> 
<h6>1.3.3.1.2.重排序代码案例</h6> 
<pre><code>import java.util.concurrent.CountDownLatch;
/**
 * 演示代码执行时被JVM重排序
 */
public class OutOfOrderExecution{
    private static int x = 0,y = 0;
    private static int a = 0,b = 0;

    public static void main(String[] args) throws InterruptedException {

        // 计数器
        int i = 0;
        for(;;){
            i++;
            // 重置
            a = 0;
            b = 0;
            x = 0;
            y = 0;

            // 闸门
            CountDownLatch countDownLatch = new CountDownLatch(1);

            // 线程一
            Thread one = new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        countDownLatch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    a = 1;
                    x = b;
                }
            });

            // 线程二
            Thread two = new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        countDownLatch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    b = 1;
                    y = a;
                }
            });

            two.start();
            one.start();
            // 放开闸门
            countDownLatch.countDown();
            // 主线程等待子线程执行完成
            one.join();
            two.join();

            String result = "第："+ i +"次" + "(" + x + "," + y + ")";

            if(x == 0 &amp;&amp; y == 0){ // 说明：如上代码出现x,y都等于0的情况说明代码执行时被重排序了(即代码并未按照编写顺序执行,而是被编译器重排序了其执行顺序大致为：y=a=0,x=b=0,b=1,a=1,)
                System.out.println("执行代码被重排序了：" + result);
                break;
            }else {
                System.out.println(result);
            }
        }
    }
}</code></pre> 
<p><strong>执行结果</strong></p> 
<h5><img alt="" height="373" src="https://images2.imgbox.com/76/27/wbSM0eg1_o.png" width="653"></h5> 
<h6>1.3.3.1.3.重排序好处</h6> 
<p><img alt="" height="464" src="https://images2.imgbox.com/02/22/NJUa7dzF_o.png" width="902"></p> 
<h6>1.3.3.1.4.重排序的三种情况</h6> 
<p>        1.编译器优化;</p> 
<p>        2.CPU指令重排;</p> 
<p>        3.内存的“重排序”</p> 
<p></p> 
<h5>1.3.3.2.可见性</h5> 
<h6>1.3.3.2.1.什么是“可见性”问题</h6> 
<p><strong>        可见性：</strong>指一个线程对共享变量的修改对于其它线程是可见的;</p> 
<p><strong>        可见性问题：</strong>多线程并发访问共享变量时,一个线程对共享变量的修改对于其它线程可能是不</p> 
<p>                              可见的;</p> 
<h6>1.3.3.2.2.为什么会有“<span style="color:#fe2c24;">可见性</span>”问题</h6> 
<p><img alt="" height="464" src="https://images2.imgbox.com/47/cd/beGjYXYO_o.png" width="821"></p> 
<p>        因为CPU有多级缓存,导致某些线程读取到的数据可能已经过期;如果所有CPU核心都只用一个缓存,那就不存在可见性问题;而实际情况是每个核心都会将需要的数据读取到自己的“独占缓存”中,数据修改后也是先写入到自己的“独占缓存”,然后等待刷新到“主存”(所有核心共享)中,在数据还未被刷新到“主存”时造成其它核心读取到过期的数据值;</p> 
<h6>1.3.3.2.3.什么是happens-before</h6> 
<p>        happens-before规则是用来解决“可见性”问题的,即在时间上动作A发生在动作B之前,B保证能看见A的所有操作这就是happens-before;</p> 
<h6>1.3.2.2.4.哪些运用了happens-before规则</h6> 
<p>        1.单线程规则;</p> 
<p><span style="color:#fe2c24;">        2.锁操作(synchroniezd和Lock);</span></p> 
<p><span style="color:#fe2c24;">        3.volatile变量;</span></p> 
<p>        4.线程启动;</p> 
<p>        5.线程join;</p> 
<p>        6.传递性(hb代表happens-before; 如果hb(A,B),且hb(B,C)则可以推出hb(A,C)) ;</p> 
<p>        7.中断(一个线程被其它线程interrupt,那么检测中断(IsInterrupted)或者抛出 </p> 
<p>           InterruptedExcption一定能被其它线程看见);</p> 
<p>        8.构造方法(对象构造方法的最后一条指令,finalize()方法一定能看到)</p> 
<p>        9.工具类的happens-before原则</p> 
<p>               9.1.线程安全的容器,如“ConcurrentHashMap”,get一定能看到之前的所有put操作;</p> 
<p>                9.2.CountDownLatch</p> 
<p>                9.3.Semaphore</p> 
<p>                9.4.Future</p> 
<p>                9.5.线程池</p> 
<p>                9.6.CyclicBarrier</p> 
<p></p> 
<h5>1.3.3.3.原子性</h5> 
<h6>1.3.3.3.1.什么是原子性</h6> 
<p>     一系列操作,要么全部执行成功,要么全部不执行或全部执行失败,不会出现执行一半的情况,原子是不可分割的;</p> 
<h6>1.3.3.3.2.Java中的原子操作有哪些</h6> 
<p>1.除long和double之外的<span style="color:#fe2c24;">基本类型赋值</span>操作(int,byte,boolean,short,char,float);</p> 
<p>2.所有<span style="color:#fe2c24;">“引用”的赋值</span>操作;</p> 
<p>3.java.concurrent.<span style="color:#fe2c24;">Atomic</span>.*包下所有类的原子操作;</p> 
<p><span style="color:#fe2c24;"><strong>备注：</strong><em><u>创建对象不是原子性操作!</u></em></span></p> 
<pre><code>1.创建对象操作不是原子性操作,其由三个操作构成(Singleton5 instance = new Singleton5(););
    1.1.创建一个空的instance;
    1.2.调用构造方法;
    1.3.将创建好的对象赋值给instance实例;</code></pre> 
<h6>1.3.3.3.3.long和double原子性问题</h6> 
<p>        对于32位的JVM long和double的操作不是原子的(32位JVM中会将long和double的一次写入操作拆分成2个单独的写入操作),但是在64位的虚拟机上long和double的操作是原子的,在实际开发中商用的Java虚拟机已经处理了这个问题;我们自己也可以使用volatile去解决;</p> 
<h5>1.3.3.4.原子操作 + 原子操作 != 原子操作</h5> 
<p>        简单地把原子操作组合在一起<span style="color:#fe2c24;">并不能</span>保证整体依然具有原子性;</p> 
<h3>1.4.synchronized可见性的正确理解</h3> 
<p>        1.4.1.synchronized不仅保证了<span style="color:#fe2c24;">原子性</span>还保证了<span style="color:#fe2c24;">可见性</span><span style="color:#0d0016;">;</span></p> 
<p>        1.4.2.synchronized不仅让被保护的代码线程安全,还让加锁之前的代码具有可见性;</p> 
<p></p> 
<h3>1.5.面试题</h3> 
<h4>1.5.1.单例模式的七种写法及单例和并发的关系</h4> 
<p><strong>        详见:</strong><a href="https://blog.csdn.net/weixin_45876411/article/details/135112202" title="单例模式的七种写法URL">单例模式的七种写法URL</a></p> 
<h4><span style="color:#fe2c24;">1.5.2.讲一讲什么是Java内存模型</span></h4> 
<p>        是一组规范，规范了JVM,CPU,JAVA代码之间一系列转换关系,Java内存模型最重要是“重排序”，“可见性”，“原子性”这三个部分<span style="color:#4da8ee;">(</span>重排序讲1.3.3.1重排序的例子和重排序的好处<span style="color:#4da8ee;">)</span>,<span style="color:#ff9900;">(</span>可见性讲因为CPU有多级缓存JMM对内存抽象为“主内存”和“本地内存”,主内存是所有线程所共享的,本地内存是线程独占的其它线程访问不了。一个线程对变量的更改是先更新到本地内存中再同步到主内存中,其它线程只能在主内存中同步这个变量的值，因为本地内存同步到主内存是需要时间的这样就会导致一个线程在本地内存中已经更改了值而这个值还没有被同步到主内存中去,这样对于其它线程来说这个值的更改是不可见的,就会导致其它线程重主内存中拿到的值还是一个旧的值,这样就出现了“线程安全”问题，对于“可见性”来说还有一个happens-before原则即在时间上动作A发生在动作B之前,B保证能看见A的所有操作这就是happens-before;<span style="color:#0d0016;"> 再可以讲下</span>1.3.2.2.4哪些运用了happens-before原则及再讲下volatie关键字<a href="https://mp.csdn.net/mp_blog/creation/editor/135101273" title="volatile关键字">volatile关键字</a><span style="color:#ff9900;">)</span><span style="color:#0d0016;">,</span><span style="color:#be191c;">(</span><span style="color:#0d0016;">最后可以再讲下1.3.3.3.2Java中的原子操作有哪些</span><span style="color:#be191c;">)</span><span style="color:#0d0016;">;</span></p> 
<h4><span style="color:#fe2c24;">1.5.3.什么是原子操作?Java中有哪些原子操作?创建对象是原子操作吗？</span></h4> 
<p>        详见1.3.33原子性;</p> 
<h4>1.5.4.64位的double和long写入的时候是原子的吗?</h4> 
<p>        32位虚拟机上不是原子的,64位虚拟机上是原子的,实际开发中使用的商用Java虚拟机已经处理了这个问题不需要我们再考虑;</p> 
<h4><span style="color:#fe2c24;">1.5.5.volatile和synchronized的异同</span></h4> 
<p>        详见<a href="https://mp.csdn.net/mp_blog/creation/editor/135101273" title="volatile关键字">volatile关键字</a>;</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f937a974adc2fb8feb5c6df3234159fd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">git stash drop误删之后如何恢复</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a7a2d66cfa751ee4d827b3b3400c698c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人型动画足部IK权重曲线烘焙</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>