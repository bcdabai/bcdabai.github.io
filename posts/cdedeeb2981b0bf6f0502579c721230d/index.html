<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序算法总结（Python版） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排序算法总结（Python版）" />
<meta property="og:description" content="经典排序算法总结与实现 经典排序算法在面试中占有很大的比重，也是基础，为了未雨绸缪，这次收集整理并用Python实现了八大经典排序算法，包括冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序以及基数排序。希望能帮助到有需要的同学。之所以用 Python 实现，主要是因为它更接近伪代码，能用更少的代码实现算法，更利于理解。
本篇博客所有排序实现均默认从小到大。
一、冒泡排序BubbleSort 介绍： 冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。
步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 Python源代码（错误版本）：
def bubble_sort(arry): n = len(arry) #获得数组的长度 for i in range(n): for j in range(i&#43;1, n): if arry[i] &gt; arry[j] : #如果前者比后者大 arry[i],arry[j] = arry[j],arry[i] #则交换两者 return arry 注：上述代码是没有问题的，但是实现却不是冒泡排序，而是选择排序（原理见选择排序），注意冒泡排序的本质是“相邻元素”的顺序交换，而非每次完成一个最小数字的选定。
Python源代码（正确版本）：
def bubble_sort(arry): n = len(arry) #获得数组的长度 for i in range(n): for j in range(1, n-i): # 每轮找到最大数值 或者用 for j in range(i&#43;1, n) if arry[j-1] &gt; arry[j] : #如果前者比后者大 arry[j-1],arry[j] = arry[j], arry[j-1] #则交换两者 return arry 不过针对上述代码还有两种优化方案。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cdedeeb2981b0bf6f0502579c721230d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-06T15:50:44+08:00" />
<meta property="article:modified_time" content="2022-03-06T15:50:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序算法总结（Python版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>经典排序算法总结与实现</h2> 
<p>经典排序算法在面试中占有很大的比重，也是基础，为了未雨绸缪，这次收集整理并用Python实现了八大经典排序算法，包括冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序以及基数排序。希望能帮助到有需要的同学。之所以用 Python 实现，主要是因为它更接近伪代码，能用更少的代码实现算法，更利于理解。</p> 
<p>本篇博客所有排序实现均默认从小到大。</p> 
<h3><a id="BubbleSort_7"></a>一、冒泡排序BubbleSort</h3> 
<h4><a id="_9"></a>介绍：</h4> 
<p>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p> 
<h4><a id="_13"></a>步骤：</h4> 
<ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol> 
<p><strong>Python源代码（错误版本）：</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arry<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arry<span class="token punctuation">)</span>                   <span class="token comment">#获得数组的长度</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span>  arry<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arry<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">:</span>       <span class="token comment">#如果前者比后者大</span>
                arry<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arry<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arry<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>arry<span class="token punctuation">[</span>i<span class="token punctuation">]</span>      <span class="token comment">#则交换两者</span>
    <span class="token keyword">return</span> arry
</code></pre> 
<blockquote> 
 <p>注：上述代码是没有问题的，但是实现却不是冒泡排序，而是选择排序（原理见选择排序），注意冒泡排序的本质是“相邻元素”的顺序交换，而非每次完成一个最小数字的选定。</p> 
</blockquote> 
<p><strong>Python源代码（正确版本）：</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arry<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arry<span class="token punctuation">)</span>                   <span class="token comment">#获得数组的长度</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 每轮找到最大数值 或者用 for j in range(i+1, n)</span>
            <span class="token keyword">if</span>  arry<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arry<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">:</span>       <span class="token comment">#如果前者比后者大</span>
                arry<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>arry<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arry<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arry<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>      <span class="token comment">#则交换两者</span>
    <span class="token keyword">return</span> arry
</code></pre> 
<p>不过针对上述代码还有两种优化方案。</p> 
<h4><a id="1_48"></a>优化1：</h4> 
<p>某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。</p> 
<p><strong>Python源代码：</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort2</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span><span class="token punctuation">:</span>
	n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
		flag <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token comment"># 标记</span>
		<span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token keyword">if</span> ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> ary<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
				ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> ary<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ary<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
				flag <span class="token operator">=</span> <span class="token boolean">False</span>
		<span class="token comment"># 某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了</span>
		<span class="token keyword">if</span> flag<span class="token punctuation">:</span>    
			<span class="token keyword">break</span>
	<span class="token keyword">return</span> ary
			
</code></pre> 
<h4><a id="2_69"></a>优化2：</h4> 
<p>记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort3</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span><span class="token punctuation">:</span>
	n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span>
	k <span class="token operator">=</span> n    <span class="token comment">#k为循环的范围，初始值n</span>
	<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
		flag <span class="token operator">=</span> <span class="token boolean">True</span>
		<span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#只遍历到最后交换的位置即可</span>
			<span class="token keyword">if</span> ary<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
				ary<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> ary<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
				k <span class="token operator">=</span> j     <span class="token comment">#记录最后交换的位置</span>
				flag <span class="token operator">=</span> <span class="token boolean">False</span>
		<span class="token keyword">if</span> flag<span class="token punctuation">:</span>
			<span class="token keyword">break</span>
	<span class="token keyword">return</span> ary
				
</code></pre> 
<blockquote> 
 <p>注：上面for j in range(1,k)，这句很有意思，虽然后面有if ary[j-1] &gt; ary[j]则k = j,但是这个k不会直接就变动，不然试想，当j=1，0与1位置坐了交换之后，k=j=1，j这一步循环直接就挂掉了，事实上，k的改变是在下一轮i坐了改变之后才会真正起作用，所以j可以记录最后交换位置。</p> 
</blockquote> 
<h3><a id="SelectionSort_90"></a>二、选择排序SelectionSort</h3> 
<h4><a id="_93"></a>介绍：</h4> 
<p>选择排序是另一个很容易理解和实现的简单排序算法。学习它之前首先要知道它的两个很鲜明的特点。<br> <strong>1. 运行时间和输入无关</strong><br> 为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供任何实质性帮助的信息。因此使用这种排序的我们会惊讶的发现，一个已经有序的数组或者数组内元素全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长！而其他算法会更善于利用输入的初始状态，选择排序则不然。<br> <strong>2. 数据移动是最少的</strong><br> 选择排序的交换次数和数组大小关系是线性关系，选择排序无疑是最简单直观的排序。看下面的原理时可以很容易明白这一点。</p> 
<h4><a id="_103"></a>步骤：</h4> 
<ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>以此类推，直到所有元素均排序完毕。</li></ol> 
<h4><a id="python_109"></a><strong>源代码：(python实现)</strong></h4> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">select_sort</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">min</span> <span class="token operator">=</span> i                             <span class="token comment">#最小元素下标标记</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> ary<span class="token punctuation">[</span><span class="token builtin">min</span><span class="token punctuation">]</span> <span class="token punctuation">:</span>
                <span class="token builtin">min</span> <span class="token operator">=</span> j                     <span class="token comment">#找到最小值的下标</span>
        ary<span class="token punctuation">[</span><span class="token builtin">min</span><span class="token punctuation">]</span><span class="token punctuation">,</span>ary<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ary<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>ary<span class="token punctuation">[</span><span class="token builtin">min</span><span class="token punctuation">]</span>   <span class="token comment">#交换两者</span>
    <span class="token keyword">return</span> ary
</code></pre> 
<h3><a id="_InsertionSort_123"></a>三、插入排序 InsertionSort</h3> 
<h4><a id="_125"></a>介绍：</h4> 
<p>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p> 
<h4><a id="_129"></a>步骤：</h4> 
<ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol> 
<h4><a id="_138"></a>排序演示</h4> 
<p><img src="https://images2.imgbox.com/30/93/k0Q29EwD_o.gif" alt="在这里插入图片描述"></p> 
<h4><a id="python_142"></a><strong>源代码：(python实现)</strong></h4> 
<pre><code class="prism language-python"><span class="token comment"># 插入排序</span>
<span class="token keyword">def</span> <span class="token function">insert_sort</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span><span class="token punctuation">:</span>
	count <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">:</span>
		key <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>
		mark <span class="token operator">=</span> ary<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token comment"># 注： 必须将ary[i]赋值为mark，不能直接用ary[i]</span>
		<span class="token keyword">while</span> key <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">and</span> ary<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">&gt;</span> mark<span class="token punctuation">:</span>
			ary<span class="token punctuation">[</span>key<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ary<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
			key <span class="token operator">-=</span> <span class="token number">1</span>
		ary<span class="token punctuation">[</span>key<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> mark
	<span class="token keyword">return</span> ary
</code></pre> 
<h3><a id="_ShellSort_158"></a>四、希尔排序 ShellSort</h3> 
<h4><a id="_160"></a>介绍：</h4> 
<p>希尔排序的实质就是分组插入排序，该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。</p> 
<p>该方法的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p> 
<p>n=10的一个数组49, 38, 65, 97, 26, 13, 27, 49, 55, 4为例</p> 
<p><strong>第一次 gap = 10/2 = 5</strong></p> 
<p>49 38 65 97 26 13 27 49 55 4</p> 
<p>1A 1B<br> 2A 2B<br> 3A 3B<br> 4A 4B<br> 5A 5B</p> 
<p>1A, 1B, 2A, 2B等为分组标记，数字相同的表示在同一组，大写字母表示是该组的第几个元素， 每次对同一组的数据进行直接插入排序。即分成了五组(49, 13) (38, 27) (65, 49) (97, 55) (26, 4)这样每组排序后就变成了(13, 49) (27, 38) (49, 65) (55, 97) (4, 26)，下同。<br> 第二次 gap = 5 / 2 = 2</p> 
<p>排序后</p> 
<p>13 27 49 55 4 49 38 65 97 26</p> 
<p>1A 1B 1C 1D 1E<br> 2A 2B 2C 2D 2E</p> 
<p>第三次 gap = 2 / 2 = 1</p> 
<p>4 26 13 27 38 49 49 55 97 65</p> 
<p>1A 1B 1C 1D 1E 1F 1G 1H 1I 1J</p> 
<p>第四次 gap = 1 / 2 = 0 排序完成得到数组：</p> 
<p>4 13 26 27 38 49 49 55 65 97</p> 
<p>下面给出严格按照定义来写的希尔排序</p> 
<h4><a id="python_200"></a><strong>源代码：(python实现)</strong></h4> 
<pre><code class="prism language-python">
<span class="token keyword">def</span> <span class="token function">shell_sort</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span><span class="token punctuation">:</span>
    count <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span>
    gap <span class="token operator">=</span> <span class="token builtin">round</span><span class="token punctuation">(</span>count <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token comment"># 双杠用于整除（向下取整），在python直接用 “/” 得到的永远是浮点数，</span>
    <span class="token comment"># 用round()得到四舍五入值</span>
    <span class="token keyword">while</span> gap <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>gap<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">:</span>
            temp <span class="token operator">=</span> ary<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            j <span class="token operator">=</span> i
            <span class="token keyword">while</span> j <span class="token operator">-</span> gap <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">and</span> ary<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">:</span>  <span class="token comment"># 到这里与插入排序一样了</span>
                ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> ary<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span>
                j <span class="token operator">-=</span> gap
            ary<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp
        gap <span class="token operator">=</span> <span class="token builtin">round</span><span class="token punctuation">(</span>gap <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> ary

</code></pre> 
<h3><a id="_MergeSort_222"></a>五、归并排序 MergeSort</h3> 
<h4><a id="_224"></a>介绍：</h4> 
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p> 
<p>首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</p> 
<h4><a id="_231"></a>原理</h4> 
<p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p> 
<p><img src="https://images2.imgbox.com/73/63/DYV9ComP_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>归因排序：</strong> 本质是采用分治法思路（Divide and Conquer）。首先，将长度为 N 的无序数组两两拆分为长度为 1 的 N 个有序数据（<strong>divide</strong>：长度为 1 的数组自然是有序的），然后，对长度为 1 的有序数组进行两两处理（<strong>conquer</strong>：将两两长度为 1 的数组进行顺序合并）。最终，得到一个完整的排序数组<br> <strong>快速排序：</strong> 思路虽然也是分治法思路（Divide and Conquer），但其处理的思路跟归因不一样，归并排序是先两两拆分为长度为 1 的有序数组再处理，而 快速排序 则是先将一个无序数组进行处理为两组数据（左边数组一定小于右边数组），然后再进一步切分，直到长度为 1 的数组时候即完成整个排序。<br> 总结：两者分治的处理步骤不在一起，归因排序 是 分-再处理-合并，而快速排序是 处理-分-合并。</p> 
</blockquote> 
<h4><a id="_240"></a>合并方法：</h4> 
<p>设r[i…n]由两个有序子表r[i…m]和r[m+1…n]组成，两个子表长度分别为m-i +1、n-m。</p> 
<pre><code>1、j=m+1；k=i；i=i; //置两个子表的起始下标及辅助数组的起始下标
2、若i&gt;m 或j&gt;n，转⑷ //其中一个子表已合并完，比较选取结束
3、//选取r[i]和r[j]较小的存入辅助数组rf
        如果r[i]&lt;r[j]，rf[k]=r[i]； i++； k++； 转⑵
        否则，rf[k]=r[j]； j++； k++； 转⑵
4、//将尚未处理完的子表中元素存入rf
        如果i&lt;=m，将r[i…m]存入rf[k…n] //前一子表非空
        如果j&lt;=n ,  将r[j…n] 存入rf[k…n] //后一子表非空
5、合并结束。
</code></pre> 
<h4><a id="_254"></a>排序演示</h4> 
<p><img src="https://images2.imgbox.com/a2/5c/Ve26d78e_o.gif" alt="在这里插入图片描述"></p> 
<h4><a id="python_260"></a><strong>源代码：(python实现)</strong></h4> 
<pre><code class="prism language-python"><span class="token comment"># 归并排序</span>

    <span class="token keyword">def</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span><span class="token punctuation">:</span>
        
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> ary
        
        median <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment"># 二分分解</span>
        left <span class="token operator">=</span> merge_sort<span class="token punctuation">(</span>ary<span class="token punctuation">[</span><span class="token punctuation">:</span>median<span class="token punctuation">]</span><span class="token punctuation">)</span>
        right <span class="token operator">=</span> merge_sort<span class="token punctuation">(</span>ary<span class="token punctuation">[</span>median<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> merge<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>    <span class="token comment"># 合并数组</span>
    
    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token triple-quoted-string string">'''合并操作，
    将两个有序数组left[]和right[]合并成一个大的有序数组'''</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        i <span class="token operator">=</span> j <span class="token operator">=</span> k <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">and</span> j <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
                
        res <span class="token operator">=</span> res <span class="token operator">+</span> left<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span>j<span class="token punctuation">:</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> res
</code></pre> 
<h3><a id="_QuickSort_292"></a>六、快速排序 QuickSort</h3> 
<h4><a id="_294"></a>介绍：</h4> 
<p>快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p> 
<h4><a id="_297"></a>步骤：</h4> 
<ol><li>从数列中挑出一个元素作为基准数。</li><li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</li><li>再对左右区间递归执行第二步，直至各区间只有一个数。</li></ol> 
<blockquote> 
 <p>虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法：</p> 
</blockquote> 
<p>先来看实例吧，定义下面再给出（最好能用自己的话来总结定义，这样对实现代码会有帮助）。</p> 
<p>以一个数组作为示例，取区间第一个数为基准数。</p> 
<table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>72</td><td>6</td><td>57</td><td>88</td><td>60</td><td>42</td><td>83</td><td>73</td><td>48</td><td>85</td></tr></tbody></table> 
<p>初始时，i = 0; j = 9; X = a[i] = 72</p> 
<p>由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。</p> 
<p>从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++; 这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j–;</p> 
<p>数组变为：</p> 
<table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>48</td><td>6</td><td>57</td><td>88</td><td>60</td><td>42</td><td>83</td><td>73</td><td>88</td><td>85</td></tr></tbody></table> 
<p>i = 3; j = 7; X=72</p> 
<p>再重复上面的步骤，<strong>先从后向前找，再从前向后找。</strong></p> 
<p>从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++;</p> 
<p>从i开始向后找，当i=5时，由于i==j退出。</p> 
<p>此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。</p> 
<p>数组变为：</p> 
<table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>48</td><td>6</td><td>57</td><td>42</td><td>60</td><td>72</td><td>83</td><td>73</td><td>88</td><td>85</td></tr></tbody></table> 
<p>可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。</p> 
<p><strong>对挖坑填数进行总结：</strong></p> 
<p>1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</p> 
<p>2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</p> 
<p>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</p> 
<p>4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p> 
<p>照着这个总结很容易实现挖坑填数的代码.</p> 
<h4><a id="_356"></a>排序演示</h4> 
<p><img src="https://images2.imgbox.com/67/f6/JVY0MNc9_o.gif" alt="在这里插入图片描述"></p> 
<h4><a id="python_361"></a><strong>源代码：(python实现)</strong></h4> 
<pre><code class="prism language-python">
<span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> qsort<span class="token punctuation">(</span>ary<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">qsort</span><span class="token punctuation">(</span>ary<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> start <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>
        left <span class="token operator">=</span> start
        right <span class="token operator">=</span> end
        key <span class="token operator">=</span> ary<span class="token punctuation">[</span>start<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> ary
    <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>
        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right <span class="token operator">and</span> ary<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> key<span class="token punctuation">:</span>
            right <span class="token operator">-=</span> <span class="token number">1</span>
        <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>  <span class="token comment"># 说明打破while循环的原因是ary[right] &lt;= key</span>
            ary<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> ary<span class="token punctuation">[</span>right<span class="token punctuation">]</span>
            left <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right <span class="token operator">and</span> ary<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">:</span>
            left <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>  <span class="token comment"># 说明打破while循环的原因是ary[left] &gt;= key</span>
            ary<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> ary<span class="token punctuation">[</span>left<span class="token punctuation">]</span>
            right <span class="token operator">-=</span> <span class="token number">1</span>
    ary<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> key  <span class="token comment"># 此时，left=right，用key来填坑</span>

    qsort<span class="token punctuation">(</span>ary<span class="token punctuation">,</span> start<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    qsort<span class="token punctuation">(</span>ary<span class="token punctuation">,</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span>
    <span class="token keyword">return</span> ary
    
</code></pre> 
<p><strong>C++ 版本：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stack&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>


<span class="token keyword">void</span> <span class="token function">quickSortHelper</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> left <span class="token operator">=</span> begin<span class="token punctuation">;</span>
	<span class="token keyword">int</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>
	<span class="token keyword">int</span> base <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> base<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			right<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
			left<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> base<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			left<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
			right<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> base<span class="token punctuation">;</span>
	<span class="token function">quickSortHelper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">quickSortHelper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">;</span>
	<span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">quickSortHelper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> nums<span class="token punctuation">;</span>

<span class="token punctuation">}</span>



<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n<span class="token punctuation">;</span>
	cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">nums</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cin <span class="token operator">&gt;&gt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>
	res <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> res<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_459"></a>另外一种实现方法</h4> 
<p>先从待排序的数组中找出一个数作为基准数（取第一个数即可），然后将原来的数组划分成两部分：小于基准数的左子数组和大于等于基准数的右子数组。然后对这两个子数组再递归重复上述过程，直到两个子数组的所有数都分别有序。最后返回“左子数组” + “基准数” + “右子数组”，即是最终排序好的数组。</p> 
<h4><a id="python_463"></a><strong>源代码：(python实现)</strong></h4> 
<pre><code class="prism language-python"><span class="token comment"># 实现快排</span>
<span class="token keyword">def</span> <span class="token function">quicksort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> nums

    <span class="token comment"># 左子数组</span>
    less <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment"># 右子数组</span>
    greater <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment"># 基准数</span>
    base <span class="token operator">=</span> nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 对原数组进行划分</span>
    <span class="token keyword">for</span> x <span class="token keyword">in</span> nums<span class="token punctuation">:</span>
        <span class="token keyword">if</span> x <span class="token operator">&lt;</span> base<span class="token punctuation">:</span>
            less<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            greater<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>

    <span class="token comment"># 递归调用</span>
    <span class="token keyword">return</span> quicksort<span class="token punctuation">(</span>less<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">[</span>base<span class="token punctuation">]</span> <span class="token operator">+</span> quicksort<span class="token punctuation">(</span>greater<span class="token punctuation">)</span>

</code></pre> 
<h3><a id="_HeapSort_491"></a>七、堆排序 HeapSort</h3> 
<h4><a id="_492"></a>介绍：</h4> 
<p>堆排序与快速排序，归并排序一样都是时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         N 
        
       
         ∗ 
        
       
         l 
        
       
         o 
        
       
         g 
        
       
         N 
        
       
         ) 
        
       
      
        O(N*logN) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mclose">)</span></span></span></span></span>的几种常见排序方法。学习堆排序前，先讲解下什么是数据结构中的二叉堆。</p> 
<p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。</p> 
<h4><a id="_497"></a>二叉堆定义及性质：</h4> 
<p>二叉堆是完全二叉树或者是近似完全二叉树。</p> 
<p>二叉堆满足二个特性：</p> 
<p>1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</p> 
<p>2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。</p> 
<p>当父结点的键值总是大于或等于任何一个子节点的键值时为<strong>最大堆</strong>。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。下图展示一个<strong>最小堆</strong>：</p> 
<p><img src="https://images2.imgbox.com/80/f0/1a2ahM8u_o.jpg" alt=""></p> 
<p>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。<br> 每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</p> 
<p>由于其它几种堆（二项式堆，斐波纳契堆等）用的较少，一般将二叉堆就简称为堆。</p> 
<h4><a id="_516"></a>堆的存储</h4> 
<p>一般都用数组来表示堆，i结点的父结点下标就为(i – 1) / 2。它的左右子结点下标分别为2 * i +<br> 1和2 * i + 2。如第0个结点左右子结点下标分别为1和2。</p> 
<p><img src="https://images2.imgbox.com/52/68/ldNUtYnQ_o.jpg" alt=""></p> 
<h4><a id="_523"></a>堆的操作——插入删除</h4> 
<p>下面先给出《数据结构C++语言描述》中最小堆的建立插入删除的图解，再给出本人的实现代码，最好是先看明白图后再去看代码。</p> 
<p><img src="https://images2.imgbox.com/11/fc/PpKDbQFq_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_528"></a>堆化数组</h4> 
<p>有了堆的插入和删除后，再考虑下如何对一个数据进行堆化操作。要一个一个的从数组中取出数据来建立堆吧，不用！先看一个数组，如下图：</p> 
<p><img src="https://images2.imgbox.com/eb/2f/YM2HkRFx_o.png" alt="在这里插入图片描述"></p> 
<p>很明显，对叶子结点来说，可以认为它已经是一个合法的堆了即20，60， 65， 4， 49都分别是一个合法的堆。只要从A[4]=50开始向下调整就可以了。然后再取A[3]=30，A[2] = 17，A[1] = 12，A[0] = 9分别作一次向下调整操作就可以了。</p> 
<p><img src="https://images2.imgbox.com/b5/24/9M9I5oKr_o.png" alt="在这里插入图片描述"></p> 
<p>下图展示了这些步骤：</p> 
<h4><a id="_543"></a>步骤：</h4> 
<ol><li> <p>构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</p> </li><li> <p>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</p> </li><li> <p>最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</p> </li></ol> 
<p><strong>排序演示：</strong></p> 
<p><img src="https://images2.imgbox.com/13/d4/VQQpTwMc_o.gif" alt="在这里插入图片描述"></p> 
<p><strong>源代码：(python实现)</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span><span class="token punctuation">:</span>
	n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ary<span class="token punctuation">)</span>
	first <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">#最后一个非叶子节点</span>
	<span class="token keyword">for</span> start <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#构建最大堆</span>
		max_heapify<span class="token punctuation">(</span>ary<span class="token punctuation">,</span>start<span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> end <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#堆排，将最大跟堆转换成有序数组</span>
		ary<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">,</span>ary<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> ary<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ary<span class="token punctuation">[</span>end<span class="token punctuation">]</span>    <span class="token comment">#将根节点元素与最后叶子节点进行互换，取出最大根节点元素，对剩余节点重新构建最大堆</span>
		max_heapify<span class="token punctuation">(</span>ary<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>end<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">#因为end上面取的是n-1，故而这里直接放end-1，相当于忽略了最后最大根节点元素ary[n-1]</span>
	<span class="token keyword">return</span> ary


<span class="token comment">#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</span>
<span class="token comment">#start为当前需要调整最大堆的位置，end为调整边界</span>
<span class="token keyword">def</span> <span class="token function">max_heapify</span><span class="token punctuation">(</span>ary<span class="token punctuation">,</span>start<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">:</span>
	root <span class="token operator">=</span> start
	<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
		child <span class="token operator">=</span> root <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment">#调整节点的子节点</span>
		<span class="token keyword">if</span> child <span class="token operator">&gt;</span> end<span class="token punctuation">:</span>
			<span class="token keyword">break</span>
		<span class="token keyword">if</span> child <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> end <span class="token operator">and</span> ary<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&lt;</span> ary<span class="token punctuation">[</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
			child <span class="token operator">=</span> child <span class="token operator">+</span> <span class="token number">1</span>   <span class="token comment">#取较大的子节点</span>
		<span class="token keyword">if</span> ary<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">&lt;</span> ary<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token comment">#较大的子节点成为父节点</span>
			ary<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">,</span> ary<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">=</span> ary<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">,</span> ary<span class="token punctuation">[</span>root<span class="token punctuation">]</span>    <span class="token comment">#交换</span>
			root <span class="token operator">=</span> child
		<span class="token keyword">else</span><span class="token punctuation">:</span>
			<span class="token keyword">break</span>

</code></pre> 
<h3><a id="_590"></a>八、基数排序</h3> 
<blockquote> 
 <p>假设要对 10 万个手机号码进行排序，显然桶排序和计数排序都不太适合，那怎样才能做到时间复杂度为 O(n) 呢?</p> 
</blockquote> 
<p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p> 
<h4><a id="81__598"></a>8.1 基数排序原理</h4> 
<ul><li>手机号码有这样的规律，假设要比较两个手机号码 a, b 的大小，如果在前面几位中，a 手机号码已经比 b大了，那后面几位就不用看了。</li><li>借助 <strong>稳定排序算法</strong>，我们可以这么实现。从手机号码的最后一位开始，分别按照每一位的数字对手机号码进行排序，依次往前进行，经过 11 次排序之后，手机号码就都有序了。</li><li>下面是一个字符串的排序实例，和手机号码类似。</li></ul> 
<p><img src="https://images2.imgbox.com/3c/ce/rrtQaq0t_o.png" alt="在这里插入图片描述"></p> 
<ul><li>根据每一位的排序，我们可以用刚才的桶排序或者计数排序来实现，它们的时间复杂度可以做到 O(n)。如果排序的数据有 K位，则总的时间复杂度为 O(K * n)，当 K 不大时，基数排序的时间复杂度就近似为 O(n)。</li><li>有时候，要排序的数据并不都是等长的，比如我们要对英文单词进行排序。这时候，我们可以<strong>把所有单词都补足到相同长度，位数不够的在后面补 ’0‘</strong>，所有字母的 ASCII 码都大于 ‘0’，因此不会影响原有的大小顺序。</li><li><strong>基数排序需要数据可以分割出独立的位出来，而且位之间有递进的关系。除此之外，每一位的数据范围都不能太大，要可以用线性排序算法来进行排序</strong>。</li></ul> 
<h4><a id="82__615"></a>8.2 算法思想</h4> 
<p>基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p> 
<p>算法步骤：</p> 
<ul><li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li><li>从最低位开始，依次进行一次排序。</li><li>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li></ul> 
<p>基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most significant digital），LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。</p> 
<p>不妨通过一个具体的实例来展示一下基数排序是如何进行的。 设有一个初始序列为: R {50, 123, 543, 187, 49, 30, 0, 2, 11, 100}。</p> 
<p>我们知道，任何一个阿拉伯数，它的各个位数上的基数都是以 0~9 来表示的，所以我们不妨把 0~9 视为 10 个桶。</p> 
<p>我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。例如：R[0] = 50，个位数上是 0，将这个数存入编号为 0 的桶中。</p> 
<p><img src="https://images2.imgbox.com/d3/d3/BhVcvhCd_o.png" alt="在这里插入图片描述"></p> 
<p>分类后，我们在从各个桶中，将这些数按照从编号 0 到编号 9 的顺序依次将所有数取出来。这时，得到的序列就是个位数上呈递增趋势的序列。</p> 
<p>按照个位数排序： {50, 30, 0, 100, 11, 2, 123, 543, 187, 49}。</p> 
<p>接下来，可以对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。</p> 
<p><strong>动态效果示意图：</strong></p> 
<p><img src="https://images2.imgbox.com/9e/c8/hwuXztUq_o.gif" alt="在这里插入图片描述"></p> 
<h4><a id="83__646"></a>8.3 代码</h4> 
<p>C++：</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 求出数组中最大数的位数的函数</span>
<span class="token keyword">int</span> <span class="token function">MaxBit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> input<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 数组最大值</span>
	<span class="token keyword">int</span> max_data <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> input<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max_data<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			max_data <span class="token operator">=</span> input<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 数组最大值的位数</span>
	<span class="token keyword">int</span> bits_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>max_data<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		bits_num<span class="token operator">++</span><span class="token punctuation">;</span>
		max_data <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> bits_num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 取数xxx上的第d位数字</span>
<span class="token keyword">int</span> <span class="token function">digit</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> pow <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>d <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		pow <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> num <span class="token operator">/</span> pow <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 基数排序</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">RadixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> input<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 临时数组，用来存放排序过程中的数据</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">bucket</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>					
	<span class="token comment">// 位记数器，从第0个元素到第9个元素依次用来记录当前比较位是0的有多少个...是9的有多少个数</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				
	<span class="token comment">// 从低位往高位循环</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> d <span class="token operator">&lt;=</span> <span class="token function">MaxBit</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span> d<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 计数器清0</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 统计各个桶中的个数</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			count<span class="token punctuation">[</span><span class="token function">digit</span><span class="token punctuation">(</span>input<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">/*
		* 比如某次经过上面统计后结果为：[0, 2, 3, 3, 0, 0, 0, 0, 0, 0]则经过下面计算后 结果为： [0, 2,
		* 5, 8, 8, 8, 8, 8, 8, 8]但实质上只有如下[0, 2, 5, 8, 0, 0, 0, 0, 0, 0]中
		* 非零数才用到，因为其他位不存在，它们分别表示如下：2表示比较位为1的元素可以存放在索引为1、0的
		* 位置，5表示比较位为2的元素可以存放在4、3、2三个(5-2=3)位置，8表示比较位为3的元素可以存放在
		* 7、6、5三个(8-5=3)位置
		*/</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">/*
		* 注，这里只能从数组后往前循环，因为排序时还需保持以前的已排序好的顺序，不应该打
		* 乱原来已排好的序，如果从前往后处理，则会把原来在前面会摆到后面去，因为在处理某个
		* 元素的位置时，位记数器是从大到到小（count[digit(arr[i], d)]--）的方式来处
		* 理的，即先存放索引大的元素，再存放索引小的元素，所以需从最后一个元素开始处理。
		* 如有这样的一个序列[212,213,312]，如果按照从第一个元素开始循环的话，经过第一轮
		* 后（个位）排序后，得到这样一个序列[312,212,213]，第一次好像没什么问题，但问题会
		* 从第二轮开始出现，第二轮排序后，会得到[213,212,312]，这样个位为3的元素本应该
		* 放在最后，但经过第二轮后却排在了前面了，所以出现了问题
		*/</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token function">digit</span><span class="token punctuation">(</span>input<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
			bucket<span class="token punctuation">[</span>count<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> input<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			count<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 临时数组复制到 input 中</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			input<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> input<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">543</span><span class="token punctuation">,</span> <span class="token number">187</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">test</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"排序前:"</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> test<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> test<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> test<span class="token punctuation">;</span>
	result <span class="token operator">=</span> <span class="token function">RadixSort</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"排序后:"</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果如下图所示：</p> 
<p><img src="https://images2.imgbox.com/a2/b9/yB7GMkSM_o.png" alt="在这里插入图片描述"></p> 
<p>Python：</p> 
<pre><code class="prism language-python"><span class="token comment"># -*- coding:utf-8 -*-</span>

<span class="token keyword">def</span> <span class="token function">RadixSort</span><span class="token punctuation">(</span>input_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token triple-quoted-string string">'''
	函数说明:基数排序（升序）
	Author:
		www.cuijiahua.com
	Parameters:
		input_list - 待排序列表
	Returns:
		sorted_list - 升序排序好的列表
	'''</span>
	<span class="token keyword">def</span> <span class="token function">MaxBit</span><span class="token punctuation">(</span>input_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token triple-quoted-string string">'''
		函数说明:求出数组中最大数的位数的函数
		Author:
			www.cuijiahua.com
		Parameters:
			input_list - 待排序列表
		Returns:
			bits-num - 位数
		'''</span>
		max_data <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>input_list<span class="token punctuation">)</span>
		bits_num <span class="token operator">=</span> <span class="token number">0</span>
		<span class="token keyword">while</span> max_data<span class="token punctuation">:</span>
			bits_num <span class="token operator">+=</span> <span class="token number">1</span>
			max_data <span class="token operator">//=</span> <span class="token number">10</span>
		<span class="token keyword">return</span> bits_num

	<span class="token keyword">def</span> <span class="token function">digit</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token triple-quoted-string string">'''
		函数说明:取数xxx上的第d位数字
		Author:
			www.cuijiahua.com
		Parameters:
			num - 待操作的数
			d - 第d位的数
		Returns:
			取数结果
		'''</span>	
		p <span class="token operator">=</span> <span class="token number">1</span>
		<span class="token keyword">while</span> d <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>
			d <span class="token operator">-=</span> <span class="token number">1</span>
			p <span class="token operator">*=</span> <span class="token number">10</span>
		<span class="token keyword">return</span> num <span class="token operator">//</span> p <span class="token operator">%</span> <span class="token number">10</span>


	<span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>input_list<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
	sorted_list <span class="token operator">=</span> input_list
	length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>sorted_list<span class="token punctuation">)</span>
	bucket <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> length
	
	<span class="token keyword">for</span> d <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> MaxBit<span class="token punctuation">(</span>sorted_list<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">10</span>

		<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">:</span>
			count<span class="token punctuation">[</span>digit<span class="token punctuation">(</span>sorted_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>

		<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>

		<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
			k <span class="token operator">=</span> digit<span class="token punctuation">(</span>sorted_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span>
			bucket<span class="token punctuation">[</span>count<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sorted_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
			count<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>
		<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">:</span>
			sorted_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

	<span class="token keyword">return</span> sorted_list

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
	input_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">543</span><span class="token punctuation">,</span> <span class="token number">187</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'排序前:'</span><span class="token punctuation">,</span> input_list<span class="token punctuation">)</span>
	sorted_list <span class="token operator">=</span> RadixSort<span class="token punctuation">(</span>input_list<span class="token punctuation">)</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'排序后:'</span><span class="token punctuation">,</span> sorted_list<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="84__850"></a>8.4 算法分析</h4> 
<h5><a id="841__852"></a>8.4.1 基数排序的性能</h5> 
<p><img src="https://images2.imgbox.com/22/48/AGufNXmv_o.png" alt="在这里插入图片描述"></p> 
<p>其中，d 代表数组元素最高为位数，n 代表元素个数。</p> 
<h5><a id="842__857"></a>8.4.2 时间复杂度</h5> 
<p>这个时间复杂度比较好计算：count * length；其中 count 为数组元素最高位数，length为元素个数；所以时间复杂度：O(n * d)</p> 
<h5><a id="843__861"></a>8.4.3 空间复杂度</h5> 
<p>空间复杂度是使用了两个临时的数组：10 + length；所以空间复杂度：<strong>O（n）。</strong></p> 
<h5><a id="844__865"></a>8.4.4 算法稳定性</h5> 
<p>在基数排序过程中，每次都是将当前位数上相同数值的元素统一“装桶”，并不需要交换位置。所以基数排序是<strong>稳定</strong>的算法。</p> 
<h3><a id="9__869"></a>9. 排序算法总结</h3> 
<h4><a id="91__871"></a>9.1 时间复杂度</h4> 
<p>下面为七种经典排序算法指标对比情况：</p> 
<p><img src="https://images2.imgbox.com/67/01/1ZUWEs3W_o.png" alt="在这里插入图片描述"></p> 
<p>O(n)这样的标志叫做渐近时间复杂度,是个近似值.各种渐近时间复杂度由小到大的顺序如下</p> 
<p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</p> 
<p>一般时间复杂度到了<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          2 
         
        
          n 
         
        
       
      
        2^n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>(指数阶)及更大的时间复杂度,这样的算法我们基本上不会用了,太不实用了.比如递归实现的汉诺塔问题算法就是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
        
        
          2 
         
        
          n 
         
        
       
         ) 
        
       
      
        O(2^n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>.</p> 
<p>平方阶(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          n 
         
        
          2 
         
        
       
      
        n^2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>)的算法是勉强能用,而nlogn及更小的时间复杂度算法那就是非常高效的算法了啊.</p> 
<h4><a id="92__885"></a>9.2 空间复杂度</h4> 
<p>冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为O(1),因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引)</p> 
<p>快速排序空间复杂度为logn(因为递归调用了) ,归并排序空间复杂是O(n),需要一个大小为n的临时数组.</p> 
<p>基数排序的空间复杂是O(n),桶排序的空间复杂度不确定</p> 
<h4><a id="93__892"></a>9.3 最快的排序算法是桶排序</h4> 
<p>所有排序算法中最快的应该是桶排序(很多人误以为是快速排序,实际上不是.不过实际应用中快速排序用的多)但桶排序一般用的不多,因为有几个比较大的缺陷.</p> 
<p>1.待排序的元素不能是负数,小数.</p> 
<p>2.空间复杂度不确定,要看待排序元素中最大值是多少.</p> 
<p>所需要的辅助数组大小即为最大元素的值.</p> 
<h4><a id="_904"></a>参考资料</h4> 
<ul><li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" rel="nofollow">经典排序算法总结与实现</a></li><li><a href="https://blog.csdn.net/column/details/algorithm-easyword.html">白话经典算法</a></li><li><a href="https://blog.csdn.net/weiwenhp/article/details/8622728">各种排序算法比较(2):时间复杂度,空间复杂度</a></li><li><a href="https://juejin.im/post/59fbe7766fb9a0451c39bf21#6" rel="nofollow">排序算法总结</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/993365cd702472f558c12289c29dd3b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于JDK8的LongAdder类源码解读</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a84931d82b11bd5e122add6514db589a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring主从数据库的配置和动态数据源切换原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>