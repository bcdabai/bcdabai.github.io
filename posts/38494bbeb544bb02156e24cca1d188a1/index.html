<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JS继承】JS继承之ES6 Class 继承 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【JS继承】JS继承之ES6 Class 继承" />
<meta property="og:description" content="自我介绍：大家好，我是吉帅振的网络日志；微信公众号：吉帅振的网络日志；前端开发工程师，工作4年，去过上海、北京，经历创业公司，进过大厂，现在郑州敲代码。
JS继承专栏 1【JS继承】什么是JS继承？
2【JS继承】常见的7种继承方式
3【JS继承】JS继承之原型链继承
4【JS继承】JS继承之构造函数继承
5【JS继承】JS继承之组合继承
6【JS继承】JS继承之原型式继承
7【JS继承】JS继承之寄生式继承
8【JS继承】JS继承之寄生组合式继承
9【JS继承】JS继承之ES6 Class继承
JS是一种基于对象的语言，要实现面向对象，写法跟传统的面向对象有很大的差异。ES6引入了Class语法糖，使得JS的继承更像面向对象语言的写法。
此篇博客，分为：基本介绍、Vue使用案例
基本介绍 Class可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多；
1
2
3
4
class Father {
}
class Son extends Father {
}
代码定义了一个Son 类，该类通过extends关键字，继承了Father类的所有属性和方法，但是由于没有部署任何代码,所以这两个类完全一样，等于复制了一个Father类。
1
2
3
4
5
6
7
8
9
10
class Son extends Father {
constructor (name,age,city) {
super(name,age);//调用父类的constructor(name,age);
this.city = city;
}
toString () { return this.city&#43; &#34; &#34; &#43;super.toString();//调用父类的toString()
}
}
constructor方法和toString方法之中，都出现了super关键字，他在这里表示父类的构造函数，用来新建父类的this对象；
子类必须在constructor方法中调用super方法，否则新建实例时会报错，这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象；
1
2" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/38494bbeb544bb02156e24cca1d188a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-29T10:56:04+08:00" />
<meta property="article:modified_time" content="2022-06-29T10:56:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JS继承】JS继承之ES6 Class 继承</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" src="https://images2.imgbox.com/ea/83/YP4ziZsw_o.png"></p> 
<p><strong>自我介绍：大家好，我是<strong><strong><strong><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fqian-duan-kai-fa-xiao-ren-wu" rel="nofollow" title="吉帅振的网络日志">吉帅振的网络日志</a></strong></strong></strong>；微信公众号：吉帅振的网络日志；前端开发工程师，工作4年，去过上海、北京，经历创业公司，进过大厂，现在郑州敲代码。</strong></p> 
<p><strong>JS继承专栏</strong> </p> 
<p><strong><strong><a href="https://blog.csdn.net/qq_42451979/article/details/125255016" title="1【JS继承】什么是JS继承？">1【JS继承】什么是JS继承？</a></strong></strong></p> 
<p><a href="https://blog.csdn.net/qq_42451979/article/details/125271820" title="2【JS继承】常见的7种继承方式">2【JS继承】常见的7种继承方式</a></p> 
<p><a href="https://blog.csdn.net/qq_42451979/article/details/82792475" title="3【JS继承】JS继承之原型链继承">3【JS继承】JS继承之原型链继承</a></p> 
<p><a href="https://blog.csdn.net/qq_42451979/article/details/125310180" title="4【JS继承】JS继承之构造函数继承">4【JS继承】JS继承之构造函数继承</a></p> 
<p><a href="https://blog.csdn.net/qq_42451979/article/details/125328929" title="5【JS继承】JS继承之组合继承">5【JS继承】JS继承之组合继承</a></p> 
<p><a href="https://blog.csdn.net/qq_42451979/article/details/125368061" title="6【JS继承】JS继承之原型式继承">6【JS继承】JS继承之原型式继承</a></p> 
<p><a href="https://blog.csdn.net/qq_42451979/article/details/125384540" title="7【JS继承】JS继承之寄生式继承">7【JS继承】JS继承之寄生式继承</a></p> 
<p><a href="https://blog.csdn.net/qq_42451979/article/details/125409028" title="8【JS继承】JS继承之寄生组合式继承">8【JS继承】JS继承之寄生组合式继承</a></p> 
<p><a href="https://blog.csdn.net/qq_42451979/article/details/125424790" title="9【JS继承】JS继承之ES6 Class继承">9【JS继承】JS继承之ES6 Class继承</a></p> 
<p>JS是一种基于对象的语言，要实现面向对象，写法跟传统的面向对象有很大的差异。ES6引入了Class语法糖，使得JS的继承更像面向对象语言的写法。</p> 
<p>此篇博客，分为：基本介绍、Vue使用案例</p> 
<h2><a name="t0"></a>基本介绍</h2> 
<p>Class可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多；</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>class Father {<!-- --></code></p> <p><code> </code><code>}</code></p> <p><code>class Son extends Father {<!-- --></code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>代码定义了一个Son 类，该类通过extends关键字，继承了Father类的所有属性和方法，但是由于没有部署任何代码,所以这两个类完全一样，等于复制了一个Father类。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> </td><td> <p><code>class Son extends Father {<!-- --></code></p> <p><code>     </code><code>constructor (name,age,city) {<!-- --></code></p> <p><code>        </code><code>super</code><code>(name,age);</code><code>//调用父类的constructor(name,age);</code></p> <p><code>        </code><code>this</code><code>.city = city;</code></p> <p><code>      </code><code>}</code></p> <p><code> </code> </p> <p><code>      </code><code>toString () { </code></p> <p><code>         </code><code>return</code> <code>this</code><code>.city+ </code><code>" "</code> <code>+</code><code>super</code><code>.toString();</code><code>//调用父类的toString()</code></p> <p><code>      </code><code>}</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>constructor方法和toString方法之中，都出现了super关键字，他在这里表示父类的构造函数，用来新建父类的this对象；</p> 
<p><strong>子类必须在constructor方法中调用super方法，否则新建实例时会报错，这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象；</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>class Father {  }</code></p> <p><code> </code> </p> <p><code>class Son extends Father {<!-- --></code></p> <p><code>     </code><code>constructor(){ }</code></p> <p><code>}</code></p> <p><code>let s = </code><code>new</code> <code>Son();</code></p> <p><code>//referenceError : this is not defined </code></p> </td></tr></tbody></table> 
<p>Son继承了父类Fatherm,但是他的构造函数没有调用super方法，这导致新建实例时报错；<br><strong>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上（Parent.apply(this)）,ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法）,然后再用子类的构造函数修改this；</strong><br><strong>如果子类没有定义constructor方法，这个方法会默认添加，也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> </td><td> <p><code>class Son extends Father {<!-- --></code></p> <p><code>}</code></p> <p><code> </code> </p> <p><code>//等同于</code></p> <p><code>class Son extends Parent {<!-- --></code></p> <p><code>    </code><code>constructor(...args) {<!-- --></code></p> <p><code>    </code><code>super</code><code>(...args);</code></p> <p><code>   </code><code>}</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>另一个需要注意的是：在子类的构造函数中，只有调用super之后，才能使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例；</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> </td><td> <p><code>class Father {<!-- --></code></p> <p><code>   </code><code>constructor (x,y) {<!-- --></code></p> <p><code>      </code><code>this</code><code>.x= x;</code></p> <p><code>      </code><code>this</code><code>.y = y;</code></p> <p><code>    </code><code>}</code></p> <p><code>}</code></p> <p><code> </code> </p> <p><code>class Son extends Father {<!-- --></code></p> <p><code>   </code><code>constructor (x, y, color) {<!-- --></code></p> <p><code>       </code><code>this</code><code>.color =color ;</code><code>//ReferenceError : this is not defined</code></p> <p><code>      </code><code>super</code><code>(x,y);</code></p> <p><code>       </code><code>this</code><code>.color = color;</code><code>//正确</code></p> <p><code>      </code><code>}</code></p> <p><code>}</code></p> <p><code> </code> </p> <p><code>let s = </code><code>new</code> <code>Son(25,8,</code><code>"green"</code><code>);</code></p> <p><code>s </code><code>instanceof</code> <code>Son </code><code>//true </code></p> <p><code>s </code><code>instanceof</code> <code>Father </code><code>//true</code></p> </td></tr></tbody></table> 
<p>子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的；</p> 
<p><strong>Object.getPrototypeOf()方法用来从子类上获取父类</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>Object.getPrototypeOf( Son ) ===Father</code></p> <p><code>//true</code></p> <p><code>//因此可以用这个方法判断，一个类是否继承了另一类</code></p> </td></tr></tbody></table> 
<p><strong>super 关键字</strong><br> super这个关键字，<strong>既可以当作函数使用，也可以当作对象使用，</strong><br> （1）第一情况是：super当作函数调用时，代表父类的构造函数，ES6要求，子类的构造函数必须执行一个super函数；</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>class Father { }</code></p> <p><code> </code> </p> <p><code>class Son extends Father {<!-- --></code></p> <p><code>    </code><code>constructor () {<!-- --></code></p> <p><code>          </code><code>super</code><code>();</code></p> <p><code>       </code><code>}</code></p> <p><code>}</code></p> <p><code>//子类Son的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</code></p> </td></tr></tbody></table> 
<p><strong>super虽然代表了父类Father的构造函数，但是返回的是子类Son的实例，即super内部的this指向的是Son，因此super()在这里相当于Father.constructor.call(this)；</strong><br> 而且作为函数时，super()只能用在子类的构造函数中，在其他地方会报错；</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> </td><td> <p><code>class A {<!-- --></code></p> <p><code>     </code><code>constructor (){<!-- --></code></p> <p><code>        </code><code>console.log(</code><code>new</code><code>.target.name);</code></p> <p><code>      </code><code>}</code></p> <p><code> </code><code>}</code></p> <p><code> </code> </p> <p><code>class B extends A {<!-- --></code></p> <p><code>   </code><code>constructor () {<!-- --></code></p> <p><code>      </code><code>super</code><code>();</code></p> <p><code>      </code><code>}</code></p> <p><code> </code><code>}</code></p> <p><code>  </code><code>new</code> <code>A()</code><code>//A</code></p> <p><code> </code><code>new</code> <code>B()</code><code>//B </code></p> </td></tr></tbody></table> 
<p>new.target指向当前正在执行的函数，在super()执行时，他指向的是子类B的构造函数，而不是父类A的构造函数，super()内部的this指向的是B；</p> 
<p>（2）第二种情况，super作为对象时，在普通方法中，指向父类的原型对象，在静态方法中，指向父类；</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> </td><td> <p><code>class Father{<!-- --></code></p> <p><code>   </code><code>getName ( ) {<!-- --></code></p> <p><code>     </code><code>return</code> <code>"MGT360124"</code><code>;</code></p> <p><code>   </code><code>}</code></p> <p><code>}</code></p> <p><code>class Son extends Father {<!-- --></code></p> <p><code>    </code><code>constructor () {<!-- --></code></p> <p><code>    </code><code>super</code><code>();</code></p> <p><code>    </code><code>console.log(</code><code>super</code><code>.getName() ) </code><code>//“MGT360124”</code></p> <p><code>    </code><code>}</code></p> <p><code>}</code></p> <p><code>let s = </code><code>new</code> <code>Son();</code></p> </td></tr></tbody></table> 
<p>子类Son中的super.p()就是将super当作一个对象使用，这时,super在普通方法中，指向Father.prototype,所以super.getName()就相当于Father.prototype.getName();//"MGT360124"，由于super指向父类的原型对象，所以定义在父类实例上的方法或者属性，是无法通过super调用的；</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> </td><td> <p><code>class Father {<!-- --></code></p> <p><code>   </code><code>constructor () {<!-- --></code></p> <p><code>       </code><code>this</code><code>.p =2</code></p> <p><code>     </code><code>}</code></p> <p><code>}</code></p> <p><code> </code> </p> <p><code>class Son extends Father {<!-- --></code></p> <p><code>     </code><code>get m ( ) {<!-- --></code></p> <p><code>          </code><code>return</code> <code>super</code><code>.p;</code></p> <p><code>     </code><code>}</code></p> <p><code>     </code><code>getValue ( ) {<!-- --></code></p> <p><code>          </code><code>return</code> <code>super</code><code>.a;</code></p> <p><code>      </code><code>}</code></p> <p><code>}</code></p> <p><code>let s = </code><code>new</code> <code>Son();</code></p> <p><code>s.m</code></p> <p><code>//undefined</code></p> </td></tr></tbody></table> 
<p>p是父类Father实例的属性，super.p就引用不到它</p> 
<p>如果属性定义在父类的原型对象上，super就可以取到。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> </td><td> <p><code>class A {}</code></p> <p><code>A.prototype.x = 2;</code></p> <p><code> </code> </p> <p><code>class B extends A {<!-- --></code></p> <p><code> </code><code>constructor() {<!-- --></code></p> <p><code>  </code><code>super</code><code>();</code></p> <p><code>  </code><code>console.log(</code><code>super</code><code>.x) </code><code>// 2</code></p> <p><code> </code><code>}</code></p> <p><code>}</code></p> <p><code> </code> </p> <p><code>let b = </code><code>new</code> <code>B();</code></p> </td></tr></tbody></table> 
<p>属性x是定义在A.prototype上面的，所以super.x可以取到它的值。</p> 
<p>ES6 规定，<strong>通过super调用父类的方法时，super会绑定子类的this。</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> </td><td> <p><code>class Father {<!-- --></code></p> <p><code>   </code><code>constructor () {<!-- --></code></p> <p><code>      </code><code>this</code><code>.x =1;</code><code>//这个this指向的是Father对象的实例</code></p> <p><code>   </code><code>}</code></p> <p><code>   </code><code>print () {<!-- --></code></p> <p><code>      </code><code>console.log(</code><code>this</code><code>.x);</code></p> <p><code>   </code><code>}</code></p> <p><code>}</code></p> <p><code> </code> </p> <p><code>class Son extends Father {<!-- --></code></p> <p><code>   </code><code>constructor () {<!-- --></code></p> <p><code>       </code><code>super</code><code>();</code></p> <p><code>        </code><code>this</code><code>.x = 2;</code><code>//这个this指向的是Son对象的实例</code></p> <p><code>   </code><code>}</code></p> <p><code>     </code><code>m() {<!-- --></code></p> <p><code>      </code><code>super</code><code>.print();    </code></p> <p><code>     </code><code>}</code></p> <p><code>}</code></p> <p><code>let s = </code><code>new</code> <code>Son();</code></p> <p><code>s.m();</code></p> <p><code>//2 </code></p> </td></tr></tbody></table> 
<p>super.print()虽然调用的是Father.prototype.print()，但是Father.prototype.print()会绑定子类Son的this，导致输出的是2，而不是1，也就是说，实际上执行的是 super.print.call(this)。</p> 
<p>如果super作为对象，用在静态方法中，这时super将指向父类，而不是父类的原型对象；</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> </td><td> <p><code>class Parent {<!-- --></code></p> <p><code>      </code><code>static myMethod (msg) {<!-- --></code></p> <p><code>           </code><code>console.log(</code><code>"static"</code><code>,msg);</code></p> <p><code>        </code><code>}</code></p> <p><code>      </code><code>myMethod (msg) {<!-- --></code></p> <p><code>          </code><code>console.log(</code><code>"instance"</code> <code>,msg);</code></p> <p><code>        </code><code>}</code></p> <p><code>}</code></p> <p><code> </code> </p> <p><code>class Child extends Parent {<!-- --></code></p> <p><code>     </code><code>static myMethod(msg) {<!-- --></code></p> <p><code>        </code><code>super</code><code>.myMethod(msg);</code></p> <p><code>     </code><code>}</code></p> <p><code>      </code><code>myMethod (msg) {<!-- --></code></p> <p><code>      </code><code>super</code><code>.myMethod(msg);</code></p> <p><code>      </code><code>}</code></p> <p><code> </code><code>}</code></p> <p><code> </code> </p> <p><code>Child.myMethod(1);</code></p> <p><code>//static 1</code></p> <p><code>var</code> <code>child = </code><code>new</code> <code>Child();</code></p> <p><code>child.myMethod(2);</code></p> <p><code>//instance 2</code></p> </td></tr></tbody></table> 
<p>super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。<br> 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。<br><strong>类的prototype属性和<strong>proto</strong>属性</strong><br> 大多数浏览器的ES5实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性，class作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链；<br> （1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类；<br> （2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性；</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> </td><td> <p><code>class A{<!-- --></code></p> <p><code>}</code></p> <p><code>class B{<!-- --></code></p> <p><code>}</code></p> <p><code>//B的实例继承A的实例</code></p> <p><code>Object.setPrototypeOf(B.prototype, A.prototype);</code></p> <p><code> </code> </p> <p><code>//B 的实例继承A的静态属性</code></p> <p><code>Object.setPrototypeOf(B,A);</code></p> <p><code> </code> </p> <p><code>const b = </code><code>new</code> <code>B();</code></p> </td></tr></tbody></table> 
<p>《对象的扩展》一章中Object.setPrototypeOf()方法的实现：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>Object.setPrototypeOf = </code><code>function</code> <code>(obj, proto) {<!-- --></code></p> <p><code>obj.__proto__ = proto;</code></p> <p><code>  </code><code>return</code> <code>obj ;</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>因此</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>Object.setPrototypeOf( B.prototype , A.prototype );</code></p> <p><code>//等同于</code></p> <p><code>B.prototype.__proto__ = A.prototype ;</code></p> <p><code> </code> </p> <p><code>Object.setPrototypeOf(B, A);</code></p> <p><code>//等同于</code></p> <p><code>B.__proto__ = A;</code></p> </td></tr></tbody></table> 
<p>这两条继承链，可以理解为：作为一个对象，子类B的原型（<strong>proto</strong>属性）是父类（A）；作为一个构造函数，子类B的原型对象（prototype属性）是父类的原型对象（prototype）的实例；</p> 
<p><strong>extends的继承目标</strong><br> extends关键字后面可以跟很多类型的值；</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>class B extends A{<!-- --></code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>只要A有一个prototype属性的函数，就能被B继承，由于函数都有prototype属性（除了Function.prototype函数）,因此A可以使任意函数，下面三种情况：<br> （1）子类继承Object类</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>class A extends Object {<!-- --></code></p> <p><code>}</code></p> <p><code>A.__proto__ === Object </code><code>//true;</code></p> <p><code>A.prototype.__proto__ === Object.prototype </code><code>//true</code></p> </td></tr></tbody></table> 
<p>这种情况就是 ： A就是构造函数Object的复制，A的实例就是Object的实例<br> （2）不存在任何继承</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>class A {<!-- --></code></p> <p><code>}</code></p> <p><code>A.__proto__ === Function.prototype </code><code>//true</code></p> <p><code>A.prototype.__proto__ = Object.prototype </code><code>//true</code></p> </td></tr></tbody></table> 
<p>这种情况是：A作为一个基类（不存在任何继承）,就是一个普通的函数，所以直接继承Function.prototype。但是A调用后返回一个空对象（即Object实例），所以A.prototype.<strong>proto</strong>指向构造函数（Object）的prototype属性；<br><strong>实例的<strong>proto</strong>属性</strong><br> 子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。</p> 
<p><strong>原生构造函数的继承</strong><br> 原生构造函数是指语言内置的构造函数，通常用来生成数据结构。</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> </td><td> <p><code>Boolean()</code></p> <p><code>Number()</code></p> <p><code>String()</code></p> <p><code>Array()</code></p> <p><code>Date()</code></p> <p><code>Function()</code></p> <p><code>RegExp()</code></p> <p><code>Error()</code></p> <p><code>Object()</code></p> </td></tr></tbody></table> 
<p>extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。</p> 
<h2><a name="t1"></a>vue使用</h2> 
<p>testClass.js</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> </td><td> <p><code>//定义类</code></p> <p><code>class Person{ </code></p> <p><code>    </code><code>// 构造 </code></p> <p><code>    </code><code>constructor(x,y){ </code></p> <p><code>        </code><code>this</code><code>.x = x; </code></p> <p><code>        </code><code>this</code><code>.y = y; </code></p> <p><code>    </code><code>} </code></p> <p><code> </code> </p> <p><code>  </code><code>//定义在类中的方法不需要添加function</code></p> <p><code>    </code><code>toString(){ </code></p> <p><code>        </code><code>return</code> <code>(</code><code>this</code><code>.x + </code><code>"的年龄是"</code> <code>+</code><code>this</code><code>.y+</code><code>"岁"</code><code>); </code></p> <p><code>    </code><code>} </code></p> <p><code>} </code></p> <p><code>export {<!-- --></code></p> <p><code>    </code><code>Person</code></p> <p><code>}; </code></p> </td></tr></tbody></table> 
<p>test.vue</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> </td><td> <p><code>&lt;template&gt;</code></p> <p><code>    </code><code>&lt;div&gt;</code></p> <p><code>        </code><code>&lt;p id=</code><code>"testJs"</code><code>&gt;&lt;/p&gt;</code></p> <p><code>    </code><code>&lt;/div&gt;</code></p> <p><code>&lt;/template&gt;</code></p> <p><code>&lt;script&gt;</code></p> <p><code>import {Person} from </code><code>'./testClass.js'</code><code>; </code></p> <p><code>export </code><code>default</code> <code>{  </code></p> <p><code>    </code><code>data() {<!-- --></code></p> <p><code>        </code><code>return</code> <code>{<!-- --></code></p> <p><code>        </code><code>}</code></p> <p><code>    </code><code>},</code></p> <p><code>    </code><code>mounted(){<!-- --></code></p> <p><code>        </code><code>let text=document.getElementById(</code><code>"testJs"</code><code>);</code></p> <p><code>        </code><code>//使用new的方式得到一个实例对象</code></p> <p><code>        </code><code>let person = </code><code>new</code> <code>Person(</code><code>'张三'</code><code>,12); </code></p> <p><code>        </code><code>text.innerHTML=person.toString();</code><code>//张三的年龄是12岁</code></p> <p><code>        </code><code>console.log(</code><code>typeof</code> <code>Person);</code><code>//function </code></p> <p><code>    </code><code>}</code></p> <p><code>}</code></p> <p><code>&lt;/script&gt;</code></p> </td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2edc24b172814908c51d8b4c023605b2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于日期相加减问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff1777f0925b13d687bebf8cebd73fb4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于wdk目录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>