<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>聊聊RedisTemplate的各种序列化器 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="聊聊RedisTemplate的各种序列化器" />
<meta property="og:description" content="[版权申明] 非商业目的注明出处可自由转载
出自：shusheng007
文章目录 概述序列化器作用和原理JDK 序列化方式多一点 String 序列化方式JSON 序列化方式 总结源码 概述 在SpringBoot中使用redis基本上都是通过Spring Data Redis，那就不得不说RedisTemplate了。在我刚接触它的时候比较懵逼的就是给其设置各种序列化器了，今天我们来唠唠他们。
序列化器 众所周知，使用RedisTemplate可以对Redis的各种数据结构进行操作，如下图所示。
作用和原理 那我们为什么需要序列化器呢，这是个啥玩意儿？
现在闭目思考一下我们是如何使用redis的？是不是先将数据存储在redis上，然后用的时候再读取出来？
那我们存储在redis里的内容是啥呢？有时是字符串，例如&#34;ShuSheng007&#34;，大部分时间是对象，例如Student、List&lt;Student&gt;、Map&lt;String,Student&gt;等等。这些个对象肯定是不能直接存储到redis上的，我们需要想办法先把它们转成byte[]后才能存储到redis上，这就是所谓的序列化。等用的时候还的把byte[]转化为相应的对象，这就是所谓的反序列化。序列化器就是完成这两个功能的。
下面是Spring中Redis序列化器的接口，从源码中可以非常清晰的看到它就干了这两个事情。
public interface RedisSerializer&lt;T&gt; { @Nullable byte[] serialize(@Nullable T t) throws SerializationException; @Nullable T deserialize(@Nullable byte[] bytes) throws SerializationException; } 之所以存在这么多序列化器，是因为我们可以通过各种方式将对象转为byte[]，也就是这个接口可以有各种实现类。总结一下，大概有如下几种：
JDK 序列化方式 （默认）String 序列化方式JSON 序列化方式XML 序列化方式 其中XML序列化器不怎么用，我们就忽略它吧。
在讲解各种序列化器之前我们应该先搞清楚RedisTemplate都有哪些地方需要设置序列化器。
public class RedisTemplate&lt;K, V&gt; extends RedisAccessor implements RedisOperations&lt;K, V&gt;, BeanClassLoaderAware { @SuppressWarnings(&#34;rawtypes&#34;) private @Nullable RedisSerializer keySerializer = null; @SuppressWarnings(&#34;rawtypes&#34;) private @Nullable RedisSerializer valueSerializer = null; @SuppressWarnings(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0e5c22026cf741c486af3e8e510d2e7d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-14T22:48:18+08:00" />
<meta property="article:modified_time" content="2023-08-14T22:48:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">聊聊RedisTemplate的各种序列化器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>[版权申明] 非商业目的注明出处可自由转载<br> 出自：shusheng007</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">概述</a></li><li><a href="#_7" rel="nofollow">序列化器</a></li><li><ul><li><a href="#_12" rel="nofollow">作用和原理</a></li><li><a href="#JDK__58" rel="nofollow">JDK 序列化方式</a></li><li><ul><li><a href="#_92" rel="nofollow">多一点</a></li></ul> 
   </li><li><a href="#String__103" rel="nofollow">String 序列化方式</a></li><li><a href="#JSON__113" rel="nofollow">JSON 序列化方式</a></li></ul> 
  </li><li><a href="#_181" rel="nofollow">总结</a></li><li><a href="#_186" rel="nofollow">源码</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_4"></a>概述</h2> 
<p>在SpringBoot中使用redis基本上都是通过<code>Spring Data Redis</code>，那就不得不说<code>RedisTemplate</code>了。在我刚接触它的时候比较懵逼的就是给其设置各种序列化器了，今天我们来唠唠他们。</p> 
<h2><a id="_7"></a>序列化器</h2> 
<p>众所周知，使用<code>RedisTemplate</code>可以对Redis的各种数据结构进行操作，如下图所示。</p> 
<p><img src="https://images2.imgbox.com/70/b0/nf2COrTk_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="_12"></a>作用和原理</h3> 
<p>那我们为什么需要序列化器呢，这是个啥玩意儿？</p> 
<p>现在闭目思考一下我们是如何使用redis的？是不是先将数据存储在redis上，然后用的时候再读取出来？</p> 
<p>那我们存储在redis里的内容是啥呢？有时是字符串，例如<code>"ShuSheng007"</code>，大部分时间是对象，例如<code>Student</code>、<code>List&lt;Student&gt;</code>、<code>Map&lt;String,Student&gt;</code>等等。这些个对象肯定是不能直接存储到redis上的，我们需要想办法先把它们转成<code>byte[]</code>后才能存储到redis上，这就是所谓的序列化。等用的时候还的把<code>byte[]</code>转化为相应的对象，这就是所谓的反序列化。序列化器就是完成这两个功能的。</p> 
<p>下面是Spring中Redis序列化器的接口，从源码中可以非常清晰的看到它就干了这两个事情。</p> 
<pre><code>public interface RedisSerializer&lt;T&gt; {

	@Nullable
	byte[] serialize(@Nullable T t) throws SerializationException;

	@Nullable
	T deserialize(@Nullable byte[] bytes) throws SerializationException;
}
</code></pre> 
<p>之所以存在这么多序列化器，是因为我们可以通过各种方式将对象转为<code>byte[]</code>，也就是这个接口可以有各种实现类。总结一下，大概有如下几种：</p> 
<ul><li>JDK 序列化方式 （默认）</li><li>String 序列化方式</li><li>JSON 序列化方式</li><li>XML 序列化方式</li></ul> 
<p>其中XML序列化器不怎么用，我们就忽略它吧。</p> 
<p>在讲解各种序列化器之前我们应该先搞清楚RedisTemplate都有哪些地方需要设置序列化器。</p> 
<pre><code>public class RedisTemplate&lt;K, V&gt; extends RedisAccessor implements RedisOperations&lt;K, V&gt;, BeanClassLoaderAware {

	@SuppressWarnings("rawtypes") private @Nullable RedisSerializer keySerializer = null;
	@SuppressWarnings("rawtypes") private @Nullable RedisSerializer valueSerializer = null;
	@SuppressWarnings("rawtypes") private @Nullable RedisSerializer hashKeySerializer = null;
	@SuppressWarnings("rawtypes") private @Nullable RedisSerializer hashValueSerializer = null;
	
}
</code></pre> 
<p>从上面的源码可以发现总共有四个地方需要设置序列化器。这个和Redis提供的数据结构有关，所以我们在往redis里面存放数据的时候有两种方式。一种是key/value形式，另一种就是 key/hashMap, 那个hashMap又是key/value形式, 所以一共有四个地方用到序列化器。</p> 
<p>key和hashKey一般都使用String序列化方式，有变化的一般是value和hashValue。</p> 
<h3><a id="JDK__58"></a>JDK 序列化方式</h3> 
<p>由 <code>JdkSerializationRedisSerializer</code>完成，它是默认序列化器，如果不手动设置就会使用它。它是利用Java自身提供的序列化方案来工作的，也就是说你要存放到redis中的数据必须是<strong>可序列化</strong>的，例如实现了<code>Serializable</code>接口。</p> 
<p>我们来实践一下，使用下面的代码就给<code>RedisTemplate</code>的value设置<code>JdkSerializationRedisSerializer</code></p> 
<pre><code>template.setKeySerializer(RedisSerializer.string());
template.setValueSerializer(RedisSerializer.java());
</code></pre> 
<p>我们有如下一个类</p> 
<pre><code>public class KeyValue implements Serializable {
    private String key;
    private Object value;
    ...
}
</code></pre> 
<p>将其保存到redis中</p> 
<pre><code>public void testRedisSerializer() {
    ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();
    valueOperations.set("object",new KeyValue("age",18));
}
</code></pre> 
<p>查看结果，你会发现value是人类不可读的样子</p> 
<pre><code>\xac\xed\x00\x05sr\x00.top.shusheng007.redisintegrate.domain.KeyValue\xb2\xf9\xec\xa5\xb5\x89\xb99\x02\x00\x02L\x00\x03keyt\x00\x12Ljava/lang/String;L\x00\x05valuet\x00\x12Ljava/lang/Object;xpt\x00\x03agesr\x00\x11java.lang.Integer...
</code></pre> 
<p>正是因为这个原因，外加跨平台问题导致其在生产中用的也比较少。</p> 
<h4><a id="_92"></a>多一点</h4> 
<p>如果在创建<code>JdkSerializationRedisSerializer</code>时传入一个<code>ClassLoader</code>，如果这个类加载器和你使用类的加载器是同一个的话，查询出的值可以直接转成对应的类型对象的。</p> 
<pre><code>//传入当前配置类的ClassLoader
template.setValueSerializer(RedisSerializer.java(getClass().getClassLoader()));

valueOperations.set("object",new KeyValue("age",18));
//从redis获取的值可以直接强转
KeyValue keyValue = (KeyValue) valueOperations.get("object");
</code></pre> 
<h3><a id="String__103"></a>String 序列化方式</h3> 
<p>由<code>StringRedisSerializer</code>完成，这个应该没什么可说的。一般情况下，key和hashKey都使用这个序列化器，它们两一般也就存放字符串。value和hashValue一般都不会设置为它，Spring Data Redis 单独提供了一个操作字符串的<code>StringRedisTemplate </code></p> 
<pre><code>public class StringRedisTemplate extends RedisTemplate&lt;String, String&gt; {
	...
}
</code></pre> 
<h3><a id="JSON__113"></a>JSON 序列化方式</h3> 
<p>由<code>GenericJackson2JsonRedisSerializer</code>或者<code>Jackson2JsonRedisSerializer</code>完成。我们一般将value和hashValue的序列化器设置为其中一个，用来以json的形式保存数据。那这两个有什么区别呢？</p> 
<ul><li>Jackson2JsonRedisSerializer</li></ul> 
<p>设置序列化器</p> 
<pre><code>Jackson2JsonRedisSerializer&lt;Object&gt; valuesSerializer2 = new Jackson2JsonRedisSerializer(Object.class);
template.setValueSerializer(valuesSerializer2);
</code></pre> 
<p>使用</p> 
<pre><code> valueOperations.set("object",new KeyValue("age",18));

 Object keyValue =  valueOperations.get("object");
 
 String clsName = keyValue.getClass().getCanonicalName();
 log.info("object:{},name:{}", keyValue,clsName);
</code></pre> 
<p>查看redis中value值，可见就是普通json格式</p> 
<pre><code>{
	"key": "age",
	"value": 18
}
</code></pre> 
<p>其中那个keyValue是一个<code>java.util.LinkedHashMap</code>类型，这个是java自动解析的类型。所以如果我们要将其解析成对应的类型的话就要借助与Jackson了。</p> 
<pre><code> ObjectMapper objectMapper = new ObjectMapper();
 KeyValue keyValue = objectMapper.convertValue(keyValue, KeyValue.class);
</code></pre> 
<ul><li>GenericJackson2JsonRedisSerializer</li></ul> 
<p>这个与<code>Jackson2JsonRedisSerializer</code>的区别是生成的json里携带了类信息，反序列化为同一个类的时候不需要借助于Jackson。但这也会产生新的问题，例如一个服务向redis里写数据，另一个服务取数据，但是他们的类信息不一样就无法反序列化了。</p> 
<p>设置序列化器</p> 
<pre><code>Jackson2JsonRedisSerializer&lt;Object&gt; valuesSerializer2 = new Jackson2JsonRedisSerializer(Object.class);
template.setValueSerializer(valueSerializer);
</code></pre> 
<p>使用，注意我们在反序列化的时候直接进行了强转。</p> 
<pre><code> valueOperations.set("object",new KeyValue("age",18));

 KeyValue keyValue = (KeyValue) valueOperations.get("object");

 String clsName = keyValue.getClass().getCanonicalName();
 log.info("object:{},name:{}", keyValue,clsName);
</code></pre> 
<p>查看redis中value值，可见多了一个<code>@class</code>信息，是在反序列时提供类型信息的。</p> 
<pre><code>{
	"@class": "top.shusheng007.redisintegrate.domain.KeyValue",
	"key": "age",
	"value": 18
}
</code></pre> 
<h2><a id="_181"></a>总结</h2> 
<p>通常<code>key/hashKey</code>使用字符串序列化器，<code>value/hashValue</code>使用Json序列化器。当服务自己存自己取的话使用<code>GenericJackson2JsonRedisSerializer</code>，但是如果取其他服务存储的Json值就要使用<code>Jackson2JsonRedisSerializer</code>。</p> 
<p>以上就是RedisRemplate的几个序列化器的总结。是不是感觉也没那么难了？小白面前的大山就是老鸟眼中的土坷垃。你回头看看你的经历，是不是很多当时感觉非常艰难的事情在你攻克他们后感觉也没那么难，而且还会感慨一句：这也没多难，为什么我当时就是不会呢？人生也是一样，当你回顾你的一生时大多遗憾的事情都是没有做的事情…</p> 
<h2><a id="_186"></a>源码</h2> 
<p>一如既往，你可以从首发找到源码 <a href="https://shusheng007.top/2023/08/11/redis-serializer/" rel="nofollow">redis-integration</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/578173ea8e98482699ea65e2564c6a54/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">全网小说下载器，只需书名，一键下载（Python爬虫&#43;tkinter 实现）小白实战案例系统教学！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/28a3763351b74b37b157e5b4ba377c04/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">idea控制台输出中文乱码解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>