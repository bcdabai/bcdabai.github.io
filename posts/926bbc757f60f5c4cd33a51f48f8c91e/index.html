<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity中用Shader实现镜子效果 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity中用Shader实现镜子效果" />
<meta property="og:description" content="做项目的时候要用到镜子，折腾了一下午，发现做镜子还是蛮快的，总结了一下网上的教程，大致有这么几种做法：
1、使用反射探针（Reflection Probe）
2、使用Render Texture
3、使用Shader着色器，我发现这种方法步骤比较少，而且重复使用起来也方便
下面就介绍一下这个方法，以及期间我踩过的坑；官方的教程在这里：MirrorReflection4
（我之所以说比较简单，是因为Shader方法可以用网上现成的代码，基本不用改
话不多说进入正题：
首先利用Shader做镜子，需要两段代码，一个是.shader着色器代码，另一个是C#脚本代码
着色器代码如下：
Mirror.shader Shader &#34;FX/MirrorReflection&#34; { Properties { _MainTex (&#34;Base (RGB)&#34;, 2D) = &#34;white&#34; {} [HideInInspector] _ReflectionTex (&#34;&#34;, 2D) = &#34;white&#34; {} } SubShader { Tags { &#34;RenderType&#34;=&#34;Opaque&#34; } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include &#34;UnityCG.cginc&#34; struct v2f { float2 uv : TEXCOORD0; float4 refl : TEXCOORD1; float4 pos : SV_POSITION; }; float4 _MainTex_ST; v2f vert(float4 pos : POSITION, float2 uv : TEXCOORD0) { v2f o; o." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/926bbc757f60f5c4cd33a51f48f8c91e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-03T15:12:53+08:00" />
<meta property="article:modified_time" content="2019-11-03T15:12:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity中用Shader实现镜子效果</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>做项目的时候要用到镜子，折腾了一下午，发现做镜子还是蛮快的，总结了一下网上的教程，大致有这么几种做法：</p> 
<p>1、使用反射探针（Reflection Probe）</p> 
<p>2、使用Render Texture</p> 
<p>3、使用Shader着色器，我发现这种方法步骤比较少，而且重复使用起来也方便</p> 
<p>下面就介绍一下这个方法，以及期间我踩过的坑；官方的教程在这里：MirrorReflection4</p> 
<p>（我之所以说比较简单，是因为Shader方法可以用网上现成的代码，基本不用改</p> 
<p>话不多说进入正题：</p> 
<p>首先利用Shader做镜子，需要两段代码，一个是.shader着色器代码，另一个是C#脚本代码</p> 
<p>着色器代码如下：</p> 
<h3>Mirror.shader</h3> 
<pre class="has"><code>Shader "FX/MirrorReflection"
{
	Properties
	{
		_MainTex ("Base (RGB)", 2D) = "white" {}
		[HideInInspector] _ReflectionTex ("", 2D) = "white" {}
	}
	SubShader
	{
		Tags { "RenderType"="Opaque" }
		LOD 100
 
		Pass {
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			#include "UnityCG.cginc"
			struct v2f
			{
				float2 uv : TEXCOORD0;
				float4 refl : TEXCOORD1;
				float4 pos : SV_POSITION;
			};
			float4 _MainTex_ST;
			v2f vert(float4 pos : POSITION, float2 uv : TEXCOORD0)
			{
				v2f o;
				o.pos = mul (UNITY_MATRIX_MVP, pos);
				o.uv = TRANSFORM_TEX(uv, _MainTex);
				o.refl = ComputeScreenPos (o.pos);
				return o;
			}
			sampler2D _MainTex;
			sampler2D _ReflectionTex;
			fixed4 frag(v2f i) : SV_Target
			{
				fixed4 tex = tex2D(_MainTex, i.uv);
				fixed4 refl = tex2Dproj(_ReflectionTex, UNITY_PROJ_COORD(i.refl));
				return tex * refl;
			}
			ENDCG
	    }
	}
}
</code></pre> 
<p>C#脚本代码如下：</p> 
<h3><a name="t1"></a>MirrorReflection.cs</h3> 
<pre class="has"><code>using UnityEngine;
using System.Collections;
 
// This is in fact just the Water script from Pro Standard Assets,
// just with refraction stuff removed.
 
[ExecuteInEditMode] // Make mirror live-update even when not in play mode
public class MirrorReflection : MonoBehaviour
{
	public bool m_DisablePixelLights = true;
	public int m_TextureSize = 256;
	public float m_ClipPlaneOffset = 0.07f;
 
	public LayerMask m_ReflectLayers = -1;
 
	private Hashtable m_ReflectionCameras = new Hashtable(); // Camera -&gt; Camera table
 
	private RenderTexture m_ReflectionTexture = null;
	private int m_OldReflectionTextureSize = 0;
 
	private static bool s_InsideRendering = false;
 
	// This is called when it's known that the object will be rendered by some
	// camera. We render reflections and do other updates here.
	// Because the script executes in edit mode, reflections for the scene view
	// camera will just work!
	public void OnWillRenderObject()
	{
		var rend = GetComponent&lt;Renderer&gt;();
		if (!enabled || !rend || !rend.sharedMaterial || !rend.enabled)
			return;
 
		Camera cam = Camera.current;
		if( !cam )
			return;
 
		// Safeguard from recursive reflections.        
		if( s_InsideRendering )
			return;
		s_InsideRendering = true;
 
		Camera reflectionCamera;
		CreateMirrorObjects( cam, out reflectionCamera );
 
		// find out the reflection plane: position and normal in world space
		Vector3 pos = transform.position;
		Vector3 normal = transform.up;
 
		// Optionally disable pixel lights for reflection
		int oldPixelLightCount = QualitySettings.pixelLightCount;
		if( m_DisablePixelLights )
			QualitySettings.pixelLightCount = 0;
 
		UpdateCameraModes( cam, reflectionCamera );
 
		// Render reflection
		// Reflect camera around reflection plane
		float d = -Vector3.Dot (normal, pos) - m_ClipPlaneOffset;
		Vector4 reflectionPlane = new Vector4 (normal.x, normal.y, normal.z, d);
 
		Matrix4x4 reflection = Matrix4x4.zero;
		CalculateReflectionMatrix (ref reflection, reflectionPlane);
		Vector3 oldpos = cam.transform.position;
		Vector3 newpos = reflection.MultiplyPoint( oldpos );
		reflectionCamera.worldToCameraMatrix = cam.worldToCameraMatrix * reflection;
 
		// Setup oblique projection matrix so that near plane is our reflection
		// plane. This way we clip everything below/above it for free.
		Vector4 clipPlane = CameraSpacePlane( reflectionCamera, pos, normal, 1.0f );
		//Matrix4x4 projection = cam.projectionMatrix;
		Matrix4x4 projection = cam.CalculateObliqueMatrix(clipPlane);
		reflectionCamera.projectionMatrix = projection;
 
		reflectionCamera.cullingMask = ~(1&lt;&lt;4) &amp; m_ReflectLayers.value; // never render water layer
		reflectionCamera.targetTexture = m_ReflectionTexture;
		GL.SetRevertBackfacing (true);
		reflectionCamera.transform.position = newpos;
		Vector3 euler = cam.transform.eulerAngles;
		reflectionCamera.transform.eulerAngles = new Vector3(0, euler.y, euler.z);
		reflectionCamera.Render();
		reflectionCamera.transform.position = oldpos;
		GL.SetRevertBackfacing (false);
		Material[] materials = rend.sharedMaterials;
		foreach( Material mat in materials ) {
			if( mat.HasProperty("_ReflectionTex") )
				mat.SetTexture( "_ReflectionTex", m_ReflectionTexture );
		}
 
		// Restore pixel light count
		if( m_DisablePixelLights )
			QualitySettings.pixelLightCount = oldPixelLightCount;
 
		s_InsideRendering = false;
	}
 
 
	// Cleanup all the objects we possibly have created
	void OnDisable()
	{
		if( m_ReflectionTexture ) {
			DestroyImmediate( m_ReflectionTexture );
			m_ReflectionTexture = null;
		}
		foreach( DictionaryEntry kvp in m_ReflectionCameras )
			DestroyImmediate( ((Camera)kvp.Value).gameObject );
		m_ReflectionCameras.Clear();
	}
 
 
	private void UpdateCameraModes( Camera src, Camera dest )
	{
		if( dest == null )
			return;
		// set camera to clear the same way as current camera
		dest.clearFlags = src.clearFlags;
		dest.backgroundColor = src.backgroundColor;        
		if( src.clearFlags == CameraClearFlags.Skybox )
		{
			Skybox sky = src.GetComponent(typeof(Skybox)) as Skybox;
			Skybox mysky = dest.GetComponent(typeof(Skybox)) as Skybox;
			if( !sky || !sky.material )
			{
				mysky.enabled = false;
			}
			else
			{
				mysky.enabled = true;
				mysky.material = sky.material;
			}
		}
		// update other values to match current camera.
		// even if we are supplying custom camera&amp;projection matrices,
		// some of values are used elsewhere (e.g. skybox uses far plane)
		dest.farClipPlane = src.farClipPlane;
		dest.nearClipPlane = src.nearClipPlane;
		dest.orthographic = src.orthographic;
		dest.fieldOfView = src.fieldOfView;
		dest.aspect = src.aspect;
		dest.orthographicSize = src.orthographicSize;
	}
 
	// On-demand create any objects we need
	private void CreateMirrorObjects( Camera currentCamera, out Camera reflectionCamera )
	{
		reflectionCamera = null;
 
		// Reflection render texture
		if( !m_ReflectionTexture || m_OldReflectionTextureSize != m_TextureSize )
		{
			if( m_ReflectionTexture )
				DestroyImmediate( m_ReflectionTexture );
			m_ReflectionTexture = new RenderTexture( m_TextureSize, m_TextureSize, 16 );
			m_ReflectionTexture.name = "__MirrorReflection" + GetInstanceID();
			m_ReflectionTexture.isPowerOfTwo = true;
			m_ReflectionTexture.hideFlags = HideFlags.DontSave;
			m_OldReflectionTextureSize = m_TextureSize;
		}
 
		// Camera for reflection
		reflectionCamera = m_ReflectionCameras[currentCamera] as Camera;
		if( !reflectionCamera ) // catch both not-in-dictionary and in-dictionary-but-deleted-GO
		{
			GameObject go = new GameObject( "Mirror Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox) );
			reflectionCamera = go.camera;
			reflectionCamera.enabled = false;
			reflectionCamera.transform.position = transform.position;
			reflectionCamera.transform.rotation = transform.rotation;
			reflectionCamera.gameObject.AddComponent("FlareLayer");
			go.hideFlags = HideFlags.HideAndDontSave;
			m_ReflectionCameras[currentCamera] = reflectionCamera;
		}        
	}
 
	// Extended sign: returns -1, 0 or 1 based on sign of a
	private static float sgn(float a)
	{
		if (a &gt; 0.0f) return 1.0f;
		if (a &lt; 0.0f) return -1.0f;
		return 0.0f;
	}
 
	// Given position/normal of the plane, calculates plane in camera space.
	private Vector4 CameraSpacePlane (Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 offsetPos = pos + normal * m_ClipPlaneOffset;
		Matrix4x4 m = cam.worldToCameraMatrix;
		Vector3 cpos = m.MultiplyPoint( offsetPos );
		Vector3 cnormal = m.MultiplyVector( normal ).normalized * sideSign;
		return new Vector4( cnormal.x, cnormal.y, cnormal.z, -Vector3.Dot(cpos,cnormal) );
	}
 
	// Calculates reflection matrix around the given plane
	private static void CalculateReflectionMatrix (ref Matrix4x4 reflectionMat, Vector4 plane)
	{
		reflectionMat.m00 = (1F - 2F*plane[0]*plane[0]);
		reflectionMat.m01 = (   - 2F*plane[0]*plane[1]);
		reflectionMat.m02 = (   - 2F*plane[0]*plane[2]);
		reflectionMat.m03 = (   - 2F*plane[3]*plane[0]);
 
		reflectionMat.m10 = (   - 2F*plane[1]*plane[0]);
		reflectionMat.m11 = (1F - 2F*plane[1]*plane[1]);
		reflectionMat.m12 = (   - 2F*plane[1]*plane[2]);
		reflectionMat.m13 = (   - 2F*plane[3]*plane[1]);
 
		reflectionMat.m20 = (   - 2F*plane[2]*plane[0]);
		reflectionMat.m21 = (   - 2F*plane[2]*plane[1]);
		reflectionMat.m22 = (1F - 2F*plane[2]*plane[2]);
		reflectionMat.m23 = (   - 2F*plane[3]*plane[2]);
 
		reflectionMat.m30 = 0F;
		reflectionMat.m31 = 0F;
		reflectionMat.m32 = 0F;
		reflectionMat.m33 = 1F;
	}
}
</code></pre> 
<h4>下面说说该如何使用这两段代码：</h4> 
<p>1、首先我们搭建一个简单的场景，这里我放了一些小方块和球之类的</p> 
<p><img alt="" class="has" height="283" src="https://images2.imgbox.com/54/2a/DJ67AHFz_o.png" width="350"></p> 
<p>然后再创建一个平面，一会儿用来做镜子</p> 
<p><img alt="" class="has" height="264" src="https://images2.imgbox.com/1e/53/agidPxeI_o.png" width="350"></p> 
<p>2、在Project中创建一个Shader</p> 
<p><img alt="" class="has" height="253" src="https://images2.imgbox.com/6b/ab/Aj3fCXgB_o.png" width="534"></p> 
<p>然后重命名一下并打开，原来的代码可以全删掉，把上面的Mirror.Shader代码复制进去</p> 
<p><img alt="" class="has" height="169" src="https://images2.imgbox.com/92/02/5rma8UTQ_o.png" width="278"></p> 
<p><img alt="" class="has" height="297" src="https://images2.imgbox.com/e0/41/AMwR6JGj_o.png" width="570"></p> 
<p> </p> 
<p>保存，回到Unity</p> 
<p>接下来新建一个脚本MirrorReflection，将上面MirrorReflection.cs中的脚本复制进去</p> 
<p><img alt="" class="has" height="145" src="https://images2.imgbox.com/7c/eb/eAo1U4eD_o.png" width="299"></p> 
<p><img alt="" class="has" height="252" src="https://images2.imgbox.com/86/44/D6zMutQf_o.png" width="683"></p> 
<p>注意：因为版本问题，脚本可能会有一些错误，我用的版本是2018.2.14，</p> 
<p>这些错误多半是因为版本的更新导致的API改动，根据相应的修改提示，改用新的API，问题解决；</p> 
<p>以下时候我改过后的截图：</p> 
<p><img alt="" class="has" height="227" src="https://images2.imgbox.com/40/b7/ONV1Y0k1_o.png" width="683"></p> 
<p>3、在Project中新建一个材质Material，将这个材质的Shader设置成FX/MirrorReflection</p> 
<p><img alt="" class="has" height="299" src="https://images2.imgbox.com/b9/0e/2OYbSaGp_o.png" width="505"></p> 
<p>4、将MirrorMaterial材质、MirrorReflection脚本 挂在Mirror也就是刚刚用来做镜子的平面上</p> 
<p><img alt="" class="has" height="369" src="https://images2.imgbox.com/f7/03/J6c6OPPa_o.png" width="361"></p> 
<p>完成以后的属性视图：</p> 
<p><img alt="" class="has" height="547" src="https://images2.imgbox.com/e8/a5/JPIR4Y2J_o.png" width="361"></p> 
<p>5、回到场景视图：</p> 
<p><img alt="" class="has" height="354" src="https://images2.imgbox.com/09/76/KkTUc4nP_o.png" width="368"></p> 
<p>效果有了，就是镜子很模糊？</p> 
<p>别急，刚刚的脚本里给我们提供了一个分辨率的设置参数，我们把它调大一点就好了</p> 
<p><img alt="" class="has" height="506" src="https://images2.imgbox.com/84/e0/5z8vL1u9_o.png" width="334"></p> 
<p>这里我设置了1024，这样一面清晰的镜子就完成了！</p> 
<p><img alt="" class="has" height="411" src="https://images2.imgbox.com/0b/19/4Cv3UoLo_o.png" width="384"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/39e7fb616ce0e3370525678c06d2be42/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kong 系列 -- Kong 101</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a216fccf4f0f034d582e710e165e8754/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">节流、防抖及使用场景</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>