<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>流程图拖拽视觉编程-流程编辑器2 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="流程图拖拽视觉编程-流程编辑器2" />
<meta property="og:description" content="目录
一、简介
二、自定义图元
2.1图元设计
2.2 端口QNEPort
2.3节点块QNEBlock
一、简介 前期文章：
流程图拖拽视觉编程--概述_Jason~shen的博客-CSDN博客
流程图拖拽视觉编程-流程编辑器_Jason~shen的博客-CSDN博客
本期内容：
本期将继续介绍流程编辑器模块的实现方法，前面介绍了视图的实现，现在介绍自定义图元的实现，即流程图中每个节点块、端口和连接线。
二、自定义图元 该部分基于QGraphicsItem 图元类实现，该类提供了一些基本的图形元件，可在此基础上自定义图元。
2.1图元设计 开始：圆角矩形 &#43; 1个输出端口
结束：圆角矩形 &#43; 1个输入端口
程序块：矩形 &#43; 1个输入端口 &#43; 1个输出端口
条件：菱形 &#43; 1个输入端口 &#43; 1个为真端口 &#43; 1个为假端口
循环：菱形 &#43; 1个输入端口 &#43; 2个循环体端口 （左&#43;下）&#43; 1个退出循环端口（右）
流程线：带箭头的直线或者折线
2.2 端口QNEPort 继承QGraphicsPathItem，设置为圆形
QPainterPath p; p.addEllipse(-radius_, -radius_, 2 * radius_, 2 * radius_); setPath(p); #ifndef QNEPORT_H #define QNEPORT_H #include &lt;QGraphicsPathItem&gt; #include &#34;floweditor_global.h&#34; class QNEBlock; class QNEConnection; /* 端口 */ class FLOWEDITORSHARED_EXPORT QNEPort : public QGraphicsPathItem { public: enum { Type = QGraphicsItem::UserType &#43; 1 }; enum E_Direction {TOP = 0, BOTTOM = 1, LEFT = 2, RIGHT = 3}; QNEPort(QGraphicsItem *parent = 0); ~QNEPort(); void setDirection(const E_Direction &amp;dir); E_Direction direction(); void setOutput(bool b); bool isOutput() const; void setNEBlock(QNEBlock *); QNEBlock *block() const; int radius(); QVector&lt;QNEConnection *&gt; &amp;connections(); bool isConnected(QNEPort *); int type() const { return Type; } protected: QVariant itemChange(GraphicsItemChange change, const QVariant &amp;value); private: QNEBlock *m_block; int radius_; bool m_isOutput; E_Direction m_directtion; QVector&lt;QNEConnection *&gt; m_connections; }; #endif // QNEPORT_H #include &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d3c78b7d1f3f3bc39312b22251ad2ebf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-27T20:53:32+08:00" />
<meta property="article:modified_time" content="2023-04-27T20:53:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">流程图拖拽视觉编程-流程编辑器2</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B" rel="nofollow">一、简介</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%85%83-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%85%83" rel="nofollow">二、自定义图元</a></p> 
<p id="2.1%E5%9B%BE%E5%85%83%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#2.1%E5%9B%BE%E5%85%83%E8%AE%BE%E8%AE%A1" rel="nofollow">2.1图元设计</a></p> 
<p id="%C2%A02.2%20%E7%AB%AF%E5%8F%A3QNEPort-toc" style="margin-left:40px;"><a href="#%C2%A02.2%20%E7%AB%AF%E5%8F%A3QNEPort" rel="nofollow">2.2 端口QNEPort</a></p> 
<p id="2.3%E8%8A%82%E7%82%B9%E5%9D%97QNEBlock-toc" style="margin-left:40px;"><a href="#2.3%E8%8A%82%E7%82%B9%E5%9D%97QNEBlock" rel="nofollow">2.3节点块QNEBlock</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B">一、简介</h2> 
<p>前期文章：</p> 
<p><a href="https://blog.csdn.net/qq_40602000/article/details/130275221" title="流程图拖拽视觉编程--概述_Jason~shen的博客-CSDN博客">流程图拖拽视觉编程--概述_Jason~shen的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/qq_40602000/article/details/130414389" title="流程图拖拽视觉编程-流程编辑器_Jason~shen的博客-CSDN博客">流程图拖拽视觉编程-流程编辑器_Jason~shen的博客-CSDN博客</a></p> 
<p></p> 
<p>本期内容：</p> 
<p>本期将继续介绍流程编辑器模块的实现方法，前面介绍了视图的实现，现在介绍自定义图元的实现，即流程图中每个节点块、端口和连接线。</p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/ad/e8/aHiVd6Sg_o.png" width="595"></p> 
<h2 id="%C2%A0%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%85%83">二、自定义图元</h2> 
<p>该部分基于QGraphicsItem 图元类实现，该类提供了一些基本的图形元件，可在此基础上自定义图元。</p> 
<h3 id="2.1%E5%9B%BE%E5%85%83%E8%AE%BE%E8%AE%A1">2.1图元设计</h3> 
<p>开始：圆角矩形 + 1个输出端口</p> 
<p><img alt="" height="176" src="https://images2.imgbox.com/fc/a0/iV6xetmg_o.png" width="417"></p> 
<p>结束：圆角矩形 + 1个输入端口</p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/7c/f9/FPRuS9Yn_o.png" width="416"></p> 
<p>程序块：矩形 + 1个输入端口 + 1个输出端口</p> 
<p><img alt="" height="161" src="https://images2.imgbox.com/8f/a5/iHVlYGNT_o.png" width="419"></p> 
<p>条件：菱形 + 1个输入端口 + 1个为真端口 + 1个为假端口</p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/0b/88/VcPueRbi_o.png" width="444"> </p> 
<p>循环：菱形 + 1个输入端口 + 2个循环体端口 （左+下）+ 1个退出循环端口（右）</p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/31/52/NXUrwKqC_o.png" width="441"></p> 
<p>流程线：带箭头的直线或者折线</p> 
<p><img alt="" height="128" src="https://images2.imgbox.com/ec/b3/rzHP7C3t_o.png" width="354"></p> 
<h3 id="%C2%A02.2%20%E7%AB%AF%E5%8F%A3QNEPort"> 2.2 端口QNEPort</h3> 
<p>继承QGraphicsPathItem，设置为圆形</p> 
<pre><code class="language-cpp">QPainterPath p;
p.addEllipse(-radius_, -radius_, 2 * radius_, 2 * radius_);
setPath(p);</code></pre> 
<pre><code class="language-cpp">#ifndef QNEPORT_H
#define QNEPORT_H

#include &lt;QGraphicsPathItem&gt;
#include "floweditor_global.h"

class QNEBlock;
class QNEConnection;

/* 端口 */
class FLOWEDITORSHARED_EXPORT QNEPort : public QGraphicsPathItem
{
public:
    enum { Type = QGraphicsItem::UserType + 1 };
    enum E_Direction {TOP = 0, BOTTOM = 1, LEFT = 2, RIGHT = 3};

    QNEPort(QGraphicsItem *parent = 0);
    ~QNEPort();

    void setDirection(const E_Direction &amp;dir);
    E_Direction direction();

    void setOutput(bool b);
    bool isOutput() const;

    void setNEBlock(QNEBlock *);
    QNEBlock *block() const;

    int radius();

    QVector&lt;QNEConnection *&gt; &amp;connections();
    bool isConnected(QNEPort *);

    int type() const
    {
        return Type;
    }
protected:
    QVariant itemChange(GraphicsItemChange change, const QVariant &amp;value);

private:
    QNEBlock *m_block;
    int radius_;
    bool m_isOutput;
    E_Direction m_directtion;
    QVector&lt;QNEConnection *&gt; m_connections;
};

#endif // QNEPORT_H
</code></pre> 
<pre><code class="language-cpp">#include "NEPort.h"

#include &lt;QGraphicsScene&gt;
#include &lt;QFontMetrics&gt;
#include &lt;QPen&gt;
#include &lt;QDebug&gt;

#include "NEConnection.h"

QNEPort::QNEPort(QGraphicsItem *parent):
    QGraphicsPathItem(parent), m_isOutput(false)
{
    radius_ = 5;

    QPainterPath p;
    p.addEllipse(-radius_, -radius_, 2 * radius_, 2 * radius_);
    setPath(p);

    setPen(QPen(Qt::darkRed));
    setBrush(Qt::red);

    setFlag(QGraphicsItem::ItemSendsScenePositionChanges);
}

QNEPort::~QNEPort()
{
    foreach(QNEConnection *conn, m_connections)
    {
        delete conn;
    }
}

void QNEPort::setDirection(const QNEPort::E_Direction &amp;dir)
{
    m_directtion = dir;
}

QNEPort::E_Direction QNEPort::direction()
{
    return m_directtion;
}

void QNEPort::setOutput(bool b)
{
    m_isOutput = b;
}

bool QNEPort::isOutput() const
{
    return m_isOutput;
}

void QNEPort::setNEBlock(QNEBlock *b)
{
    m_block = b;
}

QNEBlock *QNEPort::block() const
{
    return m_block;
}

int QNEPort::radius()
{
    return radius_;
}

QVector&lt;QNEConnection *&gt; &amp;QNEPort::connections()
{
    return m_connections;
}


bool QNEPort::isConnected(QNEPort *other)
{
    qDebug() &lt;&lt; "m_connections" &lt;&lt; m_connections.size();
    foreach(QNEConnection *conn, m_connections)
        if (conn-&gt;port1() == other || conn-&gt;port2() == other)
        {
            return true;
        }
    return false;
}

QVariant QNEPort::itemChange(GraphicsItemChange change, const QVariant &amp;value)
{
    if (change == GraphicsItemChange::ItemScenePositionHasChanged)
    {
        foreach(QNEConnection *conn, m_connections)
        {
            conn-&gt;updatePosFromPorts();
            conn-&gt;updatePath();
        }
    }
    return value;
}
</code></pre> 
<h3 id="2.3%E8%8A%82%E7%82%B9%E5%9D%97QNEBlock">2.3节点块QNEBlock</h3> 
<p>继承QGraphicsPathItem</p> 
<pre><code class="language-cpp">#ifndef QNEBLOCK_H
#define QNEBLOCK_H

#include &lt;QFont&gt;
#include &lt;QGraphicsPathItem&gt;
#include "floweditor_global.h"
#include "TypeDefine.h"

class QNEPort;
class QNEConnection;
USE_NAMESPACE_FLOWEDITOR

class FLOWEDITORSHARED_EXPORT QNEBlock : public QGraphicsPathItem
{
public:
    enum { Type = QGraphicsItem::UserType + 3 };

    QNEBlock(QGraphicsItem *parent = 0);

    void setUuid(const QString &amp;uuid);
    QString uuid() const;

    void setName(const QString &amp;name);
    QString name() const;

    void setNodeType(const E_NodeType &amp;type);
    E_NodeType nodeType() const;
    void initBlockByType();

    void setData(const QVariant &amp;data);
    QVariant data() const;

    void setPixmap(const QPixmap &amp;pm);
    void setInitData(const E_NodeType type);

    QMap&lt;QString, QStringList&gt; getNodeStrMap();

    /* 保存加载 */
    void save(T_NodeInfo &amp;);
    void load(const T_NodeInfo &amp;);

    /* 克隆 */
    QNEBlock *clone(int max_uuid);
    QNEBlock *clone(QString uuid_str);

    /* 获得相连的block */
    QNEBlock *getNextBlock(int dir);

    /* 端口 */
    QVector&lt;QNEPort *&gt; ports();
    QNEPort *port(int direction);

    int type() const
    {
        return Type;
    }

    inline int width() const
    {
        return m_width;
    }

    inline int height() const
    {
        return m_height;
    }

    inline QPointF center() const
    {
        return QPointF(m_width / 2, m_height / 2);
    }

protected:
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);
    QVariant itemChange(GraphicsItemChange change, const QVariant &amp;value);

private:
    int m_width;
    int m_height;
    E_NodeType m_nodeType;
    QVariant m_data;         /**&lt;  携带数据 */
    QString m_uuid;          /**&lt;  唯一识别码 */
    QString m_name;          /**&lt;  名称 */
    QList&lt;QNEPort *&gt; m_nePortList;
    QFont m_font;
    QPixmap m_pixmap;
    T_NodeInfo m_ni;
    bool m_bIsDrawPixmap;
};

#endif // QNEBLOCK_H
</code></pre> 
<p>设置路径：QPainterPath， 根据类型添加不同的形状，添加圆角矩形addRoundedRect、添加菱形addPolygon</p> 
<p>添加端口：QNEBlock和QNEPort绑定为父子关系new QNEPort(this)，QNEBlock位置移动时QNEPort也会跟随移动</p> 
<pre><code class="language-cpp">void QNEBlock::initBlockByType()
{
    QPainterPath p;
    if(E_NodeType::Start == m_nodeType)
    {
        /* 圆角矩形 */
        p.addRoundedRect(0, 0, m_width, m_height, m_height / 2, m_height / 2);
        // 下
        QNEPort *port = new QNEPort(this);
        port-&gt;setPos(m_width / 2, m_height);
        port-&gt;setNEBlock(this);
        port-&gt;setOutput(true);
        port-&gt;setToolTip("Out");
        port-&gt;setDirection(QNEPort::BOTTOM);
    }
    else if(E_NodeType::End == m_nodeType)
    {
        /* 圆角矩形 */
        p.addRoundedRect(0, 0, m_width, m_height, m_height / 2, m_height / 2);
        // 上
        QNEPort *port = new QNEPort(this);
        port-&gt;setPos(m_width / 2, 0);
        port-&gt;setNEBlock(this);
        port-&gt;setOutput(false);
        port-&gt;setToolTip("In");
        port-&gt;setDirection(QNEPort::TOP);
    }
    else if(E_NodeType::Judge == m_nodeType)
    {
        /* 菱形 */
        QPolygonF polygonf;
        polygonf &lt;&lt; QPointF(0, m_height / 2)
                 &lt;&lt; QPointF(m_width / 2, m_height)
                 &lt;&lt; QPointF(m_width, m_height / 2)
                 &lt;&lt; QPointF(m_width / 2, 0)
                 &lt;&lt; QPointF(0, m_height / 2);
        p.addPolygon(polygonf);

        // 上
        QNEPort *port = new QNEPort(this);
        port-&gt;setPos(m_width / 2, 0);
        port-&gt;setNEBlock(this);
        port-&gt;setOutput(false);
        port-&gt;setToolTip("In");
        port-&gt;setDirection(QNEPort::TOP);

        // 右
        port = new QNEPort(this);
        port-&gt;setPos(m_width, m_height / 2);
        port-&gt;setNEBlock(this);
        port-&gt;setOutput(true);
        port-&gt;setToolTip("Out");
        port-&gt;setDirection(QNEPort::RIGHT);

        // 下
        port = new QNEPort(this);
        port-&gt;setPos(m_width / 2, m_height);
        port-&gt;setNEBlock(this);
        port-&gt;setOutput(true);
        port-&gt;setToolTip("Out");
        port-&gt;setDirection(QNEPort::BOTTOM);
    }
    else if(E_NodeType::Loop == m_nodeType)
    {
        /* 菱形 */
        QPolygonF polygonf;
        polygonf &lt;&lt; QPointF(0, m_height / 2)
                 &lt;&lt; QPointF(m_width / 2, m_height)
                 &lt;&lt; QPointF(m_width, m_height / 2)
                 &lt;&lt; QPointF(m_width / 2, 0)
                 &lt;&lt; QPointF(0, m_height / 2);
        p.addPolygon(polygonf);

        // 上
        QNEPort *port = new QNEPort(this);
        port-&gt;setPos(m_width / 2, 0);
        port-&gt;setNEBlock(this);
        port-&gt;setOutput(false);
        port-&gt;setToolTip("In");
        port-&gt;setDirection(QNEPort::TOP);

        // 右
        port = new QNEPort(this);
        port-&gt;setPos(m_width, m_height / 2);
        port-&gt;setNEBlock(this);
        port-&gt;setOutput(true);
        port-&gt;setToolTip("Out");
        port-&gt;setDirection(QNEPort::RIGHT);

        // 下
        port = new QNEPort(this);
        port-&gt;setPos(m_width / 2, m_height);
        port-&gt;setNEBlock(this);
        port-&gt;setOutput(true);
        port-&gt;setToolTip("Out");
        port-&gt;setDirection(QNEPort::BOTTOM);

        // 左
        port = new QNEPort(this);
        port-&gt;setPos(0, m_height / 2);
        port-&gt;setNEBlock(this);
        port-&gt;setOutput(false);
        port-&gt;setToolTip("In");
        port-&gt;setDirection(QNEPort::LEFT);
    }
    else
    {
        /* 圆角矩形 */
        p.addRoundedRect(0, 0, m_width, m_height, 5, 5);

        // 上
        QNEPort *port = new QNEPort(this);
        port-&gt;setPos(m_width / 2, 0);
        port-&gt;setNEBlock(this);
        port-&gt;setOutput(false);
        port-&gt;setToolTip("In");
        port-&gt;setDirection(QNEPort::TOP);

        // 下
        port = new QNEPort(this);
        port-&gt;setPos(m_width / 2, m_height);
        port-&gt;setNEBlock(this);
        port-&gt;setOutput(true);
        port-&gt;setToolTip("Out");
        port-&gt;setDirection(QNEPort::BOTTOM);
        m_bIsDrawPixmap = true;
    }
    setPath(p);
}</code></pre> 
<p>重写绘图函数paint(), 选中时端口显示port<em>-&gt;show()，未选中时端口隐藏port</em>-&gt;hide()，绘制路径drawPath、图片drawPixmap、文字drawText</p> 
<pre><code class="language-cpp">void QNEBlock::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(option)
    Q_UNUSED(widget)

    if (isSelected())
    {
        painter-&gt;setPen(QPen(Qt::darkYellow));
        painter-&gt;setBrush(Qt::yellow);

        foreach(QGraphicsItem *port_, childItems())
        {
            if (port_-&gt;type() == QNEPort::Type)
            {
                port_-&gt;show();
            }
        }
    }
    else
    {
        painter-&gt;setPen(QPen(Qt::darkGreen));
        painter-&gt;setBrush(Qt::green);
        foreach(QGraphicsItem *port_, childItems())
        {
            if (port_-&gt;type() == QNEPort::Type)
            {
                port_-&gt;hide();
            }
        }
    }

    painter-&gt;drawPath(path());

    if(m_bIsDrawPixmap &amp;&amp; !m_pixmap.isNull())
    {
        QRect rect(m_height * 0.25, m_height * 0.25, m_height * 0.5, m_height * 0.5);
        painter-&gt;drawPixmap(rect, m_pixmap);
    }

    if(!m_name.isEmpty())
    {
        painter-&gt;setPen(QPen(Qt::black));
        painter-&gt;setBrush(Qt::BrushStyle::NoBrush);
        painter-&gt;setFont(m_font);
        QTextOption option(Qt::AlignCenter);
        option.setWrapMode(QTextOption::WordWrap);
        painter-&gt;drawText(boundingRect(), m_uuid + m_name, option);
    }
}</code></pre> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d33131be3c786832c925a64017ff6652/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">魔兽世界服务端用户注册以及网页的搭建教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c005b4ece8c3f409234ace52b8b4df88/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于SpringBoot的线上日志阅读器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>