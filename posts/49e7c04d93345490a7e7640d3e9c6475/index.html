<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构|一道还蛮有意思的链表题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构|一道还蛮有意思的链表题" />
<meta property="og:description" content="最近在二刷数据结构，也偶尔去刷一下Leetcode上的算法题，不过感觉自己还是太菜了，一道题经常憋半个小时一个小时，有时候也有用例死活过不去的情况（手动狗头），还是要多学习多看书多刷题，有机会也会把自己的一些刷题心得放在上面。
前几天把以前做过的一些数据结构题又拿出来看了一下，有这么一道题：
/*键盘输入英语单词的个数n及n个单词，编一程序，建立一个单向链表，实现： （1）如果单词重复出现，则只在链表上保留一个。 （2）除满足（1）的要求外。链表结点还应有一个计数域，记录该单词重复出现的次数，然后输出出现次数最多的前k(k&lt;=n，需键盘输入)个单词。 注：次数并列的情况考虑、不考虑均可。*/ 思路还是比较清晰的，就是每出现一个新的单词，就在链表中生成一个新的结点，否则令其设置的计数域&#43;1，对于（2）根据计数域对单词排序，输出前k个
这里贴出代码：
#include&#34;stdio.h&#34; #include&#34;string.h&#34; #include&#34;stdlib.h&#34; typedef struct LinkNode { char word[20]; struct LinkNode *next; int count; }LinkNode; /* *定义链表中的结点，包括单词，指针，与出现的次数count */ LinkNode *wordCheck(LinkNode *head, char word[]) { LinkNode *p; if(head==NULL) return NULL; p=head-&gt;next; while(p!=NULL) { if(strcmp(p-&gt;word, word)==0) return p; else p=p-&gt;next; } return NULL; } /* * 定义函数wordCheck，在当前链表查找有无重复单词，如果有重复则返回该单词的指针 * 如果没有重复返回NULL */ LinkNode *createLinkList() { int n; char word[20]; LinkNode *head; LinkNode *p1; LinkNode *p2; LinkNode *word_isnull; head=(LinkNode*)malloc(sizeof(LinkNode)); if(head==NULL) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/49e7c04d93345490a7e7640d3e9c6475/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-23T20:52:30+08:00" />
<meta property="article:modified_time" content="2018-09-23T20:52:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构|一道还蛮有意思的链表题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>最近在二刷数据结构，也偶尔去刷一下Leetcode上的算法题，不过感觉自己还是太菜了，一道题经常憋半个小时一个小时，有时候也有用例死活过不去的情况（手动狗头），还是要多学习多看书多刷题，有机会也会把自己的一些刷题心得放在上面。<br> 前几天把以前做过的一些数据结构题又拿出来看了一下，有这么一道题：</p> 
<pre><code>/*键盘输入英语单词的个数n及n个单词，编一程序，建立一个单向链表，实现： 
（1）如果单词重复出现，则只在链表上保留一个。
（2）除满足（1）的要求外。链表结点还应有一个计数域，记录该单词重复出现的次数，然后输出出现次数最多的前k(k&lt;=n，需键盘输入)个单词。
注：次数并列的情况考虑、不考虑均可。*/
</code></pre> 
<p>思路还是比较清晰的，就是每出现一个新的单词，就在链表中生成一个新的结点，否则令其设置的计数域+1，对于（2）根据计数域对单词排序，输出前k个<br> 这里贴出代码：</p> 
<pre><code>#include"stdio.h"
#include"string.h"
#include"stdlib.h"
typedef struct LinkNode
{
	char word[20];
	struct LinkNode *next;
	int count;
}LinkNode;
/*
*定义链表中的结点，包括单词，指针，与出现的次数count
*/
LinkNode *wordCheck(LinkNode *head, char word[])
{
	LinkNode *p;
	if(head==NULL)
		return NULL;
	p=head-&gt;next;
	while(p!=NULL)
	{
		if(strcmp(p-&gt;word, word)==0)
			return p;
		else
			p=p-&gt;next;
	}
	return NULL;
}
/*
*   定义函数wordCheck，在当前链表查找有无重复单词，如果有重复则返回该单词的指针
*   如果没有重复返回NULL
*/
LinkNode *createLinkList()
{
	int n;
	char word[20];
	LinkNode *head;
	LinkNode *p1;
	LinkNode *p2;
	LinkNode *word_isnull; 
	head=(LinkNode*)malloc(sizeof(LinkNode));
	if(head==NULL)
	{
		printf("分配失败");
		return NULL;
	}
	head-&gt;next=NULL; 
	p1=head;
	printf("请输入单词的个数");
	scanf("%d",&amp;n);
	printf("请输入单词\n");
	while(n--)
	{
		scanf("%s", word);
		word_isnull=wordCheck(head, word);
		/*word_isnull用于查找是否有重复单词，如果不重复，wordCheck方法返回null，并生成新的结点，否则返回当前单词，
		令其计数域count加一
		*/
		if(word==NULL)
		{
			p2=(LinkNode*)malloc(sizeof(LinkNode));
			if(p2==NULL)
			{
				printf("分配失败");
				return head;
			}
			strcpy(p2-&gt;word, word);
			p2-&gt;count=1;
			p2-&gt;next=NULL;
			p1-&gt;next=p2;
			p1=p2;
		}
		else
			word_isnull-&gt;count++;
	}
	return head;
}
/*
* 定义函数createLinkList创建链表，返回生成链表的头指针
*/
void sort(LinkNode *head)
{
	LinkNode *p1;
	LinkNode *p2;
	LinkNode *maxCount;
	if(head==NULL)
		return;
	for(p1=head-&gt;next; p1-&gt;next!=NULL; p1=p1-&gt;next)
	{
		maxCount=p1;
		for(p2=p1-&gt;next; p2!=NULL; p2=p2-&gt;next)
		{
			if(p2-&gt;count&gt;maxCount-&gt;count)
				maxCount=p2;
		}
	}
}
/*
*定义函数sort对链表按照单词出现次数进行排序
*/
void input(LinkNode *head, int k)
{
	LinkNode *p;
	if(head==NULL)
		return;
	p=head-&gt;next;
	printf("出现次数最多的%d个单词为:\n", k);
	while(k!=0&amp;&amp;p!=NULL)
	{
		printf("%s出现了(%d次)\n", p-&gt;word, p-&gt;count);
		p=p-&gt;next;
		k--;
	}
}
/*
* 定义input函数输出排序后的前k个单词
*/
int main()
{
	int k;
	LinkNode *head;
	head =createLinkList();
	sort(head);
	printf("请输入要输出的单词数:");
	scanf("%d", &amp;k);
	input(head, k);
	return 0;
}
/*
*程序主函数，先创建符合要求的链表，然后调用sort对单词出现次数进行排序，最后输出前k个单词
*/

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81a07d5b83c6c20086fb7b98441d3342/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NOIP2006开心的金明（普及组T2）————动态规划，01背包</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3fbfa1a1f7f2d6780423c6ce88396174/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">锚点定位的三种解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>