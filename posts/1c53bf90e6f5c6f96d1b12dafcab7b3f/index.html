<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于java  JPA (小结） Java Persistence API - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于java  JPA (小结） Java Persistence API" />
<meta property="og:description" content="JPA(Java Persistence API)作为Java EE 5.0平台标准的ORM规范，将得到所有Java EE服务器的支持。Sun这次吸取了之前EJB规范惨痛失败的经历，在充分吸收现有ORM框架的基础上，得到了一个易于使用、伸缩性强的ORM规范。
JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中.
JPA已经作为一项对象持久化的标准，不但可以获得Java EE应用服务器的支持，还可以直接在Java SE中使用。开发者将无需在现有多种ORM框架中艰难地选择，按照Sun的预想，现有ORM框架头顶的光环将渐渐暗淡，不再具有以往的吸引力。
JPA的技术：
JPA包括以下3方面的技术：
(1). ORM映射元数据，JPA支持XML和JDK 5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中.
(2). JPA 的API，用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。
(3). 查询语言，这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 JPA的优势：
1 标准化 JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问 API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。
2 对容器级特性的支持 JPA 框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。 3 简单易用，集成方便 JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释；JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成。
4 可媲美JDBC的查询能力 JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。
5 支持面向对象的高级特性 JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。
JPA的实现:
JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个. 从功能上来说，JPA现在就是Hibernate功能的一个子集。Hibernate 从3.2开始，就开始兼容JPA。
在Spring 2.0.1中，正式提供对JPA的支持，这也促成了JPA的发展，要知道JPA的好处在于可以分离于容器运行，变得更加的简洁。
OpenJPA 是 Apache 组织提供的开源项目，它实现了 EJB 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1c53bf90e6f5c6f96d1b12dafcab7b3f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-08-22T17:16:46+08:00" />
<meta property="article:modified_time" content="2011-08-22T17:16:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于java  JPA (小结） Java Persistence API</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>JPA(Java Persistence API)作为Java EE 5.0平台标准的ORM规范，将得到所有Java EE服务器的支持。Sun这次吸取了之前EJB规范惨痛失败的经历，在充分吸收现有ORM框架的基础上，得到了一个易于使用、伸缩性强的ORM规范。</p> 
<p><strong>JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中.</strong></p> 
<p>JPA已经作为一项对象持久化的标准，不但可以获得Java EE应用服务器的支持，还可以直接在Java SE中使用。开发者将无需在现有多种ORM框架中艰难地选择，按照Sun的预想，现有ORM框架头顶的光环将渐渐暗淡，不再具有以往的吸引力。</p> 
<p><strong><span style="font-size:18px; color:#3366ff"></span></strong> </p> 
<p><strong><span style="font-size:18px; color:#3366ff">JPA的技术：</span></strong></p> 
<p><strong>JPA包括以下3方面的技术：<br> (1).  ORM映射元数据，JPA支持XML和JDK 5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中.<br> (2). JPA 的API，用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。<br> (3). 查询语言，这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 </strong></p> 
<p><strong><span style="font-size:18px; color:#3366ff"></span></strong> </p> 
<p> <strong><span style="font-size:18px; color:#3366ff">JPA的优势：</span></strong><br> 　　1 标准化 <br> 　　JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问 API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。<br> 　　2 对容器级特性的支持 <br> 　　JPA 框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。 <br> 　　3 简单易用，集成方便 <br> 　　JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释；JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成。<br> 　　4 可媲美JDBC的查询能力 <br> 　　JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。<br> 　　5 支持面向对象的高级特性 <br> 　　JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。<br> </p> 
<strong><span style="font-size:18px; color:#3366ff"></span></strong> 
<p><strong><span style="font-size:18px; color:#3366ff">JPA的实现:</span></strong></p> 
<p>JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个. 从功能上来说，JPA现在就是Hibernate功能的一个子集。Hibernate 从3.2开始，就开始兼容JPA。</p> 
<p>在Spring 2.0.1中，正式提供对JPA的支持，这也促成了JPA的发展，要知道JPA的好处在于可以分离于容器运行，变得更加的简洁。</p> 
<p>OpenJPA 是 Apache 组织提供的开源项目，它实现了 EJB 3.0 中的 JPA 标准，为开发者提供功能强大、使用简单的持久化数据管理框架。OpenJPA 封装了和关系型数据库交互的操作，让开发者把注意力集中在编写业务逻辑上。</p> 
<p>目前其它支持的实现包括Toplink、Hibernate Entitymanager等。TopLink以前需要收费，如今开源了.</p> 
<p> </p> 
<p><strong><span style="font-size:18px; color:#3366ff">JPA的缺陷:</span></strong></p> 
<p>   JPA 的采用虽然大大简化了Entity Bean的使用.  但结果就有可能将数据库结构移植到你的应用程序的代码中。这将给应用程序的维护和升级带来麻烦。这里主要指通过Annotation对Entity Bean之间的关系进行定义。</p> 
<p>这些数据实体的关系，如一对多，一对一，多对一，多对多及关联操作（cascade）等，很明显是数据库概念。为了实现ORM的目的，JPA不得不将其在Entity源代码中定义这种关系。</p> 
<p>　　这在很大程度上，将数据库的结构与设计移植到了应用程序中。这有以下几个问题：</p> 
<p>　　一，应用程序源代码可读性差数据库结构的复杂程度，几乎完全取决于应用的业务逻辑。如果业务逻辑复杂，对Entity Bean的关系定义将很困难。可以想象，其代码的可阅读性将很差。</p> 
<p>　　二，应用程序的可维护性差一旦数据库结构因业务需求而发生变化，这些关系将需要重新定义。</p> 
<p>　　三，对较复杂的数据库结构关系进行定义几乎是不现实的这也是ORM本身的局限性。将数据库结构移植到应用程序中本身就是个错误方向。关系数据库主要在于“关系”二字，因为数据库关心的是数据及其完整性（Data）。而应用程序采用OOP的开发手段，关心的是系统内部各“物件（Object）”的动作（Operation）。数据是应用程序的状态；动作是应用程序的业务逻辑。状态和动作是构成应用程序的两大要素，二者缺一不可。而ORM试图忽视状态而抬高动作，岂不知“动作”的最终结果要落实在“状态”的改变上。</p> 
<p>    也许这也是为什么Object Database Management System （ODBMS）不太流行的原因？</p> 
<p> </p> 
<p><strong><span style="font-size:18px; color:#3366ff">JPA关联的常用概念:</span></strong></p> 
<p>Entity:<br> 具有ORM元数据的领域对象称为实体（Entity），按JPA的规范，实体具备以下的条件：<br> 必须使用javax.persistence.Entity注解或者在XML映射文件中有对应的元素；<br> 必须具有一个不带参的构造函数，类不能声明为final，方法和需要持久化的属性也不能声明为final；<br> 如果游离状的实体对象需要以值的方式进行传递，如通Session bean的远程业务接口传递，则必须实现Serializable接口；<br> 需要持久化的属性，其访问修饰符不能是public，它们必须通过实体类方法进行访问。</p> 
<p> JDBC</p> 
<p align="left">很多企业应用的开发者选择使用 JDBC 管理关系型数据库中的数据。JDBC支持处理大量的数据，能够保证数据的一致性，支持信息的并发访问，提供 SQL 查询语言查找数据。JDBC 所使用的关系模型不是为保存对象而设计的，因此迫使开发者选择在处理持久数据时放弃面向对象编程，或者自己去开发将面向对象特性（比如：类之间的继承）和关系型数据库进行映射的专有解决方案。</p> 
<h5>Object Relational Mapping，ORM</h5> 
<p align="left">ORM 是目前完成对象和关系数据表之间的映射最好的一种技术， 这些 ORM 框架处理对象和关系数据库之间的协调工作，将开发者从这部分工作中解脱出来，集中精力处理对象模型。阻碍 ORM 发展的问题是，现有的每一种 ORM 产品都有自己特有的 API，开发者只能将自己的代码绑定到某一个框架提供商的接口上，这种状况形成了厂商锁定，意味着一旦该框架提供商无法解决系统中出现的严重错误，或者因为其它的原因转而采用其它的框架，将会给开发者的企业应用带来极大的困难，唯一的解决办法是重写所有的持久化代码。</p> 
<h5>Java Data Object，JDO</h5> 
<p align="left">JDO 是 Java EE 标准中另外一个支持管理持久化数据的规范，JDO 规范使用和 JPA 非常类似的 API，只是通常是通过 JCA 技术集成到应用服务器上。但是 JDO 是针对轻量级容器而设计的，不能够支持容器级别的声明式安全、事务特性，也无法对远程方法调用提供支持。</p> 
<p></p> 
<p><strong><span style="font-size:18px; color:#3366ff">JPA的使用:</span></strong></p> 
<ul type="disc"><li><strong>EntityManagerFactory</strong> </li></ul> 
<p align="left">EntityManagerFactory 是 EntityManager 的工厂类，负责创建 EntityManager 对象。</p> 
<ul type="disc"><li><strong>EntityManager</strong> </li></ul> 
<p align="left">EntityManager 是 JPA 应用中使用的基本对象，通过它提供的相应方法可以管理持久化对象，也可以新建或者删除持久化对象。<u>EntityManager 还负责创建 Query 实例</u>。<u>在容器外使用时，EntityManagerFactory 和 EntityManager 之间是一对一的关系。</u></p> 
<ul type="disc"><li><strong>Entity</strong> </li></ul> 
<p align="left"><u>EntityTransaction 提供 Entity 操作时需要的事务管理</u>，和 EntityManager 是一对一的关系。在查询操作时不需要使用 EntityTransaction，而在对象持久化、状态更新、对象删除等情况下则必须使用显式的使用 EntityTransaction 的相关方法管理事务。</p> 
<ul type="disc"><li><strong>Query</strong> </li></ul> 
<p align="left">Query 是查询实体的接口，Query 对象可以从 EntityManager 中获得。根据 EJB 3.0 规范中的描述，<u>Query 接口需要同时支持 JPQL 和原生态 SQL 两种语法。</u></p> 
<ul type="disc"><li><strong>Persistence</strong> </li></ul> 
<p align="left"><u>Persistence 是一个工具类，负责根据配置文件提供的参数创建 EntityManagerFactory 对象</u>。</p> 
<p> </p> 
<ul><li><strong> JPA<strong>依赖的jar</strong></strong></li></ul> 
<p>//TODO </p> 
<ul><li><strong><span style="color:#000000">JPA的配置文件</span></strong></li></ul> 
<p> JPA规范要求在类路径的META-INF目录下放置<span style="color:blue">persistence.xml</span>, 文件的名称是固定的，配置模板如下： </p> 
<p><strong><span style="font-size:18px; color:#3366ff"></span></strong></p> 
<p> </p> 
<table cellspacing="1" cellpadding="1" width="926" border="1" style="width:926px; height:444px"><tbody><tr><td> <p align="left">&lt;?xml version="1.0" encoding="UTF-8"?&gt; </p> <p align="left">&lt;persistence version="1.0" xmlns:persistence="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/persistence persistence_1_0.xsd "&gt;</p> <p align="left">          &lt;!-- Name属性用于定义持久化单元的名字 (name必选,空值也合法); transaction-type 指定事务类型(可选) --&gt;</p> <p align="left">            &lt;persistence-unit name="unitName" transaction-type="JTA"&gt;</p> 
    <blockquote dir="ltr" style="margin-right:0px"> 
     <blockquote dir="ltr" style="margin-right:0px"> 
      <p align="left">&lt;!-- 描述信息.(可选) --&gt;</p> 
      <p align="left"> &lt;description&gt; &lt;/description&gt; </p> 
      <p align="left"> </p> 
      <p align="left">&lt;!-- javax.persistence.PersistenceProvider接口的一个实现类(可选) --&gt; </p> 
      <p align="left">&lt;provider&gt; &lt;/provider&gt; </p> 
      <p align="left"> </p> 
      <p align="left">&lt;!-- Jta-data-source和 non-jta-data-source用于分别指定持久化提供商使用的JTA和/或non-JTA数据源的全局JNDI名称(可选) --&gt;</p> 
      <p align="left"> &lt;jta-data-source&gt;java:/MySqlDS&lt;/jta-data-source&gt; &lt;non-jta-data-source&gt; &lt;/non-jta-data-source&gt;</p> 
      <p align="left"> </p> 
      <p align="left">&lt;!-- 声明orm.xml所在位置.(可选) --&gt; </p> 
      <p align="left">&lt;mapping-file&gt;product.xml&lt;/mapping-file&gt;</p> 
      <p align="left"> </p> 
      <p align="left"> &lt;!-- 以包含persistence.xml的jar文件为基准的相对路径,添加额外的jar文件.(可选) --&gt; </p> 
      <p align="left">&lt;jar-file&gt;../lib/model.jar&lt;/jar-file&gt; </p> 
      <p align="left"> </p> 
      <p align="left">&lt;!-- 显式列出实体类,在Java SE 环境中应该显式列出.(可选) --&gt; </p> 
      <p align="left">&lt;class&gt;com.domain.User&lt;/class&gt; </p> 
      <p align="left">&lt;class&gt;com.domain.Product&lt;/class&gt; </p> 
      <p align="left"> </p> 
      <p align="left">&lt;!-- 声明是否扫描jar文件中标注了@Enity类加入到上下文.若不扫描,则如下:(可选) --&gt; </p> 
      <p align="left">&lt;exclude-unlisted-classes/&gt;</p> 
      <p align="left"> </p> 
      <p align="left"> &lt;!-- 厂商专有属性(可选) --&gt; </p> 
      <p align="left">&lt;properties&gt; &lt;!-- hibernate.hbm2ddl.auto= create-drop / create / update --&gt;</p> 
      <p align="left"> &lt;property name="hibernate.hbm2ddl.auto" value="update" /&gt; </p> 
      <p align="left">&lt;property name="hibernate.show_sql" value="true" /&gt; </p> 
      <p align="left">&lt;/properties&gt; </p> 
     </blockquote> 
     <p align="left">&lt;/persistence-unit&gt;</p> 
    </blockquote> <p align="left">&lt;/persistence&gt;</p> </td></tr></tbody></table> 
<p></p> 
<ul><li> JPA  开发</li></ul> 
<p><strong>(1).  在非 Java EE 环境使用 JPA 接口的例子</strong><br> EntityManagerFactory factory = Persistence.createEntityManagerFactory (“mysql”);<br> // 从 EntityManagerFactory 实例 factory 中获取 EntityManager<br> EntityManager em = factory.createEntityManager(PersistenceContextType.EXTENDED);<br> // 实体的更新需要在事务中运行<br> EntityTransaction tx = em.getTransaction ();<br> tx.begin ();         </p> 
<p>// 查找所有公司中的雇员<br> Query query = em.createQuery ("select e from Employee e  );<br> List results = query.getResultList ();<br> // 给所有雇员增加半天假期<br> for (Object res : results)<br> {    <br>      Employee emp = (Employee) res;  <br>      emp.setHoliday (emp.getHoliday () +0.5);<br> }         </p> 
<p>// 提交事务(持久化所有更新)<br> tx.commit ();<br> em.close ();<br> factory.close ();</p> 
<p>  <br> <strong>(2).  在容器中运行的 JPA 例子</strong></p> 
<p>下面的代码显示了在 EJB 容器中开发 JPA 应用时的接口使用情况，由于容器中的 EntityManager 是注入的，事务也是声明式的，因此在容器中完成上面的业务逻辑要简单得多</p> 
<p>/*</p> 
<p>* 在容器中运行 JPA 应用时，EntityManager 接口的实例”em”</p> 
<p>* 是通过 @Resource 注释注入的。事务也通常是声明式的。</p> 
<p>*/</p> 
<p>// 查找所有公司中的雇员</p> 
<p>Query query = em.createQuery ("select e from Employee e );<br> List results = query.getResultList (); </p> 
<p>// 给所有雇员增加半天假期</p> 
<p>for (Object res : results)<br> {<!-- --></p> 
<p>   Employee emp = (Employee) res; <br>    emp.setHoliday (emp.getHoliday () +0.5);<br> }</p> 
<p> </p> 
<p></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d5521926068716b5b43613fe761904b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VC实现程序最小化到系统托盘功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d66a5fe3f9ab04e3906d9f2afc50575/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Unix/Linux下C/C&#43;&#43;开发技术概览-平台差异简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>