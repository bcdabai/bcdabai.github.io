<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的类反射机制 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中的类反射机制" />
<meta property="og:description" content="作者: 来源:http://www.cnxiyang.com/ 时间:2006-5-5 19:12:20 Java 中的类反射机制 一、反射的概念 ： 反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。其中LEAD/LEAD&#43;&#43; 、OpenC&#43;&#43; 、MetaXa和OpenJava等就是基于反射机制的语言。最近，反射机制也被应用到了视窗系统、操作系统和文件系统中。 反射本身并不是一个新概念，它可能会使我们联想到光学中的反射概念，尽管计算机科学赋予了反射概念新的含义，但是，从现象上来说，它们确实有某些相通之处，这些有助于我们的理解。在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。可以看出，同一般的反射概念相比，计算机科学领域的反射不单单指反射本身，还包括对反射结果所采取的措施。所有采用反射机制的系统（即反射系统）都希望使系统的实现更开放。可以说，实现了反射机制的系统都具有开放性，但具有开放性的系统并不一定采用了反射机制，开放性是反射系统的必要条件。一般来说，反射系统除了满足开放性条件外还必须满足原因连接（Causally-connected）。所谓原因连接是指对反射系统自描述的改变能够立即反映到系统底层的实际状态和行为上的情况，反之亦然。开放性和原因连接是反射系统的两大基本要素。13700863760 Java中，反射是一种强大的工具。它使您能够创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代表链接。反射允许我们在编写与执行时，使我们的程序代码能够接入装载到JVM中的类的内部信息，而不是源代码中选定的类协作的代码。这使反射成为构建灵活的应用的主要工具。但需注意的是：如果使用不当，反射的成本很高。 二、Java中的类反射： Reflection 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性。Java 的这一能力在实际应用中也许用得不是很多，但是在其它的java/j2me/code/&#39; target=&#39;_blank&#39;&gt;程序设计语言中根本就不存在这一特性。例如，Pascal、C 或者 C&#43;&#43; 中就没有办法在程序中获得函数定义相关的信息。 1 ．检测类： 1.1 reflection 的工作机制 考虑下面这个简单的例子，让我们看看 reflection 是如何工作的。 import java.lang.reflect.*; public class DumpMethods { public static void main(String args[]) { try { Class c = Class.forName(args[0]); Method m[] = c.getDeclaredMethods(); for (int i = 0; i &lt; m.length; i&#43;&#43;) System.out.println(m[i].toString()); } catch (Throwable e) { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/462a94a59066eb081f2ee6152d1fdb4b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2006-08-03T17:23:00+08:00" />
<meta property="article:modified_time" content="2006-08-03T17:23:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的类反射机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                      
<table id="table28" style="TABLE-LAYOUT: fixed; BORDER-COLLAPSE: collapse" cellspacing="1" cellpadding="2" width="100%" border="0"><tbody><tr><td> 
    <div align="center">
      作者: 来源:http://www.cnxiyang.com/ 时间:2006-5-5 19:12:20 
    </div> </td></tr><tr><td> <p> </p> 
    <div align="center"> 
     <strong>Java</strong> 
     <strong>中的类反射机制</strong> 
    </div> 
    <div>
        
    </div> 
    <div style="MARGIN: 13pt 0cm"> 
     <strong><font size="4">一、反射的概念 ：</font></strong> 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。其中LEAD/LEAD++ 、OpenC++ 、MetaXa和OpenJava等就是基于反射机制的语言。最近，反射机制也被应用到了视窗系统、操作系统和文件系统中。 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      反射本身并不是一个新概念，它可能会使我们联想到光学中的反射概念，尽管计算机科学赋予了反射概念新的含义，但是，从现象上来说，它们确实有某些相通之处，这些有助于我们的理解。在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。可以看出，同一般的反射概念相比，计算机科学领域的反射不单单指反射本身，还包括对反射结果所采取的措施。所有采用反射机制的系统（即反射系统）都希望使系统的实现更开放。可以说，实现了反射机制的系统都具有开放性，但具有开放性的系统并不一定采用了反射机制，开放性是反射系统的必要条件。一般来说，反射系统除了满足开放性条件外还必须满足原因连接（Causally-connected）。所谓原因连接是指对反射系统自描述的改变能够立即反映到系统底层的实际状态和行为上的情况，反之亦然。开放性和原因连接是反射系统的两大基本要素。13700863760 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      Java中，反射是一种强大的工具。它使您能够创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代表链接。反射允许我们在编写与执行时，使我们的程序代码能够接入装载到JVM中的类的内部信息，而不是源代码中选定的类协作的代码。这使反射成为构建灵活的应用的主要工具。但需注意的是：如果使用不当，反射的成本很高。 
    </div> 
    <div style="MARGIN: 13pt 0cm"> 
     <strong><font size="4">二、Java中的类反射：</font></strong> 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      Reflection 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性。Java 的这一能力在实际应用中也许用得不是很多，但是在其它的java/j2me/code/' target='_blank'&gt;程序设计语言中根本就不存在这一特性。例如，Pascal、C 或者 C++ 中就没有办法在程序中获得函数定义相关的信息。 
    </div> 
    <div style="LINE-HEIGHT: 150%"> 
     <strong>1</strong> 
     <strong>．检测类：</strong> 
    </div> 
    <div style="LINE-HEIGHT: 150%"> 
     <strong>1.1 reflection</strong> 
     <strong>的工作机制</strong> 
    </div> 
    <div style="LINE-HEIGHT: 150%">
      考虑下面这个简单的例子，让我们看看 reflection 是如何工作的。 
    </div> 
    <div>
      import java.lang.reflect.*; 
     <br>public class DumpMethods { 
     <br>    public static void main(String args[]) { 
     <br>        try { 
     <br>            Class c = Class.forName(args[0]); 
     <br>            Method m[] = c.getDeclaredMethods(); 
     <br>            for (int i = 0; i &lt; m.length; i++) 
     <br>                System.out.println(m[i].toString()); 
     <br>        } catch (Throwable e) { 
     <br>            System.err.println(e); 
     <br>        } 
     <br>    } 
     <br>} 
    </div> 
    <div>
      按如下语句执行： 
    </div> 
    <div>
      java DumpMethods java.util.Stack 
    </div> 
    <div>
      它的结果输出为： 
    </div> 
    <div>
      public java.lang.Object java.util.Stack.push(java.lang.Object) 
    </div> 
    <div>
      public synchronized java.lang.Object java.util.Stack.pop() 
    </div> 
    <div>
      public synchronized java.lang.Object java.util.Stack.peek() 
    </div> 
    <div>
      public boolean java.util.Stack.empty() 
    </div> 
    <div>
      public synchronized int java.util.Stack.search(java.lang.Object) 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      这样就列出了java.util.Stack 类的各方法名以及它们的限制符和返回类型。 
    </div> 
    <div style="LINE-HEIGHT: 150%">
      这个程序使用 Class.forName 载入指定的类，然后调用 getDeclaredMethods 来获取这个类中定义了的方法列表。java.lang.reflect.Methods 是用来描述某个类中单个方法的一个类。 
    </div> 
    <div style="LINE-HEIGHT: 150%"> 
     <strong>1.2 Java</strong> 
     <strong>类反射中的主要方法</strong> 
    </div> 
    <div style="TEXT-INDENT: 26.25pt; LINE-HEIGHT: 150%">
      对于以下三类组件中的任何一类来说 -- 构造函数、字段和方法 -- java.lang.Class 提供四种独立的反射调用，以不同的方式来获得信息。调用都遵循一种标准格式。以下是用于查找构造函数的一组反射调用： 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 47.25pt; TEXT-INDENT: -21pt">
      l         Constructor getConstructor(Class[] params) -- 获得使用特殊的参数类型的公共构造函数， 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 47.25pt; TEXT-INDENT: -21pt">
      l         Constructor[] getConstructors() -- 获得类的所有公共构造函数 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 47.25pt; TEXT-INDENT: -21pt">
      l         Constructor getDeclaredConstructor(Class[] params) -- 获得使用特定参数类型的构造函数(与接入级别无关) 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 47.25pt; TEXT-INDENT: -21pt">
      l         Constructor[] getDeclaredConstructors() -- 获得类的所有构造函数(与接入级别无关) 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      获得字段信息的Class 反射调用不同于那些用于接入构造函数的调用，在参数类型数组中使用了字段名： 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 47.25pt; TEXT-INDENT: -21pt">
      l         Field getField(String name) -- 获得命名的公共字段 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 47.25pt; TEXT-INDENT: -21pt">
      l         Field[] getFields() -- 获得类的所有公共字段 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 47.25pt; TEXT-INDENT: -21pt">
      l         Field getDeclaredField(String name) -- 获得类声明的命名的字段 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 47.25pt; TEXT-INDENT: -21pt">
      l         Field[] getDeclaredFields() -- 获得类声明的所有字段 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      用于获得方法信息函数： 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 47.25pt; TEXT-INDENT: -21pt">
      l         Method getMethod(String name, Class[] params) -- 使用特定的参数类型，获得命名的公共方法 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 47.25pt; TEXT-INDENT: -21pt">
      l         Method[] getMethods() -- 获得类的所有公共方法 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 47.25pt; TEXT-INDENT: -21pt">
      l         Method getDeclaredMethod(String name, Class[] params) -- 使用特写的参数类型，获得类声明的命名的方法 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 47.25pt; TEXT-INDENT: -21pt">
      l         Method[] getDeclaredMethods() -- 获得类声明的所有方法 
    </div> 
    <div>
        
    </div> 
    <div style="LINE-HEIGHT: 150%"> 
     <strong>1.3</strong> 
     <strong>开始使用 Reflection：</strong> 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      用于 reflection 的类，如 Method，可以在 java.lang.relfect 包中找到。使用这些类的时候必须要遵循三个步骤：第一步是获得你想操作的类的 java.lang.Class 对象。在运行中的 Java 程序中，用 java.lang.Class 类来描述类和接口等。 
    </div> 
    <div style="TEXT-INDENT: 15.75pt; LINE-HEIGHT: 150%">
      下面就是获得一个 Class 对象的方法之一： 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      Class c = Class.forName("java.lang.String"); 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      这条语句得到一个 String 类的类对象。还有另一种方法，如下面的语句： 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      Class c = int.class; 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      或者 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      Class c = Integer.TYPE; 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      它们可获得基本类型的类信息。其中后一种方法中访问的是基本类型的封装类 (如 Integer) 中预先定义好的 TYPE 字段。 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      第二步是调用诸如 getDeclaredMethods 的方法，以取得该类中定义的所有方法的列表。 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 21pt; LINE-HEIGHT: 150%">
      一旦取得这个信息，就可以进行第三步了——使用 reflection API 来操作这些信息，如下面这段代码： 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      Class c = Class.forName("java.lang.String"); 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      Method m[] = c.getDeclaredMethods(); 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      System.out.println(m[0].toString()); 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      它将以文本方式打印出 String 中定义的第一个方法的原型。 
    </div> 
    <div style="LINE-HEIGHT: 150%"> 
     <strong>2</strong> 
     <strong>．处理对象：</strong> 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 8.9pt; TEXT-INDENT: 6.7pt; LINE-HEIGHT: 150%">
      如果要作一个开发工具像debugger之类的，你必须能发现filed values,以下是三个步骤: 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 35.7pt; LINE-HEIGHT: 150%">
      a.创建一个Class对象 
     <br>b.通过getField 创建一个Field对象 
     <br>c.调用Field.getXXX(Object)方法(XXX是Int,Float等，如果是对象就省略；Object是指实例). 
    </div> 
    <div style="LINE-HEIGHT: 150%">
      例如： 
     <br>import java.lang.reflect.*; 
     <br>import java.awt.*; 
    </div> 
    <div>
      class SampleGet { 
    </div> 
    <div>
         public static void main(String[] args) { 
     <br>      Rectangle r = new Rectangle(100, 325); 
     <br>      printHeight(r); 
    </div> 
    <div>
         } 
    </div> 
    <div>
         static void printHeight(Rectangle r) { 
     <br>      Field heightField; 
     <br>      Integer heightValue; 
     <br>      Class c = r.getClass(); 
     <br>      try { 
     <br>        heightField = c.getField("height"); 
     <br>        heightValue = (Integer) heightField.get(r); 
     <br>        System.out.println("Height: " + heightValue.toString()); 
     <br>      } catch (NoSuchFieldException e) { 
     <br>          System.out.println(e); 
     <br>      } catch (SecurityException e) { 
     <br>          System.out.println(e); 
     <br>      } catch (IllegalAccessException e) { 
     <br>          System.out.println(e); 
     <br>      } 
     <br>   } 
     <br>} 
    </div> 
    <div>
        
    </div> 
    <div style="MARGIN: 13pt 0cm"> 
     <strong><font size="4">三、安全性和反射：</font></strong> 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      在处理反射时安全性是一个较复杂的问题。反射经常由框架型代码使用，由于这一点，我们可能希望框架能够全面接入代码，无需考虑常规的接入限制。但是，在其它情况下，不受控制的接入会带来严重的安全性风险，例如当代码在不值得信任的代码共享的环境中运行时。 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      由于这些互相矛盾的需求，Java编程语言定义一种多级别方法来处理反射的安全性。基本模式是对反射实施与应用于源代码接入相同的限制： 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 77.9pt; TEXT-INDENT: -21pt; LINE-HEIGHT: 150%">
      n         从任意位置到类公共组件的接入 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 77.9pt; TEXT-INDENT: -21pt; LINE-HEIGHT: 150%">
      n         类自身外部无任何到私有组件的接入 
    </div> 
    <div style="MARGIN: 0cm 0cm 0pt 77.9pt; TEXT-INDENT: -21pt; LINE-HEIGHT: 150%">
      n         受保护和打包（缺省接入）组件的有限接入 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      不过至少有些时候，围绕这些限制还有一种简单的方法。我们可以在我们所写的类中，扩展一个普通的基本类java.lang.reflect.AccessibleObject 类。这个类定义了一种setAccessible方法，使我们能够启动或关闭对这些类中其中一个类的实例的接入检测。唯一的问题在于如果使用了安全性管理器，它将检测正在关闭接入检测的代码是否许可了这样做。如果未许可，安全性管理器抛出一个例外。 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      下面是一段程序，在TwoString 类的一个实例上使用反射来显示安全性正在运行： 
    </div> 
    <div>
      public class ReflectSecurity { 
    </div> 
    <div>
          public static void main(String[] args) { 
    </div> 
    <div>
              try { 
    </div> 
    <div>
                  TwoString ts = new TwoString("a", "b"); 
    </div> 
    <div>
                  Field field = clas.getDeclaredField("m_s1"); 
    </div> 
    <div>
      //          field.setAccessible(true); 
    </div> 
    <div>
                  System.out.println("Retrieved value is " + 
    </div> 
    <div>
                      field.get(inst)); 
    </div> 
    <div>
              } catch (Exception ex) { 
    </div> 
    <div>
                  ex.printStackTrace(System.out); 
    </div> 
    <div>
              } 
    </div> 
    <div>
          } 
    </div> 
    <div>
      } 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      如果我们编译这一程序时，不使用任何特定参数直接从命令行运行，它将在field .get(inst)调用中抛出一个IllegalAccessException异常。如果我们不注释field.setAccessible(true)代码行，那么重新编译并重新运行该代码，它将编译成功。最后，如果我们在命令行添加了JVM参数-Djava.security.manager以实现安全性管理器，它仍然将不能通过编译，除非我们定义了ReflectSecurity类的许可权限。 
    </div> 
    <div style="MARGIN: 13pt 0cm"> 
     <strong><font size="4">四、反射性能：</font></strong> 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      反射是一种强大的工具，但也存在一些不足。一个主要的缺点是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      下面的程序是字段接入性能测试的一个例子，包括基本的测试方法。每种方法测试字段接入的一种形式 -- accessSame 与同一对象的成员字段协作，accessOther 使用可直接接入的另一对象的字段，accessReflection 使用可通过反射接入的另一对象的字段。在每种情况下，方法执行相同的计算 -- 循环中简单的加/乘顺序。 
    </div> 
    <div style="LINE-HEIGHT: 150%">
      程序如下： 
    </div> 
    <div>
      public int accessSame(int loops) { 
    </div> 
    <div>
          m_value = 0; 
    </div> 
    <div>
          for (int index = 0; index &lt; loops; index++) { 
    </div> 
    <div>
              m_value = (m_value + ADDITIVE_VALUE) * 
    </div> 
    <div>
                  MULTIPLIER_VALUE; 
    </div> 
    <div>
          } 
    </div> 
    <div>
          return m_value; 
    </div> 
    <div>
      } 
    </div> 
    <div>
        
    </div> 
    <div>
      public int accessReference(int loops) { 
    </div> 
    <div>
          TimingClass timing = new TimingClass(); 
    </div> 
    <div>
          for (int index = 0; index &lt; loops; index++) { 
    </div> 
    <div>
              timing.m_value = (timing.m_value + ADDITIVE_VALUE) * 
    </div> 
    <div>
                  MULTIPLIER_VALUE; 
    </div> 
    <div>
          } 
    </div> 
    <div>
          return timing.m_value; 
    </div> 
    <div>
      } 
    </div> 
    <div>
        
    </div> 
    <div>
      public int accessReflection(int loops) throws Exception { 
    </div> 
    <div>
          TimingClass timing = new TimingClass(); 
    </div> 
    <div>
          try { 
    </div> 
    <div>
              Field field = TimingClass.class. 
    </div> 
    <div>
                  getDeclaredField("m_value"); 
    </div> 
    <div>
              for (int index = 0; index &lt; loops; index++) { 
    </div> 
    <div>
                  int value = (field.getInt(timing) + 
    </div> 
    <div>
                      ADDITIVE_VALUE) * MULTIPLIER_VALUE; 
    </div> 
    <div>
                  field.setInt(timing, value); 
    </div> 
    <div>
              } 
    </div> 
    <div>
              return timing.m_value; 
    </div> 
    <div>
          } catch (Exception ex) { 
    </div> 
    <div>
              System.out.println("Error using reflection"); 
    </div> 
    <div>
              throw ex; 
    </div> 
    <div>
          } 
    </div> 
    <div>
      } 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      在上面的例子中，测试程序重复调用每种方法，使用一个大循环数，从而平均多次调用的时间衡量结果。平均值中不包括每种方法第一次调用的时间，因此初始化时间不是结果中的一个因素。下面的图清楚的向我们展示了每种方法字段接入的时间： 
    </div> 
    <div style="LINE-HEIGHT: 150%">
      图 1：字段接入时间 ： 
     <br> 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      我们可以看出：在前两副图中(Sun JVM)，使用反射的执行时间超过使用直接接入的1000倍以上。通过比较，IBM JVM可能稍好一些，但反射方法仍旧需要比其它方法长700倍以上的时间。任何JVM上其它两种方法之间时间方面无任何显著差异，但IBM JVM几乎比Sun JVM快一倍。最有可能的是这种差异反映了Sun Hot Spot JVM的专业优化，它在简单基准方面表现得很糟糕。反射性能是Sun开发1.4 JVM时关注的一个方面，它在反射方法调用结果中显示。在这类操作的性能方面，Sun 1.4.1 JVM显示了比1.3.1版本很大的改进。 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      如果为为创建使用反射的对象编写了类似的计时测试程序，我们会发现这种情况下的差异不象字段和方法调用情况下那么显著。使用newInstance()调用创建一个简单的java.lang.Object实例耗用的时间大约是在Sun 1.3.1 JVM上使用new Object()的12倍，是在IBM 1.4.0 JVM的四倍，只是Sun 1.4.1 JVM上的两部。使用Array.newInstance(type, size)创建一个数组耗用的时间是任何测试的JVM上使用new type[size]的两倍，随着数组大小的增加，差异逐步缩小。 
    </div> 
    <div style="MARGIN: 13pt 0cm"> 
     <strong><font size="4">结束语：</font></strong> 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      Java语言反射提供一种动态链接程序组件的多功能方法。它允许程序创建和控制任何类的对象(根据安全性限制)，无需提前硬编码目标类。这些特性使得反射特别适用于创建以非常普通的方式与对象协作的库。例如，反射经常在持续存储对象为数据库、XML或其它外部格式的框架中使用。Java reflection 非常有用，它使类和数据结构能按名称动态检索相关信息，并允许在运行着的程序中操作这些信息。Java 的这一特性非常强大，并且是其它一些常用语言，如 C、C++、Fortran 或者 Pascal 等都不具备的。 
    </div> 
    <div style="TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">
      但反射有两个缺点。第一个是性能问题。用于字段和方法接入时反射要远慢于直接代码。性能问题的程度取决于程序中是如何使用反射的。如果它作为程序运行中相对很少涉及的部分，缓慢的性能将不会是一个问题。即使测试中最坏情况下的计时图显示的反射操作只耗用几微秒。仅反射在性能关键的应用的核心逻辑中使用时性能问题才变得至关重要。 
    </div> 
    <div style="LINE-HEIGHT: 150%">
      许多应用中更严重的一个缺点是使用反射会模糊程序内部实际要发生的事情。程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术会带来维护问题。反射代码比相应的直接代码更复杂，正如性能比较的代码实例中看到的一样。解决这些问题的最佳方案是保守地使用反射——仅在它可以真正增加灵活性的地方——记录其在目标类中的使用。 
    </div> 
    <div>
        
    </div> 
    <div>
        
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="center">
      利用 
     <strong>反射</strong>实现 
     <strong>类</strong>的动态加载 
     <br> 
     <br> 
     <br> 
    </div> 
    <div align="left">
      Bromon原创 请尊重版权 
    </div> 
    <div align="left">
      最近在成都写一个 
     <strong>移动增值项目</strong>，俺负责后台server端。功能很简单，手机用户通过GPRS打开Socket与服务器连接，我则根据用户传过来的数据做出响应。做过 
     <strong>类</strong>似项目的兄弟一定都知道，首先需要定义一个 
     <strong>类</strong>似于MSNP的通讯协议，不过今天的话题是如何把这个系统设计得具有高度的扩展性。由于这个项目本身没有进行过较为完善的客户沟通和需求分析，所以以后肯定会有很多功能上的扩展，通讯协议肯定会越来越庞大，而我作为一个不那么勤快的人，当然不想以后再去修改写好的程序，所以这个项目是实践面向对象设计的好机会。 
    </div> 
    <div align="left">
      首先定义一个接口来隔离 
     <strong>类</strong>： 
    </div> 
    <div align="left">
      package org.bromon.reflect; 
    </div> 
    <div align="left">
      public interface Operator 
    </div> 
    <div align="left">
      { 
    </div> 
    <div align="left">
      public java.util.List act(java.util.List params) 
    </div> 
    <div align="left">
      } 
    </div> 
    <div align="left">
      根据设计模式的原理，我们可以为不同的功能编写不同的 
     <strong>类</strong>，每个 
     <strong>类</strong>都继承Operator接口，客户端只需要针对Operator接口编程就可以避免很多麻烦。比如这个 
     <strong>类</strong>： 
    </div> 
    <div align="left">
      package org.bromon.reflect.*; 
    </div> 
    <div align="left">
      public class Success implements Operator 
    </div> 
    <div align="left">
      { 
    </div> 
    <div align="left">
      public java.util.List act(java.util.List params) 
    </div> 
    <div align="left">
      { 
    </div> 
    <div align="left">
      List result=new ArrayList(); 
    </div> 
    <div align="left">
      result.add(new String(“操作成功”)); 
    </div> 
    <div align="left">
      return result; 
    </div> 
    <div align="left">
      } 
    </div> 
    <div align="left">
      } 
    </div> 
    <div align="left">
      我们还可以写其他很多 
     <strong>类</strong>，但是有个问题，接口是无法实例化的，我们必须手动控制具体实例化哪个 
     <strong>类</strong>，这很不爽，如果能够向应用程序传递一个参数，让自己去选择实例化一个 
     <strong>类</strong>，执行它的act方法，那我们的工作就轻松多了。 
    </div> 
    <div align="left">
      很幸运，我使用的是Java，只有Java才提供这样的 
     <strong>反射</strong>机制，或者说内省机制，可以实现我们的无理要求。编写一个配置文件emp.properties: 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      #成功响应 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      1000=Success 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      #向客户发送普通文本消息 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      2000=Load 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      #客户向服务器发送普通文本消息 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      3000=Store 
    </div> 
    <div style="TEXT-INDENT: 21pt" align="left">
      文件中的键名是客户将发给我的消息头，客户发送1000给我，那么我就执行Success 
     <strong>类</strong>的act方法， 
     <strong>类</strong>似的如果发送2000给我，那就执行Load 
     <strong>类</strong>的act方法，这样一来系统就完全符合开闭原则了，如果要添加新的功能，完全不需要修改已有代码，只需要在配置文件中添加对应规则，然后编写新的 
     <strong>类</strong>，实现act方法就ok，即使我弃这个项目而去，它将来也可以很好的扩展。这样的系统具备了非常良好的扩展性和可插入性。 
    </div> 
    <div style="TEXT-INDENT: 21pt" align="left">
      下面这个例子体现了动态加载的功能，程序在执行过程中才知道应该实例化哪个 
     <strong>类</strong>： 
    </div> 
    <div align="left">
      package org.bromon.reflect.*; 
    </div> 
    <div align="left">
      import java.lang.reflect.*; 
    </div> 
    <div align="left">
      public class TestReflect 
    </div> 
    <div align="left">
      { 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      //加载配置文件,查询消息头对应的 
     <strong>类</strong>名 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      private String loadProtocal(String header) 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      { 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      String result=null; 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      try 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      { 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      Properties prop=new Properties(); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      FileInputStream fis=new FileInputStream("emp.properties"); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      prop.load(fis); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      result=prop.getProperty(header); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      fis.close(); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      }catch(Exception e) 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      { 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      System.out.println(e); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      } 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      return result; 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      } 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      //针对消息作出响应,利用 
     <strong>反射</strong>导入对应的 
     <strong>类</strong> 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      public String response(String header,String content) 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      { 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      String result= 
     <strong>null</strong>; 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      String s= 
     <strong>null</strong>; 
    </div> 
    <div align="left"> 
     <strong>try</strong> 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      { 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      /* 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      * 导入属性文件emp.properties,查询header所对应的 
     <strong>类</strong>的名字 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      * 通过 
     <strong>反射</strong>机制动态加载匹配的 
     <strong>类</strong>,所有的 
     <strong>类</strong>都被Operator接口隔离 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      * 可以通过修改属性文件、添加新的 
     <strong>类</strong>(继承MsgOperator接口)来扩展协议 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      */ 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      s="org.bromon.reflect."+ 
     <strong>this</strong>.loadProtocal(header); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      //加载 
     <strong>类</strong> 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      Class c=Class.forName(s); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      //创建 
     <strong>类</strong>的事例 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      Operator mo=(Operator)c.newInstance(); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      //构造参数列表 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      Class params[]= 
     <strong>new</strong> Class[1]; 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      params[0]=Class.forName("java.util.List"); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      //查询act方法 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      Method m=c.getMethod("act",params); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      Object args[]= 
     <strong>new</strong> Object[1]; 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      args[0]=content; 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      //调用方法并且获得返回 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      Object returnObject=m.invoke(mo,args); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      } 
     <strong>catch</strong>(Exception e) 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      { 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      System.out.println("Handler-response:"+e); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      } 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left"> 
     <strong>return</strong> result; 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      } 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      public static void main(String args[]) 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      { 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      TestReflect tr=new TestReflect(); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      tr.response(args[0],”消息内容”); 
    </div> 
    <div style="MARGIN: 0cm 0cm 12pt" align="left">
      } 
    </div> 
    <div align="left">
      } 
    </div> 
    <div style="TEXT-INDENT: 21pt" align="left">
      测试一下：java TestReflect 1000 
    </div> 
    <div align="left">
      这个程序是针对Operator编程的，所以无需做任何修改，直接提供Load和Store 
     <strong>类</strong>，就可以支持2000、3000做参数的调用。 
    </div> 
    <div align="left">
      有了这样的内省机制，可以把接口的作用发挥到极至，设计模式也更能体现出威力，而不仅仅供我们饭后闲聊。 
    </div> </td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c60943e9710c5ff61fd7697be5797a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DXUT编程指南(三):通过DXUT使用程序窗口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e6d9e7d589e04ed2928ba1a3baeb0ccc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用c语言写的base64编码解码函数！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>