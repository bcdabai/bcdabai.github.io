<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>super - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="super" />
<meta property="og:description" content="react中的super
1、为什么一定要在constructor中调用super
答案：如果一个子类，通过extends关键字继承父类，那么，在子类的constructor构造函数中，必须优先调用一下super()
2、super是什么东西
答案：super是一个函数，而且，它是父类的构造器，子类中的super，其实就是父类中construct构造器的一个引用
3、为什么调用super()之后，p中的name和age变成了undefined
class Hello extends React.Component{ constructor(name,age){ super() this.name = name this.age = age } } const p = new Hello(&#39;terry&#39;,23) console.log(p) ===========================
super关键字即可做函数使用，也可做对象使用，两种情况，用法完全不同
constructor 是一种用于创建和初始化class创建的对象的特殊方法。
（1）super做函数使用
class A { constructor() { console.log(new.target.name); // new.target 指向当前正在执行的函数 } } class B extends A{ constructor(){ //构造函数 super() //es6要求，子类的构造函数必须执行一次super()函数，否则会报错 } } new A() //A new B() //B 注意：在constructor中必须调用super方法，因为子类没有自己的this对象，而是继承父类的this对象
super代表父类的构造函数，但返回子类的实例，即super内部的this指向B
所以，super()在这里相当于A.prototype.constructor.call(this, props)
(2)当对象使用
1）在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
class A { c() { return 2; } } class B extends A { constructor() { super(); console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1b3231655cebb7a1f783eddf27d254ca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-02T17:09:34+08:00" />
<meta property="article:modified_time" content="2020-11-02T17:09:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">super</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>react中的super<br> 1、为什么一定要在constructor中调用super<br> 答案：如果一个子类，通过extends关键字继承父类，那么，在子类的constructor构造函数中，必须优先调用一下super()<br> 2、super是什么东西<br> 答案：super是一个函数，而且，它是父类的构造器，子类中的super，其实就是父类中construct构造器的一个引用<br> 3、为什么调用super()之后，p中的name和age变成了undefined</p> 
<pre><code>class Hello extends React.Component{
            constructor(name,age){
            	super()
                this.name = name
                this.age = age
            }                
        }      
        const p = new Hello('terry',23)
        console.log(p)
</code></pre> 
<p>===========================<br> super关键字即可做函数使用，也可做对象使用，两种情况，用法完全不同<br> constructor 是一种用于创建和初始化class创建的对象的特殊方法。<br> （1）super做函数使用</p> 
<pre><code>class A {
  constructor() {
    console.log(new.target.name); // new.target 指向当前正在执行的函数
  }
}
class B extends A{
  constructor(){   //构造函数
    super()  //es6要求，子类的构造函数必须执行一次super()函数，否则会报错
  }
}

new A()  //A
new B() //B
</code></pre> 
<p>注意：在constructor中必须调用super方法，因为子类没有自己的this对象，而是继承父类的this对象<br> super代表父类的构造函数，但返回子类的实例，即super内部的this指向B<br> 所以，super()在这里相当于A.prototype.constructor.call(this, props)</p> 
<p>(2)当对象使用<br> 1）在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p> 
<pre><code>class A {
  c() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();
    console.log(super.c()); // 2
  }
}

let b = new B();
</code></pre> 
<p>子类 B 当中的 super.c()，就是将 super 当作一个对象使用。<br> 这时，super 在普通方法之中，指向 A.prototype，所以 super.c() 就相当于 A.prototype.c()。</p> 
<p>2）通过 super 调用父类的方法时，super 会绑定子类的 this。</p> 
<pre><code>class A {
  constructor() {
    this.x = 1;
  }
  s() {
    console.log(this.x);
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
  }
  m() {
    super.s();
  }
}

let b = new B();
b.m(); // 2
</code></pre> 
<p>上面代码中，super.s() 虽然调用的是 A.prototytpe.s()，但是 A.prototytpe.s()会绑定子类 B 的 this，导致输出的是 2，而不是 1。也就是说，实际上执行的是 super.s.call(this)。</p> 
<p>3）由于绑定子类的 this，所以如果通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性。</p> 
<pre><code>class A {
  constructor() {
    this.x = 1;
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  }
}

let b = new B();
</code></pre> 
<p>上面代码中，super.x 赋值为 3，这时等同于对 this.x 赋值为 3。而当读取 super.x 的时候，调用的是 A.prototype.x，但并没有 x 方法，所以返回 undefined。</p> 
<p>4）注意，使用 super 的时候，必须显式指定是作为函数，还是作为对象使用，否则会报错。</p> 
<pre><code>class A {}
class B extends A {
  constructor() {
    super();
    console.log(super); // 报错
  }
}
</code></pre> 
<p>静态方法：在构造函数本身上定义的方法，只能通过构造函数本身调用，new出来的对象不能够调用。<br> 实例代码：</p> 
<pre><code>//创建构造函数f1
  function f1(){}

  //静态方法
  f1.static = function(){
      console.log("我是一个静态方法");
  }
  f1.static();        //  我是一个静态方法
</code></pre> 
<p>es6中super<br> class类有两个关键字：static和super<br> <strong>super不仅是关键字，还可作为函数对象</strong></p> 
<p><strong>函数</strong>：在子类继承父类中，super作为函数调用，只能写在子类的构造函数里，super代表父类的构造函数</p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
	&lt;meta charset="UTF-8"&gt;
	&lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;script&gt;
		//Animal类
		class Animal{
			//1.构造函数
			constructor(name,age){
				this.name=name;
				this.age=age;
			}
			//2.普通方法
			sayName(){
				console.log("my name is",this.name);
			}
			sayAge(){
				console.log('my age is',this.age);
			}
		}
		//原型链继承
		class Dog extends Animal{
			constructor(name,age,gender){
				//等价于借用构造函数
				super(name,age)
				this.gender=gender;
			}
			sayGender(){
				console.log("my gender is",this.gender);
			}

		}
		let d = new Dog("一休",2,"male");
		console.log(d);
		d.sayName();
		d.sayAge();
		d.sayGender();
	&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>执行过时super()代表的是子类，super()里面的this指向子类的实例对象</p> 
<p><strong>对象</strong>：super作为对象使用时，分为普通方法中使用和在静态方法中使用</p> 
<p>普通方法中：super指向父类的原型，即A.prototype,可以访问到原型中的方法和属性</p> 
<p>ES6规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1bcf51c9db5cb5cc405d9f4c30f2564c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">错误代码:com.netflix.discovery.AbstractDiscoveryClientOptionalA</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae373fc26187d7a2766952caf34c3ce3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PostgreSQL查询账号所拥有的表权限</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>