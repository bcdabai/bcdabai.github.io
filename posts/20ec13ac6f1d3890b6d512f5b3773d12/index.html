<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Autowired实现原理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Autowired实现原理" />
<meta property="og:description" content="一、认识@Autowired
@Autowired
替换：autowire属性,自动装配（按照类型装配，通过set方法，且方法可以省略）
位置：修饰属性，set方法
语法：@Autowired(required=&#34;true&#34;)
注意：1.如果容器中没有一个可以与之匹配且required属性为true则会报异常
NoSuchBeanDefinitionException
2.如果容器中有多个可以类型可以与之匹配，则自动切换为按照名称装配
3.如果容器中有多个可以类型可以与之匹配，则自动切换为按照名称装配，如果名称也没有匹配，则报异常 NoUniqueBeanDefinitionException
@Autowired提供required的属性，用来处理当注入的Bean实例不存在的情况。
required为true时，如果注入的Bean实例不存在，程序会抛出异常；
required为false时，如果注入的Bean实例不存在，程序会忽略。
二、@Autowired的操作思路：
解析谁要进行注入==》查找依赖的来源==》注入的一个对象。 从源码中看到它可以被标注在构造函数、属性、setter方法或配置方法上，用于实现依赖自动注入。
@Autowired注解的作用是由AutowiredAnnotationBeanPostProcessor实现的，查看该类的源码会发现它实现了MergedBeanDefinitionPostProcessor接口，进而实现了接口中的postProcessMergedBeanDefinition方法，@Autowired注解正是通过这个方法实现注入类型的预解析，将需要依赖注入的属性信息封装到InjectionMetadata类中，InjectionMetadata类中包含了哪些需要注入的元素及元素要注入到哪个目标类中，在Spring容器启动的过程中初始化单例bean的时候通过populateBean方法实现对属性的注入。
Spring容器在启动的时候会执行AbstractApplicationContext类的refresh方法，在refresh方法执行的过程中先注册AutowiredAnnotationBeanPostProcessor，然后在对非延迟初始化的单例bean进行初始化时，会间接调用。
refresh方法中registerBeanPostProcessors(beanFactory)完成了对AutowiredAnnotationBeanPostProcessor的注册，当执行finishBeanFactoryInitialization(beanFactory)方法对非延迟初始化的单例bean进行初始化时，会执行到AbstractAutowireCapableBeanFactory类的doCreateBean方法
在这段代码中会执行applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName)，深入到这个applyMergedBeanDefinitionPostProcessors方法中
查看postProcessMergedBeanDefinition方法的具体实现类，会发现这里调用的是AutowiredAnnotationBeanPostProcessor类的postProcessMergedBeanDefinition方法，也就是开头介绍的在这个方法中完成了对注入元素注解的预解析。
同样，在doCreateBean方法中执行populateBean方法实现对属性的注入。
metadata.inject(bean, beanName, pvs)代码的执行会进入如下inject方法中，在这里完成依赖的注入。
InjectedElement有两个子类，分别是AutowiredFieldElement和AutowiredMethodElement。Spring的优秀不仅在抽象封装上，连命名都是那么的出色。从类名上可以很容易的看出，AutowiredFieldElement用于对标注在属性上的注入，AutowiredMethodElement用于对标注在方法上的注入。两种方式的注入过程都差不多，根据需要注入的元素的描述信息，按类型或名称查找需要的依赖值，如果依赖没有实例化先实例化依赖，然后使用反射进行赋值。
总结：@Autowied是spring的重要注解，虽然理解困难，但是它的本质永远是new对象，因为spring的核心思想就是IOC，程序员不需要new对象，只是将控制权给了spring框架，由它在底层通过注解或者配置文件帮我们new对象。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/20ec13ac6f1d3890b6d512f5b3773d12/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-24T20:47:35+08:00" />
<meta property="article:modified_time" content="2022-10-24T20:47:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Autowired实现原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、认识@Autowired</p> 
<p>@Autowired<br>     替换：autowire属性,自动装配（按照类型装配，通过set方法，且方法可以省略）<br>     位置：修饰属性，set方法<br>     语法：@Autowired(required="true")<br>     注意：1.如果容器中没有一个可以与之匹配且required属性为true则会报异常<br>                   NoSuchBeanDefinitionException<br>                2.如果容器中有多个可以类型可以与之匹配，则自动切换为按照名称装配<br>                3.如果容器中有多个可以类型可以与之匹配，则自动切换为按照名称装配，如果名称也没有匹配，则报异常 NoUniqueBeanDefinitionException</p> 
<blockquote> 
 <p>@Autowired提供required的属性，用来处理当注入的Bean实例不存在的情况。</p> 
 <p>required为true时，如果注入的Bean实例不存在，程序会抛出异常；</p> 
 <p>required为false时，如果注入的Bean实例不存在，程序会忽略。</p> 
</blockquote> 
<p>二、@Autowired的操作思路：</p> 
<p>       解析谁要进行注入==》查找依赖的来源==》注入的一个对象。 </p> 
<p>从源码中看到它可以被标注在构造函数、属性、setter方法或配置方法上，用于实现依赖自动注入。</p> 
<p><img alt="" height="196" src="https://images2.imgbox.com/e2/3a/77jgDPn3_o.png" width="1200"></p> 
<p>@Autowired注解的作用是由AutowiredAnnotationBeanPostProcessor实现的，查看该类的源码会发现它实现了MergedBeanDefinitionPostProcessor接口，进而实现了接口中的postProcessMergedBeanDefinition方法，@Autowired注解正是通过这个方法实现注入类型的预解析，将需要依赖注入的属性信息封装到InjectionMetadata类中，InjectionMetadata类中包含了哪些需要注入的元素及元素要注入到哪个目标类中，在Spring容器启动的过程中初始化单例bean的时候通过populateBean方法实现对属性的注入。</p> 
<p><img alt="" height="60" src="https://images2.imgbox.com/72/32/zn1k9U2Q_o.png" width="1200"></p> 
<p> <img alt="" height="113" src="https://images2.imgbox.com/27/e2/2hiDpm8N_o.png" width="1103"></p> 
<p> <img alt="" height="549" src="https://images2.imgbox.com/c7/dc/qq6NESNC_o.png" width="1040"></p> 
<p> Spring容器在启动的时候会执行AbstractApplicationContext类的refresh方法，在refresh方法执行的过程中先注册AutowiredAnnotationBeanPostProcessor，然后在对非延迟初始化的单例bean进行初始化时，会间接调用。</p> 
<p> refresh方法中registerBeanPostProcessors(beanFactory)完成了对AutowiredAnnotationBeanPostProcessor的注册，当执行finishBeanFactoryInitialization(beanFactory)方法对非延迟初始化的单例bean进行初始化时，会执行到AbstractAutowireCapableBeanFactory类的doCreateBean方法</p> 
<p>在这段代码中会执行applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName)，深入到这个applyMergedBeanDefinitionPostProcessors方法中</p> 
<p>查看postProcessMergedBeanDefinition方法的具体实现类，会发现这里调用的是AutowiredAnnotationBeanPostProcessor类的postProcessMergedBeanDefinition方法，也就是开头介绍的在这个方法中完成了对注入元素注解的预解析。</p> 
<p>同样，在doCreateBean方法中执行populateBean方法实现对属性的注入。</p> 
<p>metadata.inject(bean, beanName, pvs)代码的执行会进入如下inject方法中，在这里完成依赖的注入。</p> 
<p>InjectedElement有两个子类，分别是AutowiredFieldElement和AutowiredMethodElement。Spring的优秀不仅在抽象封装上，连命名都是那么的出色。从类名上可以很容易的看出，AutowiredFieldElement用于对标注在属性上的注入，AutowiredMethodElement用于对标注在方法上的注入。两种方式的注入过程都差不多，根据需要注入的元素的描述信息，按类型或名称查找需要的依赖值，如果依赖没有实例化先实例化依赖，然后使用反射进行赋值。</p> 
<blockquote> 
 <p>总结：@Autowied是spring的重要注解，虽然理解困难，但是它的本质永远是new对象，因为spring的核心思想就是IOC，程序员不需要new对象，只是将控制权给了spring框架，由它在底层通过注解或者配置文件帮我们new对象。</p> 
</blockquote> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/760abd5de8af8ca989060bbd3d27492f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java获取当前时间的前一天时间</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c08dedaf680da9995ac37b255d50b0f5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">@Autowired注解的实现原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>