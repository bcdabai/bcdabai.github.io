<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java Set集合的详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java Set集合的详解" />
<meta property="og:description" content="一，Set Set:注重独一无二的性质,该体系集合可以知道某物是否已近存在于集合中,不会存储重复的元素 用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。
对象的相等性
引用到堆上同一个对象的两个引用是相等的。如果对两个引用调用hashCode方法，会得到相同的结果，如果对象所属的类没有覆盖Object的hashCode方法的话，hashCode会返回每个对象特有的序号（java是依据对象的内存地址计算出的此序号），所以两个不同的对象的hashCode值是不可能相等的。
如果想要让两个不同的Person对象视为相等的，就必须覆盖Object继下来的hashCode方法和equals方法，因为Object hashCode方法返回的是该对象的内存地址，所以必须重写hashCode方法，才能保证两个不同的对象具有相同的hashCode，同时也需要两个不同对象比较equals方法会返回true
该集合中没有特有的方法，直接继承自Collection。
---| Itreable 接口 实现该接口可以使用增强for循环 ---| Collection	描述所有集合共性的接口 ---| List接口	可以有重复元素的集合 ---| ArrayList ---| LinkedList ---| Set接口	不可以有重复元素的集合 案例：set集合添加元素并使用迭代器迭代元素。
public class Demo4 { public static void main(String[] args) { //Set 集合存和取的顺序不一致。 Set hs = new HashSet(); hs.add(&#34;世界军事&#34;); hs.add(&#34;兵器知识&#34;); hs.add(&#34;舰船知识&#34;); hs.add(&#34;汉和防务&#34;); System.out.println(hs); // [舰船知识, 世界军事, 兵器知识, 汉和防务] Iterator it = hs.iterator(); while (it.hasNext()) { System.out.println(it.next()); } } } 二，HashSet ---| Itreable 接口 实现该接口可以使用增强for循环 ---| Collection	描述所有集合共性的接口 ---| List接口	可以有重复元素的集合 ---| ArrayList ---| LinkedList ---| Set接口	不可以有重复元素的集合 ---| HashSet 线程不安全，存取速度快。底层是以哈希表实现的。 HashSet" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/85c5ada20540e73ed4597cdca210825a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-07-26T22:39:17+08:00" />
<meta property="article:modified_time" content="2016-07-26T22:39:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java Set集合的详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><span style="font-weight:normal"><span style="font-size:14px; color:#ff0000">一，Set</span></span></h3> 
<h3><span style="font-weight:normal"><span style="font-size:14px; color:#ff0000">Set:<span style="font-family:宋体">注重独一无二的性质</span><span style="font-family:'Times New Roman'">,</span><span style="font-family:宋体">该体系集合可以知道某物是否已近存在于集合中</span><span style="font-family:'Times New Roman'">,</span><span style="font-family:宋体">不会存储重复的元素</span></span></span></h3> 
<p><span style="font-size:14px">用于存储无序<span style="font-family:Times New Roman">(</span><span style="font-family:宋体">存入和取出的顺序不一定相同</span><span style="font-family:Times New Roman">)</span><span style="font-family:宋体">元素，值不能重复。</span></span></p> 
<p><span style="font-size:14px">对象的相等性</span></p> 
<p><span style="font-size:14px">   引用到堆上同一个对象的两个引用是相等的。如果对两个引用调用hashCode方法，会得到相同的结果，如果对象所属的类没有覆盖Object的hashCode方法的话，hashCode会返回每个对象特有的序号（java是依据对象的内存地址计算出的此序号），所以两个不同的对象的hashCode值是不可能相等的。</span></p> 
<p><span style="font-size:14px">如果想要让两个不同的Person对象视为相等的，就必须覆盖Object继下来的hashCode方法和equals方法，因为Object  hashCode方法返回的是该对象的内存地址，所以必须重写hashCode方法，才能保证两个不同的对象具有相同的hashCode，同时也需要两个不同对象比较equals方法会返回true</span></p> 
<p><span style="font-size:14px">该集合中没有特有的方法，直接继承自<span style="font-family:Courier New">Collection</span><span style="font-family:宋体">。</span></span></p> 
<p><span style="font-size:14px"><span style="font-family:宋体"></span></span></p> 
<pre><code class="language-java">---| Itreable      接口 实现该接口可以使用增强for循环
				---| Collection		描述所有集合共性的接口
					---| List接口	    可以有重复元素的集合
                            ---| ArrayList   
                            ---|  LinkedList
					---| Set接口	    不可以有重复元素的集合</code></pre> 
<p></p> 
<p><span style="font-size:14px"><span style="font-family:宋体"></span></span></p> 
<p>案例：set集合添加元素并使用迭代器迭代元素。</p> 
<pre><code class="language-java">public class Demo4 {
	public static void main(String[] args) {
		//Set 集合存和取的顺序不一致。
		Set hs = new HashSet();
		hs.add("世界军事");
		hs.add("兵器知识");
		hs.add("舰船知识");
		hs.add("汉和防务");
		System.out.println(hs);
		// [舰船知识, 世界军事, 兵器知识, 汉和防务]
		Iterator it = hs.iterator();
		while (it.hasNext()) {
			System.out.println(it.next());
		}
	}
}</code></pre> 
<span style="color:#ff0000">二，HashSet</span> 
<p><span style="font-size:14px"><span style="font-family:宋体"></span></span></p> 
<pre><code class="language-java">---| Itreable      接口 实现该接口可以使用增强for循环
				---| Collection		描述所有集合共性的接口
					---| List接口	    可以有重复元素的集合
                            ---| ArrayList   
                            ---|  LinkedList
					---| Set接口	    不可以有重复元素的集合
                            ---| HashSet  线程不安全，存取速度快。底层是以哈希表实现的。</code></pre> 
<p></p> 
<p>HashSet</p> 
<p>哈希表边存放的是哈希值。<span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">存储元素的顺序并不是按照存入时的顺序（和</span><span style="font-family:Courier New">List</span><span style="font-family:宋体">显然不同） 是按照哈希值来存的所以取数据也是按照哈希值取得。</span></p> 
<p>HashSet<span style="font-family:宋体">不存入重复元素的规则</span><span style="font-family:Courier New">.</span><span style="font-family:宋体">使用</span><span style="font-family:Courier New">hashcode</span><span style="font-family:宋体">和</span><span style="font-family:Courier New">equals</span></p> 
<p>由于<span style="font-family:Courier New">Set</span><span style="font-family:宋体">集合是不能存入重复元素的集合。那么</span><span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">也是具备这一特性的。</span><span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">如何检查重复？</span><span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">会通过元素的</span><span style="font-family:Courier New">hashcode</span><span style="font-family:宋体">（）和</span><span style="font-family:Courier New">equals</span><span style="font-family:宋体">方法进行判断元素师否重复。</span></p> 
<p>当你试图把对象加入<span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">时，</span><span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">会使用对象的</span><span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">来判断对象加入的位置。同时也会与其他已经加入的对象的</span><span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">进行比较，如果没有相等的</span><span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">，</span><span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">就会假设对象没有重复出现。</span></p> 
<p>简单一句话，如果对象的<span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">值是不同的，那么</span><span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">会认为对象是不可能相等的。</span></p> 
<p>因此我们自定义类的时候需要重写<span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">，来确保对象具有相同的</span><span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">值。</span></p> 
<p>如果元素<span style="font-family:Courier New">(</span><span style="font-family:宋体">对象</span><span style="font-family:Courier New">)</span><span style="font-family:宋体">的</span><span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">值相同</span><span style="font-family:Courier New">,</span><span style="font-family:宋体">是不是就无法存入</span><span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">中了</span><span style="font-family:Courier New">? </span><span style="font-family:宋体">当然不是</span><span style="font-family:Courier New">,</span><span style="font-family:宋体">会继续使用</span><span style="font-family:Courier New">equals </span><span style="font-family:宋体">进行比较</span><span style="font-family:Courier New">.</span><span style="font-family:宋体">如果 </span><span style="font-family:Courier New">equals</span><span style="font-family:宋体">为</span><span style="font-family:Courier New">true </span><span style="font-family:宋体">那么</span><span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">认为新加入的对象重复了</span><span style="font-family:Courier New">,</span><span style="font-family:宋体">所以加入失败。如果</span><span style="font-family:Courier New">equals </span><span style="font-family:宋体">为</span><span style="font-family:Courier New">false</span><span style="font-family:宋体">那么</span><span style="font-family:Courier New">HashSet </span><span style="font-family:宋体">认为新加入的对象没有重复</span><span style="font-family:Courier New">.</span><span style="font-family:宋体">新元素可以存入</span><span style="font-family:Courier New">.</span></p> 
<p>总结：</p> 
<p>元素的哈希值是通过元素的<span style="font-family:Courier New">hashcode</span><span style="font-family:宋体">方法 来获取的</span><span style="font-family:Courier New">, HashSet</span><span style="font-family:宋体">首先判断两个元素的哈希值，如果哈希值一样，接着会比较</span><span style="font-family:Courier New">equals</span><span style="font-family:宋体">方法 如果 </span><span style="font-family:Courier New">equls</span><span style="font-family:宋体">结果为</span><span style="font-family:Courier New">true </span><span style="font-family:宋体">，</span><span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">就视为同一个元素。如果</span><span style="font-family:Courier New">equals </span><span style="font-family:宋体">为</span><span style="font-family:Courier New">false</span><span style="font-family:宋体">就不是同一个元素。</span></p> 
<p>哈希值相同<span style="font-family:Courier New">equals</span><span style="font-family:宋体">为</span><span style="font-family:Courier New">false</span><span style="font-family:宋体">的元素是怎么存储呢</span><span style="font-family:Courier New">,</span><span style="font-family:宋体">就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。</span></p> 
<p>hashtable</p> 
<p><img src="https://images2.imgbox.com/6c/16/MmFmzUZA_o.png" alt=""><br> </p> 
<p></p> 
<p>图<span style="font-family:Courier New">1</span><span style="font-family:宋体">：</span><span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">值不相同的情况</span></p> 
<p>图<span style="font-family:Courier New">2</span><span style="font-family:宋体">：</span><span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">值相同，但</span><span style="font-family:Courier New">equals</span><span style="font-family:宋体">不相同的情况。</span></p> 
<p>HashSet<span style="font-family:宋体">：通过</span><span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">值来确定元素在内存中的位置。一个</span><span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">位置上可以存放多个元素。</span></p> 
<p>当<span style="font-family:Courier New">hashcode() </span><span style="font-family:宋体">值相同</span><span style="font-family:Courier New">equals() </span><span style="font-family:宋体">返回为</span><span style="font-family:Courier New">true </span><span style="font-family:宋体">时</span><span style="font-family:Courier New">,hashset </span><span style="font-family:宋体">集合认为这两个元素是相同的元素</span><span style="font-family:Courier New">.</span><span style="font-family:宋体">只存储一个（重复元素无法放入）。调用原理</span><span style="font-family:Courier New">:</span><span style="font-family:宋体">先判断</span><span style="font-family:Courier New">hashcode </span><span style="font-family:宋体">方法的值</span><span style="font-family:Courier New">,</span><span style="font-family:宋体">如果相同才会去判断</span><span style="font-family:Courier New">equals </span><span style="font-family:宋体">如果不相同</span><span style="font-family:Courier New">,</span><span style="font-family:宋体">是不会调用</span><span style="font-family:Courier New">equals</span><span style="font-family:宋体">方法的。</span></p> 
<br> 
<p></p> 
<p><span style="color:#ff0000">HashSet<span style="font-family:宋体">到底是如何判断两个元素重复。</span></span></p> 
<p>通过hashCode方法和equals方法来保证元素的唯一性，add()返回的是boolean类型</p> 
<p>判断两个元素是否相同，先要判断元素的<span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">值是否一致，只有在该值一致的情况下，才会判断</span><span style="font-family:Courier New">equals</span><span style="font-family:宋体">方法</span>，如果存储在HashSet中的两个对象hashCode方法的值相同equals方法返回的结果是true，那么HashSet认为这两个元素是相同元素，只存储一个（重复元素无法存入）。</p> 
<p>注意：<span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">集合在判断元素是否相同先判断</span><span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">方法，如果相同才会判断</span><span style="font-family:Courier New">equals</span><span style="font-family:宋体">。如果不相同，是不会调用</span><span style="font-family:Courier New">equals</span><span style="font-family:宋体">方法的。</span></p> 
<p> </p> 
<p>HashSet <span style="font-family:宋体">和</span><span style="font-family:Courier New">ArrayList</span><span style="font-family:宋体">集合都有判断元素是否相同的方法，</span></p> 
<p>boolean contains(Object o)</p> 
<p>HashSet<span style="font-family:宋体">使用</span><span style="font-family:Courier New">hashCode</span><span style="font-family:宋体">和</span><span style="font-family:Courier New">equals</span><span style="font-family:宋体">方法，</span><span style="font-family:Courier New">ArrayList</span><span style="font-family:宋体">使用了</span><span style="font-family:Courier New">equals</span><span style="font-family:宋体">方法</span></p> 
<br> 
<p>案例：</p> 
<p>使用<span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">存储字符串，并尝试添加重复字符串</span></p> 
<p>回顾<span style="font-family:Courier New">String</span><span style="font-family:宋体">类的</span><span style="font-family:Courier New">equals()</span><span style="font-family:宋体">、</span><span style="font-family:Courier New">hashCode()</span><span style="font-family:宋体">两个方法。</span></p> 
<p><span style="font-family:宋体"></span></p> 
<pre><code class="language-java">public class Demo4 {
	public static void main(String[] args) {
		// Set 集合存和取的顺序不一致。
		Set hs = new HashSet();
		hs.add("世界军事");
		hs.add("兵器知识");
		hs.add("舰船知识");
		hs.add("汉和防务");

		// 返回此 set 中的元素的数量
		System.out.println(hs.size()); // 4

		// 如果此 set 尚未包含指定元素，则返回 true
		boolean add = hs.add("世界军事"); // false
		System.out.println(add);

		// 返回此 set 中的元素的数量
		System.out.println(hs.size());// 4
		Iterator it = hs.iterator();
		while (it.hasNext()) {
			System.out.println(it.next());
		}
	}
}</code></pre> 
<br> 
<p></p> 
<p>使用<span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">存储自定义对象，并尝试添加重复对象（对象的重复的判定）</span></p> 
<pre><code class="language-java">public class Demo4 {
	public static void main(String[] args) {
		HashSet hs = new HashSet();
		hs.add(new Person("jack", 20));
		hs.add(new Person("rose", 20));
		hs.add(new Person("hmm", 20));
		hs.add(new Person("lilei", 20));
		hs.add(new Person("jack", 20));

		Iterator it = hs.iterator();
		while (it.hasNext()) {
			Object next = it.next();
			System.out.println(next);
		}
	}
}

class Person {
	private String name;
	private int age;

	Person() {

	}

	public Person(String name, int age) {

		this.name = name;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public int hashCode() {
		System.out.println("hashCode:" + this.name);
		return this.name.hashCode() + age * 37;
	}

	@Override
	public boolean equals(Object obj) {
		System.out.println(this + "---equals---" + obj);
		if (obj instanceof Person) {
			Person p = (Person) obj;
			return this.name.equals(p.name) &amp;&amp; this.age == p.age;
		} else {
			return false;
		}
	}

	@Override
	public String toString() {

		return "Person@name:" + this.name + " age:" + this.age;
	}

}</code></pre> 
<br> 
<p>问题：现在有一批数据，要求不能重复存储元素，而且要排序。<span style="font-family:Courier New">ArrayList </span> <span style="font-family:宋体">、 </span><span style="font-family:Courier New">LinkedList</span><span style="font-family:宋体">不能去除重复数据。</span><span style="font-family:Courier New">HashSet</span><span style="font-family:宋体">可以去除重复，但是是无序。</span></p> 
<p><span style="font-family:宋体">所以这时候就要使用TreeSet了</span></p> 
<p><span style="font-family:宋体"><span style="color:#ff0000">三，TreeSet</span></span></p> 
<p><span style="font-family:宋体"></span></p> 
<p>案例：使用TreeSet集合存储字符串元素，并遍历</p> 
<pre><code class="language-java">public class Demo5 {
	public static void main(String[] args) {
		TreeSet ts = new TreeSet();
		ts.add("ccc");
		ts.add("aaa");
		ts.add("ddd");
		ts.add("bbb");

		System.out.println(ts); // [aaa, bbb, ccc, ddd]

	}
}</code></pre> 
<pre><code class="language-java">---| Itreable      接口 实现该接口可以使用增强for循环
				---| Collection		描述所有集合共性的接口
					---| List接口	    有序，可以重复，有角标的集合
                            ---| ArrayList   
                            ---|  LinkedList
					---| Set接口	    无序，不可以重复的集合
                            ---| HashSet  线程不安全，存取速度快。底层是以hash表实现的。
                            ---| TreeSet  红-黑树的数据结构，默认对元素进行自然排序（String）。如果在比较的时候两个对象返回值为0，那么元素重复。</code></pre> 
<p>红<span style="font-family:Courier New">-</span><span style="font-family:宋体">黑树</span></p> 
<p>红黑树是一种特定类型的二叉树</p> 
<img src="https://images2.imgbox.com/21/de/5xlwOUKc_o.png" alt=""> 
<br> 
<br> 
<p></p> 
<p>红黑树算法的规则: 左小右大。</p> 
<p><span style="color:#ff0000">既然<span style="font-family:Courier New">TreeSet</span><span style="font-family:宋体">可以自然排序</span><span style="font-family:Courier New">,</span><span style="font-family:宋体">那么</span><span style="font-family:Courier New">TreeSet</span><span style="font-family:宋体">必定是有排序规则的。</span></span></p> 
<p>1:<span style="font-family:宋体">让存入的元素自定义比较规则。</span></p> 
<p></p> 
<p>2:<span style="font-family:宋体">给</span><span style="font-family:Courier New">TreeSet</span><span style="font-family:宋体">指定排序规则。</span></p> 
<p>方式一：元素自身具备比较性</p> 
<p>元素自身具备比较性，需要元素实现Comparable接口，重写compareTo方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫做默认排序。</p> 
<p>方式二：容器具备比较性</p> 
<p>当元素自身不具备比较性，或者自身具备的比较性不是所需要的。那么此时可以让容器自身具备。需要定义一个类实现接口Comparator，重写compare方法，并将该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。</p> 
<p>注意：当Comparable比较方式和Comparator比较方式同时存在时，以Comparator的比较方式为主；</p> 
<p>注意：在重写compareTo或者compare方法时，必须要明确比较的主要条件相等时要比较次要条件。（假设姓名和年龄一直的人为相同的人，如果想要对人按照年龄的大小来排序，如果年龄相同的人，需要如何处理？不能直接<span style="font-family:Courier New">return 0</span><span style="font-family:宋体">，因为可能姓名不同（年龄相同姓名不同的人是不同的人）。此时就需要进行次要条件判断（需要判断姓名），只有姓名和年龄同时相等的才可以返回</span><span style="font-family:Courier New">0.</span><span style="font-family:宋体">）</span></p> 
<p>通过<span style="font-family:Courier New">return 0</span><span style="font-family:宋体">来判断唯一性。</span></p> 
<p> </p> 
<p>问题<span style="font-family:Courier New">:</span><span style="font-family:宋体">为什么使用</span><span style="font-family:Courier New">TreeSet</span><span style="font-family:宋体">存入字符串</span><span style="font-family:Courier New">,</span><span style="font-family:宋体">字符串默认输出是按升序排列的</span><span style="font-family:Courier New">?</span><span style="font-family:宋体">因为字符串实现了一个接口</span><span style="font-family:Courier New">,</span><span style="font-family:宋体">叫做</span>Comparable 接口<span style="font-family:Courier New">.</span><span style="font-family:宋体">字符串重写了该接口的</span>compareTo 方法<span style="font-family:Courier New">,</span><span style="font-family:宋体">所以</span><span style="font-family:Courier New">String</span><span style="font-family:宋体">对象具备了比较性</span><span style="font-family:Courier New">.</span><span style="font-family:宋体">那么同样道理</span><span style="font-family:Courier New">,</span><span style="font-family:宋体">我的自定义元素</span><span style="font-family:Courier New">(</span><span style="font-family:宋体">例如</span><span style="font-family:Courier New">Person</span><span style="font-family:宋体">类</span><span style="font-family:Courier New">,Book</span><span style="font-family:宋体">类</span><span style="font-family:Courier New">)</span><span style="font-family:宋体">想要存入</span><span style="font-family:Courier New">TreeSet</span><span style="font-family:宋体">集合</span><span style="font-family:Courier New">,</span><span style="font-family:宋体">就需要实现该接口</span><span style="font-family:Courier New">,</span><span style="font-family:宋体">也就是要让自定义对象具备比较性</span><span style="font-family:Courier New">.</span></p> 
<p>存入<span style="font-family:Courier New">TreeSet</span><span style="font-family:宋体">集合中的元素要具备比较性</span>.</p> 
<p>比较性要实现<span style="font-family:Courier New">Comparable</span><span style="font-family:宋体">接口，重写该接口的</span><span style="font-family:Courier New">compareTo</span><span style="font-family:宋体">方法</span></p> 
<p>TreeSet<span style="font-family:宋体">属于</span><span style="font-family:Courier New">Set</span><span style="font-family:宋体">集合，该集合的元素是不能重复的，</span><span style="font-family:Courier New">TreeSet</span><span style="font-family:宋体">如何保证元素的唯一性</span></p> 
<p>通过compareTo或者compare方法中的来保证元素的唯一性。</p> 
<p>添加的元素必须要实现Comparable接口。当compareTo()函数返回值为0时，说明两个对象相等，此时该对象不会添加进来。</p> 
<p>比较器接口</p> 
<p></p> 
<pre><code class="language-java">----| Comparable
       		compareTo(Object o)     元素自身具备比较性
----| Comparator
       		compare( Object o1, Object o2 )	给容器传入比较器</code></pre> 
<br> 
<p></p> 
<p><span style="color:#ff0000">TreeSet<span style="font-family:宋体">集合</span>排序的两种方式：</span></p> 
<p>一，让元素自身具备比较性。</p> 
<p>也就是元素需要实现Comparable接口，覆盖compareTo 方法。</p> 
<p>这种方式也作为元素的自然排序，也可称为默认排序。</p> 
<p>年龄按照搜要条件，年龄相同再比姓名。</p> 
<pre><code class="language-java">public class Demo4 {
	public static void main(String[] args) {
		TreeSet ts = new TreeSet();
		ts.add(new Person("aa", 20, "男"));
		ts.add(new Person("bb", 18, "女"));
		ts.add(new Person("cc", 17, "男"));
		ts.add(new Person("dd", 17, "女"));
		ts.add(new Person("dd", 15, "女"));
		ts.add(new Person("dd", 15, "女"));


		System.out.println(ts);
		System.out.println(ts.size()); // 5

	}
}

class Person implements Comparable {
	private String name;
	private int age;
	private String gender;

	public Person() {

	}

	public Person(String name, int age, String gender) {

		this.name = name;
		this.age = age;
		this.gender = gender;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public String getGender() {
		return gender;
	}

	public void setGender(String gender) {
		this.gender = gender;
	}

	@Override
	public int hashCode() {
		return name.hashCode() + age * 37;
	}

	public boolean equals(Object obj) {
		System.err.println(this + "equals :" + obj);
		if (!(obj instanceof Person)) {
			return false;
		}
		Person p = (Person) obj;
		return this.name.equals(p.name) &amp;&amp; this.age == p.age;

	}

	public String toString() {
		return "Person [name=" + name + ", age=" + age + ", gender=" + gender
				+ "]";
	}

	@Override
	public int compareTo(Object obj) {
		
		Person p = (Person) obj;
		System.out.println(this+" compareTo:"+p);
		if (this.age &gt; p.age) {
			return 1;
		}
		if (this.age &lt; p.age) {
			return -1;
		}
		return this.name.compareTo(p.name);
	}

}</code></pre> 
<p>二，让容器自身具备比较性，自定义比较器。</p> 
<p>需求：当元素自身不具备比较性，或者元素自身具备的比较性不是所需的。</p> 
<p>那么这时只能让容器自身具备。</p> 
<p>定义一个类实现<span style="font-family:Courier New">Comparator </span><span style="font-family:宋体">接口，覆盖</span><span style="font-family:Courier New">compare</span><span style="font-family:宋体">方法。</span></p> 
<p>并将该接口的子类对象作为参数传递给<span style="font-family:Courier New">TreeSet</span><span style="font-family:宋体">集合的构造函数。</span></p> 
<p>当<span style="font-family:Courier New">Comparable</span><span style="font-family:宋体">比较方式，及</span><span style="font-family:Courier New">Comparator</span><span style="font-family:宋体">比较方式同时存在，以</span><span style="font-family:Courier New">Comparator</span></p> 
<p>比较方式为主。</p> 
<pre><code class="language-java">public class Demo5 {
	public static void main(String[] args) {
		TreeSet ts = new TreeSet(new MyComparator());
		ts.add(new Book("think in java", 100));
		ts.add(new Book("java 核心技术", 75));
		ts.add(new Book("现代操作系统", 50));
		ts.add(new Book("java就业教程", 35));
		ts.add(new Book("think in java", 100));
		ts.add(new Book("ccc in java", 100));

		System.out.println(ts); 
	}
}

class MyComparator implements Comparator {

	public int compare(Object o1, Object o2) {
		Book b1 = (Book) o1;
		Book b2 = (Book) o2;
		System.out.println(b1+" comparator "+b2);
		if (b1.getPrice() &gt; b2.getPrice()) {
			return 1;
		}
		if (b1.getPrice() &lt; b2.getPrice()) {
			return -1;
		}
		return b1.getName().compareTo(b2.getName());
	}

}

class Book {
	private String name;
	private double price;

	public Book() {

	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public double getPrice() {
		return price;
	}

	public void setPrice(double price) {
		this.price = price;
	}

	public Book(String name, double price) {

		this.name = name;
		this.price = price;
	}

	@Override
	public String toString() {
		return "Book [name=" + name + ", price=" + price + "]";
	}

}</code></pre> 
<br> 
<br> 
<span style="color:#ff0000">四，LinkedHashSet</span> 
<p></p> 
<p>会保存插入的顺序。</p> 
<p>看到<span style="font-family:Courier New">array</span><span style="font-family:宋体">，就要想到角标。</span></p> 
<p>看到<span style="font-family:Courier New">link</span><span style="font-family:宋体">，就要想到</span><span style="font-family:Courier New">first</span><span style="font-family:宋体">，</span><span style="font-family:Courier New">last</span><span style="font-family:宋体">。</span></p> 
<p>看到<span style="font-family:Courier New">hash</span><span style="font-family:宋体">，就要想到</span><span style="font-family:Courier New">hashCode,equals.</span></p> 
<p>看到<span style="font-family:Courier New">tree</span><span style="font-family:宋体">，就要想到两个接口。</span><span style="font-family:Courier New">Comparable</span><span style="font-family:宋体">，</span><span style="font-family:Courier New">Comparator</span><span style="font-family:宋体">。</span></p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e70e3e6e517443073c55bd71e71829e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 迭代器Iterator的详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5586e52e4f697cfc99c3e570828a7254/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java Map集合的详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>