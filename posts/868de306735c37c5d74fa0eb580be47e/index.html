<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker入门 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker入门" />
<meta property="og:description" content="目录
服务器选型
对比
虚拟机
微服务的部署策略
基于主机(物理机或虚机)的多服务实例
基于容器的服务实例
Docker
虚拟机与容器的区别
Docker三要素 Docker镜像
Docker仓库
Docker容器
Docker安装
Docker基本使用
基本操作
仓库&#43;镜像
容器
服务器选型 在选择服务器操作系统时， Windows 附带了许多您需要付费的功能。 Linux 是开放源代码，可让用户免费使用。 对比 Linux 是开源的，因此是免费的。 Web 主机仅需要支付技术支持即可安装和维护程序（如果需 要）。服务器提供商不需要将额外的成本转嫁给客户。另一方面，对于 Windows 服务器，公司通常 必须为操作系统和定期使用许可证付费。 Linux 服务器及其运行的应用程序通常设计为精益运行，因此通常使用较少的计算机资源。好处是 程序员可以 “ 即时 ” 修改 Linux 服务器和软件，而无需重新启动，这在 Windows 环境中是不可能的。 Microsoft Windows 服务器在多数据库任务下趋向于变慢，崩溃的风险更高。 Linux 比 Windows 更安全。尽管没有哪个系统能幸免于黑客和恶意软件的攻击，但是 Linux 往往是 一个低调的目标。由于 Windows 运行着世界上大多数软件，因此，黑客们渴望获得低挂的果实 Windows 。 虚拟机 虚拟机指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 微服务的部署策略 部署单体应用意味着运行大型应用的多个相同副本，通常提供若干台（ N ）服务器（物理机或虚拟 机），在每台服务器上运行若干个（ M）应用实例。部署单体应用并不总是简单明了，但还是比部署微服务应用简单。 微服务应用由几十甚至数百个服务组成。服务用不同的语言和框架写成，每个都是一个小应用，包括特定的部署、资源、扩展和监控需求，例如，根据服务需求运行若干数量的服务实例。 此外，每个服务实例必须配套提供适当的 CPU 、内存 和 I/O 资源。更具挑战性的是，尽管如此复杂，部署服务还必须快速、可靠和性价比高。 基于主机(物理机或虚机)的多服务实例 “ 基于主机的多服务实例 ” 模式是最为传统的应用程序部署方法。 在该模式下，软件开发人员可以提供单个或多个物理机或虚机，同时在每个主机上运行多个服务实例。 此模式有几种不同的实现形式，其中包括：将每一个服务实例都作为一个单独的进程，或是在同一进程中运行多个服务实例。 优点 : 由于多个服务实例使用的是同一服务器、及其操作系统，因此它们的资源使用效率相对较 高。 不足 : 除非每个实例都是一个单独的进程，否则您对服务实例的实际控制权并不大。而且，您无法 限制每个实例能够使用到的资源比例。这将带来主机内存被大量消耗的隐患。 如果多个服务实例在同一进程中运行，它们之间会缺乏隔离关系。这通常会导致在相同进程 中，某个行为异常的服务能够直接影响、甚至中断其他的服务。 由于运营团队需要了解服务的详细信息，因此在部署期间，他们可能发生人为错误的风险较 高。显然，开发和运营团队之间需要通过必要的信息交换，来尽可能地消除复杂性。 基于容器的服务实例 在这种部署模式下，每个服务实例都运行在其各自的容器中，因此也被称为操作系统级别的虚拟化机制。 使用这一模式时，用户将服务打包为容器镜像。每个容器镜像就是一个文件系统镜像，由应用和运行服 务所需的库构成。有的容器镜像还包括完整的 Linux 根文件系统，有的则更轻量。 以部署 Java 服务为例，构建的容器镜像包括 Java 运行时、 Apache Tomcat 服务器、以及编译好的 Java 应用。 一旦将服务打包为容器镜像，就启动一到多个容器。通常每个物理机或虚拟主机上会运行多个容器，会 用到 Kubernetes 或 Marathon 这样的集群管理工具来管理容器。 集群管理工具把主机看做资源池，根据每个容器需要的资源和每个主机上可用的资源来调度容器。 Docker Docker 是近年来新兴的虚拟化工具，它可以和虚拟机一样实现资源和系统环境的隔离。 虚拟机与容器的区别 VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用； Container(Docker 容器 ) ，在宿主机器、宿主机器操作系统上创建 Docker引擎，在引擎的基础上再安装应用。 Docker三要素 Docker镜像 Docker 镜像就是一个只读的模板。 例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。 镜像可以用来创建 Docker 容器。 Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。 Docker仓库 仓库是集中存放镜像文件的场所。 有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（ tag ）。 仓库分为公开仓库（ Public ）和私有仓库（ Private ）两种形式。 最大的公开仓库是 Docker Hub ，存放了数量庞大的镜像供用户下载。 当然，用户也可以在本地网络内创建一个私有仓库。 当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。 Docker容器 Docker 利用容器来运行应用。 容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等和运行在其中的应用程序。 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/868de306735c37c5d74fa0eb580be47e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-11T20:33:08+08:00" />
<meta property="article:modified_time" content="2024-01-11T20:33:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E5%9E%8B" rel="nofollow">服务器选型</a></p> 
<p id="%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#%E5%AF%B9%E6%AF%94" rel="nofollow">对比</a></p> 
<p id="%E8%99%9A%E6%8B%9F%E6%9C%BA-toc" style="margin-left:40px;"><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA" rel="nofollow">虚拟机</a></p> 
<p id="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5" rel="nofollow">微服务的部署策略</a></p> 
<p id="%E5%9F%BA%E4%BA%8E%E4%B8%BB%E6%9C%BA(%E7%89%A9%E7%90%86%E6%9C%BA%E6%88%96%E8%99%9A%E6%9C%BA)%E7%9A%84%E5%A4%9A%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E4%BA%8E%E4%B8%BB%E6%9C%BA%28%E7%89%A9%E7%90%86%E6%9C%BA%E6%88%96%E8%99%9A%E6%9C%BA%29%E7%9A%84%E5%A4%9A%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B" rel="nofollow">基于主机(物理机或虚机)的多服务实例</a></p> 
<p id="%E5%9F%BA%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B" rel="nofollow">基于容器的服务实例</a></p> 
<p id="Docker-toc" style="margin-left:40px;"><a href="#Docker" rel="nofollow">Docker</a></p> 
<p id="%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">虚拟机与容器的区别</a></p> 
<p id="Docker%E4%B8%89%E8%A6%81%E7%B4%A0%C2%A0-toc" style="margin-left:80px;"><a href="#Docker%E4%B8%89%E8%A6%81%E7%B4%A0%C2%A0" rel="nofollow">Docker三要素 </a></p> 
<p id="Docker%E9%95%9C%E5%83%8F-toc" style="margin-left:120px;"><a href="#Docker%E9%95%9C%E5%83%8F" rel="nofollow">Docker镜像</a></p> 
<p id="Docker%E4%BB%93%E5%BA%93-toc" style="margin-left:120px;"><a href="#Docker%E4%BB%93%E5%BA%93" rel="nofollow">Docker仓库</a></p> 
<p id="Docker%E5%AE%B9%E5%99%A8-toc" style="margin-left:120px;"><a href="#Docker%E5%AE%B9%E5%99%A8" rel="nofollow">Docker容器</a></p> 
<p id="Docker%E5%AE%89%E8%A3%85-toc" style="margin-left:80px;"><a href="#Docker%E5%AE%89%E8%A3%85" rel="nofollow">Docker安装</a></p> 
<p id="Docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#Docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">Docker基本使用</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-toc" style="margin-left:120px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" rel="nofollow">基本操作</a></p> 
<p id="%E4%BB%93%E5%BA%93%2B%E9%95%9C%E5%83%8F-toc" style="margin-left:120px;"><a href="#%E4%BB%93%E5%BA%93%2B%E9%95%9C%E5%83%8F" rel="nofollow">仓库+镜像</a></p> 
<p id="%E5%AE%B9%E5%99%A8-toc" style="margin-left:120px;"><a href="#%E5%AE%B9%E5%99%A8" rel="nofollow">容器</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E5%9E%8B"><span style="color:#333333;"><strong>服务器选型</strong></span></h3> 
<div> 
 <div> 
  <span style="color:#333333;">在选择服务器操作系统时，</span> 
  <span style="color:#333333;">Windows</span> 
  <span style="color:#333333;">附带了许多您需要付费的功能。 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">Linux</span> 
  <span style="color:#333333;">是开放源代码，可让用户免费使用。 </span> 
 </div> 
 <div> 
  <h4 id="%E5%AF%B9%E6%AF%94"><span style="color:#333333;">对比 </span></h4> 
  <div> 
   <span style="color:#333333;">Linux</span> 
   <span style="color:#333333;">是开源的，因此是免费的。</span> 
   <span style="color:#333333;">Web</span> 
   <span style="color:#333333;">主机仅需要支付技术支持即可安装和维护程序（如果需 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">要）。服务器提供商不需要将额外的成本转嫁给客户。另一方面，对于</span> 
   <span style="color:#333333;">Windows</span> 
   <span style="color:#333333;">服务器，公司通常 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">必须为操作系统和定期使用许可证付费。 </span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#333333;">Linux</span> 
   <span style="color:#333333;">服务器及其运行的应用程序通常设计为精益运行，因此通常使用较少的计算机资源。好处是 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">程序员可以</span> 
   <span style="color:#333333;">“</span> 
   <span style="color:#333333;">即时</span> 
   <span style="color:#333333;">”</span> 
   <span style="color:#333333;">修改</span> 
   <span style="color:#333333;">Linux</span> 
   <span style="color:#333333;">服务器和软件，而无需重新启动，这在</span> 
   <span style="color:#333333;">Windows</span> 
   <span style="color:#333333;">环境中是不可能的。 </span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#333333;">Microsoft </span> 
  </div> 
  <div> 
   <span style="color:#333333;">Windows</span> 
   <span style="color:#333333;">服务器在多数据库任务下趋向于变慢，崩溃的风险更高。 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">Linux</span> 
   <span style="color:#333333;">比</span> 
   <span style="color:#333333;">Windows</span> 
   <span style="color:#333333;">更安全。尽管没有哪个系统能幸免于黑客和恶意软件的攻击，但是</span> 
   <span style="color:#333333;">Linux</span> 
   <span style="color:#333333;">往往是 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">一个低调的目标。由于</span> 
   <span style="color:#333333;">Windows</span> 
   <span style="color:#333333;">运行着世界上大多数软件，因此，黑客们渴望获得低挂的果实 </span> 
  </div> 
  <div> 
   <span style="color:#333333;">Windows</span> 
   <span style="color:#333333;">。</span> 
  </div> 
  <div> 
   <h3 id="%E8%99%9A%E6%8B%9F%E6%9C%BA"><span style="color:#333333;"><strong>虚拟机 </strong></span></h3> 
   <div> 
    <span style="color:#333333;">虚拟机指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 </span> 
   </div> 
   <h4 id="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5"><span style="color:#333333;">微服务的部署策略 </span></h4> 
   <div> 
    <span style="color:#333333;">部署单体应用意味着运行大型应用的多个相同副本，通常提供若干台（</span> 
    <span style="color:#333333;">N</span> 
    <span style="color:#333333;">）服务器（物理机或虚拟 </span> 
   </div> 
   <div> 
    <span style="color:#333333;">机），在每台服务器上运行若干个（</span> 
    <span style="color:#333333;">M）应用实例。部署单体应用并不总是简单明了，但还是比部署微服务应用简单。</span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#333333;">微服务应用由几十甚至数百个服务组成。服务用不同的语言和框架写成，每个都是一个小应用，包括特定的部署、资源、扩展和监控需求，例如，根据服务需求运行若干数量的服务实例。</span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#333333;">此外，每个服务实例必须配套提供适当的</span> 
    <span style="color:#333333;"> CPU</span> 
    <span style="color:#333333;">、内存 和</span> 
    <span style="color:#333333;"> I/O 资源。更具挑战性的是，尽管如此复杂，部署服务还必须快速、可靠和性价比高。</span> 
   </div> 
   <div></div> 
   <div></div> 
   <div> 
    <h4 id="%E5%9F%BA%E4%BA%8E%E4%B8%BB%E6%9C%BA(%E7%89%A9%E7%90%86%E6%9C%BA%E6%88%96%E8%99%9A%E6%9C%BA)%E7%9A%84%E5%A4%9A%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B"><span style="color:#333333;">基于主机</span><span style="color:#333333;">(</span><span style="color:#333333;">物理机或虚机</span><span style="color:#333333;">)</span><span style="color:#333333;">的多服务实例 </span></h4> 
    <div> 
     <span style="color:#333333;">“</span> 
     <span style="color:#333333;">基于主机的多服务实例</span> 
     <span style="color:#333333;">”</span> 
     <span style="color:#333333;">模式是最为传统的应用程序部署方法。 </span> 
    </div> 
    <div> 
     <span style="color:#333333;">在该模式下，软件开发人员可以提供单个或多个物理机或虚机，同时在每个主机上运行多个服务实例。 </span> 
    </div> 
    <div> 
     <span style="color:#333333;">此模式有几种不同的实现形式，其中包括：将每一个服务实例都作为一个单独的进程，或是在同一进程中运行多个服务实例。</span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#333333;"><img alt="" src="https://images2.imgbox.com/01/52/AFpiANtH_o.png"></span> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<div> 
 <span style="color:#777777;">优点</span> 
 <span style="color:#777777;">: </span> 
 <span style="color:#777777;">由于多个服务实例使用的是同一服务器、及其操作系统，因此它们的资源使用效率相对较 </span> 
</div> 
<div> 
 <span style="color:#777777;">高。 </span> 
</div> 
<div> 
 <span style="color:#777777;">不足</span> 
 <span style="color:#777777;">: </span> 
</div> 
<div> 
 <span style="color:#777777;">除非每个实例都是一个单独的进程，否则您对服务实例的实际控制权并不大。而且，您无法 </span> 
</div> 
<div> 
 <span style="color:#777777;">限制每个实例能够使用到的资源比例。这将带来主机内存被大量消耗的隐患。 </span> 
</div> 
<div> 
 <span style="color:#777777;">如果多个服务实例在同一进程中运行，它们之间会缺乏隔离关系。这通常会导致在相同进程 </span> 
</div> 
<div> 
 <span style="color:#777777;">中，某个行为异常的服务能够直接影响、甚至中断其他的服务。 </span> 
</div> 
<div> 
 <span style="color:#777777;">由于运营团队需要了解服务的详细信息，因此在部署期间，他们可能发生人为错误的风险较 </span> 
</div> 
<div> 
 <span style="color:#777777;">高。显然，开发和运营团队之间需要通过必要的信息交换，来尽可能地消除复杂性。</span> 
</div> 
<p> </p> 
<h4 id="%E5%9F%BA%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B"><span style="color:#333333;">基于容器的服务实例 </span></h4> 
<div> 
 <span style="color:#333333;">在这种部署模式下，每个服务实例都运行在其各自的容器中，因此也被称为操作系统级别的虚拟化机制。</span> 
</div> 
<div></div> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/31/32/Kym01YEJ_o.png"> </p> 
<div> 
 <span style="color:#333333;">使用这一模式时，用户将服务打包为容器镜像。每个容器镜像就是一个文件系统镜像，由应用和运行服 </span> 
</div> 
<div> 
 <span style="color:#333333;">务所需的库构成。有的容器镜像还包括完整的</span> 
 <span style="color:#333333;"> Linux </span> 
 <span style="color:#333333;">根文件系统，有的则更轻量。 </span> 
</div> 
<div> 
 <span style="color:#333333;">以部署</span> 
 <span style="color:#333333;"> Java </span> 
 <span style="color:#333333;">服务为例，构建的容器镜像包括</span> 
 <span style="color:#333333;"> Java </span> 
 <span style="color:#333333;">运行时、</span> 
 <span style="color:#333333;">Apache Tomcat </span> 
 <span style="color:#333333;">服务器、以及编译好的</span> 
 <span style="color:#333333;"> Java </span> 
</div> 
<div> 
 <span style="color:#333333;">应用。 </span> 
</div> 
<div> 
 <span style="color:#333333;">一旦将服务打包为容器镜像，就启动一到多个容器。通常每个物理机或虚拟主机上会运行多个容器，会 </span> 
</div> 
<div> 
 <span style="color:#333333;">用到</span> 
 <span style="color:#333333;"> Kubernetes </span> 
 <span style="color:#333333;">或</span> 
 <span style="color:#333333;"> Marathon </span> 
 <span style="color:#333333;">这样的集群管理工具来管理容器。 </span> 
</div> 
<div> 
 <span style="color:#333333;">集群管理工具把主机看做资源池，根据每个容器需要的资源和每个主机上可用的资源来调度容器。 </span> 
</div> 
<h3 id="Docker">Docker</h3> 
<div> 
 <span style="color:#333333;">Docker</span> 
 <span style="color:#333333;">是近年来新兴的虚拟化工具，它可以和虚拟机一样实现资源和系统环境的隔离。 </span> 
</div> 
<h4 id="%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span style="color:#0d0016;">虚拟机与容器的区别 </span></h4> 
<div> 
 <span style="color:#333333;">VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用；</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">Container(Docker</span> 
 <span style="color:#333333;">容器</span> 
 <span style="color:#333333;">)</span> 
 <span style="color:#333333;">，在宿主机器、宿主机器操作系统上创建</span> 
 <span style="color:#333333;">Docker引擎，在引擎的基础上再安装应用。</span> 
</div> 
<div></div> 
<div style="text-align:center;"> 
 <span style="color:#333333;"><img alt="" src="https://images2.imgbox.com/69/f9/QXd4yedJ_o.png"></span> 
</div> 
<h4 id="Docker%E4%B8%89%E8%A6%81%E7%B4%A0%C2%A0"><span style="color:#333333;"><strong>Docker</strong></span><span style="color:#333333;"><strong>三要素</strong></span> </h4> 
<h5 id="Docker%E9%95%9C%E5%83%8F"><span style="color:#333333;">Docker</span><span style="color:#333333;">镜像 </span></h5> 
<div> 
 <span style="color:#333333;">Docker </span> 
 <span style="color:#333333;">镜像就是一个只读的模板。 </span> 
</div> 
<div> 
 <span style="color:#333333;">例如：一个镜像可以包含一个完整的</span> 
 <span style="color:#333333;"> ubuntu </span> 
 <span style="color:#333333;">操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序</span>。 
</div> 
<div> 
 <span style="color:#333333;">镜像可以用来创建</span> 
 <span style="color:#333333;"> Docker </span> 
 <span style="color:#333333;">容器。 </span> 
</div> 
<div> 
 <span style="color:#333333;">Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</span> 
</div> 
<div></div> 
<div></div> 
<h5 id="Docker%E4%BB%93%E5%BA%93"><span style="color:#333333;">Docker</span><span style="color:#333333;">仓库 </span></h5> 
<div> 
 <span style="color:#333333;">仓库是集中存放镜像文件的场所。 </span> 
</div> 
<div> 
 <span style="color:#333333;">有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（</span> 
 <span style="color:#333333;">tag</span> 
 <span style="color:#333333;">）。</span> 
</div> 
<div> 
 <span style="color:#333333;">仓库分为公开仓库（</span> 
 <span style="color:#333333;">Public</span> 
 <span style="color:#333333;">）和私有仓库（</span> 
 <span style="color:#333333;">Private</span> 
 <span style="color:#333333;">）两种形式。 </span> 
</div> 
<div> 
 <span style="color:#333333;">最大的公开仓库是</span> 
 <span style="color:#333333;"> Docker Hub</span> 
 <span style="color:#333333;">，存放了数量庞大的镜像供用户下载。 </span> 
</div> 
<div> 
 <span style="color:#333333;">当然，用户也可以在本地网络内创建一个私有仓库。 </span> 
</div> 
<div> 
 <span style="color:#333333;">当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上</span> 
 <span style="color:#333333;"> pull </span> 
 <span style="color:#333333;">下来就可以了。</span> 
</div> 
<div></div> 
<div></div> 
<p> </p> 
<h5 id="Docker%E5%AE%B9%E5%99%A8"><span style="color:#333333;">Docker</span><span style="color:#333333;">容器 </span></h5> 
<div> 
 <span style="color:#333333;">Docker </span> 
 <span style="color:#333333;">利用容器来运行应用。 </span> 
</div> 
<div> 
 <span style="color:#333333;">容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</span> 
</div> 
<div> 
 <span style="color:#333333;">可以把容器看做是一个简易版的</span> 
 <span style="color:#333333;"> Linux </span> 
 <span style="color:#333333;">环境（包括root用户权限、进程空间、用户空间和网络空间等和运行在其中的应用程序。</span> 
</div> 
<div> 
 <span style="color:#333333;">1. </span> 
 <span style="color:#333333;">提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境 </span> 
</div> 
<div> 
 <span style="color:#333333;">2. </span> 
 <span style="color:#333333;">提供弹性的云服务。因为</span> 
 <span style="color:#333333;"> Docker </span> 
 <span style="color:#333333;">容器可以随开随关，很适合动态扩容和缩容 </span> 
</div> 
<div> 
 <span style="color:#333333;">3. </span> 
 <span style="color:#333333;">组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构</span> 
</div> 
<p> </p> 
<h4 id="Docker%E5%AE%89%E8%A3%85"><span style="color:#333333;"><strong>Docker</strong></span><span style="color:#333333;"><strong>安装 </strong></span></h4> 
<div> 
 <span style="color:#777777;">Docker</span> 
 <span style="color:#777777;">支持运行</span> 
 <span style="color:#777777;">CentOS</span> 
 <span style="color:#777777;">版本：</span> 
 <span style="color:#777777;">CentOS 7.X </span> 
</div> 
<div> 
 <span style="color:#777777;">内核版本检查</span> 
 <span style="color:#777777;">: </span> 
 <span style="color:#777777;">uname </span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">r </span> 
</div> 
<div> 
 <span style="color:#777777;">卸载可能存在的旧版本</span> 
</div> 
<p> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2e/cf/FzLpDUIi_o.png"> </p> 
<div> 
 <span style="color:#777777;">旧版本的</span> 
 <span style="color:#777777;">docker</span> 
 <span style="color:#777777;">叫做</span> 
 <span style="color:#777777;">docker</span> 
 <span style="color:#777777;">或者</span> 
 <span style="color:#777777;">docker-engine</span> 
 <span style="color:#777777;">，如果有安装，先卸载其以及其依赖，新版本的 </span> 
</div> 
<div> 
 <span style="color:#777777;">docker</span> 
 <span style="color:#777777;">叫做</span> 
 <span style="color:#777777;">docker-ce </span> 
</div> 
<div> 
 <span style="color:#777777;">docker-ce</span> 
 <span style="color:#777777;">（社区版，免费） </span> 
</div> 
<div> 
 <span style="color:#777777;">docker-ee</span> 
 <span style="color:#777777;">（专业版，收费） </span> 
</div> 
<div> 
 <span style="color:#777777;">安装必要的系统工具</span> 
 <span style="color:#777777;">: </span> 
 <span style="color:#777777;">yum install </span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">y yum</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">utils device</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">mapper</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">persistent</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">data lvm2 </span> 
</div> 
<div> 
 <span style="color:#777777;">添加</span> 
 <span style="color:#777777;">docker-ce</span> 
 <span style="color:#777777;">安装源</span> 
 <span style="color:#777777;">: </span> 
 <span style="color:#777777;">yum</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">config</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">manager </span> 
 <span style="color:#777777;">--</span> 
 <span style="color:#777777;">add</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">repo </span> 
</div> 
<div> 
 <span style="color:#777777;">https://download.docker.com/linux/centos/docker</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">ce.repo </span> 
</div> 
<div> 
 <span style="color:#777777;">配置阿里云</span> 
 <span style="color:#777777;">Docker Yum</span> 
 <span style="color:#777777;">源</span> 
 <span style="color:#777777;">: </span> 
 <span style="color:#777777;">yum</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">config</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">manager </span> 
 <span style="color:#777777;">--</span> 
 <span style="color:#777777;">add</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">repo </span> 
</div> 
<div> 
 <span style="color:#777777;">http://mirrors.aliyun.com/docker</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">ce/linux/centos/docker</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">ce.repo </span> 
</div> 
<div> 
 <span style="color:#777777;">更新</span> 
 <span style="color:#777777;">yum</span> 
 <span style="color:#777777;">缓存</span> 
 <span style="color:#777777;">: </span> 
 <span style="color:#777777;">yum makecache fast </span> 
</div> 
<div> 
 <span style="color:#777777;">yml.pid</span> 
 <span style="color:#777777;">占用</span> 
 <span style="color:#777777;">: </span> 
 <span style="color:#777777;">-- </span> 
 <span style="color:#777777;">rm </span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">f /var/run/yum.pid </span> 
</div> 
<div> 
 <span style="color:#777777;">安装</span> 
 <span style="color:#777777;">docker-CE: </span> 
 <span style="color:#777777;">yum </span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">y install docker</span> 
 <span style="color:#777777;">-</span> 
 <span style="color:#777777;">ce </span> 
</div> 
<div> 
 <span style="color:#777777;">1</span> 
 <span style="color:#777777;">）默认安装的是最新版本的稳定版 </span> 
</div> 
<div> 
 <span style="color:#777777;">2</span> 
 <span style="color:#777777;">）查看版本列表请使用如下命令： </span> 
</div> 
<div> 
 <span style="color:#777777;">yum list docker-ce --showduplicates | sort -r</span> 
</div> 
<div> 
 <span style="color:#777777;">3</span> 
 <span style="color:#777777;">）如果要安装特定版本的</span> 
 <span style="color:#777777;">docker-CE</span> 
 <span style="color:#777777;">请使用如下命令格式： </span> 
</div> 
<div> 
 <span style="color:#777777;">yum install docker-ce</span> 
</div> 
<h4 id="Docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span style="color:#333333;"><strong>Docker</strong></span><span style="color:#333333;"><strong>基本使用 </strong></span></h4> 
<h5 id="%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span style="color:#333333;">基本操作 </span></h5> 
<div> 
 <span style="color:#333333;">查看服务状态 </span> 
 <pre><code class="hljs">systemctl status docker</code></pre> 
 <div> 
  <span style="color:#333333;">启停服务 </span> 
 </div> 
</div> 
<pre><code class="hljs">systemctl start docker
systemctl stop docker
systemctl restart docker</code></pre> 
<div> 
 <span style="color:#333333;">开机自启</span> 
 <pre><code class="hljs">systemctl enable docker
systemctl disable docker</code></pre> 
 <h5 id="%E4%BB%93%E5%BA%93%2B%E9%95%9C%E5%83%8F"><span style="color:#333333;">仓库</span><span style="color:#333333;">+</span><span style="color:#333333;">镜像 </span></h5> 
 <div> 
  <span style="color:#333333;">Docker </span> 
  <span style="color:#333333;">运行容器前需要本地存在对应的镜像， 如果镜像不存在， Docker 会尝试先从默认镜像仓库下载（默认使用</span> 
  <span style="color:#333333;"> Docker Hub 公共注册服务器中的仓库）， 用户也可以通过配置，使用自定义的</span> 
 </div> 
 <div> 
  <span style="color:#333333;">镜像仓库 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">配置加速器</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#333333;">通过阿里云控制台获得加速地址</span> 
  <span style="color:#333333;">) </span> 
 </div> 
 <div> 
  <pre><code class="hljs">vi /etc/docker/daemon.json
{
"registry-mirrors":["你的阿里云专属加速器地址"]
}</code></pre> 
  <div> 
   <span style="color:#333333;">重新加载</span> 
   <span style="color:#333333;">daemon </span> 
   <pre><code class="hljs">systemctl daemon-reload</code></pre> 
   <div> 
    <span style="color:#333333;">重启</span> 
    <span style="color:#333333;">docker </span> 
    <pre><code class="hljs">systemctl restart docker</code></pre> 
    <div> 
     <span style="color:#333333;">搜索镜像</span> 
     <pre><code class="hljs">docker search 镜像名称</code></pre> 
     <div> 
      <span style="color:#333333;">下载镜像</span> 
      <pre><code class="hljs">docker pull 镜像名
获取一个 centos 系统的基础镜像可以使用如下的命令:
docker pull centos （未指定版本一般会使用latest(最新的)版本）
docker pull centos:版本号 （或者直接指定版本）</code></pre> 
      <div> 
       <span style="color:#333333;">查看宿主机上的镜像</span> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<pre><code class="hljs">docker images
查看image位置
cd /var/lib/docker/containers (/var/lib/docker为docker默认安装目录) &amp;&amp; ll</code></pre> 
<p> <span style="color:#333333;">docker rmi </span><span style="color:#333333;">镜像</span><span style="color:#333333;">ID/</span><span style="color:#333333;">标签</span></p> 
<pre><code class="hljs">docker rmi centos
docker rmi -f centos:latest
如果提示镜像被使用，需要先停止某个ID的容器，那么要先删除容器再删除镜像。或者强制删除镜像。
正确做法：先删除依赖该镜像的所有容器， 再来删除镜像</code></pre> 
<h5 id="%E5%AE%B9%E5%99%A8"><span style="color:#333333;">容器 </span></h5> 
<div> 
 <span style="color:#333333;">容器是</span> 
 <span style="color:#333333;">Docker</span> 
 <span style="color:#333333;">的另一个核心概念。简单来说，容器是镜像的一个运行实例。 </span> 
</div> 
<div> 
 <span style="color:#333333;">镜像是静态的只读文件，而容器带有运行时需要的可写文件层，同时，容器中的应用进程处于运行状态 </span> 
</div> 
<div> 
 <p><span style="color:#333333;">创建容器</span></p> 
 <pre><code class="hljs">docker create -it centos:latest
docker create -it --name centos01 centos:latest
centos:latest 即镜像名字:版本(或镜像ID)，将使用指定镜像创建容器。另外，Docker会检查本地是否
存在指定的镜像，
不存在就从公有仓库下载
-it：是两个参数，-i：interactive容器具有交互功能，-t：容器将提供伪终端
--name：指定生成的容器的名字，允许空，如果不指定会自动生成</code></pre> 
 <div> 
  <span style="color:#333333;">启动、停止、重启容器</span> 
  <pre><code class="hljs">docker start 容器ID|name|name:tag
docker stop 容器ID|name|name:tag
docker restart 容器ID|name|name:tag</code></pre> 
  <div> 
   <span style="color:#333333;">查看当前的容器</span> 
   <pre><code class="hljs">docker ps
docker ps -a</code></pre> 
   <div> 
    <span style="color:#333333;">删除容器</span> 
   </div> 
   <div> 
    <pre><code class="hljs">docker rm 容器ID
docker rm -f 容器ID</code></pre> 
    <div> 
     <span style="color:#333333;">进入容器</span> 
    </div> 
    <div> 
     <pre><code class="hljs">docker exec -it 容器ID/容器NAME /bin/bash
docker exec -it 容器ID/容器NAME bash (简写)</code></pre> 
     <div> 
      <span style="color:#333333;">退出容器</span> 
     </div> 
     <div> 
      <pre><code class="hljs">退出时如果想继续运行容器：按顺序按【ctrl+p】，【ctrl+q】
如果不想继续运行：按【ctrl+d】或输入exit</code></pre> 
      <p></p> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/041199e1dff3f31a59ef53a98bfcaa77/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java实现Leetcode题（二叉树-3）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/60379e6f1df1748bda495990bee9404f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python如何重复执行代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>