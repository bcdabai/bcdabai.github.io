<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AtomicInteger - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AtomicInteger" />
<meta property="og:description" content="目录
一、从a&#43;&#43;说起为什么使用AtomicInteger
二、原理分析
三、总结
java并发包里面的类一直是学习和面试的重点，这篇文章主要是对java并发包的其中一个类AtomicInteger的讲解。从为什么要出现AtomicInteger再到其底层原理来一个分析。
一、从a&#43;&#43;说起为什么使用AtomicInteger 我们知道java并发机制中主要有三个特性需要我们去考虑，原子性、可见性和有序性。volatile关键字可以保证可见性和有序性却无法保证原子性。而这个AtomicInteger的作用就是为了保证原子性。我们先看一个例子。
在上面的这个例子中，我们定义了一个变量a。并且使用了5个线程分别去增加。为了保证可见性和有序性我们使用了volatile关键字对a进行修饰。在这里我们只测试原子性。如果我们第一次接触的话肯定会觉得5个线程，每个线程加10，最后结果一定是50呀。我们可以运行一边测试一波
很明显，可能跟你想象的不一样。为什么会出现这个问题呢？这是因为变量a虽然保证了可见性和有序性，但是缺没有保证原子性。其原因我们可以来分析一下。
对于a&#43;&#43;的操作，其实可以分解为3个步骤。
（1）从主存中读取a的值
（2）对a进行加1操作
（3）把a重新刷新到主存
这三个步骤在单线程中一点问题都没有，但是到了多线程就出现了问题了。比如说有的线程已经把a进行了加1操作，但是还没来得及重新刷入到主存，其他的线程就重新读取了旧值。因为才造成了错误。如何去解决呢？方法当然很多，但是为了和我们今天的主题对应上，很自然的联想到使用AtomicInteger。下面我们使用AtomicInteger重新来测试一遍：
在上面的代码中我们使用了AtomicInteger来定义a，而且使用了AtomicInteger的函数incrementAndGet来对a进行自增操作。现在我们再来测试一遍。
现在使用了AtomicInteger，不管你测试多少次，最后结果一定是50。为什么会出现这样的结果呢？AtomicInteger又是如何保证了这样的特性呢？下面我们就正式的开始揭开其面纱。
二、原理分析 上面的例子中我们只是调用了incrementAndGet函数来进行自增操作。其实AtomicInteger类为我们提供了很多函数。可以先使用一下。
1、基本使用
最常用的方法就是这么几个。当然了还有很多其他的方法。对于上面几个函数，每一个函数的意思都已经列了出来。意思都很简单。下面我们就通过源码的角度分析一下AtomicInteger的真正原理。
2、源码分析
既然AtomicInteger使用了incrementAndGet函数，那我们就直接来看这个方法，对于其他的方法也是同样的道理。我们直接看源码，这里使用的是jdk1.8的版本，不同的版本会有出入。
在这里我们会看到，底层使用的是unsafe的getAndAddInt方法。这里你可能有一个疑问了，这个unsafe是个什么鬼，而且还有一个valueOffset参数又是什么，想要看明白，我们从源码的开头开始看起。
开头在Unsafe的上面会发现，有一行注释叫做Unsafe.compareAndSwapInt。这又是什么？带着这些疑问我们开始一点一点揭开其面纱。
（1）compareAndSwapInt的含义
compareAndSwapInt又叫做CAS，如果你将来找工作，这个不清楚的话，基本上可以告别java这个方向了。
CAS 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。
我看过无数篇文章，对这个概念都是这样解释的，但是一开始看会一脸懵逼。我们使用一个例子来解释相信你会更加的清楚。
比如说给你儿子订婚。你儿子就是内存位置，你原本以为你儿子是和杨贵妃在一起了，结果在订婚的时候发现儿子身边是西施。这时候该怎么办呢？你一气之下不做任何操作。如果儿子身边是你预想的杨贵妃，你一看很开心就给他们订婚了，也叫作执行操作。现在你应该明白了吧。
对于CAS的解释我不准备长篇大论讲解。因为里面涉及到的知识点还是挺多的。在这里你理解了其含义就好。
（2）Unsafe的含义
在上面我们主要是讲解了CAS的含义，CAS修饰在Unsafe上面。那这个Unsafe是什么意思呢？
Unsafe是位于sun.misc包下的一个类，Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。
这里说一句题外话，在jdk1.9中，对Usafe进行了删除，所以因为这，那些基于Usafe开发的框架慢慢的都死掉了。
在这里也就是说，Usafe再进行getAndAddInt的时候，首先是先加1，然后对底层对象的地址做出了更改。这个地址是什么呢？这就是涉及到我们的第三个疑问参数了。
（3）valueOffset的含义
这个valueOffset是long类型的，代表的含义就是对象的地址的偏移量。下面我们重新解释一下这行代码。
unsafe.getAndAddInt(this, valueOffset, 1) &#43; 1。这行代码的含义是，usafe通过getAndAddInt方法，对原先对象的地址进行了加1操作。现在应该明白了。我们return的时候，也是直接返回的最新的值。这一点我们对比另外一个方法incrementAndGet就能看出。
在这个方法的源代码中我们可以看到最后的&#43;1操作没有了，也就是说，直接返回的是旧地址的值，然后再进行自增操作。如何去拿的地址的偏移量呢？是通过下面这个代码。
OK，到了这一步相信你已经知道了，usafe对a的值使用getAndAddInt方法进行了加1操作。然后返回最新的值。那么这个getAndAddInt方法是如何实现的呢？我们可以在进入看看：
这段代码的含义也很清晰。底层还是通过compareAndSwapInt这个CAS机制来完成的增加操作，
第一个参数var1表示的是当前对象，也就是a。
第二个参数var2表示的是地址偏移量
第三个参数var3表示的是我们要增加的值，这里表示为1
对于AtomicInteger的原理就是这，主要是通过Usafe的方式来完成的。Usafe又是通过CAS机制来实现的，因此想要弄清整个原子系列的真正实现，就是要搞清楚CAS机制。不过我会在下一章节进行讲解。
3、其他方法
对于其他方法其实也是同样的道理，我们可以给出几个看看。
我们可以看到底层基本上还是Usafe来实现的。Usafe又是经过CAS实现。
三、总结 对于jdk1.8的并发包来说，底层基本上就是通过Usafe和CAS机制来实现的。有好处也肯定有一个坏处。从好的方面来讲，就是上面AtomicInteger类可以保持其原子性。但是从坏的方面来看，Usafe因为直接操作的底层地址，肯定不是那么安全，而且CAS机制也伴随着大量的问题，比如说有名的ABA问题等等。关于CAS机制，我也会在后续的文章中专门讲解。大家可以先根据那个给儿子订婚的例子有一个基本的认识。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/34fe1c48a7a2786f7ce6b1fd223335fb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-07T10:02:44+08:00" />
<meta property="article:modified_time" content="2022-06-07T10:02:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AtomicInteger</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%8Ea%2B%2B%E8%AF%B4%E8%B5%B7%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8AtomicInteger-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%8Ea%2B%2B%E8%AF%B4%E8%B5%B7%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8AtomicInteger" rel="nofollow">一、从a++说起为什么使用AtomicInteger</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90" rel="nofollow">二、原理分析</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">三、总结</a></p> 
<hr id="hr-toc"> 
<blockquote> 
 <p>java并发包里面的类一直是学习和面试的重点，这篇文章主要是对java并发包的其中一个类AtomicInteger的讲解。从为什么要出现AtomicInteger再到其底层原理来一个分析。</p> 
</blockquote> 
<h3 id="%E4%B8%80%E3%80%81%E4%BB%8Ea%2B%2B%E8%AF%B4%E8%B5%B7%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8AtomicInteger"><strong>一、从a++说起为什么使用AtomicInteger</strong></h3> 
<blockquote> 
 <p>我们知道java并发机制中主要有三个特性需要我们去考虑，原子性、可见性和有序性。volatile关键字可以保证可见性和有序性却无法保证原子性。而这个AtomicInteger的作用就是为了保证原子性。我们先看一个例子。</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/b8/0f/sbS80wox_o.png"></p> 
<blockquote> 
 <p>在上面的这个例子中，我们定义了一个变量a。并且使用了5个线程分别去增加。为了保证可见性和有序性我们使用了volatile关键字对a进行修饰。在这里我们只测试原子性。如果我们第一次接触的话肯定会觉得5个线程，每个线程加10，最后结果一定是50呀。我们可以运行一边测试一波</p> 
</blockquote> 
<p><img alt="" height="333" src="https://images2.imgbox.com/7c/c6/CYFtDeCm_o.png" width="414"></p> 
<blockquote> 
 <p>很明显，可能跟你想象的不一样。为什么会出现这个问题呢？这是因为变量a虽然保证了可见性和有序性，但是缺没有保证原子性。其原因我们可以来分析一下。</p> 
 <p>对于a++的操作，其实可以分解为3个步骤。</p> 
 <p>（1）从主存中读取a的值</p> 
 <p>（2）对a进行加1操作</p> 
 <p>（3）把a重新刷新到主存</p> 
 <p>这三个步骤在单线程中一点问题都没有，但是到了多线程就出现了问题了。比如说有的线程已经把a进行了加1操作，但是还没来得及重新刷入到主存，其他的线程就重新读取了旧值。因为才造成了错误。如何去解决呢？方法当然很多，但是为了和我们今天的主题对应上，很自然的联想到使用AtomicInteger。下面我们使用AtomicInteger重新来测试一遍：</p> 
</blockquote> 
<p><img alt="" height="401" src="https://images2.imgbox.com/24/de/fABpBe3P_o.png" width="501"></p> 
<blockquote> 
 <p>在上面的代码中我们使用了AtomicInteger来定义a，而且使用了AtomicInteger的函数incrementAndGet来对a进行自增操作。现在我们再来测试一遍。</p> 
</blockquote> 
<p><img alt="" height="318" src="https://images2.imgbox.com/33/cc/RTJhiSvU_o.png" width="324"></p> 
<blockquote> 
 <p>现在使用了AtomicInteger，不管你测试多少次，最后结果一定是50。为什么会出现这样的结果呢？AtomicInteger又是如何保证了这样的特性呢？下面我们就正式的开始揭开其面纱。</p> 
</blockquote> 
<h3 id="%E4%BA%8C%E3%80%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><strong>二、原理分析</strong></h3> 
<blockquote> 
 <p>上面的例子中我们只是调用了incrementAndGet函数来进行自增操作。其实AtomicInteger类为我们提供了很多函数。可以先使用一下。</p> 
</blockquote> 
<p><strong>1、基本使用</strong></p> 
<p><img alt="" height="384" src="https://images2.imgbox.com/12/c9/mWRM8NkN_o.png" width="542"></p> 
<blockquote> 
 <p>最常用的方法就是这么几个。当然了还有很多其他的方法。对于上面几个函数，每一个函数的意思都已经列了出来。意思都很简单。下面我们就通过源码的角度分析一下AtomicInteger的真正原理。</p> 
</blockquote> 
<p><strong>2、源码分析</strong></p> 
<blockquote> 
 <p>既然AtomicInteger使用了incrementAndGet函数，那我们就直接来看这个方法，对于其他的方法也是同样的道理。我们直接看源码，这里使用的是jdk1.8的版本，不同的版本会有出入。</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/ac/5b/cUXTK1Wq_o.png"></p> 
<blockquote> 
 <p>在这里我们会看到，底层使用的是unsafe的getAndAddInt方法。这里你可能有一个疑问了，这个unsafe是个什么鬼，而且还有一个valueOffset参数又是什么，想要看明白，我们从源码的开头开始看起。</p> 
</blockquote> 
<p><img alt="" height="259" src="https://images2.imgbox.com/bd/23/94TLyN9O_o.png" width="584"></p> 
<blockquote> 
 <p>开头在Unsafe的上面会发现，有一行注释叫做Unsafe.compareAndSwapInt。这又是什么？带着这些疑问我们开始一点一点揭开其面纱。</p> 
</blockquote> 
<p><strong>（1）compareAndSwapInt的含义</strong></p> 
<blockquote> 
 <p>compareAndSwapInt又叫做CAS，如果你将来找工作，这个不清楚的话，基本上可以告别java这个方向了。</p> 
 <p>CAS 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。</p> 
 <p>我看过无数篇文章，对这个概念都是这样解释的，但是一开始看会一脸懵逼。我们使用一个例子来解释相信你会更加的清楚。</p> 
 <p>比如说给你儿子订婚。你儿子就是内存位置，你原本以为你儿子是和杨贵妃在一起了，结果在订婚的时候发现儿子身边是西施。这时候该怎么办呢？你一气之下不做任何操作。如果儿子身边是你预想的杨贵妃，你一看很开心就给他们订婚了，也叫作执行操作。现在你应该明白了吧。</p> 
 <p>对于CAS的解释我不准备长篇大论讲解。因为里面涉及到的知识点还是挺多的。在这里你理解了其含义就好。</p> 
</blockquote> 
<p><strong>（2）Unsafe的含义</strong></p> 
<blockquote> 
 <p>在上面我们主要是讲解了CAS的含义，CAS修饰在Unsafe上面。那这个Unsafe是什么意思呢？</p> 
 <p>Unsafe是位于sun.misc包下的一个类，Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p> 
 <p>这里说一句题外话，在jdk1.9中，对Usafe进行了删除，所以因为这，那些基于Usafe开发的框架慢慢的都死掉了。</p> 
 <p>在这里也就是说，Usafe再进行getAndAddInt的时候，首先是先加1，然后对底层对象的地址做出了更改。这个地址是什么呢？这就是涉及到我们的第三个疑问参数了。</p> 
</blockquote> 
<p><strong>（3）valueOffset的含义</strong></p> 
<blockquote> 
 <p>这个valueOffset是long类型的，代表的含义就是对象的地址的偏移量。下面我们重新解释一下这行代码。</p> 
 <p>unsafe.getAndAddInt(this, valueOffset, 1) + 1。这行代码的含义是，usafe通过getAndAddInt方法，对原先对象的地址进行了加1操作。现在应该明白了。我们return的时候，也是直接返回的最新的值。这一点我们对比另外一个方法incrementAndGet就能看出。</p> 
</blockquote> 
<p><img alt="" height="155" src="https://images2.imgbox.com/46/af/DDRkRj5g_o.png" width="431"></p> 
<blockquote> 
 <p>在这个方法的源代码中我们可以看到最后的+1操作没有了，也就是说，直接返回的是旧地址的值，然后再进行自增操作。如何去拿的地址的偏移量呢？是通过下面这个代码。</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/47/55/OIBx8QQh_o.png"></p> 
<blockquote> 
 <p>OK，到了这一步相信你已经知道了，usafe对a的值使用getAndAddInt方法进行了加1操作。然后返回最新的值。那么这个getAndAddInt方法是如何实现的呢？我们可以在进入看看：</p> 
</blockquote> 
<p><img alt="" height="133" src="https://images2.imgbox.com/ec/76/GBJQsUjm_o.png" width="529"></p> 
<blockquote> 
 <p>这段代码的含义也很清晰。底层还是通过compareAndSwapInt这个CAS机制来完成的增加操作，</p> 
 <p>第一个参数var1表示的是当前对象，也就是a。</p> 
 <p>第二个参数var2表示的是地址偏移量</p> 
 <p>第三个参数var3表示的是我们要增加的值，这里表示为1</p> 
 <p>对于AtomicInteger的原理就是这，主要是通过Usafe的方式来完成的。Usafe又是通过CAS机制来实现的，因此想要弄清整个原子系列的真正实现，就是要搞清楚CAS机制。不过我会在下一章节进行讲解。</p> 
</blockquote> 
<p><strong>3、其他方法</strong></p> 
<blockquote> 
 <p>对于其他方法其实也是同样的道理，我们可以给出几个看看。</p> 
</blockquote> 
<p><img alt="" height="280" src="https://images2.imgbox.com/f0/83/Z2quXxho_o.png" width="518"></p> 
<blockquote> 
 <p>我们可以看到底层基本上还是Usafe来实现的。Usafe又是经过CAS实现。</p> 
</blockquote> 
<h3 id="%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93"><strong>三、总结</strong></h3> 
<blockquote> 
 <p>对于jdk1.8的并发包来说，底层基本上就是通过Usafe和CAS机制来实现的。有好处也肯定有一个坏处。从好的方面来讲，就是上面AtomicInteger类可以保持其原子性。但是从坏的方面来看，Usafe因为直接操作的底层地址，肯定不是那么安全，而且CAS机制也伴随着大量的问题，比如说有名的ABA问题等等。关于CAS机制，我也会在后续的文章中专门讲解。大家可以先根据那个给儿子订婚的例子有一个基本的认识。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8859e9bfb73bae5ff72b3633a2018ec2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis入门到精通(七),Redis的淘汰策略及配置变更</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3cd1dc94181b484bd8a2a3752e5b3fb1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">FPGA和单片机的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>