<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机组成原理：1.2 计算机的基本组成 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机组成原理：1.2 计算机的基本组成" />
<meta property="og:description" content="1.2 计算机的基本组成 文章目录 1.2 计算机的基本组成1 冯·诺伊曼计算机的特点2 计算机硬件结构框图3 计算机的工作流程3.1 主存储器3.2 CPU：运算器3.3 CPU：控制器3.4 I/O3.5 ✊总结，全流程 1 冯·诺伊曼计算机的特点 计算机由运算器、存储器、输入设备、输出设备、控制器五大部件组成指令和数据以同等地位存放于存储器内，并可按照地址寻访指令和数据均以二进制数表示指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。指令在存储器内按顺序存放。通常指令是按顺序执行的，在特定条件下可根据运算结果或者根据设定的条件改变执行顺序。机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成。 2 计算机硬件结构框图 图1
图2
运算器和控制器在逻辑关系和电路结构上联系紧密，所以通常被集成在一个芯片上，因此将他们合称为CPU（Center Processing Unit）；输入和输出设备统称为IO设备。
所以现代计算机可以认为是三大部分组成：CPU、I/O设备、主存储器
图3
主存储器（Main Memory）：存储子系统的一类，用来存放程序和数据，可以直接与CPU交换信息。另一类称为辅助存储器，简称辅存，又称外存。
算术逻辑单元（Arithmetic Logic Unit）：简称算逻部件，用来完成算术逻辑运算。
控制单元（Control Unit）：用来解释存储器中的指令，并发出各种操作命令来执行指令。
3 计算机的工作流程 我的书写顺序可能跟书上不太一样，编制解题程序的机器指令放到了本节最后
图4
ACC（Accumulator）：累加器
MQ（Multiplier-Quotient Register）：乘商寄存器
X：操作数寄存器
PC（Program Counter）：程序计数器
IR（Instruction Register）：指令寄存器
MAR（Memory Adress Register）：存储器地址寄存器
MDR（Memory Data Register）：存储器数据寄存器
3.1 主存储器 图5
存储体由很多存储单元组成，每个存储单元里面又包含很多存储元件，每个存储元件能够寄存一位二进制代码0或者1，所以，一个存储单元能够存储一串二进制代码，那么这串二进制代码被称为一个存储字，这串二进制代码的长度被称为存储字长
一个存储字可以表示一个数字、一串字符或者一条指令。
主存的工作方式是按存储单元的地址号来实现对存储字各位的存取，这种方式被称为按地址存取方式
我们看图4中的MAR和MDR，MAR是存储器地址寄存器，我们使用MAR是要寄存存储单元的地址，那么有多少存储单元，MAR就要能构成多少个地址。比如我有64个存储单元，那么MAR必定有6位，因为2^6=64，只有六位才能产生64个不同的地址。
而下面几个小节我们会提到，MDR是存储器数据寄存器，从存储体中获得的数据（存储字）需要寄存到MDR中，那么MDR的位数应该和存储字的长度相同（即存储字长）
所以假设MAR的位数位n，MDR的位数为m，那么我们会有 2 n 2^n 2n个存储单元，每个单元又会有m个存储元件，那么总容量应该为 ( 2 n ) × m (2^n)\times m (2n)×m。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/aedee31f7bb01918e92bbf22649214ad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-17T21:34:46+08:00" />
<meta property="article:modified_time" content="2020-11-17T21:34:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机组成原理：1.2 计算机的基本组成</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="12__0"></a>1.2 计算机的基本组成</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#12__0" rel="nofollow">1.2 计算机的基本组成</a></li><li><ul><li><a href="#u1_u_5" rel="nofollow"><u>1 冯·诺伊曼计算机的特点</u></a></li><li><a href="#u2_u_20" rel="nofollow"><u>2 计算机硬件结构框图</u></a></li><li><a href="#u3_u_47" rel="nofollow"><u>3 计算机的工作流程</u></a></li><li><ul><li><a href="#31__80" rel="nofollow">3.1 主存储器</a></li><li><a href="#32_CPU_104" rel="nofollow">3.2 CPU：运算器</a></li><li><a href="#33_CPU_160" rel="nofollow">3.3 CPU：控制器</a></li><li><a href="#34_IO_204" rel="nofollow">3.4 I/O</a></li><li><a href="#35__208" rel="nofollow">3.5 ✊总结，全流程</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<br> 
<img src="https://images2.imgbox.com/4e/53/31kQZqur_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dD3tnVSz-1605619177683)(1_2_计算机的基本组成.assets/image-20201031184402174.png)]"> 
<p></p> 
<h3><a id="u1_u_5"></a><u>1 冯·诺伊曼计算机的特点</u></h3> 
<p><img src="https://images2.imgbox.com/20/41/DcSApEF8_o.png" alt="在这里插入图片描述"></p> 
<ol><li>计算机由运算器、存储器、输入设备、输出设备、控制器五大部件组成</li><li>指令和数据以同等地位存放于存储器内，并可按照地址寻访</li><li>指令和数据均以二进制数表示</li><li>指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。</li><li>指令在存储器内按顺序存放。通常指令是按顺序执行的，在特定条件下可根据运算结果或者根据设定的条件改变执行顺序。</li><li>机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成。</li></ol> 
<h3><a id="u2_u_20"></a><u>2 计算机硬件结构框图</u></h3> 
<p><img src="https://images2.imgbox.com/57/8b/eMs25oaU_o.png" alt="在这里插入图片描述"></p> 
<p>图1</p> 
<p><img src="https://images2.imgbox.com/cb/ac/HAHDOFYe_o.png" alt="在这里插入图片描述"></p> 
<p>图2</p> 
<p>运算器和控制器在逻辑关系和电路结构上联系紧密，所以通常被集成在一个芯片上，因此将他们合称为CPU（Center Processing Unit）；输入和输出设备统称为IO设备。</p> 
<p>所以现代计算机可以认为是三大部分组成：<strong>CPU、I/O设备、主存储器</strong></p> 
<p><img src="https://images2.imgbox.com/06/0c/PKNq0s2w_o.png" alt="在这里插入图片描述"></p> 
<p>图3</p> 
<p>主存储器（Main Memory）：存储子系统的一类，用来存放<strong>程序和数据</strong>，可以直接与CPU交换信息。另一类称为辅助存储器，简称辅存，又称外存。</p> 
<p>算术逻辑单元（Arithmetic Logic Unit）：简称算逻部件，用来完成算术逻辑运算。</p> 
<p>控制单元（Control Unit）：用来解释存储器中的指令，并发出各种操作命令来执行指令。</p> 
<h3><a id="u3_u_47"></a><u>3 计算机的工作流程</u></h3> 
<p><u><em><strong>我的书写顺序可能跟书上不太一样，编制解题程序的机器指令放到了本节最后</strong></em></u></p> 
<p><img src="https://images2.imgbox.com/a4/08/AByatzj2_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vdGkNi35-1605619177699)(1_2_计算机的基本组成.assets/image-20201031204059066.png)]"></p> 
<p>图4</p> 
<p>ACC（Accumulator）：累加器</p> 
<p>MQ（Multiplier-Quotient Register）：乘商寄存器</p> 
<p>X：操作数寄存器</p> 
<hr> 
<p>PC（Program Counter）：程序计数器</p> 
<p>IR（Instruction Register）：指令寄存器</p> 
<hr> 
<p>MAR（Memory Adress Register）：存储器地址寄存器</p> 
<p>MDR（Memory Data Register）：存储器数据寄存器</p> 
<h4><a id="31__80"></a>3.1 主存储器</h4> 
<p><img src="https://images2.imgbox.com/0f/62/pXbS8dqM_o.png" alt="在这里插入图片描述"></p> 
<p>图5</p> 
<p>存储体由很多存储单元组成，每个存储单元里面又包含很多存储元件，每个存储元件能够寄存一位二进制代码0或者1，所以，<strong>一个存储单元能够存储一串二进制代码</strong>，那么这串二进制代码被称为一个<strong>存储字</strong>，这串二进制代码的长度被称为<strong>存储字长</strong></p> 
<p>一个存储字可以表示<strong>一个数字</strong>、<strong>一串字符</strong>或者<strong>一条指令</strong>。</p> 
<p>主存的工作方式是按<strong>存储单元的地址号</strong>来实现对存储字各位的存取，这种方式被称为<strong>按地址存取方式</strong></p> 
<p>我们看图4中的MAR和MDR，MAR是存储器地址寄存器，我们使用MAR是要寄存存储单元的地址，那么有多少存储单元，MAR就要能构成多少个地址。比如我有64个存储单元，那么MAR必定有6位，因为2^6=64，只有六位才能产生64个不同的地址。</p> 
<p><img src="https://images2.imgbox.com/2a/59/DkXOxD0K_o.png" alt="在这里插入图片描述"></p> 
<p>而下面几个小节我们会提到，MDR是存储器数据寄存器，从存储体中获得的数据（存储字）需要寄存到MDR中，那么MDR的位数应该和存储字的长度相同（即存储字长）</p> 
<p>所以假设MAR的位数位n，MDR的位数为m，那么我们会有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          2 
         
        
          n 
         
        
       
      
        2^n 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>个存储单元，每个单元又会有m个存储元件，那么总容量应该为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         ( 
        
        
        
          2 
         
        
          n 
         
        
       
         ) 
        
       
         × 
        
       
         m 
        
       
      
        (2^n)\times m 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>。</p> 
<h4><a id="32_CPU_104"></a>3.2 CPU：运算器</h4> 
<p><img src="https://images2.imgbox.com/f2/6d/GexLKC9S_o.png" alt="在这里插入图片描述"></p> 
<p>运算器中至少包含三个寄存器</p> 
<ul><li>ACC(Accumulator)：累加器</li><li>MQ(Multiplier-Quotient Register)：乘商寄存器</li><li>X：操作数寄存器</li></ul> 
<p>下图为三种寄存器存储的不同数据，先别看乘法，剩余的加、减、除都是<code>ACC</code>存储被…数，<code>X</code>存储…数，最后的结果，加和减法的结果寄存到<code>ACC</code>中，除法的余数寄存到<code>ACC</code>中，商寄存到<code>MQ</code>中。</p> 
<p>那么乘法来说，被乘数原本是寄存在ACC中的，不过计算开始，就从<code>ACC</code>中移入到<code>X</code>中，乘数放在<code>MQ</code>中，乘积结果的高位在<code>MQ</code>中，低位在<code>ACC</code>中。</p> 
<p><img src="https://images2.imgbox.com/37/c9/TC7wR4vV_o.png" alt="在这里插入图片描述"></p> 
<p>在<a href="https://baike.baidu.com/item/%E5%94%90%E6%9C%94%E9%A3%9E/5718942" rel="nofollow">唐朔飞</a>教授的《计算机组成原理》一书中，采用了如下的运算器结构进行举例：</p> 
<blockquote> 
 <p>运算器可将结果从ACC中送至存储器的MDR；而存储器中的操作数也可以从MDR送至运算器的ACC、MQ或X</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/65/68/8uGoidzc_o.png" alt="在这里插入图片描述"></p> 
<p>我们以如上这种结构的运算器结构，对不同操作进行分析</p> 
<p>设<code>M</code>为存储器的任意一个地址号，<code>[M]</code>表示对应地址号单元的内容，<code>[X]</code>表示X寄存器中的内容，同理，<code>[ACC]</code>表示ACC寄存器的内容，<code>[MQ]</code>表示MQ寄存器的内容。</p> 
<p>👉<strong>加法</strong></p> 
<blockquote> 
 <p>[M]-&gt;X</p> 
</blockquote> 
<blockquote> 
 <p>[ACC] + [X] -&gt; ACC</p> 
</blockquote> 
<p>👉<strong>减法</strong></p> 
<blockquote> 
 <p>[M]-&gt;X</p> 
</blockquote> 
<blockquote> 
 <p>[ACC] - [X] -&gt; ACC</p> 
</blockquote> 
<p>👉<strong>乘法</strong></p> 
<blockquote> 
 <p>[M]-&gt;MQ</p> 
</blockquote> 
<blockquote> 
 <p>[ACC] - &gt; X</p> 
</blockquote> 
<blockquote> 
 <p>0 -&gt; ACC</p> 
</blockquote> 
<blockquote> 
 <p>[X] × [MQ] -&gt; ACC//MQ</p> 
</blockquote> 
<p>👉<strong>除法</strong></p> 
<blockquote> 
 <p>[M] -&gt; X</p> 
</blockquote> 
<blockquote> 
 <p>[ACC] ÷ [X] -&gt; MQ…ACC（商在MQ中，余数在ACC中）</p> 
</blockquote> 
<h4><a id="33_CPU_160"></a>3.3 CPU：控制器</h4> 
<p><img src="https://images2.imgbox.com/64/62/orr68y20_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/85/b1/ApdiT8xM_o.png" alt="在这里插入图片描述"></p> 
<p>👉取指：命令存储器读出一条指令</p> 
<p>👉分析：对指令进行分析，指出指令应该完成什么操作，指明操作数的地址</p> 
<p>👉执行：根据<strong>操作数所在的地址</strong>以及<strong>指令的操作码</strong>完成某种操作</p> 
<p>这里我们要明确一个关于指令的概念：</p> 
<p>一条计算机指令由<strong>操作码</strong>和<strong>地址码</strong>组成，</p> 
<p><img src="https://images2.imgbox.com/91/a1/RlWZ0fvk_o.png" alt="在这里插入图片描述"></p> 
<p><strong>操作码指明了我想要干什么，地址码说明了我要用哪个地址的数据来完成这个操作。</strong></p> 
<p><img src="https://images2.imgbox.com/2e/11/znDhMWam_o.png" alt="在这里插入图片描述"></p> 
<p>比如这些操作码，说明了我想要做什么。以000001为例，某条机器指令的操作码部分是000001，那么对于控制器来说，它知道了这条指令是想要取一个数，放到ACC中。具体取什么数，那就看后10位地址码指向的是什么位置。</p> 
<p>💻PC(Program Counter)：程序计数器，存放当前欲执行的指令的地址，<strong>与MAR之间由一条直接通路。</strong></p> 
<p>还能记起来MAR是什么东西吗？<code>MAR（Memory Adress Register）：存储器地址寄存器</code>，我们知道主存的工作方式是按照<code>地址存取方式</code>，我们无论想获得数据，还是指令，都要将其地址送入MAR，然后CU会对主存下达命令，根据地址寻找数据（有可能是一些数，也有可能是一条指令）并且将数据放入MDR中，然后MDR将数据送入需要的地方。这是冯·诺伊曼老前辈的思想：</p> 
<p><img src="https://images2.imgbox.com/0d/50/EPGezvpc_o.png" alt="在这里插入图片描述"></p> 
<p>程序计数器还有一个功能，就是<font color="red"><strong>自动加1的功能</strong></font>，可自动形成下一条指令。</p> 
<p>💻IR(Instruction Register)：指令寄存器，存放当前的指令，这些指令来自主存的MDR。</p> 
<p><img src="https://images2.imgbox.com/98/6b/q3usTte3_o.png" alt="在这里插入图片描述"></p> 
<p>IR中存放着当前指令，每一条指令又包含操作码和地址码，操作码会送至CU（控制单元）中进行分析，并且发出各种微操作命令序列，控制所有 被控对象；而地址码则送入MAR中进行进一步的取数操作。</p> 
<h4><a id="34_IO_204"></a>3.4 I/O</h4> 
<p>I/O子系统包括各种I/O设备及其相应的接口。每一种I/O设备都由I/O接口与主机相连，它们接收CU发出的各种控制命令，并完成相应的操作。</p> 
<h4><a id="35__208"></a>3.5 ✊总结，全流程</h4> 
<p>我们以一个式子的计算流程为例<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
        
        
          x 
         
        
          2 
         
        
       
         + 
        
       
         b 
        
       
         x 
        
       
         + 
        
       
         c 
        
       
      
        ax^2 + bx + c 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.897438em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span></p> 
<p>我们可以将这个式子改写成<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         ( 
        
       
         a 
        
       
         x 
        
       
         + 
        
       
         b 
        
       
         ) 
        
       
         + 
        
       
         c 
        
       
      
        x(ax + b) + c 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span></p> 
<p>那么在计算机中，这个式子的计算过程</p> 
<ol><li>将x放置在运算器</li><li>x乘以a得到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          a 
         
        
          x 
         
        
       
         ax 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span></span></span></span></span>，结果还是放在运算器中</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          a 
         
        
          x 
         
        
          + 
         
        
          b 
         
        
       
         ax + b 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span>，结果放到运算器</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ( 
         
        
          a 
         
        
          x 
         
        
          + 
         
        
          b 
         
        
          ) 
         
        
          × 
         
        
          x 
         
        
       
         (ax + b)\times x 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>，结果放到运算器</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ( 
         
        
          a 
         
        
          x 
         
        
          + 
         
        
          b 
         
        
          ) 
         
        
          × 
         
        
          x 
         
        
          + 
         
        
          c 
         
        
       
         (ax + b) \times x + c 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span> 还是放到运算器中</li></ol> 
<p>这个过程中，我们其实是把每个结果放在寄存器中，我们可以考虑一下，这些数每次都放在什么寄存器中？</p> 
<p>由3.2节我们已经知道，本质上所有的被加数、被减数、被乘数和被除数，从存储器中拿出来的时候都是首先放到ACC了，所以第一步，x的值放到ACC；</p> 
<p>接下来，运行乘法，想想3.2节我们怎么做的？忘了没事，再来看一遍</p> 
<p>👉<strong>乘法</strong></p> 
<blockquote> 
 <p>[M]-&gt;MQ</p> 
</blockquote> 
<blockquote> 
 <p>[ACC] - &gt; X</p> 
</blockquote> 
<blockquote> 
 <p>0 -&gt; ACC</p> 
</blockquote> 
<blockquote> 
 <p>[X] × [MQ] -&gt; ACC//MQ</p> 
</blockquote> 
<p>我们把存储器中拿来的数据a放入MQ，把ACC中的被乘数放到X寄存器中，将ACC置零，ALU计算乘法结果，高位写入ACC中，低位写入MQ中（但是注意为了简单，这个例子中把ACC中的结果认为就是乘法结果）；</p> 
<p>第三步，加法；</p> 
<p>第四步、第五步</p> 
<p>操作都是一样的，但是我们的重点不在这里，而是整个系统的工作过程。这里我们先把上面的例子对应的运算程序放出来：</p> 
<p><img src="https://images2.imgbox.com/99/cc/2Hh0ujfE_o.png" alt="在这里插入图片描述"></p> 
<p>3.3节有各个操作码的含义，这里不再放出。</p> 
<p>我们看到，指令（比如<code>0000010000001000</code>）和数据是以同等地位放在存储器中的。</p> 
<p><img src="https://images2.imgbox.com/ba/a2/CV9uu5xK_o.png" alt="在这里插入图片描述"></p> 
<p>现在来看一看第一条指令的执行流程：</p> 
<ol><li> <p>控制器：程序启动，PC值为0，PC的值送入MAR（MAR在存储器中），<code>控制器</code>命令<code>存储器</code>——根据MAR的地址从主存中找到对应地址的内容（我们可以看到，0位置上是一条指令）送到MDR</p> </li><li> <p>MDR把内容（000001 0000001000）又送回控制器，不过这次是送回IR，也就是指令寄存器，寄存寄存，就是暂时存着。</p> </li><li> <p>读完一条指令或者一个数据，PC加1变成1了，地址指向了主存的下一个存储单元。</p> </li><li> <p>CU对IR的内容分析，现在读出的指令为<code>000001 0000001000</code>，000001这个操作码是<code>取数放到ACC</code>，CU就明白了，我一会得下指令让主存取数放进ACC；0000001000这个地址码，说明了我取数要取哪个地址里面的（目前这个地址码指向的是8，也就是x这个值）。所以地址码会被送到哪里？应该是送到存储器地址寄存器MAR。而且控制器对主存说：“<strong>主存，我给你个地址，你照着这个地址把内容给我找出来送给ACC！找不出来削你</strong>！”</p> </li><li> <p>主存乖乖听话，照着地址找数据（或者指令），前面我们说过，这个例子的背景架构是支持MDR与ACC、MQ、X直接传递数据的，所以主存找到对应地址的数据（或者指令）x，送入MDR寄存器，有机会就写入ACC，完成这个操作。</p> </li><li> <p>接下来，我们继续将PC的值（此时为1）送入MAR，并对主存发出一条控制信号，读出1位置的指令（000100 0000001001），送到MDR</p> </li><li> <p>MDR把指令送入IR，同时PC+1=2</p> </li><li> <p>CU分析IR中寄存的指令：操作码000100，说明要做乘法；地址码0000001001，要取9号位置的数据给运算器，与运算器上一步存的值（x）做乘法。所以地址码送入MAR，同时下达读指令，读出的数据送入运算器（送到哪里？还记得不？MQ）</p> </li><li> <p>CU继续下达指令，命令运算器进行乘法运算，得出结果，存入ACC（书上应该就暂时认为乘法结果放入ACC了，没考虑高低位，应该是为了简化流程），操作结束</p> </li><li> <p>…</p> </li></ol> 
<p>到这里，本节的基本内容就结束了。</p> 
<p><img src="https://images2.imgbox.com/6a/58/kuIeTlPG_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/798e3820165ed602a26f8c925f2a35a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">idea更新版本2017切换到2020</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d2068839c92504b7ca05481deee30f29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">为什么单例模式可以支持多线程并发访问</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>