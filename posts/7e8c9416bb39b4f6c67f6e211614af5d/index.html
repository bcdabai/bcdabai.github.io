<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言——二分查找 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言——二分查找" />
<meta property="og:description" content="【前置】多个字符从两端移动，向中间汇聚 利用代码实现如下效果：
############ H##########! He########d! Hel######ld! Hell####rld! Hello##orld! Hello world! 要求： 刚开始全部是 ############ ，每循环一次，左右两边各一个#被代替成 Hello world! 这句话
的对应字符
思路： 1.需要创建两个数组来存储原始字符串 ############ 和用来替代的字符串 Hello world! 2.需要计算数组的长度从而计算原始字符串哪个位置对应替代字符串的位置
隐藏条件：两个数组的长度相同
因此只需要计算一个数组的长度即可，同时数组存储的是字符串，可以使用 strlen()函数计算长度，strlen()函数计算字符串长度时不会计算最后的终止符 \0
也可以使用 sizeof(arr)/sizeof(arr[0]) 来计算数组的长度，但字符串在存储的过程中会添加终止符 \0，而 sizeof(arr)/sizeof(arr[0]) 在计算时会把终止符计算进去，所以数组的真实长度为 sizeof(arr)/sizeof(arr[0])-1
3.需要两个变量 left 和 right 来代表左右两边移动的位置（即移动到哪里了）
int left = 0; int right = strlen(arr)-1; //数组的下标是从0开始，最后一个元素的下标是数组的长度-1 //如果是用sizeof(arr)/sizeof(arr[0])来计算长度的话，最后一个元素的下标是sizeof(arr)/sizeof(arr[0])-2 //在DEV——C&#43;&#43;中使用strlen()函数时需要包含头文件#include &lt;cstring&gt; 完整实现代码如下： #include &lt;stdio.h&gt; #include &lt;cstring&gt; int main() { char arr1[] = &#34;Hello world!&#34;; char arr2[] = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7e8c9416bb39b4f6c67f6e211614af5d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-08T15:03:41+08:00" />
<meta property="article:modified_time" content="2023-11-08T15:03:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言——二分查找</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#1f2329;">【前置】多个字符从两端移动，向中间汇聚 </span></h2> 
<p><span style="color:#1f2329;">利用代码实现如下效果：</span></p> 
<pre><code>############
H##########!
He########d!
Hel######ld!
Hell####rld!
Hello##orld!
Hello world!</code></pre> 
<h3>要求：</h3> 
<p>刚开始全部是 <strong>############</strong> ，每循环一次，左右两边各一个#被代替成 <strong>Hello world! </strong>这句话</p> 
<p>的对应字符</p> 
<h3>思路：</h3> 
<p>1.需要创建两个数组来存储原始字符串 <strong>############</strong>  和用来替代的字符串 <strong>Hello world! </strong></p> 
<p>2.需要计算数组的长度从而计算原始字符串哪个位置对应替代字符串的位置</p> 
<p>隐藏条件：两个数组的长度相同</p> 
<p>因此只需要计算一个数组的长度即可，同时数组存储的是字符串，可以使用<strong> strlen()</strong>函数计算长度，<span style="color:#fe2c24;">strlen()函数计算字符串长度时不会计算最后的终止符 \0</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">也可以使用 sizeof(arr)/sizeof(arr[0]) 来计算数组的长度，但字符串在存储的过程中会添加终止符 \0，而 sizeof(arr)/sizeof(arr[0]) 在计算时会把终止符计算进去，所以数组的真实长度为 sizeof(arr)/sizeof(arr[0])-1</span></p> 
</blockquote> 
<p>3.需要两个变量 <strong>left </strong>和 <strong>right</strong> 来代表左右两边移动的位置（即移动到哪里了）</p> 
<pre><code>int left = 0;
int right = strlen(arr)-1;
//数组的下标是从0开始，最后一个元素的下标是数组的长度-1
//如果是用sizeof(arr)/sizeof(arr[0])来计算长度的话，最后一个元素的下标是sizeof(arr)/sizeof(arr[0])-2
//在DEV——C++中使用strlen()函数时需要包含头文件#include &lt;cstring&gt;
</code></pre> 
<h3>完整实现代码如下：</h3> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;cstring&gt;
int main()
{
	char arr1[] = "Hello world!";
	char arr2[] = "############";
	int left = 0;
	int right = strlen(arr1)-1;
	while(left&lt;=right)
	{
		printf("%s\n",arr2);
		arr2[left] = arr1[left];
		arr2[right] = arr1[right];
		left++;
		right--;
	}
	printf("%s",arr2);
	return 0;
}</code></pre> 
<h2>二分查找：</h2> 
<h3>可以运用二分查找的前提条件：必须有序</h3> 
<p>二分查找的思路和前置问题有点像但有不同，会多一个变量 <strong>mid </strong>作为比较值</p> 
<p>假设我要在 [1,2,3,4,5,6,7,8]里面找到数字5，利用二分查找的思路如下：</p> 
<pre><code>int sz = sizeof(arr)/sizeof(arr[0]);
int left = 0;
int right = sz-1;
int mid = left+(right-left)/2;</code></pre> 
<p><img alt="" height="549" src="https://images2.imgbox.com/f9/2c/2dx1wWks_o.png" width="1200"></p> 
<p>第一次比较：mid指向的 arr[3]（即数字4）和5比大小，因为4比5小，因此我想要找的数字就在4的左边（相当于 arr[0] 到 arr[3] 都已经找过了，都比数字5小），此时重置 left 的值，将 left 变为 <strong>mid+1</strong>(因为 mid 所指的数字和我想找的数字已经比较了，再比较一次没有意义)</p> 
<p>第二次比较：因为第一次比较后 left 的值发生变化，而 mid=left+(right-left)/2 ，所以 mid 也会发生变化</p> 
<p><img alt="" height="593" src="https://images2.imgbox.com/14/7d/OGW87fwj_o.png" width="1200">此时 mid 指向的是 arr[5] (即数字6) 和5比大小，因为6比5大，因此我想要找的数字就在6的右边，此时重置 right 的值（相当于 arr[5] 到 arr[7] 都已经找过了，都比数字5大），将 right 变为 <strong>mid-1</strong>(因为 mid 所指的数字和我想找的数字已经比较了，再比较一次没有意义)</p> 
<p>第三次比较：</p> 
<p><img alt="" height="616" src="https://images2.imgbox.com/2a/5b/wUXtkdre_o.png" width="1200">此时 mid 指向的是 arr[4] (即数字5) 和5比大小，相等即找到了数字5</p> 
<p>如果此时还没有找到我想要的数字，那么 要么 right 会变成 mid-1 ，要么 left 会变成 mid+1 ，无论哪种情况， left 都会大于 right ，一旦 left &gt; right 就证明整个数组已经全部找过了，如果还没有找到，证明不在想找的数字不在这个数组里面</p> 
<h3>完整的代码如下：</h3> 
<pre><code>#include &lt;stdio.h&gt;
int main()
{
	int arr[10] = {0};
	int sz = sizeof(arr)/sizeof(arr[0]);
	int i = 0;
	int num = 0;
	int left = 0;
	int right = sz-1;
	int mid = (left+right)/2;
	int flag = 0;
	//数组必须有序 
	for(i=0;i&lt;sz;i++)
	{
		scanf("%d",&amp;arr[i]);
	}
	printf("请输入要查找数字的值，我将返回对应数字的下标：————&gt;"); 
	scanf("%d",&amp;num);
	
	while(left&lt;=right)
	{
		if(arr[mid]&lt;num)
		{
			left = mid+1;
		}
		else if(arr[mid]&gt;num)
		{
			right = mid-1;
		}
		else
		{
			flag = 1;
			break;
		}
		mid = (left+right)/2;
	}
	if(flag)
	{
		printf("数字%d对应的下标是%d",num,mid);
	}
	else
	{
		printf("数字%d不存在",num);
	}
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/77526da44b8f8000d35e1028c69b1cf6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker数据目录迁移</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bb74e8d15759ad12d5ce4268c88459c0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言实现简易扫雷游戏</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>