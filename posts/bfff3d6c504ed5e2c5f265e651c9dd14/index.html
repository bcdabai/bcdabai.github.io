<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FPGA PLL锁相环控制LED闪烁程序设计与仿真 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FPGA PLL锁相环控制LED闪烁程序设计与仿真" />
<meta property="og:description" content="开发软件：Quartus 13.0 开发组件：Cyclone IV EP4CE10F17C8 仿真：Modelsim 10.1d
文章目录 PLL锁相环一、程序设计二、仿真测试问题总结 PLL锁相环 PLL：Phase Locked Loop（锁相环）是一种反馈控制电路，其特点是利用外部输入的参考信号控制环路内部震荡信号的频率和相位。它可以将FPGA的系统时钟转化所需的倍频及相位时钟，是IC开发中很重要的一个部分。PLL的工作原理图如下图所示：
​
锁相环通常由鉴相器（FPD，Frequency Phase Detector）、滤波器（LF，Loop Filter）和压控振荡器（VCO，Voltage Controlled Oscillator）3部分组成前向通路，由VCO分频器组成频率相位的反馈通路。PLL的组成结构如下图所示：
​
摘自：https://blog.csdn.net/weixin_48956120/article/details/130695162
一、程序设计 任务：利用FPGA的PLL IP核实现LED闪烁控制。
思路：通过FPGA的4个I/O口连接4个LED，设定这些I/O为输出模式。内部计数器完成计数后改变该各I/O口的电平状态，实现LED灯的闪烁效果。
步骤：建立工程、新建顶层文件、调用PLL IP核、编写Testbench仿真文件、仿真。
代码如下：
My_PLL.v （例化PLL IP核的顶层文件） `timescale 1ps/1ps module My_PLL ( input wire clk, // inclk0.clk input wire rst, // arest.rst output wire outclk_0, // outclk0.clk output wire outclk_1, // outclk1.clk output wire outclk_2, // outclk2.clk output wire outclk_3, // outclk3.clk output wire outclk_4, // outclk4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bfff3d6c504ed5e2c5f265e651c9dd14/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-12T17:24:00+08:00" />
<meta property="article:modified_time" content="2023-07-12T17:24:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FPGA PLL锁相环控制LED闪烁程序设计与仿真</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>开发软件：Quartus 13.0    开发组件：Cyclone IV EP4CE10F17C8   仿真：Modelsim 10.1d</p> 
</blockquote> 
<div> 
 <h4>文章目录</h4> 
 <ul><li>PLL锁相环</li><li>一、程序设计</li><li>二、仿真测试</li><li>问题总结</li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_7"></a>PLL锁相环</h2> 
<p>PLL：Phase Locked Loop（锁相环）是一种反馈控制电路，其特点是利用外部输入的参考信号控制环路内部震荡信号的频率和相位。它可以将FPGA的系统时钟转化所需的倍频及相位时钟，是IC开发中很重要的一个部分。PLL的工作原理图如下图所示：</p> 
<p><img alt="" height="579" src="https://images2.imgbox.com/a5/01/E4IREaWF_o.png" width="1200">​</p> 
<p style="text-align:justify;">锁相环通常由鉴相器（<a name="_Hlk135083295">FPD</a>，Frequency Phase Detector）、滤波器（LF，Loop Filter）和压控振荡器（VCO，Voltage Controlled Oscillator）3部分组成前向通路，由VCO分频器组成频率相位的反馈通路。PLL的组成结构如下图所示：</p> 
<p><img alt="" src="https://images2.imgbox.com/d5/57/SmqcQBD0_o.png">​</p> 
<p> 摘自：<a class="link-info" href="https://blog.csdn.net/weixin_48956120/article/details/130695162" title="https://blog.csdn.net/weixin_48956120/article/details/130695162">https://blog.csdn.net/weixin_48956120/article/details/130695162</a></p> 
<h2>一、程序设计</h2> 
<p>任务：利用FPGA的PLL IP核实现LED闪烁控制。</p> 
<p>思路：通过FPGA的4个I/O口连接4个LED，设定这些I/O为输出模式。内部计数器完成计数后改变该各I/O口的电平状态，实现LED灯的闪烁效果。</p> 
<p>步骤：建立工程、新建顶层文件、调用PLL IP核、编写Testbench仿真文件、仿真。</p> 
<p>代码如下：</p> 
<h6>My_PLL.v （例化PLL IP核的顶层文件）</h6> 
<div> 
 <pre><code>`timescale 1ps/1ps

module My_PLL (
		input  wire       clk,   //    inclk0.clk
		input  wire       rst,   //     arest.rst
		output wire  outclk_0,   //   outclk0.clk
		output wire  outclk_1,   //   outclk1.clk
		output wire  outclk_2,   //   outclk2.clk
		output wire  outclk_3,   //   outclk3.clk
		output wire  outclk_4,   //   outclk4.clk
		output wire    locked    // locked.export
	);
	
PLL_ip My_PLL_u1 (
		
		.inclk0  (clk),     //   inclk0.clk
		.areset (~rst),     //  areset.rst
		.c0 (outclk_0),     //  outclk0.clk
		.c1 (outclk_1),     //  outclk1.clk
		.c2 (outclk_2),     //  outclk2.clk
		.c3 (outclk_3),     //  outclk3.clk
		.c4 (outclk_4),     //  outclk4.clk
		.locked(locked)     //locked.export
	);
	
endmodule</code></pre> 
</div> 
<h6><a id="_19"></a>PLL_ip.v （从Quartus中调用的PLL IP核）</h6> 
<div> 
 <pre><code>`timescale 1 ps / 1 ps
// synopsys translate_on
module PLL_ip (
	areset,
	inclk0,
	c0,
	c1,
	c2,
	c3,
	c4,
	locked);

	input	  areset;
	input	  inclk0;
	output	  c0;
	output	  c1;
	output	  c2;
	output	  c3;
	output	  c4;
	output	  locked;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0	  areset;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire [4:0] sub_wire0;
	wire  sub_wire6;
	wire [0:0] sub_wire9 = 1'h0;
	wire [3:3] sub_wire5 = sub_wire0[3:3];
	wire [4:4] sub_wire4 = sub_wire0[4:4];
	wire [2:2] sub_wire3 = sub_wire0[2:2];
	wire [0:0] sub_wire2 = sub_wire0[0:0];
	wire [1:1] sub_wire1 = sub_wire0[1:1];
	wire  c1 = sub_wire1;
	wire  c0 = sub_wire2;
	wire  c2 = sub_wire3;
	wire  c4 = sub_wire4;
	wire  c3 = sub_wire5;
	wire  locked = sub_wire6;
	wire  sub_wire7 = inclk0;
	wire [1:0] sub_wire8 = {sub_wire9, sub_wire7};

	altpll	altpll_component (
				.areset (areset),
				.inclk (sub_wire8),
				.clk (sub_wire0),
				.locked (sub_wire6),
				.activeclock (),
				.clkbad (),
				.clkena ({6{1'b1}}),
				.clkloss (),
				.clkswitch (1'b0),
				.configupdate (1'b0),
				.enable0 (),
				.enable1 (),
				.extclk (),
				.extclkena ({4{1'b1}}),
				.fbin (1'b1),
				.fbmimicbidir (),
				.fbout (),
				.fref (),
				.icdrclk (),
				.pfdena (1'b1),
				.phasecounterselect ({4{1'b1}}),
				.phasedone (),
				.phasestep (1'b1),
				.phaseupdown (1'b1),
				.pllena (1'b1),
				.scanaclr (1'b0),
				.scanclk (1'b0),
				.scanclkena (1'b1),
				.scandata (1'b0),
				.scandataout (),
				.scandone (),
				.scanread (1'b0),
				.scanwrite (1'b0),
				.sclkout0 (),
				.sclkout1 (),
				.vcooverrange (),
				.vcounderrange ());
	defparam
		altpll_component.bandwidth_type = "AUTO",
		altpll_component.clk0_divide_by = 1,
		altpll_component.clk0_duty_cycle = 50,
		altpll_component.clk0_multiply_by = 4,
		altpll_component.clk0_phase_shift = "0",
		altpll_component.clk1_divide_by = 1,
		altpll_component.clk1_duty_cycle = 50,
		altpll_component.clk1_multiply_by = 2,
		altpll_component.clk1_phase_shift = "0",
		altpll_component.clk2_divide_by = 1,
		altpll_component.clk2_duty_cycle = 50,
		altpll_component.clk2_multiply_by = 1,
		altpll_component.clk2_phase_shift = "-3333",
		altpll_component.clk3_divide_by = 1,
		altpll_component.clk3_duty_cycle = 50,
		altpll_component.clk3_multiply_by = 1,
		altpll_component.clk3_phase_shift = "3333",
		altpll_component.clk4_divide_by = 2,
		altpll_component.clk4_duty_cycle = 50,
		altpll_component.clk4_multiply_by = 1,
		altpll_component.clk4_phase_shift = "0",
		altpll_component.compensate_clock = "CLK0",
		altpll_component.inclk0_input_frequency = 40000,
		altpll_component.intended_device_family = "Cyclone IV E",
		altpll_component.lpm_hint = "CBX_MODULE_PREFIX=PLL_ip",
		altpll_component.lpm_type = "altpll",
		altpll_component.operation_mode = "NORMAL",
		altpll_component.pll_type = "AUTO",
		altpll_component.port_activeclock = "PORT_UNUSED",
		altpll_component.port_areset = "PORT_USED",
		altpll_component.port_clkbad0 = "PORT_UNUSED",
		altpll_component.port_clkbad1 = "PORT_UNUSED",
		altpll_component.port_clkloss = "PORT_UNUSED",
		altpll_component.port_clkswitch = "PORT_UNUSED",
		altpll_component.port_configupdate = "PORT_UNUSED",
		altpll_component.port_fbin = "PORT_UNUSED",
		altpll_component.port_inclk0 = "PORT_USED",
		altpll_component.port_inclk1 = "PORT_UNUSED",
		altpll_component.port_locked = "PORT_USED",
		altpll_component.port_pfdena = "PORT_UNUSED",
		altpll_component.port_phasecounterselect = "PORT_UNUSED",
		altpll_component.port_phasedone = "PORT_UNUSED",
		altpll_component.port_phasestep = "PORT_UNUSED",
		altpll_component.port_phaseupdown = "PORT_UNUSED",
		altpll_component.port_pllena = "PORT_UNUSED",
		altpll_component.port_scanaclr = "PORT_UNUSED",
		altpll_component.port_scanclk = "PORT_UNUSED",
		altpll_component.port_scanclkena = "PORT_UNUSED",
		altpll_component.port_scandata = "PORT_UNUSED",
		altpll_component.port_scandataout = "PORT_UNUSED",
		altpll_component.port_scandone = "PORT_UNUSED",
		altpll_component.port_scanread = "PORT_UNUSED",
		altpll_component.port_scanwrite = "PORT_UNUSED",
		altpll_component.port_clk0 = "PORT_USED",
		altpll_component.port_clk1 = "PORT_USED",
		altpll_component.port_clk2 = "PORT_USED",
		altpll_component.port_clk3 = "PORT_USED",
		altpll_component.port_clk4 = "PORT_USED",
		altpll_component.port_clk5 = "PORT_UNUSED",
		altpll_component.port_clkena0 = "PORT_UNUSED",
		altpll_component.port_clkena1 = "PORT_UNUSED",
		altpll_component.port_clkena2 = "PORT_UNUSED",
		altpll_component.port_clkena3 = "PORT_UNUSED",
		altpll_component.port_clkena4 = "PORT_UNUSED",
		altpll_component.port_clkena5 = "PORT_UNUSED",
		altpll_component.port_extclk0 = "PORT_UNUSED",
		altpll_component.port_extclk1 = "PORT_UNUSED",
		altpll_component.port_extclk2 = "PORT_UNUSED",
		altpll_component.port_extclk3 = "PORT_UNUSED",
		altpll_component.self_reset_on_loss_lock = "OFF",
		altpll_component.width_clock = 5;


endmodule</code></pre> 
</div> 
<h2>二、仿真测试</h2> 
<h6>My_PLL_tb.v （测试程序）</h6> 
<pre><code>`timescale 1ps/1ps

module My_PLL_tb();

		reg       clk; //         clk.clk
		reg       rst; //      areset.rst
		wire outclk_0; //     outclk0.clk
		wire outclk_1; //     outclk1.clk
		wire outclk_2; //     outclk2.clk
	   wire outclk_3; //     outclk3.clk
		wire outclk_4; //     outclk4.clk
		wire   locked; //   locked.export

		
initial      clk = 0;
always #5 clk = ~clk;

initial begin  
	 rst = 0;
	 #100;
	 rst = 1;
	 #100;
	 $stop;
end

My_PLL  My_PLL_tb_u1(
		.clk          (clk),   //      clk.clk
		.rst          (rst),   //   areset.rst
		.outclk_0(outclk_0),   //  outclk0.clk
		.outclk_1(outclk_1),   //  outclk1.clk
		.outclk_2(outclk_2),   //  outclk2.clk
		.outclk_3(outclk_3),   //  outclk3.clk
		.outclk_4(outclk_4),   //  outclk4.clk
		.locked    (locked)    //locked.export
);

endmodule 
</code></pre> 
<h6>仿真波形</h6> 
<h3><a id="1_20"></a><img alt="" height="1181" src="https://images2.imgbox.com/d2/6f/fuQmYxsk_o.png" width="1200"></h3> 
<h6> 逻辑电路<img alt="" height="603" src="https://images2.imgbox.com/63/f4/qkL5ywZV_o.png" width="1200"></h6> 
<p style="text-align:justify;">如上图所示，PLL模块有两个输入，分别为clk和rst。c为PLL输出，locked为输出时钟使能信号，高电平时表示输出有效。根据波形图可知，程序设计基本符合预期。</p> 
<h2>三、问题总结</h2> 
<p style="text-align:justify;">1. 使用Modelsim进行仿真时出现错误：Instantiation of ‘****’ failed. The design unit was not found。参考自：<a class="link-info" href="https://blog.csdn.net/qq_52450571/article/details/125765689" title="https://blog.csdn.net/qq_52450571/article/details/125765689">https://blog.csdn.net/qq_52450571/article/details/125765689</a><br> 原因：Modelsim未导入IP核。</p> 
<p style="text-align:justify;">解决方法：设置testbench的时候需要将除被仿真的主体文件之外的其他模块，比如IP核、仿真模型等也添加进去。</p> 
<p style="text-align:justify;">2. altpll模块找不到。</p> 
<p style="text-align:justify;">原因：未导入altpll.v</p> 
<p style="text-align:justify;">解决方法：同上。</p> 
<p style="text-align:justify;">3. 使用PLL进行led控制时，仿真波形显示不正常，无期望输出波形。</p> 
<p style="text-align:justify;"><img alt="" height="53" src="https://images2.imgbox.com/40/75/1xKB6IuS_o.png" width="1200"></p> 
<p>原因：信号例化错误。</p> 
<p style="text-align:justify;">解决方法：PLL中的（areset）rst信号是高电平有效的。在例化时须将rst取反。</p> 
<pre><code>.areset(~Rst_n)</code></pre> 
<p>4. 语法错误</p> 
<p>解决方法：自行校正。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c15cd4b7c6fdc2ed6dd87959c35c9d3b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信小程序canvas生成图片并保存本地</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d49a0318e077651066e15a198ecc783/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023年11月软考高级网络规划设计师报名时间-报名入口-报名流程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>