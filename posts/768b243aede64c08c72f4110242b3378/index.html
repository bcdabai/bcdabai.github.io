<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java中Blob数据存入数据库 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java中Blob数据存入数据库" />
<meta property="og:description" content="BLOB (binary large object)，二进制大对象，是一个可以存储二进制文件的容器。
在计算机中，BLOB常常是数据库中用来存储二进制文件的字段类型。
BLOB是一个大文件，典型的BLOB是一张图片或一个声音文件，由于它们的尺寸，必须使用特殊的方式来处理（例如：上传、下载或者存放到一个数据库）。
根据Eric Raymond的说法，处理BLOB的主要思想就是让文件处理器（如数据库管理器）不去理会文件是什么，而是关心如何去处理它。
但也有专家强调，这种处理大数据对象的方法是把双刃剑，它有可能引发一些问题，如存储的二进制文件过大，会使数据库的性能下降。在数据库中存放体积较大的多媒体对象就是应用程序处理BLOB的典型例子。（以上摘自百度）
blob字段出库请点这里
1.首先说存入Blob，也就是上传文件并把文件存入数据库Blob字段
首先创建一个字符串存储上传的文件路径和名称：
String filePath = &#34;&#34;; 上传文件的页面和普通上传文件写法一样，利用form表单提交servlet处理，注意设置form表单的enctype为multipart/form-data，然后提交到后台servlet中，然后重点来了，通过form表单提交的文件，要得到这个文件需要使用
DiskFileItemFactory factory = new DiskFileItemFactory();
这个东西 ，他的作用是：实例化一个硬盘文件工厂，用来配置文件组建ServletFileUpload，
然后创建一个文件上传解析器：
ServletFileUpload fileUpload = new ServletFileUpload(factory);
接下来解决乱码问题：
fileUpload.setHeaderEncoding(&#34;UTF-8&#34;);
之后判断拿到的数据是不是通过form提交上来的数据：
if(!fileUpload.isMultipartContent(request)){ return;//如果进了if，那说明有问题，直接return，当然根据实际情况不同处理 } 然后创建一个临时路径，用来存放临时上传的文件，用于存入blob
String path = this.getServletContext().getRealPath(&#34;/WEB-INF/upload&#34;); File file = new File(path);//放在WEB-INF文件夹下，是因为比较安全 //判断上传文件的保存目录是否存在 if (!file.exists() &amp;&amp; !file.isDirectory()) { System.out.println(savePath&#43;&#34;目录不存在，需要创建&#34;); //创建目录 file.mkdir(); } 接下来就是获取提交的文件数据了，这里我们写List&lt;FileItem&gt;，因为如果一次提交多个文件，那么就需要接收多个文件:
List&lt;FileItem&gt; fiList = fileUpload.parseRequest(request);//使用ServletFileUpload解析器解析上传文件的数据，解析的结果返回的是一个List&lt;FileItem&gt;集合，每一个FileItem对应一个Form表单的输入内容 for (int i = 0;i &lt; fiList.size(); i&#43;&#43;) { FileItem item = fiList." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/768b243aede64c08c72f4110242b3378/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-06-01T15:37:49+08:00" />
<meta property="article:modified_time" content="2017-06-01T15:37:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java中Blob数据存入数据库</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>BLOB (binary large object)，二进制大对象，是一个可以存储二进制文件的容器。<br> 在计算机中，BLOB常常是数据库中用来存储二进制文件的字段类型。<br> BLOB是一个大文件，典型的BLOB是一张图片或一个声音文件，由于它们的尺寸，必须使用特殊的方式来处理（例如：上传、下载或者存放到一个数据库）。<br> 根据Eric Raymond的说法，处理BLOB的主要思想就是让文件处理器（如数据库管理器）不去理会文件是什么，而是关心如何去处理它。<br> 但也有专家强调，这种处理大数据对象的方法是把双刃剑，它有可能引发一些问题，如存储的二进制文件过大，会使数据库的性能下降。在数据库中存放体积较大的多媒体对象就是应用程序处理BLOB的典型例子。（以上摘自百度）<br> <a href="http://blog.csdn.net/qq_34203492/article/details/72844780">blob字段出库请点这里</a></p> 
<p>1.首先说存入Blob，也就是上传文件并把文件存入数据库Blob字段<br> 首先创建一个字符串存储上传的文件路径和名称：</p> 
<pre><code>String filePath = "";
</code></pre> 
<p>上传文件的页面和普通上传文件写法一样，利用form表单提交servlet处理，注意设置form表单的enctype为multipart/form-data，然后提交到后台servlet中，然后重点来了，通过form表单提交的文件，要得到这个文件需要使用</p> 
<p><code>DiskFileItemFactory factory = new DiskFileItemFactory();</code><br> 这个东西 ，他的作用是：实例化一个硬盘文件工厂，用来配置文件组建ServletFileUpload，<br> 然后创建一个文件上传解析器：<br> <code>ServletFileUpload fileUpload = new ServletFileUpload(factory);</code><br> 接下来解决乱码问题：<br> <code>fileUpload.setHeaderEncoding("UTF-8");</code><br> 之后判断拿到的数据是不是通过form提交上来的数据：</p> 
<pre><code>if(!fileUpload.isMultipartContent(request)){
   return;//如果进了if，那说明有问题，直接return，当然根据实际情况不同处理
}
</code></pre> 
<p>然后创建一个临时路径，用来存放临时上传的文件，用于存入blob</p> 
<pre><code>String path = this.getServletContext().getRealPath("/WEB-INF/upload");
File file = new File(path);//放在WEB-INF文件夹下，是因为比较安全
//判断上传文件的保存目录是否存在
 if (!file.exists() &amp;&amp; !file.isDirectory()) {
     System.out.println(savePath+"目录不存在，需要创建");
     //创建目录
     file.mkdir();
 }
</code></pre> 
<p>接下来就是获取提交的文件数据了，这里我们写<code>List&lt;FileItem&gt;</code>，因为如果一次提交多个文件，那么就需要接收多个文件:</p> 
<pre><code>List&lt;FileItem&gt; fiList = fileUpload.parseRequest(request);//使用ServletFileUpload解析器解析上传文件的数据，解析的结果返回的是一个List&lt;FileItem&gt;集合，每一个FileItem对应一个Form表单的输入内容
for (int i = 0;i &lt; fiList.size(); i++) {
   FileItem item =  fiList.get(i);//循环遍历list
   //在循环的时候，因为是从form表单中提交的，所以有可能会拿到form中提交的非文件数据，这种情况就要根据下面写法区分
   if(item.isFormField()){
      //如果程序进入到这里，那说明是非form提交的file数据
   }else{
     String fileName = item.getName();//拿到上传的文件名称
     //这里需要注意，不同浏览器提交的文件名不同，有的会连带着文件存放的路径一起拿到，所以需要处理拿到的fileName 
     fileName = fileName.substring(fileName.lastIndexOf(File.separator)+1);//这个就是拿到fileName的文件名部分
     String time = new SimpleDateFormat("yyyyMMddHHmmss").format(new Date()) + '_'+ new Random().nextInt(1000);//创建一个time的String，防止有可能文件名重复
     fileName += time;
     InputStream is = item.getInputStream();//创建文件输入流
     FileOutputStream fos = new FileOutputStream(path +File.separator+fileName);
     byte buffer[] = new byte[1024];//创建一个缓冲区
     int length = 0;//判断输入流中的数据是否已经读完的标识
     while((length = is.read(buffer))&gt;0){//循环将输入流读入到缓冲区当中
        fos.write(buffer, 0, length);//使用FileOutputStream输出流将缓冲区的数据写入到指定的目录中
     }
     is.close();//关闭输入流
     fos.close();//关闭输出流   
     if(i != fiList.size() - 1){
       filePath = filePath + fileName+ "*";//记录每个上传的文件，用*分割，用*分割上传的每个文件是因为文件名中不能有*号
     }else{
       filePath = filePath + fileName;
     }
   }
}
</code></pre> 
<p>到这里才是把要存入Blob的文件上传到临时路径下面，filePath就是我们上传的所有文件的路径并用*隔开的<br> 存入数据库我们选择jdbc方式：</p> 
<pre><code>String[] files = filePath.split("*");
for(String fp : files){
  Class.forName("oracle.jdbc.driver.OracleDriver");
  // 根据数据库连接字符，名称，密码给conn赋值
  conn = DriverManager.getConnection("url", "user", "password");
  conn.setAutoCommit(false);//程序必须调用commit或者rollback方法
  // 初始化驱动包,这里我用的事oracle，jdbc是基础，都一样的
	String uuid = UUID.randomUUID().toString();//生成一个uuid
	String sql = "insert into test (id,blobvalue) values ('"+uuid+ "',empty_blob())"//先插入空的blob值empty_blob
	PreparedStatement pstmt = conn.prepareStatement(sql);
	pstmt.executeUpdate();
	pstmt.close();
	pstmt = conn.prepareStatement("select blobvalue from test where id= '"+ uuid + "' for update");
	ResultSet rset = pstmt.executeQuery();
	File f = new File(path + "\\" +fp);
	InputStream fin = new FileInputStream(f);
	if (rset.next()){
		try{
			BLOB oracleblob = (oracle.sql.BLOB) rset.getBlob(1);
		    OutputStream out = oracleblob.getBinaryOutputStream();
	        BufferedOutputStream output = new BufferedOutputStream(out); 
	        BufferedInputStream input = new BufferedInputStream(fin); 
	        byte[] buff = new byte[2048]; //用做文件写入的缓冲 
	        int bytesRead; 
	        while(-1 != (bytesRead = input.read(buff, 0, buff.length))){ 
	            output.write(buff, 0, bytesRead); 
	        } 
	        fin.close();
	        out.flush();
	        output.close();
		}catch(Exception e){
			// 得到流
			OracleThinBlob oracleweblogicblob = (OracleThinBlob)rset.getBlob(1);
			OutputStream out = oracleweblogicblob.getBinaryOutputStream();
	        BufferedOutputStream output = new BufferedOutputStream(out); 
	        BufferedInputStream input = new BufferedInputStream(fin); 
	        byte[] buff = new byte[2048]; //用做文件写入的缓冲 
	        int bytesRead; 
	        while(-1 != (bytesRead = input.read(buff, 0, buff.length))){ 
	            output.write(buff, 0, bytesRead); 
	        } 
	        fin.close();
	        out.flush();
	        output.close();
		}
	}
    pstmt.executeUpdate();//修改
	pstmt.close();
	conn.commit();提交
    conn.close();
    f.delete();//最后别忘了删除临时文件
}

</code></pre> 
<p>到这里 基本就算完成了文件上传到数据库blob 我这里是吧文件上传和存入数据库分开写了，问了方便大家理解上传文件和存入blob字段，文章纯手打，可能有错误地方，不过具体思路和过程应该没啥问题，不过程序有很多需要优化的地方，比如数据库连接池创建写在了for循环里面，这样每次循环都创建、关闭都会很耗费电脑资源，本文章仅提供思路参考。<br> 原创：影公子 ——转载请注明原帖链接</p> 
<p>这里贴一个公司的技术公众号，欢迎关注：<br> <img src="https://images2.imgbox.com/82/9a/gp9wUXSW_o.png" alt="在这里插入图片描述"><br> 在这里插入图片描述<br> 【玩物得志技术】<br> 走古风玩技术<br> 每周四定期分享技术干货<br> 程序员不无聊</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/99f59a6fd4f4a0c34a603404f5cd8a30/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring中BeanFactory和ApplicationContext的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0bb9d4ed2a64e65f33cb73316e425525/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（32）快速排序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>