<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>intpart在C语言中怎么运用,《数据结构和算法分析---C语言描述》读书笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="intpart在C语言中怎么运用,《数据结构和算法分析---C语言描述》读书笔记" />
<meta property="og:description" content="一、绪论
1、导致递归的四个基本法则：
(1)基准情形：必须总有某些基准情形，它无须递归就能解出，这就好比数学归纳法中的第一步，证明基本情况
(2)不断推进：每一次递归调用都必须要使求解状况朝接近基准情形的方向推进
(3)设计法则：所有的递归调用都能运行
(4)合成效益法则：在求解一个问题时，切勿在不同的递归调用中做重复的工作，
例如斐波那契序列不符合这一条，
f(n)= f(n-1)&#43;f(n-2)
而f(n-1) = f(n-2)&#43;f(n-3)，这当中就和f(n)重复了，所以效率很低。
2、只使用处理I/O的printDigit函数编写一个过程以输出任意整数(可以是负数)
/*打印出一个整数*/
voidprintOut(intn)
{
/*该整数的中间数都以正数打出*/
if(abs(n) &gt;= 10)
{
printOut(n/10);
printf(&#34;%d&#34;, abs(n%10));
} else//第一个数字按原样打出
printf(&#34;%d&#34;, n%10);
}
/*打印一个实数n，pointNum小数点位数*/
voidprintReal(doublen,intpointNum)
{
/*整数部分*/
intintPart, i, dicInt = 0;
/*小数部分*/
doubledicPart;
intPart = n;
dicPart = n - intPart;
/*打印整数部分*/
printOut(intPart);
if(pointNum &gt; 0)
{
/*打印小数点*/
printf(&#34;.&#34;);
/*将小数部分转换为整数*/
for(i = 0; i {
dicPart *= 10;
}
/*小数部分符号都弄为正数*/
dicInt = abs(dicPart);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9d1f35c45ac8ebed466ba7256b84c8af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-19T17:50:30+08:00" />
<meta property="article:modified_time" content="2021-05-19T17:50:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">intpart在C语言中怎么运用,《数据结构和算法分析---C语言描述》读书笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>一、绪论</p> 
 <p>1、导致递归的四个基本法则：</p> 
 <p>(1)基准情形：必须总有某些基准情形，它无须递归就能解出，这就好比数学归纳法中的第一步，证明基本情况</p> 
 <p>(2)不断推进：每一次递归调用都必须要使求解状况朝接近基准情形的方向推进</p> 
 <p>(3)设计法则：所有的递归调用都能运行</p> 
 <p>(4)合成效益法则：在求解一个问题时，切勿在不同的递归调用中做重复的工作，</p> 
 <p>例如斐波那契序列不符合这一条，</p> 
 <p>f(n)= f(n-1)+f(n-2)</p> 
 <p>而f(n-1) = f(n-2)+f(n-3)，这当中就和f(n)重复了，所以效率很低。</p> 
 <p>2、只使用处理I/O的printDigit函数编写一个过程以输出任意整数(可以是负数)</p> 
 <p>/*打印出一个整数*/</p> 
 <p>voidprintOut(intn)</p> 
 <p>{<!-- --></p> 
 <p>/*该整数的中间数都以正数打出*/</p> 
 <p>if(abs(n) &gt;= 10)</p> 
 <p>{<!-- --></p> 
 <p>printOut(n/10);</p> 
 <p>printf("%d", abs(n%10));</p> 
 <p>} else//第一个数字按原样打出</p> 
 <p>printf("%d", n%10);</p> 
 <p>}</p> 
 <p>/*打印一个实数n，pointNum小数点位数*/</p> 
 <p>voidprintReal(doublen,intpointNum)</p> 
 <p>{<!-- --></p> 
 <p>/*整数部分*/</p> 
 <p>intintPart, i, dicInt = 0;</p> 
 <p>/*小数部分*/</p> 
 <p>doubledicPart;</p> 
 <p>intPart = n;</p> 
 <p>dicPart = n - intPart;</p> 
 <p>/*打印整数部分*/</p> 
 <p>printOut(intPart);</p> 
 <p>if(pointNum &gt; 0)</p> 
 <p>{<!-- --></p> 
 <p>/*打印小数点*/</p> 
 <p>printf(".");</p> 
 <p>/*将小数部分转换为整数*/</p> 
 <p>for(i = 0; i </p> 
 <p>{<!-- --></p> 
 <p>dicPart *= 10;</p> 
 <p>}</p> 
 <p>/*小数部分符号都弄为正数*/</p> 
 <p>dicInt = abs(dicPart);</p> 
 <p>/*打印出小数部分*/</p> 
 <p>printOut(dicInt);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>3、</p> 
 <p align="center"><img src="https://images2.imgbox.com/ce/10/YyUb1a0f_o.png" alt="0818b9ca8b590ca3270a3433284dd417.png"></p> 
 <p align="center"><img src="https://images2.imgbox.com/d3/52/6Id0wktC_o.png" alt="0818b9ca8b590ca3270a3433284dd417.png"></p> 
 <p>1.5证明：</p> 
 <p>(1)logX0成立</p> 
 <p>令f(x) = logX/X，只需证明f(X)在X&gt;0时小于1即可然后求导，知道当X=2时取的最大值f(x)=f(2)=1/2&lt;1</p> 
 <p>(2)log(A的B次方)=log(A*A*......A)   [共有B个A相乘]</p> 
 <p>= logA+logA+logA+.......+logA         【共有B个logA相加】</p> 
 <p>= BlogA</p> 
 <p>1.6求下列各和：</p> 
 <p align="center"><img src="https://images2.imgbox.com/85/4c/YeJiGx9x_o.png" alt="0818b9ca8b590ca3270a3433284dd417.png"></p> 
 <p>a.采用等比数列的求和公式求得Sa</p> 
 <p>b.令和=Sb，则4*Sb -Sb=3*S=1+1/4+1/(4*4)+......=Sa</p> 
 <p>c.4*Sc-Sc = ......+(i*i-(i-1)*(i-1))/(4*4...共i-1个4相乘)+....=.....+(2*i-1)/(4*4...共i-1个4相乘)......=2*Sb-Sa</p> 
 <p>d.</p> 
 <p align="center"><img src="https://images2.imgbox.com/b4/04/2MRjrF2w_o.png" alt="0818b9ca8b590ca3270a3433284dd417.png"></p> 
 <p>1.7</p> 
 <p>(1+1/2+....1/N)-(1+1/2+.....1/(N/2))=logN-log(N/2)=log2.</p> 
 <p>1.8</p> 
 <p>0</p> 
 <p>1</p> 
 <p>2</p> 
 <p>3</p> 
 <p>4</p> 
 <p>5</p> 
 <p>6</p> 
 <p>7</p> 
 <p>8</p> 
 <p>9</p> 
 <p>10</p> 
 <p>11</p> 
 <p>12</p> 
 <p>13</p> 
 <p>14</p> 
 <p>1</p> 
 <p>2</p> 
 <p>4</p> 
 <p>8</p> 
 <p>6</p> 
 <p>2</p> 
 <p>4</p> 
 <p>8</p> 
 <p>6</p> 
 <p>2</p> 
 <p>4</p> 
 <p>8</p> 
 <p>6</p> 
 <p>2</p> 
 <p>4 2(100)=2(4)(25)</p> 
 <p>2(4)的尾数为6，则mod5为1,2(100)mod5也是1</p> 
 <p>1.9</p> 
 <p>a.数学归纳法</p> 
 <p>b.数学归纳法</p> 
 <p>1.10</p> 
 <p>a.S=2*(1+2+3+......+N)-N=2*(1+N)*N/2-N = N+N*N-N=N*N</p> 
 <p>b.数学归纳法</p> 
 <p>二、算法分析</p> 
 <p>1、</p> 
 <p align="center"><img src="https://images2.imgbox.com/f7/5c/KqJbGwow_o.png" alt="0818b9ca8b590ca3270a3433284dd417.png"></p> 
 <p>2、</p> 
 <p>法则一：如果T1(N)=O(f(N))且T2(N) = O(g(N))，那么：</p> 
 <p>T1+T2 = max(O(f(N)) ，O(g(N)))；</p> 
 <p>T1*T2 = O(f(N)*g(N))</p> 
 <p>法则二：</p> 
 <p>如果T(N)是一个k次多项式，则T(N) = Θ(N的k次方)</p> 
 <p>法则三：</p> 
 <p>对任意常数k，(logN)的k次方 = O(N)</p> 
 <p>3、当递归正常使用时，将其转换成为一个简单的循环结构是相当困难的。</p> 
 <p>4、求序列中最大子序列和的算法：</p> 
 <p align="center"><img src="https://images2.imgbox.com/11/57/cWU0oJzR_o.png" alt="0818b9ca8b590ca3270a3433284dd417.png"></p> 
 <p>5、对数最常出现的规律概括为：</p> 
 <p>如果一个算法用常数时间(O(1))将问题的大小削减为其一部分，通常是1/2，那么算法就是O(logN)，另一方面，如果使用常数时间只是把问题减少为一个常数(如将问题减少1)，那么这种算法就是O(N)</p> 
 <p align="center"><img src="https://images2.imgbox.com/c2/1e/idhCKwHb_o.png" alt="0818b9ca8b590ca3270a3433284dd417.png"></p> 
 <p>对分查找的时间复杂度为：O(logN)</p> 
 <p align="center"><img src="https://images2.imgbox.com/05/1a/FmdEapIR_o.png" alt="0818b9ca8b590ca3270a3433284dd417.png"></p> 
 <p>时间复杂度为：O(logN)</p> 
 <p>6、定理：</p> 
 <p>如果M&gt;N,则M mod N &lt; M/2</p> 
 <p align="center"><img src="https://images2.imgbox.com/6d/21/BLrk3UMq_o.png" alt="0818b9ca8b590ca3270a3433284dd417.png"></p> 
 <p>第七行还可以写成：</p> 
 <p>return   Pow(X,N-1)* X;</p> 
 <p>但是不能写成：</p> 
 <p>return Pow(Pow(X,2),N/2)；</p> 
 <p>return Pow(Pow(X,2),N/2);</p> 
 <p>因为在N=2时，会产生无限循环，因为当N=2时，递归调用Pow中有一个是以2作为第二个参数。</p> 
 <p>同时，return Pow(X,N/2)*Pow(X,N/2);这种方式影响效率，因为产生两个递归调用。</p> 
 <p>2.1、按增长率排列 下列函数：</p> 
 <p>2/N,37，N的开方，N,NloglogN,NlogN,Nlog(N*N)，NlogN*logN，N(1.5)，N*N,N*N*logN，N*N*N，2(N/2)，2(N)</p> 
 <p>其中NlogN,Nlog(N*N)以相同的增长率增长</p> 
 <p>2.2、</p> 
 <p>a.成立</p> 
 <p>b.不</p> 
 <p>c.不成立</p> 
 <p>d.不成立</p> 
 <p>2.3对两个数同时求对数，然后洛必达法则</p> 
 <p>2.4</p> 
 <p>罗比达法则，应用k次，最后还是为0</p> 
 <p>2.5</p> 
 <p>Let PfOO (NO) = 1 whenNO is even, and NO whenNO is odd. Likewise, let gO(NO) = 1 whenNO isodd, and NO whenNO is even. Then the ratio PfOO (NO) / g O(NO) oscillates between 0 and ∞.</p> 
 <p>2.6</p> 
 <p>(1)O(N)</p> 
 <p>(2)O(N*N)</p> 
 <p>(3)O(N*N*N)</p> 
 <p>(4)O(N*N)</p> 
 <p>(5)O(N*N*N*N*N)</p> 
 <p>(6)O(N*N*N*N)</p> 
 <p>*****************************************************************************************************************************************************************************************</p> 
 <p>2013年5月16日更新</p> 
 <p>*****************************************************************************************************************************************************************************************</p> 
 <p>三、表、栈、队列</p> 
 <p>1、</p> 
 <p>*****************************************************************************************************************************************************************************************</p> 
 <p>2013年5月16日更新</p> 
 <p>*****************************************************************************************************************************************************************************************</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e433c369d8dbcb7381c0f599dd1fe4d1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java.lang.NoSuchMethodException: org.apache.catalina.deploy.WebXml addServlet</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f92868236c951ebcff8171ab9346f48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android后台限制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>