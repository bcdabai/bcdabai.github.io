<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux之bash介绍 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux之bash介绍" />
<meta property="og:description" content="Shell的介绍 shell是一个程序，可以称之为壳程序，用于用户与操作系统进行交互。用来区别与核，相当于是一个命令解析器，Shell有很多中，这里列出其中几种
Bourne SHell(sh)Bourne Again SHell(bash)C SHell(csh)KornSHell(ksh)zsh 各个shell的功能都差不太多，在某些语法的下达下面有些区别，Linux预设就是bash。这里主要介绍bash
bash bash命令是sh命令的超集，大多数sh脚本都可以在bash下运行，bash主要有如下这些功能
bash功能 记录历史命令:bash可以记录曾经的命令，保持在~/.bash_history文件中，只保存上次注销登录之后的命令tab键自动补全:使用tab见可以自动不全命令或者目录ialias命令别名:可以使用alias ll=&#39;ls -al&#39;来设置命令的别名工作控制:可以将某些任务放在后台去运行，这里不多种介绍程序脚本:可以执行shell脚本文件通配符:在查找相关文件或者执行相关命令时，可以使用通配符*内建命令type:可以使用type 命令来查看某个命令是否为内建在bash当中的命令「 bash变量 bash中变量有两种，分别是环境变量和自定义变量，可以理解为全局变量和局部变量，在理解他们的区别前，需要知道父程序和子程序，举个例子，当前的bash我们称之为父程序，而在这个bash下执行的任何程序，都称之为子程序。那全局变量和局部变量的区别就是，全局变量在子程序中仍然有效，局部变量只在当前程序中生效。（注意，一旦退出父程序这个bash的话，无论是全局变量还是局部变量都失效了，再次打开bash时，该变量是不存在的）
变量范围
变量的设定 变量的设定有几个规则，这里列举如下:
设定变量通过=来链接，例如name=sujinzhou,两边不能有空格，如果有空格的话，需要用引号变量名只能是英文名和数字，只能是英文开头如果变量内容被引号扩起来的话，双引号和单引号是有区别的双引号里面的特殊字符，会保持原有的特性。单引号里面的特殊字符，只会是字符使用\将特殊字符转换为一般字符使用``这个符号扩起来的命令会先计算这个命令里面的内容，这个指令等价于$()给原有的变量添加值时，使用 变 量 , &#34; {变量},&#34; 变量,&#34;变量&#34;再加具体的内容 变量类型
bash中变量类型有两种，一种是普通的字符串，一种是整数;设置变量的类型使用的是declare命令，delcare的命令格式如下
declare -[axir] variable 参数的意思:
-a:将variable定义为数组-i:将后面的变量设置为整数类型-x:与export一样，将后面的变量设置为环境变量-r:将后面的变量设置为只读变量
如果declare命令没有接任何变量的话，则表示显示所哟的 定义数组
var[index]=content 变量的删除 删除变量使用如下命令
unset 变量名 变量的查看 查看单个命令的内容，可以使用echo命令，使用echo $变量名就可以查看变量内容，另外如果要查看所有变量有3个命令，分别是如下几个命令，每个命令又有区别。
echo $变量名:用于显示制定变量env:用来查询环境变量，set:显示shell变量，包括私有变量与用户变量，不同的shell有不同的私有变量，在shell中设置变量之后，可以通过set查到export:显示当前导出成用户变量的shell变量，也是用来查询环境变量的，shell的私有变量不会出现 Bash shell的操作环境 在shell中设置的变量，无论是环境变量还是自定义变量，在bash中注销登录之后，就失效了。下次登录时，是没有这些变量的，如果想要这些变量永久生效，是需要下如配置文件的，bash在启动时，会读取这个配置文件，来设置当前shell的各种变量。shell分为两种，分别是login shell和nonlogin shell，这里先说login shell；login shell是需要输入用户名和密码的，一般情况下，login shell在登录之后，会去读取两个文件，来设置当前shell的环境变量，分别是
/etc/profile:这个配置文件是默认配置文件，是系统整体的设置~/.bash_profile或者~/.bash_login或者~/.profile：这个是用户的自定义设置文件 shell在读取/etc/profile中的文件之后，会去读取用户自定义的设置文件，按照顺序读取上文中所说的自定义设置文件，只要找到其中任何一个，就不再继续。在用户自定义的配置文件中，都会调用~/.bashrc这个文件，来配置当前的这个shell
/etc/profile或者~/.bash_profile都是在登录的时候才去读取，如果将自己的一些设置到这些文件之后，一般都需要重新登录一次shell才会生效，也可以使用source这个命令，来读取配置文件的内容到当前的这个shell
数据流重导向 数据重导向，表示将数据从一个地方导向到另外一个地方，在linux的bash中，有两种输出，分别是
标准输出:输出在屏幕当中的正常的提示信息，或者正常的返回值错误输出:命令执行出错时，显示在屏幕当中的出错信息 有时候，我们需要将标准输出或者错误输出保留到某个文件中，方便以后你查询，这种情况下，就需要数据流重导向，也就是将输出到屏幕的信息导向到一个文件中。而导向又分为标准输出导向和错误输出导向
标准输出重导向:代码为1,使用&gt;或者&gt;&gt;错误输出重导向:代码为2,使用2&gt;或者2&gt;&gt; 在linux中一个特殊的装置，是/dev/null，所有将导向到这个装置的数据都会被丢弃，相当与删除数据。
有时候，我们需要将标准输出和错误输出导出到文件中，则可以使用符号 2&gt;&amp;1，这个符号是连在一起的，表示将错误和标准输出一起输出。
除了输出之外，还有输入，
标准输入重导向:代码为0,使用&lt;
某些由键盘输入的数据，可以使用标准输入重导向，从文件中输入数据。 管线命令 常用的关系命令有如下几个，具体的用法可以查询man文件" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0bc057c173ed8925fe5b4de787c2d73a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-14T23:12:42+08:00" />
<meta property="article:modified_time" content="2022-05-14T23:12:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux之bash介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Shell_0"></a>Shell的介绍</h2> 
<p>shell是一个程序，可以称之为壳程序，用于用户与操作系统进行交互。用来区别与核，相当于是一个命令解析器，Shell有很多中，这里列出其中几种</p> 
<ul><li>Bourne SHell(sh)</li><li>Bourne Again SHell(bash)</li><li>C SHell(csh)</li><li>KornSHell(ksh)</li><li>zsh</li></ul> 
<p>各个shell的功能都差不太多，在某些语法的下达下面有些区别，Linux预设就是bash。这里主要介绍bash</p> 
<h3><a id="bash_10"></a>bash</h3> 
<p>bash命令是sh命令的超集，大多数sh脚本都可以在bash下运行，bash主要有如下这些功能</p> 
<h4><a id="bash_12"></a>bash功能</h4> 
<ul><li>记录历史命令:bash可以记录曾经的命令，保持在~/.bash_history文件中，只保存上次注销登录之后的命令</li><li>tab键自动补全:使用tab见可以自动不全命令或者目录i</li><li>alias命令别名:可以使用<code>alias ll='ls -al'</code>来设置命令的别名</li><li>工作控制:可以将某些任务放在后台去运行，这里不多种介绍</li><li>程序脚本:可以执行shell脚本文件</li><li>通配符:在查找相关文件或者执行相关命令时，可以使用通配符<code>*</code></li><li>内建命令type:可以使用<code>type 命令</code>来查看某个命令是否为内建在bash当中的命令「</li></ul> 
<h4><a id="bash_21"></a>bash变量</h4> 
<p>bash中变量有两种，分别是环境变量和自定义变量，可以理解为全局变量和局部变量，在理解他们的区别前，需要知道父程序和子程序，举个例子，当前的bash我们称之为父程序，而在这个bash下执行的任何程序，都称之为子程序。那全局变量和局部变量的区别就是，全局变量在子程序中仍然有效，局部变量只在当前程序中生效。（注意，一旦退出父程序这个bash的话，无论是全局变量还是局部变量都失效了，再次打开bash时，该变量是不存在的）</p> 
<p>变量范围</p> 
<h5><a id="_26"></a>变量的设定</h5> 
<p>变量的设定有几个规则，这里列举如下:</p> 
<ul><li>设定变量通过=来链接，例如name=sujinzhou,两边不能有空格，如果有空格的话，需要用引号</li><li>变量名只能是英文名和数字，只能是英文开头</li><li>如果变量内容被引号扩起来的话，双引号和单引号是有区别的</li><li>双引号里面的特殊字符，会保持原有的特性。</li><li>单引号里面的特殊字符，只会是字符</li><li>使用\将特殊字符转换为一般字符</li><li>使用``这个符号扩起来的命令会先计算这个命令里面的内容，这个指令等价于<code>$()</code></li><li>给原有的变量添加值时，使用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           变 
          
         
           量 
          
         
        
          , 
         
        
          " 
         
        
       
         {变量}," 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">"</span></span></span></span></span>变量"再加具体的内容</li></ul> 
<p>变量类型</p> 
<p>bash中变量类型有两种，一种是普通的字符串，一种是整数;设置变量的类型使用的是declare命令，delcare的命令格式如下</p> 
<pre><code>declare -[axir] variable
</code></pre> 
<p>参数的意思:</p> 
<ul><li><code>-a</code>:将variable定义为数组</li><li><code>-i</code>:将后面的变量设置为整数类型</li><li><code>-x</code>:与export一样，将后面的变量设置为环境变量</li><li><code>-r</code>:将后面的变量设置为只读变量<br> 如果declare命令没有接任何变量的话，则表示显示所哟的</li></ul> 
<p>定义数组</p> 
<pre><code>var[index]=content
</code></pre> 
<h5><a id="_55"></a>变量的删除</h5> 
<p>删除变量使用如下命令</p> 
<ul><li>unset 变量名</li></ul> 
<h5><a id="_59"></a>变量的查看</h5> 
<p>查看单个命令的内容，可以使用echo命令，使用<code>echo $变量名</code>就可以查看变量内容，另外如果要查看所有变量有3个命令，分别是如下几个命令，每个命令又有区别。</p> 
<ul><li><code>echo $变量名</code>:用于显示制定变量</li><li><code>env</code>:用来查询环境变量，</li><li><code>set</code>:显示shell变量，包括私有变量与用户变量，不同的shell有不同的私有变量，在shell中设置变量之后，可以通过set查到</li><li><code>export</code>:显示当前导出成用户变量的shell变量，也是用来查询环境变量的，shell的私有变量不会出现</li></ul> 
<h5><a id="Bash_shell_66"></a>Bash shell的操作环境</h5> 
<p>在shell中设置的变量，无论是环境变量还是自定义变量，在bash中注销登录之后，就失效了。下次登录时，是没有这些变量的，如果想要这些变量永久生效，是需要下如配置文件的，bash在启动时，会读取这个配置文件，来设置当前shell的各种变量。shell分为两种，分别是login shell和nonlogin shell，这里先说login shell；login shell是需要输入用户名和密码的，一般情况下，login shell在登录之后，会去读取两个文件，来设置当前shell的环境变量，分别是</p> 
<ol><li>/etc/profile:这个配置文件是默认配置文件，是系统整体的设置</li><li>~/.bash_profile或者~/.bash_login或者~/.profile：这个是用户的自定义设置文件</li></ol> 
<p>shell在读取/etc/profile中的文件之后，会去读取用户自定义的设置文件，按照顺序读取上文中所说的自定义设置文件，只要找到其中任何一个，就不再继续。在用户自定义的配置文件中，都会调用~/.bashrc这个文件，来配置当前的这个shell</p> 
<p>/etc/profile或者~/.bash_profile都是在登录的时候才去读取，如果将自己的一些设置到这些文件之后，一般都需要重新登录一次shell才会生效，也可以使用source这个命令，来读取配置文件的内容到当前的这个shell</p> 
<h5><a id="_76"></a>数据流重导向</h5> 
<p>数据重导向，表示将数据从一个地方导向到另外一个地方，在linux的bash中，有两种输出，分别是</p> 
<ul><li>标准输出:输出在屏幕当中的正常的提示信息，或者正常的返回值</li><li>错误输出:命令执行出错时，显示在屏幕当中的出错信息</li></ul> 
<p>有时候，我们需要将标准输出或者错误输出保留到某个文件中，方便以后你查询，这种情况下，就需要数据流重导向，也就是将输出到屏幕的信息导向到一个文件中。而导向又分为标准输出导向和错误输出导向</p> 
<ul><li>标准输出重导向:代码为1,使用&gt;或者&gt;&gt;</li><li>错误输出重导向:代码为2,使用2&gt;或者2&gt;&gt;</li></ul> 
<p>在linux中一个特殊的装置，是/dev/null，所有将导向到这个装置的数据都会被丢弃，相当与删除数据。</p> 
<p>有时候，我们需要将标准输出和错误输出导出到文件中，则可以使用符号 2&gt;&amp;1，这个符号是连在一起的，表示将错误和标准输出一起输出。</p> 
<p>除了输出之外，还有输入，</p> 
<ul><li>标准输入重导向:代码为0,使用&lt;<br> 某些由键盘输入的数据，可以使用标准输入重导向，从文件中输入数据。</li></ul> 
<h5><a id="_95"></a>管线命令</h5> 
<p>常用的关系命令有如下几个，具体的用法可以查询man文件</p> 
<ul><li>选择命令 
  <ul><li>cut</li><li>grep</li></ul> </li><li>排序命令 
  <ul><li>sort</li><li>wc</li><li>uniq</li></ul> </li><li>双向重导向 
  <ul><li>tee</li></ul> </li><li>字符转换命令 
  <ul><li>tr</li><li>col</li><li>join</li><li>paste</li><li>expand</li></ul> </li><li>分割命令 
  <ul><li>split</li></ul> </li></ul> 
<h5><a id="_118"></a>其他</h5> 
<p>命令别名</p> 
<pre><code>alias             //显示所有的命令别名
alias rm='rm -i'  //设置命令别名
unalias rm        //删除命令别名
</code></pre> 
<p>历史命令</p> 
<p>使用history命令，可以显示当前shell的内存中保存的历史记录命令，这里每个shell的历史记录命令是独立的，bash在退出的时候会自动将内存中的历史命令写入到histfiles中，也可以手动将当前shell内存中的历史命令同步回histfiles中，如果想从当前shell A读取另一个shell B中的历史命令了，需要在B这个Shell中先使用命令<code>history -w</code>将内存中的命令写入到histfiles中，然后在A这个shell中使用<code>history -r</code>来将histfiles中的命令读取到内存中</p> 
<pre><code>history n     //显示最近的n笔命令的意思
history -c    //将shell中所有的history命令全部删除
history -a    //将目前新增的指令加入到histfiles中，如果不存在，则加入到~/.bash_history中
history -w    //将内存中的history指令保持到histfile中
history -r    //将histfile中的指令读取到这个shell中
</code></pre> 
<p>历史命令的读取与记录如下:</p> 
<ul><li>当使用bash登录后，去~/.bash_history中读取历史命令</li><li>注销当前bash时，会将最近的HISTFILESIZE笔命令更新到~/.bash_history中,也可以使用<code>history -w</code>命令来强制更新</li></ul> 
<p>可以使用！来执行历史命令，如下:</p> 
<pre><code>!2          //执行历史命令中的第二个命令
!command    //从最见的命令往前搜，查找以command开头的命令
!!          //执行上一个指令
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7e75567e0abbcdaeb49ec2e3d15ebd1e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">结构体数组：有5个同学的信息（包括：学号，名字，成绩），要求按照成绩从大到小的顺序输出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6344c9f0de693d49d71cdbc083089e5c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">runner.logger.info(‘loss become infinite or NaN</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>