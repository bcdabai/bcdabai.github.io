<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文了解Flutter的GetX框架 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一文了解Flutter的GetX框架" />
<meta property="og:description" content="Get 关于GetGetX的计数器示例Get三大功能状态管理响应式状态管理器声明一个响应式变量数据变化监听 简单状态管理器用法无需StatefulWidgets其他使用方法唯一标识 依赖管理controller生命周期实例方法Get.put()Get.lazyPutGet.putAsync使用实例化方法/类区别 BindingsBindings类BindingsBuilder FlutterBinding智能管理如何改变SmartManagement.fullSmartManagement.onlyBuildersSmartManagement.keepFactory Bindings的工作原理 路由配置路由路由跳转路由传参数路由获取参数SnackBarsDialogsBottomSheets嵌套导航兼容使用 实用工具国际化翻译使用翻译 语言改变语言系统语言 改变主题GetConnect默认配置自定义配置 GetPage 中间件优先级RedirectonPageCalledOnBindingsStartOnPageBuildStartOnPageBuiltOnPageDispose 其他高级APIValueBuilderGetViewGetxServiceGetUtils 关于Get GetX 是 Flutter 上的一个轻量且强大的解决方案：高性能的状态管理、智能的依赖注入和便捷的路由管理。GetX 有3个基本原则： 性能： GetX 专注于性能和最小资源消耗。GetX 打包后的apk占用大小和运行时的内存占用与其他状态管理插件不相上下。效率： GetX 的语法非常简捷，并保持了极高的性能，能极大缩短开发时长。结构： GetX 可以将界面、逻辑、依赖和路由完全解耦，逻辑更清晰，代码更容易维护。 GetX 并不臃肿，却很轻量。如果你只使用状态管理，只有状态管理模块会被编译，其他没用到的东西都不会被编译到你的代码中。它拥有众多的功能，但这些功能都在独立的容器中，只有在使用后才会启动。Getx有一个庞大的生态系统，能够在Android、iOS、Web、Mac、Linux、Windows和你的服务器上用同样的代码运行。 在Flutter三方库中，也是likes最高的
GetX的计数器示例 Flutter默认创建的 &#34;计数器 &#34;项目有100多行（含注释），这里使用 GetX 重写一个计数器 。
而完成这一切只需 26 行代码（含注释）
步骤1. 在你的MaterialApp前添加 “Get”，将其变成GetMaterialApp。 void main() =&gt; runApp(GetMaterialApp(home: Home())); GetMaterialApp只是对MaterialApp封装了一层，它的子组件是默认的MaterialApp。
如果你只用Get来进行状态管理或依赖管理，就没有必要使用GetMaterialApp。GetMaterialApp对于路由、snackbar、国际化、bottomSheet、对话框以及与路由相关的高级apis和没有上下文（context）的情况下是必要的。
第二步： 创建你的业务逻辑类，并将所有的变量，方法和控制器放在里面。 你可以使用一个简单的&#34;.obs &#34;使任何变量成为可观察的。 class Controller extends GetxController{ var count = 0.obs; increment() =&gt; count&#43;&#43;; } 第三步: 创建你的界面，使用StatelessWidget节省一些内存，使用Get你可能不再需要使用StatefulWidget。 class Home extends StatelessWidget { @override Widget build(context) { // 使用Get." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/61134fae6a6f44e8da1bb569b5a6eade/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-12T11:29:18+08:00" />
<meta property="article:modified_time" content="2022-05-12T11:29:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文了解Flutter的GetX框架</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Get</h4> 
 <ul><li><a href="#Get_2" rel="nofollow">关于Get</a></li><li><a href="#GetX_17" rel="nofollow">GetX的计数器示例</a></li><li><a href="#Get_77" rel="nofollow">Get三大功能</a></li><li><ul><li><a href="#_79" rel="nofollow">状态管理</a></li><li><ul><li><a href="#_91" rel="nofollow">响应式状态管理器</a></li><li><ul><li><a href="#_124" rel="nofollow">声明一个响应式变量</a></li><li><a href="#_170" rel="nofollow">数据变化监听</a></li></ul> 
    </li><li><a href="#_198" rel="nofollow">简单状态管理器</a></li><li><ul><li><a href="#_209" rel="nofollow">用法</a></li><li><a href="#StatefulWidgets_230" rel="nofollow">无需StatefulWidgets</a></li><li><a href="#_256" rel="nofollow">其他使用方法</a></li><li><a href="#_301" rel="nofollow">唯一标识</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_328" rel="nofollow">依赖管理</a></li><li><ul><li><a href="#controller_338" rel="nofollow">controller生命周期</a></li><li><a href="#_350" rel="nofollow">实例方法</a></li><li><ul><li><a href="#Getput_352" rel="nofollow">Get.put()</a></li><li><a href="#GetlazyPut_393" rel="nofollow">Get.lazyPut</a></li><li><a href="#GetputAsync_433" rel="nofollow">Get.putAsync</a></li><li><a href="#_465" rel="nofollow">使用实例化方法/类</a></li><li><a href="#_488" rel="nofollow">区别</a></li></ul> 
    </li><li><a href="#Bindings_503" rel="nofollow">Bindings</a></li><li><ul><li><a href="#Bindings_507" rel="nofollow">Bindings类</a></li><li><a href="#BindingsBuilder_571" rel="nofollow">BindingsBuilder</a></li></ul> 
    </li><li><a href="#FlutterBinding_601" rel="nofollow">FlutterBinding</a></li><li><ul><li><a href="#_642" rel="nofollow">智能管理</a></li><li><a href="#_646" rel="nofollow">如何改变</a></li><li><ul><li><a href="#SmartManagementfull_661" rel="nofollow">SmartManagement.full</a></li><li><a href="#SmartManagementonlyBuilders_665" rel="nofollow">SmartManagement.onlyBuilders</a></li><li><a href="#SmartManagementkeepFactory_673" rel="nofollow">SmartManagement.keepFactory</a></li></ul> 
     </li><li><a href="#Bindings_677" rel="nofollow">Bindings的工作原理</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_685" rel="nofollow">路由</a></li><li><ul><li><a href="#_687" rel="nofollow">配置路由</a></li><li><a href="#_725" rel="nofollow">路由跳转</a></li><li><a href="#_759" rel="nofollow">路由传参数</a></li><li><a href="#_793" rel="nofollow">路由获取参数</a></li><li><a href="#SnackBars_815" rel="nofollow">SnackBars</a></li><li><a href="#Dialogs_891" rel="nofollow">Dialogs</a></li><li><a href="#BottomSheets_912" rel="nofollow">BottomSheets</a></li><li><a href="#_937" rel="nofollow">嵌套导航</a></li><li><a href="#_985" rel="nofollow">兼容使用</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_1013" rel="nofollow">实用工具</a></li><li><ul><li><a href="#_1015" rel="nofollow">国际化</a></li><li><ul><li><a href="#_1017" rel="nofollow">翻译</a></li><li><ul><li><a href="#_1039" rel="nofollow">使用翻译</a></li></ul> 
    </li><li><a href="#_1052" rel="nofollow">语言</a></li><li><ul><li><a href="#_1064" rel="nofollow">改变语言</a></li><li><a href="#_1073" rel="nofollow">系统语言</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_1085" rel="nofollow">改变主题</a></li><li><a href="#GetConnect_1106" rel="nofollow">GetConnect</a></li><li><ul><li><a href="#_1110" rel="nofollow">默认配置</a></li><li><a href="#_1135" rel="nofollow">自定义配置</a></li></ul> 
   </li><li><a href="#GetPage__1184" rel="nofollow">GetPage 中间件</a></li><li><ul><li><a href="#_1190" rel="nofollow">优先级</a></li><li><a href="#Redirect_1205" rel="nofollow">Redirect</a></li><li><a href="#onPageCalled_1216" rel="nofollow">onPageCalled</a></li><li><a href="#OnBindingsStart_1227" rel="nofollow">OnBindingsStart</a></li><li><a href="#OnPageBuildStart_1241" rel="nofollow">OnPageBuildStart</a></li><li><a href="#OnPageBuilt_1252" rel="nofollow">OnPageBuilt</a></li><li><a href="#OnPageDispose_1256" rel="nofollow">OnPageDispose</a></li></ul> 
   </li><li><a href="#API_1260" rel="nofollow">其他高级API</a></li><li><ul><li><a href="#ValueBuilder_1392" rel="nofollow">ValueBuilder</a></li><li><a href="#GetView_1409" rel="nofollow">GetView</a></li><li><a href="#GetxService_1432" rel="nofollow">GetxService</a></li><li><a href="#GetUtils_1513" rel="nofollow">GetUtils</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Get_2"></a>关于Get</h2> 
<ul><li>GetX 是 Flutter 上的一个轻量且强大的解决方案：高性能的状态管理、智能的依赖注入和便捷的路由管理。</li><li>GetX 有3个基本原则： 
  <ul><li><strong>性能：</strong> GetX 专注于性能和最小资源消耗。GetX 打包后的apk占用大小和运行时的内存占用与其他状态管理插件不相上下。</li><li><strong>效率：</strong> GetX 的语法非常简捷，并保持了极高的性能，能极大缩短开发时长。</li><li><strong>结构：</strong> GetX 可以将界面、逻辑、依赖和路由完全解耦，逻辑更清晰，代码更容易维护。</li></ul> </li><li>GetX 并不臃肿，却很轻量。如果你只使用状态管理，只有状态管理模块会被编译，其他没用到的东西都不会被编译到你的代码中。它拥有众多的功能，但这些功能都在独立的容器中，只有在使用后才会启动。</li><li>Getx有一个庞大的生态系统，能够在Android、iOS、Web、Mac、Linux、Windows和你的服务器上用同样的代码运行。</li></ul> 
<p>在Flutter三方库中，也是likes最高的</p> 
<p><img src="https://images2.imgbox.com/74/52/C5fDCZPm_o.png" alt="请添加图片描述"></p> 
<h2><a id="GetX_17"></a>GetX的计数器示例</h2> 
<p>Flutter默认创建的 "计数器 "项目有100多行（含注释），这里使用 GetX 重写一个计数器 。</p> 
<p>而完成这一切只需 <strong>26 行代码（含注释）</strong></p> 
<ul><li>步骤1. 在你的MaterialApp前添加 “Get”，将其变成GetMaterialApp。</li></ul> 
<pre><code class="prism language-dart">void main() =&gt; runApp(GetMaterialApp(home: Home()));
</code></pre> 
<blockquote> 
 <p>GetMaterialApp只是对MaterialApp封装了一层，它的子组件是默认的MaterialApp。</p> 
 <p>如果你只用Get来进行状态管理或依赖管理，就没有必要使用GetMaterialApp。GetMaterialApp对于路由、snackbar、国际化、bottomSheet、对话框以及与路由相关的高级apis和没有上下文（context）的情况下是必要的。</p> 
</blockquote> 
<ul><li>第二步： 创建你的业务逻辑类，并将所有的变量，方法和控制器放在里面。 你可以使用一个简单的".obs "使任何变量成为可观察的。</li></ul> 
<pre><code class="prism language-dart">class Controller extends GetxController{
  var count = 0.obs;
  increment() =&gt; count++;
}
</code></pre> 
<ul><li>第三步: 创建你的界面，使用StatelessWidget节省一些内存，使用Get你可能不再需要使用StatefulWidget。</li></ul> 
<pre><code class="prism language-dart">class Home extends StatelessWidget {

  @override
  Widget build(context) {

    // 使用Get.put()实例化你的类，使其对当下的所有子路由可用。
    final Controller c = Get.put(Controller());

    return Scaffold(
      // 使用Obx(()=&gt;每当改变计数时，就更新Text()。
      appBar: AppBar(title: Obx(() =&gt; Text("Clicks: ${c.count}"))),

      // 用一个简单的Get.to()即可代替Navigator.push那8行，无需上下文！
      body: Center(child: ElevatedButton(
              child: Text("Go to Other"), onPressed: () =&gt; Get.to(Other()))),
      floatingActionButton:
          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));
  }
}

class Other extends StatelessWidget {
  // 你可以让Get找到一个正在被其他页面使用的Controller，并将它返回给你。
  final Controller c = Get.find();

  @override
  Widget build(context){
     // 访问更新后的计数变量
     return Scaffold(body: Center(child: Text("${c.count}")));
  }
}
</code></pre> 
<h2><a id="Get_77"></a>Get三大功能</h2> 
<h3><a id="_79"></a>状态管理</h3> 
<p>目前，Flutter有几种状态管理器。但是，它们中的大多数都涉及到使用ChangeNotifier来更新widget，这对于功能复杂的应用是比较麻烦的。在Flutter的官方文档中查看到，ChangeNotifier使用了1个或多个监听器来达到状态管理。</p> 
<blockquote> 
 <p>A class that can be extended or mixed in that provides a change notification API using VoidCallback for notifications.</p> 
 <p>It is O(1) for adding listeners and O(N) for removing listeners and dispatching notifications (where N is the number of listeners).</p> 
</blockquote> 
<p>Get是一个微框架，而不仅仅是一个状态管理器，<strong>既可以单独使用，也可以与其他状态管理器结合使用</strong>，意味着引用进我们的项目中，并不会影响之前的功能。</p> 
<p>Get有两个不同的状态管理器：简单的状态管理器（GetBuilder）和响应式状态管理器（GetX）。</p> 
<h4><a id="_91"></a>响应式状态管理器</h4> 
<p>响应式状态管理器使用响应式编程。</p> 
<ul><li>你不需要创建StreamControllers.</li><li>你不需要为每个变量创建一个StreamBuilder。</li><li>你不需要为每个状态创建一个类。</li><li>你不需要为一个初始值创建一个get。</li></ul> 
<p>比如现在有一个名称变量，并且希望每次改变它时，所有使用它的小组件都会自动刷新。</p> 
<pre><code class="prism language-dart">var name = 'Abc';
</code></pre> 
<p>要想让它变得可观察，你只需要在它的末尾加上".obs"。</p> 
<pre><code class="prism language-dart">var name = 'Abc'.obs;
</code></pre> 
<p>而在UI中，当你想显示该值并在值变化时更新页面，只需这样做。</p> 
<pre><code>Obx(() =&gt; Text("${controller.name}"));
</code></pre> 
<p>我们把这个".obs"变量称为 <em>Rx</em> 。</p> 
<p>原理就是创建了一个 "Stream "的 “String”，分配了初始值 “Abc”，我们通知所有使用 "Abc "的widgets，它们现在 "属于 "这个变量，当_Rx_的值发生变化时，它们也要随之改变，监听流的变化。</p> 
<p>如果<code>name</code>是<code>"Abc"</code>，你把它改成了<code>"Abc"</code>，因为它进行增量变化，所以界面上不会有任何变化，也不会重建Widget。</p> 
<h5><a id="_124"></a>声明一个响应式变量</h5> 
<p>你有3种方法可以把一个变量变成是 “可观察的”。</p> 
<p>1 - 第一种是使用 <strong><code>Rx{Type}</code></strong>。</p> 
<pre><code class="prism language-dart">// 建议使用初始值，但不是强制性的
final name = RxString('');
final isLogged = RxBool(false);
final count = RxInt(0);
final balance = RxDouble(0.0);
final items = RxList&lt;String&gt;([]);
final myMap = RxMap&lt;String, int&gt;({});
</code></pre> 
<p>2 - 第二种是使用 <strong><code>Rx</code></strong>，规定泛型 <code>Rx&lt;Type&gt;</code>。</p> 
<pre><code class="prism language-dart">  final name = Rx&lt;String&gt;('');
  final isLogged = Rx&lt;bool&gt;(false);
  final count = Rx&lt;int&gt;(0);
  final balance = Rx&lt;double&gt;(0.0);
  final number = Rx&lt;num&gt;(0)
  final items = Rx&lt;List&lt;String&gt;&gt;([]);
  final myMap = Rx&lt;Map&lt;String, int&gt;&gt;({});

</code></pre> 
<p>3 - 第三种更实用、更简单、更可取的方法，只需添加 <strong><code>.obs</code></strong> 作为<code>value</code>的属性。</p> 
<pre><code class="prism language-dart">final name = ''.obs;
final isLogged = false.obs;
final count = 0.obs;
final balance = 0.0.obs;
final number = 0.obs;
final items = &lt;String&gt;[].obs;
final myMap = &lt;String, int&gt;{}.obs;

// 自定义类 - 可以是任何类
final user = User().obs;
</code></pre> 
<h5><a id="_170"></a>数据变化监听</h5> 
<p>除了使用 <code>Obx</code> 实现界面数据自动刷新外，GetX 提供了多种手动方式对响应式变量进行数据变化监听</p> 
<pre><code class="prism language-dart">///每次`count1`变化时调用。
ever(count1, (_) =&gt; print("$_ has been changed"));

///只有在变量$_第一次被改变时才会被调用。
once(count1, (_) =&gt; print("$_ was changed once"));

///防DDos - 每当用户停止输入1秒时调用，例如。
debounce(count1, (_) =&gt; print("debouce$_"), time: Duration(seconds: 1));

///忽略1秒内的所有变化。
interval(count1, (_) =&gt; print("interval $_"), time: Duration(seconds: 1));
</code></pre> 
<p>这些手动监听方式(除 "debounce "外)都有一个名为 "condition"的参数，它可以是一个 "bool "或一个返回 "bool "的回调。 这个<code>condition</code>定义了<code>callback</code>函数何时执行。</p> 
<p>所有这些方法都会返回一个<code>Worker</code>实例，你可以用它来取消（通过<code>dispose()</code>）worker。</p> 
<ul><li><strong><code>ever</code></strong> 当数据发生改变时触发</li><li><strong><code>everAll</code></strong> 和 "ever "很像，只是监听的是多个响应式变量的变化，当其中一个发生变化就会触发回调</li><li><strong><code>once</code></strong> 只在变量第一次被改变时被调用</li><li><strong><code>debounce</code></strong> 防抖，即延迟一定时间调用，且在规定时间内只有最后一次改变会触发回调。如设置时间为 1 秒，发生了3次数据变化，每次间隔500毫秒，则只有最后一次变化会触发回调。</li><li><strong><code>interval</code></strong> 时间间隔内只有最后一次变化会触发回调。如设置时间间隔为1秒，则在1秒内无论点击多少次都只有最后一次会触发回调，然后进入下一次的时间间隔。</li></ul> 
<h4><a id="_198"></a>简单状态管理器</h4> 
<p>Get有一个极其轻巧简单的状态管理器，它不使用ChangeNotifier，可以满足特别是对Flutter新手的需求，而且不会给大型应用带来问题。</p> 
<ol><li>只更新需要的小部件。</li><li>不使用changeNotifier，状态管理器使用较少的内存（接近0mb）。</li><li>真正的解耦你的项目! 控制器一定不要在你的UI中，把你的TextEditController，或者你使用的任何控制器放在你的Controller类中。</li><li>仅在必要时使用流。你可以在你的控制器里面正常使用你的StreamControllers，也可以正常使用StreamBuilder，一个流消耗合理的内存，响应式编程很美，但是你不应该滥用它。</li><li>更新widgets而不需要为此花费内存。Get只存储GetBuilder的创建者ID，必要时更新该GetBuilder。get ID存储在内存中的消耗非常低，即使是成千上万的GetBuilders。当你创建一个新的GetBuilder时，你实际上是在共享拥有创建者ID的GetBuilder的状态。不会为每个GetBuilder创建一个新的状态，这为大型应用节省了大量的内存。基本上你的应用程序将是完全无状态的，而少数有状态的Widgets(在GetBuilder内)将有一个单一的状态，因此更新一个状态将更新所有的状态。状态只是一个。</li><li>Get有很强大的控制器内存管理，会在合适的时候进行销毁或创建。</li></ol> 
<h5><a id="_209"></a>用法</h5> 
<pre><code class="prism language-dart">// 创建控制器类并扩展GetxController。
class Controller extends GetxController {
  int counter = 0;
  void increment() {
    counter++;
    update(); // 当调用增量时，使用update()来更新用户界面上的计数器变量。
  }
}
// 在你的Stateless/Stateful类中，当调用increment时，使用GetBuilder来更新Text。
GetBuilder&lt;Controller&gt;(
  init: Controller(), // 首次启动
  builder: (_) =&gt; Text(
    '${_.counter}',
  ),
)
//只在第一次时初始化你的控制器。第二次使用ReBuilder时，不要再使用同一控制器。一旦将控制器标记为 "init "的部件部署完毕，你的控制器将自动从内存中移除。你不必担心这个问题，Get会自动做到这一点，只是要确保你不要两次启动同一个控制器。
</code></pre> 
<h5><a id="StatefulWidgets_230"></a>无需StatefulWidgets</h5> 
<p>使用StatefulWidgets意味着不必要地存储整个界面的状态，甚至因为如果你需要最小化地重建一个widget，你会把它嵌入一个Consumer/Observer/BlocProvider/GetBuilder/GetX/Obx中，这将是另一个StatefulWidget。 StatefulWidget类是一个比StatelessWidget大的类，它将分配更多的内存，只使用一两个类之间可能不会有明显的区别，但当你有100个类时，它肯定会有区别! 除非你需要使用混合器，比如TickerProviderStateMixin，否则完全没有必要使用StatefulWidget与Get。</p> 
<p>你可以直接从GetBuilder中调用StatefulWidget的所有方法。 例如，如果你需要调用initState()或dispose()方法，你可以直接调用它们。</p> 
<pre><code class="prism language-dart">GetBuilder&lt;Controller&gt;(
  initState: (_) =&gt; Controller.to.fetchApi(),
  dispose: (_) =&gt; Controller.to.closeStreams(),
  builder: (s) =&gt; Text('${s.username}'),
),
</code></pre> 
<p>比这更好的方法是直接从控制器中使用onInit()和onClose()方法。</p> 
<pre><code class="prism language-dart">@override
void onInit() {
  fetchApi();
  super.onInit();
}
</code></pre> 
<blockquote> 
 <p>如果你想在控制器第一次被调用的那一刻启动一个方法，你不需要为此使用构造函数，在控制器内有onInit();和onClose();方法就是为此而创建的，它们会在Controller被创建，或者第一次使用时被调用，这取决于你是否使用Get.lazyPut。</p> 
</blockquote> 
<h5><a id="_256"></a>其他使用方法</h5> 
<p>你可以直接在GetBuilder值上使用Controller实例。</p> 
<pre><code class="prism language-dart">GetBuilder&lt;Controller&gt;(
  init: Controller(),
  builder: (value) =&gt; Text(
    '${value.counter}', //here
  ),
),
</code></pre> 
<p>你可能还需要在GetBuilder之外的控制器实例，你可以使用这些方法来实现。</p> 
<pre><code class="prism language-dart">class Controller extends GetxController {
  static Controller get to =&gt; Get.find();
[...]
}
//view
GetBuilder&lt;Controller&gt;(  
  init: Controller(), // 每个控制器只用一次
  builder: (_) =&gt; Text(
    '${Controller.to.counter}', //here
  )
),
</code></pre> 
<p>或者</p> 
<pre><code class="prism language-dart">class Controller extends GetxController {
 // static Controller get to =&gt; Get.find(); // with no static get
[...]
}
// on stateful/stateless class
GetBuilder&lt;Controller&gt;(  
  init: Controller(), // 每个控制器只用一次
  builder: (_) =&gt; Text(
    '${Get.find&lt;Controller&gt;().counter}', //here
  ),
),
</code></pre> 
<h5><a id="_301"></a>唯一标识</h5> 
<p>如果你想只更新某个或者特定的widget控件，你可以给它们分配唯一的ID。</p> 
<pre><code class="prism language-dart">GetBuilder&lt;Controller&gt;(
  id: 'text', //这里
  init: Controller(), // 每个控制器只用一次
  builder: (_) =&gt; Text(
    '${Get.find&lt;Controller&gt;().counter}', //here
  ),
),
</code></pre> 
<p>并更新它：</p> 
<pre><code class="prism language-dart">update(['text']);
</code></pre> 
<p>还可以为更新设置条件。</p> 
<pre><code class="prism language-dart">update(['text'], counter &lt; 10);
</code></pre> 
<p>GetX会自动进行重建，并且只重建使用被更改的变量的小组件，如果您将一个变量更改为与之前相同的变量，并且不意味着状态的更改，GetX不会重建小组件以节省内存和CPU周期（界面上正在显示3，而您再次将变量更改为3。在大多数状态管理器中，这将导致一个新的重建，但在GetX中，如果事实上他的状态已经改变，那么widget将只被再次重建）</p> 
<h3><a id="_328"></a>依赖管理</h3> 
<p>Get有一个简单而强大的依赖管理器，它允许你只用1行代码就能检索到与你的Bloc或Controller相同的类，无需Provider上下文，无需 inheritedWidget。</p> 
<pre><code class="prism language-dart">Controller controller = Get.put(Controller()); // 而不是 Controller controller = Controller();
</code></pre> 
<p>你是在Get实例中实例化它，而不是在你正在使用的类中实例化你的类，这将使它在整个App中可用。 所以你可以正常使用你的控制器（或Bloc类）。</p> 
<h4><a id="controller_338"></a>controller生命周期</h4> 
<p>比方说，我们有这样的情况。</p> 
<pre><code class="prism language-dart">Class a =&gt; Class B (has controller X) =&gt; Class C (has controller X)
</code></pre> 
<p>在A类中，控制器还没有进入内存，因为你还没有使用它（Get是懒加载）。在类B中，你使用了控制器，并且它进入了内存。在C类中，你使用了与B类相同的控制器，Get会将控制器B的状态与控制器C共享，同一个控制器还在内存中。如果你关闭C屏和B屏，Get会自动将控制器X从内存中移除，释放资源，因为a类没有使用该控制器。</p> 
<p>如果你再次导航到B，控制器X将再次进入内存，如果你没有去C类，而是再次回到a类，Get将以同样的方式将控制器从内存中移除。如果类C没有使用控制器，你把类B从内存中移除，就没有类在使用控制器X，同样也会被处理掉。唯一能让Get乱了阵脚的例外情况，是如果你意外地从路由中删除了B，并试图使用C中的控制器，在这种情况下，B中的控制器的创建者ID被删除了，Get被设计为从内存中删除每一个没有创建者ID的控制器。如果你打算这样做，在B类的GetBuilder中添加 "autoRemove: false "标志，并在C类的GetBuilder中使用adopID = true；</p> 
<h4><a id="_350"></a>实例方法</h4> 
<h5><a id="Getput_352"></a>Get.put()</h5> 
<p>最常见的插入依赖关系的方式。例如，对于你的视图的控制器来说：</p> 
<pre><code class="prism language-dart">Get.put&lt;SomeClass&gt;(SomeClass());
Get.put&lt;LoginController&gt;(LoginController(), permanent: true);
Get.put&lt;ListItemController&gt;(ListItemController, tag: "some unique string");
</code></pre> 
<p>这是你使用put时可以设置的所有选项。</p> 
<pre><code class="prism language-dart">Get.put&lt;S&gt;(
  // 必备：你想得到保存的类，比如控制器或其他东西。
  // 注："S "意味着它可以是任何类型的类。
  S dependency

  // 可选：当你想要多个相同类型的类时，可以用这个方法。
  // 因为你通常使用Get.find&lt;Controller&gt;()来获取一个类。
  // 你需要使用标签来告诉你需要哪个实例。
  // 必须是唯一的字符串
  String tag,

  // 可选：默认情况下，get会在实例不再使用后进行销毁
  // （例如：一个已经销毁的视图的Controller)
  // 但你可能需要这个实例在整个应用生命周期中保留在那里，就像一个sharedPreferences的实例或其他东西。
  //所以你设置这个选项
  // 默认值为false
  bool permanent = false,

  // 可选：允许你在测试中使用一个抽象类后，用另一个抽象类代替它，然后再进行测试。
  // 默认为false
  bool overrideAbstract = false,

  // 可选：允许你使用函数而不是依赖（dependency）本身来创建依赖。
  // 这个不常用
  InstanceBuilderCallback&lt;S&gt; builder,
)
</code></pre> 
<h5><a id="GetlazyPut_393"></a>Get.lazyPut</h5> 
<p>可以懒加载一个依赖，这样它只有在使用时才会被实例化。这对于计算代价高的类来说非常有用，或者如果你想在一个地方实例化几个类（比如在Bindings类中），而且你知道你不会在那个时候使用这个类。</p> 
<pre><code class="prism language-dart">///只有当第一次使用Get.find&lt;ApiMock&gt;时，ApiMock才会被调用。
Get.lazyPut&lt;ApiMock&gt;(() =&gt; ApiMock());

Get.lazyPut&lt;FirebaseAuth&gt;(
  () {
    // ... some logic if needed
    return FirebaseAuth();
  },
  tag: Math.random().toString(),
  fenix: true
)

Get.lazyPut&lt;Controller&gt;( () =&gt; Controller() )
</code></pre> 
<p>这是你在使用lazyPut时可以设置的所有选项。</p> 
<pre><code class="prism language-dart">Get.lazyPut&lt;S&gt;(
  // 强制性：当你的类第一次被调用时，将被执行的方法。
  InstanceBuilderCallback builder,
  
  // 可选：和Get.put()一样，当你想让同一个类有多个不同的实例时，就会用到它。
  // 必须是唯一的
  String tag,

  // 可选：类似于 "永久"，
  // 不同的是，当不使用时，实例会被丢弃，但当再次需要使用时，Get会重新创建实例，
  // 就像 bindings api 中的 "SmartManagement.keepFactory "一样。
  // 默认值为false
  bool fenix = false
  
)
</code></pre> 
<h5><a id="GetputAsync_433"></a>Get.putAsync</h5> 
<p>如果你想注册一个异步实例，你可以使用<code>Get.putAsync</code>。</p> 
<pre><code class="prism language-dart">Get.putAsync&lt;SharedPreferences&gt;(() async {
  final prefs = await SharedPreferences.getInstance();
  await prefs.setInt('counter', 12345);
  return prefs;
});

Get.putAsync&lt;YourAsyncClass&gt;( () async =&gt; await YourAsyncClass() )
</code></pre> 
<p>这都是你在使用putAsync时可以设置的选项。</p> 
<pre><code class="prism language-dart">Get.putAsync&lt;S&gt;(

  // 必备：一个将被执行的异步方法，用于实例化你的类。
  AsyncInstanceBuilderCallback&lt;S&gt; builder,

  // 可选：和Get.put()一样，当你想让同一个类有多个不同的实例时，就会用到它。
  // 必须是唯一的
  String tag,

  // 可选：与Get.put()相同，当你需要在整个应用程序中保持该实例的生命时使用。
  // 默认值为false
  bool permanent = false
)
</code></pre> 
<h5><a id="_465"></a>使用实例化方法/类</h5> 
<p>Get为你的控制器自动 "寻找"在堆栈中并没有销毁的数据，你不需要任何额外的依赖关系。</p> 
<pre><code class="prism language-dart">final controller = Get.find&lt;Controller&gt;();
// 或者
Controller controller = Get.find();
</code></pre> 
<p>然后你就可以恢复你在后面获得的控制器数据。</p> 
<pre><code class="prism language-dart">Text(controller.textFromApi);
</code></pre> 
<p>由于返回的值是一个正常的类，你可以做任何你想做的事情。</p> 
<pre><code class="prism language-dart">int count = Get.find&lt;SharedPreferences&gt;().getInt('counter');
print(count); // out: 12345
</code></pre> 
<h5><a id="_488"></a>区别</h5> 
<p>首先，让我们来看看Get.lazyPut的 "fenix "和其他方法的 “permanent”。</p> 
<p><code>permanent</code>和<code>fenix</code>的根本区别在于你想如何存储实例。</p> 
<p>强化：默认情况下，GetX会在不使用实例时删除它们。 这意味着 如果页面1有控制器1，页面2有控制器2，而你从堆栈中删除了第一个路由，（比如你使用<code>Get.off()</code>或<code>Get.offNamed()</code>）控制器1失去了它的使用，所以它将被删除。</p> 
<p>但是如果你想选择使用<code>permanent:true</code>，那么控制器就不会在这个过渡中丢失–这对于你想在整个应用程序中保持生命的服务来说非常有用。</p> 
<p><code>fenix</code>则是针对那些你不担心在页面变化之间丢失的服务，但当你需要该服务时，你希望它还活着。所以基本上，它会处理未使用的控制器/服务/类，但当你需要它时，它会 重新创建一个新的实例。</p> 
<ul><li>Get.put和Get.putAsync的创建顺序是一样的，不同的是，第二个方法使用的是异步方法创建和初始化实例。put是直接插入内存，使用内部方法<code>insert</code>，参数<code>permanent: false</code>和<code>isSingleton: true</code>（这个isSingleton参数只是告诉它是使用<code>dependency</code>上的依赖，还是使用<code>FcBuilderFunc</code>上的依赖），之后，调用<code>Get.find()</code>，立即初始化内存中的实例。</li><li>Get.lazyPut。顾名思义，这是一个懒加载的过程。实例被创建了，但它并没有被调用来立即使用，而是一直等待被调用。与其他方法相反，这里没有调用 “insert”。取而代之的是，实例被插入到内存的另一个部分，这个部分负责判断实例是否可以被重新创建，我们称之为 “工厂”。如果我们想创建一些以后使用的东西，它不会和现在使用的东西混在一起。这就是 "fenix "的魔力所在：如果你选择留下 “fenix: false”，并且你的 "smartManagement "不是 “keepFactory”，那么当使用 "Get.find "时，实例将把内存中的位置从 "工厂 "改为普通实例内存区域。紧接着，默认情况下，它将从 "工厂 "中移除。现在，如果你选择 “fenix: true”，实例将继续存在这个专用的部分，甚至进入公共区域，以便将来再次被调用。</li></ul> 
<h4><a id="Bindings_503"></a>Bindings</h4> 
<p>这个包最大的区别之一，也许就是可以将路由、状态管理器和依赖管理器完全集成。 当一个路由从Stack中移除时，所有与它相关的控制器、变量和对象的实例都会从内存中移除。如果你使用的是流或定时器，它们会自动关闭，你不必担心这些。 在2.10版本中，Get完全实现了Bindings API。 现在你不再需要使用init方法了。如果你不想的话，你甚至不需要键入你的控制器。你可以在适当的地方启动你的控制器和服务来实现。 Binding类是一个将解耦依赖注入的类，同时 "Bindings "路由到状态管理器和依赖管理器。 这使得Get可以知道当使用某个控制器时，哪个页面正在显示，并知道在哪里以及如何销毁它。 此外，Binding类将允许你拥有SmartManager配置控制。你可以配置依赖关系，当从堆栈中删除一个路由时，或者当使用它的widget被布置时，或者两者都不布置。你将有智能依赖管理为你工作，但即使如此，你也可以按照你的意愿进行配置。</p> 
<h5><a id="Bindings_507"></a>Bindings类</h5> 
<ul><li>创建一个类并实现Binding</li></ul> 
<pre><code class="prism language-dart">class HomeBinding implements Bindings {}
</code></pre> 
<p>你的IDE会自动要求你重写 "dependencies"方法，然后插入你要在该路由上使用的所有类。</p> 
<pre><code class="prism language-dart">class HomeBinding implements Bindings {
  @override
  void dependencies() {
    Get.lazyPut&lt;HomeController&gt;(() =&gt; HomeController());
    Get.put&lt;Service&gt;(()=&gt; Api());
  }
}

class DetailsBinding implements Bindings {
  @override
  void dependencies() {
    Get.lazyPut&lt;DetailsController&gt;(() =&gt; DetailsController());
  }
}
</code></pre> 
<p>现在你只需要通知你的路由，你将使用该 Binding 来建立路由管理器、依赖关系和状态之间的连接。</p> 
<ul><li>使用别名路由：</li></ul> 
<pre><code class="prism language-dart">getPages: [
  GetPage(
    name: '/',
    page: () =&gt; HomeView(),
    binding: HomeBinding(),
  ),
  GetPage(
    name: '/details',
    page: () =&gt; DetailsView(),
    binding: DetailsBinding(),
  ),
];
</code></pre> 
<ul><li>使用正常路由。</li></ul> 
<pre><code class="prism language-dart">Get.to(Home(), binding: HomeBinding());
Get.to(DetailsView(), binding: DetailsBinding())
</code></pre> 
<p>至此，你不必再担心你的应用程序的内存管理，Get将为你做这件事。</p> 
<p>Binding类在调用路由时被调用，你可以在你的GetMaterialApp中创建一个 "initialBinding "来插入所有将要创建的依赖关系。</p> 
<pre><code class="prism language-dart">GetMaterialApp(
  initialBinding: SampleBind(),
  home: Home(),
);
</code></pre> 
<h5><a id="BindingsBuilder_571"></a>BindingsBuilder</h5> 
<p>创建Bindings的默认方式是创建一个实现Bindings的类，但是，你也可以使用<code>BindingsBuilder</code>回调，这样你就可以简单地使用一个函数来实例化任何你想要的东西。</p> 
<p>例子:</p> 
<pre><code class="prism language-dart">getPages: [
  GetPage(
    name: '/',
    page: () =&gt; HomeView(),
    binding: BindingsBuilder(() {
      Get.lazyPut&lt;ControllerX&gt;(() =&gt; ControllerX());
      Get.put&lt;Service&gt;(()=&gt; Api());
    }),
  ),
  GetPage(
    name: '/details',
    page: () =&gt; DetailsView(),
    binding: BindingsBuilder(() {
      Get.lazyPut&lt;DetailsController&gt;(() =&gt; DetailsController());
    }),
  ),
];
</code></pre> 
<p>这样一来，你就可以避免为每条路径创建一个 Binding 类，使之更加简单。</p> 
<p>两种方式都可以完美地工作，我们希望您使用最适合您的风格。</p> 
<h4><a id="FlutterBinding_601"></a>FlutterBinding</h4> 
<p>还可以在项目启动时，使用flutter的binding去绑定。</p> 
<pre><code class="prism language-dart">Future&lt;void&gt; init() async {
  final sharedPreference = await SharedPreferences.getInstance();
  
  Get.lazyPut(() =&gt; sharedPreference);
  // api client
  Get.lazyPut(() =&gt; ApiClient(appBaseUrl: AppConstants.BASE_URL));

  // repos
  Get.lazyPut(() =&gt; PopularProductRepo(apiClient: Get.find()));
  Get.lazyPut(() =&gt; RecommendedProductRepo(apiClient: Get.find()));
  Get.lazyPut(() =&gt; CartRepo(sharedPreferences: Get.find()));
  Get.lazyPut(() =&gt; AuthRepository(apiClient: Get.find(), sharedPreferences: Get.find()));

  // controllers
  Get.lazyPut(() =&gt; AuthController(authRepository: Get.find()));
  Get.lazyPut(() =&gt; PopularProductController(popularProductRepo: Get.find()));
  Get.lazyPut(() =&gt; RecommendedProductController(recommendedProductRepo: Get.find()));
  // 这里使用lazyput会导致提取释放，而报错--解决报错就是在之前的页面中使用一下，这样就不会释放，或者直接put进去
  Get.lazyPut(() =&gt; CartController(cartRepo: Get.find()));
  // Get.put(CartController(cartRepo: Get.find()));
}

-----------------------------
// 然后在启动app时调用
import 'helper/dependencies.dart' as dep;

Future&lt;void&gt; main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await dep.init();

  runApp(const MyApp());
}
</code></pre> 
<p>这样不会去绑定到对应的页面，只有在对应的页面使用到的时候，才会加载。</p> 
<h5><a id="_642"></a>智能管理</h5> 
<p>GetX 默认情况下会将未使用的控制器从内存中移除。 但是如果你想改变GetX控制类的销毁方式，你可以用<code>SmartManagement</code>类设置不同的行为。</p> 
<h5><a id="_646"></a>如何改变</h5> 
<p>如果你想改变这个配置（你通常不需要），就用这个方法。</p> 
<pre><code class="prism language-dart">void main () {
  runApp(
    GetMaterialApp(
      smartManagement: SmartManagement.onlyBuilders //这里
      home: Home(),
    )
  )
}
</code></pre> 
<h6><a id="SmartManagementfull_661"></a>SmartManagement.full</h6> 
<p>这是默认的。销毁那些没有被使用的、没有被设置为永久的类。在大多数情况下，你会希望保持这个配置不受影响。如果你是第一次使用GetX，那么不要改变这个配置。</p> 
<h6><a id="SmartManagementonlyBuilders_665"></a>SmartManagement.onlyBuilders</h6> 
<p>使用该选项，只有在<code>init:</code>中启动的控制器或用<code>Get.lazyPut()</code>加载到Binding中的控制器才会被销毁。</p> 
<p>如果你使用<code>Get.put()</code>或<code>Get.putAsync()</code>或任何其他方法，SmartManagement将没有权限移除这个依赖。</p> 
<p>在默认行为下，即使是用 "Get.put "实例化的widget也会被移除，这与SmartManagement.onlyBuilders不同。</p> 
<h6><a id="SmartManagementkeepFactory_673"></a>SmartManagement.keepFactory</h6> 
<p>就像SmartManagement.full一样，当它不再被使用时，它将删除它的依赖关系，但它将保留它们的工厂，这意味着如果你再次需要该实例，它将重新创建该依赖关系。</p> 
<h5><a id="Bindings_677"></a>Bindings的工作原理</h5> 
<p>Bindings会创建过渡性工厂，在你点击进入另一个页面的那一刻，这些工厂就会被创建，一旦换屏动画发生，就会被销毁。 这种情况发生得非常快，以至于分析器甚至都来不及注册。 当你再次导航到这个页面时，一个新的临时工厂将被调用，所以这比使用SmartManagement.keepFactory更可取，但如果你不想创建Bindings，或者想让你所有的依赖关系都在同一个Binding上，它肯定会帮助你。 Factories占用的内存很少，它们并不持有实例，而是一个具有你想要的那个类的 "形状 "的函数。 这在内存上的成本很低，但由于这个库的目的是用最少的资源获得最大的性能，所以Get连工厂都默认删除。 请使用对你来说最方便的方法。</p> 
<blockquote> 
 <ul><li>如果你使用多个Bindings，不要使用SmartManagement.keepFactory。它被设计成在没有Bindings的情况下使用，或者在GetMaterialApp的初始Binding中链接一个Binding。</li><li>使用Bindings是完全可选的，你也可以在使用给定控制器的类上使用<code>Get.put()</code>和<code>Get.find()</code>。 然而，如果你使用Services或任何其他抽象，我建议使用Bindings来更好地组织。</li></ul> 
</blockquote> 
<h3><a id="_685"></a>路由</h3> 
<h4><a id="_687"></a>配置路由</h4> 
<pre><code class="prism language-dart">return GetMaterialApp(
                  debugShowCheckedModeBanner: false,
                  title: 'Flutter Demo',
                  theme: ThemeData(
                    primarySwatch: Colors.blue,
                  ),
                  initialRoute: RouterHelper.getSplashPage(),
                  getPages: RouterHelper.routes,
                );

class RouterHelper {
  static const String splashPage = '/splash-page';
  static const String initial = '/';
  static const String cartPage = '/cart-page';

  static String getInitial() =&gt; initial;
  static String getCartPage() =&gt; cartPage;
  static String getSplashPage() =&gt; splashPage;

  static List&lt;GetPage&gt; routes = [
    GetPage(name: splashPage, page: () =&gt; const SplashScreen()),
    GetPage(name: initial, page: () =&gt; const HomePage()).
    GetPage(
        name: cartPage,
        page: () {
          return const CartPage();
        },
        transition: Transition.fadeIn
    ),
  ];
}
</code></pre> 
<blockquote> 
 <p>路由和原生路由同时设置会有问题，配置了<code>pages</code>会和<code>routes</code>，会只生效pages</p> 
</blockquote> 
<h4><a id="_725"></a>路由跳转</h4> 
<p>只要包裹了<code>GetMaterialApp</code>，之后跳转路由可以不用获取context，可以在任何地方直接跳转。</p> 
<p>导航到新屏幕:</p> 
<pre><code class="prism language-dart">Get.to(NextScreen());
</code></pre> 
<p>通过路由导航：</p> 
<pre><code class="prism language-dart">Get.toNamed('/details');
</code></pre> 
<p>关闭snackbars、dialogs、bottomsheets或任何你通常会用Navigator.pop(context)关闭的东西；</p> 
<pre><code class="prism language-dart">Get.back();
</code></pre> 
<p>转到下一个屏幕并且没有返回上一个屏幕的选项（用于 SplashScreens、登录屏幕等）</p> 
<pre><code class="prism language-dart">Get.off(NextScreen());
</code></pre> 
<p>转到下一个屏幕并取消所有先前的路线（在购物车、投票和测试中很有用）</p> 
<pre><code class="prism language-dart">Get.offAll(NextScreen());
</code></pre> 
<h4><a id="_759"></a>路由传参数</h4> 
<p>方式一：</p> 
<pre><code class="prism language-dart"> Get.toNamed('/detail', arguments: {'abc':5});
</code></pre> 
<p>方式二：</p> 
<p>使用**？**拼接后面参数</p> 
<pre><code class="prism language-dart"> Get.toNamed('/detail?abc=5');
</code></pre> 
<p>使用id标识某一个特定的路由，可以做专门跳转</p> 
<pre><code class="prism language-dart"> Get.toNamed('/detail', id: 2);
</code></pre> 
<p>返回指定路由页面</p> 
<pre><code class="prism language-dart">Get.back(id: 2);
</code></pre> 
<p>返回时候传参数</p> 
<pre><code class="prism language-dart">Get.back(result: 'ccccc');
</code></pre> 
<h4><a id="_793"></a>路由获取参数</h4> 
<p>传参数的方式一的获取方式：</p> 
<pre><code class="prism language-dart">// 在build方法内获取
var params = Get.arguments;
</code></pre> 
<p>传参数的方式二的获取方式：</p> 
<pre><code class="prism language-dart">// 在build方法内获取
var params = Get.parameters;
</code></pre> 
<p>返回时候获取参数</p> 
<pre><code class="prism language-dart">var result = await Get.toNamed('/detail');
</code></pre> 
<h4><a id="SnackBars_815"></a>SnackBars</h4> 
<p>以前要使用 Flutter 制作简单的 SnackBar，您必须获取 Scaffold 的上下文，或者您必须使用附加到 Scaffold 的 GlobalKey</p> 
<pre><code class="prism language-dart">final snackBar = SnackBar(
  content: Text('Hi!'),
  action: SnackBarAction(
    label: 'I am a old and ugly snackbar :(',
    onPressed: (){}
  ),
);
// Find the Scaffold in the widget tree and use
// it to show a SnackBar.
Scaffold.of(context).showSnackBar(snackBar);
</code></pre> 
<p>使用GetX</p> 
<pre><code>Get.snackbar('Hi', 'i am a modern snackbar');
</code></pre> 
<p>使用 Get，您所要做的就是从代码中的任何位置调用 Get.snackbar，或者根据需要自定义它！</p> 
<pre><code class="prism language-dart">Get.snackbar(
  "Hey i'm a Get SnackBar!", // title
  "It's unbelievable! I'm using SnackBar without context, without boilerplate, without Scaffold, it is something truly amazing!", // message
  icon: Icon(Icons.alarm),
  shouldIconPulse: true,
  onTap:(){},
  barBlur: 20,
  isDismissible: true,
  duration: Duration(seconds: 3),
);

  // ALL FEATURES //
  //     Color colorText,
  //     Duration duration,
  //     SnackPosition snackPosition,
  //     Widget titleText,
  //     Widget messageText,
  //     bool instantInit,
  //     Widget icon,
  //     bool shouldIconPulse,
  //     double maxWidth,
  //     EdgeInsets margin,
  //     EdgeInsets padding,
  //     double borderRadius,
  //     Color borderColor,
  //     double borderWidth,
  //     Color backgroundColor,
  //     Color leftBarIndicatorColor,
  //     List&lt;BoxShadow&gt; boxShadows,
  //     Gradient backgroundGradient,
  //     TextButton mainButton,
  //     OnTap onTap,
  //     bool isDismissible,
  //     bool showProgressIndicator,
  //     AnimationController progressIndicatorController,
  //     Color progressIndicatorBackgroundColor,
  //     Animation&lt;Color&gt; progressIndicatorValueColor,
  //     SnackStyle snackStyle,
  //     Curve forwardAnimationCurve,
  //     Curve reverseAnimationCurve,
  //     Duration animationDuration,
  //     double barBlur,
  //     double overlayBlur,
  //     Color overlayColor,
  //     Form userInputForm
  ///
</code></pre> 
<p>如果你更喜欢传统的snackbar，或者想从头开始定制它，包括只添加一行（Get.snackbar 使用强制性的标题和消息），你可以使用 <code>Get.rawSnackbar();</code>它提供了构建 Get.snackbar 的 原生 API。</p> 
<h4><a id="Dialogs_891"></a>Dialogs</h4> 
<p>打开对话框：</p> 
<pre><code class="prism language-dart">Get.dialog(YourDialogWidget());
</code></pre> 
<p>打开默认对话框：</p> 
<pre><code class="prism language-dart">Get.defaultDialog(
  onConfirm: () =&gt; print("Ok"),
  middleText: "Dialog made in 3 lines of code"
);
</code></pre> 
<p>您还可以使用 Get.generalDialog 代替 showGeneralDialog。</p> 
<p>对于所有其他 Flutter 对话框小部件，包括 cupertinos，您可以使用 Get.overlayContext 代替 context，并在代码中的任何位置打开它。对于不使用 Overlay 的小部件，您可以使用 Get.context。这两个上下文将在 99% 的情况下用于替换 UI 的上下文，除非在没有导航上下文的情况下使用了 inheritWidget。</p> 
<h4><a id="BottomSheets_912"></a>BottomSheets</h4> 
<p>Get.bottomSheet 类似于 showModalBottomSheet，但不需要上下文。</p> 
<pre><code class="prism language-dart">Get.bottomSheet(
  Container(
    child: Wrap(
      children: &lt;Widget&gt;[
        ListTile(
          leading: Icon(Icons.music_note),
          title: Text('Music'),
          onTap: () {}
        ),
        ListTile(
          leading: Icon(Icons.videocam),
          title: Text('Video'),
          onTap: () {},
        ),
      ],
    ),
  )
);
</code></pre> 
<h4><a id="_937"></a>嵌套导航</h4> 
<p>Get让Flutter的嵌套导航更加简单。 你不需要context，而是通过Id找到你的导航栈。</p> 
<ul><li>注意：创建平行导航堆栈可能是危险的。理想的情况是不要使用NestedNavigators，或者尽量少用。如果你的项目需要它，请继续，但请记住，在内存中保持多个导航堆栈可能不是一个好主意(消耗RAM)。</li></ul> 
<p>看看它有多简单:</p> 
<pre><code class="prism language-dart">Navigator(
  key: Get.nestedKey(1), // create a key by index
  initialRoute: '/',
  onGenerateRoute: (settings) {
    if (settings.name == '/') {
      return GetPageRoute(
        page: () =&gt; Scaffold(
          appBar: AppBar(
            title: Text("Main"),
          ),
          body: Center(
            child: TextButton(
              color: Colors.blue,
              onPressed: () {
                Get.toNamed('/second', id:1); // navigate by your nested route by index
              },
              child: Text("Go to second"),
            ),
          ),
        ),
      );
    } else if (settings.name == '/second') {
      return GetPageRoute(
        page: () =&gt; Center(
          child: Scaffold(
            appBar: AppBar(
              title: Text("Main"),
            ),
            body: Center(
              child:  Text("second")
            ),
          ),
        ),
      );
    }
  }
),
</code></pre> 
<h4><a id="_985"></a>兼容使用</h4> 
<p>如果不使用GetX的语法，只要把 Navigator（大写）改成 navigator（小写），你就可以拥有标准导航的所有功能，而不需要使用context，例如：</p> 
<pre><code class="prism language-dart">// 默认的Flutter导航
Navigator.of(context).push(
  context,
  MaterialPageRoute(
    builder: (BuildContext context) {
      return HomePage();
    },
  ),
);

// 使用Flutter语法获得，而不需要context。
navigator.push(
  MaterialPageRoute(
    builder: (_) {
      return HomePage();
    },
  ),
);

// get语法 (这要好得多)
Get.to(HomePage());
</code></pre> 
<h2><a id="_1013"></a>实用工具</h2> 
<h3><a id="_1015"></a>国际化</h3> 
<h4><a id="_1017"></a>翻译</h4> 
<p>翻译被保存为一个简单的键值字典映射。 要添加自定义翻译，请创建一个类并扩展<code>翻译</code>。</p> 
<pre><code class="prism language-dart">import 'package:get/get.dart';

class Messages extends Translations {
  @override
  Map&lt;String, Map&lt;String, String&gt;&gt; get keys =&gt; {
        'zh_CN': {
          'hello': '你好 世界',
          'logged_in': '用 @name 和 @email登陆',
        },
        'de_DE': {
          'hello': 'Hallo World',
          'logged_in': 'logged in as @name with email @email',
        }
      };
}
</code></pre> 
<h5><a id="_1039"></a>使用翻译</h5> 
<p>只要将<code>.tr</code>追加到指定的键上，就会使用<code>Get.locale</code>和<code>Get.fallbackLocale</code>的当前值进行翻译。</p> 
<pre><code class="prism language-dart">Text('hello'.tr);
// 拼接参数
Text('logged_in'.trParams({
  'name': 'Jhon',
  'email': 'jhon@example.com'
  }));
</code></pre> 
<h4><a id="_1052"></a>语言</h4> 
<p>传递参数给<code>GetMaterialApp</code>来定义语言和翻译。</p> 
<pre><code class="prism language-dart">return GetMaterialApp(
    translations: Messages(), // 你的翻译
    locale: Locale('zh', 'CN'), // 将会按照此处指定的语言翻译
    fallbackLocale: Locale('en', 'US'), // 添加一个回调语言选项，以备上面指定的语言翻译不存在
);
</code></pre> 
<h5><a id="_1064"></a>改变语言</h5> 
<p>调用<code>Get.updateLocale(locale)</code>来更新语言环境。然后翻译会自动使用新的locale。</p> 
<pre><code class="prism language-dart">var locale = Locale('en', 'US');
Get.updateLocale(locale);
</code></pre> 
<h5><a id="_1073"></a>系统语言</h5> 
<p>要读取系统语言，可以使用<code>window.locale</code>。</p> 
<pre><code class="prism language-dart">import 'dart:ui' as ui;

return GetMaterialApp(
    locale: ui.window.locale,
);
</code></pre> 
<h3><a id="_1085"></a>改变主题</h3> 
<p>请不要使用比<code>GetMaterialApp</code>更高级别的widget来更新主题，这可能会造成键重复。很多人习惯于创建一个 "ThemeProvider "的widget来改变应用主题，这在<strong>GetX™</strong>中是绝对没有必要的。</p> 
<p>你可以创建你的自定义主题，并简单地将其添加到<code>Get.changeTheme</code>中，而无需任何模板。</p> 
<pre><code class="prism language-dart">Get.changeTheme(ThemeData.light());
</code></pre> 
<p>如果你想在 "onTap "中创建类似于改变主题的按钮，你可以结合两个<strong>GetX™</strong> API来实现。</p> 
<ul><li>检查是否使用了深色的 "Theme "的API，以及 "Theme "更改API。</li><li>而<code>Theme</code> Change API，你可以把下面的代码放在<code>onPressed</code>里。</li></ul> 
<pre><code class="prism language-dart">Get.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());
</code></pre> 
<p>当<code>.darkmode</code>被激活时，它将切换到light主题，当light主题被激活时，它将切换到dark主题。</p> 
<h3><a id="GetConnect_1106"></a>GetConnect</h3> 
<p>GetConnect可以便捷的通过http或websockets进行前后台通信。</p> 
<h4><a id="_1110"></a>默认配置</h4> 
<p>你能轻松的通过extend GetConnect就能使用GET/POST/PUT/DELETE/SOCKET方法与你的Rest API或websockets通信。</p> 
<pre><code class="prism language-dart">class UserProvider extends GetConnect {
  // Get request
  Future&lt;Response&gt; getUser(int id) =&gt; get('http://youapi/users/$id');
  // Post request
  Future&lt;Response&gt; postUser(Map data) =&gt; post('http://youapi/users', body: data);
  // Post request with File
  Future&lt;Response&lt;CasesModel&gt;&gt; postCases(List&lt;int&gt; image) {
    final form = FormData({
      'file': MultipartFile(image, filename: 'avatar.png'),
      'otherFile': MultipartFile(image, filename: 'cover.png'),
    });
    return post('http://youapi/users/upload', form);
  }

  GetSocket userMessages() {
    return socket('https://yourapi/users/socket');
  }
}
</code></pre> 
<h4><a id="_1135"></a>自定义配置</h4> 
<p>GetConnect具有多种自定义配置。你可以配置base Url，配置响应，配置请求，添加权限验证，甚至是尝试认证的次数，除此之外，还可以定义一个标准的解码器，该解码器将把您的所有请求转换为您的模型，而不需要任何额外的配置。</p> 
<pre><code class="prism language-dart">class HomeProvider extends GetConnect {
  @override
  void onInit() {
    // All request will pass to jsonEncode so CasesModel.fromJson()
    httpClient.defaultDecoder = CasesModel.fromJson;
    httpClient.baseUrl = 'https://api.covid19api.com';
    // baseUrl = 'https://api.covid19api.com'; // It define baseUrl to
    // Http and websockets if used with no [httpClient] instance

    // It's will attach 'apikey' property on header from all requests
    httpClient.addRequestModifier((request) {
      request.headers['apikey'] = '12345678';
      return request;
    });

    // Even if the server sends data from the country "Brazil",
    // it will never be displayed to users, because you remove
    // that data from the response, even before the response is delivered
    httpClient.addResponseModifier&lt;CasesModel&gt;((request, response) {
      CasesModel model = response.body;
      if (model.countries.contains('Brazil')) {
        model.countries.remove('Brazilll');
      }
    });

    httpClient.addAuthenticator((request) async {
      final response = await get("http://yourapi/token");
      final token = response.body['token'];
      // Set the header
      request.headers['Authorization'] = "$token";
      return request;
    });

    //Autenticator will be called 3 times if HttpStatus is
    //HttpStatus.unauthorized
    httpClient.maxAuthRetries = 3;
  }
  }

  @override
  Future&lt;Response&lt;CasesModel&gt;&gt; getCases(String path) =&gt; get(path);
}
</code></pre> 
<h3><a id="GetPage__1184"></a>GetPage 中间件</h3> 
<p>GetPage现在有个新的参数可以把列表中的Get中间件按指定顺序执行。</p> 
<p><strong>注意</strong>: 当GetPage有中间件时，所有的子page会自动有相同的中间件。</p> 
<h4><a id="_1190"></a>优先级</h4> 
<p>设置中间件的优先级定义Get中间件的执行顺序。</p> 
<pre><code class="prism language-dart">final middlewares = [
  GetMiddleware(priority: 2),
  GetMiddleware(priority: 5),
  GetMiddleware(priority: 4),
  GetMiddleware(priority: -8),
];
</code></pre> 
<p>这些中间件会按这个顺序执行 <strong>-8 =&gt; 2 =&gt; 4 =&gt; 5</strong></p> 
<h4><a id="Redirect_1205"></a>Redirect</h4> 
<p>当被调用路由的页面被搜索时，这个函数将被调用。它将RouteSettings作为重定向的结果。或者给它null，就没有重定向了。</p> 
<pre><code class="prism language-dart">RouteSettings redirect(String route) {
  final authService = Get.find&lt;AuthService&gt;();
  return authService.authed.value ? null : RouteSettings(name: '/login')
}
</code></pre> 
<h4><a id="onPageCalled_1216"></a>onPageCalled</h4> 
<p>在调用页面时，创建任何东西之前，这个函数会先被调用。 您可以使用它来更改页面的某些内容或给它一个新页面。</p> 
<pre><code class="prism language-dart">GetPage onPageCalled(GetPage page) {
  final authService = Get.find&lt;AuthService&gt;();
  return page.copyWith(title: 'Welcome ${authService.UserName}');
}
</code></pre> 
<h4><a id="OnBindingsStart_1227"></a>OnBindingsStart</h4> 
<p>这个函数将在绑定初始化之前被调用。 在这里，您可以更改此页面的绑定。</p> 
<pre><code class="prism language-dart">List&lt;Bindings&gt; onBindingsStart(List&lt;Bindings&gt; bindings) {
  final authService = Get.find&lt;AuthService&gt;();
  if (authService.isAdmin) {
    bindings.add(AdminBinding());
  }
  return bindings;
}
</code></pre> 
<h4><a id="OnPageBuildStart_1241"></a>OnPageBuildStart</h4> 
<p>这个函数将在绑定初始化之后被调用。 在这里，您可以在创建绑定之后和创建页面widget之前执行一些操作。</p> 
<pre><code class="prism language-dart">GetPageBuilder onPageBuildStart(GetPageBuilder page) {
  print('bindings are ready');
  return page;
}
</code></pre> 
<h4><a id="OnPageBuilt_1252"></a>OnPageBuilt</h4> 
<p>这个函数将在GetPage.page调用后被调用，并给出函数的结果，并获取将要显示的widget。</p> 
<h4><a id="OnPageDispose_1256"></a>OnPageDispose</h4> 
<p>这个函数将在处理完页面的所有相关对象(Controllers, views, …)之后被调用。</p> 
<h3><a id="API_1260"></a>其他高级API</h3> 
<pre><code class="prism language-dart">// 给出当前页面的args。
Get.arguments

//给出以前的路由名称
Get.previousRoute

// 给出要访问的原始路由，例如，rawRoute.isFirst()
Get.rawRoute

// 允许从GetObserver访问Rounting API。
Get.routing

// 检查 snackbar 是否打开
Get.isSnackbarOpen

// 检查 dialog 是否打开
Get.isDialogOpen

// 检查 bottomsheet 是否打开
Get.isBottomSheetOpen

// 删除一个路由。
Get.removeRoute()

//反复返回，直到表达式返回真。
Get.until()

// 转到下一条路由，并删除所有之前的路由，直到表达式返回true。
Get.offUntil()

// 转到下一个命名的路由，并删除所有之前的路由，直到表达式返回true。
Get.offNamedUntil()

//检查应用程序在哪个平台上运行。
GetPlatform.isAndroid
GetPlatform.isIOS
GetPlatform.isMacOS
GetPlatform.isWindows
GetPlatform.isLinux
GetPlatform.isFuchsia

//检查设备类型
GetPlatform.isMobile
GetPlatform.isDesktop
//所有平台都是独立支持web的!
//你可以知道你是否在浏览器内运行。
//在Windows、iOS、OSX、Android等系统上。
GetPlatform.isWeb


// 相当于.MediaQuery.of(context).size.height,
//但不可改变。
Get.height
Get.width

// 提供当前上下文。
Get.context

// 在你的代码中的任何地方，在前台提供 snackbar/dialog/bottomsheet 的上下文。
Get.contextOverlay

// 注意：以下方法是对上下文的扩展。
// 因为在你的UI的任何地方都可以访问上下文，你可以在UI代码的任何地方使用它。

// 如果你需要一个可改变的高度/宽度（如桌面或浏览器窗口可以缩放），你将需要使用上下文。
context.width
context.height

// 让您可以定义一半的页面、三分之一的页面等。
// 对响应式应用很有用。
// 参数： dividedBy (double) 可选 - 默认值：1
// 参数： reducedBy (double) 可选 - 默认值：0。
context.heightTransformer()
context.widthTransformer()

/// 类似于 MediaQuery.of(context).size。
context.mediaQuerySize()

/// 类似于 MediaQuery.of(context).padding。
context.mediaQueryPadding()

/// 类似于 MediaQuery.of(context).viewPadding。
context.mediaQueryViewPadding()

/// 类似于 MediaQuery.of(context).viewInsets。
context.mediaQueryViewInsets()

/// 类似于 MediaQuery.of(context).orientation;
context.orientation()

///检查设备是否处于横向模式
context.isLandscape()

///检查设备是否处于纵向模式。
context.isPortrait()

///类似于MediaQuery.of(context).devicePixelRatio。
context.devicePixelRatio()

///类似于MediaQuery.of(context).textScaleFactor。
context.textScaleFactor()

///查询设备最短边。
context.mediaQueryShortestSide()

///如果宽度大于800，则为真。
context.showNavbar()

///如果最短边小于600p，则为真。
context.isPhone()

///如果最短边大于600p，则为真。
context.isSmallTablet()

///如果最短边大于720p，则为真。
context.isLargeTablet()

///如果当前设备是平板电脑，则为真
context.isTablet()

///根据页面大小返回一个值&lt;T&gt;。
///可以给值为：
///watch：如果最短边小于300
///mobile：如果最短边小于600
///tablet：如果最短边（shortestSide）小于1200
///desktop：如果宽度大于1200
context.responsiveValue&lt;T&gt;()
</code></pre> 
<h4><a id="ValueBuilder_1392"></a>ValueBuilder</h4> 
<p><code>StatefulWidget</code>的简化，它与<code>.setState</code>回调一起工作，并接受更新的值。</p> 
<pre><code class="prism language-dart">ValueBuilder&lt;bool&gt;(
  initialValue: false,
  builder: (value, updateFn) =&gt; Switch(
    value: value,
    onChanged: updateFn, // 你可以用( newValue )=&gt; updateFn( newValue )。
  ),
  // 如果你需要调用 builder 方法之外的东西。
  onUpdate: (value) =&gt; print("Value updated: $value"),
  onDispose: () =&gt; print("Widget unmounted"),
),
</code></pre> 
<h4><a id="GetView_1409"></a>GetView</h4> 
<p>这是个很实用的Widget。</p> 
<p>它是一个对已注册的<code>Controller</code>有一个名为<code>controller</code>的getter的<code>const Stateless</code>的Widget，仅此而已。</p> 
<pre><code class="prism language-dart"> class AwesomeController extends GetxController {
   final String title = 'My Awesome View';
 }

  // 一定要记住传递你用来注册控制器的`Type`!
 class AwesomeView extends GetView&lt;AwesomeController&gt; {
   @override
   Widget build(BuildContext context) {
     return Container(
       padding: EdgeInsets.all(20),
       child: Text( controller.title ), // 只需调用 "controller.something"。
     );
   }
 }
</code></pre> 
<h4><a id="GetxService_1432"></a>GetxService</h4> 
<p>这个类就像一个 “GetxController”，它共享相同的生命周期（“onInit()”、“onReady()”、“onClose()”）。 但里面没有 “逻辑”。它只是通知<strong>GetX</strong>的依赖注入系统，这个子类<strong>不能</strong>从内存中删除。</p> 
<p>所以这对保持你的 "服务 "总是可以被<code>Get.find()</code>获取到并保持运行是超级有用的。比如 <code>ApiService</code>，<code>StorageService</code>，<code>CacheService</code>。</p> 
<pre><code class="prism language-dart">Future&lt;void&gt; main() async {
  await initServices(); /// 等待服务初始化.
  runApp(SomeApp());
}

/// 在你运行Flutter应用之前，让你的服务初始化是一个明智之举。
因为你可以控制执行流程（也许你需要加载一些主题配置，apiKey，由用户自定义的语言等，所以在运行ApiService之前加载SettingService。
///所以GetMaterialApp()不需要重建，可以直接取值。
void initServices() async {
  print('starting services ...');
  ///这里是你放get_storage、hive、shared_pref初始化的地方。
  ///或者moor连接，或者其他什么异步的东西。
  await Get.putAsync(() =&gt; DbService().init());
  await Get.putAsync(SettingsService()).init();
  print('All services started...');
}

class DbService extends GetxService {
  Future&lt;DbService&gt; init() async {
    print('$runtimeType delays 2 sec');
    await 2.delay();
    print('$runtimeType ready!');
    return this;
  }
}

class SettingsService extends GetxService {
  void init() async {
    print('$runtimeType delays 1 sec');
    await 1.delay();
    print('$runtimeType ready!');
  }
}
</code></pre> 
<p>实际删除一个<code>GetxService</code>的唯一方法是使用<code>Get.reset()</code>，它就像"热重启 "你的应用程序。</p> 
<p>所以如果你需要在你的应用程序的生命周期内对一个类实例进行绝对的持久化，请使用<code>GetxService</code>。</p> 
<p>我们在项目中可以这样使用，封装了网络请求的基类</p> 
<pre><code class="prism language-dart">import 'package:get/get.dart';

class ApiClient extends GetConnect implements GetxService{
  late String token;
  final String appBaseUrl;

  late Map&lt;String, String&gt; _mainHeaders;

  ApiClient({required this.appBaseUrl}){
    baseUrl = appBaseUrl;
    timeout = const Duration(seconds: 30);
    token=AppConstants.TOKEN;
    _mainHeaders={
      'Content-type': 'application/json; charset=UTF-8',
      'Authorization': 'Bearer $token'
    };
  }

  Future&lt;Response&gt; getData(String uri) async {
    try{
      Response response = await get(uri);
      return response;
    }catch(e){
      return Response(statusCode: 1, statusText: e.toString());
    }
  }
	// 还有post、download等等其他操作
  ...
    
}
</code></pre> 
<h4><a id="GetUtils_1513"></a>GetUtils</h4> 
<p><code>GetUtils </code>是<code>getx</code>为咱们提供一些罕用的工具类库，包含<strong>值是否为空</strong>、<strong>是否是数字</strong>、<strong>是否是视频、图片、音频、PPT、Word、APK</strong>、<strong>邮箱、手机号码、日期、MD5、SHA1</strong>等等</p> 
<pre><code class="prism language-dart">// 使用方式
GetUtils.isEmail('');
</code></pre> 
<p><img src="https://images2.imgbox.com/42/78/sezPaqkj_o.png" alt="请添加图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eab371164f4b7b4b519deb43a5ac2eba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SVN图标丢失解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0ea86c184d8dc909bcfd36893d11ebf5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java实现顺序表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>