<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>矩阵按键行列扫描法与反转扫描法：原理、代码实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="矩阵按键行列扫描法与反转扫描法：原理、代码实现" />
<meta property="og:description" content="矩阵按键：行列扫描法与反转扫描法
通常情况下，按键按下时会产生低电平信号，按键一般用低电平表示按下状态。
当按键没有被按下时，通常处于高电平状态，这是因为按键连接到电路时，内部的上拉电阻或外部的上拉电阻会将按键未按下的状态拉高为高电平。当按键被按下时，按键内部会导通，使连接到电路的引脚处于低电平状态，从而表示按键被按下。
这种低电平表示按下的设计方式是常见的，因为在数字电路中，低电平通常被认为是逻辑“0”，而高电平被认为是逻辑“1”。通过使用低电平表示按下，可以更容易地进行逻辑判断和控制。当然，也可以根据特定应用的需求，在设计中采用高电平表示按下，只需根据相应的逻辑处理即可。
1、矩阵按键行列扫描法： 原理： 矩阵按键行列扫描法是一种简单直观的按键扫描方法。在矩阵按键行列扫描法中，键盘的按键是通过行和列的交叉连接来构成一个矩阵。每个按键都位于一个行和一个列的交点上。通过轮询扫描的方式，逐个检测按键的状态。当有按键按下时，通过判断对应的行和列，可以确定按下的是哪一个按键。
一般来说：
行扫描，行线为低电平，列线为高电平。（就STC89C5类型的机子来说，一般都是用列扫描，以为行线端口有可能被其他的引脚占用（复用）（B站江协大的教学视频中的51单片机不建议用行扫描））
列扫描，行线为高电平，列线为低电平。
优点： 矩阵按键行列扫描法简单易懂，实现成本较低，适用于较小规模的键盘矩阵。
缺点： 随着键盘规模的增大，扫描效率会降低，因为需要逐一扫描每个按键。
矩阵按键行列扫描法（假设使用GPIO控制引脚）： #include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
// 定义行列数量
#define NUM_ROWS 4
#define NUM_COLS 4
// 定义行列引脚
int rows[NUM_ROWS] = {R0, R1, R2, R3}; //数组中为具体引脚
int cols[NUM_COLS] = {C0, C1, C2, C3}; //数组中为具体引脚
// 初始化引脚状态
void setup() {
for (int i = 0; i &lt; NUM_ROWS; i&#43;&#43;) {
pinMode(rows[i], OUTPUT); //行配置为输出模式，
digitalWrite(rows[i], LOW); //行初始化电平为低电平
}
for (int i = 0; i &lt; NUM_COLS; i&#43;&#43;) {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d46400cedb8fd91385f2f4c0b9af9e0a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-02T12:56:32+08:00" />
<meta property="article:modified_time" content="2023-08-02T12:56:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">矩阵按键行列扫描法与反转扫描法：原理、代码实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#4da8ee;">矩阵按键：行列扫描法与反转扫描法<br> 通常情况下，按键按下时会产生低电平信号，按键一般用低电平表示按下状态。</span></p> 
<p><span style="color:#4da8ee;">当按键没有被按下时，通常处于高电平状态，这是因为按键连接到电路时，内部的上拉电阻或外部的上拉电阻会将按键未按下的状态拉高为高电平。当按键被按下时，按键内部会导通，使连接到电路的引脚处于低电平状态，从而表示按键被按下。</span></p> 
<p><span style="color:#4da8ee;">这种低电平表示按下的设计方式是常见的，因为在数字电路中，低电平通常被认为是逻辑“0”，而高电平被认为是逻辑“1”。通过使用低电平表示按下，可以更容易地进行逻辑判断和控制。当然，也可以根据特定应用的需求，在设计中采用高电平表示按下，只需根据相应的逻辑处理即可。</span></p> 
<h2><br> 1、矩阵按键行列扫描法：</h2> 
<h3><br> 原理：</h3> 
<p>矩阵按键行列扫描法是一种简单直观的按键扫描方法。在矩阵按键行列扫描法中，键盘的按键是通过行和列的交叉连接来构成一个矩阵。每个按键都位于一个行和一个列的交点上。通过轮询扫描的方式，逐个检测按键的状态。当有按键按下时，通过判断对应的行和列，可以确定按下的是哪一个按键。</p> 
<p><span style="color:#fe2c24;">一般来说：<br> 行扫描，行线为低电平，列线为高电平。（就STC89C5类型的机子来说，一般都是用列扫描，以为行线端口有可能被其他的引脚占用（复用）（B站江协大的教学视频中的51单片机不建议用行扫描））<br> 列扫描，行线为高电平，列线为低电平。</span></p> 
<h3>优点：</h3> 
<p>矩阵按键行列扫描法简单易懂，实现成本较低，适用于较小规模的键盘矩阵。</p> 
<h3><br> 缺点：</h3> 
<p>随着键盘规模的增大，扫描效率会降低，因为需要逐一扫描每个按键。</p> 
<h3>矩阵按键行列扫描法（假设使用GPIO控制引脚）：</h3> 
<blockquote> 
 <p>#include &lt;stdio.h&gt;<br> #include &lt;stdbool.h&gt;</p> 
 <p>// 定义行列数量<br> #define NUM_ROWS 4<br> #define NUM_COLS 4</p> 
 <p>// 定义行列引脚<br> int rows[NUM_ROWS] = {R0, R1, R2, R3};        //数组中为具体引脚<br> int cols[NUM_COLS] = {C0, C1, C2, C3};         //数组中为具体引脚</p> 
 <p>// 初始化引脚状态<br> void setup() {<!-- --><br>     for (int i = 0; i &lt; NUM_ROWS; i++) {<!-- --><br>         pinMode(rows[i], OUTPUT);        //行配置为输出模式，<br>         digitalWrite(rows[i], LOW);        //行初始化电平为低电平<br>     }<br>     for (int i = 0; i &lt; NUM_COLS; i++) {<!-- --><br>         pinMode(cols[i], INPUT_PULLUP);        //列配置为输入模式、上拉<br>     }<br> }</p> 
 <p>// 扫描键盘状态<br> void scanKeypad() {<!-- --><br>     for (int col = 0; col &lt; NUM_COLS; col++) {<!-- --><br>         // 将当前列引脚设置为低电平<br>         digitalWrite(cols[col], LOW);<br>         for (int row = 0; row &lt; NUM_ROWS; row++) {<!-- --><br>             // 检测行引脚状态，如果为低电平，则说明该按键被按下<br>             if (digitalRead(rows[row]) == LOW) {<!-- --><br>                 // 在这里处理按键按下的逻辑<br>                 // ...<br>             }<br>         }<br>         // 将当前列引脚设置为高电平，准备扫描下一列<br>         digitalWrite(cols[col], HIGH);<br>     }<br> }</p> 
 <p>int main() {<!-- --><br>     setup();<br>     while (true) {<!-- --><br>         scanKeypad();<br>     }<br>     return 0;</p> 
</blockquote> 
<h2><br> 2. 反转扫描法</h2> 
<h3><br> 原理：</h3> 
<p>反转扫描法是另一种常见的按键扫描方法。在反转扫描法中，将行和列的引脚分开连接，行引脚设置为输出，列引脚设置为输入。然后，将行引脚逐个设置为高电平，检测列引脚的状态来确定按键的状态。</p> 
<h3>优点：</h3> 
<p>反转扫描法的扫描效率相对较高，适用于大规模的键盘矩阵，因为只需逐一扫描行引脚。</p> 
<h3><br> 缺点：</h3> 
<p>相比矩阵按键行列扫描法，反转扫描法在硬件连接上稍微复杂一些。</p> 
<h3><br> 反转扫描法（假设使用GPIO控制引脚）：</h3> 
<blockquote> 
 <p><br> #include &lt;stdio.h&gt;<br> #include &lt;stdbool.h&gt;</p> 
 <p>// 定义行列数量<br> #define NUM_ROWS 4<br> #define NUM_COLS 4</p> 
 <p>// 定义行列引脚<br> int rows[NUM_ROWS] = {R0, R1, R2, R3};<br> int cols[NUM_COLS] = {C0, C1, C2, C3};</p> 
 <p>// 初始化引脚状态<br> void setup() {<!-- --><br>     for (int i = 0; i &lt; NUM_COLS; i++) {<!-- --><br>         pinMode(cols[i], OUTPUT);<br>         digitalWrite(cols[i], HIGH);<br>     }<br>     for (int i = 0; i &lt; NUM_ROWS; i++) {<!-- --><br>         pinMode(rows[i], INPUT_PULLUP);<br>     }<br> }</p> 
 <p>// 扫描键盘状态<br> void scanKeypad() {<!-- --><br>     for (int row = 0; row &lt; NUM_ROWS; row++) {<!-- --><br>         // 将当前行引脚设置为低电平<br>         digitalWrite(rows[row], LOW);<br>         for (int col = 0; col &lt; NUM_COLS; col++) {<!-- --><br>             // 检测列引脚状态，如果为低电平，则说明该按键被按下<br>             if (digitalRead(cols[col]) == LOW) {<!-- --><br>                 // 在这里处理按键按下的逻辑<br>                 // ...<br>             }<br>         }<br>         // 将当前行引脚设置为高电平，准备扫描下一行<br>         digitalWrite(rows[row], HIGH);<br>     }<br> }</p> 
 <p>int main() {<!-- --><br>     setup();<br>     while (true) {<!-- --><br>         scanKeypad();<br>     }<br>     return 0;<br> }</p> 
</blockquote> 
<h2> 实例：</h2> 
<p>有一51矩阵按键的原理图如下：</p> 
<p><img alt="" height="473" src="https://images2.imgbox.com/e1/79/8rsL2nPG_o.png" width="460"></p> 
<blockquote> 
 <p> #define KEY_MATRIX_PORT P1</p> 
 <h6>//行列选中法：</h6> 
 <p>unsigned char key_matrix_ranks_scan(void)<br> {<!-- --><br>     unsigned char key_value=0;</p> 
 <p>    KEY_MATRIX_PORT=0xf7;//给第一列赋值0<br>     if(KEY_MATRIX_PORT!=0xf7)//判断第一列按键是否按下<br>     {<!-- --><br>         delay_10us(1000);//消抖<br>         switch(KEY_MATRIX_PORT)//保存第一列按键按下后的键值    <br>         {<!-- --><br>             case 0x77: key_value=1;break;<br>             case 0xb7: key_value=5;break;<br>             case 0xd7: key_value=9;break;<br>             case 0xe7: key_value=13;break;<br>         }<br>     }<br>     while(KEY_MATRIX_PORT!=0xf7);//等待按键松开    <br>     <br>     KEY_MATRIX_PORT=0xfb;//给第二列赋值0，其余全为1<br>     if(KEY_MATRIX_PORT!=0xfb)//判断第二列按键是否按下<br>     {<!-- --><br>         delay_10us(1000);//消抖<br>         switch(KEY_MATRIX_PORT)//保存第二列按键按下后的键值    <br>         {<!-- --><br>             case 0x7b: key_value=2;break;<br>             case 0xbb: key_value=6;break;<br>             case 0xdb: key_value=10;break;<br>             case 0xeb: key_value=14;break;<br>         }<br>     }<br>     while(KEY_MATRIX_PORT!=0xfb);//等待按键松开    <br>     <br>     KEY_MATRIX_PORT=0xfd;//给第三列赋值0，其余全为1<br>     if(KEY_MATRIX_PORT!=0xfd)//判断第三列按键是否按下<br>     {<!-- --><br>         delay_10us(1000);//消抖<br>         switch(KEY_MATRIX_PORT)//保存第三列按键按下后的键值    <br>         {<!-- --><br>             case 0x7d: key_value=3;break;<br>             case 0xbd: key_value=7;break;<br>             case 0xdd: key_value=11;break;<br>             case 0xed: key_value=15;break;<br>         }<br>     }<br>     while(KEY_MATRIX_PORT!=0xfd);//等待按键松开    <br>     <br>     KEY_MATRIX_PORT=0xfe;//给第四列赋值0，其余全为1<br>     if(KEY_MATRIX_PORT!=0xfe)//判断第四列按键是否按下<br>     {<!-- --><br>         delay_10us(1000);//消抖<br>         switch(KEY_MATRIX_PORT)//保存第四列按键按下后的键值    <br>         {<!-- --><br>             case 0x7e: key_value=4;break;<br>             case 0xbe: key_value=8;break;<br>             case 0xde: key_value=12;break;<br>             case 0xee: key_value=16;break;<br>         }<br>     }<br>     while(KEY_MATRIX_PORT!=0xfe);//等待按键松开<br>     <br>     return key_value;        <br> }</p> 
 <p></p> 
 <h6>//线反转法：</h6> 
 <p>unsigned char key_matrix_flip_scan(void)<br> {<!-- --><br>     static unsigned char key_value=0;</p> 
 <p>    KEY_MATRIX_PORT=0x0f;//给所有行赋值0，列全为1<br>     if(KEY_MATRIX_PORT!=0x0f)//判断按键是否按下<br>     {<!-- --><br>         delay_10us(1000);//消抖<br>         if(KEY_MATRIX_PORT!=0x0f)<br>         {<!-- --><br>             //测试列<br>             KEY_MATRIX_PORT=0x0f;<br>             switch(KEY_MATRIX_PORT)//保存行为0，按键按下后的列值    <br>             {<!-- --><br>                 case 0x07: key_value=1;break;<br>                 case 0x0b: key_value=2;break;<br>                 case 0x0d: key_value=3;break;<br>                 case 0x0e: key_value=4;break;<br>             }<br>             //测试行<br>             KEY_MATRIX_PORT=0xf0;<br>             switch(KEY_MATRIX_PORT)//保存列为0，按键按下后的键值    <br>             {<!-- --><br>                 case 0x70: key_value=key_value;break;<br>                 case 0xb0: key_value=key_value+4;break;<br>                 case 0xd0: key_value=key_value+8;break;<br>                 case 0xe0: key_value=key_value+12;break;<br>             }<br>             while(KEY_MATRIX_PORT!=0xf0);//等待按键松开    <br>         }<br>     }<br>     else<br>         key_value=0;        <br>     return key_value;        <br> }</p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<p> </p> 
<p><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fb8e5db6a0e7dac146c321b58993941f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VIM 常用命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7ef87d7c8a4c1fd9326efcaabbb4db59/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">修改cuda软链接(实操演示)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>