<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32cubeMx系列小白学习教程（三）——外部中断 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32cubeMx系列小白学习教程（三）——外部中断" />
<meta property="og:description" content="前言 首先了解一下中断是什么。中断是计算机系统中的一种机制，用于处理和响应来自外部设备或内部事件的请求。当一个设备或事件发送一个中断请求时，CPU会暂时停止当前的任务，转而处理中断请求（记住，是暂停，不是同时），一旦中断处理程序执行完毕，CPU会回到原来的任务继续执行。。中断可以是硬件中断，例如设备的输入/输出请求，或者是软件中断，如操作系统的系统调用。
NVIC NVIC (Nested Vectored Interrupt Controller) 中断控制器，NVIC由三个元素组成，中断使能、中断优先级、中断嵌套。
中断使能，相当于就是是否使用中断，
中断优先级，分为抢占优先级和响应优先级，用来管理中断进行顺序的（例如加减乘除，乘除的优先级更高，需要先计算）。可自由分配，如f103，优先级由4位管理，任意分配，数字越小，优先级越高。
中断嵌套，即当一个中断正在处理时，如果有更高优先级的中断请求发生，NVIC 可以暂时挂起当前中断的处理，转而处理更高优先级的中断。
NVIC 还支持中断嵌套，指在处理一个中断的过程中,如果有更高优先级的中断请求发生,系统可以中断当前正在执行的中断处理过程,转而处理更高优先级的中断。一旦更高优先级的中断处理完毕,中断控制器会恢复之前保存的上下文,继续处理原来的中断。
电路 我们继续按这个电路配置：
配置工程 打开之前的工程Test_F103，在这个工程的基础上继续添加外设。
配置GPIO Pinout&amp;Configuration -&gt; System Core -&gt; GPIO -&gt; PA4 -&gt; GPIO_EXTI4；
配置如下：
GPIO mode -&gt; External Interrupt Mode with Falling...
GPIO Pull-up/Pull-down -&gt; Pull-up
User Label -&gt; KEY_2
各模式介绍：
External Interrupt Mode with Rising edge trigger detection：外部中断上升沿触发检测
External Interrupt Mode with Falling edge trigger detection：外部中断下降沿触发检测
External Interrupt Mode with Rising/Falling edge trigger detection：外部中断上升/下降沿触发检测" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ff1f8b19e1e1b0fd47f25fb029f9dfb0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-18T15:28:26+08:00" />
<meta property="article:modified_time" content="2023-10-18T15:28:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32cubeMx系列小白学习教程（三）——外部中断</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>首先了解一下中断是什么。中断是计算机系统中的一种机制，用于处理和响应来自外部设备或内部事件的请求。当一个设备或事件发送一个中断请求时，CPU会暂时停止当前的任务，转而处理中断请求（记住，是暂停，不是同时），一旦中断处理程序执行完毕，CPU会回到原来的任务继续执行。。中断可以是硬件中断，例如设备的输入/输出请求，或者是软件中断，如操作系统的系统调用。</p> 
<h2>NVIC</h2> 
<p>NVIC (Nested Vectored Interrupt Controller) 中断控制器，NVIC由三个元素组成，中断使能、中断优先级、中断嵌套。</p> 
<p>中断使能，相当于就是是否使用中断，</p> 
<p>中断优先级，分为抢占优先级和响应优先级，用来管理中断进行顺序的（例如加减乘除，乘除的优先级更高，需要先计算）。可自由分配，如f103，优先级由4位管理，任意分配，数字越小，优先级越高。</p> 
<p>中断嵌套，即当一个中断正在处理时，如果有更高优先级的中断请求发生，NVIC 可以暂时挂起当前中断的处理，转而处理更高优先级的中断。</p> 
<p>NVIC 还支持中断嵌套，指在处理一个中断的过程中,如果有更高优先级的中断请求发生,系统可以中断当前正在执行的中断处理过程,转而处理更高优先级的中断。一旦更高优先级的中断处理完毕,中断控制器会恢复之前保存的上下文,继续处理原来的中断。</p> 
<h2>电路</h2> 
<p>我们继续按这个电路配置：</p> 
<p><img alt="" height="364" src="https://images2.imgbox.com/d3/56/VlovJyhS_o.png" width="451"></p> 
<h2>配置工程</h2> 
<p>打开之前的工程Test_F103，在这个工程的基础上继续添加外设。</p> 
<h3>配置GPIO</h3> 
<p>Pinout&amp;Configuration -&gt; System Core -&gt; GPIO -&gt; PA4 -&gt; GPIO_EXTI4；</p> 
<p>配置如下：</p> 
<p>GPIO mode -&gt; External Interrupt Mode with Falling...</p> 
<p>GPIO Pull-up/Pull-down -&gt; Pull-up</p> 
<p>User Label -&gt; KEY_2</p> 
<p>各模式介绍：</p> 
<p>External Interrupt Mode with Rising edge trigger detection：外部中断上升沿触发检测</p> 
<p>External Interrupt Mode with Falling edge trigger detection：外部中断下降沿触发检测</p> 
<p>External Interrupt Mode with Rising/Falling edge trigger detection：外部中断上升/下降沿触发检测</p> 
<p>External Event Mode with Rising edge trigger detection：外部事件上升沿触发检测</p> 
<p>External Event Mode with Falling edge trigger detection：外部事件下降沿触发检测</p> 
<p>External Event Mode with Rising/Falling edge trigger detection：外部事件上升/下降沿触发检测</p> 
<p><img alt="" height="752" src="https://images2.imgbox.com/10/a7/swx2lTAp_o.png" width="1200"></p> 
<h3>配置NVIC</h3> 
<p>System Core -&gt; NVIC -&gt; Prioty Group -&gt; 3bit，1bit -&gt; EXTI line4 interrupt -&gt; Enabled -&gt; Preemption Priority (7) -&gt; Sub Priority(1)</p> 
<p>按以上配置，3位抢占优先级，1位响应优先级，使能line4中断，抢占优先级设置为6，响应优先级设置为1</p> 
<p><img alt="" height="711" src="https://images2.imgbox.com/c2/91/MHm3GNMR_o.png" width="1200"></p> 
<p>这时候你会发现，左边状态栏NVIC出现了一个红叉，错误警告，然后找到Time base: System tick timer这里抢占优先级15字体是红色的，配置的抢占优先级是3位，3位最大111，为7。将15改为7，红叉就消失了；</p> 
<p>Time base: System tick timer设置为7，1；系统计时器，这个不需要很高的优先级，设置为最低就行。还有一点就是这个中断优先级如果与外部中断一样或者更低，如果在外部中断中使用延时，延时会被卡死，所以不推荐在中断中使用延时，如果非要用，然后又不想把时基优先级调高怎么办。</p> 
<p>最后会在附录奉上。</p> 
<p>配置好之后，输出程序。</p> 
<h2>程序讲解</h2> 
<p>先打开启动文件，找到线4中断处理函数EXTI4_IRQHandler，右键跟踪过去，Go To Definition...</p> 
<p><img alt="" height="394" src="https://images2.imgbox.com/6b/53/EpKguQ7M_o.png" width="970"></p> 
<p> 在处理函数中，只调用了一个中断服务函数HAL_GPIO_EXTI_IRQHandler()，再次右键跟踪，看看中断服务干了些啥，</p> 
<p><img alt="" height="191" src="https://images2.imgbox.com/32/96/IkA3Ui4u_o.png" width="496"></p> 
<p> 服务函数中，先是判断是否接收到指定的外部中断，如果接收到，则清除中断标志（HAL库的服务函数都会帮忙清除中断标志，所以在使用HAL库的时候，不用管标志位这一点）。并进入中断回调函数HAL_GPIO_EXTI_Callback(GPIO_Pin);再次跟踪回调函数；</p> 
<p><img alt="" height="189" src="https://images2.imgbox.com/86/71/CHuBLQsV_o.png" width="517"></p> 
<p> 回调函数前面有一个__weak，__weak是一个弱化符号，代表这个中断回调函数可以重新定义一个新的函数，并且只执行新定义的函数，不会报错。</p> 
<p><img alt="" height="196" src="https://images2.imgbox.com/1e/98/VmAQ2Apv_o.png" width="654"></p> 
<p>所以说我们在使用HAL库的时候，只需要重写回调函数就行，其他的都可以不用管。在开发时，也不必每次都这么去找回调函数，因为生成程序的时候勾选了这个，为每一对外设生成一组单独的.c和.h文件，</p> 
<p><img alt="" height="194" src="https://images2.imgbox.com/9a/86/DwvZLyRS_o.png" width="589"></p> 
<p>所以只需要打开左边工具栏Functions，外部中断属于GPIO输入，找到....gpio.c，就可以找到对应的回调函数；如果是串口就找到...uart.c，DMA就找到...DMA.c，中断就找到...exti.c，其他的也一样</p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/e9/0d/52j2v1Mp_o.png" width="956"></p> 
<p>现在我们来编写中断服务函数，我们使用按键控制的，找到key.c，编写程序：</p> 
<p><span style="background-color:#cccccc;">这里的上升沿检测是按键触发的，所以需要进行消抖，如果是芯片或者一些外设给的一个脉冲信号，不能消抖，一消就检测不到信号了。</span></p> 
<pre><code class="language-cpp">void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	if(GPIO_Pin == GPIO_PIN_4)
	{
		delay_ms(10);
		if(GPIO_Pin == GPIO_PIN_4)
		{
			HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
		}
	}
}
</code></pre> 
<p>结尾再附上一段延时代码。</p> 
<h2 style="background-color:transparent;">附：</h2> 
<p>如下是内部晶振，主频64Mhz延时1us的程序：</p> 
<pre><code class="language-cpp">void delay_us(uint16_t us) 
{
	for(;us&gt;0;us--)
	    for(int i=0;i&lt;9;i++);
}
</code></pre> 
<p>51单片机的话可以根据时钟周期和频率计算，但是32单片机的话由于程序优化等各种原因，计算不准确，但是可以通过仿真测试出来。</p> 
<p>老版的keil可以在这设置单片机频率，新版的这里变灰了</p> 
<p><img alt="" height="291" src="https://images2.imgbox.com/df/93/f1pt3H9p_o.png" width="582"></p> 
<p>新版的可以在这里修改时钟频率，魔术棒 -&gt; Debug -&gt; Settings -&gt; Trace -&gt; Core Clock -&gt; 64(单片机主频率) -&gt; 确定</p> 
<p><img alt="" height="845" src="https://images2.imgbox.com/98/03/vDvc9oxo_o.png" width="1200"></p> 
<p>然后烧录程序，点击Debug图标进行仿真，打断点检测延时时间，根据具体情况调整。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a498190acfe6468e4775a2b8a490516a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">服务器往浏览器推消息（SSE）应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cd985fd4c959f8473c616ac5ad666666/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">7、Linux驱动开发：设备-自动创建设备节点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>