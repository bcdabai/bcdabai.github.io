<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring中请求如何映射到达controller具体的方法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring中请求如何映射到达controller具体的方法" />
<meta property="og:description" content="上图中DispatcherServlet的位置是：spring-webmvc依赖包（getHandler、doDispatch等方法都在这里）
SpringMVC的执行流程:
- 用户发送请求至前端控制器DispatcherServlet。 - DispatcherServlet收到请求调用HandlerMapping处理器映射器。 - 处理器映射器找到具体的处理器（controller或者handle）(可以根据xml配置、注解进行查找)，生成 - 处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 - DispatcherServlet调用HandlerAdapter处理器适配器。 - HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 - Controller执行完成返回ModelAndView。 - HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 - DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 - ViewReslover解析后返回具体View。 - DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 - DispatcherServlet响应用户。 名词解释：
- 前端控制器（DispatcherServlet）：接收请求，响应结果，相当于电脑的CPU。 - 处理器映射器（HandlerMapping）：根据URL去查找处理器 - 处理器（Handler）：（需要程序员去写代码处理逻辑的），即后端控制器用controller表示。 - 处理器适配器（HandlerAdapter）：会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用） - 视图解析器（ViewResovler）：进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面 Handle是什么？
Handler是一个Controller的对象和请求方式的组合的一个Object对象 HandleExcutionChains是HandleMapping返回的一个处理执行链，它是对Handle的二次封装，将拦截器关联到一起。然后，在DispatcherServlert中完成了拦截器链对handler的过滤。 DispatcherServlet要将一个请求交给哪个特定的Controller，它需要咨询一个Bean——这个Bean的名字为“HandlerMapping”。HandlerMapping是把一个URL指定到一个Controller上，（就像应用系统的web.xml文件使用&lt;servlet-mapping&gt;将URL映射到servlet）。 在SpringBoot项目中，我们通常在相应的controller中定义我们的方法。
@RestController @RequestMapping(&#34;/api/{edition}/page&#34;) public class MyPageHelperController { @Autowired private Environment env; @Autowired private PersonConfig personConfig; @GetMapping(&#34;/myPage&#34;) @ResponseBody public List&lt;String&gt; myPage(Object str) throws IOException { List&lt;String&gt; person= personConfig.getList(str); return person; } } 那么当我们通过postman调用这个方法时，springboot是如何将请求分发到我们相应的方法的呢？下面就来简单的分析下。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/707095496d48254ab031c33c282cbdb1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-15T14:36:35+08:00" />
<meta property="article:modified_time" content="2024-01-15T14:36:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring中请求如何映射到达controller具体的方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/5a/d4/srKxdYjH_o.png" alt="在这里插入图片描述"><br> 上图中DispatcherServlet的位置是：spring-webmvc依赖包（getHandler、doDispatch等方法都在这里）<br> <img src="https://images2.imgbox.com/26/02/GKkdYCxH_o.png" alt="在这里插入图片描述"></p> 
<p>SpringMVC的执行流程:</p> 
<pre><code class="prism language-html"> - 用户发送请求至前端控制器DispatcherServlet。
 - DispatcherServlet收到请求调用HandlerMapping处理器映射器。
 - 处理器映射器找到具体的处理器（controller或者handle）(可以根据xml配置、注解进行查找)，生成   - 处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
 - DispatcherServlet调用HandlerAdapter处理器适配器。
 - HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。
 - Controller执行完成返回ModelAndView。
 - HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。
 - DispatcherServlet将ModelAndView传给ViewReslover视图解析器。
 - ViewReslover解析后返回具体View。
 - DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。
 - DispatcherServlet响应用户。
</code></pre> 
<p>名词解释：</p> 
<pre><code class="prism language-html"> - 前端控制器（DispatcherServlet）：接收请求，响应结果，相当于电脑的CPU。

 - 处理器映射器（HandlerMapping）：根据URL去查找处理器

 - 处理器（Handler）：（需要程序员去写代码处理逻辑的），即后端控制器用controller表示。

 - 处理器适配器（HandlerAdapter）：会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用）

 - 视图解析器（ViewResovler）：进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面
</code></pre> 
<p>Handle是什么？</p> 
<pre><code class="prism language-html">Handler是一个Controller的对象和请求方式的组合的一个Object对象
HandleExcutionChains是HandleMapping返回的一个处理执行链，它是对Handle的二次封装，将拦截器关联到一起。然后，在DispatcherServlert中完成了拦截器链对handler的过滤。
DispatcherServlet要将一个请求交给哪个特定的Controller，它需要咨询一个Bean——这个Bean的名字为“HandlerMapping”。HandlerMapping是把一个URL指定到一个Controller上，（就像应用系统的web.xml文件使用<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>将URL映射到servlet）。
</code></pre> 
<p>在SpringBoot项目中，我们通常在相应的controller中定义我们的方法。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api/{edition}/page"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyPageHelperController</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">Environment</span> env<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">PersonConfig</span> personConfig<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/myPage"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@ResponseBody</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">myPage</span><span class="token punctuation">(</span><span class="token class-name">Object</span> str<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> person<span class="token operator">=</span> personConfig<span class="token punctuation">.</span><span class="token function">getList</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> person<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么当我们通过postman调用这个方法时，springboot是如何将请求分发到我们相应的方法的呢？下面就来简单的分析下。</p> 
<p><strong>DispatcherServlet 类<br> DispatcherServlet 译为分发器，其作用如其名，是 Spring 接收请求的中心调度类，此类就是专门负责将web请求分派给已注册的合适的处理程序处理Web请求<br> DispatcherServlet继承于FrameworkServlet<br> FrameworkServlet继承于HttpServletBean<br> HttpServletBean继承于HttpServlet</strong><br> <img src="https://images2.imgbox.com/32/40/XSD8qJXi_o.png" alt="在这里插入图片描述"><br> 我们由postmsn发送的请求一般包括一下几种：</p> 
<p>GET<br> POST<br> PUT<br> DELETE<br> OPTIONS<br> 每一种请求都会调用一种对应的方法来处理，比如GET请求，就会由doGet()方法进行处理。而doGet方法被定义在了HttpServlet抽象类中<br> <img src="https://images2.imgbox.com/4b/9a/L0wQKGe9_o.png" alt="在这里插入图片描述"><br> 通关对继承树的观察，我们在HttpServlet的子类FrameworkServlet中发现了对doGet()方法的重写</p> 
<pre><code class="prism language-java">
	<span class="token comment">/**
	 * Delegate GET requests to processRequest/doService.
	 * &lt;p&gt;Will also be invoked by HttpServlet's default implementation of {@code doHead},
	 * with a {@code NoBodyResponse} that just captures the content length.
	 * @see #doService
	 * @see #doHead
	 */</span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span>
			<span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>

		<span class="token function">processRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

</code></pre> 
<p>重写后的doGet方法实际上调用了另外一个方法processRequest<br> 进入到这个方法中</p> 
<pre><code class="prism language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">processRequest</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span>
			<span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>

		<span class="token comment">// 省略部分代码</span>

		<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">doService</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ServletException</span> <span class="token operator">|</span> <span class="token class-name">IOException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			failureCause <span class="token operator">=</span> ex<span class="token punctuation">;</span>
			<span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			failureCause <span class="token operator">=</span> ex<span class="token punctuation">;</span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NestedServletException</span><span class="token punctuation">(</span><span class="token string">"Request processing failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">resetContextHolders</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> previousLocaleContext<span class="token punctuation">,</span> previousAttributes<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>requestAttributes <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				requestAttributes<span class="token punctuation">.</span><span class="token function">requestCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token function">logResult</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> failureCause<span class="token punctuation">,</span> asyncManager<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">publishRequestHandledEvent</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> startTime<span class="token punctuation">,</span> failureCause<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

</code></pre> 
<pre><code class="prism language-html">/**
	 * Process this request, publishing an event regardless of the outcome.
	 * <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>The actual event handling is performed by the abstract
	 * {@link #doService} template method.
	 */

</code></pre> 
<p>通过该方法的注释，可以了解到processRequest此方法最终处理请求事件的处理器，是该类的抽象方法doService，其实现方法写在了子类DispatcherServlet中。</p> 
<p>在DispatcherServlet找到对doService的实现方法，观察到其注释告诉我们，他将特定的属性和请求方法发送给doDispatch方法进行实际的调度。</p> 
<pre><code class="prism language-html">	/**
	 * Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch}
	 * for the actual dispatching.
	 */

</code></pre> 
<p>继续找到doDispatch方法，先看其注释</p> 
<pre><code class="prism language-html">   /**
    * Process the actual dispatching to the handler.
    * <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>The handler will be obtained by applying the servlet's HandlerMappings in order.
    * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters
    * to find the first that supports the handler class.
    * <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers
    * themselves to decide which methods are acceptable.
    * @param request current HTTP request
    * @param response current HTTP response
    * @throws Exception in case of any kind of processing failure
    */

</code></pre> 
<p>注释说明，实际上是这个方法对请求做实际的分派，通过按顺序查找注册的HandlerMappings映射，获取查询到的第一个处理器。并且所有的 HTTP 方法都是由此方法做处理的</p> 
<p>通过阅读doDispatch 方法，可以在其方法内找到一行注释以及一个方法：<br> <img src="https://images2.imgbox.com/74/9a/cMDkQsIh_o.png" alt="在这里插入图片描述"><br> 这行注释告诉我们是getHandler这个方法来确定当前请求的处理器</p> 
<p>进入getHandler方法内部</p> 
<pre><code class="prism language-java">
	<span class="token comment">/**
	 * Return the HandlerExecutionChain for this request.
	 * &lt;p&gt;Tries all handler mappings in order.
	 * @param request current HTTP request
	 * @return the HandlerExecutionChain, or {@code null} if no handler could be found
	 */</span>
	<span class="token annotation punctuation">@Nullable</span>
	<span class="token keyword">protected</span> <span class="token class-name">HandlerExecutionChain</span> <span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>handlerMappings <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">HandlerMapping</span> mapping <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handlerMappings<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token class-name">HandlerExecutionChain</span> handler <span class="token operator">=</span> mapping<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>handler <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span> handler<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

</code></pre> 
<p>我们启动项目，请求一个hello测试接口<br> 我们通过计算器查看handlerMapping，如下<br> <img src="https://images2.imgbox.com/70/03/6vGLUWR1_o.png" alt="在这里插入图片描述"><br> 可以看到有很多HandlerMapping，第一个（索引为0）的为RequestMappingHandlerMapping 就是和我们的请求息息相关的handlerMapping.<br> 在进入RequestMappingHandlerMapping内部,如下图<br> <img src="https://images2.imgbox.com/5b/f9/rq6tgaN1_o.png" alt="在这里插入图片描述"><br> 直接找到mappingRegistry查看 如下图<br> <img src="https://images2.imgbox.com/4f/f8/I5q8Cv0b_o.png" alt="在这里插入图片描述"><br> 就可以看到，里面维护了我们定义的所有的RequestMapping方法<br> 而我此时请求的就是下面这个方法</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api/{edition}/page"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyPageHelperController</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">Environment</span> env<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">PersonConfig</span> personConfig<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/myPage"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@ResponseBody</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">myPage</span><span class="token punctuation">(</span><span class="token class-name">Object</span> str<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>env<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"api.url.default.message"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> person<span class="token operator">=</span> personConfig<span class="token punctuation">.</span><span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token keyword">return</span> person<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当我们getHandler并传入当前request对象的时候，就可以看到如下图<br> <img src="https://images2.imgbox.com/1d/85/FpeYGZgN_o.png" alt="在这里插入图片描述"></p> 
<p>此时已经成功找到了处理该请求的方法，然后就是后续调用该方法进行请求的处理。</p> 
<p><strong>注意：mappingRegistry中的数据是如何来的呢？</strong></p> 
<pre><code class="prism language-html">其实Spring Boot在启动后，会将所有扫描到的@RequestMapping注解注册到映射处理器handlerMappings中，其中包含了路径、方法等信息，在接收到请求时，会从注册的映射处理器中查找对应的路径方法，最后分发到方法中进行处理。
</code></pre> 
<p>获取requestMappings示例代码：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMapping</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> requestMappings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">AbstractHandlerMethodMapping</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RequestMappingInfo</span><span class="token punctuation">&gt;</span></span> methodMapping <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">AbstractHandlerMethodMapping</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RequestMappingInfo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"requestMappingHandlerMapping"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RequestMappingInfo</span><span class="token punctuation">,</span> <span class="token class-name">HandlerMethod</span><span class="token punctuation">&gt;</span></span> mapRet <span class="token operator">=</span> methodMapping<span class="token punctuation">.</span><span class="token function">getHandlerMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mapRet<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>requestMappingInfo <span class="token operator">-&gt;</span> requestMappings<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>requestMappingInfo<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bcdd6ef6b624ed4ba95f6c6fa3a866b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">云计算概述（发展过程、定义、发展阶段、云计算榜单）(一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5172e5e0a19a4d7cb5a6e2670749b43b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Github &#43; PicGo搭建个人图床，并使用CDN加速</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>