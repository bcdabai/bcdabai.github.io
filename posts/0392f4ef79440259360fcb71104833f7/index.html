<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Nginx之location详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Nginx之location详解" />
<meta property="og:description" content="root location中root指定的只是相对路径，需要和路径结合起来映射地址，比如
location ^~/static/ {	## 这里的root需要和路径结合使用，即是映射的文件位置为 /usr/alyingboy/static root /usr/alyingboy/; index index.html } 此时我们访问 IP/static/a.css ，那么就会找到 /usr/alyingboy/static/a.css
alias alias指定的是绝对路径，不会和location中的路径结合使用，而是直接使用地址映射到文件，比如
location ^~/static/ {	## 不会路径结合映射地址，那么这里就会直接映射到/usr/alyingboy/文件夹下的文件 alias /usr/alyingboy/; index index.html } 如果定义的路径是文件夹，那么需要使用/结尾 一旦配置请求location映射到了指定的位置，那么下面全部的文件夹和文件都可以映射到，不需要在配置对其的映射，比如 ，但是如果使用其中的文件名重新映射了地址，那么这个路径将不能使用 # /usr/alyingboy/文件夹下的全部文件包括子文件夹和文件都可以使用指定的地址访问到，比如访问地址为 ：# IP/static/a.txt ,那么这个地址访问的是/usr/alyingboy/static/a.txt文件location / { root /usr/alyingboy/; index index.html; } 路径匹配 = 开头表示精确匹配。如 A 中只匹配根目录结尾的请求，后面不能带任何字符串；^~ 开头表示uri以某个常规字符串开头，不是正则匹配；~ 开头表示区分大小写的正则匹配；~* 开头表示不区分大小写的正则匹配；/ 通用匹配, 如果没有其它匹配,任何请求都会匹配到。 一个location定义可以是一个前缀字符串，也可以是一个正则表达式。正则表达式使用的时候要在前面用“*”修饰符（用于不区分大小写匹配），或者“”修饰符（用于区分大小写）。为了找到请求匹配的location，nginx首先检查location定义，用前缀字符串（这些location成为前缀location）。其中，最长匹配前缀的location会被选中并记住。然后，检查正则表达式，按照它们在配置文件中出现的顺序。对正则表达式的搜索在第一次匹配时终止，并使用相应的配置。如果没有找到与正则表达式的匹配，则使用前面记住的前缀位置的配置。 1、用前缀字符串（前缀location）匹配URL，并且选中并记住最长匹配前缀的location（注意：是在匹配的里面记住最长的那个）
2、按照正则表达式在配置文件中出现的顺序依次去匹配，当匹配到第一个以后立即停止，并使用与之相应的那个location。如果没有一个正则表达式匹配，则使用之前记住的那个前缀location。
以上，我们可以得出一个结论：优先使用正则表达式，如果没有匹配的正则表达式发现，则使用匹配的最长前缀字符串location
location = / { # 精确匹配 / ，主机名后面不能带任何字符串 [ configuration A ] }location / { # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求 # 但是正则和最长字符串会优先匹配 [ configuration B ] }location /documents/ { # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration C ] }location ~ /documents/Abc { # 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration CC ] }location ^~ /images/ { # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。 [ configuration D ] }location ~* \." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0392f4ef79440259360fcb71104833f7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-17T17:53:56+08:00" />
<meta property="article:modified_time" content="2020-06-17T17:53:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Nginx之location详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="root_0"></a>root</h2> 
<p>location中root指定的只是相对路径，需要和路径结合起来映射地址，比如</p> 
<pre><code class="prism language-c">location <span class="token operator">^</span><span class="token operator">~</span><span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>	## 这里的root需要和路径结合使用，即是映射的文件位置为 <span class="token operator">/</span>usr<span class="token operator">/</span>alyingboy<span class="token operator">/</span><span class="token keyword">static</span>
    root <span class="token operator">/</span>usr<span class="token operator">/</span>alyingboy<span class="token operator">/</span><span class="token punctuation">;</span> 
    index index<span class="token punctuation">.</span>html
<span class="token punctuation">}</span>
</code></pre> 
<p>此时我们访问 IP/static/a.css ，那么就会找到 /usr/alyingboy/static/a.css</p> 
<h2><a id="alias_9"></a>alias</h2> 
<p>alias指定的是绝对路径，不会和location中的路径结合使用，而是直接使用地址映射到文件，比如</p> 
<pre><code class="prism language-c">location <span class="token operator">^</span><span class="token operator">~</span><span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>	## 不会路径结合映射地址，那么这里就会直接映射到<span class="token operator">/</span>usr<span class="token operator">/</span>alyingboy<span class="token operator">/</span>文件夹下的文件
    alias <span class="token operator">/</span>usr<span class="token operator">/</span>alyingboy<span class="token operator">/</span><span class="token punctuation">;</span> 
    index index<span class="token punctuation">.</span>html
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_17"></a>如果定义的路径是文件夹，那么需要使用/结尾</h2> 
<h2><a id="location__18"></a>一旦配置请求location映射到了指定的位置，那么下面全部的文件夹和文件都可以映射到，不需要在配置对其的映射，比如 ，但是如果使用其中的文件名重新映射了地址，那么这个路径将不能使用</h2> 
<pre><code class="prism language-c"># <span class="token operator">/</span>usr<span class="token operator">/</span>alyingboy<span class="token operator">/</span>文件夹下的全部文件包括子文件夹和文件都可以使用指定的地址访问到，比如访问地址为 ：# IP<span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">/</span>a<span class="token punctuation">.</span>txt  <span class="token punctuation">,</span>那么这个地址访问的是<span class="token operator">/</span>usr<span class="token operator">/</span>alyingboy<span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">/</span>a<span class="token punctuation">.</span>txt文件location <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
    root <span class="token operator">/</span>usr<span class="token operator">/</span>alyingboy<span class="token operator">/</span><span class="token punctuation">;</span>
    index index<span class="token punctuation">.</span>html<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_25"></a>路径匹配</h2> 
<ul><li>= 开头表示精确匹配。如 A 中只匹配根目录结尾的请求，后面不能带任何字符串；</li><li>^~ 开头表示uri以某个常规字符串开头，不是正则匹配；</li><li>~ 开头表示区分大小写的正则匹配；</li><li>~* 开头表示不区分大小写的正则匹配；</li><li>/ 通用匹配, 如果没有其它匹配,任何请求都会匹配到。</li></ul> 
<h2><a id="locationlocationnginxlocationlocationlocationlocation_31"></a>一个location定义可以是一个前缀字符串，也可以是一个正则表达式。正则表达式使用的时候要在前面用“*”修饰符（用于不区分大小写匹配），或者“”修饰符（用于区分大小写）。为了找到请求匹配的location，nginx首先检查location定义，用前缀字符串（这些location成为前缀location）。其中，最长匹配前缀的location会被选中并记住。然后，检查正则表达式，按照它们在配置文件中出现的顺序。对正则表达式的搜索在第一次匹配时终止，并使用相应的配置。如果没有找到与正则表达式的匹配，则使用前面记住的前缀位置的配置。</h2> 
<p>1、用前缀字符串（前缀location）匹配URL，并且选中并记住最长匹配前缀的location（注意：是在匹配的里面记住最长的那个）</p> 
<p>2、按照正则表达式在配置文件中出现的顺序依次去匹配，当匹配到第一个以后立即停止，并使用与之相应的那个location。如果没有一个正则表达式匹配，则使用之前记住的那个前缀location。</p> 
<p>以上，我们可以得出一个结论：优先使用正则表达式，如果没有匹配的正则表达式发现，则使用匹配的最长前缀字符串location</p> 
<pre><code class="prism language-c">location  <span class="token operator">=</span> <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
  # 精确匹配 <span class="token operator">/</span> ，主机名后面不能带任何字符串
  <span class="token punctuation">[</span> configuration A <span class="token punctuation">]</span>
<span class="token punctuation">}</span>location  <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
  # 因为所有的地址都以 <span class="token operator">/</span> 开头，所以这条规则将匹配到所有请求
  # 但是正则和最长字符串会优先匹配
  <span class="token punctuation">[</span> configuration B <span class="token punctuation">]</span>
<span class="token punctuation">}</span>location <span class="token operator">/</span>documents<span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>  # 匹配任何以 <span class="token operator">/</span>documents<span class="token operator">/</span> 开头的地址，匹配符合以后，还要继续往下搜索
  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条
  <span class="token punctuation">[</span> configuration C <span class="token punctuation">]</span>
<span class="token punctuation">}</span>location <span class="token operator">~</span> <span class="token operator">/</span>documents<span class="token operator">/</span>Abc <span class="token punctuation">{<!-- --></span>  # 匹配任何以 <span class="token operator">/</span>documents<span class="token operator">/</span>Abc 开头的地址，匹配符合以后，还要继续往下搜索
  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条
  <span class="token punctuation">[</span> configuration CC <span class="token punctuation">]</span>
<span class="token punctuation">}</span>location <span class="token operator">^</span><span class="token operator">~</span> <span class="token operator">/</span>images<span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>  # 匹配任何以 <span class="token operator">/</span>images<span class="token operator">/</span> 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。
  <span class="token punctuation">[</span> configuration D <span class="token punctuation">]</span>
<span class="token punctuation">}</span>location <span class="token operator">~</span><span class="token operator">*</span> \<span class="token punctuation">.</span><span class="token punctuation">(</span>gif<span class="token operator">|</span>jpg<span class="token operator">|</span>jpeg<span class="token punctuation">)</span>$ <span class="token punctuation">{<!-- --></span>  # 匹配所有以 gif<span class="token punctuation">,</span>jpg或jpeg 结尾的请求
  # 然而，所有请求 <span class="token operator">/</span>images<span class="token operator">/</span> 下的图片会被 config D 处理，因为 <span class="token operator">^</span><span class="token operator">~</span> 到达不了这一条正则
  <span class="token punctuation">[</span> configuration E <span class="token punctuation">]</span>
<span class="token punctuation">}</span>location <span class="token operator">/</span>images<span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>  # 字符匹配到 <span class="token operator">/</span>images<span class="token operator">/</span>，继续往下，会发现 <span class="token operator">^</span><span class="token operator">~</span> 存在
  <span class="token punctuation">[</span> configuration F <span class="token punctuation">]</span>
<span class="token punctuation">}</span>location <span class="token operator">/</span>images<span class="token operator">/</span>abc <span class="token punctuation">{<!-- --></span>  # 最长字符匹配到 <span class="token operator">/</span>images<span class="token operator">/</span>abc，继续往下，会发现 <span class="token operator">^</span><span class="token operator">~</span> 存在
  <span class="token macro property"># F与G的放置顺序是没有关系的</span>
  <span class="token punctuation">[</span> configuration G <span class="token punctuation">]</span>
<span class="token punctuation">}</span>location <span class="token operator">~</span> <span class="token operator">/</span>images<span class="token operator">/</span>abc<span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>  # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用
  # 因为都是正则匹配，优先级一样，选择最上面的
    <span class="token punctuation">[</span> configuration H <span class="token punctuation">]</span>
<span class="token punctuation">}</span>location <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">/</span>js<span class="token operator">/</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token operator">/</span>\<span class="token punctuation">.</span>js
</code></pre> 
<h2><a id="_67"></a>优先级</h2> 
<h2><a id="_location_____location_____location______location______location_______68"></a>( location = ) &gt; ( location 完整路径 ) &gt; ( location ^~ 路径 ) &gt; ( location ,* 正则顺序 ) &gt; ( location 部分起始路径 ) &gt; ( / )</h2> 
<h2><a id="_69"></a>推荐使用</h2> 
<pre><code class="prism language-c">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。#这里是直接转发给后端应用服务器了，也可以是一个静态首页# 第一个必选规则location <span class="token operator">=</span> <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
    proxy_pass http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>tomcat<span class="token punctuation">:</span><span class="token number">8080</span><span class="token operator">/</span>index
<span class="token punctuation">}</span># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项# 有两种配置模式，目录匹配或后缀匹配<span class="token punctuation">,</span>任选其一或搭配使用location <span class="token operator">^</span><span class="token operator">~</span> <span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
    root <span class="token operator">/</span>webroot<span class="token operator">/</span><span class="token keyword">static</span><span class="token operator">/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>location <span class="token operator">~</span><span class="token operator">*</span> \<span class="token punctuation">.</span><span class="token punctuation">(</span>gif<span class="token operator">|</span>jpg<span class="token operator">|</span>jpeg<span class="token operator">|</span>png<span class="token operator">|</span>css<span class="token operator">|</span>js<span class="token operator">|</span>ico<span class="token punctuation">)</span>$ <span class="token punctuation">{<!-- --></span>
    root <span class="token operator">/</span>webroot<span class="token operator">/</span>res<span class="token operator">/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>#第三个规则就是通用规则，用来转发动态请求到后端应用服务器#非静态文件请求就默认是动态请求，自己根据实际把握#毕竟目前的一些框架的流行，带<span class="token punctuation">.</span>php<span class="token punctuation">,</span><span class="token punctuation">.</span>jsp后缀的情况很少了location <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
    proxy_pass http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>tomcat<span class="token punctuation">:</span><span class="token number">8080</span><span class="token operator">/</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="proxy_pass_81"></a>proxy_pass</h2> 
<p>在nginx中配置proxy_pass代理转发时，如果在proxy_pass后面的url加/，表示绝对根路径；如果没有/，表示相对路径，把匹配的路径部分也给代理走。</p> 
<p>假设下面四种情况分别用 http://192.168.1.1/proxy/test.html 进行访问。</p> 
<pre><code class="prism language-c">第一种：location <span class="token operator">/</span>proxy<span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
    proxy_pass http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
代理到URL：http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">/</span>test<span class="token punctuation">.</span>html

第二种（相对于第一种，最后少一个 <span class="token operator">/</span> ）
location <span class="token operator">/</span>proxy<span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
    proxy_pass http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
代理到URL：http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">/</span>proxy<span class="token operator">/</span>test<span class="token punctuation">.</span>html

第三种：location <span class="token operator">/</span>proxy<span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
    proxy_pass http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">/</span>aaa<span class="token operator">/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
代理到URL：http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">/</span>aaa<span class="token operator">/</span>test<span class="token punctuation">.</span>html

第四种（相对于第三种，最后少一个 <span class="token operator">/</span> ）
location <span class="token operator">/</span>proxy<span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
    proxy_pass http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">/</span>aaa<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
代理到URL：http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">/</span>aaatest<span class="token punctuation">.</span>html
</code></pre> 
<p>参考链接：</p> 
<p>Nginx之location详解 ：https://mp.weixin.qq.com/s/d9Kh-7CQhMIhEpcaZ3Em_A</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b9d8da71dd1b6a3447e638d5463144e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IE浏览器POI导出Excel文件名乱码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c1ae3b1fbe647ace04e9c255f16be35/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">modelsim : module is not defined</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>