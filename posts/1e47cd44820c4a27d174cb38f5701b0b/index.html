<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>初学Springboot(四) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="初学Springboot(四)" />
<meta property="og:description" content="文章目录 前言一、Springboot整合MyBatis1.数据准备：2.创建项目，引入相应的启动器：3.编写配置文件：方式1：用注解方式整合①创建接口Mapper②创建测试类 方式2:使用配置文件的方式整合MyBatis1.创建Mapper接口文件：ArticleMapper2.创建XML映射文件：编写对应的SQL语句3.在全局文件中配置XML映射文件路径以及实体类别名映射路径4.编写测试方法进行接口方法测试及整合测试 二.Spring Boot 整合JPA1.在pom中添加Jpa依赖启动器步骤一:建立一个实体类，表示与表的映射关系步骤二：编写接口类接口类DiscussRepository 步骤三：测试类 三.Spring Boot 整合RedisRedis优点1.在pom文件中添加Spring Data Redis依赖启动器2.编写ORM实体类3.编写Repository接口4.在全局配置文件application.properties中添加Redis数据库连接配置5.编写单元测试进行接口方法测试及整合测试 总结 前言 本次来讲一讲Springboot的数据访问问题，分别整合了访问MyBatis与JPA跟Redis
提示：以下是本篇文章正文内容，下面案例可供参考
项目目录
首先要知道对应的依赖启动器有哪些
名称对应数据库spring-boot-starter-data-jpa•Spring Data JPA •Hibernatespring-boot-starter-data-mongodb•MongoDB •Spring Data MongoDBspring-boot-starter-data-neo4j•Neo4j图数据库 •Spring Data Neo4jspring-boot-starter-data-redis•Redis 一、Springboot整合MyBatis 1.数据准备： 创建数据库、数据表并插入一定的数据
这里我们引用了
先开启数据库，这里我用的是MySQL
①首先创建一张springboot的库
CREATE DATABASE springbootdata; ②创建t_article的表并插入数据
CREATE TABLE `t_article` ( `id` int(20) NOT NULL AUTO_INCREMENT COMMENT &#39;文章id&#39;, `title` varchar(200) DEFAULT NULL COMMENT &#39;文章标题&#39;, `content` longtext COMMENT &#39;文章内容&#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO `t_article` VALUES (&#39;1&#39;, &#39;Spring Boot基础入门&#39;, &#39;从入门到退出." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1e47cd44820c4a27d174cb38f5701b0b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-15T22:56:28+08:00" />
<meta property="article:modified_time" content="2021-03-15T22:56:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">初学Springboot(四)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_9" rel="nofollow">前言</a></li><li><a href="#SpringbootMyBatis_27" rel="nofollow">一、Springboot整合MyBatis</a></li><li><ul><li><ul><li><a href="#1_28" rel="nofollow">1.数据准备：</a></li><li><a href="#2_80" rel="nofollow">2.创建项目，引入相应的启动器：</a></li><li><a href="#3_211" rel="nofollow">3.编写配置文件：</a></li><li><ul><li><a href="#1_232" rel="nofollow">方式1：用注解方式整合</a></li><li><ul><li><a href="#Mapper_235" rel="nofollow">①创建接口Mapper</a></li><li><a href="#_262" rel="nofollow">②创建测试类</a></li></ul> 
     </li><li><a href="#2MyBatis_273" rel="nofollow">方式2:使用配置文件的方式整合MyBatis</a></li><li><ul><li><a href="#1MapperArticleMapper_279" rel="nofollow">1.创建Mapper接口文件：ArticleMapper</a></li><li><a href="#2XMLSQL_292" rel="nofollow">2.创建XML映射文件：编写对应的SQL语句</a></li><li><a href="#3XML_340" rel="nofollow">3.在全局文件中配置XML映射文件路径以及实体类别名映射路径</a></li><li><a href="#4_351" rel="nofollow">4.编写测试方法进行接口方法测试及整合测试</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#Spring_Boot_JPA_362" rel="nofollow">二.Spring Boot 整合JPA</a></li><li><ul><li><ul><li><a href="#1pomJpa_366" rel="nofollow">1.在pom中添加Jpa依赖启动器</a></li><li><ul><li><a href="#_374" rel="nofollow">步骤一:建立一个实体类，表示与表的映射关系</a></li><li><a href="#_445" rel="nofollow">步骤二：编写接口类</a></li><li><ul><li><ul><li><a href="#DiscussRepository_475" rel="nofollow">接口类DiscussRepository</a></li></ul> 
     </li></ul> 
     </li><li><a href="#_508" rel="nofollow">步骤三：测试类</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#Spring_Boot_Redis_535" rel="nofollow">三.Spring Boot 整合Redis</a></li><li><ul><li><a href="#Redis_538" rel="nofollow">Redis优点</a></li><li><ul><li><a href="#1pomSpring_Data_Redis_547" rel="nofollow">1.在pom文件中添加Spring Data Redis依赖启动器</a></li><li><a href="#2ORM_557" rel="nofollow">2.编写ORM实体类</a></li><li><a href="#3Repository_597" rel="nofollow">3.编写Repository接口</a></li><li><a href="#4applicationpropertiesRedis_615" rel="nofollow">4.在全局配置文件application.properties中添加Redis数据库连接配置</a></li><li><a href="#5_627" rel="nofollow">5.编写单元测试进行接口方法测试及整合测试</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_663" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr color="#000000" size='1"'> 
<h2><a id="_9"></a>前言</h2> 
<p><font color="#999AAA">本次来讲一讲Springboot的数据访问问题，分别整合了访问MyBatis与JPA跟Redis</font></p> 
<hr color="#000000" size='1"'> 
<p><font color="#999AAA">提示：以下是本篇文章正文内容，下面案例可供参考</font></p> 
<p>项目目录<br> <img src="https://images2.imgbox.com/58/18/j08afhp0_o.png" alt="在这里插入图片描述"></p> 
<p>首先要知道对应的依赖启动器有哪些</p> 
<table><thead><tr><th><strong>名称</strong></th><th><strong>对应数据库</strong></th></tr></thead><tbody><tr><td>spring-boot-starter-data-jpa</td><td>•Spring Data JPA •Hibernate</td></tr><tr><td>spring-boot-starter-data-mongodb</td><td>•MongoDB •Spring Data MongoDB</td></tr><tr><td>spring-boot-starter-data-neo4j</td><td>•Neo4j图数据库 •Spring Data Neo4j</td></tr><tr><td>spring-boot-starter-data-redis</td><td>•Redis</td></tr></tbody></table> 
<h2><a id="SpringbootMyBatis_27"></a>一、Springboot整合MyBatis</h2> 
<h4><a id="1_28"></a>1.数据准备：</h4> 
<p><strong>创建数据库、数据表并插入一定的数据</strong><br> 这里我们引用了</p> 
<p>先开启数据库，这里我用的是MySQL<br> ①首先创建一张springboot的库<br> <img src="https://images2.imgbox.com/49/13/qFjJCKWU_o.png" alt="在这里插入图片描述"></p> 
<pre><code>CREATE DATABASE springbootdata;
</code></pre> 
<p>②创建t_article的表并插入数据<br> <img src="https://images2.imgbox.com/dc/17/kXDM1v0P_o.png" alt="在这里插入图片描述"></p> 
<pre><code>CREATE TABLE `t_article` (
  `id` int(20) NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `title` varchar(200) DEFAULT NULL COMMENT '文章标题',
  `content` longtext COMMENT '文章内容',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
</code></pre> 
<pre><code>INSERT INTO `t_article` VALUES ('1', 'Spring Boot基础入门', '从入门到退出...');
INSERT INTO `t_article` VALUES ('2', 'Spring Cloud基础入门', '从入门到退出...');
</code></pre> 
<p>③创建t_comment表，插入数据</p> 
<p><img src="https://images2.imgbox.com/1f/a6/1vna6dQA_o.png" alt="在这里插入图片描述"></p> 
<pre><code>CREATE TABLE `t_comment` (
  `id` int(20) NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `content` longtext COMMENT '评论内容',
  `author` varchar(200) DEFAULT NULL COMMENT '评论作者',
  `a_id` int(20) DEFAULT NULL COMMENT '关联的文章id',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
</code></pre> 
<pre><code>INSERT INTO `t_comment` VALUES ('1', '真好', '李大', '1');
INSERT INTO `t_comment` VALUES ('2', '真不错，赞一个', 'tom', '1');
INSERT INTO `t_comment` VALUES ('3', '很详细', 'pity', '1');
INSERT INTO `t_comment` VALUES ('4', '年轻人真厉害', '李四', '1');
INSERT INTO `t_comment` VALUES ('5', '很不错', '王五', '2');
</code></pre> 
<hr> 
<h4><a id="2_80"></a>2.创建项目，引入相应的启动器：</h4> 
<p>使用Spring Initializr的方式构建项目，选择MySQL和MyBatis依赖,编写实体类。</p> 
<p><img src="https://images2.imgbox.com/e5/7d/8Q6UuNC2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d0/97/phVZSZr4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5c/fb/TqXpoe2X_o.png" alt="在这里插入图片描述"><br> <strong>编写两张表的实体类</strong></p> 
<pre><code>public class Comment {
    private Integer id;
    private String content;
    private String author;
    private Integer aId;

    @Override
    public String toString() {
        return "Comment{" +
                "id=" + id +
                ", content='" + content + '\'' +
                ", author='" + author + '\'' +
                ", aId=" + aId +
                '}';
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public Integer getaId() {
        return aId;
    }

    public void setaId(Integer aId) {
        this.aId = aId;
    }
}

</code></pre> 
<pre><code>public class Article {
    private Integer id;
    private String title;
    private String content;
    private List&lt;Comment&gt; commentList;

    @Override
    public String toString() {
        return "Article{" +
                "id=" + id +
                ", title='" + title + '\'' +
                ", content='" + content + '\'' +
                ", commentList=" + commentList +
                '}';
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public List&lt;Comment&gt; getCommentList() {
        return commentList;
    }

    public void setCommentList(List&lt;Comment&gt; commentList) {
        this.commentList = commentList;
    }
}

</code></pre> 
<p><strong>引入Mybatis依赖启动器</strong></p> 
<pre><code>&lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.4&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre> 
<p><strong>增加依赖，以阿里巴巴的Druid数据源为案例</strong></p> 
<pre><code>&lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.10&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre> 
<h4><a id="3_211"></a>3.编写配置文件：</h4> 
<p>在配置文件中进行数据库连接配置以及进行第三方数据源的默认参数覆盖。</p> 
<pre><code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/springboottest1?serverTimezone=UTC
spring.datasource.username=你数据库的帐号
spring.datasource.password=你数据库的密码
#对数据源默认值进行修改
#数据源类型
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
#初始化连接数
spring.datasource.initialSize=20
#最小空闲数
spring.datasource.minIdle=10
#最大连接数
spring.datasource.maxActive=100
#开启驼峰命名匹配映射
mybatis.configuration.map-underscore-to-camel-case=true
</code></pre> 
<h5><a id="1_232"></a>方式1：用注解方式整合</h5> 
<p><strong>优点：相对简洁，但是多表操作的话不方便</strong><br> <strong>这里可以发现，接口只需要添加注解，不用去再创建一个实现类</strong></p> 
<h6><a id="Mapper_235"></a>①创建接口Mapper</h6> 
<pre><code>package com.itheima.mapper;

import com.demo03.domain.Comment;
import org.apache.ibatis.annotations.*;

@Mapper//表示该类是一个mybatis接口文件，是需要被springboot扫描的
public interface CommentMapper {
    //查询方法
    @Select("select * from t_comment where id =#{id}")
    public Comment findById(Integer id);
    //添加方法
    @Insert("insert into t_comment values(#{id},#{content},#{author},#{aId})")
    public void insertComment(Comment comment);
    //修改
    @Update("update t_comment set content=#{content} where id=#{id}")
    public void updateComment(Comment comment);
    //删除
    @Delete("delete from t_comment where id=#{id}")
    public void deleteComment(Insert id);

}
</code></pre> 
<h6><a id="_262"></a>②创建测试类</h6> 
<pre><code> @Autowired
    private CommentMapper commentMapper;
    @Test
    void contextLoads() {
        Comment comment=commentMapper.findById(1);
    System.out.println(comment);
    }
</code></pre> 
<h5><a id="2MyBatis_273"></a>方式2:使用配置文件的方式整合MyBatis</h5> 
<p><strong>优点：文件复杂比较适用（多表查询）</strong></p> 
<p><strong>整合步骤：</strong></p> 
<h6><a id="1MapperArticleMapper_279"></a>1.创建Mapper接口文件：ArticleMapper</h6> 
<p><strong>@Mapper</strong>注解</p> 
<pre><code>@Mapper
public interface ArticleMapper {
    //根据id查询文章（包含对应的评论）
    public Article selectArticle(Integer id);
    //根据id更新
    public Article updateArticle(Article id);
}
</code></pre> 
<h6><a id="2XMLSQL_292"></a>2.创建XML映射文件：编写对应的SQL语句</h6> 
<p><img src="https://images2.imgbox.com/80/bd/XjQH5yfZ_o.png" alt="在这里插入图片描述"></p> 
<pre><code>&lt;!--约束头--&gt;
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;!--  namepace对应接口的程序--&gt;
&lt;mapper namespace="com.demo03.mapper.ArticleMapper"&gt;
&lt;!--自定义映射--&gt;
    &lt;resultMap id="ac" type="Article"&gt;
&lt;!--        property属性名 column字段名--&gt;
&lt;!--        先id然后result--&gt;
        &lt;id property="id" column="id"&gt;&lt;/id&gt;
        &lt;result property="title" column="title"&gt;&lt;/result&gt;
        &lt;result property="content" column="content"&gt;&lt;/result&gt;
&lt;!--        如果属性里面是另一个实体类用collection ofType泛型对应实体类路径--&gt;
        &lt;collection property="commentList" ofType="com.demo03.domain.Comment"&gt;
            &lt;id property="id" column="c_id"&gt;&lt;/id&gt;
            &lt;result property="content" column="content"&gt;&lt;/result&gt;
            &lt;result property="author" column="author"&gt;&lt;/result&gt;
            &lt;result property="aId" column="aId"&gt;&lt;/result&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
&lt;!--    id=接口方法名 parameterType对应方法获取的值类型--&gt;
    &lt;select id="selectArticle" resultMap="ac" parameterType="int"&gt;
    SELECT a.*,c.id c_id,c.content c_content,c.author,c.a_Id aId
       FROM t_article a,t_comment c
       WHERE a.id=c.a_id AND a.id = #{id}
&lt;/select&gt;
    &lt;update id="updateArticle" parameterType="Article" &gt;
        UPDATE t_article
        &lt;set&gt;
            &lt;if test="title !=null and title !=''"&gt;
                title=#{title},
            &lt;/if&gt;
            &lt;if test="content !=null and content !=''"&gt;
                content=#{content}
            &lt;/if&gt;
        &lt;/set&gt;
        WHERE id=#{id}
    &lt;/update&gt;

&lt;/mapper&gt;
</code></pre> 
<h6><a id="3XML_340"></a>3.在全局文件中配置XML映射文件路径以及实体类别名映射路径</h6> 
<pre><code>#开启驼峰命名匹配映射
mybatis.configuration.map-underscore-to-camel-case=true
#配置mybatis的xml配置文件路径(如果有多个配置文件可以把Att.xml改为*.xml)
mybatis.mapper-locations=classpath:mapper/*.xml
#配置xml映射文件中指定的实体类别名路径
mybatis.type-aliases-package=com.demo03.domain
</code></pre> 
<h6><a id="4_351"></a>4.编写测试方法进行接口方法测试及整合测试</h6> 
<pre><code>private ArticleMapper articleMapper;
    @Test
    void contextLoads2() {
    根据id查询文章（包含对应的评论）
        Article article=articleMapper.selectArticle(2);
        System.out.println(article);
    }
</code></pre> 
<h2><a id="Spring_Boot_JPA_362"></a>二.Spring Boot 整合JPA</h2> 
<p><strong>Spring Data JPA是Spring基于ORM框架、JPA规范的基础上封装的一套JPA应用框架，它提供了增删改查等常用功能，使开发者可以用较少的代码实现数据操作，同时还易于扩展。</strong><br> <strong>总结：创建一个实体类与表进行关联映射，创建一个接口继承JpaRepository并额外编写sql语句</strong></p> 
<h4><a id="1pomJpa_366"></a>1.在pom中添加Jpa依赖启动器</h4> 
<pre><code>&lt;dependency&gt;
           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre> 
<h5><a id="_374"></a>步骤一:建立一个实体类，表示与表的映射关系</h5> 
<p><strong>@GeneratedValue(strategy = GenerationType.IDENTITY)</strong><br> 这个后缀的各个作用<br> IDENTITY主键生成自增长<br> AUTO根据底层数据库判断生成策略<br> SEQUENCE是oulikou库数据库<br> TABLE表的形式我们取主键是从表中取</p> 
<p><strong>@Column(name = “content”)//对应表中的字段关系映射</strong></p> 
<pre><code>@Entity(name= "t_comment") //该注解表示当前实体类是与表有映射关系的实体类
public class Discuss {
    @Id//该注解表示配置该属性对应的字段为主键
    //IDENTITY主键生成自增长
    // AUTO根据底层数据库判断生成策略
    // SEQUENCE是oulikou库数据库
    // TABLE表的形式我们取主键是从表中取
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    //主键生成策略
    private Integer id;
    @Column(name = "content")
    private String content;
    @Column(name = "author")
    private String author;
    @Column(name = "a_Id")
    private Integer aId;
    @Override
    public String toString() {
        return "Discuss{" +
                "id=" + id +
                ", content='" + content + '\'' +
                ", author='" + author + '\'' +
                ", aId=" + aId +
                '}';
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public Integer getaId() {
        return aId;
    }

    public void setaId(Integer aId) {
        this.aId = aId;
    }


}
</code></pre> 
<h5><a id="_445"></a>步骤二：编写接口类</h5> 
<p>DiscussRepository</p> 
<p>新增注解：@Transactional//进行数控(数据变动要加)</p> 
<p><strong>•在自定义的Repository接口中，针对数据的变更操作（修改、删除），无论是否使用了@Query注解，都必须在方法上方添加@Transactional注解进行事务管理，否则程序执行就会出现InvalidDataAccessApiUsageException异常。</strong></p> 
<p><strong>•如果在调用Repository接口方法的业务层Service类上已经添加了@Transactional注解进行事务管理，那么Repository接口文件中就可以省略@Transactional注解</strong></p> 
<p><strong>@Modifying//对数据库进行变更必须加</strong></p> 
<p><strong>•在自定义的Repository接口中，使用@Query注解方式执行数据变更操作（修改、删除），除了要使用@Query注解，还必须添加@Modifying注解表示数据变更。</strong></p> 
<p>@Query("")//添加sql语句</p> 
<p><strong>例子：@Query(“UPDATE t_comment c SET c.author = ?1 WHERE c.id = ?2”)</strong><br> <strong>public int updateDiscuss(String author,Integer id);</strong></p> 
<p><strong>?1表示下面方法的第一个对象 ?2表示第二个</strong></p> 
<p><strong>对应导包</strong></p> 
<pre><code>import com.demo03.domain.Discuss;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import javax.transaction.Transactional;
</code></pre> 
<h6><a id="DiscussRepository_475"></a>接口类DiscussRepository</h6> 
<pre><code>//当前操作的&lt;实体类,主键数据类型&gt;
//好处：具有简单的增删查改功能
public interface DiscussRepository extends JpaRepository&lt;Discuss,Integer&gt; {
//    1查询author非空的Discuss评论信息
//使用jpa方式
 //findBy+查询条件+查询方式
    public List&lt;Discuss&gt; findByAuthorNotNull();
//2通过文章id分页查询出Discuss评论信息。
    //用注解引入sql语句
    @Query("SELECT c FROM t_comment c WHERE c.aId = ?1")
    public List&lt;Discuss&gt; getDiscussPaged(Integer aid, Pageable pageable);

//3通过文章id分页查询出Discuss评论信息。
//nativeQuery使用原生sql语句例如上面的语句c可以不用加*
    @Query(value = "SELECT * FROM t_comment  WHERE  a_Id = ?1",nativeQuery = true)
    public List&lt;Discuss&gt; getDiscussPaged2(Integer aid,Pageable pageable);
//4对数据进行更新
    @Transactional//进行数控
    @Modifying//对数据库进行变更必须加
    @Query("UPDATE t_comment c SET c.author = ?1 WHERE c.id = ?2")
    public int updateDiscuss(String author,Integer id);
    //5删除操作
    @Transactional
    @Modifying
    @Query("DELETE from t_comment c WHERE c.id = ?1")
    public int deleteDiscuss(Integer id);

}

</code></pre> 
<h5><a id="_508"></a>步骤三：测试类</h5> 
<pre><code>@Autowired
    private DiscussRepository discussRepository;
@Test
    public void test1(){
//    查询crudrespoitory自带的方法
    //Optional&lt;T&gt;是在java.util包下的一个用于代替null的一个工具类
        Optional&lt;Discuss&gt; byId= discussRepository.findById(1);
    //调用类里面的get方法，如果为空回会输出，解决空指针异常
    System.out.println(byId.get());
}
@Test
    public void test2(){
//    查询根据名字的方法
        List&lt;Discuss&gt; ByAuthorNotNull= discussRepository.findByAuthorNotNull();
        for (Discuss discuss:ByAuthorNotNull)
        System.out.println(discuss);
    }
    @Test
    public void test3(){
//    查询自带的方法
        int i= discussRepository.deleteDiscuss(1);
            System.out.println(i);
    }
</code></pre> 
<h2><a id="Spring_Boot_Redis_535"></a>三.Spring Boot 整合Redis</h2> 
<p>Redis 是一个<strong>开源</strong>（BSD许可）的、内存中的<strong>数据结构</strong>存储系统，它可以用作<strong>数据库、缓存和消息中间件</strong>，并提供多种语言的API。</p> 
<h3><a id="Redis_538"></a>Redis优点</h3> 
<p>1.<strong>存取速度快</strong>：Redis速度非常快，每秒可执行大约110000次的设值操作，或者执行81000次的读取操作。</p> 
<p>2.<strong>支持丰富的数据类型</strong>:Redis支持开发人员常用的大多数数据类型，例如列表、集合、排序集和散列等。(字符串,List,哈希)</p> 
<p>3.<strong>操作具有原子性</strong>：所有Redis操作都是原子操作，这确保如果两个客户端并发访问，Redis服务器能接收更新后的值。</p> 
<p>4.<strong>提供多种功能</strong>：Redis提供了多种功能特性，可用作非关系型数据库、缓存中间件、消息中间件等。</p> 
<h4><a id="1pomSpring_Data_Redis_547"></a>1.在pom文件中添加Spring Data Redis依赖启动器</h4> 
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre> 
<h4><a id="2ORM_557"></a>2.编写ORM实体类</h4> 
<p><strong>记得要生成getset方法</strong></p> 
<p><strong>Person实体类</strong></p> 
<pre><code>@RedisHash("persons")//创建一个存储空间
    public class Person {
        @Id//实体类主键
        private String id;
        @Indexed//用户标识该属性回在redis数据库中生成二级索引
        private String firstname;
        @Indexed
        private String lastname;
        private Address address;
        private List&lt;Family&gt; familyList;
}
</code></pre> 
<p><strong>Address实体类</strong></p> 
<pre><code>public class Address {
    @Indexed
    private String city;
    @Indexed
    private String country;
}
</code></pre> 
<p><strong>Family实体类</strong></p> 
<pre><code>public class Family {
    @Indexed
    private String type;
    @Indexed
    private String username;
}
</code></pre> 
<h4><a id="3Repository_597"></a>3.编写Repository接口</h4> 
<p><strong>创建一个接口PersonRepository</strong></p> 
<pre><code>public interface PersonRepository extends CrudRepository&lt;Person,String&gt; {
    //根据姓名查询某人
    List&lt;Person&gt; findByLastname(String lastname);
//根据姓氏查询某人（加了分页查询）
    Page&lt;Person&gt; findPersonByLastname(String lastname, Pageable page);
    //根据姓和名查询某人
    List&lt;Person&gt; findByFirstnameAndLastname(String firstname, String lastname);
    //查询这座城市查询
    List&lt;Person&gt; findByAddress_City(String city);
    //根据家庭查人
    List&lt;Person&gt; findByFamilyList_Username(String username);

}
</code></pre> 
<h4><a id="4applicationpropertiesRedis_615"></a>4.在全局配置文件application.properties中添加Redis数据库连接配置</h4> 
<pre><code>#配置redis连接
#配置服务器地址
spring.redis.host=127.0.0.1
#redis连接端口
spring.redis.port=6379
#redis服务连接密码
spring.redis.password=
</code></pre> 
<h4><a id="5_627"></a>5.编写单元测试进行接口方法测试及整合测试</h4> 
<pre><code>@SpringBootTest
class RedisTest {
@Autowired
    private PersonRepository personRepository;
@Test
    public void savePerson(){
    Person person=new Person();
    person.setFirstname("有才");
    person.setLastname("张");
    Address address = new Address();
    address.setCity("北京");
    person.setAddress(address);
    Family family = new Family();
    family.setType("父亲");
    family.setUsername("张三");
    Family family2 = new Family();
    family.setType("母亲");
    family.setUsername("李四");
    ArrayList&lt;Family&gt; familes = new ArrayList&lt;&gt;();
    familes.add(family);
    familes.add(family2);
    person.setFamilyList(familes);
    personRepository.save(person);
}
@Test
    public  void findByLastname(){
    List&lt;Person&gt; zhang = personRepository.findByLastname("张");
    System.out.println(zhang);

}
}
</code></pre> 
<p><strong>进入Redis可视化工具查看对应插入的数据</strong></p> 
<h2><a id="_663"></a>总结</h2> 
<p>相关文章<br> <a href="https://blog.csdn.net/loler15/article/details/114644779?spm=1001.2014.3001.5502">初学Springboot(一)</a><br> <a href="https://blog.csdn.net/loler15/article/details/114680268?spm=1001.2014.3001.5502">初学Springboot(二)</a><br> <a href="https://blog.csdn.net/loler15/article/details/114792617?spm=1001.2014.3001.5502">初学Springboot(三)</a><br> <font color="#999AAA">本章是对Springboot数据的整合，这里就MyBatis,JPA,REdis进行数据整合<br> 用了三个案例进行运行测试</font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0029b4afeee256a7d62e186a2016243d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">联通GPON/4&#43;1&#43;WiFi(2.4G)TEWA-800G配置桥接模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/648f9ce7b1cd289c13f9283faf01a5b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java编程实现算符优先分析法,编译原理实验三-算符优先分析法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>