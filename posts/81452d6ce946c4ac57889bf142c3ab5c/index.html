<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>魔板（搜索与图论、bfs） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="魔板（搜索与图论、bfs）" />
<meta property="og:description" content="Rubik 先生在发明了风靡全球的魔方之后，又发明了它的二维版本——魔板。
这是一张有 8 个大小相同的格子的魔板：
1 2 3 4 8 7 6 5 我们知道魔板的每一个方格都有一种颜色。
这 8 种颜色用前 8 个正整数来表示。
可以用颜色的序列来表示一种魔板状态，规定从魔板的左上角开始，沿顺时针方向依次取出整数，构成一个颜色序列。
对于上图的魔板状态，我们用序列 (1,2,3,4,5,6,7,8) 来表示，这是基本状态。
这里提供三种基本操作，分别用大写字母 A，B，C 来表示（可以通过这些操作改变魔板的状态）：
A：交换上下两行；
B：将最右边的一列插入到最左边；
C：魔板中央对的4个数作顺时针旋转。
下面是对基本状态进行操作的示范：
A：
8 7 6 5 1 2 3 4 B：
4 1 2 3 5 8 7 6 C：
1 7 2 4 8 6 3 5 对于每种可能的状态，这三种基本操作都可以使用。
你要编程计算用最少的基本操作完成基本状态到特殊状态的转换，输出基本操作序列。
注意：数据保证一定有解。
输入格式
输入仅一行，包括 8 个整数，用空格分开，表示目标状态。
输出格式
输出文件的第一行包括一个整数，表示最短操作序列的长度。
如果操作序列的长度大于0，则在第二行输出字典序最小的操作序列。
数据范围
输入数据中的所有数字均为 1 到 8 之间的整数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/81452d6ce946c4ac57889bf142c3ab5c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-09T17:56:28+08:00" />
<meta property="article:modified_time" content="2022-06-09T17:56:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">魔板（搜索与图论、bfs）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Rubik 先生在发明了风靡全球的魔方之后，又发明了它的二维版本——魔板。</p> 
<p>这是一张有 8 个大小相同的格子的魔板：</p> 
<pre><code>1 2 3 4
8 7 6 5
</code></pre> 
<p>我们知道魔板的每一个方格都有一种颜色。</p> 
<p>这 8 种颜色用前 8 个正整数来表示。</p> 
<p>可以用颜色的序列来表示一种魔板状态，规定从魔板的左上角开始，沿顺时针方向依次取出整数，构成一个颜色序列。</p> 
<p>对于上图的魔板状态，我们用序列 (1,2,3,4,5,6,7,8) 来表示，这是基本状态。</p> 
<p>这里提供三种基本操作，分别用大写字母 A，B，C 来表示（可以通过这些操作改变魔板的状态）：</p> 
<p>A：交换上下两行；<br> B：将最右边的一列插入到最左边；<br> C：魔板中央对的4个数作顺时针旋转。</p> 
<p>下面是对基本状态进行操作的示范：</p> 
<p>A：</p> 
<pre><code>8 7 6 5
1 2 3 4
</code></pre> 
<p>B：</p> 
<pre><code>4 1 2 3
5 8 7 6
</code></pre> 
<p>C：</p> 
<pre><code>1 7 2 4
8 6 3 5
</code></pre> 
<p>对于每种可能的状态，这三种基本操作都可以使用。</p> 
<p>你要编程计算用最少的基本操作完成基本状态到特殊状态的转换，输出基本操作序列。</p> 
<p><strong>注意</strong>：数据保证一定有解。</p> 
<p>输入格式</p> 
<p>输入仅一行，包括 8 个整数，用空格分开，表示目标状态。</p> 
<p>输出格式</p> 
<p>输出文件的第一行包括一个整数，表示最短操作序列的长度。</p> 
<p>如果操作序列的长度大于0，则在第二行输出字典序最小的操作序列。</p> 
<p>数据范围</p> 
<p>输入数据中的所有数字均为 1 到 8 之间的整数。</p> 
<p>输入样例：</p> 
<pre><code>2 6 8 4 5 7 3 1
</code></pre> 
<p>输出样例：</p> 
<pre><code>7
BCABCCB</code></pre> 
<p> <strong>把bfs的dir改成函数指针即可</strong></p> 
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std; using ll = long long;
vector&lt;int&gt;(*dir[3])(vector&lt;int&gt;&amp; s);
//using lll = __int128; template &lt;class T&gt; istream&amp; read(T&amp; x, istream&amp; cin = std::cin) { T num = 0; bool f = 0; char ch = 0; while (!isdigit(ch)) { f |= ch == '-'; if (!cin.get(ch)) return cin; }while (isdigit(ch)) { num = (num &lt;&lt; 3) + (num &lt;&lt; 1) + (ch ^ 48); if (!cin.get(ch)) break; }x = f ? -num : num; return cin; }template &lt;class T&gt; ostream&amp; write(T x, ostream&amp; cout = std::cout) { if (x &lt; 0) cout.put('-'), x = -x; if (x &gt; 9) write(x / 10); cout.put(x % 10 + '0'); return cout; }ostream&amp; operator&lt;&lt;(ostream&amp; cout, lll x) { write(x); return cout; }istream&amp; operator&gt;&gt;(istream&amp; cin, lll&amp; x) { return read(x); }bool check(int i, int j);
bool check(int i, int j);

const int N = 1e5 + 10, mod = 1e9 + 7, INF = 0x3f3f3f3f;

int n, m;
vector&lt;int&gt; tar(8, 0);

map &lt;vector&lt;int&gt;, pair&lt;vector&lt;int&gt;, char&gt;&gt; st;

vector&lt;int&gt; A(vector&lt;int&gt;&amp; s) {
	vector&lt;int&gt; t(s);
	reverse(t.begin(), t.end());
	return t;
}

vector&lt;int&gt; B(vector&lt;int&gt;&amp; s) {
	vector&lt;int&gt; t(s);
	t[0] = s[3];
	t[1] = s[0];
	t[2] = s[1];
	t[3] = s[2];
	t[4] = s[5];
	t[5] = s[6];
	t[6] = s[7];
	t[7] = s[4];
	return t;
}

vector&lt;int&gt; C(vector&lt;int&gt;&amp; s) {
	vector&lt;int&gt; t(s);
	swap(t[1], t[2]);
	swap(t[1], t[6]);
	swap(t[5], t[6]);
	return t;
}
vector&lt;int&gt; s;

void init() {
	dir[0] = A;
	dir[1] = B;
	dir[2] = C;
	n = 8;
	for (int i = 1; i &lt;= n; i++)
		s.emplace_back(i);
	for (int i = 0; i &lt; n; i++)
		cin &gt;&gt; tar[i];
	//cout &lt;&lt; "finish" &lt;&lt; endl;
	return;
}

void bfs() {
	//s.swap(tar);
	//for (auto i : tar) {
	//	cout &lt;&lt; i &lt;&lt; " ";
	//}
	//cout &lt;&lt; "tar\n";
	st[s] = { vector&lt;int&gt;(8, 0), '*' };
	queue&lt;pair&lt;vector&lt;int&gt;, int&gt;&gt; qu;
	qu.emplace(s, 0);
	while (qu.size()) {
		auto [x, d] = qu.front();
		//for (auto i : x) {
		//	cout &lt;&lt; i &lt;&lt; " ";
		//}
		//cout &lt;&lt; endl;
		qu.pop();
		if (x == tar) {
			cout &lt;&lt; d &lt;&lt; "\n";
			return;
		}
		for (int i = 0; i &lt; 3; i++) {
			//cout &lt;&lt; i &lt;&lt; endl;
			auto nx = dir[i](x);
			if (st.count(nx)) continue;
			st[nx] = { x, (char)('A' + i) };
			qu.emplace(nx, d + 1);
		}
	}
}

void solve() {
	bfs();
	vector&lt;char&gt; ans;
	while (tar != s) {
		ans.emplace_back(st[tar].second);
		tar = st[tar].first;
	}
	for (auto i = ans.rbegin(); i != ans.rend(); i++) {
		cout &lt;&lt; *i;
	}
	return;
}

int main(void) {
	ios::sync_with_stdio(0); cin.tie(0); cout &lt;&lt; setprecision(6) &lt;&lt; fixed;
	int TT = 1;
	//cin &gt;&gt; TT;
	for (int ii = 1; ii &lt;= TT; init(), solve(), ii++) {}
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/39d366061245ebce226bd4a621f2d18a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">矩阵距离（搜索与图论、bfs）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae3b7e770682c6e80cc74c0e83247d77/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;软件工程师之什么是类型安全？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>