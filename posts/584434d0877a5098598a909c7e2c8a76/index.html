<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>EMQX 安装使用和部分坑 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="EMQX 安装使用和部分坑" />
<meta property="og:description" content="0、前言 1、强烈建议查看官方文档，说的是真的不错，浅显易懂：EMQ 提供了通俗易懂的技术文章，帮助开发者快速了解 MQTT 协议及其相关特性
2、在我使用到现在，对比了很多MQTT broker，EMQX 几乎是完美的，只有一点限制，那就是开源版本不支持消息持久化
3、当然直接使用官方编译好的方式，启动也是不错的，很简单，也是很推荐的，官方文档的安装步骤一栏就有，记得选好版本欧
官方安装文档地址
点击上面箭头的链接，就会跳转了
一、安装 1、这里安装使用docker安装，版本为4.4.9，目前为止版本已经到5.x，但是本着先不用最新版本的原则，就先使用4.x版本
官网文档：4.4版本中文官方文档，左下角有切换版本和语言的按钮，选择对应的版本就好
2、从 dockerHub中找到对应的镜像版本 emqx/emqx
3、我就使用4.4.9版本的镜像就🆗。
4、建立对应的数据挂载目录，至于为什么挂载这些目录，是因为这些目录比较重要，可以看官方的目录解释
mkdir -p /data/docker/emqx/{etc,lib,data,log} 5、先运行一个demo 的emqx，就是没有挂载的镜像版本，为了将对应的目录文件copy出来，因为等下如果挂载，会读取挂载目录的数据，所以我们又不知道要那些数据，所以先跑一个demo，把对应文件数据copy出来，后面用来挂载即可
对应端口说明，如下图，其中挂载一个时间是因为，我发现这个镜像的时区不对，比我们少8个小时，所以挂载下时区，就可以保证和系统是一致的了
docker run -d --name emqx -v /etc/localtime:/etc/localtime -p 1883:1883 -p 8081:8081 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx:4.4.9 6、将对应的问价copy到我们前面建立的目录中,copy完成之后，就会发现我们的目录有数据了，这都是默认的基础配置，后面就可以用它们来挂载
docker cp emqx:/opt/emqx/etc /data/docker/emqx docker cp emqx:/opt/emqx/lib /data/docker/emqx docker cp emqx:/opt/emqx/data /data/docker/emqx docker cp emqx:/opt/emqx/log /data/docker/emqx 7、修改目录权限
chown -R 1000:1000 /data/docker/emqx/ chmod -R 755 /data/docker/emqx/ 8、删除不用的，建立完整的镜像" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/584434d0877a5098598a909c7e2c8a76/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-07T15:08:34+08:00" />
<meta property="article:modified_time" content="2023-06-07T15:08:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">EMQX 安装使用和部分坑</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="0_0"></a>0、前言</h2> 
<p>1、强烈建议查看官方文档，说的是真的不错，浅显易懂：<a href="https://www.emqx.com/zh/mqtt" rel="nofollow">EMQ 提供了通俗易懂的技术文章，帮助开发者快速了解 MQTT 协议及其相关特性</a></p> 
<p>2、在我使用到现在，对比了很多MQTT broker，EMQX 几乎是完美的，只有一点限制，<strong>那就是开源版本不支持消息持久化</strong></p> 
<p>3、当然直接使用官方编译好的方式，启动也是不错的，很简单，也是很推荐的，官方文档的安装步骤一栏就有，记得选好版本欧</p> 
<blockquote> 
 <p><a href="https://www.emqx.io/docs/zh/v4.4/getting-started/install.html#rpm-deb%E5%8C%85%E5%AE%89%E8%A3%85-linux" rel="nofollow">官方安装文档地址</a><br> <img src="https://images2.imgbox.com/41/25/dWXNTKPA_o.png" alt="在这里插入图片描述"><br> 点击上面箭头的链接，就会跳转了<img src="https://images2.imgbox.com/76/ff/BI7iH36e_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h2><a id="_9"></a>一、安装</h2> 
<p>1、这里安装使用docker安装，版本为4.4.9，目前为止版本已经到5.x，但是本着先不用最新版本的原则，就先使用4.x版本<br> 官网文档：<a href="https://www.emqx.io/docs/zh/v4.4/" rel="nofollow">4.4版本中文官方文档</a>，左下角有切换版本和语言的按钮，选择对应的版本就好</p> 
<p>2、从 <code>dockerHub</code>中找到对应的镜像版本 <a href="https://hub.docker.com/r/emqx/emqx/tags?page=1&amp;name=4.4" rel="nofollow">emqx/emqx</a></p> 
<p>3、我就使用4.4.9版本的镜像就🆗。</p> 
<p><img src="https://images2.imgbox.com/2e/ca/QGSLhQ3R_o.png" alt="在这里插入图片描述"></p> 
<p>4、建立对应的数据挂载目录，至于为什么挂载这些目录，是因为这些目录比较重要，可以看官方的目录解释</p> 
<pre><code class="prism language-shell"><span class="token function">mkdir</span> -p /data/docker/emqx/<span class="token punctuation">{<!-- --></span>etc,lib,data,log<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/dd/96/WGTbeiIJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4d/2d/kYn2PCzf_o.png" alt="在这里插入图片描述"></p> 
<p>5、先运行一个demo 的emqx，就是没有挂载的镜像版本，为了将对应的目录文件copy出来，因为等下如果挂载，会读取挂载目录的数据，所以我们又不知道要那些数据，所以先跑一个demo，把对应文件数据copy出来，后面用来挂载即可</p> 
<blockquote> 
 <p>对应端口说明，如下图，其中挂载一个时间是因为，我发现这个镜像的时区不对，比我们少8个小时，所以挂载下时区，就可以保证和系统是一致的了</p> 
</blockquote> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run -d --name emqx -v /etc/localtime:/etc/localtime  -p <span class="token number">1883</span>:1883 -p <span class="token number">8081</span>:8081 -p <span class="token number">8083</span>:8083 -p <span class="token number">8084</span>:8084 -p <span class="token number">8883</span>:8883 -p <span class="token number">18083</span>:18083 emqx/emqx:4.4.9
</code></pre> 
<p><img src="https://images2.imgbox.com/91/00/DxZPagKm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4f/e4/rKsME0yk_o.png" alt="在这里插入图片描述"></p> 
<p>6、将对应的问价copy到我们前面建立的目录中,copy完成之后，就会发现我们的目录有数据了，这都是默认的基础配置，后面就可以用它们来挂载</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token function">cp</span> emqx:/opt/emqx/etc /data/docker/emqx
<span class="token function">docker</span> <span class="token function">cp</span> emqx:/opt/emqx/lib /data/docker/emqx
<span class="token function">docker</span> <span class="token function">cp</span> emqx:/opt/emqx/data /data/docker/emqx
<span class="token function">docker</span> <span class="token function">cp</span> emqx:/opt/emqx/log /data/docker/emqx
</code></pre> 
<p><img src="https://images2.imgbox.com/a6/24/vS6VLCWI_o.png" alt="在这里插入图片描述"><br> 7、修改目录权限</p> 
<pre><code class="prism language-shell"><span class="token function">chown</span> -R <span class="token number">1000</span>:1000 /data/docker/emqx/
<span class="token function">chmod</span> -R <span class="token number">755</span> /data/docker/emqx/
</code></pre> 
<p><img src="https://images2.imgbox.com/32/41/I3GvxSL4_o.png" alt="在这里插入图片描述"></p> 
<p>8、删除不用的，建立完整的镜像</p> 
<pre><code class="prism language-shell"><span class="token comment"># 删除前面那个demo</span>
<span class="token function">docker</span> stop emqx <span class="token operator">&amp;&amp;</span> <span class="token function">docker</span> <span class="token function">rm</span> emqx


<span class="token comment"># 建立新的</span>
<span class="token function">docker</span> run -d --name emqx --restart<span class="token operator">=</span>always <span class="token punctuation">\</span>
-p <span class="token number">1883</span>:1883 <span class="token punctuation">\</span>
-p <span class="token number">8883</span>:8883 <span class="token punctuation">\</span>
-p <span class="token number">8083</span>:8083 <span class="token punctuation">\</span>
-p <span class="token number">8084</span>:8084 <span class="token punctuation">\</span>
-p <span class="token number">8081</span>:8081 <span class="token punctuation">\</span>
-p <span class="token number">18083</span>:18083 <span class="token punctuation">\</span>
-v /etc/localtime:/etc/localtime <span class="token punctuation">\</span>
-v /data/docker/emqx/etc:/opt/emqx/etc <span class="token punctuation">\</span>
-v /data/docker/emqx/lib:/opt/emqx/lib <span class="token punctuation">\</span>
-v /data/docker/emqx/data:/opt/emqx/data <span class="token punctuation">\</span>
-v /data/docker/emqx/log:/opt/emqx/log <span class="token punctuation">\</span>
emqx/emqx:4.4.9
</code></pre> 
<p><img src="https://images2.imgbox.com/0f/c6/MSHBlOho_o.png" alt="在这里插入图片描述"><br> 9、登录页面，根据前面的那个端口关系知道，<code>18083</code>是<code>dashboard</code>端口，访问即可<br> <code>http://192.168.172.229:18083</code>，输入默认账号: <code>admin</code> 默认密码：<code>public</code><br> <img src="https://images2.imgbox.com/f3/22/nlS2AZqf_o.png" alt="在这里插入图片描述"><br> 10、然后会强制你修改默认的密码，就🆗了，然后用新密码登录<br> <img src="https://images2.imgbox.com/2b/18/MlyJBteT_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="springBoot__82"></a>二、springBoot 使用</h2> 
<p>1、这个参考文章 <a href="https://blog.csdn.net/weixin_45614461/article/details/119318909">springboot整合mqtt实现消息发送和消费，以及客户端断线重连之后的消息恢复</a>，就行写的很好</p> 
<h2><a id="_85"></a>三、修改客户端链接授权</h2> 
<p>1、如上默认任何客户端都可以链接，这肯定是不可以的。</p> 
<p>2、官方提供很多认证方式，这里选取较为方便的一种 mnesia认证<br> <img src="https://images2.imgbox.com/03/99/nqxwetmc_o.png" alt="在这里插入图片描述"><br> 3、首先在配置文件中关闭匿名客户端链接，修改我们的挂载的配置文件（镜像里面的配置也会跟着改），<strong>然后重启镜像</strong>（不然不能生效…）</p> 
<pre><code class="prism language-shell"><span class="token comment"># 修改下述配置</span>
<span class="token function">vim</span> /data/docker/emqx/etc/emqx.conf

<span class="token comment"># 重启镜像</span>
<span class="token function">docker</span> restart emqx
</code></pre> 
<p><img src="https://images2.imgbox.com/57/01/9l0YXkrn_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/78/ce/tBjFbRLp_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/31/c2/dcmxHZta_o.png" alt="在这里插入图片描述"><br> 4、再次链接你就会发现无权链接<br> <img src="https://images2.imgbox.com/91/93/XZBkWjyN_o.png" alt="在这里插入图片描述"><br> 5、先在控制台开启 <code> mnesia认证</code></p> 
<p><img src="https://images2.imgbox.com/e4/6a/23iln4oT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a7/03/ut1z7M6Z_o.png" alt="在这里插入图片描述"></p> 
<p>6、增加对应用户，这的话官方说的已经很清楚了 <a href="https://www.emqx.io/docs/zh/v4.4/advanced/auth-mnesia.html" rel="nofollow">Mnesia 认证</a>，两种方式</p> 
<ul><li>预设认证数据（就是修改对应的配置文件，手动添加用户和密码）</li><li>使用 HTTP API 管理认证数据 （通过http的方式，来添加用户和密码）</li></ul> 
<p>7、那我们通过修改配置文件的方式好了，改完之后重启</p> 
<pre><code class="prism language-shell"><span class="token comment"># 1、修改配置文件，增加用户</span>
<span class="token function">vim</span> /data/docker/emqx/etc/plugins/emqx_auth_mnesia.conf


<span class="token comment"># etc/plugins/emqx_auth_mnesia.conf</span>

<span class="token comment">## clientid 认证数据</span>
auth.client.1.clientid <span class="token operator">=</span> thermal
auth.client.1.password <span class="token operator">=</span> TAUb<span class="token operator">&amp;</span>LjCdYB<span class="token comment">#EjAMNB</span>

<span class="token comment">## username 认证数据</span>
auth.user.2.username <span class="token operator">=</span> thermal
auth.user.2.password <span class="token operator">=</span> TAUb<span class="token operator">&amp;</span>LjCdYB<span class="token comment">#EjAMNB</span>

<span class="token comment"># 2、重启</span>
<span class="token function">docker</span> restart emqx
</code></pre> 
<p><img src="https://images2.imgbox.com/52/9e/zocH2dki_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/96/c2/6lyqBbWY_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>至于为啥有clientId和userName，两种，我建议是两个都配置，并且保持一致，当然你也可以只配置<code>userName</code>的方式也行，我已经测试过了。<img src="https://images2.imgbox.com/fd/2a/UaEy8Pv1_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>8、最后就可以了，使用最新的账号去链接。注意那个<code>admin</code>账号是登录控制台的，和客户端链接认证没有关系，客户端链接得写后面我们增加的用户 <code>thermal</code></p> 
<p><img src="https://images2.imgbox.com/30/79/Mb4aNKpc_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_146"></a>四、使用问题说明</h2> 
<h3><a id="41MQTT_EMQX_147"></a>4.1、MQTT EMQX中如何监听客户端上下线？</h3> 
<ul><li>1、官方提供了三种方案，但是最后一种是企业版本的要收费<br> <img src="https://images2.imgbox.com/e3/3e/p6wJu1PH_o.png" alt="在这里插入图片描述"></li><li>2、订阅相关的 $SYS 主题</li></ul> 
<blockquote> 
 <ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           S 
          
         
           Y 
          
         
           S 
          
         
           / 
          
         
           b 
          
         
           r 
          
         
           o 
          
         
           k 
          
         
           e 
          
         
           r 
          
         
           s 
          
         
           / 
          
         
        
          SYS/brokers/ 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord mathnormal" style="margin-right: 0.2222em;">Y</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord">/</span><span class="mord mathnormal">b</span><span class="mord mathnormal">ro</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mord mathnormal">ers</span><span class="mord">/</span></span></span></span></span>{node}/clients/${clientid}/connected</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           S 
          
         
           Y 
          
         
           S 
          
         
           / 
          
         
           b 
          
         
           r 
          
         
           o 
          
         
           k 
          
         
           e 
          
         
           r 
          
         
           s 
          
         
           / 
          
         
        
          SYS/brokers/ 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord mathnormal" style="margin-right: 0.2222em;">Y</span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord">/</span><span class="mord mathnormal">b</span><span class="mord mathnormal">ro</span><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="mord mathnormal">ers</span><span class="mord">/</span></span></span></span></span>{node}/clients/${clientid}/disconnected</li></ul> 
</blockquote> 
<ul><li>3、可以直接使用<code>web_hook</code>来实现 参考文章 <a href="https://blog.csdn.net/san13219091/article/details/127339206">MQTT EMQX中如何监听客户端上下线？</a>，但是这个文章中说<code>web_hook</code>没有问题是不对的，比如，我们提供的<code>web_hook</code>接口的服务需要重启，而重启这段时间内，其他客户端上下线的数据，我们就拿不到了。<br> <img src="https://images2.imgbox.com/e9/0d/qLlt1c86_o.png" alt="在这里插入图片描述"></li></ul> 
<p><img src="https://images2.imgbox.com/b6/eb/yVdcgiDs_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/68/fd/qbndDvVp_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="42emqx_164"></a>4.2、emqx开源版服务重启后主题和消息会丢失(无法持久化离线消息)</h3> 
<p>1、意思就是，消息已经发布到<code>emqx</code>服务器了，但是此时接收者不在线，而我们重启emqx服务后，再让接收者上线，前面那一部分数据，接收者是收不到的，也就是丢失了。 文章说明参考 <a href="https://www.cnblogs.com/gmhappy/p/13457039.html" rel="nofollow">基于emq x开源版实现服务重启后主题和消息恢复的完整方案（二）</a>，<strong><mark>开源版本不持支数据持久化</mark></strong>。</p> 
<p><img src="https://images2.imgbox.com/df/06/F3uFfeab_o.png" alt="在这里插入图片描述"></p> 
<p>2、付费版本是提供了很多方式的数据持久化的，参考官方文章<a href="https://www.emqx.com/zh/blog/emqx-plugin-persistence-series-5-mysql-mqtt-data-storage" rel="nofollow">EMQX 插件持久化系列 （五）MySQL MQTT 数据存储</a></p> 
<blockquote> 
 <p>注意这里的消息持久化，是指普通消息重启之后也会在（即离线消息），官方有提供一个插件，<code>emqx_retainer</code>，但是这个只是持久化<code>保留消息的</code>，每次重启都会发给订阅者 ，关于<code>保留消息</code>的概念，可以参考 官方文档 <a href="https://www.emqx.io/docs/zh/v4/advanced/retained.html#%E7%AE%80%E4%BB%8B" rel="nofollow">保留消息</a></p> 
</blockquote> 
<blockquote> 
 <p><mark><strong>大家要区分出来 <code>离线消息，消息未送到订阅端，保存在emqx服务器中，但是emqx服务重启了</code>和<code>保留消息（只有保存最新的一次消息）</code>的区别</strong></mark>，下面这个配置是配置保留消息的持久化的，所以和持久化离线消息是没有的。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/3a/59/XfnsCXuC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="43_178"></a>4.3、客户端断线自动重连</h3> 
<p>1、这篇文章说的很不错，参考链接 <a href="https://blog.csdn.net/myinsert/article/details/107715538">SpringBoot 开发之 MQTT 协议客户端断线后自动重连与保留断线时发布的主题消息</a>，可以直接看这篇，下面的就是它的解决方案。</p> 
<p>2、如果有一个客户端程序已经用emqx很久了，突然emqx服务需要重启，那么这个客户端程序就会抛出一个异常，说被迫断开了一个链接，即使emqx服务重启好了之后，这个客户端程序还是不可以使用，除非你重启这个客户端程序，再次重连，所以我们需要做的是，不重启客户都安程序，当emqx服务OK的时候，自动重连。</p> 
<ul><li> <p>设置参数<code>AutomaticReconnect</code> 为<code>true</code>，<strong>但是 使用 automaticReconnect 为 true 表示断线自动重连，但仅仅只是重新连接，并不订阅主题；</strong></p> </li><li> <p>所以还要在链接完成后，再次订阅主题</p> </li></ul> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">connectComplete</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">,</span> <span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 客户端连接成功</span>
    <span class="token class-name">CodeUtils</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"[MQTT] 连接成功，重新订阅主题..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        client<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> QOS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MqttException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面代码等同于，我们自己在链接成功的时候去订阅主题，<code>主题可以重复订阅</code></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">connectComplete</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> reconnect<span class="token punctuation">,</span> <span class="token class-name">String</span> serverURI<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"platform端 链接成功,是否是reconnect的结果: {},serverURI: {}"</span><span class="token punctuation">,</span> reconnect<span class="token punctuation">,</span> serverURI<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 以testtopic/#结尾表示订阅所有以testtopic开头的主题</span>
        <span class="token comment">// 手动订阅之后，messageArrived() 方法就收不到消息了，都在这里</span>
        mqttPlatformClient<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">TopicConstant</span><span class="token punctuation">.</span>UPPER_MACHINE_2_PLATFORM<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">IMqttMessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">messageArrived</span><span class="token punctuation">(</span><span class="token class-name">String</span> topic<span class="token punctuation">,</span> <span class="token class-name">MqttMessage</span> message<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"platform端 订阅消息回调函数topic: "</span> <span class="token operator">+</span> topic <span class="token operator">+</span> <span class="token string">" ,msg: "</span> <span class="token operator">+</span> message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>两种方式二选一即可。</p> 
<h3><a id="44_215"></a>4.4、客户端掉线再上线，获取掉线期间的数据</h3> 
<p>1、我们假设emqx服务是🆗的，那么如果一个客户端服务，需要重启更新版本，那么，我希望更新版本之后，这个客户端还能收到掉线这段时间的数据，这个很简单，emqx服务已经实现了，需要设置以下两点</p> 
<ul><li>重连后接收端的clientId不变</li><li>且设置参数clearSession为false</li></ul> 
<p>2、但是EMQX服务保存的数据量也是有配置的，这里说的是将离线消息保存在内存中，即EMQX服务没有重启(<strong>开源版本不支持离线消息持久化，前面说了</strong>),如下图，我们知道，离线保存消息在内存中（<strong>也就是飞行窗口和消息队列</strong>）只会保存5分钟，且最大也才1000条，修改参数，可以在全局参数文件<code>emqx.conf</code>中修改</p> 
<p><img src="https://images2.imgbox.com/3b/0d/w6KtvOcF_o.png" alt="在这里插入图片描述"></p> 
<p>3、修改时间参数和队列存储长度的参数，可以看 4.5小节，里面举例就是按照这个参数举例的。</p> 
<pre><code class="prism language-shell"><span class="token comment"># 队列长度，默认1000，设置为0不限制</span>
zone.external.max_mqueue_len  <span class="token operator">=</span> <span class="token number">1000</span>

<span class="token comment"># 会话默认超时时间, 这个其实就是在离线消息的保存时间 2h = 120min = 7200s</span>
zone.external.session_expiry_interval <span class="token operator">=</span> 2h

<span class="token comment"># 注意并不是 zone.external.await_rel_timeout 这个参数</span>
</code></pre> 
<p>4、其实我们搭建完成 <code>Dashboard</code>后，也是能看出来一些的。<br> <img src="https://images2.imgbox.com/18/9b/8OG0o5NZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8a/0f/1zJjPRC9_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="441_241"></a>4.4.1、验证离线消息默认队列长度</h4> 
<p>1、 我们使用默认的配置，不修改参数<code>zone.external.max_mqueue_len</code>和<code>zone.external.session_expiry_interval</code>,直接通过<code>EmqxPlatformApplication :7093/</code>应用向队列里面发送2w条消息</p> 
<blockquote> 
 <p>这个实验得在2h内完成，因为我们没有修改<code>zone.external.session_expiry_interval</code>参数</p> 
</blockquote> 
<p>2、 为了方便观察，我们使用控制台，监控该队列的数据流入流出情况，目前为止都是 0</p> 
<p><img src="https://images2.imgbox.com/11/90/x94vLvso_o.png" alt="在这里插入图片描述"><br> 3、 该图是mock数据的接口，我们直接请求该接口，传参为 20000</p> 
<p><img src="https://images2.imgbox.com/6b/f3/Sw1KdxNH_o.png" alt="在这里插入图片描述"><br> 4、 发送结束，我们看到监控台，已经流入了2w的数据了，因为消费应用<code>EmqxUpperMachineApplication</code>，还没有启动，所以这些消息，会变为离线消息<br> <img src="https://images2.imgbox.com/45/2a/snrUdvZy_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/51/84/vl8lV8NN_o.png" alt="在这里插入图片描述"></p> 
<p>5、启动消费客户端发现只有 19000-20000的数据，其他数据丢失<br> <img src="https://images2.imgbox.com/b8/0b/oZQvebVg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/19/75/csX6Ci33_o.png" alt="在这里插入图片描述"></p> 
<p>6、我们观察日志可以看到，日志中写了，队列已经满了，所以放不下，我们计算下数据的条数就知道，从第五行开始，加上19000，就是说会到19004行,正好 19000条被遗弃掉，所以队列长度，默认为1000</p> 
<pre><code class="prism language-shell"><span class="token number">2022</span>-12-09T10:09:27.513000+08:00 <span class="token punctuation">[</span>warning<span class="token punctuation">]</span> upperMachine@127.0.0.1:53739 <span class="token punctuation">[</span>Session<span class="token punctuation">]</span> Dropped msg due to mqueue is full: Message<span class="token punctuation">(</span>Id<span class="token operator">=</span>0005EF5BA46867AAF4420000020B0001, <span class="token assign-left variable">QoS</span><span class="token operator">=</span><span class="token number">2</span>, <span class="token assign-left variable">Topic</span><span class="token operator">=</span>test/thermal/platform_2_upper_machine, <span class="token assign-left variable">From</span><span class="token operator">=</span><span class="token operator">&lt;&lt;</span><span class="token string">"platform"</span><span class="token operator">&gt;&gt;</span>, <span class="token assign-left variable">Flags</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>, <span class="token assign-left variable">Headers</span><span class="token operator">=</span><span class="token comment">#{peerhost =&gt; {127,0,0,1}, properties =&gt; #{},proto_ver =&gt; 3,protocol =&gt; mqtt,username =&gt; &lt;&lt;"thermal"&gt;&gt;})</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/dc/7a/HtoIakl3_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b1/19/YRqRfNFc_o.png" alt="在这里插入图片描述"></p> 
<p>7、所以，如果不限制的话，可以设置为0，则20000条数据就都会在，修改之后，我们也能在控制台看到<br> <img src="https://images2.imgbox.com/6c/de/6hTl8JsU_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="442_273"></a>4.4.2、验证离线消息保留时长</h4> 
<p>1、我们使用默认的配置，不修改参数<code>zone.external.max_mqueue_len</code>，修改<code>zone.external.session_expiry_interval</code>设置为 20分钟，控制台页面也能看到修改的参数值</p> 
<pre><code class="prism language-shell"><span class="token comment"># 为啥设置那么长时间，是为了和其他参数区分开来，更好的验证，我们过去20分钟就去验证即可。</span>
zone.external.session_expiry_interval <span class="token operator">=</span> 20m
</code></pre> 
<p><img src="https://images2.imgbox.com/15/f3/Ihshwvcw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8a/10/qqwSoVn7_o.png" alt="在这里插入图片描述"></p> 
<p>2、 直接通过<code>EmqxPlatformApplication :7093/</code>应用向队列里面发送10条消息即可，因为我们是验证已经存储的消息的保留时间，不需要太多数据</p> 
<ul><li> <p>监控如下.<br> <img src="https://images2.imgbox.com/3f/8e/OFPBuFIF_o.png" alt="在这里插入图片描述"></p> </li><li> <p><mark><strong>过20多分钟后</strong></mark> 启动客户端发现没有之前的10条数据</p> </li><li> <p>查看日志发现已经丢弃</p> </li></ul> 
<h3><a id="45emqx_298"></a>4.5、emqx的全局配置文件参数说明</h3> 
<p>1、这个很重要，我强烈建议你去读取一遍，了解一下有那些参数可以配置，其中有写参数非常重要，<br> <a href="https://www.emqx.io/docs/zh/v4.3/configuration/configuration.html#zoneexternal" rel="nofollow">EMQX- V4.4</a> 官方参数文档地址</p> 
<p><img src="https://images2.imgbox.com/44/5a/cuaks1P8_o.png" alt="在这里插入图片描述"><br> 2、这里我举几个比较重要的参数，比如4.4小节中提到的飞行窗口的参数，看如下图，可得知，离线消息先到飞行窗口里面，再到meassge_queue中，两个的参数分别为 <code>zone.内部/外部.max_inflight</code> 和 <code>max_mqueue_len</code>，并且这些离线数据存储也是有时限的，第四小节中的那张图片中有说明，其实那个就是<code>EMQX</code>的默认配置</p> 
<blockquote> 
 <p>含义解释如下：<img src="https://images2.imgbox.com/09/cf/xzn9LK8M_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ul><li>就可以知道<code>max_mqueue_len</code>默认值是1000，要是希望不限制，则改为0即可，如果你设置为1000，但是有3000条消息，那么这个队列里面只会保留2000-3000这个一千条最新的数据。1到1999的数据会收不到，以上面的参数，设置离线消息的保留时间。</li></ul> 
<p><img src="https://images2.imgbox.com/2a/fa/OtEJKjrA_o.png" alt="在这里插入图片描述"></p> 
<ul><li>内部<code>max_inflight</code></li><li><img src="https://images2.imgbox.com/37/13/5I0Hyw6P_o.png" alt="在这里插入图片描述"></li><li>外部<code>max_inflight</code><br> <img src="https://images2.imgbox.com/6b/84/lMKWrJON_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="46docker__315"></a>4.6、docker 部署后即使挂载了日志目录，还是没有日志</h3> 
<p>1、官方说明，如果版本大约4.3.3，还使用docker部署，则自能通过 docker logs 查看，或者如下配置，官方说明 <a href="https://www.emqx.io/docs/zh/v4.4/getting-started/log.html#%E6%8E%A7%E5%88%B6%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA" rel="nofollow">控制日志输出</a></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/13/08/7hMclsdA_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="47emqx__319"></a>4.7、emqx 会丢弃消息</h3> 
<p>1、接受队列的客户端一直不在，则会丢弃消息，举一个例子，如下，现有客户端</p> 
<ul><li>platform</li><li>upperMachine</li></ul> 
<p>2、有队列<code>platform_2_upper_machine</code>，则<code>platform</code>上线，向队列<code>platform_2_upper_machine</code>发生消息，但是客户端<code>upperMachine</code>没有上线过或者上线过后，session已经被清除了</p> 
<blockquote> 
 <p>什么时候被清除，就是前面说的那个参数 <code>zone.external.session_expiry_interval</code>,下面这个图设置的值是一天，也就是86400秒。这个参数确实可以是保存离线消息的时间，但是提前是你之前有登录过emqx服务器，即下面的记录中有你，也就是在 <code>zone.external.session_expiry_interval</code>时间内，存在，一旦这个时间期限一过，而你还是没有登录，则会自动清除，离线消息也就没有了</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/b7/90/ggetcXHq_o.png" alt="在这里插入图片描述"><br> 3、所以这个时候你向队列<code>platform_2_upper_machine</code>发送消息，会直接被遗弃，因为没有 <code>zone.external.session_expiry_interval</code>时间范围内存活的客户端来消费这个队列。</p> 
<p><img src="https://images2.imgbox.com/a1/0e/j9HWbq0y_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_333"></a>五、生产环境建议修改的值</h2> 
<p>根据第四小节的说明，我们可以知道要修改EMQX的服务参数</p> 
<ul><li> <p>修改web_hook的地址，来监听客户端的上下线问题</p> </li><li> <p>修改消息队列大小，不用修改飞行窗口的大小 ，修改参数<code>zone.external.max _mqueue_len</code>为0，表示不限制，注意是**外部域（external）**的参数</p> </li><li> <p>修改离线消息的保存时间可以根据线上环境来考虑<code>zone.external.session_expiry_interval</code></p> </li><li> <p>还有一个部署时候的日志bug，如果版本大约4.3.3，还使用docker部署，则自能通过 docker logs 查看，或者如下配置，官方说明 <a href="https://www.emqx.io/docs/zh/v4.4/getting-started/log.html#%E6%8E%A7%E5%88%B6%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA" rel="nofollow">控制日志输出</a></p> </li></ul> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/74/10/S7HwiZqr_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h2><a id="_345"></a>六、各个功能的账号密码说明</h2> 
<h3><a id="61dashboard_346"></a>6.1、登录<code>dashboard</code>的账号密码</h3> 
<p>1、登录<code>dashboard</code>的账号密码，默认是admin/public，这个修改的方式很简单，直接到用户模块进行修改即可，<strong>这个修改的作用只是用于登录dashboard，无任何其他作用</strong><br> <img src="https://images2.imgbox.com/b2/16/Wb0PzuZZ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="62java_349"></a>6.2、客户端的账号密码（比如java程序）</h3> 
<p>1、这个看第三节 <code>修改客户端链接授权</code> 即可</p> 
<h3><a id="63HTTP_API_352"></a>6.3、使用HTTP API，的用户名和密码</h3> 
<p>1、这个官方也给出了说明 <a href="https://askemq.com/t/topic/549" rel="nofollow">HTTP API，用户名和密码哪里配置？</a></p> 
<p><img src="https://images2.imgbox.com/89/b8/BNbymPRX_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f6/9f/VvMAb51G_o.png" alt="在这里插入图片描述"><br> 2、添加完成之后密码就是密钥，会自动生成<br> <img src="https://images2.imgbox.com/33/ef/Co6T7XSm_o.png" alt="在这里插入图片描述"><br> 3、比如现在我需要获取对应的客户端信息通过api接口，账号密码安装前面的生成即可.<br> <img src="https://images2.imgbox.com/5f/9b/1mPYmy5L_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fb72ff0c554dfa56902af6820138741a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python毕业设计如何选题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/97e36553bdff2008ad50fb384a52bfb8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">kali网络配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>