<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>秒懂SpringBoot之参数验证全解析(@Validated与@Valid) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="秒懂SpringBoot之参数验证全解析(@Validated与@Valid)" />
<meta property="og:description" content="[版权申明] 非商业目的注明出处可自由转载
出自：shusheng007
文章目录 概述实例SpringBoot 验证概述引入依赖使用相关注解标记使用@Valid标记统一处理异常 高级用法复杂对象参数验证基本类型参数验证Service方法参数验证手动验证分组验证自定义约束注解JPA Entity验证 概述源码题外话 概述 在构建 Web 应用程序时，确保进入应用程序的数据有效并满足您的业务需求非常重要。 实现此目的的一种方法是在服务器端验证输入数据。 在这篇博客中，我们将探讨如何在 Spring Boot 应用程序中进行输入数据验证，善用的话可以写出健壮而优美的代码。
让我们从一个实例开始吧
实例 邻家有女初长成，大名唤作牛翠华，家里催翠花找对象，无奈翠花深受互联网女拳师的影响，搞得翠花对另一半的要求非常高…
择偶标准
非王思聪类型不嫁年龄大于30不嫁身高矮于185cm不嫁体重高于85kg不嫁没有大别墅不嫁没有大奔驰不嫁父母建在且没有城市养老金不嫁
… 假如我们要写一个产生符合其要求的男朋友的API，如何来写呢？
@Slf4j @RestController @RequestMapping(&#34;/validation&#34;) public class ValidateController { @Autowired private ValidationService validationService; @PostMapping(&#34;/boy-friends&#34;) public ResponseEntity&lt;BoyFriend&gt; createBoyFriend(@RequestBody BoyFriend boy) { log.info(&#34;create:{}&#34;, boy); return ResponseEntity.ok(boy); } } 于是我们今天的主角就登场了。
SpringBoot 验证概述 Spring Boot 使用 Jakarta Bean Validation API 为输入数据验证提供内置支持，Java Bean Validation API 是用于验证 Java 对象的标准 API。 此 API 允许您使用注释定义 Java 类属性的约束，并根据这些约束验证输入数据。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0294f49a84fc8001190466905c7e5b8d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-02T09:11:01+08:00" />
<meta property="article:modified_time" content="2023-04-02T09:11:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">秒懂SpringBoot之参数验证全解析(@Validated与@Valid)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>[版权申明] 非商业目的注明出处可自由转载<br> 出自：shusheng007</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_5" rel="nofollow">概述</a></li><li><a href="#_10" rel="nofollow">实例</a></li><li><a href="#SpringBoot__44" rel="nofollow">SpringBoot 验证概述</a></li><li><ul><li><a href="#_50" rel="nofollow">引入依赖</a></li><li><a href="#_62" rel="nofollow">使用相关注解标记</a></li><li><a href="#Valid_78" rel="nofollow">使用@Valid标记</a></li><li><a href="#_101" rel="nofollow">统一处理异常</a></li></ul> 
  </li><li><a href="#_118" rel="nofollow">高级用法</a></li><li><ul><li><a href="#_121" rel="nofollow">复杂对象参数验证</a></li><li><a href="#_141" rel="nofollow">基本类型参数验证</a></li><li><a href="#Service_163" rel="nofollow">Service方法参数验证</a></li><li><a href="#_180" rel="nofollow">手动验证</a></li><li><a href="#_205" rel="nofollow">分组验证</a></li><li><a href="#_255" rel="nofollow">自定义约束注解</a></li><li><a href="#JPA_Entity_314" rel="nofollow">JPA Entity验证</a></li></ul> 
  </li><li><a href="#_318" rel="nofollow">概述</a></li><li><a href="#_324" rel="nofollow">源码</a></li><li><a href="#_329" rel="nofollow">题外话</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_5"></a>概述</h2> 
<p>在构建 Web 应用程序时，确保进入应用程序的数据有效并满足您的业务需求非常重要。 实现此目的的一种方法是在服务器端验证输入数据。 在这篇博客中，我们将探讨如何在 Spring Boot 应用程序中进行输入数据验证，善用的话可以写出健壮而优美的代码。</p> 
<p>让我们从一个实例开始吧</p> 
<h2><a id="_10"></a>实例</h2> 
<p>邻家有女初长成，大名唤作牛翠华，家里催翠花找对象，无奈翠花深受互联网女拳师的影响，搞得翠花对另一半的要求非常高…</p> 
<p>择偶标准</p> 
<ul><li>非王思聪类型不嫁</li><li>年龄大于30不嫁</li><li>身高矮于185cm不嫁</li><li>体重高于85kg不嫁</li><li>没有大别墅不嫁</li><li>没有大奔驰不嫁</li><li>父母建在且没有城市养老金不嫁<br> …</li></ul> 
<p>假如我们要写一个产生符合其要求的男朋友的API，如何来写呢？</p> 
<pre><code>@Slf4j
@RestController
@RequestMapping("/validation")
public class ValidateController {

    @Autowired
    private ValidationService validationService;

    @PostMapping("/boy-friends")
    public ResponseEntity&lt;BoyFriend&gt; createBoyFriend(@RequestBody BoyFriend boy) {
        log.info("create:{}", boy);
        return ResponseEntity.ok(boy);
    }
 }
</code></pre> 
<p>于是我们今天的主角就登场了。</p> 
<h2><a id="SpringBoot__44"></a>SpringBoot 验证概述</h2> 
<p>Spring Boot 使用 <a href="https://beanvalidation.org/2.0/" rel="nofollow">Jakarta Bean Validation API</a> 为输入数据验证提供内置支持，Java Bean Validation API 是用于验证 Java 对象的标准 API。 此 API 允许您使用注释定义 Java 类属性的约束，并根据这些约束验证输入数据。</p> 
<p>目前一般使用2.0版本，由<strong>JSR 380</strong>提出。Java提出了这个标准，却没有给出实现，我们使用的都是Hibernate 的实现版本： <a href="https://hibernate.org/validator/" rel="nofollow">Hibernate Validator</a> .</p> 
<h3><a id="_50"></a>引入依赖</h3> 
<p>要使用Hibernate Validator，所以要引入其依赖。SpringBoot2.3以后必须手动引入如下依赖（2.3以前在web的依赖包中包含了）。</p> 
<pre><code> &lt;dependencies&gt;
     &lt;dependency&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
         &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
     &lt;/dependency&gt;
 &lt;/dependencies&gt;
</code></pre> 
<h3><a id="_62"></a>使用相关注解标记</h3> 
<p><code>jakarta.validation-api</code>模块中提供了很多添加约束的注解，包括</p> 
<pre><code>@NotNull @NotEmpty @NotBlank @Min @Max @Email @Size @Pattern  ...
</code></pre> 
<p>使用时可以查阅源码，都很简单。</p> 
<pre><code>public class BoyFriend {
    @Max(30)
    private Integer age;
    ...
}
</code></pre> 
<h3><a id="Valid_78"></a>使用@Valid标记</h3> 
<p>使用<code>@Valid </code>标记参数即可。</p> 
<pre><code>    @PostMapping("/boy-friends")
    public ResponseEntity&lt;BoyFriend&gt; createBoyFriend(@Valid @RequestBody BoyFriend boy) {
        log.info("create:{}", boy);
        return ResponseEntity.ok(boy);
    }
</code></pre> 
<p>完成以上三步其实已经可以了，不过在验证失败时会抛出<code>MethodArgumentNotValidException</code>，对前端不友好，实际项目中我们都会对异常做统一处理，然后包装成统一的返回格式。</p> 
<p>例如下面这样的格式：</p> 
<pre><code>{
    "code": 10000,
    "message": "错误消息",
    "data": xxx
}
</code></pre> 
<h3><a id="_101"></a>统一处理异常</h3> 
<pre><code>@RestControllerAdvice
public class ExceptionHandlers {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public BaseResponse&lt;String&gt; onMethodArgumentNotValidException(MethodArgumentNotValidException e) {
        String errMsg = e.getBindingResult().getFieldErrors().stream()
                .map(f -&gt; f.getField() + ":" + f.getDefaultMessage())
                .collect(Collectors.joining("| "));
        return new BaseResponse&lt;&gt;(10000, MessageFormat.format("Invalid param: [{0}]", errMsg), null);
    }
    
}
</code></pre> 
<h2><a id="_118"></a>高级用法</h2> 
<p>一般情况下，上面的方法已经可以应对，但是有些场景需要更多的努力</p> 
<h3><a id="_121"></a>复杂对象参数验证</h3> 
<p>有时入参比较复杂，例如BoyFriend里面的house属性也是一个object，我们也需要对House这个对象属性进行验证。我们只需要在house属性申明处添加上<code>@Valid</code>注解即可。</p> 
<pre><code>public class BoyFriend {
    @Valid
    @NotNull
    private House house;
}

public class House {
    @AssertTrue
    private Boolean isVilla;
    
    @DecimalMin("100000000")
    private Integer price;
}

</code></pre> 
<h3><a id="_141"></a>基本类型参数验证</h3> 
<p>有时我们的入参是基本类型，例如使用<code>@RequestParam</code> 或<code>@PathVariable</code> 标记的参数，这个怎么验证呢？例如下面的入参name。</p> 
<pre><code>@Validated
@RestController
@RequestMapping("/validation")
public class ValidateController {
      ...
    @GetMapping("/boy-friends")
    public ResponseEntity&lt;BoyFriend&gt; updateBoyFriend(@NotBlank @RequestParam("name") String name) {
        ...
    }
}
</code></pre> 
<p>我们只需要给参数添加上相应的约束注解，例如<code>@NotBlank</code>，然后再给Controller类添加上<code>@Validated</code>即可。 <code>@Validated</code>是Spring提供的一个注解。</p> 
<p>需要注意的是，这会抛出的是<code>ConstraintViolationException</code>异常，不是<code>MethodArgumentNotValidException</code>，所以需要将此异常也统一处理了，具体看文后源码。</p> 
<h3><a id="Service_163"></a>Service方法参数验证</h3> 
<p>一般情况下我们都是在controller里就把参数验证做了，但是如果我们也想在Service里面的方法使用这套验证机制可以吗？答案是肯定的</p> 
<ul><li>使用<code>@Validated</code>标记Service类</li><li>使用<code>@Valid</code>注解标记方法入参，如果是基本类型的话只使用约束注解即可，与controller一样。</li></ul> 
<pre><code>@Validated
@Service
public class ValidationService {
    public BoyFriend queryBoyFriendByName(@Size(min = 1,max = 3) String name) {
        return BoyFriend.builder().name(name).build();
    }
}
</code></pre> 
<h3><a id="_180"></a>手动验证</h3> 
<p>有时我们需要手动触发验证而不依赖框架，这也是可以的。</p> 
<ul><li>注入<code>Validator</code>的实例</li><li>调用其<code>validate</code>方法并处理结果</li></ul> 
<pre><code>@RestController
@RequestMapping("/validation")
public class ValidateController {
    @Autowired
    private Validator validator;

    @PatchMapping("/boy-friends")
    public ResponseEntity&lt;BoyFriend&gt; updateBoyFriend(@Valid  @RequestBody BoyFriend boy) {
            Set&lt;ConstraintViolation&lt;House&gt;&gt; validateResults = validator.validate(boy.getHouse());
            
            String errMsg = validateResults.stream().map(e -&gt; e.getPropertyPath() + ":" + e.getMessage()).collect(Collectors.joining("| "));

            throw new BusinessException(errMsg,10002);
         ...
    }
 }
</code></pre> 
<h3><a id="_205"></a>分组验证</h3> 
<p>有时一个类被多个方法使用，而每个方法对入参的要求却不一样，这种情况怎么办呢？例如我们的<code>BoyFriend</code>，里面有一个体重的属性，创建时要求不能高于85kg，由于条件苛刻，于是修改的时候要求不能高于100kg。</p> 
<p>Spring提供了一种解决方法，那就是使用分组。每个注解里面都可以设置其属于哪些分组，在验证的时候只验证属于自己分组的那些约束。</p> 
<p>例如我们这里设置两个分组：创建和更新，当调用创建方法的时候就只验证属于创建分组的约束，不高于85kg…</p> 
<pre><code>public class BoyFriend {
    @Max(groups = BoyFriendCreate.class, value = 85)
    @Max(groups = BoyFriendUpdate.class, value = 100)
    private Integer weight;
}
</code></pre> 
<p>如何实现呢？</p> 
<ul><li>定义分组</li></ul> 
<p>分组必须是接口，例如我们这里定义了两个分组</p> 
<pre><code>public interface BoyFriendCreate {
}

public interface BoyFriendUpdate {
}
</code></pre> 
<ul><li>给约束添加相应的分组</li></ul> 
<pre><code>public class BoyFriend {
    @Max(groups = BoyFriendCreate.class, value = 85)
    @Max(groups = BoyFriendUpdate.class, value = 100)
    private Integer weight;
}
</code></pre> 
<ul><li>给Controller方法添加分组</li></ul> 
<p>先给Controller类添加<code>@Validated</code>，然后给方法添加带有分组信息的<code>@Validated</code></p> 
<pre><code>    @Validated(BoyFriendUpdate.class)
    @PatchMapping("/boy-friends")
    public ResponseEntity&lt;BoyFriend&gt; updateBoyFriend(@Valid @RequestBody BoyFriend boy) {
        return ResponseEntity.ok(boy);
    }
</code></pre> 
<p>注意，这种方法被认为是<strong>反模式</strong>的，因为其将代码耦合在了一起。本来创建和更新应该是两个不同的类，现在我们却将其耦合在了一起，通过一个分组的信息来区分</p> 
<h3><a id="_255"></a>自定义约束注解</h3> 
<p>这是最后一招拉，每当框架提供的不能满足我们的需求时，我们就需要按照自己的需求自定义了，每个优秀的框架和类库都提供了这种能力</p> 
<p>假设牛翠华对男朋友要求非常之高，要求必须是指定的某些人，例如王思聪，马化腾…，当然这个需求可以使用<code>@Pattern</code>然后写正则表达式来实现，不过我们这里为了演示就写一个自定义的约束注解来实现。</p> 
<ul><li>定义一个约束注解</li></ul> 
<p>我们自定义一个注解<code>@Target</code>，前三个属性都是必须的，最后一个value是我们自己的，我们用它来保存目标的名称。</p> 
<pre><code>@Documented
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = TargetManValidator.class)
public @interface TargetMan {
    String message() default "错误的人";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};

    String[] value() default {};
}
</code></pre> 
<p>可以看到我们使用了<code>@Constraint(validatedBy = TargetManValidator.class)</code>来标记<code>@TargerMan</code>注解，所以我们还需要实现一个<code>TargetManValidator</code>。</p> 
<ul><li>实现一个<code>TargetManValidator</code></li></ul> 
<p>具体的验证逻辑就是在这个类里面的。</p> 
<pre><code>public class TargetManValidator implements ConstraintValidator&lt;TargetMan,String&gt; {
    private List&lt;String&gt; values = new ArrayList&lt;&gt;();
    
    @Override
    public void initialize(TargetMan constraintAnnotation) {
       //从TargetMan 注解中获取用户设置的姓名列表
       values = Arrays.stream(constraintAnnotation.value()).collect(Collectors.toList());
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        return values.contains(value);
    }
}
</code></pre> 
<p>我们的验证逻辑就在<code>isValid</code>方法中，如果用户输入的姓名不在设置的姓名集合之中就返回FALSE。</p> 
<ul><li>使用</li></ul> 
<pre><code>public class BoyFriend {
    @NotBlank
    @TargetMan({"马化腾", "王思聪", "王二狗"})
    private String name;
}
</code></pre> 
<h3><a id="JPA_Entity_314"></a>JPA Entity验证</h3> 
<p>你自己加几个约束注解试试…</p> 
<h2><a id="_318"></a>概述</h2> 
<p>今天就到这啦，希望小朋友们都学头秃了… 对了，最后牛翠华嫁给了王二狗，至少都姓王，O(∩_∩)O哈哈~ 。</p> 
<p>我在此为牛翠华正名：说翠花打拳只是为行文方便，翠花是一个温婉贤良，上孝下敬的好女子…</p> 
<h2><a id="_324"></a>源码</h2> 
<p>一如既往，你可以在首发找到本文源码：<a href="https://shusheng007.top/2023/03/25/validation/" rel="nofollow">秒懂SpringBoot参数验证全解析(@Validated与@Valid)</a>，小星星点一点，需要的时候方便找的到。</p> 
<p>参考文章：<a href="https://reflectoring.io/bean-validation-with-spring-boot/" rel="nofollow">Validation with Spring Boot - the Complete Guide</a></p> 
<h2><a id="_329"></a>题外话</h2> 
<p>最近小区物业群里警察叔叔经常发送辖区被电信诈骗的案例。我从头到尾只有两个感觉，一个是这些人怎么这么有钱？二是这些人怎么这么傻？基本上老人妇女死于刷单理财，壮男死于约炮…。我觉得要是骗我估计有点困难，不是我聪明主要人到中年一没钱，而没啥兴趣，骗子都绕着走啊，o(<em>￣︶￣</em>)o…</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/47908f4d2844cc5673931b03b966759d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PCB模块化设计19——光口模块PCB布局布线设计规范</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fe4ae90c47163f4fe243ec2d2a1ae929/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Docker搭建Hadoop集群</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>