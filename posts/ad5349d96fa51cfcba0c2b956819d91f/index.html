<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis 基础 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis 基础" />
<meta property="og:description" content="文章目录 1. redis初识1.1 Redis是什么1.2 Redis特性1.3 Redis单机安装1.4 卸载流程1.5 服务端三种启动方式1.6 客户端连接 2. 通用命令3. 数据类型命令3.1 字符串命令3.2 列表命令3.3 哈希命令3.4 集合命令3.5 有序集合命令 4. 慢查询4.1 默认配置4.2 修改配置4.3 慢查询队列相关命令 5. 发布订阅5.1 订阅相关命令5.2 实例 6. Bitmap 位图6.1 位图应用原理6.2 位图常用命令 1. redis初识 1.1 Redis是什么 Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区
是一个 cs 架构的开源软件非关系型（没有外键关联关系）数据库数据都放在内存中(读写速度超级快，每秒的 qps 10w)以 key-value 形式存储有5大数据类型（字符串，list，hash，集合，有序集合）
好处 Redis典型使用场景
缓存系统：使用最广泛的就是缓存 计数器：网站访问量，转发量，评论数（文章转发，商品销量，单线程模型，不会出现并发问题） 消息队列：发布订阅，阻塞队列实现（简单的分布式，blpop：阻塞队列，生产者消费者） 排行榜：有序集合（阅读排行，点赞排行，推荐（销量高的，推荐）） 社交网络：很多特效跟社交网络匹配，粉丝数，关注数 实时系统：垃圾邮件处理系统，布隆过滤器 1.2 Redis特性 速度快：10w ops（每秒10w读写），数据存在内存中，c语言实现，单线程模型
持久化：rdb 和 aof
5大数据结构
BitMaps位图：布隆过滤器 本质是 字符串
HyperLogLog：超小内存唯一值计数，12kb HyperLogLog 本质是 字符串
GEO：地理信息定位 本质是有序集合" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ad5349d96fa51cfcba0c2b956819d91f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-26T16:49:58+08:00" />
<meta property="article:modified_time" content="2022-08-26T16:49:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis 基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1_redis_1" rel="nofollow">1. redis初识</a></li><li><ul><li><a href="#11_Redis_2" rel="nofollow">1.1 Redis是什么</a></li><li><a href="#12_Redis_23" rel="nofollow">1.2 Redis特性</a></li><li><a href="#13_Redis_49" rel="nofollow">1.3 Redis单机安装</a></li><li><a href="#14__94" rel="nofollow">1.4 卸载流程</a></li><li><a href="#15__114" rel="nofollow">1.5 服务端三种启动方式</a></li><li><a href="#16__161" rel="nofollow">1.6 客户端连接</a></li></ul> 
   </li><li><a href="#2__179" rel="nofollow">2. 通用命令</a></li><li><a href="#3__204" rel="nofollow">3. 数据类型命令</a></li><li><ul><li><a href="#31__205" rel="nofollow">3.1 字符串命令</a></li><li><a href="#32__231" rel="nofollow">3.2 列表命令</a></li><li><a href="#33__256" rel="nofollow">3.3 哈希命令</a></li><li><a href="#34__277" rel="nofollow">3.4 集合命令</a></li><li><a href="#35__297" rel="nofollow">3.5 有序集合命令</a></li></ul> 
   </li><li><a href="#4__322" rel="nofollow">4. 慢查询</a></li><li><ul><li><a href="#41__327" rel="nofollow">4.1 默认配置</a></li><li><a href="#42__340" rel="nofollow">4.2 修改配置</a></li><li><a href="#43__356" rel="nofollow">4.3 慢查询队列相关命令</a></li></ul> 
   </li><li><a href="#5__394" rel="nofollow">5. 发布订阅</a></li><li><ul><li><a href="#51__401" rel="nofollow">5.1 订阅相关命令</a></li><li><a href="#52__418" rel="nofollow">5.2 实例</a></li></ul> 
   </li><li><a href="#6_Bitmap__454" rel="nofollow">6. Bitmap 位图</a></li><li><ul><li><a href="#61__469" rel="nofollow">6.1 位图应用原理</a></li><li><a href="#62__513" rel="nofollow">6.2 位图常用命令</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1_redis_1"></a>1. redis初识</h3> 
<h4><a id="11_Redis_2"></a>1.1 Redis是什么</h4> 
<p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持<strong>字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs</strong>等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区</p> 
<ul><li>是一个 cs 架构的开源软件</li><li>非关系型（没有外键关联关系）数据库</li><li>数据都放在内存中(读写速度超级快，每秒的 qps 10w)</li><li>以 key-value 形式存储</li><li>有5大数据类型（字符串，list，hash，集合，有序集合）<br> 好处</li></ul> 
<p><strong>Redis典型使用场景</strong></p> 
<pre><code class="prism language-python">缓存系统：使用最广泛的就是缓存
计数器：网站访问量，转发量，评论数（文章转发，商品销量，单线程模型，不会出现并发问题）
消息队列：发布订阅，阻塞队列实现（简单的分布式，blpop：阻塞队列，生产者消费者）
排行榜：有序集合（阅读排行，点赞排行，推荐（销量高的，推荐））
社交网络：很多特效跟社交网络匹配，粉丝数，关注数
实时系统：垃圾邮件处理系统，布隆过滤器
</code></pre> 
<h4><a id="12_Redis_23"></a>1.2 Redis特性</h4> 
<p>速度快：10w ops（每秒10w读写），数据存在内存中，c语言实现，单线程模型</p> 
<p>持久化：rdb 和 aof</p> 
<p><strong>5大数据结构</strong></p> 
<ul><li> <p>BitMaps位图：布隆过滤器 本质是 字符串</p> </li><li> <p>HyperLogLog：超小内存唯一值计数，12kb HyperLogLog 本质是 字符串</p> </li><li> <p>GEO：地理信息定位 本质是有序集合</p> </li></ul> 
<p>支持多种编程语言：基于tcp通信协议，各大编程语言都支持</p> 
<p>功能丰富：发布订阅（消息） Lua脚本，事务（pipeline）</p> 
<p>简单：源代码几万行，不依赖外部库</p> 
<p>主从复制：主服务器和从服务器，主服务器可以同步到从服务器中</p> 
<p>高可用和分布式：</p> 
<ul><li> <p>​ 2.8版本以后使用redis-sentinel支持高可用</p> </li><li> <p>​ 3.0版本以后支持分布式</p> </li></ul> 
<h4><a id="13_Redis_49"></a>1.3 Redis单机安装</h4> 
<ol><li><strong>下载地址</strong>：<a href="http://download.redis.io/releases/" rel="nofollow">http://download.redis.io/releases/</a></li></ol> 
<pre><code>yum install wget
wget http://download.redis.io/releases/redis-5.0.7.tar.gz
</code></pre> 
<p><img src="https://images2.imgbox.com/53/b3/hktRr1AO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/13/25/urX4Y3pe_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li><strong>解压：</strong></li></ol> 
<pre><code>tar -xzf redis-5.0.7.tar.gz
</code></pre> 
<ol start="3"><li><strong>建立软连接</strong></li></ol> 
<pre><code>ln -s redis-5.0.7 redis
</code></pre> 
<p><img src="https://images2.imgbox.com/52/f0/izt12W21_o.png" alt="在这里插入图片描述"></p> 
<ol start="4"><li><strong>编译</strong></li></ol> 
<pre><code>cd redis
make&amp;&amp;make install
</code></pre> 
<p>编译完成后在 src 里有以下内容</p> 
<p><img src="https://images2.imgbox.com/bf/63/7KmiBEpu_o.png" alt="在这里插入图片描述"></p> 
<table><thead><tr><th align="left">内容</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">redis-server</td><td align="left">redis 服务器</td></tr><tr><td align="left">redis-cli</td><td align="left">redis 命令行客户端</td></tr><tr><td align="left">redis-benchmark</td><td align="left">redis 性能测试工具</td></tr><tr><td align="left">redis-check-aof</td><td align="left">aof 文件修复工具</td></tr><tr><td align="left">redis-check-dump</td><td align="left">rdb 文件检查工具</td></tr><tr><td align="left">redis-sentinel</td><td align="left">sentinel 服务器，哨兵</td></tr></tbody></table> 
<h4><a id="14__94"></a>1.4 卸载流程</h4> 
<pre><code>1、查看redis进程；
ps aux|grep redis

2、kill掉进程；
kill 进程id

3、进入到redis目录
cd /usr/local/

4、删除redis对应的文件
rm -f /usr/local/redis/bin/redis*
rm -f /usr/local/bin/redis*

5、删除对应的文件
rm -rf redis
</code></pre> 
<h4><a id="15__114"></a>1.5 服务端三种启动方式</h4> 
<ol><li>最简启动</li></ol> 
<pre><code class="prism language-python">redis<span class="token operator">-</span>server					<span class="token comment"># 最简启动</span>
ps <span class="token operator">-</span>ef<span class="token operator">|</span>grep redis  				<span class="token comment"># 查看进程</span>

yum install net<span class="token operator">-</span>tools
netstat <span class="token operator">-</span>antpl<span class="token operator">|</span>grep redis 		<span class="token comment"># 查看端口</span>

redis<span class="token operator">-</span>cli <span class="token operator">-</span>h ip <span class="token operator">-</span>p port ping 	<span class="token comment"># 命令查看</span>
</code></pre> 
<ol start="2"><li>动态参数启动</li></ol> 
<pre><code class="prism language-python"><span class="token comment"># 动态参数启动</span>
redis<span class="token operator">-</span>serve <span class="token operator">-</span><span class="token operator">-</span>port <span class="token number">6380</span> <span class="token comment"># 启动，监听6380端口</span>
</code></pre> 
<ol start="3"><li>配置文件启动</li></ol> 
<pre><code class="prism language-python"><span class="token number">1.</span> 通过redis<span class="token operator">-</span>cli连接，输入 config get <span class="token operator">*</span> 可以获得默认配置

<span class="token number">2.</span> 在redis目录下创建 config 目录，copy 一个redis<span class="token punctuation">.</span>conf文件
   cp redis<span class="token punctuation">.</span>conf redis<span class="token operator">-</span>back<span class="token punctuation">.</span>conf
   rm <span class="token operator">-</span>rf redis<span class="token punctuation">.</span>conf

<span class="token number">3.</span> 重写配置文件
   daemonize yes 
   pidfile <span class="token operator">/</span>var<span class="token operator">/</span>run<span class="token operator">/</span>redis<span class="token punctuation">.</span>pid
   port <span class="token number">6379</span>
   <span class="token builtin">dir</span> <span class="token string">"/root/redis/data"</span>
   logfile <span class="token string">"6379.log"</span>

   <span class="token comment"># 参数说明</span>
   <span class="token comment"># daemonize 是否是守护进程启动（no|yes）</span>
   <span class="token comment"># port 端口号</span>
   <span class="token comment"># logfile redis系统日志</span>
   <span class="token comment"># dir redis工作目录</span>
   
<span class="token number">4.</span> 启动服务端   
   <span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span>redis<span class="token operator">-</span>server redis<span class="token punctuation">.</span>conf

<span class="token number">5.</span> 查看进程
   ps <span class="token operator">-</span>ef <span class="token operator">|</span>grep redis<span class="token operator">-</span>server <span class="token operator">|</span>grep <span class="token number">6379</span>

</code></pre> 
<h4><a id="16__161"></a>1.6 客户端连接</h4> 
<pre><code class="prism language-python">redis<span class="token operator">-</span>cli <span class="token operator">-</span>h <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span> <span class="token operator">-</span>p <span class="token number">6379</span>
ping <span class="token comment"># 返回PONG</span>

<span class="token comment"># 有密码的情况可以两种登陆方式</span>
<span class="token comment"># 方式一</span>
redis<span class="token operator">-</span>cli <span class="token operator">-</span>h <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span>    <span class="token operator">-</span>p <span class="token number">6370</span> <span class="token operator">-</span>a <span class="token number">123456</span>
<span class="token comment"># 方式二</span>
先登陆，再通过 auth 输入密码

<span class="token comment"># redis-cli 进入</span>
CONFIG GET <span class="token operator">*</span>   						<span class="token comment"># 一百多对建值</span>
CONFIG SET maxmemory 128M  			<span class="token comment"># 设置最大使用的内存</span>
CONFIG <span class="token builtin">set</span> requirepass <span class="token number">123456</span>  		<span class="token comment"># 设置密码</span>
CONFIG REWRITE  					<span class="token comment"># 保存到配置文件</span>
</code></pre> 
<h3><a id="2__179"></a>2. 通用命令</h3> 
<table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">keys *</td><td align="left">打印出所有key</td></tr><tr><td align="left">keys he*</td><td align="left">打印出所有以he开头的key</td></tr><tr><td align="left">keys he[h-l]</td><td align="left">打印出所有以he开头，第三个字母是h到l的范围</td></tr><tr><td align="left">keys he？</td><td align="left">三位长度，以he开头，？表示任意一位</td></tr><tr><td align="left"><strong>keys 注意点</strong></td><td align="left">keys命令一般不在生产环境中使用，生产环境key很多，时间复杂度为o(n),用scan命令</td></tr><tr><td align="left">dbsize</td><td align="left">redis内置了计数器，插入删除值该计数器会更改，所以可以在生产环境使用，时间复杂度是o(1)</td></tr><tr><td align="left">set a b</td><td align="left">设置a</td></tr><tr><td align="left">exists a</td><td align="left">查看a是否存在，存在返回1，不存在返回0</td></tr><tr><td align="left">del key</td><td align="left">时间复杂度o(1)，删除成功返回1，key不存在返回0</td></tr><tr><td align="left">expire key seconds</td><td align="left">设置过期时间，时间复杂度o(1)</td></tr><tr><td align="left">ttl name</td><td align="left">查看name还有多长时间过期</td></tr><tr><td align="left">persist name</td><td align="left">去掉name的过期时间</td></tr><tr><td align="left">type key</td><td align="left">查看key类型，返回string，时间复杂度o(1)</td></tr><tr><td align="left">info</td><td align="left">内存，cpu，主从相关</td></tr><tr><td align="left">client list</td><td align="left">正在连接的会话</td></tr><tr><td align="left">client kill ip:端口</td><td align="left">结束</td></tr><tr><td align="left">flushall</td><td align="left">清空所有</td></tr><tr><td align="left">flushdb</td><td align="left">只清空当前库</td></tr><tr><td align="left">select 数字</td><td align="left">选择某个库 总共16个库</td></tr><tr><td align="left">monitor</td><td align="left">记录操作日志，夯住</td></tr></tbody></table> 
<h3><a id="3__204"></a>3. 数据类型命令</h3> 
<h4><a id="31__205"></a>3.1 字符串命令</h4> 
<p>Redis 字符串数据类型的相关命令用于管理 redis 字符串值</p> 
<table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><font color="red"> SET key value</font></td><td align="left"><font color="red">设置指定 key 的值</font></td></tr><tr><td align="left"><font color="red"> GET key</font></td><td align="left"><font color="red">获取指定 key 的值。</font></td></tr><tr><td align="left">GETRANGE key start end</td><td align="left">返回 key 中字符串值的子字符</td></tr><tr><td align="left">GETSET key value</td><td align="left">将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td></tr><tr><td align="left">GETBIT key offset</td><td align="left">对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td></tr><tr><td align="left">MGET key1 [key2…]</td><td align="left">获取所有(一个或多个)给定 key 的值。</td></tr><tr><td align="left">SETBIT key offset value</td><td align="left">对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td></tr><tr><td align="left">SETEX key seconds value</td><td align="left">将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td></tr><tr><td align="left">SETNX key value</td><td align="left">只有在 key 不存在时设置 key 的值。</td></tr><tr><td align="left">SETRANGE key offset value</td><td align="left">用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td></tr><tr><td align="left">STRLEN key</td><td align="left">返回 key 所储存的字符串值的长度。</td></tr><tr><td align="left">MSET key value [key value …]</td><td align="left">同时设置一个或多个 key-value 对。</td></tr><tr><td align="left">MSETNX key value [key value …]</td><td align="left">同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td></tr><tr><td align="left">PSETEX key milliseconds value</td><td align="left">这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td></tr><tr><td align="left"><font color="red">INCR key</font></td><td align="left"><font color="red">将 key 中储存的数字值增一。</font></td></tr><tr><td align="left">INCRBY key increment</td><td align="left">将 key 所储存的值加上给定的增量值（increment） 。</td></tr><tr><td align="left">INCRBYFLOAT key increment</td><td align="left">将 key 所储存的值加上给定的浮点增量值（increment） 。</td></tr><tr><td align="left"><font color="red">DECR key</font></td><td align="left"><font color="red">将 key 中储存的数字值减一。</font></td></tr><tr><td align="left">DECRBY key decrement key</td><td align="left">所储存的值减去给定的减量值（decrement） 。</td></tr><tr><td align="left">APPEND key value</td><td align="left">如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。</td></tr></tbody></table> 
<h4><a id="32__231"></a>3.2 列表命令</h4> 
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）</p> 
<p>有序队列，可以从左侧添加，右侧添加，可以重复，可以从左右两边弹出</p> 
<table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><font color="red">blpop key1 [key2 ] timeout</font></td><td align="left">移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left">BRPOP key1 [key2 ] timeout</td><td align="left">移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left">BRPOPLPUSH source destination timeout</td><td align="left">从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left"><font color="red"> lindex key index</font></td><td align="left">通过索引获取列表中的元素</td></tr><tr><td align="left"><font color="red"> linsert key BEFORE|AFTER pivot value</font></td><td align="left">在列表的元素前或者后插入元素</td></tr><tr><td align="left"><font color="red">llen key</font></td><td align="left">获取列表长度</td></tr><tr><td align="left"><font color="red">lpop key</font></td><td align="left">移出并获取列表的第一个元素</td></tr><tr><td align="left"><font color="red">lpush key value1 [value2]</font></td><td align="left">将一个或多个值插入到列表头部</td></tr><tr><td align="left"><font color="red">lpushx key value</font></td><td align="left">将一个或多个值插入到已存在的列表头部</td></tr><tr><td align="left">LRANGE key start stop</td><td align="left">获取列表指定范围内的元素</td></tr><tr><td align="left">LREM key count value</td><td align="left">移除列表元素</td></tr><tr><td align="left">LSET key index value</td><td align="left">通过索引设置列表元素的值</td></tr><tr><td align="left">LTRIM key start stop</td><td align="left">对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td align="left">RPOP key</td><td align="left">移除并获取列表最后一个元素</td></tr><tr><td align="left">RPOPLPUSH source destination</td><td align="left">移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td align="left">RPUSH key value1 [value2]</td><td align="left">在列表中添加一个或多个值</td></tr><tr><td align="left">RPUSHX key value</td><td align="left">为已存在的列表添加值</td></tr></tbody></table> 
<h4><a id="33__256"></a>3.3 哈希命令</h4> 
<table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">HDEL key field2 [field2]</td><td align="left">删除一个或多个哈希表字段</td></tr><tr><td align="left">HEXISTS key field</td><td align="left">查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td align="left">HGET key field</td><td align="left">获取存储在哈希表中指定字段的值/td&gt;</td></tr><tr><td align="left">HGETALL key</td><td align="left">获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td align="left"><font color="red">HINCRBY key field increment</font></td><td align="left">为哈希表 key 中的指定字段的整数值加上增量 increment</td></tr><tr><td align="left">HINCRBYFLOAT key field increment</td><td align="left">为哈希表 key 中的指定字段的浮点数值加上增量 increment</td></tr><tr><td align="left">HKEYS key</td><td align="left">获取所有哈希表中的字段</td></tr><tr><td align="left">HLEN key</td><td align="left">获取哈希表中字段的数量</td></tr><tr><td align="left">HMGET key field1 [field2]</td><td align="left">获取所有给定字段的值</td></tr><tr><td align="left">HMSET key field1 value1 [field2 value2 ]</td><td align="left">同时将多个 field-value (域-值)对设置到哈希表 key 中。</td></tr><tr><td align="left">HSET key field value</td><td align="left">将哈希表 key 中的字段 field 的值设为 value 。</td></tr><tr><td align="left">HSETNX key field value</td><td align="left">只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td align="left">HVALS key</td><td align="left">获取哈希表中所有值</td></tr><tr><td align="left">HSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代哈希表中的键值对。</td></tr></tbody></table> 
<h4><a id="34__277"></a>3.4 集合命令</h4> 
<table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SADD key member1 [member2]</td><td align="left">向集合添加一个或多个成员</td></tr><tr><td align="left">SCARD key</td><td align="left">获取集合的成员数</td></tr><tr><td align="left">SDIFF key1 [key2]</td><td align="left">返回给定所有集合的差集</td></tr><tr><td align="left">SDIFFSTORE destination key1 [key2]</td><td align="left">返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td align="left">SINTER key1 [key2]</td><td align="left">返回给定所有集合的交集</td></tr><tr><td align="left">SINTERSTORE destination key1 [key2]</td><td align="left">返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td align="left">SISMEMBER key member</td><td align="left">判断 member 元素是否是集合 key 的成员</td></tr><tr><td align="left">SMEMBERS key</td><td align="left">返回集合中的所有成员</td></tr><tr><td align="left">SMOVE source destination member</td><td align="left">将 member 元素从 source 集合移动到 destination 集合</td></tr><tr><td align="left">SPOP key</td><td align="left">移除并返回集合中的一个随机元素</td></tr><tr><td align="left">SRANDMEMBER key [count]</td><td align="left">返回集合中一个或多个随机数</td></tr><tr><td align="left">SREM key member1 [member2]</td><td align="left">移除集合中一个或多个成员</td></tr><tr><td align="left">SUNION key1 [key2]</td><td align="left">返回所有给定集合的并集</td></tr><tr><td align="left">SUNIONSTORE destination key1 [key2]</td><td align="left">所有给定集合的并集存储在 destination 集合中</td></tr><tr><td align="left">SSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代集合中的元素</td></tr></tbody></table> 
<h4><a id="35__297"></a>3.5 有序集合命令</h4> 
<table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ZADD key score1 member1 [score2 member2]</td><td align="left">向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td align="left">ZCARD key</td><td align="left">获取有序集合的成员数</td></tr><tr><td align="left">ZCOUNT key min max</td><td align="left">计算在有序集合中指定区间分数的成员数</td></tr><tr><td align="left">ZINCRBY key increment member</td><td align="left">有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td align="left">ZINTERSTORE destination numkeys key [key …]</td><td align="left">计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td align="left">ZLEXCOUNT key min max</td><td align="left">在有序集合中计算指定字典区间内成员数量</td></tr><tr><td align="left">ZRANGE key start stop [WITHSCORES]</td><td align="left">通过索引区间返回有序集合成指定区间内的成员</td></tr><tr><td align="left">ZRANGEBYLEX key min max [LIMIT offset count]</td><td align="left">通过字典区间返回有序集合的成员</td></tr><tr><td align="left">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</td><td align="left">通过分数返回有序集合指定区间内的成员</td></tr><tr><td align="left">ZRANK key member</td><td align="left">返回有序集合中指定成员的索引</td></tr><tr><td align="left">ZREM key member [member …]</td><td align="left">移除有序集合中的一个或多个成员</td></tr><tr><td align="left">ZREMRANGEBYLEX key min max</td><td align="left">移除有序集合中给定的字典区间的所有成员</td></tr><tr><td align="left">ZREMRANGEBYRANK key start stop</td><td align="left">移除有序集合中给定的排名区间的所有成员</td></tr><tr><td align="left">ZREMRANGEBYSCORE key min max</td><td align="left">移除有序集合中给定的分数区间的所有成员</td></tr><tr><td align="left">ZREVRANGE key start stop [WITHSCORES]</td><td align="left">返回有序集中指定区间内的成员，通过索引，分数从高到底</td></tr><tr><td align="left">ZREVRANGEBYSCORE key max min [WITHSCORES]</td><td align="left">返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td align="left">ZREVRANK key member</td><td align="left">返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td align="left">ZSCORE key member</td><td align="left">返回有序集中，成员的分数值</td></tr><tr><td align="left">ZUNIONSTORE destination numkeys key [key …]</td><td align="left">计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td align="left">ZSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table> 
<h3><a id="4__322"></a>4. 慢查询</h3> 
<p>我们配置一个时间，如果查询时间超过了我们设置的时间，我们就认为这是一个慢查询</p> 
<p>慢查询是一个先进先出的队列，固定长度，保存在内存中<br> <img src="https://images2.imgbox.com/e2/2a/RWesUbTQ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="41__327"></a>4.1 默认配置</h4> 
<pre><code class="prism language-python"><span class="token comment"># 默认慢查询队列的长度</span>
config get slowlog<span class="token operator">-</span><span class="token builtin">max</span><span class="token operator">-</span><span class="token builtin">len</span><span class="token operator">=</span><span class="token number">128</span>

<span class="token comment"># 时间慢于默认的10000微秒，就记录命令</span>
Config get slowly<span class="token operator">-</span>log<span class="token operator">-</span>slower<span class="token operator">-</span>than<span class="token operator">=</span><span class="token number">10000</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/28/eb/X3aWAtAg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/52/46/QKF80oi8_o.png" alt="在这里插入图片描述" width="625" height="80"></p> 
<h4><a id="42__340"></a>4.2 修改配置</h4> 
<pre><code class="prism language-python"><span class="token comment"># 设置记录所有命令</span>
config <span class="token builtin">set</span> slowlog<span class="token operator">-</span>log<span class="token operator">-</span>slower<span class="token operator">-</span>than <span class="token number">0</span>

<span class="token comment"># 设置不记录命令</span>
config <span class="token builtin">set</span> slowlog<span class="token operator">-</span>log<span class="token operator">-</span>slower<span class="token operator">-</span>than <span class="token operator">&lt;</span><span class="token number">0</span>

<span class="token comment"># 最多记录100条</span>
config <span class="token builtin">set</span> slowlog<span class="token operator">-</span><span class="token builtin">max</span><span class="token operator">-</span><span class="token builtin">len</span> <span class="token number">100</span>

<span class="token comment"># 持久化到本地配置文件</span>
config rewrite 
</code></pre> 
<h4><a id="43__356"></a>4.3 慢查询队列相关命令</h4> 
<pre><code class="prism language-python"><span class="token comment"># 获取慢查询队列长度</span>
slowlog <span class="token builtin">len</span>

<span class="token comment"># 清空慢查询队列日志</span>
slowlog reset

<span class="token comment"># 获取慢查询队列日志</span>
slowlog get

<span class="token comment"># 获取慢查询队列日志个数</span>
slowlog get <span class="token number">10</span>

<span class="token triple-quoted-string string">"""
日志由4个属性组成：
1）日志的标识id
2）发生的时间戳
3）命令耗时
4）执行的命令和参数
"""</span>
</code></pre> 
<pre><code class="prism language-python"><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> slowlog get
<span class="token comment"># 唯一的日志标识符,只有在Redis服务器重启的时候才会重置,可以避免对日志的重复处理(比如邮件通知)</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>             
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1660984040</span>    <span class="token comment"># 被记录命令的执行时间点,以Unix时间戳格式表示</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">17</span>            <span class="token comment"># 被查询的时间,以微秒为单位</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"SLOWLOG"</span>            <span class="token comment"># 执行的命令,以数组的形式排列</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"get"</span>
   <span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"127.0.0.1:55394"</span>
   <span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">""</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/a2/99/kGqc4wI2_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5__394"></a>5. 发布订阅</h3> 
<p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p> 
<p>Redis 客户端可以订阅任意数量的频道。<br> 发布者发布了消息，所有的订阅者都可以收到，就是生产者消费者模型（后订阅了，无法获取历史消息）</p> 
<p><img src="https://images2.imgbox.com/1b/40/MSQKaiTE_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="51__401"></a>5.1 订阅相关命令</h4> 
<table><thead><tr><th align="left">命令</th><th align="left">表格</th></tr></thead><tbody><tr><td align="left">publish channel message</td><td align="left">发布命令</td></tr><tr><td align="left">publish souhu:tv “hello world”</td><td align="left">在souhu:tv频道发布一条hello world 返回订阅者个数</td></tr><tr><td align="left">subscribe [channel]</td><td align="left">订阅命令，可以订阅一个或多个</td></tr><tr><td align="left">subscribe souhu:tv</td><td align="left">订阅sohu:tv频道</td></tr><tr><td align="left">unsubscribe [channel]</td><td align="left">取消订阅一个或多个频道</td></tr><tr><td align="left">unsubscribe sohu:tv</td><td align="left">取消订阅sohu:tv频道</td></tr><tr><td align="left">psubscribe [pattern…]</td><td align="left">订阅模式匹配</td></tr><tr><td align="left">psubscribe c*</td><td align="left">订阅以c开头的频道</td></tr><tr><td align="left">unpsubscribe [pattern…]</td><td align="left">按模式退订指定频道</td></tr><tr><td align="left">pubsub channels</td><td align="left">列出至少有一个订阅者的频道,列出活跃的频道</td></tr><tr><td align="left">pubsub numsub [channel…]</td><td align="left">列出给定频道的订阅者数量</td></tr><tr><td align="left">pubsub numpat</td><td align="left">列出被订阅模式的数量</td></tr></tbody></table> 
<h4><a id="52__418"></a>5.2 实例</h4> 
<p><img src="https://images2.imgbox.com/79/ab/POtbE43w_o.png" alt="在这里插入图片描述"></p> 
<p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat:</p> 
<pre><code class="prism language-python">redis <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> SUBSCRIBE redisChat
 
Reading messages<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span>press Ctrl<span class="token operator">-</span>C to quit<span class="token punctuation">)</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"subscribe"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"redisChat"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre> 
<p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p> 
<pre><code class="prism language-python">redis <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> PUBLISH redisChat <span class="token string">"Redis is a great caching technique"</span>
 
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
 
redis <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> PUBLISH redisChat <span class="token string">"Learn redis by w3cschool.cc"</span>
 
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
 

<span class="token comment"># 订阅者的客户端会显示如下消息</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"message"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"redisChat"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"Redis is a great caching technique"</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"message"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"redisChat"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"Learn redis by w3cschool.cc"</span>

</code></pre> 
<h3><a id="6_Bitmap__454"></a>6. Bitmap 位图</h3> 
<p>在平时开发过程中，经常会有一些 bool 类型数据需要存取。比如记录用户一年内签到的次数，签了是 1，没签是 0。如果使用 key-value 来存储，那么每个用户都要记录 365 次，当用户成百上亿时，需要的存储空间将非常巨大。为了解决这个问题，Redis 提供了位图结构。</p> 
<p>位图（bitmap）同样属于 string 数据类型。Redis 中一个字符串类型的值最多能存储 512 MB 的内容，每个字符串由多个字节组成，每个字节又由 8 个 Bit 位组成。位图结构正是使用“位”来实现存储的，它通过将比特位设置为 0 或 1来达到数据存取的目的，这大大增加了 value 存储数量，它存储上限为2^32</p> 
<p>位图本质上就是一个普通的字节串，也就是 bytes 数组。您可以使用getbit/setbit命令来处理这个位数组，位图的结构如下所示:</p> 
<p><img src="https://images2.imgbox.com/cb/84/ffM3euTe_o.png" alt="在这里插入图片描述"></p> 
<p>位图适用于一些特定的应用场景，比如用户签到次数、或者登录次数等。上图是表示一位用户 10 天内来网站的签到次数，1 代表签到，0 代表未签到，这样可以很轻松地统计出用户的活跃程度。相比于直接使用字符串而言，位图中的每一条记录仅占用一个 bit 位，从而大大降低了内存空间使用率。</p> 
<p>Redis 官方也做了一个实验，他们模拟了一个拥有 1 亿 2 千 8 百万用户的系统，然后使用 Redis 的位图来统计“日均用户数量”，最终所用时间的约为 50ms，且仅仅占用 16 MB内存。</p> 
<p><img src="https://images2.imgbox.com/ee/0e/z458NMJb_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="61__469"></a>6.1 位图应用原理</h4> 
<p>某网站要统计一个用户一年的签到记录，若用 sring 类型存储，则需要 365 个键值对。若使用位图存储，用户签到就存 1，否则存 0。最后会生成 11010101… 这样的存储结果，其中每天的记录只占一位，一年就是 365 位，约为 46 个字节。如果只想统计用户签到的天数，那么统计 1 的个数即可。</p> 
<p>位图操作的优势，相比于字符串而言，它不仅效率高，而且还非常的节省空间。</p> 
<p>Redis 的位数组是自动扩展的，如果设置了某个偏移位置超出了现有的内容范围，位数组就会自动扩充。</p> 
<p>下面设置一个名为 a 的 key，我们对这个 key 进行位图操作，使得 a 的对应的 value 变为“he”。</p> 
<p>首先我们分别获取字符“h”和字符“e”的八位二进制码，如下所示：</p> 
<pre><code class="prism language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token builtin">bin</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'0b1101000'</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token builtin">bin</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">"e"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'0b1100101'</span>
</code></pre> 
<p>接下来，只要对需值为 1 的位进行操作即可。如下图所示：</p> 
<p><img src="https://images2.imgbox.com/fc/85/yljdtvxY_o.png" alt="在这里插入图片描述"></p> 
<p>把 h 和 e 的二进制码连接在一起，第一位的下标是 0，依次递增至 15，然后将数字为 1 的位置标记出来，得到 1/2/4/9/10/13/15，我们把这组数字称为位的“偏置数”，最后按照上述偏置数对字符 a 进行如下位图操作。注意，key 的初始二进制位全部为 0。</p> 
<pre><code class="prism language-python">C<span class="token punctuation">:</span>\Users\Administrator<span class="token operator">&gt;</span>redis<span class="token operator">-</span>cli
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> SETBIT a <span class="token number">1</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> SETBIT a <span class="token number">2</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> SETBIT a <span class="token number">4</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> get hello
<span class="token string">"h"</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> SETBIT a <span class="token number">9</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> SETBIT a <span class="token number">10</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> SETBIT a <span class="token number">13</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> SETBIT a <span class="token number">15</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> get hello
<span class="token string">"he"</span>
</code></pre> 
<h4><a id="62__513"></a>6.2 位图常用命令</h4> 
<ol><li><strong>SETBIT</strong>命令</li></ol> 
<p>用来设置或者清除某一位上的值，其返回值是原来位上存储的值。key 在初始状态下所有的位都为 0 ，语法格式如下：</p> 
<pre><code class="prism language-python">SETBIT key offset value
</code></pre> 
<p>其中 offset 表示偏移量，从 0 开始。示例如下：</p> 
<pre><code class="prism language-python"><span class="token builtin">set</span> hello big <span class="token comment">#放入key位hello 值为big的字符串</span>
getbit hello <span class="token number">0</span> <span class="token comment">#取位图的第0个位置，返回0</span>
getbit hello <span class="token number">1</span> <span class="token comment">#取位图的第1个位置，返回1 如上图</span>

<span class="token comment">##我们可以直接操纵位</span>
setbit key offset value <span class="token comment">#给位图指定索引设置值</span>
setbit hello <span class="token number">7</span> <span class="token number">1</span> <span class="token comment">#把hello的第7个位置设为1 这样，big就变成了cig</span>

setbit test <span class="token number">50</span> <span class="token number">1</span> <span class="token comment">#test不存在，在key为test的value的第50位设为1，那其他位都以0补</span>

bitcount key <span class="token punctuation">[</span>start end<span class="token punctuation">]</span> <span class="token comment">#获取位图指定范围(start到end,单位为字节,注意按字节一个字节8个bit为，如果不指定就是获取全部)位值为1的个数</span>

bitop op destkey key <span class="token punctuation">[</span>key<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token comment">#做多个Bitmap的and(交集)/or(并集)/not(非)/xor(异或)，操作并将结果保存在destkey中 </span>
bitop <span class="token keyword">and</span> after_lqz lqz lqz2 <span class="token comment">#把lqz和lqz2按位与操作，放到after_lqz中</span>

bitpos key targetBit start end <span class="token comment">#计算位图指定范围(start到end，单位为字节，如果不指定是获取全部)第一个偏移量对应的值等于targetBit的位置</span>
bitpos lqz <span class="token number">1</span> <span class="token comment">#big 对应位图中第一个1的位置，在第二个位置上，由于从0开始返回1</span>
bitpos lqz <span class="token number">0</span> <span class="token comment">#big 对应位图中第一个0的位置，在第一个位置上，由于从0开始返回0</span>
bitpos lqz <span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token comment">#返回9：返回从第一个字节到第二个字节之间 第一个1的位置，看上图，为9</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1136e206e870944d4b1c2f657e0dd335/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;编程规范：头文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d1e3e59bb2e796d27d41800311381fda/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android Adb命令(1) - 查看所有的Apk包 / 安装install 和卸载uninstall</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>