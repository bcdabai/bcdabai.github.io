<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java IO流基础 万字详解（从拷贝文件到模拟上传头像） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java IO流基础 万字详解（从拷贝文件到模拟上传头像）" />
<meta property="og:description" content="目录
一、前言：
二、IO流简介：
1.什么是IO流？
2.IO流能干什么？
3.IO流的分类：
4.IO流体系： 三、字符流读写文件：
1.普通字符流读取文件：
前言: ①以单个字符读取: 代码演示（耐心全部看完！）:
②以字符数组读取： 代码演示:
2.普通字符流写入文件： ①按单个字符写入：
代码演示：
②按字符数组写入：
代码演示：
③按字符串写入：
代码演示：
3.字符流拷贝文件:
前言:
IO流拷贝的核心六部曲（全文背诵！）：
①以单个字符拷贝：
代码演示:
②以字符数组拷贝： 代码演示:
4.字符缓冲流（高效字符流）:
①字符缓冲流介绍:
②字符缓冲流的普通用法：
代码演示:
③字符缓冲流的特有用法：
代码演示: 四、字节流读写文件：
1.前言：
2.普通字节流用法：
①一次读写一个字节数组: 代码演示：
3.高效字节流用法：
①前言
②write重载方法：
代码演示:
五、IO流模拟上传头像系统：
六、完结撒❀
一、前言： 大家好，今天给大家带来一篇详解Java IO流基础的博文，也是我们“API——常用工具”专题——IO流篇章的最后一篇博文（异常基础 --&gt; File类 --&gt; IO流基础）。up会从字符流读写文件，字节流读写文件，高效字符流拷贝文件，以及高效字节流拷贝图片等几个方面一一进行代码演示，以帮助大家查缺补漏，快速上手Java IO流。注意事项 : ①代码中的注释也很重要。②不要眼高手低，自己跟着过一遍才真正有收获。③点击侧边栏目录或者文章开头的目录可以跳转。良工不示人以朴，up所有文章都会适时补充完善。感谢阅读！ 二、IO流简介： 1.什么是IO流？ 流是一种抽象概念，它代表了数据的无结构化传递。按照流的方式进行输入输出，数据被当成无结构的字节序列或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入输出的，即数据像流体一样连绵不绝进行传输。
I 即Input，输入。O 即Output，输出。
2.IO流能干什么？ IO流可以在本地磁盘和网络上对数据进行传输，比如说，字符流可以向一个空的文本文件中写入数据，或是从一个未知文本文件中读取数据，还可以进行文件的拷贝。而字节流则常用于拷贝图片。
3.IO流的分类： 关于IO流的分类，up认为一张图片便可清晰直观地解释，如图：
4.IO流体系： 不多bb，还是直接上图片！如图：
首先是字符流：
再来看一下字符流的类图，如下 : 然后是字节流：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d5a8ebe86109bc5a4ecac3f76c902e48/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-20T16:37:10+08:00" />
<meta property="article:modified_time" content="2023-12-20T16:37:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java IO流基础 万字详解（从拷贝文件到模拟上传头像）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">一、前言：</a></p> 
<p id="%E4%BA%8C%E3%80%81IO%E6%B5%81%E7%AE%80%E4%BB%8B%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81IO%E6%B5%81%E7%AE%80%E4%BB%8B%EF%BC%9A" rel="nofollow">二、IO流简介：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E4%BB%80%E4%B9%88%E6%98%AFIO%E6%B5%81%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E4%BB%80%E4%B9%88%E6%98%AFIO%E6%B5%81%EF%BC%9F" rel="nofollow">        1.什么是IO流？</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.IO%E6%B5%81%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.IO%E6%B5%81%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">        2.IO流能干什么？</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A" rel="nofollow">        3.IO流的分类：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.IO%E6%B5%81%E4%BD%93%E7%B3%BB%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.IO%E6%B5%81%E4%BD%93%E7%B3%BB%EF%BC%9A%C2%A0" rel="nofollow">        4.IO流体系： </a></p> 
<p id="%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%EF%BC%9A" rel="nofollow">三、字符流读写文件：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%EF%BC%9A%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%EF%BC%9A%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0" rel="nofollow">        1.普通字符流读取文件：</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E8%A8%80%3A%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E8%A8%80%3A%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0" rel="nofollow">                前言:         </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E6%8C%89%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%8F%96%3A%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E6%8C%89%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%8F%96%3A%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0" rel="nofollow">                ①以单个字符读取:       </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A" rel="nofollow">                代码演示（耐心全部看完！）:</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E4%BB%A5%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E8%AF%BB%E5%8F%96%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E4%BB%A5%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E8%AF%BB%E5%8F%96%EF%BC%9A%C2%A0" rel="nofollow">                ②以字符数组读取： </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A" rel="nofollow">                代码演示:</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6%E6%B5%81%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6%E6%B5%81%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%EF%BC%9A%C2%A0" rel="nofollow">        2.普通字符流写入文件： </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E6%8C%89%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%86%99%E5%85%A5%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E6%8C%89%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%86%99%E5%85%A5%EF%BC%9A" rel="nofollow">                ①按单个字符写入：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A" rel="nofollow">                代码演示：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E6%8C%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%86%99%E5%85%A5%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E6%8C%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%86%99%E5%85%A5%EF%BC%9A" rel="nofollow">                ②按字符数组写入：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A" rel="nofollow">                代码演示：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A2%E6%8C%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%99%E5%85%A5%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A2%E6%8C%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%99%E5%85%A5%EF%BC%9A" rel="nofollow">                ③按字符串写入：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A" rel="nofollow">                代码演示：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E5%AD%97%E7%AC%A6%E6%B5%81%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%3A-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E5%AD%97%E7%AC%A6%E6%B5%81%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%3A" rel="nofollow">        3.字符流拷贝文件:</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%89%8D%E8%A8%80%3A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%89%8D%E8%A8%80%3A" rel="nofollow">                前言:</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20IO%E6%B5%81%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A0%B8%E5%BF%83%E5%85%AD%E9%83%A8%E6%9B%B2%EF%BC%88%E5%85%A8%E6%96%87%E8%83%8C%E8%AF%B5%EF%BC%81%EF%BC%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20IO%E6%B5%81%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A0%B8%E5%BF%83%E5%85%AD%E9%83%A8%E6%9B%B2%EF%BC%88%E5%85%A8%E6%96%87%E8%83%8C%E8%AF%B5%EF%BC%81%EF%BC%89%EF%BC%9A" rel="nofollow">                IO流拷贝的核心六部曲（全文背诵！）：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E4%BB%A5%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E6%8B%B7%E8%B4%9D%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E4%BB%A5%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E6%8B%B7%E8%B4%9D%EF%BC%9A" rel="nofollow">                ①以单个字符拷贝：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A" rel="nofollow">                代码演示:</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E4%BB%A5%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E4%BB%A5%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D%EF%BC%9A%C2%A0" rel="nofollow">                ②以字符数组拷贝： </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A" rel="nofollow">                代码演示:</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%EF%BC%88%E9%AB%98%E6%95%88%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89%3A-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%EF%BC%88%E9%AB%98%E6%95%88%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89%3A" rel="nofollow">        4.字符缓冲流（高效字符流）:</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E4%BB%8B%E7%BB%8D%3A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E4%BB%8B%E7%BB%8D%3A" rel="nofollow">                ①字符缓冲流介绍:</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E6%99%AE%E9%80%9A%E7%94%A8%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E6%99%AE%E9%80%9A%E7%94%A8%E6%B3%95%EF%BC%9A" rel="nofollow">                ②字符缓冲流的普通用法：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A" rel="nofollow">                代码演示:</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A2%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E7%89%B9%E6%9C%89%E7%94%A8%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A2%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E7%89%B9%E6%9C%89%E7%94%A8%E6%B3%95%EF%BC%9A" rel="nofollow">                ③字符缓冲流的特有用法：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A%C2%A0" rel="nofollow">                代码演示: </a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%EF%BC%9A" rel="nofollow">四、字节流读写文件：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">        1.前言：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E6%99%AE%E9%80%9A%E5%AD%97%E8%8A%82%E6%B5%81%E7%94%A8%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E6%99%AE%E9%80%9A%E5%AD%97%E8%8A%82%E6%B5%81%E7%94%A8%E6%B3%95%EF%BC%9A" rel="nofollow">        2.普通字节流用法：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%3A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%3A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0" rel="nofollow">                ①一次读写一个字节数组:            </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A" rel="nofollow">                代码演示：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E9%AB%98%E6%95%88%E5%AD%97%E8%8A%82%E6%B5%81%E7%94%A8%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E9%AB%98%E6%95%88%E5%AD%97%E8%8A%82%E6%B5%81%E7%94%A8%E6%B3%95%EF%BC%9A" rel="nofollow">        3.高效字节流用法：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E5%89%8D%E8%A8%80-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E5%89%8D%E8%A8%80" rel="nofollow">                ①前言</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%E2%91%A1write%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%E2%91%A1write%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">                ②write重载方法：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A" rel="nofollow">                代码演示:</a></p> 
<p id="%E4%BA%94%E3%80%81IO%E6%B5%81%E6%A8%A1%E6%8B%9F%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F%E7%B3%BB%E7%BB%9F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81IO%E6%B5%81%E6%A8%A1%E6%8B%9F%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F%E7%B3%BB%E7%BB%9F%EF%BC%9A" rel="nofollow">五、IO流模拟上传头像系统：</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%AE%8C%E7%BB%93%E6%92%92%E2%9D%80%20%2B%20%E7%BB%99%E8%87%AA%E5%B7%B1%E6%89%93%E5%B9%BF%E5%91%8A%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%AE%8C%E7%BB%93%E6%92%92%E2%9D%80%20%2B%20%E7%BB%99%E8%87%AA%E5%B7%B1%E6%89%93%E5%B9%BF%E5%91%8A%EF%BC%9A" rel="nofollow">六、完结撒❀</a></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80%EF%BC%9A">一、前言：</h2> 
<blockquote> 
 <ul><li>大家好，今天给大家带来一篇<span style="color:#fe2c24;"><strong>详解Java IO流基础</strong></span>的博文，也是我们“<span style="color:#0d0016;"><strong>API——常用工具</strong></span>”专题——<span style="color:#0d0016;"><strong>IO流篇章</strong></span>的最后一篇博文（<a class="link-info" href="https://blog.csdn.net/TYRA9/article/details/127295364" title="异常基础">异常基础</a> --&gt; <a class="link-info" href="https://blog.csdn.net/TYRA9/article/details/127541155" title="File类">File类</a> --&gt; IO流基础）。up会从<span style="color:#1c7331;"><strong>字符流读写文件，字节流读写文件，高效字符流拷贝文件，以及高效字节流拷贝图片等几个方面一一进行代码演示</strong></span>，以帮助大家查缺补漏，快速上手Java IO流。</li><li><span style="color:#be191c;"><strong>注意事项 : ①</strong></span>代码中的注释也很重要。<span style="color:#be191c;"><strong>②</strong></span>不要眼高手低，自己跟着过一遍才真正有收获。<span style="color:#be191c;"><strong>③</strong></span>点击侧边栏目录或者文章开头的目录可以跳转。</li><li>良工不示人以朴，up所有文章都会适时补充完善。<span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;">感谢阅读！</span></strong></span></li></ul> 
</blockquote> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81IO%E6%B5%81%E7%AE%80%E4%BB%8B%EF%BC%9A" style="background-color:transparent;">二、IO流简介：</h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E4%BB%80%E4%B9%88%E6%98%AFIO%E6%B5%81%EF%BC%9F">        1.什么是IO流？</h3> 
<p>        流是一种抽象概念，它代表了数据的无结构化传递。<strong><span style="background-color:#fefcd8;">按照流的方式进行输入输出，数据被当成无结构的字节序列或字符序列</span></strong>。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，<span style="color:#956fe7;"><strong>IO流就是以流的方式进行输入输出的，即数据像流体一样连绵不绝进行传输</strong>。</span></p> 
<p>        <span style="color:#fe2c24;"><strong>I 即Input，输入。O 即Output，输出。</strong></span></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.IO%E6%B5%81%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F">        2.IO流能干什么？</h3> 
<p>      <strong>  IO流可以在本地磁盘和网络上对数据进行传输</strong>，比如说，字符流可以向一个空的文本文件中写入数据，或是从一个未知文本文件中读取数据，还可以进行文件的拷贝。而字节流则常用于拷贝图片。</p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A">        3.IO流的分类：</h3> 
<p>        关于IO流的分类，up认为一张<strong>图片</strong>便可<strong>清晰直观</strong>地解释，如图：</p> 
<p class="img-center"><img alt="" height="585" src="https://images2.imgbox.com/82/d7/mw4rcAUg_o.png" width="1200"></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.IO%E6%B5%81%E4%BD%93%E7%B3%BB%EF%BC%9A%C2%A0">        4.IO流体系： </h3> 
<p>        不多bb，还是<strong>直接上图片</strong>！如图：</p> 
<p>        首先是<strong>字符流：</strong></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/04/2e/Rr31CGGc_o.png" width="994"></p> 
<p>        再来看一下<strong>字符流的类图，如下 :</strong> </p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/06/99/vbEtePsv_o.png" width="1200"></p> 
<p>        然后是<strong>字节流：</strong></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/cb/f1/PxSNYqdZ_o.png" width="970"></p> 
<p>        再来看一下<strong>字节流的类图，如下 : </strong></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/e8/f4/i8bnSvTe_o.png" width="1200"></p> 
<hr> 
<h2 id="%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%EF%BC%9A" style="background-color:transparent;">三、字符流读写文件：</h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%EF%BC%9A%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0">        1.普通字符流读取文件：</h3> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E8%A8%80%3A%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0">                前言:         </h4> 
<p>                <strong>使用<span style="color:#956fe7;">普通字符流</span>来读取文件（FileReader）时，共有两种方式</strong>，分别是<strong>①</strong>以单个字符读取，<strong>②</strong>以字符数组读取，<span style="background-color:#ffd900;">两种方式大同小异，因此up会重点把第一种详细讲好</span>，第二种就没那么难了。<br>                 <strong>使用<span style="color:#956fe7;">普通字符流</span>来写入文件（FileWriter）时，一共有三种方式</strong>，分别是<strong>①</strong>以单个字符写入，<strong>②</strong>以字符数组写入，<strong>③</strong>以字符串形式写入，同样，三种方式大同小异，up<span style="background-color:#ffd900;">还是重点讲解第一种方式</span>。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E6%8C%89%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%8F%96%3A%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0">                ①以单个字符读取:       </h4> 
<p>               <span style="color:#956fe7;"><strong> 步骤:</strong></span></p> 
<p>               <strong> 1)</strong> 创建字符输入流对象，关联数据源文件 (<strong>建议第一步就<span style="color:#fe2c24;">抛出父类异常IOException</span></strong>)</p> 
<p>               <strong> 2)</strong> 定义变量，记录读取到的内容</p> 
<p>               <strong> 3)</strong> 循环读取，只要条件满足就一直读，并将读取到的内容赋值给变量</p> 
<p>               <strong> 4)</strong> 释放资源。（为防止遗忘，最好先释放资源。）</p> 
<p>               <span style="color:#956fe7;"><strong> 读取方法：</strong></span></p> 
<p><strong><span style="color:#956fe7;">               </span></strong><strong><span style="color:#956fe7;"> </span></strong>需要<strong>调用Reader类中的read() </strong>方法：<br><strong>                int read(): 每次读取一个字符，返回该字符对应的ASCII码值(整数)， 若达到流的末尾，返回-1。</strong>如果有对ASCII码相关知识不了解的话，可以参考up之前写的博文：(见链接博文的第三点，链接如下)</p> 
<p><a class="link-info" href="https://blog.csdn.net/TYRA9/article/details/127197213" title="https://blog.csdn.net/TYRA9/article/details/127197213">https://blog.csdn.net/TYRA9/article/details/127197213</a></p> 
<p>                <span style="color:#fe2c24;"><strong>由于Reader类是抽象类，因此需要多态的方式来实例化其子类</strong></span>。Reader类的常用子类是FileReader类。其构造方法为:<br><strong>                public FileReader(String pathName)</strong> 需要<span style="background-color:#ffd900;">传入</span><strong><span style="background-color:#ffd900;">要读取文件</span></strong><span style="background-color:#ffd900;">的</span><strong><span style="background-color:#ffd900;">路径的字符串形式</span></strong>，来获取字符输入流对象。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A">                代码演示（耐心全部看完！）:</h4> 
<p>                在代码演示前，先声明一点，因为我们现在要以单个字符的形式去读取文件，所以首先我们要有一个能读取的文件！<br>                <span style="color:#956fe7;"><strong> eg（演示）</strong></span>：up在D：/JAVA/ IDEA/ file文件夹下创建了一个1.txt文件，注意路径没必要和我一样，但你一定得知道你创建的文本文件的路径（建议用绝对路径）。如图：</p> 
<p class="img-center"><img alt="" height="275" src="https://images2.imgbox.com/02/16/v5zvc8BL_o.png" width="962"></p> 
<p>                我们在1.txt文件中<strong>先写入<span style="background-color:#ffd900;">01234</span>进行测试</strong>，如图：</p> 
<p class="img-center"><img alt="" height="175" src="https://images2.imgbox.com/b9/94/pfYjzAtQ_o.png" width="659"></p> 
<p>                好的，接下来<strong>上代码，演示如何以单个字符形式读取文本文件1.txt</strong>：我们先在charactercurrent包下创建一个AsSingleCharacter类来作为演示类，如下图所示 : </p> 
<p class="img-center"><img alt="" height="225" src="https://images2.imgbox.com/8e/9b/D9XoIydF_o.png" width="284"></p> 
<p>                 AsSingleCharacter类<strong>代码如下：</strong></p> 
<pre><code class="language-java">package knowledge.iocurrent.charactercurrent;

import java.io.FileReader;
import java.io.Reader;
import java.io.IOException;//虽然IDEA会自动导包，但是小心使得万年船，别忘了导包！！！

/**
 * 字符流读数据
 *      Reader类中的方法
 *          int read():         每次读取一个字符，返回该字符对应的ASCII码值(整数)，
 *                              若达到流的末尾，返回-1
 *
*       FileReader类的构造方法
 *          public  FileReader(String pathName)
 *          ①根据传入的字符串形式的路径，获取字符输入流对象
 *          ②注意因为Reader类是抽象类，所以需要通过多态的方式来实例化它的子类。
 */
public class AsSingleCharacter {
    public static void main(String[] args) throws IOException {
    //1.创建字符输入流对象，关联数据源文件。
        Reader reader = new FileReader("D:\\JAVA\\IDEA\\file\\1.txt");

    //2.定义变量，记录读取到的内容。
        int data;
        /*
            因为不知道循环次数，所以要用while循环来实现
        */
    //3.循环读取，只要条件满足就一直读，并将读取到的内容赋值给变量
        /* 错误写法如下：
            while (r.read() != -1) {
                  int data = r.read();
                  System.out.println(data);
             }
            如果你这样写的话，每次循环开始前都会先在括号中执行read()方法,
            然后在循环体中又执行了一次read()方法，相当于每次循环执行了两次read()方法，
            必然会导致输出结果事与愿违。
        */
        /* 正确写法如下： */
        while ((data = reader.read()) != -1) {  //赋值表达式的值，就等于赋值后变量的值。
            System.out.println(data);
        }

        //4.释放资源        //为防止遗忘，最好先释放资源
        reader.close();

    }
}</code></pre> 
<p>                <strong>输出结果①_1：</strong></p> 
<p class="img-center"><img alt="" height="339" src="https://images2.imgbox.com/dc/bb/N3pZuGQK_o.png" width="613"></p> 
<p>                控制台上打印出的内容正确对应了01234的ASCII码值，48~52；<span style="color:#fe2c24;">这时候可以就要有小伙伴儿们问了，为啥我不能把01234按照它们原本的形式输出，而只能输出它们的ASCII码值呢?</span></p> 
<p>                这个问题非常容易，只需要将输出语句中System.out.println(data);改为System.out.println((char) data); 就可以了。我们来看一下输出结果:</p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/74/13/Y1DgAbLC_o.jpg" width="839"></p> 
<p>                <strong>接下来我们对1.txt中的内容进行更改</strong>：</p> 
<p class="img-center"><img alt="" height="198" src="https://images2.imgbox.com/72/59/X6WINmxN_o.png" width="729"></p> 
<p>                我们<strong>在01234后面加上了ABCDE和abcde，来测试一下它们的ASCII码值</strong>，注意先将输出语句中的（char）强制类型转化给去掉。</p> 
<p>                <strong>输出结果①_2:</strong></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/fc/a6/8gtn6CWW_o.png" width="814"></p> 
<p>                可以看到，在原来的48~52下面，又多输出了<strong>65~69 和 97~101，即A~E 和 a~e分别对应的ASCII码值</strong>。 当然我们也可以<strong><u><span style="background-color:#fefcd8;">再次把输出语句中的强制类型转化再加上</span></u></strong>，看看<strong>输出结果</strong>如何：</p> 
<p class="img-center"><img alt="" height="525" src="https://images2.imgbox.com/40/3c/xMbaEtGI_o.png" width="821"></p> 
<p>                准确输出了它们的字符形式！<br>                 注意，这时候我们可以<strong>将println改成print（即每次输出不再换行），来看看输出效果</strong>:</p> 
<p>                <strong>输出结果①_3: </strong></p> 
<p class="img-center"><img alt="" height="202" src="https://images2.imgbox.com/a8/f6/9FIkJYuv_o.png" width="906"></p> 
<p>                嗯，也符合我们预期，<span style="color:#fe2c24;">这时候可能就要有p小将（</span><span style="color:#38d8f0;"><strong>Personable小将，指风度翩翩的人</strong></span><span style="color:#fe2c24;">）出来问了：你tm输出这一堆有什么**用啊？还不如换行输出看着整洁呢?</span></p> 
<p><span style="color:#fe2c24;">                </span>别着急，重点来了，我们<strong>对1.txt文件本身先做一下手脚，如图</strong>:</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/60/f8/llwPZkFS_o.png" width="711"></p> 
<p>                我们分别<strong>在4和E后面输入一个<span style="color:#0d0016;"><u>键盘上的Enter键</u></span>，即我们平时所说的回车键</strong>。然后我们<strong>在强制类型转化的输出语句下输出</strong>.</p> 
<p>                <strong>输出结果①_4:</strong></p> 
<p class="img-center"><img alt="" height="392" src="https://images2.imgbox.com/8a/7f/XDehOtTH_o.png" width="803"></p> 
<p>                嗯，是不是整洁了许多，但是<span style="color:#fe2c24;">又有p小将（</span><span style="color:#38d8f0;"><strong>Personable小将，指风度翩翩的人</strong></span><span style="color:#fe2c24;">）要问了：你tm耍我呢，这有啥看的？快**别卖关子了，你到底要说啥</span>？</p> 
<p>                哎，别着急，<strong>现在我们再次把输出语句的<span style="background-color:#ffd900;">强制类型转换（char）给去掉</span>，并且把print语句再<span style="background-color:#ffd900;">还原成println语句</span></strong>，下面就是<u>见证奇迹的时刻（bushi）</u>。</p> 
<p>                <strong>输出结果①_5:</strong></p> 
<p class="img-center"><img alt="" height="600" src="https://images2.imgbox.com/55/a2/VdljIPWj_o.jpg" width="777"></p> 
<p>                发现没! <strong><span style="color:#fe2c24;">在ASCII码值52和69的后面，凭空出现了13和10两个没见过的ASCII码值，那么，这到底是怎么回事呢？</span></strong></p> 
<p><strong><span style="color:#fe2c24;">                </span></strong><span style="color:#0d0016;">注意，<strong><span style="background-color:#fefcd8;">52和69就是 4 和 E 分别对应的ASCII码值</span></strong>，而我们之前不正是<strong>在4 和 E后面输入了Enter键</strong>吗？所以说，多出的两个字符一定和敲下的那个回车键有关系，好奇心旺盛的小up立刻去查询了<strong>ASCII码表，如图：</strong></span></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/3f/7c/ylJVZbkd_o.jpg" width="924"></p> 
<p>                经过查询我们发现，<span style="background-color:#ffd900;">ASCII码值<strong>13</strong>和<strong>10</strong>对应的字符分别叫做<strong>Line Feed</strong>和<strong>Carriage Return</strong></span>，那么这俩是啥意思呢，我直接把XX翻译的结果给小伙伴儿们看看:</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/a3/39/T15f1jtv_o.png" width="312"></p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/31/4b/RK5YQcgV_o.png" width="277"></p> 
<p>                (<span style="color:#956fe7;"><strong>重点</strong></span>) 没错，<strong><span style="background-color:#fefcd8;">ASCII码13对应的字符Carriage Return就是回车符，而ASCII码11对应的字符Line   Feed就是换行符</span></strong>。<br>                 所以这说明什么——<strong><span style="color:#fe2c24;">我们在输入Enter键的时候，达到的效果是：先输入一个回车符\r , 然后再输入一个换行符\n</span></strong>。其实，<strong><span style="background-color:#fefcd8;">在不同操作系统中，输入Enter键所达到的效果都不一样，在Windows是'\r\n', 在Linux是'\n', 而在MacOS是'\r'</span>。</strong>这就能解释我们为什么会得到这样的输出结果了。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E4%BB%A5%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E8%AF%BB%E5%8F%96%EF%BC%9A%C2%A0">                ②以字符数组读取： </h4> 
<p>                以单个字符的形式读取文件要是会了，这个就是小菜一碟了。老规矩，还是先把步骤和读取方法给大家说一下:</p> 
<p>                <span style="color:#956fe7;"><strong>步骤:</strong></span></p> 
<p>               <strong> 1) </strong>创建字符输入流对象，关联数据源文件 (<strong>建议第一步就<span style="color:#fe2c24;">抛出父类异常IOException</span></strong>)</p> 
<p>               <strong> 2)</strong> 定义变量，记录读取到的内容</p> 
<p>              <strong>  3)</strong> 循环读取，只要条件满足就一直读，并将读取到的内容赋值给变量</p> 
<p>              <strong>  4) </strong>释放资源。（为防止遗忘，最好先释放资源。）</p> 
<p>               <span style="color:#956fe7;"><strong> 读取方法：</strong></span></p> 
<p><span style="color:#956fe7;"><strong>               </strong></span><strong>char[] charArray = new char[len];</strong>       //定义了一个初始长度为len的字符数组。</p> 
<p>               <strong>int len = reader.read(charArray)</strong>;         //<strong>该方法可以<span style="background-color:#ffd900;">读取</span>指定个数的字符<span style="background-color:#ffd900;">到</span>你所定义的<span style="background-color:#ffd900;">字符数组中</span>，然后返回读取到的<span style="color:#fe2c24;">有效字符数</span></strong>。</p> 
<h4>                代码演示:</h4> 
<p>                老规矩，我们先创建一个文本文件来模拟要读取的文件，up在<strong>D:/JAVA/IDEA/file</strong>文件夹下创建了一个2.txt文件，(大家可以自由创建，但一定要保证你能找到这个文件)，建议使用绝对路径。</p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/7b/6f/OI3p7AsI_o.png" width="813"></p> 
<p>                然后我们在2.txt文件中写入一些东西，如图，up写入了一句诗：</p> 
<p class="img-center"><img alt="" height="275" src="https://images2.imgbox.com/de/d2/ym50amaw_o.png" width="691"></p> 
<p>                然后我们在charactercurrent包下创建一个AsCharArray类，用作代码演示,如图:</p> 
<p class="img-center"><img alt="" height="240" src="https://images2.imgbox.com/16/1a/mPK5zThL_o.png" width="344"></p> 
<p>                 好的，如下是AsCharArray类的代码（<strong><span style="color:#fe2c24;">一定要认真看注释</span></strong>）:</p> 
<pre><code class="language-java">package knowledge.iocurrent.charactercurrent;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;

/**
 *  //步骤:
 *
 *  1) 创建字符输入流对象，关联数据源文件(建议第一步就抛出父类异常IOException)
 *
 *  2) 定义变量，记录读取到的内容
 *
 *  3) 循环读取，只要条件满足就一直读，并将读取到的内容赋值给变量
 *
 *  4) 释放资源。（为防止遗忘，最好先释放资源。）
 *
 *  //读取方法：
 *  char[] charArray = new char[3];   //定义了一个初始长度为3的字符数组
 *  int data = reader.read(charArray);
 *
 */

public class AsCharArray {
    public static void main(String[] args) throws FileNotFoundException, IOException {
    //1.创建字符输入流对象，关联数据源文件（建议第一步就抛出父类异常IOException）
        Reader reader = new FileReader("D:\\JAVA\\IDEA\\file\\2.txt");
    //2.定义变量，记录读取到的内容
        char[] charArray = new char[3];   //定义了一个初始长度为3 的字符数组
        int i1 = reader.read(charArray);//第一次读取
        /*
            字符串的底层，其实就是一个字符数组，所以此处会将字符数组中的内容自动拼接成字符串
         */
        System.out.println("👴看看第一次读到了些啥：");
        System.out.println(charArray);
        System.out.println("第一次读取到的有效字符数是：" + i1);     //有效字符数3
        System.out.println("--------------------------");

        int i2 = reader.read(charArray);//第二次读取
        System.out.println("👴看看第二次读到了些啥：");
        System.out.println(charArray);
        System.out.println("第二次读取到的有效字符数是：" + i2);     //有效字符数3
        System.out.println("--------------------------");

        int i3 = reader.read(charArray);//第三次读取
        System.out.println("👴看看第三次读到了些啥：");
        System.out.println(charArray);
        System.out.println("第三次读取到的有效字符数是：" + i3);     //有效字符数3
        System.out.println("--------------------------");

        int i4 = reader.read(charArray);//第四次读取
        System.out.println("👴看看第四次读到了些啥：");
        System.out.println(charArray);
        System.out.println("第四次读取到的有效字符数是：" + i4);     //有效字符数3
        System.out.println("--------------------------");

        int i5 = reader.read(charArray);//第五次读取
        System.out.println("👴看看第五次读到了些啥：");
        System.out.println(charArray);
        System.out.println("第五次读取到的有效字符数是：" + i5);     //有效字符数3
        System.out.println("--------------------------");

        int i6 = reader.read(charArray);//第六次读取
        System.out.println("👴看看第六次读到了些啥：");
        System.out.println(charArray);
        System.out.println("第六次读取到的有效字符数是：" + i6);     //有效字符数1
        System.out.println("=========================================");
        /*
                发现没有? 第六次用charArray这个数组来读时，输出结果为”。度秋“
            ，而且有效字符数是1，这说明每次3个3个的读取，其实本质是将读取到
            的内容覆盖掉数组中原本的内容。
                但因为我们创建的2.txt文本文件中，一共16个字符，16 / 3 = 5······1，
            所以第六次读取时，仅能读到最后的句号“。”这一个字符了，所以仅能覆盖掉第一个内容，
            即“几度秋”变成了“。度秋” .
         */

        /*
            用While循环优化以上代码；
        */
    //3.循环读取，只要条件满足就一直读，并将读取到的内容赋值给变量
        //定义一个变量，记录读取到的有效字符数
        //define a variable which can record the number of valid character
        int count;
        while ((count = reader.read(charArray)) != -1) {
            /**
                可以将读取到的内容转换成字符串，并打印出来，这里利用了String的一个特别构造
             * */
            String charString = new String(charArray, 0, count);
            /*
            * 该构造方法需要传入字符数组名， 起始索引， 以及有效字符数(特别注意这个有效字符数)
            * String这个构造器中三个参数的作用————
            *   ①charArray : 表示要使用的数组（用这个数组来读取内容）
            *   ②0 : 表示起始索引
            *   ③len : 表示 要操作的字符 的个数
            *     注意:如果这里只传入数组名，那么控制台上打印出的效果会和原来一样————
            *     即，当文件中的剩余字符数小于既定数组长度时，能覆盖几个覆盖几个。
            * */
            System.out.println(charString);
            System.out.println(count);
        }
        //4.释放资源// 一定要记得释放
        reader.close();
    }
}
/**
 * 总结
 *      ①利用字符输入流的r.read(字符数组);的方法按字符数组读取文件时，数组内的内容每次都会被
 *      重新覆盖(覆盖范围是既定的数组的长度) ，若剩余有效符数小于既定数组长度，则能覆盖几个覆盖几个
 *      ，剩下的还是上次覆盖的内容。
 *      ②空格对文件的影响还是很大的
 *      ③同一个字符输入流读文件对象 在读取文件时是一定的，即读到哪儿就算那儿，倘若已经读到了流的末尾，
 *      再读一遍就需要创建新的读文件对象了，这是因为当前字符流相当于已经读完了。
 */
</code></pre> 
<p>                <strong>输出结果②_1:</strong></p> 
<p class="img-center"><img alt="" height="575" src="https://images2.imgbox.com/92/ef/bZHoWrbj_o.png" width="874"></p> 
<p class="img-center"><img alt="" height="600" src="https://images2.imgbox.com/dd/97/qcBn2Le6_o.png" width="841"></p> 
<p>                <strong> 输出结果②_1解读：</strong></p> 
<p>                （<s>其实注释里说得已经很详细了，这里再说一遍就是怕有些头铁娃只看代码，不看注释。</s>）</p> 
<p>                我们先定义了一个长度为3的字符数组，也就是说每次读取最多只能读到3个字符，由于<span style="color:#fe2c24;"><strong>字符串的底层，其实就是一个字符数组，所以此处会自动将读取到的字符数组中的内容拼接成字符串</strong></span>。 我们之前在2.txt文件中输入的“闲云潭影日悠悠，物换星移几度秋。”共16个字符，所以前五次读取的结果都是返回3个有效字符，而第六次用charArray这个数组来读时，输出结果为”。度秋“ ，而且有效字符数是1，这说明<span style="color:#fe2c24;"><strong>每次3个3个的读取，其实本质是将读取到 的内容覆盖掉数组中原本的内容</strong></span>，所以第六次读取时，仅能读到最后的句号“。”这一个字符了， 所以仅能覆盖掉第一个内容，即“几度秋”变成了“。度秋” .</p> 
<p>                同理也能说明，<span style="color:#fe2c24;">为什么我们在分割线下面用了while循环来优化代码后，啥都没有读到</span>，<strong>同一个字符输入流读文件对象 在读取文件时是一定的，即读到哪儿就算那儿，倘若已经读到了流的末尾，再读一遍就需要创建新的读文件对象了</strong>，因为当前字符流相当于已经读完了。</p> 
<p>                为了不让我们写得while循环代码读了个寂寞，我们在2.txt文本文件下增加一些内容，如图：（<span style="color:#956fe7;"><strong>特别注意我们之前说过，在windows下一个Enter键相当于\r\n两个字符</strong></span>）</p> 
<p class="img-center"><img alt="" height="196" src="https://images2.imgbox.com/e9/6f/lbifXpjm_o.png" width="756"></p> 
<p>                <strong>注意</strong>，由于多加了字符，所以之前的第六次读取的  “<strong>。度秋</strong>”  就会变成  “<strong>。 </strong>” ，因为<strong><span style="background-color:#ffd900;">。</span></strong>加上<strong><span style="background-color:#ffd900;">\r\n</span></strong>就是<strong>三个字符</strong>啦😆。</p> 
<p>                <strong>输出结果②_2:</strong></p> 
<p class="img-center"><img alt="" height="600" src="https://images2.imgbox.com/b2/f0/7eeQ2OXY_o.png" width="768"></p> 
<p>                <strong>输出结果②_2解读：</strong></p> 
<p><strong>                注意看，首先是</strong>第六次的输出结果确实如我们所料，变成了“。”  其次是我们用循环读取的结果，最后一次是“。”，而不是“。自流”.  这是我们<strong>所用的String类构造器</strong>的原因，如果在String构造器中你只传入数组名，而不传入起始索引和有效字符数的话，输出结果就是“。自流”了.  如下图所示：</p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/30/eb/NLl2MQnv_o.jpg" width="1164"></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6%E6%B5%81%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%EF%BC%9A%C2%A0" style="background-color:transparent;">        2.普通字符流写入文件： </h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E6%8C%89%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%86%99%E5%85%A5%EF%BC%9A">                ①按单个字符写入：</h4> 
<p>               <span style="color:#956fe7;"><strong> 步骤：</strong></span></p> 
<p>                <strong>①</strong>创建字符输出流对象，关联目的地文件。<strong>(建议第一步就<span style="color:#fe2c24;">抛出父类异常IOException</span>)</strong></p> 
<p>                <strong>②</strong>将目标数据写入到目的地文件中。</p> 
<p>                <strong>③</strong>释放资源       </p> 
<p>               <span style="color:#956fe7;"><strong> 写入方法:</strong></span></p> 
<p>                <strong><span style="background-color:#fefcd8;">需要调用Writer类中的 void write(int ch) 方法，该方法返回值为void类型</span></strong>，因此不需要作接收，使用该方法需要传入一个字符(别忘了加单引号) ，达到的效果就是可以一次写入一个字符。<span style="color:#fe2c24;"><strong>因为Writer类是抽象类，所以我们仍要使用多态的方式初始化它的子类</strong></span>。</p> 
<p>                Writer类的常用子类是FileWriter类。<strong>其构造方法为:</strong><br>                <strong><span style="background-color:#fefcd8;"> public FileWriter(String pathname) </span></strong>,该构造器需要传入<strong>目的地文件</strong>的<strong>路径</strong>的<strong>字符串形式</strong>，以获取字符输出流对象。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A">                代码演示：</h4> 
<p>                老规矩，我们先创建一个空的文本文件来模拟要写入的文件，up在D:/JAVA/IDEA/file文件夹下创建了一个3.txt文件，（自由创建，但一定要保证你能找到这个文件），<strong>建议用绝对路径</strong>。如图：</p> 
<p class="img-center"><img alt="" height="401" src="https://images2.imgbox.com/b7/ea/7w7Br5uy_o.png" width="958"></p> 
<p>                然后我们看一下3.txt中的内容，一开始就是空的，如图:</p> 
<p class="img-center"><img alt="" height="173" src="https://images2.imgbox.com/d0/ae/NvPD4H1k_o.png" width="752"></p> 
<p>                俗话说的好：“<strong>地上种了菜，就不易长草；心中有善，就不易生恶</strong>” 。我们赶紧想办法给它写入点东西，直接输进去多普通啊，咱好歹是个程序猿，得，IO输出流直接搞定。</p> 
<p>                我们现在<strong>在charactercurrent包下，创建一个WriteData1类用作演示类</strong>，<strong>代码如下:</strong></p> 
<pre><code class="language-java">package knowledge.iocurrent.charactercurrent;

import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

/**
 * 字符流写数据
 * Writer类中的方法：
 *      void write(int ch) : 一次写一个字符
 *     
*  FileWriter类中的构造方法 ：
 *      1° public FileWriter(String pathname) : 根据传入的字符串形式的路径，获取字符输出流对象
        2° public FileWriter(String p, true) : 流的指针不在文件的首端，而在尾端（追加模式）
 */
public class WriteData1 {
    public static void main(String[] args) throws IOException {
        //1.创建字符输出流对象，关联目的地文件
        Writer writer = new FileWriter("D:\JAVA\IDEA\file\3.txt");

        //2.将目标数据写入到目的地文件中
        writer.write(' ');  //写入一个空格
        writer.write(' ');
        writer.write(' ');
        writer.write(' ');
        writer.write(' ');
        writer.write(' ');
        writer.write('滕');
        writer.write('王');
        writer.write('阁');
        writer.write('\n');
        
        //3.释放资源
        writer.close();
    }
}
/*
    summary:
    //注意①, 调用write方法默认会覆盖文件中原有的内容
    //注意②, 若部分write方法被注释掉，那么再次运行时，其内容也会被覆盖
 */
</code></pre> 
<p>                <strong>运行效果:</strong></p> 
<p class="img-center"><img alt="" height="164" src="https://images2.imgbox.com/f0/2a/pXiHkYNf_o.png" width="753"></p> 
<p>                可以看到我们创建的3.txt文件下成功写入了内容：<strong>滕王阁</strong></p> 
<p>                这里要注意一点就是，如果文件中原本就有内容，那么输入流写入文件时会对文本中的内容进行覆盖。 <strong>举个栗子：</strong></p> 
<p><strong>                </strong>如图，当我们3.txt文件中本来就有内容时:</p> 
<p class="img-center"><img alt="" height="147" src="https://images2.imgbox.com/28/13/sq9V6rIt_o.png" width="748"></p> 
<p>                此时 我们再次运行就又会得到:</p> 
<p class="img-center"><img alt="" height="128" src="https://images2.imgbox.com/0d/d0/c9ZE8fOk_o.png" width="757"></p> 
<p>                没错，这是需要注意的一个点。 </p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E6%8C%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%86%99%E5%85%A5%EF%BC%9A">                ②按字符数组写入：</h4> 
<p>               <strong><span style="color:#956fe7;"> 步骤：</span></strong></p> 
<p>                <strong>①</strong>创建字符输入流对象，关联目的地文件。<strong>(建议第一步就<span style="color:#fe2c24;">抛出父类异常IOException</span>)</strong></p> 
<p>                <strong>②</strong>将目标内容写入到目的地文件中</p> 
<p>                <strong>③</strong>释放资源</p> 
<p>               <span style="color:#956fe7;"><strong> 写入方法：</strong></span></p> 
<p>                先<strong><span style="background-color:#fefcd8;">创建一个字符型数组，并在数组中放入你想写入到文件中的内容</span></strong>，然后调用Write类中的方法——<br>                 <strong>void write(char[] c, int index, int len) : </strong>一次写一个指定的字符数组，需要<strong><span style="background-color:#ffd900;">传入</span><u><span style="background-color:#ffd900;">数组名</span></u><span style="background-color:#ffd900;">，</span><u><span style="background-color:#ffd900;">起始索引</span></u><span style="background-color:#ffd900;">，和</span><u><span style="background-color:#ffd900;">有效字符的总长度</span></u></strong>。<br><strong>                void write(char[] c) : </strong>若<strong><span style="background-color:#ffd900;">只传入数组名</span></strong>，这个方法会将数组中的全部内容都写进去。</p> 
<p>                <span style="color:#0d0016;"><strong>PS : </strong></span>获取输出流对象的方式与前面以单个字符写入时相同，这里就不再赘述了，以下同理。</p> 
<h4>                代码演示：</h4> 
<p>               <s> 老规矩，</s> 欸，这次没有老规矩了！我们就<strong>在之前创建的3.txt下继续操作</strong>。理由就是up想整点儿私货（bushi）。看一下我们3.txt目前的状况，如图：</p> 
<p class="img-center"><img alt="" height="135" src="https://images2.imgbox.com/fb/6d/moESTjzU_o.png" width="758"></p> 
<p>                好的，我们还是在charactercurrent包下创建一个WriteData2类，用作我们的演示类，如图：</p> 
<p class="img-center"><img alt="" height="258" src="https://images2.imgbox.com/8a/9e/QDmvcvsQ_o.png" width="308"></p> 
<p>                 WriteData2类<strong>代码如下:</strong></p> 
<pre><code class="language-java">package knowledge.iocurrent.charactercurrent;

import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

/**
 * 字符流写数据
 * Writer类中的方法：
 *      void write(char[] c, int index, int len) : 一次写一个指定的字符数组
 *
 * FileWriter类中的构造方法 ：
 *      1° public FileWriter(String pathname) : 根据传入的字符串形式的路径，获取字符输出流对象（覆盖模式）
        2° public FileWriter(String p, true) : 流的指针不在文件的首端，而在尾端（追加模式）
 */
public class WriteData2 {
    public static void main(String[] args) throws IOException {//这里直接就抛出了父类异常
    //1.创建字符输出流对象，关联目的地文件
        Writer writer = new FileWriter("D:\\JAVA\\IDEA\\file\\3.txt");

    //2.将目标数据写入到目的地文件中
        writer.write(' ');  //写入一个空格
        writer.write(' ');
        writer.write(' ');
        writer.write(' ');
        writer.write(' ');
        writer.write(' ');
        writer.write('滕');
        writer.write('王');
        writer.write('阁');
        writer.write('\n');
        /*
            这里我们把之前WriteData1类中的代码拷贝过来，因为write() 方法会覆盖原有的内容，
            而up为了整点儿私活，肯定不能让它随便就给覆盖了，如何让它留下？把之前写入原有内容
            的代码复制粘贴过来不就行了。
         */

        /*
            这里我们创建两个数组，把两个写入方法都给大家演示一遍，其中：
            charArray1用于演示  void write(char[] c, int index, int len)
            charArray2用于演示  void write(char[] c)
         */
        char[] charArray1 = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '(', '唐', ')', '嘿'};
        char[] charArray2 = {'王', '勃', '\n'};
        writer.write(charArray1, 0, 12);
        writer.write(charArray2);

    //3.释放资源
        writer.close();
    }
}
/*
    summary:
    //注意①, 调用write方法默认会覆盖原文件中已有的内容
    //注意②，若部分write方法的代码被注释掉，那么再次运行时，其对应的内容也会被覆盖
 */
</code></pre> 
<p>                看一下运行效果:</p> 
<p class="img-center"><img alt="" height="171" src="https://images2.imgbox.com/92/86/PDPf9gL7_o.png" width="751"></p> 
<p>                嗯，非常完美。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A2%E6%8C%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%99%E5%85%A5%EF%BC%9A">               <strong> ③按字符串写入：</strong></h4> 
<p>               <span style="color:#956fe7;"><strong> 步骤：</strong></span>（其实三种写入方法步骤都差不多，重复写属实有凑字数嫌疑（bushi））</p> 
<p>                <strong>①</strong>创建字符输出流对象，关联目的地文件。(建议第一步就<span style="color:#fe2c24;"><strong>抛出父类异常IOException</strong></span>)</p> 
<p>                <strong>②</strong>将目标内容写入到目的地文件中</p> 
<p>                <strong>③</strong>释放资源</p> 
<p>               <strong><span style="color:#956fe7;"> 写入方法：</span></strong></p> 
<p>                与上述写入方式大同小异，此处直接调用 <strong>write(String str) </strong>方法就🆗了。<br>               <strong>  eg：</strong>write("我写代码两年半");</p> 
<h4>                代码演示：</h4> 
<p>                <s>老规矩，</s>好吧，我们<strong>这次也继续在3.txt文本文件下操作</strong>，同时<strong><span style="background-color:#fefcd8;">把之前写入内容的代码拷贝过来，防止旧的内容被新的write语句写入的内容覆盖</span></strong>。我们在charactercurrent包下创建WriteData3类，用作演示，<strong>代码如下:</strong></p> 
<pre><code class="language-java">package knowledge.iocurrent.charactercurrent;

import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

/**
 * 字符流写数据
 * Writer类中的方法：
 *      void write(String str) : 一次写一个字符串
 *
 * FileWriter类中的构造方法 ：
 *      1° public FileWriter(String pathname) : 根据传入的字符串形式的路径，获取字符输出流对象
        2° public FileWriter(String p, true) : 流的指针不在文件的首端，而在尾端（追加模式）
 */
public class WriteData3 {
    public static void main(String[] args) throws IOException {//这里直接就抛出了父类异常
    //1.创建字符输出流对象，关联目的地文件
        Writer writer = new FileWriter("D:\\JAVA\\IDEA\\file\\3.txt");

    //2.将目标数据写入到目的地文件中
        writer.write(' ');  //写入一个空格
        writer.write(' ');
        writer.write(' ');
        writer.write(' ');
        writer.write(' ');
        writer.write(' ');
        writer.write('滕');
        writer.write('王');
        writer.write('阁');
        writer.write('\n');

        char[] charArray1 = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '(', '唐', ')', '嘿'};
        char[] charArray2 = {'王', '勃', '\n'};
        writer.write(charArray1, 0, 12);
        writer.write(charArray2);

        /*
            好的，接下来是演示以字符串形式写入:
         */
        writer.write("滕王高阁临江渚，佩玉鸣鸾罢歌舞。\n");
        writer.write("画栋朝飞南浦云，珠帘暮卷西山雨。\n");
        writer.write("闲云潭影日悠悠，物换星移几度秋。\n");
        writer.write("阁中帝子今何在？槛外长江空自流。");


    //3.释放资源
        writer.close();
    }
}
</code></pre> 
<p>                OK,来看一下最终的效果图：</p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/38/25/hwKHtdjF_o.png" width="751"></p> 
<p>                呃，好吧，就是和大家分享一首up喜欢的诗。你们要是有兴趣也可以试着把滕王阁序整篇写入到一个文本文件里。hahah（bushi） 。废号少说，我们接着继续讲解 :</p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E5%AD%97%E7%AC%A6%E6%B5%81%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%3A">      <strong>  3.字符流拷贝文件:</strong></h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%89%8D%E8%A8%80%3A"><strong>                前言:</strong></h4> 
<p><strong>                </strong>其实，所谓字符流拷贝文件，无非就是把我们前面的字符流读取文件和字符流写入文件给杂糅到一块儿了，结合起来使用，<strong>先用<span style="color:#fe2c24;">字符输入流读取xxx文件的内容</span>，再用<span style="color:#fe2c24;">字符输出流把读取到的xxx文件中的内容写入到另一个yyy文件</span></strong>，可不就叫拷贝么！所以，僵尸栽花，只要你前面的读取和写入扎扎实实走了一遍，这里的拷贝就tm简单地一塌糊涂!</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20IO%E6%B5%81%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A0%B8%E5%BF%83%E5%85%AD%E9%83%A8%E6%9B%B2%EF%BC%88%E5%85%A8%E6%96%87%E8%83%8C%E8%AF%B5%EF%BC%81%EF%BC%89%EF%BC%9A">                IO流拷贝的核心六部曲（<span style="color:#fe2c24;"><strong>全文背诵！</strong></span>）：</h4> 
<p><span style="color:#4da8ee;"><span style="background-color:#f3f3f4;">               </span><strong><span style="background-color:#f3f3f4;"> 1）创建字符(字节）输入流对象，关联数据源文件</span></strong></span></p> 
<p><span style="color:#4da8ee;"><strong><span style="background-color:#f3f3f4;">                2）创建字符(字节）输出流对象，关联目的地文件 </span></strong></span></p> 
<p><span style="color:#4da8ee;"><strong><span style="background-color:#f3f3f4;">                3）定义变量，记录读取到的内容 </span></strong></span></p> 
<p><span style="color:#4da8ee;"><strong><span style="background-color:#f3f3f4;">                4）循环读取，只要条件满足就一直读，并将读取到的内容赋值给变量</span></strong></span></p> 
<p><span style="color:#4da8ee;"><strong><span style="background-color:#f3f3f4;">                5）将读取到的数据写入到 目的地文件中 </span></strong></span></p> 
<p><span style="color:#4da8ee;"><strong><span style="background-color:#f3f3f4;">                6）释放资源。</span></strong></span></p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E4%BB%A5%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E6%8B%B7%E8%B4%9D%EF%BC%9A" style="background-color:transparent;">                ①以单个字符拷贝：</h4> 
<p><span style="color:#956fe7;"><strong>                步骤:</strong></span></p> 
<p>                上面核心六部曲</p> 
<h4>                代码演示:</h4> 
<p>                我们试着将 ”3.txt“ 中的滕王阁诗拷贝到 ”拷贝到这里.txt" 中，如图:</p> 
<p class="img-center"><img alt="" height="240" src="https://images2.imgbox.com/66/d6/pYazMOmT_o.png" width="859"></p> 
<p>                注意看“拷贝到这里来.txt” 大小0kb， 是空的，点击后打开也是空空如也：</p> 
<p class="img-center"><img alt="" height="124" src="https://images2.imgbox.com/d3/96/nFpDbvZW_o.png" width="755"></p> 
<p>                然后我们还是先在character包下创建一个<strong>演示类:CopyAsSingleCharacter类</strong>，如图，:</p> 
<p class="img-center"><img alt="" height="276" src="https://images2.imgbox.com/40/a4/KDuUSoBc_o.png" width="316"></p> 
<p>                CopyAsSingleCharacter类<strong>代码如下： </strong></p> 
<pre><code class="language-java">package knowledge.iocurrent.charactercurrent;

import java.io.*;//*式的导包可以一次性导入一个包中所有的引用类，只是会降低编译速度，但是不影响运行速度。

/**
    IO流拷贝文件核心六步曲
        1.创建字符输入流对象，关联数据源文件
        2.创建字符输出流对象，关联目的地文件
        3.定义变量，记录读取到的内容
        4.循环读取，只要条件满足就一直读，并将读取到的内容赋值给变量
        5.将读取到的数据写入到  目的地文件中
        6.释放资源。
 * */

public class CopyAsSingleCharacter {
//通过字符流拷贝文件，一次拷贝一个字符 eg： 将a.txt -&gt; b.txt 中
    public static void main(String[] args) throws IOException {
    //1. 创建字符输入流对象，关联数据源文件
        Reader reader = new FileReader("D:\\JAVA\\IDEA\\file\\3.txt");

    //2. 创建字符输出流对象，关联目的地文件
        Writer writer = new FileWriter("D:\\JAVA\\IDEA\\file\\拷贝到这里来.txt");

    //3. 定义变量，记录读取到的内容
        int data;    //此处不需要赋初值，因为整数成员变量有默认值0

    //4. 循环读取(用while)，只要条件满足就一直读，并将读取到的内容赋值给变量。
        while ((data = reader.read()) != -1)  //赋值表达式的值就是赋值后变量的值。
        {
    //5. 将读取到的数据写入到  目的地文件中
            writer.write(data);
        }
            /*
                写入方法是如何实现的呢？为什么传入的是一个int类型的值？
                因为去查看JDK17的API就会发现，write方法写入一个字符
                , 需要传入的形参就是int类型，只不过将底层的实现细节隐藏了而已，
                这也是面向对象编程的特点。
             */
    //6.释放资源
        //但凡是IO流都要记得释放资源
        reader.close();
        writer.close();
    }
}
/*
 * 如果目的地文件不存在， 程序会自动创建
 */
</code></pre> 
<p>                 好的，看一下运行之后的效果:</p> 
<p class="img-center"><img alt="" height="408" src="https://images2.imgbox.com/41/8b/lrbDkPM7_o.png" width="585"></p> 
<p>                 Perfect！</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E4%BB%A5%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D%EF%BC%9A%C2%A0">                ②以字符数组拷贝： </h4> 
<p>                <span style="color:#956fe7;"><strong>步骤：</strong></span></p> 
<p>                还是上面<strong>核心六部曲</strong> ，只不过读写部分是按字符数组读写罢了。字符数组上面也已经较为详细的讲过了，还没掌握的小伙伴儿们可以跳转回去看看。</p> 
<h4>                代码演示:</h4> 
<p>                我们试着将 “3.txt” 文本文件中的滕王阁诗拷贝到 "拷贝到这里来2.txt" 文件中来，但这次是以字符数组的形式。我们先创建一个目的地文件，如图：</p> 
<p class="img-center"><img alt="" height="506" src="https://images2.imgbox.com/65/24/mVBfHH9r_o.png" width="841"></p> 
<p>                然后，我们在charactercurrent包下创建一个CopyAsCharArray类，用作拷贝的演示类，如图：</p> 
<p class="img-center"><img alt="" height="240" src="https://images2.imgbox.com/be/3a/HNyruq0I_o.png" width="301"></p> 
<p>                CopyAsCharArray类<strong>代码如下 : </strong></p> 
<pre><code class="language-java">package knowledge.iocurrent.charactercurrent;

import java.io.Reader;
import java.io.FileReader;
import java.io.Writer;
import java.io.FileWriter;
import java.io.IOException;


/***
 * IO流拷贝文件核心六步曲：
 *      1.创建字符输入流对象，关联数据源文件
 *      2.创建字符输出流对象，关联目的地文件
 *      3.定义变量，记录读取到的内容
 *      4.循环读取，只要条件满足就一直读取，并将读到的内容赋值给变量
 *      5.将读取到的数据写入到  目的地文件中
 *      6.释放资源
 */
public class CopyAsCharArray {
    public static void main(String[] args) throws IOException{
    // 1.创建字符输入流对象，关联数据源文件
        Reader r = new FileReader("D:\\JAVA\\IDEA\\file\\3.txt");
    // 2.创建字符输出流对象，关联目的地文件
        Writer w = new FileWriter("D:\\JAVA\\IDEA\\file\\拷贝到这里来2.txt");
        char[] cArray = new char[1024];
        /*
            以字符数组的形式进行IO流拷贝操作时，所定义数组的长度最好是1024的整数倍。
         */
    // 3.定义变量，记录读取到的内容 (此处实际记录读取的有效字符数，读取到的内容保存在字符数组中)
        int len;
    // 4.循环读取，只要条件满足就一直读取，并将读到的内容赋值给变量
        while ((len = r.read(cArray)) != -1)
        {
    // 5.将读取到的内容写入到目的地文件中
            w.write(cArray, 0, len);     
            //这个write重载方法我们在上文“以字符数组的形式写入”那里讲过噢
        }
        System.out.println("给👴看看数组成什么样儿了：\n");
        System.out.println(cArray);
        System.out.println("" + cArray);
        /*
            如果输出语句中写作了 “” + cArray, 那么打印出的cArray就只是它的地址值，
            所以此处应该分开写。
         */
    // 6.释放资源
        r.close();
        w.close();
    }
}
</code></pre> 
<p>                <strong>运行结果：</strong></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/71/35/souE1Efs_o.png" width="1060"></p> 
<p>                后面那一长串尾巴是定义的cArray中没内容的空字符。 来看一下运行效果:</p> 
<p class="img-center"><img alt="" height="232" src="https://images2.imgbox.com/8b/c1/9tSXKHf5_o.png" width="787"></p> 
<p>                成功将滕王阁诗又拷贝到了 "拷贝到这里来2.txt"  文件中。  </p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%EF%BC%88%E9%AB%98%E6%95%88%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89%3A">        4.字符缓冲流（高效字符流）:</h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E4%BB%8B%E7%BB%8D%3A">                ①字符缓冲流介绍:</h4> 
<p>                <strong>字符缓冲流，又叫做高效字符流</strong>。<span style="color:#956fe7;"><strong>字符缓冲流自带有缓冲区，大小为8192个字符，也就是16KB</strong></span>。 (即字节数：16*1024 == 8192*2) ----&gt;（Unicode编码一个中文或英文字符都是占两个字节）。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A1%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E6%99%AE%E9%80%9A%E7%94%A8%E6%B3%95%EF%BC%9A">                ②字符缓冲流的普通用法：</h4> 
<p>                使用字符缓冲流来拷贝文件时，依然<span style="color:#fe2c24;"><strong>遵循经典的IO流拷贝文件核心六部曲</strong></span>，因此为什么我强调要把IO流拷贝文件核心六部曲全文背诵？因为太经典了！几乎可以可以做到一招通吃。<br>                 但是，<span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">与之前有差异的地方在于</span></strong></span>，<span style="color:#956fe7;">在创建高效字符输入流对象时，并不是直接传入数据源文件的路径了，而是要传入一个普通的字符输入流对象，而我们知道，普通读文件对象在创建时传入的就是数据源文件的路径了</span>，因此，可以总结为：<span style="color:#fe2c24;"><strong>创建高效字符输入流对象需要传入一个 ‘已经关联数据源文件的普通字符输入流对象’ 。</strong></span>仔细品味这句话，高效字符输出流也是同理。一下子看不懂也没有关系，毕竟都是带抽象，没上手过纯纯天书，还是<strong><span style="background-color:#ffd900;">直接举个栗子</span></strong>直观一点：</p> 
<pre><code class="language-java">//声明：以下是仅作差异演示的代码段，并不完整，完整代码在之后的代码演示中会有

//1.我们先创建一个普通字符输入流对象
    Reader reader = new FileReader("Test/1.txt");

//2.好，有了普通字符输入流对象后，我们就可以创建高效字符输入流对象了。
    BufferedReader bufferedReader = new BufferedReader(reader);
//这样我们就得到了一个高效字符输入流对象bufferedReader。

//其实，实际开发中往往采用链式编程优化代码，如下：
    BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter("Test/2.txt"));

//说白了就是把1. 2. 两步合起来了，看着简洁直观。</code></pre> 
<p>                好的，看完这波<strong>带栗子</strong>，小伙伴儿应该会好理解一丢丢了。</p> 
<h4>                代码演示:</h4> 
<p>                我们先<span style="background-color:#fefcd8;">创建一个数据源文件</span>，up是在D:/JAVA/IDEA/file/a文件夹下创建了一个“高效字符流滴数据源文件.txt” 文本文件。</p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/b2/b5/PKLuZU8J_o.png" width="884"></p> 
<p>                接着我们在该源文件下<strong>输入一些东西</strong>，如图：</p> 
<p class="img-center"><img alt="" height="195" src="https://images2.imgbox.com/8f/67/43gsiHhl_o.png" width="751"></p> 
<p>                我们再<span style="background-color:#fefcd8;">创建一个空的目的地文件</span>，up是在D:/JAVA/IDEA/file/a文件夹下创建了一个“高效字符流滴目的地文件.txt” 文本文件。如下图所示 : </p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/84/25/cWg52KOc_o.png" width="784"></p> 
<p>                OK，准备工作做完后我们在charactecurrent包下，buffered包下创建一个OrdinaryUse类，如图：</p> 
<p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/ae/f7/UbksU5Bv_o.png" width="413"></p> 
<p>                OrdinaryUse类<strong>代码如下:</strong></p> 
<pre><code class="language-java">package knowledge.iocurrent.charactercurrent.buffered;

import java.io.IOException;
import java.io.FileWriter;
import java.io.FileReader;
import java.io.BufferedWriter;
import java.io.BufferedReader;

/***
 * 特点：
 *      ①字符缓冲流（高效字符流）    自带有缓冲区，大小为8192个字符，也就是16KB。
 *      (即字节数：16*1024 == 8192*2) （Unicode一个中或英文字符都是  占两个字节）
        ②需注意，高效字符输入流与之前有差异的地方在于，
                *   在创建高效字符输入流对象时，并不是直接传入数据源文件的路径了，而是要传入一个
                *   普通的字符输入流对象，而我们知道，普通读文件对象在创建时传入的就是数据源文件
                *   的路径了，因此，可以概括为：创建高效字符输入流对象需要传入一个‘已经关联数据
                *   源文件的普通字符输入流对象’。
 */
public class OrdinaryUse {
    public static void main(String[] args) throws IOException{
//需求：使用高效字节流拷贝文件。
    //1.创建（高效）字符输入流对象，关联数据源文件（此处直接采用链式编程）
        BufferedReader bufferedReader = new BufferedReader(new FileReader("D:\\JAVA\\IDEA\\file\\a/高效字符流滴数据源文件.txt"));
    //2.创建（高效）字符输出流对象，关联目的地文件（此处直接采用链式编程）
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter("D:/JAVA/IDEA/file/a/高效字符流滴目的地文件.txt"));
    //3.定义变量，记录读取到的内容
        int len;
    //4.循环读取，只要条件满足就一直读取，并将读取到的内容赋值给变量
        while ((len = bufferedReader.read()) != -1)
        {
    //5.将读取到的数据写入到目的地文件中。
            bufferedWriter.write(len);    //此处为以“单个字符”的形式写入
        }
    //6.释放资源
        bufferedReader.close();
        bufferedWriter.close();
    }
}
/*
     Notice:
     这里的while循环,表面上看着就像六部曲的一次读写一个字符，但底层实际是按字符数组读取的。
 */
</code></pre> 
<p>                看一下运行效果如何：</p> 
<p class="img-center"><img alt="" height="240" src="https://images2.imgbox.com/71/f2/sWaXDCJ4_o.png" width="953"></p> 
<p>                 Very good。成功拷贝到了目的地文件中。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A2%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E7%89%B9%E6%9C%89%E7%94%A8%E6%B3%95%EF%BC%9A">                ③字符缓冲流的特有用法：</h4> 
<p>                <span style="background-color:#ffd900;">BufferedReader类中的方法：</span><br><strong>                public String readLine() : 一次读取一行数据并返回读取到的内容，读不到返回null</strong>,<br>                 该方法可以用String类型的变量作接收。</p> 
<p>                <span style="background-color:#ffd900;">BufferedWriter类中的方法：</span><br><strong>                public void newLine: 根据当前操作系统给出相应的换行符 (注释中有详解)</strong></p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%3A%C2%A0">                代码演示: </h4> 
<p>                准备工作: 这次我们就不再创建新的文本文件了，我们就直接拿来主义，用刚刚创建的两个文件算了。绝不是因为我懒！我们先把“高效字符流地数据源文件.txt” 中的内容改一下，如图:</p> 
<p class="img-center"><img alt="" height="550" src="https://images2.imgbox.com/5d/ef/NGbqWSaG_o.png" width="885"></p> 
<p>                🆗，我们还是在charactecurrent包下，buffered包下创建一个UniqueUse类，如图： </p> 
<p class="img-center"><img alt="" height="154" src="https://images2.imgbox.com/94/13/yxnC2qEI_o.png" width="433"></p> 
<p>                UniqueUse类<strong>代码如下：</strong></p> 
<pre><code class="language-java">package knowledge.iocurrent.charactercurrent.buffered;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

//注意独有方法的返回值类型
/*
 * 字符缓冲流独有拷贝方式  ————  一次读取一行数据
 *      分类：
 *          BufferedReader: 字符缓冲输入流（也叫高效字符输入流）
 *              成员方法：
 *              public String readLine() :  一次读取一行数据并返回读取到的内容，读不到返回null
 *          BufferedWriter: 字符缓冲输出流（也叫高效字符输出流）
 *              成员方法：
 *              public void newLine: 根据当前操作系统给出相应的换行符
 *                                   windows操作系统：        /r/n
 *                                   mac操作系统：            /r
 *                                   unix / Linux操作系统：   /n
 *  */

public class UniqueUse {
    public static void main(String[] args) throws IOException{ //还是直接抛出父类异常IOException
//需求: 实现高效字符流的独特用法：
        System.out.println("给👴好好看注释");
    //1.创建（高效）字符输入流对象，关联数据源文件
        BufferedReader bufferedReader = new BufferedReader(new FileReader("D:\\JAVA\\IDEA\\file\\a\\高效字符流滴数据源文件.txt"));
    //2.创建（高效）字符输出流对象，关联目的地文件
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter("D:\\JAVA\\IDEA\\file\\a\\高效字符流滴目的地文件.txt"));
    //3.定义变量，记录读取到的内容
        String len;
    //4.循环读取，只要条件满足就一直读取，并将读到的数据赋值给变量
        while ((len = bufferedReader.readLine()) != null)
        {
    //5.将读取到的数据写入到 目的地文件中
            bufferedWriter.write(len);
            bufferedWriter.newLine();
             //千万别忘记换行
            /*
                Δ注意:
             若不写bufferedWriter.newLine();
             文件中的内容同样可以拷贝成功，但是，全部在一行。
             所以newLine() 这行代码是个容易忽略但不可忽略的小细节
             */
        }
    //6.释放资源  (最好提前写上，以防粗心忘记)
        bufferedReader.close();
        bufferedWriter.close();
    }
}
/*
 * 特别注意（重要） :
 *      ①字符流只能拷贝纯文本文件！
 *      ②拷贝文件内容时，并不会考虑目的地文件中旧的内容，
 *       而是直接根据数据源文件中的内容进行重新覆盖
 *      （这个我们之前其实说过了，再强调一下是怕大家忘了）
 */
/*
* 还有一个小细节：
*    如果数据源文件中最后无换行，目的地文件拷贝后会因为newLine() 加一个换行
*    但如果数据源文件最后有换行，由于循环体中最后还加了一个换行，所以拷贝后目的地文件就与数据源文件一致了
* */</code></pre> 
<p>                来看一下运行效果:                                 </p> 
<p class="img-center"><img alt="" height="550" src="https://images2.imgbox.com/ef/c1/Hyx7eUJx_o.png" width="834"></p> 
<p>                 可以看到我们目的地文件中的《登幽州台歌》 已经被换成了《春江花月夜》，陈子昂大喜（bushi）。</p> 
<hr> 
<h2 id="%E5%9B%9B%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%EF%BC%9A" style="background-color:transparent;">四、字节流读写文件：</h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E5%89%8D%E8%A8%80%EF%BC%9A">        1.前言：</h3> 
<p>                由于字符流再怎么牛逼也只能拷贝文本文件，因此如果我们想拷贝非纯文本文件时，就得需要用到字节流。记住，<span style="color:#fe2c24;"><strong>IO流拷贝文件核心六部曲是根本，万变不离其宗</strong></span>，所以你应该能猜到我想说什么了。字节流和字符流在用法上基本大同小异，因此，字符流那块儿你整明白儿了，这里就压根儿不是个事儿。</p> 
<p>                <span style="color:#fe2c24;"><strong>拷贝纯文本文件使用字符流</strong></span><span style="color:#0d0016;"><strong>；</strong></span><span style="color:#fe2c24;"><strong>拷贝其他（视频，图片，音频等）文件 使用字节流。</strong></span></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E6%99%AE%E9%80%9A%E5%AD%97%E8%8A%82%E6%B5%81%E7%94%A8%E6%B3%95%EF%BC%9A">        2.普通字节流用法：</h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%3A%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0">                ①一次读写一个字节数组:            </h4> 
<p>               <span style="color:#956fe7;"><strong> 步骤:</strong></span></p> 
<p>                仍是<strong>IO流拷贝核心六部曲</strong>但字节流。</p> 
<h4>                代码演示：</h4> 
<p>                我们试着利用普通字节流去拷贝一份图片。我们先随便找一张图片，然后把它放在指定目录，up仍是放在了D:/JAVA/IDEA/file/a文件夹下，如图: </p> 
<p class="img-center"><img alt="" height="225" src="https://images2.imgbox.com/b5/79/QBEiHT5m_o.png" width="879"></p> 
<p>                然后是up<strong>随便</strong>找的一张<strong>普普通通</strong>的图片，因为教学演示嘛，<strong>朴实无华</strong>才更实用，如图:</p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/f7/24/77dEOY7m_o.png" width="889"></p> 
<p>                好的，我们试试能不能用字节流<strong>在该目录下拷贝一份相同的“我是拷贝滴.png”图片</strong>。在bytecurrent包下创建OrdinaryByteCurrent类作为演示类，如图：</p> 
<p class="img-center"><img alt="" height="99" src="https://images2.imgbox.com/1a/25/lDpErPXV_o.png" width="396"></p> 
<p>               <strong> OrdianryByteCurrent类的代码如下:</strong></p> 
<pre><code class="language-java">package knowledge.iocurrent.bytecurrent;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
/*
IO流拷贝文件核心六步曲：
        1.创建字节输入流对象，关联数据源文件对象
        2.创建字节输出流对象，关联目的地文件对象
        3.定义变量，记录读取到的内容
        4.循环读取，只要条件满足就一直读，并将读取到的内容赋值给变量
        5.将读取到的数据写入到  目的地文件中
        6.释放资源。
 */
/**
 * 字节流的用法：
 *      FileInputStream： 普通字节输入流，用来读取数据的
 *          成员方法：
 *              public int read(byte[] b) :
 *                  一次读取一个字节数组，将读取到的内容存入到字节数组中
 *                  并返回读取到的有效字节数，读不到返回-1
 *
 *      FileOutputStream: 普通字节输出流，用来写出数据的
 *          成员方法:
 *              public void write(byte[] b,int index, int len) :
 *                  一次写入一个指定的字节数组,需要传入数组名，起始索引，有效长度
 */
public class OrdinaryByteCurrent {
    public static void main(String[] args) throws IOException {
//需求： 学会使用普通字节流的的读写方法，试着拷贝一份图片吧。
    //1.创建字节输入流对象，关联数据源文件
        //记得传入正确的路径！
        InputStream inputStream = new FileInputStream("D:/JAVA/IDEA/file/a/1.png");

    //2.创建字节输出流对象，关联目的地文件
        OutputStream outputStream = new FileOutputStream("D:/JAVA/IDEA/file/a/我是拷贝滴.png");

    //3.定义变量，记录读取到的内容
        byte[] b = new byte[1024];    //建议定义的数组长度为1024的整数倍
        int len;

    //4.循环读取，只要条件满足就一直读，并将读取到的内容赋值给变量
        while ((len = inputStream.read(b)) != -1)
            /*
            细节:
                这里如果一不小心写成了read()
                后果: read 了个寂寞
            */
        {
    //5.将读取到的数据写入到 目的地文件中
            outputStream.write(b, 0, len);
        }
    //6.释放资源(建议直接写到最后，以防忘记释放)
        inputStream.close();
        outputStream.close();
    }
}</code></pre> 
<p>                看一下代码的运行效果：</p> 
<p class="img-center"><img alt="" height="321" src="https://images2.imgbox.com/54/25/uDCYLsnM_o.png" width="952"></p> 
<p>                成功拷贝过来了，甚至连右边的大小都一模一样，牛不牛逼？我们在点开“我是拷贝滴.png” 看看情况如何：</p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/73/64/LrRGl7rE_o.jpg" width="935"></p> 
<p>                不能说大体相似，只能说是一模一样！ </p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E9%AB%98%E6%95%88%E5%AD%97%E8%8A%82%E6%B5%81%E7%94%A8%E6%B3%95%EF%BC%9A" style="background-color:transparent;">        3.高效字节流用法：</h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E2%91%A0%E5%89%8D%E8%A8%80">                ①前言</h4> 
<p>               <strong><span style="color:#956fe7;"> 高效字节流</span>的用法与<span style="color:#956fe7;">高效字符流</span>的用法一致。</strong></p> 
<p>                <strong><span style="background-color:#fefcd8;">高效</span></strong><span style="background-color:#fefcd8;">字节流</span>和<strong><span style="background-color:#fefcd8;">普通</span></strong><span style="background-color:#fefcd8;">字节流</span>差异的地方在于:</p> 
<p>                高效字节流在创建字节输入流对象时，不再是直接传入数据源文件的路径，而是<strong>传入一个 <span style="color:#956fe7;">已经关联了数据源文件路径的</span> 普通字节输入流对象</strong>。在创建高效字节输出流时也是同理。这里我们还是像之前高效字符流一样，先拿代码段给大家示范一下：</p> 
<pre><code class="language-java">//声明:一下代码只是暂且作为片段给大家举个栗子，并不是完整代码

//1.创建普通字节流读文件对象，关联数据源文件。
    InputStream inputStream = new FileInputStream("Test2/1.jpg");

//2.创建高效字节流读文件对象。
    BufferedInputStream bufferedInputStream  = new BufferedOutputStream(inputStream);

//3.当然了，实际开发中，我们往往将1.2.步合并，也就是之前说到的所谓链式编程了
    BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream("Test2/2.jpg"));</code></pre> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%E2%91%A1write%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95%EF%BC%9A">                ②write重载方法：</h4> 
<p>                还记得刚刚我们的普通字节流是怎么拷贝的来不？我们是以一次读写一个字节数组来拷贝的，其实write类的重载方法很多，up截了个图给小伙伴儿们看看：</p> 
<p class="img-center"><img alt="" height="175" src="https://images2.imgbox.com/08/85/QkuaPwjx_o.png" width="645"></p> 
<p>                 仔细看，普通字节流那块儿我们用到不就是中间的重载方法吗？那么字节缓冲流演示里，我们就换换口味，这次我们选用<strong>write(int b) 这个重载方法</strong>，该方法本质是<strong>一次写入单个字节</strong>。</p> 
<h4>                代码演示:</h4> 
<p>                老规矩，我们还是先随便找个要拷贝的图片，放在既定的文件目录下，如图:</p> 
<p class="img-center"><img alt="" height="275" src="https://images2.imgbox.com/a5/f1/TMTgUOUE_o.png" width="1041"></p> 
<p>                up也是<strong>随便</strong>找了一张<strong>普普通通</strong>的图片，毕竟是做演示，还是<strong>效率和实用更重要</strong>！如图： </p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/fe/7b/O0jX4KEX_o.jpg" width="889"></p> 
<p>                好的，我们试试能不能用字节流<strong>在该目录下拷贝一份相同的“我是拷贝滴2.jpg”图片</strong>。在bytecurrent包下创建EfficientByteCurrent类作为演示类，如图：                                </p> 
<p class="img-center"><img alt="" height="124" src="https://images2.imgbox.com/6b/af/BfmIanpE_o.png" width="385"></p> 
<p>                <strong>EffeciveByteCurrent类的代码如下:</strong>                 </p> 
<pre><code class="language-java">package knowledge.iocurrent.bytecurrent;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

//*
// * IO流拷贝文件核心六步曲
// *         1.创建字符（节）输入流对象，关联数据源文件对象
// *         2.创建字符（节）输出流对象，关联目的地文件对象
// *         3.定义变量，记录读取到的内容
// *         4.循环读取，只要条件满足就一直读，并将读取到的内容赋值给变量
// *         5.将读取到的数据写入到  目的地文件中
// *         6.释放资源。（怕忘记可提前写，同时在这之前记得进行异常处理）

/*
 * 特点：
 *      字节缓冲流有自己的缓冲区，大小为8192个字节（注意是字节噢，不是字符），也就是8kb
 */
public class EffectiveByteCurrent {
    public static void main(String[] args) throws IOException{
    //1.创建高效字节输入流对象，关联数据源文件(链式编程)
        BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream("D:\\JAVA\\IDEA\\file\\a\\2.jpg"));

    //2.创建高效字节输出流对象，关联目的地文件(链式编程)
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream("D:/JAVA/IDEA/file/a/我是拷贝滴2.jpg"));

    //3.定义变量，记录读取到的内容。
        int data;

    //4.循环读取，只要条件满足就一直读，并将读到的内容赋值给变量。
        while ((data=bufferedInputStream.read()) != -1)
        {
    //5.将读取到的数据写入到 目的地文件中
            bufferedOutputStream.write(data);
        }
        /*
            write（）有很多重载方法，但是
            这里我们把重载方法选为了write（int len），即一次写入一个字节
         */

    //6.关闭资源 （建议提前写，小心使得万年船）
        bufferedInputStream.close();
        bufferedOutputStream.close();
    }
}
/**
 * Summary（总结）
 *      拷贝纯文本文件使用字符流，拷贝其他（视频，图片，音频等）文件  使用字节流。
 */
</code></pre> 
<p>                看一下代码的执行效果：</p> 
<p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/8c/47/arjRTkwZ_o.png" width="809"></p> 
<p>                牛逼，又成了。我们再点开“我是拷贝滴2.jpg”看看情况：</p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/ea/7a/xWoJ8yyd_o.png" width="932"></p> 
<p>                艹（中日双语） ，只能说完全一致。🐂<strong>🖊</strong>！</p> 
<p>                🆗，普通字节流和高效字节流用法我们就讲到这里，更多精彩内容欢迎订阅up。</p> 
<hr> 
<h2 id="%E4%BA%94%E3%80%81IO%E6%B5%81%E6%A8%A1%E6%8B%9F%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F%E7%B3%BB%E7%BB%9F%EF%BC%9A" style="background-color:transparent;">五、IO流模拟上传头像系统：</h2> 
<p>                <s>GG，🕊🕊🕊。写到这已经两万多字了，就算你牛逼，你头铁你看到这里还意犹未尽，up也已经“心力交瘁”，写不动了（bushi）。好吧，由于模拟上传头像的代码较长，而且有较强的逻辑性，因此up准备单独发一篇博文详解，将放在java进阶专栏。现在是10月22日，我会在三天内上传详解IO流模拟上传头像系统的博文，到时候把链接给小伙伴儿们放在这里，大家敬请期待。</s></p> 
<p>2022.10.24已更新：点击查看<a class="link-info" href="https://blog.csdn.net/TYRA9/article/details/127470940" title="java IO流进阶 模拟上传头像系统">java IO流进阶 模拟上传头像系统</a>。</p> 
<hr> 
<h2 id="%E5%85%AD%E3%80%81%E5%AE%8C%E7%BB%93%E6%92%92%E2%9D%80%20%2B%20%E7%BB%99%E8%87%AA%E5%B7%B1%E6%89%93%E5%B9%BF%E5%91%8A%EF%BC%9A">六、完结撒❀</h2> 
<blockquote> 
 <p>        🆗，以上就是我们IO流基础的全部内容了。回顾一下我们的 “<span style="color:#0d0016;"><strong>API——常用工具</strong></span>”专题——I<span style="color:#0d0016;"><strong>O流篇章</strong></span>：我们从异常基础开始引入，中间补充了File类的内容讲解，最后就是本篇博文的IO流基础详解。当然，既然整个IO流体系是作为Java的“常用工具”，那显然我们得多多练习，把这些方法用的6起来。<span style="color:#0d0016;"><strong>下一个专题是——"Java 反射"</strong></span>，我们不见不散。<span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;">感谢阅读！</span></strong></span></p> 
 <p>        PS :  2023-04-19 做了改动。</p> 
 <p>        PS :  2023/12/20 做了一些小的完善。 </p> 
</blockquote> 
<p>        <strong>System.out.println("END-----------------------------------------------------------------------------");</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ff91e386456867c721a932948a415dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nmap下载地址，免费使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/789931a7a83760ca6d4eeee1141d3ca1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">spring中DI依赖注入的两种方式set方法注入（property ）、构造器注入（constructor-arg）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>