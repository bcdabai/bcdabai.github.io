<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CNN之图像识别 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CNN之图像识别" />
<meta property="og:description" content="什么是图像识别 • 图像识别技术是信息时代的一门重要的技术，其产生目的是为了让计算机代替人类去处理大量的物理信息。随着计算机技术的发展，人类对图像识别技术的认识越来越深刻 • 图像识别技术的定义为利用计算机对图像进行处理、分析和理解，以识别不同模式的目标和对象的技术 • 图像识别技术的过程分为信息的获取、预处理、特征抽取和选择、分类器设计和分类决策 举个栗子： 好看不？
卧槽，真好看！这进气格栅，这前铲，真大！
臭直男，就知道看车！
那不然呢，这可是AMG GTR诶
......
对象1：奔驰AMG GTR
对象2：妹子
那么问题来了，人眼一眼就能分辨，但是计算机如何分辨呢？
模式识别 • 模式识别是人工智能和信息科学的重要组成部分。模式识别是指对表示事物或现象的不同形式的信息做分析和处理从而得到一个对事物或现象做出描述、辨认和分类等的过程。 • 计算机的图像识别技术就是模拟人类的图像识别过程。在图像识别的过程中进行模式识别是必不可少的。 • 模式识别原本是人类的一项基本智能。但随着计算机的发展和人工智能的兴起，人类本身的模式识别已经满足不了生活的需要，于是人类就希望用计算机来代替或扩展人类的部分脑力劳动。这样计算机的模式识别就产生了。 • 简单地说，模式识别就是对数据进行分类，它是一门与数学紧密结合的科学，其中所用的思想大部分是概率与统计。 还是上图为例，要准确识别出车和车模，就需要大量的车和人的图片对计算机进行训练，让它知道车的特征和人的特征，然后去进行区分
图像识别的过程 1. 信息的获取： 是指通过传感器，将光或声音等信息转化为电信息。也就是获取研究对象的基本信息并通过某种方法将其转变为机器能够认识的信息。 2. 预处理： 主要是指图像处理中的去噪、平滑、变换等的操作，从而加强图像的重要特征。图像增强。 3. 特征抽取和选择： 是指在模式识别中，需要进行特征的抽取和选择。特征抽取和选择在图像识别过程中是非常关键的技术之一。 4. 分类器设计： 是指通过训练而得到一种识别规则，通过此识别规则可以得到一种特征分类，使图像识别技术能够得到高识别率。分类决策是指在特征空间中对被识别对象进行分类，从而更好地识别所研究的对象具体属于哪一类。 分类与检测 当机器看到这张图的时候，首先就要确定这张图片是什么？风景？人物？事物？美食？...这就是分类
当确定类型之后，就要对图中的对象进行进一步检测了，红色框是车模，绿色框是车，这就是检测出来的结果。
物体分类与检测在很多领域得到广泛应用，包括安防领域的人脸识别、行人检测、智能视频分析、行人跟踪等，交通领域的交通场景物体识别、车辆计数、逆行检测、车牌检测与识别，以及互联网领域的基于内容的图像检索、相册自动归类等。 自动驾驶，最常见，最直观。 常见的卷积神经网络 VGG（VGG16） VGG之所以经典，在于它首次将深度学习做得非常“深”，达到了16-19层，同时，它用了非常“小”的卷积核（3X3）。 哇，这个结构的艺术成分很高啊
有多高啊
洪家铁线圈大师的强力推荐（敢说不好，打屎你，以德服人）
来看下它的结构： 具体的过程：
1：输入图像尺寸为224x224x3，经64个通道为3的3x3的卷积核，步长为1，padding=same填充，卷积两次，再经ReLU激活，输出的尺寸大小为224x224x64
2：经max pooling（最大化池化），滤波器为2x2，步长为2，图像尺寸减半，池化后的尺寸变为112x112x64
3：经128个3x3的卷积核，两次卷积，ReLU激活，尺寸变为112x112x128
4：max pooling池化，尺寸变为56x56x128
5：经256个3x3的卷积核，三次卷积，ReLU激活，尺寸变为56x56x256
6：max pooling池化，尺寸变为28x28x256
7：经512个3x3的卷积核，三次卷积，ReLU激活，尺寸变为28x28x512
8：max pooling池化，尺寸变为14x14x512
9：经512个3x3的卷积核，三次卷积，ReLU，尺寸变为14x14x512
10：max pooling池化，尺寸变为7x7x512" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1566a4f21a9b1682b76495429c95d1c4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-19T14:19:00+08:00" />
<meta property="article:modified_time" content="2023-08-19T14:19:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CNN之图像识别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>什么是图像识别</h2> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">图像识别技术是信息时代的一门重要的技术，其产生目的是为了让计算机代替人类去处理大量的物理信息。随着计算机技术的发展，人类对图像识别技术的认识越来越深刻 </span> 
</div> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">图像识别技术的定义为利用计算机对图像进行处理、分析和理解，以识别不同模式的目标和对象的技术</span> 
</div> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">图像识别技术的过程分为信息的获取、预处理、特征抽取和选择、分类器设计和分类决策</span> 
</div> 
<div> 
 <span style="color:#000000;">举个栗子：</span> 
</div> 
<div> 
 <img alt="" src="https://images2.imgbox.com/67/f5/1EngrSCk_o.jpg"> 
</div> 
<p></p> 
<p>好看不？</p> 
<p>卧槽，真好看！这进气格栅，这前铲，真大！</p> 
<p>臭直男，就知道看车！</p> 
<p>那不然呢，这可是AMG GTR诶</p> 
<p>......</p> 
<p>对象1：奔驰AMG GTR</p> 
<p>对象2：妹子</p> 
<p>那么问题来了，人眼一眼就能分辨，但是计算机如何分辨呢？</p> 
<h2>模式识别</h2> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">模式识别是人工智能和信息科学的重要组成部分。模式识别是指对表示事物或现象的不同形式的信息做分析和处理从而得到一个对事物或现象做出描述、辨认和分类等的过程。 </span> 
</div> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">计算机的图像识别技术就是模拟人类的图像识别过程。在图像识别的过程中进行模式识别是必不可少的。 </span> 
</div> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">模式识别原本是人类的一项基本智能。但随着计算机的发展和人工智能的兴起，人类本身的模式识别已经满足不了生活的需要，于是人类就希望用计算机来代替或扩展人类的部分脑力劳动。这样计算机的模式识别就产生了。 </span> 
</div> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">简单地说，模式识别就是对数据进行分类，它是一门与数学紧密结合的科学，其中所用的思想大部分是概率与统计。</span> 
</div> 
<p>还是上图为例，<strong>要准确识别出车和车模，就需要大量的车和人的图片对计算机进行训练，让它知道车的特征和人的特征，然后去进行区分</strong></p> 
<h2><span style="color:#404040;"><strong>图像识别的过程</strong></span></h2> 
<div> 
 <span style="color:#000000;"><strong>1. 信息的获取：</strong></span> 
</div> 
<div> 
 <span style="color:#000000;">是指通过传感器，将光或声音等信息转化为电信息。也就是获取研究对象的基本信息并通过某种方法将其转变为机器能够认识的信息。 </span> 
</div> 
<div> 
 <span style="color:#000000;"><strong>2. 预处理：</strong></span> 
</div> 
<div> 
 <span style="color:#000000;">主要是指图像处理中的去噪、平滑、变换等的操作，从而加强图像的重要特征。图像增强。 </span> 
</div> 
<div> 
 <span style="color:#000000;"><strong>3. 特征抽取和选择：</strong></span> 
</div> 
<div> 
 <span style="color:#000000;">是指在模式识别中，需要进行特征的抽取和选择。特征抽取和选择在图像识别过程中是非常关键的技术之一。 </span> 
</div> 
<div> 
 <span style="color:#000000;"><strong>4. 分类器设计：</strong></span> 
</div> 
<div> 
 <span style="color:#000000;">是指通过训练而得到一种识别规则，通过此识别规则可以得到一种特征分类，使图像识别技术能够得到高识别率。分类决策是指在特征空间中对被识别对象进行分类，从而更好地识别所研究的对象具体属于哪一类。</span> 
</div> 
<div> 
 <h2><span style="color:#404040;"><strong>分类与检测</strong></span></h2> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/7b/23/oxiBICPk_o.png"></p> 
 <p></p> 
 <p>当机器看到这张图的时候，首先就要确定这张图片是什么？风景？人物？事物？美食？...<strong>这就是分类</strong></p> 
 <p>当确定类型之后，就要对图中的对象进行进一步检测了，红色框是车模，绿色框是车，这就是检测出来的结果。</p> 
 <div> 
  <span style="color:#000000;">物体分类与检测在很多领域得到广泛应用，包括安防领域的人脸识别、行人检测、智能视频分析、行人跟踪等，交通领域的交通场景物体识别、车辆计数、逆行检测、车牌检测与识别，以及互联网领域的基于内容的图像检索、相册自动归类等。</span> 
 </div> 
 <div> 
  <p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/02/a1/Rfinqqav_o.jpg" width="1200"></p> 自动驾驶，最常见，最直观。 
 </div> 
 <h2><span style="color:#000000;"><strong>常见的卷积神经网络</strong></span></h2> 
 <p class="img-center"><img alt="" height="575" src="https://images2.imgbox.com/ae/23/MyGtFK1p_o.png" width="983"></p> 
 <h3><span style="color:#404040;"><strong>VGG（VGG16）</strong></span></h3> 
 <div> 
  <span style="color:#000000;">VGG之所以经典，在于它首次将深度学习做得非常“深”，达到了16-19层，同时，它用了非常“小”的卷积核（3X3）。</span> 
 </div> 
 <div> 
  <p class="img-center"><img alt="" height="677" src="https://images2.imgbox.com/bb/4e/oEpKe5TO_o.png" width="345"></p> 
  <p>哇，这个结构的艺术成分很高啊</p> 
  <p>有多高啊</p> 
  <p class="img-center"><img alt="" height="322" src="https://images2.imgbox.com/f5/5a/JcVsxHXI_o.png" width="720"></p> 
 </div> 
 <p>洪家铁线圈大师的强力推荐（敢说不好，打屎你，以德服人）</p> 
 <div> 
  <span style="color:#000000;">来看下它的结构：</span> 
 </div> 
 <div> 
  <p class="img-center"><img alt="" height="569" src="https://images2.imgbox.com/87/53/0bM1YFFQ_o.png" width="935"></p> 
  <p>具体的过程：</p> 
  <p>1：输入图像尺寸为224x224x3，经64个通道为3的3x3的卷积核，步长为1，padding=same填充，卷积两次，再经ReLU激活，输出的尺寸大小为224x224x64<br> 2：经max pooling（最大化池化），滤波器为2x2，步长为2，图像尺寸减半，池化后的尺寸变为112x112x64<br> 3：经128个3x3的卷积核，两次卷积，ReLU激活，尺寸变为112x112x128<br> 4：max pooling池化，尺寸变为56x56x128<br> 5：经256个3x3的卷积核，三次卷积，ReLU激活，尺寸变为56x56x256<br> 6：max pooling池化，尺寸变为28x28x256<br> 7：经512个3x3的卷积核，三次卷积，ReLU激活，尺寸变为28x28x512<br> 8：max pooling池化，尺寸变为14x14x512<br> 9：经512个3x3的卷积核，三次卷积，ReLU，尺寸变为14x14x512<br> 10：max pooling池化，尺寸变为7x7x512<br> 11：然后Flatten，将数据拉平成向量，变成一维51277=25088。<br> 12：再经过两层1x1x4096，一层1x1x1000的全连接层（共三层），经ReLU激活<br> 13：最后通过softmax输出1000个预测结果</p> 
  <p>MD，那么多字，看的头疼，上图！</p> 
 </div> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/2e/d3/KebmQK8K_o.png"></p> 
</div> 
<p>我们看一下最后那个1*1的卷积是干嘛用的：</p> 
<p><span style="color:#000000;"><strong>实现特征通道的升维和降维，</strong>通过控制卷积核的数量达到通道数大小的放缩。而池化层只能改变高度和宽度，无法改变通道数。</span></p> 
<h3><span style="color:#404040;"><strong>Resnet</strong></span></h3> 
<div> 
 <span style="color:#000000;">Residual net(残差网络)：将靠前若干层的某一层数据输出直接跳过多层引入到后面数据层的输入部分。 </span> 
</div> 
<div> 
 <span style="color:#000000;">残差神经单元：假定某段神经网络的输入是x，期望输出是H(x)，如果我们直接将输入x传到输出作为初始结果，那么我们需要学习的目标就是F(x) = H(x) - x，这就是一个残差神经单元，相当于将学习目标改变了，不再是学习一个完整的输出H(x)，只是输出和输入的差别 H(x) - x ，即残差。</span> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="339" src="https://images2.imgbox.com/39/dd/4XkfLygb_o.png" width="467"></p> 
 <h4><span style="color:#000000;">普通的直连的卷积神经网络和ResNet的区别:</span></h4> 
</div> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">普通的直连的卷积神经网络和ResNet的最大区别在于，ResNet有很多旁路的支线将输入直接连到后面的层，使得后面的层可以直接学习残差，这种结构也 </span> 
</div> 
<div> 
 <span style="color:#000000;">被称为shortcut或skip connections。 </span> 
</div> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">传统的卷积层或全连接层在信息传递时，或多或少会存在信息丢失、损耗等问题。ResNet在某种程度上解决了这个问题，通过直接将输入信息绕道传到输出， </span> 
</div> 
<div> 
 <span style="color:#000000;">保护信息的完整性，整个网络只需要学习输入、输出差别的那一部分，简化了学习目标和难度。</span> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="548" src="https://images2.imgbox.com/f3/43/Dgo39Ap2_o.png" width="497"></p> 
</div> 
<div>
  假设，预激活后的输出是，[1，2，3，4，5]，经过卷积之后，可能只剩[1，2，3]，但是旁路会保留这些信息。 
</div> 
<div>
  像不像小时候让朋友去买东西，原本是两个汉堡，一大盒薯条，六个蛋挞，结果到你手上只剩俩蛋挞了，旁路就是外卖员，会原封不动的给你送来。 
 <strong>看到这里，各位老板还不V我50看看实力吗（手动滑稽）</strong> 
</div> 
<h3><strong>Resnet50（50，卧槽，呼应上了啊）</strong></h3> 
<p></p> 
<div> 
 <span style="color:#000000;">ResNet50有两个基本的块，分别名为Conv Block和Identity Block，其中Conv Block输入和输出的维度是不一样的，所以不能连续串联，它的作用是改变网络的维度；Identity Block输入维度和输出维度相同，可以串联，用于加深网络的。</span> 
</div> 
<div> 
 <img alt="" class="left" height="467" src="https://images2.imgbox.com/d9/76/iYs6YnN5_o.png" width="722"> 
</div> 
<p> <img alt="" class="left" height="558" src="https://images2.imgbox.com/27/05/99txsUnJ_o.png" width="315"></p> 
<div>
  看右图，Conv Block下面可以跟着好几个Identity Block，但是没有两个Conv Block是连在一起的，因为Conv输入和输出的维度不同，举个栗子： 
</div> 
<div>
  Conv：[3*3*3] → [3*3*1] 
</div> 
<div>
  Identity：[3*3*1] → [3*3*1] 
</div> 
<div style="text-align:center;"> 
 <p style="text-align:left;">Conv就好比是我去健身房，然后吃轻食餐，Identity是我也去了，然后......：</p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/c5/c1/5JUJR4J3_o.jpg"></p> 
</div> 
<div> 
 <h3><span style="color:#404040;"><strong>BatchNormalization（批量归一化）</strong></span></h3> 
 <div> 
  <span style="color:#000000;">• </span> 
  <span style="color:#000000;">所有输出保证在0~1之间。 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">• </span> 
  <span style="color:#000000;">所有输出数据的均值接近0，标准差接近1的正太分布。使其落入激活函数的敏感区，避免梯度消失，加快收敛。 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">• </span> 
  <span style="color:#000000;">加快模型收敛速度，并且具有一定的泛化能力。 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">• </span> 
  <span style="color:#000000;">可以减少dropout的使用。</span> 
 </div> 
 <div> 
  <span style="color:#000000;">归一化咱们已经知道了，你肯定知道什么叫批量归一化，但是批量，这个批量是指的哪些？</span> 
 </div> 
 <div> 
  <span style="color:#000000;">举个栗子：</span> 
 </div> 
 <div>
   在网络训练中，从第二层开始，每一层的输入都是上一层的输出，所以每一层的输入和输出都不一样。 
 </div> 
 <div>
   so！！！！！！！！！！！ 
 </div> 
 <div> 
  <strong>BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布。</strong> 
 </div> 
 <h3><span style="color:#000000;"><strong>迁移学习</strong></span><span style="color:#404040;"><strong>-fine tuning</strong></span></h3> 
 <div> 
  <div> 
   <span style="color:#000000;">常见的两类迁移学习场景： </span> 
  </div> 
  <div> 
   <span style="color:#000000;">1 卷积网络当做特征提取器。使用在ImageNet上预训练的网络，去掉最后的全连接层，剩余部分当做特征提取器（例如AlexNet在最后分类器前，是4096维的特征向量）。这样提取的特征叫做CNN codes。得到这样的特征后，可以使用线性分类器（Liner SVM、Softmax等）来分类图像。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">2 Fine-tuning卷积网络。替换掉网络的输入层（数据），使用新的数据继续训练。Fine-tune时可以选择fine-tune全部层或部分层。通常，前面的层提取的是图像的通用特征（generic features）（例如边缘检测，色彩检测），这些特征对许多任务都有用。后面的层提取的是与特定类别有关的特征，因此fine-tune时常常只需要Fine-tuning后面的层。</span> 
  </div> 
  <div> 
   <span style="color:#000000;">• </span> 
   <span style="color:#000000;">有论文依据表明可以保留训练好的inception模型中所有卷积层的参数，只替换最后一层全连接层。在最后这一层全连接层之前的网络称为<strong>瓶颈层</strong></span> 
   <span style="color:#000000;">。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">• </span> 
   <span style="color:#000000;">原理：在训练好的inception模型中，因为将瓶颈层的输出再通过一个单层的全连接层，神经网络可以很好的区分1000种类别的图像，所以可以认为瓶颈层输出的节点向量可以被作为任何图像的一个更具有表达能力的特征向量。于是在新的数据集上可以直接利用这个训练好的神经网络对图像进行特征提取，然后将提取得到的特征向量作为输入来训练一个全新的单层全连接神经网络处理新的分类问题。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">• </span> 
   <span style="color:#000000;">一般来说在数据量足够的情况下，迁移学习的效果不如完全重新训练。但是迁移学习所需要的训练时间和训练样本要远远小于训练完整的模型。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">• </span> 
   <span style="color:#000000;">这其中说到inception模型，其实它是和Alexnet结构完全不同的卷积神经网络。在Alexnet模型中，不同卷积层通过串联的方式连接在一起，而inception模型中的inception结构是将不同的卷积层通过并联的方式结合在一起</span> 
  </div> 
  <div> 
   <div> 
    <span style="color:#000000;">Inception 网络是 CNN 发展史上一个重要的里程碑。在 Inception 出现之前，大部分流行 CNN仅仅是把卷积层堆叠得越来越多，使网络越来越深，以此希望能够得到更好的性能。但是存在以下问题： </span> 
   </div> 
   <div> 
    <span style="color:#000000;">1. 图像中突出部分的大小差别很大。 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">2. 由于信息位置的巨大差异，为卷积操作选择合适的卷积核大小就比较困难。信息分布更全局性的图像偏好较大的卷积核，信息分布比较局部的图像偏好较小的卷积核。 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">3. 非常深的网络更容易过拟合。将梯度更新传输到整个网络是很困难的。 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">4. 简单地堆叠较大的卷积层非常消耗计算资源。</span> 
   </div> 
   <h4><span style="color:#404040;"><strong>Inception module</strong></span></h4> 
   <div> 
    <span style="color:#000000;">解决方案： </span> 
   </div> 
   <div> 
    <span style="color:#000000;">为什么不在同一层级上运行具备多个尺寸的滤波器呢？网络本质上会变得稍微「宽一些」，而不是「更深」。作者因此设计了 Inception 模块。 </span> 
   </div> 
   <div> 
    <span style="color:#000000;"><strong>Inception 模块（</strong></span> 
    <span style="color:#000000;"><strong>Inception module ）：</strong></span> 
    <span style="color:#000000;">它使用 3 个不同大小的滤波器（1x1、3x3、5x5）对输入执行卷积操作，此外它还会执行最大池化。所有子层的输出最后会被级联起来，并传送至下一个Inception 模块。 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">一方面增加了网络的宽度，另一方面增加了网络<strong>对尺度的适应性。</strong></span> 
   </div> 
   <div> 
    <p class="img-center"><img alt="" height="359" src="https://images2.imgbox.com/e7/44/i8mDSnv6_o.png" width="972"></p> 
    <div> 
     <span style="color:#000000;"><strong>实现降维的 Inception 模块：</strong></span> 
     <span style="color:#000000;">如前所述，深度神经网络需要耗费大量计算资源。为了降低算力成本，作者在 3x3 和 5x5 卷积层之前添加额外的 1x1 卷积层，来限制输入通道的数量。尽管添加额外的卷积操作似乎是反直觉的，但是 1x1 卷积比 5x5 卷积要廉价很多，而且输入通道数量减少也有利于降低算力成本。</span> 
    </div> 
   </div> 
   <p class="img-center"><img alt="" height="434" src="https://images2.imgbox.com/7b/e8/1dKkYp8w_o.png" width="954"></p> 
   <h5 style="background-color:transparent;">1*1卷积和5*5卷积性能对比：</h5> 
   <p><a href="https://blog.csdn.net/weixin_44878336/article/details/120612186" title="[Inception V1]1×1卷积的理解_inception模型中1*1_Le0v1n的博客-CSDN博客">[Inception V1]1×1卷积的理解_inception模型中1*1_Le0v1n的博客-CSDN博客</a></p> 
   <h4><span style="color:#404040;"><strong>InceptionV1--Googlenet </strong></span></h4> 
   <div> 
    <span style="color:#000000;">1. GoogLeNet采用了Inception模块化（9个）的结构，共22层； </span> 
   </div> 
   <div> 
    <span style="color:#000000;">2. 为了避免梯度消失，网络额外增加了2个辅助的softmax用于向前传导梯度。</span> 
   </div> 
   <div> 
    <h4><span style="color:#404040;"><strong>InceptionV2 </strong></span></h4> 
    <div> 
     <span style="color:#000000;">Inception V2 在输入的时候增加了BatchNormalization： </span> 
    </div> 
    <div> 
     <span style="color:#000000;">• </span> 
     <span style="color:#000000;">所有输出保证在0~1之间。 </span> 
    </div> 
    <div> 
     <span style="color:#000000;">• </span> 
     <span style="color:#000000;">所有输出数据的均值接近0，标准差接近1的正太分布。使其落入激活函数的敏感区，避免梯度消失，加快收敛。 </span> 
    </div> 
    <div> 
     <span style="color:#000000;">• </span> 
     <span style="color:#000000;">加快模型收敛速度，并且具有一定的泛化能力。 </span> 
    </div> 
    <div> 
     <span style="color:#000000;">• </span> 
     <span style="color:#000000;">可以减少dropout的使用。</span> 
    </div> 
    <div> 
     <div> 
      <span style="color:#000000;">• </span> 
      <span style="color:#000000;">作者提出可以用</span> 
      <span style="color:#000000;"><strong>2个连续的3x3卷积层(stride=1)组成的小网络来代替单个的5x5卷积</strong></span> 
      <span style="color:#000000;"><strong>层</strong></span> 
      <span style="color:#000000;">，这便是</span> 
      <span style="color:#000000;"><strong>Inception V2</strong></span> 
      <span style="color:#000000;">结构。 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">• </span> 
      <span style="color:#000000;">5x5卷积核参数是3x3卷积核的25/9=2.78倍。</span> 
     </div> 
     <div> 
      <img alt="" class="left" height="443" src="https://images2.imgbox.com/40/49/hMZJVPXK_o.png" width="566"> 
      <img alt="" class="left" height="443" src="https://images2.imgbox.com/4c/35/Iiy9JJCR_o.png" width="504"> 
     </div> 
     <p></p> 
     <p></p> 
     <div></div> 
    </div> 
   </div> 
  </div> 
 </div> 
 <p></p> 
 <p></p> 
 <p></p> 
 <p></p> 
 <p></p> 
 <p></p> 
 <p></p> 
 <p></p> 
 <div> 
  <span style="color:#000000;">此外，作者将 n*n 的卷积核尺寸分解为 1×n 和 n×1 两个卷积。</span> 
 </div> 
 <div> 
  <p class="img-center"><img alt="" height="534" src="https://images2.imgbox.com/90/1e/aR00SyMM_o.png" width="1103"></p> 
 </div> 
 <p></p> 
 <div> 
  <span style="color:#000000;">前面三个原则用来构建三种不同类型的 Inception 模块。</span> 
 </div> 
 <div> 
  <p class="img-center"><img alt="" height="567" src="https://images2.imgbox.com/21/f9/a2OSNqyA_o.png" width="654"></p> 
  <h4><span style="color:#404040;"><strong>InceptionV3</strong></span></h4> 
  <div> 
   <span style="color:#000000;">InceptionV3 整合了前面 Inception v2 中提到的所有升级，还使用了7x7 卷积</span> 
  </div> 
 </div> 
 <p class="img-center"><img alt="" height="575" src="https://images2.imgbox.com/a9/35/CIQrkiDh_o.png" width="986"></p> 
 <div> 
  <span style="color:#000000;">Inception V3设计思想和Trick： </span> 
 </div> 
 <div> 
  <span style="color:#000000;">1：分解成小卷积很有效，可以降低参数量，减轻过拟合，增加网络非线性的表达能力。 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">2：卷积网络从输入到输出，应该让图片尺寸逐渐减小，输出通道数逐渐增加，即让空间结构化，将空间信息转化为高阶抽象的特征信息。 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">3：Inception Module用多个分支提取不同抽象程度的高阶特征的思路很有效，可以丰富网络的表达能力</span> 
 </div> 
 <h4><span style="color:#404040;"><strong>InceptionV4</strong></span></h4> 
 <div> 
  <span style="color:#000000;">1. 左图是基本的Inception v2/v3模块，使用两个3x3卷积代替5x5卷积，并且使用average pooling，该模块主要处理尺寸为35x35的feature map； </span> 
 </div> 
 <div> 
  <span style="color:#000000;">2. 中图模块使用1xn和nx1卷积代替nxn卷积，同样使用average pooling，该模块主要处理尺寸为17x17的feature map； </span> 
 </div> 
 <div> 
  <span style="color:#000000;">3. 右图将3x3卷积用1x3卷积和3x1卷积代替。 </span> 
 </div> 
 <div> 
  <span style="color:#000000;"><strong>总的来说</strong></span> 
  <span style="color:#000000;">，Inception v4中基本的Inception module还是沿袭了Inception v2/v3的结构，只是结构看起来更加简洁统一，并且使用更多的Inception module，实</span> 
 </div> 
 <div> 
  <span style="color:#000000;">验效果也更好。</span> 
 </div> 
 <p class="img-center"><img alt="" height="311" src="https://images2.imgbox.com/f4/f9/Acur01NZ_o.png" width="1200"></p> 
 <p class="img-center"><img alt="" height="683" src="https://images2.imgbox.com/81/f1/VL1SxOHq_o.png" width="585"></p> 
 <div> 
  <span style="color:#000000;">Inception模型优势： </span> 
 </div> 
 <div> 
  <span style="color:#000000;">1. 采用了1x1卷积核，性价比高，用很少的计算量既可以增加一层的特征变换和非线性变换。 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">2. 提出</span> 
  <span style="color:#000000;"><strong>Batch Normalization</strong></span> 
  <span style="color:#000000;">，通过一定的手段，把每层神经元的输入值分布拉到均值0方差1的正态分布，使其落入激活函数的敏感区，避免梯度消失，加快收敛。 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">3. 引入</span> 
  <span style="color:#000000;"><strong>Inception module</strong></span> 
  <span style="color:#000000;">，4个分支结合的结构。</span> 
 </div> 
 <h3><span style="color:#404040;"><strong>Mobilenet</strong></span></h3> 
 <p></p> 
 <div> 
  <span style="color:#000000;">MobileNet模型是Google针对手机等嵌入式设备提出的一种轻量级的深层神经网络，其使用的核心思想便是深度可分离卷积 depthwise separable convolution。</span> 
 </div> 
 <h4><span style="color:#404040;"><strong>深度可分离卷积</strong></span><span style="color:#000000;"><strong>depthwise separable convolution</strong></span></h4> 
 <div> 
  <span style="color:#000000;">通俗地理解就是3x3的卷积核厚度只有一层，然后在输入张量上一层一层地滑动，每一次卷积完生成一个输出通道，当卷积完成后，再利用1x1的卷积调整厚度。</span> 
 </div> 
 <div> 
  <p class="img-center"><img alt="" height="410" src="https://images2.imgbox.com/99/a0/C0ck6tS0_o.png" width="699"></p> 
  <div> 
   <span style="color:#000000;">对于一个卷积点而言： </span> 
  </div> 
  <div> 
   <span style="color:#000000;">假设有一个3×3大小的卷积层，其输入通道为16、输出通道为32。具体为，32个3×3大小的卷积核会遍历16个通道中的每个数据，最后可得到所需的32个输出通道，所需参数为16×32×3×3=4608个。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">应用深度可分离卷积，用16个3×3大小的卷积核分别遍历16通道的数据，得到了16个特征图谱，接着用32个1×1大小的卷积核遍历这16个特征图谱，所需参数为16×3×3+16×32×1×1=656个。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong>可以看出来depthwise separable convolution可以减少模型的参数。</strong></span> 
  </div> 
  <div> 
   <img alt="" height="666" src="https://images2.imgbox.com/98/a6/Zahw84vz_o.png" width="558"> 
   <img alt="" height="670" src="https://images2.imgbox.com/18/ee/muHqan0s_o.png" width="601"> 
  </div> 
  <h2><span style="color:#404040;"><strong>卷积神经网络设计技巧：</strong></span></h2> 
  <p><span style="color:#404040;"><strong>接下来的内容都是扯淡的，没个十年脑血栓想不出来（手动滑稽）</strong></span></p> 
  <div> 
   <div> 
    <span style="color:#000000;"><strong>1） 架构遵循应用 </strong></span> 
   </div> 
   <div> 
    <span style="color:#000000;">你也许会被 Google Brain 或者 Deep Mind 这些有想象力的实验室所发明的那些耀眼的新模型所吸引，但是其中许多要么是不可能实现的，要么是不实用的对于你的需求。<strong>或许你应该使用</strong></span> 
    <span style="color:#000000;"><strong>对你的特定应用最有意义的模型，这种模型或许非常简单，但是仍然很强大，</strong></span> 
    <span style="color:#000000;">例如 VGG。</span> 
   </div> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong>2） 路径的激增 </strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">每年ImageNet Challenge的赢家都比上一年的冠军使用更加深层的网络。从AlexNet 到Inception到Resnets，有”网络的路径数量成倍增长”的趋势。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong>3） 追求简约 </strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">更大的并不一定是更好的。（轮胎宽就是快，马力大就是好！）</span> 
  </div> 
  <div> 
   <p class="img-center"><img alt="" height="480" src="https://images2.imgbox.com/dd/f1/mYUgRO0E_o.jpg" width="600"></p> powerrrrrrrrrrrrrrr！！！！！！！！！！！！ 
  </div> 
  <div> 
   <span style="color:#000000;"><strong>4）增加对称性 </strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">无论是在建筑上，还是在生物上，对称性被认为是质量和工艺的标志。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong>5） 金字塔形状 </strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">你总是在表征能力和减少冗余或者无用信息之间权衡。CNNs通常会降低激活函数的采样，并会增加从输入层到最终层之间的连接通道。</span> 
  </div> 
  <div> 
   <div> 
    <span style="color:#000000;"><strong>6） 过渡训练 </strong></span> 
   </div> 
   <div> 
    <span style="color:#000000;">另一个权衡是训练准确度和泛化能力。用正则化的方法类似 drop-out 或 drop-path进行提升泛化能力，这是神经网络的重要优势。用比实际用例更难的问题训练网络，以提高泛化性能。 </span> 
   </div> 
   <div> 
    <span style="color:#000000;"><strong>7） 覆盖问题的空间 </strong></span> 
   </div> 
   <div> 
    <span style="color:#000000;">为了扩大训练数据和提升泛化能力，要使用噪声和人工增加训练集的大小。例如随机旋转、裁剪和一些图像增强操作。 </span> 
   </div> 
   <div> 
    <span style="color:#000000;"><strong>8） 递增的功能结构 </strong></span> 
   </div> 
   <div> 
    <span style="color:#000000;">当架构变得成功时，它们会简化每一层的“工作”。在非常深的神经网络中，每个层只会递增地修改输入。 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">在ResNets中，每一层的输出可能类似于输入。所以，在实践中，请在ResNet中使用短的跳过长度。 </span> 
   </div> 
   <div> 
    <span style="color:#000000;"><strong>9） 标准化层的输入 </strong></span> 
   </div> 
   <div> 
    <span style="color:#000000;">标准化是可以使计算层的工作变得更加容易的一条捷径，并且在实际中可以提升训练的准确性。标准化把所有层的输入样本放在了一个平等的基础上（类似于单位转换），这允许反向传播可以更有效地训练。</span> 
   </div> 
  </div> 
 </div> 
 <div> 
  <span style="color:#000000;"><strong>10）使用微调过的预训练网络（</strong></span> 
  <span style="color:#000000;"><strong>fine tuning） </strong></span> 
 </div> 
 <div> 
  <span style="color:#000000;">机器学习公司 Diffbot 的 CEO Mike Tung 说，“如果你的视觉数据和 ImageNet 相似，那么用预训练网络会帮助你学习得更快”。低水平的CNN通常可以被重复使用，因为它们大多能够检测到像线条和边缘这些常见的模式。比如，用自己设计的层替换分类层，并且用你特定的数据去训练最后的几个层。 </span> 
 </div> 
 <div> 
  <span style="color:#000000;"><strong>11）使用循环的学习率 </strong></span> 
 </div> 
 <div> 
  <span style="color:#000000;">学习率的实验会消耗大量的时间，并且会让你遇到错误。自适应学习率在计算上可能是非常昂贵的，但是循环学习率不会。使用循环学习率时，你可以设置一组最大最小边界，并且在这个范围改变它。</span> 
 </div> 
</div> 
<p></p> 
<div></div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0fb627a7c82712c646bc508ff7470b16/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Oracle客户端】PLSQL Developer 15 (64 bit)最新版安装使用教程（亲测）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e46aea712d1664fde7fe7c0a064ac28d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Unity进阶–通过PhotonServer实现人物移动和攻击–PhotonServer(五)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>