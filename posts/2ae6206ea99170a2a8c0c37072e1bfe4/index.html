<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Servlet - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Servlet" />
<meta property="og:description" content="第一：Servlet是一个运行在web服务端的java小程序
第二：它可以用于接收和响应客户端的请求
第三：要想实现Servlet功能，可以实现Servlet接口，继承GenericServlet或者HttpServlet
第四：每次请求都会执行service方法
第五：Servlet还支持配置
概述 Servlet 作用 1）接收客户端的请求
2）处理业务逻辑
3）响应给浏览器客户端
Servlet类视图 快速入门 步骤 1.创建web项目
2.导入servlet依赖
&lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;!--导入servlet依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.在创建的web项目中自定义类实现Servlet接口
4.在自定义类中实现Servlet接口中的所有的抽象方法
5.在实现Servlet接口的service方法体中书写代码处理业务逻辑
void service(ServletRequest req, ServletResponse res) 6.在web项目的核心配置文件web.xml中配置访问servlet的路径。
​ 说明：这样配置是告知tomcat有具体的Servlet类需要被访问。
7.启动tomcat
8.在浏览器中访问servlet类
实现 1.创建maven的web项目
2.导入servlet的依赖
&lt;!--servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;!--编译 测试需要，运行时不需要--&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 2.在创建的web项目中自定义类实现Servlet接口
3.在自定义类中实现Servlet接口中的所有的抽象方法
4.在实现Servlet接口的service方法体中书写代码处理业务逻辑
import javax.servlet.*; import java.io.IOException; /* 2.在创建的web项目中自定义类实现Servlet接口 */ public class HelloWorldServlet implements Servlet{ //3.在自定义类中实现Servlet接口中的所有的抽象方法 //4.在实现Servlet接口的service方法体中书写代码处理业务逻辑 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2ae6206ea99170a2a8c0c37072e1bfe4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T17:16:30+08:00" />
<meta property="article:modified_time" content="2024-01-22T17:16:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Servlet</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <hr> 
<blockquote> 
 <p>第一：Servlet是一个运行在web服务端的java小程序<br> 第二：它可以用于接收和响应客户端的请求<br> 第三：要想实现Servlet功能，可以实现Servlet接口，继承GenericServlet或者HttpServlet<br> 第四：每次请求都会执行service方法<br> 第五：Servlet还支持配置</p> 
</blockquote> 
<p></p> 
<h2><a id="_10"></a>概述</h2> 
<p></p> 
<h3><a id="Servlet__13"></a>Servlet 作用</h3> 
<p>1）接收客户端的请求<br> 2）处理业务逻辑<br> 3）响应给浏览器客户端<br> <br></p> 
<h3><a id="Servlet_18"></a>Servlet类视图</h3> 
<p><img src="https://images2.imgbox.com/e8/d6/ZcWI16js_o.png" alt="Servlet类视图.png"><br> </p> 
<h2><a id="_23"></a>快速入门</h2> 
<h3><a id="_25"></a>步骤</h3> 
<p>1.创建web项目</p> 
<p>2.导入servlet依赖</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>--导入依赖--<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span>dependencies<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span><span class="token operator">!</span>--导入servlet依赖--<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>javax.servlet<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>javax.servlet-api<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">3.0</span>.<span class="token operator"><span class="token file-descriptor important">1</span>&lt;</span>/version<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span>/dependencies<span class="token operator">&gt;</span>
</code></pre> 
<p>3.在创建的web项目中自定义类实现Servlet接口</p> 
<p>4.在自定义类中实现Servlet接口中的所有的抽象方法</p> 
<p>5.在实现Servlet接口的service方法体中书写代码处理业务逻辑</p> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> res<span class="token punctuation">)</span>  
</code></pre> 
<p>6.在web项目的核心配置文件web.xml中配置访问servlet的路径。</p> 
<p>​ 说明：这样配置是告知tomcat有具体的Servlet类需要被访问。</p> 
<p>7.启动tomcat</p> 
<p>8.在浏览器中访问servlet类</p> 
<h3><a id="_59"></a>实现</h3> 
<p>1.创建maven的web项目</p> 
<p>2.导入servlet的依赖</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>--servlet--<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span>dependency<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>javax.servlet<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>javax.servlet-api<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token number">3.0</span>.<span class="token operator"><span class="token file-descriptor important">1</span>&lt;</span>/version<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span><span class="token operator">!</span>--编译 测试需要，运行时不需要--<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>scope<span class="token operator">&gt;</span>provided<span class="token operator">&lt;</span>/scope<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span>/dependency<span class="token operator">&gt;</span>
</code></pre> 
<p>2.在创建的web项目中自定义类实现Servlet接口</p> 
<p>3.在自定义类中实现Servlet接口中的所有的抽象方法</p> 
<p>4.在实现Servlet接口的service方法体中书写代码处理业务逻辑</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>

<span class="token comment">/*
    2.在创建的web项目中自定义类实现Servlet接口
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorldServlet</span> <span class="token keyword">implements</span> <span class="token class-name">Servlet</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//3.在自定义类中实现Servlet接口中的所有的抽象方法</span>

    <span class="token comment">//4.在实现Servlet接口的service方法体中书写代码处理业务逻辑</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> servletRequest<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> servletResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"service...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">ServletConfig</span> servletConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ServletConfig</span> <span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>



    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getServletInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>5.在web项目的核心配置文件web.xml中配置访问servlet的路径。</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>?xml <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token string">"1.0"</span> <span class="token assign-left variable">encoding</span><span class="token operator">=</span><span class="token string">"UTF-8"</span>?<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>web-app <span class="token assign-left variable">xmlns</span><span class="token operator">=</span><span class="token string">"http://java.sun.com/xml/ns/javaee"</span>
           xmlns:xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>
           xsi:schemaLocation<span class="token operator">=</span><span class="token string">"http://java.sun.com/xml/ns/javaee
		  http://java.sun.com/xml/ns/javaee/web-app_3_1.xsd"</span>
           <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token string">"3.1"</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span>--
       <span class="token number">5</span>.在web项目的核心配置文件web.xml中配置访问servlet的路径。
​	    说明：这样配置是告知tomcat有具体的Servlet类需要被访问。
    --<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span>--
        <span class="token number">1</span>.<span class="token operator">&lt;</span>servlet<span class="token operator">&gt;</span> 表示将当前Servlet类注册到tomcat中，告知tomcat有一个类要被访问
    --<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>servlet<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">!</span>--
            表示当前要被访问类的标识，在当前web.xml中要唯一，helloWorldServlet属于标识符
        --<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>servlet-name<span class="token operator">&gt;</span>helloWorldServlet<span class="token operator">&lt;</span>/servlet-name<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">!</span>--
            配置要访问 的servlet类，必须是类的全路径：包名.类名。
            说明：tomcat底层通过获取这里的类全路径使用反射技术调用当前类的无参构造方法创建对象
        --<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>servlet-class<span class="token operator">&gt;</span>com.test.HelloWorldServlet<span class="token operator">&lt;</span>/servlet-class<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/servlet<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span>--
        配置要访问的servlet类的映射路径
    --<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>servlet-mapping<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">!</span>--这里要和上面的servlet-name文本值一致，这里找到上面的servlet-name--<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>servlet-name<span class="token operator">&gt;</span>helloWorldServlet<span class="token operator">&lt;</span>/servlet-name<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">!</span>--浏览器上地址栏上输入的映射路径及访问路径，这里必须加/--<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>url-pattern<span class="token operator">&gt;</span>/hello<span class="token operator">&lt;</span>/url-pattern<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>/servlet-mapping<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/web-app<span class="token operator">&gt;</span>
</code></pre> 
<p>6.启动tomcat<img src="https://images2.imgbox.com/c4/c7/YiFDYXfB_o.png" alt="在这里插入图片描述"></p> 
<p>7.在浏览器中访问servlet类<br> <img src="https://images2.imgbox.com/8f/39/I4OESQni_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="Servlet_167"></a>Servlet的执行原理</h2> 
<p>【1】执行流程<br> <img src="https://images2.imgbox.com/dd/5a/15tp12aC_o.png" alt="在这里插入图片描述"></p> 
<p>【2】原理</p> 
<p>1.当我们点击run运行的时候，tomcat之所以会启动，是因为程序入口(main方法)在tomcat中</p> 
<p>2.tomcat开始运行，会加载web项目里面的配置文件web.xml(xml解析，读取数据)</p> 
<p>主要是根据url-pattern 找到对应的servlet-class</p> 
<p>3.然后tomcat进入等待状态(永不停止，除非手动关闭)</p> 
<p>4.当用户在浏览器中输入地址：http://localhost:8080/hello就会定位到tomcat的访问的项目下面的某个servlet中</p> 
<p>5.tomcat会根据 /hello 的servlet的虚拟路径 找到HelloServlet的全限定名</p> 
<p>6.tomcat底层通过反射创建HelloServlet的对象，并调用HelloServlet的service方法：</p> 
<pre><code class="prism language-java"><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"全限定名"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Servlet</span> servlet <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//实际上HelloServlet对象，向上转型</span>
servlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h2><a id="_Servlet__3__196"></a>实现 Servlet 功能的 3 种途径</h2> 
<p><strong>第一种</strong>：实现 Servlet 接口，接口中的方法必须全部实现。<br>使用此种方式，表示接口中的所有方法在需求方面都有重写的必要。此种方式支持最大程度的自定义。<br><strong>第二种</strong>：继承 GenericServlet，service方法必须重写，其他方法可根据需求，选择性重写。<br>使用此种方式，表示只在接收和响应客户端请求这方面有重写的需求，而其他方法可根据实际需求选择性重写，使我们的开发Servlet变得简单。但是，此种方式是和HTTP协议无关的。<br><strong>第三种</strong>：继承HttpServlet，它是 javax.servlet.http 包下的一个抽象类，是 GenericServlet 的子类。<strong>如果我们选择继承HttpServlet时，只需要重写doGet和doPost方法，不要覆盖service方法。</strong><br>使用此种方式，表示我们的请求和响应需要和 HTTP 协议相关。也就是说，我们是通过 HTTP 协议来访问的。那么每次请求和响应都符合 HTTP 协议的规范。请求的方式就是 HTTP 协议所支持的方式（目前我们只知道GET和POST，而实际HTTP协议支持7种请求方式，GET POST PUT DELETE TRACE OPTIONS HEAD )。</p> 
<p></p> 
<hr> 
<h2><a id="Servlet__203"></a>Servlet 生命周期</h2> 
<br> 
<p><strong>创建</strong>：请求第一次到达 Servlet 时，对象就创建出来，并且初始化成功。只创建一次，就放到内存中。<br></p> 
<p><strong>执行</strong>：服务器提供服务的整个过程中，该对象一直存在，每次只是执行 service 方法。<br></p> 
<p><strong>销毁</strong>：当服务停止时，或者服务器宕机时，对象消亡。<br></p> 
<p>通过分析 Servlet 的生命周期我们发现，它的实例化和初始化只会在请求第一次到达 Servlet 时执行，而销毁只会在 Tomcat 服务器停止时执行，由此我们得出一个结论，Servlet对象只会创建一次，销毁一次。所以，Servlet 对象只有一个实例。如果一个对象实例在应用中是唯一的存在，那么我们就说它是单实例的，即运用了单例模式。</p> 
<p><img src="https://images2.imgbox.com/70/53/wJlPbasL_o.png" alt="在这里插入图片描述"></p> 
<p><strong>生命周期的API</strong> :</p> 
<pre><code class="prism language-java"><span class="token comment">// 1. servlet对象创建完毕，使用对象调用此方法，初始化方法，只有在第一次访问的时候执行一次</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">ServletConfig</span> servletConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2. 用户访问servlet时，调用此方法 (每次访问都会调用一次)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> servletRequest<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> servletResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 3. servlet对象销毁时，调用此方法</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <ul><li> <p><strong>创建</strong> 默认情况下 用户第一次访问时，创建servlet，执行init方法</p> </li><li> <p><strong>运行</strong>（提供服务） 用户每次访问时，都执行service方法</p> </li><li> <p><strong>销毁</strong> 服务器正常关闭时，销毁servlet，执行destroy方法</p> </li></ul> 
</blockquote> 
<p></p> 
<hr> 
<h2><a id="Servlet__237"></a>Servlet 的线程安全</h2> 
<br> 
<p>其实每一个浏览器端发送请求，就代表是一个线程，那么多个浏览器就是多个线程，所以测试的结果说明了多个线程会共享 Servlet 类成员中的数据，其中任何一个线程修改了数据，都会影响其他线程。因此，我们可以认为 <font color="red">Servlet 它不是线程安全的</font>。<br></p> 
<p>分析产生这个问题的根本原因，其实<mark>就是因为 Servlet 是单例</mark>，单例对象的类成员只会随类实例化时初始化一次，之后的操作都是改变，而不会重新初始化。<br></p> 
<p>解决这个问题也非常简单，就是在 Servlet 中定义类成员要慎重。如果类成员是共用的，并且只会在初始化时赋值，其余时间都是获取的话，那么是没问题。如果类成员并非共用，或者每次使用都有可能对其赋值，那么就要考虑线程安全问题了，把它定义到 doGet 或者 doPost 方法里面去就可以了。</p> 
<p></p> 
<hr> 
<h2><a id="ServletConfig_250"></a>ServletConfig</h2> 
<p></p> 
<h3><a id="_252"></a>基本概念</h3> 
<p>它是Servlet的配置参数对象，在Servlet规范中，允许为每个Servlet都提供一些初始化配置。所以，每个Servlet都一个自己的ServletConfig。它的作用是在Servlet初始化期间，把一些配置信息传递给Servlet。<br> </p> 
<h3><a id="_255"></a>生命周期</h3> 
<p>由于它是在初始化阶段读取了web.xml中为Servlet准备的初始化配置，并把配置信息传递给Servlet，所以生命周期与Servlet相同。这里需要注意的是，如果Servlet配置了1，那么ServletConfig也会在应用加载时创建。<br> </p> 
<h3><a id="_258"></a>常用方法</h3> 
<p><img src="https://images2.imgbox.com/4d/8c/CZ75e8t4_o.png" alt="ServletConfig对象.png"></p> 
<p></p> 
<h2><a id="ServletContext_262"></a>ServletContext</h2> 
<p></p> 
<h3><a id="_264"></a>基本介绍</h3> 
<p>ServletContext对象，它是应用上下文对象。每一个应用有且只有一个ServletContext对象。它可以实现让应用中所有Servlet间的数据共享。<br> </p> 
<h3><a id="_267"></a>生命周期</h3> 
<p>出生——活着——死亡<br>出生： 应用一加载，该对象就被创建出来了。一个应用只有一个实例对象。(Servlet和ServletContext都是单例的)<br>活着：只要应用一直提供服务，该对象就一直存在。<br>死亡：应用被卸载（或者服务器挂了），该对象消亡。<br> </p> 
<h3><a id="_270"></a>域对象概念</h3> 
<p>域对象的概念，它指的是对象有作用域，即有作用范围。<br>域对象的作用，域对象可以实现数据共享。不同作用范围的域对象，共享数据的能力不一样。<br>在Servlet规范中，一共有4个域对象。今天我们讲解的ServletContext就是其中一个。它也是我们接触的第一个域对象。它是web应用中最大的作用域，叫application域。每个应用只有一个application域。它可以实现整个应用间的数据共享功能。<br> </p> 
<h3><a id="ServletContext_273"></a>ServletContext的使用</h3> 
<p></p> 
<h4><a id="ServletContext_275"></a>ServletContext介绍</h4> 
<blockquote> 
 <p>ServletContext 是应用上下文对象。每一个应用中只有一个 ServletContext 对象。<br> 作用：可以获得应用的全局初始化参数和达到 Servlet 之间的数据共享。<br> 生命周期：应用一加载则创建，应用被停止则销毁。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ed/99/oZ4BAVja_o.png" alt="ServletContext.png"><br> </p> 
<h4><a id="_282"></a>域对象</h4> 
<blockquote> 
 <p>域对象指的是对象有作用域。也就是有作用范围。域对象可以实现数据的共享。不同作用范围的域对象，共享数据的能力也不一样。<br> 在 Servlet 规范中，一共有 4 个域对象。ServletContext 就是其中的一个。它也是 web 应用中最大的作用域，也叫 application 域。它可以实现整个应用之间的数据共享！</p> 
</blockquote> 
<p></p> 
<h4><a id="ServletContext_288"></a>ServletContext常用方法</h4> 
<pre><code>public class ServletContextDemo extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //获取ServletContext对象
        ServletContext context = getServletContext();

        //获取全局配置的globalEncoding
        String value = context.getInitParameter("globalEncoding");
        System.out.println(value);

        //获取应用的访问虚拟目录
        String contextPath = context.getContextPath();
        System.out.println(contextPath);

        //根据虚拟目录获取应用部署的磁盘绝对路径
        //获取b.txt文件的绝对路径
        String b = context.getRealPath("/b.txt");
        System.out.println(b);

        //获取c.txt文件的绝对路径
        String c = context.getRealPath("/WEB-INF/c.txt");
        System.out.println(c);

        //获取a.txt文件的绝对路径
        String a = context.getRealPath("/WEB-INF/classes/a.txt");
        System.out.println(a);


        //向域对象中存储数据
        context.setAttribute("username","zhangsan");

        //移除域对象中username的数据
        //context.removeAttribute("username");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req,resp);
    }
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b136ffc98fb4506bea3ca5930836bac0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">app测试知识</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d8ad073e5bd3b9c87dc01e2d6300fee0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Git 开发日常</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>