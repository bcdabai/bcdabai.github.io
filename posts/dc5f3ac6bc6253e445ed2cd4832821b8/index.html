<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>popen函数和system函数详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="popen函数和system函数详解" />
<meta property="og:description" content="1、popen函数
我们先用man指令查一下popen函数：
函数说明：
（1）popen()会调用fork()产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令。
（2）参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。
（3）此外，所有使用文件指针(FILE*)操作的函数也都可以使用，除了fclose()以外。
（4）如果 type 为 r，那么调用进程读进 command 的标准输出。
如果 type 为 w，那么调用进程写到 command 的标准输入。
返回值：若成功则返回文件指针，否则返回NULL，错误原因存于errno中。
**注意：**popen()会继承环境变量，通过环境变量可能会造成系统安全的问题。
具体实例：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { FILE *fp; char buffer[80]; fp = popen(&#34;cat /etc/passwd&#34;, &#34;r&#34;); fgets(buffer, sizeof(buffer), fp); printf(&#34;%s&#34;, buffer); pclose(fp); } 运行结果：
2、system函数
函数解释：
system()函数先fork一个子进程，在这个子进程中调用/bin/sh -c来执行command指定的命令。/bin/sh在系统中一般是个软链接，指向dash或者bash等常用的shell，-c选项是告诉shell从字符串command中读取要执行的命令（shell将扩展command中的任何特殊字符）。父进程则调用waitpid()函数来为变成僵尸的子进程收尸，获得其结束状态，然后将这个结束状态返回给system()函数的调用者。
返回值：
（1）当参数command是NULL的时候
在参数为NULL的情况下，system函数的返回值很简单明了，只有0和1。
返回1，表明系统的命令处理程序，即/bin/sh是可用的。
相反，如果命令处理程序不可用，则返回0。
（2）当参数command不是NULL的时候
当参数不为NULL的时候，情况有些小复杂，根据APUE这里可以分为以下三种情况：
1）如果fork等系统调用失败，或者waitpid函数发生除EINTR外的错误时，system返回-1
2）一切致使execl失败的情况下，system返回127
3）除此之外，system返回/bin/sh的终止状态
system源码：
int system(const char * cmdstring)
{
pid_t pid;
int status;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dc5f3ac6bc6253e445ed2cd4832821b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-26T09:15:04+08:00" />
<meta property="article:modified_time" content="2021-06-26T09:15:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">popen函数和system函数详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、popen函数<br> 我们先用man指令查一下popen函数：</p> 
<p>函数说明：<br> （1）popen()会调用fork()产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令。<br> （2）参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。<br> （3）此外，所有使用文件指针(FILE*)操作的函数也都可以使用，除了fclose()以外。<br> （4）如果 type 为 r，那么调用进程读进 command 的标准输出。<br> 如果 type 为 w，那么调用进程写到 command 的标准输入。<br> 返回值：若成功则返回文件指针，否则返回NULL，错误原因存于errno中。<br> **注意：**popen()会继承环境变量，通过环境变量可能会造成系统安全的问题。<br> 具体实例：</p> 
<pre><code class="language-objectivec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main()
{
    FILE *fp;
    char buffer[80];
    fp = popen("cat /etc/passwd", "r");
    fgets(buffer, sizeof(buffer), fp);
    printf("%s", buffer);
    pclose(fp);
}
</code></pre> 
<p><br> 运行结果：</p> 
<p><br> 2、system函数</p> 
<p>函数解释：<br> system()函数先fork一个子进程，在这个子进程中调用/bin/sh -c来执行command指定的命令。/bin/sh在系统中一般是个软链接，指向dash或者bash等常用的shell，-c选项是告诉shell从字符串command中读取要执行的命令（shell将扩展command中的任何特殊字符）。父进程则调用waitpid()函数来为变成僵尸的子进程收尸，获得其结束状态，然后将这个结束状态返回给system()函数的调用者。<br> 返回值：<br> （1）当参数command是NULL的时候<br> 在参数为NULL的情况下，system函数的返回值很简单明了，只有0和1。<br> 返回1，表明系统的命令处理程序，即/bin/sh是可用的。<br> 相反，如果命令处理程序不可用，则返回0。<br> （2）当参数command不是NULL的时候<br> 当参数不为NULL的时候，情况有些小复杂，根据APUE这里可以分为以下三种情况：<br> 1）如果fork等系统调用失败，或者waitpid函数发生除EINTR外的错误时，system返回-1<br> 2）一切致使execl失败的情况下，system返回127<br> 3）除此之外，system返回/bin/sh的终止状态<br> system源码：</p> 
<p>int system(const char * cmdstring)<br> {<!-- --><br> pid_t pid;<br> int status;</p> 
<p>if(cmdstring == NULL){<!-- --></p> 
<p>     return (1);<br> }</p> 
<p><br> if((pid = fork())&lt;0){<!-- --></p> 
<p>        status = -1;<br> }<br> else if(pid == 0){<!-- --><br>     execl("/bin/sh", "sh", "-c", cmdstring, (char *)0);<br>     -exit(127); //子进程正常执行则不会执行此语句<br>     }<br> else{<!-- --><br>         while(waitpid(pid, &amp;status, 0) &lt; 0){<!-- --><br>             if(errno != EINTER){<!-- --><br>                 status = -1;<br>                 break;<br>             }<br>         }<br>     }<br>     return status;<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> }</p> 
<p>当system接受的命令为NULL时直接返回，否则fork出一个子进程，因为fork在两个进程：父进程和子进程中都返回，这里要检查返回的pid，fork在子进程中返回0，在父进程中返回子进程的pid，父进程使用waitpid等待子进程结束，子进程则是调用execl来启动一个程序代替自己，execl(“/bin/sh”, “sh”, “-c”, cmdstring,(char*)0)是调用shell，这个shell的路径是/bin/sh，后面的字符串都是参数，然后子进程就变成了一个shell进程，这个shell的参数是cmdstring，就是system接受的参数。<br> ————————————————<br> 版权声明：本文为CSDN博主「Shining-LY」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/qq_37964547/article/details/79720860</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb13a770cd161f09050bda28694032d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">cmd锁定计算机代码,锁定cmd的批处理编写</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/02bc79c3a3ac5f82f44f4e76f6af41c2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CICD系列之k8s</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>