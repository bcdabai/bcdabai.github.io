<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法：流水作业调度 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法：流水作业调度" />
<meta property="og:description" content="问题：
n个作业 N={1，2，…，n}要在2台机器M1和M2组成的流水线上完成加工。每个作业须先在M1上加工，然后在M2上加工。M1和M2加工作业 i 所需的时间分别为 ai 和bi，每台机器同一时间最多只能执行一个作业。
流水作业调度问题要求确定这n个作业的最优加工顺序，使得所有作业在两台机器上都加工完成所需最少时间。最优调度应该是：
使M1上的加工是无间断的。即M1上的加工时间是所有ai之和，但M2上不一定是bi之和。
使作业在两台机器上的加工次序是完全相同的。
则得结论：仅需考虑在两台机上加工次序完全相同的调度。
最优子解结构
机器M1开始加工S中作业时，机器M2还在加工其他作业，要等时间 t 后才可利用,则：
1. 则完成S中作业所需的最短时间记为T(S,t)
2. 完成所有作业所需的最短时间为T(N,0)
3. T(N,0)=min{ai &#43; T(N-{i}, bi)}, i∈N。
ai：选一个作业i先加工，在M1的加工时间。
T(N-{i},bi}：剩下的作业要等bi时间后才能在M2上加工。注意这里函数的定义，因为一开始工作i是随机取的，M1加工完了ai之后，要开始加工bi了，这里M1是空闲的可以开始加工剩下的N-i个作业了，但此时M2开始加工bi，所以要等bi时间之后才能重新利用，对应到上面函数T(s,t)的定义的话，这里就应该表示成T(N-{i},bi), 所以最优解可表示为T(N,0)=min{ai &#43; T(N-{i}, bi)}, i∈N，即我们要枚举所有的工作i，使这个式子取到最小值。这里顺便吐槽一句：算法中会利用很多数学知识，一定要搞清楚函数的意义以及每个数学符号所代表的含义，这样不至于各种懵比。继续分析T(S,t)可得：
T(S,t)={ai &#43; T(S-{i}, bi&#43;max{t-ai,0})}, i∈S
其中：T(S-{i}, bi&#43;max{t-ai,0})：剩下的作业等bi&#43;max{t-ai,0}才能在M2加工，至于这里是怎么推导出来的呢？见下面推导：
最优子结构的证明（问题最优解包括子问题最优解）：
最优子结构：设π是N的一个最优调度，其加工顺序为π1,…, πn，其所需的加工时间为 aπ1&#43;T’(即第一个作业π1在M1上加工的时间和其它的加工时间)。记S=N-{π1}，则T’=T(S, bπ1)。
证明：由T的定义知T(S, bπ1)是对S最优的，故T’&gt;=T(S, bπ1)。若T’&gt;T(S, bπ1),设π’是作业集S在机器M2的等待时间为bπ1情况下的一个最优调度。则π1,π’2, …,π’n是N的一个调度，且该调度所需的时间为aπ1&#43;T’ &gt; aπ1&#43;T(S, bπ1)。这与π是N的最优调度矛盾。故T’&lt;=T(S, bπ1), 从而T’=T(S, bπ1)。最优子结构的性质得证。
分析：
这段证明我开始有点云里雾里的，简单来说就是要证明问题的最优解包含子问题的最优解就行了，那么这里的证明思路是先假设一个最优调度，对于他的子调度T’，因为T(S,t)被定义为是完成S中作业所需的最短时间记为T(S,t)，所以有T’&gt;=T(S, bπ1)，那么如果这个子调度这里不是最优解的话即T’&gt;T(S, bπ1)，会得出aπ1&#43;T’ &gt; aπ1&#43;T(S, bπ1)即原来假设的最优调度不符和最优调度的标准，矛盾，从而推出 T’是一定等于T(S, bπ1)，即这个子调度也是最优调度。
问题是：虽然满足最优子结构性质，也在一定程度满足子问题重叠性质。N的每个非空子集都计算一次，共2n-1次，指数级的。
为了解决这个问题引入Johnson不等式:
结论：先把所有作业的ai和bi放在一起， 从这之中选个最小的， 如果是bi的话这个作业i就放最后 ，如果是ai的话这个作业就放最前， 把这个已经安排好的作业从作业集中删除。 重复上述步骤即可。 源代码：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b7ff8bd821d7d451712047164270ee47/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-01T12:48:37+08:00" />
<meta property="article:modified_time" content="2019-11-01T12:48:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法：流水作业调度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>问题：</p> 
<p>n个作业 N={1，2，…，n}要在2台机器M1和M2组成的流水线上完成加工。每个作业须先在M1上加工，然后在M2上加工。M1和M2加工作业 i 所需的时间分别为 ai 和bi，每台机器同一时间最多只能执行一个作业。</p> 
<p>流水作业调度问题要求确定这n个作业的最优加工顺序，使得所有作业在两台机器上都加工完成所需最少时间。最优调度应该是：</p> 
<ol><li> <p>使M1上的加工是无间断的。即M1上的加工时间是所有ai之和，但M2上不一定是bi之和。</p> </li><li> <p>使作业在两台机器上的加工次序是完全相同的。<br> <img src="https://images2.imgbox.com/03/82/sWTBEseb_o.png" alt="在这里插入图片描述"><br> 则得结论：仅需考虑在两台机上加工次序完全相同的调度。<br> 最优子解结构<br> <img src="https://images2.imgbox.com/2b/9c/5viNvGIw_o.png" alt="在这里插入图片描述"><br> 机器M1开始加工S中作业时，机器M2还在加工其他作业，要等时间 t 后才可利用,则：</p> </li></ol> 
<p>1. 则完成S中作业所需的最短时间记为T(S,t)</p> 
<p>2. 完成所有作业所需的最短时间为T(N,0)</p> 
<p>3. T(N,0)=min{ai + T(N-{i}, bi)}, i∈N。</p> 
<p>ai：选一个作业i先加工，在M1的加工时间。</p> 
<p>T(N-{i},bi}：剩下的作业要等bi时间后才能在M2上加工。注意这里函数的定义，因为一开始工作i是随机取的，M1加工完了ai之后，要开始加工bi了，这里M1是空闲的可以开始加工剩下的N-i个作业了，但此时M2开始加工bi，所以要等bi时间之后才能重新利用，对应到上面函数T(s,t)的定义的话，这里就应该表示成T(N-{i},bi), 所以最优解可表示为T(N,0)=min{ai + T(N-{i}, bi)}, i∈N，即我们要枚举所有的工作i，使这个式子取到最小值。这里顺便吐槽一句：算法中会利用很多数学知识，一定要搞清楚函数的意义以及每个数学符号所代表的含义，这样不至于各种懵比。继续分析T(S,t)可得：</p> 
<p>T(S,t)={ai + T(S-{i}, bi+max{t-ai,0})}, i∈S</p> 
<p>其中：T(S-{i}, bi+max{t-ai,0})：剩下的作业等bi+max{t-ai,0}才能在M2加工，至于这里是怎么推导出来的呢？见下面推导：<br> 　　 <img src="https://images2.imgbox.com/56/59/yMB4dZax_o.png" alt="在这里插入图片描述"><br> 　　 最优子结构的证明（问题最优解包括子问题最优解）：</p> 
<p>最优子结构：设π是N的一个最优调度，其加工顺序为π1,…, πn，其所需的加工时间为 aπ1+T’(即第一个作业π1在M1上加工的时间和其它的加工时间)。记S=N-{π1}，则T’=T(S, bπ1)。</p> 
<p>证明：由T的定义知T(S, bπ1)是对S最优的，故T’&gt;=T(S, bπ1)。若T’&gt;T(S, bπ1),设π’是作业集S在机器M2的等待时间为bπ1情况下的一个最优调度。则π1,π’2, …,π’n是N的一个调度，且该调度所需的时间为aπ1+T’ &gt; aπ1+T(S, bπ1)。这与π是N的最优调度矛盾。故T’&lt;=T(S, bπ1), 从而T’=T(S, bπ1)。最优子结构的性质得证。</p> 
<p>分析：</p> 
<p>这段证明我开始有点云里雾里的，简单来说就是要证明问题的最优解包含子问题的最优解就行了，那么这里的证明思路是先假设一个最优调度，对于他的子调度T’，因为T(S,t)被定义为是完成S中作业所需的最短时间记为T(S,t)，所以有T’&gt;=T(S, bπ1)，那么如果这个子调度这里不是最优解的话即T’&gt;T(S, bπ1)，会得出aπ1+T’ &gt; aπ1+T(S, bπ1)即原来假设的最优调度不符和最优调度的标准，矛盾，从而推出 T’是一定等于T(S, bπ1)，即这个子调度也是最优调度。</p> 
<p>问题是：虽然满足最优子结构性质，也在一定程度满足子问题重叠性质。N的每个非空子集都计算一次，共2n-1次，指数级的。<br> <img src="https://images2.imgbox.com/b8/c5/2Rup8cCa_o.png" alt="在这里插入图片描述"><br> 为了解决这个问题引入Johnson不等式:<br> <img src="https://images2.imgbox.com/d6/37/jfdIt411_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/df/1c/gi5epwPn_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9f/8a/wVSlllcp_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">结论：先把所有作业的ai和bi放在一起，
从这之中选个最小的，
如果是bi的话这个作业i就放最后
，如果是ai的话这个作业就放最前，
把这个已经安排好的作业从作业集中删除。
重复上述步骤即可。
</code></pre> 
<p>源代码：</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Jobtype</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">int</span> key<span class="token punctuation">,</span>index<span class="token punctuation">;</span><span class="token comment">//key为机器所用时间，index为作业序号</span>
		<span class="token keyword">bool</span> job<span class="token punctuation">;</span><span class="token comment">//job为ture表示M1,false表示M2</span>
		<span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> Jobtype <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token comment">//重载 &lt;=</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span><span class="token punctuation">(</span>key<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">FlowShop</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> c<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> minTime <span class="token operator">=</span>  <span class="token function">FlowShop</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout<span class="token operator">&lt;&lt;</span><span class="token string">"作业在机器1上的运行时间为："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"作业在机器2上的运行时间为："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout<span class="token operator">&lt;&lt;</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>

	cout<span class="token operator">&lt;&lt;</span><span class="token string">"完成作业的最短时间为："</span><span class="token operator">&lt;&lt;</span>minTime<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"编号从0开始，作业调度的顺序为："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout<span class="token operator">&lt;&lt;</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">FlowShop</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Jobtype <span class="token operator">*</span>d <span class="token operator">=</span> <span class="token keyword">new</span> Jobtype<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">?</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">:</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//按Johnson法则分别取对应的b[i]或a[i]值作为关键字</span>
		<span class="token comment">//找作业在两台机器上处理时间小的那个作业</span>
		d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>job <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//给符合条件a[i]&lt;b[i]的放入到N1子集标记为true</span>
		d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index <span class="token operator">=</span> i<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">sort</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span>d<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对数组d按关键字升序进行排序 快排</span>

	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>k <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>job<span class="token punctuation">)</span><span class="token comment">//N1集合，ai&lt;=bi</span>
		<span class="token punctuation">{<!-- --></span>
			c<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">;</span><span class="token comment">//将排过序的数组d，取其中作业序号属于N1的从前面进入</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span><span class="token comment">//N2集合，ai&gt;bi</span>
		<span class="token punctuation">{<!-- --></span>
			c<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">;</span><span class="token comment">//属于N2的从后面进入，从而实现N1的非减序排序，N2的非增序排序</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	j <span class="token operator">=</span> a<span class="token punctuation">[</span>c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//第一个作业在M1上的处理时间</span>
	k <span class="token operator">=</span> j<span class="token operator">+</span>b<span class="token punctuation">[</span>c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//第一个作业处理完所需时间</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		j <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//M1在执行c[i]作业的同时，M2在执行c[i-1]号作业，最短执行时间取决于M1与M2谁后执行完</span>
		k <span class="token operator">=</span> j<span class="token operator">&lt;</span>k<span class="token operator">?</span>k<span class="token operator">+</span>b<span class="token punctuation">[</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span>j<span class="token operator">+</span>b<span class="token punctuation">[</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//计算最优加工时间</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">delete</span> d<span class="token punctuation">;</span>
	<span class="token keyword">return</span> k<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


</code></pre> 
<p>运行效果：<br> <img src="https://images2.imgbox.com/a5/b7/KkrcOjev_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea6dac01a1715da8c3b20a1da89eac07/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sqlserver的PIVOT和UNPIVOT</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8a6277b8c05b2d54fbe815b6d8b1728d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">构造方法可不可以被重写和重载？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>