<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C/C&#43;&#43;编程：前置声明 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C/C&#43;&#43;编程：前置声明" />
<meta property="og:description" content="什么是前置声明 所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.
一般的前置函数声明 #include &lt;iostream&gt; using namespace std; void fun(char ch, int *pValue, double dValue); void main() { int nValue = 100; double dValue = 111.22; fun(&#39;a&#39;, &amp;nValue, dValue); system(&#34;pause&#34;); } void fun(char ch, int *pValue, double dValue) { return; } 自定义类型的前置声明 声明一个将稍后在此作用域定义的类类型。直到定义出现前，此类名具有不完整类型。这些类之间允许彼此引用：
class Vector; // 前置声明 class Matrix { // ... friend Vector operator*(const Matrix&amp;, const Vector&amp;); }; class Vector { // ... friend Vector operator*(const Matrix&amp;, const Vector&amp;); }; 自定义类型的前置声明，由于编译器不知道类型的大小，所以不可以声明类型的对象。只可以利用类型声明指针和引用：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/66badc5075d524bc647739d6f31c6816/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-22T16:22:00+08:00" />
<meta property="article:modified_time" content="2022-10-22T16:22:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C/C&#43;&#43;编程：前置声明</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>什么是前置声明</h2> 
<p>所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.</p> 
<h3><a id="_2"></a>一般的前置函数声明</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>pValue<span class="token punctuation">,</span> <span class="token keyword">double</span> dValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> nValue <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> dValue <span class="token operator">=</span> <span class="token number">111.22</span><span class="token punctuation">;</span>
  <span class="token function">fun</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>nValue<span class="token punctuation">,</span> dValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
  <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>pValue<span class="token punctuation">,</span> <span class="token keyword">double</span> dValue<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_24"></a>自定义类型的前置声明</h3> 
<p><font color="red"><strong>声明一个将稍后在此作用域定义的类类型。直到定义出现前，此类名具有<code>不完整类型</code></strong></font>。这些类之间允许彼此引用：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Vector</span><span class="token punctuation">;</span> <span class="token comment">// 前置声明</span>
<span class="token keyword">class</span> <span class="token class-name">Matrix</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
    <span class="token keyword">friend</span> Vector <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Matrix<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Vector<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Vector</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
    <span class="token keyword">friend</span> Vector <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Matrix<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Vector<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>自定义类型的前置声明，由于编译器不知道类型的大小，所以不可以声明类型的对象。只可以利用类型声明指针和引用：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    B b<span class="token punctuation">;</span> <span class="token comment">// error: aggregate 'B b' has incomplete type and cannot be defined</span>
    B b1 <span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span> <span class="token comment">// error: variable 'B b1' has initializer but incomplete type</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">A</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token comment">// 内置类型</span>
  <span class="token keyword">int</span> m_nInt<span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">&amp;</span> m_nRInt<span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">*</span> m_pInt<span class="token punctuation">;</span>
 
  <span class="token comment">// 自定义类型</span>
<span class="token comment">//  B b; // error！</span>
  B<span class="token operator">*</span> m_pB<span class="token punctuation">;</span>
  B<span class="token operator">&amp;</span> m_b<span class="token punctuation">;</span>
 
<span class="token keyword">public</span><span class="token operator">:</span> 
  <span class="token function">A</span> <span class="token punctuation">(</span>B <span class="token operator">*</span>pBPara <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_nInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">m_nRInt</span><span class="token punctuation">(</span>m_nInt<span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">m_pInt</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">m_pB</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span> <span class="token function">m_b</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pBPara<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token operator">*</span>m_pB<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">*</span>pBPara<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token keyword">void</span> <span class="token function">funA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
<span class="token comment">//    m_pB-&gt;doAnything(); // build error C2027: use of undefined type 'B'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">B</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> m_n<span class="token punctuation">;</span>
 
<span class="token keyword">public</span><span class="token operator">:</span> 
  <span class="token function">B</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_n</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~B()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B::anythig()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  A objA<span class="token punctuation">;</span>
  <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如上，利用前置类型的指针想调用其成员函数，会报编译错误！那么，肿么办？请看下文。</p> 
<h4><a id="_120"></a>声明与实现分离</h4> 
<p>代码如下，声明头文件：</p> 
<pre><code class="prism language-cpp"><span class="token comment">/*
 * TestForwardDeclar.h
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">D_TESTFORWARDDECLAR_H_</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">D_TESTFORWARDDECLAR_H_</span></span>
 
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
 
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">;</span> <span class="token comment">// 前置声明自定义类型</span>
 
<span class="token keyword">class</span> <span class="token class-name">A</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token comment">// 内置类型</span>
  <span class="token keyword">int</span> m_nInt<span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">&amp;</span> m_nRInt<span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">*</span> m_pInt<span class="token punctuation">;</span>
 
  <span class="token comment">// 自定义类型</span>
<span class="token comment">//  B b; // error！</span>
  B<span class="token operator">*</span> m_pB<span class="token punctuation">;</span>
  B<span class="token operator">&amp;</span> m_b<span class="token punctuation">;</span>
 
<span class="token keyword">public</span><span class="token operator">:</span> 
  <span class="token function">A</span> <span class="token punctuation">(</span>B <span class="token operator">*</span>pBPara <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">~</span><span class="token function">A</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">funA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">B</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> m_n<span class="token punctuation">;</span>
 
<span class="token keyword">public</span><span class="token operator">:</span> 
  <span class="token function">B</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">~</span><span class="token function">B</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<p>代码如下，定义文件：</p> 
<pre><code class="prism language-cpp"><span class="token comment">/*
 * TestForwardDeclar.cpp
 */</span>
 
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"TestForwardDeclar.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
 
<span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">A</span> <span class="token punctuation">(</span>B <span class="token operator">*</span>pBPara<span class="token punctuation">)</span> 
  <span class="token operator">:</span> <span class="token function">m_nInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
  <span class="token punctuation">,</span> <span class="token function">m_nRInt</span><span class="token punctuation">(</span>m_nInt<span class="token punctuation">)</span>
  <span class="token punctuation">,</span> <span class="token function">m_pInt</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
  <span class="token punctuation">,</span> <span class="token function">m_pB</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
  <span class="token punctuation">,</span> <span class="token function">m_b</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> pBPara<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token operator">*</span>m_pB<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">*</span>pBPara<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">funA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  m_pB<span class="token operator">-&gt;</span><span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分开头文件和实现文件即可</span>
<span class="token punctuation">}</span>
 
 
<span class="token class-name">B</span><span class="token double-colon punctuation">::</span><span class="token function">B</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_n</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token class-name">B</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~B()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token class-name">B</span><span class="token double-colon punctuation">::</span><span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B::anythig()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码如下：测试文件：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"TestForwardDeclar.h"</span></span>
  
 <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
  A objA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译成功，运行结果是期望效果。</p> 
<h4><a id="_221"></a>总结</h4> 
<ul><li><strong>自定义类型前置声明时，只可以利用类型名声明指针和变量（谨记不可以声明对象或new 对象，均因为类型大小不确定，编译器无能为力）。</strong> 
  <ul><li>前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。</li><li>毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</li></ul> </li><li>若需要利用指针或引用调用前置类型的接口，必须按照声明和实现分离的方式进行编码。</li><li>而且如果特性的源文件仅使用到该类的指针和引用，也令减少<code>#include</code>的依赖：</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">// 在 MyStruct.h 中</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iosfwd&gt;</span> <span class="token comment">// 含有 std::ostream 的前置声明</span></span>
<span class="token keyword">struct</span> <span class="token class-name">MyStruct</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    <span class="token keyword">friend</span> std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword">const</span> S<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 其定义在 MyStruct.cpp 文件中提供，该文件使用 #include &lt;ostream&gt;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_239"></a>前置声明出现在局部作用域</h3> 
<p>如果前置声明出现在局部作用域，则它隐藏其外围作用域中可出现的先前声明的相同名字的类、变量、<br> 函数，以及所有其他声明：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">s</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">s</span><span class="token punctuation">;</span> <span class="token comment">// 不做任何事（s 已定义于此作用域）</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">s</span><span class="token punctuation">;</span> <span class="token comment">// 新的局部类“s”的前置声明</span>
              <span class="token comment">// 它隐藏全局的 struct s 直至此块结尾</span>
    s<span class="token operator">*</span> p<span class="token punctuation">;</span>     <span class="token comment">// 指向局部 struct s 的指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">s</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 局部 struct s 的定义</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_253"></a>注意</h3> 
<p>注意，通过作为其他声明一部分的<a href="https://zh.cppreference.com/w/cpp/language/elaborated_type_specifier" rel="nofollow">详述类型说明符</a>，也可以引入新的类名，但仅当<strong>名字查找</strong>无法找到先前声明的有此名的类时才行。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token punctuation">;</span>
<span class="token keyword">namespace</span> ns<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Y</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token class-name">T</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 声明函数 ns::f 并声明 ns::T 与 ns::Y</span>
    <span class="token keyword">class</span> <span class="token class-name">U</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// U 指代 ::U</span>
    Y<span class="token operator">*</span> p<span class="token punctuation">;</span> T<span class="token operator">*</span> q<span class="token punctuation">;</span> <span class="token comment">// 可使用到 T 和 Y 的指针及引用</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="include_264"></a>实施建议：倾向于使用<code>#include</code>，而不是<code>前置声明</code></h2> 
<p>建议： 倾向于使用<code>#include</code>，而不是<code>前置声明</code></p> 
<p>原因：</p> 
<ul><li>前置声明最大的好处是<strong>节省编译时间</strong> 
  <ul><li>前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。</li><li>前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。</li></ul> </li><li>但是带来的问题更大 
  <ul><li>前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。</li><li>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</li><li>前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。</li><li>举个例子： 
    <ul><li>一个类的实现着需要把这个类<strong>改个名字/换个命名空间</strong>。出于兼容性原本可以在原命名空间里/用原名<strong>通过using来起一个别名指向新类</strong>，然而<strong>别名不能被前置声明</strong>。。内网有一份代码改动一下子试图修改总计265个头文件，就是实现者为了要改这个类的名字而不得不去改所有的调用处。想一想，如果这265个文件分属于50个不同的团队，你得拿到50个人的同意才能提交这份改动，想不想打人？</li><li>再举一个code style中提到的，更为严重的例子——<strong>它可能导致运行时出现错误的结果：</strong></li></ul> </li></ul> </li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">// b.h:</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">B</span></span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// good_user.cc:</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"b.h"</span></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>B<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>D<span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">// calls f(B*)</span>
</code></pre> 
<p>若把#include换成前置声明，由于声明时不知道D是B的子类，test()中f(x)就会导致f(void*)被调用，而不是f(B*)。</p> 
<p>再比如，C++标准5.3.5/5中规定，<strong>delete一个不完整类型的指针时</strong>，如果这个类型有<code>non-trivial</code>的析构函数，那么这种行为是未定义的。把前置声明换成#include则能保证消除这种风险。</p> 
<blockquote> 
 <p>什么时候该用前置声明，什么时候该用 #include</p> 
</blockquote> 
<ul><li><strong>尽量避免前置声明那些定义在其他项目中的实体</strong></li><li>函数：总是使用 #include.</li><li>类模板：优先使用 #include.</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1382625e55d1312af416c01b57c0a8a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java八股文大全</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bcbe147173b39de0e5436c3ec118d572/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">重复性的计算公式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>