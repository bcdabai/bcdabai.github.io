<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android设置Toast长时间显示,及AlertDialog的使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android设置Toast长时间显示,及AlertDialog的使用" />
<meta property="og:description" content="来源：
http://hi.baidu.com/ritrachiao/blog/item/235d17fea40e528db901a0cc.html
首先简单介绍一下Toast（吐司）。这个控件的用词相当准确，它所表现出来的特征正是吐司似的弹出效果，而且非常的简单便捷。Android自带的整个Toast功能能够帮助我们编写程序的时候实现简单的提醒功能，使得程序的应用变得更加友好。
可是在使用Toast的时候，无论是使用makeText()，还是使用toast.setDuration()，在其中进行Toast显示时间的设置时，取值Toast.LENGTH_LONG，或者是Toast.LENGTH_SHORT，Toast都会只是一闪而过，显示的时间很短。如果我们需要提醒大量的信息的时候，显然这样是用Toast是很不友好的。那么，如何能够使得Toast可以长时间显示呢？
在Java中有一个类，叫做Timer，这个类可以帮我们。
示例如下：
private Toast toast = null;
private class IntroButtonListener implements OnClickListener {
@Override
public void onClick(View v) {
// TODO Auto-generated method stub
toast = Toast.makeText(StartPage.this, toastText,Toast.LENGTH_LONG);
initToast();
execToast();
}
}
private void execToast(){
Timer timer = new Timer();
timer.schedule(new TimerTask(){
@Override
public void run() {
// TODO Auto-generated method stub
initToast();
}
}, 30);
}
private void initToast(){
toast.show();
}
我在这里将Toast的示例化延迟到了触发事件是再响应，然后调用的是makeText()方法，给它设置Duration的值为Toast.LENGTH_LONG，然后将toast.show()用一个方法initToast()包起来，这么做的目的是让它显示在Timer中也会接着显示我的Toast。
这么做的逻辑是，首先先显示Toast，然后让Timer帮助再次显示Toast，这样就会出现了Toast长时间显示的效果，如果想让时间变得更长，可以修改Timer里面timer.schedule()的值，我这里设置的是30。
你可以直接Copy这段代码，这是我测试通过的。如果你真的有必要利用提醒和用户产生互动，建议不要使用Toast，可以改用Dialog，可能效果会更好些。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6a1ca58bedc37ff6f315e243b461a6da/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-06-16T21:11:00+08:00" />
<meta property="article:modified_time" content="2011-06-16T21:11:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android设置Toast长时间显示,及AlertDialog的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p>来源：</p> 
<p> <a href="http://hi.baidu.com/ritrachiao/blog/item/235d17fea40e528db901a0cc.html" rel="nofollow">http://hi.baidu.com/ritrachiao/blog/item/235d17fea40e528db901a0cc.html</a></p> 
<p> </p> 
<p><a href="http://hi.baidu.com/ritrachiao/blog/item/235d17fea40e528db901a0cc.html" rel="nofollow"></a> </p> 
<p> </p> 
<p>  首先简单介绍一下Toast（吐司）。这个控件的用词相当准确，它所表现出来的特征正是吐司似的弹出效果，而且非常的简单便捷。Android自带的整个Toast功能能够帮助我们编写程序的时候实现简单的提醒功能，使得程序的应用变得更加友好。</p> 
<p>      可是在使用Toast的时候，无论是使用makeText()，还是使用toast.setDuration()，在其中进行Toast显示时间的设置时，取值Toast.LENGTH_LONG，或者是Toast.LENGTH_SHORT，Toast都会只是一闪而过，显示的时间很短。如果我们需要提醒大量的信息的时候，显然这样是用Toast是很不友好的。那么，如何能够使得Toast可以长时间显示呢？</p> 
<p>       在Java中有一个类，叫做Timer，这个类可以帮我们。</p> 
<p>       示例如下：</p> 
<p>private Toast toast = null;</p> 
<p>private class IntroButtonListener implements OnClickListener {<!-- --></p> 
<p>        @Override<br>         public void onClick(View v) {<!-- --><br>         // TODO Auto-generated method stub<br>         toast = Toast.makeText(StartPage.this, toastText,Toast.LENGTH_LONG);<br>   <br>         initToast();<br>         execToast();<br>        }<br>}<br><br>private void execToast(){<!-- --><br>        Timer timer = new Timer();<br>        timer.schedule(new TimerTask(){<!-- --></p> 
<p>         @Override<br>         public void run() {<!-- --><br>               // TODO Auto-generated method stub<br>               initToast();<br>         }<br>   <br>        }, 30);<br>}<br><br>private void initToast(){<!-- --><br>        toast.show();<br>}</p> 
<p> </p> 
<p>      我在这里将Toast的示例化延迟到了触发事件是再响应，然后调用的是makeText()方法，给它设置Duration的值为Toast.LENGTH_LONG，然后将toast.show()用一个方法initToast()包起来，这么做的目的是让它显示在Timer中也会接着显示我的Toast。</p> 
<p>      这么做的逻辑是，首先先显示Toast，然后让Timer帮助再次显示Toast，这样就会出现了Toast长时间显示的效果，如果想让时间变得更长，可以修改Timer里面timer.schedule()的值，我这里设置的是30。</p> 
<p>      你可以直接Copy这段代码，这是我测试通过的。如果你真的有必要利用提醒和用户产生互动，建议不要使用Toast，可以改用Dialog，可能效果会更好些。</p> 
<p>       Dialog dialog = new AlertDialog.Builder(StartPage.this)<br>           .setTitle("提示")<br>           .setMessage(toastText)<br>          .setPositiveButton("确定", new DialogInterface.OnClickListener() {<!-- --><br>           public void onClick(DialogInterface dialog,int whichButton){<!-- --><br>                    dialog.cancel();<br>            }<br>          }).create();<br>          dialog.show();</p> 
<p>         这种对话框是只显示确定的对话框，也就是提示对话框，我们可以根据这个对话框写法的构造，给它添加成可以有选择功能的对话框：</p> 
<p>Dialog dialog = new AlertDialog.Builder(ContactsSettingPage.this).setTitle(<br>    "提示").setMessage("确定删除此项？").setPositiveButton("确定",<br>     new DialogInterface.OnClickListener() {<!-- --><br>      public void onClick(DialogInterface dialog,<br>        int whichButton) {<!-- --></p> 
<p>      <span style="color: #0000ff;">//需要做的事情.....</span></p> 
<p>        }<br>    <span style="color: #ff0000;"><span style="color: #000000;">})</span>.setNegativeButton("取消", <br>      new DialogInterface.OnClickListener() { <br>       @Override<br>       public void onClick(DialogInterface dialog, int which) {<!-- --><br>        // TODO Auto-generated method stub<br>        dialog.cancel();<br>       }<br>     }).</span>create();<br>    dialog.show();</p> 
<p>       显然红色字体是我添加的内容，也就是多出来了一个“取消”按钮，这样就可以进行对话框的选择了。如果你想在确定之后做些什么，那就在蓝色的地方添加需要做的事情就好了。这样扩展对话框正好是设计模式中的装饰者模式，这样的设计具有非常便利的好处，面向对象的优越性跃然而出！</p> 
<p>       根据这样的推断，如果你还想添加其他神马按钮，不妨可以模仿试一试~</p> 
<p> </p> 
<p>以下代码请忽略：</p> 
<p> </p> 
<p><textarea name="code" class="c-sharp">		
		ConnectivityManager connMgr = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);
		if (connMgr.getNetworkInfo(0).isConnected()) {
			AlertDialog.Builder builder = new AlertDialog.Builder(this);
			builder.setMessage("你现在使用的不是电信提供的Wifi接入点，继续访问电信相关业务可能会失败，是否继续？")
			       .setCancelable(false)
			       .setPositiveButton("继续", new DialogInterface.OnClickListener() {
			           public void onClick(DialogInterface dialog, int id) {
			                dialog.cancel();
			                Intent i = new Intent();
			                i.setData(Uri.parse("http://www.baidu.com"));
			                startActivity(i);
			                ENet.this.finish();
			           }
			       })
			       .setNegativeButton("退出", new DialogInterface.OnClickListener() {
			           public void onClick(DialogInterface dialog, int id) {
			                ENet.this.finish();
			           }
			       });
			AlertDialog alert = builder.create();
			alert.show();
			
		}</textarea> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/93a3f94604fd7f9a27264013556af830/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深入分析Linux内核源码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6bf29dce84077cf9bd123dfacbfabec2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">(转)C# 数组转string,string数组</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>