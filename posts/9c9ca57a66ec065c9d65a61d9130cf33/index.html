<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解Socket套接字原理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入理解Socket套接字原理" />
<meta property="og:description" content="Socket套接字原理 1、什么是Socket 在计算机领域，套接字Socket作为计算机之间进行通信的固定的约定方式之一存在。这种太抽象了，我举个例子，我们要是用笔记本电脑前需要先对电脑供电，那供电就有两种方式电线插座供电和电池供电，电网有电就用插座供电，电网没电就用笔记本的自带的电池供电。那么这个供电的工具（电池或者电线插座）就是套接字Socket。
Socket起源于Linux系统 ，我们都知道Linux是以文件系统进行存在。在linux里万物皆文件，就连进程都成为了一种数据结构，设备也被视为一个文件可以读写。在我看来Socket对于计算机就是实现这种模式的工具，Socket的函数就是实现对通信的操作来实现网络通信。
Socket作为中间件几乎支持所有协议使用
2、Socket如何实现网络通信 学过计网的都知道，对于计算机本地通信之间的通信是由进程实现的。
2.1、本地进程的通信方式 常见就只有几种。消息队列、管道、进程管理器、信号量等
消息队列 ，按照普通队列方式完成多进程之间的数据传递（multiprocessing模块的Queue）
管道 ，文件的一种，本质是一个固定大小的缓冲区，在Linux中缓冲区大小为4kb。
管道工作原理：假设两个进程之间需要通讯，前面的进程对缓冲区进行文件写操作，后面的进程对文件进行读操作，就这样前面写后面读，两个进程就通过管道完成通信。
#这里提供一个演示文本 import datetime from multiprocessing import Process,Pipe import time from charset_normalizer import constant num=0 def sendMsg(p): now=str(datetime.datetime.now()) # p.name msg=&#34;管道传输的数据&#34; # name=psutil.Process(os.getpid()).name() print(&#34;这个是独立子进程 &#34;&#43;now&#43;&#34;数据是 :&#34;&#43;msg) p.send(msg) print(&#34;数据发送成功&#34;) p.close() def receiveMsg(p): print(&#34;接受管道传输信息：&#34;,p.recv()) if __name__==&#39;__main__&#39;: print(&#34;-----------start---------&#34;) # (grandPipe,parentPipe)=Pipe() (parentPipe,sonPipe)=Pipe() task1=Process(target=sendMsg,args=[parentPipe]) task1.start() task3=Process(target=sendMsg,args=[parentPipe],name=&#34;task1&#34;) task3.start() task2=Process(target=receiveMsg,args=[sonPipe],name=&#34;task2&#34;) task2.start() time.sleep(5) print(&#34;-----------end---------&#34;) 远程过程调用、共享内存、同步等
2.2、网络中进程的通信方式 要理解网络进程通讯，我们要先解决两个问题
如何标定一台主机，我们需要直到需要通信的进程在哪一个主机上运行？如何标定唯一进程，本地进程通讯可以通过pid区别，在网络上怎么区别？ TCP/IP协议族会解决第一个问题，定位通讯主机；而网络七层的传输层利用三元组（ip、端口、协议）则可以解决第二个问题
2.3、Socket实现通信的过程 现在我们已经知道网络中进程如何通信的，那么如何去实现他就是Socket的作用了。
Socket就如定义一般，是作为三元组解决网络通信中的中间件工具，就目前程序来说大部分都是采用Socket套接字中间件去实现网络中进程的通讯
Socket通信的传输方式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9c9ca57a66ec065c9d65a61d9130cf33/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-04T11:25:00+08:00" />
<meta property="article:modified_time" content="2022-04-04T11:25:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解Socket套接字原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Socket_0"></a>Socket套接字原理</h3> 
<h4><a id="1Socket_2"></a>1、<strong>什么是Socket</strong></h4> 
<p>在计算机领域，套接字Socket作为计算机之间进行通信的固定的约定方式之一存在。这种太抽象了，我举个例子，<strong>我们要是用笔记本电脑前需要先对电脑供电，那供电就有两种方式电线插座供电和电池供电，电网有电就用插座供电，电网没电就用笔记本的自带的电池供电。那么这个供电的工具（电池或者电线插座）就是套接字Socket</strong>。</p> 
<p><strong>Socket起源于Linux系统</strong> ，我们都知道Linux是以文件系统进行存在。在linux里万物皆文件，就连进程都成为了一种数据结构，设备也被视为一个文件可以读写。在我看来Socket对于计算机就是实现这种模式的工具，Socket的函数就是实现对通信的操作来实现网络通信。</p> 
<p>Socket作为中间件几乎支持所有协议使用</p> 
<h4><a id="2Socket_12"></a>2、Socket如何实现网络通信</h4> 
<p>学过计网的都知道，对于计算机本地通信之间的通信是由进程实现的。</p> 
<h5><a id="21_16"></a>2.1、<strong>本地进程的通信方式</strong></h5> 
<p>常见就只有几种。消息队列、管道、进程管理器、信号量等</p> 
<ol><li> <p><strong>消息队列</strong> ，按照普通队列方式完成多进程之间的数据传递（multiprocessing模块的Queue）</p> </li><li> <p><strong>管道</strong> ，文件的一种，本质是一个固定大小的缓冲区，在Linux中缓冲区大小为4kb。</p> <p><strong>管道工作原理</strong>：假设两个进程之间需要通讯，前面的进程对缓冲区进行文件写操作，后面的进程对文件进行读操作，就这样前面写后面读，两个进程就通过管道完成通信。</p> <pre><code class="prism language-python"><span class="token comment">#这里提供一个演示文本</span>
<span class="token keyword">import</span> datetime
<span class="token keyword">from</span>  multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span>Pipe
<span class="token keyword">import</span> time

<span class="token keyword">from</span> charset_normalizer <span class="token keyword">import</span> constant

num<span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">def</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>
    now<span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">(</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># p.name</span>
    msg<span class="token operator">=</span><span class="token string">"管道传输的数据"</span>
    <span class="token comment"># name=psutil.Process(os.getpid()).name()</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这个是独立子进程 "</span><span class="token operator">+</span>now<span class="token operator">+</span><span class="token string">"数据是 :"</span><span class="token operator">+</span>msg<span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数据发送成功"</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">receiveMsg</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"接受管道传输信息："</span><span class="token punctuation">,</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-----------start---------"</span><span class="token punctuation">)</span>
    <span class="token comment"># (grandPipe,parentPipe)=Pipe()</span>
    <span class="token punctuation">(</span>parentPipe<span class="token punctuation">,</span>sonPipe<span class="token punctuation">)</span><span class="token operator">=</span>Pipe<span class="token punctuation">(</span><span class="token punctuation">)</span>

    task1<span class="token operator">=</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>sendMsg<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">[</span>parentPipe<span class="token punctuation">]</span><span class="token punctuation">)</span>
    task1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    task3<span class="token operator">=</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>sendMsg<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">[</span>parentPipe<span class="token punctuation">]</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">"task1"</span><span class="token punctuation">)</span>
    task3<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    task2<span class="token operator">=</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>receiveMsg<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">[</span>sonPipe<span class="token punctuation">]</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">"task2"</span><span class="token punctuation">)</span>
    task2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>


    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-----------end---------"</span><span class="token punctuation">)</span>
</code></pre> </li><li> <p>远程过程调用、共享内存、同步等</p> </li></ol> 
<h5><a id="22_70"></a>2.2、<strong>网络中进程的通信方式</strong></h5> 
<p>要理解网络进程通讯，我们要先解决两个问题</p> 
<ol><li>如何标定一台主机，我们需要直到需要通信的进程在哪一个主机上运行？</li><li>如何标定唯一进程，本地进程通讯可以通过pid区别，在网络上怎么区别？</li></ol> 
<p>TCP/IP协议族会解决第一个问题，定位通讯主机；而网络七层的传输层利用三元组（ip、端口、协议）则可以解决第二个问题</p> 
<h5><a id="23Socket_81"></a>2.3、Socket实现通信的过程</h5> 
<p>现在我们已经知道网络中进程如何通信的，那么如何去实现他就是Socket的作用了。</p> 
<p><strong>Socket就如定义一般，是作为三元组解决网络通信中的中间件工具，就目前程序来说大部分都是采用Socket套接字中间件去实现网络中进程的通讯</strong></p> 
<p><strong>Socket通信的传输方式</strong></p> 
<ol><li><strong>SOCK_STREAM</strong> ,面向连接数据传输方式，数据可以准确无误达到另外一台计算机。如有丢失损坏，允许重新发送，但是效率慢。Http协议使用的就是该套接字进行传输的，毕竟浏览器要解析网页，数据就不能出现错误的地方</li><li><strong>SOCK_DGRAM</strong> , 表示面向无连接的数据传输方式，不做数据校验。如果数据在传输过程中损坏，没有办法补救，错了就是错了。我们使用qq和微信的时候使用的就是该种套接字</li></ol> 
<h4><a id="3TCPIP_94"></a>3、加入套接字后去理解TCP/IP</h4> 
<p>TCP协议作为一种面向连接的可靠字节流通信协议，数据在传输前要建立连接，建立连接传输后还要断开连接。用TCP建立连接目的就是保证ip、端口和物理线路正确开辟传输通道，</p> 
<p><strong>我们建立连接三次握手通过套接字可以抽象成如下场景</strong></p> 
<blockquote> 
 <p>1、客户端发送建立连接请求发送SYN报文，套接字A向套接字B表示A要连接传送数据</p> 
 <p>2、服务端接受SYN报文返回客户端ACk确认报文和SYN报文，套接字B表示我已经就绪</p> 
 <p>3、客户端接受ACK报文然后向服务端发送ACK确认报文，套接字A表示感谢B的支持</p> 
</blockquote> 
<p><strong>对于TCP四次握手断开连接</strong></p> 
<p>TCP断开连接是可以通过关闭套接字来实现断开连接</p> 
<blockquote> 
 <p>1、客户端发送FIN报文,套接字B向套接字A表示我要断开连接</p> 
 <p>2、服务端接受FIn后向客户端发送ACK确认报文，套接字A向套接字B表示我知道了正在处理</p> 
 <p>3、服务端完成断开连接处理后向客户端发送Fin终止报文，套接字A向套接字B表示我已处理好断开连接操作B你可以断开了</p> 
 <p>4、客户端接受FIN后再向服务端发送ACK确认报文，套接字B向套接字A表示好的我会断开连接然后等待数秒断开连接</p> 
</blockquote> 
<h5><a id="31TCPSocket_120"></a>3.1、TCP使用Socket所导致的粘包现象</h5> 
<p><strong>什么是粘包</strong></p> 
<p>多个要发送的数据包被联系存储与连续的缓存中，如果接收方对发过来的数据进行读取时没能确定发送方的发送边界（连续几个数据包为一个完整数据没法确定），<strong>而是采用估测方式假定边界值（发送方认为5个数据包为一个完整数据，而接收方认为6个包为一个完整数据）</strong>，最后就会导致<strong>发送方发送的多个数据包在接收方处被视为一个数据包</strong>，</p> 
<p><strong>为什么需要考虑粘包</strong></p> 
<p>我们假设发送方需要像接受方发送两条信息</p> 
<p>hello this message、you can not use this message，如果发生粘包现象发生，就会出现hello this messageyoucan not use this message,这样接收方就不知道这个信息是什么意思，处理不了。</p> 
<p><strong>出现粘包的原因</strong></p> 
<p>出现粘包的原因发送方和接收方都有责任，</p> 
<ul><li> <p><strong>发送方的粘包原因</strong></p> <p>发送方主责是TCP协议本身所造成的，TCP作为注重传输效率的协议，发送前会收集一定量的数据才能去发送。若是连续几次的发送的数据量变少，之后的传输中TCP的优化算法会把类似这种情况的数据都合成一包数据发送出去，不会考虑后果**（毕竟TCP协议只是一个打工人只考虑效益**），这就会导致接收方收到的粘连数据</p> </li><li> <p><strong>接收方的粘包原因</strong></p> <p>接收方粘包主责在于使用此连接用户进程没有即时处理数据包。接收方一般接收数据后会先将数据存往一个缓冲区，使用连接的用户进程从缓冲区读取数据。 <strong>若是进程读取速度过慢，上一包和下一包数据会一起在缓冲区存储着，如果用户进程这个时候去读，就会获得多包数据造成粘连</strong></p> </li></ul> 
<p><strong>如何解决粘包现象</strong></p> 
<ul><li>如果是发送发导致粘包现象，用户可以通过编程设置避免。TCP提供push强推送指令，一旦接受就立刻发出缓冲区数据，而不是等待缓冲区充满。</li><li>对于接收方导致的粘包现象，用户可以通过优化程序设计、精简接受进程的工作量提高数据发送的优先级来避免粘包</li><li>或者发送时机选择由接收方控制，人为的进行多次接收数据然后合并关联数据避免粘包</li></ul> 
<p>以上三种解决粘包现象的方法都有缺点，要么影响程序执行性能要么影响发送效率，或者在实际业务场景中不实用。</p> 
<h5><a id="32TCP_158"></a>3.2、套接字如何断开TCP连接</h5> 
<p>套接字关闭是通过程序调用函数直接将套接字描述符从内存清除，然后再也不使用该套接字。<strong>套接字关闭后，通过该套接字的连接和缓存区自然失去了连接意义，TCP协议检测到套接字消失会自动执行关闭连接的操作。</strong></p> 
<p><strong>默认情况下close()/closesocket()是调用关闭套接字的函数，shutdown()则是用来关闭连接的。</strong></p> 
<ul><li>close()/closesocket()，调用即关闭套接字即向对端发送断开连接FIN包，所以会丢失缓存区的数据。</li><li>shutdown()，用来关闭TCP连接，会等到缓存区没有数据包内容时执行断开连接操作。</li></ul> 
<p>对于程序来说无论是调用close()/closesocket()还是shutdown()，计算机都会向对端发送FIN包请求断开连接。</p> 
<h4><a id="4OSI_173"></a>4、导入套接字后理解OSI七层模型</h4> 
<p><img src="https://images2.imgbox.com/72/93/Qwo3u0og_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="5Socketpython38_178"></a>5、Socket套接字函数与原理（基于python3.8）</h4> 
<p>Socket套接字是建立连接的中间件，而连接成立的前提就是有两台机器存在，所以Socket的使用方式也存在两种。一般这两端是服务器端和客户端。</p> 
<p><strong>同时两端创建socket时需要指定三种元素，ip地址协议类型、传输方式和使用的协议</strong>，其中协议指定为非必要，不指定默认是TCP</p> 
<h5><a id="51_184"></a>5.1、服务器端</h5> 
<ul><li> <p><strong>创建socket套接字的，socket()</strong></p> </li><li> <p><strong>对socket绑定端口号和地址的，bind(),端口号和地址作为一组数据传入bind</strong></p> </li><li> <p><strong>表示开始监听对端通讯的，listen()</strong></p> <p>listen只是让套接字出于监听状态，要接受请求的话还得执行accept</p> </li><li> <p><strong>被动接受TCP客户端连接请求的，accept()</strong></p> </li><li> <p><strong>从请求中接受数据指定接受量的，recv()</strong></p> </li><li> <p><strong>关闭同时停止当前socket的，close()</strong></p> </li></ul> 
<h5><a id="52_200"></a>5.2、客户端</h5> 
<ul><li><strong>创建socket的，socket()</strong></li><li><strong>主动连接指定地址与端口的，connect()</strong></li><li><strong>向套接字中写入数据进行发送到套接字进行发送的，send()、sendall()</strong></li><li><strong>关闭本端socket使用的，close()</strong></li></ul> 
<h4><a id="53_207"></a>5.3、扩展</h4> 
<p>socket本身作为一个中间件也支持udp协议，具体流程与TCP类似主要是服务器端和客户端用于数据处理的函数被替换为recvfrom()和sendto()</p> 
<p>除此之外还有一些返回内容</p> 
<table><thead><tr><th>s.getpeername()</th><th>返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</th></tr></thead><tbody><tr><td>s.getsockname()</td><td>返回套接字自己的地址。通常是一个元组(ipaddr,port)</td></tr><tr><td>s.setsockopt(level,optname,value)</td><td>设置给定套接字选项的值。</td></tr><tr><td>s.getsockopt(level,optname[.buflen])</td><td>返回套接字选项的值。</td></tr><tr><td>s.settimeout(timeout)</td><td>设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</td></tr><tr><td>s.gettimeout()</td><td>返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。</td></tr><tr><td>s.fileno()</td><td>返回套接字的文件描述符。</td></tr><tr><td>s.setblocking(flag)</td><td>如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。</td></tr><tr><td>s.makefile()</td><td>创建一个与该套接字相关连的文件</td></tr></tbody></table> 
<h4><a id="6Socket_224"></a>6、用代码实现套接字Socket的实例</h4> 
<p>python3.8，我们可以用代码模拟socket工作流程</p> 
<pre><code class="prism language-python"><span class="token comment">#socketServerTest.py 服务端代码</span>

<span class="token keyword">import</span> socket


<span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    s1<span class="token operator">=</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
    s2 <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
    <span class="token comment">#选择使用ipv4地址方式以及流模式传递数据，如果是ipv6则对应AF_INET6</span>
 
    <span class="token comment"># host=socket.gethostname()</span>
    <span class="token comment"># port=6999</span>
    <span class="token comment"># # print(host)</span>
    s1<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'LAPTOP-SRMA7P3L'</span><span class="token punctuation">,</span><span class="token number">6999</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    s2<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'LAPTOP-SRMA7P3L'</span><span class="token punctuation">,</span><span class="token number">6998</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#这是绑定要监听的接口，我通过gethost获取到本机计算机地址</span>
    s1<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment">#开始监听，允许使用五个连接排队</span>
    s2<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        c1<span class="token punctuation">,</span>addr1<span class="token operator">=</span>s1<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#服务器端等待连接</span>
        c2<span class="token punctuation">,</span>addr2<span class="token operator">=</span>s2<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment"># print(c1,addr1)</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                data1 <span class="token operator">=</span> c1<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token comment">#接受客户端数据</span>
                data2 <span class="token operator">=</span> c2<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'reieve '</span><span class="token punctuation">,</span>data1<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>data2<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#打印数据</span>
                c1<span class="token punctuation">.</span>send<span class="token punctuation">(</span>data1<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#发送数据</span>
                c2<span class="token punctuation">.</span>send<span class="token punctuation">(</span>data2<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">except</span> ConnectionError <span class="token keyword">as</span> e<span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'关闭正在展现连接'</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span>
        c1<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
        c2<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>
    function<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-python"><span class="token comment">#socketClientTest01.py 第一个客户端代码</span>
<span class="token keyword">import</span> socket

<span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    client <span class="token operator">=</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
    client<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'LAPTOP-SRMA7P3L'</span><span class="token punctuation">,</span><span class="token number">6999</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        msg<span class="token operator">=</span><span class="token string">'clinet1Msg'</span>
        client<span class="token punctuation">.</span>send<span class="token punctuation">(</span>msg<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        data<span class="token operator">=</span>client<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'recv: '</span><span class="token punctuation">,</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    client<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    function<span class="token punctuation">(</span><span class="token punctuation">)</span>
    

<span class="token comment">#socketClientTest02.py 第二个客户端代码</span>
<span class="token keyword">import</span> socket

<span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    client <span class="token operator">=</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
    client<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'LAPTOP-SRMA7P3L'</span><span class="token punctuation">,</span><span class="token number">6998</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        msg<span class="token operator">=</span><span class="token string">'clinet2Msg'</span>
        client<span class="token punctuation">.</span>send<span class="token punctuation">(</span>msg<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        data<span class="token operator">=</span>client<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'recv: '</span><span class="token punctuation">,</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    client<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    function<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>都运行起来后服务端控制台会打印如下内容</p> 
<blockquote> 
 <p>reieve clinet1Msg clinet2Msg</p> 
</blockquote> 
<p><strong>参考文章</strong></p> 
<p><a href="https://blog.csdn.net/binghuazh/article/details/4222516">Socket粘包问题_blingpro的博客-CSDN博客</a></p> 
<p><a href="http://c.biancheng.net/view/vip_5864.html" rel="nofollow">面向连接和无连接的套接字到底有什么区别 (biancheng.net)</a></p> 
<p><a href="https://blog.csdn.net/Nice07/article/details/83515660">什么是粘包？socket 中造成粘包的原因是什么？ 粘包的处理方式_Nice07的博客-CSDN博客_什么是粘包</a></p> 
<p><a href="https://blog.csdn.net/hzlnice/article/details/84591508?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_antiscanv2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">进程间通信的几种方式_古越少年的博客-CSDN博客_进程间的通信方式三种</a></p> 
<p><a href="https://www.jianshu.com/p/066d99da7cbd" rel="nofollow">一、Socket技术详解 - 简书 (jianshu.com)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8a88aecdbe9c6d59a9e1b7cc047e93a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">web测试基础知识（一）web基础</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e0d8182e4af941dd023d408129f43030/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第十六章：红黑树模拟实现STL中的map与set</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>