<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>opencv#30 线性滤波 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="opencv#30 线性滤波" />
<meta property="og:description" content="均值滤波原理 均值滤波步骤 Step1:求和。
Step2:计算平均值。
所谓均值滤波，就是求平均值的意思。我们假设在一个3*3的范围内有一个图像，其中这个图像每一个像素可能含有噪声，也可能不含噪声，我们是不知道的，因此通过均值滤波的方式，对图像中所有像素进行求和，并除以像素个数，得到的结果就是滤波后的结果，将3*3区域的中心位置更改为滤波后的平均值，这样的过程就是均值滤波。
均值滤波和图像的卷积操作相类似，它们都是在原图像中将每一个像素分别覆盖滤波模板，也可称为滤波器，覆盖原图像后求取平均值，放入中心区域作为滤波结果，然后移动滤波器，使滤波器能够覆盖图像的每一个位置。对于上图3*3的矩阵来说，其中每一个位置都乘了1，也就是说它进行卷积的模板是一个3*3的矩阵，此矩阵中的值都为1，之后又除以了和，因此它的卷积模板（滤波器）就是一个1/9乘全为1的矩阵（3*3）。
均值滤波函数 blur() void cv::blur(InuputArray src, OutputArray dst, Size ksize, Point anchor = Point(-1,-1), int borderType = BORDER_DEFAULT ) ·src:待均值滤波的图像，图像数据类型必须是CV_8U,CV_16U,CV_16S,CV_32F和CV_64F这五种数据类型之一。均值滤波输出的结果的数据类型与输入图像的数据类型保持一致。
·dst:均值滤波后的图像，与输入图像具有相同的尺寸和数据类型。
·ksize:卷积核尺寸（滤波器尺寸：常用的是奇数正方形）。因为均值滤波中，滤波器中的每一位参数值是恒定的，因此这里面我们只需给出其尺寸即可。
·anchor:内核的基准点（锚点），其默认值为（-1，-1）代表内核基准点位于kernel的中心位置。·borderType:像素外推法选择标志。
方框滤波函数 boxFilter() void cv::boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor = Point(-1,-1), bool normalize = true, int borderType = BORDER_DEFAULT ) 方框滤波函数与均值滤波其实是等价的，只不过方框滤波运行滤波器不进行归一化，但是在均值滤波中是强制进行归一化的。 由于方框滤波是一个求和的参数，可能会出现255&#43;255&#43;255&#43;....很多个255相加，最终超出255范围的情况，因此第三个参数运行用户设定输出图像的数据类型，也就是输出图像的数据类型可以与输入图像不同，但是尺寸和通道数是一致的。
·src:输入图像。
·dst:输出图像，与输入图像具有相同的尺寸和通道数。
·ddepth:输出图像的数据类型（深度），根据输入图像的数据类型不同拥有不同的取值范围。
·ksize:卷积核尺寸。
·anchor:内核的基准点（锚点），其默认值为（-1，-1）代表内核基准点位于kernel的中心位置。
·normalize:是否将卷积核进行归一化的标志，默认参数为true，表示进行归一化（在矩阵前面乘所有数值之和）。
·borderType:像素外推法选择标志。
高斯滤波原理 高斯滤波也就是滤波器是一个高斯分布的形式，如上图所示，滤波器中中间的像素值较大，而四周像素值较小的情况，是一个中心对称的滤波器。若以这样的滤波器作为卷积核与原图像进行卷积操作的时候，得到的就是一个高斯滤波之后的结果 。
高斯滤波函数 GaussianBlur() void cv::GaussianBlur(InputArray src, OutputArray dst, Size xsize, double sigmaX, double sigmaY = 0, int borderType = BORDER_DEFAULT ) ·src:待高斯滤波图像，数据类型必须为CV_8U,CV_16U,CV_16S,CV_32F或CV_64F。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0e3c8a26ab2368d000a32d8f1bdf9179/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T12:50:49+08:00" />
<meta property="article:modified_time" content="2024-01-22T12:50:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">opencv#30 线性滤波</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>均值滤波原理</h2> 
<h3>均值滤波步骤</h3> 
<p>Step1:求和。</p> 
<p>Step2:计算平均值。</p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/6d/37/x6TX77wy_o.png" width="1007"></p> 
<p>     所谓均值滤波，就是求平均值的意思。我们假设在一个3*3的范围内有一个图像，其中这个图像每一个像素可能含有噪声，也可能不含噪声，我们是不知道的，因此通过均值滤波的方式，对图像中所有像素进行求和，并除以像素个数，得到的结果就是滤波后的结果，将3*3区域的中心位置更改为滤波后的平均值，这样的过程就是均值滤波。</p> 
<p>     均值滤波和图像的卷积操作相类似，它们都是在原图像中将每一个像素分别覆盖滤波模板，也可称为滤波器，覆盖原图像后求取平均值，放入中心区域作为滤波结果，然后移动滤波器，使滤波器能够覆盖图像的每一个位置。对于上图3*3的矩阵来说，其中每一个位置都乘了1，也就是说它进行卷积的模板是一个3*3的矩阵，此矩阵中的值都为1，之后又除以了和，因此它的卷积模板（滤波器）就是一个1/9乘全为1的矩阵（3*3）。</p> 
<h3>均值滤波函数</h3> 
<h3>blur()</h3> 
<pre><code class="language-cpp">void cv::blur(InuputArray   src,
              OutputArray   dst,
              Size          ksize,
              Point         anchor = Point(-1,-1),
              int           borderType = BORDER_DEFAULT
             )</code></pre> 
<p><strong>·</strong>src:待均值滤波的图像，图像数据类型必须是CV_8U,CV_16U,CV_16S,CV_32F和CV_64F这五种数据类型之一。均值滤波输出的结果的数据类型与输入图像的数据类型保持一致。</p> 
<p><strong>·</strong>dst:均值滤波后的图像，与输入图像具有相同的尺寸和数据类型。</p> 
<p><strong>·</strong>ksize:卷积核尺寸（滤波器尺寸：常用的是奇数正方形）。因为均值滤波中，滤波器中的每一位参数值是恒定的，因此这里面我们只需给出其尺寸即可。</p> 
<p><strong>·</strong>anchor:内核的基准点（锚点），其默认值为（-1，-1）代表内核基准点位于kernel的中心位置。<strong>·</strong>borderType:像素外推法选择标志。</p> 
<h3>方框滤波函数</h3> 
<h3>boxFilter()</h3> 
<pre><code class="language-cpp">void cv::boxFilter(InputArray   src,
                   OutputArray  dst,
                   int          ddepth,
                   Size         ksize,
                   Point        anchor = Point(-1,-1),
                   bool         normalize = true,
                   int          borderType = BORDER_DEFAULT
                  )</code></pre> 
<p>     方框滤波函数与均值滤波其实是等价的，只不过方框滤波运行滤波器不进行归一化，但是在均值滤波中是强制进行归一化的。 由于方框滤波是一个求和的参数，可能会出现255+255+255+....很多个255相加，最终超出255范围的情况，因此第三个参数运行用户设定输出图像的数据类型，也就是输出图像的数据类型可以与输入图像不同，但是尺寸和通道数是一致的。</p> 
<p>·src:输入图像。</p> 
<p>·dst:输出图像，与输入图像具有相同的尺寸和通道数。</p> 
<p>·ddepth:输出图像的数据类型（深度），根据输入图像的数据类型不同拥有不同的取值范围。</p> 
<p>·ksize:卷积核尺寸。</p> 
<p>·anchor:内核的基准点（锚点），其默认值为（-1，-1）代表内核基准点位于kernel的中心位置。</p> 
<p>·normalize:是否将卷积核进行归一化的标志，默认参数为true，表示进行归一化（在矩阵前面乘所有数值之和）。</p> 
<p>·borderType:像素外推法选择标志。</p> 
<h2>高斯滤波原理</h2> 
<p><img alt="" height="537" src="https://images2.imgbox.com/7d/41/7iKhDYBu_o.png" width="1200">     高斯滤波也就是滤波器是一个高斯分布的形式，如上图所示，滤波器中中间的像素值较大，而四周像素值较小的情况，是一个中心对称的滤波器。若以这样的滤波器作为卷积核与原图像进行卷积操作的时候，得到的就是一个高斯滤波之后的结果 。</p> 
<h3>高斯滤波函数</h3> 
<h3>GaussianBlur()</h3> 
<pre><code class="language-cpp">void cv::GaussianBlur(InputArray    src,
                      OutputArray   dst,
                      Size          xsize,
                      double        sigmaX,
                      double        sigmaY = 0,
                      int           borderType = BORDER_DEFAULT
                     )</code></pre> 
<p>·src:待高斯滤波图像，数据类型必须为CV_8U,CV_16U,CV_16S,CV_32F或CV_64F。</p> 
<p>·dst:输出图像，与输入图像src具有相同的尺寸，通道数和数据类型。</p> 
<p>·ksize:高斯滤波器的尺寸，滤波器可以不为正方形，但是必须是正奇数。如果尺寸为0，则由标准偏差计算尺寸。高斯滤波器不需要人为的输入，因为高斯滤波器的高斯函数分布形式是固定的，只需给出滤波器尺寸即可。</p> 
<p>·sigmaX:X方向的高斯滤波器标准偏差。</p> 
<p>·sigmaY:Y方向的高斯滤波器标准偏差。如果输入量为0，则将其设置为等于sigmaX，如果两个轴的标准差均为0，则根据输入的高斯滤波器尺寸计算标准差。</p> 
<p>ksize ,sigmaX,sigmaY不允许同时为0，若某个参数为0，可以根据对应关系计算出参数。</p> 
<p>·borderType:像素外推法选择标志。</p> 
<h5>示例</h5> 
<pre><code class="language-cpp">#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;

using namespace cv; //opencv的命名空间
using namespace std;



//主函数
int main()
{
	Mat lenaGray = imread("E:/opencv/opencv-4.6.0-vc14_vc15/opencv/lenaGray.png");
	Mat equalLena_Salt = imread("E:/opencv/opencv-4.6.0-vc14_vc15/opencv/equalLena_S.png");
	Mat equalLena_Gauss = imread("E:/opencv/opencv-4.6.0-vc14_vc15/opencv/equalLena_G.png");

	if (lenaGray.empty() || equalLena_Salt.empty() || equalLena_Gauss.empty())
	{
		cout &lt;&lt; "请确认图像名称是否正确" &lt;&lt; endl;
		return -1;
	}

	Mat result_3, result_9; //存放不含噪声滤波结果，后面的数字代表滤波器尺寸
	Mat result_3gauss, result_9gauss; //存放含有高斯噪声滤波结果，后面数字代表滤波器尺寸
	Mat result_3salt, result_9salt; //存放含有椒盐噪声滤波结果，后面的数字代表滤波器尺寸

	//调用均值滤波函数blur()进行滤波
	blur(lenaGray, result_3, Size(3, 3));
	blur(lenaGray, result_9, Size(9, 9));
	blur(equalLena_Salt, result_3salt, Size(3, 3));
	blur(equalLena_Salt, result_9salt, Size(9, 9));
	blur(equalLena_Gauss, result_3gauss, Size(3, 3));
	blur(equalLena_Gauss, result_9gauss, Size(9, 9));


	//显示不含噪声图像
	imshow("lenaGray", lenaGray);
	imshow("result_3", result_3);
	imshow("result_9", result_9);
	//显示不含噪声图像
	imshow("equalLena_Salt", equalLena_Salt);
	imshow("result_3salt", result_3salt);
	imshow("result_9salt", result_9salt);
	//显示不含噪声图像
	imshow("equalLena_Gauss", equalLena_Gauss);
	imshow("result_3gauss", result_3gauss);
	imshow("result_9gauss", result_9gauss);

	cout &lt;&lt; "下面是方框滤波" &lt;&lt; endl;
	waitKey(0);//等待函数用于显示图像,按下键盘任意键后退出
	
	Mat resultNorm, result;
	//方框滤波boxFilter()和sqrBoxFilter()
	boxFilter(lenaGray, resultNorm, -1, Size(3, 3), Point(-1, -1), true); //进行归一化
	boxFilter(lenaGray, result, -1, Size(3, 3), Point(-1, -1), false); //进行归一化

	//显示处理结果
	imshow("resultNorm", resultNorm);
	imshow("result", result);
	cout &lt;&lt; "下面是高斯滤波" &lt;&lt; endl;
	waitKey(0);//等待函数用于显示图像,按下键盘任意键后退出

	Mat result_5_G, result_9_G;//存放不含噪声滤结果，后面数字代表滤波器尺寸
	Mat result_5Gauss_G, result_9Gauss_G;//存放含高斯噪声滤结果，后面数字代表滤波器尺寸
	Mat result_5Salt_G, result_9Salt_G;//存放含椒盐噪声滤结果，后面数字代表滤波器尺寸

	GaussianBlur(lenaGray, result_5_G, Size(5, 5), 10, 20);
	GaussianBlur(lenaGray, result_5_G, Size(5, 5), 10, 20);
	GaussianBlur(equalLena_Gauss, result_5Gauss_G, Size(5, 5), 10, 20);
	GaussianBlur(equalLena_Gauss, result_9Gauss_G, Size(9, 9), 10, 20);
	GaussianBlur(equalLena_Salt, result_5Salt_G, Size(5, 5), 10, 20);
	GaussianBlur(equalLena_Salt, result_9Salt_G, Size(9, 9), 10, 20);


	//显示不含噪声图像
	imshow("lenaGray", lenaGray);
	imshow("result_5_G", result_5_G);
	imshow("result_9_G", result_9_G);
	//显示不含噪声图像
	imshow("equalLena_Salt", equalLena_Salt);
	imshow("result_5Gauss_G", result_5Gauss_G);
	imshow("result_9Gauss_G", result_9Gauss_G);
	//显示不含噪声图像
	imshow("equalLena_Gauss", equalLena_Gauss);
	imshow("result_5Salt_G", result_5Salt_G);
	imshow("result_9Salt_G", result_9Salt_G);
	waitKey(0);//等待函数用于显示图像,按下键盘任意键后退出

	return 0;

}</code></pre> 
<p>滤波完成后:</p> 
<p>在均值滤波中:对于椒盐噪声和高斯噪声的滤波结果，尺寸越大的滤波器，对于图像来说，滤波后的结果也越模糊，噪声产生的影响变小。如果想最大程度的去除噪声，采用均值滤波的形式的话，那么需要一个很大的尺寸，同时对图像的整体质量有较大的影响。</p> 
<p>对椒盐噪声，由于我们的均值滤波是每一个像素值都贡献了相同作用，所以对于椒盐噪声来说，仍然可以看出图像中含有椒盐噪声，只不过椒盐噪声的颗粒没有那么亮，没有那么明显，但是椒盐噪声的颗粒变得更粗了。</p> 
<p>在方框滤波中：方框滤波中如果进行归一化操作，所得到的结果与均值滤波的结果一致，若不进行归一化操作，那么有可能出现图像中数值远远大于255，但是在opencv中，会强制为255，所以导致整个图像中，较大的区域都为白色,而有纹理的恰恰是原图像中较暗的区域。</p> 
<p>在高斯滤波中:顾名思义对高斯噪声的滤波更为理想。结果也会变得模糊，但是处理结果也较好。若图像中含有椒盐噪声，采用线性滤波的方式得到的结果不太理想。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/61dfaafcf6c38df95625d1377f79dbfb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java - 单元测试及Junit的使用讲解及练习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf10b18fbf338019051b4a964651c1b6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">不同开发语言在进程、线程和协程的设计差异</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>