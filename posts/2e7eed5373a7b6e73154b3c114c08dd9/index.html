<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>栈与队列 循环队列 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="栈与队列 循环队列" />
<meta property="og:description" content="1.操作受限的线性表（栈和队列，即双端队列）:只能在表头或表尾处做插入和删除的线性表（对于栈和队列来说，插入即输入，删除即输出）
特点：后进先出(LIFO:last imput first output)
a开头的：ab,bc,ad b开头的：ba,bc,bd c开头的：ca,cb,cd d开头的：dc,da(X),db(X) abcd abdc acbd acdb adcb 5种
bacd badc bcad bcda bdca 5种
cbad cbda cdba 3种
dcba 1种
已知入栈顺序是1,2,3....n
如果第一个出栈的是i，则表明前面的i-1个元素已经在栈中了。之后出栈的必然是i-1，i-2...1
是降序排列的
例题：入栈序列是递增升序的入栈1，2，3，4，5,确实是递增的 A项：第一位是5，后面小于5的数应该是是降序排列的 B项：第一位是4，小于4的数是1,3,2,但1,3,2不是降序排列的 C项：第一位是4，小于4的数是3,1,2,但3,1,2不是降序排列的 D项：第一位是3，小于3的数是2,1是降序排列的。再看2，再看1，再看5，再看4。每一位都要满足后面小于它的数是降序排列的
入栈序列是降序的
每一位都要满足后面大于它的数是升序排列的
A：第一位是2，大于2的数是3,4,5,6,是升序排列的 ；对。每一位都符合
B：第一位是3，大于3的数是4,6,5,不是升序排列的 ；错
入栈序列≠输入序列 因为p1=n， 该题的输出序列只能降序排列
n n-1 n-2 ... 3 2 1 代入i是2的话pi=p2=n-1来判断，故选C 输出第一个元素是i，出栈的序列就有i种，所以第j个输出元素是不确定的
p2是n，后面出栈的肯定是小于n 的且为降序的，只看p1的取值即可，有n-1种出栈序列。例如p1为5，先把1.2.3.4.5入栈，之后5出栈(p1)，再将6.7.8.9...n入栈，n出栈(p2)
因为入队列和出队列的顺序一样，所以7个元素出栈的顺序已知。
队列 删除端：出队列（队头）
在队头处做出队列的操作 在队尾处做入队列的操作 特点：先进先出 直接根据尾指针rear找到尾结点，做插入时，不需要遍历整个链队列
​​​​​​ 1.可以颠倒次序，求逆序：一个字符串，每次读的时候，是以a,b,c,d的顺序读的，输出是d,c,b,a的顺序 2.函数机制的实现：当调用函数时，是在栈区里面的 要求栈和队列的插入和删除的时间复杂度都是O(1)
存储栈：顺序存储（顺序栈||循环队列）&amp;&amp;链式存储（链栈||链队列）
已知顺序表在表尾处做插入和删除都是O(1),base可直接代表数组(顺序表)的起始地址，而top可以是下标，也可以是地址***，可以指向栈顶元素，也可以定义成指向将要入栈的位置***
top做下标时：s.base[top]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2e7eed5373a7b6e73154b3c114c08dd9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-05T07:34:49+08:00" />
<meta property="article:modified_time" content="2022-07-05T07:34:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">栈与队列 循环队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.<span style="color:#fe2c24;">操作受限</span><span style="color:#0d0016;">的线性表（</span><span style="color:#fe2c24;">栈和队列，即双端队列</span><span style="color:#0d0016;">）</span>:只能在<span style="color:#956fe7;">表头或表尾处做插入和删除</span>的线性表（对于栈和队列来说，插入即输入，删除即输出）</p> 
<p><img alt="" height="152" src="https://images2.imgbox.com/98/dc/3katNW5Q_o.png" width="285"><img alt="" height="137" src="https://images2.imgbox.com/1c/74/dqyq1xYc_o.png" width="342"></p> 
<p>特点：<span style="color:#ed7976;">后进先出</span>(LIFO:last imput first output)</p> 
<p><img alt="" height="105" src="https://images2.imgbox.com/63/e7/UnLD9ueS_o.png" width="707"></p> 
<p>  <img alt="" height="342" src="https://images2.imgbox.com/d9/3e/RVdSn5NC_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;">a</span>开头的：ab,bc,ad    <span style="color:#fe2c24;">b</span>开头的：ba,bc,bd   <span style="color:#fe2c24;">c</span>开头的：ca,cb,cd  <span style="color:#fe2c24;">d</span>开头的：dc,da(X),db(X) </p> 
<p>abcd abdc acbd acdb adcb     5种</p> 
<p>bacd badc bcad bcda bdca     5种</p> 
<p>cbad cbda cdba                      3种</p> 
<p>dcba                                        1种</p> 
<blockquote> 
 <p>已知入栈顺序是1,2,3....n</p> 
 <p>如果第一个出栈的是i，则表明前面的i-1个元素已经在栈中了。之后出栈的必然是i-1，i-2...1</p> 
 <p>是降序排列的</p> 
 <p><img alt="" height="155" src="https://images2.imgbox.com/4a/e9/xT313KvI_o.png" width="359"><img alt="" height="162" src="https://images2.imgbox.com/9a/e6/CSETS4Lc_o.png" width="248"></p> 
 <p> 例题：<span style="color:#fe2c24;">入栈序列是递增<strong>升序</strong>的</span>入栈1，2，3，4，5,确实是递增的                                                     A项：第一位是5，后面小于5的数应该是是降序排列的                                 </p> 
 <p>   B项：第一位是4，小于4的数是1,3,2,但1,3,2不是降序排列的                                                C项：第一位是4，小于4的数是3,1,2,但3,1,2不是降序排列的                                                  D项：第一位是3，小于3的数是2,1是降序排列的。再看2，再看1，再看5，再看4。每一位都要满足后面小于它的数是降序排列的</p> 
 <p><span style="color:#fe2c24;">入栈序列是<strong>降序</strong>的</span></p> 
 <p><img alt="" height="274" src="https://images2.imgbox.com/dd/52/zVja0R6o_o.png" width="569"></p> 
 <p><span style="color:#fe2c24;">每一位都要满足后面</span><span style="color:#1a439c;">大于</span><span style="color:#fe2c24;">它的数是</span><span style="color:#1a439c;">升序</span><span style="color:#fe2c24;">排列的</span></p> 
 <p>A：第一位是2，大于2的数是3,4,5,6,是升序排列的 ；对。每一位都符合</p> 
 <p>B：第一位是3，大于3的数是4,6,5,不是升序排列的 ；错</p> 
 <p></p> 
 <p><img alt="" height="310" src="https://images2.imgbox.com/4b/12/SFa6l5ir_o.png" width="434">                                                                            <span style="color:#ed7976;">入栈序列≠输入序列          因为p1=n， 该题的输出序列只能降序排列</span></p> 
 <p><span style="color:#ed7976;">n      n-1       n-2   ...  3  2 1                            代入i是2的话pi=p2=n-1来判断，故选C  </span></p> 
 <p><img alt="" height="375" src="https://images2.imgbox.com/7d/63/ekud3f1a_o.png" width="927"><span style="color:#ed7976;">           输出第一个元素是i，出栈的序列就有i种，所以第j个输出元素是不确定的</span></p> 
 <p></p> 
 <p><img alt="" height="334" src="https://images2.imgbox.com/3f/46/kIxLMTMc_o.png" width="1107"></p> 
 <p>p2是n，后面出栈的肯定是小于n 的且为降序的，只看p1的取值即可，有n-1种出栈序列。例如p1为5，先把1.2.3.4.5入栈，之后5出栈(p1)，再将6.7.8.9...n入栈，n出栈(p2)</p> 
 <hr> 
 <img alt="" height="353" src="https://images2.imgbox.com/eb/a6/a9yD4Tq3_o.png" width="895"> 
 <p></p> 
 <p></p> 
 <hr> 
 <p><img alt="" height="137" src="https://images2.imgbox.com/a1/18/NeihDmuh_o.png" width="646"></p> 
 <p> 因为入队列和出队列的顺序一样，所以7个元素出栈的顺序已知。</p> 
 <hr> 
 <h2>    <strong> 队列 </strong>                  </h2> 
 <p><img alt="" height="249" src="https://images2.imgbox.com/85/a9/rm6YXDED_o.png" width="387"><span style="color:#ed7976;">    删除端：出队列（队头）</span></p> 
 <p><span style="color:#0d0016;">在队头处做出队列的操作</span><span style="color:#ed7976;">     </span><span style="color:#0d0016;">在队尾处做入队列的操作</span><span style="color:#ed7976;">     </span>         特点：先进先出   </p> 
 <p><img alt="" height="370" src="https://images2.imgbox.com/a5/34/dShL1PRr_o.png" width="1119"></p> 
 <p> 直接根据尾指针rear找到尾结点，做插入时，不需要遍历整个链队列</p> 
 <p><img alt="" height="268" src="https://images2.imgbox.com/c6/8a/SAwDESki_o.png" width="411"></p> 
 <p><img alt="" height="276" src="https://images2.imgbox.com/1f/f8/uuN6O1Gd_o.png" width="410"></p> 
 <p><img alt="" height="156" src="https://images2.imgbox.com/e3/a3/RwuijBRB_o.png" width="298"></p> 
 <p></p> 
 <p></p> 
 <p></p> 
</blockquote> 
<p></p> 
<p></p> 
<blockquote> 
 <p><img alt="" height="196" src="https://images2.imgbox.com/2c/14/Sv9HEn1T_o.png" width="285"><span style="color:#fe2c24;"><strong>​​​​​​ </strong></span> <img alt="" height="240" src="https://images2.imgbox.com/27/aa/IKYjiv5B_o.png" width="266"></p> 
 <p>1.可以颠倒次序，求逆序：一个字符串，每次读的时候，是以a,b,c,d的顺序读的，输出是d,c,b,a的顺序                   2.函数机制的实现：当调用函数时，是在栈区里面的  </p> 
 <p><strong><span style="color:#be191c;">要求栈和队列的插入和删除的时间复杂度都是O(1)</span></strong></p> 
 <p><strong><span style="color:#be191c;">存储栈：顺序存储（</span><span style="color:#0d0016;">顺序栈</span><span style="color:#be191c;">||循环队列）&amp;&amp;链式存储（</span><span style="color:#0d0016;">链栈</span><span style="color:#be191c;">||</span><span style="color:#0d0016;">链队列</span><span style="color:#be191c;">）</span></strong></p> 
 <p><span style="color:#0d0016;">已知顺序表在表尾处做插入和删除都是O(1),base可直接代表数组(顺序表)的起始地址，而top可以是下标，也可以是地址***，可以指向栈顶元素，也可以定义成指向将要入栈的位置***</span></p> 
 <p><img alt="" height="178" src="https://images2.imgbox.com/a4/03/LsDoYLVP_o.png" width="328"></p> 
 <p>top做下标时：s.base[top]</p> 
 <p>top做地址时：*top</p> 
 <p>top可以是栈顶元素的下标和地址，也可以指向将要入栈的位置</p> 
 <p><img alt="" height="281" src="https://images2.imgbox.com/b2/8d/wq50GSb5_o.png" width="416"></p> 
 <p> <img alt="" height="225" src="https://images2.imgbox.com/28/58/G9AbVL70_o.png" width="463"></p> 
 <p> *S.top++=e:首先++和*的优先级一样<img alt="" height="38" src="https://images2.imgbox.com/80/e5/ABAHuq9J_o.png" width="118"> 又因为是(单目运算符)右结合的(先执行右边的运算符)，先做红圈里的， *(s.top++)就是把原来top的值(还没递增时)取内容，放在e中，e放在了S.top原来未加1的值中</p> 
 <p>如  i=1;    j=i++;          则i=2,j=1</p> 
 <p>如   i=1;   j=++i; 则i=2；j=2；i++与++i中，i都会做自增操作，只是表达式的值不一样，一个是i自增前的，另一个是自增后的</p> 
 <hr> 
 <hr>  
 <hr> 
 <p><img alt="" height="349" src="https://images2.imgbox.com/61/f1/B5aKX7GE_o.png" width="430"></p> 
 <p></p> 
 <p><img alt="" height="298" src="https://images2.imgbox.com/a0/4e/j0iinCxM_o.png" width="1135"></p> 
 <p> 链表每次在表头出做插入和删除O(1)       </p> 
 <p><img alt="" height="512" src="https://images2.imgbox.com/61/67/XGe1zTzv_o.png" width="1142"></p> 
 <p> 入栈插在首元结点的前面，出栈即删除首元接点</p> 
 <p></p> 
 <p></p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p> <strong>栈的应用 之表达式求值</strong></p> 
 <p><strong>例如3*(7-2)#,使用两个栈来存，一个专门盛操作数（OPND栈），一个专门盛运算符（OPTR栈）</strong><img alt="" height="181" src="https://images2.imgbox.com/cc/27/k5x2dgwg_o.png" width="279"></p> 
 <p>在读入数据之前，先定义一个’#‘放在OPTR栈中，认为#的优先级小于all运算符优先级的，因此，在读入第一个’*‘时，就可以和#进行优先关系的比较了</p> 
 <p>当读到的表达式是运算数时，直接让运算数<strong>入</strong>算数栈</p> 
 <p>当读到的表达式是运算符ch时，OPTR的栈顶元素和ch要进行优先关系的比较：                   1.当栈顶元素的优先级&lt;ch时，让ch入栈                                                                                    2.当栈顶元素的优先级&gt;ch时，先做栈顶元素的运算：如减号的优先级&gt;右括号，即先做读减号的运算，减号出栈，同时2  、7出OPND栈，做7-2的运算，运算结果入OPND 栈</p> 
 <p><img alt="" height="813" src="https://images2.imgbox.com/59/99/S03BTRok_o.png" width="1200"></p> 
 <p> <img alt="" height="208" src="https://images2.imgbox.com/8f/96/i5DLfbVk_o.png" width="178"></p> 
 <p> 此时OPTR的栈顶元素是左括号，重新让读到的运算符右括号与栈顶元素进行比较。左右括号的优先级是相等的，所以让左括号出栈 即可。再读下一个，读到了#，而OPTR中新的栈顶元素是*，*的优先级&gt;#的优先级。故先做*运算，让*出栈，5、3也出OPND栈 ，#入栈</p> 
 <p><img alt="" height="604" src="https://images2.imgbox.com/7c/08/vCuiM00t_o.png" width="1138"><img alt="" height="498" src="https://images2.imgbox.com/87/8f/VSZY6ZZS_o.png" width="1028"></p> 
 <p><img alt="" height="369" src="https://images2.imgbox.com/74/35/f8DprzEN_o.png" width="1093"></p> 
 <p><img alt="" height="543" src="https://images2.imgbox.com/54/7d/5RaY4kts_o.png" width="1067"></p> 
 <p> <img alt="" height="711" src="https://images2.imgbox.com/dc/b4/hWRhCEzd_o.png" width="1130"></p> 
 <p> <img alt="" height="263" src="https://images2.imgbox.com/9d/2a/rhLBUu8g_o.png" width="899"></p> 
 <p>将"中缀表达式转为后缀表达式"的过程==表达式求值</p> 
 <p>即求：<span style="color:#fe2c24;">运算符栈</span>的情况 </p> 
 <p>当读到*，*与#比较，(优先级关系的比较)&gt;,*入栈<span style="color:#be191c;">P</span>。当读到+，'+'&lt;'*'，'*'出栈<span style="color:#be191c;">O</span>，+&gt;#,+入栈<span style="color:#be191c;">P</span>。当读到/，/&gt;+,/入栈<span style="color:#be191c;">P</span>。当读到#，#&lt;/,/出栈<span style="color:#be191c;">O</span>。此时#&lt;+,+出栈<span style="color:#be191c;">O</span>。</p> 
 <p><img alt="" height="172" src="https://images2.imgbox.com/35/9b/j20DW9m6_o.png" width="446">C</p> 
 <p> <img alt="" height="316" src="https://images2.imgbox.com/5c/0f/4iMkSlTH_o.png" width="1056"></p> 
 <p>首先+入栈，*&gt;+,*入栈，再读+，+&lt;*,*出栈。此时左边+&gt;右边+，左边+出栈。再读左括号&gt;+,左括号入栈,再读*，*&gt;左括号，*入栈，再读+，+&lt;*,*出栈，+&gt;左括号，+入栈，读到了f，截止 B</p> 
 <p></p> 
 <p></p> 
 <p></p> 
 <p></p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p></p> 
 <p><img alt="" height="172" src="https://images2.imgbox.com/2c/5b/kqDqFfBa_o.png" width="232"><img alt="" height="171" src="https://images2.imgbox.com/0f/62/hUrrMFnf_o.png" width="282"></p> 
 <p> 前缀或后缀表达式不带有括号。后缀表达式求值是最简单的，操作数已经存好了，运算符直接出栈即可</p> 
 <p><img alt="" height="74" src="https://images2.imgbox.com/a7/da/y5DOLGRZ_o.png" width="260"></p> 
 <p> 此时，第一个操作数是a，第二个操作数是bc+所得结果</p> 
 <p><img alt="" height="116" src="https://images2.imgbox.com/bc/fb/4TkIU2qb_o.png" width="382"></p> 
 <p> 此时，第一个操作数是abc+*所得结果,第二个操作数是d</p> 
 <p><img alt="" height="139" src="https://images2.imgbox.com/b0/78/haADCYIK_o.png" width="499"></p> 
 <p> 若是求前缀表达式：</p> 
 <p>+bc-&gt;*a+bc(此时，第一个操作数是a，第二个操作数是+bc所得结果)-&gt;-*a+bcd</p> 
 <p> <img alt="" height="196" src="https://images2.imgbox.com/40/ea/F6catvJ4_o.png" width="639"></p> 
 <p> <img alt="" height="365" src="https://images2.imgbox.com/75/3b/3UKFhu34_o.png" width="740"></p> 
 <p>后缀表达式只设一个运算数栈即可，当根据化得的后缀表达式，读到运算数时入栈，读到运算符时，相应的操作数出栈 </p> 
 <p>a,b,c入栈，读到*，b,c出栈，结果b*c入栈，读到+，a也出栈，a+b*c结果入栈</p> 
 <p></p> 
 <p></p> 
 <p></p> 
 <p></p> 
</blockquote> 
<p></p> 
<p></p> 
<h3><strong>循环队列</strong></h3> 
<p> 判断题：所谓“循环队列”是指用单向循环链表或者循环数组表示的队列。<strong> × </strong>             </p> 
<p>循环队列指的是后者,用数组表示的队列,利用求余数运算使得头尾相接。 循环队列本身是一种顺序存储结构,而循环列表是一种链式存储结构。两者之间是平级关系。 </p> 
<p>1.队头元素并不是从下标为0的位置开始存放的(因为如果出队删除的话，还需前移覆盖浪费大量空间),设置front记录队头元素的下标</p> 
<p><img alt="" height="254" src="https://images2.imgbox.com/31/50/Mn98NWDP_o.png" width="374"></p> 
<p>用取余将数组看做循环数组，循环队列是队列采用了顺序存储结构，用数组来存的</p> 
<p>2.头尾指针下移</p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/b5/ae/dKZ6ATT1_o.png" width="385"></p> 
<p>3.头尾指针类型为整形，是下标。base是数组的起始地址</p> 
<p><img alt="" height="214" src="https://images2.imgbox.com/46/20/0dpUOG9w_o.png" width="372"></p> 
<p>其出入队列时间复杂度均为O(1)</p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/b7/ff/yf83s3qX_o.png" width="702"></p> 
<p> <img alt="" height="52" src="https://images2.imgbox.com/1b/39/mFwbgzPa_o.png" width="196">就是根据这个来算的</p> 
<p><img alt="" height="200" src="https://images2.imgbox.com/36/55/qRjyYHA1_o.png" width="370"><img alt="" height="215" src="https://images2.imgbox.com/d7/55/N8Jou53O_o.png" width="417">也是循环队列元素的个数</p> 
<p><img alt="" height="211" src="https://images2.imgbox.com/62/cb/6xFHJQlF_o.png" width="577"></p> 
<p>根据题意画个图看看即可</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9c99f761b8f5e9a1e93ce4cf425d0bf0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">线性表习题课</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4be2d6b92332e69612f4f9e03df5842/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构复习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>