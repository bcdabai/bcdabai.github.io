<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;面向对象（三）：类和对象 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;面向对象（三）：类和对象" />
<meta property="og:description" content="C&#43;&#43;面向对象：类和对象 会有点长，不过读过就全学会喽！！！！！！
会有点长，不过读过就全学会喽！！！！！！
会有点长，不过读过就全学会喽！！！！！！
1.类与对象的基本概念 1.1 结构与类 1 . 结构的扩充
结构是 C 语言的一种自定义的数据类型, 在结构体中可以含有各种不同类型的数 据。C &#43; &#43; 语言对结构类型进行了扩充, 它不仅可以含有不同类型的数据, 而且还可以含有函数。
结构中的数据和函数都是结构的成员,分别称作数据成员和函数成员。在 C &#43; &#43; 中, 通常把 函 数 成 员 称 为 成 员 函 数。
为了访问这些成员函数,必须 定义该结构类型的变量,然后像访问结构中的数据成员一样进行访问。
#include &lt; iostream .h &gt; #include &lt; math .h &gt; struct complex { double real; // 复数的实部 double imag; // 复数的虚部 void init( double r, double i) // 给 real 和 imag 赋初值 { real = r; imag = i; } double realcomplex() // 求复数的实部值 { return real; } double imagcomplex() // 求复数的虚部值 { return imag; } double abscomplex() // 求复数的绝对值 {double t ; t = real * real &#43; imag * imag; return sqrt(t) ; } } A; int main() { A ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ce5756919b9d3317a7d31ea758dabcae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-26T20:19:57+08:00" />
<meta property="article:modified_time" content="2020-07-26T20:19:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;面向对象（三）：类和对象</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="C_0"></a>C++面向对象：类和对象</h3> 
<p>会有点长，不过读过就全学会喽！！！！！！<br> 会有点长，不过读过就全学会喽！！！！！！<br> 会有点长，不过读过就全学会喽！！！！！！</p> 
<h4><a id="1_5"></a>1.类与对象的基本概念</h4> 
<h5><a id="11__6"></a>1.1 结构与类</h5> 
<p><strong>1 . 结构的扩充</strong><br> 结构是 C 语言的一种自定义的数据类型, 在结构体中可以含有各种不同类型的数 据。C + + 语言对结构类型进行了扩充, 它不仅可以含有不同类型的数据, 而且还可以含有函数。<br> 结构中的数据和函数都是结构的成员,分别称作数据成员和函数成员。在 C + + 中, 通常把 函 数 成 员 称 为 成 员 函 数。<br> 为了访问这些成员函数,必须 定义该结构类型的变量,然后像访问结构中的数据成员一样进行访问。</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt; iostream .h &gt;</span> </span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt; math .h &gt;</span> </span>
<span class="token keyword">struct</span> complex <span class="token punctuation">{<!-- --></span> 
<span class="token keyword">double</span> real<span class="token punctuation">;</span> <span class="token comment">// 复数的实部 </span>
<span class="token keyword">double</span> imag<span class="token punctuation">;</span> <span class="token comment">// 复数的虚部 </span>
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span> <span class="token keyword">double</span> r<span class="token punctuation">,</span> <span class="token keyword">double</span> i<span class="token punctuation">)</span> <span class="token comment">// 给 real 和 imag 赋初值 </span>
<span class="token punctuation">{<!-- --></span> real <span class="token operator">=</span> r<span class="token punctuation">;</span> imag <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token keyword">double</span> <span class="token function">realcomplex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 求复数的实部值 </span>
<span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> real<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token keyword">double</span> <span class="token function">imagcomplex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 求复数的虚部值 </span>
<span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> imag<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token keyword">double</span> <span class="token function">abscomplex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 求复数的绝对值 </span>
<span class="token punctuation">{<!-- --></span><span class="token keyword">double</span> t <span class="token punctuation">;</span> 
t <span class="token operator">=</span> real <span class="token operator">*</span> real <span class="token operator">+</span> imag <span class="token operator">*</span> imag<span class="token punctuation">;</span> 
<span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span> A<span class="token punctuation">;</span> 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
A <span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token number">.1</span> <span class="token punctuation">,</span><span class="token number">2</span> <span class="token number">.2</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ”real of complex A <span class="token operator">=</span> ”<span class="token operator">&lt;</span> <span class="token operator">&lt;</span> A <span class="token punctuation">.</span><span class="token function">realcomplex</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> endl<span class="token punctuation">;</span> 
cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ”imag of complex A <span class="token operator">=</span> ”<span class="token operator">&lt;</span> <span class="token operator">&lt;</span> A <span class="token punctuation">.</span><span class="token function">imagcomplex</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>
cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ”abs of complex A <span class="token operator">=</span> ”<span class="token operator">&lt;</span> <span class="token operator">&lt;</span> A <span class="token punctuation">.</span>abscomplex <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> endl<span class="token punctuation">;</span> 
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>在 C ++ 中,一个结构的成员通常分为两类:<strong>私有成员 ( private )和公有成员 ( public )</strong>。 私有成员(包括数据和函数) 只能被该结构中的其它成员访问,而公有成员( 包括数据和函数)既可被结构内其它成员访问,也可被结构外的其它部分访问。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> complex<span class="token punctuation">{<!-- --></span> 
<span class="token keyword">private</span> <span class="token operator">:</span> 
	<span class="token keyword">double</span> real<span class="token punctuation">;</span> 
	<span class="token keyword">double</span> imag<span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span> 
	<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span> <span class="token keyword">double</span> r<span class="token punctuation">,</span> <span class="token keyword">double</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> real <span class="token operator">=</span> r<span class="token punctuation">;</span> imag <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
	<span class="token keyword">double</span> <span class="token function">realcomplex</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> real<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
	<span class="token keyword">double</span> <span class="token function">imagcomplex</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> imag<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
	<span class="token keyword">double</span> <span class="token function">abscomplex</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">double</span> t<span class="token punctuation">;</span> t <span class="token operator">=</span> real <span class="token operator">*</span> real <span class="token operator">+</span> imag <span class="token operator">*</span> imag<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span> t<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre> 
<p><strong>C + + 规定, 在缺省情况下,结构中的成员是公有的。</strong><br> <strong>2 . 类的声明</strong><br> C + + 提供了一种比结构类型更安全有效的数据类型———类。类是 C + + 的一个最 重要的特性。类与结构的扩充形式十分相似,其一般形式如下:</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> 类名<span class="token punctuation">{<!-- --></span> 
<span class="token punctuation">[</span> <span class="token keyword">private</span><span class="token operator">:</span> <span class="token punctuation">]</span> 
	私有数据成员和成员函数 
<span class="token keyword">public</span><span class="token operator">:</span> 
	公有数据成员和成员函数 
<span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre> 
<p>其中: class 是声明类的关键字, 类名是要声明的类的名字; 后面的花括号表示出类的声明 范围;最后的分号表示类声明结束。<br> <strong>类的声明内容包括数据和函数。类中的数据和函数都是类的成员, 分别叫做数据成 员和成员函数。</strong><br> 与结构的扩充形式一样,类的成员也分为私有成员和公有成员。私有成员用 private 说明, private 下面的每一行,不论是数据成员还是成员函数, 都是私有成员。私有成员只 能被该类的成员函数访问,这是 C + + 实现封装的一种方法, 即把特定的成员定义为私有的,就能严格地控制对它的访问。公有成员用 public 说明, public 下面的每一行都是公有 成员。公有成员可被程序中的其它函数访问, 它们是类的对外接口。<br> <strong>在类中, 缺省时成 员是私有的; 而在结构中,缺省时成员是公有的。</strong></p> 
<br> 
<p><strong>C + + 中为什么要用类代替结构呢 ?</strong></p> 
<p><strong>原因是,在缺省的情况下, 类成员是私有的, 类提供了缺省的安全性。这一规定符合面向 对象思想中数据隐藏的准则。数据隐藏使得类中的成员比一般的局部变量得到更好的保 护</strong><br> <strong>说明:</strong></p> 
<ol><li><strong>类的声明中的 private 和 public 两个关键字可以按任意顺序出现任意次。</strong></li><li><strong>除了 private 和 public 之外, 类中的成员还可以用另一个关键字 protected 来说 明。被 protected 说明的成员称为保护成员, 它不能被外部函数使用</strong></li><li><strong>数据成员可以是任何数据类型,但是不能用自动( auto)、寄存器 ( register) 或外部 ( extern)进行说明。</strong></li><li><strong>不能在类的声明中给数据成员赋初值</strong></li></ol> 
<p><strong>C + + 规定, 只有在类对象定义之后才能给数据成员赋初值。</strong></p> 
<h5><a id="12__87"></a>1.2 成员函数的定义</h5> 
<p><strong>成员函数的定义通常采用两种方式。</strong><br> <strong>第一种方式是在类声明中只给出成员函数的原型, 而成员函数体在类的外部定义。 这种成员函数定义的一般形式是:</strong></p> 
<pre><code class="prism language-cpp">返回类型 类名∷函数名<span class="token punctuation">(</span>参数表<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
<span class="token comment">// 函数体 </span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">point</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span> <span class="token operator">:</span> 
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">void</span> setpoint <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// 设置坐标点的成员函数 setpoint( )的函数原型 </span>
	<span class="token keyword">int</span> <span class="token function">getx</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// 取 x 坐标点的成员函数 getx( )的函数原型 </span>
	<span class="token keyword">int</span> gety <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// 取 y 坐标点的成员函数 gety( )的函数原型 </span>
<span class="token punctuation">}</span> <span class="token punctuation">;</span> 
<span class="token keyword">void</span> point∷<span class="token function">setpoint</span><span class="token punctuation">(</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token comment">// 定义成员函数 setpoint( ) </span>
<span class="token punctuation">{<!-- --></span> x <span class="token operator">=</span> a<span class="token punctuation">;</span> y <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token keyword">int</span> point∷<span class="token function">getx</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token comment">// 定义成员函数 getx() </span>
<span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token keyword">int</span> point∷<span class="token function">gety</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 定义成员函数 gety( ) </span>
<span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> 
<p>从这个例子可以看出,虽然函数 setpoint( )、getx( )和 gety( ) 在类外部定义, 但它们属 于类 point 的成员函数, 它们可以直接使用类 point 中的数据成员 x 和 y。<br> <strong>说明:</strong></p> 
<ol><li><strong>在所定义的成员函数名之前应缀上类名, 在类名和函数名之间应加上分隔符 “∷”,例如上面例子中的“point∷”。</strong></li><li><strong>在定义成员函数时, 对函数所带的参数, 不但要说明它的类型, 还要指出其参 数名。</strong></li><li><strong>在定义成员函数时, 其返回类型一定要与函数原型中声明的返回类型匹配。</strong></li></ol> 
<p><strong>成员函数的第二种定义方式是:将成员函数定义在类的内部, 即定义为内置函数。</strong><br> 1️⃣<strong>隐式定义：所谓内置函数的隐式定义, 就是直接将函数定义在类内部</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">point</span><span class="token punctuation">{<!-- --></span> 
<span class="token keyword">private</span> <span class="token operator">:</span> 
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span> 
	<span class="token keyword">void</span> <span class="token function">setpoint</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span> x <span class="token operator">=</span> a<span class="token punctuation">;</span> y <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
	<span class="token keyword">int</span> <span class="token function">getx</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
	<span class="token keyword">int</span> gety <span class="token punctuation">(</span> <span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span> retrun y<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre> 
<p><strong>此时, 函数 setpoint( )、getx( )和 gety( )就是隐含的内置函数。内置函数的调用类似宏指 令的扩展,它直接在调用处扩展其代码, 而不进行一般函数的调用操作。</strong><br> 2️⃣<strong>显式定义：在定义内置函数时, 为了书写清晰,仍将它放在类定义体外。但为了 使它仍然起内置函数的作用, 在函数定义前冠以关键字“inline”, 以此显式地说明这是一 个内置函数。</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">point</span><span class="token punctuation">{<!-- --></span> 
<span class="token keyword">private</span> <span class="token operator">:</span> 
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span> 
	<span class="token keyword">void</span> <span class="token function">setpoint</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 
	<span class="token keyword">int</span> <span class="token function">getx</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">int</span> gety <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
<span class="token punctuation">}</span> <span class="token punctuation">;</span> 
<span class="token keyword">inline</span> <span class="token keyword">void</span> point∷<span class="token function">setpoint</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span> x <span class="token operator">=</span> a<span class="token punctuation">;</span> y <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token keyword">inline</span> <span class="token keyword">int</span> point∷<span class="token function">getx</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token keyword">inline</span> <span class="token keyword">int</span> point∷<span class="token function">gety</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> 
<p><strong>说明:简单的成员函数定义成内置函数可以提高执行的效率, 但如果函数体较长, 将 使程序量增加很多。因此,一般对非常简单的函数才声明为内置函数。</strong></p> 
<h5><a id="13__155"></a>1.3 对象的定义及引用</h5> 
<p><strong>1 . 类与对象的关系</strong><br> 通常我们把具有同样性质和功能的东西所构成的集合称为类。在 C + + 中, 可以把 相同内部存储结构和相同操作集的对象看成属于同一类。<br> <strong>2 . 对象的定义</strong><br> 可以用以下两种方法定义对象。<br> 1️⃣<strong>在声明类的同时, 直接定义对象,即在声明类的右花括号“}”后, 直接写出属于该 类的对象名表。例如:</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">point</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span> <span class="token operator">:</span> 
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span> 
	<span class="token keyword">void</span> <span class="token function">setpoint</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 
	<span class="token keyword">int</span> <span class="token function">getx</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
	<span class="token keyword">int</span> <span class="token function">gety</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
<span class="token punctuation">}</span> op1<span class="token punctuation">,</span> op2<span class="token punctuation">;</span>
</code></pre> 
<p><strong>在声明类 point 的同时, 直接定义了对象 op1 和 op2 ,这时定义的是一个全局对象。</strong><br> 2️⃣<strong>声明了类之后, 在使用时再定义对象, 定义的格式与一般变量的定义格式相同</strong></p> 
<pre><code class="prism language-cpp">point op1 <span class="token punctuation">,</span>op2<span class="token punctuation">;</span>
</code></pre> 
<p><strong>此时定义了 op1 和 op2 为 point 类的两个对象。</strong><br> <strong>说明:</strong></p> 
<ol><li><strong>声明了一个类便声明了一种类型, 它并不接收和存储具体的值, 只作为生成具体对象的一种“样板”,只有定义了对象后, 系统才为对象并且只为对象分配存储空间。</strong></li><li><strong>在声明类的同时定义的对象是一种全局对象, 在它的生存期内任何函数都可以 使用它。但有时使用它的函数只在极短的时间对它进行操作,而它却总是存在, 直到整个 程序运行结束,采用使用时再定义对象的方法可以消除这种弊端。</strong></li></ol> 
<p><strong>3 . 对象的引用</strong><br> <strong>在此, 对象的引用是指对对象成员的引用。不论是数据成员, 还是成员函数, 只要是 公有的,就可以被外部函数直接引用, 引用格式是:</strong></p> 
<pre><code class="prism language-cpp">对象名 <span class="token punctuation">.</span> 数据成员名 
或 
对象名 <span class="token punctuation">.</span> 成员函数名<span class="token punctuation">(</span> 实参表<span class="token punctuation">)</span>
</code></pre> 
<p><strong>其中“ .”叫做对象选择符, 简称点运算符。</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt; iostream .h &gt;</span></span>
<span class="token keyword">class</span> <span class="token class-name">point</span><span class="token punctuation">{<!-- --></span> 
<span class="token keyword">private</span><span class="token operator">:</span> 
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span> 
	<span class="token keyword">void</span> <span class="token function">setpoint</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> x <span class="token operator">=</span> a <span class="token punctuation">;</span> y <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
	<span class="token keyword">int</span> getx <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
	<span class="token keyword">int</span> <span class="token function">gety</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> <span class="token punctuation">;</span> 
<span class="token keyword">void</span> main <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
point op1<span class="token punctuation">,</span> op2<span class="token punctuation">;</span> 
<span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span> 
op1 <span class="token punctuation">.</span><span class="token function">setpoint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// 调用 op1 的 setpoint( ) , 初始化对象 op1 3 </span>
op2 <span class="token punctuation">.</span><span class="token function">setpoint</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// 调用 op2 的 setpoint( ) , 初始化对象 </span>
op2 i <span class="token operator">=</span> op1 <span class="token punctuation">.</span><span class="token function">getx</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 调用 op1 的 <span class="token function">getx</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">,</span>取 op1 的 x 值 
j <span class="token operator">=</span> op1 <span class="token punctuation">.</span><span class="token function">gety</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 调用 op1 的 <span class="token function">gety</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">,</span> 取 op1 的 y 值 
cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ”op1 i <span class="token operator">=</span> ”<span class="token operator">&lt;</span> <span class="token operator">&lt;</span> i <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ”op1 j <span class="token operator">=</span> ”<span class="token operator">&lt;</span> <span class="token operator">&lt;</span> j <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> endl<span class="token punctuation">;</span> 
i <span class="token operator">=</span> op2 <span class="token punctuation">.</span><span class="token function">getx</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 调用 op2 的 <span class="token function">getx</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">,</span>取 op2 的 x 值 
j <span class="token operator">=</span> op2 <span class="token punctuation">.</span><span class="token function">gety</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 调用 op2 的 <span class="token function">gety</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">,</span> 取 op2 的 y 值 
cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ”op2 i <span class="token operator">=</span> ”<span class="token operator">&lt;</span> <span class="token operator">&lt;</span> i <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ”op2 j <span class="token operator">=</span> ”<span class="token operator">&lt;</span> <span class="token operator">&lt;</span> j <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> endl<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>说明:</strong></p> 
<ol><li><strong>本例中 op1 .setpoint( 1, 2) 实际上是一种缩写形式, 它表达的意义是 op1 .point∷ setpoint( 1 .2) , 这两种表达式是等价的。</strong></li><li><strong>外部函数不能引用对象的私有成员。</strong></li><li><strong>在定义对象时, 若我们定义的是指向此对象的指针, 则访问此对象的成员时, 不 能用“ .”操作符, 而应使用“ - &gt; ”操作符</strong></li></ol> 
<p><strong>4 . 对象赋值语句</strong><br> 如果有两个整型变量 x 和 y, 那么用 y = x,就可以把 x 的值赋给 y。同类型的对象之 间也可以进行赋值,当一个对象赋值给另一个对象时, 所有的数据成员都会逐位拷贝。<br> <strong>说明:</strong></p> 
<ol><li>在使用对象赋值语句进行对象赋值时, 两个对象的类型必须相同,如对象的类型 不同,编译时将出错。</li><li>两个对象之间的赋值, 仅仅使这些对象中数据相同,而两个对象仍是分离的。例 如本例对象赋值后,再调用 o1 .set( ) 设置o1 的值,不会影响 o2 的值。</li><li>将一个对象的值赋给另一个对象时, 多数情况下都是成功的, 但当类中存在指针 时,可能会产生错误。</li></ol> 
<h5><a id="14__231"></a>1.4 类的作用域</h5> 
<p><strong>所谓类的作用域就是指在类的声明中的一对花括号所形成的作用域。一个类的所有 成员都在该类的作用域内。一个类的任何成员可以引用该类的其它成员。</strong><br> 一个类的成员函数可以不受限制地引用该类的数据成员,而在该类作用域之外, 对该 类的数据成员和成员函数的引用则要受到一定的限制, 有时甚至是不允许的。这体现了 类的封装功能。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt; iostream .h &gt;</span> </span>
<span class="token keyword">class</span> <span class="token class-name">abc</span><span class="token punctuation">{<!-- --></span> 
<span class="token keyword">public</span><span class="token operator">:</span> 
	<span class="token keyword">int</span> i<span class="token punctuation">;</span> 
	<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 
	<span class="token keyword">void</span> <span class="token function">disp</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ”i <span class="token operator">=</span> ”<span class="token operator">&lt;</span> <span class="token operator">&lt;</span> i <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 可以引用类中的数据成员 i </span>
<span class="token punctuation">}</span> <span class="token punctuation">;</span> 
<span class="token keyword">void</span> abc∷<span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> si<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span> 
i <span class="token operator">=</span> si<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 可以引用类中的数据成员  </span>
<span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 非法, i 没有定义 </span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
abc ob<span class="token punctuation">;</span> ob <span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// 给数据成员 i 赋初值 2 </span>
ob <span class="token punctuation">.</span><span class="token function">disp</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> <span class="token comment">// 非法, i 没有定义, 可改写成</span>
 ob <span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">1</span> ob <span class="token punctuation">.</span><span class="token function">disp</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
 <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="2_254"></a>2.构造函数与析构函数</h4> 
<p>当声明一个类对象时, 编译程序需要为对 象分配存储空间, 进行必要的初始化, 这部分工作随着类的不同而不同。在 C + + 中, 由 构造函数来完成这些工作。构造函数是属于某一个类的,它可以由用户提供, 也可以由系 统自动生成。与构造函数对应的是析构函数, 当撤消类对象时, 析构函数就回收存储空 间,并做一些善后工作。析构函数也属于某一个类, 它可以由用户提供, 也可以由系统自 动生成</p> 
<h5><a id="21__256"></a>2.1 构造函数</h5> 
<p><strong>构造函数是一种特殊的成员函数,它主要用于为对象分配空间, 进行初始化。构造函 数具有一些特殊的性质:</strong></p> 
<ol><li><strong>构造函数的名字必须与类名相同。</strong></li><li><strong>构造函数可以有任意类型的参数, 但不能具有返回类型。</strong></li><li><strong>定义对象时, 编译系统会自动地调用构造函数。</strong></li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">complex</span><span class="token punctuation">{<!-- --></span> 
<span class="token keyword">private</span> <span class="token operator">:</span> 
	<span class="token keyword">double</span> real<span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 表示复数的实部 
	<span class="token keyword">double</span> imag<span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 表示复数的虚部 
<span class="token keyword">public</span><span class="token operator">:</span> 
	complex <span class="token punctuation">(</span> <span class="token keyword">double</span> r<span class="token punctuation">,</span> <span class="token keyword">double</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token operator">/</span> 定义构造函数<span class="token punctuation">,</span> 其名与类名相同 
	<span class="token punctuation">{<!-- --></span> real <span class="token operator">=</span> r<span class="token punctuation">;</span> imag <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">/</span> <span class="token operator">/</span> 在构造函数中<span class="token punctuation">,</span> 对私有数据 real 和 imag 赋值 
	<span class="token keyword">double</span> <span class="token function">abscomplex</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span><span class="token keyword">double</span> t<span class="token punctuation">;</span> t <span class="token operator">=</span> real <span class="token operator">*</span> real <span class="token operator">+</span> imag <span class="token operator">*</span> imag<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token function">sgrt</span><span class="token punctuation">(</span> t<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre> 
<p><strong>构造函数不能像其它成员函数那样被显式地调用,它是在定义对象的同时调用的, 其 一般格式为:</strong></p> 
<pre><code class="prism language-cpp">类名 对象名<span class="token punctuation">(</span>实参表<span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre> 
<p><strong>这里的“类名”与构造函数名相同“, 实参表”是为构造函数提供的实际参数。</strong><br> <strong>说明:</strong></p> 
<ol><li><strong>构造函数的名字必须与类名相同, 否则编译程序将把它当作一般的成员函数来 处理。</strong></li><li><strong>构造函数没有返回值, 在声明和定义构造函数时, 是不能说明它的类型的,甚至 说明为 void 类型也不行。</strong></li><li><strong>在实际应用中, 通常需要给每个类定义构造函数。如果没有给类定义构造函数, 则编译系统自动地生成一个缺省的构造函数。这个缺省的构造函数不带任何参数,它只能为对象开辟一个存储空间, 而不能给对象中的 数据成员赋初值,这时的初始值是随机数, 程序运行时可能会造成错误。</strong></li><li><strong>构造函数可以是不带参数的</strong></li><li><strong>构造函数也可采用构造初始化表对数据成员进行初始化, 这是某些程序员喜欢 使用的方法。</strong></li><li><strong>对没有定义构造函数的类, 其公有数据成员可以用初始值表进行初始化</strong></li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">int</span> i<span class="token punctuation">;</span> 
	<span class="token keyword">char</span> j<span class="token punctuation">;</span> 
	<span class="token keyword">float</span> f<span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span> 
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> I<span class="token punctuation">,</span> <span class="token keyword">char</span> J<span class="token punctuation">,</span> <span class="token keyword">float</span> F<span class="token punctuation">)</span>∶<span class="token function">i</span><span class="token punctuation">(</span> I<span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token function">j</span><span class="token punctuation">(</span>J<span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre> 
<h5><a id="22__300"></a>2.2 缺省参数的构造函数</h5> 
<p>对于带参数的构造函数,在定义对象时必须给构造函数传递参数, 否则构造函数将不 被执行。但在实际使用中,有些构造函数的参数值通常是不变的, 只有在特殊情况下才需 要改变它的参数值,这时可以将其定义成带缺省参数的构造函数</p> 
<pre><code class="prism language-cpp">complex <span class="token punctuation">(</span> <span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">0</span> <span class="token number">.0</span> <span class="token punctuation">,</span> <span class="token keyword">double</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token number">.0</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 含有缺省参数的构造函数
complex S1<span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 不传递参数<span class="token punctuation">,</span> 全部用缺省值
</code></pre> 
<h5><a id="23__308"></a>2.3 析构函数</h5> 
<p><strong>析构函数也是一种特殊的成员函数。它执行与构造函数相反的操作, 通常用于执行 一些清理任务,如释放分配给对象的内存空间等。析构函数有以下一些特点:</strong></p> 
<ol><li><strong>析构函数与构造函数名字相同, 但它前面必须加一个波浪号( ～ )。</strong></li><li><strong>析构函数没有参数, 也没有返回值, 而且不能重载, 因此在一个类中只能有一个析构函数。</strong></li><li><strong>当撤消对象时, 编译系统会自动地调用析构函数。</strong></li></ol> 
<p><strong>说明:每个类必须有一个析构函数。若没有显式地为一个类定义析构函数, 编译系统 会自动地生成一个缺省的析构函数。例如, 编译系统为类 complex 生成缺省的构造函数 如下所示: complex∷～ complex ( ) { }</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">string</span> _data<span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">char</span> <span class="token operator">*</span> str<span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span> 
string <span class="token operator">-</span> data <span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span> s<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span> 
str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">;</span> 
<span class="token function">strcpy</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span>s<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token operator">~</span>string <span class="token operator">-</span> <span class="token function">data</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span> 
<span class="token keyword">delete</span> str<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token keyword">void</span> get <span class="token operator">-</span> <span class="token function">info</span><span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
<span class="token keyword">void</span> sent <span class="token operator">-</span> <span class="token function">info</span><span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
<span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre> 
<p><strong>这是构造函数和析构函数常见的用法,即在构造函数中用运算符 new 为字符串分配 存储空间,最后在析构函数中用运算符 delete 释放已分配的存储空间</strong></p> 
<h5><a id="24__333"></a>2.4 重载构造函数</h5> 
<p>与一般的成员函数一样, C + + 允许重载构造函数, 以适应不同的场合。</p> 
<pre><code class="prism language-cpp"> <span class="token function">A</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 不带参数的构造函数 <span class="token operator">?</span>
 <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 只带一个整型参数的构造函数 
 <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 带两个参数的构造函数<span class="token punctuation">,</span> 一个是整型<span class="token punctuation">,</span>另一个是字符型 
 <span class="token function">A</span><span class="token punctuation">(</span> <span class="token keyword">float</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 带两个参数的构造函数<span class="token punctuation">,</span> 一个是浮点型<span class="token punctuation">,</span>另一个是字符型
</code></pre> 
<p><strong>说明:在重载没有参数和带缺省参数的构造函数时, 有可能产生二义性,例如:</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">x</span><span class="token punctuation">{<!-- --></span> 
<span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 没有参数的构造函数 
<span class="token function">x</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 带缺省参数的构造函数 
<span class="token punctuation">}</span> <span class="token punctuation">;</span> 
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
x <span class="token function">one</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 正确<span class="token punctuation">,</span>调用 <span class="token function">x</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">)</span> 
x two<span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 存在二义性 
<span class="token operator">/</span> <span class="token operator">/</span> … 
<span class="token punctuation">}</span>
</code></pre> 
<p>该例定义了两个重载构造函数 x, 其中一个没有参数, 另一个带有一个缺省参数。创 建对象 two 时, 由于没有给出参数,它既可以调用第一个构造函数, 也可以调用第二个构 造函数。这时,编译系统无法确定应该调用哪一个构造函数, 因此产生了二义性。在实际 应用时,一定要注意避免这种情况。</p> 
<h5><a id="25__356"></a>2.5 拷贝构造函数</h5> 
<p><strong>拷贝构造函数是一种特殊的构造函数。它用于依据已存在的对象建立一个新对象。 典型的情况是,将参数代表的对象逐域拷贝到新创建的对象中。</strong><br> 用户可以根据自己的需要定义拷贝构造函数,系统也可以为类产生一个缺省的拷贝 构造函数。<br> <strong>1.自定义拷贝构造函数</strong><br> 自定义拷贝构造函数的一般形式如下:</p> 
<pre><code class="prism language-cpp">classname <span class="token punctuation">(</span> <span class="token keyword">const</span> classname <span class="token operator">&amp;</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token operator">/</span> <span class="token operator">/</span> 拷贝构造函数的函数体 <span class="token punctuation">}</span>
</code></pre> 
<p><strong>其中,ob 是用来初始化另一个对象的对象的引用。</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt; iostream .h &gt;</span> </span>
<span class="token keyword">class</span> <span class="token class-name">point</span><span class="token punctuation">{<!-- --></span> 
<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">point</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token operator">/</span> 构造函数 
<span class="token punctuation">{<!-- --></span> x <span class="token operator">=</span> a<span class="token punctuation">;</span> y <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token function">point</span><span class="token punctuation">(</span> <span class="token keyword">const</span> point <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token operator">/</span> 拷贝构造函数 
<span class="token punctuation">{<!-- --></span>x <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> p <span class="token punctuation">.</span>x<span class="token punctuation">;</span> y <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> p <span class="token punctuation">.</span>y<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> x <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ” ”<span class="token operator">&lt;</span> <span class="token operator">&lt;</span> y <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> <span class="token punctuation">;</span> 
main <span class="token punctuation">(</span> <span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>point p1 <span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 定义类 point 的对象 p1 
point p2 <span class="token punctuation">(</span> p1<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 显式调用拷贝构造函数<span class="token punctuation">,</span>创建对象 p2 
p1 <span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
p2 <span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
<span class="token keyword">return</span> <span class="token number">0</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>在定义对象 p2 时, 虽然从形式上看是将对象 p1 赋值给了对象 p2, 但实际上调用的 是拷贝构造函数, 在对象 p2 被创建 时, 将对象 p1 的值逐域 拷贝给对 象 p2, 运行结 果 同上。</strong><br> <strong>2.缺省的拷贝构造函数</strong><br> <strong>如果没有编写自定义的拷贝构造函数, C + + 会自动地将一个已存在的对象复制给 新对象,这种按成员逐一复制的过程是由缺省拷贝构造函数自动完成的。</strong><br> <strong>说明:</strong></p> 
<ol><li><strong>与一般的构造函数一样, 拷贝构造函数没有返回值。</strong></li><li><strong>通常缺省的拷贝构造函数是能够胜任工作的, 但若类中有指针类型时, 按成员复 制的方法有时会产生错误。</strong></li></ol> 
<h4><a id="3_393"></a>3.对象数组与对象指针</h4> 
<h5><a id="31__394"></a>3.1 对象数组</h5> 
<p>对象数组是指每一数组元素都是对象的数组, 也就是说, 若一个类有若干个对象, 我 们把这一系列的对象用一个数组来存放。<br> <strong>如果类中含有用户定义的构造函数, 而且构造函数带有参数, 则定义对象数组时, 可 通过初始值表进行赋值。</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt; iostream .h &gt;</span> </span>
<span class="token keyword">class</span> <span class="token class-name">exam</span>
<span class="token punctuation">{<!-- --></span> 
<span class="token keyword">int</span> x<span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span> 
<span class="token function">exam</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> x <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token keyword">int</span> get <span class="token operator">-</span> <span class="token function">x</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
 <span class="token punctuation">}</span> <span class="token punctuation">;</span>
  main <span class="token punctuation">(</span> <span class="token punctuation">)</span> 
  <span class="token punctuation">{<!-- --></span>exam ob<span class="token punctuation">[</span><span class="token number">4</span> <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">11</span> <span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span> <span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">}</span> <span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 通过初始值表给对象数组赋值 
  <span class="token keyword">int</span> i<span class="token punctuation">;</span> 
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token punctuation">;</span> i <span class="token operator">+</span> <span class="token operator">+</span> <span class="token punctuation">)</span> 
  cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ob<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">.</span>get <span class="token operator">-</span> <span class="token function">x</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token operator">&lt;</span>′′<span class="token punctuation">;</span> cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> endl<span class="token punctuation">;</span> 
  <span class="token keyword">return</span> <span class="token number">0</span> <span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
</code></pre> 
<p><strong>若类中含有构造函数,那么定义对象数组时, 也可通过不带参数的构造函数或带有缺 省参数的构造函数给对象数组元素赋值</strong></p> 
<h5><a id="32__416"></a>3.2 对象指针</h5> 
<p><strong>在 C + + 语言中可以直接引用对象, 也可以通过指向该对象的指针引用对象。对 象指针是 C + + 的重要特性之一。</strong><br> <strong>1 . 用指针引用单个对象成员</strong><br> 说明对象指针的语法和说明其它数据类型指针的语法相同。使用对象指针时, 首先 要把它指向一个已创建的对象,然后才能引用该对象的成员。<br> <strong>在一般情况下,用点运算符(·) 来引用对象成员, 当用指向对象的指针来引用对象成 员时,就要用“ - &gt;”操作符。</strong></p> 
<pre><code class="prism language-cpp">main <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
exe ob<span class="token punctuation">,</span> <span class="token operator">*</span> p<span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 声明类 exe 的对象 ob 和类 exe 的对象指针 p 
ob <span class="token punctuation">.</span>set <span class="token operator">-</span> <span class="token function">a</span><span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 
ob <span class="token punctuation">.</span>show <span class="token operator">-</span> <span class="token function">a</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
p <span class="token operator">=</span> <span class="token operator">&amp;</span>ob<span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 将 p 指针指向对象 ob 
p <span class="token operator">-</span> <span class="token operator">&gt;</span> show <span class="token operator">-</span> a <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
<span class="token keyword">return</span> <span class="token number">0</span> <span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中, 声明了一个类 exe , ob 是类 exe 的一个对象, p 是类 exe 的对象指针, 对象 ob 的地址是用地址操作符( &amp; )获得并赋给对象指针 p 的。<br> <strong>2 . 用对象指针引用对象数组</strong></p> 
<p><strong>对象指针不仅能引用单个对象, 也能引用对象数组。</strong></p> 
<pre><code class="prism language-cpp">main <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
exe ob<span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token operator">*</span> p<span class="token punctuation">;</span> 
ob<span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">]</span> <span class="token punctuation">.</span>set <span class="token operator">-</span> a <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 
ob<span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">]</span> <span class="token punctuation">.</span>set <span class="token operator">-</span> a <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 
p <span class="token operator">=</span> ob<span class="token punctuation">;</span> 
p <span class="token operator">-</span> <span class="token operator">&gt;</span> show <span class="token operator">-</span> a <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
p <span class="token operator">+</span> <span class="token operator">+</span> <span class="token punctuation">;</span> 
p <span class="token operator">-</span> <span class="token operator">&gt;</span> show <span class="token operator">-</span> a <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
<span class="token keyword">return</span> <span class="token number">0</span> <span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>一般而言,当指针加 1 或减 1 时, 它总是指向其基本类型中相邻的一个元素, 对象指针也是如此。本例中指针对象 p 加 1 时,指向下一个数组元素。</strong></p> 
<h5><a id="33_this__452"></a>3.3 this 指针</h5> 
<p><strong>C + + 提供了一个特殊的对象指针———this 指针。它是成员函数所属对象的指针。 它指向类对象的地址。</strong><br> 成员函数访问类中数据成员的格式可以 写成:<strong>this - &gt; 成员变量</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt; iostream .h &gt;</span> </span>
<span class="token keyword">class</span> <span class="token class-name">exth</span><span class="token punctuation">{<!-- --></span> 
<span class="token keyword">int</span> i<span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span> 
<span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">this</span> <span class="token operator">-</span> <span class="token operator">&gt;</span> i <span class="token operator">=</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">/</span> <span class="token operator">/</span> 与“i <span class="token operator">=</span> val<span class="token punctuation">;</span>”相同 
<span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token operator">-</span> <span class="token operator">&gt;</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">/</span> <span class="token operator">/</span> 与“<span class="token keyword">return</span> i<span class="token punctuation">;</span>”相同 
<span class="token punctuation">}</span> <span class="token punctuation">;</span> 
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
exth obj <span class="token punctuation">;</span> 
obj <span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> obj <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>当一个对象调用成员函数时, 该成员函数的 this 指针便指向这个对象。如果不同的 对象调用同一个成员函数, C + + 编译器将根据该成员函数的 this 指针指向的对象来确 定应该引用哪一个对象的数据成员。<br> <strong>那么 C + + 如何使 this 指针指向对象 ob 呢 ?</strong><br> <strong>ob .init(′x′,12) ;</strong><br> 将上述调用 init( ) 函数的语句转换成如下形式:<br> <strong>init( &amp;ob,′x′, 12 ) ;</strong><br> 换句话说, C + + 把类对象作为参数传递给函数(传地址) 。虽然程序中的成员函数 init ( ) 没有对应的形参,但程序编译时 C + + 将其转换成以下形式:<br> <strong>void init( abc * this, char ma, int mb) { this - &gt; a = ma ; this - &gt; b = mb; }</strong><br> 由于函数调用时, 第一个参数是按地址传递的, 因此当对象 ob 调用函数 init( ) 时, this 指 针便指向 ob,于是隐式指针 this 保证了成员函数 init( ) 的操作对象确实是对象 ob。</p> 
<h4><a id="4_478"></a>4.向函数传递对象</h4> 
<p><strong>把对象的拷贝而不是对象本身传给函 数。因此函数中对对象的任何修改均不影响调用该函数的对象本身。</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> sqr <span class="token operator">-</span> <span class="token function">it</span><span class="token punctuation">(</span> tr ob <span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
ob <span class="token punctuation">.</span>set <span class="token operator">-</span> <span class="token function">i</span><span class="token punctuation">(</span>ob <span class="token punctuation">.</span>get <span class="token operator">-</span> <span class="token function">i</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token operator">*</span> ob <span class="token punctuation">.</span>get <span class="token operator">-</span> <span class="token function">i</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ”copy of obj has i value of ”<span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ob <span class="token punctuation">.</span>get <span class="token operator">-</span> <span class="token function">i</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ”\ n”<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>如同其它类型的变量一样, 也可以将对象的地址传递给函数。这时函数对对象的修 改将影响调用该函数的对象本身。</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> sqr <span class="token operator">-</span> <span class="token function">it</span><span class="token punctuation">(</span> tr <span class="token operator">*</span> ob <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
ob <span class="token operator">-</span> <span class="token operator">&gt;</span> set <span class="token operator">-</span> <span class="token function">i</span><span class="token punctuation">(</span>ob <span class="token operator">-</span> <span class="token operator">&gt;</span> get <span class="token operator">-</span> <span class="token function">i</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token operator">*</span> ob <span class="token operator">-</span> <span class="token operator">&gt;</span> get <span class="token operator">-</span> <span class="token function">i</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ”Copy of obj has i value of ”<span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ob <span class="token operator">-</span> <span class="token operator">&gt;</span> get <span class="token operator">-</span> <span class="token function">i</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> 
cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> ”\ n”<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="5____500"></a>5.静 态 成 员</h4> 
<p><strong>静态成员的特性是不管这个类创建了多少个对象, 而其静态 成员只有一个拷贝(副本) ,这个拷贝被所有属于这个类的对象共享。</strong></p> 
<p><strong>静态成员在类中有两种情况, 即静态数据成员和静态成员函数。</strong></p> 
<h5><a id="51__504"></a>5.1 静态数据成员</h5> 
<p>在一个类中,若将一个数据成员说明为 static, 这种成员称为静态数据成员。与一般 的数据成员不同,无论建立多少个类的对象, 都只有一个静态数据的拷贝。<br> <strong>说明:</strong></p> 
<ol><li><strong>静态数据成员属于类( 准确地说,是属于类中一个对象集合 ) , 而不像普通数据成 员那样属于某一对象,因此可以使用“类名∷”访问静态的数据成员。例如上面例子中的 Student∷count。</strong></li><li><strong>静态数据成员不能在类中进行初始化, 因为在类中不给它分配内存空间, 必须在 类外的其它地方为它提供定义。一般在 main( )开始之前, 类的声明之后的特殊地带为它 提供定义和初始化。缺省时,静态成员被初始化为零。</strong></li><li><strong>静态数据成员与静态变量一样, 是在编译时创建并初始化。它在该类的任何对 象被建立之前就存在,它可以在程序内部不依赖于任何对象被访问。</strong></li><li><strong>C + + 支持静态数据成员的一个主要原因是可以不必使用全局变量。依赖于全 局变量的类几乎都是违反面向对象程序设计的封装原理的。静态数据成员的主要用途是 定义类的各个对象所公用的数据,如统计总数、平均数等。</strong></li></ol> 
<h5><a id="52__513"></a>5.2 静态成员函数</h5> 
<p><strong>在类定义中,前面有 static 说明的成员函数称为静态成员函数。静态成员函数属于 整个类,是该类所有对象共享的成员函数, 而不属于类中的某个对象。</strong><br> 静态成员函数首先是一个成员函数,因此它不能像类以外的其它函数那样使用, 在使 用时要用“类名∷”作为它的限定词,或指出它作用在哪个对象上。其次静态成员函数是 一种特殊的成员函数,它不属于某一个特定的对象<br> <strong>一般而言, 静态成员函数访问的基本上是静态 数据成员或全局变量。</strong></p> 
<p><strong>下面对静态成员函数的使用再作几点说明:</strong></p> 
<ol><li><strong>静态成员函数可以定义成内嵌的, 也可以在类外定义, 在类外定义时, 不要用 static 前缀。</strong></li><li><strong>编译系统将静态成员函数限定为内部连接, 也就是说,与现行文件相连接的其它 文件中的同名函数不会与该函数发生冲突,维护了该函数使用的安全性, 这是使用静态成 员函数的一个原因。</strong></li><li><strong>使用静态成员函数的另一个原因是, 可以用它在建立任何对象之前处理静态数 据成员,这是普通成员函数不能实现的功能。</strong></li><li><strong>在一般的成员函数中都隐含有一个 this 指针, 用来指向对象自身,而在静态成员 函数中是没有 this 指针的,因为它不与特定的对象相联系, 调用时使用如下格式较好:</strong><br> <strong>类名∷静态成员函数名( )</strong></li><li><strong>一般而言, 静态成员函数不访问类中的非静态成员。若确实需要,静态成员函数 只能通过对象名(或指向对象的指针) 访问该对象的非静态成员。</strong><br> <strong>static void display (small - cat &amp; w) { cout &lt; &lt; ”The small - cat weights”&lt; &lt; w .weight &lt; &lt; ”pounds \ n”; }</strong></li></ol> 
<h4><a id="6__531"></a>6.友 元</h4> 
<p><strong>在不放弃私有数据安全性的情况下, 使得类外部的函 数或类能够访问类中的私有成员,在 C + + 中就用友元作为实现这个要求的辅助手段。</strong></p> 
<h5><a id="61__533"></a>6.1 友元函数</h5> 
<p><strong>友元函数不是当前类的成员函数,而是独立于当前类的外部函数, 但它可以访问该类 的所有对象的成员,包括私有成员和公有成员。</strong><br> 在类定义中声明友元函数时, 需在其函数名前加上关键字 friend。此声明可以放在 公有部分,也可以放在私有部分。友元函数可以定义在类内部, 也可以定义在类的外部。<br> <strong>说明:</strong></p> 
<ol><li><strong>友元函数虽然可以访问类对象的私有成员, 但它毕竟不是成员函数。因此,在类 的外部定义友元函数时,不必像成员函数那样, 在函数名前加上“类名∷”。</strong></li><li><strong>友元函数一般带有一个该类的入口参数。因为友元函数不是类的成员, 所以它 不能直接引用对象成员的名字,也不能通过 this 指针引用对象的成员, 它必须通过作为入 口参数传递进来的对象名或对象指针来引用该对象的成员。</strong></li><li><strong>当一个函数需要访问多个类时, 友元函数非常有用,普通的成员函数只能访问其所属的类,但是多个类的友元函数能够访问相应的所有类的数据。</strong><br> <strong>friend void prdata( const girl plg , const boy plb) ; / / 声明函数 prdata( )</strong></li><li><strong>友元函数通过直接访问对象的私有成员,提高了程序运行的效率。</strong></li></ol> 
<h5><a id="62__543"></a>6.2 友元成员</h5> 
<p><strong>除了一般的函数可以作为某个类的友元外, 一个类的成员函数也可以作为另一个类 的友元,这种成员函数不仅可以访问自己所在类对象中的私有成员和公有成员, 还可以访 问 friend 声明语句所在类对象中的私有成员和公有成员, 这样能使两个类相互合作、协调 工作,完成某一任务。</strong></p> 
<p><strong>说明:</strong></p> 
<ol><li><strong>一个类的成员函数作为另一个类的友元函数时, 必须先定义这个类</strong><br> <strong>friend void boy∷disp( girl &amp; ) ;</strong></li><li><strong>程序中第 3 行“class girl;”为向前引用</strong></li></ol> 
<h5><a id="63__553"></a>6.3 友元类</h5> 
<p><strong>不仅函数可以作为一个类的友元, 一个类也可以作为另一个类的友元。</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token punctuation">{<!-- --></span> <span class="token operator">/</span> <span class="token operator">/</span> … <span class="token punctuation">}</span> <span class="token punctuation">;</span> 
<span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">{<!-- --></span> <span class="token operator">/</span> <span class="token operator">/</span> …
<span class="token keyword">friend</span> Y<span class="token punctuation">;</span> <span class="token operator">/</span> <span class="token operator">/</span> 声明类 Y 为类 X 的友元类
<span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>当一个类被说明为另一个类的友元时,它的所有的成员函数都成为另一个类的友元 函数,这就意味着作为友元的类中的所有成员函数都可以访问另一个类中的私有成员。</strong><br> <strong>说明:</strong><br> <strong>友元关系是单向的,不具有交换性。若类 X 是类 Y 的友元(即在类 Y 定义中声 明 X 为 friend 类) , 类 Y 是否是 X 的友元,要看在类中是否有相应的声明。友元关系也不 具有传递性,若类 X 是类 Y 的友元, 类 Y 是类 Z 的友元, 不一定类 X 是类 Z 的友元。</strong></p> 
<h4><a id="7_567"></a>7.类对象作为成员</h4> 
<p>在类定义中定义的数据成员一般都是基本的数据类型。但是类中的成员也可以是对 象,叫做对象成员。使用对象成员着重要注意的问题是构造函数的定义方式, 即类内部对 象的初始化问题。<br> <strong>含有对象成员的类, 其构造函数和不含对象成员的构造函数有所不同</strong></p> 
<pre><code class="prism language-cpp">一般来说<span class="token punctuation">,</span>类 X 的构造函数的定义形式为<span class="token operator">:</span> 
X∷<span class="token function">X</span><span class="token punctuation">(</span>参数表 <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span>成员名 <span class="token number">1</span> <span class="token punctuation">(</span>参数表 <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>…<span class="token punctuation">,</span> 成员名 <span class="token function">n</span><span class="token punctuation">(</span> 参数表 n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
<span class="token operator">/</span> <span class="token operator">/</span> 构造函数体 
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>冒号后面的部分是对象成员的初始化列表,各对象成员的初始化列表用逗号分隔, 参数表 i(i 为 1 到 n )给出了初始化对象成员所需要的数据,它们一般来自参数表 0。</strong><br> <strong>当调用构造函数 X∷X( ) 时, 首先按各对象成员在类定义中的顺序依次调用它们的 构造函数,对这些对象初始化, 最后再执行 X∷X( )的函数体。析构函数的调用顺序与此 相反。</strong></p> 
<p><strong>说明:</strong></p> 
<ol><li><strong>声明一个含有对象成员的类, 首先要创建各成员对象。本例在声明类 girl 中, 定 义了对象成员 name :</strong><br> <strong>string name;</strong></li><li><strong>girl 类对象在调用构造函数进行初始化的同时, 也要对对象成员进行初始化, 因 为它也是属于此类的成员。因此在写类 girl 的构造函数时, 也缀上了对对象成员的初 始化:</strong><br> <strong>girl( char * st , int ag) : name (st)</strong> 于是在调用 girl 的构造函数进行初始化时,也给对象成员 name 赋上了初值。<br> 这里需要注意的是:在定义类 girl 的构造函数时, 必须缀上其对象成员的名字 name, 而不能缀上类名,若写成:<br> <strong>girl( char * st , int ag) :string(st)</strong><br> <strong>是不允许的,因为在类 girl 中是类 string 的对象 name 作为成员, 而不是类 string 作为其成 员。</strong></li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b3968d7837ed82200f2a1010336016d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">fedora chrome_如何在Fedora Linux上安装Chrome？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/72c764fcd80d2aa8f550ae3e9a811d42/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">爬虫进阶之scrapy项目实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>