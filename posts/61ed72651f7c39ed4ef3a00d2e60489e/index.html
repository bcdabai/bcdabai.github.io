<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[转]伪代码的写法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[转]伪代码的写法" />
<meta property="og:description" content="伪代码的写法（附：12种排序算法详解）
转自：http://blog.sina.com.cn/s/blog_134451adb0102wfgu.html
伪代码（Pseudocode）是一种算法描述语言。使用伪代码的目的是为了使被描述的算法可以容易地以任何一种编程语言（Pascal，C，Java，etc）实现。因此，伪代码必须结构清晰、代码简单、可读性好，并且类似自然语言。 介于自然语言与编程语言之间。
它以编程语言的书写形式指明算法的职能。相比于程序语言（例如Java, C&#43;&#43;,C, Dephi 等等）它更类似自然语言。它是半角式化、不标准的语言。我们可以将整个算法运行过程的结构用接近自然语言的形式（这里，你可以使用任何一种你熟悉的文字，中文，英文 等等，关键是你把你程序的意思表达出来）描述出来. 使用伪代码, 可以帮助我们更好的表述算法, 不用拘泥于具体的实现.
人们在用不同的编程语言实现同一个算法时意识到，他们的实现（注意:这里是实现,不是功能）很不同。尤其是对于那些熟练于不同编程语言的程序员要理解一个(用其他编程语言编写的程序的)功能时可能很难，因为程序语言的形式限制了程序员对程序关键部分的理解。这样伪代码就应运而生了。
当考虑算法功能（而不是其语言实现）时，伪代码常常得到应用。计算机科学在教学中通常使用虚拟码，以使得所有的程序员都能理解。
综上，简单的说，让人便于理解的代码。不依赖于语言的，用来表示程序执行过程，而不一定能编译运行的代码。在数据结构讲算法的时候用的很多。 语法规则
例如，类Pascal语言的伪代码的语法规则是： 在伪代码中，每一条指令占一行（else if，例外）。指令后不跟任何符号（Pascal和C中语句要以分号结尾）。书写上的“缩进”表示程序中的分支程序结构。这种缩进风格也适用于if-then-else语句。用缩进取代传统Pascal中的begin和end语句来表示程序的块结构可以大大提高代码的清晰性；同一模块的语句有相同的缩进量，次一级模块的语句相对与其父级模块的语句缩进。
算法的伪代码语言在某些方面可能显得不太正规，但是给我们描述算法提供了很多方便，并且可以使我们忽略算法实现中很多麻烦的细节。通常每个算法开始时都要描述它的输入和输出，而且算法中的每一行都给编上号码，在解释算法的过程中会经常使用算法步骤中的行号来指代算法的步骤。算法的伪代码描述形式上并不是非常严格，其主要特性和通常的规定如下：
1) 算法中出现的数组、变量可以是以下类型：整数、实数、字符、位串或指针。通常这些类型可以从算法的上下文来看是清楚的，并不需要额外加以说明。
2) 在算法中的某些指令或子任务可以用文字来叙述，例如，&#34;设x是A中的最大项&#34;，这里A是一个数组；或者&#34;将x插入L中&#34;，这里L是一个链表。这样做的目的是为了避免因那些与主要问题无关的细节使算法本身杂乱无章。
3) 算术表达式可以使用通常的算术运算符（&#43;，-，*，/，以及表示幂的^）。逻辑表达式可以使用关系运算符=,≠,&lt;,&gt;,≤和≥，以及逻辑运算符与(and),或（or），非（not）。
4) 赋值语句是如下形式的语句：a&lt;-b 。
这里a是变量、数组项，b是算术表达式、逻辑表达式或指针表达式。语句的含义是将b的值赋给a。
5) 若a和b都是变量、数组项，那么记号a&lt;-&gt;b 表示a和b的内容进行交换。
6) goto语句具有形式 goto label（goto标号）它将导致转向具有指定标号的语句。
7) 条件语句有以下两种形式：
if c then s或者 if c then s
else s′
这里c是逻辑表达式，s和s′是单一的语句或者是被括在do和end之间的语句串。对于上述两种形式，假若c为真，则s被执行一次。假若c为假，则在第一种形式中，if语句的执行就完成了，而在第二种形式中，执行s′。在所有的情况下，控制就进行到了下一个语句，除非在s或s′中的goto语句使控制转向到其它地方。
8) 有两种循环指令：while和for。
while语句的形式是
while c do s
end
这里c是逻辑表达式，而s是由一个或更多个语句组成的语句串。当c为真时，执行s。在每一次执行s之前，c都被检查一下；假若c为假，控制就进行到紧跟在while语句后面的语句。注意，当控制第一次达到while语句时，假若c为假，则s一次也不执行。 for语句的形式是
for var init to limit by incr do
s" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/61ed72651f7c39ed4ef3a00d2e60489e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-20T16:59:18+08:00" />
<meta property="article:modified_time" content="2018-11-20T16:59:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[转]伪代码的写法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>伪代码的写法（附：12</strong><strong>种排序算法详解）</strong></p> 
<p>转自：<a href="http://blog.sina.com.cn/s/blog_134451adb0102wfgu.html" rel="nofollow">http://blog.sina.com.cn/s/blog_134451adb0102wfgu.html</a><br> 伪代码（Pseudocode）是一种算法描述语言。使用伪代码的目的是为了使被描述的算法可以容易地以任何一种编程语言（Pascal，C，Java，etc）实现。因此，伪代码必须结构清晰、代码简单、可读性好，并且类似自然语言。 介于自然语言与编程语言之间。</p> 
<p>　　它以编程语言的书写形式指明算法的职能。相比于程序语言（例如Java, C++,C, Dephi 等等）它更类似自然语言。它是半角式化、不标准的语言。我们可以将整个算法运行过程的结构用接近自然语言的形式（这里，你可以使用任何一种你熟悉的文字，中文，英文 等等，关键是你把你程序的意思表达出来）描述出来. 使用伪代码, 可以帮助我们更好的表述算法, 不用拘泥于具体的实现.</p> 
<p>　　人们在用不同的编程语言实现同一个算法时意识到，他们的实现（注意:这里是实现,不是功能）很不同。尤其是对于那些熟练于不同编程语言的程序员要理解一个(用其他编程语言编写的程序的)功能时可能很难，因为程序语言的形式限制了程序员对程序关键部分的理解。这样伪代码就应运而生了。</p> 
<p>　　当考虑算法功能（而不是其语言实现）时，伪代码常常得到应用。计算机科学在教学中通常使用虚拟码，以使得所有的程序员都能理解。</p> 
<p>　　综上，简单的说，让人便于理解的代码。不依赖于语言的，用来表示程序执行过程，而不一定能编译运行的代码。在数据结构讲算法的时候用的很多。 </p> 
<p>语法规则</p> 
<p>　　例如，类Pascal语言的伪代码的语法规则是： 在伪代码中，每一条指令占一行（else if，例外）。指令后不跟任何符号（Pascal和C中语句要以分号结尾）。书写上的“缩进”表示程序中的分支程序结构。这种缩进风格也适用于if-then-else语句。用缩进取代传统Pascal中的begin和end语句来表示程序的块结构可以大大提高代码的清晰性；同一模块的语句有相同的缩进量，次一级模块的语句相对与其父级模块的语句缩进。</p> 
<p>    算法的伪代码语言在某些方面可能显得不太正规，但是给我们描述算法提供了很多方便，并且可以使我们忽略算法实现中很多麻烦的细节。通常每个算法开始时都要描述它的输入和输出，而且算法中的每一行都给编上号码，在解释算法的过程中会经常使用算法步骤中的行号来指代算法的步骤。算法的伪代码描述形式上并不是非常严格，其主要特性和通常的规定如下：</p> 
<p>        1) 算法中出现的数组、变量可以是以下类型：整数、实数、字符、位串或指针。通常这些类型可以从算法的上下文来看是清楚的，并不需要额外加以说明。</p> 
<p>        2) 在算法中的某些指令或子任务可以用文字来叙述，例如，"设x是A中的最大项"，这里A是一个数组；或者"将x插入L中"，这里L是一个链表。这样做的目的是为了避免因那些与主要问题无关的细节使算法本身杂乱无章。</p> 
<p>        3) 算术表达式可以使用通常的算术运算符（+，-，*，/，以及表示幂的^）。逻辑表达式可以使用关系运算符=,≠,&lt;,&gt;,≤和≥，以及逻辑运算符与(and),或（or），非（not）。</p> 
<p>        4) 赋值语句是如下形式的语句：a&lt;-b 。</p> 
<p>这里a是变量、数组项，b是算术表达式、逻辑表达式或指针表达式。语句的含义是将b的值赋给a。</p> 
<p>        5) 若a和b都是变量、数组项，那么记号a&lt;-&gt;b 表示a和b的内容进行交换。</p> 
<p>        6) goto语句具有形式             goto label（goto标号）它将导致转向具有指定标号的语句。</p> 
<p>        7) 条件语句有以下两种形式：</p> 
<p>                                            if c then s或者 </p> 
<p>                                               if c then s</p> 
<p>                                                  else s′</p> 
<p>这里c是逻辑表达式，s和s′是单一的语句或者是被括在do和end之间的语句串。对于上述两种形式，假若c为真，则s被执行一次。假若c为假，则在第一种形式中，if语句的执行就完成了，而在第二种形式中，执行s′。在所有的情况下，控制就进行到了下一个语句，除非在s或s′中的goto语句使控制转向到其它地方。</p> 
<p>         8) 有两种循环指令：while和for。</p> 
<p>         while语句的形式是</p> 
<p>                                              while c do  </p> 
<p>                                                    s</p> 
<p>                                                  end</p> 
<p>这里c是逻辑表达式，而s是由一个或更多个语句组成的语句串。当c为真时，执行s。在每一次执行s之前，c都被检查一下；假若c为假，控制就进行到紧跟在while语句后面的语句。注意，当控制第一次达到while语句时，假若c为假，则s一次也不执行。 </p> 
<p>       for语句的形式是</p> 
<p>                                      for var init to limit by incr do</p> 
<p>                                                        s</p> 
<p>                                                      end</p> 
<p>这里var是变量，init、limit和incr都是算术表达式，而s是由一个或多个语句组成的语句串。初始时，var被赋予init的值。假若incr≥0，则只要var≤limit，就执行s并且将incr加到var上。（假若incr&lt;0，则只要var≥limit，就执行s并且将incr加到var上）。incr的符号不能由s来该改变。</p> 
<p>      9) exit语句可以在通常的结束条件满足之前，被用来结束while循环或者for循环的执行。exit导致转向到紧接在包含exit的（最内层）while或者for循环后面的一个语句。</p> 
<p>     10) return用来指出一个算法执行的终点；如果算法在最后一条指令之后结束，它通常是被省略的；它被用得最多的场合是检测到不合需要的条件时。return的后面可以紧接被括在引号的信息。</p> 
<p>      11) 算法中的注释被括在之中。诸如read和output之类的各种输入或者输出也在需要时被用到</p> 
<p><strong>伪代码实例</strong></p> 
<p><strong>　　</strong>伪代码只是像流程图一样用在程序设计的初期，帮助写出程序流程。简单的程序一般都不用写流程、写思路，但是复杂的代码，最好还是把流程写下来，总体上去考虑整个功能如何实现。写完以后不仅可以用来作为以后测试,维护的基础，还可用来与他人交流。但是，如果把全部的东西写下来必定可能会让费很多时间，那么这个时候可以采用伪代码方式。比如：</p> 
<p>　　IF 九点以前 THEN</p> 
<p>     do 私人事务；</p> 
<p>　　ELSE 9点到18点 THEN</p> 
<p>　　工作；</p> 
<p>　　ELSE</p> 
<p>　　下班;</p> 
<p>　　END IF</p> 
<p>　　这样不但可以达到文档的效果,同时可以节约时间. 更重要的是,使结构比较清晰,表达方式更加直观.</p> 
<p>　　下面介绍一种类Pascal语言的伪代码的语法规则。</p> 
<p>　　在伪代码中，每一条指令占一行(else if 例外，)，指令后不跟任何符号（Pascal和C中语句要以分号结尾）；</p> 
<p>　　书写上的“缩进”表示程序中的分支程序结构。这种缩进风格也适用于if-then-else语句。用缩进取代传统Pascal中的begin和end语句来表示程序的块结构可以大大提高代码的清晰性；同一模块的语句有相同的缩进量，次一级模块的语句相对与其父级模块的语句缩进；　</p> 
<p>　　在伪代码中，通常用连续的数字或字母来标示同一即模块中的连续语句，有时也可省略标号。</p> 
<p>　　符号△后的内容表示注释；</p> 
<p>　　在伪代码中，变量名和保留字不区分大小写，这一点和Pascal相同，与C或C++不同；</p> 
<p>　　在伪代码中，变量不需声明，但变量局部于特定过程，不能不加显示的说明就使用全局变量；</p> 
<p>　　赋值语句用符号←表示，x←exp表示将exp的值赋给x，其中x是一个变量，exp是一个与x同类型的变量或表达式（该表达式的结果与x同类型）；多重赋值i←j←e是将表达式e的值赋给变量i和j，这种表示与j←e和i←e等价。</p> 
<p>　　例如：</p> 
<p>　　x←y</p> 
<p>　　x←20*(y+1)</p> 
<p>　　x←y←30</p> 
<p>　　以上语句用C分别表示为：</p> 
<p>　　x = y;</p> 
<p>　　x = 20*(y+1);</p> 
<p>　　x = y = 30;</p> 
<p>　　选择语句用if-then-else来表示，并且这种if-then-else可以嵌套，与Pascal中的if-then-else没有什么区别。</p> 
<p>　　例如:</p> 
<p>　　if (Condition1)</p> 
<p>　　then [ Block 1 ]</p> 
<p>　　else if (Condition2)</p> 
<p>　　then [ Block 2 ]</p> 
<p>　　else [ Block 3 ]</p> 
<p>　　循环语句有三种：while循环、repeat-until循环和for循环，其语法均与Pascal类似，只是用缩进代替begin - end；</p> 
<p>　　例如：</p> 
<p>　　1. x ← 0</p> 
<p>　　2. y ← 0</p> 
<p>　　3. z ← 0</p> 
<p>　　4. while x &lt; N</p> 
<p>　　1. do x ← x + 1</p> 
<p>　　2. y ← x + y</p> 
<p>　　3. for t ← 0 to 10</p> 
<p>　　1. do z ← ( z + x * y ) / 100</p> 
<p>　　2. repeat</p> 
<p>　　1. y ← y + 1</p> 
<p>　　2. z ← z - y</p> 
<p>　　3. until z &lt; 0</p> 
<p>　　4. z ← x * y</p> 
<p>　　5. y ← y / 2</p> 
<p>　　　上述语句用C或C++来描述是：</p> 
<p>　　x = y = z = 0;</p> 
<p>　　while( z &lt; N )</p> 
<p>　　{<!-- --></p> 
<p>　　x ++;</p> 
<p>　　y += x;</p> 
<p>　　for( t = 0; t &lt; 10; t++ )</p> 
<p>　　{<!-- --></p> 
<p>　　z = ( z + x * y ) / 100;</p> 
<p>　　do {<!-- --></p> 
<p>　　y ++;</p> 
<p>　　z -= y;</p> 
<p>　　} while( z &gt;= 0 );</p> 
<p>     }</p> 
<p>　　z = x * y;</p> 
<p>　　}</p> 
<p>　　y /= 2;</p> 
<p>　　数组元素的存取有数组名后跟“[下标]”表示。例如A[j]指示数组A的第j个元素。符号“ …”用来指示数组中值的范围。</p> 
<p>　　例如：</p> 
<p>　　A[1…j]表示含元素A[1], A[2], … , A[j]的子数组；</p> 
<p>　　复合数据用对象(Object)来表示，对象由属性(attribute)和域(field)构成。域的存取是由域名后接由方括号括住的对象名表示。</p> 
<p>　　例如：数组可被看作是一个对象，其属性有length，表示其中元素的个数，则length[A]就表示数组A中的元素的个数。在表示数组元素和对象属性时都要用方括号，一般来说从上下文可以看出其含义。</p> 
<p>　　用于表示一个数组或对象的变量被看作是指向表示数组或对象的数据的一个指针。对于某个对象x的所有域f，赋值y←x就使f[y]=f[x]，更进一步，若有f[x]←3，则不仅有f[x]=3，同时有f[y]=3，换言之，在赋值y←x后，x和y指向同一个对象。</p> 
<p>　　有时，一个指针不指向任何对象，这时我们赋给他nil。</p> 
<p>　　函数和过程语法与Pascal类似。</p> 
<p>　　函数值利用 “return (函数返回值)” 语句来返回，调用方法与Pascal类似；过程用 “call 过程名”语句来调用；</p> 
<p>　　例如：　　1. x ← t + 10</p> 
<p>　　2. y ← sin(x)</p> 
<p>　　3. call CalValue(x,y)</p> 
<p>　　参数用按值传递方式传给一个过程：被调用过程接受参数的一份副本，若他对某个参数赋值，则这种变化对发出调用的过程是不可见的。当传递一个对象时，只是拷贝指向该对象的指针，而不拷贝其各个域。  </p> 
<p>​PS:用伪代码书写的程序形式来表达算法，这种伪代码在很多方面都与C、Pascal或Java等语言比较类似。如果熟悉这几种语言的话，阅读伪代码算法应该不会有什么困难。伪代码与真实代码的不同之处在于，在伪代码中，可以采用最具表达力的、最简明扼要的方法来表达一个给定的算法。有时，最清晰的方法就是英语，因此，当遇到在一段“真正的”代码中嵌入了一个英语短语或句子时，不要感到惊讶。在伪代码和真正的代码之间还有一点区别，就是伪代码一般不关心软件工程方面的问题。亦即，数据抽象、模块化和错误处理等问题往往都被忽略掉 了，以便更简练地表达算法的核心内容。</p> 
<p>伪代码中的约定：</p> 
<p>在伪代码的使用中有以下一些约定：</p> 
<p>1）书写上的“缩进”表示程序中的分程序（程序块）结构。用缩进取代传统的begin和end语句来表示程序的块结构，可以大大提高代码的清晰性。（在真正的程序设计语言里，一般不建议单独使用缩进来表示分程序结构，这是因为当代码跨页时，缩进的层次很难确定。）</p> 
<p>2）while,for,repeat等循环结构和if,then,else条件结构与Pascal中相同。（多数分程序结构的语言中都有与此等价的语言构造，具体的语法与Pascal中的可能有所不同。）然而，对for循环来说有一点不同，在Pascal中，循环计数器变量在退出循环时是未定义的，但在伪代码中，在退出循环后，循环计数器的值仍然保持。于是，紧接着一个for循环之后，循环计时器的值就是第一个超过for循环终值的那个数字。</p> 
<p>3）符合“▷”表示后面的部分是个注释。</p> 
<p>4）多重赋值  i←j←e是将表达式e的值赋给变量i和j；等价于赋值j←e,再进行赋值i←j。</p> 
<p>5）变量（如i,t和key等）是局部于给定过程的。在没有显示说明的情况下，我们不使用全局变量。</p> 
<p>6）数组元素是通过“数组名[下标]”这样的形式来访问的。例如，A[i]表示数组A的第i个元素。符合“..”用来表示数组中的一个取值范围，例如，A[1..j]就表示A的一个子数组，它包含了j个元素：A[1],A[2],…,A[j]。</p> 
<p>7）复合数据一般组织成对象，它们是由属性（attribute）或域（field）所组成的。域的访问是由域名后跟由方括号括住的对象名形式来表示。例如，数组可以被看作是一个对象，其属性有length，表示数组中元素的个数，如length[A]就表示数组A中的元素个数。在表示数组元素和对象属性时，都要用的方括号，一般来说，通过上下文就可以看出其含义。</p> 
<p>用于表示一个数组或对象的变量被看作是指向表示数组或对象的数据的一个指针。对于某个对象x的所有域f，赋值y←x就使得f[y] = f[x]。更进一步，如果有f[x] ← 3，则不仅有f[x] = 3，同时f[y] = 3。换言之，在赋值y←x后，x和y指向同一个对象。</p> 
<p>有时，一个指针不指向任何对象。这时，我们赋给它NIL。</p> 
<p>8）参数采用按值传递方式：被调用的过程会收到参数的一份副本。如果它对某个参数赋值的话，主调过程是看不见这一变动的。当对象被传递时，实际传递的是一个指向该对象数据的指针，而对象的各个域则不被拷贝。例如，如果x是某个被调用过程的参数，在被调用过程中的赋值x←y对主调过程来说是不可见的。但是，赋值f[x] = 3却是可见的。</p> 
<p>9）布尔运算符“and”和“or”都具有短路能力。亦即，当我们求表达式“x and y”的值时，首先计算x的值为FALSE，那么整个表达式的值就不可能为TRUE了，因而就无需再对y求值了。但是，如果x的值为TRUE的话，就必须进一步计算出y的值，才能确定整个表达式的值。类似地，在计算表达式“x or y”的值时，仅当x的值为FALSE时，才需要计算子表达式y的值。短路运算符允许我们写出如“x  ≠ NIL and f[x] = y”这样的布尔表达式，而不用担心当我们试图在x为NIL时计算f[x]，会发生怎样的情况。</p> 
<p><strong>​</strong></p> 
<p><strong>伪代码示例：</strong></p> 
<p>涉及到<strong>12</strong><strong>种排序算法(</strong><strong>包括插入排序、二分插入排序、希尔排序、选择排序、冒泡排序、鸡尾酒排序、快速排序、堆排序、归并排序、桶排序、计数排序和基数排序</strong>)。每一种算法都有基本介绍、算法原理分析、图解/flash演示/视频演示、算法代码、笔试面试重点分析、笔试面试题等板块，希望能帮助大家</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bfa5f51a20a848d6b2feb2948c9a2549/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">从输入URL到显示页面的过程中发生了什么？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c755e08c2392456f370149516477578/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jmx基本知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>