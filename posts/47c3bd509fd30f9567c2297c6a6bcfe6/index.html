<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>队列的基本操作（全） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="队列的基本操作（全）" />
<meta property="og:description" content="目录
1.实现功能
2.建队列
3.进队列
4.打印队列信息
5.队列的判空
6.求队列的长度
7.求队尾元素
8.删除队列元素同时返回队尾元素的值
9.求队头元素
10.输入队列元素
11.摧毁一个队列
12.请空队列
13.switch case选择
14.全部代码内容
15.运行图片
本帖可以实现的功能
1.实现功能 void pro() { printf(&#34;0.退出\n&#34;); printf(&#34;1.建立一个新队列\n&#34;); printf(&#34;2.按照输出方式打印队列信息\n&#34;); printf(&#34;3.求队列长度\n&#34;); printf(&#34;4.获取对头元素\n&#34;); printf(&#34;5.获取队尾元素\n&#34;); printf(&#34;6.删除对头元素\n&#34;); printf(&#34;7.判断队列是否为空\n&#34;); printf(&#34;8.在队尾插入一个数\n&#34;); printf(&#34;9.清空一个队列\n&#34;); printf(&#34;10.摧毁一个队列\n&#34;); } 2.建队列 void InitQueue(LinkQueue &amp;Q) { //建立链队列 Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); Q.front = Q.rear; if (!Q.front) printf(&#34;开辟空间失败\n&#34;); Q.front-&gt;next = NULL; printf(&#34;链式队列存储空间开辟完成\n&#34;); // Q.front-&gt;next=Q.rear-&gt;next; } 3.进队列 Status EnQueue(LinkQueue &amp;Q, int e) { //在队列的尾部插入元素 QueuePtr p = (QueuePtr)malloc(sizeof(QNode)); p-&gt;data = e; p-&gt;next = NULL; Q." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/47c3bd509fd30f9567c2297c6a6bcfe6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-23T12:37:42+08:00" />
<meta property="article:modified_time" content="2022-10-23T12:37:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">队列的基本操作（全）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#1.%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD" rel="nofollow">1.实现功能</a></p> 
<p id="2.%E5%BB%BA%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#2.%E5%BB%BA%E9%98%9F%E5%88%97" rel="nofollow">2.建队列</a></p> 
<p id="3.%E8%BF%9B%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#3.%E8%BF%9B%E9%98%9F%E5%88%97" rel="nofollow">3.进队列</a></p> 
<p id="4.%E6%89%93%E5%8D%B0%E9%98%9F%E5%88%97%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#4.%E6%89%93%E5%8D%B0%E9%98%9F%E5%88%97%E4%BF%A1%E6%81%AF" rel="nofollow">4.打印队列信息</a></p> 
<p id="5.%E9%98%9F%E5%88%97%E7%9A%84%E5%88%A4%E7%A9%BA-toc" style="margin-left:40px;"><a href="#5.%E9%98%9F%E5%88%97%E7%9A%84%E5%88%A4%E7%A9%BA" rel="nofollow">5.队列的判空</a></p> 
<p id="6.%E6%B1%82%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6-toc" style="margin-left:40px;"><a href="#6.%E6%B1%82%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6" rel="nofollow">6.求队列的长度</a></p> 
<p id="7.%E6%B1%82%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#7.%E6%B1%82%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0" rel="nofollow">7.求队尾元素</a></p> 
<p id="8.%E5%88%A0%E9%99%A4%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0%E5%90%8C%E6%97%B6%E8%BF%94%E5%9B%9E%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC-toc" style="margin-left:40px;"><a href="#8.%E5%88%A0%E9%99%A4%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0%E5%90%8C%E6%97%B6%E8%BF%94%E5%9B%9E%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC" rel="nofollow">8.删除队列元素同时返回队尾元素的值</a></p> 
<p id="9.%E6%B1%82%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#9.%E6%B1%82%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0" rel="nofollow">9.求队头元素</a></p> 
<p id="10.%E8%BE%93%E5%85%A5%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#10.%E8%BE%93%E5%85%A5%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0" rel="nofollow">10.输入队列元素</a></p> 
<p id="11.%E6%91%A7%E6%AF%81%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#11.%E6%91%A7%E6%AF%81%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97" rel="nofollow">11.摧毁一个队列</a></p> 
<p id="12.%E8%AF%B7%E7%A9%BA%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#12.%E8%AF%B7%E7%A9%BA%E9%98%9F%E5%88%97" rel="nofollow">12.请空队列</a></p> 
<p id="13.switch%20case%E9%80%89%E6%8B%A9-toc" style="margin-left:40px;"><a href="#13.switch%20case%E9%80%89%E6%8B%A9" rel="nofollow">13.switch case选择</a></p> 
<p id="14.%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81%E5%86%85%E5%AE%B9-toc" style="margin-left:40px;"><a href="#14.%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81%E5%86%85%E5%AE%B9" rel="nofollow">14.全部代码内容</a></p> 
<p id="15.%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%89%87-toc" style="margin-left:40px;"><a href="#15.%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%89%87" rel="nofollow">15.运行图片</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>本帖可以实现的功能</p> 
<h3 id="1.%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD">1.实现功能</h3> 
<pre><code class="language-cpp">void pro()
{
    printf("0.退出\n");
    printf("1.建立一个新队列\n");
    printf("2.按照输出方式打印队列信息\n");
    printf("3.求队列长度\n");
    printf("4.获取对头元素\n");
    printf("5.获取队尾元素\n");
    printf("6.删除对头元素\n");
    printf("7.判断队列是否为空\n");
    printf("8.在队尾插入一个数\n");
    printf("9.清空一个队列\n");
    printf("10.摧毁一个队列\n");
}</code></pre> 
<h3 id="2.%E5%BB%BA%E9%98%9F%E5%88%97">2.建队列</h3> 
<pre><code class="language-cpp">void InitQueue(LinkQueue &amp;Q)
{
    //建立链队列
    Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode));
    Q.front = Q.rear;
    if (!Q.front)
        printf("开辟空间失败\n");
    Q.front-&gt;next = NULL;
    printf("链式队列存储空间开辟完成\n");
    // Q.front-&gt;next=Q.rear-&gt;next;
}</code></pre> 
<h3 id="3.%E8%BF%9B%E9%98%9F%E5%88%97">3.进队列</h3> 
<pre><code class="language-cpp">Status EnQueue(LinkQueue &amp;Q, int e)
{
    //在队列的尾部插入元素
    QueuePtr p = (QueuePtr)malloc(sizeof(QNode));
    p-&gt;data = e;
    p-&gt;next = NULL;
    Q.rear-&gt;next = p;
    Q.rear = p;
}</code></pre> 
<h3 id="4.%E6%89%93%E5%8D%B0%E9%98%9F%E5%88%97%E4%BF%A1%E6%81%AF">4.打印队列信息</h3> 
<pre><code>void print(LinkQueue Q)
{
    //打印对列信息，按照输出方向
    QueuePtr p;
    p = Q.front-&gt;next;
    while (p != NULL)
    {
        printf("%d ", p-&gt;data);
        p = p-&gt;next;
    }
    printf("\n");
}</code></pre> 
<h3 id="5.%E9%98%9F%E5%88%97%E7%9A%84%E5%88%A4%E7%A9%BA">5.队列的判空</h3> 
<pre><code class="language-cpp">void QueueEmpty(LinkQueue Q)
{
    //判断是否为空队列
    if (Q.front == Q.rear)
    {
        printf("空\n");
    }
    else
    {
        printf("不空\n");
    }
}</code></pre> 
<h3 id="6.%E6%B1%82%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6">6.求队列的长度</h3> 
<pre><code class="language-cpp">void QueueLength(LinkQueue Q)
{
    //求队列的长度
    int length = 0;
    QueuePtr p, q;
    p = Q.front-&gt;next;
    while (p != NULL)
    {
        p = p-&gt;next;
        length++;
    }
    printf("长度为%d\n", length);
}
</code></pre> 
<h3 id="7.%E6%B1%82%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0">7.求队尾元素</h3> 
<pre><code class="language-cpp">void QueueRear(LinkQueue Q)
{
    //求队尾
    printf("队尾元素是：%d\n", Q.rear-&gt;data);
}</code></pre> 
<h3 id="8.%E5%88%A0%E9%99%A4%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0%E5%90%8C%E6%97%B6%E8%BF%94%E5%9B%9E%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC">8.删除队列元素同时返回队尾元素的值</h3> 
<pre><code class="language-cpp">Status DeQueue(LinkQueue &amp;Q)
{
    int e;
    if (Q.front == Q.rear)
    {
        printf("这个队列为空\n");
    }
    QueuePtr p = Q.front-&gt;next;
    e = p-&gt;data;
    Q.front-&gt;next = p-&gt;next;
    if (Q.rear == p)
    {
        Q.rear = Q.front;
    }
    free(p);
    return e;
}</code></pre> 
<h3 id="9.%E6%B1%82%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0">9.求队头元素</h3> 
<pre><code class="language-cpp">void QueueFront(LinkQueue Q)
{
    //求对头
    printf("对头元素为:%d\n", Q.front-&gt;next-&gt;data);
}</code></pre> 
<h3 id="10.%E8%BE%93%E5%85%A5%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0">10.输入队列元素</h3> 
<pre><code class="language-cpp">Status CreatQueue(LinkQueue &amp;Q)
{
    //输入队列元素
    printf("请输入队列里面的元素\n");
    int e;
    scanf("%d", &amp;e);
    while (e != -1)
    {
        EnQueue(Q, e);
        scanf("%d", &amp;e);
    }
}</code></pre> 
<h3 id="11.%E6%91%A7%E6%AF%81%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97">11.摧毁一个队列</h3> 
<pre><code class="language-cpp">Status DestoryQueue(LinkQueue &amp;Q)
{
    QueuePtr p;
    while(!p)
    {
        p=Q.front;
        Q.front=Q.front-&gt;next;
        free(p);
    }
    printf("摧毁队列完成\n");
}</code></pre> 
<h3 id="12.%E8%AF%B7%E7%A9%BA%E9%98%9F%E5%88%97">12.请空队列</h3> 
<pre><code class="language-cpp">Status ClearQueue(LinkQueue &amp;Q)
{
    Q.rear=Q.front-&gt;next=NULL;
    printf("清空操作已经完成\n");
}</code></pre> 
<h3 id="13.switch%20case%E9%80%89%E6%8B%A9">13.switch case选择</h3> 
<pre><code class="language-cpp">void swi(LinkQueue Q)
{
    int num;
    pro();
    printf("请输入功能数字:");
    scanf("%d", &amp;num);
    while (num)
    {
        switch (num)
        {
        case 0:
            num = 0;
            break;
        case 1:
            printf("建立一个新队列\n");
            InitQueue(Q);
            printf("\n\n");
            CreatQueue(Q);
            printf("建立成功\n");
            break;
        case 2:
            if (Q.rear == NULL)
            {
                printf("在进行操作二时，需要进行操作一\n");
            }
            else
            {
                printf("队列信息如下：\n");
                print(Q);
            }
            break;
        case 3:
            if (Q.rear == NULL)
            {
                printf("在进行操作三时，需要进行操作一\n");
            }
            else
            {
                printf("队列");
                QueueLength(Q);
            }
            break;
        case 4:
            if (Q.rear == NULL)
            {
                printf("在进行操作四时，需要进行操作一\n");
            }
            else
            {
                printf("获取对头元素\n");
                QueueFront(Q);
            }
            break;
        case 5:
            if (Q.rear == NULL)
            {
                printf("在进行操作五时，需要进行操作一\n");
            }
            else
            {
                printf("获取队尾元素\n");
                QueueRear(Q);
            }
            break;
        case 6:
            if (Q.rear == NULL)
            {
                printf("在进行操作六时，需要进行操作一\n");
            }
            else
            {
                printf("删除对头元素，");
                int e;
                e = DeQueue(Q);
                printf("删除的对头元素是：%d\n", e);
            }
            break;
        case 7:
            if (Q.rear == NULL)
            {
                printf("在进行操作七时，需要进行操作一\n");
            }
            else
            {
                printf("判断队列是否为空\n");
                QueueEmpty(Q);
            }
            break;
        case 8:
            if (Q.rear == NULL)
            {
                printf("在进行操作八时，需要进行操作一\n");
            }
            else
            {
                printf("在队尾插入一个数\n");
                int n;
                printf("请输入一个数字:");
                scanf("%d", &amp;n);
                printf("\n");
                EnQueue(Q, n);
                printf("插入成功\n");
            }
            break;
        case 9:
            if (Q.rear == NULL)
            {
                printf("在进行操作九时，需要进行操作一\n");
            }
            else
            {
                ClearQueue(Q);
            }
        break;
        case 10:
            if (Q.rear == NULL)
            {
                printf("在进行操作十时，需要进行操作一\n");
            }
            else
            {
                DestoryQueue(Q);
                Q.rear=NULL;
            }
            break;
        default:
            printf("输入错误，请重新输入\n");
        }
        printf("\n\n");
        pro();
        printf("请输入功能数字:");
        scanf("%d", &amp;num);
    }
}
</code></pre> 
<h3 id="14.%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81%E5%86%85%E5%AE%B9">14.全部代码内容</h3> 
<pre><code class="language-cpp">// define区
#define Stack_Init_Size 100
#define Stack_Increment 10
#define OK 1
#define OVERFLOW -2
#define ERROR 0

//预处理
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//typedef
typedef int Status;
typedef struct QNode
{
    int data;
    struct QNode *next;
} QNode, *QueuePtr;
typedef struct
{
    QueuePtr front;
    QueuePtr rear;
} LinkQueue;

//函数区声明
void InitQueue(LinkQueue &amp;Q);               //建立链队列
Status EnQueue(LinkQueue &amp;Q, int e);        //在队列的尾部插入元素
void print(LinkQueue Q);                    //打印对列信息，按照输出方向
void QueueEmpty(LinkQueue Q);                //判断是否为空队列
void QueueLength(LinkQueue Q);              //求队列的长度
void QueueRear(LinkQueue Q);                //求队尾
Status DeQueue(LinkQueue &amp;Q);               //求对头
void QueueFront(LinkQueue Q);               //输入队列元素
Status CreatQueue(LinkQueue &amp;Q);            //创建队列
Status DestoryQueue(LinkQueue &amp;Q);          //摧毁队列
Status ClearQueue(LinkQueue &amp;Q);            //请空队列
void pro();                                 //功能  
void swi(LinkQueue Q);                      //switch

//主函数
int main()
{
    LinkQueue Q;
    Q.rear = NULL;
    swi(Q);
}


void InitQueue(LinkQueue &amp;Q)
{
    //建立链队列
    Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode));
    Q.front = Q.rear;
    if (!Q.front)
        printf("开辟空间失败\n");
    Q.front-&gt;next = NULL;
    printf("链式队列存储空间开辟完成\n");
    // Q.front-&gt;next=Q.rear-&gt;next;
}

Status EnQueue(LinkQueue &amp;Q, int e)
{
    //在队列的尾部插入元素
    QueuePtr p = (QueuePtr)malloc(sizeof(QNode));
    p-&gt;data = e;
    p-&gt;next = NULL;
    Q.rear-&gt;next = p;
    Q.rear = p;
}

void print(LinkQueue Q)
{
    //打印对列信息，按照输出方向
    QueuePtr p;
    p = Q.front-&gt;next;
    while (p != NULL)
    {
        printf("%d ", p-&gt;data);
        p = p-&gt;next;
    }
    printf("\n");
}

void QueueEmpty(LinkQueue Q)
{
    //判断是否为空队列
    if (Q.front == Q.rear)
    {
        printf("空\n");
    }
    else
    {
        printf("不空\n");
    }
}

void QueueLength(LinkQueue Q)
{
    //求队列的长度
    int length = 0;
    QueuePtr p, q;
    p = Q.front-&gt;next;
    while (p != NULL)
    {
        p = p-&gt;next;
        length++;
    }
    printf("长度为%d\n", length);
}

void QueueRear(LinkQueue Q)
{
    //求队尾
    printf("队尾元素是：%d\n", Q.rear-&gt;data);
}

Status DeQueue(LinkQueue &amp;Q)
{
    int e;
    if (Q.front == Q.rear)
    {
        printf("这个队列为空\n");
    }
    QueuePtr p = Q.front-&gt;next;
    e = p-&gt;data;
    Q.front-&gt;next = p-&gt;next;
    if (Q.rear == p)
    {
        Q.rear = Q.front;
    }
    free(p);
    return e;
}

void QueueFront(LinkQueue Q)
{
    //求对头
    printf("对头元素为:%d\n", Q.front-&gt;next-&gt;data);
}
/*
int DeQueue(LinkQueue &amp;Q)

{
    //删除对列的对头元素
    QNode *p;
    p = Q.front-&gt;next;
    int e = p-&gt;data;
    Q.front-&gt;next = p-&gt;next;
    free(p);
    return e;
}*/

Status CreatQueue(LinkQueue &amp;Q)
{
    //输入队列元素
    printf("请输入队列里面的元素\n");
    int e;
    scanf("%d", &amp;e);
    while (e != -1)
    {
        EnQueue(Q, e);
        scanf("%d", &amp;e);
    }
}

Status DestoryQueue(LinkQueue &amp;Q)
{
    QueuePtr p;
    while(!p)
    {
        p=Q.front;
        Q.front=Q.front-&gt;next;
        free(p);
    }
    printf("摧毁队列完成\n");
}

Status ClearQueue(LinkQueue &amp;Q)
{
    Q.rear=Q.front-&gt;next=NULL;
    printf("清空操作已经完成\n");
}

void pro()
{
    printf("0.退出\n");
    printf("1.建立一个新队列\n");
    printf("2.按照输出方式打印队列信息\n");
    printf("3.求队列长度\n");
    printf("4.获取对头元素\n");
    printf("5.获取队尾元素\n");
    printf("6.删除对头元素\n");
    printf("7.判断队列是否为空\n");
    printf("8.在队尾插入一个数\n");
    printf("9.清空一个队列\n");
    printf("10.摧毁一个队列\n");
}

void swi(LinkQueue Q)
{
    int num;
    pro();
    printf("请输入功能数字:");
    scanf("%d", &amp;num);
    while (num)
    {
        switch (num)
        {
        case 0:
            num = 0;
            break;
        case 1:
            printf("建立一个新队列\n");
            InitQueue(Q);
            printf("\n\n");
            CreatQueue(Q);
            printf("建立成功\n");
            break;
        case 2:
            if (Q.rear == NULL)
            {
                printf("在进行操作二时，需要进行操作一\n");
            }
            else
            {
                printf("队列信息如下：\n");
                print(Q);
            }
            break;
        case 3:
            if (Q.rear == NULL)
            {
                printf("在进行操作三时，需要进行操作一\n");
            }
            else
            {
                printf("队列");
                QueueLength(Q);
            }
            break;
        case 4:
            if (Q.rear == NULL)
            {
                printf("在进行操作四时，需要进行操作一\n");
            }
            else
            {
                printf("获取对头元素\n");
                QueueFront(Q);
            }
            break;
        case 5:
            if (Q.rear == NULL)
            {
                printf("在进行操作五时，需要进行操作一\n");
            }
            else
            {
                printf("获取队尾元素\n");
                QueueRear(Q);
            }
            break;
        case 6:
            if (Q.rear == NULL)
            {
                printf("在进行操作六时，需要进行操作一\n");
            }
            else
            {
                printf("删除对头元素，");
                int e;
                e = DeQueue(Q);
                printf("删除的对头元素是：%d\n", e);
            }
            break;
        case 7:
            if (Q.rear == NULL)
            {
                printf("在进行操作七时，需要进行操作一\n");
            }
            else
            {
                printf("判断队列是否为空\n");
                QueueEmpty(Q);
            }
            break;
        case 8:
            if (Q.rear == NULL)
            {
                printf("在进行操作八时，需要进行操作一\n");
            }
            else
            {
                printf("在队尾插入一个数\n");
                int n;
                printf("请输入一个数字:");
                scanf("%d", &amp;n);
                printf("\n");
                EnQueue(Q, n);
                printf("插入成功\n");
            }
            break;
        case 9:
            if (Q.rear == NULL)
            {
                printf("在进行操作九时，需要进行操作一\n");
            }
            else
            {
                ClearQueue(Q);
            }
        break;
        case 10:
            if (Q.rear == NULL)
            {
                printf("在进行操作十时，需要进行操作一\n");
            }
            else
            {
                DestoryQueue(Q);
                Q.rear=NULL;
            }
            break;
        default:
            printf("输入错误，请重新输入\n");
        }
        printf("\n\n");
        pro();
        printf("请输入功能数字:");
        scanf("%d", &amp;num);
    }
}
</code></pre> 
<h3 id="15.%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%89%87">15.运行图片</h3> 
<p>在没有建立队列时：</p> 
<p><img alt="" height="86" src="https://images2.imgbox.com/2a/a5/QorhD0iS_o.png" width="353"></p> 
<p>建立队列</p> 
<p><img alt="" height="393" src="https://images2.imgbox.com/b9/c5/668urBro_o.png" width="253"></p> 
<p>打印队列</p> 
<p><img alt="" height="71" src="https://images2.imgbox.com/ac/98/jNErz32C_o.png" width="214"></p> 
<p>求长度</p> 
<p><img alt="" height="95" src="https://images2.imgbox.com/53/c9/nkw5ZUib_o.png" width="247"></p> 
<p></p> 
<p>获取对头元素</p> 
<p><img alt="" height="101" src="https://images2.imgbox.com/b7/02/0URkXZ6V_o.png" width="258"></p> 
<p></p> 
<p>获取队尾元素</p> 
<p><img alt="" height="85" src="https://images2.imgbox.com/51/ca/OMyOIhnY_o.png" width="278"></p> 
<p>删除对头元素</p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/89/af/kl6CdMsv_o.png" width="453"></p> 
<p>队尾插入一个数字</p> 
<p><img alt="" height="115" src="https://images2.imgbox.com/65/53/A1HsxmhE_o.png" width="267"></p> 
<p> 验证</p> 
<p><img alt="" height="117" src="https://images2.imgbox.com/1a/e7/r1fY31dH_o.png" width="297"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c206265125f5ea37b4ed9b0812e3608/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">读写分离中间件案例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f9e627ce5131c28d3cccf74e57f83648/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Sql中多表连接查询详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>