<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IO进程基本操作 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="IO进程基本操作" />
<meta property="og:description" content="IO进程学习概述 概述缓存机制标准IO打开文件读写文件cat 每次一行地读写文件wc -l 文件定位操作 文件IO打开文件读写文件cp命令的实现 文件定位操作 文件属性的获取目录操作库分类 进程进程状态切换图创建进程获取进程号结束进程回收进程资源创建守护进程 线程创建线程线程退出线程回收&amp;线程取消获取线程tid号 线程同步信号量初始化&amp;pv操作 线程互斥死锁线程条件变量的控制 进程间通信无名管道创建无名管道 有名管道创建有名管道 信号信号的响应方式信号处理接口司机与售票员信号处理 共享内存 概述 IO进程主打的就是文件之间的通信，希望本文有你需要的内容。
缓存机制 全缓存：与文件相关
刷新缓存的条件:程序正常退出时刷新,缓存区满刷新,强制刷新行缓存：与终端相关
刷新缓存的条件：\n刷新,程序正常退出时刷新,缓存区满刷新,强制刷新:fflush()不缓存：没有缓存区（stderr） 标准IO IO：input/output,针对于文件输入输出。
linux下文件类型：
b(块设备) c(字符设备) d(目录) -(普通文件) l(链接文件) s(套接字) p(管道)
概念：在C库中定义的一组专门用于输入输出的函数特点：
a. 标准IO通过缓冲机制减少系统调用的次数，提高效率
b. 标准IO围绕流进行操作，流用FILE *描述；（FILE 就是一个结构体，用于存放操作文件的相关信息，它在stdio.h文件中定义；vi -t FILE，ctags，ctrl&#43;]:代码追踪，ctrl&#43;t：回退）
c. 标准IO默认打开了三个流，stdin(标准输入)、stdout(标准输出)、stderr(标准出错)(FILE *stdin) 打开文件 FILE *fopen(const char *path, const char *mode) 功能：打开文件 参数： path：打开的文件 mode：打开的方式 r：只读，当文件不存在时报错，文件流定位到文件开头 r&#43;：可读可写，当文件不存在时报错，文件流定位到文件开头 w：只写，文件不存在创建，存在清空 w&#43;：可读可写，文件不存在创建，存在清空 a：追加(在末尾写),文件不存在创建，存在追加，文件流定位到文件末尾 a&#43;：读和追加，文件不存在创建，存在追加，文件流定位到文件末尾 注：当a的方式打开文件时，写只能在末尾进行追加，定位操作 是无法改变写的位置，但是可以改变读的位置 返回值： 成功：文件流 失败：NULL，并且会设置错误码 FILE * freopen(const char *pathname, const char *mode, FILE* fp) 功能：将指定的文件流重定向到打开的文件中 参数：path：文件路径 mode：打开文件的方式（同fopen） fp：文件流指针 返回值：成功：返回文件流指针 失败：NULL	读写文件 int fgetc(FILE * stream) 功能：从文件中读取一个字符 参数：stream：文件流 返回值：成功：读到的字符 失败或读到文件末尾：EOF(-1) int fputc(int c, FILE * stream) 功能：向文件中写入一个字符 参数：c：要写的字符 stream：文件流 返回值：成功：写的字符的ASCII 失败：EOF size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：从文件流读取多个元素 参数：	ptr ：用来存放读取元素 size ：元素大小 sizeof(数据类型) nmemb ：读取元素的个数 stream ：要读取的文件 返回值：成功：读取的元素的个数； 读到文件尾： 0 失败： -1	size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：按对象写 参数：同上	返回值：成功：写的元素个数 失败 ：-1 由这两个函数，可以实现cat命令" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/04b9d73ee46a337ac19b0a0caef977d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-31T18:14:06+08:00" />
<meta property="article:modified_time" content="2022-07-31T18:14:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">IO进程基本操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>IO进程学习概述</h4> 
 <ul><li><a href="#_1" rel="nofollow">概述</a></li><li><a href="#_3" rel="nofollow">缓存机制</a></li><li><a href="#IO_9" rel="nofollow">标准IO</a></li><li><ul><li><a href="#_19" rel="nofollow">打开文件</a></li><li><a href="#_44" rel="nofollow">读写文件</a></li><li><ul><li><a href="#cat_76" rel="nofollow">cat</a></li></ul> 
   </li><li><a href="#_97" rel="nofollow">每次一行地读写文件</a></li><li><ul><li><a href="#wc_l_115" rel="nofollow">wc -l</a></li></ul> 
   </li><li><a href="#_142" rel="nofollow">文件定位操作</a></li></ul> 
  </li><li><a href="#IO_162" rel="nofollow">文件IO</a></li><li><ul><li><a href="#_169" rel="nofollow">打开文件</a></li><li><a href="#_189" rel="nofollow">读写文件</a></li><li><ul><li><a href="#cp_208" rel="nofollow">cp命令的实现</a></li></ul> 
   </li><li><a href="#_250" rel="nofollow">文件定位操作</a></li></ul> 
  </li><li><a href="#_265" rel="nofollow">文件属性的获取</a></li><li><a href="#_285" rel="nofollow">目录操作</a></li><li><a href="#_310" rel="nofollow">库</a></li><li><ul><li><a href="#_315" rel="nofollow">分类</a></li></ul> 
  </li><li><a href="#_357" rel="nofollow">进程</a></li><li><ul><li><a href="#_383" rel="nofollow">进程状态切换图</a></li><li><a href="#_385" rel="nofollow">创建进程</a></li><li><a href="#_408" rel="nofollow">获取进程号</a></li><li><a href="#_415" rel="nofollow">结束进程</a></li><li><a href="#_427" rel="nofollow">回收进程资源</a></li><li><a href="#_449" rel="nofollow">创建守护进程</a></li></ul> 
  </li><li><a href="#_467" rel="nofollow">线程</a></li><li><ul><li><a href="#_481" rel="nofollow">创建线程</a></li><li><a href="#_493" rel="nofollow">线程退出</a></li><li><a href="#_501" rel="nofollow">线程回收&amp;线程取消</a></li><li><a href="#tid_515" rel="nofollow">获取线程tid号</a></li></ul> 
  </li><li><a href="#_521" rel="nofollow">线程同步</a></li><li><ul><li><a href="#pv_525" rel="nofollow">信号量初始化&amp;pv操作</a></li></ul> 
  </li><li><a href="#_549" rel="nofollow">线程互斥</a></li><li><a href="#_579" rel="nofollow">死锁</a></li><li><ul><li><a href="#_587" rel="nofollow">线程条件变量的控制</a></li></ul> 
  </li><li><a href="#_615" rel="nofollow">进程间通信</a></li><li><ul><li><a href="#_623" rel="nofollow">无名管道</a></li><li><ul><li><a href="#_630" rel="nofollow">创建无名管道</a></li></ul> 
   </li><li><a href="#_643" rel="nofollow">有名管道</a></li><li><ul><li><a href="#_650" rel="nofollow">创建有名管道</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_666" rel="nofollow">信号</a></li><li><ul><li><a href="#_670" rel="nofollow">信号的响应方式</a></li><li><a href="#_687" rel="nofollow">信号处理接口</a></li><li><ul><li><a href="#_721" rel="nofollow">司机与售票员信号处理</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_809" rel="nofollow">共享内存</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>概述</h2> 
<p>IO进程主打的就是文件之间的通信，希望本文有你需要的内容。</p> 
<h2><a id="_3"></a>缓存机制</h2> 
<ol><li>全缓存：与文件相关<br> 刷新缓存的条件:程序正常退出时刷新,缓存区满刷新,强制刷新</li><li>行缓存：与终端相关<br> 刷新缓存的条件：\n刷新,程序正常退出时刷新,缓存区满刷新,强制刷新:fflush()</li><li>不缓存：没有缓存区（stderr）</li></ol> 
<h2><a id="IO_9"></a>标准IO</h2> 
<p>IO：input/output,针对于文件输入输出。<br> linux下文件类型：<br> b(块设备) c(字符设备) d(目录) -(普通文件) l(链接文件) s(套接字) p(管道)</p> 
<ol><li>概念：在C库中定义的一组专门用于输入输出的函数</li><li>特点：<br> a. 标准IO通过<strong>缓冲机制</strong>减少系统调用的次数，提高效率<br> b. 标准IO围绕流进行操作，流用FILE *描述；（FILE 就是一个结构体，用于存放操作文件的相关信息，它在stdio.h文件中定义；vi -t FILE，ctags，ctrl+]:代码追踪，ctrl+t：回退）<br> c. 标准IO默认打开了三个流，stdin(标准输入)、stdout(标准输出)、stderr(标准出错)(FILE *stdin)</li></ol> 
<h3><a id="_19"></a>打开文件</h3> 
<pre><code class="prism language-c">FILE <span class="token operator">*</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>mode<span class="token punctuation">)</span>
功能：打开文件
参数：
    path：打开的文件
    mode：打开的方式
        r：只读，当文件不存在时报错，文件流定位到文件开头
        r<span class="token operator">+</span>：可读可写，当文件不存在时报错，文件流定位到文件开头
        w：只写，文件不存在创建，存在清空
        w<span class="token operator">+</span>：可读可写，文件不存在创建，存在清空
        a：追加<span class="token punctuation">(</span>在末尾写<span class="token punctuation">)</span><span class="token punctuation">,</span>文件不存在创建，存在追加，文件流定位到文件末尾
        a<span class="token operator">+</span>：读和追加，文件不存在创建，存在追加，文件流定位到文件末尾
                注：当a的方式打开文件时，写只能在末尾进行追加，定位操作
                是无法改变写的位置，但是可以改变读的位置
返回值： 成功：文件流
        失败：<span class="token constant">NULL</span>，并且会设置错误码
FILE <span class="token operator">*</span> <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span>  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>mode<span class="token punctuation">,</span>  FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span>
功能：将指定的文件流重定向到打开的文件中
参数：path：文件路径
	  mode：打开文件的方式（同fopen）
	  fp：文件流指针
返回值：成功：返回文件流指针
	   失败：<span class="token constant">NULL</span>	
</code></pre> 
<h3><a id="_44"></a>读写文件</h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span>  <span class="token function">fgetc</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span>
功能：从文件中读取一个字符
参数：stream：文件流
返回值：成功：读到的字符
        失败或读到文件末尾：<span class="token constant">EOF</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span>
功能：向文件中写入一个字符
参数：c：要写的字符
        stream：文件流
返回值：成功：写的字符的ASCII
       失败：<span class="token constant">EOF</span>

<span class="token class-name">size_t</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：从文件流读取多个元素
参数：	  ptr ：用来存放读取元素
         size ：元素大小  <span class="token keyword">sizeof</span><span class="token punctuation">(</span>数据类型<span class="token punctuation">)</span>
     	 nmemb ：读取元素的个数
  	    stream ：要读取的文件
返回值：成功：读取的元素的个数；
            读到文件尾： <span class="token number">0</span>
              失败： <span class="token operator">-</span><span class="token number">1</span>	 
<span class="token class-name">size_t</span> <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：按对象写
参数：同上	
返回值：成功：写的元素个数
      	失败 ：<span class="token operator">-</span><span class="token number">1</span>
</code></pre> 
<p>由这两个函数，可以实现cat命令</p> 
<h4><a id="cat_76"></a>cat</h4> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span>
	<span class="token keyword">int</span> ch <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fopen err"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_97"></a>每次一行地读写文件</h3> 
<pre><code class="prism language-c"><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">fgets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span>  <span class="token keyword">int</span> size<span class="token punctuation">,</span>  FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：从文件中每次读取一行字符串
参数：s：存放字符串的地址
         size：一次读取的字符个数
         stream：文件流
 返回值：成功：s的地址
        失败或读到文件末尾：<span class="token constant">NULL</span>
特性：每次实际读取的字符个数为size<span class="token operator">-</span><span class="token number">1</span>个，会在末尾自动添加\<span class="token number">0</span>
<span class="token keyword">int</span>  <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span>  FILE <span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：向文件中写字符串
参数：s：要写的内容
        stream：文件流
返回值：成功：非负整数
       失败：<span class="token constant">EOF</span>
</code></pre> 
<h4><a id="wc_l_115"></a>wc -l</h4> 
<p>fgets每次读取的数据特点是，读完这一行所有的内容，在字符串末尾添加一个\0，再读下一行的内容。但有时文件一行的字符个数大于读取的size个数，fgets也会读取size-1个，然后在末尾添加\0，这一行剩下的内容交给下一次读。这就导致计算文件行数，不能简单地每执行一次fgets行数就加1，还需要确定读的这一行倒数第二个字符是不是\n。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> fp<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fopen err"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>
			n<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_142"></a>文件定位操作</h3> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">rewind</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：将文件位置指针定位到起始位置
<span class="token keyword">int</span> <span class="token function">fseek</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：文件的定位操作
参数：stream：文件流
           offset：偏移量：正数表示向后文件尾部偏移
           					负数表示向文件开头偏移
           whence：相对位置：
                   <span class="token constant">SEEK_SET</span><span class="token operator">:</span>相对于文件开头
                   <span class="token constant">SEEK_CUR</span><span class="token operator">:</span>相对于文件当前位置
                   <span class="token constant">SEEK_END</span><span class="token operator">:</span>相对于文件末尾
  返回值：成功：<span class="token number">0</span>
         失败：<span class="token operator">-</span><span class="token number">1</span>                 
<span class="token keyword">long</span> <span class="token function">ftell</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：获取当前的文件位置
参数：要检测的文件流
返回值：成功：当前的文件位置，出错：<span class="token operator">-</span><span class="token number">1</span>
</code></pre> 
<h2><a id="IO_162"></a>文件IO</h2> 
<ol><li>概念：由系统提供的一组用于输入输出的函数接口</li><li>特点：<br> a. 没有缓冲机制，每次访问都要经过系统调用(系统向上提供的一组接口)<br> b. 围绕文件描述符进行操作，文件描述符是非负整数(&gt;=0),依次加1进行分配<br> c. 文件IO默认打开三个描述符：0(标准输入)、1(标准输出)、2(标准出错)<br> d. 可以操作-、b、c、p、s、l类型的文件</li></ol> 
<h3><a id="_169"></a>打开文件</h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：打开文件
参数：pathname：文件路径名
		flags：打开文件的方式
						O_RDONLY：只读
                        O_WRONLY<span class="token operator">:</span>只写
                        O_RDWR：可读可写
                        O_CREAT<span class="token operator">:</span>创建
                        O_TRUNC：清空
                        O_APPEND：追加   
返回值：成功：文件描述符
	   失败：<span class="token operator">-</span><span class="token number">1</span>
当第二个参数中有O_CREAT选项时，需要给open函数传递第三个参数
指定创建文件的权限 
<span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
创建出来的文件权限为指定权限值<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span>umask<span class="token punctuation">)</span>默认为<span class="token number">0002</span>，可以用八进制的数修改
umask <span class="token number">0000</span>
</code></pre> 
<h3><a id="_189"></a>读写文件</h3> 
<pre><code class="prism language-c"><span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：从一个已打开的可读文件中读取数据
参数：fd  文件描述符
         buf  存放位置
         count  期望的个数
返回值：成功：实际读到的个数
       返回<span class="token operator">-</span><span class="token number">1</span>：表示出错<span class="token punctuation">,</span>并设置errno号
       返回<span class="token number">0</span>：表示读到文件结尾	
<span class="token class-name">ssize_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：向指定文件描述符中，写入 count个字节的数据。
参数：fd   文件描述符
          buf   要写的内容
          count  期望值
返回值：成功：实际写入数据的个数
        失败  ： <span class="token operator">-</span><span class="token number">1</span>
</code></pre> 
<h4><a id="cp_208"></a>cp命令的实现</h4> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> fd_src<span class="token punctuation">,</span> fd_dest<span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
	<span class="token class-name">ssize_t</span> s<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage:%s &lt;src file&gt; &lt;dest file&gt;\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//1.打开文件（源文件、目标文件）</span>
	fd_src <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd_src <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open src file err"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	fd_dest <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> O_WRONLY<span class="token operator">|</span>O_CREAT<span class="token operator">|</span>O_TRUNC<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>fd_dest <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open dest file err"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//2.循环读源文件，写目标文件</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd_src<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">write</span><span class="token punctuation">(</span>fd_dest<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//3.关闭文件</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd_src<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd_dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_250"></a>文件定位操作</h3> 
<pre><code class="prism language-c"><span class="token class-name">off_t</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：设定文件的偏移位置	
参数：fd：文件描述符
	offset偏移量  				
		正数：向文件结尾位置移动
		负数：向文件开始位置
	whence  相对位置
		<span class="token constant">SEEK_SET</span>   开始位置
		<span class="token constant">SEEK_CUR</span>   当前位置
		<span class="token constant">SEEK_END</span>   结尾位置
返回值：成功：文件的当前位置
	      失败：<span class="token operator">-</span><span class="token number">1</span>
</code></pre> 
<h2><a id="_265"></a>文件属性的获取</h2> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：获取文件属性
参数：path：文件路径名
	    buf：保存文件属性信息的结构体
返回值：成功：<span class="token number">0</span>
	      失败：<span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ino_t</span>     st_ino<span class="token punctuation">;</span>     <span class="token comment">/* inode号 */</span>
        <span class="token class-name">mode_t</span>    st_mode<span class="token punctuation">;</span>    <span class="token comment">/* 权限 */</span>
        <span class="token class-name">nlink_t</span>   st_nlink<span class="token punctuation">;</span>   <span class="token comment">/* 硬链接数 */</span>
        <span class="token class-name">uid_t</span>     st_uid<span class="token punctuation">;</span>     <span class="token comment">/* 用户ID */</span>
        <span class="token class-name">gid_t</span>     st_gid<span class="token punctuation">;</span>     <span class="token comment">/* 组ID */</span>
        <span class="token class-name">off_t</span>     st_size<span class="token punctuation">;</span>    <span class="token comment">/* 大小 */</span>
        <span class="token class-name">time_t</span>    st_atime<span class="token punctuation">;</span>   <span class="token comment">/* 最后访问时间 */</span>
        <span class="token class-name">time_t</span>    st_mtime<span class="token punctuation">;</span>   <span class="token comment">/* 最后修改时间 */</span>
        <span class="token class-name">time_t</span>    st_ctime<span class="token punctuation">;</span>  <span class="token comment">/* 最后状态改变时间 */</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_285"></a>目录操作</h2> 
<pre><code class="prism language-c">DIR <span class="token operator">*</span><span class="token function">opendir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：获得目录流
参数：要打开的目录
返回值：成功：目录流
	   失败：<span class="token constant">NULL</span>
<span class="token keyword">struct</span> <span class="token class-name">dirent</span> <span class="token operator">*</span><span class="token function">readdir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：读目录
参数：要读的目录流
返回值：成功：读到的信息    
        失败：<span class="token constant">NULL</span>
返回值为结构体，该结构体成员为描述该目录下的文件信息
<span class="token keyword">struct</span> <span class="token class-name">dirent</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ino_t</span>   d_ino<span class="token punctuation">;</span>                   <span class="token comment">/* 索引节点号*/</span>
        <span class="token class-name">off_t</span>   d_off<span class="token punctuation">;</span>               <span class="token comment">/*在目录文件中的偏移*/</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">short</span> d_reclen<span class="token punctuation">;</span>    <span class="token comment">/* 文件名长度*/</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">char</span>  d_type<span class="token punctuation">;</span>      <span class="token comment">/* 文件类型 */</span>
        <span class="token keyword">char</span>    d_name<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	      <span class="token comment">/* 文件名 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">closedir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：关闭目录
参数：dirp：目录流
</code></pre> 
<h2><a id="_310"></a>库</h2> 
<p>当使用别人的函数时除了包含头文件以外还要有库<br> 头文件：函数声明、结构体等类型定义、头文件、宏定义<br> 库：就是把一些常用函数的目标文件打包在一起，提供相应函数的接口，便于程序员使用；本质上来说库是一种可执行代码的二进制形式<br> 由于windows和linux的本质不同，因此二者库的二进制是不兼容的</p> 
<h3><a id="_315"></a>分类</h3> 
<p><strong>静态库和共享库（动态库）</strong><br> 区别<br> 1） 静态库在程序编译时会被连接到目标代码中。<br> 优点：程序运行时将不再需要该静态库；运行时无需加载库，运行速度更快<br> 缺点：静态库中的代码复制到了程序中，因此<strong>体积较大</strong>；<strong>静态库升级后，程序需要重新编译链接</strong><br> 2） 动态库是在程序运行时才被载入代码中。<br> 优点：程序在执行时加载动态库，代码体积小；将一些程序升级变得简单；不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。<br> 缺点：运行时还需要动态库的存在，<strong>移植性较差</strong></p> 
<pre><code class="prism language-c">静态库
<span class="token number">1</span><span class="token operator">-</span>将源文件编译生成目标文件
		gcc <span class="token operator">-</span>c  add<span class="token punctuation">.</span>c <span class="token operator">-</span>o add<span class="token punctuation">.</span>o
<span class="token number">2</span><span class="token operator">-</span>创建静态库用ar命令，它将很多<span class="token punctuation">.</span>o转换成<span class="token punctuation">.</span>a
		ar  crs  libmyadd<span class="token punctuation">.</span>a  add<span class="token punctuation">.</span>o 
		静态库文件名的命名规范是以lib为前缀，紧接着跟静态库名
		扩展名为<span class="token punctuation">.</span>a
<span class="token number">3</span><span class="token operator">-</span>测试使用静态库：
		gcc  main<span class="token punctuation">.</span>c  <span class="token operator">-</span>L<span class="token punctuation">.</span>  <span class="token operator">-</span>lmyadd    <span class="token comment">// -L指定库的路径</span>
		执行<span class="token punctuation">.</span><span class="token operator">/</span>a<span class="token punctuation">.</span>out
</code></pre> 
<pre><code class="prism language-c">动态库
<span class="token number">1</span><span class="token operator">-</span>我们用gcc来创建共享库
		gcc <span class="token operator">-</span>fPIC  <span class="token operator">-</span>c hello<span class="token punctuation">.</span>c  <span class="token operator">-</span>o hello<span class="token punctuation">.</span>o
			<span class="token operator">-</span>fPIC 创建与地址无关的编译程序
		gcc  <span class="token operator">-</span>shared  <span class="token operator">-</span>o  libmyhello<span class="token punctuation">.</span>so  hello<span class="token punctuation">.</span>o
<span class="token number">2</span><span class="token operator">-</span>测试动态库使用	
		gcc main<span class="token punctuation">.</span>c  <span class="token operator">-</span>L<span class="token punctuation">.</span> <span class="token operator">-</span>lmyhello
</code></pre> 
<p>可以正常编译通过，但是运行时报错./a.out: error while loading shared libraries: libmyadd.so: cannot open shared object file: No such file or directory<br> 原因：当加载动态库时，系统会默认从/lib或/usr/lib路径下查找<br> 解决方法（有三种）：<br> (1)把库拷贝到/usr/lib和/lib目录下。(此方法编译时不需要指定库的路径)<br> (2)在LD_LIBRARY_PATH环境变量中加上库所在路径。<br> export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:. 后跟动态库的路径<br> （终端关闭，环境变量就没在了）<br> (3) 添加/etc/ld.so.conf.d/*.conf文件。<br> 把库所在的路径加到文件末尾，并执行ldconfig刷新<br> sudo vi xx.conf<br> 添加动态库存在的路径,如：<br> /home/22061/day3/dynamiclib</p> 
<h2><a id="_357"></a>进程</h2> 
<p>进程是一个独立的可调度的任务<br> 进程是动态的，是程序的一次执行过程，包含创建、调度、执行、消亡<br> <strong>特点：</strong><br> 系统会为每一个进程分配0-4g的虚拟空间，0-3g(用户空间)是每个进程所独有的，3g-4g(内核空间)是所有进程共有的。<br> CPU调度进程时会给进程分配时间片(几毫秒~十几毫秒),当时间片用完后，cpu再进行其他进程的调度，实现进程的轮转，从而实现多任务的操作<br> <strong>进程段：</strong><br> Linux中的进程包含三个段：<br> “数据段”存放的是全局变量、常数以及动态数据分配的数据空间(如malloc函数取得的空间)等。<br> “正文段”存放的是程序中的代码<br> “堆栈段”存放的是函数的返回地址、函数的参数以及程序中的局部变量<br> <strong>进程分类：</strong><br> 交互进程：该类进程是由shell控制和运行的。交互进程既可以在前台运行，也可以在后台运行。该类进程经常与用户进行交互，需要等待用户的输入，当接收到用户的输入后，该类进程会立刻响应，典型的交互式进程有：shell命令进程、文本编辑器等<br> 批处理进程：该类进程不属于某个终端，它被提交到一个队列中以便顺序执行。<br> 守护进程：该类进程在后台运行。它一般在Linux启动时开始执行，系统关闭时才结束。<br> <strong>进程状态：</strong><br> 1）运行态（TASK_RUNNING）：<strong>R</strong><br> 指正在被CPU运行或者就绪的状态。这样的进程被成为runnning进程。<br> 2）睡眠态(等待态)：<br> 可中断睡眠态（TASK_INTERRUPTIBLE）<strong>S</strong>：处于等待状态中的进程，一旦被该进程等待的资源被释放，那么该进程就会进入运行状态。<br> 不可中断睡眠态（TASK_UNINTERRUPTIBLE）<strong>D</strong>：该状态的进程只能用wake_up()函数唤醒。<br> 3）暂停态（TASK_STOPPED）:<strong>T</strong><br> 当进程收到信号SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU时就会进入暂停状态。可向其发送SIGCONT信号让进程转换到可运行状态。<br> 4）死亡态：进程结束 <strong>X</strong><br> 5）僵尸态：<strong>Z</strong><br> 当进程已经终止运行，但还占用系统资源，要避免僵尸态的产生</p> 
<h3><a id="_383"></a>进程状态切换图</h3> 
<p>进程创建后，进程进入就绪态，当CPU调度到此进程时进入运行态，当时间片用完时，此进程会进入就绪态，如果此进程正在执行一些IO操作(阻塞操作)会进入阻塞态，完成IO操作后又可进入就绪态，当进程运行结束即进入结束态。<img src="https://images2.imgbox.com/e0/f7/AXx6q16W_o.png" alt="进程状态切换"></p> 
<h3><a id="_385"></a>创建进程</h3> 
<pre><code class="prism language-c"><span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：创建子进程
返回值：
    成功：在父进程中：返回子进程的进程号 <span class="token operator">&gt;</span><span class="token number">0</span>
                在子进程中：返回值为<span class="token number">0</span>
    失败：<span class="token operator">-</span><span class="token number">1</span>并设置errno
特性：
<span class="token number">1</span>）子进程几乎拷贝了父进程的全部内容。包括代码、数据
	系统数据段中的pc值、栈中的数据、父进程中打开的文件等；但它们的PID
	PPID是不同的。
<span class="token number">2</span>）父子进程有独立的地址空间，互不影响；当在相应的进程中改变全局变量
	静态变量，都互不影响。
<span class="token number">3</span>）若父进程先结束，子进程成为孤儿进程，被init进程收养 子进程变成后台进程
<span class="token number">4</span>）若子进程先结束，父进程如果没有及时回收，子进程变成僵尸进程
	要避免僵尸进程产生
<span class="token number">5</span>）fork函数的“写时拷贝”特性，当子进程要修改全局变量值时
	会复制父进程的地址空间，如果只是读取变量的值
	子进程和父进程访问的是同一个地址空间；
	vfork函数先执行子进行再执行父进程，父子进程共享数据段。
</code></pre> 
<h3><a id="_408"></a>获取进程号</h3> 
<pre><code class="prism language-c"><span class="token class-name">pid_t</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：获取当前进程的进程号
<span class="token class-name">pid_t</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：获取当前进程的父进程号
</code></pre> 
<h3><a id="_415"></a>结束进程</h3> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：结束进程，刷新缓存
<span class="token keyword">void</span> <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：结束进程，不刷新缓存
参数：status是一个整型的参数，可以利用这个参数传递进程结束时的状态。
	通常<span class="token number">0</span>表示正常结束；
	其他的数值表示出现了错误，进程非正常结束
	在实际编程时，子进程中调用exit函数，会将参数值<span class="token punctuation">(</span>状态<span class="token punctuation">)</span>传递给父进程
	父进程可以进行相应的处理。
</code></pre> 
<h3><a id="_427"></a>回收进程资源</h3> 
<pre><code class="prism language-c"><span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：回收子进程资源<span class="token punctuation">(</span>阻塞<span class="token punctuation">)</span>
参数：status：子进程退出状态
返回值：成功：回收的子进程的进程号
              失败：<span class="token operator">-</span><span class="token number">1</span>
<span class="token class-name">pid_t</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：回收子进程资源
参数：
        pid：<span class="token operator">&gt;</span><span class="token number">0</span>     指定子进程进程号
		 <span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>   任意子进程
		 <span class="token operator">=</span><span class="token number">0</span>    等待其组ID等于调用进程的组ID的任一子进程
		 <span class="token operator">&lt;</span><span class="token operator">-</span><span class="token number">1</span>   等待其组ID等于pid的绝对值的任一子进程
        status：子进程退出状态
        options：<span class="token number">0</span>：阻塞
                WNOHANG：非阻塞
返回值：正常：结束的子进程的进程号
	      当使用选项WNOHANG且没有子进程结束时：<span class="token number">0</span>
	   出错：<span class="token operator">-</span><span class="token number">1</span>
当子进程退出时会给父进程发送SIGCHLD信号。
</code></pre> 
<h3><a id="_449"></a>创建守护进程</h3> 
<pre><code class="prism language-c">【<span class="token number">2</span>】守护进程<span class="token operator">-</span>掌握
<span class="token number">1.</span> 特点：守护进程是后台进程；生命周期比较长，从系统启动时开启
 	系统关闭时结束；它是脱离控制终端且周期执行的进程。
<span class="token number">2.</span> 步骤：
	<span class="token number">1</span>） 创建子进程，父进程退出
		让子进程变成孤儿进程，成为后台进程；fork
	<span class="token number">2</span>） 在子进程中创建新回话
		让子进程成为会话组组长，为了让子进程完全脱离终端；<span class="token function">setsid</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token number">3</span>）改变进程运行路径为根目录
		原因进程运行的路径不能被删除或卸载；<span class="token function">chdir</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token number">4</span>）重设文件权限掩码
		目的：增大进程创建文件时权限，提高灵活性；<span class="token function">umask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token number">5</span>）关闭文件描述符
		将不需要的文件关闭；<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h2><a id="_467"></a>线程</h2> 
<p>是一个轻量级的进程，为了提高系统的性能引入线程，Linux里同样用task_struct来描述一个线程。<br> 线程和进程都参与统一的调度。<br> 在同一个进程中创建的线程共享该进程的地址空间。<br> <strong>进程和线程区别</strong>：<br> 共性：都为操作系统提供了<strong>并发执行能力</strong><br> 不同点：<br> 调度和资源：线程是系统调度的最小单位，进程是资源分配的最小单位<br> 地址空间方面：同一个进程创建的多个线程共享进程的资源；进程的地址空间相互独立<br> 通信方面：线程通信相对简单，只需要通过全局变量可以实现，但是需要考虑临界资源访问的问题；进程通信比较复杂，需要借助进程间的通信机制(借助3g-4g内核空间)<br> 安全性方面：线程安全性差一些，当进程结束时会导致所有线程退出；进程相对安全<br> <strong>线程资源：</strong><br> 共享的资源：可执行的指令、静态数据、进程中打开的文件描述符、信号处理函数、当前工作目录、用户ID、用户组ID<br> 私有的资源：线程ID (TID)、PC(程序计数器)和相关寄存器、堆栈、错误号 (errno)、信号掩码和优先级、执行状态和属性</p> 
<h3><a id="_481"></a>创建线程</h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> <span class="token operator">*</span>thread<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> 
                      <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：创建线程
参数：thread：线程标识
            attr：线程属性， <span class="token constant">NULL</span>：代表设置默认属性
            start_routine：函数名：代表线程函数
            arg：用来给前面函数传参
返回值：成功：<span class="token number">0</span>
       失败：错误码
</code></pre> 
<h3><a id="_493"></a>线程退出</h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span>  <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>value_ptr<span class="token punctuation">)</span> 
功能：用于退出线程的执行
参数：value_ptr：线程退出时返回的值
返回值：成功 ： <span class="token number">0</span>
	    失败：errno
</code></pre> 
<h3><a id="_501"></a>线程回收&amp;线程取消</h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span>  <span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">,</span>  <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>value_ptr<span class="token punctuation">)</span> 
功能：用于等待一个指定的线程结束
参数：thread：创建的线程对象
        value_ptr：指针<span class="token operator">*</span>value_ptr指向线程返回的参数
返回值：成功 ： <span class="token number">0</span>
	       失败：errno
<span class="token keyword">int</span> <span class="token function">pthread_detach</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：让线程分离，让线程结束时自动回收线程资源
参数：thread：线程ID
<span class="token keyword">int</span> <span class="token function">pthread_cancel</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：取消线程
</code></pre> 
<h3><a id="tid_515"></a>获取线程tid号</h3> 
<pre><code class="prism language-c"><span class="token class-name">pthread_t</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：获取当前线程的tid
返回值：tid值
</code></pre> 
<h2><a id="_521"></a>线程同步</h2> 
<p>同步指的是多个任务(线程)按照约定的顺序相互配合完成一件事情<br> <strong>信号量</strong>：通过信号量实现同步操作；由信号量来决定线程是继续运行还是阻塞等待<br> 信号量代表某一类资源，其值表示系统中该资源的数量，它是一个受保护的变量，只能通过三种操作来访问：初始化、Ｐ操作(申请资源)、Ｖ操作(释放资源)其值为非负整数。</p> 
<h3><a id="pv_525"></a>信号量初始化&amp;pv操作</h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span>  <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span>  <span class="token keyword">int</span> pshared<span class="token punctuation">,</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span>  
功能：初始化信号量   
参数：sem：初始化的信号量对象
	pshared：信号量共享的范围<span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span> 线程间使用   非<span class="token number">0</span><span class="token operator">:</span><span class="token number">1</span>进程间使用<span class="token punctuation">)</span>
	value：信号量初值
返回值：成功 <span class="token number">0</span>
	   失败 <span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">int</span>  <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>  
功能：申请资源  P操作 
参数：sem：信号量对象
返回值：成功 <span class="token number">0</span>
	    失败 <span class="token operator">-</span><span class="token number">1</span>
注：此函数执行过程，先对信号量进行减<span class="token number">1</span>，当信号量的值大于等于<span class="token number">0</span>时
	表示有资源可以用，则继续执行；当信号量的值小于<span class="token number">0</span>时
	表示没有资源可以使用，函数阻塞
<span class="token keyword">int</span>  <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>   
功能：释放资源  V操作      
参数：sem：信号量对象
返回值：成功 <span class="token number">0</span>
	    失败 <span class="token operator">-</span><span class="token number">1</span>	
注：释放一次信号量的值加<span class="token number">1</span>，函数不阻塞
</code></pre> 
<h2><a id="_549"></a>线程互斥</h2> 
<p><strong>临界资源</strong>：一次仅允许一个进程所使用的资源<br> <strong>临界区</strong>：指的是一个访问共享资源的程序片段<br> <strong>互斥</strong>：多个线程在访问临界资源时，同一时间只能一个线程访问<br> <strong>互斥锁</strong>：通过互斥锁可以实现互斥机制，主要用来保护临界资源，每个临界资源都由一个互斥锁来保护，线程必须先获得互斥锁才能访问临界资源，访问完资源后释放该锁。如果无法获得锁，线程会阻塞直到获得锁为止。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span>  <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span>  <span class="token operator">*</span>mutex<span class="token punctuation">,</span> <span class="token class-name">pthread_mutexattr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">)</span>  
功能：初始化互斥锁  
参数：mutex：互斥锁
	    attr<span class="token operator">:</span>  互斥锁属性  <span class="token comment">//  NULL表示缺省属性</span>
返回值：成功 <span class="token number">0</span>
	      失败 <span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">int</span>  <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span>   
功能：申请互斥锁     
参数：mutex：互斥锁
返回值：成功 <span class="token number">0</span>
	      失败 <span class="token operator">-</span><span class="token number">1</span>
注：和pthread_mutex_trylock区别：
	pthread_mutex_lock是阻塞的；
	pthread_mutex_trylock不阻塞，如果申请不到锁会立刻返回
<span class="token keyword">int</span>  <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span>   
功能：释放互斥锁     
参数：mutex：互斥锁
返回值：成功 <span class="token number">0</span>
	      失败 <span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">int</span>  <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span>  <span class="token operator">*</span>mutex<span class="token punctuation">)</span>  
功能：销毁互斥锁     
参数：mutex：互斥锁
</code></pre> 
<h2><a id="_579"></a>死锁</h2> 
<p>两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去<br> 死锁产生的四个必要条件：<br> 1、<strong>互斥使用</strong> 当资源被一个线程使用(占有)时，别的线程不能使用<br> 2、<strong>不可抢占</strong> 资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。<br> 3、<strong>请求和保持</strong> 当资源请求者在请求其他的资源的同时保持对原有资源的占有。<br> 4、<strong>循环等待</strong> 存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。<br> 注意：当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。</p> 
<h3><a id="_587"></a>线程条件变量的控制</h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span> <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token class-name">pthread_condattr_t</span> <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：初始化条件变量
参数：cond：是一个指向结构<span class="token class-name">pthread_cond_t</span>的指针
	restrict attr：是一个指向结构<span class="token class-name">pthread_condattr_t</span>的指针，
	一般设为<span class="token constant">NULL</span>
返回值：成功：<span class="token number">0</span> 失败：非<span class="token number">0</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span> <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>restrict mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：等待信号的产生
参数：restrict cond：要等待的条件
	restrict mutex：对应的锁
返回值：成功：<span class="token number">0</span>，失败：不为<span class="token number">0</span>
注：当没有条件产生时函数会阻塞，同时会将锁解开；如果等待到条件产生
	函数会结束阻塞同时进行上锁。
<span class="token keyword">int</span> <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span> <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：给条件变量发送信号
参数：cond：条件变量值
返回值：成功：<span class="token number">0</span>，失败：非<span class="token number">0</span>
注：必须等待pthread_cond_wait函数先执行，再产生条件才可以
	此函数和pthread_cond_broadcast区别是：
	pthread_cond_broadcast函数相当于是广播，会将所有等待此条件的线程唤醒
pthread_cond_signal只能唤醒单个等待此条件的线程
<span class="token keyword">int</span> <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span> <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：将条件变量销毁
参数：cond：条件变量值
返回值：成功：<span class="token number">0</span>， 失败：非<span class="token number">0</span>
</code></pre> 
<h2><a id="_615"></a>进程间通信</h2> 
<p>进程间通信方式<br> 1）早期的进程间通信：<br> 无名管道、有名管道、信号<br> 2）systerm V IPC：<br> 共享内存、消息队列、信号灯集<br> 3）BSD：<br> 套接字</p> 
<h3><a id="_623"></a>无名管道</h3> 
<p>特点<br> a. 只能用于具有亲缘关系的进程之间的通信<br> b. 半双工的通信模式，具有固定的读端和写端<br> c. 管道可以看成是一种特殊的文件，对于它的读写可以使用文件IO如read、write函数.<br> d. 管道是基于文件描述符的通信方式。当一个管道建立时，它会创建两个文件描述符<br> fd[0]和fd[1]。其中fd[0]固定用于读管道，而fd[1]固定用于写管道。</p> 
<h4><a id="_630"></a>创建无名管道</h4> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
功能：创建无名管道
参数：文件描述符 fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>：读端  fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span>写端
返回值：成功 <span class="token number">0</span>
	   失败 <span class="token operator">-</span><span class="token number">1</span>
</code></pre> 
<p><strong>注意事项</strong><br> a. 当管道中无数据时，读操作会阻塞<br> b. 管道中装满（管道大小64K）数据写阻塞，一旦有4k空间，写继续<br> c. 只有在管道的读端存在时，向管道中写入数据才有意义。否则，会导致管道破裂，向管道中写入数据的进程将收到内核传来的SIGPIPE信号 (通常Broken pipe错误)。</p> 
<h3><a id="_643"></a>有名管道</h3> 
<p>1） 特点<br> a. 有名管道可以使互不相关的两个进程互相通信。<br> b. 有名管道可以通过路径名来指出，并且在文件系统中可见，但内容存放在内存中。<br> c. 进程通过文件IO来操作有名管道<br> d. 有名管道遵循先进先出规则<br> e. 不支持如lseek() 操作</p> 
<h4><a id="_650"></a>创建有名管道</h4> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span><span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：创健有名管道
参数：filename：有名管道文件名
	  mode：权限
返回值：成功：<span class="token number">0</span>	
	    失败：<span class="token operator">-</span><span class="token number">1</span>，并设置errno号	
</code></pre> 
<p>注意对错误的处理方式：<br> 如果错误是file exist时，注意加判断，如：if(errno == EEXIST)。<br> 函数只是在路径下创建管道文件，往管道中写的数据依然写在内核空间。<br> <strong>注意事项</strong><br> a. 只写方式，写阻塞，一直到另一个进程把读打开<br> b. 只读方式，读阻塞，一直到另一个进程把写打开<br> c. 可读可写，如果管道中没有数据，读阻塞</p> 
<h2><a id="_666"></a>信号</h2> 
<p>1.信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式<br> 2.信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。<br> 3.如果该进程当前并未处于执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它；如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。</p> 
<h3><a id="_670"></a>信号的响应方式</h3> 
<pre><code>1）忽略信号：对信号不做任何处理，但是有两个信号不能忽略：
	即SIGKILL及SIGSTOP。
2）捕捉信号：定义信号处理函数，当信号发生时，执行相应的处理函数。
3）执行缺省操作：Linux对每种信号都规定了默认操作 
</code></pre> 
<p><strong>信号种类</strong></p> 
<pre><code class="prism language-c">SIGKILL：结束进程，不能被忽略不能被捕捉
SIGSTOP：结束进程，不能被忽略不能被捕捉
SIGCHLD：子进程退出时给父进程发的信号
SIGINT：结束进程，对应快捷方式ctrl<span class="token operator">+</span>c
SIGTSTP：暂停信号，对应快捷方式ctrl<span class="token operator">+</span>z
SIGQUIT：退出信号，对应快捷方式ctrl<span class="token operator">+</span>\
SIGALRM：闹钟信号，alarm函数设置定时，当到设定的时间时
内核会向进程发送此信号结束进程。
SIGTERM：结束终端进程，kill 使用时不加数字默认是此信号
</code></pre> 
<h3><a id="_687"></a>信号处理接口</h3> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">kill</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：信号发送
参数：pid：指定进程
	 sig：要发送的信号
返回值：成功 <span class="token number">0</span>     失败 <span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">int</span> <span class="token function">raise</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：进程向自己发送信号
参数：sig：信号
返回值：成功 <span class="token number">0</span>   失败 <span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seconds<span class="token punctuation">)</span>
功能：在进程中设置一个定时器
参数：seconds：定时时间，单位为秒
返回值：如果调用此<span class="token function">alarm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>前，进程中已经设置了闹钟时间，则
返回上一个闹钟时间的剩余时间，否则返回<span class="token number">0</span>。
注意：一个进程只能有一个闹钟时间。如果在调用alarm时
	已设置过闹钟时间，则之前的闹钟时间被新值所代替
<span class="token keyword">int</span> <span class="token function">pause</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：用于将调用进程挂起，直到收到信号为止。

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
 <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">sighandler_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">sighandler_t</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token class-name">sighandler_t</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：信号处理函数
参数：signum：要处理的信号
          handler：信号处理方式
                    SIG_IGN：忽略信号
                    SIG_DFL：执行默认操作
                    handler：捕捉信号  <span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token comment">//函数名可以自定义</span>
返回值：成功：设置之前的信号处理方式
              失败：<span class="token operator">-</span><span class="token number">1</span>
</code></pre> 
<p>附上一个挺有意思的练习</p> 
<h4><a id="_721"></a>司机与售票员信号处理</h4> 
<blockquote> 
 <p>用信号的知识实现司机和售票员问题。<br> 1）售票员捕捉SIGINT（代表开车）信号，向司机发送SIGUSR1信号，司机打印（let’s gogogo）<br> 2）售票员捕捉SIGQUIT（代表停车）信号，向司机发送SIGUSR2信号，司机打印（stop the bus）<br> 3）司机捕捉SIGTSTP（代表到达终点站）信号，向售票员发送SIGUSR1信号，售票员打印（please get off the bus）<br> 4）司机等待售票员下车，之后司机再下车。<br> 售票员：捕捉：SIGINT SIGQUIT SIGUSR1<br> 忽略：SIGTSTP<br> 司机：捕捉：SIGUSR1 SIGUSR2 SIGTSTP<br> 忽略：SIGINT SIGQUIT</p> 
</blockquote> 
<p>下面是我的实现过程，输出带点个人风格，不影响理解</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">handler_conductor</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>SIGINT <span class="token operator">==</span> sig<span class="token punctuation">)</span>
		<span class="token function">kill</span><span class="token punctuation">(</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>SIGUSR1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>SIGQUIT <span class="token operator">==</span> sig<span class="token punctuation">)</span>
		<span class="token function">kill</span><span class="token punctuation">(</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>SIGUSR2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>SIGUSR1 <span class="token operator">==</span> sig<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nConductor: Terminal is here,PLZ GET OFF ^.^\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Conductor: All passengers get off,now I'm gone"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">handler_busdriver</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>SIGUSR1 <span class="token operator">==</span> sig<span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nBusdriver: Hustle Hustle let's go!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>SIGUSR2 <span class="token operator">==</span> sig<span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nBusdriver: Bus Stopped,Get Off Quickly!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>SIGTSTP <span class="token operator">==</span> sig<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span>SIGUSR1<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Busdriver: Conductor already get off,I'm gone too\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork err: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>	
		<span class="token comment">//conductor ignore</span>
		<span class="token function">signal</span><span class="token punctuation">(</span>SIGTSTP<span class="token punctuation">,</span>SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//	while(1)</span>
	<span class="token comment">//	{	</span>
			<span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span>handler_conductor<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">signal</span><span class="token punctuation">(</span>SIGQUIT<span class="token punctuation">,</span>handler_conductor<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">signal</span><span class="token punctuation">(</span>SIGUSR1<span class="token punctuation">,</span>handler_conductor<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//	}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>		
		<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//busdriver ignore</span>
		<span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span>SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">signal</span><span class="token punctuation">(</span>SIGQUIT<span class="token punctuation">,</span>SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//	while(1)</span>
	<span class="token comment">//	{<!-- --></span>
			<span class="token function">signal</span><span class="token punctuation">(</span>SIGTSTP<span class="token punctuation">,</span>handler_busdriver<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">signal</span><span class="token punctuation">(</span>SIGUSR1<span class="token punctuation">,</span>handler_busdriver<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">signal</span><span class="token punctuation">(</span>SIGUSR2<span class="token punctuation">,</span>handler_busdriver<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//	}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token function">pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注释处换成pause后，功能一样，但是pause函数可以让程序对CPU的资源占用率极大的降低，这与pause的底层实现逻辑有关，哥们也不懂 qaq。</p> 
<h2><a id="_809"></a>共享内存</h2> 
<pre><code>1）共享内存是一种最为高效的进程间通信方式，进程可以直接读写内存，
	而不需要任何数据的拷贝
2）为了在多个进程间交换信息，内核专门留出了一块内存区，可以由
 	需要访问的进程将其映射到自己的私有地址空间
3）进程就可以直接读写这一内存区而不需要进行数据的拷贝，从而大大
	 提高的效率。
4）由于多个进程共享一段内存，因此也需要依靠某种同步机制
	如互斥锁和信号量等
</code></pre> 
<p>创建共享内存步骤<br> a. 创建key值 <br> b. 创建或打开共享内存<br> c. 映射共享内存到用户空间<br> d. 撤销映射<br> e. 删除共享内存</p> 
<pre><code class="prism language-c"><span class="token class-name">key_t</span> <span class="token function">ftok</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> proj_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：产生一个独一无二的key值
参数：
	Pathname：已经存在的可访问文件的名字
	Proj_id：一个字符（因为只用低<span class="token number">8</span>位）
返回值：成功：key值
	      失败：<span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：创建或打开共享内存
参数：
	key  键值
        size   共享内存的大小
        shmflg   IPC_CREAT<span class="token operator">|</span>IPC_EXCL<span class="token operator">|</span><span class="token number">0777</span>
返回值：成功   shmid
              出错    <span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">void</span>  <span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span>  shmid<span class="token punctuation">,</span><span class="token keyword">const</span>  <span class="token keyword">void</span>  <span class="token operator">*</span>shmaddr<span class="token punctuation">,</span><span class="token keyword">int</span>  shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：映射共享内存，即把指定的共享内存映射到进程的地址空间用于访问
参数：
	shmid   共享内存的id号
        shmaddr   一般为<span class="token constant">NULL</span>，表示由系统自动完成映射
                      如果不为<span class="token constant">NULL</span>，那么有用户指定
        shmflg：SHM_RDONLY就是对该共享内存只进行读操作
                            <span class="token number">0</span>     可读可写		
返回值：成功：完成映射后的地址，
	      出错：<span class="token operator">-</span><span class="token number">1</span>的地址
	用法：<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">shmat</span><span class="token punctuation">(</span>shmid，<span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>shmaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：取消映射
参数：要取消的地址
返回值：成功<span class="token number">0</span>  
	      失败的<span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">int</span>  <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span>  shmid<span class="token punctuation">,</span><span class="token keyword">int</span>  cmd<span class="token punctuation">,</span><span class="token keyword">struct</span>  <span class="token class-name">shmid_ds</span>   <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
功能：<span class="token punctuation">(</span>删除共享内存<span class="token punctuation">)</span>，对共享内存进行各种操作
参数：
	shmid   共享内存的id号
      	cmd     IPC_STAT 获得shmid属性信息，存放在第三参数
                IPC_SET 设置shmid属性信息，要设置的属性放在第三参数
                IPC_RMID<span class="token operator">:</span>删除共享内存，此时第三个参数为<span class="token constant">NULL</span>即可	
返回：  成功<span class="token number">0</span> 
	    失败<span class="token operator">-</span><span class="token number">1</span>
用法：<span class="token function">shmctl</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span>IPC_RMID<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>系统命令： <br> ipcs -m : 查看共享内存<br> ipcrm -m shmid: 删除共享内存</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fbe7f5fb6520a371c149f1bfff3d56dd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言数组存储学生信息，并通过姓名获得该学生其他信息</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f270555ca2e881500a56d44ec7d32b1d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Timer，时间堆</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>