<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>聚类--DBSCAN - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="聚类--DBSCAN" />
<meta property="og:description" content="1、什么是DBSCN DBSCAN也是一个非常有用的聚类算法。
它的主要优点:它不需要用户先验地设置簇的个数，可以划分具有复杂形状的簇，还可以找出不属于任何簇的点。DBSCAN比凝聚聚类和k均值稍慢，但仍可以扩展到相对较大的数据集。 1.1算法原理 DBSCAN的原理是识别特征空间的“拥挤”区域中的点，在这些区域中许多数据点靠近在一起。这些区域被称为特征空间中的密集区域。
DBSCAN背后的思想：簇形成数据的密集区域，并由相对较空的区域分隔开。 在密集区域内的点被称为核心样本（或核心点），它们的定义如下。
DBSCAN有两个参数：min_samples和eps。 如果在距一个给定数据点eps的距离内至少有min_samples个数据点，那么这个数据点就是核心样本。DBSCAN将彼此距离小于eps的核心样本放到同一个簇中。 一共有三种类型的点：核心点，与核心点的距离在eps之内的点（叫做边界点）和噪声。
如果DBSCAN算法在特定数据集上多次运行，那么核心点的聚类始终相同，同样的点也始终被标记为噪声。 但边界点可能与不止一个簇的核心样本相邻。因此，边界点所属的簇依赖于数据点的访问顺序。一般来说只有很少的边界点，这种对访问顺序的轻度依赖并不重要。 2、应用于模拟数据make_blobs X, y = make_blobs(random_state=0,n_samples=12) dbscan = DBSCAN() clusters = dbscan.fit_predict(X) print(&#34;Cluster memberships:\n{}&#34;.format(clusters)) 输出：
Cluster memberships: [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1] 📣
因为eps和min_samples设置不当，所有的数据都被标记为噪声
可视化
mglearn.plots.plot_dbscan() 📣
在这张图中，属于簇的点是实心的，噪声点为空心。核心样本显示为较大的标记，边界点则显示为较小的标记。 增大eps，扩大核心点的领域，会让一个簇变得更大增大min_samples会让一个簇中包含更多的点，同时核心点变小，噪声变多 👍
eps更重要 它决定了点与点之间“接近的含义”。 eps过小，没有点是核心样本eps过大，所有点成单个簇 min_samples是为了判断稀疏区域内的点被标记为异常值还是形成自己的簇 决定了簇的尺寸 3、应用于模拟数据make_moons 虽然DBSCAN不需要显式地设置簇的个数，但设置eps可以隐式地控制找到的簇的个数。使用StandardScaler或MinMaxScaler对数据进行缩放之后，有时会更容易找到eps的较好取值，因为使用这些缩放技术将确保所有特征具有相似的范围.
from sklearn.datasets import make_moons from sklearn.preprocessing import StandardScaler from matplotlib import pyplot as plt X, y = make_moons(n_samples=200,noise=0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dfcc9c94cc6fb3007fc6985b2e864bbf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-07T11:22:57+08:00" />
<meta property="article:modified_time" content="2022-05-07T11:22:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">聚类--DBSCAN</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1DBSCN_0"></a>1、什么是DBSCN</h3> 
<p>DBSCAN也是一个非常有用的聚类算法。</p> 
<ul><li>它的主要优点:它不需要用户先验地设置簇的个数，可以划分具有复杂形状的簇，还可以找出不属于任何簇的点。</li><li>DBSCAN比凝聚聚类和k均值稍慢，但仍可以扩展到相对较大的数据集。</li></ul> 
<h4><a id="11_6"></a>1.1算法原理</h4> 
<p>DBSCAN的原理是识别特征空间的“拥挤”区域中的点，在这些区域中许多数据点靠近在一起。这些区域被称为特征空间中的<strong>密集区域</strong>。</p> 
<ul><li>DBSCAN背后的思想：簇形成数据的密集区域，并由相对较空的区域分隔开。</li></ul> 
<p>在密集区域内的点被称为<strong>核心样本</strong>（或核心点），它们的定义如下。</p> 
<ul><li>DBSCAN有两个参数：min_samples和eps。 
  <ul><li>如果在距一个给定数据点eps的距离内至少有min_samples个数据点，那么这个数据点就是核心样本。</li><li>DBSCAN将彼此距离小于eps的核心样本放到同一个簇中。</li></ul> </li></ul> 
<p>一共有三种类型的点：<strong>核心点</strong>，与核心点的距离在eps之内的点（叫做<strong>边界点</strong>）和<strong>噪声</strong>。</p> 
<ul><li>如果DBSCAN算法在特定数据集上多次运行，那么核心点的聚类始终相同，同样的点也始终被标记为噪声。 
  <ul><li>但边界点可能与不止一个簇的核心样本相邻。因此，边界点所属的簇依赖于数据点的访问顺序。</li><li>一般来说只有很少的边界点，这种对访问顺序的轻度依赖并不重要。</li></ul> </li></ul> 
<h3><a id="2make_blobs_22"></a>2、应用于模拟数据make_blobs</h3> 
<pre><code>  X, y = make_blobs(random_state=0,n_samples=12)

  dbscan = DBSCAN()

  clusters = dbscan.fit_predict(X)

  print("Cluster memberships:\n{}".format(clusters))
</code></pre> 
<ul><li> <p>输出：</p> <pre><code>Cluster memberships:
[-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]
</code></pre> </li></ul> 
<p>📣</p> 
<p>因为eps和min_samples设置不当，所有的数据都被标记为噪声</p> 
<ul><li> <p>可视化</p> <pre><code>mglearn.plots.plot_dbscan()
</code></pre> </li></ul> 
<p><img src="https://images2.imgbox.com/f4/62/ICkQB4uf_o.png" alt=""></p> 
<p>📣</p> 
<ul><li>在这张图中，属于簇的点是实心的，噪声点为空心。核心样本显示为较大的标记，边界点则显示为较小的标记。 
  <ul><li>增大eps，扩大核心点的领域，会让一个簇变得更大</li><li>增大min_samples会让一个簇中包含更多的点，同时核心点变小，噪声变多</li></ul> </li></ul> 
<p>👍</p> 
<ul><li>eps更重要 
  <ul><li>它决定了点与点之间“接近的含义”。 
    <ul><li>eps过小，没有点是核心样本</li><li>eps过大，所有点成单个簇</li></ul> </li></ul> </li><li>min_samples是为了判断稀疏区域内的点被标记为异常值还是形成自己的簇 
  <ul><li>决定了簇的尺寸</li></ul> </li></ul> 
<h3><a id="3make_moons_65"></a>3、应用于模拟数据make_moons</h3> 
<p>虽然DBSCAN不需要显式地设置簇的个数，但设置eps可以隐式地控制找到的簇的个数。使用StandardScaler或MinMaxScaler对数据进行缩放之后，有时会更容易找到eps的较好取值，因为使用这些缩放技术将确保所有特征具有相似的范围.</p> 
<pre><code>  from sklearn.datasets import make_moons
  from sklearn.preprocessing import StandardScaler
  from matplotlib import pyplot as plt


  X, y = make_moons(n_samples=200,noise=0.05,random_state=0)

  #将数据缩放成平均值为0，方差为1
  scaler = StandardScaler().fit(X)
  X_scaled = scaler.transform(X)

  dbscan = DBSCAN()
  clusters = dbscan.fit_predict(X_scaled)

  #绘制簇分配

  plt.scatter(X_scaled[:,0],X_scaled[:,1],c=clusters,cmap=mglearn.cm2,s=60)
</code></pre> 
<p><img src="https://images2.imgbox.com/95/c9/m2ZNVeHb_o.png" alt=""></p> 
<p>📣</p> 
<p>可以看到，利用DBSCAN的默认设置，算法找到了两个半圆形并将其分开。<br> 由于算法找到了我们想要的簇的个数（2个），因此参数设置的效果很好。</p> 
<ul><li>如果将eps减小到0.2（默认值为0.5），我们将会得到8个簇，这显然太多了。</li><li>将eps增大到0.7则会导致只有一个簇。</li></ul> 
<h3><a id="4_97"></a>4、参考文献</h3> 
<p>《python机器学习基础教程》P143-P147</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ab1aee4a4be507ab7529a30f4cdeae1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu20.04安装NVIDIA驱动后docker中rviz，pcl_viewer等涉及到访问宿主机界面的程序不可用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf7b5bf53768f0abfcc199fb7624cc20/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">三大编程范式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>