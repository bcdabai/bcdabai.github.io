<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Lua错误处理之error、assert、pcall和xpcall - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Lua错误处理之error、assert、pcall和xpcall" />
<meta property="og:description" content="Lua错误处理 errorassertpcallxpcall error error (message [, level])
中止上一次保护函数调用，将错误对象 message 返回。 函数 error 永远不会返回。
当 message 是一个字符串时，通常 error 会把一些有关出错位置的信息附加在消息的前头。 level 参数指明了怎样获得出错位置。 对于 level 1 （默认值），出错位置指 error 函数调用的位置。 Level 2 将出错位置指向调用 error的函数的函数；以此类推。 传入 level 0 可以避免在消息前添加出错位置信息。
在Lua中使用error函数抛出错误信息，通常包含调用堆栈信息以及错误提示信息！
第一个参数message为自定义的错误提示信息。
第二个参数为可选的出错位置信息，默认为1，即为调用error函数的位置；2即为调用error函数的函数的位置；0则不打印出错位置信息！
function testError() error(&#34;error test1&#34;) -- error(&#34;error test2&#34;, 1) -- error(&#34;error test3&#34;, 0) -- error(&#34;error test4&#34;, 2) end testError() --[[ lua: C:\Users\user\Desktop\transition\csdn\test.lua:2: error test1 stack traceback: [C]: in function &#39;error&#39; C:\Users\user\Desktop\transition\csdn\test.lua:2: in function &#39;testError&#39; C:\Users\user\Desktop\transition\csdn\test." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a904eefdd6665ba1f5c92da656b4a0a9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-17T21:58:37+08:00" />
<meta property="article:modified_time" content="2019-05-17T21:58:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Lua错误处理之error、assert、pcall和xpcall</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Lua错误处理</h4> 
 <ul><li><a href="#error_2" rel="nofollow">error</a></li><li><a href="#assert_30" rel="nofollow">assert</a></li><li><a href="#pcall_56" rel="nofollow">pcall</a></li><li><a href="#xpcall_82" rel="nofollow">xpcall</a></li></ul> 
</div> 
<p></p> 
<h2><a id="error_2"></a>error</h2> 
<p><strong>error (message [, level])</strong></p> 
<blockquote> 
 <p>中止上一次保护函数调用，将错误对象 message 返回。 函数 error 永远不会返回。<br> 当 message 是一个字符串时，通常 error 会把一些有关出错位置的信息附加在消息的前头。 level 参数指明了怎样获得出错位置。 对于 level 1 （默认值），出错位置指 error 函数调用的位置。 Level 2 将出错位置指向调用 error的函数的函数；以此类推。 传入 level 0 可以避免在消息前添加出错位置信息。</p> 
</blockquote> 
<p>在Lua中使用error函数抛出错误信息，通常包含调用堆栈信息以及错误提示信息！<br> 第一个参数message为自定义的错误提示信息。<br> 第二个参数为可选的出错位置信息，默认为1，即为调用error函数的位置；2即为调用error函数的函数的位置；0则不打印出错位置信息！</p> 
<pre><code class="prism language-lua"><span class="token keyword">function</span> <span class="token function">testError</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"error test1"</span><span class="token punctuation">)</span>
    <span class="token comment">-- error("error test2", 1)</span>
    <span class="token comment">-- error("error test3", 0)</span>
    <span class="token comment">-- error("error test4", 2)</span>
<span class="token keyword">end</span>

<span class="token function">testError</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">--[[
lua: C:\Users\user\Desktop\transition\csdn\test.lua:2: error test1
stack traceback:
    [C]: in function 'error'
    C:\Users\user\Desktop\transition\csdn\test.lua:2: in function 'testError'
    C:\Users\user\Desktop\transition\csdn\test.lua:8: in main chunk
    [C]: ?
]]</span>
</code></pre> 
<h2><a id="assert_30"></a>assert</h2> 
<p><strong>assert (v [, message])</strong></p> 
<blockquote> 
 <p>如果其参数 v 的值为假（nil 或 false）， 它就调用 error； 否则，返回所有的参数。 在错误情况时， message 指那个错误对象； 如果不提供这个参数，参数默认为 “assertion failed!” 。</p> 
</blockquote> 
<p>assert是error的包装，将判断之类的操作包装了进去！所以使用assert比之使用error更为方便！<br> 第一个参数为nil或判断的结果为false的时候抛出错误，中止运行，调用error函数；否则继续执行！<br> 第二个参数为可选的错误提示信息，如果提供这个参数，调用error函数的时候则打印出message；否则使用默认的"assertion failed!"。</p> 
<pre><code class="prism language-lua"><span class="token keyword">function</span> <span class="token function">testAssert</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">local</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">,</span> <span class="token string">"a,b is not equal !"</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"next operate"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token function">testAssert</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">--[[
lua: C:\Users\user\Desktop\transition\csdn\test.lua:3: a,b is not equal !
stack traceback:
    [C]: in function 'assert'
    C:\Users\user\Desktop\transition\csdn\test.lua:3: in function 'testAssert'
    C:\Users\user\Desktop\transition\csdn\test.lua:7: in main chunk
    [C]: ?
]]</span>
</code></pre> 
<h2><a id="pcall_56"></a>pcall</h2> 
<p><strong>pcall (f [, arg1, ···])</strong></p> 
<blockquote> 
 <p>传入参数，以 保护模式 调用函数 f 。 这意味着 f 中的任何错误不会抛出； 取而代之的是，pcall 会将错误捕获到，并返回一个状态码。 第一个返回值是状态码（一个布尔量）， 当没有错误时，其为真。 此时，pcall 同样会在状态码后返回所有调用的结果。 在有错误时，pcall 返回 false 加错误消息。</p> 
</blockquote> 
<p>pcall会捕捉错误，但不会抛出，所以程序的运行不会被中止！<br> 第一个参数为目标函数，如果目标函数执行发生错误，pcall函数返回false和错误信息；否则pcall函数返回true和目标函数所有的调用结果！<br> 后面的参数为目标函数的参数列表，可选！</p> 
<pre><code class="prism language-lua"><span class="token keyword">function</span> <span class="token function">testPcall</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span>
    <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"pcall test"</span><span class="token punctuation">)</span>
    <span class="token comment">-- return "pcall test"</span>
<span class="token keyword">end</span>

<span class="token keyword">local</span> ret<span class="token punctuation">,</span> msg <span class="token operator">=</span> <span class="token function">pcall</span><span class="token punctuation">(</span>testPcall<span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"fightsyj"</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"next operate"</span><span class="token punctuation">)</span>
<span class="token comment">--[[
hello   fightsyj
false   C:\Users\user\Desktop\transition\csdn\test.lua:3: pcall test
next operate
]]</span>
</code></pre> 
<h2><a id="xpcall_82"></a>xpcall</h2> 
<p><strong>xpcall (f, msgh [, arg1, ···])</strong></p> 
<blockquote> 
 <p>这个函数和 pcall 类似。 不过它可以额外设置一个消息处理器 msgh。</p> 
</blockquote> 
<p>xpcall在pcall的基础之上还可以加一个错误处理函数！<br> 第一个参数以及后面的参数列表和pcall一样！<br> 第二个参数为错误处理函数，可以在这个函数中做打印堆栈信息等操作！</p> 
<pre><code class="prism language-lua"><span class="token keyword">function</span> <span class="token function">testXpcall</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"xpcall test"</span><span class="token punctuation">)</span>
    <span class="token comment">-- return "pcall test"</span>
<span class="token keyword">end</span>

<span class="token comment">-- 错误处理函数</span>
<span class="token keyword">function</span> <span class="token function">dealFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">-- print(debug.traceback())</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"xpcall dealFunc"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token keyword">local</span> ret<span class="token punctuation">,</span> msg <span class="token operator">=</span> <span class="token function">xpcall</span><span class="token punctuation">(</span>testXpcall<span class="token punctuation">,</span> dealFunc<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"next operate"</span><span class="token punctuation">)</span>
<span class="token comment">--[[
xpcall dealFunc
false   nil
next operate
]]</span>
</code></pre> 
<p>参考：<br> <a href="https://www.runoob.com/manual/lua53doc/manual.html#2.3" rel="nofollow">Lua 5.3 参考手册</a><br> <a href="https://www.cnblogs.com/Richard-Core/p/4359953.html" rel="nofollow">Lua 学习笔记（八）错误（error）</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e4e374156a33324ab17b0b5bf9935bd3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue项目--资产管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/14143087f84f06ffde8a69076c10520b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（七）ORBSLAM特征点的三角化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>