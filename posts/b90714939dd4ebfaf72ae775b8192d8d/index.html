<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>小程序之图片懒加载[完美方案，你不来看看？] - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="小程序之图片懒加载[完美方案，你不来看看？]" />
<meta property="og:description" content="效果图 既然来了，把妹子都给你。
定义 懒加载，前端人都知道的一种性能优化方式，简单的来说，只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载。
实现原理 监听页面的scroll事件,判读元素距离页面的top值是否是小于等于页面的可视高度
判断逻辑代码如下
element.getBoundingClientRect().top &lt;= document.documentElement.clientHeight ? 显示 : 默认
我们知道小程序页面的脚本逻辑是在JsCore中运行，JsCore是一个没有窗口对象的环境，所以不能在脚本中使用window，也无法在脚本中操作组件。
所以关于图片懒加载就需要在数据上面做文章了。
页面 页面上面只需要根据数据的某一个字段来判断是否显示图片就可以了，字段为Boolean类型，当为false的时候显示默认图片就行了。
代码大概长成这样
&lt;view wx:for=&#34;{{list}}&#34; class=&#39;item item-{{index}}&#39; wx:key=&#34;{{index}}&#34;&gt; &lt;image class=&#34;{{item.show ? &#39;active&#39;: &#39;&#39;}}&#34; src=&#34;{{item.show ? item.src : item.def}}&#34;&gt;&lt;/image&gt; &lt;/view&gt; 复制代码 布局跟简单，view组件里面有个图片，并循环list，有多少就展示多少
image组件的src字段通过每一项的show来进行绑定，active是加了个透明的过渡
样式 image{ transition: all .3s ease; opacity: 0; } .active{ opacity: 1; } 复制代码 逻辑 本位主要讲解懒加载，所以把数据写死在页面上了
数据结构如下：
我们使用两种方式来实现懒加载，准备好没有，一起来快乐的撸码吧。
WXML节点信息 小程序支持调用createSelectQuery创建一个SelectorQuery实例，并使用select方法来选择节点，并通过boundingClientRect来获取节点信息。
wx.createSelectorQuery().select(&#39;.item&#39;).boundingClientRect((ret)=&gt;{ console.log(ret) }).exec() 复制代码 显示结果如下
悄悄告诉你，小程序里面有个 onPageScroll函数，是用来监听页面的滚动的。 还有个 getSystemInfo函数，可以获取获取系统信息，里面包含屏幕的高度。 接下来，思路就透彻了吧。还是上面的逻辑， 扒拉扒拉直接写代码就行了,这里只写下主要的逻辑，完整代码请戳文末github" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b90714939dd4ebfaf72ae775b8192d8d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-27T09:22:49+08:00" />
<meta property="article:modified_time" content="2018-04-27T09:22:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">小程序之图片懒加载[完美方案，你不来看看？]</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <h3 class="heading">效果图</h3> 
 <p>既然来了，把妹子都给你。</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h3 class="heading">定义</h3> 
 <p>懒加载，前端人都知道的一种性能优化方式，简单的来说，只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载。</p> 
 <h3 class="heading">实现原理</h3> 
 <p>监听页面的<code>scroll</code>事件,判读元素距离页面的<code>top</code>值是否是小于等于页面的可视高度</p> 
 <p>判断逻辑代码如下</p> 
 <p><code>element.getBoundingClientRect().top &lt;= document.documentElement.clientHeight ? 显示 : 默认</code></p> 
 <p>我们知道小程序页面的脚本逻辑是在JsCore中运行，JsCore是一个没有窗口对象的环境，所以不能在脚本中使用window，也无法在脚本中操作组件。</p> 
 <p>所以关于图片懒加载就需要在数据上面做文章了。</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h3 class="heading">页面</h3> 
 <p>页面上面只需要根据数据的某一个字段来判断是否显示图片就可以了，字段为Boolean类型，当为false的时候显示默认图片就行了。</p> 
 <p>代码大概长成这样</p> 
 <pre><code class="hljs bash copyable">&lt;view wx:<span class="hljs-keyword">for</span>=<span class="hljs-string">"{<!-- -->{list}}"</span> class=<span class="hljs-string">'item item-{<!-- -->{index}}'</span>
 wx:key=<span class="hljs-string">"{<!-- -->{index}}"</span>&gt;
	&lt;image class=<span class="hljs-string">"{<!-- -->{item.show ? 'active': ''}}"</span> src=<span class="hljs-string">"{<!-- -->{item.show ? item.src : item.def}}"</span>&gt;&lt;/image&gt;
&lt;/view&gt;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>布局跟简单，<code>view</code>组件里面有个图片，并循环<code>list</code>，有多少就展示多少</p> 
 <p><code>image</code>组件的<code>src</code>字段通过每一项的<code>show</code>来进行绑定，<code>active</code>是加了个透明的过渡</p> 
 <h3 class="heading">样式</h3> 
 <pre><code class="hljs bash copyable">image{
	transition: all .3s ease;
	opacity: 0;
}
.active{
	opacity: 1;
}

<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading">逻辑</h3> 
 <p>本位主要讲解懒加载，所以把数据写死在页面上了</p> 
 <p>数据结构如下：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>我们使用两种方式来实现懒加载，准备好没有，一起来快乐的撸码吧。</p> 
 <h4 class="heading">WXML节点信息</h4> 
 <p>小程序支持调用<a href="https://link.juejin.im?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminiprogram%2Fdev%2Fapi%2Fwxml-nodes-info.html" rel="nofollow">createSelectQuery</a>创建一个<code>SelectorQuery</code>实例，并使用<code>select</code>方法来选择节点，并通过<code>boundingClientRect</code>来获取节点信息。</p> 
 <pre><code class="hljs bash copyable">wx.createSelectorQuery().select(<span class="hljs-string">'.item'</span>).boundingClientRect((ret)=&gt;{
	console.log(ret)
}).exec()
 
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>显示结果如下</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 悄悄告诉你，小程序里面有个 
 <code>onPageScroll</code>函数，是用来监听页面的滚动的。 还有个 
 <code>getSystemInfo</code>函数，可以获取获取系统信息，里面包含屏幕的高度。 
 <p></p> 
 <p>接下来，思路就透彻了吧。还是上面的逻辑， 扒拉扒拉直接写代码就行了,这里只写下主要的逻辑，完整代码请戳文末github</p> 
 <pre><code class="hljs js copyable" lang="js">showImg(){
	<span class="hljs-keyword">let</span> group = <span class="hljs-keyword">this</span>.data.group
	<span class="hljs-keyword">let</span> height = <span class="hljs-keyword">this</span>.data.height  <span class="hljs-comment">// 页面的可视高度</span>
	
	wx.createSelectorQuery().selectAll(<span class="hljs-string">'.item'</span>).boundingClientRect(<span class="hljs-function">(<span class="hljs-params">ret</span>) =&gt;</span> {
	 ret.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {
	   <span class="hljs-keyword">if</span> (item.top &lt;= height) { 判断是否在显示范围内
	     group[index].show = <span class="hljs-literal">true</span> <span class="hljs-comment">// 根据下标改变状态</span>
	   }
	 })
	 <span class="hljs-keyword">this</span>.setData({
	   group
	 })
	}).exec()

}
onPageScroll(){ <span class="hljs-comment">// 滚动事件</span>
	<span class="hljs-keyword">this</span>.showImg()
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>至此，我们完成了一个小程序版的图片懒加载，只是思维转变了下，其实并没有改变实现方式。我们来学些新的东西吧。</p> 
 <h4 class="heading">节点布局相交状态</h4> 
 <p>节点相交状态是啥？它是一个新的API，叫做<code>IntersectionObserver</code>, 本文只讲解简单的使用，了解更多请猛戳<a href="https://juejin.im/post/5a7973575188257a5911a749" rel="nofollow">没错，就是点我</a></p> 
 <p>小程序里面给它的定义是节点布局交叉状态API可用于监听两个或多个组件节点在布局位置上的相交状态。这一组API常常可以用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。</p> 
 <p>里面设计的概念主要有五个，分别为</p> 
 <ul><li>参照节点：以某参照节点的布局区域作为参照区域，<em>参照节点可以有多个</em>，多个话参照区域取它们的布局区域的<em>交集</em></li><li>目标节点：监听的目标，只能是<em>一个</em>节点</li><li>相交区域：目标节点与参照节点的相交区域</li><li>相交比例：目标节点与参照节点的相交比例</li><li>阈值：可以有多个，默认为[0], 可以理解为交叉比例，例如[0.2, 0.5]</li></ul> 
 <p>关于它的API有五个，依次如下</p> 
 <p>1、<code>createIntersectionObserver([this], [options])</code>，见名知意,创建一个IntersectionObserver实例</p> 
 <p>2、<code>intersectionObserver.relativeTo(selector, [margins])</code>, 指定节点作为参照区域，margins参数可以放大缩小参照区域，可以包含top、left、bottom、right四项</p> 
 <p>3、<code>intersectionObserver.relativeToViewport([margin])</code>，指定页面显示区域为参照区域</p> 
 <p>4、<code>intersectionObserver.observer(targetSelector, callback)</code>，参数为指定监听的节点和一个回调函数，目标元素的相交状态发生变化时就会触发此函数，callback函数包含一个result，下面再讲</p> 
 <p>5、<code>intersectionObserver.disconnect()</code> 停止监听，回调函数不会再触发</p> 
 <p>然后说下callback函数中的result，它包含的字段为</p> 
 <table><thead><tr><th>字段名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>intersectionRatio</td><td>Number</td><td>相交比例</td></tr><tr><td>intersectionRect</td><td>Object</td><td>相交区域的边界，包含 left 、 right 、 top 、 bottom 四项</td></tr><tr><td>boundingClientRect</td><td>Object</td><td>目标节点布局区域的边界，包含 left 、 right 、 top 、 bottom 四项</td></tr><tr><td>relativeRect</td><td>Object</td><td>参照区域的边界，包含 left 、 right 、 top 、 bottom 四项</td></tr><tr><td>time</td><td>Number</td><td>相交检测时的时间戳</td></tr></tbody></table> 
 <p>我们主要使用<code>intersectionRatio</code>进行判断，当它大于0时说明是相交的也就是可见的。</p> 
 <p>先来波测试题，请说出下面的函数做了什么，并且log函数会执行几次</p> 
 <pre><code class="hljs js copyable" lang="js"><span class="hljs-number">1</span>、
wx.createIntersectionObserver().relativeToViewport().observer(<span class="hljs-string">'.box'</span>, (result) =&gt; {
 	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'监听box组件触发的函数'</span>)   
 })
 
<span class="hljs-number">2</span>、
wx.createIntersectionObserver().relativeTo(<span class="hljs-string">'.box'</span>).observer(<span class="hljs-string">'.item'</span>, (result) =&gt; {
 	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'监听item组件触发的函数'</span>) 
})

<span class="hljs-number">3</span>、
wx.createIntersectionObserver().relativeToViewport().observer(<span class="hljs-string">'.box'</span>, (result) =&gt; {
	<span class="hljs-keyword">if</span>(result.intersectionRatio &gt; <span class="hljs-number">0</span>){
		<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'.box组件是可见的'</span>) 
	}
})
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>duang，揭晓答案。</p> 
 <p>第一个以当前页面的视窗监听了<code>.box</code>组件，log会触发两次，一次是进入页面一次是离开页面</p> 
 <p>第二个以<code>.box</code>节点的布局区域监听了<code>.item</code>组件，log会触发两次，一次是进入页面一次是离开页面</p> 
 <p>第三个以当前页面的视窗监听了<code>.box</code>组件，log只会在节点可见的时候触发</p> 
 <p>好了，题也做了，API你也掌握了，相信你已经可以使用<code>IntersectionObserver</code>来实现图片懒加载了吧，主要逻辑如下</p> 
 <pre><code class="hljs js copyable" lang="js"><span class="hljs-keyword">let</span> group = <span class="hljs-keyword">this</span>.data.group <span class="hljs-comment">// 获取图片数组数据</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.data.group){   wx.createIntersectionObserver().relativeToViewport().observe(<span class="hljs-string">'.item-'</span>+ i, (ret) =&gt; {
	   <span class="hljs-keyword">if</span> (ret.intersectionRatio &gt; <span class="hljs-number">0</span>){
	     group[i].show = <span class="hljs-literal">true</span> 
	   }
	   <span class="hljs-keyword">this</span>.setData({
	     group
	   })
	 })
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <h3 class="heading">最后</h3> 
 <p>至此，我们使用两种方式实现了小程序版本的图片懒加载，可以发现，使用<code>IntersectionObserver</code>来实现不要太酸爽。</p> 
 <p>本文代码请戳<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FOrtonzhang%2Fsimple-code%2Ftree%2Fmaster%2Fjavascript%2Flazyload-miniprogram" rel="nofollow">github</a></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00816af73608449c6461c0c8f43c3da1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">局域网打印机共享时好时坏问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/45b9634a63aa1d724fe2bd51cf1cd60b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Redis】获取没有设置ttl的key脚本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>