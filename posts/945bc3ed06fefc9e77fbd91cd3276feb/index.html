<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>http加密、状态码、百度 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="http加密、状态码、百度" />
<meta property="og:description" content="1.怎么实现非对称加密传输对称加密： 概念 https相当于在http和tcp之间加上了一层ssl加密，但是要注意的是：
https协议的内容传输的加密上使用的是对称加密；非对称加密之作用在证书验证阶段。
因为非对称加密的加解密效率是非常低的，而https的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。
对于对称加密，比如说常见的移位替换等方法，只要知道了加密过程，就一定知道解密过程，因为加密算法比较简单，那么根据加密算法就能反推出解密算法，也就是双方的秘钥是一样的，这就是对称加密。
非对称加密：你的手上有两个密钥（一对密钥），它们有一定的关联，但没有办法通过其中一个算出另外一个。你把一个密钥紧紧地攥在手里，永远不向别人公布**（私钥）；把另外一个发送给我，当然，发送给我的途中，所有的设备都知道了这个密钥（公钥）。之后我用公钥加密了数据**，并发送给你，你却可以奇迹般地用私钥解密它。但是对于只有公钥的人，却不能用公钥对其进行解密。
过程 https建立连接的过程：
1、客户端发起握手请求，注意这里请求是明文的，客户端没有使用任何秘钥。直接达到请求url的443端口即可。
2、服务器将数字证书发送给客户端，这个数字证书是为了防止中间人攻击的，里面包括了公钥。请注意，这里服务器接收到请求之后，会在服务器本地生成这个一对公钥和私钥，它的公钥会发送给客户端，私钥留在自己本地。而数字证书，是保证了客户端收到这个私钥所在的数字证书之后，信任真正是由这个网站发送过来的**（数字证书表示对服务器的认可）而不是别的中间人。
3、客户端验证证书的合法性**。因为数字证书包括过期时间，域名以及最重要的公钥，所以数字证书能验证是不是真正由网站发过来的。
4、确定证书合法之后，客户端随机生成一个长整数，这个长整数用公钥加密，加密之后就发送至服务器。
5、服务器用私钥解密，拿到了之后进行数据交换时用于对称加密的秘钥。这个秘钥就是以后进行真正数据交换的秘钥了。
6、服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输给客户端，这样子这个对称加密的算法双方都知道了，https加密连接也就完成了。
那究竟怎么避免加密失败了呢？
首先，第二步的数字证书保证了服务器和公钥的可信任性，这样之后客户端就可以大胆利用这个公钥进行加密。
第二，服务器用公钥发送，私钥一直留在本地，这样就没可能让客户端发送的东西被其他人截取之后破解，因为没有私钥。也就是说第五步用私钥解密之后，保证了这个客户端随机生成的整数只有客户端和服务器知道，其他的人都不知道。
之后利用这个别人都不知道的整数去生成对称加密的算法，这样其他人就就算是拦截了数据，因为对称加密算法不知道，也就无法破解了。因此保证了https协议的安全性
web状态码 1XX：信息提示 这类状态代码表示临时的响应。客户端在收到常规相应之前，应准备接受一个或多个1xx相应。
HTTP状态码说明100继续101切换协议 2XX：成功 这类状态代码表示服务器成功的接受了客户的请求。
HTTP状态码说明200确定。客户端请求已经成功201已经创建202已接受203非权威性信息204无内容205重置内容206部分内容。表明已经部分下载了一个文件。可以继续损坏的下载，或者将下载拆分为多个并发的流207多状态（webDAV）。此消息之前应该还有一条XML消息，其中可能包含几个单独的响应代码，具体取决于发出了多少个子请求。 3XX：重定向 客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同页面，或通过代理服务器重复该请求。
HTTP状态码说明301已永久移动。此请求和之后所有的请求都应该转到指定的URL302对象已移动。对于基于表单的身份验证，此消息通常表示“对象已经移动”。请求的资源临时驻留在不同的URL。由于重定向有时可能对改变，客户端将来在请求时应该继续使用RequestURL。只有在CacheControl 或 Expires 标题字段中指示，此响应才能够缓存。304未修改。客户端请求的文档已经在缓存中，文档缓存以来尚未被修改过。客户端使用的缓存副本。而从不服务器下载文档307临时从定向 4XX：客户端错误 发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。
401状态码： 403状态码 404状态码 5XX：服务器错误 服务器由于遭遇错误而不能完成该请求
500状态码 502状态码 如何与百度建立连接 1、检查本地dns缓存，看缓存中是否有解析数据。
2、查看本地的hosts文件
3、本机固定的dns服务器（路由器）找到13台根域服务器
4、根域找到com域，com找到baidu域名
给你返回结果
返回给你主机
5、和百度服务器建立TCP可靠连接，三次握手
keep-alive
request
response
最终通过浏览器实现解析页面" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/945bc3ed06fefc9e77fbd91cd3276feb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-11T15:41:42+08:00" />
<meta property="article:modified_time" content="2022-07-11T15:41:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">http加密、状态码、百度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_0"></a>1.怎么实现非对称加密传输对称加密：</h2> 
<h3><a id="_1"></a>概念</h3> 
<p>https相当于在http和tcp之间加上了一层<strong>ssl加密</strong>，但是要注意的是：<br> https协议的<strong>内容传输的加密上使用的是对称加密</strong>；<strong>非对称加密</strong>之作用在<strong>证书验证阶段</strong>。<br> <strong>因为</strong>非对称加密的加解密效率是非常低的，而https的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。</p> 
<p><strong>对于对称加密</strong>，比如说常见的移位替换等方法，只要<strong>知道了加密</strong>过程，就一定<strong>知道解密</strong>过程，因为加密算法比较简单，那么根据加密算法就能反推出解密算法，也就是<strong>双方的秘钥</strong>是一样的，这就是对称加密。</p> 
<p><strong>非对称加密</strong>：你的手上有<strong>两个密钥（一对密钥）</strong>，它们有一定的<strong>关联</strong>，但<strong>没有办法通过其中一个算出另外一个</strong>。你把一个密钥紧紧地攥在手里，永远不向别人公布**（私钥）<strong>；把另外一个发送给我，当然，发送给我的途中，所有的设备都知道了这个密钥</strong>（公钥）<strong>。之后我用</strong>公钥加密了数据**，并发送给你，你却可以奇迹般地用<strong>私钥解密它</strong>。但是对于只有公钥的人，<strong>却不能用公钥对其进行解密</strong>。</p> 
<h3><a id="_9"></a>过程</h3> 
<p><strong>https建立连接的过程</strong>：<br> <img src="https://images2.imgbox.com/eb/ce/1Nje1fn3_o.png" alt="在这里插入图片描述"><br> 1、<strong>客户端发起握手</strong>请求，注意这里<strong>请求是明文的</strong>，客户端<strong>没有使用任何秘钥</strong>。直接达到请求url的443端口即可。<br> 2、<strong>服务器将数字证书</strong>发送给客户端，这个<strong>数字证书是为了防止中间人攻击的，里面包括了公钥</strong>。请注意，这里<strong>服务器接收到请求</strong>之后，会在服务器<strong>本地生成这个一对公钥和私钥</strong>，它的<strong>公钥会发送给客户端，私钥留在自己本地</strong>。而数字证书，是保证了客户端收到这个私钥所在的数字证书之后，信任真正是由这个网站发送过来的**（数字证书表示对服务器的认可）<strong>而不是别的中间人。<br> 3、客户端</strong>验证证书的合法性**。因为<strong>数字证书包括过期时间，域名以及最重要的公钥</strong>，所以数字证书能验证是不是真正由网站发过来的。<br> 4、<strong>确定证书合法之后</strong>，客户端<strong>随机生成一个长整数</strong>，这个长整数<strong>用公钥加密</strong>，加密之后就<strong>发送至服务器。</strong><br> 5、服务器用<strong>私钥解密</strong>，拿到了之后进行<strong>数据交换时用于对称加密的秘钥</strong>。这个秘钥就是以后进行真正数据交换的秘钥了。<br> 6、<strong>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输给客户端</strong>，这样子这个对称加密的算法双方都知道了，https加密连接也就完成了。</p> 
<p><strong>那究竟怎么避免加密失败了呢？</strong><br> 首先，第二步的<strong>数字证书保证了服务器和公钥的可信任性</strong>，这样之后客户端就可以大胆利用这个公钥进行加密。</p> 
<p>第二，服务器用公钥发送，私钥一直留在本地，这样就没可能让客户端发送的东西被其他人截取之后破解，因为没有私钥。也就是说第五步用私钥解密之后，保证了这个客户端随机生成的整数只有客户端和服务器知道，其他的人都不知道。</p> 
<p>之后利用这个别人都不知道的<strong>整数去生成对称加密的算法</strong>，这样其他人就就算是拦截了数据，因为对称加密算法不知道，也就无法破解了。因此保证了https协议的安全性</p> 
<h2><a id="web_27"></a>web状态码</h2> 
<h3><a id="1XX_28"></a>1XX：信息提示</h3> 
<p>这类状态代码表示<strong>临时的响应</strong>。客户端在收到常规相应之前，应准备接受一个或多个1xx相应。</p> 
<table><thead><tr><th>HTTP状态码</th><th>说明</th></tr></thead><tbody><tr><td>100</td><td>继续</td></tr><tr><td>101</td><td>切换协议</td></tr></tbody></table> 
<h3><a id="2XX_34"></a>2XX：成功</h3> 
<p>这类状态代码表示<strong>服务器成功的接受了客户的请求。</strong></p> 
<table><thead><tr><th>HTTP状态码</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>确定。客户端请求已经成功</td></tr><tr><td>201</td><td>已经创建</td></tr><tr><td>202</td><td>已接受</td></tr><tr><td>203</td><td>非权威性信息</td></tr><tr><td>204</td><td>无内容</td></tr><tr><td>205</td><td>重置内容</td></tr><tr><td>206</td><td>部分内容。表明已经部分下载了一个文件。可以继续损坏的下载，或者将下载拆分为多个并发的流</td></tr><tr><td>207</td><td>多状态（webDAV）。此消息之前应该还有一条XML消息，其中可能包含几个单独的响应代码，具体取决于发出了多少个子请求。</td></tr></tbody></table> 
<h3><a id="3XX_46"></a>3XX：重定向</h3> 
<p>客户端浏览器<strong>必须采取更多操作来实现请求</strong>。例如，浏览器可能不得不请求服务器上的不同页面，或通过代理服务器重复该请求。</p> 
<table><thead><tr><th>HTTP状态码</th><th>说明</th></tr></thead><tbody><tr><td>301</td><td>已永久移动。此请求和之后所有的请求都应该转到指定的URL</td></tr><tr><td>302</td><td>对象已移动。对于基于表单的身份验证，此消息通常表示“对象已经移动”。请求的资源临时驻留在不同的URL。由于重定向有时可能对改变，客户端将来在请求时应该继续使用RequestURL。只有在CacheControl 或 Expires 标题字段中指示，此响应才能够缓存。</td></tr><tr><td>304</td><td>未修改。客户端请求的文档已经在缓存中，文档缓存以来尚未被修改过。客户端使用的缓存副本。而从不服务器下载文档</td></tr><tr><td>307</td><td>临时从定向</td></tr></tbody></table> 
<h3><a id="4XX_54"></a>4XX：客户端错误</h3> 
<p><strong>发生错误，客户端似乎有问题</strong>。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。</p> 
<p><img src="https://images2.imgbox.com/fa/69/WsCjdsBP_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="401_58"></a>401状态码：</h3> 
<p><img src="https://images2.imgbox.com/bb/8c/BNQvhWbo_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="403_61"></a>403状态码</h3> 
<p><img src="https://images2.imgbox.com/ef/9a/ZfP1qVHr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4a/98/atnWE3RM_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="404_65"></a>404状态码</h3> 
<p><img src="https://images2.imgbox.com/aa/8c/23ZAERez_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5XX_68"></a>5XX：服务器错误</h3> 
<p><strong>服务器由于遭遇错误</strong>而不能完成该请求<br> <img src="https://images2.imgbox.com/f8/ce/w4cvLomC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="500_71"></a>500状态码</h3> 
<p><img src="https://images2.imgbox.com/3b/f8/Pv3OPdiR_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="502_74"></a>502状态码</h3> 
<p><img src="https://images2.imgbox.com/49/a0/C0hOmDFg_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_77"></a>如何与百度建立连接</h2> 
<p>1、检查本地dns缓存，看缓存中是否有解析数据。<br> 2、查看本地的hosts文件<br> 3、本机固定的dns服务器（路由器）找到13台根域服务器<br> 4、根域找到com域，com找到baidu域名<br> 给你返回结果<br> 返回给你主机<br> 5、和百度服务器建立TCP可靠连接，三次握手<br> keep-alive<br> request<br> response<br> 最终通过浏览器实现解析页面</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9e34e49762a5f73aadbe3ae825c1dacf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows关闭445、3389端口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/65724d7e8fc192d55f1fccf10aaacef8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">＜C&#43;&#43;＞ 通讯录管理系统(纯手写含源码)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>