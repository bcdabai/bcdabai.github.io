<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Pygame程序的屏幕显示 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Pygame程序的屏幕显示" />
<meta property="og:description" content="不同对象的绘制与显示过程 在Pygame中，需要将所有需要在屏幕上显示的内容都绘制在一个display surface上。该Surface通常称为screen surface，它是pygame.display.set_mode()函数返回的Surface对象。
在绘制不同对象时，可以使用不同的绘制方法。下面介绍一些常用的绘制方法：
绘制图像：
使用pygame.image.load()函数加载图像文件，返回一个Surface对象。将需要绘制的图像blit到screen surface中，使用Surface.blit()方法进行绘制。 绘制文本：
使用pygame.font.Font()函数创建字体对象，该函数接受两个参数：字体文件的路径和字体大小。使用字体对象的render()方法将文本渲染成Surface对象。将渲染好的Surface对象blit到screen surface中。 绘制几何图形：
使用pygame.draw.rect()函数绘制矩形。使用pygame.draw.circle()函数绘制圆形。使用pygame.draw.line()函数绘制直线等。 Pygame中不同对象的显示过程 在Pygame中，不同对象的显示过程如下：
颜色填充：
调用screen surface对象的fill()方法，可以将整个screen surface区域或部分screen surface区域填充为指定颜色。 简单图形：
使用pygame.draw模块下的相关函数，例如pygame.draw.line()绘制直线、pygame.draw.rect()绘制矩形、pygame.draw.circle()绘制圆形等。将绘制函数的第一个参数指定为screen surface对象，以便将图形绘制在screen surface上。 图片图像：
使用pygame.image.load()方法加载图片文件，返回一个image surface对象，表示图片的像素信息。调用screen surface对象的blit()方法，将image surface绘制到screen surface上。blit()方法的第一个参数是要绘制的image surface，第二个参数是一个坐标元组，表示绘制的位置。 文字：
使用pygame.font.Font()函数创建字体对象，指定字体文件的路径和字体大小。使用字体对象的render()方法将文字渲染成一个text surface对象。调用screen surface对象的blit()方法，将text surface绘制到screen surface上。 在绘制完所有对象后，需要调用pygame.display.flip()或pygame.display.update()函数来更新屏幕显示。flip()函数会将screen surface的内容更新到屏幕上，并清除之前的内容。update()函数只会更新有变化的部分，可以提高程序的运行效率。
总之，在Pygame中，颜色填充只需调用fill()方法，简单图形使用相关绘制函数并指定screen surface为第一个参数，图片图像先加载为image surface再使用blit()方法绘制，文字先渲染为text surface再使用blit()方法绘制。最后需要调用flip()或update()函数更新屏幕显示。
在Pygame的画面中移动物体 在Pygame中，要移动物体，可以按照以下步骤进行操作：
在游戏循环中，使用pygame.Surface.fill()方法或其他绘制函数将物体绘制在屏幕上。在每次循环中，更新物体的位置。可以通过改变物体的坐标来实现物体的移动。在下一次循环开始之前，使用pygame.Surface.fill()方法或其他绘制函数将物体从原来的位置擦除。使用pygame.Surface.blit()方法或其他绘制函数将物体绘制到新的位置上。 注意：
注意对象的绘制顺序，后绘制的对象会把先绘制的对象覆盖住。注意及时清除屏幕，当在循环中不断绘制某个对象时，若是没有及时清除屏幕，则会导致“重影”现象，特别是在对象移动的情况下；因此在每次重绘时，最好清除屏幕内容，可以利用fill（）方法把整个屏幕填充为相同颜色，也可重绘背景图片，具体方法取决于应用场景。注意记得调用pygame.display.flip（）或者pygame.display.update（）更新屏幕，否则屏幕上什么都不会显示。 具体示例：一个运动的小球 import pygame pygame.init() # 设置窗口大小 size = [400, 300] screen = pygame.display.set_mode(size) # 设置窗口标题 pygame.display.set_caption(&#34;Moving Ball&#34;) # 设置背景颜色 bg_color = (255, 255, 255) # 设置小球初始位置和速度 ball_pos = [50, 50] ball_speed = [2, 2] # 游戏循环 done = False while not done: # 处理事件 for event in pygame." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fb98b4880d680dca8cb2440b8a994f7c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T23:03:34+08:00" />
<meta property="article:modified_time" content="2024-01-12T23:03:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Pygame程序的屏幕显示</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>不同对象的绘制与显示过程</h2> 
<p>在Pygame中，需要将所有需要在屏幕上显示的内容都绘制在一个display surface上。该Surface通常称为screen surface，它是pygame.display.set_mode()函数返回的Surface对象。</p> 
<p>在绘制不同对象时，可以使用不同的绘制方法。下面介绍一些常用的绘制方法：</p> 
<ul><li> <p>绘制图像：</p> 
  <ul><li>使用pygame.image.load()函数加载图像文件，返回一个Surface对象。</li><li>将需要绘制的图像blit到screen surface中，使用Surface.blit()方法进行绘制。</li></ul></li><li> <p>绘制文本：</p> 
  <ul><li>使用pygame.font.Font()函数创建字体对象，该函数接受两个参数：字体文件的路径和字体大小。</li><li>使用字体对象的render()方法将文本渲染成Surface对象。</li><li>将渲染好的Surface对象blit到screen surface中。</li></ul></li><li> <p>绘制几何图形：</p> 
  <ul><li>使用pygame.draw.rect()函数绘制矩形。</li><li>使用pygame.draw.circle()函数绘制圆形。</li><li>使用pygame.draw.line()函数绘制直线等。</li></ul></li></ul> 
<h2>Pygame中不同对象的显示过程</h2> 
<p>在Pygame中，不同对象的显示过程如下：</p> 
<ol><li> <p>颜色填充：</p> 
  <ul><li>调用screen surface对象的fill()方法，可以将整个screen surface区域或部分screen surface区域填充为指定颜色。</li></ul></li><li> <p>简单图形：</p> 
  <ul><li>使用pygame.draw模块下的相关函数，例如pygame.draw.line()绘制直线、pygame.draw.rect()绘制矩形、pygame.draw.circle()绘制圆形等。</li><li>将绘制函数的第一个参数指定为screen surface对象，以便将图形绘制在screen surface上。</li></ul></li><li> <p>图片图像：</p> 
  <ul><li>使用pygame.image.load()方法加载图片文件，返回一个image surface对象，表示图片的像素信息。</li><li>调用screen surface对象的blit()方法，将image surface绘制到screen surface上。blit()方法的第一个参数是要绘制的image surface，第二个参数是一个坐标元组，表示绘制的位置。</li></ul></li><li> <p>文字：</p> 
  <ul><li>使用pygame.font.Font()函数创建字体对象，指定字体文件的路径和字体大小。</li><li>使用字体对象的render()方法将文字渲染成一个text surface对象。</li><li>调用screen surface对象的blit()方法，将text surface绘制到screen surface上。</li></ul></li></ol> 
<p>在绘制完所有对象后，需要调用pygame.display.flip()或pygame.display.update()函数来更新屏幕显示。flip()函数会将screen surface的内容更新到屏幕上，并清除之前的内容。update()函数只会更新有变化的部分，可以提高程序的运行效率。</p> 
<p>总之，在Pygame中，颜色填充只需调用fill()方法，简单图形使用相关绘制函数并指定screen surface为第一个参数，图片图像先加载为image surface再使用blit()方法绘制，文字先渲染为text surface再使用blit()方法绘制。最后需要调用flip()或update()函数更新屏幕显示。</p> 
<h2>在Pygame的画面中移动物体</h2> 
<p>在Pygame中，要移动物体，可以按照以下步骤进行操作：</p> 
<ol><li>在游戏循环中，使用pygame.Surface.fill()方法或其他绘制函数将物体绘制在屏幕上。</li><li>在每次循环中，更新物体的位置。可以通过改变物体的坐标来实现物体的移动。</li><li>在下一次循环开始之前，使用pygame.Surface.fill()方法或其他绘制函数将物体从原来的位置擦除。</li><li>使用pygame.Surface.blit()方法或其他绘制函数将物体绘制到新的位置上。</li></ol> 
<blockquote> 
 <p>注意：</p> 
 <ul><li>注意对象的绘制顺序，后绘制的对象会把先绘制的对象覆盖住。</li><li>注意及时清除屏幕，当在循环中不断绘制某个对象时，若是没有及时清除屏幕，则会导致“重影”现象，特别是在对象移动的情况下；因此在每次重绘时，最好清除屏幕内容，可以利用fill（）方法把整个屏幕填充为相同颜色，也可重绘背景图片，具体方法取决于应用场景。</li><li>注意记得调用pygame.display.flip（）或者pygame.display.update（）更新屏幕，否则屏幕上什么都不会显示。</li></ul> 
</blockquote> 
<p>具体示例：一个运动的小球 </p> 
<pre><code class="language-python">import pygame

pygame.init()

# 设置窗口大小
size = [400, 300]
screen = pygame.display.set_mode(size)

# 设置窗口标题
pygame.display.set_caption("Moving Ball")

# 设置背景颜色
bg_color = (255, 255, 255)

# 设置小球初始位置和速度
ball_pos = [50, 50]
ball_speed = [2, 2]

# 游戏循环
done = False
while not done:
    # 处理事件
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            done = True

    # 清除屏幕
    screen.fill(bg_color)

    # 移动小球
    ball_pos[0] += ball_speed[0]
    ball_pos[1] += ball_speed[1]

    # 如果小球碰到边界，就反弹回来
    if ball_pos[0] &lt; 0 or ball_pos[0] &gt; size[0]:
        ball_speed[0] = -ball_speed[0]
    if ball_pos[1] &lt; 0 or ball_pos[1] &gt; size[1]:
        ball_speed[1] = -ball_speed[1]

    # 绘制小球
    pygame.draw.circle(screen, (255, 0, 0), ball_pos, 10)

    # 刷新屏幕
    pygame.display.flip()

    # 控制帧率
    pygame.time.Clock().tick(60)

# 退出程序
pygame.quit()

</code></pre> 
<blockquote> 
 <p>在上面的代码中，首先初始化了Pygame库，创建一个窗口，并设置了窗口标题和背景颜色。</p> 
 <p>然后定义了小球的初始位置和速度，以及游戏循环中需要处理的事件。</p> 
 <p>在游戏循环中，首先清除屏幕，然后移动小球的位置，并处理小球碰到边界的情况，使其反弹回来。</p> 
 <p>接下来，通过pygame.draw.circle()函数绘制了一个红色的小球，</p> 
 <p>最后通过pygame.display.flip()刷新屏幕，让绘制的内容显示出来。</p> 
 <p>在每次循环结束后，调用pygame.time.Clock().tick(60)控制帧率，从而保证程序的运行速度不会过快或过慢。</p> 
</blockquote> 
<p>通过上面的代码，实现了一个简单的运动小球，并且可以通过修改参数和添加功能，实现自己想要的效果。</p> 
<p><img alt="" height="415" src="https://images2.imgbox.com/31/36/01AlDMjO_o.png" width="502"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1bee67302968a8a2f4b54aa7e25e89a7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">写在学习webkit过程的前面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ee7bf9f5b2cfa6a63c8ab50a64095828/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaWeb-HTTP</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>