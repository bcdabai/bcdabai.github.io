<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Ajax异步请求阻塞情况的解决办法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Ajax异步请求阻塞情况的解决办法" />
<meta property="og:description" content="情况：同事在写Webform页面程序发现这样一个现象：在做导出功能时，由于导出数据的处理时间比较长，就在客户端加一个定时器通过ajax不间断查询导出进度。然后发现了一个情况，这个请求一直是阻塞的状态，直到导出事件处理完成之后。才去执行这个请求，也就是说如果响应时间长的请求还在进行中，短的请求却被挂起了。
连续用了两个异步请求去获取资源为什么反而加载更慢了呢？
原来是在进行异步请求时访问了session，为了安全考虑（避免单个用户并发请求导致的session数据错乱），.net中session实现了Reader/Writer的锁机制,当session具有读写功能时，采用排它锁来互斥的访问session数据，也就是说开启了session后，单个用户只能串行的访问这个站点，直到这个访问结束前，其他的请求都会进入等待状态，从而进入线程的顺序执行。
SessionReader/Writer的锁机制原理：当页面对Session具有可写功能（即页面有&lt;%@Page EnableSessionState=&#34;True&#34; %&gt;标记），此时直到请求完成该页面的Session持有一个写锁定。
当页面对Session具有只读功能（即页面有&lt;%@Page EnableSessionState=&#34;ReadOnly&#34; %&gt;标记），此时知道请求完成该页面的Session持有一个读锁定。
读锁定将阻塞一个写锁定；读锁定不会阻塞读锁定；写锁定将阻塞所有的读写锁定。这就是为什么两个框架中的同一个页面都去写同一个Session时，其中一个要等待另一个（稍快的那个）完成后，才开始写。
解决方案： “写锁定将阻塞所有的读写锁定”，也就是说页面在EnableSessionState=&#34;True&#34;的情况下没返回输出时，一直持着Session写操作，其他页面对Session的读操作必须等待，而asp.net的aspx页面默认是EnableSessionState=&#34;True&#34;，每个页面从请求开始至返回一直持着Session写操作，需验证页面必须读取Session值判断，这就是为什么需验证的页面请求被阻塞的原因。只要耗时页面（A页面）没有Session的写操作，也就不会阻塞其他页面的请求，于是修改A页面的EnableSessionState=&#34;ReadOnly&#34;，例如：
&lt;%@ Page Language=&#34;C#&#34; AutoEventWireup=&#34;true&#34;CodeFile=&#34;TBS_Monitor_List.aspx.cs&#34;EnableSessionState=&#34;ReadOnly&#34; Inherits=&#34;TBS_Monitor_List&#34; %&gt; ，问题解决。
结论：也就是说，在无需对session进行写操作的页面，在Page指令加上EnableSessionState=&#34;ReadOnly&#34;属性，就不会造成Request阻塞的情况了。同样的，访问其他实现了锁机制的资源时也要注意锁造成的Request阻塞的情况。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7104eda14ed6205ec3391d1c695cb0d0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-19T15:13:53+08:00" />
<meta property="article:modified_time" content="2022-10-19T15:13:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Ajax异步请求阻塞情况的解决办法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;"><strong><span style="background-color:#ffffff;"><span style="color:#333333;">情况：</span></span></strong><span style="background-color:#ffffff;"><span style="color:#333333;">同事在写Webform页面程序发现这样一个现象：在做导出功能时，由于导出数据的处理时间比较长，就在客户端加一个定时器通过ajax不间断查询导出进度。然后发现了一个情况，这个请求一直是阻塞的状态，直到导出事件处理完成之后。才去执行这个请求，也就是说如果响应时间长的请求还在进行中，短的请求却被挂起了。</span></span><br>  </p> 
<p style="margin-left:0cm;"><span style="color:#a5a5a5;">连续用了两个异步请求去获取资源为什么反而加载更慢了呢？</span></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">原来是在进行异步请求时访问了session，为了安全考虑（避免单个用户并发请求导致的session数据错乱），.net中<strong>session实现了Reader/Writer的锁机制</strong>,当session具有读写功能时，采用排它锁来互斥的访问session数据，也就是说开启了session后，单个用户只能串行的访问这个站点，直到这个访问结束前，其他的请求都会进入等待状态，从而进入线程的顺序执行。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><strong><span style="background-color:#ffffff;"><span style="color:#333333;">SessionReader/Writer</span></span></strong><span style="background-color:#ffffff;"><span style="color:#333333;"><strong>的锁机制原理：</strong>当页面对Session具有可写功能（即页面有&lt;%@Page EnableSessionState="True" %&gt;标记），此时直到请求完成该页面的Session持有一个写锁定。</span></span></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#333333;">当页面对Session具有只读功能（即页面有&lt;%@Page EnableSessionState="ReadOnly" %&gt;标记），此时知道请求完成该页面的Session持有一个读锁定。</span></span></p> 
<p style="margin-left:0cm;">  <span style="background-color:#ffffff;"><span style="color:#333333;">读锁定将阻塞一个写锁定；读锁定不会阻塞读锁定；写锁定将阻塞所有的读写锁定。这就是为什么两个框架中的同一个页面都去写同一个Session时，其中一个要等待另一个（稍快的那个）完成后，才开始写。</span></span></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><strong><span style="background-color:#ffffff;"><span style="color:#333333;">解决方案： </span></span></strong></p> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#333333;">“</span></span><span style="background-color:#ffffff;"><span style="color:#333333;">写锁定将阻塞所有的读写锁定”，也就是说页面在EnableSessionState="True"的情况下没返回输出时，一直持着Session写操作，其他页面对Session的读操作必须等待，而asp.net的aspx页面默认是EnableSessionState="True"，每个页面从请求开始至返回一直持着Session写操作，需验证页面必须读取Session值判断，这就是为什么需验证的页面请求被阻塞的原因。只要耗时页面（A页面）没有Session的写操作，也就不会阻塞其他页面的请求，于是修改A页面的EnableSessionState="ReadOnly"，例如：</span></span></p> 
<p></p> 
<pre><code class="language-cs">&lt;%@ Page Language="C#" AutoEventWireup="true"CodeFile="TBS_Monitor_List.aspx.cs"EnableSessionState="ReadOnly" Inherits="TBS_Monitor_List" %&gt;</code></pre> 
<p style="margin-left:0cm;"><span style="background-color:#ffffff;"><span style="color:#333333;">，问题解决。</span></span></p> 
<p style="margin-left:0cm;"><br>  </p> 
<p style="margin-left:0cm;"><strong><span style="background-color:#ffffff;"><span style="color:#333333;">结论：</span></span></strong><span style="background-color:#ffffff;"><span style="color:#333333;">也就是说，在</span></span><strong>无需对session进行写操作</strong>的页面，在Page指令加上<strong><span style="background-color:#ffffff;"><span style="color:#994800;">EnableSessionState="ReadOnly"</span></span></strong><span style="background-color:#ffffff;"><span style="color:#333333;">属性，就不会造成Request阻塞的情况了。同样的，访问其他实现了锁机制的资源时也要注意锁造成的Request阻塞的情况。</span></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ef1ae5ed4145ee959530590de83bfecf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">对象（object) 与数组（array)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e6113fbb5652982df68ca25e70cc69ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp 获取手机号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>