<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>NVDLA学习笔记（1） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="NVDLA学习笔记（1）" />
<meta property="og:description" content="NVDLA学习笔记（1） 作者：夏风喃喃 参考：http://nvdla.org/index.html NVIDIA 深度学习加速器 （NVDLA） 是一个免费和开放的架构，促进设计深度学习推理加速器的标准方法。NVDLA 采用模块化架构，可扩展、高度可配置，旨在简化集成性和便携性。硬件支持广泛的 IoT 设备。
文章目录 NVDLA学习笔记（1）NVDLA入门一. 概述二. 使用 NVDLA 加速深度学习推理2.1 小 NVDLA 模型2.2 大 NVDLA 模型 三. 硬件架构3.1 连接3.2 组件3.2.1 卷积（Convolution）3.2.2 单数据点处理器（Single Data Point Processor）3.2.3 平面数据处理器（Planar Data Processor）3.2.4 跨通道数据处理器（Cross-channel Data Processor）3.2.5 数据Reshape引擎（Data Reshape Engine）3.2.6 Bridge DMA 3.3 可配置性 四. 软件设计4.1 编译工具：模型创建和编译4.2 Runtime环境：设备上模型推理 五. NVDLA 系统集成5.1 调整问题5.1.1 对于任何给定的瞬时所需的工作量，需要什么数学精度？5.1.2 MAC单位的数量和所需的内存带宽是多少？5.1.3 是否需要芯片上的SRAM？ 5.2 NVDLA的示例面积和性能5.3 示例平台5.3.1 仿真5.3.2 FPGA 5.4 模型5.4.1 Verilog 模型5.4.2 仿真模型和验证套件 5.5 软件 NVDLA入门 一. 概述 深度学习推理的大部分计算工作基于数学操作，这些操作主要可分为四个部分：卷积，激活，池化和归一化。这些操作具有一些特点，使其特别适合特殊用途的硬件实现，它们的内存访问模式非常可预测，并且很容易并行。NVIDIA深度学习加速器 （NVDLA） 项目促进了标准化、开放的架构，以满足推理的计算需求。NVDLA 架构既可扩展又高度可配置，模块化设计保持灵活性，简化集成。标准化深度学习加速可促进与大多数现代深度学习网络的互操作性，有助于机器学习的统一规模增长。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a78459abce2b8f89afe7165087fa2db9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-08T20:07:00+08:00" />
<meta property="article:modified_time" content="2021-07-08T20:07:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">NVDLA学习笔记（1）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="NVDLA1_0"></a>NVDLA学习笔记（1）</h2> 
<pre><code>作者：夏风喃喃
参考：http://nvdla.org/index.html
</code></pre> 
<p>NVIDIA 深度学习加速器 （NVDLA） 是一个免费和开放的架构，促进设计深度学习推理加速器的标准方法。NVDLA 采用模块化架构，可扩展、高度可配置，旨在简化集成性和便携性。硬件支持广泛的 IoT 设备。<br> </p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#NVDLA1_0" rel="nofollow">NVDLA学习笔记（1）</a></li><li><ul><li><a href="#NVDLA_5" rel="nofollow">NVDLA入门</a></li><li><ul><li><a href="#__6" rel="nofollow">一. 概述</a></li><li><a href="#__NVDLA__11" rel="nofollow">二. 使用 NVDLA 加速深度学习推理</a></li><li><ul><li><a href="#21__NVDLA__34" rel="nofollow">2.1 小 NVDLA 模型</a></li><li><a href="#22__NVDLA__40" rel="nofollow">2.2 大 NVDLA 模型</a></li></ul> 
    </li><li><a href="#__46" rel="nofollow">三. 硬件架构</a></li><li><ul><li><a href="#31__51" rel="nofollow">3.1 连接</a></li><li><a href="#32__58" rel="nofollow">3.2 组件</a></li><li><ul><li><a href="#321_Convolution_60" rel="nofollow">3.2.1 卷积（Convolution）</a></li><li><a href="#322_Single_Data_Point_Processor_66" rel="nofollow">3.2.2 单数据点处理器（Single Data Point Processor）</a></li><li><a href="#323_Planar_Data_Processor_70" rel="nofollow">3.2.3 平面数据处理器（Planar Data Processor）</a></li><li><a href="#324_Crosschannel_Data_Processor_74" rel="nofollow">3.2.4 跨通道数据处理器（Cross-channel Data Processor）</a></li><li><a href="#325_ReshapeData_Reshape_Engine_78" rel="nofollow">3.2.5 数据Reshape引擎（Data Reshape Engine）</a></li><li><a href="#326_Bridge_DMA_82" rel="nofollow">3.2.6 Bridge DMA</a></li></ul> 
     </li><li><a href="#33__84" rel="nofollow">3.3 可配置性</a></li></ul> 
    </li><li><a href="#__106" rel="nofollow">四. 软件设计</a></li><li><ul><li><a href="#41__109" rel="nofollow">4.1 编译工具：模型创建和编译</a></li><li><a href="#42_Runtime_113" rel="nofollow">4.2 Runtime环境：设备上模型推理</a></li></ul> 
    </li><li><a href="#_NVDLA__126" rel="nofollow">五. NVDLA 系统集成</a></li><li><ul><li><a href="#51__128" rel="nofollow">5.1 调整问题</a></li><li><ul><li><a href="#511__129" rel="nofollow">5.1.1 对于任何给定的瞬时所需的工作量，需要什么数学精度？</a></li><li><a href="#512_MAC_131" rel="nofollow">5.1.2 MAC单位的数量和所需的内存带宽是多少？</a></li><li><a href="#513_SRAM_137" rel="nofollow">5.1.3 是否需要芯片上的SRAM？</a></li></ul> 
     </li><li><a href="#52_NVDLA_139" rel="nofollow">5.2 NVDLA的示例面积和性能</a></li><li><a href="#53__144" rel="nofollow">5.3 示例平台</a></li><li><ul><li><a href="#531__146" rel="nofollow">5.3.1 仿真</a></li><li><a href="#532_FPGA_148" rel="nofollow">5.3.2 FPGA</a></li></ul> 
     </li><li><a href="#54__152" rel="nofollow">5.4 模型</a></li><li><ul><li><a href="#541_Verilog__154" rel="nofollow">5.4.1 Verilog 模型</a></li><li><a href="#542__158" rel="nofollow">5.4.2 仿真模型和验证套件</a></li></ul> 
     </li><li><a href="#55__162" rel="nofollow">5.5 软件</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="NVDLA_5"></a>NVDLA入门</h3> 
<h4><a id="__6"></a>一. 概述</h4> 
<p>深度学习推理的大部分计算工作基于数学操作，这些操作主要可分为四个部分：<mark>卷积，激活，池化和归一化</mark>。这些操作具有一些特点，使其特别适合特殊用途的硬件实现，它们的内存访问模式非常可预测，并且很容易并行。NVIDIA深度学习加速器 （NVDLA） 项目促进了标准化、开放的架构，以满足推理的计算需求。NVDLA 架构既可扩展又高度可配置，模块化设计保持灵活性，简化集成。标准化深度学习加速可促进与大多数现代深度学习网络的互操作性，有助于机器学习的统一规模增长。</p> 
<p>NVDLA 硬件提供简单、灵活、稳健的推理加速解决方案。它支持广泛的性能水平和易扩展的应用程序，从更小、对成本敏感的物联网 （IoT） 设备到面向性能的 IoT 设备。<mark>NVDLA 是一套基于开放行业标准的 IP 核心模型，Verilog 模型是 RTL 形式的综合和仿真模型，TLM SystemC 仿真模型可用于软件开发、系统集成和测试。</mark> NVDLA 软件生态系统包括设备内软件堆栈（开源发布的一部分）、构建包含深度学习的新模型的完整训练基础架构，以及将现有模型转换为设备上软件可用的形式的解析器。</p> 
<h4><a id="__NVDLA__11"></a>二. 使用 NVDLA 加速深度学习推理</h4> 
<p>NVDLA 引入了模块化架构，旨在简化配置、集成和便携性，它暴露了用于加速核心深度学习推理操作的构建基块。NVDLA 硬件由以下组件组成：</p> 
<ul><li>Convolution Core——优化的高性能<mark>卷积</mark>引擎。</li><li>Single Data Processor——用于<mark>激活</mark>功能的单点查找引擎。</li><li>Planar Data Processor——用于<mark>池化</mark>的平面平均引擎。</li><li>Channel Data Processor——用于高级<mark>归一化</mark>功能的多通道平均引擎。</li><li>Dedicated Memory and Data Reshape Engines——用于<mark>张量改变形状和复制</mark>操作的内存转换加速。</li></ul> 
<p><mark>每个块都是分离和独立配置的。</mark> 例如，无需池化的系统可以完全删除平面平均引擎；或者，需要额外卷积性能的系统可以在不修改加速器中其他单元的情况下，提高卷积单元的性能。每个单元的调度操作权下放给协处理器或CPU；它们在极其精细的调度边界上运行，每个单元独立运行。这种严格管理的调度要求可以作为 NVDLA 子系统的一部分，并添加专门的管理协处理器（"headed"实现），或者此功能可以与主系统处理器（"headless"实现）的更高级别的驱动程序实现融合。这使得相同的 NVDLA 硬件架构能够满足各种实现大小。</p> 
<p>NVDLA 硬件使用标准实践与系统其他部分进行<mark>接口</mark>：一个控制通道实现一个寄存器文件和中断接口，并使用一对标准 AXI 总线接口与内存连接。主内存接口旨在连接到系统的更宽的内存系统，包括系统 DRAM；此内存接口应与系统的 CPU 和 I/O 外设共享。第二个内存接口是可选的，并允许连接到高带宽内存，可以专用于 NVDLA 或计算机视觉子系统。此选项用于异构存储接口，可为在不同类型的主机系统之间扩展提供额外的灵活性。</p> 
<p>典型的<mark>推理流程</mark>始于 NVDLA 管理处理器（无论是"headed"实现中的微控制器，还是"headless"实现中的主CPU）发送一个硬件层的配置，然后发送"activate"命令。如果数据依赖性不排除这种情况，则可以将多个硬件层发送到不同的引擎并同时激活（即，如果存在另一个层，其输入不依赖于上一层的输出）。由于每个引擎的配置寄存器都有双缓冲，因此它还可以捕获第二层的配置，以便在激活层完成后立即开始处理。一旦硬件引擎完成激活任务后，将发送中断给管理处理器以报告完成，然后管理处理器将再次开始处理。这种命令——执行——中断流重复，直到整个网络上的推论完成。</p> 
<p>NVDLA 实现通常分为两类：</p> 
<ul><li>headless——NVDLA硬件的逐个单元管理发生在主系统处理器上。</li><li>headed——将高中断频率的任务委托给与NVDLA子系统紧密耦合的配套微控制器。</li></ul> 
<p>注意：NVDLA 的初始开源版本将只提供"headless"模式的软件解决方案，"headed"模式驱动程序将在稍后时间出现。</p> 
<p>图1中的小型系统模型（下图）显示了headless NVDLA 实现的示例，而大系统模型显示了headed实现。小型模型表示 NVDLA 实现，用于更具有成本敏感性的目的构建设备。大型系统模型的特点是增加了专用控制协处理器和高带宽 SRAM 以支持 NVDLA 子系统。大型系统模型更面向高性能的 IoT 设备，这些设备可以同时执行许多任务。<br> <img src="https://images2.imgbox.com/2a/e1/mrtxF0hU_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="21__NVDLA__34"></a>2.1 小 NVDLA 模型</h5> 
<p>小型 NVDLA 模型在以前不可行的领域开辟了深度学习技术。此模型非常适合对<mark>成本敏感</mark>的互联物联网 （IoT） 类设备、AI 和自动化导向系统，这些系统具有明确的任务，其中成本、面积和功耗是主要驱动因素。节省（在成本、面积和功耗方面）是通过 NVDLA 可配置资源实现的。神经网络模型可进行预先编译和性能优化，使较大的模型能够"消减"并降低负载复杂性；这反过来又使 NVDLA 实现缩小，其中模型消耗更少的存储空间，并且系统软件加载和处理的时间更少。</p> 
<p>这些专用系统通常一次只执行一项任务，因此，在 NVDLA 运行期间牺牲系统性能通常不是一个重要问题。与这些系统相关的相对便宜的上下文切换机（有时是由于处理器架构选择的结果，有时是由于使用 FreeRTOS 等系统进行任务管理）导致主处理器不会因为服务大量 NVDLA 中断而承受过重的负担。这消除了对额外微控制器的需求，<mark>主处理器同时执行粗粒式调度和内存分配，以及细粒式的 NVDLA 管理。</mark></p> 
<p>通常，遵循小型 NVDLA 模型的系统将<mark>不包括可选的第二个内存接口</mark>。当整体系统性能不那么重要时，没有高速存储路径的影响不太可能是至关重要的。在此类系统中，系统内存（通常是 DRAM）的耗电量可能低于 SRAM，因此使用系统内存作为计算缓存的功效更高。</p> 
<h5><a id="22__NVDLA__40"></a>2.2 大 NVDLA 模型</h5> 
<p>当主要强调高性能和多功能性时，大型 NVDLA 模型是更好的选择。面向性能的物联网系统可以在许多不同的网络拓扑中执行推理；因此，这些系统必须保持高度的灵活性。此外，这些系统可能同时执行许多任务，而不是序列化推理操作，因此推理操作不得消耗主机上太多的处理能力。为了满足这些需求，NVDLA 硬件包括用于专用高带宽 SRAM 的第二个（可选）内存接口，并能够与专用控制协处理器（微控制器）连接，以限制主处理器上的中断负载。</p> 
<p>在实现时，NVDLA 上<mark>高带宽 SRAM</mark> 连接到快速内存总线接口的端口。此 SRAM 被 NVDLA 用作缓存；可选地，它可以由系统上其他高性能计算机视觉相关组件共享，以进一步减少主系统内存（Sys DRAM）的流量。</p> 
<p>NVDLA <mark>协处理器</mark>的要求相当典型；因此，有许多通用处理器是适当的（例如，基于 RISC-V 的 PicoRV32 处理器、ARM Cortex-M 或Cortex-R 处理器，甚至内部微控制器设计）。使用专用协处理器时，主处理器仍处理与管理 NVDLA 相关的某些任务。例如，虽然<mark>协处理器负责 NVDLA 硬件的调度和细粒度编程，但主机仍将负责 NVDLA 硬件上的粗粒度调度、NVDLA 内存访问 IOMMU 映射（必要时）、NVDLA 输入数据和固定权重阵列的内存分配以及 NVDLA 上运行的其他系统组件和任务之间的同步。</mark></p> 
<h4><a id="__46"></a>三. 硬件架构</h4> 
<p>NVDLA 架构可以两种操作模式进行编程： independent mode和fused mode。</p> 
<ul><li><strong>Independent.</strong> 独立操作时，每个功能块都配置为执行时间和内容，每个块都执行其分配的任务（类似于深度学习框架中的独立层）。独立操作的开始和结束伴随着分配的块执行内存到内存操作，进出主系统内存或专用 SRAM 内存。</li><li><strong>Fused.</strong> 融合操作类似于独立操作，但是，某些块可以组装为管道。这可以通过绕过内存往返来提高性能，而是让块通过小型 FIFO 相互通信（即卷积内核可以将数据传递给Single Data Point Processor(SDP)，该处理器可以将数据传递给Planar Data Processor(PDP)，然后传递给Cross-channel Data Processor(CDP)）。<br> <img src="https://images2.imgbox.com/08/14/4WVcXLKY_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="31__51"></a>3.1 连接</h5> 
<p>NVDLA 与系统的其他部分实现了三个主要连接：</p> 
<ul><li><strong>Configuration Space Bus (CSB) interface.</strong> 此接口是一个同步、低带宽、低功耗、32 位控制总线，设计用于 CPU 访问 NVDLA 配置寄存器。NVDLA 在 CSB 接口中充当从设备。CSB 实现了非常简单的接口协议，因此可以轻松地将其转换为 AMBA、OCP 或具有简单垫片层的任何其他系统总线。</li><li><strong>Interrupt interface.</strong> NVDLA 硬件包括 1 位级别驱动中断。当任务完成或发生错误时，中断线被断言。</li><li><strong>Data Backbone (DBB) interface.</strong> DBB 接口连接 NVDLA 和主系统内存子系统。它是一个同步、高速和高度可配置的数据总线。可以指定它具有不同的地址大小、不同的数据大小，并根据系统的要求发出不同大小的请求。数据骨干接口是一个简单的接口协议，类似于 AXI（并且可在符合 AXI 的系统中轻松使用）。</li></ul> 
<p>DBB 界面具有可选的第二个连接，当有第二个内存路径可用时，可以使用该连接。此连接在设计上与主 DBB 接口相同，并用于芯片上 SRAM，可提供更高的吞吐量和更低的访问延迟。NVDLA 无需第二个 DBB 接口即可正常工作，不需要此内存接口的系统可以通过删除该接口来节省面积。</p> 
<h5><a id="32__58"></a>3.2 组件</h5> 
<p>NVDLA 架构中的每个组件都存在，以支持深度神经网络推理中不可或缺的特定操作。以下描述提供了每个块的简要功能概述，包括映射到它们上的 TensorFlow 操作。虽然 TensorFlow 操作是作为示例提供的，但 NVDLA 硬件支持其他深度学习框架。</p> 
<h6><a id="321_Convolution_60"></a>3.2.1 卷积（Convolution）</h6> 
<p>卷积操作适用于两组数据：一组离线训练的"权重"（每次推理之间保持不变），另一组输入"特征"数据（随网络输入而变化）。卷积引擎将参数暴露在高效率的硬件上，以映射许多不同大小的卷积。NVDLA 卷积引擎包括优化，以改善性能，而不是天真的卷积实现。<mark>支持稀疏的权重压缩</mark>可节省内存带宽。内置的 <mark>Winograd 卷积</mark>支持可提高某些尺寸过滤器的计算效率。<mark>批次卷积</mark>，可在并行运行多个推理时重复使用权重来节省额外的内存带宽。</p> 
<p>为了避免重复访问系统内存，NVDLA 卷积引擎具有内部 RAM，用于权重和输入特征存储，称为 <mark>“卷积缓冲器”</mark>。此设计大大提高了内存效率，而不是在需要权重或特征的每个独立时间向系统内存控制器发送请求。</p> 
<p>卷积单元映射到 TensorFlow 操作，如 <code>.tf.nn.conv2d</code></p> 
<h6><a id="322_Single_Data_Point_Processor_66"></a>3.2.2 单数据点处理器（Single Data Point Processor）</h6> 
<p>单数据点处理器 （SDP） 允许将<mark>线性和非线性函数应用于单个数据点</mark>。这在 CNN 系统中卷积后通常立即使用。SDP 有一个<mark>查找表</mark>来实现非线性功能，或者对于线性函数，它<mark>支持简单的偏置和缩放</mark>。此组合可以支持最常见的激活函数，以及其他元素操作，包括 ReLU、PReLU、精密缩放、批次归一化、偏置添加或其他复杂的非线性函数，如sigmoid或tanh函数。</p> 
<p>SDP 映射到TensorFlow操作，包括<code>tf.nn.batch_normalization</code> ，<code>tf.nn.bias_add</code>，<code>tf.nn.elu</code>，<code>tf.nn.relu</code>，<code>tf.sigmoid</code>，<code>tf.tanh</code>等等。</p> 
<h6><a id="323_Planar_Data_Processor_70"></a>3.2.3 平面数据处理器（Planar Data Processor）</h6> 
<p>平面数据处理器 （PDP） 支持 CNN 应用程序中常见的特定空间操作。它可以在运行时配置以<mark>支持不同的池化组大小</mark>，并支持三个池化函数：最大池化、最小池化和平均池化。</p> 
<p>PDP 映射到<code>tf.nn.avg_pool</code>, <code>tf.nn.max_pool</code>和<code>tf.nn.pool</code>操作。</p> 
<h6><a id="324_Crosschannel_Data_Processor_74"></a>3.2.4 跨通道数据处理器（Cross-channel Data Processor）</h6> 
<p>跨通道数据处理器 （CDP） 是一个专门单元，旨在<mark>应用局部响应归一化 （LRN） 函数</mark> —— 一种在通道维度上运行的特殊归一化函数，而不是空间维度。</p> 
<p>CDP 映射到函数<code>tf.nn.local_response_normalization</code>。</p> 
<h6><a id="325_ReshapeData_Reshape_Engine_78"></a>3.2.5 数据Reshape引擎（Data Reshape Engine）</h6> 
<p>数据Reshape引擎执行<mark>数据格式转换</mark>（例如，拆分或切片、合并、收缩、变形-转置）。在卷积网络上执行推理的过程中，通常需要重新配置或重新变形内存中的数据。例如，"切片"操作可用于分离图像的不同特征或空间区域，"变形-转置"操作（在反卷积网络中常见）创建的输出数据的尺寸大于输入数据集。</p> 
<p>数据Reshape引擎映射到 TensorFlow 操作上，例如<code>tf.nn.conv2d_transpose</code>, <code>tf.concat</code>, <code>tf.slice</code>和<code>tf.transpose</code>。</p> 
<h6><a id="326_Bridge_DMA_82"></a>3.2.6 Bridge DMA</h6> 
<p>Bridge DMA （BDMA） 模块提供<mark>数据复制</mark>引擎，用于在<mark>系统 DRAM 和专用高性能内存接口之间移动数据</mark>；这是一个加速路径，以在这两个否则非连接的内存系统间移动数据。</p> 
<h5><a id="33__84"></a>3.3 可配置性</h5> 
<p>NVDLA 具有广泛的硬件参数，可配置以平衡面积、功耗和性能。以下是这些选项的简短列表。</p> 
<ul><li><strong>数据类型</strong>。NVDLA 原生地支持其各种功能单元的各种数据类型；可以选择其中的一个子集来节约面积。可以选择的数据类型包括二进制，int4，int8，int16，int32，fp16，fp32和fp64。</li><li><strong>输入图像内存格式</strong>。NVDLA 可以支持平面图像、半平面图像或其他包装内存格式。这些不同的模式可以启用或禁用以节约面积。</li><li><strong>权重压缩</strong>。NVDLA 具有通过稀疏存储卷积重量来减少内存带宽的机制。此功能可以禁用以节约面积。</li><li><strong>Winograd 卷积</strong>。Winograd算法是某些维度卷积的优化。NVDLA 在支持或不支持其的情况下均可构建。</li><li><strong>批次卷积</strong>。分批是一种节省内存带宽的功能。NVDLA 可以在支持或不支持的情况下构建。</li><li><strong>卷积缓冲器大小</strong>。卷积缓冲是由许多banks组成的。可以调整banks数量（从2个到32个）和每家bank的规模（从4个KiB到8个KiB）。（通过将这些存储器相乘，可以确定瞬时的卷积缓冲存储器的总量。</li><li><strong>MAC 阵列大小</strong>。乘累加引擎由两个维度组成。宽度（"C"维度）可从 8 调整到 64，深度（"K"维）可从 4 调整到 64。（创建的乘累加总数可以通过将这两个乘在一起来确定。）</li><li><strong>第二个内存接口</strong>。NVDLA 可以支持用于高速访问的第二个内存接口，也可以仅使用一个内存接口构建。</li><li><strong>非线性激活函数</strong>。为了节省面积，可以删除支持非线性激活函数（如sigmoid或 tanh）的查找表。</li><li><strong>激活引擎机尺寸</strong>。每个周期产生的激活输出数可以从 1 调整到 16。</li><li><strong>Bridge DMA 引擎</strong>。Bridge DMA 引擎可以去掉以节省面积。</li><li><strong>数据整形引擎</strong>。可以删除数据整形引擎以节省面积。</li><li><strong>池化引擎存在</strong>。可以去除池化引擎以节省面积。</li><li><strong>池化引擎尺寸</strong>。池发引擎可进行调整，以产生每个周期 1 到 4 个输出。</li><li><strong>局部响应归一化引擎存在</strong>。可以去除局部响应归一化引擎以节省面积。</li><li><strong>局部响应归一化引擎尺寸</strong>。局部响应归一化引擎可进行调整，以产生每个周期 1 到 4 个输出。</li><li><strong>内存接口位宽度</strong>。内存接口位宽度可根据外部存储接口的宽度调整至适当大小的内部缓冲。</li><li><strong>内存读取延迟容限</strong>。内存延迟时间定义为从读取请求到读取数据返回的周期数。可以调整此的容限，这会影响每个读取 DMA 引擎的内部延迟缓冲器大小。</li></ul> 
<h4><a id="__106"></a>四. 软件设计</h4> 
<p>NVDLA 拥有完整的软件生态系统来支持它。此生态系统的一部分包括设备上软件堆栈，这是 NVDLA 开源释放的一部分；此外，NVIDIA 将提供完整的训练基础架构，以构建包含深度学习的新模型，并将现有模型转换为 NVDLA 软件可用的形式。一般来说，<mark>与 NVDLA 相关的软件分为两组：编译工具（模型转换）和runtime环境（在 NVDLA 上加载和执行网络的run-time软件）</mark>。这些的总体流程如下图所示；下面描述它们中的每一个。<br> <img src="https://images2.imgbox.com/99/93/7vE4WKGC_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="41__109"></a>4.1 编译工具：模型创建和编译</h5> 
<p><mark>编译工具包括编译器和解析器</mark>。编译器负责创建一系列硬件层，这些层针对给定的 NVDLA 配置进行优化；拥有优化的硬件层网络通过减少模型大小、负载和运行时间来提高性能。编译是一个分门别类的多步骤过程，可分为两个基本组件：解析和编译。<mark>解析器</mark>可以相对简单；在其最基本的体现中，它可以读取预先训练的Caffe模型，并<mark>创建网络的"中间表示"</mark>，以传递到编译的下一步。<mark>编译器</mark>将 NVDLA 实现的解析中间表示和硬件配置作为输入，并<mark>生成硬件层网络</mark>。这些步骤是离线执行的，并可能在包含 NVDLA 实现的设备上执行。</p> 
<p>了解 NVDLA 实现的特定硬件配置非常重要，它使编译器能够为可用的特征生成适当的层。例如，这可能包括在不同的卷积操作模式（如 Winograd 卷积或基本卷积）之间进行选择，或根据可用的卷积缓冲大小将卷积操作拆分为多个较小的小型操作。此阶段还负责量化模型以降低精度，如 8 位或 16 位整数或 16 位浮点，并分配用于权重的内存区域。同一编译工具可用于生成多个不同 NVDLA 配置的操作列表。</p> 
<h5><a id="42_Runtime_113"></a>4.2 Runtime环境：设备上模型推理</h5> 
<p>Runtime环境涉及在兼容的 NVDLA 硬件上运行模型。它实际上分为两层：</p> 
<ul><li><strong>用户模式驱动（UMD）</strong>。用户模式程序的主要接口。分析神经网络后，编译器逐层编译网络，并将其转换为称为 “NVDLA Loadable” 的文件格式。用户模式runtime驱动加载此loadable，并将推理工作提交给“内核模式驱动”。</li><li><strong>内核模式驱动（KMD）</strong>。由驱动和固件组成，这些驱动和固件可执行 NVDLA 上调度层操作的工作，并编程 NVDLA 寄存器以配置每个功能块。</li></ul> 
<p><mark>Runtime执行</mark>从存储的网络表示开始；此存储格式称为 “NVDLA loadable” 图像。在loadable的视图中，NVDLA 实现中的每个功能块都由软件中的 “层” 表示；每一层都包含有关其依赖性的信息、它用作输入和输出的内存中的张量以及每个块用于操作的特定配置。层通过依赖性图连接在一起，内核模式驱动（KMD）用于安排每次操作。NVDLA loadable格式在编译器实现和用户模式驱动（UMD）实现中实现标准化。所有符合 NVDLA 标准的实现至少应该能够理解任何 NVDLA loadable图像，即使实现可能没有使用该loadable图像运行推理所需的某些特征。</p> 
<p><mark>UMD</mark> 具有标准的应用程序编程接口 （API），用于处理可加载图像、将输入和输出张量绑定到内存位置以及运行推理。此层以一组定义的数据结构将网络加载到内存中，并以实现定义的方式将其传递给 KMD。例如，在 Linux 上，这可能是一个<code>ioctl()</code>，将数据从用户模式驱动传递到内核模式驱动；在 KMD 运行在与 UMD 相同环境的单一处理系统中，这可能是一个简单的函数调用。</p> 
<p><mark>KMD</mark> 的主要切入点在内存中接收推理工作，从多个可用工作中选择用于调度（如果在多处理系统上），并将其提交给核心引擎调度器。此核心引擎调度器负责处理 NVDLA 中断、每个函数块上的调度层以及根据上一层任务的完成更新该层的任何依赖关系。调度程序使用依赖性图中的信息来确定后续层何时准备被调度；这允许编译器以优化的方式决定层的调度，并避免不同的KMD实现的性能差异。<br> <img src="https://images2.imgbox.com/90/0c/rxRVlcPt_o.png" alt="在这里插入图片描述"><br> <mark>UMD 堆栈和 KMD 堆栈</mark>都以定义的 API 存在，并且预计将用系统可移植性层包裹。在可移植性层中保持核心实现预计需要的更改相对较少，并在可能需要多个平台上运行 NVDLA 软件堆栈时加快任何努力；在适当的可移植性层到位后，在 Linux 和 FreeRTOS 上应容易编译相同的核心实现。同样，在具有与 NVDLA 紧密耦合的微控制器的 “headed” 实现上，便携式层的存在使得在微控制器上与在没有此类配套处理器的 “headless” 实现中在主 CPU 上运行相同的低级软件成为可能。</p> 
<h4><a id="_NVDLA__126"></a>五. NVDLA 系统集成</h4> 
<p><mark>NVDLA 可配置为各种性能级别；选择这些参数取决于将要执行的卷积神经网络 （CNN） 的要求。</mark> 本节描述了影响这些参数选择的一些因素，以及它们对系统面积和性能影响的一些考虑。运行每一层所需的时间是数据输入、输出以及执行乘累加（MAC） 操作所需的最大时间量。运行整个网络所需的时间等于所有层的总和。选择正确的 MAC 单元数、卷积缓冲器大小和片上 SRAM 大小以达到所需的性能是调整尺寸的最关键步骤。NVDLA 有更多的配置参数用于额外的性能调整，需要仔细考虑，这些参数对总面积的影响较小；它们不应该被配置为出现不必要的瓶颈。</p> 
<h5><a id="51__128"></a>5.1 调整问题</h5> 
<h6><a id="511__129"></a>5.1.1 对于任何给定的瞬时所需的工作量，需要什么数学精度？</h6> 
<p>较大配置中的 NVDLA 面积的大部分由卷积缓冲器和 MAC 单元使用，因此有理由认为这些参数在初始性能/面积权衡分析中是最重要的。深度学习培训通常以 32 位浮点精度进行，但由此产生的<mark>网络通常可简化为 8 位整型</mark>，而不会显著降低推理质量；然而，在某些情况下，使用 16 位整型或浮点数可能仍可取。</p> 
<h6><a id="512_MAC_131"></a>5.1.2 MAC单位的数量和所需的内存带宽是多少？</h6> 
<p>精度之后，性能和面积的下两个关键参数是 MAC 单位的数量和所需的内存带宽。在配置 NVDLA 时，应仔细考虑这些问题。处理是逐层进行的，因此最佳性能估计也是逐层完成的。对于任何给定层，MAC 吞吐量或内存带宽通常是瓶颈。</p> 
<p>所需的 MAC 单位数量相对容易确定。例如，<mark>卷积层具有已知的输入和输出分辨率，以及已知的输入和输出特征；卷积内核大小也已知。将这些操作相乘，可提供处理该层的 MAC 操作总数。</mark> 硬件可以定义为具有一定数量的 MAC 单元；除以 MAC 单元数量所需的操作次数，给出了一层可处理的时钟周期数的下界。</p> 
<p>计算所需的内存带宽就不那么琐碎了。在理想情况下，只需要读取输入图像一次，输出图像一次，权重一次，<mark>周期的最小数将按每个时钟可读取或书写的样本数除以这些周期的总和。</mark> 但是，如果卷积缓冲区太小，无法容纳输入和权重集的支持区域，则需要多次通过。例如，如果卷积缓冲区只能容纳四分之一的权重数据，则计算必须分为四个步骤，将输入带宽相乘（即 10MB 的输入内存流量将相乘得到 40MB）。同样，如果缓冲区不能容纳足够的线，用于卷积的支持区域，则卷积也必须分解成水平条。在选择卷积缓冲器大小和调整内存接口大小时，此效应是重要的必须加以考虑。</p> 
<h6><a id="513_SRAM_137"></a>5.1.3 是否需要芯片上的SRAM？</h6> 
<p><mark>如果出于电源或性能原因，外部内存带宽处于价格更高的状态，则添加片上 SRAM 会有所帮助。</mark> 这种 SRAM 可视为二级缓存；它的带宽比主内存高，其带宽是主内存带宽的加倍。芯片上的 SRAM 比更大的卷积缓冲器便宜，后者需要宽端口，并且具有非常严格的计时要求，但在限制卷积缓冲的应用程序中，没有那么大的乘数倍数。（例如，如果一个层的带宽有限，添加一个 SRAM 足以保持整个输入图像，其运行速度是系统 DRAM 速度的两倍，则其性能可以翻倍。但是，如果该层也受到卷积缓冲器大小的限制，则相同数量的内存可能会对系统吞吐量产生更大的乘数。考虑这种权衡的最简单方法是，增加卷积缓冲器大小将有助于减少带宽要求，同时添加片上 SRAM 可以改善可用总带宽。</p> 
<h5><a id="52_NVDLA_139"></a>5.2 NVDLA的示例面积和性能</h5> 
<p><mark>下表提供了为流行的 ResNet-50 神经网络优化的 NVDLA 配置的估计值。</mark> 给出的面积数值是估计的综合面积，包括所需的所有内存；实际面积结果将因代工厂和工艺库而异。在此示例中，不使用片上 SRAM。如果可用的 SDRAM 带宽较低，则片上 SRAM 将是有益的。NVDLA 的开源版本具有性能估算工具，可用于探索 NVDLA 设计的空间以及对性能的影响。</p> 
<p>以下表中的功耗和性能显示为 1GHz 频率。通过调整电压和频率，给定配置的功耗和性能可能会有所不同。<br> <img src="https://images2.imgbox.com/16/53/Gm8s35DF_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="53__144"></a>5.3 示例平台</h5> 
<p>提供示例平台，允许用户在<mark>小型的 SoC 环境中观察、评估和测试 NVDLA。最低 SoC 系统配置包括 CPU、NVDLA 实例、互连和存储器。</mark> 这些平台可用于软件开发，或作为将 NVDLA 集成到工业实力雄厚的 SoC 的起点。</p> 
<h6><a id="531__146"></a>5.3.1 仿真</h6> 
<p><mark>NVDLA 开源版本包括一个基于GreenSocs QBox 的仿真平台。</mark> 在此平台中，QEMU CPU 模型 （x86 或 ARMv8） 与 NVDLA SystemC 模型相结合，提供一个寄存器精度系统，可以快速开发和调试软件。提供 Linux 内核模式驱动和用户模式测试实用程序，以便在此仿真平台上运行。</p> 
<h6><a id="532_FPGA_148"></a>5.3.2 FPGA</h6> 
<p><mark>此示例平台将 NVDLA Verilog 模型映射到 FPGA 上，它提供了一个可综合的在真实设计中例化 NVDLA 的示例。</mark> 在此平台中，不使用 NVDLA SystemC 模型，软件寄存器直接在真实的 RTL 环境中进行读取和写入执行。这允许有限的循环计数性能评估，也允许针对更大、更复杂的网络更快地测试软件。FPGA 模型仅用于验证，没有努力优化 FPGA 平台的周期时间、设计尺寸或功耗，FPGA 模型的性能无法与其他基于 FPGA 的深度学习加速器直接相比。</p> 
<p>FPGA 系统模型使用Amazon EC2 “F1” 环境，这是一个公开可用的标准化 FPGA 系统，可按小时租赁。使用这种模式不需要预先购买专门的硬件或软件；综合软件仅在Amazon EC2环境下以计算时间的成本提供，硬件无需承诺即可访问。由于 FPGA 平台基于 Xilinx，因此迁移到其他 Virtex 系列设备应该相对简单。</p> 
<h5><a id="54__152"></a>5.4 模型</h5> 
<p>NVDLA IP 核心模型基于开放的行业标准。基础构造的简单化设计和使用有望轻松融入典型的 SoC 设计流程中。</p> 
<h6><a id="541_Verilog__154"></a>5.4.1 Verilog 模型</h6> 
<p><mark>Verilog 模型以 RTL 形式提供综合和仿真模型。它有四个功能接口：一个从主接口、一条中断线路和两个主接口，用于内部和外部存储器访问。</mark> 主机和内存接口非常简单，但需要外部总线适配器连接到现有的 SoC 设计；为方便起见，AXI4 和 TileLink 的样本适配器包含在 NVDLA 开源版本中。NVDLA 开源版本包含示例综合脚本。为了便于在更复杂的系统或更大的 NVDLA 例化进行物理设计，该设计被拆分为分区，每个分区都可以在 SoC 后端流程中独立处理。分区之间的接口可以根据需要重定时，以满足路由要求。</p> 
<p><mark>NVDLA 核心在单个时钟域内运行</mark>；总线适配器允许时钟域从内部 NVDLA 时钟交叉到总线时钟。同样，<mark>NVDLA 也在单一电源域内运行</mark>；该设计同时适用于细粒和粗粒功耗门控。如果添加到实现中，SRAM 将以行为模型为建模，并且必须在完整的 SoC 设计中由编译的 RAM 替换。NVDLA 设计要求实现单端口和双端口（一读端口加一写端口）SRAM。</p> 
<h6><a id="542__158"></a>5.4.2 仿真模型和验证套件</h6> 
<p><mark>NVDLA 包括用于软件开发、系统集成和测试的 TLM2 SystemC 仿真模型。</mark> 这种模型能够实现比将RTL与信号激励模型结合起来运行更快的仿真。此 SystemC 模型用于全 SoC 仿真环境，如 Synopsys VDK 或提供的 GreenSocs QBox 平台。包括的模型可在与RTL模型相同的轴上进行参数化，以便直接比较和模拟。</p> 
<p><mark>仿真模型还可用于 NVDLA testbench和验证套件。</mark> 基于轻量级trace-player的测试平台适用于简单的综合和构建可靠验证（这将在初始NVDLA版本中提供）。在后续版本中，将会提供一个完整的验证环境，并对每个单元进行广泛的测试。验证套件可用于在流片前提供设计保证，包括验证编译后的RAMs、时钟门控和扫描链插入的更改。这种环境将适合进行更实质性的更改（例如，验证新的NVDLA配置或对现有NVDLA设计的修改）。</p> 
<h5><a id="55__162"></a>5.5 软件</h5> 
<p><mark>最初的 NVDLA 开源版本包括用于 “headless” 实现的软件，与 Linux 兼容。</mark> 内核模式驱动和用户模式测试实用程序均以源形式提供，并且可以在未经修改的 Linux 系统之上运行。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c227327fdb6f1ea650bc01f0de132fc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Constructor：构造器，this 关键字,static:静态的,block 块,debug 调试工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/04934af5cd4070c28787bfe6b586baf1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">查找算法汇总—手撕代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>