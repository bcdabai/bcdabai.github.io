<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>哈夫曼编码的实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="哈夫曼编码的实现" />
<meta property="og:description" content="哈夫曼编码 一.关于哈弗曼编码的个人理解二.问题的提出三.哈夫曼编码的实现原理四.哈夫曼树的存储结构五.哈夫曼树如何构造1.统计文本中字符出现的频率2.对入队列的节点进行排序处理3.哈夫曼树的两种构造方法 六.哈夫曼编码的生成(压缩编码长度)1.利用哈夫曼树生成对应的密钥字典2.根据密钥字典进行字符串的压缩3.利用密钥字典中的编码对字符串进行解密 七.测试结果 一.关于哈弗曼编码的个人理解 在数据传输过程中，数据都是由很多字符构成，每个字符又都是由二进制数构成，如果给每个字符确定且定长的编码，那么在数据传输过程中，数据量就会很大，如何使数据量变小呢？
可以通过观察得到，在我们人类的所使用的语言中，总是有那么几个字符的应用频率大于其他字符的使用频率，所以我们可以通过将这些使用频率很高的字符通过缩短其二进制编码的长度，来进行数据量的压缩。
哈夫曼树就是一种很好的解决方式，哈夫曼树可以根据我们规定的权值，对字符进行排列组合，生成一颗哈夫曼树，而在这个树中，每个字符所生成的编码都是独一无二的，不会产生二义性，当对压缩后的数据进行解密时，不会因为字符编码出现二义性，不仅减小了数据量，并且保证压缩之后的数据的准确性。
二.问题的提出 如何统计给定的一篇文本中，每个字符出现的频率。使用什么样的结构可以完成哈夫曼树权值最小子树的挑选。如何对输入的数据进行压缩处理。 以上问题将会在下文进行解释。
三.哈夫曼编码的实现原理 哈夫曼编码的实现需要通过构造哈夫曼树，通过遍历哈夫曼的子树来确定每个字符的编码。在构建哈夫曼树时，需要取出权值最小的两颗子树，可以利用队列从队头取元素的特性，将树节点按照权值由小到大的存储在队列中，在构造哈夫曼树时，从队头取出两个权值最小的子树进行哈夫曼树的构造，并将构造好的子树继续根据权值大小放入队列中，用于下一次构造，直至队列为空。为节点生成哈夫曼编码，生成时，利用前序遍历的方式，将每个节点走过的路径记录下来，并且将路径生成的字符串进行存储。压缩后的编码如何解密，我们可以知道，哈夫曼编码是没有二义性的，就可以利用生成的编码顺序对比压缩的编码，一位一位进行解密。
四.哈夫曼树的存储结构 为了利用队列的特性，使用队列节点嵌套二叉树节点的方式，进行存储。
// 哈夫曼树节点 struct BiTreeNode { ElemType data; int weight; BiTreeNode* lchild; BiTreeNode* rchild; }; // 队列节点 struct SqQueueNode { BiTreeNode* btNode; SqQueueNode* next; }; struct SqQueueLink { SqQueueNode* front; SqQueueNode* rear; }; // 密钥表结构 struct EncTable { char ch; char table[256]; }; 五.哈夫曼树如何构造 1.统计文本中字符出现的频率 string str = &#34;this is a test string&#34;;	// 示例字符串 int priority[ACSII_LEN] = { 0 };	// 确定优先级，记录ACSII表所有字符出现的次数 // 记录str中每个字符出现的次数（将字符转为acsII进行记录） for (int i = 0; i &lt; str." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d63e979387b565a5e1a3191c816bf86e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-02T16:02:19+08:00" />
<meta property="article:modified_time" content="2021-04-02T16:02:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">哈夫曼编码的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>哈夫曼编码</h4> 
 <ul><li><a href="#_1" rel="nofollow">一.关于哈弗曼编码的个人理解</a></li><li><a href="#_7" rel="nofollow">二.问题的提出</a></li><li><a href="#_15" rel="nofollow">三.哈夫曼编码的实现原理</a></li><li><a href="#_21" rel="nofollow">四.哈夫曼树的存储结构</a></li><li><a href="#_54" rel="nofollow">五.哈夫曼树如何构造</a></li><li><ul><li><a href="#1_55" rel="nofollow">1.统计文本中字符出现的频率</a></li><li><a href="#2_77" rel="nofollow">2.对入队列的节点进行排序处理</a></li><li><a href="#3_136" rel="nofollow">3.哈夫曼树的两种构造方法</a></li></ul> 
  </li><li><a href="#_248" rel="nofollow">六.哈夫曼编码的生成(压缩编码长度)</a></li><li><ul><li><a href="#1_249" rel="nofollow">1.利用哈夫曼树生成对应的密钥字典</a></li><li><a href="#2_279" rel="nofollow">2.根据密钥字典进行字符串的压缩</a></li><li><a href="#3_304" rel="nofollow">3.利用密钥字典中的编码对字符串进行解密</a></li></ul> 
  </li><li><a href="#_346" rel="nofollow">七.测试结果</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一.关于哈弗曼编码的个人理解</h2> 
<p>       在数据传输过程中，数据都是由很多字符构成，每个字符又都是由二进制数构成，如果给每个字符确定且定长的编码，那么在数据传输过程中，数据量就会很大，如何使数据量变小呢？<br>        可以通过观察得到，在我们人类的所使用的语言中，总是有那么几个字符的应用频率大于其他字符的使用频率，所以我们可以通过将这些使用频率很高的字符通过缩短其二进制编码的长度，来进行数据量的压缩。<br>        哈夫曼树就是一种很好的解决方式，哈夫曼树可以根据我们规定的权值，对字符进行排列组合，生成一颗哈夫曼树，而在这个树中，每个字符所生成的编码都是独一无二的，不会产生二义性，当对压缩后的数据进行解密时，不会因为字符编码出现二义性，不仅减小了数据量，并且保证压缩之后的数据的准确性。<br> <br></p> 
<h2><a id="_7"></a>二.问题的提出</h2> 
<ol><li>如何统计给定的一篇文本中，每个字符出现的频率。</li><li>使用什么样的结构可以完成哈夫曼树权值最小子树的挑选。</li><li>如何对输入的数据进行压缩处理。</li></ol> 
<p>以上问题将会在下文进行解释。<br> <br></p> 
<h2><a id="_15"></a>三.哈夫曼编码的实现原理</h2> 
<ol><li>哈夫曼编码的实现需要通过构造哈夫曼树，通过遍历哈夫曼的子树来确定每个字符的编码。</li><li>在构建哈夫曼树时，需要取出权值最小的两颗子树，可以利用队列从队头取元素的特性，将树节点按照权值由小到大的存储在队列中，在构造哈夫曼树时，从队头取出两个权值最小的子树进行哈夫曼树的构造，并将构造好的子树继续根据权值大小放入队列中，用于下一次构造，直至队列为空。</li><li>为节点生成哈夫曼编码，生成时，利用前序遍历的方式，将每个节点走过的路径记录下来，并且将路径生成的字符串进行存储。</li><li>压缩后的编码如何解密，我们可以知道，哈夫曼编码是没有二义性的，就可以利用生成的编码顺序对比压缩的编码，一位一位进行解密。<br> <br></li></ol> 
<h2><a id="_21"></a>四.哈夫曼树的存储结构</h2> 
<p>为了利用队列的特性，使用队列节点嵌套二叉树节点的方式，进行存储。</p> 
<pre><code class="prism language-c"><span class="token comment">// 哈夫曼树节点</span>
<span class="token keyword">struct</span> BiTreeNode
<span class="token punctuation">{<!-- --></span>
	ElemType data<span class="token punctuation">;</span>
	<span class="token keyword">int</span> weight<span class="token punctuation">;</span>
	BiTreeNode<span class="token operator">*</span> lchild<span class="token punctuation">;</span>
	BiTreeNode<span class="token operator">*</span> rchild<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 队列节点</span>
<span class="token keyword">struct</span> SqQueueNode
<span class="token punctuation">{<!-- --></span>
	BiTreeNode<span class="token operator">*</span> btNode<span class="token punctuation">;</span>
	SqQueueNode<span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> SqQueueLink
<span class="token punctuation">{<!-- --></span>
	SqQueueNode<span class="token operator">*</span> front<span class="token punctuation">;</span>
	SqQueueNode<span class="token operator">*</span> rear<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 密钥表结构</span>
<span class="token keyword">struct</span> EncTable
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> ch<span class="token punctuation">;</span>
	<span class="token keyword">char</span> table<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h2><a id="_54"></a>五.哈夫曼树如何构造</h2> 
<h3><a id="1_55"></a>1.统计文本中字符出现的频率</h3> 
<pre><code class="prism language-c">	string str <span class="token operator">=</span> <span class="token string">"this is a test string"</span><span class="token punctuation">;</span>		<span class="token comment">// 示例字符串</span>
	<span class="token keyword">int</span> priority<span class="token punctuation">[</span>ACSII_LEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>		<span class="token comment">// 确定优先级，记录ACSII表所有字符出现的次数 </span>

	<span class="token comment">// 记录str中每个字符出现的次数（将字符转为acsII进行记录）</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		priority<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 对字符进行入队</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ACSII_LEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>priority<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">AddSqQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> i<span class="token punctuation">,</span> priority<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h3><a id="2_77"></a>2.对入队列的节点进行排序处理</h3> 
<pre><code class="prism language-c"><span class="token comment">// 入队操作 根据weight进行入队 从小到大进行排序</span>
<span class="token keyword">void</span> <span class="token function">AddSqQueue</span><span class="token punctuation">(</span>SqQueueLink<span class="token operator">*</span><span class="token operator">&amp;</span> sq<span class="token punctuation">,</span> ElemType e<span class="token punctuation">,</span> <span class="token keyword">int</span> weight<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SqQueueNode<span class="token operator">*</span> sqNew <span class="token operator">=</span> new SqQueueNode<span class="token punctuation">;</span>
	sqNew<span class="token operator">-&gt;</span>btNode <span class="token operator">=</span> new BiTreeNode<span class="token punctuation">;</span>
	sqNew<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>lchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	sqNew<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

	sqNew<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>
	sqNew<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>
	sqNew<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

	SqQueueNode<span class="token operator">*</span> sqCur <span class="token operator">=</span> new SqQueueNode<span class="token punctuation">;</span>
	sqCur<span class="token operator">-&gt;</span>btNode <span class="token operator">=</span> new BiTreeNode<span class="token punctuation">;</span>
	sqCur <span class="token operator">=</span> sq<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

	<span class="token comment">// 队列为空时 直接入栈</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>sq<span class="token operator">-&gt;</span>front <span class="token operator">==</span> sq<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		sq<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>next <span class="token operator">=</span> sqNew<span class="token punctuation">;</span>
		sq<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> sqNew<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	
	<span class="token comment">// 如果权最小 则在队头直接加入</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sqNew<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>weight <span class="token operator">&lt;=</span> sqCur<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		sqNew<span class="token operator">-&gt;</span>next <span class="token operator">=</span> sqCur<span class="token punctuation">;</span>
		sq<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next <span class="token operator">=</span> sqNew<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 按照权小-大寻找位置进行插入</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>sqCur <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> sqCur<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>sqNew<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>weight <span class="token operator">&lt;=</span> sqCur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			sqCur <span class="token operator">=</span> sqCur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>sqCur<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			sqCur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> sqNew<span class="token punctuation">;</span>
			sqNew<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
			sq<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> sqNew<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			sqNew<span class="token operator">-&gt;</span>next <span class="token operator">=</span> sqCur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			sqCur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> sqNew<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h3><a id="3_136"></a>3.哈夫曼树的两种构造方法</h3> 
<ol><li>将生成的子树继续入队，通过取队头两元素进行哈夫曼树构造</li></ol> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">CreateHuffmanTreeBySq</span><span class="token punctuation">(</span>BiTreeNode<span class="token operator">*</span><span class="token operator">&amp;</span> hufmTree<span class="token punctuation">,</span> SqQueueLink<span class="token operator">*</span><span class="token operator">&amp;</span> sq<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   hufmTree <span class="token operator">=</span> new BiTreeNode<span class="token punctuation">;</span>

   BiTreeNode<span class="token operator">*</span> bRes <span class="token operator">=</span> new BiTreeNode<span class="token punctuation">;</span>
   bRes<span class="token operator">-&gt;</span>lchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
   bRes<span class="token operator">-&gt;</span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

   <span class="token keyword">while</span> <span class="token punctuation">(</span>sq<span class="token operator">-&gt;</span>front <span class="token operator">!=</span> sq<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
   	<span class="token comment">// 判断队列中元素是否只剩一个</span>
   	<span class="token keyword">if</span> <span class="token punctuation">(</span>sq<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> sq<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span>
   	<span class="token punctuation">{<!-- --></span>
   		<span class="token comment">// 取出队头两个元素</span>
   		<span class="token function">GetHeadQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
   		<span class="token function">GetHeadQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
   		<span class="token comment">// 将取出的队头两个最小元素 构造树</span>
   		<span class="token function">CreateBiTree</span><span class="token punctuation">(</span>hufmTree<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>

   		<span class="token comment">// 创建临时变量 构造哈夫曼树</span>
   		SqQueueNode<span class="token operator">*</span> sqTmp <span class="token operator">=</span> new SqQueueNode<span class="token punctuation">;</span>
   		sqTmp<span class="token operator">-&gt;</span>btNode <span class="token operator">=</span> hufmTree<span class="token punctuation">;</span>

   		<span class="token function">AddSqQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> sqTmp<span class="token operator">-&gt;</span>btNode<span class="token punctuation">,</span> sqTmp<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>data<span class="token punctuation">,</span> sqTmp<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
   	<span class="token punctuation">}</span>
   	<span class="token keyword">else</span>
   	<span class="token punctuation">{<!-- --></span>
   		<span class="token function">GetHeadQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>

   		hufmTree <span class="token operator">=</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span>
   	<span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>从队列中取出节点进行构建</li></ol> 
<pre><code class="prism language-c"><span class="token comment">// 队列节点嵌套树节点 利用嵌套的树节点进行构建  节点值小的放左边 大的放右边</span>
<span class="token keyword">void</span> <span class="token function">CreateHuffmanTree</span><span class="token punctuation">(</span>BiTreeNode<span class="token operator">*</span><span class="token operator">&amp;</span> hufmTree<span class="token punctuation">,</span> SqQueueLink<span class="token operator">*</span><span class="token operator">&amp;</span> sq<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	hufmTree <span class="token operator">=</span> new BiTreeNode<span class="token punctuation">;</span>

	BiTreeNode<span class="token operator">*</span> bRes <span class="token operator">=</span> new BiTreeNode<span class="token punctuation">;</span>

	<span class="token comment">// 取出队头两个元素</span>
	<span class="token function">GetHeadQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">GetHeadQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将取出的队头两个最小元素 构造树</span>
	<span class="token function">CreateBiTree</span><span class="token punctuation">(</span>hufmTree<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>sq<span class="token operator">-&gt;</span>front <span class="token operator">!=</span> sq<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		SqQueueNode<span class="token operator">*</span> sqTmp <span class="token operator">=</span> sq<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

		<span class="token comment">// 判断当前队列中是否剩余一个元素</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>sqTmp <span class="token operator">!=</span> sq<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 如果哈夫曼树当前的根节点与队列中最小的节点的权值小于从队头取出的两元素权值，则将lchild加入hufmTree</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>hufmTree<span class="token operator">-&gt;</span>weight <span class="token operator">+</span> sqTmp<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>sqTmp<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>weight <span class="token operator">+</span> sqTmp<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>btNode<span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">GetHeadQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token keyword">if</span> <span class="token punctuation">(</span>hufmTree<span class="token operator">-&gt;</span>weight <span class="token operator">&lt;</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token function">CreateBiTree</span><span class="token punctuation">(</span>hufmTree<span class="token punctuation">,</span> hufmTree<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token function">CreateBiTree</span><span class="token punctuation">(</span>hufmTree<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">,</span> hufmTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>	<span class="token comment">// 如果不满足条件 则利用两节点构建新二叉树 并将新二叉树添加值hufmTree</span>
			<span class="token punctuation">{<!-- --></span>
				BiTreeNode<span class="token operator">*</span> btNew <span class="token operator">=</span> new BiTreeNode<span class="token punctuation">;</span>

				<span class="token comment">// 构建树</span>
				<span class="token function">GetHeadQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">GetHeadQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">CreateBiTree</span><span class="token punctuation">(</span>btNew<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token comment">// 判断该将子树添加值左子树或右子树</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>btNew<span class="token operator">-&gt;</span>weight <span class="token operator">&lt;</span> hufmTree<span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token function">CreateBiTree</span><span class="token punctuation">(</span>hufmTree<span class="token punctuation">,</span> btNew<span class="token punctuation">,</span> hufmTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token function">CreateBiTree</span><span class="token punctuation">(</span>hufmTree<span class="token punctuation">,</span> hufmTree<span class="token punctuation">,</span> btNew<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>	<span class="token comment">// 剩余一个元素时 直接将队列中的节点加入哈夫曼树中</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">GetHeadQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span>hufmTree<span class="token operator">-&gt;</span>weight <span class="token operator">&lt;</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token operator">-&gt;</span>weight<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">CreateBiTree</span><span class="token punctuation">(</span>hufmTree<span class="token punctuation">,</span> hufmTree<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">CreateBiTree</span><span class="token punctuation">(</span>hufmTree<span class="token punctuation">,</span> bRes<span class="token operator">-&gt;</span>lchild<span class="token punctuation">,</span> hufmTree<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h2><a id="_248"></a>六.哈夫曼编码的生成(压缩编码长度)</h2> 
<h3><a id="1_249"></a>1.利用哈夫曼树生成对应的密钥字典</h3> 
<pre><code class="prism language-c"><span class="token comment">// 利用前序遍历二叉树进行遍历  如果遇到叶子节点 或者 该节点已定义 则将该节点添加至 存储结构中</span>
<span class="token comment">// int i: 用于记录生成密文后的下标</span>
<span class="token keyword">int</span> <span class="token function">CreateHuffmanCode</span><span class="token punctuation">(</span>BiTreeNode<span class="token operator">*</span> hufmTree<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token function">EncTable</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>encTable<span class="token punctuation">)</span><span class="token punctuation">[</span>ACSII_LEN<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">char</span><span class="token operator">*</span> code <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> deep <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>hufmTree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果当前节点有数据 或者为叶子节点 则将编码 和 节点数据 存至 密钥表中</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>hufmTree<span class="token operator">-&gt;</span>data <span class="token operator">!=</span> <span class="token string">'#'</span> <span class="token operator">&amp;&amp;</span> hufmTree <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>hufmTree<span class="token operator">-&gt;</span>lchild <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> hufmTree<span class="token operator">-&gt;</span>rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			encTable<span class="token punctuation">[</span>deep<span class="token punctuation">]</span><span class="token punctuation">.</span>ch <span class="token operator">=</span> hufmTree<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
			<span class="token function">strcpy</span><span class="token punctuation">(</span>encTable<span class="token punctuation">[</span>deep<span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>
			encTable<span class="token punctuation">[</span>deep<span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
			deep <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		code<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>
		<span class="token function">CreateHuffmanCode</span><span class="token punctuation">(</span>hufmTree<span class="token operator">-&gt;</span>lchild<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> encTable<span class="token punctuation">)</span><span class="token punctuation">;</span>
		code<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>
		<span class="token function">CreateHuffmanCode</span><span class="token punctuation">(</span>hufmTree<span class="token operator">-&gt;</span>rchild<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> encTable<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> deep<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2_279"></a>2.根据密钥字典进行字符串的压缩</h3> 
<pre><code class="prism language-c"><span class="token comment">// 将输入字符串 匹配字符串 将密钥替换进去</span>
<span class="token keyword">void</span> <span class="token function">Encrypt</span><span class="token punctuation">(</span>string str<span class="token punctuation">,</span> EncTable enctable<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> deep<span class="token comment">/*密钥表大小*/</span><span class="token punctuation">,</span> string<span class="token operator">&amp;</span> cryptograph<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span><span class="token operator">*</span> cryptographTmp <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> pC <span class="token operator">=</span> cryptographTmp<span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> deep<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> enctable<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>ch<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">strcpy</span><span class="token punctuation">(</span>cryptographTmp<span class="token punctuation">,</span> enctable<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>
				cryptographTmp <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>enctable<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	cryptographTmp<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>cryptographTmp<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>

	cryptographTmp <span class="token operator">=</span> pC<span class="token punctuation">;</span>
	cryptograph <span class="token operator">=</span> cryptographTmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3_304"></a>3.利用密钥字典中的编码对字符串进行解密</h3> 
<pre><code class="prism language-c"><span class="token comment">// 解密函数 根据密钥表 对 密文进行匹配 匹配到一位 存储一位 直到全部解密完成</span>
<span class="token keyword">void</span> <span class="token function">Decode</span><span class="token punctuation">(</span>string cryptograph<span class="token punctuation">,</span> EncTable enctable<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> deep<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span><span class="token operator">*</span> decodeStr <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> deocelen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token keyword">char</span><span class="token operator">*</span> crytmp <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span>cryptograph<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">strcpy</span><span class="token punctuation">(</span>crytmp<span class="token punctuation">,</span> cryptograph<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> crytmplen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>crytmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> crytmplen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> z <span class="token operator">&lt;</span> deep<span class="token punctuation">;</span> z<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>enctable<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>enctable<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> crytmp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					flag<span class="token operator">++</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token function">strlen</span><span class="token punctuation">(</span>enctable<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				decodeStr<span class="token punctuation">[</span>deocelen<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> enctable<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">.</span>ch<span class="token punctuation">;</span>
				crytmp <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>enctable<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">.</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>

				crytmplen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>crytmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
				i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	decodeStr<span class="token punctuation">[</span>deocelen<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>

	str <span class="token operator">=</span> decodeStr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h2><a id="_346"></a>七.测试结果</h2> 
<p><img src="https://images2.imgbox.com/44/87/0GoCPyYJ_o.png" alt="测试结果"></p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SqQueueLink<span class="token operator">*</span> sq <span class="token operator">=</span> new SqQueueLink<span class="token punctuation">;</span>

	<span class="token function">InitQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">)</span><span class="token punctuation">;</span>

	ElemType e<span class="token punctuation">;</span>
	<span class="token keyword">int</span> weight<span class="token punctuation">;</span>

	string str <span class="token operator">=</span> <span class="token string">"This is a test string!!"</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> priority<span class="token punctuation">[</span>ACSII_LEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>		<span class="token comment">// 确定优先级，记录ACSII所有字符出现的次数 </span>

	<span class="token comment">// 记录str中每个字符出现的次数（将字符转为acsII进行记录）</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		priority<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ACSII_LEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		BiTreeNode<span class="token operator">*</span> bi <span class="token operator">=</span> new BiTreeNode<span class="token punctuation">;</span>
		bi<span class="token operator">-&gt;</span>lchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		bi<span class="token operator">-&gt;</span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>priority<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">AddSqQueue</span><span class="token punctuation">(</span>sq<span class="token punctuation">,</span> bi<span class="token punctuation">,</span> i<span class="token punctuation">,</span> priority<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	BiTreeNode<span class="token operator">*</span> hufmTree <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token function">CreateHuffmanTreeBySq</span><span class="token punctuation">(</span>hufmTree<span class="token punctuation">,</span> sq<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 密钥表</span>
	EncTable encTable<span class="token punctuation">[</span>ACSII_LEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token comment">// 加密算法有问题</span>
	<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> deep <span class="token operator">=</span> <span class="token function">CreateHuffmanCode</span><span class="token punctuation">(</span>hufmTree<span class="token punctuation">,</span> len<span class="token punctuation">,</span> encTable<span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"密钥表:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> deep<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> encTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>ch <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> encTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>table <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 对字符串进行加密</span>
	string cryptograph<span class="token punctuation">;</span>
	<span class="token function">Encrypt</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> encTable<span class="token punctuation">,</span> deep<span class="token punctuation">,</span> cryptograph<span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n密文:\n"</span> <span class="token operator">&lt;&lt;</span> cryptograph <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	string decodeStr<span class="token punctuation">;</span>
	<span class="token function">Decode</span><span class="token punctuation">(</span>cryptograph<span class="token punctuation">,</span> encTable<span class="token punctuation">,</span> deep<span class="token punctuation">,</span> decodeStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n\n解密:\n"</span> <span class="token operator">&lt;&lt;</span> decodeStr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e64744c924fd5a5c92d9155b2d8f879/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vulnhub之lampiao渗透测试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c7e96cd0c98bc13c7a96d5f66226eadd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">清华裴丹：AIOps九大发展趋势</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>