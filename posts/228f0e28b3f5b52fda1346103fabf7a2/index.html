<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker简介以及如何在 IDEA 中使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker简介以及如何在 IDEA 中使用" />
<meta property="og:description" content="1 Docker简介 1.1 什么是Docker ​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。
​
​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。
​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。
​ Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。
​ 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
1.2 为什么要用 Docker 优势
更高效的利用系统资源， 由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。更快速的启动时间， 传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。一致的运行环境， 开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。持续交付和部署， 对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。更轻松的迁移， 由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 对比传统虚拟机总结" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/228f0e28b3f5b52fda1346103fabf7a2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-05T22:29:34+08:00" />
<meta property="article:modified_time" content="2022-04-05T22:29:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker简介以及如何在 IDEA 中使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_Docker_0"></a>1 Docker简介</h2> 
<h3><a id="11_Docker_2"></a>1.1 什么是Docker</h3> 
<p>​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。</p> 
<p>​<img src="https://images2.imgbox.com/ee/df/PY8yJwJD_o.png" alt="什么是docker"></p> 
<p>​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。</p> 
<p>​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。</p> 
<p>​ Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p> 
<p>​ 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p> 
<h3><a id="12__Docker_20"></a>1.2 为什么要用 Docker</h3> 
<p><strong>优势</strong></p> 
<ol><li><strong>更高效的利用系统资源，</strong> 由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</li><li><strong>更快速的启动时间，</strong> 传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</li><li><strong>一致的运行环境，</strong> 开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</li><li><strong>持续交付和部署，</strong> 对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</li><li><strong>更轻松的迁移，</strong> 由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</li></ol> 
<p><strong>对比传统虚拟机总结</strong></p> 
<table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 <code>MB</code></td><td>一般为 <code>GB</code></td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table> 
<p><img src="https://images2.imgbox.com/8a/1f/Sy1YXGeT_o.png" alt="传统虚拟化"></p> 
<center>
  传统虚拟化 
</center> 
<br> 
<p><img src="https://images2.imgbox.com/e2/a3/lFgqxC1X_o.png" alt="在这里插入图片描述"></p> 
<center>
  docker虚拟化 
</center> 
<p></p> 
<h3><a id="13_Docker_54"></a>1.3 Docker的三个基本概念</h3> 
<ul><li> <p><strong>镜像（<code>Image</code>）：</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p> </li><li> <p><strong>容器（<code>Container</code>）：</strong> 镜像运行实例，镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p> <p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。</p> </li><li> <p><strong>仓库：</strong> 集中存放镜像文件的场所，镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务。</p> </li></ul> 
<h3><a id="14_Dockerfile_65"></a>1.4 Dockerfile文件</h3> 
<p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。<br> 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；<br> 2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；<br> 3、对于运维人员：在部署时，可以实现应用的无缝移植。</p> 
<h4><a id="141_Dockerfile_71"></a>1.4.1 Dockerfile命令含义</h4> 
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>FROM image_name:tag</td><td>定义了使用哪个基础镜像启动构建流程</td></tr><tr><td>MAINTAINER user_name</td><td>声明镜像的创建者</td></tr><tr><td>ENV key value</td><td>设置环境变量 (可以写多条)</td></tr><tr><td>RUN command</td><td>是Dockerfile的核心部分(可以写多条)</td></tr><tr><td>ADD source_dir/file dest_dir/file</td><td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td></tr><tr><td>COPY source_dir/file dest_dir/file</td><td>和ADD相似，但是如果有压缩文件并不能解压</td></tr><tr><td>WORKDIR path_dir</td><td>设置工作目录</td></tr></tbody></table> 
<h2><a id="2_IDEADocker_83"></a>2 IDEA集成Docker插件</h2> 
<h3><a id="21_Docker_86"></a>2.1 配置Docker服务器地址</h3> 
<p><img src="https://images2.imgbox.com/7f/2f/VcMZ5MlI_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22_Dockerfile_90"></a>2.2 在项目下创建Dockerfile文件</h3> 
<p><strong>Dockerfile配置</strong></p> 
<pre><code class="prism language-dockerfile">FROM java:8

# 镜像制作者
LABEL maintainer="test@qq.com"

# 将项目 jar 包（demo-0.0.1-SNAPSHOT.jar）拷贝到 studentdemo.jar中
COPY target/demo-0.0.1-SNAPSHOT.jar studentdemo.jar

# 仅仅只是声明端口，以方便配置映射
EXPOSE 8762

# 执行 jar 包  "-Djava.security.egd=file:/dev/./urandom"加快随机数产生过程
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/studentdemo.jar"]
</code></pre> 
<h3><a id="23_Dockerfile_111"></a>2.3 Dockerfile的运行配置</h3> 
<p><img src="https://images2.imgbox.com/a4/e7/7m9lfWoX_o.png" alt="在这里插入图片描述"></p> 
<p><strong>配置内容：</strong></p> 
<p><img src="https://images2.imgbox.com/05/9f/EUwLjJxh_o.png" alt="在这里插入图片描述"></p> 
<p><strong>端口映射：</strong></p> 
<p><img src="https://images2.imgbox.com/97/39/O0bKzPQ3_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="24_Docker_127"></a>2.4 构建Docker镜像</h3> 
<p><strong>pom配置</strong></p> 
<pre><code class="prism language-shell"><span class="token operator">&lt;</span>build<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>plugins<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>plugin<span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>groupId<span class="token operator">&gt;</span>org.springframework.boot<span class="token operator">&lt;</span>/groupId<span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>artifactId<span class="token operator">&gt;</span>spring-boot-maven-plugin<span class="token operator">&lt;</span>/artifactId<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>/plugin<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>/plugins<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/build<span class="token operator">&gt;</span>
</code></pre> 
<p><strong>打包</strong></p> 
<p><img src="https://images2.imgbox.com/5c/0a/2pPe75wS_o.png" alt="在这里插入图片描述"></p> 
<p><strong>执行Dockerfile构建镜像</strong><br> <img src="https://images2.imgbox.com/07/58/icguyTIC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="25__150"></a>2.5 运行项目所在的容器</h3> 
<p>镜像生成后，会自动创建相应的容器，右键运行容器后，可在控制台的查看应用的启动情况。<br> <img src="https://images2.imgbox.com/82/cf/nyuIgX9D_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="26_Docker_154"></a>2.6 访问Docker容器中运行的项目</h3> 
<p><img src="https://images2.imgbox.com/36/51/ENeAem2q_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="3_Docker_157"></a>3 Docker迁移与备份</h2> 
<h3><a id="31__159"></a>3.1 容器保存为镜像</h3> 
<p>我们可以通过以下命令将容器保存为镜像</p> 
<p><code>docker commit studentdemo_container studentdemo_image</code></p> 
<h3><a id="32__167"></a>3.2 镜像备份</h3> 
<p>我们可以通过以下命令将镜像保存为tar 文件</p> 
<p><code>docker save -o studentdemo_image.tar studentdemo_image</code></p> 
<h3><a id="33__175"></a>3.3 镜像恢复与迁移</h3> 
<p>首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复，-i后是镜像文件名</p> 
<p><code>docker load -i studentdemo_image.tar</code></p> 
<p>执行后再次查看镜像，可以看到镜像已经恢复</p> 
<p>*参考资料：Docker —— 从入门到实践(https://yeasy.gitbook.io/docker_practice/)</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4469ef1352e42c96c0f28daefbca7289/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nmap的介绍、安装 并进行网络扫描</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df1684da461179c78d783777ac5c58ce/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Redis systemd 服务和 daemon no 配置的冲突问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>