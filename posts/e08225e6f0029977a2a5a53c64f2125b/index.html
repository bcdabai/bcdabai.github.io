<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Rust基础③】方法method、泛型与特征 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Rust基础③】方法method、泛型与特征" />
<meta property="og:description" content="文章目录 6 方法 Method6.1 定义方法self、&amp;self 和 &amp;mut self 6.2 自动引用和解引用6.3 关联函数 7 泛型和特征7.1 泛型 Generics7.1.1 结构体中使用泛型7.1.2 枚举中使用泛型7.1.3 方法中使用泛型为具体的泛型类型实现方法 7.1.4 const 泛型 7.2 特征 Trait7.2.1 为类型实现特征7.2.2 使用特征作为函数参数7.2.3 特征约束(trait bound)多重约束where约束 7.2.4 函数返回中的impl trait7.2.5 两个综合例子为自定义类型实现 `&#43;` 操作自定义类型的打印输出 7.3 特征对象 6 方法 Method Rust中，方法往往和对象成对出现：object.method()。Rust 的方法往往跟结构体、枚举、特征(Trait)一起使用
6.1 定义方法 Rust 使用 impl 来定义方法，例如以下代码：
struct Circle { x: f64, y: f64, radius: f64, } impl Circle { // new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字 // 这种方法往往用于初始化当前结构体的实例 fn new(x: f64, y: f64, radius: f64) -&gt; Circle { Circle { x: x, y: y, radius: radius, } } // Circle的方法，&amp;self表示借用当前的Circle结构体 fn area(&amp;self) -&gt; f64 { std::f64::consts::PI * (self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e08225e6f0029977a2a5a53c64f2125b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-15T17:13:42+08:00" />
<meta property="article:modified_time" content="2023-10-15T17:13:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Rust基础③】方法method、泛型与特征</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#6__Method_1" rel="nofollow">6 方法 Method</a></li><li><ul><li><a href="#61__5" rel="nofollow">6.1 定义方法</a></li><li><ul><li><a href="#selfself__mut_self_36" rel="nofollow">self、&amp;self 和 &amp;mut self</a></li></ul> 
   </li><li><a href="#62__75" rel="nofollow">6.2 自动引用和解引用</a></li><li><a href="#63__88" rel="nofollow">6.3 关联函数</a></li></ul> 
  </li><li><a href="#7__133" rel="nofollow">7 泛型和特征</a></li><li><ul><li><a href="#71__Generics_135" rel="nofollow">7.1 泛型 Generics</a></li><li><ul><li><a href="#711__145" rel="nofollow">7.1.1 结构体中使用泛型</a></li><li><a href="#712__166" rel="nofollow">7.1.2 枚举中使用泛型</a></li><li><a href="#713__190" rel="nofollow">7.1.3 方法中使用泛型</a></li><li><ul><li><a href="#_221" rel="nofollow">为具体的泛型类型实现方法</a></li></ul> 
    </li><li><a href="#714_const__237" rel="nofollow">7.1.4 const 泛型</a></li></ul> 
   </li><li><a href="#72__Trait_264" rel="nofollow">7.2 特征 Trait</a></li><li><ul><li><a href="#721__267" rel="nofollow">7.2.1 为类型实现特征</a></li><li><a href="#722__307" rel="nofollow">7.2.2 使用特征作为函数参数</a></li><li><a href="#723_trait_bound_321" rel="nofollow">7.2.3 特征约束(trait bound)</a></li><li><ul><li><a href="#_347" rel="nofollow">多重约束</a></li><li><a href="#where_355" rel="nofollow">where约束</a></li></ul> 
    </li><li><a href="#724_impl_trait_372" rel="nofollow">7.2.4 函数返回中的impl trait</a></li><li><a href="#725__391" rel="nofollow">7.2.5 两个综合例子</a></li><li><ul><li><a href="#___393" rel="nofollow">为自定义类型实现 `+` 操作</a></li><li><a href="#_433" rel="nofollow">自定义类型的打印输出</a></li></ul> 
   </li></ul> 
   </li><li><a href="#73__503" rel="nofollow">7.3 特征对象</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="6__Method_1"></a>6 方法 Method</h2> 
<p>Rust中，方法往往和对象成对出现：<code>object.method()</code>。Rust 的方法往往跟结构体、枚举、特征(Trait)一起使用</p> 
<h3><a id="61__5"></a>6.1 定义方法</h3> 
<p>Rust 使用 <code>impl</code> 来定义方法，例如以下代码：</p> 
<pre><code class="prism language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Circle</span> <span class="token punctuation">{<!-- --></span>
    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span>
    radius<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Circle</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字</span>
    <span class="token comment">// 这种方法往往用于初始化当前结构体的实例</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> radius<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Circle</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Circle</span> <span class="token punctuation">{<!-- --></span>
            x<span class="token punctuation">:</span> x<span class="token punctuation">,</span>
            y<span class="token punctuation">:</span> y<span class="token punctuation">,</span>
            radius<span class="token punctuation">:</span> radius<span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Circle的方法，&amp;self表示借用当前的Circle结构体</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{<!-- --></span>
        <span class="token namespace">std<span class="token punctuation">::</span></span><span class="token keyword">f64</span><span class="token punctuation">::</span><span class="token namespace">consts<span class="token punctuation">::</span></span><span class="token constant">PI</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>radius <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>radius<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注：Rust 的对象定义和方法定义是分离的，这种数据和使用分离的方式，会给予使用者极高的灵活度。</p> 
<h4><a id="selfself__mut_self_36"></a>self、&amp;self 和 &amp;mut self</h4> 
<p>在一个 <code>impl</code> 块内，<code>Self</code> 指代被实现方法的结构体类型，<code>self</code> 指代此类型的实例，即为哪个结构体实现方法，那么 <code>self</code> 就是指代哪个结构体的实例。<code>self</code> 依然有所有权的概念：</p> 
<ul><li><code>self</code> 表示 <code>Rectangle</code> 的所有权转移到该方法中，这种形式用的较少</li><li><code>&amp;self</code> 表示该方法对 <code>Rectangle</code> 的不可变借用</li><li><code>&amp;mut self</code> 表示可变借用</li></ul> 
<p><code>self</code> 的使用就跟函数参数一样，要严格遵守 Rust 的所有权规则。使用方法代替函数有以下好处：</p> 
<ul><li>不用在函数签名中重复书写 <code>self</code> 对应的类型</li><li>代码的组织性和内聚性更强，对于代码维护和阅读来说，好处巨大</li></ul> 
<p>在 Rust 中，允许方法名跟结构体的字段名相同，往往适用于实现 <code>getter</code> 访问器：</p> 
<pre><code class="prism language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{<!-- --></span>
    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Rectangle</span> <span class="token punctuation">{<!-- --></span> width<span class="token punctuation">,</span> height <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">width</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">self</span><span class="token punctuation">.</span>width<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>用这种方式，我们可以把 <code>Rectangle</code> 的字段设置为私有属性，只需把它的 <code>new</code> 和 <code>width</code> 方法设置为公开可见，那么用户就可以创建一个矩形，同时通过访问器 <code>rect1.width()</code> 方法来获取矩形的宽度，因为 <code>width</code> 字段是私有的，当用户访问 <code>rect1.width</code> 字段时，就会报错。注意在此例中，<code>Self</code> 指代的就是被实现方法的结构体 <code>Rectangle</code>。</p> 
<h3><a id="62__75"></a>6.2 自动引用和解引用</h3> 
<p>在 C/C++ 语言中，有两个不同的运算符来调用方法：<code>.</code> 直接在对象上调用方法，而 <code>-&gt;</code> 在一个对象的指针上调用方法，这时需要先解引用指针。换句话说，如果 <code>object</code> 是一个指针，那么 <code>object-&gt;something()</code> 和 <code>(*object).something()</code> 是一样的。</p> 
<p>Rust 并没有一个与 <code>-&gt;</code> 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。他是这样工作的：当使用 <code>object.something()</code> 调用方法时，Rust 会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使 <code>object</code> 与方法签名匹配。也就是说，这些代码是等价的:</p> 
<pre><code class="prism language-rust">p1<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>第一行看起来简洁的多。这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— <code>self</code> 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（<code>&amp;self</code>），做出修改（<code>&amp;mut self</code>）或者是获取所有权（<code>self</code>）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。</p> 
<h3><a id="63__88"></a>6.3 关联函数</h3> 
<p>思考一个问题，如何为一个结构体定义一个构造器方法？也就是接受几个参数，然后构造并返回该结构体的实例。其实答案在开头的代码片段中就给出了，很简单，参数中不包含 <code>self</code> 即可。</p> 
<p>这种定义在 <code>impl</code> 中且没有 <code>self</code> 的函数被称之为<strong>关联函数</strong>： 因为它没有 <code>self</code>，不能用 <code>f.read()</code> 的形式调用，因此它是一个函数而不是方法，它又在 <code>impl</code> 中，与结构体紧密关联，因此称为关联函数。</p> 
<p>在之前的代码中，我们已经多次使用过关联函数，例如 <code>String::from</code>，用于创建一个动态字符串。</p> 
<pre><code class="prism language-rust"><span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>w<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span> h<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Rectangle</span> <span class="token punctuation">{<!-- --></span> width<span class="token punctuation">:</span> w<span class="token punctuation">,</span> height<span class="token punctuation">:</span> h <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>Rust 中有一个约定俗成的规则，使用 <code>new</code> 来作为构造器的名称，出于设计上的考虑，Rust 特地没有用 <code>new</code> 作为关键字</p> 
</blockquote> 
<p>因为是函数，所以不能用 <code>.</code> 的方式来调用，我们需要用 <code>::</code> 来调用，例如 <code>let sq = Rectangle::new(3, 3);</code>。这个方法位于结构体的命名空间中：<code>::</code> 语法用于关联函数和模块创建的命名空间。</p> 
<p>Rust 允许我们为一个结构体定义多个 <code>impl</code> 块，目的是提供更多的灵活性和代码组织性，例如当方法多了后，可以把相关的方法组织在同一个 <code>impl</code> 块中，那么就可以形成多个 <code>impl</code> 块，各自完成一块儿目标。</p> 
<p>除了结构体，还可以为枚举、特征(trait)实现方法，如：</p> 
<pre><code class="prism language-rust"><span class="token attribute attr-name">#![allow(unused)]</span>
<span class="token keyword">enum</span> <span class="token type-definition class-name">Message</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Quit</span><span class="token punctuation">,</span>
    <span class="token class-name">Move</span> <span class="token punctuation">{<!-- --></span> x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token class-name">Write</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">ChangeColor</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Message</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fn</span> <span class="token function-definition function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 在这里定义方法体</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">Write</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    m<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="7__133"></a>7 泛型和特征</h2> 
<h3><a id="71__Generics_135"></a>7.1 泛型 Generics</h3> 
<p>使用泛型参数，有一个先决条件，必需在使用前对其进行声明：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">largest</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>list<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token class-name">T</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">T</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>可以这样理解这个函数定义：函数 <code>largest</code> 有泛型类型 <code>T</code>，它有个参数 <code>list</code>，其类型是元素为 <code>T</code> 的数组切片，最后，该函数返回值的类型也是 <code>T</code>。</p> 
<h4><a id="711__145"></a>7.1.1 结构体中使用泛型</h4> 
<p>结构体中的字段类型也可以用泛型来定义，下面代码定义了一个坐标点 <code>Point</code>，它可以存放任何类型的坐标值：</p> 
<pre><code class="prism language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> integer <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{<!-- --></span> x<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> float <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{<!-- --></span> x<span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里有两点需要特别的注意：</p> 
<ul><li><strong>提前声明</strong>，跟泛型函数定义类似，首先我们在使用泛型参数之前必需要进行声明 <code>Point&lt;T&gt;</code>，接着就可以在结构体的字段类型中使用 <code>T</code> 来替代具体的类型</li><li><strong>x 和 y 是相同的类型</strong>，若需要不同类型，将声明改为<code>struct Point&lt;T,U&gt; { x: T, y: U, }</code></li></ul> 
<h4><a id="712__166"></a>7.1.2 枚举中使用泛型</h4> 
<p><code>Option</code> 枚举类型</p> 
<pre><code class="prism language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">None</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>Option&lt;T&gt;</code> 是一个拥有泛型 <code>T</code> 的枚举类型，它第一个成员是 <code>Some(T)</code>，存放了一个类型为 <code>T</code> 的值。可以在任何一个需要返回值的函数中，去使用 <code>Option&lt;T&gt;</code> 枚举类型来做为返回值，用于返回一个任意类型的值 <code>Some(T)</code>，或者没有值 <code>None</code>。</p> 
<p><code>Result</code>枚举类型</p> 
<pre><code class="prism language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">E</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>主要用于函数返回值，如果函数正常运行，则最后返回一个 <code>Ok(T)</code>，<code>T</code> 是函数具体的返回值类型，如果函数异常运行，则返回一个 <code>Err(E)</code>，<code>E</code> 是错误类型。例如打开一个文件：如果成功打开文件，则返回 <code>Ok(std::fs::File)</code>，因此 <code>T</code> 对应的是 <code>std::fs::File</code> 类型；而当打开文件时出现问题时，返回 <code>Err(std::io::Error)</code>，<code>E</code> 对应的就是 <code>std::io::Error</code> 类型。</p> 
<h4><a id="713__190"></a>7.1.3 方法中使用泛型</h4> 
<p>在结构体的方法中定义额外的泛型参数，就跟泛型函数一样：</p> 
<pre><code class="prism language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> <span class="token class-name">U</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fn</span> <span class="token function-definition function">mixup</span><span class="token operator">&lt;</span><span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token class-name">W</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token class-name">W</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">W</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Point</span> <span class="token punctuation">{<!-- --></span>
            x<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span>
            y<span class="token punctuation">:</span> other<span class="token punctuation">.</span>y<span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{<!-- --></span> x<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10.4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{<!-- --></span> x<span class="token punctuation">:</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token char">'c'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> p3 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">mixup</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p3.x = {}, p3.y = {}"</span><span class="token punctuation">,</span> p3<span class="token punctuation">.</span>x<span class="token punctuation">,</span> p3<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个例子中，<code>T,U</code> 是定义在结构体 <code>Point</code> 上的泛型参数，<code>V,W</code> 是单独定义在方法 <code>mixup</code> 上的泛型参数，可以理解为，一个是结构体泛型，一个是函数泛型。</p> 
<h5><a id="_221"></a>为具体的泛型类型实现方法</h5> 
<p>对于 <code>Point&lt;T&gt;</code> 类型，你不仅能定义基于 <code>T</code> 的方法，还能针对特定的具体类型，进行方法定义：</p> 
<pre><code class="prism language-rust"><span class="token keyword">impl</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token keyword">f32</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fn</span> <span class="token function-definition function">distance_from_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f32</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>x<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这段代码意味着 <code>Point&lt;f32&gt;</code> 类型会有一个方法 <code>distance_from_origin</code>，而其他 <code>T</code> 不是 <code>f32</code> 类型的 <code>Point&lt;T&gt; </code>实例则没有定义此方法。这个方法计算点实例与坐标<code>(0.0, 0.0)</code> 之间的距离，并使用了只能用于浮点型的数学运算符。</p> 
<p>这样我们就能针对特定的泛型类型实现某个特定的方法，对于其它泛型类型则没有定义该方法</p> 
<h4><a id="714_const__237"></a>7.1.4 const 泛型</h4> 
<p>const 泛型，针对值的泛型，可以用于处理数组长度的问题：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">display_array</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token namespace">std<span class="token punctuation">::</span>fmt<span class="token punctuation">::</span></span><span class="token class-name">Debug</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">N</span><span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">T</span><span class="token punctuation">;</span> <span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">display_array</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">display_array</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如上所示，我们定义了一个类型为 <code>[T; N]</code> 的数组，其中 <code>T</code> 是一个基于类型的泛型参数，重点在于 <code>N</code> 这个泛型参数，它是一个基于值的泛型参数！因为它用来替代的是数组的长度。</p> 
<blockquote> 
 <p>注意的是需要对 <code>T</code> 加一个限制 <code>std::fmt::Debug</code>，该限制表明 <code>T</code> 可以用在 <code>println!("{:?}", arr)</code> 中，因为 <code>{:?}</code> 形式的格式化输出需要 <code>arr</code> 实现该特征。</p> 
</blockquote> 
<p><code>N</code> 就是 const 泛型，定义的语法是 <code>const N: usize</code>，表示 const 泛型 <code>N</code> ，它基于的值类型是 <code>usize</code>。</p> 
<p>Rust 通过在编译时进行泛型代码的 <strong>单态化</strong>(<em>monomorphization</em>)来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p> 
<p>编译器所做的工作正好与我们创建泛型函数的步骤相反，编译器寻找所有泛型代码被调用的位置并针对具体类型生成代码。</p> 
<h3><a id="72__Trait_264"></a>7.2 特征 Trait</h3> 
<p>特征类似于其他语言中的接口，定义了<strong>一组可以被共享的行为，只要实现了特征，你就能使用这组行为</strong>。</p> 
<h4><a id="721__267"></a>7.2.1 为类型实现特征</h4> 
<p>因为特征只定义行为看起来是什么样的，因此我们需要为类型实现具体的特征，定义行为具体是怎么样的。</p> 
<p>首先来为 <code>Post</code> 和 <code>Weibo</code> 实现 <code>Summary</code> 特征：</p> 
<pre><code class="prism language-rust"><span class="token comment">//特征定义，也可以在特征中定义具有默认实现的方法</span>
<span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Summary</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fn</span> <span class="token function-definition function">summarize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Post</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">pub</span> title<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token comment">// 标题</span>
    <span class="token keyword">pub</span> author<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token comment">// 作者</span>
    <span class="token keyword">pub</span> content<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token comment">// 内容</span>
<span class="token punctuation">}</span>
<span class="token comment">//特征实现</span>
<span class="token keyword">impl</span> <span class="token class-name">Summary</span> <span class="token keyword">for</span> <span class="token class-name">Post</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fn</span> <span class="token function-definition function">summarize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{<!-- --></span>
        <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"文章{}, 作者是{}"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>title<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>author<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Weibo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">pub</span> username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
    <span class="token keyword">pub</span> content<span class="token punctuation">:</span> <span class="token class-name">String</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Summary</span> <span class="token keyword">for</span> <span class="token class-name">Weibo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fn</span> <span class="token function-definition function">summarize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{<!-- --></span>
        <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"{}发表了微博{}"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>username<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>content<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>实现特征的语法与为结构体、枚举实现方法很像：<code>impl Summary for Post</code>，读作“为 <code>Post</code> 类型实现 <code>Summary</code> 特征”，然后在 <code>impl</code> 的花括号中实现该特征的具体方法。</p> 
<blockquote> 
 <p>关于特征实现与定义的位置，有一条非常重要的原则：<strong>如果你想要为类型</strong> <code>A</code> <strong>实现特征</strong> <code>T</code><strong>，那么</strong> <code>A</code> <strong>或者</strong> <code>T</code> <strong>至少有一个是在当前作用域中定义的！</strong></p> 
</blockquote> 
<h4><a id="722__307"></a>7.2.2 使用特征作为函数参数</h4> 
<p>定义一个函数，使用特征作为函数参数：</p> 
<pre><code class="prism language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">impl</span> <span class="token class-name">Summary</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Breaking news! {}"</span><span class="token punctuation">,</span> item<span class="token punctuation">.</span><span class="token function">summarize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>impl Summary</code>，它的意思是 <strong>实现了<code>Summary</code>特征</strong> 的 <code>item</code> 参数。</p> 
<p>你可以使用任何实现了 <code>Summary</code> 特征的类型作为该函数的参数，同时在函数体内，还可以调用该特征的方法，例如 <code>summarize</code> 方法。具体的说，可以传递 <code>Post</code> 或 <code>Weibo</code> 的实例来作为参数，而其它类如 <code>String</code> 或者 <code>i32</code> 的类型则不能用做该函数的参数，因为它们没有实现 <code>Summary</code> 特征。</p> 
<h4><a id="723_trait_bound_321"></a>7.2.3 特征约束(trait bound)</h4> 
<p>虽然 <code>impl Trait</code> 这种语法非常好理解，但是实际上它只是一个语法糖：</p> 
<pre><code class="prism language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Summary</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Breaking news! {}"</span><span class="token punctuation">,</span> item<span class="token punctuation">.</span><span class="token function">summarize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>真正的完整书写形式如上所述，形如 <code>T: Summary</code> 被称为<strong>特征约束</strong>。</p> 
<p>在简单的场景下 <code>impl Trait</code> 这种语法糖就足够使用，但是对于复杂的场景，特征约束可以让我们拥有更大的灵活性和语法表现能力，例如一个函数接受两个 <code>impl Summary</code> 的参数：</p> 
<pre><code class="prism language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token punctuation">(</span>item1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">impl</span> <span class="token class-name">Summary</span><span class="token punctuation">,</span> item2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">impl</span> <span class="token class-name">Summary</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>如果函数两个参数是不同的类型，那么上面的方法很好，只要这两个类型都实现了 <code>Summary</code> 特征即可。但是如果我们想要强制函数的两个参数是同一类型呢？上面的语法就无法做到这种限制，此时我们只能使特征约束来实现：</p> 
<pre><code class="prism language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Summary</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>item1<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">,</span> item2<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>泛型类型 <code>T</code> 说明了 <code>item1</code> 和 <code>item2</code> 必须拥有同样的类型，同时 <code>T: Summary</code> 说明了 <code>T</code> 必须实现 <code>Summary</code> 特征。</p> 
<h5><a id="_347"></a>多重约束</h5> 
<pre><code class="prism language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Summary</span> <span class="token operator">+</span> <span class="token class-name">Display</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>通过这两个特征，就可以使用 <code>item.summarize</code> 方法，以及通过 <code>println!("{}", item)</code> 来格式化输出 <code>item</code>。</p> 
<h5><a id="where_355"></a>where约束</h5> 
<p>当特征约束变得很多时，函数的签名将变得很复杂：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">some_function</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Display</span> <span class="token operator">+</span> <span class="token class-name">Clone</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token punctuation">:</span> <span class="token class-name">Clone</span> <span class="token operator">+</span> <span class="token class-name">Debug</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">,</span> u<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">U</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>严格来说，上面的例子还是不够复杂，但是我们还是能对其做一些形式上的改进，通过 <code>where</code>：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">some_function</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">,</span> u<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">U</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span>
    <span class="token keyword">where</span> <span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Display</span> <span class="token operator">+</span> <span class="token class-name">Clone</span><span class="token punctuation">,</span>
          <span class="token class-name">U</span><span class="token punctuation">:</span> <span class="token class-name">Clone</span> <span class="token operator">+</span> <span class="token class-name">Debug</span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<h4><a id="724_impl_trait_372"></a>7.2.4 函数返回中的impl trait</h4> 
<p>可以通过 <code>impl Trait</code> 来说明一个函数返回了一个类型，该类型实现了某个特征：</p> 
<pre><code class="prism language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">returns_summarizable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">impl</span> <span class="token class-name">Summary</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Weibo</span> <span class="token punctuation">{<!-- --></span>
        username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"sunface"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        content<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>
            <span class="token string">"m1 max太厉害了，电脑再也不会卡"</span><span class="token punctuation">,</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>因为 <code>Weibo</code> 实现了 <code>Summary</code>，因此这里可以用它来作为返回值。要注意的是，虽然我们知道这里是一个 <code>Weibo</code> 类型，但是对于 <code>returns_summarizable</code> 的调用者而言，他只知道返回了一个实现了 <code>Summary</code> 特征的对象，但是并不知道返回了一个 <code>Weibo</code> 类型。</p> 
<p>当函数返回的真实类型非常复杂，不知道该怎么声明时(毕竟 Rust 要求你必须标出所有的类型)，此时就可以用 <code>impl Trait</code> 的方式简单返回。例如，闭包和迭代器就是很复杂，只有编译器才知道那玩意的真实类型，如果让你写出来它们的具体类型，估计内心有一万只草泥马奔腾，好在你可以用 <code>impl Iterator</code> 来告诉调用者，返回了一个迭代器，因为所有迭代器都会实现 <code>Iterator</code> 特征。</p> 
<h4><a id="725__391"></a>7.2.5 两个综合例子</h4> 
<h5><a id="___393"></a>为自定义类型实现 <code>+</code> 操作</h5> 
<p>在 Rust 中除了数值类型的加法，<code>String</code> 也可以做<a href="https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">加法</a>，因为 Rust 为该类型实现了 <code>std::ops::Add</code> 特征，同理，如果我们为自定义类型实现了该特征，那就可以自己实现 <code>Point1 + Point2</code> 的操作:</p> 
<pre><code class="prism language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span></span><span class="token class-name">Add</span><span class="token punctuation">;</span>

<span class="token comment">// 为Point结构体派生Debug特征，用于格式化输出</span>
<span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Add</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token class-name">T</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//限制类型T必须实现了Add特征，否则无法进行+操作。</span>
    x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Add</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token class-name">T</span><span class="token operator">&gt;&gt;</span> <span class="token class-name">Add</span> <span class="token keyword">for</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">type</span> <span class="token type-definition class-name">Output</span> <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">add</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Point</span><span class="token punctuation">{<!-- --></span>
            x<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">+</span> p<span class="token punctuation">.</span>x<span class="token punctuation">,</span>
            y<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y <span class="token operator">+</span> p<span class="token punctuation">.</span>y<span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">add</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Add</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">Output</span><span class="token operator">=</span><span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span><span class="token class-name">T</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">T</span> <span class="token punctuation">{<!-- --></span>
    a <span class="token operator">+</span> b
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">{<!-- --></span>x<span class="token punctuation">:</span> <span class="token number">1.1f32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1.1f32</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">{<!-- --></span>x<span class="token punctuation">:</span> <span class="token number">2.1f32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2.1f32</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> p3 <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">{<!-- --></span>x<span class="token punctuation">:</span> <span class="token number">1i32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">1i32</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> p4 <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">{<!-- --></span>x<span class="token punctuation">:</span> <span class="token number">2i32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2i32</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>p3<span class="token punctuation">,</span> p4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_433"></a>自定义类型的打印输出</h5> 
<p>在开发过程中，往往只要使用 <code>#[derive(Debug)]</code> 对我们的自定义类型进行标注，即可实现打印输出的功能：</p> 
<pre><code class="prism language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token punctuation">{<!-- --></span>
    x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> <span class="token keyword">i32</span>
<span class="token punctuation">}</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">{<!-- --></span>x<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span>y<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是在实际项目中，往往需要对我们的自定义类型进行自定义的格式化输出，以让用户更好的阅读理解我们的类型，此时就要为自定义类型实现 <code>std::fmt::Display</code> 特征：</p> 
<pre><code class="prism language-rust"><span class="token attribute attr-name">#![allow(dead_code)]</span>

<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>fmt<span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>fmt<span class="token punctuation">::</span></span><span class="token punctuation">{<!-- --></span><span class="token class-name">Display</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token attribute attr-name">#[derive(Debug,PartialEq)]</span>
<span class="token keyword">enum</span> <span class="token type-definition class-name">FileState</span> <span class="token punctuation">{<!-- --></span>
  <span class="token class-name">Open</span><span class="token punctuation">,</span>
  <span class="token class-name">Closed</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">File</span> <span class="token punctuation">{<!-- --></span>
  name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
  data<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">u8</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  state<span class="token punctuation">:</span> <span class="token class-name">FileState</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Display</span> <span class="token keyword">for</span> <span class="token class-name">FileState</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">fn</span> <span class="token function-definition function">fmt</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Formatter</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Result</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">match</span> <span class="token operator">*</span><span class="token keyword">self</span> <span class="token punctuation">{<!-- --></span>
         <span class="token class-name">FileState</span><span class="token punctuation">::</span><span class="token class-name">Open</span> <span class="token operator">=&gt;</span> <span class="token macro property">write!</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token string">"OPEN"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
         <span class="token class-name">FileState</span><span class="token punctuation">::</span><span class="token class-name">Closed</span> <span class="token operator">=&gt;</span> <span class="token macro property">write!</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token string">"CLOSED"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Display</span> <span class="token keyword">for</span> <span class="token class-name">File</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">fn</span> <span class="token function-definition function">fmt</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Formatter</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Result</span> <span class="token punctuation">{<!-- --></span>
      <span class="token macro property">write!</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token string">"&lt;{} ({})&gt;"</span><span class="token punctuation">,</span>
             <span class="token keyword">self</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">File</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">File</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">File</span> <span class="token punctuation">{<!-- --></span>
        name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>
        data<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        state<span class="token punctuation">:</span> <span class="token class-name">FileState</span><span class="token punctuation">::</span><span class="token class-name">Closed</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> f6 <span class="token operator">=</span> <span class="token class-name">File</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"f6.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//...</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> f6<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> f6<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="73__503"></a>7.3 特征对象</h3> 
<p>可以通过 <code>&amp;</code> 引用或者 <code>Box&lt;T&gt;</code> 智能指针的方式来创建特征对象。</p> 
<pre><code class="prism language-rust"><span class="token keyword">trait</span> <span class="token type-definition class-name">Draw</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fn</span> <span class="token function-definition function">draw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Draw</span> <span class="token keyword">for</span> <span class="token keyword">u8</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fn</span> <span class="token function-definition function">draw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{<!-- --></span>
        <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"u8: {}"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">self</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Draw</span> <span class="token keyword">for</span> <span class="token keyword">f64</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">fn</span> <span class="token function-definition function">draw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{<!-- --></span>
        <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"f64: {}"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">self</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 若 T 实现了 Draw 特征， 则调用该函数时传入的 Box&lt;T&gt; 可以被隐式转换成函数参数签名中的 Box&lt;dyn Draw&gt;</span>
<span class="token keyword">fn</span> <span class="token function-definition function">draw1</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">dyn</span> <span class="token class-name">Draw</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 由于实现了 Deref 特征，Box 智能指针会自动解引用为它所包裹的值，然后调用该值对应的类型上定义的 `draw` 方法</span>
    x<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">draw2</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">dyn</span> <span class="token class-name">Draw</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    x<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1.1f64</span><span class="token punctuation">;</span>
    <span class="token comment">// do_something(&amp;x);</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">8u8</span><span class="token punctuation">;</span>

    <span class="token comment">// x 和 y 的类型 T 都实现了 `Draw` 特征，因为 Box&lt;T&gt; 可以在函数调用时隐式地被转换为特征对象 Box&lt;dyn Draw&gt; </span>
    <span class="token comment">// 基于 x 的值创建一个 Box&lt;f64&gt; 类型的智能指针，指针指向的数据被放置在了堆上</span>
    <span class="token function">draw1</span><span class="token punctuation">(</span><span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 基于 y 的值创建一个 Box&lt;u8&gt; 类型的智能指针</span>
    <span class="token function">draw1</span><span class="token punctuation">(</span><span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">draw2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">draw2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面代码，有几个非常重要的点：</p> 
<ul><li><code>draw1</code> 函数的参数是 <code>Box&lt;dyn Draw&gt;</code> 形式的特征对象，该特征对象是通过 <code>Box::new(x)</code> 的方式创建的</li><li><code>draw2</code> 函数的参数是 <code>&amp;dyn Draw</code> 形式的特征对象，该特征对象是通过 <code>&amp;x</code> 的方式创建的</li><li><code>dyn</code> 关键字只用在特征对象的类型声明上，在创建时无需使用 <code>dyn</code></li></ul> 
<p>因此，可以使用特征对象来代表泛型或具体的类型。</p> 
<p>泛型是在编译期完成处理的：编译器会为每一个泛型参数对应的具体类型生成一份代码，这种方式是<strong>静态分发(static dispatch)</strong>，因为是在编译期完成的，对于运行期性能完全没有任何影响。</p> 
<p>与静态分发相对应的是<strong>动态分发(dynamic dispatch)</strong>，在这种情况下，直到运行时，才能确定需要调用什么方法。之前代码中的关键字 <code>dyn</code> 正是在强调这一“动态”的特点。当使用特征对象时，Rust 必须使用动态分发。</p> 
<p>特征对象特点：</p> 
<ul><li>特征对象大小不固定（对于不同的类型可以实现相同特征）</li><li>几乎总是使用特征对象的引用方式，如 <code>&amp;dyn Draw</code>、<code>Box&lt;dyn Draw&gt;</code>（引用大小是固定的，占用两个指针大小：ptr-指向实现了特征的具体类型的实例/vptr-指向虚表vtable）</li></ul> 
<blockquote> 
 <p>在Rust中，一般<code>Self</code>代表类型，<code>self</code>指代当前实例对象。</p> 
</blockquote> 
<p>不是所有特征都能拥有特征对象，只有对象安全的特征才行。当一个特征的所有方法都有如下属性时，它的对象才是安全的：</p> 
<ul><li>方法的返回类型不能是 <code>Self</code></li><li>方法没有任何泛型参数</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13c5a714853f84b0b584667b47f756c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">@NoArgsConstructor注解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0e1777baac05e1d401f6506594743115/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;前置声明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>