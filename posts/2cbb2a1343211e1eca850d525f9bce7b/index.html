<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;智能指针 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;智能指针" />
<meta property="og:description" content="普通指针不足 new和new[] 的内存需要用delete和delete[]释放程序员的主观失误，忘了或漏了释放程序员也不知道何时释放内存 智能指针设计思路 智能指针是类模板，在栈上创建智能指针对象把普通指针交给智能指针对象智能指针对象过期时，调用析构函数释放普通指针的内存 智能指针类型 auto_ptr C&#43;&#43;&#43;98标准 但是C&#43;&#43;17已经弃用unique_ptr、shared_ptr和weak_ptr是C&#43;&#43;11的标准 unique_ptr 概念 指独享指向的对象。
同一时间只有一个unique_ptr指向同一个对象，当unique_ptr被销毁时，该对象也被销毁
用法 包含 memory 头文件
初始化 //方法一 unique_ptr&lt;CBB&gt;pp(new CBB(&#34;貂蝉&#34;,20));//分配内存并初始化 //方法二 C&#43;&#43;14标准 unique_ptr&lt;CBB&gt;p0= std::make_unique&lt;CBB&gt;(&#34;王昭君&#34;,21); //方法三 CBB *p = new CBB(&#34;西施&#34;,18); //假设我们忘记delete指针p了 那么不会调用析构函数 unique_ptr&lt;CBB&gt;pt(p);//我们使用unique_ptr智能指针管理p 用已经存在的地址初始化 使用 重载了-&gt;和*操作符，可以像使用指针一样使用unique_ptr不支持普通的拷贝和赋值不要用同一个裸指针（普通指针）初始化多个unique_ptr指针（会造成同一块内存多次释放，操作野指针）get方法返回裸指针 cout&lt;&lt;&#34;裸指针地址：&#34;&lt;&lt;pp.get()&lt;&lt;endl; cout&lt;&lt;&#34;pp的值：&#34;&lt;&lt;pp&lt;&lt;endl; cout&lt;&lt;&#34;pp的地址：&#34;&lt;&lt;&amp;pp&lt;&lt;endl; /* 裸指针地址：0x2be260c62d0 pp的值：0x2be260c62d0 pp的地址：0xff023ff808 */ 不要用unique_ptr管理不是new分配的内存用于函数参数 传引用（不能传值，因为没有拷贝构造函数）裸指针 不支持指针的运算（&#43;、-、&#43;&#43;、–） 更多技巧 1)将一个 unique ptr 赋给另一个时，如果源 unique_ptr 是一个临时右值，编译器允许这样做;如果源 unique ptr 将存在一段时间，编译器禁止这样做。一般用于函数的返回值 class CBB{ public: int cbb; string m_name; CBB(){ cout&lt;&lt;&#34;默认构造函数&#34;&lt;&lt;endl; } CBB(string name,int num):m_name(name),cbb(num){ cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2cbb2a1343211e1eca850d525f9bce7b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T16:58:49+08:00" />
<meta property="article:modified_time" content="2024-01-22T16:58:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;智能指针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>普通指针不足</h2> 
<ul><li>new和new[] 的内存需要用delete和delete[]释放</li><li>程序员的主观失误，忘了或漏了释放</li><li>程序员也不知道何时释放内存</li></ul> 
<h2><a id="_6"></a>智能指针设计思路</h2> 
<ul><li>智能指针是类模板，在栈上创建智能指针对象</li><li>把普通指针交给智能指针对象</li><li>智能指针对象过期时，调用析构函数释放普通指针的内存</li></ul> 
<h2><a id="_12"></a>智能指针类型</h2> 
<ul><li>auto_ptr C+++98标准 但是C++17已经弃用</li><li>unique_ptr、shared_ptr和weak_ptr是C++11的标准</li></ul> 
<h2><a id="unique_ptr_17"></a>unique_ptr</h2> 
<h3><a id="_19"></a>概念</h3> 
<p>指独享指向的对象。<br> 同一时间只有一个unique_ptr指向同一个对象，当unique_ptr被销毁时，该对象也被销毁</p> 
<h3><a id="_26"></a>用法</h3> 
<p>包含 <code>memory</code> 头文件<br> <img src="https://images2.imgbox.com/48/0e/szmwuDU8_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_32"></a>初始化</h4> 
<pre><code class="prism language-cpp">    <span class="token comment">//方法一</span>
    unique_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token function">pp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"貂蝉"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配内存并初始化</span>

    <span class="token comment">//方法二 C++14标准</span>
    unique_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span>p0<span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"王昭君"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//方法三</span>
    CBB <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"西施"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//假设我们忘记delete指针p了 那么不会调用析构函数</span>
    unique_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token function">pt</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//我们使用unique_ptr智能指针管理p 用已经存在的地址初始化</span>
</code></pre> 
<h4><a id="_46"></a>使用</h4> 
<ul><li>重载了-&gt;和*操作符，可以像使用指针一样使用unique_ptr</li><li><strong>不支持普通的拷贝和赋值</strong></li><li>不要用同一个裸指针（普通指针）初始化多个unique_ptr指针（会造成同一块内存多次释放，操作野指针）</li><li>get方法返回裸指针</li></ul> 
<pre><code class="prism language-cpp">    cout<span class="token operator">&lt;&lt;</span><span class="token string">"裸指针地址："</span><span class="token operator">&lt;&lt;</span>pp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"pp的值："</span><span class="token operator">&lt;&lt;</span>pp<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"pp的地址："</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>pp<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token comment">/*
裸指针地址：0x2be260c62d0
pp的值：0x2be260c62d0
pp的地址：0xff023ff808
*/</span>
</code></pre> 
<ul><li>不要用unique_ptr管理不是new分配的内存</li><li><strong>用于函数参数</strong> 
  <ul><li>传引用（不能传值，因为没有拷贝构造函数）</li><li>裸指针</li></ul> </li><li>不支持指针的运算（+、-、++、–）</li></ul> 
<h4><a id="_68"></a>更多技巧</h4> 
<ul><li>1)将一个 unique ptr 赋给另一个时，如果源 unique_ptr 是一个<strong>临时右值</strong>，编译器<strong>允许</strong>这样做;如果源 unique ptr 将<strong>存在一段时间</strong>，编译器<strong>禁止</strong>这样做。<strong>一般用于函数的返回值</strong></li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">CBB</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> cbb<span class="token punctuation">;</span>
    string m_name<span class="token punctuation">;</span>
    <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"默认构造函数"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">CBB</span><span class="token punctuation">(</span>string name<span class="token punctuation">,</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">m_name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">cbb</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"带参数的构造函数"</span><span class="token operator">&lt;&lt;</span>name<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">CBB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"析构函数"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

unique_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    unique_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"小乔"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

    unique_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token function">p0</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"貂蝉"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    unique_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span>p1<span class="token punctuation">;</span>
    <span class="token comment">// p1=p0;//报错 这样不可以 因为p0还存在</span>
    <span class="token comment">// 匿名对象赋值  允许 匿名对象仅存活在该语句，是临时的</span>
    p1<span class="token operator">=</span> <span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"妲己"</span><span class="token punctuation">,</span><span class="token number">2100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout<span class="token operator">&lt;&lt;</span><span class="token string">"fun之前"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token comment">//本身p1管理这name为妲己的CBB对象，但是此时p1管理fun返回的CBB对象，那么赋值完毕之后要释放</span>
    p1<span class="token operator">=</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里能接受的原因时fun返回的是临时对象，如果返回的是全局变量那么肯定报错</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"fun之后"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>

<span class="token comment">/*
带参数的构造函数貂蝉
带参数的构造函数妲己
fun之前
带参数的构造函数小乔
析构函数
fun之后
析构函数
析构函数
*/</span>
</code></pre> 
<ul><li>2)用 <strong>nullptr给 unique_ptr 赋值将释放对象</strong>，空的 unique_ptr==nullptr</li></ul> 
<pre><code class="prism language-cpp">    unique_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token function">p0</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"貂蝉"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配内存并初始化</span>
    p0<span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"p0=nullptr"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token comment">/*
带参数的构造函数貂蝉
析构函数
p0=nullptr
*/</span>
<span class="token comment">//析构函数先于最后一个调试语句输出，说明给智能指针赋值nullptr后就释放了对象</span>
</code></pre> 
<ul><li>3)release()释放对原始指针的控制权，将 unique_ptr 置为空，<strong>返回裸指针</strong>。(可用于把 unique_ptr传递给子函数，子函数将负责释放对象)</li><li>4)std:.move()可以转移对原始指针的控制权。(可用于把 unique ptr 传递给子函数，子函数形参<br> 也是 unique ptr)</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">const</span> CBB<span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">-&gt;</span>m_name<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span>CBB<span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">-&gt;</span>m_name<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">func3</span><span class="token punctuation">(</span>unique_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span>c<span class="token operator">-&gt;</span>m_name<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">func4</span><span class="token punctuation">(</span>unique_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span>c<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span>c<span class="token operator">-&gt;</span>m_name<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">//func1 2 3 4要一个一个调用</span>
    unique_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token function">pu</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"貂蝉"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配内存并初始化</span>

    cout<span class="token operator">&lt;&lt;</span><span class="token string">"开始调用函数"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token function">func1</span><span class="token punctuation">(</span>pu<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//函数需要一个裸指针，但是不对裸指针负责（不释放）</span>
    <span class="token comment">/*
    开始调用函数
    貂蝉
    调用函数完成
    析构函数
    */</span>
    <span class="token function">func2</span><span class="token punctuation">(</span>pu<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//函数需要一个裸指针，并且对裸指针负责（释放）</span>
    <span class="token comment">/*
     开始调用函数
    貂蝉
    析构函数
    调用函数完成
      */</span>

    <span class="token function">func3</span><span class="token punctuation">(</span>pu<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//函数需要一个unique_ptr指针，但是不对裸指针负责（不释放）</span>
    <span class="token comment">/*
    开始调用函数
    貂蝉
    调用函数完成
    析构函数
     * */</span>

    <span class="token comment">//move将对裸指针的控制权交给函数形参</span>
    <span class="token function">func4</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//函数需要一个unique_ptr指针，并且对裸指针负责（释放）</span>
    <span class="token comment">/*
    开始调用函数
    貂蝉
    析构函数
    调用函数完成
     */</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"调用函数完成"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>

</code></pre> 
<ul><li>5)reset()释放对象</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span>T<span class="token operator">*</span>_ptr<span class="token operator">=</span><span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放p指向的资源对象</span>
p<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放p指向的资源对象</span>
p<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">AA</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放p指向的资源对象，同时指向新的对象</span>
</code></pre> 
<ul><li>6)swap()交换两个 unique_ptr 的控制权。</li><li>7)<strong>unique_ptr</strong> 也可象普通指针那样，当指向一个类继承体系的基类对象时，也具有<strong>多态性质</strong>，如同使用裸指针管理基类对象和派生类对象那样</li><li>8)unique_ptr不是绝对安全的，如果调用exit()退出，全局的unique_ptr指针可以自动释放，但是局部的unique_ptr指针不可以自动释放</li><li>9)unique_ptr提供了支持数组的具体化版本</li></ul> 
<pre><code class="prism language-cpp">unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不指定初始值</span>
unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token function">p</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//指定初始值</span>
</code></pre> 
<h2><a id="shared_ptr_210"></a>shared_ptr</h2> 
<h3><a id="_212"></a>概念</h3> 
<p>共享它指向的对象<br> 多个shared ptr 可以指向(关联)相同的对象，在内部采用计数机制来实现<br> 当新的shared_ptr与对象关联时，引用计数器+1<br> 当shared_ptr超出作用域时，引用计数器-1<br> 引用计数器=0，没有任何的shared_ptr与对象关联，释放该对象</p> 
<h3><a id="_220"></a>用法</h3> 
<p>shared_ptr的构造函数也是explicit，但是没有删除拷贝构造和赋值函数</p> 
<h4><a id="_224"></a>初始化</h4> 
<pre><code class="prism language-cpp">    <span class="token comment">//方法一</span>
    shared_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token function">pp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"貂蝉"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配内存并初始化</span>

    <span class="token comment">//方法二 C++11标准</span>
    shared_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span>p0<span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"王昭君"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//方法三</span>
    CBB <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"西施"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token function">pt</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用已经存在的地址初始化</span>

	<span class="token comment">//方法四</span>
	CBB <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"西施"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token function">pt</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用已经存在的地址初始化</span>
    shared_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span>p1 <span class="token operator">=</span> pt<span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token function">p2</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_242"></a>使用</h4> 
<ul><li>重载了-&gt;和*操作符，可以像使用指针一样使用unique_ptr</li><li><code>use_count</code>方法返回引用计数器的值</li><li><code>unique()</code>方法，如果 use count()为1，返回 true，否则返回 false</li><li>支持普通的拷贝和赋值,<strong>左值的 shared_ptr 的计数器将减1,右值 shared_ptr 的计算器将加 1</strong></li><li>不要用同一个裸指针（普通指针）初始化多个<code>shared_ptr</code>指针（会造成同一块内存多次释放，操作野指针）</li><li><code>get</code>方法返回裸指针</li><li>不要用<code>shared_ptr</code>管理不是new分配的内存</li></ul> 
<h4><a id="_251"></a>更多技巧</h4> 
<ul><li>1)用 <strong>nullptr给 shared_ptr 赋值将把计数器-1</strong></li><li>2)std:.move()可以转移对原始指针的控制权。还可以把unique_ptr转移成shared_ptr 反过来不行</li><li>3)reset</li><li>4)swap</li><li>5)<strong>shared_ptr ** 也可象普通指针那样，当指向一个类继承体系的基类对象时，也具有</strong>多态性质**，如同使用裸指针管理基类对象和派生类对象那样</li><li>6)shared_ptr 不是绝对安全的，如果调用exit()退出，<strong>全局的shared_ptr 指针可以自动释放，但是局部的shared_ptr 指针不可以自动释放</strong></li><li>7)shared_ptr 提供了支持数组的具体化版本</li><li>8)shared_ptr 的引用计数本身就是线程安全（引用计数是原子操作）<br> <img src="https://images2.imgbox.com/d5/8b/AfKF8pku_o.png" alt="在这里插入图片描述"></li><li>9)如果 <strong>unique_ptr 能解决问题，就不要用 shared ptr</strong>。unique ptr 的效率更高，占用的资源更少</li></ul> 
<h2><a id="_265"></a>智能指针删除器</h2> 
<p>在默认情况下，智能指针过期的时候，用 delete 原始指针;释放它管理的资源</p> 
<p>程序员可以自定义删除器，改变智能指针释放资源的行为。</p> 
<p>删除器可以是全局函数、仿函数和 Lambda 表达式，形参为原始指针（裸指针）</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">deletefunc</span><span class="token punctuation">(</span>CBB<span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"自定义删除器（全局函数）"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">deleteclass</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>CBB<span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"自定义删除器（仿函数）"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"xx"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>deletefunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>CBB<span class="token operator">&gt;</span><span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"xxxxx"</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">deleteclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    unique_ptr<span class="token operator">&lt;</span>CBB<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>deletefunc<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token function">p3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"ddd"</span><span class="token punctuation">,</span><span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deletefunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    unique_ptr<span class="token operator">&lt;</span>CBB<span class="token punctuation">,</span> deleteclass<span class="token operator">&gt;</span><span class="token function">p4</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">CBB</span><span class="token punctuation">(</span><span class="token string">"ddd"</span><span class="token punctuation">,</span><span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">deleteclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="weak_ptr_295"></a>weak_ptr</h2> 
<h3><a id="shared_ptr_297"></a>shared_ptr存在的问题</h3> 
<p>shared ptr 内部维护了一个共享的引用计数器，多个 shared ptr 可以指向同一个资源</p> 
<p>如果出现了<strong>循环引用</strong>的情况，引用计数永远无法归0，<strong>资源不会被释放</strong></p> 
<h3><a id="weak_ptr_303"></a>weak_ptr是什么</h3> 
<p>weak ptr 是为了配合 shared ptr 而引入的，它指向一个由 shared ptr 管理的资源但不影响资源的生命周期</p> 
<p>也就是说，将一个weak ptr 绑定到一个shared ptr 不会改变 shared ptr 的引用计数</p> 
<p>不论是否有 weak ptr 指向，如果最后一个指向资源的 shared ptr 被销毁，资源就会被释放</p> 
<p>weak ptr 更像是 shared ptr 的助手而不是智能指针</p> 
<h3><a id="_315"></a>使用</h3> 
<p>weak_ptr没有重载 -&gt; 和 * 不能直接访问资源</p> 
<p><img src="https://images2.imgbox.com/e8/82/sSB4snv6_o.png" alt="在这里插入图片描述"></p> 
<p><strong>weak_ptr精髓：</strong></p> 
<ul><li>weak_ptr 不控制对象的生命周期，但是知道对象是否还活着</li><li>用lock成员函数可以提升为shared_ptr</li><li>提升的行为lock是线程安全的</li></ul> 
<p>weak_ptr和shared_ptr主要用于多线程的问题</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0d6ccd1648766c9ee30d08ed0733249d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">架构篇01：架构的简介，到底什么是架构？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/673d15730dd437d2fe37754cfc3ce132/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">.net系列环境包，需要的滴滴</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>