<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>交换排序算法之快速排序-C语言版（带图详细） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="交换排序算法之快速排序-C语言版（带图详细）" />
<meta property="og:description" content="文章目录 前言一、什么是快速排序？二、算法思想三、实例讲解四、算法分析1.时间复杂度2.空间复杂度 五、代码实现六、运行结果总结 前言 哈喽，大家好，我最近在复习数据结构中的排序算法章节，今天复习到了交换排序算法中的快速排序算法，所以给大家分享一下。
一、什么是快速排序？ 快速排序算法是在几种排序算法中效率最高的一个排序算法了，故称为快速排序，它的时间复杂度为：O(nlog2n)，相比冒泡排序算法的O(n2)有很大的提升。
二、算法思想 1、选取一个基准元素（一般我们将待排序序列中的第一个元素选取为基准元素）
2、将其他元素与基准元素进行比较，比基准元素大的放到基准元素的右边，比基准元素小的放到基准元素的右边。（以基准元素为中心将元素重新分成两个序列，并返回基准元素的下标）
3、将新生成的两个序列继续执行1和2两步（此处可以用递归实现）
接下来我们通过一个动图来看一下快速排序算法。
三、实例讲解 我们有一个待排序序列是：【 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48】
第一轮排序：
①选取第一个元素44为基准坐标。
②以44为中心，将序列分为两部分，左边比44小，右边比44大。
③原来的序列被分成两部分，一部分比44小的是【0，基准坐标-1】，另一部分比44大的是【基准坐标&#43;1，最后】，将这两部分继续执行①和②两步最终即可排序完成。
第一轮排序总结： 算法思想其实不难理解，那么接下来需要解决的问题就是，如何将一个序列以基准坐标分成相对有序的两部分，以及递归出口问题。
四、算法分析 1.时间复杂度 O(nlog2n)
2.空间复杂度 空间复杂度由于需要开辟一个临时空间来存储基准坐标所以是：O(1)
五、代码实现 #include&lt;stdio.h&gt; void Print(int array[],int len){ for(int i=0;i&lt;len;i&#43;&#43;){ printf(&#34;%d &#34;,array[i]); } printf(&#34;\n&#34;); } /*获取基准坐标，并相对有序（左边比基准坐标小，右边比基准坐标大）*/ int getStandard(int array[],int low,int high) { int key = array[low]; //临时保存基准元素 while(low&lt;high) { //high指针从后向前遍历 ， 元素比基准元素大则指针向前移动 则比基准元素小则和基准元素交换 while(low&lt;high &amp;&amp; array[high]&gt;=key){ high--; } if(low&lt;high){ array[low] = array[high]; //赋值给第一个元素，因为第一个元素作为基准元素已经临时保存了，所可以直接赋值 } //low指针从前向后遍历 ， 元素比基准元素小则指针向后移动 否则比基准元素大则和基准元素交换 while(low&lt;high &amp;&amp; array[low]&lt;=key){ low&#43;&#43;; } if(low&lt;high){ array[high] = array[low]; //复制给high指针所指得位置，因为在11行已经赋值给array[low]了 } } array[low] = key; return low; } void QuickSort(int array[],int low,int high){ if(low&lt;high){ //递归出口 int standard = getStandard(array,low,high); QuickSort(array,low,standard-1); //比基准元素小的部分继续调用快速排序 QuickSort(array,standard&#43;1,high); //比基准元素大的部分继续调用快速排序 } } int main(){ int array[] = {3, 44, 38, 5, 47, 15, 36}; int size = sizeof(array) / sizeof(int); printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/43a183d1fd411766ba925b90fb751b99/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-03T20:44:47+08:00" />
<meta property="article:modified_time" content="2021-04-03T20:44:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">交换排序算法之快速排序-C语言版（带图详细）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#_4" rel="nofollow">一、什么是快速排序？</a></li><li><a href="#_8" rel="nofollow">二、算法思想</a></li><li><a href="#_17" rel="nofollow">三、实例讲解</a></li><li><a href="#_31" rel="nofollow">四、算法分析</a></li><li><ul><li><a href="#1_32" rel="nofollow">1.时间复杂度</a></li><li><a href="#2_34" rel="nofollow">2.空间复杂度</a></li></ul> 
  </li><li><a href="#_36" rel="nofollow">五、代码实现</a></li><li><a href="#_85" rel="nofollow">六、运行结果</a></li><li><a href="#_89" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p>哈喽，大家好，我最近在复习数据结构中的排序算法章节，今天复习到了交换排序算法中的快速排序算法，所以给大家分享一下。</p> 
<h2><a id="_4"></a>一、什么是快速排序？</h2> 
<p>快速排序算法是在几种排序算法中效率最高的一个排序算法了，故称为快速排序，它的时间复杂度为：O(nlog<sub>2</sub>n)，相比冒泡排序算法的O(n<sup>2</sup>)有很大的提升。</p> 
<h2><a id="_8"></a>二、算法思想</h2> 
<p>1、选取一个基准元素（一般我们将待排序序列中的<strong>第一个元素</strong>选取为基准元素）<br> 2、将其他元素与基准元素进行比较，比基准元素大的放到基准元素的右边，比基准元素小的放到基准元素的右边。（<strong>以基准元素为中心将元素重新分成两个序列</strong>，<strong>并返回基准元素的下标</strong>）<br> 3、将新生成的两个序列继续执行1和2两步（此处可以用递归实现）</p> 
<p>接下来我们通过一个动图来看一下快速排序算法。<br> <img src="https://images2.imgbox.com/67/c5/NXaw0WrO_o.gif" alt="快速排序"></p> 
<h2><a id="_17"></a>三、实例讲解</h2> 
<p>我们有一个待排序序列是：【 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48】<br> <img src="https://images2.imgbox.com/79/79/2JhS1cSh_o.png" alt="在这里插入图片描述"></p> 
<p><font color="red">第一轮排序：</font></p> 
<p>①选取第一个元素44为基准坐标。<br> <img src="https://images2.imgbox.com/2b/44/DXlhnTYq_o.png" alt="在这里插入图片描述"></p> 
<p>②以44为中心，将序列分为两部分，左边比44小，右边比44大。<br> <img src="https://images2.imgbox.com/d9/0f/5Nn5vGZx_o.png" alt="在这里插入图片描述"><br> ③原来的序列被分成两部分，<strong>一部分比44小的是【0，基准坐标-1】，另一部分比44大的是【基准坐标+1，最后】</strong>，将这两部分继续执行①和②两步最终即可排序完成。</p> 
<p><strong>第一轮排序总结：</strong> 算法思想其实不难理解，<font color="red">那么接下来需要解决的问题就是，如何将一个序列以基准坐标分成<strong>相对有序</strong>的两部分，</font>以及递归出口问题。</p> 
<h2><a id="_31"></a>四、算法分析</h2> 
<h3><a id="1_32"></a>1.时间复杂度</h3> 
<p>O(nlog<sub>2</sub>n)</p> 
<h3><a id="2_34"></a>2.空间复杂度</h3> 
<p>空间复杂度由于需要开辟一个临时空间来存储基准坐标所以是：O(1)</p> 
<h2><a id="_36"></a>五、代码实现</h2> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
<span class="token comment">/*获取基准坐标，并相对有序（左边比基准坐标小，右边比基准坐标大）*/</span>
<span class="token keyword">int</span> <span class="token function">getStandard</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> key <span class="token operator">=</span> array<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//临时保存基准元素 </span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
		<span class="token comment">//high指针从后向前遍历 ， 元素比基准元素大则指针向前移动 则比基准元素小则和基准元素交换 </span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">&gt;=</span>key<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			high<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			array<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//赋值给第一个元素，因为第一个元素作为基准元素已经临时保存了，所可以直接赋值 </span>
		<span class="token punctuation">}</span>
		<span class="token comment">//low指针从前向后遍历 ， 元素比基准元素小则指针向后移动 否则比基准元素大则和基准元素交换 </span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">&lt;=</span>key<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			low<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			array<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//复制给high指针所指得位置，因为在11行已经赋值给array[low]了 </span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	array<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
	<span class="token keyword">return</span> low<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">//递归出口 </span>
		<span class="token keyword">int</span> standard <span class="token operator">=</span> <span class="token function">getStandard</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>low<span class="token punctuation">,</span>standard<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//比基准元素小的部分继续调用快速排序 </span>
		<span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>standard<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//比基准元素大的部分继续调用快速排序 </span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 	<span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始序列为：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Print</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后序列为：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Print</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> 
</code></pre> 
<h2><a id="_85"></a>六、运行结果</h2> 
<p><img src="https://images2.imgbox.com/01/75/MiRHdJ9O_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_89"></a>总结</h2> 
<p>最后，我们只需要记住快速排序的算法思想（两步）以及如何通过两个指针来实现将待排序序列分成两部分即可。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/758bfb4fc9133d7f92f02e776006c81d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LIKE运算符</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/472be9b1168cb9fd71b8cea95f231ad5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Alexnet模型识别猫和狗</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>