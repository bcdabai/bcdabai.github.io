<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Shell编程及自动化运维实现 第5章 三剑客 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Shell编程及自动化运维实现 第5章 三剑客" />
<meta property="og:description" content="文章目录 正则表达式名词解释工具场景示例 元字符定义分类基本正则表达式元字符扩展正则表达式元字符 grep目的分类grepegrepfgrep 返回值参数示例 sed格式返回值sed和正则表达式汇总示例删除命令： d替换命令： s读文件命令：r写文件命令：w(另存为)追加命令： a（之后）插入命令： i（之前）替换整行命令： c获取下一行命令：n多重编辑 e实战案例 awk1.前言2.工作原理3.语法内部变量① FS② OFS③ RS④ ORS⑤ FNR ，NR⑥ NF 格式化输出① print 函数② printf 函数 模式（正则表达）和动作① 字符串比较② 数值比较 awk脚本编程变量条件判断循环数组awk编程案例 正则表达式 名词解释 正则表达式（regular expression, RE）是一种字符模式， 用于在查找过程中匹配指定的字符。 在大多数程序里，正则表达式都被置于两个正斜杠之间； 例如/l[oO]ve/就是由正斜杠界定的正则表达式， 它将匹配被查找的行中任何位置出现的相同模式。 在正则表达式中，元字符是最重要的概念。 工具 被vim、sed、awk、grep调用 场景 mysql、oracle、php、python ，Apache，Nginx... 需要正则 示例 需求 匹配数字的脚本：用户输入创建账号的数量 语法 [[ ^[0-9]&#43;$ ]] 示范 read -p &#34;输入数字才退出: &#34; num while : do if [[ ! $num =~ ^[0-9]&#43;$ ]];then echo &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4bc6b7d18109df185c226632f1a0d999/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-09T15:18:19+08:00" />
<meta property="article:modified_time" content="2020-09-09T15:18:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Shell编程及自动化运维实现 第5章 三剑客</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_7" rel="nofollow"></a></li><li><a href="#_10" rel="nofollow">正则表达式</a></li><li><ul><li><ul><li><a href="#_11" rel="nofollow">名词解释</a></li><li><a href="#_19" rel="nofollow">工具</a></li><li><a href="#_21" rel="nofollow">场景</a></li><li><a href="#_23" rel="nofollow">示例</a></li></ul> 
   </li><li><a href="#_46" rel="nofollow">元字符</a></li><li><ul><li><a href="#_47" rel="nofollow">定义</a></li><li><a href="#_49" rel="nofollow">分类</a></li><li><ul><li><a href="#_50" rel="nofollow">基本正则表达式元字符</a></li><li><a href="#_197" rel="nofollow">扩展正则表达式元字符</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#grep_270" rel="nofollow">grep</a></li><li><ul><li><a href="#_271" rel="nofollow">目的</a></li><li><a href="#_273" rel="nofollow">分类</a></li><li><ul><li><a href="#grep_274" rel="nofollow">grep</a></li><li><a href="#egrep_276" rel="nofollow">egrep</a></li><li><a href="#fgrep_287" rel="nofollow">fgrep</a></li></ul> 
   </li><li><a href="#_292" rel="nofollow">返回值</a></li><li><a href="#_314" rel="nofollow">参数</a></li><li><a href="#_351" rel="nofollow">示例</a></li></ul> 
  </li><li><a href="#sed_389" rel="nofollow">sed</a></li><li><ul><li><a href="#_399" rel="nofollow">格式</a></li><li><a href="#_404" rel="nofollow">返回值</a></li><li><a href="#sed_408" rel="nofollow">sed和正则表达式</a></li><li><a href="#_416" rel="nofollow">汇总示例</a></li><li><ul><li><a href="#___d_417" rel="nofollow">删除命令： d</a></li><li><a href="#___s_434" rel="nofollow">替换命令： s</a></li><li><a href="#r_458" rel="nofollow">读文件命令：r</a></li><li><a href="#w_467" rel="nofollow">写文件命令：w(另存为)</a></li><li><a href="#___a_471" rel="nofollow">追加命令： a（之后）</a></li><li><a href="#___i_479" rel="nofollow">插入命令： i（之前）</a></li><li><a href="#___c_491" rel="nofollow">替换整行命令： c</a></li><li><a href="#n_509" rel="nofollow">获取下一行命令：n</a></li><li><a href="#___e_540" rel="nofollow">多重编辑 e</a></li><li><a href="#_553" rel="nofollow">实战案例</a></li></ul> 
  </li></ul> 
  </li><li><a href="#awk_585" rel="nofollow">awk</a></li><li><ul><li><a href="#1_586" rel="nofollow">1.前言</a></li><li><a href="#2_597" rel="nofollow">2.工作原理</a></li><li><a href="#3_607" rel="nofollow">3.语法</a></li><li><a href="#_624" rel="nofollow">内部变量</a></li><li><ul><li><a href="#_FS_625" rel="nofollow">① FS</a></li><li><a href="#_OFS_638" rel="nofollow">② OFS</a></li><li><a href="#_RS_647" rel="nofollow">③ RS</a></li><li><a href="#_ORS_661" rel="nofollow">④ ORS</a></li><li><a href="#_FNR_NR_663" rel="nofollow">⑤ FNR ，NR</a></li><li><a href="#_NF_678" rel="nofollow">⑥ NF</a></li></ul> 
   </li><li><a href="#_691" rel="nofollow">格式化输出</a></li><li><ul><li><a href="#_print___692" rel="nofollow">① print 函数</a></li><li><a href="#_printf__705" rel="nofollow">② printf 函数</a></li></ul> 
   </li><li><a href="#_743" rel="nofollow">模式（正则表达）和动作</a></li><li><ul><li><a href="#__751" rel="nofollow">① 字符串比较</a></li><li><a href="#__759" rel="nofollow">② 数值比较</a></li></ul> 
  </li></ul> 
  </li><li><a href="#awk_786" rel="nofollow">awk脚本编程</a></li><li><ul><li><a href="#_787" rel="nofollow">变量</a></li><li><a href="#_806" rel="nofollow">条件判断</a></li><li><a href="#_826" rel="nofollow">循环</a></li><li><a href="#_852" rel="nofollow">数组</a></li><li><a href="#awk_876" rel="nofollow">awk编程案例</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr color="#000000" size='1"'> 
<h2><a id="_7"></a></h2> 
<h2><a id="_10"></a>正则表达式</h2> 
<h4><a id="_11"></a>名词解释</h4> 
<pre><code>正则表达式（regular expression, RE）是一种字符模式，
用于在查找过程中匹配指定的字符。
在大多数程序里，正则表达式都被置于两个正斜杠之间；
例如/l[oO]ve/就是由正斜杠界定的正则表达式，
它将匹配被查找的行中任何位置出现的相同模式。
在正则表达式中，元字符是最重要的概念。
</code></pre> 
<h4><a id="_19"></a>工具</h4> 
<pre><code>被vim、sed、awk、grep调用
</code></pre> 
<h4><a id="_21"></a>场景</h4> 
<pre><code>mysql、oracle、php、python ，Apache，Nginx...  需要正则
</code></pre> 
<h4><a id="_23"></a>示例</h4> 
<pre><code>需求
	匹配数字的脚本：用户输入创建账号的数量
语法
	[[ ^[0-9]+$ ]]
示范
	read -p "输入数字才退出:  " num

while :
do

if [[ ! $num =~ ^[0-9]+$ ]];then
    echo "error enter!"
    read -p "输入数字才退出：" num
else
    echo "thank you"
    exit 1
fi
done
</code></pre> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/eb/bd/cSe13HNJ_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/c8/9c/FH8nTqfN_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_46"></a>元字符</h3> 
<h4><a id="_47"></a>定义</h4> 
<pre><code>元字符是这样一类字符，它们表达的是不同于字面本身的含义
</code></pre> 
<h4><a id="_49"></a>分类</h4> 
<h5><a id="_50"></a>基本正则表达式元字符</h5> 
<pre><code>^
行首定位符
</code></pre> 
<blockquote> 
 <p>❌[root@localhost ~]# grep “root” /etc/passwd<br> <strong>root: x :0:0:root:/root:/bin/bash<br> operator: x :11:0:operator:/root:/sbin/nologin</strong><br> <br> <br> [root@localhost ~]# grep “^root” /etc/passwd<br> 为什么什么少一行？<br> <strong>root: x :0:0:root:/root:/bin/bash</strong></p> 
</blockquote> 
<pre><code>[^]
匹配不在指定组内的字符
	[^a-z0-9]ove          //取反
</code></pre> 
<blockquote> 
 <p>❌[root@localhost~]# cat 1.txt<br> love<br> 1ove<br> |ove<br> <br> [root@localhost~]# grep [0-9a-Z]ove 1.txt<br> love<br> 1ove<br> [root@localhost ~]# grep [^0-9a-Z]ove 1.txt<br> |ove</p> 
</blockquote> 
<pre><code>$
行尾定位符
</code></pre> 
<blockquote> 
 <p>❌[root@mycat ~]# grep “gin$” passwd<br> <strong>mail: x :8:12:mail:/var/spool/mail:/sbin/nologin</strong></p> 
</blockquote> 
<pre><code>.
匹配任意单个字符
</code></pre> 
<blockquote> 
 <p>❌[root@localhost ~]# grep abc 1.txt<br> abc<br> [root@localhost ~]# grep adc 1.txt<br> adc<br> [root@localhost ~]# grep a.c 1.txt<br> abc<br> adc</p> 
</blockquote> 
<pre><code>*
匹配前导符0到多次
</code></pre> 
<blockquote> 
 <p>❌[root@localhost ~]# cat 1.txt<br> a<br> ab<br> abc<br> abcd<br> abcde<br> abcdef<br> ggg<br> hhh<br> iii<br> [root@localhost ~]# grep “abc*” 1.txt<br> ab<br> abc<br> abcd<br> abcde<br> abcdef<br> [root@localhost ~]# grep “abcd*” 1.txt<br> abc<br> abcd<br> abcde<br> abcdef</p> 
</blockquote> 
<pre><code>.*
任意多个字符
</code></pre> 
<blockquote> 
 <p>❌[root@localhost ~]# grep ".* " 1.txt<br> a<br> ab<br> abc<br> abcd<br> abcde<br> abcdef<br> ggg<br> hhh<br> iii<br> 为什么*.不好使？</p> 
</blockquote> 
<pre><code>[ ]
匹配指定范围内的一个字符
</code></pre> 
<blockquote> 
 <p>❌[lL]ove<br> 搜索love不论大小写</p> 
</blockquote> 
<pre><code>[ - ]
匹配指定范围内的一个字符,连续的范围
</code></pre> 
<blockquote> 
 <p>❌[a-z0-9]ove //[a-Z]=[a-zA-Z]</p> 
</blockquote> 
<pre><code>\
用来转义元字符	(''   ""    \)，脱意符
</code></pre> 
<blockquote> 
 <p>❌[root@localhost ~]# grep “l.” 1.txt<br> love<br> l.ve<br> [root@localhost ~]# grep “l.” 1.txt<br> l.ve</p> 
</blockquote> 
<pre><code>\&lt;
词首定位符
</code></pre> 
<blockquote> 
 <p>❌[root@localhost ~]# grep “love” 1.txt<br> love<br> iloveyou<br> [root@localhost ~]# grep “\ &lt;love” 1.txt<br> love<br> <br> \ &gt;<br> 词尾定位符<br> love&gt;</p> 
</blockquote> 
<pre><code>()
\(..\)
匹配稍后使用的字符的标签
</code></pre> 
<blockquote> 
 <p>❌:% s/172.16.130.1/172.16.130.5/<br> :% s/(172.16.130.)1/\15/<br> :% s/(172.)(16.)(130.)1/\1\2\35/<br> :3,9 s/(.*)/#\1/ 加注释</p> 
</blockquote> 
<pre><code>x\{m\}
字符x重复出现m次
</code></pre> 
<blockquote> 
 <p>❌[root@localhost ~]# grep o 1.txt<br> love<br> loove<br> looove<br> [root@localhost ~]# grep “o{3}” 1.txt<br> looove</p> 
</blockquote> 
<pre><code>x\{m,\}
字符x重复出现m次以上
	o\{5,\}
</code></pre> 
<p>❌</p> 
<pre><code>x\{m,n\}
字符x重复出现m到n次
	o\{5,10\}
</code></pre> 
<blockquote> 
 <p>[root@localhost ~]# egrep “o{4,5}” 1.txt<br> oooo<br> ooooo<br> ioooo<br> ooooi<br> iooooi<br> [root@localhost ~]# egrep “o{5,5}” 1.txt<br> ooooo</p> 
</blockquote> 
<hr> 
<h5><a id="_197"></a>扩展正则表达式元字符</h5> 
<p><strong><mark>egrep</mark></strong></p> 
<pre><code>+
匹配1~n个前导字符
</code></pre> 
<blockquote> 
 <p>[root@localhost ~]# cat 1.txt<br> lve<br> love<br> loove<br> [root@localhost ~]# egrep lo+ve 1.txt<br> love<br> loove</p> 
</blockquote> 
<pre><code>?
匹配0~1个前导字符
	lo?ve ：？前面的o 有还是没有，都行！
</code></pre> 
<blockquote> 
 <p>[root@localhost ~]# egrep lo?ve tom.sh<br> love<br> lve</p> 
</blockquote> 
<pre><code>a|b
匹配a或b
</code></pre> 
<blockquote> 
 <p>[root@localhost ~]# egrep “o|v” 1.txt<br> lve<br> 1ove<br> loove<br> looove<br> loeve<br> love<br> Love<br> iloveyou<br> l.ve<br> o<br> oo<br> ooo<br> oooo<br> ooooo<br> ioooo<br> ooooi<br> iooooi</p> 
</blockquote> 
<pre><code>()
组字符
</code></pre> 
<blockquote> 
 <p>[root@localhost ~]# egrep “loveable|rs” 1.txt<br> rs<br> loveable<br> lovers<br> [root@localhost ~]# egrep “love(able|rs)” 1.txt<br> loveable<br> lovers</p> 
</blockquote> 
<hr> 
<pre><code>示例1
grep   love    1.txt
	找love
/^love/
	以love开头
/love$/
	以love结尾
/l.ve/
	l开始，一个任意字符，ve结尾
/lo*ve/
	l开始，零个或多个o，ve结尾
/[Ll]ove/
	大L 或者小L 开头的  ove
/love[a-z]/
	love最后一个小写字母
/love[^a-zA-Z0-9]/
	love最后一个（不是字母或者数字），而是符号
		[root@localhost ~]# egrep  "love[^a-zA-Z0-9]" 1.txt 
love,
love?
</code></pre> 
<hr> 
<h2><a id="grep_270"></a>grep</h2> 
<h3><a id="_271"></a>目的</h3> 
<pre><code>过滤，查找文档中的内容
</code></pre> 
<h3><a id="_273"></a>分类</h3> 
<h4><a id="grep_274"></a>grep</h4> 
<pre><code>略
</code></pre> 
<h4><a id="egrep_276"></a>egrep</h4> 
<p><strong>扩展支持正则</strong></p> 
<pre><code>\w	所有字母与数字，称为字符[a-zA-Z0-9]		    
		'l[a-zA-Z0-9]*ve'		 ===       'l\w*ve'
		
\W 所有字母与数字之外的字符，称为非字符		
'love[^a-zA-Z0-9]+' 	===    'love\W+'

\b	词边界										
 '\&lt;love\&gt;'		  	 ===             '\blove\b'		
</code></pre> 
<h4><a id="fgrep_287"></a>fgrep</h4> 
<p><strong>就不支持正则</strong></p> 
<pre><code>	[root@localhost ~]# fgrep . 1.txt
l.ve
</code></pre> 
<h3><a id="_292"></a>返回值</h3> 
<blockquote> 
 <p>0 是找到了<br> 表示成功；<br> 1 是没有<br> 表示在所提供的文件无法找到匹配的pattern<br> 2 找到地儿不对</p> 
</blockquote> 
<pre><code>示范
# grep 'root' /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
# echo $?
0

# grep 'root1' /etc/passwd  #用户root1并不存在
# echo $?
1

grep 'root' /etc/passwd1  #这里的/etc/passwd1文件并不存在
#grep: /etc/passwd1: No such file or directory
#echo $?
2
</code></pre> 
<h3><a id="_314"></a>参数</h3> 
<blockquote> 
 <p>grep -q 静默<br> 结果不显示在屏幕上，可通过返回值了解</p> 
</blockquote> 
<blockquote> 
 <p>grep -v 去反</p> 
</blockquote> 
<blockquote> 
 <p>grep -R 可以查目录下面的文件<br> 默认只能查找文件</p> 
</blockquote> 
<blockquote> 
 <p>grep -o 只找到这个关键字就可以<br> [root@localhost ~]# grep “a” 1.txt<br> 5.a<br> 5.aaa<br> a<br> ab<br> ldfadasfsdave<br> <br> [root@localhost ~]# grep -o “a” 1.txt<br> a<br> a<br> a<br> a<br> a</p> 
</blockquote> 
<blockquote> 
 <p>grep -B2前两行<br> grep -A2后两行<br> grep -C2上下两行</p> 
</blockquote> 
<blockquote> 
 <p>egrep -l 只要文件名<br> [root@localhost ~]# egrep -l ‘root’ /etc/passwd<br> /etc/passwd</p> 
</blockquote> 
<blockquote> 
 <p>egrep -n 带行号<br> [root@localhost ~]# egrep -n ‘xulei’ /etc/passwd<br> 43:xulei: x :1000:1000::/home/xulei:/bin/bash</p> 
</blockquote> 
<h3><a id="_351"></a>示例</h3> 
<pre><code># egrep 'NW' datafile
在datafile文件中，找NW
# egrep 'NW' d*
找NW，文件只要是d开头就可以
# egrep '^n' datafile
以n开头的
# egrep '4$' datafile
4结尾
# egrep TB Savage datafile
找TB，在savage里找，在datafile里找
# egrep 'TB Savage' datafile
找TB Savage
# egrep '5\..' datafile	
找五点后面是一个任意字符
# egrep '\.5' datafile
找点五
# egrep '\&lt;north\&gt;' datafile	
就找这个词
# egrep '\&lt;[a-r].*n\&gt;' datafile
a或r开头，中间任意，n结尾
# egrep '^n\w*\W' datafile
n开头，多个字母，结尾一个非字母
# egrep '\bnorth\b' datafile
就找north
# egrep 'NW|EA' datafile
NW或者EA
# egrep '3+' datafile
1个或多个3
# egrep '2\.?[0-9]' datafile
2开头，0个或1个点，一个数字
# egrep '(no)+' datafile
一个或多个no
# egrep 'S(h|u)' datafile
sh或su
# egrep 'Sh|u' datafile
sh或者u
</code></pre> 
<hr> 
<h2><a id="sed_389"></a>sed</h2> 
<blockquote> 
 <p>前言<br> <strong>Stream EDitor：流编辑<br> sed 是一种在线的、非交互式的编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。<br> 接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输 出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；<br> 文本文件-&gt;“模式空间”（pattern space）-&gt;屏幕<br> 逐行处理<br> 内容未变<br> 编辑文件</strong></p> 
</blockquote> 
<h3><a id="_399"></a>格式</h3> 
<pre><code>1 sed   选项  命令 文件 
	sed [options] 'command' file(s)
2 sed     选项 –f 脚本 文件
	sed [options] -f scriptfile file(s)
</code></pre> 
<h3><a id="_404"></a>返回值</h3> 
<pre><code>都是0，对错不管。
只有当命令存在语法错误时，sed的退出状态才是非0
</code></pre> 
<h3><a id="sed_408"></a>sed和正则表达式</h3> 
<pre><code>与grep一样，sed在文件中查找模式时也可以使用正则表达式(RE)和各种元字符。
正则表达式是括在斜杠间的模式，用于查找和替换，以下是sed支持的元字符。
使用基本元字符集	^, $, ., *, [], [^], \&lt; \&gt;,\(\),\{\}
使用扩展元字符集	?, +, |, ( )
使用扩展元字符的方式：
	\+           转义
	sed -r      加-r
</code></pre> 
<h3><a id="_416"></a>汇总示例</h3> 
<h4><a id="___d_417"></a>删除命令： d</h4> 
<blockquote> 
 <p>#<strong>sed -r ‘/root/d’ passwd</strong><br> 删除带root的行<br> <br> #<strong>sed -r ‘3d’ passwd</strong><br> #<strong>sed -r ‘3{d}’ passwd</strong><br> 删除第三行<br> <br> #<strong>sed -r ‘3{d;}’ passwd</strong><br> {存放sed的多个命令} 3{h;d}，h暂存空间<br> <br> #<strong>sed -r ‘3,$d’ passwd</strong><br> 删除3到最后一行之间的内容</p> 
</blockquote> 
<blockquote> 
 <p>#<strong>sed -r ‘$d’ passwd</strong><br> 删除最后一行内容</p> 
</blockquote> 
<h4><a id="___s_434"></a>替换命令： s</h4> 
<blockquote> 
 <p><mark><strong>sed -r ‘s/root/aofa/’ passwd</strong></mark><br> <img src="https://images2.imgbox.com/64/b4/NHElTZJq_o.png" alt="在这里插入图片描述"><br> <br> <mark><strong>sed -r ‘s/^root/aofa/’ passwd</strong></mark><br> <img src="https://images2.imgbox.com/52/03/7ErMsNDT_o.png" alt="在这里插入图片描述"><br> <br> <mark><strong>sed -r ‘s/root/aofa/g’ passwd</strong></mark><br> <img src="https://images2.imgbox.com/d2/44/C3Unv3WM_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p><strong>sed -r ‘s/[0-9][0-9]$/&amp;.5/’ passwd</strong><br> 查找双数 结尾的词组<br> &amp;：替换成 双数.5<br> &amp;有查询结果的含义。<br> <img src="https://images2.imgbox.com/1a/b7/ERUXUPuK_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>#<strong>sed -r ‘s/(mail)/E\1/g’ passwd</strong><br> （）括号组合字符，\1调用括号<br> [root@localhost ~]# sed -r ‘s/(mail)/E\1/g’ passwd<br> Email: x :8:12:Email:/var/spool/Email:/sbin/nologin9<br> <br> <strong>sed -r ‘s#(mail)#E\1#g’ passwd</strong><br> 分隔符可以换成井号</p> 
</blockquote> 
<h4><a id="r_458"></a>读文件命令：r</h4> 
<blockquote> 
 <p><strong>sed -r ‘$r 1.txt’ passwd</strong><br> 在passwd后面追读1.txt的内容<br> <img src="https://images2.imgbox.com/0f/ae/GTfxWne6_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p><strong>sed -r ‘/root/r 1.txt’ passwd</strong><br> 正则搜寻root<br> 在root后面读取新文件<br> <img src="https://images2.imgbox.com/90/ad/0REZsq5U_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="w_467"></a>写文件命令：w(另存为)</h4> 
<blockquote> 
 <p><strong>sed -r ‘w 111.txt’ 1.txt</strong><br> 把1.txt全部内容 写入111.txt<br> <img src="https://images2.imgbox.com/c5/04/7x00ud7j_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="___a_471"></a>追加命令： a（之后）</h4> 
<pre><code class="prism language-bash"><span class="token comment"># sed -r 'a123' passwd</span>
	每行后面，都加上123行
<span class="token comment"># sed -r '2a123' passwd</span>
	2行后面，加上123行
</code></pre> 
<h4><a id="___i_479"></a>插入命令： i（之前）</h4> 
<pre><code class="prism language-bash"><span class="token comment"># sed -r '2iaaaaaaaa' passwd</span>
	在第二行插入新行aaaaaaaaaa

<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># sed -r '2iaaaaaaaa' passwd </span>
root:x:0:0:root:/root:/bin/bash1
aaaaaaaa
bin:x:1:1:bin:/bin:/sbin/nologin2
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
</code></pre> 
<h4><a id="___c_491"></a>替换整行命令： c</h4> 
<pre><code class="prism language-bash"><span class="token comment"># sed -r '2caaaaaaaa' passwd</span>
	把第二行替换成aaaaaaaaa

<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># sed -r '2caaaaaaaa' passwd </span>
root:x:0:0:root:/root:/bin/bash1
aaaaaaaa
daemon:x:2:2:daemon:/sbin:/sbin/nologin3
adm:x:3:4:adm:/var/adm:/sbin/nologin4
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin5
sync:x:5:0:sync:/sbin:/bin/sync6
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown7
halt:x:7:0:halt:/sbin:/sbin/halt8
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin9
operator:x:11:0:operator:/root:/sbin/nologin10
</code></pre> 
<h4><a id="n_509"></a>获取下一行命令：n</h4> 
<pre><code class="prism language-bash"><span class="token comment"># sed -r '/root/{n;d}' passwd</span>
	n下一行的意思。
找root行，然后下一行，删除

<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># sed -r '/root/{n;d}' passwd </span>
root:x:0:0:root:/root:/bin/bash1
daemon:x:2:2:daemon:/sbin:/sbin/nologin3
adm:x:3:4:adm:/var/adm:/sbin/nologin4
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin5
sync:x:5:0:sync:/sbin:/bin/sync6
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown7
halt:x:7:0:halt:/sbin:/sbin/halt8
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin9
operator:x:11:0:operator:/root:/sbin/nologin10

		n：next下一行可以用多次。
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># sed -r '/root/{n;n;d}' passwd </span>
root:x:0:0:root:/root:/bin/bash1
bin:x:1:1:bin:/bin:/sbin/nologin2
adm:x:3:4:adm:/var/adm:/sbin/nologin4
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin5
sync:x:5:0:sync:/sbin:/bin/sync6
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown7
halt:x:7:0:halt:/sbin:/sbin/halt8
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin9
operator:x:11:0:operator:/root:/sbin/nologin10

</code></pre> 
<h4><a id="___e_540"></a>多重编辑 e</h4> 
<pre><code class="prism language-bash"><span class="token function">sed</span> -r -e <span class="token string">'1,3d'</span> -e <span class="token string">'4s/adm/admin/g'</span> <span class="token function">passwd</span> 
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># sed -r -e '1,3d' -e '4s/adm/admin/g'passwd </span>
admin:x:3:4:admin:/var/admin:/sbin/nologin4
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin5
sync:x:5:0:sync:/sbin:/bin/sync6
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown7
halt:x:7:0:halt:/sbin:/sbin/halt8
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin9
operator:x:11:0:operator:/root:/sbin/nologin10
</code></pre> 
<h4><a id="_553"></a>实战案例</h4> 
<p><strong>删除配置文件中#号注释行</strong></p> 
<pre><code class="prism language-bash"><span class="token function">sed</span> -r <span class="token string">'/^#/d'</span> /etc/vsftpd/vsftpd.conf
</code></pre> 
<p><strong>修改文件：</strong></p> 
<pre><code class="prism language-bash"><span class="token function">sed</span> -ri <span class="token string">'<span class="token variable">$a</span>\chroot_local_user=YES'</span> /etc/vsftpd/vsftpd.conf 
		在最后一行追加
<span class="token function">sed</span> -ri <span class="token string">'/^SELINUX=/cSELINUX=disabled'</span> /etc/selinux/config 
		换行c
</code></pre> 
<p><strong>给文件行添加注释：</strong></p> 
<pre><code class="prism language-bash">	<span class="token function">sed</span> -r <span class="token string">'2,6s/^/#/'</span> a.txt
		找到2到6行，把开始换成<span class="token comment">#</span>
	<span class="token function">sed</span> -r <span class="token string">'2,6s/(.*)/#\1/'</span> a.txt	
		（）内容可以被\1引用
	<span class="token function">sed</span> -r <span class="token string">'2,6s/.*/#&amp;/'</span> a.txt 
		       <span class="token operator">&amp;</span>匹配前面查找的内容
</code></pre> 
<p><strong>sed中使用外部变量</strong></p> 
<pre><code class="prism language-bash"><span class="token function">sed</span> -r <span class="token string">"\<span class="token variable">$a</span><span class="token variable">$var1</span>"</span> /etc/hosts
第一行后追加变量<span class="token variable">$var1</span>
</code></pre> 
<h2><a id="awk_585"></a>awk</h2> 
<h3><a id="1_586"></a>1.前言</h3> 
<blockquote> 
 <p><em>awk 是一种编程语言，用于在linux/unix下对文本和数据进行处理。<br> 数据可以来自标准输入、一个或多个文件，或其它命令的输出。<br> 它支持用户自定义函数和动态正则表达式等先进功能，<br> awk的处理文本和数据的方式是这样的，<br> 它逐行扫描文件，从第一行到最后一行，<br> 寻找匹配的特定模式的行，并在这些行上进行你想要的操作。<br> 如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)，<br> awk分别代表其作者姓氏的第一个字母。因为它的作者是三个人，<br> 分别是Alfred Aho、Peter Weinberger、 Kernighan。</em></p> 
</blockquote> 
<h3><a id="2_597"></a>2.工作原理</h3> 
<blockquote> 
 <p>awk -F: ‘{print $1,$3}’ /etc/passwd<br> (1)awk使用一行作为输入，并将这一行赋给内部变量$0，每一行也可称为一个记录，以换行符结束<br> <br> (2)然后，行被:（默认为空格或制表符）分解成字段（或域），每个字段存储在已编号的变量中，从$1开始，<br> 最多达100个字段<br> <br> (3)awk输出之后，将从文件中获取另一行，并将其存储在$0中，覆盖原来的内容，然后将新的字符串分隔<br> 成字段并进行处理。该过程将持续到所有行处理完毕<br> <img src="https://images2.imgbox.com/a5/51/17BRBkkI_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="3_607"></a>3.语法</h3> 
<blockquote> 
 <p>awk [options] ‘commands’ filenames （推荐）</p> 
</blockquote> 
<blockquote> 
 <p>＝＝options：<br> 例如：-F 定义输入字段分隔符，默认的分隔符是空格或制表符(tab)</p> 
</blockquote> 
<blockquote> 
 <p>＝＝command（时空）：<br> BEGIN{} {} END{}<br> BEGIN{}<br> begin发生在行处理前（注意大写）<br> {}<br> 行处理时，读一行执行一次<br> END{}<br> 行处理后<br> <mark>awk ‘BEGIN{print 1/2} {print “ok”} END{print “-----------”}’ /etc/hosts</mark><br> <img src="https://images2.imgbox.com/2d/f2/OmFRSDTX_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="_624"></a>内部变量</h3> 
<h4><a id="_FS_625"></a>① FS</h4> 
<pre><code>输入字段分隔符（默认空格）
</code></pre> 
<pre><code class="prism language-bash">
<span class="token comment"># awk -F: '{print $1, $3}' /etc/passwd | head -1</span>
root 0
或
<span class="token comment"># awk -F'[ :\t]' '{print $1,$2,$3}' /etc/passwd | head -1</span>
root x 0
或
<span class="token comment"># awk 'BEGIN{FS=":"} {print $1,$3}' /etc/passwd | head -1</span>
root 0
</code></pre> 
<h4><a id="_OFS_638"></a>② OFS</h4> 
<pre><code>输出字段分隔符
</code></pre> 
<pre><code class="prism language-bash"><span class="token comment"># awk -F: '{print $1,$2,$3,$4}' /etc/passwd | head -1</span>
root x 0 0

<span class="token comment"># awk -F: 'BEGIN{FS=":";OFS="+++"}{print $1,$2,$3,$4}' /etc/passwd | head -1</span>
root+++x+++0+++0
</code></pre> 
<h4><a id="_RS_647"></a>③ RS</h4> 
<pre><code>输入记录（行）分隔符，默认换行符
</code></pre> 
<pre><code class="prism language-bash"><span class="token comment"># awk   '{print $0}' a.txt </span>
111 222 333 444 555:666:777
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># awk 'BEGIN{RS="   "}{print $0}' a.txt </span>
111
222
333
444
555:666:777
请注意，在此时记录已经不是行的概念了。分隔符由”换行符“换成了”空格“
</code></pre> 
<h4><a id="_ORS_661"></a>④ ORS</h4> 
<pre><code>输出记录（行）分隔符，默认换行符
</code></pre> 
<h4><a id="_FNR_NR_663"></a>⑤ FNR ，NR</h4> 
<pre><code>多文件汇总编号

多文件独立编号
</code></pre> 
<pre><code class="prism language-bash"><span class="token comment"># awk -F: '{print NR, $0}' /etc/centos-release /etc/hosts</span>
1 CentOS Linux release 7.3.1611 <span class="token punctuation">(</span>Core<span class="token punctuation">)</span> 
2 127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
3 ::1    localhost localhost.localdomain localhost6 localhost6.localdomain6
<span class="token comment"># awk -F: '{print FNR, $0}' /etc/centos-release /etc/hosts</span>
1 CentOS Linux release 7.3.1611 <span class="token punctuation">(</span>Core<span class="token punctuation">)</span> 
1 127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
2 ::1    localhost localhost.localdomain localhost6 localhost6.localdomain6
</code></pre> 
<h4><a id="_NF_678"></a>⑥ NF</h4> 
<pre><code>字段总数
</code></pre> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># awk -F: '{print NF, $0}'  /etc/passwd</span>
7 root:x:0:0:root:/root:/bin/bash
7 bin:x:1:1:bin:/bin:/sbin/nologin
7 daemon:x:2:2:daemon:/sbin:/sbin/nologin

<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># awk -F: '{print NF, $NF}'  /etc/passwd</span>
7 /bin/bash
7 /sbin/nologin
7 /sbin/nologin
</code></pre> 
<h3><a id="_691"></a>格式化输出</h3> 
<h4><a id="_print___692"></a>① print 函数</h4> 
<pre><code class="prism language-bash"><span class="token function">date</span> <span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'{print "Month: " <span class="token variable">$2</span> "\nYear: " <span class="token variable">$1</span>}'</span>
Month: 11月
Year: 2017年
	\n换行符
	想输出文字，用引号
<span class="token function">awk</span> -F: <span class="token string">'{print "username is: " <span class="token variable">$1</span> "\t uid is: " <span class="token variable">$3</span>}'</span> /etc/passwd <span class="token operator">|</span> <span class="token function">head</span> -1
username is: root	 uid is: 0
<span class="token function">awk</span> -F: <span class="token string">'{print "\tusername and uid: " <span class="token variable">$1</span>,<span class="token variable">$3</span> "!"}'</span> /etc/passwd  <span class="token operator">|</span> <span class="token function">head</span> -1
	username and uid: root 0<span class="token operator">!</span>
</code></pre> 
<h4><a id="_printf__705"></a>② printf 函数</h4> 
<blockquote> 
 <p><strong>语法<br> %s 字符类型<br> %d 数值类型<br> %f 浮点型，可以定义保留<br> 占15字符<br> - 表示左对齐，默认是右对齐<br> printf默认不会在行尾自动换行，加\n<br> , 逗号，输出字段分隔符</strong></p> 
</blockquote> 
<pre><code class="prism language-bash"><span class="token function">awk</span> -F: <span class="token string">'{printf "%-10s %-10s %-15s\n", <span class="token variable">$1</span>,<span class="token variable">$2</span>,<span class="token variable">$3</span>}'</span> /etc/passwd <span class="token operator">|</span> <span class="token function">head</span> 
root       x          0              
bin        x          1              
daemon     x          2              
adm        x          3              
lp         x          4              
<span class="token function">sync</span>       x          5              
<span class="token function">shutdown</span>   x          6              
halt       x          7              
mail       x          8              
operator   x          11  
这是由于xmind的对齐导致的。
</code></pre> 
<pre><code class="prism language-bash"><span class="token function">awk</span> -F: <span class="token string">'{printf "|%-15s| %-10s| %-15s|\n", <span class="token variable">$1</span>,<span class="token variable">$2</span>,<span class="token variable">$3</span>}'</span> /etc/passwd <span class="token operator">|</span> <span class="token function">head</span>
<span class="token operator">|</span>root           <span class="token operator">|</span> x         <span class="token operator">|</span> 0              <span class="token operator">|</span>
<span class="token operator">|</span>bin            <span class="token operator">|</span> x         <span class="token operator">|</span> 1              <span class="token operator">|</span>
<span class="token operator">|</span>daemon         <span class="token operator">|</span> x         <span class="token operator">|</span> 2              <span class="token operator">|</span>
<span class="token operator">|</span>adm            <span class="token operator">|</span> x         <span class="token operator">|</span> 3              <span class="token operator">|</span>
<span class="token operator">|</span>lp             <span class="token operator">|</span> x         <span class="token operator">|</span> 4              <span class="token operator">|</span>
<span class="token operator">|</span><span class="token function">sync</span>           <span class="token operator">|</span> x         <span class="token operator">|</span> 5              <span class="token operator">|</span>
<span class="token operator">|</span><span class="token function">shutdown</span>       <span class="token operator">|</span> x         <span class="token operator">|</span> 6              <span class="token operator">|</span>
<span class="token operator">|</span>halt           <span class="token operator">|</span> x         <span class="token operator">|</span> 7              <span class="token operator">|</span>
<span class="token operator">|</span>mail           <span class="token operator">|</span> x         <span class="token operator">|</span> 8              <span class="token operator">|</span>
<span class="token operator">|</span>operator       <span class="token operator">|</span> x         <span class="token operator">|</span> 11             <span class="token operator">|</span>

</code></pre> 
<h3><a id="_743"></a>模式（正则表达）和动作</h3> 
<blockquote> 
 <p>概念<br> 任何awk语句都由模式和动作组成。模式部分决定动作语句何时触发及触发事件。<br> 如果省略模式部分，动作将时刻保持执行状态。每一行都会有动作。<br> 模式可以是任何条件语句或复合语句或正则表达式。有模式的话，就是对模式对应的行进行动作。</p> 
</blockquote> 
<p><strong>模式：可以是条件测试，正则，复合语句<br> 动作：可以是打印，计算等。</strong></p> 
<h4><a id="__751"></a>① 字符串比较</h4> 
<pre><code class="prism language-bash"><span class="token function">awk</span>    <span class="token string">'/^root/'</span>     /etc/passwd
<span class="token function">awk</span> <span class="token string">'<span class="token variable">$0</span> ~ /^root/'</span> /etc/passwd
<span class="token function">awk</span> <span class="token string">'<span class="token variable">$0!</span>~/^root/'</span> /etc/passwd
<span class="token function">awk</span> -F: <span class="token string">'<span class="token variable">$1</span> ~ /^root/'</span> /etc/passwd
</code></pre> 
<h4><a id="__759"></a>② 数值比较</h4> 
<p>关系运算符</p> 
<pre><code>语法
运算符 含义 示例
&lt; 	小于 			x&lt;y
&lt;= 	小于或等于 	x&lt;=y
== 	等于		 	x==y
!= 	不等于		x!=y
&gt;= 	大于等于 		x&gt;=y
&gt; 	大于 			x&gt;y
</code></pre> 
<pre><code class="prism language-bash"><span class="token function">awk</span> -F: <span class="token string">'<span class="token variable">$3</span> == 0'</span> /etc/passwd 
<span class="token function">awk</span> -F: <span class="token string">'<span class="token variable">$3</span> == 1'</span> /etc/passwd 
<span class="token function">awk</span> -F: <span class="token string">'<span class="token variable">$3</span> &lt; 10'</span> /etc/passwd
<span class="token operator">==</span> 也可以用于字符串判断
<span class="token function">awk</span> -F: <span class="token string">'<span class="token variable">$7</span> == "/bin/bash"'</span> /etc/passwd
<span class="token function">awk</span> -F: <span class="token string">'<span class="token variable">$1</span> == "alice"'</span> /etc/passwd
</code></pre> 
<p>算术 运算</p> 
<pre><code>语法
+ - * / %(模) ^(幂2^3) 
</code></pre> 
<pre><code class="prism language-bash"><span class="token function">awk</span> -F: <span class="token string">'<span class="token variable">$3</span> * 10 &gt; 500'</span> /etc/passwd
</code></pre> 
<hr> 
<h2><a id="awk_786"></a>awk脚本编程</h2> 
<h3><a id="_787"></a>变量</h3> 
<p>awk调用变量</p> 
<pre><code class="prism language-bash">自定义内部变量 -v 
<span class="token function">awk</span> -v user<span class="token operator">=</span>root -F: <span class="token string">'<span class="token variable">$1</span> == user'</span> /etc/passwd
-v 
定义变量
</code></pre> 
<pre><code class="prism language-bash">外部变量 “’”
单引号
<span class="token comment"># heihei=shutdown</span>
<span class="token comment"># echo $heihei</span>
<span class="token function">shutdown</span>
<span class="token comment"># awk -F: '$1 ~ "'"$heihei"'" ' passwd</span>
shutdown:x:6:0shutdown:/sbin:/sbin:shutdown7
</code></pre> 
<h3><a id="_806"></a>条件判断</h3> 
<p><strong>if…else if…else</strong></p> 
<blockquote> 
 <p>格式<br> {if(表达式1）{语句；语句；…} else if （表达式2）{语句；语句；…}else{语句；语句;…} }<br> if(){}else if (){}else{}</p> 
</blockquote> 
<p>示例</p> 
<blockquote> 
 <p>需求：<br> 管理员数量：管理员id为0<br> 内置用户数量：用户id’小于1000<br> 普通用户数量：用户id大于999</p> 
</blockquote> 
<pre><code class="prism language-bash"><span class="token function">awk</span> -F: <span class="token string">'{if(<span class="token variable">$3</span>==0){i++} else if(<span class="token variable">$3</span>&gt;999){k++} 
else{j++}} END{print i; print k; print j}'</span> /etc/passwd
<span class="token function">awk</span> -F: <span class="token string">'{if(<span class="token variable">$3</span>==0){i++} else if(<span class="token variable">$3</span>&gt;999)
{k++} else{j++}} END{print "管理员个数: "i;
 print "普通用个数: "k; print "系统用户: "j}'</span> /etc/passwd
</code></pre> 
<p><img src="https://images2.imgbox.com/40/da/fSeVbyKi_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_826"></a>循环</h3> 
<blockquote> 
 <p>while<br> 每行打印十次<br> awk ‘{i=1;whilw(i&lt;=10){print $0;i++}}’ passwd<br> for<br> 循环打印5个数字<br> awk ‘BEGIN{for(i=1;i&lt;=5;i++){print i} }’<br> 不适用BEGIN可以吗？<br> {},和END{}可以吗？可以需要有文件。</p> 
</blockquote> 
<pre><code class="prism language-bash">
将每行打印10次
<span class="token function">awk</span> -F: <span class="token string">'{ for(i=1;i&lt;=10;i++) {print <span class="token variable">$0</span>} }'</span> /etc/passwd
打印每一行的每一列
<span class="token function">awk</span> -F: <span class="token string">'{ for(i=1;i&lt;=NF;i++) {print <span class="token variable">$i</span>} }'</span> <span class="token function">passwd</span>
说明：NF是最大列数，循环打印了每一列。
<span class="token function">awk</span> -F: <span class="token string">'{ for(i=1;i&lt;=NF;i++) {print <span class="token variable">$i</span>} }'</span> <span class="token function">passwd</span>
root
x
0
0
root
/root
/bin/bash
</code></pre> 
<h3><a id="_852"></a>数组</h3> 
<blockquote> 
 <p>定义数组<br> 需求<br> 将用户名定义为数组的值，打印第一个值</p> 
</blockquote> 
<pre><code class="prism language-bash"><span class="token function">awk</span> -F: <span class="token string">'{username[++i]=<span class="token variable">$1</span>} END{print username[1]}'</span> /etc/passwd
root
数组遍历
按索引遍历
<span class="token function">awk</span> -F: <span class="token string">'{username[x++]=<span class="token variable">$1</span>} END{for(i in username) {print
 i,username[i]} }'</span> /etc/passwd
10 games
11 <span class="token function">ftp</span>
12 nobody
13 systemd-bus-proxy
14 systemd-network
15 dbus
16 polkitd
30 chrony
17 abrt
31 ntp
18 unbound

</code></pre> 
<h3><a id="awk_876"></a>awk编程案例</h3> 
<pre><code>统计/etc/passwd中各种类型shell的数量
</code></pre> 
<pre><code class="prism language-bash"><span class="token function">awk</span> -F: <span class="token string">'{shells[<span class="token variable">$NF</span>]++} END{ for(i in shells){print i,
shells[i]} }'</span> /etc/passwd
提示
<span class="token variable">$NF</span> 最后一列的字段内容
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>行处理
把统计的对象，作为索引。每次递增。
Print i  打印索引
Shells<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  数组加索引，显示的就是值
</code></pre> 
<p><img src="https://images2.imgbox.com/5e/15/FFlWWEnE_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85a3e068c65eda9fd34e40ca7d25568c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js  判断某个数值是否在某个范围之内</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d482cbb5be6f4f39089148fe4aa681b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ubuntu 安装 k8s</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>