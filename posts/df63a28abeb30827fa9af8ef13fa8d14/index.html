<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql知识点总结（网安必备） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql知识点总结（网安必备）" />
<meta property="og:description" content="目录
数据库介绍
数据库基本概念
数据库类型
MySql数据库管理系统
SQL语言
概述
常见操作
表的完整性约束
非外键约束
外键约束
单表查询
函数
多表查询
事务
事务隔离级别
视图
数据库介绍 数据库基本概念 数据：所谓数据（Data）是指对客观事物进行描述并可以鉴别的符号，这些符号是可识别的、抽象的。它不仅仅指狭义上的数字，而是有多种表现形式：字母、文字、文本、图形、音频、视频等。现在计算机存储和处理的数据范围十分广泛，而描述这些数据的符号也变得越来越复杂了。
数据库：数据库（Database，DB）指的是以一定格式存放、能够实现多个用户共享、与应用程序彼此独立的数据集合。
数据库管理系统：数据库管理系统（Database Management System，DBMS）是用来定义和管理数据的软件。如何科学的组织和存储数据，如何高效的获取和维护数据，如何保证数据的安全性和完整性，这些都需要靠数据库管理系统完成。目前，比较流行的数据库管理系统有：Oracle、MySQL、SQL Server、DB2等。
数据库应用程序：数据库应用程序（Database Application System，DBAS）是在数据库管理系统基础上，使用数据库管理系统的语法，开发的直接面对最终用户的应用程序，如学生管理系统、人事管理系统、图书管理系统等。
数据库系统：数据库系统（Database System，DBS）一般是由数据库、数据库管理系统、数据库应用程序、数据库管理员和最终用户构成。其中DBMS是数据库系统的基础和核心。
数据库类型 关系型数据库 ：将复杂的数据结构用较为简单的二元关系（二维表）来表示。在该类型数据库中，对数据的操作基本上都建立在一个或多个表格上，我们可以采用结构化查询语言（SQL）对数据库进行操作。关系型数据库是目前主流的数据库技术，其中具有代表性的数据库管理系统有：Oracle、DB2、SQL Server、MySQL等。非关系型数据库（NOSQL）：NOSQL（Not Only SQL）泛指非关系型数据库。关系型数据库在超大规模和高并发的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题。NOSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。常见的非关系型数据库管理系统有Memcached、MongoDB，redis，HBase等。 关系型数据库是存储在硬盘上，而非关系型数据库是存储在硬盘，访问速度更快。
MySql数据库管理系统 理ilnaug概述：MySQL是一种开放源代码的轻量级关系型数据库，MySQL数据库使用最常用的结构化查询语言（SQL）对数据库进行管理；MySQL数据库体积小、速度快、成本低、开放源码等优点。
安装好数据库后可以在对应bin目录下cmd登陆mysql。
或者配置环境变量后，直接在cmd登陆。
登陆所用参数：
-h：host主机名。后面跟要访问的数据库服务器的地址；如果是登录本机，可以省略 -u：user 用户名。后面跟登录数据的用户名，第一次安装后以root用户来登录，是MySQL的管理员用户 -p: password 密码。一般不直接输入，而是回车后以保密方式输入。
MySQL 层次：不同项目对应不同的数据库组成 - 每个数据库中有很多表 - 每个表中有很多数据 退出数据库：可以使用quit或者exit命令完成，也可以用\q; 完成退出操作 。
数据库的卸载：在服务中停止mysql服务，然后再控制面板中卸载mysql软件。删除所有的mysql文件夹。（C:\Program Files\MySQL；C:\ProgramData\MySQL。）；把环境变量删除。
SQL语言 概述 数据库管理人员（DBA）通过数据库管理系统（DBMS）可以对数据库（DB）中的数据进行操作，操作用到的就是sq语言。
SQL（Structured Query Language）是结构化查询语言的简称，它是一种数据库查询和程序设计语言，同时也是目前使用最广泛的关系型数据库操作语言。在数据库管理系统中，使用SQL语言来实现数据的存取、查询、更新等功能。
SQL语言可以分为五个部分： 数据查询语言（Data Query Language，DQL）：DQL主要用于数据的查询，其基本结构是使用SELECT子句，FROM子句和WHERE子句的组合来查询一条或多条数据。数据操作语言（Data Manipulation Language，DML）：DML主要用于对数据库中的数据进行增加、修改和删除的操作，其主要包括：INSERT：增加数据、 UPDATE：修改数据、DELETE：删除数据数据定义语言（Data Definition Language，DDL）：DDL主要用针对是数据库对象（数据库、表、索引、视图、触发器、存储过程、函数）进行创建、修改和删除操作。其主要包括：CREATE：创建数据库对象、ALTER：修改数据库对象、DROP：删除数据库对象数据控制语言（Data Control Language，DCL）：DCL用来授予或回收访问 数据库的权限，其主要包括： GRANT：授予用户某种权限、REVOKE：回收授予的某种权限事务控制语言（Transaction Control Language，TCL）：TCL用于数据库的事务管理。其主要包括：START TRANSACTION：开启事务、COMMIT：提交事务、ROLLBACK：回滚事务、SET TRANSACTION：设置事务的属性 。 常见操作 创建数据库表:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/df63a28abeb30827fa9af8ef13fa8d14/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-04T14:09:54+08:00" />
<meta property="article:modified_time" content="2023-01-04T14:09:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql知识点总结（网安必备）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D" rel="nofollow">数据库介绍</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">数据库基本概念</a></p> 
<p id="%C2%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B" rel="nofollow"> 数据库类型</a></p> 
<p id="MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-toc" style="margin-left:0px;"><a href="#MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" rel="nofollow">MySql数据库管理系统</a></p> 
<p id="SQL%E8%AF%AD%E8%A8%80-toc" style="margin-left:0px;"><a href="#SQL%E8%AF%AD%E8%A8%80" rel="nofollow">SQL语言</a></p> 
<p id="%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%E6%A6%82%E8%BF%B0" rel="nofollow">概述</a></p> 
<p id="%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C" rel="nofollow">常见操作</a></p> 
<p id="%E8%A1%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F-toc" style="margin-left:40px;"><a href="#%E8%A1%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F" rel="nofollow">表的完整性约束</a></p> 
<p id="%E9%9D%9E%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F-toc" style="margin-left:80px;"><a href="#%E9%9D%9E%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F" rel="nofollow">非外键约束</a></p> 
<p id="%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F-toc" style="margin-left:80px;"><a href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F" rel="nofollow">外键约束</a></p> 
<p id="%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2-toc" style="margin-left:40px;"><a href="#%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2" rel="nofollow">单表查询</a></p> 
<p id="%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%87%BD%E6%95%B0" rel="nofollow">函数</a></p> 
<p id="%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2-toc" style="margin-left:40px;"><a href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2" rel="nofollow">多表查询</a></p> 
<p id="%E4%BA%8B%E5%8A%A1-toc" style="margin-left:40px;"><a href="#%E4%BA%8B%E5%8A%A1" rel="nofollow">事务</a></p> 
<p id="%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-toc" style="margin-left:40px;"><a href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" rel="nofollow">事务隔离级别</a></p> 
<p id="%E8%A7%86%E5%9B%BE-toc" style="margin-left:40px;"><a href="#%E8%A7%86%E5%9B%BE" rel="nofollow">视图</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D">数据库介绍</h2> 
<h3 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">数据库基本概念</h3> 
<p>数据：所谓数据（Data）是指对客观事物进行描述并可以鉴别的符号，这些符号是可识别的、抽象的。它不仅仅指狭义上的数字，而是有多种表现形式：字母、文字、文本、图形、音频、视频等。现在计算机存储和处理的数据范围十分广泛，而描述这些数据的符号也变得越来越复杂了。</p> 
<p>数据库：数据库（Database，DB）指的是以<span style="color:#ff6600;">一定格式存放</span>、能够实现多个用户共享、与应用程序彼此独立的数据集合。</p> 
<p>数据库管理系统：数据库管理系统（Database Management System，DBMS）是用来定义和管理数据的软件。如何科学的组织和存储数据，如何高效的获取和维护数据，如何保证数据的安全性和完整性，这些都需要靠数据库管理系统完成。目前，比较流行的数据库管理系统有：Oracle、MySQL、SQL Server、DB2等。</p> 
<p>数据库应用程序：数据库应用程序（Database Application System，DBAS）是在数据库管理系统基础上，使用数据库管理系统的语法，开发的直接面对最终用户的应用程序，如学生管理系统、人事管理系统、图书管理系统等。</p> 
<p>数据库系统：数据库系统（Database System，DBS）一般是由数据库、数据库管理系统、数据库应用程序、数据库管理员和最终用户构成。其中DBMS是数据库系统的基础和核心。</p> 
<p><img alt="" height="368" src="https://images2.imgbox.com/cc/2f/xx0PTuLh_o.png" width="779"></p> 
<h3 id="%C2%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B"> 数据库类型</h3> 
<ul><li>关系型数据库 ：将复杂的数据结构用较为简单的二元关系（二维表）来表示。在该类型数据库中，对数据的操作基本上都建立在一个或多个表格上，我们可以采用结构化查询语言（SQL）对数据库进行操作。关系型数据库是目前主流的数据库技术，其中具有代表性的数据库管理系统有：Oracle、DB2、SQL Server、MySQL等。</li><li>非关系型数据库（NOSQL）：NOSQL（Not Only SQL）泛指非关系型数据库。关系型数据库在超大规模和高并发的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题。NOSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。常见的非关系型数据库管理系统有Memcached、MongoDB，redis，HBase等。 </li></ul> 
<p>关系型数据库是存储在硬盘上，而非关系型数据库是存储在硬盘，访问速度更快。</p> 
<h2 id="MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">MySql数据库管理系统</h2> 
<p>理ilnaug概述：MySQL是一种开放源代码的轻量级关系型数据库，MySQL数据库使用最常用的结构化查询语言（SQL）对数据库进行管理；MySQL数据库体积小、速度快、成本低、开放源码等优点。</p> 
<p>安装好数据库后可以在对应bin目录下cmd登陆mysql。</p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/b4/13/qIOkCW6v_o.png" width="1200"></p> 
<p>或者配置环境变量后，直接在cmd登陆。</p> 
<p>登陆所用参数：</p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">-h：host主机名。后面跟要访问的数据库服务器的地址；</span><strong><span style="background-color:#ffffff;"><strong>如果是登录本机，可以省略</strong></span></strong> </p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">-u：user 用户名。后面跟登录数据的用户名，第一次安装后以root用户来登录，是MySQL的管理员用户</span> </p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">-p:   password 密码。一般不直接输入，而是回车后以保密方式输入。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="369" src="https://images2.imgbox.com/42/0d/IFydDfb5_o.png" width="1012"></p> 
<p><span style="background-color:#ffffff;">MySQL 层次：不同项目对应不同的数据库组成 - 每个数据库中有很多表  - 每个表中有很多数据</span>  </p> 
<p> 退出数据库：<span style="background-color:#ffffff;">可以使用quit或者exit命令完成，也可以用\q;  完成退出操作</span> 。</p> 
<p>数据库的卸载：在服务中停止mysql服务，然后再控制面板中卸载mysql软件。删除所有的mysql文件夹。（C:\Program Files\MySQL；C:\ProgramData\MySQL。）；把环境变量删除。</p> 
<h2 id="SQL%E8%AF%AD%E8%A8%80">SQL语言</h2> 
<h3 id="%E6%A6%82%E8%BF%B0">概述</h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">数据库管理人员（DBA）通过数据库管理系统（DBMS）可以对数据库（DB）中的数据进行操作，操作用到的就是sq语言。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">SQL（Structured Query Language）是<span style="color:#fe2c24;">结构化查询语言</span>的简称，它是一种数据库查询和程序设计语言，同时也是目前使用最广泛的关系型数据库操作语言。在数据库管理系统中，使用SQL语言来实现数据的存取、查询、更新等功能。</p> 
<ol><li style="margin-left:.0001pt;text-align:justify;">SQL语言可以分为五个部分：</li></ol> 
<ul><li style="text-align:left;">数据查询语言（Data Query Language，DQL）：DQL主要用于<span style="color:#ff6600;">数据的查询</span>，其基本结构是使用SELECT子句，FROM子句和WHERE子句的组合来查询一条或多条数据。</li><li style="text-align:left;">数据操作语言（Data Manipulation Language，DML）：DML主要用于对数据库中的<span style="color:#ff6600;">数据进行增加、修改和删除</span>的操作，其主要包括：INSERT：增加数据、 UPDATE：修改数据、DELETE：删除数据</li><li style="text-align:left;">数据定义语言（Data Definition Language，DDL）：DDL主要用针对是<span style="color:#ff6600;">数据库对象</span>（数据库、表、索引、视图、触发器、存储过程、函数）进行创建、修改和删除操作。其主要包括：CREATE：创建数据库对象、ALTER：修改数据库对象、DROP：删除数据库对象</li><li style="text-align:left;">数据控制语言（Data Control Language，DCL）：DCL用来授予或回收<span style="color:#ff6600;">访问 数据库的权限</span>，其主要包括： GRANT：授予用户某种权限、REVOKE：回收授予的某种权限</li><li style="text-align:left;">事务控制语言（Transaction Control Language，TCL）：TCL用于数据库的<span style="color:#ff6600;">事务管理</span>。其主要包括：START TRANSACTION：开启事务、COMMIT：提交事务、ROLLBACK：回滚事务、SET TRANSACTION：设置事务的属性 。</li></ul> 
<h3 id="%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C" style="text-align:left;">常见操作</h3> 
<p style="text-align:left;">创建数据库表:</p> 
<pre><code class="language-sql">
-- 创建数据库表：
create table t_student(
	sno int(6), -- 6显示长度 
	sname varchar(5), -- 5个字符
	sex char(1),
	age int(3),
	enterdate date,
	classname varchar(10),
	email varchar(15)
);

-- 查看表的结构：展示表的字段详细信息
desc t_student;

-- 查看表中数据：
select * from t_student;

-- 查看建表语句：
show create table t_student;






</code></pre> 
<p>对于数据库表的字段类型：</p> 
<ul><li>整数类型：</li></ul> 
<p><img alt="" height="361" src="https://images2.imgbox.com/83/61/wx4P17YF_o.png" width="1092"></p> 
<p>在int类型后的括号里面可以加数字，指定显示的整数长度，但并不会限制大小</p> 
<p>主键自增：不使用序列，通过auto_increment，要求是整数类型  </p> 
<ul><li>浮点数类型</li></ul> 
<p style="margin-left:.0001pt;text-align:justify;">需要注意的是与整数类型不一样的是，浮点数类型的宽度不会自动扩充。double(4,1)--小数部分为1位，总宽度4位，并且不会自动扩充。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="183" src="https://images2.imgbox.com/81/fe/et6FGxyA_o.png" width="498"></p> 
<p></p> 
<ul><li>字符串类型 </li></ul> 
<p><img alt="" height="263" src="https://images2.imgbox.com/1f/f3/tF1Qq6Bg_o.png" width="1038"></p> 
<p></p> 
<p>CHAR和VARCHAR类型相似，均用于存于较短的字符串，主要的不同之处在于存储方式。<span style="color:#ff6600;">CHAR类型长度固定，VARCHAR类型的长度可变</span>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">因为VARCHAR类型能够根据字符串的实际长度来动态改变所占字节的大小，所以在不能明确该字段具体需要多少字符时推荐使用VARCHAR类型，这样可以大大地节约磁盘空间、提高存储效率。</p> 
<p style="margin-left:.0001pt;text-align:justify;">CHAR和VARCHAR表示的是字符的个数，而不是字节的个数</p> 
<ul><li>日期和时间类型</li></ul> 
<p><img alt="" height="485" src="https://images2.imgbox.com/69/72/yIGdnvPc_o.png" width="1108"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">TIMESTEMP类型的数据指定方式与DATETIME基本相同，两者的不同之处在于以下几点：</p> 
<p style="margin-left:.0001pt;text-align:justify;">(1) 数据的取值范围不同，TIMESTEMP类型的取值范围更小。</p> 
<p style="margin-left:.0001pt;text-align:justify;">(2) 如果我们对TIMESTAMP类型的字段没有明确赋值，或是被赋与了NULL值，MySQL会自动将该字段赋值为系统当前的日期与时间。</p> 
<p style="margin-left:.0001pt;text-align:justify;">(3) TIMESTEMP类型还可以使用CURRENT_TIMESTAMP来获取系统当前时间。now() , sysdate() ,也可以显示获得当前时间。</p> 
<p style="margin-left:.0001pt;text-align:justify;">(4) TIMESTEMP类型有一个很大的特点，那就是时间是根据时区来显示的。例如，在东八区插入的TIMESTEMP数据为2017-07-11 16:43:25，在东七区显示时，时间部分就变成了15:43:25，在东九区显示时，时间部分就变成了17:43:25。</p> 
<p style="margin-left:.0001pt;text-align:justify;">在创建好数据库之后我们就开始插入数据。</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">格式：insert into 表名 values()——&gt;这是在所有字段插入的情况</p> 
 <p style="margin-left:.0001pt;text-align:justify;">insert into 表名 (字段名) values()——&gt;插入其中某几个字段 </p> 
 <p style="margin-left:.0001pt;text-align:justify;">可以在一个insert后面添加多条数据：insert into 表名 values (),(),();</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;">注意事项：</p> 
<ol><li style="text-align:left;">int  宽度是显示宽度，如果超过，可以自动增大宽度 int底层都是4个字节</li><li style="text-align:left;">时间的方式多样  '1256-12-23'  "1256/12/23"  "1256.12.23"</li><li style="text-align:left;">字符串不区分单引号和双引号</li><li style="text-align:left;">如何写入当前的时间  now() , sysdate() , CURRENT_DATE()</li><li style="text-align:left;">char varchar 是字符的个数，不是字节的个数，可以使用binary，varbinary表示定长和不定长的字节个数。超过长度会报错，不会自动增加宽度。</li></ol> 
<p style="text-align:left;">修改数据</p> 
<blockquote> 
 <p style="text-align:left;">update 表名 set 字段名="";——&gt;这种操作会将表中的所有数据都会更改</p> 
 <p style="text-align:left;">update 表名 set 字段名="" where 条件；——&gt;这种操作将会修改符号条件的数据</p> 
</blockquote> 
<p style="text-align:left;">删除数据</p> 
<blockquote> 
 <p style="text-align:left;">delete from 表名；会删除整个表数据</p> 
 <p style="text-align:left;">delete from 表名 where 字段=“”;会删除对于条件的数据</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">注意事项</p> 
<p style="margin-left:.0001pt;text-align:justify;">1.关键字，表名，字段名不区分大小写</p> 
<p style="margin-left:.0001pt;text-align:justify;">2.默认情况下，内容不区分大小写</p> 
<p style="margin-left:.0001pt;text-align:justify;">3.删除操作from关键字不可缺少</p> 
<p style="margin-left:.0001pt;text-align:justify;">4.修改，删除数据别忘记加限制条件</p> 
<p style="margin-left:.0001pt;text-align:justify;">修改、删除数据库表</p> 
<blockquote> 
 <p style="text-align:left;">修改表的结构：</p> 
 <ol><li style="text-align:left;">-- 增加一列：alter table 表名 add 字段名 字段类型 ; </li><li style="text-align:left;">-- 增加一列（放在最前面）alter table 表名 add 字段名 字段类型  first;</li><li style="text-align:left;">-- 增加一列（放在xx列的后面）alter table 表名 add 字段名 字段类型 after xx;</li><li style="text-align:left;">-- 删除一列：alter table 表名 drop 字段名</li><li style="text-align:left;">-- 修改一列：</li><li style="text-align:left;">alter table t_student modify score float(4,1); -- modify修改是列的类型的定义，但是不会改变列的名字</li><li style="text-align:left;">alter table t_student change score score1 double(5,1); -- change修改列名和列的类型的定义</li><li style="text-align:left;">-- 删除表：drop table 表名;</li></ol> 
</blockquote> 
<h3 id="%E8%A1%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F" style="text-align:left;">表的完整性约束</h3> 
<h4 id="%E9%9D%9E%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F" style="text-align:left;">非外键约束</h4> 
<p style="margin-left:.0001pt;text-align:justify;">为防止不符合规范的数据存入数据库，在用户对数据进行插入、修改、删除等操作时，MySQL提供了一种机制来检查数据库中的数据是否满足规定的条件，<span style="color:#0d0016;">以保证数据库中数据的准确性和一致性，这种机制就是完整性约束。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="330" src="https://images2.imgbox.com/b9/01/FhPO94Fa_o.png" width="920"></p> 
<p>注意：</p> 
<ol><li style="text-align:left;">如果sql报错，可能主键就浪费了，后续插入的主键是不连号的，我们主键也不要求连号的</li><li style="text-align:left;">如果主键没有设定值，或者用null.default都可以完成主键自增的效果</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">约束从作用上可以分为两类：</p> 
<p style="margin-left:.0001pt;text-align:justify;">(1)   表级约束：可以约束表中任意一个或多个字段。与列定义相互独立，不包含在列定义中；与定义用‘，’分隔；必须指出要约束的列的名称；</p> 
<p style="margin-left:.0001pt;text-align:justify;">(2)   列级约束：包含在列定义中，直接跟在该列的其它定义之后 ，用空格分隔；不必指定列名；</p> 
<pre><code class="language-sql">20.-- 在创建表以后添加约束：
21.alter table t_student add constraint pk_stu primary key (sno) ; -- 主键约束
22.alter table t_student modify sno int(6) auto_increment; -- 修改自增条件
23.alter table t_student add constraint ck_stu_sex check (sex = '男' || sex = '女');
24.alter table t_student add constraint ck_stu_age check (age &gt;= 18 and age &lt;= 50);
25.alter table t_student add constraint uq_stu_email unique (email);</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">总结：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1.主键约束  </p> 
<p style="margin-left:.0001pt;text-align:justify;">主键约束（PRIMARY KEY，缩写PK），是数据库中最重要的一种约束，其作用是约束表中的某个字段可以<strong><span style="color:#ff0000;"><strong>唯一标识一条记录</strong></span></strong>。因此，使用主键约束可以快速查找表中的记录。就像人的身份证、学生的学号等等，<strong><span style="color:#ff0000;"><strong>设置为主键的字段取值不能重复（唯一），也不能为空（非空）</strong></span></strong>，否则无法唯一标识一条记录。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">主键可以是单个字段，也可以是多个字段组合。</span>对于单字段主键的添加可使用表级约束，也可以使用列级约束；而对于多字段主键的添加只能使用表级约束。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2.</strong></strong><strong><strong>非空约束</strong></strong><strong> </strong> </p> 
<p style="margin-left:.0001pt;text-align:justify;">非空约束（NOT NULL，缩写NK）规定了一张表中指定的某个字段的值不能为空（NULL）。设置了非空约束的字段，在插入的数据为NULL时，数据库会提示错误，导致数据无法插入。</p> 
<p style="margin-left:.0001pt;text-align:justify;">无论是单个字段还是多个字段非空约束的添加只能使用列级约束（非空约束无表级约束） </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>为已存在表中的字段添加非空约束</strong></strong>  </p> 
<table border="1" cellspacing="0" style="margin-left:5.4pt;width:426pt;"><tbody><tr><td style="background-color:#e7e6e6;width:426pt;"> <p style="margin-left:.0001pt;text-align:justify;"> alter   table student8 modify stu_sex varchar(1) not null;</p> </td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;">  </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>使用ALTER TABLE语句删除非空约束</strong></strong>  </p> 
<table border="1" cellspacing="0" style="margin-left:5.4pt;width:426pt;"><tbody><tr><td style="background-color:#e7e6e6;width:426pt;"> <p style="margin-left:.0001pt;text-align:justify;"> alter  table student8 modify stu_sex varchar(1) null;</p> </td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3. </strong></strong><strong><strong>唯一约束</strong></strong> </p> 
<p style="margin-left:.0001pt;text-align:justify;">  </p> 
<p style="margin-left:.0001pt;text-align:justify;">唯一约束（UNIQUE，缩写UK）比较简单，它规定了一张表中指定的某个字段的值不能重复，即这一字段的每个值都是唯一的。如果想要某个字段的值不重复，那么就可以为该字段添加为唯一约束。</p> 
<p style="margin-left:.0001pt;text-align:justify;">无论单个字段还是多个字段唯一约束的添加均可使用列级约束和表级约束</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4. 检查约束 </strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">检查约束（CHECK）用来限制某个字段的取值范围，可以定义为列级约束，也可以定义为表级约束。MySQL8开始支持检查约束。  </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>5. 默认值约束 </strong></strong> </p> 
<p style="margin-left:.0001pt;text-align:justify;">默认值约束（DEFAULT）用来规定字段的默认值。如果某个被设置为DEFAULT约束的字段没插入具体值，那么该字段的值将会被默认值填充。</p> 
<p style="margin-left:.0001pt;text-align:justify;">     默认值约束的设置与非空约束一样，也只能使用列级约束。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>6. 字段值自动增加约束 </strong></strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">自增约束（AUTO_INCREMENT）可以使表中某个字段的值自动增加。一张表中只能有一个自增长字段，并且该字段必须定义了约束（该约束可以是主键约束、唯一约束以及外键约束），如果自增字段没有定义约束，数据库则会提示“Incorrect table definition; there can be only one auto column and it must be defined as a key”错误。</p> 
<p style="margin-left:.0001pt;text-align:justify;">由于自增约束会自动生成唯一的ID，所以自增约束通常会配合主键使用，并且只适用于整数类型。一般情况下，设置为自增约束字段的值会从1开始，每增加一条记录，该字段的值加1。</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">/*为student11表中的主键字段添加自增约束*/ </p> 
 <p style="margin-left:.0001pt;text-align:justify;">alter   table student11 modify stu_id int(10) auto_increment; </p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><strong>使用ALTER TABLE语句删除自增约束</strong></strong>  </p> 
 <p style="margin-left:.0001pt;text-align:justify;">alter   table studen11 modify stu_id int(10);</p> 
</blockquote> 
<h4 id="%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F" style="margin-left:.0001pt;text-align:justify;">外键约束</h4> 
<p style="margin-left:.0001pt;text-align:justify;">概述：</p> 
<p style="margin-left:.0001pt;text-align:justify;">外键约束（FOREIGN KEY，缩写FK）是用来实现数据库表的参照完整性的。外键约束可以使两张表紧密的结合起来，特别是针对修改或者删除的级联操作时，会保证数据的完整性。</p> 
<p style="margin-left:.0001pt;text-align:justify;">外键是指表中某个字段的值依赖于另一张表中某个字段的值，而被依赖的字段必须具有主键约束或者唯一约束。被依赖的表我们通常称之为父表或者主表，设置外键约束的表称为子表或者从表。</p> 
<blockquote> 
 <ul><li style="margin-left:.0001pt;text-align:justify;">创建的时候先创建父表，再创建子表</li><li style="margin-left:.0001pt;text-align:justify;">删除的时候先删除子表，再删除父表</li><li style="margin-left:.0001pt;text-align:justify;"> <p style="margin-left:.0001pt;text-align:justify;">外键约束只有表级约束，没有列级约束</p> </li><li style="margin-left:.0001pt;text-align:justify;"> <p style="margin-left:.0001pt;text-align:justify;">格式： constraint fk_stu_classno foreign key (字段名) references 父表名 (父表字段)</p> </li><li style="margin-left:.0001pt;text-align:justify;"> <p style="margin-left:.0001pt;text-align:justify;">在创建表以后添加外键约束：alter table 表名 add constraint fk_stu_classno foreign key (classno) references t_class (cno)</p> </li></ul> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;">外键策略：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">如果我们直接删除父表元素会报错，因为i有子表依赖；</p> 
 <p style="margin-left:.0001pt;text-align:justify;">策略1：no action不允许操作；就是把子表依赖的删除或者修改，然后可以删除父表中没有依赖的字段。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">策略2：cascade 级联操作：操作主表的时候影响从表的外键信息。</p> 
 <ol><li style="text-align:left;">先删除之前的外键约束：</li><li style="text-align:left;">alter table t_student drop foreign key fk_stu_classno;</li><li style="text-align:left;">-- 重新添加外键约束：</li><li style="text-align:left;">alter table t_student add constraint fk_stu_classno foreign key (classno) references t_class (cno) on update cascade on delete cascade;</li></ol> 
 <p style="text-align:left;">策略2就是在删除父表对于字段时候依赖于该字段的数据也会被删除，更高该字段时依赖的数据也会更改。</p> 
 <p style="text-align:left;">策略3：set null  置空操作：</p> 
 <ol><li style="text-align:left;">-- 先删除之前的外键约束：</li><li style="text-align:left;">alter table t_student drop foreign key 外键名;</li><li style="text-align:left;">-- 重新添加外键约束：</li><li style="text-align:left;">alter table t_student add constraint fk_stu_classno foreign key (classno) references t_class (cno) on update set null on delete set null;</li></ol> 
 <p style="text-align:left;">注意：策略2和策略3是可以混着使用的</p> 
</blockquote> 
<p style="text-align:left;">DDL和DML补充：</p> 
<blockquote> 
 <p style="text-align:left;">快速添加一张和xx一样的表：</p> 
 <ul><li style="text-align:left;">create table t_student2 as select * from xx;（包括表的数据和字段）</li><li style="text-align:left;">create table t_student2 as select * from xx where 1=2;(只包括表的字段不包括任何数据)</li><li style="text-align:left;">create table t_student4 as select sno,sname,age from t_student where sno = 2;(只包括表的某些字段和数据)</li></ul> 
 <p style="text-align:left;">清空数据操作：</p> 
 <ol><li style="text-align:left;">delete from t_student;</li><li style="text-align:left;">truncate table t_student;</li></ol> 
 <p style="margin-left:.0001pt;text-align:justify;">delete和truncate的区别：</p> 
 <p style="margin-left:.0001pt;text-align:justify;">从最终的结果来看，虽然使用TRUNCATE操作和使用DELETE操作都可以删除表中的全部记录，但是两者还是有很多区别的，其区别主要体现在以下几个方面：</p> 
 <p style="margin-left:.0001pt;text-align:justify;">(1)DELETE为数据操作语言DML；TRUNCATE为数据定义语言DDL。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">(2) DELETE操作是将表中所有记录一条一条删除直到删除完；TRUNCATE操作则是保留了表的结构，重新创建了这个表，所有的状态都相当于新表。因此，TRUNCATE操作的效率更高。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">(3)DELETE操作可以回滚；TRUNCATE操作会导致隐式提交，因此不能回滚（在第十章中会讲解事务的提交和回滚）。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">(4)DELETE操作执行成功后会返回已删除的行数（如删除4行记录，则会显示“Affected rows：4”）；截断操作不会返回已删除的行量，结果通常是“Affected rows：0”。DELETE操作删除表中记录后，再次向表中添加新记录时，对于设置有自增约束字段的值会从删除前表中该字段的最大值加1开始自增；TRUNCATE操作则会重新从1开始自增。</p> 
</blockquote> 
<h3 id="%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2" style="margin-left:.0001pt;text-align:justify;">单表查询</h3> 
<blockquote> 
 <p style="text-align:left;">select * from 表名;         从该表查询所有数据</p> 
 <p style="text-align:left;">select 字段 from 表名;   从该表查询该字段，字段之间用逗号隔开</p> 
 <p style="text-align:left;">显示部分行：where子句</p> 
 <p style="text-align:left;">select empno,ename,job,mgr from emp where sal &gt; 2000;显示部分列，部分行：</p> 
 <p style="text-align:left;"> 起别名：</p> 
 <ol><li style="text-align:left;">select empno 员工编号,ename 姓名,sal 工资 from emp; -- as 省略，''或者""省略了</li><li style="text-align:left;">-- as alias 别名</li><li style="text-align:left;">select empno as 员工编号,ename as 姓名,sal as 工资 from emp;</li><li style="text-align:left;">select empno as '员工编号',ename as "姓名",sal as 工资 from emp;</li><li style="text-align:left;">在别名中有特殊符号的时候，''或者""不可以省略不写</li><li style="text-align:left;"> 算术运算符：</li><li style="text-align:left;">select empno,ename,sal,sal+1000 as '涨薪后',deptno from emp where sal &lt; 2500;</li><li style="text-align:left;">select empno,ename,sal,comm,sal+comm from emp;  -- ？？？查询时候不仅仅可以在已有字段查询，也可以查询对其操作后的数据；但是在相加的时候若其中一个伪null，则结果是null</li><li style="text-align:left;">-- 去重操作：</li><li style="text-align:left;">select job from emp;</li><li style="text-align:left;">select distinct job from emp;</li><li style="text-align:left;">select job,deptno from emp;</li><li style="text-align:left;">select distinct job,deptno from emp; 在字段前面加上distinct对后面的所有列组合 去重 ，而不是单独的某一列去重</li><li style="text-align:left;">-- 排序：</li><li style="text-align:left;">select * from emp order by sal; -- 默认情况下是按照升序排列的</li><li style="text-align:left;">select * from emp order by sal asc; -- asc 升序，可以默认不写</li><li style="text-align:left;">select * from emp order by sal desc; -- desc 降序</li><li style="text-align:left;">select * from emp order by sal asc ,deptno desc; -- 在工资升序的情况下，deptno按照降序排列（就是首先按照工资升序排序，然后在工资相同的情况下deptno按降序排列）</li></ol> 
</blockquote> 
<p style="text-align:left;">where子句</p> 
<p style="text-align:left;">where子句：将过滤条件放在where子句的后面，可以筛选/过滤出我们想要的符合条件的数据：</p> 
<blockquote> 
 <p style="text-align:left;">-- where 子句 + 关系运算符</p> 
 <p style="text-align:left;">select * from emp where deptno = 10;</p> 
 <p style="text-align:left;">select * from emp where deptno &gt; 10;</p> 
 <p style="text-align:left;">select * from emp where deptno &gt;= 10;</p> 
 <p style="text-align:left;">select * from emp where deptno &lt; 10;</p> 
 <p style="text-align:left;">select * from emp where deptno &lt;= 10;</p> 
 <p style="text-align:left;">select * from emp where deptno &lt;&gt; 10;</p> 
 <p style="text-align:left;">select * from emp where deptno != 10;</p> 
 <p style="text-align:left;">select * from emp where job = 'CLERK';</p> 
 <p style="text-align:left;">select * from emp where job = 'clerk'; -- 默认情况下不区分大小写</p> 
 <p style="text-align:left;">select * from emp where <span style="color:#fe2c24;">binary </span><span style="color:#0d0016;">j</span>ob = 'clerk'; -- binary区分大小写</p> 
 <p style="text-align:left;">select * from emp where hiredate &lt; '1981-12-25';-- 对日期也可以比较</p> 
 <p style="text-align:left;"></p> 
 <p style="text-align:left;">-- where 子句 + 逻辑运算符：and</p> 
 <p style="text-align:left;"></p> 
 <p style="text-align:left;">select * from emp where sal &gt; 1500 and sal &lt; 3000;  -- (1500,3000)</p> 
 <p style="text-align:left;">select * from emp where sal &gt; 1500 &amp;&amp; sal &lt; 3000;</p> 
 <p style="text-align:left;">select * from emp where sal &gt; 1500 and sal &lt; 3000 order by sal;</p> 
 <p style="text-align:left;">select * from emp where sal between 1500 and 3000; -- [1500,3000]注意between……and是闭合的</p> 
 <p style="text-align:left;"> where 子句 + 逻辑运算符：or</p> 
 <p style="text-align:left;">select * from emp where deptno = 10 or deptno = 20;</p> 
 <p style="text-align:left;">select * from emp where deptno = 10 || deptno = 20;</p> 
 <p style="text-align:left;">select * from emp where deptno in (10,20);-- 选择是10或者20的结果</p> 
 <p style="text-align:left;">select * from emp where job in ('MANAGER','CLERK','ANALYST');</p> 
 <p style="text-align:left;"></p> 
 <p style="text-align:left;">-- where子句 + 模糊查询：</p> 
 <p style="text-align:left;">-- 查询名字中带A的员工  -- %代表通配符</p> 
 <p style="text-align:left;">select * from emp where ename like '%A%' ;</p> 
 <p style="text-align:left;">-- -任意一个字符</p> 
 <p style="text-align:left;">select * from emp where ename like '_A%' ;-- 下划线表示的是一个字符</p> 
 <p style="text-align:left;"></p> 
 <p style="text-align:left;"></p> 
 <p style="text-align:left;">-- 关于null的判断：</p> 
 <p style="text-align:left;">select * from emp where comm is null;</p> 
 <p style="text-align:left;">select * from emp where comm is not null;</p> 
 <p style="text-align:left;"></p> 
 <p style="text-align:left;"></p> 
 <p style="text-align:left;">-- 小括号的使用  ：因为不同的运算符的优先级别不同，加括号为了可读性</p> 
 <p style="text-align:left;">select * from emp where job = 'SALESMAN' or job = 'CLERK' and sal &gt;=1500; -- 先and再or 优先级： and &gt; or</p> 
 <p style="text-align:left;">select * from emp where job = 'SALESMAN' or (job = 'CLERK' and sal &gt;=1500);</p> 
 <p style="text-align:left;">select * from emp where (job = 'SALESMAN' or job = 'CLERK') and sal &gt;=1500;</p> 
</blockquote> 
<h3 id="%E5%87%BD%E6%95%B0" style="text-align:left;">函数</h3> 
<p style="margin-left:.0001pt;text-align:justify;">MySQL中提供了大量函数来简化用户对数据库的操作，比如字符串的处理、日期的运算、数值的运算等等。使用函数可以大大提高SELECT语句操作数据库的能力，同时也给数据的转换和处理提供了方便。 （在sql中使用函数）函数提高了select能力</p> 
<p style="margin-left:.0001pt;text-align:justify;">函数只是对查询结果中的数据进行处理，不会改变数据库中数据表的值。MySQL中的函数主要分为单行函数和多行函数两大类。（单行多行可以根据对其操作的数据进行判断，如果该函数操作的是多行数据eg：求最大值、最小、和等等就是多行函数，对一行数据进行处理就是单行函数）</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;">除了多行函数都是单行函数</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">单行函数</p> 
<p style="margin-left:.0001pt;text-align:justify;">字符串函数</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="916" src="https://images2.imgbox.com/c3/6e/hqjP3uTF_o.png" width="890"></p> 
<p>数值函数</p> 
<p><img alt="" height="477" src="https://images2.imgbox.com/ac/0d/QatQDGZl_o.png" width="897"> 日期与时间函数</p> 
<p><img alt="" height="925" src="https://images2.imgbox.com/38/81/pfyLJiKW_o.png" width="935"></p> 
<blockquote> 
 <p> 注意：</p> 
 <ul><li>substring下标是从1开始往后数</li><li> <p style="margin-left:.0001pt;text-align:justify;">select abs(-5),ceil(5.3),floor(5.9),round(3.14) from dual; -- dual实际就是一个伪表,也可以省略不写</p> </li><li> <p style="margin-left:.0001pt;text-align:justify;">curdate()是年月日，curtime()是时分秒;now()、sysdate()是年月日时分秒；但是当擦插入数据时候会参照表的结构的</p> </li></ul> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;">流程函数</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="545" src="https://images2.imgbox.com/a1/e8/Ir9NnMiQ_o.png" width="928"></p> 
<p style="margin-left:.0001pt;text-align:justify;">其他函数</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="397" src="https://images2.imgbox.com/c8/20/AO3MC9Tl_o.png" width="932"></p> 
<blockquote> 
 <p></p> 
 <ol><li style="text-align:left;">select empno,ename,sal,if(sal&gt;=2500,'高薪','底薪') as '薪资等级' from emp; -- if-else 双分支结构</li><li style="text-align:left;">select empno,ename,sal,comm,sal+ifnull(comm,0) from emp; -- 如果comm是null，那么取值为0 -- 单分支</li></ol> 
 <p style="text-align:left;">case job</p> 
 <p style="text-align:left;"> when 'CLERK' then '店员'</p> 
 <p style="text-align:left;"> when 'SALESMAN'  then '销售'</p> 
 <p style="text-align:left;"> when 'MANAGER' then '经理'</p> 
 <p style="text-align:left;"> else '其他'</p> 
 <p style="text-align:left;">end '岗位',</p> 
 <p style="text-align:left;">sal from emp;</p> 
 <p style="text-align:left;">注意：在查询多个字段时不同字段之间用逗号隔开，而和as 类似的重命名是空格</p> 
</blockquote> 
<p style="text-align:left;">多行函数</p> 
<p style="text-align:left;"><img alt="" height="272" src="https://images2.imgbox.com/42/81/BfawhqAQ_o.png" width="936"></p> 
<blockquote> 
 <ul><li> 多行函数会自动忽略null值，而0不会忽略</li><li style="text-align:left;">max(),min(),count()针对所有类型   sum(),avg() 只针对数值型类型有效</li><li style="text-align:left;">count计数：select count(*) from 表名;select 1 from 表名；直接使用某个字段不一定准确，因为count()不会统计null的个数。</li></ul> 
</blockquote> 
<p style="text-align:left;">group_by（用来分组）</p> 
<blockquote> 
 <p style="text-align:left;">当我们同时查询多行函数和某一个字段时候是不会出现预期结果，我们不能这么使用；通长我们可以先分组再求其多行函数。</p> 
 <ul><li style="text-align:left;"><span style="color:#000000;">select</span><span style="color:#000000;"> deptno,</span><span style="color:#000000;">avg</span><span style="color:#000000;">(sal) </span><span style="color:#000000;">from</span><span style="color:#000000;"> emp </span><span style="color:#000000;">group</span> <span style="color:#000000;">by</span><span style="color:#000000;"> deptno; </span><span style="color:#000000;">-- 字段和多行函数不可以同时使用,除非这个字段属于分组</span></li><li style="text-align:left;"><span style="color:#000000;">select</span><span style="color:#000000;"> deptno,</span><span style="color:#000000;">avg</span><span style="color:#000000;">(sal) </span><span style="color:#000000;">from</span><span style="color:#000000;"> emp </span><span style="color:#000000;">group</span> <span style="color:#000000;">by</span><span style="color:#000000;"> deptno </span><span style="color:#000000;">order</span> <span style="color:#000000;">by</span><span style="color:#000000;"> deptno </span><span style="color:#000000;">desc</span><span style="color:#000000;">;</span></li></ul> 
 <p style="text-align:left;"><span style="color:#000000;">having 分组后进行筛选</span></p> 
 <ul><li style="text-align:left;">select deptno,avg(sal) 平均工资 from emp group by deptno having 平均工资 &gt; 2000 order by deptno desc;</li></ul> 
 <p style="text-align:left;">有两种方法，可以先进行筛选再进行分组；或者先进行分组再进行筛选</p> 
 <p style="text-align:left;">select 字段名1,avg(字段名) from 表名  where 字段名条件 group by 字段名1</p> 
 <p style="text-align:left;">select 字段名1,avg(字段名) from 表名   group by 字段名1 having 字段名条件</p> 
 <p style="text-align:left;">having where order by后面都是加字段名，实现对其筛选或者按照某种规则排列输出。</p> 
</blockquote> 
<blockquote> 
 <p style="text-align:left;">单表查询语句总结：</p> 
 <p style="margin-left:.0001pt;text-align:justify;">select column, group_function(column) </p> 
 <p style="margin-left:.0001pt;text-align:justify;">from table </p> 
 <p style="margin-left:.0001pt;text-align:justify;">[where condition] </p> 
 <p style="margin-left:.0001pt;text-align:justify;">[group by  group_by_expression] </p> 
 <p style="margin-left:.0001pt;text-align:justify;">[having group_condition] </p> 
 <p style="margin-left:.0001pt;text-align:justify;">[order by column]; </p> 
 <p style="margin-left:.0001pt;text-align:justify;">注意：顺序固定，不可以改变顺序</p> 
 <p style="margin-left:.0001pt;text-align:justify;">select语句的执行顺序：from--where -- group  by–  select   -  having-   order  by</p> 
</blockquote> 
<h3 id="%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2" style="text-align:left;">多表查询</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">实际开发中往往需要针对两张甚至更多张数据表进行操作，而这多张表之间需要使用主键和外键关联在一起，然后使用连接查询来查询多张表中满足要求的数据记录。</p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;">一条SQL语句查询多个表，得到一个结果，包含多个表的数据。效率高。在SQL99中，连接查询需要使用join关键字实现。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">提供了多种连接查询的类型： cross   natural   using   on</p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;">交叉连接（CROSS JOIN）是对两个或者多个表进行笛卡儿积操作，所谓笛卡儿积就是关系代数里的一个概念，表示两个表中的每一行数据任意组合的结果。比如：有两个表，左表有m条数据记录，x个字段，右表有n条数据记录，y个字段，则执行交叉连接后将返回m*n条数据记录，x+y个字段</p> 
 <ul><li style="margin-left:.0001pt;text-align:justify;">交叉连接cross join:select * from 表名 cross join 表名（在mysql中cross是可以省略不写的）</li><li style="margin-left:.0001pt;text-align:justify;">自然连接natural join ：它可以自动匹配所有的同名列，同名列只展示一次 。:select * from 表名 natural join 表名；但是这种方法并没有指定查询字段所在表，查询速度慢、效率低</li><li style="margin-left:.0001pt;text-align:justify;">给字段名指定表 select e.empno,e.ename,e.sal,d.dname,d.loc,d.deptno from emp e natural join dept d;</li><li style="margin-left:.0001pt;text-align:justify;">在自然连接中他会自动匹配所有的同名字段，如果我们只想匹配部分字段，可以使用内连接</li></ul> 
 <p style="text-align:left;">select *  from emp e inner join dept d using(deptno) -- 这里不能写natural join了 ,这里是内连接，可以指定重名字段匹配</p> 
 <ul><li style="text-align:left;">select *  from emp e inner join dept d on (e.deptno = d.deptno);这里两个表中即使字段名不一样也可以匹配</li><li style="text-align:left;">可以在后面继续使用where子句进行一个筛选</li><li style="text-align:left;">在上面讲的连接方式中，如果连接要看的字段没有数据那么就不会在结果中显示，此时我们可以使用外连接的方式</li></ul> 
 <ol><li style="text-align:left;"> 左外连接： left outer join   -- 左面的那个表的信息，即使不匹配也可以查看出效果select *  from emp e left outer join dept d on e.deptno = d.deptno;</li><li style="text-align:left;"> 右外连接： right outer join   -- 右面的那个表的信息，即使不匹配也可以查看出效果select *  from emp e right outer join dept d on e.deptno = d.deptno;</li><li style="text-align:left;">在mysql中不支持全外连接，只能通过求并集的方式</li></ol> 
 <p style="text-align:left;">select *  from emp e left outer join dept d on e.deptno = d.deptno union  select *  from emp e right outer join dept d on e.deptno = d.deptno;这种方法去重，效率低</p> 
 <p style="text-align:left;">select *  from emp e left outer join dept d on e.deptno = d.deptno union all select *  from emp e right outer join dept d on e.deptno = d.deptno;这种方法不会去重，效率高。</p> 
 <p style="text-align:left;">其中outer可以省略不写，在mysql中只支持并集，交集和差集都不支持。</p> 
</blockquote> 
<p style="text-align:left;">三表连接查询</p> 
<p style="text-align:left;">思路：就是先查两个，然后把这个两个整体当作一个再与第三个表进行查询。</p> 
<p style="text-align:left;">eg: select e.ename,e.sal,e.empno,e.deptno,d.dname,s.*  from emp e right outer join dept d on e.deptno = d.deptno inner join salgrade s  on e.sal between s.losal and s.hisal</p> 
<p style="text-align:left;">自连接查询：就是把自己表看作是两张表，然后按上述方法对其操作。</p> 
<p style="text-align:left;">不相关子查询</p> 
<p style="text-align:left;">不相关的子查询：子查询可以独立运行，先运行子查询，再运行外查询。</p> 
<p style="text-align:left;">子查询就是一条SQL语句有多个select语句。可以看作是select的嵌套。</p> 
<blockquote> 
 <p style="text-align:left;">单行子查询：就是在后面where子句中的查询结果只有一个</p> 
 <p style="text-align:left;">select ename,sal from emp where deptno = (select deptno from emp where ename 'CLARK')  and sal &lt; (select sal from emp where ename = 'CLARK')</p> 
 <p style="text-align:left;">多行子查询</p> 
 <p style="text-align:left;">就是在后面的查询语句结果中有多个值，如果要是有其中一个可以使用in，如果比所有的都大，可以使用all；如果比其中一个大就行可以使用any</p> 
</blockquote> 
<p style="text-align:left;">相关子查询：子查询不可以独立运行，并且先运行外查询，再运行子查询。</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">好处：简单   功能强大（一些使用不相关子查询不能实现或者实现繁琐的子查询，可以使用相关子查询实现）</p> 
 <p style="margin-left:.0001pt;text-align:justify;">缺点：稍难理解</p> 
 <ol><li style="text-align:left;">select * from emp e where sal = (select max(sal) from emp where deptno = e.deptno) order by deptno</li><li style="text-align:left;">select * from emp e where sal &gt;= (select avg(sal) from emp e2 where e2.job = e.job)</li></ol> 
</blockquote> 
<h3 id="%E4%BA%8B%E5%8A%A1" style="margin-left:.0001pt;text-align:justify;">事务</h3> 
<p style="margin-left:.0001pt;text-align:left;">事务：</p> 
<p style="margin-left:.0001pt;text-align:justify;">事务（Transaction）指的是一个操作序列，该操作序列中的多个操作要么都做，要么都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位，由DBMS（数据库管理系统）中的事务管理子系统负责事务的处理。</p> 
<p style="margin-left:.0001pt;text-align:justify;">事务特性：</p> 
<p style="margin-left:.0001pt;text-align:justify;">事务处理可以确保除非事务性序列内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的序列，可以简化错误恢复并使应用程序更加可靠。</p> 
<p style="margin-left:.0001pt;text-align:justify;">但并不是所有的操作序列都可以称为事务，这是因为一个操作序列要成为事务，必须满足事务的原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这四个特性简称为<span style="background-color:#ffff00;">ACID</span>特性。</p> 
<blockquote> 
 <ol><li style="text-align:left;">-- 手动开启事务：</li><li style="text-align:left;">start transaction;</li><li style="text-align:left;"><li style="text-align:left;">update account set balance = balance - 200 where id = 1;</li><li style="text-align:left;">update account set balance = balance + 200 where id = 2;</li><li style="text-align:left;"><li style="text-align:left;">-- 手动回滚：刚才执行的操作全部取消：</li><li style="text-align:left;">rollback;</li><li style="text-align:left;">-- 手动提交：</li><li style="text-align:left;">commit;</li><li style="text-align:left;"><li style="text-align:left;">-- 在回滚和提交之前，数据库中的数据都是操作的缓存中的数据，而不是数据库的真实数据</li></ol> 
</blockquote> 
<p style="text-align:left;">事务并发问题</p> 
<p style="margin-left:.0001pt;text-align:justify;">脏读（Dirty read）</p> 
<p style="margin-left:.0001pt;text-align:justify;">当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">不可重复读</p> 
<p style="margin-left:.0001pt;text-align:justify;">（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p> 
<p style="margin-left:.0001pt;text-align:justify;">幻读</p> 
<p style="margin-left:.0001pt;text-align:justify;">（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>不可重复度和幻读区别：</strong></strong>  </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;">不可重复读的重点是修改，幻读的重点在于新增或者删除。 </span></p> 
<p style="margin-left:.0001pt;text-align:justify;">解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表  </p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 id="%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><strong><strong><strong>事务隔离级别</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">事务的隔离级别用于决定如何控制并发用户读写数据的操作。数据库是允许多用户并发访问的，如果多个用户同时开启事务并对同一数据进行读写操作的话，有可能会出现脏读、不可重复读和幻读问题，所以MySQL中提供了四种隔离级别来解决上述问题。</p> 
<p style="margin-left:.0001pt;text-align:justify;">    事务的隔离级别从低到高依次为READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ以及SERIALIZABLE，隔离级别越低，越能支持高并发的数据库操作。          <img alt="" height="205" src="https://images2.imgbox.com/72/53/HYSsh7Po_o.png" width="938"></p> 
<blockquote> 
 <ol><li style="text-align:left;">-- 查看默认的事务隔离级别  MySQL默认的是repeatable read  </li><li style="text-align:left;">select @@transaction_isolation;  </li><li style="text-align:left;">-- 设置事务的隔离级别   （设置当前会话的隔离级别）</li><li style="text-align:left;">set session transaction isolation level read uncommitted;  </li><li style="text-align:left;">set session transaction isolation level read committed;  </li><li style="text-align:left;">set session transaction isolation level repeatable read;  </li><li style="text-align:left;">set session transaction isolation level serializable;  </li><li style="text-align:left;"><li style="text-align:left;">start transaction ;</li><li style="text-align:left;">select * from account where id = 1; </li></ol> 
</blockquote> 
<h3 id="%E8%A7%86%E5%9B%BE" style="text-align:left;">视图</h3> 
<p style="text-align:left;">概述：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">视图（view）是</span></span><span style="background-color:#ffffff;"><span style="color:#ff6600;">一个</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">从单张或多张基础数据表或其他视图中构建出来的</span></span><span style="background-color:#ffffff;"><span style="color:#ff6600;">虚拟表</span></span><span style="background-color:#ffffff;"><span style="color:#222222;">。同基础表一样，视图中也包含了一系列带有名称的列和行数据，但是数据库中只是存放视图的定义，也就是动态检索数据的查询语句，而并不存放视图中的数据，这些数据依旧存放于构建视图的基础表中，只有当用户使用视图时才去数据库请求相对应的数据，即视图中的数据是在引用视图时动态生成的。因此视图中的数据依赖于构建视图的基础表，如果基本表中的数据发生了变化，视图中相应的数据也会跟着改变。</span></span> </p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#222222;">PS:视图本质上就是：一个查询语句，是一个虚拟的表，不存在的表，你查看视图，其实就是查看视图对应的sql语句</span></span> </p> 
<p style="text-align:left;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0546be0f36c163476cd9d457378c85c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【JWT在线解密为什么不用提供密钥也可以】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c0cf2a1faf4e6080185f8177065c37a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SSH远程连接报错:Permission denied, please try again.的解决办法【备忘】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>