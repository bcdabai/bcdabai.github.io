<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue：跨域以及sessionId不一致问题解决方法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue：跨域以及sessionId不一致问题解决方法" />
<meta property="og:description" content="情景：
使用Vue和SpringBoot做前后端分离项目，出现跨域问题，因为前端访问调用后端3个接口，
第一：session校验 ，第二：登录 ，第三：查询接口
但是将session分别获取，然后打印出来，发现sessionid不一致，导致访问第三个查询数据接口而失败。
后端springboot处理： 拦截器preHandle中加入如下 代码：
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception { response.setHeader(&#34;Access-Control-Allow-Origin&#34;,request.getHeader(&#34;Origin&#34;)); response.setHeader(&#34;Access-Control-Allow-Methods&#34;, &#34;*&#34;); response.setHeader(&#34;Access-Control-Allow-Credentials&#34;, &#34;true&#34;); response.setHeader(&#34;Access-Control-Allow-Headers&#34;, &#34;Authorization,Origin, X-Requested-With, Content-Type, Accept,Access-Token&#34;);//Origin, X-Requested-With, Content-Type, Accept,Access-Token return true; } 关键是这两句 response.setHeader(&#34;Access-Control-Allow-Origin&#34;,request.getHeader(&#34;Origin&#34;));//支持跨域请求
response.setHeader(&#34;Access-Control-Allow-Credentials&#34;, &#34;true&#34;);//是否支持cookie跨域
注意：当Access-Control-Allow-Credentials设置为ture时，Access-Control-Allow-Origin不能设置为*
package com.huayong.bi.web.interceptor; import com.huayong.bi.inter.constants.EnumHttpStatusType; import com.huayong.bi.inter.util.LogUtil; import com.huayong.bi.web.common.util.SpringUtil; import com.huayong.bi.web.dao.impl.PermissionCheckImpl; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import com.alibaba.fastjson.JSONObject; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.PrintWriter; import java.util.Arrays; import java." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/547d1755779614212e20ff99493ff5fa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-07T12:25:23+08:00" />
<meta property="article:modified_time" content="2019-06-07T12:25:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue：跨域以及sessionId不一致问题解决方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>情景：</p> 
<p>使用Vue和SpringBoot做前后端分离项目，出现跨域问题，因为前端访问调用后端3个接口，</p> 
<p>第一：session校验 ，第二：登录 ，第三：查询接口</p> 
<p>但是将session分别获取，然后打印出来，发现sessionid不一致，导致访问第三个查询数据接口而失败。</p> 
<p> </p> 
<h4>后端springboot处理：</h4> 
<p>拦截器preHandle中加入如下 代码：</p> 
<pre class="has"><code> public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception {
 
    	response.setHeader("Access-Control-Allow-Origin",request.getHeader("Origin"));
        response.setHeader("Access-Control-Allow-Methods", "*");
        response.setHeader("Access-Control-Allow-Credentials", "true");
        response.setHeader("Access-Control-Allow-Headers", "Authorization,Origin, X-Requested-With, Content-Type, Accept,Access-Token");//Origin, X-Requested-With, Content-Type, Accept,Access-Token
        return true;
    }
</code></pre> 
<p>关键是这两句 </p> 
<p>response.setHeader("Access-Control-Allow-Origin",request.getHeader("Origin"));//支持跨域请求</p> 
<p>response.setHeader("Access-Control-Allow-Credentials", "true");//是否支持cookie跨域</p> 
<p>注意：当Access-Control-Allow-Credentials设置为ture时，Access-Control-Allow-Origin不能设置为*</p> 
<p> </p> 
<p><img alt="" class="has" height="635" src="https://images2.imgbox.com/7c/5f/DpLzqyuu_o.png" width="1200"></p> 
<pre class="has"><code>package com.huayong.bi.web.interceptor;

import com.huayong.bi.inter.constants.EnumHttpStatusType;
import com.huayong.bi.inter.util.LogUtil;
import com.huayong.bi.web.common.util.SpringUtil;
import com.huayong.bi.web.dao.impl.PermissionCheckImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
import com.alibaba.fastjson.JSONObject;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Set;

public class LoginInterceptor implements HandlerInterceptor {

    private static final Logger log = LoggerFactory.getLogger(LoginInterceptor.class);

    PermissionCheckImpl pci = null;


    /**
     * 进入controller层之前拦截请求
     * @param request
     * @param
     * @param
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        PrintWriter out = null;
        JSONObject jo = null;
        try {
        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json; charset=utf-8");
//        response.setHeader("Access-Control-Allow-Origin", "*");
//        response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE");
//        response.setHeader("Access-Control-Max-Age", "3600");
//        response.setHeader("Access-Control-Allow-Headers", "x-requested-with");


            response.setHeader("Access-Control-Allow-Origin",request.getHeader("Origin"));
            response.setHeader("Access-Control-Allow-Methods", "*");
            response.setHeader("Access-Control-Allow-Credentials", "true");
            response.setHeader("Access-Control-Allow-Headers", "Authorization,Origin, X-Requested-With, Content-Type, Accept,Access-Token");//Origin, X-Requested-With, Content-Type, Accept,Access-Token
            

        //本地调试将if-else注释 直接返回true
        if ("".equals((String) request.getSession().getAttribute("token")) || (String) request.getSession().getAttribute("token") == null) {
            PrintWriter writer = response.getWriter();
            writer.print("login");
            return false;
        } else {
            System.out.println("=====LoginInterceptor=======");
            //校验权限
            String userName = (String) request.getSession().getAttribute("userName");
            String mobile = (String) request.getSession().getAttribute("mobile");
            LogUtil.print("---userName---" + userName);
            LogUtil.print("---mobile---" + mobile);
            LogUtil.print("URL : " + request.getRequestURL().toString());
            System.out.println("URL : " + request.getRequestURL().toString());
            System.out.println("RequestURI : " + request.getRequestURI());
            pci = (PermissionCheckImpl) SpringUtil.getBean("permissionCheckImpl");
            String uri = request.getRequestURI();
            Set&lt;String&gt; set = pci.queryPermissions(userName, mobile);
            if(null==set || set.size()&lt;1){
                //默认用户
                userName="普通用户";
                mobile="0";
                set = pci.queryPermissions(userName, mobile);
            }
            boolean per = false;
                if (null != set &amp;&amp; set.size() &gt; 0) {
                    for (String se : set) {
                        LogUtil.print("---se---" + se);
                        if (uri.split("/")[1].equals(se.replace("/", ""))) {
                            if (per == false) {
                                per = true;
                            }
                        }
                    }
                }else{
                    jo = new JSONObject();
                    jo.put("code", EnumHttpStatusType.no_permission.getCode());
                    jo.put("msg", EnumHttpStatusType.no_permission.getStatus());
                    jo.put("data", "");
                    out = response.getWriter();
                    out.append(jo.toString());
                    return false;
                }
                if (per == true) {
                    return true;
                } else {
                        jo = new JSONObject();
                        jo.put("code", EnumHttpStatusType.no_permission.getCode());
                        jo.put("msg", EnumHttpStatusType.no_permission.getStatus());
                        jo.put("data", "");
                        out = response.getWriter();
                        out.append(jo.toString());
                        return false;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            response.sendError(500);
            return false;
        }
    }

    @Override
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
        //log.info("--------------处理请求完成后视图渲染之前的处理操作---------------");
    }

    @Override
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {
        //log.info("---------------视图渲染之后的操作-------------------------0");
    }

}</code></pre> 
<h4>前端vue处理：</h4> 
<p><strong>前端使用 axios请求数据</strong></p> 
<p>axios默认是发送请求的时候不会带上cookie的，需要通过设置withCredentials: true来解决 </p> 
<pre class="has"><code>axios.defaults.withCredentials = true</code></pre> 
<p><img alt="" class="has" height="586" src="https://images2.imgbox.com/98/c4/nkYLUd9i_o.png" width="594"></p> 
<p> </p> 
<p>参考：</p> 
<p><a href="https://blog.csdn.net/xukongjing1/article/details/83308057">https://blog.csdn.net/xukongjing1/article/details/83308057</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ef7141b52c7633a17eae0ecf7c5ee6a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">redis 反序列化deserialize异常问题解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1fda5ee66c13124860835ef2968980b2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PN结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>