<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CMakeLists.txt 之C&#43;&#43; - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CMakeLists.txt 之C&#43;&#43;" />
<meta property="og:description" content="https://blog.codekissyoung.com/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/cmake CMake 入门实战
CMake Official Tutorial——教程还是官方的好
cmake 教程 基本语法
一、什么是Cmake CMake是一个跨平台的、开源的安装(编译)工具， 因为它使用和平台、编译器无关的配置文件（较为简单的语句）来描述编译控制，所以他能够输出各种各样的makefile或者project文件,能测试编译器所支持的C&#43;&#43;特性,类似UNIX下的automake。
二、常用命令 1. 指定 cmake 的最小版本 cmake_minimum_required(VERSION 3.15) 可选命令，如果 CMakeLists.txt 中使用了高版本 cmake 特有的命令，需要use这一行加以声明，会check and advice 升级到该版本或以上。
2. 设置项目名称 project(demo) 这个命令不是强制性的，加上它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。
3. 设置支持C&#43;&#43;版本 set(CMAKE_CXX_STANDARD 14) 这里CMake 3.1或者更高版本支持使用这个，更低版本使用如下：
set(CMAKE_CXX_FLAGS &#34;${CMAKE_CXX_FLAGS} -std=c&#43;&#43;11&#34;) 也可以使用如下，我最早接触是这个：
add_definitions(-std=c&#43;&#43;11) #add_definitions(&#34;-Wall -std=c&#43;&#43;14&#34;) 4. 设置编译器类型 set(CMAKE_CXX_COMPILER g&#43;&#43;) 系统默认的gcc/g&#43;&#43;在/usr/bin目录下。
我们升级安装的gcc目录在/usr/local/bin目录下，现在我们希望使用升级后的gcc。
通过百度搜索出来的结果，大多是如下操作:
在CMakeLists.txt中调用编译器之前添加：
SET(CMAKE_C_COMPILER &#34;/usr/local/bin/gcc&#34;)
SET(CMAKE_CXX_COMPILER &#34;/usr/local/bin/g&#43;&#43;&#34;)
然而经过本人亲自实践，该方法不起作用，正确的做法是：
执行cmake命令之前，在shell终端先设置如下两个变量：
export CC=/usr/local/bin/gcc
export CXX=/usr/local/bin/g&#43;&#43;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d4b9829bb9a7dbabd3e79c57f9e99783/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-15T22:12:56+08:00" />
<meta property="article:modified_time" content="2020-11-15T22:12:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CMakeLists.txt 之C&#43;&#43;</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a href="https://blog.codekissyoung.com/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/cmake" rel="nofollow">https://blog.codekissyoung.com/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/cmake</a></h2> 
<ul><li> <p><a href="http://www.hahack.com/codes/cmake/" rel="nofollow">CMake 入门实战</a></p> </li><li> <p><a href="https://www.cnblogs.com/Xiaoyan-Li/p/5674747.html" rel="nofollow">CMake Official Tutorial——教程还是官方的好</a></p> </li><li> <p><a href="https://blog.csdn.net/luanpeng825485697/article/details/81202136">cmake 教程 基本语法</a></p> </li><li> <p> </p> </li></ul> 
<h2 id="articleContentId">一、什么是Cmake</h2> 
<p><a href="http://tzc.is-programmer.com/posts/496.html" rel="nofollow">   CMake是一个跨平台的、开源的安装(编译)工具， 因为它使用和平台、编译器无关的配置文件（较为简单的语句）来描述编译控制，所以他能够输出各种各样的makefile或者project文件,能测试编译器所支持的C++特性,类似UNIX下的automake。</a></p> 
<p> </p> 
<h3 id="-"><a name="t1"></a>二、常用命令</h3> 
<h4 id="1-cmake-"><a name="t2"></a>1. 指定 cmake 的最小版本</h4> 
<pre><code class="language-cpp">cmake_minimum_required(VERSION 3.15)</code></pre> 
<p>可选命令，如果 CMakeLists.txt 中使用了高版本 cmake 特有的命令，需要use这一行加以声明，会check and advice 升级到该版本或以上。</p> 
<h4 id="2-"><a name="t3"></a>2. 设置项目名称</h4> 
<pre><code class="language-cpp">project(demo)</code></pre> 
<p>这个命令不是强制性的，加上它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。</p> 
<h4 id="3-"><a name="t4"></a>3. 设置支持C++版本</h4> 
<pre><code>set(CMAKE_CXX_STANDARD 14)</code></pre> 
<p>这里CMake 3.1或者更高版本支持使用这个，更低版本使用如下：</p> 
<pre><code>set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")</code></pre> 
<p>也可以使用如下，我最早接触是这个：</p> 
<pre><code>add_definitions(-std=c++11)
#add_definitions("-Wall -std=c++14")
</code></pre> 
<h4>4. 设置编译器类型</h4> 
<pre><code>set(CMAKE_CXX_COMPILER g++)
</code></pre> 
<p style="text-indent:0;"><br> 系统默认的gcc/g++在/usr/bin目录下。</p> 
<p style="text-indent:0;">我们升级安装的gcc目录在/usr/local/bin目录下，现在我们希望使用升级后的gcc。</p> 
<p style="text-indent:0;">通过百度搜索出来的结果，大多是如下操作:</p> 
<p style="text-indent:0;">在CMakeLists.txt中调用编译器之前添加：</p> 
<p style="text-indent:0;">SET(CMAKE_C_COMPILER "/usr/local/bin/gcc")<br> SET(CMAKE_CXX_COMPILER "/usr/local/bin/g++")<br> 然而经过本人亲自实践，该方法不起作用，正确的做法是：</p> 
<p style="text-indent:0;">执行cmake命令之前，在shell终端先设置如下两个变量：</p> 
<p style="text-indent:0;">export CC=/usr/local/bin/gcc<br> export CXX=/usr/local/bin/g++<br> 然后再执行cmake等后续命令，这样就可以用指定的编译器版本了。</p> 
<p style="text-indent:0;">具体更多的原因，请参考此处：https://stackoverflow.com/questions/17275348/how-to-specify-new-gcc-path-for-cmake</p> 
<p> </p> 
<h4>5. 设置目标文件支持系统总线架构（默认同编译系统一致）</h4> 
<pre><code>set(CMAKE_CXX_FLAGS "-m64")
</code></pre> 
<h4>6. 设置生成目标类型</h4> 
<ol><li> <p><code>add_executable(demo demo.cpp) # 生成可执行文件</code>demo | demo.exe</p> </li><li> <p><code>add_library(common <span style="color:#f33b45;">STATIC </span>util.cpp) # 生成静态库</code>libcommon.a | common.lib</p> </li><li> <p><code>add_library(common <span style="color:#f33b45;">SHARED</span> util.cpp) # 生成动态库或共享库</code>libcommon.so | common.dll</p> </li></ol> 
<p><span style="color:#f33b45;">      add_library 默认生成是静态库</span>，通过以上命令生成文件名字，<br>  </p> 
<h4 id="4-"><a name="t5"></a>7 指定编译包含的源文件</h4> 
<p><strong>7.1 明确指定包含哪些源文件</strong></p> 
<pre><code>add_library(demo demo.cpp test.cpp util.cpp)
#add_executable(demo src/demo.cpp)</code></pre> 
<p><strong>7.2 搜索方式添加cpp 文件</strong></p> 
<p>aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。</p> 
<ol><li> <p><code>aux_source_directory(. SRC_LIST) # 搜索当前目录下的所有.cpp文件</code></p> </li><li> <p><code>add_library(demo ${SRC_LIST})  或 add_library(demo <span style="color:#f33b45;">SHARED</span> ${SRC_LIST})<span style="color:#f33b45;"> </span>或 add_executable(demo ${SRC_LIST}) </code></p> </li></ol> 
<p><strong>7.3 自定义搜索规则</strong></p> 
<pre><code>file(GLOB SRC_LIST "*.cpp" "protocol/*.cpp")
add_library(demo ${SRC_LIST})</code></pre> 
<p><code># 或者</code></p> 
<pre><code>file(GLOB SRC_LIST "*.cpp")
file(GLOB SRC_PROTOCOL_LIST "protocol/*.cpp")

add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})</code></pre> 
<p>#或者</p> 
<pre><code>aux_source_directory(. SRC_LIST)
aux_source_directory(protocol SRC_PROTOCOL_LIST)

add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})</code></pre> 
<p> </p> 
<h4 id="5-"><a name="t6"></a>8. 查找指定的库文件</h4> 
<p>find_library(VAR name path)查找到指定的预编译库，并将它的路径存储在变量中。<br> 默认的搜索路径为 cmake 包含的系统库，因此如果是公共库只需要指定库的 name 即可。</p> 
<pre><code>find_library( # Sets the name of the path variable.

log-lib

# you want CMake to locate.

log )</code></pre> 
<pre><code>find_path(HIREDIS_INCLUDE_DIR hiredis.h /usr/local/include/hiredis)
find_library(HIREDIS_LIBRARY NAMES hiredis PATH /usr/local/lib)

if(HIREDIS_INCLUDE_DIR AND HIREDIS_LIBRARY)
    SET(HIREDIS_FOUND TRUE)
endif(HIREDIS_INCLUDE_DIR AND HIREDIS_LIBRARY)</code></pre> 
<p>类似的命令还有 find_file()、find_path()、find_program()、find_package()。</p> 
<h4 id="6-"><a name="t7"></a>9. 设置包含的目录</h4> 
<pre><code>/*
include_directories(

${CMAKE_CURRENT_SOURCE_DIR}

${CMAKE_CURRENT_BINARY_DIR}

${CMAKE_CURRENT_SOURCE_DIR}/include

)
*/


set(INC_DIR include)
include_directories(${INC_DIR})</code></pre> 
<p>Linux 下还可以通过如下方式设置包含的目录</p> 
<pre><code>set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -I${CMAKE_CURRENT_SOURCE_DIR}")</code></pre> 
<h4 id="7-"><a name="t8"></a>10. 设置链接库搜索目录</h4> 
<pre><code class="language-cpp">#link_directories(
#${CMAKE_CURRENT_SOURCE_DIR}/libs
#)

link_directories(${LINK_DIR})
link_libraries(library_name)

add_executable(project_name ${SOURCE_FILES})

target_link_libraries(project_name library_name)</code></pre> 
<pre><code class="language-html hljs">Linux 下还可以通过如下方式设置包含的目录
</code></pre> 
<pre><code>set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -L${CMAKE_CURRENT_SOURCE_DIR}/libs")</code></pre> 
<h4 id="8-target-"><a name="t9"></a>11. 设置 target 需要链接的库</h4> 
<pre><code>target_link_libraries( # 目标库

demo

# 目标库需要链接的库
# log-lib 是上面 find_library 指定的变量名

${log-lib} )</code></pre> 
<p>在 Windows 下，系统会根据链接库目录，搜索xxx.lib 文件，Linux 下会搜索 xxx.so 或者 xxx.a 文件，如果都存在会优先链接动态库（so 后缀）。</p> 
<p><strong>11.1 指定链接动态库或静态库</strong></p> 
<pre><code>target_link_libraries(demo libface.a) # 链接libface.a

target_link_libraries(demo libface.so) # 链接libface.so</code></pre> 
<pre><code class="language-html hljs">11.2 指定全路径
</code></pre> 
<pre><code>target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a)

target_link_libraries(demo ${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.so)</code></pre> 
<p><strong>11.3 指定链接多个库</strong></p> 
<pre><code>target_link_libraries(demo

${CMAKE_CURRENT_SOURCE_DIR}/libs/libface.a

boost_system.a

boost_thread

pthread)</code></pre> 
<h4 id="9-"><a name="t10"></a>12. 设置变量</h4> 
<p><strong>12.1 set 直接设置变量的值</strong></p> 
<pre><code>set(SRC_LIST main.cpp test.cpp)

add_executable(demo ${SRC_LIST})</code></pre> 
<p><strong>12.2 set 追加设置变量的值</strong></p> 
<ol><li> <p><code>set(SRC_LIST main.cpp)</code></p> </li><li> <p><span style="color:#f33b45;"><code>set(SRC_LIST ${SRC_LIST} test.cpp)</code></span></p> </li><li> <p><code>add_executable(demo ${SRC_LIST})</code></p> </li></ol> 
<pre><code class="language-html hljs">12.3 list 追加或者删除变量的值
</code></pre> 
<ol><li> <p><code>set(SRC_LIST main.cpp)</code></p> </li><li> <p><code>list(<span style="color:#f33b45;">APPEND SRC_LIST</span> test.cpp)</code></p> </li><li> <p><code>list(<span style="color:#f33b45;">REMOVE_ITEM SRC_LIST</span> main.cpp)</code></p> </li><li> <p><code>add_executable(demo ${SRC_LIST})</code></p> </li></ol> 
<h4 id="10-"><a name="t11"></a>13. 条件控制</h4> 
<p><strong>13.1 if…elseif…else…endif</strong></p> 
<p><strong>逻辑判断和比较：</strong><br><strong>if (expression)</strong>：expression 不为空（0,N,NO,OFF,FALSE,NOTFOUND）时为真<br><strong>if (not exp)</strong>：与上面相反<br><strong>if (var1 AND var2)</strong><br><strong>if (var1 OR var2)</strong><br><strong>if (COMMAND cmd)</strong>：如果 cmd 确实是命令并可调用为真<br><strong>if (EXISTS dir) if (EXISTS file)</strong>：如果目录或文件存在为真<br><strong>if (file1 IS_NEWER_THAN file2)</strong>：当 file1 比 file2 新，或 file1/file2 中有一个不存在时为真，文件名需使用全路径<br><strong>if (IS_DIRECTORY dir)</strong>：当 dir 是目录时为真<br><strong>if (DEFINED var)</strong>：如果变量被定义为真<br><strong>if (var MATCHES regex)</strong>：给定的变量或者字符串能够匹配正则表达式 regex 时为真，此处 var 可以用 var 名，也可以用 ${var}<br><strong>if (string MATCHES regex)</strong></p> 
<p><strong>数字比较：</strong><br><strong>if (variable LESS number)</strong>：LESS 小于<br><strong>if (string LESS number)</strong><br><strong>if (variable GREATER number)</strong>：GREATER 大于<br><strong>if (string GREATER number)</strong><br><strong>if (variable EQUAL number)</strong>：EQUAL 等于<br><strong>if (string EQUAL number)</strong></p> 
<p><strong>字母表顺序比较：</strong><br><strong>if (variable STRLESS string)<br> if (string STRLESS string)<br> if (variable STRGREATER string)<br> if (string STRGREATER string)<br> if (variable STREQUAL string)<br> if (string STREQUAL string)</strong><br><strong>示例：</strong></p> 
<pre><code>if(MSVC)

set(LINK_LIBS common)

else()

set(boost_thread boost_log.a boost_system.a)

endif()

target_link_libraries(demo ${LINK_LIBS})

# 或者

if(UNIX)

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -fpermissive -g")

else()

add_definitions(-D_SCL_SECURE_NO_WARNINGS

D_CRT_SECURE_NO_WARNINGS

-D_WIN32_WINNT=0x601

-D_WINSOCK_DEPRECATED_NO_WARNINGS)

endif()


if(${CMAKE_BUILD_TYPE} MATCHES "debug")

...

else()

...

endif()</code></pre> 
<p><strong>10.2 while…endwhile</strong></p> 
<pre><code>while(condition)

...

endwhile()</code></pre> 
<p><strong>10.3 foreach…endforeach</strong></p> 
<pre><code>foreach(loop_var RANGE start stop [step])

...

endforeach(loop_var)



foreach(i RANGE 1 9 2)

message(${i})

endforeach(i)

# 输出：13579</code></pre> 
<p>start 表示起始数，stop 表示终止数，step 表示步长</p> 
<pre><code class="language-html hljs">11. 打印信息
</code></pre> 
<pre><code>message(${PROJECT_SOURCE_DIR})

message("build with debug mode")

message(WARNING "this is warnning message")

message(FATAL_ERROR "this build has many error") # FATAL_ERROR 会导致编译失败</code></pre> 
<h4 id="12-cmake-"><a name="t13"></a>12. 包含其它 cmake 文件</h4> 
<pre><code>include(./common.cmake) # 指定包含文件的全路径

include(def) # 在搜索路径中搜索def.cmake文件

set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake) # 设置include的搜索路径</code></pre> 
<h3><a name="t14"></a>三、常用变量</h3> 
<h4 id="1-"><a name="t15"></a>1. 预定义变量</h4> 
<p><strong>PROJECT_SOURCE_DIR</strong>：工程的根目录<br><strong>PROJECT_BINARY_DIR</strong>：运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}/build<br><strong>PROJECT_NAME</strong>：返回通过 project 命令定义的项目名称<br><strong>CMAKE_CURRENT_SOURCE_DIR</strong>：当前处理的 CMakeLists.txt 所在的路径<br><strong>CMAKE_CURRENT_BINARY_DIR</strong>：target 编译目录<br><strong>CMAKE_CURRENT_LIST_DIR</strong>：CMakeLists.txt 的完整路径<br><strong>CMAKE_CURRENT_LIST_LINE</strong>：当前所在的行<br><strong>CMAKE_MODULE_PATH</strong>：定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)，然后可以用INCLUDE命令来调用自己的模块<br><strong>EXECUTABLE_OUTPUT_PATH</strong>：重新定义目标二进制可执行文件的存放位置<br><strong>LIBRARY_OUTPUT_PATH</strong>：重新定义目标链接库文件的存放位置</p> 
<p> </p> 
<h3>变量参考,项目目录相关:</h3> 
<pre><code># 构建发生的目录
CMAKE_BINARY_DIR
PROJECT_BINARY_DIR
&lt;projectname&gt;_BINARY_DIR

# 不论采用何种编译方式，都是工程顶层目录
CMAKE_SOURCE_DIR
PROJECT_SOURCE_DIR
&lt;projectname&gt;_SOURCE_DIR

CMAKE_CURRENT_SOURCE_DIR  # 当前处理的CMakeLists.txt所在的路径

CMAKE_CURRRENT_BINARY_DIR # 内部编译: 跟CMAKE_CURRENT_SOURCE_DIR一致
                          # 外部编译: 指的是构建目录
                          # add_subdirectory(src bin) 会更改它的值为 bin

CMAKE_CURRENT_LIST_FILE   # 当前输出所在的CMakeLists.txt的完整路径
CMAKE_CURRENT_LIST_LINE   # 当前输出所在的行





CMAKE_MODULE_PATH         # 模块所在路径

EXECUTABLE_OUTPUT_PATH    # 可执行文件存放目录
LIBRARY_OUTPUT_PATH       # 库存放目录

CMAKE_INCLUDE_DIRECTORIES_PROJECT_BEFORE # 将工程提供的头文件目录始终置于系统头文件目录的前面

CMAKE_INCLUDE_PATH        # 头文件搜索目录

CMAKE_LIBRARY_PATH        # 库搜索目录</code></pre> 
<p> </p> 
<h4><a name="t16"></a>2. 环境变量</h4> 
<p>使用环境变量</p> 
<pre><code> $ENV{Name}</code></pre> 
<p>写入环境变量</p> 
<pre><code> set(ENV{Name} value) # 这里没有“$”符号</code></pre> 
<h4><a name="t17"></a>3. 系统信息</h4> 
<p>CMAKE_MAJOR_VERSION       # CMAKE主版本号，比如2.4.6中的2<br> CMAKE_MINOR_VERSION       # CMAKE次版本号，比如2.4.6中的4<br> CMAKE_PATCH_VERSION       # CMAKE补丁等级，比如2.4.6中的6<br> CMAKE_SYSTEM              # 系统名称，比如Linux-2.6.22<br> CMAKE_SYSTEM_NAME         # 不包含版本的系统名，比如Linux<br> CMAKE_SYSTEM_VERSION      # 系统版本，比如2.6.22<br> CMAKE_SYSTEM_PROCESSOR    # 处理器名称，比如i686<br> UNIX                      # 在所有的类Unix平台为TRUE，包括OSX和cygwin<br> WIN32                     # 在所有的Win32平台为TRUE，包括cygwin</p> 
<p> </p> 
<p><strong>4. 主要开关选项</strong></p> 
<p><span style="color:#f33b45;">CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS   # 用来控制IF ELSE语句的书写方式<br> CMAKE_INCLUDE_CURRENT_DIR           # 自动将每个CMakeLists.txt的所在目录依次加入到 头文件搜索目录</span></p> 
<p><strong>BUILD_SHARED_LIBS</strong><span style="color:#f33b45;">：这个开关用来控制默认的库编译方式，如果不进行设置，使用 add_library 又没有指定库类型的情况下，默认编译生成的库都是静态库。如果 </span><span style="color:#86ca5e;">set(BUILD_SHARED_LIBS ON) 后，默认生成的为动态库</span></p> 
<p><span style="color:#f33b45;"><strong>CMAKE_C_FLAGS</strong>：设置 C 编译选项，也可以通过指令 add_definitions() 添加<br><strong>CMAKE_CXX_FLAGS</strong>：设置 C++ 编译选项，也可以通过指令 add_definitions() 添加</span></p> 
<pre><code>add_definitions(-DENABLE_DEBUG -DABC) # 参数之间用空格分隔</code></pre> 
<p> </p> 
<h3><a name="t19"></a>四、项目示例</h3> 
<h4><a name="t20"></a>1. 简单项目（单个源文件）</h4> 
<p>一个经典的 C 程序，如何通过 cmake 来编译呢？</p> 
<p> </p> 
<p><strong><img alt="" src="https://images2.imgbox.com/29/10/WRQEzgtF_o.png"></strong></p> 
<p><strong>依次执行以下命令：</strong></p> 
<ol><li> <p><code>cd build</code></p> </li><li> <p><code>cmake ..</code></p> </li></ol> 
<p> </p> 
<p><strong><em>为什么要新建一个 build 文件夹？</em></strong><br>         <em>一般我们采用 cmake 的 out-of-source 方式来构建（即生成的中间产物和源代码分离），这样做可以让生成的文件和源文件不会弄混，且目录结构看起来也会清晰明了。所以推荐使用这种方式，至于这个文件夹的命名并无限制，我们习惯命名为 build。</em></p> 
<p> </p> 
<p>首先进入到 build 目录，然后就是 <code>cmake ..</code> 命令，另外要注意将 cmake 配置到环境变量中去才可直接使用，否则需要使用绝对路径，<code>..</code> 表示上一级目录，cmake 会在上一级目录下找到 CMakeLists.txt 文件并编译，并生成如下图所示的一些中间文件：</p> 
<p><img alt="" src="https://images2.imgbox.com/a6/a8/FOb0EG1f_o.png"></p> 
<p>直接执行 <code>make</code> 命令，生成可执行程序，如下图：</p> 
<p><img alt="" src="https://images2.imgbox.com/cf/fe/ooyWVFmB_o.png"></p> 
<p>运行程序，如下所示：运行程序，如下所示：</p> 
<p><img alt="" src="https://images2.imgbox.com/c6/c8/BiuJZYKG_o.png"></p> 
<h4><a name="t21"></a>2. 复杂项目（多个目录，多个源文件，多个项目）</h4> 
<p><strong>目录结构如下：</strong></p> 
<p><strong><img alt="" src="https://images2.imgbox.com/f5/73/Twb7r3vo_o.png"></strong></p> 
<p><strong>demo 根目录下的 CMakeLists.txt 文件如下：</strong></p> 
<pre><code>cmake_minimum_required (VERSION 2.8)

project(demo)

aux_source_directory(. DIR_SRCS)

# 添加math子目录
add_subdirectory(math)

# 指定生成目标
add_executable(demo ${DIR_SRCS})

# 添加链接库
target_link_libraries(demo MathFunctions)</code></pre> 
<p><strong>math 目录下的 CMakeLists.txt 文件如下：</strong></p> 
<pre><code>aux_source_directory(. DIR_LIB_SRCS)

# 生成链接库
add_library(MathFunctions ${DIR_LIB_SRCS})</code></pre> 
<h4><a name="t22"></a>3. 自定义编译选项</h4> 
<p>cmake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。<br> 例如，可以将 MathFunctions 库设为一个可选的库，如果该选项为 ON ，就使用该库定义的数学函数来进行运算，否则就调用标准库中的数学函数库。<br><strong>修改根目录下的 CMakeLists.txt 文件如下：</strong></p> 
<pre><code># CMake 最低版本号要求
cmake_minimum_required (VERSION 2.8)

# 项目信息
project (Demo)

# 加入一个配置头文件，用于处理 CMake 对源码的设置
configure_file (
"${PROJECT_SOURCE_DIR}/config.h.in"
"${PROJECT_BINARY_DIR}/config.h"
)

# 是否使用自己的 MathFunctions 库
option (USE_MYMATH
"Use provided math implementation" ON)

# 是否加入 MathFunctions 库
if (USE_MYMATH)
include_directories ("${PROJECT_SOURCE_DIR}/math")
add_subdirectory (math)
set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)
endif (USE_MYMATH)

# 查找当前目录下的所有源文件,并将名称保存到 DIR_SRCS 变量
aux_source_directory(. DIR_SRCS)

# 指定生成目标
add_executable(Demo ${DIR_SRCS})

target_link_libraries (Demo ${EXTRA_LIBS})</code></pre> 
<ul><li>configure_file 命令用于加入一个配置头文件 config.h ，这个文件由 cmake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。</li><li>option 命令添加了一个 USE_MYMATH 选项，并且默认值为 ON 。根据 USE_MYMATH 变量的值来决定是否使用我们自己编写的 MathFunctions 库。</li></ul> 
<p><strong>修改 main.cc 文件，让其根据 USE_MYMATH 的预定义值来决定是否调用标准库还是MathFunctions 库：</strong></p> 
<pre><code>#include "config.h"

#ifdef USE_MYMATH

#include "math/MathFunctions.h"

#else

#include &lt;math.h&gt;

#endif


int main(int argc, char *argv[])
{

if (argc &lt; 3){

printf("Usage: %s base exponent \n", argv[0]);

return 1;

}

double base = atof(argv[1]);

int exponent = atoi(argv[2]);


#ifdef USE_MYMATH

printf("Now we use our own Math library. \n");

double result = power(base, exponent);

#else

printf("Now we use the standard library. \n");

double result = pow(base, exponent);

#endif

printf("%g ^ %d is %g\n", base, exponent, result);

return 0;

}</code></pre> 
<p><strong>编写 config.h.in 文件</strong><br> 注意 main.cc 的第一行，这里引用了一个 config.h 文件，这个文件预定义了 USE_MYMATH 的值。但我们并不直接编写这个文件，为了方便从 CMakeLists.txt 中导入配置，我们编写一个 config.h.in 文件，内容如下：</p> 
<pre><code>#cmakedefine USE_MYMATH</code></pre> 
<p>这样 cmake 会自动根据 CMakeLists.txt 配置文件中的设置自动生成 config.h 文件。</p> 
<p>​</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f75939bb20336f504a2e20092a3cb57/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Tips--解决Deepin20系统安装完毕无WiFi问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53e16ac535c99e1e8097d10c54c29d46/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CMakeList 中 find_library 用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>