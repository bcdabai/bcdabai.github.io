<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker 容器的操作 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker 容器的操作" />
<meta property="og:description" content="Docker 容器的操作 1 新建并运行容器1.1 创建容器1.2 新建并运行容器 2 查看运行的容器3 查看容器日志4 进入容器的内部4.1 attach4.2 exec 5 删除容器6 导入和导出容器 1 新建并运行容器 1.1 创建容器 docker create -it ubuntu:latest # 使用如上命令新建的容器处于停止状态，可以使用如下命令启动它 docker start [CONTAINER ID] 1.2 新建并运行容器 # docker run # 有两种：第一种：基于镜像新建一个容器并启动，第二种是处于终止状态【stop】的容器重新启动 当利用docker run来创建并启动容器时,Docker 在后台运行的标准操作包括: 1. 检查本地是否存在指定的镜像,不存在就从公有仓库下载。 2. 利用镜像创建并启动一个容器。 3. 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层。 4. 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。 5. 从地址池配置一个IP地址给容器。 6. 执行用户指定的应用程序。 7. 执行完毕后容器被终止。 ---------------------------- # 启动一个bash终端，允许用户进行交互 docker run -it ubuntu /bin/bash -t	分配一个伪终端 -i	让容器的标准输入保持打开 ---------------------------- # 运行容器需要定制具体镜像，如果镜像不存在，会直接下载 docker run -d -p 宿主机端口:容器端口 --name [CONTAINER NAMES] [IMAGE ID] | REPOSITORY[:tag] #-d	代表后台运行容器 #-p 宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口 #--name 容器名称:指定容器的名称【唯一】	如果不指定，则随机名称 # [IMAGE ID] | REPOSITORY[:tag] 镜像的标识或者镜像名称[:tag]，二选一 例如： docker run -d -p 8081:8080 --name tomcat b8dfe9ade316 2 查看运行的容器 查看全部正在运行的容器信息 docker ps [-qa] #-a 查看全部的容器，包括没有运行 #-q 只查看容器的标识 例如： docker ps -a	# 查看所有容器 docker ps -qa	# 仅仅是查看所有容器的ID # 重点： docker ps -af # 文档：https://docs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a6d046f33decd390f1eee13e09763131/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-08T17:23:48+08:00" />
<meta property="article:modified_time" content="2021-11-08T17:23:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker 容器的操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Docker 容器的操作</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1 新建并运行容器</a></li><li><ul><li><a href="#11__3" rel="nofollow">1.1 创建容器</a></li><li><a href="#12__11" rel="nofollow">1.2 新建并运行容器</a></li></ul> 
  </li><li><a href="#2__45" rel="nofollow">2 查看运行的容器</a></li><li><a href="#3__63" rel="nofollow">3 查看容器日志</a></li><li><a href="#4__77" rel="nofollow">4 进入容器的内部</a></li><li><ul><li><a href="#41_attach_79" rel="nofollow">4.1 attach</a></li><li><a href="#42_exec_95" rel="nofollow">4.2 exec</a></li></ul> 
  </li><li><a href="#5__108" rel="nofollow">5 删除容器</a></li><li><a href="#6__120" rel="nofollow">6 导入和导出容器</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1 新建并运行容器</h2> 
<h3><a id="11__3"></a>1.1 创建容器</h3> 
<pre><code>docker create -it ubuntu:latest
# 使用如上命令新建的容器处于停止状态，可以使用如下命令启动它
docker start [CONTAINER ID]
</code></pre> 
<h3><a id="12__11"></a>1.2 新建并运行容器</h3> 
<pre><code># docker run
# 有两种：第一种：基于镜像新建一个容器并启动，第二种是处于终止状态【stop】的容器重新启动

当利用docker run来创建并启动容器时,Docker 在后台运行的标准操作包括:
1. 检查本地是否存在指定的镜像,不存在就从公有仓库下载。
2. 利用镜像创建并启动一个容器。
3. 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层。
4. 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。
5. 从地址池配置一个IP地址给容器。
6. 执行用户指定的应用程序。
7. 执行完毕后容器被终止。

----------------------------
# 启动一个bash终端，允许用户进行交互
docker run -it ubuntu /bin/bash

-t	分配一个伪终端
-i	让容器的标准输入保持打开
----------------------------

# 运行容器需要定制具体镜像，如果镜像不存在，会直接下载
docker run -d -p 宿主机端口:容器端口 --name [CONTAINER NAMES] [IMAGE ID] | REPOSITORY[:tag]
#-d	代表后台运行容器
#-p 宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口
#--name 容器名称:指定容器的名称【唯一】	如果不指定，则随机名称
# [IMAGE ID] | REPOSITORY[:tag]   镜像的标识或者镜像名称[:tag]，二选一

例如：
docker run -d -p 8081:8080 --name tomcat b8dfe9ade316
</code></pre> 
<h2><a id="2__45"></a>2 查看运行的容器</h2> 
<pre><code>查看全部正在运行的容器信息
docker ps [-qa]
#-a 查看全部的容器，包括没有运行
#-q 只查看容器的标识

例如：
docker ps -a	# 查看所有容器
docker ps -qa	# 仅仅是查看所有容器的ID


# 重点： docker ps -af 
# 文档：https://docs.docker.com/engine/reference/commandline/ps/#filtering
docker ps -qa -f ancestor=nginx:1.9.5	# 过滤"nginx:1.9.5"镜像的所有容器ID
</code></pre> 
<h2><a id="3__63"></a>3 查看容器日志</h2> 
<pre><code># 查看容器日志，以查看容器运行的信息
docker logs -f 容器id
#-f：可以滚动查看日志的最后几行

例如：
docker logs -f 38e2b4b8d0cf

</code></pre> 
<h2><a id="4__77"></a>4 进入容器的内部</h2> 
<h3><a id="41_attach_79"></a>4.1 attach</h3> 
<pre><code># 多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示
# 当窗口因命令阻塞时，其他窗口也无法执行操作

docker attach [NAMES] | [CONTAINER ID]


docker attach 7ffa27b9b43c
docker attach sweet_wing

# 连接后就能显示容器中用 ENTRYPOINT/CMD 启动进程的输出内容内容,终止，容器也会停止的，需注意
# 正常退出但不关闭容器,请按 Ctrl+P+Q进行退出容器
</code></pre> 
<h3><a id="42_exec_95"></a>4.2 exec</h3> 
<pre><code>docker exec -it [CONTAINER ID] | [容器名字] /bin/bash

# 如果不是/bin/bash,那么需要查找bash在哪里了：docker exec 38e2b4b8d0cf ls -l /

例如：
docker exec -it 38e2b4b8d0cf /bin/bash
</code></pre> 
<h2><a id="5__108"></a>5 删除容器</h2> 
<pre><code>docker rm [CONTAINER ID] | NAMES

docker rm $(docker ps -qa -f ancestor=nginx:1.9.5) # 删除以"nginx:1.9.5"镜像ID的所有容器

# 删除前要停止容器【docker stop 容器id | 容器名字】
docker stop $(docker ps -qa)	# 停止所有容器
docker rm $(docker ps -qa) 	# 删除全部容器
</code></pre> 
<h2><a id="6__120"></a>6 导入和导出容器</h2> 
<pre><code># 导出容器
docker export [CONTAINER ID] | [NAMES]
# 查看容器
docker ps -a
docker export b3ed34636ee5 &gt; test_run.tar


# 导入容器，成为镜像
docker import - [REPOSITORY]:TAG
cat test_run.tar | docker import - test/ubuntu:v1.0

实际上,
既可以使用docker load 命令来导人镜像存储文件到本地的镜像库，
又可以使用docker import命令来导入一个容器快照到本地镜像库。
这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息(即仅保存容器当时的快照状态),
而镜像存储文件将保存完整记录，体积也要大。
此外,从容器快照文件导人时可以重新指定标签等元数据信息。
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f5d6b295e40830cec33d83fdf1402ce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">浏览器控制台报JS脚本执行错误：Module is not defined</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5d122fe4e8a95ac0b30014dd4b012af0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">孤尽训练营打卡日记day14--第二周总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>