<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Numpy和Pandas的使用入门 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Numpy和Pandas的使用入门" />
<meta property="og:description" content="Numpy
Numpy基本数据结构
np.array()函数接受一个多维list,返回对应纬度的矩阵
vector = np.array([1, 2, 3, 4])
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
特殊矩阵:
np.zeros((第一维size, 第二维size, ...)) 初始化全零矩阵,要求传入的是一个元组,存储各个维度上的尺寸.
np.ones((第一维size, 第二维size, ...)) 初始化全一矩阵,要求传入的是一个元组,存储各个维度上的尺寸.
np.arange(起点, 终点, 步长) 创建一个序列
np.eye(size) 创建一个size*size的单位矩阵
np.linspace(起点, 终点, 数列长度) 返回一个从起点到终点线性插值的长度为数列长度序列
np.logspace(起点指数, 终点指数, 数列长度, base=底数) 返回从 底数起点指数 到底数终点指数的长度为数列长度的等比序列
Numpy基本操作和属性
一个矩阵中存储的数据类型应该相同,其dtype属性返回矩阵中元素的数据类型
使用astype(类型)方法安全地改变元素的数据类型.
vector = numpy.array([&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;]) # [&#39;1&#39; &#39;2&#39; &#39;3&#39; &#39;4&#39;]
vector = vector.astype(float) # [1. 2. 3. 4.]
矩阵对象的shape属性返回其各维度上的尺寸." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/171995b38ed704ed46aae6f6bbd2a580/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-06T16:18:00+08:00" />
<meta property="article:modified_time" content="2019-10-06T16:18:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Numpy和Pandas的使用入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>　　Numpy</p> 
 <p>　　Numpy基本数据结构</p> 
 <p>　　np.array()函数接受一个多维list,返回对应纬度的矩阵</p> 
 <p>　　vector = np.array([1, 2, 3, 4])</p> 
 <p>　　matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</p> 
 <p>　　特殊矩阵:</p> 
 <p>　　np.zeros((第一维size, 第二维size, ...)) 初始化全零矩阵,要求传入的是一个元组,存储各个维度上的尺寸.</p> 
 <p>　　np.ones((第一维size, 第二维size, ...)) 初始化全一矩阵,要求传入的是一个元组,存储各个维度上的尺寸.</p> 
 <p>　　np.arange(起点, 终点, 步长) 创建一个序列</p> 
 <p>　　np.eye(size) 创建一个size*size的单位矩阵</p> 
 <p>　　np.linspace(起点, 终点, 数列长度) 返回一个从起点到终点线性插值的长度为数列长度序列</p> 
 <p>　　np.logspace(起点指数, 终点指数, 数列长度, base=底数) 返回从 底数起点指数 到底数终点指数的长度为数列长度的等比序列</p> 
 <p>　　Numpy基本操作和属性</p> 
 <p>　　一个矩阵中存储的数据类型应该相同,其dtype属性返回矩阵中元素的数据类型</p> 
 <p>　　使用astype(类型)方法安全地改变元素的数据类型.</p> 
 <p>　　vector = numpy.array(["1", "2", "3", "4"]) # ['1' '2' '3' '4']</p> 
 <p>　　vector = vector.astype(float) # [1. 2. 3. 4.]</p> 
 <p>　　矩阵对象的shape属性返回其各维度上的尺寸.</p> 
 <p>　　使用reshape((第一维size, 第二维size, ...)) 方法更改重整数组的形状,若传入某维度上的size为-1,则根据其他维度的尺寸反推此维度的尺寸</p> 
 <p>　　matrix = np.arange(6).reshape(-1, 3) # 得到 [[0 1 2] [3 4 5]]</p> 
 <p>　　使用ravel()方法将高维矩阵拉伸成一维向量</p> 
 <p>　　matrix = np.arange(6).reshape(-1, 3)</p> 
 <p>　　matrix = matrix.ravel() # 得到 [0 1 2 3 4 5]</p> 
 <p>　　Numpy矩阵支持下标索引与切片,与python的list类似</p> 
 <p>　　matrix = numpy.array([[5,10,15], [20,25,30], [35,40,45]])</p> 
 <p>　　matrix[:,1] # 得到[10 25 40]</p> 
 <p>　　matrix[:,0:2] # 得到[[5 10] [20 25] [35 40]]</p> 
 <p>　　matrix[1:3,:2] # 得到 [[20 25] [35 40]]</p> 
 <p>　　Numpy矩阵的reshape()和切片并不返回新矩阵,只是更改了原矩阵的一个视图(view),对新视图进行的修改也会作用在原视图上</p> 
 <p>　　Numpy矩阵支持比较运算符, 返回一个与原矩阵尺寸相同的bool矩阵,存储对对应为进行判断的结果</p> 
 <p>　　print(matrix == 10) # 得到 [[False True False] [False False False] [False False False]]</p> 
 <p>　　print(matrix &gt; 10) # 得到 [[False False True] [ True True True] [ True True True]]</p> 
 <p>　　与MATLAB类似,可以用矩阵比较运算的结果来索引矩阵</p> 
 <p>　　matrix[matrix&gt;10]=10 # 得到 [[ 5 10 10] [10 10 10] [10 10 10]]</p> 
 <p>　　使用min(axis=维度), max(axis=维度), sum(axis=维度) 分别返回数组在某维度上的最小值,最大值和求和</p> 
 <p>　　matrix = np.arange(9).reshape((3, 3))</p> 
 <p>　　matrix.min(axis=1) # array([0, 3, 6])</p> 
 <p>　　matrix.max(axis=1) # array([2, 5, 8])</p> 
 <p>　　matrix.sum(axis=1) # array([3, 12, 21])</p> 
 <p>　　排序</p> 
 <p>　　numpy.sort(矩阵, axis=维度)返回对矩阵对应维度进行排序后的矩阵,注意返回的是一个新矩阵,而原矩阵不改变</p> 
 <p>　　numpy.argsort(矩阵, axis=维度)返回排序后矩阵每个位置的元素在原矩阵中的对应索引.</p> 
 <p>　　Numpy矩阵运算</p> 
 <p>　　加减法:</p> 
 <p>　　相同维度矩阵加减,对应位置元素相加减</p> 
 <p>　　a1 = np.array([20,30,40,50]) # 得到 [20 30 40 50]</p> 
 <p>　　a2 = np.arange(4) # 得到 [0 1 2 3]</p> 
 <p>　　a3 = a1 - a2 # 得到 [20 29 38 47]</p> 
 <p>　　矩阵加减某个标量,则对每个元素都加减这个标量</p> 
 <p>　　a1 = np.array([20,30,40,50]) # 得到 [20 30 40 50]</p> 
 <p>　　a2 = a1-1 # 得到 [19 29 39 49]</p> 
 <p>　　矩阵乘法:</p> 
 <p>　　相同维度矩阵使用*运算符,返回尺寸相同的新矩阵,其存储的是对应位置元素相乘结果</p> 
 <p>　　使用矩阵1.dot(矩阵1)或np.dot(矩阵1,矩阵2)计算矩阵点乘</p> 
 <p>　　A = np.array([[1,1],[0,1]])</p> 
 <p>　　B = np.array([[2,0],[3,4]])</p> 
 <p>　　# 矩阵对应位置相乘</p> 
 <p>　　print(A*B) # 得到 [[2 0] [0 4]]</p> 
 <p>　　# 矩阵点乘两种写法</p> 
 <p>　　print(A.dot(B)) # 得到 [[5 4] [3 4]]</p> 
 <p>　　print(np.dot(A,B)) # 得到 [[5 4] [3 4]]</p> 
 <p>　　乘方操作: 对矩阵每个元素进行乘方操作</p> 
 <p>　　A = np.range(5)</p> 
 <p>　　A = A ** 2 # 得到 [0 1 4 9 25]</p> 
 <p>　　矩阵拼接:</p> 
 <p>　　使用tile(矩阵,(第一维倍数, 第二维倍数, ...))方法将矩阵对应尺寸上延展对应倍数</p> 
 <p>　　matrix = np.arange(2)</p> 
 <p>　　matrix = np.tile(matrix,(1,3)) # 得到 [[0 1 0 1 0 1]]</p> 
 <p>　　matrix = np.tile(matrix,(3,1)) # 得到 [[0 1] [0 1] [0 1]]</p> 
 <p>　　矩阵的转置,行列式,求逆</p> 
 <p>　　使用.T属性求矩阵的转置</p> 
 <p>　　使用np.linalg.inv(矩阵)求矩阵的逆</p> 
 <p>　　使用np.linalg.det(矩阵)求矩阵的行列式</p> 
 <p>　　matrix = np.arange(1,5).reshape(2,2)</p> 
 <p>　　# 求矩阵转置</p> 
 <p>　　print(matrix.T) # 得到 [[1 3] [2 4]]</p> 
 <p>　　# 求矩阵的逆</p> 
 <p>　　print(np.linalg.inv(matrix)) # 得到 [[-2. 1. ] [ 1.5 -0.5]]</p> 
 <p>　　# 求矩阵的行列式</p> 
 <p>　　print(np.linalg.det(matrix)) # 得到 -2.0000000000000004</p> 
 <p>　　Pandas</p> 
 <p>　　pandas数据读取</p> 
 <p>　　使用pandas的read_csv()方法读取csv数据,读取到的数据将会被包装成一个DataFrame对象.</p> 
 <p>　　food_info = pd.read_csv("food_info.csv")</p> 
 <p>　　type(food_info) # pandas.core.frame.DataFrame</p> 
 <p>　　food_info.dtypes # DataFrame中包含的每个对象都被看成Numpy对象</p> 
 <p>　　food_info.columns.tolist() # 得到所有列名</p> 
 <p>　　food_info.values.tolist() # 以np.array形式返回其内容</p> 
 <p>　　pandas数据展示</p> 
 <p>　　调用DataFrame对象的head(行数)方法显示前行数行,tail(行数)方法显示前head行.</p> 
 <p>　　food_info.head() # 显示前5行</p> 
 <p>　　food_info.head(3) # 显示前3行</p> 
 <p>　　food_info.tail() # 显示后5行</p> 
 <p>　　调用DataFrame对象的shape()方法返回其矩阵形状</p> 
 <p>　　food_info.shape # (8618, 36)</p> 
 <p>　　调用DataFrame对象的loc[行数]属性取第行数行,行数可以是一个int数或一个列表</p> 
 <p>　　若行数为一个int数字,则返回一个Series对象</p> 
 <p>　　若行数为一个列表,则返回一个DataFrame对象</p> 
 <p>　　type(food_info.loc[[0]]) # pandas.core.frame.DataFrame</p> 
 <p>　　type(food_info.loc[0]) # pandas.core.series.Series</p> 
 <p>　　food_info.loc[3:5]</p> 
 <p>　　food_info.loc[[2,5,10]]</p> 
 <p>　　对DataFrame对象使用下标索引可以返回某几列</p> 
 <p>　　若传入一个索引值,则返回一个Series对象</p> 
 <p>　　若传入一个索引列表,则返回一个DataFrame对象</p> 
 <p>　　ndb_col = food_info["NDB_No"]</p> 
 <p>　　zinc_copper_col = food_info[["Zinc_(mg)", "Copper_(mg)"]]</p> 
 <p>　　type(ndb_col) # pandas.core.series.Series</p> 
 <p>　　type(zinc_copper_col) # pandas.core.frame.DataFrame</p> 
 <p>　　Pandas数据处理</p> 
 <p>　　对DataFrame对象进行加减乘除,等价于对其每一个元素进行加减乘除</p> 
 <p>　　div_100 = food_info["Iron_(mg)"] / 100</p> 
 <p>　　add_100 = food_info["Iron_(mg)"] + 100</p> 
 <p>　　sub_100 = food_info["Iron_(mg)"] - 100</p> 
 <p>　　mult_100 = food_info["Iron_(mg)"] * 100</p> 
 <p>　　例子: 计算加权指标</p> 
 <p>　　# Score = 2*(protein_(g))-0.75*(Lipid_Tot_(g))</p> 
 <p>　　weighted_protein = food_info["Protein_(g)"] * 2</p> 
 <p>　　weighted_fat = -0.75 * food_info["Lipid_Tot_(g)"]</p> 
 <p>　　initial_rating = weighted_protein + weighted_fat</p> 
 <p>　　取最值,平均值: max(),min(),mean(),Pandas会自动剔除不存在的坏值</p> 
 <p>　　# 使用max()取最大值</p> 
 <p>　　max_calories = food_info["Energ_Kcal"].max()</p> 
 <p>　　mean_calories = food_info["Energ_Kcal"].mean()</p> 
 <p>　　例子: 归一化数据并将其作为新行</p> 
 <p>　　normalized_protein = food_info["Protein_(g)"] / food_info["Protein_(g)"].max()</p> 
 <p>　　normalized_fat = food_info["Lipid_Tot_(g)"] / food_info["Lipid_Tot_(g)"].max()</p> 
 <p>　　food_info["Normalized_Protein"] = normalized_protein</p> 
 <p>　　food_info["Normalized_Fat"] = normalized_fat</p> 
 <p>　　排序</p> 
 <p>　　sort_value()方法将所有行按值排序</p> 
 <p>　　sort_index()方法将所有行按索引排序</p> 
 <p>　　# 第一个参数: 排序的键</p> 
 <p>　　# inplace: 是否直接替换原对象</p> 
 <p>　　# ascending: 升序与否</p> 
 <p>　　food_info.sort_values("Sodium_(mg)", inplace=True)</p> 
 <p>　　food_info.sort_values("Sodium_(mg)", inplace=True, ascending=False)</p> 
 <p>　　数据透视表</p> 
 <p>　　titanic_surival = pd.read_csv("titanic_train.csv")</p> 
 <p>　　使用pivot_table()函数生成数据透视表,其参数如下</p> 
 <p>　　index:指定以哪个指标为基准进行统计</p> 
 <p>　　values:统计的字段,可以为索引,也可以为索引列表</p> 
 <p>　　aggfunc:对统计字段的值应用的方法,默认取平均值,即np.mean()</p> 
 <p>　　# 统计不同船舱的获救概率</p> 
 <p>　　passenger_survival = titanic_surival.pivot_table(index="Pclass", values="Survived", aggfunc=np.mean)</p> 
 <p>　　# 统计不同船舱的年龄</p> 
 <p>　　passenger_age = titanic_surival.pivot_table(index="Pclass", values="Survived")</p> 
 <p>　　# 统计每个港口的 总票价 和 总获救人数</p> 
 <p>　　port_stats = titanic_surival.pivot_table(index="Embarked", values=["Fare", "Survived"], aggfunc=np.sum)</p> 
 <p>　　删除空值<span style="color:#ffffff;">无锡妇科哪家医院好 http://www.87554006.com/</span></p> 
 <p>　　使用dropna()来删除带有空值的行或列,其参数列表如下</p> 
 <p>　　axis:维度,取0删除有空值的列,取1删除有空值的行</p> 
 <p>　　subset:删除掉subset字段有空值的行</p> 
 <p>　　# 删除掉所有有空值的列, axis=1</p> 
 <p>　　drop_na_columns = titanic_surival.dropna(axis=1)</p> 
 <p>　　# 删除掉所有["Age"或"Sex"字段]有空值的行</p> 
 <p>　　new_titanic_survival = titanic_surival.dropna(axis=0, subset=["Age", "Sex"])</p> 
 <p>　　重新建立索引</p> 
 <p>　　使用reset_index方法来重新建立索引</p> 
 <p>　　new_titanic_survival = titanic_surival.sort_values("Age", ascending=False)</p> 
 <p>　　# 将数据集按照当前顺序重新建立索引,drop代表放弃原来索引</p> 
 <p>　　titanic_reindexed = new_titanic_survival.reset_index(drop=True)</p> 
 <p>　　DataFrame对象的apply(函数)方法可以对数据每一列都执行自定义函数,并将结果汇总到一个Series对象中.</p> 
 <p>　　# 返回每一列的第100名</p> 
 <p>　　def hundredth_row(column):</p> 
 <p>　　# Extract the hundredth item</p> 
 <p>　　hundredth_item = column.loc[99]</p> 
 <p>　　return hundredth_item</p> 
 <p>　　# 对每个字段返回其第100位,下一行等价于 titanic_surival.loc[99]</p> 
 <p>　　hundredth_row = titanic_surival.apply(hundredth_row)</p> 
 <p>　　# 统计每一列的空值个数</p> 
 <p>　　def not_null_count(column):</p> 
 <p>　　column_null = pd.isnull(column)</p> 
 <p>　　null = column[column_null]</p> 
 <p>　　return len(null)</p> 
 <p>　　# 对每个字段返回其空值个数</p> 
 <p>　　column_null_count = titanic_surival.apply(not_null_count)</p> 
 <p>　　# 对每一行的Pclass字段编码</p> 
 <p>　　def which_class(row):</p> 
 <p>　　pclass = row["Pclass"]</p> 
 <p>　　if pd.isnull(pclass):</p> 
 <p>　　return "Unknown"</p> 
 <p>　　elif pclass == 1:</p> 
 <p>　　return "First Class"</p> 
 <p>　　elif pclass == 2:</p> 
 <p>　　return "Second Class"</p> 
 <p>　　elif pclass == 3:</p> 
 <p>　　return "Third Class"</p> 
 <p>　　# 返回每一行的Pclass字段的编码</p> 
 <p>　　classes = titanic_surival.apply(which_class, axis=1)</p> 
 <p>　　Pandas的基本数据结构:DataFrame和Series</p> 
 <p>　　DataFrame和Series为Pandas最重要的两种结构,其中Series类似于一维向量,而DataFrame类似于二维矩阵.</p> 
 <p>　　Series可以看作是Numpy对象的集合,DataFrame可以看作是Series的集合</p> 
 <p>　　fandango = pd.read_csv('fandango_score_comparison.csv')</p> 
 <p>　　# 对DataFrame进行索引取值得到Series</p> 
 <p>　　series_film = fandango['FILM']</p> 
 <p>　　type(series_film) # pandas.core.series.Series</p> 
 <p>　　可以使用Series()构造函数生成Series对象,index参数指定索引</p> 
 <p>　　from pandas import Series</p> 
 <p>　　film_names = fandango['FILM'].values # 得到所有电影名字</p> 
 <p>　　rt_scores = series_rt.values # 得到所有评分值</p> 
 <p>　　# 以电影名字为索引,将电影评分构成一个Series</p> 
 <p>　　series_custom = Series(rt_scores, index=film_names)</p> 
 <p>　　# 这样可以以电影名为索引找到电影</p> 
 <p>　　series_custom[['Minions (2015)', 'Leviathan (2014)']]</p> 
 <p>　　series的底层实现用的是np.ndarray,因此series对象可以替代ndarray作为函数参数</p> 
 <p>　　np.add(series_custom, series_custom)</p> 
 <p>　　np.sin(series_custom)</p> 
 <p>　　np.max(series_custom)</p> 
</div> 
<p>转载于:https://www.cnblogs.com/djw12333/p/11627591.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f8ad6fd26cc5512fdf4fc550eaf2579/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">互联网公司去年到今年的大批裁员，这是怎么了？程序员该何去何从</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c33cbbc04d86f8850b462ecb096e1a5d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">bootstrap&#43;spring boot实现面包屑导航</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>