<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>全面理解守护进程的基础概念，以及如何创建一个守护进程（系列文章第三篇） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="全面理解守护进程的基础概念，以及如何创建一个守护进程（系列文章第三篇）" />
<meta property="og:description" content="前言 这个系列的文章有四篇，其目的是为了搞清楚：
进程，shell，shell进程，终端，控制终端，前台进程，后台进程，控制进程，前台进程组，后台进程组，会话，守护进程，init进程，用户进程，系统进程 它们之间的联系与区别系列文章第一篇传送门：全面理解shell进程、终端、控制终端的概念，以及它们之间有什么区别与联系？（系列文章第一篇）系列文章第二篇传送门：全面理解进程组，会话的基础概念，以及进程组，会话，控制终端，前台进程组与后台进程组之间的联系（系列文章第二篇）系列文章第四篇传送门：全面理解前台进程，后台进程的概念，以及之间如何切换，init进程与系列文章大总结（系列文章第四篇） 什么是守护进程 守护进程（daemon）是在 Unix 和类 Unix（如 Linux）操作系统中运行的一种特殊的后台进程，它们独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。
守护进程通常在系统引导装载时启动，并且在系统关闭之前一直运行。
守护进程的名称通常以 &#34;d&#34; 结尾，以便于区分。例如，sshd 是 Secure Shell 守护进程，httpd 是 HTTP 守护进程。
这些进程在后台运行，提供各种服务，例如处理网络请求（如 web 服务器）、处理系统日志、处理电子邮件和其他各种任务。
守护进程通常不直接与用户交互，但它们工作起来非常重要，为其他程序和用户提供关键服务。
守护进程在创建时通常会进行“孤儿化”操作，使其成为 init 进程（进程ID为1）的子进程。这样，它们就可以在后台运行，不受任何特定用户或会话的影响。此外，守护进程通常会更改其工作目录到根目录 (“/”)，关闭所有已打开的文件描述符（包括输入、输出和错误输出），并重新打开标准输入、标准输出和标准错误到/dev/null，这样就可以防止它们不小心读取或写入任何用户文件或终端。
总的来说，守护进程是一种在后台运行，为系统或其他程序提供服务的进程。
如何创建一个守护进程 创建守护进程需要一定的步骤，这些步骤确保了守护进程能够在后台独立运行，并且不受任何特定用户或会话的影响。
下面我来解释一下每个步骤的含义：
执行一个 fork()，之后父进程退出，子进程继续执行。
这是创建守护进程的第一步，目的是让守护进程在后台运行。在fork()之后，父进程退出，子进程成为孤儿进程，并被 init 进程（进程ID为1）接管。 子进程调用 setsid() 开启一个新会话。
setsid()函数会创建一个新的会话，并且让子进程成为这个新会话的首进程。这样子进程就与其原来的会话、进程组和控制终端脱离，成为一个新的会话的首进程，可以独立运行。 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。
umask是一个权限掩码，它决定了新建文件或目录的默认权限。清除umask是为了让守护进程能够有更大的权限控制它创建的文件或目录。 修改进程的当前工作目录，通常会改为根目录（/）。
这是为了防止守护进程阻止文件系统被卸载。如果守护进程的工作目录在一个挂载的文件系统中，那么这个文件系统就不能被卸载。 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。
这是为了避免守护进程继续使用这些文件描述符，可能会导致不可预料的问题。 在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2() 使所有这些描述符指向这个设备。
这是为了让守护进程的标准输入、输出和错误输出被重定向到/dev/null，避免它们产生任何输出，因为守护进程通常不需要和用户交互。 核心业务逻辑 在完成了以上所有的步骤后，守护进程开始执行其核心的业务逻辑，为系统或其他程序提供服务。
示例：创建一个守护进程 下面是一个简单的守护进程的例子，这个程序会每2秒获取一次系统时间，并写入一个叫做time.txt的文件中
#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/593ef6b4c821274822be7a9294a33fd2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-16T22:27:41+08:00" />
<meta property="article:modified_time" content="2023-05-16T22:27:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">全面理解守护进程的基础概念，以及如何创建一个守护进程（系列文章第三篇）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<blockquote> 
 <p><strong>这个系列的文章有四篇，其目的是为了搞清楚</strong>：</p> 
</blockquote> 
<ul><li><code>进程，shell，shell进程，终端，控制终端，前台进程，后台进程，控制进程，前台进程组，后台进程组，会话，守护进程，init进程，用户进程，系统进程</code> <strong>它们之间的联系与区别</strong></li><li>系列文章第一篇传送门：<a href="https://blog.csdn.net/weixin_49503250/article/details/130631203?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22130631203%22,%22source%22:%22weixin_49503250%22%7D">全面理解shell进程、终端、控制终端的概念，以及它们之间有什么区别与联系？（系列文章第一篇）</a></li><li>系列文章第二篇传送门：<a href="https://blog.csdn.net/weixin_49503250/article/details/130661834?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22130661834%22,%22source%22:%22weixin_49503250%22%7D">全面理解进程组，会话的基础概念，以及进程组，会话，控制终端，前台进程组与后台进程组之间的联系（系列文章第二篇）</a></li><li>系列文章第四篇传送门：<a href="https://blog.csdn.net/weixin_49503250/article/details/130713914?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22130713914%22,%22source%22:%22weixin_49503250%22%7D">全面理解前台进程，后台进程的概念，以及之间如何切换，init进程与系列文章大总结（系列文章第四篇）</a></li></ul> 
<h2><a id="_6"></a>什么是守护进程</h2> 
<blockquote> 
 <p>守护进程（daemon）是在 Unix 和类 Unix（如 Linux）操作系统中运行的一种特殊的后台进程，它们独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</p> 
</blockquote> 
<ul><li> <p>守护进程通常在系统引导装载时启动，并且在系统关闭之前一直运行。</p> </li><li> <p><code>守护进程的名称通常以 "d" 结尾，以便于区分</code>。例如，sshd 是 Secure Shell 守护进程，httpd 是 HTTP 守护进程。</p> </li><li> <p><code>这些进程在后台运行，提供各种服务</code>，例如处理网络请求（如 web 服务器）、处理系统日志、处理电子邮件和其他各种任务。</p> </li><li> <p>守护进程通常不直接与用户交互，但它们工作起来非常重要，为其他程序和用户提供关键服务。</p> </li><li> <p>守护进程在创建时通常会进行“孤儿化”操作，使其成为 init 进程（进程ID为1）的子进程。这样，它们就可以在后台运行，不受任何特定用户或会话的影响。此外，守护进程通常会更改其工作目录到根目录 (“/”)，关闭所有已打开的文件描述符（包括输入、输出和错误输出），并重新打开标准输入、标准输出和标准错误到/dev/null，这样就可以防止它们不小心读取或写入任何用户文件或终端。</p> </li></ul> 
<p>总的来说，守护进程是一种在后台运行，为系统或其他程序提供服务的进程。</p> 
<h3><a id="_20"></a>如何创建一个守护进程</h3> 
<blockquote> 
 <p>创建守护进程需要一定的步骤，这些步骤确保了守护进程能够在后台独立运行，并且不受任何特定用户或会话的影响。</p> 
</blockquote> 
<p><strong>下面我来解释一下每个步骤的含义：</strong></p> 
<ol><li> <p>执行一个 fork()，之后父进程退出，子进程继续执行。</p> 
  <ul><li>这是创建守护进程的第一步，目的是让守护进程在后台运行。在fork()之后，父进程退出，子进程成为孤儿进程，并被 init 进程（进程ID为1）接管。</li></ul> </li><li> <p>子进程调用 setsid() 开启一个新会话。</p> 
  <ul><li>setsid()函数会创建一个新的会话，并且让子进程成为这个新会话的首进程。这样子进程就与其原来的会话、进程组和控制终端脱离，成为一个新的会话的首进程，可以独立运行。</li></ul> </li><li> <p>清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。</p> 
  <ul><li>umask是一个权限掩码，它决定了新建文件或目录的默认权限。清除umask是为了让守护进程能够有更大的权限控制它创建的文件或目录。</li></ul> </li><li> <p>修改进程的当前工作目录，通常会改为根目录（/）。</p> 
  <ul><li>这是为了防止守护进程阻止文件系统被卸载。如果守护进程的工作目录在一个挂载的文件系统中，那么这个文件系统就不能被卸载。</li></ul> </li><li> <p>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。</p> 
  <ul><li>这是为了避免守护进程继续使用这些文件描述符，可能会导致不可预料的问题。</li></ul> </li><li> <p>在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2() 使所有这些描述符指向这个设备。</p> 
  <ul><li>这是为了让守护进程的标准输入、输出和错误输出被重定向到/dev/null，避免它们产生任何输出，因为守护进程通常不需要和用户交互。</li></ul> </li></ol> 
<p><strong>核心业务逻辑 在完成了以上所有的步骤后，守护进程开始执行其核心的业务逻辑，为系统或其他程序提供服务。</strong></p> 
<h3><a id="_45"></a>示例：创建一个守护进程</h3> 
<blockquote> 
 <p><strong>下面是一个简单的守护进程的例子，这个程序会每2秒获取一次系统时间，并写入一个叫做time.txt的文件中</strong></p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">daemonize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 执行一个 fork()，之后父进程退出，子进程继续执行。</span>
    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 子进程调用 setsid() 开启一个新会话。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setsid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"setsid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。</span>
    <span class="token function">umask</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 修改进程的当前工作目录，通常会改为根目录（/）。</span>
    <span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">"/home/nowcoder/Linux/lession28"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。</span>
    <span class="token function">close</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>STDERR_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2() 使所有这些描述符指向这个设备。</span>
<span class="token punctuation">}</span>

<span class="token comment">// 代码主体逻辑部分</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">daemonize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FILE <span class="token operator">*</span>file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"/home/nowcoder/Linux/lession28/time.txt"</span><span class="token punctuation">,</span> <span class="token string">"a+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fopen"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        time_t tt <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">tm</span> t <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">localtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tt<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">fprintf</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">"现在是北京时间: %d-%d-%d %d:%d:%d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>tm_year <span class="token operator">+</span> <span class="token number">1900</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>tm_mon <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>tm_mday<span class="token punctuation">,</span> t<span class="token punctuation">.</span>tm_hour<span class="token punctuation">,</span> t<span class="token punctuation">.</span>tm_min<span class="token punctuation">,</span> t<span class="token punctuation">.</span>tm_sec<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fflush</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证数据立即写入文件</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>编译和运行这个程序之后，你可以使用ps -ef | grep a.out（假设你的程序名是a.out）来查看守护进程。你会看到它没有控制终端，而且会话ID是1，这都是守护进程的特征。</li><li>你可以用 <code>kill - 9 守护进程的进程号</code> 去杀死一个守护进程</li></ul> 
<p><strong>注意，这是一个基础的守护进程，一个真实的守护进程可能需要处理更多的细节，对于实际环境中的守护进程，需要处理的问题可能包括但不限于：</strong></p> 
<ul><li> <p>日志记录：当守护进程运行时，可能需要记录或报告它的行为。通常，它将这些信息写入日志文件或系统日志。</p> </li><li> <p>配置文件：守护进程通常有一些可配置的设置，这些设置通常存储在配置文件中。当守护进程启动时，它会读取这个配置文件。</p> </li><li> <p>信号处理：守护进程需要响应系统发送给它的信号。例如，当系统关闭时，它可能会收到一个SIGTERM信号，通知它应当进行清理并优雅地终止。</p> </li><li> <p>错误处理：守护进程需要处理可能在运行时发生的各种错误，例如文件读取失败、网络连接中断等。</p> </li><li> <p>权限管理：守护进程可能需要以特定的用户身份运行，以限制其对系统资源的访问。</p> </li><li> <p>资源管理：如果守护进程创建了子进程，那么它可能需要跟踪这些进程，确保它们被正确地关闭和清理。</p> </li></ul> 
<p>以上就是在设计守护进程时，可能需要考虑的一些问题。这些问题的处理方式会因应用的具体需求而异。</p> 
<h3><a id="_135"></a>如何终止一个守护进程</h3> 
<blockquote> 
 <p>终止守护进程：</p> 
</blockquote> 
<ul><li> <p>使用kill命令：如果你知道守护进程的进程ID（可以通过ps，top，htop或者pgrep命令查找），你可以使用kill命令来发送一个信号终止它，例如kill 12345，其中12345是进程ID。</p> </li><li> <p>使用pkill或者killall命令：如果你知道守护进程的名字，你可以使用pkill或者killall命令来终止所有名字匹配的进程，例如pkill mydaemon或者killall mydaemon，其中mydaemon是进程名。</p> </li></ul> 
<h3><a id="_142"></a>系统定义的守护进程与用户自定义的守护进程的区别</h3> 
<ul><li> <p>系统定义的守护进程通常是在系统启动时自动启动的，用于执行一些系统任务，如网络服务、日志记录等。这些守护进程的生命周期通常与系统运行时间相同。</p> </li><li> <p>用户自定义的守护进程是由用户创建并启动的，通常用于执行特定的任务，如监控某个服务、定期执行一些任务等。这些守护进程的生命周期可能会比系统定义的守护进程短，因为它们可能在任务完成后就终止。</p> </li></ul> 
<p><code>注意，系统定义的守护进程通常是由系统管理员或者root用户启动的，所以只有管理员或者root用户才能终止它们。而用户自定义的守护进程则可以由创建它们的用户来终止</code>。</p> 
<h3><a id="_152"></a>总结</h3> 
<ul><li> <p>守护进程（Daemon）是一类在 Unix 和 Unix-like 操作系统中运行的后台进程。这些进程通常在系统启动时开始，然后在系统关闭时结束。守护进程通常不与用户直接交互，它们为其他程序和用户提供服务，例如网络服务、系统日志服务、打印服务等。</p> </li><li> <p>守护进程的名称通常以 “d” 结尾，这表示它是一个守护进程。例如，httpd 是一个处理 HTTP 请求的守护进程，sshd 是一个提供安全 shell 服务的守护进程。</p> </li></ul> 
<p>总的来说，守护进程就是在后台运行，为系统或用户提供各种服务的进程。与普通的进程一样，只要知道进程号，就可以用kill信号去杀死它。</p> 
<p><code>最后的最后，如果你觉得我的这篇文章写的不错的话，请给我一个赞与收藏，关注我，我会继续给大家带来更多更优质的干货内容</code>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ff9d04ad90505faafc88f89e197d45bc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python基础(四)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8a765aa47f0b040e3d5be0ecce74b2c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL 教程-入门基础篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>