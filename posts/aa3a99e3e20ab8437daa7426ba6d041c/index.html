<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DW PCIE 的Register Module, LBC, and DBI章节学习笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="DW PCIE 的Register Module, LBC, and DBI章节学习笔记" />
<meta property="og:description" content="SPIN互斥锁很好的链接
文章起源 PCIE的使用SPIN解决IP的LBC没有使用专用总线导致中断冲突问题的软件避归方案(特殊芯片使用）。后续再编写C语言的驱动程序时对IP的Register Module, LBC, and DBI章节进行一学习并记录学习理解和心得。
寄存器说明 Capability ID汇总
Capabilities结构说明
在初次看寄存器文档的时候比较容易迷糊。CAP 寄存器即对应功能的Capability（能力）说明，对应的地址都是B&#43;0x** 容易让人迷糊。每个Resiters的描述内部都有个Capability指向下一个，每个CAP都有自己特定的ID号，对应固定的长度所以程序可以通过一个个的偏移量找到下个CAP从而完成全部的查找。
CAP的地址说明 PCI-X 和PCIe 总线规范要求其设备必须支持Capabilities 结构。在PCI 总线的基本配置空间中，包含一个Capabilities Pointer 寄存器，该寄存器存放Capabilities 结构链表的头指针。在一个PCIe 设备中，可能含有多个Capability 结构，这些寄存器组成一个链表，如下图所示。
其中每一个Capability 结构都有唯一的ID 号，每一个Capability 寄存器都有一个指针，这个指针指向下一个Capability 结构，从而组成一个单向链表结构，这个链表的最后一个Capability 结构的指针为0。链表开始的指针地址为0x34处的1byte数值，寻址过程如下。注意对应的偏移地址是绝对地址，不是从本身CAP计算的偏移地址。
相关说明链接
比如下面的读取 0X34-&gt;0X40(bit8-16)-&gt;0X50(bit8-16)-&gt;0X70(bit8-16)-&gt;0XD0(bit8-16) 在0XD0 对应下一个CAP地址为0，在这结束了CAP.
[0000] abcd16c3 00100107 06040001 00010000 [0010] 00000000 00000000 00ff0100 20000000 [0020] 00000000 00010001 00000000 00000000 [0030] 00000000 00000040 00000000 000001ff [0040] 5bc35001 00000008 00000000 00000000 [0050] 038a7005 00000000 00000000 00000000 [0060] 00000000 00000000 00000000 00000000 [0070] 0042d010 00008021 00002110 00534842 [0080] 30420000 0006007f 004003c0 00000000 [0090] 00000000 80000410 00000000 80000006 [00a0] 40000002 00000000 00000000 00000000 [00b0] 00000000 00000000 00000000 00000000 [00c0] 00000000 00000000 00000000 00000000 [00d0] 00000003 00000000 00000000 00000000 [00e0] 00000000 00000000 00000000 00000000 [00f0] 00000000 00000000 00000000 00000000 我使用的芯片当切换到访问RC本身寄存器的时候对应地址列表：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/aa3a99e3e20ab8437daa7426ba6d041c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-23T14:38:46+08:00" />
<meta property="article:modified_time" content="2022-09-23T14:38:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DW PCIE 的Register Module, LBC, and DBI章节学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="http://www.wowotech.net/kernel_synchronization/spinlock.html" rel="nofollow">SPIN互斥锁很好的链接</a></p> 
<h2><a id="_1"></a>文章起源</h2> 
<p>PCIE的使用SPIN解决IP的LBC没有使用专用总线导致中断冲突问题的软件避归方案(特殊芯片使用）。后续再编写C语言的驱动程序时对IP的Register Module, LBC, and DBI章节进行一学习并记录学习理解和心得。</p> 
<h2><a id="_3"></a>寄存器说明</h2> 
<p><a href="https://blog.csdn.net/qingfengjuechen/article/details/113104827">Capability ID汇总</a><br> <a href="https://www.cnblogs.com/zhongzhe/p/3900111.html" rel="nofollow">Capabilities结构说明</a><br> 在初次看寄存器文档的时候比较容易迷糊。CAP 寄存器即对应功能的Capability（能力）说明，对应的地址都是B+0x** 容易让人迷糊。每个Resiters的描述内部都有个Capability指向下一个，每个CAP都有自己特定的ID号，对应固定的长度所以程序可以通过一个个的偏移量找到下个CAP从而完成全部的查找。<br> <img src="https://images2.imgbox.com/e3/6b/uxSkF0aE_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="CAP_10"></a>CAP的地址说明</h3> 
<p>PCI-X 和PCIe 总线规范要求其设备必须支持Capabilities 结构。在PCI 总线的基本配置空间中，包含一个Capabilities Pointer 寄存器，该寄存器存放Capabilities 结构链表的头指针。在一个PCIe 设备中，可能含有多个Capability 结构，这些寄存器组成一个链表，如下图所示。</p> 
<p>其中每一个Capability 结构都有唯一的ID 号，每一个Capability 寄存器都有一个指针，这个指针指向下一个Capability 结构，从而组成一个单向链表结构，这个链表的最后一个Capability 结构的指针为0。链表开始的指针地址为0x34处的1byte数值，寻址过程如下。注意对应的偏移地址是绝对地址，不是从本身CAP计算的偏移地址。</p> 
<p><a href="https://blog.csdn.net/pwl999/article/details/78207965">相关说明链接</a></p> 
<p><img src="https://images2.imgbox.com/6f/72/4MeevCje_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d1/3c/DiZK80Ic_o.png" alt="在这里插入图片描述"><br> 比如下面的读取 0X34-&gt;0X40(bit8-16)-&gt;0X50(bit8-16)-&gt;0X70(bit8-16)-&gt;0XD0(bit8-16) 在0XD0 对应下一个CAP地址为0，在这结束了CAP.</p> 
<pre><code class="prism language-bash"> <span class="token punctuation">[</span>0000<span class="token punctuation">]</span> abcd16c3 00100107 06040001 00010000
 <span class="token punctuation">[</span>0010<span class="token punctuation">]</span> 00000000 00000000 00ff0100 <span class="token number">20000000</span>
 <span class="token punctuation">[</span>0020<span class="token punctuation">]</span> 00000000 00010001 00000000 00000000
 <span class="token punctuation">[</span>0030<span class="token punctuation">]</span> 00000000 00000040 00000000 000001ff
 <span class="token punctuation">[</span>0040<span class="token punctuation">]</span> 5bc35001 00000008 00000000 00000000
 <span class="token punctuation">[</span>0050<span class="token punctuation">]</span> 038a7005 00000000 00000000 00000000
 <span class="token punctuation">[</span>0060<span class="token punctuation">]</span> 00000000 00000000 00000000 00000000
 <span class="token punctuation">[</span>0070<span class="token punctuation">]</span> 0042d010 00008021 00002110 00534842
 <span class="token punctuation">[</span>0080<span class="token punctuation">]</span> <span class="token number">30420000</span> 0006007f 004003c0 00000000
 <span class="token punctuation">[</span>0090<span class="token punctuation">]</span> 00000000 <span class="token number">80000410</span> 00000000 <span class="token number">80000006</span>
 <span class="token punctuation">[</span>00a0<span class="token punctuation">]</span> <span class="token number">40000002</span> 00000000 00000000 00000000
 <span class="token punctuation">[</span>00b0<span class="token punctuation">]</span> 00000000 00000000 00000000 00000000
 <span class="token punctuation">[</span>00c0<span class="token punctuation">]</span> 00000000 00000000 00000000 00000000
 <span class="token punctuation">[</span>00d0<span class="token punctuation">]</span> 00000003 00000000 00000000 00000000
 <span class="token punctuation">[</span>00e0<span class="token punctuation">]</span> 00000000 00000000 00000000 00000000
 <span class="token punctuation">[</span>00f0<span class="token punctuation">]</span> 00000000 00000000 00000000 00000000
</code></pre> 
<p>我使用的芯片当切换到访问RC本身寄存器的时候对应地址列表：<br> F9000034 :00000040 所属内容 PF0_TYPE1_HDR :NEXT=0X40<br> F9000040 :5bc35001 所属内容 PF0_PM_CAP ID=0X01 NEXT=0X50<br> F9000050 :038a7005 所属内容 PCI_MSI_CAP_ID_NEXT_CTRL ID=0X05 NEXT=0X70<br> F9000070 :0042d010 所属内容 PF0_PCIE_CAP ID=0X10 NEXT=0Xd0<br> F90000d0 :00000003 所属内容 /PF0_MSI_CAP ID=0X3 NEXT=0X0 (最后一个CAP)</p> 
<h2><a id="_48"></a>几个定义</h2> 
<p>DSP：RC Mode 对应的模式<br> USP：EP Mode 对应的模式</p> 
<p>CDM:Configuration Dependent Module.This is an internal block in the native controller that has the PCIe configuration registers and some user-accessible registers.包括 PICE叫做的配置寄存器（比如PCIE 从机显示的标准设置头信息）和 厂家定义的寄存器（比如ATU和DMA等）。</p> 
<p>ELBI:External Local Bus Interface.Delivers an inbound register RD/WR received by the controller to external application registers when the controller is expected to generate the PCIe completion of this register<br> RD/WR. For switch applications: the ELBI is intended for incoming requests that are targeted to local switch application registers, while TRGT1 is intended for TLPs that are passing through the switch. The controller automatically generates completions for requests that are routed to the ELBI。ELBI和CDM 注册了本地寄存器，在下面章节寄存器配置空间概览有描述。ELBI我理解为通过PCIE访问一个CPU的内部空间寄存器。ELBI 主要是在EP端，使用RC没有该部分功能。</p> 
<p>LBC:Local Bus Controller .This is an internal block that allows the DBI interface (from your application side), or the wire side interface (through the TRGT0 interface), to access the CDM or your external application registers on the ELBI.本地的寄存器控制，比如RC中断清除等相关都需要操作。</p> 
<p>XALI:Transmit Client Interface.理解为给外部传输的接口</p> 
<p>DBI:Data Bus Interface.You can use this interface to locally access the controller’s internal registers in the CDM, or your external application registers on the ELBI. You can optionally connect a local CPU or controller to this port.</p> 
<p>CQ 和CC ：PCIe 完成器请求 (CQ)/完成器完成 (CC) 模块用于从远程 PCIe 代理接收 TLP 请求并加以处理。</p> 
<h3><a id="DBI__65"></a>DBI 内部划分</h3> 
<p>DBI内部划分了2个部分，DBI和DBI2通过片选来进行选择。<br> When you are using an AXI DBI slave, shadow registers can only be accessed through the DBI where you select between the two registers using the CS2 address bit.This is called DBI2, CS2, dbi_cs2, DBI_CS2, or Dbi2 access; all of these terms mean the same thing.</p> 
<p>DBI2和DBI内容具体区别看本文“寄存器配置空间概览”部分章节</p> 
<h4><a id="_70"></a>我使用芯片的空间排布</h4> 
<p>我使用的芯片DBI和DBI2的地址关系是pci-&gt;dbi_base2 = pci-&gt;dbi_base + 0x100000。<br> DBI: 0<br> DBI2: 0x100000<br> iATU: 0x300000<br> DMA: 0x380000<br> <img src="https://images2.imgbox.com/d3/00/4LGUHbXj_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_79"></a>问题原因</h2> 
<p>设计使用IP时没有使用独立Native的一条CPU直接访问LBC访问寄存器的总线通道DBI(见Local Bus Controller (LBC)章节和Data Bus Interface (DBI) Access章节)。在设置EP端和RC自身LBC访问通道只能用同一个通道AXI 的SLAVE通道。<br> AXI DBI 访问使用的是 Shared Slave Interface 模式，即共享总线访问方式。CPU作RC主模式时对内部的LBC控制寄存器的访问和对外部EP设备的寄存器访问使用的是同一套总线，并没有使用专用的DBI总线。如下图1 访问XALI外部和访问内部LBC是通过SWITCH 来控制切换的。在没有中断的情况下该不会有访问冲突，但是在使用SMI中断的情况下由于中断和EP设备驱动可能不运行在多核的同一个CPU上会导致中断中切换到LBC路径访问时，EP设备驱动如果同时在访问XALI实际设备驱动访问的时LBC，导致EP设备驱动读取数据异常。<br> 所以使用时需要对RC模式下的驱动进行修改，保证中断访问PCI寄存器和应用访问EP互斥,防止同时使用到AXI SLAVE。</p> 
<p>CPU能直接DBI访问<br> AXI DBI Access with a Dedicated Slave Interface SHARED_DBI_ENABLED =0, DBI_4SLAVE_POPULATED =1)<br> <img src="https://images2.imgbox.com/f3/bf/ZXsQgYrd_o.png" alt="在这里插入图片描述"></p> 
<p>我们芯片的处理方式<br> AXI DBI Access with a Shared Slave Interface (SHARED_DBI_ENABLED =1, DBI_4SLAVE_POPULATED =0)<br> <img src="https://images2.imgbox.com/eb/cd/tjUOm26l_o.png" alt="SWITCH 切换访问自身的寄存器或是EP的寄存器"></p> 
<p>我们芯片的设置切换代码如下，是通过设置PCIE的SIDEBAND的2个寄存器来影响切换，保证从AXI接口访问访问到LBC</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pcie_sideband_dbi_disable</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">oa1801_pcie</span> <span class="token operator">*</span>oa1801_pcie<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	u32 val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	val <span class="token operator">=</span> <span class="token function">oa1801_sideband_readl</span><span class="token punctuation">(</span>oa1801_pcie<span class="token punctuation">,</span> SIDEBAND_SLV_AWMISC_INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>
	val <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span>AXI_DBI_W_EN<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">oa1801_sideband_writel</span><span class="token punctuation">(</span>oa1801_pcie<span class="token punctuation">,</span> val<span class="token punctuation">,</span> SIDEBAND_SLV_AWMISC_INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>

	val <span class="token operator">=</span> <span class="token function">oa1801_sideband_readl</span><span class="token punctuation">(</span>oa1801_pcie<span class="token punctuation">,</span> SIDEBAND_AXI_DBI_R_EN_INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>
	val <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span>AXI_DBI_R_EN<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">oa1801_sideband_writel</span><span class="token punctuation">(</span>oa1801_pcie<span class="token punctuation">,</span> val<span class="token punctuation">,</span> SIDEBAND_AXI_DBI_R_EN_INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pcie_sideband_dbi_enable</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">oa1801_pcie</span> <span class="token operator">*</span>oa1801_pcie<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	u32 val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	val <span class="token operator">=</span> <span class="token function">oa1801_sideband_readl</span><span class="token punctuation">(</span>oa1801_pcie<span class="token punctuation">,</span> SIDEBAND_SLV_AWMISC_INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>
	val <span class="token operator">|=</span> AXI_DBI_W_EN<span class="token punctuation">;</span>
	<span class="token function">oa1801_sideband_writel</span><span class="token punctuation">(</span>oa1801_pcie<span class="token punctuation">,</span> val<span class="token punctuation">,</span> SIDEBAND_SLV_AWMISC_INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>

	val <span class="token operator">=</span> <span class="token function">oa1801_sideband_readl</span><span class="token punctuation">(</span>oa1801_pcie<span class="token punctuation">,</span> SIDEBAND_AXI_DBI_R_EN_INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>
	val <span class="token operator">|=</span> AXI_DBI_R_EN<span class="token punctuation">;</span>
	<span class="token function">oa1801_sideband_writel</span><span class="token punctuation">(</span>oa1801_pcie<span class="token punctuation">,</span> val<span class="token punctuation">,</span> SIDEBAND_AXI_DBI_R_EN_INFO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h2><a id="_122"></a>寄存器配置空间概览</h2> 
<p>The controller has 4096 bytes of register space per function. Based on the location of the registers, this space is divided into two groups, CDM and ELBI. PICE控制器的4096字节空间用于作为寄存器控制，这个空间又分为两部分一部分为CMD空间一部分为ELBI空间。<br> CDM:前面名词解释有说明，包括了一些PCI 配置头部信息，PCIE设备本身标准或者是扩展的功能和端口的逻辑寄存器。对于PCI使用来说我的理解就是我们使用命令PCI -vvvv 能看到的东西。</p> 
<p>ELBI:<br> 通过外部接口（PCIE）访问寄存器是通过ELBI 进行的。</p> 
<p>对于PCIE 的EP和RC 他们的排布是有一定差异的。右边的CS2=0和CS2=0有不同的访问区域，如果是设置CDM/ELBI 为1 的情况，访问的是特殊的寄存器Shadow（比较特殊的寄存器，算是IP厂家特殊的）；</p> 
<p>Shadow Registers：PCI头部的一些设置是在Shadow寄存器中设置，比如BAR的MASK,前面介绍是在DBI2地址范围。</p> 
<p>EP 的排布：<br> 1.右边是DBI2访问的空间内容。<br> 2.左边是DBI访问空间内容。<br> <img src="https://images2.imgbox.com/4b/88/ujR8oFiD_o.png" alt="在这里插入图片描述"></p> 
<p>RC对应空间排布:</p> 
<p><img src="https://images2.imgbox.com/f2/b3/6Xm3t3tc_o.png" alt="在这里插入图片描述"><br> UPS即EP模式下恩不CFG访问和外部MEM和IO访问对应的空间关系。<br> <img src="https://images2.imgbox.com/6a/19/XT6rdHsi_o.png" alt="在这里插入图片描述"></p> 
<p>对应上面图左边UPS即EP模式下 DBI访问空间地址说明</p> 
<p><img src="https://images2.imgbox.com/22/6a/uOeDRkld_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_151"></a>需要注意的地方</h3> 
<h4><a id="VIEWPORT_152"></a>VIEWPORT功能说明</h4> 
<p><strong>实际发现ATU可以使用直接访问的方式也可以使用VIEWPORT 的方式，直接访问方式地址为0x300000起始地址，使用VIEWPORT在LINUX驱动中被定义为0X900开始。</strong><br> VIEWPORT 方式说明：<br> 置地址在CS2=0的情况下。直接访问比如AUT 第N个iATU Region Control 1 Register.为：0x700+0x200*(N+1)。间接访问就首先配置 700+200地址的 (iATU_VIEWPORT_OFF)寄存器，设置访问第N个iATU。然后iATU Region Control 1 Register.为：0x700+0x200+0x4</p> 
<p>置地址在CS2=0的情况下。直接访问比如AUT 第N个iATU Region Control 1 Register.为：0x700+0x200*(N+1)。间接访问就首先配置 700+200地址的 (iATU_VIEWPORT_OFF)寄存器，设置访问第N个iATU。然后iATU Region Control 1 Register.为：0x700+0x200+0x4。<br> 程序设置(iATU_VIEWPORT_OFF)寄存器如下： <br> dw_pcie_writel_dbi(pci, PCIE_ATU_VIEWPORT, PCIE_ATU_REGION_INBOUND | index);</p> 
<h4><a id="CPU_AXIDBI__AXI_Bridge_DBI_Access_164"></a>CPU AXI桥访问DBI AXI Bridge DBI Access</h4> 
<p><img src="https://images2.imgbox.com/3e/56/DAscSNV1_o.png" alt="在这里插入图片描述"><br> 在LINUX 驱动下可以看到DMA 和ATU 后缀加unroll参数的部分程序。在头文件也有介绍</p> 
<pre><code class="prism language-c"><span class="token comment">/*
 * iATU Unroll-specific register definitions
 * From 4.80 core version the address translation will be made by unroll
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PCIE_ATU_UNR_REGION_CTRL1</span>	<span class="token expression"><span class="token number">0x00</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PCIE_ATU_UNR_REGION_CTRL2</span>	<span class="token expression"><span class="token number">0x04</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PCIE_ATU_UNR_LOWER_BASE</span>		<span class="token expression"><span class="token number">0x08</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PCIE_ATU_UNR_UPPER_BASE</span>		<span class="token expression"><span class="token number">0x0C</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PCIE_ATU_UNR_LIMIT</span>		<span class="token expression"><span class="token number">0x10</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PCIE_ATU_UNR_LOWER_TARGET</span>	<span class="token expression"><span class="token number">0x14</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PCIE_ATU_UNR_UPPER_TARGET</span>	<span class="token expression"><span class="token number">0x18</span></span></span>
</code></pre> 
<p>地址访问设置方式如下：</p> 
<pre><code class="prism language-c"><span class="token comment">/* Register address builder */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PCIE_GET_ATU_OUTB_UNR_REG_OFFSET</span><span class="token expression"><span class="token punctuation">(</span>region<span class="token punctuation">)</span>	</span><span class="token punctuation">\</span>
			<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0x3</span> <span class="token operator">&lt;&lt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>region<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PCIE_GET_ATU_INB_UNR_REG_OFFSET</span><span class="token expression"><span class="token punctuation">(</span>region<span class="token punctuation">)</span>				</span><span class="token punctuation">\</span>
			<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0x3</span> <span class="token operator">&lt;&lt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>region<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0x1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">static</span> u32 <span class="token function">dw_pcie_readl_ob_unroll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dw_pcie</span> <span class="token operator">*</span>pci<span class="token punctuation">,</span> u32 index<span class="token punctuation">,</span> u32 reg<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	u32 offset <span class="token operator">=</span> <span class="token function">PCIE_GET_ATU_OUTB_UNR_REG_OFFSET</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">dw_pcie_readl_dbi</span><span class="token punctuation">(</span>pci<span class="token punctuation">,</span> offset <span class="token operator">+</span> reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dw_pcie_writel_ob_unroll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dw_pcie</span> <span class="token operator">*</span>pci<span class="token punctuation">,</span> u32 index<span class="token punctuation">,</span> u32 reg<span class="token punctuation">,</span>
				     u32 val<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	u32 offset <span class="token operator">=</span> <span class="token function">PCIE_GET_ATU_OUTB_UNR_REG_OFFSET</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">dw_pcie_writel_dbi</span><span class="token punctuation">(</span>pci<span class="token punctuation">,</span> offset <span class="token operator">+</span> reg<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我使用的CPU就是通过unroll模式对ATU 、DMA 进行访问。对应地址设置如图</p> 
<p><img src="https://images2.imgbox.com/af/8f/y8sY3eXv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ae/be/Sr23tx0L_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="ELBI_213"></a>ELBI和外部总线</h2> 
<p>关于访问的数据流实线是访问CDM,虚线为访问ELBI。<br> PCIe Wire Access to CDM Registers or ELBI：<br> <img src="https://images2.imgbox.com/1b/13/D5nutg3P_o.png" alt="在这里插入图片描述"><br> DBI Access to CDM Registers or ELBI：<br> 其中实线是DBI 接口访问CMD.<br> <img src="https://images2.imgbox.com/12/87/HwnRpyDq_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="BAR__221"></a>BAR 的详解</h2> 
<h3><a id="EP_BAR_222"></a>EP 模式下的BAR</h3> 
<p>常规的BAR介绍我简单说一下，不清楚的看文档和上网了解。</p> 
<ol><li>32BIT 64BIT 访问</li><li>设置BAR地址和BAR大小（通过BAR MASK）</li><li>通过写BAR的MASK为0禁止BAR</li><li>可设置IO、MEM、预取等特性</li><li>通过BAR可以访问TRGT1 (AXI master interface)， TRGT0 ( access internal port logic registers or external application registers on the ELBI)</li></ol> 
<h4><a id="BAR_MASK_232"></a>BAR MASK的配置注意事项</h4> 
<p>Memory BAR Sizes：开启了MEM BAR 对应的[11:0]设置为1,因为2.0PCIE要求是4KB最小值。<br> IO BAR Sizes：开启IO BAR 为256个最小值。<br> BAR Mask Registers访问方式：EP是通过DBI接口对寄存器访问，该地址和BAR地址寄存器一样。不过通过DBI总线访是通过CS2切换访问的shadow访问得到的是MASK寄存器。</p> 
<h3><a id="RC_BAR_238"></a>RC 模式下的BAR</h3> 
<p>RC存在两个 BAR，但预计不会使用。 您应该禁用它们以避免在设备枚举期间进行不必要的内存分配。 如果您确实使用 BAR，那么您应该对其进行编程以捕获针对本地非应用程序内存空间的 TLP定义在 TRGT1 （AXI master interface）, 不适用于 TRGT1 上的应用程序（Because in a DSP, there is no wire access to TRGT0 (ELBI or CDM) using CFG requests or BAR-matched MEM requests.）. <strong>BAR 范围必须在三个范围之外基础/限制区域（Base/Limit regions）</strong>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab3408c7d20e255b7230edf2b80f8fb8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言——入门级学生管理系统（只对基本信息操作）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/935c0e1e51781c77ef10e7d38b754c52/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">帧率与曝光的时间对于手机屏幕采集图像的影响</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>