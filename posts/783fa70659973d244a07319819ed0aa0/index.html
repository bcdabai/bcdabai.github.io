<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>机器学习：交叉验证，网络搜索 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="机器学习：交叉验证，网络搜索" />
<meta property="og:description" content="学习目标 目标 知道交叉验证、网格搜索的概念会使用交叉验证、网格搜索优化训练模型 1 什么是交叉验证(cross validation) 交叉验证：将拿到的训练数据，分为训练和验证集。以下图为例：将数据分成4份，其中一份作为验证集。然后经过4次(组)的测试，每次都更换不同的验证集。即得到4组模型的结果，取平均值作为最终结果。又称4折交叉验证。
1.1 分析 我们之前知道数据分为训练集和测试集，但是为了让从训练得到模型结果更加准确。做以下处理
训练集：训练集&#43;验证集测试集：测试集 1.2 为什么需要交叉验证 交叉验证目的：为了让被评估的模型更加准确可信
问题：这个只是让被评估的模型更加准确可信，那么怎么选择或者调优参数呢？
2 什么是网格搜索(Grid Search) 通常情况下，有很多参数是需要手动指定的（如k-近邻算法中的K值），这种叫超参数。但是手动过程繁杂，所以需要对模型预设几种超参数组合。每组超参数都采用交叉验证来进行评估。最后选出最优参数组合建立模型。
3 交叉验证，网格搜索（模型选择与调优）API： sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None) 对估计器的指定参数值进行详尽搜索estimator：估计器对象param_grid：估计器参数(dict){“n_neighbors”:[1,3,5]}cv：指定几折交叉验证fit：输入训练数据score：准确率结果分析： bestscore__:在交叉验证中验证的最好结果bestestimator：最好的参数模型cvresults:每次交叉验证后的验证集准确率结果和训练集准确率结果 4 鸢尾花案例增加K值调优 使用GridSearchCV构建估计器 # 1、获取数据集 iris = load_iris() # 2、数据基本处理 -- 划分数据集 x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=22) # 3、特征工程：标准化 # 实例化一个转换器类 transfer = StandardScaler() # 调用fit_transform x_train = transfer.fit_transform(x_train) x_test = transfer.transform(x_test) # 4、KNN预估器流程 # 4.1 实例化预估器类 estimator = KNeighborsClassifier() # 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/783fa70659973d244a07319819ed0aa0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-17T17:08:48+08:00" />
<meta property="article:modified_time" content="2022-06-17T17:08:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">机器学习：交叉验证，网络搜索</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="学习目标">学习目标</h3> 
<ul><li>目标 
  <ul><li>知道交叉验证、网格搜索的概念</li><li>会使用交叉验证、网格搜索优化训练模型</li></ul></li></ul> 
<h3 id="1-什么是交叉验证cross-validation">1 什么是交叉验证(cross validation)</h3> 
<p>交叉验证：将拿到的训练数据，分为训练和验证集。以下图为例：将数据分成4份，其中一份作为验证集。然后经过4次(组)的测试，每次都更换不同的验证集。即得到4组模型的结果，取平均值作为最终结果。又称4折交叉验证。</p> 
<h4 id="11-分析">1.1 分析</h4> 
<p>我们之前知道数据分为训练集和测试集，但是<strong>为了让从训练得到模型结果更加准确。</strong>做以下处理</p> 
<ul><li>训练集：训练集+验证集</li><li>测试集：测试集</li></ul> 
<p><img alt="" height="342" src="https://images2.imgbox.com/b7/9f/XlF98Zm0_o.png" width="623"></p> 
<p> </p> 
<h4 id="12-为什么需要交叉验证">1.2 为什么需要交叉验证</h4> 
<p>交叉验证目的：<strong>为了让被评估的模型更加准确可信</strong></p> 
<p><strong>问题：这个只是让被评估的模型更加准确可信，那么怎么选择或者调优参数呢？</strong></p> 
<h3 id="2-什么是网格搜索grid-search">2 什么是网格搜索(Grid Search)</h3> 
<p>通常情况下，<strong>有很多参数是需要手动指定的（如k-近邻算法中的K值），这种叫超参数</strong>。但是手动过程繁杂，所以需要对模型预设几种超参数组合。<strong>每组超参数都采用交叉验证来进行评估。最后选出最优参数组合建立模型。</strong></p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/42/33/JlqQPFi6_o.png" width="594"></p> 
<p> </p> 
<h3 id="3-交叉验证，网格搜索（模型选择与调优）api：">3 交叉验证，网格搜索（模型选择与调优）API：</h3> 
<ul><li>sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None) 
  <ul><li>对估计器的指定参数值进行详尽搜索</li><li>estimator：估计器对象</li><li>param_grid：估计器参数(dict){“n_neighbors”:[1,3,5]}</li><li>cv：指定几折交叉验证</li><li><li>fit：输入训练数据</li><li>score：准确率</li><li>结果分析： 
    <ul><li>best<em>score__:在交叉验证中验证的最好结果</em></li><li>best<em>estimator</em>：最好的参数模型</li><li>cv<em>results</em>:每次交叉验证后的验证集准确率结果和训练集准确率结果</li></ul></li></ul></li></ul> 
<h3 id="4-鸢尾花案例增加k值调优">4 鸢尾花案例增加K值调优</h3> 
<ul><li>使用GridSearchCV构建估计器</li></ul> 
<pre><code># 1、获取数据集
iris = load_iris()
# 2、数据基本处理 -- 划分数据集
x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=22)
# 3、特征工程：标准化
# 实例化一个转换器类
transfer = StandardScaler()
# 调用fit_transform
x_train = transfer.fit_transform(x_train)
x_test = transfer.transform(x_test)
# 4、KNN预估器流程
#  4.1 实例化预估器类
estimator = KNeighborsClassifier()

# 4.2 模型选择与调优——网格搜索和交叉验证
# 准备要调的超参数
param_dict = {"n_neighbors": [1, 3, 5]}
estimator = GridSearchCV(estimator, param_grid=param_dict, cv=3)
# 4.3 fit数据进行训练
estimator.fit(x_train, y_train)
# 5、评估模型效果
# 方法a：比对预测结果和真实值
y_predict = estimator.predict(x_test)
print("比对预测结果和真实值：\n", y_predict == y_test)
# 方法b：直接计算准确率
score = estimator.score(x_test, y_test)
print("直接计算准确率：\n", score)
</code></pre> 
<ul><li>然后进行评估查看最终选择的结果和交叉验证的结果</li></ul> 
<pre><code>print("在交叉验证中验证的最好结果：\n", estimator.best_score_)
print("最好的参数模型：\n", estimator.best_estimator_)
print("每次交叉验证后的准确率结果：\n", estimator.cv_results_)
</code></pre> 
<ul><li>最终结果</li></ul> 
<pre><code>比对预测结果和真实值：
 [ True  True  True  True  True  True  True False  True  True  True  True
  True  True  True  True  True  True False  True  True  True  True  True
  True  True  True  True  True  True  True  True  True  True  True  True
  True  True]
直接计算准确率：
 0.947368421053
在交叉验证中验证的最好结果：
 0.973214285714
最好的参数模型：
 KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
           metric_params=None, n_jobs=1, n_neighbors=5, p=2,
           weights='uniform')
每次交叉验证后的准确率结果：
 {'mean_fit_time': array([ 0.00114751,  0.00027037,  0.00024462]), 'std_fit_time': array([  1.13901511e-03,   1.25300249e-05,   1.11011951e-05]), 'mean_score_time': array([ 0.00085751,  0.00048693,  0.00045625]), 'std_score_time': array([  3.52785082e-04,   2.87650037e-05,   5.29673344e-06]), 'param_n_neighbors': masked_array(data = [1 3 5],
             mask = [False False False],
       fill_value = ?)
, 'params': [{'n_neighbors': 1}, {'n_neighbors': 3}, {'n_neighbors': 5}], 'split0_test_score': array([ 0.97368421,  0.97368421,  0.97368421]), 'split1_test_score': array([ 0.97297297,  0.97297297,  0.97297297]), 'split2_test_score': array([ 0.94594595,  0.89189189,  0.97297297]), 'mean_test_score': array([ 0.96428571,  0.94642857,  0.97321429]), 'std_test_score': array([ 0.01288472,  0.03830641,  0.00033675]), 'rank_test_score': array([2, 3, 1], dtype=int32), 'split0_train_score': array([ 1.        ,  0.95945946,  0.97297297]), 'split1_train_score': array([ 1.        ,  0.96      ,  0.97333333]), 'split2_train_score': array([ 1.  ,  0.96,  0.96]), 'mean_train_score': array([ 1.        ,  0.95981982,  0.96876877]), 'std_train_score': array([ 0.        ,  0.00025481,  0.0062022 ])}
</code></pre> 
<h3 id="5-总结">5 总结</h3> 
<ul><li>交叉验证【知道】 
  <ul><li>定义： 
    <ul><li>将拿到的训练数据，分为训练和验证集</li><li>*折交叉验证</li></ul></li><li>分割方式： 
    <ul><li>训练集：训练集+验证集</li><li>测试集：测试集</li></ul></li><li>为什么需要交叉验证 
    <ul><li>为了让被评估的模型更加准确可信</li><li>注意：交叉验证不能提高模型的准确率</li></ul></li></ul></li><li>网格搜索【知道】 
  <ul><li>超参数: 
    <ul><li>sklearn中,需要手动指定的参数,叫做超参数</li></ul></li><li>网格搜索就是把这些超参数的值,通过字典的形式传递进去,然后进行选择最优值</li></ul></li><li>api【知道】 
  <ul><li>sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None) 
    <ul><li>estimator -- 选择了哪个训练模型</li><li>param_grid -- 需要传递的超参数</li><li>cv -- 几折交叉验证</li></ul></li></ul></li></ul> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb5b77734e51cf42710b29ee024d1aa4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Dart 、Flutter环境安装配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a57ad91864f3f7dc689e457229888b7a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Django DRF 视图基类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>