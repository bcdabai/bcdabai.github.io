<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【ASP.NET Core 基础知识】--依赖注入（DI）--什么是依赖注入 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【ASP.NET Core 基础知识】--依赖注入（DI）--什么是依赖注入" />
<meta property="og:description" content="依赖注入（Dependency Injection，简称DI）是一种设计模式，用于解耦和管理类之间的依赖关系。它的核心思想是将原本需要在代码中显式创建的依赖关系，交给外部容器进行控制和管理。
具体来说，依赖注入的实现方式是通过将依赖对象的创建和维护责任转移到外部容器中，使得类不需要自己实例化，而是通过外部容器进行注入。这样，类之间的依赖关系就被解耦了，代码的可维护性和可测试性也得到了提高。
依赖注入的优点包括：降低类之间的耦合度，提高代码的可读性和可维护性，方便进行单元测试，以及支持运行时的动态配置。
依赖注入是一种重要的软件设计模式，可以帮助我们更好地组织和管理代码，提高程序的可扩展性和可维护性。
一、依赖注入的原理 依赖注入（Dependency Injection，简称DI）的原理是将依赖关系从代码中抽离出来，交给外部容器进行管理，并通过容器向对象提供所需的其他对象。具体来说，依赖注入的实现原理是通过以下步骤实现的：
声明依赖： 在代码中声明需要哪些依赖对象。这通常是通过注解、XML配置文件或编程方式来完成的。**创建对象： **容器负责创建对象和依赖关系。当需要创建一个对象时，容器会检查该对象是否已经创建，如果没有创建，则创建该对象并注入所需的依赖。提供依赖： 容器将所需的依赖注入到需要依赖的对象中。这通常是通过调用对象的方法或将依赖对象设置为对象的属性来完成的。使用依赖： 对象可以使用注入的依赖对象。在对象的方法中，可以使用注入的依赖对象来完成所需的操作。 通过依赖注入，对象不需要知道依赖对象的具体实现，只需要知道依赖对象的接口即可。这样，对象之间的依赖关系就被解耦了，代码的可维护性和可测试性也得到了提高。
依赖注入的原理是将依赖关系的创建和管理从代码中抽离出来，交给外部容器进行控制和管理，从而实现对象之间的解耦和依赖关系的管理。
二、依赖注入的优点 依赖注入（Dependency Injection，简称DI）的优点主要包括以下几个方面：
降低耦合度： 依赖注入可以将类之间的依赖关系解耦，使得类之间的依赖关系更加灵活，便于维护和扩展。提高可测试性： 依赖注入使得类之间的依赖关系更加清晰，可以方便地进行单元测试，提高了代码的可测试性。增加代码复用性： 通过依赖注入，可以使得不同的类使用同一接口，从而实现代码的复用和灵活性。简化代码： 使用依赖注入可以减少代码中的冗余，使代码更加简洁、清晰。支持运行时动态配置： 依赖注入可以在运行时动态地改变依赖关系，使得应用程序更加灵活和可配置。提高了程序的可扩展性： 依赖注入的使用可以使程序更加容易扩展，因为每个组件都是可替换的，而且无需改动代码。 依赖注入的优点包括降低耦合度、提高可测试性、增加代码复用性、简化代码、支持运行时动态配置和提高程序的可扩展性等方面。使用依赖注入可以使程序更加灵活、可维护和可扩展。
三、依赖注入的实现方式 在C#中，依赖注入可以通过多种方式实现，以下是其中几种常见的实现方式：
构造函数注入（Constructor Injection）
构造函数注入是将依赖对象作为构造函数的参数传递给需要依赖的对象。这种方式可以确保依赖对象在对象创建时就被正确地初始化。例如： public class CustomerService { private readonly IEmailService _emailService; public CustomerService(IEmailService emailService) { _emailService = emailService; } // ... } 属性注入（Property Injection）
属性注入是将依赖对象通过属性的方式注入到需要依赖的对象中。这种方式可以在对象创建后动态地注入依赖对象。例如： public class CustomerService { private IEmailService _emailService; [Dependency] public void Configure(IEmailService emailService) { _emailService = emailService; } // ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/29c8f1fe34b4907e7fc74d5ed446492c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T22:56:05+08:00" />
<meta property="article:modified_time" content="2024-01-22T22:56:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【ASP.NET Core 基础知识】--依赖注入（DI）--什么是依赖注入</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>依赖注入（Dependency Injection，简称DI）是一种设计模式，用于解耦和管理类之间的依赖关系。它的核心思想是将原本需要在代码中显式创建的依赖关系，交给外部容器进行控制和管理。<br> 具体来说，依赖注入的实现方式是通过将依赖对象的创建和维护责任转移到外部容器中，使得类不需要自己实例化，而是通过外部容器进行注入。这样，类之间的依赖关系就被解耦了，代码的可维护性和可测试性也得到了提高。<br> 依赖注入的优点包括：降低类之间的耦合度，提高代码的可读性和可维护性，方便进行单元测试，以及支持运行时的动态配置。<br> 依赖注入是一种重要的软件设计模式，可以帮助我们更好地组织和管理代码，提高程序的可扩展性和可维护性。</p> 
<h4><a id="_4"></a>一、依赖注入的原理</h4> 
<p>依赖注入（Dependency Injection，简称DI）的原理是将依赖关系从代码中抽离出来，交给外部容器进行管理，并通过容器向对象提供所需的其他对象。具体来说，依赖注入的实现原理是通过以下步骤实现的：</p> 
<ol><li><strong>声明依赖：</strong> 在代码中声明需要哪些依赖对象。这通常是通过注解、XML配置文件或编程方式来完成的。</li><li>**创建对象： **容器负责创建对象和依赖关系。当需要创建一个对象时，容器会检查该对象是否已经创建，如果没有创建，则创建该对象并注入所需的依赖。</li><li><strong>提供依赖：</strong> 容器将所需的依赖注入到需要依赖的对象中。这通常是通过调用对象的方法或将依赖对象设置为对象的属性来完成的。</li><li><strong>使用依赖：</strong> 对象可以使用注入的依赖对象。在对象的方法中，可以使用注入的依赖对象来完成所需的操作。</li></ol> 
<p>通过依赖注入，对象不需要知道依赖对象的具体实现，只需要知道依赖对象的接口即可。这样，对象之间的依赖关系就被解耦了，代码的可维护性和可测试性也得到了提高。</p> 
<p>依赖注入的原理是将依赖关系的创建和管理从代码中抽离出来，交给外部容器进行控制和管理，从而实现对象之间的解耦和依赖关系的管理。</p> 
<h4><a id="_14"></a>二、依赖注入的优点</h4> 
<p>依赖注入（Dependency Injection，简称DI）的优点主要包括以下几个方面：</p> 
<ol><li><strong>降低耦合度：</strong> 依赖注入可以将类之间的依赖关系解耦，使得类之间的依赖关系更加灵活，便于维护和扩展。</li><li><strong>提高可测试性：</strong> 依赖注入使得类之间的依赖关系更加清晰，可以方便地进行单元测试，提高了代码的可测试性。</li><li><strong>增加代码复用性：</strong> 通过依赖注入，可以使得不同的类使用同一接口，从而实现代码的复用和灵活性。</li><li><strong>简化代码：</strong> 使用依赖注入可以减少代码中的冗余，使代码更加简洁、清晰。</li><li><strong>支持运行时动态配置：</strong> 依赖注入可以在运行时动态地改变依赖关系，使得应用程序更加灵活和可配置。</li><li><strong>提高了程序的可扩展性：</strong> 依赖注入的使用可以使程序更加容易扩展，因为每个组件都是可替换的，而且无需改动代码。</li></ol> 
<p>依赖注入的优点包括降低耦合度、提高可测试性、增加代码复用性、简化代码、支持运行时动态配置和提高程序的可扩展性等方面。使用依赖注入可以使程序更加灵活、可维护和可扩展。</p> 
<h4><a id="_24"></a>三、依赖注入的实现方式</h4> 
<p>在C#中，依赖注入可以通过多种方式实现，以下是其中几种常见的实现方式：</p> 
<ol><li><strong>构造函数注入（Constructor Injection）</strong><br> 构造函数注入是将依赖对象作为构造函数的参数传递给需要依赖的对象。这种方式可以确保依赖对象在对象创建时就被正确地初始化。例如：</li></ol> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomerService</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IEmailService</span> _emailService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">CustomerService</span><span class="token punctuation">(</span><span class="token class-name">IEmailService</span> emailService<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _emailService <span class="token operator">=</span> emailService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li><strong>属性注入（Property Injection）</strong><br> 属性注入是将依赖对象通过属性的方式注入到需要依赖的对象中。这种方式可以在对象创建后动态地注入依赖对象。例如：</li></ol> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomerService</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">IEmailService</span> _emailService<span class="token punctuation">;</span>

    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Dependency</span></span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Configure</span><span class="token punctuation">(</span><span class="token class-name">IEmailService</span> emailService<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _emailService <span class="token operator">=</span> emailService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li><strong>方法注入（Method Injection）</strong><br> 方法注入是将依赖对象通过方法的方式注入到需要依赖的对象中。这种方式可以在对象创建后动态地注入依赖对象。例如：</li></ol> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomerService</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">IEmailService</span> _emailService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Configure</span><span class="token punctuation">(</span><span class="token class-name">IEmailService</span> emailService<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _emailService <span class="token operator">=</span> emailService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="4"><li><strong>装饰器模式（Decorator Pattern）</strong><br> 装饰器模式是一种结构型设计模式，它可以通过动态地将对象包装在装饰器中来实现对象的功能扩展。在依赖注入中，可以使用装饰器模式来实现依赖对象的动态替换和扩展。例如：</li></ol> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IEmailService</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SendEmail</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> to<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> subject<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsoleEmailService</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IEmailService</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SendEmail</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> to<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> subject<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> body<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"To: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">to</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"Subject: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">subject</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"Body: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">body</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmtpEmailService</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IEmailService</span></span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IEmailService</span> _innerService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">SmtpEmailService</span><span class="token punctuation">(</span><span class="token class-name">IEmailService</span> innerService<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _innerService <span class="token operator">=</span> innerService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SendEmail</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> to<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> subject<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> body<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Send email using SMTP</span>
        _innerService<span class="token punctuation">.</span><span class="token function">SendEmail</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> subject<span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomerService</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IEmailService</span> _emailService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">CustomerService</span><span class="token punctuation">(</span><span class="token class-name">IEmailService</span> emailService<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _emailService <span class="token operator">=</span> emailService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SendEmail</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> to<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> subject<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> body<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        _emailService<span class="token punctuation">.</span><span class="token function">SendEmail</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> subject<span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上述示例中，<code>CustomerService</code> 类通过构造函数注入了一个 <code>IEmailService</code> 对象。在实际应用中，可以使用不同的 <code>IEmailService</code> 实现来替换和扩展邮件发送功能。例如，可以使用 <code>ConsoleEmailService</code> 来实现简单的控制台输出，或者使用 <code>SmtpEmailService</code> 来实现通过 SMTP 协议发送邮件的功能。</p> 
<h4><a id="_124"></a>四、依赖注入和控制反转的关系</h4> 
<p>依赖注入（Dependency Injection，简称DI）和控制反转（Inversion of Control，简称IoC）是相互关联的概念。<br> 控制反转是指通过反转对象之间的依赖关系，使得对象的创建和分配由容器来完成，而不是由对象自己来完成。这样，对象之间的依赖关系就解耦了，代码的可维护性和可扩展性也得到了提高。而依赖注入是控制反转的一种实现方式，它通过将依赖关系从代码中抽离出来，交给外部容器进行管理，并通过容器向对象提供所需的其他对象。这样，对象就可以从容器中获取所需的依赖对象，而不需要自己创建和分配。因此，可以说依赖注入是控制反转的一种具体实现方式。控制反转提供了宏观的思路和框架，而依赖注入则提供了具体的实现方式和细节。在实际应用中，通常使用依赖注入来实现控制反转，从而实现对象之间的解耦和依赖关系的管理。</p> 
<h4><a id="_127"></a>五、依赖注入的应用场景</h4> 
<p>依赖注入在很多场景下都可以应用，以下是一些常见的应用场景：</p> 
<ol><li><strong>Web开发：</strong> 在Web开发中，依赖注入可以用来解耦应用程序的不同层，比如控制器、服务、数据访问等。通过依赖注入，可以将依赖关系从代码中抽离出来，交给外部容器进行管理，从而使代码更加灵活、可维护和可测试。</li><li><strong>单元测试：</strong> 在单元测试中，依赖注入可以用来模拟和注入测试对象。通过依赖注入，可以轻松地替换和模拟依赖对象，从而对代码进行测试和验证。</li><li><strong>插件化应用程序：</strong> 在插件化应用程序中，依赖注入可以用来实现插件之间的解耦。通过依赖注入，可以将插件之间的依赖关系交给外部容器进行管理，从而使插件更加灵活、可扩展和可插拔。</li><li><strong>消息队列：</strong> 在消息队列中，依赖注入可以用来解耦消息生产者和消费者。通过依赖注入，可以将消息生产者和消费者之间的依赖关系交给外部容器进行管理，从而使消息队列更加灵活、可维护和可扩展。</li><li><strong>单例模式：</strong> 在单例模式中，依赖注入可以用来创建和管理单例对象。通过依赖注入，可以确保单例对象的创建和分配由容器来完成，从而使代码更加简洁、可维护和可测试。</li></ol> 
<h4><a id="_135"></a>六、总结</h4> 
<p>依赖注入（DI）是一种软件设计模式，也是实现控制反转的其中一种技术。这种模式能让一个物件接收它所依赖的其他物件。依赖注入可以应用到很多场景中，如Web开发、单元测试、插件化应用程序、消息队列和单例模式等。通过依赖注入，可以实现对象之间的解耦和依赖关系的管理，从而提高代码的可维护性、可扩展性和可测试性。依赖注入是控制反转的一种具体实现方式，它通过将依赖关系从代码中抽离出来，交给外部容器进行管理，并通过容器向对象提供所需的其他对象。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d5cec1af47ff77859362d0a03f51c519/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《WebKit 技术内幕》学习之四（3）： 资源加载和网络栈</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/84a6df69b6074980ca4da0944c5c8a36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql进阶-执行计划</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>