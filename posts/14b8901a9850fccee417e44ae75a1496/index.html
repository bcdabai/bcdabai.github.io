<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中常用函数以及类型总结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中常用函数以及类型总结" />
<meta property="og:description" content="记录在刷题过程中经常用到的，总结一下加深印象，方便以后查询。
目录 vector(动态数组）stringlist(双向链表)algorithm头文件下的常用函数sortnext_permutation()max(),min(),abs(),reverse(),swap()fill() setmapqueuepriority_queuedequestack vector(动态数组） 需要头文件&lt;vector&gt;
构造函数
vector&lt;int&gt; nums; //构造数据元素类型为int的空动态数组
vector&lt;int&gt; nums2(nums1); //构造元素与nums相同的动态数组（拷贝）
vector&lt;int&gt; nums(size); //数据元素类型为int，个数为size的动态数组
vector&lt;int&gt; nums(size,val); //数据元素类型为int，个数为size,初始值为val的动态数组
vector&lt;int&gt; nums[arraySize]; //定义长度为arraySize的vector动态数组数组。
访问 vector内元素有两种访问方式，通过下标或迭代器访问。
通过下标访问时和普通数组差不多，范围为(0到nums.size()-1)
通过迭代器访问如下:
vector&lt;typename&gt;::iterator it; //typename是类型名,通过*it 来访问
注意：
(nums[i]和*(it.begin()&#43;i)等价)(it.end()是尾元素的下一个地址)
排序 需要头文件&lt;algorithm&gt;(具体细节见algorithm)
sort(nums.begin(),nums.end());
nums.push_back(val); //在数组末尾插入一个值为val的 元素
string 头文件为&lt;string&gt;
子串
string s;
s.substr(begin,len) //返回字符串s从begin位置开始长度为len的子串。
list(双向链表) 头文件为&lt;list&gt;，list无法通过下标访问。
双向链表的每一个元素中都有一个指针指向后一个元素，也有一个指针指向前一个元素。
在 list 容器中，在已经定位到要增删元素的位置的情况下，增删元素能在常数时间内完成。(比vector要快)。
注意:list无法用algorithm中的sort进行排序，可以用自己的成员函数进行排序。
构造函数:
list&lt;int&gt; lst; //创建空list
list&lt;int&gt; lst1(5,5); //创建含有5个值为5的元素的list
list&lt;int&gt; lst2(lst); //用lst初始化lst2
常用函数:
list.begin()、list.end()list.front()、list.back()list.push_back(val)、list.push_front(val)list.pop_back()、list.pop_front()list.erase() algorithm头文件下的常用函数 sort sort(首元素地址(必须填),尾元素地址的下一个地址(必填)，比较函数(非必填))
如果不写比较函数，默认对区间递增排序，实例如下（参考《算法笔记》）
注意： 在写cmp函数时,针对两个比较的对象，如果相等一定要返回false!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/14b8901a9850fccee417e44ae75a1496/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-03T14:36:54+08:00" />
<meta property="article:modified_time" content="2019-07-03T14:36:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中常用函数以及类型总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>记录在刷题过程中经常用到的，总结一下加深印象，方便以后查询。</strong><br> </p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#vector_3" rel="nofollow">vector(动态数组）</a></li><li><a href="#string_25" rel="nofollow">string</a></li><li><a href="#list_31" rel="nofollow">list(双向链表)</a></li><li><a href="#algorithm_49" rel="nofollow">algorithm头文件下的常用函数</a></li><li><ul><li><a href="#sort_50" rel="nofollow">sort</a></li><li><a href="#next_permutation_142" rel="nofollow">next_permutation()</a></li><li><a href="#maxminabsreverseswap_164" rel="nofollow">max(),min(),abs(),reverse(),swap()</a></li><li><a href="#fill_167" rel="nofollow">fill()</a></li></ul> 
  </li><li><a href="#set_172" rel="nofollow">set</a></li><li><a href="#map_184" rel="nofollow">map</a></li><li><a href="#queue_212" rel="nofollow">queue</a></li><li><a href="#priority_queue_221" rel="nofollow">priority_queue</a></li><li><a href="#deque_263" rel="nofollow">deque</a></li><li><a href="#stack_274" rel="nofollow">stack</a></li></ul> 
</div> 
<p></p> 
<h2><a id="vector_3"></a>vector(动态数组）</h2> 
<p>需要头文件&lt;vector&gt;<br> <strong>构造函数</strong></p> 
<blockquote> 
 <p>vector&lt;int&gt; nums; //构造数据元素类型为int的空动态数组<br> vector&lt;int&gt; nums2(nums1); //构造元素与nums相同的动态数组（拷贝）<br> vector&lt;int&gt; nums(size); //数据元素类型为int，个数为size的动态数组<br> vector&lt;int&gt; nums(size,val); //数据元素类型为int，个数为size,初始值为val的动态数组<br> vector&lt;int&gt; nums[arraySize]; //定义长度为arraySize的vector动态数组数组。</p> 
</blockquote> 
<p><strong>访问</strong> vector内元素有两种访问方式，通过下标或迭代器访问。<br> 通过下标访问时和普通数组差不多，范围为(0到nums.size()-1)<br> 通过迭代器访问如下:</p> 
<blockquote> 
 <p>vector&lt;typename&gt;::iterator it; //typename是类型名,通过*it 来访问</p> 
</blockquote> 
<p>注意：<br> (nums[i]和*(it.begin()+i)等价)(it.end()是尾元素的下一个地址)</p> 
<p><strong>排序</strong> 需要头文件&lt;algorithm&gt;(具体细节见algorithm)</p> 
<blockquote> 
 <p>sort(nums.begin(),nums.end());</p> 
</blockquote> 
<blockquote> 
 <p>nums.push_back(val); //在数组末尾插入一个值为val的 元素</p> 
</blockquote> 
<h2><a id="string_25"></a>string</h2> 
<p>头文件为&lt;string&gt;<br> <strong>子串</strong></p> 
<blockquote> 
 <p>string s;<br> s.substr(begin,len) //返回字符串s从begin位置开始长度为len的子串。</p> 
</blockquote> 
<h2><a id="list_31"></a>list(双向链表)</h2> 
<p>头文件为&lt;list&gt;，list无法通过下标访问。</p> 
<blockquote> 
 <p>双向链表的每一个元素中都有一个指针指向后一个元素，也有一个指针指向前一个元素。<br> 在 list 容器中，在已经定位到要增删元素的位置的情况下，增删元素能在常数时间内完成。(比vector要快)。<br> <strong>注意</strong>:list无法用algorithm中的sort进行排序，可以用自己的成员函数进行排序。</p> 
</blockquote> 
<p>构造函数:</p> 
<blockquote> 
 <p>list&lt;int&gt; lst; //创建空list<br> list&lt;int&gt; lst1(5,5); //创建含有5个值为5的元素的list<br> list&lt;int&gt; lst2(lst); //用lst初始化lst2</p> 
</blockquote> 
<p>常用函数:</p> 
<ul><li>list.begin()、list.end()</li><li>list.front()、list.back()</li><li>list.push_back(val)、list.push_front(val)</li><li>list.pop_back()、list.pop_front()</li><li>list.erase()</li></ul> 
<h2><a id="algorithm_49"></a>algorithm头文件下的常用函数</h2> 
<h3><a id="sort_50"></a>sort</h3> 
<blockquote> 
 <p>sort(首元素地址(必须填),尾元素地址的下一个地址(必填)，比较函数(非必填))<br> 如果不写比较函数，默认对区间递增排序，实例如下（参考《算法笔记》）</p> 
</blockquote> 
<p><strong>注意： 在写cmp函数时,针对两个比较的对象，如果相等一定要返回false!!!</strong></p> 
<p><strong>数组的排序</strong></p> 
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;

int main(){
	int a[6] = {9,4,2,5,6,-1};
	//将a[0]~a[3]从小到大排序
	sort(a,a+4);
	for(int i = 0;i &lt;6;i++)
		printf("%d ",a[i]); 
	return 0;
}
</code></pre> 
<blockquote> 
 <p>对于排序的指定规则，也可以自己定义，这时候就要用到sort的第三个可选参数cmp.使用sort对数组升序排列时，cmp函数的构造如下。</p> 
</blockquote> 
<p><strong>结构体数组的排序</strong></p> 
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;

bool cmp(int a,int b){
	return a &gt; b;	//可以理解为当a&gt;b时，把a放在前面
}

int main(){
	int a[6] = {9,4,2,5,6,-1};
	//将a[0]~a[3]从大到小排序
	sort(a,a+4,cmp);
	for(int i = 0;i &lt;6;i++)
		printf("%d ",a[i]); 
	return 0;
}
</code></pre> 
<blockquote> 
 <p>使用sort也可以对<strong>结构体数组</strong>进行排序,使用方法见下例。</p> 
</blockquote> 
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;

struct node{
	int x,y;
}ssd[10];

bool cmp(node a,node b){
	return a.x &gt;= b.x ; //按x的值降序
}

int main(){
	ssd[0].x = 2;ssd[0].y = 2; //{2,2}
	ssd[1].x = 1;ssd[1].y = 3; //{1,3}
	ssd[2].x = 3;ssd[2].y = 1; //{3,1}
	sort(ssd,ssd+3,cmp);
	for(int i = 0;i &lt;3;i++)
		printf("%d %d\n",ssd[i].x,ssd[i].y); 
	return 0;
}
</code></pre> 
<p><strong>容器的排序</strong></p> 
<blockquote> 
 <p>在STL标准容器中，只有vector、string、deque是可以使用sort的，这是因为像map、set这种容器是用红黑树实现的，元素本身有序，故不允许用sort排序.对vector排序的例子如下:</p> 
</blockquote> 
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;


bool cmp(int a,int b){
	return a &gt;= b ; //降序
}

int main(){
	vector&lt;int&gt; nums;
	nums.push_back(3);
	nums.push_back(1);
	nums.push_back(2);
	sort(nums.begin(),nums.end(),cmp); //对整个vector排序 
	for(int i = 0;i &lt;3;i++)
		printf("%d ",nums[i]); 
	return 0;
}
</code></pre> 
<p>如string等，其余类似。</p> 
<h3><a id="next_permutation_142"></a>next_permutation()</h3> 
<p>next_permutation()给出一个序列在全排列的下一个序列。<br> prev_permutation()给出一个序列在全排列的上一个序列。</p> 
<blockquote> 
 <p>例题:<a href="https://www.luogu.com.cn/problem/P1088" rel="nofollow">洛谷p1088 火星人</a></p> 
</blockquote> 
<pre><code class="prism language-c++">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;

int main(){
	int nums[10000];
	int n,m;
	scanf("%d %d",&amp;n,&amp;m);
	for(int i=0;i&lt;n;i++)
		scanf("%d",&amp;nums[i]);
	while(m--)
		next_permutation(nums,nums+n);
	for(int i=0;i&lt;n;i++)
		printf("%d ",nums[i]);
	return 0;
}
</code></pre> 
<h3><a id="maxminabsreverseswap_164"></a>max(),min(),abs(),reverse(),swap()</h3> 
<p>这些函数比较常用也比较容易，略。(使用reverse()也注意左闭右开)</p> 
<h3><a id="fill_167"></a>fill()</h3> 
<blockquote> 
 <p>int a[5] = {1,2,3,4,5};<br> fill(a,a+5,233); //将a[0]~a[4]均赋值为233。</p> 
</blockquote> 
<h2><a id="set_172"></a>set</h2> 
<p>set(集合）是一个内部自动有序且不含重复元素的容器。只能通过迭代器访问。</p> 
<blockquote> 
 <p>set&lt;typename&gt; name;<br> set&lt;typename&gt;::iterator it; //只能it++不能it+1的方式访问</p> 
</blockquote> 
<p>常用函数:insert(),find(),erase(),size(),clear().<br> 注意：</p> 
<ul><li>find(value)返回set中对应值为value的迭代器。set中没有该值时为.end();</li></ul> 
<p>实际上，由于set和map底层是基于平衡树（红黑树）实现，因此应该有很多平衡树的接口，比如lower_bound,upper_bound在log(N)的时间查询出第一个大于或等于大于的元素，这个有时也会用到，感兴趣可以自行查询<code>https://zh.cppreference.com/w/cpp/container/set/lower_bound</code></p> 
<h2><a id="map_184"></a>map</h2> 
<p>需要头文件&lt;map&gt;<br> map的原理为红黑数，查询复杂度为log(N)<br> map可以通过下标访问，或者通过迭代器访问。</p> 
<blockquote> 
 <p>map&lt;typename1,typename2&gt;::iterator it;</p> 
</blockquote> 
<p>通过it-&gt;first来访问键，使用it-&gt;second来访问值。</p> 
<p><strong>构造函数</strong></p> 
<blockquote> 
 <p>map&lt;int,int&gt; hashmap; //构造一个map对象hashmap,键：int型，值：int型</p> 
</blockquote> 
<p><strong>插入</strong></p> 
<blockquote> 
 <p>map&lt;string,int&gt; hashmap;<br> hashmap[“asd”] = 1; //直接插入，如果已经有键为"asd"的结点，则直接覆盖。<br> hashmap.insert(pair&lt;string, int&gt;(“aaa”,1)); //使用insert函数插入，如果结点已经存在，则无法插入（不会改变原来的值）</p> 
</blockquote> 
<p><strong>删除</strong></p> 
<blockquote> 
 <p>map&lt;string,int&gt; hashmap;<br> map&lt;string,int&gt;::iterator iter;<br> hashmap.erase(iter); //通过迭代器的方式删除，删除成功返回1，失败返回0<br> hashmap.erase(“aaa”); //通过关键字的方式删除，删除成功返回1，失败返回0</p> 
</blockquote> 
<p><strong>查找</strong></p> 
<blockquote> 
 <p>map&lt;string,int&gt; hashmap;<br> map&lt;string,int&gt;::iterator iter;<br> iter = hashmap.find(“asd”); //迭代器返回当前元素的位置，如果map中无该元素，则返回hashmap.end()<br> int n = hashmap.count(“asd”); //因为map中不存在相同的元素，因此只能返回0或1.</p> 
</blockquote> 
<h2><a id="queue_212"></a>queue</h2> 
<p>queue为队列（先进先出），需要头文件&lt;queue&gt;</p> 
<blockquote> 
 <p>queue&lt;typename&gt; name;</p> 
</blockquote> 
<p><strong>访问</strong><br> 只能通过front()来访问队首元素，通过back()来访问队尾元素。<br> push()入队，pop()出队。<br> 通过empty()，queue为空返回true;</p> 
<h2><a id="priority_queue_221"></a>priority_queue</h2> 
<p>priority_queue(优先队列),头文件也是&lt;queue&gt;。<br> 底层用堆来实现，队首元素是队列中优先级最高的一个。</p> 
<blockquote> 
 <p>priority_queue&lt;typename&gt; name;</p> 
</blockquote> 
<p><strong>访问</strong><br> 和queue队列不同，priority_queue优先队列没有front()和back()函数，只能通过top()函数来访问队首元素。</p> 
<p><strong>优先级设置</strong></p> 
<ul><li>当优先队列的类型为可比较的类型时候，下列两种写法等价，以int类型为例。</li></ul> 
<blockquote> 
 <p>priority_queue&lt;int&gt; q;<br> priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q;</p> 
</blockquote> 
<p>如果想把最小的元素放在队列首</p> 
<blockquote> 
 <p>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</p> 
</blockquote> 
<ul><li>结构体的优先级设置。按price高为优先级高</li></ul> 
<ol><li>写法一（重载结构体的"&lt;"号）</li></ol> 
<pre><code class="prism language-c++">struct fuit{
	string name;
	int price;
	friend bool operator &lt; (fruit f1, fruit f2){
		return f1.price &lt; f2.price;
	}
};
</code></pre> 
<p>2.写法二 (写在结构体外部)</p> 
<pre><code class="prism language-c++">struct fuit{
	string name;
	int price;
};

struct cmp{
	bool operator () (fruit f1, fruit f2){
		return f1.price &lt; f2.price;
	}
};

priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp&gt; q;
</code></pre> 
<h2><a id="deque_263"></a>deque</h2> 
<p>双端队列,两头都能插入删除查看数据。需要头文件&lt;deque&gt;</p> 
<blockquote> 
 <p>deque dq;</p> 
</blockquote> 
<p>常用函数:</p> 
<ul><li>dq.push_front();</li><li>dq.push_back();</li><li>dq.pop_front();</li><li>dq.pop_back();</li><li>dq.front();</li><li>dq.back();</li></ul> 
<h2><a id="stack_274"></a>stack</h2> 
<p>stack栈，后进先出，需要头文件&lt;stack&gt;</p> 
<blockquote> 
 <p>stack&lt;typename&gt; name;</p> 
</blockquote> 
<p><strong>访问</strong><br> 只能通过top()访问栈顶元素。</p> 
<p><strong>常用函数</strong><br> push(),pop(),top(),empty(),size().</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/de6f16ef0811f2a124deb2de112d7e9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端请求后端接口出现Waiting(TTFB)耗时很长的解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/87bef07b9bb7051ac61e417793df144b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">请求（RequestInfo）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>