<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>云备份项目 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="云备份项目" />
<meta property="og:description" content="目录
项目实现目标设计:
项目环境:
使用到的库:
Jsoncpp 库: 使用方法:
Bundle 库:
使用方法:
Httplib 库:
使用方法: C&#43;&#43;17 filesystem库:
模块的实现: 服务端数据管理模块:
服务端热点管理模块:
服务端网络通信模块 与 业务处理模块:
客户端数据管理模块:
客户端目录检查模块:
客户端网络通信模块:
项目的不足及改进思路:
项目源码:
项目实现目标设计: 服务端程序: 部署在linux服务器上
实现针对客户端请求的业务处理: 文件的上传备份，以及客户端浏览器的查看以及下载功能, 并且具有热点管理功能和下载时断点续传功能，将非热点文件压缩存储节省磁盘空间
服务端模块划分设计:
网络通信模块: 实现与客户端进行网络通信，并进行http协议数据解析客户端请求
业务处理模块: 明确客户端请求，并且进行对应的业务处理(上传文件，备份信息获取，文件下载)数据管理模块: 对备份文件信息进行统一数据管理
热点管理模块: 对服务器上备份的文件进行热点管理，将非热点文件进行压缩存储
客户端程序: 部署在windows客户机上
实现针对客户端主机上指定文件夹中的文件，自动进行检测判断是否需要备份，需要则上传到服务器备份
客户端模块划分设计:
目录检测模块: 遍历客户端主机上的指定文件夹，获取文件夹下所有的文件信息
数据管理模块:管理客户端所备份的所有文件信息(判断一个文件是否需要备份:1.历史备份信息中不存在，2.历史备份信息存在但是不一致)
网络通信模块: 搭建网络通信客户端，将需需要备份的文件上传备份到服务器
项目环境: 服务器: centos7(以上)/ vim、g&#43;&#43;(7.3以上)、gdb、makefile
客户端: Windows10/ vs2017(以上)
使用到的库: Jsoncpp 库: json 是一种数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。比如将一个一个的键值对组织成这种格式:
jsoncpp 库用于实现 json 格式的序列化和反序列化，完成将多个数据对象组织成为 json 格式字符串，以及将 json 格式字符串解析得到多个数据对象的功能。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0635efd47f994054a51e84401f49c3e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-22T16:23:40+08:00" />
<meta property="article:modified_time" content="2022-03-22T16:23:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">云备份项目</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E7%9B%AE%E6%A0%87%E8%AE%BE%E8%AE%A1%3A-toc" style="margin-left:0px;"><a href="#%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E7%9B%AE%E6%A0%87%E8%AE%BE%E8%AE%A1%3A" rel="nofollow">项目实现目标设计:</a></p> 
<p id="%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%3A-toc" style="margin-left:0px;"><a href="#%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%3A" rel="nofollow">项目环境:</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%BA%93%3A-toc" style="margin-left:0px;"><a href="#%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%BA%93%3A" rel="nofollow">使用到的库:</a></p> 
<p id="Jsoncpp%20%E5%BA%93%3A%C2%A0-toc" style="margin-left:40px;"><a href="#Jsoncpp%20%E5%BA%93%3A%C2%A0" rel="nofollow">Jsoncpp 库: </a></p> 
<p id="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%3A-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%3A" rel="nofollow">使用方法</a>:</p> 
<p id="Bundle%20%E5%BA%93%3A-toc" style="margin-left:40px;"><a href="#Bundle%20%E5%BA%93%3A" rel="nofollow">Bundle 库:</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%3A-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%3A" rel="nofollow">使用方法:</a></p> 
<p id="Httplib%20%E5%BA%93%3A-toc" style="margin-left:40px;"><a href="#Httplib%20%E5%BA%93%3A" rel="nofollow">Httplib 库:</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%3A%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%3A%C2%A0" rel="nofollow">使用方法: </a></p> 
<p id="C%2B%2B17%20filesystem%E5%BA%93%3A-toc" style="margin-left:40px;"><a href="#C%2B%2B17%20filesystem%E5%BA%93%3A" rel="nofollow">C++17 filesystem库:</a></p> 
<p id="%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%9E%E7%8E%B0%3A%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%9E%E7%8E%B0%3A%C2%A0" rel="nofollow">模块的实现: </a></p> 
<p id="%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%3A-toc" style="margin-left:40px;"><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%3A" rel="nofollow">服务端数据管理模块:</a></p> 
<p id="%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%83%AD%E7%82%B9%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%3A-toc" style="margin-left:40px;"><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%83%AD%E7%82%B9%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%3A" rel="nofollow">服务端热点管理模块:</a></p> 
<p id="%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97%20%E4%B8%8E%20%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97%3A-toc" style="margin-left:40px;"><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97%20%E4%B8%8E%20%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97%3A" rel="nofollow">服务端网络通信模块 与 业务处理模块:</a></p> 
<p id="%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%3A-toc" style="margin-left:40px;"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%3A" rel="nofollow">客户端数据管理模块:</a></p> 
<p id="%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9B%AE%E5%BD%95%E6%A3%80%E6%9F%A5%E6%A8%A1%E5%9D%97%3A-toc" style="margin-left:40px;"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9B%AE%E5%BD%95%E6%A3%80%E6%9F%A5%E6%A8%A1%E5%9D%97%3A" rel="nofollow">客户端目录检查模块:</a></p> 
<p id="%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97%3A-toc" style="margin-left:40px;"><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97%3A" rel="nofollow">客户端网络通信模块:</a></p> 
<p id="%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%8D%E8%B6%B3%E5%8F%8A%E6%94%B9%E8%BF%9B%E6%80%9D%E8%B7%AF%3A-toc" style="margin-left:0px;"><a href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%8D%E8%B6%B3%E5%8F%8A%E6%94%B9%E8%BF%9B%E6%80%9D%E8%B7%AF%3A" rel="nofollow">项目的不足及改进思路:</a></p> 
<p id="%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%3A-toc" style="margin-left:0px;"><a href="#%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%3A" rel="nofollow">项目源码:</a></p> 
<p></p> 
<h2 id="%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E7%9B%AE%E6%A0%87%E8%AE%BE%E8%AE%A1%3A">项目实现目标设计:</h2> 
<p><strong><span style="color:#fe2c24;">服务端程序</span>: </strong>部署在linux服务器上<br> 实现针对客户端请求的业务处理: <strong>文件的上传备份，以及客户端浏览器的查看以及下载功能, 并且具有热点管理功能和下载时断点续传功能，将非热点文件压缩存储节省磁盘空间</strong></p> 
<p><strong>服务端模块划分设计:</strong><br><strong>网络通信模块</strong>: 实现与客户端进行网络通信，并进行http协议数据解析客户端请求<br><strong>业务处理模块:</strong> 明确客户端请求，并且进行对应的业务处理(上传文件，备份信息获取，文件下载)<strong>数据管理模块:</strong> 对备份文件信息进行统一数据管理<br><strong>热点管理模块:</strong> 对服务器上备份的文件进行热点管理，将非热点文件进行压缩存储</p> 
<p><strong><span style="color:#fe2c24;">客户端程序</span>: </strong>部署在windows客户机上<br> 实现针对客户端主机上指定文件夹中的文件，自动进行检测判断是否需要备份，需要则上传到服务器备份</p> 
<p><strong>客户端模块划分设计:</strong></p> 
<p><strong>目录检测模块: </strong>遍历客户端主机上的指定文件夹，获取文件夹下所有的文件信息</p> 
<p><strong>数据管理模块:</strong>管理客户端所备份的所有文件信息(判断一个文件是否需要备份:1.历史备份信息中不存在，2.历史备份信息存在但是不一致)</p> 
<p><strong>网络通信模块: </strong>搭建网络通信客户端，将需需要备份的文件上传备份到服务器</p> 
<p></p> 
<h2 id="%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%3A">项目环境:</h2> 
<p>服务器: centos7(以上)/ vim、g++(7.3以上)、gdb、makefile</p> 
<p>客户端: Windows10/ vs2017(以上)</p> 
<p></p> 
<h2 id="%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%BA%93%3A">使用到的库:</h2> 
<h3 id="Jsoncpp%20%E5%BA%93%3A%C2%A0">Jsoncpp 库: </h3> 
<p><strong>json 是一种数据交换格式，</strong>采用完全独立于编程语言的文本格式来存储和表示数据。比如<strong>将一个一个的键值对组织成这种格式:</strong></p> 
<p> <img alt="" height="134" src="https://images2.imgbox.com/42/4a/G10ydGwu_o.png" width="211"></p> 
<p>jsoncpp 库用于实现 json 格式的序列化和反序列化，完成将多个数据对象组织成为 json 格式字符串，以及将 json 格式字符串解析得到多个数据对象的功能。</p> 
<p>在<strong>本项目中, 选择json序列化在<span style="color:#fe2c24;">服务端的数据管理模块</span>实现数据的持续化存储和数据传输</strong>, 管理文件信息时<strong>将文件信息组织成json序列化后存储在备份文件信息文件中实现持续化存储. 读取备份文件信息时再将信息反序列化放入hash表中实现运行时高效地内存读写.</strong></p> 
<h4 id="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%3A"><strong>使用方法:</strong></h4> 
<p><img alt="" height="1095" src="https://images2.imgbox.com/ec/2d/f8KldQMw_o.png" width="1000"></p> 
<h3></h3> 
<h3 id="Bundle%20%E5%BA%93%3A"><strong>Bundle 库:</strong></h3> 
<p>数据压缩及解压缩库, 在本项目中<strong><span style="color:#fe2c24;">服务端的热点管理模块</span>, 若判断文件不是热点文件使用bundle库将其压缩用户下载时再将其解压缩.</strong>(因为bundle.cpp过于庞大, 编译较慢 在项目中将其生成为一个静态库使用)</p> 
<h4>使用方法:</h4> 
<p><img alt="" height="1183" src="https://images2.imgbox.com/7d/72/kdn7H8Dy_o.png" width="1028"></p> 
<p></p> 
<h3 id="Httplib%20%E5%BA%93%3A">Httplib 库:</h3> 
<p>本来应该自己实现一个基本的http服务器, 但是本项目由于时间较为紧张, 因此使用了现成的高效的httplib库.</p> 
<p>在本项目中, <strong>服务端使用httplib库<span style="color:#fe2c24;">实现业务处理模块, 处理客户端发来的上传, 查看, 下载三个请求</span>, 客户端使用其实现文件的上传.(客户端的查看, 下载请求通过浏览器直接输入实现). </strong>在传输层是基于tcp实现传输的</p> 
<h4 id="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%3A%C2%A0"><strong>使用方法: </strong></h4> 
<p><img alt="" height="952" src="https://images2.imgbox.com/79/d2/l2i4b45H_o.png" width="926"></p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/a0/f4/PAu2Gppm_o.png" width="857"></p> 
<p></p> 
<h3 id="C%2B%2B17%20filesystem%E5%BA%93%3A"><strong>C++17 filesystem库:</strong></h3> 
<p>使用该库实现<strong><span style="color:#fe2c24;">服务端和客户端的文件操作工具类实现( util.hpp ),</span> 实现文件目录的创建, 检索文件是否存在, 获取不带路径的纯文件名, 浏览遍历指定目录下文件, 删除文件等操作.</strong></p> 
<p><strong>使用方法:  详见 util.hpp...</strong></p> 
<p></p> 
<h2 id="%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%9E%E7%8E%B0%3A%C2%A0">模块的实现: </h2> 
<h3 id="%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%3A">服务端数据管理模块:</h3> 
<p><strong>要管理的数据: </strong>原文件名，原文件大小，原文件时间属性，对应的压缩包名称，压缩标志<br> 上传的文件，最终是用户在浏览器上进行查看并下载的，而<strong>浏览器界面上需要能够展示客户端曾经备份过的文件: 原文件名，文件大小，文件备份时间</strong></p> 
<p>在浏览器客户端下载时, 规定下载链接为/download/文件名 , 所以我们管理的数据中还需要有url_path这个下载链接, 且url_path作为运行时内存中数据hash表的key值, 其他信息封装为fileinfo结构体作hash的val值.<br><img alt="" height="197" src="https://images2.imgbox.com/1c/b3/TdtFMmnV_o.png" width="644"></p> 
<p><img alt="" height="199" src="https://images2.imgbox.com/69/ca/jbyT657i_o.png" width="1200"></p> 
<p><strong>实现详解( data.hpp &amp; util.hpp): </strong></p> 
<p><strong>文件数据的管理主要是<span style="color:#fe2c24;">文件信息的增删改查</span>, 和每次对信息增改删后更新back_info文件中的备份文件信息: </strong></p> 
<p><strong>增:</strong> 传入一个文件的文件名(带路径), 先通过文件工具类File_util判断文件是否存在, 存在才获取文件信息并压入hash表写入back_info, 没有该文件则说明该文件不在服务端存储备份文件的文件夹backup_dir中, 视为没有备份该文件不增加输入的文件名的文件信息.</p> 
<p><strong>删: </strong>删除backup_info中备份文件的信息.. 通常是不需要这么干的. 除非是服务端自己调用File_util中的文件删除接口把用户备份的文件删除了, 才应该把被删除的备份文件的文件信息也给删除了.</p> 
<p><strong>改: </strong>给出文件名和要修改的文件状态(bool类型), 备份文件被压缩后更新备份信息, 只需要更新文件的压缩状态为true, 因为其他的信息都是固定不变的. 用户下载非热点的压缩文件时解压缩后更新压缩状态为false.</p> 
<p><strong>查</strong>: 查询与有三种方法. 1.查询所有文件的备份信息, 传入一个vecrtor&lt;fileinfo&gt;接收所有文件的信息</p> 
<p>2. 根据指定文件的url_path查询, 传入url_path和fileinfo结构体指针接收指定文件的文件信息</p> 
<p>3. 根据指定文件的real_path查询, 传入real_path和fileinfo结构体指针接收指定文件的文件信息</p> 
<p><strong>文件File_util主要是通</strong>过C++17中的文件系统库以ifstream及ofsram类操作文件, 包括<strong>文件的读写(open接口不存在则会创建),  判断文件是否存在, 获取不带路径的纯文件名, 浏览遍历指定目录下文件, 删除文件操作, 除此之外, 文件的压缩解压缩也属于文件操作也放在File_util内. </strong></p> 
<p><strong>util.hpp内除了File_util还有Json_util类, 有序列化反序列化两个静态方法, 静态方法好处是不需要实例化这个类的对象就可以对文件信息序列化反序列化.</strong></p> 
<h2></h2> 
<h3 id="%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%83%AD%E7%82%B9%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%3A">服务端热点管理模块:</h3> 
<p>功能:  对备份目录下的文件，进行检测，判断每个文件是否为热点文件, 本项目设的判断依据是当前时间距离文件最后一次访问时间是否超过<strong>30秒 热点判断时间</strong>，如果<strong>超过了就表示这是一个非热点文件，则需要压缩存储，压缩之后删除源文件，压缩成功之后，通过数据管理对象，修改备份信息, 状态为已压缩。</strong><br> 实现:<br> 1.遍历指定目录-文件备份目录-源文件存储路径，获取目录下所有文件的实际路径名</p> 
<p>2.遍历所有文件名，通过文件路径名，获取文件的时间属性(最后一次访问时间)</p> 
<p>3.获取系统当前时间，与文件最后一次访问时间进行相减，将差值与指定的热点判断时间进行比较</p> 
<p>4.若超过热点判断时长，则判定为非热点，进行压缩存储</p> 
<p>5.压缩完毕后，修改备份信息<br>  </p> 
<h3 id="%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97%20%E4%B8%8E%20%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97%3A">服务端网络通信模块 与 业务处理模块:</h3> 
<p>网络通信模块使用httplib库搭建http服务器，我们<strong>更多关注业务的处理</strong>。业务处理<strong>包括: 上传的处理，查看页面请求的处理</strong>，下载的处理. ( 文件上传成功后，测试代码时需要校验校验源文件与服务器备份的文件是否一致, 通过比较MD5值判断文件内容是否一致)</p> 
<p>MD5: 根据文件内容进行的散列计算得到的一串字符串，文件内容只要不同计算而出的MD5值就不一样.      linux命令: md5sum a.txt     windows命令: certutil-hashfile a.txt md5</p> 
<p><strong>上传: </strong>上传请求业务处理通过服务器接收到的 http 请求正文实现,  通过 MutipartFormData 中的区域标识符字段name是否为 "file" 判断上传的是否为文件, 再通过 filename 文件名字段获取备份文件名, content字段获取备份文件的内容, 通过 File_util 中的 write 接口实现备份, 添加备份信息, 成功返回 200OK 响应状态码.</p> 
<p><strong>查看: </strong>查看请求业务处理通过遍历获取备份文件夹下所有备份文件的文件信息, 将文件信息组织渲染成html页面, 这里简单学了最基本的前端知识来写了个页面, <strong>将文件名作为 /download/filename 超链接</strong>, <strong>客户端浏览器点击该文件名即向服务点发送 /download/filename 下载文件请求</strong>. 将写好的html 页面作为响应正文返回.</p> 
<p><strong>下载: </strong>下载请求业务具有断点续传功能,  <strong>断点续传: </strong>当下载一个文件的时候，下载到中途，因为网络或者其他原因，导致下载中断, 如果第二次后边重新下载所有文件数据，效率就比较低，因为实际上之前传输的数据是不需要重新传输的如果这次下载只是从上一次断开的位置重新下载，就可以提升很高的下载效率<strong>. </strong></p> 
<p><strong>实现思想(配合代码注释):</strong>  需要一端能够记记录目己传输的位置，也就是下载到哪里了，但是服务端记录是不合适的，因为请求都是由客户端发起的，因此应该由客户端记录实际上也就是谁需要数据，就谁记录. 客户端下载过程中，记录自己的已经下载的数据长度和位置，如果中途下载中断，在下次请求的时候，将自己所需要的指定文件的区间范围发送给服务器，服务器根据指定的区间范围返回数据即可。但是存在一个问题: 怎么保证上次下载的文件，和当前续传的文件是一致的?也就是如果续传的时候，服务器上的文件数据已经发生了改变，则续传是没有意义的. 因此就必须有个标识(etag)，用于辨别服务器上的文件在上一次下载后有没有被修改过。没有修改过则可以断点续传，如果修改过了则不能断点续传，需要重新下载<br> 因此断点续传，需要和上一次的下载关联起来，需要上一次下载信息的支持，比如文件唯一标识</p> 
<p><img alt="" height="787" src="https://images2.imgbox.com/5b/90/6dbvZbFt_o.png" width="1066"></p> 
<p></p> 
<h3 id="%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%3A">客户端数据管理模块:</h3> 
<p>客户端的数据处理模块不需要管理太多的文件数据, 只需要记录 "文件名= etag" 即可, 所以不需要json库的将信息序列化存储也就不需要按序列化这两个接口了, 当然客户端也不需要压缩解压缩接口.  File_util 的代码是linux, windows都可以复用的, 所以获取文件信息, 创建备份文件目录, 创建备份文件信息文件等直接复用 util.hpp 代码即可. 客户端的数据管理模块也是对文件信息的增删改查, </p> 
<p>增: 将文件放入上传备份的文件夹中, 则增加放入的文件的文件信息.</p> 
<p>删: 和服务端一样, 作为拓展模块, 一般不需要调用删除.</p> 
<p>改: 在判断文件是否需要上传时, 若此时文件信息和之前保存发文件信息不同了则上传, 同时更新文件存储信息.</p> 
<p>查: 通过查询保存的文件信息etag与当前时刻的文件etag比较时使用.</p> 
<h3 id="%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9B%AE%E5%BD%95%E6%A3%80%E6%9F%A5%E6%A8%A1%E5%9D%97%3A">客户端目录检查模块:</h3> 
<p>客户端的目录检索模块复用服务端 util.hpp 代码, 实现相同的功能.</p> 
<h3 id="%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97%3A">客户端网络通信模块:</h3> 
<p>通过不断遍历备份文件夹中的文件, 判断其是否需要上传, 判断条件: 1. 该文件没有存储文件信息, 则说明该文件是刚放入备份文件夹的, 还没有备份上传, 需要备份. 2. 若存在备份文件信息, 则比较当前的etag与之前保存的etag比较, 若不相同则需要上传( 若最后一次访问时间与当前时间比较, 大于指定时间则认为用户已对文件修改完成, 可以上传, 否则认为用户还在修改, 先不上传, 等下次循环再判断时间是否大于, 大于则认为修改完成, 可以上传.)</p> 
<p>需要上传则使用 httplib 搭建客户端, 通过对库中MultipartFormData 设置区域标识字段 name="file" , 文件名filename="xxx" , File_util中 Read(xxx) 读取该文件的内容到content正文中, 再将MultipartFormData结构体通过 httplib::Post()接口即可实现上传.</p> 
<p></p> 
<h2 id="%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%8D%E8%B6%B3%E5%8F%8A%E6%94%B9%E8%BF%9B%E6%80%9D%E8%B7%AF%3A">项目的不足及拓展思路:</h2> 
<p>1. 上传时也可以实现断点续传功能  , 内存中的管理的数据也可以采用热点管理, 也可以自己实现http通信锻炼能力. </p> 
<p>2. 由于没有实现用户管理, 每个用户都是一个未知客户端, 每个客户端都是共享的上传下载 , 所以目前的项目对同名文件是只做了简单的覆盖处理, 后续改进可以考虑同一个客户端的二次备份, 不同客户端的同名文件的不同处理.</p> 
<p>3. 可以使用单例模式管理文件信息，能够让配置信息的管理控制更加统一灵活。且有了互斥锁对信息的保护才安全. </p> 
<p>4. 给客户端开发一个好看的界面( 需要学习前端知识 )，让监控目录可以选择.</p> 
<p>3. 文件压缩模块也可以使用线程池实现</p> 
<h2 id="%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%3A">项目源码:</h2> 
<p><a href="https://gitee.com/hemz/learning-records/tree/04a729992b608413461ee56bb3b4b6008e9cfba9/backup_cloud" rel="nofollow" title="backup_cloud · Hemz/学习记录 - 码云 - 开源中国 (gitee.com)">backup_cloud · Hemz/学习记录 - 码云 - 开源中国 (gitee.com)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c4279f2dd806728742b35197b1a9b363/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">KEPServerEX 6 之 数据模拟驱动 Simulator 使用方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99dbf7f0e155ca5ff12f92b4bf26967f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2022年最热门的招聘技术技能是什么，您绝对想不到</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>