<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】算法学习·Dijkstra算法详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C语言】算法学习·Dijkstra算法详解" />
<meta property="og:description" content="目录
Dijkstra算法设计
Dijkstra算法简介
Dijkstra算法的基本思想
Dijkstra贪心策略
完美图解
伪代码详解
完整代码
算法解析及优化拓展
​使用优先队列的完整代码
Dijkstra算法设计 Dijkstra算法简介 Dijkstra算法是解决**单源最短路径**问题的**贪心算法**
它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径直到求出从源点到其他各个顶点的最短路径。
Dijkstra算法的基本思想 首先假定源点为u，顶点集合V被划分为两部分：集合 S 和 V-S。 初始时S中仅含有源点u，其中S中的顶点到源点的最短路径已经确定。
集合S 和V-S中所包含的顶点到源点的最短路径的长度待定，称从源点出发只经过S中的点到达V-S中的点的路径为特殊路径，并用dist[]记录当前每个顶点对应的最短特殊路径长度。
Dijkstra贪心策略 选择特殊路径长度最短的路径，将其连接的V-S中的顶点加入到集合S中，同时更新数组dist[]。一旦S包含了所有顶点，dist[]就是从源到所有其他顶点的最短路径长度。
（1）数据结构。 设置地图的带权邻接矩阵为map[][]，即如果从源点u到顶点i有边，就令map[u][i]=&lt;u,i&gt;的权值，否则map[u][i]=∞；采用一维数组dist[i]来记录从源点到i顶点的最短路径长度：采用一维数组p[i]来记录最短路径上i顶点的前驱。（2）初始化。令集合S={u}，对于集合V-S中的所有顶点x，初始化dist[i]=map[u][i],如果源点u到顶点i有边相连，初始化p[i]=u(i的前驱是u),否则p[i]=-1（3）找最小。在集合V-S中依照贪心策略来寻找使得dist[j]具有最小值的顶点t,即dist[t]=min，则顶点t就是集合V-S中距离源点u最近的顶点。（4）加入S战队。将顶点t加入集合S，同时更新V-S（5）判结束。如果集合V-S为空，算法结束，否则转6（6）借东风。在（3）中已近找到了源点到t的最短路径，那么对集合V-S中所有与顶点t相邻的顶点j，都可以借助t走捷径。如果dist[j]&gt;dist[t]&#43;map[t][j],则dist[j]=dist[t]&#43;map[t][j]，记录顶点j的前驱为t，p[j]=t，转（3）。 我自己在这里理解就是，从u找到与它最近的点t，在从t找到与它最近的点j，在....按照这样持续下去，直到最后一个点 这里我再通俗的解释下这个借东风的意思。源点为1，如果我们找到了距离源点最近的点2，且点2与3,4相连。这样，我们如果要倒3,4有两种方法：
1-&gt;2-&gt;3(4) 1-&gt;3(4) 这里我们就要判断是从1直接到3(4)快，还是经过2后快。假设&lt;1,2&gt;=2 / &lt;2,3&gt;=3 / &lt;1,3&gt;=4，根据上面的数据，我们第一次找最小找到的是2结点，如果我们直接把2替换掉1当做源点继续找下一个最近的点，这种方法是错的。
因为可以看出1-&gt;3只用4，而过2的话要用5。
完美图解 这里我就直接放图片了，书里的图不好画。但主要的是自己按照其流程过一遍，在草稿纸上自己画一遍。
伪代码详解 跟着图解大致了解了一遍接下来就要上代码了，放心，代码不是一个完整的几十行的代码，全部按步骤划分好了的，这里方便大家粘贴。
/* (1)数据结构 n:城市顶点个数. m:城市间路线的条数. map[][]:地图对应的带权邻接矩阵. dist[]:记录源点u到某顶点的最短路径长度。 p[]:记录源点到某顶点的最短路径上的该顶点的前一个顶点(前驱).flag[]：flag[i]=true说明顶点i已加入到集合S，否则该顶点属于集合V-S */ const int N=100;//初始化城市个数，可修改 const int INF=1e7;	//无穷大 int map[N][N],dist[N],p[N],n,m; bool flag[N]; //(2)初始化源点u到其他各个顶点的最短路径长度，初始化源点u出边邻接点的前驱为u bool flag[n];//如果flag[i]=true,说明该顶点i已经加入到集合S；否则i属于集合V-S for(int i=1;i&lt;=n;i&#43;&#43;){ dist[i]=map[u][i];	//初始化源点u到其他各个顶点的最短路径长度 flag[i]=false; if(dist[i]==INF) p[i]=-1;	//说明源点u到顶点i无边相连，设置p[i]=-1 else p[i]=u;	//说明源点u到顶点i有边相连，设置p[i]=u } //(3)初始化集合S，令集合S={u},从源点u的最短路径为0 flag[u]=true;//初始化集合S中，只有一个元素：源点u dist[u]=0;	//初始化源点u的最短路径为0，自己到自己的最短路径 //(4)找最小." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f4b619b0ec5438b842e44734e5ac2885/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-09T10:46:06+08:00" />
<meta property="article:modified_time" content="2023-06-09T10:46:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】算法学习·Dijkstra算法详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="Dijkstra%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#Dijkstra%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1" rel="nofollow">Dijkstra算法设计</a></p> 
<p id="Dijkstra%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px;"><a href="#Dijkstra%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B" rel="nofollow">Dijkstra算法简介</a></p> 
<p id="Dijkstra%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#Dijkstra%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">Dijkstra算法的基本思想</a></p> 
<p id="Dijkstra%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#Dijkstra%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5" rel="nofollow">Dijkstra贪心策略</a></p> 
<p id="%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3-toc" style="margin-left:80px;"><a href="#%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3" rel="nofollow">完美图解</a></p> 
<p id="%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3-toc" style="margin-left:80px;"><a href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3" rel="nofollow">伪代码详解</a></p> 
<p id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">完整代码</a></p> 
<p id="%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-toc" style="margin-left:80px;"><a href="#%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95" rel="nofollow">算法解析及优化拓展</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%E2%80%8B%E7%BC%96%E8%BE%91%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%E2%80%8B%E7%BC%96%E8%BE%91%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">​使用优先队列的完整代码</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="Dijkstra%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1">Dijkstra算法设计</h3> 
<h4 id="Dijkstra%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B"><a name="t2"></a><a id="Dijkstra_3"></a>Dijkstra算法简介</h4> 
<p>        Dijkstra算法是解决**单源最短路径**问题的**贪心算法**<br>         它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径直到求出从源点到其他各个顶点的最短路径。</p> 
<h4 id="Dijkstra%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">Dijkstra算法的基本思想</h4> 
<p>        首先假定源点为u，顶点集合V被划分为两部分：集合 S 和 V-S。    初始时S中仅含有源点u，其中S中的顶点到源点的最短路径已经确定。<br>         集合S 和V-S中所包含的顶点到源点的最短路径的长度待定，称从源点出发只经过S中的点到达V-S中的点的路径为特殊路径，并用dist[]记录当前每个顶点对应的最短特殊路径长度。</p> 
<h4 id="Dijkstra%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5">Dijkstra贪心策略</h4> 
<p>        选择特殊路径长度最短的路径，将其连接的V-S中的顶点加入到集合S中，同时更新数组dist[]。一旦S包含了所有顶点，dist[]就是从源到所有其他顶点的最短路径长度。</p> 
<ul><li>（1）数据结构。 设置地图的带权邻接矩阵为map[][]，即如果从源点u到顶点i有边，就令map[u][i]=&lt;u,i&gt;的权值，否则map[u][i]=∞；采用一维数组dist[i]来记录从源点到i顶点的最短路径长度：采用一维数组p[i]来记录最短路径上i顶点的前驱。</li><li>（2）初始化。令集合S={u}，对于集合V-S中的所有顶点x，初始化dist[i]=map[u][i],如果源点u到顶点i有边相连，初始化p[i]=u(i的前驱是u),否则p[i]=-1</li><li>（3）找最小。在集合V-S中依照贪心策略来寻找使得dist[j]具有最小值的顶点t,即dist[t]=min，则顶点t就是集合V-S中距离源点u最近的顶点。</li><li>（4）加入S战队。将顶点t加入集合S，同时更新V-S</li><li>（5）判结束。如果集合V-S为空，算法结束，否则转6</li><li>（6）借东风。在（3）中已近找到了源点到t的最短路径，那么对集合V-S中所有与顶点t相邻的顶点j，都可以借助t走捷径。如果dist[j]&gt;dist[t]+map[t][j],则dist[j]=dist[t]+map[t][j]，记录顶点j的前驱为t，p[j]=t，转（3）。</li></ul> 
<p>        我自己在这里理解就是，从u找到与它最近的点t，在从t找到与它最近的点j，在....按照这样持续下去，直到最后一个点 这里我再通俗的解释下这个借东风的意思。源点为1，如果我们找到了距离源点最近的点2，且点2与3,4相连。这样，我们如果要倒3,4有两种方法：</p> 
<ul><li>                1-&gt;2-&gt;3(4)</li><li>                1-&gt;3(4)</li></ul> 
<p>        这里我们就要判断是从1直接到3(4)快，还是经过2后快。假设&lt;1,2&gt;=2 / &lt;2,3&gt;=3 / &lt;1,3&gt;=4，根据上面的数据，我们第一次找最小找到的是2结点，如果我们直接把2替换掉1当做源点继续找下一个最近的点，这种方法是错的。</p> 
<p>        因为可以看出1-&gt;3只用4，而过2的话要用5。</p> 
<h4 id="%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3">完美图解</h4> 
<p>这里我就直接放图片了，书里的图不好画。但主要的是自己按照其流程过一遍，在草稿纸上自己画一遍。</p> 
<p><img alt="" src="https://images2.imgbox.com/8e/ee/scprs6ak_o.jpg"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/ef/66/61HRMiE7_o.jpg"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/ed/96/5wWXWQIg_o.jpg"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/9d/97/6xG3UdQw_o.jpg"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/c2/a5/dfdyi2KV_o.jpg">     </p> 
<h4 id="%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3">伪代码详解</h4> 
<p>跟着图解大致了解了一遍接下来就要上代码了，放心，代码不是一个完整的几十行的代码，全部按步骤划分好了的，这里方便大家粘贴。</p> 
<pre><code class="language-cpp">/*
(1)数据结构
	n:城市顶点个数. m:城市间路线的条数. map[][]:地图对应的带权邻接矩阵. dist[]:记录源点u到某顶点的最短路径长度。
	p[]:记录源点到某顶点的最短路径上的该顶点的前一个顶点(前驱).flag[]：flag[i]=true说明顶点i已加入到集合S，否则该顶点属于集合V-S
*/
	const int N=100;//初始化城市个数，可修改
	const int INF=1e7;	//无穷大
	int map[N][N],dist[N],p[N],n,m;
	bool flag[N];

//(2)初始化源点u到其他各个顶点的最短路径长度，初始化源点u出边邻接点的前驱为u
	bool flag[n];//如果flag[i]=true,说明该顶点i已经加入到集合S；否则i属于集合V-S
	for(int i=1;i&lt;=n;i++){
		dist[i]=map[u][i];	//初始化源点u到其他各个顶点的最短路径长度
		flag[i]=false;
		if(dist[i]==INF)
			p[i]=-1;	//说明源点u到顶点i无边相连，设置p[i]=-1
		else
			p[i]=u;	//说明源点u到顶点i有边相连，设置p[i]=u
	}
//(3)初始化集合S，令集合S={u},从源点u的最短路径为0
	flag[u]=true;//初始化集合S中，只有一个元素：源点u
	dist[u]=0;	//初始化源点u的最短路径为0，自己到自己的最短路径

//(4)找最小.在集合V-S中寻找距离源点u最近的顶点t,若找不到，则跳出循环;否则，将t加入集合S。
	int temp=INF,t=u;
	for(int j=1;j&lt;=n;j++){//在集合V-S中寻找距离源点u最近的顶点t
		if(!flag[j] &amp;&amp; dist[j]&lt;temp){
			t=j;	//记录距离源点u最近的顶点
			temp=dist[j];
		}
	}
	if(t==u) return ;	//找不到t跳出循环
	flag[t]=true;	//否则，将t加入集合S
	
//(5)借东风。考察集合V-S中源点u到t的邻接点j的距离，如果源点u经过t到达j的路径更短，
//	则更新dist[j]=dist[t]+map[t][j],即松弛操作，并记录j的前驱为t;
	for(int j=1;j&lt;=n;j++){//更新集合V-S中与t邻接的顶点到u的距离
		if(!flag[j] &amp;&amp; map[t][j]&lt;INF){//！flag[j]表示j在v-s集合中，map[t][j]&lt;INF表示t与j邻接
			if(dist[j]&gt;(dist[t]+map[t][j])){//经过t到达j的路径更短
				dist[j]=dist[t]+map[t][j];
				p[j]=t;	//记录j的前驱为t
			}
		}
	}	
//重复(4)~(5),知道源点u到所有顶点的最短路径被找到
</code></pre> 
<h4 id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">完整代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=100;	//城市个数可修改
const int INF=1e7;	//初始化无穷大为.......
int map[N][N],dist[N],p[N],n,m;	//n为城市个数，m为城市间路线的条数
bool flag[N];	//如果flag[i]=true,说明该顶点i已经加入到集合S；否则i属于集合V-S

void Dijkstra(int u){
	for(int i=1;i&lt;=n;i++){//********&gt;&gt;&gt;--1--&lt;&lt;&lt;******//
		dist[i]=map[u][i];	//初始化源点u到其他各个顶点的最短路径长度
		flag[i]=false;
		if(dist[i]==INF)
			p[i]=-1;	//说明源点u到顶点i无边相连，设置p[i]=-1
		else
			p[i]=u;	//说明源点u到顶点i有边相连，设置p[i]=u
	}
	flag[u]=true;//初始化集合S中，只有一个元素：源点u
	dist[u]=0;	//初始化源点u的最短路径为0，自己到自己的最短路径
	for(int i=1;i&lt;=n;i++){//********&gt;&gt;&gt;--2--&lt;&lt;&lt;******//
		int temp=INF,t=u;
		for(int j=1;j&lt;=n;j++){//&gt;&gt;--3--&lt;&lt;在集合V-S中寻找距离源点u最近的顶点t
			if(!flag[j] &amp;&amp; dist[j]&lt;temp){
				t=j;	//记录距离源点u最近的顶点
				temp=dist[j];
			}
		}
		if(t==u) return ;	//找不到t跳出循环
		flag[t]=true;	//否则，将t加入集合S
		for(int j=1;j&lt;=n;j++){//&gt;&gt;--4--&lt;&lt;更新集合V-S中与t邻接的顶点到u的距离
			if(!flag[j] &amp;&amp; map[t][j]&lt;INF){//！flag[j]表示j在v-s集合中，map[t][j]&lt;INF表示t与j邻接
				if(dist[j]&gt;(dist[t]+map[t][j])){//经过t到达j的路径更短
					dist[j]=dist[t]+map[t][j];
					p[j]=t;	//记录j的前驱为t
				}
			}
		}	
	}	
}

int main(){
		int u, v, w, st;
	system("color 0d");
	cout &lt;&lt; "请输入城市的个数：" &lt;&lt; endl;
	cin &gt;&gt; n;
	cout &lt;&lt; "请输入城市之间的路线个数" &lt;&lt; endl;
	cin &gt;&gt; m;
	cout &lt;&lt; "请输入城市之间的路线以及距离" &lt;&lt; endl;
	for(int i=1;i&lt;=n;i++)//初始化图的邻接矩阵
		for (int j = 1; j &lt;= n; j++)
		{
			map[i][j] = INF;//初始化邻接矩阵为无穷大
		}
	while (m--)
	{
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		map[u][v] = min(map[u][v], w);	//邻接矩阵存储，保留最小的距离
	}
	cout &lt;&lt; "请输入小明所在的位置：" &lt;&lt; endl;
	cin &gt;&gt; st;
	Dijkstra(st);
	cout &lt;&lt; "小明所在的位置：" &lt;&lt; st &lt;&lt; endl;
	for (int i = 1; i &lt;= n; i++)
	{
		cout &lt;&lt; "小明：" &lt;&lt; st &lt;&lt; " - " &lt;&lt; "要去的位置：" &lt;&lt; i &lt;&lt; endl;
		if (dist[i] == INF)
			cout &lt;&lt; "sorry,无路可达" &lt;&lt; endl;
		else
			cout &lt;&lt; "最短距离为：" &lt;&lt; dist[i] &lt;&lt; endl; 
	}
	return 0;
}
</code></pre> 
<pre><code class="language-cpp">输入
请输入城市的个数：
5
请输入城市之间的路线个数
11
请输入城市之间的路线以及距离
1 5 2
5 1 8
1 2 16
2 1 29
5 2 32
2 4 13
4 2 27
1 3 15
3 1 21
3 4 7
4 3 19
请输入小明所在的位置：
5

输出
小明所在的位置：5
小明：5 - 要去的位置：1 最短距离为：8
小明：5 - 要去的位置：2 最短距离为：24
小明：5 - 要去的位置：3 最短距离为：23
小明：5 - 要去的位置：4 最短距离为：30
小明：5 - 要去的位置：5 最短距离为：0
</code></pre> 
<pre><code class="language-cpp">因为我们在程序中使用了p[]数组记录了最短路径上每一个结点的前驱，所以我们可以增加一段程序逆向该最短路径上的城市序列。
void findpath(int u)
{
	int x;
	stack&lt;int&gt;s;
	cout &lt;&lt; "源点为：" &lt;&lt; u &lt;&lt; endl;
	for (int i = 1; i &lt;= n; i++)
	{
		x = p[i];
		while (x != -1)
		{
			s.push(x);
			x = p[x];
		}
		cout &lt;&lt; "源点到其他各顶点的最短路径为：";
		while (!s.empty())
		{
			cout &lt;&lt; s.top() &lt;&lt; "--";
			s.pop();
		}
		cout &lt;&lt; i &lt;&lt; ";最短距离为：" &lt;&lt; dist[i] &lt;&lt; endl;
	}
}
只需要在主函数末尾调用即可

结果为：
源点为：5
源点到其他各顶点的最短路径为：5--1;最短距离为：8
源点到其他各顶点的最短路径为：5--1--2;最短距离为：24
源点到其他各顶点的最短路径为：5--1--3;最短距离为：23
源点到其他各顶点的最短路径为：5--1--3--4;最短距离为：30
源点到其他各顶点的最短路径为：5;最短距离为：0
</code></pre> 
<h4 id="%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95">算法解析及优化拓展</h4> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91%E2%80%8B%E7%BC%96%E8%BE%91%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/88/8b/tmnqZmqd_o.jpg"><br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/f2/8d/gIdMAK4r_o.jpg"></h4> 
<h4>使用优先队列的完整代码</h4> 
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 100;//城市的个数可修改
const int INF = 1e7;//初始化无穷大为10000000
int map[N][N], dist[N], p[N], n, m;//n为城市的个数，m为城市间路线的条数
int flag[N];	//	如果flag[i]==true,说明顶点i已经加入到集合S；否则顶点i属于集合V-S

struct Node {
	int u, step;
	Node() {};
	Node(int a, int sp)
	{
		u = a, step = sp;
	}
	bool operator&lt;(const Node&amp; a)const {//重载 &lt;
		return step &gt; a.step;
	}
};

void Dijkstra(int st)
{
	priority_queue&lt;Node&gt;Q;//优先队列优化
	Q.push(Node(st, 0));
	memset(flag, 0, sizeof(flag));//初始化flag数组为0
	for (int i = 1; i &lt;= n; ++i)
		dist[i] = INF;//初始化所有距离为无穷大
	dist[st] = 0;
	while (!Q.empty())
	{
		Node it = Q.top();//优先队列列头元素为最小值
		Q.pop();
		int t = it.u;
		if (flag[t])//说明已经找到了最短距离，该节点是队列里面的重复元素
			continue;
		flag[t] = 1;
		for (int i = 1; i &lt;= n; i++)
		{
			if(!flag[i] &amp;&amp; map[t][i]&lt;INF)//判断与当前点有关系的点，并且自己不能到自己
				if (dist[i] &gt; dist[t] + map[t][i])
				{
					//求距离当前点的每个点的最短距离，进行松弛操作
					dist[i] = dist[t] + map[t][i];
					Q.push(Node(i, dist[i]));//把更新后的最短距离压入队列中，注意：里面有重复元素
				}
		}
	}

}

int main()
{
	int u, v, w, st;
	system("color 0d");
	cout &lt;&lt; "请输入城市的个数：" &lt;&lt; endl;
	cin &gt;&gt; n;
	cout &lt;&lt; "请输入城市之间的路线个数" &lt;&lt; endl;
	cin &gt;&gt; m;
	cout &lt;&lt; "请输入城市之间的路线以及距离" &lt;&lt; endl;
	for (int i = 1; i &lt;= n; i++)//初始化图的邻接矩阵
		for (int j = 1; j &lt;= n; j++)
		{
			map[i][j] = INF;//初始化邻接矩阵为无穷大
		}
	while (m--)
	{
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		map[u][v] = min(map[u][v], w);	//邻接矩阵存储，保留最小的距离
	}
	cout &lt;&lt; "请输入小明所在的位置：" &lt;&lt; endl;
	cin &gt;&gt; st;
	Dijkstra(st);
	cout &lt;&lt; "小明所在的位置：" &lt;&lt; st &lt;&lt; endl;
	for (int i = 1; i &lt;= n; i++)
	{
		cout &lt;&lt; "小明：" &lt;&lt; st &lt;&lt; " ---&gt; " &lt;&lt; "要去的位置：" &lt;&lt; i;
		if (dist[i] == INF)
			cout &lt;&lt; "sorry,无路可达" &lt;&lt; endl;
		else
			cout &lt;&lt; " 最短距离为：" &lt;&lt; dist[i] &lt;&lt; endl;
	}
	return 0;
}

/*
请输入城市的个数：
5
请输入城市之间的路线个数
11
请输入城市之间的路线以及距离
1 5 2
5 1 8
1 2 16
2 1 29
5 2 32
2 4 13
4 2 27
1 3 15
3 1 21
3 4 7
4 3 19
请输入小明所在的位置：
5
小明所在的位置：5
小明：5 ---&gt; 要去的位置：1 最短距离为：8
小明：5 ---&gt; 要去的位置：2 最短距离为：24
小明：5 ---&gt; 要去的位置：3 最短距离为：23
小明：5 ---&gt; 要去的位置：4 最短距离为：30
小明：5 ---&gt; 要去的位置：5 最短距离为：0
*/
</code></pre> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/d1/a3/zhB0SQiT_o.jpg"></p> 
<h2><a name="t10"></a><a id="_359"></a></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/57c2287fa0b2e7ae4e1a169f6092926e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Postgre内建触发器函数suppress_redundant_updates_trigger</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e50e2aec52869d0e17ab0bcae23268d6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python modbus RTU</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>