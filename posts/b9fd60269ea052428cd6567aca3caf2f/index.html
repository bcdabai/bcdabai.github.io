<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Memcache是什么 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Memcache是什么" />
<meta property="og:description" content="Memcache是什么
Memcache是danga.com的一个项目，最早是为 LiveJournal 服务的，目前全世界不少人使用这个缓存项目来构建自己大负载的网站，来分担数据库的压力。
它可以应对任意多个连接，使用非阻塞的网络IO。由于它的工作机制是在内存中开辟一块空间，然后建立一个HashTable，Memcached自管理这些HashTable。
Memcache官方网站：http://www.danga.com/memcached，更多详细的信息可以来这里了解 为什么会有Memcache和memcached两种名称？
其实Memcache是这个项目的名称，而memcached是它服务器端的主程序文件名，知道我的意思了把~~~~。一个是项目名称，一个是主程序文件名，在网上看到了很多人不明白，于是混用了。
Memcache的安装
分为两个过程：memcache服务器端的安装和memcached客户端的安装。
所谓服务器端的安装就是在服务器（一般都是linux系统）上安装Memcache实现数据的存储
所谓客户端的安装就是指php（或者其他程序，Memcache还有其他不错的api接口提供）去使用服务器端的Memcache提供的函数，需要php添加扩展。
具体的配置大家可以参考：
Linux下的Memcache安装：http://www.ccvita.com/index.php/257.html
Windows下的Memcache安装：http://www.ccvita.com/index.php/258.html
Memcache基础教程：http://www.ccvita.com/index.php/259.html
PHP的Memcache
&lt; ?php //连接 $mem = new Memcache; $mem-&gt;connect(&#34;192.168.0.200&#34;, 12000); //保存数据 $mem-&gt;set(&#39;key1&#39;, &#39;This is first value&#39;, 0, 60); $val = $mem-&gt;get(&#39;key1&#39;); echo &#34;Get key1 value: &#34; . $val .&#34;&lt;br /&gt;&#34;; //替换数据 $mem-&gt;replace(&#39;key1&#39;, &#39;This is replace value&#39;, 0, 60); $val = $mem-&gt;get(&#39;key1&#39;); echo &#34;Get key1 value: &#34; . $val . &#34;&lt;br /&gt;&#34;; //保存数组 $arr = array(&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;, &#39;ddd&#39;); $mem-&gt;set(&#39;key2&#39;, $arr, 0, 60); $val2 = $mem-&gt;get(&#39;key2&#39;); echo &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b9fd60269ea052428cd6567aca3caf2f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2008-01-31T09:17:00+08:00" />
<meta property="article:modified_time" content="2008-01-31T09:17:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Memcache是什么</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                      
<p><strong>Memcache是什么</strong><br>Memcache是danga.com的一个项目，最早是为 LiveJournal 服务的，目前全世界不少人使用这个缓存项目来构建自己大负载的网站，来分担数据库的压力。<br>它可以应对任意多个连接，使用非阻塞的网络IO。由于它的工作机制是在内存中开辟一块空间，然后建立一个HashTable，Memcached自管理这些HashTable。<br>Memcache官方网站：http://www.danga.com/memcached，更多详细的信息可以来这里了解 <img class="wp-smiley" alt=":)" src="https://images2.imgbox.com/8c/9b/bx07b9xR_o.gif"> </p> 
<p>为什么会有Memcache和memcached两种名称？<br>其实Memcache是这个项目的名称，而memcached是它服务器端的主程序文件名，知道我的意思了把~~~~。一个是项目名称，一个是主程序文件名，在网上看到了很多人不明白，于是混用了。</p> 
<p><strong>Memcache的安装</strong><br>分为两个过程：memcache服务器端的安装和memcached客户端的安装。<br>所谓服务器端的安装就是在服务器（一般都是linux系统）上安装Memcache实现数据的存储<br>所谓客户端的安装就是指php（或者其他程序，Memcache还有其他不错的api接口提供）去使用服务器端的Memcache提供的函数，需要php添加扩展。</p> 
<p>具体的配置大家可以参考：<br><a href="http://www.ccvita.com/index.php/257.html" rel="nofollow">Linux下的Memcache安装</a>：http://www.ccvita.com/index.php/257.html<br><a href="http://www.ccvita.com/index.php/258.html" rel="nofollow">Windows下的Memcache安装</a>：http://www.ccvita.com/index.php/258.html<br><a href="http://www.ccvita.com/index.php/259.html" rel="nofollow">Memcache基础教程</a>：http://www.ccvita.com/index.php/259.html</p> 
<p><span id="more-259"></span><br><strong>PHP的Memcache</strong></p> 
<div class="hl-surround"> 
 <div class="hl-main">
   &lt; ?php 
  <br>//连接 
  <br>$mem = new Memcache; 
  <br>$mem-&gt;connect("192.168.0.200", 12000); 
  <br> 
  <br>//保存数据 
  <br>$mem-&gt;set('key1', 'This is first value', 0, 60); 
  <br>$val = $mem-&gt;get('key1'); 
  <br>echo "Get key1 value: " . $val ."&lt;br /&gt;"; 
  <br> 
  <br>//替换数据 
  <br>$mem-&gt;replace('key1', 'This is replace value', 0, 60); 
  <br>$val = $mem-&gt;get('key1'); 
  <br>echo "Get key1 value: " . $val . "&lt;br /&gt;"; 
  <br> 
  <br>//保存数组 
  <br>$arr = array('aaa', 'bbb', 'ccc', 'ddd'); 
  <br>$mem-&gt;set('key2', $arr, 0, 60); 
  <br>$val2 = $mem-&gt;get('key2'); 
  <br>echo "Get key2 value: "; 
  <br>print_r($val2); 
  <br>echo "&lt;br /&gt;"; 
  <br> 
  <br>//删除数据 
  <br>$mem-&gt;delete('key1'); 
  <br>$val = $mem-&gt;get('key1'); 
  <br>echo "Get key1 value: " . $val . "&lt;br /&gt;"; 
  <br> 
  <br>//清除所有数据 
  <br>$mem-&gt;flush(); 
  <br>$val2 = $mem-&gt;get('key2'); 
  <br>echo "Get key2 value: "; 
  <br>print_r($val2); 
  <br>echo "&lt;br /&gt;"; 
  <br> 
  <br>//关闭连接 
  <br>$mem-&gt;close(); 
  <br>?&gt; 
 </div> 
</div> 
<p>如果正常的话，浏览器将输出：<br>Get key1 value: This is first value<br>Get key1 value: This is replace value<br>Get key2 value: Array ( [0] =&gt; aaa [1] =&gt; bbb [2] =&gt; ccc [3] =&gt; ddd )<br>Get key1 value:<br>Get key2 value: </p> 
<p><strong>程序代码分析</strong></p> 
<p>初始化一个Memcache的对象：<br><font color="#0000ff"></font><font color="#993300">$mem</font> = new <font color="#000000">Memcache</font>;</p> 
<p>连接到我们的Memcache服务器端，第一个参数是服务器的IP地址，也可以是主机名，第二个参数是Memcache的开放的端口：<br><font color="#0000ff"></font><font color="#993300">$mem-&gt;</font>connect(<font color="#339966">"192.168.0.200"</font>, <font color="#ff0000">12000</font>);</p> 
<p>保存一个数据到Memcache服务器上，第一个参数是数据的key，用来定位一个数据，第二个参数是需要保存的数据内容，这里是一个字符串，第三个参数是一个标记，一般设置为0或者MEMCACHE_COMPRESSED就行了，第四个参数是数据的有效期，就是说数据在这个时间内是有效的，如果过去这个时间，那么会被Memcache服务器端清除掉这个数据，单位是秒，如果设置为0，则是永远有效，我们这里设置了60，就是一分钟有效时间：<br><font color="#0000ff"></font><font color="#993300">$mem</font>-&gt;set(<font color="#339966">‘key1</font>‘, <font color="#339966">‘This is first value’</font>, <font color="#ff0000">0</font>, <font color="#ff0000">60</font>);</p> 
<p>从Memcache服务器端获取一条数据，它只有一个参数，就是需要获取数据的key，我们这里是上一步设置的key1，现在获取这个数据后输出输出：<br><font color="#0000ff"></font><font color="#993300">$val</font> = <font color="#993300">$mem</font>-&gt;get(’<font color="#339966">key1′</font>);<br>echo <font color="#339966">"Get key1 value: "</font> . <font color="#993300">$val;</font></p> 
<p>现在是使用replace方法来替换掉上面key1的值，replace方法的参数跟set是一样的，不过第一个参数key1是必须是要替换数据内容的key，最后输出了：<br><font color="#0000ff"></font><font color="#993300">$mem</font>-&gt;replace(<font color="#339966">‘key1′</font>, <font color="#339966">‘This is replace value’</font>, <font color="#ff0000">0</font>, <font color="#ff0000">60</font>);<br><font color="#993300">$val</font> = <font color="#993300">$mem</font>-&gt;get(<font color="#339966">‘key1′</font>);<br>echo "<font color="#339966">Get key1 value:</font> " . <font color="#993300">$val</font>;</p> 
<p>同样的，Memcache也是可以保存数组的，下面是在Memcache上面保存了一个数组，然后获取回来并输出<br><font color="#0000ff"></font><font color="#993300">$arr</font> = array(<font color="#339966">‘aaa’,</font> <font color="#339966">‘bbb’,</font> <font color="#339966">‘ccc’</font>, <font color="#339966">‘ddd’</font>);<br><font color="#993300">$mem</font>-&gt;set(<font color="#339966">‘key2′</font>, <font color="#ff0000">$arr</font>, <font color="#ff0000">0</font>, <font color="#ff0000">60</font>);<br><font color="#993300">$val2</font> = <font color="#993300">$mem</font>-&gt;get(<font color="#339966">‘key2′</font>);<br>print_r(<font color="#993300">$val2</font>);</p> 
<p>现在删除一个数据，使用delte接口，参数就是一个key，然后就能够把Memcache服务器这个key的数据删除，最后输出的时候没有结果<br><font color="#0000ff">$</font><font color="#993300">mem</font>-&gt;delete(<font color="#339966">‘key1′</font>);<br>$<font color="#993300">val</font> = $<font color="#993300">mem</font>-&gt;get(<font color="#339966">‘key1′</font>);<br>echo "<font color="#339966">Get key1 value:</font> " . $<font color="#993300">val</font> . <font color="#339966">"&lt;br&gt;";</font></p> 
<p>最后我们把所有的保存在Memcache服务器上的数据都清除，会发现数据都没有了，最后输出key2的数据为空，最后关闭连接<br><font color="#0000ff">$</font><font color="#993300">mem</font>-&gt;flush();<br>$<font color="#993300">val2</font> = $<font color="#993300">mem</font>-&gt;get(<font color="#339966">‘key2′</font>);<br>echo "<font color="#339966">Get key2 value:</font> ";<br>print_r(<font color="#993300">$val2</font>);<br>echo <font color="#339966">"&lt;br&gt;";</font></p> 
<p><strong>Memcache的使用</strong><br>使用Memcache的网站一般流量都是比较大的，为了缓解数据库的压力，让Memcache作为一个缓存区域，把部分信息保存在内存中，在前端能够迅速的进行存取。那么一般的焦点就是集中在如何分担数据库压力和进行分布式，毕竟单台Memcache的内存容量的有限的。我这里简单提出我的个人看法，未经实践，权当参考。</p> 
<p><em>分布式应用</em><br>Memcache本来支持分布式，我们客户端稍加改造，更好的支持。我们的key可以适当进行有规律的封装，比如以user为主的网站来说，每个用户都有User ID，那么可以按照固定的ID来进行提取和存取，比如1开头的用户保存在第一台Memcache服务器上，以2开头的用户的数据保存在第二胎Mecache服务器上，存取数据都先按照User ID来进行相应的转换和存取。</p> 
<p>但是这个有缺点，就是需要对User ID进行判断，如果业务不一致，或者其他类型的应用，可能不是那么合适，那么可以根据自己的实际业务来进行考虑，或者去想更合适的方法。</p> 
<p><em>减少数据库压力</em><br>这个算是比较重要的，所有的数据基本上都是保存在数据库当中的，每次频繁的存取数据库，导致数据库性能极具下降，无法同时服务更多的用户，比如MySQL，特别频繁的锁表，那么让Memcache来分担数据库的压力吧。我们需要一种改动比较小，并且能够不会大规模改变前端的方式来进行改变目前的架构。</p> 
<p>我考虑的一种简单方法：<br>后端的数据库操作模块，把所有的Select操作提取出来（update/delete/insert不管），然后把对应的SQL进行相应的hash算法计算得出一个hash数据key（比如MD5或者SHA），然后把这个key去Memcache中查找数据，如果这个数据不存在，说明还没写入到缓存中，那么从数据库把数据提取出来，一个是数组类格式，然后把数据在set到Memcache中，key就是这个SQL的hash值，然后相应的设置一个失效时间，比如一个小时，那么一个小时中的数据都是从缓存中提取的，有效减少数据库的压力。缺点是数据不实时，当数据做了修改以后，无法实时到前端显示，并且还有可能对内存占用比较大，毕竟每次select出来的数据数量可能比较巨大，这个是需要考虑的因素。</p> 
<p><strong>Memcache的安全</strong><br>我们上面的Memcache服务器端都是直接通过客户端连接后直接操作，没有任何的验证过程，这样如果服务器是直接暴露在互联网上的话是比较危险，轻则数据泄露被其他无关人员查看，重则服务器被入侵，因为Mecache是以root权限运行的，况且里面可能存在一些我们未知的bug或者是缓冲区溢出的情况，这些都是我们未知的，所以危险性是可以预见的。为了安全起见，我做两点建议，能够稍微的防止黑客的入侵或者数据的泄露。</p> 
<p><em>内网访问</em><br>最好把两台服务器之间的访问是内网形态的，一般是Web服务器跟Memcache服务器之间。普遍的服务器都是有两块网卡，一块指向互联网，一块指向内网，那么就让Web服务器通过内网的网卡来访问Memcache服务器，我们Memcache的服务器上启动的时候就监听内网的IP地址和端口，内网间的访问能够有效阻止其他非法的访问。<br># memcached -d -m 1024 -u root -l 192.168.0.200 -p 11211 -c 1024 -P /tmp/memcached.pid<br>Memcache服务器端设置监听通过内网的192.168.0.200的ip的11211端口，占用1024MB内存，并且允许最大1024个并发连接</p> 
<p><em>设置防火墙</em><br>防火墙是简单有效的方式，如果却是两台服务器都是挂在网的，并且需要通过外网IP来访问Memcache的话，那么可以考虑使用防火墙或者代理程序来过滤非法访问。<br>一般我们在Linux下可以使用iptables或者FreeBSD下的ipfw来指定一些规则防止一些非法的访问，比如我们可以设置只允许我们的Web服务器来访问我们Memcache服务器，同时阻止其他的访问。<br># iptables -F<br># iptables -P INPUT DROP<br># iptables -A INPUT -p tcp -s 192.168.0.2 –dport 11211 -j ACCEPT<br># iptables -A INPUT -p udp -s 192.168.0.2 –dport 11211 -j ACCEPT<br>上面的iptables规则就是只允许192.168.0.2这台Web服务器对Memcache服务器的访问，能够有效的阻止一些非法访问，相应的也可以增加一些其他的规则来加强安全性，这个可以根据自己的需要来做</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/313bc96c89411d5bca31b7dadd21017c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Spring&#43;Hibernate的通用增删改查的实现方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90849dd9d614b2d9185fc7bf6e2371fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">日本語三級</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>